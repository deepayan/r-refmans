<!DOCTYPE html><html><head><title>Help for package bittermelon</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bittermelon}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bittermelon'><p>bittermelon: Monochrome Bitmap Font Tools</p></a></li>
<li><a href='#+5B.bm_bitmap'><p>Extract or replace parts of a bitmap</p></a></li>
<li><a href='#as_bm_bitmap'><p>Coerce to bitmap glyph objects</p></a></li>
<li><a href='#as_bm_font'><p>Coerce to bitmap font objects</p></a></li>
<li><a href='#as_bm_list'><p>Coerce to bitmap list objects</p></a></li>
<li><a href='#as.matrix.bm_bitmap'><p>Coerce bitmap objects to matrix</p></a></li>
<li><a href='#bm_bitmap'><p>Bitmap object</p></a></li>
<li><a href='#bm_call'><p>Execute a function call on bitmap objects</p></a></li>
<li><a href='#bm_clamp'><p>Clamp bitmap integer values.</p></a></li>
<li><a href='#bm_compose'><p>Compose graphemes in a bitmap list by applying combining marks</p></a></li>
<li><a href='#bm_compress'><p>Compress bitmaps using a &quot;block elements&quot; scheme</p></a></li>
<li><a href='#bm_distort'><p>Resize images via distortion.</p></a></li>
<li><a href='#bm_edit'><p>Edit a bitmap via text editor</p></a></li>
<li><a href='#bm_expand'><p>Expand bitmaps by repeating each row and/or column</p></a></li>
<li><a href='#bm_extend'><p>Extend bitmaps on the sides with extra pixels</p></a></li>
<li><a href='#bm_flip'><p>Flip (reflect) bitmaps</p></a></li>
<li><a href='#bm_font'><p>Bitmap font object</p></a></li>
<li><a href='#bm_lapply'><p>Modify bitmap lists</p></a></li>
<li><a href='#bm_list'><p>Bitmap list object</p></a></li>
<li><a href='#bm_mask'><p>Modify bitmaps via masking with a 'mask' bitmap</p></a></li>
<li><a href='#bm_outline'><p>Compute &quot;outline&quot; bitmap of a bitmap</p></a></li>
<li><a href='#bm_overlay'><p>Merge bitmaps by overlaying one over another</p></a></li>
<li><a href='#bm_pad'><p>Adjust bitmap padding lengths</p></a></li>
<li><a href='#bm_padding_lengths'><p>Compute bitmap padding lengths</p></a></li>
<li><a href='#bm_resize'><p>Resize bitmaps by trimming and/or extending</p></a></li>
<li><a href='#bm_rotate'><p>Rotate bitmaps 0, 90, 180, or 270 degrees</p></a></li>
<li><a href='#bm_shadow'><p>Bitmap shadow, bold, and glow effects</p></a></li>
<li><a href='#bm_shift'><p>Shift elements within bitmaps</p></a></li>
<li><a href='#bm_trim'><p>Trim bitmaps</p></a></li>
<li><a href='#bm_widths'><p>Widths or heights of bitmaps</p></a></li>
<li><a href='#c.bm_bitmap'><p>Combine bitmap objects</p></a></li>
<li><a href='#cbind.bm_bitmap'><p>Combine bitmaps by rows or columns</p></a></li>
<li><a href='#hex2ucp'><p>Get Unicode code points</p></a></li>
<li><a href='#is_bm_bitmap'><p>Test if the object is a bitmap glyph object</p></a></li>
<li><a href='#is_bm_font'><p>Test if the object is a bitmap font object</p></a></li>
<li><a href='#is_bm_list'><p>Test if the object is a bitmap glyph list object</p></a></li>
<li><a href='#Ops.bm_bitmap'><p>S3 Ops group generic methods for bitmap objects</p></a></li>
<li><a href='#plot.bm_bitmap'><p>Plot bitmap object</p></a></li>
<li><a href='#print.bm_bitmap'><p>Print bitmap objects</p></a></li>
<li><a href='#read_hex'><p>Read and write hex bitmap font files</p></a></li>
<li><a href='#read_monobit'><p>Read and write bitmap font files using monobit</p></a></li>
<li><a href='#read_yaff'><p>Read and write yaff bitmap font files</p></a></li>
<li><a href='#Summary.bm_list'><p>max, min, and range for bitmap objects</p></a></li>
<li><a href='#ucp2label'><p>Other Unicode utilities</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Monochrome Bitmap Font Tools</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions for creating and modifying bitmaps with special emphasis on bitmap fonts and their glyphs.  Provides native read/write support for the 'hex' and 'yaff' bitmap font formats and if 'Python' is installed can also read/write several more bitmap font formats using an embedded version of 'monobit'.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://trevorldavis.com/R/bittermelon/">https://trevorldavis.com/R/bittermelon/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/trevorld/bittermelon/issues">https://github.com/trevorld/bittermelon/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Imports:</td>
<td>findpython, grDevices, grid, png, rappdirs, Unicode, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>crayon, git2r, ragg, testthat, vdiffr, withr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-14 23:34:44 UTC; trevor</td>
</tr>
<tr>
<td>Author:</td>
<td>Trevor L Davis <a href="https://orcid.org/0000-0001-6341-4639"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Rob Hagemans [cph] (Author of included 'monobit' library),
  Frederic Cambus [cph] (Author of included 'Spleen' font)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Trevor L Davis &lt;trevor.l.davis@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-15 03:20:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='bittermelon'>bittermelon: Monochrome Bitmap Font Tools</h2><span id='topic+bittermelon'></span><span id='topic+bittermelon-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Provides functions for creating and modifying bitmaps with special emphasis on bitmap fonts and their glyphs. Provides native read/write support for the 'hex' and 'yaff' bitmap font formats and if 'Python' is installed can also read/write several more bitmap font formats using an embedded version of 'monobit'.
</p>


<h3>Package options</h3>

<p>The following <code>bittermelon</code> option may be set globally via <code><a href="base.html#topic+options">base::options()</a></code>:
</p>

<dl>
<dt>bittermelon.px</dt><dd><p>Set new default <code>px</code> argument value for
<code><a href="#topic+format.bm_bitmap">format.bm_bitmap()</a></code> and <code><a href="#topic+print.bm_bitmap">print.bm_bitmap()</a></code>.
If unset both functions default to <code>px_unicode</code> but
some may prefer <code>px_ascii</code> which is an ASCII alternative.</p>
</dd>
<dt>bittermelon.fg</dt><dd><p>Set new default <code>fg</code> argument value for
<code><a href="#topic+format.bm_bitmap">format.bm_bitmap()</a></code> and <code><a href="#topic+print.bm_bitmap">print.bm_bitmap()</a></code>.</p>
</dd>
<dt>bittermelon.bg</dt><dd><p>Set new default <code>bg</code> argument value for
<code><a href="#topic+format.bm_bitmap">format.bm_bitmap()</a></code> and <code><a href="#topic+print.bm_bitmap">print.bm_bitmap()</a></code>.</p>
</dd>
<dt>bittermelon.compress</dt><dd><p>Set new default <code>compress</code> argument value for
<code><a href="#topic+format.bm_bitmap">format.bm_bitmap()</a></code> and <code><a href="#topic+print.bm_bitmap">print.bm_bitmap()</a></code>.</p>
</dd>
<dt>bittermelon.monobit_path</dt><dd><p>Set new default <code>monobit_path</code> argument value
for <code><a href="#topic+read_monobit">read_monobit()</a></code> and <code><a href="#topic+write_monobit">write_monobit()</a></code>.</p>
</dd>
</dl>

<p>The following <code>findpython</code> option may also be of interest:
</p>

<dl>
<dt>python_cmd</dt><dd><p>Explicitly set path to python binary to use with <code><a href="#topic+read_monobit">read_monobit()</a></code>
or <code><a href="#topic+write_monobit">write_monobit()</a></code>.  This is actually the appropriate global option
for <code><a href="findpython.html#topic+find_python_cmd">findpython::find_python_cmd()</a></code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Trevor L Davis <a href="mailto:trevor.l.davis@gmail.com">trevor.l.davis@gmail.com</a> (<a href="https://orcid.org/0000-0001-6341-4639">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Rob Hagemans (Author of included 'monobit' library) [copyright holder]
</p>
</li>
<li><p> Frederic Cambus (Author of included 'Spleen' font) [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://trevorldavis.com/R/bittermelon/">https://trevorldavis.com/R/bittermelon/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/trevorld/bittermelon/issues">https://github.com/trevorld/bittermelon/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+5B.bm_bitmap'>Extract or replace parts of a bitmap</h2><span id='topic++5B.bm_bitmap'></span><span id='topic++5B+3C-.bm_bitmap'></span>

<h3>Description</h3>

<p><code style="white-space: pre;">&#8288;[.bm_bitmap()&#8288;</code> is defined so that it returns a <code>bm_bitmap()</code> object
(if the value is a matrix) and <code style="white-space: pre;">&#8288;[&lt;-.bm_bitmap()&#8288;</code> casts
any replacement values as integers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bm_bitmap'
x[i, j, ..., drop = TRUE]

## S3 replacement method for class 'bm_bitmap'
x[i, j, ...] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.bm_bitmap_+3A_x">x</code></td>
<td>
<p><code><a href="#topic+bm_bitmap">bm_bitmap()</a></code> object</p>
</td></tr>
<tr><td><code id="+2B5B.bm_bitmap_+3A_i">i</code>, <code id="+2B5B.bm_bitmap_+3A_j">j</code></td>
<td>
<p>indices specifying elements to extract or replace.
See [base::<code style="white-space: pre;">&#8288;[()&#8288;</code>] for more information.</p>
</td></tr>
<tr><td><code id="+2B5B.bm_bitmap_+3A_...">...</code></td>
<td>
<p>Passed to [base::<code style="white-space: pre;">&#8288;[()&#8288;</code>].</p>
</td></tr>
<tr><td><code id="+2B5B.bm_bitmap_+3A_drop">drop</code></td>
<td>
<p>If <code>TRUE</code> the result is coerced to a integer vector.</p>
</td></tr>
<tr><td><code id="+2B5B.bm_bitmap_+3A_value">value</code></td>
<td>
<p>Replacement value</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;[.bm_bitmap()&#8288;</code> returns a <code>bm_bitmap()</code> object if the value is a matrix  and/or <code>drop</code> is <code>FALSE</code>
otherwise it returns an integer matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> font_file &lt;- system.file("fonts/spleen/spleen-8x16.hex.gz", package = "bittermelon")
 font &lt;- read_hex(font_file)
 capital_r &lt;- font[[str2ucp("R")]]
 print(capital_r[4:14,2:8], px = px_ascii)
 capital_r[11:13,3:5] &lt;- 2L
 print(capital_r, px = px_ascii)
</code></pre>

<hr>
<h2 id='as_bm_bitmap'>Coerce to bitmap glyph objects</h2><span id='topic+as_bm_bitmap'></span><span id='topic+as_bm_bitmap.matrix'></span><span id='topic+as_bm_bitmap.default'></span><span id='topic+as_bm_bitmap.character'></span><span id='topic+as_bm_bitmap.grob'></span>

<h3>Description</h3>

<p><code>as_bm_bitmap()</code> turns an existing object into a <code>bm_bitmap()</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_bm_bitmap(x, ...)

## S3 method for class 'matrix'
as_bm_bitmap(x, ...)

## Default S3 method:
as_bm_bitmap(x, ...)

## S3 method for class 'character'
as_bm_bitmap(
  x,
  ...,
  direction = "left-to-right, top-to-bottom",
  font = bm_font(),
  hjust = "left",
  vjust = "top",
  compose = TRUE,
  pua_combining = character(0)
)

## S3 method for class 'grob'
as_bm_bitmap(
  x,
  ...,
  width = 8L,
  height = 16L,
  png_device = NULL,
  threshold = 0.25
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_bm_bitmap_+3A_x">x</code></td>
<td>
<p>An object that can reasonably be coerced to a <code>bm_bitmap()</code> object.</p>
</td></tr>
<tr><td><code id="as_bm_bitmap_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="as_bm_bitmap_+3A_direction">direction</code></td>
<td>
<p>For purely horizontal binding either &quot;left-to-right&quot; (default) or its aliases &quot;ltr&quot; and &quot;lr&quot;
OR &quot;right-to-left&quot; or its aliases &quot;rtl&quot; and &quot;rl&quot;.
For purley vertical binding either &quot;top-to-bottom&quot; (default) or its aliases &quot;ttb&quot; and &quot;tb&quot;
OR &quot;bottom-to-top&quot; or its aliases &quot;btt&quot; and &quot;bt&quot;.
For character vectors of length greater than one: for first horizontal binding within
values in the vector
and then vertical binding across values in the vector &quot;left-to-right, top-to-bottom&quot; (default)
or its aliases &quot;lrtb&quot; and &quot;lr-tb&quot;; &quot;left-to-right, bottom-to-top&quot; or its aliases &quot;lrbt&quot; and &quot;lr-bt&quot;;
&quot;right-to-left, top-to-bottom&quot; or its aliases &quot;rltb&quot; and &quot;rl-tb&quot;; or
&quot;right-to-left, bottom-to-top&quot; or its aliases &quot;rlbt&quot; and &quot;rl-bt&quot;.
For first vertical binding within values in the vector and then horizontal binding across values
&quot;top-to-bottom, left-to-right&quot; or its aliases &quot;tblr&quot; and &quot;tb-lr&quot;;
&quot;top-to-bottom, right-to-left&quot; or its aliases &quot;tbrl&quot; and &quot;tb-rl&quot;;
&quot;bottom-to-top, left-to-right&quot; or its aliases &quot;btlr&quot; and &quot;bt-lr&quot;; or
&quot;bottom-to-top, right-to-left&quot; or its aliases &quot;btrl&quot; and &quot;bt-rl&quot;.
The <code>direction</code> argument is not case-sensitive.</p>
</td></tr>
<tr><td><code id="as_bm_bitmap_+3A_font">font</code></td>
<td>
<p>A <code><a href="#topic+bm_font">bm_font()</a></code> object that contains all the characters within <code>x</code>.</p>
</td></tr>
<tr><td><code id="as_bm_bitmap_+3A_hjust">hjust</code></td>
<td>
<p>Used by <code><a href="#topic+bm_extend">bm_extend()</a></code> if bitmap widths are different.</p>
</td></tr>
<tr><td><code id="as_bm_bitmap_+3A_vjust">vjust</code></td>
<td>
<p>Used by <code><a href="#topic+bm_extend">bm_extend()</a></code> if bitmap heights are different.</p>
</td></tr>
<tr><td><code id="as_bm_bitmap_+3A_compose">compose</code></td>
<td>
<p>Compose graphemes using <code><a href="#topic+bm_compose">bm_compose()</a></code>.</p>
</td></tr>
<tr><td><code id="as_bm_bitmap_+3A_pua_combining">pua_combining</code></td>
<td>
<p>Passed to <code><a href="#topic+bm_compose">bm_compose()</a></code>.</p>
</td></tr>
<tr><td><code id="as_bm_bitmap_+3A_width">width</code></td>
<td>
<p>Desired width of bitmap</p>
</td></tr>
<tr><td><code id="as_bm_bitmap_+3A_height">height</code></td>
<td>
<p>Desired height of bitmap</p>
</td></tr>
<tr><td><code id="as_bm_bitmap_+3A_png_device">png_device</code></td>
<td>
<p>A function taking arguments <code>filename</code>, <code>width</code>, and <code>height</code>
that starts a graphics device that saves a png image
with a transparent background.  By default will use <code><a href="ragg.html#topic+agg_png">ragg::agg_png()</a></code>
if available else the &ldquo;cairo&rdquo; version of <code><a href="grDevices.html#topic+png">grDevices::png()</a></code>
if available else just <code><a href="grDevices.html#topic+png">grDevices::png()</a></code>.</p>
</td></tr>
<tr><td><code id="as_bm_bitmap_+3A_threshold">threshold</code></td>
<td>
<p>If any png channel weakly exceeds this threshold
(on an interval from zero to one)
then the pixel is determined to be &ldquo;black&rdquo;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>bm_bitmap()</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bm_bitmap">bm_bitmap()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> space_matrix &lt;- matrix(0L, nrow = 16L, ncol = 16L)
 space_glyph &lt;- as_bm_bitmap(space_matrix)
 is_bm_bitmap(space_glyph)
  font_file &lt;- system.file("fonts/fixed/4x6.yaff.gz", package = "bittermelon")
  font &lt;- read_yaff(font_file)
  bm &lt;- as_bm_bitmap("RSTATS", font = font)
  print(bm, px = px_ascii)
  bm &lt;- as_bm_bitmap("RSTATS", direction = "top-to-bottom", font = font)
  print(bm, px = px_ascii)

 if (require("grid") &amp;&amp; capabilities("png")) {
   circle &lt;- as_bm_bitmap(circleGrob(r = 0.25), width = 16L, height = 16L)
   print(circle, px = c(".", "@"))

   inverted_exclamation &lt;- as_bm_bitmap(textGrob("!", rot = 180),
                                        width = 8L, height = 16L)
   print(inverted_exclamation, px = c(".", "@"))
 }
</code></pre>

<hr>
<h2 id='as_bm_font'>Coerce to bitmap font objects</h2><span id='topic+as_bm_font'></span><span id='topic+as_bm_font.default'></span><span id='topic+as_bm_font.list'></span>

<h3>Description</h3>

<p><code>as_bm_font()</code> turns an existing object into a <code>bm_font()</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_bm_font(x, ..., comments = NULL, properties = NULL)

## Default S3 method:
as_bm_font(x, ..., comments = NULL, properties = NULL)

## S3 method for class 'list'
as_bm_font(x, ..., comments = NULL, properties = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_bm_font_+3A_x">x</code></td>
<td>
<p>An object that can reasonably be coerced to a <code>bm_font()</code> object.</p>
</td></tr>
<tr><td><code id="as_bm_font_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="as_bm_font_+3A_comments">comments</code></td>
<td>
<p>An optional character vector of (global) font comments.</p>
</td></tr>
<tr><td><code id="as_bm_font_+3A_properties">properties</code></td>
<td>
<p>An optional named list of font metadata.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>bm_font()</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bm_font">bm_font()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plus_sign &lt;- matrix(0L, nrow = 9L, ncol = 9L)
  plus_sign[5L, 3:7] &lt;- 1L
  plus_sign[3:7, 5L] &lt;- 1L
  plus_sign_glyph &lt;- bm_bitmap(plus_sign)

  space_glyph &lt;- bm_bitmap(matrix(0L, nrow = 9L, ncol = 9L))

  l &lt;- list()
  l[[str2ucp("+")]] &lt;- plus_sign_glyph
  l[[str2ucp(" ")]] &lt;- space_glyph
  font &lt;- as_bm_font(l)
  is_bm_font(font)

</code></pre>

<hr>
<h2 id='as_bm_list'>Coerce to bitmap list objects</h2><span id='topic+as_bm_list'></span><span id='topic+as_bm_list.default'></span><span id='topic+as_bm_list.list'></span><span id='topic+as_bm_list.character'></span>

<h3>Description</h3>

<p><code>as_bm_list()</code> turns an existing object into a <code><a href="#topic+bm_list">bm_list()</a></code> object.
In particular <code>as_bm_list.character()</code> turns a string into a bitmap list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_bm_list(x, ...)

## Default S3 method:
as_bm_list(x, ...)

## S3 method for class 'list'
as_bm_list(x, ...)

## S3 method for class 'character'
as_bm_list(x, ..., font = bm_font())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_bm_list_+3A_x">x</code></td>
<td>
<p>An object that can reasonably be coerced to a <code><a href="#topic+bm_list">bm_list()</a></code> object.</p>
</td></tr>
<tr><td><code id="as_bm_list_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="as_bm_list_+3A_font">font</code></td>
<td>
<p>A <code><a href="#topic+bm_font">bm_font()</a></code> object that contains all the characters within <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+bm_list">bm_list()</a></code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bm_list">bm_list()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # as_bm_list.character()
  font_file &lt;- system.file("fonts/spleen/spleen-8x16.hex.gz", package = "bittermelon")
  font &lt;- read_hex(font_file)
  bml &lt;- as_bm_list("RSTATS", font = font)
  bml &lt;- bm_extend(bml, sides = 1L, value = 0L)
  bml &lt;- bm_extend(bml, sides = c(2L, 1L), value = 2L)
  bm &lt;- do.call(cbind, bml)
  print(bm, px = c(" ", "#", "X"))
</code></pre>

<hr>
<h2 id='as.matrix.bm_bitmap'>Coerce bitmap objects to matrix</h2><span id='topic+as.matrix.bm_bitmap'></span>

<h3>Description</h3>

<p><code>as.matrix.bm_bitmap()</code> coerces <code>bm_bitmap()</code> objects to an integer matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bm_bitmap'
as.matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.matrix.bm_bitmap_+3A_x">x</code></td>
<td>
<p>A <code>bm_bitmap()</code> object</p>
</td></tr>
<tr><td><code id="as.matrix.bm_bitmap_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'> space_matrix &lt;- matrix(0L, ncol = 8L, nrow = 8L)
 space_glyph &lt;- bm_bitmap(space_matrix)
 print(space_glyph, px = ".")
 print(as.matrix(space_glyph))
</code></pre>

<hr>
<h2 id='bm_bitmap'>Bitmap object</h2><span id='topic+bm_bitmap'></span>

<h3>Description</h3>

<p><code>bm_bitmap()</code> creates an S3 object representing bitmap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bm_bitmap(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bm_bitmap_+3A_x">x</code></td>
<td>
<p>Object to be converted to <code>bm_bitmap()</code>.
If not already an integer matrix it will be cast to one
by <code><a href="#topic+as_bm_bitmap">as_bm_bitmap()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Bitmaps are represented as integer matrices with special class methods.
The bottom left pixel is represented by the first row and first column.
The bottom right pixel is represented by the first row and last column.
The top left pixel is represented by the last row and first column.
The top right pixel is represented by the last row and last column.
Color bitmaps are supported (the integer can be any non-negative integer)
but we are unlikely to ever support exporting color bitmap fonts.
Color bitmaps can be cast to black-and-white bitmaps via <code><a href="#topic+bm_clamp">bm_clamp()</a></code>.
</p>


<h3>Value</h3>

<p>An integer matrix with a &ldquo;bm_bitmap&rdquo; subclass.
</p>


<h3>Supported S3 methods</h3>


<ul>
<li> <p><code><a href="#topic++5B.bm_bitmap">[.bm_bitmap</a></code> and <code><a href="#topic++5B+3C-.bm_bitmap">[&lt;-.bm_bitmap</a></code>
</p>
</li>
<li> <p><code><a href="#topic+as.matrix.bm_bitmap">as.matrix.bm_bitmap()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+as.raster.bm_bitmap">as.raster.bm_bitmap()</a></code> and <code><a href="#topic+plot.bm_bitmap">plot.bm_bitmap()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+cbind.bm_bitmap">cbind.bm_bitmap()</a></code> and <code><a href="#topic+rbind.bm_bitmap">rbind.bm_bitmap()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+format.bm_bitmap">format.bm_bitmap()</a></code> and <code><a href="#topic+print.bm_bitmap">print.bm_bitmap()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+Ops.bm_bitmap">Ops.bm_bitmap()</a></code> for all the S3 &ldquo;Ops&rdquo; Group generic functions
</p>
</li>
<li> <p><code><a href="#topic+which.bm_bitmap">which.bm_bitmap()</a></code> (with <code>which()</code> re-defined as a generic)
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+as_bm_bitmap">as_bm_bitmap()</a></code>, <code><a href="#topic+is_bm_bitmap">is_bm_bitmap()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> space &lt;- bm_bitmap(matrix(0, nrow = 16, ncol = 16))
 print(space, px = ".")
</code></pre>

<hr>
<h2 id='bm_call'>Execute a function call on bitmap objects</h2><span id='topic+bm_call'></span>

<h3>Description</h3>

<p><code>bm_call()</code> excutes a function call on bitmap objects.
Since its first argument is the bitmap object it is more
convenient to use with pipes then directly using <code><a href="base.html#topic+do.call">base::do.call()</a></code>
plus it is easier to specify additional arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bm_call(bm_object, .f, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bm_call_+3A_bm_object">bm_object</code></td>
<td>
<p>Either a <code><a href="#topic+bm_bitmap">bm_bitmap()</a></code>, <code><a href="#topic+bm_list">bm_list()</a></code>,  or <code><a href="#topic+bm_font">bm_font()</a></code> object.</p>
</td></tr>
<tr><td><code id="bm_call_+3A_.f">.f</code></td>
<td>
<p>A function to execute.</p>
</td></tr>
<tr><td><code id="bm_call_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>.f</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The return value of <code>.f</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  font_file &lt;- system.file("fonts/spleen/spleen-8x16.hex.gz", package = "bittermelon")
  font &lt;- read_hex(font_file)
  bml &lt;- as_bm_list("RSTATS", font = font)
  bml &lt;- bm_flip(bml, "both")
  bm &lt;- bm_call(bml, cbind, direction = "RTL")
  print(bm, px = px_ascii)
</code></pre>

<hr>
<h2 id='bm_clamp'>Clamp bitmap integer values.</h2><span id='topic+bm_clamp'></span>

<h3>Description</h3>

<p><code>bm_clamp()</code> &ldquo;clamps&rdquo; bitmap integers that lie outside an interval.
The default coerces a multiple-integer-valued bitmap
into a binary bitmap (as expected by most bitmap font formats).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bm_clamp(bm_object, lower = 0L, upper = 1L, value = upper)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bm_clamp_+3A_bm_object">bm_object</code></td>
<td>
<p>Either a <code><a href="#topic+bm_bitmap">bm_bitmap()</a></code>, <code><a href="#topic+bm_list">bm_list()</a></code>,  or <code><a href="#topic+bm_font">bm_font()</a></code> object.</p>
</td></tr>
<tr><td><code id="bm_clamp_+3A_lower">lower</code></td>
<td>
<p>Integer value.  Any value below <code>lower</code> will be clamped.</p>
</td></tr>
<tr><td><code id="bm_clamp_+3A_upper">upper</code></td>
<td>
<p>Integer value.  Any value above <code>upper</code> will be clamped.</p>
</td></tr>
<tr><td><code id="bm_clamp_+3A_value">value</code></td>
<td>
<p>Integer vector of length one or two of replacement value(s).
If <code>value</code> is length one
any values above <code>upper</code> are replaced by <code>value</code>
while those below <code>lower</code> are replaced by <code>lower</code>.
If <code>value</code> is length two any values above <code>upper</code>
are replaced by <code>value[2]</code> and any values below <code>lower</code>
are replaced by <code>value[1]</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a <code><a href="#topic+bm_bitmap">bm_bitmap()</a></code>, <code><a href="#topic+bm_list">bm_list()</a></code>, or <code><a href="#topic+bm_font">bm_font()</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> plus_sign &lt;- matrix(0L, nrow = 9L, ncol = 9L)
 plus_sign[5L, 3:7] &lt;- 2L
 plus_sign[3:7, 5L] &lt;- 2L
 plus_sign_glyph &lt;- bm_bitmap(plus_sign)
 print(plus_sign_glyph, px = c(".", "#", "@"))

 plus_sign_clamped &lt;- bm_clamp(plus_sign_glyph)
 print(plus_sign_clamped, px = c(".", "#", "@"))
</code></pre>

<hr>
<h2 id='bm_compose'>Compose graphemes in a bitmap list by applying combining marks</h2><span id='topic+bm_compose'></span>

<h3>Description</h3>

<p><code>bm_compose()</code> simplifies <code>bm_list()</code> object
by applying combining marks to preceding glpyhs (composing new graphemes).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bm_compose(bml, pua_combining = character(0), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bm_compose_+3A_bml">bml</code></td>
<td>
<p>A <code>bm_list()</code> object.
All combining marks need appropriate Unicode code point names
to be recognized by <code><a href="#topic+is_combining_character">is_combining_character()</a></code>.</p>
</td></tr>
<tr><td><code id="bm_compose_+3A_pua_combining">pua_combining</code></td>
<td>
<p>Additional Unicode code points to be considered
as a &ldquo;combining&rdquo; character such as characters
defined in the Private Use Area (PUA) of a font.</p>
</td></tr>
<tr><td><code id="bm_compose_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="#topic+bm_overlay">bm_overlay()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bm_compose()</code> identifies combining marks by their name using <code><a href="#topic+is_combining_character">is_combining_character()</a></code>.
It then combines such marks with their immediately preceding glyph using <code><a href="#topic+bm_overlay">bm_overlay()</a></code>.
</p>


<h3>Value</h3>

<p>A <code>bm_list()</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  font_file &lt;- system.file("fonts/spleen/spleen-8x16.hex.gz", package = "bittermelon")
  font &lt;- read_hex(font_file)
  grave &lt;- font[[str2ucp("`")]]
  a &lt;- font[[str2ucp("a")]]
  bml &lt;- bm_list(`U+0061` = a, `U+0300` = grave)
  print(bml, px = px_ascii)
  print(bm_compose(bml), px = px_ascii)
</code></pre>

<hr>
<h2 id='bm_compress'>Compress bitmaps using a &quot;block elements&quot; scheme</h2><span id='topic+bm_compress'></span>

<h3>Description</h3>

<p>Compress bitmaps by a factor of two by re-mapping to a &ldquo;block elements&rdquo; scheme.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bm_compress(bm_object, direction = "vertical")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bm_compress_+3A_bm_object">bm_object</code></td>
<td>
<p>Either a <code><a href="#topic+bm_bitmap">bm_bitmap()</a></code>, <code><a href="#topic+bm_list">bm_list()</a></code>,  or <code><a href="#topic+bm_font">bm_font()</a></code> object.</p>
</td></tr>
<tr><td><code id="bm_compress_+3A_direction">direction</code></td>
<td>
<p>Either &quot;vertical&quot; or &quot;v&quot;, &quot;horizontal&quot; or &quot;h&quot;,
OR &quot;both&quot; or &quot;b&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on <code>direction</code> we shrink the bitmaps height and/or width by
a factor of two and re-encode pairs/quartets of pixels to a &ldquo;block elements&rdquo; scheme.
If necessary we pad the right/bottom of the bitmap(s) by
a pixel. For each pair/quartet we determine the most-common non-zero element
and map them to a length twenty set of integers representing the &ldquo;block
elements&rdquo; scheme.  For integers greater than zero we map it to higher twenty
character sets i.e. <code>1</code>'s get mapped to 0:19, <code>2</code>'s get mapped to 20:39, <code>3</code>'s
get mapped to 40:59, etc.  Using the default <code>px_unicode</code> will give you the exact
matching &ldquo;Block Elements&rdquo; glyphs while <code>px_ascii</code> gives the closest ASCII approximation.
Hence <code>print.bm_bitmap()</code> should produce reasonable results for compressed bitmaps if
either of them are used as the <code>px</code> argument.
</p>


<h3>Value</h3>

<p>Either a <code><a href="#topic+bm_bitmap">bm_bitmap()</a></code>, <code><a href="#topic+bm_list">bm_list()</a></code>, or <code><a href="#topic+bm_font">bm_font()</a></code> object.
</p>


<h3>See Also</h3>

<p>See <a href="https://en.wikipedia.org/wiki/Block_Elements">https://en.wikipedia.org/wiki/Block_Elements</a> for more info on the Unicode Block Elements block.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  font_file &lt;- system.file("fonts/spleen/spleen-8x16.hex.gz", package = "bittermelon")
  font &lt;- read_hex(font_file)
  r &lt;- font[[str2ucp("R")]]
  print(r, px = px_ascii)
  print(bm_compress(r, "vertical"), px = px_ascii)
  print(bm_compress(r, "horizontal"), px = px_ascii)
  print(bm_compress(r, "both"), px = px_ascii)
</code></pre>

<hr>
<h2 id='bm_distort'>Resize images via distortion.</h2><span id='topic+bm_distort'></span>

<h3>Description</h3>

<p><code>bm_distort()</code> resize images to arbitrary width and height value via distortion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bm_distort(
  bm_object,
  width = NULL,
  height = NULL,
  interpolate = FALSE,
  vp = NULL,
  png_device = NULL,
  threshold = 0.25
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bm_distort_+3A_bm_object">bm_object</code></td>
<td>
<p>Either a <code><a href="#topic+bm_bitmap">bm_bitmap()</a></code>, <code><a href="#topic+bm_list">bm_list()</a></code>,  or <code><a href="#topic+bm_font">bm_font()</a></code> object.</p>
</td></tr>
<tr><td><code id="bm_distort_+3A_width">width</code></td>
<td>
<p>Desired width of bitmap</p>
</td></tr>
<tr><td><code id="bm_distort_+3A_height">height</code></td>
<td>
<p>Desired height of bitmap</p>
</td></tr>
<tr><td><code id="bm_distort_+3A_interpolate">interpolate</code></td>
<td>
<p>Passed to <code><a href="grid.html#topic+grid.raster">grid::grid.raster()</a></code>.</p>
</td></tr>
<tr><td><code id="bm_distort_+3A_vp">vp</code></td>
<td>
<p>A <code><a href="grid.html#topic+viewport">grid::viewport()</a></code> object that could be used to further manipulate the image.</p>
</td></tr>
<tr><td><code id="bm_distort_+3A_png_device">png_device</code></td>
<td>
<p>A function taking arguments <code>filename</code>, <code>width</code>, and <code>height</code>
that starts a graphics device that saves a png image
with a transparent background.  By default will use <code><a href="ragg.html#topic+agg_png">ragg::agg_png()</a></code>
if available else the &ldquo;cairo&rdquo; version of <code><a href="grDevices.html#topic+png">grDevices::png()</a></code>
if available else just <code><a href="grDevices.html#topic+png">grDevices::png()</a></code>.</p>
</td></tr>
<tr><td><code id="bm_distort_+3A_threshold">threshold</code></td>
<td>
<p>If any png channel weakly exceeds this threshold
(on an interval from zero to one)
then the pixel is determined to be &ldquo;black&rdquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bm_distort()</code> generates a distorted <code><a href="grid.html#topic+grid.raster">grid::rasterGrob()</a></code> with the help of
<code><a href="#topic+as.raster.bm_bitmap">as.raster.bm_bitmap()</a></code> which is then converted back to a
<code><a href="#topic+bm_bitmap">bm_bitmap()</a></code> via <code><a href="#topic+as_bm_bitmap.grob">as_bm_bitmap.grob()</a></code>.
</p>


<h3>Value</h3>

<p>Either a <code><a href="#topic+bm_bitmap">bm_bitmap()</a></code>, <code><a href="#topic+bm_list">bm_list()</a></code>, or <code><a href="#topic+bm_font">bm_font()</a></code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bm_expand">bm_expand()</a></code> for expanding width/height by integer multiples.
<code><a href="#topic+bm_resize">bm_resize()</a></code> for resizing an image via trimming/extending an image.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> font_file &lt;- system.file("fonts/spleen/spleen-8x16.hex.gz", package = "bittermelon")
 font &lt;- read_hex(font_file)
 capital_r &lt;- font[[str2ucp("R")]]
 dim(capital_r) # 8 x 16
 if (require("grid") &amp;&amp; capabilities("png")) {
   print(bm_distort(capital_r, width = 9L, height = 21L), px = px_ascii)
 }
</code></pre>

<hr>
<h2 id='bm_edit'>Edit a bitmap via text editor</h2><span id='topic+bm_edit'></span>

<h3>Description</h3>

<p>Edit a binary bitmap in a text editor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bm_edit(bitmap, editor = getOption("editor"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bm_edit_+3A_bitmap">bitmap</code></td>
<td>
<p><code><a href="#topic+bm_bitmap">bm_bitmap()</a></code> object.
It will be coerced into a binary bitmap via <code><a href="#topic+bm_clamp">bm_clamp()</a></code>.</p>
</td></tr>
<tr><td><code id="bm_edit_+3A_editor">editor</code></td>
<td>
<p>Text editor.  See <code><a href="utils.html#topic+file.edit">utils::file.edit()</a></code> for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Represent zeroes with a <code>.</code> and ones with a <code>@</code>
(as in the <code>yaff</code> font format).  You may
also add/delete rows/columns but the bitmap must
be rectangular.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+bm_bitmap">bm_bitmap()</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  font_file &lt;- system.file("fonts/spleen/spleen-8x16.hex.gz", package = "bittermelon")
  font &lt;- read_hex(font_file)
  r &lt;- font[[str2ucp("R")]]

  # requires users to manually close file in text editor
  ## Not run: 
    edited_r &lt;- bm_edit(r)
    print(edited_r, px = px_ascii)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='bm_expand'>Expand bitmaps by repeating each row and/or column</h2><span id='topic+bm_expand'></span>

<h3>Description</h3>

<p><code>bm_expand()</code> expands bitmap(s) by repeating each row and/or column
an indicated number of times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bm_expand(bm_object, width = 1L, height = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bm_expand_+3A_bm_object">bm_object</code></td>
<td>
<p>Either a <code><a href="#topic+bm_bitmap">bm_bitmap()</a></code>, <code><a href="#topic+bm_list">bm_list()</a></code>,  or <code><a href="#topic+bm_font">bm_font()</a></code> object.</p>
</td></tr>
<tr><td><code id="bm_expand_+3A_width">width</code></td>
<td>
<p>An integer of how many times to repeat each column.</p>
</td></tr>
<tr><td><code id="bm_expand_+3A_height">height</code></td>
<td>
<p>An integer of how many times to repeat each row.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a <code><a href="#topic+bm_bitmap">bm_bitmap()</a></code>, <code><a href="#topic+bm_list">bm_list()</a></code>, or <code><a href="#topic+bm_font">bm_font()</a></code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bm_extend">bm_extend()</a></code> (and <code><a href="#topic+bm_resize">bm_resize()</a></code> which makes larger bitmaps
by adding pixels to their sides.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> font_file &lt;- system.file("fonts/spleen/spleen-8x16.hex.gz", package = "bittermelon")
 font &lt;- read_hex(font_file)
 capital_r &lt;- font[[str2ucp("R")]]
 print(capital_r, px = px_ascii)
 print(bm_expand(capital_r, width = 2L),
       px = px_ascii)
 print(bm_expand(capital_r, height = 2L),
       px = px_ascii)
 print(bm_expand(capital_r, width = 2L, height = 2L),
       px = px_ascii)
</code></pre>

<hr>
<h2 id='bm_extend'>Extend bitmaps on the sides with extra pixels</h2><span id='topic+bm_extend'></span>

<h3>Description</h3>

<p><code>bm_extend()</code> extends <code><a href="#topic+bm_bitmap">bm_bitmap()</a></code> objects with extra pixels.
The directions and the integer value of the extra pixels are settable
(defaulting to <code>0L</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bm_extend(
  bm_object,
  value = 0L,
  sides = NULL,
  top = NULL,
  right = NULL,
  bottom = NULL,
  left = NULL,
  width = NULL,
  height = NULL,
  hjust = "center-left",
  vjust = "center-top"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bm_extend_+3A_bm_object">bm_object</code></td>
<td>
<p>Either a <code><a href="#topic+bm_bitmap">bm_bitmap()</a></code>, <code><a href="#topic+bm_list">bm_list()</a></code>,  or <code><a href="#topic+bm_font">bm_font()</a></code> object.</p>
</td></tr>
<tr><td><code id="bm_extend_+3A_value">value</code></td>
<td>
<p>Integer value for the new pixels.</p>
</td></tr>
<tr><td><code id="bm_extend_+3A_sides">sides</code></td>
<td>
<p>If not <code>NULL</code> then an integer vector indicating how
many pixels to pad on all four sides.
If the integer vector is of length one it indicates the number of pixels for all four sides.
If of length two gives first the number for the vertical sides and then the horizontal sides.
If of length three gives the number of pixels for top, the horizontal sides, and then bottom sides.
If of length four gives the number of pixels for top, right, bottom, and then left sides.
This is the same scheme as used by the CSS padding and margin properties.</p>
</td></tr>
<tr><td><code id="bm_extend_+3A_top">top</code></td>
<td>
<p>How many pixels to pad the top.</p>
</td></tr>
<tr><td><code id="bm_extend_+3A_right">right</code></td>
<td>
<p>How many pixels to pad the right.</p>
</td></tr>
<tr><td><code id="bm_extend_+3A_bottom">bottom</code></td>
<td>
<p>How many pixels to pad the bottom.</p>
</td></tr>
<tr><td><code id="bm_extend_+3A_left">left</code></td>
<td>
<p>How many pixels to pad the left.</p>
</td></tr>
<tr><td><code id="bm_extend_+3A_width">width</code></td>
<td>
<p>How many pixels wide should the new bitmap be.
Use with the <code>hjust</code> argument or just one of either the <code>left</code> or <code>right</code> arguments.</p>
</td></tr>
<tr><td><code id="bm_extend_+3A_height">height</code></td>
<td>
<p>How many pixels tall should the new bitmap be.
Use with the <code>vjust</code> argument or just one of either the <code>top</code> or <code>bottom</code> arguments.</p>
</td></tr>
<tr><td><code id="bm_extend_+3A_hjust">hjust</code></td>
<td>
<p>One of &quot;left&quot;, &quot;center-left&quot;, &quot;center-right&quot;, &quot;right&quot;.
&quot;center-left&quot; and &quot;center-right&quot; will attempt to
place in &quot;center&quot; if possible but if not possible will bias
it one pixel left or right respectively.
&quot;centre&quot;, &quot;center&quot;, and &quot;centre-left&quot; are aliases for &quot;center-left&quot;.
&quot;centre-right&quot; is an alias for &quot;center-right&quot;.</p>
</td></tr>
<tr><td><code id="bm_extend_+3A_vjust">vjust</code></td>
<td>
<p>One of &quot;bottom&quot;, &quot;center-bottom&quot;, &quot;center-top&quot;, &quot;top&quot;.
&quot;center-bottom&quot; and &quot;center-top&quot; will attempt to
place in &quot;center&quot; if possible but if not possible will bias
it one pixel down or up respectively.
&quot;centre&quot;, &quot;center&quot;, and &quot;centre-top&quot; are aliases for &quot;center-top&quot;.
&quot;centre-bottom&quot; is an alias for &quot;center-bottom&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a <code><a href="#topic+bm_bitmap">bm_bitmap()</a></code>, <code><a href="#topic+bm_list">bm_list()</a></code>, or <code><a href="#topic+bm_font">bm_font()</a></code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bm_expand">bm_expand()</a></code>, <code><a href="#topic+bm_pad">bm_pad()</a></code>, <code><a href="#topic+bm_resize">bm_resize()</a></code>, and <code><a href="#topic+bm_trim">bm_trim()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> font_file &lt;- system.file("fonts/spleen/spleen-8x16.hex.gz", package = "bittermelon")
 font &lt;- read_hex(font_file)
 # add a border to an "R"
 capital_r &lt;- font[[str2ucp("R")]]
 capital_r &lt;- bm_extend(capital_r, value = 2L, sides = 1L)
 capital_r &lt;- bm_extend(capital_r, value = 3L, sides = 1L)
 print(capital_r, px = c(" ", "#", ".", "@"))
</code></pre>

<hr>
<h2 id='bm_flip'>Flip (reflect) bitmaps</h2><span id='topic+bm_flip'></span>

<h3>Description</h3>

<p><code>bm_flip()</code> flips (reflects) bitmaps horizontally, vertically, or both.
It can flip the entire bitmap or just the glyph in place.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bm_flip(bm_object, direction = "vertical", in_place = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bm_flip_+3A_bm_object">bm_object</code></td>
<td>
<p>Either a <code><a href="#topic+bm_bitmap">bm_bitmap()</a></code>, <code><a href="#topic+bm_list">bm_list()</a></code>,  or <code><a href="#topic+bm_font">bm_font()</a></code> object.</p>
</td></tr>
<tr><td><code id="bm_flip_+3A_direction">direction</code></td>
<td>
<p>Either &quot;vertical&quot; or &quot;v&quot;, &quot;horizontal&quot; or &quot;h&quot;,
OR &quot;both&quot; or &quot;b&quot;.</p>
</td></tr>
<tr><td><code id="bm_flip_+3A_in_place">in_place</code></td>
<td>
<p>If <code>TRUE</code> flip the glyphs in place (without changing any white space padding).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a <code><a href="#topic+bm_bitmap">bm_bitmap()</a></code>, <code><a href="#topic+bm_list">bm_list()</a></code>, or <code><a href="#topic+bm_font">bm_font()</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  font_file &lt;- system.file("fonts/spleen/spleen-8x16.hex.gz", package = "bittermelon")
  font &lt;- read_hex(font_file)

  # Print upside down
  bml &lt;- as_bm_list("RSTATS", font = font)
  bml &lt;- bm_flip(bml, "both")
  bm &lt;- bm_call(bml, cbind, direction = "RTL")
  print(bm, px = px_ascii)

  # Can also modify glyphs "in place"
  exclamation &lt;- font[[str2ucp("!")]]
  exclamation_flipped &lt;- bm_flip(exclamation, in_place = TRUE)
  print(exclamation_flipped, px = px_ascii)
</code></pre>

<hr>
<h2 id='bm_font'>Bitmap font object</h2><span id='topic+bm_font'></span>

<h3>Description</h3>

<p><code>bm_font()</code> creates a bitmap font object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bm_font(x = bm_list(), comments = NULL, properties = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bm_font_+3A_x">x</code></td>
<td>
<p>Named list of <code><a href="#topic+bm_bitmap">bm_bitmap()</a></code> objects.
Names must be coercible by <code><a href="Unicode.html#topic+u_char_basics">Unicode::as.u_char()</a></code>.</p>
</td></tr>
<tr><td><code id="bm_font_+3A_comments">comments</code></td>
<td>
<p>An optional character vector of (global) font comments.</p>
</td></tr>
<tr><td><code id="bm_font_+3A_properties">properties</code></td>
<td>
<p>An optional named list of font metadata.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bm_font()</code> is a named list.
The names are of the form &ldquo;U+HHHH&rdquo; or &ldquo;U+HHHHH&rdquo;.
where the <code>H</code> are appropriate hexadecimal Unicode code points.
It is a subclass of <code><a href="#topic+bm_list">bm_list()</a></code>.
</p>


<h3>Value</h3>

<p>A named list with a &ldquo;bm_font&rdquo; subclass.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is_bm_font">is_bm_font()</a></code>, [as_bm_font(), <code><a href="#topic+hex2ucp">hex2ucp()</a></code>]
</p>


<h3>Examples</h3>

<pre><code class='language-R'> font_file &lt;- system.file("fonts/spleen/spleen-8x16.hex.gz", package = "bittermelon")
 font &lt;- read_hex(font_file)
 is_bm_font(font)

 # number of characters in font
 length(font)

 # print out "R"
 R_glyph &lt;- font[[str2ucp("R")]]
 print(R_glyph, px = c(".", "#"))
</code></pre>

<hr>
<h2 id='bm_lapply'>Modify bitmap lists</h2><span id='topic+bm_lapply'></span>

<h3>Description</h3>

<p><code>bm_lapply()</code> applies a function over a bitmap glyph list
and returns a modified bitmap glyph list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bm_lapply(X, FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bm_lapply_+3A_x">X</code></td>
<td>
<p>A bitmap glyph list object such as <code><a href="#topic+bm_list">bm_list()</a></code> or <code><a href="#topic+bm_font">bm_font()</a></code>.</p>
</td></tr>
<tr><td><code id="bm_lapply_+3A_fun">FUN</code></td>
<td>
<p>A function that takes a <code><a href="#topic+bm_bitmap">bm_bitmap()</a></code> object as its first argument
and returns a <code><a href="#topic+bm_bitmap">bm_bitmap()</a></code> object.</p>
</td></tr>
<tr><td><code id="bm_lapply_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>FUN</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bm_lapply()</code> is a wrapper around <code>base::lapply()</code> that
preserves the classes and metadata of the original bitmap glyph list.
</p>


<h3>Value</h3>

<p>A modified bitmap glyph list.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+lapply">base::lapply()</a></code>, <code><a href="#topic+bm_list">bm_list()</a></code>, <code><a href="#topic+bm_font">bm_font()</a></code>, <code><a href="#topic+bm_bitmap">bm_bitmap()</a></code>
</p>

<hr>
<h2 id='bm_list'>Bitmap list object</h2><span id='topic+bm_list'></span>

<h3>Description</h3>

<p><code>bm_list()</code> creates a bitmap list object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bm_list(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bm_list_+3A_...">...</code></td>
<td>
<p><code><a href="#topic+bm_bitmap">bm_bitmap()</a></code> objects, possibly named.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bm_list()</code> is a list of <code><a href="#topic+bm_bitmap">bm_bitmap()</a></code> objects with class &ldquo;bm_list&rdquo;.
It is superclass of <code><a href="#topic+bm_font">bm_font()</a></code>.
</p>


<h3>Value</h3>

<p>A named list with a &ldquo;bm_list&rdquo; subclass.
</p>


<h3>Supported S3 methods</h3>


<ul>
<li> <p><code>as.list.bm_list()</code>
</p>
</li>
<li><p> Slicing with <code style="white-space: pre;">&#8288;[]&#8288;</code> returns <code>bm_list()</code> objects.
</p>
</li>
<li><p> The <code>min()</code>, <code>max()</code>, and <code>range()</code> functions from the &ldquo;Summary&rdquo;
group of generic methods.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+is_bm_list">is_bm_list()</a></code>, <code><a href="#topic+as_bm_list">as_bm_list()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> font_file &lt;- system.file("fonts/spleen/spleen-8x16.hex.gz", package = "bittermelon")
 font &lt;- read_hex(font_file)

 gl &lt;- font[c("U+0023", "U+0052", "U+0053", "U+0054", "U+0041", "U+0054", "U+0053")] # #RSTATS
 gl &lt;- as_bm_list(gl)
 is_bm_list(gl)

</code></pre>

<hr>
<h2 id='bm_mask'>Modify bitmaps via masking with a 'mask' bitmap</h2><span id='topic+bm_mask'></span>

<h3>Description</h3>

<p><code>bm_mask()</code> modifies bitmaps by using a binary bitmap &ldquo;mask&rdquo;
to set certain elements to zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bm_mask(
  bm_object,
  mask = NULL,
  base = NULL,
  mode = c("luminance", "alpha"),
  hjust = "center-left",
  vjust = "center-top"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bm_mask_+3A_bm_object">bm_object</code></td>
<td>
<p>Either a <code><a href="#topic+bm_bitmap">bm_bitmap()</a></code>, <code><a href="#topic+bm_list">bm_list()</a></code>,  or <code><a href="#topic+bm_font">bm_font()</a></code> object.</p>
</td></tr>
<tr><td><code id="bm_mask_+3A_mask">mask</code></td>
<td>
<p>A 'bm_bitmap()' object to use as a &ldquo;mask&rdquo;.
Only one of <code>mask</code> or <code>base</code> may be set.</p>
</td></tr>
<tr><td><code id="bm_mask_+3A_base">base</code></td>
<td>
<p>A 'bm_bitmap()' object which will be &ldquo;masked&rdquo; by <code>mask</code>.
Only one of <code>mask</code> or <code>base</code> may be set.</p>
</td></tr>
<tr><td><code id="bm_mask_+3A_mode">mode</code></td>
<td>
<p>Either &quot;luminance&quot; (default) or &quot;alpha&quot;.</p>
</td></tr>
<tr><td><code id="bm_mask_+3A_hjust">hjust</code></td>
<td>
<p>One of &quot;left&quot;, &quot;center-left&quot;, &quot;center-right&quot;, &quot;right&quot;.
&quot;center-left&quot; and &quot;center-right&quot; will attempt to
place in &quot;center&quot; if possible but if not possible will bias
it one pixel left or right respectively.
&quot;centre&quot;, &quot;center&quot;, and &quot;centre-left&quot; are aliases for &quot;center-left&quot;.
&quot;centre-right&quot; is an alias for &quot;center-right&quot;.</p>
</td></tr>
<tr><td><code id="bm_mask_+3A_vjust">vjust</code></td>
<td>
<p>One of &quot;bottom&quot;, &quot;center-bottom&quot;, &quot;center-top&quot;, &quot;top&quot;.
&quot;center-bottom&quot; and &quot;center-top&quot; will attempt to
place in &quot;center&quot; if possible but if not possible will bias
it one pixel down or up respectively.
&quot;centre&quot;, &quot;center&quot;, and &quot;centre-top&quot; are aliases for &quot;center-top&quot;.
&quot;centre-bottom&quot; is an alias for &quot;center-bottom&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If necessary bitmaps will be extended by <code>bm_extend()</code> such that
they are the same size.
If necessary the <code>mask</code> will be coerced into a &ldquo;binary&rdquo; mask.
If <code>mode</code> is &quot;luminance&quot; then where the <code>mask</code> is <code>1L</code>
the corresponding pixel in <code>base</code> will be coerced to <code>0L</code>.
If <code>mode</code> is &quot;alpha&quot; then where the <code>mask</code> is <code>0L</code>
the corresponding pixel in <code>base</code> will be coerced to <code>0L</code>
</p>


<h3>Value</h3>

<p>Either a <code><a href="#topic+bm_bitmap">bm_bitmap()</a></code>, <code><a href="#topic+bm_list">bm_list()</a></code>, or <code><a href="#topic+bm_font">bm_font()</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> if (require("grid") &amp;&amp; capabilities("png")) {
   font_file &lt;- system.file("fonts/spleen/spleen-8x16.hex.gz", package = "bittermelon")
   font &lt;- read_hex(font_file)
   one &lt;- font[[str2ucp("1")]]
   circle_large &lt;- as_bm_bitmap(circleGrob(r = 0.50), width = 16L, height = 16L)
   circle_small &lt;- as_bm_bitmap(circleGrob(r = 0.40), width = 16L, height = 16L)

   circle_outline &lt;- bm_mask(circle_large, circle_small)
   print(circle_outline, px = px_ascii)

   # U+2776 "Dingbat Negative Circled Digit One"
   circle_minus_one &lt;- bm_mask(circle_large, one)
   print(circle_minus_one, px = px_ascii)

   # Can also do "alpha" mask
   square_full &lt;- bm_bitmap(matrix(1L, nrow = 16L, ncol = 16L))
   square_minus_lower_left &lt;- square_full
   square_minus_lower_left[1:8, 1:8] &lt;- 0L
   print(square_minus_lower_left, px = px_ascii)

   circle_minus_lower_left &lt;- bm_mask(circle_large, square_minus_lower_left, mode = "alpha")
   print(circle_minus_lower_left, px = px_ascii)
 }
</code></pre>

<hr>
<h2 id='bm_outline'>Compute &quot;outline&quot; bitmap of a bitmap</h2><span id='topic+bm_outline'></span>

<h3>Description</h3>

<p><code>bm_outline()</code> returns a bitmap that is just the &ldquo;outline&rdquo;
of another bitmap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bm_outline(bm_object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bm_outline_+3A_bm_object">bm_object</code></td>
<td>
<p>Either a <code><a href="#topic+bm_bitmap">bm_bitmap()</a></code>, <code><a href="#topic+bm_list">bm_list()</a></code>,  or <code><a href="#topic+bm_font">bm_font()</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a <code><a href="#topic+bm_bitmap">bm_bitmap()</a></code>, <code><a href="#topic+bm_list">bm_list()</a></code>, or <code><a href="#topic+bm_font">bm_font()</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  square &lt;- bm_bitmap(matrix(1L, nrow = 16L, ncol = 16L))
  square_outline &lt;- bm_outline(square)
  print(square_outline, px = px_ascii)

  if (require(grid) &amp;&amp; capabilities("png")) {
    circle &lt;- as_bm_bitmap(circleGrob(), width=16, height=16)
    circle_outline &lt;- bm_outline(circle)
    print(circle_outline, px = px_ascii)
  }
</code></pre>

<hr>
<h2 id='bm_overlay'>Merge bitmaps by overlaying one over another</h2><span id='topic+bm_overlay'></span>

<h3>Description</h3>

<p><code>bm_overlay()</code> merges bitmaps by overlaying a bitmap over another.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bm_overlay(
  bm_object,
  over = NULL,
  under = NULL,
  hjust = "center-left",
  vjust = "center-top"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bm_overlay_+3A_bm_object">bm_object</code></td>
<td>
<p>Either a <code><a href="#topic+bm_bitmap">bm_bitmap()</a></code>, <code><a href="#topic+bm_list">bm_list()</a></code>,  or <code><a href="#topic+bm_font">bm_font()</a></code> object.</p>
</td></tr>
<tr><td><code id="bm_overlay_+3A_over">over</code></td>
<td>
<p>A 'bm_bitmap()' object to overlay
over the <code>bm_object</code> bitmap(s).
Only one of <code>over</code> or <code>under</code> may be set.</p>
</td></tr>
<tr><td><code id="bm_overlay_+3A_under">under</code></td>
<td>
<p>A 'bm_bitmap()' object which will be overlaid
by the <code>bm_object</code> bitmap(s).
Only one of <code>over</code> or <code>under</code> may be set.</p>
</td></tr>
<tr><td><code id="bm_overlay_+3A_hjust">hjust</code></td>
<td>
<p>One of &quot;left&quot;, &quot;center-left&quot;, &quot;center-right&quot;, &quot;right&quot;.
&quot;center-left&quot; and &quot;center-right&quot; will attempt to
place in &quot;center&quot; if possible but if not possible will bias
it one pixel left or right respectively.
&quot;centre&quot;, &quot;center&quot;, and &quot;centre-left&quot; are aliases for &quot;center-left&quot;.
&quot;centre-right&quot; is an alias for &quot;center-right&quot;.</p>
</td></tr>
<tr><td><code id="bm_overlay_+3A_vjust">vjust</code></td>
<td>
<p>One of &quot;bottom&quot;, &quot;center-bottom&quot;, &quot;center-top&quot;, &quot;top&quot;.
&quot;center-bottom&quot; and &quot;center-top&quot; will attempt to
place in &quot;center&quot; if possible but if not possible will bias
it one pixel down or up respectively.
&quot;centre&quot;, &quot;center&quot;, and &quot;centre-top&quot; are aliases for &quot;center-top&quot;.
&quot;centre-bottom&quot; is an alias for &quot;center-bottom&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If necessary bitmaps will be extended by <code>bm_extend()</code> such that
they are the same size.  Then the non-zero pixels of the &ldquo;over&rdquo;
bitmap will be inserted into the &ldquo;under&rdquo; bitmap.
</p>


<h3>Value</h3>

<p>Either a <code><a href="#topic+bm_bitmap">bm_bitmap()</a></code>, <code><a href="#topic+bm_list">bm_list()</a></code>, or <code><a href="#topic+bm_font">bm_font()</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  font_file &lt;- system.file("fonts/spleen/spleen-8x16.hex.gz", package = "bittermelon")
  font &lt;- read_hex(font_file)
  grave &lt;- font[[str2ucp("`")]]
  a &lt;- font[[str2ucp("a")]]
  a_grave &lt;- bm_overlay(a, over = grave)
  print(a_grave, px = px_ascii)

  # Can also instead specify the under glyph as a named argument
  a_grave2 &lt;- bm_overlay(grave, under = a)
  print(a_grave2, px = px_ascii)
</code></pre>

<hr>
<h2 id='bm_pad'>Adjust bitmap padding lengths</h2><span id='topic+bm_pad'></span>

<h3>Description</h3>

<p><code>bm_pad()</code> adjusts bitmap padding lengths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bm_pad(
  bm_object,
  value = 0L,
  type = c("exact", "extend", "trim"),
  sides = NULL,
  top = NULL,
  right = NULL,
  bottom = NULL,
  left = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bm_pad_+3A_bm_object">bm_object</code></td>
<td>
<p>Either a <code><a href="#topic+bm_bitmap">bm_bitmap()</a></code>, <code><a href="#topic+bm_list">bm_list()</a></code>,  or <code><a href="#topic+bm_font">bm_font()</a></code> object.</p>
</td></tr>
<tr><td><code id="bm_pad_+3A_value">value</code></td>
<td>
<p>Integer value for the new pixels.</p>
</td></tr>
<tr><td><code id="bm_pad_+3A_type">type</code></td>
<td>
<p>Either &quot;exact&quot;, '&quot;extend&quot;, or &quot;trim&quot;.
&quot;exact&quot; makes sure the padding is exactly the indicated amount,
&quot;extend&quot; does not trim any padding if existing padding is more than the indicated amount,
and &quot;trim&quot; does not extend any padding if existing padding is less than the indicated amount.</p>
</td></tr>
<tr><td><code id="bm_pad_+3A_sides">sides</code></td>
<td>
<p>If not <code>NULL</code> then an integer vector indicating the desired
number of pixels of padding on all four sides.
If the integer vector is of length one it indicates the number of pixels for all four sides.
If of length two gives first the number for the vertical sides and then the horizontal sides.
If of length three gives the number of pixels for top, the horizontal sides, and then bottom sides.
If of length four gives the number of pixels for top, right, bottom, and then left sides.
This is the same scheme as used by the CSS padding and margin properties.</p>
</td></tr>
<tr><td><code id="bm_pad_+3A_top">top</code></td>
<td>
<p>Desired number of pixels of padding on the top.</p>
</td></tr>
<tr><td><code id="bm_pad_+3A_right">right</code></td>
<td>
<p>Desired number of pixels of padding on the right.</p>
</td></tr>
<tr><td><code id="bm_pad_+3A_bottom">bottom</code></td>
<td>
<p>Desired number of pixels of padding on the bottom.</p>
</td></tr>
<tr><td><code id="bm_pad_+3A_left">left</code></td>
<td>
<p>Desired number of pixels of padding on the left.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a <code><a href="#topic+bm_bitmap">bm_bitmap()</a></code>, <code><a href="#topic+bm_list">bm_list()</a></code>, or <code><a href="#topic+bm_font">bm_font()</a></code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bm_extend">bm_extend()</a></code>, <code><a href="#topic+bm_resize">bm_resize()</a></code>, and <code><a href="#topic+bm_trim">bm_trim()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> font_file &lt;- system.file("fonts/spleen/spleen-8x16.hex.gz", package = "bittermelon")
 font &lt;- read_hex(font_file)
 capital_r &lt;- font[[str2ucp("R")]]
 print(capital_r, px = c(".", "#"))
 capital_r_padded &lt;- bm_pad(capital_r, sides = 2L)
 print(capital_r_padded, px = c(".", "#"))
</code></pre>

<hr>
<h2 id='bm_padding_lengths'>Compute bitmap padding lengths</h2><span id='topic+bm_padding_lengths'></span>

<h3>Description</h3>

<p><code>bm_padding_lengths()</code> computes the padding lengths of a
target value for the top, right, bottom, and left sides of the bitmap.
If the entire bitmap is of the target value then the left/right and top/bottom
will simply split the width/height in half.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bm_padding_lengths(bm_object, value = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bm_padding_lengths_+3A_bm_object">bm_object</code></td>
<td>
<p>Either a <code><a href="#topic+bm_bitmap">bm_bitmap()</a></code>, <code><a href="#topic+bm_list">bm_list()</a></code>,  or <code><a href="#topic+bm_font">bm_font()</a></code> object.</p>
</td></tr>
<tr><td><code id="bm_padding_lengths_+3A_value">value</code></td>
<td>
<p>The value of the &ldquo;padding&rdquo; integer to compute lengths for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>bm_object</code> is a <code>bm_bitmap()</code> object then a integer vector of length four
representing the padding lengths for the top, right, bottom, and left sides respectively.
If <code>bm_object</code> is a <code>bm_list()</code> or <code>bm_font()</code> then a list of integer vectors of length four.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> font_file &lt;- system.file("fonts/spleen/spleen-8x16.hex.gz", package = "bittermelon")
 font &lt;- read_hex(font_file)
 # add a border to an "R"
 capital_r &lt;- font[[str2ucp("R")]]
 print(capital_r, px = c(".", "@"))
 print(bm_padding_lengths(capital_r))
</code></pre>

<hr>
<h2 id='bm_resize'>Resize bitmaps by trimming and/or extending</h2><span id='topic+bm_resize'></span>

<h3>Description</h3>

<p>Trim and/or extend bitmaps to a desired height and/or width.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bm_resize(
  bm_object,
  value = 0L,
  width = NULL,
  height = NULL,
  hjust = "center-left",
  vjust = "center-top"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bm_resize_+3A_bm_object">bm_object</code></td>
<td>
<p>Either a <code><a href="#topic+bm_bitmap">bm_bitmap()</a></code>, <code><a href="#topic+bm_list">bm_list()</a></code>,  or <code><a href="#topic+bm_font">bm_font()</a></code> object.</p>
</td></tr>
<tr><td><code id="bm_resize_+3A_value">value</code></td>
<td>
<p>Integer value for the new pixels.</p>
</td></tr>
<tr><td><code id="bm_resize_+3A_width">width</code></td>
<td>
<p>How many pixels wide should the new bitmap be.
Use with the <code>hjust</code> argument or just one of either the <code>left</code> or <code>right</code> arguments.</p>
</td></tr>
<tr><td><code id="bm_resize_+3A_height">height</code></td>
<td>
<p>How many pixels tall should the new bitmap be.
Use with the <code>vjust</code> argument or just one of either the <code>top</code> or <code>bottom</code> arguments.</p>
</td></tr>
<tr><td><code id="bm_resize_+3A_hjust">hjust</code></td>
<td>
<p>One of &quot;left&quot;, &quot;center-left&quot;, &quot;center-right&quot;, &quot;right&quot;.
&quot;center-left&quot; and &quot;center-right&quot; will attempt to
place in &quot;center&quot; if possible but if not possible will bias
it one pixel left or right respectively.
&quot;centre&quot;, &quot;center&quot;, and &quot;centre-left&quot; are aliases for &quot;center-left&quot;.
&quot;centre-right&quot; is an alias for &quot;center-right&quot;.</p>
</td></tr>
<tr><td><code id="bm_resize_+3A_vjust">vjust</code></td>
<td>
<p>One of &quot;bottom&quot;, &quot;center-bottom&quot;, &quot;center-top&quot;, &quot;top&quot;.
&quot;center-bottom&quot; and &quot;center-top&quot; will attempt to
place in &quot;center&quot; if possible but if not possible will bias
it one pixel down or up respectively.
&quot;centre&quot;, &quot;center&quot;, and &quot;centre-top&quot; are aliases for &quot;center-top&quot;.
&quot;centre-bottom&quot; is an alias for &quot;center-bottom&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a convenience wrapper around <code><a href="#topic+bm_trim">bm_trim()</a></code> and <code><a href="#topic+bm_extend">bm_extend()</a></code>.
</p>


<h3>Value</h3>

<p>Either a <code><a href="#topic+bm_bitmap">bm_bitmap()</a></code>, <code><a href="#topic+bm_list">bm_list()</a></code>, or <code><a href="#topic+bm_font">bm_font()</a></code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bm_extend">bm_extend()</a></code>, <code><a href="#topic+bm_pad">bm_pad()</a></code>, and <code><a href="#topic+bm_trim">bm_trim()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> font_file &lt;- system.file("fonts/spleen/spleen-8x16.hex.gz", package = "bittermelon")
 font &lt;- read_hex(font_file)
 # add a border to an "R"
 capital_r &lt;- font[[str2ucp("R")]]
 print(capital_r, px = c("-", "#"))
 capital_r &lt;- bm_resize(capital_r, width = 12L, height = 12L, vjust = "top")
 print(capital_r, px = c("-", "#"))
</code></pre>

<hr>
<h2 id='bm_rotate'>Rotate bitmaps 0, 90, 180, or 270 degrees</h2><span id='topic+bm_rotate'></span>

<h3>Description</h3>

<p><code>bm_rotate()</code> losslessly rotates bitmaps by 0, 90, 180, or 270 degrees.
If <code>90</code> or <code>270</code> degrees are indicated the width and height of the bitmap will be flipped.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bm_rotate(bm_object, angle = 0, clockwise = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bm_rotate_+3A_bm_object">bm_object</code></td>
<td>
<p>Either a <code><a href="#topic+bm_bitmap">bm_bitmap()</a></code>, <code><a href="#topic+bm_list">bm_list()</a></code>,  or <code><a href="#topic+bm_font">bm_font()</a></code> object.</p>
</td></tr>
<tr><td><code id="bm_rotate_+3A_angle">angle</code></td>
<td>
<p>Angle to rotate bitmap by.</p>
</td></tr>
<tr><td><code id="bm_rotate_+3A_clockwise">clockwise</code></td>
<td>
<p>If <code>TRUE</code> rotate bitmaps clockwise.
Note Unicode's convention is to rotate glyphs clockwise
i.e. the top of the &quot;BLACK CHESS PAWN ROTATED NINETY DEGREES&quot; glyph points right.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a <code><a href="#topic+bm_bitmap">bm_bitmap()</a></code>, <code><a href="#topic+bm_list">bm_list()</a></code>, or <code><a href="#topic+bm_font">bm_font()</a></code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bm_distort">bm_distort()</a></code> can do other (distorted) rotations by careful
use of its <code>vp</code> <code><a href="grid.html#topic+viewport">grid::viewport()</a></code> argument.
<code><a href="#topic+bm_flip">bm_flip()</a></code> with <code>direction</code> &quot;both&quot; and <code>in_place</code> <code>TRUE</code> can
rotate glyphs 180 degrees in place.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # as_bm_list.character()
  font_file &lt;- system.file("fonts/spleen/spleen-8x16.hex.gz", package = "bittermelon")
  font &lt;- read_hex(font_file)
  capital_r &lt;- font[[str2ucp("R")]]
  print(bm_rotate(capital_r, 90), px = px_ascii)
  print(bm_rotate(capital_r, 180), px = px_ascii)
  print(bm_rotate(capital_r, 270), px = px_ascii)
  print(bm_rotate(capital_r, 90, clockwise = FALSE), px = px_ascii)

</code></pre>

<hr>
<h2 id='bm_shadow'>Bitmap shadow, bold, and glow effects</h2><span id='topic+bm_shadow'></span><span id='topic+bm_bold'></span><span id='topic+bm_glow'></span>

<h3>Description</h3>

<p><code>bm_shadow()</code> adds a basic &quot;shadow&quot; effect to the bitmap(s).
<code>bm_bold()</code> is a variant with different defaults to create a basic &quot;bold&quot; effect.
<code>bm_glow()</code> adds a basic &quot;glow&quot; effect to the bitmap(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bm_shadow(
  bm_object,
  value = 2L,
  top = NULL,
  right = NULL,
  bottom = NULL,
  left = NULL,
  extend = TRUE
)

bm_bold(
  bm_object,
  value = 1L,
  top = NULL,
  right = NULL,
  bottom = NULL,
  left = NULL,
  extend = TRUE
)

bm_glow(bm_object, value = 2L, extend = TRUE, corner = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bm_shadow_+3A_bm_object">bm_object</code></td>
<td>
<p>Either a <code><a href="#topic+bm_bitmap">bm_bitmap()</a></code>, <code><a href="#topic+bm_list">bm_list()</a></code>,  or <code><a href="#topic+bm_font">bm_font()</a></code> object.</p>
</td></tr>
<tr><td><code id="bm_shadow_+3A_value">value</code></td>
<td>
<p>The integer value for the shadow, bold, or glow effect.</p>
</td></tr>
<tr><td><code id="bm_shadow_+3A_top">top</code></td>
<td>
<p>How many pixels above should the shadow go.</p>
</td></tr>
<tr><td><code id="bm_shadow_+3A_right">right</code></td>
<td>
<p>How many pixels right should the shadow go.
if <code>top</code>, <code>right</code>, <code>bottom</code>, and <code>left</code> are all <code>NULL</code> then defaults to <code>1L</code>.</p>
</td></tr>
<tr><td><code id="bm_shadow_+3A_bottom">bottom</code></td>
<td>
<p>How many pixels below should the shadow go.
if <code>top</code>, <code>right</code>, <code>bottom</code>, and <code>left</code> are all <code>NULL</code>
then defaults to <code>1L</code> for <code>bm_shadow()</code> and <code>0L</code> for <code>bm_embolden()</code>.</p>
</td></tr>
<tr><td><code id="bm_shadow_+3A_left">left</code></td>
<td>
<p>How many pixels left should the shadow go.</p>
</td></tr>
<tr><td><code id="bm_shadow_+3A_extend">extend</code></td>
<td>
<p>Make the bitmap larger to give the new glyph more &quot;room&quot;.</p>
</td></tr>
<tr><td><code id="bm_shadow_+3A_corner">corner</code></td>
<td>
<p>Fill in the corners.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a <code><a href="#topic+bm_bitmap">bm_bitmap()</a></code>, <code><a href="#topic+bm_list">bm_list()</a></code>, or <code><a href="#topic+bm_font">bm_font()</a></code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bm_extend">bm_extend()</a></code> and <code><a href="#topic+bm_shift">bm_shift()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> font_file &lt;- system.file("fonts/spleen/spleen-8x16.hex.gz", package = "bittermelon")
 font &lt;- read_hex(font_file)
 capital_r &lt;- font[[str2ucp("R")]]
 print(capital_r, px = px_ascii)
 print(bm_shadow(capital_r), px = px_ascii)
 print(bm_bold(capital_r), px = px_ascii)
 print(bm_glow(capital_r), px = px_ascii)
 print(bm_glow(capital_r, corner = TRUE), px = px_ascii)

</code></pre>

<hr>
<h2 id='bm_shift'>Shift elements within bitmaps</h2><span id='topic+bm_shift'></span>

<h3>Description</h3>

<p>Shifts non-padding elements within bitmaps by trimming on a specified side and padding on the other
while preserving the width and height of the original bitmap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bm_shift(
  bm_object,
  value = 0L,
  top = NULL,
  right = NULL,
  bottom = NULL,
  left = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bm_shift_+3A_bm_object">bm_object</code></td>
<td>
<p>Either a <code><a href="#topic+bm_bitmap">bm_bitmap()</a></code>, <code><a href="#topic+bm_list">bm_list()</a></code>,  or <code><a href="#topic+bm_font">bm_font()</a></code> object.</p>
</td></tr>
<tr><td><code id="bm_shift_+3A_value">value</code></td>
<td>
<p>Integer value for the new pixels.</p>
</td></tr>
<tr><td><code id="bm_shift_+3A_top">top</code></td>
<td>
<p>Number of pixels to shift towards the top side.</p>
</td></tr>
<tr><td><code id="bm_shift_+3A_right">right</code></td>
<td>
<p>Number of pixels to shift towards the right side.</p>
</td></tr>
<tr><td><code id="bm_shift_+3A_bottom">bottom</code></td>
<td>
<p>Number of pixels to shift towards the bottom side.</p>
</td></tr>
<tr><td><code id="bm_shift_+3A_left">left</code></td>
<td>
<p>Number of pixels to shift towards the left side.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a convenience wrapper around <code><a href="#topic+bm_trim">bm_trim()</a></code> and <code><a href="#topic+bm_extend">bm_extend()</a></code>.
</p>


<h3>Value</h3>

<p>Either a <code><a href="#topic+bm_bitmap">bm_bitmap()</a></code>, <code><a href="#topic+bm_list">bm_list()</a></code>, or <code><a href="#topic+bm_font">bm_font()</a></code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bm_trim">bm_trim()</a></code> and <code><a href="#topic+bm_extend">bm_extend()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> font_file &lt;- system.file("fonts/spleen/spleen-8x16.hex.gz", package = "bittermelon")
 font &lt;- read_hex(font_file)
 capital_r &lt;- font[[str2ucp("R")]]
 print(capital_r, px = c("-", "#"))
 capital_r &lt;- bm_shift(capital_r, bottom = 2L, right = 1L)
 print(capital_r, px = c("-", "#"))
</code></pre>

<hr>
<h2 id='bm_trim'>Trim bitmaps</h2><span id='topic+bm_trim'></span>

<h3>Description</h3>

<p><code>bm_trim()</code> trims <code><a href="#topic+bm_bitmap">bm_bitmap()</a></code> objects reducing the number of pixels.
The directions and amount of removed pixels are settable
(defaulting to <code>0L</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bm_trim(
  bm_object,
  sides = NULL,
  top = NULL,
  right = NULL,
  bottom = NULL,
  left = NULL,
  width = NULL,
  height = NULL,
  hjust = "center-left",
  vjust = "center-top"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bm_trim_+3A_bm_object">bm_object</code></td>
<td>
<p>Either a <code><a href="#topic+bm_bitmap">bm_bitmap()</a></code>, <code><a href="#topic+bm_list">bm_list()</a></code>,  or <code><a href="#topic+bm_font">bm_font()</a></code> object.</p>
</td></tr>
<tr><td><code id="bm_trim_+3A_sides">sides</code></td>
<td>
<p>If not <code>NULL</code> then an integer vector indicating how
many pixels to trim on all four sides.
If the integer vector is of length one it indicates the number of pixels for all four sides.
If of length two gives first the number for the vertical sides and then the horizontal sides.
If of length three gives the number of pixels for top, the horizontal sides, and then bottom sides.
If of length four gives the number of pixels for top, right, bottom, and then left sides.
This is the same scheme as used by the CSS padding and margin properties.</p>
</td></tr>
<tr><td><code id="bm_trim_+3A_top">top</code></td>
<td>
<p>How many pixels to trim the top.</p>
</td></tr>
<tr><td><code id="bm_trim_+3A_right">right</code></td>
<td>
<p>How many pixels to trim the right.</p>
</td></tr>
<tr><td><code id="bm_trim_+3A_bottom">bottom</code></td>
<td>
<p>How many pixels to trim the bottom.</p>
</td></tr>
<tr><td><code id="bm_trim_+3A_left">left</code></td>
<td>
<p>How many pixels to trim the left.</p>
</td></tr>
<tr><td><code id="bm_trim_+3A_width">width</code></td>
<td>
<p>How many pixels wide should the new bitmap be.
Use with the <code>hjust</code> argument or just one of either the <code>left</code> or <code>right</code> arguments.</p>
</td></tr>
<tr><td><code id="bm_trim_+3A_height">height</code></td>
<td>
<p>How many pixels tall should the new bitmap be.
Use with the <code>vjust</code> argument or just one of either the <code>top</code> or <code>bottom</code> arguments.</p>
</td></tr>
<tr><td><code id="bm_trim_+3A_hjust">hjust</code></td>
<td>
<p>One of &quot;left&quot;, &quot;center-left&quot;, &quot;center-right&quot;, &quot;right&quot;.
&quot;center-left&quot; and &quot;center-right&quot; will attempt to
place in &quot;center&quot; if possible but if not possible will bias
it one pixel left or right respectively.
&quot;centre&quot;, &quot;center&quot;, and &quot;centre-left&quot; are aliases for &quot;center-left&quot;.
&quot;centre-right&quot; is an alias for &quot;center-right&quot;.
Note if &quot;left&quot; we will trim on the right (and vice-versa).</p>
</td></tr>
<tr><td><code id="bm_trim_+3A_vjust">vjust</code></td>
<td>
<p>One of &quot;bottom&quot;, &quot;center-bottom&quot;, &quot;center-top&quot;, &quot;top&quot;.
&quot;center-bottom&quot; and &quot;center-top&quot; will attempt to
place in &quot;center&quot; if possible but if not possible will bias
it one pixel down or up respectively.
&quot;centre&quot;, &quot;center&quot;, and &quot;centre-top&quot; are aliases for &quot;center-top&quot;.
&quot;centre-bottom&quot; is an alias for &quot;center-bottom&quot;.
Note if &quot;top&quot; we will trim on the bottom (and vice-versa).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a <code><a href="#topic+bm_bitmap">bm_bitmap()</a></code>, <code><a href="#topic+bm_list">bm_list()</a></code>, or <code><a href="#topic+bm_font">bm_font()</a></code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bm_extend">bm_extend()</a></code>, <code><a href="#topic+bm_pad">bm_pad()</a></code>, and <code><a href="#topic+bm_resize">bm_resize()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> font_file &lt;- system.file("fonts/spleen/spleen-8x16.hex.gz", package = "bittermelon")
 font &lt;- read_hex(font_file)
 capital_r &lt;- font[[str2ucp("R")]]
 print(capital_r, px = c("-", "#"))
 capital_r_trimmed &lt;- bm_trim(capital_r, c(1, 1, 3, 0))
 print(capital_r_trimmed, px = c("-", "#"))
</code></pre>

<hr>
<h2 id='bm_widths'>Widths or heights of bitmaps</h2><span id='topic+bm_widths'></span><span id='topic+bm_heights'></span>

<h3>Description</h3>

<p><code>bm_widths()</code> returns the widths of the bitmaps while
<code>bm_heights()</code> returns the heights of the bitmaps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bm_widths(bm_object, unique = TRUE)

bm_heights(bm_object, unique = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bm_widths_+3A_bm_object">bm_object</code></td>
<td>
<p>Either a <code><a href="#topic+bm_bitmap">bm_bitmap()</a></code>, <code><a href="#topic+bm_list">bm_list()</a></code>,  or <code><a href="#topic+bm_font">bm_font()</a></code> object.</p>
</td></tr>
<tr><td><code id="bm_widths_+3A_unique">unique</code></td>
<td>
<p>Apply <code><a href="base.html#topic+unique">base::unique()</a></code> to the returned integer vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A integer vector of the relevant length of each
of the <code>bm_bitmap()</code> objects in <code>x</code>.
If <code>unique</code> is <code>TRUE</code> then any duplicates will have been removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  font_file &lt;- system.file("fonts/spleen/spleen-8x16.hex.gz", package = "bittermelon")
  font &lt;- read_hex(font_file)
  bm_widths(font) # every glyph in the font is 8 pixels wide
  bm_heights(font) # every glyph in the font is 16 pixels high
</code></pre>

<hr>
<h2 id='c.bm_bitmap'>Combine bitmap objects</h2><span id='topic+c.bm_bitmap'></span><span id='topic+c.bm_font'></span><span id='topic+c.bm_list'></span>

<h3>Description</h3>

<p><code>c()</code> combines bitmap objects into <code>bm_list()</code> or <code>bm_font()</code> objects.
In particular when using it to combine fonts the later fonts
&quot;update&quot; the glyphs in the earlier fonts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bm_bitmap'
c(...)

## S3 method for class 'bm_font'
c(...)

## S3 method for class 'bm_list'
c(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c.bm_bitmap_+3A_...">...</code></td>
<td>
<p><code><a href="#topic+bm_bitmap">bm_bitmap()</a></code>, <code><a href="#topic+bm_list">bm_list()</a></code>, and/or <code><a href="#topic+bm_font">bm_font()</a></code> objects to combine.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The various bitmap objects are &quot;reduced&quot; in the following ways:
</p>

<table>
<tr>
 <td style="text-align: left;">
First </td><td style="text-align: left;"> Second </td><td style="text-align: left;"> Result</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>bm_bitmap()</code> </td><td style="text-align: left;"> <code>bm_bitmap()</code> </td><td style="text-align: left;"> <code>bm_list()</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>bm_bitmap()</code> </td><td style="text-align: left;"> <code>bm_list()</code> </td><td style="text-align: left;"> <code>bm_list()</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>bm_bitmap()</code> </td><td style="text-align: left;"> <code>bm_font()</code> </td><td style="text-align: left;"> <code>bm_font()</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>bm_list()</code> </td><td style="text-align: left;"> <code>bm_bitmap()</code> </td><td style="text-align: left;"> <code>bm_list()</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>bm_list()</code> </td><td style="text-align: left;"> <code>bm_list()</code> </td><td style="text-align: left;"> <code>bm_list()</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>bm_list()</code> </td><td style="text-align: left;"> <code>bm_font()</code> </td><td style="text-align: left;"> <code>bm_font()</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>bm_font()</code> </td><td style="text-align: left;"> <code>fm_bitmap()</code> </td><td style="text-align: left;"> <code>bm_font()</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>bm_font()</code> </td><td style="text-align: left;"> <code>fm_list()</code> </td><td style="text-align: left;"> <code>bm_font()</code></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>bm_font()</code> </td><td style="text-align: left;"> <code>fm_font()</code> </td><td style="text-align: left;"> <code>bm_font()</code></td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>When combining with a <code>bm_font()</code> object if any <code>bm_bitmap()</code> objects
share the same name we only keep the last one.
Although names are preserved other attributes such as font
comments and properties are not guaranteed to be preserved.
</p>


<h3>Value</h3>

<p>Either a <code><a href="#topic+bm_list">bm_list()</a></code> or <code><a href="#topic+bm_font">bm_font()</a></code> object.
See Details for more info.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>font_file &lt;- system.file("fonts/spleen/spleen-8x16.hex.gz", package = "bittermelon")
font &lt;- read_hex(font_file)
capital_r &lt;- font[[str2ucp("R")]]
stats &lt;- as_bm_list("STATS", font = font)
is_bm_list(c(capital_r, capital_r))
rstats &lt;- c(capital_r, stats)
print(bm_call(rstats, cbind), px = px_ascii)
</code></pre>

<hr>
<h2 id='cbind.bm_bitmap'>Combine bitmaps by rows or columns</h2><span id='topic+cbind.bm_bitmap'></span><span id='topic+rbind.bm_bitmap'></span>

<h3>Description</h3>

<p><code>cbind.bm_bitmap()</code> and <code>rbind.bm_bitmap()</code> combine
by columns or rows respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bm_bitmap'
cbind(..., direction = "left-to-right", vjust = "center-top")

## S3 method for class 'bm_bitmap'
rbind(..., direction = "top-to-bottom", hjust = "center-left")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cbind.bm_bitmap_+3A_...">...</code></td>
<td>
<p><code><a href="#topic+bm_bitmap">bm_bitmap()</a></code> objects.</p>
</td></tr>
<tr><td><code id="cbind.bm_bitmap_+3A_direction">direction</code></td>
<td>
<p>For <code style="white-space: pre;">&#8288;cbind().bm_bitmap&#8288;</code> either &quot;left-to-right&quot; (default) or its aliases &quot;ltr&quot; and &quot;lr&quot;
OR &quot;right-to-left&quot; or its aliases &quot;rtl&quot; and &quot;rl&quot;.
For <code style="white-space: pre;">&#8288;rbind().bm_bitmap&#8288;</code> either &quot;top-to-bottom&quot; (default) or its aliases &quot;ttb&quot; and &quot;tb&quot;
OR &quot;bottom-to-top&quot; or its aliases &quot;btt&quot; and &quot;bt&quot;.
The <code>direction</code> argument is not case-sensitive.</p>
</td></tr>
<tr><td><code id="cbind.bm_bitmap_+3A_vjust">vjust</code></td>
<td>
<p>Used by <code><a href="#topic+bm_extend">bm_extend()</a></code> if bitmap heights are different.</p>
</td></tr>
<tr><td><code id="cbind.bm_bitmap_+3A_hjust">hjust</code></td>
<td>
<p>Used by <code><a href="#topic+bm_extend">bm_extend()</a></code> if bitmap widths are different.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+bm_bitmap">bm_bitmap()</a></code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  font_file &lt;- system.file("fonts/spleen/spleen-8x16.hex.gz", package = "bittermelon")
  font &lt;- read_hex(font_file)
  capital_b &lt;- font[[str2ucp("B")]]
  capital_m &lt;- font[[str2ucp("M")]]
  cbm &lt;- cbind(capital_b, capital_m)
  print(cbm, px = c(".", "#"))
  cbm_rl &lt;- cbind(capital_b, capital_m, direction = "right-to-left")
  print(cbm_rl, px = c(".", "#"))
  rbm &lt;- rbind(capital_b, capital_m)
  print(rbm, px = c(".", "#"))
  rbm_bt &lt;- rbind(capital_b, capital_m, direction = "bottom-to-top")
  print(rbm_bt, px = c(".", "#"))
</code></pre>

<hr>
<h2 id='hex2ucp'>Get Unicode code points</h2><span id='topic+hex2ucp'></span><span id='topic+int2ucp'></span><span id='topic+str2ucp'></span><span id='topic+name2ucp'></span><span id='topic+is_ucp'></span><span id='topic+block2ucp'></span><span id='topic+range2ucp'></span>

<h3>Description</h3>

<p><code>hex2ucp()</code>, <code>int2ucp()</code>, <code>name2ucp()</code>, and <code>str2ucp()</code> return
Unicode code points as character vectors. <code>is_ucp()</code> returns
<code>TRUE</code> if a valid Unicode code point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hex2ucp(x)

int2ucp(x)

str2ucp(x)

name2ucp(x, type = c("exact", "grep"), ...)

is_ucp(x)

block2ucp(x, omit_unnamed = TRUE)

range2ucp(x, omit_unnamed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hex2ucp_+3A_x">x</code></td>
<td>
<p>R objects coercible to the respective Unicode character data types.
See <code><a href="Unicode.html#topic+u_char_basics">Unicode::as.u_char()</a></code> for <code>hex2ucp()</code> and <code>int2ucp()</code>,
<code><a href="base.html#topic+utf8Conversion">base::utf8ToInt()</a></code> for <code>str2ucp()</code>,
<code><a href="Unicode.html#topic+u_char_names">Unicode::u_char_from_name()</a></code> for <code>name2ucp()</code>,
<code><a href="Unicode.html#topic+u_char_basics">Unicode::as.u_char_range()</a></code> for <code>range2ucp()</code>,
and <code><a href="Unicode.html#topic+u_blocks">Unicode::u_blocks()</a></code> for <code>block2ucp()</code>.</p>
</td></tr>
<tr><td><code id="hex2ucp_+3A_type">type</code></td>
<td>
<p>one of <code>"exact"</code> or <code>"grep"</code>, or an abbreviation
thereof.
</p>
</td></tr>
<tr><td><code id="hex2ucp_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code><a href="base.html#topic+grepl">grepl</a></code> when using
this for pattern matching.
</p>
</td></tr>
<tr><td><code id="hex2ucp_+3A_omit_unnamed">omit_unnamed</code></td>
<td>
<p>Omit control codes or unassigned code points</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>hex2ucp(x)</code> is a wrapper for <code>as.character(Unicode::as.u_char(x))</code>.
<code>int2ucp</code> is a wrapper for <code>as.character(Unicode::as.u_char(as.integer(x)))</code>.
<code>str2ucp(x)</code> is a wrapper for <code>as.character(Unicode::as.u_char(utf8ToInt(x)))</code>.
<code>name2ucp(x)</code> is a wrapper for <code>as.character(Unicode::u_char_from_name(x))</code>.
However missing values are coerced to <code>NA_character_</code> instead of <code>"&lt;NA&gt;"</code>.
Note the names of <code>bm_font()</code> objects must be character vectors as returned
by these functions and not <code>Unicode::u_char</code> objects.
</p>


<h3>Value</h3>

<p>A character vector of Unicode code points.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ucp2label">ucp2label()</a></code> and <code><a href="#topic+is_combining_character">is_combining_character()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # These are all different ways to get the same 'R' code point
  hex2ucp("52")
  hex2ucp(as.hexmode("52"))
  hex2ucp("0052")
  hex2ucp("U+0052")
  hex2ucp("0x0052")
  int2ucp(82) # 82 == as.hexmode("52")
  int2ucp("82") # 82 == as.hexmode("52")
  int2ucp(utf8ToInt("R"))
  ucp2label("U+0052")
  name2ucp("LATIN CAPITAL LETTER R")
  str2ucp("R")

  # Potential gotcha as as.hexmode("52") == as.integer("82") == 52L
  all.equal(hex2ucp(52L), int2ucp(52L)) # TRUE
  all.equal(hex2ucp("52"), int2ucp("82")) # TRUE
  all.equal(hex2ucp("82"), int2ucp("82")) # FALSE

  block2ucp("Basic Latin")
  block2ucp("Basic Latin", omit_unnamed = FALSE)
  range2ucp("U+0020..U+0030")

</code></pre>

<hr>
<h2 id='is_bm_bitmap'>Test if the object is a bitmap glyph object</h2><span id='topic+is_bm_bitmap'></span>

<h3>Description</h3>

<p><code>is_bm_bitmap()</code> returns <code>TRUE</code> for <code>bm_bitmap</code> objects (or subclasses)
and <code>FALSE</code> for all other objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_bm_bitmap(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_bm_bitmap_+3A_x">x</code></td>
<td>
<p>An object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> or <code>FALSE</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bm_bitmap">bm_bitmap()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> space_matrix &lt;- matrix(0L, nrow = 16L, ncol = 16L)
 is_bm_bitmap(space_matrix)
 space_glyph &lt;- bm_bitmap(space_matrix)
 is_bm_bitmap(space_glyph)
</code></pre>

<hr>
<h2 id='is_bm_font'>Test if the object is a bitmap font object</h2><span id='topic+is_bm_font'></span>

<h3>Description</h3>

<p><code>is_bm_font()</code> returns <code>TRUE</code> for <code>bm_font</code> objects (or subclasses)
and <code>FALSE</code> for all other objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_bm_font(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_bm_font_+3A_x">x</code></td>
<td>
<p>An object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> or <code>FALSE</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bm_font">bm_font()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> font_file &lt;- system.file("fonts/spleen/spleen-8x16.hex.gz", package = "bittermelon")
 font &lt;- read_hex(font_file)
 is_bm_font(font)
</code></pre>

<hr>
<h2 id='is_bm_list'>Test if the object is a bitmap glyph list object</h2><span id='topic+is_bm_list'></span>

<h3>Description</h3>

<p><code>is_bm_list()</code> returns <code>TRUE</code> for <code><a href="#topic+bm_list">bm_list()</a></code> objects (or subclasses)
and <code>FALSE</code> for all other objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_bm_list(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_bm_list_+3A_x">x</code></td>
<td>
<p>An object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> or <code>FALSE</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bm_list">bm_list()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> font_file &lt;- system.file("fonts/spleen/spleen-8x16.hex.gz", package = "bittermelon")
 font &lt;- read_hex(font_file)
 is_bm_font(font)
</code></pre>

<hr>
<h2 id='Ops.bm_bitmap'>S3 Ops group generic methods for bitmap objects</h2><span id='topic+Ops.bm_bitmap'></span><span id='topic+Ops.bm_list'></span><span id='topic+which'></span><span id='topic+which.default'></span><span id='topic+which.bm_bitmap'></span>

<h3>Description</h3>

<p>The S3 Ops group generic methods for <code>bm_bitmap()</code> objects
are simply the result of the generic integer matrix method
cast back to a binary <code>bm_bitmap()</code> object (which
is an integer matrix of ones and zeros).
The S3 Ops group generic methods for <code>bm_list()</code>
and <code>bm_font()</code> objects simply returns another object
with that operator applied to every bitmap in the original object.
Since <code><a href="base.html#topic+which">base::which()</a></code> does not automatically cast
its argument to a logical value we also redefine it as a generic
and besides a default method which simply calls <code>base:which()</code> we
offer a <code>which.bm_bitmap()</code> method that first
casts the bitmap to logical before calling <code>base::which()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bm_bitmap'
Ops(e1, e2)

## S3 method for class 'bm_list'
Ops(e1, e2)

which(x, arr.ind = FALSE, useNames = TRUE)

## Default S3 method:
which(x, arr.ind = FALSE, useNames = TRUE)

## S3 method for class 'bm_bitmap'
which(x, arr.ind = FALSE, useNames = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ops.bm_bitmap_+3A_e1">e1</code>, <code id="Ops.bm_bitmap_+3A_e2">e2</code></td>
<td>
<p>objects.</p>
</td></tr>
<tr><td><code id="Ops.bm_bitmap_+3A_x">x</code></td>
<td>
<p>a <code><a href="base.html#topic+logical">logical</a></code> vector or array.  <code><a href="base.html#topic+NA">NA</a></code>s
are allowed and omitted (treated as if <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="Ops.bm_bitmap_+3A_arr.ind">arr.ind</code></td>
<td>
<p>logical; should <b>arr</b>ay <b>ind</b>ices be returned
when <code>x</code> is an array?  Anything other than a single true value
is treated as false.</p>
</td></tr>
<tr><td><code id="Ops.bm_bitmap_+3A_usenames">useNames</code></td>
<td>
<p>logical indicating if the value of <code>arrayInd()</code>
should have (non-null) dimnames at all.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>which.bm_bitmap()</code> returns a logical vector.
The various <code>Ops.bm_bitmap</code> methods return a <code><a href="#topic+bm_bitmap">bm_bitmap()</a></code> object.
The various <code>Ops.bm_list</code> methods return a <code><a href="#topic+bm_list">bm_list()</a></code> object.
</p>


<h3>See Also</h3>

<p><a href="base.html#topic+groupGeneric">base::Ops</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  font_file &lt;- system.file("fonts/spleen/spleen-8x16.hex.gz", package = "bittermelon")
  font &lt;- read_hex(font_file)

  # Examples applied to individual bitmaps
  capital_r &lt;- font[[str2ucp("R")]]
  print(!capital_r, px = px_ascii)
  capital_b &lt;- font[[str2ucp("B")]]
  print(capital_r &amp; capital_b, px = px_ascii)
  print(capital_r | capital_b, px = px_ascii)
  print(capital_r + 1L, px = px_ascii)
  print(capital_r + 1L &gt; 1L, px = px_ascii)
  which(capital_r &gt; 0L)

  # Examples applied to `bm_list()` objects
  bml &lt;- font[c("U+0023", "U+0052", "U+0053", "U+0054", "U+0041", "U+0054", "U+0053")] # #RSTATS
  bml &lt;- as_bm_list(bml)
  bm &lt;- do.call(cbind, bml)
  print(bm, px = px_ascii)

  bml &lt;- !bml
  bm &lt;- do.call(cbind, bml)
  print(bm, px = px_ascii)

  bml &lt;- 2 * (bml + 1L)
  bm &lt;- do.call(cbind, bml)
  print(bm, px = px_ascii)

</code></pre>

<hr>
<h2 id='plot.bm_bitmap'>Plot bitmap object</h2><span id='topic+plot.bm_bitmap'></span><span id='topic+as.raster.bm_bitmap'></span>

<h3>Description</h3>

<p><code>plot.bm_bitmap()</code> plots a bitmap object to the graphics device.
It is a wrapper around <code>grid::grid.raster()</code> and <code>as.raster.bm_bitmap()</code>
which converts a bitmap glyph object to a raster object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bm_bitmap'
plot(x, ..., col = c("grey80", "black", "grey40"), interpolate = FALSE)

## S3 method for class 'bm_bitmap'
as.raster(x, ..., col = c("grey80", "black", "grey40"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bm_bitmap_+3A_x">x</code></td>
<td>
<p>A <code>bm_bitmap()</code> object</p>
</td></tr>
<tr><td><code id="plot.bm_bitmap_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="grid.html#topic+grid.raster">grid::grid.raster()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.bm_bitmap_+3A_col">col</code></td>
<td>
<p>Character vector of R color specifications.</p>
</td></tr>
<tr><td><code id="plot.bm_bitmap_+3A_interpolate">interpolate</code></td>
<td>
<p>Passed to <code><a href="grid.html#topic+grid.raster">grid::grid.raster()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>grid</code> rastergrob grob object silently.
As a side effect will draw to graphics device.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bm_bitmap">bm_bitmap()</a></code>, <code><a href="#topic+as.raster.bm_bitmap">as.raster.bm_bitmap()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  font_file &lt;- system.file("fonts/spleen/spleen-8x16.hex.gz", package = "bittermelon")
  font &lt;- read_hex(font_file)
  capital_r &lt;- bm_extend(font[[str2ucp("R")]], left = 1L)
  capital_r &lt;- bm_extend(capital_r, sides = 1L, value = 2L)  # add a border effect

  plot(capital_r)

  grid::grid.newpage()
  plot(capital_r, col = c("yellow", "blue", "red"))
</code></pre>

<hr>
<h2 id='print.bm_bitmap'>Print bitmap objects</h2><span id='topic+print.bm_bitmap'></span><span id='topic+format.bm_bitmap'></span><span id='topic+px_unicode'></span><span id='topic+px_ascii'></span>

<h3>Description</h3>

<p><code>print.bm_bitmap()</code> prints a representation of bitmap objects to the terminal.
It is a wrapper around <code>format.bm_bitmap()</code> which converts bitmap objects
to a character vector.
<code>px_unicode</code> and <code>px_ascii</code> are builtin character vectors intended for use with the <code>px</code>
argument (the former contains Unicode &ldquo;Block Elements&rdquo; while the latter is purely ASCII).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bm_bitmap'
print(x, ..., px = getOption("bittermelon.px", px_unicode),
                                 fg = getOption("bittermelon.fg", FALSE),
                                 bg = getOption("bittermelon.bg", FALSE),
                                 compress = getOption("bittermelon.compress", "none"))

## S3 method for class 'bm_bitmap'
format(x, ..., px = getOption("bittermelon.px", px_unicode),
                                 fg = getOption("bittermelon.fg", FALSE),
                                 bg = getOption("bittermelon.bg", FALSE),
                                 compress = getOption("bittermelon.compress", "none"))

px_unicode

px_ascii
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.bm_bitmap_+3A_x">x</code></td>
<td>
<p>A <code>bm_bitmap()</code> object</p>
</td></tr>
<tr><td><code id="print.bm_bitmap_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="print.bm_bitmap_+3A_px">px</code></td>
<td>
<p>Character vector of the pixel to use for each integer value i.e.
The first character for integer <code>0L</code>,
the second character for integer <code>1L</code>, and so on.
Will be recycled.</p>
</td></tr>
<tr><td><code id="print.bm_bitmap_+3A_fg">fg</code></td>
<td>
<p>R color strings of foreground colors to use.
Requires suggested package <code>crayon</code>.
<code>FALSE</code> (default) for no foreground colors.
Will be recycled.</p>
</td></tr>
<tr><td><code id="print.bm_bitmap_+3A_bg">bg</code></td>
<td>
<p>R color strings of background colors to use.
Requires suggested package <code>crayon</code>.
<code>FALSE</code> (default) for no background colors.
Will be recycled.</p>
</td></tr>
<tr><td><code id="print.bm_bitmap_+3A_compress">compress</code></td>
<td>
<p>If <code>none</code> (default) don't compress first with <code><a href="#topic+bm_compress">bm_compress()</a></code>.
Otherwise compress first with <code><a href="#topic+bm_compress">bm_compress()</a></code> passing
the value of <code>compress</code> as its <code>direction</code> argument
(i.e. either &quot;vertical&quot; or &quot;v&quot;, &quot;horizontal&quot; or &quot;h&quot;,
OR &quot;both&quot; or &quot;b&quot;).</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 20.
</p>
<p>An object of class <code>character</code> of length 20.
</p>


<h3>Value</h3>

<p>A character vector of the string representation (<code>print.bm_bitmap()</code> does this invisibly).
As a side effect <code>print.bm_bitmap()</code> prints out the string representation to the terminal.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bm_bitmap">bm_bitmap()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  font_file &lt;- system.file("fonts/spleen/spleen-8x16.hex.gz", package = "bittermelon")
  font &lt;- read_hex(font_file)
  bm_R &lt;- font[[str2ucp("R")]]
  print(bm_R, px = c(" ", "#"))

  bm_8 &lt;- font[[str2ucp("8")]]
  bm_8_with_border &lt;- bm_extend(bm_extend(bm_8, left = 1L),
                                sides = 1L, value = 2L)
  print(bm_8_with_border, px = c(".", "@", "X"))

  if (require("crayon") &amp;&amp; crayon::has_color()) {
    print(bm_8_with_border, px = " ", bg = c("white", "blue", "red"))
  }
</code></pre>

<hr>
<h2 id='read_hex'>Read and write hex bitmap font files</h2><span id='topic+read_hex'></span><span id='topic+write_hex'></span>

<h3>Description</h3>

<p><code>read_hex()</code> reads in hex format bitmap font files
as a <code><a href="#topic+bm_font">bm_font()</a></code> object while <code>write_hex()</code> writes a <code><a href="#topic+bm_font">bm_font()</a></code> object
as a hex format bitmap font file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_hex(con, ucp = NULL)

write_hex(font, con = stdout())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_hex_+3A_con">con</code></td>
<td>
<p>A connection object or a character string of a filename.
See <code><a href="base.html#topic+readLines">base::readLines()</a></code> or <code><a href="base.html#topic+writeLines">base::writeLines()</a></code> for more info.
If it is a connection it will be explicitly closed.</p>
</td></tr>
<tr><td><code id="read_hex_+3A_ucp">ucp</code></td>
<td>
<p>Character vector of Unicode Code Points: glyphs not in this vector won't be read in.
If <code>NULL</code> (default) read every glyph in the font.</p>
</td></tr>
<tr><td><code id="read_hex_+3A_font">font</code></td>
<td>
<p>A <code><a href="#topic+bm_font">bm_font()</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>read_hex()</code> returns a <code><a href="#topic+bm_font">bm_font()</a></code> object.
<code>write_hex()</code> returns invisibly a character vector of the contents
of the hex font file it wrote to <code>con</code> as a side effect.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bm_font">bm_font()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> font_file &lt;- system.file("fonts/spleen/spleen-8x16.hex.gz", package = "bittermelon")
 font &lt;- read_hex(font_file)
 capital_r &lt;- font[[str2ucp("R")]]
 print(capital_r, px = px_ascii)

 filename &lt;- tempfile(fileext = ".hex.gz")
 write_hex(font, gzfile(filename))

 font &lt;- read_hex(font_file, ucp = block2ucp("Basic Latin"))
 capital_r &lt;- font[[str2ucp("R")]]
 print(capital_r, px = px_ascii)
</code></pre>

<hr>
<h2 id='read_monobit'>Read and write bitmap font files using monobit</h2><span id='topic+read_monobit'></span><span id='topic+write_monobit'></span><span id='topic+update_monobit'></span>

<h3>Description</h3>

<p><code>read_monobit()</code> reads in bitmap font file as a <code><a href="#topic+bm_font">bm_font()</a></code> object while <code>write_monobit()</code>
writes a <code><a href="#topic+bm_font">bm_font()</a></code> object as a bitmap font file.
It uses the file extension to determine the appropriate bitmap font format to use.
<code>update_monobit()</code> downloads an updated version of <code>monobit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_monobit(
  file,
  quietly = FALSE,
  monobit_path = getOption("bittermelon.monobit_path", NULL)
)

write_monobit(
  font,
  file,
  quietly = FALSE,
  monobit_path = getOption("bittermelon.monobit_path", NULL)
)

update_monobit(site = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_monobit_+3A_file">file</code></td>
<td>
<p>A character string of a filename.</p>
</td></tr>
<tr><td><code id="read_monobit_+3A_quietly">quietly</code></td>
<td>
<p>If <code>TRUE</code> suppress any standard output/error from <code>monobit</code>.</p>
</td></tr>
<tr><td><code id="read_monobit_+3A_monobit_path">monobit_path</code></td>
<td>
<p>Which directory containing <code>monobit</code> to use.
Default will be to look in <code>file.path(rappdirs::user_config_dir("bittermelon"), "monobit")</code>,
<code>file.path(rappdirs::site_config_dir("bittermelon"), "monobit")</code>, and
<code>system.file("monobit", package = "bittermelon")</code> (in that order).</p>
</td></tr>
<tr><td><code id="read_monobit_+3A_font">font</code></td>
<td>
<p>A <code><a href="#topic+bm_font">bm_font()</a></code> object.</p>
</td></tr>
<tr><td><code id="read_monobit_+3A_site">site</code></td>
<td>
<p>If <code>TRUE</code> try to install into <code>rappdirs::site_config_dir("bittermelon")</code>
instead of <code>rappdirs::user_config_dir("bittermelon")</code>.
Note this may require administrator privileges.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>read_monobit()</code> and <code>write_monobit()</code> require Python v3.6 or greater available on the system.
<code>read_monobit()</code> and <code>write_monobit()</code> uses <code>monobit</code>'s <code>convert.py</code> script to convert to/from
the yaff font format which this package can natively read/write from/to.
This package embeds an older, smaller version of <code>monobit</code>.
Use <code>update_monobit()</code> to download a newer, better version of <code>monobit</code>
(which unfortunately is too large to embed within this package).
</p>


<h3>Value</h3>

<p><code>read_monobit()</code> returns a <code><a href="#topic+bm_font">bm_font()</a></code> object.  <code>write_monobit()</code> returns <code>NULL</code> invisibly and
as a side effect writes <code>file</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bm_font">bm_font()</a></code> for more information about bitmap font objects.
<code><a href="#topic+read_hex">read_hex()</a></code>, <code><a href="#topic+write_hex">write_hex()</a></code>, <code><a href="#topic+read_yaff">read_yaff()</a></code>, <code><a href="#topic+write_yaff">write_yaff()</a></code> for pure R bitmap font readers and writers.
For more information about <code>monobit</code> see <a href="https://github.com/robhagemans/monobit">https://github.com/robhagemans/monobit</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
 if (findpython::can_find_python_cmd(minimum_version = "3.6")) {
   try({
     font_file &lt;- system.file("fonts/spleen/spleen-8x16.hex.gz", package = "bittermelon")
     tempfile &lt;- tempfile(fileext = ".hex")
     writeLines(readLines(font_file), tempfile)

     font &lt;- read_monobit(tempfile)
     capital_r &lt;- font[[str2ucp("R")]]
     print(capital_r, px = c(".", "#"))

     filename &lt;- tempfile(fileext = ".yaff")
     write_monobit(font, filename)
   })
 }
 
</code></pre>

<hr>
<h2 id='read_yaff'>Read and write yaff bitmap font files</h2><span id='topic+read_yaff'></span><span id='topic+write_yaff'></span>

<h3>Description</h3>

<p><code>read_yaff()</code> reads in yaff format bitmap font files
as a <code><a href="#topic+bm_font">bm_font()</a></code> object while <code>write_yaff()</code> writes a <code><a href="#topic+bm_font">bm_font()</a></code> object
as a yaff format bitmap font file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_yaff(con)

write_yaff(font, con = stdout())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_yaff_+3A_con">con</code></td>
<td>
<p>A connection object or a character string of a filename.
See <code><a href="base.html#topic+readLines">base::readLines()</a></code> or <code><a href="base.html#topic+writeLines">base::writeLines()</a></code> for more info.
If it is a connection it will be explicitly closed.</p>
</td></tr>
<tr><td><code id="read_yaff_+3A_font">font</code></td>
<td>
<p>A <code><a href="#topic+bm_font">bm_font()</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>read_yaff()</code> returns a <code><a href="#topic+bm_font">bm_font()</a></code> object.
<code>write_yaff()</code> returns invisibly a character vector of the contents
of the yaff font file it wrote to <code>con</code> as a side effect.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bm_font">bm_font()</a></code> for information about bitmap font objects.
For more information about yaff font format see <a href="https://github.com/robhagemans/monobit#the-yaff-format">https://github.com/robhagemans/monobit#the-yaff-format</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
 font_file &lt;- system.file("fonts/fixed/4x6.yaff.gz", package = "bittermelon")
 font &lt;- read_yaff(font_file)
 capital_r &lt;- font[[str2ucp("R")]]
 print(capital_r, px = c(".", "#"))

 filename &lt;- tempfile(fileext = ".yaff")
 write_yaff(font, filename)
 
</code></pre>

<hr>
<h2 id='Summary.bm_list'>max, min, and range for bitmap objects</h2><span id='topic+Summary.bm_list'></span>

<h3>Description</h3>

<p><code>max()</code>, <code>min()</code>, and <code>range()</code> will provide the  maximum and minimum
integer values found in the <code>bm_bitmap()</code>, <code>bm_list()</code>, or <code>bm_list()</code> objects.
The other four S3 <a href="base.html#topic+groupGeneric">base::Summary</a> methods - <code>all()</code>, <code>any()</code>, <code>sum</code>, and <code>prod</code> -
are only supported for <code>bm_bitmap()</code> objects
(which are subclasses of integer matrices).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bm_list'
Summary(..., na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Summary.bm_list_+3A_...">...</code></td>
<td>
<p>Passed to relevant functions.</p>
</td></tr>
<tr><td><code id="Summary.bm_list_+3A_na.rm">na.rm</code></td>
<td>
<p>Passed to <code>min()</code> and <code>max()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  font_file &lt;- system.file("fonts/spleen/spleen-8x16.hex.gz", package = "bittermelon")
  font &lt;- read_hex(font_file)
  min(font)
  max(font)
  range(font)
</code></pre>

<hr>
<h2 id='ucp2label'>Other Unicode utilities</h2><span id='topic+ucp2label'></span><span id='topic+ucp_sort'></span><span id='topic+is_combining_character'></span>

<h3>Description</h3>

<p><code>ucp2label()</code> returns Unicode code point &ldquo;labels&rdquo; as a character vector.
<code>ucp_sort()</code> sorts Unicode code points.
<code>is_combining_character()</code> returns <code>TRUE</code> if the character is a &ldquo;combining&rdquo; character.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ucp2label(x)

ucp_sort(x, decreasing = FALSE)

is_combining_character(x, pua_combining = character(0))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ucp2label_+3A_x">x</code></td>
<td>
<p>A character vector of Unicode code points.</p>
</td></tr>
<tr><td><code id="ucp2label_+3A_decreasing">decreasing</code></td>
<td>
<p>If <code>TRUE</code> do a decreasing sort.</p>
</td></tr>
<tr><td><code id="ucp2label_+3A_pua_combining">pua_combining</code></td>
<td>
<p>Additional Unicode code points to be considered
as a &ldquo;combining&rdquo; character such as characters
defined in the Private Use Area (PUA) of a font.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ucp2label()</code> returns a character vector of Unicode labels.
<code>ucp_sort()</code> returns a character vector of Unicode code points.
<code>is_combining_character()</code> returns a logical vector.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+block2ucp">block2ucp()</a></code>, <code><a href="#topic+hex2ucp">hex2ucp()</a></code>, <code><a href="#topic+int2ucp">int2ucp()</a></code>, <code><a href="#topic+name2ucp">name2ucp()</a></code>, <code><a href="#topic+range2ucp">range2ucp()</a></code>, and <code><a href="#topic+str2ucp">str2ucp()</a></code>
all return Unicode code points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Get the Unicode Code Point "label" for "R"
  ucp2label(str2ucp("R"))

  is_combining_character(str2ucp("a"))
  is_combining_character("U+0300") # COMBINING GRAVE ACCENT
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
