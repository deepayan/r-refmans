<!DOCTYPE html><html><head><title>Help for package vipor</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {vipor}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aveWithArgs'><p>the ave() function but with arguments passed to FUN</p></a></li>
<li><a href='#counties'><p>Census ata on US counties</p></a></li>
<li><a href='#digits2number'><p>Convert a vector of integers representing digits in an arbitrary base to an integer</p></a></li>
<li><a href='#generatePermuteString'><p>Generate a permutation string meeting Tukey criteria</p></a></li>
<li><a href='#integrations'><p>Data on HIV integration sites from several studies</p></a></li>
<li><a href='#number2digits'><p>Convert an integer to an arbitrary base</p></a></li>
<li><a href='#offsetX'><p>Offset data using quasirandom noise to avoid overplotting</p></a></li>
<li><a href='#permute'><p>Return all permutations of a vector</p></a></li>
<li><a href='#topBottomDistribute'><p>Produce offsets such that points are sorted with most extreme values to right and left</p></a></li>
<li><a href='#tukeyPermutes'><p>Find permutations meeting Tukey criteria</p></a></li>
<li><a href='#tukeyT'><p>Combine multiple permutation strings into one</p></a></li>
<li><a href='#tukeyTexture'><p>Generate random positions based on Tukey texture algorithm</p></a></li>
<li><a href='#vanDerCorput'><p>Generate van der Corput sequences</p></a></li>
<li><a href='#vipor'><p>Functions to generate violin scatter plots</p></a></li>
<li><a href='#vpPlot'><p>Plot data using offsets by quasirandom noise to generate a violin point plot</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Plot Categorical Data Using Quasirandom Noise and Density
Estimates</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-15</td>
</tr>
<tr>
<td>Author:</td>
<td>Scott Sherrill-Mix, Erik Clarke</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Scott Sherrill-Mix &lt;ssm@msu.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Generate a violin point plot, a combination of a violin/histogram
    plot and a scatter plot by offsetting points within a category based on their
    density using quasirandom noise.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>True</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, beeswarm, lattice, ggplot2, beanplot, vioplot,
ggbeeswarm,</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-16 03:56:56 UTC; scott</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-18 14:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='aveWithArgs'>the ave() function but with arguments passed to FUN</h2><span id='topic+aveWithArgs'></span>

<h3>Description</h3>

<p>A function is applied to subsets of <code>x</code> where each subset consist of those observations with the same groupings in <code>y</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aveWithArgs(x, y, FUN = mean, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aveWithArgs_+3A_x">x</code></td>
<td>
<p>a vector to apply FUN to</p>
</td></tr>
<tr><td><code id="aveWithArgs_+3A_y">y</code></td>
<td>
<p>a vector or list of vectors of grouping variables all of the same length as <code>x</code></p>
</td></tr>
<tr><td><code id="aveWithArgs_+3A_fun">FUN</code></td>
<td>
<p>function to apply for each factor level combination.</p>
</td></tr>
<tr><td><code id="aveWithArgs_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>FUN</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of the same length as <code>x</code> where an each element contains the output from <code>FUN</code> after <code>FUN</code> was applied on the corresponding subgroup for that element (repeated if necessary within a subgroup).
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+ave">ave</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aveWithArgs(1:10,rep(1:5,2))
aveWithArgs(c(1:9,NA),rep(1:5,2),max,na.rm=TRUE)
</code></pre>

<hr>
<h2 id='counties'>Census ata on US counties</h2><span id='topic+counties'></span>

<h3>Description</h3>

<p>A dataset containing data from the US census burea
</p>


<h3>Usage</h3>

<pre><code class='language-R'>counties
</code></pre>


<h3>Format</h3>

<p>A data frame with 3143 rows and 8 variables:
</p>

<dl>
<dt>id</dt><dd><p>GEO.id from original data</p>
</dd>
<dt>state</dt><dd><p>state in which the county is located</p>
</dd>
<dt>county</dt><dd><p>name of the county</p>
</dd>
<dt>population</dt><dd><p>population of the county</p>
</dd>
<dt>housingUnits</dt><dd><p>housing units in the county</p>
</dd>
<dt>totalArea</dt><dd><p>Area in square miles - Total area</p>
</dd>
<dt>waterArea</dt><dd><p>Area in square miles - Water area</p>
</dd>
<dt>landArea</dt><dd><p>Area in square miles - Land area</p>
</dd>
</dl>



<h3>Source</h3>

<p>http://factfinder.census.gov/bkmk/table/1.0/en/DEC/10_SF1/GCTPH1.US05PR (link now dead), system.file(&quot;data-raw&quot;, &quot;makeCounties.R&quot;, package = &quot;vipor&quot;)
</p>


<h3>References</h3>

<p><a href="https://web.archive.org/web/20150326040847/https://www.census.gov/prod/cen2010/cph-2-1.pdf">https://web.archive.org/web/20150326040847/https://www.census.gov/prod/cen2010/cph-2-1.pdf</a>
</p>

<hr>
<h2 id='digits2number'>Convert a vector of integers representing digits in an arbitrary base to an integer</h2><span id='topic+digits2number'></span>

<h3>Description</h3>

<p>Takes a vector of integers representing digits in an arbitrary base e.g. binary or octal and converts it into an integer (or the integer divided by base^length(digits) for the number of digits if fractional is TRUE). Note that the first digit in the input is the least significant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>digits2number(digits, base = 2, fractional = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="digits2number_+3A_digits">digits</code></td>
<td>
<p>a vector of integers representing digits in an arbitrary base</p>
</td></tr>
<tr><td><code id="digits2number_+3A_base">base</code></td>
<td>
<p>the base for the numeral system (e.g. 2 for binary or 8 for octal)</p>
</td></tr>
<tr><td><code id="digits2number_+3A_fractional">fractional</code></td>
<td>
<p>divide the output by the max for this number of digits and base. Note that this is <code>base^length(digits)</code> not <code>base^length(digits)-1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an integer
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Radix">https://en.wikipedia.org/wiki/Radix</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>digits2number(c(4,4,1),8)
digits2number(number2digits(100))
</code></pre>

<hr>
<h2 id='generatePermuteString'>Generate a permutation string meeting Tukey criteria</h2><span id='topic+generatePermuteString'></span>

<h3>Description</h3>

<p>Find a random string of concatenated permutations of 1:n fulfilling Tukey's criteria that there are no runs of 3 or more increases or decreases in a row. Tukey just uses the default n=5.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generatePermuteString(nReps = 20, n = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generatePermuteString_+3A_nreps">nReps</code></td>
<td>
<p>number of permutations to concatenate</p>
</td></tr>
<tr><td><code id="generatePermuteString_+3A_n">n</code></td>
<td>
<p>permutations from 1 to n</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of nReps*n integers giving concatenated permutations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tukeyPermutes()
tukeyPermutes(6,3)
</code></pre>

<hr>
<h2 id='integrations'>Data on HIV integration sites from several studies</h2><span id='topic+integrations'></span>

<h3>Description</h3>

<p>A dataset containing data from a meta-analysis looking for differences between active and inactive HIV integrations. Each row represents a provirus integrated somewhere in a human chromosome with whether viral expression was detectd, the distance to the nearest gene and the number of reads from H4K12ac ChIP-Seq mapped to within 50,000 bases of the integration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integrations
</code></pre>


<h3>Format</h3>

<p>A data frame with 12436 rows and 4 variables:
</p>

<dl>
<dt>study</dt><dd><p>the cell population infected by HIV</p>
</dd>
<dt>latent</dt><dd><p>whether the provirus was active (expressed) or inactive (latent)</p>
</dd>
<dt>nearestGene</dt><dd><p>distance to nearest gene (transcription unit) (0 if in a gene)</p>
</dd>
<dt>H4K12ac</dt><dd><p>number of reads aligned within +- 50,000 bases in a H4K12ac ChIP-Seq</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://retrovirology.biomedcentral.com/articles/10.1186/1742-4690-10-90">https://retrovirology.biomedcentral.com/articles/10.1186/1742-4690-10-90</a>, system.file(&quot;data-raw&quot;, &quot;makeIntegrations.R&quot;, package = &quot;vipor&quot;)
</p>


<h3>References</h3>

<p><a href="https://retrovirology.biomedcentral.com/articles/10.1186/1742-4690-10-90">https://retrovirology.biomedcentral.com/articles/10.1186/1742-4690-10-90</a>
</p>

<hr>
<h2 id='number2digits'>Convert an integer to an arbitrary base</h2><span id='topic+number2digits'></span>

<h3>Description</h3>

<p>Takes an integer and converts it into an arbitrary base e.g. binary or octal. Note that the first digit in the output is the least significant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>number2digits(n, base = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="number2digits_+3A_n">n</code></td>
<td>
<p>the integer to be converted</p>
</td></tr>
<tr><td><code id="number2digits_+3A_base">base</code></td>
<td>
<p>the base for the numeral system (e.g. 2 for binary or 8 for octal)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of length <code>ceiling(log(n+1,base))</code> respresenting each digit for that numeral system
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Radix">https://en.wikipedia.org/wiki/Radix</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>number2digits(100)
number2digits(100,8)
</code></pre>

<hr>
<h2 id='offsetX'>Offset data using quasirandom noise to avoid overplotting</h2><span id='topic+offsetX'></span><span id='topic+offsetSingleGroup'></span>

<h3>Description</h3>

<p>Arranges data points using quasirandom noise (van der Corput sequence), pseudorandom noise or alternatively positioning extreme values within a band to the left and right to form beeswarm/one-dimensional scatter/strip chart style plots. That is a plot resembling a cross between a violin plot (showing the density distribution) and a scatter plot (showing the individual points). This function returns a vector of the offsets to be used in plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>offsetX(y, x = rep(1, length(y)), width = 0.4, varwidth = FALSE, ...)

offsetSingleGroup(
  y,
  maxLength = NULL,
  method = c("quasirandom", "pseudorandom", "smiley", "maxout", "frowney", "minout",
    "tukey", "tukeyDense"),
  nbins = NULL,
  adjust = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="offsetX_+3A_y">y</code></td>
<td>
<p>vector of data points</p>
</td></tr>
<tr><td><code id="offsetX_+3A_x">x</code></td>
<td>
<p>a grouping factor for y (optional)</p>
</td></tr>
<tr><td><code id="offsetX_+3A_width">width</code></td>
<td>
<p>the maximum spacing away from center for each group of points. Since points are spaced to left and right, the maximum width of the cluster will be approximately width*2 (0 = no offset, default = 0.4)</p>
</td></tr>
<tr><td><code id="offsetX_+3A_varwidth">varwidth</code></td>
<td>
<p>adjust the width of each group based on the number of points in the group</p>
</td></tr>
<tr><td><code id="offsetX_+3A_...">...</code></td>
<td>
<p>additional arguments to offsetSingleGroup</p>
</td></tr>
<tr><td><code id="offsetX_+3A_maxlength">maxLength</code></td>
<td>
<p>multiply the offset by sqrt(length(y)/maxLength) if not NULL. The sqrt is to match boxplot (allows comparison of order of magnitude different ns, scale with standard error)</p>
</td></tr>
<tr><td><code id="offsetX_+3A_method">method</code></td>
<td>
<p>method used to distribute the points:
</p>

<dl>
<dt>quasirandom:</dt><dd><p>points are distributed within a kernel density estimate of the distribution with offset determined by quasirandom Van der Corput noise</p>
</dd>
<dt>pseudorandom:</dt><dd><p>points are distributed within a kernel density estimate of the distribution with offset determined by pseudorandom noise a la jitter</p>
</dd>
<dt>maxout:</dt><dd><p>points are distributed within a kernel density with points in a band distributed with highest value points on the  outside and lowest in the middle</p>
</dd>
<dt>minout:</dt><dd><p>points are distributed within a kernel density with points in a band distributed with highest value points in the middle and lowest on the outside</p>
</dd>
<dt>tukey:</dt><dd><p>points are distributed as described in Tukey and Tukey &quot;Strips displaying empirical distributions: I. textured dot strips&quot;</p>
</dd>
<dt>tukeyDense:</dt><dd><p>points are distributed as described in Tukey and Tukey but are constrained with the kernel density estimate</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="offsetX_+3A_nbins">nbins</code></td>
<td>
<p>the number of points used to calculate density (defaults to 1000 for quasirandom and pseudorandom and 100 for others)</p>
</td></tr>
<tr><td><code id="offsetX_+3A_adjust">adjust</code></td>
<td>
<p>adjust the bandwidth used to calculate the kernel density (smaller values mean tighter fit, larger values looser fit, default is 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with of x-offsets of the same length as y
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate fake data
dat &lt;- list(rnorm(50), rnorm(500), c(rnorm(100), rnorm(100,5)), rcauchy(100))
names(dat) &lt;- c("Normal", "Dense Normal", "Bimodal", "Extremes")

## Plot each distribution with a variety of parameters
par(mfrow=c(4,1), mar=c(2,4, 0.5, 0.5))
sapply(names(dat),function(label) {
  y&lt;-dat[[label]]
  
  offsets &lt;- list(
    'Default'=offsetX(y),
    'Smoother'=offsetX(y, adjust=2),
    'Tighter'=offsetX(y, adjust=0.1),
    'Thinner'=offsetX(y, width=0.1)
  )
  ids &lt;- rep(1:length(offsets), sapply(offsets,length))
  
  plot(unlist(offsets) + ids, rep(y, length(offsets)), 
       ylab=label, xlab='', xaxt='n', pch=21, las=1)
  axis(1, 1:4, c("Default", "Adjust=2", "Adjust=0.1", "Width=10%"))
})

</code></pre>

<hr>
<h2 id='permute'>Return all permutations of a vector</h2><span id='topic+permute'></span>

<h3>Description</h3>

<p>Recursively generates all permutations of a vector. The result will be <code>factorial(length(vals))</code> long so be careful with any longer vectors (e.g. longer than 10).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permute(vals)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permute_+3A_vals">vals</code></td>
<td>
<p>a vector of elements to be permuted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of vectors containing all permutation of the values
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+sample">sample</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>permute(letters[1:3])
permute(1:5)
</code></pre>

<hr>
<h2 id='topBottomDistribute'>Produce offsets such that points are sorted with most extreme values to right and left</h2><span id='topic+topBottomDistribute'></span>

<h3>Description</h3>

<p>Produce offsets to generate smile-like or frown-like distributions of points. That is sorting the points so that the most extreme values alternate between the left and right e.g. (max,3rd max,...,4th max, 2nd max). The function returns either a proportion between 0 and 1 (useful for plotting) or an order
</p>


<h3>Usage</h3>

<pre><code class='language-R'>topBottomDistribute(x, frowney = FALSE, prop = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="topBottomDistribute_+3A_x">x</code></td>
<td>
<p>the elements to be sorted</p>
</td></tr>
<tr><td><code id="topBottomDistribute_+3A_frowney">frowney</code></td>
<td>
<p>if TRUE then sort minimums to the outside, otherwise sort maximums to the outside</p>
</td></tr>
<tr><td><code id="topBottomDistribute_+3A_prop">prop</code></td>
<td>
<p>if FALSE then return an ordering of the data with extremes on the outside. If TRUE then return a sequence between 0 and 1 sorted by the ordering</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of the same length as x with values ranging between 0 and 1 if prop is TRUE or an ordering of 1 to length(x)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>topBottomDistribute(1:10)
topBottomDistribute(1:10,TRUE)
</code></pre>

<hr>
<h2 id='tukeyPermutes'>Find permutations meeting Tukey criteria</h2><span id='topic+tukeyPermutes'></span>

<h3>Description</h3>

<p>Find all permutations of 1:n fulfilling Tukey's criteria that there are no runs of 3 or more increases or decreases in a row. Tukey just uses the default n=5 and limit=2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tukeyPermutes(n = 5, limit = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tukeyPermutes_+3A_n">n</code></td>
<td>
<p>permutations from 1 to n</p>
</td></tr>
<tr><td><code id="tukeyPermutes_+3A_limit">limit</code></td>
<td>
<p>the maximum number of increases or decreases in a row</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of vectors containing valid permutations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tukeyPermutes()
tukeyPermutes(6,3)
</code></pre>

<hr>
<h2 id='tukeyT'>Combine multiple permutation strings into one</h2><span id='topic+tukeyT'></span>

<h3>Description</h3>

<p>Combine base+1 permutation strings to generate offsets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tukeyT(nReps = 10, base = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tukeyT_+3A_nreps">nReps</code></td>
<td>
<p>number of permutations to paste together</p>
</td></tr>
<tr><td><code id="tukeyT_+3A_base">base</code></td>
<td>
<p>generate permutations of integers 1:base</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A nReps*base length vector giving offset positions based on Tukey's algorithm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tukeyT()
tukeyT()
tukeyT(5,4)
</code></pre>

<hr>
<h2 id='tukeyTexture'>Generate random positions based on Tukey texture algorithm</h2><span id='topic+tukeyTexture'></span>

<h3>Description</h3>

<p>Generate partly random, partly constrained lateral displacements based on Tukey texture algorithm from Tukey and Tukey 1990
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tukeyTexture(
  x,
  jitter = TRUE,
  thin = FALSE,
  hollow = FALSE,
  delta = diff(stats::quantile(x, c(0.25, 0.75))) * 0.03
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tukeyTexture_+3A_x">x</code></td>
<td>
<p>the points to be jittered. really only used to calculate length</p>
</td></tr>
<tr><td><code id="tukeyTexture_+3A_jitter">jitter</code></td>
<td>
<p>if TRUE add random jitter to each point</p>
</td></tr>
<tr><td><code id="tukeyTexture_+3A_thin">thin</code></td>
<td>
<p>if TRUE then push points to the center in thin regions</p>
</td></tr>
<tr><td><code id="tukeyTexture_+3A_hollow">hollow</code></td>
<td>
<p>if TRUE then expand points outward to avoid &ldquo;hollowness&rdquo;</p>
</td></tr>
<tr><td><code id="tukeyTexture_+3A_delta">delta</code></td>
<td>
<p>a &ldquo;reasonably small value&rdquo; used in edge straightening and thinning</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of length length(x) giving displacements for each corresponding point in x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-rnorm(200)
plot(tukeyTexture(x),x)
x&lt;-1:100
plot(tukeyTexture(x),x)
plot(tukeyTexture(log10(counties$landArea),TRUE,TRUE),log10(counties$landArea),cex=.25)
</code></pre>

<hr>
<h2 id='vanDerCorput'>Generate van der Corput sequences</h2><span id='topic+vanDerCorput'></span>

<h3>Description</h3>

<p>Generates the first (or an arbitrary offset) n elements of the van der Corput low-discrepancy sequence for a given base
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vanDerCorput(n, base = 2, start = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vanDerCorput_+3A_n">n</code></td>
<td>
<p>the first n elements of the van der Corput sequence</p>
</td></tr>
<tr><td><code id="vanDerCorput_+3A_base">base</code></td>
<td>
<p>the base to use for calculating the van der Corput sequence</p>
</td></tr>
<tr><td><code id="vanDerCorput_+3A_start">start</code></td>
<td>
<p>start at this position in the sequence</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of length n with values ranging between 0 and 1
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Van_der_Corput_sequence">https://en.wikipedia.org/wiki/Van_der_Corput_sequence</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vanDerCorput(100)
</code></pre>

<hr>
<h2 id='vipor'>Functions to generate violin scatter plots</h2><span id='topic+vipor'></span>

<h3>Description</h3>

<p>Arranges data points using quasirandom noise (van der Corput sequence) to create a plot resembling a cross between a violin plot (showing the density distribution) and a scatter plot (showing the individual points). The development version of this package is on <a href="https://github.com/sherrillmix/vipor">https://github.com/sherrillmix/vipor</a>
</p>


<h3>Details</h3>

<p>The main functions are: 
</p>

<dl>
<dt><code><a href="#topic+offsetX">offsetX</a></code>:</dt><dd><p>calculate offsets in X position for plotting (groups of) one dimensional data</p>
</dd>
<dt><code><a href="#topic+vpPlot">vpPlot</a></code>:</dt><dd><p>a simple wrapper around plot and offsetX to generate plots of grouped data</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Scott Sherrill-Mix, <a href="mailto:shescott@upenn.edu">shescott@upenn.edu</a>
</p>


<h3>See Also</h3>

<p><a href="https://github.com/sherrillmix/vipor">https://github.com/sherrillmix/vipor</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat&lt;-list(rnorm(100),rnorm(50,1,2))
ids&lt;-rep(1:length(dat),sapply(dat,length))
offset&lt;-offsetX(unlist(dat),ids)
plot(unlist(dat),ids+offset)
</code></pre>

<hr>
<h2 id='vpPlot'>Plot data using offsets by quasirandom noise to generate a violin point plot</h2><span id='topic+vpPlot'></span>

<h3>Description</h3>

<p>Arranges data points using quasirandom noise (van der Corput sequence), pseudorandom noise or alternatively positioning extreme values within a band to the left and right to form beeswarm/one-dimensional scatter/strip chart style plots. That is a plot resembling a cross between a violin plot (showing the density distribution) and a scatter plot (showing the individual points) and so here we'll call it a violin point plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vpPlot(x = rep("Data", length(y)), y, xaxt = "y", offsetXArgs = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vpPlot_+3A_x">x</code></td>
<td>
<p>a grouping factor for y (optional)</p>
</td></tr>
<tr><td><code id="vpPlot_+3A_y">y</code></td>
<td>
<p>vector of data points</p>
</td></tr>
<tr><td><code id="vpPlot_+3A_xaxt">xaxt</code></td>
<td>
<p>if 'n' then no x axis is plotted</p>
</td></tr>
<tr><td><code id="vpPlot_+3A_offsetxargs">offsetXArgs</code></td>
<td>
<p>a list with arguments for offsetX</p>
</td></tr>
<tr><td><code id="vpPlot_+3A_...">...</code></td>
<td>
<p>additional arguments to plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisibly return the adjusted x positions of the points
</p>


<h3>See Also</h3>

<p><code><a href="#topic+offsetX">offsetX</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat&lt;-list(
  'Mean=0'=rnorm(200),
  'Mean=1'=rnorm(50,1),
  'Bimodal'=c(rnorm(40,-2),rnorm(60,2)),
  'Gamma'=rgamma(50,1)
)
labs&lt;-factor(rep(names(dat),sapply(dat,length)),levels=names(dat))
vpPlot(labs,unlist(dat))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
