<!DOCTYPE html><html><head><title>Help for package Monte.Carlo.se</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Monte.Carlo.se}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#A.Quick.Outline'><p>Monte.Carlo.se: A package for computing standard errors of Monte Carlo estimates</p></a></li>
<li><a href='#boot.se'><p>Bootstrap Standard Error</p></a></li>
<li><a href='#Extra'><p>Auxiliary Functions</p></a></li>
<li><a href='#jack.se'><p>Jackknife Standard Error</p></a></li>
<li><a href='#mc.se.matrix'><p>Standard Errors for Summaries Based on 2 or More Vectors of Monte Carlo Output</p></a></li>
<li><a href='#mc.se.vector'><p>Standard Errors for Monte Carlo Output Summaries</p></a></li>
<li><a href='#pairwise.se'><p>Standard Errors for Paired Comparisons of Monte Carlo Output Summaries</p></a></li>
<li><a href='#sim.samp'><p>Code for Generating Random Samples</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Monte Carlo Standard Errors</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Dennis Boos, Kevin Matthew, Jason Osborne</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dennis Boos &lt;boos@ncsu.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Computes Monte Carlo standard errors for summaries of Monte Carlo output. Summaries and their standard errors are based on columns of Monte Carlo simulation output. Dennis D. Boos and Jason A. Osborne (2015) &lt;<a href="https://doi.org/10.1111%2Finsr.12087">doi:10.1111/insr.12087</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-06 00:20:56 UTC; boos</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-06 11:00:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='A.Quick.Outline'>Monte.Carlo.se: A package for computing standard errors of Monte Carlo estimates</h2><span id='topic+A.Quick.Outline'></span>

<h3>Description</h3>

<p>The Monte.Carlo.se package has two main R functions
<code><a href="#topic+mc.se.vector">mc.se.vector</a></code> and <code><a href="#topic+mc.se.matrix">mc.se.matrix</a></code> that are built on two basic functions
<code><a href="#topic+jack.se">jack.se</a></code> and <code><a href="#topic+boot.se">boot.se</a></code> for computing jackknife and bootstrap standard errors, respectively.
</p>


<h3>Details</h3>

<p>A Monte Carlo Study often results in an N by k matrix X of estimates based on N independent samples of
simulation data.  X might contain parameter estimates (like the mean or median) or test results
(say 0 for &quot;accept the null hypothesis&quot; or 1 for &quot;reject the null&quot;). Summary calculations from X,
such as means or variances, are then displayed in a table or plot.
</p>
<p>The purpose of the Monte.Carlo.se package is to compute estimates of the standard deviation
(called standard errors) of these table entries.
</p>
<p>Examples are included in the documentation for <code><a href="#topic+mc.se.vector">mc.se.vector</a></code> and <code><a href="#topic+mc.se.matrix">mc.se.matrix</a></code>.
However, more extended examples may be found in the three vignettes found by clicking &quot;index&quot; at
the bottom of this page and then on &quot;User guides, package vignettes and other documentation.&quot;
</p>


<h3>Author(s)</h3>

<p>Dennis Boos, Kevin Matthew, Jason Osborne
</p>

<hr>
<h2 id='boot.se'>Bootstrap Standard Error</h2><span id='topic+boot.se'></span>

<h3>Description</h3>

<p><code>boot.se</code> &ndash; gives a bootstrap standard error (SE=estimated standard deviation)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.se(x, B, theta, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boot.se_+3A_x">x</code></td>
<td>
<p>vector of data</p>
</td></tr>
<tr><td><code id="boot.se_+3A_b">B</code></td>
<td>
<p>number of bootstrap resamples (replications)</p>
</td></tr>
<tr><td><code id="boot.se_+3A_theta">theta</code></td>
<td>
<p>function (statistic) applied to the data (e.g., mean, median, var)</p>
</td></tr>
<tr><td><code id="boot.se_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The code was modified from code associated with the appendix of Efron and Tibshirani (1993)
</p>


<h3>Value</h3>

<p>Returns the bootstrap SE of theta(x)
</p>


<h3>Author(s)</h3>

<p>Dennis Boos, Kevin Matthew, Jason Osborne
</p>


<h3>References</h3>

<p>Efron and Tibshirani (1993), _An Introduction to the Bootstrap_.
</p>
<p>Boos, D. D., and Osborne, J. A. (2015), &quot;Assessing Variability of Complex Descriptive
Statistics in Monte Carlo Studies using Resampling Methods,&quot; 
International Statistical Review, 25, 775-792.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jack.se">jack.se</a></code> &ndash; <code><a href="#topic+mc.se.vector">mc.se.vector</a></code> &ndash;
<code><a href="#topic+mc.se.matrix">mc.se.matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# simple example, data from Boos and Osborne (2105, Table 3)
# using theta=coefficient of variation mean/sd

x=c(1,2,79,5,17,11,2,15,85)
cv=function(x){sd(x)/mean(x)}

cv(x)
# [1] 1.383577

# bootstrap SE using B=1000

set.seed(384)
boot.se(x,B=1000,theta=cv)
# [1] 0.3416897

# More complex example using two samples, se for ratio of means
# data from Higgins (2003, problem 4.4, p. 142), LDH readings on 7 patients

before=c(89,90,87,98,120,85,97)
after=c(76,101,84,86,105,84,93)

# requires function using row index as "data", real data is extra parameter xdata
ratio.means &lt;- function(index,xdata)
 {mean(xdata[index,1])/mean(xdata[index,2])}

ratio.means(index=1:7,xdata=data.frame(before,after))
# [1] 1.058824

# boostrap SE for ratio of means

set.seed(2917)
boot.se(x=1:7,B=1000,theta=ratio.means,xdata=data.frame(before,after))
# [1] 0.03576659

# To illustrate use with Monte Carlo output, first create some sample data
# 10,000 samples of size 15 from the Laplace (double exp) distribution

N&lt;-10000
set.seed(450)
z1 &lt;- matrix(rexp(N*15),nrow=N)
z2 &lt;- matrix(rexp(N*15),nrow=N)
z&lt;-(z1-z2)/sqrt(2)              # subtract standard exponentials
out.m.15   &lt;- apply(z,1,mean)
out.t20.15 &lt;- apply(z,1,mean,trim=0.20)
out.med.15 &lt;- apply(z,1,median)


# The three datasets (out.m.15,out.t20.15,out.med.15) each contain 10000 values.
# If we want use the variance of each column in a table, then to get
# the Monte Carlo standard error of those 3 variances,

set.seed(250)
boot.se(out.m.15,B=1000,theta = var)
# [1] 0.0009373835

boot.se(out.t20.15,B=1000,theta = var)
# [1] 0.0007086057

boot.se(out.med.15,B=1000,theta = var)
# [1] 0.0008307258
 # ends donttest
# Function Code

boot.se&lt;-function(x, B, theta, ...){
  call &lt;- match.call()
  n &lt;- length(x)
  bootsam &lt;- matrix(sample(x, size = n * B, replace = T), nrow = B)
  thetastar &lt;- apply(bootsam, 1, theta, ...)
  se &lt;- sd(thetastar)
  return(se)
  }

</code></pre>

<hr>
<h2 id='Extra'>Auxiliary Functions</h2><span id='topic+Extra'></span><span id='topic+ratio.var'></span><span id='topic+ratio.sd'></span><span id='topic+ratio.mse'></span><span id='topic+ratio.mean.vhat.var'></span><span id='topic+ratio.mean.sdhat.sd'></span><span id='topic+corr'></span><span id='topic+cv'></span><span id='topic+varn'></span><span id='topic+jack.var'></span><span id='topic+boot.var'></span>

<h3>Description</h3>

<p>Auxiliary functions to be used in the Monte.Carlo.se package,
mainly with mc.se.matrix.  Scroll down to the Examples Section to
see the actual code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ratio.var(index, xdata)

ratio.sd(index, xdata)

ratio.mse(index, xdata, true)

ratio.mean.vhat.var(index, xdata)

ratio.mean.sdhat.sd(index, xdata)

corr(index, xdata)

cv(x)

varn(x, n)

jack.var(x, theta, ...)

boot.var(x, B, theta, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Extra_+3A_index">index</code></td>
<td>
<p>index = usually of the form 1:N</p>
</td></tr>
<tr><td><code id="Extra_+3A_xdata">xdata</code></td>
<td>
<p>actual data</p>
</td></tr>
<tr><td><code id="Extra_+3A_true">true</code></td>
<td>
<p>true parameter value when computing mean squared error</p>
</td></tr>
<tr><td><code id="Extra_+3A_x">x</code></td>
<td>
<p>Input vector in calls to jack.var and boot.var</p>
</td></tr>
<tr><td><code id="Extra_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="Extra_+3A_theta">theta</code></td>
<td>
<p>theta = function in calls to jack.var and boot.var</p>
</td></tr>
<tr><td><code id="Extra_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed</p>
</td></tr>
<tr><td><code id="Extra_+3A_b">B</code></td>
<td>
<p>Bootstrap reps in calls to boot.var</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dennis Boos, Kevin Matthew, Jason Osborne
</p>


<h3>Examples</h3>

<pre><code class='language-R'># These are extra functions included in the MCse package
# The following functions are to be used with mc.se.matrix

ratio.var &lt;- function(index,xdata)         # ratio of variances
 {var(xdata[index,1])/var(xdata[index,2])}

# The above function is for the ratio of the sample variance of column 1 to
# the sample variance  of column 2 of xdata.
# Note that the actual data goes into xdata, the second argument of ratio.var.
# Example call for 10,000 means and medians:
# ratio.var(1:10000,xdata=cbind(out.m.15,out.med.15))

ratio.sd&lt;-function(index,xdata){           # ratio of standard deviations
 sd(xdata[index,1])/sd(xdata[index,2])}

ratio.mse&lt;-function(index,xdata,true){     # ratio of mean squared errors
 mean((xdata[index,1]-true)^2)/mean((xdata[index,2]-true)^2)}

ratio.mean.vhat.var&lt;-function(index,xdata){# estimates in col 1, vhats in col. 2
 mean(xdata[index,2])/var(xdata[index,1])}

ratio.mean.sdhat.sd&lt;-function(index,xdata){# estimates in col 1, SEs in col. 2
 mean(xdata[index,2])/sd(xdata[index,1])}

corr&lt;-function(index,xdata){               # simple correlation
 cor(xdata[index,1],xdata[index,2])}

# These next two functions correspond to jack.se and boot.se.
# x is a data vector, and theta is a function applied to x.
# Each returns a variance estimate for theta(x).

jack.var &lt;- function(x, theta, ...){  # jackknife estimate of variance
 n &lt;- length(x)
 u &lt;- rep(0, n)
 for(i in 1:n){u[i] &lt;- theta(x[ - i], ...)}
 jack.var &lt;-((n-1)/n)* sum((u-mean(u))^2)
 return(jack.var)}

boot.var &lt;- function(x,B,theta, ...){ # bootstrap estimate of variance
 n &lt;- length(x)
 bootsam &lt;- matrix(sample(x,size = n*B,replace=T), nrow=B)
 thetastar &lt;- apply(bootsam,1,theta,...)
 boot.var &lt;- var(thetastar)
 return(boot.var)}

</code></pre>

<hr>
<h2 id='jack.se'>Jackknife Standard Error</h2><span id='topic+jack.se'></span>

<h3>Description</h3>

<p><code>jack.se</code> &mdash; gives jackknife standard error (SE=estimated standard deviation)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jack.se(x, theta, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jack.se_+3A_x">x</code></td>
<td>
<p>vector of data</p>
</td></tr>
<tr><td><code id="jack.se_+3A_theta">theta</code></td>
<td>
<p>&mdash; function (statistic) applied to the data (e.g., mean, median, var)</p>
</td></tr>
<tr><td><code id="jack.se_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The code was modified from code associated with the appendix of Efron and Tibshirani (1993)
</p>


<h3>Value</h3>

<p>Returns the jackknife standard error of theta(x)
</p>


<h3>Author(s)</h3>

<p>Dennis Boos, Kevin Matthew, Jason Osborne
</p>


<h3>References</h3>

<p>Efron and Tibshirani (1993), *An Introduction to the Bootstrap*.
</p>
<p>Boos, D. D., and Osborne, J. A. (2015), &quot;Assessing Variability of Complex Descriptive
Statistics in Monte Carlo Studies using Resampling Methods,&quot; 
International Statistical Review, 25, 775-792.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+boot.se">boot.se</a></code> &mdash; <code><a href="#topic+mc.se.vector">mc.se.vector</a></code> &mdash; <code><a href="#topic+mc.se.matrix">mc.se.matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# simple example, data from Boos and Osborne (2015, Table 3)
# using theta = coefficient of variation = mean/sd

x=c(1,2,79,5,17,11,2,15,85)
cv=function(x){sd(x)/mean(x)}
cv(x)
# [1] 1.383577

jack.se(x,theta=cv)
# [1] 0.3435321

# More complex example using two samples, se for ratio of means
# data from Higgins (2003, problem 4.4, p. 142), LDH readings on 7 patients

before=c(89,90,87,98,120,85,97)
after=c(76,101,84,86,105,84,93)

# requires function using row index as "data,"
# real data is extra parameter xdata

ratio.means &lt;- function(index,xdata){
 mean(xdata[index,1])/mean(xdata[index,2])}

# ratio of means for before-after data

ratio.means(index=1:7,xdata=data.frame(before,after))
# [1] 1.058824

# jackknife SE for ratio of means

jack.se(x=1:7,theta=ratio.means,xdata=data.frame(before,after))
# [1] 0.03913484

# To illustrate use with Monte Carlo output, first create some sample data
# 10,000 samples of size 15 from the Laplace (double exp) distribution

N&lt;-10000
set.seed(450)
z1 &lt;- matrix(rexp(N*15),nrow=N)
z2 &lt;- matrix(rexp(N*15),nrow=N)
z&lt;-(z1-z2)/sqrt(2)              # subtract standard exponentials
out.m.15   &lt;- apply(z,1,mean)
out.t20.15 &lt;- apply(z,1,mean,trim=0.20)
out.med.15 &lt;- apply(z,1,median)

# The three datasets (out.m.15,out.t20.15,out.med.15) each contain 10,000 values.
# If we want use the variance of each column in a table, then to get
# the Monte Carlo standard error of those 3 variances,

jack.se(out.m.15,theta = var)
# [1] 0.0009612314

jack.se(out.t20.15,theta = var)
# [1] 0.0007008859

jack.se(out.med.15,theta = var)
# [1] 0.0008130531

# Function Code

jack.se=function(x, theta, ...){
 call &lt;- match.call()
 n &lt;- length(x)
 u &lt;- rep(0, n)
 for(i in 1:n) {u[i] &lt;- theta(x[ - i], ...)}
 jack.se &lt;- sqrt(((n - 1)/n) * sum((u - mean(u))^2))
 return(jack.se)}

</code></pre>

<hr>
<h2 id='mc.se.matrix'>Standard Errors for Summaries Based on 2 or More Vectors of Monte Carlo Output</h2><span id='topic+mc.se.matrix'></span>

<h3>Description</h3>

<p><code>mc.se.matrix</code> &mdash; jackknife and bootstrap SEs for statistics based on k correlated samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc.se.matrix(x, xcol, B = 0, seed = NULL, summary.f, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc.se.matrix_+3A_x">x</code></td>
<td>
<p>N by k matrix or data frame of MC output, k&gt;1</p>
</td></tr>
<tr><td><code id="mc.se.matrix_+3A_xcol">xcol</code></td>
<td>
<p>vector specifying columns of x to use</p>
</td></tr>
<tr><td><code id="mc.se.matrix_+3A_b">B</code></td>
<td>
<p>B=0 (default) means use jackknife, B&gt;0 means use bootstrap with B resamples, If B&gt;0, then a seed must be given to start the bootstrap resampling</p>
</td></tr>
<tr><td><code id="mc.se.matrix_+3A_seed">seed</code></td>
<td>
<p>seed=NULL (default) used with jackknife, otherwise needs positive integer</p>
</td></tr>
<tr><td><code id="mc.se.matrix_+3A_summary.f">summary.f</code></td>
<td>
<p>summary function with arguments (index,xdata), x goes into xdata</p>
</td></tr>
<tr><td><code id="mc.se.matrix_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose that k columns of Monte Carlo output are produced from N
independent Monte Carlo samples, and summary statistics involving 2 or more columns are to be
reported in tables.  <code>mc.se.matrix</code> gives Monte Carlo standard errors (SEs) for
these summary statistics (e.g., the ratio of 2 column means or variances). The vignette 
<code>vignette("Example2", package = "Monte.Carlo.se")</code> is a detailed 
account of using mc.se.vector.
</p>


<h3>Value</h3>

<p>Returns data frame of summary.f, Monte Carlo (MC) SE of summary.f, MC sample size N,
method (jackknife or bootstrap), B and seed if bootstrap is used
</p>


<h3>Author(s)</h3>

<p>Dennis Boos, Kevin Matthew, Jason Osborne
</p>


<h3>References</h3>

<p>Boos, D. D., and Osborne, J. A. (2015), &quot;Assessing Variability of Complex Descriptive
Statistics in Monte Carlo Studies using Resampling Methods,&quot; 
International Statistical Review, 25, 775-792.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# First create MC output used in Table 9.1, p. 367, of Boos and Stefanski (2013).
# norm15 holds 10,000 sample means, 20% trimmed means, and medians
# for normal samples of size 15

N &lt;- 10000
set.seed(346)                   # sets the random number seed
z &lt;- matrix(rnorm(N*15),nrow=N) # N rows of N(0,1) samples, n=15
out.m.15 &lt;- apply(z,1,mean)     # mean for each sample
out.t20.15 &lt;- apply(z,1,mean,trim=0.20)   # 20% trimmed mean for each sample
out.med.15 &lt;- apply(z,1,median)           # median for each sample

# Save all 1000 blocks of 3 estimators in a data frame
norm15 &lt;- data.frame(mean=out.m.15,trim20=out.t20.15,median=out.med.15)

# Pearson correlation based on 2 vectors of MC output
# Note that the 2 vectors are in xdata, index is for the rows of xdata
corr&lt;-function(index,xdata){cor(xdata[index,1],xdata[index,2])}

# Compute jackknife SE for summary.f=corr

mc.se.matrix(norm15,xcol=c(1,2),summary.f=corr)
#      summary          se     N    method
#  1 0.9367602 0.001256079 10000 Jackknife

# Compute bootstrap SE for summary.f=corr

mc.se.matrix(norm15,xcol=c(1,2),summary.f=corr,B=1000,seed=3928)
#      summary          se     N    method    B seed
#  1 0.9367602 0.001287065 10000 Bootstrap 1000 3928

# Rerun with B=5000

mc.se.matrix(norm15,xcol=c(1,2),summary.f=corr,B=5000,seed=3928)
#      summary          se     N    method    B seed
#  1 0.9367602 0.001266177 10000 Bootstrap 5000 3928

# Compute jackknife SE for summary.f=ratio.var
# = ratio of variances of the two columns
# A ratio of 2 variances facilitates comparison of the variances

ratio.var &lt;- function(index,xdata)
{var(xdata[index,1])/var(xdata[index,2])}

# ratio of column 1 variance to column 2 variance

mc.se.matrix(norm15,xcol=c(1,2),summary.f=ratio.var)
#     summary          se     N    method
# 1 0.8895367 0.006263652 10000 Jackknife
# Coupled with SE=0.006, the ratio=0.89 shows the second variance is larger than the fitst

# ratio of column 2 variance to column 1 variance
# Same conclusion as for the previous ratio

mc.se.matrix(norm15,xcol=c(2,1),summary.f=ratio.var)
#    summary          se     N    method
# 1 1.124181 0.007915667 10000 Jackknife


# Function Code

mc.se.matrix &lt;- function(x,xcol,B=0,seed=NULL,summary.f,...){
 # x is an n by k matrix or data frame of MC output, k&gt;1
 # xcol is a vector specifying columns of x to use
 # summary.f is the summary function with arguments (index,xdata)
 # ... is for additional arguments to summary.f
 # B=0 means use jackkife, B&gt;0 means use bootstrap with B resamples
 # If B&gt;0, then a seed must be given to start the bootstrap resampling
 N=nrow(x)
 x=x[,xcol]   # use columns selected
 if(B&gt;0){
   if(is.null(seed))stop('If B&gt;0, then seed for the bootstrap must be given in the call')
   se=boot.se(1:N,B=B,theta = summary.f,xdata=x,...)}
 else{se=jack.se(1:N,theta = summary.f,xdata=x,...)}
 summ = summary.f(1:N,xdata=x,...)
 if(B&gt;0) {out=data.frame(summary=summ,se,N,method="Bootstrap",B,seed)}
 else{out=data.frame(summary=summ,se,N,method="Jackknife")}
 return(out)}
 
</code></pre>

<hr>
<h2 id='mc.se.vector'>Standard Errors for Monte Carlo Output Summaries</h2><span id='topic+mc.se.vector'></span>

<h3>Description</h3>

<p><code>mc.se.vector</code> &mdash; gives jackknife and bootstrap SEs for a vector of MC output (say N estimates)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc.se.vector(x, summary.f, B = 0, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc.se.vector_+3A_x">x</code></td>
<td>
<p>vector from N independent Monte Carlo replications</p>
</td></tr>
<tr><td><code id="mc.se.vector_+3A_summary.f">summary.f</code></td>
<td>
<p>summary function computed from x (e.g., mean, median, var)</p>
</td></tr>
<tr><td><code id="mc.se.vector_+3A_b">B</code></td>
<td>
<p>B=0 means use jackknife (default), B&gt;0 means use bootstrap with B resamples, If B&gt;0, then a seed must be given to start the bootstrap resampling</p>
</td></tr>
<tr><td><code id="mc.se.vector_+3A_seed">seed</code></td>
<td>
<p>seed=NULL (default) used with jackknife, otherwise needs a positive integer</p>
</td></tr>
<tr><td><code id="mc.se.vector_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose that an N-vector of Monte Carlo output (thus, a sample of size N)
is produced from N
independent Monte Carlo samples, and a summary statistic like the mean or variance is to be
reported in a table.
<code>mc.se.vector</code> gives Monte Carlo standard errors (SEs) for these summary statistics.
The vignette <code>vignette("Example1", package = "Monte.Carlo.se")</code> is a detailed account of using <code>mc.se.vector</code>.
</p>


<h3>Value</h3>

<p>Returns data frame of summary.f , MC standard error of summary.f, MC sample size N,
method (jackknife or bootstrap), B and seed if bootstrap is used
</p>


<h3>Author(s)</h3>

<p>Dennis Boos, Kevin Matthew, Jason Osborne
</p>


<h3>References</h3>

<p>Boos, D. D., and Osborne, J. A. (2015), &quot;Assessing Variability of Complex Descriptive
Statistics in Monte Carlo Studies using Resampling Methods,&quot; 
International Statistical Review, 25, 775-792.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# First create MC output used for Table 9.1, p. 367, of Boos and Stefanski (2013)
# norm15 holds 10,000 sample means, 20% trimmed means, and medians
# computed from normal samples of size 15

N&lt;-10000
set.seed(346)                   # sets the random number seed
z &lt;- matrix(rnorm(N*15),nrow=N) # N rows of N(0,1) samples, n=15
out.m.15 &lt;- apply(z,1,mean)     # mean for each sample
out.t20.15 &lt;- apply(z,1,mean,trim=0.20)   # 20% trimmed mean for each sample
out.med.15 &lt;- apply(z,1,median)           # median for each sample

# Save all 1000 blocks of 3 estimators in a data frame

norm15 &lt;- data.frame(mean=out.m.15,trim20=out.t20.15,median=out.med.15)

# Compute the jackknife Standard Error (SE) for summary.f=mean
# This summary is useful for estimating the bias of estimators.

mc.se.vector(norm15[,1],summary.f=mean)
#        summary         se     N    method
# 1 -0.001920642 0.00256714 10000 Jackknife

# Compute a bootstrap SE for summary.f=mean

mc.se.vector(norm15[,1],B=1000,seed=4822,summary.f=mean)
#        summary          se     n    method    B seed
# 1 -0.001920642 0.002573516 10000 Bootstrap 1000 4822

# compare to basic R

mean(norm15[,1])
# [1] -0.001920642

sd(norm15[,1])/sqrt(10000)
# [1] 0.00256714

# Illustrate use with summaries having additional parameters.
# Compute the jackknife SE for summary.f=varn
# Multiplying the variance by sample size n allows comparison for different n

varn=function(x,n){n*var(x)}

# The additional parameter n replaces the ... in the mc.se.vector definition

mc.se.vector(norm15[,1],summary.f=varn,n=15)
#     summary         se     N    method
# 1 0.9885314 0.01407249 10000 Jackknife

# Compute a bootstrap SE for summary.f=varn

mc.se.vector(norm15[,1],B=1000,seed=3029,summary.f=varn,n=15)
#     summary         se     n    method    B seed
# 1 0.9885314 0.01408173 10000 Bootstrap 1000 3029


# Function Code

mc.se.vector &lt;- function(x,summary.f,B=0,seed=NULL,...){
# x is a vector from N independent Monte Carlo replications
# summary.f is a summary function computed from MC output
# ... is for additional arguments to summary.f
# B=0 means use jackkife, B&gt;0 means use bootstrap with B resamples
 if (B&gt;0){
  if(is.null(seed))stop('If B&gt;0, then seed for the bootstrap must be given in the call')
  set.seed(seed);se=boot.se(x,B=B,theta = summary.f,...)}
 else{se = jack.se(x,theta = summary.f,...)}
summ = summary.f(x,...)
if(B&gt;0){out=data.frame(summary=summ,se,n=length(x),method="Bootstrap",B,seed)}
 else{out=data.frame(summary=summ,se,N=length(x),method="Jackknife")}
return(out)}

</code></pre>

<hr>
<h2 id='pairwise.se'>Standard Errors for Paired Comparisons of Monte Carlo Output Summaries</h2><span id='topic+pairwise.se'></span>

<h3>Description</h3>

<p><code>pairwise.se</code> &mdash; gives jackknife and bootstrap SEs for all the pairwise difference or
ratios of Monte Carlo summaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairwise.se(
  x,
  xcol,
  diff = TRUE,
  digits = 4,
  B = 0,
  seed = NULL,
  summary.f,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairwise.se_+3A_x">x</code></td>
<td>
<p>vector from N independent Monte Carlo replications</p>
</td></tr>
<tr><td><code id="pairwise.se_+3A_xcol">xcol</code></td>
<td>
<p>columns of x to be used</p>
</td></tr>
<tr><td><code id="pairwise.se_+3A_diff">diff</code></td>
<td>
<p>If TRUE (default), uses differences; if diff=F, uses ratios</p>
</td></tr>
<tr><td><code id="pairwise.se_+3A_digits">digits</code></td>
<td>
<p>number of digits to retain in output data frame</p>
</td></tr>
<tr><td><code id="pairwise.se_+3A_b">B</code></td>
<td>
<p>B=0 means use jackknife (default), B&gt;0 means use bootstrap with B resamples, 
If B&gt;0, then a seed must be given to start the bootstrap resampling</p>
</td></tr>
<tr><td><code id="pairwise.se_+3A_seed">seed</code></td>
<td>
<p>seed=NULL (default) used with jackknife, otherwise needs a positive integer</p>
</td></tr>
<tr><td><code id="pairwise.se_+3A_summary.f">summary.f</code></td>
<td>
<p>summary function computed from x (e.g., mean, median, var)</p>
</td></tr>
<tr><td><code id="pairwise.se_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose that an N-vector of Monte Carlo output (thus, a sample of size N)
is produced from N
independent Monte Carlo samples, and a summary statistic like the mean or variance is to be
reported in a table.
<code>pairwise.se</code> gives Monte Carlo standard errors (SEs) for all pairwise differences
or ratios of these summary statistics.
The vignette <code>vignette("Example3", package = "Monte.Carlo.se")</code> 
is a detailed account of using <code>pairwise.se</code>.
</p>


<h3>Value</h3>

<p>Returns a data frame of the indiviual ith and jth column summaries (summi and summj),
the differences or ratios of those summaries (summary), MC standard error of the 
difference or ratio, MC sample size N,
method (jackknife or bootstrap), B and seed if bootstrap is used
</p>


<h3>Author(s)</h3>

<p>Dennis Boos, Kevin Matthew, Jason Osborne
</p>


<h3>References</h3>

<p>Boos, D. D., and Osborne, J. A. (2015), &quot;Assessing Variability of Complex Descriptive
Statistics in Monte Carlo Studies using Resampling Methods,&quot; 
International Statistical Review, 25, 775-792.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Using the output data matrix hold generated in vignette Example3, 
# calculate jackknife and bootstrap standard errors
# for the differences and ratios of the CV estimates.

# Jackknife SE of Differences of CVs

# pairwise.se(hold,xcol=10:12,summary.f=cv)
# elem  summi  summj summary     se  t.stat    N    method
# 1 10 11 0.6884 0.7030 -0.0146 0.0299 -0.4877 1000 Jackknife
# 2 10 12 0.6884 0.6489  0.0395 0.0195  2.0274 1000 Jackknife
# 3 11 12 0.7030 0.6489  0.0541 0.0311  1.7374 1000 Jackknife

# Jackknife SE of Ratios of CVs

# pairwise.se(hold,xcol=10:12,diff=FALSE,summary.f=cv)
# elem  summi  summj summary     se  t.stat    N    method
# 1 10 11 0.6884 0.7030  0.9792 0.0429 -0.4833 1000 Jackknife
# 2 10 12 0.6884 0.6489  1.0608 0.0321  1.8972 1000 Jackknife
# 3 11 12 0.7030 0.6489  1.0833 0.0475  1.7531 1000 Jackknife

# Bootstrap SE of Differences of CVs

# pairwise.se(hold,xcol=10:12,B=1000,seed=770,summary.f=cv)
# elem  summi  summj summary     se  t.stat    B seed    N    method
# 1 10 11 0.6884 0.7030 -0.0146 0.0278 -0.5250 1000  770 1000 Bootstrap
# 2 10 12 0.6884 0.6489  0.0395 0.0182  2.1671 1000  770 1000 Bootstrap
# 3 11 12 0.7030 0.6489  0.0541 0.0303  1.7844 1000  770 1000 Bootstrap

# Bootstrap SE of Ratios of CVs

# pairwise.se(hold,xcol=10:12,diff=FALSE,B=1000,seed=770,summary.f=cv)
# elem  summi  summj summary     se  t.stat    B seed    N    method
# 1 10 11 0.6884 0.7030  0.9792 0.0390 -0.5316 1000  770 1000 Bootstrap
# 2 10 12 0.6884 0.6489  1.0608 0.0292  2.0797 1000  770 1000 Bootstrap
# 3 11 12 0.7030 0.6489  1.0833 0.0430  1.9372 1000  770 1000 Bootstrap


</code></pre>

<hr>
<h2 id='sim.samp'>Code for Generating Random Samples</h2><span id='topic+sim.samp'></span>

<h3>Description</h3>

<p><code>sim.samp</code> &mdash; generates N samples of size n from distribution DIST
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.samp(nrep, n, DIST, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.samp_+3A_nrep">nrep</code></td>
<td>
<p>= number of random data sets</p>
</td></tr>
<tr><td><code id="sim.samp_+3A_n">n</code></td>
<td>
<p>= sample size of each data set</p>
</td></tr>
<tr><td><code id="sim.samp_+3A_dist">DIST</code></td>
<td>
<p>= distribution to generate from, e.g., runif, rnorm, additional parameters in ...</p>
</td></tr>
<tr><td><code id="sim.samp_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>N by n matrix, each row is a data set of size n
</p>


<h3>Author(s)</h3>

<p>Dennis Boos, Kevin Matthew, Jason Osborne
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N&lt;-100
 set.seed(346)            # sets the random number seed
 sim.samp(N,15,rnorm)-&gt;z  # 100 N(0,1) samples of size n=15
 sim.samp(N,40,rnorm,mean=10,sd=5)-&gt;z  # 100 N(10,25) samples of size n=40

# Function Code

sim.samp &lt;- function(nrep,n,DIST,...){
 data &lt;- matrix(DIST(n * nrep, ...), ncol = n, nrow = nrep)}

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
