<!DOCTYPE html><html><head><title>Help for package bigtime</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bigtime}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.diagnostics_plot'><p>Internal function to plot the diagnostics plot</p></a></li>
<li><a href='#.get_ic_vals'><p>Calculates ICs</p></a></li>
<li><a href='#.recursiveforecast'><p>Recursively forecast a VAR</p></a></li>
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#bigtime'><p>bigtime: A package for obtaining sparse estimates of large time series models.</p></a></li>
<li><a href='#create_rand_coef_mat'><p>Creates a random coefficient matrix</p></a></li>
<li><a href='#diagnostics_plot'><p>Creates a Diagnostic Plot</p></a></li>
<li><a href='#diagnostics_plot.bigtime.VAR'><p>diagnostics_plot function for VAR models</p></a></li>
<li><a href='#diagnostics_plot.bigtime.VARMA'><p>diagnostics_plot function for VARMA models</p></a></li>
<li><a href='#diagnostics_plot.bigtime.VARX'><p>diagnostics_plot function for VARX models</p></a></li>
<li><a href='#directforecast'><p>Function to obtain h-step ahead direct forecast based on estimated VAR, VARX or VARMA model</p></a></li>
<li><a href='#fitted.bigtime.VAR'><p>Gives the fitted values of a model estimated using</p>
<code>sparseVAR</code></a></li>
<li><a href='#fitted.bigtime.VARMA'><p>Gives the fitted values of a model estimated using</p>
<code>sparseVARMA</code></a></li>
<li><a href='#fitted.bigtime.VARX'><p>Gives the fitted values of a model estimated using</p>
<code>sparseVARX</code></a></li>
<li><a href='#get_ic_vals'><p>Calculates the Information Criteria for a VAR, VARX, VARMA model</p></a></li>
<li><a href='#get_ic_vals.bigtime.VAR'><p>Calculates the Information Criteria for a model estimated using</p>
<code>sparseVAR</code></a></li>
<li><a href='#get_ic_vals.bigtime.VARX'><p>Calculates the Information Criteria for a model estimated using</p>
<code>sparseVARX</code></a></li>
<li><a href='#ic_selection'><p>Selects the optimal penalty parameter using information criteria</p></a></li>
<li><a href='#is.stable'><p>Checks whether a VAR is stable</p></a></li>
<li><a href='#lagmatrix'><p>Creates Lagmatrix of Estimated Coefficients</p></a></li>
<li><a href='#plot_cv'><p>Plot the Cross Validation Error Curve for a Sparse VAR or VARX</p></a></li>
<li><a href='#plot.bigtime.recursiveforecast'><p>Plots Recursive Forecasts</p></a></li>
<li><a href='#plot.bigtime.simVAR'><p>Plots a simulated VAR</p></a></li>
<li><a href='#recursiveforecast'><p>Recursively Forecasts a VAR</p></a></li>
<li><a href='#reduce_cube'><p>Reduces the third dimension of a cube and returns a data frame</p></a></li>
<li><a href='#residuals.bigtime.VAR'><p>Gives the residuals for VAR models estimated using</p>
<code>sparseVAR</code></a></li>
<li><a href='#residuals.bigtime.VARMA'><p>Gives the residuals for VARMA models estimated using</p>
<code>sparseVARMA</code></a></li>
<li><a href='#residuals.bigtime.VARX'><p>Gives the residuals for VARX models estimated using</p>
<code>sparseVARX</code></a></li>
<li><a href='#simVAR'><p>Simulates a VAR(p) with various sparsity patterns</p></a></li>
<li><a href='#sparseVAR'><p>Sparse Estimation of the Vector AutoRegressive (VAR) Model</p></a></li>
<li><a href='#sparseVARMA'><p>Sparse Estimation of the Vector AutoRegressive Moving Average (VARMA) Model</p></a></li>
<li><a href='#sparseVARX'><p>Sparse Estimation of the Vector AutoRegressive  with Exogenous Variables X (VARX) Model</p></a></li>
<li><a href='#summary.bigtime.simVAR'><p>Gives a small summary of a VAR simulation</p></a></li>
<li><a href='#X.varx'><p>VARX Time Series Example (<code>varx.example</code>)</p></a></li>
<li><a href='#Y.var'><p>VAR Time Series Example (<code>var.example</code>)</p></a></li>
<li><a href='#Y.varma'><p>VARMA Time Series Example (<code>varma.example</code>)</p></a></li>
<li><a href='#Y.varx'><p>VARX Time Series Example (<code>varx.example</code>)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Sparse Estimation of Large Time Series Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.3</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ines Wilms &lt;i.wilms@maastrichtuniversity.nl&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimation of large Vector AutoRegressive (VAR), Vector AutoRegressive with Exogenous Variables X (VARX) and Vector AutoRegressive Moving Average (VARMA) Models with Structured Lasso Penalties, see Nicholson, Wilms, Bien and Matteson (2020) <a href="https://jmlr.org/papers/v21/19-777.html">https://jmlr.org/papers/v21/19-777.html</a> and Wilms, Basu, Bien and Matteson (2021) &lt;<a href="https://doi.org/10.1080%2F01621459.2021.1942013">doi:10.1080/01621459.2021.1942013</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0), methods</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.7), stats, utils, grDevices, graphics, corrplot,
dplyr, ggplot2, tidyr, magrittr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppEigen</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ineswilms/bigtime">https://github.com/ineswilms/bigtime</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-21 16:30:57 UTC; I.Wilms</td>
</tr>
<tr>
<td>Author:</td>
<td>Ines Wilms [cre, aut],
  David S. Matteson [aut],
  Jacob Bien [aut],
  Sumanta Basu [aut],
  Will Nicholson [aut],
  Enrico Wegner [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-21 20:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='.diagnostics_plot'>Internal function to plot the diagnostics plot</h2><span id='topic+.diagnostics_plot'></span>

<h3>Description</h3>

<p>Internal function to plot the diagnostics plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.diagnostics_plot(Y, fit, res, s, variable, dates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".diagnostics_plot_+3A_y">Y</code></td>
<td>
<p>observed values</p>
</td></tr>
<tr><td><code id=".diagnostics_plot_+3A_fit">fit</code></td>
<td>
<p>fitted values</p>
</td></tr>
<tr><td><code id=".diagnostics_plot_+3A_res">res</code></td>
<td>
<p>residual values</p>
</td></tr>
<tr><td><code id=".diagnostics_plot_+3A_s">s</code></td>
<td>
<p>how many observations were lost</p>
</td></tr>
<tr><td><code id=".diagnostics_plot_+3A_variable">variable</code></td>
<td>
<p>variable to plot: either numeric or column name</p>
</td></tr>
<tr><td><code id=".diagnostics_plot_+3A_dates">dates</code></td>
<td>
<p>vector of dates of length <code>nrow(Y)</code></p>
</td></tr>
</table>

<hr>
<h2 id='.get_ic_vals'>Calculates ICs</h2><span id='topic+.get_ic_vals'></span>

<h3>Description</h3>

<p>Not meant to be called by the user
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.get_ic_vals(res, tt, df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".get_ic_vals_+3A_res">res</code></td>
<td>
<p>Matrix of residuals</p>
</td></tr>
<tr><td><code id=".get_ic_vals_+3A_tt">tt</code></td>
<td>
<p>Number of time periods</p>
</td></tr>
<tr><td><code id=".get_ic_vals_+3A_df">df</code></td>
<td>
<p>Degrees of freedom</p>
</td></tr>
</table>

<hr>
<h2 id='.recursiveforecast'>Recursively forecast a VAR</h2><span id='topic+.recursiveforecast'></span>

<h3>Description</h3>

<p>This function is not meant to be directly called by the user
and is only a helper function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.recursiveforecast(Y, Phi_hat, phi_0, h)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".recursiveforecast_+3A_y">Y</code></td>
<td>
<p>Data matrix</p>
</td></tr>
<tr><td><code id=".recursiveforecast_+3A_phi_hat">Phi_hat</code></td>
<td>
<p>Coefficient matrix</p>
</td></tr>
<tr><td><code id=".recursiveforecast_+3A_phi_0">phi_0</code></td>
<td>
<p>Constant terms</p>
</td></tr>
<tr><td><code id=".recursiveforecast_+3A_h">h</code></td>
<td>
<p>Forecast horizon</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix of forecasts
</p>

<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='bigtime'>bigtime: A package for obtaining sparse estimates of large time series models.</h2><span id='topic+bigtime'></span><span id='topic+bigtime-package'></span>

<h3>Description</h3>

<p>The bigtime package provides sparse estimators for three large time series models:
Vector AutoRegressive Models,
Vector AutoRegressive Models with Exogenous variables,
and Vector AutoRegressive Moving Average Models. The univariate cases are also supported.
</p>


<h3>Details</h3>

<p>To use the facilities of this package, start with a T by k time series matrix Y (for the VAR and VARMA), and an exogenous time series matrix X (for the VARX).
Run <a href="#topic+sparseVAR">sparseVAR</a>, <a href="#topic+sparseVARX">sparseVARX</a> or <a href="#topic+sparseVARMA">sparseVARMA</a> to get the estimated model.
The function <a href="#topic+lagmatrix">lagmatrix</a> returns the lag matrix of estimated coefficients of the estimated model.
The function <a href="#topic+directforecast">directforecast</a> gives h-step ahead forecasts based on the estimated model.
The function <a href="#topic+recursiveforecast">recursiveforecast</a> can be used to recursively forecast a VAR model.
The function <a href="#topic+is.stable">is.stable</a> returns whether an estimated VAR model is stable.
The function <a href="#topic+diagnostics_plot">diagnostics_plot</a> returns a plot of the fitted vs. observed values as well as of the residuals.
The functions <a href="stats.html#topic+fitted">fitted</a> and <a href="stats.html#topic+residuals">residuals</a> return the fitted, respectively the residuals of the estimated model.
The function <a href="#topic+simVAR">simVAR</a> can be used to simulate a VAR model with various sparsity patterns.
</p>


<h3>Author(s)</h3>

<p>Ines Wilms &lt;i.wilms@maastrichtuniversity.nl&gt;, Jacob Bien, David S. Matteson, Sumanta Basu, Will Nicholson, Enrico Wegner
</p>


<h3>References</h3>

<p>Nicholson William B., Wilms Ines, Bien Jacob and Matteson David S. (2020), “High-dimensional forecasting via
interpretable vector autoregression”, Journal of Machine Learning Research, 21(166), 1-52.
</p>
<p>Wilms Ines, Sumanta Basu, Bien Jacob and Matteson David S. (2021), “Sparse Identification and
Estimation of Large-Scale Vector AutoRegressive Moving Averages”, Journal of the American Statistical Association, doi: 10.1080/01621459.2021.1942013.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Fit a sparse VAR model
data(var.example)
VARfit &lt;- sparseVAR(Y=scale(Y.var), selection = "cv") # using time series cross-validation
Lhat &lt;- lagmatrix(fit=VARfit) # get estimated lagmatrix
VARforecast &lt;- directforecast(fit=VARfit, h=1) # get one-step ahead forecasts
</code></pre>

<hr>
<h2 id='create_rand_coef_mat'>Creates a random coefficient matrix</h2><span id='topic+create_rand_coef_mat'></span>

<h3>Description</h3>

<p>Creates a random coefficient matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_rand_coef_mat(
  k,
  p,
  max_abs_eigval = 0.8,
  sparsity_pattern = c("none", "lasso", "hvar"),
  sparsity_options = NULL,
  decay = 0.5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_rand_coef_mat_+3A_k">k</code></td>
<td>
<p>Number of time series</p>
</td></tr>
<tr><td><code id="create_rand_coef_mat_+3A_p">p</code></td>
<td>
<p>Number of lags</p>
</td></tr>
<tr><td><code id="create_rand_coef_mat_+3A_max_abs_eigval">max_abs_eigval</code></td>
<td>
<p>if &lt; 1, then the VAR will be stable</p>
</td></tr>
<tr><td><code id="create_rand_coef_mat_+3A_sparsity_pattern">sparsity_pattern</code></td>
<td>
<p>The sparsity pattern that should be simulated.
Options are: <code>"none"</code> for a dense VAR, <code>"lasso"</code> for a VAR with random zeroes,
and <code>"hvar"</code> for an elementwise hierarchical sparsity pattern</p>
</td></tr>
<tr><td><code id="create_rand_coef_mat_+3A_sparsity_options">sparsity_options</code></td>
<td>
<p>Named list of additional options for
when sparsity pattern is lasso or hvar. For lasso the option <code>num_zero</code>
determines the number of zeros. For hvar, the options <code>zero_min</code> (<code>zero_max</code>)
give the minimum (maximum) of zeroes for each variable in each equation,
and the option <code>zeroes_in_self</code> (boolean) determines if any of the
coefficients of a variable on itself should be zero.</p>
</td></tr>
<tr><td><code id="create_rand_coef_mat_+3A_decay">decay</code></td>
<td>
<p>How fast should coefficients shrink when the lag increases.</p>
</td></tr>
<tr><td><code id="create_rand_coef_mat_+3A_...">...</code></td>
<td>
<p>Not currently used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a coefficient matrix in companion form of dimension <code>kp</code>x<code>kp</code>.
</p>

<hr>
<h2 id='diagnostics_plot'>Creates a Diagnostic Plot</h2><span id='topic+diagnostics_plot'></span>

<h3>Description</h3>

<p>Creates a Diagnostic Plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagnostics_plot(mod, variable = 1, dates = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagnostics_plot_+3A_mod">mod</code></td>
<td>
<p>VAR model estimated using <code><a href="#topic+sparseVAR">sparseVAR</a></code>,
<code><a href="#topic+sparseVARMA">sparseVARMA</a></code>, or <code><a href="#topic+sparseVARX">sparseVARX</a></code></p>
</td></tr>
<tr><td><code id="diagnostics_plot_+3A_variable">variable</code></td>
<td>
<p>Variable to show. Either numeric (which column) or character
(variable name)</p>
</td></tr>
<tr><td><code id="diagnostics_plot_+3A_dates">dates</code></td>
<td>
<p>Optional Date vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot2 plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'># VAR example
dat &lt;- simVAR(periods=200, k=2, p=5, decay = 0.1, seed = 6150533,
                       sparsity_pattern = "hvar")
mod &lt;- sparseVAR(Y=scale(dat$Y), selection = "bic", h = 1)
diagnostics_plot(mod, variable = 1) # Plotting the first variable
## Not run: 
# VARMA example
data(varma.example)
varma &lt;- sparseVARMA(Y=scale(Y.varma), VARMAselection="cv")
diagnostics_plot(varma, variable = 2) # Plotting the second variable

## End(Not run)
## Not run: 
# VARX example
data(varx.example)
varx &lt;- sparseVARX(Y=scale(Y.varx), X=scale(X.varx), selection="cv")
diagnostics_plot(varx, variable = 1) # Plotting the first variable

## End(Not run)
</code></pre>

<hr>
<h2 id='diagnostics_plot.bigtime.VAR'>diagnostics_plot function for VAR models</h2><span id='topic+diagnostics_plot.bigtime.VAR'></span>

<h3>Description</h3>

<p>Not supposed to be called directly. Rather call <code><a href="#topic+diagnostics_plot">diagnostics_plot</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bigtime.VAR'
diagnostics_plot(mod, variable = 1, dates = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagnostics_plot.bigtime.VAR_+3A_mod">mod</code></td>
<td>
<p>VAR model estimated using <code><a href="#topic+sparseVAR">sparseVAR</a></code></p>
</td></tr>
<tr><td><code id="diagnostics_plot.bigtime.VAR_+3A_variable">variable</code></td>
<td>
<p>Variable to show. Either numeric (which column) or character
(variable name)</p>
</td></tr>
<tr><td><code id="diagnostics_plot.bigtime.VAR_+3A_dates">dates</code></td>
<td>
<p>Optional Date vector.</p>
</td></tr>
</table>

<hr>
<h2 id='diagnostics_plot.bigtime.VARMA'>diagnostics_plot function for VARMA models</h2><span id='topic+diagnostics_plot.bigtime.VARMA'></span>

<h3>Description</h3>

<p>Not supposed to be called directly. Rather call <code><a href="#topic+diagnostics_plot">diagnostics_plot</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bigtime.VARMA'
diagnostics_plot(mod, variable = 1, dates = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagnostics_plot.bigtime.VARMA_+3A_mod">mod</code></td>
<td>
<p>VAR model estimated using <code><a href="#topic+sparseVARMA">sparseVARMA</a></code></p>
</td></tr>
<tr><td><code id="diagnostics_plot.bigtime.VARMA_+3A_variable">variable</code></td>
<td>
<p>Variable to show. Either numeric (which column) or character
(variable name)</p>
</td></tr>
<tr><td><code id="diagnostics_plot.bigtime.VARMA_+3A_dates">dates</code></td>
<td>
<p>Optional Date vector.</p>
</td></tr>
</table>

<hr>
<h2 id='diagnostics_plot.bigtime.VARX'>diagnostics_plot function for VARX models</h2><span id='topic+diagnostics_plot.bigtime.VARX'></span>

<h3>Description</h3>

<p>Not supposed to be called directly. Rather call <code><a href="#topic+diagnostics_plot">diagnostics_plot</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bigtime.VARX'
diagnostics_plot(mod, variable = 1, dates = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagnostics_plot.bigtime.VARX_+3A_mod">mod</code></td>
<td>
<p>VARX model estimated using <code><a href="#topic+sparseVARX">sparseVARX</a></code></p>
</td></tr>
<tr><td><code id="diagnostics_plot.bigtime.VARX_+3A_variable">variable</code></td>
<td>
<p>Variable to show. Either numeric (which column) or character
(variable name)</p>
</td></tr>
<tr><td><code id="diagnostics_plot.bigtime.VARX_+3A_dates">dates</code></td>
<td>
<p>Optional Date vector.</p>
</td></tr>
</table>

<hr>
<h2 id='directforecast'>Function to obtain h-step ahead direct forecast based on estimated VAR, VARX or VARMA model</h2><span id='topic+directforecast'></span>

<h3>Description</h3>

<p>Function to obtain h-step ahead direct forecast based on estimated VAR, VARX or VARMA model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>directforecast(fit, h = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="directforecast_+3A_fit">fit</code></td>
<td>
<p>Fitted sparse VAR, VARX or VARMA model.</p>
</td></tr>
<tr><td><code id="directforecast_+3A_h">h</code></td>
<td>
<p>Desired forecast horizon. Default is h=1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of length k containing the h-step ahead forecasts for the k time series.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(var.example)
VARfit &lt;- sparseVAR(Y=scale(Y.var), selection = "cv") # sparse VAR
VARforecast &lt;- directforecast(fit=VARfit, h=1)
</code></pre>

<hr>
<h2 id='fitted.bigtime.VAR'>Gives the fitted values of a model estimated using
<code><a href="#topic+sparseVAR">sparseVAR</a></code></h2><span id='topic+fitted.bigtime.VAR'></span>

<h3>Description</h3>

<p>Gives the fitted values of a model estimated using
<code><a href="#topic+sparseVAR">sparseVAR</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bigtime.VAR'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.bigtime.VAR_+3A_object">object</code></td>
<td>
<p>Model estimated using <code><a href="#topic+sparseVAR">sparseVAR</a></code></p>
</td></tr>
<tr><td><code id="fitted.bigtime.VAR_+3A_...">...</code></td>
<td>
<p>Not currently used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix of fitted values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- simVAR(periods=200, k=2, p=5, decay = 0.001, seed = 6150533)
mod &lt;- sparseVAR(Y=scale(dat$Y))
f &lt;- fitted(mod)
</code></pre>

<hr>
<h2 id='fitted.bigtime.VARMA'>Gives the fitted values of a model estimated using
<code><a href="#topic+sparseVARMA">sparseVARMA</a></code></h2><span id='topic+fitted.bigtime.VARMA'></span>

<h3>Description</h3>

<p>Gives the fitted values of a model estimated using
<code><a href="#topic+sparseVARMA">sparseVARMA</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bigtime.VARMA'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.bigtime.VARMA_+3A_object">object</code></td>
<td>
<p>Model estimated using <code><a href="#topic+sparseVARMA">sparseVARMA</a></code></p>
</td></tr>
<tr><td><code id="fitted.bigtime.VARMA_+3A_...">...</code></td>
<td>
<p>Not currently used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix of fitted values
data(varma.example)
varma &lt;- sparseVARMA(Y = scale(Y.varma), VARMAselection=&quot;cv&quot;)
f &lt;- fitted(varma)
</p>

<hr>
<h2 id='fitted.bigtime.VARX'>Gives the fitted values of a model estimated using
<code><a href="#topic+sparseVARX">sparseVARX</a></code></h2><span id='topic+fitted.bigtime.VARX'></span>

<h3>Description</h3>

<p>Gives the fitted values of a model estimated using
<code><a href="#topic+sparseVARX">sparseVARX</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bigtime.VARX'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.bigtime.VARX_+3A_object">object</code></td>
<td>
<p>Model estimated using <code><a href="#topic+sparseVARX">sparseVARX</a></code></p>
</td></tr>
<tr><td><code id="fitted.bigtime.VARX_+3A_...">...</code></td>
<td>
<p>Not currently used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix of fitted values
data(varx.example)
varx &lt;- sparseVARX(Y=scale(Y.varx), X=scale(X.varx), selection=&quot;cv&quot;)
fit &lt;- fitted(varx)
</p>

<hr>
<h2 id='get_ic_vals'>Calculates the Information Criteria for a VAR, VARX, VARMA model</h2><span id='topic+get_ic_vals'></span>

<h3>Description</h3>

<p>The number of non-zero coefficients are taken as the degrees of freedom.
Use with care for VARMA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ic_vals(mod, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_ic_vals_+3A_mod">mod</code></td>
<td>
<p>Model estimated Model estimated using <code><a href="#topic+sparseVAR">sparseVAR</a></code>,
<code><a href="#topic+sparseVARX">sparseVARX</a></code>, or <code><a href="#topic+sparseVARMA">sparseVARMA</a></code></p>
</td></tr>
<tr><td><code id="get_ic_vals_+3A_verbose">verbose</code></td>
<td>
<p>Should information about the optimal selection be printed?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- simVAR(periods=200, k=2, p=5, decay = 0.01)
mod &lt;- sparseVAR(Y=scale(dat$Y))
ics &lt;- get_ic_vals(mod)
</code></pre>

<hr>
<h2 id='get_ic_vals.bigtime.VAR'>Calculates the Information Criteria for a model estimated using
<code><a href="#topic+sparseVAR">sparseVAR</a></code></h2><span id='topic+get_ic_vals.bigtime.VAR'></span>

<h3>Description</h3>

<p>The number of non-zero coefficients are taken as the degrees of freedom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bigtime.VAR'
get_ic_vals(mod, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_ic_vals.bigtime.VAR_+3A_mod">mod</code></td>
<td>
<p>Model estimated using <code><a href="#topic+sparseVAR">sparseVAR</a></code></p>
</td></tr>
<tr><td><code id="get_ic_vals.bigtime.VAR_+3A_verbose">verbose</code></td>
<td>
<p>Should information about the optimal selection be printed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing
</p>
<table>
<tr><td><code>ics</code></td>
<td>
<p>Values of the ICs for all lambdas</p>
</td></tr>
<tr><td><code>mins</code></td>
<td>
<p>Which IC lead to the minimum (the row number)</p>
</td></tr>
<tr><td><code>selected_lambdas</code></td>
<td>
<p>Which lambdas were selected</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- simVAR(periods = 200, k=2, p=5, decay = 0.01)
mod &lt;- sparseVAR(Y=scale(dat$Y))
ics &lt;- get_ic_vals(mod)
</code></pre>

<hr>
<h2 id='get_ic_vals.bigtime.VARX'>Calculates the Information Criteria for a model estimated using
<code><a href="#topic+sparseVARX">sparseVARX</a></code></h2><span id='topic+get_ic_vals.bigtime.VARX'></span>

<h3>Description</h3>

<p>The number of non-zero coefficients in both the <code>Phihat</code>
and <code>Bhat</code> matrix are taken as the degrees of freedom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bigtime.VARX'
get_ic_vals(mod, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_ic_vals.bigtime.VARX_+3A_mod">mod</code></td>
<td>
<p>Model estimated using <code><a href="#topic+sparseVARX">sparseVARX</a></code></p>
</td></tr>
<tr><td><code id="get_ic_vals.bigtime.VARX_+3A_verbose">verbose</code></td>
<td>
<p>Should information about the optimal selection be printed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing
</p>
<table>
<tr><td><code>ics</code></td>
<td>
<p>Values of the ICs for all lambdas</p>
</td></tr>
<tr><td><code>mins</code></td>
<td>
<p>Which IC lead to the minimum (the row number)</p>
</td></tr>
<tr><td><code>selected_lamPhi</code></td>
<td>
<p>Which lambda Phi were selected</p>
</td></tr>
<tr><td><code>selected_lamB</code></td>
<td>
<p>Which lambda B were selected</p>
</td></tr>
</table>

<hr>
<h2 id='ic_selection'>Selects the optimal penalty parameter using information criteria</h2><span id='topic+ic_selection'></span>

<h3>Description</h3>

<p>Selects the optimal penalty parameter using information criteria
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ic_selection(mod, ic = c("bic", "aic", "hq"), verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ic_selection_+3A_mod">mod</code></td>
<td>
<p>Model estimated Model estimated using <code><a href="#topic+sparseVAR">sparseVAR</a></code>,
<code><a href="#topic+sparseVARX">sparseVARX</a></code>, or <code><a href="#topic+sparseVARMA">sparseVARMA</a></code></p>
</td></tr>
<tr><td><code id="ic_selection_+3A_ic">ic</code></td>
<td>
<p>Which information criteria should be used. Must be one of
<code>"bic"</code>, <code>"aic"</code> or <code>"hq"</code></p>
</td></tr>
<tr><td><code id="ic_selection_+3A_verbose">verbose</code></td>
<td>
<p>If true, some useful information will be printed during the process</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a model that uses the optimal penalty
</p>

<hr>
<h2 id='is.stable'>Checks whether a VAR is stable</h2><span id='topic+is.stable'></span>

<h3>Description</h3>

<p>Using a model estimated by <code><a href="#topic+sparseVAR">sparseVAR</a></code>, this function checks whether
the resulting VAR is stable. This is the case, whenever the maximum absolute
eigenvalue of the companion matrix corresponding to the VAR is less than one.
This is sometimes also referred to as that the root lies outside the unit circle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.stable(mod, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.stable_+3A_mod">mod</code></td>
<td>
<p>Model estimated using <code><a href="#topic+sparseVAR">sparseVAR</a></code>. Can only be a model
with one coefficient vector. Hence, the model must be estimated using a selection
method. See <code><a href="#topic+sparseVAR">sparseVAR</a></code> for more details.</p>
</td></tr>
<tr><td><code id="is.stable_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, then the actual maximum absolute
eigenvalue of the companion matrix will be printed to the console.
Default is <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>TRUE</code> if the VAR is stable and <code>FALSE</code> otherwise
</p>

<hr>
<h2 id='lagmatrix'>Creates Lagmatrix of Estimated Coefficients</h2><span id='topic+lagmatrix'></span>

<h3>Description</h3>

<p>Creates Lagmatrix of Estimated Coefficients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lagmatrix(fit, returnplot = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lagmatrix_+3A_fit">fit</code></td>
<td>
<p>Fitted VAR, VARX or VARMA model.</p>
</td></tr>
<tr><td><code id="lagmatrix_+3A_returnplot">returnplot</code></td>
<td>
<p>TRUE or FALSE: return plot of lag matrix or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with estimated lag matrix of the VAR model, or lag matrices
of the VARX or VARMA model. The rows contain the responses, the columns
contain the predictors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(var.example)
mod &lt;- sparseVAR(Y=scale(Y.var), selection="cv")
Lhat &lt;- lagmatrix(fit=mod)
</code></pre>

<hr>
<h2 id='plot_cv'>Plot the Cross Validation Error Curve for a Sparse VAR or VARX</h2><span id='topic+plot_cv'></span>

<h3>Description</h3>

<p>Plot the Cross Validation Error Curve for a Sparse VAR or VARX
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_cv(fit, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_cv_+3A_fit">fit</code></td>
<td>
<p>Fitted VAR, VARMA or VARX model.
returned by <code><a href="#topic+sparseVAR">sparseVAR</a></code>, <code><a href="#topic+sparseVARMA">sparseVARMA</a></code> or <code><a href="#topic+sparseVARX">sparseVARX</a></code>.</p>
</td></tr>
<tr><td><code id="plot_cv_+3A_...">...</code></td>
<td>
<p>Not currently used</p>
</td></tr>
</table>

<hr>
<h2 id='plot.bigtime.recursiveforecast'>Plots Recursive Forecasts</h2><span id='topic+plot.bigtime.recursiveforecast'></span>

<h3>Description</h3>

<p>Plots the recursive forecast obtained using <code><a href="#topic+recursiveforecast">recursiveforecast</a></code>
When forecasts were made for multiple lambdas and <code>lmbda</code> is not a single
number, then a ribbon will be plotted that reaches from the minimum estimate
of all lambdas to the maximum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bigtime.recursiveforecast'
plot(x, series = NULL, lmbda = NULL, last_n = floor(nrow(fcst$Y) * 0.1), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bigtime.recursiveforecast_+3A_x">x</code></td>
<td>
<p>Recursive Forecast obtained using <code><a href="#topic+recursiveforecast">recursiveforecast</a></code></p>
</td></tr>
<tr><td><code id="plot.bigtime.recursiveforecast_+3A_series">series</code></td>
<td>
<p>Series name. If original data has no names, then use Y1 for
the first series, Y2 for the second, and so on.</p>
</td></tr>
<tr><td><code id="plot.bigtime.recursiveforecast_+3A_lmbda">lmbda</code></td>
<td>
<p>Lambdas to be used for plotting. If forecast was done using only
one lambda, then this will be ignored.</p>
</td></tr>
<tr><td><code id="plot.bigtime.recursiveforecast_+3A_last_n">last_n</code></td>
<td>
<p>Last <code>n</code> observations of the original data to include in the plot</p>
</td></tr>
<tr><td><code id="plot.bigtime.recursiveforecast_+3A_...">...</code></td>
<td>
<p>Not currently used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>lmbda</code> is of length one or forecasts were made using only one lambda,
then only a line will be plotted.
</p>
<p>Default names for series are Y1, Y2, ... if the original data does
not have any column names.
</p>


<h3>Value</h3>

<p>Returns a ggplot
</p>

<hr>
<h2 id='plot.bigtime.simVAR'>Plots a simulated VAR</h2><span id='topic+plot.bigtime.simVAR'></span>

<h3>Description</h3>

<p>Plots a simulated VAR
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bigtime.simVAR'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bigtime.simVAR_+3A_x">x</code></td>
<td>
<p>Simulated data of class <code>bigtime.simVAR</code> obtained
from the <code><a href="#topic+simVAR">simVAR</a></code> function</p>
</td></tr>
<tr><td><code id="plot.bigtime.simVAR_+3A_...">...</code></td>
<td>
<p>Not currently used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a ggplot2 plot
</p>

<hr>
<h2 id='recursiveforecast'>Recursively Forecasts a VAR</h2><span id='topic+recursiveforecast'></span>

<h3>Description</h3>

<p>Recursively forecasts a VAR estimated using sparseVAR.
lambda can either be NULL, in which case all lambdas that were used for
model estimation are used for forecasting, or a single value, in which case
only the model using this lambda will be used for forecasting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recursiveforecast(mod, h = 1, lambda = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recursiveforecast_+3A_mod">mod</code></td>
<td>
<p>VAR model estimated using <code>sparseVAR</code></p>
</td></tr>
<tr><td><code id="recursiveforecast_+3A_h">h</code></td>
<td>
<p>Desired forecast horizon. Default is h=1.</p>
</td></tr>
<tr><td><code id="recursiveforecast_+3A_lambda">lambda</code></td>
<td>
<p>Either <code>NULL</code> in which case a forecast will be made for all
lambdas for which the model was estimated, or a single value in which
case a forecast will only be made for the model using this lambda.
Choice is redundant if the model was estimated using a selection procedure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of S3 class <code>bigtime.recursiveforecast</code> containing
</p>
<table>
<tr><td><code>fcst</code></td>
<td>
<p>Matrix or 3D array of forecasts</p>
</td></tr>
<tr><td><code>h</code></td>
<td>
<p>Selected forecast horizon</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>List of lambdas for which the forecasts were made</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>Data used for recursive forecasting</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>sim_data &lt;- simVAR(periods=200, k=5, p=5, seed = 12345)
summary(sim_data)
mod &lt;- sparseVAR(Y=scale(sim_data$Y), selection = "bic")
is.stable(mod)
fcst_recursive &lt;- recursiveforecast(mod, h = 4)
plot(fcst_recursive, series = "Y1")
fcst_direct &lt;- directforecast(mod)
fcst_direct
fcst_recursive$fcst
</code></pre>

<hr>
<h2 id='reduce_cube'>Reduces the third dimension of a cube and returns a data frame</h2><span id='topic+reduce_cube'></span>

<h3>Description</h3>

<p>This is only meant to be a helper function and not meant to be called by
the user itself
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduce_cube(cube, dim3_names, name = deparse(substitute(dim3_names)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduce_cube_+3A_cube">cube</code></td>
<td>
<p>Some 3D array</p>
</td></tr>
<tr><td><code id="reduce_cube_+3A_dim3_names">dim3_names</code></td>
<td>
<p>Vector of length dim(cube)[3] containing a name for
each slice</p>
</td></tr>
<tr><td><code id="reduce_cube_+3A_name">name</code></td>
<td>
<p>What should the column containing the dim3_names be called?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame constructed from the cube
</p>

<hr>
<h2 id='residuals.bigtime.VAR'>Gives the residuals for VAR models estimated using
<code><a href="#topic+sparseVAR">sparseVAR</a></code></h2><span id='topic+residuals.bigtime.VAR'></span>

<h3>Description</h3>

<p>Gives the residuals for VAR models estimated using
<code><a href="#topic+sparseVAR">sparseVAR</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bigtime.VAR'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.bigtime.VAR_+3A_object">object</code></td>
<td>
<p>Model estimated using <code><a href="#topic+sparseVAR">sparseVAR</a></code></p>
</td></tr>
<tr><td><code id="residuals.bigtime.VAR_+3A_...">...</code></td>
<td>
<p>Not currently used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix of residuals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- simVAR(periods=200, k=2, p=5, decay = 0.001, seed = 6150533)
mod &lt;- sparseVAR(Y=scale(dat$Y))
res &lt;- resid(mod)
</code></pre>

<hr>
<h2 id='residuals.bigtime.VARMA'>Gives the residuals for VARMA models estimated using
<code><a href="#topic+sparseVARMA">sparseVARMA</a></code></h2><span id='topic+residuals.bigtime.VARMA'></span>

<h3>Description</h3>

<p>Gives the residuals for VARMA models estimated using
<code><a href="#topic+sparseVARMA">sparseVARMA</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bigtime.VARMA'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.bigtime.VARMA_+3A_object">object</code></td>
<td>
<p>Model estimated using <code><a href="#topic+sparseVARMA">sparseVARMA</a></code></p>
</td></tr>
<tr><td><code id="residuals.bigtime.VARMA_+3A_...">...</code></td>
<td>
<p>Not currently used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix of residuals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(varma.example)
varma &lt;- sparseVARMA(Y = scale(Y.varma), VARMAselection="cv")
res &lt;- residuals(varma)

## End(Not run)
</code></pre>

<hr>
<h2 id='residuals.bigtime.VARX'>Gives the residuals for VARX models estimated using
<code><a href="#topic+sparseVARX">sparseVARX</a></code></h2><span id='topic+residuals.bigtime.VARX'></span>

<h3>Description</h3>

<p>Gives the residuals for VARX models estimated using
<code><a href="#topic+sparseVARX">sparseVARX</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bigtime.VARX'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.bigtime.VARX_+3A_object">object</code></td>
<td>
<p>Model estimated using <code><a href="#topic+sparseVARX">sparseVARX</a></code></p>
</td></tr>
<tr><td><code id="residuals.bigtime.VARX_+3A_...">...</code></td>
<td>
<p>Not currently used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix of residuals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(varx.example)
varx &lt;- sparseVARX(Y=scale(Y.varx), X=scale(X.varx), selection="cv")
res &lt;- residuals(varx)

## End(Not run)
</code></pre>

<hr>
<h2 id='simVAR'>Simulates a VAR(p) with various sparsity patterns</h2><span id='topic+simVAR'></span>

<h3>Description</h3>

<p>Simulates a VAR(p) with various sparsity patterns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simVAR(
  periods,
  k,
  p,
  coef_mat = NULL,
  const = rep(0, k),
  e_dist = rnorm,
  init_y = rep(0, k * p),
  max_abs_eigval = 0.8,
  burnin = periods,
  sparsity_pattern = c("none", "lasso", "L1", "hvar", "HLag"),
  sparsity_options = NULL,
  decay = 1/p,
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simVAR_+3A_periods">periods</code></td>
<td>
<p>Scalar indicating the desired time series length</p>
</td></tr>
<tr><td><code id="simVAR_+3A_k">k</code></td>
<td>
<p>Number of time series</p>
</td></tr>
<tr><td><code id="simVAR_+3A_p">p</code></td>
<td>
<p>Maximum lag number. In case of <code>sparsity_patter="none"</code> this will be
the actual number of lags for all variables</p>
</td></tr>
<tr><td><code id="simVAR_+3A_coef_mat">coef_mat</code></td>
<td>
<p>Coefficient matrix in companion form. If not provided,
one will be simulated</p>
</td></tr>
<tr><td><code id="simVAR_+3A_const">const</code></td>
<td>
<p>Constant term of VAR. Default is zero. Must be either a scalar,
in which case it will be broadcasted to a k-vector, or a k-vector</p>
</td></tr>
<tr><td><code id="simVAR_+3A_e_dist">e_dist</code></td>
<td>
<p>Either a function taking argument n indicating the number of
variables in the system, or a matrix of dimensions k x (periods+burnin)</p>
</td></tr>
<tr><td><code id="simVAR_+3A_init_y">init_y</code></td>
<td>
<p>Initial values. Defaults to zero. Expects either a scalar or
a vector of length (k*p)</p>
</td></tr>
<tr><td><code id="simVAR_+3A_max_abs_eigval">max_abs_eigval</code></td>
<td>
<p>Maximum allowed eigenvalue of companion matrix.
Only applicable if coefficient matrix is being simulated</p>
</td></tr>
<tr><td><code id="simVAR_+3A_burnin">burnin</code></td>
<td>
<p>Number of time points to be used for burnin</p>
</td></tr>
<tr><td><code id="simVAR_+3A_sparsity_pattern">sparsity_pattern</code></td>
<td>
<p>The sparsity pattern that should be simulated.
Options are: <code>"none"</code> for a dense VAR, <code>"lasso"</code> (or <code>"L1"</code>)
for a VAR with random zeroes,
and <code>"hvar"</code> (or <code>"HLag"</code>) for an elementwise hierarchical sparsity pattern</p>
</td></tr>
<tr><td><code id="simVAR_+3A_sparsity_options">sparsity_options</code></td>
<td>
<p>Named list of additional options for
when sparsity pattern is lasso (L1) or hvar (HLag). For lasso (L1) the option <code>num_zero</code>
determines the number of zeros. For hvar (HLag), the options <code>zero_min</code> (<code>zero_max</code>)
give the minimum (maximum) of zeroes for each variable in each equation,
and the option <code>zeroes_in_self</code> (boolean) determines if any of the
coefficients of a variable on itself should be zero.</p>
</td></tr>
<tr><td><code id="simVAR_+3A_decay">decay</code></td>
<td>
<p>How much smaller should parameters for later lags be. The
smaller, the larger will early parameters be w.r.t. later ones.</p>
</td></tr>
<tr><td><code id="simVAR_+3A_seed">seed</code></td>
<td>
<p>Seed to be used for the simulation</p>
</td></tr>
<tr><td><code id="simVAR_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>e_dist</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of S3 class <code>bigtime.simVAR</code> containing the following
</p>
<table>
<tr><td><code>Y</code></td>
<td>
<p>Simulated Data</p>
</td></tr>
<tr><td><code>periods</code></td>
<td>
<p>Time series length</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>Number of endogenous variables</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>Maximum lag length; effective lag length might be shorter due to sparsity patterns</p>
</td></tr>
<tr><td><code>coef_mat</code></td>
<td>
<p>Companion form of the coefficient matrix. Will be of
dimensions (<code>k</code><code>p</code>)x(<code>k</code><code>p</code>). First <code>k</code> rows correspond
to the actual coefficient matrix.</p>
</td></tr>
<tr><td><code>is_coef_mat_simulated</code></td>
<td>
<p><code>TRUE</code> if the <code>coef_mat</code> was simulated, <code>FALSE</code> if
it was user provided</p>
</td></tr>
<tr><td><code>const</code></td>
<td>
<p>Constant term</p>
</td></tr>
<tr><td><code>e_dist</code></td>
<td>
<p>Errors used in the construction of the data</p>
</td></tr>
<tr><td><code>init_y</code></td>
<td>
<p>Initial conditions</p>
</td></tr>
<tr><td><code>max_abs_eigval</code></td>
<td>
<p>Maximum eigenvalue to which the companion matrix
was constraint</p>
</td></tr>
<tr><td><code>burnin</code></td>
<td>
<p>Burnin period used</p>
</td></tr>
<tr><td><code>sparsity_pattern</code></td>
<td>
<p>Sparsity pattern used</p>
</td></tr>
<tr><td><code>sparsity_options</code></td>
<td>
<p>Extra options for the sparsity patterns used</p>
</td></tr>
<tr><td><code>seed</code></td>
<td>
<p>Seed used for the simulation</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>periods &lt;- 200 # time series length
k &lt;- 5 # number of variables
p &lt;- 10 # maximum lag
sparsity_pattern &lt;- "HLag" # HLag sparsity structure
sparsity_options &lt;- list(zero_min = 0, # variables can be included with all lags
                         zero_max = 10, # but some could also include no lags
                         zeroes_in_self = TRUE)
sim &lt;- simVAR(periods=periods, k=k, p=p, sparsity_pattern=sparsity_pattern,
              sparsity_options=sparsity_options, seed = 12345)
summary(sim)
</code></pre>

<hr>
<h2 id='sparseVAR'>Sparse Estimation of the Vector AutoRegressive (VAR) Model</h2><span id='topic+sparseVAR'></span>

<h3>Description</h3>

<p>Sparse Estimation of the Vector AutoRegressive (VAR) Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparseVAR(
  Y,
  p = NULL,
  VARpen = "HLag",
  VARlseq = NULL,
  VARgran = NULL,
  selection = c("none", "cv", "bic", "aic", "hq"),
  cvcut = 0.9,
  h = 1,
  eps = 0.001,
  check_std = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparseVAR_+3A_y">Y</code></td>
<td>
<p>A <code class="reqn">T</code> by <code class="reqn">k</code> matrix of time series. If k=1, a univariate autoregressive model is estimated.</p>
</td></tr>
<tr><td><code id="sparseVAR_+3A_p">p</code></td>
<td>
<p>User-specified maximum autoregressive lag order of the VAR. Typical usage is to have the program compute its own maximum lag order based on the time series length.</p>
</td></tr>
<tr><td><code id="sparseVAR_+3A_varpen">VARpen</code></td>
<td>
<p>&quot;HLag&quot; (hierarchical sparse penalty) or &quot;L1&quot; (standard lasso penalty) penalization.</p>
</td></tr>
<tr><td><code id="sparseVAR_+3A_varlseq">VARlseq</code></td>
<td>
<p>User-specified grid of values for regularization parameter corresponding to sparse penalty. Typical usage is to have the program compute
its own grid. Supplying a grid of values overrides this. WARNING: use with care.</p>
</td></tr>
<tr><td><code id="sparseVAR_+3A_vargran">VARgran</code></td>
<td>
<p>User-specified vector of granularity specifications for the penalty parameter grid:  First element specifies
how deep the grid should be constructed. Second element specifies how many values the grid should contain.</p>
</td></tr>
<tr><td><code id="sparseVAR_+3A_selection">selection</code></td>
<td>
<p>One of &quot;none&quot; (default), &quot;cv&quot; (Time Series Cross-Validation), &quot;bic&quot;, &quot;aic&quot;, &quot;hq&quot;. Used to select the optimal penalization.</p>
</td></tr>
<tr><td><code id="sparseVAR_+3A_cvcut">cvcut</code></td>
<td>
<p>Proportion of observations used for model estimation in the time series cross-validation procedure. The remainder is used for forecast evaluation. Redundant if selection is not &quot;cv&quot;.</p>
</td></tr>
<tr><td><code id="sparseVAR_+3A_h">h</code></td>
<td>
<p>Desired forecast horizon in time-series cross-validation procedure.</p>
</td></tr>
<tr><td><code id="sparseVAR_+3A_eps">eps</code></td>
<td>
<p>a small positive numeric value giving the tolerance for convergence in the proximal gradient algorithm.</p>
</td></tr>
<tr><td><code id="sparseVAR_+3A_check_std">check_std</code></td>
<td>
<p>Check whether data is standardised. Default is TRUE and is not recommended to be changed</p>
</td></tr>
<tr><td><code id="sparseVAR_+3A_verbose">verbose</code></td>
<td>
<p>Logical to print value of information criteria for each lambda together with selection. Default is FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components
</p>
<table>
<tr><td><code>Y</code></td>
<td>
<p><code class="reqn">T</code> by <code class="reqn">k</code> matrix of time series.</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>Number of time series.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>Maximum autoregressive lag order of the VAR.</p>
</td></tr>
<tr><td><code>Phihat</code></td>
<td>
<p>Matrix of estimated autoregressive coefficients of the VAR.</p>
</td></tr>
<tr><td><code>phi0hat</code></td>
<td>
<p>vector of VAR intercepts.</p>
</td></tr>
<tr><td><code>series_names</code></td>
<td>
<p>names of time series</p>
</td></tr>
<tr><td><code>lambdas</code></td>
<td>
<p>sparsity parameter grid</p>
</td></tr>
<tr><td><code>MSFEcv</code></td>
<td>
<p>MSFE cross-validation scores for each value of the sparsity parameter in the considered grid</p>
</td></tr>
<tr><td><code>MSFEcv_all</code></td>
<td>
<p>MSFE cross-validation full output</p>
</td></tr>
<tr><td><code>lambda_opt</code></td>
<td>
<p>Optimal value of the sparsity parameter as selected by the time-series cross-validation procedure</p>
</td></tr>
<tr><td><code>lambda_SEopt</code></td>
<td>
<p>Optimal value of the sparsity parameter as selected by the time-series cross-validation
procedure and after applying the one-standard-error rule.  This is the value used.</p>
</td></tr>
<tr><td><code>h</code></td>
<td>
<p>Forecast horizon h</p>
</td></tr>
</table>


<h3>References</h3>

<p>Nicholson William B., Wilms Ines, Bien Jacob and Matteson David S. (2020), “High-dimensional forecasting via interpretable vector autoregression”, Journal of Machine Learning Research, 21(166), 1-52.
</p>


<h3>See Also</h3>

<p><a href="#topic+lagmatrix">lagmatrix</a> and <a href="#topic+directforecast">directforecast</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(var.example)
VARfit &lt;- sparseVAR(Y = scale(Y.var)) # sparse VAR
ARfit &lt;- sparseVAR(Y=scale(Y.var[,2])) # sparse AR
</code></pre>

<hr>
<h2 id='sparseVARMA'>Sparse Estimation of the Vector AutoRegressive Moving Average (VARMA) Model</h2><span id='topic+sparseVARMA'></span>

<h3>Description</h3>

<p>Sparse Estimation of the Vector AutoRegressive Moving Average (VARMA) Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparseVARMA(
  Y,
  U = NULL,
  VARp = NULL,
  VARpen = "HLag",
  VARlseq = NULL,
  VARgran = NULL,
  VARselection = c("cv", "bic", "aic", "hq"),
  VARMAp = NULL,
  VARMAq = NULL,
  VARMApen = "HLag",
  VARMAlPhiseq = NULL,
  VARMAPhigran = NULL,
  VARMAlThetaseq = NULL,
  VARMAThetagran = NULL,
  VARMAalpha = 0,
  VARMAselection = c("none", "cv", "bic", "aic", "hq"),
  h = 1,
  cvcut = 0.9,
  eps = 10^-3,
  check_std = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparseVARMA_+3A_y">Y</code></td>
<td>
<p>A <code class="reqn">T</code> by <code class="reqn">k</code> matrix of time series. If k=1, a univariate autoregressive moving average model is estimated.</p>
</td></tr>
<tr><td><code id="sparseVARMA_+3A_u">U</code></td>
<td>
<p>A <code class="reqn">T</code> by <code class="reqn">k</code> matrix of (approximated) error terms. Typical usage is to have the program estimate a high-order VAR model (Phase I) to get approximated error terms U.</p>
</td></tr>
<tr><td><code id="sparseVARMA_+3A_varp">VARp</code></td>
<td>
<p>User-specified maximum  autoregressive lag order of the PhaseI VAR. Typical usage is to have the program compute its own maximum lag order based on the time series length.</p>
</td></tr>
<tr><td><code id="sparseVARMA_+3A_varpen">VARpen</code></td>
<td>
<p>&quot;HLag&quot; (hierarchical sparse penalty) or &quot;L1&quot; (standard lasso penalty) penalization in PhaseI VAR.</p>
</td></tr>
<tr><td><code id="sparseVARMA_+3A_varlseq">VARlseq</code></td>
<td>
<p>User-specified grid of values for regularization parameter in the PhaseI VAR. Typical usage is to have the program compute
its own grid. Supplying a grid of values overrides this. WARNING: use with care.</p>
</td></tr>
<tr><td><code id="sparseVARMA_+3A_vargran">VARgran</code></td>
<td>
<p>User-specified vector of granularity specifications for the penalty parameter grid of the PhaseI VAR:  First element specifies
how deep the grid should be constructed. Second element specifies how many values the grid should contain.</p>
</td></tr>
<tr><td><code id="sparseVARMA_+3A_varselection">VARselection</code></td>
<td>
<p>Selection procedure for the first stage. Default is time series Cross-Validation. Alternatives are BIC, AIC, HQ</p>
</td></tr>
<tr><td><code id="sparseVARMA_+3A_varmap">VARMAp</code></td>
<td>
<p>User-specified maximum autoregressive lag order of the VARMA. Typical usage is to have the program compute its own maximum lag order based on the time series length.</p>
</td></tr>
<tr><td><code id="sparseVARMA_+3A_varmaq">VARMAq</code></td>
<td>
<p>User-specified maximum moving average lag order of the VARMA. Typical usage is to have the program compute its own maximum lag order based on the time series length.</p>
</td></tr>
<tr><td><code id="sparseVARMA_+3A_varmapen">VARMApen</code></td>
<td>
<p>&quot;HLag&quot; (hierarchical sparse penalty) or &quot;L1&quot; (standard lasso penalty) penalization in the VARMA.</p>
</td></tr>
<tr><td><code id="sparseVARMA_+3A_varmalphiseq">VARMAlPhiseq</code></td>
<td>
<p>User-specified grid of values for regularization parameter corresponding to the autoregressive coefficients in the VARMA. Typical usage is to have the program compute
its own grid. Supplying a grid of values overrides this. WARNING: use with care.</p>
</td></tr>
<tr><td><code id="sparseVARMA_+3A_varmaphigran">VARMAPhigran</code></td>
<td>
<p>User-specified vector of granularity specifications for the penalty parameter grid corresponding to the autoregressive coefficients in the VARMA:  First element specifies
how deep the grid should be constructed. Second element specifies how many values the grid should contain.</p>
</td></tr>
<tr><td><code id="sparseVARMA_+3A_varmalthetaseq">VARMAlThetaseq</code></td>
<td>
<p>User-specified grid of values for regularization parameter corresponding to the moving average coefficients in the VARMA. Typical usage is to have the program compute
its own grid. Supplying a grid of values overrides this. WARNING: use with care.</p>
</td></tr>
<tr><td><code id="sparseVARMA_+3A_varmathetagran">VARMAThetagran</code></td>
<td>
<p>User-specified vector of granularity specifications for the penalty parameter grid corresponding to the moving average coefficients in the VARMA:  First element specifies
how deep the grid should be constructed. Second element specifies how many values the grid should contain.</p>
</td></tr>
<tr><td><code id="sparseVARMA_+3A_varmaalpha">VARMAalpha</code></td>
<td>
<p>a small positive regularization parameter value corresponding to squared Frobenius penalty in  VARMA. The default is zero.</p>
</td></tr>
<tr><td><code id="sparseVARMA_+3A_varmaselection">VARMAselection</code></td>
<td>
<p>selection procedure in the second stage. Default is &quot;none&quot;; Alternatives are cv, bic, aic, hq</p>
</td></tr>
<tr><td><code id="sparseVARMA_+3A_h">h</code></td>
<td>
<p>Desired forecast horizon in time-series cross-validation procedure.</p>
</td></tr>
<tr><td><code id="sparseVARMA_+3A_cvcut">cvcut</code></td>
<td>
<p>Proportion of observations used for model estimation in the time series cross-validation procedure. The remainder is used for forecast evaluation.</p>
</td></tr>
<tr><td><code id="sparseVARMA_+3A_eps">eps</code></td>
<td>
<p>a small positive numeric value giving the tolerance for convergence in the proximal gradient algorithms.</p>
</td></tr>
<tr><td><code id="sparseVARMA_+3A_check_std">check_std</code></td>
<td>
<p>Check whether data is standardised. Default is TRUE and is not recommended to be changed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components
</p>
<table>
<tr><td><code>Y</code></td>
<td>
<p><code class="reqn">T</code> by <code class="reqn">k</code> matrix of time series.</p>
</td></tr>
<tr><td><code>U</code></td>
<td>
<p>Matrix of (approximated) error terms.</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>Number of time series.</p>
</td></tr>
<tr><td><code>VARp</code></td>
<td>
<p>Maximum autoregressive lag order of the PhaseI VAR.</p>
</td></tr>
<tr><td><code>VARPhihat</code></td>
<td>
<p>Matrix of estimated autoregressive coefficients of the Phase I VAR.</p>
</td></tr>
<tr><td><code>VARphi0hat</code></td>
<td>
<p>Vector of Phase I VAR intercepts.</p>
</td></tr>
<tr><td><code>VARMAp</code></td>
<td>
<p>Maximum autoregressive lag order of the VARMA.</p>
</td></tr>
<tr><td><code>VARMAq</code></td>
<td>
<p>Maximum moving average lag order of the VARMA.</p>
</td></tr>
<tr><td><code>Phihat</code></td>
<td>
<p>Matrix of estimated autoregressive coefficients of the VARMA.</p>
</td></tr>
<tr><td><code>Thetahat</code></td>
<td>
<p>Matrix of estimated moving average coefficients of the VARMA.</p>
</td></tr>
<tr><td><code>phi0hat</code></td>
<td>
<p>Vector of VARMA intercepts.</p>
</td></tr>
<tr><td><code>series_names</code></td>
<td>
<p>names of time series</p>
</td></tr>
<tr><td><code>PhaseI_lambas</code></td>
<td>
<p>Phase I sparsity parameter grid</p>
</td></tr>
<tr><td><code>PhaseI_MSFEcv</code></td>
<td>
<p>MSFE cross-validation scores for each value of the sparsity parameter in the considered grid</p>
</td></tr>
<tr><td><code>PhaseI_lambda_opt</code></td>
<td>
<p>Phase I Optimal value of the sparsity parameter as selected by the time-series cross-validation procedure</p>
</td></tr>
<tr><td><code>PhaseI_lambda_SEopt</code></td>
<td>
<p>Phase I Optimal value of the sparsity parameter as selected by the time-series cross-validation procedure and after applying the one-standard-error rule</p>
</td></tr>
<tr><td><code>PhaseII_lambdaPhi</code></td>
<td>
<p>Phase II sparsity parameter grid corresponding to Phi parameters</p>
</td></tr>
<tr><td><code>PhaseII_lambdaTheta</code></td>
<td>
<p>Phase II sparsity parameter grid corresponding to Theta parameters</p>
</td></tr>
<tr><td><code>PhaseII_lambdaPhi_opt</code></td>
<td>
<p>Phase II Optimal value of the sparsity parameter (corresponding to Phi parameters) as selected by the time-series cross-validation procedure</p>
</td></tr>
<tr><td><code>PhaseII_lambdaPhi_SEopt</code></td>
<td>
<p>Phase II Optimal value of the sparsity parameter (corresponding to Theta parameters) as selected by the time-series cross-validation procedure and after applying the one-standard-error rule</p>
</td></tr>
<tr><td><code>PhaseII_lambdaTheta_opt</code></td>
<td>
<p>Phase II Optimal value of the sparsity parameter (corresponding to Phi parameters) as selected by the time-series cross-validation procedure</p>
</td></tr>
<tr><td><code>PhaseII_lambdaTheta_SEopt</code></td>
<td>
<p>Phase II Optimal value of the sparsity parameter (corresponding to Theta parameters) as selected by the time-series cross-validation procedure and after applying the one-standard-error rule</p>
</td></tr>
<tr><td><code>PhaseII_MSFEcv</code></td>
<td>
<p>Phase II MSFE cross-validation scores for each value in the two-dimensional sparsity grid</p>
</td></tr>
<tr><td><code>h</code></td>
<td>
<p>Forecast horizon h</p>
</td></tr>
</table>


<h3>References</h3>

<p>Wilms Ines, Sumanta Basu, Bien Jacob and Matteson David S. (2021), “Sparse Identification and
Estimation of Large-Scale Vector AutoRegressive Moving Averages”, Journal of the American Statistical Association, doi: 10.1080/01621459.2021.1942013.
</p>


<h3>See Also</h3>

<p><a href="#topic+lagmatrix">lagmatrix</a> and <a href="#topic+directforecast">directforecast</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(varma.example)
VARMAfit &lt;- sparseVARMA(Y = scale(Y.varma)) # sparse VARMA
y &lt;- matrix(Y.varma[,1], ncol=1)
ARMAfit &lt;- sparseVARMA(Y=scale(y)) # sparse ARMA
</code></pre>

<hr>
<h2 id='sparseVARX'>Sparse Estimation of the Vector AutoRegressive  with Exogenous Variables X (VARX) Model</h2><span id='topic+sparseVARX'></span>

<h3>Description</h3>

<p>Sparse Estimation of the Vector AutoRegressive  with Exogenous Variables X (VARX) Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparseVARX(
  Y,
  X,
  p = NULL,
  s = NULL,
  VARXpen = "HLag",
  VARXlPhiseq = NULL,
  VARXPhigran = NULL,
  VARXlBseq = NULL,
  VARXBgran = NULL,
  VARXalpha = 0,
  h = 1,
  cvcut = 0.9,
  eps = 10^-3,
  selection = c("none", "cv", "bic", "aic", "hq"),
  check_std = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparseVARX_+3A_y">Y</code></td>
<td>
<p>A <code class="reqn">T</code> by <code class="reqn">k</code> matrix of time series. If k=1, a univariate autoregressive model is estimated.</p>
</td></tr>
<tr><td><code id="sparseVARX_+3A_x">X</code></td>
<td>
<p>A <code class="reqn">T</code> by <code class="reqn">m</code> matrix of time series.</p>
</td></tr>
<tr><td><code id="sparseVARX_+3A_p">p</code></td>
<td>
<p>User-specified maximum endogenous autoregressive lag order. Typical usage is to have the program compute its own maximum lag order based on the time series length.</p>
</td></tr>
<tr><td><code id="sparseVARX_+3A_s">s</code></td>
<td>
<p>User-specified maximum exogenous autoregressive lag order. Typical usage is to have the program compute its own maximum lag order based on the time series length.</p>
</td></tr>
<tr><td><code id="sparseVARX_+3A_varxpen">VARXpen</code></td>
<td>
<p>&quot;HLag&quot; (hierarchical sparse penalty) or &quot;L1&quot; (standard lasso penalty) penalization in VARX.</p>
</td></tr>
<tr><td><code id="sparseVARX_+3A_varxlphiseq">VARXlPhiseq</code></td>
<td>
<p>User-specified grid of values for regularization parameter corresponding to the endogenous autoregressive coefficients in the VARX. Typical usage is to have the program compute
its own grid. Supplying a grid of values overrides this. WARNING: use with care.</p>
</td></tr>
<tr><td><code id="sparseVARX_+3A_varxphigran">VARXPhigran</code></td>
<td>
<p>User-specified vector of granularity specifications for the penalty parameter grid corresponding to the endogenous autoregressive coefficients in the VARX:  First element specifies
how deep the grid should be constructed. Second element specifies how many values the grid should contain.</p>
</td></tr>
<tr><td><code id="sparseVARX_+3A_varxlbseq">VARXlBseq</code></td>
<td>
<p>User-specified grid of values for regularization parameter corresponding to the exogenous autoregressive coefficients in the VARX. Typical usage is to have the program compute
its own grid. Supplying a grid of values overrides this. WARNING: use with care.</p>
</td></tr>
<tr><td><code id="sparseVARX_+3A_varxbgran">VARXBgran</code></td>
<td>
<p>User-specified vector of granularity specifications for the penalty parameter grid corresponding to the exogenous autoregressive coefficients in the VARX:  First element specifies
how deep the grid should be constructed. Second element specifies how many values the grid should contain.</p>
</td></tr>
<tr><td><code id="sparseVARX_+3A_varxalpha">VARXalpha</code></td>
<td>
<p>a small positive regularization parameter value corresponding to squared Frobenius penalty. The default is zero.</p>
</td></tr>
<tr><td><code id="sparseVARX_+3A_h">h</code></td>
<td>
<p>Desired forecast horizon in time-series cross-validation procedure.</p>
</td></tr>
<tr><td><code id="sparseVARX_+3A_cvcut">cvcut</code></td>
<td>
<p>Proportion of observations used for model estimation in the time series cross-validation procedure. The remainder is used for forecast evaluation.</p>
</td></tr>
<tr><td><code id="sparseVARX_+3A_eps">eps</code></td>
<td>
<p>a small positive numeric value giving the tolerance for convergence in the proximal gradient algorithm.</p>
</td></tr>
<tr><td><code id="sparseVARX_+3A_selection">selection</code></td>
<td>
<p>Model selection method to be used. Default is none, which will return all values for all penalisations.</p>
</td></tr>
<tr><td><code id="sparseVARX_+3A_check_std">check_std</code></td>
<td>
<p>Check whether data is standardised. Default is TRUE and is not recommended to be changed</p>
</td></tr>
<tr><td><code id="sparseVARX_+3A_verbose">verbose</code></td>
<td>
<p>Logical to print value of information criteria for each lambda together with selection. Default is FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components
</p>
<table>
<tr><td><code>Y</code></td>
<td>
<p><code class="reqn">T</code> by <code class="reqn">k</code> matrix of endogenous time series.</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p><code class="reqn">T</code> by <code class="reqn">m</code> matrix of exogenous time series.</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>Number of endogenous time series.</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>Number of exogenous time series.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>Maximum endogenous autoregressive lag order of the VARX.</p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>Maximum exogenouss autoregressive lag order of the VARX.</p>
</td></tr>
<tr><td><code>Phihat</code></td>
<td>
<p>Matrix of estimated endogenous autoregressive coefficients.</p>
</td></tr>
<tr><td><code>Bhat</code></td>
<td>
<p>Matrix of estimated exogenous autoregressive coefficients.</p>
</td></tr>
<tr><td><code>phi0hat</code></td>
<td>
<p>vector of VARX intercepts.</p>
</td></tr>
<tr><td><code>exogenous_series_names</code></td>
<td>
<p>names of the exogenous time series</p>
</td></tr>
<tr><td><code>endogenous_series_names</code></td>
<td>
<p>names of the endogenous time series</p>
</td></tr>
<tr><td><code>lambdaPhi</code></td>
<td>
<p>sparsity parameter grid corresponding to endogenous autoregressive parameters</p>
</td></tr>
<tr><td><code>lambdaB</code></td>
<td>
<p>sparsity parameter grid corresponding to exogenous autoregressive parameters</p>
</td></tr>
<tr><td><code>lambdaPhi_opt</code></td>
<td>
<p>Optimal value of the sparsity parameter (corresponding to the endogenous autoregressive parameters) as selected by the time-series cross-validation procedure</p>
</td></tr>
<tr><td><code>lambdaPhi_SEopt</code></td>
<td>
<p>Optimal value of the sparsity parameter (corresponding to the endogenous autoregressive parameters) as selected by the time-series cross-validation procedure and after applying the one-standard-error rule</p>
</td></tr>
<tr><td><code>lambdaB_opt</code></td>
<td>
<p>Optimal value of the sparsity parameter (corresponding to the exogenous autoregressive parameters) as selected by the time-series cross-validation procedure</p>
</td></tr>
<tr><td><code>lambdaB_SEopt</code></td>
<td>
<p>Optimal value of the sparsity parameter (corresponding to the exogenous autoregressive parameters) as selected by the time-series cross-validation procedure and after applying the one-standard-error rule</p>
</td></tr>
<tr><td><code>MSFEcv</code></td>
<td>
<p>MSFE cross-validation scores for each value in the two-dimensional sparsity grid</p>
</td></tr>
<tr><td><code>h</code></td>
<td>
<p>Forecast horizon h</p>
</td></tr>
</table>


<h3>References</h3>

<p>Wilms Ines, Sumanta Basu, Bien Jacob and Matteson David S. (2017), “Interpretable vector autoregressions with exogenous time series”, NIPS 2017 Symposium on Interpretable Machine Learning, arXiv:1711.03623.
</p>


<h3>See Also</h3>

<p><a href="#topic+lagmatrix">lagmatrix</a> and <a href="#topic+directforecast">directforecast</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(varx.example)
VARXfit &lt;- sparseVARX(Y=scale(Y.varx), X=scale(X.varx)) # sparse VARX
y &lt;- matrix(Y.varx[,1], ncol=1)
ARXfit &lt;- sparseVARX(Y=y, X=X.varx) # sparse ARX
</code></pre>

<hr>
<h2 id='summary.bigtime.simVAR'>Gives a small summary of a VAR simulation</h2><span id='topic+summary.bigtime.simVAR'></span>

<h3>Description</h3>

<p>Gives a small summary of a VAR simulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bigtime.simVAR'
summary(object, plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.bigtime.simVAR_+3A_object">object</code></td>
<td>
<p>Simulated data of class <code>bigtime.simVAR</code> obtained
from the <code><a href="#topic+simVAR">simVAR</a></code> function</p>
</td></tr>
<tr><td><code id="summary.bigtime.simVAR_+3A_plot">plot</code></td>
<td>
<p>Should the VAR be plotted. Default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="summary.bigtime.simVAR_+3A_...">...</code></td>
<td>
<p>Not currently used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If 'plot=TRUE', then a ggplot2 plot will be returned
</p>

<hr>
<h2 id='X.varx'>VARX Time Series Example (<code>varx.example</code>)</h2><span id='topic+X.varx'></span>

<h3>Description</h3>

<p>The data consists of a 200x3 matrix of endogenous variables, <code>Y.varx</code>,
and a 200x3 matrix of exogenous variables, <code>X.varx</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>X.varx
</code></pre>


<h3>Format</h3>

<p>Two matrices, <code>X.varx</code> and <code>Y.varx</code>, both of dimension 200x3
</p>

<hr>
<h2 id='Y.var'>VAR Time Series Example (<code>var.example</code>)</h2><span id='topic+Y.var'></span>

<h3>Description</h3>

<p>The data consists of a 200x5 data matrix, <code>Y.var</code>, and was simulated from a sparse
VAR model with HLag sparsity pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Y.var
</code></pre>


<h3>Format</h3>

<p>A matrix of dimension 200x5
</p>

<hr>
<h2 id='Y.varma'>VARMA Time Series Example (<code>varma.example</code>)</h2><span id='topic+Y.varma'></span>

<h3>Description</h3>

<p>The data consists of a 200x3 data matrix, <code>Y.varma</code>, and was simulated from a
sparse VARMA model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Y.varma
</code></pre>


<h3>Format</h3>

<p>A matrix of dimension 200x3
</p>

<hr>
<h2 id='Y.varx'>VARX Time Series Example (<code>varx.example</code>)</h2><span id='topic+Y.varx'></span>

<h3>Description</h3>

<p>The data consists of a 200x3 matrix of endogenous variables, <code>Y.varx</code>,
and a 200x3 matrix of exogenous variables, <code>X.varx</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Y.varx
</code></pre>


<h3>Format</h3>

<p>Two matrices, <code>X.varx</code> and <code>Y.varx</code>, both of dimension 200x3
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
