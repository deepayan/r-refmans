<!DOCTYPE html><html><head><title>Help for package musclesyneRgies</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {musclesyneRgies}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#classify_kmeans'><p>Muscle synergy classification with k-means</p></a></li>
<li><a href='#CoA'><p>Centre of activity</p></a></li>
<li><a href='#FILT_EMG'><p>Filtered EMG example</p></a></li>
<li><a href='#filtEMG'><p>To filter raw EMG</p></a></li>
<li><a href='#FWHM'><p>Full width at half maximum</p></a></li>
<li><a href='#HFD'><p>Higuchi's fractal dimension</p></a></li>
<li><a href='#Hurst'><p>Hurst exponent</p></a></li>
<li><a href='#normEMG'><p>To time-normalise filtered EMG</p></a></li>
<li><a href='#plot_classified_syns'><p>Plot muscle synergies</p></a></li>
<li><a href='#plot_classified_syns_UMAP'><p>Plot 2D UMAP of muscle synergies</p></a></li>
<li><a href='#plot_meanEMG'><p>Plot EMG averaged across all cycles</p></a></li>
<li><a href='#plot_rawEMG'><p>Plot raw EMG</p></a></li>
<li><a href='#plot_syn_trials'><p>Plot muscle synergies (individual trials)</p></a></li>
<li><a href='#primitive'><p>Single motor primitive example (30 cycles)</p></a></li>
<li><a href='#primitives'><p>All motor primitives of one synergy example (30 cycles)</p></a></li>
<li><a href='#RAW_DATA'><p>Raw EMG example</p></a></li>
<li><a href='#rawdata'><p>Import RData or ASCII data into R</p></a></li>
<li><a href='#sMLE'><p>Short-term maximum Lyapunov exponents</p></a></li>
<li><a href='#subsetEMG'><p>Subset raw EMG</p></a></li>
<li><a href='#SYNS'><p>Muscle synergies example</p></a></li>
<li><a href='#synsNMF'><p>Non-negative matrix factorisation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Extract Muscle Synergies from Electromyography</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a framework to factorise electromyography (EMG) data.
    Tools are provided for raw data pre-processing, non negative matrix factorisation,
    classification of factorised data and plotting of obtained outcomes.
    In particular, reading from ASCII files is supported, along with wide-used
    filtering approaches to process EMG data. All steps include one or more sensible
    defaults that aim at simplifying the workflow. Yet, all functions are largely
    tunable at need. Example data sets are included.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/alesantuz/musclesyneRgies">https://github.com/alesantuz/musclesyneRgies</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/alesantuz/musclesyneRgies/issues">https://github.com/alesantuz/musclesyneRgies/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>FNN, ggplot2, graphics, grDevices, gridExtra, plyr, proxy,
reshape2, signal, stats, umap</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-07-19 16:59:00 UTC; aless</td>
</tr>
<tr>
<td>Author:</td>
<td>Alessandro Santuz <a href="https://orcid.org/0000-0002-6577-5101"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alessandro Santuz &lt;alessandro.santuz@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-07-19 17:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='classify_kmeans'>Muscle synergy classification with k-means</h2><span id='topic+classify_kmeans'></span>

<h3>Description</h3>

<p>Muscle synergy classification with k-means
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classify_kmeans(x, MSE_lim = 0.001, inspect = FALSE, show_plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classify_kmeans_+3A_x">x</code></td>
<td>
<p>A list of <code>musclesyneRgies</code> objects</p>
</td></tr>
<tr><td><code id="classify_kmeans_+3A_mse_lim">MSE_lim</code></td>
<td>
<p>Mean squared error threshold for determining the minimum number of clusters</p>
</td></tr>
<tr><td><code id="classify_kmeans_+3A_inspect">inspect</code></td>
<td>
<p>Logical, ask for interactive re-ordering or go fully automated?</p>
</td></tr>
<tr><td><code id="classify_kmeans_+3A_show_plot">show_plot</code></td>
<td>
<p>Logical, to decide whether plots should be plotted in the active graphic device</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function must be applied to a list with a sufficient amount of trials, otherwise the
classification will not work. Typically, at least 10 trials for the same condition are needed
for satisfactory classification. If <code>show_plot</code> is TRUE (default) plots are also shown in the
active graphic device.
Plots can then be saved with the preferred export method, such as <code>ggplot2::ggsave</code>.
The algorithm used is the default for stats::kmeans (Hartigan and Wong, 1979), which is known
for its robustness to local minima. Nonetheless, the stochastic nature of the algorithm
should prompt the user to attempt a few classifications and analyse their stability,
before drawing conclusions on e.g. the number of fundamental synergies and/or their function.
While the default parameters are optimised for human locomotion, it is suggested to test the
function with different mean squared error thresholds, which is a crucial quantity to
determine the number of clusters. Inspection and plotting are as well highly recommended
to gain more insight into the classification process.
</p>


<h3>Value</h3>

<p>List of <code>musclesyneRgies</code> objects, each with elements:<br />
</p>

<ul>
<li> <p><code>syns</code> factorisation rank or minimum number of synergies<br />
</p>
</li>
<li> <p><code>M</code> motor modules (time-invariant coefficients)<br />
</p>
</li>
<li> <p><code>P</code> motor primitives (time-dependent coefficients)<br />
</p>
</li>
<li> <p><code>V</code> original data<br />
</p>
</li>
<li> <p><code>Vr</code> reconstructed data<br />
</p>
</li>
<li> <p><code>iterations</code> number of iterations to convergence<br />
</p>
</li>
<li> <p><code>R2</code> quality of reconstruction (coefficient of determination)
</p>
</li>
<li> <p><code>rank_type</code> was the rank <code>fixed</code> or <code>variable</code>?<br />
</p>
</li>
<li> <p><code>classification</code> classification type (<code>k-means</code>)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Load some data
data(SYNS)
# Classify synergies
SYNS_classified &lt;- classify_kmeans(SYNS)
</code></pre>

<hr>
<h2 id='CoA'>Centre of activity</h2><span id='topic+CoA'></span>

<h3>Description</h3>

<p>Centre of activity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CoA(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CoA_+3A_x">x</code></td>
<td>
<p>A time series  (numeric)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The centre of activity of the time series, calculated with
circular statistics
</p>


<h3>References</h3>

<p>Martino, G. et al.
Locomotor patterns in cerebellar ataxia.
J. Neurophysiol. 112, 2810–2821 (2014).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Number of users connected to the Internet through a server every minute
ts &lt;- datasets::WWWusage[1:80]

# Calculate CoA
ts_CoA &lt;- CoA(ts)

# Plot
plot(ts, ty = "l", xlab = "Time", ylab = "Number of users")
graphics::abline(v = ts_CoA, lwd = 2, lty = 2)
</code></pre>

<hr>
<h2 id='FILT_EMG'>Filtered EMG example</h2><span id='topic+FILT_EMG'></span>

<h3>Description</h3>

<p>A list containing filtered and time-normalised electromyographic (EMG)
human data from the right-side lower limb recorded during one walking trial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FILT_EMG
</code></pre>


<h3>Format</h3>

<p>A list containing one object of class <code>EMG</code>
with elements <code>cycles</code> and <code>emg</code>, both data frames.
</p>

<dl>
<dt><code>ID0012_TW_01</code></dt><dd><p>Object of class <code>EMG</code> containing the two following data frames:</p>
</dd>
<dt><code>cycles</code></dt><dd><p>Gait cycle-timings, in seconds.</p>
</dd>
<dt><code>emg</code></dt><dd><p>Filtered and time-normalised EMG, first column is time in points, muscles named as:<br /><br />
ME=gluteus medius<br />
MA=gluteus maximus<br />
FL=tensor fasciae latae<br />
RF=rectus femoris<br />
VM=vastus medialis<br />
VL=vastus lateralis<br />
ST=semitendinosus<br />
BF=biceps femoris<br />
TA=tibialis anterior<br />
PL=peroneus longus<br />
GM=gastrocnemius medialis<br />
GL=gastrocnemius lateralis<br />
SO=soleus</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://doi.org/10.1016/j.isci.2019.100796">doi:10.1016/j.isci.2019.100796</a>
</p>

<hr>
<h2 id='filtEMG'>To filter raw EMG</h2><span id='topic+filtEMG'></span>

<h3>Description</h3>

<p>To filter raw EMG
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filtEMG(
  x,
  demean = TRUE,
  rectif = "fullwave",
  HPf = 50,
  HPo = 4,
  LPf = 20,
  LPo = 4,
  min_sub = TRUE,
  ampl_norm = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filtEMG_+3A_x">x</code></td>
<td>
<p>Object of class <code>EMG</code> with elements <code>cycles</code> and <code>emg</code></p>
</td></tr>
<tr><td><code id="filtEMG_+3A_demean">demean</code></td>
<td>
<p>Logical: should EMG be demeaned?</p>
</td></tr>
<tr><td><code id="filtEMG_+3A_rectif">rectif</code></td>
<td>
<p>Rectification type: &quot;fullwave&quot;, &quot;halfwave&quot; or &quot;none&quot;</p>
</td></tr>
<tr><td><code id="filtEMG_+3A_hpf">HPf</code></td>
<td>
<p>High-pass filter cut-off frequency, use 0 to exclude high-pass filtering</p>
</td></tr>
<tr><td><code id="filtEMG_+3A_hpo">HPo</code></td>
<td>
<p>High-pass filter order</p>
</td></tr>
<tr><td><code id="filtEMG_+3A_lpf">LPf</code></td>
<td>
<p>Low-pass filter cut-off frequency, use 0 to exclude Low-pass filtering</p>
</td></tr>
<tr><td><code id="filtEMG_+3A_lpo">LPo</code></td>
<td>
<p>Low-pass filter order</p>
</td></tr>
<tr><td><code id="filtEMG_+3A_min_sub">min_sub</code></td>
<td>
<p>Logical: should the minimum be subtracted?</p>
</td></tr>
<tr><td><code id="filtEMG_+3A_ampl_norm">ampl_norm</code></td>
<td>
<p>Logical: should amplitude be normalised?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Lists in the correct format can be created with the function <code>rawdata()</code>.
The first column of each <code>emg</code> element must be time in the same units as those
used for <code>cycles</code> (e.g., [s] or [ms]).
</p>


<h3>Value</h3>

<p>Object of class <code>EMG</code> with elements:<br />
</p>

<ul>
<li> <p><code>cycles</code> data frame containing cycle timings, with as many columns as many cycle subdivisions are wanted<br />
</p>
</li>
<li> <p><code>emg</code> data frame containing filtered EMG data in columns, first column is time
</p>
</li></ul>



<h3>References</h3>

<p>Santuz, A., Ekizos, A., Janshen, L., Baltzopoulos, V. &amp; Arampatzis, A.
On the Methodological Implications of Extracting Muscle Synergies from Human Locomotion.
Int. J. Neural Syst. 27, 1750007 (2017).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load some data
data("RAW_DATA")
# Filter raw EMG
filtered_EMG &lt;- lapply(
  RAW_DATA,
  function(x) {
    filtEMG(x,
      HPf = 50,
      HPo = 4,
      LPf = 20,
      LPo = 4
    )
  }
)
</code></pre>

<hr>
<h2 id='FWHM'>Full width at half maximum</h2><span id='topic+FWHM'></span>

<h3>Description</h3>

<p>Full width at half maximum
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FWHM(x, sub_minimum = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FWHM_+3A_x">x</code></td>
<td>
<p>A time series (numeric)</p>
</td></tr>
<tr><td><code id="FWHM_+3A_sub_minimum">sub_minimum</code></td>
<td>
<p>Logical; should the minimum be subtracted before amplitude normalisation?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The full width at half maximum of the time series.
</p>


<h3>References</h3>

<p>Martino, G. et al.
Locomotor patterns in cerebellar ataxia.
J. Neurophysiol. 112, 2810–2821 (2014).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Number of users connected to the Internet through a server every minute
ts &lt;- datasets::WWWusage

# Calculate FWHM
ts_FWHM &lt;- FWHM(ts)

# Half maximum (for the plots)
hm &lt;- min(ts) + (max(ts) - min(ts)) / 2
hm_plot &lt;- ts
hm_plot[which(hm_plot &gt; hm)] &lt;- hm
hm_plot[which(hm_plot &lt; hm)] &lt;- NA

# Plots
plot(ts, ty = "l", xlab = "Time", ylab = "Number of users")
lines(hm_plot, lwd = 3, col = 2)
</code></pre>

<hr>
<h2 id='HFD'>Higuchi's fractal dimension</h2><span id='topic+HFD'></span>

<h3>Description</h3>

<p>Higuchi's fractal dimension
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HFD(P, k_max = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HFD_+3A_p">P</code></td>
<td>
<p>A time series (numeric)</p>
</td></tr>
<tr><td><code id="HFD_+3A_k_max">k_max</code></td>
<td>
<p>Maximum window length in points</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Higuchi’s fractal dimension is a measure of local complexity and it increases together
with the “roughness” of the time series at a single cycle level (thus the term “local”).
Higuchi’s fractal dimension values range from 1 to 2, with increasing values correlating to
increasingly complex data and Higuchi’s fractal dimension = 1.5 indicating random
Gaussian noise (Higuchi, 1988; Anmuth et al., 1994; Kesić &amp; Spasić, 2016)
For motor primitives, only the most linear part of the log-log plot should be used,
as reported in Santuz, Akay (2020).
</p>


<h3>Value</h3>

<p>A list with elements:<br />
</p>

<ul>
<li> <p><code>loglog</code> containing the log-log plot from which the HFD is calculated<br />
</p>
</li>
<li> <p><code>Higuchi</code> containing the Higuchi's fractal dimension of the time series.
</p>
</li></ul>



<h3>References</h3>

<p>Higuchi, T.
Approach to an irregular time series on the basis of the fractal theory.
Phys. D Nonlinear Phenom. 31, 277–283 (1988).<br />
</p>
<p>Anmuth C. J., Goldberg G. &amp; Mayer N. H.
Fractal dimension of electromyographic signals recorded with surface electrodes during
isometric contractions is linearly correlated with muscle activation.
Muscle Nerve 17, 953–954 (1994).<br />
</p>
<p>Kesić S. &amp; Spasić S. Z.
Application of Higuchi’s fractal dimension from basic to clinical neurophysiology: A review.
Comput Methods Programs Biomed 133, 55–70 (2016).<br />
</p>
<p>Santuz, A. &amp; Akay, T.
Fractal analysis of muscle activity patterns during locomotion: pitfalls and how to avoid them.
J. Neurophysiol. 124, 1083–1091 (2020).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Measurements of the annual flow of the river Nile at Aswan
flow &lt;- datasets::Nile

# Calculate HFD
fractal_dimension &lt;- HFD(flow)$Higuchi
message("Higuchi's fractal dimension: ", round(fractal_dimension, 3))

# Thirty-cycle locomotor primitive from Santuz &amp; Akay (2020)
data(primitive)
fractal_dimension &lt;- HFD(primitive$signal)$Higuchi
message("Higuchi's fractal dimension: ", round(fractal_dimension, 3))
</code></pre>

<hr>
<h2 id='Hurst'>Hurst exponent</h2><span id='topic+Hurst'></span>

<h3>Description</h3>

<p>Hurst exponent
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Hurst(P, min_win = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hurst_+3A_p">P</code></td>
<td>
<p>A time series (numeric)</p>
</td></tr>
<tr><td><code id="Hurst_+3A_min_win">min_win</code></td>
<td>
<p>Minimum window length in points</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>Hurst</code> calculates the Hurst exponent based on the R/S approach as in Hurst (1951).
The Hurst exponent is a measure of global complexity and it increases if the “accuracy” of
the time series decreases across several cycles (thus the term “global”).
The Hurst exponent can vary between 0 and 1. For 0.5 &lt; Hurst exponent &lt; 1, in the long-term high
values in the time series (the motor primitive in our case) will be probably followed by other high
values and a positive or negative trend is visible (Mandelbrot, 1983; Gneiting &amp; Schlather, 2004).
For 0 &lt; Hurst exponent &lt; 0.5, in the long term high values in the series will be probably followed
by low values, with a frequent switch between high and low values
(Mandelbrot, 1983; Gneiting &amp; Schlather, 2004). Hurst exponent = 0.5 corresponds to a completely
random series (Mandelbrot, 1983; Qian &amp; Rasheed, 2004). In other words, values of Hurst
exponent approaching 0.5 from both ends indicate more complex (or random) behaviour of the
time series (Hurst, 1951).
For motor primitives, the minimum window length should be bigger than the period
(i.e. the length of each cycle), as reported in Santuz, Akay (2020).
</p>


<h3>Value</h3>

<p>A list with elements:<br />
</p>

<ul>
<li> <p><code>loglog</code> containing the log-log plot from which the HFD is calculated<br />
</p>
</li>
<li> <p><code>Hurst</code> containing the Higuchi's fractal dimension of the time series.
</p>
</li></ul>



<h3>References</h3>

<p>Hurst, H. E.
Long-term storage capacity of reservoirs.
Trans. Am. Soc. Civ. Eng. 116, 770-808 (1951).<br />
</p>
<p>Mandelbrot B. B.
The Fractal Geometry of Nature.
W. H. Freeman and Co., New York (1983).<br />
</p>
<p>Gneiting T .&amp; Schlather M.
Stochastic Models That Separate Fractal Dimension and the Hurst Effect.
SIAM Rev 46, 269–282 (2004).<br />
</p>
<p>Qian B. &amp; Rasheed K.
Hurst exponent and financial market predictability.
In Proceedings of the Second IASTED International Conference on Financial Engineering and
Applications, pp. 203–209 (2004).<br />
</p>
<p>Santuz, A. &amp; Akay, T.
Fractal analysis of muscle activity patterns during locomotion: pitfalls and how to avoid them.
J. Neurophysiol. 124, 1083-1091 (2020).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Measurements of the annual flow of the river Nile at Aswan
flow &lt;- datasets::Nile

# Calculate Hurst exponent
H &lt;- Hurst(flow)$Hurst
message("Hurst exponent: ", round(H, 3))

# Thirty-cycle locomotor primitive from Santuz &amp; Akay (2020)
data(primitive)
H &lt;- Hurst(primitive$signal, min_win = max(primitive$time))$Hurst
message("Hurst exponent: ", round(H, 3))
</code></pre>

<hr>
<h2 id='normEMG'>To time-normalise filtered EMG</h2><span id='topic+normEMG'></span>

<h3>Description</h3>

<p>To time-normalise filtered EMG
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normEMG(x, trim = TRUE, cy_max = NA, cycle_div = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normEMG_+3A_x">x</code></td>
<td>
<p>Object of class <code>EMG</code> with elements <code>cycles</code> and <code>emg</code></p>
</td></tr>
<tr><td><code id="normEMG_+3A_trim">trim</code></td>
<td>
<p>Logical: should first and last cycle be trimmed to remove filtering effects?</p>
</td></tr>
<tr><td><code id="normEMG_+3A_cy_max">cy_max</code></td>
<td>
<p>Maximum number of cycles to be considered</p>
</td></tr>
<tr><td><code id="normEMG_+3A_cycle_div">cycle_div</code></td>
<td>
<p>A vector or one dimensional array with the number of points each cycle should be normalised to</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Lists in the correct format can be created with the function <code>rawdata()</code>.
The first column of each <code>emg</code> element must be time in the same units as those
used for <code>cycles</code> (e.g., [s] or [ms]).
</p>


<h3>Value</h3>

<p>Object of class <code>EMG</code> with elements:<br />
</p>

<ul>
<li> <p><code>cycles</code> data frame containing cycle timings, with as many columns as many cycle subdivisions are wanted<br />
</p>
</li>
<li> <p><code>emg</code> data frame containing filtered and time-normalised EMG data in columns, first column is time
</p>
</li></ul>



<h3>References</h3>

<p>Santuz, A., Ekizos, A., Janshen, L., Baltzopoulos, V. &amp; Arampatzis, A.
On the Methodological Implications of Extracting Muscle Synergies from Human Locomotion.
Int. J. Neural Syst. 27, 1750007 (2017).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load some data
data("RAW_DATA")
# Filter raw EMG
filtered_EMG &lt;- lapply(RAW_DATA, function(x) {
  filtEMG(x, HPf = 50, HPo = 4, LPf = 20, LPo = 4)
})
# Time-normalise filtered EMG, including three cycles and trimming first and last
filt_norm_EMG &lt;- lapply(filtered_EMG, function(x) {
  normEMG(
  x,
  cy_max = 3,
  cycle_div = c(100, 100))
})
</code></pre>

<hr>
<h2 id='plot_classified_syns'>Plot muscle synergies</h2><span id='topic+plot_classified_syns'></span>

<h3>Description</h3>

<p>Plot muscle synergies
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_classified_syns(
  x,
  dark_mode = FALSE,
  line_size = 0.9,
  dot_size = 0.1,
  line_col = "black",
  sd_col = "grey80",
  condition = NA,
  show_plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_classified_syns_+3A_x">x</code></td>
<td>
<p>List of objects of class <code>musclesyneRgies</code> (must be classified)</p>
</td></tr>
<tr><td><code id="plot_classified_syns_+3A_dark_mode">dark_mode</code></td>
<td>
<p>To enable dark mode</p>
</td></tr>
<tr><td><code id="plot_classified_syns_+3A_line_size">line_size</code></td>
<td>
<p>Line thickness</p>
</td></tr>
<tr><td><code id="plot_classified_syns_+3A_dot_size">dot_size</code></td>
<td>
<p>Dot size on motor modules</p>
</td></tr>
<tr><td><code id="plot_classified_syns_+3A_line_col">line_col</code></td>
<td>
<p>Line colour</p>
</td></tr>
<tr><td><code id="plot_classified_syns_+3A_sd_col">sd_col</code></td>
<td>
<p>Standard deviation ribbon colour</p>
</td></tr>
<tr><td><code id="plot_classified_syns_+3A_condition">condition</code></td>
<td>
<p>Character: the condition that is being analysed, for archiving purposes</p>
</td></tr>
<tr><td><code id="plot_classified_syns_+3A_show_plot">show_plot</code></td>
<td>
<p>Logical, to decide whether plots should be plotted in the active graphic device</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>show_plot</code> is TRUE (default) plots are also shown in the active graphic device.
Plots can then be saved with the preferred export method, such as <code>ggplot2::ggsave</code>.
</p>


<h3>Value</h3>

<p>Global plot containing the average classified muscle synergies and individual trials
(motor modules) or standard deviations (motor primitives)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load some data
data(SYNS)

# Classify synergies with k-means
SYNS_classified &lt;- classify_kmeans(SYNS)

# Save plot of classified synergies
pp &lt;- plot_classified_syns(SYNS_classified,
  dark_mode = TRUE,
  line_col = "tomato1",
  sd_col = "tomato4",
  condition = "TW",
  show_plot = FALSE
)
</code></pre>

<hr>
<h2 id='plot_classified_syns_UMAP'>Plot 2D UMAP of muscle synergies</h2><span id='topic+plot_classified_syns_UMAP'></span>

<h3>Description</h3>

<p>Plot 2D UMAP of muscle synergies
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_classified_syns_UMAP(x, condition, show_plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_classified_syns_UMAP_+3A_x">x</code></td>
<td>
<p>List of objects of class <code>musclesyneRgies</code> (must be classified)</p>
</td></tr>
<tr><td><code id="plot_classified_syns_UMAP_+3A_condition">condition</code></td>
<td>
<p>Character: the condition that is being analysed, for archiving purposes</p>
</td></tr>
<tr><td><code id="plot_classified_syns_UMAP_+3A_show_plot">show_plot</code></td>
<td>
<p>Logical, to decide whether plots should be plotted in the active graphic device</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>show_plot</code> is TRUE (default) plots are also shown in the active graphic device.
Plots can then be saved with the preferred export method, such as <code>ggplot2::ggsave</code>.
</p>


<h3>Value</h3>

<p>2D UMAP plot of classified synergies.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load some data
data(SYNS)

# Classify synergies with k-means
SYNS_classified &lt;- classify_kmeans(SYNS)

# Save plot
pp &lt;- plot_classified_syns_UMAP(SYNS_classified,
  condition = "TW",
  show_plot = FALSE
)
</code></pre>

<hr>
<h2 id='plot_meanEMG'>Plot EMG averaged across all cycles</h2><span id='topic+plot_meanEMG'></span>

<h3>Description</h3>

<p>Plot EMG averaged across all cycles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_meanEMG(
  x,
  trial,
  row_number = NA,
  col_number = 1,
  dark_mode = FALSE,
  line_size = 0.6,
  line_col = "black",
  show_plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_meanEMG_+3A_x">x</code></td>
<td>
<p>A data frame containing filtered EMG organised in columns</p>
</td></tr>
<tr><td><code id="plot_meanEMG_+3A_trial">trial</code></td>
<td>
<p>Character: the name of the considered trial, for archiving purposes</p>
</td></tr>
<tr><td><code id="plot_meanEMG_+3A_row_number">row_number</code></td>
<td>
<p>How many rows should the final plot be divided into?</p>
</td></tr>
<tr><td><code id="plot_meanEMG_+3A_col_number">col_number</code></td>
<td>
<p>How many columns should the final plot be divided into?</p>
</td></tr>
<tr><td><code id="plot_meanEMG_+3A_dark_mode">dark_mode</code></td>
<td>
<p>To enable dark mode</p>
</td></tr>
<tr><td><code id="plot_meanEMG_+3A_line_size">line_size</code></td>
<td>
<p>Line thickness</p>
</td></tr>
<tr><td><code id="plot_meanEMG_+3A_line_col">line_col</code></td>
<td>
<p>Line colour</p>
</td></tr>
<tr><td><code id="plot_meanEMG_+3A_show_plot">show_plot</code></td>
<td>
<p>Logical, to decide whether plots should be plotted in the active graphic device</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>show_plot</code> is TRUE (default) plots are also shown in the active graphic device.
Plots can then be saved with the preferred export method, such as <code>ggplot2::ggsave</code>.
</p>


<h3>Value</h3>

<p>Exports average filtered and normalised EMG.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load some data
data(FILT_EMG)

# Save a plot of the only present trial with the average filtered and time-normalised EMG
pp &lt;- plot_meanEMG(FILT_EMG[[1]],
  trial = names(FILT_EMG)[1],
  row_number = 4,
  col_number = 4,
  dark_mode = TRUE,
  line_col = "tomato3",
  show_plot = FALSE
)
</code></pre>

<hr>
<h2 id='plot_rawEMG'>Plot raw EMG</h2><span id='topic+plot_rawEMG'></span>

<h3>Description</h3>

<p>Plot raw EMG
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_rawEMG(
  x,
  trial,
  plot_time = 3,
  start = 1,
  row_number = NA,
  col_number = 1,
  dark_mode = FALSE,
  line_size = 0.3,
  line_col = "black",
  show_plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_rawEMG_+3A_x">x</code></td>
<td>
<p>Object of class <code>EMG</code> with elements <code>cycles</code> and <code>emg</code></p>
</td></tr>
<tr><td><code id="plot_rawEMG_+3A_trial">trial</code></td>
<td>
<p>Character: the name of the considered trial, for archiving purposes</p>
</td></tr>
<tr><td><code id="plot_rawEMG_+3A_plot_time">plot_time</code></td>
<td>
<p>How many seconds of data should be plotted?</p>
</td></tr>
<tr><td><code id="plot_rawEMG_+3A_start">start</code></td>
<td>
<p>At which data point should the plot start?</p>
</td></tr>
<tr><td><code id="plot_rawEMG_+3A_row_number">row_number</code></td>
<td>
<p>How many rows should the final plot be divided into?</p>
</td></tr>
<tr><td><code id="plot_rawEMG_+3A_col_number">col_number</code></td>
<td>
<p>How many columns should the final plot be divided into?</p>
</td></tr>
<tr><td><code id="plot_rawEMG_+3A_dark_mode">dark_mode</code></td>
<td>
<p>To enable dark mode</p>
</td></tr>
<tr><td><code id="plot_rawEMG_+3A_line_size">line_size</code></td>
<td>
<p>Line thickness</p>
</td></tr>
<tr><td><code id="plot_rawEMG_+3A_line_col">line_col</code></td>
<td>
<p>Line colour</p>
</td></tr>
<tr><td><code id="plot_rawEMG_+3A_show_plot">show_plot</code></td>
<td>
<p>Logical, to decide whether plots should be plotted in the active graphic device</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>show_plot</code> is TRUE (default) plots are also shown in the active graphic device.
Plots can then be saved with the preferred export method, such as <code>ggplot2::ggsave</code>.
</p>


<h3>Value</h3>

<p>Plots raw EMG trials of the specified length.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load some data
data(RAW_DATA)

# Save a plot with the first (and only) trial in RAW_DATA, first three seconds, in dark mode
plot_rawEMG(RAW_DATA[[1]],
  trial = names(RAW_DATA)[1],
  row_number = 4,
  col_number = 4,
  dark_mode = TRUE,
  line_col = "tomato3",
  show_plot = FALSE
)
</code></pre>

<hr>
<h2 id='plot_syn_trials'>Plot muscle synergies (individual trials)</h2><span id='topic+plot_syn_trials'></span>

<h3>Description</h3>

<p>Plot muscle synergies (individual trials)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_syn_trials(
  x,
  max_syns,
  trial,
  dark_mode = FALSE,
  line_size = 0.6,
  line_col = "black",
  sd_col = "grey80",
  show_plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_syn_trials_+3A_x">x</code></td>
<td>
<p>Object of class <code>musclesyneRgies</code></p>
</td></tr>
<tr><td><code id="plot_syn_trials_+3A_max_syns">max_syns</code></td>
<td>
<p>Number of synergies to be plotted or how many rows should the final panel
be divided into</p>
</td></tr>
<tr><td><code id="plot_syn_trials_+3A_trial">trial</code></td>
<td>
<p>Character: the name of the considered trial, for archiving purposes</p>
</td></tr>
<tr><td><code id="plot_syn_trials_+3A_dark_mode">dark_mode</code></td>
<td>
<p>To enable dark mode</p>
</td></tr>
<tr><td><code id="plot_syn_trials_+3A_line_size">line_size</code></td>
<td>
<p>Line thickness</p>
</td></tr>
<tr><td><code id="plot_syn_trials_+3A_line_col">line_col</code></td>
<td>
<p>Line colour</p>
</td></tr>
<tr><td><code id="plot_syn_trials_+3A_sd_col">sd_col</code></td>
<td>
<p>Standard deviation ribbon colour</p>
</td></tr>
<tr><td><code id="plot_syn_trials_+3A_show_plot">show_plot</code></td>
<td>
<p>Logical, to decide whether plots should be plotted in the active graphic device</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>show_plot</code> is TRUE (default) plots are also shown in the active graphic device.
Plots can then be saved with the preferred export method, such as <code>ggplot2::ggsave</code>.
</p>


<h3>Value</h3>

<p>Plots of the unclassified synergies, trial by trial.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load some data
data(SYNS)

# Find maximum number of synergies
max_syns &lt;- max(unlist(lapply(SYNS, function(x) x$syns)))

# Save a plot with the first (and only, in this case) trial in the list
pp &lt;- plot_syn_trials(SYNS[[1]],
  max_syns = max_syns,
  trial = names(SYNS)[1],
  dark_mode = TRUE,
  line_size = 0.8,
  line_col = "tomato1",
  sd_col = "tomato4",
  show_plot = FALSE
)
</code></pre>

<hr>
<h2 id='primitive'>Single motor primitive example (30 cycles)</h2><span id='topic+primitive'></span>

<h3>Description</h3>

<p>A data frame containing one motor primitive extracted from one wild type mouse
walking on a treadmill.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>primitive
</code></pre>


<h3>Format</h3>

<p>A data frame of two columns:
</p>

<dl>
<dt><code>time</code></dt><dd><p>Normalised time in points.</p>
</dd></dl>
<p><br />
</p>
<dl>
<dt><code>signal</code></dt><dd><p>Motor primitive</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://doi.org/10.1152/jn.00360.2020">doi:10.1152/jn.00360.2020</a>
</p>

<hr>
<h2 id='primitives'>All motor primitives of one synergy example (30 cycles)</h2><span id='topic+primitives'></span>

<h3>Description</h3>

<p>A demo and incomplete <code>musclesyneRgies</code> object containing time info and three motor primitives
extracted from one wild type mouse walking on a treadmill.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>primitives
</code></pre>


<h3>Format</h3>

<p>A data frame of four columns:
</p>

<dl>
<dt><code>time</code></dt><dd><p>Normalised time in points.</p>
</dd></dl>
<p><br />
</p>
<dl>
<dt><code>Syn1</code></dt><dd><p>Motor primitive of synergy 1</p>
</dd></dl>
<p><br />
</p>
<dl>
<dt><code>Syn2</code></dt><dd><p>Motor primitive of synergy 2</p>
</dd></dl>
<p><br />
</p>
<dl>
<dt><code>Syn3</code></dt><dd><p>Motor primitive of synergy 3</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://doi.org/10.1152/jn.00360.2020">doi:10.1152/jn.00360.2020</a>
</p>

<hr>
<h2 id='RAW_DATA'>Raw EMG example</h2><span id='topic+RAW_DATA'></span>

<h3>Description</h3>

<p>A list containing electromyographic (EMG) human data from the right-side
lower limb recorded during one walking trial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RAW_DATA
</code></pre>


<h3>Format</h3>

<p>A list containing one object of class <code>EMG</code>
with elements <code>cycles</code> and <code>emg</code>, both data frames.
</p>

<dl>
<dt><code>ID0012_TW_01</code></dt><dd><p>Object of class <code>EMG</code> containing the two following data frames:</p>
</dd>
<dt><code>cycles</code></dt><dd><p>Gait cycle-timings, in seconds.</p>
</dd>
<dt><code>emg</code></dt><dd><p>Raw EMG, first column is time in seconds, muscles named as:<br /><br />
ME=gluteus medius<br />
MA=gluteus maximus<br />
FL=tensor fasciae latae<br />
RF=rectus femoris<br />
VM=vastus medialis<br />
VL=vastus lateralis<br />
ST=semitendinosus<br />
BF=biceps femoris<br />
TA=tibialis anterior<br />
PL=peroneus longus<br />
GM=gastrocnemius medialis<br />
GL=gastrocnemius lateralis<br />
SO=soleus</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://doi.org/10.1016/j.isci.2019.100796">doi:10.1016/j.isci.2019.100796</a>
</p>

<hr>
<h2 id='rawdata'>Import RData or ASCII data into R</h2><span id='topic+rawdata'></span>

<h3>Description</h3>

<p>Import RData or ASCII data into R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rawdata(path_cycles = NA, path_emg = NA, header_cycles, header_emg = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rawdata_+3A_path_cycles">path_cycles</code></td>
<td>
<p>Optional, path where cycle timing files are located</p>
</td></tr>
<tr><td><code id="rawdata_+3A_path_emg">path_emg</code></td>
<td>
<p>Optional, path where raw EMG files are located</p>
</td></tr>
<tr><td><code id="rawdata_+3A_header_cycles">header_cycles</code></td>
<td>
<p>Logical, are the cycle files containing a named header (the header is optional)?</p>
</td></tr>
<tr><td><code id="rawdata_+3A_header_emg">header_emg</code></td>
<td>
<p>Logical, are the raw EMG files containing a named header (they should)?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Supported are R lists saved as RData files or tab- or comma-separated files
readable through <code>read.table()</code> or <code>read.csv()</code>.
The first column of each raw emg file must be time in the same units as those used for the
cycle timings (e.g., [s] or [ms]).
If reading from RData files, please call cycles <code>CYCLE_TIMES.RData</code> and raw EMG <code>RAW_EMG.RData</code>. Lists
must be saved with <code>save()</code>.
</p>


<h3>Value</h3>

<p>List of objects of class <code>EMG</code>, each with elements:<br />
</p>

<ul>
<li> <p><code>cycles</code> data frame containing cycle timings, with as many columns as many cycle subdivisions are wanted<br />
</p>
</li>
<li> <p><code>emg</code> data frame containing raw EMG data in columns, first column must be time in the same units as in the cycle timings
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Load built-in data set
data("RAW_DATA")

# Get current working directory
data_path &lt;- getwd()
data_path &lt;- paste0(data_path, .Platform$file.sep)

# Create two conveniently-named subfolders if they don't already exist
# (if they exist, please make sure they're empty!)
dir.create("cycles", showWarnings = FALSE)
dir.create("emg", showWarnings = FALSE)

# Export ASCII data from built-in data set to the new subfolders
write.table(RAW_DATA[[1]]$cycles,
  file = paste0(data_path, "cycles", .Platform$file.sep, names(RAW_DATA)[1], ".txt"),
  sep = "\t", row.names = FALSE, col.names = FALSE
)
write.table(RAW_DATA[[1]]$emg,
  file = paste0(data_path, "emg", .Platform$file.sep, names(RAW_DATA)[1], ".txt"),
  sep = "\t", row.names = FALSE
)

# Run the function to parse ASCII files into objects of class `EMG`
raw_data_from_files &lt;- rawdata(
  path_cycles = paste0(data_path, "/cycles/"),
  path_emg = paste0(data_path, "/emg/"),
  header_cycles = FALSE
)

# Check data in the new folders if needed before running the following (will delete!)

# Delete folders
unlink("cycles", recursive = TRUE)
unlink("emg", recursive = TRUE)
</code></pre>

<hr>
<h2 id='sMLE'>Short-term maximum Lyapunov exponents</h2><span id='topic+sMLE'></span>

<h3>Description</h3>

<p>Short-term maximum Lyapunov exponents
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sMLE(synergies, mean_period, future_pts, norm, pts, R2_threshold = 0.9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sMLE_+3A_synergies">synergies</code></td>
<td>
<p>A <code>musclesyneRgies</code> object</p>
</td></tr>
<tr><td><code id="sMLE_+3A_mean_period">mean_period</code></td>
<td>
<p>To locate the nearest neighbour of each point on the state space
trajectory</p>
</td></tr>
<tr><td><code id="sMLE_+3A_future_pts">future_pts</code></td>
<td>
<p>To limit the number of points &quot;in the future&quot; that are being searched</p>
</td></tr>
<tr><td><code id="sMLE_+3A_norm">norm</code></td>
<td>
<p>Type of normalisation (&quot;u&quot; for minimum subtraction and normalisation to the maximum,
&quot;z&quot; for subtracting the mean and then divide by the standard deviation)</p>
</td></tr>
<tr><td><code id="sMLE_+3A_pts">pts</code></td>
<td>
<p>Minimum number of points needed to linearly approximate the first part
of the divergence curve</p>
</td></tr>
<tr><td><code id="sMLE_+3A_r2_threshold">R2_threshold</code></td>
<td>
<p>Threshold for calculating the slope of the divergence curve</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mean period is intended to exclude temporally close points. In gait, values are usually
plus/minus half gait cycle. Future points usually correspond in gait to one to two gait cycles.
Please consider that a sufficient amount of cycles in order to compute meaningful sMLE.
For locomotor primitives, 30 gait cycles have been shown to be sensitive to perturbations
(Santuz et al. 2020). However, in the more classical and widespread use on kinematic data,
more are usually needed (Kang and Dingwell, 2006).
</p>


<h3>Value</h3>

<p>A list with elements:<br />
</p>

<ul>
<li> <p><code>divergences</code> containing the average logarithmic divergence curve<br />
</p>
</li>
<li> <p><code>sMLE</code> the short-term Maximum Lyapunov exponent<br />
</p>
</li>
<li> <p><code>R2</code> the goodness of fit of the most linear part of the divergence curve
</p>
</li></ul>



<h3>References</h3>

<p>Rosenstein, M.T., Collins, J.J., and De Luca, C.J. (1993).
A practical method for calculating largest Lyapunov exponents from small data sets.
Phys. D 65, 117–134.<br />
</p>
<p>Santuz A, Brüll L, Ekizos A, Schroll A, Eckardt N, Kibele A, et al.
Neuromotor Dynamics of Human Locomotion in Challenging Settings.
iScience. 2020;23: 100796.<br />
</p>
<p>Kang H.G., and Dingwell J.B. (2006).
Intra-session reliability of local dynamic stability of walking.
Gait Posture. 24(3) 386-390.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load some primitives
data("primitives")
# Calculate sMLE of motor primitives in the muscle synergy space
short_term_MLE &lt;- sMLE(primitives,
  mean_period = 80,
  future_pts = 200,
  norm = "z",
  pts = 30
)
</code></pre>

<hr>
<h2 id='subsetEMG'>Subset raw EMG</h2><span id='topic+subsetEMG'></span>

<h3>Description</h3>

<p>Subset raw EMG
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsetEMG(x, cy_max, cy_start = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subsetEMG_+3A_x">x</code></td>
<td>
<p>Objects of class <code>EMG</code> with elements <code>cycles</code> and <code>emg</code></p>
</td></tr>
<tr><td><code id="subsetEMG_+3A_cy_max">cy_max</code></td>
<td>
<p>Maximum number of cycles to be considered</p>
</td></tr>
<tr><td><code id="subsetEMG_+3A_cy_start">cy_start</code></td>
<td>
<p>From which cycle should the subset begin?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Lists in the correct format can be created with the function <code>rawdata()</code>.
The first column of each <code>emg</code> element must be time in the same units as those
used for <code>cycles</code> (e.g., [s] or [ms]). For locomotion, thirty cycles
are enough for proper synergy extraction (Oliveira et al. 2014).
</p>


<h3>Value</h3>

<p>Object of class <code>EMG</code> with elements:<br />
</p>

<ul>
<li> <p><code>cycles</code> data frame containing cycle timings, with as many columns as many cycle subdivisions are wanted<br />
</p>
</li>
<li> <p><code>emg</code> data frame containing raw EMG data in columns, first column is time
</p>
</li></ul>



<h3>References</h3>

<p>Oliveira, A. S. C., Gizzi, L., Farina, D. &amp; Kersting, U. G.
Motor modules of human locomotion:
influence of EMG averaging, concatenation, and number of step cycles.
Front. Hum. Neurosci. 8, 335 (2014).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load some data
data("RAW_DATA")
# Subset example raw data to the first 3 cycles
RAW_DATA_sub &lt;- lapply(
  RAW_DATA,
  function(x) {
    subsetEMG(x,
      cy_max = 3,
      cy_start = 1
    )
  }
)
</code></pre>

<hr>
<h2 id='SYNS'>Muscle synergies example</h2><span id='topic+SYNS'></span>

<h3>Description</h3>

<p>A list created by synsNMF containing muscle synergies extracted from
15 humans walking on a treadmill.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SYNS
</code></pre>


<h3>Format</h3>

<p>A list containing 15 objects of class <code>musclesyneRgies</code>, each of which represents
a walking trial from a different person.
</p>

<dl>
<dt><code>ID0012_TW_01</code><br />
<code>ID0001_TW_01</code><br />
<code>ID0002_TW_01</code><br />
<code>ID0003_TW_01</code><br />
<code>ID0004_TW_01</code><br />
<code>ID0005_TW_01</code><br />
<code>ID0006_TW_01</code><br />
<code>ID0007_TW_01</code><br />
<code>ID0008_TW_01</code><br />
<code>ID0009_TW_01</code><br />
<code>ID0010_TW_01</code><br />
<code>ID0011_TW_01</code><br />
<code>ID0012_TW_01</code><br />
<code>ID0013_TW_01</code><br />
<code>ID0014_TW_01</code><br />
<code>ID0015_TW_01</code><br /></dt><dd><p>Objects of class <code>musclesyneRgies</code> containing the following items:</p>
</dd>
<dt><code>syns</code></dt><dd><p>Factorisation rank or minimum number of synergies.</p>
</dd>
<dt><code>M</code></dt><dd><p>Motor modules (time-invariant coefficients)</p>
</dd>
<dt><code>P</code></dt><dd><p>Motor primitives (time-dependent coefficients)</p>
</dd>
<dt><code>V</code></dt><dd><p>Original data, muscles named as:<br /><br />
ME=gluteus medius<br />
MA=gluteus maximus<br />
FL=tensor fasciae latae<br />
RF=rectus femoris<br />
VM=vastus medialis<br />
VL=vastus lateralis<br />
ST=semitendinosus<br />
BF=biceps femoris<br />
TA=tibialis anterior<br />
PL=peroneus longus<br />
GM=gastrocnemius medialis<br />
GL=gastrocnemius lateralis<br />
SO=soleus</p>
</dd>
<dt><code>Vr</code></dt><dd><p>Reconstructed data, muscles named as in <code>Vr</code></p>
</dd>
<dt><code>iterations</code></dt><dd><p>Number of iterations to convergence</p>
</dd>
<dt><code>R2</code></dt><dd><p>Quality of reconstruction (coefficient of determination)</p>
</dd>
<dt><code>classification</code></dt><dd><p>Classification type (e.g., <code>none</code>, <code>k-means</code>, <code>NMF</code>, etc.)</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://doi.org/10.1016/j.isci.2019.100796">doi:10.1016/j.isci.2019.100796</a>
</p>

<hr>
<h2 id='synsNMF'>Non-negative matrix factorisation</h2><span id='topic+synsNMF'></span>

<h3>Description</h3>

<p>Non-negative matrix factorisation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>synsNMF(
  V,
  R2_target = 0.01,
  runs = 5,
  max_iter = 1000,
  last_iter = 20,
  MSE_min = 1e-04,
  fixed_syns = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="synsNMF_+3A_v">V</code></td>
<td>
<p>EMG data frame to be reconstructed, usually filtered and time-normalised</p>
</td></tr>
<tr><td><code id="synsNMF_+3A_r2_target">R2_target</code></td>
<td>
<p>Threshold to stop iterations for a certain factorisation rank</p>
</td></tr>
<tr><td><code id="synsNMF_+3A_runs">runs</code></td>
<td>
<p>Number of repetitions for each rank to avoid local minima</p>
</td></tr>
<tr><td><code id="synsNMF_+3A_max_iter">max_iter</code></td>
<td>
<p>Maximum number of iterations allowed for each rank</p>
</td></tr>
<tr><td><code id="synsNMF_+3A_last_iter">last_iter</code></td>
<td>
<p>How many of the last iterations should be checked before stopping?</p>
</td></tr>
<tr><td><code id="synsNMF_+3A_mse_min">MSE_min</code></td>
<td>
<p>Threshold on the mean squared error to choose the factorisation rank or
minimum number of synergies</p>
</td></tr>
<tr><td><code id="synsNMF_+3A_fixed_syns">fixed_syns</code></td>
<td>
<p>To impose the factorisation rank or number of synergies</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first column of <code>V</code> must always contain time information.
</p>


<h3>Value</h3>

<p>Object of class <code>musclesyneRgies</code> with elements:<br />
</p>

<ul>
<li> <p><code>syns</code> factorisation rank or minimum number of synergies<br />
</p>
</li>
<li> <p><code>M</code> motor modules (time-invariant coefficients)<br />
</p>
</li>
<li> <p><code>P</code> motor primitives (time-dependent coefficients)<br />
</p>
</li>
<li> <p><code>V</code> original data<br />
</p>
</li>
<li> <p><code>Vr</code> reconstructed data<br />
</p>
</li>
<li> <p><code>iterations</code> number of iterations to convergence<br />
</p>
</li>
<li> <p><code>R2</code> quality of reconstruction (coefficient of determination)
</p>
</li>
<li> <p><code>rank_type</code> was the rank <code>fixed</code> or <code>variable</code>?<br />
</p>
</li>
<li> <p><code>classification</code> classification type (e.g., <code>none</code>, <code>k-means</code>, <code>NMF</code>, etc.)
</p>
</li></ul>



<h3>References</h3>

<p>Lee, D. D. &amp; Seung, H. S.
Learning the parts of objects by non-negative matrix factorization.
Nature 401, 788-91 (1999).<br />
</p>
<p>Santuz, A., Ekizos, A., Janshen, L., Baltzopoulos, V. &amp; Arampatzis, A.
On the Methodological Implications of Extracting Muscle Synergies from Human Locomotion.
Int. J. Neural Syst. 27, 1750007 (2017).<br />
</p>
<p>Févotte, C., Idier, J.
Algorithms for Nonnegative Matrix Factorization with the Beta-Divergence
Neural Computation 23, 9 (2011).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Note that for bigger data sets one might want to run computation in parallel
# Load some data
data(FILT_EMG)
# Extract synergies (careful, rank is imposed here!)
SYNS &lt;- lapply(FILT_EMG, synsNMF, fixed_syns = 4)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
