<!DOCTYPE html><html lang="en"><head><title>Help for package SpatialDDLS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SpatialDDLS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#SpatialDDLS-package'><p>SpatialDDLS: Deconvolution of Spatial Transcriptomics Data Based on Neural Networks</p></a></li>
<li><a href='#barErrorPlot'><p>Generate bar error plots</p></a></li>
<li><a href='#barPlotCellTypes'><p>Bar plot of deconvoluted cell type proportions</p></a></li>
<li><a href='#blandAltmanLehPlot'><p>Generate Bland-Altman agreement plots between predicted and expected cell</p>
type proportions of test data</a></li>
<li><a href='#calculateEvalMetrics'><p>Calculate evaluation metrics on test mixed transcriptional profiles</p></a></li>
<li><a href='#cell.names'><p>Get and set <code>cell.names</code> slot in a</p>
<code>PropCellTypes</code> object</a></li>
<li><a href='#cell.types'><p>Get and set <code>cell.types</code> slot in a</p>
<code>DeconvDLModel</code> object</a></li>
<li><a href='#corrExpPredPlot'><p>Generate correlation plots between predicted and expected cell type</p>
proportions of test data</a></li>
<li><a href='#createSpatialDDLSobject'><p>Create a <code>SpatialDDLS</code> object</p></a></li>
<li><a href='#deconv.spots'><p>Get and set <code>deconv.spots</code> slot in a</p>
<code>SpatialExperiment</code> object</a></li>
<li><a href='#DeconvDLModel-class'><p>The DeconvDLModel Class</p></a></li>
<li><a href='#deconvSpatialDDLS'><p>Deconvolute spatial transcriptomics data using trained model</p></a></li>
<li><a href='#distErrorPlot'><p>Generate box or violin plots showing error distribution</p></a></li>
<li><a href='#estimateZinbwaveParams'><p>Estimate parameters of the ZINB-WaVE model to simulate new single-cell</p>
RNA-Seq expression profiles</a></li>
<li><a href='#features'><p>Get and set <code>features</code> slot in a</p>
<code>DeconvDLModel</code> object</a></li>
<li><a href='#genMixedCellProp'><p>Generate training and test cell type composition matrices</p></a></li>
<li><a href='#getProbMatrix'><p>Getter function for the cell composition matrix</p></a></li>
<li><a href='#installTFpython'><p>Install Python dependencies for SpatialDDLS</p></a></li>
<li><a href='#interGradientsDL'><p>Calculate gradients of predicted cell types/loss function with respect to</p>
input features for interpreting trained deconvolution models</a></li>
<li><a href='#loadSTProfiles'><p>Loads spatial transcriptomics data into a SpatialDDLS object</p></a></li>
<li><a href='#loadTrainedModelFromH5'><p>Load from an HDF5 file a trained deep neural network model into a</p>
<code>SpatialDDLS</code> object</a></li>
<li><a href='#method'><p>Get and set <code>method</code> slot in a <code>PropCellTypes</code></p>
object</a></li>
<li><a href='#mixed.profiles'><p>Get and set <code>mixed.profiles</code> slot in a</p>
<code>SpatialExperiment</code> object</a></li>
<li><a href='#model'><p>Get and set <code>model</code> slot in a <code>DeconvDLModel</code></p>
object</a></li>
<li><a href='#plotDistances'><p>Plot distances between intrinsic and extrinsic profiles</p></a></li>
<li><a href='#plotHeatmapGradsAgg'><p>Plot a heatmap of gradients of classes / loss function wtih respect to the</p>
input</a></li>
<li><a href='#plots'><p>Get and set <code>plots</code> slot in a <code>PropCellTypes</code></p>
object</a></li>
<li><a href='#plotSpatialClustering'><p>Plot results of clustering based on predicted cell proportions</p></a></li>
<li><a href='#plotSpatialGeneExpr'><p>Plot normalized gene expression data (logCPM) in spatial coordinates</p></a></li>
<li><a href='#plotSpatialProp'><p>Plot predicted proportions for a specific cell type using spatial coordinates</p>
of spots</a></li>
<li><a href='#plotSpatialPropAll'><p>Plot predicted proportions for all cell types using spatial coordinates of</p>
spots</a></li>
<li><a href='#plotTrainingHistory'><p>Plot training history of a trained SpatialDDLS deep neural network model</p></a></li>
<li><a href='#preparingToSave'><p>Prepare <code>SpatialDDLS</code> object to be saved as an RDA file</p></a></li>
<li><a href='#prob.cell.types'><p>Get and set <code>prob.cell.types</code> slot in a</p>
<code>SpatialExperiment</code> object</a></li>
<li><a href='#prob.matrix'><p>Get and set <code>prob.matrix</code> slot in a</p>
<code>PropCellTypes</code> object</a></li>
<li><a href='#project'><p>Get and set <code>project</code> slot in a</p>
<code>SpatialExperiment</code> object</a></li>
<li><a href='#PropCellTypes-class'><p>The PropCellTypes Class</p></a></li>
<li><a href='#saveRDS'><p>Save <code>SpatialExperiment</code> objects as RDS files</p></a></li>
<li><a href='#saveTrainedModelAsH5'><p>Save a trained <code>SpatialDDLS</code> deep neural network model to</p>
disk as an HDF5 file</a></li>
<li><a href='#set'><p>Get and set <code>set</code> slot in a <code>PropCellTypes</code></p>
object</a></li>
<li><a href='#set.list'><p>Get and set <code>set.list</code> slot in a</p>
<code>PropCellTypes</code> object</a></li>
<li><a href='#showProbPlot'><p>Show distribution plots of the cell proportions generated by</p>
<code>genMixedCellProp</code></a></li>
<li><a href='#simMixedProfiles'><p>Simulate training and test mixed spot profiles</p></a></li>
<li><a href='#simSCProfiles'><p>Simulate new single-cell RNA-Seq expression profiles using the ZINB-WaVE</p>
model parameters</a></li>
<li><a href='#single.cell.real'><p>Get and set <code>single.cell.real</code> slot in a</p>
<code>SpatialExperiment</code> object</a></li>
<li><a href='#single.cell.simul'><p>Get and set <code>single.cell.simul</code> slot in a</p>
<code>SpatialExperiment</code> object</a></li>
<li><a href='#spatial.experiments'><p>Get and set <code>spatial.experiments</code> slot in a</p>
<code>SpatialExperiment</code> object</a></li>
<li><a href='#SpatialDDLS-class'><p>The SpatialDDLS Class</p></a></li>
<li><a href='#SpatialDDLS-Rpackage'><p>SpatialDDLS: an R package to deconvolute spatial transcriptomics data using</p>
deep neural networks</a></li>
<li><a href='#spatialPropClustering'><p>Cluster spatial data based on predicted cell proportions</p></a></li>
<li><a href='#test.deconv.metrics'><p>Get and set <code>test.deconv.metrics</code> slot in a</p>
<code>DeconvDLModel</code> object</a></li>
<li><a href='#test.metrics'><p>Get and set <code>test.metrics</code> slot in a</p>
<code>DeconvDLModel</code> object</a></li>
<li><a href='#test.pred'><p>Get and set <code>test.pred</code> slot in a</p>
<code>DeconvDLModel</code> object</a></li>
<li><a href='#topGradientsCellType'><p>Get top genes with largest/smallest gradients per cell type</p></a></li>
<li><a href='#trainDeconvModel'><p>Train deconvolution model for spatial transcriptomics data</p></a></li>
<li><a href='#trained.model'><p>Get and set <code>trained.model</code> slot in a</p>
<code>SpatialExperiment</code> object</a></li>
<li><a href='#training.history'><p>Get and set <code>training.history</code> slot in a</p>
<code>DeconvDLModel</code> object</a></li>
<li><a href='#zinb.params'><p>Get and set <code>zinb.params</code> slot in a</p>
<code>SpatialExperiment</code> object</a></li>
<li><a href='#ZinbParametersModel-class'><p>The Class ZinbParametersModel</p></a></li>
<li><a href='#zinbwave.model'><p>Get and set <code>zinbwave.model</code> slot in a</p>
<code>ZinbParametersModel</code> object</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Deconvolution of Spatial Transcriptomics Data Based on Neural
Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.3</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Diego Mañanes &lt;dmananesc@cnic.es&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Deconvolution of spatial transcriptomics data based on neural networks and single-cell RNA-seq data. SpatialDDLS implements a workflow to create neural network models able to make accurate estimates of cell composition of spots from spatial transcriptomics data using deep learning and the meaningful information provided by single-cell RNA-seq data. See Torroja and Sanchez-Cabo (2019) &lt;<a href="https://doi.org/10.3389%2Ffgene.2019.00978">doi:10.3389/fgene.2019.00978</a>&gt; and Mañanes et al. (2024) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtae072">doi:10.1093/bioinformatics/btae072</a>&gt; to get an overview of the method and see some examples of its performance. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://diegommcc.github.io/SpatialDDLS/">https://diegommcc.github.io/SpatialDDLS/</a>,
<a href="https://github.com/diegommcc/SpatialDDLS">https://github.com/diegommcc/SpatialDDLS</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/diegommcc/SpatialDDLS/issues">https://github.com/diegommcc/SpatialDDLS/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>rlang, grr, Matrix, methods, SpatialExperiment,
SingleCellExperiment, SummarizedExperiment, zinbwave, stats,
pbapply, S4Vectors, dplyr, reshape2, gtools, reticulate, keras,
tensorflow, FNN, ggplot2, ggpubr, scran, scuttle</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, BiocParallel, rhdf5, DelayedArray,
DelayedMatrixStats, HDF5Array, testthat, ComplexHeatmap, grid,
bluster, lsa, irlba</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>Python (&gt;= 2.7.0), TensorFlow
(https://www.tensorflow.org/)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Collate:</td>
<td>'AllClasses.R' 'AllGenerics.R' 'SpatialDDLS.R' 'dnnModel.R'
'evalMetrics.R' 'interGradientsDL.R' 'loadData.R'
'plotSpatialCoor.R' 'simMixedSpots.R' 'simSingleCell.R'
'spatialClustering.R' 'utils.R'</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-31 08:55:20 UTC; dmananes</td>
</tr>
<tr>
<td>Author:</td>
<td>Diego Mañanes <a href="https://orcid.org/0000-0001-7247-6794"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Carlos Torroja <a href="https://orcid.org/0000-0001-8914-3400"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Fatima Sanchez-Cabo
    <a href="https://orcid.org/0000-0003-1881-1664"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-31 09:40:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='SpatialDDLS-package'>SpatialDDLS: Deconvolution of Spatial Transcriptomics Data Based on Neural Networks</h2><span id='topic+SpatialDDLS-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Deconvolution of spatial transcriptomics data based on neural networks and single-cell RNA-seq data. SpatialDDLS implements a workflow to create neural network models able to make accurate estimates of cell composition of spots from spatial transcriptomics data using deep learning and the meaningful information provided by single-cell RNA-seq data. See Torroja and Sanchez-Cabo (2019) <a href="https://doi.org/10.3389/fgene.2019.00978">doi:10.3389/fgene.2019.00978</a> and Mañanes et al. (2024) <a href="https://doi.org/10.1093/bioinformatics/btae072">doi:10.1093/bioinformatics/btae072</a> to get an overview of the method and see some examples of its performance.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Diego Mañanes <a href="mailto:dmananesc@cnic.es">dmananesc@cnic.es</a> (<a href="https://orcid.org/0000-0001-7247-6794">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Carlos Torroja <a href="mailto:ctorroja@cnic.es">ctorroja@cnic.es</a> (<a href="https://orcid.org/0000-0001-8914-3400">ORCID</a>)
</p>
</li>
<li><p> Fatima Sanchez-Cabo <a href="mailto:fscabo@cnic.es">fscabo@cnic.es</a> (<a href="https://orcid.org/0000-0003-1881-1664">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://diegommcc.github.io/SpatialDDLS/">https://diegommcc.github.io/SpatialDDLS/</a>
</p>
</li>
<li> <p><a href="https://github.com/diegommcc/SpatialDDLS">https://github.com/diegommcc/SpatialDDLS</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/diegommcc/SpatialDDLS/issues">https://github.com/diegommcc/SpatialDDLS/issues</a>
</p>
</li></ul>


<hr>
<h2 id='barErrorPlot'>Generate bar error plots</h2><span id='topic+barErrorPlot'></span>

<h3>Description</h3>

<p>Generate bar error plots by cell type (<code>CellType</code>) or by number of
different cell types (<code>nCellTypes</code>) on test mixed transcriptional
profiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>barErrorPlot(
  object,
  error = "MSE",
  by = "CellType",
  dispersion = "se",
  filter.sc = TRUE,
  title = NULL,
  angle = NULL,
  theme = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="barErrorPlot_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object with
<code>trained.model</code> slot containing metrics in the
<code>test.deconv.metrics</code> slot of a <code><a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code>
object.</p>
</td></tr>
<tr><td><code id="barErrorPlot_+3A_error">error</code></td>
<td>
<p><code>'MAE'</code> or <code>'MSE'</code>.</p>
</td></tr>
<tr><td><code id="barErrorPlot_+3A_by">by</code></td>
<td>
<p>Variable used to show errors. Available options are:
<code>'nCellTypes'</code>, <code>'CellType'</code>.</p>
</td></tr>
<tr><td><code id="barErrorPlot_+3A_dispersion">dispersion</code></td>
<td>
<p>Standard error (<code>'se'</code>) or standard deviation
(<code>'sd'</code>). The former by default.</p>
</td></tr>
<tr><td><code id="barErrorPlot_+3A_filter.sc">filter.sc</code></td>
<td>
<p>Boolean indicating whether single-cell profiles are filtered
out and only correlation of results associated with mixed transcriptional
profiles are shown (<code>TRUE</code> by default).</p>
</td></tr>
<tr><td><code id="barErrorPlot_+3A_title">title</code></td>
<td>
<p>Title of the plot.</p>
</td></tr>
<tr><td><code id="barErrorPlot_+3A_angle">angle</code></td>
<td>
<p>Angle of ticks.</p>
</td></tr>
<tr><td><code id="barErrorPlot_+3A_theme">theme</code></td>
<td>
<p><span class="pkg">ggplot2</span> theme.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calculateEvalMetrics">calculateEvalMetrics</a></code> <code><a href="#topic+corrExpPredPlot">corrExpPredPlot</a></code>
<code><a href="#topic+distErrorPlot">distErrorPlot</a></code> <code><a href="#topic+blandAltmanLehPlot">blandAltmanLehPlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
sce &lt;- SingleCellExperiment::SingleCellExperiment(
  assays = list(
    counts = matrix(
      rpois(30, lambda = 5), nrow = 15, ncol = 20,
      dimnames = list(paste0("Gene", seq(15)), paste0("RHC", seq(20)))
    )
  ),
  colData = data.frame(
    Cell_ID = paste0("RHC", seq(20)),
    Cell_Type = sample(x = paste0("CellType", seq(6)), size = 20,
                       replace = TRUE)
  ),
  rowData = data.frame(
    Gene_ID = paste0("Gene", seq(15))
  )
)
SDDLS &lt;- createSpatialDDLSobject(
  sc.data = sce,
  sc.cell.ID.column = "Cell_ID",
  sc.gene.ID.column = "Gene_ID",
  sc.filt.genes.cluster = FALSE
)
SDDLS &lt;- genMixedCellProp(
  object = SDDLS,
  cell.ID.column = "Cell_ID",
  cell.type.column = "Cell_Type",
  num.sim.spots = 100,
  train.freq.cells = 2/3,
  train.freq.spots = 2/3,
  verbose = TRUE
)
SDDLS &lt;- simMixedProfiles(SDDLS)
# training of DDLS model
SDDLS &lt;- trainDeconvModel(
  object = SDDLS,
  batch.size = 10,
  num.epochs = 5
)
# evaluation using test data
SDDLS &lt;- calculateEvalMetrics(object = SDDLS)
# bar error plots
barErrorPlot(
  object = SDDLS,
  error = "MSE",
  by = "CellType"
)
barErrorPlot(
  object = SDDLS,
  error = "MAE",
  by = "nCellTypes"
)


</code></pre>

<hr>
<h2 id='barPlotCellTypes'>Bar plot of deconvoluted cell type proportions</h2><span id='topic+barPlotCellTypes'></span>

<h3>Description</h3>

<p>Bar plot of deconvoluted cell type proportions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>barPlotCellTypes(
  data,
  colors = NULL,
  set = NULL,
  prediction = "Regularized",
  color.line = NA,
  x.label = "Spots",
  rm.x.text = FALSE,
  title = "Results of deconvolution",
  legend.title = "Cell types",
  angle = 90,
  theme = NULL,
  index.st = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="barPlotCellTypes_+3A_data">data</code></td>
<td>
<p><code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object with the
<code>deconv.spots</code> slot containing predicted cell type proportions.</p>
</td></tr>
<tr><td><code id="barPlotCellTypes_+3A_colors">colors</code></td>
<td>
<p>Vector of colors to be used.</p>
</td></tr>
<tr><td><code id="barPlotCellTypes_+3A_set">set</code></td>
<td>
<p>Type of simplification performed during deconvolution. It can
be <code>simpli.set</code> or <code>simpli.maj</code> (<code>NULL</code> by default).</p>
</td></tr>
<tr><td><code id="barPlotCellTypes_+3A_prediction">prediction</code></td>
<td>
<p>Set of predicted cell proportions to be plotted. It can be
<code>"Regularized"</code>, <code>"Intrinsic"</code> or <code>"Extrinsic"</code>.</p>
</td></tr>
<tr><td><code id="barPlotCellTypes_+3A_color.line">color.line</code></td>
<td>
<p>Color of the border bars.</p>
</td></tr>
<tr><td><code id="barPlotCellTypes_+3A_x.label">x.label</code></td>
<td>
<p>Label of x-axis.</p>
</td></tr>
<tr><td><code id="barPlotCellTypes_+3A_rm.x.text">rm.x.text</code></td>
<td>
<p>Logical value indicating whether to remove x-axis ticks
(name of samples).</p>
</td></tr>
<tr><td><code id="barPlotCellTypes_+3A_title">title</code></td>
<td>
<p>Title of the plot.</p>
</td></tr>
<tr><td><code id="barPlotCellTypes_+3A_legend.title">legend.title</code></td>
<td>
<p>Title of the legend plot.</p>
</td></tr>
<tr><td><code id="barPlotCellTypes_+3A_angle">angle</code></td>
<td>
<p>Angle of text ticks.</p>
</td></tr>
<tr><td><code id="barPlotCellTypes_+3A_theme">theme</code></td>
<td>
<p><span class="pkg">ggplot2</span> theme.</p>
</td></tr>
<tr><td><code id="barPlotCellTypes_+3A_index.st">index.st</code></td>
<td>
<p>Name or index of the element wanted to be shown in the
<code>deconv.spots</code> slot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object with the provided cell proportions represented as a
bar plot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+deconvSpatialDDLS">deconvSpatialDDLS</a></code>
</p>

<hr>
<h2 id='blandAltmanLehPlot'>Generate Bland-Altman agreement plots between predicted and expected cell
type proportions of test data</h2><span id='topic+blandAltmanLehPlot'></span>

<h3>Description</h3>

<p>Generate Bland-Altman agreement plots between predicted and expected cell
type proportions from test data. The Bland-Altman agreement plots can be
shown all mixed or split by either cell type (<code>CellType</code>) or the number
of cell types present in spots (<code>nCellTypes</code>). See the <code>facet.by</code>
argument and examples for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blandAltmanLehPlot(
  object,
  colors,
  color.by = "CellType",
  facet.by = NULL,
  log.2 = FALSE,
  filter.sc = TRUE,
  density = TRUE,
  color.density = "darkblue",
  size.point = 0.05,
  alpha.point = 1,
  ncol = NULL,
  nrow = NULL,
  title = NULL,
  theme = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blandAltmanLehPlot_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object with
<code>trained.model</code> slot containing metrics in the
<code>test.deconv.metrics</code> slot of a <code><a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code>
object.</p>
</td></tr>
<tr><td><code id="blandAltmanLehPlot_+3A_colors">colors</code></td>
<td>
<p>Vector of colors to be used.</p>
</td></tr>
<tr><td><code id="blandAltmanLehPlot_+3A_color.by">color.by</code></td>
<td>
<p>Variable used to color data. Options are <code>nCellTypes</code>
and <code>CellType</code>.</p>
</td></tr>
<tr><td><code id="blandAltmanLehPlot_+3A_facet.by">facet.by</code></td>
<td>
<p>Variable used to show the data in different panels. If
<code>NULL</code>, the plot is not split into different panels. Options are
<code>nCellTypes</code> (by number of different cell types) and <code>CellType</code>
(by cell type).</p>
</td></tr>
<tr><td><code id="blandAltmanLehPlot_+3A_log.2">log.2</code></td>
<td>
<p>Whether to show the Bland-Altman agreement plot in log2 space
(<code>FALSE</code> by default).</p>
</td></tr>
<tr><td><code id="blandAltmanLehPlot_+3A_filter.sc">filter.sc</code></td>
<td>
<p>Boolean indicating whether single-cell profiles are filtered
out and only correlations of results associated with mixed spot profiles
are shown (<code>TRUE</code> by default).</p>
</td></tr>
<tr><td><code id="blandAltmanLehPlot_+3A_density">density</code></td>
<td>
<p>Boolean indicating whether density lines should be shown
(<code>TRUE</code> by default).</p>
</td></tr>
<tr><td><code id="blandAltmanLehPlot_+3A_color.density">color.density</code></td>
<td>
<p>Color of density lines if the <code>density</code> argument is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="blandAltmanLehPlot_+3A_size.point">size.point</code></td>
<td>
<p>Size of the points (0.1 by default).</p>
</td></tr>
<tr><td><code id="blandAltmanLehPlot_+3A_alpha.point">alpha.point</code></td>
<td>
<p>Alpha of the points (0.1 by default).</p>
</td></tr>
<tr><td><code id="blandAltmanLehPlot_+3A_ncol">ncol</code></td>
<td>
<p>Number of columns if <code>facet.by</code> is used.</p>
</td></tr>
<tr><td><code id="blandAltmanLehPlot_+3A_nrow">nrow</code></td>
<td>
<p>Number of rows if <code>facet.by</code> is used.</p>
</td></tr>
<tr><td><code id="blandAltmanLehPlot_+3A_title">title</code></td>
<td>
<p>Title of the plot.</p>
</td></tr>
<tr><td><code id="blandAltmanLehPlot_+3A_theme">theme</code></td>
<td>
<p><span class="pkg">ggplot2</span> theme.</p>
</td></tr>
<tr><td><code id="blandAltmanLehPlot_+3A_...">...</code></td>
<td>
<p>Additional argument for the <code>facet_wrap</code> function of
<span class="pkg">ggplot2</span> if <code>facet.by</code> is not <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calculateEvalMetrics">calculateEvalMetrics</a></code> <code><a href="#topic+corrExpPredPlot">corrExpPredPlot</a></code>
<code><a href="#topic+distErrorPlot">distErrorPlot</a></code> <code><a href="#topic+barErrorPlot">barErrorPlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
sce &lt;- SingleCellExperiment::SingleCellExperiment(
  assays = list(
    counts = matrix(
      rpois(30, lambda = 5), nrow = 15, ncol = 20,
      dimnames = list(paste0("Gene", seq(15)), paste0("RHC", seq(20)))
    )
  ),
  colData = data.frame(
    Cell_ID = paste0("RHC", seq(20)),
    Cell_Type = sample(x = paste0("CellType", seq(6)), size = 20,
                       replace = TRUE)
  ),
  rowData = data.frame(
    Gene_ID = paste0("Gene", seq(15))
  )
)
SDDLS &lt;- createSpatialDDLSobject(
  sc.data = sce,
  sc.cell.ID.column = "Cell_ID",
  sc.gene.ID.column = "Gene_ID",
  sc.filt.genes.cluster = FALSE
)
SDDLS &lt;- genMixedCellProp(
  object = SDDLS,
  cell.ID.column = "Cell_ID",
  cell.type.column = "Cell_Type",
  num.sim.spots = 50,
  train.freq.cells = 2/3,
  train.freq.spots = 2/3,
  verbose = TRUE
)
SDDLS &lt;- simMixedProfiles(SDDLS)
# training of DDLS model
SDDLS &lt;- trainDeconvModel(
  object = SDDLS,
  batch.size = 15,
  num.epochs = 5
)
# evaluation using test data
SDDLS &lt;- calculateEvalMetrics(object = SDDLS)
# Bland-Altman plot by cell type
blandAltmanLehPlot(
  object = SDDLS,
  facet.by = "CellType",
  color.by = "CellType"
)
# Bland-Altman plot of all samples mixed
blandAltmanLehPlot(
  object = SDDLS,
  facet.by = NULL,
  color.by = "CellType",
  alpha.point = 0.3,
  log2 = TRUE
)


</code></pre>

<hr>
<h2 id='calculateEvalMetrics'>Calculate evaluation metrics on test mixed transcriptional profiles</h2><span id='topic+calculateEvalMetrics'></span>

<h3>Description</h3>

<p>Calculate evaluation metrics on test mixed transcriptional profiles. By
default, absolute error (<code>AbsErr</code>), proportional absolute error
(<code>ppAbsErr</code>), squared error (<code>SqrErr</code>), and proportional squared
error (<code>ppSqrErr</code>) are calculated for each test mixed profile. In
addition, each of these metrics is aggregated according to three criteria:
cell type (<code>CellType</code>), probability bins in ranges of 0.1 (<code>pBin</code>),
and number of different cell types present in the spot (<code>nCellTypes</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateEvalMetrics(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculateEvalMetrics_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object with a trained model in
<code>trained.model</code> slot and the actual cell proportions of test mixed
profiles in <code>prob.cell.types</code> slot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object with is a
<code><a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code> object. The calculated metrics are
stored in the <code>test.deconv.metrics</code> slot of the
<code><a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distErrorPlot">distErrorPlot</a></code> <code><a href="#topic+corrExpPredPlot">corrExpPredPlot</a></code>
<code><a href="#topic+blandAltmanLehPlot">blandAltmanLehPlot</a></code> <code><a href="#topic+barErrorPlot">barErrorPlot</a></code>
</p>

<hr>
<h2 id='cell.names'>Get and set <code>cell.names</code> slot in a
<code><a href="#topic+PropCellTypes-class">PropCellTypes</a></code> object</h2><span id='topic+cell.names'></span><span id='topic+cell.names+2CPropCellTypes-method'></span><span id='topic+cell.names+3C-'></span><span id='topic+cell.names+3C-+2CPropCellTypes-method'></span>

<h3>Description</h3>

<p>Get and set <code>cell.names</code> slot in a
<code><a href="#topic+PropCellTypes-class">PropCellTypes</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cell.names(object)

cell.names(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cell.names_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+PropCellTypes-class">PropCellTypes</a></code> object.</p>
</td></tr>
<tr><td><code id="cell.names_+3A_value">value</code></td>
<td>
<p>Matrix containing names of the mixed transcriptional profiles to
be simulated as rows and cells to be used to simulate them as columns.</p>
</td></tr>
</table>

<hr>
<h2 id='cell.types'>Get and set <code>cell.types</code> slot in a
<code><a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code> object</h2><span id='topic+cell.types'></span><span id='topic+cell.types+2CDeconvDLModel-method'></span><span id='topic+cell.types+3C-'></span><span id='topic+cell.types+3C-+2CDeconvDLModel-method'></span>

<h3>Description</h3>

<p>Get and set <code>cell.types</code> slot in a
<code><a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cell.types(object)

cell.types(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cell.types_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code> object.</p>
</td></tr>
<tr><td><code id="cell.types_+3A_value">value</code></td>
<td>
<p>Vector with cell types considered by the deep neural network
model.</p>
</td></tr>
</table>

<hr>
<h2 id='corrExpPredPlot'>Generate correlation plots between predicted and expected cell type
proportions of test data</h2><span id='topic+corrExpPredPlot'></span>

<h3>Description</h3>

<p>Generate correlation plots between predicted and expected cell type
proportions of test data. Correlation plots can be shown all mixed or either
split by cell type (<code>CellType</code>) or the number of different cell types
present in the spots (<code>nCellTypes</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corrExpPredPlot(
  object,
  colors,
  facet.by = NULL,
  color.by = "CellType",
  corr = "both",
  filter.sc = TRUE,
  pos.x.label = 0.01,
  pos.y.label = 0.95,
  sep.labels = 0.15,
  size.point = 0.1,
  alpha.point = 1,
  ncol = NULL,
  nrow = NULL,
  title = NULL,
  theme = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="corrExpPredPlot_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object with
<code>trained.model</code> slot containing metrics in the
<code>test.deconv.metrics</code> slot of a <code><a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code>
object.</p>
</td></tr>
<tr><td><code id="corrExpPredPlot_+3A_colors">colors</code></td>
<td>
<p>Vector of colors to be used.</p>
</td></tr>
<tr><td><code id="corrExpPredPlot_+3A_facet.by">facet.by</code></td>
<td>
<p>Show data in different panels. Options are <code>nCellTypes</code>
(number of different cell types) and <code>CellType</code> (cell type)
(<code>NULL</code> by default).</p>
</td></tr>
<tr><td><code id="corrExpPredPlot_+3A_color.by">color.by</code></td>
<td>
<p>Variable used to color data. Options are <code>nCellTypes</code>
and <code>CellType</code>.</p>
</td></tr>
<tr><td><code id="corrExpPredPlot_+3A_corr">corr</code></td>
<td>
<p>Correlation value shown as an annotation on the plot. Available
metrics are Pearson's correlation coefficient (<code>'pearson'</code>) and
concordance correlation coefficient (<code>'ccc'</code>). It can be
<code>'pearson'</code>, <code>'ccc'</code> or <code>'both'</code> (by default).</p>
</td></tr>
<tr><td><code id="corrExpPredPlot_+3A_filter.sc">filter.sc</code></td>
<td>
<p>Boolean indicating whether single-cell profiles are filtered
out and only mixed transcriptional profile errors are shown (<code>TRUE</code> by
default).</p>
</td></tr>
<tr><td><code id="corrExpPredPlot_+3A_pos.x.label">pos.x.label</code></td>
<td>
<p>X-axis position of correlation annotations (0.95 by
default).</p>
</td></tr>
<tr><td><code id="corrExpPredPlot_+3A_pos.y.label">pos.y.label</code></td>
<td>
<p>Y-axis position of correlation annotations (0.1 by
default).</p>
</td></tr>
<tr><td><code id="corrExpPredPlot_+3A_sep.labels">sep.labels</code></td>
<td>
<p>Space separating annotations if <code>corr</code> is equal to
<code>'both'</code> (0.15 by default).</p>
</td></tr>
<tr><td><code id="corrExpPredPlot_+3A_size.point">size.point</code></td>
<td>
<p>Size of points (0.1 by default).</p>
</td></tr>
<tr><td><code id="corrExpPredPlot_+3A_alpha.point">alpha.point</code></td>
<td>
<p>Alpha of points (0.1 by default).</p>
</td></tr>
<tr><td><code id="corrExpPredPlot_+3A_ncol">ncol</code></td>
<td>
<p>Number of columns if <code>facet.by</code> is other than <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="corrExpPredPlot_+3A_nrow">nrow</code></td>
<td>
<p>Number of rows if <code>facet.by</code> is different from <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="corrExpPredPlot_+3A_title">title</code></td>
<td>
<p>Title of the plot.</p>
</td></tr>
<tr><td><code id="corrExpPredPlot_+3A_theme">theme</code></td>
<td>
<p><span class="pkg">ggplot2</span> theme.</p>
</td></tr>
<tr><td><code id="corrExpPredPlot_+3A_...">...</code></td>
<td>
<p>Additional arguments for the <a href="ggplot2.html#topic+facet_wrap">facet_wrap</a> function
of <span class="pkg">ggplot2</span> if <code>facet.by</code> is not <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calculateEvalMetrics">calculateEvalMetrics</a></code> <code><a href="#topic+distErrorPlot">distErrorPlot</a></code>
<code><a href="#topic+blandAltmanLehPlot">blandAltmanLehPlot</a></code> <code><a href="#topic+barErrorPlot">barErrorPlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
sce &lt;- SingleCellExperiment::SingleCellExperiment(
  assays = list(
    counts = matrix(
      rpois(30, lambda = 5), nrow = 15, ncol = 20,
      dimnames = list(paste0("Gene", seq(15)), paste0("RHC", seq(20)))
    )
  ),
  colData = data.frame(
    Cell_ID = paste0("RHC", seq(20)),
    Cell_Type = sample(x = paste0("CellType", seq(6)), size = 20,
                       replace = TRUE)
  ),
  rowData = data.frame(
    Gene_ID = paste0("Gene", seq(15))
  )
)
SDDLS &lt;- createSpatialDDLSobject(
  sc.data = sce,
  sc.cell.ID.column = "Cell_ID",
  sc.gene.ID.column = "Gene_ID",
  sc.filt.genes.cluster = FALSE
)
SDDLS &lt;- genMixedCellProp(
  object = SDDLS,
  cell.ID.column = "Cell_ID",
  cell.type.column = "Cell_Type",
  num.sim.spots = 50,
  train.freq.cells = 2/3,
  train.freq.spots = 2/3,
  verbose = TRUE
)
SDDLS &lt;- simMixedProfiles(SDDLS)
# training of DDLS model
SDDLS &lt;- trainDeconvModel(
  object = SDDLS,
  batch.size = 15,
  num.epochs = 5
)
# evaluation using test data
SDDLS &lt;- calculateEvalMetrics(object = SDDLS)
# correlations by cell type
corrExpPredPlot(
  object = SDDLS,
  facet.by = "CellType",
  color.by = "CellType",
  corr = "both"
)
# correlations of all samples mixed
corrExpPredPlot(
  object = SDDLS,
  facet.by = NULL,
  color.by = "CellType",
  corr = "ccc",
  pos.x.label = 0.2,
  alpha.point = 0.3
)


</code></pre>

<hr>
<h2 id='createSpatialDDLSobject'>Create a <code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object</h2><span id='topic+createSpatialDDLSobject'></span>

<h3>Description</h3>

<p>Create a <code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object by providing single-cell
RNA-seq data. Additionally, spatial transcriptomics data contained in
<code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> objects can also be provided. It is
recommended to provide both types of data to only use genes shared between
both experiments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createSpatialDDLSobject(
  sc.data,
  sc.cell.ID.column,
  sc.cell.type.column,
  sc.gene.ID.column,
  st.data,
  st.spot.ID.column,
  st.gene.ID.column,
  filter.mt.genes = "^mt-",
  sc.filt.genes.cluster = TRUE,
  sc.min.mean.counts = 1,
  sc.n.genes.per.cluster = 300,
  top.n.genes = 2000,
  sc.log.FC = TRUE,
  sc.min.counts = 1,
  sc.min.cells = 1,
  st.min.counts = 1,
  st.min.spots = 1,
  st.n.slides = 3,
  shared.genes = TRUE,
  sc.name.dataset.h5 = NULL,
  sc.file.backend = NULL,
  sc.name.dataset.backend = NULL,
  sc.compression.level = NULL,
  sc.chunk.dims = NULL,
  sc.block.processing = FALSE,
  verbose = TRUE,
  project = "SpatialDDLS-Proj"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createSpatialDDLSobject_+3A_sc.data">sc.data</code></td>
<td>
<p>Single-cell RNA-seq profiles to be used as reference. If data
are provided from files, <code>single.cell.real</code> must be a vector of three
elements: single-cell counts, cells metadata and genes metadata. On the
other hand, If data are provided from a
<code><a href="SingleCellExperiment.html#topic+SingleCellExperiment">SingleCellExperiment</a></code> object,
single-cell counts must be present in the <code>assay</code> slot, cells metadata
in the <code>colData</code> slot, and genes metadata in the <code>rowData</code> slot.</p>
</td></tr>
<tr><td><code id="createSpatialDDLSobject_+3A_sc.cell.id.column">sc.cell.ID.column</code></td>
<td>
<p>Name or number of the column in cells metadata
corresponding to cell names in expression matrix (single-cell RNA-seq
data).</p>
</td></tr>
<tr><td><code id="createSpatialDDLSobject_+3A_sc.cell.type.column">sc.cell.type.column</code></td>
<td>
<p>Name or column number corresponding to cell types
in cells metadata.</p>
</td></tr>
<tr><td><code id="createSpatialDDLSobject_+3A_sc.gene.id.column">sc.gene.ID.column</code></td>
<td>
<p>Name or number of the column in genes metadata
corresponding to the names used for features/genes (single-cell RNA-seq
data).</p>
</td></tr>
<tr><td><code id="createSpatialDDLSobject_+3A_st.data">st.data</code></td>
<td>
<p>Spatial transcriptomics datasets to be deconvoluted. It can be
a single <code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code> object or a
list of them.</p>
</td></tr>
<tr><td><code id="createSpatialDDLSobject_+3A_st.spot.id.column">st.spot.ID.column</code></td>
<td>
<p>Name or number of the column in spots metadata
corresponding to spot names in expression matrix (spatial transcriptomics
data).</p>
</td></tr>
<tr><td><code id="createSpatialDDLSobject_+3A_st.gene.id.column">st.gene.ID.column</code></td>
<td>
<p>Name or number of the column in the genes metadata
corresponding to the names used for features/genes (spatial transcriptomics
data).</p>
</td></tr>
<tr><td><code id="createSpatialDDLSobject_+3A_filter.mt.genes">filter.mt.genes</code></td>
<td>
<p>Regular expression matching mitochondrial genes to
be ruled out (<code>^mt-</code> by default). If <code>NULL</code>, no filtering is
performed.</p>
</td></tr>
<tr><td><code id="createSpatialDDLSobject_+3A_sc.filt.genes.cluster">sc.filt.genes.cluster</code></td>
<td>
<p>Whether to filter single-cell RNA-seq genes
according to a minimum threshold of non-zero average counts per cell type
(<code>sc.min.mean.counts</code>). <code>TRUE</code> by default.</p>
</td></tr>
<tr><td><code id="createSpatialDDLSobject_+3A_sc.min.mean.counts">sc.min.mean.counts</code></td>
<td>
<p>Minimum non-zero average counts per cluster to
filter genes. 1 by default.</p>
</td></tr>
<tr><td><code id="createSpatialDDLSobject_+3A_sc.n.genes.per.cluster">sc.n.genes.per.cluster</code></td>
<td>
<p>Top n genes with the highest logFC per cluster
(300 by default). See Details section for more details.</p>
</td></tr>
<tr><td><code id="createSpatialDDLSobject_+3A_top.n.genes">top.n.genes</code></td>
<td>
<p>Maximum number of genes used for downstream steps (2000
by default). In case the number of genes after filtering is greater than
<code>top.n.genes</code>, these genes will be set according to
variability across the whole single-cell dataset.</p>
</td></tr>
<tr><td><code id="createSpatialDDLSobject_+3A_sc.log.fc">sc.log.FC</code></td>
<td>
<p>Whether to filter genes with a logFC less than 0.5 when
<code>sc.filt.genes.cluster = TRUE</code> (<code>TRUE</code> by default).</p>
</td></tr>
<tr><td><code id="createSpatialDDLSobject_+3A_sc.min.counts">sc.min.counts</code></td>
<td>
<p>Minimum gene counts to filter (1 by default; single-cell
RNA-seq data).</p>
</td></tr>
<tr><td><code id="createSpatialDDLSobject_+3A_sc.min.cells">sc.min.cells</code></td>
<td>
<p>Minimum of cells with more than <code>min.counts</code> (1 by
default; single-cell RNA-seq data).</p>
</td></tr>
<tr><td><code id="createSpatialDDLSobject_+3A_st.min.counts">st.min.counts</code></td>
<td>
<p>Minimum gene counts to filter (1 by default; spatial
transcriptomics data).</p>
</td></tr>
<tr><td><code id="createSpatialDDLSobject_+3A_st.min.spots">st.min.spots</code></td>
<td>
<p>Minimum of cells with more than <code>min.counts</code> (1 by
default; spatial transcriptomics data).</p>
</td></tr>
<tr><td><code id="createSpatialDDLSobject_+3A_st.n.slides">st.n.slides</code></td>
<td>
<p>Minimum number of slides
(<code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code>
objects) in which a gene has to be expressed in order to keep it. This
parameter is applicable only when
multiple
<code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code>
objects are provided. Genes not present in at least <code>st.n.slides</code> will
be discarded. If no filtering is desired, set <code>st.n.slides = 1</code>.</p>
</td></tr>
<tr><td><code id="createSpatialDDLSobject_+3A_shared.genes">shared.genes</code></td>
<td>
<p>If set to <code>TRUE</code>, only genes present in both the
single-cell and spatial transcriptomics data will be retained for further
processing (<code>TRUE</code> by default).</p>
</td></tr>
<tr><td><code id="createSpatialDDLSobject_+3A_sc.name.dataset.h5">sc.name.dataset.h5</code></td>
<td>
<p>Name of the data set if HDF5 file is provided for
single-cell RNA-seq data.</p>
</td></tr>
<tr><td><code id="createSpatialDDLSobject_+3A_sc.file.backend">sc.file.backend</code></td>
<td>
<p>Valid file path where to store the loaded for
single-cell RNA-seq data as HDF5 file. If provided, data are stored in a
HDF5 file as back-end using the <span class="pkg">DelayedArray</span> and <span class="pkg">HDF5Array</span>
packages instead of being loaded into RAM. This is suitable for situations
where you have large amounts of data that cannot be stored in memory. Note
that operations on these data will be performed by blocks (i.e subsets of
determined size), which may result in longer execution times. <code>NULL</code>
by default.</p>
</td></tr>
<tr><td><code id="createSpatialDDLSobject_+3A_sc.name.dataset.backend">sc.name.dataset.backend</code></td>
<td>
<p>Name of the HDF5 file dataset to be used. Note
that it cannot exist. If <code>NULL</code> (by default), a random dataset name
will be generated.</p>
</td></tr>
<tr><td><code id="createSpatialDDLSobject_+3A_sc.compression.level">sc.compression.level</code></td>
<td>
<p>The compression level used if
<code>sc.file.backend</code> is provided. It is an integer value between 0 (no
compression) and 9 (highest and slowest compression). See
<code>?<a href="HDF5Array.html#topic+getHDF5DumpCompressionLevel">getHDF5DumpCompressionLevel</a></code> from the
<span class="pkg">HDF5Array</span> package for more information.</p>
</td></tr>
<tr><td><code id="createSpatialDDLSobject_+3A_sc.chunk.dims">sc.chunk.dims</code></td>
<td>
<p>Specifies dimensions that HDF5 chunk will have. If
<code>NULL</code>, the default value is a vector of two items: the number of
genes considered by <code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object during the
simulation, and only one sample in order to increase read times in the
following steps. A larger number of columns written in each chunk may lead
to longer read times.</p>
</td></tr>
<tr><td><code id="createSpatialDDLSobject_+3A_sc.block.processing">sc.block.processing</code></td>
<td>
<p>Boolean indicating whether single-cell RNA-seq
data should be treated as blocks (only if data are provided as HDF5 file).
<code>FALSE</code> by default. Note that using this functionality is suitable for
cases where it is not possible to load data into RAM and therefore
execution times will be longer.</p>
</td></tr>
<tr><td><code id="createSpatialDDLSobject_+3A_verbose">verbose</code></td>
<td>
<p>Show informative messages during the execution (<code>TRUE</code> by
default).</p>
</td></tr>
<tr><td><code id="createSpatialDDLSobject_+3A_project">project</code></td>
<td>
<p>Name of the project for <code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code>
object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Filtering genes</strong>
</p>
<p>In order to reduce the number of dimensions used for subsequent steps,
<code>createSpatialDDLSobject</code> implements different strategies aimed at
removing useless genes for deconvolution: </p>
 <ul>
<li><p> Filtering at the
cell level: genes less expressed than a determined cutoff in N cells are
removed. See <code>sc.min.cells</code>/<code>st.min.cells</code> and
<code>sc.min.counts</code>/<code>st.min.cells</code> parameters. </p>
</li>
<li><p> Filtering at the
cluster level (only for scRNA-seq data): if
<code>sc.filt.genes.cluster == TRUE</code>, <code>createSpatialDDLSobject</code> sets a
cutoff of non-zero average counts per
cluster (<code>sc.min.mean.counts</code> parameter) and take only the
<code>sc.n.genes.per.cluster</code> genes with the highest logFC per cluster.
LogFCs are calculated using normalized logCPM of each cluster with respect to
the average in the whole dataset). Finally, if
the number of remaining genes is greater than <code>top.n.genes</code>, genes are
ranked based on variance and the <code>top.n.genes</code> most variable genes are
used for downstream analyses.</p>
</li></ul>

<p><strong>Single-cell RNA-seq data</strong>
</p>
<p>Single-cell RNA-seq data can be provided from files (formats allowed: tsv,
tsv.gz, mtx (sparse matrix) and hdf5) or a
<code><a href="SingleCellExperiment.html#topic+SingleCellExperiment">SingleCellExperiment</a></code> object. Data will be
stored in the <code>single.cell.real</code> slot, and must consist of three pieces
of information: </p>
 <ul>
<li><p> Single-cell counts: genes as rows and cells
as columns. </p>
</li>
<li><p> Cells metadata: annotations (columns) for each cell (rows).
</p>
</li>
<li><p> Genes metadata: annotations (columns) for each gene (rows). </p>
</li></ul>
<p> If data
are provided from files, <code>single.cell.real</code> argument must be a vector of
three elements ordered so that the first file corresponds to the count
matrix, the second to the cells metadata, and the last to the genes metadata.
On the other hand, if data are provided as a
<code><a href="SingleCellExperiment.html#topic+SingleCellExperiment">SingleCellExperiment</a></code> object, it must
contain single-cell counts in <code>assay</code>, cells metadata in <code>colData</code>,
and genes metadata in <code>rowData</code>. Data must be provided without any
transformation (e.g. log-transformation), raw counts are preferred.
</p>
<p><strong>Spatial transcriptomics data</strong>
</p>
<p>It must be a <code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code> object (or a
list of them if more than one slide is going to be deconvoluted) containing
the same information as the single-cell RNA-seq data: the count matrix, spots
metadata, and genes metadata. Please, make sure the gene identifiers used the
spatial and single-cell transcriptomics data are consistent.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object with the single-cell
RNA-seq data provided loaded into the <code>single.cell.real</code> slot as a
<code><a href="SingleCellExperiment.html#topic+SingleCellExperiment">SingleCellExperiment</a></code> object. If spatial
transcriptomics data are provided, they will be loaded into the
<code>spatial.experiments</code> slot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimateZinbwaveParams">estimateZinbwaveParams</a></code> <code><a href="#topic+genMixedCellProp">genMixedCellProp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
sce &lt;- SingleCellExperiment::SingleCellExperiment(
  assays = list(
    counts = matrix(
      rpois(100, lambda = 5), nrow = 40, ncol = 30,
      dimnames = list(paste0("Gene", seq(40)), paste0("RHC", seq(30)))
    )
  ),
  colData = data.frame(
    Cell_ID = paste0("RHC", seq(30)),
    Cell_Type = sample(x = paste0("CellType", seq(4)), size = 30,
                       replace = TRUE)
  ),
  rowData = data.frame(
    Gene_ID = paste0("Gene", seq(40))
  )
)
counts &lt;- matrix(
  rpois(30, lambda = 5), ncol = 6,
  dimnames = list(paste0("Gene", 1:5), paste0("Spot", 1:6))
)
coordinates &lt;- matrix(
  c(1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3), ncol = 2
)
ste &lt;- SpatialExperiment::SpatialExperiment(
  assays = list(counts = as.matrix(counts)),
  rowData = data.frame(Gene_ID = paste0("Gene", 1:5)),
  colData = data.frame(Cell_ID = paste0("Spot", 1:6)),
  spatialCoords = coordinates
)

SDDLS &lt;- createSpatialDDLSobject(
  sc.data = sce,
  sc.cell.ID.column = "Cell_ID",
  sc.gene.ID.column = "Gene_ID",
  st.data = ste,
  st.spot.ID.column = "Cell_ID",
  st.gene.ID.column = "Gene_ID",
  project = "Simul_example",
  sc.filt.genes.cluster = FALSE
)
  
</code></pre>

<hr>
<h2 id='deconv.spots'>Get and set <code>deconv.spots</code> slot in a
<code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code> object</h2><span id='topic+deconv.spots'></span><span id='topic+deconv.spots+2CSpatialDDLS-method'></span><span id='topic+deconv.spots+3C-'></span><span id='topic+deconv.spots+3C-+2CSpatialDDLS-method'></span>

<h3>Description</h3>

<p>Get and set <code>deconv.spots</code> slot in a
<code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deconv.spots(object, index.st = NULL)

deconv.spots(object, index.st = NULL) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deconv.spots_+3A_object">object</code></td>
<td>
<p><code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code> object.</p>
</td></tr>
<tr><td><code id="deconv.spots_+3A_index.st">index.st</code></td>
<td>
<p>Name or index of predicted cell proportions (same as for the
<code>spatial.experiments</code> slot). If <code>NULL</code> (by default), all
results are returned.</p>
</td></tr>
<tr><td><code id="deconv.spots_+3A_value">value</code></td>
<td>
<p>List of predicted cell type proportions for the experiments
stored in the <code>spatial.experiments</code> slot.</p>
</td></tr>
</table>

<hr>
<h2 id='DeconvDLModel-class'>The DeconvDLModel Class</h2><span id='topic+DeconvDLModel-class'></span><span id='topic+DeconvDLModel'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code> object stores all the information
related to deep neural network models. It consists of the trained model, the
training history, and the predictions on test data. After running
<code><a href="#topic+calculateEvalMetrics">calculateEvalMetrics</a></code>, it is possible to find the performance
evaluation of the model on test data (see <code>?<a href="#topic+calculateEvalMetrics">calculateEvalMetrics</a></code>
for details).
</p>


<h3>Details</h3>

<p>The steps related to Deep Learning are carried out using the <span class="pkg">keras</span> and
<span class="pkg">tensorflow</span> packages, which use the R6 classes system. If you want to
save the <code><a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code> object as an RDS file,
<span class="pkg">SpatialDDLS</span> provides a <code>saveRDS</code> generic function that transforms
the R6 object containing the trained model into a native valid R object.
Specifically, the model is converted into a list with the architecture of the
network and the weights learned during training, which is the minimum
information needed to use the model as a predictor. If you want to keep the
optimizer state, see <code>?<a href="#topic+saveTrainedModelAsH5">saveTrainedModelAsH5</a></code>. If you want to
store either the <code><a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code> or the
<code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> objects on disk as RDA files, see
<code>?<a href="#topic+preparingToSave">preparingToSave</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>model</code></dt><dd><p>Trained deep neural network. This slot can contain an R6
<code>keras.engine.sequential.Sequential</code> object or a list with two
elements: the architecture of the model and the resulting weights after
training.</p>
</dd>
<dt><code>training.history</code></dt><dd><p>List with the evolution of the selected metrics during
training.</p>
</dd>
<dt><code>test.metrics</code></dt><dd><p>Performance of the model on test data.</p>
</dd>
<dt><code>test.pred</code></dt><dd><p>Predicted cell type proportions on test data.</p>
</dd>
<dt><code>cell.types</code></dt><dd><p>Vector with cell types considered by the model.</p>
</dd>
<dt><code>features</code></dt><dd><p>Vector with features (genes) considered by the model. These
features will be used for subsequent predictions.</p>
</dd>
<dt><code>test.deconv.metrics</code></dt><dd><p>Performance of the model on test data by cell type.
This slot is generated by the <code><a href="#topic+calculateEvalMetrics">calculateEvalMetrics</a></code> function
(see <code>?<a href="#topic+calculateEvalMetrics">calculateEvalMetrics</a></code> for more details).</p>
</dd>
<dt><code>interpret.gradients</code></dt><dd><p>Gradients for interpretation. <span class="pkg">SpatialDDLS</span>
provides some functions to better understand prediction made by the model
(see <code>?<a href="#topic+interGradientsDL">interGradientsDL</a></code> for more details). This slot is a list
of either one or two elements: gradients of either the loss function or the
predicted class with respect to the input variables using pure (only one
cell type) mixed transcriptional profiles. These gradients can be
interpreted as to what extent the model is using these variables to predict
each cell type proportions.</p>
</dd>
</dl>

<hr>
<h2 id='deconvSpatialDDLS'>Deconvolute spatial transcriptomics data using trained model</h2><span id='topic+deconvSpatialDDLS'></span>

<h3>Description</h3>

<p>Deconvolute spatial transcriptomics data using the trained model in
the <code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object. The trained model is used
to predict cell proportions of two mirrored transcriptional profiles:
</p>
 <ul>
<li><p> 'Intrinsic' profiles: transcriptional profiles of each spot
in the ST dataset. </p>
</li>
<li><p> 'Extrinsic' profiles: profiles simulated from the
surrounding spots of each spot.</p>
</li></ul>
<p> After prediction, cell proportions
from the intrinsic profiles (intrinsic cell proportions) are regularized
based on the similarity between intrinsic and extrinsic profiles in order
to maintain spatial consistency. This approach leverages both transcriptional
and spatial information. For more details, see Mañanes et al., 2023 and the
Details section.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deconvSpatialDDLS(
  object,
  index.st,
  normalize = TRUE,
  scaling = "standardize",
  k.spots = 4,
  pca.space = TRUE,
  fast.pca = TRUE,
  pcs.num = 50,
  pca.var = 0.8,
  metric = "euclidean",
  alpha.cutoff = "mean",
  alpha.quantile = 0.5,
  simplify.set = NULL,
  simplify.majority = NULL,
  use.generator = FALSE,
  batch.size = 64,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deconvSpatialDDLS_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object with
<code>trained.model</code> and <code>spatial.experiments</code> slots.</p>
</td></tr>
<tr><td><code id="deconvSpatialDDLS_+3A_index.st">index.st</code></td>
<td>
<p>Name or index of the dataset/slide stored in the
<code>SpatialDDLS</code> object (<code>spatial.experiments</code> slot) to be
deconvolute. If missing, all datasets will be deconvoluted.</p>
</td></tr>
<tr><td><code id="deconvSpatialDDLS_+3A_normalize">normalize</code></td>
<td>
<p>Normalize data (logCPM) before deconvolution (<code>TRUE</code> by
default).</p>
</td></tr>
<tr><td><code id="deconvSpatialDDLS_+3A_scaling">scaling</code></td>
<td>
<p>How to scale data before training. Options include
<code>"standardize"</code> (values are centered around the mean with a unit
standard deviation) or <code>"rescale"</code> (values are shifted and rescaled so
that they end up ranging between 0 and 1). If <code>normalize = FALSE</code>,
data are not scaled.</p>
</td></tr>
<tr><td><code id="deconvSpatialDDLS_+3A_k.spots">k.spots</code></td>
<td>
<p>Number of nearest spots considered for each spot during
regularization and simulation of extrinsic transcriptional profiles. The
greater, the smoother the regularization will be (4 by default).</p>
</td></tr>
<tr><td><code id="deconvSpatialDDLS_+3A_pca.space">pca.space</code></td>
<td>
<p>Whether to use PCA space to calculate distances between
intrinsic and extrinsic transcriptional profiles (<code>TRUE</code> by default).</p>
</td></tr>
<tr><td><code id="deconvSpatialDDLS_+3A_fast.pca">fast.pca</code></td>
<td>
<p>Whether using the <span class="pkg">irlba</span> implementation. If <code>TRUE</code>,
the number of PCs used is defined by the  parameter. If
<code>FALSE</code>, the PCA implementation from the <span class="pkg">stats</span> R package is
used instead (<code>TRUE</code> by default).</p>
</td></tr>
<tr><td><code id="deconvSpatialDDLS_+3A_pcs.num">pcs.num</code></td>
<td>
<p>Number of PCs used to calculate distances if
<code>fast.pca == TRUE</code> (50 by default).</p>
</td></tr>
<tr><td><code id="deconvSpatialDDLS_+3A_pca.var">pca.var</code></td>
<td>
<p>Threshold of explained
variance (between 0.2 and 1) used to choose the number of PCs used if
<code>pca.space == TRUE</code> and <code>fast.pca == FALSE</code> (0.8 by default).</p>
</td></tr>
<tr><td><code id="deconvSpatialDDLS_+3A_metric">metric</code></td>
<td>
<p>Metric used to measure distance/similarity between intrinsic
and extrinsic transcriptional profiles. It may be <code>'euclidean'</code>,
<code>'cosine'</code> or <code>'pearson'</code> (<code>'euclidean'</code> by default).</p>
</td></tr>
<tr><td><code id="deconvSpatialDDLS_+3A_alpha.cutoff">alpha.cutoff</code></td>
<td>
<p>Minimum distance for regularization.
It may be <code>'mean'</code> (spots with transcriptional distances shorter than
the mean distance of the dataset will be modified) or <code>'quantile'</code>
(spots with transcriptional distances shorter than the
<code>alpha.quantile</code> quantile are used). <code>'mean'</code> by default.</p>
</td></tr>
<tr><td><code id="deconvSpatialDDLS_+3A_alpha.quantile">alpha.quantile</code></td>
<td>
<p>Quantile used if <code>alpha.cutoff == 'quantile'</code>.
0.5 by default.</p>
</td></tr>
<tr><td><code id="deconvSpatialDDLS_+3A_simplify.set">simplify.set</code></td>
<td>
<p>List specifying which cell types should be compressed
into a new label with the name of the list item. See examples for details.
If provided, results are stored in a list with <code>'raw'</code> and
<code>'simpli.set'</code> elements.</p>
</td></tr>
<tr><td><code id="deconvSpatialDDLS_+3A_simplify.majority">simplify.majority</code></td>
<td>
<p>List specifying which cell types should be
compressed into the cell type with the highest proportion in each spot.
Unlike <code>simplify.set</code>, no new labels are created. If provided, results
are stored in a list with <code>'raw'</code> and <code>'simpli.majority'</code>
elements.</p>
</td></tr>
<tr><td><code id="deconvSpatialDDLS_+3A_use.generator">use.generator</code></td>
<td>
<p>Boolean indicating whether to use generators for
prediction (<code>FALSE</code> by default).</p>
</td></tr>
<tr><td><code id="deconvSpatialDDLS_+3A_batch.size">batch.size</code></td>
<td>
<p>Number of samples per batch. Only when <code>use.generator
= TRUE</code>.</p>
</td></tr>
<tr><td><code id="deconvSpatialDDLS_+3A_verbose">verbose</code></td>
<td>
<p>Show informative messages during the execution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The deconvolution process involves two main steps: predicting cell
proportions based on transcriptome using the trained neural network model,
and regularization of cell proportions based on the spatial location of each
spot. In the regularization step, a mirrored version of each spot is
simulated based on its N-nearest spots. We refer to these profiles as
'extrinsic' profiles, whereas the transcriptional profiles of each spot are
called 'intrinsic' profiles. Extrinsic profiles are used to regularize
predictions based on intrinsic profiles. The rationale is that spots
surrounded by transcriptionally similar spots should have similar cell
compositions, and therefore predicted proportions can be smoothed to preserve
their spatial consistency. On the other hand, spots surrounded by dissimilar
spots cannot be predicted by their neighbors, and thus they can only be
predicted by their own transcriptional profiles likely due to presenting very
specific cell compositions.
</p>
<p>Regarding the working os <span class="pkg">SpatialDDLS</span>: first, extrinsic profiles are
simulated based on the N-nearest spots for each spot by summing their
transcriptomes. Distances between extrinsic and intrinsic profiles of each
spot are calculated so that similar/dissimilar spots are identified. These
two sets of transcriptional profiles are used as input for the trained neural
network model, and according to the calculated distances, a weighted mean
between the predicted proportions for each spot is calculated. Spots with
distances between intrinsic and extrinsic profiles greater than
<code>alpha.cutoff</code> are not regularized, whereas spots with distances less
than <code>alpha.cutoff</code> contribute to the weighted mean. Weights are
calculated by rescaling distances less than <code>alpha.cutoff</code> between 0
and 0.5, so that the maximum extent to which a extrinsic profile can
modified the predictions based on intrinsic profiles is 0.5 (a regular
mean). For more details, see Mañanes et al., 2023.
</p>
<p>This function requires a <code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object with a
trained deep neural network model (<code><a href="#topic+trained.model">trained.model</a></code> slot, and the
spatial transcriptomics datasets to be deconvoluted in the
<code>spatial.experiments</code> slot. See <code>?<a href="#topic+createSpatialDDLSobject">createSpatialDDLSobject</a></code>
or <code>?<a href="#topic+loadSTProfiles">loadSTProfiles</a></code> for more details.
</p>


<h3>Value</h3>

<p><code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object with a <code>deconv.spots</code>
slot. The output is a list containing 'Regularized', 'Intrinsic' and
'Extrinsic' deconvoluted cell proportions, 'Distances' between intrinsic
and extrinsic transcriptional profiles, and 'Weight.factors' with the
final weights used to regularize intrinsic cell proportions. If
<code>simplify.set</code> and/or <code>simplify.majority</code> are provided,
the <code>deconv.spots</code> slot will contain a list with raw and simplified
results.
</p>


<h3>References</h3>

<p>Mañanes, D., Rivero-García, I., Jimenez-Carretero, D.,
Torres, M., Sancho, D., Torroja, C., Sánchez-Cabo, F. (2023). SpatialDDLS:
An R package to deconvolute spatial transcriptomics data using neural
networks. biorxiv. doi: <a href="https://doi.org/10.1101/2023.08.31.555677">doi:10.1101/2023.08.31.555677</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trainDeconvModel">trainDeconvModel</a></code> <code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
sce &lt;- SingleCellExperiment::SingleCellExperiment(
  assays = list(
    counts = matrix(
     rpois(30, lambda = 5), nrow = 15, ncol = 20,
      dimnames = list(paste0("Gene", seq(15)), paste0("RHC", seq(20)))
    )
  ),
  colData = data.frame(
    Cell_ID = paste0("RHC", seq(20)),
    Cell_Type = sample(x = paste0("CellType", seq(6)), size = 20,
                       replace = TRUE)
  ),
  rowData = data.frame(
    Gene_ID = paste0("Gene", seq(15))
  )
)
SDDLS &lt;- createSpatialDDLSobject(
  sc.data = sce,
  sc.cell.ID.column = "Cell_ID",
  sc.gene.ID.column = "Gene_ID",
  sc.filt.genes.cluster = FALSE
)
SDDLS &lt;- genMixedCellProp(
  object = SDDLS,
  cell.ID.column = "Cell_ID",
  cell.type.column = "Cell_Type",
  num.sim.spots = 50,
  train.freq.cells = 2/3,
  train.freq.spots = 2/3,
  verbose = TRUE
) 
SDDLS &lt;- simMixedProfiles(SDDLS)
# training of SDDLS model
SDDLS &lt;- trainDeconvModel(
  object = SDDLS,
  batch.size = 15,
  num.epochs = 5
)
# simulating spatial data
ngenes &lt;- sample(3:40, size = 1)
ncells &lt;- sample(10:40, size = 1)
counts &lt;- matrix(
  rpois(ngenes * ncells, lambda = 5), ncol = ncells,
  dimnames = list(paste0("Gene", seq(ngenes)), paste0("Spot", seq(ncells)))
)
coordinates &lt;- matrix(
  rep(c(1, 2), ncells), ncol = 2
)
st &lt;- SpatialExperiment::SpatialExperiment(
  assays = list(counts = as.matrix(counts)),
  rowData = data.frame(Gene_ID = paste0("Gene", seq(ngenes))),
  colData = data.frame(Cell_ID = paste0("Spot", seq(ncells))),
  spatialCoords = coordinates
)
SDDLS &lt;- loadSTProfiles(
  object = SDDLS,
  st.data = st,
  st.spot.ID.column = "Cell_ID",
  st.gene.ID.column = "Gene_ID"
)
# simplify arguments
simplify &lt;- list(CellGroup1 = c("CellType1", "CellType2", "CellType4"),
                 CellGroup2 = c("CellType3", "CellType5"))
SDDLS &lt;- deconvSpatialDDLS(
  object = SDDLS,
  index.st = 1,
  simplify.set = simplify, 
  simplify.majority = simplify
)

</code></pre>

<hr>
<h2 id='distErrorPlot'>Generate box or violin plots showing error distribution</h2><span id='topic+distErrorPlot'></span>

<h3>Description</h3>

<p>Generate box or violin plots to show how errors are distributed. Errors can
be shown all mixed or either split by cell type (<code>CellType</code>) or number
of cell types present in the spots (<code>nCellTypes</code>). See the
<code>facet.by</code> argument and examples for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distErrorPlot(
  object,
  error,
  colors,
  x.by = "pBin",
  facet.by = NULL,
  color.by = "nCellTypes",
  filter.sc = TRUE,
  error.label = FALSE,
  pos.x.label = 4.6,
  pos.y.label = NULL,
  size.point = 0.1,
  alpha.point = 1,
  type = "violinplot",
  ylimit = NULL,
  nrow = NULL,
  ncol = NULL,
  title = NULL,
  theme = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distErrorPlot_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object with
<code>trained.model</code> slot containing metrics in the
<code>test.deconv.metrics</code> slot of a <code><a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code>
object.</p>
</td></tr>
<tr><td><code id="distErrorPlot_+3A_error">error</code></td>
<td>
<p>Error to be represented. Available metric errors are: absolute
error (<code>'AbsErr'</code>), proportional absolute error (<code>'ppAbsErr'</code>),
squared error (<code>'SqrErr'</code>), and proportional squared error
(<code>'ppSqrErr'</code>).</p>
</td></tr>
<tr><td><code id="distErrorPlot_+3A_colors">colors</code></td>
<td>
<p>Vector of colors to be used.</p>
</td></tr>
<tr><td><code id="distErrorPlot_+3A_x.by">x.by</code></td>
<td>
<p>Variable used for the X-axis. When <code>facet.by</code> is not
<code>NULL</code>, the best choice is <code>pBin</code> (probability bins). Options:
<code>nCellTypes</code> (number of different cell types), <code>CellType</code> (cell
type), and <code>pBin</code>.</p>
</td></tr>
<tr><td><code id="distErrorPlot_+3A_facet.by">facet.by</code></td>
<td>
<p>Show data in different panels. Options are <code>nCellTypes</code>
(number of different cell types) and <code>CellType</code> (cell type)
(<code>NULL</code> by default).</p>
</td></tr>
<tr><td><code id="distErrorPlot_+3A_color.by">color.by</code></td>
<td>
<p>Variable used to color data. Options are <code>nCellTypes</code>
and <code>CellType</code>.</p>
</td></tr>
<tr><td><code id="distErrorPlot_+3A_filter.sc">filter.sc</code></td>
<td>
<p>Boolean indicating whether single-cell profiles are filtered
out and only mixed transcriptional profile errors are shown (<code>TRUE</code> by
default).</p>
</td></tr>
<tr><td><code id="distErrorPlot_+3A_error.label">error.label</code></td>
<td>
<p>Boolean indicating whether to show the average error as a
plot annotation (<code>FALSE</code> by default).</p>
</td></tr>
<tr><td><code id="distErrorPlot_+3A_pos.x.label">pos.x.label</code></td>
<td>
<p>X-axis position of error annotations.</p>
</td></tr>
<tr><td><code id="distErrorPlot_+3A_pos.y.label">pos.y.label</code></td>
<td>
<p>Y-axis position of error annotations.</p>
</td></tr>
<tr><td><code id="distErrorPlot_+3A_size.point">size.point</code></td>
<td>
<p>Size of points (0.1 by default).</p>
</td></tr>
<tr><td><code id="distErrorPlot_+3A_alpha.point">alpha.point</code></td>
<td>
<p>Alpha of points (0.1 by default).</p>
</td></tr>
<tr><td><code id="distErrorPlot_+3A_type">type</code></td>
<td>
<p>Type of plot: <code>'boxplot'</code> or <code>'violinplot'</code> (the latter
by default).</p>
</td></tr>
<tr><td><code id="distErrorPlot_+3A_ylimit">ylimit</code></td>
<td>
<p>Upper limit in Y-axis if it is required (<code>NULL</code> by
default).</p>
</td></tr>
<tr><td><code id="distErrorPlot_+3A_nrow">nrow</code></td>
<td>
<p>Number of rows if <code>facet.by</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="distErrorPlot_+3A_ncol">ncol</code></td>
<td>
<p>Number of columns if <code>facet.by</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="distErrorPlot_+3A_title">title</code></td>
<td>
<p>Title of the plot.</p>
</td></tr>
<tr><td><code id="distErrorPlot_+3A_theme">theme</code></td>
<td>
<p><span class="pkg">ggplot2</span> theme.</p>
</td></tr>
<tr><td><code id="distErrorPlot_+3A_...">...</code></td>
<td>
<p>Additional arguments for the <a href="ggplot2.html#topic+facet_wrap">facet_wrap</a> function
of <span class="pkg">ggplot2</span> if <code>facet.by</code> is not <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calculateEvalMetrics">calculateEvalMetrics</a></code> <code><a href="#topic+corrExpPredPlot">corrExpPredPlot</a></code>
<code><a href="#topic+blandAltmanLehPlot">blandAltmanLehPlot</a></code> <code><a href="#topic+barErrorPlot">barErrorPlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
sce &lt;- SingleCellExperiment::SingleCellExperiment(
  assays = list(
    counts = matrix(
      rpois(30, lambda = 5), nrow = 15, ncol = 20,
      dimnames = list(paste0("Gene", seq(15)), paste0("RHC", seq(20)))
    )
  ),
  colData = data.frame(
    Cell_ID = paste0("RHC", seq(20)),
    Cell_Type = sample(
      x = paste0("CellType", seq(6)), size = 20, replace = TRUE
    )
  ),
  rowData = data.frame(
    Gene_ID = paste0("Gene", seq(15))
  )
)
SDDLS &lt;- createSpatialDDLSobject(
  sc.data = sce,
  sc.cell.ID.column = "Cell_ID",
  sc.gene.ID.column = "Gene_ID",
  sc.filt.genes.cluster = FALSE
)
SDDLS &lt;- genMixedCellProp(
  object = SDDLS,
  cell.ID.column = "Cell_ID",
  cell.type.column = "Cell_Type",
  num.sim.spots = 50,
  train.freq.cells = 2/3,
  train.freq.spots = 2/3,
  verbose = TRUE
)
SDDLS &lt;- simMixedProfiles(SDDLS)
# training of DDLS model
SDDLS &lt;- trainDeconvModel(
  object = SDDLS,
  batch.size = 15,
  num.epochs = 5
)
# evaluation using test data
SDDLS &lt;- calculateEvalMetrics(object = SDDLS)
# representation, for more examples, see the vignettes
distErrorPlot(
  object = SDDLS,
  error = "AbsErr",
  facet.by = "CellType",
  color.by = "nCellTypes",
  error.label = TRUE
)
distErrorPlot(
  object = SDDLS,
  error = "AbsErr",
  x.by = "CellType",
  facet.by = NULL,
  color.by = "CellType",
  error.label = TRUE
)


</code></pre>

<hr>
<h2 id='estimateZinbwaveParams'>Estimate parameters of the ZINB-WaVE model to simulate new single-cell
RNA-Seq expression profiles</h2><span id='topic+estimateZinbwaveParams'></span>

<h3>Description</h3>

<p>Estimate the parameters of the ZINB-WaVE model using a real single-cell
RNA-Seq data set as reference to simulate new single-cell profiles and
increase the signal of underrepresented cell types. This step is only is
needed if the size of the single-cell RNA-seq dataset is too small or there
are underrepresented cell types. After this step, the
<code><a href="#topic+simSCProfiles">simSCProfiles</a></code> function will use the estimated parameters to
simulate new single-cell profiles. See <code>?<a href="#topic+simSCProfiles">simSCProfiles</a></code> for more
information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateZinbwaveParams(
  object,
  cell.type.column,
  cell.ID.column,
  gene.ID.column,
  cell.cov.columns,
  gene.cov.columns,
  subset.cells = NULL,
  proportional = TRUE,
  set.type = "All",
  threads = 1,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimateZinbwaveParams_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object with a
<code>single.cell.real</code> slot.</p>
</td></tr>
<tr><td><code id="estimateZinbwaveParams_+3A_cell.type.column">cell.type.column</code></td>
<td>
<p>Name or column number corresponding to the cell type
of each cell in cells metadata.</p>
</td></tr>
<tr><td><code id="estimateZinbwaveParams_+3A_cell.id.column">cell.ID.column</code></td>
<td>
<p>Name or column number corresponding to the cell names
of expression matrix in cells metadata.</p>
</td></tr>
<tr><td><code id="estimateZinbwaveParams_+3A_gene.id.column">gene.ID.column</code></td>
<td>
<p>Name or column number corresponding to the notation
used for features/genes in genes metadata.</p>
</td></tr>
<tr><td><code id="estimateZinbwaveParams_+3A_cell.cov.columns">cell.cov.columns</code></td>
<td>
<p>Name or column number(s) in cells metadata to be used
as covariates during model fitting (if no covariates are used, set to empty
or <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="estimateZinbwaveParams_+3A_gene.cov.columns">gene.cov.columns</code></td>
<td>
<p>Name or column number(s) in genes metadata that will
be used as covariates during model fitting (if no covariates are used, set
to empty or <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="estimateZinbwaveParams_+3A_subset.cells">subset.cells</code></td>
<td>
<p>Number of cells to fit the ZINB-WaVE model. Useful when
the original data set is too large to fit the model. Set a value according
to the original data set and the resources available on your computer. If
<code>NULL</code> (by default), all cells will be used. Must be an integer
greater than or equal to the number of cell types considered and less than
or equal to the total number of cells.</p>
</td></tr>
<tr><td><code id="estimateZinbwaveParams_+3A_proportional">proportional</code></td>
<td>
<p>If <code>TRUE</code>, the original cell type proportions in the
subset of cells generated by <code>subset.cells</code> will not be altered as far
as possible. If <code>FALSE</code>, all cell types will have the same number of
cells as far as possible (<code>TRUE</code> by default).</p>
</td></tr>
<tr><td><code id="estimateZinbwaveParams_+3A_set.type">set.type</code></td>
<td>
<p>Cell type(s) to evaluate (<code>'All'</code> by default). It is
recommended fitting the model to all cell types rather than using only a
subset of them to capture the total variability present in the original
experiment even if only a subset of cell types is simulated.</p>
</td></tr>
<tr><td><code id="estimateZinbwaveParams_+3A_threads">threads</code></td>
<td>
<p>Number of threads used for estimation (1 by default). To set
up the parallel environment, the <span class="pkg">BiocParallel</span> package must be
installed.</p>
</td></tr>
<tr><td><code id="estimateZinbwaveParams_+3A_verbose">verbose</code></td>
<td>
<p>Show informative messages during the execution (<code>TRUE</code> by
default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ZINB-WaVE is a flexible model for zero-inflated count data. This function
carries out the model fit to real single-cell data modeling <code class="reqn">Y_{ij}</code> (the
count of feature <code class="reqn">j</code> for sample <code class="reqn">i</code>) as a random variable following a
zero-inflated negative binomial (ZINB) distribution. The estimated parameters
will be used for the simulation of new single-cell expression profiles by
sampling a negative binomial distribution and inserting dropouts from a
binomial distribution. To do so, <span class="pkg">SpatialDDLS</span> uses the
<code><a href="zinbwave.html#topic+zinbFit">zinbFit</a></code> function from the <span class="pkg">zinbwave</span> package
(Risso et al., 2018). For more details about the model, see Risso et al.,
2018.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object with <code>zinb.params</code>
slot containing a <code><a href="#topic+ZinbParametersModel-class">ZinbParametersModel</a></code> object. This
object contains a slot with the estimated ZINB-WaVE parameters from the
real single-cell RNA-Seq data.
</p>


<h3>References</h3>

<p>Risso, D., Perraudeau, F., Gribkova, S. et al. (2018). A general
and flexible method for signal extraction from single-cell RNA-seq data.
Nat Commun 9, 284. doi: <a href="https://doi.org/10.1038/s41467-017-02554-5">doi:10.1038/s41467-017-02554-5</a>.
</p>
<p>Torroja, C. and Sánchez-Cabo, F. (2019). digitalDLSorter: A Deep Learning
algorithm to quantify immune cell populations based on scRNA-Seq data.
Frontiers in Genetics 10, 978. doi: <a href="https://doi.org/10.3389/fgene.2019.00978">doi:10.3389/fgene.2019.00978</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simSCProfiles">simSCProfiles</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123) # reproducibility
sce &lt;- SingleCellExperiment::SingleCellExperiment(
  assays = list(
    counts = matrix(
      rpois(30, lambda = 5), nrow = 15, ncol = 10,
      dimnames = list(paste0("Gene", seq(15)), paste0("RHC", seq(10)))
    )
  ),
  colData = data.frame(
    Cell_ID = paste0("RHC", seq(10)),
    Cell_Type = sample(x = paste0("CellType", seq(2)), size = 10,
                       replace = TRUE)
  ),
  rowData = data.frame(
    Gene_ID = paste0("Gene", seq(15))
  )
)
SDDLS &lt;- createSpatialDDLSobject(
  sc.data = sce,
  sc.cell.ID.column = "Cell_ID",
  sc.gene.ID.column = "Gene_ID",
  project = "Simul_example",
  sc.filt.genes.cluster = FALSE
)
SDDLS &lt;- estimateZinbwaveParams(
  object = SDDLS,
  cell.type.column = "Cell_Type",
  cell.ID.column = "Cell_ID",
  gene.ID.column = "Gene_ID",
  subset.cells = 2,
  verbose = TRUE
)

</code></pre>

<hr>
<h2 id='features'>Get and set <code>features</code> slot in a
<code><a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code> object</h2><span id='topic+features'></span><span id='topic+features+2CDeconvDLModel-method'></span><span id='topic+features+3C-'></span><span id='topic+features+3C-+2CDeconvDLModel-method'></span>

<h3>Description</h3>

<p>Get and set <code>features</code> slot in a
<code><a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>features(object)

features(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="features_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code> object.</p>
</td></tr>
<tr><td><code id="features_+3A_value">value</code></td>
<td>
<p>Vector with features (genes) considered by the deep neural
network model.</p>
</td></tr>
</table>

<hr>
<h2 id='genMixedCellProp'>Generate training and test cell type composition matrices</h2><span id='topic+genMixedCellProp'></span>

<h3>Description</h3>

<p>Generate training and test cell type composition matrices for the simulation
of mixed transcriptional profiles with known cell composition using
single-cell expression profiles. The resulting
<code><a href="#topic+PropCellTypes-class">PropCellTypes</a></code> object will contain all the information
needed to simulate new mixed transcriptional profiles. Note this function
does not simulate the mixed profiles, this task is performed by the
<code><a href="#topic+simMixedProfiles">simMixedProfiles</a></code> or <code><a href="#topic+trainDeconvModel">trainDeconvModel</a></code> functions
(see Documentation).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genMixedCellProp(
  object,
  cell.ID.column,
  cell.type.column,
  num.sim.spots,
  n.cells = 50,
  train.freq.cells = 3/4,
  train.freq.spots = 3/4,
  proportion.method = c(0, 0, 1),
  prob.sparity = 1,
  min.zero.prop = NULL,
  balanced.type.cells = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genMixedCellProp_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object with
<code>single.cell.real</code> slot and, optionally, with <code>single.cell.simul</code>
slot.</p>
</td></tr>
<tr><td><code id="genMixedCellProp_+3A_cell.id.column">cell.ID.column</code></td>
<td>
<p>Name or column number corresponding to cell names in
cells metadata.</p>
</td></tr>
<tr><td><code id="genMixedCellProp_+3A_cell.type.column">cell.type.column</code></td>
<td>
<p>Name or column number corresponding to cell types in
cells metadata.</p>
</td></tr>
<tr><td><code id="genMixedCellProp_+3A_num.sim.spots">num.sim.spots</code></td>
<td>
<p>Number of mixed profiles to be simulated. It is
recommended to adjust this number according to the number of available
single-cell profiles.</p>
</td></tr>
<tr><td><code id="genMixedCellProp_+3A_n.cells">n.cells</code></td>
<td>
<p>Specifies the number of cells to be randomly selected and
combined to generate the simulated mixed profiles. By default, it is set to
50 It controls the level of noise present in the simulated data, as it
determines how many single-cell profiles will be combined to produce each
spot.</p>
</td></tr>
<tr><td><code id="genMixedCellProp_+3A_train.freq.cells">train.freq.cells</code></td>
<td>
<p>Proportion of cells used to simulate training mixed
transcriptional profiles (3/4 by default).</p>
</td></tr>
<tr><td><code id="genMixedCellProp_+3A_train.freq.spots">train.freq.spots</code></td>
<td>
<p>Proportion of mixed transcriptional profiles to be
used for training, relative to the total number of simulated spots
(<code>num.sim.spots</code>). The default value is 3/4.</p>
</td></tr>
<tr><td><code id="genMixedCellProp_+3A_proportion.method">proportion.method</code></td>
<td>
<p>Vector with three elements that controls the
proportion of simulated proportions generated by each method: random
sampling of a Dirichlet distribution, &quot;pure&quot; spots (1 cell type), and spots
generated from a random sampling of a Dirichlet distribution but with a
specified number of different cell types (determined by
<code>min.zero.prop</code>), respectively. By default, all samples are generated
by the last method.</p>
</td></tr>
<tr><td><code id="genMixedCellProp_+3A_prob.sparity">prob.sparity</code></td>
<td>
<p>It only affects the proportions generated by the first
method (Dirichlet distribution). It determines the probability of having
missing cell types in each simulated spot, as opposed to a mixture of all
cell types. A higher value for this parameter will result in more sparse
simulated samples.</p>
</td></tr>
<tr><td><code id="genMixedCellProp_+3A_min.zero.prop">min.zero.prop</code></td>
<td>
<p>This parameter controls the minimum number of cell types
that will be absent in each simulated spot. If <code>NULL</code> (by default),
this value will be half of the total number of different cell types, but
increasing it will result in more spots composed of fewer cell types. This
helps to create more sparse proportions and cover a wider range of
situations during model training.</p>
</td></tr>
<tr><td><code id="genMixedCellProp_+3A_balanced.type.cells">balanced.type.cells</code></td>
<td>
<p>Boolean indicating whether training and test cells
will be split in a balanced way considering cell types (<code>TRUE</code> by
default).</p>
</td></tr>
<tr><td><code id="genMixedCellProp_+3A_verbose">verbose</code></td>
<td>
<p>Show informative messages during the execution (<code>TRUE</code> by
default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First, the single-cell profiles are randomly divided into two subsets, with
2/3 of the data for training and 1/3 for testing. The default setting for
this ratio can be changed using the <code>train.freq.cells</code> parameter. Next,
a total of <code>num.sim.spots</code> mixed proportions are simulated using a
Dirichlet distribution. This simulation takes into account the probability of
missing cell types in each spot, which can be adjusted using the
<code>prob.sparity</code> parameter. For each mixed sample, <code>n.cells</code>
single-cell profiles are randomly selected and combined to generate the
simulated mixed sample. In addition to the Dirichlet-based proportions, pure
spots (containing only one cell type) and spots containing a specified number
of different cell types (determined by the <code>min.zero.prop</code> parameter)
are also generated in order to cover situations with only a few cell types
present. The proportion of simulated spots generated by each method can be
controlled using the <code>proportion.method</code> parameter. To visualize the
distribution of cell type proportions generated by each method, the
<code><a href="#topic+showProbPlot">showProbPlot</a></code> function can be used.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object with <code>prob.cell.types</code>
slot containing a <code>list</code> with two <code><a href="#topic+PropCellTypes-class">PropCellTypes</a></code>
objects (training and test). For more information about the structure of
this class, see <code>?<a href="#topic+PropCellTypes-class">PropCellTypes</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simMixedProfiles">simMixedProfiles</a></code> <code><a href="#topic+PropCellTypes-class">PropCellTypes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
sce &lt;- SingleCellExperiment::SingleCellExperiment(
  assays = list(
    counts = matrix(
      rpois(100, lambda = 5), nrow = 40, ncol = 30,
      dimnames = list(paste0("Gene", seq(40)), paste0("RHC", seq(30)))
    )
  ),
  colData = data.frame(
    Cell_ID = paste0("RHC", seq(30)),
    Cell_Type = sample(x = paste0("CellType", seq(4)), size = 30,
                       replace = TRUE)
  ),
  rowData = data.frame(
    Gene_ID = paste0("Gene", seq(40))
  )
)

SDDLS &lt;- createSpatialDDLSobject(
  sc.data = sce,
  sc.cell.ID.column = "Cell_ID",
  sc.gene.ID.column = "Gene_ID",
  sc.filt.genes.cluster = FALSE,
  project = "Simul_example"
)
SDDLS &lt;- genMixedCellProp(
  object = SDDLS,
  cell.ID.column = "Cell_ID",
  cell.type.column = "Cell_Type",
  num.sim.spots = 10,
  train.freq.cells = 2/3,
  train.freq.spots = 2/3,
  verbose = TRUE
)
  
</code></pre>

<hr>
<h2 id='getProbMatrix'>Getter function for the cell composition matrix</h2><span id='topic+getProbMatrix'></span>

<h3>Description</h3>

<p>Getter function for the cell composition matrix. This function allows to
access to the cell composition matrix of simulated mixed transcriptional
profiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getProbMatrix(object, type.data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getProbMatrix_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object with
<code>prob.cell.types</code> slot.</p>
</td></tr>
<tr><td><code id="getProbMatrix_+3A_type.data">type.data</code></td>
<td>
<p>Subset of data to return: <code>train</code> or <code>test</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Cell type proportion matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genMixedCellProp">genMixedCellProp</a></code>
</p>

<hr>
<h2 id='installTFpython'>Install Python dependencies for SpatialDDLS</h2><span id='topic+installTFpython'></span>

<h3>Description</h3>

<p>This function facilitates the installation of the required Python
dependencies for the <span class="pkg">SpatialDDLS</span> R package, as it requires a Python
interpreter with the TensorFlow Python library and its dependencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>installTFpython(
  conda = "auto",
  python.version = "3.8",
  tensorflow.version = "2.6",
  install.conda = FALSE,
  miniconda.path = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="installTFpython_+3A_conda">conda</code></td>
<td>
<p>Path to a conda executable. Using <code>"auto"</code> (by default)
allows <span class="pkg">reticulate</span> to automatically find an appropriate conda binary.</p>
</td></tr>
<tr><td><code id="installTFpython_+3A_python.version">python.version</code></td>
<td>
<p>Python version to be installed in the environment
(<code>"3.8"</code> by default). We recommend keeping this version as it has
been tested to be compatible with tensorflow 2.6.</p>
</td></tr>
<tr><td><code id="installTFpython_+3A_tensorflow.version">tensorflow.version</code></td>
<td>
<p>Tensorflow version to be installed in the
environment (<code>"2.6"</code> by default).</p>
</td></tr>
<tr><td><code id="installTFpython_+3A_install.conda">install.conda</code></td>
<td>
<p>Boolean indicating if installing miniconda automatically
by using <span class="pkg">reticulate</span>. If <code>TRUE</code>, <code>conda</code> argument is
ignored. <code>FALSE</code> by default.</p>
</td></tr>
<tr><td><code id="installTFpython_+3A_miniconda.path">miniconda.path</code></td>
<td>
<p>If <code>install.conda</code> is <code>TRUE</code>, you can set the
path where miniconda will be installed. If <code>NULL</code>, conda will find
automatically the proper place.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is intended to simplify the installation process for
<span class="pkg">SpatialDDLS</span> by automatically installing Miniconda and creating a new
environment named SpatialDDLS-env with all <span class="pkg">SpatialDDLS</span>' dependencies
covered. For users who wish to use a different Python or conda environment,
see the <code>tensorflow::use_condaenv</code> function for more information.
</p>


<h3>Value</h3>

<p>No return value, called for side effects: installation of conda
environment with a Python interpreter and Tensorflow
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
notesInstallation &lt;- installTFpython(
  conda = "auto", install.conda = TRUE
)

## End(Not run)

</code></pre>

<hr>
<h2 id='interGradientsDL'>Calculate gradients of predicted cell types/loss function with respect to
input features for interpreting trained deconvolution models</h2><span id='topic+interGradientsDL'></span>

<h3>Description</h3>

<p>This function enables users to gain insights into the interpretability of the
deconvolution model. It calculates the gradients of classes/loss function
with respect to the input features used in training. These numeric values are
calculated per gene and cell type in pure mixed transcriptional profiles,
providing information on the extent to which each feature influences the
model's prediction of cell proportions for each cell type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interGradientsDL(
  object,
  method = "class",
  normalize = TRUE,
  scaling = "standardize",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interGradientsDL_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object containing a trained
deconvolution model (<code>trained.model</code> slot) and pure mixed
transcriptional profiles (<code>mixed.profiles</code> slot).</p>
</td></tr>
<tr><td><code id="interGradientsDL_+3A_method">method</code></td>
<td>
<p>Method to calculate gradients with respect to inputs. It can be
<code>'class'</code> (gradients of predicted classes w.r.t. inputs),
<code>'loss'</code> (gradients of loss w.r.t. inputs) or <code>'both'</code>.</p>
</td></tr>
<tr><td><code id="interGradientsDL_+3A_normalize">normalize</code></td>
<td>
<p>Whether to normalize data using logCPM (<code>TRUE</code> by
default). This parameter is only considered when the method used to
simulate the mixed transcriptional profiles (<code>simMixedProfiles</code>
function) was <code>"AddRawCount"</code>. Otherwise, data were already
normalized. This parameter should be set according to the transformation
used to train the model.</p>
</td></tr>
<tr><td><code id="interGradientsDL_+3A_scaling">scaling</code></td>
<td>
<p>How to scale data. It can be: <code>"standardize"</code>
(values are centered around the mean with a unit standard deviation),
<code>"rescale"</code> (values are shifted and rescaled so that they end up
ranging between 0 and 1, by default) or <code>"none"</code> (no scaling is
performed). This parameter should be set according to the transformation
used to train the model.</p>
</td></tr>
<tr><td><code id="interGradientsDL_+3A_verbose">verbose</code></td>
<td>
<p>Show informative messages during the execution (<code>TRUE</code> by
default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Gradients of classes / loss function with respect to the input features are
calculated exclusively using pure mixed transcriptional profiles composed of
a single cell type. Consequently, these numbers can be interpreted as the
extent to which each feature is being used to predict each cell type
proportion. Gradients are calculated at the sample level for each gene, but
only mean gradients by cell type are reported. For additional details, see
Mañanes et al., 2023.
</p>


<h3>Value</h3>

<p>Object containing gradients in the <code>interpret.gradients</code> slot of
the <code>DeconvDLModel</code> object (<code>trained.model</code> slot).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+deconvSpatialDDLS">deconvSpatialDDLS</a></code> <code><a href="#topic+plotTrainingHistory">plotTrainingHistory</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
sce &lt;- SingleCellExperiment::SingleCellExperiment(
  assays = list(
    counts = matrix(
      rpois(30, lambda = 5), nrow = 15, ncol = 10,
      dimnames = list(paste0("Gene", seq(15)), paste0("RHC", seq(10)))
    )
  ),
  colData = data.frame(
    Cell_ID = paste0("RHC", seq(10)),
    Cell_Type = sample(x = paste0("CellType", seq(2)), size = 10,
                       replace = TRUE)
  ),
  rowData = data.frame(
    Gene_ID = paste0("Gene", seq(15))
  )
)
SDDLS &lt;- createSpatialDDLSobject(
  sc.data = sce,
  sc.cell.ID.column = "Cell_ID",
  sc.gene.ID.column = "Gene_ID",
  sc.filt.genes.cluster = FALSE
)
SDDLS &lt;- genMixedCellProp(
  object = SDDLS,
  cell.ID.column = "Cell_ID",
  cell.type.column = "Cell_Type",
  num.sim.spots = 50,
  train.freq.cells = 2/3,
  train.freq.spots = 2/3,
  verbose = TRUE
)
SDDLS &lt;- simMixedProfiles(SDDLS)
SDDLS &lt;- trainDeconvModel(
  object = SDDLS,
  batch.size = 12,
  num.epochs = 5
)
## calculating gradients
SDDLS &lt;- interGradientsDL(SDDLS)

  
</code></pre>

<hr>
<h2 id='loadSTProfiles'>Loads spatial transcriptomics data into a SpatialDDLS object</h2><span id='topic+loadSTProfiles'></span>

<h3>Description</h3>

<p>This function loads a <code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code>
object (or a list with several
<code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code> objects) into a
<code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadSTProfiles(
  object,
  st.data,
  st.spot.ID.column,
  st.gene.ID.column,
  st.min.counts = 0,
  st.min.spots = 0,
  st.n.slides = 3,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loadSTProfiles_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object.</p>
</td></tr>
<tr><td><code id="loadSTProfiles_+3A_st.data">st.data</code></td>
<td>
<p>A <code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code> object
(or a list with several <code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code>
objects) to be deconvoluted.</p>
</td></tr>
<tr><td><code id="loadSTProfiles_+3A_st.spot.id.column">st.spot.ID.column</code></td>
<td>
<p>Name or number of the column in spots metadata
corresponding to spot names in the expression matrix.</p>
</td></tr>
<tr><td><code id="loadSTProfiles_+3A_st.gene.id.column">st.gene.ID.column</code></td>
<td>
<p>Name or number of the column in genes metadata
corresponding to names used for features/genes.</p>
</td></tr>
<tr><td><code id="loadSTProfiles_+3A_st.min.counts">st.min.counts</code></td>
<td>
<p>Minimum gene counts to filter (0 by default).</p>
</td></tr>
<tr><td><code id="loadSTProfiles_+3A_st.min.spots">st.min.spots</code></td>
<td>
<p>Minimum of spots with more than <code>min.counts</code> (0 by
default).</p>
</td></tr>
<tr><td><code id="loadSTProfiles_+3A_st.n.slides">st.n.slides</code></td>
<td>
<p>Minimum number of slides
(<code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code> objects) in which a
gene has to be expressed in order to keep it. This parameter is applicable
only when multiple <code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code>
objects are provided. Genes not present in at least <code>st.n.slides</code> will
be discarded. If no filtering is desired, set <code>st.n.slides = 1</code>.</p>
</td></tr>
<tr><td><code id="loadSTProfiles_+3A_verbose">verbose</code></td>
<td>
<p>Show informative messages during execution (<code>TRUE</code> by
default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is recommended to perform this step when creating the
<code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object using the
<code><a href="#topic+createSpatialDDLSobject">createSpatialDDLSobject</a></code> function in order to only keep genes
shared between the spatial transcriptomics and the single-cell
transcriptomics data used as reference. In addition, please, make sure the
gene identifiers used the spatial and single-cell transcriptomics data are
consistent.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object with the provided spatial
trainscriptomics data loaded into the <code>spatial.experiments</code> slot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+createSpatialDDLSobject">createSpatialDDLSobject</a></code> <code><a href="#topic+trainDeconvModel">trainDeconvModel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
sce &lt;- SingleCellExperiment::SingleCellExperiment(
  assays = list(
    counts = matrix(
      rpois(100, lambda = 5), nrow = 40, ncol = 30,
      dimnames = list(paste0("Gene", seq(40)), paste0("RHC", seq(30)))
    )
  ),
  colData = data.frame(
    Cell_ID = paste0("RHC", seq(30)),
    Cell_Type = sample(x = paste0("CellType", seq(4)), size = 30,
                       replace = TRUE)
  ),
  rowData = data.frame(
    Gene_ID = paste0("Gene", seq(40))
  )
)
SDDLS &lt;- createSpatialDDLSobject(
  sc.data = sce,
  sc.cell.ID.column = "Cell_ID",
  sc.gene.ID.column = "Gene_ID",
  sc.filt.genes.cluster = FALSE
)

## simulating a SpatialExperiment object
counts &lt;- matrix(rpois(30, lambda = 5), ncol = 6)
rownames(counts) &lt;- paste0("Gene", 1:5)
colnames(counts) &lt;- paste0("Spot", 1:6)
coordinates &lt;- matrix(
  c(1, 2, 3, 1, 2, 3, 1, 2, 3, 1, 2, 3), ncol = 2
)
ste &lt;- SpatialExperiment::SpatialExperiment(
  assays = list(counts = as.matrix(counts)),
  rowData = data.frame(Gene_ID = paste0("Gene", 1:5)),
  colData = data.frame(Cell_ID = paste0("Spot", 1:6)),
  spatialCoords = coordinates
)

## previous SpatialDDLS object
SDDLS &lt;- loadSTProfiles(
  object = SDDLS,
  st.data = ste,
  st.spot.ID.column = "Cell_ID",
  st.gene.ID.column = "Gene_ID"
)

  
</code></pre>

<hr>
<h2 id='loadTrainedModelFromH5'>Load from an HDF5 file a trained deep neural network model into a
<code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object</h2><span id='topic+loadTrainedModelFromH5'></span>

<h3>Description</h3>

<p>Load from an HDF5 file a trained deep neural network model into a
<code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object. Note that HDF5 file must be a valid
trained model (<span class="pkg">keras</span> object).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadTrainedModelFromH5(object, file.path, reset.slot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loadTrainedModelFromH5_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object with
<code>trained.model</code> slot.</p>
</td></tr>
<tr><td><code id="loadTrainedModelFromH5_+3A_file.path">file.path</code></td>
<td>
<p>Valid file path where the model are stored.</p>
</td></tr>
<tr><td><code id="loadTrainedModelFromH5_+3A_reset.slot">reset.slot</code></td>
<td>
<p>Deletes <code>trained.slot</code> if it already exists. A new
<code><a href="#topic+DeconvDLModel">DeconvDLModel</a></code> object will be formed, but will not contain
other slots (<code>FALSE</code> by default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object with <code>trained.model</code>
slot with the new <span class="pkg">keras</span> DNN model incorporated.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trainDeconvModel">trainDeconvModel</a></code> <code><a href="#topic+saveTrainedModelAsH5">saveTrainedModelAsH5</a></code>
</p>

<hr>
<h2 id='method'>Get and set <code>method</code> slot in a <code><a href="#topic+PropCellTypes-class">PropCellTypes</a></code>
object</h2><span id='topic+method'></span><span id='topic+method+2CPropCellTypes-method'></span><span id='topic+method+3C-'></span><span id='topic+method+3C-+2CPropCellTypes-method'></span>

<h3>Description</h3>

<p>Get and set <code>method</code> slot in a <code><a href="#topic+PropCellTypes-class">PropCellTypes</a></code>
object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>method(object)

method(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="method_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+PropCellTypes-class">PropCellTypes</a></code> object.</p>
</td></tr>
<tr><td><code id="method_+3A_value">value</code></td>
<td>
<p>Vector containing the method by which cell type proportions were
generated.</p>
</td></tr>
</table>

<hr>
<h2 id='mixed.profiles'>Get and set <code>mixed.profiles</code> slot in a
<code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code> object</h2><span id='topic+mixed.profiles'></span><span id='topic+mixed.profiles+2CSpatialDDLS-method'></span><span id='topic+mixed.profiles+3C-'></span><span id='topic+mixed.profiles+3C-+2CSpatialDDLS-method'></span>

<h3>Description</h3>

<p>Get and set <code>mixed.profiles</code> slot in a
<code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixed.profiles(object, type.data = "both")

mixed.profiles(object, type.data = "both") &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mixed.profiles_+3A_object">object</code></td>
<td>
<p><code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code> object.</p>
</td></tr>
<tr><td><code id="mixed.profiles_+3A_type.data">type.data</code></td>
<td>
<p>Type of data to return. It can be <code>'both'</code> (default),
<code>'train'</code>, or <code>'test'</code>.</p>
</td></tr>
<tr><td><code id="mixed.profiles_+3A_value">value</code></td>
<td>
<p>List with two
<code><a href="SummarizedExperiment.html#topic+SummarizedExperiment">SummarizedExperiment</a></code> objects, train and
test, each one containing simulated mixed transcriptional profiles.</p>
</td></tr>
</table>

<hr>
<h2 id='model'>Get and set <code>model</code> slot in a <code><a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code>
object</h2><span id='topic+model'></span><span id='topic+model+2CDeconvDLModel-method'></span><span id='topic+model+3C-'></span><span id='topic+model+3C-+2CDeconvDLModel-method'></span>

<h3>Description</h3>

<p>Get and set <code>model</code> slot in a <code><a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code>
object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model(object)

model(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code> object.</p>
</td></tr>
<tr><td><code id="model_+3A_value">value</code></td>
<td>
<p><code>keras.engine.sequential.Sequential</code> object with a trained
deep neural network model.</p>
</td></tr>
</table>

<hr>
<h2 id='plotDistances'>Plot distances between intrinsic and extrinsic profiles</h2><span id='topic+plotDistances'></span>

<h3>Description</h3>

<p>Color spots on the spatial coordinates according to distances between
intrinsic and extrinsic transcriptional profiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDistances(
  object,
  index.st,
  mid.scale = "mean",
  size.point = 1,
  title = NULL,
  theme = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotDistances_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object.</p>
</td></tr>
<tr><td><code id="plotDistances_+3A_index.st">index.st</code></td>
<td>
<p>Index of the spatial transcriptomics data to be plotted. It
can be either a position or a name if a named list was provided.</p>
</td></tr>
<tr><td><code id="plotDistances_+3A_mid.scale">mid.scale</code></td>
<td>
<p>The midpoint of the diverging scale. it may be <code>'mean'</code>
or <code>'median'</code> (the former by default).</p>
</td></tr>
<tr><td><code id="plotDistances_+3A_size.point">size.point</code></td>
<td>
<p>Size of points (0.1 by default).</p>
</td></tr>
<tr><td><code id="plotDistances_+3A_title">title</code></td>
<td>
<p>Title of plot.</p>
</td></tr>
<tr><td><code id="plotDistances_+3A_theme">theme</code></td>
<td>
<p><span class="pkg">ggplot2</span> theme.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+deconvSpatialDDLS">deconvSpatialDDLS</a></code> <code><a href="#topic+trainDeconvModel">trainDeconvModel</a></code>
</p>

<hr>
<h2 id='plotHeatmapGradsAgg'>Plot a heatmap of gradients of classes / loss function wtih respect to the
input</h2><span id='topic+plotHeatmapGradsAgg'></span>

<h3>Description</h3>

<p>Plot a heatmap showing the top positive and negative gene average
gradients per cell type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotHeatmapGradsAgg(
  object,
  method = "class",
  top.n.genes = 15,
  scale.gradients = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotHeatmapGradsAgg_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object with a
<code><a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code> object containing gradients in the
<code>interpret.gradients</code> slot.</p>
</td></tr>
<tr><td><code id="plotHeatmapGradsAgg_+3A_method">method</code></td>
<td>
<p>Method to calculate gradients with respect to input features.
It can be
<code>'class'</code> (gradients of predicted classes w.r.t. input features) or
<code>'loss'</code> (gradients of loss w.r.t. input features) (<code>'class'</code> by
default).</p>
</td></tr>
<tr><td><code id="plotHeatmapGradsAgg_+3A_top.n.genes">top.n.genes</code></td>
<td>
<p>Top n genes (positive and negative) taken per cell type.</p>
</td></tr>
<tr><td><code id="plotHeatmapGradsAgg_+3A_scale.gradients">scale.gradients</code></td>
<td>
<p>Whether to calculate feature-wise z-scores of
gradients (<code>TRUE</code> by default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>Heatmap-class</code> objects, one for top
positive and another one for top negative gradients.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+interGradientsDL">interGradientsDL</a></code> <code><a href="#topic+trainDeconvModel">trainDeconvModel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
sce &lt;- SingleCellExperiment::SingleCellExperiment(
  assays = list(
    counts = matrix(
      rpois(30, lambda = 5), nrow = 15, ncol = 10,
      dimnames = list(paste0("Gene", seq(15)), paste0("RHC", seq(10)))
    )
  ),
  colData = data.frame(
    Cell_ID = paste0("RHC", seq(10)),
    Cell_Type = sample(x = paste0("CellType", seq(2)), size = 10,
                       replace = TRUE)
  ),
  rowData = data.frame(
    Gene_ID = paste0("Gene", seq(15))
  )
)
SDDLS &lt;- createSpatialDDLSobject(
  sc.data = sce,
  sc.cell.ID.column = "Cell_ID",
  sc.gene.ID.column = "Gene_ID",
  sc.filt.genes.cluster = FALSE
)
SDDLS &lt;- genMixedCellProp(
  object = SDDLS,
  cell.ID.column = "Cell_ID",
  cell.type.column = "Cell_Type",
  num.sim.spots = 50,
  train.freq.cells = 2/3,
  train.freq.spots = 2/3,
  verbose = TRUE
)
SDDLS &lt;- simMixedProfiles(SDDLS)
SDDLS &lt;- trainDeconvModel(
  object = SDDLS,
  batch.size = 12,
  num.epochs = 5
)
## calculating gradients
SDDLS &lt;- interGradientsDL(SDDLS)
plotHeatmapGradsAgg(SDDLS, top.n.genes = 2)

  
</code></pre>

<hr>
<h2 id='plots'>Get and set <code>plots</code> slot in a <code><a href="#topic+PropCellTypes-class">PropCellTypes</a></code>
object</h2><span id='topic+plots'></span><span id='topic+plots+2CPropCellTypes-method'></span><span id='topic+plots+3C-'></span><span id='topic+plots+3C-+2CPropCellTypes-method'></span>

<h3>Description</h3>

<p>Get and set <code>plots</code> slot in a <code><a href="#topic+PropCellTypes-class">PropCellTypes</a></code>
object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plots(object)

plots(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plots_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+PropCellTypes-class">PropCellTypes</a></code> object.</p>
</td></tr>
<tr><td><code id="plots_+3A_value">value</code></td>
<td>
<p>List of lists with plots showing the distribution of cell
proportions generated by each method.</p>
</td></tr>
</table>

<hr>
<h2 id='plotSpatialClustering'>Plot results of clustering based on predicted cell proportions</h2><span id='topic+plotSpatialClustering'></span>

<h3>Description</h3>

<p>Color spots on the spatial coordinates according to the results of
clustering based on predicted proportions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSpatialClustering(
  object,
  index.st,
  method,
  k.nn,
  k.centers,
  colors,
  size.point = 1,
  title = NULL,
  theme = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotSpatialClustering_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object.</p>
</td></tr>
<tr><td><code id="plotSpatialClustering_+3A_index.st">index.st</code></td>
<td>
<p>Index of the spatial transcriptomics data to be plotted. It
can be either a position or a name if a named list of
<code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code> objects was provided.</p>
</td></tr>
<tr><td><code id="plotSpatialClustering_+3A_method">method</code></td>
<td>
<p>Clustering method results to plot. It can be <code>"graph"</code> or
<code>"k.means"</code>. If missing, the first configuration found in the object
will be plotted.</p>
</td></tr>
<tr><td><code id="plotSpatialClustering_+3A_k.nn">k.nn</code></td>
<td>
<p>Number of nearest neighbors used if <code> method == "graph"</code>.</p>
</td></tr>
<tr><td><code id="plotSpatialClustering_+3A_k.centers">k.centers</code></td>
<td>
<p>Number of k centers used if <code> method == "k.means"</code>.</p>
</td></tr>
<tr><td><code id="plotSpatialClustering_+3A_colors">colors</code></td>
<td>
<p>Vector of colors to be used.</p>
</td></tr>
<tr><td><code id="plotSpatialClustering_+3A_size.point">size.point</code></td>
<td>
<p>Size of points (0.1 by default).</p>
</td></tr>
<tr><td><code id="plotSpatialClustering_+3A_title">title</code></td>
<td>
<p>Title of plot.</p>
</td></tr>
<tr><td><code id="plotSpatialClustering_+3A_theme">theme</code></td>
<td>
<p><span class="pkg">ggplot2</span> theme.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spatialPropClustering">spatialPropClustering</a></code> <code><a href="#topic+deconvSpatialDDLS">deconvSpatialDDLS</a></code>
</p>

<hr>
<h2 id='plotSpatialGeneExpr'>Plot normalized gene expression data (logCPM) in spatial coordinates</h2><span id='topic+plotSpatialGeneExpr'></span>

<h3>Description</h3>

<p>Color spots on the spatial coordinates according to the logCPM values of a
particular gene.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSpatialGeneExpr(
  object,
  index.st,
  gene,
  colors = "spectral",
  size.point = 1,
  title = NULL,
  theme = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotSpatialGeneExpr_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object.</p>
</td></tr>
<tr><td><code id="plotSpatialGeneExpr_+3A_index.st">index.st</code></td>
<td>
<p>Index of the spatial transcriptomics data to be plotted. It
can be either a position or a name if a named list of
<code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code> objects was provided.</p>
</td></tr>
<tr><td><code id="plotSpatialGeneExpr_+3A_gene">gene</code></td>
<td>
<p>Gene to color spots by.</p>
</td></tr>
<tr><td><code id="plotSpatialGeneExpr_+3A_colors">colors</code></td>
<td>
<p>Color scale to be used. It can be <code>"blues"</code> or
<code>"spectral"</code> (the latter by default).</p>
</td></tr>
<tr><td><code id="plotSpatialGeneExpr_+3A_size.point">size.point</code></td>
<td>
<p>Size of points (0.1 by default).</p>
</td></tr>
<tr><td><code id="plotSpatialGeneExpr_+3A_title">title</code></td>
<td>
<p>Title of plot.</p>
</td></tr>
<tr><td><code id="plotSpatialGeneExpr_+3A_theme">theme</code></td>
<td>
<p><span class="pkg">ggplot2</span> theme.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+interGradientsDL">interGradientsDL</a></code> <code><a href="#topic+topGradientsCellType">topGradientsCellType</a></code>
</p>

<hr>
<h2 id='plotSpatialProp'>Plot predicted proportions for a specific cell type using spatial coordinates
of spots</h2><span id='topic+plotSpatialProp'></span>

<h3>Description</h3>

<p>Color spots on the spatial coordinates according to the predicted proportions
of a particular cell type. Color scale is adapted depending on the range of
predicted proportions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSpatialProp(
  object,
  index.st,
  cell.type,
  colors = "blues",
  set = "raw",
  prediction = "Regularized",
  limits = NULL,
  size.point = 1,
  title = NULL,
  theme = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotSpatialProp_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object.</p>
</td></tr>
<tr><td><code id="plotSpatialProp_+3A_index.st">index.st</code></td>
<td>
<p>Index of the spatial transcriptomics data to be plotted. It
can be either a position or a name if a named list of
<code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code> objects was provided.</p>
</td></tr>
<tr><td><code id="plotSpatialProp_+3A_cell.type">cell.type</code></td>
<td>
<p>Cell type predicted proportions to color spots by.</p>
</td></tr>
<tr><td><code id="plotSpatialProp_+3A_colors">colors</code></td>
<td>
<p>Color scale to be used. It can be <code>"blues"</code> or
<code>"spectral"</code> (the former by default).</p>
</td></tr>
<tr><td><code id="plotSpatialProp_+3A_set">set</code></td>
<td>
<p>If results were simplified (see <code>?<a href="#topic+deconvSpatialDDLS">deconvSpatialDDLS</a></code>
for details), what results to plot (<code>raw</code> by default).</p>
</td></tr>
<tr><td><code id="plotSpatialProp_+3A_prediction">prediction</code></td>
<td>
<p>It can be <code>"Regularized"</code>, <code>"Intrinsic"</code> or
<code>"Extrinsic"</code> (<code>"Regularized"</code> by default).</p>
</td></tr>
<tr><td><code id="plotSpatialProp_+3A_limits">limits</code></td>
<td>
<p>A vector of two elements indicating wanted limits for color
scale. If <code>NULL</code> (by default), color scale is adjusted to max and min
predicted proportions.</p>
</td></tr>
<tr><td><code id="plotSpatialProp_+3A_size.point">size.point</code></td>
<td>
<p>Size of points (0.1 by default).</p>
</td></tr>
<tr><td><code id="plotSpatialProp_+3A_title">title</code></td>
<td>
<p>Title of plot.</p>
</td></tr>
<tr><td><code id="plotSpatialProp_+3A_theme">theme</code></td>
<td>
<p><span class="pkg">ggplot2</span> theme.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotSpatialPropAll">plotSpatialPropAll</a></code> <code><a href="#topic+deconvSpatialDDLS">deconvSpatialDDLS</a></code>
<code><a href="#topic+trainDeconvModel">trainDeconvModel</a></code>
</p>

<hr>
<h2 id='plotSpatialPropAll'>Plot predicted proportions for all cell types using spatial coordinates of
spots</h2><span id='topic+plotSpatialPropAll'></span>

<h3>Description</h3>

<p>Color spots on the spatial coordinates plot according to their predicted cell
type proportions. All cell types are represented together using the same
color scale from 0 to 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSpatialPropAll(
  object,
  index.st,
  colors = "blues",
  set = "raw",
  prediction = "Regularized",
  size.point = 0.1,
  title = NULL,
  nrow = NULL,
  ncol = NULL,
  theme = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotSpatialPropAll_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object.</p>
</td></tr>
<tr><td><code id="plotSpatialPropAll_+3A_index.st">index.st</code></td>
<td>
<p>Index of the spatial transcriptomics data to be plotted. It
can be either a position or a name if a named list of
<code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code> objects was provided.</p>
</td></tr>
<tr><td><code id="plotSpatialPropAll_+3A_colors">colors</code></td>
<td>
<p>Color scale to be used. It can be <code>"blues"</code> or
<code>"spectral"</code> (the former by default).</p>
</td></tr>
<tr><td><code id="plotSpatialPropAll_+3A_set">set</code></td>
<td>
<p>If results were simplified (see <code>?<a href="#topic+deconvSpatialDDLS">deconvSpatialDDLS</a></code>
for details), which results to plot (<code>raw</code> by default).</p>
</td></tr>
<tr><td><code id="plotSpatialPropAll_+3A_prediction">prediction</code></td>
<td>
<p>It can be <code>"Regularized"</code>, <code>"Intrinsic"</code> or
<code>"Extrinsic"</code> (<code>"Regularized"</code> by default).</p>
</td></tr>
<tr><td><code id="plotSpatialPropAll_+3A_size.point">size.point</code></td>
<td>
<p>Size of points (0.1 by default).</p>
</td></tr>
<tr><td><code id="plotSpatialPropAll_+3A_title">title</code></td>
<td>
<p>Title of plot.</p>
</td></tr>
<tr><td><code id="plotSpatialPropAll_+3A_nrow">nrow</code></td>
<td>
<p>Number of rows in the split plot.</p>
</td></tr>
<tr><td><code id="plotSpatialPropAll_+3A_ncol">ncol</code></td>
<td>
<p>Number of columns in the split plot.</p>
</td></tr>
<tr><td><code id="plotSpatialPropAll_+3A_theme">theme</code></td>
<td>
<p><span class="pkg">ggplot2</span> theme.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotSpatialProp">plotSpatialProp</a></code> <code><a href="#topic+deconvSpatialDDLS">deconvSpatialDDLS</a></code>
<code><a href="#topic+trainDeconvModel">trainDeconvModel</a></code>
</p>

<hr>
<h2 id='plotTrainingHistory'>Plot training history of a trained SpatialDDLS deep neural network model</h2><span id='topic+plotTrainingHistory'></span>

<h3>Description</h3>

<p>Plot training history of a trained SpatialDDLS deep neural network model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotTrainingHistory(
  object,
  title = "History of metrics during training",
  metrics = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotTrainingHistory_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object with a
<code>trained.model</code> slot.</p>
</td></tr>
<tr><td><code id="plotTrainingHistory_+3A_title">title</code></td>
<td>
<p>Title of plot.</p>
</td></tr>
<tr><td><code id="plotTrainingHistory_+3A_metrics">metrics</code></td>
<td>
<p>Metrics to be plotted. If <code>NULL</code> (by default), all
metrics available in the <code><a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code> object will be
plotted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object with the progression of the selected metrics during
training.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trainDeconvModel">trainDeconvModel</a></code>
</p>

<hr>
<h2 id='preparingToSave'>Prepare <code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object to be saved as an RDA file</h2><span id='topic+preparingToSave'></span>

<h3>Description</h3>

<p>This function prepares a <code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object to be saved
as an RDA file when contains a <code><a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code> object with
a trained DNN model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preparingToSave(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="preparingToSave_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object with a
<code>trained.data</code> slot containing a <code><a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code>
object with a trained DNN model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since <span class="pkg">keras</span> models cannot be saved natively as R objects, this function
saves the structure of the model as a JSON-like character object and its
weights as a list. This allows for the retrieval of the model and making
predictions. It is important to note that the state of the optimizer is not
saved, only the model's architecture and weights. To save the entire model,
please see the <code><a href="#topic+saveTrainedModelAsH5">saveTrainedModelAsH5</a></code> and
<code><a href="#topic+loadTrainedModelFromH5">loadTrainedModelFromH5</a></code> functions.
</p>
<p>It is also possible to save a <code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object as an
RDS file with the <code>saveRDS</code> function without any preparation.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> or
<code><a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code> object with its trained keras model
transformed from a <code>keras.engine.sequential.Sequential</code> class into a
<code>list</code> with its architecture as a JSON-like character object, and its
weights as a list.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+saveRDS">saveRDS</a></code> <code><a href="#topic+saveTrainedModelAsH5">saveTrainedModelAsH5</a></code>
</p>

<hr>
<h2 id='prob.cell.types'>Get and set <code>prob.cell.types</code> slot in a
<code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code> object</h2><span id='topic+prob.cell.types'></span><span id='topic+prob.cell.types+2CSpatialDDLS-method'></span><span id='topic+prob.cell.types+3C-'></span><span id='topic+prob.cell.types+3C-+2CSpatialDDLS-method'></span>

<h3>Description</h3>

<p>Get and set <code>prob.cell.types</code> slot in a
<code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prob.cell.types(object, type.data = "both")

prob.cell.types(object, type.data = "both") &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prob.cell.types_+3A_object">object</code></td>
<td>
<p><code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code> object.</p>
</td></tr>
<tr><td><code id="prob.cell.types_+3A_type.data">type.data</code></td>
<td>
<p>Type of data to return. It can be <code>'both'</code> (default),
<code>'train'</code>, or <code>'test'</code>.</p>
</td></tr>
<tr><td><code id="prob.cell.types_+3A_value">value</code></td>
<td>
<p>List with two <code><a href="#topic+PropCellTypes-class">PropCellTypes</a></code> objects
corresponding to train and test data.</p>
</td></tr>
</table>

<hr>
<h2 id='prob.matrix'>Get and set <code>prob.matrix</code> slot in a
<code><a href="#topic+PropCellTypes-class">PropCellTypes</a></code> object</h2><span id='topic+prob.matrix'></span><span id='topic+prob.matrix+2CPropCellTypes-method'></span><span id='topic+prob.matrix+3C-'></span><span id='topic+prob.matrix+3C-+2CPropCellTypes-method'></span>

<h3>Description</h3>

<p>Get and set <code>prob.matrix</code> slot in a
<code><a href="#topic+PropCellTypes-class">PropCellTypes</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prob.matrix(object)

prob.matrix(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prob.matrix_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+PropCellTypes-class">PropCellTypes</a></code> object.</p>
</td></tr>
<tr><td><code id="prob.matrix_+3A_value">value</code></td>
<td>
<p>Matrix with cell types as columns and samples as rows.</p>
</td></tr>
</table>

<hr>
<h2 id='project'>Get and set <code>project</code> slot in a
<code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code> object</h2><span id='topic+project'></span><span id='topic+project+2CSpatialDDLS-method'></span><span id='topic+project+3C-'></span><span id='topic+project+3C-+2CSpatialDDLS-method'></span>

<h3>Description</h3>

<p>Get and set <code>project</code> slot in a
<code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>project(object)

project(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="project_+3A_object">object</code></td>
<td>
<p><code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code> object.</p>
</td></tr>
<tr><td><code id="project_+3A_value">value</code></td>
<td>
<p>Character indicating the name of the project.</p>
</td></tr>
</table>

<hr>
<h2 id='PropCellTypes-class'>The PropCellTypes Class</h2><span id='topic+PropCellTypes-class'></span><span id='topic+PropCellTypes'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+PropCellTypes-class">PropCellTypes</a></code> class is a data storage class which
contains information related to cell type composition matrices used to
simulate mixed transcriptional profiles. This matrix is stored in the
<code>prob.matrix</code> slot while the other slots contain additional information
generated during the process and required for subsequent steps.
</p>


<h3>Details</h3>

<p>See <code>?<a href="#topic+genMixedCellProp">genMixedCellProp</a></code> function for information about how cell
type composition matrices are generated. Plots of cell type proportion
distributions can be accessed using the <code><a href="#topic+showProbPlot">showProbPlot</a></code> function
(see <code>?<a href="#topic+showProbPlot">showProbPlot</a></code> for more details).
</p>


<h3>Slots</h3>


<dl>
<dt><code>prob.matrix</code></dt><dd><p>Matrix of cell type proportions to simulate mixed
transcriptional profiles.</p>
</dd>
<dt><code>cell.names</code></dt><dd><p>Matrix containing cells used to generate the simulated
mixed transcriptional profiles.</p>
</dd>
<dt><code>set.list</code></dt><dd><p>List of cells sorted by cell type.</p>
</dd>
<dt><code>set</code></dt><dd><p>Vector containing cell names present in the object.</p>
</dd>
<dt><code>method</code></dt><dd><p>Vector indicating the method by which cell type proportions were
generated.</p>
</dd>
<dt><code>plots</code></dt><dd><p>Plots showing cell type proportion distributions. See
<code>?<a href="#topic+showProbPlot">showProbPlot</a></code> for more details.</p>
</dd>
<dt><code>type.data</code></dt><dd><p>Character indicating the type of data contained:
<code>'train'</code> or <code>'test'</code>.</p>
</dd>
</dl>

<hr>
<h2 id='saveRDS'>Save <code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code> objects as RDS files</h2><span id='topic+saveRDS'></span><span id='topic+saveRDS+2CsaveRDS-method'></span><span id='topic+saveRDS+2CDeconvDLModel-method'></span><span id='topic+saveRDS+2CSpatialDDLS-method'></span>

<h3>Description</h3>

<p>Save <code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code> and
<code><a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code> objects as RDS files. <span class="pkg">keras</span> models
cannot be stored natively as R objects (e.g. RData or RDS files). By saving
the architecture as a JSON-like character object and the weights as a list,
it is possible to retrieve a functional model and make new predictions. If
the <code>trained.model</code> slot is empty, the function will behave as usual.
<strong>Note:</strong> with this option, the state of optimizer is not saved, only
model's architecture and weights. It is possible to save the entire model as
an HDF5 file with the <code><a href="#topic+saveTrainedModelAsH5">saveTrainedModelAsH5</a></code> function and load it
into a <code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code> object with the
<code><a href="#topic+loadTrainedModelFromH5">loadTrainedModelFromH5</a></code> function. See documentation for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveRDS(
  object,
  file,
  ascii = FALSE,
  version = NULL,
  compress = TRUE,
  refhook = NULL
)

## S4 method for signature 'DeconvDLModel'
saveRDS(
  object,
  file,
  ascii = FALSE,
  version = NULL,
  compress = TRUE,
  refhook = NULL
)

## S4 method for signature 'SpatialDDLS'
saveRDS(
  object,
  file,
  ascii = FALSE,
  version = NULL,
  compress = TRUE,
  refhook = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="saveRDS_+3A_object">object</code></td>
<td>
<p><code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code> or
<code><a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code> object to be saved</p>
</td></tr>
<tr><td><code id="saveRDS_+3A_file">file</code></td>
<td>
<p>File path where the object will be saved</p>
</td></tr>
<tr><td><code id="saveRDS_+3A_ascii">ascii</code></td>
<td>
<p>a logical.  If <code>TRUE</code> or <code>NA</code>, an ASCII
representation is written; otherwise (default), a binary one is used.
See the comments in the help for <code><a href="base.html#topic+save">save</a></code>.</p>
</td></tr>
<tr><td><code id="saveRDS_+3A_version">version</code></td>
<td>
<p>the workspace format version to use.  <code>NULL</code>
specifies the current default version (3). The only other supported
value is 2, the default from <span class="rlang"><b>R</b></span> 1.4.0 to <span class="rlang"><b>R</b></span> 3.5.0.</p>
</td></tr>
<tr><td><code id="saveRDS_+3A_compress">compress</code></td>
<td>
<p>a logical specifying whether saving to a named file is
to use <code>"gzip"</code> compression, or one of <code>"gzip"</code>,
<code>"bzip2"</code> or <code>"xz"</code> to indicate the type of compression to
be used.  Ignored if <code>file</code> is a connection.</p>
</td></tr>
<tr><td><code id="saveRDS_+3A_refhook">refhook</code></td>
<td>
<p>a hook function for handling reference objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, saves a
<code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code> object as an RDS file on
disk.
</p>


<h3>See Also</h3>

<p><code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code>
<code><a href="#topic+saveTrainedModelAsH5">saveTrainedModelAsH5</a></code>
</p>

<hr>
<h2 id='saveTrainedModelAsH5'>Save a trained <code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> deep neural network model to
disk as an HDF5 file</h2><span id='topic+saveTrainedModelAsH5'></span>

<h3>Description</h3>

<p>Save a trained <code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> deep neural network model to
disk as an HDF5 file. Note that this function does not save the
<code><a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code> object, only the trained <span class="pkg">keras</span>
model. This is the alternative to the <code><a href="#topic+saveRDS">saveRDS</a></code> and
<code><a href="#topic+preparingToSave">preparingToSave</a></code> functions if you want to keep the state of the
optimizer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveTrainedModelAsH5(object, file.path, overwrite = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="saveTrainedModelAsH5_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object with
<code>trained.model</code> slot.</p>
</td></tr>
<tr><td><code id="saveTrainedModelAsH5_+3A_file.path">file.path</code></td>
<td>
<p>Valid file path where to save the model to.</p>
</td></tr>
<tr><td><code id="saveTrainedModelAsH5_+3A_overwrite">overwrite</code></td>
<td>
<p>Overwrite file if it already exists.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, saves a <span class="pkg">keras</span> DNN trained model as HDF5 file
on disk.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trainDeconvModel">trainDeconvModel</a></code> <code><a href="#topic+loadTrainedModelFromH5">loadTrainedModelFromH5</a></code>
</p>

<hr>
<h2 id='set'>Get and set <code>set</code> slot in a <code><a href="#topic+PropCellTypes-class">PropCellTypes</a></code>
object</h2><span id='topic+set'></span><span id='topic+set+2CPropCellTypes-method'></span><span id='topic+set+3C-'></span><span id='topic+set+3C-+2CPropCellTypes-method'></span>

<h3>Description</h3>

<p>Get and set <code>set</code> slot in a <code><a href="#topic+PropCellTypes-class">PropCellTypes</a></code>
object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set(object)

set(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+PropCellTypes-class">PropCellTypes</a></code> object.</p>
</td></tr>
<tr><td><code id="set_+3A_value">value</code></td>
<td>
<p>A vector containing the names of cells that are present in the
object.</p>
</td></tr>
</table>

<hr>
<h2 id='set.list'>Get and set <code>set.list</code> slot in a
<code><a href="#topic+PropCellTypes-class">PropCellTypes</a></code> object</h2><span id='topic+set.list'></span><span id='topic+set.list+2CPropCellTypes-method'></span><span id='topic+set.list+3C-'></span><span id='topic+set.list+3C-+2CPropCellTypes-method'></span>

<h3>Description</h3>

<p>Get and set <code>set.list</code> slot in a
<code><a href="#topic+PropCellTypes-class">PropCellTypes</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.list(object)

set.list(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set.list_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+PropCellTypes-class">PropCellTypes</a></code> object.</p>
</td></tr>
<tr><td><code id="set.list_+3A_value">value</code></td>
<td>
<p>List of cells sorted by their corresponding cell type.</p>
</td></tr>
</table>

<hr>
<h2 id='showProbPlot'>Show distribution plots of the cell proportions generated by
<code><a href="#topic+genMixedCellProp">genMixedCellProp</a></code></h2><span id='topic+showProbPlot'></span>

<h3>Description</h3>

<p>Show distribution plots of the cell proportions generated by the
<code><a href="#topic+genMixedCellProp">genMixedCellProp</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showProbPlot(object, type.data, set, type.plot = "boxplot")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="showProbPlot_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object with
<code>prob.cell.types</code> slot with <code>plot</code> slot.</p>
</td></tr>
<tr><td><code id="showProbPlot_+3A_type.data">type.data</code></td>
<td>
<p>Subset of data to show: <code>train</code> or <code>test</code>.</p>
</td></tr>
<tr><td><code id="showProbPlot_+3A_set">set</code></td>
<td>
<p>Integer determining which of the 6 different subsets to display.</p>
</td></tr>
<tr><td><code id="showProbPlot_+3A_type.plot">type.plot</code></td>
<td>
<p>Character determining which type of visualization to
display. It can be <code>'boxplot'</code>, <code>'violinplot'</code>,
<code>'linesplot'</code> or <code>'ncelltypes'</code>. See Description for more
information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These frequencies will determine the proportion of different cell types used
during the simulation of mixed transcriptional profiles. Proportions
generated by each method (see <code>?<a href="#topic+genMixedCellProp">genMixedCellProp</a></code>) can be
visualized in three ways: box plots, violin plots, and lines plots. You can
also plot the probabilities based on the number of different cell types
present in the samples by setting <code>type.plot = 'nCellTypes'</code>.
</p>


<h3>Value</h3>

<p>A ggplot object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genMixedCellProp">genMixedCellProp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
sce &lt;- SingleCellExperiment::SingleCellExperiment(
  assays = list(
    counts = matrix(
      rpois(100, lambda = 5), nrow = 40, ncol = 30,
      dimnames = list(paste0("Gene", seq(40)), paste0("RHC", seq(30)))
    )
  ),
  colData = data.frame(
    Cell_ID = paste0("RHC", seq(30)),
    Cell_Type = sample(x = paste0("CellType", seq(4)), size = 30,
                       replace = TRUE)
  ),
  rowData = data.frame(
    Gene_ID = paste0("Gene", seq(40))
  )
)

SDDLS &lt;- createSpatialDDLSobject(
  sc.data = sce,
  sc.cell.ID.column = "Cell_ID",
  sc.gene.ID.column = "Gene_ID",
  project = "Simul_example",
  sc.filt.genes.cluster = FALSE
)
SDDLS &lt;- genMixedCellProp(
  object = SDDLS,
  cell.ID.column = "Cell_ID",
  cell.type.column = "Cell_Type",
  num.sim.spots = 10, 
  train.freq.cells = 2/3,
  train.freq.spots = 2/3,
  verbose = TRUE
)
showProbPlot(
   SDDLS,
   type.data = "train",
   set = 1,
   type.plot = "boxplot"
 )
 
</code></pre>

<hr>
<h2 id='simMixedProfiles'>Simulate training and test mixed spot profiles</h2><span id='topic+simMixedProfiles'></span>

<h3>Description</h3>

<p>Simulate training and test mixed spot transcriptional profiles using cell
composition matrices generated by the <code><a href="#topic+genMixedCellProp">genMixedCellProp</a></code>
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simMixedProfiles(
  object,
  type.data = "both",
  mixing.function = "AddRawCount",
  file.backend = NULL,
  compression.level = NULL,
  block.processing = FALSE,
  block.size = 1000,
  chunk.dims = NULL,
  threads = 1,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simMixedProfiles_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object with
<code>single.cell.real</code>/<code>single.cell.simul</code>, and
<code>prob.cell.types</code> slots.</p>
</td></tr>
<tr><td><code id="simMixedProfiles_+3A_type.data">type.data</code></td>
<td>
<p>Type of data to generate: <code>'train'</code>, <code>'test'</code> or
<code>'both'</code> (the last by default).</p>
</td></tr>
<tr><td><code id="simMixedProfiles_+3A_mixing.function">mixing.function</code></td>
<td>
<p>Function used to build mixed transcriptional profiles.
It may be: </p>
  <ul>
<li> <p><code>"AddRawCount"</code>: single-cell profiles (raw
counts) are added up across cells. Then, log-CPMs are calculated (by
default). </p>
</li>
<li> <p><code>"MeanCPM"</code>: single-cell profiles (raw counts) are
transformed into CPMs and cross-cell averages are calculated. Then,
<code>log2(CPM + 1)</code> is calculated. </p>
</li>
<li> <p><code>"AddCPM"</code>: single-cell
profiles (raw counts) are transformed into CPMs and are added up across
cells. Then, log-CPMs are calculated.</p>
</li></ul>
</td></tr>
<tr><td><code id="simMixedProfiles_+3A_file.backend">file.backend</code></td>
<td>
<p>Valid file path to store simulated mixed expression
profiles as an HDF5 file (<code>NULL</code> by default). If provided, data are
stored in HDF5 files used as back-end by using the <span class="pkg">DelayedArray</span>,
<span class="pkg">HDF5Array</span> and <span class="pkg">rhdf5</span> packages instead of loading all data into
RAM. Note that operations on this matrix will be performed in blocks (i.e
subsets of determined size) which may result in longer execution times.</p>
</td></tr>
<tr><td><code id="simMixedProfiles_+3A_compression.level">compression.level</code></td>
<td>
<p>The compression level used if <code>file.backend</code> is
provided. It is an integer value between 0 (no compression) and 9 (highest
and slowest compression). See
<code>?<a href="HDF5Array.html#topic+getHDF5DumpCompressionLevel">getHDF5DumpCompressionLevel</a></code> from the
<span class="pkg">HDF5Array</span> package for more information.</p>
</td></tr>
<tr><td><code id="simMixedProfiles_+3A_block.processing">block.processing</code></td>
<td>
<p>Boolean indicating whether data should be simulated
in blocks (only if <code>file.backend</code> is used, <code>FALSE</code> by default).
This functionality is suitable for cases where it is not possible to load
all data into memory, and it leads to longer execution times.</p>
</td></tr>
<tr><td><code id="simMixedProfiles_+3A_block.size">block.size</code></td>
<td>
<p>Only if <code>block.processing = TRUE</code>. Number of mixed
expression profiles that will be simulated in each iteration. Larger
numbers result in higher memory usage but shorter execution times. Set
accordingly to available computational resources (1000 by default).</p>
</td></tr>
<tr><td><code id="simMixedProfiles_+3A_chunk.dims">chunk.dims</code></td>
<td>
<p>Specifies the dimensions that HDF5 chunk will have. If
<code>NULL</code>, the default value is a vector of two items: the number of
genes considered by <code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object during the
simulation, and a single sample to reduce read times in the following
steps. A larger number of columns written in each chunk can lead to longer
read times.</p>
</td></tr>
<tr><td><code id="simMixedProfiles_+3A_threads">threads</code></td>
<td>
<p>Number of threads used during simulation (1 by default).</p>
</td></tr>
<tr><td><code id="simMixedProfiles_+3A_verbose">verbose</code></td>
<td>
<p>Show informative messages during the execution (<code>TRUE</code> by
default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mixed profiles are generated under the assumption that the expression level
of a particular gene in a given spot is the sum of the expression levels of
the cell types that make it up weighted by their proportions. In practice, as
described in Torroja and Sanchez-Cabo, 2019, these profiles are generated by
summing gene expression levels of a determined number of cells specified by a
known cell composition matrix. The number of simulated spots and cells used
to simulate each spot are determined by the <code><a href="#topic+genMixedCellProp">genMixedCellProp</a></code>
function. This step can be avoided by using the <code>on.the.fly</code> argument in
the <code><a href="#topic+trainDeconvModel">trainDeconvModel</a></code> function.
</p>
<p><span class="pkg">SpatialDDLS</span> allows to use HDF5 files as back-end to store simulated
data using the <span class="pkg">DelayedArray</span> and <span class="pkg">HDF5Array</span> packages. This
functionality allows to work without keeping the data loaded into RAM, which
could be useful during some computationally heavy steps such as neural
network training on RAM-limited machines. You must provide a valid file path
in the <code>file.backend</code> argument to store the resulting file with the
'.h5' extension. This option slows down execution times, as subsequent
transformations of the data will be done in blocks. Note that if you use the
<code>file.backend</code> argument with <code>block.processing = FALSE</code>, all mixed
profiles will be simulated in one step and, thus, loaded into RAM. Then, the
matrix will be written to an HDF5 file. To avoid the RAM collapse, these
profiles can be simulated and written to HDF5 files in blocks of
<code>block.size</code> size by setting <code>block.processing = TRUE</code>. We
recommend this option accordingly to the computational resources available
and the number of simulated spots to be generated, but, in most of the cases,
it is not necessary.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object with <code>mixed.profiles</code>
slot containing a list with one or two entries (depending on selected
<code>type.data</code> argument): <code>'train'</code> and <code>'test'</code>. Each entry
consists of a
<code><a href="SummarizedExperiment.html#topic+SummarizedExperiment">SummarizedExperiment</a></code>
object with the simulated mixed slot profiles.
</p>


<h3>References</h3>

<p>Fischer B, Smith M and Pau, G (2020). rhdf5: R Interface to HDF5.
R package version 2.34.0.
</p>
<p>Pagès H, Hickey P and Lun A (2020). DelayedArray: A unified framework for
working transparently with on-disk and in-memory array-like datasets. R
package version 0.16.0.
</p>
<p>Pagès H (2020). HDF5Array: HDF5 backend for DelayedArray objects. R package
version 1.18.0.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genMixedCellProp">genMixedCellProp</a></code> <code><a href="#topic+PropCellTypes-class">PropCellTypes</a></code>
<code><a href="#topic+trainDeconvModel">trainDeconvModel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
sce &lt;- SingleCellExperiment::SingleCellExperiment(
  assays = list(
    counts = matrix(
      rpois(100, lambda = 5), nrow = 40, ncol = 30,
      dimnames = list(paste0("Gene", seq(40)), paste0("RHC", seq(30)))
    )
  ),
  colData = data.frame(
    Cell_ID = paste0("RHC", seq(30)),
    Cell_Type = sample(x = paste0("CellType", seq(4)), size = 30,
                       replace = TRUE)
  ),
  rowData = data.frame(
    Gene_ID = paste0("Gene", seq(40))
  )
)

SDDLS &lt;- createSpatialDDLSobject(
  sc.data = sce,
  sc.cell.ID.column = "Cell_ID",
  sc.gene.ID.column = "Gene_ID",
  sc.filt.genes.cluster = FALSE,
  project = "Simul_example"
)
SDDLS &lt;- genMixedCellProp(
  object = SDDLS,
  cell.ID.column = "Cell_ID",
  cell.type.column = "Cell_Type",
  num.sim.spots = 10,
  train.freq.cells = 2/3,
  train.freq.spots = 2/3,
  verbose = TRUE
)
SDDLS &lt;- simMixedProfiles(SDDLS, verbose = TRUE)

</code></pre>

<hr>
<h2 id='simSCProfiles'>Simulate new single-cell RNA-Seq expression profiles using the ZINB-WaVE
model parameters</h2><span id='topic+simSCProfiles'></span>

<h3>Description</h3>

<p>Simulate single-cell expression profiles by randomly sampling from a negative
binomial distribution and inserting dropouts by sampling from a binomial
distribution using the ZINB-WaVE parameters estimated by the
<code><a href="#topic+estimateZinbwaveParams">estimateZinbwaveParams</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simSCProfiles(
  object,
  cell.ID.column,
  cell.type.column,
  n.cells,
  suffix.names = "_Simul",
  cell.types = NULL,
  file.backend = NULL,
  name.dataset.backend = NULL,
  compression.level = NULL,
  block.processing = FALSE,
  block.size = 1000,
  chunk.dims = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simSCProfiles_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object with
<code>single.cell.real</code> and <code>zinb.params</code> slots.</p>
</td></tr>
<tr><td><code id="simSCProfiles_+3A_cell.id.column">cell.ID.column</code></td>
<td>
<p>Name or column number corresponding to the cell names
of expression matrix in cells metadata.</p>
</td></tr>
<tr><td><code id="simSCProfiles_+3A_cell.type.column">cell.type.column</code></td>
<td>
<p>Name or column number corresponding to the cell type
of each cell in cells metadata.</p>
</td></tr>
<tr><td><code id="simSCProfiles_+3A_n.cells">n.cells</code></td>
<td>
<p>Number of simulated cells generated per cell type (i.e. if you
have 10 different cell types in your dataset, if <code>n.cells = 100</code>, then
1000 cell profiles will be simulated).</p>
</td></tr>
<tr><td><code id="simSCProfiles_+3A_suffix.names">suffix.names</code></td>
<td>
<p>Suffix used on simulated cells. This suffix must be
unique in the simulated cells, so make sure that this suffix does not
appear in the real cell names.</p>
</td></tr>
<tr><td><code id="simSCProfiles_+3A_cell.types">cell.types</code></td>
<td>
<p>Vector indicating the cell types to simulate. If
<code>NULL</code> (by default), <code>n.cells</code> single-cell profiles for all cell
types will be simulated.</p>
</td></tr>
<tr><td><code id="simSCProfiles_+3A_file.backend">file.backend</code></td>
<td>
<p>Valid file path to store the simulated single-cell
expression profiles as an HDF5 file (<code>NULL</code> by default). If provided,
the data are stored in HDF5 files used as back-end by using the
<span class="pkg">DelayedArray</span>, <span class="pkg">HDF5Array</span> and <span class="pkg">rhdf5</span> packages instead of
loading all data into RAM memory. This is suitable for situations where you
have large amounts of data that cannot be loaded into memory. Note that
operations on this data will be performed in blocks (i.e subsets of
determined size) which may result in longer execution times.</p>
</td></tr>
<tr><td><code id="simSCProfiles_+3A_name.dataset.backend">name.dataset.backend</code></td>
<td>
<p>Name of the dataset in HDF5 file to be used. Note
that it cannot exist. If <code>NULL</code> (by default), a random dataset name
will be used.</p>
</td></tr>
<tr><td><code id="simSCProfiles_+3A_compression.level">compression.level</code></td>
<td>
<p>The compression level used if <code>file.backend</code> is
provided. It is an integer value between 0 (no compression) and 9 (highest
and slowest compression). See
<code>?<a href="HDF5Array.html#topic+getHDF5DumpCompressionLevel">getHDF5DumpCompressionLevel</a></code> from the
<span class="pkg">HDF5Array</span> package for more information.</p>
</td></tr>
<tr><td><code id="simSCProfiles_+3A_block.processing">block.processing</code></td>
<td>
<p>Boolean indicating whether the data should be
simulated in blocks (only if <code>file.backend</code> is used, <code>FALSE</code> by
default). This functionality is suitable for cases where is not possible to
load all data into memory and it leads to larger execution times.</p>
</td></tr>
<tr><td><code id="simSCProfiles_+3A_block.size">block.size</code></td>
<td>
<p>Only if <code>block.processing = TRUE</code>. Number of
single-cell expression profiles that will be simulated in each iteration
during the process. Larger numbers result in higher memory usage but
shorter execution times. Set according to available computational resources
(1000 by default). Note that it cannot be greater than the total number of
simulated cells.</p>
</td></tr>
<tr><td><code id="simSCProfiles_+3A_chunk.dims">chunk.dims</code></td>
<td>
<p>Specifies the dimensions that HDF5 chunk will have. If
<code>NULL</code>, the default value is a vector of two items: the number of
genes considered by the ZINB-WaVE model during the simulation and a single
sample in order to reduce read times in the following steps. A larger
number of columns written in each chunk can lead to longer read times in
subsequent steps. Note that it cannot be greater than the dimensions of the
simulated matrix.</p>
</td></tr>
<tr><td><code id="simSCProfiles_+3A_verbose">verbose</code></td>
<td>
<p>Show informative messages during the execution (<code>TRUE</code> by
default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Before this step, see <code>?<a href="#topic+estimateZinbwaveParams">estimateZinbwaveParams</a></code>. As described in
Torroja and Sanchez-Cabo, 2019, this function simulates a given number of
transcriptional profiles for each cell type provided by randomly sampling
from a negative binomial distribution with <code class="reqn">\mu</code> and <code class="reqn">\theta</code>
estimated parameters and inserting dropouts by sampling from a binomial
distribution with probability pi. All parameters are estimated from
single-cell real data using the <code><a href="#topic+estimateZinbwaveParams">estimateZinbwaveParams</a></code>
function. It uses the ZINB-WaVE model (Risso et al., 2018). For more details
about the model, see <code>?<a href="#topic+estimateZinbwaveParams">estimateZinbwaveParams</a></code> and Risso et al.,
2018.
</p>
<p>The <code>file.backend</code> argument allows to create a HDF5 file with simulated
single-cell profiles to be used as back-end to work with data stored on disk
instead of loaded into RAM. If the <code>file.backend</code> argument is used with
<code>block.processing = FALSE</code>, all the single-cell profiles will be
simulated in one step and, therefore, loaded into in RAM memory. Then, data
will be written in HDF5 file. To avoid to collapse RAM memory if too many
single-cell profiles are goin to be simulated, single-cell profiles can be
simulated and written to HDF5 files in blocks of <code>block.size</code> size by
setting <code>block.processing = TRUE</code>.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object with
<code>single.cell.simul</code> slot containing a
<code><a href="SingleCellExperiment.html#topic+SingleCellExperiment">SingleCellExperiment</a></code>
object with the simulated single-cell expression profiles.
</p>


<h3>References</h3>

<p>Risso, D., Perraudeau, F., Gribkova, S. et al. (2018). A general
and flexible method for signal extraction from single-cell RNA-seq data.
Nat Commun 9, 284. doi: <a href="https://doi.org/10.1038/s41467-017-02554-5">doi:10.1038/s41467-017-02554-5</a>.
</p>
<p>Torroja, C. and Sánchez-Cabo, F. (2019). digitalDLSorter: A Deep Learning
algorithm to quantify immune cell populations based on scRNA-Seq data.
Frontiers in Genetics 10, 978. doi: <a href="https://doi.org/10.3389/fgene.2019.00978">doi:10.3389/fgene.2019.00978</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimateZinbwaveParams">estimateZinbwaveParams</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123) # reproducibility
sce &lt;- SingleCellExperiment::SingleCellExperiment(
  assays = list(
    counts = matrix(
      rpois(30, lambda = 5), nrow = 15, ncol = 10,
      dimnames = list(paste0("Gene", seq(15)), paste0("RHC", seq(10)))
    )
  ),
  colData = data.frame(
    Cell_ID = paste0("RHC", seq(10)),
    Cell_Type = sample(x = paste0("CellType", seq(2)), size = 10,
                       replace = TRUE)
  ),
  rowData = data.frame(
    Gene_ID = paste0("Gene", seq(15))
  )
)
SDDLS &lt;- createSpatialDDLSobject(
  sc.data = sce,
  sc.cell.ID.column = "Cell_ID",
  sc.gene.ID.column = "Gene_ID",
  sc.filt.genes.cluster = FALSE,
  project = "Simul_example"
)
SDDLS &lt;- estimateZinbwaveParams(
  object = SDDLS,
  cell.type.column = "Cell_Type",
  cell.ID.column = "Cell_ID",
  gene.ID.column = "Gene_ID",
  subset.cells = 2,
  verbose = TRUE
)
SDDLS &lt;- simSCProfiles(
  object = SDDLS,
  cell.ID.column = "Cell_ID",
  cell.type.column = "Cell_Type",
  n.cells = 2,
  verbose = TRUE
)

</code></pre>

<hr>
<h2 id='single.cell.real'>Get and set <code>single.cell.real</code> slot in a
<code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code> object</h2><span id='topic+single.cell.real'></span><span id='topic+single.cell.real+2CSpatialDDLS-method'></span><span id='topic+single.cell.real+3C-'></span><span id='topic+single.cell.real+3C-+2CSpatialDDLS-method'></span>

<h3>Description</h3>

<p>Get and set <code>single.cell.real</code> slot in a
<code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>single.cell.real(object)

single.cell.real(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="single.cell.real_+3A_object">object</code></td>
<td>
<p><code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code> object.</p>
</td></tr>
<tr><td><code id="single.cell.real_+3A_value">value</code></td>
<td>
<p><code><a href="SingleCellExperiment.html#topic+SingleCellExperiment">SingleCellExperiment</a></code> object
with real single-cell profiles.</p>
</td></tr>
</table>

<hr>
<h2 id='single.cell.simul'>Get and set <code>single.cell.simul</code> slot in a
<code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code> object</h2><span id='topic+single.cell.simul'></span><span id='topic+single.cell.simul+2CSpatialDDLS-method'></span><span id='topic+single.cell.simul+3C-'></span><span id='topic+single.cell.simul+3C-+2CSpatialDDLS-method'></span>

<h3>Description</h3>

<p>Get and set <code>single.cell.simul</code> slot in a
<code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>single.cell.simul(object)

single.cell.simul(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="single.cell.simul_+3A_object">object</code></td>
<td>
<p><code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code> object.</p>
</td></tr>
<tr><td><code id="single.cell.simul_+3A_value">value</code></td>
<td>
<p><code><a href="SingleCellExperiment.html#topic+SingleCellExperiment">SingleCellExperiment</a></code> object
with simulated single-cell profiles.</p>
</td></tr>
</table>

<hr>
<h2 id='spatial.experiments'>Get and set <code>spatial.experiments</code> slot in a
<code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code> object</h2><span id='topic+spatial.experiments'></span><span id='topic+spatial.experiments+2CSpatialDDLS-method'></span><span id='topic+spatial.experiments+3C-'></span><span id='topic+spatial.experiments+3C-+2CSpatialDDLS-method'></span>

<h3>Description</h3>

<p>Get and set <code>spatial.experiments</code> slot in a
<code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatial.experiments(object, index.st = NULL)

spatial.experiments(object, index.st = NULL) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spatial.experiments_+3A_object">object</code></td>
<td>
<p><code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code> object.</p>
</td></tr>
<tr><td><code id="spatial.experiments_+3A_index.st">index.st</code></td>
<td>
<p>Index of the spatial transcriptomics data within the list. It
can be either an position or a name if a named list was provided. If
<code>NULL</code> (by default), all data contained in the
<code>spatial.experiments</code> slot are returned.</p>
</td></tr>
<tr><td><code id="spatial.experiments_+3A_value">value</code></td>
<td>
<p>List in which each element is a
<code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code>
object. It can be a named list.</p>
</td></tr>
</table>

<hr>
<h2 id='SpatialDDLS-class'>The SpatialDDLS Class</h2><span id='topic+SpatialDDLS-class'></span><span id='topic+SpatialDDLS'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object is the core of the
<span class="pkg">SpatialDDLS</span> package. This object stores different intermediate data
needed for the construction of new deconvolution models, the spatial
transcriptomics profiles to be deconvoluted, and the predicted cell type
proportions.
</p>


<h3>Details</h3>

<p>This object uses other classes to store different types of data generated
during the workflow: </p>
 <ul>
<li>
<p><code><a href="SingleCellExperiment.html#topic+SingleCellExperiment">SingleCellExperiment</a></code>
class for single-cell RNA-Seq data
storage, using sparse matrix from the <span class="pkg">Matrix</span> package
(<code>dgCMatrix</code> class) or <code>HDF5Array</code> class in case of
using HDF5 files as back-end (see below for more information). </p>
</li>
<li>
<p><code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code> class
for spatial transcriptomics data
storage. </p>
</li>
<li> <p><code><a href="zinbwave.html#topic+zinbModel">zinbModel</a></code> class with estimated
parameters for the simulation of new single-cell profiles. </p>
</li>
<li>
<p><code><a href="SummarizedExperiment.html#topic+SummarizedExperiment">SummarizedExperiment</a></code> class for simulated
mixed transcriptional profiles storage.
</p>
</li>
<li> <p><code><a href="#topic+PropCellTypes-class">PropCellTypes</a></code> class for composition cell type
matrices. See <code>?<a href="#topic+PropCellTypes-class">PropCellTypes</a></code> for details. </p>
</li>
<li>
<p><code><a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code> class to store information related to
deep neural network models. See <code>?<a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code> for
details. </p>
</li></ul>

<p>In order to provide a way to work with large amounts of data in
RAM-constrained machines, we provide the possibility of using HDF5 files as
back-end to store count matrices of both real and simulated single-cell
profiles by using the <span class="pkg">HDF5Array</span> and <span class="pkg">DelayedArray</span> classes from the
homonymous packages.
</p>


<h3>Slots</h3>


<dl>
<dt><code>single.cell.real</code></dt><dd><p>Real single-cell data stored in a
<code>SingleCellExperiment</code> object. The count matrix is stored either as
<code>dgCMatrix</code> or <code>HDF5Array</code> objects.</p>
</dd>
<dt><code>spatial.experiments</code></dt><dd><p>List of
<code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code>
objects to be deconvoluted.</p>
</dd>
<dt><code>zinb.params</code></dt><dd><p><code><a href="zinbwave.html#topic+zinbModel">zinbModel</a></code> object with estimated
parameters for the simulation of new single-cell expression profiles.</p>
</dd>
<dt><code>single.cell.simul</code></dt><dd><p>Simulated single-cell expression profiles using the
ZINB-WaVE model.</p>
</dd>
<dt><code>prob.cell.types</code></dt><dd><p><code><a href="#topic+PropCellTypes-class">PropCellTypes</a></code> class with cell
composition matrices built for the simulation of mixed transcriptional
profiles with known cell composition.</p>
</dd>
<dt><code>mixed.profiles</code></dt><dd><p>List of simulated train and test mixed transcriptional
profiles. Each entry is a
<code><a href="SummarizedExperiment.html#topic+SummarizedExperiment">SummarizedExperiment</a></code> object. Count
matrices can be stored as <code>HDF5Array</code> objects using HDF5 files as
back-end in case of RAM limitations.</p>
</dd>
<dt><code>trained.model</code></dt><dd><p><code><a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code> object with
information related to the deconvolution model. See
<code>?<a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code> for more details.</p>
</dd>
<dt><code>deconv.spots</code></dt><dd><p>Deconvolution results. It consists of a list where each
element corresponds to the results for each
<code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code> object contained in the
<code>spatial.experiments</code> slot.</p>
</dd>
<dt><code>project</code></dt><dd><p>Name of the project.</p>
</dd>
<dt><code>version</code></dt><dd><p>Version of <span class="pkg">SpatialDDLS</span> this object was built under.</p>
</dd>
</dl>

<hr>
<h2 id='SpatialDDLS-Rpackage'>SpatialDDLS: an R package to deconvolute spatial transcriptomics data using
deep neural networks</h2><span id='topic+SpatialDDLS-Rpackage'></span>

<h3>Description</h3>

<p><span class="pkg">SpatialDDLS</span> is an R package that provides a neural network-based
solution for cell type deconvolution of spatial transcriptomics data. The
package takes advantage of single-cell RNA sequencing (scRNA-seq) data to
simulate mixed transcriptional profiles with known cell composition and train
fully-connected neural networks to predict the cell type composition of
spatial transcriptomics spots. The resulting trained models can be applied to
new spatial transcriptomics data to predict cell type proportions, allowing
for more accurate cell type identification and characterization of
spatially-resolved transcriptomic data. Finally, predictions are forced to keep
spatial consistency through a process we refer to as spatial regularization.
Overall, <span class="pkg">SpatialDDLS</span> is a powerful tool for cell type deconvolution in
spatial transcriptomics data, providing a reliable, fast and flexible
solution for researchers in the field. See Mañanes et al. (2024)
(<a href="https://doi.org/10.1093/bioinformatics/btae072">doi:10.1093/bioinformatics/btae072</a>) and some examples
(<a href="https://diegommcc.github.io/SpatialDDLS/">https://diegommcc.github.io/SpatialDDLS/</a>) for more details.
</p>

<hr>
<h2 id='spatialPropClustering'>Cluster spatial data based on predicted cell proportions</h2><span id='topic+spatialPropClustering'></span>

<h3>Description</h3>

<p>Cluster spatial transcriptomics data according to the cell proportions
predicted in each spot. It allows to segregate ST data into niches with
similar cell composition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatialPropClustering(
  object,
  index.st,
  method = "graph",
  k.nn = 10,
  k.centers = 5,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spatialPropClustering_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object with deconvoluted ST
datasets.</p>
</td></tr>
<tr><td><code id="spatialPropClustering_+3A_index.st">index.st</code></td>
<td>
<p>Name or index of the dataset/slide already deconvoluted to be
clustered. If missing, all datasets already deconvoluted will be clustered.</p>
</td></tr>
<tr><td><code id="spatialPropClustering_+3A_method">method</code></td>
<td>
<p>Clustering method. It can be <code>graph</code> (a nearest neighbor
graph is created and Louvain algorithm is used to detect communities) or
<code>k.means</code> (k-means algorithm is run with the specified number of
centers (<code>k.centers</code> parameter)).</p>
</td></tr>
<tr><td><code id="spatialPropClustering_+3A_k.nn">k.nn</code></td>
<td>
<p>An integer specifying the number of nearest neighbors to be used
during graph construction (10 by default). Only if
<code>method == "graph"</code>.</p>
</td></tr>
<tr><td><code id="spatialPropClustering_+3A_k.centers">k.centers</code></td>
<td>
<p>An integer specifying the number of centers for k-means
algorithm (5 by default). Only if <code>method == "k.means"</code>.</p>
</td></tr>
<tr><td><code id="spatialPropClustering_+3A_verbose">verbose</code></td>
<td>
<p>Show informative messages during the execution (<code>TRUE</code> by
default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object containing computed
clusters as a column in the slot <code>colData</code> of the
<code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code> objects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotTrainingHistory">plotTrainingHistory</a></code> <code><a href="#topic+deconvSpatialDDLS">deconvSpatialDDLS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
sce &lt;- SingleCellExperiment::SingleCellExperiment(
  assays = list(
    counts = matrix(
      rpois(30, lambda = 5), nrow = 15, ncol = 10,
      dimnames = list(paste0("Gene", seq(15)), paste0("RHC", seq(10)))
    )
  ),
  colData = data.frame(
    Cell_ID = paste0("RHC", seq(10)),
    Cell_Type = sample(x = paste0("CellType", seq(2)), size = 10,
                       replace = TRUE)
  ),
  rowData = data.frame(
    Gene_ID = paste0("Gene", seq(15))
  )
)
SDDLS &lt;- createSpatialDDLSobject(
  sc.data = sce,
  sc.cell.ID.column = "Cell_ID",
  sc.gene.ID.column = "Gene_ID",
  sc.filt.genes.cluster = FALSE
) 
SDDLS &lt;- genMixedCellProp(
  SDDLS,
  cell.ID.column = "Cell_ID",
  cell.type.column = "Cell_Type",
  num.sim.spots = 50,
  train.freq.cells = 2/3,
  train.freq.spots = 2/3,
  verbose = TRUE
) 
SDDLS &lt;- simMixedProfiles(SDDLS) 
SDDLS &lt;- trainDeconvModel(
  SDDLS,
  batch.size = 12,
  num.epochs = 5
) 
# simulating spatial data
ngenes &lt;- sample(3:40, size = 1)
ncells &lt;- sample(10:40, size = 1)
counts &lt;- matrix(
  rpois(ngenes * ncells, lambda = 5), ncol = ncells,
  dimnames = list(paste0("Gene", seq(ngenes)), paste0("Spot", seq(ncells)))
)
coordinates &lt;- matrix(
  rep(c(1, 2), ncells), ncol = 2
)
st &lt;- SpatialExperiment::SpatialExperiment(
  assays = list(counts = as.matrix(counts)),
  rowData = data.frame(Gene_ID = paste0("Gene", seq(ngenes))),
  colData = data.frame(Cell_ID = paste0("Spot", seq(ncells))),
  spatialCoords = coordinates
)
SDDLS &lt;- loadSTProfiles(
  object = SDDLS,
  st.data = st,
  st.spot.ID.column = "Cell_ID",
  st.gene.ID.column = "Gene_ID"
)
SDDLS &lt;- deconvSpatialDDLS(
  SDDLS,
  index.st = 1
) 
SDDLS &lt;- spatialPropClustering(SDDLS, index.st = 1, k.nn = 5)

  
</code></pre>

<hr>
<h2 id='test.deconv.metrics'>Get and set <code>test.deconv.metrics</code> slot in a
<code><a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code> object</h2><span id='topic+test.deconv.metrics'></span><span id='topic+test.deconv.metrics+2CDeconvDLModel-method'></span><span id='topic+test.deconv.metrics+3C-'></span><span id='topic+test.deconv.metrics+3C-+2CDeconvDLModel-method'></span>

<h3>Description</h3>

<p>Get and set <code>test.deconv.metrics</code> slot in a
<code><a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.deconv.metrics(object, metrics = "All")

test.deconv.metrics(object, metrics = "All") &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test.deconv.metrics_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code> object.</p>
</td></tr>
<tr><td><code id="test.deconv.metrics_+3A_metrics">metrics</code></td>
<td>
<p>Metrics to show (<code>'All'</code> by default)</p>
</td></tr>
<tr><td><code id="test.deconv.metrics_+3A_value">value</code></td>
<td>
<p>List with evaluation metrics to assess the performance of the
model on each sample of test data.</p>
</td></tr>
</table>

<hr>
<h2 id='test.metrics'>Get and set <code>test.metrics</code> slot in a
<code><a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code> object</h2><span id='topic+test.metrics'></span><span id='topic+test.metrics+2CDeconvDLModel-method'></span><span id='topic+test.metrics+3C-'></span><span id='topic+test.metrics+3C-+2CDeconvDLModel-method'></span>

<h3>Description</h3>

<p>Get and set <code>test.metrics</code> slot in a
<code><a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.metrics(object)

test.metrics(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test.metrics_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code> object.</p>
</td></tr>
<tr><td><code id="test.metrics_+3A_value">value</code></td>
<td>
<p>List with evaluation metrics after prediction on test data.</p>
</td></tr>
</table>

<hr>
<h2 id='test.pred'>Get and set <code>test.pred</code> slot in a
<code><a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code> object</h2><span id='topic+test.pred'></span><span id='topic+test.pred+2CDeconvDLModel-method'></span><span id='topic+test.pred+3C-'></span><span id='topic+test.pred+3C-+2CDeconvDLModel-method'></span>

<h3>Description</h3>

<p>Get and set <code>test.pred</code> slot in a
<code><a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.pred(object)

test.pred(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test.pred_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code> object.</p>
</td></tr>
<tr><td><code id="test.pred_+3A_value">value</code></td>
<td>
<p>Matrix object with prediction results on test data.</p>
</td></tr>
</table>

<hr>
<h2 id='topGradientsCellType'>Get top genes with largest/smallest gradients per cell type</h2><span id='topic+topGradientsCellType'></span>

<h3>Description</h3>

<p>Retrieve feature names with the largest/smallest gradients per cell
type. These genes can be used to visualize their spatial expression
in the ST data (<code>plotGeneSpatial</code> function) or to plot the calculated
gradients as a heatmap (<code>plotGradHeatmap</code> function).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>topGradientsCellType(object, method = "class", top.n.genes = 15)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="topGradientsCellType_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object with a
<code><a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code> object containing gradients in the
<code>interpret.gradients</code> slot.</p>
</td></tr>
<tr><td><code id="topGradientsCellType_+3A_method">method</code></td>
<td>
<p>Method gradients were calculated by. It can be either
<code>'class'</code> (gradients of predicted classes w.r.t. inputs) or
<code>'loss'</code> (gradients of loss w.r.t. input features).</p>
</td></tr>
<tr><td><code id="topGradientsCellType_+3A_top.n.genes">top.n.genes</code></td>
<td>
<p>Top n genes (positive and negative) taken per cell type.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of gene names with the top positive and negative
gradients per cell type.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+interGradientsDL">interGradientsDL</a></code> <code><a href="#topic+trainDeconvModel">trainDeconvModel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
sce &lt;- SingleCellExperiment::SingleCellExperiment(
  assays = list(
    counts = matrix(
      rpois(30, lambda = 5), nrow = 15, ncol = 10,
      dimnames = list(paste0("Gene", seq(15)), paste0("RHC", seq(10)))
    )
  ),
  colData = data.frame(
    Cell_ID = paste0("RHC", seq(10)),
    Cell_Type = sample(x = paste0("CellType", seq(2)), size = 10,
                       replace = TRUE)
  ),
  rowData = data.frame(
    Gene_ID = paste0("Gene", seq(15))
  )
)
SDDLS &lt;- createSpatialDDLSobject(
  sc.data = sce,
  sc.cell.ID.column = "Cell_ID",
  sc.gene.ID.column = "Gene_ID",
  sc.filt.genes.cluster = FALSE
)
SDDLS &lt;- genMixedCellProp(
  object = SDDLS,
  cell.ID.column = "Cell_ID",
  cell.type.column = "Cell_Type",
  num.sim.spots = 50,
  train.freq.cells = 2/3,
  train.freq.spots = 2/3,
  verbose = TRUE
)
SDDLS &lt;- simMixedProfiles(SDDLS)
SDDLS &lt;- trainDeconvModel(
  object = SDDLS,
  batch.size = 12,
  num.epochs = 5
)
## calculating gradients
SDDLS &lt;- interGradientsDL(SDDLS)
listGradients &lt;- topGradientsCellType(SDDLS)
lapply(listGradients, head, n = 5)

  
</code></pre>

<hr>
<h2 id='trainDeconvModel'>Train deconvolution model for spatial transcriptomics data</h2><span id='topic+trainDeconvModel'></span>

<h3>Description</h3>

<p>Train a deep neural network model using training data from the
<code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object. This model will be used to
deconvolute spatial transcriptomics data from the same biological context as
the single-cell RNA-seq data used to train it. In addition, the trained
model is evaluated using test data, and prediction results are obtained to
determine its performance (see <code>?<a href="#topic+calculateEvalMetrics">calculateEvalMetrics</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trainDeconvModel(
  object,
  type.data.train = "mixed",
  type.data.test = "mixed",
  batch.size = 64,
  num.epochs = 60,
  num.hidden.layers = 2,
  num.units = c(200, 200),
  activation.fun = "relu",
  dropout.rate = 0.25,
  loss = "kullback_leibler_divergence",
  metrics = c("accuracy", "mean_absolute_error", "categorical_accuracy"),
  normalize = TRUE,
  scaling = "standardize",
  norm.batch.layers = TRUE,
  custom.model = NULL,
  shuffle = TRUE,
  sc.downsampling = NULL,
  use.generator = FALSE,
  on.the.fly = FALSE,
  agg.function = "AddRawCount",
  threads = 1,
  view.metrics.plot = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trainDeconvModel_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object with
<code>single.cell.real</code>/<code>single.cell.simul</code>, <code>prob.cell.types</code>,
and <code>mixed.profiles</code> slots (the last only if <code>on.the.fly =
  FALSE</code>).</p>
</td></tr>
<tr><td><code id="trainDeconvModel_+3A_type.data.train">type.data.train</code></td>
<td>
<p>Type of profiles to be used for training. It can be
<code>'both'</code>, <code>'single-cell'</code> or <code>'mixed'</code> (<code>'mixed'</code> by
default).</p>
</td></tr>
<tr><td><code id="trainDeconvModel_+3A_type.data.test">type.data.test</code></td>
<td>
<p>Type of profiles to be used for evaluation. It can be
<code>'both'</code>, <code>'single-cell'</code> or <code>'mixed'</code> (<code>'mixed'</code> by
default).</p>
</td></tr>
<tr><td><code id="trainDeconvModel_+3A_batch.size">batch.size</code></td>
<td>
<p>Number of samples per gradient update (64 by default).</p>
</td></tr>
<tr><td><code id="trainDeconvModel_+3A_num.epochs">num.epochs</code></td>
<td>
<p>Number of epochs to train the model (60 by default).</p>
</td></tr>
<tr><td><code id="trainDeconvModel_+3A_num.hidden.layers">num.hidden.layers</code></td>
<td>
<p>Number of hidden layers of the neural network (2 by
default). This number must be equal to the length of <code>num.units</code>
argument.</p>
</td></tr>
<tr><td><code id="trainDeconvModel_+3A_num.units">num.units</code></td>
<td>
<p>Vector indicating the number of neurons per hidden layer
(<code>c(200, 200)</code> by default). The length of this vector must be equal to
the <code>num.hidden.layers</code> argument.</p>
</td></tr>
<tr><td><code id="trainDeconvModel_+3A_activation.fun">activation.fun</code></td>
<td>
<p>Activation function (<code>'relu'</code> by default). See
the
<a href="https://tensorflow.rstudio.com/reference/keras/activation_relu.html">keras
documentation</a> to know available activation functions.</p>
</td></tr>
<tr><td><code id="trainDeconvModel_+3A_dropout.rate">dropout.rate</code></td>
<td>
<p>Float between 0 and 1 indicating the fraction of
input neurons to be dropped in layer dropouts (0.25 by default). By
default, <span class="pkg">SpatialDDLS</span> implements 1 dropout layer per hidden layer.</p>
</td></tr>
<tr><td><code id="trainDeconvModel_+3A_loss">loss</code></td>
<td>
<p>Character indicating loss function selected for model training
(<code>'kullback_leibler_divergence'</code> by default). See the
<a href="https://tensorflow.rstudio.com/reference/keras/loss-functions.html">keras
documentation</a> to know available loss functions.</p>
</td></tr>
<tr><td><code id="trainDeconvModel_+3A_metrics">metrics</code></td>
<td>
<p>Vector of metrics used to assess model performance during
training and evaluation (<code>c("accuracy", "mean_absolute_error",
  "categorical_accuracy")</code> by default). See the
<a href="https://tensorflow.rstudio.com/reference/keras/metric_binary_accuracy.html">keras
documentation</a> to know available performance metrics.</p>
</td></tr>
<tr><td><code id="trainDeconvModel_+3A_normalize">normalize</code></td>
<td>
<p>Whether to normalize data using logCPM (<code>TRUE</code> by
default). This parameter is only considered when the method used to
simulate mixed transcriptional profiles (<code>simMixedProfiles</code>
function) was <code>"AddRawCount"</code>. Otherwise, data were already
normalized.</p>
</td></tr>
<tr><td><code id="trainDeconvModel_+3A_scaling">scaling</code></td>
<td>
<p>How to scale data before training. It can be:
<code>"standardize"</code> (values are centered around the mean with a unit
standard deviation), <code>"rescale"</code> (values are shifted and rescaled so
that they end up ranging between 0 and 1) or <code>"none"</code> (no
scaling is performed). <code>"standardize"</code> by default.</p>
</td></tr>
<tr><td><code id="trainDeconvModel_+3A_norm.batch.layers">norm.batch.layers</code></td>
<td>
<p>Whether to include batch normalization layers
between each hidden dense layer (<code>TRUE</code> by default).</p>
</td></tr>
<tr><td><code id="trainDeconvModel_+3A_custom.model">custom.model</code></td>
<td>
<p>It allows to use a custom neural network architecture. It
must be a <code>keras.engine.sequential.Sequential</code> object in which the
number of input neurons is equal to the number of considered
features/genes, and the number of output neurons is equal to the number of
cell types considered (<code>NULL</code> by default). If provided, the arguments
related to the neural network architecture will be ignored.</p>
</td></tr>
<tr><td><code id="trainDeconvModel_+3A_shuffle">shuffle</code></td>
<td>
<p>Boolean indicating whether data will be shuffled (<code>TRUE</code>
by default).</p>
</td></tr>
<tr><td><code id="trainDeconvModel_+3A_sc.downsampling">sc.downsampling</code></td>
<td>
<p>It is only used if <code>type.data.train</code> is equal to
<code>'both'</code> or <code>'single-cell'</code>. It allows to set a maximum number of
single-cell profiles of a specific cell type for training to avoid
an unbalanced representation of classes (<code>NULL</code> by default).</p>
</td></tr>
<tr><td><code id="trainDeconvModel_+3A_use.generator">use.generator</code></td>
<td>
<p>Boolean indicating whether to use generators during
training and test. Generators are automatically used when <code>on.the.fly
  = TRUE</code> or HDF5 files are used, but it can be activated by the user on
demand (<code>FALSE</code> by default).</p>
</td></tr>
<tr><td><code id="trainDeconvModel_+3A_on.the.fly">on.the.fly</code></td>
<td>
<p>Boolean indicating whether simulated data will be generated
'on the fly' during training (<code>FALSE</code> by default).</p>
</td></tr>
<tr><td><code id="trainDeconvModel_+3A_agg.function">agg.function</code></td>
<td>
<p>If <code>on.the.fly == TRUE</code>, function used to build
mixed transcriptional profiles. It may be:
</p>
 <ul>
<li> <p><code>"AddRawCount"</code> (by default): single-cell
profiles (raw counts) are added up across cells. Then, log-CPMs are
calculated. </p>
</li>
<li> <p><code>"MeanCPM"</code>: single-cell profiles (raw counts) are
transformed into logCPM and cross-cell averages are calculated.
</p>
</li>
<li> <p><code>"AddCPM"</code>: single-cell profiles (raw counts) are transformed
into CPMs and are added up across cells. Then, log-CPMs are calculated.</p>
</li></ul>
</td></tr>
<tr><td><code id="trainDeconvModel_+3A_threads">threads</code></td>
<td>
<p>Number of threads used during simulation of mixed
transcriptional profiles if <code>on.the.fly = TRUE</code> (1 by default).</p>
</td></tr>
<tr><td><code id="trainDeconvModel_+3A_view.metrics.plot">view.metrics.plot</code></td>
<td>
<p>Boolean indicating whether to show plots of loss and
evaluation metrics during training (<code>TRUE</code> by default). <span class="pkg">keras</span>
for R allows to see model progression during training if you are working in
RStudio.</p>
</td></tr>
<tr><td><code id="trainDeconvModel_+3A_verbose">verbose</code></td>
<td>
<p>Boolean indicating whether to display model progression during
training and model architecture information (<code>TRUE</code> by default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Simulation of mixed transcriptional profiles 'on the fly'</strong>
</p>
<p><code>trainDeconvModel</code> can avoid storing simulated mixed spot profiles by
using the <code>on.the.fly</code> argument. This functionality aims at reducing the
the <code>simMixedProfiles</code> function's memory usage: simulated profiles are
built in each batch during training/evaluation.
</p>
<p><strong>Neural network architecture</strong>
</p>
<p>It is possible to change the model's architecture: number of hidden layers,
number of neurons for each hidden layer, dropout rate, activation function,
and loss function. For more customized models, it is possible to provide a
pre-built model through the <code>custom.model</code> argument (a
<code>keras.engine.sequential.Sequential</code> object) where it is necessary that
the number of input neurons is equal to the number of considered
features/genes, and the number of output neurons is equal to the number of
considered cell types.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+SpatialDDLS-class">SpatialDDLS</a></code> object with <code>trained.model</code>
slot containing a <code><a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code> object. For more
information about the structure of this class, see
<code>?<a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotTrainingHistory">plotTrainingHistory</a></code> <code><a href="#topic+deconvSpatialDDLS">deconvSpatialDDLS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(123)
sce &lt;- SingleCellExperiment::SingleCellExperiment(
  assays = list(
    counts = matrix(
      rpois(30, lambda = 5), nrow = 15, ncol = 10,
      dimnames = list(paste0("Gene", seq(15)), paste0("RHC", seq(10)))
    )
  ),
  colData = data.frame(
    Cell_ID = paste0("RHC", seq(10)),
    Cell_Type = sample(x = paste0("CellType", seq(2)), size = 10,
                       replace = TRUE)
  ),
  rowData = data.frame(
    Gene_ID = paste0("Gene", seq(15))
  )
)
SDDLS &lt;- createSpatialDDLSobject(
  sc.data = sce,
  sc.cell.ID.column = "Cell_ID",
  sc.gene.ID.column = "Gene_ID",
  sc.filt.genes.cluster = FALSE
)
SDDLS &lt;- genMixedCellProp(
  object = SDDLS,
  cell.ID.column = "Cell_ID",
  cell.type.column = "Cell_Type",
  num.sim.spots = 50,
  train.freq.cells = 2/3,
  train.freq.spots = 2/3,
  verbose = TRUE
)
SDDLS &lt;- simMixedProfiles(SDDLS)
SDDLS &lt;- trainDeconvModel(
  object = SDDLS,
  batch.size = 12,
  num.epochs = 5
)

  
</code></pre>

<hr>
<h2 id='trained.model'>Get and set <code>trained.model</code> slot in a
<code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code> object</h2><span id='topic+trained.model'></span><span id='topic+trained.model+2CSpatialDDLS-method'></span><span id='topic+trained.model+3C-'></span><span id='topic+trained.model+3C-+2CSpatialDDLS-method'></span>

<h3>Description</h3>

<p>Get and set <code>trained.model</code> slot in a
<code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trained.model(object)

trained.model(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trained.model_+3A_object">object</code></td>
<td>
<p><code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code> object.</p>
</td></tr>
<tr><td><code id="trained.model_+3A_value">value</code></td>
<td>
<p><code><a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code> object.</p>
</td></tr>
</table>

<hr>
<h2 id='training.history'>Get and set <code>training.history</code> slot in a
<code><a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code> object</h2><span id='topic+training.history'></span><span id='topic+training.history+2CDeconvDLModel-method'></span><span id='topic+training.history+3C-'></span><span id='topic+training.history+3C-+2CDeconvDLModel-method'></span>

<h3>Description</h3>

<p>Get and set <code>training.history</code> slot in a
<code><a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>training.history(object)

training.history(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="training.history_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+DeconvDLModel-class">DeconvDLModel</a></code> object.</p>
</td></tr>
<tr><td><code id="training.history_+3A_value">value</code></td>
<td>
<p><code>keras_training_history</code> object with the training history
of the deep neural network model.</p>
</td></tr>
</table>

<hr>
<h2 id='zinb.params'>Get and set <code>zinb.params</code> slot in a
<code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code> object</h2><span id='topic+zinb.params'></span><span id='topic+zinb.params+2CSpatialDDLS-method'></span><span id='topic+zinb.params+3C-'></span><span id='topic+zinb.params+3C-+2CSpatialDDLS-method'></span>

<h3>Description</h3>

<p>Get and set <code>zinb.params</code> slot in a
<code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zinb.params(object)

zinb.params(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zinb.params_+3A_object">object</code></td>
<td>
<p><code><a href="SpatialExperiment.html#topic+SpatialExperiment">SpatialExperiment</a></code> object.</p>
</td></tr>
<tr><td><code id="zinb.params_+3A_value">value</code></td>
<td>
<p><code><a href="#topic+ZinbParametersModel-class">ZinbParametersModel</a></code> object with a valid
<code><a href="zinbwave.html#topic+zinbModel">zinbModel</a></code> object.</p>
</td></tr>
</table>

<hr>
<h2 id='ZinbParametersModel-class'>The Class ZinbParametersModel</h2><span id='topic+ZinbParametersModel-class'></span><span id='topic+ZinbParametersModel'></span>

<h3>Description</h3>

<p>The ZinbParametersModel class is a wrapper class for the
<code><a href="zinbwave.html#topic+zinbModel">zinbModel</a></code> class from the
<span class="pkg">zinbwave</span> package.
</p>


<h3>Details</h3>

<p>This wrapper class contains the <code>zinbwave.model</code> slot, which holds a
valid <code><a href="zinbwave.html#topic+zinbModel">zinbModel</a></code> object.
</p>


<h3>Slots</h3>


<dl>
<dt><code>zinbwave.model</code></dt><dd><p>A valid
<code><a href="zinbwave.html#topic+zinbModel">zinbModel</a></code> object.</p>
</dd>
</dl>


<h3>References</h3>

<p>Risso, D., Perraudeau, F., Gribkova, S. et al. (2018). A general
and flexible method for signal extraction from single-cell RNA-seq data.
Nat Commun 9, 284. doi: <a href="https://doi.org/10.1038/s41467-017-02554-5">doi:10.1038/s41467-017-02554-5</a>.
</p>

<hr>
<h2 id='zinbwave.model'>Get and set <code>zinbwave.model</code> slot in a
<code><a href="#topic+ZinbParametersModel-class">ZinbParametersModel</a></code> object</h2><span id='topic+zinbwave.model'></span><span id='topic+zinbwave.model+2CZinbParametersModel-method'></span><span id='topic+zinbwave.model+3C-'></span><span id='topic+zinbwave.model+3C-+2CZinbParametersModel-method'></span>

<h3>Description</h3>

<p>Get and set <code>zinbwave.model</code> slot in a
<code><a href="#topic+ZinbParametersModel-class">ZinbParametersModel</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zinbwave.model(object)

zinbwave.model(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zinbwave.model_+3A_object">object</code></td>
<td>
<p><code><a href="#topic+ZinbParametersModel-class">ZinbParametersModel</a></code> object.</p>
</td></tr>
<tr><td><code id="zinbwave.model_+3A_value">value</code></td>
<td>
<p><code><a href="zinbwave.html#topic+zinbModel">zinbModel</a></code> object with the
estimated parameters to simulate new single-cell profiles.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
