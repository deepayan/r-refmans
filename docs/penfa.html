<!DOCTYPE html><html><head><title>Help for package penfa</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {penfa}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#penfa-package'><p>penfa: Single- and Multiple-Group Penalized Factor Analysis</p></a></li>
<li><a href='#ccdata'><p>Data set for cross-cultural analysis</p></a></li>
<li><a href='#coef,penfa-method'><p>Coefficients from a <code>penfa</code> object</p></a></li>
<li><a href='#fitted,penfa-method'><p>Model-implied moments for a <code>penfa</code> object</p></a></li>
<li><a href='#penfa'><p>Single- and multiple-group penalized factor analysis</p></a></li>
<li><a href='#penfa-class'><p>S4 Class for describing a <code>penfa</code> model</p></a></li>
<li><a href='#penfaData-class'><p>S4 Class for describing the input data</p></a></li>
<li><a href='#penfaModel-class'><p>S4 Class for internal representation of a factor model</p></a></li>
<li><a href='#penfaOptions'><p><code>penfa</code> Options</p></a></li>
<li><a href='#penfaOut'><p>Print estimated parameter matrices</p></a></li>
<li><a href='#penfaParEstim'><p>Print parameter estimates in table format</p></a></li>
<li><a href='#penfaPenalty-class'><p>S4 Class for describing the penalization process</p></a></li>
<li><a href='#penfaPredict'><p>Compute the factor scores from a fitted <code>penfa</code> model</p></a></li>
<li><a href='#penfaSampleStats-class'><p>S4 Class for describing the sample moments</p></a></li>
<li><a href='#penmat'><p>Extract estimated penalty matrix</p></a></li>
<li><a href='#show,penfa-method'><p>Display a <code>penfa</code> object</p></a></li>
<li><a href='#show,penfaData-method'><p>Display details on the input data</p></a></li>
<li><a href='#show,penfaPenalty-method'><p>Display details on the penalization</p></a></li>
<li><a href='#summary,penfa-method'><p>Summary constructor for a <code>penfa</code> object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Single- And Multiple-Group Penalized Factor Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Fits single- and multiple-group penalized factor analysis models 
    via a trust-region algorithm with integrated automatic multiple tuning 
    parameter selection (Geminiani et al., 2021 &lt;<a href="https://doi.org/10.1007%2Fs11336-021-09751-8">doi:10.1007/s11336-021-09751-8</a>&gt;). 
    Available penalties include lasso, adaptive lasso, scad, mcp, and ridge. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, methods, mgcv, GJRM, stats, trust, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>cartography, knitr, plotly, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/egeminiani/penfa">https://github.com/egeminiani/penfa</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-07-15 06:41:38 UTC; egeminiani</td>
</tr>
<tr>
<td>Author:</td>
<td>Elena Geminiani <a href="https://orcid.org/0000-0001-5992-9728"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Giampiero Marra <a href="https://orcid.org/0000-0002-9010-2646"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Irini Moustaki <a href="https://orcid.org/0000-0001-8371-1251"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Elena Geminiani &lt;geminianielena@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-07-17 05:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='penfa-package'>penfa: Single- and Multiple-Group Penalized Factor Analysis</h2><span id='topic+penfa-package'></span>

<h3>Description</h3>

<p>The <code>penfa</code> package (a short form for <em>PENalized Factor Analysis</em>) provides
several routines for single- and multiple-group penalized factor analysis for
continuous data. The models are estimated via a trust-region algorithm with
integrated automatic multiple tuning parameter selection. The available
penalties include lasso, adaptive lasso, scad, mcp, and ridge. <br /><br />
The main function of the package is <code><a href="#topic+penfa">penfa</a></code>. To learn more about
it, start with the vignettes and tutorials at <code>browseVignettes(package = "penfa")</code> and
<a href="https://egeminiani.github.io/penfa/articles/">https://egeminiani.github.io/penfa/articles/</a>.
</p>


<h3>Details</h3>

<p>Penalized factor analysis allows to produce parsimonious models using largely
an automated procedure. In the single-group case, a typical penalty function
will automatically shrink a subset of the factor loadings to zero. The use of
sparsity-inducing penalty functions leads to optimally sparse factor
structures supported by the data. The resulting models are less prone to
instability in the estimation process and are easier to interpret and
generalize than their unpenalized counterparts.
</p>
<p>In the multiple-group scenario, penalized factor analysis can be used to
automatically ascertain differences and similarities of parameter
estimates across groups. Typical penalties will automatically encourage
sparse loading matrices and invariant factor loadings and intercepts.
</p>
<p>In <code>penfa</code>, estimation is achieved via a penalized likelihood-based
framework that builds upon differentiable approximations of
non-differentiable penalties, a theoretically founded definition of degrees
of freedom, and an algorithm with integrated automatic multiple tuning
parameter selection. The estimation is based on a trust-region algorithm
approach exploiting second-order analytical derivative information. The
standard errors for the model parameters are derived using a Bayesian
approach.
</p>
<p>The selection of the tuning parameters is a crucial issue in penalized
estimation strategies, as the tuning parameters are responsible for the
optimal balance between goodness of fit and sparsity. In <code>penfa</code>, the
optimal values of the tuning parameters can be determined through the
automatic procedure or grid-searches.
</p>
<p>In addition to the fitting function <code><a href="#topic+penfa">penfa</a></code>, the package provides
several methods for examining the parameter estimates, monitoring
the optimization process, and inspecting the structures of the penalty
matrices through interactive visualizations.
</p>


<h3>Author(s)</h3>

<p>Authors: Elena Geminiani, Giampiero Marra, Irini Moustaki
</p>
<p>Maintainer: Elena Geminiani. Please address any query or comment to
<a href="mailto:geminianielena@gmail.com">geminianielena@gmail.com</a>.
</p>


<h3>References</h3>

<p>Geminiani, E., Marra, G., &amp; Moustaki, I. (2021). &quot;Single- and Multiple-Group
Penalized Factor Analysis: A Trust-Region Algorithm Approach with Integrated
Automatic Multiple Tuning Parameter Selection.&quot; Psychometrika, 86(1), 65-95.
doi: <a href="https://doi.org/10.1007/s11336-021-09751-8">10.1007/s11336-021-09751-8</a>
</p>
<p>Geminiani E. (2020), &quot;A penalized likelihood-based framework for single and
multiple-group factor analysis models&quot; (Doctoral dissertation, University of
Bologna). Available at <a href="http://amsdottorato.unibo.it/9355/">http://amsdottorato.unibo.it/9355/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+penfa">penfa</a></code>, <code><a href="#topic+penfa-class">penfa-class</a></code>
</p>

<hr>
<h2 id='ccdata'>Data set for cross-cultural analysis</h2><span id='topic+ccdata'></span>

<h3>Description</h3>

<p>A data set for cross-cultural analysis containing the
standardized ratings to 12 items concerning organizational citizenship
behavior. Employees from different countries were asked to rate their
attitudes towards helping other employees and giving suggestions for
improved work conditions. The items are thought to measure two latent
factors: helping behavior (first seven items) and voice behavior
(last five items). See below for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ccdata
</code></pre>


<h3>Format</h3>

<p>A data frame with 767 rows and 13 variables:
</p>

<dl>
<dt>country</dt><dd><p>Character. Country of origin of the employee: Lebanon
(&quot;LEB&quot;) or Taiwan (&quot;TAIW&quot;).</p>
</dd>
<dt>h1</dt><dd><p>Numeric. Standardized ratings to the item &quot;<em>I volunteer to do
things for this organization</em>.&quot;</p>
</dd>
<dt>h2</dt><dd><p>Numeric.  Standardized ratings to the item &quot;<em>I help orient new
employees in this organization</em>.&quot;</p>
</dd>
<dt>h3</dt><dd><p>Numeric. Standardized ratings to the item &quot;<em>I attend functions
that help this organization</em>.&quot;</p>
</dd>
<dt>h4</dt><dd><p>Numeric. Standardized ratings to the item &quot;<em>I help others in
this work group with their work for the benefit of the group</em>.&quot;</p>
</dd>
<dt>h5</dt><dd><p>Numeric. Standardized ratings to the item &quot;<em>I get involved to
benefit this organization</em>.&quot;</p>
</dd>
<dt>h6</dt><dd><p>Numeric. Standardized ratings to the item &quot;<em>I help others in this
organization learn about the work</em>.&quot;</p>
</dd>
<dt>h7</dt><dd><p>Numeric. Standardized ratings to the item &quot;<em>I help others in this
organization with their work responsibilities</em>.&quot;</p>
</dd>
<dt>v1</dt><dd><p>Numeric. Standardized ratings to the item &quot;<em>I develop and make
recommendations concerning issues that affect this organization</em>.&quot;</p>
</dd>
<dt>v2</dt><dd><p>Numeric. Standardized ratings to the item &quot;<em>I speak up
and encourage other in this organization to get involved in issues that
affect the group</em>.&quot;</p>
</dd>
<dt>v3</dt><dd><p>Numeric. Standardized ratings to the item &quot;<em>I
communicate my opinions about work issues to others in this organization
even if my opinion is different and others in the organization disagree
with me</em>.&quot;</p>
</dd>
<dt>v4</dt><dd><p>Numeric. Standardized ratings to the item &quot;<em>I keep well informed
about issues where my opinion might be useful to this organization</em>.&quot;</p>
</dd>
<dt>v5</dt><dd><p>Numeric. Standardized ratings to the item &quot;<em>I speak up in
this organization with ideas for new projects or changes in procedures</em>.&quot;</p>
</dd>
</dl>



<h3>Details</h3>

<p>The original data come from the
<a href="https://github.com/Jo-Karl/ccpsyc/"><code>ccpsyc</code></a> package. For convenience,
the following pre-processing has been applied:
</p>

<ul>
<li><p> The data were filtered to only include employees from Lebanon and Taiwan.
</p>
</li>
<li><p> The answers, originally on a 7-point Likert scale, were standardized.
</p>
</li>
<li><p> The items were renamed as described above.
</p>
</li></ul>



<h3>Source</h3>

<p>The original data set is available from the
<a href="https://github.com/Jo-Karl/ccpsyc/tree/master/data/"><code>ccpsyc</code></a> package.
Please refer to <a href="https://www.frontiersin.org/articles/10.3389/fpsyg.2019.01507/full">Fischer and Karl (2019)</a>
and <a href="https://link.springer.com/article/10.1057/s41267-017-0132-6">Fischer et al. (2019)</a> for a
description and analysis of these data.
</p>

<hr>
<h2 id='coef+2Cpenfa-method'>Coefficients from a <code>penfa</code> object</h2><span id='topic+coef+2Cpenfa-method'></span>

<h3>Description</h3>

<p>An S4 method returning the estimates of the model parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'penfa'
coef(object, type = "free", labels = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef+2B2Cpenfa-method_+3A_object">object</code></td>
<td>
<p>An object of class <code>penfa</code>, found as a result of a call
to <code>penfa</code>.</p>
</td></tr>
<tr><td><code id="coef+2B2Cpenfa-method_+3A_type">type</code></td>
<td>
<p>Character. If <code>type="free"</code>, only the estimated parameters
(both penalized and unpenalized) are returned. If <code>type="user"</code>, all
parameters listed in the parameter table are returned, including fixed
parameters.</p>
</td></tr>
<tr><td><code id="coef+2B2Cpenfa-method_+3A_labels">labels</code></td>
<td>
<p>Logical. If <code>TRUE</code>, parameters are returned with their
names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of class <code>penfa.vector</code> containing the
estimated model parameters.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+penfa">penfa</a></code>, <code><a href="#topic+penfa-class">penfa-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(ccdata)

syntax = 'help  =~   h1 + h2 + h3 + h4 + h5 + h6 + h7 + 0*v1 + v2 + v3 + v4 + v5
          voice =~ 0*h1 + h2 + h3 + h4 + h5 + h6 + h7 +   v1 + v2 + v3 + v4 + v5'

alasso_fit &lt;- penfa(## factor model
                    model  = syntax,
                    data   = ccdata,
                    std.lv = TRUE,
                    ## penalization
                    pen.shrink = "alasso",
                    eta = list(shrink = c("lambda" = 0.01), diff = c("none" = 0)),
                    ## automatic procedure
                    strategy = "auto")

coef(alasso_fit)




</code></pre>

<hr>
<h2 id='fitted+2Cpenfa-method'>Model-implied moments for a <code>penfa</code> object</h2><span id='topic+fitted+2Cpenfa-method'></span>

<h3>Description</h3>

<p>An S4 method returning the model-implied moments for an object of class
<code>penfa</code>. For every group, a list with the model-implied  moments is
returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'penfa'
fitted(object, labels = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted+2B2Cpenfa-method_+3A_object">object</code></td>
<td>
<p>An object of class <code>penfa</code>, found as a result of a call
to <code>penfa</code>.</p>
</td></tr>
<tr><td><code id="fitted+2B2Cpenfa-method_+3A_labels">labels</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the model-implied moments are named
according to the item names used in the model syntax.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the model-implied moments for each group: <code>cov</code>
contains the implied covariance matrix, and <code>mean</code> the implied mean
vector. If just the covariance matrix is analyzed, only the <code>cov</code>
argument is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+penfa">penfa</a></code>, <code><a href="#topic+penfa-class">penfa-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(ccdata)

syntax = 'help  =~   h1 + h2 + h3 + h4 + h5 + h6 + h7 + 0*v1 + v2 + v3 + v4 + v5
          voice =~ 0*h1 + h2 + h3 + h4 + h5 + h6 + h7 +   v1 + v2 + v3 + v4 + v5'

alasso_fit &lt;- penfa(## factor model
                    model  = syntax,
                    data   = ccdata,
                    std.lv = TRUE,
                    ## penalization
                    pen.shrink = "alasso",
                    eta = list(shrink = c("lambda" = 0.01), diff = c("none" = 0)),
                    ## automatic procedure
                    strategy = "auto")

fitted(alasso_fit)



</code></pre>

<hr>
<h2 id='penfa'>Single- and multiple-group penalized factor analysis</h2><span id='topic+penfa'></span>

<h3>Description</h3>

<p>The function <code>penfa</code> fits single- and multiple-group
<em>PENalized Factor Analysis</em> models via a trust-region algorithm with
integrated automatic multiple tuning parameter selection.
</p>
<p>In a single-group analysis, <code>penfa</code> can automatically shrink a subset
of the factor loadings to zero. In a multiple-group analysis, it can
encourage sparse loading matrices and invariant factor loadings and
intercepts. The currently supported penalty functions are lasso, adaptive
lasso, scad, mcp, and ridge. Except for the latter, all penalties can
achieve sparsity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>penfa(
  model = NULL,
  data = NULL,
  group = NULL,
  pen.shrink = "alasso",
  pen.diff = "none",
  eta = list(shrink = c(lambda = 0.01), diff = c(none = 0)),
  strategy = "auto",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="penfa_+3A_model">model</code></td>
<td>
<p>A description of a user-specified model. It takes the form of a
lavaan-like model syntax. See below for additional details on how to
specify a model syntax.</p>
</td></tr>
<tr><td><code id="penfa_+3A_data">data</code></td>
<td>
<p>A data frame containing the (continuous) observed variables used
in the model. Except for the <code>group</code> variable, all variables are
treated as numeric.</p>
</td></tr>
<tr><td><code id="penfa_+3A_group">group</code></td>
<td>
<p>Character. An optional variable name in the data frame defining
the groups in a multiple-group analysis.</p>
</td></tr>
<tr><td><code id="penfa_+3A_pen.shrink">pen.shrink</code></td>
<td>
<p>Character. The type of penalty function used for shrinking
a subset of the model parameters (see the <code>eta</code> argument for details
on how to specify which model parameters shall be penalized). Possible
values for <code>pen.shrink</code> are &quot;lasso&quot;, &quot;alasso&quot; (i.e., adaptive lasso),
&quot;scad&quot; (i.e., smoothly clipped absolute deviation), &quot;mcp&quot; (i.e., minimax
concave penalty), &quot;ridge&quot;, and &quot;none&quot; in case of no shrinkage penalization.</p>
</td></tr>
<tr><td><code id="penfa_+3A_pen.diff">pen.diff</code></td>
<td>
<p>Character. The type of penalty function used for shrinking
certain parameter differences across groups, and thus encouraging parameter
equivalence across groups (see the <code>eta</code> argument for details on how
to specify which model parameters shall be encouraged to be equivalent).
Possible values for <code>pen.diff</code> are &quot;lasso&quot;, &quot;alasso&quot; (i.e., adaptive
lasso), &quot;scad&quot; (i.e., smoothly clipped  absolute deviation), &quot;mcp&quot; (i.e.,
minimax concave penalty), &quot;ridge&quot;, and &quot;none&quot; in case of no difference
penalization. Note that the specification of <code>pen.diff</code> is only valid
for multiple-group factor analyses when a <code>group</code> variable is defined.
If a difference penalty is requested, the groups must have the same
parameters.</p>
</td></tr>
<tr><td><code id="penfa_+3A_eta">eta</code></td>
<td>
<p>A named list containing the starting value(s) of the tuning
parameter(s) if the automatic procedure is requested (<code>strategy =
  "auto"</code>) or the fixed value(s) of the tuning parameter(s) to be used during
optimization if <code>strategy = "fixed"</code>. The list has two components with
names &quot;shrink&quot; and &quot;diff&quot;, which refer to the tuning parameters to be used
for shrinkage and group equivalence, respectively. The components of the
list are, in turn, named vectors specifying the type of parameter matrices
or vectors to be penalized. Common choices are &quot;lambda&quot; for the loading
matrix and &quot;tau&quot; for the intercept vector of the observed variables. Other
possible values are &quot;phi&quot; for the factor covariance matrix, &quot;psi&quot; for the
covariance matrix of the unique factors, and &quot;kappa&quot; for the factor means.
All non-fixed elements of the specified matrix/vector are penalized. When
<code>strategy = "fixed"</code> and the tuning values in <code>eta</code> are equal to
zero, specifying both list names as &quot;none&quot; results in ordinary maximum
likelihood estimation (no penalization).</p>
</td></tr>
<tr><td><code id="penfa_+3A_strategy">strategy</code></td>
<td>
<p>Character. The strategy used for the selection of the tuning
parameter(s). If <code>strategy = "auto"</code>, the optimal values of the tuning
parameters are determined via an automatic tuning parameter procedure; if
<code>strategy = "fixed"</code>, a penalized factor model with the values of the
tuning parameters stored in the option <code>eta</code> is estimated.</p>
</td></tr>
<tr><td><code id="penfa_+3A_...">...</code></td>
<td>
<p>Additional options that can be defined using <code>name =
"value"</code>. For a complete list, please refer to <code><a href="#topic+penfaOptions">penfaOptions</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+penfa-class">penfa</a></code>, for which several
methods are available. See the manual pages of <code>summary,penfa-method</code>,
<code>show,penfa-method</code>, <code>coef,penfa-method</code>, and
<code>fitted,penfa-method</code> for details.
</p>


<h3>Data set vs Sample Moments</h3>

<p>The <code>penfa</code> function currently takes as input a data set, as opposed to
the sample moments (i.e., covariance matrices and mean vectors). Future
implementations will allow <code>penfa</code> to additionally take as input sample
covariance matrices and sample means. For now, if only sample moments are
available, users can generate multivariate data from those sample moments,
and apply the <code>penfa</code> function on the generated data.  <br /> All variables
(except for the <code>group</code> variable in multiple-group analyses) are treated
as continuous. <br /> Categorical items are not currently supported. <br />
</p>


<h3>Model syntax</h3>

<p>The model syntax in the <code>model</code> argument describes the factor analysis
model to be estimated, and specifies the relationships between the observed
and latent variables (i.e., the common factors). To facilitate its
formulation, the rules for the syntax specification broadly follow the ones in
the <a href="https://CRAN.R-project.org/package=lavaan"><code>lavaan</code></a> package.
</p>
<p>The model syntax is composed of one or multiple formula-like expressions
describing specific parts of the model. The model syntax can be specified as
a literal string enclosed by single quotes as in the example below.
</p>
<pre>model_syntax &lt;- '
                # Common factors
                factor1 =~ x1 + x2 + x3 + x4 + x5 + x6
                factor2 =~ x1 + x2 + x3 + x4 + x5 + x6

                # Factor variances and covariances
                factor1 ~~ factor1
                factor1 ~~ factor2

                # Unique variances and covariances
                x1 ~~ x1
                x1 ~~ x2

                # Intercepts and factor means
                x1 ~ 1
                factor1 ~ 1
                '
</pre>
<p>Blank lines and comments can be used in between formulas, and formulas can be
split over multiple lines. Multiple formulas can be placed on
a single line if they are separated by a semicolon (;).
</p>
<p>The current implementation allows for the following types of formula-like
expressions in the model syntax: </p>
 <ol>
<li><p> Common factors: The
<code>"=~"</code> operator can be used to define the continuous common factors
(latent variables). The name of the factor (e.g., factor1) is on the left of
the <code>"=~"</code> operator, whereas the terms on the right (e.g., <code>x1 + x2
+ x3 + x4 + x5 + x6</code>), separated by <code>"+"</code> operators, are the indicators
of the factor. The operator <code>"=~"</code> can be read as &quot;is measured by&quot;.
</p>
</li>
<li><p> Variances and covariances: The <code>"~~"</code> (&quot;double tilde&quot;) operator
specifies the (residual) variance of an observed or latent variable, or a set
of covariances between one variable, and several other variables (either
observed or latent). The distinction between variances and residual variances
is made automatically. Covariances between unique factors are currently only
allowed when <code>information = "fisher"</code>.
</p>
</li>
<li><p> Intercepts and factor means: We can specify an intercept for an
observed variable (<code>x1 ~ 1</code>) or a common factor (<code>factor1 ~ 1</code>).
The variable name appears on the left of the <code>"~"</code> operator. On the
right-hand side, there is the number &quot;1&quot;, which stands for the
intercept/mean. Including an intercept/mean formula in the model
automatically implies <code>meanstructure = TRUE</code>. The distinction between
observed variable intercepts and factor means is made automatically.
</p>
</li></ol>

<p>Usually, only a single variable name appears on the left side of an operator.
However, if multiple variable names are specified, separated by the &quot;+&quot;
operator, the formula is repeated for each element on the left side. For
instance, the formula
</p>
<pre>
 x1 + x2 + x3 + x4 ~ 1</pre>
<p>specifies an intercept for variables <code>x1, x2, x3</code> and <code>x4</code>.
</p>
<p>On the right-hand side of these formula-like expressions, each element can be
modified (using the <code>"*"</code> operator) by a numeric constant or the special
function start(). This provides the user with a mechanism to fix
parameters and provide alternative starting values, respectively. All
<code>"*"</code> expressions are referred to as modifiers, and are explained in
detail in the sections below.
</p>
<p>Each parameter in a model is automatically given a name consisting of three
parts, that are coerced to a single character vector. The first part is the
name of the variable on the left-hand side of the formula where the parameter
is implied. The middle part is based on the special &quot;operator&quot; used in the
formula (e.g., <code>"=~"</code>, <code>"~"</code> or <code>"~~"</code>). The third part is the
name of the variable on the right-hand side of the formula where the
parameter is implied, or &quot;1&quot; if it is an intercept. The three parts are
pasted together in a single string. For example, the name of the factor
loading of <code>x2</code> on <code>factor1</code> is the string <code>"factor1~x2"</code>.
The name of the parameter corresponding to the factor covariance between
<code>factor1</code> and <code>factor2</code> is the string <code>"factor1~~factor2"</code>.
</p>


<h4>Fixing parameters</h4>

<p>It is often desirable to fix a model parameter that is otherwise (by default)
estimated. Any parameter in a model can be fixed by using a modifier
resulting in a numerical constant. For instance:
</p>

<ul>
<li><p> Fixing factor loadings for scale setting or identification
restrictions:
</p>
<pre>
factor1 ~ 0.8*x1 + x2 + x3 +   0*x4 + x5 + x6
factor2 ~   0*x1 + x2 + x3 + 0.8*x4 + x5 + x6</pre>
</li>
<li><p> Specifying an orthogonal (zero) covariance between two factors:
</p>
<pre>factor1 ~~ 0*factor2</pre>
</li></ul>

<p>Notice that multiplying a certain parameter by <code>NA</code> forces it to be
estimated.
</p>



<h4>Starting values</h4>

<p>User-defined starting values can be provided through the special function
start(), containing a numeric constant. For instance, the formula below
provides a starting value equal to 0.8 to the loading of <code>x2</code> on
<code>factor1</code>.
</p>
<pre>
factor1 ~ x1 + start(0.8)*x2 + x3 + x4 + x5 + x6</pre>



<h4>Multiple groups</h4>

<p>In a multiple group factor analysis, the modifiers containing a single element
should be replaced by a vector of the same length as the number of groups.
If a single element is provided, it is used for all groups. In the
example below with two groups, the factor loadings of <code>x1</code> on
<code>factor1</code> are fixed to 0.8 in both groups, whereas the factor loadings
of <code>x4</code> are fixed to 0.75 and 0.85 in the first and second group,
respectively.
</p>
<pre>
multigroup_syntax &lt;- '
 factor1 ~  0.8*x1 + x2 + x3 +               x4 + x5 + x6
 factor2 ~      x1 + x2 + x3 + c(0.75, 0.85)*x4 + x5 + x6 '</pre>



<h3>Algorithm</h3>

<p>Penalized factor analysis allows to produce parsimonious models using largely
an automated procedure. The use of sparsity-inducing penalty functions leads
to optimally sparse factor structures supported by the data. The resulting
models are less prone to instability in the estimation process and are easier
to interpret and generalize than their unpenalized counterparts.
Multiple-group penalized factor analysis can be used to automatically
ascertain the differences and similarities of parameter estimates across
groups.
</p>
<p>In <code>penfa</code>, estimation is achieved via a penalized likelihood-based
framework that builds upon differentiable approximations of
non-differentiable penalties, a theoretically founded definition of degrees
of freedom, and an algorithm with automatic multiple tuning parameter
selection (see section below for details).
</p>
<p>The <code>penfa</code> function uses a
<a href="https://CRAN.R-project.org/package=trust"><code>trust-region</code></a>
algorithm approach. This strategy constructs a model function whose behavior
near the current point and within a trust-region (usually a ball) is similar
to that of the actual objective function. The algorithm exploits second-order
analytical derivative information. This can come in the form of the penalized
Hessian matrix (if <code>information = "hessian"</code>) or the penalized Fisher
information matrix (if <code>information = "fisher"</code>). Models with a
mean structure can be only estimated with the penalized Fisher information
matrix, which exhibits similar performances to the penalized Hessian at a
reduced computational cost. <br />
</p>


<h3>Tuning parameter selection</h3>

<p>The selection of the tuning parameters is a crucial issue in penalized
estimation strategies, as the tuning parameters are responsible for the
optimal balance between goodness of fit and sparsity.
</p>


<h4>Automatic procedure</h4>

<p>The penalized framework discussed above is easily integrated with automatic
multiple tuning parameter selection (if <code>strategy = "auto"</code>). The tuning
parameters are chosen to minimize an approximate AIC. See below for
additional details on how to introduce more sparsity, if desired. The
automatic procedure is fast, efficient, and scales well with the number of
tuning parameters. It also eliminates the need for time-consuming and
computationally intensive grid-searches.
</p>
<p><strong>Note:</strong> Only lasso, adaptive lasso and ridge penalties can be used
with the automatic procedure.
</p>
<p>The automatic procedure returns the optimal value of the tuning parameter.
Notice, however, that the parameter estimates from this model will slightly
differ from the ones one would obtain by setting <code>strategy = "fixed"</code> and
<code>eta</code> equal to that optimal tuning value. This is due to the different
starting values employed in the two scenarios. In the automatic procedure,
the starting values of the final model come from the ones of the previous
model in the optimization loop; in the fixed-tuning context, the starting
values come from the default ones in <code>penfa</code>.
</p>



<h4>Grid-search</h4>

<p>If <code>strategy = "fixed"</code>, <code>penfa</code> estimates a penalized factor model
with the value of the tuning parameter stored in <code>eta</code>. This is useful
if users wish to make multiple calls to the <code>penfa</code> function using a
range of values for the tuning parameter. Then, the optimal penalized model
can be picked on the basis of information criteria, which are easily computed
by calling the <code>AIC</code> and <code>BIC</code> functions. It is often convenient
to use the (Generalized) Bayesian Information Criterion as a selector, due to
its recurrent use in sparse settings.
</p>
<p>These information criteria use the theoretical definition of the effective
degrees of freedom (<em>edf</em>) as their bias terms. This is because the use
of differentiable penalty approximations make the objective function
twice-continuously differentiable. The total <code>edf</code> are as the sum of the
effective degree of freedom for each model parameter, which in turn ranges
from 0 to 1 and quantifies the extend to which each parameter has been
penalized. <br />
</p>



<h3>Penalization</h3>

<p>The <code>penfa</code> function penalizes every element in the parameter
matrix/vector specified in the <code>eta</code> argument. For instance, if
<code>eta = list("shrink" = c("lambda" = 0.01), "diff" = c("none" = 0))</code> all
factor loadings are penalized through a shrinkage penalty.
</p>


<h4>Choosing the penalty function</h4>

<p>It may be beneficial to try out different penalties, and see which one works
best for the problem at hand. It is also useful to keep the following in mind:
</p>

<ul>
<li> <p><strong>Shrinkage</strong>: lasso, alasso, scad, and mcp are able to shrink parameters
to zero, contrarily to the ridge penalty whose purpose is just regularizing
the estimation process.
</p>
</li>
<li> <p><strong>Unbiasedness</strong>: alasso, scad, and mcp enjoy the so-called &quot;oracle&quot;
property. On the contrary, the lasso is biased since it applies the same
penalization to all parameters.
</p>
</li>
<li> <p><strong>Automatic procedure:</strong> only lasso, alasso, and ridge are supported by the
automatic procedure. This means that these penalties are a convenient choice
with all the analyses requiring multiple penalty terms (e.g., multiple-group
analyses), for which the automatic procedure is the only feasible alternative
to otherwise computationally intensive multi-dimensional grid-searches.
</p>
</li></ul>

<p>Geminiani, Marra, and Moustaki (2021) performed numerical and
empirical examples to evaluate and compare the performance of single- and
multiple-group penalized factor models under different penalty functions. The
alasso penalty generally produced the best trade-off between sparsity and
goodness of fit. However, unlike other penalties, the alasso requires a set
of adaptive weights. In some situations, the weights might not be available,
or might be difficult to obtain. If this is the case, users are encouraged to
resort to simpler penalties. <br />
</p>



<h4>More sparsity</h4>

<p>The penalized model automatically tries to generate the optimal trade-off
between goodness of fit and model complexity (if <code>strategy = "auto"</code>).
As a result of this delicate balance, it may not provide the sparsest factor
solution. If users desire more sparsity, they can follow the guidelines
below.
</p>

<ul>
<li><p> Influence factor: increase the value of the influence factor stored in
the option <code>gamma</code>. As a rule of thumb, in our experience, common values
for obtaining sparse solutions usually range between 3.5 and 4.5.
</p>
</li>
<li><p> Penalties: some penalties rely on a second tuning parameter. It may be
helpful to try out different values for it, and see which one performs best.
For instance, increasing the value or the exponent of the alasso (by
specifying, for instance, <code>a.alasso = 2</code>) leads to sparser solutions. </p>
</li></ul>

<p>In case users fitted a penalized model with a fixed tuning parameter
(<code>strategy = "fixed"</code>), they can manually and subjectively increase its
value in the option <code>eta</code> to encourage more sparsity. When doing so, it
is helpful to first do some trials and understand a reasonable range of
values that the tuning parameter can take. <br />
</p>



<h4>Ordinary Maximum Likelihood</h4>

<p>If <code>strategy = "fixed"</code>, <code>pen.shrink = "none"</code>, <code>pen.diff =
"none"</code>, and <code>eta = list("shrink" = c("none" = 0), "diff" = c("none" =
0))</code>, no penalization is applied, and the model is estimated through ordinary
maximum likelihood. <br />
</p>



<h3>Convergence &amp; Admissibility</h3>

<p>The function <code>penfa</code> internally assesses the convergence of the fitted
model, and the admissibility of the final solution.
</p>


<h4>Convergence</h4>

<p>The convergence checks assess whether the penalized gradient vector is close
to zero and the penalized Hessian/Fisher information matrix is positive
definite. In case of convergence issues, <code>penfa</code> warns the users with
explanatory messages. <br /> <strong>Note:</strong> Due to the presence of possibly
multiple penalty terms, our experiments highlighted that the penalized
gradient need not be strictly close to zero to obtain meaningful results. It
is enough that its elements do not exceed a pre-specified threshold, whose
value can be changed through the <code>optim.dx.tol</code> option.
</p>



<h4>Admissibility</h4>

<p>The admissibility checks are carried out to determine whether the final
solution is <em>admissible</em>. Specifically, the <code>penfa</code> function
sequentially checks whether:
</p>

<ol>
<li><p> The final model includes any negative unique variances (Heywood cases);
</p>
</li>
<li><p> The final model includes any negative factor variances;
</p>
</li>
<li><p> The estimated common factor covariance matrix is positive definite;
</p>
</li>
<li><p> The estimated unique factor covariance matrix is positive definite;
</p>
</li>
<li><p> The estimated factor loading matrix is of full column rank;
</p>
</li>
<li><p> The estimated factor loading matrix does not contain any null rows.
</p>
</li></ol>

<p>In case of multiple-group analyses, the function checks the admissibility of
the parameter matrices of each group. If any of the above conditions are not
satisfied, the <code>penfa</code> function warns the user with explanatory
messages on the reasons why. <br />
</p>



<h3>Warnings &amp; Errors</h3>

<p>Occasionally the <code>penfa</code> function may print out warnings or produce
errors. If the errors concern convergence issues, it may be helpful to go
through the following steps:
</p>
 <ol>
<li><p> Identification: please make sure that at least the
minimum identification restrictions are satisfied. This implies fixing the
scale and the origin of every factor in each group. In addition, other
constraints - which usually come in the form of zero-restricted loadings -
are necessary due to rotational freedom.
</p>
</li>
<li><p> Starting values: the choice of the starting values is of paramount
importance when it comes to convergence. The starting values internally used
by <code>penfa</code> correspond to the ones used by the
<a href="https://CRAN.R-project.org/package=lavaan"><code>lavaan</code></a> package for
<code>confirmatory factor analysis</code>. If users have some prior knowledge or
intuition about possible values for some of the parameters, it might be
beneficial to include this information by providing the starting values for
those parameters in the syntax specification (see below for additional
details). For instance, depending on the case, specifying the starting values
of the primary loadings equal to 1 (<code>start(1)*x1 + ...</code>) often results
in more stable optimization processes, especially when dealing with
complicated models that require the estimation of many parameters, as in
multiple-group penalized factor analysis.
</p>
</li>
<li><p> Sample size: the penalized models fitted by <code>penfa</code> have
a larger number of parameters than confirmatory factor analytic applications.
This complexity should be accompanied by a reasonable sample size. If the
sample size is too small for the complexity of the model, convergence issues
will arise. In case of small sample sizes, it might in principle be more
reliable to select the tuning parameter through a grid-search with the GBIC
instead of using the automatic procedure.
</p>
</li>
<li><p> Automatic procedure: if the starting values of the tuning parameters
prevent the automatic procedure from finding the optimal estimates of the
tuning parameters, the procedure is repeated with different starting values.
If this fails, an error is printed out.
</p>
</li>
<li><p> Adaptive weights: when using the alasso penalty, it is suggested to
manually provide a vector of adaptive weights, especially for complex models.
The adaptive weights often come in the form of (unpenalized) maximum
likelihood estimates. If no vector of weights is provided, the <code>penfa</code>
function internally estimates an unpenalized MLE model whose parameter
estimates will serve as weights. If the unpenalized model does not converge,
the <code>penfa</code> function internally estimates a ridge-regularized factor
model and uses the resulting estimates as weights. If even this estimation
fails, an error is printed out. <br />
</p>
</li></ol>

<p>Ultimately, if none of the above succeeds, users shall consider re-specifying
the model, either by simplifying the hypothesized factor structure or
considering a subset of the observed variables. Increasing the number of
restrictions (for instance, by specifying some additional fixed loadings)
might be advantageous. Also, as a general practice, when conducting a
multiple-group analysis, make sure beforehand that the groups share similar
factor structures: if the groups have different factor configurations, the
final results will be distorted.
</p>
<p>It is always important to assess whether the distributional assumptions of
the normal linear factor model hold. The <code>penfa</code> function fits penalized
factor models to continuous observed variables; this excludes categorical
items or items with a few number of categories that would instead require
tailored approaches that specifically take into account the qualitative
nature of the data. <br />
</p>


<h3>Standard Errors</h3>

<p>The standard errors are derived from the inverse of the penalized Fisher
information matrix (if <code>information = "fisher"</code>) or penalized Hessian
(if <code>information = "hessian"</code>), which relies on the Bayesian result for
the covariance matrix of the estimated parameters. The implemented framework
allows to have a standard error for every model parameter. However, users
should take extra caution when using the standard errors associated with the
penalized parameters that were shrunken to zero. <br />
</p>


<h3>Vignettes and Tutorials</h3>

<p>To learn more about <code>penfa</code>, start with the vignettes and tutorials at
<code>browseVignettes(package = "penfa")</code> and
<a href="https://egeminiani.github.io/penfa/articles/">https://egeminiani.github.io/penfa/articles/</a>.
</p>


<h3>Author(s)</h3>

<p>Elena Geminiani <a href="mailto:geminianielena@gmail.com">geminianielena@gmail.com</a>.
</p>


<h3>References</h3>

<p>Geminiani, E., Marra, G., &amp; Moustaki, I. (2021). &quot;Single- and Multiple-Group
Penalized Factor Analysis: A Trust-Region Algorithm Approach with Integrated
Automatic Multiple Tuning Parameter Selection.&quot; Psychometrika, 86(1), 65-95.
doi: <a href="https://doi.org/10.1007/s11336-021-09751-8">10.1007/s11336-021-09751-8</a>
</p>
<p>Geminiani E. (2020), &quot;A penalized likelihood-based framework for single and
multiple-group factor analysis models&quot; (Doctoral dissertation, University of
Bologna). Available at <a href="http://amsdottorato.unibo.it/9355/">http://amsdottorato.unibo.it/9355/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+penfa-class">penfa-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ccdata)

### Single-group analysis (no mean-structure, unit factor variances)
syntax = 'help  =~   h1 + h2 + h3 + h4 + h5 + h6 + h7 + 0*v1 + v2 + v3 + v4 + v5
          voice =~ 0*h1 + h2 + h3 + h4 + h5 + h6 + h7 +   v1 + v2 + v3 + v4 + v5'

alasso_fit &lt;- penfa(## factor model
                    model  = syntax,
                    data   = ccdata,
                    std.lv = TRUE,
                    ## penalization
                    pen.shrink = "alasso",
                    eta = list(shrink = c("lambda" = 0.01), diff = c("none" = 0)),
                    ## automatic procedure
                    strategy = "auto",
                    gamma = 4)



### Multiple-group analysis (mean structure, marker-variable approach, starting values)
syntax_mg = '
help  =~ 1*h1 +          h2 +          h3 + h4 + h5 + h6 + h7 + 0*v1 + v2 + v3 + v4 + v5
voice =~ 0*h1 + start(0)*h2 + start(0)*h3 + h4 + h5 + h6 + h7 + 1*v1 + v2 + v3 + v4 + v5
h1 + v1 ~ 0*1 '

# Compute weights for alasso from unpenalized model
mle_fitMG &lt;- penfa(model = syntax_mg,
                   data  = ccdata,
                   group = "country",
                   int.ov.free = TRUE,
                   int.lv.free = TRUE,
                   pen.shrink = "none",
                   pen.diff = "none",
                   eta = list(shrink = c("lambda" = 0), diff = c("none" = 0)),
                   strategy = "fixed")
mle_weightsMG &lt;- coef(mle_fitMG)

# Fit model
alasso_fitMG &lt;- penfa(## factor model
                      model = syntax_mg,
                      data = ccdata,
                      group = "country",
                      int.ov.free = TRUE,
                      int.lv.free = TRUE,
                      ## penalization
                      pen.shrink = "alasso",
                      pen.diff = "alasso",
                      eta = list(shrink = c("lambda" = 0.01),
                      diff = c("lambda" = 0.1, "tau" = 0.01)),
                      ## automatic procedure
                      strategy = "auto",
                      gamma = 4,
                      ## alasso
                      weights = mle_weightsMG)

### For additional examples, see the vignettes and tutorials at
### browseVignettes(package = "penfa") and https://egeminiani.github.io/penfa/articles/


</code></pre>

<hr>
<h2 id='penfa-class'>S4 Class for describing a <code>penfa</code> model</h2><span id='topic+penfa-class'></span>

<h3>Description</h3>

<p>The <code>penfa</code> class represents a (fitted) penalized factor
analysis model. It contains a description of the model as specified by the
user, a summary of the data, an internal matrix representation, the
fitting results, and the penalized quantities.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created via the <code><a href="#topic+penfa">penfa</a></code> function.
</p>


<h3>Slots</h3>


<dl>
<dt><code>version</code>:</dt><dd><p>The <code>penfa</code> package version used to create this object.</p>
</dd>
<dt><code>call</code>:</dt><dd><p>The function call as returned by <code>match.call()</code>.</p>
</dd>
<dt><code>timing</code>:</dt><dd><p>The elapsed time (user + system) for various parts of
the program as a list, including the total time.</p>
</dd>
<dt><code>Options</code>:</dt><dd><p>Named list of options that were provided by the user
or filled-in automatically. See <code><a href="#topic+penfaOptions">penfaOptions</a></code> for additional
details.</p>
</dd>
<dt><code>ParTable</code>:</dt><dd><p>Named list describing the model parameters.
Can be coerced to a data.frame. This is also called &quot;parameter table&quot;.
It includes information on the fixed, free and penalized parameters, their
indices, the active penalization strategies (&quot;none&quot;, &quot;shrink&quot;, &quot;diff&quot;, or
&quot;shrink + diff&quot;), the starting values, the estimated parameters and the
associated standard errors.</p>
</dd>
<dt><code>pta</code>:</dt><dd><p>Named list containing parameter table attributes, like
observed and latent variable names, their indices, and the number of groups.</p>
</dd>
<dt><code>Data</code>:</dt><dd><p>Object of internal class <code>"penfaData"</code>; contains
information about the data set. See the <code><a href="#topic+penfaData-class">penfaData</a></code> class
for additional details.</p>
</dd>
<dt><code>SampleStats</code>:</dt><dd><p>Object of internal class <code>"penfaSampleStats"</code>;
contains the sample statistics. See the <code><a href="#topic+penfaSampleStats-class">penfaSampleStats</a></code>
class for additional details.</p>
</dd>
<dt><code>Model</code>:</dt><dd><p>Object of internal class <code>"penfaModel"</code>: the internal
(matrix) representation of the model. See the <code><a href="#topic+penfaModel-class">penfaModel</a></code>
class for additional details.</p>
</dd>
<dt><code>Optim</code>:</dt><dd><p>List. Information about the optimization process. This
includes the estimated parameters (<code>x</code>), the number of estimated
parameters (<code>npar</code>), the number of trust-region iterations
(<code>iterations</code>), the value of the penalized objective function
(<code>fx.pen</code>), the value of the unpenalized objective
function (<code>fx.unpen</code>), the penalized log-likelihood (<code>logl.pen</code>;
this is equal to <code>fx.pen</code> multiplied by (-1)), the unpenalized
log-likelihood (<code>logl.unpen</code>; this is equal to <code>fx.unpen</code> multiplied
by (-1)), the penalized gradient (<code>dx.pen</code>), the penalized Hessian/Fisher
information matrix (<code>hessian.pen</code>), the list of control arguments for
the trust-region algorithm (<code>control</code>), and how many times the
objective function became non-positive definite during the estimation
process (<code>npd</code>). If penfa was called with the option <code>verbose =
 TRUE</code>, the following additional arguments coming from the trust-region
function <code>trust</code> are reported in the <code>Optim</code> slot: <code>argpath</code>,
<code>argtry</code>, <code>type</code>, <code>accept</code>, <code>radii</code>, <code>rho</code>,
<code>fx.val</code>, <code>fx.valtry</code>, <code>change</code>, <code>stepnorm</code>. See the
manual page of <code>trust</code> from the <code>trust</code> package for an overview of
these quantities.</p>
</dd>
<dt><code>Penalize</code>:</dt><dd><p>Object of internal class <code>"penfaPenalty"</code>; contains
information about the penalization. See the <code><a href="#topic+penfaPenalty-class">penfaPenalty</a></code> for
additional details.</p>
</dd>
<dt><code>Implied</code>:</dt><dd><p>List. Model-implied moments (covariance matrix and
mean vector).</p>
</dd>
<dt><code>Vcov</code>:</dt><dd><p>List. Information about the covariance matrix (vcov) of
the model parameters. This slot includes the following quantities:  the type
of penalized information matrix used in the model (either Hessian or Fisher;
<code>information</code>), the vcov matrix of parameters (<code>vcov</code>), whether
the convergence checks on the penalized gradient and the penalized
information matrix were satisfied (<code>solution</code>), whether the employed
information matrix was positive-definite (<code>pdef</code>),  whether the
estimated factor solution was admissible (<code>admissibility</code>), the
standard errors computed according to the Bayesian result from the
information matrix reported in <code>information</code> (<code>se</code>), and the 95%
confidence intervals (<code>ci</code>).</p>
</dd>
<dt><code>Inference</code>:</dt><dd><p>List. Information on effective degrees of the model
and information criteria for model selection. This slot reports the
following quantities: effective degree of freedom for each parameter
(<code>edf.single</code>), total edf (<code>edf</code>), influence matrix
(<code>influence.mat</code>), generalized information criteria (<code>IC</code>), such
as AIC and BIC.</p>
</dd>
<dt><code>external</code>:</dt><dd><p>List. Empty slot.</p>
</dd>
</dl>



<h3>Methods</h3>

<p>The following methods are available for an object of class
<code><a href="#topic+penfa-class">penfa</a></code>:
</p>

<dl>
<dt>show</dt><dd><p><code>signature(object = "penfa")</code>: Prints a short summary of the
estimation process, including the optimization method, the specified penalty
functions, the convergence status, the number of iterations, the tuning
selection strategy, and the effective degrees of freedom. See the manual page of
<code>show,penfa-method</code> for details. </p>
</dd> <dt>summary</dt><dd><p><code>signature(object
= "penfa", header = TRUE, estimates = TRUE, ci = TRUE, level =</code> <code> 0.95,
nd = 3L, cutoff = 0.05, extra = TRUE)</code>: Prints a summary of the model
parameter estimates, and the optimization process. See the manual page of
<code>summary,penfa-method</code> for details.</p>
</dd> <dt>coef</dt><dd><p><code>signature(object
= "penfa", type = "free", labels = TRUE)</code>: Returns the estimates of the
parameters in the model as a named numeric vector. See the manual page of
<code>coef,penfa-method</code> for details.</p>
</dd> <dt>fitted</dt><dd><p><code>signature(object =
"penfa", labels = TRUE)</code>: Returns a list of the model-implied moments (per
group). See the manual page of <code>fitted,penfa-method</code> for details.</p>
</dd>
</dl>



<h3>References</h3>

<p>Geminiani, E., Marra, G., &amp; Moustaki, I. (2021). &quot;Single- and
Multiple-Group Penalized Factor Analysis: A Trust-Region Algorithm Approach
with Integrated Automatic Multiple Tuning Parameter Selection.&quot;
Psychometrika, 86(1), 65-95. doi: <a href="https://doi.org/10.1007/s11336-021-09751-8">10.1007/s11336-021-09751-8</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+penfa">penfa</a></code>, <code><a href="#topic+penfaParEstim">penfaParEstim</a></code>
</p>

<hr>
<h2 id='penfaData-class'>S4 Class for describing the input data</h2><span id='topic+penfaData-class'></span>

<h3>Description</h3>

<p>The <code>penfaData</code> class gives information on the data set
provided in input for analysis. This class is an adaptation of the
<code>lavData</code> class from the
<a href="https://CRAN.R-project.org/package=lavaan">lavaan</a> package.
</p>


<h3>Slots</h3>


<dl>
<dt><code>ngroups</code></dt><dd><p>Integer. The number of groups.</p>
</dd>
<dt><code>group</code></dt><dd><p>Character. The observed variables defining the groups.</p>
</dd>
<dt><code>group.label</code></dt><dd><p>Character. The group labels, that is, the values of the
<code>group</code> variable, if any.</p>
</dd>
<dt><code>std.ov</code></dt><dd><p>Logical indicating whether the observed variables should be
standardized.</p>
</dd>
<dt><code>nobs</code></dt><dd><p>List of the effective number of observations in each group.</p>
</dd>
<dt><code>norig</code></dt><dd><p>List of the original number of observations in each group.</p>
</dd>
<dt><code>ov.names</code></dt><dd><p>List of the observed variable names in each group.</p>
</dd>
<dt><code>ov</code></dt><dd><p>List of details at the observed variable level.</p>
</dd>
<dt><code>case.idx</code></dt><dd><p>List of the case (i.e., observation) indices in each group.</p>
</dd>
<dt><code>X</code></dt><dd><p>List. Local copy of the input data set split into groups.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+penfa">penfa</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ccdata)

syntax = 'help  =~   h1 + h2 + h3 + h4 + h5 + h6 + h7 + 0*v1 + v2 + v3 + v4 + v5
          voice =~ 0*h1 + h2 + h3 + h4 + h5 + h6 + h7 +   v1 + v2 + v3 + v4 + v5'

alasso_fit &lt;- penfa(## factor model
                    model  = syntax,
                    data   = ccdata,
                    std.lv = TRUE,
                    ## penalization
                    pen.shrink = "alasso",
                    eta = list(shrink = c("lambda" = 0.01), diff = c("none" = 0)),
                    ## automatic procedure
                    strategy = "auto")

alasso_fit@Data
str(alasso_fit@Data)


</code></pre>

<hr>
<h2 id='penfaModel-class'>S4 Class for internal representation of a factor model</h2><span id='topic+penfaModel-class'></span>

<h3>Description</h3>

<p>The <code>penfaModel</code> class gives the internal matrix
representation of a factor analysis model. Note that this representation
summarizes the characteristics of the model itself (e.g., number of items,
number of factors, parameter indices, etc), without information on the
penalization process (see <code><a href="#topic+penfaPenalty-class">penfaPenalty</a></code> for that
aspect). This class is an adaptation of the <code>lavModel</code> class from the
<a href="https://CRAN.R-project.org/package=lavaan">lavaan</a> package.
</p>


<h3>Slots</h3>


<dl>
<dt><code>GLIST</code></dt><dd><p>List. The model matrices and vectors: &quot;lambda&quot; for the factor
loading matrix, &quot;psi&quot; for the covariance matrix of the unique factors,
&quot;phi&quot; for the covariance matrix of the common factors, &quot;tau&quot; for the
intercept vector, and &quot;kappa&quot; for the vector of factor means. In case of a
multiple-group analysis, the elements of each group are presented
sequentially.</p>
</dd>
<dt><code>dimNames</code></dt><dd><p>List. Dimension names (row names and column names) of every
model matrix and vector.</p>
</dd>
<dt><code>isSymmetric</code></dt><dd><p>Logical vector declaring whether each model matrix/vector
is symmetric.</p>
</dd>
<dt><code>mmSize</code></dt><dd><p>Integer vector specifying the size (unique elements only) of
each model matrix/vector.</p>
</dd>
<dt><code>meanstructure</code></dt><dd><p>Logical. It declares whether the model includes a
meanstructure.</p>
</dd>
<dt><code>ngroups</code></dt><dd><p>Integer. The number of groups.</p>
</dd>
<dt><code>nmat</code></dt><dd><p>Integer vector specifying the number of model matrices/vectors for
each group.</p>
</dd>
<dt><code>nvar</code></dt><dd><p>Integer vector specifying the number of observed variables in each
group.</p>
</dd>
<dt><code>num.idx</code></dt><dd><p>List of the indices of the observed variables in each group.</p>
</dd>
<dt><code>nx.free</code></dt><dd><p>Integer. The number of parameters of the factor model. This
count does not include the fixed parameters, but it does include the
parameters that will be penalized (if any) during optimization. (see
<code><a href="#topic+penfaPenalty-class">penfaPenalty</a></code> for additional details in this respect).</p>
</dd>
<dt><code>nx.user</code></dt><dd><p>Integer. The total count of the parameters that are being
estimated and the ones that have been fixed.</p>
</dd>
<dt><code>m.free.idx</code></dt><dd><p>List. For each model matrix, the indices of the elements to
be estimated (i.e., non-fixed). The counter starts at 1 for every model
matrix.</p>
</dd>
<dt><code>x.free.idx</code></dt><dd><p>List. For each model matrix, the indices of the elements to
be estimated (i.e., non-fixed). The counter continues from the previous
model matrix.</p>
</dd>
<dt><code>m.user.idx</code></dt><dd><p>List. Much like <code>m.free.idx</code>, but it also contains the
indices of the parameters that have been fixed by the user.</p>
</dd>
<dt><code>x.user.idx</code></dt><dd><p>List. Much like <code>x.free.idx</code>, but it also contains the
indices of the parameters that have been fixed by the user.</p>
</dd>
<dt><code>x.free.var.idx</code></dt><dd><p>Vector of integers denoting the indices corresponding to
the unique variances.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+penfa">penfa</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ccdata)

syntax = 'help  =~   h1 + h2 + h3 + h4 + h5 + h6 + h7 + 0*v1 + v2 + v3 + v4 + v5
          voice =~ 0*h1 + h2 + h3 + h4 + h5 + h6 + h7 +   v1 + v2 + v3 + v4 + v5'

alasso_fit &lt;- penfa(## factor model
                    model  = syntax,
                    data   = ccdata,
                    std.lv = TRUE,
                    ## penalization
                    pen.shrink = "alasso",
                    eta = list(shrink = c("lambda" = 0.01), diff = c("none" = 0)),
                    ## automatic procedure
                    strategy = "auto")

alasso_fit@Model

</code></pre>

<hr>
<h2 id='penfaOptions'><code>penfa</code> Options</h2><span id='topic+penfaOptions'></span>

<h3>Description</h3>

<p>The default options internally used by the <code><a href="#topic+penfa">penfa</a></code>
function. These options can be changed by passing &quot;name = value&quot; arguments to
the <code>penfa</code> function call, where they are being added to the &quot;...&quot;
argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>penfaOptions(
  opt = list(meanstructure = FALSE, int.ov.free = FALSE, int.lv.free = FALSE,
    orthogonal = FALSE, std.lv = FALSE, auto.fix.first = FALSE, auto.fix.single = FALSE,
    std.ov = FALSE, information = "fisher", control = list(), optim.dx.tol = 100, a.scad
    = 3.7, a.mcp = 3, a.alasso = 1, weights = NULL, cbar = 1e-08, gamma = 4, user.start =
    FALSE, start.val = c(), verbose = TRUE, warn = TRUE, debug = FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="penfaOptions_+3A_opt">opt</code></td>
<td>
<p>List of default options. See below for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following section details the full list of options currently
accepted by the <code>penfa</code> function.
</p>
<p>Model features:
</p>

<dl>
<dt><code>meanstructure</code>:</dt><dd><p>Logical. If <code>TRUE</code>, a meanstructure is
requested. It should be used in conjunction with <code>int.ov.free</code> and
<code>int.lv.free</code> or intercept-like formulas in the model syntax.
Default to <code>FALSE</code>.</p>
</dd>
<dt><code>int.ov.free</code>:</dt><dd><p>Logical. If <code>FALSE</code>, the intercepts of the
observed variables are fixed to zero. Default to <code>FALSE</code>.</p>
</dd>
<dt><code>int.lv.free</code>:</dt><dd><p>Logical. If <code>FALSE</code>, the intercepts of the
common factors are fixed to zero. Default to <code>FALSE</code>.</p>
</dd>
<dt><code>orthogonal</code>:</dt><dd><p>Logical. If <code>TRUE</code>, all covariances among the
common factors are set to zero. Default to <code>FALSE</code>.</p>
</dd>
<dt><code>std.lv</code>:</dt><dd><p>Logical. If <code>TRUE</code>, the factor variances are fixed
to 1.0. Default to <code>FALSE</code>.</p>
</dd>
<dt><code>auto.fix.first</code>:</dt><dd><p>Logical. If <code>TRUE</code>, the factor loading of
the first indicator is set to 1.0 for every factor. Default to <code>FALSE</code>.</p>
</dd>
<dt><code>auto.fix.single</code>:</dt><dd><p>Logical. If <code>TRUE</code>, the residual variance
(if included) of an observed indicator is set to zero if it is the only
indicator of a common factor. Default to <code>FALSE</code>.</p>
</dd>
</dl>

<p>Data options:
</p>

<dl>
<dt><code>std.ov</code>:</dt><dd><p>Logical. If <code>TRUE</code>, all observed variables are
standardized before entering the analysis. Default to <code>FALSE</code>.</p>
</dd>
</dl>

<p>Estimation and optimization:
</p>

<dl>
<dt><code>information</code>:</dt><dd><p>Character. If <code>"fisher"</code>, the penalized
expected Fisher information matrix is used as second-order derivatives
in the trust-region algorithm and for computing the standard errors of the
model parameters. If <code>"hessian"</code>, the penalized Hessian matrix
is used. Default to <code>"fisher"</code>.</p>
</dd>
<dt><code>control</code>:</dt><dd><p>A list containing control parameters passed to the
trust-region optimizer. See the manual page of <code>trust</code> from the
<code>trust</code> package for an overview of its control parameters. Default
values for these parameters are <code>rinit=1L</code>, <code>rmax=100L</code>,
<code>iterlim=1000L</code>, <br /> <code>fterm = sqrt(.Machine$double.eps)</code>,
<code>mterm = sqrt(.Machine$double.eps)</code>. </p>
</dd>
<dt><code>optim.dx.tol</code></dt><dd><p>Numeric. The tolerance value used when checking
the size of the elements of the gradient of the objective function. Default
equal to 100.</p>
</dd>
</dl>

<p>Penalization:
</p>

<dl>
<dt><code>a.scad</code></dt><dd><p>Numeric. The shape parameter for the scad penalty.
Default to 3.7, as recommended by Fan &amp; Li (2001).</p>
</dd>
<dt><code>a.mcp</code></dt><dd><p>Numeric. The shape parameter of the mcp penalty. Default
to 3.</p>
</dd>
<dt><code>a.alasso</code></dt><dd><p>Numeric. The exponent in the adaptive weights for the
alasso penalty. Default to 1.</p>
</dd>
<dt><code>weights</code></dt><dd><p>Numeric. Only valid when either <code>pen.shrink</code> or
<code>pen.diff</code> is equal to &quot;alasso&quot;. An optional vector of values provided
by the user representing a consistent estimate for each model parameter. The
vector is then internally used for computing the adaptive weights. If
unspecified, the maximum likelihood estimates (MLE) from the unpenalized
model are used. </p>
</dd>
<dt><code>cbar</code></dt><dd><p>Numeric. Numerical constant used in the local approximation
of the penalty functions. Default to 1e-08.</p>
</dd>
</dl>
<p>Automatic procedure:
</p>
<dl>
<dt><code>gamma</code></dt><dd><p>Numeric. The value of the influence factor used in the
automatic tuning parameter procedure. Default to 4.</p>
</dd>
<dt><code>user.start</code></dt><dd><p>Logical whether the user has provided a vector of
starting values for the model parameter estimates. </p>
</dd>
<dt><code>start.val</code></dt><dd><p>Numeric. An optional vector of parameter estimates to
be used as starting values for the model parameters. This option is also
internally used by the automatic procedure.</p>
</dd>
</dl>

<p>Verbosity options:
</p>

<dl>
<dt><code>verbose</code>:</dt><dd><p>Logical. If <code>TRUE</code>, some information on the
estimation process (e.g., convergence and admissibility checks, effective
degrees of freedom) are printed out. Default to <code>TRUE</code>.</p>
</dd>
<dt><code>warn</code>:</dt><dd><p>Logical. If <code>TRUE</code>, some warnings are printed out
during the iterations. Default to <code>TRUE</code>.</p>
</dd>
<dt><code>debug</code>:</dt><dd><p>Logical. If <code>TRUE</code>, debugging information is
printed out. Default to <code>FALSE</code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A list of default options internally used by the <code><a href="#topic+penfa">penfa</a></code>
function.
</p>

<hr>
<h2 id='penfaOut'>Print estimated parameter matrices</h2><span id='topic+penfaOut'></span>

<h3>Description</h3>

<p>A utility that extracts the estimated parameter matrices
and vectors of the penalized factor model for each group and rounds them to
the specified number of decimal digits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>penfaOut(
  object,
  which = c("lambda", "psi", "phi", "tau", "kappa"),
  ...,
  nd = 3L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="penfaOut_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+penfa-class">penfa</a></code>, that is, a
fitted penalized factor model.</p>
</td></tr>
<tr><td><code id="penfaOut_+3A_which">which</code></td>
<td>
<p>Character denoting the name of the estimated matrix or vector to
display. Possible values are &quot;lambda&quot;, &quot;psi&quot;, &quot;phi&quot;, &quot;tau&quot;, and &quot;kappa&quot;.
Multiple elements can be specified. By default, all estimated matrices are
shown.</p>
</td></tr>
<tr><td><code id="penfaOut_+3A_...">...</code></td>
<td>
<p>Additional options.</p>
</td></tr>
<tr><td><code id="penfaOut_+3A_nd">nd</code></td>
<td>
<p>The number of decimal digits to be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of the estimated parameter matrices and vectors for each group.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+penfa">penfa</a></code>
</p>

<hr>
<h2 id='penfaParEstim'>Print parameter estimates in table format</h2><span id='topic+penfaParEstim'></span>

<h3>Description</h3>

<p>The parameter estimates of the penalized factor analysis model
in each group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>penfaParEstim(
  object,
  se = TRUE,
  ci = TRUE,
  level = 0.95,
  remove.nonfree = FALSE,
  output = "data.frame",
  header = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="penfaParEstim_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+penfa-class">penfa</a></code>.</p>
</td></tr>
<tr><td><code id="penfaParEstim_+3A_se">se</code></td>
<td>
<p>Logical. If <code>TRUE</code>, it includes a column with the standard
errors.</p>
</td></tr>
<tr><td><code id="penfaParEstim_+3A_ci">ci</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the confidence intervals are added to the
output.</p>
</td></tr>
<tr><td><code id="penfaParEstim_+3A_level">level</code></td>
<td>
<p>The confidence level, default is 0.95.</p>
</td></tr>
<tr><td><code id="penfaParEstim_+3A_remove.nonfree">remove.nonfree</code></td>
<td>
<p>Logical. If <code>TRUE</code>, it filters the output and
removes all rows with fixed (that is, neither free, nor penalized)
parameters.</p>
</td></tr>
<tr><td><code id="penfaParEstim_+3A_output">output</code></td>
<td>
<p>Character. If &quot;data.frame&quot;, the parameter table is displayed as
a standard formatted data.frame. If &quot;text&quot;, the parameter table is
displayed with subsections (as used by the <code>summary</code> function).</p>
</td></tr>
<tr><td><code id="penfaParEstim_+3A_header">header</code></td>
<td>
<p>Logical, only used if <code>output = "text"</code>. If <code>TRUE</code>,
it prints a header on top of the parameter list with details on the group
levels and the information matrix used during optimization by the
trust-region algorithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of class <code>penfa.data.frame</code> with the parameter
estimates of a <code>penfa</code> model for each group.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+penfa">penfa</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ccdata)

syntax = 'help  =~   h1 + h2 + h3 + h4 + h5 + h6 + h7 + 0*v1 + v2 + v3 + v4 + v5
          voice =~ 0*h1 + h2 + h3 + h4 + h5 + h6 + h7 +   v1 + v2 + v3 + v4 + v5'

alasso_fit &lt;- penfa(## factor model
                    model  = syntax,
                    data   = ccdata,
                    std.lv = TRUE,
                    ## penalization
                    pen.shrink = "alasso",
                    eta = list(shrink = c("lambda" = 0.01), diff = c("none" = 0)),
                    ## automatic procedure
                    strategy = "auto")

penfaParEstim(alasso_fit)

</code></pre>

<hr>
<h2 id='penfaPenalty-class'>S4 Class for describing the penalization process</h2><span id='topic+penfaPenalty-class'></span>

<h3>Description</h3>

<p>The <code>penfaPenalty</code> class provides information on the
penalization process, such as the user-specified penalty functions, the
optimal values of the tuning parameters, and the penalty matrices at
convergence.
</p>


<h3>Slots</h3>


<dl>
<dt><code>strategy</code></dt><dd><p>Character. The strategy used for the selection of the tuning
parameter(s). If <code>strategy = "auto"</code>, the optimal values of the tuning
parameters are determined via the automatic tuning parameter procedure; if
<code>strategy = "fixed"</code>, a penalized factor model with the values of the
tuning parameters stored in the option <code>eta</code> is estimated.</p>
</dd>
<dt><code>penalty</code></dt><dd><p>List. A list of the user-specified penalty functions for
sparsity (&quot;shrink&quot;) and parameter equivalence (&quot;diff&quot;).</p>
</dd>
<dt><code>tuning</code></dt><dd><p>List. A named list containing the optimal values of the tuning
parameter(s) if <code>strategy = "auto"</code> or the user-specified fixed
values of the tuning parameter(s) if <code>strategy = "fixed"</code>. The list
has two components with names &quot;shrink&quot; and &quot;diff&quot;, and refers to the tuning
parameters used for shrinkage and group equivalence, respectively. The
components of the list are, in turn, the named vectors specifying the type
of parameter matrices or vectors that were penalized.</p>
</dd>
<dt><code>pmat</code></dt><dd><p>List. A named list containing the names of the parameter matrices
and vectors that were penalized for sparsity (&quot;shrink&quot;) and/or group
equivalence (&quot;diff&quot;).</p>
</dd>
<dt><code>pen.idx</code></dt><dd><p>List. A named list with the indices of the parameters that were
penalized for sparsity (&quot;shrink&quot;) and/or group equivalence (&quot;diff&quot;).</p>
</dd>
<dt><code>Sh.info</code></dt><dd><p>List. A list of the penalization terms, vectors and matrices
evaluated at the optimal values of the tuning parameters. In particular,
its argument <code>S.h</code> returns the estimated penalty matrix. If the factor
model is penalized only through a shrinkage penalty (i.e.,
<code>pen.shrink</code> is not <code>'none'</code>), and there is no penalization on
the differences (i.e., <code>pen.diff = 'none'</code>), then <code>S.h</code> is a
diagonal matrix whose elements precisely quantify the extent to which each
model parameter has been penalized.</p>
</dd>
<dt><code>extra</code></dt><dd><p>List. A list possibly containing additional information on the
penalization process, such as the hyperparameter values for some penalty
functions (e.g., for the alasso, the value of the exponent and the adaptive
weights.)</p>
</dd>
<dt><code>automatic</code></dt><dd><p>List. If <code>strategy = "auto"</code>, it contains information on
the automatic multiple tuning parameter procedure, such as the optimal
values of the tuning parameters, the convergence status, the specified
value of the influence factor, the number of necessary iterations, and the
tolerance level.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+penfa">penfa</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ccdata)

syntax = 'help  =~   h1 + h2 + h3 + h4 + h5 + h6 + h7 + 0*v1 + v2 + v3 + v4 + v5
          voice =~ 0*h1 + h2 + h3 + h4 + h5 + h6 + h7 +   v1 + v2 + v3 + v4 + v5'

alasso_fit &lt;- penfa(## factor model
                    model  = syntax,
                    data   = ccdata,
                    std.lv = TRUE,
                    ## penalization
                    pen.shrink = "alasso",
                    eta = list(shrink = c("lambda" = 0.01), diff = c("none" = 0)),
                    ## automatic procedure
                    strategy = "auto")

alasso_fit@Penalize

str(alasso_fit@Penalize)

</code></pre>

<hr>
<h2 id='penfaPredict'>Compute the factor scores from a fitted <code>penfa</code> model</h2><span id='topic+penfaPredict'></span>

<h3>Description</h3>

<p>The <code>penfaPredict</code> function estimates the factor scores
from a fitted penalized factor model. The factor scores are the estimated
values (&quot;predictions&quot;) of the common factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>penfaPredict(
  object,
  newdata = NULL,
  method = "regression",
  label = TRUE,
  append.data = FALSE,
  assemble = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="penfaPredict_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+penfa-class">penfa</a></code>.</p>
</td></tr>
<tr><td><code id="penfaPredict_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame containing the same variables as the
ones appearing in the original data frame used for fitting the model in
<code>object</code>.</p>
</td></tr>
<tr><td><code id="penfaPredict_+3A_method">method</code></td>
<td>
<p>Character indicating the method for computing the factor
scores. Possible options are <code>"regression"</code> and <code>"bartlett"</code>. For
the normal linear continuous case, the regression method is equivalent to
the Empirical Bayes Method (EBM), whereas Bartlett's strategy is equivalent
to maximum likelihood's method.</p>
</td></tr>
<tr><td><code id="penfaPredict_+3A_label">label</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the columns are labeled.</p>
</td></tr>
<tr><td><code id="penfaPredict_+3A_append.data">append.data</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the original data set (or the
data set provided in the <code>newdata</code> argument) is appended to the factor
scores.</p>
</td></tr>
<tr><td><code id="penfaPredict_+3A_assemble">assemble</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the factor scores from each group
are assembled in a single data frame of the same dimensions as the original
data set and with a group column defining the groups.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the factor scores from a fitted <code>penfa</code> model.
</p>


<h3>References</h3>

<p>Geminiani E. (2020), &quot;A penalized likelihood-based framework for
single and multiple-group factor analysis models&quot; (Doctoral dissertation,
University of Bologna). Available at
<a href="http://amsdottorato.unibo.it/9355/">http://amsdottorato.unibo.it/9355/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+penfa">penfa</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ccdata)

syntax = 'help  =~   h1 + h2 + h3 + h4 + h5 + h6 + h7 + 0*v1 + v2 + v3 + v4 + v5
          voice =~ 0*h1 + h2 + h3 + h4 + h5 + h6 + h7 +   v1 + v2 + v3 + v4 + v5'

alasso_fit &lt;- penfa(## factor model
                    model  = syntax,
                    data   = ccdata,
                    std.lv = TRUE,
                    ## penalization
                    pen.shrink = "alasso",
                    eta = list(shrink = c("lambda" = 0.01), diff = c("none" = 0)),
                    ## automatic procedure
                    strategy = "auto",
                    gamma = 4)

fscores &lt;- penfaPredict(alasso_fit)

</code></pre>

<hr>
<h2 id='penfaSampleStats-class'>S4 Class for describing the sample moments</h2><span id='topic+penfaSampleStats-class'></span>

<h3>Description</h3>

<p>The <code>penfaSampleStats</code> class provides information on the
sample moments of the factor analysis model. This
class is an adaptation of the <code>lavSampleStats</code> class from the
<a href="https://CRAN.R-project.org/package=lavaan">lavaan</a> package.
</p>


<h3>Slots</h3>


<dl>
<dt><code>var</code></dt><dd><p>List of the variances of the observed variables in every group.</p>
</dd>
<dt><code>cov</code></dt><dd><p>List of the covariance matrices of the observed variables
in every group.</p>
</dd>
<dt><code>mean</code></dt><dd><p>List of the means of the observed variables in every group.</p>
</dd>
<dt><code>group.w</code></dt><dd><p>List of group weights.</p>
</dd>
<dt><code>nobs</code></dt><dd><p>List of the effective number of observations for every group.</p>
</dd>
<dt><code>ntotal</code></dt><dd><p>Integer. Total number of observations across all groups.</p>
</dd>
<dt><code>ngroups</code></dt><dd><p>Integer. Number of groups.</p>
</dd>
<dt><code>icov</code></dt><dd><p>List of the inverse matrices of the covariance matrices of the
observed variables in every group.</p>
</dd>
<dt><code>cov.log.det</code></dt><dd><p>List of the logarithms of the determinants of the
covariance matrices of the observed variables for every group.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+penfa">penfa</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ccdata)

syntax = 'help  =~   h1 + h2 + h3 + h4 + h5 + h6 + h7 + 0*v1 + v2 + v3 + v4 + v5
          voice =~ 0*h1 + h2 + h3 + h4 + h5 + h6 + h7 +   v1 + v2 + v3 + v4 + v5'

alasso_fit &lt;- penfa(## factor model
                    model  = syntax,
                    data   = ccdata,
                    std.lv = TRUE,
                    ## penalization
                    pen.shrink = "alasso",
                    eta = list(shrink = c("lambda" = 0.01), diff = c("none" = 0)),
                    ## automatic procedure
                    strategy = "auto")

alasso_fit@SampleStats

</code></pre>

<hr>
<h2 id='penmat'>Extract estimated penalty matrix</h2><span id='topic+penmat'></span>

<h3>Description</h3>

<p>A utility that extracts the estimated penalty matrix from a
fitted object of class <code>penfa</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>penmat(x, type = "full", which = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="penmat_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+penfa-class">penfa</a></code>, that is, a
fitted penalized factor model.</p>
</td></tr>
<tr><td><code id="penmat_+3A_type">type</code></td>
<td>
<p>Character denoting the type of penalization. Type equal to
<code>"full"</code> returns the complete penalty matrix; <code>type="shrink"</code>
returns the penalty matrix for shrinkage; <code>type="diff"</code>
the penalty matrix for parameter equivalence. The matrix
returned by <code>type="full"</code> is the sum of all the <code>shrink</code> and
<code>diff</code> penalty sub-matrices.</p>
</td></tr>
<tr><td><code id="penmat_+3A_which">which</code></td>
<td>
<p>Character prompting the extraction of the penalty matrix
component corresponding to the specified model matrix. It is only valid
when <code>type="shrink"</code> or <code>type="diff"</code>. Possible values are
<code>"lambda"</code>, <code>"psi"</code>, <code>"phi"</code>, <code>"tau"</code>, <code>"kappa"</code>
and <code>"none"</code>.  Only the model matrices penalized during model fitting
(i.e., in the <code>penfa</code> call) can appear in the <code>which</code> argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A penalty matrix of class <code>penfaPenMat</code>. If multiple elements
are specified in the <code>which</code> argument, a list of penalty matrices (one
for each element, and each of class <code>penfaPenMat</code>) is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+penfa">penfa</a></code>
</p>

<hr>
<h2 id='show+2Cpenfa-method'>Display a <code>penfa</code> object</h2><span id='topic+show+2Cpenfa-method'></span>

<h3>Description</h3>

<p>An S4 method printing a short summary of the estimation process, including
the optimization method, the specified penalty functions, the convergence
status, the number of iterations, the tuning selection strategy, and the
effective degrees of freedom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'penfa'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2Cpenfa-method_+3A_object">object</code></td>
<td>
<p>An object of class <code>penfa</code>, found as a result of a call
to <code>penfa</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object reporting a short summary of a fitted <code>penfa</code> model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+penfa">penfa</a></code>, <code><a href="#topic+penfa-class">penfa-class</a></code>
</p>

<hr>
<h2 id='show+2CpenfaData-method'>Display details on the input data</h2><span id='topic+show+2CpenfaData-method'></span>

<h3>Description</h3>

<p>An S4 method showing information on the input data, including the number of
observations. In case of a multiple-group analysis, the sample sizes for each
group are displayed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'penfaData'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CpenfaData-method_+3A_object">object</code></td>
<td>
<p>An object of class <code>penfaData</code>, found in the <code>Data</code>
slot from a <code>penfa</code> class object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object reporting a short summary of the input data.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+penfaData-class">penfaData-class</a></code>
</p>

<hr>
<h2 id='show+2CpenfaPenalty-method'>Display details on the penalization</h2><span id='topic+show+2CpenfaPenalty-method'></span>

<h3>Description</h3>

<p>An S4 method showing information on the penalization process, including the
employed penalty functions and the model matrices they affect. Additionally,
it reports the optimal values of the tuning parameters and the tuning
parameter selection strategy. If the automatic procedure was used, the output
would also show the value of the influence factor, and the number of two-steps
iterations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'penfaPenalty'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CpenfaPenalty-method_+3A_object">object</code></td>
<td>
<p>An object of class <code>penfaPenalty</code>, found in the
<code>Penalize</code> slot from an object of <code>penfa</code> class.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object reporting a short summary of the penalization process for
a fitted <code>penfa</code> model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+penfaPenalty-class">penfaPenalty-class</a></code>
</p>

<hr>
<h2 id='summary+2Cpenfa-method'>Summary constructor for a <code>penfa</code> object</h2><span id='topic+summary+2Cpenfa-method'></span>

<h3>Description</h3>

<p>An S4 method printing a summary of the model parameter estimates for an
object of class <code>penfa</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'penfa'
summary(
  object,
  header = TRUE,
  estimates = TRUE,
  ci = TRUE,
  level = 0.95,
  nd = 3L,
  cutoff = 0.05,
  extra = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary+2B2Cpenfa-method_+3A_object">object</code></td>
<td>
<p>An object of class <code>penfa</code>, found as a result of a call
to <code>penfa</code>.</p>
</td></tr>
<tr><td><code id="summary+2B2Cpenfa-method_+3A_header">header</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the header section is printed. The
header contains relevant information about the data, the fitted model, the
optimization process, and the penalization strategy, including, for
instance, the employed penalties, the estimated effective degrees of
freedom (<em>edf</em>), the optimal values of the tuning parameter(s), the
GBIC and many others.</p>
</td></tr>
<tr><td><code id="summary+2B2Cpenfa-method_+3A_estimates">estimates</code></td>
<td>
<p>Logical. If <code>TRUE</code>, a section with the parameter
estimates is printed out.</p>
</td></tr>
<tr><td><code id="summary+2B2Cpenfa-method_+3A_ci">ci</code></td>
<td>
<p>Logical. If <code>TRUE</code>, confidence intervals are added to the
parameter estimates section.</p>
</td></tr>
<tr><td><code id="summary+2B2Cpenfa-method_+3A_level">level</code></td>
<td>
<p>Logical. It denotes the significance level used for the
statistical tests.</p>
</td></tr>
<tr><td><code id="summary+2B2Cpenfa-method_+3A_nd">nd</code></td>
<td>
<p>Integer. It determines the number of digits after the decimal point
to be printed in the parameter estimates section.</p>
</td></tr>
<tr><td><code id="summary+2B2Cpenfa-method_+3A_cutoff">cutoff</code></td>
<td>
<p>Numeric. Standard errors and confidence intervals for the
penalized parameter estimates falling below the <code>cutoff</code> value are not
displayed. Confidence intervals for the parameters that have been penalized
and shrunken to zero must be treated with caution.</p>
</td></tr>
<tr><td><code id="summary+2B2Cpenfa-method_+3A_extra">extra</code></td>
<td>
<p>Logical. If <code>TRUE</code>, additional information on the model
are displayed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object reporting a detailed summary of the estimated parameters
for a <code>penfa</code> model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+penfa">penfa</a></code>, <code><a href="#topic+penfa-class">penfa-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ccdata)

syntax = 'help  =~   h1 + h2 + h3 + h4 + h5 + h6 + h7 + 0*v1 + v2 + v3 + v4 + v5
          voice =~ 0*h1 + h2 + h3 + h4 + h5 + h6 + h7 +   v1 + v2 + v3 + v4 + v5'

alasso_fit &lt;- penfa(## factor model
                    model  = syntax,
                    data   = ccdata,
                    std.lv = TRUE,
                    ## penalization
                    pen.shrink = "alasso",
                    eta = list(shrink = c("lambda" = 0.01), diff = c("none" = 0)),
                    ## automatic procedure
                    strategy = "auto")

summary(alasso_fit)



</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
