<!DOCTYPE html><html lang="en-GB"><head><title>Help for package feasts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {feasts}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#feasts-package'><p>feasts: Feature Extraction and Statistics for Time Series</p></a></li>
<li><a href='#ACF'><p>(Partial) Autocorrelation and Cross-Correlation Function Estimation</p></a></li>
<li><a href='#autoplot.tbl_cf'><p>Auto- and Cross- Covariance and -Correlation plots</p></a></li>
<li><a href='#classical_decomposition'><p>Classical Seasonal Decomposition by Moving Averages</p></a></li>
<li><a href='#coef_hurst'><p>Hurst coefficient</p></a></li>
<li><a href='#cointegration_johansen'><p>Johansen Procedure for VAR</p></a></li>
<li><a href='#cointegration_phillips_ouliaris'><p>Phillips and Ouliaris Cointegration Test</p></a></li>
<li><a href='#feat_acf'><p>Autocorrelation-based features</p></a></li>
<li><a href='#feat_intermittent'><p>Intermittency features</p></a></li>
<li><a href='#feat_pacf'><p>Partial autocorrelation-based features</p></a></li>
<li><a href='#feat_spectral'><p>Spectral features of a time series</p></a></li>
<li><a href='#feat_stl'><p>STL features</p></a></li>
<li><a href='#generate.stl_decomposition'><p>Generate block bootstrapped series from an STL decomposition</p></a></li>
<li><a href='#gg_arma'><p>Plot characteristic ARMA roots</p></a></li>
<li><a href='#gg_irf'><p>Plot impulse response functions</p></a></li>
<li><a href='#gg_lag'><p>Lag plots</p></a></li>
<li><a href='#gg_season'><p>Seasonal plot</p></a></li>
<li><a href='#gg_subseries'><p>Seasonal subseries plots</p></a></li>
<li><a href='#gg_tsdisplay'><p>Ensemble of time series displays</p></a></li>
<li><a href='#gg_tsresiduals'><p>Ensemble of time series residual diagnostic plots</p></a></li>
<li><a href='#guerrero'><p>Guerrero's method for Box Cox lambda selection</p></a></li>
<li><a href='#ljung_box'><p>Portmanteau tests</p></a></li>
<li><a href='#longest_flat_spot'><p>Longest flat spot length</p></a></li>
<li><a href='#n_crossing_points'><p>Number of crossing points</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#scale_cf_lag'><p>lagged datetime scales</p>
This set of scales defines new scales for lagged time structures.</a></li>
<li><a href='#shift_level_max'><p>Sliding window features</p></a></li>
<li><a href='#stat_arch_lm'><p>ARCH LM Statistic</p></a></li>
<li><a href='#STL'><p>Multiple seasonal decomposition by Loess</p></a></li>
<li><a href='#unitroot_kpss'><p>Unit root tests</p></a></li>
<li><a href='#unitroot_ndiffs'><p>Number of differences required for a stationary series</p></a></li>
<li><a href='#var_tiled_var'><p>Time series features based on tiled windows</p></a></li>
<li><a href='#X_13ARIMA_SEATS'><p>X-13ARIMA-SEATS Seasonal Adjustment</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Feature Extraction and Statistics for Time Series</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a collection of features, decomposition methods, 
    statistical summaries and graphics functions for the analysing tidy time
    series data. The package name 'feasts' is an acronym comprising of its key
    features: Feature Extraction And Statistics for Time Series.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), fabletools (&ge; 0.3.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>rlang (&ge; 0.2.0), tibble (&ge; 1.4.1), tsibble (&ge; 0.9.0),
ggplot2 (&ge; 3.0.0), dplyr (&ge; 1.0.0), tidyr (&ge; 0.8.3), scales
(&ge; 1.1.0), vctrs, lubridate, grid, slider, utils, lifecycle,
gtable</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tsibbledata, pillar (&ge; 1.0.1), knitr, rmarkdown, testthat,
covr, seasonal, urca, fracdiff, fable, ggrepel</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://feasts.tidyverts.org/">http://feasts.tidyverts.org/</a>, <a href="https://github.com/tidyverts/feasts/">https://github.com/tidyverts/feasts/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tidyverts/feasts/issues">https://github.com/tidyverts/feasts/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>lifecycle</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-25 23:01:19 UTC; mitchell</td>
</tr>
<tr>
<td>Author:</td>
<td>Mitchell O'Hara-Wild [aut, cre],
  Rob Hyndman [aut],
  Earo Wang [aut],
  Di Cook [ctb],
  Thiyanga Talagala [ctb] (Correlation features),
  Leanne Chhay [ctb] (Guerrero's method)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mitchell O'Hara-Wild &lt;mail@mitchelloharawild.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-25 23:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='feasts-package'>feasts: Feature Extraction and Statistics for Time Series</h2><span id='topic+feasts'></span><span id='topic+feasts-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Provides a collection of features, decomposition methods, statistical summaries and graphics functions for the analysing tidy time series data. The package name 'feasts' is an acronym comprising of its key features: Feature Extraction And Statistics for Time Series.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Mitchell O'Hara-Wild <a href="mailto:mail@mitchelloharawild.com">mail@mitchelloharawild.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Rob Hyndman
</p>
</li>
<li><p> Earo Wang
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Di Cook [contributor]
</p>
</li>
<li><p> Thiyanga Talagala (Correlation features) [contributor]
</p>
</li>
<li><p> Leanne Chhay (Guerrero's method) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="http://feasts.tidyverts.org/">http://feasts.tidyverts.org/</a>
</p>
</li>
<li> <p><a href="https://github.com/tidyverts/feasts/">https://github.com/tidyverts/feasts/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/tidyverts/feasts/issues">https://github.com/tidyverts/feasts/issues</a>
</p>
</li></ul>


<hr>
<h2 id='ACF'>(Partial) Autocorrelation and Cross-Correlation Function Estimation</h2><span id='topic+ACF'></span><span id='topic+PACF'></span><span id='topic+CCF'></span>

<h3>Description</h3>

<p>The function <code>ACF</code> computes an estimate of the autocorrelation function
of a (possibly multivariate) tsibble. Function <code>PACF</code> computes an estimate
of the partial autocorrelation function of a (possibly multivariate) tsibble.
Function <code>CCF</code> computes the cross-correlation or cross-covariance of two columns
from a tsibble.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ACF(
  .data,
  y,
  ...,
  lag_max = NULL,
  type = c("correlation", "covariance", "partial"),
  na.action = na.contiguous,
  demean = TRUE,
  tapered = FALSE
)

PACF(.data, y, ..., lag_max = NULL, na.action = na.contiguous, tapered = FALSE)

CCF(
  .data,
  y,
  x,
  ...,
  lag_max = NULL,
  type = c("correlation", "covariance"),
  na.action = na.contiguous
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ACF_+3A_.data">.data</code></td>
<td>
<p>A tsibble</p>
</td></tr>
<tr><td><code id="ACF_+3A_...">...</code></td>
<td>
<p>The column(s) from the tsibble used to compute the ACF, PACF or CCF.</p>
</td></tr>
<tr><td><code id="ACF_+3A_lag_max">lag_max</code></td>
<td>
<p>maximum lag at which to calculate the acf. Default is 10*log10(N/m)
where N is the number of observations and m the number of series. Will be
automatically limited to one less than the number of observations in the series.</p>
</td></tr>
<tr><td><code id="ACF_+3A_type">type</code></td>
<td>
<p>character string giving the type of ACF to be computed. Allowed values are <code>"correlation"</code> (the default), <code>"covariance"</code> or <code>"partial"</code>.</p>
</td></tr>
<tr><td><code id="ACF_+3A_na.action">na.action</code></td>
<td>
<p>function to be called to handle missing
values. <code>na.pass</code> can be used.</p>
</td></tr>
<tr><td><code id="ACF_+3A_demean">demean</code></td>
<td>
<p>logical.  Should the covariances be about the sample
means?</p>
</td></tr>
<tr><td><code id="ACF_+3A_tapered">tapered</code></td>
<td>
<p>Produces banded and tapered estimates of the (partial) autocorrelation.</p>
</td></tr>
<tr><td><code id="ACF_+3A_x">x</code>, <code id="ACF_+3A_y">y</code></td>
<td>
<p>a univariate or multivariate (not <code>ccf</code>) numeric time
series object or a numeric vector or matrix, or an <code>"acf"</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions improve the <code><a href="stats.html#topic+acf">stats::acf()</a></code>, <code><a href="stats.html#topic+acf">stats::pacf()</a></code> and
<code><a href="stats.html#topic+acf">stats::ccf()</a></code> functions. The main differences are that <code>ACF</code> does not plot
the exact correlation at lag 0 when <code>type=="correlation"</code> and
the horizontal axes show lags in time units rather than seasonal units.
</p>
<p>The resulting tables from these functions can also be plotted using
<code><a href="#topic+autoplot.tbl_cf">autoplot.tbl_cf()</a></code>.
</p>


<h3>Value</h3>

<p>The <code>ACF</code>, <code>PACF</code> and <code>CCF</code> functions return objects
of class &quot;tbl_cf&quot;, which is a tsibble containing the correlations computed.
</p>


<h3>Author(s)</h3>

<p>Mitchell O'Hara-Wild and Rob J Hyndman
</p>


<h3>References</h3>

<p>Hyndman, R.J. (2015). Discussion of &quot;High-dimensional
autocovariance matrices and optimal linear prediction&quot;. <em>Electronic
Journal of Statistics</em>, 9, 792-796.
</p>
<p>McMurry, T. L., &amp; Politis, D. N. (2010). Banded and tapered estimates for
autocovariance matrices and the linear process bootstrap. <em>Journal of
Time Series Analysis</em>, 31(6), 471-482.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+acf">stats::acf()</a></code>, <code><a href="stats.html#topic+acf">stats::pacf()</a></code>, <code><a href="stats.html#topic+acf">stats::ccf()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tsibble)
library(tsibbledata)
library(dplyr)

vic_elec %&gt;% ACF(Temperature)

vic_elec %&gt;% ACF(Temperature) %&gt;% autoplot()

vic_elec %&gt;% PACF(Temperature)

vic_elec %&gt;% PACF(Temperature) %&gt;% autoplot()

global_economy %&gt;%
  filter(Country == "Australia") %&gt;%
  CCF(GDP, Population)

global_economy %&gt;%
  filter(Country == "Australia") %&gt;%
  CCF(GDP, Population) %&gt;%
  autoplot()

</code></pre>

<hr>
<h2 id='autoplot.tbl_cf'>Auto- and Cross- Covariance and -Correlation plots</h2><span id='topic+autoplot.tbl_cf'></span>

<h3>Description</h3>

<p>Produces an appropriate plot for the result of  <code><a href="#topic+ACF">ACF()</a></code>, <code><a href="#topic+PACF">PACF()</a></code>, or <code><a href="#topic+CCF">CCF()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tbl_cf'
autoplot(object, level = 95, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="autoplot.tbl_cf_+3A_object">object</code></td>
<td>
<p>A tbl_cf object (the result <code><a href="#topic+ACF">ACF()</a></code>, <code><a href="#topic+PACF">PACF()</a></code>, or <code><a href="#topic+CCF">CCF()</a></code>).</p>
</td></tr>
<tr><td><code id="autoplot.tbl_cf_+3A_level">level</code></td>
<td>
<p>The level of confidence for the blue dashed lines.</p>
</td></tr>
<tr><td><code id="autoplot.tbl_cf_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object showing the correlations.
</p>

<hr>
<h2 id='classical_decomposition'>Classical Seasonal Decomposition by Moving Averages</h2><span id='topic+classical_decomposition'></span>

<h3>Description</h3>

<p>Decompose a time series into seasonal, trend and irregular components
using moving averages.  Deals with additive or multiplicative
seasonal component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classical_decomposition(formula, type = c("additive", "multiplicative"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="classical_decomposition_+3A_formula">formula</code></td>
<td>
<p>Decomposition specification (see &quot;Specials&quot; section).</p>
</td></tr>
<tr><td><code id="classical_decomposition_+3A_type">type</code></td>
<td>
<p>The type of seasonal component. Can be abbreviated.</p>
</td></tr>
<tr><td><code id="classical_decomposition_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="stats.html#topic+decompose">stats::decompose()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The additive model used is:
</p>
<p style="text-align: center;"><code class="reqn">Y_t = T_t + S_t + e_t</code>
</p>

<p>The multiplicative model used is:
</p>
<p style="text-align: center;"><code class="reqn">Y_t = T_t\,S_t\, e_t</code>
</p>

<p>The function first determines the trend component using a moving
average (if <code>filter</code> is <code>NULL</code>, a symmetric window with
equal weights is used), and removes it from the time series.  Then,
the seasonal figure is computed by averaging, for each time unit, over
all periods.  The seasonal figure is then centered.   Finally, the error
component is determined by removing trend and seasonal figure
(recycled as needed) from the original time series.
</p>
<p>This only works well if <code>x</code> covers an integer number of complete
periods.
</p>


<h3>Value</h3>

<p>A <code><a href="fabletools.html#topic+dable">fabletools::dable()</a></code> containing the decomposed trend, seasonality
and remainder from the classical decomposition.
</p>


<h3>Specials</h3>



<h4>season</h4>

<p>The <code>season</code> special is used to specify seasonal attributes of the decomposition.
</p>
<pre>
season(period = NULL)
</pre>

<table>
<tr>
 <td style="text-align: left;">
<code>period</code>   </td><td style="text-align: left;"> The periodic nature of the seasonality. This can be either a number indicating the number of observations in each seasonal period, or text to indicate the duration of the seasonal window (for example, annual seasonality would be "1 year").
</td>
</tr>

</table>




<h3>Examples</h3>

<pre><code class='language-R'>as_tsibble(USAccDeaths) %&gt;%
  model(classical_decomposition(value)) %&gt;%
  components()

as_tsibble(USAccDeaths) %&gt;%
  model(classical_decomposition(value ~ season(12), type = "mult")) %&gt;%
  components()

</code></pre>

<hr>
<h2 id='coef_hurst'>Hurst coefficient</h2><span id='topic+coef_hurst'></span>

<h3>Description</h3>

<p>Computes the Hurst coefficient indicating the level of fractional differencing
of a time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coef_hurst(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef_hurst_+3A_x">x</code></td>
<td>
<p>a vector. If missing values are present, the largest
contiguous portion of the vector is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value.
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>

<hr>
<h2 id='cointegration_johansen'>Johansen Procedure for VAR</h2><span id='topic+cointegration_johansen'></span>

<h3>Description</h3>

<p>Conducts the Johansen procedure on a given data set. The
<code>"trace"</code> or <code>"eigen"</code> statistics are reported and the
matrix of eigenvectors as well as the loading matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cointegration_johansen(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cointegration_johansen_+3A_x">x</code></td>
<td>
<p>Data matrix to be investigated for cointegration.</p>
</td></tr>
<tr><td><code id="cointegration_johansen_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="urca.html#topic+ca.jo">urca::ca.jo()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a general VAR of the form:
</p>
<p style="text-align: center;"><code class="reqn">\bold{X}_t = \bold{\Pi}_1 \bold{X}_{t-1} + \dots + \bold{\Pi}_k
    \bold{X}_{t-k} + \bold{\mu} + \bold{\Phi D}_t + \bold{\varepsilon}_t
    , \quad (t = 1, \dots, T),</code>
</p>

<p>the following two specifications of a VECM exist:
</p>
<p style="text-align: center;"><code class="reqn">\Delta \bold{X}_t = \bold{\Gamma}_1 \Delta \bold{X}_{t-1} +
    \dots + \bold{\Gamma}_{k-1} \Delta \bold{X}_{t-k+1} + \bold{\Pi
    X}_{t-k} + \bold{\mu} + \bold{\Phi D}_t + \bold{\varepsilon}_t</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">\bold{\Gamma}_i = - (\bold{I} - \bold{\Pi}_1 - \dots -
    \bold{\Pi}_i), \quad (i = 1, \dots , k-1),</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">\bold{\Pi} = -(\bold{I} - \bold{\Pi}_1 - \dots - \bold{\Pi}_k)</code>
</p>

<p>The <code class="reqn">\bold{\Gamma}_i</code> matrices contain the cumulative long-run
impacts, hence if <code>spec="longrun"</code> is choosen, the above VECM is
estimated.
</p>
<p>The other VECM specification is of the form:
</p>
<p style="text-align: center;"><code class="reqn">\Delta \bold{X}_t = \bold{\Gamma}_1 \Delta \bold{X}_{t-1} +
    \dots + \bold{\Gamma}_{k-1} \Delta \bold{X}_{t-k+1} + \bold{\Pi
    X}_{t-1} + \bold{\mu} + \bold{\Phi D}_t + \bold{\varepsilon}_t</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">\bold{\Gamma}_i = - (\bold{\Pi}_{i+1} + \dots + \bold{\Pi}_k),
    \quad(i = 1, \dots , k-1),</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">\bold{\Pi} = -(\bold{I} - \bold{\Pi}_1 - \dots - \bold{\Pi}_k).</code>
</p>

<p>The <code class="reqn">\bold{\Pi}</code> matrix is the same as in the first specification.
However, the <code class="reqn">\bold{\Gamma}_i</code> matrices now differ, in the sense
that they measure transitory effects, hence by setting
<code>spec="transitory"</code> the second VECM form is estimated. Please note
that inferences drawn on <code class="reqn">\bold{\Pi}</code> will be the same, regardless
which specification is choosen and that the explanatory power is the
same, too. 
</p>
<p>If <code>"season"</code> is not NULL, centered seasonal dummy variables are
included. 
</p>
<p>If <code>"dumvar"</code> is not NULL, a matrix of dummy variables is included
in the VECM. Please note, that the number of rows of the matrix
containing the dummy variables must be equal to the row number of
<code>x</code>.
</p>
<p>Critical values are only reported for systems with less than
11 variables and are taken from Osterwald-Lenum.
</p>


<h3>Value</h3>

<p>An object of class <code>ca.jo</code>.
</p>


<h3>Author(s)</h3>

<p>Bernhard Pfaff
</p>


<h3>References</h3>

<p>Johansen, S. (1988), Statistical Analysis of Cointegration Vectors,
<em>Journal of Economic Dynamics and Control</em>, <b>12</b>, 231&ndash;254.
</p>
<p>Johansen, S. and Juselius, K. (1990), Maximum Likelihood Estimation and
Inference on Cointegration &ndash; with Applications to the Demand for
Money, <em>Oxford Bulletin of Economics and Statistics</em>, <b>52,
2</b>, 169&ndash;210.
</p>
<p>Johansen, S. (1991), Estimation and Hypothesis Testing of
Cointegration Vectors in Gaussian Vector Autoregressive Models,
<em>Econometrica</em>, <b>Vol. 59, No. 6</b>, 1551&ndash;1580.
</p>
<p>Osterwald-Lenum, M. (1992), A Note with Quantiles of the Asymptotic
Distribution of the Maximum Likelihood Cointegration Rank Test
Statistics, <em>Oxford Bulletin of Economics and Statistics</em>,
<b>55, 3</b>, 461&ndash;472.
</p>


<h3>See Also</h3>

<p><code><a href="urca.html#topic+ca.jo">urca::ca.jo()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cointegration_johansen(cbind(mdeaths, fdeaths))


</code></pre>

<hr>
<h2 id='cointegration_phillips_ouliaris'>Phillips and Ouliaris Cointegration Test</h2><span id='topic+cointegration_phillips_ouliaris'></span>

<h3>Description</h3>

<p>Performs the Phillips and Ouliaris <code>"Pu"</code> and <code>"Pz"</code>
cointegration test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cointegration_phillips_ouliaris(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cointegration_phillips_ouliaris_+3A_x">x</code></td>
<td>
<p>Matrix of data to be tested.</p>
</td></tr>
<tr><td><code id="cointegration_phillips_ouliaris_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="urca.html#topic+ca.po">urca::ca.po()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test <code>"Pz"</code>, compared to the test <code>"Pu"</code>, has the
advantage that it is invariant to the normalization of the
cointegration vector, <em>i.e.</em> it does not matter which variable
is on the left hand side of the equation. In case convergence
problems are encountered by matrix inversion, one can pass a higher
tolerance level <em>via</em> <code>"tol=..."</code> to the <code>solve()</code>-function.
</p>


<h3>Value</h3>

<p>An object of class <code>ca.po</code>.
</p>


<h3>Author(s)</h3>

<p>Bernhard Pfaff
</p>


<h3>References</h3>

<p>Phillips, P.C.B. and Ouliaris, S. (1990), Asymptotic Properties of
Residual Based Tests for Cointegration, <em>Econometrica</em>,
<b>Vol. 58, No. 1</b>, 165&ndash;193.
</p>


<h3>See Also</h3>

<p><code><a href="urca.html#topic+ca.po">urca::ca.po()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cointegration_phillips_ouliaris(cbind(mdeaths, fdeaths))

</code></pre>

<hr>
<h2 id='feat_acf'>Autocorrelation-based features</h2><span id='topic+feat_acf'></span>

<h3>Description</h3>

<p>Computes various measures based on autocorrelation coefficients of the
original series, first-differenced series and second-differenced series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feat_acf(x, .period = 1, lag_max = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="feat_acf_+3A_x">x</code></td>
<td>
<p>a univariate time series</p>
</td></tr>
<tr><td><code id="feat_acf_+3A_.period">.period</code></td>
<td>
<p>The seasonal period (optional)</p>
</td></tr>
<tr><td><code id="feat_acf_+3A_lag_max">lag_max</code></td>
<td>
<p>maximum lag at which to calculate the acf. The default is
<code>max(.period, 10L)</code> for <code>feat_acf</code>, and <code>max(.period, 5L)</code> for <code>feat_pacf</code></p>
</td></tr>
<tr><td><code id="feat_acf_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="stats.html#topic+acf">stats::acf()</a></code> or <code><a href="stats.html#topic+acf">stats::pacf()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of 6 values: first autocorrelation coefficient and sum of squared of
first ten autocorrelation coefficients of original series, first-differenced series,
and twice-differenced series.
For seasonal data, the autocorrelation coefficient at the first seasonal lag is
also returned.
</p>


<h3>Author(s)</h3>

<p>Thiyanga Talagala
</p>

<hr>
<h2 id='feat_intermittent'>Intermittency features</h2><span id='topic+feat_intermittent'></span>

<h3>Description</h3>

<p>Computes various measures that can indicate the presence and structures of
intermittent data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feat_intermittent(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="feat_intermittent_+3A_x">x</code></td>
<td>
<p>A vector to extract features from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of named features:
</p>

<ul>
<li><p> zero_run_mean: The average interval between non-zero observations
</p>
</li>
<li><p> nonzero_squared_cv: The squared coefficient of variation of non-zero observations
</p>
</li>
<li><p> zero_start_prop: The proportion of data which starts with zero
</p>
</li>
<li><p> zero_end_prop: The proportion of data which ends with zero
</p>
</li></ul>



<h3>References</h3>

<p>Kostenko, A. V., &amp; Hyndman, R. J. (2006). A note on the categorization of
demand patterns. <em>Journal of the Operational Research Society</em>, 57(10),
1256-1257.
</p>

<hr>
<h2 id='feat_pacf'>Partial autocorrelation-based features</h2><span id='topic+feat_pacf'></span>

<h3>Description</h3>

<p>Computes various measures based on partial autocorrelation coefficients of the
original series, first-differenced series and second-differenced series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feat_pacf(x, .period = 1, lag_max = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="feat_pacf_+3A_x">x</code></td>
<td>
<p>a univariate time series</p>
</td></tr>
<tr><td><code id="feat_pacf_+3A_.period">.period</code></td>
<td>
<p>The seasonal period (optional)</p>
</td></tr>
<tr><td><code id="feat_pacf_+3A_lag_max">lag_max</code></td>
<td>
<p>maximum lag at which to calculate the acf. The default is
<code>max(.period, 10L)</code> for <code>feat_acf</code>, and <code>max(.period, 5L)</code> for <code>feat_pacf</code></p>
</td></tr>
<tr><td><code id="feat_pacf_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="stats.html#topic+acf">stats::acf()</a></code> or <code><a href="stats.html#topic+acf">stats::pacf()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of 3 values: Sum of squared of first 5
partial autocorrelation coefficients of the original series, first differenced
series and twice-differenced series.
For seasonal data, the partial autocorrelation coefficient at the first seasonal
lag is also returned.
</p>


<h3>Author(s)</h3>

<p>Thiyanga Talagala
</p>

<hr>
<h2 id='feat_spectral'>Spectral features of a time series</h2><span id='topic+feat_spectral'></span>

<h3>Description</h3>

<p>Computes spectral entropy from a univariate normalized
spectral density, estimated using an AR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feat_spectral(x, .period = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="feat_spectral_+3A_x">x</code></td>
<td>
<p>a univariate time series</p>
</td></tr>
<tr><td><code id="feat_spectral_+3A_.period">.period</code></td>
<td>
<p>The seasonal period.</p>
</td></tr>
<tr><td><code id="feat_spectral_+3A_...">...</code></td>
<td>
<p>Further arguments for <code><a href="stats.html#topic+spec.ar">stats::spec.ar()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>spectral entropy</em> equals the Shannon entropy of the spectral density
<code class="reqn">f_x(\lambda)</code> of a stationary process <code class="reqn">x_t</code>:
</p>
<p style="text-align: center;"><code class="reqn">
H_s(x_t) = - \int_{-\pi}^{\pi} f_x(\lambda) \log f_x(\lambda) d \lambda,
</code>
</p>

<p>where the density is normalized such that
<code class="reqn">\int_{-\pi}^{\pi} f_x(\lambda) d \lambda = 1</code>.
An estimate of <code class="reqn">f(\lambda)</code> can be obtained using <code><a href="stats.html#topic+spec.ar">spec.ar</a></code> with
the <code>burg</code> method.
</p>


<h3>Value</h3>

<p>A non-negative real value for the spectral entropy <code class="reqn">H_s(x_t)</code>.
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>References</h3>

<p>Jerry D. Gibson and Jaewoo Jung (2006). &ldquo;The
Interpretation of Spectral Entropy Based Upon Rate Distortion Functions&rdquo;.
IEEE International Symposium on Information Theory, pp. 277-281.
</p>
<p>Goerg, G. M. (2013). &ldquo;Forecastable Component Analysis&rdquo;.
Journal of Machine Learning Research (JMLR) W&amp;CP 28 (2): 64-72, 2013.
Available at <a href="https://proceedings.mlr.press/v28/goerg13.html">https://proceedings.mlr.press/v28/goerg13.html</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+spec.ar">spec.ar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>feat_spectral(rnorm(1000))
feat_spectral(lynx)
feat_spectral(sin(1:20))
</code></pre>

<hr>
<h2 id='feat_stl'>STL features</h2><span id='topic+feat_stl'></span>

<h3>Description</h3>

<p>Computes a variety of measures extracted from an STL decomposition of the
time series. This includes details about the strength of trend and seasonality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>feat_stl(x, .period, s.window = 11, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="feat_stl_+3A_x">x</code></td>
<td>
<p>A vector to extract features from.</p>
</td></tr>
<tr><td><code id="feat_stl_+3A_.period">.period</code></td>
<td>
<p>The period of the seasonality.</p>
</td></tr>
<tr><td><code id="feat_stl_+3A_s.window">s.window</code></td>
<td>
<p>The seasonal window of the data (passed to <code><a href="stats.html#topic+stl">stats::stl()</a></code>)</p>
</td></tr>
<tr><td><code id="feat_stl_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="stats.html#topic+stl">stats::stl()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of numeric features from a STL decomposition.
</p>


<h3>See Also</h3>

<p><a href="https://otexts.com/fpp3/stlfeatures.html">Forecasting Principle and Practices: Measuring strength of trend and seasonality</a>
</p>

<hr>
<h2 id='generate.stl_decomposition'>Generate block bootstrapped series from an STL decomposition</h2><span id='topic+generate.stl_decomposition'></span>

<h3>Description</h3>

<p>Produces new data with the same structure by resampling the residuals using
a block bootstrap procedure. This method can only generate within sample, and
any generated data out of the trained sample will produce NA simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stl_decomposition'
generate(x, new_data, specials = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate.stl_decomposition_+3A_x">x</code></td>
<td>
<p>A fitted model.</p>
</td></tr>
<tr><td><code id="generate.stl_decomposition_+3A_new_data">new_data</code></td>
<td>
<p>A tsibble containing the time points and exogenous regressors to produce forecasts for.</p>
</td></tr>
<tr><td><code id="generate.stl_decomposition_+3A_specials">specials</code></td>
<td>
<p>(passed by <code><a href="fabletools.html#topic+forecast">fabletools::forecast.mdl_df()</a></code>).</p>
</td></tr>
<tr><td><code id="generate.stl_decomposition_+3A_...">...</code></td>
<td>
<p>Other arguments passed to methods</p>
</td></tr>
</table>


<h3>References</h3>

<p>Bergmeir, C., R. J. Hyndman, and J. M. Benitez (2016). Bagging Exponential Smoothing Methods using STL Decomposition and Box-Cox Transformation. International Journal of Forecasting 32, 303-312.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as_tsibble(USAccDeaths) %&gt;%
  model(STL(log(value))) %&gt;%
  generate(as_tsibble(USAccDeaths), times = 3)

</code></pre>

<hr>
<h2 id='gg_arma'>Plot characteristic ARMA roots</h2><span id='topic+gg_arma'></span>

<h3>Description</h3>

<p>Produces a plot of the inverse AR and MA roots of an ARIMA model.
Inverse roots outside the unit circle are shown in red.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gg_arma(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gg_arma_+3A_data">data</code></td>
<td>
<p>A mable containing models with AR and/or MA roots.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only models which compute ARMA roots can be visualised with this function.
That is to say, the <code>glance()</code> of the model contains <code>ar_roots</code> and <code>ma_roots</code>.
</p>


<h3>Value</h3>

<p>A ggplot object the characteristic roots from ARMA components.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("fable", quietly = TRUE)) {
library(fable)
library(tsibble)
library(dplyr)

tsibbledata::aus_retail %&gt;%
  filter(
    State == "Victoria",
    Industry == "Cafes, restaurants and catering services"
  ) %&gt;%
  model(ARIMA(Turnover ~ pdq(0,1,1) + PDQ(0,1,1))) %&gt;%
  gg_arma()
}
</code></pre>

<hr>
<h2 id='gg_irf'>Plot impulse response functions</h2><span id='topic+gg_irf'></span>

<h3>Description</h3>

<p>Produces a plot of impulse responses from an impulse response function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gg_irf(data, y = all_of(measured_vars(data)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gg_irf_+3A_data">data</code></td>
<td>
<p>A tsibble with impulse responses</p>
</td></tr>
<tr><td><code id="gg_irf_+3A_y">y</code></td>
<td>
<p>The impulse response variables to plot (defaults to all measured variables).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object of the impulse responses.
</p>

<hr>
<h2 id='gg_lag'>Lag plots</h2><span id='topic+gg_lag'></span>

<h3>Description</h3>

<p>A lag plot shows the time series against lags of itself. It is often coloured
the seasonal period to identify how each season correlates with others.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gg_lag(
  data,
  y = NULL,
  period = NULL,
  lags = 1:9,
  geom = c("path", "point"),
  arrow = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gg_lag_+3A_data">data</code></td>
<td>
<p>A tidy time series object (tsibble)</p>
</td></tr>
<tr><td><code id="gg_lag_+3A_y">y</code></td>
<td>
<p>The variable to plot (a bare expression). If NULL, it will
automatically selected from the data.</p>
</td></tr>
<tr><td><code id="gg_lag_+3A_period">period</code></td>
<td>
<p>The seasonal period to display. If NULL (default),
the largest frequency in the data is used. If numeric, it represents
the frequency times the interval between observations. If a string
(e.g., &quot;1y&quot; for 1 year, &quot;3m&quot; for 3 months, &quot;1d&quot; for 1 day,
&quot;1h&quot; for 1 hour, &quot;1min&quot; for 1 minute, &quot;1s&quot; for 1 second),
it's converted to a Period class object from the lubridate package.
Note that the data must have at least one observation per seasonal period,
and the period cannot be smaller than the observation interval.</p>
</td></tr>
<tr><td><code id="gg_lag_+3A_lags">lags</code></td>
<td>
<p>A vector of lags to display as facets.</p>
</td></tr>
<tr><td><code id="gg_lag_+3A_geom">geom</code></td>
<td>
<p>The geometry used to display the data.</p>
</td></tr>
<tr><td><code id="gg_lag_+3A_arrow">arrow</code></td>
<td>
<p>Arrow specification to show the direction in the lag path. If
TRUE, an appropriate default arrow will be used. Alternatively, a user
controllable arrow created with <code><a href="grid.html#topic+arrow">grid::arrow()</a></code> can be used.</p>
</td></tr>
<tr><td><code id="gg_lag_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the geom.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object showing a lag plot of a time series.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tsibble)
library(dplyr)
tsibbledata::aus_retail %&gt;%
  filter(
    State == "Victoria",
    Industry == "Cafes, restaurants and catering services"
  ) %&gt;%
  gg_lag(Turnover)

</code></pre>

<hr>
<h2 id='gg_season'>Seasonal plot</h2><span id='topic+gg_season'></span>

<h3>Description</h3>

<p>Produces a time series seasonal plot. A seasonal plot is similar to a regular
time series plot, except the x-axis shows data from within each season. This
plot type allows the underlying seasonal pattern to be seen more clearly,
and is especially useful in identifying years in which the pattern changes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gg_season(
  data,
  y = NULL,
  period = NULL,
  facet_period = NULL,
  max_col = Inf,
  max_col_discrete = 7,
  pal = (scales::hue_pal())(9),
  polar = FALSE,
  labels = c("none", "left", "right", "both"),
  labels_repel = FALSE,
  labels_left_nudge = 0,
  labels_right_nudge = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gg_season_+3A_data">data</code></td>
<td>
<p>A tidy time series object (tsibble)</p>
</td></tr>
<tr><td><code id="gg_season_+3A_y">y</code></td>
<td>
<p>The variable to plot (a bare expression). If NULL, it will
automatically selected from the data.</p>
</td></tr>
<tr><td><code id="gg_season_+3A_period">period</code></td>
<td>
<p>The seasonal period to display. If NULL (default),
the largest frequency in the data is used. If numeric, it represents
the frequency times the interval between observations. If a string
(e.g., &quot;1y&quot; for 1 year, &quot;3m&quot; for 3 months, &quot;1d&quot; for 1 day,
&quot;1h&quot; for 1 hour, &quot;1min&quot; for 1 minute, &quot;1s&quot; for 1 second),
it's converted to a Period class object from the lubridate package.
Note that the data must have at least one observation per seasonal period,
and the period cannot be smaller than the observation interval.</p>
</td></tr>
<tr><td><code id="gg_season_+3A_facet_period">facet_period</code></td>
<td>
<p>A secondary seasonal period to facet by
(typically smaller than period).</p>
</td></tr>
<tr><td><code id="gg_season_+3A_max_col">max_col</code></td>
<td>
<p>The maximum number of colours to display on the plot. If the
number of seasonal periods in the data is larger than <code>max_col</code>, the plot
will not include a colour. Use <code>max_col = 0</code> to never colour the lines, or Inf
to always colour the lines. If labels are used, then max_col will be ignored.</p>
</td></tr>
<tr><td><code id="gg_season_+3A_max_col_discrete">max_col_discrete</code></td>
<td>
<p>The maximum number of colours to show using a discrete colour scale.</p>
</td></tr>
<tr><td><code id="gg_season_+3A_pal">pal</code></td>
<td>
<p>A colour palette to be used.</p>
</td></tr>
<tr><td><code id="gg_season_+3A_polar">polar</code></td>
<td>
<p>If TRUE, the season plot will be shown on polar coordinates.</p>
</td></tr>
<tr><td><code id="gg_season_+3A_labels">labels</code></td>
<td>
<p>Position of the labels for seasonal period identifier.</p>
</td></tr>
<tr><td><code id="gg_season_+3A_labels_repel">labels_repel</code></td>
<td>
<p>If TRUE, the seasonal period identifying labels will be repelled with the ggrepel package.</p>
</td></tr>
<tr><td><code id="gg_season_+3A_labels_left_nudge">labels_left_nudge</code>, <code id="gg_season_+3A_labels_right_nudge">labels_right_nudge</code></td>
<td>
<p>Allows seasonal period identifying labels to be nudged to the left or right from their default position.</p>
</td></tr>
<tr><td><code id="gg_season_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to geom_line()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object showing a seasonal plot of a time series.
</p>


<h3>References</h3>

<p>Hyndman and Athanasopoulos (2019) Forecasting: principles and practice,
3rd edition, OTexts: Melbourne, Australia. https://OTexts.com/fpp3/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tsibble)
library(dplyr)
tsibbledata::aus_retail %&gt;%
  filter(
    State == "Victoria",
    Industry == "Cafes, restaurants and catering services"
  ) %&gt;%
  gg_season(Turnover)

</code></pre>

<hr>
<h2 id='gg_subseries'>Seasonal subseries plots</h2><span id='topic+gg_subseries'></span>

<h3>Description</h3>

<p>A seasonal subseries plot facets the time series by each season in the
seasonal period. These facets form smaller time series plots consisting of
data only from that season. If you had several years of monthly data, the
resulting plot would show a separate time series plot for each month. The
first subseries plot would consist of only data from January. This case is
given as an example below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gg_subseries(data, y = NULL, period = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gg_subseries_+3A_data">data</code></td>
<td>
<p>A tidy time series object (tsibble)</p>
</td></tr>
<tr><td><code id="gg_subseries_+3A_y">y</code></td>
<td>
<p>The variable to plot (a bare expression). If NULL, it will
automatically selected from the data.</p>
</td></tr>
<tr><td><code id="gg_subseries_+3A_period">period</code></td>
<td>
<p>The seasonal period to display. If NULL (default),
the largest frequency in the data is used. If numeric, it represents
the frequency times the interval between observations. If a string
(e.g., &quot;1y&quot; for 1 year, &quot;3m&quot; for 3 months, &quot;1d&quot; for 1 day,
&quot;1h&quot; for 1 hour, &quot;1min&quot; for 1 minute, &quot;1s&quot; for 1 second),
it's converted to a Period class object from the lubridate package.
Note that the data must have at least one observation per seasonal period,
and the period cannot be smaller than the observation interval.</p>
</td></tr>
<tr><td><code id="gg_subseries_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to geom_line()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The horizontal lines are used to represent the mean of each facet, allowing
easy identification of seasonal differences between seasons. This plot is
particularly useful in identifying changes in the seasonal pattern over time.
</p>
<p>similar to a seasonal plot (<code><a href="#topic+gg_season">gg_season()</a></code>), and
</p>


<h3>Value</h3>

<p>A ggplot object showing a seasonal subseries plot of a time series.
</p>


<h3>References</h3>

<p>Hyndman and Athanasopoulos (2019) Forecasting: principles and practice,
3rd edition, OTexts: Melbourne, Australia. https://OTexts.com/fpp3/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tsibble)
library(dplyr)
tsibbledata::aus_retail %&gt;%
  filter(
    State == "Victoria",
    Industry == "Cafes, restaurants and catering services"
  ) %&gt;%
  gg_subseries(Turnover)

</code></pre>

<hr>
<h2 id='gg_tsdisplay'>Ensemble of time series displays</h2><span id='topic+gg_tsdisplay'></span>

<h3>Description</h3>

<p>Plots a time series along with its ACF along with an customisable third
graphic of either a PACF, histogram, lagged scatterplot or spectral density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gg_tsdisplay(
  data,
  y = NULL,
  plot_type = c("auto", "partial", "season", "histogram", "scatter", "spectrum"),
  lag_max = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gg_tsdisplay_+3A_data">data</code></td>
<td>
<p>A tidy time series object (tsibble)</p>
</td></tr>
<tr><td><code id="gg_tsdisplay_+3A_y">y</code></td>
<td>
<p>The variable to plot (a bare expression). If NULL, it will
automatically selected from the data.</p>
</td></tr>
<tr><td><code id="gg_tsdisplay_+3A_plot_type">plot_type</code></td>
<td>
<p>type of plot to include in lower right corner. By default
(<code>"auto"</code>) a season plot will be shown for seasonal data, a spectrum plot
will be shown for non-seasonal data without missing values, and a PACF will
be shown otherwise.</p>
</td></tr>
<tr><td><code id="gg_tsdisplay_+3A_lag_max">lag_max</code></td>
<td>
<p>maximum lag at which to calculate the acf. Default is 10*log10(N/m)
where N is the number of observations and m the number of series. Will be
automatically limited to one less than the number of observations in the series.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of ggplot objects showing useful plots of a time series.
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman &amp; Mitchell O'Hara-Wild
</p>


<h3>References</h3>

<p>Hyndman and Athanasopoulos (2019) <em>Forecasting: principles
and practice</em>, 3rd edition, OTexts: Melbourne, Australia.
<a href="https://OTexts.com/fpp3/">https://OTexts.com/fpp3/</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+plot.ts">plot.ts</a></code>, <code><a href="#topic+ACF">ACF</a></code>,
<code><a href="stats.html#topic+spec.ar">spec.ar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tsibble)
library(dplyr)
tsibbledata::aus_retail %&gt;%
  filter(
    State == "Victoria",
    Industry == "Cafes, restaurants and catering services"
  ) %&gt;%
  gg_tsdisplay(Turnover)

</code></pre>

<hr>
<h2 id='gg_tsresiduals'>Ensemble of time series residual diagnostic plots</h2><span id='topic+gg_tsresiduals'></span>

<h3>Description</h3>

<p>Plots the residuals using a time series plot, ACF and histogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gg_tsresiduals(data, type = "innovation", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gg_tsresiduals_+3A_data">data</code></td>
<td>
<p>A mable containing one model with residuals.</p>
</td></tr>
<tr><td><code id="gg_tsresiduals_+3A_type">type</code></td>
<td>
<p>The type of residuals to compute. If <code>type="response"</code>, residuals on the back-transformed data will be computed.</p>
</td></tr>
<tr><td><code id="gg_tsresiduals_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+gg_tsdisplay">gg_tsdisplay()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of ggplot objects showing a useful plots of a time series model's residuals.
</p>


<h3>References</h3>

<p>Hyndman and Athanasopoulos (2019) <em>Forecasting: principles
and practice</em>, 3rd edition, OTexts: Melbourne, Australia.
<a href="https://OTexts.com/fpp3/">https://OTexts.com/fpp3/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gg_tsdisplay">gg_tsdisplay()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("fable", quietly = TRUE)) {
library(fable)

tsibbledata::aus_production %&gt;%
  model(ETS(Beer)) %&gt;%
  gg_tsresiduals()
}

</code></pre>

<hr>
<h2 id='guerrero'>Guerrero's method for Box Cox lambda selection</h2><span id='topic+guerrero'></span>

<h3>Description</h3>

<p>Applies Guerrero's (1993) method to select the lambda which minimises the
coefficient of variation for subseries of x.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guerrero(x, lower = -0.9, upper = 2, .period = 2L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="guerrero_+3A_x">x</code></td>
<td>
<p>A numeric vector. The data used to identify the transformation
parameter lambda.</p>
</td></tr>
<tr><td><code id="guerrero_+3A_lower">lower</code></td>
<td>
<p>The lower bound for lambda.</p>
</td></tr>
<tr><td><code id="guerrero_+3A_upper">upper</code></td>
<td>
<p>The upper bound for lambda.</p>
</td></tr>
<tr><td><code id="guerrero_+3A_.period">.period</code></td>
<td>
<p>The length of each subseries (usually the length of seasonal
period). Subseries length must be at least 2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this function will give slightly different results to
<code>forecast::BoxCox.lambda(y)</code> if your data does not start at the start of the
seasonal period. This function will make use of all of your data, whereas the
forecast package will not use data that doesn't complete a seasonal period.
</p>


<h3>Value</h3>

<p>A Box Cox transformation parameter (lambda) chosen by Guerrero's method.
</p>


<h3>References</h3>

<p>Box, G. E. P. and Cox, D. R. (1964) An analysis of transformations. JRSS B 26 211–246.
</p>
<p>Guerrero, V.M. (1993) Time-series analysis supported by power transformations. Journal of Forecasting, 12, 37–48.
</p>

<hr>
<h2 id='ljung_box'>Portmanteau tests</h2><span id='topic+ljung_box'></span><span id='topic+box_pierce'></span><span id='topic+portmanteau_tests'></span>

<h3>Description</h3>

<p>Compute the Box–Pierce or Ljung–Box test statistic for examining the null hypothesis of independence in a given time series. These are sometimes known as ‘portmanteau’ tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ljung_box(x, lag = 1, dof = 0, ...)

box_pierce(x, lag = 1, dof = 0, ...)

portmanteau_tests
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ljung_box_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
<tr><td><code id="ljung_box_+3A_lag">lag</code></td>
<td>
<p>The number of lag autocorrelation coefficients to use in calculating the statistic</p>
</td></tr>
<tr><td><code id="ljung_box_+3A_dof">dof</code></td>
<td>
<p>Degrees of freedom of the fitted model (useful if x is a series of residuals).</p>
</td></tr>
<tr><td><code id="ljung_box_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.
</p>


<h3>Value</h3>

<p>A vector of numeric features for the test's statistic and p-value.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+box.test">stats::Box.test()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ljung_box(rnorm(100))

box_pierce(rnorm(100))
</code></pre>

<hr>
<h2 id='longest_flat_spot'>Longest flat spot length</h2><span id='topic+longest_flat_spot'></span><span id='topic+n_flat_spots'></span>

<h3>Description</h3>

<p>&quot;Flat spots” are computed by dividing the sample space of a time series into
ten equal-sized intervals, and computing the maximum run length within any
single interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>longest_flat_spot(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="longest_flat_spot_+3A_x">x</code></td>
<td>
<p>a vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value.
</p>


<h3>Author(s)</h3>

<p>Earo Wang and Rob J Hyndman
</p>

<hr>
<h2 id='n_crossing_points'>Number of crossing points</h2><span id='topic+n_crossing_points'></span>

<h3>Description</h3>

<p>Computes the number of times a time series crosses the median.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_crossing_points(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="n_crossing_points_+3A_x">x</code></td>
<td>
<p>a univariate time series</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value.
</p>


<h3>Author(s)</h3>

<p>Earo Wang and Rob J Hyndman
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3E+25'></span><span id='topic+as_tsibble'></span><span id='topic+autoplot'></span><span id='topic+autolayer'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+reexports">%&gt;%</a></code></p>
</dd>
<dt>ggplot2</dt><dd><p><code><a href="ggplot2.html#topic+autolayer">autolayer</a></code>, <code><a href="ggplot2.html#topic+autoplot">autoplot</a></code></p>
</dd>
<dt>tsibble</dt><dd><p><code><a href="tsibble.html#topic+as-tsibble">as_tsibble</a></code></p>
</dd>
</dl>

<hr>
<h2 id='scale_cf_lag'>lagged datetime scales
This set of scales defines new scales for lagged time structures.</h2><span id='topic+scale_cf_lag'></span><span id='topic+scale_x_cf_lag'></span>

<h3>Description</h3>

<p>lagged datetime scales
This set of scales defines new scales for lagged time structures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_x_cf_lag(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_cf_lag_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed on to scale_x_continuous()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggproto object inheriting from <code>Scale</code>
</p>

<hr>
<h2 id='shift_level_max'>Sliding window features</h2><span id='topic+shift_level_max'></span><span id='topic+shift_var_max'></span><span id='topic+shift_kl_max'></span>

<h3>Description</h3>

<p>Computes feature of a time series based on sliding (overlapping) windows.
<code>shift_level_max</code> finds the largest mean shift between two consecutive windows.
<code>shift_var_max</code> finds the largest var shift between two consecutive windows.
<code>shift_kl_max</code> finds the largest shift in Kulback-Leibler divergence between
two consecutive windows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shift_level_max(x, .size = NULL, .period = 1)

shift_var_max(x, .size = NULL, .period = 1)

shift_kl_max(x, .size = NULL, .period = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shift_level_max_+3A_x">x</code></td>
<td>
<p>a univariate time series</p>
</td></tr>
<tr><td><code id="shift_level_max_+3A_.size">.size</code></td>
<td>
<p>size of sliding window, if NULL <code>.size</code> will be automatically chosen using <code>.period</code></p>
</td></tr>
<tr><td><code id="shift_level_max_+3A_.period">.period</code></td>
<td>
<p>The seasonal period (optional)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the largest level shift and largest variance shift in sliding mean calculations
</p>


<h3>Value</h3>

<p>A vector of 2 values: the size of the shift, and the time index of the shift.
</p>


<h3>Author(s)</h3>

<p>Earo Wang, Rob J Hyndman and Mitchell O'Hara-Wild
</p>

<hr>
<h2 id='stat_arch_lm'>ARCH LM Statistic</h2><span id='topic+stat_arch_lm'></span>

<h3>Description</h3>

<p>Computes a statistic based on the Lagrange Multiplier (LM) test of Engle (1982) for
autoregressive conditional heteroscedasticity (ARCH). The statistic returned is
the <code class="reqn">R^2</code> value of an autoregressive model of order <code>lags</code> applied
to <code class="reqn">x^2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_arch_lm(x, lags = 12, demean = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stat_arch_lm_+3A_x">x</code></td>
<td>
<p>a univariate time series</p>
</td></tr>
<tr><td><code id="stat_arch_lm_+3A_lags">lags</code></td>
<td>
<p>Number of lags to use in the test</p>
</td></tr>
<tr><td><code id="stat_arch_lm_+3A_demean">demean</code></td>
<td>
<p>Should data have mean removed before test applied?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value.
</p>


<h3>Author(s)</h3>

<p>Yanfei Kang
</p>

<hr>
<h2 id='STL'>Multiple seasonal decomposition by Loess</h2><span id='topic+STL'></span>

<h3>Description</h3>

<p>Decompose a time series into seasonal, trend and remainder components.
Seasonal components are estimated iteratively using STL. Multiple seasonal periods are
allowed. The trend component is computed for the last iteration of STL.
Non-seasonal time series are decomposed into trend and remainder only.
In this case, <code><a href="stats.html#topic+supsmu">supsmu</a></code> is used to estimate the trend.
Optionally, the time series may be Box-Cox transformed before decomposition.
Unlike <code><a href="stats.html#topic+stl">stl</a></code>, <code>mstl</code> is completely automated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>STL(formula, iterations = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="STL_+3A_formula">formula</code></td>
<td>
<p>Decomposition specification (see &quot;Specials&quot; section).</p>
</td></tr>
<tr><td><code id="STL_+3A_iterations">iterations</code></td>
<td>
<p>Number of iterations to use to refine the seasonal component.</p>
</td></tr>
<tr><td><code id="STL_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="stats.html#topic+stl">stats::stl()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="fabletools.html#topic+dable">fabletools::dable()</a></code> containing the decomposed trend, seasonality
and remainder from the STL decomposition.
</p>


<h3>Specials</h3>



<h4>trend</h4>

<p>The <code>trend</code> special is used to specify the trend extraction parameters.
</p>
<pre>
trend(window, degree, jump)
</pre>

<table>
<tr>
 <td style="text-align: left;">
<code>window</code> </td><td style="text-align: left;"> The span (in lags) of the loess window, which should be odd. If NULL, the default, nextodd(ceiling((1.5*period) / (1-(1.5/s.window)))), is taken.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>degree</code> </td><td style="text-align: left;"> The degree of locally-fitted polynomial. Should be zero or one. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>jump</code>   </td><td style="text-align: left;"> Integers at least one to increase speed of the respective smoother. Linear interpolation happens between every <code>jump</code>th value.
</td>
</tr>

</table>




<h4>season</h4>

<p>The <code>season</code> special is used to specify the season extraction parameters.
</p>
<pre>
season(period = NULL, window = NULL, degree, jump)
</pre>

<table>
<tr>
 <td style="text-align: left;">
<code>period</code> </td><td style="text-align: left;"> The periodic nature of the seasonality. This can be either a number indicating the number of observations in each seasonal period, or text to indicate the duration of the seasonal window (for example, annual seasonality would be "1 year").</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>window</code> </td><td style="text-align: left;"> The span (in lags) of the loess window, which should be odd. If the <code>window</code> is set to <code>"periodic"</code> or <code>Inf</code>, the seasonal pattern will be fixed. The window size should be odd and at least 7, according to Cleveland et al. The default (NULL) will choose an appropriate default, for a dataset with one seasonal pattern this would be 11, the second larger seasonal window would be 15, then 19, 23, ... onwards.</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>degree</code> </td><td style="text-align: left;"> The degree of locally-fitted polynomial. Should be zero or one. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>jump</code>   </td><td style="text-align: left;"> Integers at least one to increase speed of the respective smoother. Linear interpolation happens between every <code>jump</code>th value.
</td>
</tr>

</table>




<h4>lowpass</h4>

<p>The <code>lowpass</code> special is used to specify the low-pass filter parameters.
</p>
<pre>
lowpass(window, degree, jump)
</pre>

<table>
<tr>
 <td style="text-align: left;">
<code>window</code> </td><td style="text-align: left;"> The span (in lags) of the loess window of the low-pass filter used for each subseries. Defaults to the smallest odd integer greater than or equal to the seasonal <code>period</code> which is recommended since it prevents competition between the trend and seasonal components. If not an odd integer its given value is increased to the next odd one. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>degree</code> </td><td style="text-align: left;"> The degree of locally-fitted polynomial. Must be zero or one. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>jump</code>   </td><td style="text-align: left;"> Integers at least one to increase speed of the respective smoother. Linear interpolation happens between every <code>jump</code>th value.
</td>
</tr>

</table>




<h3>References</h3>

<p>R. B. Cleveland, W. S. Cleveland, J.E. McRae, and I. Terpenning (1990) STL: A Seasonal-Trend Decomposition Procedure Based on Loess. Journal of Official Statistics, 6, 3–73.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+stl">stl</a></code>, <code><a href="stats.html#topic+supsmu">supsmu</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as_tsibble(USAccDeaths) %&gt;%
  model(STL(value ~ trend(window = 10))) %&gt;%
  components()

</code></pre>

<hr>
<h2 id='unitroot_kpss'>Unit root tests</h2><span id='topic+unitroot_kpss'></span><span id='topic+unitroot_pp'></span>

<h3>Description</h3>

<p>Performs a test for the existence of a unit root in the vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unitroot_kpss(x, type = c("mu", "tau"), lags = c("short", "long", "nil"), ...)

unitroot_pp(
  x,
  type = c("Z-tau", "Z-alpha"),
  model = c("constant", "trend"),
  lags = c("short", "long"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unitroot_kpss_+3A_x">x</code></td>
<td>
<p>A vector to be tested for the unit root.</p>
</td></tr>
<tr><td><code id="unitroot_kpss_+3A_type">type</code></td>
<td>
<p>Type of deterministic part.</p>
</td></tr>
<tr><td><code id="unitroot_kpss_+3A_lags">lags</code></td>
<td>
<p>Maximum number of lags used for error term correction.</p>
</td></tr>
<tr><td><code id="unitroot_kpss_+3A_...">...</code></td>
<td>
<p>Arguments passed to unit root test function.</p>
</td></tr>
<tr><td><code id="unitroot_kpss_+3A_model">model</code></td>
<td>
<p>Determines the deterministic part in the test regression.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>unitroot_kpss</code> computes the statistic for the Kwiatkowski et al. unit root test with linear trend and lag 1.
</p>
<p><code>unitroot_pp</code> computes the statistic for the <code>Z-tau</code> version of Phillips &amp; Perron unit root test with constant trend and lag 1.
</p>


<h3>Value</h3>

<p>A vector of numeric features for the test's statistic and p-value.
</p>


<h3>See Also</h3>

<p><code><a href="urca.html#topic+ur.kpss">urca::ur.kpss()</a></code>
</p>
<p><code><a href="urca.html#topic+ur.pp">urca::ur.pp()</a></code>
</p>

<hr>
<h2 id='unitroot_ndiffs'>Number of differences required for a stationary series</h2><span id='topic+unitroot_ndiffs'></span><span id='topic+unitroot_nsdiffs'></span>

<h3>Description</h3>

<p>Use a unit root function to determine the minimum number of differences
necessary to obtain a stationary time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unitroot_ndiffs(
  x,
  alpha = 0.05,
  unitroot_fn = ~unitroot_kpss(.)["kpss_pvalue"],
  differences = 0:2,
  ...
)

unitroot_nsdiffs(
  x,
  alpha = 0.05,
  unitroot_fn = ~feat_stl(., .period)[2] &lt; 0.64,
  differences = 0:2,
  .period = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unitroot_ndiffs_+3A_x">x</code></td>
<td>
<p>A vector to be tested for the unit root.</p>
</td></tr>
<tr><td><code id="unitroot_ndiffs_+3A_alpha">alpha</code></td>
<td>
<p>The level of the test.</p>
</td></tr>
<tr><td><code id="unitroot_ndiffs_+3A_unitroot_fn">unitroot_fn</code></td>
<td>
<p>A function (or lambda) that provides a p-value for a unit root test.</p>
</td></tr>
<tr><td><code id="unitroot_ndiffs_+3A_differences">differences</code></td>
<td>
<p>The possible differences to consider.</p>
</td></tr>
<tr><td><code id="unitroot_ndiffs_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code>unitroot_fn</code> function</p>
</td></tr>
<tr><td><code id="unitroot_ndiffs_+3A_.period">.period</code></td>
<td>
<p>The period of the seasonality.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the default 'unit root function' for <code>unitroot_nsdiffs()</code> is based
on the seasonal strength of an STL decomposition. This is not a test for the
presence of a seasonal unit root, but generally works reasonably well in
identifying the presence of seasonality and the need for a seasonal
difference.
</p>


<h3>Value</h3>

<p>A numeric corresponding to the minimum required differences for stationarity.
</p>

<hr>
<h2 id='var_tiled_var'>Time series features based on tiled windows</h2><span id='topic+var_tiled_var'></span><span id='topic+var_tiled_mean'></span>

<h3>Description</h3>

<p>Computes feature of a time series based on tiled (non-overlapping) windows.
Means or variances are produced for all tiled windows. Then stability is
the variance of the means, while lumpiness is the variance of the variances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_tiled_var(x, .size = NULL, .period = 1)

var_tiled_mean(x, .size = NULL, .period = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="var_tiled_var_+3A_x">x</code></td>
<td>
<p>a univariate time series</p>
</td></tr>
<tr><td><code id="var_tiled_var_+3A_.size">.size</code></td>
<td>
<p>size of sliding window, if NULL <code>.size</code> will be automatically chosen using <code>.period</code></p>
</td></tr>
<tr><td><code id="var_tiled_var_+3A_.period">.period</code></td>
<td>
<p>The seasonal period (optional)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length 2 containing a measure of lumpiness and
a measure of stability.
</p>


<h3>Author(s)</h3>

<p>Earo Wang and Rob J Hyndman
</p>

<hr>
<h2 id='X_13ARIMA_SEATS'>X-13ARIMA-SEATS Seasonal Adjustment</h2><span id='topic+X_13ARIMA_SEATS'></span>

<h3>Description</h3>

<p>X-13ARIMA-SEATS is a seasonal adjustment program developed and maintained by
the U.S. Census Bureau.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>X_13ARIMA_SEATS(
  formula,
  ...,
  na.action = seasonal::na.x13,
  defaults = c("seasonal", "none")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="X_13ARIMA_SEATS_+3A_formula">formula</code></td>
<td>
<p>Decomposition specification.</p>
</td></tr>
<tr><td><code id="X_13ARIMA_SEATS_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="seasonal.html#topic+seas">seasonal::seas()</a></code>.</p>
</td></tr>
<tr><td><code id="X_13ARIMA_SEATS_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain NAs. <code>na.omit</code> (default), <code>na.exclude</code> or <code>na.fail</code>.
If <code>na.action = na.x13</code>, NA handling is done by X-13, i.e. NA values
are substituted by -99999.</p>
</td></tr>
<tr><td><code id="X_13ARIMA_SEATS_+3A_defaults">defaults</code></td>
<td>
<p>If defaults=&quot;seasonal&quot;, the default options of
<code><a href="seasonal.html#topic+seas">seasonal::seas()</a></code> will be used, which should work well in most
circumstances. Setting defaults=&quot;none&quot; gives an empty model specification,
which can be added to in the model formula.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The SEATS decomposition method stands for &quot;Seasonal
Extraction in ARIMA Time Series&quot;, and is the default method for seasonally
adjusting the data. This decomposition method can extract seasonality from
data with seasonal periods of 2 (biannual), 4 (quarterly), 6 (bimonthly),
and 12 (monthly). This method is specified using the <code>seats()</code> function in
the model formula.
</p>
<p>Alternatively, the seasonal adjustment can be done using an enhanced X-11
decomposition method. The X-11 method uses weighted averages over a moving
window of the time series. This is used in combination with the RegARIMA
model to prepare the data for decomposition. To use the X-11 decomposition
method, the <code>x11()</code> function can be used in the model formula.
</p>


<h3>Specials</h3>

<p>The specials of the X-13ARIMA-SEATS model closely follow the individual
specification options of the original function. Refer to
<a href="https://www2.census.gov/software/x-13arima-seats/x13as/windows/documentation/docx13as.pdf#chapter.7">Chapter 7 of the X-13ARIMA-SEATS Reference Manual</a>
for full details of the arguments.
</p>
<p>The available specials for this model are:
</p>
<p>#' </p>


<h4>arima</h4>

<p>The <code>arima</code> special is used to specify the ARIMA part of the regARIMA model.
This defines a pure ARIMA model if the <code>regression()</code> special absent and if
no exogenous regressors are specified. The lags of the ARIMA model can be
specified in the <code>model</code> argument, potentially along with <code>ar</code> and <code>ma</code>
coefficients.
</p>
<pre>
arima(...)
</pre>

<table>
<tr>
 <td style="text-align: left;">
<code>...</code>   </td><td style="text-align: left;"> Arguments described in the reference manual linked below.
</td>
</tr>

</table>




<h4>automdl</h4>

<p>The <code>automdl</code> special is used to specify the ARIMA part of the regARIMA
model will be sought using an automatic model selection procedure
derived from the one used by TRAMO (see Gomez and Maravall (2001a)). The
maximum order of lags and differencing can be specified using <code>maxorder</code> and
<code>maxdiff</code> arguments. Models containing mixtures of AR and MA components can
be allowed or disallowed using the <code>mixed</code> argument.
</p>
<pre>
automdl(...)
</pre>

<table>
<tr>
 <td style="text-align: left;">
<code>...</code>   </td><td style="text-align: left;"> Arguments described in the reference manual linked below.
</td>
</tr>

</table>




<h4>check</h4>

<p>The <code>check</code> special is used to produce statistics for diagnostic checking of
residuals from the estimated model. The computed statistics include ACF and
PACF of residuals, along with some statistical tests. These calculations are
included in the model object, but difficult to access. It is recommended that
these checks are done in R after estimating the model, and that this special
is not used.
</p>
<pre>
check(...)
</pre>

<table>
<tr>
 <td style="text-align: left;">
<code>...</code>   </td><td style="text-align: left;"> Arguments described in the reference manual linked below.
</td>
</tr>

</table>




<h4>estimate</h4>

<p>The <code>estimate</code> special is used to specify optimisation parameters and
estimation options for the regARIMA model specified by the <code>regression()</code>
and <code>arima()</code> specials. Among other options, the tolerance can be set with
<code>tol</code>, and maximum iterations can be set with <code>maxiter</code>.
</p>
<pre>
estimate(...)
</pre>

<table>
<tr>
 <td style="text-align: left;">
<code>...</code>   </td><td style="text-align: left;"> Arguments described in the reference manual linked below.
</td>
</tr>

</table>




<h4>force</h4>

<p>The <code>force</code> is an optional special for invoking options that allow users to
force yearly totals of the seasonally adjusted series to equal those of the
original series for convenience.
</p>
<pre>
force(...)
</pre>

<table>
<tr>
 <td style="text-align: left;">
<code>...</code>   </td><td style="text-align: left;"> Arguments described in the reference manual linked below.
</td>
</tr>

</table>




<h4>forecast</h4>

<p>The <code>forecast</code> special is used to specify options for forecasting and/or
backcasting the time series using the estimated model. This process is used
to enhance the decomposition procedure, especially its performance at the
start and end of the series. The number of forecasts to produce is specified
in the <code>maxlead</code> argument, and the number of backcasts in the <code>maxback</code>
argument.
</p>
<pre>
forecast(...)
</pre>

<table>
<tr>
 <td style="text-align: left;">
<code>...</code>   </td><td style="text-align: left;"> Arguments described in the reference manual linked below.
</td>
</tr>

</table>




<h4>history</h4>

<p>The <code>history</code> special is an optional special for requesting a sequence of
runs from a sequence of truncated versions of the time series. Using this
special can substantially slow down the program.
</p>
<pre>
history(...)
</pre>

<table>
<tr>
 <td style="text-align: left;">
<code>...</code>   </td><td style="text-align: left;"> Arguments described in the reference manual linked below.
</td>
</tr>

</table>




<h4>metadata</h4>

<p>The <code>metadata</code> special is used to insert metadata into the diagnostic summary
file. This is typically not needed when interacting with the program via R.
</p>
<pre>
metadata(...)
</pre>

<table>
<tr>
 <td style="text-align: left;">
<code>...</code>   </td><td style="text-align: left;"> Arguments described in the reference manual linked below.
</td>
</tr>

</table>




<h4>identify</h4>

<p>The <code>identify</code> special is used to produce tables and line printer plots of
sample ACFs and PACFs for identifying the ARIMA part of a regARIMA model.
</p>
<pre>
identify(...)
</pre>

<table>
<tr>
 <td style="text-align: left;">
<code>...</code>   </td><td style="text-align: left;"> Arguments described in the reference manual linked below.
</td>
</tr>

</table>




<h4>outlier</h4>

<p>The <code>outlier</code> special is used to perform automatic detection of additive
(point) outliers, temporary change outliers, level shifts, or any combination
of the three using the specified model. The <code>seasonal::seas()</code> defaults used
when <code>defaults="seasonal"</code> will include the default automatic detection of
outliers.
</p>
<pre>
outlier(...)
</pre>

<table>
<tr>
 <td style="text-align: left;">
<code>...</code>   </td><td style="text-align: left;"> Arguments described in the reference manual linked below.
</td>
</tr>

</table>




<h4>pickmdl</h4>

<p>The <code>pickmdl</code> special is used to specify the ARIMA part of the regARIMA
model will be sought using an automatic model selectionprocedure
similar to the one used by X-11-ARIMA/88 (see Dagum 1988).
</p>
<pre>
pickmdl(...)
</pre>

<table>
<tr>
 <td style="text-align: left;">
<code>...</code>   </td><td style="text-align: left;"> Arguments described in the reference manual linked below.
</td>
</tr>

</table>




<h4>regression</h4>

<p>The <code>regression</code> special is used to specify including regression variables
in a regARIMA model, or for specifying regression variables whose
effects are to be removed by the <code>identify()</code> special to aid ARIMA model
identification. Any exogenous regressors specified in the model formula will
be passed into this specification via the <code>user</code> and <code>data</code> arguments. The
<code><a href="seasonal.html#topic+seas">seasonal::seas()</a></code> defaults used when <code>defaults="seasonal"</code> will set
<code>aictest = c("td", "easter")</code>, indicating that trading days and Easter
effects will be included conditional on AIC-based selection methods.
</p>
<pre>
regression(...)
</pre>

<table>
<tr>
 <td style="text-align: left;">
<code>...</code>   </td><td style="text-align: left;"> Arguments described in the reference manual linked below.
</td>
</tr>

</table>




<h4>seats</h4>

<p>The <code>seats</code> special is optionally used to invoke the production of model
based signal extraction using SEATS, a seasonal adjustment program developed
by Victor Gomez and Agustin Maravall at the Bank of Spain.
</p>
<pre>
seats(...)
</pre>

<table>
<tr>
 <td style="text-align: left;">
<code>...</code>   </td><td style="text-align: left;"> Arguments described in the reference manual linked below.
</td>
</tr>

</table>




<h4>slidingspans</h4>

<p>The optional <code>slidingspans</code> special is to provide sliding spans stability
analysis on the model. These compare different features of seasonal
adjustment output from overlapping subspans of the time series data.
</p>
<pre>
slidingspans(...)
</pre>

<table>
<tr>
 <td style="text-align: left;">
<code>...</code>   </td><td style="text-align: left;"> Arguments described in the reference manual linked below.
</td>
</tr>

</table>




<h4>spectrum</h4>

<p>The optional <code>spectrum</code> special is used to provide a choice between two
spectrum diagnostics to detect seasonality or trading day effects in
monthly series.
</p>
<pre>
spectrum(...)
</pre>

<table>
<tr>
 <td style="text-align: left;">
<code>...</code>   </td><td style="text-align: left;"> Arguments described in the reference manual linked below.
</td>
</tr>

</table>




<h4>transform</h4>

<p>The <code>transform</code> special is used to transform or adjust the series prior to
estimating a regARIMA model. This is comparable to transforming the response
on the formula's left hand side, but offers X-13ARIMA-SEATS specific
adjustment options.
</p>
<pre>
transform(...)
</pre>

<table>
<tr>
 <td style="text-align: left;">
<code>...</code>   </td><td style="text-align: left;"> Arguments described in the reference manual linked below.
</td>
</tr>

</table>




<h4>x11</h4>

<p>The optional <code>x11</code> special is used to invoke seasonal adjustment by
an enhanced version of the methodology of the Census Bureau X-11 and X-11Q
programs. The user can control the type of seasonal adjustment decomposition
calculated (<code>mode</code>), the seasonal and trend moving averages used
(<code>seasonalma</code> and <code>trendma</code>), and the type of extreme value adjustment
performed during seasonal adjustment (<code>sigmalim</code>).
</p>
<pre>
x11(...)
</pre>

<table>
<tr>
 <td style="text-align: left;">
<code>...</code>   </td><td style="text-align: left;"> Arguments described in the reference manual linked below.
</td>
</tr>

</table>




<h4>x11regression</h4>

<p>The <code>x11regression</code> special is used in conjunction with the <code>x11()</code> special
for series without missing observations. This special estimates calendar
effects by regression modeling of the irregular component with predefined or
user-defined regressors. Any exogenous regressors specified in the model
formula will be passed into this specification via the <code>user</code> and <code>data</code>
arguments.
</p>
<pre>
x11regression(...)
</pre>

<table>
<tr>
 <td style="text-align: left;">
<code>...</code>   </td><td style="text-align: left;"> Arguments described in the reference manual linked below.
</td>
</tr>

</table>




<h3>References</h3>

<p>Gomez, Victor, and Agustin Maravall. &quot;Automatic modeling methods for
univariate series.&quot; A course in time series analysis (2001): 171-201.
</p>
<p>Dagum, E.B. (1988), The X11 ARIMA/88 Seasonal Adjustment Method - Foundations
And User’s Manual, Time Series Research and Analysis Division Statistics
Canada, Ottawa.
</p>
<p>Dagum, E. B., &amp; Bianconcini, S. (2016) &quot;Seasonal adjustment methods and real
time trend-cycle estimation&quot;. <em>Springer</em>.
</p>
<p>X-13ARIMA-SEATS Documentation from the seasonal package's website:
http://www.seasonal.website/seasonal.html
</p>
<p>Official X-13ARIMA-SEATS manual: <a href="https://www2.census.gov/software/x-13arima-seats/x13as/windows/documentation/docx13as.pdf">https://www2.census.gov/software/x-13arima-seats/x13as/windows/documentation/docx13as.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="seasonal.html#topic+seas">seasonal::seas()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

fit &lt;- tsibbledata::aus_production %&gt;%
  model(X_13ARIMA_SEATS(Beer))

report(fit)
components(fit)

# Additive X-11 decomposition
fit &lt;- tsibbledata::aus_production %&gt;%
  model(X_13ARIMA_SEATS(Beer ~ transform(`function` = "none") + x11(mode = "add")))

report(fit)
components(fit)



</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
