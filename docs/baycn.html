<!DOCTYPE html><html><head><title>Help for package baycn</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {baycn}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#baycn-class'><p>baycn class</p></a></li>
<li><a href='#drosophila'><p>Tissue type and transcription factor binding data during Drosophila mesoderm</p>
development</a></li>
<li><a href='#geuvadis'><p>Genotype and gene expression data from the GEUVADIS project</p></a></li>
<li><a href='#mhEdge'><p>mhEdge</p></a></li>
<li><a href='#mse'><p>mse</p></a></li>
<li><a href='#plot+2Cbaycn-method'><p>plot</p></a></li>
<li><a href='#prerec'><p>prerec</p></a></li>
<li><a href='#show+2Cbaycn-method'><p>show</p></a></li>
<li><a href='#simdata'><p>simdata</p></a></li>
<li><a href='#summary+2Cbaycn-method'><p>summary</p></a></li>
<li><a href='#tracePlot'><p>tracePlot</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Inference for Causal Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Evan A Martin [aut, cre], Audrey Qiuyan Fu [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Evan A Martin &lt;evanamartin@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A Bayesian hybrid approach for inferring Directed Acyclic Graphs
    (DAGs) for continuous, discrete, and mixed data. The algorithm can use the 
    graph inferred by another more efficient graph inference method as input;
    the input graph may contain false edges or undirected edges but can help
    reduce the search space to a more manageable size. A Bayesian Markov chain
    Monte Carlo algorithm is then used to infer the probability of direction and
    absence for the edges in the network.
    References:
    Martin and Fu (2019) &lt;<a href="https://doi.org/10.48550/arXiv.1909.10678">doi:10.48550/arXiv.1909.10678</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>egg, ggplot2, gtools, igraph, MASS, methods</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-07-26 01:03:48 UTC; Evatar</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-07-31 18:40:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='baycn-class'>baycn class</h2><span id='topic+baycn-class'></span>

<h3>Description</h3>

<p>baycn class
</p>


<h3>Slots</h3>


<dl>
<dt><code>burnIn</code></dt><dd><p>The percentage of MCMC iterations that will be discarded from
the beginning of the chain.</p>
</dd>
<dt><code>chain</code></dt><dd><p>A matrix where the rows contain the vector of edge states for the
accepted graph.</p>
</dd>
<dt><code>decimal</code></dt><dd><p>A vector of decimal numbers. Each element in the vector is the
decimal of the accepted graph.</p>
</dd>
<dt><code>iterations</code></dt><dd><p>The number of iterations for which the Metropolis-Hastings
algorithm is run.</p>
</dd>
<dt><code>posteriorES</code></dt><dd><p>A matrix of posterior probabilities for all three edge
states for each edge in the network.</p>
</dd>
<dt><code>posteriorPM</code></dt><dd><p>A posterior probability adjacency matrix.</p>
</dd>
<dt><code>likelihood</code></dt><dd><p>A vector of log likelihood values. Each element in the
vector is the log likelihood of the accepted graph.</p>
</dd>
<dt><code>stepSize</code></dt><dd><p>The number of iterations discarded between each iteration that
is kept.</p>
</dd>
<dt><code>time</code></dt><dd><p>The runtime of the Metropolis-Hastings algorithm in seconds.</p>
</dd>
</dl>

<hr>
<h2 id='drosophila'>Tissue type and transcription factor binding data during Drosophila mesoderm
development</h2><span id='topic+drosophila'></span>

<h3>Description</h3>

<p>Zinzen et al. (2009) measured in vivo transcription factor binding for five
key transcription factors using ChIP-chip assays at two hour intervals during
drosophila mesoderm development. The five transcription factors are: Twist
(Twi), Tinman (Tin), Myocyte enhancing factor 2 (Mef2), Bagpipe (Bap), and
Biniou (Bin). Both Twi and Tin were assayed from 2-8 hours, Mef2 from 2-12
hours, Bap from 6-8 hours, and Bin from 6-12 hours. In addition, Zinzen et
al. identified six tissue types based on tissue specific expression: mesoderm
(Meso), somatic muscle (SM), visceral muscle (VM), cardiac muscle (CM),
mesoderm and somatic muscle (Meso&amp;SM), and somatic and visceral muscle
(SM&amp;VM). All data are binary and measured at 310 cis-regulatory modules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(drosophila)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"list"</code> containing tissue type and
transcription factor binding data. The first element in the list is a matrix
which contains the data in the original form. The second element in the list
is a matrix that contains the binary data. For this matrix any value greater
than zero to changed to a one. For both data sets the tissue type data
appears in the first six columns of the data matrix and the remaining 15
columns contain the transcription factor binding data.
</p>


<h3>Source</h3>

<p><a href="https://www.nature.com/articles/nature08531#Sec22">https://www.nature.com/articles/nature08531#Sec22</a>
</p>


<h3>References</h3>

<p>Zinzen, R., Girardot, C., Gagneur, J. et al. Combinatorial
binding predicts spatio-temporal cis-regulatory activity. Nature 462, 65–70
(2009) doi:10.1038/nature08531
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the data.
data(drosophila)

# Display the first 5 rows and 8 columns of the continuous data matrix.
drosophila$continuous[1:5, 1:8]

# Display the first 5 rows and 8 columns of the discrete data matrix.
drosophila$discrete[1:5, 1:8]

</code></pre>

<hr>
<h2 id='geuvadis'>Genotype and gene expression data from the GEUVADIS project</h2><span id='topic+geuvadis'></span>

<h3>Description</h3>

<p>The GEUVADIS (Genetic European Variation in Disease) project (Lappalainen et
al., 2013) measured the gene expression in Lymphoblastoid Cell Lines (LCLs)
from a subset of individuals from the 1,000 Genomes Project (Auton et al.,
2015), which measured the genotypes of individuals from multiple ethnicities.
This data set contains genotype and gene expression data from 373 European
individuals. The data are divided into 46 sets which each contain data from
an expression quantitative trait locus (eQTL) and its associated genes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(geuvadis)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"list"</code> containing 46 eQTL-gene sets. Each
element of the list is a matrix with the observations down the rows and the
eQTL and genes across the columns. The first column in the matrix contains
the genotype (eQTL) data and the remaining columns contain the gene
expression data.
</p>


<h3>Source</h3>

<p><a href="https://www.ebi.ac.uk/arrayexpress/files/E-GEUV-1/analysis_results/">https://www.ebi.ac.uk/arrayexpress/files/E-GEUV-1/analysis_results/</a>
</p>


<h3>References</h3>

<p>Lappalainen, T., Sammeth, M., Friedländer, M. et al.
Transcriptome and genome sequencing uncovers functional variation in humans.
Nature 501, 506–511 (2013) doi:10.1038/nature12531
</p>
<p>Auton, A., Abecasis, G., Altshuler, D. et al. A global reference for human
genetic variation. Nature 526, 68–74 (2015) doi:10.1038/nature15393
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the data.
data(geuvadis)

# Display the first 6 rows of the eQTL-gene set Q8.
head(geuvadis$Q8)

</code></pre>

<hr>
<h2 id='mhEdge'>mhEdge</h2><span id='topic+mhEdge'></span>

<h3>Description</h3>

<p>The main function for the Metropolis-Hastings algorithm. It returns the
posterior distribution of the edge directions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mhEdge(
  data,
  adjMatrix,
  prior = c(0.05, 0.05, 0.9),
  nCPh = 0,
  nGV = 0,
  pmr = FALSE,
  burnIn = 0.2,
  iterations = 1000,
  thinTo = 200,
  progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mhEdge_+3A_data">data</code></td>
<td>
<p>A matrix with the variables across the columns and the
observations down the rows. If there are genetic variants in the data these
variables must come before the remaining variables. If there are clinical
phenotypes in the data these variables must come after all other variables.
For example, if there is a data set with one genetic variant variable, three
gene expression variables, and one clinical phenotype variable the first
column in the data matrix must contain the genetic variant data, the next
three columns will contain the gene expression data, and the last column will
contain the clinical phenotype data.</p>
</td></tr>
<tr><td><code id="mhEdge_+3A_adjmatrix">adjMatrix</code></td>
<td>
<p>An adjacency matrix indicating the edges that will be
considered by the Metropolis-Hastings algorithm. An adjacency matrix is a
matrix of zeros and ones. The ones represent an edge and its direction
between two nodes.</p>
</td></tr>
<tr><td><code id="mhEdge_+3A_prior">prior</code></td>
<td>
<p>A vector containing the prior probability for the three edge
states.</p>
</td></tr>
<tr><td><code id="mhEdge_+3A_ncph">nCPh</code></td>
<td>
<p>The number of clinical phenotypes in the graph.</p>
</td></tr>
<tr><td><code id="mhEdge_+3A_ngv">nGV</code></td>
<td>
<p>The number of genetic variants in the graph.</p>
</td></tr>
<tr><td><code id="mhEdge_+3A_pmr">pmr</code></td>
<td>
<p>Logical. If true the Metropolis-Hastings algorithm will use the
Principle of Mendelian Randomization (PMR). This prevents the direction of an
edge pointing from a gene expression or a clinical phenotype node to a
genetic variant node.</p>
</td></tr>
<tr><td><code id="mhEdge_+3A_burnin">burnIn</code></td>
<td>
<p>A number between 0 and 1 indicating the percentage of the
sample that will be discarded.</p>
</td></tr>
<tr><td><code id="mhEdge_+3A_iterations">iterations</code></td>
<td>
<p>An integer for the number of iterations to run the MH
algorithm.</p>
</td></tr>
<tr><td><code id="mhEdge_+3A_thinto">thinTo</code></td>
<td>
<p>An integer indicating the number of observations the chain
should be thinned to.</p>
</td></tr>
<tr><td><code id="mhEdge_+3A_progress">progress</code></td>
<td>
<p>Logical. If TRUE the runtime in seconds for the cycle finder
and log likelihood functions and a progress bar will be printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class baycn containing 9 elements:
</p>

<ul>
<li><p> burnIn &ndash; The percentage of MCMC iterations that will be discarded from
the beginning of the chain.
</p>
</li>
<li><p> chain &ndash; A matrix where each row contains the vector of edge states for
the accepted graph.
</p>
</li>
<li><p> decimal &ndash; A vector of decimal numbers. Each element in the vector is
the decimal of the accepted graph.
</p>
</li>
<li><p> iterations &ndash; The number of iterations for which the
Metropolis-Hastings algorithm is run.
</p>
</li>
<li><p> posteriorES &ndash; A matrix of posterior probabilities for all three edge
states for each edge in the network.
</p>
</li>
<li><p> posteriorPM &ndash; A posterior probability adjacency matrix.
</p>
</li>
<li><p> likelihood &ndash; A vector of log likelihood values. Each element in the
vector is the log likelihood of the accepted graph.
</p>
</li>
<li><p> stepSize &ndash; The number of MCMC iterations discarded between each
accepted graph.
</p>
</li>
<li><p> time &ndash; The runtime of the Metropolis-Hastings algorithm in seconds.
</p>
</li></ul>



<h3>References</h3>

<p>Martin, E. A. and Fu, A. Q. (2019). A Bayesian approach to
directed acyclic graphs with a candidate graph. <em>arXiv preprint
arXiv:1909.10678</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate data under topology m1_gv.
# Use ?simdata for a description and graph of m1_gv.
data_m1 &lt;- simdata(b0 = 0,
                   N = 200,
                   s = 1,
                   graph = 'm1_gv',
                   ss = 1,
                   q = 0.27)

# Create an adjacency matrix with the true edges.
am_m1 &lt;- matrix(c(0, 1, 0,
                  0, 0, 1,
                  0, 0, 0),
                byrow = TRUE,
                nrow = 3)

# Run the Metropolis-Hastings algorithm on the data from m1_gv using the
# Principle of Mendelian Randomization (PMR) and the true edges as the input.
mh_m1_pmr &lt;- mhEdge(data = data_m1,
                    adjMatrix = am_m1,
                    prior = c(0.05,
                              0.05,
                              0.9),
                    nCPh = 0,
                    nGV = 1,
                    pmr = TRUE,
                    burnIn = 0.2,
                    iterations = 1000,
                    thinTo = 200,
                    progress = FALSE)

summary(mh_m1_pmr)

# Generate data under topology gn4.
# Use ?simdata for a description and graph of gn4.
data_gn4 &lt;- simdata(b0 = 0,
                    N = 200,
                    s = 1,
                    graph = 'gn4',
                    ss = 1)

# Create an adjacency matrix with the true edges.
am_gn4 &lt;- matrix(c(0, 1, 1, 0,
                   0, 0, 0, 1,
                   0, 0, 0, 0,
                   0, 0, 1, 0),
                 byrow = TRUE,
                 nrow = 4)

# Run the Metropolis-Hastings algorithm on the data from gn4 with the true
# edges as the input.
mh_gn4 &lt;- mhEdge(data = data_gn4,
                 adjMatrix = am_gn4,
                 prior = c(0.05,
                           0.05,
                           0.9),
                 nCPh = 0,
                 nGV = 0,
                 pmr = FALSE,
                 burnIn = 0.2,
                 iterations = 1000,
                 thinTo = 200,
                 progress = FALSE)

summary(mh_gn4)

</code></pre>

<hr>
<h2 id='mse'>mse</h2><span id='topic+mse'></span>

<h3>Description</h3>

<p>Calculates either the edge-wise or whole graph MSE. If more than one data set
is input the mean and standard deviation of the MSE will be calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mse(posterior, expected, adjMatrix, type = "emse")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mse_+3A_posterior">posterior</code></td>
<td>
<p>A list of baycn objects or posterior probability adjacency
matrices. Each element in posterior can also be a list. For example, if
multiple data sets were generated under the same simulation scheme and baycn
was run on each data set, the input list could be a list containing the
output from each run of baycn. In this scenario the mean and standard
deviation of of the edgewise or whole graph MSE would be output.</p>
</td></tr>
<tr><td><code id="mse_+3A_expected">expected</code></td>
<td>
<p>The expected edge state probabilities for each edge. This
must be a matrix with the expected probability for the three edge states
across the columns and each edge down the rows.</p>
</td></tr>
<tr><td><code id="mse_+3A_adjmatrix">adjMatrix</code></td>
<td>
<p>This is only required if the input to posterior is a
posterior probability adjacency matrix (for example, output from the BiDAG or
structmcmc pacakges). This matrix will be used to convert the posterior
probability adjacency matrix to an edge state matrix. Only the edges in
adjMatrix will be converted to the edge state matrix. To consider all
possible edges use a fully connected adjacency matrix.</p>
</td></tr>
<tr><td><code id="mse_+3A_type">type</code></td>
<td>
<p>A character string indicating the type of MSE to be calculated.
The two options are 'emse' - edge-wise MSE or 'gmse' - whole graph MSE.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(3)

# Generate data from topology M2.
data_m2 &lt;- simdata(graph = 'm2_ge',
                   N = 200,
                   b0 = 0,
                   ss = 1,
                   s = 1)

# Adjacency matrix for topology M2
am_m2 &lt;- matrix(c(0, 1, 1,
                  0, 0, 1,
                  0, 0, 0),
                byrow = TRUE,
                nrow = 3)

# Run baycn on the data from topology M2.
baycn_m2 &lt;- mhEdge(data = data_m2,
                   adjMatrix = am_m2,
                   prior = c(0.05,
                             0.05,
                             0.9),
                   nCPh = 0,
                   nGV = 0,
                   pmr = FALSE,
                   iterations = 1000,
                   burnIn = 0.2,
                   thinTo = 500,
                   progress = FALSE)

# Expected probabilities for topology M2.
ep_m2 &lt;- matrix(c(1, 0, 0,
                  0, 0, 1,
                  0, 1, 0),
                byrow = TRUE,
                ncol = 3)

# Calculate the edgewise MSE.
emse_m2 &lt;- mse(posterior = list(baycn_m2),
               expected = ep_m2,
               type = 'emse')


# When a list with two levels is passed posterior the mean and standard
# deviation of the MSE is returned. Below is an example demonstrating this
# feature.

# Adjacency matrix for topology M2
am_m2 &lt;- matrix(c(0, 1, 1,
                  0, 0, 1,
                  0, 0, 0),
                byrow = TRUE,
                nrow = 3)

# Create a list to hold multiple M2 data sets.
data_m2 &lt;- vector(mode = 'list',
                  length = 5)

# Create a list to hold the output from baycn.
baycn_m2 &lt;- vector(mode = 'list',
                   length = 5)

for (e in 1:5) {

  # Generate data for topology M2.
  data_m2[[e]] &lt;- simdata(graph = 'm2_ge',
                          N = 200,
                          b0 = 0,
                          ss = 1,
                          s = 1)

  # Run baycn on the data simulated for topology M2.
  baycn_m2[[e]] &lt;- mhEdge(data = data_m2[[e]],
                          adjMatrix = am_m2,
                          prior = c(0.05,
                                    0.05,
                                    0.9),
                          nCPh = 0,
                          nGV = 0,
                          pmr = FALSE,
                          iterations = 1000,
                          burnIn = 0.2,
                          thinTo = 500,
                          progress = FALSE)
}

# Expected probabilities for topology M2.
ep_m2 &lt;- matrix(c(1, 0, 0,
                  0, 0, 1,
                  0, 1, 0),
                byrow = TRUE,
                ncol = 3)

# Calculate the edgewise MSE
emse_m2 &lt;- mse(posterior = list(baycn_m2),
               expected = ep_m2,
               type = 'emse')



</code></pre>

<hr>
<h2 id='plot+2Cbaycn-method'>plot</h2><span id='topic+plot+2Cbaycn-method'></span>

<h3>Description</h3>

<p>plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'baycn'
plot(
  x,
  presence = 0.4,
  direction = 0.2,
  edgeLabel = TRUE,
  mode = "directed",
  weighted = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2Cbaycn-method_+3A_x">x</code></td>
<td>
<p>An object of class baycn.</p>
</td></tr>
<tr><td><code id="plot+2B2Cbaycn-method_+3A_presence">presence</code></td>
<td>
<p>A scalar between 0 and 1. This is the cutoff for considering
an edge to be present. For example, if presence = 0.4 then an edge is
considered to be present if the sum of the posterior proability for the two
edge directions is greater than 0.4. The edge will be considered to be absent
if this sum is less than 0.4.</p>
</td></tr>
<tr><td><code id="plot+2B2Cbaycn-method_+3A_direction">direction</code></td>
<td>
<p>A scalar between 0 and 1. This is the cutoff for determining
the direction of an edge. For example, if direction = 0.2 then an edge is
considered to be directed if the difference between the posterior proability
for the two edge directions is greater than 0.2. An edge will be considered
undirected if the difference is less than 0.2.</p>
</td></tr>
<tr><td><code id="plot+2B2Cbaycn-method_+3A_edgelabel">edgeLabel</code></td>
<td>
<p>Logical - indicates whether the posterior probabilities
should be included as edge labels in the plot. If edgeLabel is TRUE then
weighted must also be set to TRUE.</p>
</td></tr>
<tr><td><code id="plot+2B2Cbaycn-method_+3A_mode">mode</code></td>
<td>
<p>See <code><a href="igraph.html#topic+graph_from_adjacency_matrix">graph_from_adjacency_matrix</a></code> for
details.</p>
</td></tr>
<tr><td><code id="plot+2B2Cbaycn-method_+3A_weighted">weighted</code></td>
<td>
<p>See <code><a href="igraph.html#topic+graph_from_adjacency_matrix">graph_from_adjacency_matrix</a></code> for
details.</p>
</td></tr>
<tr><td><code id="plot+2B2Cbaycn-method_+3A_...">...</code></td>
<td>
<p>Other Arguments passed to plot.igraph.</p>
</td></tr>
</table>

<hr>
<h2 id='prerec'>prerec</h2><span id='topic+prerec'></span>

<h3>Description</h3>

<p>Calculates the precision and recall (i.e., power) of the inferred graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prerec(amInferred, amTrue, cutoff)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prerec_+3A_aminferred">amInferred</code></td>
<td>
<p>A baycn object or a posterior probability adjacency
matrix.</p>
</td></tr>
<tr><td><code id="prerec_+3A_amtrue">amTrue</code></td>
<td>
<p>The undirected adjacency matrix of the true graph. This will
be a symmetric matrix with 0s along the diagonal.</p>
</td></tr>
<tr><td><code id="prerec_+3A_cutoff">cutoff</code></td>
<td>
<p>A number between 0 and 1 indicating the posterior probability
threshold for considering an edge present.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list. The first element is the precision and the second element is
the recall of the inferred graph.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(5)

# Generate data from topology GN4.
data_gn4 &lt;- simdata(graph = 'gn4',
                    N = 200,
                    b0 = 0,
                    ss = 1,
                    s = 1)

# Adjacency matrix for topology GN4 - all possible edges.
am_gn4 &lt;- matrix(c(0, 1, 1, 1,
                   0, 0, 1, 1,
                   0, 0, 0, 1,
                   0, 0, 0, 0),
                 byrow = TRUE,
                 nrow = 4)

# Run baycn on the data from topology GN4.
baycn_gn4 &lt;- mhEdge(data = data_gn4,
                    adjMatrix = am_gn4,
                    prior = c(0.05,
                              0.05,
                              0.9),
                    nCPh = 0,
                    nGV = 0,
                    pmr = FALSE,
                    iterations = 1000,
                    burnIn = 0.2,
                    thinTo = 500,
                    progress = FALSE)

# Adjacency matrix with the true edges for topology GN4.
am_gn4_true &lt;- matrix(c(0, 1, 1, 0,
                        1, 0, 0, 1,
                        1, 0, 0, 1,
                        0, 1, 1, 0),
                      byrow = TRUE,
                      nrow = 4)

# Calculate the precision and recall.
prerec_gn4 &lt;- prerec(amInferred = baycn_gn4,
                     amTrue = am_gn4_true,
                     cutoff = 0.4)

</code></pre>

<hr>
<h2 id='show+2Cbaycn-method'>show</h2><span id='topic+show+2Cbaycn-method'></span>

<h3>Description</h3>

<p>show
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'baycn'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2Cbaycn-method_+3A_object">object</code></td>
<td>
<p>An object of class baycn.</p>
</td></tr>
</table>

<hr>
<h2 id='simdata'>simdata</h2><span id='topic+simdata'></span>

<h3>Description</h3>

<p>A function for simulating data under various topologies for continuous and
mixed data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simdata(
  graph = "gn4",
  N = 500,
  b0 = 0,
  ss = 1,
  s = 1,
  p = 0.6,
  q = 0.45,
  ssc = 0.2,
  nConfounding = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simdata_+3A_graph">graph</code></td>
<td>
<p>A character string of the graph for which data will be
simulated. The graphs that can be chosen are m1_ge, m1_gv, m1_cp, m1_cc,
m1_iv, m2_ge, m2_gv, m2_cp, m2_cc, m2_iv, m3_gv, m3_cp, m3_cc, m3_iv, mp_ge,
mp_gv, gn4, gn5, gn8, gn11, layer, layer_cp, layer_iv, and star.
</p>
<p>The following figures show the graph for each of the topologies listed above.
The nodes with a circle around the name are normally distributed and the
nodes with a diamond around the name are distributed multinomial. The nodes
labeled with a C represent confounding variables. The Principle of Mendelian
Randomization (PMR) can be used on graphs with discrete and continuous
random variables. This introduces the constraint that the continuous random
variables cannot be parents of discrete random variables and edges between
these types of variables only have two states: absent and directed with the
discrete random variable as the parent.
</p>
<p>m1_ge - Topology M1 with three continuous random variables. In this case M1
has two other Markov equivalent graphs.
</p>
<p>m1_gv - Topology M1 with one discrete random variable U and two continuous
random variables. When using the PMR this graph does not have any other
Markov equivalent graphs.
</p>
<p>We consider three types of confounding variables (Yang et al., 2017):
</p>
<p>m1_cp - Topology M1 with n common parent confounding variables.
</p>
<p>m1_cc - Topology M1 with n common child confounding variables.
</p>
<p>m1_iv - Topology M1 with n intermediate confounding variables.
</p>
<p><img src="../help/figures/m1.png" width="75%" alt="Figure: m1.png" />

</p>
<p>m2_ge - Topology M2 with three continuous random variables. This graph is a v
structure and does not have any other Markov equivalent graphs.
</p>
<p>m2_gv - Topolog M2 with one discrete random variable U and two continuous
random variables. This graph is a v structure and does not have any other
Markov equivalent graphs.
</p>
<p>m2_cp - Topology M2 with n common parent confounding variables.
</p>
<p>m2_cc - Topology M2 with n common child confounding variables.
</p>
<p>m2_iv - Topology M2 with n intermediate confounding variables.
</p>
<p><img src="../help/figures/m2.png" width="75%" alt="Figure: m2.png" />

</p>
<p>m3_gv - Topolog M3 with one discrete random variable U and two continuous
random variables.
</p>
<p>m3_cp - Topology M3 with n common parent confounding variables.
</p>
<p>m3_cc - Topology M3 with n common child confounding variables.
</p>
<p>m3_iv - Topology M3 with n intermediate confounding variables.
</p>
<p><img src="../help/figures/m3.png" width="75%" alt="Figure: m3.png" />

</p>
<p>mp_ge - The multi-parent topology with continuous random variables. This
graph is made up of multiple v structures and has no other Markov equivalent
graphs.
</p>
<p>mp_gv - The multi-parent topology with one discrete random variable. This
graph is made up of multiple v structures and has no other Markov equivalent
graphs.
</p>
<p><img src="../help/figures/mp.png" width="55%" alt="Figure: mp.png" />

</p>
<p>gn4 - Topology GN4 is formed by combining topologies M1 and M2. The Markov
equivalence class for this topology is made up of three different graphs.
</p>
<p>gn5 - Topology GN5 has three other Markov equivalent graphs.
</p>
<p>gn8 - Topology GN8 has three overlapping cycles, two v structures, and two
other Markov equivalent graphs.
</p>
<p>gn11 - Topology GN11 has two sub-graphs separated by a v structure at node
T6.
</p>
<p><img src="../help/figures/gn.png" width="55%" alt="Figure: gn.png" />

</p>
<p>layer - The layer topology has no other Markov equivalent graphs when using
the PMR and is made up of multiple M1 topologies.
</p>
<p>layer_cp - The layer topology with 2 common parent confounding variables.
</p>
<p>layer_iv - The layer topology with 2 intermediate confounding variables.
</p>
<p><img src="../help/figures/layer.png" width="75%" alt="Figure: layer.png" />

</p>
<p>star - The star topology has no other Markov equivalent graphs when using the
PMR and is made up of multiple M1 topologies.
</p>
<p><img src="../help/figures/star.png" width="25%" alt="Figure: star.png" />
</p>
</td></tr>
<tr><td><code id="simdata_+3A_n">N</code></td>
<td>
<p>The number of observations to simulate.</p>
</td></tr>
<tr><td><code id="simdata_+3A_b0">b0</code></td>
<td>
<p>The mean of the variable if it does not have any parents. If the
variable has one or more parents it is the slope in the linear model that is
the mean of the normally distributed variables.</p>
</td></tr>
<tr><td><code id="simdata_+3A_ss">ss</code></td>
<td>
<p>The coefficient of the parent nodes (if there are any) in the
linear model that is the mean of the normally distributed variables. This
coefficient is referred to as the signal strength.</p>
</td></tr>
<tr><td><code id="simdata_+3A_s">s</code></td>
<td>
<p>The standard deviation of the normal distribution.</p>
</td></tr>
<tr><td><code id="simdata_+3A_p">p</code></td>
<td>
<p>The probability of success for a binomial random variable.</p>
</td></tr>
<tr><td><code id="simdata_+3A_q">q</code></td>
<td>
<p>The frequency of the reference allele.</p>
</td></tr>
<tr><td><code id="simdata_+3A_ssc">ssc</code></td>
<td>
<p>The signal strength of the confounding variables.</p>
</td></tr>
<tr><td><code id="simdata_+3A_nconfounding">nConfounding</code></td>
<td>
<p>The number of confounding variables to simulate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the variables across the columns and the observations
down the rows.
</p>


<h3>References</h3>

<p>Yang, F., Wang, J., The GTEx Consortium, Pierce, B. L., and
Chen, L. S. (2017).
Identifying cis-mediators for trans-eQTLs across many human tissues using
genomic mediation analysis. <em>Genome Res.</em> 27, 1859-1871.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate data under topology GN4.
data_gn4 &lt;- simdata(graph = 'gn4',
                    N = 500,
                    b0 = 1,
                    ss = 1,
                    s = 1)

# Display the first few rows of the data.
data_gn4[1:5, ]

# Generate data under topology M1 with 3 intermediate confounding variables.
data_m1_iv &lt;- simdata(graph = 'm1_iv',
                      N = 500,
                      b0 = 0,
                      ss = 1,
                      s = 1,
                      q = 0.1,
                      ssc = 0.2,
                      nConfounding = 3)

# Show the first few rows of the data.
data_m1_iv[1:5, ]

</code></pre>

<hr>
<h2 id='summary+2Cbaycn-method'>summary</h2><span id='topic+summary+2Cbaycn-method'></span>

<h3>Description</h3>

<p>summary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'baycn'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary+2B2Cbaycn-method_+3A_object">object</code></td>
<td>
<p>An object of class baycn.</p>
</td></tr>
<tr><td><code id="summary+2B2Cbaycn-method_+3A_...">...</code></td>
<td>
<p>Other Arguments passed to methods.</p>
</td></tr>
</table>

<hr>
<h2 id='tracePlot'>tracePlot</h2><span id='topic+tracePlot'></span>

<h3>Description</h3>

<p>Creates a trace plot of the log likelihood and graph decimal. The graph
decimal is a decimal number calculated from the vector of edge states for the
accepted graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tracePlot(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tracePlot_+3A_x">x</code></td>
<td>
<p>An object of class baycn.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
