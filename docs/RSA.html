<!DOCTYPE html><html><head><title>Help for package RSA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RSA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aictab'><p>Show a table of AIC model comparisons</p></a></li>
<li><a href='#caRange'><p>Range check for the CA/RRCA model</p></a></li>
<li><a href='#clRange'><p>Range check for the CL/RRCL model</p></a></li>
<li><a href='#compare'><p>Compare a full list of RSA models</p></a></li>
<li><a href='#compare2'><p>Compare two specific RSA models</p></a></li>
<li><a href='#confint.RSA'><p>Computes confidence intervals for RSA parameters, standard or bootstrapped</p></a></li>
<li><a href='#demoRSA'><p>Plots a response surface of a polynomial equation of second degree with interactive controls</p></a></li>
<li><a href='#fitted.RSA'><p>Return fitted values of a RSA model</p></a></li>
<li><a href='#getPar'><p>Retrieves several variables from an RSA object</p></a></li>
<li><a href='#modeltree'><p>Plots a flow chart with model comparisons</p></a></li>
<li><a href='#motcon'><p>Data set on motive congruence.</p></a></li>
<li><a href='#motcon2'><p>Another data set on motive congruence.</p></a></li>
<li><a href='#movieRSA'><p>Create a movie of plotRSA plots, with changing surface and/or rotation</p></a></li>
<li><a href='#plotRSA'><p>Plots a response surface of a polynomial equation of second degree</p></a></li>
<li><a href='#residuals.RSA'><p>Return residual values of a RSA model</p></a></li>
<li><a href='#RSA'><p>Performs several RSA model tests on a data set with two predictors</p></a></li>
<li><a href='#RSA.ST'><p>Surface tests</p></a></li>
<li><a href='#selfother'><p>A fake data set on self-other agreement</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Response Surface Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.10.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-01-12</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Felix Schönbrodt &lt;felix@nicebread.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Advanced response surface analysis. The main function RSA computes
    and compares several nested polynomial regression models (full second- or 
    third-order polynomial, shifted and rotated squared difference model, 
    rising ridge surfaces, basic squared difference model, asymmetric or 
    level-dependent congruence effect models). The package provides plotting 
    functions for 3d wireframe surfaces, interactive 3d plots, and contour plots. 
    Calculates many surface parameters (a1 to a5, principal axes, stationary point,
    eigenvalues) and provides standard, robust, or bootstrapped standard errors
    and confidence intervals for them.</td>
</tr>
<tr>
<td>Suggests:</td>
<td>fields, rgl, qgraph, tcltk, tkrplot, testthat, covr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.15.0), lavaan (&ge; 0.5.20), ggplot2, lattice</td>
</tr>
<tr>
<td>Imports:</td>
<td>plyr, RColorBrewer, aplpack, methods</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-12 08:06:22 UTC; felix</td>
</tr>
<tr>
<td>Author:</td>
<td>Felix Schönbrodt [cre, aut],
  Sarah Humberg [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-12 08:20:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='aictab'>Show a table of AIC model comparisons</h2><span id='topic+aictab'></span>

<h3>Description</h3>

<p>Show a table of AIC model comparisons
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aictab(
  x,
  plot = FALSE,
  bw = FALSE,
  models = names(x$models)[!names(x$models) %in% c("absdiff", "absunc")],
  digits = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aictab_+3A_x">x</code></td>
<td>
<p>An RSA object</p>
</td></tr>
<tr><td><code id="aictab_+3A_plot">plot</code></td>
<td>
<p>Should a plot of the AICc table be plotted?</p>
</td></tr>
<tr><td><code id="aictab_+3A_bw">bw</code></td>
<td>
<p>Should the plot be black &amp; white?</p>
</td></tr>
<tr><td><code id="aictab_+3A_models">models</code></td>
<td>
<p>A vector with all model names of the candidate set. Defaults to all polynomial models in the RSA object.</p>
</td></tr>
<tr><td><code id="aictab_+3A_digits">digits</code></td>
<td>
<p>The output is rounded to this number of digits. No rounding if NA (default).</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>Modnames</dt><dd><p>Model names.</p>
</dd>
<dt>K</dt><dd><p>Number of estimated parameters (including the intercept, residual variance, and, if present in the model, control variables).</p>
</dd>
<dt>LL</dt><dd><p>Model log-likelihood.</p>
</dd>
<dt>AICc</dt><dd><p>Akaike Information Criterion (corrected).</p>
</dd>
<dt>Delta_AICc</dt><dd><p>Difference in AICc between this model and the best model.</p>
</dd>
<dt>AICcWt</dt><dd><p>The Akaike weights, also termed &quot;model probabilities&quot; by Burnham and Anderson (2002). Indicates the level of support (i.e., weight of evidence) of a model being the most parsimonious among the candidate model set.</p>
</dd>
<dt>Cum.Wt</dt><dd><p>Cumulative Akaike weight. One possible strategy is to restrict interpretation to the &quot;confidence set&quot; of models, that is, discard models with a Cum.Wt &gt; .95 (see Burnham &amp; Anderson, 2002, for details and alternatives).</p>
</dd>
<dt>evidence.ratio</dt><dd><p>Likelihood ratio of this model vs. the best model.</p>
</dd>
<dt>cfi</dt><dd><p>Comparative Fit Index (CFI).</p>
</dd>
<dt>R2</dt><dd><p>Coefficient of determination (R-squared).</p>
</dd>
<dt>R2.adj</dt><dd><p>Adjusted R-squared.</p>
</dd>
<dt>R2.baseline</dt><dd><p>Only provided if the model contains control variables. Difference in R-squared as compared to the baseline model with intercept and control variables (= the model &quot;null&quot;). This R^2 increment will typically be of interest because it refers to the amount of variance explained by the two predictors X and Y (plus their squared and interaction terms) in the RSA model.</p>
</dd>
<dt>R2.baseline.p</dt><dd><p>Only provided if the model contains control variables. p-value for the F-test of the model against the baseline model.</p>
</dd>
</dl>



<h3>Note</h3>

<p>This function is similar to the function <code>aictab</code> in the <code>AICcmodavg</code> package.
</p>


<h3>References</h3>

<p>Burnham, K. P., &amp; Anderson, D. R. (2002). <em>Model selection and multimodel inference: A practical information-theoretic approach.</em> Springer Science &amp; Business Media.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(motcon)
r.m &lt;- RSA(postVA~ePow*iPow, motcon, verbose=FALSE)
aictab(r.m, plot=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='caRange'>Range check for the CA/RRCA model</h2><span id='topic+caRange'></span>

<h3>Description</h3>

<p>Identify data points behind E2 and test how many of them have outcome predictions that significantly differ from predictions for predictor combinations on E2 (that have the same level)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>caRange(
  object,
  alpha = 0.05,
  verbose = TRUE,
  model = "CA",
  alphacorrection = "none"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="caRange_+3A_object">object</code></td>
<td>
<p>An RSA object</p>
</td></tr>
<tr><td><code id="caRange_+3A_alpha">alpha</code></td>
<td>
<p>Alpha level for the one-sided confidence interval of the outcome predictions on E2</p>
</td></tr>
<tr><td><code id="caRange_+3A_verbose">verbose</code></td>
<td>
<p>Should extra information be printed?</p>
</td></tr>
<tr><td><code id="caRange_+3A_model">model</code></td>
<td>
<p>Either &quot;CA&quot; or &quot;RRCA&quot;</p>
</td></tr>
<tr><td><code id="caRange_+3A_alphacorrection">alphacorrection</code></td>
<td>
<p>Set &quot;Bonferroni&quot; to adjust the alpha level for multiple testing when testing the outcome predictions of all data points behind E2</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When testing an asymmetric congruence hypothesis with the CA or RRCA model, the <code>caRange</code> function helps to determine whether the hypothesis is supported for the whole range of realistic predictor combinations. It computes the position of the second extremum line E2 and tests how many predictor combinations are in the data which lie &quot;behind&quot; this line and, at the same time, have a significantly different outcome prediction than points on E2. 
</p>
<p>When plotting the estimated model (CA or RRCA) with <code><a href="graphics.html#topic+plot">plot</a></code>, you can plot the line E2 and the surface above this line by calling &quot;E2&quot; in the options <code>project</code> and <code>axes</code>.
</p>


<h3>References</h3>

<p>Humberg, S., Schönbrodt, F. D., Back, M. D., Nestler, S. (in preparation). <em>Cubic response surface analysis: Investigating asymmetric and level-dependent congruence effects with third-order polynomial models.</em> Manuscript submitted for publication.
</p>

<hr>
<h2 id='clRange'>Range check for the CL/RRCL model</h2><span id='topic+clRange'></span>

<h3>Description</h3>

<p>Compute the regions of significance and test their intersection with the data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clRange(object, alpha = 0.05, verbose = TRUE, model = "CL")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clRange_+3A_object">object</code></td>
<td>
<p>An RSA object</p>
</td></tr>
<tr><td><code id="clRange_+3A_alpha">alpha</code></td>
<td>
<p>Alpha level for the regions of significance of the surface's curvature</p>
</td></tr>
<tr><td><code id="clRange_+3A_verbose">verbose</code></td>
<td>
<p>Should extra information be printed?</p>
</td></tr>
<tr><td><code id="clRange_+3A_model">model</code></td>
<td>
<p>Either &quot;CL&quot; or &quot;RRCL&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When testing a level-dependent congruence hypothesis with the CL or RRCL model, the <code>clRange</code> function helps to determine whether the hypothesis is supported for the whole range of realistic predictor combinations. It computes the mean predictor levels k1 and k2 at which the curvature of the surface changes its significance status. For each of the resulting intervals, the function informs whether the curvature is significantly negative, nonsignificant, or significantly positive in the respective interval.
</p>
<p>When plotting the estimated model (CL or RRCL) with <code><a href="graphics.html#topic+plot">plot</a></code>, you can plot the lines at which the significance status of the curvature changes and the surface above these lines by calling &quot;K1&quot; and &quot;K2&quot; in the options <code>project</code> and <code>axes</code>.
</p>


<h3>References</h3>

<p>Humberg, S., Schönbrodt, F. D., Back, M. D., Nestler, S. (in preparation). <em>Cubic response surface analysis: Investigating asymmetric and level-dependent congruence effects with third-order polynomial models.</em> Manuscript submitted for publication.
</p>

<hr>
<h2 id='compare'>Compare a full list of RSA models</h2><span id='topic+compare'></span>

<h3>Description</h3>

<p>Compare several fit indexes of all models computed from the RSA function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare(x, verbose = TRUE, plot = FALSE, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_+3A_x">x</code></td>
<td>
<p>An RSA object</p>
</td></tr>
<tr><td><code id="compare_+3A_verbose">verbose</code></td>
<td>
<p>Should the summary be printed?</p>
</td></tr>
<tr><td><code id="compare_+3A_plot">plot</code></td>
<td>
<p>Should the comparison be plotted (using the <code><a href="#topic+modeltree">modeltree</a></code> function)?</p>
</td></tr>
<tr><td><code id="compare_+3A_digits">digits</code></td>
<td>
<p>Digits of the output</p>
</td></tr>
<tr><td><code id="compare_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to the <code><a href="#topic+modeltree">modeltree</a></code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No details so far.
</p>

<hr>
<h2 id='compare2'>Compare two specific RSA models</h2><span id='topic+compare2'></span>

<h3>Description</h3>

<p>Compare several fit indexes of two models computed from the RSA function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare2(x, m1 = "", m2 = "full", digits = 3, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare2_+3A_x">x</code></td>
<td>
<p>An RSA object</p>
</td></tr>
<tr><td><code id="compare2_+3A_m1">m1</code></td>
<td>
<p>Name of first model</p>
</td></tr>
<tr><td><code id="compare2_+3A_m2">m2</code></td>
<td>
<p>Name of second model</p>
</td></tr>
<tr><td><code id="compare2_+3A_digits">digits</code></td>
<td>
<p>Digits of the output</p>
</td></tr>
<tr><td><code id="compare2_+3A_verbose">verbose</code></td>
<td>
<p>Should the summary be printed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You must take care yourself that the compared models are nested! There is no automatic check, so you could, in principle, compare non-nested models. This is valid for AIC, BIC, CFI, and R2 indices, but *not* for the chi2-LR test!
</p>

<hr>
<h2 id='confint.RSA'>Computes confidence intervals for RSA parameters, standard or bootstrapped</h2><span id='topic+confint.RSA'></span><span id='topic+confint'></span>

<h3>Description</h3>

<p>Computes confidence intervals for RSA parameters, standard or bootstrapped (using a percentile bootstrap)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'RSA'
confint(
  object,
  parm,
  level = 0.95,
  ...,
  model = "full",
  digits = 3,
  method = "standard",
  R = 5000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.RSA_+3A_object">object</code></td>
<td>
<p>An RSA object</p>
</td></tr>
<tr><td><code id="confint.RSA_+3A_parm">parm</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="confint.RSA_+3A_level">level</code></td>
<td>
<p>The confidence level required.</p>
</td></tr>
<tr><td><code id="confint.RSA_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to the bootstrapLavaan function, e.g., <code>parallel="multicore", ncpus=2</code>.</p>
</td></tr>
<tr><td><code id="confint.RSA_+3A_model">model</code></td>
<td>
<p>A string specifying the model; defaults to &quot;full&quot;</p>
</td></tr>
<tr><td><code id="confint.RSA_+3A_digits">digits</code></td>
<td>
<p>Number of digits the output is rounded to; if NA, digits are unconstrained</p>
</td></tr>
<tr><td><code id="confint.RSA_+3A_method">method</code></td>
<td>
<p>&quot;standard&quot; returns the CI for the lavaan object as it was computed. &quot;boot&quot; computes new percentile bootstrapped CIs.</p>
</td></tr>
<tr><td><code id="confint.RSA_+3A_r">R</code></td>
<td>
<p>If <code>method = "boot"</code>, R specifies the number of bootstrap samples</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two ways of getting bootstrapped CIs and p-values in the RSA package If you use the option <code>se="boot"</code> in the <code><a href="#topic+RSA">RSA</a></code> function, <code>lavaan</code> provides CIs and p-values based on the bootstrapped standard error (<em>not</em> percentile bootstraps). If you use <code>confint(..., method="boot")</code>, in contrast, you get CIs and p-values based on percentile bootstrap.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RSA">RSA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
set.seed(0xBEEF)
n &lt;- 300
err &lt;- 2
x &lt;- rnorm(n, 0, 5)
y &lt;- rnorm(n, 0, 5)
df &lt;- data.frame(x, y)
df &lt;- within(df, {
	diff &lt;- x-y
	absdiff &lt;- abs(x-y)
	SD &lt;- (x-y)^2
	z.sq &lt;- SD + rnorm(n, 0, err)
})

r1 &lt;- RSA(z.sq~x*y, df, models="SSQD")
(c1 &lt;- confint(r1, model="SSQD"))

# Dummy example with 10 bootstrap replications - better use &gt;= 5000!
(c2 &lt;- confint(r1, model="SSQD", method="boot", R=10))
# multicore version
confint(r1, model="SSQD", R=5000, parallel="multicore", ncpus=2)

## End(Not run)
</code></pre>

<hr>
<h2 id='demoRSA'>Plots a response surface of a polynomial equation of second degree with interactive controls</h2><span id='topic+demoRSA'></span><span id='topic+demoSRR'></span><span id='topic+demoSRRR'></span>

<h3>Description</h3>

<p>Plots an RSA object, or a response surface with specified parameters, with interactive controls for coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>demoRSA(
  x = NULL,
  y = 0,
  x2 = 0,
  y2 = 0,
  xy = 0,
  w = 0,
  wx = 0,
  wy = 0,
  x3 = 0,
  xy2 = 0,
  x2y = 0,
  y3 = 0,
  b0 = 0,
  type = "3d",
  zlim = c(-2, 2),
  xlim = c(-2, 2),
  ylim = c(-2, 2),
  xlab = NULL,
  ylab = NULL,
  zlab = NULL,
  points = TRUE,
  model = "full",
  project = c("PA1", "PA2"),
  extended = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="demoRSA_+3A_x">x</code></td>
<td>
<p>Either an RSA object (returned by the <code>RSA</code> function), or the coefficient for the X predictor</p>
</td></tr>
<tr><td><code id="demoRSA_+3A_y">y</code></td>
<td>
<p>Y coefficient</p>
</td></tr>
<tr><td><code id="demoRSA_+3A_x2">x2</code></td>
<td>
<p>X^2 coefficient</p>
</td></tr>
<tr><td><code id="demoRSA_+3A_y2">y2</code></td>
<td>
<p>Y^2 coefficient</p>
</td></tr>
<tr><td><code id="demoRSA_+3A_xy">xy</code></td>
<td>
<p>XY interaction coefficient</p>
</td></tr>
<tr><td><code id="demoRSA_+3A_w">w</code></td>
<td>
<p>W coefficient (for (un)constrained absolute difference model)</p>
</td></tr>
<tr><td><code id="demoRSA_+3A_wx">wx</code></td>
<td>
<p>WX coefficient (for (un)constrained absolute difference model)</p>
</td></tr>
<tr><td><code id="demoRSA_+3A_wy">wy</code></td>
<td>
<p>WY coefficient (for (un)constrained absolute difference model)</p>
</td></tr>
<tr><td><code id="demoRSA_+3A_x3">x3</code></td>
<td>
<p>X^3 coefficient</p>
</td></tr>
<tr><td><code id="demoRSA_+3A_xy2">xy2</code></td>
<td>
<p>XY^2 coefficient</p>
</td></tr>
<tr><td><code id="demoRSA_+3A_x2y">x2y</code></td>
<td>
<p>X^2Y coefficient</p>
</td></tr>
<tr><td><code id="demoRSA_+3A_y3">y3</code></td>
<td>
<p>Y^3 coefficient</p>
</td></tr>
<tr><td><code id="demoRSA_+3A_b0">b0</code></td>
<td>
<p>Intercept</p>
</td></tr>
<tr><td><code id="demoRSA_+3A_type">type</code></td>
<td>
<p><code>3d</code> for 3d surface plot, <code>contour</code> for 2d contour plot. Shortcuts (i.e., first letter of string) are sufficient; be careful: &quot;contour&quot; is very slow at the moment</p>
</td></tr>
<tr><td><code id="demoRSA_+3A_zlim">zlim</code></td>
<td>
<p>Limits of the z axis</p>
</td></tr>
<tr><td><code id="demoRSA_+3A_xlim">xlim</code></td>
<td>
<p>Limits of the x axis</p>
</td></tr>
<tr><td><code id="demoRSA_+3A_ylim">ylim</code></td>
<td>
<p>Limits of the y axis</p>
</td></tr>
<tr><td><code id="demoRSA_+3A_xlab">xlab</code></td>
<td>
<p>Label of the x axis</p>
</td></tr>
<tr><td><code id="demoRSA_+3A_ylab">ylab</code></td>
<td>
<p>Label of the y axis</p>
</td></tr>
<tr><td><code id="demoRSA_+3A_zlab">zlab</code></td>
<td>
<p>Label of the z axis</p>
</td></tr>
<tr><td><code id="demoRSA_+3A_points">points</code></td>
<td>
<p>A list of parameters which define the appearance of the raw scatter points: show = TRUE: Should the original data points be overplotted? value=&quot;raw&quot;: Plot the original z value, &quot;predicted&quot;: plot the predicted z value. jitter=0: Amount of jitter for the raw data points. cex = .5: multiplication factor for point size. See ?plotRSA for details.</p>
</td></tr>
<tr><td><code id="demoRSA_+3A_model">model</code></td>
<td>
<p>If x is an RSA object: from which model should the response surface be computed?</p>
</td></tr>
<tr><td><code id="demoRSA_+3A_project">project</code></td>
<td>
<p>Which features should be projected on the floor? See ?plotRSA for details.</p>
</td></tr>
<tr><td><code id="demoRSA_+3A_extended">extended</code></td>
<td>
<p>Show additional controls (not implemented yet)</p>
</td></tr>
<tr><td><code id="demoRSA_+3A_...">...</code></td>
<td>
<p>Other parameters passed through to plot.RSA (e.g., xlab, ylab, zlab, cex, legend)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No details so far. Just play around with the interface!
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotRSA">plotRSA</a></code>, <code><a href="#topic+RSA">RSA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plot response surfaces from known parameters
# example of Edwards (2002), Figure 3
## Not run: 
demoRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628, type="3d")
demoRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628, legend=FALSE, type="c")

## End(Not run)

# Plot response surface from an RSA object
## Not run: 
set.seed(0xBEEF)
n &lt;- 300
err &lt;- 2
x &lt;- rnorm(n, 0, 5)
y &lt;- rnorm(n, 0, 5)
df &lt;- data.frame(x, y)
df &lt;- within(df, {
	diff &lt;- x-y
	absdiff &lt;- abs(x-y)
	SD &lt;- (x-y)^2
	z.diff &lt;- diff + rnorm(n, 0, err)
	z.abs &lt;- absdiff + rnorm(n, 0, err)
	z.sq &lt;- SD + rnorm(n, 0, err)
	z.add &lt;- diff + 0.4*x + rnorm(n, 0, err)
	z.complex &lt;- 0.4*x + - 0.2*x*y + + 0.1*x^2 - 0.03*y^2 + rnorm(n, 0, err)
})

r1 &lt;- RSA(z.sq~x*y, df)
demoRSA(r1)
demoRSA(r1, points=TRUE, model="SQD")

## End(Not run)
</code></pre>

<hr>
<h2 id='fitted.RSA'>Return fitted values of a RSA model</h2><span id='topic+fitted.RSA'></span>

<h3>Description</h3>

<p>Return fitted values of a RSA model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'RSA'
fitted(object, ..., model = "full")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.RSA_+3A_object">object</code></td>
<td>
<p>An RSA object.</p>
</td></tr>
<tr><td><code id="fitted.RSA_+3A_...">...</code></td>
<td>
<p>Other parameters (currently not used)</p>
</td></tr>
<tr><td><code id="fitted.RSA_+3A_model">model</code></td>
<td>
<p>Model on which the fitted values are based</p>
</td></tr>
</table>

<hr>
<h2 id='getPar'>Retrieves several variables from an RSA object</h2><span id='topic+getPar'></span>

<h3>Description</h3>

<p>Retrieves several variables from an RSA object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPar(x, type = "coef", model = "full", digits = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getPar_+3A_x">x</code></td>
<td>
<p>RSA object</p>
</td></tr>
<tr><td><code id="getPar_+3A_type">type</code></td>
<td>
<p>One of: &quot;syntax&quot;, &quot;coef&quot;, &quot;R2&quot;, &quot;R2.adj&quot;, &quot;free&quot;, &quot;summary&quot;, &quot;p.value&quot;</p>
</td></tr>
<tr><td><code id="getPar_+3A_model">model</code></td>
<td>
<p>A string specifying the model; defaults to &quot;full&quot;</p>
</td></tr>
<tr><td><code id="getPar_+3A_digits">digits</code></td>
<td>
<p>Number of digits the output is rounded to; if NA, digits are unconstrained</p>
</td></tr>
<tr><td><code id="getPar_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to the extraction function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>None so far.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RSA">RSA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(0xBEEF)
n &lt;- 300
err &lt;- 2
x &lt;- rnorm(n, 0, 5)
y &lt;- rnorm(n, 0, 5)
df &lt;- data.frame(x, y)
df &lt;- within(df, {
	diff &lt;- x-y
	absdiff &lt;- abs(x-y)
	SD &lt;- (x-y)^2
	z.sq &lt;- SD + rnorm(n, 0, err)
})

r1 &lt;- RSA(z.sq~x*y, df, models=c("full", "SSQD"))
getPar(r1, "syntax")
getPar(r1, "R2")
getPar(r1, "coef")
</code></pre>

<hr>
<h2 id='modeltree'>Plots a flow chart with model comparisons</h2><span id='topic+modeltree'></span>

<h3>Description</h3>

<p>Plots a flow chart with model comparisons from a RSA object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modeltree(x, digits = 3, sig = 0.05, borderline = 0.1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modeltree_+3A_x">x</code></td>
<td>
<p>A cRSA object (= output from the <code><a href="#topic+compare">compare</a></code> function)</p>
</td></tr>
<tr><td><code id="modeltree_+3A_digits">digits</code></td>
<td>
<p>The number of digits to which numbers are rounded</p>
</td></tr>
<tr><td><code id="modeltree_+3A_sig">sig</code></td>
<td>
<p>Threshold for models to be marked as &quot;not significant&quot;</p>
</td></tr>
<tr><td><code id="modeltree_+3A_borderline">borderline</code></td>
<td>
<p>Threshold for models to be marked as &quot;borderline significant&quot; (used for color of arrows)</p>
</td></tr>
<tr><td><code id="modeltree_+3A_...">...</code></td>
<td>
<p>Additional parameters (not used yet)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plot can be either requested within the <code>compare</code> function:
<code>compare(r1, plot=TRUE)</code>
Or it can be plotted from a cRSA object (= output from the <code><a href="#topic+compare">compare</a></code> function):
<code>c1 &lt;- compare(r1)</code>
<code>plot(c1)</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RSA">RSA</a></code>, <code><a href="#topic+compare">compare</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(motcon)
r.m &lt;- RSA(postVA~ePow*iPow, motcon)
c1 &lt;- compare(r.m)
modeltree(c1)

## End(Not run)
</code></pre>

<hr>
<h2 id='motcon'>Data set on motive congruence.</h2><span id='topic+motcon'></span>

<h3>Description</h3>

<p>A dataset containing the explicit power motive, implicit power motive and self ratings of affective valence during a spontaneous speech.
The variables are as follows:
</p>


<h3>Format</h3>

<p>A data frame with 84 rows and 3 variables
</p>


<h3>Details</h3>


<ul>
<li><p> ePow Explicit power motive, measured with a questionnaire (Unified Motive Scales, Schönbrodt &amp; Gerstenberg, 2012). Raw values have been z standardized.
</p>
</li>
<li><p> iPow Implicit power motive, measure with picture story exercise (6 pictures). Raw motive scores have been controlled for word count and z standardized
</p>
</li>
<li><p> postVA z standardized valence rating after the speech (&lsquo;How did you feel during the speech&rsquo;). Consists of two bipolar items from the PANAVA questionnaire (Schallberger, 2005): &lsquo;zufrieden ... unzufrieden&rsquo; (satisfied ... unsatisfied) and &lsquo;ungluecklich ... gluecklich&rsquo; (unhappy ... happy).
</p>
</li></ul>



<h3>References</h3>

<p>Schallberger, U. (2005). <em>Kurzskala zur Erfassung der Positiven Aktivierung, Negativen Aktivierung und Valenz in Experience Sampling Studien (PANAVA-KS) [Short scales for the assessment of positive affect, negative affect, and valence in experience sampling studies]</em>. University of Zurich.
</p>
<p>Schönbrodt, F. D., &amp; Gerstenberg, F. X. R. (2012). An IRT analysis of motive questionnaires: The Unified Motive Scales. <em>Journal of Research in Personality, 46</em>, 725-742. doi:10.1016/j.jrp.2012.08.010
</p>

<hr>
<h2 id='motcon2'>Another data set on motive congruence.</h2><span id='topic+motcon2'></span>

<h3>Description</h3>

<p>A dataset containing the explicit intimacy motive, implicit affiliation/intimacy motive and self ratings of affective valence.
The variables are as follows:
</p>


<h3>Format</h3>

<p>A data frame with 362 rows and 3 variables
</p>


<h3>Details</h3>


<ul>
<li><p> EM Explicit intimacy motive, measured with a questionnaire (Unified Motive Scales, Schönbrodt &amp; Gerstenberg, 2012). Raw values have been z standardized.
</p>
</li>
<li><p> IM Implicit affiliation/intimacy motive, measured with picture story exercise (6 pictures). Raw motive scores have been controlled for word count and z standardized.
</p>
</li>
<li><p> VA z standardized valence rating. Consists of two bipolar items from the PANAVA questionnaire (Schallberger, 2005): &lsquo;zufrieden ... unzufrieden&rsquo; (satisfied ... unsatisfied) and &lsquo;ungluecklich ... gluecklich&rsquo; (unhappy ... happy).
</p>
</li></ul>



<h3>References</h3>

<p>Schallberger, U. (2005). <em>Kurzskala zur Erfassung der Positiven Aktivierung, Negativen Aktivierung und Valenz in Experience Sampling Studien (PANAVA-KS) [Short scales for the assessment of positive affect, negative affect, and valence in experience sampling studies]</em>. University of Zurich.
</p>
<p>Schönbrodt, F. D., &amp; Gerstenberg, F. X. R. (2012). An IRT analysis of motive questionnaires: The Unified Motive Scales. <em>Journal of Research in Personality, 46</em>, 725-742. doi:10.1016/j.jrp.2012.08.010
</p>

<hr>
<h2 id='movieRSA'>Create a movie of plotRSA plots, with changing surface and/or rotation</h2><span id='topic+movieRSA'></span>

<h3>Description</h3>

<p>Create a movie of plotRSA plots, with changing surface and/or rotation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>movieRSA(
  name,
  frames,
  dur = 2000,
  fps = 30,
  width = 800,
  height = 600,
  mirror = TRUE,
  savetodisk = TRUE,
  clean = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="movieRSA_+3A_name">name</code></td>
<td>
<p>Name for the subfolder containing all still pictures, and for the final movie file.</p>
</td></tr>
<tr><td><code id="movieRSA_+3A_frames">frames</code></td>
<td>
<p>A list of lists: Each list contains parameters which are passed to the plotRSA function. See <code><a href="#topic+plotRSA">plotRSA</a></code> for details.</p>
</td></tr>
<tr><td><code id="movieRSA_+3A_dur">dur</code></td>
<td>
<p>Duration of the movie in milliseconds</p>
</td></tr>
<tr><td><code id="movieRSA_+3A_fps">fps</code></td>
<td>
<p>Frame per second (defaults to 30)</p>
</td></tr>
<tr><td><code id="movieRSA_+3A_width">width</code></td>
<td>
<p>Width of the final movie in pixels</p>
</td></tr>
<tr><td><code id="movieRSA_+3A_height">height</code></td>
<td>
<p>Height of the final movie in pixels</p>
</td></tr>
<tr><td><code id="movieRSA_+3A_mirror">mirror</code></td>
<td>
<p>If <code>TRUE</code>, the frame sequence is mirrored at the end so that the movie ends at frame 1.</p>
</td></tr>
<tr><td><code id="movieRSA_+3A_savetodisk">savetodisk</code></td>
<td>
<p>If <code>TRUE</code> the files are saved to the disk. If <code>FALSE</code>, the movie is only shown on the screen</p>
</td></tr>
<tr><td><code id="movieRSA_+3A_clean">clean</code></td>
<td>
<p>Should the still images be deleted?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>frames</code> is a list of the first, intermediate, and the final parameters of the surface. Each scalar parameter defined in <code>frames</code> is interpolated between steps in order to create a smooth sequence of plots. Logical and character parameters are inherited from the first frame. Plots are saved as individual still pictures in a subfolder called <code>name</code> and finally glued together using ffmpeg. Hence, a ffmpeg installation is needed to create the movie (the still pictures can be produced without ffmpeg).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotRSA">plotRSA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
movieRSA(name="SD0",
		frames &lt;- list(
	 	step1 = list(b0=0, xy=-.40, x2=.20, y2=.20, 
			rotation=list(x=-63, y=32, z=15),
			legend=FALSE, zlim=c(0, 4), param=FALSE),
	 	step2 = list(b0=0, xy=-.10, x2=.05, y2=.05, 
			rotation=list(x=-54, y=39, z=25)),
		step3 = list(b0=0, xy=-.40, x2=.20, y2=.20, 
			rotation=list(x=-45, y=45, z=35))
	 ),
	 mirror=TRUE, fps=30, dur=5000)

## End(Not run)
</code></pre>

<hr>
<h2 id='plotRSA'>Plots a response surface of a polynomial equation of second degree</h2><span id='topic+plotRSA'></span>

<h3>Description</h3>

<p>Plots an RSA object, or a response surface with specified parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotRSA(
  x = 0,
  y = 0,
  x2 = 0,
  y2 = 0,
  xy = 0,
  w = 0,
  wx = 0,
  wy = 0,
  x3 = 0,
  xy2 = 0,
  x2y = 0,
  y3 = 0,
  b0 = 0,
  type = "3d",
  model = "full",
  xlim = NULL,
  ylim = NULL,
  zlim = NULL,
  xlab = NULL,
  ylab = NULL,
  zlab = NULL,
  main = "",
  surface = "predict",
  lambda = NULL,
  suppress.surface = FALSE,
  suppress.box = FALSE,
  suppress.grid = FALSE,
  suppress.ticklabels = FALSE,
  rotation = list(x = -63, y = 32, z = 15),
  label.rotation = list(x = 19, y = -40, z = 92),
  gridsize = 21,
  bw = FALSE,
  legend = TRUE,
  param = TRUE,
  coefs = FALSE,
  axes = c("LOC", "LOIC", "PA1", "PA2"),
  axesStyles = list(LOC = list(lty = "solid", lwd = 2, col = ifelse(bw == TRUE, "black",
    "blue")), LOIC = list(lty = "solid", lwd = 2, col = ifelse(bw == TRUE, "black",
    "blue")), PA1 = list(lty = "dotted", lwd = 2, col = ifelse(bw == TRUE, "black",
    "gray30")), PA2 = list(lty = "dotted", lwd = 2, col = ifelse(bw == TRUE, "black",
    "gray30"))),
  project = c("contour"),
  maxlines = FALSE,
  cex.tickLabel = 1,
  cex.axesLabel = 1,
  cex.main = 1,
  points = list(data = NULL, show = NA, value = "raw", jitter = 0, color = "black", cex =
    0.5, stilt = NULL, out.mark = FALSE, fill = NULL),
  fit = NULL,
  link = "identity",
  tck = c(1.5, 1.5, 1.5),
  distance = c(1.3, 1.3, 1.4),
  border = FALSE,
  contour = list(show = FALSE, color = "grey40", highlight = c()),
  hull = NA,
  showSP = FALSE,
  showSP.CI = FALSE,
  pal = NULL,
  pal.range = "box",
  pad = 0,
  claxes.alpha = 0.05,
  demo = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotRSA_+3A_x">x</code></td>
<td>
<p>Either an RSA object (returned by the <code>RSA</code> function), or the coefficient for the X predictor</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_y">y</code></td>
<td>
<p>Y coefficient</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_x2">x2</code></td>
<td>
<p>X^2 coefficient</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_y2">y2</code></td>
<td>
<p>Y^2 coefficient</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_xy">xy</code></td>
<td>
<p>XY interaction coefficient</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_w">w</code></td>
<td>
<p>W coefficient (for (un)constrained absolute difference model)</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_wx">wx</code></td>
<td>
<p>WX coefficient (for (un)constrained absolute difference model)</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_wy">wy</code></td>
<td>
<p>WY coefficient (for (un)constrained absolute difference model)</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_x3">x3</code></td>
<td>
<p>X^3 coefficient</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_xy2">xy2</code></td>
<td>
<p>XY^2 coefficient</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_x2y">x2y</code></td>
<td>
<p>X^2Y coefficient</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_y3">y3</code></td>
<td>
<p>Y^3 coefficient</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_b0">b0</code></td>
<td>
<p>Intercept</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_type">type</code></td>
<td>
<p><code>3d</code> for 3d surface plot, <code>contour</code> for 2d contour plot, &quot;interactive&quot; for interactive rotatable plot. Shortcuts (i.e., first letter of string) are sufficient</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_model">model</code></td>
<td>
<p>If x is an RSA object: from which model should the response surface be computed?</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_xlim">xlim</code></td>
<td>
<p>Limits of the x axis</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_ylim">ylim</code></td>
<td>
<p>Limits of the y axis</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_zlim">zlim</code></td>
<td>
<p>Limits of the z axis</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_xlab">xlab</code></td>
<td>
<p>Label for x axis</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_ylab">ylab</code></td>
<td>
<p>Label for y axis</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_zlab">zlab</code></td>
<td>
<p>Label for z axis</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_main">main</code></td>
<td>
<p>the main title of the plot</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_surface">surface</code></td>
<td>
<p>Method for the calculation of the surface z values. &quot;predict&quot; takes the predicted values from the model, &quot;smooth&quot; uses a thin plate smoother (function <code>Tps</code> from the <code>fields</code> package) of the raw data</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_lambda">lambda</code></td>
<td>
<p>lambda parameter for the smoother. Default (NULL) means that it is estimated by the smoother function. Small lambdas around 1 lead to rugged surfaces, big lambdas to very smooth surfaces.</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_suppress.surface">suppress.surface</code></td>
<td>
<p>Should the surface be suppressed (only for <code>type="3d"</code>)? Useful for only showing the data points, or for didactic purposes (e.g., first show the cube, then fade in the surface).</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_suppress.box">suppress.box</code></td>
<td>
<p>Should the surrounding box be suppressed (only for <code>type="3d"</code>)?</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_suppress.grid">suppress.grid</code></td>
<td>
<p>Should the grid lines be suppressed (only for <code>type="3d"</code>)?</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_suppress.ticklabels">suppress.ticklabels</code></td>
<td>
<p>Should the numbers on the axes be suppressed (only for <code>type="3d"</code>)?</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_rotation">rotation</code></td>
<td>
<p>Rotation of the 3d surface plot (when type == &quot;3d&quot;)</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_label.rotation">label.rotation</code></td>
<td>
<p>Rotation of the axis labls (when type == &quot;3d&quot;)</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_gridsize">gridsize</code></td>
<td>
<p>Number of grid nodes in each dimension</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_bw">bw</code></td>
<td>
<p>Print surface in black and white instead of colors?</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_legend">legend</code></td>
<td>
<p>Print color legend for z values?</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_param">param</code></td>
<td>
<p>Should the surface parameters a1 to a5 be shown on the plot? In case of a 3d plot a1 to a5 are printed on top of the plot; in case of a contour plot the principal axes are plotted. Surface parameters are not printed for cubic surfaces.</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_coefs">coefs</code></td>
<td>
<p>Should the regression coefficients b1 to b5 (b1 to b9 for cubic models) be shown on the plot? (Only for 3d plot)</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_axes">axes</code></td>
<td>
<p>A vector of strings specifying the axes that should be plotted. Can be any combination of c(&quot;LOC&quot;, &quot;LOIC&quot;, &quot;PA1&quot;, &quot;PA2&quot;, &quot;E2&quot;, &quot;K1&quot;, &quot;K2&quot;). LOC = line of congruence, LOIC = line of incongruence, PA1 = first principal axis, PA2 = second principal axis, E2 = second extremum line in the CA or RRCA model, K1, K2 = boundary lines of the regions of significance in the CL or RRCL model.</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_axesstyles">axesStyles</code></td>
<td>
<p>Define the visual styles of the axes LOC, LOIC, PA1, PA2, E2, K1, and K2. Provide a named list: <code>axesStyles=list(LOC = list(lty="solid",  lwd=2, col=ifelse(bw==TRUE, "black", "blue"))</code>. It recognizes three parameters: <code>lty</code>, <code>lwd</code>, and <code>col</code>. If you define a style for an axis, you have to provide all three parameters, otherwise a warning will be shown.</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_project">project</code></td>
<td>
<p>A vector of graphic elements that should be projected on the floor of the cube. Can include any combination of c(&quot;LOC&quot;, &quot;LOIC&quot;, &quot;PA1&quot;, &quot;PA2&quot;, &quot;contour&quot;, &quot;points&quot;, &quot;E2&quot;, &quot;K1&quot;, &quot;K2&quot;). Note that projected elements are plotted in the order given in the vector (first elements are plotted first and overplotted by later elements).</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_maxlines">maxlines</code></td>
<td>
<p>Should the maximum lines be plotted? (red: maximum X for a given Y, blue: maximum Y for a given X). Works only in type=&quot;3d&quot;</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_cex.ticklabel">cex.tickLabel</code></td>
<td>
<p>Font size factor for tick labels</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_cex.axeslabel">cex.axesLabel</code></td>
<td>
<p>Font size factor for axes labels</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_cex.main">cex.main</code></td>
<td>
<p>Factor for main title size</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_points">points</code></td>
<td>
<p>A list of parameters which define the appearance of the raw scatter points: 
</p>

<ul>
<li><p> data: Data frame which contains the coordinates of the raw data points. First column = x, second = y, third = z. This data frame is automatically generated when the plot is based on a fitted RSA-object
</p>
</li>
<li><p> show = TRUE: Should the original data points be overplotted?
</p>
</li>
<li><p> color = &quot;black&quot;: Color of the points. Either a single value for all points, or a vector with the same size as data points provided. If parameter <code>fill</code> is also defined, <code>color</code> refers to the border of the points.
</p>
</li>
<li><p> fill = NULL: Fill of the points. Either a single value for all points, or a vector with the same size as data points provided. As a default, this is set to NULL, which means that all points simply have the color <code>color</code>.
</p>
</li>
<li><p> value=&quot;raw&quot;: Plot the original z value, &quot;predicted&quot;: plot the predicted z value
</p>
</li>
<li><p> jitter = 0: Amount of jitter for the raw data points. For z values, a value of 0.005 is reasonable
</p>
</li>
<li><p> cex = .5: multiplication factor for point size. Either a single value for all points, or a vector with the same size as data points provided.
</p>
</li>
<li><p> stilt: Should stilts be drawn for selected data points (i.e., lines from raw data points to the floor)? A logical vector with the same size as data points provided, indicating which points should get a stilt.
</p>
</li>
<li><p> out.mark = FALSE: If set to TRUE, outliers according to Bollen &amp; Jackman (1980) are printed as red X symbols, but only when they have been removed in the RSA function: <code>RSA(..., out.rm=TRUE)</code>.
</p>

<ul>
<li><p> If out.rm == TRUE (in RSA()) and out.mark == FALSE (in plotRSA()), the outlier is removed from the model and *not plotted* in plotRSA.
</p>
</li>
<li><p> If out.rm == TRUE (in RSA()) and out.mark == TRUE (in plotRSA()), the outlier is removed from the model but plotted and marked in plotRSA.
</p>
</li>
<li><p> If out.rm == FALSE (in RSA()): Outliers are not removed and cannot be plotted.
</p>
</li>
<li><p> Example syntax: <code>plotRSA(r1, points=list(show=TRUE, out.mark=TRUE))</code>
</p>
</li></ul>

</li></ul>

<p>As a shortcut, you can also set <code>points=TRUE</code> to set the defaults.</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_fit">fit</code></td>
<td>
<p>Do not change that parameter (internal use only)</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_link">link</code></td>
<td>
<p>Link function to transform the z axes. Implemented are &quot;identity&quot; (no transformation; default), &quot;probit&quot;, and &quot;logit&quot;</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_tck">tck</code></td>
<td>
<p>A vector of three values defining the position of labels to the axes (see ?wireframe)</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_distance">distance</code></td>
<td>
<p>A vector of three values defining the distance of labels to the axes</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_border">border</code></td>
<td>
<p>Should a thicker border around the surface be plotted? Sometimes this border leaves the surrounding box, which does not look good. In this case the border can be suppressed by setting <code>border=FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_contour">contour</code></td>
<td>
<p>A list defining the appearance of contour lines (aka. height lines). show=TRUE: Should the contour lines be plotted on the 3d wireframe plot? (Parameter only relevant for <code>type="3d"</code>). color = &quot;grey40&quot;: Color of the contour lines. highlight = c(): A vector of heights which should be highlighted (i.e., printed in bold). Be careful: the highlighted line is not necessarily exactly at the specified height; instead the nearest height line is selected.</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_hull">hull</code></td>
<td>
<p>Plot a bag plot on the surface (This is a bivariate extension of the boxplot. 50% of points are in the inner bag, 50% in the outer region). See Rousseeuw, Ruts, &amp; Tukey (1999).</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_showsp">showSP</code></td>
<td>
<p>Plot the stationary point? (only relevant for <code>type="contour"</code>)</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_showsp.ci">showSP.CI</code></td>
<td>
<p>Plot the CI of the stationary point? (only relevant for <code>type="contour"</code>)</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_pal">pal</code></td>
<td>
<p>A palette for shading. You can use <code><a href="grDevices.html#topic+colorRampPalette">colorRampPalette</a></code> to construct a color ramp, e.g. <code>plot(r.m, pal=colorRampPalette(c("darkgreen", "yellow", "darkred"))(20))</code>. If <code>pal="flip"</code>, the default palette is used, but reversed (so that red is on top and green on the bottom).</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_pal.range">pal.range</code></td>
<td>
<p>Should the color range be scaled to the box (<code>pal.range = "box"</code>, default), or to the min and max of the surface (<code>pal.range = "surface"</code>)? If set to &quot;box&quot;, different surface plots can be compared along their color, as long as the zlim is the same for both.</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_pad">pad</code></td>
<td>
<p>Pad controls the margin around the figure (positive numbers: larger margin, negative numbers: smaller margin)</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_claxes.alpha">claxes.alpha</code></td>
<td>
<p>Alpha level that is used to determine the axes K1 and K2 that demarcate the regions of significance for the cubic models &quot;CL&quot; and &quot;RRCL&quot;</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_demo">demo</code></td>
<td>
<p>Do not change that parameter (internal use only)</p>
</td></tr>
<tr><td><code id="plotRSA_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to the plotting function (e.g., sub=&quot;Title&quot;). A useful title might be the R squared of the plotted model: <code>sub = as.expression(bquote(R^2==.(round(getPar(x, "r2", model="full"), 3))))</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each plot type has its distinctive advantages. The two-dimensional contour plot gives a clear view of the position of the principal axes and the stationary point. The 3d plot gives a three dimensional impression of the surface, allows overplotting of the original data points (in case an RSA object is provided), and allows the interactive adjustment of regression weights in the <code><a href="#topic+RSA">RSA</a></code> function. The interactive plot allows rotating and exploring a three-dimensional surface with the mouse (nice for demonstration purposes).
If you want to export publication-ready plots, it is recommended to export it with following commands:
<code>p1 &lt;- plot(r1, bw=TRUE)
trellis.device(device="cairo_pdf", filename="RSA_plot.pdf")
print(p1)
dev.off()</code>
</p>


<h3>References</h3>

<p>Rousseeuw, P. J., Ruts, I., &amp; Tukey, J. W. (1999). The Bagplot: A Bivariate Boxplot. The American Statistician, 53(4), 382-387. doi:10.1080/00031305.1999.10474494
</p>


<h3>See Also</h3>

<p><code><a href="#topic+demoRSA">demoRSA</a></code>, <code><a href="#topic+RSA">RSA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plot response surfaces from known parameters
# example of Edwards (2002), Figure 3
## Not run: 
# Default: 3d plot:
plotRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628)
# Contour plot:
plotRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628, type="c")
# Interactive plot (try the mouse!):
plotRSA(x=.314, y=-.118, x2=-.145, y2=-.102, xy=.299, b0=5.628, type="i")

# Plot response surface from an RSA object
set.seed(0xBEEF)
n &lt;- 300
err &lt;- 2
x &lt;- rnorm(n, 0, 5)
y &lt;- rnorm(n, 0, 5)
df &lt;- data.frame(x, y)
df &lt;- within(df, {
	diff &lt;- x-y
	absdiff &lt;- abs(x-y)
	SD &lt;- (x-y)^2
	z.diff &lt;- diff + rnorm(n, 0, err)
	z.abs &lt;- absdiff + rnorm(n, 0, err)
	z.sq &lt;- SD + rnorm(n, 0, err)
	z.add &lt;- diff + 0.4*x + rnorm(n, 0, err)
	z.complex &lt;- 0.4*x + - 0.2*x*y + + 0.1*x^2 - 0.03*y^2 + rnorm(n, 0, err)
})

r1 &lt;- RSA(z.sq~x*y, df, models=c("SQD", "full", "IA"))
plot(r1)	# default: model = "full"
plot(r1, model="SQD", points=list(show=TRUE, value="predicted"))

## End(Not run)
</code></pre>

<hr>
<h2 id='residuals.RSA'>Return residual values of a RSA model</h2><span id='topic+residuals.RSA'></span><span id='topic+resid'></span>

<h3>Description</h3>

<p>Return residual values of a RSA model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'RSA'
residuals(object, ..., model = "full")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.RSA_+3A_object">object</code></td>
<td>
<p>An RSA object.</p>
</td></tr>
<tr><td><code id="residuals.RSA_+3A_...">...</code></td>
<td>
<p>Other parameters (currently not used)</p>
</td></tr>
<tr><td><code id="residuals.RSA_+3A_model">model</code></td>
<td>
<p>Model on which the fitted values are based</p>
</td></tr>
</table>

<hr>
<h2 id='RSA'>Performs several RSA model tests on a data set with two predictors</h2><span id='topic+RSA'></span>

<h3>Description</h3>

<p>Performs several RSA model tests on a data set with two predictors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RSA(
  formula,
  data = NULL,
  center = "none",
  scale = "none",
  na.rm = FALSE,
  out.rm = TRUE,
  breakline = FALSE,
  models = "default",
  cubic = FALSE,
  verbose = TRUE,
  add = "",
  estimator = "MLR",
  se = "robust",
  missing = NA,
  control.variables = c(),
  center.control.variables = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RSA_+3A_formula">formula</code></td>
<td>
<p>A formula in the form <code>z ~ x*y</code>, specifying the variable names used from the data frame, where z is the name of the response variable, and x and y are the names of the predictor variables.</p>
</td></tr>
<tr><td><code id="RSA_+3A_data">data</code></td>
<td>
<p>A data frame with the variables</p>
</td></tr>
<tr><td><code id="RSA_+3A_center">center</code></td>
<td>
<p>Method for centering the predictor variables before the analysis. Default option (&quot;none&quot;) applies no centering. &quot;pooled&quot; centers the predictor variables on their <em>pooled</em> sample mean, which preserves the commensurability of the predictor scales. &quot;variablewise&quot; centers the predictor variables on <em>their respective</em> sample mean. You should think carefully before applying the &quot;variablewise&quot; option, as centering the predictor variables at different values (e.g., their respective means) can affect the commensurability of the predictor scales.</p>
</td></tr>
<tr><td><code id="RSA_+3A_scale">scale</code></td>
<td>
<p>Method for scaling the predictor variables before the analysis. Default option (&quot;none&quot;) applies no scaling. &quot;pooled&quot; scales the predictor variables on their <em>pooled</em> sample SD, which preserves the commensurability of the predictor scales. &quot;variablewise&quot; scales the predictor variables on <em>their respective</em> sample SD. You should think carefully before applying the &quot;variablewise&quot; option, as scaling the predictor variables at different values (e.g., their respective SDs) can affect the commensurability of the predictor scales.</p>
</td></tr>
<tr><td><code id="RSA_+3A_na.rm">na.rm</code></td>
<td>
<p>Remove missings before proceeding?</p>
</td></tr>
<tr><td><code id="RSA_+3A_out.rm">out.rm</code></td>
<td>
<p>Should outliers according to Bollen &amp; Jackman (1980) criteria be excluded from the analyses? In large data sets this analysis is the speed bottleneck. If you are sure that no outliers exist, set this option to FALSE for speed improvements.</p>
</td></tr>
<tr><td><code id="RSA_+3A_breakline">breakline</code></td>
<td>
<p>Should the breakline in the unconstrained absolute difference model be allowed (the breakline is possible from the model formulation, but empirically rather unrealistic ...). Defaults to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="RSA_+3A_models">models</code></td>
<td>
<p>A vector with names of all models that should be computed. Should be any from <code>c("absdiff", "absunc", "diff", "mean", "additive", "IA", "SQD", "RR", "SRR", "SRRR", "SSQD", "SRSQD", "full", "null", "onlyx", "onlyy", "onlyx2", "onlyy2", "cubic", "CA", "RRCA", "CL", "RRCL")</code>. For <code>models="all"</code>, all models are computed, for <code>models="default"</code> all models besides absolute difference models are computed.</p>
</td></tr>
<tr><td><code id="RSA_+3A_cubic">cubic</code></td>
<td>
<p>Should the cubic models with the additional terms Y^3, XY^2, YX^2, and X^3 be included?</p>
</td></tr>
<tr><td><code id="RSA_+3A_verbose">verbose</code></td>
<td>
<p>Should additional information during the computation process be printed?</p>
</td></tr>
<tr><td><code id="RSA_+3A_add">add</code></td>
<td>
<p>Additional syntax that is added to the lavaan model. Can contain, for example, additional constraints, like &quot;p01 == 0; p11 == 0&quot;</p>
</td></tr>
<tr><td><code id="RSA_+3A_estimator">estimator</code></td>
<td>
<p>Type of estimator that should be used by lavaan. Defaults to &quot;MLR&quot;, which provides robust standard errors, a robust scaled test statistic, and can handle missing values. If you want to reproduce standard OLS estimates, use <code>estimator="ML"</code> and <code>se="standard"</code></p>
</td></tr>
<tr><td><code id="RSA_+3A_se">se</code></td>
<td>
<p>Type of standard errors. This parameter gets passed through to the <code>sem</code> function of the <code>lavaan</code> package. See options there. By default, robust SEs are computed. If you use <code>se="boot"</code>, <code>lavaan</code> provides CIs and p-values based on the bootstrapped standard error. If you use <code>confint(..., method="boot")</code>, in contrast, you get CIs and p-values based on percentile bootstrap (see also <code><a href="#topic+confint.RSA">confint.RSA</a></code>).</p>
</td></tr>
<tr><td><code id="RSA_+3A_missing">missing</code></td>
<td>
<p>Handling of missing values (this parameter is passed to the <code>lavaan</code> <code>sem</code> function). By default (<code>missing=NA</code>), Full Information Maximum Likelihood (FIML) is employed in case of missing values. If cases with missing values should be excluded, use <code>missing = "listwise"</code>.</p>
</td></tr>
<tr><td><code id="RSA_+3A_control.variables">control.variables</code></td>
<td>
<p>A string vector with variable names from <code>data</code>. These variables are added as linear predictors to the model (in order &quot;to control for them&quot;). No interactions with the other variables are modeled.</p>
</td></tr>
<tr><td><code id="RSA_+3A_center.control.variables">center.control.variables</code></td>
<td>
<p>Should the control variables be centered before analyses? This can improve interpretability of the intercept, which will then reflect the predicted outcome value at the point (X,Y)=(0,0) when all control variables take their respective <em>average</em> values.</p>
</td></tr>
<tr><td><code id="RSA_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to the <code>lavaan</code> <code><a href="lavaan.html#topic+sem">sem</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Even if the main variables of the model are normally distributed, their squared terms and interaction terms are necessarily non-normal. By default, the RSA function uses a scaled test statistic (<code>test="Satorra-Bentler"</code>) and robust standard errors (<code>se="robust"</code>), which are robust against violations of the normality assumption. 
</p>
<p><em>Why does my standard polynomial regression give different p-values and SEs than the RSA package? Shouldn't they be the same?</em> This is due to the robust standard errors employed in the RSA package. If you set <code>estimator="ML"</code> and <code>se="standard"</code>, you get p-values that are very close to the standard approach. (They might still not be identical because the standard regression approach usually uses an OLS estimator and RSA uses an ML estimator).
</p>
<p>Experimental feature (use with caution!): You can also fit <strong>binary outcome variables</strong> with a probit link function. For that purpose, the response variable has to be defined as &quot;ordered&quot;, and the <code>lavaan</code> estimator changed to &quot;WLSMV&quot;: <code>r1.binary &lt;- RSA(z.binary~x*y, df, ordered="z.binary", estimator="WLSMV", model="full")</code> (for more details see the help file of the <code><a href="lavaan.html#topic+sem">sem</a></code> function in the <code>lavaan</code> package.). The results can also be plotted with probabilities on the z axis using the probit link function: <code>plot(r1.binary, link="probit", zlim=c(0, 1), zlab="Probability")</code>. For plotting, the binary outcome variable must be coded with 0 and 1 (not as a factor).
<code>lavaan</code> at the moment only supports a probit link function for binary outcomes, not a logit link. Please be aware that this experimental feature can fit the full model, but most other functions (such as model comparisons) might break and errors might show up.
</p>


<h3>Note</h3>

<p>For explanations of the meaning of the various different models that can be estimated, please see Schönbrodt (2016) for the second-order models (i.e., all models but &quot;CA&quot;, &quot;RRCA&quot;, &quot;CL&quot;, &quot;RRCL&quot;) and Humberg et al. (in press) for the third-order (cubic) models (&quot;CA&quot;, &quot;RRCA&quot;, &quot;CL&quot;, &quot;RRCL&quot;). 
</p>
<p>For most of the second-order models, several auxiliary parameters are computed from the estimated model coefficients (e.g., a1, ..., a5, p10, p11, p20, p21) and printed in the <code>summary</code> output. They can be used to guide interpretation by means of response surface methodology. Some references that explain how to use these parameters for interpretation are Edwards (2002; comprehensive overview of response surface methodology), Humberg et al. (2019; interpretation of a1, a2, a3, a4, p10, and p11, and how to use them to investigate congruence effects), Nestler et al. (2019; interpretation of a1, a2, a3, a4, and a5, and how to use them to investigate congruence effects, see in particular Appendix A for the introduction of a5), and Schönbrodt et al. (2018; interpretation of a1, ..., a5, see in particular Appendix A for a5).
</p>
<p>The print function provides descriptive statistics about discrepancies in the predictors (with respect to numerical congruence). A cutpoint of |delta z| &gt; 0.5 is used. The computation generally follows the idea of Shannock et al (2010) and Fleenor et al. (1996). However, in contrast to them, we standardize to the common mean and the common SD of both predictor variables. Otherwise we would break commensurability, and a person who has x=y in the unstandardized variable could become incongruent after variable-wise standardization. See also our discussion of commensurability and scale transformation in the cubic RSA paper (Humberg et al., in press; see pp. 35 - 37 in the preprint at <a href="https://psyarxiv.com/v6m35)">https://psyarxiv.com/v6m35)</a>.
</p>


<h3>References</h3>

<p>Edwards, J. R. (2002). Alternatives to difference scores: Polynomial regression analysis and response surface methodology. In F. Drasgow &amp; N. W. Schmitt (Eds.), <em>Advances in measurement and data analysis</em> (pp. 350–400). San Francisco, CA: Jossey-Bass.
</p>
<p>Humberg, S., Nestler, S., &amp; Back, M. D. (2019). Response Surface Analysis in Personality and Social Psychology: Checklist and Clarifications for the Case of Congruence Hypotheses. <em>Social Psychological and Personality Science</em>, 10(3), 409–419. doi:10.1177/1948550618757600
</p>
<p>Humberg, S., Schönbrodt, F. D., Back, M. D., &amp; Nestler, S. (in press). Cubic response surface analysis: Investigating asymmetric and level-dependent congruence effects with third-order polynomial models. Psychological Methods. doi:10.1037/met0000352
</p>
<p>Nestler, S., Humberg, S., &amp; Schönbrodt, F. D. (2019). Response surface analysis with multilevel data: Illustration for the case of congruence hypotheses. <em>Psychological Methods</em>, 24(3), 291–308. doi:10.1037/met0000199
</p>
<p>Schönbrodt, F. D. (2016). <em>Testing fit patterns with polynomial regression models.</em> Retrieved from osf.io/3889z
</p>
<p>Schönbrodt, F. D., Humberg, S., &amp; Nestler, S. (2018). Testing similarity effects with dyadic response surface analysis. <em>European Journal of Personality</em>, 32(6), 627-641. doi:10.1002/per.2169
</p>


<h3>See Also</h3>

<p><code><a href="#topic+demoRSA">demoRSA</a></code>, <code><a href="#topic+plotRSA">plotRSA</a></code>, <code><a href="#topic+RSA.ST">RSA.ST</a></code>, <code><a href="#topic+confint.RSA">confint.RSA</a></code>, <code><a href="#topic+compare">compare</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute response surface from a fake data set
set.seed(0xBEEF)
n &lt;- 300
err &lt;- 15
x &lt;- rnorm(n, 0, 5)
y &lt;- rnorm(n, 0, 5)
df &lt;- data.frame(x, y)
df &lt;- within(df, {
	diff &lt;- x-y
	absdiff &lt;- abs(x-y)
	SD &lt;- (x-y)^2
	z.diff &lt;- diff + rnorm(n, 0, err)
	z.abs &lt;- absdiff + rnorm(n, 0, err)
	z.sq &lt;- SD + rnorm(n, 0, err)
	z.add &lt;- diff + 0.4*x + rnorm(n, 0, err)
	z.complex &lt;- 0.4*x + - 0.2*x*y + + 0.1*x^2 - 0.03*y^2 + rnorm(n, 0, err)
})
df$z.binary &lt;- as.numeric(df$z.sq &lt; median(df$z.sq))

## Not run: 
r1 &lt;- RSA(z.sq~x*y, df)
summary(r1)
compare(r1)
plot(r1)
plot(r1, model="SRSQD")
plot(r1, model="full", type="c")
getPar(r1, "coef")	# print model parameters including SE and CI
RSA.ST(r1)	# get surface parameters

# Example with binary outcome 
(probit regression, see Details; Experimental and a dirty workaround!).
# The standard summary output does not work; you have to access the full model directly:
r1.binary &lt;- RSA(z.binary~x*y, df, ordered="z.binary", estimator="WLSMV", 
    model="full", se="standard")
# --&gt; ignore the warning
summary(r1.binary$models[["full"]])
plot(r1.binary, link="probit", zlim=c(0, 1), zlab="Probability")

# Motive congruency example
data(motcon)
r.m &lt;- RSA(postVA~ePow*iPow, motcon)

# Get boostrapped CIs with 10 bootstrap samples (usually this should be set to 5000 or higher),
# only from the SSQD model
c1 &lt;- confint(r.m, model="SSQD", method="boot", R=10)

# Plot the final model
plot(r.m, model="RR", xlab="Explicit power motive", 
		ylab="Implicit power motive", zlab="Affective valence")
		
# Inclusion of control variables: Fake data on self-other agreement
data(selfother)
r.c &lt;- RSA(liking~IQ_self*IQ_friend, 
           center="pooled",
           control.variables=c("age", "int"),
           center.control.variables = TRUE,
           data=selfother)
summary(r.c)	
		

## End(Not run)
</code></pre>

<hr>
<h2 id='RSA.ST'>Surface tests</h2><span id='topic+RSA.ST'></span>

<h3>Description</h3>

<p>Calculates surface parameters a1 to a4, the stationary point, the principal axes, the eigenvectors and -values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RSA.ST(
  x = 0,
  y = 0,
  x2 = 0,
  xy = 0,
  y2 = 0,
  b0 = 0,
  SE = NULL,
  COV = NULL,
  df = NULL,
  model = "full"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RSA.ST_+3A_x">x</code></td>
<td>
<p>Either an RSA object (returned by the <code>RSA</code> function), or the coefficient for the X predictor</p>
</td></tr>
<tr><td><code id="RSA.ST_+3A_y">y</code></td>
<td>
<p>Y coefficient</p>
</td></tr>
<tr><td><code id="RSA.ST_+3A_x2">x2</code></td>
<td>
<p>X^2 coefficient</p>
</td></tr>
<tr><td><code id="RSA.ST_+3A_xy">xy</code></td>
<td>
<p>XY interaction coefficient</p>
</td></tr>
<tr><td><code id="RSA.ST_+3A_y2">y2</code></td>
<td>
<p>Y^2 coefficient</p>
</td></tr>
<tr><td><code id="RSA.ST_+3A_b0">b0</code></td>
<td>
<p>The intercept</p>
</td></tr>
<tr><td><code id="RSA.ST_+3A_se">SE</code></td>
<td>
<p>In case that the coefficients are provided directly (as parameters x, y, x2, y2, xy), SE can provide the standard errors of these estimates. SE has to be a named vector with exactly five elements with the names of the coefficients, e.g.: <code>SE=c(x=.1, y=.2, x2=.1, y2=.5, xy=.3)</code>. SEs of all parameters have to be provided, otherwise the function will print an error. In case standard errors <em>and</em> the covariances (see below) <em>and</em> df (see below) are provided, parametric confidence intervals for a1 to a4 are calculated.</p>
</td></tr>
<tr><td><code id="RSA.ST_+3A_cov">COV</code></td>
<td>
<p>Covariances between parameters. COV has to be a named vector with exactly four elements with the names of four specific covariances, e.g.: <code>COV=c(x_y=.1, x2_y2 = .2, x2_xy = .3, y2_xy = .4)</code>, where x_y is the covariance between x and y, and so on. All these covariances have to be provided with exactly these names, otherwise the function will print an error.</p>
</td></tr>
<tr><td><code id="RSA.ST_+3A_df">df</code></td>
<td>
<p>Degrees of freedom for the calculation of a1 to a4 confidence intervals. The df are the residual dfs of the model (df = n - estimated parameters). For the full second-order polynomial model, this is 'n - 6 - number of control variables' in a regular regression (the following parameters are estimated: Intercept, x, y, x2, xy, y2, all control variables). <code>df</code> should be a single number.</p>
</td></tr>
<tr><td><code id="RSA.ST_+3A_model">model</code></td>
<td>
<p>If x is an RSA object, this parameter specifies the model from which to extract the coefficients</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No details so far.
</p>


<h3>Value</h3>

<p>Returns surface parameters a1 to a5. If an RSA object or SE, COV and df are provided, also significance test and standard errors of a1 to a5 are reported.
The stationary point (X0, Y0, and Z0). 
First principal axis (PA) relative to the X-Y plane (p10 = intercept, p11 = slope), second PA (p20 = intercept, p21 = slope). 
M = eigenvectors, l = eigenvalues, L = lambda matrix
as1X to as4X: surface parameters of the PA, relative to X values
as1Y to as4Y: surface parameters of the PA, relative to Y values
PA1.curvX: quadratic component of the first PA, as seen from X axis
PA2.curvX: quadratic component of the second PA, as seen from X axis
PA1.curv: quadratic component of the first PA, after optimal coord transformation
PA2.curv: quadratic component of the second PA, after optimal coord transformation
</p>


<h3>References</h3>

<p>Shanock, L. R., Baran, B. E., Gentry, W. A., Pattison, S. C., &amp; Heggestad, E. D. (2010). Polynomial Regression with Response Surface Analysis: A Powerful Approach for Examining Moderation and Overcoming Limitations of Difference Scores. <em>Journal of Business and Psychology, 25</em>, 543-554. doi:10.1007/s10869-010-9183-4
Shanock, L. R., Baran, B. E., Gentry, W. A., &amp; Pattison, S. C. (2014). Erratum to: Polynomial regression with response surface analysis: A powerful approach for examining moderation and overcoming limitations of difference scores. Journal of Business and Psychology, 29, . http://doi.org/10.1007/s10869-013-9317-6
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RSA">RSA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get surface parameters from known parameters
# example from Shanock et al. (2010), p. 548, Table 2
RSA.ST(x=-.23, y=.77, x2=-.07, y2=-.10, xy=.27)


## Compute standard errors and p values for surface parameters 
## from external regression coefficients:
# standard errors for coefficients
SE &lt;- c(x=.09, y=.09, x2=.07, y2=.07, xy=.11)
# covariances for specific coefficients:
COV &lt;- c(x_y= -.000, x2_y2 = .001, x2_xy = -.003, y2_xy = -.004)
RSA.ST(x = .131, y = .382, x2 = .074, xy = .002, y2 = .039, SE=SE, COV=COV, df=181)


# Get surface parameters from a computed RSA object
set.seed(0xBEEF)
n &lt;- 300
err &lt;- 2
x &lt;- rnorm(n, 0, 5)
y &lt;- rnorm(n, 0, 5)
df &lt;- data.frame(x, y)
df &lt;- within(df, {
	diff &lt;- x-y
	absdiff &lt;- abs(x-y)
	SD &lt;- (x-y)^2
	z.diff &lt;- diff + rnorm(n, 0, err)
	z.abs &lt;- absdiff + rnorm(n, 0, err)
	z.sq &lt;- SD + rnorm(n, 0, err)
	z.add &lt;- diff + 0.4*x + rnorm(n, 0, err)
	z.complex &lt;- 0.4*x + - 0.2*x*y + + 0.1*x^2 - 0.03*y^2 + rnorm(n, 0, err)
})

r1 &lt;- RSA(z.sq~x*y, df, models="full")
RSA.ST(r1)
</code></pre>

<hr>
<h2 id='selfother'>A fake data set on self-other agreement</h2><span id='topic+selfother'></span>

<h3>Description</h3>

<p>The data set selfother is a self-generated fake data set which can, for example, be used to try out the inclusion of control variables in the RSA() function and to try out cubic RSA. The variables in the data set are meant to reflect the following constructs:
</p>


<h3>Format</h3>

<p>A data frame with 800 rows and 9 variables
</p>


<h3>Details</h3>


<ul>
<li><p> IQ_self Self-rated intelligence (on IQ scale)
</p>
</li>
<li><p> IQ_friend Friend-rated intelligence (on IQ scale)
</p>
</li>
<li><p> harmony Level of harmony in typical interactions between the target person and the friend
</p>
</li>
<li><p> VI_self Self-reported value importance
</p>
</li>
<li><p> VI_partner Partner-reported value importance
</p>
</li>
<li><p> distance Emotional distance felt toward the partner
</p>
</li>
<li><p> age Age of the target person
</p>
</li>
<li><p> int Typical number of interactions between the target person and the friend (who provided the intelligence rating) per week
</p>
</li>
<li><p> liking Target person's rating about how much he/she likes the friend
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
