<!DOCTYPE html><html><head><title>Help for package npExact</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {npExact}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bargaining'><p>Amount sent in the Ultimatum Game</p></a></li>
<li><a href='#french'><p>Indices of minority shareholder protection of countries with</p>
civil law with and without french origin.</a></li>
<li><a href='#mshscores'><p>Indices of minority shareholder protection of countries with common and</p>
with civil law.</a></li>
<li><a href='#npExact-package'><p>Nonparametric hypothesis tests</p></a></li>
<li><a href='#npMeanPaired'><p>A test for the mean difference between two bounded random variables given</p>
matched pairs.</a></li>
<li><a href='#npMeanSingle'><p>A test for the mean of a bounded random variable based on a single sample</p>
of iid observations.</a></li>
<li><a href='#npMeanUnpaired'><p>A test for comparing the means of two bounded random variables given two</p>
independent samples</a></li>
<li><a href='#npStochinUnpaired'><p>A test of a stochastic inequality given two independent samples</p></a></li>
<li><a href='#npVarianceSingle'><p>A test for the variance of a bounded random variable based on a single</p>
sample of iid observations.</a></li>
<li><a href='#pain'><p>Pain experienced before and after a knie operation</p></a></li>
<li><a href='#uncertainty'><p>Uncertainty in a game theoretical experiment.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Exact Nonparametric Hypothesis Tests for the Mean, Variance and
Stochastic Inequality</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-11-12</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides several novel exact hypothesis tests with minimal assumptions on the errors. The tests are exact, meaning that their p-values are correct for the given sample sizes (the p-values are not derived from asymptotic analysis). The test for stochastic inequality is for ordinal comparisons based on two independent samples and requires no assumptions on the errors. The other tests include tests for the mean and variance of a single sample and comparing means in independent samples. All these tests only require that the data has known bounds (such as percentages that lie in [0,100]. These bounds are part of the input.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/zauster/npExact">https://github.com/zauster/npExact</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/zauster/npExact/issues">https://github.com/zauster/npExact/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-11-09 18:23:11 UTC; reitero</td>
</tr>
<tr>
<td>Author:</td>
<td>Oliver Reiter <a href="https://orcid.org/0000-0001-6338-5428"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Karl Schlag [aut],
  Peter Saffert [ctb],
  Christian Pechhacker [ctb],
  Simona Jokubauskaite [ctb],
  Tautvilas Janusauskas [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Oliver Reiter &lt;oliver.reiter@snapdragon.cc&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-12-03 09:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='bargaining'>Amount sent in the Ultimatum Game</h2><span id='topic+bargaining'></span>

<h3>Description</h3>

<p>The Ultimatum game was played separately in four different
countries. This data contains the offers of 30 students in
Israel and 27 in the United States on a scale from 0 to 10.
This dataset is taken from Roth et al. (1991).
</p>


<h3>Format</h3>

<p>A data frame containing 30 observations for Israel
and 27 for the US.</p>


<h3>References</h3>

<p>Roth, A. E., Prasnikar, V., Okuno-Fujiwara, M., &amp;
Zamir, S. (1991). Bargaining and market behavior in
Jerusalem, Ljubljana, Pittsburgh, and Tokyo: An
experimental study. The American Economic Review,
1068-1095.
</p>

<hr>
<h2 id='french'>Indices of minority shareholder protection of countries with
civil law with and without french origin.</h2><span id='topic+french'></span>

<h3>Description</h3>

<p>This data contains the indices of minority shareholder protection on a
scale from 0 to 1 in 51 countries with civil law, differentiating between
those with (32 observations) and those without (19 observations) french
origin. A higher value of the index means that country is more protected.
The data set is taken from Djankov et al. (2008).
</p>


<h3>Format</h3>

<p>A list containing a vector of 32 observations of
countries with french origin and a vector of 19 countries
without french origin.</p>


<h3>References</h3>

<p>Djankov, S., La Porta, R., Lopez-de-Silanes, F.,
&amp; Shleifer, A. (2008). The law and economics of
self-dealing. Journal of financial economics, 88(3),
430-465.
</p>

<hr>
<h2 id='mshscores'>Indices of minority shareholder protection of countries with common and
with civil law.</h2><span id='topic+mshscores'></span>

<h3>Description</h3>

<p>This data contains the indices of minority shareholder protection on a
scale from 0 to 1 in 51 countries with civil law and 21 countries with
common loaw. A higher value of the index means that country is more
protected. The data set is taken from Djankov et al. (2008).
</p>


<h3>Format</h3>

<p>A dataframe containing 51 observations for civil law
and 21 for common law.</p>


<h3>References</h3>

<p>Djankov, S., La Porta, R., Lopez-de-Silanes, F.,
&amp; Shleifer, A. (2008). The law and economics of
self-dealing. Journal of financial economics, 88(3),
430-465.
</p>

<hr>
<h2 id='npExact-package'>Nonparametric hypothesis tests</h2><span id='topic+npExact-package'></span><span id='topic+npExact'></span>

<h3>Description</h3>

<p><code>npExact</code> provides distribution-free hypothesis tests.
</p>


<h3>Details</h3>

<p>This package contains several new hypothesis tests, which do
not require that the user makes assumptions on the underlying
distributions.
</p>
<p>However, all tests except <code>npStochin</code> can only be
applied if there are exogenously given bounds known to the
user before gathering the data such that it is known by
definition of the underlying process that all observations
lie within these bounds.
</p>
<p>So for instance, if the data involves percentages then the
lower bound is 0 and the upper bound is 100, by definition of
the data and not something (like normality) that cannot be
deduced from the properties of the data.
</p>


<h3>Author(s)</h3>

<p>Karl Schlag, Oliver Reiter, Peter Saffert, Christian
Pechhacker, Simona Jokubauskaite, Tautvilas Janusauskas
</p>


<h3>References</h3>

<p>Karl Schlag, A New Method for Constructing Exact
Tests without Making any Assumptions (August, 2008)
Department of Economics and Business Working Paper 1109,
Universitat Pompeu Fabra
</p>


<h3>See Also</h3>

<p><a href="http://homepage.univie.ac.at/karl.schlag/research/statistics/exacthypothesistesting8.pdf">http://homepage.univie.ac.at/karl.schlag/research/statistics/exacthypothesistesting8.pdf</a>
</p>
<p><a href="https://homepage.univie.ac.at/karl.schlag/statistics.php">https://homepage.univie.ac.at/karl.schlag/statistics.php</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## npMeanPaired
## test whether pain after the surgery is less than before the surgery
data(pain)
npMeanPaired(pain$before, pain$after, lower = 0, upper = 100)

## npMeanSingle
## test whether Americans gave more than 5 dollars in a round of
## the Ultimatum game
data(bargaining)
us_offers &lt;- bargaining$US
npMeanSingle(us_offers, mu = 5, lower = 0, upper = 10, alternative =
"greater", ignoreNA = TRUE) ## no rejection

## npMeanUnpaired
## test whether countries with french origin score lower than
## countries with no french origin
data(french)
origin &lt;- french$french.origin
rest &lt;- french$rest.of.civil
npMeanUnpaired(origin, rest, alternative = "less", ignoreNA = TRUE)

## npStochin
npStochinUnpaired(origin, rest, ignoreNA = TRUE)

## npVarianceSingle
## see if the minority share holder shores have a variance greater
## than 0.05
data(mshscores)
scores &lt;- unlist(mshscores)
npVarianceSingle(scores, lower = 0, upper = 1, v = 0.05, ignoreNA = TRUE)

</code></pre>

<hr>
<h2 id='npMeanPaired'>A test for the mean difference between two bounded random variables given
matched pairs.</h2><span id='topic+npMeanPaired'></span>

<h3>Description</h3>

<p>This test requires that the user knows bounds before gathering the data
such that the properties of the data generating process imply that all
observations will be within these bounds. The data input consists of pairs
of observations, each pair consisting of an observation of each random
variable, different pairs being independently generated. No further
distributional assumptions are made.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>npMeanPaired(x1, x2, lower = 0, upper = 1, alpha = 0.05,
  alternative = "two.sided", epsilon = 1 * 10^(-6),
  iterations = 5000, max.iterations = 100000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="npMeanPaired_+3A_x1">x1</code>, <code id="npMeanPaired_+3A_x2">x2</code></td>
<td>
<p>the (non-empty) numerical data vectors which contain the
variables to be tested. The first values of the vectors are assumed to be
the first matched pair of observations, the second values the second
matched pair and so on.</p>
</td></tr>
<tr><td><code id="npMeanPaired_+3A_lower">lower</code>, <code id="npMeanPaired_+3A_upper">upper</code></td>
<td>
<p>the theoretical lower and upper bounds on the data
outcomes known ex-ante before gathering the data.</p>
</td></tr>
<tr><td><code id="npMeanPaired_+3A_alpha">alpha</code></td>
<td>
<p>the type I error.</p>
</td></tr>
<tr><td><code id="npMeanPaired_+3A_alternative">alternative</code></td>
<td>
<p>a character string describing the alternative
hypothesis, can take values &quot;greater&quot;, &quot;less&quot; or &quot;two.sided&quot;.</p>
</td></tr>
<tr><td><code id="npMeanPaired_+3A_epsilon">epsilon</code></td>
<td>
<p>the tolerance in terms of probability of the Monte Carlo
simulations.</p>
</td></tr>
<tr><td><code id="npMeanPaired_+3A_iterations">iterations</code></td>
<td>
<p>the number of iterations used, should not be changed if
the exact solution should be derived</p>
</td></tr>
<tr><td><code id="npMeanPaired_+3A_max.iterations">max.iterations</code></td>
<td>
<p>the maximum number of iterations that should be
carried out. This number could be increased to achieve greater accuracy in
cases where the difference between the threshold probability and theta is
small. Default: <code>10000</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Under alternative = &quot;greater&quot;, it is a test of the null hypothesis
<code class="reqn">H_0: E(x_1) \le E(x_2)</code> against the alternative hypothesis <code class="reqn">H_1:
E(x_1) &gt; E(x_2)</code>.
</p>
<p>This test uses the known bounds of the variables to transform the data into
[0, 1]. Then a random transformation is used to turn the data into
binary-valued variables. On this variables the exact McNemar Test with
level <code>pseudoalpha</code> is performed and the result recorded. The random
transformation and the test are then repeated <code>iterations</code> times. If
the average rejection probability <code>probrej</code> of the iterations is at
least <code>theta</code>, then the null hypothesis is rejected. If however
<code>probrej</code> is too close to the threshold <code>theta</code> then the number
of iterations is increased. The algorithm keeps increasing the number of
iterations until the bound on the mistake involved by running these
iterations is below <code>epsilon</code>. This error epsilon is incorporated into
the overall level <code>alpha</code> in order to maintain that the test is exact.
</p>
<p><code>theta</code> (and a value <code>mu</code> of the difference between the two means
in the set of the alternative hypothesis) is found in an optimization
procedure. <code>theta</code> and <code>mu</code> are chosen as to maximize the set of
data generating processes belonging to the alternative hypothesis that
yield type II error probability below 0.5. Please see the cited paper below
for further information.
</p>


<h3>Value</h3>

<p>A list with class &quot;nphtest&quot; containing the following components:
</p>
<table>
<tr><td><code>method</code></td>
<td>
<p> a character string indicating the name and type of the test
that was performed.  </p>
</td></tr> <tr><td><code>data.name</code></td>
<td>
<p> a character string giving the
name(s) of the data.  </p>
</td></tr> <tr><td><code>alternative</code></td>
<td>
<p> a character string describing
the alternative hypothesis.  </p>
</td></tr> <tr><td><code>estimate</code></td>
<td>
<p> the sample means of the
given data.  </p>
</td></tr> <tr><td><code>probrej</code></td>
<td>
<p> numerical estimate of the rejection
probability of the randomized test, derived by taking an average of
<code>iterations</code> realizations of the rejection probability.  </p>
</td></tr>
<tr><td><code>bounds</code></td>
<td>
<p> the lower and upper bounds of the variables.  </p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p> the specified hypothesized value of the difference of
the variable means.  </p>
</td></tr> <tr><td><code>alpha</code></td>
<td>
<p> the type I error.  </p>
</td></tr> <tr><td><code>theta</code></td>
<td>
<p> the
parameter that minimizes the type II error.  </p>
</td></tr> <tr><td><code>pseudoalpha</code></td>
<td>

<p><code>theta</code>*<code>alpha</code>, this is the level used when calculating the
average rejection probability during the iterations.  </p>
</td></tr> <tr><td><code>rejection</code></td>
<td>

<p>logical indicator for whether or not the null hypothesis can be rejected.
</p>
</td></tr> <tr><td><code>iterations</code></td>
<td>
<p> the number of iterations that were performed.  </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Karl Schlag, Christian Pechhacker and Oliver Reiter
</p>


<h3>References</h3>

<p>Schlag, Karl H. 2008, A New Method for Constructing Exact Tests
without Making any Assumptions, Department of Economics and Business
Working Paper 1109, Universitat Pompeu Fabra. Available at
<a href="https://ideas.repec.org/p/upf/upfgen/1109.html">https://ideas.repec.org/p/upf/upfgen/1109.html</a>.
</p>


<h3>See Also</h3>

<p><a href="https://homepage.univie.ac.at/karl.schlag/statistics.php">https://homepage.univie.ac.at/karl.schlag/statistics.php</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## test whether pain after the surgery is less than before the surgery
data(pain)
npMeanPaired(pain$before, pain$after, lower = 0, upper = 100)

## when the computer was used in the surgery
before_pc &lt;- pain[pain$pc == 1, "before"]
after_pc &lt;- pain[pain$pc == 1, "after"]
npMeanPaired(before_pc, after_pc, lower = 0, upper = 100)

## test whether uncertainty decreased from the first to the second round
data(uncertainty)
npMeanPaired(uncertainty$w1, uncertainty$w2, upper = 60) ## or
with(uncertainty, npMeanPaired(w1, w2, upper = 60))

</code></pre>

<hr>
<h2 id='npMeanSingle'>A test for the mean of a bounded random variable based on a single sample
of iid observations.</h2><span id='topic+npMeanSingle'></span>

<h3>Description</h3>

<p>This test requires that the user knows upper and lower bounds before
gathering the data such that the properties of the data generating process
imply that all observations will be within these bounds. The data input
consists of a sequence of observations, each being an independent
realization of the random variable. No further distributional assumptions
are made.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>npMeanSingle(x, mu, lower = 0, upper = 1, alternative = "two.sided",
  iterations = 5000, alpha = 0.05, epsilon = 1 * 10^(-6),
  ignoreNA = FALSE, max.iterations = 100000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="npMeanSingle_+3A_x">x</code></td>
<td>
<p>a (non-empty) numeric vector of data values.</p>
</td></tr>
<tr><td><code id="npMeanSingle_+3A_mu">mu</code></td>
<td>
<p>threshold value for the null hypothesis.</p>
</td></tr>
<tr><td><code id="npMeanSingle_+3A_lower">lower</code>, <code id="npMeanSingle_+3A_upper">upper</code></td>
<td>
<p>the theoretical lower and upper bounds on the data
outcomes known ex-ante before gathering the data.</p>
</td></tr>
<tr><td><code id="npMeanSingle_+3A_alternative">alternative</code></td>
<td>
<p>a character string describing the alternative
hypothesis, can take values &quot;greater&quot;, &quot;less&quot; or &quot;two.sided&quot;.</p>
</td></tr>
<tr><td><code id="npMeanSingle_+3A_iterations">iterations</code></td>
<td>
<p>the number of iterations used, should not be changed if
the exact solution should be derived</p>
</td></tr>
<tr><td><code id="npMeanSingle_+3A_alpha">alpha</code></td>
<td>
<p>the type I error.</p>
</td></tr>
<tr><td><code id="npMeanSingle_+3A_epsilon">epsilon</code></td>
<td>
<p>the tolerance in terms of probability of the Monte Carlo
simulations.</p>
</td></tr>
<tr><td><code id="npMeanSingle_+3A_ignorena">ignoreNA</code></td>
<td>
<p>if <code>TRUE</code>, NA values will be omitted. Default:
<code>FALSE</code></p>
</td></tr>
<tr><td><code id="npMeanSingle_+3A_max.iterations">max.iterations</code></td>
<td>
<p>the maximum number of iterations that should be
carried out. This number could be increased to achieve greater accuracy in
cases where the difference between the threshold probability and theta is
small. Default: <code>10000</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For any <code class="reqn">\mu</code> that lies between the two bounds, under alternative =
&quot;greater&quot;, it is a test of the null hypothesis <code class="reqn">H_0 : E(X) \le \mu</code>
against the alternative hypothesis <code class="reqn">H_1 : E(X) &gt; \mu</code>.
</p>
<p>Using the known bounds, the data is transformed to lie in [0, 1] using an
affine transformation. Then the data is randomly transformed into a new
data set that has values 0, <code>mu</code> and 1 using a mean preserving
transformation. The exact randomized binomial test is then used to
calculate the rejection probability of this under new data when level is
<code>theta</code>*<code>alpha</code>. This random transformation is repeated
<code>iterations</code> times. If the average rejection probability is greater
than theta, one can reject the null hypothesis. If however the average
rejection probability is too close to theta then the iterations are
continued. The values of <code>theta</code> and a value of <code>mu</code> in the
alternative hypothesis is found in an optimization procedure to maximize
the set of parameters in the alternative hypothesis under which the type II
error probability is below 0.5. Please see the cited paper below for
further information.
</p>


<h3>Value</h3>

<p>A list with class &quot;nphtest&quot; containing the following components:
</p>
<table>
<tr><td><code>method</code></td>
<td>
<p> a character string indicating the name and type of the test
that was performed.  </p>
</td></tr> <tr><td><code>data.name</code></td>
<td>
<p> a character string giving the
name(s) of the data.  </p>
</td></tr> <tr><td><code>alternative</code></td>
<td>
<p> a character string describing
the alternative hypothesis.  </p>
</td></tr> <tr><td><code>estimate</code></td>
<td>
<p> the estimated mean or
difference in means depending on whether it was a one-sample test or a
two-sample test.  </p>
</td></tr> <tr><td><code>probrej</code></td>
<td>
<p> numerical estimate of the rejection
probability of the randomized test, derived by taking an average of
<code>iterations</code> realizations of the rejection probability.  </p>
</td></tr>
<tr><td><code>bounds</code></td>
<td>
<p> the lower and upper bounds of the variables.  </p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p> the specified hypothesized value of the correlation
between the variables.  </p>
</td></tr> <tr><td><code>alpha</code></td>
<td>
<p> the type I error </p>
</td></tr> <tr><td><code>theta</code></td>
<td>

<p>the parameter that minimizes the type II error.  </p>
</td></tr> <tr><td><code>pseudoalpha</code></td>
<td>

<p><code>theta</code>*<code>alpha</code>, this is the level used when calculating the
average rejection probability during the iterations.  </p>
</td></tr> <tr><td><code>rejection</code></td>
<td>

<p>logical indicator for whether or not the null hypothesis can be rejected.
</p>
</td></tr> <tr><td><code>iterations</code></td>
<td>
<p> the number of iterations that were performed.  </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Karl Schlag, Peter Saffert and Oliver Reiter
</p>


<h3>References</h3>

<p>Schlag, Karl H. 2008, A New Method for Constructing Exact Tests
without Making any Assumptions, Department of Economics and Business
Working Paper 1109, Universitat Pompeu Fabra. Available at
<a href="https://ideas.repec.org/p/upf/upfgen/1109.html">https://ideas.repec.org/p/upf/upfgen/1109.html</a>.
</p>


<h3>See Also</h3>

<p><a href="https://homepage.univie.ac.at/karl.schlag/statistics.php">https://homepage.univie.ac.at/karl.schlag/statistics.php</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## test whether Americans gave more than 5 dollars in a round of
## the Ultimatum game
data(bargaining)
us_offers &lt;- bargaining$US
npMeanSingle(us_offers, mu = 5, lower = 0, upper = 10, alternative =
"greater", ignoreNA = TRUE) ## no rejection

## test if the decrease in pain before and after the surgery is smaller
## than 50
data(pain)
pain$decrease &lt;- with(pain, before - after)
without_pc &lt;- pain[pain$pc == 0, "decrease"]
npMeanSingle(without_pc, mu = 50, lower = 0, upper = 100,
alternative = "less")

</code></pre>

<hr>
<h2 id='npMeanUnpaired'>A test for comparing the means of two bounded random variables given two
independent samples</h2><span id='topic+npMeanUnpaired'></span>

<h3>Description</h3>

<p>This test requires that the user knows upper and lower bounds before
gathering the data such that the properties of the data generating process
imply that all observations will be within these bounds. The data input
consists of a sequence of independent observations for each random
variable, the two sequences being generated independently. No further
distributional assumptions are made.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>npMeanUnpaired(x1, x2, lower = 0, upper = 1, iterations = 5000,
  alpha = 0.05, alternative = "two.sided", epsilon = 1 * 10^(-6),
  ignoreNA = FALSE, max.iterations = 100000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="npMeanUnpaired_+3A_x1">x1</code>, <code id="npMeanUnpaired_+3A_x2">x2</code></td>
<td>
<p>the (non-empty) numerical data vectors which contain the
variables to be tested.</p>
</td></tr>
<tr><td><code id="npMeanUnpaired_+3A_lower">lower</code>, <code id="npMeanUnpaired_+3A_upper">upper</code></td>
<td>
<p>the theoretical lower and upper bounds on the data
outcomes known ex-ante before gathering the data.</p>
</td></tr>
<tr><td><code id="npMeanUnpaired_+3A_iterations">iterations</code></td>
<td>
<p>the number of iterations used, should not be changed if
the exact solution should be derived.</p>
</td></tr>
<tr><td><code id="npMeanUnpaired_+3A_alpha">alpha</code></td>
<td>
<p>the type I error.</p>
</td></tr>
<tr><td><code id="npMeanUnpaired_+3A_alternative">alternative</code></td>
<td>
<p>a character string describing the alternative
hypothesis, can take values &quot;greater&quot;, &quot;less&quot; or &quot;two.sided&quot;.</p>
</td></tr>
<tr><td><code id="npMeanUnpaired_+3A_epsilon">epsilon</code></td>
<td>
<p>the tolerance in terms of probability of the Monte Carlo
simulations.</p>
</td></tr>
<tr><td><code id="npMeanUnpaired_+3A_ignorena">ignoreNA</code></td>
<td>
<p>if <code>TRUE</code>, NA values will be omitted. Default:
<code>FALSE</code></p>
</td></tr>
<tr><td><code id="npMeanUnpaired_+3A_max.iterations">max.iterations</code></td>
<td>
<p>the maximum number of iterations that should be
carried out. This number could be increased to achieve greater accuracy in
cases where the difference between the threshold probability and theta is
small. Default: <code>10000</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a test of the null hypothesis: <code class="reqn">H_0: E(X_1) \le E(X_2)</code> against
<code class="reqn">H_1: E(X_1) &gt; E(X_2)</code>.
</p>
<p>This test uses the known bounds of the variables to transform the data into
[0, 1]. Then a random transformation is used to turn the data into
binary-valued variables. On this variables the exact Fischer-Tocher Test
with level <code>pseudoalpha</code> is performed and the result recorded. The
random transformation and the test are then repeated <code>iterations</code>
times. If the average rejection probability <code>probrej</code> of the
iterations is at least <code>theta</code>, then the null hypothesis is rejected.
If however <code>probrej</code> is too close to the threshold <code>theta</code> then
the number of iterations is increased. The algorithm keeps increasing the
number of iterations until the bound on the mistake involved by running
these iterations is below <code>epsilon</code>. This error epsilon is
incorporated into the overall level <code>alpha</code> in order to maintain that
the test is exact.
</p>
<p><code>theta</code> is found in an optimization procedure. <code>theta</code> is chosen
as to bring the type II error to 0.5. Please see the cited paper below for
further information.
</p>


<h3>Value</h3>

<p>A list with class &quot;nphtest&quot; containing the following components:
</p>
<table>
<tr><td><code>method</code></td>
<td>
<p> a character string indicating the name and type of the test
that was performed.  </p>
</td></tr> <tr><td><code>data.name</code></td>
<td>
<p> a character string giving the
name(s) of the data.  </p>
</td></tr> <tr><td><code>alternative</code></td>
<td>
<p> a character string describing
the alternative hypothesis.  </p>
</td></tr> <tr><td><code>estimate</code></td>
<td>
<p> the sample means of the two
variables.  </p>
</td></tr> <tr><td><code>probrej</code></td>
<td>
<p> numerical estimate of the rejection
probability of the randomized test, derived by taking an average of
<code>iterations</code> realizations of the rejection probability.  </p>
</td></tr>
<tr><td><code>bounds</code></td>
<td>
<p> the lower and upper bounds of the variables.  </p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p> the specified hypothesized value of the correlation
between the variables.  </p>
</td></tr> <tr><td><code>alpha</code></td>
<td>
<p> the type I error.  </p>
</td></tr> <tr><td><code>theta</code></td>
<td>

<p>the parameter that minimizes the type II error.  </p>
</td></tr> <tr><td><code>pseudoalpha</code></td>
<td>

<p><code>theta</code>*<code>alpha</code>, this is the level used when calculating the
average rejection probability during the iterations </p>
</td></tr> <tr><td><code>rejection</code></td>
<td>

<p>logical indicator for whether or not the null hypothesis can be rejected </p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p> the number of iterations that were performed.  </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Karl Schlag, Christian Pechhacker, Peter Saffert and Oliver Reiter
</p>


<h3>References</h3>

<p>Karl Schlag (2008), A New Method for Constructing Exact Tests
without Making any Assumptions. Available at
<a href="https://ideas.repec.org/p/upf/upfgen/1109.html">https://ideas.repec.org/p/upf/upfgen/1109.html</a>.
</p>


<h3>See Also</h3>

<p><a href="https://homepage.univie.ac.at/karl.schlag/statistics.php">https://homepage.univie.ac.at/karl.schlag/statistics.php</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## test whether countries with french origin score lower than
## countries with no french origin
data(french)
npMeanUnpaired(french[[1]], french[[2]], alternative = "less", ignoreNA =
TRUE)

## test whether American tend to be more generous than Isrealis
## in a round of the Ultimatum game
data(bargaining)
npMeanUnpaired(bargaining$US, bargaining$IS, lower = 0, upper = 10, ignoreNA = TRUE)

</code></pre>

<hr>
<h2 id='npStochinUnpaired'>A test of a stochastic inequality given two independent samples</h2><span id='topic+npStochinUnpaired'></span>

<h3>Description</h3>

<p>The data input consists of a sequence of independent realizations
observations of each random variable, observations of the different
sequences also being independent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>npStochinUnpaired(x1, x2, d = 0, alternative = "two.sided",
  iterations = 5000, alpha = 0.05, epsilon = 1 * 10^(-6),
  ignoreNA = FALSE, max.iterations = 100000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="npStochinUnpaired_+3A_x1">x1</code>, <code id="npStochinUnpaired_+3A_x2">x2</code></td>
<td>
<p>the (non-empty) numerical data vectors which contain the
variables to be tested.</p>
</td></tr>
<tr><td><code id="npStochinUnpaired_+3A_d">d</code></td>
<td>
<p>the maximal difference in probabilities assumed <code class="reqn">H_0 : P(X_2 &gt;
X_1) - P(X_2 &lt; X_1) &lt;= d</code>. Default is 0.</p>
</td></tr>
<tr><td><code id="npStochinUnpaired_+3A_alternative">alternative</code></td>
<td>
<p>a character string describing the alternative
hypothesis. Default is &quot;greater&quot;. If &quot;less&quot; is given, <code>x1</code> and
<code>x2</code> are switched for each other.</p>
</td></tr>
<tr><td><code id="npStochinUnpaired_+3A_iterations">iterations</code></td>
<td>
<p>the number of iterations used, should not be changed if
the exact solution should be derived.</p>
</td></tr>
<tr><td><code id="npStochinUnpaired_+3A_alpha">alpha</code></td>
<td>
<p>the type I error.</p>
</td></tr>
<tr><td><code id="npStochinUnpaired_+3A_epsilon">epsilon</code></td>
<td>
<p>the tolerance in terms of probability of the Monte Carlo
simulations.</p>
</td></tr>
<tr><td><code id="npStochinUnpaired_+3A_ignorena">ignoreNA</code></td>
<td>
<p>if <code>TRUE</code>, NA values will be omitted. Default:
<code>FALSE</code></p>
</td></tr>
<tr><td><code id="npStochinUnpaired_+3A_max.iterations">max.iterations</code></td>
<td>
<p>the maximum number of iterations that should be
carried out. This number could be increased to achieve greater accuracy in
cases where the difference between the threshold probability and theta is
small. Default: <code>10000</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given <code class="reqn">-1 &lt; d &lt; 1</code> it is a test of the null hypothesis <code class="reqn">H_0 : P(X_2
&gt; X_1) \le P(X_2 &lt; X_1) + d</code> against the alternative hypothesis <code class="reqn">H_1 :
P(X_2 &gt; X_1) &gt; P(X_2 &lt; X_1) + d</code>.
</p>
<p>The data is randomly matched into pairs and then treats them as matched
pairs. The number of pairs is equal to the number of observations in the
smaller sequence. The exact randomized test is then used to determine if
sufficiently many occurrences of <code class="reqn">x_2 &gt; x_1</code> occur when compared to how
often <code class="reqn">x_2 &lt; x_1</code> occurs, using level <code>theta</code>*<code>alpha</code>. The
matching into pairs is repeated <code>iterations</code> times. The test gives a
rejection of the average rejection probability in these iterations lies
above <code>theta</code>. If the average rejection probability lies too close to
theta then the number of iterations is increased.
</p>
<p><code>theta</code> is determined to maximize the set of differences
<code class="reqn">P(X_2&gt;X_1) - P(X_2&lt;X_1)</code> belonging to the alternative hypothesis in
which the type II error probability lies below 0.5. For more details see
the paper.
</p>


<h3>Value</h3>

<p>A list with class &quot;nphtest&quot; containing the following components:
</p>
<table>
<tr><td><code>method</code></td>
<td>
<p> a character string indicating the name and type of the test
that was performed.  </p>
</td></tr> <tr><td><code>data.name</code></td>
<td>
<p> a character string giving the
name(s) of the data.  </p>
</td></tr> <tr><td><code>alternative</code></td>
<td>
<p> a character string describing
the alternative hypothesis.  </p>
</td></tr> <tr><td><code>estimate</code></td>
<td>
<p> an estimate of <code class="reqn">P(x_2 &gt;
x_1) - P(x_2 &lt; x_1)</code>.  </p>
</td></tr> <tr><td><code>probrej</code></td>
<td>
<p> numerical estimate of the
rejection probability of the randomized test, derived by taking an average
of <code>iterations</code> realizations of the rejection probability.  </p>
</td></tr>
<tr><td><code>bounds</code></td>
<td>
<p> the lower and upper bounds of the variables.  </p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p> the specified hypothesized value of the correlation
between the variables.  </p>
</td></tr> <tr><td><code>alpha</code></td>
<td>
<p> the type I error.  </p>
</td></tr> <tr><td><code>theta</code></td>
<td>

<p>the parameter that minimizes the type II error.  </p>
</td></tr> <tr><td><code>pseudoalpha</code></td>
<td>

<p><code>theta</code>*<code>alpha</code>, this is the level used when calculating the
average rejection probability during the iterations.  </p>
</td></tr> <tr><td><code>rejection</code></td>
<td>

<p>logical indicator for whether or not the null hypothesis can be rejected.
</p>
</td></tr> <tr><td><code>iterations</code></td>
<td>
<p> the number of iterations that were performed.  </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Karl Schlag, Peter Saffert and Oliver Reiter
</p>


<h3>References</h3>

<p>Schlag, Karl H. 2008, A New Method for Constructing Exact Tests
without Making any Assumptions, Department of Economics and Business
Working Paper 1109, Universitat Pompeu Fabra. Available at
<a href="https://ideas.repec.org/p/upf/upfgen/1109.html">https://ideas.repec.org/p/upf/upfgen/1109.html</a>.
</p>


<h3>See Also</h3>

<p><a href="https://homepage.univie.ac.at/karl.schlag/statistics.php">https://homepage.univie.ac.at/karl.schlag/statistics.php</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(french)
origin &lt;- french$french.origin
rest &lt;- french$rest.of.civil
npStochinUnpaired(origin, rest, ignoreNA = TRUE)

</code></pre>

<hr>
<h2 id='npVarianceSingle'>A test for the variance of a bounded random variable based on a single
sample of iid observations.</h2><span id='topic+npVarianceSingle'></span>

<h3>Description</h3>

<p>This test requires that the user knows upper and lower bounds before
gathering the data such that the properties of the data generating process
imply that all observations will be within these bounds. The data input
consists of a sequence of observations, each being an independent
realization of the random variable. No further distributional assumptions
are made.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>npVarianceSingle(x, v, lower = 0, upper = 1,
  alternative = "two.sided", alpha = 0.05, iterations = 5000,
  epsilon = 1 * 10^(-6), ignoreNA = FALSE, max.iterations = 100000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="npVarianceSingle_+3A_x">x</code></td>
<td>
<p>a (non-empty) numeric vector of data values.</p>
</td></tr>
<tr><td><code id="npVarianceSingle_+3A_v">v</code></td>
<td>
<p>the value of the variance to be tested as <code class="reqn">H_0: Var(x) \le v</code>.</p>
</td></tr>
<tr><td><code id="npVarianceSingle_+3A_lower">lower</code>, <code id="npVarianceSingle_+3A_upper">upper</code></td>
<td>
<p>the theoretical lower and upper bounds on the data
outcomes known ex-ante before gathering the data.</p>
</td></tr>
<tr><td><code id="npVarianceSingle_+3A_alternative">alternative</code></td>
<td>
<p>a character string describing the alternative
hypothesis, can take values &quot;greater&quot;, &quot;less&quot; or &quot;two.sided&quot;</p>
</td></tr>
<tr><td><code id="npVarianceSingle_+3A_alpha">alpha</code></td>
<td>
<p>the type I error.</p>
</td></tr>
<tr><td><code id="npVarianceSingle_+3A_iterations">iterations</code></td>
<td>
<p>the number of iterations used, should not be changed if
the exact solution should be derived.</p>
</td></tr>
<tr><td><code id="npVarianceSingle_+3A_epsilon">epsilon</code></td>
<td>
<p>the tolerance in terms of probability of the Monte Carlo
simulations.</p>
</td></tr>
<tr><td><code id="npVarianceSingle_+3A_ignorena">ignoreNA</code></td>
<td>
<p>if <code>TRUE</code>, NA values will be omitted. Default:
<code>FALSE</code></p>
</td></tr>
<tr><td><code id="npVarianceSingle_+3A_max.iterations">max.iterations</code></td>
<td>
<p>the maximum number of iterations that should be
carried out. This number could be increased to achieve greater accuracy in
cases where the difference between the threshold probability and theta is
small. Default: <code>10000</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a test of the null hypothesis <code class="reqn">H_0: Var(X) \le v</code> against
<code class="reqn">H_1 : Var(X) &gt; v</code>.
</p>
<p>This test randomly matches the data into pairs, then computes for each pair
the square of the difference and continues with the resulting sequence with
half as many observations as npMeanSingle. See the cited paper for more
information.
</p>


<h3>Value</h3>

<p>A list with class &quot;nphtest&quot; containing the following components:
</p>
<table>
<tr><td><code>method</code></td>
<td>
<p> a character string indicating the name and type of the test
that was performed.  </p>
</td></tr> <tr><td><code>data.name</code></td>
<td>
<p> a character string giving the
name(s) of the data.  </p>
</td></tr> <tr><td><code>alternative</code></td>
<td>
<p> a character string describing
the alternative hypothesis.  </p>
</td></tr> <tr><td><code>estimate</code></td>
<td>
<p> the estimated mean or
difference in means depending on whether it was a one-sample test or a
two-sample test.  </p>
</td></tr> <tr><td><code>probrej</code></td>
<td>
<p> numerical estimate of the rejection
probability of the randomized test, derived by taking an average of
<code>iterations</code> realizations of the rejection probability.  </p>
</td></tr>
<tr><td><code>bounds</code></td>
<td>
<p> the lower and upper bounds of the variables.  </p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p> the specified hypothesized value of the correlation
between the variables.  </p>
</td></tr> <tr><td><code>alpha</code></td>
<td>
<p> the type I error.  </p>
</td></tr> <tr><td><code>theta</code></td>
<td>

<p>the parameter that minimizes the type II error.  </p>
</td></tr> <tr><td><code>pseudoalpha</code></td>
<td>

<p><code>theta</code>*<code>alpha</code>, this is the level used when calculating the
average rejection probability during the iterations.  </p>
</td></tr> <tr><td><code>rejection</code></td>
<td>

<p>logical indicator for whether or not the null hypothesis can be rejected.
</p>
</td></tr> <tr><td><code>iterations</code></td>
<td>
<p> the number of iterations that were performed.  </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Karl Schlag and Oliver Reiter
</p>


<h3>References</h3>

<p>Karl Schlag (2008).  Exact tests for correlation and for the
slope in simple linear regressions without making assumptions. Available at
<a href="https://ideas.repec.org/p/upf/upfgen/1097.html">https://ideas.repec.org/p/upf/upfgen/1097.html</a>.
</p>


<h3>See Also</h3>

<p><a href="https://homepage.univie.ac.at/karl.schlag/statistics.php">https://homepage.univie.ac.at/karl.schlag/statistics.php</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## see if the minority share holder shores have a variance greater
## than 0.05
data(mshscores)
scores &lt;- unlist(mshscores)
npVarianceSingle(scores, lower = 0, upper = 1, v = 0.05, ignoreNA = TRUE)

</code></pre>

<hr>
<h2 id='pain'>Pain experienced before and after a knie operation</h2><span id='topic+pain'></span>

<h3>Description</h3>

<p>There are two ways to determine where to start an operation
on a knee, either with a computer or manually. The data
describes the pain experienced by the patients before and
after the surgery.
</p>


<h3>Format</h3>

<p>A dataframe containing 50 observations. Column &quot;pc&quot;
indicates if a computer was used (coded with &quot;1&quot;) or not
(coded with &quot;0&quot;)</p>


<h3>References</h3>

<p>Sabeti-Aschraf, M., Dorotka, R., Goll, A., &amp;
Trieb, K. (2005). Extracorporeal shock wave therapy in
the treatment of calcific tendinitis of the rotator cuff.
The American journal of sports medicine, 33(9),
1365-1368.
</p>

<hr>
<h2 id='uncertainty'>Uncertainty in a game theoretical experiment.</h2><span id='topic+uncertainty'></span>

<h3>Description</h3>

<p>In an experiment, subjects played a similar game twice.
Choices could be between 110 and 170. Each time, before they
made their own choice, they had to indicate an interval [L,
U] that they believed would contain the choice of their
opponent. They paid some additional money if the choice of
their opponent was in the interval they specified, and were
paid more the smaller this interval was. So the width W_i of
this interval in round i gives an indication of how uncertain
they are in round i. The data contains the interval width in
round 1 and 2 which makes this a sample of matched pairs.
</p>


<h3>Format</h3>

<p>A dataframe containing the 25 intervals in each round
of the game.</p>


<h3>References</h3>

<p>Galbiati, R., Schlag, K., &amp; van der Weele, J.
Sanctions that Signal: an Experiment. Journal of Economic
Behavior and Organization, Forthcoming
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
