<!DOCTYPE html><html><head><title>Help for package LncFinder</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {LncFinder}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#build_model'><p>Build Users' Own Model</p></a></li>
<li><a href='#compute_EIIP'><p>Extract the EIIP-derived features</p></a></li>
<li><a href='#compute_EucDistance'><p>Compute Euclidean Distance</p></a></li>
<li><a href='#compute_FickettScore'><p>Compute Fickett TESTCODE Score</p></a></li>
<li><a href='#compute_GC'><p>Calculate GC content</p></a></li>
<li><a href='#compute_hexamerScore'><p>Compute Hexamer Score</p></a></li>
<li><a href='#compute_kmer'><p>Compute <em>k</em>-mer Features</p></a></li>
<li><a href='#compute_LogDistance'><p>Compute Logarithm Distance</p></a></li>
<li><a href='#compute_pI'><p>Compute Theoretical Isoelectric Point</p></a></li>
<li><a href='#demo_dataset'><p>A demo of dataset</p></a></li>
<li><a href='#demo_DNA.seq'><p>A demo of DNA sequences</p></a></li>
<li><a href='#demo_SS.seq'><p>A demo of secondary structure sequences</p></a></li>
<li><a href='#extract_features'><p>Extract the Features</p></a></li>
<li><a href='#find_orfs'><p>Find ORFs</p></a></li>
<li><a href='#lnc_finder'><p>Long Non-coding RNA Identification</p></a></li>
<li><a href='#make_frequencies'><p>Make the frequencies file for new classifier construction</p></a></li>
<li><a href='#make_referFreq'><p>Make Frequencies File for Log.Dist, Euc.Dist, and hexamer score</p></a></li>
<li><a href='#read_SS'><p>Read Secondary Structure Information</p></a></li>
<li><a href='#run_RNAfold'><p>Obtain the Secondary Structure Sequences Using RNAfold</p></a></li>
<li><a href='#svm_cv'><p><em>k</em>-fold Cross Validation for SVM</p></a></li>
<li><a href='#svm_tune'><p>Parameter Tuning of SVM</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>LncRNA Identification and Analysis Using Heterologous Features</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.5</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Siyu HAN &lt;hansy15@mails.jlu.edu.cn&gt;</td>
</tr>
<tr>
<td>Acknowledgments:</td>
<td>CHENG Ming, FAN Linrui, GUO Yuan, LI Yaolong, SUN
Ying, WANG Ruoyu</td>
</tr>
<tr>
<td>Description:</td>
<td>Long non-coding RNAs identification and analysis. Default models are trained with human, mouse and wheat datasets by employing SVM. Features are based on intrinsic composition of sequence, EIIP value (electron-ion interaction pseudopotential), and secondary structure. This package can also extract other classic features and build new classifiers. Reference: Han SY., Liang YC., Li Y., et al. (2018) &lt;<a href="https://doi.org/10.1093%2Fbib%2Fbby065">doi:10.1093/bib/bby065</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://bmbl.bmi.osumc.edu/lncfinder/">https://bmbl.bmi.osumc.edu/lncfinder/</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>seqinr (&ge; 2.1-3), e1071 (&ge; 1.0), parallel (&ge; 2.1.0), caret
(&ge; 6.0-71),</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-12-09 16:11:28 UTC; siyu.han</td>
</tr>
<tr>
<td>Author:</td>
<td>Siyu HAN [aut, cre],
  Ying LI [aut],
  Yanchun LIANG [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-12-09 17:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='build_model'>Build Users' Own Model</h2><span id='topic+build_model'></span>

<h3>Description</h3>

<p>This function is used to build new models with users' own data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_model(
  lncRNA.seq,
  mRNA.seq,
  frequencies.file,
  SS.features = FALSE,
  lncRNA.format = "DNA",
  mRNA.format = "DNA",
  parallel.cores = 2,
  folds.num = 10,
  seed = 1,
  gamma.range = (2^seq(-5, 0, 1)),
  cost.range = c(1, 4, 8, 16, 24, 32),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_model_+3A_lncrna.seq">lncRNA.seq</code></td>
<td>
<p>Long non-coding sequences. Can be a FASTA file loaded by
<code><a href="seqinr.html#topic+seqinr-package">seqinr-package</a></code> or secondary structure
sequences file (Dot-Bracket Notation) obtained from function
<code><a href="#topic+run_RNAfold">run_RNAfold</a></code>. If <code>lncRNA.seq</code> is secondary structure
sequences file, parameter <code>lncRNA.format</code> should be defined as <code>"SS"</code>.</p>
</td></tr>
<tr><td><code id="build_model_+3A_mrna.seq">mRNA.seq</code></td>
<td>
<p>mRNA sequences. FASTA file loaded by <code><a href="seqinr.html#topic+read.fasta">read.fasta</a></code> or
secondary structure sequences (Dot-Bracket Notation) obtained from function
<code><a href="#topic+run_RNAfold">run_RNAfold</a></code>. If <code>mRNA.seq</code> is secondary structure sequences
file, parameter <code>mRNA.format</code> should be defined as <code>"SS"</code>.</p>
</td></tr>
<tr><td><code id="build_model_+3A_frequencies.file">frequencies.file</code></td>
<td>
<p>String or a list obtained from function
<code><a href="#topic+make_frequencies">make_frequencies</a></code>. Input species name <code>"human"</code>,
<code>"mouse"</code> or <code>"wheat"</code> to use pre-build frequencies files. Or assign
a users' own frequencies file (Please refer to function
<code><a href="#topic+make_frequencies">make_frequencies</a></code> for more information).</p>
</td></tr>
<tr><td><code id="build_model_+3A_ss.features">SS.features</code></td>
<td>
<p>Logical. If <code>SS.features = TRUE</code>, secondary structure
features will be used to build the model. In this case, <code>lncRNA.seq</code> and
<code>mRNA.seq</code> should be secondary structure sequences (Dot-Bracket Notation)
obtained from function <code><a href="#topic+run_RNAfold">run_RNAfold</a></code> and parameter
<code>lncRNA.format</code> and <code>mRNA.format</code> should be set as <code>"SS"</code>.</p>
</td></tr>
<tr><td><code id="build_model_+3A_lncrna.format">lncRNA.format</code></td>
<td>
<p>String. Define the format of <code>lncRNA.seq</code>. <code>"DNA"</code>
for DNA sequences and <code>"SS"</code> for secondary structure sequences. Only when
both <code>mRNA.format</code> and <code>lncRNA.format</code> are set as <code>"SS"</code>, can
the model with secondary structure features be built (<code>SS.features = TRUE</code>).</p>
</td></tr>
<tr><td><code id="build_model_+3A_mrna.format">mRNA.format</code></td>
<td>
<p>String. Define the format of <code>mRNA.seq</code>. Can be
<code>"DNA"</code> or <code>"SS"</code>. <code>"DNA"</code> for DNA sequences and <code>"SS"</code>
for secondary structure sequences. When this parameter is defined as <code>"DNA"</code>,
only the model without secondary structure features can be built. In this case,
parameter <code>SS.features</code> should be set as <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="build_model_+3A_parallel.cores">parallel.cores</code></td>
<td>
<p>Integer. The number of cores for parallel computation.
By default the number of cores is <code>2</code>, users can set as <code>-1</code> to run
this function with all cores. During the process of svm tuning, if the number
of <code>parallel.cores</code> is more than the <code>folds.num</code> (number of the folds
for cross-validation), the number of <code>parallel.cores</code> will be set as
<code>folds.num</code> automatically.</p>
</td></tr>
<tr><td><code id="build_model_+3A_folds.num">folds.num</code></td>
<td>
<p>Integer. Specify the number of folds for cross-validation.
(Default: <code>10</code>)</p>
</td></tr>
<tr><td><code id="build_model_+3A_seed">seed</code></td>
<td>
<p>Integer. Used to set the seed for cross-validation. (Default: <code>1</code>)</p>
</td></tr>
<tr><td><code id="build_model_+3A_gamma.range">gamma.range</code></td>
<td>
<p>The range of gamma. (Default: <code>2 ^ seq(-5, 0, 1)</code>)</p>
</td></tr>
<tr><td><code id="build_model_+3A_cost.range">cost.range</code></td>
<td>
<p>The range of cost. (Default: <code>c(1, 4, 8, 16, 24, 32)</code>)</p>
</td></tr>
<tr><td><code id="build_model_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to function <code><a href="#topic+svm_tune">svm_tune</a></code> for customised SVM model training.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to build a new model with users' own sequences.
Users can use function <code><a href="#topic+lnc_finder">lnc_finder</a></code> to predict the sequences with
new models.
</p>
<p>For the details of <code>frequencies.file</code>, please refer to function
<code><a href="#topic+make_frequencies">make_frequencies</a></code>.
</p>
<p>For the details of the features, please refer to function
<code><a href="#topic+extract_features">extract_features</a></code>.
</p>
<p>For the details of svm tuning, please refer to function <code><a href="#topic+svm_tune">svm_tune</a></code>.
</p>


<h3>Value</h3>

<p>Returns a svm model.
</p>


<h3>References</h3>

<p>Siyu Han, Yanchun Liang, Qin Ma, Yangyi Xu, Yu Zhang, Wei Du, Cankun Wang &amp; Ying Li.
LncFinder: an integrated platform for long non-coding RNA identification utilizing
sequence intrinsic composition, structural information, and physicochemical property.
<em>Briefings in Bioinformatics</em>, 2019, 20(6):2009-2027.
</p>


<h3>Author(s)</h3>

<p>HAN Siyu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_frequencies">make_frequencies</a></code>, <code><a href="#topic+lnc_finder">lnc_finder</a></code>,
<code><a href="#topic+extract_features">extract_features</a></code>, <code><a href="#topic+svm_tune">svm_tune</a></code>,
<code><a href="e1071.html#topic+svm">svm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(demo_DNA.seq)
Seqs &lt;- demo_DNA.seq

### Build the model with pre-build frequencies.file:
my_model &lt;- build_model(lncRNA.seq = Seqs[1:5], mRNA.seq = Seqs[6:10],
                        frequencies.file = "human", SS.features = FALSE,
                        lncRNA.format = "DNA", mRNA.format = "DNA",
                        parallel.cores = 2, folds.num = 2, seed = 1,
                        gamma.range = (2 ^ seq(-5, -1, 2)),
                        cost.range = c(2, 6, 12, 20))

### Users can use default values of gamma.range and cost.range to find the
best parameters.
### Use your own frequencies file by assigning frequencies list to parameter
### "frequencies.file".

## End(Not run)
</code></pre>

<hr>
<h2 id='compute_EIIP'>Extract the EIIP-derived features</h2><span id='topic+compute_EIIP'></span>

<h3>Description</h3>

<p>This function can extract EIIP-derived features proposed by Han et al (2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_EIIP(
  Sequences,
  label = NULL,
  spectrum.percent = 0.1,
  quantile.probs = seq(0, 1, 0.25)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_EIIP_+3A_sequences">Sequences</code></td>
<td>
<p>A FASTA file loaded by function  <code><a href="seqinr.html#topic+read.fasta">read.fasta</a></code> of
<code><a href="seqinr.html#topic+seqinr-package">seqinr-package</a></code>.</p>
</td></tr>
<tr><td><code id="compute_EIIP_+3A_label">label</code></td>
<td>
<p>Optional. String. Indicate the label of the sequences such as
&quot;NonCoding&quot;, &quot;Coding&quot;.</p>
</td></tr>
<tr><td><code id="compute_EIIP_+3A_spectrum.percent">spectrum.percent</code></td>
<td>
<p>Numeric specifying the percentage of the sorted power spectrum that be
used to calculate the quantile-based features. For example, if <code>spectrum.percent = 0.1</code>,
the top 10% percent of the sorted power spectrum will be used to compute the quantiles.</p>
</td></tr>
<tr><td><code id="compute_EIIP_+3A_quantile.probs">quantile.probs</code></td>
<td>
<p>Numeric. The probabilities with values in [0,1].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>compute_EIIP</code> can extract EIIP (electron-ion interaction pseudo-potential) features including:
signal at 1/3 position (<code>Signal.Peak</code>), average power (<code>Average.Power</code>), signal to noise ratio (<code>SNR</code>),
and quantile-based features of one specified percentage of the sorted power spectrum
(e.g. <code>0%</code>, <code>20%</code>, <code>40%</code>, <code>60%</code>, <code>70%</code>,
<code>100%</code> when <code>quantile.probs = seq(0, 1, 0.2)</code> and <code>spectrum.percent =</code> <code>0.1</code>).
</p>
<p>In method LncFinder, EIIP features includes <code>Signal.Peak</code>, <code>SNR</code>, 0% (<code>Signal.Min</code>),
25% (<code>Singal.Q1</code>, 50% <code>Signal.Q2</code>), and 75% (<code>Signal.Max</code>) of the top 10% sorted
power spectrum, i.e. <code>quantile.prob</code> <code>= seq(0, 1, 0.25)</code> and <code>spectrum.percent = 0.1</code>.
</p>


<h3>Value</h3>

<p>A dataframe including the EIIP-derived features.
</p>


<h3>References</h3>

<p>Siyu Han, Yanchun Liang, Qin Ma, Yangyi Xu, Yu Zhang, Wei Du, Cankun Wang &amp; Ying Li.
LncFinder: an integrated platform for long non-coding RNA identification utilizing
sequence intrinsic composition, structural information, and physicochemical property.
<em>Briefings in Bioinformatics</em>, 2019, 20(6):2009-2027.
</p>
<p>Lalović, Dragutin, and Veljko Veljković.
The global average DNA base composition of coding regions may be determined by the electron-ion interaction potential.
<em>Biosystems</em>, 1990, 23(4):311-316.
</p>
<p>Achuthsankar S Nair &amp; Sivarama Pillai Sreenadhan.
A coding measure scheme employing electron-ion interaction pseudopotential (EIIP).
<em>Bioinformation</em>, 2006, 1(6):197-202.
</p>


<h3>Author(s)</h3>

<p>HAN Siyu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extract_features">extract_features</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(demo_DNA.seq)
Seqs &lt;- demo_DNA.seq

EIIP_res &lt;- compute_EIIP(Seqs, label = "NonCoding", spectrum.percent = 0.25,
                         quantile.probs = seq(0, 1, 0.25))

</code></pre>

<hr>
<h2 id='compute_EucDistance'>Compute Euclidean Distance</h2><span id='topic+compute_EucDistance'></span>

<h3>Description</h3>

<p>This function can compute Euclidean Distance proposed by method LncFinder
(Han et al. 2018). Euclidean Distance can be calculated on full sequence or the longest ORF
region. The step and <em>k</em> of the sliding window can also be customized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_EucDistance(
  Sequences,
  label = NULL,
  referFreq,
  k = 6,
  step = 1,
  alphabet = c("a", "c", "g", "t"),
  on.ORF = FALSE,
  auto.full = FALSE,
  parallel.cores = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_EucDistance_+3A_sequences">Sequences</code></td>
<td>
<p>A FASTA file loaded by function  <code><a href="seqinr.html#topic+read.fasta">read.fasta</a></code> of
<code><a href="seqinr.html#topic+seqinr-package">seqinr-package</a></code>.</p>
</td></tr>
<tr><td><code id="compute_EucDistance_+3A_label">label</code></td>
<td>
<p>Optional. String. Indicate the label of the sequences such as
&quot;NonCoding&quot;, &quot;Coding&quot;.</p>
</td></tr>
<tr><td><code id="compute_EucDistance_+3A_referfreq">referFreq</code></td>
<td>
<p>a list obtained from function <code><a href="#topic+make_referFreq">make_referFreq</a></code>.</p>
</td></tr>
<tr><td><code id="compute_EucDistance_+3A_k">k</code></td>
<td>
<p>An integer that indicates the sliding window size. (Default: <code>6</code>)</p>
</td></tr>
<tr><td><code id="compute_EucDistance_+3A_step">step</code></td>
<td>
<p>Integer defaulting to <code>1</code> for the window step.</p>
</td></tr>
<tr><td><code id="compute_EucDistance_+3A_alphabet">alphabet</code></td>
<td>
<p>A vector of single characters that specify the different character
of the sequence. (Default: <code>alphabet = c("a", "c", "g", "t")</code>)</p>
</td></tr>
<tr><td><code id="compute_EucDistance_+3A_on.orf">on.ORF</code></td>
<td>
<p>Logical. If <code>TRUE</code>, Euclidean Distance will be calculated on
the longest ORF region. NOTE: If <code>TRUE</code>, the input has to be DNA sequences.
(Default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="compute_EucDistance_+3A_auto.full">auto.full</code></td>
<td>
<p>Logical. When <code>on.ORF = TRUE</code> but no ORF can be found,
if <code>auto.full = TRUE</code>, Euclidean Distance will be calculated on full sequences automatically;
if <code>auto.full</code> is <code>FALSE</code>, the sequences that have no ORF will be discarded. Ignored when <code>on.ORF = FALSE</code>.
(Default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="compute_EucDistance_+3A_parallel.cores">parallel.cores</code></td>
<td>
<p>Integer. The number of cores for parallel computation.
By default the number of cores is <code>2</code>. Users can set as <code>-1</code> to run
this function with all cores.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can compute Euclidean Distance proposed by LncFinder (HAN et al. 2018).
In LncFinder, two schemes are provided to calculate Euclidean Distance:
1) <code>step = 3</code> and <code>k = 6</code> on the longest ORF region;
2) <code>step = 1</code> and <code>k = 6</code> on full sequence.
Using this function <code>compute_EucDistance</code>, both <code>step</code>, <code>k</code>,
and calculated region (full sequence or ORF)
can be customized to maximize its availability.
</p>


<h3>Value</h3>

<p>A dataframe.
</p>


<h3>References</h3>

<p>Siyu Han, Yanchun Liang, Qin Ma, Yangyi Xu, Yu Zhang, Wei Du, Cankun Wang &amp; Ying Li.
LncFinder: an integrated platform for long non-coding RNA identification utilizing
sequence intrinsic composition, structural information, and physicochemical property.
<em>Briefings in Bioinformatics</em>, 2019, 20(6):2009-2027.
</p>


<h3>Author(s)</h3>

<p>HAN Siyu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_referFreq">make_referFreq</a></code>,
<code><a href="#topic+compute_LogDistance">compute_LogDistance</a></code>,
<code><a href="#topic+compute_hexamerScore">compute_hexamerScore</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
Seqs &lt;- seqinr::read.fasta(file =
"http://www.ncbi.nlm.nih.gov/WebSub/html/help/sample_files/nucleotide-sample.txt")

referFreq &lt;- make_referFreq(cds.seq = Seqs, lncRNA.seq = Seqs, k = 6, step = 3,
                            alphabet = c("a", "c", "g", "t"), on.orf = TRUE,
                            ignore.illegal = TRUE)

data(demo_DNA.seq)
Sequences &lt;- demo_DNA.seq

EucDistance &lt;- compute_EucDistance(Sequences, label = "NonCoding", referFreq = referFreq,
                                   k = 6, step = 3, alphabet = c("a", "c", "g", "t"),
                                   on.ORF = TRUE, auto.full = TRUE, parallel.cores = 2)

## End(Not run)

</code></pre>

<hr>
<h2 id='compute_FickettScore'>Compute Fickett TESTCODE Score</h2><span id='topic+compute_FickettScore'></span>

<h3>Description</h3>

<p>This function can compute Fickett TESTCODE score of DNA sequences proposed by James W.Fickett
(Fickett JW. 1982). Fickett TESTCODE score can be calculated on full sequence or the longest ORF
region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_FickettScore(
  Sequences,
  label = NULL,
  on.ORF = FALSE,
  auto.full = FALSE,
  parallel.cores = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_FickettScore_+3A_sequences">Sequences</code></td>
<td>
<p>A FASTA file loaded by function  <code><a href="seqinr.html#topic+read.fasta">read.fasta</a></code> of
<code><a href="seqinr.html#topic+seqinr-package">seqinr-package</a></code>.</p>
</td></tr>
<tr><td><code id="compute_FickettScore_+3A_label">label</code></td>
<td>
<p>Optional. String. Indicate the label of the sequences such as
&quot;NonCoding&quot;, &quot;Coding&quot;.</p>
</td></tr>
<tr><td><code id="compute_FickettScore_+3A_on.orf">on.ORF</code></td>
<td>
<p>Logical. If <code>TRUE</code>, Fickett TESTCODE score will be calculated on
the longest ORF region.</p>
</td></tr>
<tr><td><code id="compute_FickettScore_+3A_auto.full">auto.full</code></td>
<td>
<p>Logical. When <code>on.ORF = TRUE</code> but no ORF can be found,
if <code>auto.full = TRUE</code>,  Fickett TESTCODE score will be calculated on full sequences automatically;
if <code>auto.full</code> is <code>FALSE</code>, the sequences that have no ORF will be discarded.
Ignored when <code>on.ORF = FALSE</code>. (Default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="compute_FickettScore_+3A_parallel.cores">parallel.cores</code></td>
<td>
<p>Integer. The number of cores for parallel computation.
By default the number of cores is <code>2</code>. Users can set as <code>-1</code> to run
this function with all cores.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can compute Fickett TESTCODE score proposed by James W.Fickett (Fickett JW. 1982).
Fickett TESTCODE score is selected as feature by method CPAT (Wang et al. 2013) and CPC2 (Kang et al. 2017).
In CPAT, Fickett TESTCODE score is calculated on the longest ORF region, but CPC2 calculates the score
on full sequence. This function <code>compute_FickettScore</code> improves the CPAT's code
and is capable of computing the score on the longest ORF region as well as full sequence.
</p>


<h3>Value</h3>

<p>A dataframe.
</p>


<h3>References</h3>

<p>James W.Fickett.
Recognition of protein coding regions in DNA sequences.
<em>Nucleic Acids Research</em>, 1982, 10(17):5303-5318.
</p>
<p>Siyu Han, Yanchun Liang, Qin Ma, Yangyi Xu, Yu Zhang, Wei Du, Cankun Wang &amp; Ying Li.
LncFinder: an integrated platform for long non-coding RNA identification utilizing
sequence intrinsic composition, structural information, and physicochemical property.
<em>Briefings in Bioinformatics</em>, 2019, 20(6):2009-2027.
</p>
<p>Liguo Wang, Hyun Jung Park, Surendra Dasari, Shengqin Wang, JeanPierre Kocher &amp; Wei Li.
CPAT: coding-potential assessment tool using an alignment-free logistic regression model.
<em>Nucleic Acids Research</em>, 2013, 41(6):e74-e74.
</p>
<p>Yu-Jian Kang, De-Chang Yang, Lei Kong, Mei Hou, Yu-Qi Meng, Liping Wei &amp; Ge Gao.
CPC2: a fast and accurate coding potential calculator based on sequence intrinsic features.
<em>Nucleic Acids Research</em>, 2017, 45(W1):W12-W16.
</p>


<h3>Author(s)</h3>

<p>HAN Siyu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(demo_DNA.seq)
Seqs &lt;- demo_DNA.seq

FickettScore &lt;- compute_FickettScore(Seqs, label = NULL, on.ORF = TRUE,
                                     auto.full = TRUE, parallel.cores = 2)

## End(Not run)
</code></pre>

<hr>
<h2 id='compute_GC'>Calculate GC content</h2><span id='topic+compute_GC'></span>

<h3>Description</h3>

<p>This function can GC content of the input sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_GC(
  Sequences,
  label = NULL,
  on.ORF = FALSE,
  auto.full = FALSE,
  parallel.cores = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_GC_+3A_sequences">Sequences</code></td>
<td>
<p>A FASTA file loaded by function  <code><a href="seqinr.html#topic+read.fasta">read.fasta</a></code> of
<code><a href="seqinr.html#topic+seqinr-package">seqinr-package</a></code>.</p>
</td></tr>
<tr><td><code id="compute_GC_+3A_label">label</code></td>
<td>
<p>Optional. String. Indicate the label of the sequences such as
&quot;NonCoding&quot;, &quot;Coding&quot;.</p>
</td></tr>
<tr><td><code id="compute_GC_+3A_on.orf">on.ORF</code></td>
<td>
<p>Logical. If <code>TRUE</code>, GC content will be calculated on
the longest ORF region.</p>
</td></tr>
<tr><td><code id="compute_GC_+3A_auto.full">auto.full</code></td>
<td>
<p>Logical. When <code>on.ORF = TRUE</code> but no ORF can be found,
if <code>auto.full = TRUE</code>,  GC content will be calculated on full sequences automatically;
if <code>auto.full</code> is <code>FALSE</code>, the sequences that have no ORF will be discarded.
Ignored when <code>on.ORF = FALSE</code>. (Default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="compute_GC_+3A_parallel.cores">parallel.cores</code></td>
<td>
<p>Integer. The number of cores for parallel computation.
By default the number of cores is <code>2</code>. Users can set as <code>-1</code> to run
this function with all cores.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can basically compute GC content of DNA sequences:
GC content = (nc + ng) / (na + nc + ng + nt).
The function will ignored the ambiguous bases.
</p>


<h3>Value</h3>

<p>A dataframe.
</p>


<h3>Author(s)</h3>

<p>HAN Siyu
</p>


<h3>See Also</h3>

<p><code><a href="seqinr.html#topic+GC">GC</a></code> (package &quot;<code><a href="seqinr.html#topic+seqinr-package">seqinr-package</a></code>&quot;)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(demo_DNA.seq)
Seqs &lt;- demo_DNA.seq

gcContent &lt;- compute_GC(Seqs, label = "NonCoding",on.ORF = TRUE,
                        auto.full = TRUE, parallel.cores = 2)

## End(Not run)
</code></pre>

<hr>
<h2 id='compute_hexamerScore'>Compute Hexamer Score</h2><span id='topic+compute_hexamerScore'></span>

<h3>Description</h3>

<p>This function can compute hexamer score proposed by method CPAT
(Wang et al. 2013). Hexamer score can be calculated on full sequence or the longest ORF
region. The step and <em>k</em> of the sliding window can also be customized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_hexamerScore(
  Sequences,
  label = NULL,
  referFreq,
  k = 6,
  step = 1,
  alphabet = c("a", "c", "g", "t"),
  on.ORF = FALSE,
  auto.full = FALSE,
  parallel.cores = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_hexamerScore_+3A_sequences">Sequences</code></td>
<td>
<p>A FASTA file loaded by function  <code><a href="seqinr.html#topic+read.fasta">read.fasta</a></code> of
<code><a href="seqinr.html#topic+seqinr-package">seqinr-package</a></code>.</p>
</td></tr>
<tr><td><code id="compute_hexamerScore_+3A_label">label</code></td>
<td>
<p>Optional. String. Indicate the label of the sequences such as
&quot;NonCoding&quot;, &quot;Coding&quot;.</p>
</td></tr>
<tr><td><code id="compute_hexamerScore_+3A_referfreq">referFreq</code></td>
<td>
<p>A list obtained from function <code><a href="#topic+make_referFreq">make_referFreq</a></code>.</p>
</td></tr>
<tr><td><code id="compute_hexamerScore_+3A_k">k</code></td>
<td>
<p>An integer that indicates the sliding window size. (Default: <code>6</code>)</p>
</td></tr>
<tr><td><code id="compute_hexamerScore_+3A_step">step</code></td>
<td>
<p>Integer defaulting to <code>1</code> for the window step.</p>
</td></tr>
<tr><td><code id="compute_hexamerScore_+3A_alphabet">alphabet</code></td>
<td>
<p>A vector of single characters that specify the different character
of the sequence. (Default: <code>alphabet = c("a", "c", "g", "t")</code>)</p>
</td></tr>
<tr><td><code id="compute_hexamerScore_+3A_on.orf">on.ORF</code></td>
<td>
<p>Logical. If <code>TRUE</code>, hexamer score will be calculated on
the longest ORF region. NOTE: If <code>TRUE</code>, the input has to be DNA sequences.
(Default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="compute_hexamerScore_+3A_auto.full">auto.full</code></td>
<td>
<p>Logical. When <code>on.ORF = TRUE</code> but no ORF can be found,
if <code>auto.full = TRUE</code>,  hexamer score will be calculated on full sequences automatically;
if <code>auto.full</code> is <code>FALSE</code>, the sequences that have no ORF will be discarded. Ignored when <code>on.ORF = FALSE</code>.
(Default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="compute_hexamerScore_+3A_parallel.cores">parallel.cores</code></td>
<td>
<p>Integer. The number of cores for parallel computation.
By default the number of cores is <code>2</code>. Users can set as <code>-1</code> to run
this function with all cores.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can compute hexamer score proposed by CPAT (Wang et al. 2013).
In CPAT, hexamer score is calculated on the longest ORF region, and the step of the
sliding window is 3 (i.e. <code>step = 3</code>). Hexamer means six adjoining bases, thus
<code>k = 6</code>. But in function <code>compute_hexamerScore</code>, both <code>step</code>, <code>k</code>,
and calculated region (full sequence or ORF)
can be customized to maximize its availability.
</p>


<h3>Value</h3>

<p>A dataframe.
</p>


<h3>References</h3>

<p>Liguo Wang, Hyun Jung Park, Surendra Dasari, Shengqin Wang, JeanPierre Kocher, &amp; Wei Li.
CPAT: coding-potential assessment tool using an alignment-free logistic regression model.
<em>Nucleic Acids Research</em>, 2013, 41(6):e74-e74.
</p>
<p>Siyu Han, Yanchun Liang, Qin Ma, Yangyi Xu, Yu Zhang, Wei Du, Cankun Wang &amp; Ying Li.
LncFinder: an integrated platform for long non-coding RNA identification utilizing
sequence intrinsic composition, structural information, and physicochemical property.
<em>Briefings in Bioinformatics</em>, 2019, 20(6):2009-2027.
</p>


<h3>Author(s)</h3>

<p>HAN Siyu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_referFreq">make_referFreq</a></code>,
<code><a href="#topic+compute_LogDistance">compute_LogDistance</a></code>,
<code><a href="#topic+compute_EucDistance">compute_EucDistance</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
Seqs &lt;- seqinr::read.fasta(file =
"http://www.ncbi.nlm.nih.gov/WebSub/html/help/sample_files/nucleotide-sample.txt")

referFreq &lt;- make_referFreq(cds.seq = Seqs, lncRNA.seq = Seqs, k = 6, step = 1,
                            alphabet = c("a", "c", "g", "t"), on.orf = TRUE,
                            ignore.illegal = TRUE)

data(demo_DNA.seq)
Sequences &lt;- demo_DNA.seq

hexamerScore &lt;- compute_hexamerScore(Sequences, label = "NonCoding", referFreq = referFreq,
                                     k = 6, step = 1, alphabet = c("a", "c", "g", "t"),
                                     on.ORF = TRUE, auto.full = TRUE, parallel.cores = 2)

## End(Not run)

</code></pre>

<hr>
<h2 id='compute_kmer'>Compute <em>k</em>-mer Features</h2><span id='topic+compute_kmer'></span>

<h3>Description</h3>

<p>This function can calculate the <em>k</em>-mer frequencies of the sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_kmer(
  Sequences,
  label = NULL,
  k = 1:5,
  step = 1,
  freq = TRUE,
  improved.mode = FALSE,
  alphabet = c("a", "c", "g", "t"),
  on.ORF = FALSE,
  auto.full = FALSE,
  parallel.cores = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_kmer_+3A_sequences">Sequences</code></td>
<td>
<p>A FASTA file loaded by function  <code><a href="seqinr.html#topic+read.fasta">read.fasta</a></code> of
<code><a href="seqinr.html#topic+seqinr-package">seqinr-package</a></code>.</p>
</td></tr>
<tr><td><code id="compute_kmer_+3A_label">label</code></td>
<td>
<p>Optional. String. Indicate the label of the sequences such as
&quot;NonCoding&quot;, &quot;Coding&quot;.</p>
</td></tr>
<tr><td><code id="compute_kmer_+3A_k">k</code></td>
<td>
<p>An integer that indicates the sliding window size. (Default: <code>1:5</code>)</p>
</td></tr>
<tr><td><code id="compute_kmer_+3A_step">step</code></td>
<td>
<p>Integer defaulting to <code>1</code> for the window step.</p>
</td></tr>
<tr><td><code id="compute_kmer_+3A_freq">freq</code></td>
<td>
<p>Logical. If TRUE, the frequencies of different patterns are returned
instead of counts. (Default: <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="compute_kmer_+3A_improved.mode">improved.mode</code></td>
<td>
<p>Logical. If TRUE, the frequencies will be normalized using
the method proposed by PLEK (Li et al. 2014).
Ignored if <code>freq = FALSE</code>. (Default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="compute_kmer_+3A_alphabet">alphabet</code></td>
<td>
<p>A vector of single characters that specify the different character
of the sequence. (Default: <code>alphabet = c("a", "c", "g", "t")</code>)</p>
</td></tr>
<tr><td><code id="compute_kmer_+3A_on.orf">on.ORF</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the <em>k</em>-mer frequencies will be calculated on
the longest ORF region. NOTE: If <code>TRUE</code>, the sequences have to be DNA.
(Default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="compute_kmer_+3A_auto.full">auto.full</code></td>
<td>
<p>Logical. When <code>on.ORF = TRUE</code> but no ORF can be found,
if <code>auto.full = TRUE</code>, the <em>k</em>-mer
frequencies will be calculated on the full sequence automatically;
if <code>auto.full</code> is <code>FALSE</code>, the sequences that have no ORF will be discarded.
Ignored when <code>on.ORF = FALSE</code>. (Default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="compute_kmer_+3A_parallel.cores">parallel.cores</code></td>
<td>
<p>Integer. The number of cores for parallel computation.
By default the number of cores is <code>2</code>. Users can set as <code>-1</code> to run
this function with all cores.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can extract <em>k</em>-mer features. <code>k</code> and <code>step</code> can be customized.
The count (<code>freq = FALSE</code>) or frequencies (<code>freq = TRUE</code>) of different patterns can be returned.
If <code>freq = TRUE</code>, <code>improved.mode</code> is available. The improved mode is proposed by method PLEK.
(Ref: Li et al. 2014)
</p>


<h3>Value</h3>

<p>A dataframe.
</p>


<h3>Author(s)</h3>

<p>HAN Siyu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(demo_DNA.seq)
Seqs &lt;- demo_DNA.seq

kmer_res1 &lt;- compute_kmer(Seqs, k = 1:5, step = 1, freq = TRUE, improved.mode = FALSE)

kmer_res2 &lt;- compute_kmer(Seqs, k = 1:5, step = 3, freq = TRUE,
                          improved.mode = TRUE, on.ORF = TRUE, auto.full = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='compute_LogDistance'>Compute Logarithm Distance</h2><span id='topic+compute_LogDistance'></span>

<h3>Description</h3>

<p>This function can compute Logarithm Distance proposed by method LncFinder
(Han et al. 2018). Logarithm Distance can be calculated on full sequence or the longest ORF
region. The step and <em>k</em> of the sliding window can also be customized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_LogDistance(
  Sequences,
  label = NULL,
  referFreq,
  k = 6,
  step = 1,
  alphabet = c("a", "c", "g", "t"),
  on.ORF = FALSE,
  auto.full = FALSE,
  parallel.cores = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_LogDistance_+3A_sequences">Sequences</code></td>
<td>
<p>A FASTA file loaded by function  <code><a href="seqinr.html#topic+read.fasta">read.fasta</a></code> of
<code><a href="seqinr.html#topic+seqinr-package">seqinr-package</a></code>.</p>
</td></tr>
<tr><td><code id="compute_LogDistance_+3A_label">label</code></td>
<td>
<p>Optional. String. Indicate the label of the sequences such as
&quot;NonCoding&quot;, &quot;Coding&quot;.</p>
</td></tr>
<tr><td><code id="compute_LogDistance_+3A_referfreq">referFreq</code></td>
<td>
<p>a list obtained from function <code><a href="#topic+make_referFreq">make_referFreq</a></code>.</p>
</td></tr>
<tr><td><code id="compute_LogDistance_+3A_k">k</code></td>
<td>
<p>An integer that indicates the sliding window size. (Default: <code>6</code>)</p>
</td></tr>
<tr><td><code id="compute_LogDistance_+3A_step">step</code></td>
<td>
<p>Integer defaulting to <code>1</code> for the window step.</p>
</td></tr>
<tr><td><code id="compute_LogDistance_+3A_alphabet">alphabet</code></td>
<td>
<p>A vector of single characters that specify the different character
of the sequence. (Default: <code>alphabet = c("a", "c", "g", "t")</code>)</p>
</td></tr>
<tr><td><code id="compute_LogDistance_+3A_on.orf">on.ORF</code></td>
<td>
<p>Logical. If <code>TRUE</code>, Logarithm Distance will be calculated on
the longest ORF region. NOTE: If <code>TRUE</code>, the input has to be DNA sequences.
(Default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="compute_LogDistance_+3A_auto.full">auto.full</code></td>
<td>
<p>Logical. When <code>on.ORF = TRUE</code> but no ORF can be found,
if <code>auto.full = TRUE</code>, Logarithm Distance will be calculated on full sequences automatically;
if <code>auto.full</code> is <code>FALSE</code>, the sequences that have no ORF will be discarded. Ignored when <code>on.ORF = FALSE</code>.
(Default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="compute_LogDistance_+3A_parallel.cores">parallel.cores</code></td>
<td>
<p>Integer. The number of cores for parallel computation.
By default the number of cores is <code>2</code>. Users can set as <code>-1</code> to run
this function with all cores.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can compute Logarithm Distance proposed by LncFinder (HAN et al. 2018).
In LncFinder, two schemes are provided to calculate Logarithm Distance:
1) <code>step = 3</code> and <code>k = 6</code> on the longest ORF region;
2) <code>step = 1</code> and <code>k = 6</code> on full sequence.
Method LncFinder uses scheme 1 to extract Logarithm Distance features.
Using this function <code>compute_EucDistance</code>, both <code>step</code>, <code>k</code>,
and calculated region (full sequence or ORF)
can be customized to maximize its availability.
</p>


<h3>Value</h3>

<p>A dataframe.
</p>


<h3>References</h3>

<p>Siyu Han, Yanchun Liang, Qin Ma, Yangyi Xu, Yu Zhang, Wei Du, Cankun Wang &amp; Ying Li.
LncFinder: an integrated platform for long non-coding RNA identification utilizing
sequence intrinsic composition, structural information, and physicochemical property.
<em>Briefings in Bioinformatics</em>, 2019, 20(6):2009-2027.
</p>


<h3>Author(s)</h3>

<p>HAN Siyu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_referFreq">make_referFreq</a></code>,
<code><a href="#topic+compute_EucDistance">compute_EucDistance</a></code>,
<code><a href="#topic+compute_hexamerScore">compute_hexamerScore</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
Seqs &lt;- seqinr::read.fasta(file =
"http://www.ncbi.nlm.nih.gov/WebSub/html/help/sample_files/nucleotide-sample.txt")

referFreq &lt;- make_referFreq(cds.seq = Seqs, lncRNA.seq = Seqs, k = 6, step = 3,
                            alphabet = c("a", "c", "g", "t"), on.orf = TRUE,
                            ignore.illegal = TRUE)

data(demo_DNA.seq)
Sequences &lt;- demo_DNA.seq

LogDistance &lt;- compute_LogDistance(Sequences, label = "NonCoding", referFreq = referFreq,
                                   k = 6, step = 3, alphabet = c("a", "c", "g", "t"),
                                   on.ORF = TRUE, auto.full = TRUE, parallel.cores = 2)

## End(Not run)

</code></pre>

<hr>
<h2 id='compute_pI'>Compute Theoretical Isoelectric Point</h2><span id='topic+compute_pI'></span>

<h3>Description</h3>

<p>This function is basically a wrapper for function <code><a href="seqinr.html#topic+computePI">computePI</a></code>.
This function translate DNA sequence into protein, and compute the theoretical isoelectric point
(pI) of this protein.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_pI(
  Sequences,
  label = NULL,
  on.ORF = FALSE,
  auto.full = FALSE,
  ambiguous.base = FALSE,
  parallel.cores = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_pI_+3A_sequences">Sequences</code></td>
<td>
<p>A FASTA file loaded by function  <code><a href="seqinr.html#topic+read.fasta">read.fasta</a></code> of
<code><a href="seqinr.html#topic+seqinr-package">seqinr-package</a></code>.</p>
</td></tr>
<tr><td><code id="compute_pI_+3A_label">label</code></td>
<td>
<p>Optional. String. Indicate the label of the sequences such as
&quot;NonCoding&quot;, &quot;Coding&quot;.</p>
</td></tr>
<tr><td><code id="compute_pI_+3A_on.orf">on.ORF</code></td>
<td>
<p>Logical. If <code>TRUE</code>, pI will be calculated on
the longest ORF region. NOTE: If <code>TRUE</code>, the input has to be DNA sequences.
(Default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="compute_pI_+3A_auto.full">auto.full</code></td>
<td>
<p>Logical. When <code>on.ORF = TRUE</code> but no ORF can be found,
if <code>auto.full = TRUE</code>,  pI will be calculated on full sequences automatically;
if <code>auto.full</code> is <code>FALSE</code>, the sequences that have no ORF will be discarded.
Ignored when <code>on.ORF = FALSE</code>. (Default: <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="compute_pI_+3A_ambiguous.base">ambiguous.base</code></td>
<td>
<p>If <code>TRUE</code>, ambiguous bases are taken into account when
translating DNA sequences into proteins.</p>
</td></tr>
<tr><td><code id="compute_pI_+3A_parallel.cores">parallel.cores</code></td>
<td>
<p>Integer. The number of cores for parallel computation.
By default the number of cores is <code>2</code>. Users can set as <code>-1</code> to run
this function with all cores.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can compute the pI of DNA sequences. Method CPC2 (Kang et al. 2017) uses this
feature to identify lncRNAs, and this feature is evaluated in the article LncFinder (Han et al. 2018).
</p>
<p>Using this function, the theoretical pI can be computed on full sequence or the longest ORF region.
In CPC2, pI is calculated on ORF region.
</p>


<h3>Value</h3>

<p>A dataframe.
</p>


<h3>Author(s)</h3>

<p>HAN Siyu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(demo_DNA.seq)
Sequences &lt;- demo_DNA.seq

pI_res &lt;- compute_pI(Sequences, on.ORF = TRUE, auto.full = FALSE, ambiguous.base = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='demo_dataset'>A demo of dataset</h2><span id='topic+demo_dataset'></span>

<h3>Description</h3>

<p>This dataset contains the features of 20 lncRNA sequences and 20 protein-coding
sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(demo_dataset)
</code></pre>


<h3>Format</h3>

<p>A data frame with 40 rows and 20 variables:
</p>

<dl>
<dt>Label</dt><dd><p>the class of the sequences</p>
</dd>
<dt>ORF.Max.Len</dt><dd><p>the length of the longest ORF</p>
</dd>
<dt>ORF.Max.Cov</dt><dd><p>the coverage of the longest ORF</p>
</dd>
<dt>Seq.lnc.Dist</dt><dd><p>Log-Distance.lncRNA</p>
</dd>
<dt>Seq.pct.Dist</dt><dd><p>Log-Distance.protein-coding transcripts</p>
</dd>
<dt>Seq.Dist.Ratio</dt><dd><p>Distance-Ratio.sequence</p>
</dd>
<dt>Signal.Peak</dt><dd><p>Signal as 1/3 position</p>
</dd>
<dt>SNR</dt><dd><p>Signal to noise ratio</p>
</dd>
<dt>Signal.Min</dt><dd><p>the minimum value of the top 10% power spectrum</p>
</dd>
<dt>Signal.Q1</dt><dd><p>the quantile Q1 of the top 10% power spectrum</p>
</dd>
<dt>Signal.Q2</dt><dd><p>the quantile Q2 of the top 10% power spectrum</p>
</dd>
<dt>Signal.Max</dt><dd><p>the maximum value of the top 10% power spectrum</p>
</dd>
<dt>Dot_lnc.dist</dt><dd><p>Log-Distance.acguD.lncRNA</p>
</dd>
<dt>Dot_pct.dist</dt><dd><p>Log-Distance.acguD.protein-coding transcripts</p>
</dd>
<dt>Dot_Dist.Ratio</dt><dd><p>Distance-Ratio.acguD</p>
</dd>
<dt>SS.lnc.dist</dt><dd><p>Log-Distance.acgu-ACGU.lncRNA</p>
</dd>
<dt>SS.pct.dist</dt><dd><p>Log-Distance.acgu-ACGU.protein-coding transcripts</p>
</dd>
<dt>SS.Dist.Ratio</dt><dd><p>Distance-Ratio.acgu-ACGU</p>
</dd>
<dt>MFE</dt><dd><p>Minimum free energy</p>
</dd>
<dt>UP.PCT</dt><dd><p>Percentage of Unpair-Pair</p>
</dd>
</dl>



<h3>Source</h3>

<p>Sequences are selected from GENCODE.
</p>

<hr>
<h2 id='demo_DNA.seq'>A demo of DNA sequences</h2><span id='topic+demo_DNA.seq'></span>

<h3>Description</h3>

<p>This file contains 10 DNA sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(demo_DNA.seq)
</code></pre>


<h3>Format</h3>

<p>A list contains 10 DNA sequences.
</p>

<p>The sequences are loaded by function <code><a href="seqinr.html#topic+read.fasta">read.fasta</a></code>.

</p>


<h3>Source</h3>

<p>DNA sequences are selected from GENCODE.
</p>

<hr>
<h2 id='demo_SS.seq'>A demo of secondary structure sequences</h2><span id='topic+demo_SS.seq'></span>

<h3>Description</h3>

<p>This file contains 10 SS (Secondary Structure) sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(demo_SS.seq)
</code></pre>


<h3>Format</h3>

<p>A data frame with 3 rows and 10 variables:
</p>

<p>The first row is RNA sequence; the second row is Dot-Bracket Notation of
secondary structure sequences; the last row is minimum free energy (MFE).

</p>


<h3>Source</h3>

<p>DNA sequences are selected from GENCODE. Secondary structure of each
sequence is obtained from program &quot;RNAfold&quot;.
</p>

<hr>
<h2 id='extract_features'>Extract the Features</h2><span id='topic+extract_features'></span>

<h3>Description</h3>

<p>This function can construct the dataset. This function is only used
to extract the features, please use function <code><a href="#topic+build_model">build_model</a></code> to build
new models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_features(
  Sequences,
  label = NULL,
  SS.features = FALSE,
  format = "DNA",
  frequencies.file = "human",
  parallel.cores = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_features_+3A_sequences">Sequences</code></td>
<td>
<p>mRNA sequences or long non-coding sequences. Can be a FASTA
file loaded by <code><a href="seqinr.html#topic+seqinr-package">seqinr-package</a></code> or
secondary structure sequences (Dot-Bracket Notation) obtained from function
<code><a href="#topic+run_RNAfold">run_RNAfold</a></code>. If <code>Sequences</code> are secondary structure
sequences file, parameter <code>format</code> should be defined as <code>"SS"</code>.</p>
</td></tr>
<tr><td><code id="extract_features_+3A_label">label</code></td>
<td>
<p>Optional. String. Indicate the label of the sequences such as
&quot;NonCoding&quot;, &quot;Coding&quot;.</p>
</td></tr>
<tr><td><code id="extract_features_+3A_ss.features">SS.features</code></td>
<td>
<p>Logical. If <code>SS.features = TRUE</code>, secondary structure
features will be extracted. In this case, <code>Sequences</code> should be secondary
structure sequences (Dot-Bracket Notation) obtained from function
<code><a href="#topic+run_RNAfold">run_RNAfold</a></code> and parameter <code>format</code> should be set as <code>"SS"</code>.</p>
</td></tr>
<tr><td><code id="extract_features_+3A_format">format</code></td>
<td>
<p>String. Can be <code>"DNA"</code> or <code>"SS"</code>. Define the format of
<code>Sequences</code>. <code>"DNA"</code> for DNA sequences and <code>"SS"</code> for secondary
structure sequences. This parameter must be set as <code>"SS"</code> when
<code>SS.features = TURE</code>.</p>
</td></tr>
<tr><td><code id="extract_features_+3A_frequencies.file">frequencies.file</code></td>
<td>
<p>String or a list obtained from function
<code><a href="#topic+make_frequencies">make_frequencies</a></code>. Input species name <code>"human"</code>, <code>"mouse"</code>
or <code>"wheat"</code> to use pre-build frequencies files. Or assign a users' own
frequencies file (See function <code><a href="#topic+make_frequencies">make_frequencies</a></code>).</p>
</td></tr>
<tr><td><code id="extract_features_+3A_parallel.cores">parallel.cores</code></td>
<td>
<p>Integer. The number of cores for parallel computation.
By default the number of cores is <code>2</code>. Users can set as <code>-1</code> to run
this function with all cores.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extracts the features and constructs the dataset.
</p>
<p>Considering that it is time consuming to obtain secondary structure sequences,
users can build the model only with features of sequence and EIIP
(<code>SS.features = FALSE</code>). When <code>SS.features = TRUE</code>, <code>Sequences</code>
should be secondary structure sequences (Dot-Bracket Notation) obtained from
function <code><a href="#topic+run_RNAfold">run_RNAfold</a></code> and parameter <code>format</code> should be set
as <code>"SS"</code>.
</p>
<p>Please note that:
</p>
<p>Secondary structure features (<code>SS.features</code>) can improve the performance
when the species of unevaluated sequences is identical to the species of the
sequences that used to build the model.
</p>
<p>However, if users are trying to predict sequences with the model trained on
other species, <code>SS.features</code> as <code>TRUE</code> may lead to low accuracy.
</p>


<h3>Value</h3>

<p>Returns a data.frame. 11 features when <code>SS.features</code> is <code>FALSE</code>,
and 19 features when <code>SS.features</code> is <code>TRUE</code>.
</p>


<h3>Features</h3>

<p>1. Features based on sequence:
</p>
<p>The length and coverage of the longest ORF (<code>ORF.Max.Len</code> and
<code>ORF.Max.Cov</code>);
</p>
<p>Log-Distance.lncRNA (<code>Seq.lnc.Dist</code>);
</p>
<p>Log-Distance.protein-coding transcripts (<code>Seq.pct.Dist</code>);
</p>
<p>Distance-Ratio.sequence (<code>Seq.Dist.Ratio</code>).
</p>
<p>2. Features based on EIIP (electron-ion interaction pseudopotential) value:
</p>
<p>Signal at 1/3 position (<code>Signal.Peak</code>);
</p>
<p>Signal to noise ratio (<code>SNR</code>);
</p>
<p>the minimum value of the top 10% power spectrum (<code>Signal.Min</code>);
</p>
<p>the quantile Q1 and Q2 of the top 10% power spectrum (<code>Singal.Q1</code>
and <code>Signal.Q2</code>)
</p>
<p>the maximum value of the top 10% power spectrum (<code>Signal.Max</code>).
</p>
<p>3. Features based on secondary structure sequence:
</p>
<p>Log-Distance.acguD.lncRNA (<code>Dot_lnc.dist</code>);
</p>
<p>Log-Distance.acguD.protein-coding transcripts (<code>Dot_pct.dist</code>);
</p>
<p>Distance-Ratio.acguD (<code>Dot_Dist.Ratio</code>);
</p>
<p>Log-Distance.acgu-ACGU.lncRNA (<code>SS.lnc.dist</code>);
</p>
<p>Log-Distance.acgu-ACGU.protein-coding transcripts (<code>SS.pct.dist</code>);
</p>
<p>Distance-Ratio.acgu-ACGU (<code>SS.Dist.Ratio</code>);
</p>
<p>Minimum free energy (<code>MFE</code>);
</p>
<p>Percentage of Unpair-Pair (<code>UP.PCT</code>)
</p>


<h3>References</h3>

<p>Siyu Han, Yanchun Liang, Qin Ma, Yangyi Xu, Yu Zhang, Wei Du, Cankun Wang &amp; Ying Li.
LncFinder: an integrated platform for long non-coding RNA identification utilizing
sequence intrinsic composition, structural information, and physicochemical property.
<em>Briefings in Bioinformatics</em>, 2019, 20(6):2009-2027.
</p>


<h3>Author(s)</h3>

<p>HAN Siyu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+svm_tune">svm_tune</a></code>, <code><a href="#topic+build_model">build_model</a></code>,
<code><a href="#topic+make_frequencies">make_frequencies</a></code>, <code><a href="#topic+run_RNAfold">run_RNAfold</a></code>, <code><a href="#topic+read_SS">read_SS</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(demo_DNA.seq)
Seqs &lt;- demo_DNA.seq

### Extract features with pre-build frequencies.file:
my_features &lt;- extract_features(Seqs, label = "Class.of.the.Sequences",
                                SS.features = FALSE, format = "DNA",
                                frequencies.file = "mouse",
                                parallel.cores = 2)

### Use your own frequencies file by assign frequencies list to parameter
### "frequencies.file".

## End(Not run)
</code></pre>

<hr>
<h2 id='find_orfs'>Find ORFs</h2><span id='topic+find_orfs'></span>

<h3>Description</h3>

<p>This function can find all the ORFs in one sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_orfs(OneSeq, reverse.strand = FALSE, max.only = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_orfs_+3A_oneseq">OneSeq</code></td>
<td>
<p>Is one sequence. Can be a FASTA file read by package &quot;seqinr&quot;
<code><a href="seqinr.html#topic+seqinr-package">seqinr-package</a></code> or just a string.</p>
</td></tr>
<tr><td><code id="find_orfs_+3A_reverse.strand">reverse.strand</code></td>
<td>
<p>Logical. Whether find ORF on the reverse strand. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="find_orfs_+3A_max.only">max.only</code></td>
<td>
<p>Logical. If <code>TRUE</code>, only the longest ORF will be returned.  Default: <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can extract ORFs of one sequence. It returns
ORF region, length and coverage of the longest ORF when <code>max.only = TRUE</code> or
ORF region, start position, end position, length and coverage of all the ORFs when
<code>max.only = FALSE</code>. Coverage is the the ratio
of the ORF to transcript length. If <code>reverse.strand = TRUE</code>, ORF will also be
found on reverse strand.
</p>


<h3>Value</h3>

<p>If <code>max.only = TRUE</code>, the function returns a list which consists the ORF region (<code>ORF.Max.Seq</code>),
length (<code>ORF.Max.Len</code>) and coverage (<code>ORF.Max.Cov</code>) of the longest ORF.
If <code>max.only = FALSE</code>, the function returns a dataframe which consists all the ORF sequences.
</p>


<h3>Author(s)</h3>

<p>HAN Siyu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### For one sequence:
OneSeq &lt;- c("cccatgcccagctagtaagcttagcc")
orf.info_1 &lt;- find_orfs(OneSeq, reverse.strand = TRUE, max.only = FALSE)

### For a FASTA file contains several sequences:
## Not run: 
### Use "read.fasta" function of package "seqinr" to read a FASTA file:
Seqs &lt;- seqinr::read.fasta(file =
"http://www.ncbi.nlm.nih.gov/WebSub/html/help/sample_files/nucleotide-sample.txt")

## End(Not run)

### Or just try to use our data "demo_DNA.seq"
data(demo_DNA.seq)
Seqs &lt;- demo_DNA.seq

### Use apply function to find the longest ORF:
orf.info_2 &lt;- sapply(Seqs, find_orfs, reverse.strand = FALSE, max.only = FALSE)
</code></pre>

<hr>
<h2 id='lnc_finder'>Long Non-coding RNA Identification</h2><span id='topic+lnc_finder'></span>

<h3>Description</h3>

<p>This function is used to predict sequences are non-coding transcripts
or protein-coding transcripts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lnc_finder(
  Sequences,
  SS.features = FALSE,
  format = "DNA",
  frequencies.file = "human",
  svm.model = "human",
  parallel.cores = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lnc_finder_+3A_sequences">Sequences</code></td>
<td>
<p>Unevaluated sequences. Can be a FASTA file loaded by
<code><a href="seqinr.html#topic+seqinr-package">seqinr-package</a></code> or secondary structure sequences
(Dot-Bracket Notation) obtained from function <code><a href="#topic+run_RNAfold">run_RNAfold</a></code>. If
<code>Sequences</code> is secondary structure sequences file, parameter <code>format</code>
should be defined as <code>"SS"</code>.</p>
</td></tr>
<tr><td><code id="lnc_finder_+3A_ss.features">SS.features</code></td>
<td>
<p>Logical. If <code>SS.features = TRUE</code>, secondary structure
features will be used.</p>
</td></tr>
<tr><td><code id="lnc_finder_+3A_format">format</code></td>
<td>
<p>String. Define the format of the <code>Sequences</code>. Can be
<code>"DNA"</code> or <code>"SS"</code>. <code>"DNA"</code> for DNA sequences and <code>"SS"</code>
for secondary structure sequences.</p>
</td></tr>
<tr><td><code id="lnc_finder_+3A_frequencies.file">frequencies.file</code></td>
<td>
<p>String or a list obtained from function
<code><a href="#topic+make_frequencies">make_frequencies</a></code>. Input species name <code>"human"</code>, <code>"mouse"</code>
or <code>"wheat"</code> to use pre-build frequencies files. Or assign a users' own
frequencies file (See function <code><a href="#topic+make_frequencies">make_frequencies</a></code>).</p>
</td></tr>
<tr><td><code id="lnc_finder_+3A_svm.model">svm.model</code></td>
<td>
<p>String or a svm model obtained from function <code><a href="#topic+build_model">build_model</a></code>
or <code><a href="#topic+svm_tune">svm_tune</a></code>. Input species name <code>"human"</code>, <code>"mouse"</code>
or <code>"wheat"</code> to use pre-build models. Or assign a users' own model (See
function <code><a href="#topic+build_model">build_model</a></code>).</p>
</td></tr>
<tr><td><code id="lnc_finder_+3A_parallel.cores">parallel.cores</code></td>
<td>
<p>Integer. The number of cores for parallel computation.
By default the number of cores is <code>2</code>. Users can set as <code>-1</code> to run
this function with all cores.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Considering that it is time consuming to obtain secondary structure
sequences, users can input nucleotide sequences and predict these sequences
without secondary structure features (Set <code>SS.features</code> as <code>FALSE</code>).
</p>
<p>Please note that:
</p>
<p><code>SS.features</code> can improve the performance when the species of unevaluated
sequences is identical to the species of the sequences that used to build the
model.
</p>
<p>However, if users are trying to predict sequences with the model trained on
other species, <code>SS.features</code> may lead to low accuracy.
</p>
<p>For the details of <code>frequencies.file</code>, please refer to function
<code><a href="#topic+make_frequencies">make_frequencies</a></code>.
</p>
<p>For the details of the features, please refer to function
<code><a href="#topic+extract_features">extract_features</a></code>.
</p>


<h3>Value</h3>

<p>Returns a data.frame. Including the results of prediction (<code>Pred</code>);
coding potential (<code>Coding.Potential</code>) and the features. For the details
of the features, please refer to function <code><a href="#topic+extract_features">extract_features</a></code>.
</p>


<h3>References</h3>

<p>Siyu Han, Yanchun Liang, Qin Ma, Yangyi Xu, Yu Zhang, Wei Du, Cankun Wang &amp; Ying Li.
LncFinder: an integrated platform for long non-coding RNA identification utilizing
sequence intrinsic composition, structural information, and physicochemical property.
<em>Briefings in Bioinformatics</em>, 2019, 20(6):2009-2027.
</p>


<h3>Author(s)</h3>

<p>HAN Siyu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+build_model">build_model</a></code>, <code><a href="#topic+make_frequencies">make_frequencies</a></code>,
<code><a href="#topic+extract_features">extract_features</a></code>, <code><a href="#topic+run_RNAfold">run_RNAfold</a></code>, <code><a href="#topic+read_SS">read_SS</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(demo_DNA.seq)
Seqs &lt;- demo_DNA.seq

### Input one sequence:
OneSeq &lt;- Seqs[1]
result_1 &lt;- lnc_finder(OneSeq, SS.features = FALSE, format = "DNA",
                       frequencies.file = "human", svm.model = "human",
                       parallel.cores = 2)

### Or several sequences:
data(demo_SS.seq)
Seqs &lt;- demo_SS.seq
result_2 &lt;- lnc_finder(Seqs, SS.features = TRUE, format = "SS",
                       frequencies.file = "mouse", svm.model = "mouse",
                       parallel.cores = 2)

### A complete work flow:
### Calculate second structure on Windows OS,
RNAfold.path &lt;- '"E:/Program Files/ViennaRNA/RNAfold.exe"'
SS.seq &lt;- run_RNAfold(Seqs, RNAfold.path = RNAfold.path, parallel.cores = 2)

### Predict the sequences with secondary structure features,
result_2 &lt;- lnc_finder(SS.seq, SS.features = TRUE, format = "SS",
                       frequencies.file = "mouse", svm.model = "mouse",
                       parallel.cores = 2)

### Predict sequences with your own model by assigning a new svm.model and
### frequencies.file to parameters "svm.model" and "frequencies.file"

## End(Not run)
</code></pre>

<hr>
<h2 id='make_frequencies'>Make the frequencies file for new classifier construction</h2><span id='topic+make_frequencies'></span>

<h3>Description</h3>

<p>This function is used to calculate the frequencies of lncRNAs, CDs, and
secondary structure sequences. The frequencies file can be used to build the classifier
using function <code><a href="#topic+extract_features">extract_features</a></code>. Functions <code>make_frequencies</code> and
<code>extract_features</code> are useful when users are trying
to build their own model.
</p>
<p>NOTE: Function <code>make_frequencies</code> makes the frequencies file
for building the classifiers of LncFinder method. If users need to calculate Logarithm-Distance,
Euclidean-Distance, and hexamer score, the frequencies file need to be computed using function
<code><a href="#topic+make_referFreq">make_referFreq</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_frequencies(
  cds.seq,
  mRNA.seq,
  lncRNA.seq,
  SS.features = FALSE,
  cds.format = "DNA",
  lnc.format = "DNA",
  check.cds = TRUE,
  ignore.illegal = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_frequencies_+3A_cds.seq">cds.seq</code></td>
<td>
<p>Coding sequences (mRNA without UTRs). Can be a FASTA file loaded
by <code><a href="seqinr.html#topic+seqinr-package">seqinr-package</a></code> or secondary structure
sequences (Dot-Bracket Notation) obtained form function <code><a href="#topic+run_RNAfold">run_RNAfold</a></code>.
CDs are used to calculate hexamer frequencies of nucleotide sequences,thus
secondary structure is not needed. Parameter <code>cds.format</code> should be
<code>"SS"</code> when input is secondary structure sequences. (See details for
more information.)</p>
</td></tr>
<tr><td><code id="make_frequencies_+3A_mrna.seq">mRNA.seq</code></td>
<td>
<p>mRNA sequences with Dot-Bracket Notation. The secondary
structure sequences can be obtained from function <code><a href="#topic+run_RNAfold">run_RNAfold</a></code>.
mRNA sequences are used to calculate the frequencies of acgu-ACGU and a acguD
(see details), thus, mRNA sequences are required only when <code>SS.features = TRUE</code>.</p>
</td></tr>
<tr><td><code id="make_frequencies_+3A_lncrna.seq">lncRNA.seq</code></td>
<td>
<p>Long non-coding RNA sequences. Can be a FASTA file loaded by
<code><a href="seqinr.html#topic+seqinr-package">seqinr-package</a></code> or secondary structure
sequences (Dot-Bracket Notation) obtained from function <code><a href="#topic+run_RNAfold">run_RNAfold</a></code>.
If <code>SS.features = TRUE</code>, <code>lncRNA.seq</code> must be RNA sequences with
secondary structure sequences and parameter <code>lnc.format</code> should be defined
as <code>"SS"</code>.</p>
</td></tr>
<tr><td><code id="make_frequencies_+3A_ss.features">SS.features</code></td>
<td>
<p>Logical. If <code>SS.features = TRUE</code>, frequencies of secondary
structure will also be calculated and the model can be built with secondary
structure features. In this case, <code>mRNA.seq</code> and <code>lncRNA.seq</code> should
be secondary structure sequences.</p>
</td></tr>
<tr><td><code id="make_frequencies_+3A_cds.format">cds.format</code></td>
<td>
<p>String. Define the format of the sequences of <code>cds.seq</code>.
Can be <code>"DNA"</code> or <code>"SS"</code>. <code>"DNA"</code> for DNA sequences and <code>"SS"</code>
for secondary structure sequences.</p>
</td></tr>
<tr><td><code id="make_frequencies_+3A_lnc.format">lnc.format</code></td>
<td>
<p>String. Define the format of lncRNAs (<code>lncRNA.seq</code>).
Can be <code>"DNA"</code> or <code>"SS"</code>. <code>"DNA"</code> for DNA sequences and <code>"SS"</code>
for secondary structure sequences. This parameter must be defined as <code>"SS"</code>
when <code>SS.features = TURE</code>.</p>
</td></tr>
<tr><td><code id="make_frequencies_+3A_check.cds">check.cds</code></td>
<td>
<p>Logical. Incomplete CDs can lead to a false shift and a
inaccurate hexamer frequencies. When <code>check.cds = TRUE</code>, hexamer frequencies
will be calculated on the longest ORF. This parameter is strongly recommended to
set as <code>TRUE</code> when mRNA is used as CDs.</p>
</td></tr>
<tr><td><code id="make_frequencies_+3A_ignore.illegal">ignore.illegal</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the sequences with non-nucleotide
characters (nucleotide characters: &quot;a&quot;, &quot;c&quot;, &quot;g&quot;, &quot;t&quot;) will be ignored when
calculating hexamer frequencies.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to make frequencies file for LncFinder method. This file is needed
when users are trying to build their own model.
</p>
<p>In order to achieve high accuracy, mRNA should not be regarded as CDs and assigned
to parameter <code>cds.seq</code>. However, CDs of some species may be insufficient
for calculating frequencies, and mRNAs can be regarded as CDs with parameter
<code>check.cds = TRUE</code>. In this case, hexamer frequencies will be calculated
on ORF region.
</p>
<p>Considering that it is time consuming to obtain secondary structure sequences,
users can only provide nucleotide sequences and build a model without secondary
structure features (<code>SS.features = </code> <code>FALSE</code>). If users want to build a model
with secondary structure features, parameter <code>SS.features</code> should be set
as <code>TRUE</code>. At the same time, the format of the sequences of <code>mRNA.seq</code>
and <code>lnc.seq</code> should be secondary structure sequences (Dot-Bracket Notation).
Secondary structure sequences can be obtained by function <code><a href="#topic+run_RNAfold">run_RNAfold</a></code>.
</p>
<p>Please note that:
</p>
<p>SS.features can improve the performance when the species of unevaluated sequences
is identical to the species of the sequences that used to build the model.
</p>
<p>However, if users are trying to predict sequences with the model trained on
other species, SS.features may lead to low accuracy.
</p>
<p>The frequencies file consists three groups: Hexamer Frequencies; acgu-ACGU
Frequencies and acguD Frequencies.
</p>
<p>Hexamer Frequencies are calculated on the original nucleotide sequences by
employing <em>k</em>-mer scheme (<em>k</em> = 6), and the sliding window will slide
3 nt each step.
</p>
<p>For any secondary structure sequences (Dot-Bracket Notation), if one position
is a dot, the corresponding nucleotide of the RNA sequence will be replaced
with character &quot;D&quot;. acguD Frequencies are the <em>k</em>-mer frequencies
(<em>k</em> = 4) calculated on this new sequences.
</p>
<p>Similarly, for any secondary structure sequences (Dot-Bracket Notation), if
one position is &quot;(&quot; or &quot;)&quot;, the corresponding nucleotide of the RNA sequence
will be replaced with upper case (&quot;A&quot;, &quot;C&quot;, &quot;G&quot;, &quot;U&quot;).
</p>
<p>A brief example,
</p>
<p>DNA Sequence:<code>          5'-   t  a  c  a  g  t  t  a  t  g   -3'</code>
</p>
<p>RNA Sequence:<code>          5'-   u  a  c  a  g  u  u  a  u  g   -3'</code>
</p>
<p>Dot-Bracket Sequence:<code>     5'-   .  .  .  .  (  (  (  (  (  (   -3'</code>
</p>
<p>acguD Sequence:<code>         {     D, D, D, D, g, u, u, a, u, g   }</code>
</p>
<p>acgu-ACGU Sequence:<code>    {     u, a, c, a, G, U, U, A, U, G   }</code>
</p>


<h3>Value</h3>

<p>Returns a list which consists the frequencies of protein-coding sequences
and non-coding sequences.
</p>


<h3>References</h3>

<p>Siyu Han, Yanchun Liang, Qin Ma, Yangyi Xu, Yu Zhang, Wei Du, Cankun Wang &amp; Ying Li.
LncFinder: an integrated platform for long non-coding RNA identification utilizing
sequence intrinsic composition, structural information, and physicochemical property.
<em>Briefings in Bioinformatics</em>, 2019, 20(6):2009-2027.
</p>


<h3>Author(s)</h3>

<p>HAN Siyu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+run_RNAfold">run_RNAfold</a></code>, <code><a href="#topic+read_SS">read_SS</a></code>,
<code><a href="#topic+build_model">build_model</a></code>, <code><a href="#topic+extract_features">extract_features</a></code>,
<code><a href="#topic+make_referFreq">make_referFreq</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Only for examples:
data(demo_DNA.seq)
Seqs &lt;- demo_DNA.seq

## Not run: 
### Obtain the secondary structure sequences (Windows OS):
RNAfold.path &lt;- '"E:/Program Files/ViennaRNA/RNAfold.exe"'
SS.seq &lt;- run_RNAfold(Seqs, RNAfold.path = RNAfold.path, parallel.cores = 2)

### Make frequencies file with secondary strucutre features,
my_file_1 &lt;- make_frequencies(cds.seq = SS.seq, mRNA.seq = SS.seq,
                              lncRNA.seq = SS.seq, SS.features = TRUE,
                              cds.format = "SS", lnc.format = "SS",
                              check.cds = TRUE, ignore.illegal = FALSE)

## End(Not run)

### Make frequencies file without secondary strucutre features,
my_file_2 &lt;- make_frequencies(cds.seq = Seqs, lncRNA.seq = Seqs,
                              SS.features = FALSE, cds.format = "DNA",
                              lnc.format = "DNA", check.cds = TRUE,
                              ignore.illegal = FALSE)

### The input of cds.seq and lncRNA.seq can also be secondary structure
### sequences when SS.features = FALSE, such as,
data(demp_SS.seq)
SS.seq &lt;- demo_SS.seq
my_file_3 &lt;- make_frequencies(cds.seq = SS.seq, lncRNA.seq = Seqs,
                              SS.features = FALSE, cds.format = "SS",
                              lnc.format = "DNA", check.cds = TRUE,
                              ignore.illegal = FALSE)
</code></pre>

<hr>
<h2 id='make_referFreq'>Make Frequencies File for Log.Dist, Euc.Dist, and hexamer score</h2><span id='topic+make_referFreq'></span>

<h3>Description</h3>

<p>This function is used to calculate the frequencies of lncRNAs and CDs.
The Frequencies file can be used to calculate Logarithm-Distance (<code><a href="#topic+compute_LogDistance">compute_LogDistance</a></code>),
Euclidean-Distance (<code><a href="#topic+compute_EucDistance">compute_EucDistance</a></code>), and hexamer score (<code><a href="#topic+compute_hexamerScore">compute_hexamerScore</a></code>).
</p>
<p>NOTE: If users need to make frequencies file to build
new LncFinder classifier using function <code><a href="#topic+extract_features">extract_features</a></code>,
please refer to function <code>make_frequencies</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_referFreq(
  cds.seq,
  lncRNA.seq,
  k = 6,
  step = 1,
  alphabet = c("a", "c", "g", "t"),
  on.orf = TRUE,
  ignore.illegal = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_referFreq_+3A_cds.seq">cds.seq</code></td>
<td>
<p>Coding sequences (mRNA without UTRs). Can be a FASTA file loaded
by <code><a href="seqinr.html#topic+seqinr-package">seqinr-package</a></code>.</p>
</td></tr>
<tr><td><code id="make_referFreq_+3A_lncrna.seq">lncRNA.seq</code></td>
<td>
<p>Long non-coding RNA sequences. Can be a FASTA file loaded by
<code><a href="seqinr.html#topic+seqinr-package">seqinr-package</a></code>.</p>
</td></tr>
<tr><td><code id="make_referFreq_+3A_k">k</code></td>
<td>
<p>An integer that indicates the sliding window size. (Default: <code>6</code>)</p>
</td></tr>
<tr><td><code id="make_referFreq_+3A_step">step</code></td>
<td>
<p>Integer defaulting to <code>1</code> for the window step.</p>
</td></tr>
<tr><td><code id="make_referFreq_+3A_alphabet">alphabet</code></td>
<td>
<p>A vector of single characters that specify the different character
of the sequence. (Default: <code>alphabet = c("a", "c", "g", "t")</code>)</p>
</td></tr>
<tr><td><code id="make_referFreq_+3A_on.orf">on.orf</code></td>
<td>
<p>Logical. Incomplete CDs can lead to a false shift and a
inaccurate hexamer frequencies. When <code>on.orf = TRUE</code>, the frequencies
will be calculated on the longest ORF. This parameter is strongly recommended to
set as <code>TRUE</code> when mRNA is used as CDs. Only available when
<code>alphabet = c("a", "c", "g", "t")</code>. (Default: <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="make_referFreq_+3A_ignore.illegal">ignore.illegal</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the sequences with non-nucleotide
characters (nucleotide characters: &quot;a&quot;, &quot;c&quot;, &quot;g&quot;, &quot;t&quot;) will be ignored when
calculating the frequencies. Only available when <code>alphabet = c("a", "c", "g", "t")</code>.
(Default: <code>TRUE</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to make frequencies file for the computation of
Logarithm-Distance (<code><a href="#topic+compute_LogDistance">compute_LogDistance</a></code>), Euclidean-Distance
(<code><a href="#topic+compute_EucDistance">compute_EucDistance</a></code>),
and hexamer score (<code><a href="#topic+compute_hexamerScore">compute_hexamerScore</a></code>).
</p>
<p>In order to achieve high accuracy, mRNA should not be regarded as CDs and assigned
to parameter <code>cds.seq</code>. However, CDs of some species may be insufficient
for calculating frequencies. In that case, mRNAs can be regarded as CDs with parameter
<code>on.orf = TRUE</code>, and the frequencies will be calculated on ORF region.
If <code>on.orf = TRUE</code>, users can set <code>step = 3</code> to simulate the translation process.
</p>


<h3>Value</h3>

<p>Returns a list which consists the frequencies of protein-coding sequences
and non-coding sequences.
</p>


<h3>References</h3>

<p>Siyu Han, Yanchun Liang, Qin Ma, Yangyi Xu, Yu Zhang, Wei Du, Cankun Wang &amp; Ying Li.
LncFinder: an integrated platform for long non-coding RNA identification utilizing
sequence intrinsic composition, structural information, and physicochemical property.
<em>Briefings in Bioinformatics</em>, 2019, 20(6):2009-2027.
</p>


<h3>Author(s)</h3>

<p>HAN Siyu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_frequencies">make_frequencies</a></code>,
<code><a href="#topic+compute_LogDistance">compute_LogDistance</a></code>,
<code><a href="#topic+compute_EucDistance">compute_EucDistance</a></code>,
<code><a href="#topic+compute_hexamerScore">compute_hexamerScore</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
Seqs &lt;- seqinr::read.fasta(file =
"http://www.ncbi.nlm.nih.gov/WebSub/html/help/sample_files/nucleotide-sample.txt")

referFreq &lt;- make_referFreq(cds.seq = Seqs, lncRNA.seq = Seqs, k = 6, step = 1,
                            alphabet = c("a", "c", "g", "t"), on.orf = TRUE,
                            ignore.illegal = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='read_SS'>Read Secondary Structure Information</h2><span id='topic+read_SS'></span>

<h3>Description</h3>

<p>This function can read secondary structure information from your
own file instead of obtaining from function <code><a href="#topic+run_RNAfold">run_RNAfold</a></code>. This function
will be useful if users have had secondary structure sequences (Dot-Bracket Notation).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_SS(
  oneFile.loc,
  seqRNA.loc,
  seqSS.loc,
  separateFile = TRUE,
  withMFE = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_SS_+3A_onefile.loc">oneFile.loc</code></td>
<td>
<p>String. The location of your sequence file. This file should contains
one (and only one) RNA sequence and its secondary structure sequence in Dot-Bracket Notation.
This parameter needs to be defined only when <code>separateFile = FALSE</code>. See Details for more
information.</p>
</td></tr>
<tr><td><code id="read_SS_+3A_seqrna.loc">seqRNA.loc</code></td>
<td>
<p>String. The location of your RNA sequences file (FASTA format). If your
RNA sequences and secondary structure sequences are in two files, you need to define the
locations of two files respectively. And the files with multiple sequences are supported
for this option. This parameter needs to be defined only when <code>separateFile</code> is <code>TRUE</code>.
Location of secondary structure sequences file is also needed (parameter <code>seqSS.loc</code>).
See Details for more information.</p>
</td></tr>
<tr><td><code id="read_SS_+3A_seqss.loc">seqSS.loc</code></td>
<td>
<p>String. The location of your secondary structure sequences file (FASTA format).</p>
</td></tr>
<tr><td><code id="read_SS_+3A_separatefile">separateFile</code></td>
<td>
<p>Logical. Your RNA sequence(s) and secondary structure sequence(s) are in
separate files? If <code>separateFile = FALSE</code>, your file should have one (and only one) RNA
sequence and its secondary structure sequence. No limit when <code>separateFile = TRUE</code>.</p>
</td></tr>
<tr><td><code id="read_SS_+3A_withmfe">withMFE</code></td>
<td>
<p>Logical. Whether MFE is provided at the end of secondary structure sequence.
If <code>withMFE = TRUE</code>, MFE will be extracted. The format should be in accordance with
the output format of RNAfold.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When users want to predict sequences with secondary structure features, users may have
had their own secondary structure sequences. With this function, users can read SS information
from their files. Two kind of files are supported: RNA sequence and SS sequence in one file
<code>separateFile</code> is <code>FALSE</code> or in separate files <code>separateFile = TRUE</code>.
</p>
<p><code>separateFile = FALSE</code> is used for secondary structure that obtained from some popular
programs, such as RNAfold. In this case, the output file only contains one RNA sequence and
its SS. Besides, this file only have two rows: RNA sequence and its SS sequences. Thus, this
option is more favorable when the file only have one sequence and the sequence are in accordance
with the output format of RNAfold.
</p>
<p>If users obtained the SS sequence from experiments, RNA sequence and SS sequence may be in two
files. In this case, users can select <code>separateFile = TRUE</code>. Two files should be in FASTA
format and one file can have multiple sequences. The sequences in two files should have the same
order. If your data are obtained from experiments or other sources, it is highly recommended
that users should build new model with this data, since the SS sequences of pre-built model are
obtained for RNAfold and may have many differences with experimental data.
</p>


<h3>Value</h3>

<p>A dataframe. The first row is RNA sequence, the second row is Dot-Bracket Notation of
secondary structure sequence, the third row is MFE (if MFE is provided).
</p>


<h3>Author(s)</h3>

<p>HAN Siyu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+run_RNAfold">run_RNAfold</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Load sequence data
data("demo_DNA.seq")
Seqs &lt;- demo_DNA.seq[1:4]
### Convert sequences from vector to string.
Seqs &lt;- sapply(Seqs, seqinr::getSequence, as.string = TRUE)
### Write a fasta file.
seqinr::write.fasta(Seqs, names = names(Seqs), file.out = "tmp.RNA.fa", as.string = TRUE)

### For Windows system: (Your path of RNAfold.)
RNAfold.path &lt;- '"E:/Program Files/ViennaRNA/RNAfold.exe"'
### Define the parameters of RNAfold. See documents of RNAfold for more information.
RNAfold.command &lt;- paste(RNAfold.path, " --noPS -i tmp.RNA.fa -o output", sep = "")
### Run RNAfold and output four result files.
system(RNAfold.command)

### Read secondary structure information for one file.
result_1 &lt;- read_SS(oneFile.loc = "output_ENST00000510062.1.fold",
                    separateFile = FALSE, withMFE = TRUE)
### Read secondary sturcture sequences for multiple files.
filePath &lt;- dir(pattern = ".fold")
result_2 &lt;- sapply(filePath, read_SS, separateFile = FALSE, withMFE = TRUE)
result_2 &lt;- as.data.frame(result_2)

## End(Not run)

</code></pre>

<hr>
<h2 id='run_RNAfold'>Obtain the Secondary Structure Sequences Using RNAfold</h2><span id='topic+run_RNAfold'></span>

<h3>Description</h3>

<p>This function can compute secondary structure sequences. The tool
&quot;RNAfold&quot; of software &quot;ViennaRNA&quot; is required for this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_RNAfold(Sequences, RNAfold.path = "RNAfold", parallel.cores = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_RNAfold_+3A_sequences">Sequences</code></td>
<td>
<p>A FASTA file loaded by function  <code><a href="seqinr.html#topic+read.fasta">read.fasta</a></code> of
<code><a href="seqinr.html#topic+seqinr-package">seqinr-package</a></code>.</p>
</td></tr>
<tr><td><code id="run_RNAfold_+3A_rnafold.path">RNAfold.path</code></td>
<td>
<p>String. Indicate the path of the program &quot;RNAfold&quot;. By
default is <code>"RNAfold"</code> for UNIX/Linux system. (See details.)</p>
</td></tr>
<tr><td><code id="run_RNAfold_+3A_parallel.cores">parallel.cores</code></td>
<td>
<p>Integer. The number of cores for parallel computation.
By default the number of cores is <code>2</code>, users can set as <code>-1</code> to run
this function with all cores.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to compute secondary structure. The output of
this function can be used in function <code><a href="#topic+make_frequencies">make_frequencies</a></code>,
<code><a href="#topic+extract_features">extract_features</a></code>, <code><a href="#topic+build_model">build_model</a></code> and
<code><a href="#topic+lnc_finder">lnc_finder</a></code> when parameter <code>SS.features</code> is set as <code>TRUE</code>.
</p>
<p>This function depends on the program &quot;RNAfold&quot; of software &quot;ViennaRNA&quot;.
(<a href="http://www.tbi.univie.ac.at/RNA/index.html">http://www.tbi.univie.ac.at/RNA/index.html</a>)
</p>
<p>Parameter <code>RNAfold.path</code> can be simply defined as <code>"RNAfold"</code> as
default when the OS is UNIX/Linux. However, for some OS, such as Windows, users
need to specify the <code>RNAfold.path</code> if the path of &quot;RNAfold&quot; haven't been
added in environment variables.
</p>
<p>This function can print the related information when the OS is UNIX/Linux,
such as:
</p>
<p><code>"25 of 100, length: 695 nt"</code>,
</p>
<p>which means around 100 sequences are assigned to this node and the program is
computing the 25th sequence. The length of this sequence is 695nt.
</p>
<p>If users have their own SS data, users can use function <code><a href="#topic+read_SS">read_SS</a></code> to load
them, instead of obtaining from RNAfold.
</p>


<h3>Value</h3>

<p>Returns data.frame. The first row is RNA sequence; the second row is
Dot-Bracket Notation of secondary structure sequences; the last row is minimum
free energy (MFE).
</p>


<h3>Author(s)</h3>

<p>HAN Siyu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read_SS">read_SS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### For a FASTA file contains several sequences,
### Use "read.fasta" function of package "seqinr" to read a FASTA file:
Seqs &lt;- read.fasta(file =
"http://www.ncbi.nlm.nih.gov/WebSub/html/help/sample_files/nucleotide-sample.txt")

### Or just try to use our data "demo_DNA.seq"
data(demo_DNA.seq)
Seqs &lt;- demo_DNA.seq

### Windows:
RNAfold.path &lt;- '"E:/Program Files/ViennaRNA/RNAfold.exe"'
SS.seq_1 &lt;- run_RNAfold(Seqs[1:2], RNAfold.path = RNAfold.path, parallel.cores = 2)

### For UNIX/Linux, "RNAfold.path" can be just defined as "RNAfold" as default:
SS.seq_2 &lt;- run_RNAfold(Seqs, RNAfold.path = "RNAfold", parallel.cores = 2)

## End(Not run)
</code></pre>

<hr>
<h2 id='svm_cv'><em>k</em>-fold Cross Validation for SVM</h2><span id='topic+svm_cv'></span>

<h3>Description</h3>

<p>This function conduct <em>k</em>-fold Cross Validation for SVM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svm_cv(
  dataset,
  label.col = 1,
  positive.class = NULL,
  folds.num = 10,
  seed = 1,
  parallel.cores = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svm_cv_+3A_dataset">dataset</code></td>
<td>
<p>The dataset obtained from function <code><a href="#topic+extract_features">extract_features</a></code>.
Or datasets used to build the classifier.</p>
</td></tr>
<tr><td><code id="svm_cv_+3A_label.col">label.col</code></td>
<td>
<p>integer specifying the column number of the label. (Default: <code>1</code>)</p>
</td></tr>
<tr><td><code id="svm_cv_+3A_positive.class">positive.class</code></td>
<td>
<p>Character. Indicate the positive class of the dataset.
(Default: <code>NonCoding</code>) The value of this parameter should be identical to
one of the classes of the response vectors.</p>
</td></tr>
<tr><td><code id="svm_cv_+3A_folds.num">folds.num</code></td>
<td>
<p>Integer. Specify the number of folds for cross-validation.
(Default: <code>10</code>)</p>
</td></tr>
<tr><td><code id="svm_cv_+3A_seed">seed</code></td>
<td>
<p>Integer. Used to set the seed for cross-validation. (Default: <code>1</code>)</p>
</td></tr>
<tr><td><code id="svm_cv_+3A_parallel.cores">parallel.cores</code></td>
<td>
<p>Integer. The number of cores for parallel computation.
By default the number of cores is <code>2</code>, users can set as <code>-1</code> to run
this function with all cores. If the number of <code>parallel.cores</code> is more
than the <code>folds.num</code> (number of the folds for cross-validation), the
number of <code>parallel.cores</code> will be set as <code>folds.num</code> automatically.</p>
</td></tr>
<tr><td><code id="svm_cv_+3A_...">...</code></td>
<td>
<p>additional parameters for function <code><a href="e1071.html#topic+svm">svm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>During the model tuning, the performance of each combination of
parameters will output. Sensitivity, Specificity, Accuracy, F-Measure and Kappa
Value are used to evaluate the performances. The best gamma and cost (or best
model) are selected based on Accuracy.
</p>
<p>For the details of parameter gamma and cost, please refer to function
<code><a href="e1071.html#topic+svm">svm</a></code> of package &quot;e1071&quot;.
</p>
<p>For the details of metrics, please refer to function
<code><a href="caret.html#topic+confusionMatrix">confusionMatrix</a></code> of package &quot;caret&quot;.
</p>


<h3>Value</h3>

<p>Returns the optimal parameters when <code>return.model = FALSE</code>.
Or returns the best model when <code>return.model = TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>HAN Siyu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extract_features">extract_features</a></code>, <code><a href="#topic+svm_tune">svm_tune</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(demo_dataset)
my_dataset &lt;- demo_dataset

cv_res &lt;- svm_cv(my_dataset, folds.num = 4, seed = 1,
                 parallel.core = 2, cost = 3, kernel = "radial", gamma = 0.5)

### Users can set return.model = TRUE to return the best model.

## End(Not run)
</code></pre>

<hr>
<h2 id='svm_tune'>Parameter Tuning of SVM</h2><span id='topic+svm_tune'></span>

<h3>Description</h3>

<p>This function conduct the parameter tuning of SVM. Parameters
gamma and cost can be tuned using grid search.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svm_tune(
  dataset,
  label.col = 1,
  positive.class = "NonCoding",
  folds.num = 10,
  seed = 1,
  gamma.range = (2^seq(-5, 0, 1)),
  cost.range = c(1, 4, 8, 16, 24, 32),
  return.model = TRUE,
  parallel.cores = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svm_tune_+3A_dataset">dataset</code></td>
<td>
<p>The dataset obtained from function <code><a href="#topic+extract_features">extract_features</a></code>.
Or datasets used to build the classifier.</p>
</td></tr>
<tr><td><code id="svm_tune_+3A_label.col">label.col</code></td>
<td>
<p>integer specifying the column number of the label. (Default: <code>1</code>)</p>
</td></tr>
<tr><td><code id="svm_tune_+3A_positive.class">positive.class</code></td>
<td>
<p>Character. Indicate the positive class of the dataset.
(Default: <code>NonCoding</code>) The value of this parameter should be identical to
one of the classes of the response vectors.</p>
</td></tr>
<tr><td><code id="svm_tune_+3A_folds.num">folds.num</code></td>
<td>
<p>Integer. Specify the number of folds for cross-validation.
(Default: <code>10</code>)</p>
</td></tr>
<tr><td><code id="svm_tune_+3A_seed">seed</code></td>
<td>
<p>Integer. Used to set the seed for cross-validation. (Default: <code>1</code>)</p>
</td></tr>
<tr><td><code id="svm_tune_+3A_gamma.range">gamma.range</code></td>
<td>
<p>The range of gamma. (Default: <code>2 ^ seq(-5, 0, 1)</code>)</p>
</td></tr>
<tr><td><code id="svm_tune_+3A_cost.range">cost.range</code></td>
<td>
<p>The range of cost. (Default: <code>c(1, 4, 8, 16, 24, 32)</code>)</p>
</td></tr>
<tr><td><code id="svm_tune_+3A_return.model">return.model</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the function will return the best
model trained on the full dataset. If <code>FALSE</code>, this function will return
the optimal parameters.</p>
</td></tr>
<tr><td><code id="svm_tune_+3A_parallel.cores">parallel.cores</code></td>
<td>
<p>Integer. The number of cores for parallel computation.
By default the number of cores is <code>2</code>, users can set as <code>-1</code> to run
this function with all cores. If the number of <code>parallel.cores</code> is more
than the <code>folds.num</code> (number of the folds for cross-validation), the
number of <code>parallel.cores</code> will be set as <code>folds.num</code> automatically.</p>
</td></tr>
<tr><td><code id="svm_tune_+3A_...">...</code></td>
<td>
<p>Additional arguments for function <code><a href="e1071.html#topic+svm">svm</a></code>, except
<code>scale</code>, <code>probability</code>, <code>kernel</code>, <code>gamma</code> and <code>cost</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>During the model tuning, the performance of each combination of
parameters will output. Sensitivity, Specificity, Accuracy, F-Measure and Kappa
Value are used to evaluate the performances. The best gamma and cost (or best
model) are selected based on Accuracy.
</p>
<p>For the details of parameter gamma and cost, please refer to function
<code><a href="e1071.html#topic+svm">svm</a></code> of package &quot;e1071&quot;.
</p>
<p>For the details of metrics, please refer to function
<code><a href="caret.html#topic+confusionMatrix">confusionMatrix</a></code> of package &quot;caret&quot;.
</p>


<h3>Value</h3>

<p>Returns the optimal parameters when <code>return.model = FALSE</code>.
Or returns the best model when <code>return.model = TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>HAN Siyu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extract_features">extract_features</a></code>, <code><a href="#topic+svm_cv">svm_cv</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(demo_DNA.seq)
Seqs &lt;- demo_DNA.seq

positive_data &lt;- extract_features(Seqs[1:5], label = "NonCoding",
                                  SS.features = FALSE, format = "DNA",
                                  frequencies.file = "human",
                                  parallel.cores = 2)

negative_data &lt;- extract_features(Seqs[6:10], label = "Coding",
                                  SS.features = FALSE, format = "DNA",
                                  frequencies.file = "human",
                                  parallel.cores = 2)

my_dataset &lt;- rbind(positive_data, negative_data)

### Or use our data "demo_dataset"
data(demo_dataset)
my_dataset &lt;- demo_dataset

optimal_parameter &lt;- svm_tune(my_dataset, positive.class = "NonCoding",
                              folds.num = 2, seed = 1,
                              gamma.range = (2 ^ seq(-5, 0, 2)),
                              cost.range = c(1, 8, 16),
                              return.model = FALSE, parallel.core = 2)

### Users can set return.model = TRUE to return the best model.

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
