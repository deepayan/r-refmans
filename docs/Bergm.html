<!DOCTYPE html><html lang="en-US"><head><title>Help for package Bergm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Bergm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Bergm-package'><p>Bayesian exponential random graph models</p></a></li>
<li><a href='#bergm'><p>Parameter estimation for Bayesian ERGMs</p></a></li>
<li><a href='#bergmC'><p>Calibrating misspecified Bayesian ERGMs</p></a></li>
<li><a href='#bergmM'><p>Parameter estimation for Bayesian ERGMs under missing data</p></a></li>
<li><a href='#bgof'><p>Bayesian goodness-of-fit diagnostics for ERGMs</p></a></li>
<li><a href='#ergmAPL'><p>Adjustment of ERGM pseudolikelihood</p></a></li>
<li><a href='#evidence'><p>Wrapper function for evidence estimation</p></a></li>
<li><a href='#evidenceCJ'><p>Evidence estimation via Chib and Jeliazkov's method</p></a></li>
<li><a href='#evidencePP'><p>Evidence estimation via power posteriors</p></a></li>
<li><a href='#lazega'><p>Lazega lawyers network data</p></a></li>
<li><a href='#plot.bergm'><p>Plot BERGM posterior output</p></a></li>
<li><a href='#summary.bergm'><p>Summary of BERGM posterior output</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Exponential Random Graph Models</td>
</tr>
<tr>
<td>Version:</td>
<td>5.0.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-06</td>
</tr>
<tr>
<td>Author:</td>
<td>Alberto Caimo [aut, cre], Lampros Bouranis [aut], Robert Krause
    [aut] Nial Friel [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alberto Caimo &lt;alberto.caimo1@ucd.ie&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Bayesian analysis for exponential random graph models using
    advanced computational algorithms. More information can be found at:
    <a href="https://acaimo.github.io/Bergm/">https://acaimo.github.io/Bergm/</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://acaimo.github.io/Bergm/">https://acaimo.github.io/Bergm/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>ergm, R (&ge; 4.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>coda, graphics, grDevices, Matrix, matrixcalc, MCMCpack,
mvtnorm, network, Rglpk, statnet.common, stats, utils</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>spelling</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-06 11:58:10 UTC; albertocaimo</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-06 12:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Bergm-package'>Bayesian exponential random graph models</h2><span id='topic+Bergm-package'></span><span id='topic+Bergm'></span>

<h3>Description</h3>

<p><code>Bergm</code> provides a range of tools to analyse 
Bayesian exponential random graph models using advanced 
computational methods.
</p>

<hr>
<h2 id='bergm'>Parameter estimation for Bayesian ERGMs</h2><span id='topic+bergm'></span>

<h3>Description</h3>

<p>Function to fit Bayesian exponential random graphs models
using the approximate exchange algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bergm(
  formula,
  prior.mean = NULL,
  prior.sigma = NULL,
  burn.in = 100,
  main.iters = 1000,
  aux.iters = 1000,
  nchains = NULL,
  gamma = 0.5,
  V.proposal = 0.0025,
  startVals = NULL,
  offset.coef = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bergm_+3A_formula">formula</code></td>
<td>
<p>formula; 
an <code><a href="ergm.html#topic+ergm">ergm</a></code> formula object,
of the form  &lt;network&gt; ~ &lt;model terms&gt;
where &lt;network&gt; is a <code><a href="network.html#topic+network">network</a></code> object
and &lt;model terms&gt; are <code>ergm-terms</code>.</p>
</td></tr>
<tr><td><code id="bergm_+3A_prior.mean">prior.mean</code></td>
<td>
<p>vector; 
mean vector of the multivariate Normal prior.
By default set to a vector of 0's.</p>
</td></tr>
<tr><td><code id="bergm_+3A_prior.sigma">prior.sigma</code></td>
<td>
<p>square matrix; 
variance/covariance matrix for the multivariate Normal prior.
By default set to a diagonal matrix with every diagonal entry equal to 100.</p>
</td></tr>
<tr><td><code id="bergm_+3A_burn.in">burn.in</code></td>
<td>
<p>count; 
number of burn-in iterations for every chain of the population.</p>
</td></tr>
<tr><td><code id="bergm_+3A_main.iters">main.iters</code></td>
<td>
<p>count; 
number of iterations for every chain of the population.</p>
</td></tr>
<tr><td><code id="bergm_+3A_aux.iters">aux.iters</code></td>
<td>
<p>count; 
number of auxiliary iterations used for network simulation.</p>
</td></tr>
<tr><td><code id="bergm_+3A_nchains">nchains</code></td>
<td>
<p>count; 
number of chains of the population MCMC.
By default set to twice the model dimension (number of model terms).</p>
</td></tr>
<tr><td><code id="bergm_+3A_gamma">gamma</code></td>
<td>
<p>scalar; 
parallel adaptive direction sampling move factor.</p>
</td></tr>
<tr><td><code id="bergm_+3A_v.proposal">V.proposal</code></td>
<td>
<p>count; 
diagonal entry for the multivariate Normal proposal.
By default set to 0.0025.</p>
</td></tr>
<tr><td><code id="bergm_+3A_startvals">startVals</code></td>
<td>
<p>vector;
optional starting values for the parameter estimation.</p>
</td></tr>
<tr><td><code id="bergm_+3A_offset.coef">offset.coef</code></td>
<td>
<p>vector;
A vector of coefficients for the offset terms.</p>
</td></tr>
<tr><td><code id="bergm_+3A_...">...</code></td>
<td>
<p>additional arguments, to be passed to lower-level functions.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Caimo, A. and Friel, N. (2011), &quot;Bayesian Inference for Exponential Random Graph Models,&quot;
Social Networks, 33(1), 41-55. <a href="https://arxiv.org/abs/1007.5192">https://arxiv.org/abs/1007.5192</a>
</p>
<p>Caimo, A. and Friel, N. (2014), &quot;Bergm: Bayesian Exponential Random Graphs in R,&quot;
Journal of Statistical Software, 61(2), 1-25. <a href="https://www.jstatsoft.org/article/view/v061i02">https://www.jstatsoft.org/article/view/v061i02</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Load the florentine marriage network
data(florentine)

# Posterior parameter estimation:
p.flo &lt;- bergm(flomarriage ~ edges + kstar(2),
               burn.in    = 50,
               aux.iters  = 500,
               main.iters = 3000,
               gamma      = 1.2)

# Posterior summaries:
summary(p.flo)

## End(Not run)
</code></pre>

<hr>
<h2 id='bergmC'>Calibrating misspecified Bayesian ERGMs</h2><span id='topic+bergmC'></span>

<h3>Description</h3>

<p>Function to transform a sample from the pseudo-posterior 
to one that is approximately sampled from the intractable 
posterior distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bergmC(
  formula,
  prior.mean = NULL,
  prior.sigma = NULL,
  burn.in = 10000,
  main.iters = 40000,
  aux.iters = 3000,
  V.proposal = 1.5,
  thin = 1,
  rm.iters = 500,
  rm.a = 0.001,
  rm.alpha = 0,
  n.aux.draws = 400,
  aux.thin = 50,
  estimate = c("MLE", "CD"),
  seed = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bergmC_+3A_formula">formula</code></td>
<td>
<p>formula; an <code><a href="ergm.html#topic+ergm">ergm</a></code> formula object,
of the form  &lt;network&gt; ~ &lt;model terms&gt;
where &lt;network&gt; is a <code><a href="network.html#topic+network">network</a></code> object
and &lt;model terms&gt; are <code>ergm-terms</code>.</p>
</td></tr>
<tr><td><code id="bergmC_+3A_prior.mean">prior.mean</code></td>
<td>
<p>vector; mean vector of the multivariate Normal prior.
By default set to a vector of 0's.</p>
</td></tr>
<tr><td><code id="bergmC_+3A_prior.sigma">prior.sigma</code></td>
<td>
<p>square matrix; variance/covariance matrix for the multivariate Normal prior.
By default set to a diagonal matrix with every diagonal entry equal to 100.</p>
</td></tr>
<tr><td><code id="bergmC_+3A_burn.in">burn.in</code></td>
<td>
<p>count; number of burn-in iterations at the beginning of an MCMC run for the pseudo-posterior estimation.</p>
</td></tr>
<tr><td><code id="bergmC_+3A_main.iters">main.iters</code></td>
<td>
<p>count; number of MCMC iterations after burn-in for the pseudo-posterior estimation.</p>
</td></tr>
<tr><td><code id="bergmC_+3A_aux.iters">aux.iters</code></td>
<td>
<p>count; number of auxiliary iterations used for drawing the first network from the ERGM likelihood (Robbins-Monro). See <code><a href="ergm.html#topic+control.simulate.formula">control.simulate.formula</a></code>.</p>
</td></tr>
<tr><td><code id="bergmC_+3A_v.proposal">V.proposal</code></td>
<td>
<p>count; diagonal entry for the multivariate Normal proposal.
By default set to 1.5.</p>
</td></tr>
<tr><td><code id="bergmC_+3A_thin">thin</code></td>
<td>
<p>count; thinning interval used in the simulation for the pseudo-posterior estimation. The number of MCMC iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="bergmC_+3A_rm.iters">rm.iters</code></td>
<td>
<p>count; number of iterations for the Robbins-Monro stochastic approximation algorithm.</p>
</td></tr>
<tr><td><code id="bergmC_+3A_rm.a">rm.a</code></td>
<td>
<p>scalar; constant for sequence alpha_n (Robbins-Monro).</p>
</td></tr>
<tr><td><code id="bergmC_+3A_rm.alpha">rm.alpha</code></td>
<td>
<p>scalar; noise added to gradient (Robbins-Monro).</p>
</td></tr>
<tr><td><code id="bergmC_+3A_n.aux.draws">n.aux.draws</code></td>
<td>
<p>count; number of auxiliary networks drawn from the ERGM likelihood (Robbins-Monro). See <code><a href="ergm.html#topic+control.simulate.formula">control.simulate.formula</a></code>.</p>
</td></tr>
<tr><td><code id="bergmC_+3A_aux.thin">aux.thin</code></td>
<td>
<p>count; number of auxiliary iterations between network draws after the first network is drawn (Robbins-Monro). See <code><a href="ergm.html#topic+control.simulate.formula">control.simulate.formula</a></code>.</p>
</td></tr>
<tr><td><code id="bergmC_+3A_estimate">estimate</code></td>
<td>
<p>If &quot;MLE&quot; (the default), then an approximate maximum likelihood estimator is used as a starting point in the Robbins-Monro algorithm. If &quot;CD&quot; , the Monte-Carlo contrastive divergence estimate is returned. See <code><a href="ergm.html#topic+ergm">ergm</a></code>.</p>
</td></tr>
<tr><td><code id="bergmC_+3A_seed">seed</code></td>
<td>
<p>integer; seed for the random number generator. See <code>set.seed</code>.</p>
</td></tr>
<tr><td><code id="bergmC_+3A_...">...</code></td>
<td>
<p>Additional arguments, to be passed to the ergm function. See <code><a href="ergm.html#topic+ergm">ergm</a></code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Bouranis, L., Friel, N., &amp; Maire, F. (2017). Efficient Bayesian inference for exponential 
random graph models by correcting the pseudo-posterior distribution. 
Social Networks, 50, 98-108. <a href="https://arxiv.org/abs/1510.00934">https://arxiv.org/abs/1510.00934</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Load the florentine marriage network
data(florentine)
                                 
# Calibrated pseudo-posterior:
cpp.flo &lt;- bergmC(flomarriage ~ edges + kstar(2),
                  aux.iters  = 500,
                  burn.in    = 500,
                  main.iters = 10000,
                  V.proposal = 2.5)

# Posterior summaries:
summary(cpp.flo)

## End(Not run)

</code></pre>

<hr>
<h2 id='bergmM'>Parameter estimation for Bayesian ERGMs under missing data</h2><span id='topic+bergmM'></span>

<h3>Description</h3>

<p>Function to fit Bayesian exponential random graphs models under missing data
using the approximate exchange algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bergmM(
  formula,
  burn.in = 100,
  main.iters = 1000,
  aux.iters = 1000,
  prior.mean = NULL,
  prior.sigma = NULL,
  nchains = NULL,
  gamma = 0.5,
  V.proposal = 0.0025,
  seed = NULL,
  startVals = NULL,
  offset.coef = NULL,
  nImp = NULL,
  missingUpdate = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bergmM_+3A_formula">formula</code></td>
<td>
<p>formula; an <code><a href="ergm.html#topic+ergm">ergm</a></code> formula object,
of the form  &lt;network&gt; ~ &lt;model terms&gt;
where &lt;network&gt; is a <code><a href="network.html#topic+network">network</a></code> object
and &lt;model terms&gt; are <code>ergm-terms</code>.</p>
</td></tr>
<tr><td><code id="bergmM_+3A_burn.in">burn.in</code></td>
<td>
<p>count; number of burn-in iterations for every chain of the population.</p>
</td></tr>
<tr><td><code id="bergmM_+3A_main.iters">main.iters</code></td>
<td>
<p>count; number of iterations for every chain of the population.</p>
</td></tr>
<tr><td><code id="bergmM_+3A_aux.iters">aux.iters</code></td>
<td>
<p>count; number of auxiliary iterations used for network simulation.</p>
</td></tr>
<tr><td><code id="bergmM_+3A_prior.mean">prior.mean</code></td>
<td>
<p>vector; mean vector of the multivariate Normal prior.
By default set to a vector of 0's.</p>
</td></tr>
<tr><td><code id="bergmM_+3A_prior.sigma">prior.sigma</code></td>
<td>
<p>square matrix; variance/covariance matrix for the multivariate Normal prior.
By default set to a diagonal matrix with every diagonal entry equal to 100.</p>
</td></tr>
<tr><td><code id="bergmM_+3A_nchains">nchains</code></td>
<td>
<p>count; number of chains of the population MCMC.
By default set to twice the model dimension (number of model terms).</p>
</td></tr>
<tr><td><code id="bergmM_+3A_gamma">gamma</code></td>
<td>
<p>scalar; parallel adaptive direction sampling move factor.</p>
</td></tr>
<tr><td><code id="bergmM_+3A_v.proposal">V.proposal</code></td>
<td>
<p>count; diagonal entry for the multivariate Normal proposal.
By default set to 0.0025.</p>
</td></tr>
<tr><td><code id="bergmM_+3A_seed">seed</code></td>
<td>
<p>count;
random number seed for the Bergm estimation.</p>
</td></tr>
<tr><td><code id="bergmM_+3A_startvals">startVals</code></td>
<td>
<p>vector;
optional starting values for the parameter estimation.</p>
</td></tr>
<tr><td><code id="bergmM_+3A_offset.coef">offset.coef</code></td>
<td>
<p>vector;
A vector of coefficients for the offset terms.</p>
</td></tr>
<tr><td><code id="bergmM_+3A_nimp">nImp</code></td>
<td>
<p>count;
number of imputed networks to be returned. If null, no imputed network will be returned.</p>
</td></tr>
<tr><td><code id="bergmM_+3A_missingupdate">missingUpdate</code></td>
<td>
<p>count;
number of tie updates in each imputation step. 
By default equal to number of missing ties. 
Smaller numbers increase speed. Larger numbers lead to better sampling.</p>
</td></tr>
<tr><td><code id="bergmM_+3A_...">...</code></td>
<td>
<p>additional arguments, to be passed to lower-level functions.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Caimo, A. and Friel, N. (2011), &quot;Bayesian Inference for Exponential Random Graph Models,&quot;
Social Networks, 33(1), 41-55. <a href="https://arxiv.org/abs/1007.5192">https://arxiv.org/abs/1007.5192</a>
</p>
<p>Caimo, A. and Friel, N. (2014), &quot;Bergm: Bayesian Exponential Random Graphs in R,&quot;
Journal of Statistical Software, 61(2), 1-25. <a href="https://www.jstatsoft.org/v61/i02">https://www.jstatsoft.org/v61/i02</a>
</p>
<p>Koskinen, J.H., Robins, G.L., Pattison, P.E. (2010), &quot;Analysing exponential
random graph (p-star) models with missing data using Bayesian data augmentation,&quot;
Statistical Methodology 7(3), 366-384.
</p>
<p>Krause, R.W., Huisman, M., Steglich, C., Snijders, T.A. (2020), &quot;Missing data in 
cross-sectional networks-An extensive comparison of missing data treatment methods&quot;, 
Social Networks 62: 99-112.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Load the florentine marriage network
data(florentine)

# Create missing data
set.seed(14021994)
n &lt;- dim(flomarriage[, ])[1]
missNode &lt;- sample(1:n, 1)
flomarriage[missNode, ] &lt;- NA
flomarriage[, missNode] &lt;- NA

# Posterior parameter estimation:
m.flo &lt;- bergmM(flomarriage ~ edges + kstar(2),
                burn.in    = 50,
                aux.iters  = 500,
                main.iters = 1000,
                gamma      = 1.2,
                nImp       = 5)

# Posterior summaries:
summary(m.flo)

## End(Not run)
</code></pre>

<hr>
<h2 id='bgof'>Bayesian goodness-of-fit diagnostics for ERGMs</h2><span id='topic+bgof'></span>

<h3>Description</h3>

<p>Function to calculate summaries for degree, 
minimum geodesic distances, 
and edge-wise shared partner distributions 
to diagnose the Bayesian goodness-of-fit of 
exponential random graph models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bgof(
  x,
  sample.size = 100,
  aux.iters = 10000,
  n.deg = NULL,
  n.dist = NULL,
  n.esp = NULL,
  n.ideg = NULL,
  n.odeg = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bgof_+3A_x">x</code></td>
<td>
<p>an <code>R</code> object of class <code>bergm</code>.</p>
</td></tr>
<tr><td><code id="bgof_+3A_sample.size">sample.size</code></td>
<td>
<p>count; number of networks 
to be simulated and compared to the observed network.</p>
</td></tr>
<tr><td><code id="bgof_+3A_aux.iters">aux.iters</code></td>
<td>
<p>count; number of iterations used for network simulation.</p>
</td></tr>
<tr><td><code id="bgof_+3A_n.deg">n.deg</code></td>
<td>
<p>count; used to plot only the first 
<code>n.deg</code>-1 degree distributions. 
By default no restrictions on the number of degree 
distributions is applied.</p>
</td></tr>
<tr><td><code id="bgof_+3A_n.dist">n.dist</code></td>
<td>
<p>count; used to plot only the first 
<code>n.dist</code>-1 geodesic distances distributions. 
By default no restrictions on the number of geodesic 
distances distributions is applied.</p>
</td></tr>
<tr><td><code id="bgof_+3A_n.esp">n.esp</code></td>
<td>
<p>count; used to plot only the first 
<code>n.esp</code>-1 edge-wise shared partner distributions. 
By default no restrictions on the number of 
edge-wise shared partner distributions is applied.</p>
</td></tr>
<tr><td><code id="bgof_+3A_n.ideg">n.ideg</code></td>
<td>
<p>count; used to plot only the first 
<code>n.ideg</code>-1 in-degree distributions. 
By default no restrictions on the number of 
in-degree distributions is applied.</p>
</td></tr>
<tr><td><code id="bgof_+3A_n.odeg">n.odeg</code></td>
<td>
<p>count; used to plot only the first 
<code>n.odeg</code>-1 out-degree distributions. 
By default no restrictions on the number of 
out-degree distributions is applied.</p>
</td></tr>
<tr><td><code id="bgof_+3A_...">...</code></td>
<td>
<p>additional arguments, 
to be passed to lower-level functions.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Caimo, A. and Friel, N. (2011), &quot;Bayesian Inference for Exponential Random Graph Models,&quot; 
Social Networks, 33(1), 41-55. <a href="https://arxiv.org/abs/1007.5192">https://arxiv.org/abs/1007.5192</a>
</p>
<p>Caimo, A. and Friel, N. (2014), &quot;Bergm: Bayesian Exponential Random Graphs in R,&quot; 
Journal of Statistical Software, 61(2), 1-25. <a href="https://www.jstatsoft.org/v61/i02">https://www.jstatsoft.org/v61/i02</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Load the florentine marriage network
data(florentine)

# Posterior parameter estimation:
p.flo &lt;- bergm(flomarriage ~ edges + kstar(2),
               burn.in    = 50,
               aux.iters  = 500,
               main.iters = 1000,
               gamma      = 1.2)

# Bayesian goodness-of-fit test:
bgof(p.flo,
     aux.iters   = 500,
     sample.size = 30,
     n.deg       = 10,
     n.dist      = 9,
     n.esp       = 6)

## End(Not run)
</code></pre>

<hr>
<h2 id='ergmAPL'>Adjustment of ERGM pseudolikelihood</h2><span id='topic+ergmAPL'></span>

<h3>Description</h3>

<p>Function to estimate the transformation parameters for
adjusting the pseudolikelihood function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergmAPL(
  formula,
  aux.iters = NULL,
  n.aux.draws = NULL,
  aux.thin = NULL,
  ladder = NULL,
  estimate = c("MLE", "CD"),
  seed = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ergmAPL_+3A_formula">formula</code></td>
<td>
<p>formula; an <code><a href="ergm.html#topic+ergm">ergm</a></code> formula object,
of the form  &lt;network&gt; ~ &lt;model terms&gt;
where &lt;network&gt; is a <code><a href="network.html#topic+network">network</a></code> object
and &lt;model terms&gt; are <code>ergm-terms</code>.</p>
</td></tr>
<tr><td><code id="ergmAPL_+3A_aux.iters">aux.iters</code></td>
<td>
<p>count; number of auxiliary iterations used for drawing the first network from the ERGM likelihood. See <code><a href="ergm.html#topic+control.simulate.formula">control.simulate.formula</a></code>.</p>
</td></tr>
<tr><td><code id="ergmAPL_+3A_n.aux.draws">n.aux.draws</code></td>
<td>
<p>count; Number of auxiliary networks drawn from the ERGM likelihood. See <code><a href="ergm.html#topic+control.simulate.formula">control.simulate.formula</a></code>.</p>
</td></tr>
<tr><td><code id="ergmAPL_+3A_aux.thin">aux.thin</code></td>
<td>
<p>count; Number of auxiliary iterations between network draws after the first network is drawn. See <code><a href="ergm.html#topic+control.simulate.formula">control.simulate.formula</a></code>.</p>
</td></tr>
<tr><td><code id="ergmAPL_+3A_ladder">ladder</code></td>
<td>
<p>count; Length of temperature ladder (&gt;=3).</p>
</td></tr>
<tr><td><code id="ergmAPL_+3A_estimate">estimate</code></td>
<td>
<p>If &quot;MLE&quot; (the default), then an approximate maximum likelihood estimator is returned. If &quot;CD&quot; , the Monte-Carlo contrastive divergence estimate is returned. See <code><a href="ergm.html#topic+ergm">ergm</a></code>.</p>
</td></tr>
<tr><td><code id="ergmAPL_+3A_seed">seed</code></td>
<td>
<p>integer; seed for the random number generator. See <code>set.seed</code>.</p>
</td></tr>
<tr><td><code id="ergmAPL_+3A_...">...</code></td>
<td>
<p>Additional arguments, to be passed to the ergm function. See <code><a href="ergm.html#topic+ergm">ergm</a></code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Bouranis, L., Friel, N., &amp; Maire, F. (2018). Bayesian model selection for exponential 
random graph models via adjusted pseudolikelihoods. 
Journal of Computational and Graphical Statistics, 27(3), 516-528. <a href="https://arxiv.org/abs/1706.06344">https://arxiv.org/abs/1706.06344</a>
</p>

<hr>
<h2 id='evidence'>Wrapper function for evidence estimation</h2><span id='topic+evidence'></span>

<h3>Description</h3>

<p>Function to estimate the evidence (marginal likelihood) with Chib and Jeliazkov's method
or Power posteriors, based on the adjusted pseudolikelihood function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evidence(evidence.method = c("CJ", "PP"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evidence_+3A_evidence.method">evidence.method</code></td>
<td>
<p>vector Method to estimate the marginal likelihood. Options are: <code>"CJ"</code>, in
which case the marginal likelihood is estimated with Chib and Jeliazkov's method; <code>"PP"</code>, in
which case the marginal likelihood is estimated with Power posteriors.</p>
</td></tr>
<tr><td><code id="evidence_+3A_...">...</code></td>
<td>
<p>further arguments to be passed.
See <code>evidenceCJ</code> and <code>evidencePP</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Bouranis, L., Friel, N., &amp; Maire, F. (2018). Bayesian model selection for exponential 
random graph models via adjusted pseudolikelihoods. 
Journal of Computational and Graphical Statistics, 27(3), 516-528. 
<a href="https://arxiv.org/abs/1706.06344">https://arxiv.org/abs/1706.06344</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Load the florentine marriage network:
data(florentine)
                                                
# MCMC sampling and evidence estimation:
CJE &lt;- evidence(evidence.method = "CJ",
                formula     = flomarriage ~ edges + kstar(2),
                main.iters  = 30000,
                burn.in     = 2000,
                aux.iters   = 1000,
                num.samples = 25000,
                V.proposal  = 2.5,
                ladder      = 100,
                seed        = 1)
                                   
# Posterior summaries:
summary(CJE)

# MCMC diagnostics plots:
plot(CJE)
    
# Log-evidence (marginal likelihood) estimate:
CJE$log.evidence

## End(Not run)

</code></pre>

<hr>
<h2 id='evidenceCJ'>Evidence estimation via Chib and Jeliazkov's method</h2><span id='topic+evidenceCJ'></span>

<h3>Description</h3>

<p>Function to estimate the evidence (marginal likelihood) with Chib and Jeliazkov's method, 
based on the adjusted pseudolikelihood function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evidenceCJ(
  formula,
  prior.mean = NULL,
  prior.sigma = NULL,
  aux.iters = 1000,
  n.aux.draws = 5,
  aux.thin = 50,
  ladder = 30,
  main.iters = 30000,
  burn.in = 5000,
  thin = 1,
  V.proposal = 1.5,
  num.samples = 25000,
  seed = 1,
  estimate = c("MLE", "CD"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evidenceCJ_+3A_formula">formula</code></td>
<td>
<p>formula; an <code><a href="ergm.html#topic+ergm">ergm</a></code> formula object,
of the form  &lt;network&gt; ~ &lt;model terms&gt;
where &lt;network&gt; is a <code><a href="network.html#topic+network">network</a></code> object
and &lt;model terms&gt; are <code>ergm-terms</code>.</p>
</td></tr>
<tr><td><code id="evidenceCJ_+3A_prior.mean">prior.mean</code></td>
<td>
<p>vector; 
mean vector of the multivariate Normal prior.
By default set to a vector of 0's.</p>
</td></tr>
<tr><td><code id="evidenceCJ_+3A_prior.sigma">prior.sigma</code></td>
<td>
<p>square matrix; 
variance/covariance matrix for the multivariate Normal prior.
By default set to a diagonal matrix with every diagonal entry equal to 100.</p>
</td></tr>
<tr><td><code id="evidenceCJ_+3A_aux.iters">aux.iters</code></td>
<td>
<p>count; 
number of auxiliary iterations used for drawing the first network from the ERGM likelihood. 
See <code><a href="ergm.html#topic+control.simulate.formula">control.simulate.formula</a></code> and <code><a href="#topic+ergmAPL">ergmAPL</a></code>.</p>
</td></tr>
<tr><td><code id="evidenceCJ_+3A_n.aux.draws">n.aux.draws</code></td>
<td>
<p>count; 
number of auxiliary networks drawn from the ERGM likelihood. 
See <code><a href="ergm.html#topic+control.simulate.formula">control.simulate.formula</a></code> and <code><a href="#topic+ergmAPL">ergmAPL</a></code>.</p>
</td></tr>
<tr><td><code id="evidenceCJ_+3A_aux.thin">aux.thin</code></td>
<td>
<p>count; 
number of auxiliary iterations between network draws after the first network is drawn. 
See <code><a href="ergm.html#topic+control.simulate.formula">control.simulate.formula</a></code> and <code><a href="#topic+ergmAPL">ergmAPL</a></code>.</p>
</td></tr>
<tr><td><code id="evidenceCJ_+3A_ladder">ladder</code></td>
<td>
<p>count; length of temperature ladder (&gt;=3). 
See <code><a href="#topic+ergmAPL">ergmAPL</a></code>.</p>
</td></tr>
<tr><td><code id="evidenceCJ_+3A_main.iters">main.iters</code></td>
<td>
<p>count; 
number of MCMC iterations after burn-in for the adjusted pseudo-posterior estimation.</p>
</td></tr>
<tr><td><code id="evidenceCJ_+3A_burn.in">burn.in</code></td>
<td>
<p>count; 
number of burn-in iterations at the beginning of an MCMC run 
for the adjusted pseudo-posterior estimation.</p>
</td></tr>
<tr><td><code id="evidenceCJ_+3A_thin">thin</code></td>
<td>
<p>count; 
thinning interval used in the simulation for the adjusted pseudo-posterior estimation. 
The number of MCMC iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="evidenceCJ_+3A_v.proposal">V.proposal</code></td>
<td>
<p>count; 
diagonal entry for the multivariate Normal proposal.
By default set to 1.5.</p>
</td></tr>
<tr><td><code id="evidenceCJ_+3A_num.samples">num.samples</code></td>
<td>
<p>integer; 
number of samples used in the marginal likelihood estimate. 
Must be lower than <code>main.iters</code> - <code>burnin</code>.</p>
</td></tr>
<tr><td><code id="evidenceCJ_+3A_seed">seed</code></td>
<td>
<p>integer; seed for the random number generator. 
See <code>set.seed</code> and <code><a href="MCMCpack.html#topic+MCMCmetrop1R">MCMCmetrop1R</a></code>.</p>
</td></tr>
<tr><td><code id="evidenceCJ_+3A_estimate">estimate</code></td>
<td>
<p>If &quot;MLE&quot; (the default), then an approximate maximum likelihood estimator is returned. If &quot;CD&quot; , the Monte-Carlo contrastive divergence estimate is returned. See <code><a href="ergm.html#topic+ergm">ergm</a></code>.</p>
</td></tr>
<tr><td><code id="evidenceCJ_+3A_...">...</code></td>
<td>
<p>additional arguments, to be passed to the ergm function. 
See <code><a href="ergm.html#topic+ergm">ergm</a></code> and <code><a href="#topic+ergmAPL">ergmAPL</a></code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Caimo, A., &amp; Friel, N. (2013). Bayesian model selection for exponential random graph models. 
Social Networks, 35(1), 11-24. <a href="https://arxiv.org/abs/1201.2337">https://arxiv.org/abs/1201.2337</a>
</p>
<p>Bouranis, L., Friel, N., &amp; Maire, F. (2018). Bayesian model selection for exponential 
random graph models via adjusted pseudolikelihoods. 
Journal of Computational and Graphical Statistics, 27(3), 516-528. 
<a href="https://arxiv.org/abs/1706.06344">https://arxiv.org/abs/1706.06344</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Load the florentine marriage network:
data(florentine)
                                                
# MCMC sampling and evidence estimation:
CJE &lt;- evidenceCJ(flomarriage ~ edges + kstar(2),
                  main.iters  = 2000,
                  burn.in     = 200,
                  aux.iters   = 500,
                  num.samples = 25000,
                  V.proposal  = 2.5)
                                   
# Posterior summaries:
summary(CJE)

# MCMC diagnostics plots:
plot(CJE)
    
# Log-evidence (marginal likelihood) estimate:
CJE$log.evidence

## End(Not run)

</code></pre>

<hr>
<h2 id='evidencePP'>Evidence estimation via power posteriors</h2><span id='topic+evidencePP'></span>

<h3>Description</h3>

<p>Function to estimate the evidence (marginal likelihood) with Power posteriors, 
based on the adjusted pseudolikelihood function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evidencePP(
  formula,
  prior.mean = NULL,
  prior.sigma = NULL,
  aux.iters = 1000,
  n.aux.draws = 50,
  aux.thin = 50,
  ladder = 30,
  main.iters = 20000,
  burn.in = 5000,
  thin = 1,
  V.proposal = 1.5,
  seed = 1,
  temps = NULL,
  estimate = c("MLE", "CD"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evidencePP_+3A_formula">formula</code></td>
<td>
<p>formula; an <code><a href="ergm.html#topic+ergm">ergm</a></code> formula object,
of the form  &lt;network&gt; ~ &lt;model terms&gt;
where &lt;network&gt; is a <code><a href="network.html#topic+network">network</a></code> object
and &lt;model terms&gt; are <code>ergm-terms</code>.</p>
</td></tr>
<tr><td><code id="evidencePP_+3A_prior.mean">prior.mean</code></td>
<td>
<p>vector; mean vector of the multivariate Normal prior.
By default set to a vector of 0's.</p>
</td></tr>
<tr><td><code id="evidencePP_+3A_prior.sigma">prior.sigma</code></td>
<td>
<p>square matrix; variance/covariance matrix for the multivariate Normal prior.
By default set to a diagonal matrix with every diagonal entry equal to 100.</p>
</td></tr>
<tr><td><code id="evidencePP_+3A_aux.iters">aux.iters</code></td>
<td>
<p>count; number of auxiliary iterations used for drawing the first network from the ERGM likelihood. See <code><a href="ergm.html#topic+control.simulate.formula">control.simulate.formula</a></code> and <code><a href="#topic+ergmAPL">ergmAPL</a></code>.</p>
</td></tr>
<tr><td><code id="evidencePP_+3A_n.aux.draws">n.aux.draws</code></td>
<td>
<p>count; number of auxiliary networks drawn from the ERGM likelihood. See <code><a href="ergm.html#topic+control.simulate.formula">control.simulate.formula</a></code> and <code><a href="#topic+ergmAPL">ergmAPL</a></code>.</p>
</td></tr>
<tr><td><code id="evidencePP_+3A_aux.thin">aux.thin</code></td>
<td>
<p>count; number of auxiliary iterations between network draws after the first network is drawn. See <code><a href="ergm.html#topic+control.simulate.formula">control.simulate.formula</a></code> and <code><a href="#topic+ergmAPL">ergmAPL</a></code>.</p>
</td></tr>
<tr><td><code id="evidencePP_+3A_ladder">ladder</code></td>
<td>
<p>count; length of temperature ladder (&gt;=3). See <code><a href="#topic+ergmAPL">ergmAPL</a></code>.</p>
</td></tr>
<tr><td><code id="evidencePP_+3A_main.iters">main.iters</code></td>
<td>
<p>count; number of MCMC iterations after burn-in for the adjusted pseudo-posterior estimation.</p>
</td></tr>
<tr><td><code id="evidencePP_+3A_burn.in">burn.in</code></td>
<td>
<p>count; number of burn-in iterations at the beginning of an MCMC run for the adjusted pseudo-posterior estimation.</p>
</td></tr>
<tr><td><code id="evidencePP_+3A_thin">thin</code></td>
<td>
<p>count; thinning interval used in the simulation for the adjusted pseudo-posterior estimation. The number of MCMC iterations must be divisible by this value.</p>
</td></tr>
<tr><td><code id="evidencePP_+3A_v.proposal">V.proposal</code></td>
<td>
<p>count; diagonal entry for the multivariate Normal proposal.
By default set to 1.5.</p>
</td></tr>
<tr><td><code id="evidencePP_+3A_seed">seed</code></td>
<td>
<p>integer; seed for the random number generator. 
See <code>set.seed</code> and <code><a href="MCMCpack.html#topic+MCMCmetrop1R">MCMCmetrop1R</a></code>.</p>
</td></tr>
<tr><td><code id="evidencePP_+3A_temps">temps</code></td>
<td>
<p>numeric vector; inverse temperature ladder, <code class="reqn">t \in [0,1]</code>.</p>
</td></tr>
<tr><td><code id="evidencePP_+3A_estimate">estimate</code></td>
<td>
<p>If &quot;MLE&quot; (the default), then an approximate maximum likelihood estimator is returned. If &quot;CD&quot; , the Monte-Carlo contrastive divergence estimate is returned. See <code><a href="ergm.html#topic+ergm">ergm</a></code>.</p>
</td></tr>
<tr><td><code id="evidencePP_+3A_...">...</code></td>
<td>
<p>additional arguments, to be passed to the ergm function. 
See <code><a href="ergm.html#topic+ergm">ergm</a></code> and <code><a href="#topic+ergmAPL">ergmAPL</a></code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Bouranis, L., Friel, N., &amp; Maire, F. (2018). Bayesian model selection for exponential 
random graph models via adjusted pseudolikelihoods. 
Journal of Computational and Graphical Statistics, 27(3), 516-528. 
<a href="https://arxiv.org/abs/1706.06344">https://arxiv.org/abs/1706.06344</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Load the florentine marriage network:
data(florentine)

PPE &lt;- evidencePP(flomarriage ~ edges + kstar(2),
                  aux.iters   = 500, 
                  aux.thin    = 50,   
                  main.iters  = 2000,
                  burn.in     = 100,
                  V.proposal  = 2.5)
                                   
# Posterior summaries:
summary(PPE)

# MCMC diagnostics plots:
plot(PPE)
  
# Log-evidence (marginal likelihood) estimate:             
PPE$log.evidence

## End(Not run)

</code></pre>

<hr>
<h2 id='lazega'>Lazega lawyers network data</h2><span id='topic+lazega'></span>

<h3>Description</h3>

<p>Lazega lawyers network data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lazega
</code></pre>


<h3>Format</h3>

<p>An oject of class <code>network</code>.
</p>


<h3>Source</h3>

<p>This network dataset comes from a network study of corporate law partnership 
that was carried out in a Northeastern US corporate law firm 
in New England from 1988 to 1991. It represents collaborative relations 
among the 36 attorneys (partners and associates) of this firm.
Nodal attributes include: Age, Gender, Office, Practice, School, and Years.
</p>


<h3>References</h3>

<p>Lazega, E. (2001), &quot;The Collegial Phenomenon: 
The Social Mechanisms of Cooperation Among Peers in a 
Corporate Law Partnership,&quot; Oxford University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 par(mfrow = c(1, 2), oma = rep(0, 4))
 CC &lt;- hcl.colors(3, "Teal")
 set.seed(22)
 plot(lazega,
      vertex.col = CC[lazega %v% "Office"], 
     vertex.cex = 2)
 legend("topright",
        pch    = 21,
        pt.bg  = CC,
        legend = c("Boston", "Hartford", "Providence"),
        title  = "OFFICE")

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.bergm'>Plot BERGM posterior output</h2><span id='topic+plot.bergm'></span>

<h3>Description</h3>

<p>This function creates  MCMC diagnostic plots for <code>bergm</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bergm'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.bergm_+3A_x">x</code></td>
<td>
<p>an <code>R</code> object of class <code>bergm</code>.</p>
</td></tr>
<tr><td><code id="plot.bergm_+3A_...">...</code></td>
<td>
<p>additional arguments, to be passed to lower-level functions.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Load the florentine marriage network
data(florentine)

# Posterior parameter estimation:
p.flo &lt;- bergm(flomarriage ~ edges + kstar(2),
               burn.in    = 50,
               aux.iters  = 500,
               main.iters = 1000,
               gamma      = 1.2)

# MCMC diagnostics plots:
plot(p.flo)

## End(Not run)

</code></pre>

<hr>
<h2 id='summary.bergm'>Summary of BERGM posterior output</h2><span id='topic+summary.bergm'></span>

<h3>Description</h3>

<p>This function summarises MCMC output for <code>bergm</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bergm'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.bergm_+3A_object">object</code></td>
<td>
<p>an <code>R</code> object of class <code>bergm</code>.</p>
</td></tr>
<tr><td><code id="summary.bergm_+3A_...">...</code></td>
<td>
<p>additional arguments, to be passed to lower-level functions.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
