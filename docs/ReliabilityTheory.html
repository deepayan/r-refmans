<!DOCTYPE html><html><head><title>Help for package ReliabilityTheory</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ReliabilityTheory}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cnO2'><p>Catalogue of Coherent Networks of Order 2</p></a></li>
<li><a href='#cnO3'><p>Catalogue of Coherent Networks of Order 3</p></a></li>
<li><a href='#computeSystemSignature'><p>Compute the signature of a system</p></a></li>
<li><a href='#computeSystemSurvivalSignature'><p>Compute the survival signature of a system</p></a></li>
<li><a href='#createSystem'>
<p>Create a system specification</p></a></li>
<li><a href='#expectedSystemLifetimeExp'><p>Compute the expected lifetime of a given system</p></a></li>
<li><a href='#maskedInferenceEXCHCustom'><p>Inference for Masked Exchangeable System Lifetimes, Custom Distribution</p></a></li>
<li><a href='#maskedInferenceEXCHExponential'><p>Inference for Masked Exchangeable System Lifetimes, Exponential Components</p></a></li>
<li><a href='#maskedInferenceIIDCustom'><p>Inference for Masked iid System Lifetimes, Custom Distribution</p></a></li>
<li><a href='#maskedInferenceIIDExponential'><p>Inference for Masked iid System Lifetimes, Exponential Components</p></a></li>
<li><a href='#nonParBayesSystemInference'><p>Non-parametric Bayesian posterior predictive system survival inference</p></a></li>
<li><a href='#nonParBayesSystemInferencePriorSets'><p>Non-parametric Bayesian posterior predictive system survival inference using sets of priors</p></a></li>
<li><a href='#ReliabilityTheory-package'><p>Structural Reliability Theory Toolbox</p></a></li>
<li><a href='#sccsO2'><p>Catalogue of Simply Connected Coherent Systems of Order 2</p></a></li>
<li><a href='#sccsO3'><p>Catalogue of Simply Connected Coherent Systems of Order 3</p></a></li>
<li><a href='#sccsO4'><p>Catalogue of Simply Connected Coherent Systems of Order 4</p></a></li>
<li><a href='#sccsO5'><p>Catalogue of Simply Connected Coherent Systems of Order 5</p></a></li>
<li><a href='#setCompTypes'>
<p>Set component types in a system</p></a></li>
<li><a href='#simulateSystem'><p>Simulate Masked Lifetime Data for a System</p></a></li>
<li><a href='#systemGraphToGenerator'><p>Construct a Continuous-time Markov Chain Generator</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Structural Reliability Analysis</td>
</tr>
<tr>
<td>Description:</td>
<td>Perform structural reliability analysis, including computation and
    simulation with system signatures, Samaniego (2007)
    &lt;<a href="https://doi.org/10.1007%2F978-0-387-71797-5">doi:10.1007/978-0-387-71797-5</a>&gt;, and survival signatures, Coolen and
    Coolen-Maturi (2013) &lt;<a href="https://doi.org/10.1007%2F978-3-642-30662-4_8">doi:10.1007/978-3-642-30662-4_8</a>&gt;. Additionally
    supports parametric and topological inference given system lifetime data,
    Aslett (2012) <a href="https://www.louisaslett.com/PhD_Thesis.pdf">https://www.louisaslett.com/PhD_Thesis.pdf</a>.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.louisaslett.com/">https://www.louisaslett.com/</a>,
<a href="https://github.com/louisaslett/ReliabilityTheory">https://github.com/louisaslett/ReliabilityTheory</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/louisaslett/ReliabilityTheory/issues">https://github.com/louisaslett/ReliabilityTheory/issues</a></td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Louis Aslett &lt;louis.aslett@durham.ac.uk&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>actuar, combinat, FRACTION, igraph (&ge; 1.0.1), mcmc, PhaseType
(&ge; 0.2.0), sfsmisc, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, reshape2, ggplot2, xtable</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-16 16:50:34 UTC; louis</td>
</tr>
<tr>
<td>Author:</td>
<td>Louis Aslett [aut, cre, cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-17 21:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cnO2'>Catalogue of Coherent Networks of Order 2</h2><span id='topic+cnO2'></span>

<h3>Description</h3>

<p>This data set provides a catalogue of the network graph, signature and minimal cut-sets of all coherent networks of node order 2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cnO2)</code></pre>


<h3>Format</h3>

<p>A list object, one item for each such network.  Each item is itself a list, with the elements <code>$graph</code>, <code>$cutsets</code> and <code>$signature</code>.</p>


<h3>Source</h3>

<p>Derived in the thesis Aslett (2012).</p>


<h3>References</h3>

<p>Aslett, L. J. M. (2012), <em>MCMC for Inference on Phase-type and Masked System Lifetime Models</em>, PhD Thesis, Trinity College Dublin.
</p>

<hr>
<h2 id='cnO3'>Catalogue of Coherent Networks of Order 3</h2><span id='topic+cnO3'></span>

<h3>Description</h3>

<p>This data set provides a catalogue of the network graph, signature and minimal cut-sets of all coherent networks of node order 3.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cnO3)</code></pre>


<h3>Format</h3>

<p>A list object, one item for each such network.  Each item is itself a list, with the elements <code>$graph</code>, <code>$cutsets</code> and <code>$signature</code>.</p>


<h3>Source</h3>

<p>Derived in the thesis Aslett (2012).</p>


<h3>References</h3>

<p>Aslett, L. J. M. (2012), <em>MCMC for Inference on Phase-type and Masked System Lifetime Models</em>, PhD Thesis, Trinity College Dublin.
</p>

<hr>
<h2 id='computeSystemSignature'>Compute the signature of a system</h2><span id='topic+computeSystemSignature'></span><span id='topic+computeNetworkSignature'></span>

<h3>Description</h3>

<p>The system signature (Samaniego, 2007) is an alternative to the structure function as a starting point for a structural reliability analysis.  This automatically computes the signature of the specified system or network.  Here, system implies components are unreliable whereas network implies links are unreliable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeSystemSignature(sys, cutsets=NULL, frac=FALSE)
computeNetworkSignature(sys, cutsets=NULL, frac=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeSystemSignature_+3A_sys">sys</code></td>
<td>

<p>a <code>system</code> object representing the system whose types are to be set.  This should have been created by a call to <code><a href="#topic+createSystem">createSystem</a></code>.
</p>
</td></tr>
<tr><td><code id="computeSystemSignature_+3A_cutsets">cutsets</code></td>
<td>

<p>if the cut-sets of the system or network are already known they may be passed in as a list of numeric vectors.  This can save time because cut-set computation is the slowest part of the algorithm.  Leaving as NULL causes the function to find the cut sets itself.
</p>
</td></tr>
<tr><td><code id="computeSystemSignature_+3A_frac">frac</code></td>
<td>

<p>if TRUE then the function prints out signature elements as fractions rather than returning a decimal signature vector.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The signature of a system is the probability vector <code class="reqn">\mathbf{s}=(s_1, \dots, s_n)</code> with elements:
</p>
<p style="text-align: center;"><code class="reqn">s_i = P(T = T_{i:n})</code>
</p>

<p>where <code class="reqn">T</code> is the failure time of the system and <code class="reqn">T_{i:n}</code> is the ith order statistic of the n component failure times.  Likewise the network signature is the same but where components are reliable and it is links which fail.  See Samaniego (2007) for details.
</p>
<p>The system or network is specified by means of a <code><a href="base.html#topic+system">system</a></code> object, whereby each end of the system is denoted by nodes named <code>s</code> and <code>t</code> which are taken to be perfectly reliable.  It is easy to construct the appropriate reliability block diagram representation using the function <code><a href="#topic+createSystem">createSystem</a></code>.  Note that each physically distinct component should be separately numbered when constructing this object.
</p>


<h3>Value</h3>

<p><code>computeSystemSignature</code> returns a numeric probability vector which is the system/network signature.
</p>


<h3>Note</h3>

<p>Please feel free to email <a href="mailto:louis.aslett@durham.ac.uk">louis.aslett@durham.ac.uk</a> with any queries or if you encounter errors when running this function.
</p>


<h3>Author(s)</h3>

<p>Louis J.M. Aslett <a href="mailto:louis.aslett@durham.ac.uk">louis.aslett@durham.ac.uk</a> (<a href="https://www.louisaslett.com/">https://www.louisaslett.com/</a>)
</p>


<h3>References</h3>

<p>Samaniego, F. J. (2007), <em>System Signatures and Their Applications in Engineering Reliability</em>, Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+computeSystemSurvivalSignature">computeSystemSurvivalSignature</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Find the signature of two component series system (which is just s=(1, 0))
computeSystemSignature(createSystem(s -- 1 -- 2 -- t))

# Find the signature of two component parallel system (which is just s=(0, 1))
computeSystemSignature(createSystem(s -- 1:2 -- t))

# Find the signature of the five component 'bridge' system (which
# is s=(0, 0.2, 0.6, 0.2, 0))
computeSystemSignature(createSystem(s -- 1 -- 2 -- t, s -- 3 -- 4 -- t, 1:2 -- 5 -- 3:4))
</code></pre>

<hr>
<h2 id='computeSystemSurvivalSignature'>Compute the survival signature of a system</h2><span id='topic+computeSystemSurvivalSignature'></span>

<h3>Description</h3>

<p>The system survival signature (Coolen and Coolen-Maturi, 2012) is a generalisation of the signature to systems with multiple component types.  This function automatically computes the survival signature of the specified system.  Here, system implies components (as opposed to links) are unreliable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeSystemSurvivalSignature(sys, cutsets=NULL, frac=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeSystemSurvivalSignature_+3A_sys">sys</code></td>
<td>

<p>a <code>system</code> object representing the system whose types are to be set.  This should have been created by a call to <code><a href="#topic+createSystem">createSystem</a></code>.
</p>
</td></tr>
<tr><td><code id="computeSystemSurvivalSignature_+3A_cutsets">cutsets</code></td>
<td>

<p>if the cut-sets of the system or network are already known they may be passed in as a list of numeric vectors.  This can save time because cut-set computation is the slowest part of the algorithm.  Leaving as NULL causes the function to find the cut sets itself.
</p>
</td></tr>
<tr><td><code id="computeSystemSurvivalSignature_+3A_frac">frac</code></td>
<td>

<p>if TRUE then the function prints out survival signature probabilities as fractions rather than decimals.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The survival signature of a system with <code class="reqn">K</code> types of component is the functional <code class="reqn">\Phi(l_1, \dots, l_K)</code> giving the probability that the system works given exactly <code class="reqn">l_k</code> of the components of type <code class="reqn">k</code> are working.  See Coolen and Coolen-Maturi (2012) for details.  Thus, the survival signature can be represented by a table with <code class="reqn">K+1</code> columns, the first <code class="reqn">K</code> being the number of each type of component which is working and the final column being the probability the system works.
</p>
<p>The system or network is specified by means of a <code><a href="base.html#topic+system">system</a></code> object, whereby each end of the system is denoted by nodes named <code>s</code> and <code>t</code> which are taken to be perfectly reliable.  It is easy to construct the appropriate reliability block diagram representation using the function <code><a href="#topic+createSystem">createSystem</a></code>.  Note that each physically distinct component should be separately numbered when constructing this object.
</p>
<p>Once the topology of the system has been defined (or at definition time), one must indicate the type of each component (if not done when initially calling <code><a href="#topic+createSystem">createSystem</a></code> it can later be modified using <code><a href="#topic+setCompTypes">setCompTypes</a></code>).  The Examples section below features the full computation of the survival signature for Figure 1 in Coolen and Coolen-Maturi (2012) and Figure 2 in Coolen <em>et al</em> (2013) to make this clear.
</p>


<h3>Value</h3>

<p><code>computeSystemSurvivalSignature</code> returns a data frame with <code class="reqn">K+1</code> columns.  The first <code class="reqn">K</code> columns represent the function inputs, <code class="reqn">l_1, \dots, l_K</code> and the final column is the probability that the system works given the corresponding numbers of each component which are working.
</p>


<h3>Note</h3>

<p>Please feel free to email <a href="mailto:louis.aslett@durham.ac.uk">louis.aslett@durham.ac.uk</a> with any queries or if you encounter errors when running this function.
</p>


<h3>Author(s)</h3>

<p>Louis J. M. Aslett <a href="mailto:louis.aslett@durham.ac.uk">louis.aslett@durham.ac.uk</a> (<a href="https://www.louisaslett.com/">https://www.louisaslett.com/</a>)
</p>


<h3>References</h3>

<p>Coolen, F. P. A. and Coolen-Maturi, T. (2012), Generalizing the signature to systems with multiple types of components, <em>in</em> 'Complex Systems and Dependability', Springer, pp. 115-130.
</p>
<p>Coolen, F. P. A., Coolen-Maturi, T., Al-nefaiee, A. H. and Aboalkhair, A. M. (2013), &lsquo;Recent advances in system reliability using the survival signature&rsquo;, <em>Proceedings of Advances in Risk and Reliability Technology Symposium, Loughborough</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+computeSystemSignature">computeSystemSignature</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## EXAMPLE 1
## Figure 1 in Coolen and Coolen-Maturi (2012)

# First, define the structure, ensuring that each physically separate component
# is separately numbered
fig1 &lt;- createSystem(s -- 1 -- 2:3 -- 4 -- 5:6 -- t, 2 -- 5, 3 -- 6)

# Second, specify the type of each of those numbered components
# (leaving s,t with no type)
fig1 &lt;- setCompTypes(fig1,
                     list("Type 1" = c("1","2","5"),
                          "Type 2" = c("3","4","6")))

# Third, compute the survival signature (getting fractions rather than decimals)
computeSystemSurvivalSignature(fig1, frac = TRUE)



## EXAMPLE 2
## Figure 3 in Coolen et al (2013)

# First, define the structure, ensuring that each physically separate component
# is separately numbered.
# For this example, we demonstrate how to define the component types at system
# creation time
fig3 &lt;- createSystem(s -- 1:4 -- 2:5 -- 3:6 -- t, s -- 7:8, 8 -- 9, 7:9 -- t,
                     types = list("Type 1" = "1",
                                  "Type 2" = c("2","3","4","7"),
                                  "Type 3" = c("5","6","8","9")))

# Third, compute the survival signature (getting fractions rather than decimals)
computeSystemSurvivalSignature(fig3, frac=TRUE)
</code></pre>

<hr>
<h2 id='createSystem'>
Create a system specification
</h2><span id='topic+createSystem'></span>

<h3>Description</h3>

<p>Creates a system design specification based on passing a textual representation of design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createSystem(..., types = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createSystem_+3A_...">...</code></td>
<td>

<p>multiple expressions which together define an undirected graph representation of the reliability block diagram for the system design. There should be two terminal &lsquo;dummy&rsquo; nodes to represent either end of the system structure, which must be labelled <code>s</code> and <code>t</code> (assumed perfectly reliable).  All reliability assessment is of the connectivity of these nodes.  See details and examples.
</p>
</td></tr>
<tr><td><code id="createSystem_+3A_types">types</code></td>
<td>

<p>(optional) named list of vectors. The names correspond to component types, whilst each vector indicates which components are of that type. When it is not specified then all components are assumed to be of the same type. This can be updated later using the function <code><a href="#topic+setCompTypes">setCompTypes</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function enables specification of a system design by textual representation of the reliability block diagram, for use in many other functions in this package.  The method of representing the system is as for an undirected graph in the <span class="pkg">igraph</span> package.
</p>
<p>There should be two terminal &lsquo;dummy&rsquo; nodes to represent either end of the system structure, which must be labelled <code>s</code> and <code>t</code> (assumed perfectly reliable). Dashes <code>--</code> are then used to connect numbered nodes together.  The full specification can be spread over multiple arguments.  Colon notation can denote an edge to multiple nodes, but is <em>not</em> a range specifier (eg <code>1:5</code> means components 1 and 5, not components 1 to 5).  Following are some concrete examples:
</p>

<ol>
<li><p> a series system of 3 components:
</p>
<p><code>createSystem(s -- 1 -- 2 -- 3 -- t)</code>
</p>
</li>
<li><p> a parallel system of 3 components:
</p>
<p><code>createSystem(s -- 1 -- t, s -- 2 -- t, s -- 3 -- t)</code>
</p>
<p>Or, more succinctly:
</p>
<p><code>createSystem(s -- 1:2:3 -- t)</code>
</p>
</li>
<li><p> a classic &lsquo;bridge&rsquo; system consisting of 5 components:
</p>
<p><code>createSystem(s -- 1:2 -- 5 -- 3:4 -- t, 1 -- 3, 2 -- 4)</code>
</p>
<p>Exactly equivalently:
</p>
<p><code>createSystem(s -- 1 -- 3 -- t, s -- 2 -- 4 -- t, 1:2 -- 5 -- 3:4)</code>
</p>
</li></ol>



<h3>Value</h3>

<p>Returns a system of the design specified.
</p>
<p>Internally, this is an <span class="pkg">igraph</span> object, with some additional attributes relevant to system specification.
</p>


<h3>Author(s)</h3>

<p>Louis J.M. Aslett <a href="mailto:louis.aslett@durham.ac.uk">louis.aslett@durham.ac.uk</a> (<a href="https://www.louisaslett.com/">https://www.louisaslett.com/</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+setCompTypes">setCompTypes</a></code> to specify component types after system creation, rather than in the same command.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a bridge system, with all components of the same type (or with type to
# be defined later)
bridge &lt;- createSystem(s -- 1:2 -- 5 -- 3:4 -- t, 1 -- 3, 2 -- 4)

# Create a bridge system, with two types of component
bridge &lt;- createSystem(s -- 1:2 -- 5 -- 3:4 -- t, 1 -- 3, 2 -- 4,
                       types = list(T1 = 1:4, T2 = 5))
</code></pre>

<hr>
<h2 id='expectedSystemLifetimeExp'>Compute the expected lifetime of a given system</h2><span id='topic+expectedSystemLifetimeExp'></span><span id='topic+expectedNetworkLifetimeExp'></span><span id='topic+expectedSignatureLifetimeExp'></span>

<h3>Description</h3>

<p>Computes the expected lifetime of a system/network specified by its signature or graph structure when the components have Exponential lifetime distribution with specified rate.  Useful for ordering systems/networks by expected lifetime.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expectedSystemLifetimeExp(sys, rate=1)
expectedNetworkLifetimeExp(sys, rate=1)
expectedSignatureLifetimeExp(s, rate=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expectedSystemLifetimeExp_+3A_sys">sys</code></td>
<td>

<p>a <code>system</code> object representing the system whose types are to be set.  This should have been created by a call to <code><a href="#topic+createSystem">createSystem</a></code>.
</p>
</td></tr>
<tr><td><code id="expectedSystemLifetimeExp_+3A_s">s</code></td>
<td>

<p>the signature vector of the system/network whose expected lifetime is to be computed.
</p>
</td></tr>
<tr><td><code id="expectedSystemLifetimeExp_+3A_rate">rate</code></td>
<td>

<p>the rate parameter of the Exponential distribution.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The system or network is specified by means of a <code><a href="base.html#topic+system">system</a></code> object, whereby each end of the system is denoted by nodes named <code>s</code> and <code>t</code> which are taken to be perfectly reliable.  It is easy to construct the appropriate reliability block diagram representation using the function <code><a href="#topic+createSystem">createSystem</a></code>.  Note that each physically distinct component should be separately numbered when constructing this object.
</p>
<p>Alternatively, the signature may be provided instead (the other functions simply use the graph object to compute the signature).
</p>


<h3>Value</h3>

<p>All the functions return a single scalar value which is the expected lifetime.
</p>


<h3>Note</h3>

<p>Please feel free to email <a href="mailto:louis.aslett@durham.ac.uk">louis.aslett@durham.ac.uk</a> with any queries or if you encounter errors when running this function.
</p>


<h3>Author(s)</h3>

<p>Louis J.M. Aslett <a href="mailto:louis.aslett@durham.ac.uk">louis.aslett@durham.ac.uk</a> (<a href="https://www.louisaslett.com/">https://www.louisaslett.com/</a>)
</p>


<h3>References</h3>

<p>Samaniego, F. J. (2007), <em>System Signatures and Their Applications in Engineering Reliability</em>, Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+computeSystemSignature">computeSystemSignature</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Find the expected lifetime of two component series system
expectedSystemLifetimeExp(createSystem(s -- 1 -- 2 -- t))

# Find the expected lifetime of two component series system using it's signature
# directly
expectedSignatureLifetimeExp(c(1,0))

# Find the expected lifetime of two component parallel system
expectedSystemLifetimeExp(createSystem(s -- 1:2 -- t))

# Find the expected lifetime of two component parallel system using it's
# signature directly
expectedSignatureLifetimeExp(c(0,1))
</code></pre>

<hr>
<h2 id='maskedInferenceEXCHCustom'>Inference for Masked Exchangeable System Lifetimes, Custom Distribution</h2><span id='topic+maskedInferenceEXCHCustom'></span>

<h3>Description</h3>

<p>Performs Bayesian inference via a signature based data augmentation MCMC scheme for masked system lifetime data for any custom component lifetime distribution.  The underlying assumption is of exchangeability at the system level (iid components within each exchangeable system).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maskedInferenceEXCHCustom(t, signature, cdfComp, pdfComp, rParmGivenData,
                          rCompGivenParm, startCompParm, startHypParm, iter, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maskedInferenceEXCHCustom_+3A_t">t</code></td>
<td>

<p>a vector of masked system lifetimes.
</p>
</td></tr>
<tr><td><code id="maskedInferenceEXCHCustom_+3A_signature">signature</code></td>
<td>

<p>the signature vector of the system/network for which inference is performed.  It may be a list of signatures which results in topological inference on the system design being jointly performed over the collection of signatures provided.
</p>
</td></tr>
<tr><td><code id="maskedInferenceEXCHCustom_+3A_cdfcomp">cdfComp</code></td>
<td>

<p>user-defined vectorised cumulative distribution function of component lifetime <code class="reqn">F_Y()</code> with prototype:
<code>function(y, parametersm, ...)</code>
</p>
</td></tr>
<tr><td><code id="maskedInferenceEXCHCustom_+3A_pdfcomp">pdfComp</code></td>
<td>

<p>user-defined vectorised probability distribution function of component lifetime <code class="reqn">f_Y()</code> with prototype:
<code>function(y, parameters, ...)</code>
</p>
</td></tr>
<tr><td><code id="maskedInferenceEXCHCustom_+3A_rparmgivendata">rParmGivenData</code></td>
<td>

<p>user-defined function which should produce random draws from <code class="reqn">f_{\Xi\,|\,Y}</code> with prototype:
</p>
<p><code>function(y, ...)</code>
</p>
<p>This must return the new parameters as a 2 item list: the first item being the hyperprior parameters drawn in the same named vector format and order as <code>startHypPriorParm</code>; the second item being a list of component lifetime parameters drawn in the same named vector format and order as <code>startCompParm</code>.
</p>
</td></tr>
<tr><td><code id="maskedInferenceEXCHCustom_+3A_rcompgivenparm">rCompGivenParm</code></td>
<td>

<p>user-defined function which should produce random draws from <code class="reqn">f_{Y\,|\,\Psi}</code> with prototype:
</p>
<p><code>function(parameters, t, censoring, ...)</code>
</p>
<p>where censoring is -1 for left censoring, 0 for exact observations and 1 for right censoring.
</p>
</td></tr>
<tr><td><code id="maskedInferenceEXCHCustom_+3A_startcompparm">startCompParm</code></td>
<td>

<p>list consisting of a vectors of starting values per system (in the same order as <code>t</code>) of named parameters for the component lifetime distribution.  The order within each named vector should match the order expected for the <code>parameters</code> argument in the user defined functions above.
</p>
</td></tr>
<tr><td><code id="maskedInferenceEXCHCustom_+3A_starthypparm">startHypParm</code></td>
<td>

<p>vector of starting values of named hyper-parameters for the hyperprior.
</p>
</td></tr>
<tr><td><code id="maskedInferenceEXCHCustom_+3A_iter">iter</code></td>
<td>

<p>number of MCMC iterations to perform.
</p>
</td></tr>
<tr><td><code id="maskedInferenceEXCHCustom_+3A_...">...</code></td>
<td>

<p>additional arguments which are passed through to the user-defined functions above.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a low level implementation of the signature based data augmented MCMC scheme described in Aslett (2012) for exchangeable systems.  This function need only be used if the component lifetime distribution of interest has not already been implemented within this package.
</p>
<p>The arguments of the function are the prerequisites described in Algorithm 6.2 of Aslett (2012).  The interested user is advised to inspect the source code of this package at the file <code>MaskedLifetimeInference_Exponential.R</code> for an example of its usage, which may be seen in the function <code><a href="#topic+maskedInferenceEXCHExponential">maskedInferenceEXCHExponential</a></code> defined there, together with the associated user-definied functions above it.
</p>


<h3>Value</h3>

<p>If a single signature vector is provided above, then a data frame of MCMC samples with columns named the same as the <code>startParm</code> argument is returned.
</p>
<p>If a list of signature vectors is provided above, then a list is returned containing three items:
</p>
<table>
<tr><td><code>topology</code></td>
<td>
<p>A vector of posterior samples from the discrete marginal posterior distribution of topologies provided in the signature list.</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>A list of data frames of MCMC samples with columns named the same as the <code>startCompParm</code> argument.</p>
</td></tr>
<tr><td><code>hyperparameters</code></td>
<td>
<p>A data frame of MCMC samples with columns named the same as the <code>startHypPriorParm</code> argument.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Please feel free to email <a href="mailto:louis.aslett@durham.ac.uk">louis.aslett@durham.ac.uk</a> with any queries or if you encounter errors when running this function.
</p>


<h3>Author(s)</h3>

<p>Louis J.M. Aslett <a href="mailto:louis.aslett@durham.ac.uk">louis.aslett@durham.ac.uk</a> (<a href="https://www.louisaslett.com/">https://www.louisaslett.com/</a>)
</p>


<h3>References</h3>

<p>Aslett, L. J. M. (2012), <em>MCMC for Inference on Phase-type and Masked System Lifetime Models</em>, PhD Thesis, Trinity College Dublin.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+computeSystemSignature">computeSystemSignature</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Please inspect the source of this package, file MaskedLifetimeInference_Exponential.R
# for example usage (see details section)
</code></pre>

<hr>
<h2 id='maskedInferenceEXCHExponential'>Inference for Masked Exchangeable System Lifetimes, Exponential Components</h2><span id='topic+maskedInferenceEXCHExponential'></span>

<h3>Description</h3>

<p>Performs Bayesian inference via a signature based data augmentation MCMC scheme for masked system lifetime data for Exponentially distributed component lifetimes.  The underlying assumption is exchangeability at the system level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maskedInferenceEXCHExponential(t, signature, iter, priorMu_Mu, priorSigma_Mu,
                               priorMu_Sigma, priorSigma_Sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maskedInferenceEXCHExponential_+3A_t">t</code></td>
<td>

<p>a vector of masked system lifetimes.
</p>
</td></tr>
<tr><td><code id="maskedInferenceEXCHExponential_+3A_signature">signature</code></td>
<td>

<p>the signature vector of the system/network for which inference is performed.  It may be a list of signatures which results in topological inference on the system design being jointly performed over the collection of signatures provided.
</p>
</td></tr>
<tr><td><code id="maskedInferenceEXCHExponential_+3A_iter">iter</code></td>
<td>

<p>number of MCMC iterations to perform.
</p>
</td></tr>
<tr><td><code id="maskedInferenceEXCHExponential_+3A_priormu_mu">priorMu_Mu</code>, <code id="maskedInferenceEXCHExponential_+3A_priorsigma_mu">priorSigma_Mu</code></td>
<td>

<p><code class="reqn">\mu</code> and <code class="reqn">\sigma</code> parameters for Log-Normal hyperprior on the mean of the exchangeable Gamma population distribution for the rate.
</p>
</td></tr>
<tr><td><code id="maskedInferenceEXCHExponential_+3A_priormu_sigma">priorMu_Sigma</code>, <code id="maskedInferenceEXCHExponential_+3A_priorsigma_sigma">priorSigma_Sigma</code></td>
<td>

<p><code class="reqn">\mu</code> and <code class="reqn">\sigma</code> parameters for Log-Normal hyperprior on the variance of the exchangeable Gamma population distribution for the rate.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a full implementation of the signature based data augmented MCMC scheme described in Aslett (2012) for exchangeable systems with Exponential component lifetimes.
</p>
<p>Thus, components are taken to have Exponential lifetimes where the rate of the components in any given system is a realisation from an exchangeable population distribution.  However, only the failure time of the system is observed, not those of the components or indeed which components were failed at the system failure time.  By specifying a Log-Normal hyper-prior on the exchangeable Gamma rate parameter population distribution, this function then produces MCMC samples from the posterior of the rate parameter and hyperparameters.
</p>
<p>The model is as follows:
</p>
<p style="text-align: center;"><code class="reqn">Y \,|\, \lambda \sim \mbox{Exponential}(\lambda)</code>
</p>

<p style="text-align: center;"><code class="reqn">\lambda \,|\, \nu, \zeta \sim \mbox{Gamma}(\mathrm{shape}=\nu, \mathrm{scale}=\zeta)</code>
</p>

<p style="text-align: center;"><code class="reqn">\mu \sim \mbox{Log-Normal}(\mu_\nu, \sigma_\nu)</code>
</p>

<p style="text-align: center;"><code class="reqn">\sigma^2 \sim \mbox{Log-Normal}(\mu_\zeta, \sigma_\zeta)</code>
</p>

<p>Additionally, if one does not know the system design, then it is possible to pass a list of many system signatures in the <code>signature</code> argument, in which case the topology of the system is jointly inferred with the parameters.
</p>


<h3>Value</h3>

<p>If a single signature vector is provided above, then a list is returned containing two items:
</p>
<table>
<tr><td><code>parameters</code></td>
<td>
<p>A list of data frames, each with a single column of MCMC samples from the posterior samples from the exhcangeable rate parameter for the given system.</p>
</td></tr>
<tr><td><code>hyperparameters</code></td>
<td>
<p>A data frame with a column of posterior MCMC samples for each of the Log-Normal hyperprior parameters.</p>
</td></tr>
</table>
<p>If a list of signature vectors is provided above, then a list is returned containing three items &ndash; the two items above, plus:
</p>
<table>
<tr><td><code>topology</code></td>
<td>
<p>A vector of posterior samples from the discrete marginal posterior distribution of topologies provided in the signature list.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Please feel free to email <a href="mailto:louis.aslett@durham.ac.uk">louis.aslett@durham.ac.uk</a> with any queries or if you encounter errors when running this function.
</p>


<h3>Author(s)</h3>

<p>Louis J.M. Aslett <a href="mailto:louis.aslett@durham.ac.uk">louis.aslett@durham.ac.uk</a> (<a href="https://www.louisaslett.com/">https://www.louisaslett.com/</a>)
</p>


<h3>References</h3>

<p>Aslett, L. J. M. (2012), <em>MCMC for Inference on Phase-type and Masked System Lifetime Models</em>, PhD Thesis, Trinity College Dublin.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+computeSystemSignature">computeSystemSignature</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Some masked system lifetime data for an exchangeable collection of systems with
# Exponential component lifetime, rate drawn from the population distribution
# Gamma(shape=9, scale=0.5)
t &lt;- c(0.2265, 0.0795, 0.1178, 0.2463, 0.1053, 0.0982, 0.0349, 0.0363,
0.1546, 0.1357, 0.1239, 0.0354, 0.0124, 0.1003, 0.0827, 0.2446,
0.1214, 0.1272, 0.5438, 0.2738, 0.0378, 0.2293, 0.1706, 0.0146,
0.1506, 0.3665, 0.046, 0.1196, 0.2724, 0.2593, 0.0438, 0.1493,
0.0697, 0.1774, 0.1157, 0.0996, 0.2815, 0.1411, 0.0921, 0.2088,
0.1164, 0.149, 0.048, 0.1019, 0.2349, 0.2211, 0.0475, 0.0721,
0.0371, 0.611, 0.1959, 0.0666, 0.0956, 0.1416, 0.2126, 0.0104,
0.088, 0.0159, 0.078, 0.1747, 0.1921, 0.3558, 0.4956, 0.0436,
0.2292, 0.1159, 0.1201, 0.1299, 0.043, 0.0584, 0.0347, 0.2084,
0.1334, 0.1491, 0.0384, 0.0589, 0.2962, 0.1023, 0.0506, 0.0501,
0.1859, 0.0714, 0.1424, 0.0027, 0.2812, 0.0318, 0.4147, 0.1088,
0.2894, 0.0734, 0.1405, 0.0367, 0.0323, 0.517, 0.1034, 0.026,
0.0485, 0.0512, 0.0116, 0.1629)

# Load the signatures of order 4 simply connected coherent systems -- the data
# above correspond to simulations from system number 3
data(sccsO4)

# Perform inference on the rate parameter:
# NB this will take some time to run
samps &lt;- maskedInferenceEXCHExponential(t, sccsO4[[3]]$signature,
2000, priorMu_Mu=1, priorSigma_Mu=0.5, priorMu_Sigma=1, priorSigma_Sigma=0.7)

# Or perform inference on rate parameter and topology jointly, taking as candidate
# set all possible simply connected coherent systems of order 4:
# NB this will take some time to run
samps &lt;- maskedInferenceEXCHExponential(t, sccsO4, 2000, priorMu_Mu=1,
priorSigma_Mu=0.5, priorMu_Sigma=1, priorSigma_Sigma=0.7)
</code></pre>

<hr>
<h2 id='maskedInferenceIIDCustom'>Inference for Masked iid System Lifetimes, Custom Distribution</h2><span id='topic+maskedInferenceIIDCustom'></span>

<h3>Description</h3>

<p>Performs Bayesian inference via a signature based data augmentation MCMC scheme for masked system lifetime data for any custom component lifetime distribution.  The underlying assumption is iid components and iid systems.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maskedInferenceIIDCustom(t, signature, cdfComp, pdfComp, rParmGivenData,
                         rCompGivenParm, startParm, iter, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maskedInferenceIIDCustom_+3A_t">t</code></td>
<td>

<p>a vector of masked system lifetimes.
</p>
</td></tr>
<tr><td><code id="maskedInferenceIIDCustom_+3A_signature">signature</code></td>
<td>

<p>the signature vector of the system/network for which inference is performed.  It may be a list of signatures which results in topological inference on the system design being jointly performed over the collection of signatures provided.
</p>
</td></tr>
<tr><td><code id="maskedInferenceIIDCustom_+3A_cdfcomp">cdfComp</code></td>
<td>

<p>user-defined vectorised cumulative distribution function of component lifetime <code class="reqn">F_Y()</code> with prototype:
<code>function(y, parametersm, ...)</code>
</p>
</td></tr>
<tr><td><code id="maskedInferenceIIDCustom_+3A_pdfcomp">pdfComp</code></td>
<td>

<p>user-defined vectorised probability distribution function of component lifetime <code class="reqn">f_Y()</code> with prototype:
<code>function(y, parameters, ...)</code>
</p>
</td></tr>
<tr><td><code id="maskedInferenceIIDCustom_+3A_rparmgivendata">rParmGivenData</code></td>
<td>

<p>user-defined function which should produce random draws from <code class="reqn">f_{\Psi\,|\,Y}</code> with prototype:
</p>
<p><code>function(y, ...)</code>
</p>
<p>This must return the parameters in the same order named vector format as used for <code>startParm</code>.
</p>
</td></tr>
<tr><td><code id="maskedInferenceIIDCustom_+3A_rcompgivenparm">rCompGivenParm</code></td>
<td>

<p>user-defined function which should produce random draws from <code class="reqn">f_{Y\,|\,\Psi}</code> with prototype:
<code>function(parameters, t, censoring, ...)</code>
where censoring is -1 for left censoring, 0 for exact observations and 1 for right censoring.
</p>
</td></tr>
<tr><td><code id="maskedInferenceIIDCustom_+3A_startparm">startParm</code></td>
<td>

<p>vector of starting values of named parameters in the correct order for the <code>parameters</code> argument in the user defined functions above.
</p>
</td></tr>
<tr><td><code id="maskedInferenceIIDCustom_+3A_iter">iter</code></td>
<td>

<p>number of MCMC iterations to perform.
</p>
</td></tr>
<tr><td><code id="maskedInferenceIIDCustom_+3A_...">...</code></td>
<td>

<p>additional arguments which are passed through to the user-defined functions above.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a low level implementation of the signature based data augmented MCMC scheme described in Aslett (2012) for iid systems.  This function need only be used if the component lifetime distribution of interest has not already been implemented within this package.
</p>
<p>The arguments of the function are the prerequisites described in Algorithm 6.2 of Aslett (2012).  The interested user is advised to inspect the source code of this package at the file <code>MaskedLifetimeInference_Exponential.R</code> for an example of its usage, which may be seen in the function <code><a href="#topic+maskedInferenceIIDExponential">maskedInferenceIIDExponential</a></code> defined there, together with the associated user-definied functions above it.
</p>


<h3>Value</h3>

<p>If a single signature vector is provided above, then a data frame of MCMC samples with columns named the same as the <code>startParm</code> argument is returned.
</p>
<p>If a list of signature vectors is provided above, then a list is returned containing two items:
</p>
<table>
<tr><td><code>topology</code></td>
<td>
<p>A vector of posterior samples from the discrete marginal posterior distribution of topologies provided in the signature list.</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>A data frame of MCMC samples with columns named the same as the <code>startParm</code> argument.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Please feel free to email <a href="mailto:louis.aslett@durham.ac.uk">louis.aslett@durham.ac.uk</a> with any queries or if you encounter errors when running this function.
</p>


<h3>Author(s)</h3>

<p>Louis J.M. Aslett <a href="mailto:louis.aslett@durham.ac.uk">louis.aslett@durham.ac.uk</a> (<a href="https://www.louisaslett.com/">https://www.louisaslett.com/</a>)
</p>


<h3>References</h3>

<p>Aslett, L. J. M. (2012), <em>MCMC for Inference on Phase-type and Masked System Lifetime Models</em>, PhD Thesis, Trinity College Dublin.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+computeSystemSignature">computeSystemSignature</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Please inspect the source of this package, file MaskedLifetimeInference_Exponential.R
# for example usage (see details section)
</code></pre>

<hr>
<h2 id='maskedInferenceIIDExponential'>Inference for Masked iid System Lifetimes, Exponential Components</h2><span id='topic+maskedInferenceIIDExponential'></span>

<h3>Description</h3>

<p>Performs Bayesian inference via a signature based data augmentation MCMC scheme for masked system lifetime data for Exponentially distributed component lifetimes.  The underlying assumption is iid components and iid systems.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maskedInferenceIIDExponential(t, signature, iter, priorShape, priorScale)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maskedInferenceIIDExponential_+3A_t">t</code></td>
<td>

<p>a vector of masked system lifetimes.
</p>
</td></tr>
<tr><td><code id="maskedInferenceIIDExponential_+3A_signature">signature</code></td>
<td>

<p>the signature vector of the system/network for which inference is performed.  It may be a list of signatures which results in topological inference on the system design being jointly performed over the collection of signatures provided.
</p>
</td></tr>
<tr><td><code id="maskedInferenceIIDExponential_+3A_iter">iter</code></td>
<td>

<p>number of MCMC iterations to perform.
</p>
</td></tr>
<tr><td><code id="maskedInferenceIIDExponential_+3A_priorshape">priorShape</code></td>
<td>

<p>the shape parameter of the Gamma prior of the Exponential rate.
</p>
</td></tr>
<tr><td><code id="maskedInferenceIIDExponential_+3A_priorscale">priorScale</code></td>
<td>

<p>the scale parameter of the Gamma prior of the Exponential rate.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a full implementation of the signature based data augmented MCMC scheme described in Aslett (2012) for iid systems with Exponential component lifetimes.
</p>
<p>Thus, components are taken to have Exponential lifetimes and be arranged into some system.  However, only the failure time of the system is observed, not those of the components or indeed which components were failed at the system failure time.  By specifying a Gamma prior distribution on the component lifetime Exponential rate parameter via <code>priorShape</code> and <code>priorScale</code>, this function then produces MCMC samples from the posterior of the rate parameter.
</p>
<p>Additionally, if one does not know the system design, then it is possible to pass a list of many system signatures in the <code>signature</code> argument, in which case the topology of the system is jointly inferred with the parameters.
</p>


<h3>Value</h3>

<p>If a single signature vector is provided above, then a data frame with a single column of MCMC samples from the posterior of the rate parameter are returned.
</p>
<p>If a list of signature vectors is provided above, then a list is returned containing two items:
</p>
<table>
<tr><td><code>topology</code></td>
<td>
<p>A vector of posterior samples from the discrete marginal posterior distribution of topologies provided in the signature list.</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>A data frame with a single column of MCMC samples from the posterior of the rate parameter.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Please feel free to email <a href="mailto:louis.aslett@durham.ac.uk">louis.aslett@durham.ac.uk</a> with any queries or if you encounter errors when running this function.
</p>


<h3>Author(s)</h3>

<p>Louis J.M. Aslett <a href="mailto:louis.aslett@durham.ac.uk">louis.aslett@durham.ac.uk</a> (<a href="https://www.louisaslett.com/">https://www.louisaslett.com/</a>)
</p>


<h3>References</h3>

<p>Aslett, L. J. M. (2012), <em>MCMC for Inference on Phase-type and Masked System Lifetime Models</em>, PhD Thesis, Trinity College Dublin.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+computeSystemSignature">computeSystemSignature</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Some masked system lifetime data for a system with Exponential component
# lifetime, rate=3.14
t &lt;- c(0.2696, 0.3613, 0.0256, 0.1287, 0.2305, 0.1565, 0.2484, 0.7482,
0.1748, 0.1805, 0.1985, 0.0799, 0.2843, 0.2392, 0.2151, 0.1177,
0.1278, 0.4189, 0.4374, 0.0931, 0.2846, 0.0357, 0.1809, 0.2077,
0.5211, 0.4935, 0.1464, 0.0297, 0.5429, 0.1294, 0.7089, 0.5534,
0.1183, 0.2628, 0.0481, 0.0518, 0.0533, 0.3595, 0.0767, 0.2606,
0.1005, 0.227, 0.01, 0.0947, 0.1248, 0.2288, 0.1422, 0.233, 0.1428,
0.2043)

# Load the signatures of order 4 simply connected coherent systems -- the data
# above correspond to simulations from system number 3
data(sccsO4)

# Perform inference on the rate parameter:
# NB this will take some time to run
samps &lt;- maskedInferenceIIDExponential(t, sccsO4[[3]]$signature, 2000,
priorShape=9, priorScale=0.5)

# Or perform inference on rate parameter and topology jointly, taking as candidate
# set all possible simply connected coherent systems of order 4:
# NB this will take some time to run
samps &lt;- maskedInferenceIIDExponential(t, sccsO4, 2000, priorShape=9,
priorScale=0.5)
</code></pre>

<hr>
<h2 id='nonParBayesSystemInference'>Non-parametric Bayesian posterior predictive system survival inference</h2><span id='topic+nonParBayesSystemInference'></span>

<h3>Description</h3>

<p>Computes a non-parametric Bayesian posterior predictive survival probability
given the survival signature of a system and test data on each of the
components as described in Aslett <em>et al</em> (2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nonParBayesSystemInference(at.times, survival.signature, test.data, alpha=1, beta=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nonParBayesSystemInference_+3A_at.times">at.times</code></td>
<td>

<p>a vector of times at which the posterior predictive estimate of survival
probability should be computed.
</p>
</td></tr>
<tr><td><code id="nonParBayesSystemInference_+3A_survival.signature">survival.signature</code></td>
<td>

<p>the survival signature matrix of the system/network for which inference is
performed.  This should be in the same format as returned by
<code><a href="#topic+computeSystemSurvivalSignature">computeSystemSurvivalSignature</a></code>.
</p>
</td></tr>
<tr><td><code id="nonParBayesSystemInference_+3A_test.data">test.data</code></td>
<td>

<p>a list of vectors containing the component test data.  The elements of the
list should be named identically to the component columns in the
<code>survival.signature</code> argument.
</p>
</td></tr>
<tr><td><code id="nonParBayesSystemInference_+3A_alpha">alpha</code>, <code id="nonParBayesSystemInference_+3A_beta">beta</code></td>
<td>

<p>the Beta prior shape parameters.  Each must match in type and can be:
</p>

<ul>
<li><p> a single scalar for a fixed prior across time and component types;
</p>
</li>
<li><p> a vector of parameters of the same length as the <code>at.times</code>
argument, which indicates the time-varying prior parameter at the
corresponding time in <code>at.times</code>.  This is therefore time-varying,
but indicates the same time-varying prior for all component types;
</p>
</li>
<li><p> a data frame where each column is named using the same names as for
the <code>survival.signature</code> argument and each row corresponds to the
time-varying prior parameter at the corresponding time in
<code>at.times</code>.
</p>
</li></ul>

<p>By default the 'uninformative' prior with <code>alpha=1</code> and <code>beta=1</code>
is used for all components at all times.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the technique described in detail in Section 4 of Aslett <em>et al</em> (2015).
</p>
<p>In brief, at any fixed time <code class="reqn">t</code>, the functioning of a single component of type <code class="reqn">k</code> is Bernoulli(<code class="reqn">p_t^k</code>) distributed for suitable <code class="reqn">p_t^k</code>, irrespective of the lifetime distribution of the component.  Correspondingly, the distribution of the number of components still functioning at time <code class="reqn">t</code> in a collection of <code class="reqn">n_k</code> iid components of type <code class="reqn">k</code> is Binomial(<code class="reqn">n_k, p_t^k</code>).
</p>
<p>Taking the priors <code class="reqn">p_t^k \sim</code> Beta(<code class="reqn">\alpha_t^k, \beta_t^k</code>), Aslett <em>et al</em> (2015) show that this leads to a posterior predictive survival distribution with a nice closed form (see equations 9 and 10 in Section 4).
</p>


<h3>Value</h3>

<p>A vector of the same length as the <code>at.times</code> argument, where each element is the posterior predictive probability of a new system surviving to the corresponding time in <code>at.times</code>.
</p>


<h3>Note</h3>

<p>Please feel free to email <a href="mailto:louis.aslett@durham.ac.uk">louis.aslett@durham.ac.uk</a> with any queries or if you encounter errors when running this function.
</p>


<h3>Author(s)</h3>

<p>Louis J. M. Aslett <a href="mailto:louis.aslett@durham.ac.uk">louis.aslett@durham.ac.uk</a> (<a href="https://www.louisaslett.com/">https://www.louisaslett.com/</a>)
</p>


<h3>References</h3>

<p>Aslett, L. J. M., Coolen, F. P. A. and Wilson, S. P. (2015), &lsquo;Bayesian Inference for Reliability of Systems and Networks using the Survival Signature&rsquo;, <em>Risk Analysis</em> <b>39</b>(9), 1640&ndash;1651.  <a href="https://www.louisaslett.com/Papers/Aslett_Coolen_Wilson_2014.html">Download paper</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+computeSystemSurvivalSignature">computeSystemSurvivalSignature</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Exactly reproduce the example in Section 4.1 of Aslett et al (2015), including Figure 5
# First specify the system layout, numbered as per Figure 4
sys &lt;- createSystem(s -- 1 -- 2:4:5, 2 -- 3 -- t, 4:5 -- 6 -- t,
                    s -- 7 -- 8 -- t, s -- 9 -- 10 -- 11 -- t, 7 -- 10 -- 8,
                    types = list(T1 = c(1, 6, 11),
                                 T2 = c(2, 3, 9),
                                 T3 = c(4, 5, 10),
                                 T4 = c(7, 8)))

# Compute the survival signature table from Appendix
sig &lt;- computeSystemSurvivalSignature(sys)

# Simulate the test data (same seed as used in the paper)
set.seed(233)
t1 &lt;- rexp(100, rate=0.55)
t2 &lt;- rweibull(100, scale=1.8, shape=2.2)
t3 &lt;- rlnorm(100, 0.4, 0.9)
t4 &lt;- rgamma(100, scale=0.9, shape=3.2)

# Compile into a list as required by this function
test.data &lt;- list("T1"=t1, "T2"=t2, "T3"=t3, "T4"=t4)

# Create a vector of times at which to evaluate the posterior predictive
# survival probability and compute using this function
t &lt;- seq(0, 5, length.out=300)
yS &lt;- nonParBayesSystemInference(t, sig, test.data)

# Compute the survival curves for the individual components (just to match
# Figure 5)
y1 &lt;- sapply(t, pexp, rate=0.55, lower.tail=FALSE)
y2 &lt;- sapply(t, pweibull, scale=1.8, shape=2.2, lower.tail=FALSE)
y3 &lt;- sapply(t, plnorm, meanlog=0.4, sdlog=0.9, lower.tail=FALSE)
y4 &lt;- sapply(t, pgamma, scale=0.9, shape=3.2, lower.tail=FALSE)

# Plot

library(ggplot2)
p &lt;- ggplot(data.frame(Time=rep(t,5), Probability=c(yS,y1,y2,y3,y4),
            Item=c(rep(c("System", "T1", "T2", "T3", "T4"), each=300))))
p &lt;- p + geom_line(aes(x=Time, y=Probability, linetype=Item))
p &lt;- p + xlab("Time") + ylab("Survival Probability")
p
</code></pre>

<hr>
<h2 id='nonParBayesSystemInferencePriorSets'>Non-parametric Bayesian posterior predictive system survival inference using sets of priors</h2><span id='topic+nonParBayesSystemInferencePriorSets'></span>

<h3>Description</h3>

<p>Computes a non-parametric Bayesian posterior predictive survival probability
given the survival signature of a system, test data on each of the
components and a set of priors. This is the methodology described in Walter
<em>et al</em> (2017), which extends the method in <code><a href="#topic+nonParBayesSystemInference">nonParBayesSystemInference</a></code> (Aslett <em>et al</em>, 2015) to allow modelling imperfect prior knowledge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nonParBayesSystemInferencePriorSets(at.times, survival.signature, test.data,
                                    nLower=2, nUpper=2, yLower=0.5, yUpper=0.5, cores=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nonParBayesSystemInferencePriorSets_+3A_at.times">at.times</code></td>
<td>

<p>a vector of times at which the posterior predictive estimate of survival
probability should be computed.
</p>
</td></tr>
<tr><td><code id="nonParBayesSystemInferencePriorSets_+3A_survival.signature">survival.signature</code></td>
<td>

<p>the survival signature matrix of the system/network for which inference is
performed.  This should be in the same format as returned by
<code><a href="#topic+computeSystemSurvivalSignature">computeSystemSurvivalSignature</a></code>.
</p>
</td></tr>
<tr><td><code id="nonParBayesSystemInferencePriorSets_+3A_test.data">test.data</code></td>
<td>

<p>a list of vectors containing the component test data.  The elements of the
list should be named identically to the component columns in the
<code>survival.signature</code> argument.
</p>
</td></tr>
<tr><td><code id="nonParBayesSystemInferencePriorSets_+3A_nlower">nLower</code>, <code id="nonParBayesSystemInferencePriorSets_+3A_nupper">nUpper</code></td>
<td>

<p>the reparameterised lower/upper prior parameter <code class="reqn">n</code> for the Beta distribution, where
<code class="reqn">n = \alpha+\beta</code>.  Each must match in type and can be:
</p>

<ul>
<li><p> a single scalar for a fixed prior across time and component types;
</p>
</li>
<li><p> a vector of parameters of the same length as the <code>at.times</code>
argument, which indicates the time-varying prior parameter at the
corresponding time in <code>at.times</code>.  This is therefore time-varying,
but indicates the same time-varying prior for all component types;
</p>
</li>
<li><p> or a data frame where each column is named using the same names as for
the <code>survival.signature</code> argument and each row corresponds to the
time-varying prior parameter at the corresponding time in
<code>at.times</code>.
</p>
</li></ul>

<p>In all cases, <code>nUpper</code> but be elementwise greater than or equal to
<code>nLower</code>.
</p>
<p>By default the 'uninformative' (but certain) prior with <code>nLower=2</code> and
<code>nUpper=1</code> is used for all components at all times.
</p>
</td></tr>
<tr><td><code id="nonParBayesSystemInferencePriorSets_+3A_ylower">yLower</code>, <code id="nonParBayesSystemInferencePriorSets_+3A_yupper">yUpper</code></td>
<td>

<p>the reparameterised lower/upper prior parameter <code class="reqn">y</code> for the Beta distribution, where
<code class="reqn">y = \alpha/(\alpha+\beta)</code>.  Each must match in type and can be:
</p>

<ul>
<li><p> a single scalar for a fixed prior across time and component types;
</p>
</li>
<li><p> a vector of parameters of the same length as the <code>at.times</code>
argument, which indicates the time-varying prior parameter at the
corresponding time in <code>at.times</code>.  This is therefore time-varying,
but indicates the same time-varying prior for all component types;
</p>
</li>
<li><p> or a data frame where each column is named using the same names as for
the <code>survival.signature</code> argument and each row corresponds to the
time-varying prior parameter at the corresponding time in
<code>at.times</code>.
</p>
</li></ul>

<p>In all cases, <code>yUpper</code> but be elementwise greater than or equal to
<code>yLower</code>.
</p>
<p>By default the 'uninformative' (but certain) prior with <code>yLower=0.5</code>
and <code>yUpper=0.5</code> is used for all components at all times.
</p>
</td></tr>
<tr><td><code id="nonParBayesSystemInferencePriorSets_+3A_cores">cores</code></td>
<td>

<p>a scalar indicating how many CPU cores on which to execute parallel parts of
the algorithm (uses the <code>parallel</code> library internally).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the technique described in Walter <em>et al</em> (2017),
which extends the methodology of Aslett <em>et al</em> (2015) to allow modelling
partial or imperfect prior knowledge on component failure distributions.
</p>
<p>In brief Aslett <em>et al</em> (2015) consider, at any fixed time <code class="reqn">t</code>, the functioning of a single component of type <code class="reqn">k</code> to be Bernoulli(<code class="reqn">p_t^k</code>) distributed for suitable <code class="reqn">p_t^k</code>, irrespective of the lifetime distribution of the component.  Correspondingly, the distribution of the number of components still functioning at time <code class="reqn">t</code> in a collection of <code class="reqn">n_k</code> iid components of type <code class="reqn">k</code> is Binomial(<code class="reqn">n_k, p_t^k</code>).
</p>
<p>Taking the priors <code class="reqn">p_t^k \sim</code> Beta(<code class="reqn">\alpha_t^k, \beta_t^k</code>), Aslett <em>et al</em> (2015) show that this leads to a posterior predictive survival distribution with a nice closed form (see equations 9 and 10 in Section 4).
</p>
<p>Walter <em>et al</em> (2017) use the standard reparameterisation (dropping sub/super-scripts for readability) <code class="reqn">n = \alpha+\beta</code> and <code class="reqn">y = \alpha/(\alpha+\beta)</code>. This allows a more natural interpretation, where <code class="reqn">n</code> represents the prior strength (it represents a pseudo-count for number of failures informing the prior specification) and <code class="reqn">y</code> represents the prior expectation for the probability a component functions.
</p>
<p>In particular, Walter <em>et al</em> (2017) then enable imprecise prior specification by allowing lower and upper bounds on <code class="reqn">n</code> and <code class="reqn">y</code>, which may optionally be time varying. This is then propagated to construct bounds on the posterior predictive distribution for the functioning of a new system containing components exchangeable with those provided in the testing set and used in a system with design specified by the survival signature provided.
</p>


<h3>Value</h3>

<p>A list containing two slots, <code>lower</code> and <code>upper</code>, each of which is a vector of the same length as the <code>at.times</code> argument, where each element is the lower/upper posterior predictive probability of a new system surviving to the corresponding time in <code>at.times</code>.
</p>


<h3>Note</h3>

<p>Please feel free to email <a href="mailto:louis.aslett@durham.ac.uk">louis.aslett@durham.ac.uk</a> with any queries or if you encounter errors when running this function.
</p>


<h3>Author(s)</h3>

<p>Louis J. M. Aslett <a href="mailto:louis.aslett@durham.ac.uk">louis.aslett@durham.ac.uk</a> (<a href="https://www.louisaslett.com/">https://www.louisaslett.com/</a>)
</p>


<h3>References</h3>

<p>Walter, G., Aslett, L. J. M. and Coolen, F. P. A. (2017), &lsquo;Bayesian nonparametric system reliability using sets of priors&rsquo;, <em>International Journal of Approximate Reasoning</em>, <b>80</b>, 67&ndash;88.  <a href="https://www.louisaslett.com/Papers/Walter_Aslett_Coolen_2017.html">Download paper</a>
</p>
<p>Aslett, L. J. M., Coolen, F. P. A. and Wilson, S. P. (2015), &lsquo;Bayesian Inference for Reliability of Systems and Networks using the Survival Signature&rsquo;, <em>Risk Analysis</em> <b>39</b>(9), 1640&ndash;1651.  <a href="https://www.louisaslett.com/Papers/Aslett_Coolen_Wilson_2014.html">Download paper</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+computeSystemSurvivalSignature">computeSystemSurvivalSignature</a></code>, and also <code><a href="#topic+nonParBayesSystemInference">nonParBayesSystemInference</a></code> which is the precise counterpart to this method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Exactly reproduce the toy bridge system example in Section 7.2.1 of Walter et al (2017)

# Produces survival signature matrix for one component of type "name", for use
# in nonParBayesSystemInference()
oneCompSurvSign &lt;- function(name){
  res &lt;- data.frame(name=c(0,1), Probability=c(0,1))
  names(res)[1] &lt;- name
  res
}

# Produces data frame with prior and posterior lower &amp; upper component survival
# function for component of type "name" based on
# nonParBayesSystemInferencePriorSets() inputs for all components except
# survival signature; nLower, nUpper, yLower, yUpper must be data frames where
# each column corresponds to the component type, so there must be a match
oneCompPriorPostSet &lt;- function(name, at.times, test.data, nLower, nUpper, yLower, yUpper){
  sig &lt;- oneCompSurvSign(name)
  nodata &lt;- list(name=NULL)
  names(nodata) &lt;- name
  nL &lt;- nLower[, match(name, names(nLower))]
  nU &lt;- nUpper[, match(name, names(nUpper))]
  yL &lt;- yLower[, match(name, names(yLower))]
  yU &lt;- yUpper[, match(name, names(yUpper))]
  data &lt;- test.data[match(name, names(test.data))]
  # NB limit to 1 core on CRAN due to Windows -- make larger to speed up locally!
  prio &lt;- nonParBayesSystemInferencePriorSets(at.times, sig, nodata, nL, nU, yL, yU, cores = 1)
  post &lt;- nonParBayesSystemInferencePriorSets(at.times, sig,   data, nL, nU, yL, yU, cores = 1)
  data.frame(Time=rep(at.times,2),
             Lower=c(prio$lower,post$lower),
             Upper=c(prio$upper,post$upper),
             Item=rep(c("Prior", "Posterior"), each=length(at.times)))
}

# ----------------------------------------------

# System
b3 &lt;- createSystem(s -- 2:3 -- 4 -- 5:6 -- 1 -- t, 2 -- 5, 3 -- 6,
                   types = list(T1 = c(2,3,5,6), T2 = c(4), T3 = c(1)))

# Data
b3nulldata &lt;- list("T1"=NULL, "T2"=NULL, "T3"=NULL)
b3testdata &lt;- list("T1"=c(2.2, 2.4, 2.6, 2.8),
                   "T2"=c(3.2, 3.4, 3.6, 3.8),
                   "T3"=(1:4)/10+4) # T3 late failures
b3testdata &lt;- list("T1"=c(2.2, 2.4, 2.6, 2.8),
                   "T2"=c(3.2, 3.4, 3.6, 3.8),
                   "T3"=(1:4)/10+0.5) # T3 early failures
b3testdata &lt;- list("T1"=c(2.2, 2.4, 2.6, 2.8),
                   "T2"=c(3.2, 3.4, 3.6, 3.8),
                   "T3"=(1:4)-0.5) # T3 fitting failures
b3dat &lt;- reshape2::melt(b3testdata); names(b3dat) &lt;- c("x", "Part")
b3dat$Part &lt;- ordered(b3dat$Part, levels=c("T1", "T2", "T3", "System"))

# Setup to run
b3sig &lt;- computeSystemSurvivalSignature(b3)
b3t &lt;- seq(0, 5, length.out=301)
b3nL &lt;- data.frame(T1=rep(1,301), T2=rep(1,301), T3=rep(1,301))
b3nU &lt;- data.frame(T1=rep(2,301), T2=rep(2,301), T3=rep(4,301))
b3yL &lt;- data.frame(T1=rep(0.001, 301),
                   T2=rep(0.001, 301),
                   T3=c(rep(c(0.625,0.375,0.250,0.125,0.010), each=60), 0.01))
b3yU &lt;- data.frame(T1=rep(0.999, 301),
                   T2=rep(0.999, 301),
                   T3=c(rep(c(0.999,0.875,0.500,0.375,0.250), each=60), 0.25))

b3T1 &lt;- oneCompPriorPostSet("T1", b3t, b3testdata, b3nL, b3nU, b3yL, b3yU)
b3T2 &lt;- oneCompPriorPostSet("T2", b3t, b3testdata, b3nL, b3nU, b3yL, b3yU)
b3T3 &lt;- oneCompPriorPostSet("T3", b3t, b3testdata, b3nL, b3nU, b3yL, b3yU)

# Compute prior and posterior sets!!
# NB limit to 1 core on CRAN due to Windows -- make larger to speed up locally!
b3prio &lt;- nonParBayesSystemInferencePriorSets(b3t, b3sig, b3nulldata,
                                              b3nL, b3nU, b3yL, b3yU, cores = 1)
b3post &lt;- nonParBayesSystemInferencePriorSets(b3t, b3sig, b3testdata,
                                              b3nL, b3nU, b3yL, b3yU, cores = 1)

b3df &lt;- rbind(data.frame(b3T1, Part="T1"),
              data.frame(b3T2, Part="T2"),
              data.frame(b3T3, Part="T3"),
              data.frame(Time=rep(b3t,2),
                         Lower=c(b3prio$lower,b3post$lower),
                         Upper=c(b3prio$upper,b3post$upper),
                         Item=rep(c("Prior", "Posterior"), each=length(b3t)), Part="System"))
b3df$Item &lt;- ordered(b3df$Item, levels=c("Prior", "Posterior"))
b3df$Part &lt;- ordered(b3df$Part, levels=c("T1", "T2", "T3", "System"))


library("ggplot2")
library("xtable")

ggplot(b3df, aes(x=Time)) +
  scale_fill_manual(values = c("#b2df8a", "#1f78b4")) +
  scale_colour_manual(values = c("#b2df8a", "#1f78b4")) +
  geom_line(aes(y=Upper, group=Item, colour=Item)) +
  geom_line(aes(y=Lower, group=Item, colour=Item)) +
  geom_ribbon(aes(ymin=Lower, ymax=Upper, group=Item, colour=Item, fill=Item), alpha=0.5) +
  facet_wrap(~Part, nrow=2) +
  geom_rug(aes(x=x), data=b3dat) +
  xlab("Time") +
  ylab("Survival Probability") +
  theme_bw() +
  theme(legend.title = element_blank())

b3sigtable &lt;- b3sig[b3sig$T3 == 1,]
b3sigtable$T1 &lt;- as.factor(b3sigtable$T1)
b3sigtable$T2 &lt;- as.factor(b3sigtable$T2)
b3sigtable$T3 &lt;- as.factor(b3sigtable$T3)
xtable(b3sigtable)

</code></pre>

<hr>
<h2 id='ReliabilityTheory-package'>Structural Reliability Theory Toolbox</h2><span id='topic+ReliabilityTheory-package'></span><span id='topic+ReliabilityTheory'></span>

<h3>Description</h3>

<p>A collection of tools for working structural reliability problems, such as catalogues of system signatures and Bayesian inferential functions.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> ReliabilityTheory</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.2.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-05-03</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2 | GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>





<h3>Author(s)</h3>

<p>Louis J. M. Aslett, <a href="mailto:louis.aslett@durham.ac.uk">louis.aslett@durham.ac.uk</a> (<a href="https://www.louisaslett.com">https://www.louisaslett.com</a>)
</p>


<h3>References</h3>

<p>Aslett, L. J. M. (2012), <em>MCMC for Inference on Phase-type and Masked System Lifetime Models</em>, PhD Thesis, Trinity College Dublin.
</p>
<p>Samaniego, F. J. (2007), <em>System Signatures and Their Applications in Engineering Reliability</em>, Springer.
</p>

<hr>
<h2 id='sccsO2'>Catalogue of Simply Connected Coherent Systems of Order 2</h2><span id='topic+sccsO2'></span>

<h3>Description</h3>

<p>This data set provides a catalogue of the network graph, signature and minimal cut-sets of all simply connected coherent systems of order 2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sccsO2)</code></pre>


<h3>Format</h3>

<p>A list object, one item for each such systems.  Each item is itself a list, with the elements <code>$graph</code>, <code>$cutsets</code> and <code>$signature</code>.</p>


<h3>Source</h3>

<p>Derived in the thesis Aslett (2012).</p>


<h3>References</h3>

<p>Aslett, L. J. M. (2012), <em>MCMC for Inference on Phase-type and Masked System Lifetime Models</em>, PhD Thesis, Trinity College Dublin.
</p>

<hr>
<h2 id='sccsO3'>Catalogue of Simply Connected Coherent Systems of Order 3</h2><span id='topic+sccsO3'></span>

<h3>Description</h3>

<p>This data set provides a catalogue of the network graph, signature and minimal cut-sets of all simply connected coherent systems of order 3.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sccsO3)</code></pre>


<h3>Format</h3>

<p>A list object, one item for each such systems.  Each item is itself a list, with the elements <code>$graph</code>, <code>$cutsets</code> and <code>$signature</code>.</p>


<h3>Source</h3>

<p>Derived in the thesis Aslett (2012).</p>


<h3>References</h3>

<p>Aslett, L. J. M. (2012), <em>MCMC for Inference on Phase-type and Masked System Lifetime Models</em>, PhD Thesis, Trinity College Dublin.
</p>

<hr>
<h2 id='sccsO4'>Catalogue of Simply Connected Coherent Systems of Order 4</h2><span id='topic+sccsO4'></span>

<h3>Description</h3>

<p>This data set provides a catalogue of the network graph, signature and minimal cut-sets of all simply connected coherent systems of order 4.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sccsO4)</code></pre>


<h3>Format</h3>

<p>A list object, one item for each such systems.  Each item is itself a list, with the elements <code>$graph</code>, <code>$cutsets</code> and <code>$signature</code>.</p>


<h3>Source</h3>

<p>Derived in the thesis Aslett (2012).</p>


<h3>References</h3>

<p>Aslett, L. J. M. (2012), <em>MCMC for Inference on Phase-type and Masked System Lifetime Models</em>, PhD Thesis, Trinity College Dublin.
</p>

<hr>
<h2 id='sccsO5'>Catalogue of Simply Connected Coherent Systems of Order 5</h2><span id='topic+sccsO5'></span>

<h3>Description</h3>

<p>This data set provides a catalogue of the network graph, signature and minimal cut-sets of all simply connected coherent systems of order 5.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sccsO5)</code></pre>


<h3>Format</h3>

<p>A list object, one item for each such systems.  Each item is itself a list, with the elements <code>$graph</code>, <code>$cutsets</code> and <code>$signature</code>.</p>


<h3>Source</h3>

<p>Derived in the thesis Aslett (2012).</p>


<h3>References</h3>

<p>Aslett, L. J. M. (2012), <em>MCMC for Inference on Phase-type and Masked System Lifetime Models</em>, PhD Thesis, Trinity College Dublin.
</p>

<hr>
<h2 id='setCompTypes'>
Set component types in a system
</h2><span id='topic+setCompTypes'></span>

<h3>Description</h3>

<p>A system created with <code><a href="#topic+createSystem">createSystem</a></code> by default assumes components to be of the same type. This function enables assigning particular types (or modified from a previous types assignment) to each component after system creation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setCompTypes(sys, types)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setCompTypes_+3A_sys">sys</code></td>
<td>

<p>a <code>system</code> object representing the system whose types are to be set.  This should have been created by a call to <code><a href="#topic+createSystem">createSystem</a></code>.
</p>
</td></tr>
<tr><td><code id="setCompTypes_+3A_types">types</code></td>
<td>

<p>a named list of vectors.  The names correspond to component types, whilst each vector indicates which components are of that type.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function enables specifying (or modifying) the types of the components in a system. The types can be specified when the system is initially defined using <code><a href="#topic+createSystem">createSystem</a></code>, but if none are specified at that time then it is assumed all components are of the same type.
</p>
<p>The <code>types</code> argument should be a named list of vectors, for example <code>list("a" = 1:3, "b" = c(4,6), "c" = 5)</code> would specify that component numbers 1 through 3 are of type a, 4 and 6 are type b, with the remaining component 5 as type c. The numbering should match numbering used when creating the system. The start and terminal nodes should not be given a type (as they are assumed perfectly reliable).
</p>


<h3>Value</h3>

<p>The system which was passed in the <code>sys</code> argument is returned with the component types updated.
</p>


<h3>Author(s)</h3>

<p>Louis J.M. Aslett <a href="mailto:louis.aslett@durham.ac.uk">louis.aslett@durham.ac.uk</a> (<a href="https://www.louisaslett.com/">https://www.louisaslett.com/</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+createSystem">createSystem</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## EXAMPLE 1
## Figure 1 in Coolen and Coolen-Maturi (2012)

# First, define the structure, ensuring that each physically separate component
# is separately numbered
fig1 &lt;- createSystem(s -- 1 -- 2:3 -- 4 -- 5:6 -- t, 2 -- 5, 3 -- 6)

# Second, assign types to the components with this function
setCompTypes(fig1, list("Type 1" = c(1, 2, 5), "Type 2" = c(3, 4, 6)))

# Note that one can create the same system and avoid using setCompTypes by
# specifying the types in the initial call to createSystem if desired.
# The following code results in exactly the same system specification as fig1:
fig1b &lt;- createSystem(s -- 1 -- 2:3 -- 4 -- 5:6 -- t, 2 -- 5, 3 -- 6,
                      types = list("Type 1" = c(1, 2, 5), "Type 2" = c(3, 4, 6)))
</code></pre>

<hr>
<h2 id='simulateSystem'>Simulate Masked Lifetime Data for a System</h2><span id='topic+simulateSystem'></span>

<h3>Description</h3>

<p>This function enables easy simulation of iid masked lifetime observations from a system or network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateSystem(system, n, rdens, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulateSystem_+3A_system">system</code></td>
<td>

<p>may be: a <code><a href="base.html#topic+system">system</a></code> object (made with <code><a href="#topic+createSystem">createSystem</a></code> representing the system; the collection of cutsets of the system; or the system signature.
</p>
</td></tr>
<tr><td><code id="simulateSystem_+3A_n">n</code></td>
<td>

<p>how many simulations to produce.
</p>
</td></tr>
<tr><td><code id="simulateSystem_+3A_rdens">rdens</code></td>
<td>

<p>a user defined function which generates random realisations of the component lifetimes.
</p>
</td></tr>
<tr><td><code id="simulateSystem_+3A_...">...</code></td>
<td>

<p>parameters passed to the user defined function <code>rdens</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The system or network is specified by means of a <code><a href="base.html#topic+system">system</a></code> object, whereby each end of the system is denoted by nodes named <code>s</code> and <code>t</code> which are taken to be perfectly reliable.  It is easy to construct the appropriate reliability block diagram representation using the function <code><a href="#topic+createSystem">createSystem</a></code>.  Note that each physically distinct component should be separately numbered when constructing this object.
</p>
<p>This function then generates iid realisations of masked lifetimes.
</p>


<h3>Value</h3>

<p>a numeric vector of length <code>n</code> containing the masked lifetime data.
</p>


<h3>Note</h3>

<p>Please feel free to email <a href="mailto:louis.aslett@durham.ac.uk">louis.aslett@durham.ac.uk</a> with any queries or if you encounter errors when running this function.
</p>


<h3>Author(s)</h3>

<p>Louis J.M. Aslett <a href="mailto:louis.aslett@durham.ac.uk">louis.aslett@durham.ac.uk</a> (<a href="https://www.louisaslett.com/">https://www.louisaslett.com/</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate 20 masked lifetimes of a two component series system with Exponential(2)
# component lifetimes
# Using igraph object ...
simulateSystem(createSystem(s -- 1 -- 2 -- t), 20, rexp, rate=2)

# ... and using signature
simulateSystem(c(1,0), 20, rexp, rate=2)
</code></pre>

<hr>
<h2 id='systemGraphToGenerator'>Construct a Continuous-time Markov Chain Generator</h2><span id='topic+systemGraphToGenerator'></span>

<h3>Description</h3>

<p>This function enables easy construction of an absorbing continuous-time Markov chain generator matrix representation for a system when components are treated as having Exponential failure and repair times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>systemGraphToGenerator(g, failRate, repairRate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="systemGraphToGenerator_+3A_g">g</code></td>
<td>

<p>an <code><a href="igraph.html#topic+igraph">igraph</a></code> object representing the system or network whose generator matrix representation is to be computed.  There should be two terminal 'dummy' nodes to represent either end of the structure which must be labelled &quot;s&quot; and &quot;t&quot;.  They are assumed perfectly reliable.  See details and examples.
</p>
</td></tr>
<tr><td><code id="systemGraphToGenerator_+3A_failrate">failRate</code></td>
<td>

<p>the rate parameter of the Exponentially distributed lifetime distribution of the components.
</p>
</td></tr>
<tr><td><code id="systemGraphToGenerator_+3A_repairrate">repairRate</code></td>
<td>

<p>the rate parameter of the Exponentially distributed repair time distribution of the components.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the system or network is specified by means of an <code><a href="igraph.html#topic+igraph">igraph</a></code> object, each end of the system must be denoted by nodes named &quot;s&quot; and &quot;t&quot; which are taken to be perfectly reliable.  It is easy to construct the appropriate graph representation using the function <code><a href="igraph.html#topic+graph.formula">graph.formula</a></code>.
</p>
<p>This function then creates the generator matrix for an absorbing continuous-time Markov chain representation of such a system where components are repairable.  All system states which in which the system is inoperative are collapsed into the absorbing state.
</p>
<p>The returned values are in the format required by the <code>phtMCMC2</code>.
</p>
<p>Full details are in Aslett (2012).
</p>


<h3>Value</h3>

<p>A list is returned with both a numeric generator matrix (in <code>$G</code> with the failure rate, <code>failRate</code>, and repair rate, <code>repairRate</code>) and a symbolic matrix (in <code>$structure$G</code>), along with a matrix of the constant multiples of generator entries (in <code>$structure$C</code>).
</p>


<h3>Note</h3>

<p>Please feel free to email <a href="mailto:louis.aslett@durham.ac.uk">louis.aslett@durham.ac.uk</a> with any queries or if you encounter errors when running this function.
</p>


<h3>Author(s)</h3>

<p>Louis J.M. Aslett <a href="mailto:louis.aslett@durham.ac.uk">louis.aslett@durham.ac.uk</a> (<a href="https://www.louisaslett.com/">https://www.louisaslett.com/</a>)
</p>


<h3>References</h3>

<p>Aslett, L. J. M. (2012), <em>MCMC for Inference on Phase-type and Masked System Lifetime Models</em>, PhD Thesis, Trinity College Dublin.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get the generator representing a repairable 5 component 'bridge' system with
# failure rate 1 and repair rate 365.
data(sccsO5)
G &lt;- systemGraphToGenerator(sccsO5[[18]]$graph, 1, 365)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
