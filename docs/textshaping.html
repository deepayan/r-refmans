<!DOCTYPE html><html lang="en"><head><title>Help for package textshaping</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {textshaping}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#textshaping-package'><p>textshaping: Bindings to the 'HarfBuzz' and 'Fribidi' Libraries for Text Shaping</p></a></li>
<li><a href='#get_font_features'><p>Get available OpenType features in a font</p></a></li>
<li><a href='#lorem_text'><p>Get gibberish text in various scripts</p></a></li>
<li><a href='#plot_shape'><p>Preview shaped text and the metrics for the text box</p></a></li>
<li><a href='#shape_text'><p>Calculate glyph positions for strings</p></a></li>
<li><a href='#text_width'><p>Calculate the width of a string, ignoring new-lines</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Bindings to the 'HarfBuzz' and 'Fribidi' Libraries for Text
Shaping</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides access to the text shaping functionality in the
    'HarfBuzz' library and the bidirectional algorithm in the 'Fribidi'
    library.  'textshaping' is a low-level utility package mainly for
    graphic devices that expands upon the font tool-set provided by the
    'systemfonts' package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/r-lib/textshaping">https://github.com/r-lib/textshaping</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-lib/textshaping/issues">https://github.com/r-lib/textshaping/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>lifecycle, stats, stringi, systemfonts (&ge; 1.1.0), utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, grDevices, grid, knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>cpp11 (&ge; 0.2.1), systemfonts (&ge; 1.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>freetype2, harfbuzz, fribidi</td>
</tr>
<tr>
<td>Config/build/compilation-database:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-20 08:47:24 UTC; thomas</td>
</tr>
<tr>
<td>Author:</td>
<td>Thomas Lin Pedersen
    <a href="https://orcid.org/0000-0002-5147-4711"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre, aut],
  Posit, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Thomas Lin Pedersen &lt;thomas.pedersen@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-20 11:00:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='textshaping-package'>textshaping: Bindings to the 'HarfBuzz' and 'Fribidi' Libraries for Text Shaping</h2><span id='topic+textshaping'></span><span id='topic+textshaping-package'></span>

<h3>Description</h3>

<p>Provides access to the text shaping functionality in the 'HarfBuzz' library and the bidirectional algorithm in the 'Fribidi' library. 'textshaping' is a low-level utility package mainly for graphic devices that expands upon the font tool-set provided by the 'systemfonts' package.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Thomas Lin Pedersen <a href="mailto:thomas.pedersen@posit.co">thomas.pedersen@posit.co</a> (<a href="https://orcid.org/0000-0002-5147-4711">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Posit, PBC [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/r-lib/textshaping">https://github.com/r-lib/textshaping</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/r-lib/textshaping/issues">https://github.com/r-lib/textshaping/issues</a>
</p>
</li></ul>


<hr>
<h2 id='get_font_features'>Get available OpenType features in a font</h2><span id='topic+get_font_features'></span>

<h3>Description</h3>

<p>This is a simply functions that returns the available OpenType feature tags
for one or more fonts. See <code><a href="systemfonts.html#topic+font_feature">font_feature()</a></code> for
more information on how to use the different feature with a font.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_font_features(
  family = "",
  italic = FALSE,
  bold = FALSE,
  path = NULL,
  index = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_font_features_+3A_family">family</code></td>
<td>
<p>The name of the font families to match</p>
</td></tr>
<tr><td><code id="get_font_features_+3A_italic">italic</code></td>
<td>
<p>logical indicating the font slant</p>
</td></tr>
<tr><td><code id="get_font_features_+3A_bold">bold</code></td>
<td>
<p>logical indicating whether the font weight</p>
</td></tr>
<tr><td><code id="get_font_features_+3A_path">path</code>, <code id="get_font_features_+3A_index">index</code></td>
<td>
<p>path an index of a font file to circumvent lookup based on
family and style</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with an element for each of the input fonts containing the
supported feature tags for that font.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Select a random font on the system
sys_fonts &lt;- systemfonts::system_fonts()
random_font &lt;- sys_fonts$family[sample(nrow(sys_fonts), 1)]

# Get the features
get_font_features(random_font)

</code></pre>

<hr>
<h2 id='lorem_text'>Get gibberish text in various scripts</h2><span id='topic+lorem_text'></span><span id='topic+lorem_bidi'></span>

<h3>Description</h3>

<p>Textshaping exists partly to allow all the various scripts that exists in the
world to be used in R graphics. This function returns gibberish filler text
(lorem ipsum text) in various scripts for testing purpose. Some of these are
transliterations of the original lorem ipsum text while others are based an
a distribution model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lorem_text(
  script = c("latin", "chinese", "arabic", "devanagari", "cyrillic", "kana", "hangul",
    "greek", "hebrew", "armenian", "georgian"),
  n = 1
)

lorem_bidi(
  ltr = c("latin", "chinese", "devanagari", "cyrillic", "kana", "hangul", "greek",
    "armenian", "georgian"),
  rtl = c("arabic", "hebrew"),
  ltr_prop = 0.9,
  n = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lorem_text_+3A_script">script</code></td>
<td>
<p>A string giving the script to fetch gibberish for</p>
</td></tr>
<tr><td><code id="lorem_text_+3A_n">n</code></td>
<td>
<p>The number of paragraphs to fetch. Each paragraph will be its own
element in the returned character vector.</p>
</td></tr>
<tr><td><code id="lorem_text_+3A_ltr">ltr</code>, <code id="lorem_text_+3A_rtl">rtl</code></td>
<td>
<p>scripts to use for left-to-right and right-to-left text</p>
</td></tr>
<tr><td><code id="lorem_text_+3A_ltr_prop">ltr_prop</code></td>
<td>
<p>The approximate proportion of left-to-right text in the final
string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a charactor vector of length <code>n</code>
</p>


<h3>References</h3>

<p>https://generator.lorem-ipsum.info
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Defaults to standard lorem ipsum
lorem_text()

# Get two paragraphs of hangul (Korean)
lorem_text("hangul", 2)

# Get gibberish bi-directional text
lorem_bidi()

</code></pre>

<hr>
<h2 id='plot_shape'>Preview shaped text and the metrics for the text box</h2><span id='topic+plot_shape'></span>

<h3>Description</h3>

<p>This function allows you to preview the layout that <code><a href="#topic+shape_text">shape_text()</a></code>
calculates. It is purely meant as a sanity check to make sure that the values
calculated are sensible and shouldn't be used as a plotting function for
rendering text on its own.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_shape(shape, id = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_shape_+3A_shape">shape</code></td>
<td>
<p>The output of a call to <code><a href="#topic+shape_text">shape_text()</a></code></p>
</td></tr>
<tr><td><code id="plot_shape_+3A_id">id</code></td>
<td>
<p>The index of the text run to show in case <code>shape</code> contains
multiples</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function is called for its side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>arab_text &lt;- lorem_text("arabic", 2)
shape &lt;- shape_text(
  arab_text,
  max_width = 5,
  indent = 0.2
)

try(
 plot_shape(shape)
)

</code></pre>

<hr>
<h2 id='shape_text'>Calculate glyph positions for strings</h2><span id='topic+shape_text'></span>

<h3>Description</h3>

<p>Performs advanced text shaping of strings including font fallbacks,
bidirectional script support, word wrapping and various character and
paragraph level formatting settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shape_text(
  strings,
  id = NULL,
  family = "",
  italic = FALSE,
  weight = "normal",
  width = "undefined",
  features = font_feature(),
  size = 12,
  res = 72,
  lineheight = 1,
  align = "auto",
  hjust = 0,
  vjust = 0,
  max_width = NA,
  tracking = 0,
  indent = 0,
  hanging = 0,
  space_before = 0,
  space_after = 0,
  direction = "auto",
  path = NULL,
  index = 0,
  bold = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shape_text_+3A_strings">strings</code></td>
<td>
<p>A character vector of strings to shape</p>
</td></tr>
<tr><td><code id="shape_text_+3A_id">id</code></td>
<td>
<p>A vector grouping the strings together. If strings share an id the
shaping will continue between strings</p>
</td></tr>
<tr><td><code id="shape_text_+3A_family">family</code></td>
<td>
<p>The name of the font families to match</p>
</td></tr>
<tr><td><code id="shape_text_+3A_italic">italic</code></td>
<td>
<p>logical indicating the font slant</p>
</td></tr>
<tr><td><code id="shape_text_+3A_weight">weight</code></td>
<td>
<p>The weight to query for, either in numbers (<code>0</code>, <code>100</code>, <code>200</code>,
<code>300</code>, <code>400</code>, <code>500</code>, <code>600</code>, <code>700</code>, <code>800</code>, or <code>900</code>) or strings (<code>"undefined"</code>,
<code>"thin"</code>, <code>"ultralight"</code>, <code>"light"</code>, <code>"normal"</code>, <code>"medium"</code>, <code>"semibold"</code>,
<code>"bold"</code>, <code>"ultrabold"</code>, or <code>"heavy"</code>). <code>NA</code> will be interpreted as
<code>"undefined"</code>/<code>0</code></p>
</td></tr>
<tr><td><code id="shape_text_+3A_width">width</code></td>
<td>
<p>The width to query for either in numbers (<code>0</code>, <code>1</code>, <code>2</code>,
<code>3</code>, <code>4</code>, <code>5</code>, <code>6</code>, <code>7</code>, <code>8</code>, or <code>9</code>) or strings (<code>"undefined"</code>,
<code>"ultracondensed"</code>, <code>"extracondensed"</code>, <code>"condensed"</code>, <code>"semicondensed"</code>,
<code>"normal"</code>, <code>"semiexpanded"</code>, <code>"expanded"</code>, <code>"extraexpanded"</code>, or
<code>"ultraexpanded"</code>). <code>NA</code> will be interpreted as <code>"undefined"</code>/<code>0</code></p>
</td></tr>
<tr><td><code id="shape_text_+3A_features">features</code></td>
<td>
<p>A <code><a href="systemfonts.html#topic+font_feature">systemfonts::font_feature()</a></code> object or a list of them,
giving the OpenType font features to set</p>
</td></tr>
<tr><td><code id="shape_text_+3A_size">size</code></td>
<td>
<p>The size in points to use for the font</p>
</td></tr>
<tr><td><code id="shape_text_+3A_res">res</code></td>
<td>
<p>The resolution to use when doing the shaping. Should optimally
match the resolution used when rendering the glyphs.</p>
</td></tr>
<tr><td><code id="shape_text_+3A_lineheight">lineheight</code></td>
<td>
<p>A multiplier for the lineheight</p>
</td></tr>
<tr><td><code id="shape_text_+3A_align">align</code></td>
<td>
<p>Within text box alignment, either <code>'auto'</code>, <code>'left'</code>, <code>'center'</code>,
<code>'right'</code>, <code>'justified'</code>, <code>'justified-left'</code>, <code>'justified-right'</code>,
<code>'justified-center'</code>, or <code>'distributed'</code>. <code>'auto'</code> and <code>'justified'</code> will
chose the left or right version depending on the direction of the text.</p>
</td></tr>
<tr><td><code id="shape_text_+3A_hjust">hjust</code>, <code id="shape_text_+3A_vjust">vjust</code></td>
<td>
<p>The justification of the textbox surrounding the text</p>
</td></tr>
<tr><td><code id="shape_text_+3A_max_width">max_width</code></td>
<td>
<p>The requested with of the string in inches. Setting this to
something other than <code>NA</code> will turn on word wrapping.</p>
</td></tr>
<tr><td><code id="shape_text_+3A_tracking">tracking</code></td>
<td>
<p>Tracking of the glyphs (space adjustment) measured in 1/1000
em.</p>
</td></tr>
<tr><td><code id="shape_text_+3A_indent">indent</code></td>
<td>
<p>The indent of the first line in a paragraph measured in inches.</p>
</td></tr>
<tr><td><code id="shape_text_+3A_hanging">hanging</code></td>
<td>
<p>The indent of the remaining lines in a paragraph measured in
inches.</p>
</td></tr>
<tr><td><code id="shape_text_+3A_space_before">space_before</code>, <code id="shape_text_+3A_space_after">space_after</code></td>
<td>
<p>The spacing above and below a paragraph,
measured in points</p>
</td></tr>
<tr><td><code id="shape_text_+3A_direction">direction</code></td>
<td>
<p>The overall directional flow of the text. The default
(<code>"auto"</code>) will guess the direction based on the content of the string. Use
<code>"ltr"</code> (left-to-right) and <code>"rtl"</code> (right-to-left) to turn detection of and
set it manually.</p>
</td></tr>
<tr><td><code id="shape_text_+3A_path">path</code>, <code id="shape_text_+3A_index">index</code></td>
<td>
<p>path an index of a font file to circumvent lookup based on
family and style</p>
</td></tr>
<tr><td><code id="shape_text_+3A_bold">bold</code></td>
<td>
<p>logical indicating whether the font weight</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two element: <code>shape</code> contains the position of each glyph,
relative to the origin in the enclosing textbox. <code>metrics</code> contain metrics
about the full strings.
</p>
<p><code>shape</code> is a data.frame with the following columns:
</p>

<dl>
<dt>glyph</dt><dd><p>The placement of the the first character contributing to the glyph within the string</p>
</dd>
<dt>index</dt><dd><p>The index of the glyph in the font file</p>
</dd>
<dt>metric_id</dt><dd><p>The index of the string the glyph is part of (referencing a row in the <code>metrics</code> data.frame)</p>
</dd>
<dt>string_id</dt><dd><p>The index of the string the glyph came from (referencing an element in the <code>strings</code> input)</p>
</dd>
<dt>x_offset</dt><dd><p>The x offset in pixels from the origin of the textbox</p>
</dd>
<dt>y_offset</dt><dd><p>The y offset in pixels from the origin of the textbox</p>
</dd>
<dt>font_path</dt><dd><p>The path to the font file used during shaping of the glyph</p>
</dd>
<dt>font_index</dt><dd><p>The index of the font used to shape the glyph in the font file</p>
</dd>
<dt>font_size</dt><dd><p>The size of the font used during shaping</p>
</dd>
<dt>advance</dt><dd><p>The advancement amount to the next glyph</p>
</dd>
<dt>ascender</dt><dd><p>The ascend of the font used for the glyph. This does not measure the actual glyph</p>
</dd>
<dt>descender</dt><dd><p>The descend of the font used for the glyph. This does not measure the actual glyph</p>
</dd>
</dl>

<p><code>metrics</code> is a data.frame with the following columns:
</p>

<dl>
<dt>string</dt><dd><p>The text the string consist of</p>
</dd>
<dt>width</dt><dd><p>The width of the string</p>
</dd>
<dt>height</dt><dd><p>The height of the string</p>
</dd>
<dt>left_bearing</dt><dd><p>The distance from the left edge of the textbox and the leftmost glyph</p>
</dd>
<dt>right_bearing</dt><dd><p>The distance from the right edge of the textbox and the rightmost glyph</p>
</dd>
<dt>top_bearing</dt><dd><p>The distance from the top edge of the textbox and the topmost glyph</p>
</dd>
<dt>bottom_bearing</dt><dd><p>The distance from the bottom edge of the textbox and the bottommost glyph</p>
</dd>
<dt>left_border</dt><dd><p>The position of the leftmost edge of the textbox related to the origin</p>
</dd>
<dt>top_border</dt><dd><p>The position of the topmost edge of the textbox related to the origin</p>
</dd>
<dt>pen_x</dt><dd><p>The horizontal position of the next glyph after the string</p>
</dd>
<dt>pen_y</dt><dd><p>The vertical position of the next glyph after the string</p>
</dd>
<dt>ltr</dt><dd><p>The global direction of the string. If <code>TRUE</code> then it is left-to-right, otherwise it is right-to-left</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>string &lt;- "This is a long string\nLook; It spans multiple lines\nand all"

# Shape with default settings
shape_text(string)

# Mix styles within the same string
string &lt;- c(
  "This string will have\na ",
  "very large",
  " text style\nin the middle"
)

shape_text(string, id = c(1, 1, 1), size = c(12, 24, 12))

</code></pre>

<hr>
<h2 id='text_width'>Calculate the width of a string, ignoring new-lines</h2><span id='topic+text_width'></span>

<h3>Description</h3>

<p>This is a very simple alternative to <code><a href="systemfonts.html#topic+shape_string">systemfonts::shape_string()</a></code> that
simply calculates the width of strings without taking any newline into
account. As such it is suitable to calculate the width of words or lines that
has already been splitted by <code style="white-space: pre;">&#8288;\n&#8288;</code>. Input is recycled to the length of
<code>strings</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_width(
  strings,
  family = "",
  italic = FALSE,
  weight = "normal",
  width = "undefined",
  features = font_feature(),
  size = 12,
  res = 72,
  include_bearing = TRUE,
  path = NULL,
  index = 0,
  bold = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="text_width_+3A_strings">strings</code></td>
<td>
<p>A character vector of strings</p>
</td></tr>
<tr><td><code id="text_width_+3A_family">family</code></td>
<td>
<p>The name of the font families to match</p>
</td></tr>
<tr><td><code id="text_width_+3A_italic">italic</code></td>
<td>
<p>logical indicating the font slant</p>
</td></tr>
<tr><td><code id="text_width_+3A_weight">weight</code></td>
<td>
<p>The weight to query for, either in numbers (<code>0</code>, <code>100</code>, <code>200</code>,
<code>300</code>, <code>400</code>, <code>500</code>, <code>600</code>, <code>700</code>, <code>800</code>, or <code>900</code>) or strings (<code>"undefined"</code>,
<code>"thin"</code>, <code>"ultralight"</code>, <code>"light"</code>, <code>"normal"</code>, <code>"medium"</code>, <code>"semibold"</code>,
<code>"bold"</code>, <code>"ultrabold"</code>, or <code>"heavy"</code>). <code>NA</code> will be interpreted as
<code>"undefined"</code>/<code>0</code></p>
</td></tr>
<tr><td><code id="text_width_+3A_width">width</code></td>
<td>
<p>The width to query for either in numbers (<code>0</code>, <code>1</code>, <code>2</code>,
<code>3</code>, <code>4</code>, <code>5</code>, <code>6</code>, <code>7</code>, <code>8</code>, or <code>9</code>) or strings (<code>"undefined"</code>,
<code>"ultracondensed"</code>, <code>"extracondensed"</code>, <code>"condensed"</code>, <code>"semicondensed"</code>,
<code>"normal"</code>, <code>"semiexpanded"</code>, <code>"expanded"</code>, <code>"extraexpanded"</code>, or
<code>"ultraexpanded"</code>). <code>NA</code> will be interpreted as <code>"undefined"</code>/<code>0</code></p>
</td></tr>
<tr><td><code id="text_width_+3A_features">features</code></td>
<td>
<p>A <code><a href="systemfonts.html#topic+font_feature">systemfonts::font_feature()</a></code> object or a list of them,
giving the OpenType font features to set</p>
</td></tr>
<tr><td><code id="text_width_+3A_size">size</code></td>
<td>
<p>The size in points to use for the font</p>
</td></tr>
<tr><td><code id="text_width_+3A_res">res</code></td>
<td>
<p>The resolution to use when doing the shaping. Should optimally
match the resolution used when rendering the glyphs.</p>
</td></tr>
<tr><td><code id="text_width_+3A_include_bearing">include_bearing</code></td>
<td>
<p>Logical, should left and right bearing be included in
the string width?</p>
</td></tr>
<tr><td><code id="text_width_+3A_path">path</code>, <code id="text_width_+3A_index">index</code></td>
<td>
<p>path an index of a font file to circumvent lookup based on
family and style</p>
</td></tr>
<tr><td><code id="text_width_+3A_bold">bold</code></td>
<td>
<p>logical indicating whether the font weight</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector giving the width of the strings in pixels. Use the
provided <code>res</code> value to convert it into absolute values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>strings &lt;- c('A short string', 'A very very looong string')
text_width(strings)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
