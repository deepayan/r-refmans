<!DOCTYPE html><html lang="en"><head><title>Help for package zip</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {zip}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#zip-package'><p>zip: Cross-Platform 'zip' Compression</p></a></li>
<li><a href='#deflate'><p>Compress a raw GZIP stream</p></a></li>
<li><a href='#inflate'><p>Uncompress a raw GZIP stream</p></a></li>
<li><a href='#unzip'><p>Uncompress 'zip' Archives</p></a></li>
<li><a href='#unzip_process'><p>Class for an external unzip process</p></a></li>
<li><a href='#zip'><p>Compress Files into 'zip' Archives</p></a></li>
<li><a href='#zip_list'><p>List Files in a 'zip' Archive</p></a></li>
<li><a href='#zip_process'><p>Class for an external zip process</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Cross-Platform 'zip' Compression</td>
</tr>
<tr>
<td>Version:</td>
<td>2.3.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Cross-Platform 'zip' Compression Library. A replacement for
    the 'zip' function, that does not require any additional external
    tools on any platform.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/r-lib/zip">https://github.com/r-lib/zip</a>, <a href="https://r-lib.github.io/zip/">https://r-lib.github.io/zip/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-lib/zip/issues">https://github.com/r-lib/zip/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, pillar, processx, R6, testthat, withr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse/tidytemplate</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-01 22:18:43 UTC; gaborcsardi</td>
</tr>
<tr>
<td>Author:</td>
<td>Gábor Csárdi [aut, cre],
  Kuba Podgórski [ctb],
  Rich Geldreich [ctb],
  Posit Software, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gábor Csárdi &lt;csardi.gabor@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-01 23:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='zip-package'>zip: Cross-Platform 'zip' Compression</h2><span id='topic+zip-package'></span>

<h3>Description</h3>

<p>Cross-Platform 'zip' Compression Library. A replacement for the 'zip' function, that does not require any additional external tools on any platform.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Gábor Csárdi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Kuba Podgórski [contributor]
</p>
</li>
<li><p> Rich Geldreich [contributor]
</p>
</li>
<li><p> Posit Software, PBC [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/r-lib/zip#readme">https://github.com/r-lib/zip#readme</a>
</p>
</li>
<li> <p><a href="https://r-lib.github.io/zip/">https://r-lib.github.io/zip/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/r-lib/zip/issues">https://github.com/r-lib/zip/issues</a>
</p>
</li></ul>


<hr>
<h2 id='deflate'>Compress a raw GZIP stream</h2><span id='topic+deflate'></span>

<h3>Description</h3>

<p>Compress a raw GZIP stream
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deflate(buffer, level = 6L, pos = 1L, size = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deflate_+3A_buffer">buffer</code></td>
<td>
<p>Raw vector, containing the data to compress.</p>
</td></tr>
<tr><td><code id="deflate_+3A_level">level</code></td>
<td>
<p>Compression level, integer between 1 (fatest) and 9 (best).</p>
</td></tr>
<tr><td><code id="deflate_+3A_pos">pos</code></td>
<td>
<p>Start position of data to compress in <code>buffer</code>.</p>
</td></tr>
<tr><td><code id="deflate_+3A_size">size</code></td>
<td>
<p>Compressed size estimate, or <code>NULL</code>. If not given, or too
small, the output buffer is resized multiple times.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named list with three entries:
</p>

<ul>
<li> <p><code>output</code>: raw vector, the compressed data,
</p>
</li>
<li> <p><code>bytes_read</code>: number of bytes used from <code>buffer</code>,
</p>
</li>
<li> <p><code>bytes_written</code>: number of bytes written to the output buffer.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="base.html#topic+memCompress">base::memCompress()</a></code> does the same with <code>type = "gzip"</code>,
but it does not tell you the number of bytes read from the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data_gz &lt;- deflate(charToRaw("Hello world!"))
inflate(data_gz$output)
</code></pre>

<hr>
<h2 id='inflate'>Uncompress a raw GZIP stream</h2><span id='topic+inflate'></span>

<h3>Description</h3>

<p>Uncompress a raw GZIP stream
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inflate(buffer, pos = 1L, size = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inflate_+3A_buffer">buffer</code></td>
<td>
<p>Raw vector, containing the data to uncompress.</p>
</td></tr>
<tr><td><code id="inflate_+3A_pos">pos</code></td>
<td>
<p>Start position of data to uncompress in <code>buffer</code>.</p>
</td></tr>
<tr><td><code id="inflate_+3A_size">size</code></td>
<td>
<p>Uncompressed size estimate, or <code>NULL</code>. If not given, or too
small, the output buffer is resized multiple times.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named list with three entries:
</p>

<ul>
<li> <p><code>output</code>: raw vector, the uncompressed data,
</p>
</li>
<li> <p><code>bytes_read</code>: number of bytes used from <code>buffer</code>,
</p>
</li>
<li> <p><code>bytes_written</code>: number of bytes written to the output buffer.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="base.html#topic+memCompress">base::memDecompress()</a></code> does the same with <code>type = "gzip"</code>,
but it does not tell you the number of bytes read from the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data_gz &lt;- deflate(charToRaw("Hello world!"))
inflate(data_gz$output)
</code></pre>

<hr>
<h2 id='unzip'>Uncompress 'zip' Archives</h2><span id='topic+unzip'></span>

<h3>Description</h3>

<p><code>unzip()</code> always restores modification times of the extracted files and
directories.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unzip(zipfile, files = NULL, overwrite = TRUE, junkpaths = FALSE, exdir = ".")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unzip_+3A_zipfile">zipfile</code></td>
<td>
<p>Path to the zip file to uncompress.</p>
</td></tr>
<tr><td><code id="unzip_+3A_files">files</code></td>
<td>
<p>Character vector of files to extract from the archive.
Files within directories can be specified, but they must use a forward
slash as path separator, as this is what zip files use internally.
If <code>NULL</code>, all files will be extracted.</p>
</td></tr>
<tr><td><code id="unzip_+3A_overwrite">overwrite</code></td>
<td>
<p>Whether to overwrite existing files. If <code>FALSE</code> and
a file already exists, then an error is thrown.</p>
</td></tr>
<tr><td><code id="unzip_+3A_junkpaths">junkpaths</code></td>
<td>
<p>Whether to ignore all directory paths when creating
files. If <code>TRUE</code>, all files will be created in <code>exdir</code>.</p>
</td></tr>
<tr><td><code id="unzip_+3A_exdir">exdir</code></td>
<td>
<p>Directory to uncompress the archive to. If it does not
exist, it will be created.</p>
</td></tr>
</table>


<h3>Permissions</h3>

<p>If the zip archive stores permissions and was created on Unix,
the permissions will be restored.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## temporary directory, to avoid messing up the user's workspace.
dir.create(tmp &lt;- tempfile())
dir.create(file.path(tmp, "mydir"))
cat("first file", file = file.path(tmp, "mydir", "file1"))
cat("second file", file = file.path(tmp, "mydir", "file2"))

zipfile &lt;- tempfile(fileext = ".zip")
zip::zip(zipfile, "mydir", root = tmp)

## List contents
zip_list(zipfile)

## Extract
tmp2 &lt;- tempfile()
unzip(zipfile, exdir = tmp2)
dir(tmp2, recursive = TRUE)
</code></pre>

<hr>
<h2 id='unzip_process'>Class for an external unzip process</h2><span id='topic+unzip_process'></span>

<h3>Description</h3>

<p><code>unzip_process()</code> returns an R6 class that represents an unzip process.
It is implemented as a subclass of <a href="processx.html#topic+process">processx::process</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unzip_process()
</code></pre>


<h3>Value</h3>

<p>An <code>unzip_process</code> R6 class object, a subclass of
<a href="processx.html#topic+process">processx::process</a>.
</p>


<h3>Using the <code>unzip_process</code> class</h3>

<div class="sourceCode"><pre>up &lt;- unzip_process()$new(zipfile, exdir = ".", poll_connection = TRUE,
                           stderr = tempfile(), ...)
</pre></div>
<p>See <a href="processx.html#topic+process">processx::process</a> for the class methods.
</p>
<p>Arguments:
</p>

<ul>
<li> <p><code>zipfile</code>: Path to the zip file to uncompress.
</p>
</li>
<li> <p><code>exdir</code>: Directory to uncompress the archive to. If it does not
exist, it will be created.
</p>
</li>
<li> <p><code>poll_connection</code>: passed to the <code>initialize</code> method of
<a href="processx.html#topic+process">processx::process</a>, it allows using <code><a href="processx.html#topic+poll">processx::poll()</a></code> or the
<code>poll_io()</code> method to poll for the completion of the process.
</p>
</li>
<li> <p><code>stderr</code>: passed to the <code>initialize</code> method of <a href="processx.html#topic+process">processx::process</a>,
by default the standard error is written to a temporary file.
This file can be used to diagnose errors if the process failed.
</p>
</li>
<li> <p><code>...</code> passed to the <code>initialize</code> method of <a href="processx.html#topic+process">processx::process</a>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>ex &lt;- system.file("example.zip", package = "zip")
tmp &lt;- tempfile()
up &lt;- unzip_process()$new(ex, exdir = tmp)
up$wait()
up$get_exit_status()
dir(tmp)
</code></pre>

<hr>
<h2 id='zip'>Compress Files into 'zip' Archives</h2><span id='topic+zip'></span><span id='topic+zipr'></span><span id='topic+zip_append'></span><span id='topic+zipr_append'></span>

<h3>Description</h3>

<p><code>zip()</code> creates a new zip archive file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zip(
  zipfile,
  files,
  recurse = TRUE,
  compression_level = 9,
  include_directories = TRUE,
  root = ".",
  mode = c("mirror", "cherry-pick")
)

zipr(
  zipfile,
  files,
  recurse = TRUE,
  compression_level = 9,
  include_directories = TRUE,
  root = ".",
  mode = c("cherry-pick", "mirror")
)

zip_append(
  zipfile,
  files,
  recurse = TRUE,
  compression_level = 9,
  include_directories = TRUE,
  root = ".",
  mode = c("mirror", "cherry-pick")
)

zipr_append(
  zipfile,
  files,
  recurse = TRUE,
  compression_level = 9,
  include_directories = TRUE,
  root = ".",
  mode = c("cherry-pick", "mirror")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zip_+3A_zipfile">zipfile</code></td>
<td>
<p>The zip file to create. If the file exists, <code>zip</code>
overwrites it, but <code>zip_append</code> appends to it. If it is a directory
an error is thrown.</p>
</td></tr>
<tr><td><code id="zip_+3A_files">files</code></td>
<td>
<p>List of file to add to the archive. See details below
about absolute and relative path names.</p>
</td></tr>
<tr><td><code id="zip_+3A_recurse">recurse</code></td>
<td>
<p>Whether to add the contents of directories recursively.</p>
</td></tr>
<tr><td><code id="zip_+3A_compression_level">compression_level</code></td>
<td>
<p>A number between 1 and 9. 9 compresses best,
but it also takes the longest.</p>
</td></tr>
<tr><td><code id="zip_+3A_include_directories">include_directories</code></td>
<td>
<p>Whether to explicitly include directories
in the archive. Including directories might confuse MS Office when
reading docx files, so set this to <code>FALSE</code> for creating them.</p>
</td></tr>
<tr><td><code id="zip_+3A_root">root</code></td>
<td>
<p>Change to this working directory before creating the
archive.</p>
</td></tr>
<tr><td><code id="zip_+3A_mode">mode</code></td>
<td>
<p>Selects how files and directories are stored in
the archive. It can be <code>"mirror"</code> or <code>"cherry-pick"</code>.
See &quot;Relative Paths&quot; below for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>zip_append()</code> appends compressed files to an existing 'zip' file.
</p>


<h4>Relative paths</h4>

<p><code>zip()</code> and <code>zip_append()</code> can run in two different modes: mirror
mode and cherry picking mode. They handle the specified <code>files</code>
differently.
</p>


<h5>Mirror mode</h5>

<p>Mirror mode is for creating the zip archive of a directory structure,
exactly as it is on the disk. The current working directory will
be the root of the archive, and the paths will be fully kept.
zip changes the current directory to <code>root</code> before creating the
archive.
</p>
<p>E.g. consider the following directory structure:
</p>
<div class="sourceCode"><pre>.
|-- foo
|   |-- bar
|   |   |-- file1
|   |   `-- file2
|   `-- bar2
`-- foo2
    `-- file3
</pre></div>
<p>Assuming the current working directory is <code>foo</code>, the following zip
entries are created by <code>zip</code>:
</p>
<div class="sourceCode r"><pre>setwd("foo")
zip::zip("../test.zip", c("bar/file1", "bar2", "../foo2"))
#&gt; Warning in warn_for_dotdot(data$key): Some paths reference parent directory,
#&gt; creating non-portable zip file
zip_list("../test.zip")[, "filename", drop = FALSE]
#&gt;        filename
#&gt; 1     bar/file1
#&gt; 2         bar2/
#&gt; 3      ../foo2/
#&gt; 4 ../foo2/file3
</pre></div>
<p>Note that zip refuses to store files with absolute paths, and chops
off the leading <code>/</code> character from these file names. This is because
only relative paths are allowed in zip files.
</p>



<h5>Cherry picking mode</h5>

<p>In cherry picking mode, the selected files and directories
will be at the root of the archive. This mode is handy if you
want to select a subset of files and directories, possibly from
different paths and put all of the in the archive, at the top
level.
</p>
<p>Here is an example with the same directory structure as above:
</p>
<div class="sourceCode r"><pre>zip::zip(
  "../test2.zip",
  c("bar/file1", "bar2", "../foo2"),
  mode = "cherry-pick"
)
zip_list("../test2.zip")[, "filename", drop = FALSE]
#&gt;     filename
#&gt; 1      file1
#&gt; 2      bar2/
#&gt; 3      foo2/
#&gt; 4 foo2/file3
</pre></div>
<p>From zip version 2.3.0, <code>"."</code> has a special meaning in the <code>files</code>
argument: it will include the files (and possibly directories) within
the current working directory, but <strong>not</strong> the working directory itself.
Note that this only applies to cherry picking mode.
</p>




<h4>Permissions:</h4>

<p><code>zip()</code> (and <code>zip_append()</code>, etc.) add the permissions of
the archived files and directories to the ZIP archive, on Unix systems.
Most zip and unzip implementations support these, so they will be
recovered after extracting the archive.
</p>
<p>Note, however that the owner and group (uid and gid) are currently
omitted, even on Unix.
</p>



<h4><code>zipr()</code> and <code>zipr_append()</code></h4>

<p>These function exist for historical reasons. They are identical
to <code>zip()</code> and <code>zipr_append()</code> with a different default for the
<code>mode</code> argument.
</p>



<h3>Value</h3>

<p>The name of the created zip file, invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Some files to zip up. We will run all this in the R session's
## temporary directory, to avoid messing up the user's workspace.
dir.create(tmp &lt;- tempfile())
dir.create(file.path(tmp, "mydir"))
cat("first file", file = file.path(tmp, "mydir", "file1"))
cat("second file", file = file.path(tmp, "mydir", "file2"))

zipfile &lt;- tempfile(fileext = ".zip")
zip::zip(zipfile, "mydir", root = tmp)

## List contents
zip_list(zipfile)

## Add another file
cat("third file", file = file.path(tmp, "mydir", "file3"))
zip_append(zipfile, file.path("mydir", "file3"), root = tmp)
zip_list(zipfile)
</code></pre>

<hr>
<h2 id='zip_list'>List Files in a 'zip' Archive</h2><span id='topic+zip_list'></span>

<h3>Description</h3>

<p>List Files in a 'zip' Archive
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zip_list(zipfile)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zip_list_+3A_zipfile">zipfile</code></td>
<td>
<p>Path to an existing ZIP file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>crc32</code> is formatted using <code>as.hexmode()</code>. <code>offset</code> refers
to the start of the local zip header for each entry. Following the approach
of <code>seek()</code> it is stored as a <code>numeric</code> rather than an <code>integer</code> vector and
can therefore represent values up to <code>2^53-1</code> (9 PB).
</p>


<h3>Value</h3>

<p>A data frame with columns: <code>filename</code>, <code>compressed_size</code>,
<code>uncompressed_size</code>, <code>timestamp</code>, <code>permissions</code>, <code>crc32</code> and <code>offset</code>.
</p>

<hr>
<h2 id='zip_process'>Class for an external zip process</h2><span id='topic+zip_process'></span>

<h3>Description</h3>

<p><code>zip_process()</code> returns an R6 class that represents a zip process.
It is implemented as a subclass of <a href="processx.html#topic+process">processx::process</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zip_process()
</code></pre>


<h3>Value</h3>

<p>A <code>zip_process</code> R6 class object, a subclass of
<a href="processx.html#topic+process">processx::process</a>.
</p>


<h3>Using the <code>zip_process</code> class</h3>

<div class="sourceCode"><pre>zp &lt;- zip_process()$new(zipfile, files, recurse = TRUE,
                         poll_connection = TRUE,
                         stderr = tempfile(), ...)
</pre></div>
<p>See <a href="processx.html#topic+process">processx::process</a> for the class methods.
</p>
<p>Arguments:
</p>

<ul>
<li> <p><code>zipfile</code>: Path to the zip file to create.
</p>
</li>
<li> <p><code>files</code>: List of file to add to the archive. Each specified file
or directory in is created as a top-level entry in the zip archive.
</p>
</li>
<li> <p><code>recurse</code>: Whether to add the contents of directories recursively.
</p>
</li>
<li> <p><code>include_directories</code>: Whether to explicitly include directories
in the archive. Including directories might confuse MS Office when
reading docx files, so set this to <code>FALSE</code> for creating them.
</p>
</li>
<li> <p><code>poll_connection</code>: passed to the <code>initialize</code> method of
<a href="processx.html#topic+process">processx::process</a>, it allows using <code><a href="processx.html#topic+poll">processx::poll()</a></code> or the
<code>poll_io()</code> method to poll for the completion of the process.
</p>
</li>
<li> <p><code>stderr</code>: passed to the <code>initialize</code> method of <a href="processx.html#topic+process">processx::process</a>,
by default the standard error is written to a temporary file.
This file can be used to diagnose errors if the process failed.
</p>
</li>
<li> <p><code>...</code> passed to the <code>initialize</code> method of <a href="processx.html#topic+process">processx::process</a>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>dir.create(tmp &lt;- tempfile())
write.table(iris, file = file.path(tmp, "iris.ssv"))
zipfile &lt;- tempfile(fileext = ".zip")
zp &lt;- zip_process()$new(zipfile, tmp)
zp$wait()
zp$get_exit_status()
zip_list(zipfile)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
