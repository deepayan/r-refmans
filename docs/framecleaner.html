<!DOCTYPE html><html><head><title>Help for package framecleaner</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {framecleaner}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#as_integer16_or_64'><p>as_integer16_or_64</p></a></li>
<li><a href='#auto_setwd'><p>auto setwd</p></a></li>
<li><a href='#clean_frame'><p>Clean Data Frame</p></a></li>
<li><a href='#create_dummies'><p>create dummies</p></a></li>
<li><a href='#create_flag'><p>create flag</p></a></li>
<li><a href='#date_yh'><p>date_yh</p></a></li>
<li><a href='#date_ym'><p>date_ym</p></a></li>
<li><a href='#date_yq'><p>date_yq</p></a></li>
<li><a href='#fill_na'><p>Fill NAs</p></a></li>
<li><a href='#filter_for'><p>filter for</p></a></li>
<li><a href='#filter_missing'><p>filter out missings</p></a></li>
<li><a href='#import_dir'><p>import directory</p></a></li>
<li><a href='#import_tibble'><p>import tibble</p></a></li>
<li><a href='#is_integerish_character'><p>is integerish character</p></a></li>
<li><a href='#is_integery'><p>is integery</p></a></li>
<li><a href='#is_missing_or_inf'><p>is missing or inf</p></a></li>
<li><a href='#is_probability'><p>is_probability</p></a></li>
<li><a href='#make_na.data.frame'><p>Make NAs</p></a></li>
<li><a href='#pad_auto'><p>pad auto</p></a></li>
<li><a href='#pad_col'><p>pad column</p></a></li>
<li><a href='#recode_chr'><p>recode_chr</p></a></li>
<li><a href='#relocate_all'><p>Relocate All</p></a></li>
<li><a href='#remove_infs'><p>remove infs</p></a></li>
<li><a href='#remove_nans'><p>remove nans</p></a></li>
<li><a href='#remove_nas'><p>remove nas</p></a></li>
<li><a href='#remove_whitespace'><p>Remove Whitespace</p></a></li>
<li><a href='#select_otherwise'><p>select_otherwise</p></a></li>
<li><a href='#set_chr'><p>set character</p></a></li>
<li><a href='#set_date'><p>set date</p></a></li>
<li><a href='#set_dbl'><p>set double</p></a></li>
<li><a href='#set_fct'><p>set factor</p></a></li>
<li><a href='#set_int'><p>set integer</p></a></li>
<li><a href='#set_lgl.data.frame'><p>set logical</p></a></li>
<li><a href='#set_type_groups'><p>set type groups</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Clean Data Frames</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Harrison Tietze &lt;Harrison4192@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a friendly interface for modifying data frames with a sequence of piped commands built upon the 'tidyverse' Wickham et al., (2019) &lt;<a href="https://doi.org/10.21105%2Fjoss.01686">doi:10.21105/joss.01686</a>&gt; . The majority of commands wrap 'dplyr' mutate statements in a convenient way to concisely solve common issues that arise when tidying small to medium data sets. Includes smart defaults and allows flexible selection of columns via 'tidyselect'. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, stringr, tidyselect, purrr, janitor, rlang, lubridate,
magrittr, tibble, rstudioapi, forcats, bit64, rio, readr,
vroom, fs, rlist, fastDummies</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, badger, readxl</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://harrison4192.github.io/framecleaner/">https://harrison4192.github.io/framecleaner/</a>,
<a href="https://github.com/Harrison4192/framecleaner">https://github.com/Harrison4192/framecleaner</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Harrison4192/framecleaner/issues">https://github.com/Harrison4192/framecleaner/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-15 06:58:32 UTC; 81804</td>
</tr>
<tr>
<td>Author:</td>
<td>Harrison Tietze [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-15 07:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='as_integer16_or_64'>as_integer16_or_64</h2><span id='topic+as_integer16_or_64'></span>

<h3>Description</h3>

<p>coerce to integer. if too large, coerces to 64-bit integer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_integer16_or_64(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_integer16_or_64_+3A_x">x</code></td>
<td>
<p>integerish vec</p>
</td></tr>
</table>


<h3>Value</h3>

<p>int or int64
</p>

<hr>
<h2 id='auto_setwd'>auto setwd</h2><span id='topic+auto_setwd'></span>

<h3>Description</h3>

<p>Call from a saved R script. Automatically sets your working directory to the directory that you saved the current
R script in. Takes no arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto_setwd()
</code></pre>


<h3>Value</h3>

<p>No return value.
</p>

<hr>
<h2 id='clean_frame'>Clean Data Frame</h2><span id='topic+clean_frame'></span>

<h3>Description</h3>

<p>Uses the functions of framecleaner and other operations to apply cleaning operations to a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_frame(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_frame_+3A_.data">.data</code></td>
<td>
<p>a data frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions applied in <code>clean_frame</code>
</p>

<ul>
<li><p><code><a href="janitor.html#topic+remove_empty">remove_empty</a></code>
</p>
</li>
<li><p><code><a href="dplyr.html#topic+rename_with">rename_with</a></code> <code>.fn = <a href="base.html#topic+enc2utf8">enc2utf8</a></code>
</p>
</li>
<li><p><code><a href="janitor.html#topic+clean_names">clean_names</a></code> <code>case = "all_caps", ascii = FALSE)</code>
</p>
</li>
<li><p><code><a href="#topic+set_int">set_int</a></code>
</p>
</li>
<li><p><code><a href="#topic+set_date">set_date</a></code>
</p>
</li>
<li><p><code><a href="#topic+make_na">make_na</a></code>
</p>
</li>
<li><p><code><a href="tibble.html#topic+as_tibble">as_tibble</a></code>
</p>
</li></ul>



<h3>Value</h3>

<p>data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
iris %&gt;%
clean_frame()
</code></pre>

<hr>
<h2 id='create_dummies'>create dummies</h2><span id='topic+create_dummies'></span>

<h3>Description</h3>

<p>adapted from the <code><a href="fastDummies.html#topic+dummy_cols">dummy_cols</a></code> function Added the option to truncate the dummy column
names, and to specify dummy cols using tidyselect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_dummies(
  .data,
  ...,
  append_col_name = TRUE,
  max_levels = 10L,
  remove_first_dummy = FALSE,
  remove_most_frequent_dummy = FALSE,
  clean_names = TRUE,
  ignore_na = FALSE,
  split = NULL,
  remove_selected_columns = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_dummies_+3A_.data">.data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="create_dummies_+3A_...">...</code></td>
<td>
<p>tidyselect columns. default selection is all character or factor variables</p>
</td></tr>
<tr><td><code id="create_dummies_+3A_append_col_name">append_col_name</code></td>
<td>
<p>logical, default TRUE. Appends original column name to dummy col name</p>
</td></tr>
<tr><td><code id="create_dummies_+3A_max_levels">max_levels</code></td>
<td>
<p>uses <code><a href="forcats.html#topic+fct_lump_n">fct_lump_n</a></code> to limit the number of categories. Only the top n levels are preserved, and the rest being lumped into &quot;other&quot;. Default is set to 10 levels, to prevent accidental overload. Set value to <code>Inf</code> to use all levels</p>
</td></tr>
<tr><td><code id="create_dummies_+3A_remove_first_dummy">remove_first_dummy</code></td>
<td>
<p>logical, default FALSE.</p>
</td></tr>
<tr><td><code id="create_dummies_+3A_remove_most_frequent_dummy">remove_most_frequent_dummy</code></td>
<td>
<p>logical, default FALSE</p>
</td></tr>
<tr><td><code id="create_dummies_+3A_clean_names">clean_names</code></td>
<td>
<p>logical, default TRUE. apply  <code><a href="janitor.html#topic+clean_names">clean_names</a></code></p>
</td></tr>
<tr><td><code id="create_dummies_+3A_ignore_na">ignore_na</code></td>
<td>
<p>logical, default FALSE</p>
</td></tr>
<tr><td><code id="create_dummies_+3A_split">split</code></td>
<td>
<p>NULL</p>
</td></tr>
<tr><td><code id="create_dummies_+3A_remove_selected_columns">remove_selected_columns</code></td>
<td>
<p>logical, default TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>reference the <a href="https://jacobkap.github.io/fastDummies/index.html">fastDummies</a> package for documentation on the original function.
</p>


<h3>Value</h3>

<p>data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
iris %&gt;%
create_dummies(Species, append_col_name = FALSE) %&gt;%
  tibble::as_tibble()


</code></pre>

<hr>
<h2 id='create_flag'>create flag</h2><span id='topic+create_flag'></span>

<h3>Description</h3>

<p>create flag
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_flag(.data, col, flag, full_name = FALSE, drop = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_flag_+3A_.data">.data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="create_flag_+3A_col">col</code></td>
<td>
<p>column</p>
</td></tr>
<tr><td><code id="create_flag_+3A_flag">flag</code></td>
<td>
<p>column entry</p>
</td></tr>
<tr><td><code id="create_flag_+3A_full_name">full_name</code></td>
<td>
<p>Logical. default F. if T, new column name is original name + flag. other wise just flag</p>
</td></tr>
<tr><td><code id="create_flag_+3A_drop">drop</code></td>
<td>
<p>logical. default F. If T, drop original column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
iris %&gt;%
  create_flag(
  col = Species,
  flag = "versicolor",
  drop = TRUE) %&gt;%
  head()

</code></pre>

<hr>
<h2 id='date_yh'>date_yh</h2><span id='topic+date_yh'></span>

<h3>Description</h3>

<p>creates a semesterly date vector from a date vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_yh(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="date_yh_+3A_x">x</code></td>
<td>
<p>a date</p>
</td></tr>
</table>


<h3>Value</h3>

<p>date vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
seq.Date(lubridate::ymd(20200101), lubridate::ymd(20220101), length.out = 10) -&gt; d1
d1 %&gt;%
  tibble::enframe() %&gt;%
  dplyr::mutate(YH = date_yh(value))
</code></pre>

<hr>
<h2 id='date_ym'>date_ym</h2><span id='topic+date_ym'></span>

<h3>Description</h3>

<p>creates a monthly date vector from a date vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_ym(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="date_ym_+3A_x">x</code></td>
<td>
<p>a date</p>
</td></tr>
</table>


<h3>Value</h3>

<p>date vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
seq.Date(lubridate::ymd(20200101), lubridate::ymd(20220101), length.out = 10) -&gt; d1
d1 %&gt;%
  tibble::enframe() %&gt;%
  dplyr::mutate(YM = date_ym(value))
</code></pre>

<hr>
<h2 id='date_yq'>date_yq</h2><span id='topic+date_yq'></span>

<h3>Description</h3>

<p>creates a quarterly date vector from a date vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_yq(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="date_yq_+3A_x">x</code></td>
<td>
<p>a date</p>
</td></tr>
</table>


<h3>Value</h3>

<p>date vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
seq.Date(lubridate::ymd(20200101), lubridate::ymd(20220101), length.out = 10) -&gt; d1
d1 %&gt;%
  tibble::enframe() %&gt;%
  dplyr::mutate(YQ = date_yq(value))
</code></pre>

<hr>
<h2 id='fill_na'>Fill NAs</h2><span id='topic+fill_na'></span>

<h3>Description</h3>

<p>use tidyselect to fill <code>NA</code> values
Default behavior is to fill all integer or double columns cols with 0, preserving their types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill_na(.data, ..., fill = 0L, missing_type = c("all", "NA", "NaN", "Inf"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fill_na_+3A_.data">.data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="fill_na_+3A_...">...</code></td>
<td>
<p>tidyselect specification. Default selection: none</p>
</td></tr>
<tr><td><code id="fill_na_+3A_fill">fill</code></td>
<td>
<p>value to fill missings</p>
</td></tr>
<tr><td><code id="fill_na_+3A_missing_type">missing_type</code></td>
<td>
<p>character vector. Choose what type of missing to fill. Default is all types. choose from &quot;all&quot;, &quot;Na&quot;, &quot;NaN&quot;, &quot;Inf&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tibble::tibble(x = c(NA, 1L, 2L, NA, NaN, 5L, Inf)) -&gt; tbl

tbl %&gt;%
  fill_na()

tbl %&gt;%
 fill_na(fill = 1L, missing_type = "Inf")

tbl %&gt;%
 fill_na(missing_type = "NaN")

</code></pre>

<hr>
<h2 id='filter_for'>filter for</h2><span id='topic+filter_for'></span>

<h3>Description</h3>

<p>Filter for all instances of a column that meet a specific condition at least once.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_for(.data, what, where)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_for_+3A_.data">.data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="filter_for_+3A_what">what</code></td>
<td>
<p>unquote col or vector of unquoted cols.</p>
</td></tr>
<tr><td><code id="filter_for_+3A_where">where</code></td>
<td>
<p>a logical condition used for filter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# An example using some time series data
tibble::tibble( CLIENT_ID = c("A1001", "B1001", "C1001",
"A1001", "B1001", "C1001", "A1001", "B1001", "C1001"),
                YEAR = c(2019L, 2019L, 2019L, 2020L, 2020L, 2020L, 2021L, 2021L, 2021L),
                SALES = c(3124, 56424, 3214132, 65534, 2342, 6566, 87654, 2332, 6565)
) %&gt;%
dplyr::arrange(CLIENT_ID, YEAR) -&gt; sales_data

sales_data

# filter for Clients that had sales greater than 4000 in the year 2019.
# this way we can see how the same clients sales looked in subsequent years

sales_data %&gt;%
  filter_for(what = CLIENT_ID, where = YEAR == 2019 &amp; SALES &gt; 4000L)


# filter for clients whose sales were less than 4000 in the year 2021
 sales_data %&gt;%
  filter_for(what = CLIENT_ID, where = YEAR == 2021 &amp; SALES &lt; 4000L)
</code></pre>

<hr>
<h2 id='filter_missing'>filter out missings</h2><span id='topic+filter_missing'></span><span id='topic+filter_missing.data.frame'></span>

<h3>Description</h3>

<p>More complex wrapper around <code>dplyr::filter(!is.na())</code> to remove <code>NA</code> rows using tidyselect. If any specified column contains an <code>NA</code>
the whole row is removed. Reports the amount of rows removed containing <code>NaN</code>, <code>NA</code>, <code>Inf</code>, in that order.
For example if one row contains <code>Inf</code> in one column and  in another, the removed row will be counted in the <code>NA</code> tally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_missing(.data, ..., remove_inf = TRUE)

## S3 method for class 'data.frame'
filter_missing(.data, ..., remove_inf = TRUE, condition = c("any", "all"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_missing_+3A_.data">.data</code></td>
<td>
<p>dataframe</p>
</td></tr>
<tr><td><code id="filter_missing_+3A_...">...</code></td>
<td>
<p>tidyselect. default selection is all columns</p>
</td></tr>
<tr><td><code id="filter_missing_+3A_remove_inf">remove_inf</code></td>
<td>
<p>logical. default is to also remove <code>Inf</code> values. set to <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="filter_missing_+3A_condition">condition</code></td>
<td>
<p>defaults to &quot;any&quot;. in which case removes rows if <code>NA</code> is in any specified column. &quot;all&quot; will remove rows only if each specified column is missing</p>
</td></tr>
</table>


<h3>Details</h3>

<p>S3 method, can also be used on vectors
</p>


<h3>Value</h3>

<p>data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tibble::tibble(x = c(NA, 1L, 2L, NA, NaN, 5L, Inf),
y = c(1L, NA, 2L, NA, Inf, 5L, Inf)) -&gt; tbl1

tbl1

# remove any row with a missing or Inf
tbl1 %&gt;%
filter_missing()

# remove any row with Na or NaN in the x column
tbl1 %&gt;%
filter_missing(x, remove_inf = FALSE)

# only remove rows where every entry is Na, NaN, or Inf
tbl1 %&gt;%
filter_missing(condition = "all")
</code></pre>

<hr>
<h2 id='import_dir'>import directory</h2><span id='topic+import_dir'></span>

<h3>Description</h3>

<p>import directory
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_dir(
  dir,
  ...,
  method = c("rio", "vroom", "vroom_jp", "read_csv"),
  return_type = c("df", "list")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import_dir_+3A_dir">dir</code></td>
<td>
<p>dir path</p>
</td></tr>
<tr><td><code id="import_dir_+3A_...">...</code></td>
<td>
<p>arguments passed to import method</p>
</td></tr>
<tr><td><code id="import_dir_+3A_method">method</code></td>
<td>
<p>import method chosen from import tibble</p>
</td></tr>
<tr><td><code id="import_dir_+3A_return_type">return_type</code></td>
<td>
<p>default is to bind dataframes together and remove duplicates. only recommended
for a folder of files with the same data format. otherwise specify return as list of data frames</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>

<hr>
<h2 id='import_tibble'>import tibble</h2><span id='topic+import_tibble'></span>

<h3>Description</h3>

<p>wrapper around multiple file readers. The default being <code><a href="rio.html#topic+import">import</a></code> set to return a tibble
Also available  <code><a href="vroom.html#topic+vroom">vroom</a></code> and <code>vroom_jp</code> for japanese characters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_tibble(
  path,
  ...,
  method = c("rio", "vroom", "vroom_jp", "read_csv", "read_excel")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import_tibble_+3A_path">path</code></td>
<td>
<p>filepath</p>
</td></tr>
<tr><td><code id="import_tibble_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
<tr><td><code id="import_tibble_+3A_method">method</code></td>
<td>
<p>method of import. default is rio</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Supports multiple types of importing through <code>method</code>
</p>


<h3>Value</h3>

<p>a tibble
</p>

<hr>
<h2 id='is_integerish_character'>is integerish character</h2><span id='topic+is_integerish_character'></span>

<h3>Description</h3>

<p>companion to rlang::is_integerish that returns true only for  integerish character vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_integerish_character(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_integerish_character_+3A_x">x</code></td>
<td>
<p>a vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical
</p>

<hr>
<h2 id='is_integery'>is integery</h2><span id='topic+is_integery'></span>

<h3>Description</h3>

<p>practical extension of rlang::is_integerish that supports integer64, integers in character strings,
and doesn't coerce factors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_integery(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_integery_+3A_x">x</code></td>
<td>
<p>a vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>

<hr>
<h2 id='is_missing_or_inf'>is missing or inf</h2><span id='topic+is_missing_or_inf'></span>

<h3>Description</h3>

<p>is missing or inf
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_missing_or_inf(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_missing_or_inf_+3A_x">x</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>

<hr>
<h2 id='is_probability'>is_probability</h2><span id='topic+is_probability'></span>

<h3>Description</h3>

<p>is_probability
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_probability(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_probability_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>

<hr>
<h2 id='make_na.data.frame'>Make NAs</h2><span id='topic+make_na.data.frame'></span><span id='topic+make_na'></span>

<h3>Description</h3>

<p>Set elements to NA values using tidyselect specification.
Don't use this function on columns of different modes at once.
Defaults to choosing all character columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
make_na(.data, ..., vec = c("-", "", " ", "null", "NA", "NA_"))

make_na(.data, ..., vec = c("-", "", " ", "null", "NA", "NA_"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_na.data.frame_+3A_.data">.data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="make_na.data.frame_+3A_...">...</code></td>
<td>
<p>tidyselect. Default selection: all chr cols</p>
</td></tr>
<tr><td><code id="make_na.data.frame_+3A_vec">vec</code></td>
<td>
<p>vector of possible elements to replace with NA</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# easily set NA values. blank space and empty space are default options

tibble::tibble(x = c("a", "b", "", "d", " ", "", "e")) %&gt;%
   make_na()

</code></pre>

<hr>
<h2 id='pad_auto'>pad auto</h2><span id='topic+pad_auto'></span>

<h3>Description</h3>

<p>Automatically pads elements of a column to the largest sized element. Useful when an integer code with
leading zeros is read in as an integer and needs to be fixed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pad_auto(mdb, ..., side = "left", pad = "0")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pad_auto_+3A_mdb">mdb</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="pad_auto_+3A_...">...</code></td>
<td>
<p>tidyselect specification</p>
</td></tr>
<tr><td><code id="pad_auto_+3A_side">side</code></td>
<td>
<p>str_pad side</p>
</td></tr>
<tr><td><code id="pad_auto_+3A_pad">pad</code></td>
<td>
<p>str_pad pad</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# good for putting leading 0's

tibble::tibble(x = 1:10) %&gt;%
  pad_auto(x)
</code></pre>

<hr>
<h2 id='pad_col'>pad column</h2><span id='topic+pad_col'></span>

<h3>Description</h3>

<p>wrapper around mutate and str_pad
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pad_col(mdb, ..., width, pad = "0", side = "left")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pad_col_+3A_mdb">mdb</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="pad_col_+3A_...">...</code></td>
<td>
<p>tidyselect</p>
</td></tr>
<tr><td><code id="pad_col_+3A_width">width</code></td>
<td>
<p>str_pad width</p>
</td></tr>
<tr><td><code id="pad_col_+3A_pad">pad</code></td>
<td>
<p>str_pad pad</p>
</td></tr>
<tr><td><code id="pad_col_+3A_side">side</code></td>
<td>
<p>str_pad side</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # manually pad with 0's (or other value)
 # use case over [pad_auto()]: the desired width is greater than the widest element

 tibble::tibble(
 ID = c(2, 13, 86, 302)
 ) %&gt;%
 pad_col(ID, width = 4)
</code></pre>

<hr>
<h2 id='recode_chr'>recode_chr</h2><span id='topic+recode_chr'></span>

<h3>Description</h3>

<p>recode_chr
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recode_chr(df, col, old_names, new_name, regex = FALSE, negate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recode_chr_+3A_df">df</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="recode_chr_+3A_col">col</code></td>
<td>
<p>unquoted col</p>
</td></tr>
<tr><td><code id="recode_chr_+3A_old_names">old_names</code></td>
<td>
<p>character vector or regular expression</p>
</td></tr>
<tr><td><code id="recode_chr_+3A_new_name">new_name</code></td>
<td>
<p>atomic chr string</p>
</td></tr>
<tr><td><code id="recode_chr_+3A_regex">regex</code></td>
<td>
<p>Logical, default F. Specify elements for old_names using a regex?</p>
</td></tr>
<tr><td><code id="recode_chr_+3A_negate">negate</code></td>
<td>
<p>logical, defailt F. If negating the regex, set to T</p>
</td></tr>
</table>


<h3>Value</h3>

<p>df
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Use a negative regex to rename all species other than "virginica" to "none"

iris %&gt;%
   recode_chr(
 col = Species,
 old_names = "vir",
 new_name = "none",
 regex = TRUE,
 negate = TRUE) %&gt;%
 dplyr::count(Species)

# Specify old names using a regex

iris %&gt;%
   recode_chr(
   col = Species,
   old_names = "set|vir",
   new_name = "other",
   regex = TRUE) %&gt;%
   dplyr::count(Species)
</code></pre>

<hr>
<h2 id='relocate_all'>Relocate All</h2><span id='topic+relocate_all'></span>

<h3>Description</h3>

<p>Arranges columns alphabetically and then by type
The user can supply a tidyselect argument to specify columns that should come first
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relocate_all(.data, ..., regex = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relocate_all_+3A_.data">.data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="relocate_all_+3A_...">...</code></td>
<td>
<p>a tidyselect specification</p>
</td></tr>
<tr><td><code id="relocate_all_+3A_regex">regex</code></td>
<td>
<p>a regular expression to match columns that will be put at the front of the df</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
iris %&gt;%
head %&gt;%
relocate_all(matches("Petal"))

</code></pre>

<hr>
<h2 id='remove_infs'>remove infs</h2><span id='topic+remove_infs'></span>

<h3>Description</h3>

<p>remove infs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_infs(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_infs_+3A_x">x</code></td>
<td>
<p>vec</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vec
</p>

<hr>
<h2 id='remove_nans'>remove nans</h2><span id='topic+remove_nans'></span>

<h3>Description</h3>

<p>remove nans
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_nans(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_nans_+3A_x">x</code></td>
<td>
<p>vec</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vec
</p>

<hr>
<h2 id='remove_nas'>remove nas</h2><span id='topic+remove_nas'></span>

<h3>Description</h3>

<p>remove nas
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_nas(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_nas_+3A_x">x</code></td>
<td>
<p>vec</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vec
</p>

<hr>
<h2 id='remove_whitespace'>Remove Whitespace</h2><span id='topic+remove_whitespace'></span>

<h3>Description</h3>

<p>Remove whitespace from columns using a tidyselect specification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_whitespace(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_whitespace_+3A_.data">.data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="remove_whitespace_+3A_...">...</code></td>
<td>
<p>tidyselect specification (default selection:  all character columns)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tibble::tibble(a = c(" a ", "b ", " c")) -&gt; t1

t1

t1 %&gt;%
remove_whitespace()
</code></pre>

<hr>
<h2 id='select_otherwise'>select_otherwise</h2><span id='topic+select_otherwise'></span>

<h3>Description</h3>

<p>flexible select operator that powers the tidy consultant universe. Used to set sensible defaults
and flexibly return the chosen columns. A developer focused function, but may be useful in
interactive programming due to the ability to return different types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_otherwise(
  .data,
  ...,
  otherwise = NULL,
  col = NULL,
  return_type = c("names", "index", "df")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_otherwise_+3A_.data">.data</code></td>
<td>
<p>dataframe</p>
</td></tr>
<tr><td><code id="select_otherwise_+3A_...">...</code></td>
<td>
<p>tidyselect. columns to choose</p>
</td></tr>
<tr><td><code id="select_otherwise_+3A_otherwise">otherwise</code></td>
<td>
<p>tidyselect. default columns to choose if ... is not specified</p>
</td></tr>
<tr><td><code id="select_otherwise_+3A_col">col</code></td>
<td>
<p>tidyselect. column to choose regardless of ... or otherwise specifications</p>
</td></tr>
<tr><td><code id="select_otherwise_+3A_return_type">return_type</code></td>
<td>
<p>choose to return column index, names, or df. defaults to index</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer vector by default. possibly data frame or character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
iris %&gt;%
select_otherwise(where(is.double), return_type = "index")
</code></pre>

<hr>
<h2 id='set_chr'>set character</h2><span id='topic+set_chr'></span>

<h3>Description</h3>

<p>set character
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_chr(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_chr_+3A_.data">.data</code></td>
<td>
<p>dataframe</p>
</td></tr>
<tr><td><code id="set_chr_+3A_...">...</code></td>
<td>
<p>tidyselect. Default selection: none</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
iris %&gt;%
tibble::as_tibble() %&gt;%
set_chr(tidyselect::everything())

</code></pre>

<hr>
<h2 id='set_date'>set date</h2><span id='topic+set_date'></span>

<h3>Description</h3>

<p>set dates manually or automatically
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_date(.data, ..., date_fn = lubridate::ymd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_date_+3A_.data">.data</code></td>
<td>
<p>dataframe</p>
</td></tr>
<tr><td><code id="set_date_+3A_...">...</code></td>
<td>
<p>tidyselect</p>
</td></tr>
<tr><td><code id="set_date_+3A_date_fn">date_fn</code></td>
<td>
<p>a function to convert to a date object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>note: can be called without any <code>...</code> arguments and instead automatically determines which character columns
are actually dates, then proceeds to set them. It checks for the date specified in <code>date_fn</code> and also <code><a href="lubridate.html#topic+ymd_hms">ymd_hms</a></code>.
On auto detect mode, it sets <code><a href="lubridate.html#topic+ymd_hms">ymd_hms</a></code> output to ymd dates instead of datetimes with hms. This is because of the common occurrence
of trying to extract a <code><a href="lubridate.html#topic+ymd">ymd</a></code> date from an excel workbook, and having it come with extra 00:00:00. If you need a datetime, manually
supply the appropriate <a href="https://lubridate.tidyverse.org/">lubridate</a> function.
</p>
<p>Auto mode is experimental. Commonly detected error is a long character string of integers being interpreted as a date.
</p>


<h3>Value</h3>

<p>tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tibble::tibble(date_col1 = c("20190101", "20170205"),
date_col2 = c("20201015", "20180909"),
not_date_col = c("a345", "b040")) -&gt; t1

t1

t1 %&gt;%
set_date()

t1 %&gt;%
set_date(date_col1)
</code></pre>

<hr>
<h2 id='set_dbl'>set double</h2><span id='topic+set_dbl'></span><span id='topic+set_dbl.character'></span><span id='topic+set_dbl.factor'></span><span id='topic+set_dbl.Date'></span><span id='topic+set_dbl.numeric'></span><span id='topic+set_dbl.integer64'></span><span id='topic+set_dbl.data.frame'></span>

<h3>Description</h3>

<p>set double
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_dbl(.data, ...)

## S3 method for class 'character'
set_dbl(.data, ...)

## S3 method for class 'factor'
set_dbl(.data, ...)

## S3 method for class 'Date'
set_dbl(.data, ...)

## S3 method for class 'numeric'
set_dbl(.data, ...)

## S3 method for class 'integer64'
set_dbl(.data, ...)

## S3 method for class 'data.frame'
set_dbl(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_dbl_+3A_.data">.data</code></td>
<td>
<p>dataframe</p>
</td></tr>
<tr><td><code id="set_dbl_+3A_...">...</code></td>
<td>
<p>tidyselect. Default selection: none</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


date_col &lt;- c(lubridate::ymd(20180101), lubridate::ymd(20210420))


tibble::tibble(int = c(1L, 2L),
fct = factor(c(10, 11)),
date = date_col,
chr = c("a2.1", "rtg50.5")) -&gt; t1

t1

t1 %&gt;%
set_dbl(tidyselect::everything())

# s3 method works for vectors individually
# custom date coercion to represent date as a number. For lubridate's coercion method, use set_int
date_col %&gt;%
set_dbl

</code></pre>

<hr>
<h2 id='set_fct'>set factor</h2><span id='topic+set_fct'></span><span id='topic+set_fct.data.frame'></span><span id='topic+set_fct.default'></span>

<h3>Description</h3>

<p>allows option to manually set the first level of the factor, for consistency with
yardstick which automatically considers the first level
as the &quot;positive class&quot; when evaluating classification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_fct(
  .data,
  ...,
  first_level = NULL,
  order_fct = FALSE,
  labels = NULL,
  max_levels = Inf
)

## S3 method for class 'data.frame'
set_fct(.data, ..., first_level = NULL, order_fct = FALSE, max_levels = Inf)

## Default S3 method:
set_fct(.data, ..., first_level = NULL, order_fct = FALSE, max_levels = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_fct_+3A_.data">.data</code></td>
<td>
<p>dataframe</p>
</td></tr>
<tr><td><code id="set_fct_+3A_...">...</code></td>
<td>
<p>tidyselect (default selection: all character columns)</p>
</td></tr>
<tr><td><code id="set_fct_+3A_first_level">first_level</code></td>
<td>
<p>character string to set the first level of the factor</p>
</td></tr>
<tr><td><code id="set_fct_+3A_order_fct">order_fct</code></td>
<td>
<p>logical. ordered factor?</p>
</td></tr>
<tr><td><code id="set_fct_+3A_labels">labels</code></td>
<td>
<p>chr vector of labels, length equal to factor levels</p>
</td></tr>
<tr><td><code id="set_fct_+3A_max_levels">max_levels</code></td>
<td>
<p>integer. uses <code><a href="forcats.html#topic+fct_lump_n">fct_lump_n</a></code> to limit the number of categories. Only the top <code>max_levels</code> are preserved, and the rest being lumped into &quot;other&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## simply set the first level of a factor

iris$Species %&gt;% levels

iris %&gt;%
  set_fct(Species, first_level = "virginica") %&gt;%
  dplyr::pull(Species) %&gt;%
  levels()
</code></pre>

<hr>
<h2 id='set_int'>set integer</h2><span id='topic+set_int'></span><span id='topic+set_int.data.frame'></span><span id='topic+set_int.grouped_df'></span>

<h3>Description</h3>

<p>set integer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_int(.data, ...)

## S3 method for class 'data.frame'
set_int(.data, ...)

## S3 method for class 'grouped_df'
set_int(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_int_+3A_.data">.data</code></td>
<td>
<p>dataframe</p>
</td></tr>
<tr><td><code id="set_int_+3A_...">...</code></td>
<td>
<p>tidyselect. Default Selecton: integerish doubles or integerish characters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

int_vec &lt;- c("1", "2", "10")

tibble::tibble(
  chr_int = int_vec,
  dbl_int = c(1.0, 5.0, 20.0),
  chr_int64 = c("1033493932", "4432500065", "30303022192"),
  string_int = c("SALES2020", "SALES2021", "SALES2022")) -&gt; tbl

# automatically coerce integerish cols in a tibble
tbl

# integerish doubles or chars will be detected for coercion automatically
tbl %&gt;%
  set_int()

# string_int requires parsing, so it must be specified directly for coercion
tbl %&gt;%
  set_int(matches("str|chr"))

# s3 method works for vectors as well

int_vec

int_vec %&gt;%
set_int()
</code></pre>

<hr>
<h2 id='set_lgl.data.frame'>set logical</h2><span id='topic+set_lgl.data.frame'></span><span id='topic+set_lgl'></span><span id='topic+set_lgl.default'></span><span id='topic+set_lgl.numeric'></span><span id='topic+set_lgl.character'></span>

<h3>Description</h3>

<p>note: for non-binary data, all values other than the true_level will be set to false
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
set_lgl(.data, ..., true_level = 1L)

set_lgl(.data, ..., true_level = 1L)

## Default S3 method:
set_lgl(.data, ...)

## S3 method for class 'numeric'
set_lgl(.data, ..., true_level = 1L)

## S3 method for class 'character'
set_lgl(.data, ..., true_level = c("T", "TRUE"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_lgl.data.frame_+3A_.data">.data</code></td>
<td>
<p>dataframe</p>
</td></tr>
<tr><td><code id="set_lgl.data.frame_+3A_...">...</code></td>
<td>
<p>tidyselect. Default selection: none</p>
</td></tr>
<tr><td><code id="set_lgl.data.frame_+3A_true_level">true_level</code></td>
<td>
<p>specify the value to set as TRUE. Default value is 1 for seamless conversion between logicals and integers. Can be given as a vector of values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dataframe
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# convert a 1/0 vector back into T/F

tibble::tibble(x = c(1, 0, 0, 1, 0, 1)) %&gt;%
set_lgl(x)
</code></pre>

<hr>
<h2 id='set_type_groups'>set type groups</h2><span id='topic+set_type_groups'></span>

<h3>Description</h3>

<p>set type groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_type_groups(.data, ..., setter)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_type_groups_+3A_.data">.data</code></td>
<td>
<p>dataframe</p>
</td></tr>
<tr><td><code id="set_type_groups_+3A_...">...</code></td>
<td>
<p>tidyselect. default selection is integerish doubles or integerish characters</p>
</td></tr>
<tr><td><code id="set_type_groups_+3A_setter">setter</code></td>
<td>
<p>which setter function to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
