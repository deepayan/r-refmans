<!DOCTYPE html><html><head><title>Help for package RaMS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RaMS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#[.msdata_connection'><p>S3 indexing for msdata_connection objects</p></a></li>
<li><a href='#$.msdata_connection'><p>S3 dollar sign notation for msdata_connection objects</p></a></li>
<li><a href='#checkOutputQuality'><p>Check that the output data is properly formatted.</p></a></li>
<li><a href='#editMSfileRTs'><p>Edit mzML/mzXML file retention times</p></a></li>
<li><a href='#getEncoded'><p>Convert from compressed binary to R numeric vector</p></a></li>
<li><a href='#giveEncoding'><p>Convert from R numeric vector to compressed binary</p></a></li>
<li><a href='#grabAccessionData'><p>Get arbitrary metadata from an mzML file by accession number</p></a></li>
<li><a href='#grabMSdata'><p>Grab mass-spectrometry data from file(s)</p></a></li>
<li><a href='#grabMzmlBPC'><p>Grab the BPC or TIC from a file</p></a></li>
<li><a href='#grabMzmlDAD'><p>Extract the DAD data from an mzML nodeset</p></a></li>
<li><a href='#grabMzmlData'><p>Get mass-spectrometry data from an mzML file</p></a></li>
<li><a href='#grabMzmlEncodingData'><p>Helper function to extract mzML file encoding data</p></a></li>
<li><a href='#grabMzmlMetadata'><p>Helper function to extract mzML file metadata</p></a></li>
<li><a href='#grabMzmlMS1'><p>Extract the MS1 data from an mzML nodeset</p></a></li>
<li><a href='#grabMzmlMS2'><p>Extract the MS2 data from an mzML nodeset</p></a></li>
<li><a href='#grabMzmlMS3'><p>Extract the MS3 data from an mzML nodeset</p></a></li>
<li><a href='#grabMzxmlBPC'><p>Grab the BPC or TIC from a file</p></a></li>
<li><a href='#grabMzxmlData'><p>Get mass-spectrometry data from an mzXML file</p></a></li>
<li><a href='#grabMzxmlEncodingData'><p>Helper function to extract mzXML file metadata</p></a></li>
<li><a href='#grabMzxmlMetadata'><p>Helper function to extract mzXML file metadata</p></a></li>
<li><a href='#grabMzxmlMS1'><p>Extract the MS1 data from an mzXML nodeset</p></a></li>
<li><a href='#grabMzxmlMS2'><p>Extract the MS2 data from an mzXML nodeset</p></a></li>
<li><a href='#grabMzxmlMS3'><p>Extract the MS3 data from an mzXML nodeset</p></a></li>
<li><a href='#grabMzxmlSpectraMzInt'><p>Extract the mass-to-charge data from the spectra of an mzXML nodeset</p></a></li>
<li><a href='#grabMzxmlSpectraPremz'><p>Extract the precursor mass from the spectra of an mzXML nodeset</p></a></li>
<li><a href='#grabMzxmlSpectraRt'><p>Extract the retention time from the spectra of an mzXML nodeset</p></a></li>
<li><a href='#grabMzxmlSpectraVoltage'><p>Extract the collison energies from the spectra of an mzXML nodeset</p></a></li>
<li><a href='#grabSpectraInt'><p>Extract the intensity information from the spectra of an mzML nodeset</p></a></li>
<li><a href='#grabSpectraMz'><p>Extract the mass-to-charge data from the spectra of an mzML nodeset</p></a></li>
<li><a href='#grabSpectraPremz'><p>Extract the precursor mass from the spectra of an mzML nodeset</p></a></li>
<li><a href='#grabSpectraRt'><p>Extract the retention time from the spectra of an mzML nodeset</p></a></li>
<li><a href='#grabSpectraVoltage'><p>Extract the collison energies from the spectra of an mzML nodeset</p></a></li>
<li><a href='#minifyMSdata'><p>Shrink MS data by including only data points near masses of interest</p></a></li>
<li><a href='#minifyMzml'><p>Shrink mzML files by including only data points near masses of interest</p></a></li>
<li><a href='#minifyMzxml'><p>Shrink mzxML files by including only data points near masses of interest</p></a></li>
<li><a href='#msdata_connection'><p>S3 constructor for msdata_connection</p></a></li>
<li><a href='#mz_group'><p>Group m/z values into bins of a specified ppm width</p></a></li>
<li><a href='#node2dt'><p>Convert node to data.table</p></a></li>
<li><a href='#pmppm'><p>Plus/minus parts per million</p></a></li>
<li><a href='#print.msdata_connection'><p>S3 print option for msdata_connection objects</p></a></li>
<li><a href='#qplotMS1data'><p>Quick plot for MS data</p></a></li>
<li><a href='#RaMS-package'><p>RaMS: R Access to Mass-Spec Data</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#tmzmlMaker'><p>Maker of tmzML documents</p></a></li>
<li><a href='#trapz'><p>Trapezoidal integration of mass-spec retention time / intensity values</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>R Access to Mass-Spec Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>William Kumler &lt;wkumler@uw.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>R-based access to mass-spectrometry (MS) data. While many packages 
  exist to process MS data, many of these make it difficult to 
  access the underlying mass-to-charge ratio (m/z), intensity, and 
  retention time of the files 
  themselves. This package is designed to format MS data in a tidy fashion and 
  allows the user perform the plotting and analysis.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/wkumler/RaMS">https://github.com/wkumler/RaMS</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/wkumler/RaMS/issues">https://github.com/wkumler/RaMS/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>xml2, base64enc, data.table, utils, stats</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, tidyverse, ggplot2, dplyr,
plotly, openxlsx, DBI, RSQLite, reticulate, BiocParallel,
Spectra, arrow, microbenchmark, rvest</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-02 21:11:48 UTC; willi</td>
</tr>
<tr>
<td>Author:</td>
<td>William Kumler [aut, cre, cph],
  Ricardo Cunha [ctb],
  Ethan Bass [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-02 22:22:34 UTC</td>
</tr>
</table>
<hr>
<h2 id='+5B.msdata_connection'>S3 indexing for msdata_connection objects</h2><span id='topic++5B.msdata_connection'></span>

<h3>Description</h3>

<p>This is the step that actually performs the file opening and extraction!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msdata_connection'
msdata_obj[sub_func]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.msdata_connection_+3A_msdata_obj">msdata_obj</code></td>
<td>
<p>An msdata_connection object containing files and grab_what</p>
</td></tr>
<tr><td><code id="+2B5B.msdata_connection_+3A_sub_func">sub_func</code></td>
<td>
<p>The function that will be parsed and used to subset the file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table with columns rt, mz, int, and filename
</p>

<hr>
<h2 id='+24.msdata_connection'>S3 dollar sign notation for msdata_connection objects</h2><span id='topic++24.msdata_connection'></span>

<h3>Description</h3>

<p>S3 dollar sign notation for msdata_connection objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msdata_connection'
msdata_obj$ms_level
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B24.msdata_connection_+3A_msdata_obj">msdata_obj</code></td>
<td>
<p>An msdata_connection object containing files and grab_what</p>
</td></tr>
<tr><td><code id="+2B24.msdata_connection_+3A_ms_level">ms_level</code></td>
<td>
<p>The requested MS level of the object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An msdata_connection object with only a single MS level
</p>

<hr>
<h2 id='checkOutputQuality'>Check that the output data is properly formatted.</h2><span id='topic+checkOutputQuality'></span>

<h3>Description</h3>

<p>This function checks that data produced by repeated calls to the
'grabMzmlData()' and 'grabMzxmlData()' functions is formatted properly before
it's provided to the user. It checks that all of the requested data has been
obtained and warns if data is found to be empty, misnamed, or has columns of
the wrong type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkOutputQuality(output_data, grab_what)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkOutputQuality_+3A_output_data">output_data</code></td>
<td>
<p>The collected data resulting from repeated calls to
'grabMzmlData()', after being bound together.</p>
</td></tr>
<tr><td><code id="checkOutputQuality_+3A_grab_what">grab_what</code></td>
<td>
<p>The names of the data requested by the user.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL (invisibly). The goal of this function is its side effects, i.e.
throwing errors and providing info when the files are not found.
</p>

<hr>
<h2 id='editMSfileRTs'>Edit mzML/mzXML file retention times</h2><span id='topic+editMSfileRTs'></span>

<h3>Description</h3>

<p>This function uses the basic XML parsing of RaMS to modify the retention
times of MS scans within the mzML/mzXML files. This method can be useful for
performing RT correction using one platform and then peakpicking and
correspondence on another. The basic method is simply replacing the scan's
recorded retention time value with an arbitrary one of your choosing. This
function is vectorized to handle multiple files, while the internal
'editMzmlRTs()' and 'editMzxmlRTs()' do most of the heavy lifting. Note that
the seconds vs minutes must be closely monitored here - the unit should be
the same as the one in the file originally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>editMSfileRTs(
  files,
  new_rt_list,
  new_filenames = NULL,
  interp_method = "linear",
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="editMSfileRTs_+3A_files">files</code></td>
<td>
<p>Vector of filenames (including the relative/absolute path)</p>
</td></tr>
<tr><td><code id="editMSfileRTs_+3A_new_rt_list">new_rt_list</code></td>
<td>
<p>Nested of new retention times. One entry in the list for
each file (in the same order as the files), each containing a vector of new
retention times. RT vectors can be equal to either every scan or just every
MS1 scan. If only the MS1 scans are provided in a file with additional MS
levels, MSn scan RTs will be interpolated according to interp_method (below)</p>
</td></tr>
<tr><td><code id="editMSfileRTs_+3A_new_filenames">new_filenames</code></td>
<td>
<p>Vector of filenames (including relative/absolute paths)
describing where the edited files should be written out. Can be the same
as files but will throw a warning and append _rtcor to each file unless
'overwrite = TRUE' (below)</p>
</td></tr>
<tr><td><code id="editMSfileRTs_+3A_interp_method">interp_method</code></td>
<td>
<p>Either &quot;linear&quot; or &quot;constant&quot;. Describes the way that
MSn retention times should be handled when only the MS1 values are provided.
&quot;linear&quot; (the default) means that the spacing will be preserved, while
&quot;constant&quot; will use the associated MS1 scan RT for all MSn scans, allowing
an easy method of linking the MSn to the MS1.</p>
</td></tr>
<tr><td><code id="editMSfileRTs_+3A_overwrite">overwrite</code></td>
<td>
<p>Boolean. Controls whether files are overwritten in place
if 'new_filenames' is not provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, the names of the edited files.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Setup (allows running on CRAN computers)
example_dir &lt;- tempdir()
rams_dir &lt;- system.file("extdata", package = "RaMS")
file.copy(list.files(rams_dir, pattern = "LB.*mzML", full.names = TRUE), example_dir)
mzMLs &lt;- list.files(example_dir, pattern = "LB.*mzML", full.names = TRUE)

library(xcms)
library(RaMS)

register(SerialParam())
xcms_obj &lt;- readMSData(mzMLs, msLevel. = 1, mode = "onDisk")
cwp &lt;- CentWaveParam(ppm = 5, peakwidth = c(20, 80))
xcms_peakpicked &lt;- findChromPeaks(xcms_obj, param = cwp)
xcms_rtcor &lt;- adjustRtime(xcms_peakpicked, param = ObiwarpParam())

# Extract the adjusted RTs from the XCMS object
new_rts &lt;- split(rtime(xcms_rtcor)/60, fromFile(xcms_rtcor))
# Apply the retention time correction to the new files
mzMLs_rtcor &lt;- editMSfileRTs(mzMLs, new_rt_list = new_rts)

# Contrast the two chromatograms to see the peaks aligned
qplotMS1data(grabMSdata(mzMLs)$MS1[mz%between%pmppm(104.1073, 10)])
qplotMS1data(grabMSdata(mzMLs_rtcor)$MS1[mz%between%pmppm(104.1073, 10)])

# Cleanup
file.remove(mzMLs)
file.remove(mzMLs_rtcor)

## End(Not run)
</code></pre>

<hr>
<h2 id='getEncoded'>Convert from compressed binary to R numeric vector</h2><span id='topic+getEncoded'></span>

<h3>Description</h3>

<p>Convert from compressed binary to R numeric vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEncoded(mzint_nodes, compression_type, bin_precision, endi_enc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getEncoded_+3A_mzint_nodes">mzint_nodes</code></td>
<td>
<p>The XML nodes containing the compressed binary string</p>
</td></tr>
<tr><td><code id="getEncoded_+3A_compression_type">compression_type</code></td>
<td>
<p>Compression type to be used by memDecompress</p>
</td></tr>
<tr><td><code id="getEncoded_+3A_bin_precision">bin_precision</code></td>
<td>
<p>The bit (?) precision used by readBin</p>
</td></tr>
<tr><td><code id="getEncoded_+3A_endi_enc">endi_enc</code></td>
<td>
<p>The byte order (?) of the string. For mzML this is always
&quot;little&quot; but mzXML can also be &quot;big&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of m/z or intensity values
</p>

<hr>
<h2 id='giveEncoding'>Convert from R numeric vector to compressed binary</h2><span id='topic+giveEncoding'></span>

<h3>Description</h3>

<p>Convert from R numeric vector to compressed binary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>giveEncoding(mzint_vals, compression_type, bin_precision, endi_enc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="giveEncoding_+3A_mzint_vals">mzint_vals</code></td>
<td>
<p>A numeric vector of m/z or intensity values</p>
</td></tr>
<tr><td><code id="giveEncoding_+3A_compression_type">compression_type</code></td>
<td>
<p>Compression type to be used by memCompress</p>
</td></tr>
<tr><td><code id="giveEncoding_+3A_bin_precision">bin_precision</code></td>
<td>
<p>The bit (?) precision used by writeBin</p>
</td></tr>
<tr><td><code id="giveEncoding_+3A_endi_enc">endi_enc</code></td>
<td>
<p>The byte order (?) of the string. For mzML this is always
&quot;little&quot; but mzXML can also be &quot;big&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single base64-encoded string of compressed binary values
</p>

<hr>
<h2 id='grabAccessionData'>Get arbitrary metadata from an mzML file by accession number</h2><span id='topic+grabAccessionData'></span>

<h3>Description</h3>

<p>Get arbitrary metadata from an mzML file by accession number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grabAccessionData(filename, accession_number)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grabAccessionData_+3A_filename">filename</code></td>
<td>
<p>The name of the file for which metadata is requested. Both
absolute and relative paths are acceptable.</p>
</td></tr>
<tr><td><code id="grabAccessionData_+3A_accession_number">accession_number</code></td>
<td>
<p>The HUPO-PSI accession number for the metadata to
be extracted. These accession numbers are typically of the form MS:#######
and the full list can be found and searched at
https://raw.githubusercontent.com/HUPO-PSI/psi-ms-CV/master/psi-ms.obo.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the name and value of the parameter requested,
as deduced from the XML tag attributes corresponding to the accession
number.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(RaMS)

sample_dir &lt;- system.file("extdata", package = "RaMS")
sample_file &lt;- list.files(sample_dir, full.names=TRUE)[3]
# Get highest observed m/z detected
topmass_df &lt;- grabAccessionData(sample_file, "MS:1000527")
# Manually create TIC
int_df &lt;- grabAccessionData(sample_file, "MS:1000285")
rt_df &lt;- grabAccessionData(sample_file, "MS:1000016")
tic &lt;- data.frame(rt=rt_df$value, int=int_df$value)
plot(tic$rt, tic$int, type = "l")
</code></pre>

<hr>
<h2 id='grabMSdata'>Grab mass-spectrometry data from file(s)</h2><span id='topic+grabMSdata'></span>

<h3>Description</h3>

<p>The main 'RaMS' function. This function accepts a list of the files that will
be read into R's working memory and returns a list of 'data.table's
containing the requested information. What information is requested is
determined by the 'grab_what' argument, which can include MS1, MS2, BPC, TIC,
or metadata information. This function serves as a wrapper around both
'grabMzmlData' and 'grabMzxmlData' and handles multiple files, but those two
have also been exposed to the user in case super-simple handling is desired.
Retention times are reported in minutes, and will be converted automatically
if they are encoded in seconds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grabMSdata(
  files,
  grab_what = "everything",
  verbosity = NULL,
  incl_polarity = FALSE,
  mz = NULL,
  ppm = NULL,
  rtrange = NULL,
  prefilter = -1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grabMSdata_+3A_files">files</code></td>
<td>
<p>A character vector of filenames to read into R's memory. Both
absolute and relative paths are acceptable.</p>
</td></tr>
<tr><td><code id="grabMSdata_+3A_grab_what">grab_what</code></td>
<td>
<p>What data should be read from the file? Options include
&quot;MS1&quot; for data only from the first spectrometer, &quot;MS2&quot; for fragmentation
data, &quot;BPC&quot; for rapid access to the base peak chromatogram, &quot;TIC&quot; for rapid
access to the total ion chromatogram, &quot;DAD&quot; for DAD (UV) data, and &quot;chroms&quot;
for precompiled chromatogram data (especially useful for MRM but often
contains BPC/TIC in other files). Metadata can be accessed with &quot;metadata&quot;,
which provides information about the instrument and time the file was run.
These options can be combined (i.e. 'grab_data=c(&quot;MS1&quot;, &quot;MS2&quot;, &quot;BPC&quot;)') or
this argument can be set to &quot;everything&quot; to extract all of the above.
Options &quot;EIC&quot; and &quot;EIC_MS2&quot; are useful when working with files whose total
size exceeds working memory - it first extracts all relevant MS1 and MS2
data, respectively, then discards data outside of the mass range(s)
calculated from the provided mz and ppm. The default, &quot;everything&quot;,
includes all MS1, MS2, BPC, TIC, and metadata.</p>
</td></tr>
<tr><td><code id="grabMSdata_+3A_verbosity">verbosity</code></td>
<td>
<p>Three levels of processing output to the R console are
available, with increasing verbosity corresponding to higher integers. A
verbosity of zero means that no output will be produced, useful when
wrapping within larger functions. A verbosity of 1 will produce a progress
bar using base R's txtProgressBar function. A verbosity of 2 or higher will
produce timing output for each individual file read in. The default, NULL,
will select between 1 and 2 depending on the number of files being read: if
a single file, verbosity is set to 2; if multiple files, verbosity is set
to 1.</p>
</td></tr>
<tr><td><code id="grabMSdata_+3A_incl_polarity">incl_polarity</code></td>
<td>
<p>Toggle this option to TRUE for mixed-polarity files. An
additional column will be added corresponding to the polarity of the scan,
with either a 1 or a -1 corresponding to positive and negative mode,
respectively.</p>
</td></tr>
<tr><td><code id="grabMSdata_+3A_mz">mz</code></td>
<td>
<p>A vector of the mass-to-charge ratio for compounds of interest.
Only used when combined with 'grab_what = &quot;EIC&quot;' (see above). Multiple
masses can be provided.</p>
</td></tr>
<tr><td><code id="grabMSdata_+3A_ppm">ppm</code></td>
<td>
<p>A single number corresponding to the mass accuracy (in parts per
million) of the instrument on which the data was collected. Only used when
combined with 'grab_what = &quot;EIC&quot;' (see above).</p>
</td></tr>
<tr><td><code id="grabMSdata_+3A_rtrange">rtrange</code></td>
<td>
<p>Only available when parsing mzML files. A vector of length 2
containing an upper and lower bound on retention times of interest.
Providing a range here can speed up load times (although not enormously, as
the entire file must still be read) and reduce the final object's size.</p>
</td></tr>
<tr><td><code id="grabMSdata_+3A_prefilter">prefilter</code></td>
<td>
<p>A single number corresponding to the minimum intensity of
interest in the MS1 data. Data points with intensities below this threshold
will be silently dropped, which can dramatically reduce the size of the
final object. Currently only works with MS1 data, but could be expanded
easily to handle more.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 'data.table's, each named after the arguments requested in
grab_what. E.g. $MS1 contains MS1 information, $MS2 contains fragmentation
info, etc. MS1 data has four columns: retention time (rt), mass-to-charge
(mz), intensity (int), and filename. MS2 data has six: retention time (rt),
precursor m/z (premz), fragment m/z (fragmz), fragment intensity (int),
collision energy (voltage), and filename. MS3 adds an additional column to
this (prepremz) corresponding to the initial MS1 m/z targeted. Data
requested that does not exist in the provided files (such as MS2 data
requested from MS1-only files) will return an empty (length zero)
data.table. The data.tables extracted from each of the individual files are
collected into one large table using data.table's 'rbindlist'. $metadata is
a little weirder because the metadata doesn't fit neatly into a tidy format
but things are hopefully named helpfully. $chroms was added in v1.3 and
contains 7 columns: chromatogram type (usually TIC, BPC or SRM info),
chromatogram index, target mz, product mz, retention time (rt), and
intensity (int). $DAD was also added in v1.3 and contains has three
columns: retention time (rt), wavelength (lambda),and intensity (int). Data
requested that does not exist in the provided files (such as MS2 data
requested from MS1-only files) will return an empty (zero-row) data.table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(RaMS)

# Extract MS1 data from a couple files
sample_dir &lt;- system.file("extdata", package = "RaMS")
sample_files &lt;- list.files(sample_dir, full.names=TRUE)
multifile_data &lt;- grabMSdata(sample_files[c(3,5,6)], grab_what="MS1")

</code></pre>

<hr>
<h2 id='grabMzmlBPC'>Grab the BPC or TIC from a file</h2><span id='topic+grabMzmlBPC'></span>

<h3>Description</h3>

<p>The base peak intensity and total ion current are actually written into the
mzML files and aren't encoded, making retrieval of BPC and TIC information
blazingly fast if parsed correctly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grabMzmlBPC(xml_data, rtrange, TIC = FALSE, incl_polarity)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grabMzmlBPC_+3A_xml_data">xml_data</code></td>
<td>
<p>An 'xml2' nodeset, usually created by applying 'read_xml' to
an mzML file.</p>
</td></tr>
<tr><td><code id="grabMzmlBPC_+3A_rtrange">rtrange</code></td>
<td>
<p>A vector of length 2 containing an upper and lower bound on
retention times of interest. Providing a range here can speed up load times
(although not enormously, as the entire file must still be read) and reduce
the final object's size.</p>
</td></tr>
<tr><td><code id="grabMzmlBPC_+3A_tic">TIC</code></td>
<td>
<p>Boolean. If TRUE, the TIC is extracted rather than the BPC.</p>
</td></tr>
<tr><td><code id="grabMzmlBPC_+3A_incl_polarity">incl_polarity</code></td>
<td>
<p>Boolean determining whether the polarity of the scan
should be returned as a column in the table (positive mode = 1, negative
mode = -1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'data.table' with columns for retention time (rt), and intensity
(int).
</p>

<hr>
<h2 id='grabMzmlDAD'>Extract the DAD data from an mzML nodeset</h2><span id='topic+grabMzmlDAD'></span>

<h3>Description</h3>

<p>Extract the DAD data from an mzML nodeset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grabMzmlDAD(xml_data, rtrange, file_metadata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grabMzmlDAD_+3A_xml_data">xml_data</code></td>
<td>
<p>An 'xml2' nodeset, usually created by applying 'read_xml' to
an mzML file.</p>
</td></tr>
<tr><td><code id="grabMzmlDAD_+3A_rtrange">rtrange</code></td>
<td>
<p>A vector of length 2 containing an upper and lower bound on
retention times of interest. Providing a range here can speed up load times
(although not enormously, as the entire file must still be read) and reduce
the final object's size.</p>
</td></tr>
<tr><td><code id="grabMzmlDAD_+3A_file_metadata">file_metadata</code></td>
<td>
<p>Information about the file used to decode the binary
arrays containing m/z and intensity information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'data.table' with columns for retention time (rt), wavelength
(lambda), and intensity (int).
</p>

<hr>
<h2 id='grabMzmlData'>Get mass-spectrometry data from an mzML file</h2><span id='topic+grabMzmlData'></span>

<h3>Description</h3>

<p>This function handles the mzML side of things, reading in files that are
written in the mzML format. Much of the code is similar to the mzXML format,
but the xpath handles are different and the mz/int array is encoded as two
separate entries rather than simultaneously. This function has been exposed
to the user in case per-file optimization (such as peakpicking or additional
filtering) is desired before the full data object is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grabMzmlData(
  filename,
  grab_what,
  verbosity = 0,
  incl_polarity = FALSE,
  mz = NULL,
  ppm = NULL,
  rtrange = NULL,
  prefilter = -1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grabMzmlData_+3A_filename">filename</code></td>
<td>
<p>A single filename to read into R's memory. Both absolute and
relative paths are acceptable.</p>
</td></tr>
<tr><td><code id="grabMzmlData_+3A_grab_what">grab_what</code></td>
<td>
<p>What data should be read from the file? Options include
&quot;MS1&quot; for data only from the first spectrometer, &quot;MS2&quot; and &quot;MS3&quot; for
fragmentation data, &quot;BPC&quot; for rapid access to the base peak chromatogram,
&quot;TIC&quot; for rapid access to the total ion chromatogram, &quot;DAD&quot; for DAD (UV)
data, and &quot;chroms&quot; for precompiled chromatogram data (especially useful for
MRM but often contains BPC/TIC in other files). Metadata can be accessed
with &quot;metadata&quot;, which provides information about the instrument and time
the file was run. These options can be combined (i.e. 'grab_data=c(&quot;MS1&quot;,
&quot;MS2&quot;, &quot;BPC&quot;)') or this argument can be set to &quot;everything&quot; to extract all
of the above. Options &quot;EIC&quot;, &quot;EIC_MS2&quot;, and &quot;EIC_MS3&quot; are useful when
working with files whose total size exceeds working memory - it first
extracts all relevant MS1/2/3 data, respectively, then discards data
outside of the mass range(s) calculated from the provided mz and ppm. The
default, &quot;everything&quot;, includes all MS1, MS2, BPC, TIC, and metadata.</p>
</td></tr>
<tr><td><code id="grabMzmlData_+3A_verbosity">verbosity</code></td>
<td>
<p>Three levels of processing output to the R console are
available, with increasing verbosity corresponding to higher integers. A
verbosity of zero means that no output will be produced, useful when
wrapping within larger functions. A verbosity of 1 will produce a progress
bar using base R's txtProgressBar function. A verbosity of 2 or higher will
produce timing output for each individual file read in.</p>
</td></tr>
<tr><td><code id="grabMzmlData_+3A_incl_polarity">incl_polarity</code></td>
<td>
<p>Toggle this option to TRUE for mixed-polarity files. An
additional column will be added corresponding to the polarity of the scan,
with either a 1 or a -1 corresponding to positive and negative mode,
respectively.</p>
</td></tr>
<tr><td><code id="grabMzmlData_+3A_mz">mz</code></td>
<td>
<p>A vector of the mass-to-charge ratio for compounds of interest.
Only used when combined with 'grab_what = &quot;EIC&quot;' (see above). Multiple
masses can be provided.</p>
</td></tr>
<tr><td><code id="grabMzmlData_+3A_ppm">ppm</code></td>
<td>
<p>A single number corresponding to the mass accuracy (in parts per
million) of the instrument on which the data was collected. Only used when
combined with 'grab_what = &quot;EIC&quot;' (see above).</p>
</td></tr>
<tr><td><code id="grabMzmlData_+3A_rtrange">rtrange</code></td>
<td>
<p>A vector of length 2 containing an upper and lower bound on
retention times of interest. Providing a range here can speed up load times
(although not enormously, as the entire file must still be read) and reduce
the final object's size.</p>
</td></tr>
<tr><td><code id="grabMzmlData_+3A_prefilter">prefilter</code></td>
<td>
<p>A single number corresponding to the minimum intensity of
interest in the MS1 data. Data points with intensities below this threshold
will be silently dropped, which can dramatically reduce the size of the
final object. Currently only works with MS1 data, but could be expanded
easily to handle more.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 'data.table's, each named after the arguments requested in
grab_what. E.g. $MS1 contains MS1 information, $MS2 contains fragmentation
info, etc. MS1 data has four columns: retention time (rt), mass-to-charge
(mz), intensity (int), and filename. MS2 data has six: retention time (rt),
precursor m/z (premz), fragment m/z (fragmz), fragment intensity (int),
collision energy (voltage), and filename. MS3 has an additional column to
MS2 (prepremz) which has the original MS1 scan's m/z ratio. Data requested
that does not exist in the provided files (such as MS2 data requested from
MS1-only files) will return an empty (length zero) data.table. The
data.tables extracted from each of the individual files are collected into
one large table using data.table's 'rbindlist'. $metadata is a little
weirder because the metadata doesn't fit neatly into a tidy format but
things are hopefully named helpfully. $chroms was added in v1.3 and
contains 7 columns: chromatogram type (usually TIC, BPC or SRM info),
chromatogram index, target mz, product mz, retention time (rt), and
intensity (int). $DAD was also added in v1.3 and contains has three
columns: retention time (rt), wavelength (lambda),and intensity (int).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sample_file &lt;- system.file("extdata", "LB12HL_AB.mzML.gz", package = "RaMS")
file_data &lt;- grabMzmlData(sample_file, grab_what="MS1")
## Not run: 
# Extract MS1 data and a base peak chromatogram
file_data &lt;- grabMzmlData(sample_file, grab_what=c("MS1", "BPC"))
# Extract data from a retention time subset
file_data &lt;- grabMzmlData(sample_file, grab_what=c("MS1", "BPC"),
                          rtrange=c(5, 7))
# Extract EIC for a specific mass
file_data &lt;- grabMzmlData(sample_file, grab_what="EIC", mz=118.0865, ppm=5)
# Extract EIC for several masses simultaneously
file_data &lt;- grabMzmlData(sample_file, grab_what="EIC", ppm=5,
                          mz=c(118.0865, 146.118104, 189.123918))

# Extract MS2 data
sample_file &lt;- system.file("extdata", "S30657.mzML.gz", package = "RaMS")
MS2_data &lt;- grabMzmlData(sample_file, grab_what="MS2")

## End(Not run)
</code></pre>

<hr>
<h2 id='grabMzmlEncodingData'>Helper function to extract mzML file encoding data</h2><span id='topic+grabMzmlEncodingData'></span>

<h3>Description</h3>

<p>Helper function to extract mzML file encoding data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grabMzmlEncodingData(xml_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grabMzmlEncodingData_+3A_xml_data">xml_data</code></td>
<td>
<p>mzML data as parsed by xml2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of values used by other parsing functions, currently
compression, mz_precision, int_precision
</p>

<hr>
<h2 id='grabMzmlMetadata'>Helper function to extract mzML file metadata</h2><span id='topic+grabMzmlMetadata'></span>

<h3>Description</h3>

<p>Helper function to extract mzML file metadata
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grabMzmlMetadata(xml_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grabMzmlMetadata_+3A_xml_data">xml_data</code></td>
<td>
<p>mzML data as parsed by xml2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of values corresponding to various pieces of metadata
for each file
</p>

<hr>
<h2 id='grabMzmlMS1'>Extract the MS1 data from an mzML nodeset</h2><span id='topic+grabMzmlMS1'></span>

<h3>Description</h3>

<p>Extract the MS1 data from an mzML nodeset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grabMzmlMS1(xml_data, rtrange, file_metadata, prefilter, incl_polarity)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grabMzmlMS1_+3A_xml_data">xml_data</code></td>
<td>
<p>An 'xml2' nodeset, usually created by applying 'read_xml' to
an mzML file.</p>
</td></tr>
<tr><td><code id="grabMzmlMS1_+3A_rtrange">rtrange</code></td>
<td>
<p>A vector of length 2 containing an upper and lower bound on
retention times of interest. Providing a range here can speed up load times
(although not enormously, as the entire file must still be read) and reduce
the final object's size.</p>
</td></tr>
<tr><td><code id="grabMzmlMS1_+3A_file_metadata">file_metadata</code></td>
<td>
<p>Information about the file used to decode the binary
arrays containing m/z and intensity information.</p>
</td></tr>
<tr><td><code id="grabMzmlMS1_+3A_prefilter">prefilter</code></td>
<td>
<p>The lowest intensity value of interest, used to reduce file
size (and especially useful for profile mode data with many 0 values)</p>
</td></tr>
<tr><td><code id="grabMzmlMS1_+3A_incl_polarity">incl_polarity</code></td>
<td>
<p>Boolean determining whether the polarity of the scan
should be returned as a column in the table (positive mode = 1, negative
mode = -1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'data.table' with columns for retention time (rt), m/z (mz), and
intensity (int).
</p>

<hr>
<h2 id='grabMzmlMS2'>Extract the MS2 data from an mzML nodeset</h2><span id='topic+grabMzmlMS2'></span>

<h3>Description</h3>

<p>Extract the MS2 data from an mzML nodeset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grabMzmlMS2(xml_data, rtrange, file_metadata, incl_polarity)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grabMzmlMS2_+3A_xml_data">xml_data</code></td>
<td>
<p>An 'xml2' nodeset, usually created by applying 'read_xml' to
an mzML file.</p>
</td></tr>
<tr><td><code id="grabMzmlMS2_+3A_rtrange">rtrange</code></td>
<td>
<p>A vector of length 2 containing an upper and lower bound on
retention times of interest. Providing a range here can speed up load times
(although not enormously, as the entire file must still be read) and reduce
the final object's size.</p>
</td></tr>
<tr><td><code id="grabMzmlMS2_+3A_file_metadata">file_metadata</code></td>
<td>
<p>Information about the file used to decode the binary
arrays containing m/z and intensity information.</p>
</td></tr>
<tr><td><code id="grabMzmlMS2_+3A_incl_polarity">incl_polarity</code></td>
<td>
<p>Boolean determining whether the polarity of the scan
should be returned as a column in the table (positive mode = 1, negative
mode = -1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'data.table' with columns for retention time (rt),  precursor m/z
(premz), fragment m/z (fragmz), collision energy (voltage), and intensity
(int).
</p>

<hr>
<h2 id='grabMzmlMS3'>Extract the MS3 data from an mzML nodeset</h2><span id='topic+grabMzmlMS3'></span>

<h3>Description</h3>

<p>Extract the MS3 data from an mzML nodeset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grabMzmlMS3(xml_data, rtrange, file_metadata, incl_polarity)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grabMzmlMS3_+3A_xml_data">xml_data</code></td>
<td>
<p>An 'xml2' nodeset, usually created by applying 'read_xml' to
an mzML file.</p>
</td></tr>
<tr><td><code id="grabMzmlMS3_+3A_rtrange">rtrange</code></td>
<td>
<p>A vector of length 2 containing an upper and lower bound on
retention times of interest. Providing a range here can speed up load times
(although not enormously, as the entire file must still be read) and reduce
the final object's size.</p>
</td></tr>
<tr><td><code id="grabMzmlMS3_+3A_file_metadata">file_metadata</code></td>
<td>
<p>Information about the file used to decode the binary
arrays containing m/z and intensity information.</p>
</td></tr>
<tr><td><code id="grabMzmlMS3_+3A_incl_polarity">incl_polarity</code></td>
<td>
<p>Boolean determining whether the polarity of the scan
should be returned as a column in the table (positive mode = 1, negative
mode = -1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'data.table' with columns for retention time (rt),
MS1 precursor m/z (prepremz), MS2 precursor m/z (premz),
fragment m/z (fragmz), collision energy (voltage), and intensity (int).
</p>

<hr>
<h2 id='grabMzxmlBPC'>Grab the BPC or TIC from a file</h2><span id='topic+grabMzxmlBPC'></span>

<h3>Description</h3>

<p>The base peak intensity and total ion current are actually written into the
mzXML files and aren't encoded, making retrieval of BPC and TIC information
blazingly fast if parsed correctly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grabMzxmlBPC(xml_data, TIC = FALSE, rtrange, incl_polarity)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grabMzxmlBPC_+3A_xml_data">xml_data</code></td>
<td>
<p>An 'xml2' nodeset, usually created by applying 'read_xml' to
an mzML file.</p>
</td></tr>
<tr><td><code id="grabMzxmlBPC_+3A_tic">TIC</code></td>
<td>
<p>Boolean. If TRUE, the TIC is extracted rather than the BPC.</p>
</td></tr>
<tr><td><code id="grabMzxmlBPC_+3A_rtrange">rtrange</code></td>
<td>
<p>A vector of length 2 containing an upper and lower bound on
retention times of interest. Providing a range here can speed up load times
(although not enormously, as the entire file must still be read) and reduce
the final object's size.</p>
</td></tr>
<tr><td><code id="grabMzxmlBPC_+3A_incl_polarity">incl_polarity</code></td>
<td>
<p>Boolean determining whether the polarity of the scan
should be returned as a column in the table (positive mode = 1, negative
mode = -1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'data.table' with columns for retention time (rt), and intensity (int).
</p>

<hr>
<h2 id='grabMzxmlData'>Get mass-spectrometry data from an mzXML file</h2><span id='topic+grabMzxmlData'></span>

<h3>Description</h3>

<p>This function handles the mzXML side of things, reading in files that are
written in the mzXML format. Much of the code is similar to the mzXML format,
but the xpath handles are different and the mz/int array is encoded
simultaneously rather than as two separate entries. This function has been
exposed to the user in case per-file optimization (such as peakpicking or
additional filtering) is desired before the full data object is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grabMzxmlData(
  filename,
  grab_what,
  verbosity = 0,
  incl_polarity = FALSE,
  rtrange = NULL,
  mz = NULL,
  ppm = NULL,
  prefilter = -1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grabMzxmlData_+3A_filename">filename</code></td>
<td>
<p>A single filename to read into R's memory. Both absolute and
relative paths are acceptable.</p>
</td></tr>
<tr><td><code id="grabMzxmlData_+3A_grab_what">grab_what</code></td>
<td>
<p>What data should be read from the file? Options include
&quot;MS1&quot; for data only from the first spectrometer, &quot;MS2&quot; for fragmentation
data, &quot;BPC&quot; for rapid access to the base peak chromatogram, and &quot;TIC&quot; for
rapid access to the total ion chromatogram. DAD and chromatogram (&quot;DAD&quot; and
&quot;chroms&quot;) are unavailable for mzXML files. Metadata can be accessed with
&quot;metadata&quot;, which provides information about the instrument and time the
file was run. These options can be combined (i.e. 'grab_data=c(&quot;MS1&quot;,
&quot;MS2&quot;, &quot;BPC&quot;)') or this argument can be set to &quot;everything&quot; to extract all
of the above. Options &quot;EIC&quot; and &quot;EIC_MS2&quot; are useful when working with
files whose total size exceeds working memory - it first extracts all
relevant MS1 and MS2 data, respectively, then discards data outside of the
mass range(s) calculated from the provided mz and ppm. The default,
&quot;everything&quot;, includes all MS1, MS2, BPC, TIC, and metadata.</p>
</td></tr>
<tr><td><code id="grabMzxmlData_+3A_verbosity">verbosity</code></td>
<td>
<p>Three levels of processing output to the R console are
available, with increasing verbosity corresponding to higher integers. A
verbosity of zero means that no output will be produced, useful when
wrapping within larger functions. A verbosity of 1 will produce a progress
bar using base R's txtProgressBar function. A verbosity of 2 or higher will
produce timing output for each individual file read in.</p>
</td></tr>
<tr><td><code id="grabMzxmlData_+3A_incl_polarity">incl_polarity</code></td>
<td>
<p>Toggle this option to TRUE for mixed-polarity files. An
additional column will be added corresponding to the polarity of the scan,
with either a 1 or a -1 corresponding to positive and negative mode,
respectively.</p>
</td></tr>
<tr><td><code id="grabMzxmlData_+3A_rtrange">rtrange</code></td>
<td>
<p>Not supported for mzXML data. Only provided here so as to
throw a friendly warning rather than an unexpected error.</p>
</td></tr>
<tr><td><code id="grabMzxmlData_+3A_mz">mz</code></td>
<td>
<p>A vector of the mass-to-charge ratio for compounds of interest.
Only used when combined with 'grab_what = &quot;EIC&quot;' (see above). Multiple
masses can be provided.</p>
</td></tr>
<tr><td><code id="grabMzxmlData_+3A_ppm">ppm</code></td>
<td>
<p>A single number corresponding to the mass accuracy (in parts per
million) of the instrument on which the data was collected. Only used when
combined with 'grab_what = &quot;EIC&quot;' (see above).</p>
</td></tr>
<tr><td><code id="grabMzxmlData_+3A_prefilter">prefilter</code></td>
<td>
<p>A single number corresponding to the minimum intensity of
interest in the MS1 data. Data points with intensities below this threshold
will be silently dropped, which can dramatically reduce the size of the
final object. Currently only works with MS1 data, but could be expanded
easily to handle more.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 'data.table's, each named after the arguments requested in
grab_what. E.g. $MS1 contains MS1 information, $MS2 contains fragmentation
info, etc. MS1 data has four columns: retention time (rt), mass-to-charge
(mz), intensity (int), and filename. MS2 data has six: retention time (rt),
precursor m/z (premz), fragment m/z (fragmz), fragment intensity (int),
collision energy (voltage), and filename. MS3 has an additional column to
MS2 (prepremz) which has the original MS1 scan's m/z ratio. Data requested
that does not exist in the provided files (such as MS2 data requested from
MS1-only files) will return an empty (length zero) data.table. The
data.tables extracted from each of the individual files are collected into
one large table using data.table's 'rbindlist'. $metadata is a little
weirder because the metadata doesn't fit neatly into a tidy format but
things are hopefully named helpfully.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sample_file &lt;- system.file("extdata", "LB12HL_AB.mzXML.gz", package = "RaMS")
file_data &lt;- grabMzxmlData(sample_file, grab_what="MS1")
## Not run: 
# Extract MS1 data and a base peak chromatogram
file_data &lt;- grabMzxmlData(sample_file, grab_what=c("MS1", "BPC"))
# Extract EIC for a specific mass
file_data &lt;- grabMzxmlData(sample_file, grab_what="EIC", mz=118.0865, ppm=5)
# Extract EIC for several masses simultaneously
file_data &lt;- grabMzxmlData(sample_file, grab_what="EIC", ppm=5,
                           mz=c(118.0865, 146.118104, 189.123918))

# Extract MS2 data
sample_file &lt;- system.file("extdata", "S30657.mzXML.gz", package = "RaMS")
MS2_data &lt;- grabMzxmlData(sample_file, grab_what="MS2")

## End(Not run)

</code></pre>

<hr>
<h2 id='grabMzxmlEncodingData'>Helper function to extract mzXML file metadata</h2><span id='topic+grabMzxmlEncodingData'></span>

<h3>Description</h3>

<p>Helper function to extract mzXML file metadata
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grabMzxmlEncodingData(xml_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grabMzxmlEncodingData_+3A_xml_data">xml_data</code></td>
<td>
<p>mzXML data as parsed by xml2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of values used by other parsing functions, currently
compression, precision, and endian encoding (endi_enc)
</p>

<hr>
<h2 id='grabMzxmlMetadata'>Helper function to extract mzXML file metadata</h2><span id='topic+grabMzxmlMetadata'></span>

<h3>Description</h3>

<p>Helper function to extract mzXML file metadata
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grabMzxmlMetadata(xml_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grabMzxmlMetadata_+3A_xml_data">xml_data</code></td>
<td>
<p>mzXML data as parsed by xml2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of values corresponding to various pieces of metadata
for each file
</p>

<hr>
<h2 id='grabMzxmlMS1'>Extract the MS1 data from an mzXML nodeset</h2><span id='topic+grabMzxmlMS1'></span>

<h3>Description</h3>

<p>Extract the MS1 data from an mzXML nodeset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grabMzxmlMS1(xml_data, file_metadata, rtrange, prefilter, incl_polarity)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grabMzxmlMS1_+3A_xml_data">xml_data</code></td>
<td>
<p>An 'xml2' nodeset, usually created by applying 'read_xml' to
an mzXML file.</p>
</td></tr>
<tr><td><code id="grabMzxmlMS1_+3A_file_metadata">file_metadata</code></td>
<td>
<p>Information about the file used to decode the binary
arrays containing m/z and intensity information.</p>
</td></tr>
<tr><td><code id="grabMzxmlMS1_+3A_rtrange">rtrange</code></td>
<td>
<p>A vector of length 2 containing an upper and lower bound on
retention times of interest. Providing a range here can speed up load times
(although not enormously, as the entire file must still be read) and reduce
the final object's size.</p>
</td></tr>
<tr><td><code id="grabMzxmlMS1_+3A_prefilter">prefilter</code></td>
<td>
<p>The lowest intensity value of interest, used to reduce file
size (and especially useful for profile mode data with many 0 values)</p>
</td></tr>
<tr><td><code id="grabMzxmlMS1_+3A_incl_polarity">incl_polarity</code></td>
<td>
<p>Boolean determining whether the polarity of the scan
should be returned as a column in the table (positive mode = 1, negative
mode = -1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'data.table' with columns for retention time (rt), m/z (mz),
and intensity (int).
</p>

<hr>
<h2 id='grabMzxmlMS2'>Extract the MS2 data from an mzXML nodeset</h2><span id='topic+grabMzxmlMS2'></span>

<h3>Description</h3>

<p>Extract the MS2 data from an mzXML nodeset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grabMzxmlMS2(xml_data, file_metadata, rtrange, incl_polarity)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grabMzxmlMS2_+3A_xml_data">xml_data</code></td>
<td>
<p>An 'xml2' nodeset, usually created by applying 'read_xml' to
an mzXML file.</p>
</td></tr>
<tr><td><code id="grabMzxmlMS2_+3A_file_metadata">file_metadata</code></td>
<td>
<p>Information about the file used to decode the binary
arrays containing m/z and intensity information.</p>
</td></tr>
<tr><td><code id="grabMzxmlMS2_+3A_rtrange">rtrange</code></td>
<td>
<p>A vector of length 2 containing an upper and lower bound on
retention times of interest. Providing a range here can speed up load times
(although not enormously, as the entire file must still be read) and reduce
the final object's size.</p>
</td></tr>
<tr><td><code id="grabMzxmlMS2_+3A_incl_polarity">incl_polarity</code></td>
<td>
<p>Boolean determining whether the polarity of the scan
should be returned as a column in the table (positive mode = 1, negative
mode = -1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'data.table' with columns for retention time (rt),  precursor m/z (premz),
fragment m/z (fragmz), collision energy (voltage), and intensity (int).
</p>

<hr>
<h2 id='grabMzxmlMS3'>Extract the MS3 data from an mzXML nodeset</h2><span id='topic+grabMzxmlMS3'></span>

<h3>Description</h3>

<p>Extract the MS3 data from an mzXML nodeset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grabMzxmlMS3(xml_data, file_metadata, rtrange, incl_polarity)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grabMzxmlMS3_+3A_xml_data">xml_data</code></td>
<td>
<p>An 'xml2' nodeset, usually created by applying 'read_xml' to
an mzXML file.</p>
</td></tr>
<tr><td><code id="grabMzxmlMS3_+3A_file_metadata">file_metadata</code></td>
<td>
<p>Information about the file used to decode the binary
arrays containing m/z and intensity information.</p>
</td></tr>
<tr><td><code id="grabMzxmlMS3_+3A_rtrange">rtrange</code></td>
<td>
<p>A vector of length 2 containing an upper and lower bound on
retention times of interest. Providing a range here can speed up load times
(although not enormously, as the entire file must still be read) and reduce
the final object's size.</p>
</td></tr>
<tr><td><code id="grabMzxmlMS3_+3A_incl_polarity">incl_polarity</code></td>
<td>
<p>Boolean determining whether the polarity of the scan
should be returned as a column in the table (positive mode = 1, negative
mode = -1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'data.table' with columns for retention time (rt),
MS1 precursor m/z (prepremz), MS2 precursor m/z (premz),
fragment m/z (fragmz), collision energy (voltage), and intensity (int).
</p>

<hr>
<h2 id='grabMzxmlSpectraMzInt'>Extract the mass-to-charge data from the spectra of an mzXML nodeset</h2><span id='topic+grabMzxmlSpectraMzInt'></span>

<h3>Description</h3>

<p>The mz and intensity information of mzXML files are encoded as a binary
array, sometimes compressed via gzip or zlib or numpress. This code finds all
the m/z-int binary arrays and converts them back to the original
measurements. See https://github.com/ProteoWizard/pwiz/issues/1301
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grabMzxmlSpectraMzInt(xml_nodes, file_metadata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grabMzxmlSpectraMzInt_+3A_xml_nodes">xml_nodes</code></td>
<td>
<p>An xml_nodeset object corresponding to the spectra collected
by the mass spectrometer, usually produced by applying 'xml_find_all' to an
MS1 or MS2 nodeset.</p>
</td></tr>
<tr><td><code id="grabMzxmlSpectraMzInt_+3A_file_metadata">file_metadata</code></td>
<td>
<p>Information about the file used to decode the binary
arrays containing m/z and intensity information. Here, the compression and
mz precision information is relevant.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of masses, many for each scan.
</p>

<hr>
<h2 id='grabMzxmlSpectraPremz'>Extract the precursor mass from the spectra of an mzXML nodeset</h2><span id='topic+grabMzxmlSpectraPremz'></span>

<h3>Description</h3>

<p>Extract the precursor mass from the spectra of an mzXML nodeset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grabMzxmlSpectraPremz(xml_nodes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grabMzxmlSpectraPremz_+3A_xml_nodes">xml_nodes</code></td>
<td>
<p>An xml_nodeset object corresponding to the spectra collected
by the mass spectrometer, usually produced by applying 'xml_find_all' to an
MS1 or MS2 nodeset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of precursor masses, one for each scan
</p>

<hr>
<h2 id='grabMzxmlSpectraRt'>Extract the retention time from the spectra of an mzXML nodeset</h2><span id='topic+grabMzxmlSpectraRt'></span>

<h3>Description</h3>

<p>Extract the retention time from the spectra of an mzXML nodeset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grabMzxmlSpectraRt(xml_nodes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grabMzxmlSpectraRt_+3A_xml_nodes">xml_nodes</code></td>
<td>
<p>An xml_nodeset object corresponding to the spectra collected
by the mass spectrometer, usually produced by applying 'xml_find_all' to an
MS1 or MS2 nodeset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of retention times, one for each scan
</p>

<hr>
<h2 id='grabMzxmlSpectraVoltage'>Extract the collison energies from the spectra of an mzXML nodeset</h2><span id='topic+grabMzxmlSpectraVoltage'></span>

<h3>Description</h3>

<p>Although the collision energy is typically fixed per file, it's equally
fast (afaik) to just grab them all individually here. Also, I'm worried about
these rumors of &quot;ramped&quot; collision energies
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grabMzxmlSpectraVoltage(xml_nodes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grabMzxmlSpectraVoltage_+3A_xml_nodes">xml_nodes</code></td>
<td>
<p>An xml_nodeset object corresponding to the spectra collected
by the mass spectrometer, usually produced by applying 'xml_find_all' to an
MS1 or MS2 nodeset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of collision energies, one for each scan.
</p>

<hr>
<h2 id='grabSpectraInt'>Extract the intensity information from the spectra of an mzML nodeset</h2><span id='topic+grabSpectraInt'></span>

<h3>Description</h3>

<p>The mz and intensity information of mzML files are encoded as binary arrays,
sometimes compressed via gzip or zlib or numpress. This code finds all the
intensity binary arrays and converts them back to the original measurements.
See https://github.com/ProteoWizard/pwiz/issues/1301
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grabSpectraInt(xml_nodes, file_metadata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grabSpectraInt_+3A_xml_nodes">xml_nodes</code></td>
<td>
<p>An xml_nodeset object corresponding to the spectra collected
by the mass spectrometer, usually produced by applying 'xml_find_all' to an
MS1 or MS2 nodeset.</p>
</td></tr>
<tr><td><code id="grabSpectraInt_+3A_file_metadata">file_metadata</code></td>
<td>
<p>Information about the file used to decode the binary
arrays containing m/z and intensity information. Here, the compression and
int precision information is relevant.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of intensities, many for each scan.
</p>

<hr>
<h2 id='grabSpectraMz'>Extract the mass-to-charge data from the spectra of an mzML nodeset</h2><span id='topic+grabSpectraMz'></span>

<h3>Description</h3>

<p>The mz and intensity information of mzML files are encoded as binary arrays,
sometimes compressed via gzip or zlib or numpress. This code finds all the
m/z binary arrays and converts them back to the original measurements. See
https://github.com/ProteoWizard/pwiz/issues/1301
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grabSpectraMz(xml_nodes, file_metadata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grabSpectraMz_+3A_xml_nodes">xml_nodes</code></td>
<td>
<p>An xml_nodeset object corresponding to the spectra collected
by the mass spectrometer, usually produced by applying 'xml_find_all' to an
MS1 or MS2 nodeset.</p>
</td></tr>
<tr><td><code id="grabSpectraMz_+3A_file_metadata">file_metadata</code></td>
<td>
<p>Information about the file used to decode the binary
arrays containing m/z and intensity information. Here, the compression and
mz precision information is relevant.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of masses, many for each scan.
</p>

<hr>
<h2 id='grabSpectraPremz'>Extract the precursor mass from the spectra of an mzML nodeset</h2><span id='topic+grabSpectraPremz'></span>

<h3>Description</h3>

<p>Extract the precursor mass from the spectra of an mzML nodeset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grabSpectraPremz(xml_nodes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grabSpectraPremz_+3A_xml_nodes">xml_nodes</code></td>
<td>
<p>An xml_nodeset object corresponding to the spectra collected
by the mass spectrometer, usually produced by applying 'xml_find_all' to an
MS1 or MS2 nodeset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of precursor masses, one for each scan
</p>

<hr>
<h2 id='grabSpectraRt'>Extract the retention time from the spectra of an mzML nodeset</h2><span id='topic+grabSpectraRt'></span>

<h3>Description</h3>

<p>Extract the retention time from the spectra of an mzML nodeset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grabSpectraRt(xml_nodes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grabSpectraRt_+3A_xml_nodes">xml_nodes</code></td>
<td>
<p>An xml_nodeset object corresponding to the spectra collected
by the mass spectrometer, usually produced by applying 'xml_find_all' to an
MS1 or MS2 nodeset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of retention times, one for each scan
</p>

<hr>
<h2 id='grabSpectraVoltage'>Extract the collison energies from the spectra of an mzML nodeset</h2><span id='topic+grabSpectraVoltage'></span>

<h3>Description</h3>

<p>Although the collision energy is typically fixed per file, it's equally fast
(afaik) to just grab them all individually here. Also, I'm worried about
these rumors of &quot;ramped&quot; collision energies
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grabSpectraVoltage(xml_nodes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grabSpectraVoltage_+3A_xml_nodes">xml_nodes</code></td>
<td>
<p>An xml_nodeset object corresponding to the spectra collected
by the mass spectrometer, usually produced by applying 'xml_find_all' to an
MS1 or MS2 nodeset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of collision energies, one for each scan.
</p>

<hr>
<h2 id='minifyMSdata'>Shrink MS data by including only data points near masses of interest</h2><span id='topic+minifyMSdata'></span>

<h3>Description</h3>

<p>MS files can be annoyingly large if only a few masses are of interest. This large size makes it
difficult to share them online for debugging purposes and often means that untargeted algorithms
spend a lot of time picking peaks in data that's irrelevant. minifyMSdata is a function designed to
&quot;minify&quot; MS files by extracting only those data points that are within the ppm error of an m/z value
of interest, and returns the file essentially otherwise unchanged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minifyMSdata(
  files,
  output_files = NULL,
  mz_exclude = NULL,
  mz_include = NULL,
  ppm = NULL,
  warn = TRUE,
  prefilter = -1,
  verbosity = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minifyMSdata_+3A_files">files</code></td>
<td>
<p>The name of a single file to be minified, usually produced by Proteowizard's 'msconvert'
or something similar.</p>
</td></tr>
<tr><td><code id="minifyMSdata_+3A_output_files">output_files</code></td>
<td>
<p>The name of the file to be written out.</p>
</td></tr>
<tr><td><code id="minifyMSdata_+3A_mz_exclude">mz_exclude</code></td>
<td>
<p>A vector of m/z values that should be excluded from the minified file. This argument
must be used with the 'ppm' argument and should not be used with mz_include. For each mass provided, an
m/z window of +/- 'ppm' is calculated, and all data points within that window are removed.</p>
</td></tr>
<tr><td><code id="minifyMSdata_+3A_mz_include">mz_include</code></td>
<td>
<p>A vector of m/z values that should be included in the minified file. This argument
must be used with the 'ppm' argument and should not be used with mz_exclude. For each mass provided, an
m/z window of +/- 'ppm' is calculated, and all data points within that window are kept.</p>
</td></tr>
<tr><td><code id="minifyMSdata_+3A_ppm">ppm</code></td>
<td>
<p>The parts-per-million error of the instrument used to collect the original file.</p>
</td></tr>
<tr><td><code id="minifyMSdata_+3A_warn">warn</code></td>
<td>
<p>Boolean. Should the function warn the user when removing an index from an mzML file?</p>
</td></tr>
<tr><td><code id="minifyMSdata_+3A_prefilter">prefilter</code></td>
<td>
<p>A single number corresponding to the minimum intensity of
interest in the MS1 data. Data points with intensities below this threshold
will be silently dropped, which can dramatically reduce the size of the
final object. Currently only works with MS1 data, but could be expanded
easily to handle more.</p>
</td></tr>
<tr><td><code id="minifyMSdata_+3A_verbosity">verbosity</code></td>
<td>
<p>A single number with a sensible default behavior. If larger
than 2, will render a progress bar as files are processed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, the name of the new files.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(RaMS)
# Extract data corresponding to only valine and homarine
# m/z = 118.0865 and 138.0555, respectively
filename &lt;- system.file("extdata", "LB12HL_AB.mzML.gz", package = "RaMS")
output_filename &lt;- "mini_LB12HL_AB.mzML"
include_mzs &lt;- c(118.0865, 138.0555)
minifyMSdata(filename, output_filename, mz_include=include_mzs, ppm=5)
init_data &lt;- grabMSdata(filename)
mini_data &lt;- grabMSdata(output_filename)
qplotMS1data(rbind(init_data$BPC, mini_data$BPC), color_col = "filename")
unlink(output_filename)

# Exclude data corresponding to valine and homarine
filename &lt;- system.file("extdata", "LB12HL_AB.mzML.gz", package = "RaMS")
output_filename &lt;- "mini_LB12HL_AB.mzML"
exclude_mzs &lt;- c(118.0865, 138.0555)
minifyMSdata(filename, output_filename, mz_exclude=exclude_mzs, ppm=5)
init_data &lt;- grabMSdata(filename)
mini_data &lt;- grabMSdata(output_filename)
qplotMS1data(rbind(init_data$BPC, mini_data$BPC), color_col = "filename")
unlink(output_filename)

## End(Not run)
</code></pre>

<hr>
<h2 id='minifyMzml'>Shrink mzML files by including only data points near masses of interest</h2><span id='topic+minifyMzml'></span>

<h3>Description</h3>

<p>mzML files can be annoyingly large if only a few masses are of interest. This large size makes it
difficult to share them online for debugging purposes and often means that untargeted algorithms
spend a lot of time picking peaks in data that's irrelevant. minifyMzml is a function designed to
&quot;minify&quot; mzML files by extracting only those data points that are within a ppm error of an m/z value
of interest, and returns the file essentially otherwise unchanged. This function currently works
only on MS1 data, but is reasonably expandable if demand becomes evident.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minifyMzml(
  filename,
  output_filename,
  ppm,
  mz_exclude = NULL,
  mz_include = NULL,
  warn = TRUE,
  prefilter = -1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minifyMzml_+3A_filename">filename</code></td>
<td>
<p>The name of a single file to be minified, usually produced by Proteowizard's 'msconvert'
or something similar.</p>
</td></tr>
<tr><td><code id="minifyMzml_+3A_output_filename">output_filename</code></td>
<td>
<p>The name of the file to be written out.</p>
</td></tr>
<tr><td><code id="minifyMzml_+3A_ppm">ppm</code></td>
<td>
<p>The parts-per-million error of the instrument used to collect the original file.</p>
</td></tr>
<tr><td><code id="minifyMzml_+3A_mz_exclude">mz_exclude</code></td>
<td>
<p>A vector of m/z values that should be excluded from the minified file. This argument
must be used with the 'ppm' argument and should not be used with mz_include. For each mass provided, an
m/z window of +/- 'ppm' is calculated, and all data points within that window are removed.</p>
</td></tr>
<tr><td><code id="minifyMzml_+3A_mz_include">mz_include</code></td>
<td>
<p>A vector of m/z values that should be included in the minified file. This argument
must be used with the 'ppm' argument and should not be used with mz_exclude. For each mass provided, an
m/z window of +/- 'ppm' is calculated, and all data points within that window are kept.</p>
</td></tr>
<tr><td><code id="minifyMzml_+3A_warn">warn</code></td>
<td>
<p>Boolean. Should the function warn the user when removing an index from an mzML file?</p>
</td></tr>
<tr><td><code id="minifyMzml_+3A_prefilter">prefilter</code></td>
<td>
<p>A single number corresponding to the minimum intensity of
interest in the MS1 data. Data points with intensities below this threshold
will be silently dropped, which can dramatically reduce the size of the
final object. Currently only works with MS1 data, but could be expanded
easily to handle more.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, the name of the new file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(RaMS)
# Extract data corresponding to only valine and homarine
# m/z = 118.0865 and 138.0555, respectively
filename &lt;- system.file("extdata", "LB12HL_AB.mzML.gz", package = "RaMS")
output_filename &lt;- "mini_LB12HL_AB.mzML"
include_mzs &lt;- c(118.0865, 138.0555)
minifyMzml(filename, output_filename, mz_include=include_mzs, ppm=5)
unlink(output_filename)

# Exclude data corresponding to valine and homarine
filename &lt;- system.file("extdata", "LB12HL_AB.mzML.gz", package = "RaMS")
output_filename &lt;- "mini_LB12HL_AB.mzML"
exclude_mzs &lt;- c(118.0865, 138.0555)
minifyMzml(filename, output_filename, mz_exclude=exclude_mzs, ppm=5)
unlink(output_filename)

## End(Not run)
</code></pre>

<hr>
<h2 id='minifyMzxml'>Shrink mzxML files by including only data points near masses of interest</h2><span id='topic+minifyMzxml'></span>

<h3>Description</h3>

<p>mzXML files can be annoyingly large if only a few masses are of interest. This large size makes it
difficult to share them online for debugging purposes and often means that untargeted algorithms
spend a lot of time picking peaks in data that's irrelevant. minifyMzxml is a function designed to
&quot;minify&quot; mzXML files by extracting only those data points that are within a ppm error of an m/z value
of interest, and returns the file essentially otherwise unchanged. This function currently works
only on MS1 data, but is reasonably expandable if demand becomes evident.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minifyMzxml(
  filename,
  output_filename,
  ppm,
  mz_exclude = NULL,
  mz_include = NULL,
  prefilter = -1,
  warn = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minifyMzxml_+3A_filename">filename</code></td>
<td>
<p>The name of a single file to be minified, usually produced by Proteowizard's 'msconvert'
or something similar.</p>
</td></tr>
<tr><td><code id="minifyMzxml_+3A_output_filename">output_filename</code></td>
<td>
<p>The name of the file to be written out.</p>
</td></tr>
<tr><td><code id="minifyMzxml_+3A_ppm">ppm</code></td>
<td>
<p>The parts-per-million error of the instrument used to collect the original file.</p>
</td></tr>
<tr><td><code id="minifyMzxml_+3A_mz_exclude">mz_exclude</code></td>
<td>
<p>A vector of m/z values that should be excluded from the minified file. This argument
must be used with the 'ppm' argument and should not be used with mz_include. For each mass provided, an
m/z window of +/- 'ppm' is calculated, and all data points within that window are removed.</p>
</td></tr>
<tr><td><code id="minifyMzxml_+3A_mz_include">mz_include</code></td>
<td>
<p>A vector of m/z values that should be included in the minified file. This argument
must be used with the 'ppm' argument and should not be used with mz_exclude. For each mass provided, an
m/z window of +/- 'ppm' is calculated, and all data points within that window are kept.</p>
</td></tr>
<tr><td><code id="minifyMzxml_+3A_prefilter">prefilter</code></td>
<td>
<p>A single number corresponding to the minimum intensity of
interest in the MS1 data. Data points with intensities below this threshold
will be silently dropped, which can dramatically reduce the size of the
final object. Currently only works with MS1 data, but could be expanded
easily to handle more.</p>
</td></tr>
<tr><td><code id="minifyMzxml_+3A_warn">warn</code></td>
<td>
<p>Boolean. Should the function warn the user when removing an index from an mzML file?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, the name of the new file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(RaMS)
# Extract data corresponding to only valine and homarine
# m/z = 118.0865 and 138.0555, respectively
filename &lt;- system.file("extdata", "LB12HL_AB.mzXML.gz", package = "RaMS")
output_filename &lt;- "mini_LB12HL_AB.mzXML"
include_mzs &lt;- c(118.0865, 138.0555)
minifyMzxml(filename, output_filename, mz_include=include_mzs, ppm=5)
unlink(output_filename)

# Exclude data corresponding to valine and homarine
filename &lt;- system.file("extdata", "LB12HL_AB.mzXML.gz", package = "RaMS")
output_filename &lt;- "mini_LB12HL_AB.mzXML"
exclude_mzs &lt;- c(118.0865, 138.0555)
minifyMzxml(filename, output_filename, mz_exclude=exclude_mzs, ppm=5)
unlink(output_filename)

## End(Not run)
</code></pre>

<hr>
<h2 id='msdata_connection'>S3 constructor for msdata_connection</h2><span id='topic+msdata_connection'></span>

<h3>Description</h3>

<p>S3 constructor for msdata_connection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msdata_connection(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="msdata_connection_+3A_x">x</code></td>
<td>
<p>This is a thing?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Itself, with the class?
</p>

<hr>
<h2 id='mz_group'>Group m/z values into bins of a specified ppm width</h2><span id='topic+mz_group'></span>

<h3>Description</h3>

<p>This function bins m/z values based on their proximity to each other in m/z
space. The algorithm takes the first value in the m/z vector and uses that
as the center of a window with a ppm value provided by the user and assigns
all m/z values within that window to the same group, then removes those
values from consideration and repeats the process until there are no points
left to group. This is often used to construct chromatograms from raw MS
data that can then be visualized or peakpicked. The function can also drop
groups of m/z values if there's not enough points within them or produce
only a certain number of groups. Because the algorithm uses the first value
in the m/z vector as the window center, it's often a good idea to first
sort the values by decreasing intensity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mz_group(mz_vals, ppm, min_group_size = 0, max_groups = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mz_group_+3A_mz_vals">mz_vals</code></td>
<td>
<p>A numeric vector of m/z values</p>
</td></tr>
<tr><td><code id="mz_group_+3A_ppm">ppm</code></td>
<td>
<p>A length-1 numeric vector specifying the desired window size in ppm</p>
</td></tr>
<tr><td><code id="mz_group_+3A_min_group_size">min_group_size</code></td>
<td>
<p>A length-1 numeric vector specifying the minimum number
of points that must fall within an m/z window to be assigned a group number</p>
</td></tr>
<tr><td><code id="mz_group_+3A_max_groups">max_groups</code></td>
<td>
<p>A length-1 numeric vector specifying the maximum number
of total groups to assign.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of the same length as mz_vals specifying the group
into which each m/z value was binned. Values not assigned to a group are
returned as NAs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
example_mz_vals &lt;- c(118.0, 118.1, 138.0, 152.0, 118.2, 138.1, 118.1)
mz_group(example_mz_vals, ppm = 1)
mz_group(example_mz_vals, ppm = 1000)
mz_group(example_mz_vals, ppm = 200000)

mz_group(example_mz_vals, ppm = 1000, min_group_size = 2)
mz_group(example_mz_vals, ppm = 1000, max_groups = 2)

## Not run: 
sample_dir &lt;- system.file("extdata", package = "RaMS")
sample_files &lt;- list.files(sample_dir, full.names=TRUE)
msdata &lt;- grabMSdata(sample_files[c(3, 5, 6)], grab_what="MS1")

grouped_MS1 &lt;- msdata$MS1[mz%between%pmppm(119.0865, 100)][
 order(int, decreasing = TRUE)][
   ,mz_group:=mz_group(mz, ppm = 5)][]
print(grouped_MS1)

library(ggplot2)
library(dplyr)
msdata$MS1[mz%between%pmppm(119.0865, 100)] %&gt;%
  arrange(desc(int)) %&gt;%
  mutate(mz_group=mz_group(mz, ppm=10)) %&gt;%
  ggplot() +
  geom_point(aes(x=rt, y=mz, color=factor(mz_group)))

msdata$MS1[mz%between%pmppm(119.0865, 100)] %&gt;%
  arrange(desc(int)) %&gt;%
  mutate(mz_group=mz_group(mz, ppm=5)) %&gt;%
  qplotMS1data(facet_col = "mz_group")
msdata$MS1[mz%between%pmppm(119.0865, 100)] %&gt;%
  arrange(desc(int)) %&gt;%
  mutate(mz_group=mz_group(mz, ppm=5, max_groups = 2)) %&gt;%
  qplotMS1data(facet_col = "mz_group")

## End(Not run)
</code></pre>

<hr>
<h2 id='node2dt'>Convert node to data.table</h2><span id='topic+node2dt'></span>

<h3>Description</h3>

<p>Convert node to data.table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node2dt(dubset_node, ms_level)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node2dt_+3A_dubset_node">dubset_node</code></td>
<td>
<p>The &quot;data subset&quot; node with children rt, mz, etc.</p>
</td></tr>
<tr><td><code id="node2dt_+3A_ms_level">ms_level</code></td>
<td>
<p>The requested MS level to search for</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table with columns depending on the MS level requested
</p>

<hr>
<h2 id='pmppm'>Plus/minus parts per million</h2><span id='topic+pmppm'></span>

<h3>Description</h3>

<p>It shouldn't be hard to translate a point mass into a mass window bounded by
spectrometer accuracy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmppm(mass, ppm = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmppm_+3A_mass">mass</code></td>
<td>
<p>A length-1 numeric representing the mass of
interest for which a mass range is desired.</p>
</td></tr>
<tr><td><code id="pmppm_+3A_ppm">ppm</code></td>
<td>
<p>The parts-per-million accuracy of the mass spectrometer on which
the data was collected.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A length-2 numeric representing the mass range requested
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pmppm(100, 5)
pmppm(1000000, 5)
pmppm(118.0865, 2.5)
pmppm(892.535313, 10)
</code></pre>

<hr>
<h2 id='print.msdata_connection'>S3 print option for msdata_connection objects</h2><span id='topic+print.msdata_connection'></span>

<h3>Description</h3>

<p>S3 print option for msdata_connection objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'msdata_connection'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.msdata_connection_+3A_x">x</code></td>
<td>
<p>An msdata_connection object containing files and grab_what</p>
</td></tr>
<tr><td><code id="print.msdata_connection_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to print.default, I guess</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Messages, mostly
</p>

<hr>
<h2 id='qplotMS1data'>Quick plot for MS data</h2><span id='topic+qplotMS1data'></span>

<h3>Description</h3>

<p>Syntactic sugar for a common chromatogram plot. Will use 'ggplot2' if
available but has a base plot implementation for use even in ultra
lightweight situations. Accepts the default MS1 output from 'grabMSdata'
of a data.table (or base data.frame) with columns for rt (retention time)
and int (intensity) as well as filename. Creates a plot of intensity vs
retention time with one trace per file. A few additional 'ggplot2' arguments
are also made available for easy coloring or facetting by providing the
name of the associated column to the 'color_col' and 'facet_col' arguments,
respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qplotMS1data(
  MS1_df,
  color_col = NULL,
  facet_col = NULL,
  facet_args = list(ncol = 1),
  force_base = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qplotMS1data_+3A_ms1_df">MS1_df</code></td>
<td>
<p>A data.table with at least three columns named rt, int, and filename</p>
</td></tr>
<tr><td><code id="qplotMS1data_+3A_color_col">color_col</code></td>
<td>
<p>The name of the column to color by. Must be quoted.</p>
</td></tr>
<tr><td><code id="qplotMS1data_+3A_facet_col">facet_col</code></td>
<td>
<p>The name of the column to facet by. Must be quoted.</p>
</td></tr>
<tr><td><code id="qplotMS1data_+3A_facet_args">facet_args</code></td>
<td>
<p>Since the call to facet_wrap is within the function, you
can provide additional facet customization arguments here as a list. Although
if you're starting to fiddle with facets you'll probably be better served by
the proper 'ggplot' call.</p>
</td></tr>
<tr><td><code id="qplotMS1data_+3A_force_base">force_base</code></td>
<td>
<p>Boolean option to force base R graphics instead of 'ggplot'
even if the 'ggplot2' package is installed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If 'ggplot2' is installed, a 'ggplot' object that can be further
modified via additional + commands. Otherwise, NULL and the plot appears
via base graphics at the active device.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
test_df &lt;- expand.grid(rt=rep(1:100, length.out=1000))
test_df$int &lt;- rep(dnorm(seq(-10, 10, length.out=100)), 10)*10+runif(1000)
test_df$filename &lt;- rep(LETTERS[1:10], each=100)
qplotMS1data(test_df)

test_df$startime &lt;- rep(gl(2, 5, labels = c("Morn", "Eve")), each=100)
qplotMS1data(test_df, color_col="startime", facet_col="startime")
qplotMS1data(test_df, color_col="startime", facet_col="startime",
            facet_args=list(ncol=2, scales="free"))

# Using data from the `grabMSdata` function:
## Not run: 
sample_dir &lt;- system.file("extdata", package = "RaMS")
sample_files &lt;- list.files(sample_dir, full.names=TRUE)
msdata &lt;- grabMSdata(sample_files[c(3, 5, 6)], grab_what="MS1")
qplotMS1data(msdata$MS1[mz%between%pmppm(118.0865)])

## End(Not run)
</code></pre>

<hr>
<h2 id='RaMS-package'>RaMS: R Access to Mass-Spec Data</h2><span id='topic+RaMS'></span><span id='topic+RaMS-package'></span>

<h3>Description</h3>

<p>R-based access to mass-spectrometry (MS) data. While many packages exist to process MS data, many of these make it difficult to access the underlying mass-to-charge ratio (m/z), intensity, and retention time of the files themselves. This package is designed to format MS data in a tidy fashion and allows the user perform the plotting and analysis.
</p>


<h3>Details</h3>

<p>The main function of RaMS is <code><a href="#topic+grabMSdata">grabMSdata()</a></code>, which handles most use-cases and
automatically detects file types and is vectorized over multiple files. If
more control over the file reading is desired, both <code><a href="#topic+grabMzmlData">grabMzmlData()</a></code> and
<code><a href="#topic+grabMzxmlData">grabMzxmlData()</a></code> have been exposed to the user, and <code><a href="#topic+grabAccessionData">grabAccessionData()</a></code> is
available if a specific accession value from an mzML file is desired.
</p>
<p>Other useful functions in the package include <code><a href="#topic+minifyMSdata">minifyMSdata()</a></code> and
<code><a href="#topic+tmzmlMaker">tmzmlMaker()</a></code> which have their own documentation pages and vignettes. Two
small helper functions are also included, <code><a href="#topic+pmppm">pmppm()</a></code> and <code><a href="#topic+between">between()</a></code> (with the
alias <code style="white-space: pre;">&#8288;%between%&#8288;</code>) imported from <code>data.table</code>.
</p>
<p>See the package intro on GitHub at https://github.com/wkumler/RaMS and
explore the vignettes with <code>vignette("help", package = "mypkg")</code>
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: William Kumler <a href="mailto:wkumler@uw.edu">wkumler@uw.edu</a> [copyright holder]
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Ricardo Cunha [contributor]
</p>
</li>
<li><p> Ethan Bass [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/wkumler/RaMS">https://github.com/wkumler/RaMS</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/wkumler/RaMS/issues">https://github.com/wkumler/RaMS/issues</a>
</p>
</li></ul>


<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+between'></span><span id='topic++between+'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>data.table</dt><dd><p><code><a href="data.table.html#topic+between">%between%</a></code>, <code><a href="data.table.html#topic+between">between</a></code></p>
</dd>
</dl>

<hr>
<h2 id='tmzmlMaker'>Maker of tmzML documents</h2><span id='topic+tmzmlMaker'></span>

<h3>Description</h3>

<p>This function converts mzML and mzXML documents into &quot;transposed&quot; mzML
(tmzML) documents. Traditional mass-spec data is organized by scan number,
corresponding to retention time, but this isn't always the most sensible
format. Often, it makes more sense to organize a mass-spec file by m/z ratio
instead. This allows parsers to scan and decode a much smaller portion of
the file when searching for a specific mass, as opposed to the traditional
format which requires that every scan be opened, searched, and subset. The
tmzML document implements this strategy and allows the creation of MS object
representations that use essentially zero memory because the data is read
off the disk instead of being stored in RAM. RaMS has been designed to
interface with these new file types identically to traditional files,
allowing all your favorite tidyverse tricks to work just as well and much
more quickly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tmzmlMaker(input_filename, output_filename = NULL, verbosity = 0, binwidth = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tmzmlMaker_+3A_input_filename">input_filename</code></td>
<td>
<p>Character vector of length 1 with the name of the file
to be converted. Can only handle
mzML and mzXML currently - other formats should be converted to one of
these first, using (for example) Proteowizard's msconvert tool.</p>
</td></tr>
<tr><td><code id="tmzmlMaker_+3A_output_filename">output_filename</code></td>
<td>
<p>The name of the file that will be written out. Should
end in &quot;.tmzML&quot; and will throw a warning otherwise. Often, it makes sense
to have two folders in a working directory, one containing the original
mzML files and a second, parallel folder for the tmzMLs.</p>
</td></tr>
<tr><td><code id="tmzmlMaker_+3A_verbosity">verbosity</code></td>
<td>
<p>Numeric value between 0 and 2, corresponding to level of
verbosity shared by the function as it proceeds. 0 means no output, 1 will
produce mile markers after file opening, MS1 and MS2 conversion, and 2 will
provide progress bars between each mile marker.</p>
</td></tr>
<tr><td><code id="tmzmlMaker_+3A_binwidth">binwidth</code></td>
<td>
<p>Numeric value controlling the width of the bins in m/z space to create. Because MS data
is created in such a way that m/z values are continuous, they must be binned
together to create a discrete representation that can be searched efficiently.
Lower values (0.1-1) will have faster retrieval times, while higher values (5-10)
will have faster conversion times.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An msdata_connection object. This object behaves exactly like a normal
RaMS list with values for MS1, MS2, etc. but secretly just contains pointers
to the files requested because the data is extracted on the fly. The S3
msdata_connection object is necessary to create new behaviors for '$' and '[' that
allow indexing like normal.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
sample_dir &lt;- system.file("extdata", package = "RaMS")
sample_files &lt;- list.files(sample_dir, full.names=TRUE, pattern="LB.*mzML")
tmzml_filenames &lt;- gsub(x=sample_files, "\\.mzML.gz", ".tmzML")

# Convert a single file
tmzmlMaker(sample_files[1], tmzml_filenames[1])
file_data &lt;- grabMSdata(tmzml_filenames[1], grab_what="everything", verbosity=2)
file_data$MS1[mz%between%pmppm(118.0865)]

# Multiple files
mapply(tmzmlMaker, sample_files, tmzml_filenames)
file_data &lt;- grabMSdata(tmzml_filenames, grab_what="everything", verbosity=2)
betaine_data &lt;- file_data$MS1[mz%between%pmppm(118.0865)]

# Plot output
plot(betaine_data$rt, betaine_data$int, type="l")
library(ggplot2)
ggplot(betaine_data) + geom_line(aes(x=rt, y=int, color=filename))

# Clean up afterward
file.remove(tmzml_filenames)

## End(Not run)
</code></pre>

<hr>
<h2 id='trapz'>Trapezoidal integration of mass-spec retention time / intensity values</h2><span id='topic+trapz'></span>

<h3>Description</h3>

<p>Performs a trapezoidal Riemann sum to calculate the area under the curve
for mass-spectrometry data. Accepts a vector of retention times and the
associated intensities and returns the area.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trapz(rts, ints, baseline = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trapz_+3A_rts">rts</code></td>
<td>
<p>A numeric vector of retention times across an MS peak. Should be
monotonically increasing and without duplicates or will throw a warning.</p>
</td></tr>
<tr><td><code id="trapz_+3A_ints">ints</code></td>
<td>
<p>A numeric vector of measured intensities across an MS peak</p>
</td></tr>
<tr><td><code id="trapz_+3A_baseline">baseline</code></td>
<td>
<p>A length-1 character vector of either &quot;none&quot; (the default),
&quot;square&quot;, or &quot;trapezoid&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A length-1 numeric value representing the area under the curve
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trapz(1:10, 1:10)
trapz(1:10, 10:1)

trapz(1:10, 11:20)
trapz(1:10, 11:20, baseline="square")
trapz(1:10, 11:20, baseline="trapezoid")

x_vals &lt;- seq(-2, 2, length.out=100)
trapz(x_vals, dnorm(x_vals))

x_vals &lt;- seq(0, pi/2, length.out=100)
trapz(x_vals, cos(x_vals))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
