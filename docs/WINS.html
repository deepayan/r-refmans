<!DOCTYPE html><html><head><title>Help for package WINS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {WINS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#data_binary'>
<p>An example with three binary endpoints.</p></a></li>
<li><a href='#data_continuous'>
<p>An example with three continuous endpoints.</p></a></li>
<li><a href='#data_mix'>
<p>An example with a mixture of endpoint types.</p></a></li>
<li><a href='#data_mix_stratum'>
<p>An example with a mixture of endpoint types with three strata.</p></a></li>
<li><a href='#data_tte'>
<p>An example with three TTE endpoints.</p></a></li>
<li><a href='#partition_t.plot'>
<p>Plot the Win Proportion over the Study Time.</p></a></li>
<li><a href='#sim.data'>
<p>Function for Data Simulation</p></a></li>
<li><a href='#stat_t.plot'>
<p>Plot Win Statistics over the Study Time.</p></a></li>
<li><a href='#win.stat'>
<p>Function to Calculate the Win Statistics</p></a></li>
<li><a href='#win.strategy.default'>
<p>The Default Win Strategy Function.</p></a></li>
<li><a href='#Z_t_con'>
<p>Covariate history in the control group.</p></a></li>
<li><a href='#Z_t_trt'>
<p>Covariate history in the treatment group.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>The R WINS Package</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ying Cui &lt;cuiyingbeicheng@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Calculate the win statistics (win ratio, net benefit and win odds) for prioritized multiple endpoints, plot the win statistics and win proportions over study time if at least one time-to-event endpoint is analyzed, and simulate datasets with dependent endpoints. The package can handle any type of outcomes (continuous, ordinal, binary, time-to-event) and allow users to perform stratified analysis, inverse probability of censoring weighting (IPCW) and inverse probability of treatment weighting (IPTW) analysis.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>copula,ggplot2,ggpubr,reshape2,survival,stringr,viridis</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-29 20:48:31 UTC; ycui</td>
</tr>
<tr>
<td>Author:</td>
<td>Ying Cui [aut, cre],
  Bo Huang [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-29 21:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='data_binary'>
An example with three binary endpoints.
</h2><span id='topic+data_binary'></span>

<h3>Description</h3>

<p>This is a simulated data example with three binary endpoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("data_binary")</code></pre>


<h3>Format</h3>

<p>A data frame with 250 observations on the following 4 variables.
</p>

<dl>
<dt><code>id</code></dt><dd><p>A vector for the patient id.</p>
</dd>
<dt><code>arm</code></dt><dd><p>A vector for the treatment groups.</p>
</dd>
<dt><code>Y_1</code></dt><dd><p>A vector for the outcome of the first endpoint.</p>
</dd>
<dt><code>Y_2</code></dt><dd><p>A vector for the outcome of the second endpoint.</p>
</dd>
<dt><code>Y_3</code></dt><dd><p>A vector for the outcome of the third endpoint.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(data_binary)
str(data_binary)
</code></pre>

<hr>
<h2 id='data_continuous'>
An example with three continuous endpoints.
</h2><span id='topic+data_continuous'></span>

<h3>Description</h3>

<p>This is a simulated data example with three continuous endpoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("data_continuous")</code></pre>


<h3>Format</h3>

<p>A data frame with 250 observations on the following 4 variables.
</p>

<dl>
<dt><code>id</code></dt><dd><p>A vector for the patient id.</p>
</dd>
<dt><code>arm</code></dt><dd><p>A vector for the treatment groups.</p>
</dd>
<dt><code>Y_1</code></dt><dd><p>A vector for the outcome of the first endpoint.</p>
</dd>
<dt><code>Y_2</code></dt><dd><p>A vector for the outcome of the second endpoint.</p>
</dd>
<dt><code>Y_3</code></dt><dd><p>A vector for the outcome of the third endpoint.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(data_continuous)
str(data_continuous)
</code></pre>

<hr>
<h2 id='data_mix'>
An example with a mixture of endpoint types.
</h2><span id='topic+data_mix'></span>

<h3>Description</h3>

<p>This is a simulated data example with a mixture of two continuous and one time-to-event endpoints. The first endpoint is time-to-event and the second and third endpoints are continuous.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("data_mix")</code></pre>


<h3>Format</h3>

<p>A data frame with 400 observations on the following 5 variables.
</p>

<dl>
<dt><code>id</code></dt><dd><p>A vector for the patient id.</p>
</dd>
<dt><code>arm</code></dt><dd><p>A vector for the treatment groups.</p>
</dd>
<dt><code>Delta_1</code></dt><dd><p>A vector for the event status of the first endpoint (1=event, 0=censored).</p>
</dd>
<dt><code>Y_1</code></dt><dd><p>A vector for the outcome of the first endpoint.</p>
</dd>
<dt><code>Y_2</code></dt><dd><p>A vector for the outcome of the second endpoint.</p>
</dd>
<dt><code>Y_3</code></dt><dd><p>A vector for the outcome of the third endpoint.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(data_mix)
str(data_mix)
</code></pre>

<hr>
<h2 id='data_mix_stratum'>
An example with a mixture of endpoint types with three strata.
</h2><span id='topic+data_mix_stratum'></span>

<h3>Description</h3>

<p>This is a simulated data example with a mixture of two continuous and one time-to-event endpoints with three strata. The first endpoint is time-to-event and the second and third endpoints are continuous.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("data_mix_stratum")</code></pre>


<h3>Format</h3>

<p>A data frame with 400 observations on the following 6 variables.
</p>

<dl>
<dt><code>id</code></dt><dd><p>A vector for the patient id.</p>
</dd>
<dt><code>arm</code></dt><dd><p>A vector for the treatment groups.</p>
</dd>
<dt><code>stratum</code></dt><dd><p>A vector for the stratum.</p>
</dd>
<dt><code>Delta_1</code></dt><dd><p>A vector for the event status of the first endpoint (1=event, 0=censored).</p>
</dd>
<dt><code>Y_1</code></dt><dd><p>A vector for the outcome of the first endpoint.</p>
</dd>
<dt><code>Y_2</code></dt><dd><p>A vector for the outcome of the second endpoint.</p>
</dd>
<dt><code>Y_3</code></dt><dd><p>A vector for the outcome of the third endpoint.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(data_mix_stratum)
str(data_mix_stratum)
</code></pre>

<hr>
<h2 id='data_tte'>
An example with three TTE endpoints.
</h2><span id='topic+data_tte'></span>

<h3>Description</h3>

<p>This is a simulated data example with three time-to-event endpoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("data_tte")</code></pre>


<h3>Format</h3>

<p>A data frame with 400 observations on the following 7 variables.
</p>

<dl>
<dt><code>id</code></dt><dd><p>A vector for the patient id.</p>
</dd>
<dt><code>arm</code></dt><dd><p>A vector for the treatment groups.</p>
</dd>
<dt><code>Delta_1</code></dt><dd><p>A vector for the event status of the first endpoint (1=event, 0=censored).</p>
</dd>
<dt><code>Delta_2</code></dt><dd><p>A vector for the event status of the second endpoint (1=event, 0=censored).</p>
</dd>
<dt><code>Delta_3</code></dt><dd><p>A vector for the event status of the third endpoint (1=event, 0=censored).</p>
</dd>
<dt><code>Y_1</code></dt><dd><p>A vector for the outcome of the first endpoint.</p>
</dd>
<dt><code>Y_2</code></dt><dd><p>A vector for the outcome of the second endpoint.</p>
</dd>
<dt><code>Y_3</code></dt><dd><p>A vector for the outcome of the third endpoint.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(data_tte)
str(data_tte)
</code></pre>

<hr>
<h2 id='partition_t.plot'>
Plot the Win Proportion over the Study Time.
</h2><span id='topic+partition_t.plot'></span>

<h3>Description</h3>

<p>A plot for the win proportions of the treatment/control group over the study time, for time-to-event endpoints only. The function &quot;win.stat&quot; is called to calculate the win proportions at each time in the plot function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partition_t.plot(data, Ctime = Inf, arm.name = c(1, 2), priority = c(1, 2),
censoring_adjust = "No", Z_t_trt = NULL, Z_t_con = NULL, tau = 0,
np_direction = "larger",plotTimeUnit = NULL,
trt_group = c("both","trt","con"), win.strategy = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partition_t.plot_+3A_data">data</code></td>
<td>
<p>The analysis dataset which contains the following variables:
</p>

<dl>
<dt>arm: </dt><dd><p>A vector for the treatment groups. Alternative names for &quot;arm&quot; include &quot;trt&quot;, &quot;treat&quot; and &quot;treatment&quot;.</p>
</dd>
<dt>id: </dt><dd><p>A vector for the patient id.</p>
</dd>
<dt>stratum: </dt><dd><p>A vector for the stratum.</p>
</dd>
<dt>Delta_j: </dt><dd><p>A vector for the event status of the j-th endpoint if the endpoint is a time-to-event outcome (1=event, 0=censored).</p>
</dd>
<dt>Y_j: </dt><dd><p>A vector for the outcome of the j-th endpoint, for time-to-event outcome, Y_j is a vector for the observed time.</p>
</dd>
<dt>Start_time: </dt><dd><p>A vector for the time when each of the individuals is first accrued to study.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="partition_t.plot_+3A_ctime">Ctime</code></td>
<td>
<p>A vector of study times, at which the win proportions are to be plotted. Study time for a subject is the time since the subject is accrued, default is Inf.</p>
</td></tr>
<tr><td><code id="partition_t.plot_+3A_arm.name">arm.name</code></td>
<td>
<p>A vector for the two treatments, default to be c(1,2). The first value is for the treatment group, and the second value is for the control group.</p>
</td></tr>
<tr><td><code id="partition_t.plot_+3A_priority">priority</code></td>
<td>
<p>Importance order (from the most to the least important). For example, given three endpoints with the importance order as Endpoint 3, Endpoint 2, and Endpoint 1, input priority = c(3,2,1).</p>
</td></tr>
<tr><td><code id="partition_t.plot_+3A_censoring_adjust">censoring_adjust</code></td>
<td>
<p>The method to adjust censoring for the kernal functions. Possible choices are listed below.
</p>

<dl>
<dt>&quot;No&quot;: </dt><dd><p>Without an adjustment.</p>
</dd>
<dt>&quot;IPCW&quot;: </dt><dd><p>IPCW (inverse-probability-of-censoring weighting) adjustment for censoring using the Kaplan-Meier estimator.</p>
</dd>
<dt>&quot;CovIPCW&quot;: </dt><dd><p>IPCW adjustment for censoring using the time dependent Cox model.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="partition_t.plot_+3A_z_t_trt">Z_t_trt</code></td>
<td>
<p>A matrix of the covariate history in the treatment group, each row is a (p+2) vector: the first two columns are id, time, the other p columns are the covariates (vector of length p). The baseline covariates are provided as the observed covariates corresponding to time 0.</p>
</td></tr>
<tr><td><code id="partition_t.plot_+3A_z_t_con">Z_t_con</code></td>
<td>
<p>A matrix of the covariate history in the control group, each row is a (p+2) vector: the first two columns are id, time, the other p columns are the covariates (vector of length p). The baseline covariates are provided as the observed covariates corresponding to time 0.</p>
</td></tr>
<tr><td><code id="partition_t.plot_+3A_tau">tau</code></td>
<td>
<p>A vector of numerical value for the magnitude of difference to determine win/loss/tie for each endpoint. Tau is applicable for TTE endpoints and continuous endpoints; tau is fixed as 0 for binary endpoints. Default is 0 for all endpoints.</p>
</td></tr>
<tr><td><code id="partition_t.plot_+3A_np_direction">np_direction</code></td>
<td>
<p>A vector of character for the direction to define a better result for each endpoint.
</p>

<dl>
<dt>&quot;larger&quot;: </dt><dd><p>The treatment group wins if min(T_trt, C_trt, C_con + tau) &gt; T_con + tau, for time-to-event outcomes; &quot;the larger value wins&quot; for continuous outcome, value 1 wins over the value 0 for binary outcome.</p>
</dd>
<dt>&quot;smaller&quot;: </dt><dd><p>The treatment group wins if min(T_trt, C_trt, C_con - tau) &lt; T_con - tau, for time-to-event outcomes; &quot;the smaller value wins&quot; for continuous outcome, value 0 wins over the value 1 for binary outcome.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="partition_t.plot_+3A_plottimeunit">plotTimeUnit</code></td>
<td>
<p>The time units, e.g., &quot;days&quot;, &quot;months&quot;, &quot;years&quot;, default as NULL.</p>
</td></tr>
<tr><td><code id="partition_t.plot_+3A_trt_group">trt_group</code></td>
<td>
<p>An argument to decide the arms for which the win proportions over time are plotted, possible choices include &quot;both&quot;, &quot;trt&quot; and &quot;con&quot;. Default is &quot;both&quot;, i.e., by default the win proportion over time is plotted both for the treatment group and for the control group.</p>
</td></tr>
<tr><td><code id="partition_t.plot_+3A_win.strategy">win.strategy</code></td>
<td>
<p>The strategy to determine the win status. Default as NULL. If NULL, the default win strategy funtion &quot;win.strategy.default&quot; is called, see <a href="#topic+win.strategy.default">win.strategy.default</a> for more details. Users can also define their own &quot;win.strategy&quot; function.</p>
</td></tr>
<tr><td><code id="partition_t.plot_+3A_...">...</code></td>
<td>
<p>Argument passed from user defined functions &quot;win.strategy&quot; if there is any. For instructions on this &quot;win.strategy&quot; function, see <a href="#topic+win.strategy.default">win.strategy.default</a> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### An simulated example with two TTE endpoints.
data &lt;- sim.data(n_trt = 200, n_con = 200, n_ep = 2, arm.name = c("A","B"),
ep_type = "tte", cdist.rate = 0.5, sim_method = "copula",
copula_trt=copula::normalCopula(0.9), margins_trt=c("gamma", "beta"),
paramMargins_trt=list(list(shape=2, scale=1),list(shape1=2, shape2=2)),
copula_con=copula::normalCopula(0.9), margins_con=c("gamma", "beta"),
paramMargins_con=list(list(shape=2, scale=1),list(shape1=2, shape2=2)),
max_accrual_time = 5)

partition_t.plot(data, Ctime = seq(0,8,0.2), arm.name = c("A","B"),
priority = c(1,2), tau = 0, plotTimeUnit = "days", trt_group = "both")

#### An simulated example with three TTE endpoints.
data &lt;- sim.data(n_trt = 200, n_con = 200, n_ep = 3, arm.name = c("A","B"),
ep_type = "tte", cdist.rate = 1, sim_method = "copula",
copula_trt=copula::normalCopula(param=c(0.9,0.8,0.95), dim = 3, dispstr = "un"),
margins_trt=c("gamma", "beta", "gamma"),
paramMargins_trt=list(list(shape=2, scale=2),list(shape1=2, shape2=2),list(shape=2, scale=3)),
copula_con=copula::normalCopula(param=c(0.9,0.8,0.95), dim = 3, dispstr = "un"),
margins_con=c("gamma", "beta", "gamma"),
paramMargins_con=list(list(shape=2, scale=1),list(shape1=2, shape2=1),list(shape=2, scale=2)),
max_accrual_time = 5)

partition_t.plot(data, Ctime = c(seq(0,8,0.5),seq(8.1,10,0.1)), arm.name = c("A","B"),
priority = c(3,2,1), tau = 0, plotTimeUnit = "years", trt_group = "trt")

</code></pre>

<hr>
<h2 id='sim.data'>
Function for Data Simulation
</h2><span id='topic+sim.data'></span>

<h3>Description</h3>

<p>A function to simulate a dataset with dependent endpoints. The time-to-event endpoints generated are assumed to have noninformative censoring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.data(randomseed = 12345, n_trt = 200, n_con = 200, n_ep = 2, n_stratum = 1,
arm.name = c(1,2), ep_type, cdist.rate, sim_method = "copula",
copula_trt = NULL, margins_trt = NULL, paramMargins_trt = NULL,
copula_con = NULL, margins_con = NULL, paramMargins_con = NULL,
rate_trt = NULL, rate_con = NULL, max_accrual_time = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.data_+3A_randomseed">randomseed</code></td>
<td>
<p>The random seed.</p>
</td></tr>
<tr><td><code id="sim.data_+3A_n_trt">n_trt</code></td>
<td>
<p>The number of individuals in the treatment group.</p>
</td></tr>
<tr><td><code id="sim.data_+3A_n_con">n_con</code></td>
<td>
<p>The number of individuals in the control group.</p>
</td></tr>
<tr><td><code id="sim.data_+3A_n_ep">n_ep</code></td>
<td>
<p>The number of endpoints.</p>
</td></tr>
<tr><td><code id="sim.data_+3A_n_stratum">n_stratum</code></td>
<td>
<p>The number of strata. For the simulated dataset, n_stratum is fixed at 1 assuming homogeneous population.</p>
</td></tr>
<tr><td><code id="sim.data_+3A_arm.name">arm.name</code></td>
<td>
<p>A vector for the labels of the two experimental arms, default to be c(1,2). The first label is for the treatment group, and the second label is for the control group.</p>
</td></tr>
<tr><td><code id="sim.data_+3A_ep_type">ep_type</code></td>
<td>
<p>A vector for the outcome type for each endpoint.  If scalar, the function will treat all the endpoints as the same type. The types of outcome include:
</p>

<dl>
<dt>&quot;tte&quot;: </dt><dd><p>Time-to-event outcome, with the default win strategy: the treatment group wins if min(T_trt, C_trt, C_con + tau) &gt; T_con + tau.</p>
</dd>
<dt>&quot;continuous&quot;: </dt><dd><p>Continuous outcome, with the default win strategy: the treatment group wins if Y_trt &gt; Y_con + tau.</p>
</dd>
<dt>&quot;binary&quot;: </dt><dd><p>Binary outcome coded as 0/1, with the default win strategy: 1 is the winner over 0.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="sim.data_+3A_cdist.rate">cdist.rate</code></td>
<td>
<p>The censoring time is generated from an exponential distribution. This argument is a vector with the rate of the censoring distribution for each time-to-event endpoint. If scalar, the function will treat all the rate for censoring distribution as the same.</p>
</td></tr>
<tr><td><code id="sim.data_+3A_sim_method">sim_method</code></td>
<td>
<p>Method used to generate multivariate dependence. Possible choices include &quot;copula&quot; and &quot;tte_exponential&quot;</p>
</td></tr>
<tr><td><code id="sim.data_+3A_copula_trt">copula_trt</code></td>
<td>
<p>an object of &quot;copula&quot; for the treatment group.</p>
</td></tr>
<tr><td><code id="sim.data_+3A_margins_trt">margins_trt</code></td>
<td>
<p>a character vector specifying all the parametric marginal distributions for the treatment group. See details in the R documentation for function &quot;copula::Mvd&quot;.</p>
</td></tr>
<tr><td><code id="sim.data_+3A_parammargins_trt">paramMargins_trt</code></td>
<td>
<p>a list for which each element is a list (or numeric vectors) of named components, giving the parameter values of the marginal distributions for the treatment group. See details in the R documentation for function &quot;copula::Mvd&quot;.</p>
</td></tr>
<tr><td><code id="sim.data_+3A_copula_con">copula_con</code></td>
<td>
<p>Same argument as &quot;copula_trt&quot; for the control group.</p>
</td></tr>
<tr><td><code id="sim.data_+3A_margins_con">margins_con</code></td>
<td>
<p>Same argument as &quot;margins_trt&quot; for the control group.</p>
</td></tr>
<tr><td><code id="sim.data_+3A_parammargins_con">paramMargins_con</code></td>
<td>
<p>Same argument as &quot;paramMargins_trt&quot; for the control group.</p>
</td></tr>
<tr><td><code id="sim.data_+3A_rate_trt">rate_trt</code></td>
<td>
<p>A vector of the rate in the treatment group for each time-to-event endpoint following an exponential distribution when &quot;sim_method&quot; is set to be the option &quot;tte_exponential&quot;.</p>
</td></tr>
<tr><td><code id="sim.data_+3A_rate_con">rate_con</code></td>
<td>
<p>A vector of the rate in the control group for each time-to-event endpoint following an exponential distribution when &quot;sim_method&quot; is set to be the option &quot;tte_exponential&quot;.</p>
</td></tr>
<tr><td><code id="sim.data_+3A_max_accrual_time">max_accrual_time</code></td>
<td>
<p>if specified, simulate the study entry time for each individual from uniform distribution U(0,max_accrual_time).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To learn more about &quot;copula&quot;, please refer to a discussion on modelling dependence with copulas with the link <a href="https://datascienceplus.com/modelling-dependence-with-copulas/">https://datascienceplus.com/modelling-dependence-with-copulas/</a>. It shows on a high level how copula works, how to use a copula in R using the copula package and then provides a simple example. Moreover, when &quot;sim_method&quot; is set to be the option &quot;tte_exponential&quot;, we simulate two endpoints based on the exponential distribution. Dependence between the two simulated endpoints is introduced, as the earlier endpoint takes the min of the two simulated exponential variables.
</p>


<h3>Value</h3>

<table>
<tr><td><code>data</code></td>
<td>
<p>The analysis dataset which contains the following variables:
</p>

<dl>
<dt>arm: </dt><dd><p>A vector for the treatment group (trt = 1 | 2), 1 represents the treatment group and 2 represents the control group.</p>
</dd>
<dt>stratum: </dt><dd><p>A vector for the stratum number. Alternative names for &quot;stratum&quot; include &quot;group&quot;, &quot;level&quot; and &quot;grade&quot;.</p>
</dd>
<dt>Delta_j: </dt><dd><p>A vector for the event status of the j-th endpoint if the endpoint is time-to-event outcome (1=event, 0=censored).</p>
</dd>
<dt>Y_j: </dt><dd><p>A vector for the outcome of the j-th endpoint, for time-to-event outcome, it would be a vector of simulated time.</p>
</dd>
<dt>Start_time: </dt><dd><p>A vector for the time when each of the individuals is first accrued to study. Valid only if &quot;max_accrual_time&quot; is not NULL.</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#### Generate with copula: This example is for three endpoints, noted as Y_1, Y_2, and Y_3,
#### with endpoint type as TTE, TTE and continuous.
#### For both the treatment group and the control group, the correlation coefficients
#### cor(Y_1,Y_2), cor(Y_1,Y_3) and cor(Y_2,Y_3) are 0.9, 0.8 and 0.95, respectively.
#### For each treatment group, the marginal distribution for Y_1, Y_2, and Y_3 are Gamma,
#### Beta and Student t specified as a vector in "margins_trt"/"margins_con". The parameters
#### are specified as a list corresponding to the margianl distributions in "paramMargins_trt"
#### or "paramMargins_con".
sim.data &lt;- sim.data(n_trt = 150, n_con = 100, n_ep = 3, arm.name = c("A","B"),
ep_type = c("tte","tte","continuous"), cdist.rate = 0.5, sim_method = "copula",
copula_trt=copula::normalCopula(param=c(0.9,0.8,0.95), dim = 3, dispstr = "un"),
margins_trt=c("gamma", "beta", "t"),
paramMargins_trt=list(list(shape=2, scale=1),list(shape1=2, shape2=2),list(df=5)),
copula_con=copula::normalCopula(param=c(0.9,0.8,0.95), dim = 3, dispstr = "un"),
margins_con=c("gamma", "beta", "t"),
paramMargins_con=list(list(shape=1, scale=1),list(shape1=1, shape2=2),list(df=2)),
max_accrual_time = 5)

win_stat &lt;- win.stat(data = sim.data, ep_type = c("tte","tte","continuous"),
arm.name = c("A","B"), priority = c(1,2,3))

#### Generate two TTE endpoints with the more important TTE endpoint expected to occur later
#### with exponential distribution.
sim.data2 &lt;- sim.data(n_trt = 150, n_con = 100, n_ep = 2, arm.name = c("A","B"),
ep_type = c("tte","tte"), cdist.rate = 0.5, sim_method = "tte_exponential",
rate_trt = c(0.2,0.25),rate_con = c(0.4,0.5), max_accrual_time = 5)

win_stat2 &lt;- win.stat(data = sim.data2, ep_type = c("tte","tte"), arm.name = c("A","B"),
priority = c(1,2))

</code></pre>

<hr>
<h2 id='stat_t.plot'>
Plot Win Statistics over the Study Time.
</h2><span id='topic+stat_t.plot'></span>

<h3>Description</h3>

<p>Plot the win statistics as a function of the study time for time-to-event endpoints only. The function &quot;win.stat&quot; is called to calculate the win statistics at each time in the plot function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_t.plot(data, Ctime = Inf, arm.name = c(1,2), priority = c(1,2),
statistic = c("WR","NB","WO"),
Z_t_trt = NULL, Z_t_con = NULL, tau = 0,np_direction = "larger",
stratum.weight = c("unstratified","MH-type","wt.stratum1","wt.stratum2","equal"),
censoring_adjust = c("No","IPCW","CovIPCW"),
win.strategy = NULL, plotTimeUnit = NULL,
plot_CI = FALSE, alpha = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_t.plot_+3A_data">data</code></td>
<td>
<p>The analysis dataset which contains the following variables:
</p>

<dl>
<dt>arm: </dt><dd><p>A vector for the treatment group (trt = 1 | 2), trt is the new treatment. Alternative names for &quot;arm&quot; include &quot;trt&quot;, &quot;treat&quot; and &quot;treatment&quot;.</p>
</dd>
<dt>id: </dt><dd><p>A vector for the patient id.</p>
</dd>
<dt>stratum: </dt><dd><p>A vector for the stratum.</p>
</dd>
<dt>Delta_j: </dt><dd><p>A vector for the event status of the j-th endpoint if the endpoint is a time-to-event outcome (1=event, 0=censored).</p>
</dd>
<dt>Y_j: </dt><dd><p>A vector for the outcome of the j-th endpoint, for a time-to-event outcome, it would be a vector for time.</p>
</dd>
<dt>Start_time: </dt><dd><p>A vector for the time when each of the individuals is first accrued to study.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="stat_t.plot_+3A_ctime">Ctime</code></td>
<td>
<p>A vector of study times, at which the win proportions are to be plotted. Study time for a subject is the time since the subject is accrued, default as Inf.</p>
</td></tr>
<tr><td><code id="stat_t.plot_+3A_arm.name">arm.name</code></td>
<td>
<p>A vector for the labels of the two experimental arms, default to be c(1,2). The first label is for the treatment group, and the second label is for the control group.</p>
</td></tr>
<tr><td><code id="stat_t.plot_+3A_priority">priority</code></td>
<td>
<p>Importance order (from the most to the least important). For example, given three endpoints with the importance order as Endpoint 3, Endpoint 2, and Endpoint 1, input priority = c(3,2,1).</p>
</td></tr>
<tr><td><code id="stat_t.plot_+3A_statistic">statistic</code></td>
<td>
<p>The win statistic to be plotted.
</p>

<dl>
<dt>&quot;WR&quot;: </dt><dd><p>Win ratio.</p>
</dd>
<dt>&quot;NB&quot;: </dt><dd><p>Net benefit.</p>
</dd>
<dt>&quot;WO&quot;: </dt><dd><p>Win odds.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="stat_t.plot_+3A_z_t_trt">Z_t_trt</code></td>
<td>
<p>A matrix for the covariate history, each row is a (p+2) vector for one record of each subject in the treatment group. The first two columns are subject id, time, the other columns are the covariates (vector of length p). The baseline covariates are provided as the observed covariates corresponding to time 0.</p>
</td></tr>
<tr><td><code id="stat_t.plot_+3A_z_t_con">Z_t_con</code></td>
<td>
<p>A matrix for the covariate history, each row is a (p+2) vector for one record of each subject in the control group. The first two columns are subject id, time, the other columns are the covariates (vector of length p). The baseline covariates are provided as the observed covariates corresponding to time 0.</p>
</td></tr>
<tr><td><code id="stat_t.plot_+3A_tau">tau</code></td>
<td>
<p>A vector of numerical value for the magnitude of difference to determine win/loss/tie for each endpoint. If tau is input as scalar, the function treat the taus for TTE endpoints and continuous endpoints to be the same and taus for binary endpoints as 0. Default as 0 for all endpoints.</p>
</td></tr>
<tr><td><code id="stat_t.plot_+3A_np_direction">np_direction</code></td>
<td>
<p>A vector of character for the direction to define a better result for each endpoint.
</p>

<dl>
<dt>&quot;larger&quot;: </dt><dd><p>The treatment group wins if min(T_trt, C_trt, C_con + tau) &gt; T_con + tau, for time-to-event outcomes; &quot;the larger value wins&quot; for continuous outcome, value 1 wins over the value 0 for binary outcome.</p>
</dd>
<dt>&quot;smaller&quot;: </dt><dd><p>The treatment group wins if min(T_trt, C_trt, C_con - tau) &lt; T_con - tau, for time-to-event outcomes; &quot;the smaller value wins&quot; for continuous outcome, value 0 wins over the value 1 for binary outcome.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="stat_t.plot_+3A_stratum.weight">stratum.weight</code></td>
<td>
<p>The weighting method for each stratum. Default is &quot;unstratified&quot; for unstratified analysis. A stratified analysis is performed if other weight option is specified. Other possible choices for this argument are listed below.
</p>

<dl>
<dt>&quot;MH-type&quot;: </dt><dd><p>weight the wins with the reciprocal of the stratum size following the Mantel-Haenszel type stratified analysis as described in Dong et al. (2018).</p>
</dd>
<dt>&quot;wt.stratum1&quot;: </dt><dd><p>weight the win statistics with weight equal to the number of subjects in each stratum divided by the total number of subjects.</p>
</dd>
<dt>&quot;wt.stratum2&quot;: </dt><dd><p>weight the win statistics with weight equal to the number of subjects with events (of any TTE endpoint) in each stratum divided by the total number of subjects with events (of any TTE endpoint).</p>
</dd>
<dt>&quot;equal&quot;: </dt><dd><p>set equal weights for all stratum.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="stat_t.plot_+3A_censoring_adjust">censoring_adjust</code></td>
<td>
<p>The method to adjust censoring for the kernal functions. Possible choices are listed below.
</p>

<dl>
<dt>&quot;No&quot;: </dt><dd><p>Without using the IPCW approach to dealing with the censoring.</p>
</dd>
<dt>&quot;IPCW&quot;: </dt><dd><p>IPCW adjustment for censoring with the Kaplan-Meier estimator.</p>
</dd>
<dt>&quot;CovIPCW&quot;: </dt><dd><p>IPCW adjustment for censoring with the time dependent Cox model.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="stat_t.plot_+3A_win.strategy">win.strategy</code></td>
<td>
<p>The strategy to determine the win status. Default as NULL. If NULL, the default win strategy funtion &quot;win.strategy.default&quot; is called, see <a href="#topic+win.strategy.default">win.strategy.default</a> for more details. Users can also define their own &quot;win.strategy&quot; function.</p>
</td></tr>
<tr><td><code id="stat_t.plot_+3A_plottimeunit">plotTimeUnit</code></td>
<td>
<p>The time units, e.g., &quot;days&quot;, &quot;months&quot;, &quot;years&quot;, default as NULL.</p>
</td></tr>
<tr><td><code id="stat_t.plot_+3A_plot_ci">plot_CI</code></td>
<td>
<p>If TRUE, plot the pointwise confidence interval, default as FALSE.</p>
</td></tr>
<tr><td><code id="stat_t.plot_+3A_alpha">alpha</code></td>
<td>
<p>The significance level, default to be 0.05.</p>
</td></tr>
<tr><td><code id="stat_t.plot_+3A_...">...</code></td>
<td>
<p>Argument passed from user defined functions &quot;win.strategy&quot; if there is any. For instructions on this &quot;win.strategy&quot; function, see <a href="#topic+win.strategy.default">win.strategy.default</a> for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### An simulated example with two TTE endpoints.
data &lt;- sim.data(n_trt = 200, n_con = 200, n_ep = 2, arm.name = c("A","B"),
ep_type = "tte", cdist.rate = 0.5, sim_method = "copula",
copula_trt=copula::normalCopula(0.9), margins_trt=c("gamma", "beta"),
paramMargins_trt=list(list(shape=2, scale=1),list(shape1=2, shape2=2)),
copula_con=copula::normalCopula(0.9), margins_con=c("gamma", "beta"),
paramMargins_con=list(list(shape=2, scale=1),list(shape1=2, shape2=2)),
max_accrual_time = 5)

stat_t.plot(data, arm.name = c("A","B"),priority = c(1,2),
Ctime = seq(2,12,1),plotTimeUnit = "years",statistic = "WR", tau = 0,
stratum.weight = "unstratified", censoring_adjust = "No", plot_CI = TRUE)

#### An simulated example with three TTE endpoints.
data &lt;- sim.data(n_trt = 200, n_con = 200, n_ep = 3, arm.name = c("A","B"),
ep_type = "tte", cdist.rate = 0.5, sim_method = "copula",
copula_trt=copula::normalCopula(param=c(0.9,0.8,0.95), dim = 3, dispstr = "un"),
margins_trt=c("gamma", "beta", "t"),
paramMargins_trt=list(list(shape=2, scale=1),list(shape1=2, shape2=2),list(df=5)),
copula_con=copula::normalCopula(param=c(0.9,0.8,0.95), dim = 3, dispstr = "un"),
margins_con=c("gamma", "beta", "t"),
paramMargins_con=list(list(shape=1, scale=1),list(shape1=2, shape2=3),list(df=5)),
max_accrual_time = 5)

stat_t.plot(data, arm.name = c("A","B"),priority = c(3,2,1),
Ctime = seq(1,8,0.5),plotTimeUnit = "years", statistic = "WR",
tau = 0, plot_CI = TRUE)

</code></pre>

<hr>
<h2 id='win.stat'>
Function to Calculate the Win Statistics
</h2><span id='topic+win.stat'></span>

<h3>Description</h3>

<p>Calculate the win statistics for a mixture type of outcomes including time-to-event outcome, continuous outcome and binary outcome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>win.stat(data, ep_type, Z_t_trt = NULL, Z_t_con = NULL, iptw.weight = NULL,
arm.name = c(1,2),priority = c(1,2), alpha = 0.05, digit = 5, tau = 0,
np_direction = "larger", win.strategy = NULL,pvalue = c("one-sided","two-sided"),
stratum.weight = c("unstratified","MH-type","wt.stratum1","wt.stratum2","equal"),
method = c("unadjusted","ipcw","covipcw","iptw"),
summary.print = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="win.stat_+3A_data">data</code></td>
<td>
<p>The analysis dataset which contains the following variables:
</p>

<dl>
<dt>arm: </dt><dd><p>A vector for the treatment groups. Alternative names for &quot;arm&quot; include &quot;trt&quot;, &quot;treat&quot; and &quot;treatment&quot;.</p>
</dd>
<dt>id: </dt><dd><p>A vector for the patient id.</p>
</dd>
<dt>stratum: </dt><dd><p>A vector for the stratum.</p>
</dd>
<dt>Delta_j: </dt><dd><p>A vector for the event status of the j-th endpoint if the endpoint is a time-to-event outcome (1=event, 0=censored).</p>
</dd>
<dt>Y_j: </dt><dd><p>A vector for the outcome of the j-th endpoint, for time-to-event outcome, Y_j is a vector for the observed time.</p>
</dd>
<dt>Start_time: </dt><dd><p>A vector for the time when each of the individuals is first accrued to study.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="win.stat_+3A_ep_type">ep_type</code></td>
<td>
<p>A vector for the outcome type for each endpoint.  If scalar, the function will treat all the endpoints as the same type. The types of outcome include:
</p>

<dl>
<dt>&quot;tte&quot;: </dt><dd><p>Time-to-event outcome, with the default win strategy: the treatment group wins if min(T_trt, C_trt, C_con + tau) &gt; T_con + tau.</p>
</dd>
<dt>&quot;continuous&quot;: </dt><dd><p>Continuous outcome, with the default win strategy: the treatment group wins if Y_trt &gt; Y_con + tau.</p>
</dd>
<dt>&quot;binary&quot;: </dt><dd><p>Binary outcome coded as 0/1, with the default win strategy: 1 is the winner over 0.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="win.stat_+3A_z_t_trt">Z_t_trt</code></td>
<td>
<p>A matrix of the covariate history in the treatment group, each row is a (p+2) vector: the first two columns are subject id, time, the other p columns are the covariates (vector of length p). The baseline covariates are provided as the observed covariates corresponding to time 0.</p>
</td></tr>
<tr><td><code id="win.stat_+3A_z_t_con">Z_t_con</code></td>
<td>
<p>A matrix of the covariate history in the control group, each row is a (p+2) vector: the first two columns are subject id, time, the other p columns are the covariates (vector of length p). The baseline covariates are provided as the observed covariates corresponding to time 0.</p>
</td></tr>
<tr><td><code id="win.stat_+3A_iptw.weight">iptw.weight</code></td>
<td>
<p>The weight assigned to each individual if method = &quot;iptw&quot;.</p>
</td></tr>
<tr><td><code id="win.stat_+3A_arm.name">arm.name</code></td>
<td>
<p>A vector for the labels of the two experimental arms, default to be c(1,2). The first label is for the treatment group, and the second label is for the control group.</p>
</td></tr>
<tr><td><code id="win.stat_+3A_priority">priority</code></td>
<td>
<p>Importance order (from the most to the least important). For example, given three endpoints with the importance order as Endpoint 3, Endpoint 2, and Endpoint 1, input priority = c(3,2,1).</p>
</td></tr>
<tr><td><code id="win.stat_+3A_alpha">alpha</code></td>
<td>
<p>The significance level, default to be 0.05.</p>
</td></tr>
<tr><td><code id="win.stat_+3A_digit">digit</code></td>
<td>
<p>The number of digits for the output, default to be 5.</p>
</td></tr>
<tr><td><code id="win.stat_+3A_tau">tau</code></td>
<td>
<p>A vector of numerical value for the magnitude of difference to determine win/loss/tie for each endpoint. Tau is applicable for TTE endpoints and continuous endpoints; tau is fixed as 0 for binary endpoints. Default is 0 for all endpoints.</p>
</td></tr>
<tr><td><code id="win.stat_+3A_np_direction">np_direction</code></td>
<td>
<p>A vector of character for the direction to define a better result for each endpoint.
</p>

<dl>
<dt>&quot;larger&quot;: </dt><dd><p>The treatment group wins if min(T_trt, C_trt, C_con + tau) &gt; T_con + tau, for time-to-event outcomes; &quot;the larger value wins&quot; for continuous outcome, value 1 wins over the value 0 for binary outcome.</p>
</dd>
<dt>&quot;smaller&quot;: </dt><dd><p>The treatment group wins if min(T_trt, C_trt, C_con - tau) &lt; T_con - tau, for time-to-event outcomes; &quot;the smaller value wins&quot; for continuous outcome, value 0 wins over the value 1 for binary outcome.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="win.stat_+3A_win.strategy">win.strategy</code></td>
<td>
<p>The strategy to determine the win status. Default as NULL. If NULL, the default win strategy funtion &quot;win.strategy.default&quot; is called, see <a href="#topic+win.strategy.default">win.strategy.default</a> for more details. Users can also define their own &quot;win.strategy&quot; function.</p>
</td></tr>
<tr><td><code id="win.stat_+3A_pvalue">pvalue</code></td>
<td>
<p>The p-value type: &quot;one-sided&quot; or &quot;two-sided&quot;.</p>
</td></tr>
<tr><td><code id="win.stat_+3A_stratum.weight">stratum.weight</code></td>
<td>
<p>The weighting method for each stratum. Default is &quot;unstratified&quot; for unstratified analysis. A stratified analysis is performed if other weight option is specified. Other possible choices for this argument are listed below.
</p>

<dl>
<dt>&quot;MH-type&quot;: </dt><dd><p>weight the wins with the reciprocal of the stratum size following the Mantel-Haenszel type stratified analysis as described in Dong et al. (2018).</p>
</dd>
<dt>&quot;wt.stratum1&quot;: </dt><dd><p>weight the win statistics with weight equal to the number of subjects in each stratum divided by the total number of subjects.</p>
</dd>
<dt>&quot;wt.stratum2&quot;: </dt><dd><p>weight the win statistics with weight equal to the number of subjects with events (of any TTE endpoint) in each stratum divided by the total number of subjects with events (of any TTE endpoint).</p>
</dd>
<dt>&quot;equal&quot;: </dt><dd><p>set equal weights for all stratum.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="win.stat_+3A_method">method</code></td>
<td>
<p>The method to adjust the kernal functions. Possible choices are listed below.
</p>

<dl>
<dt>&quot;unadjusted&quot;: </dt><dd><p>Without using the IPCW approach to dealing with the censoring.</p>
</dd>
<dt>&quot;ipcw&quot;: </dt><dd><p>IPCW adjustment for censoring with the Kaplan-Meier estimator.</p>
</dd>
<dt>&quot;covipcw&quot;: </dt><dd><p>IPCW adjustment for censoring with the time dependent Cox model.</p>
</dd>
<dt>&quot;iptw&quot;: </dt><dd><p>Inverse probability of treatment weighting (IPTW) method.</p>
</dd>
</dl>

<p>Other methods may be added in future versions.
</p>
</td></tr>
<tr><td><code id="win.stat_+3A_summary.print">summary.print</code></td>
<td>
<p>If TRUE, print out a summary of the estimation and inference result for the win statistics; If FALSE, return a list that summarizes the results. Default as TRUE.</p>
</td></tr>
<tr><td><code id="win.stat_+3A_...">...</code></td>
<td>
<p>Argument passed from user defined functions &quot;win.strategy&quot; if there is any. For instructions on this &quot;win.strategy&quot; function, see <a href="#topic+win.strategy.default">win.strategy.default</a> for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments of user defined &quot;win.strategy&quot; function must at least include the argument &quot;trt_con&quot; and &quot;priority&quot;. &quot;priority&quot; is defined the same as stated in the main function &quot;win.stat&quot;. The intermediate analysis dataset &quot;trt_con&quot; for the patient pairs (i.e., unmatched pairs, see Pocock et al., 2012) contains the following variables. Each row represents a pair.
</p>

<dl>
<dt>stratum: </dt><dd><p>A vector for the stratum number of the unmatched pairs.</p>
</dd>
<dt>pid_trt: </dt><dd><p>A vector for the subject id of the individuals from the treatment group within each unmatched pair.</p>
</dd>
<dt>pid_con: </dt><dd><p>A vector for the subject id of the individuals from the control group within each unmatched pair.</p>
</dd>
<dt>Delta_j_trt: </dt><dd><p>A vector for the event status of the j-th endpoint (1=event, 0=censored) for the individuals from the treatment group in each unmatched pair. If the outcome type for the endpoint is continuous/binary, then the event status is 1 for all.</p>
</dd>
<dt>Delta_j_con: </dt><dd><p>A vector for the event status of the j-th endpoint (1=event, 0=censored) for the individuals from the control group in each unmatched pair. If the outcome type for the endpoint is continuous/binary, then the event status is 1 for all.</p>
</dd>
<dt>Y_j_trt: </dt><dd><p>A vector for the outcome of the j-th endpoint for the individuals from the treatment group in each unmatched pair. For a time-to-event outcome, it would be a vector of observed time-to-event observations.</p>
</dd>
<dt>Y_j_con: </dt><dd><p>A vector for the outcome of the j-th endpoint for the individuals from the control group in each unmatched pair. For a time-to-event outcome, it would be a vector of observed time-to-event observations.</p>
</dd>
</dl>



<h3>Value</h3>

<table>
<tr><td><code>Win_prop</code></td>
<td>
<p>The win proportion of the treatment and the control group.</p>
</td></tr>
<tr><td><code>Win_statistic</code></td>
<td>
<p>The win statistics including:
</p>

<dl>
<dt>Win_Ratio: </dt><dd><p>A list for the ratio of the win proportion between the treatment and the control groups.</p>
</dd>
<dt>Net_Benefit: </dt><dd><p>A list for the difference of the win proportion between the treatment and the control groups.</p>
</dd>
<dt>Win_Odds: </dt><dd><p>A list for the win odds between the treatment and the control groups.</p>
</dd>
</dl>

</td></tr>
<tr><td><code>z_statistic</code></td>
<td>
<p>The z-scores including:
</p>

<dl>
<dt>zstat_WR: </dt><dd><p>z-score for win ratio.</p>
</dd>
<dt>zstat_NB: </dt><dd><p>z-score for net benefit.</p>
</dd>
<dt>zstat_WO: </dt><dd><p>z-score for win odds.</p>
</dd>
</dl>

</td></tr>
<tr><td><code>pvalue</code></td>
<td>
<p>The p-value for the test statistics including:
</p>

<dl>
<dt>pvalue_WR: </dt><dd><p>p-value for win ratio.</p>
</dd>
<dt>pvalue_NB: </dt><dd><p>p-value for net benefit.</p>
</dd>
<dt>pvalue_WO: </dt><dd><p>p-value for win odds.</p>
</dd>
</dl>

</td></tr>
<tr><td><code>summary_ep</code></td>
<td>
<p>The win count and win proportion of the treatment and the control group for each endpoint</p>
</td></tr>
</table>


<h3>References</h3>


<ul>
<li><p> Bebu, I. and Lachin, J.M., 2016. Large sample inference for a win ratio analysis of a composite outcome based on prioritized components. Biostatistics.
</p>
</li>
<li><p> Buyse, M., 2010. Generalized pairwise comparisons of prioritized outcomes in the two-sample problem. Statistics in medicine.
</p>
</li>
<li><p> Cui, Y., Dong, G., Kuan, P.F. and Huang, B., 2022. Evidence synthesis analysis with prioritized benefit outcomes in oncology clinical trials. Journal of Biopharmaceutical Statistics.
</p>
</li>
<li><p> Dong, G., Li, D., Ballerstedt, S. and Vandemeulebroecke, M., 2016. A generalized analytic solution to the win ratio to analyze a composite endpoint considering the clinical importance order among components. Pharmaceutical statistics.
</p>
</li>
<li><p> Dong, G., Qiu, J., Wang, D. and Vandemeulebroecke, M., 2018. The stratified win ratio. Journal of biopharmaceutical statistics.
</p>
</li>
<li><p> Dong, G., Huang, B., Chang, Y.W., Seifu, Y., Song, J. and Hoaglin, D.C., 2020. The win ratio: Impact of censoring and follow-up time and use with nonproportional hazards. Pharmaceutical statistics.
</p>
</li>
<li><p> Dong, G., Mao, L., Huang, B., Gamalo-Siebers, M., Wang, J., Yu, G. and Hoaglin, D.C., 2020. The inverse-probability-of-censoring weighting (IPCW) adjusted win ratio statistic: an unbiased estimator in the presence of independent censoring. Journal of biopharmaceutical statistics.
</p>
</li>
<li><p> Dong, G., Hoaglin, DC., Qiu, J., Matsouaka, RA., Chang, Y., Wang, J., Vandemeulebroecke, M., 2020. The win ratio: on interpretation and handling of ties. Statistics in Biopharmaceutical Research.
</p>
</li>
<li><p> Dong, G., Huang, B., Wang, D., Verbeeck, J., Wang, J. and Hoaglin, D.C., 2021. Adjusting win statistics for dependent censoring. Pharmaceutical Statistics.
</p>
</li>
<li><p> Dong, G., Huang, B., Verbeeck, J., Cui, Y., Song, J., Gamalo-Siebers, M., Wang, D., Hoaglin, D.C., Seifu, Y., Mutze, T. and Kolassa, J., 2022. Win statistics (win ratio, win odds, and net benefit) can complement one another to show the strength of the treatment effect on time-to-event outcomes. Pharmaceutical Statistics.
</p>
</li>
<li><p> Dong, G., Hoaglin, D.C., Huang, B., Cui, Y., Wang, D., Cheng, Y. and Gamalo-Siebers, M., 2023. The stratified win statistics (win ratio, win odds, and net benefit). Pharmaceutical Statistics.
</p>
</li>
<li><p> Finkelstein, D.M. and Schoenfeld, D.A., 1999. Combining mortality and longitudinal measures in clinical trials. Statistics in medicine.
</p>
</li>
<li><p> Finkelstein, D.M. and Schoenfeld, D.A., 2019. Graphing the Win Ratio and its components over time. Statistics in medicine.
</p>
</li>
<li><p> Luo, X., Tian, H., Mohanty, S. and Tsai, W.Y., 2015. An alternative approach to confidence interval estimation for the win ratio statistic. Biometrics.
</p>
</li>
<li><p> Pocock, S.J., Ariti, C.A., Collier, T.J. and Wang, D., 2012. The win ratio: a new approach to the analysis of composite endpoints in clinical trials based on clinical priorities. European heart journal.
</p>
</li>
<li><p> Wang D, Pocock S., 2016. A win ratio approach to comparing continuous non-normal outcomes in clinical trials. Pharmaceutical Statistics.
</p>
</li>
<li><p> Wang, D., Zheng S., Cui, Y., He, N., Chen, T., Huang, B., 2023. Adjusted win ratio using inverse probability treatment weighting (IPTW) propensity score analysis. Journal of Biopharmaceutical Statistics.
</p>
</li>
<li><p> Zheng S, Wang D, Qiu J, Chen T, Gamalo M., 2023. A win ratio approach for comparing crossing survival curves in clinical trials. Journal of Biopharmaceutical Statistics.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
#### An example with time-to-event outcome.
head(data_tte)
head(Z_t_trt)

### CovIPCW adjustment for dependent censoring
res_tte_covipcw &lt;- win.stat(data = data_tte, ep_type = "tte", arm.name = c("A","B"), tau = 0.1,
Z_t_trt = Z_t_trt, Z_t_con = Z_t_con, priority = c(1:3), alpha = 0.05, digit = 3,
method = "covipcw", stratum.weight = "unstratified", pvalue = "two-sided")

#### An example with continuous outcome.
head(data_continuous)

res_continuous &lt;- win.stat(data = data_continuous, ep_type = "continuous", arm.name = c("A","B"),
tau = 0, priority = c(1:3), alpha=0.05, digit = 3, stratum.weight = "unstratified",
pvalue = "two-sided")

#### An example with binary outcome.
head(data_binary)

res_binary &lt;- win.stat(data = data_binary, ep_type = "binary", arm.name = c("A","B"),
priority = c(1:3), alpha=0.05, digit = 3, stratum.weight = "unstratified",
pvalue = "two-sided")

</code></pre>

<hr>
<h2 id='win.strategy.default'>
The Default Win Strategy Function.
</h2><span id='topic+win.strategy.default'></span>

<h3>Description</h3>

<p>An intermediate function to determine the win status for each pair based on the default win strategy. Specifically, one compares each subject in the treatment group with every subject in the control group to determine the win status.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>win.strategy.default(trt_con, priority, tau, np_direction)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="win.strategy.default_+3A_trt_con">trt_con</code></td>
<td>
<p>Given N_t subjects in the treatment group and N_c subjects in the control group, there are N_t*N_c pairs, each row represents a pair. The analysis dataset trt_con contains the following variables:
</p>

<dl>
<dt>stratum: </dt><dd><p>A vector for the stratum number of the unmatched pairs.</p>
</dd>
<dt>pid_trt: </dt><dd><p>A vector for the subject id of the individuals from the treatment group within each unmatched pair.</p>
</dd>
<dt>pid_con: </dt><dd><p>A vector for the subject id of the individuals from the control group within each unmatched pair.</p>
</dd>
<dt>Delta_j_trt: </dt><dd><p>A vector for the event status of the j-th endpoint (1=event, 0=censored) for the individuals from the treatment group in each unmatched pair. If the outcome type for the endpoint is continuous/binary, then the event status is 1 for all.</p>
</dd>
<dt>Delta_j_con: </dt><dd><p>A vector for the event status of the j-th endpoint (1=event, 0=censored) for the individuals from the control group in each unmatched pair. If the outcome type for the endpoint is continuous/binary, then the event status is 1 for all.</p>
</dd>
<dt>Y_j_trt: </dt><dd><p>A vector for the outcome of the j-th endpoint for the individuals from the treatment group in each unmatched pair. For a time-to-event outcome, it would be a vector of observed time-to-event observations.</p>
</dd>
<dt>Y_j_con: </dt><dd><p>A vector for the outcome of the j-th endpoint for the individuals from the control group in each unmatched pair. For a time-to-event outcome, it would be a vector of observed time-to-event observations.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="win.strategy.default_+3A_priority">priority</code></td>
<td>
<p>Importance order (from the most to the least important). For example, given three endpoints with the importance order as Endpoint 3, Endpoint 2, and Endpoint 1, input priority = c(3,2,1).</p>
</td></tr>
<tr><td><code id="win.strategy.default_+3A_tau">tau</code></td>
<td>
<p>A vector of numerical value for the magnitude of difference to determine win/loss/tie for each endpoint. Tau is applicable for TTE endpoints and continuous endpoints; tau is fixed as 0 for binary endpoints. Default is 0 for all endpoints.</p>
</td></tr>
<tr><td><code id="win.strategy.default_+3A_np_direction">np_direction</code></td>
<td>
<p>A vector of character for the direction to define a better result for each endpoint.
</p>

<dl>
<dt>&quot;larger&quot;: </dt><dd><p>The treatment group wins if min(T_trt, C_trt, C_con + tau) &gt; T_con + tau, for time-to-event outcomes; &quot;the larger value wins&quot; for continuous outcome, value 1 wins over the value 0 for binary outcome.</p>
</dd>
<dt>&quot;smaller&quot;: </dt><dd><p>The treatment group wins if min(T_trt, C_trt, C_con - tau) &lt; T_con - tau, for time-to-event outcomes; &quot;the smaller value wins&quot; for continuous outcome, value 0 wins over the value 1 for binary outcome.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>Users can define their own win strategy function and input the function with the argument &quot;win.strategy&quot; in the &quot;win.stat&quot; function.
</p>


<h3>Value</h3>

<table>
<tr><td><code>win_status</code></td>
<td>
<p>A data frame for the win status of each pair for each endpoint.</p>
</td></tr>
</table>

<hr>
<h2 id='Z_t_con'>
Covariate history in the control group.
</h2><span id='topic+Z_t_con'></span>

<h3>Description</h3>

<p>This is a simulated data example for the covariate history in the control group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("data_tte")</code></pre>


<h3>Format</h3>

<p>A data frame with 796 observations on the following 4 variables.
</p>

<dl>
<dt><code>id</code></dt><dd><p>A vector for the patient id.</p>
</dd>
<dt><code>time</code></dt><dd><p>A vector for the observed time of the covariate.</p>
</dd>
<dt><code>Z1</code></dt><dd><p>A vector for the observed value of the first covariate.</p>
</dd>
<dt><code>Z2</code></dt><dd><p>A vector for the observed value of the second covariate.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(data_tte)
str(Z_t_con)
</code></pre>

<hr>
<h2 id='Z_t_trt'>
Covariate history in the treatment group.
</h2><span id='topic+Z_t_trt'></span>

<h3>Description</h3>

<p>This is a simulated data example for the covariate history in the treatment group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("data_tte")</code></pre>


<h3>Format</h3>

<p>A data frame with 796 observations on the following 4 variables.
</p>

<dl>
<dt><code>id</code></dt><dd><p>A vector for the patient id.</p>
</dd>
<dt><code>time</code></dt><dd><p>A vector for the observed time of the covariate.</p>
</dd>
<dt><code>Z1</code></dt><dd><p>A vector for the observed value of the first covariate.</p>
</dd>
<dt><code>Z2</code></dt><dd><p>A vector for the observed value of the second covariate.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(data_tte)
str(Z_t_trt)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
