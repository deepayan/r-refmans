<!DOCTYPE html><html><head><title>Help for package elec</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {elec}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#audit.plan'><p>Audit Plans for CAST and Trinomial Methods</p></a></li>
<li><a href='#audit.totals.to.OS'><p>Converting total vote counts to Over Statements</p></a></li>
<li><a href='#AuditErrors'><p>Functions that Compute Error Levels Given Audit Data</p></a></li>
<li><a href='#CAST.audit'><p>Given audit data, compute p.values and all that.</p></a></li>
<li><a href='#CAST.calc.opt.cut'><p>Calculate Optimal CAST plan</p></a></li>
<li><a href='#CAST.calc.sample'><p>Construct a sample for auditing using CAST</p></a></li>
<li><a href='#CAST.sample'><p>Sample from the various strata according to the schedule set by 'ns'.</p>
Ignore all precincts that are known (i.e., have been previously audited).</a></li>
<li><a href='#compute.audit.errors'><p>Calculate the measured error in each of the audited precicnts.</p></a></li>
<li><a href='#compute.stark.t'><p>compute.stark.t</p></a></li>
<li><a href='#countVotes'><p>countVotes</p></a></li>
<li><a href='#do.audit'><p>do.audit</p></a></li>
<li><a href='#elec-package'><p>Statistical Election Audits Package</p></a></li>
<li><a href='#elec.data'><p>core election audit data structure</p></a></li>
<li><a href='#find.q'><p>find.q</p></a></li>
<li><a href='#find.stark.SRS.p'><p>find.stark.SRS.p</p></a></li>
<li><a href='#find.stratification'><p>find.stratification</p></a></li>
<li><a href='#fractionOfVotesBound'><p>Fraction of votes bound</p></a></li>
<li><a href='#is.elec.data'><p>Check if object is elec.data object</p></a></li>
<li><a href='#KM.audit'><p>KM Audit Calculator</p></a></li>
<li><a href='#KM.calc.sample'><p>Calculate sample size for KM-audit.</p></a></li>
<li><a href='#make.audit.from.Z'><p>Make a fake audit given specified error for simulations</p></a></li>
<li><a href='#make.cartoon'><p>Make the cartoon example from the CAST paper as a voter data</p>
matrix.</a></li>
<li><a href='#make.opt.packed.bad'><p>make.truth.opt.bad</p></a></li>
<li><a href='#make.random.truth'><p>making fake truth for electios</p></a></li>
<li><a href='#make.sample'><p>Generate fake election results for simulation studies</p></a></li>
<li><a href='#make.sample.from.totals'><p>Make sample from vote totals (for simulations)</p></a></li>
<li><a href='#make.truth'><p>Make baseline truth for simulations</p></a></li>
<li><a href='#marin'><p>Marin Measure B Reported Results</p></a></li>
<li><a href='#maximumMarginBound'><p>Election Audit Error Bound Functions</p></a></li>
<li><a href='#opt.sample.size'><p>KM Audit Sample Size Calc</p></a></li>
<li><a href='#print.audit.plan.KM'><p>Pretty print KM audit plan</p></a></li>
<li><a href='#santa.cruz'><p>Santa Cruz Election Data</p></a></li>
<li><a href='#santa.cruz.audit'><p>Santa Cruz Election Data</p></a></li>
<li><a href='#sim.race'><p>Simulate CAST audits to assess performance</p></a></li>
<li><a href='#simulateIt'><p>simulate KM audits</p></a></li>
<li><a href='#stark.test.Z'><p>Workhorse driver for stark.test</p></a></li>
<li><a href='#tri.audit.sim'><p>tri.audit.sim</p></a></li>
<li><a href='#tri.calc.sample'><p>Calculate needed sample size for election auditing using the</p>
Trinomial Bound</a></li>
<li><a href='#tri.sample'><p>Sample from List of Precincts PPEB</p></a></li>
<li><a href='#tri.sample.stats'><p>Utility function for tri.sample</p></a></li>
<li><a href='#trinomial.audit'><p>Conduct trinomial audit</p></a></li>
<li><a href='#trinomial.bound'><p>Auditing with the Trinomial Bound: trinomial.bound and trinomial.audit</p></a></li>
<li><a href='#truth.looker'><p>Looking at fake &ldquo;truths&rdquo; for election simulations</p></a></li>
<li><a href='#weight.function'><p>weight functions</p></a></li>
<li><a href='#yolo'><p>Yolo County, CA Election Data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Collection of Functions for Statistical Election Audits</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-04-23</td>
</tr>
<tr>
<td>Author:</td>
<td>Luke Miratrix</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Luke Mirarix &lt;lmiratrix@g.harvard.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>This is a (somewhat bizarre) collection of functions written to do
        various sorts of statistical election audits.  There are also
        functions to generate simulated voting data, including methods to simulation different types 
        of voting errors which allow for simulations for checking the characteristics of
        these methods.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-26 16:09:09 UTC; lmiratrix</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-26 22:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='audit.plan'>Audit Plans for CAST and Trinomial Methods</h2><span id='topic+audit.plan'></span><span id='topic+is.audit.plan'></span><span id='topic+print.audit.plan'></span><span id='topic+is.audit.plan.tri'></span><span id='topic+print.audit.plan.tri'></span>

<h3>Description</h3>

<p>An <code>audit.plan</code> is returned by CAST.calc.sample, containing details of
how to audit for a desired level of confidence.  It has a print method for
pretty output.
</p>
<p>The <code>audit.plan.tri</code>, similarly, is an object that holds information
about conduting a PPEB election audit, in particular an audit that will use
the trinomial bound to analyze resultant audit data.  It is what is returned
by the tri.calc.sample method.
</p>
<p>Theoretically, auditors will use the plan and go out and generate actual
audit data.  (You can fake it with simulations&ndash;see <a href="#topic+make.truth">make.truth</a>.)  The
audit data should be stored in a new data frame with new vote totals, or
overstatements, for the candidates in the audited precincts. To convert from
totals to overstatements, use <code><a href="#topic+audit.totals.to.OS">audit.totals.to.OS</a></code>.  You can
store that in a elec.data object under &ldquo;audit&rdquo;, or keep it seperate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.audit.plan(x)

## S3 method for class 'audit.plan'
print(x, ...)

is.audit.plan.tri(x)

## S3 method for class 'audit.plan.tri'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="audit.plan_+3A_x">x</code></td>
<td>
<p>object to check</p>
</td></tr>
<tr><td><code id="audit.plan_+3A_...">...</code></td>
<td>
<p>No extra options passed.</p>
</td></tr>
<tr><td><code id="audit.plan_+3A_audit.plan">audit.plan</code></td>
<td>
<p>to print.</p>
</td></tr>
<tr><td><code id="audit.plan_+3A_audit.plan.tri">audit.plan.tri</code></td>
<td>
<p>to print.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>is.audit.plan: TRUE if object is an audit.plan object.
</p>
<p>print: No return value; prints results.
</p>
<p>is.audit.plan.tri: TRUE if object is an audit.plan.tri object.
</p>
<p>print: No return value; prints results.
</p>


<h3>Author(s)</h3>

<p>Luke W. Miratrix
</p>


<h3>See Also</h3>

<p><a href="#topic+CAST.calc.sample">CAST.calc.sample</a> <a href="#topic+tri.calc.sample">tri.calc.sample</a>
</p>

<hr>
<h2 id='audit.totals.to.OS'>Converting total vote counts to Over Statements</h2><span id='topic+audit.totals.to.OS'></span>

<h3>Description</h3>

<p>This utility function takes a collection of total votes from an audit and
subtracts the originally reported totals from them to give overstatement
errors (i.e., how many votes more than actual a candidate had).  I.e., the
overstatement error is REPORTED - ACTUAL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>audit.totals.to.OS(Z, audit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="audit.totals.to.OS_+3A_z">Z</code></td>
<td>
<p>Elec.data object holding the originally reported results</p>
</td></tr>
<tr><td><code id="audit.totals.to.OS_+3A_audit">audit</code></td>
<td>
<p>A data.frame with one column per candidate that holds the
totals from the audit.  Each row corresponds to a precinct.  Object needs a
PID column with precinct ids that match the ones in Z.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Make sure the audit's PID column is a character vector and not a factor.  If
needed, convert via <code>audit\$PID = as.character(audit\$PID)</code>.
</p>


<h3>Value</h3>

<p>A new data.frame with overstatement errors.
</p>


<h3>Author(s)</h3>

<p>Luke W. Miratrix
</p>


<h3>See Also</h3>

<p>See <a href="#topic+AuditErrors">AuditErrors</a> for different ways of summarizing audit
errors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Generate a fake race, a fake audit, and then compute overstatements
Z = make.sample(0.08, 150, per.winner=0.4, R=2.01)
Z
Zb = make.ok.truth(Z, num.off=150, amount.off=5)
Zb
aud = Zb$V[ sample(1:Zb$N, 10), ]
aud
audit.totals.to.OS(Z, aud )

</code></pre>

<hr>
<h2 id='AuditErrors'>Functions that Compute Error Levels Given Audit Data</h2><span id='topic+AuditErrors'></span><span id='topic+calc.overstatement.e_p'></span><span id='topic+calc.pairwise.e_p'></span>

<h3>Description</h3>

<p>Calculate the error amounts for all precincts in Z that were audited from
the audit data, given as overstatement errors for all candidates.
</p>
<p>compute.audit.errors uses the calc functions and the weight functions in a
1-2 combination.
</p>
<p>calc.pairwise.e\_p() is often used with an err.override for simulation
studies and whatnot to see what a fixed vote impact would have on taints for
trinomial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc.overstatement.e_p(Z)

calc.pairwise.e_p(Z, audit = NULL, err.override = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AuditErrors_+3A_z">Z</code></td>
<td>
<p>elec.data object</p>
</td></tr>
<tr><td><code id="AuditErrors_+3A_audit">audit</code></td>
<td>
<p>The audit object, if it is not in the Z object, or if some
other object other than the one in the Z object is desired to be considered
as the audit object.  Used by the simulation functions to generate errors
for some fixed amount of error in conjunction with the err.override.</p>
</td></tr>
<tr><td><code id="AuditErrors_+3A_err.override">err.override</code></td>
<td>
<p>Assume a baserate of this amount of error everywhere,
ignoring audit data. If non-null, use this as the found error in votes
rather than the actual errors found in the audit.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>compute.audit.errors returns a new audit table from Z with two new
columns, err and err.weighted, corresponding to the errors found in each
audited precinct before and after the weight function has been applied to
them.
</p>
<p>calc.overstatement.e_p: Vector (of length of audited precincts) of found errors by precinct.
</p>


<h3>Note</h3>

<p>Z must have an audit component, or one must be passed, for this
function to make sense!  Remember that audit objects have overstatements,
NOT total votes for candidates.  With err.override being set this is less
relevant as the actual votes are usually ignored.
</p>


<h3>Author(s)</h3>

<p>Luke W. Miratrix
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+audit.totals.to.OS">audit.totals.to.OS</a></code> for a utility function that
handles processing of audit data.
</p>

<hr>
<h2 id='CAST.audit'>Given audit data, compute p.values and all that.</h2><span id='topic+CAST.audit'></span>

<h3>Description</h3>

<p>Given audit data, compute p.values and all that.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CAST.audit(Z, audit = NULL, plan = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CAST.audit_+3A_z">Z</code></td>
<td>
<p>elec.data object (voter matrix)</p>
</td></tr>
<tr><td><code id="CAST.audit_+3A_audit">audit</code></td>
<td>
<p>A data.matrix holding the audit data, if the Z object
does not have one, or if it is desirable to override it.  If both
the Z object has an audit object and audit is not null, it will
use this parameter and ignore the one in Z.</p>
</td></tr>
<tr><td><code id="CAST.audit_+3A_plan">plan</code></td>
<td>
<p>An audit.plan object that the audit was conducted
under.</p>
</td></tr>
<tr><td><code id="CAST.audit_+3A_...">...</code></td>
<td>
<p>Passed to CAST.calc.sample if plan is null and needs to
be regenerated.</p>
</td></tr>
</table>

<hr>
<h2 id='CAST.calc.opt.cut'>Calculate Optimal CAST plan</h2><span id='topic+CAST.calc.opt.cut'></span>

<h3>Description</h3>

<p>With CAST, it is sometimes advantageous to set aside small precincts and
assume they are entirely in error so as to reduce the total number of
precincts in the pool that we sample from.  This trade-off can increase the
power of the audit or, in other terms, allow us to sample fewer precincts as
the chance of nabbing the large, dangerous ones is larger.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CAST.calc.opt.cut(Z, beta = 0.9, stages = 2, t = 3, plot = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CAST.calc.opt.cut_+3A_z">Z</code></td>
<td>
<p>The elec.data object</p>
</td></tr>
<tr><td><code id="CAST.calc.opt.cut_+3A_beta">beta</code></td>
<td>
<p>1-<code>beta</code> is the risk of the audit failing to notice the
need to go to a full manual count if it should.</p>
</td></tr>
<tr><td><code id="CAST.calc.opt.cut_+3A_stages">stages</code></td>
<td>
<p>Number of stages in the audit.</p>
</td></tr>
<tr><td><code id="CAST.calc.opt.cut_+3A_t">t</code></td>
<td>
<p>The allowed vote swing that is not considered a material error.</p>
</td></tr>
<tr><td><code id="CAST.calc.opt.cut_+3A_plot">plot</code></td>
<td>
<p>TRUE/FALSE.  Plot the trade-off curve.</p>
</td></tr>
<tr><td><code id="CAST.calc.opt.cut_+3A_...">...</code></td>
<td>
<p>Extra arguments to the plot command.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Of all cuts that produce the smallest <code>n</code>, it returns the smallest cut
(since sometimes multiple cut-offs lead to the same sample size).
</p>
<p>This function also plots the trade-off of sample size for a specific cut, if
the plot flag is TRUE.
</p>
<p>This function iteratively passes increasing values of <code>small.cut</code> to
<code><a href="#topic+CAST.calc.sample">CAST.calc.sample</a></code> and examines the resulting <code>n</code>.
</p>


<h3>Value</h3>

<p>Returns a list.  </p>
<table>
<tr><td><code>cut</code></td>
<td>
<p> Size of the optimal cut.  All precincts
with an error smaller than or equal to cut would not be audited, and instead
be assumed to be in full error. </p>
</td></tr> <tr><td><code>n</code></td>
<td>
<p> Corresponding needed sample size
given that cut. </p>
</td></tr> <tr><td><code>q</code></td>
<td>
<p> The number of tainted precincts that would be
needed to throw the election, beyond the ones set aside due to being smaller
than <code>cut</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Luke W. Miratrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

        ## Find optimial cut for  determining which small precincts that
        ## we would set aside and not audit in Santa Cruz
        data(santa.cruz)
        Z = elec.data( santa.cruz, C.names=c("leopold","danner") )

        CAST.calc.opt.cut( Z, beta=0.75, stages=1, t=5, plot=TRUE )

</code></pre>

<hr>
<h2 id='CAST.calc.sample'>Construct a sample for auditing using CAST</h2><span id='topic+CAST.calc.sample'></span>

<h3>Description</h3>

<p>Collection of functions for planning and evaluating results of a CAST
election audit.  CAST is a system devised by Dr. Philip B., Stark, UC
Berkeley Department of Statistics.
</p>
<p><code>CAST.calc.sample</code> determines what size SRS sample should be drawn to
have a reasonable chance of certification if the election does not have
substantial error.  It returns an <code>audit.plan</code>. <code>CAST.sample</code>
takes the audit.plan and draws a sample to audit. <code>CAST.audit</code> takes
audit data (presumably from the audit of the sample drawn in previous step)
and analyzes it.
</p>
<p>Make an audit.plan given reported results for an election.  It gives back what to
do for a single stage.  If stages is &gt; 1, then it adjusts beta appropriately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CAST.calc.sample(
  Z,
  beta = 0.9,
  stages = 1,
  t = 3,
  as.taint = FALSE,
  small.cut = NULL,
  strata = NULL,
  drop = NULL,
  method = c("select", "binomial", "hypergeometric"),
  calc.e.max = TRUE,
  bound.function = maximumMarginBound
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CAST.calc.sample_+3A_z">Z</code></td>
<td>
<p>elec.data object (voter matrix)</p>
</td></tr>
<tr><td><code id="CAST.calc.sample_+3A_beta">beta</code></td>
<td>
<p>the confidence level desired - overall chance of correctly escalating a bad election to full recount</p>
</td></tr>
<tr><td><code id="CAST.calc.sample_+3A_stages">stages</code></td>
<td>
<p>number of auditing stages. Each stage will have the same
confidence level, determined by a function of beta.  A value of 1 is a
single-stage audit.</p>
</td></tr>
<tr><td><code id="CAST.calc.sample_+3A_t">t</code></td>
<td>
<p>The maximum amount of error, in votes, expected. Threshold error for escalation &ndash; if &gt;= 1 then number of votes, otherwise
fraction of margin.</p>
</td></tr>
<tr><td><code id="CAST.calc.sample_+3A_as.taint">as.taint</code></td>
<td>
<p>Boolean value.  TRUE means interpret $t$ as a taint in
$[0,1]$ by batch (so the threshold error will be batch-specific).  FALSE
means interpret $t$ as a proportion of the margin or as number of votes (as
described above).</p>
</td></tr>
<tr><td><code id="CAST.calc.sample_+3A_small.cut">small.cut</code></td>
<td>
<p>Cut-off in votes&ndash;any precincts with potential error
smaller than this value will not be audited and be assumed to be worst case
error.</p>
</td></tr>
<tr><td><code id="CAST.calc.sample_+3A_strata">strata</code></td>
<td>
<p>Name of the stratification column of Z.  Not needed if audit
plan also being passed in case of CAST.sample. NULL means single strata.</p>
</td></tr>
<tr><td><code id="CAST.calc.sample_+3A_drop">drop</code></td>
<td>
<p>Vector of precincts to drop for whatever reasons (such as they
are already known).  This is a vector of TRUE/FALSE.</p>
</td></tr>
<tr><td><code id="CAST.calc.sample_+3A_method">method</code></td>
<td>
<p>Method of calculation.</p>
</td></tr>
<tr><td><code id="CAST.calc.sample_+3A_calc.e.max">calc.e.max</code></td>
<td>
<p>Should the e.max be taken as given, or recalculated?</p>
</td></tr>
<tr><td><code id="CAST.calc.sample_+3A_bound.function">bound.function</code></td>
<td>
<p>What function should be used to calculate worst-case
potential error of precincts.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Luke W. Miratrix
</p>


<h3>References</h3>

<p>Philip B. Stark. CAST: Canvass Audits by Sampling and Testing.
University of California at Berkeley Department of Statistics, 2009. URL:
http://statistics.berkeley.edu/~stark/Preprints/cast09.pdf.  Also see
http://www.stat.berkeley.edu/~stark/Vote/index.htm for other relevant
information.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+elec.data">elec.data</a></code> for a description of the object that holds
precinct-level vote records.  See <code><a href="#topic+tri.calc.sample">tri.calc.sample</a></code> for a PPEB
auditing method.  See <code><a href="#topic+CAST.calc.opt.cut">CAST.calc.opt.cut</a></code> for calculating
optimal cut-offs to keep needed sample size low. Also see
<code><a href="#topic+sim.race">sim.race</a></code>, <code><a href="#topic+do.audit">do.audit</a></code>, <code><a href="#topic+make.sample">make.sample</a></code>,
and <code><a href="#topic+make.truth">make.truth</a></code> for doing simulation studies of this method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
        ## Make an example cartoon race (from Stark paper)
	Z = make.cartoon()

        ## What should we do?
	samp.info = CAST.calc.sample( Z )
	samp.info

        ## Draw a sample.
	samp = CAST.sample( Z, samp.info$ns )
        samp

        ## Analyze what a CAST audit of santa cruz would entail
        data(santa.cruz)
        Z = elec.data( santa.cruz, C.names=c("leopold","danner") )
        CAST.calc.sample( Z, beta=0.75, stages=1, t=5, small.cut=60)
</code></pre>

<hr>
<h2 id='CAST.sample'>Sample from the various strata according to the schedule set by 'ns'.
Ignore all precincts that are known (i.e., have been previously audited).</h2><span id='topic+CAST.sample'></span>

<h3>Description</h3>

<p>Sample from the various strata according to the schedule set by 'ns'.
Ignore all precincts that are known (i.e., have been previously audited).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CAST.sample(
  Z,
  ns,
  strata = NULL,
  seed = NULL,
  print.trail = FALSE,
  known = "known"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CAST.sample_+3A_z">Z</code></td>
<td>
<p>elec.data object (voter matrix)</p>
</td></tr>
<tr><td><code id="CAST.sample_+3A_ns">ns</code></td>
<td>
<p>EITHER an audit.plan or a vector of sample sizes for the strata.
Names must correspond ot the names of the strata.  If ns is an audit plan,
then the strata variable should not be passed as well.</p>
</td></tr>
<tr><td><code id="CAST.sample_+3A_strata">strata</code></td>
<td>
<p>Name of the stratification column of Z.  Not needed if audit
plan also being passed in case of CAST.sample. NULL means single strata.</p>
</td></tr>
<tr><td><code id="CAST.sample_+3A_seed">seed</code></td>
<td>
<p>Seed to use&ndash;for reproducability.</p>
</td></tr>
<tr><td><code id="CAST.sample_+3A_print.trail">print.trail</code></td>
<td>
<p>Print out diagnostics.</p>
</td></tr>
<tr><td><code id="CAST.sample_+3A_known">known</code></td>
<td>
<p>The column of known precincts that should thus not be selected.
Similar to &quot;drop&quot;, above.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>: List of precincts to be audited.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Z = make.cartoon()
samp.info = CAST.calc.sample( Z )
samp.info
samp = CAST.sample( Z, samp.info )

</code></pre>

<hr>
<h2 id='compute.audit.errors'>Calculate the measured error in each of the audited precicnts.</h2><span id='topic+compute.audit.errors'></span>

<h3>Description</h3>

<p>Calculate the measured error in each of the audited precicnts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.audit.errors(
  Z,
  audit = NULL,
  calc.e_p = calc.pairwise.e_p,
  w_p = weight.function("no.weight"),
  bound.col = "tot.votes",
  err.override = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.audit.errors_+3A_z">Z</code></td>
<td>
<p>Elec.data object holding the originally reported results</p>
</td></tr>
<tr><td><code id="compute.audit.errors_+3A_audit">audit</code></td>
<td>
<p>A data.frame with one column per candidate that holds
the totals from the audit.  Each row corresponds to a precinct.
Object needs a PID column with precinct ids that match the ones
in Z.</p>
</td></tr>
<tr><td><code id="compute.audit.errors_+3A_calc.e_p">calc.e_p</code></td>
<td>
<p>Calculate e\_p or take as given.</p>
</td></tr>
<tr><td><code id="compute.audit.errors_+3A_w_p">w_p</code></td>
<td>
<p>The weight function to use to reweight the errors of
precincts.</p>
</td></tr>
<tr><td><code id="compute.audit.errors_+3A_bound.col">bound.col</code></td>
<td>
<p>This is the vector (in audit) containing the
maximum number of votes possible in the various precincts.</p>
</td></tr>
<tr><td><code id="compute.audit.errors_+3A_err.override">err.override</code></td>
<td>
<p>If non-null, use this as the found error in
votes rather than the actual errors found in the audit.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Orig audit table from Z with two new columns, err and
err.weighted, corresponding to the errors found in each audited
precinct before and after the weight function has been applied to
them.
</p>

<hr>
<h2 id='compute.stark.t'>compute.stark.t</h2><span id='topic+compute.stark.t'></span>

<h3>Description</h3>

<p>Compute the test statistic for election audits, essentially the largest
error found in the audit, as measured by the passed functions and methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.stark.t(
  Z,
  bound.col,
  calc.e_p = calc.pairwise.e_p,
  w_p = weight.function("no.weight"),
  err.override = NULL,
  return.revised.audit = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.stark.t_+3A_z">Z</code></td>
<td>
<p>If it already has an audit table with err and err.weighted then it
will use those errors, otherwise it will compute them with compute.stark.err</p>
</td></tr>
<tr><td><code id="compute.stark.t_+3A_bound.col">bound.col</code></td>
<td>
<p>This is the vector containing the maximum number of votes
possible in the various precincts.</p>
</td></tr>
<tr><td><code id="compute.stark.t_+3A_calc.e_p">calc.e_p</code></td>
<td>
<p>Function to compute e_p.  Default is calc.pairwise.e_p.</p>
</td></tr>
<tr><td><code id="compute.stark.t_+3A_w_p">w_p</code></td>
<td>
<p>The weight function to be applied to the precinct error.</p>
</td></tr>
<tr><td><code id="compute.stark.t_+3A_err.override">err.override</code></td>
<td>
<p>If non-null, use this as the found error in votes rather
than the actual errors found in the audit.</p>
</td></tr>
<tr><td><code id="compute.stark.t_+3A_return.revised.audit">return.revised.audit</code></td>
<td>
<p>Return the updated audit frame with the error
and weighted errors calculated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an older method that other methods sometime use&mdash;it is probably
best ignored unless you have a good reason not to.
</p>


<h3>Value</h3>

<p>The test statistic, i.e. the maximum found error in the audit
sample, as computed by calc.e\_p and weighted by w\_p.
</p>


<h3>Author(s)</h3>

<p>Luke W. Miratrix
</p>


<h3>See Also</h3>

<p><code><a href="#topic+find.q">find.q</a></code> <code><a href="#topic+stark.test">stark.test</a></code>
</p>

<hr>
<h2 id='countVotes'>countVotes</h2><span id='topic+countVotes'></span>

<h3>Description</h3>

<p>Given a elec.data object, count the votes as reported and determine
winner(s) and loser(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countVotes(Z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="countVotes_+3A_z">Z</code></td>
<td>
<p>the elec.data object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated 'Z' matrix with the total votes as components inside it.
</p>


<h3>Author(s)</h3>

<p>Luke W. Miratrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  Z = make.cartoon()
  ## Take away 20 percent of C1's votes.
  Z$V$C1 = Z$V$C1 * 0.8
  ## Count again to find winner.
  Z = countVotes(Z)
  Z

</code></pre>

<hr>
<h2 id='do.audit'>do.audit</h2><span id='topic+do.audit'></span>

<h3>Description</h3>

<p>Given a list of precincts to audit, the truth (as an elec.data object), and
the original votes (also as an elec.data object), do a simulated CAST audit
and return the audit frame as a result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do.audit(Z, truth, audit.names, ns = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="do.audit_+3A_z">Z</code></td>
<td>
<p>elec.data object</p>
</td></tr>
<tr><td><code id="do.audit_+3A_truth">truth</code></td>
<td>
<p>another elec.data object&ndash;this one's vote counts are considered
&quot;true&quot;</p>
</td></tr>
<tr><td><code id="do.audit_+3A_audit.names">audit.names</code></td>
<td>
<p>name of precincts to audit.  Correspond to rownames of
the Z and truth elec.data objects.</p>
</td></tr>
<tr><td><code id="do.audit_+3A_ns">ns</code></td>
<td>
<p>List of sample sizes for strata. If this is passed, this method
will randomly select the precincts to audit.  In this case audit.names
should be set to NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given the reported vote table, Z, and the actual truth (simulated) (a Z
matrix with same precincts), and a list of precincts to audit, do the audit.
If audit.names is null and the ns is not null, it will sample from precincts
via CAST.sample automatically.
</p>


<h3>Value</h3>

<p>Overstatments for each candidate for each precinct.
</p>


<h3>Author(s)</h3>

<p>Luke W. Miratrix
</p>


<h3>See Also</h3>

<p><a href="#topic+CAST.audit">CAST.audit</a> for how to run the CAST auditing method.  See
<code><a href="#topic+make.sample">make.sample</a></code> and <code><a href="#topic+make.truth">make.truth</a></code> for generating fake
situations for doing simulation studies of the CAST method.  See
<a href="#topic+AuditErrors">AuditErrors</a> and <code><a href="#topic+audit.totals.to.OS">audit.totals.to.OS</a></code> for utility
functions handing processing of audit data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Z = make.cartoon(n=200)
truth = make.truth.opt.bad(Z, t=0, bound="WPM")
samp.info=CAST.calc.sample(Z, beta=0.75, stages=1, t=5 )
audit.names = CAST.sample( Z, samp.info )
do.audit( Z, truth, audit.names )


</code></pre>

<hr>
<h2 id='elec-package'>Statistical Election Audits Package</h2><span id='topic+elec-package'></span><span id='topic+elec'></span>

<h3>Description</h3>

<p>This is a collection of functions written to do various sorts of statistical
election audits.  There are also functions to generate simulated voting
data, and simulated &ldquo;truth&rdquo; so as to do simulations to check
charactaristics of these methods.  The package includes two data sets
consisting of actual reported voting results for races held November, 2008,
in California.  It also includes actual audit date for one of these races.
</p>

<table>
<tr>
 <td style="text-align: left;"> Package: </td><td style="text-align: left;"> elec</td>
</tr>
<tr>
 <td style="text-align: left;"> Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;"> Version: </td><td style="text-align: left;">
0.1</td>
</tr>
<tr>
 <td style="text-align: left;"> Date: </td><td style="text-align: left;"> 2009-01-14</td>
</tr>
<tr>
 <td style="text-align: left;"> License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;"> LazyLoad: </td><td style="text-align: left;">
yes</td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>

<p>There are three general audit styles implemented in this package.  For each
style there are two main computational tasks provided: estimate the needed
sample size and expected workload, and calculate $P$-values for a given
audit result.  The three methods are CAST (see
<code><a href="#topic+CAST.calc.sample">CAST.calc.sample</a></code> and <code><a href="#topic+CAST.audit">CAST.audit</a></code>, the Trinomial Bound
(see <code><a href="#topic+tri.calc.sample">tri.calc.sample</a></code> and <code><a href="#topic+trinomial.audit">trinomial.audit</a></code>), and the
Kaplan-Markov (KM) Bound (see <code><a href="#topic+KM.calc.sample">KM.calc.sample</a></code> and
<code><a href="#topic+KM.audit">KM.audit</a></code>).
</p>
<p>The examples primarily use a data set included in the package,
<code><a href="#topic+santa.cruz">santa.cruz</a></code> and <code><a href="#topic+santa.cruz.audit">santa.cruz.audit</a></code>, which holds the
ballot counts for a Santa Cruz, CA race that we audited using these methods.
See <code><a href="#topic+trinomial.bound">trinomial.bound</a></code> for how these data were analyzed.  The
<code><a href="#topic+yolo">yolo</a></code> data set holds precinct level counts for a race in Yolo
county.
</p>
<p>There are also many functions allowing for construction of new audit methods
and simulations.  This includes methods that generate fake race data that
can be used for computational simulations to assess the efficay of different
auditing approaches (see, e.g., <code><a href="#topic+make.sample">make.sample</a></code> and
<code><a href="#topic+make.truth">make.truth</a></code>).
</p>
<p>The package grew out of an earlier, disorganized package that implemented
general routines for election auditing.  Pieces of this package are used by
the aforementioned cleaner methods, but all the individual functions are
still there for specific uses, such as making different tests.  Start with
<a href="#topic+stark.test">stark.test</a>, which has an index of these pieces in its &ldquo;see also&rdquo;
section.
</p>
<p>If you find yourself confused, please contact the maintainer, L. Miratrix,
for help.  This will help improve the clarity of the package a great deal.
</p>


<h3>Author(s)</h3>

<p>Luke W. Miratrix
</p>
<p>Maintainer: Luke W. Miratrix &lt;luke@vzvz.org&gt;
</p>


<h3>References</h3>

<p>CAST and KM were developed by Philip B. Stark.  The Trinomial
bound was developed by Luke W. Miratrix and Philip B. Stark.
</p>
<p>For general papers on election auditing see the list at
http://www.stat.berkeley.edu/~stark/Vote/index.htm.
</p>
<p>In particular, for the trinomial bound, see Luke W. Miratrix and Philip B.
Stark. (2009) Election Audits using a Trinomial Bound (in press).
</p>
<p>For the KM bound see Stark, P.B., 2009. Risk-limiting post-election audits:
P-values from common probability inequalities.
</p>
<p>For an overview of the races and the methods, see Joseph Lorenzo Hall,
Philip B. Stark, Luke W. Miratrix, Elaine Ginnold, Freddie Oakley, Tom
Stanionis, and Gail Pellerin. (2009) Implementing Risk-Limiting Audits in
California.
</p>

<hr>
<h2 id='elec.data'>core election audit data structure</h2><span id='topic+elec.data'></span><span id='topic+print.elec.data'></span>

<h3>Description</h3>

<p>Makes an object (often called a &lsquo;Z&rsquo; object in this documentation) that holds
all the vote totals, etc., as well as some precomputed information such as
vote margins between candidates, the theoretical winners, and so on.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elec.data(
  V,
  C.names = names(V)[2:length(V)],
  f = 1,
  audit = NULL,
  pool = TRUE,
  tot.votes.col = "tot.votes",
  PID.col = "PID"
)

## S3 method for class 'elec.data'
print(x, n = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elec.data_+3A_v">V</code></td>
<td>
<p>Voter matrix OR 2-element list with Voter Matrix followed by
Candidate names</p>
</td></tr>
<tr><td><code id="elec.data_+3A_c.names">C.names</code></td>
<td>
<p>List of candidate names.  Also names of columns in V</p>
</td></tr>
<tr><td><code id="elec.data_+3A_f">f</code></td>
<td>
<p>Number of winners</p>
</td></tr>
<tr><td><code id="elec.data_+3A_audit">audit</code></td>
<td>
<p>The audit data&mdash;must have columns that match C.names.  Columns
are overstatements of votes found for those candidates.</p>
</td></tr>
<tr><td><code id="elec.data_+3A_pool">pool</code></td>
<td>
<p>Combine small candidates into single pseudo-candidates to
increase power</p>
</td></tr>
<tr><td><code id="elec.data_+3A_tot.votes.col">tot.votes.col</code></td>
<td>
<p>Name of column that has the total votes for the
precincts.</p>
</td></tr>
<tr><td><code id="elec.data_+3A_pid.col">PID.col</code></td>
<td>
<p>Name of column that identifies unique PIDs for precincts.</p>
</td></tr>
<tr><td><code id="elec.data_+3A_x">x</code></td>
<td>
<p>For print() and is.elec.data(). An elec.data object</p>
</td></tr>
<tr><td><code id="elec.data_+3A_n">n</code></td>
<td>
<p>Number to print</p>
</td></tr>
<tr><td><code id="elec.data_+3A_...">...</code></td>
<td>
<p>The collection of arguments that are passed directly to
elec.data, or (in the case of print), unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>elec.data</code> does some cleaning and renaming of the passed data
structure.  In particular it will rename the tot.votes column to &quot;tot.votes&quot;
if it is not that name already.
</p>


<h3>Value</h3>

<p>A &ldquo;elec.data&rdquo; data structure.  Note: Will add PID (precinct ID) column if
no PID provided (and generate unique PIDs).  It will rename the PID column
to PID.  Also, rownames are always PIDs (so indexing by PID works).
</p>
<p>print: No return value; prints results.
</p>


<h3>Author(s)</h3>

<p>Luke W. Miratrix
</p>


<h3>See Also</h3>

<p>See <a href="#topic+CAST.audit">CAST.audit</a> for the CAST method.  See
<code><a href="#topic+tri.calc.sample">tri.calc.sample</a></code> for the trinomial bound method.  See
<code><a href="#topic+countVotes">countVotes</a></code> for counting the votes listed in Z.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(santa.cruz)
elec.data( santa.cruz, C.names=c("danner","leopold") )

</code></pre>

<hr>
<h2 id='find.q'>find.q</h2><span id='topic+find.q'></span>

<h3>Description</h3>

<p>Find q, the minimum number of precints with w\_p's greater than given t.stat
that can hold an entire election shift in them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.q(
  V,
  t.stat,
  bound.col,
  M,
  threshold = 1,
  w_p = weight.function("no.weight"),
  drop = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find.q_+3A_v">V</code></td>
<td>
<p>The data.frame of votes&ndash;the subwing of a elec.data object,
usually.</p>
</td></tr>
<tr><td><code id="find.q_+3A_t.stat">t.stat</code></td>
<td>
<p>The worst error found in the audit (weighted, etc.)</p>
</td></tr>
<tr><td><code id="find.q_+3A_bound.col">bound.col</code></td>
<td>
<p>The name of the column in V to be used for the passed size
(max number of votes, total votes, incl undervotes, etc.) to the error
function.</p>
</td></tr>
<tr><td><code id="find.q_+3A_m">M</code></td>
<td>
<p>The margin to close.  Usually 1 for proportional.  Can be less if
error from other sources is assumed.</p>
</td></tr>
<tr><td><code id="find.q_+3A_threshold">threshold</code></td>
<td>
<p>The total amount of error to pack in the set of tainted
precincts</p>
</td></tr>
<tr><td><code id="find.q_+3A_w_p">w_p</code></td>
<td>
<p>The weight function for errors.</p>
</td></tr>
<tr><td><code id="find.q_+3A_drop">drop</code></td>
<td>
<p>Drop precincts with this column having a &quot;true&quot; value&ndash;they are
previously audited or otherwise known, and thus can't hold error.  Can also
pass a logical T/F vector of the length of nrow(V)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This number is behind the SRS methods such as CAST.  If we know how many
precincts, at minimum, would have to hold substantial error in order to have
the reported outcome be wrong, we can compute the chance of finding at least
one such precinct given a SRS draw of size n.
</p>
<p>Find the number of precints that need to have &quot;large taint&quot; in order to flip
the election.  This is, essentially, finding a collection of precints such
that the max error (e.max) plus the background error (the w\_p-inverse of
the t.stat) for the rest of the precints is greater than the margin (or 1 if
done by proportions).
</p>


<h3>Value</h3>

<p>integer, number of badly tainted precints needed to hold 'threshold'
error
</p>


<h3>Author(s)</h3>

<p>Luke W. Miratrix
</p>

<hr>
<h2 id='find.stark.SRS.p'>find.stark.SRS.p</h2><span id='topic+find.stark.SRS.p'></span>

<h3>Description</h3>

<p>Find the p-value for a given q, n, and N.  Helper function for a simple
hypergeometric calculaton&ndash;see reports.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.stark.SRS.p(N, n, q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find.stark.SRS.p_+3A_n">N</code></td>
<td>
<p>total number of precints</p>
</td></tr>
<tr><td><code id="find.stark.SRS.p_+3A_n">n</code></td>
<td>
<p>total number of audited precints (must be less than N)</p>
</td></tr>
<tr><td><code id="find.stark.SRS.p_+3A_q">q</code></td>
<td>
<p>min number of precints that could hold taint to flip election</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Chance that 1 or more of the q 'bad' things will be seen in a size n
SRS draw from the N sized bucket.
</p>


<h3>Author(s)</h3>

<p>Luke W. Miratrix
</p>

<hr>
<h2 id='find.stratification'>find.stratification</h2><span id='topic+find.stratification'></span>

<h3>Description</h3>

<p>Find how audit covered the strata for a given table of votes and audits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.stratification(D, aud, strat.col)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find.stratification_+3A_d">D</code></td>
<td>
<p>Table of votes</p>
</td></tr>
<tr><td><code id="find.stratification_+3A_aud">aud</code></td>
<td>
<p>Table of audit data</p>
</td></tr>
<tr><td><code id="find.stratification_+3A_strat.col">strat.col</code></td>
<td>
<p>The column to use that identifies the stratification levels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Table of strata. For each stratum (row) the table has the name of
the stratam, the number of precincts in the stratum, the number of audited
precincts and percent of precincts audited.
</p>


<h3>Author(s)</h3>

<p>Luke W. Miratrix
</p>

<hr>
<h2 id='fractionOfVotesBound'>Fraction of votes bound</h2><span id='topic+fractionOfVotesBound'></span>

<h3>Description</h3>

<p>WPM.  The maximum error of the unit is a fixed
percentage of the total votes cast in the unit.  Typically the 20% WPM is
used&ndash;meaning a swing of 40% is the largest error possible as 20% of the
votes go from the winner to the loser.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fractionOfVotesBound(Z, frac = 0.4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fractionOfVotesBound_+3A_z">Z</code></td>
<td>
<p>The elec.data object.</p>
</td></tr>
<tr><td><code id="fractionOfVotesBound_+3A_frac">frac</code></td>
<td>
<p>Fraction of total votes that could be a winner
overstatement/loser understatement.  So if the worst-case is a
20% flip then enter 0.4</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>maximumMarginBound
</p>

<hr>
<h2 id='is.elec.data'>Check if object is elec.data object</h2><span id='topic+is.elec.data'></span>

<h3>Description</h3>

<p>Check if object is elec.data object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.elec.data(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.elec.data_+3A_x">x</code></td>
<td>
<p>object to test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>is.elec.data: TRUE if object is an elec.data object.
</p>

<hr>
<h2 id='KM.audit'>KM Audit Calculator</h2><span id='topic+KM.audit'></span>

<h3>Description</h3>

<p>Do a KM audit given a specified list of audited batches for a specified
election.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KM.audit(
  data,
  U,
  Z,
  alpha = 0.25,
  plot = FALSE,
  debug = FALSE,
  return.Ps = FALSE,
  truncate.Ps = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KM.audit_+3A_data">data</code></td>
<td>
<p>Data frame holding audit data with taint and tot.votes as two
columns.</p>
</td></tr>
<tr><td><code id="KM.audit_+3A_u">U</code></td>
<td>
<p>Maximum total error bound (sum of e.max for all batches in race).</p>
</td></tr>
<tr><td><code id="KM.audit_+3A_z">Z</code></td>
<td>
<p>elec.data object for the race&mdash;the original reported results.</p>
</td></tr>
<tr><td><code id="KM.audit_+3A_alpha">alpha</code></td>
<td>
<p>Risk.</p>
</td></tr>
<tr><td><code id="KM.audit_+3A_plot">plot</code></td>
<td>
<p>Plot the audit?</p>
</td></tr>
<tr><td><code id="KM.audit_+3A_debug">debug</code></td>
<td>
<p>Print debugging info</p>
</td></tr>
<tr><td><code id="KM.audit_+3A_return.ps">return.Ps</code></td>
<td>
<p>Return the stepwise P-values</p>
</td></tr>
<tr><td><code id="KM.audit_+3A_truncate.ps">truncate.Ps</code></td>
<td>
<p>Return the stepwise P-values only up to the audit stop
point.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This will do a single-stage KM audit as a consequence of doing the stepwise
version (since the single-stage is the same as the stepwise up to the number
of batches audited).
</p>
<p>WARNING: This function is not fully debugged!
</p>


<h3>Value</h3>

<p>List of various things, including final p-value.
</p>


<h3>Author(s)</h3>

<p>Miratrix
</p>


<h3>References</h3>

<p>Stark, Miratrix
</p>

<hr>
<h2 id='KM.calc.sample'>Calculate sample size for KM-audit.</h2><span id='topic+KM.calc.sample'></span>

<h3>Description</h3>

<p>Calculate the size of a sample needed to certify a correct election if a KM
audit is planned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KM.calc.sample(Z, beta = 0.75, taint = 0, bound = c("e.plus", "WPM", "passed"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KM.calc.sample_+3A_z">Z</code></td>
<td>
<p>elec.data object</p>
</td></tr>
<tr><td><code id="KM.calc.sample_+3A_beta">beta</code></td>
<td>
<p>Desired level of confidence.  This is 1-risk, where risk is the
maximum chance of not going to a full recount if the results are wrong.
Note that in Stark's papers, the value of interest is typically risk,
denoted $alpha$.</p>
</td></tr>
<tr><td><code id="KM.calc.sample_+3A_taint">taint</code></td>
<td>
<p>Assumed taint.  Taint is assumed to be the taint for all
batches (very conservative).  If taint=0 then we produce a good baseline.</p>
</td></tr>
<tr><td><code id="KM.calc.sample_+3A_bound">bound</code></td>
<td>
<p>Type of bound on the maximum error one could find in a batch.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A audit.plan.KM object.
</p>


<h3>Author(s)</h3>

<p>Based on the KM audit by Stark.
</p>


<h3>See Also</h3>

<p>KM.audit
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data(santa.cruz)
  Z = elec.data( santa.cruz, C.names=c("danner","leopold") )
  KM.calc.sample( Z, beta=0.75, taint=0 )

</code></pre>

<hr>
<h2 id='make.audit.from.Z'>Make a fake audit given specified error for simulations</h2><span id='topic+make.audit.from.Z'></span><span id='topic+make.audit'></span>

<h3>Description</h3>

<p>Functions that make fake audits given a specified error mechanism and a
elec.data object holding reported outcomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.audit.from.Z(Z, N = 400, ...)

make.audit(
  Z = NULL,
  method = c("tweak", "opt.bad", "opt.bad.WPM", "opt.bad.packed", "opt.bad.packed.WPM",
    "ok", "no error"),
  p_d = 0.2,
  swing = 20,
  max.taint = 1,
  print.race = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.audit.from.Z_+3A_z">Z</code></td>
<td>
<p>elec.data object.  For make.audit.from.Z, this is the large
election, holding precincts with size, votes, etc., that get sampled to make
an election of a requested number of batches.</p>
</td></tr>
<tr><td><code id="make.audit.from.Z_+3A_n">N</code></td>
<td>
<p>The desired size of the new election.</p>
</td></tr>
<tr><td><code id="make.audit.from.Z_+3A_...">...</code></td>
<td>
<p>other arguments to the method functions</p>
</td></tr>
<tr><td><code id="make.audit.from.Z_+3A_method">method</code></td>
<td>
<p>the method of error generation.  if &quot;tweak&quot; (the default),
then add random amounts of swing to some precincts, and call that the
&quot;truth&quot;.  The other methods generate the truth according to various metrics.</p>
</td></tr>
<tr><td><code id="make.audit.from.Z_+3A_p_d">p_d</code></td>
<td>
<p>percent chance of error in precinct (for ok method)</p>
</td></tr>
<tr><td><code id="make.audit.from.Z_+3A_swing">swing</code></td>
<td>
<p>vote swing if batch has error (for ok method)</p>
</td></tr>
<tr><td><code id="make.audit.from.Z_+3A_max.taint">max.taint</code></td>
<td>
<p>maximum taint allowed in batch</p>
</td></tr>
<tr><td><code id="make.audit.from.Z_+3A_print.race">print.race</code></td>
<td>
<p>print info on race to command line?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>make.audit is to make the election results that can be sampled from with the
simulator.  This method generates the true taint and sampling weights of all
precincts in the race.  The taint is in column 'taint', sampling weights in
'e.max'
</p>
<p>make.audit.from.Z Given the structure of some large election, make a small
election by sampling batches (with replacement) from the full list.  This
first samples N precincts (and gets the totals from them) and then builds
the 'truth' as normal using the make.audit() method.  Note different calls
to this will produce different margins based on precincts selected.
</p>
<p>WARNING: It is concievable that the winner will flip due to the sampling, if
the sample has too many batches for the loser.
</p>


<h3>Value</h3>

<p>Data frame with precinct information for the race.  NOTE- The reported vote
totals are just that, reported.
</p>


<h3>Author(s)</h3>

<p>Miratrix
</p>


<h3>See Also</h3>

<p><a href="#topic+truth.looker">truth.looker</a>
</p>

<hr>
<h2 id='make.cartoon'>Make the cartoon example from the CAST paper as a voter data
matrix.</h2><span id='topic+make.cartoon'></span>

<h3>Description</h3>

<p>This makes the sample scenario described in P. B. Stark's CAST
paper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.cartoon(n = 400, vote.dist = c(125, 113, 13), stratify = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.cartoon_+3A_n">n</code></td>
<td>
<p>Size of sample.</p>
</td></tr>
<tr><td><code id="make.cartoon_+3A_vote.dist">vote.dist</code></td>
<td>
<p>reported votes for C1, C2, and C3 in order for all
precincts.prompt</p>
</td></tr>
<tr><td><code id="make.cartoon_+3A_stratify">stratify</code></td>
<td>
<p>Should the sample be stratified?</p>
</td></tr>
</table>

<hr>
<h2 id='make.opt.packed.bad'>make.truth.opt.bad</h2><span id='topic+make.opt.packed.bad'></span>

<h3>Description</h3>

<p>Generate a &ldquo;truth&rdquo; that is optimally bad in the sense of the margin in
error is packed into as few precints as possible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.opt.packed.bad(
  Z,
  max.taint = 1,
  max.taint.good = max.taint,
  WPM = FALSE,
  add.good = 0,
  add.random = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.opt.packed.bad_+3A_z">Z</code></td>
<td>
<p>elec.data object to make bad truth for.</p>
</td></tr>
<tr><td><code id="make.opt.packed.bad_+3A_max.taint">max.taint</code></td>
<td>
<p>max taint for any batch</p>
</td></tr>
<tr><td><code id="make.opt.packed.bad_+3A_max.taint.good">max.taint.good</code></td>
<td>
<p>max taint in good direction for any batch</p>
</td></tr>
<tr><td><code id="make.opt.packed.bad_+3A_wpm">WPM</code></td>
<td>
<p>Use WPM bound on error.</p>
</td></tr>
<tr><td><code id="make.opt.packed.bad_+3A_add.good">add.good</code></td>
<td>
<p>add this amount of margin in good error (i.e. for the
winner)</p>
</td></tr>
<tr><td><code id="make.opt.packed.bad_+3A_add.random">add.random</code></td>
<td>
<p>add a random tweak to error</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Make an audit data.frame with the error being exactly 1 margin, and packed
into a small number of precincts (with some potential for binding amount of
error per precinct).
</p>
<p>Warning: error is not necessarily achievable as the discrete nature of whole
votes is disregarded.
</p>


<h3>Value</h3>

<p>Return the vote matrix (a data.frame) with tot.votes, e.max, and
taint computed (NOT the elec data object).
</p>

<hr>
<h2 id='make.random.truth'>making fake truth for electios</h2><span id='topic+make.random.truth'></span>

<h3>Description</h3>

<p>Make a random truth that is with the reported outcome, but has random error
scattered throughout.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.random.truth(
  Z,
  p_d = 0.1,
  swing = 10,
  uniform = TRUE,
  seed = NULL,
  PID = "PID"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.random.truth_+3A_z">Z</code></td>
<td>
<p>elec.data object.  The original reported results.</p>
</td></tr>
<tr><td><code id="make.random.truth_+3A_p_d">p_d</code></td>
<td>
<p>chance a batch has error</p>
</td></tr>
<tr><td><code id="make.random.truth_+3A_swing">swing</code></td>
<td>
<p>max amount of error in votes.</p>
</td></tr>
<tr><td><code id="make.random.truth_+3A_uniform">uniform</code></td>
<td>
<p>if yes, then error is from 1 to swing.  If no, then error is
swing.</p>
</td></tr>
<tr><td><code id="make.random.truth_+3A_seed">seed</code></td>
<td>
<p>random seed to ease replication</p>
</td></tr>
<tr><td><code id="make.random.truth_+3A_pid">PID</code></td>
<td>
<p>which column has batch IDs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given reported results (Z), make a new data.frame which is the truth (that
can be 'audited' by looking at relevant precincts).
</p>
<p>This is the generic small error generation used in trinomial paper and
elsewhere as a baseline &quot;normal&quot; mode of operations.
</p>


<h3>Value</h3>

<p># Return: elec.data object holding the 'truth'.
</p>

<hr>
<h2 id='make.sample'>Generate fake election results for simulation studies</h2><span id='topic+make.sample'></span>

<h3>Description</h3>

<p>These methods are for SIMULATION STUDIES.  These functions will build a
sample, i.e. simulated, record of votes given certain parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.sample(
  M,
  N,
  strata = 1,
  per.winner = NULL,
  worst.e.max = NULL,
  R = NULL,
  tot.votes = 1e+05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.sample_+3A_m">M</code></td>
<td>
<p>The margin desired between the winner and loser (as a percent).</p>
</td></tr>
<tr><td><code id="make.sample_+3A_n">N</code></td>
<td>
<p>Number of precincts desired.</p>
</td></tr>
<tr><td><code id="make.sample_+3A_strata">strata</code></td>
<td>
<p>Number of strata desired.</p>
</td></tr>
<tr><td><code id="make.sample_+3A_per.winner">per.winner</code></td>
<td>
<p>The percent of votes the winner should receive.</p>
</td></tr>
<tr><td><code id="make.sample_+3A_worst.e.max">worst.e.max</code></td>
<td>
<p>The worst e.max possible for any precinct.</p>
</td></tr>
<tr><td><code id="make.sample_+3A_r">R</code></td>
<td>
<p>The &quot;dispersion&quot; a measure of how unequal in size precincts should
be.  R needs to be greater than 0.  NULL indicates equal size.  For R
between 0 and 1, the precincts are distributed 'linearly', i.e., the size of
precinct i is proportional to i.  At 2, the smallest precint will be near 0
and the largest twice the average votes per precinct.  After 2, the
precincts are distributed in a more curved fashion so that the smaller
precincts do not go negative.</p>
</td></tr>
<tr><td><code id="make.sample_+3A_tot.votes">tot.votes</code></td>
<td>
<p>The total votes desired.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A elec.data object meeting the desired specifications.
</p>


<h3>Author(s)</h3>

<p>Luke W. Miratrix
</p>


<h3>References</h3>

<p>See http://www.stat.berkeley.edu/~stark/Vote/index.htm for
relevant information.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+elec.data">elec.data</a></code> <code><a href="#topic+make.truth">make.truth</a></code>
<code><a href="#topic+do.audit">do.audit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Z = make.sample(0.08, 150, per.winner=0.4)
Z

Z2 = make.sample(0.08, 150, per.winner=0.4, R=2.2)
Z2

## Note how they have different precinct sizes.

summary(Z$V$tot.votes)
summary(Z2$V$tot.votes)



</code></pre>

<hr>
<h2 id='make.sample.from.totals'>Make sample from vote totals (for simulations)</h2><span id='topic+make.sample.from.totals'></span>

<h3>Description</h3>

<p>Given a vector of precinct totals and the total votes for the winner
and the loser, make a plausible precinct-by-precinct vote count that
works. 
Note: the margins of the precincts will all be the same as the margin
of the overall race.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.sample.from.totals(vote.W, vote.L, totals)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.sample.from.totals_+3A_vote.w">vote.W</code></td>
<td>
<p>Total votes for winner.</p>
</td></tr>
<tr><td><code id="make.sample.from.totals_+3A_vote.l">vote.L</code></td>
<td>
<p>Total votes for loser.</p>
</td></tr>
<tr><td><code id="make.sample.from.totals_+3A_totals">totals</code></td>
<td>
<p>Vector of total votes for precincts.</p>
</td></tr>
</table>

<hr>
<h2 id='make.truth'>Make baseline truth for simulations</h2><span id='topic+make.truth'></span><span id='topic+make.truth.ex.bad'></span><span id='topic+make.truth.opt.bad'></span><span id='topic+make.truth.opt.bad.strat'></span><span id='topic+make.ok.truth'></span>

<h3>Description</h3>

<p>For simulations.  These methods, given an elec.data object, make a
&ldquo;truth&rdquo;&mdash;i.e. a different vote count&mdash;that meets the same precinct and
tot.votes structure, but has potentially different results and outcomes.
</p>
<p><code>make.truth.opt.bad</code> makes the &ldquo;optimally worse truth&rdquo;, where the
error needed to flip the winner and runner-up is packed into as a few
precincts as possible.
</p>
<p><code>make.ok.truth</code> makes the truth have the same outcome as the reported,
but some errors here and there.
</p>
<p>Warning: if bound is WPM this error is made by simply adding the max amount of error
to the first loser's total (so that total votes may in this case exceed the total votes
of the precinct)&ndash;this could potentially cause trouble.  Be careful!
</p>
<p>make bad truth as described in Stark's paper (assuming fixed precinct size)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.truth.ex.bad(Z)

make.truth.opt.bad(Z, strata = "strata", bound = c("margin", "WPM"), t = 0)

make.truth.opt.bad.strat(Z, strata = "strata", t = 3, shuffle.strata = FALSE)

make.ok.truth(Z, num.off = 8, amount.off = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.truth_+3A_z">Z</code></td>
<td>
<p>The elec.data to build from.</p>
</td></tr>
<tr><td><code id="make.truth_+3A_strata">strata</code></td>
<td>
<p>name of column holding strata, if any.</p>
</td></tr>
<tr><td><code id="make.truth_+3A_bound">bound</code></td>
<td>
<p>What sort of maximum error can be held in a precinct.</p>
</td></tr>
<tr><td><code id="make.truth_+3A_t">t</code></td>
<td>
<p>an allowed backgound level of error for all precincts</p>
</td></tr>
<tr><td><code id="make.truth_+3A_shuffle.strata">shuffle.strata</code></td>
<td>
<p>Should the error be randomly put in the strata?</p>
</td></tr>
<tr><td><code id="make.truth_+3A_num.off">num.off</code></td>
<td>
<p>Number of precincts that should have small errors.  Direction
of errors split 50-50 positive and negative.</p>
</td></tr>
<tr><td><code id="make.truth_+3A_amount.off">amount.off</code></td>
<td>
<p>Size of the small errors that should be imposed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Another elec.data matrix with the same candidates and total ballot
counts as the passed frame, but with different candidate totals and
by-precinct votes.  Can be used to test the power or actual confidence of
the various auditing procedures.
</p>
<p>WARNING: make.ok.truth randomly adds votes and can thus sometimes exceed the
allowed ballot count for a precinct by small amounts.
</p>
<p>WARNING: If the desired bound is WPM, the error in make.opt.bad.truth is
made by simply adding the maximum allowed amount of error in votes to the
first loser's total (so that total votes may in this case exceed the total
votes of the precinct)&ndash;this could potentially cause trouble.  Be careful!
</p>
<p>WARNING: <code>make.truth.ex.bad</code> and <code>make.truth.opt.bad.strat</code> only
work in conjunction with the <code><a href="#topic+make.cartoon">make.cartoon</a></code> method.
</p>


<h3>Author(s)</h3>

<p>Luke W. Miratrix
</p>


<h3>See Also</h3>

<p><code><a href="#topic+elec.data">elec.data</a></code> <code><a href="#topic+make.sample">make.sample</a></code>
<code><a href="#topic+do.audit">do.audit</a></code> <code><a href="#topic+make.cartoon">make.cartoon</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## First make a fake election.
Z = make.sample(0.08, 150, per.winner=0.4, R=2.2)
Z

## Now make a fake truth, which has a lot of small errors:
Zb = make.ok.truth(Z, num.off=150, amount.off=5)
Zb

## Finally, make the hardest to detect (via SRS) ``wrong'' election:
Zw = make.truth.opt.bad( Z, t=4 )
Zw 
</code></pre>

<hr>
<h2 id='marin'>Marin Measure B Reported Results</h2><span id='topic+marin'></span>

<h3>Description</h3>

<p>These are the reported vote totals from the 2009 election in Marin, CA for
Measure B.
</p>
<p>Note the vote totals for the VBM strata are made up.  The batches are the
&ldquo;Decks&rdquo;, which could not be individually tallied with ease.  The
work-around was complex.  See the references, below.
</p>


<h3>Format</h3>

<p>A data frame with 544 observations on the following 5 variables.
</p>
 <dl>
<dt>PID</dt><dd><p>Batch ID</p>
</dd> <dt>strata</dt><dd><p>There are two
levels, <code>ST-IB</code> <code>ST-VBM</code> for in-precinct and Vote-by-Mail.</p>
</dd>
<dt>tot.votes</dt><dd><p>total ballots cast in the batch.</p>
</dd>
<dt>Yes</dt><dd><p>Number recorded for Yes</p>
</dd> <dt>No</dt><dd><p>Number
recorded for No</p>
</dd> </dl>



<h3>Source</h3>

<p>Marin, CA 2009 reported election results.
</p>


<h3>References</h3>

<p>See J. L. Hall, L. W. Miratrix, P. B. Stark, M. Briones, E.
Ginnold, F. Oakley, M. Peaden, G. Pellerin, T. Stanionis, and T. Webber.
Implementing risk-limiting audits in california.  USENIX EVT/WOTE in press,
July 2009.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(marin)
marin = elec.data( marin, C.names=c("Yes","No") )

# Hand fixing error bound due to unknown
# vote totals in the VBM decks
marin$V$e.max = maximumMarginBound(marin)
sum( marin$V$e.max )   # 7.128
vbm = marin$V$strata=="ST-VBM"
marin$V[ vbm, "e.max" ] = 2 * marin$V[ vbm, "tot.votes" ] / marin$margin

sum( marin$V$e.max )   # 9.782


</code></pre>

<hr>
<h2 id='maximumMarginBound'>Election Audit Error Bound Functions</h2><span id='topic+maximumMarginBound'></span>

<h3>Description</h3>

<p>This is one of the various bounding functions used to
bound the maximum amount of error one could see in a single audit
unit.
</p>
<p>maximumMarginBound returns the maximum margin reduction for each
precint by computing all margin reductions between pairs of winners
&amp; losers and then scaling by that pair's total margin to get a
proportion and then taking the max of all such proportions (usually
will be the last winner to the closest loser).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maximumMarginBound(Z, votes = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maximumMarginBound_+3A_z">Z</code></td>
<td>
<p>The elec.data object.</p>
</td></tr>
<tr><td><code id="maximumMarginBound_+3A_votes">votes</code></td>
<td>
<p>The data.frame to compute the maximumMarginBounds for.
If null, will return all bounds for all precincts in Z.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector (of length of precincts) of maximum possible error
for each precinct.
</p>


<h3>Author(s)</h3>

<p>Luke W. Miratrix
</p>

<hr>
<h2 id='opt.sample.size'>KM Audit Sample Size Calc</h2><span id='topic+opt.sample.size'></span>

<h3>Description</h3>

<p>Calc KM Optimal Sample Size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opt.sample.size(Z, beta = 0.25)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opt.sample.size_+3A_z">Z</code></td>
<td>
<p>elec.data object</p>
</td></tr>
<tr><td><code id="opt.sample.size_+3A_beta">beta</code></td>
<td>
<p>risk</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is how many steps would be needed if no error was found with each step.
Obviously a bit idealistic, but still useful.
</p>


<h3>Value</h3>

<p>Single number of batches to sample.
</p>

<hr>
<h2 id='print.audit.plan.KM'>Pretty print KM audit plan</h2><span id='topic+print.audit.plan.KM'></span>

<h3>Description</h3>

<p>Pretty print KM audit plan
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'audit.plan.KM'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.audit.plan.KM_+3A_x">x</code></td>
<td>
<p>A audit.plan.KM object, such as one returned by KM.calc.sample.</p>
</td></tr>
<tr><td><code id="print.audit.plan.KM_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='santa.cruz'>Santa Cruz Election Data</h2><span id='topic+santa.cruz'></span>

<h3>Description</h3>

<p><code>santa.cruz</code> and <code>santa.cruz.audit</code> hold data from a Santa Cruz
County, CA, contest held in November, 2008, for County Supervisor in the 1st
District.  The competitive candidates were John Leopold and Betty Danner.
According to the semi-official results provided to us by the Santa Cruz
County Clerk's office, Leopold won with votes on 45% of the 26,655 ballots.
Danner received the votes on 37% of the ballots.  The remaining ballots
were undervoted, overvoted, or had votes for minor candidates.
</p>
<p><code>santa.cruz</code> holds the semi-official results for the race.
<code>santa.cruz.audit</code> holds the audit totals for the random sample of
precincts selected for the audit.  Note the <code>santa.cruz.audit</code> vote
counts are larger for some precincts due the missing provisional ballot
counts in the semi-official results.
</p>


<h3>Format</h3>

<p>A data frame with 152 observations on the following 5 variables.
</p>
 <dl>
<dt>PID</dt><dd><p>Precinct IDs (unique) for all precincts
involved in race</p>
</dd> <dt>r</dt><dd><p>Total number of registered voters in the
precinct.</p>
</dd> <dt>tot.votes</dt><dd><p>Total number of ballots cast in the
precinct.</p>
</dd> <dt>leopold</dt><dd><p>Total number of ballots marked for John
Leopold.</p>
</dd> <dt>danner</dt><dd><p>Total number of ballots marked for Betty
Danner.</p>
</dd> </dl>



<h3>Source</h3>

<p>Santa Cruz County, CA, Clerk Gail Pellerin, and their staff.
</p>


<h3>See Also</h3>

<p><a href="#topic+santa.cruz.audit">santa.cruz.audit</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(santa.cruz)
elec.data( santa.cruz, C.names=c("danner","leopold") )

</code></pre>

<hr>
<h2 id='santa.cruz.audit'>Santa Cruz Election Data</h2><span id='topic+santa.cruz.audit'></span>

<h3>Description</h3>

<p><code>santa.cruz</code> and <code>santa.cruz.audit</code> hold data from a Santa Cruz
County, CA, contest held in November, 2008, for County Supervisor in the 1st
District.  The competitive candidates were John Leopold and Betty Danner.
According to the semi-official results provided to us by the Santa Cruz
County Clerk's office, Leopold won with votes on 45% of the 26,655 ballots.
Danner received the votes on 37% of the ballots.  The remaining ballots
were undervoted, overvoted, or had votes for minor candidates.
</p>
<p><code>santa.cruz.audit</code> holds the audit totals for the random sample of
precincts selected for the audit.  Note the <code>santa.cruz.audit</code> vote
counts are larger for some precincts due the missing provisional ballot
counts in the semi-official results.
</p>


<h3>Format</h3>

<p>A data frame with 16 observations on the following 4 variables.
</p>
 <dl>
<dt>PID</dt><dd><p>Precinct IDs (unique) for all precincts
involved in race</p>
</dd> <dt>leopold</dt><dd><p>Total number of ballots marked for
John Leopold.</p>
</dd> <dt>danner</dt><dd><p>Total number of ballots marked for
Betty Danner.</p>
</dd> <dt>count</dt><dd><p>The number of times precinct was sampled
in the PPEB sample taken.</p>
</dd> </dl>



<h3>Source</h3>

<p>Santa Cruz County, CA, Clerk Gail Pellerin, and their staffs, which
we thank for their generous cooperation and the considerable time and effort
they spent counting ballots by hand in order to collect these data.
</p>


<h3>See Also</h3>

<p><a href="#topic+santa.cruz">santa.cruz</a>. For an illustration of analyzing this data, see
the example in <code><a href="#topic+trinomial.bound">trinomial.bound</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(santa.cruz.audit)
data(santa.cruz)
santa.cruz = elec.data(santa.cruz, C.names=c("leopold","danner"))
trinomial.audit( santa.cruz, santa.cruz.audit )

</code></pre>

<hr>
<h2 id='sim.race'>Simulate CAST audits to assess performance</h2><span id='topic+sim.race'></span>

<h3>Description</h3>

<p>Simulate a race (using the <code><a href="#topic+make.cartoon">make.cartoon</a></code> method) and run a CAST
audit on that simulation.  CAST is a system devised by Dr. Philip B., Stark,
UC Berkeley Department of Statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.race(
  n = 800,
  beta = 0.75,
  stages = 2,
  truth.maker = make.truth.opt.bad,
  print.trail = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.race_+3A_n">n</code></td>
<td>
<p>Desired sample size.</p>
</td></tr>
<tr><td><code id="sim.race_+3A_beta">beta</code></td>
<td>
<p>the confidence level desired</p>
</td></tr>
<tr><td><code id="sim.race_+3A_stages">stages</code></td>
<td>
<p>number of auditing stages. Each stage will have the same
confidence level, determined by a function of beta.</p>
</td></tr>
<tr><td><code id="sim.race_+3A_truth.maker">truth.maker</code></td>
<td>
<p>Function to generate &quot;truth&quot;</p>
</td></tr>
<tr><td><code id="sim.race_+3A_print.trail">print.trail</code></td>
<td>
<p>Print out diagnostics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of 3 numbers.  The first is the stage reached.  The second
is the total number of precincts audited.  The third is 0 if the audit
failed to certify (i.e. found large error in the final stage), and 1 if the
audit certified the election (did not find large error in the final stage).
</p>


<h3>Author(s)</h3>

<p>Luke W. Miratrix
</p>


<h3>References</h3>

<p>See http://www.stat.berkeley.edu/~stark/Vote/index.htm for
relevant information.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+CAST.audit">CAST.audit</a></code> and <code><a href="#topic+CAST.calc.opt.cut">CAST.calc.opt.cut</a></code> for
methods regarding CAST audits. Also see <code><a href="#topic+do.audit">do.audit</a></code>,
<code><a href="#topic+make.sample">make.sample</a></code>, and <code><a href="#topic+make.truth">make.truth</a></code> for doing other
simulation studies of this method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
     ## See how many times the CAST method fails to catch a wrong
     ##  election in 20 trials.
     replicate( 20, sim.race( beta=0.75, stages=2, truth.maker=make.truth.opt.bad) )

     ## Now see how much work the CAST method does for typical elections.
     replicate( 20, sim.race( beta=0.75, stages=2, truth.maker=make.ok.truth) )

</code></pre>

<hr>
<h2 id='simulateIt'>simulate KM audits</h2><span id='topic+simulateIt'></span>

<h3>Description</h3>

<p>This takes an election and a truth and conducts a KM audit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateIt(
  data,
  M = 50,
  alpha = 0.25,
  plot = FALSE,
  debug = FALSE,
  return.Ps = FALSE,
  truncate.Ps = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulateIt_+3A_data">data</code></td>
<td>
<p>a data frame, one row per patch, with: tot.votes, e.max, taint</p>
</td></tr>
<tr><td><code id="simulateIt_+3A_m">M</code></td>
<td>
<p>the maximum number of samples to draw before automatically
escalating to a full recount.</p>
</td></tr>
<tr><td><code id="simulateIt_+3A_alpha">alpha</code></td>
<td>
<p>level of risk.</p>
</td></tr>
<tr><td><code id="simulateIt_+3A_plot">plot</code></td>
<td>
<p>plot a chart?</p>
</td></tr>
<tr><td><code id="simulateIt_+3A_debug">debug</code></td>
<td>
<p>debug diag printed?</p>
</td></tr>
<tr><td><code id="simulateIt_+3A_return.ps">return.Ps</code></td>
<td>
<p>Return the sequence of p-values all the way up to N.</p>
</td></tr>
<tr><td><code id="simulateIt_+3A_truncate.ps">truncate.Ps</code></td>
<td>
<p>Return Ps only up to where audit stopped.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a list of all precincts and their true taints and their sampling
weights (in data, a data.frame), do a sequential audit at the specified
alpha.
</p>


<h3>Value</h3>

<p>stopPt - number of draws drawn n - number of unique precincts
audited
</p>

<hr>
<h2 id='stark.test.Z'>Workhorse driver for stark.test</h2><span id='topic+stark.test.Z'></span><span id='topic+stark.test'></span>

<h3>Description</h3>

<p>These main methods conduct the test of the election audit and returns a
p-value and other related info on that test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stark.test.Z(
  Z,
  calc.e_p = calc.pairwise.e_p,
  w_p = weight.function("no.weight"),
  max_err = maximumMarginBound,
  bound.col = Z$tot.votes.col,
  strat.col = NULL,
  drop = NULL,
  strat.method = NULL,
  err.override = NULL,
  n = NULL,
  t = NULL,
  q = NULL
)

stark.test(
  votes,
  audits,
  C.names = NULL,
  f = 1,
  pool = TRUE,
  pairwise = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stark.test.Z_+3A_z">Z</code></td>
<td>
<p>The object holding all the voting information.  See below for
details.</p>
</td></tr>
<tr><td><code id="stark.test.Z_+3A_calc.e_p">calc.e_p</code></td>
<td>
<p>The Function used to calculate maximum error bounds</p>
</td></tr>
<tr><td><code id="stark.test.Z_+3A_w_p">w_p</code></td>
<td>
<p>The function used to calculate weights of error (A list of two
functions)</p>
</td></tr>
<tr><td><code id="stark.test.Z_+3A_max_err">max_err</code></td>
<td>
<p>Function to compute max error bounds for each precint</p>
</td></tr>
<tr><td><code id="stark.test.Z_+3A_bound.col">bound.col</code></td>
<td>
<p>Name (or column index) of column in the vote matrix
corresponding to maximum number of votes allowed in precinct.</p>
</td></tr>
<tr><td><code id="stark.test.Z_+3A_strat.col">strat.col</code></td>
<td>
<p>Name of column that determines how to stratify if NULL will
not stratify</p>
</td></tr>
<tr><td><code id="stark.test.Z_+3A_drop">drop</code></td>
<td>
<p>Either a vector of TRUE/FALSE or a name of a column in Z\$V of
T/F values.  Precincts identified by drop will be dropped from calculations.</p>
</td></tr>
<tr><td><code id="stark.test.Z_+3A_strat.method">strat.method</code></td>
<td>
<p>Not currently implemented.</p>
</td></tr>
<tr><td><code id="stark.test.Z_+3A_err.override">err.override</code></td>
<td>
<p>If non-null, use this as the found error in votes rather
than the actual errors found in the audit.</p>
</td></tr>
<tr><td><code id="stark.test.Z_+3A_n">n</code></td>
<td>
<p>Elements of the test statistic.  Can pass to avoid computation if
those values are already known (e.g., for a simulation)</p>
</td></tr>
<tr><td><code id="stark.test.Z_+3A_t">t</code></td>
<td>
<p>Elements of the test statistic.  Can pass to avoid computation if
those values are already known (e.g., for a simulation)</p>
</td></tr>
<tr><td><code id="stark.test.Z_+3A_q">q</code></td>
<td>
<p>Elements of the test statistic.  Can pass to avoid computation if
those values are already known (e.g., for a simulation)</p>
</td></tr>
<tr><td><code id="stark.test.Z_+3A_votes">votes</code></td>
<td>
<p>data.frame of votes. Each row is precinct.</p>
</td></tr>
<tr><td><code id="stark.test.Z_+3A_audits">audits</code></td>
<td>
<p>data.frame of audits. Each row is precinct.  Table reports
overstatement by candidate.</p>
</td></tr>
<tr><td><code id="stark.test.Z_+3A_c.names">C.names</code></td>
<td>
<p>Names of candidates (and names of cor columns in votes and
audits tables.  If NULL will derive from cols 2 on of votes</p>
</td></tr>
<tr><td><code id="stark.test.Z_+3A_f">f</code></td>
<td>
<p>The number of winners</p>
</td></tr>
<tr><td><code id="stark.test.Z_+3A_pool">pool</code></td>
<td>
<p>If TRUE, combine small candidates into single pseudo-candidates
to increase power</p>
</td></tr>
<tr><td><code id="stark.test.Z_+3A_pairwise">pairwise</code></td>
<td>
<p>if TRUE then do a pairwise test for all pairs and return
highest p-value</p>
</td></tr>
<tr><td><code id="stark.test.Z_+3A_...">...</code></td>
<td>
<p>Extra arguments passed directly to the work-horse method
stark.test.Z</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is an older method.  Most likely <code><a href="#topic+CAST.audit">CAST.audit</a></code> or
<code><a href="#topic+trinomial.audit">trinomial.audit</a></code> should be used instead.
</p>
<p>stark.test() will do the entire test. It is basically a driver function that
sets up 'Z' matrix and passes buck to the stark.test.Z
</p>
<p>The Z object, in particular has: Z\$V: The table of reported votes Z\$audit:
The table of audits as differences from recorded votes
</p>


<h3>Value</h3>

<p>Return an htest object with pvalue, some relevant statistics, and
the Z object used (possibly constructed) that produced those results.
</p>


<h3>Author(s)</h3>

<p>Luke W. Miratrix
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+elec.data">elec.data</a></code> for description of the main object.
See <code><a href="#topic+find.q">find.q</a></code> and <code><a href="#topic+compute.stark.t">compute.stark.t</a></code> for the main
components of this test.  <code><a href="#topic+find.stark.SRS.p">find.stark.SRS.p</a></code> is a utility
function for computing a p-value for a specific situation.  See
<a href="#topic+weight.function">weight.function</a> for functions used to weight audit errors.  See
MaximumBound for a bound on error that one might use for
these tests.  See <code><a href="#topic+find.stratification">find.stratification</a></code> for a utility for
stratification.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## pretending that santa cruz audit was a SRS audit (which it was not)
data(santa.cruz)
Z = elec.data(santa.cruz, C.names=c("leopold","danner"))
data(santa.cruz.audit)
## do some work to get the audit totals to overstatements
rownames(santa.cruz.audit) = santa.cruz.audit$PID
Z$audit = audit.totals.to.OS(Z, santa.cruz.audit)
Z$audit
stark.test.Z(Z)


</code></pre>

<hr>
<h2 id='tri.audit.sim'>tri.audit.sim</h2><span id='topic+tri.audit.sim'></span>

<h3>Description</h3>

<p>This is a SIMULATION FUNCTION, and is not used for actual auditing of
elections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tri.audit.sim(
  Z,
  n,
  p_d = 0.1,
  swing = 5,
  return.type = c("statistics", "taints", "precinct"),
  seed = NULL,
  PID = "PID",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tri.audit.sim_+3A_z">Z</code></td>
<td>
<p>elec.data object.</p>
</td></tr>
<tr><td><code id="tri.audit.sim_+3A_n">n</code></td>
<td>
<p>Sample size to draw.</p>
</td></tr>
<tr><td><code id="tri.audit.sim_+3A_p_d">p_d</code></td>
<td>
<p>The probability of a precinct having an error.</p>
</td></tr>
<tr><td><code id="tri.audit.sim_+3A_swing">swing</code></td>
<td>
<p>The size of the error, in votes.</p>
</td></tr>
<tr><td><code id="tri.audit.sim_+3A_return.type">return.type</code></td>
<td>
<p>What kind of results to return: &quot;statistics&quot;,&quot;taints&quot;, or
&quot;precinct&quot;</p>
</td></tr>
<tr><td><code id="tri.audit.sim_+3A_seed">seed</code></td>
<td>
<p>Random seed to use.</p>
</td></tr>
<tr><td><code id="tri.audit.sim_+3A_pid">PID</code></td>
<td>
<p>Column name of column holding unique precinct IDs</p>
</td></tr>
<tr><td><code id="tri.audit.sim_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to tri.sample</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a matrix of votes, calculate the weights for all precincts and then
draw a sample (using tri.sample).  Then, assuming that p\_d percent of the
precincts (at random) have error, and the errors are due to vote miscounts
of size 'swing', conduct a simulated &ldquo;audit&rdquo;, returning the found
descrepancies.
</p>


<h3>Value</h3>

<p>List of taints found in such a circumstance OR precincts selected
with relevant attributes (including simulated errors, if asked) OR the
number of non-zero taints and the size of largest taint.
</p>


<h3>Author(s)</h3>

<p>Luke W. Miratrix
</p>


<h3>See Also</h3>

<p><code><a href="#topic+elec.data">elec.data</a></code> for the object that holds vote data.  See
<code><a href="#topic+tri.calc.sample">tri.calc.sample</a></code> for computing sample sizes for trinomial bound
audits.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

  data(santa.cruz)
  Z = elec.data(santa.cruz, C.names=c("leopold","danner"))
  Z$V$e.max = maximumMarginBound( Z )
  ## Sample from fake truth, see how many errors we get.
  tri.audit.sim( Z, 10,  p_d=0.25, swing=10, return.type="precinct" )

  ## what does distribution look like?
  res = replicate( 200, tri.audit.sim( Z, 10,  p_d=0.25, swing=10 ) )
  apply(res,1, summary) 
  hist( res[2,], main="Distribution of maximum size taint" )

</code></pre>

<hr>
<h2 id='tri.calc.sample'>Calculate needed sample size for election auditing using the
Trinomial Bound</h2><span id='topic+tri.calc.sample'></span>

<h3>Description</h3>

<p>Calculate an estimated sample size to do a trinomial bound that
would have a specified power (the chance to certify assuming a
given estimate of low-error error rate), and a specified maximum
risk of erroneously certifying if the actual election outcome is
wrong.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tri.calc.sample(
  Z,
  beta = 0.75,
  guess.N = 20,
  p_d = 0.1,
  swing = 5,
  power = 0.9,
  bound = c("e.plus", "WPM", "passed")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tri.calc.sample_+3A_z">Z</code></td>
<td>
<p>elec.data object</p>
</td></tr>
<tr><td><code id="tri.calc.sample_+3A_beta">beta</code></td>
<td>
<p>1-beta is the acceptable risk of failing to notice that
a full manual count is needed given an election with an actual
outcome different from the semi-official outcome.</p>
</td></tr>
<tr><td><code id="tri.calc.sample_+3A_guess.n">guess.N</code></td>
<td>
<p>The guessed needed sample size.</p>
</td></tr>
<tr><td><code id="tri.calc.sample_+3A_p_d">p_d</code></td>
<td>
<p>For the alternate: estimate of the proportion of
precincts that have error.</p>
</td></tr>
<tr><td><code id="tri.calc.sample_+3A_swing">swing</code></td>
<td>
<p>For the alternate: estimate of the max size of an
error in votes, given that error exists.</p>
</td></tr>
<tr><td><code id="tri.calc.sample_+3A_power">power</code></td>
<td>
<p>The desired power of the test against the specified
alternate defined by p\_d and swing.</p>
</td></tr>
<tr><td><code id="tri.calc.sample_+3A_bound">bound</code></td>
<td>
<p>e.plus, WPM, or use the passed, previously computed,
e.max values in the Z object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>audit.plan.tri</code> object.  This is an object that
holds information on how many samples are needed in the audit,
the maximum amount of potential overstatement in the election,
and a few other things.
</p>


<h3>References</h3>

<p>See Luke W. Miratrix and Philip B. Stark.  (2009)
Election Audits using a Trinomial Bound.
http://www.stat.berkeley.edu/~stark
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+elec.data">elec.data</a></code> for information on the object that
holds vote counts.  See <code><a href="#topic+tri.sample">tri.sample</a></code> for drawing the
actual sample.  The <code>audit.plan.tri</code> object holds the audit
plan information (e.g., number of draws, estimated work in ballots
to audit, etc.).  See <code><a href="#topic+trinomial.bound">trinomial.bound</a></code> for analyzing
the data once the audit results are in.  See
<code><a href="#topic+tri.audit.sim">tri.audit.sim</a></code> for simulating audits using this
method.  See <a href="#topic+CAST.audit">CAST.audit</a> for an SRS audit method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(santa.cruz)
Z = elec.data( santa.cruz, C.names=c("danner","leopold") )
tri.calc.sample( Z, beta=0.75, guess.N = 10, p_d = 0.05,
               swing=10, power=0.9, bound="e.plus" )

</code></pre>

<hr>
<h2 id='tri.sample'>Sample from List of Precincts PPEB</h2><span id='topic+tri.sample'></span>

<h3>Description</h3>

<p>tri.sample selects a sample of precincts PPEB.  Namely, samples n times,
with replacement, from the precincts proportional to the weights of the
precincts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tri.sample(
  Z,
  n,
  seed = NULL,
  print.trail = FALSE,
  simplify = TRUE,
  return.precincts = TRUE,
  PID = "PID",
  known = "known"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tri.sample_+3A_z">Z</code></td>
<td>
<p>elec.data object</p>
</td></tr>
<tr><td><code id="tri.sample_+3A_n">n</code></td>
<td>
<p>Either a audit.plan.tri object (that contains n) or an integer
which is the size of the sample</p>
</td></tr>
<tr><td><code id="tri.sample_+3A_seed">seed</code></td>
<td>
<p>Seed to use.</p>
</td></tr>
<tr><td><code id="tri.sample_+3A_print.trail">print.trail</code></td>
<td>
<p>Print diagnostics and info on the selection process.</p>
</td></tr>
<tr><td><code id="tri.sample_+3A_simplify">simplify</code></td>
<td>
<p>If TRUE, return a data frame of unique precincts sampled,
with counts of how many times they were sampled.  Otherwise return
repeatedly sampled precincts seperately.</p>
</td></tr>
<tr><td><code id="tri.sample_+3A_return.precincts">return.precincts</code></td>
<td>
<p>Return the precincts, or just the precint IDs</p>
</td></tr>
<tr><td><code id="tri.sample_+3A_pid">PID</code></td>
<td>
<p>The name of the column in Z\$V holding unique precinct IDs</p>
</td></tr>
<tr><td><code id="tri.sample_+3A_known">known</code></td>
<td>
<p>Name of column in Z\$V of TRUE/FALSE, where TRUE are precincts
that are considered &ldquo;known&rdquo;, and thus should not be sampled for whatever
reason.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The weights, if passed, are in the &ldquo;e.max&rdquo; column of Z\$V.
</p>


<h3>Value</h3>

<p>a sample of precincts.
</p>


<h3>Author(s)</h3>

<p>Luke W. Miratrix
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trinomial.bound">trinomial.bound</a></code> <code><a href="#topic+elec.data">elec.data</a></code>
<code><a href="#topic+tri.calc.sample">tri.calc.sample</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(santa.cruz)
Z = elec.data( santa.cruz, C.names=c("danner","leopold") )
samp = tri.calc.sample( Z, beta=0.75, guess.N = 10, p_d = 0.05,
               swing=10, power=0.9, bound="e.plus" )
tri.sample( Z, samp, seed=541227 )

</code></pre>

<hr>
<h2 id='tri.sample.stats'>Utility function for tri.sample</h2><span id='topic+tri.sample.stats'></span>

<h3>Description</h3>

<p>A utility function returning the total number of unique precincts
and ballots given a sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tri.sample.stats(samp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tri.sample.stats_+3A_samp">samp</code></td>
<td>
<p>A sample, such as one returned from tri.sample</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the total number of unique precincts and ballots given a
sample.
</p>

<hr>
<h2 id='trinomial.audit'>Conduct trinomial audit</h2><span id='topic+trinomial.audit'></span>

<h3>Description</h3>

<p><code>trinomial.audit</code> converts the audited total counts for candidates to
overstatements and taints. <code>trinomial.bound</code> calculates the trinomial
bound given the size of an audit sample, the number of non-zero errors, and
the size of the small-error threshold. It can also plot a contour of the
distribution space, bounds, and alpha lines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trinomial.audit(Z, audit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trinomial.audit_+3A_z">Z</code></td>
<td>
<p>An elec.data object that is the race being audited.</p>
</td></tr>
<tr><td><code id="trinomial.audit_+3A_audit">audit</code></td>
<td>
<p>A data.frame with a column for each candidate and a row for
each audited precinct, holding the audit totals for each candidate. An
additional column, <code>count</code>, holds the number of times that precinct was
sampled (since sampling was done by replacement).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Right now the p-value is computed in a clumsy, bad way.  A grid of points
over (0, xlim) X (0, ylim) is generated corresponding to values of p0 and
pd, and for each point the mean of that distribution and the chance of
generating an outcome as extreme as k is calculated.  Then the set of points
with an outcome close to alpha is extrated, and the corresponding bound is
optimized over this subset.  Not the best way to do things.
</p>

<hr>
<h2 id='trinomial.bound'>Auditing with the Trinomial Bound: trinomial.bound and trinomial.audit</h2><span id='topic+trinomial.bound'></span>

<h3>Description</h3>

<p>This method makes a contour plot of the optimization problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trinomial.bound(
  n = 11,
  k = 2,
  d = 40,
  e.max = 100,
  xlim = c(0.4, 1),
  ylim = c(0, 0.55),
  alpha.lvls = c(10),
  zero.threshold = 0.3,
  tick.lines = NULL,
  alpha.lwd = 2,
  bold.first = FALSE,
  plot = TRUE,
  p.value.bound = NULL,
  grid.resolution = 300,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trinomial.bound_+3A_n">n</code></td>
<td>
<p>Size of the sample (not precincts, but samples which could
potentially be multiple samples of the same precinct).</p>
</td></tr>
<tr><td><code id="trinomial.bound_+3A_k">k</code></td>
<td>
<p>The number of positive taints found in sample.</p>
</td></tr>
<tr><td><code id="trinomial.bound_+3A_d">d</code></td>
<td>
<p>The maximum size of a small taint. This is the threshold for being
in the middle bin of the trinomial.  All taints larger than d would be in
the largest error bin.</p>
</td></tr>
<tr><td><code id="trinomial.bound_+3A_e.max">e.max</code></td>
<td>
<p>The size of the largest error bin.  Typically 100 (for percent)
or 1.</p>
</td></tr>
<tr><td><code id="trinomial.bound_+3A_xlim">xlim</code></td>
<td>
<p>Range of possible values of p0 worth considering</p>
</td></tr>
<tr><td><code id="trinomial.bound_+3A_ylim">ylim</code></td>
<td>
<p>Range of possible values of pd worth considering</p>
</td></tr>
<tr><td><code id="trinomial.bound_+3A_alpha.lvls">alpha.lvls</code></td>
<td>
<p>List of alphas for which bounds should be calculated. The
first is the one that will be returned.  The others will be graphed.</p>
</td></tr>
<tr><td><code id="trinomial.bound_+3A_zero.threshold">zero.threshold</code></td>
<td>
<p>Since the method calculates on a numerical grid, what
difference between alpha and the calculated probabilty should be considered
no difference.</p>
</td></tr>
<tr><td><code id="trinomial.bound_+3A_tick.lines">tick.lines</code></td>
<td>
<p>A list of bounds.  For these bound levels, add tick-lines
(more faint lines) to graph</p>
</td></tr>
<tr><td><code id="trinomial.bound_+3A_alpha.lwd">alpha.lwd</code></td>
<td>
<p>Line width for alpha line.</p>
</td></tr>
<tr><td><code id="trinomial.bound_+3A_bold.first">bold.first</code></td>
<td>
<p>TRUE/FALSE.  Should first alpha line be in bold.</p>
</td></tr>
<tr><td><code id="trinomial.bound_+3A_plot">plot</code></td>
<td>
<p>Should a plot be generated.</p>
</td></tr>
<tr><td><code id="trinomial.bound_+3A_p.value.bound">p.value.bound</code></td>
<td>
<p>What is the bound (1/U) that would correspond to the
entire margin.  Finding the alpha corresponding to this bound is a method
for finding the p-value for the trinomial bound test.</p>
</td></tr>
<tr><td><code id="trinomial.bound_+3A_grid.resolution">grid.resolution</code></td>
<td>
<p>How many divisions of the grid should there be?  More
gives greater accuracy in the resulting p-values and bounds.</p>
</td></tr>
<tr><td><code id="trinomial.bound_+3A_...">...</code></td>
<td>
<p>Extra arguments passed to the plot command.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: alphas are multiplied by 100 to get in percents.
</p>


<h3>Value</h3>

<p>List with characteristics of the audit and the final results.
</p>
<table>
<tr><td><code>n</code></td>
<td>
<p> Size of sample.</p>
</td></tr> <tr><td><code>k</code></td>
<td>
<p>Number of non-zero taints.</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>Threshold for what a small taint is.</p>
</td></tr> <tr><td><code>e.max</code></td>
<td>
<p>The worst-case
taint.</p>
</td></tr> <tr><td><code>max</code></td>
<td>
<p> The upper confidence bound for the passed alpha-level.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>A length three vector.  The distribution (p0, pd, p1) that achieves
the worst case.</p>
</td></tr> <tr><td><code>p.value</code></td>
<td>
<p> The p.value for the test, if a specific
worst-case bound 1/U was passed via p.value.bound.</p>
</td></tr>
</table>


<h3>References</h3>

<p>See Luke W. Miratrix and Philip B. Stark.  (2009) Election
Audits using a Trinomial Bound.  https://www.stat.berkeley.edu/~stark/Vote/index.htm
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+elec.data">elec.data</a></code> for information on the object that holds vote
counts.  See <code><a href="#topic+tri.sample">tri.sample</a></code> for drawing the actual sample.  See
<code><a href="#topic+tri.calc.sample">tri.calc.sample</a></code> for figuring out how many samples to draw.
See <code><a href="#topic+tri.audit.sim">tri.audit.sim</a></code> for simulating audits using this method.
See <a href="#topic+CAST.audit">CAST.audit</a> for an SRS audit method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# The reported poll data: make an elec.data object for processing
data(santa.cruz)
Z = elec.data(santa.cruz, C.names=c("leopold","danner"))
Z

# Make a plan
plan = tri.calc.sample( Z, beta=0.75, guess.N = 10, p_d = 0.05,
               swing=10, power=0.9, bound="e.plus" )

# Conduct the audit
data(santa.cruz.audit)
res = trinomial.audit( Z, santa.cruz.audit )
res

# Compute the bound.  Everything is scaled by 100 (i.e. to percents) for easier numbers. 
trinomial.bound(n=res$n, k = res$k, d=100*plan$d, e.max=100, p.value.bound=100/plan$T,
           xlim=c(0.75,1), ylim=c(0.0,0.25),
           alpha.lvls=c(25), asp=1,
           main="Auditing Santa Cruz with Trinomial Bound" )

</code></pre>

<hr>
<h2 id='truth.looker'>Looking at fake &ldquo;truths&rdquo; for election simulations</h2><span id='topic+truth.looker'></span>

<h3>Description</h3>

<p>This prints out total error in a fake truth for an election, and some other
info.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>truth.looker(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="truth.looker_+3A_data">data</code></td>
<td>
<p>The data.frame returned from such things as make.audit</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Utility function for debugging and understanding stuff.
</p>
<p>Look at a specific &quot;truth&quot; and print out what total error, etc.  is.
</p>


<h3>Value</h3>

<p>None.  Just does printout.
</p>

<hr>
<h2 id='weight.function'>weight functions</h2><span id='topic+weight.function'></span>

<h3>Description</h3>

<p>This function produces weight functions to reweight found audit miscounts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weight.function(
  name = c("no.weight", "weight", "weight.and.slop", "margin.weight", "taint")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weight.function_+3A_name">name</code></td>
<td>
<p>name of function desired</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions are no weighting, weighted by size of precint, weight by size,
after a slop of 2 votes has been taken off, and weighing for pairwise margin
tests, and finally, the taint weight function that takes maximum error in
precincts and gives a ratio of actual error to maximum error.
</p>


<h3>Value</h3>

<p>A two-element list of two functions, the second being the inverse of
the first.  All the functions have three parameters, x, b\_m, and M, which
are the things to weight, the bound on votes (or maximum error in
precincts), and the (smallest) margin.
</p>


<h3>Author(s)</h3>

<p>Luke W. Miratrix
</p>

<hr>
<h2 id='yolo'>Yolo County, CA Election Data</h2><span id='topic+yolo'></span>

<h3>Description</h3>

<p>This is for measure W in Yolo County, CA, November 2008.  The file includes
precinct-level reports.
</p>
<p>In the actual audit, 6 precincts were selected (see example) and audited by
hand-to-eye count by a group of 4 people cross-checking each other. One of
the 6 batches had underreported the &quot;yes&quot; votes by 1, and one had
overreported the &quot;yes&quot; votes by 1.  There were no other errors.
</p>


<h3>Format</h3>

<p>A data frame with 114 observations on the following 8 variables.
</p>
 <dl>
<dt>PID</dt><dd><p> Unique identifier for the batches of ballots</p>
</dd>
<dt>Pct</dt><dd><p>The precinct id of the batch</p>
</dd> <dt>how</dt><dd><p>Vote by
mail (VBM) or walk-in (PCT)</p>
</dd> <dt>b</dt><dd><p>Number of votes cast in that
unit</p>
</dd> <dt>under</dt><dd><p>Number of undervotes (ballots not voted).</p>
</dd>
<dt>over</dt><dd><p>Number of overvotes (where someone marked both yes and
no).</p>
</dd> <dt>y</dt><dd><p>Reported number of valid ballots marked yes.</p>
</dd>
<dt>n</dt><dd><p>Reported number of valid ballots marked no.</p>
</dd> </dl>



<h3>Source</h3>

<p>Yolo County, CA.  Special thanks to Freddie Oakley and Tom
Stanionis.
</p>


<h3>References</h3>

<p>See Stark et al. for papers using this data to illustrate
risk-limiting audits of election data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Make an elec.data object out of precicnt-level results
data(yolo)
yolo = elec.data( yolo, C.names=c("y","n","under","over"), tot.votes.col="b" ) 

# Look at different sample sizes and cuts for setting aside
# small precincts
CAST.calc.opt.cut( yolo, beta=0.75, stages=1, t=5, plot=TRUE )

print( yolo )

# Get details of the audit plan -- expected work, etc.
ap &lt;- CAST.calc.sample( yolo, beta=0.75, stages=1, t=5, small.cut=5 )
print( ap )

# Draw a sample (seed not used for actual audit)
CAST.sample(yolo, ap, seed=12345678)



</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
