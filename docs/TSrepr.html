<!DOCTYPE html><html lang="en"><head><title>Help for package TSrepr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TSrepr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#clipping'><p>Creates bit-level (clipped representation) from a vector</p></a></li>
<li><a href='#coefComp'><p>Functions for linear regression model coefficients extraction</p></a></li>
<li><a href='#denorm_atan'><p>Arctangent denormalisation</p></a></li>
<li><a href='#denorm_boxcox'><p>Two-parameter Box-Cox denormalisation</p></a></li>
<li><a href='#denorm_min_max'><p>Min-Max denormalisation</p></a></li>
<li><a href='#denorm_yj'><p>Yeo-Johnson denormalisation</p></a></li>
<li><a href='#denorm_z'><p>Z-score denormalisation</p></a></li>
<li><a href='#elec_load'><p>2 weeks of electricity load data from 50 consumers.</p></a></li>
<li><a href='#fast_stat'><p>Fast statistic functions (helpers)</p></a></li>
<li><a href='#maape'><p>MAAPE</p></a></li>
<li><a href='#mae'><p>MAE</p></a></li>
<li><a href='#mape'><p>MAPE</p></a></li>
<li><a href='#mase'><p>MASE</p></a></li>
<li><a href='#mdae'><p>MdAE</p></a></li>
<li><a href='#mse'><p>MSE</p></a></li>
<li><a href='#norm_atan'><p>Arctangent normalisation</p></a></li>
<li><a href='#norm_boxcox'><p>Two-parameter Box-Cox normalisation</p></a></li>
<li><a href='#norm_min_max'><p>Min-Max normalisation</p></a></li>
<li><a href='#norm_min_max_list'><p>Min-Max normalization list</p></a></li>
<li><a href='#norm_min_max_params'><p>Min-Max normalisation with parameters</p></a></li>
<li><a href='#norm_yj'><p>Yeo-Johnson normalisation</p></a></li>
<li><a href='#norm_z'><p>Z-score normalisation</p></a></li>
<li><a href='#norm_z_list'><p>Z-score normalization list</p></a></li>
<li><a href='#norm_z_params'><p>Z-score normalisation with parameters</p></a></li>
<li><a href='#repr_dct'><p>DCT representation</p></a></li>
<li><a href='#repr_dft'><p>DFT representation by FFT</p></a></li>
<li><a href='#repr_dwt'><p>DWT representation</p></a></li>
<li><a href='#repr_exp'><p>Exponential smoothing seasonal coefficients as representation</p></a></li>
<li><a href='#repr_feaclip'><p>FeaClip representation of time series</p></a></li>
<li><a href='#repr_feacliptrend'><p>FeaClipTrend representation of time series</p></a></li>
<li><a href='#repr_featrend'><p>FeaTrend representation of time series</p></a></li>
<li><a href='#repr_gam'><p>GAM regression coefficients as representation</p></a></li>
<li><a href='#repr_list'><p>Computation of list of representations list of time series with different lengths</p></a></li>
<li><a href='#repr_lm'><p>Regression coefficients from linear model as representation</p></a></li>
<li><a href='#repr_matrix'><p>Computation of matrix of representations from matrix of time series</p></a></li>
<li><a href='#repr_paa'><p>PAA - Piecewise Aggregate Approximation</p></a></li>
<li><a href='#repr_pip'><p>PIP representation</p></a></li>
<li><a href='#repr_pla'><p>PLA representation</p></a></li>
<li><a href='#repr_sax'><p>SAX - Symbolic Aggregate Approximation</p></a></li>
<li><a href='#repr_seas_profile'><p>Mean seasonal profile of time series</p></a></li>
<li><a href='#repr_sma'><p>Simple Moving Average representation</p></a></li>
<li><a href='#repr_windowing'><p>Windowing of time series</p></a></li>
<li><a href='#rleC'><p>RLE (Run Length Encoding) written in C++</p></a></li>
<li><a href='#rmse'><p>RMSE</p></a></li>
<li><a href='#smape'><p>sMAPE</p></a></li>
<li><a href='#trending'><p>Creates bit-level (trending) representation from a vector</p></a></li>
<li><a href='#TSrepr'><p>TSrepr package</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Time Series Representations</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-07-12</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods for representations (i.e. dimensionality reduction, preprocessing, feature extraction) of time series to help more accurate and effective time series data mining.
    Non-data adaptive, data adaptive, model-based and data dictated (clipped) representation methods are implemented. Also various normalisation methods (min-max, z-score, Box-Cox, Yeo-Johnson),
    and forecasting accuracy measures are implemented.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.12), MASS, quantreg, wavelets, mgcv, dtt</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://petolau.github.io/package/">https://petolau.github.io/package/</a>,
<a href="https://github.com/PetoLau/TSrepr/">https://github.com/PetoLau/TSrepr/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/PetoLau/TSrepr/issues">https://github.com/PetoLau/TSrepr/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, ggplot2, data.table, moments, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-07-12 21:59:54 UTC; PeterLaurinec</td>
</tr>
<tr>
<td>Author:</td>
<td>Peter Laurinec <a href="https://orcid.org/0000-0002-3501-8783"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Peter Laurinec &lt;tsreprpackage@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-07-13 06:50:15 UTC</td>
</tr>
</table>
<hr>
<h2 id='clipping'>Creates bit-level (clipped representation) from a vector</h2><span id='topic+clipping'></span>

<h3>Description</h3>

<p>The <code>clipping</code> computes bit-level (clipped representation) from a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clipping(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clipping_+3A_x">x</code></td>
<td>
<p>the numeric vector (time series)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Clipping transforms time series to bit-level representation.
</p>
<p>It is defined as follows:
</p>
<p style="text-align: center;"><code class="reqn">repr_t   =   {1   if   x_t   &gt;   \mu ,  0  otherwise,}</code>
</p>
<p> where <code class="reqn">x_t</code> is a value of a time series
and <code class="reqn">\mu</code> is average of a time series.
</p>


<h3>Value</h3>

<p>the integer vector of zeros and ones
</p>


<h3>Author(s)</h3>

<p>Peter Laurinec, &lt;tsreprpackage@gmail.com&gt;
</p>


<h3>References</h3>

<p>Bagnall A, Ratanamahatana C, Keogh E, Lonardi S, Janacek G (2006)
A bit level representation for time series data mining with shape based similarity.
Data Mining and Knowledge Discovery 13(1):11-40
</p>
<p>Laurinec P, and Lucka M (2018)
Interpretable multiple data streams clustering with clipped streams representation for the improvement of electricity consumption forecasting.
Data Mining and Knowledge Discovery. Springer. DOI: 10.1007/s10618-018-0598-2
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trending">trending</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>clipping(rnorm(50))

</code></pre>

<hr>
<h2 id='coefComp'>Functions for linear regression model coefficients extraction</h2><span id='topic+coefComp'></span><span id='topic+lmCoef'></span><span id='topic+rlmCoef'></span><span id='topic+l1Coef'></span>

<h3>Description</h3>

<p>The functions computes regression coefficients from a linear model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmCoef(X, Y)

rlmCoef(X, Y)

l1Coef(X, Y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coefComp_+3A_x">X</code></td>
<td>
<p>the model (design) matrix of independent variables</p>
</td></tr>
<tr><td><code id="coefComp_+3A_y">Y</code></td>
<td>
<p>the vector of dependent variable (time series)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The numeric vector of regression coefficients
</p>


<h3>Author(s)</h3>

<p>Peter Laurinec, &lt;tsreprpackage@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+lm">lm</a>, <a href="MASS.html#topic+rlm">rlm</a>, <a href="quantreg.html#topic+rq">rq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>design_matrix &lt;- matrix(rnorm(10), ncol = 2)
lmCoef(design_matrix, rnorm(5))

rlmCoef(design_matrix, rnorm(5))

l1Coef(design_matrix, rnorm(5))

</code></pre>

<hr>
<h2 id='denorm_atan'>Arctangent denormalisation</h2><span id='topic+denorm_atan'></span>

<h3>Description</h3>

<p>The <code>denorm_atan</code> denormalises time series from Arctangent function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>denorm_atan(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="denorm_atan_+3A_x">x</code></td>
<td>
<p>the numeric vector (time series)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the numeric vector of denormalised values
</p>


<h3>Author(s)</h3>

<p>Peter Laurinec, &lt;tsreprpackage@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+denorm_z">denorm_z</a>, <a href="#topic+denorm_min_max">denorm_min_max</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>denorm_atan(runif(50))

</code></pre>

<hr>
<h2 id='denorm_boxcox'>Two-parameter Box-Cox denormalisation</h2><span id='topic+denorm_boxcox'></span>

<h3>Description</h3>

<p>The <code>denorm_boxcox</code> denormalises time series by two-parameter Box-Cox method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>denorm_boxcox(x, lambda = 0.1, gamma = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="denorm_boxcox_+3A_x">x</code></td>
<td>
<p>the numeric vector (time series) to be denormalised</p>
</td></tr>
<tr><td><code id="denorm_boxcox_+3A_lambda">lambda</code></td>
<td>
<p>the numeric value - power transformation parameter (default is 0.1)</p>
</td></tr>
<tr><td><code id="denorm_boxcox_+3A_gamma">gamma</code></td>
<td>
<p>the non-negative numeric value - parameter for holding the time series positive (offset) (default is 0)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the numeric vector of denormalised values
</p>


<h3>Author(s)</h3>

<p>Peter Laurinec, &lt;tsreprpackage@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+denorm_z">denorm_z</a>, <a href="#topic+denorm_min_max">denorm_min_max</a>, <a href="#topic+denorm_atan">denorm_atan</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>denorm_boxcox(runif(50))

</code></pre>

<hr>
<h2 id='denorm_min_max'>Min-Max denormalisation</h2><span id='topic+denorm_min_max'></span>

<h3>Description</h3>

<p>The <code>denorm_min_max</code> denormalises time series by min-max method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>denorm_min_max(x, min, max)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="denorm_min_max_+3A_x">x</code></td>
<td>
<p>the numeric vector (time series)</p>
</td></tr>
<tr><td><code id="denorm_min_max_+3A_min">min</code></td>
<td>
<p>the minimum value</p>
</td></tr>
<tr><td><code id="denorm_min_max_+3A_max">max</code></td>
<td>
<p>the maximal value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the numeric vector of denormalised values
</p>


<h3>Author(s)</h3>

<p>Peter Laurinec, &lt;tsreprpackage@gmail.com&gt;
</p>


<h3>References</h3>

<p>Laurinec P, Lucká M (2018)
Clustering-based forecasting method for individual consumers electricity load using time series representations.
Open Comput Sci, 8(1):38–50, DOI: 10.1515/comp-2018-0006
</p>


<h3>See Also</h3>

<p><code><a href="#topic+norm_min_max">norm_min_max</a>, <a href="#topic+norm_min_max_list">norm_min_max_list</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Normalise values and save normalisation parameters:
norm_res &lt;- norm_min_max_list(rnorm(50, 5, 2))
# Denormalise new data with previous computed parameters:
denorm_min_max(rnorm(50, 4, 2), min = norm_res$min, max = norm_res$max)

</code></pre>

<hr>
<h2 id='denorm_yj'>Yeo-Johnson denormalisation</h2><span id='topic+denorm_yj'></span>

<h3>Description</h3>

<p>The <code>denorm_yj</code> denormalises time series by Yeo-Johnson method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>denorm_yj(x, lambda = 0.1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="denorm_yj_+3A_x">x</code></td>
<td>
<p>the numeric vector (time series) to be denormalised</p>
</td></tr>
<tr><td><code id="denorm_yj_+3A_lambda">lambda</code></td>
<td>
<p>the numeric value - power transformation parameter (default is 0.1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the numeric vector of denormalised values
</p>


<h3>Author(s)</h3>

<p>Peter Laurinec, &lt;tsreprpackage@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+denorm_z">denorm_z</a>, <a href="#topic+denorm_min_max">denorm_min_max</a>, <a href="#topic+denorm_boxcox">denorm_boxcox</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>denorm_yj(runif(50))

</code></pre>

<hr>
<h2 id='denorm_z'>Z-score denormalisation</h2><span id='topic+denorm_z'></span>

<h3>Description</h3>

<p>The <code>denorm_z</code> denormalises time series by z-score method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>denorm_z(x, mean, sd)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="denorm_z_+3A_x">x</code></td>
<td>
<p>the numeric vector (time series)</p>
</td></tr>
<tr><td><code id="denorm_z_+3A_mean">mean</code></td>
<td>
<p>the mean value</p>
</td></tr>
<tr><td><code id="denorm_z_+3A_sd">sd</code></td>
<td>
<p>the standard deviation value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the numeric vector of denormalised values
</p>


<h3>Author(s)</h3>

<p>Peter Laurinec, &lt;tsreprpackage@gmail.com&gt;
</p>


<h3>References</h3>

<p>Laurinec P, Lucká M (2018)
Clustering-based forecasting method for individual consumers electricity load using time series representations.
Open Comput Sci, 8(1):38–50, DOI: 10.1515/comp-2018-0006
</p>


<h3>See Also</h3>

<p><code><a href="#topic+norm_z">norm_z</a>, <a href="#topic+norm_z_list">norm_z_list</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Normalise values and save normalisation parameters:
norm_res &lt;- norm_z_list(rnorm(50, 5, 2))
# Denormalise new data with previous computed parameters:
denorm_z(rnorm(50, 4, 2), mean = norm_res$mean, sd = norm_res$sd)

</code></pre>

<hr>
<h2 id='elec_load'>2 weeks of electricity load data from 50 consumers.</h2><span id='topic+elec_load'></span>

<h3>Description</h3>

<p>A dataset containing the electricity consumption time series from 50 consumers of the length of 2 weeks.
Every day is 48 measurements (half-hourly data). Each row represents one consumers time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elec_load
</code></pre>


<h3>Format</h3>

<p>A data frame with 50 rows and 672 variables.
</p>


<h3>Source</h3>

<p>Anonymized.
</p>

<hr>
<h2 id='fast_stat'>Fast statistic functions (helpers)</h2><span id='topic+fast_stat'></span><span id='topic+maxC'></span><span id='topic+minC'></span><span id='topic+meanC'></span><span id='topic+sumC'></span><span id='topic+medianC'></span>

<h3>Description</h3>

<p>Fast statistic functions (helpers) for representations computation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxC(x)

minC(x)

meanC(x)

sumC(x)

medianC(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fast_stat_+3A_x">x</code></td>
<td>
<p>the numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the numeric value
</p>


<h3>Author(s)</h3>

<p>Peter Laurinec, &lt;tsreprpackage@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>maxC(rnorm(50))

minC(rnorm(50))

meanC(rnorm(50))

sumC(rnorm(50))

medianC(rnorm(50))

</code></pre>

<hr>
<h2 id='maape'>MAAPE</h2><span id='topic+maape'></span>

<h3>Description</h3>

<p>the <code>maape</code> computes MAAPE (Mean Arctangent Absolute Percentage Error) of a forecast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maape(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maape_+3A_x">x</code></td>
<td>
<p>the numeric vector of real values</p>
</td></tr>
<tr><td><code id="maape_+3A_y">y</code></td>
<td>
<p>the numeric vector of forecasted values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the numeric value in %
</p>


<h3>Author(s)</h3>

<p>Peter Laurinec, &lt;tsreprpackage@gmail.com&gt;
</p>


<h3>References</h3>

<p>Sungil Kim, Heeyoung Kim (2016)
A new metric of absolute percentage error for intermittent demand forecasts,
International Journal of Forecasting 32(3):669-679
</p>


<h3>Examples</h3>

<pre><code class='language-R'>maape(runif(50), runif(50))

</code></pre>

<hr>
<h2 id='mae'>MAE</h2><span id='topic+mae'></span>

<h3>Description</h3>

<p>The <code>mae</code> computes MAE (Mean Absolute Error) of a forecast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mae(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mae_+3A_x">x</code></td>
<td>
<p>the numeric vector of real values</p>
</td></tr>
<tr><td><code id="mae_+3A_y">y</code></td>
<td>
<p>the numeric vector of forecasted values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the numeric value
</p>


<h3>Author(s)</h3>

<p>Peter Laurinec, &lt;tsreprpackage@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mae(runif(50), runif(50))

</code></pre>

<hr>
<h2 id='mape'>MAPE</h2><span id='topic+mape'></span>

<h3>Description</h3>

<p>the <code>mape</code> computes MAPE (Mean Absolute Percentage Error) of a forecast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mape(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mape_+3A_x">x</code></td>
<td>
<p>the numeric vector of real values</p>
</td></tr>
<tr><td><code id="mape_+3A_y">y</code></td>
<td>
<p>the numeric vector of forecasted values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the numeric value in %
</p>


<h3>Author(s)</h3>

<p>Peter Laurinec, &lt;tsreprpackage@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mape(runif(50), runif(50))

</code></pre>

<hr>
<h2 id='mase'>MASE</h2><span id='topic+mase'></span>

<h3>Description</h3>

<p>The <code>mase</code> computes MASE (Mean Absolute Scaled Error) of a forecast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mase(real, forecast, naive)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mase_+3A_real">real</code></td>
<td>
<p>the numeric vector of real values</p>
</td></tr>
<tr><td><code id="mase_+3A_forecast">forecast</code></td>
<td>
<p>the numeric vector of forecasted values</p>
</td></tr>
<tr><td><code id="mase_+3A_naive">naive</code></td>
<td>
<p>the numeric vector of naive forecast</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the numeric value
</p>


<h3>Author(s)</h3>

<p>Peter Laurinec, &lt;tsreprpackage@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mase(rnorm(50), rnorm(50), rnorm(50))

</code></pre>

<hr>
<h2 id='mdae'>MdAE</h2><span id='topic+mdae'></span>

<h3>Description</h3>

<p>The <code>mdae</code> computes MdAE (Median Absolute Error) of a forecast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mdae(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mdae_+3A_x">x</code></td>
<td>
<p>the numeric vector of real values</p>
</td></tr>
<tr><td><code id="mdae_+3A_y">y</code></td>
<td>
<p>the numeric vector of forecasted values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the numeric value
</p>


<h3>Author(s)</h3>

<p>Peter Laurinec, &lt;tsreprpackage@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mdae(runif(50), runif(50))

</code></pre>

<hr>
<h2 id='mse'>MSE</h2><span id='topic+mse'></span>

<h3>Description</h3>

<p>The <code>mse</code> computes MSE (Mean Squared Error) of a forecast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mse(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mse_+3A_x">x</code></td>
<td>
<p>the numeric vector of real values</p>
</td></tr>
<tr><td><code id="mse_+3A_y">y</code></td>
<td>
<p>the numeric vector of forecasted values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the numeric value
</p>


<h3>Author(s)</h3>

<p>Peter Laurinec, &lt;tsreprpackage@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mse(runif(50), runif(50))

</code></pre>

<hr>
<h2 id='norm_atan'>Arctangent normalisation</h2><span id='topic+norm_atan'></span>

<h3>Description</h3>

<p>The <code>norm_atan</code> normalises time series by Arctangent to max (-1,1) range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm_atan(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="norm_atan_+3A_x">x</code></td>
<td>
<p>the numeric vector (time series)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the numeric vector of normalised values
</p>


<h3>Author(s)</h3>

<p>Peter Laurinec, &lt;tsreprpackage@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+norm_z">norm_z</a>, <a href="#topic+norm_min_max">norm_min_max</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>norm_atan(rnorm(50))

</code></pre>

<hr>
<h2 id='norm_boxcox'>Two-parameter Box-Cox normalisation</h2><span id='topic+norm_boxcox'></span>

<h3>Description</h3>

<p>The <code>norm_boxcox</code> normalises time series by two-parameter Box-Cox normalisation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm_boxcox(x, lambda = 0.1, gamma = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="norm_boxcox_+3A_x">x</code></td>
<td>
<p>the numeric vector (time series)</p>
</td></tr>
<tr><td><code id="norm_boxcox_+3A_lambda">lambda</code></td>
<td>
<p>the numeric value - power transformation parameter (default is 0.1)</p>
</td></tr>
<tr><td><code id="norm_boxcox_+3A_gamma">gamma</code></td>
<td>
<p>the non-negative numeric value - parameter for holding the time series positive (offset) (default is 0)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the numeric vector of normalised values
</p>


<h3>Author(s)</h3>

<p>Peter Laurinec, &lt;tsreprpackage@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+norm_z">norm_z</a>, <a href="#topic+norm_min_max">norm_min_max</a>, <a href="#topic+norm_atan">norm_atan</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>norm_boxcox(runif(50))

</code></pre>

<hr>
<h2 id='norm_min_max'>Min-Max normalisation</h2><span id='topic+norm_min_max'></span>

<h3>Description</h3>

<p>The <code>norm_min_max</code> normalises time series by min-max method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm_min_max(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="norm_min_max_+3A_x">x</code></td>
<td>
<p>the numeric vector (time series)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the numeric vector of normalised values
</p>


<h3>Author(s)</h3>

<p>Peter Laurinec, &lt;tsreprpackage@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+norm_z">norm_z</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>norm_min_max(rnorm(50))

</code></pre>

<hr>
<h2 id='norm_min_max_list'>Min-Max normalization list</h2><span id='topic+norm_min_max_list'></span>

<h3>Description</h3>

<p>The <code>norm_min_max_list</code> normalises time series by min-max method and returns normalization parameters (min and max).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm_min_max_list(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="norm_min_max_list_+3A_x">x</code></td>
<td>
<p>the numeric vector (time series)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the list composed of:
</p>

<dl>
<dt><strong>norm_values</strong></dt><dd><p>the numeric vector of normalised values of time series</p>
</dd>
<dt><strong>min</strong></dt><dd><p>the min value</p>
</dd>
<dt><strong>max</strong></dt><dd><p>the max value</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Peter Laurinec, &lt;tsreprpackage@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+norm_z_list">norm_z_list</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>norm_min_max_list(rnorm(50))

</code></pre>

<hr>
<h2 id='norm_min_max_params'>Min-Max normalisation with parameters</h2><span id='topic+norm_min_max_params'></span>

<h3>Description</h3>

<p>The <code>norm_min_max_params</code> normalises time series by min-max method with defined parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm_min_max_params(x, min, max)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="norm_min_max_params_+3A_x">x</code></td>
<td>
<p>the numeric vector (time series)</p>
</td></tr>
<tr><td><code id="norm_min_max_params_+3A_min">min</code></td>
<td>
<p>the numeric value</p>
</td></tr>
<tr><td><code id="norm_min_max_params_+3A_max">max</code></td>
<td>
<p>the numeric value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the numeric vector of normalised values
</p>


<h3>Author(s)</h3>

<p>Peter Laurinec, &lt;tsreprpackage@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+norm_z_params">norm_z_params</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>norm_min_max_params(rnorm(50), 0, 1)

</code></pre>

<hr>
<h2 id='norm_yj'>Yeo-Johnson normalisation</h2><span id='topic+norm_yj'></span>

<h3>Description</h3>

<p>The <code>norm_yj</code> normalises time series by Yeo-Johnson normalisation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm_yj(x, lambda = 0.1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="norm_yj_+3A_x">x</code></td>
<td>
<p>the numeric vector (time series)</p>
</td></tr>
<tr><td><code id="norm_yj_+3A_lambda">lambda</code></td>
<td>
<p>the numeric value - power transformation parameter (default is 0.1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the numeric vector of normalised values
</p>


<h3>Author(s)</h3>

<p>Peter Laurinec, &lt;tsreprpackage@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+norm_z">norm_z</a>, <a href="#topic+norm_min_max">norm_min_max</a>, <a href="#topic+norm_boxcox">norm_boxcox</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>norm_yj(runif(50))

</code></pre>

<hr>
<h2 id='norm_z'>Z-score normalisation</h2><span id='topic+norm_z'></span>

<h3>Description</h3>

<p>The <code>norm_z</code> normalises time series by z-score.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm_z(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="norm_z_+3A_x">x</code></td>
<td>
<p>the numeric vector (time series)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the numeric vector of normalised values
</p>


<h3>Author(s)</h3>

<p>Peter Laurinec, &lt;tsreprpackage@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+norm_min_max">norm_min_max</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>norm_z(runif(50))

</code></pre>

<hr>
<h2 id='norm_z_list'>Z-score normalization list</h2><span id='topic+norm_z_list'></span>

<h3>Description</h3>

<p>The <code>norm_z_list</code> normalizes time series by z-score and returns normalization parameters (mean and standard deviation).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm_z_list(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="norm_z_list_+3A_x">x</code></td>
<td>
<p>the numeric vector (time series)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the list composed of:
</p>

<dl>
<dt><strong>norm_values</strong></dt><dd><p>the numeric vector of normalised values of time series</p>
</dd>
<dt><strong>mean</strong></dt><dd><p>the mean value</p>
</dd>
<dt><strong>sd</strong></dt><dd><p>the standard deviation</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Peter Laurinec, &lt;tsreprpackage@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+norm_min_max_list">norm_min_max_list</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>norm_z_list(runif(50))

</code></pre>

<hr>
<h2 id='norm_z_params'>Z-score normalisation with parameters</h2><span id='topic+norm_z_params'></span>

<h3>Description</h3>

<p>The <code>norm_z_params</code> normalises time series by z-score with defined mean and standard deviation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm_z_params(x, mean, sd)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="norm_z_params_+3A_x">x</code></td>
<td>
<p>the numeric vector (time series)</p>
</td></tr>
<tr><td><code id="norm_z_params_+3A_mean">mean</code></td>
<td>
<p>the numeric value</p>
</td></tr>
<tr><td><code id="norm_z_params_+3A_sd">sd</code></td>
<td>
<p>the numeric value - standard deviation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the numeric vector of normalised values
</p>


<h3>Author(s)</h3>

<p>Peter Laurinec, &lt;tsreprpackage@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+norm_min_max_params">norm_min_max_params</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>norm_z_params(runif(50), 0.5, 1)

</code></pre>

<hr>
<h2 id='repr_dct'>DCT representation</h2><span id='topic+repr_dct'></span>

<h3>Description</h3>

<p>The <code>repr_dct</code> computes DCT (Discrete Cosine Transform) representation from a time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repr_dct(x, coef = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repr_dct_+3A_x">x</code></td>
<td>
<p>the numeric vector (time series)</p>
</td></tr>
<tr><td><code id="repr_dct_+3A_coef">coef</code></td>
<td>
<p>the number of coefficients to extract from DCT</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The length of the final time series representation is equal to set <code>coef</code> parameter.
</p>


<h3>Value</h3>

<p>the numeric vector of DCT coefficients
</p>


<h3>Author(s)</h3>

<p>Peter Laurinec, &lt;tsreprpackage@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+repr_dft">repr_dft</a>, <a href="#topic+repr_dwt">repr_dwt</a>, <a href="dtt.html#topic+dtt">dtt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>repr_dct(rnorm(50), coef = 4)

</code></pre>

<hr>
<h2 id='repr_dft'>DFT representation by FFT</h2><span id='topic+repr_dft'></span>

<h3>Description</h3>

<p>The <code>repr_dft</code> computes DFT (Discrete Fourier Transform) representation from a time series by FFT (Fast Fourier Transform).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repr_dft(x, coef = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repr_dft_+3A_x">x</code></td>
<td>
<p>the numeric vector (time series)</p>
</td></tr>
<tr><td><code id="repr_dft_+3A_coef">coef</code></td>
<td>
<p>the number of coefficients to extract from FFT</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The length of the final time series representation is equal to set <code>coef</code> parameter.
</p>


<h3>Value</h3>

<p>the numeric vector of DFT coefficients
</p>


<h3>Author(s)</h3>

<p>Peter Laurinec, &lt;tsreprpackage@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+repr_dwt">repr_dwt</a>, <a href="#topic+repr_dct">repr_dct</a>, <a href="stats.html#topic+fft">fft</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>repr_dft(rnorm(50), coef = 4)

</code></pre>

<hr>
<h2 id='repr_dwt'>DWT representation</h2><span id='topic+repr_dwt'></span>

<h3>Description</h3>

<p>The <code>repr_dwt</code> computes DWT (Discrete Wavelet Transform) representation (coefficients) from a time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repr_dwt(x, level = 4, filter = "d4")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repr_dwt_+3A_x">x</code></td>
<td>
<p>the numeric vector (time series)</p>
</td></tr>
<tr><td><code id="repr_dwt_+3A_level">level</code></td>
<td>
<p>the level of DWT transformation (default is 4)</p>
</td></tr>
<tr><td><code id="repr_dwt_+3A_filter">filter</code></td>
<td>
<p>the filter name (default is &quot;d6&quot;).
Can be: &quot;haar&quot;, &quot;d4&quot;, &quot;d6&quot;, ..., &quot;d20&quot;, &quot;la8&quot;, &quot;la10&quot;, ..., &quot;la20&quot;, &quot;bl14&quot;, &quot;bl18&quot;, &quot;bl20&quot;,
&quot;c6&quot;, &quot;c12&quot;, ..., &quot;c30&quot;. See more info at <code><a href="wavelets.html#topic+wt.filter">wt.filter</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extracts DWT coefficients.
You can use various wavelet filters, see all of them here <code><a href="wavelets.html#topic+wt.filter">wt.filter</a></code>.
The number of extracted coefficients depends on the <code>level</code> selected.
The final representation has length equal to floor(n / 2^level), where n is a length of original time series.
</p>


<h3>Value</h3>

<p>the numeric vector of DWT coefficients
</p>


<h3>Author(s)</h3>

<p>Peter Laurinec, &lt;tsreprpackage@gmail.com&gt;
</p>


<h3>References</h3>

<p>Laurinec P, Lucka M (2016)
Comparison of representations of time series for clustering smart meter data.
In: Lecture Notes in Engineering and Computer Science: Proceedings of The World Congress on Engineering and Computer Science 2016, pp 458-463
</p>


<h3>See Also</h3>

<p><code><a href="#topic+repr_dft">repr_dft</a>, <a href="#topic+repr_dct">repr_dct</a>, <a href="wavelets.html#topic+dwt">dwt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Interpretation: DWT with Daubechies filter of length 4 and
# 3rd level of DWT coefficients extracted.
repr_dwt(rnorm(50), filter = "d4", level = 3)

</code></pre>

<hr>
<h2 id='repr_exp'>Exponential smoothing seasonal coefficients as representation</h2><span id='topic+repr_exp'></span>

<h3>Description</h3>

<p>The <code>repr_exp</code> computes exponential smoothing seasonal coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repr_exp(x, freq, alpha = TRUE, gamma = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repr_exp_+3A_x">x</code></td>
<td>
<p>the numeric vector (time series)</p>
</td></tr>
<tr><td><code id="repr_exp_+3A_freq">freq</code></td>
<td>
<p>the frequency of the time series</p>
</td></tr>
<tr><td><code id="repr_exp_+3A_alpha">alpha</code></td>
<td>
<p>the smoothing factor (default is TRUE - automatic determination of smoothing factor), or number between 0 to 1</p>
</td></tr>
<tr><td><code id="repr_exp_+3A_gamma">gamma</code></td>
<td>
<p>the seasonal smoothing factor (default is TRUE - automatic determination of seasonal smoothing factor), or number between 0 to 1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extracts exponential smoothing seasonal coefficients and uses them as time series representation.
You can set smoothing factors (<code>alpha, gamma</code>) manually, but recommended is automatic method (set to <code>TRUE</code>).
The trend component is not included in computations.
</p>


<h3>Value</h3>

<p>the numeric vector of seasonal coefficients
</p>


<h3>Author(s)</h3>

<p>Peter Laurinec, &lt;tsreprpackage@gmail.com&gt;
</p>


<h3>References</h3>

<p>Laurinec P, Lucka M (2016)
Comparison of representations of time series for clustering smart meter data.
In: Lecture Notes in Engineering and Computer Science: Proceedings of The World Congress on Engineering and Computer Science 2016, pp 458-463
</p>
<p>Laurinec P, Loderer M, Vrablecova P, Lucka M, Rozinajova V, Ezzeddine AB (2016)
Adaptive time series forecasting of energy consumption using optimized cluster analysis.
In: Data Mining Workshops (ICDMW), 2016 IEEE 16th International Conference on, IEEE, pp 398-405
</p>


<h3>See Also</h3>

<p><code><a href="#topic+repr_lm">repr_lm</a>, <a href="#topic+repr_gam">repr_gam</a>, <a href="#topic+repr_seas_profile">repr_seas_profile</a>,
<a href="stats.html#topic+HoltWinters">HoltWinters</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>repr_exp(rnorm(96), freq = 24)

</code></pre>

<hr>
<h2 id='repr_feaclip'>FeaClip representation of time series</h2><span id='topic+repr_feaclip'></span>

<h3>Description</h3>

<p>The <code>repr_feaclip</code> computes representation of time series based on feature extraction from bit-level (clipped) representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repr_feaclip(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repr_feaclip_+3A_x">x</code></td>
<td>
<p>the numeric vector (time series)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>FeaClip is method of time series representation based on feature extraction from run lengths (RLE) of bit-level (clipped) representation.
It extracts 8 key features from clipped representation.
</p>
<p>There are as follows: </p>
<p style="text-align: center;"><code class="reqn">repr   =  \{  max_1  -  max.  from  run  lengths  of  ones,</code>
</p>

<p style="text-align: center;"><code class="reqn">sum_1 -  sum  of  run  lengths  of  ones,</code>
</p>

<p style="text-align: center;"><code class="reqn">max_0  -  max.  from  run  lengths  of  zeros,</code>
</p>

<p style="text-align: center;"><code class="reqn">crossings  -  length  of  RLE  encoding  -  1,</code>
</p>

<p style="text-align: center;"><code class="reqn">f_0  -  number  of   first  zeros,</code>
</p>

<p style="text-align: center;"><code class="reqn">l_0  -  number  of  last  zeros,</code>
</p>

<p style="text-align: center;"><code class="reqn">f_1  -  number  of  first  ones,</code>
</p>

<p style="text-align: center;"><code class="reqn">l_1  -  number  of  last  ones  \}  .</code>
</p>



<h3>Value</h3>

<p>the numeric vector of length 8
</p>


<h3>Author(s)</h3>

<p>Peter Laurinec, &lt;tsreprpackage@gmail.com&gt;
</p>


<h3>References</h3>

<p>Laurinec P, and Lucka M (2018)
Interpretable multiple data streams clustering with clipped streams representation for the improvement of electricity consumption forecasting.
Data Mining and Knowledge Discovery. Springer. DOI: 10.1007/s10618-018-0598-2
</p>


<h3>See Also</h3>

<p><code><a href="#topic+repr_featrend">repr_featrend</a>, <a href="#topic+repr_feacliptrend">repr_feacliptrend</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>repr_feaclip(rnorm(50))

</code></pre>

<hr>
<h2 id='repr_feacliptrend'>FeaClipTrend representation of time series</h2><span id='topic+repr_feacliptrend'></span>

<h3>Description</h3>

<p>The <code>repr_feacliptrend</code> computes representation of time series
based on feature extraction from bit-level representations (clipping and trending).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repr_feacliptrend(x, func, pieces = 2L, order = 4L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repr_feacliptrend_+3A_x">x</code></td>
<td>
<p>the numeric vector (time series)</p>
</td></tr>
<tr><td><code id="repr_feacliptrend_+3A_func">func</code></td>
<td>
<p>the aggregation function for FeaTrend procedure (sumC or maxC)</p>
</td></tr>
<tr><td><code id="repr_feacliptrend_+3A_pieces">pieces</code></td>
<td>
<p>the number of parts of time series to split</p>
</td></tr>
<tr><td><code id="repr_feacliptrend_+3A_order">order</code></td>
<td>
<p>the order of simple moving average</p>
</td></tr>
</table>


<h3>Details</h3>

<p>FeaClipTrend combines FeaClip and FeaTrend representation methods.
See documentation of these two methods (check See Also section).
</p>


<h3>Value</h3>

<p>the numeric vector of frequencies of features
</p>


<h3>Author(s)</h3>

<p>Peter Laurinec, &lt;tsreprpackage@gmail.com&gt;
</p>


<h3>References</h3>

<p>Laurinec P, and Lucka M (2018)
Interpretable multiple data streams clustering with clipped streams representation for the improvement of electricity consumption forecasting.
Data Mining and Knowledge Discovery. Springer. DOI: 10.1007/s10618-018-0598-2
</p>


<h3>See Also</h3>

<p><code><a href="#topic+repr_featrend">repr_featrend</a>, <a href="#topic+repr_feaclip">repr_feaclip</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>repr_feacliptrend(rnorm(50), maxC, 2, 4)

</code></pre>

<hr>
<h2 id='repr_featrend'>FeaTrend representation of time series</h2><span id='topic+repr_featrend'></span>

<h3>Description</h3>

<p>The <code>repr_featrend</code> computes representation of time series based on feature extraction from bit-level (trending) representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repr_featrend(x, func, pieces = 2L, order = 4L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repr_featrend_+3A_x">x</code></td>
<td>
<p>the numeric vector (time series)</p>
</td></tr>
<tr><td><code id="repr_featrend_+3A_func">func</code></td>
<td>
<p>the function of aggregation, can be sumC or maxC or similar aggregation function</p>
</td></tr>
<tr><td><code id="repr_featrend_+3A_pieces">pieces</code></td>
<td>
<p>the number of parts of time series to split (default to 2)</p>
</td></tr>
<tr><td><code id="repr_featrend_+3A_order">order</code></td>
<td>
<p>the order of simple moving average (default to 4)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>FeaTrend is method of time series representation based on feature extraction from run lengths (RLE) of bit-level (trending) representation.
It extracts number of features from trending representation based on number of pieces defined.
From every piece, 2 features are extracted. You can define what feature will be extracted,
recommended functions are max and sum. For example if max is selected, then maximum value of run lengths of ones and zeros are extracted.
</p>


<h3>Value</h3>

<p>the numeric vector of the length pieces
</p>


<h3>Author(s)</h3>

<p>Peter Laurinec, &lt;tsreprpackage@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+repr_feaclip">repr_feaclip</a>, <a href="#topic+repr_feacliptrend">repr_feacliptrend</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># default settings
repr_featrend(rnorm(50), maxC)

# compute FeaTrend for 4 pieces and make more smoothed ts by order = 8
repr_featrend(rnorm(50), sumC, 4, 8)

</code></pre>

<hr>
<h2 id='repr_gam'>GAM regression coefficients as representation</h2><span id='topic+repr_gam'></span>

<h3>Description</h3>

<p>The <code>repr_gam</code> computes seasonal GAM regression coefficients. Additional exogenous variables can be also added.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repr_gam(x, freq = NULL, xreg = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repr_gam_+3A_x">x</code></td>
<td>
<p>the numeric vector (time series)</p>
</td></tr>
<tr><td><code id="repr_gam_+3A_freq">freq</code></td>
<td>
<p>the frequency of the time series. Can be vector of two frequencies (seasonalities) or just an integer of one frequency.</p>
</td></tr>
<tr><td><code id="repr_gam_+3A_xreg">xreg</code></td>
<td>
<p>the numeric vector or the data.frame with additional exogenous regressors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This model-based representation method extracts regression coefficients from a GAM (Generalized Additive Model).
The extraction of seasonal regression coefficients is automatic.
The maximum number of seasonalities is 2 so it is possible to compute representation for double-seasonal time series.
The first set seasonality (frequency) is main, so for example if we have hourly time series (<code>freq = c(24, 24*7)</code>),
the number of extracted daily seasonal coefficients is 24 and the number of
weekly seasonal coefficients is 7, because the length of second seasonality representation is always freq_1 / freq_2.
The smooth function for seasonal variables is set to cubic regression spline.
There is also possibility to add another independent variables (<code>xreg</code>).
</p>


<h3>Value</h3>

<p>the numeric vector of GAM regression coefficients
</p>


<h3>Author(s)</h3>

<p>Peter Laurinec, &lt;tsreprpackage@gmail.com&gt;
</p>


<h3>References</h3>

<p>Laurinec P, Lucka M (2016)
Comparison of representations of time series for clustering smart meter data.
In: Lecture Notes in Engineering and Computer Science: Proceedings of The World Congress on Engineering and Computer Science 2016, pp 458-463
</p>
<p>Laurinec P, Loderer M, Vrablecova P, Lucka M, Rozinajova V, Ezzeddine AB (2016)
Adaptive time series forecasting of energy consumption using optimized cluster analysis.
In: Data Mining Workshops (ICDMW), 2016 IEEE 16th International Conference on, IEEE, pp 398-405
</p>
<p>Laurinec P, Lucká M (2018)
Clustering-based forecasting method for individual consumers electricity load using time series representations.
Open Comput Sci, 8(1):38–50, DOI: 10.1515/comp-2018-0006
</p>


<h3>See Also</h3>

<p><code><a href="#topic+repr_lm">repr_lm</a>, <a href="#topic+repr_exp">repr_exp</a>, <a href="mgcv.html#topic+gam">gam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>repr_gam(rnorm(96), freq = 24)

</code></pre>

<hr>
<h2 id='repr_list'>Computation of list of representations list of time series with different lengths</h2><span id='topic+repr_list'></span>

<h3>Description</h3>

<p>The <code>repr_list</code> computes list of representations from list of time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repr_list(
  x,
  func = NULL,
  args = NULL,
  normalise = FALSE,
  func_norm = norm_z,
  windowing = FALSE,
  win_size = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repr_list_+3A_x">x</code></td>
<td>
<p>the list of time series, where time series can have different lengths</p>
</td></tr>
<tr><td><code id="repr_list_+3A_func">func</code></td>
<td>
<p>the function that computes representation</p>
</td></tr>
<tr><td><code id="repr_list_+3A_args">args</code></td>
<td>
<p>the list of additional (or required) parameters of func (function that computes representation)</p>
</td></tr>
<tr><td><code id="repr_list_+3A_normalise">normalise</code></td>
<td>
<p>normalise (scale) time series before representations computation? (default is FALSE)</p>
</td></tr>
<tr><td><code id="repr_list_+3A_func_norm">func_norm</code></td>
<td>
<p>the normalisation function (default is <code>norm_z</code>)</p>
</td></tr>
<tr><td><code id="repr_list_+3A_windowing">windowing</code></td>
<td>
<p>perform windowing? (default is FALSE)</p>
</td></tr>
<tr><td><code id="repr_list_+3A_win_size">win_size</code></td>
<td>
<p>the size of the window</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes representation to an every member of a list of time series (that can have different lengths) and returns list of time series representations.
It can be combined with windowing (see <code><a href="#topic+repr_windowing">repr_windowing</a></code>) and normalisation of time series.
</p>


<h3>Value</h3>

<p>the numeric list of representations of time series
</p>


<h3>Author(s)</h3>

<p>Peter Laurinec, &lt;tsreprpackage@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+repr_windowing">repr_windowing</a>, <a href="#topic+repr_matrix">repr_matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create random list of time series with different lengths
list_ts &lt;- list(rnorm(sample(8:12, 1)), rnorm(sample(8:12, 1)), rnorm(sample(8:12, 1)))
repr_list(list_ts, func = repr_sma,
 args = list(order = 3))

# return normalised representations, and normalise time series by min-max normalisation
repr_list(list_ts, func = repr_sma,
 args = list(order = 3), normalise = TRUE, func_norm = norm_min_max)

</code></pre>

<hr>
<h2 id='repr_lm'>Regression coefficients from linear model as representation</h2><span id='topic+repr_lm'></span>

<h3>Description</h3>

<p>The <code>repr_lm</code> computes seasonal regression coefficients from a linear model.
Additional exogenous variables can be also added.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repr_lm(x, freq = NULL, method = "lm", xreg = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repr_lm_+3A_x">x</code></td>
<td>
<p>the numeric vector (time series)</p>
</td></tr>
<tr><td><code id="repr_lm_+3A_freq">freq</code></td>
<td>
<p>the frequency of the time series. Can be vector of two frequencies (seasonalities) or just an integer of one frequency.</p>
</td></tr>
<tr><td><code id="repr_lm_+3A_method">method</code></td>
<td>
<p>the linear regression method to use. It can be &quot;lm&quot;, &quot;rlm&quot; or &quot;l1&quot;.</p>
</td></tr>
<tr><td><code id="repr_lm_+3A_xreg">xreg</code></td>
<td>
<p>the data.frame with additional exogenous regressors or the single numeric vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This model-based representation method extracts regression coefficients from a linear model.
The extraction of seasonal regression coefficients is automatic.
The maximum number of seasonalities is 2 so it is possible to compute representation for double-seasonal time series.
The first set seasonality (frequency) is main, so for example if we have hourly time series (<code>freq = c(24, 24*7)</code>),
the number of extracted daily seasonal coefficients is 24 and the number of
weekly seasonal coefficients is 7, because the length of second seasonality representation is always freq_1 / freq_2.
There is also possibility to add another independent variables (<code>xreg</code>).
</p>
<p>You have three possibilities for selection of a linear model method.
</p>

<ul>
<li><p> &quot;lm&quot; is classical OLS regression.
</p>
</li>
<li><p> &quot;rlm&quot; is robust linear model using psi huber function and is implemented in MASS package.
</p>
</li>
<li><p> &quot;l1&quot; is L1 quantile regression model (also robust linear regression method) implemented in package quantreg.
</p>
</li></ul>



<h3>Value</h3>

<p>the numeric vector of regression coefficients
</p>


<h3>Author(s)</h3>

<p>Peter Laurinec, &lt;tsreprpackage@gmail.com&gt;
</p>


<h3>References</h3>

<p>Laurinec P, Lucka M (2016)
Comparison of representations of time series for clustering smart meter data.
In: Lecture Notes in Engineering and Computer Science: Proceedings of The World Congress on Engineering and Computer Science 2016, pp 458-463
</p>
<p>Laurinec P, Loderer M, Vrablecova P, Lucka M, Rozinajova V, Ezzeddine AB (2016)
Adaptive time series forecasting of energy consumption using optimized cluster analysis.
In: Data Mining Workshops (ICDMW), 2016 IEEE 16th International Conference on, IEEE, pp 398-405
</p>
<p>Laurinec P, Lucká M (2018)
Clustering-based forecasting method for individual consumers electricity load using time series representations.
Open Comput Sci, 8(1):38–50, DOI: 10.1515/comp-2018-0006
</p>


<h3>See Also</h3>

<p><code><a href="#topic+repr_gam">repr_gam</a>, <a href="#topic+repr_exp">repr_exp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Extracts 24 seasonal regression coefficients from the time series by linear model
repr_lm(rnorm(96), freq = 24, method = "lm")

# Try also robust linear models ("rlm" and "l1")
repr_lm(rnorm(96), freq = 24, method = "rlm")
repr_lm(rnorm(96), freq = 24, method = "l1")

</code></pre>

<hr>
<h2 id='repr_matrix'>Computation of matrix of representations from matrix of time series</h2><span id='topic+repr_matrix'></span>

<h3>Description</h3>

<p>The <code>repr_matrix</code> computes matrix of representations from matrix of time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repr_matrix(
  x,
  func = NULL,
  args = NULL,
  normalise = FALSE,
  func_norm = norm_z,
  windowing = FALSE,
  win_size = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repr_matrix_+3A_x">x</code></td>
<td>
<p>the matrix, data.frame or data.table of time series, where time series are in rows of the table</p>
</td></tr>
<tr><td><code id="repr_matrix_+3A_func">func</code></td>
<td>
<p>the function that computes representation</p>
</td></tr>
<tr><td><code id="repr_matrix_+3A_args">args</code></td>
<td>
<p>the list of additional (or required) parameters of func (function that computes representation)</p>
</td></tr>
<tr><td><code id="repr_matrix_+3A_normalise">normalise</code></td>
<td>
<p>normalise (scale) time series before representations computation? (default is FALSE)</p>
</td></tr>
<tr><td><code id="repr_matrix_+3A_func_norm">func_norm</code></td>
<td>
<p>the normalisation function (default is <code>norm_z</code>)</p>
</td></tr>
<tr><td><code id="repr_matrix_+3A_windowing">windowing</code></td>
<td>
<p>perform windowing? (default is FALSE)</p>
</td></tr>
<tr><td><code id="repr_matrix_+3A_win_size">win_size</code></td>
<td>
<p>the size of the window</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes representation to an every row of a matrix of time series and returns matrix of time series representations.
It can be combined with windowing (see <code><a href="#topic+repr_windowing">repr_windowing</a></code>) and normalisation of time series.
</p>


<h3>Value</h3>

<p>the numeric matrix of representations of time series
</p>


<h3>Author(s)</h3>

<p>Peter Laurinec, &lt;tsreprpackage@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+repr_windowing">repr_windowing</a>, <a href="#topic+repr_list">repr_list</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create random matrix of time series
mat_ts &lt;- matrix(rnorm(100), ncol = 10)
repr_matrix(mat_ts, func = repr_paa,
 args = list(q = 5, func = meanC))

# return normalised representations, and normalise time series by min-max normalisation
repr_matrix(mat_ts, func = repr_paa,
 args = list(q = 2, func = meanC), normalise = TRUE, func_norm = norm_min_max)

# with windowing
repr_matrix(mat_ts, func = repr_feaclip, windowing = TRUE, win_size = 5)

</code></pre>

<hr>
<h2 id='repr_paa'>PAA - Piecewise Aggregate Approximation</h2><span id='topic+repr_paa'></span>

<h3>Description</h3>

<p>The <code>repr_paa</code> computes PAA representation from a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repr_paa(x, q, func)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repr_paa_+3A_x">x</code></td>
<td>
<p>the numeric vector (time series)</p>
</td></tr>
<tr><td><code id="repr_paa_+3A_q">q</code></td>
<td>
<p>the integer of the length of the &quot;piece&quot;</p>
</td></tr>
<tr><td><code id="repr_paa_+3A_func">func</code></td>
<td>
<p>the aggregation function. Can be meanC, medianC, sumC, minC or maxC or similar aggregation function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>PAA with possibility to use arbitrary aggregation function.
The original method uses average as aggregation function.
</p>


<h3>Value</h3>

<p>the numeric vector
</p>


<h3>Author(s)</h3>

<p>Peter Laurinec, &lt;tsreprpackage@gmail.com&gt;
</p>


<h3>References</h3>

<p>Keogh E, Chakrabarti K, Pazzani M, Mehrotra Sh (2001)
Dimensionality Reduction for Fast Similarity Search in Large Time Series Databases.
Knowledge and Information Systems 3(3):263-286
</p>


<h3>See Also</h3>

<p><code><a href="#topic+repr_dwt">repr_dwt</a>, <a href="#topic+repr_dft">repr_dft</a>, <a href="#topic+repr_dct">repr_dct</a>, <a href="#topic+repr_sma">repr_sma</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>repr_paa(rnorm(11), 2, meanC)

</code></pre>

<hr>
<h2 id='repr_pip'>PIP representation</h2><span id='topic+repr_pip'></span>

<h3>Description</h3>

<p>The <code>repr_pip</code> computes PIP (Perceptually Important Points) representation from a time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repr_pip(x, times = 10, return = "points")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repr_pip_+3A_x">x</code></td>
<td>
<p>the numeric vector (time series)</p>
</td></tr>
<tr><td><code id="repr_pip_+3A_times">times</code></td>
<td>
<p>the number of important points to extract (default 10)</p>
</td></tr>
<tr><td><code id="repr_pip_+3A_return">return</code></td>
<td>
<p>what to return? Can be important points (&quot;points&quot;),
places of important points in a vector (&quot;places&quot;) or &quot;both&quot; (data.frame).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the values based on the argument return (see above)
</p>


<h3>Author(s)</h3>

<p>Peter Laurinec, &lt;tsreprpackage@gmail.com&gt;
</p>


<h3>References</h3>

<p>Fu TC, Chung FL, Luk R, and Ng CM (2008)
Representing financial time series based on data point importance.
Engineering Applications of Artificial Intelligence, 21(2):277-300
</p>


<h3>Examples</h3>

<pre><code class='language-R'>repr_pip(rnorm(100), times = 12, return = "both")

</code></pre>

<hr>
<h2 id='repr_pla'>PLA representation</h2><span id='topic+repr_pla'></span>

<h3>Description</h3>

<p>The <code>repr_pla</code> computes PLA (Piecewise Linear Approximation) representation from a time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repr_pla(x, times = 10, return = "points")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repr_pla_+3A_x">x</code></td>
<td>
<p>the numeric vector (time series)</p>
</td></tr>
<tr><td><code id="repr_pla_+3A_times">times</code></td>
<td>
<p>the number of important points to extract (default 10)</p>
</td></tr>
<tr><td><code id="repr_pla_+3A_return">return</code></td>
<td>
<p>what to return? Can be &quot;points&quot; (segments),
places of points (segments) in a vector (&quot;places&quot;) or &quot;both&quot; (data.frame).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the values based on the argument return (see above)
</p>


<h3>Author(s)</h3>

<p>Peter Laurinec, &lt;tsreprpackage@gmail.com&gt;
</p>


<h3>References</h3>

<p>Zhu Y, Wu D, Li Sh (2007)
A Piecewise Linear Representation Method of Time Series Based on Feature Points.
Knowledge-Based Intelligent Information and Engineering Systems 4693:1066-1072
</p>


<h3>Examples</h3>

<pre><code class='language-R'>repr_pla(rnorm(100), times = 12, return = "both")

</code></pre>

<hr>
<h2 id='repr_sax'>SAX - Symbolic Aggregate Approximation</h2><span id='topic+repr_sax'></span>

<h3>Description</h3>

<p>The <code>repr_sax</code> creates SAX symbols for a univariate time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repr_sax(x, q = 2, a = 6, eps = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repr_sax_+3A_x">x</code></td>
<td>
<p>the numeric vector (time series)</p>
</td></tr>
<tr><td><code id="repr_sax_+3A_q">q</code></td>
<td>
<p>the integer of the length of the &quot;piece&quot; in PAA</p>
</td></tr>
<tr><td><code id="repr_sax_+3A_a">a</code></td>
<td>
<p>the integer of the alphabet size</p>
</td></tr>
<tr><td><code id="repr_sax_+3A_eps">eps</code></td>
<td>
<p>is the minimum threshold for variance in x and should be a numeric value. If x has a smaller variance than eps, it will represented as a word using the middle alphabet.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the character vector of SAX representation
</p>


<h3>Author(s)</h3>

<p>Peter Laurinec, &lt;tsreprpackage@gmail.com&gt;
</p>


<h3>References</h3>

<p>Lin J, Keogh E, Lonardi S, Chiu B (2003)
A symbolic representation of time series, with implications for streaming algorithms.
Proceedings of the 8th ACM SIGMOD Workshop on Research Issues in Data Mining and Knowledge Discovery - DMKD'03
</p>


<h3>See Also</h3>

<p><code><a href="#topic+repr_paa">repr_paa</a>, <a href="#topic+repr_pla">repr_pla</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(48)
repr_sax(x, q = 4, a = 5)

</code></pre>

<hr>
<h2 id='repr_seas_profile'>Mean seasonal profile of time series</h2><span id='topic+repr_seas_profile'></span>

<h3>Description</h3>

<p>The <code>repr_seas_profile</code> computes mean seasonal profile representation from a time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repr_seas_profile(x, freq, func)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repr_seas_profile_+3A_x">x</code></td>
<td>
<p>the numeric vector (time series)</p>
</td></tr>
<tr><td><code id="repr_seas_profile_+3A_freq">freq</code></td>
<td>
<p>the integer of the length of the season</p>
</td></tr>
<tr><td><code id="repr_seas_profile_+3A_func">func</code></td>
<td>
<p>the aggregation function. Can be meanC or medianC or similar aggregation function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes mean seasonal profile representation for a seasonal time series.
The length of representation is length of set seasonality (frequency) of a time series.
Aggregation function is arbitrary (best choice is for you maybe mean or median).
</p>


<h3>Value</h3>

<p>the numeric vector
</p>


<h3>Author(s)</h3>

<p>Peter Laurinec, &lt;tsreprpackage@gmail.com&gt;
</p>


<h3>References</h3>

<p>Laurinec P, Lucka M (2016)
Comparison of representations of time series for clustering smart meter data.
In: Lecture Notes in Engineering and Computer Science: Proceedings of The World Congress on Engineering and Computer Science 2016, pp 458-463
</p>
<p>Laurinec P, Loderer M, Vrablecova P, Lucka M, Rozinajova V, Ezzeddine AB (2016)
Adaptive time series forecasting of energy consumption using optimized cluster analysis.
In: Data Mining Workshops (ICDMW), 2016 IEEE 16th International Conference on, IEEE, pp 398-405
</p>
<p>Laurinec P, Lucká M (2018)
Clustering-based forecasting method for individual consumers electricity load using time series representations.
Open Comput Sci, 8(1):38–50, DOI: 10.1515/comp-2018-0006
</p>


<h3>See Also</h3>

<p><code><a href="#topic+repr_lm">repr_lm</a>, <a href="#topic+repr_gam">repr_gam</a>, <a href="#topic+repr_exp">repr_exp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>repr_seas_profile(rnorm(48*10), 48, meanC)

</code></pre>

<hr>
<h2 id='repr_sma'>Simple Moving Average representation</h2><span id='topic+repr_sma'></span>

<h3>Description</h3>

<p>The <code>repr_sma</code> computes Simple Moving Average (SMA) from a time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repr_sma(x, order)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repr_sma_+3A_x">x</code></td>
<td>
<p>the numeric vector (time series)</p>
</td></tr>
<tr><td><code id="repr_sma_+3A_order">order</code></td>
<td>
<p>the order of simple moving average</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the numeric vector of smoothed values of the length = length(x) - order + 1
</p>


<h3>Author(s)</h3>

<p>Peter Laurinec, &lt;tsreprpackage@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>repr_sma(rnorm(50), 4)

</code></pre>

<hr>
<h2 id='repr_windowing'>Windowing of time series</h2><span id='topic+repr_windowing'></span>

<h3>Description</h3>

<p>The <code>repr_windowing</code> computes representations from windows of a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repr_windowing(x, win_size, func = NULL, args = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repr_windowing_+3A_x">x</code></td>
<td>
<p>the numeric vector (time series)</p>
</td></tr>
<tr><td><code id="repr_windowing_+3A_win_size">win_size</code></td>
<td>
<p>the length of the window</p>
</td></tr>
<tr><td><code id="repr_windowing_+3A_func">func</code></td>
<td>
<p>the function for representation computation. For example <code>repr_feaclip</code> or <code>repr_trend</code>.</p>
</td></tr>
<tr><td><code id="repr_windowing_+3A_args">args</code></td>
<td>
<p>the list of additional arguments to the func (representation computation function). The args list must be named.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function applies specified representation method (function) to every non-overlapping window (subsequence, piece) of a time series.
</p>


<h3>Value</h3>

<p>the numeric vector
</p>


<h3>Author(s)</h3>

<p>Peter Laurinec, &lt;tsreprpackage@gmail.com&gt;
</p>


<h3>References</h3>

<p>Laurinec P, and Lucka M (2018)
Interpretable multiple data streams clustering with clipped streams representation for the improvement of electricity consumption forecasting.
Data Mining and Knowledge Discovery. Springer. DOI: 10.1007/s10618-018-0598-2
</p>


<h3>See Also</h3>

<p><code><a href="#topic+repr_paa">repr_paa</a>, <a href="#topic+repr_matrix">repr_matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># func without arguments
repr_windowing(rnorm(48), win_size = 24, func = repr_feaclip)

# func with arguments
repr_windowing(rnorm(48), win_size = 24, func = repr_featrend,
 args = list(func = maxC, order = 2, pieces = 2))

</code></pre>

<hr>
<h2 id='rleC'>RLE (Run Length Encoding) written in C++</h2><span id='topic+rleC'></span>

<h3>Description</h3>

<p>The <code>rleC</code> computes RLE from bit-level (clipping or trending representation) vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rleC(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rleC_+3A_x">x</code></td>
<td>
<p>the integer vector (from <code>clipping</code> or <code>trending</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the list of values and counts of zeros and ones
</p>


<h3>Examples</h3>

<pre><code class='language-R'># clipping
clipped &lt;- clipping(rnorm(50))
rleC(clipped)
# trending
trended &lt;- trending(rnorm(50))
rleC(trended)

</code></pre>

<hr>
<h2 id='rmse'>RMSE</h2><span id='topic+rmse'></span>

<h3>Description</h3>

<p>The <code>rmse</code> computes RMSE (Root Mean Squared Error) of a forecast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmse(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rmse_+3A_x">x</code></td>
<td>
<p>the numeric vector of real values</p>
</td></tr>
<tr><td><code id="rmse_+3A_y">y</code></td>
<td>
<p>the numeric vector of forecasted values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the numeric value
</p>


<h3>Author(s)</h3>

<p>Peter Laurinec, &lt;tsreprpackage@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rmse(runif(50), runif(50))

</code></pre>

<hr>
<h2 id='smape'>sMAPE</h2><span id='topic+smape'></span>

<h3>Description</h3>

<p>The <code>smape</code> computes sMAPE (Symmetric Mean Absolute Percentage Error) of a forecast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smape(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smape_+3A_x">x</code></td>
<td>
<p>the numeric vector of real values</p>
</td></tr>
<tr><td><code id="smape_+3A_y">y</code></td>
<td>
<p>the numeric vector of forecasted values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the numeric value in %
</p>


<h3>Author(s)</h3>

<p>Peter Laurinec, &lt;tsreprpackage@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>smape(runif(50), runif(50))

</code></pre>

<hr>
<h2 id='trending'>Creates bit-level (trending) representation from a vector</h2><span id='topic+trending'></span>

<h3>Description</h3>

<p>The <code>trending</code> Computes bit-level (trending) representation from a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trending(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trending_+3A_x">x</code></td>
<td>
<p>the numeric vector (time series)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Trending transforms time series to bit-level representation.
</p>
<p>It is defined as follows:
</p>
<p style="text-align: center;"><code class="reqn">repr_t   =   {1   if   x_t  -  x_{t+1}  &lt;  0 ,  0   otherwise,}</code>
</p>

<p>where <code class="reqn">x_t</code> is a value of a time series.
</p>


<h3>Value</h3>

<p>the integer vector of zeros and ones
</p>


<h3>Author(s)</h3>

<p>Peter Laurinec, &lt;tsreprpackage@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clipping">clipping</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trending(rnorm(50))

</code></pre>

<hr>
<h2 id='TSrepr'>TSrepr package</h2><span id='topic+TSrepr'></span>

<h3>Description</h3>

<p>Package contains methods for time series representations computation.
Representation methods of time series are for dimensionality and noise reduction,
emphasizing of main characteristics of time series data and speed up of consequent usage of machine learning methods.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;"> Package: </td><td style="text-align: left;"> TSrepr</td>
</tr>
<tr>
 <td style="text-align: left;"> Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;"> Date: </td><td style="text-align: left;">
2018-01-26 - Inf</td>
</tr>
<tr>
 <td style="text-align: left;"> License: </td><td style="text-align: left;"> GPL-3 </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>

<p>The following functions for time series representations are included in the package:
</p>

<ul>
<li> <p><a href="#topic+repr_paa">repr_paa</a> - Piecewise Aggregate Approximation (PAA)
</p>
</li>
<li> <p><a href="#topic+repr_dwt">repr_dwt</a> - Discrete Wavelet Transform (DWT)
</p>
</li>
<li> <p><a href="#topic+repr_dft">repr_dft</a> - Discrete Fourier Transform (DFT)
</p>
</li>
<li> <p><a href="#topic+repr_dct">repr_dct</a> - Discrete Cosine Transform (DCT)
</p>
</li>
<li> <p><a href="#topic+repr_sma">repr_sma</a> - Simple Moving Average (SMA)
</p>
</li>
<li> <p><a href="#topic+repr_pip">repr_pip</a> - Perceptually Important Points (PIP)
</p>
</li>
<li> <p><a href="#topic+repr_sax">repr_sax</a> - Symbolic Aggregate Approximation (SAX)
</p>
</li>
<li> <p><a href="#topic+repr_pla">repr_pla</a> - Piecewise Linear Approximation (PLA)
</p>
</li>
<li> <p><a href="#topic+repr_seas_profile">repr_seas_profile</a> - Mean seasonal profile
</p>
</li>
<li> <p><a href="#topic+repr_lm">repr_lm</a> - Model-based seasonal representations based on linear model (lm, rlm, l1)
</p>
</li>
<li> <p><a href="#topic+repr_gam">repr_gam</a> - Model-based seasonal representations based on generalized additive model (GAM)
</p>
</li>
<li> <p><a href="#topic+repr_exp">repr_exp</a> - Exponential smoothing seasonal coefficients
</p>
</li>
<li> <p><a href="#topic+repr_feaclip">repr_feaclip</a> - Feature extraction from clipping representation (FeaClip)
</p>
</li>
<li> <p><a href="#topic+repr_featrend">repr_featrend</a> - Feature extraction from trending representation (FeaTrend)
</p>
</li>
<li> <p><a href="#topic+repr_feacliptrend">repr_feacliptrend</a> - Feature extraction from clipping and trending representation (FeaClipTrend)
</p>
</li></ul>

<p>There are also implemented additional useful functions as:
</p>

<ul>
<li> <p><a href="#topic+repr_windowing">repr_windowing</a> - applies above mentioned representations to every window of a time series
</p>
</li>
<li> <p><a href="#topic+repr_matrix">repr_matrix</a> - applies above mentioned representations to every row of a matrix of time series
</p>
</li>
<li> <p><a href="#topic+repr_list">repr_list</a> - applies above mentioned representations to every member of a list of time series
</p>
</li>
<li> <p><a href="#topic+norm_z">norm_z</a>, <a href="#topic+norm_min_max">norm_min_max</a>, <a href="#topic+norm_boxcox">norm_boxcox</a>, <a href="#topic+norm_yj">norm_yj</a>, <a href="#topic+norm_atan">norm_atan</a>  - normalisation functions
</p>
</li>
<li> <p><a href="#topic+norm_z_params">norm_z_params</a>, <a href="#topic+norm_min_max_params">norm_min_max_params</a> - normalisation functions with defined parameters
</p>
</li>
<li> <p><a href="#topic+norm_z_list">norm_z_list</a>, <a href="#topic+norm_min_max_list">norm_min_max_list</a> - normalisation functions with output also of scaling parameters
</p>
</li>
<li> <p><a href="#topic+denorm_z">denorm_z</a>, <a href="#topic+denorm_min_max">denorm_min_max</a>, <a href="#topic+denorm_boxcox">denorm_boxcox</a>, <a href="#topic+denorm_yj">denorm_yj</a>, <a href="#topic+denorm_atan">denorm_atan</a> - denormalisation functions
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Peter Laurinec
</p>
<p>Maintainer: Peter Laurinec &lt;tsreprpackage@gmail.com&gt;
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
