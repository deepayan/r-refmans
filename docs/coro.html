<!DOCTYPE html><html lang="en"><head><title>Help for package coro</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {coro}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coro-package'><p>coro: 'Coroutines' for R</p></a></li>
<li><a href='#as_iterator'><p>Transform an object to an iterator</p></a></li>
<li><a href='#async'><p>Make an async function</p></a></li>
<li><a href='#async_collect'><p>Collect elements of an asynchronous iterator</p></a></li>
<li><a href='#async_generator'><p>Construct an async generator</p></a></li>
<li><a href='#async_ops'><p>Async operations</p></a></li>
<li><a href='#async_sleep'><p>Sleep asynchronously</p></a></li>
<li><a href='#collect'><p>Iterate over iterator functions</p></a></li>
<li><a href='#coro_debug'><p>Debug a generator or async function</p></a></li>
<li><a href='#generator'><p>Create a generator function</p></a></li>
<li><a href='#iterator'><p>Iterator protocol</p></a></li>
<li><a href='#yield'><p>Yield a value from a generator</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>'Coroutines' for R</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides 'coroutines' for R, a family of functions that can
    be suspended and resumed later on. This includes 'async' functions
    (which await) and generators (which yield). 'Async' functions are
    based on the concurrency framework of the 'promises' package.
    Generators are based on a dependency free iteration protocol defined
    in 'coro' and are compatible with iterators from the 'reticulate'
    package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/r-lib/coro">https://github.com/r-lib/coro</a>, <a href="https://coro.r-lib.org/">https://coro.r-lib.org/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-lib/coro/issues">https://github.com/r-lib/coro/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>rlang (&ge; 0.4.12)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, later (&ge; 1.1.0), magrittr (&ge; 2.0.0), promises,
reticulate, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse/tidytemplate</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-05 09:54:43 UTC; lionel</td>
</tr>
<tr>
<td>Author:</td>
<td>Lionel Henry [aut, cre],
  Posit Software, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lionel Henry &lt;lionel@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-05 10:30:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='coro-package'>coro: 'Coroutines' for R</h2><span id='topic+coro'></span><span id='topic+coro-package'></span>

<h3>Description</h3>

<p>Provides 'coroutines' for R, a family of functions that can be suspended and resumed later on. This includes 'async' functions (which await) and generators (which yield). 'Async' functions are based on the concurrency framework of the 'promises' package. Generators are based on a dependency free iteration protocol defined in 'coro' and are compatible with iterators from the 'reticulate' package.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Lionel Henry <a href="mailto:lionel@posit.co">lionel@posit.co</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Posit Software, PBC [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/r-lib/coro">https://github.com/r-lib/coro</a>
</p>
</li>
<li> <p><a href="https://coro.r-lib.org/">https://coro.r-lib.org/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/r-lib/coro/issues">https://github.com/r-lib/coro/issues</a>
</p>
</li></ul>


<hr>
<h2 id='as_iterator'>Transform an object to an iterator</h2><span id='topic+as_iterator'></span><span id='topic+as_iterator.default'></span>

<h3>Description</h3>

<p><code>as_iterator()</code> is a generic function that transforms its input to
an <a href="#topic+iterator">iterator function</a>. The default implementation
is as follows:
</p>

<ul>
<li><p> Functions are returned as is.
</p>
</li>
<li><p> Other objects are assumed to be vectors with <code>length()</code> and <code>[[</code>
methods.
</p>
</li></ul>

<p>Methods must return functions that implement coro's <a href="#topic+iterator">iterator protocol</a>.
</p>
<p><code>as_iterator()</code> is called by coro on the RHS of <code style="white-space: pre;">&#8288;in&#8288;</code> in <code>for</code>
loops. This applies within <a href="#topic+generator">generators</a>, <a href="#topic+async">async functions</a>, and <code><a href="#topic+loop">loop()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_iterator(x)

## Default S3 method:
as_iterator(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_iterator_+3A_x">x</code></td>
<td>
<p>An object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An iterable function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as_iterator(1:3)

i &lt;- as_iterator(1:3)
loop(for (x in i) print(x))
</code></pre>

<hr>
<h2 id='async'>Make an async function</h2><span id='topic+async'></span><span id='topic+await'></span>

<h3>Description</h3>

<p><code>async()</code> functions are building blocks for cooperative
concurrency.
</p>

<ul>
<li><p> They are <em>concurrent</em> because they are jointly managed by a
scheduler in charge of running them.
</p>
</li>
<li><p> They are <em>cooperative</em> because they decide on their own when they
can no longer make quick progress and need to <strong>await</strong> some
result. This is done with the <code>await()</code> keyword which suspends
the async function and gives control back to the scheduler. The
scheduler waits until the next async operation is ready to make
progress.
</p>
</li></ul>

<p>The async framework used by <code>async()</code> functions is implemented in
the <a href="https://github.com/r-lib/later/">later</a> and
<a href="https://rstudio.github.io/promises/">promises</a> packages:
</p>

<ul>
<li><p> You can chain async functions created with coro to promises.
</p>
</li>
<li><p> You can await promises. You can also await futures created with
the <a href="https://github.com/HenrikBengtsson/future">future</a> package
because they are coercible to promises.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>async(fn)

await(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="async_+3A_fn">fn</code></td>
<td>
<p>An anonymous function within which <code>await()</code> calls are
allowed.</p>
</td></tr>
<tr><td><code id="async_+3A_x">x</code></td>
<td>
<p>An awaitable value, i.e. a <a href="promises.html#topic+promise">promise</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function that returns a <code><a href="promises.html#topic+promise">promises::promise()</a></code> invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+async_generator">async_generator()</a></code> and <code><a href="#topic+await_each">await_each()</a></code>;
<code><a href="#topic+coro_debug">coro_debug()</a></code> for step-debugging.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This async function counts down from `n`, sleeping for 2 seconds
# at each iteration:
async_count_down &lt;- async(function(n) {
  while (n &gt; 0) {
    cat("Down", n, "\n")
    await(async_sleep(2))
    n &lt;- n - 1
  }
})

# This async function counts up until `stop`, sleeping for 0.5
# seconds at each iteration:
async_count_up &lt;- async(function(stop) {
  n &lt;- 1
  while (n &lt;= stop) {
    cat("Up", n, "\n")
    await(async_sleep(0.5))
    n &lt;- n + 1
  }
})

# You can run these functions concurrently using `promise_all()`
if (interactive()) {
  promises::promise_all(async_count_down(5), async_count_up(5))
}
</code></pre>

<hr>
<h2 id='async_collect'>Collect elements of an asynchronous iterator</h2><span id='topic+async_collect'></span>

<h3>Description</h3>

<p><code>async_collect()</code> takes an asynchronous iterator, i.e. an iterable
function that is also awaitable. <code>async_collect()</code> returns an
awaitable that eventually resolves to a list containing the values
returned by the iterator. The values are collected until exhaustion
unless <code>n</code> is supplied. The collection is grown geometrically for
performance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>async_collect(x, n = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="async_collect_+3A_x">x</code></td>
<td>
<p>An iterator function.</p>
</td></tr>
<tr><td><code id="async_collect_+3A_n">n</code></td>
<td>
<p>The number of elements to collect. If <code>x</code> is an infinite
sequence, <code>n</code> must be supplied to prevent an infinite loop.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Emulate an async stream by yielding promises that resolve to the
# elements of the input vector
generate_stream &lt;- async_generator(function(x) for (elt in x) yield(elt))

# You can await `async_collect()` in an async function. Once the
# list of values is resolved, the async function resumes.
async(function() {
  stream &lt;- generate_stream(1:3)
  values &lt;- await(async_collect(stream))
  values
})
</code></pre>

<hr>
<h2 id='async_generator'>Construct an async generator</h2><span id='topic+async_generator'></span><span id='topic+await_each'></span>

<h3>Description</h3>

<p>An async generator constructs iterable functions that are also
awaitables. They support both the <code>yield()</code> and <code>await()</code> syntax.
An async iterator can be looped within async functions and
iterators using <code>await_each()</code> on the input of a <code>for</code> loop.
</p>
<p>The iteration protocol is derived from the one described in
<code><a href="#topic+iterator">iterator</a></code>. An async iterator always returns a
promise. When the iterator is exhausted, it returns a resolved
promise to the exhaustion sentinel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>async_generator(fn)

await_each(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="async_generator_+3A_fn">fn</code></td>
<td>
<p>An anonymous function describing an async generator
within which <code>await()</code> calls are allowed.</p>
</td></tr>
<tr><td><code id="async_generator_+3A_x">x</code></td>
<td>
<p>An awaitable value, i.e. a <a href="promises.html#topic+promise">promise</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A generator factory. Generators constructed with this
factory always return <code><a href="promises.html#topic+promise">promises::promise()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+async">async()</a></code> for creating awaitable functions;
<code><a href="#topic+async_collect">async_collect()</a></code> for collecting the values of an async iterator;
<code><a href="#topic+coro_debug">coro_debug()</a></code> for step-debugging.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creates awaitable functions that transform their inputs into a stream
generate_stream &lt;- async_generator(function(x) for (elt in x) yield(elt))

# Maps a function to a stream
async_map &lt;- async_generator(function(.i, .fn, ...) {
  for (elt in await_each(.i)) {
    yield(.fn(elt, ...))
  }
})

# Example usage:
if (interactive()) {
  library(magrittr)
  generate_stream(1:3) %&gt;% async_map(`*`, 2) %&gt;% async_collect()
}
</code></pre>

<hr>
<h2 id='async_ops'>Async operations</h2><span id='topic+async_ops'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Customisation point for the <em>async</em> package or any concurrency
framework that defines a &quot;then&quot; operation. Assign the result of
<code>async_ops()</code> to the <code>.__coro_async_ops__.</code> symbol in your
namespace.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>async_ops(package, then, as_promise)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="async_ops_+3A_package">package</code></td>
<td>
<p>The package name of the framework as a
string. <code>async()</code> and <code>async_generator()</code> check that the package
is installed at runtime.</p>
</td></tr>
<tr><td><code id="async_ops_+3A_then">then</code></td>
<td>
<p>A function of two arguments. The first argument is a
promise object (as created by <code>as_promise</code>). The second argument
is a callback function that must be called once the promise
object is resolved.</p>
</td></tr>
<tr><td><code id="async_ops_+3A_as_promise">as_promise</code></td>
<td>
<p>A function of one argument. It should be a no-op
when passed a promise object, and otherwise wrap the value in a
resolved promise.</p>
</td></tr>
</table>

<hr>
<h2 id='async_sleep'>Sleep asynchronously</h2><span id='topic+async_sleep'></span>

<h3>Description</h3>

<p>Sleep asynchronously
</p>


<h3>Usage</h3>

<pre><code class='language-R'>async_sleep(seconds)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="async_sleep_+3A_seconds">seconds</code></td>
<td>
<p>The number of second to sleep.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A chainable promise.
</p>

<hr>
<h2 id='collect'>Iterate over iterator functions</h2><span id='topic+collect'></span><span id='topic+loop'></span>

<h3>Description</h3>

<p><code>loop()</code> and <code>collect()</code> are helpers for iterating over
<a href="#topic+iterator">iterator functions</a> such as <a href="#topic+generator">generators</a>.
</p>

<ul>
<li> <p><code>loop()</code> takes a <code>for</code> loop expression in which the collection
can be an iterator function.
</p>
</li>
<li> <p><code>collect()</code> loops over the iterator and collects the values in a
list.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>collect(x, n = NULL)

loop(loop)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="collect_+3A_x">x</code></td>
<td>
<p>An iterator function.</p>
</td></tr>
<tr><td><code id="collect_+3A_n">n</code></td>
<td>
<p>The number of elements to collect. If <code>x</code> is an infinite
sequence, <code>n</code> must be supplied to prevent an infinite loop.</p>
</td></tr>
<tr><td><code id="collect_+3A_loop">loop</code></td>
<td>
<p>A <code>for</code> loop expression.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>collect()</code> returns a list of values; <code>loop()</code> returns
the <code><a href="#topic+exhausted">exhausted()</a></code> sentinel, invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+async_collect">async_collect()</a></code> for async generators.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>generate_abc &lt;- generator(function() for (x in letters[1:3]) yield(x))
abc &lt;- generate_abc()

# Collect 1 element:
collect(abc, n = 1)

# Collect all remaining elements:
collect(abc)

# With exhausted iterators collect() returns an empty list:
collect(abc)


# With loop() you can use `for` loops with iterators:
abc &lt;- generate_abc()
loop(for (x in abc) print(x))
</code></pre>

<hr>
<h2 id='coro_debug'>Debug a generator or async function</h2><span id='topic+coro_debug'></span>

<h3>Description</h3>


<ul>
<li><p> Call <code>coro_debug()</code> on a <code><a href="#topic+generator">generator()</a></code>, <code><a href="#topic+async">async()</a></code>, or
<code><a href="#topic+async_generator">async_generator()</a></code> function to enable step-debugging.
</p>
</li>
<li><p> Alternatively, set <code>options(coro_debug = TRUE)</code> for
step-debugging through all functions created with coro.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>coro_debug(fn, value = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coro_debug_+3A_fn">fn</code></td>
<td>
<p>A generator factory or an async function.</p>
</td></tr>
<tr><td><code id="coro_debug_+3A_value">value</code></td>
<td>
<p>Whether to debug the function.</p>
</td></tr>
</table>

<hr>
<h2 id='generator'>Create a generator function</h2><span id='topic+generator'></span><span id='topic+gen'></span>

<h3>Description</h3>

<p><code>generator()</code> creates an generator factory. A generator is an
<a href="#topic+iterator">iterator function</a> that can pause its execution with
<code><a href="#topic+yield">yield()</a></code> and resume from where it left off. Because they manage
state for you, generators are the easiest way to create
iterators. See <code>vignette("generator")</code>.
</p>
<p>The following rules apply:
</p>

<ul>
<li><p> Yielded values do not terminate the generator. If you call the
generator again, the execution resumes right after the yielding
point. All local variables are preserved.
</p>
</li>
<li><p> Returned values terminate the generator. If called again after a
<code>return()</code>, the generator keeps returning the <code><a href="#topic+exhausted">exhausted()</a></code>
sentinel.
</p>
</li></ul>

<p>Generators are compatible with all features based on the iterator
protocol such as <code><a href="#topic+loop">loop()</a></code> and <code><a href="#topic+collect">collect()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generator(fn)

gen(expr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generator_+3A_fn">fn</code></td>
<td>
<p>A function template for generators. The function can
<code><a href="#topic+yield">yield()</a></code> values. Within a generator, <code>for</code> loops have
<a href="#topic+iterator">iterator</a> support.</p>
</td></tr>
<tr><td><code id="generator_+3A_expr">expr</code></td>
<td>
<p>A yielding expression.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+yield">yield()</a></code>, <code><a href="#topic+coro_debug">coro_debug()</a></code> for step-debugging.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A generator statement creates a generator factory. The
# following generator yields three times and then returns `"d"`.
# Only the yielded values are visible to the callers.
generate_abc &lt;- generator(function() {
  yield("a")
  yield("b")
  yield("c")
  "d"
})

# Equivalently:
generate_abc &lt;- generator(function() {
  for (x in c("a", "b", "c")) {
    yield(x)
  }
})

# The factory creates generator instances. They are iterators
# that you can call successively to obtain new values:
abc &lt;- generate_abc()
abc()
abc()

# Once a generator has returned it keeps returning `exhausted()`.
# This signals to its caller that new values can no longer be
# produced. The generator is exhausted:
abc()
abc()

# You can only exhaust a generator once but you can always create
# new ones from a factory:
abc &lt;- generate_abc()
abc()


# As generators implement the coro iteration protocol, you can use
# coro tools like `loop()`. It makes it possible to loop over
# iterators with `for` expressions:
loop(for (x in abc) print(x))

# To gather values of an iterator in a list, use `collect()`. Pass
# the `n` argument to collect that number of elements from a
# generator:
abc &lt;- generate_abc()
collect(abc, 1)

# Or drain all remaining elements:
collect(abc)


# coro provides a short syntax `gen()` for creating one-off
# generator _instances_. It is handy to adapt existing iterators:
numbers &lt;- 1:10
odds &lt;- gen(for (x in numbers) if (x %% 2 != 0) yield(x))
squares &lt;- gen(for (x in odds) yield(x^2))
greetings &lt;- gen(for (x in squares) yield(paste("Hey", x)))

collect(greetings)


# Arguments passed to generator instances are returned from the
# `yield()` statement on reentry:
new_tally &lt;- generator(function() {
  count &lt;- 0
  while (TRUE) {
    i &lt;- yield(count)
    count &lt;- count + i
  }
})
tally &lt;- new_tally()
tally(1)
tally(2)
tally(10)
</code></pre>

<hr>
<h2 id='iterator'>Iterator protocol</h2><span id='topic+iterator'></span><span id='topic+exhausted'></span><span id='topic+is_exhausted'></span>

<h3>Description</h3>

<p>An <strong>iterator</strong> is a function that implements the following
protocol:
</p>

<ul>
<li><p> Calling the function advances the iterator. The new value is
returned.
</p>
</li>
<li><p> When the iterator is exhausted and there are no more elements to
return, the symbol <code>quote(exhausted)</code> is returned. This signals
exhaustion to the caller.
</p>
</li>
<li><p> Once an iterator has signalled exhaustion, all subsequent
invokations must consistently return <code>coro::exhausted()</code> or
<code>as.symbol(".__exhausted__.")</code>.
</p>
</li>
<li><p> The iterator function may have a <code>close</code> argument taking boolean
values. When passed a <code>TRUE</code> value, it indicates early termination
and the iterator is given the opportunity to clean up resources.
</p>
<p>Cleanup must only be performed once, even if the iterator is called
multiple times with <code>close = TRUE</code>.
</p>
<p>An iterator is allowed to not have any <code>close</code> argument. Iterator
drivers must check for the presence of the argument. If not present,
the iterator can be dropped without cleanup.
</p>
<p>An iterator passed <code>close = TRUE</code> must return <code>coro::exhausted()</code> and
once closed, an iterator must return <code>coro::exhausted()</code> when called
again.
</p>
</li></ul>

<div class="sourceCode r"><pre>iterator &lt;- as_iterator(1:3)

# Calling the iterator advances it
iterator()
#&gt; [1] 1
iterator()
#&gt; [1] 2

# This is the last value
iterator()
#&gt; [1] 3

# Subsequent invokations return the exhaustion sentinel
iterator()
#&gt; .__exhausted__.
</pre></div>
<p>Because iteration is defined by a protocol, creating iterators is
free of dependency. However, it is often simpler to create
iterators with <a href="#topic+generator">generators</a>, see
<code>vignette("generator")</code>. To loop over an iterator, it is simpler
to use the <code><a href="#topic+loop">loop()</a></code> and <code><a href="#topic+collect">collect()</a></code> helpers provided in this
package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exhausted()

is_exhausted(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iterator_+3A_x">x</code></td>
<td>
<p>An object.</p>
</td></tr>
</table>


<h3>Properties</h3>

<p>Iterators are <strong>stateful</strong>. Advancing the iterator creates a
persistent effect in the R session. Also iterators are
<strong>one-way</strong>. Once you have advanced an iterator, there is no going
back and once it is exhausted, it stays exhausted.
</p>
<p>Iterators are not necessarily finite. They can also represent
infinite sequences, in which case trying to exhaust them is a
programming error that causes an infinite loop.
</p>


<h3>The exhausted sentinel</h3>

<p>Termination of iteration is signalled via a sentinel value,
<code>as.symbol(".__exhausted__.")</code>. Alternative designs include:
</p>

<ul>
<li><p> A condition as in python.
</p>
</li>
<li><p> A rich value containing a termination flag as in Javascript.
</p>
</li></ul>

<p>The sentinel design is a simple and efficient solution but it has a
downside. If you are iterating over a collection of elements that
inadvertently contains the sentinel value, the iteration will be
terminated early. To avoid such mix-ups, the sentinel should only
be used as a temporary value. It should be created from scratch by
a function like <code>coro::exhausted()</code> and never stored in a container
or namespace.
</p>

<hr>
<h2 id='yield'>Yield a value from a generator</h2><span id='topic+yield'></span>

<h3>Description</h3>

<p>The <code>yield()</code> statement suspends <code><a href="#topic+generator">generator()</a></code> functions. It works
like <code>return()</code> except that the function continues execution at the
yielding point when it is called again.
</p>
<p><code>yield()</code> can be called within loops and if-else branches but for
technical reasons it can't be used anywhere in R code:
</p>

<ul>
<li> <p><code>yield()</code> cannot be called as part of a function argument. Code
such as <code>list(yield())</code> is illegal.
</p>
</li>
<li> <p><code>yield()</code> does not cross function boundaries. You can't use it a
lambda function passed to <code>lapply()</code> for instance.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>yield(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="yield_+3A_x">x</code></td>
<td>
<p>A value to yield.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+generator">generator()</a></code> for examples.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
