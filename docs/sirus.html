<!DOCTYPE html><html><head><title>Help for package sirus</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sirus}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#sirus.cv'><p>Estimate p0.</p></a></li>
<li><a href='#sirus.fit'><p>Fit SIRUS.</p></a></li>
<li><a href='#sirus.plot.cv'><p>Plot SIRUS cross-validation path.</p></a></li>
<li><a href='#sirus.predict'><p>Predict.</p></a></li>
<li><a href='#sirus.print'><p>Print SIRUS.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Stable and Interpretable RUle Set</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-06-10</td>
</tr>
<tr>
<td>Author:</td>
<td>Clement Benard [aut, cre], Marvin N. Wright [ctb, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Clement Benard &lt;clement.benard5@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A regression and classification algorithm based on random forests, which takes the form of a short list of rules. SIRUS combines the simplicity of decision trees with a predictivity close to random forests. The core aggregation principle of random forests is kept, but instead of aggregating predictions, SIRUS aggregates the forest structure: the most frequent nodes of the forest are selected to form a stable rule ensemble model. The algorithm is fully described in the following articles: Benard C., Biau G., da Veiga S., Scornet E. (2021), Electron. J. Statist., 15:427-505 &lt;<a href="https://doi.org/10.1214%2F20-EJS1792">doi:10.1214/20-EJS1792</a>&gt; for classification, and Benard C., Biau G., da Veiga S., Scornet E. (2021), AISTATS, PMLR 130:937-945 <a href="http://proceedings.mlr.press/v130/benard21a">http://proceedings.mlr.press/v130/benard21a</a>, for regression. This R package is a fork from the project ranger (<a href="https://github.com/imbs-hl/ranger">https://github.com/imbs-hl/ranger</a>). </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.11.2), Matrix, ROCR, ggplot2, glmnet</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>survival, testthat, ranger</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://gitlab.com/drti/sirus">https://gitlab.com/drti/sirus</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://gitlab.com/drti/sirus/-/issues">https://gitlab.com/drti/sirus/-/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-11 18:30:14 UTC; d584316</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-13 09:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='sirus.cv'>Estimate p0.</h2><span id='topic+sirus.cv'></span>

<h3>Description</h3>

<p>Estimate the optimal hyperparameter <code>p0</code> used to select rules in <code><a href="#topic+sirus.fit">sirus.fit</a></code> using cross-validation (Benard et al. 2021a, 2021b).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sirus.cv(
  data,
  y,
  type = "auto",
  nfold = 10,
  ncv = 10,
  num.rule.max = 25,
  q = 10,
  discrete.limit = 10,
  num.trees.step = 1000,
  alpha = 0.05,
  mtry = NULL,
  max.depth = 2,
  num.trees = NULL,
  num.threads = NULL,
  replace = TRUE,
  sample.fraction = NULL,
  verbose = TRUE,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sirus.cv_+3A_data">data</code></td>
<td>
<p>Input dataframe, each row is an observation vector. Each column is an input variable and is numeric or factor.</p>
</td></tr>
<tr><td><code id="sirus.cv_+3A_y">y</code></td>
<td>
<p>Numeric response variable. For classification, <code>y</code> takes only 0 and 1 values.</p>
</td></tr>
<tr><td><code id="sirus.cv_+3A_type">type</code></td>
<td>
<p>'reg' for regression, 'classif' for classification and 'auto' for automatic detection (classification if <code>y</code> takes only 0 and 1 values).</p>
</td></tr>
<tr><td><code id="sirus.cv_+3A_nfold">nfold</code></td>
<td>
<p>Number of folds in the cross-validation. Default is 10.</p>
</td></tr>
<tr><td><code id="sirus.cv_+3A_ncv">ncv</code></td>
<td>
<p>Number of repetitions of the cross-validation. Default is 10 for a robust estimation of <code>p0</code>.</p>
</td></tr>
<tr><td><code id="sirus.cv_+3A_num.rule.max">num.rule.max</code></td>
<td>
<p>Maximum number of rules of SIRUS model in the cross-validation grid. Default is 25.</p>
</td></tr>
<tr><td><code id="sirus.cv_+3A_q">q</code></td>
<td>
<p>Number of quantiles used for node splitting in the forest construction. Default and recommended value is 10.</p>
</td></tr>
<tr><td><code id="sirus.cv_+3A_discrete.limit">discrete.limit</code></td>
<td>
<p>Maximum number of distinct values for a variable to be considered discrete. If higher, variable is continuous.</p>
</td></tr>
<tr><td><code id="sirus.cv_+3A_num.trees.step">num.trees.step</code></td>
<td>
<p>Number of trees grown between two evaluations of the stopping criterion. Ignored if <code>num.trees</code> is provided.</p>
</td></tr>
<tr><td><code id="sirus.cv_+3A_alpha">alpha</code></td>
<td>
<p>Parameter of the stopping criterion for the number of trees: stability has to reach 1-<code>alpha</code> to stop the growing of the forest. Ignored if <code>num.trees</code> is provided. Default value is 0.05.</p>
</td></tr>
<tr><td><code id="sirus.cv_+3A_mtry">mtry</code></td>
<td>
<p>Number of variables to possibly split at each node. Default is the number of variables divided by 3.</p>
</td></tr>
<tr><td><code id="sirus.cv_+3A_max.depth">max.depth</code></td>
<td>
<p>Maximal tree depth. Default and recommended value is 2.</p>
</td></tr>
<tr><td><code id="sirus.cv_+3A_num.trees">num.trees</code></td>
<td>
<p>Number of trees grown in the forest. If NULL (recommended), the number of trees is automatically set using a stability stopping criterion.</p>
</td></tr>
<tr><td><code id="sirus.cv_+3A_num.threads">num.threads</code></td>
<td>
<p>Number of threads used to grow the forest. Default is number of CPUs available.</p>
</td></tr>
<tr><td><code id="sirus.cv_+3A_replace">replace</code></td>
<td>
<p>Boolean. If true (default), sample with replacement.</p>
</td></tr>
<tr><td><code id="sirus.cv_+3A_sample.fraction">sample.fraction</code></td>
<td>
<p>Fraction of observations to sample. Default is 1 for sampling with replacement and 0.632 for sampling without replacement.</p>
</td></tr>
<tr><td><code id="sirus.cv_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. If true, information messages are printed.</p>
</td></tr>
<tr><td><code id="sirus.cv_+3A_seed">seed</code></td>
<td>
<p>Random seed. Default is NULL, which generates the seed from R. Set to 0 to ignore the R seed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a robust estimation of <code>p0</code>, it is recommended to run multiple cross-validations (typically <code>ncv</code> = 10).
Two optimal values of <code>p0</code> are provided: <code>p0.pred</code> (Benard et al. 2021a) and <code>p0.stab</code> (Benard et al. 2021b), defined such that <code>p0.pred</code> minimizes the error, and <code>p0.stab</code> finds a tradeoff between error and stability.
Error is 1-AUC for classification and the unexplained variance for regression.
Stability is the average proportion of rules shared by two SIRUS models fit on two distinct folds of the cross-validation.
</p>


<h3>Value</h3>

<p>Optimal value of <code>p0</code> with the elements
</p>
<table>
<tr><td><code>p0.pred</code></td>
<td>
<p>Optimal <code>p0</code> value to minimize model error (recommended for classification).</p>
</td></tr>
<tr><td><code>p0.stab</code></td>
<td>
<p>Optimal <code>p0</code> value for a tradeoff between error and stability (recommended for regression).</p>
</td></tr>
<tr><td><code>error.grid.p0</code></td>
<td>
<p>Table with the full cross-validation results for a fine grid of <code>p0</code>: number of rules, stability, and error. 
The last three columns of the table are the standard deviations of the metrics across the <code>ncv</code> repetitions of the cross-validation.
See details for the definitions of the error and stability metrics.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>'reg' for regression, 'classif' for classification.</p>
</td></tr>
</table>


<h3>References</h3>


<ul>
<li><p> Benard, C., Biau, G., Da Veiga, S. &amp; Scornet, E. (2021a). SIRUS: Stable and Interpretable RUle Set for Classification. Electronic Journal of Statistics, 15:427-505. <a href="https://doi.org/10.1214/20-EJS1792">doi:10.1214/20-EJS1792</a>.
</p>
</li>
<li><p> Benard, C., Biau, G., Da Veiga, S. &amp; Scornet, E. (2021b). Interpretable Random Forests via Rule Extraction. Proceedings of The 24th International Conference on Artificial Intelligence and Statistics, PMLR 130:937-945. <a href="http://proceedings.mlr.press/v130/benard21a">http://proceedings.mlr.press/v130/benard21a</a>. 
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## load SIRUS
require(sirus)

## prepare data
data &lt;- iris
y &lt;- rep(0, nrow(data))
y[data$Species == 'setosa'] = 1
data$Species &lt;- NULL

## run cv
cv.grid &lt;- sirus.cv(data, y, nfold = 3, ncv = 2, num.trees = 100)

</code></pre>

<hr>
<h2 id='sirus.fit'>Fit SIRUS.</h2><span id='topic+sirus.fit'></span>

<h3>Description</h3>

<p>Fit SIRUS for a given number of rules (10 by default) or a given <code>p0</code>. <br />
SIRUS is a regression and classification algorithm, based on random forests (Breiman, 2001), that takes the form of a short list of rules.
SIRUS combines the simplicity of rule algorithms or decision trees with an accuracy close to random forests.
More importantly, the rule selection is stable with respect to data perturbation.
SIRUS for classification is defined in (Benard et al. 2021a), and the extension to regression is provided in (Benard et al. 2021b).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sirus.fit(
  data,
  y,
  type = "auto",
  num.rule = 10,
  p0 = NULL,
  num.rule.max = 25,
  q = 10,
  discrete.limit = 10,
  num.trees.step = 1000,
  alpha = 0.05,
  mtry = NULL,
  max.depth = 2,
  num.trees = NULL,
  num.threads = NULL,
  replace = TRUE,
  sample.fraction = ifelse(replace, 1, 0.632),
  verbose = TRUE,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sirus.fit_+3A_data">data</code></td>
<td>
<p>Input dataframe, each row is an observation vector. Each column is an input variable and is numeric or factor.</p>
</td></tr>
<tr><td><code id="sirus.fit_+3A_y">y</code></td>
<td>
<p>Numeric response variable. For classification, <code>y</code> takes only 0 and 1 values.</p>
</td></tr>
<tr><td><code id="sirus.fit_+3A_type">type</code></td>
<td>
<p>'reg' for regression, 'classif' for classification and 'auto' for automatic detection (classification if <code>y</code> takes only 0 and 1 values).</p>
</td></tr>
<tr><td><code id="sirus.fit_+3A_num.rule">num.rule</code></td>
<td>
<p>Number of rules in SIRUS model. Default is 10. Ignored if a <code>p0</code> value is provided. For regression, the effective number of rules can be smaller than <code>num.rule</code> because of null coefficients in the final linear aggregation of the rules.</p>
</td></tr>
<tr><td><code id="sirus.fit_+3A_p0">p0</code></td>
<td>
<p>Selection threshold on the frequency of appearance of a path in the forest to set the number of rules. Default is NULL and <code>num.rule</code> is used to select rules. <code><a href="#topic+sirus.cv">sirus.cv</a></code> provides the optimal <code>p0</code> by cross-validation.</p>
</td></tr>
<tr><td><code id="sirus.fit_+3A_num.rule.max">num.rule.max</code></td>
<td>
<p>Maximum number of rules in SIRUS model. Ignored if <code>num.rule</code> is provided.</p>
</td></tr>
<tr><td><code id="sirus.fit_+3A_q">q</code></td>
<td>
<p>Number of quantiles used for node splitting in the forest construction. Default and recommended value is 10.</p>
</td></tr>
<tr><td><code id="sirus.fit_+3A_discrete.limit">discrete.limit</code></td>
<td>
<p>Maximum number of distinct values for a variable to be considered discrete. If higher, variable is continuous.</p>
</td></tr>
<tr><td><code id="sirus.fit_+3A_num.trees.step">num.trees.step</code></td>
<td>
<p>Number of trees grown between two evaluations of the stopping criterion. Ignored if <code>num.trees</code> is provided.</p>
</td></tr>
<tr><td><code id="sirus.fit_+3A_alpha">alpha</code></td>
<td>
<p>Parameter of the stopping criterion for the number of trees: stability has to reach 1-<code>alpha</code> to stop the growing of the forest. Ignored if <code>num.trees</code> is provided. Default value is 0.05.</p>
</td></tr>
<tr><td><code id="sirus.fit_+3A_mtry">mtry</code></td>
<td>
<p>Number of variables to possibly split at each node. Default is the number of variables divided by 3.</p>
</td></tr>
<tr><td><code id="sirus.fit_+3A_max.depth">max.depth</code></td>
<td>
<p>Maximal tree depth. Default and recommended value is 2.</p>
</td></tr>
<tr><td><code id="sirus.fit_+3A_num.trees">num.trees</code></td>
<td>
<p>Number of trees grown in the forest. Default is NULL. If NULL (recommended), the number of trees is automatically set using a stability based stopping criterion.</p>
</td></tr>
<tr><td><code id="sirus.fit_+3A_num.threads">num.threads</code></td>
<td>
<p>Number of threads used to grow the forest. Default is number of CPUs available.</p>
</td></tr>
<tr><td><code id="sirus.fit_+3A_replace">replace</code></td>
<td>
<p>Boolean. If true (default), sample with replacement.</p>
</td></tr>
<tr><td><code id="sirus.fit_+3A_sample.fraction">sample.fraction</code></td>
<td>
<p>Fraction of observations to sample. Default is 1 for sampling with replacement and 0.632 for sampling without replacement.</p>
</td></tr>
<tr><td><code id="sirus.fit_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. If true, information messages are printed.</p>
</td></tr>
<tr><td><code id="sirus.fit_+3A_seed">seed</code></td>
<td>
<p>Random seed. Default is NULL, which generates the seed from R. Set to 0 to ignore the R seed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the output <code>y</code> takes only 0 and 1 values, a classification model is fit, otherwise a regression model is fit.
SIRUS algorithm proceeds the following steps:
</p>

<ol>
<li><p> Discretize data
</p>
</li>
<li><p> Fit a random forest
</p>
</li>
<li><p> Extract rules from tree nodes
</p>
</li>
<li><p> Select the most frequent rules (which occur in at least a fraction p0 of the trees)
</p>
</li>
<li><p> Filter rules to remove linear dependence between them
</p>
</li>
<li><p> Aggregate the selected rules
</p>

<ul>
<li><p> Classification: rules are averaged
</p>
</li>
<li><p> Regression: rules are linearly combined via a ridge regression (constrained to have all coefficients positive)
</p>
</li></ul>

</li></ol>

<p>The hyperparameter <code>p0</code> can be tuned using <code><a href="#topic+sirus.cv">sirus.cv</a></code> to set the optimal number of rules. <br />
The number of trees is automatically set with a stopping criterion based on stability: 
the forest growing is stopped when the number of trees is high enough to ensure that 95% of the rules in average are identical over two runs of SIRUS on the provided dataset. <br />
Data is discretized depending on variable types: numerical variables are binned using <code>q</code>-quantiles, 
categorical variables are transformed in ordered variables as in <code><a href="ranger.html#topic+ranger">ranger</a></code> (standard method to handle categorical variables in trees),
while discrete variables (numerical variables with less than <code>discrete.limit</code> distinct values) are left untouched.
Notice that categorical variables with a high number of categories should be discarded or transformed, as SIRUS is likely to identify associated irrelevant rules.
</p>


<h3>Value</h3>

<p>SIRUS model with elements
</p>
<table>
<tr><td><code>rules</code></td>
<td>
<p>List of rules in SIRUS model.</p>
</td></tr>
<tr><td><code>rules.out</code></td>
<td>
<p>List of rule outputs. <code>rule.out</code>: the output mean whether the rule is satisfied or not. <code>supp.size</code>: the number of points inside and outside the rule.</p>
</td></tr>
<tr><td><code>proba</code></td>
<td>
<p>Frequency of occurence of paths in the forest.</p>
</td></tr>
<tr><td><code>paths</code></td>
<td>
<p>List of selected paths (symbolic representation with quantile order for continuous variables).</p>
</td></tr>
<tr><td><code>rule.weights</code></td>
<td>
<p>Vector of positive or null coefficients assigned to each rule for the linear aggregation (1/number of rules for classification).</p>
</td></tr>
<tr><td><code>rule.glm</code></td>
<td>
<p>Fitted glmnet object for regression (linear rule aggregation with ridge penalty).</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>Type of SIRUS model: 'reg' for regression, 'classif' for classification.</p>
</td></tr> 
<tr><td><code>num.trees</code></td>
<td>
<p>Number of trees used to build SIRUS.</p>
</td></tr>
<tr><td><code>data.names</code></td>
<td>
<p>Names of input variables.</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>Mean output over the full training data. Default model output if no rule is selected.</p>
</td></tr>
<tr><td><code>bins</code></td>
<td>
<p>List of type and possible split values for all input variables.</p>
</td></tr>
</table>


<h3>References</h3>


<ul>
<li><p> Benard, C., Biau, G., Da Veiga, S. &amp; Scornet, E. (2021a). SIRUS: Stable and Interpretable RUle Set for Classification. Electronic Journal of Statistics, 15:427-505. <a href="https://doi.org/10.1214/20-EJS1792">doi:10.1214/20-EJS1792</a>.
</p>
</li>
<li><p> Benard, C., Biau, G., Da Veiga, S. &amp; Scornet, E. (2021b). Interpretable Random Forests via Rule Extraction. Proceedings of The 24th International Conference on Artificial Intelligence and Statistics, PMLR 130:937-945. <a href="http://proceedings.mlr.press/v130/benard21a">http://proceedings.mlr.press/v130/benard21a</a>. 
</p>
</li>
<li><p> Breiman, L. (2001). Random forests. Machine learning, 45, 5-32.
</p>
</li>
<li><p> Wright, M. N. &amp; Ziegler, A. (2017). ranger: A fast implementation of random forests for high dimensional data in C++ and R. J Stat Softw 77:1-17. <a href="https://doi.org/10.18637/jss.v077.i01">doi:10.18637/jss.v077.i01</a>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## load SIRUS
require(sirus)

## prepare data
data &lt;- iris
y &lt;- rep(0, nrow(data))
y[data$Species == 'setosa'] = 1
data$Species &lt;- NULL

## fit SIRUS
sirus.m &lt;- sirus.fit(data, y)

</code></pre>

<hr>
<h2 id='sirus.plot.cv'>Plot SIRUS cross-validation path.</h2><span id='topic+sirus.plot.cv'></span>

<h3>Description</h3>

<p>Plot SIRUS cross-validation path: error and stability versus the number of rules when <code>p0</code> varies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sirus.plot.cv(sirus.cv.grid, p0.criterion = NULL, num.rule.max = 25)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sirus.plot.cv_+3A_sirus.cv.grid">sirus.cv.grid</code></td>
<td>
<p>Cross-validation results returned by <code><a href="#topic+sirus.cv">sirus.cv</a></code>.</p>
</td></tr>
<tr><td><code id="sirus.plot.cv_+3A_p0.criterion">p0.criterion</code></td>
<td>
<p>Criterion to pick the optimal <code>p0</code> displayed in the plots: if 'pred' then <code>p0.pred</code> is used for a minimal error, if 'stab' then <code>p0.stab</code> is used for a tradeoff error/stability. Default is 'pred' for classification and 'stab' for regression.</p>
</td></tr>
<tr><td><code id="sirus.plot.cv_+3A_num.rule.max">num.rule.max</code></td>
<td>
<p>Upper limit on the number of rules for the x-axis. Default is 25.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Error is 1-AUC for classification and the unexplained variance for regression.
Stability is the average proportion of rules shared by two SIRUS models fit on two distinct folds of the cross-validation.
</p>


<h3>Value</h3>

<p>Plots of cross-validation results.
</p>
<table>
<tr><td><code>error</code></td>
<td>
<p>plot of error vs number of rules (ggplot2 object).</p>
</td></tr>
<tr><td><code>stability</code></td>
<td>
<p>plot of stability vs number of rules (ggplot2 object).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## load SIRUS
require(sirus)

## prepare data
data &lt;- iris
y &lt;- rep(0, nrow(data))
y[data$Species == 'setosa'] = 1
data$Species &lt;- NULL

## run cv
cv.grid &lt;- sirus.cv(data, y, nfold = 3, ncv = 2, num.trees = 100)

## plot cv result
plot.error &lt;- sirus.plot.cv(cv.grid)$error
plot(plot.error)

</code></pre>

<hr>
<h2 id='sirus.predict'>Predict.</h2><span id='topic+sirus.predict'></span>

<h3>Description</h3>

<p>Compute SIRUS predictions for new observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sirus.predict(sirus.m, data.test)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sirus.predict_+3A_sirus.m">sirus.m</code></td>
<td>
<p>A SIRUS model generated by <code><a href="#topic+sirus.fit">sirus.fit</a></code>.</p>
</td></tr>
<tr><td><code id="sirus.predict_+3A_data.test">data.test</code></td>
<td>
<p>Testing data (dataframe of new observations).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Predictions. For classification, vector of the predicted probability of each new observation to be of class 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load SIRUS
require(sirus)

## prepare data
data &lt;- iris
y &lt;- rep(0, nrow(data))
y[data$Species == 'setosa'] = 1
data$Species &lt;- NULL

#' ## fit SIRUS
sirus.m &lt;- sirus.fit(data, y)

## predict
predictions &lt;- sirus.predict(sirus.m, data)

</code></pre>

<hr>
<h2 id='sirus.print'>Print SIRUS.</h2><span id='topic+sirus.print'></span>

<h3>Description</h3>

<p>Print the list of rules output by SIRUS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sirus.print(sirus.m, digits = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sirus.print_+3A_sirus.m">sirus.m</code></td>
<td>
<p>A SIRUS model generated by <code><a href="#topic+sirus.fit">sirus.fit</a></code>.</p>
</td></tr>
<tr><td><code id="sirus.print_+3A_digits">digits</code></td>
<td>
<p>Number of significant digits for numerical values. Default value is 3.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Formatted list of rules.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## load SIRUS
require(sirus)

## prepare data
data &lt;- iris
y &lt;- rep(0, nrow(data))
y[data$Species == 'setosa'] = 1
data$Species &lt;- NULL

## fit SIRUS
sirus.m &lt;- sirus.fit(data, y)

## print sirus model
sirus.print(sirus.m)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
