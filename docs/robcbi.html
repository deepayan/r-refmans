<!DOCTYPE html><html><head><title>Help for package robcbi</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {robcbi}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#robcbi-package'>
<p>Robust Fit for Discrete Generalized Linear Model</p></a></li>
<li><a href='#Breslow'>
<p>Breslow Data</p></a></li>
<li><a href='#correl'>
<p>Generic functions for objects of classes &quot;glm&quot; and &quot;cubinf&quot;</p></a></li>
<li><a href='#cubinf'>
<p>Conditionally unbiased bounded influence estimates of discrete Generalized Linear Models</p></a></li>
<li><a href='#cubinf.control'>
<p>Control parameters for the function cubinf</p></a></li>
<li><a href='#cubinf.missing'>
<p>Missing methods for an object of class &quot;cubinf&quot;</p></a></li>
<li><a href='#cubinf.summaries'>
<p>Functions required by the corresponding access functions</p></a></li>
<li><a href='#Finney'>
<p>Finney data from 'Annals of Eugenics' 1947</p></a></li>
<li><a href='#fits.compare'>
<p>Comparison of fits</p></a></li>
<li><a href='#glm.summaries'>
<p>Accessor functions for objects the class &quot;glm&quot;</p></a></li>
<li><a href='#plot.cubinf'><p>Diagnostic plots for an object of class &quot;cubinf&quot;</p></a></li>
<li><a href='#plot.fits.compare'>
<p>Plots for comparing fits</p></a></li>
<li><a href='#predict.cubinf'>
<p>Prediction methods for objects of class &quot;cubinf&quot;</p></a></li>
<li><a href='#QQline'>
<p>Add a theoretical QQ-line in a plot</p></a></li>
<li><a href='#robust.print.summaries'>
<p>Print methods for objects of class &quot;cubinf&quot;, &quot;cubinf.i&quot;, &quot;summary.cubinf&quot; or &quot;glm.i&quot;</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Conditionally Unbiased Bounded Influence Estimates</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1-4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-21</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>Author:</td>
<td>Alfio Marazzi &lt;Alfio.Marazzi@unisante.ch&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>A. Randriamiharisoa &lt;exelami@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Conditionally unbiased bounded influence estimates as described in 
  Kuensch et al. (1989) &lt;<a href="https://doi.org/10.1080%2F01621459.1989.10478791">doi:10.1080/01621459.1989.10478791</a>&gt; in three special cases of 
  the generalized linear model: Bernoulli, Binomial, and Poisson distributed responses. </td>
</tr>
<tr>
<td>Imports:</td>
<td>robeth, stats, graphics, utils</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-21 15:00:11 UTC; Alex</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-21 17:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='robcbi-package'>
Robust Fit for Discrete Generalized Linear Model
</h2><span id='topic+robcbi-package'></span><span id='topic+robcbi'></span>

<h3>Description</h3>

<p>Conditionally unbiased bounded influence estimates as described in Kuensch et al.  
(1989) in three special cases of the Generalized Linear Model: Bernoulli, Binomial,  
and Poisson distributed responses. 
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> cubinf</td>
</tr>
<tr>
 <td style="text-align: left;">
#Version: </td><td style="text-align: left;"> 1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
#Date: </td><td style="text-align: left;"> 2013-07-04</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;">  GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>A. Marazzi  &lt;Alfio.Marazzi@chuv.ch&gt;
</p>
<p>Maintainer: A. Randriamiharisoa &lt;Alex.Randriamiharisoa@chuv.ch&gt;
</p>


<h3>References</h3>

<p>Kuensch, H.R., Stefanski L.A., Carroll R.J. (1989).
Conditionally unbiased bounded-influence estimation in general regression models,
with application to generalized linear models. 
Journal of the American Statistical Association, 84, 460-466.
</p>
<p>Marazzi, A. (1993).
Algorithms, Routines, and S-functions for robust Statistics.
Chapman and Hall, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> library(robcbi)
# First example
 data(Finney)
 Vol &lt;- Finney$Vol; Rate &lt;- Finney$Rate; Resp &lt;- Finney$Resp
## Not run: 
 plot(Vol,Rate,type="n")
 points(Vol[Resp==0],Rate[Resp==0],pch=5, cex=1.2)
 points(Vol[Resp==1],Rate[Resp==1],pch=16,cex=1.2)

## End(Not run)
 lVol &lt;-log(Vol); lRate &lt;- log(Rate)
 z.glm &lt;- glm(Resp~lVol+lRate,family=binomial)
 summary(z.glm)
 z.cub &lt;- glm(Resp~lVol+lRate,family=binomial,method="cubinf", ufact=3.2)
 summary(z.cub)
 weights(z.cub)
## Not run: 
 plot(z.cub, smooth=TRUE, ask=TRUE)

## End(Not run)
 comp &lt;- fits.compare(z.glm,z.cub)
 comp
## Not run: 
 plot(comp)

## End(Not run)
# Second example
 data(Breslow)
## Not run:  
 help(Breslow)

## End(Not run)
 y  = Breslow$sumY
 x1 = Breslow$Age10
 x2 = Breslow$Base4
 x3 = rep(0,length(y))
 x3[Breslow$Trt=="progabide"] = 1
 x4 = x2*x3
 CBA = glm(y~x1+x2+x3+x4,family=poisson,method=cubinf,ufact=3.2)
## Not run: 
 plot(CBA,num=5)

## End(Not run)
 weights(CBA)
#
# compute the $R_n^2$ statistic (Section 2.5) to compare CBA 
# with a reduced model with three variables:
#
 CBA.red = update(CBA, .~.-x3-x4)
 np = 5       # number of parameters of the full model
 nq = 3       # number of parameters of the reduced model
 CVR = covar(CBA)
 CFF = coef(CBA)
 K22 = CVR[(nq+1):np,(nq+1):np]
 cff = as.matrix(CFF[(nq+1):np])
 Rn2 = t(cff)%*%solve(K22)%*%cff
 Rn2
</code></pre>

<hr>
<h2 id='Breslow'>
Breslow Data
</h2><span id='topic+Breslow'></span>

<h3>Description</h3>

<p>Patients suffering from simple or complex partial seizures were randomized to receive 
either the antiepileptic drug progabide or a placebo. At each of four successive
postrandomization clinic visits, the number of seizures occuring over the previous 
two weeks was reported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Breslow)
</code></pre>


<h3>Format</h3>

<p>A data frame with 59 observations and the following 4 variables 
</p>

<dl>
<dt>Trt</dt><dd><p>The treatment: a factor with levels &quot;placebo&quot; and &quot;progabide&quot;.</p>
</dd>
<dt>sumY</dt><dd><p>An integer value, the sum of seizures during the 1st, 2nd, 3rd and 4th two week periods.</p>
</dd>
<dt>Age10</dt><dd><p>Age divided by 10.</p>
</dd>
<dt>Base4</dt><dd><p>The eight-week baseline seizure count divided by 4.</p>
</dd>
</dl>


<h3>References</h3>

<p>Breslow, N. E., and Clayton, D. G. (1993), &quot;Approximate Inference in Generalized Linear Mixed Models,&quot; 
Journal of the American Statistical Association, Vol. 88, No. 421, pp. 9-25. 
</p>
<p>Thrall, P. F., and Vail, S. C. (1990), &quot;Some Covariance Models for Longitudinal Count Data With 
Overdispersion,&quot; Biometrics, Vol. 46, pp. 657-671. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(robcbi)
data(Breslow)
y  &lt;- Breslow$sumY
x1 &lt;- Breslow$Age10
x2 &lt;- Breslow$Base4
x3 &lt;- rep(0,length(y))
x3[Breslow$Trt=="progabide"] &lt;- 1
</code></pre>

<hr>
<h2 id='correl'>
Generic functions for objects of classes &quot;glm&quot; and &quot;cubinf&quot; 
</h2><span id='topic+correl'></span><span id='topic+covar'></span><span id='topic+Rank'></span><span id='topic+rscale'></span><span id='topic+weights'></span>

<h3>Description</h3>

<p>Correlation and covariance matrix of the parameter estimates,  
rank, scale estimate, and weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correl(object, tl = 1e-10)

covar(object)
 
Rank(object)

rscale(object)

weights(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correl_+3A_object">object</code></td>
<td>

<p>An object inheriting from class &quot;glm&quot; or &quot;cubinf&quot;.
</p>
</td></tr>
<tr><td><code id="correl_+3A_tl">tl</code></td>
<td>

<p>Tolerance for a scale factor (denominator) close to zero.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generic functions <code>coef</code>, <code>residuals</code>, <code>fitted</code>, 
<code>formula</code>, <code>deviance</code>, <code>rscale</code>, <code>covar</code>, <code>correl</code>, <code>weights</code>, <code>Rank</code> 
can be used to extract elements from an object returned by <code>glm</code>. 
</p>


<h3>See Also</h3>

<p>The model fitting function <code><a href="stats.html#topic+glm">glm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> library(robcbi)
 data(Finney)
 Vol &lt;- Finney$Vol; Rate &lt;- Finney$Rate; Resp &lt;- Finney$Resp
 lVol &lt;-log(Vol); lRate &lt;- log(Rate)
 z.cub &lt;- glm(Resp~lVol+lRate,family=binomial,method="cubinf", ufact=3.2)
 correl(z.cub)
 covar(z.cub)
 Rank(z.cub)
 rscale(z.cub)
 weights(z.cub)
</code></pre>

<hr>
<h2 id='cubinf'>
Conditionally unbiased bounded influence estimates of discrete Generalized Linear Models
</h2><span id='topic+cubinf'></span>

<h3>Description</h3>

<p>Conditionally unbiased bounded influence estimates as described in Kuensch et al. 
(1989) in three special GLM cases: Bernoulli, Binomial, and Poisson distributed responses. 
The result is an object of class &quot;cubinf&quot;. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cubinf(x, y, weights = NULL,  start=NULL, etastart=NULL, mustart=NULL,
       offset = NULL, family = binomial(), control = cubinf.control(...),  
       intercept = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cubinf_+3A_x">x</code></td>
<td>
<p>Vector or matrix of explanatory variable(s).
Columns represent variables and rows are observations.
</p>
</td></tr>
<tr><td><code id="cubinf_+3A_y">y</code></td>
<td>
<p>Vector of observed responses. 
In the case of Binomial responses, y is a two column matrix:
the 1st column contains the number of successes, 
the 2nd column the number of failures.
The Bernoulli case, is treated as a special Binomial case. 
However, the response y is a categorical variable (not a matrix with two colums) with two levels.
</p>
</td></tr>
<tr><td><code id="cubinf_+3A_weights">weights</code></td>
<td>
<p>Optional weigths for weighted regression. Components must be non negative integers. 
</p>
</td></tr>
<tr><td><code id="cubinf_+3A_start">start</code></td>
<td>
<p>Starting values for the parameters in the linear predictor. 
Not used but required for compatibility with the glm function. 
</p>
</td></tr>
<tr><td><code id="cubinf_+3A_etastart">etastart</code></td>
<td>
<p>Starting values for the linear predictor. 
Not used but required for compatibility with the glm function. 
</p>
</td></tr>
<tr><td><code id="cubinf_+3A_mustart">mustart</code></td>
<td>
<p>Starting values for the vector of means. 
Not used but required for compatibility with the glm function.
</p>
</td></tr>
<tr><td><code id="cubinf_+3A_offset">offset</code></td>
<td>
<p>Optional offset added to the linear predictor. 
</p>
</td></tr>
<tr><td><code id="cubinf_+3A_family">family</code></td>
<td>
<p>A family object. Only two options are available for cubinf: 
'family=binomial()' and 'family=poisson()'. 
</p>
</td></tr>
<tr><td><code id="cubinf_+3A_control">control</code></td>
<td>
<p>A list of control parameters for the numerical algorithms. 
See cubinf.control for the possible control parameters and their defaults.
</p>
</td></tr>
<tr><td><code id="cubinf_+3A_intercept">intercept</code></td>
<td>
<p>Logical flag: if TRUE, an intercept term is added to the model. 
</p>
</td></tr>
<tr><td><code id="cubinf_+3A_...">...</code></td>
<td>
<p>Further named control arguments as singular.ok or qr.out used in the case 
where the x matrix is singular.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The initial values of the coefficients (theta), the matrix A and the bias correction c are 
computed using the ROBETH subroutine GINTAC (Marazzi, 1993). Then an initial covariance 
matrix (for the convergence criterion) is computed by means of the ROBETH subroutines 
GFEDCA and KTASKW. 
Finally, the main algorithm (subroutine GYMAIN) alternates between improving values of
- theta, for fixed A and c (theta-step, subroutine GYTSTP),
- c, for fixed theta and A (c-step, subroutine GYCSTP),
- A, for fixed theta and c (A-step, subroutine GYASTP).
</p>
<p>For the different available options see the function cubinf.control. 
</p>


<h3>Value</h3>

<p>A list with the following components: 
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>Coefficient estimates. </p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>Working residuals. </p>
</td></tr>
<tr><td><code>rsdev</code></td>
<td>
<p>Deviance residuals. </p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>Fitted values. </p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>Estimated covariance matrix of the coefficients. </p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>Rank of the model matrix. </p>
</td></tr>
<tr><td><code>df.residuals</code></td>
<td>
<p>Degrees of freedom in the residuals. </p>
</td></tr>
<tr><td><code>ci</code></td>
<td>
<p>Vector of final bias corrections. </p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>Final value of the matrix A. </p>
</td></tr>
<tr><td><code>ai</code></td>
<td>
<p>Vector with components a_i=ufact/|Ax_i| (where x_i^T denotes the ith row of the model matrix) </p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>A logical value. FALSE if the maximum number of iterations was reached.  </p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>Control parameters.  </p>
</td></tr>
<tr><td><code>prior.weights</code></td>
<td>
<p>Input vector w (when some of its components are different from 1). </p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>The family object used in the call to cubinf
'ics=1' for the Bernoulli case.
'ics=2' for the Binomial case.
'ics=3' for the Poisson case. </p>
</td></tr>
<tr><td><code>linear.predictors</code></td>
<td>
<p>Components of the linear predictor (the model matrix 
multiplied by the coefficient vector). </p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Number of iterations required in the main algorithm.  </p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Coded value of the response. </p>
</td></tr>
<tr><td><code>gradient</code></td>
<td>
<p>Vector of the final unscaled negative gradient of the objective 
function. </p>
</td></tr>
<tr><td><code>inv.hessian</code></td>
<td>
<p>Vector of the final inverse of the Hessian matrix in compact 
storage mode. </p>
</td></tr>
</table>


<h3>References</h3>

<p>Kuensch, H.R., Stefanski L.A., Carroll R.J. (1989).
Conditionally unbiased bounded-influence estimation in general regression models,
with application to generalized linear models. 
Journal of the American Statistical Association, 84, 460-466.
</p>
<p>Marazzi, A. (1993).
Algorithms, Routines, and S-functions for robust Statistics.
Chapman and Hall, New York.
</p>


<h3>See Also</h3>

<p>glm(..., method=&quot;cubinf&quot;), <code><a href="#topic+cubinf.control">cubinf.control</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  library(robcbi)
  y &lt;- c(5,10,15,20,30,40,60,80,100)
  x &lt;- matrix(
	c(0,1,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,1,1,1),
    nrow=9,byrow=FALSE)
  z &lt;- cubinf(x,y, family=poisson, control=list(ufact=3.2), intercept=TRUE)
  z$iter
  z$coeff
  z &lt;- cubinf(x,y, family=poisson, control=list(ufact=30), intercept=TRUE)
  z$iter
  z$coeff
</code></pre>

<hr>
<h2 id='cubinf.control'>
Control parameters for the function cubinf
</h2><span id='topic+cubinf.control'></span>

<h3>Description</h3>

<p>Allows the user to set parameters affecting the estimation of 
the discrete GLMs implemented in cubinf. Most control parameters 
are parameters of the ROBETH subroutine GYMAIN (Marazzi, 1993). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cubinf.control(tlo = 0.001, tua = 1e-06, mxx = 30, mxt = 10, mxf = 10, ntm = 0, gma = 1, 
               iug = 1, ipo = 1, ilg = 2, icn = 1, icv = 1, ufact = 0, cpar = 1.5,
               null.dev=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cubinf.control_+3A_tlo">tlo</code></td>
<td>
<p>Relative precision for the convergence criterion of the main algorithm (GYMAIN) 
called by cubinf. The relative precision for the convergence criterion in the lower level 
steps (theta-step, A-step and c-step) is '10*tlo'. 
</p>
</td></tr>
<tr><td><code id="cubinf.control_+3A_tua">tua</code></td>
<td>
<p>Tolerance used for the determination of the pseudo-rank. 
</p>
</td></tr>
<tr><td><code id="cubinf.control_+3A_mxx">mxx</code></td>
<td>
<p>Maximum number of cycles for the main algorithm. 
</p>
</td></tr>
<tr><td><code id="cubinf.control_+3A_mxt">mxt</code></td>
<td>
<p>Maximum number of iterations for the theta-step. 
</p>
</td></tr>
<tr><td><code id="cubinf.control_+3A_mxf">mxf</code></td>
<td>
<p>Maximum number of iterations for the A-step. 
</p>
</td></tr>
<tr><td><code id="cubinf.control_+3A_ntm">ntm</code></td>
<td>
<p>Parameter to control iteration monitoring. When the number of iterations in the 
theta-step reaches a multiple of 'ntm', the current parameter values as well as the 
corresponding value of the objective function are printed. 
</p>
</td></tr>
<tr><td><code id="cubinf.control_+3A_gma">gma</code></td>
<td>
<p>Relaxation factor for the theta-step. 
</p>
</td></tr>
<tr><td><code id="cubinf.control_+3A_iug">iug</code></td>
<td>
<p>Parameter for the choice of the u-function in the A-step. 
See Marazzi, 1993, for details. 
</p>
</td></tr>
<tr><td><code id="cubinf.control_+3A_ipo">ipo</code></td>
<td>
<p>Parameter for the choice of the steplength algorithm in the theta-step.
If 'ipo=1', a quadratic comparison function is minimized.
If 'ipo=2', the Goldstein-Armijo step length algorithm is used. 
</p>
</td></tr>
<tr><td><code id="cubinf.control_+3A_ilg">ilg</code></td>
<td>
<p>Parameter for the choice of the algorithm in the c-step.
If 'ilg=1', the H-algorithm is used.
If 'ilg=2', the W-algorithm is used.
</p>
</td></tr>
<tr><td><code id="cubinf.control_+3A_icn">icn</code></td>
<td>
<p>Parameter for the choice of the convergence criterion for the theta-step and the main algorithm.
If 'icn=1', convergence is assumed when the change in each coefficient is less than 
the tolerance ('10*tlo') times an estimate of the coefficient variance. 
See Marazzi (1993, p. 281), for the other options ('icn=2' and 'icn=3'). 
</p>
</td></tr>
<tr><td><code id="cubinf.control_+3A_icv">icv</code></td>
<td>
<p>Parameter for the choice of the convergence criterion for the A-step. 
If 'icv=1', convergence is assumed when the norm of the difference between two consecutive 
values of A is less than the tolerance (10*tol).
See Marazzi (1993, p.288 and p. 301), for another option ('icv=2'). 
</p>
</td></tr>
<tr><td><code id="cubinf.control_+3A_ufact">ufact</code></td>
<td>
<p>The tuning constant b is set equal to ufact*sqrt(p), where p is the dimension of 
the observation vectors. The default value of b is 1.1*sqrt(p); this value is used when 'ufact=0' on input. 
</p>
</td></tr>
<tr><td><code id="cubinf.control_+3A_cpar">cpar</code></td>
<td>
<p>Parameter used in determining an initial value of theta (standard Mallows estimate, see Marazzi, 1993, p281). 
</p>
</td></tr>
<tr><td><code id="cubinf.control_+3A_null.dev">null.dev</code></td>
<td>
<p>If 'null.dev=TRUE', the null deviance is computed. The null deviance is the deviance 
of the model with no predictors. 
</p>
</td></tr>
<tr><td><code id="cubinf.control_+3A_...">...</code></td>
<td>
<p>Further named control arguments as singular.ok or qr.out used in the case where the
x matrix is singular</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>List of control parameters. 
</p>


<h3>References</h3>

<p>Marazzi, A. (1993).
Algorithms, Routines, and S-functions for robust Statistics.
Chapman and Hall, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cubinf">cubinf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#To compute the classical estimates using cubinf, set:
control &lt;- cubinf.control(ufact=300)
</code></pre>

<hr>
<h2 id='cubinf.missing'>
Missing methods for an object of class &quot;cubinf&quot;
</h2><span id='topic+anova'></span><span id='topic+add1'></span><span id='topic+drop1'></span><span id='topic+step'></span>

<h3>Description</h3>

<p>These functions are not implemented for an object of class &quot;cubinf&quot;. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
anova(object, ...)

add1(object, ...)
 
drop1(object, ...)
 
step(object, ...)
 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cubinf.missing_+3A_object">object</code></td>
<td>

<p>An object inheriting from class &quot;glm&quot; or &quot;cubinf&quot;.</p>
</td></tr>
<tr><td><code id="cubinf.missing_+3A_...">...</code></td>
<td>

<p>Optional arguments according to the method.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>The model fitting function <code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="#topic+cubinf">cubinf</a></code>
</p>

<hr>
<h2 id='cubinf.summaries'>
Functions required by the corresponding access functions 
</h2><span id='topic+residuals.cubinf'></span><span id='topic+summary.cubinf'></span><span id='topic+covar.cubinf'></span><span id='topic+deviance.cubinf'></span><span id='topic+family.cubinf'></span><span id='topic+Rank.cubinf'></span><span id='topic+rscale.cubinf'></span><span id='topic+weights.cubinf'></span>

<h3>Description</h3>

<p>Auxiliary functions for residuals(), summary(), covar(), deviance(), family(), Rank(), rscale(), weights().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cubinf'
residuals(object, type = c("deviance", "pearson", "response"), ...)

## S3 method for class 'cubinf'
summary(object, ...)
 
## S3 method for class 'cubinf'
covar(object)
 
## S3 method for class 'cubinf'
deviance(object, ...)

## S3 method for class 'cubinf'
family(object, ...)
 
## S3 method for class 'cubinf'
Rank(object)
 
## S3 method for class 'cubinf'
rscale(object)
 
## S3 method for class 'cubinf'
weights(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cubinf.summaries_+3A_object">object</code></td>
<td>
<p>An object inheriting from class &quot;cubinf&quot;.</p>
</td></tr> 
<tr><td><code id="cubinf.summaries_+3A_type">type</code></td>
<td>
<p>A character string for the residual type.</p>
</td></tr>
<tr><td><code id="cubinf.summaries_+3A_...">...</code></td>
<td>
<p>Optional arguments. For summary, it can be correlation=TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generic functions <code>coef</code>, <code>residuals</code>, <code>fitted</code>, <code>formula</code>, 
<code>deviance</code>, <code>rscale</code>, <code>r.squared</code>, <code>covar</code>, <code>correl</code>, <code>weights</code> 
and <code>Rank</code> can be used to extract elements from an object of class &quot;cubinf&quot; returned by <code>glm</code>. 
The class &quot;lm&quot; functions <code>effects</code>, <code>alias</code>, <code>add1</code>, <code>drop1</code>, codekappa,
<code>proj</code>, <code>step</code>, <code>influence</code>, <code>anova</code> and <code>sensitivity</code> are not
implemented to objects of class &quot;cubinf&quot;.
</p>


<h3>Value</h3>

<p>summary.cubinf returns a list with the following components: 
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The model formula used in glm. </p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>Terms object used in fitting the model. </p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>A matrix with three columns, containing the coefficients, their 
standard errors and the corresponding t-statistics.</p>
</td></tr>
<tr><td><code>dispersion</code></td>
<td>
<p>Dispersion coefficient </p>
</td></tr> 
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom for model and residuals. </p>
</td></tr>
<tr><td><code>deviance.resid</code></td>
<td>
<p>Deviance residuals</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>The family function used: binomial or poisson</p>
</td></tr>
<tr><td><code>cov.unscaled</code></td>
<td>
<p>Unscaled covariance matrix of coefficient estimates.</p>
</td></tr>
<tr><td><code>correlation</code></td>
<td>
<p>Correlation matrix of coefficient estimates.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>Deviance.</p>
</td></tr>
<tr><td><code>null.deviance</code></td>
<td>
<p>Null deviance. </p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Number of iterations of the main algorithm. </p>
</td></tr>
<tr><td><code>nas</code></td>
<td>
<p>A logical vector whose i-th component is TRUE if the i-th coefficient is NA. </p>
</td></tr>
</table>


<h3>See Also</h3>

<p>The model fitting function <code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="#topic+cubinf">cubinf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> library(robcbi)
 data(Finney)
 Vol &lt;- Finney$Vol; Rate &lt;- Finney$Rate; Resp &lt;- Finney$Resp
 lVol &lt;-log(Vol); lRate &lt;- log(Rate)
 z.glm &lt;- glm(Resp~lVol+lRate,family=binomial)
 summary(z.glm)
 z.cub &lt;- glm(Resp~lVol+lRate,family=binomial,method="cubinf", ufact=3.2)
 summary(z.cub)
 weights(z.cub)
 covar(z.cub)
 deviance(z.cub)
 Rank(z.cub)
 residuals(z.cub)
 rscale(z.cub)
</code></pre>

<hr>
<h2 id='Finney'>
Finney data from 'Annals of Eugenics' 1947
</h2><span id='topic+Finney'></span>

<h3>Description</h3>

<p>Finney data over 39 observations on occurence or not of vaso-constriction.
The data were obtained in a study of the effect of the rate and volume 
of air inspired on a transcient vaso-constriction in the skin of the digits. 
The R function, plotFdat, for plotting the variables is included in the list. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Finney)
</code></pre>


<h3>Format</h3>

<p>A list with the following components
</p>

<dl>
<dt>Resp</dt><dd><p>Occurence (Resp=1) or not (Resp=0) of vaso-constriction</p>
</dd>
<dt>Vol</dt><dd><p>Volume of air inspired</p>
</dd>
<dt>Rate</dt><dd><p>Observed Rate</p>
</dd>
<dt>plotFdat</dt><dd><p>R function for plotting the response and explanatory variables</p>
</dd>
</dl>


<h3>Source</h3>

<p>Finney (1947), The truncated binomial distribution, Annals of Eugenics, 14: 319-328.
</p>


<h3>References</h3>

<p>Kuensch, H.R., Stefanski L.A., Carroll R.J. (1989).
Conditionally unbiased bounded-influence estimation in general regression models,
with application to generalized linear models. 
Journal of the American Statistical Association, 84, 460-466.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(robcbi)
data(Finney)
Vol   &lt;- Finney$Vol; Rate &lt;- Finney$Rate; Resp  &lt;- Finney$Resp
lVol  &lt;- log(Vol);  lRate &lt;- log(Rate)
</code></pre>

<hr>
<h2 id='fits.compare'>
Comparison of fits
</h2><span id='topic+fits.compare'></span><span id='topic+print.fits.compare'></span>

<h3>Description</h3>

<p>The fits.compare function accepts a sequence of objects of class
&quot;glm&quot;, &quot;cubinf&quot;, or &quot;aov&quot; (with optional names), and creates a class &quot;fits.compare&quot; object. 
The print.fits.compare function prints summaries of each
of the input objects in a manner suitable for comparing the input models. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fits.compare'
print(x, digits = max(3, .Options$digits - 3), ...)

fits.compare(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fits.compare_+3A_x">x</code></td>
<td>

<p>An object inheriting from class &quot;fits.compare&quot;, the result of a call to <code>fits.compare</code>. 
</p>
</td></tr>
<tr><td><code id="fits.compare_+3A_digits">digits</code></td>
<td>

<p>Minimal number of <em>significant digits</em>.
</p>
</td></tr>
<tr><td><code id="fits.compare_+3A_...">...</code></td>
<td>

<p>In <code>fits.compare()</code>, <code>...</code> is a sequence of objects of class &quot;lm&quot;, &quot;lm.robust&quot;, or &quot;aov&quot;. 
Otherwise <code>...</code> represents further arguments passed to or from <code>print</code> method.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is not recommended to compare objects with different structures.
</p>


<h3>See Also</h3>

<p>The model fitting function <code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="#topic+cubinf">cubinf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> library(robcbi)
 data(Finney)
 Vol &lt;- Finney$Vol; Rate &lt;- Finney$Rate; Resp &lt;- Finney$Resp
 lVol &lt;-log(Vol); lRate &lt;- log(Rate)
 z.glm &lt;- glm(Resp~lVol+lRate,family=binomial)
 z.cub &lt;- glm(Resp~lVol+lRate,family=binomial,method="cubinf", ufact=3.2)
 comp &lt;- fits.compare(z.glm,z.cub)
 comp
</code></pre>

<hr>
<h2 id='glm.summaries'>
Accessor functions for objects the class &quot;glm&quot;
</h2><span id='topic+covar.glm'></span><span id='topic+Rank.glm'></span><span id='topic+rscale.glm'></span><span id='topic+weights.glm'></span>

<h3>Description</h3>

<p>Covariance matrix of the coefficient estimates, rank, scale estimate and the weights 
for class &quot;glm&quot; objects. All these functions are methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'glm'
covar(object)
 
## S3 method for class 'glm'
Rank(object)
 
## S3 method for class 'glm'
rscale(object)
 
## S3 method for class 'glm'
weights(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glm.summaries_+3A_object">object</code></td>
<td>

<p>An object inheriting from class &quot;glm&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generic accessor functions <code>coef</code>, <code>residuals</code>, <code>fitted</code>, <code>formula</code>, 
<code>deviance</code>, <code>rscale</code>, <code>covar</code>, <code>correl</code>, <code>weights</code> 
and <code>Rank</code> can be used to extract elements from an object returned by <code>glm</code>. 
</p>


<h3>See Also</h3>

<p>The model fitting function <code><a href="stats.html#topic+glm">glm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> library(robcbi)
 data(Finney)
 Vol &lt;- Finney$Vol; Rate &lt;- Finney$Rate; Resp &lt;- Finney$Resp
 lVol &lt;-log(Vol); lRate &lt;- log(Rate)
 z.glm &lt;- glm(Resp~lVol+lRate,family=binomial)
 summary(z.glm)
 covar(z.glm)
 Rank(z.glm)
 rscale(z.glm)
 weights(z.glm)
</code></pre>

<hr>
<h2 id='plot.cubinf'>Diagnostic plots for an object of class &quot;cubinf&quot;
</h2><span id='topic+plot.cubinf'></span>

<h3>Description</h3>

<p>Six plots are available:
Residuals vs Fitted Values, Sqrt of abs(Residuals) vs Fitted Values, 
Response vs Fitted Values&quot; and  QQline of Residuals. 
r-f spread plot is not available and Cook's distances are not available for objects of class &quot;cubinf&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cubinf'
plot(x, residuals = NULL, smooths = FALSE, rugplot = FALSE, id.n = 0, 
  ask = TRUE, num=0,  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cubinf_+3A_x">x</code></td>
<td>

<p>An object of class &quot;cubinf&quot;
</p>
</td></tr>
<tr><td><code id="plot.cubinf_+3A_residuals">residuals</code></td>
<td>
<p>The residuals to be used in the plots if not null.
</p>
</td></tr>
<tr><td><code id="plot.cubinf_+3A_smooths">smooths</code></td>
<td>
<p>Logical indicating if a smoother should be added to most plots.
</p>
</td></tr>
<tr><td><code id="plot.cubinf_+3A_rugplot">rugplot</code></td>
<td>
<p>Logical indicating if a &quot;rug&quot; representation of the data should be added 
to the plot.
</p>
</td></tr>
<tr><td><code id="plot.cubinf_+3A_id.n">id.n</code></td>
<td>
<p>Number of points to be labelled in each plot, starting with the most extreme.
</p>
</td></tr>
<tr><td><code id="plot.cubinf_+3A_ask">ask</code></td>
<td>
<p>If ask=TRUE, the function operates in interactive mode.
</p>
</td></tr>
<tr><td><code id="plot.cubinf_+3A_...">...</code></td>
<td>
<p>Optional arguments for <code><a href="graphics.html#topic+par">par</a>.</code>
</p>
</td></tr>
<tr><td><code id="plot.cubinf_+3A_num">num</code></td>
<td>
<p>Integer between 0 and 6. If num&gt;0, plot the num-th choice in the previous list
in batch mode. 
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+glm.fit">glm.fit</a></code>, <code><a href="graphics.html#topic+plot.default">plot.default</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> library(robcbi)
 data(Finney)
 Vol &lt;- Finney$Vol; Rate &lt;- Finney$Rate; Resp &lt;- Finney$Resp
 lVol &lt;-log(Vol); lRate &lt;- log(Rate)
 z.cub &lt;- glm(Resp~lVol+lRate,family=binomial,method="cubinf", ufact=3.2)
 summary(z.cub)
## Not run: 
 plot(z.cub, smooth=TRUE, ask=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.fits.compare'>
Plots for comparing fits 
</h2><span id='topic+plot.fits.compare'></span>

<h3>Description</h3>

<p>Plots the results of a call to fits.compare. 
Plotting the &quot;fits.compare&quot; object results in a sequence of graphical
displays. These displays are designed to be of use in comparing two sets of 
parameter estimates in linear models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fits.compare'
plot(x, xplots = FALSE, ..., ask = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fits.compare_+3A_x">x</code></td>
<td>

<p>An object inheriting from class &quot;fits.compare&quot;, the result of a call to <code>fits.compare</code>. 
</p>
</td></tr>
<tr><td><code id="plot.fits.compare_+3A_xplots">xplots</code></td>
<td>

<p>If TRUE, the graphics are displayed.
</p>
</td></tr>
<tr><td><code id="plot.fits.compare_+3A_...">...</code></td>
<td>

<p>Further arguments passed to or from <code>plot</code> method.
</p>
</td></tr>
<tr><td><code id="plot.fits.compare_+3A_ask">ask</code></td>
<td>

<p>Graphical parameter, if TRUE (and the R session is interactive) the user is asked for 
input, before a new figure is drawn.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is not recommended to compare objects with different structures.
</p>


<h3>See Also</h3>

<p>The model fitting function <code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="#topic+cubinf">cubinf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> library(robcbi)
 data(Finney)
 Vol &lt;- Finney$Vol; Rate &lt;- Finney$Rate; Resp &lt;- Finney$Resp
 lVol &lt;-log(Vol); lRate &lt;- log(Rate)
 z.glm &lt;- glm(Resp~lVol+lRate,family=binomial)
 z.cub &lt;- glm(Resp~lVol+lRate,family=binomial,method="cubinf", ufact=3.2)
 comp &lt;- fits.compare(z.glm,z.cub)
 comp
## Not run: 
 plot(comp)

## End(Not run)
</code></pre>

<hr>
<h2 id='predict.cubinf'>
Prediction methods for objects of class &quot;cubinf&quot;
</h2><span id='topic+predict.cubinf'></span>

<h3>Description</h3>

<p>Predictions provided by a model fit when method is &quot;cubinf&quot;.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cubinf'
predict(object, newdata, type = c("link", "response", "terms"), 
   se.fit = FALSE, terms = labels(object$terms), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.cubinf_+3A_object">object</code></td>
<td>
<p>An object of class &quot;cubinf&quot; for which predictions are desired.
</p>
</td></tr>
<tr><td><code id="predict.cubinf_+3A_newdata">newdata</code></td>
<td>
<p>Specify the explanatory variables to used.
</p>
</td></tr>
<tr><td><code id="predict.cubinf_+3A_type">type</code></td>
<td>
<p>The prediction type.
</p>
</td></tr>
<tr><td><code id="predict.cubinf_+3A_se.fit">se.fit</code></td>
<td>
<p>Logical to specify if standard errors are returned or not.
</p>
</td></tr>
<tr><td><code id="predict.cubinf_+3A_terms">terms</code></td>
<td>
<p>The terms in newdata.
</p>
</td></tr>
<tr><td><code id="predict.cubinf_+3A_...">...</code></td>
<td>
<p>Additional arguments affecting the predictions produced.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value returned depends on type.
</p>


<h3>References</h3>

<p>Marazzi, A. (1993). <em>Algorithms, Routines, and S-functions for robust Statistics.</em>
Chapman and Hall, New York.
</p>
<p>Kuensch, H.R., Stefanski L.A., Carroll R.J. (1989).
Conditionally unbiased bounded-influence estimation in general regression models,
with application to generalized linear models. 
Journal of the American Statistical Association, 84, 460-466.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+predict.glm">predict.glm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> library(robcbi)
 data(Finney)
 Vol &lt;- Finney$Vol; Rate &lt;- Finney$Rate; Resp &lt;- Finney$Resp
 df &lt;- data.frame(lVol = log(Vol), lRate = log(Rate), Resp = Resp)
 z.cub &lt;- glm(Resp~lVol+lRate,family=binomial,data=df,method="cubinf",ufact=3.2)
 set.seed(123)
 rVol  &lt;- runif(20,0.4,3.7); rRate &lt;- runif(20,0.3,3.75)
 newdat &lt;- data.frame(lVol=log(rVol),lRate=log(rRate))
 predict(z.cub, newdat, type="response")
</code></pre>

<hr>
<h2 id='QQline'>
Add a theoretical QQ-line in a plot
</h2><span id='topic+QQline'></span>

<h3>Description</h3>

<p>Adds a QQ-line for the values in x in the current plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QQline(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QQline_+3A_x">x</code></td>
<td>
<p>The sample for QQ-line
</p>
</td></tr>
<tr><td><code id="QQline_+3A_...">...</code></td>
<td>
<p>Graphical parameters
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The intercept and the slope of the QQ-line are returned
</p>


<h3>References</h3>

<p>Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) <em>The New S Language</em>. 
Wadsworth &amp; Brooks/Cole. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(robcbi)
data(Finney)
Vol  &lt;- Finney$Vol; Rate &lt;- Finney$Rate; Resp &lt;- Finney$Resp
lVol &lt;-log(Vol); lRate &lt;- log(Rate)
z.cub &lt;- glm(Resp~lVol+lRate,family=binomial,method="cubinf", ufact=3.2)
x    &lt;- residuals(z.cub, type="deviance")
## Not run: 
qqnorm(x, ylab = "Deviance Residuals")
QQline(x, lty = 2)

## End(Not run)
</code></pre>

<hr>
<h2 id='robust.print.summaries'>
Print methods for objects of class &quot;cubinf&quot;, &quot;cubinf.i&quot;, &quot;summary.cubinf&quot; or &quot;glm.i&quot;
</h2><span id='topic+print.cubinf'></span><span id='topic+print.cubinf.i'></span><span id='topic+print.summary.cubinf'></span><span id='topic+print.glm.i'></span>

<h3>Description</h3>

<p>Printing linear model fits provided by glm or with method=&quot;cubinf&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cubinf'
print(x, ai = FALSE, ci = FALSE, A.mat = FALSE, ...)

## S3 method for class 'summary.cubinf'
print(x, ...)

## S3 method for class 'glm.i'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="robust.print.summaries_+3A_x">x</code></td>
<td>

<p>An object result of a call to <code>summary.cubinf</code> (first usage),
to <code>glm</code> with method=&quot;cubinf&quot; (second usage),
to <code>rscale.cubinf</code> or to <code>summary.cubinf</code> or to <code>weights.cubinf</code>
or to <code>covar.cubinf</code> (third usage) and respectively to <code>rscale.glm</code> or 
or to <code>covar.glm</code> or to <code>weights.glm</code>.
</p>
</td></tr>
<tr><td><code id="robust.print.summaries_+3A_ai">ai</code></td>
<td>
<p>Vector with components a_i=ufact/|Ax_i| (where x_i^T 
denotes the ith row of the model matrix).
</p>
</td></tr>
<tr><td><code id="robust.print.summaries_+3A_ci">ci</code></td>
<td>
<p>Vector of the final bias corrections.
</p>
</td></tr>
<tr><td><code id="robust.print.summaries_+3A_a.mat">A.mat</code></td>
<td>
<p>The final value of the matrix A.
</p>
</td></tr>
<tr><td><code id="robust.print.summaries_+3A_...">...</code></td>
<td>

<p>Further optional arguments according to the print method. Implicit argument in all these 
functions is digits = max(3, .Options$digits - 3).
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Kuensch, H.R., Stefanski L.A., Carroll R.J. (1989).
Conditionally unbiased bounded-influence estimation in general regression models,
with application to generalized linear models. 
Journal of the American Statistical Association, 84, 460-466.
</p>
<p>Marazzi, A. (1993).
Algorithms, Routines, and S-functions for robust Statistics.
Chapman and Hall, New York.
</p>


<h3>See Also</h3>

<p>The model fitting function <code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="#topic+cubinf">cubinf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(robcbi)
 
## Dobson (1990) Page 93: Randomized Controlled Trial :
 counts &lt;- c(18,17,15,20,10,20,25,13,12)
 outcome &lt;- gl(3,1,9)
 treatment &lt;- gl(3,3)
 print(d.AD &lt;- data.frame(treatment, outcome, counts))
 zD93 &lt;- glm(counts ~ outcome + treatment, family=poisson,method="cubinf",ufact=3.2)
 summary(zD93)
 print(zD93)
 wi &lt;- weights(zD93)
 print(wi)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
