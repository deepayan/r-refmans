<!DOCTYPE html><html><head><title>Help for package gstat</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gstat}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coalash'><p>Coal ash samples from a mine in Pennsylvania</p></a></li>
<li><a href='#DE_RB_2005'>
<p>Spatio-temporal data set with rural background PM10 concentrations in Germany 2005</p></a></li>
<li><a href='#estiStAni'>
<p>Estimation of the spatio-temporal anisotropy</p></a></li>
<li><a href='#extractPar'>
<p>Extracting parameters and their names from a spatio-temporal variogram model</p></a></li>
<li><a href='#fit.lmc'><p> Fit a Linear Model of Coregionalization to a Multivariable Sample Variogram</p></a></li>
<li><a href='#fit.StVariogram'><p>Fit a spatio-temporal sample variogram to a sample variogram</p></a></li>
<li><a href='#fit.variogram'><p> Fit a Variogram Model to a Sample Variogram</p></a></li>
<li><a href='#fit.variogram.gls'><p> GLS fitting of variogram parameters</p></a></li>
<li><a href='#fit.variogram.reml'><p> REML Fit Direct Variogram Partial Sills to Data</p></a></li>
<li><a href='#fulmar'><p>Fulmaris glacialis data</p></a></li>
<li><a href='#get.contr'><p> Calculate contrasts from multivariable predictions</p></a></li>
<li><a href='#gstat'><p> Create gstat objects, or subset it</p></a></li>
<li><a href='#gstat-internal'><p>Gstat Internal Functions</p></a></li>
<li><a href='#hscat'>
<p>Produce h-scatterplot</p></a></li>
<li><a href='#image'>
<p>Image Gridded Coordinates in Data Frame</p></a></li>
<li><a href='#jura'><p>Jura data set</p></a></li>
<li><a href='#krige'><p> Simple, Ordinary or Universal, global or local, Point or Block Kriging,</p>
or simulation.</a></li>
<li><a href='#krige.cv'><p> (co)kriging cross validation, n-fold or leave-one-out</p></a></li>
<li><a href='#krigeSimCE'><p>Simulation based on circulant embedding</p></a></li>
<li><a href='#krigeST'><p> Ordinary global Spatio-Temporal Kriging</p></a></li>
<li><a href='#krigeSTSimTB'><p>conditional/unconditional spatio-temporal simulation</p></a></li>
<li><a href='#krigeTg'><p> TransGaussian kriging using Box-Cox transforms</p></a></li>
<li><a href='#map.to.lev'><p> rearrange data frame for plotting with levelplot</p></a></li>
<li><a href='#meuse.all'><p>Meuse river data set &ndash; original, full data set</p></a></li>
<li><a href='#meuse.alt'><p>Meuse river altitude data set</p></a></li>
<li><a href='#ncp.grid'><p>Grid for the NCP, the Dutch part of the North Sea</p></a></li>
<li><a href='#ossfim'><p> Kriging standard errors as function of grid spacing and block size</p></a></li>
<li><a href='#oxford'><p>Oxford soil samples</p></a></li>
<li><a href='#pcb'><p>PCB138 measurements in sediment at the NCP, the Dutch part of the North Sea</p></a></li>
<li><a href='#plot.gstatVariogram'>
<p>Plot a sample variogram, and possibly a fitted model</p></a></li>
<li><a href='#plot.pointPairs'>
<p>Plot a point pairs, identified from a variogram cloud</p></a></li>
<li><a href='#plot.variogramCloud'>
<p>Plot and Identify Data Pairs on Sample Variogram Cloud</p></a></li>
<li><a href='#predict'><p> Multivariable Geostatistical Prediction and Simulation</p></a></li>
<li><a href='#progress'><p> Get or set progress indicator</p></a></li>
<li><a href='#show.vgms'>
<p>Plot Variogram Model Functions</p></a></li>
<li><a href='#sic2004'><p> Spatial Interpolation Comparison 2004 data set: Natural Ambient Radioactivity</p></a></li>
<li><a href='#sic97'><p> Spatial Interpolation Comparison 1997 data set: Swiss Rainfall</p></a></li>
<li><a href='#spplot.vcov'><p> Plot map matrix of prediction error variances and covariances</p></a></li>
<li><a href='#tull'><p>SÃ¼dliche Tullnerfeld data set</p></a></li>
<li><a href='#variogram'><p> Calculate Sample or Residual Variogram or Variogram Cloud</p></a></li>
<li><a href='#variogramLine'><p> Semivariance Values For a Given Variogram Model</p></a></li>
<li><a href='#variogramST'><p>Calculate Spatio-Temporal Sample Variogram</p></a></li>
<li><a href='#variogramSurface'><p>Semivariance values for a given spatio-temporal variogram model</p></a></li>
<li><a href='#vgm'>
<p>Generate, or Add to Variogram Model</p></a></li>
<li><a href='#vgm.panel.xyplot'><p> panel functions for most of the variogram plots through lattice</p></a></li>
<li><a href='#vgmArea'><p> point-point, point-area or area-area semivariance</p></a></li>
<li><a href='#vgmAreaST'>
<p>Function that returns the covariances for areas</p></a></li>
<li><a href='#vgmST'><p>Constructing a spatio-temporal variogram</p></a></li>
<li><a href='#vv'><p>Precomputed variogram for PM10 in data set air</p></a></li>
<li><a href='#walker'><p>Walker Lake sample and exhaustive data sets</p></a></li>
<li><a href='#wind'><p>Ireland wind data, 1961-1978</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.1-1</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatial and Spatio-Temporal Geostatistical Modelling, Prediction
and Simulation</td>
</tr>
<tr>
<td>Description:</td>
<td>Variogram modelling; simple, ordinary and universal point or block (co)kriging; spatio-temporal kriging; sequential Gaussian or indicator (co)simulation; variogram and variogram map plotting utility functions; supports sf and stars.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, stats, graphics, methods, lattice, sp (&ge; 0.9-72), zoo,
sf (&ge; 0.7-2), sftime, spacetime (&ge; 1.2-8), stars, FNN</td>
</tr>
<tr>
<td>Suggests:</td>
<td>fields, maps, mapdata, xts, raster, future, future.apply</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2.0)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/r-spatial/gstat/">https://github.com/r-spatial/gstat/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-spatial/gstat/issues/">https://github.com/r-spatial/gstat/issues/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-06 09:22:07 UTC; edzer</td>
</tr>
<tr>
<td>Author:</td>
<td>Edzer Pebesma <a href="https://orcid.org/0000-0001-8049-7069"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Benedikt Graeler [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Edzer Pebesma &lt;edzer.pebesma@uni-muenster.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-06 10:32:40 UTC</td>
</tr>
</table>
<hr>
<h2 id='coalash'>Coal ash samples from a mine in Pennsylvania</h2><span id='topic+coalash'></span>

<h3>Description</h3>

<p>Data obtained from Gomez and Hazen (1970, Tables 19 and 20) on coal ash
for the Robena Mine Property in Greene County Pennsylvania.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(coalash)
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>x</dt><dd><p>a numeric vector; x-coordinate; reference unknown </p>
</dd>
<dt>y</dt><dd><p>a numeric vector; x-coordinate; reference unknown </p>
</dd>
<dt>coalash</dt><dd><p>the target variable</p>
</dd>
</dl>
 


<h3>Note</h3>

<p> data are also present in package fields, as coalash.  </p>


<h3>Author(s)</h3>

<p> unknown; R version prepared by Edzer Pebesma; data obtained from
<a href="http://homepage.divms.uiowa.edu/~dzimmer/spatialstats/">http://homepage.divms.uiowa.edu/~dzimmer/spatialstats/</a>, Dale Zimmerman's
course page </p>


<h3>References</h3>

<p> N.A.C. Cressie, 1993, Statistics for Spatial Data,
Wiley. 
</p>
<p>Gomez, M. and Hazen, K. (1970). Evaluating sulfur and ash
distribution in coal seems by statistical response surface regression
analysis. U.S. Bureau of Mines Report RI 7377.
</p>
<p>see also fields manual: 
<a href="https://www.image.ucar.edu/GSP/Software/Fields/fields.manual.coalashEX.Krig.shtml">https://www.image.ucar.edu/GSP/Software/Fields/fields.manual.coalashEX.Krig.shtml</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(coalash)
summary(coalash)
</code></pre>

<hr>
<h2 id='DE_RB_2005'>
Spatio-temporal data set with rural background PM10 concentrations in Germany 2005
</h2><span id='topic+DE_RB_2005'></span>

<h3>Description</h3>

<p>Spatio-temporal data set with rural background PM10 concentrations in Germany 2005 (airbase v6). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("DE_RB_2005")</code></pre>


<h3>Format</h3>

<p>The format is:
Formal class 'STSDF' [package &quot;spacetime&quot;] with 5 slots
..@ data   :'data.frame':	23230 obs. of  2 variables:
.. ..$ PM10   : num [1:23230] 16.7 31.7 5 22.4 26.8 ...
.. ..$ logPM10: num [1:23230] 2.82 3.46 1.61 3.11 3.29 ...
..@ index  : int [1:23230, 1:2] 1 2 3 4 5 6 7 8 9 10 ...
..@ sp     :Formal class 'SpatialPointsDataFrame' [package &quot;sp&quot;] with 5 slots
.. .. ..@ data       :'data.frame':	69 obs. of  9 variables:
.. .. .. ..$ station_altitude     : int [1:69] 8 3 700 15 35 50 343 339 45 45 ...
.. .. .. ..$ station_european_code: Factor w/ 7965 levels &quot;AD0942A&quot;,&quot;AD0944A&quot;,..: 1991 1648 1367 2350 1113 1098 1437 2043 1741 1998 ...
.. .. .. ..$ country_iso_code     : Factor w/ 39 levels &quot;AD&quot;,&quot;AL&quot;,&quot;AT&quot;,..: 10 10 10 10 10 10 10 10 10 10 ...
.. .. .. ..$ station_start_date   : Factor w/ 2409 levels &quot;1900-01-01&quot;,&quot;1951-04-01&quot;,..: 152 1184 1577 1132 744 328 1202 1555 1148 407 ...
.. .. .. ..$ station_end_date     : Factor w/ 864 levels &quot;&quot;,&quot;1975-02-06&quot;,..: 1 1 1 579 1 1 1 1 1 1 ...
.. .. .. ..$ type_of_station      : Factor w/ 5 levels &quot;&quot;,&quot;Background&quot;,..: 2 2 2 2 2 2 2 2 2 2 ...
.. .. .. ..$ station_type_of_area : Factor w/ 4 levels &quot;rural&quot;,&quot;suburban&quot;,..: 1 1 1 1 1 1 1 1 1 1 ...
.. .. .. ..$ street_type          : Factor w/ 5 levels &quot;&quot;,&quot;Canyon street: L/H &lt; 1.5&quot;,..: 4 1 1 1 1 1 1 1 1 1 ...
.. .. .. ..$ annual_mean_PM10     : num [1:69] 20.9 21.8 16.5 20.3 23.3 ...
.. .. ..@ coords.nrs : num(0) 
.. .. ..@ coords     : num [1:69, 1:2] 538709 545414 665711 551796 815738 ...
.. .. .. ..- attr(*, &quot;dimnames&quot;)=List of 2
.. .. .. .. ..$ : chr [1:69] &quot;DESH001&quot; &quot;DENI063&quot; &quot;DEBY109&quot; &quot;DEUB038&quot; ...
.. .. .. .. ..$ : chr [1:2] &quot;coords.x1&quot; &quot;coords.x2&quot;
.. .. ..@ bbox       : num [1:2, 1:2] 307809 5295752 907375 6086661
.. .. .. ..- attr(*, &quot;dimnames&quot;)=List of 2
.. .. .. .. ..$ : chr [1:2] &quot;coords.x1&quot; &quot;coords.x2&quot;
.. .. .. .. ..$ : chr [1:2] &quot;min&quot; &quot;max&quot;
.. .. ..@ proj4string:Formal class 'CRS' [package &quot;sp&quot;] with 1 slot
.. .. .. .. ..@ projargs: chr &quot;+init=epsg:32632 +proj=utm +zone=32 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0&quot;
..@ time   :An ?xts? object on 2005-01-01/2005-12-31 containing:
Data: int [1:365, 1] 5115 5116 5117 5118 5119 5120 5121 5122 5123 5124 ...
- attr(*, &quot;dimnames&quot;)=List of 2
..$ : NULL
..$ : chr &quot;..1&quot;
Indexed by objects of class: [POSIXct,POSIXt] TZ: GMT
xts Attributes:  
NULL
..@ endTime: POSIXct[1:365], format: &quot;2005-01-02&quot; &quot;2005-01-03&quot; &quot;2005-01-04&quot; &quot;2005-01-05&quot; ...
</p>


<h3>Source</h3>

<p>EEA, airbase v6
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(DE_RB_2005)
str(DE_RB_2005)
</code></pre>

<hr>
<h2 id='estiStAni'>
Estimation of the spatio-temporal anisotropy
</h2><span id='topic+estiStAni'></span>

<h3>Description</h3>

<p>Estimation of the spatio-temporal anisotropy without an underlying spatio-temporal model. Different methods are implemented using a linear model to predict the temporal gamma values or the ratio of the ranges of a spatial and temporal variogram model or a spatial variogram model to predict the temporal gamma values or the spatio-temporal anisotropy value as used in a metric spatio-temporal variogram. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estiStAni(empVgm, interval, method = "linear", spatialVgm, 
          temporalVgm, s.range=NA, t.range=NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estiStAni_+3A_empvgm">empVgm</code></td>
<td>

<p>An empirical spatio-temporal variogram.
</p>
</td></tr>
<tr><td><code id="estiStAni_+3A_interval">interval</code></td>
<td>

<p>A search interval for the optimisation of the spatio-temporal anisotropy parameter
</p>
</td></tr>
<tr><td><code id="estiStAni_+3A_method">method</code></td>
<td>

<p>A character string determining the method to be used (one of <code>linear</code>, <code>range</code>, <code>vgm</code> or <code>metric</code>, see below for details)
</p>
</td></tr>
<tr><td><code id="estiStAni_+3A_spatialvgm">spatialVgm</code></td>
<td>

<p>A spatial variogram definition from the call to <code><a href="#topic+vgm">vgm</a></code>. The model is optimised based on the pure spatial values in <code>empVgm</code>.
</p>
</td></tr>
<tr><td><code id="estiStAni_+3A_temporalvgm">temporalVgm</code></td>
<td>

<p>A temporal variogram definition from the call to <code><a href="#topic+vgm">vgm</a></code>. The model is optimised based on the pure temporal values in <code>empVgm</code>.</p>
</td></tr>
<tr><td><code id="estiStAni_+3A_s.range">s.range</code></td>
<td>

<p>A spatial cutoff value applied to the empirical variogram <code>empVgm</code>.  
</p>
</td></tr>
<tr><td><code id="estiStAni_+3A_t.range">t.range</code></td>
<td>

<p>A temporal cutoff value applied to the empirical variogram <code>empVgm</code>.  
</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>linear</dt><dd>
<p>A linear model is fitted to the pure spatial gamma values based on the spatial distances. An optimal scaling is searched to stretch the temporal distances such that the linear model explains best the pure temporal gamma values. This assumes (on average) a linear relationship between distance and gamma, hence it is advisable to use only those pairs of pure spatial (pure temporal) distance and gamma value that show a considerable increase (i.e. drop all values beyond the range by setting values for <code>s.range</code> and <code>t.range</code>).
</p>
</dd>
<dt>range</dt><dd>
<p>A spatial and temporal variogram model is fitted to the pure spatial and temporal gamma values respectively. The spatio-temporal anisotropy estimate is the ratio of the spatial range over the temporal range.
</p>
</dd>
<dt>vgm</dt><dd>
<p>A spatial variogram model is fitted to the pure spatial gamma values. An optimal scaling is used to stretch the temporal distances such that the spatial variogram model explains best the pure temporal gamma values.
</p>
</dd>
<dt>metric</dt><dd>
<p>A metric spatio-temporal variogram model is fitted with <code>joint</code> component according to the defined spatial variogram <code>spatialVgm</code>. The starting value of <code>stAni</code> is the mean of the <code>interval</code> parameter (see <code><a href="#topic+vgmST">vgmST</a></code> for the metric variogram definition). The spatio-temporal anisotropy as estimated in the spatio-temporal variogram is returned. Note that the parameter <code>interval</code> is only used to set the starting value. Hence, the estimate might exceed the given interval.
</p>
</dd>
</dl>



<h3>Value</h3>

<p>A scalar representing the spatio-temporal anisotropy estimate.</p>


<h3>Note</h3>

<p>Different methods might lead to very different estimates. All but the <code>linear</code> approach are sensitive to the variogram model selection.</p>


<h3>Author(s)</h3>

<p>Benedikt Graeler</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(vv)

estiStAni(vv, c(10, 150))
estiStAni(vv, c(10, 150), "vgm", vgm(80, "Sph", 120, 20))
</code></pre>

<hr>
<h2 id='extractPar'>
Extracting parameters and their names from a spatio-temporal variogram model
</h2><span id='topic+extractPar'></span><span id='topic+extractParNames'></span>

<h3>Description</h3>

<p>All spatio-temporal variogram models have a different set of parameters. These functions extract the parameters and their names from the spatio-temporal variogram model. Note, this function is as well used to pass the parameters to the optim function. The arguments lower and upper passed to optim should follow the same structure. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractPar(model)
extractParNames(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractPar_+3A_model">model</code></td>
<td>
<p>a spatio-temporal variogram model from <code><a href="#topic+vgmST">vgmST</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named numeric vector of parameters or a vector of characters holding the parameters' names.
</p>


<h3>Author(s)</h3>

<p>Benedikt Graeler
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit.StVariogram">fit.StVariogram</a></code> and <code><a href="#topic+vgmST">vgmST</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sumMetricModel &lt;- vgmST("sumMetric",
                        space=vgm(30, "Sph", 200,  6),
                        time =vgm(30, "Sph",  15,  7),
                        joint=vgm(60, "Exp",  84, 22),
                        stAni=100)

extractPar(sumMetricModel)
extractParNames(sumMetricModel)
</code></pre>

<hr>
<h2 id='fit.lmc'> Fit a Linear Model of Coregionalization to a Multivariable Sample Variogram </h2><span id='topic+fit.lmc'></span>

<h3>Description</h3>

<p>Fit a Linear Model of Coregionalization to a Multivariable Sample Variogram;
in case of a single variogram model (i.e., no nugget) this is equivalent to
Intrinsic Correlation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.lmc(v, g, model, fit.ranges = FALSE, fit.lmc = !fit.ranges, 
correct.diagonal = 1.0, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.lmc_+3A_v">v</code></td>
<td>
<p> multivariable sample variogram, output of <a href="#topic+variogram">variogram</a> </p>
</td></tr>
<tr><td><code id="fit.lmc_+3A_g">g</code></td>
<td>
<p> gstat object, output of <a href="#topic+gstat">gstat</a> </p>
</td></tr>
<tr><td><code id="fit.lmc_+3A_model">model</code></td>
<td>
<p> variogram model, output of <a href="#topic+vgm">vgm</a>; if supplied 
this value is used as initial value for each fit </p>
</td></tr>
<tr><td><code id="fit.lmc_+3A_fit.ranges">fit.ranges</code></td>
<td>
<p> logical; determines whether the range coefficients
(excluding that of the nugget component) should be fitted; or logical
vector: determines for each range parameter of the variogram model
whether it should be fitted or fixed. </p>
</td></tr>
<tr><td><code id="fit.lmc_+3A_fit.lmc">fit.lmc</code></td>
<td>
<p> logical; if TRUE, each coefficient matrices of partial
sills is guaranteed to be positive definite </p>
</td></tr>
<tr><td><code id="fit.lmc_+3A_correct.diagonal">correct.diagonal</code></td>
<td>
<p> multiplicative correction factor to be applied
to partial sills of direct variograms only; the default value, 1.0, does
not correct. If you encounter problems with singular covariance matrices
during cokriging or cosimulation, you may want to try to increase this
to e.g. 1.01 </p>
</td></tr>
<tr><td><code id="fit.lmc_+3A_...">...</code></td>
<td>
<p> parameters that get passed to <a href="#topic+fit.variogram">fit.variogram</a> </p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns an object of class <code>gstat</code>, with fitted variograms;
</p>


<h3>Note</h3>

<p> This function does not use the iterative procedure proposed by
M. Goulard and M. Voltz (Math. Geol., 24(3): 269-286; reproduced in
Goovaerts' 1997 book) but uses simply two steps: first, each variogram
model is fitted to a direct or cross variogram; next each of the partial
sill coefficient matrices is approached by its in least squares sense
closest positive definite matrices (by setting any negative eigenvalues
to zero). 
</p>
<p>The argument <code>correct.diagonal</code> was introduced by experience: by
zeroing the negative eigenvalues for fitting positive definite partial
sill matrices, apparently still perfect correlation may result, leading
to singular cokriging/cosimulation matrices. If someone knows of a more
elegant way to get around this, please let me know.
</p>


<h3>Author(s)</h3>

<p> Edzer Pebesma </p>


<h3>References</h3>

 <p><a href="http://www.gstat.org/">http://www.gstat.org/</a> </p>


<h3>See Also</h3>

 <p><a href="#topic+variogram">variogram</a>, <a href="#topic+vgm">vgm</a>, <a href="#topic+fit.variogram">fit.variogram</a>,
<code>demo(cokriging)</code> </p>

<hr>
<h2 id='fit.StVariogram'>Fit a spatio-temporal sample variogram to a sample variogram</h2><span id='topic+fit.StVariogram'></span>

<h3>Description</h3>

<p>Fits a spatio-temporal variogram of a given type to spatio-temporal sample variogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.StVariogram(object, model, ...,  method = "L-BFGS-B",
	lower, upper, fit.method = 6, stAni=NA, wles)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.StVariogram_+3A_object">object</code></td>
<td>
<p>The spatio-temporal sample variogram. Typically output from <code><a href="#topic+variogramST">variogramST</a></code></p>
</td></tr>
<tr><td><code id="fit.StVariogram_+3A_model">model</code></td>
<td>
<p>The desired spatio-temporal model defined through <code><a href="#topic+vgmST">vgmST</a></code>.</p>
</td></tr>
<tr><td><code id="fit.StVariogram_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="stats.html#topic+optim">optim</a></code>. <code><a href="#topic+extractParNames">extractParNames</a></code> provides the parameter structure of spatio-temporal variogram models that help to provide sensible <code>upper</code> and <code>lower</code> limits.</p>
</td></tr>
<tr><td><code id="fit.StVariogram_+3A_lower">lower</code></td>
<td>
<p>Lower limits used by optim. If missing, the smallest well defined values are used (mostly near 0).</p>
</td></tr>
<tr><td><code id="fit.StVariogram_+3A_upper">upper</code></td>
<td>
<p>Upper limits used by optim. If missing, the largest well defined values are used (mostly <code>Inf</code>).</p>
</td></tr>
<tr><td><code id="fit.StVariogram_+3A_method">method</code></td>
<td>
<p>fit method, pass to <code><a href="stats.html#topic+optim">optim</a></code></p>
</td></tr>
<tr><td><code id="fit.StVariogram_+3A_fit.method">fit.method</code></td>
<td>
<p>an integer between 0 and 13 determine the fitting routine (i.e. weighting of the squared residuals in the LSE). Values 0 to 6 correspond with the pure spatial version (see <code><a href="#topic+fit.variogram">fit.variogram</a></code>). See the details section for the meaning of the other values (partly experimental).</p>
</td></tr>
<tr><td><code id="fit.StVariogram_+3A_stani">stAni</code></td>
<td>
<p>The spatio-temporal anisotropy that is used in the weighting. Might be missing if the desired spatio-temporal variogram model does contain a spatio-temporal anisotropy parameter (this might cause bad convergence behaviour). The default is <code>NA</code> and will be understood as identity (1 temporal unit = 1 spatial unit). As this only in very few cases a valid assumption, a warning is issued.</p>
</td></tr>
<tr><td><code id="fit.StVariogram_+3A_wles">wles</code></td>
<td>
<p>Should be missing; only for backwards compatibility, <code>wles = TRUE</code> corresponds to <code>fit.method = 1</code> and <code>wles = FALSE</code> corresponds to <code>fit.method = 6</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following list summarizes the meaning of the <code>fit.method</code> argument which is essential a weighting of the squared residuals in the least-squares estimation. Please note, that weights based on the models gamma value might fail to converge properly due to the dependence of weights on the variogram estimate:
</p>

<dl>
<dt><code>fit.method = 0</code></dt><dd><p>no fitting, however the MSE between the provided variogram model and sample variogram surface is calculated.</p>
</dd>
<dt><code>fit.method = 1</code></dt><dd><p>Number of pairs in the spatio-temporal bin: <code class="reqn">N_j</code></p>
</dd>
<dt><code>fit.method = 2</code></dt><dd><p>Number of pairs in the spatio-temporal bin divided by the square of the current variogram model's value: <code class="reqn">N_j/\gamma(h_j, u_j)^2</code></p>
</dd>
<dt><code>fit.method = 3</code></dt><dd><p>Same as <code>fit.method = 1</code> for compatibility with <code><a href="#topic+fit.variogram">fit.variogram</a></code> but as well evaluated in R.</p>
</dd>
<dt><code>fit.method = 4</code></dt><dd><p>Same as <code>fit.method = 2</code> for compatibility with <code><a href="#topic+fit.variogram">fit.variogram</a></code> but as well evaluated in R.</p>
</dd>
<dt><code>fit.method = 5</code></dt><dd><p>Reserved for REML for compatibility with <code><a href="#topic+fit.variogram">fit.variogram</a></code>, not yet implemented.</p>
</dd>
<dt><code>fit.method = 6</code></dt><dd><p>No weights.</p>
</dd>
<dt><code>fit.method = 7</code></dt><dd><p>Number of pairs in the spatio-temporal bin divided by the square of the bin's metric distance. If <code>stAni</code> is not specified, the model's  parameter is used to calculate the metric distance across space and time: <code class="reqn">N_j/(h_j^2 + {\rm stAni}^2\cdot u_j^2)</code></p>
</dd>
<dt><code>fit.method = 8</code></dt><dd><p>Number of pairs in the spatio-temporal bin divided by the square of the bin's spatial distance. <code class="reqn">N_j/h_j^2</code>. Note that the 0 distances are replaced by the smallest non-zero distances to avoid division by zero.</p>
</dd>
<dt><code>fit.method = 9</code></dt><dd><p>Number of pairs in the spatio-temporal bin divided by the square of the bin's temporal distance. <code class="reqn">N_j/u_j^2</code>. Note that the 0 distances are replaced by the smallest non-zero distances to avoid division by zero.</p>
</dd>
<dt><code>fit.method = 10</code></dt><dd><p>Reciprocal of the square of the current variogram model's value: <code class="reqn">1/\gamma(h_j,u_j)^2</code></p>
</dd>
<dt><code>fit.method = 11</code></dt><dd><p>Reciprocal of the square of the bin's metric distance. If <code>stAni</code> is not specified, the model's  parameter is used to calculate the metric distance across space and time: <code class="reqn">1/(h_j^2 + {\rm stAni}^2\cdot u_j^2)</code></p>
</dd>
<dt><code>fit.method = 12</code></dt><dd><p>Reciprocal of the square of the bin's spatial distance. <code class="reqn">1/h_j^2</code>. Note that the 0 distances are replaced by the smallest non-zero distances to avoid division by zero.</p>
</dd>
<dt><code>fit.method = 13</code></dt><dd><p>Reciprocal of the square of the bin's temporal distance. <code class="reqn">1/u_j^2</code>. Note that the 0 distances are replaced by the smallest non-zero distances to avoid division by zero.</p>
</dd>
</dl>

<p>See also Table 4.2 in the gstat manual for the original spatial version.
</p>


<h3>Value</h3>

<p>Returns a spatio-temporal variogram model, as S3 class StVariogramModel. It carries the temporal and spatial unit as attributes <code>"temporal unit"</code> and <code>"spatial unit"</code> in order to allow <code><a href="#topic+krigeST">krigeST</a></code> to adjust for different units. The units are obtained from the provided empirical variogram. Further attributes are the optim output <code>"optim.output"</code> and the always not weighted mean squared error <code>"MSE"</code>.
</p>


<h3>Author(s)</h3>

<p>Benedikt Graeler
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit.variogram">fit.variogram</a></code> for the pure spatial case. <code><a href="#topic+extractParNames">extractParNames</a></code> helps to understand the parameter structure of spatio-temporal variogram models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># separable model: spatial and temporal sill will be ignored
# and kept constant at 1-nugget respectively. A joint sill is used.
## Not run: 
separableModel &lt;- vgmST("separable", 
                        method = "Nelder-Mead", # no lower &amp; upper needed
                        space=vgm(0.9,"Exp", 123, 0.1),
                        time =vgm(0.9,"Exp", 2.9, 0.1),
                        sill=100)

data(vv)
separableModel &lt;- fit.StVariogram(vv, separableModel,
                                  method="L-BFGS-B",
                                  lower=c(10,0,0.01,0,1),
                                  upper=c(500,1,20,1,200))
plot(vv, separableModel)

## End(Not run) # dontrun
</code></pre>

<hr>
<h2 id='fit.variogram'> Fit a Variogram Model to a Sample Variogram </h2><span id='topic+fit.variogram'></span>

<h3>Description</h3>

<p>Fit ranges and/or sills from a simple or nested variogram model 
to a sample variogram </p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.variogram(object, model, fit.sills = TRUE, fit.ranges = TRUE,
	fit.method = 7, debug.level = 1, warn.if.neg = FALSE, fit.kappa = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.variogram_+3A_object">object</code></td>
<td>
<p> sample variogram, output of <a href="#topic+variogram">variogram</a> </p>
</td></tr>
<tr><td><code id="fit.variogram_+3A_model">model</code></td>
<td>
<p> variogram model, output of <a href="#topic+vgm">vgm</a>; see Details below
for details on how <code>NA</code> values in <code>model</code> are initialised. </p>
</td></tr>
<tr><td><code id="fit.variogram_+3A_fit.sills">fit.sills</code></td>
<td>
<p> logical; determines whether the partial sill
coefficients (including nugget variance) should be fitted; or logical
vector: determines for each partial sill parameter whether it should be
fitted or fixed.  </p>
</td></tr>
<tr><td><code id="fit.variogram_+3A_fit.ranges">fit.ranges</code></td>
<td>
<p> logical; determines whether the range coefficients
(excluding that of the nugget component) should be fitted; or logical
vector: determines for each range parameter whether it should be fitted
or fixed.  </p>
</td></tr>
<tr><td><code id="fit.variogram_+3A_fit.method">fit.method</code></td>
<td>
<p> fitting method, used by gstat. The default method uses
weights $N_h/h^2$ with $N_h$ the number of point pairs and $h$ the
distance. This criterion is not supported by theory, but by practice. 
For other values of <code>fit.method</code>, see details. </p>
</td></tr>
<tr><td><code id="fit.variogram_+3A_debug.level">debug.level</code></td>
<td>
<p> integer; set gstat internal debug level </p>
</td></tr>
<tr><td><code id="fit.variogram_+3A_warn.if.neg">warn.if.neg</code></td>
<td>
<p> logical; if TRUE a warning is issued whenever
a sill value of a direct variogram becomes negative </p>
</td></tr>
<tr><td><code id="fit.variogram_+3A_fit.kappa">fit.kappa</code></td>
<td>
<p> logical; if <code>TRUE</code>, a sequence of 0.3, 0.4,...,5 will
be searched for optimal fit; alternatively another sequence can be given to
this argument </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If any of the initial parameters of <code>model</code> are <code>NA</code>,
they are given default values as follows. The range parameter
is given one third of the maximum value of <code>object$dist</code>.
The nugget value is given the mean value of the first three values
of <code>object$gamma</code>.  The partial sill is given the mean of the
last five values of <code>object$gamma</code>.
</p>
<p>Values for <code>fit.method</code> are 1: weights equal to
$N_j$; 2: weights equal to $N_j/((gamma(h_j))^2)$; 5 (ignore, use
<a href="#topic+fit.variogram.reml">fit.variogram.reml</a>); 6: unweighted (OLS); 7: $N_j/(h_j^2)$. 
(from: <a href="http://www.gstat.org/gstat.pdf">http://www.gstat.org/gstat.pdf</a>, table 4.2).
</p>


<h3>Value</h3>

<p>returns a fitted variogram model (of class <code>variogramModel</code>).
</p>
<p>This is a <code>data.frame</code> with two attributes: (i) <code>singular</code>
a logical attribute that indicates whether the non-linear fit
converged (FALSE), or ended in a singularity (TRUE), and (ii)
<code>SSErr</code> a numerical attribute with the (weighted) sum of
squared errors of the fitted model. See Notes below.
</p>


<h3>Note</h3>

<p> If fitting the range(s) is part of the job of this function,
the results may well depend on the starting values, given in
argument <code>model</code>, which is generally the case for non-linear
regression problems. This function uses internal C code, which
uses Levenberg-Marquardt.
</p>
<p>If for a direct (i.e. not a cross) variogram a sill parameter
(partial sill or nugget) becomes negative, fit.variogram is called
again with this parameter set to zero, and with a FALSE flag to
further fit this sill. This implies that the search does not move
away from search space boundaries.
</p>
<p>On singular model fits: If your variogram turns out to be a flat,
horizontal or sloping line, then fitting a three parameter model such
as the exponential or spherical with nugget is a bit heavy: there's an
infinite number of possible combinations of sill and range (both very
large) to fit to a sloping line. In this case, the returned, singular
model may still be useful: just try and plot it. Gstat converges when
the parameter values stabilize, and this may not be the case. Another
case of singular model fits happens when a model that reaches the sill
(such as the spherical) is fit with a nugget, and the range parameter
starts, or converges to a value smaller than the distance of the second
sample variogram estimate. In this case, again, an infinite number of
possibilities occur essentially for fitting a line through a single
(first sample variogram) point. In both cases, fixing one or more of
the variogram model parameters may help you out.
</p>
<p>The function will accept anisotropic sample variograms as input. It will
fit a model for a given direction interval if the sample variogram 
only includes this direction. It is not possible to fit 
a multiple direction model to each direction of the sample variogram, 
in this case the model will be fitted to an average of all directions.
</p>


<h3>Author(s)</h3>

<p> Edzer Pebesma </p>


<h3>References</h3>

 <p><a href="http://www.gstat.org/">http://www.gstat.org/</a> 
</p>
<p>Pebesma, E.J., 2004. Multivariable geostatistics in S: the gstat package.
Computers and Geosciences, 30: 683-691.
</p>


<h3>See Also</h3>

<p><a href="#topic+variogram">variogram</a>,
<a href="#topic+vgm">vgm</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sp)
data(meuse)
coordinates(meuse) = ~x+y
vgm1 &lt;- variogram(log(zinc)~1, meuse)
fit.variogram(vgm1, vgm(1, "Sph", 300, 1))
fit.variogram(vgm1, vgm("Sph"))

# optimize the value of kappa in a Matern model, using ugly &lt;&lt;- side effect:
f = function(x) attr(m.fit &lt;&lt;- fit.variogram(vgm1, vgm(,"Mat",nugget=NA,kappa=x)),"SSErr")
optimize(f, c(0.1, 5))
plot(vgm1, m.fit)
# best fit from the (0.3, 0.4, 0.5. ... , 5) sequence:
(m &lt;- fit.variogram(vgm1, vgm("Mat"), fit.kappa = TRUE))
attr(m, "SSErr")
</code></pre>

<hr>
<h2 id='fit.variogram.gls'> GLS fitting of variogram parameters </h2><span id='topic+fit.variogram.gls'></span>

<h3>Description</h3>

<p>Fits variogram parameters (nugget, sill, range) to variogram cloud,
using GLS (generalized least squares) fitting. Only for direct variograms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.variogram.gls(formula, data, model, maxiter = 30, 
		eps = .01, trace = TRUE, ignoreInitial = TRUE, cutoff = Inf,
		plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.variogram.gls_+3A_formula">formula</code></td>
<td>
<p>formula defining the response vector and (possible) 
regressors; in case of absence of regressors, use e.g. <code>z~1</code></p>
</td></tr>
<tr><td><code id="fit.variogram.gls_+3A_data">data</code></td>
<td>
<p>object of class Spatial</p>
</td></tr>
<tr><td><code id="fit.variogram.gls_+3A_model">model</code></td>
<td>
<p>variogram model to be fitted, output of <code>vgm</code></p>
</td></tr>
<tr><td><code id="fit.variogram.gls_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations</p>
</td></tr>
<tr><td><code id="fit.variogram.gls_+3A_eps">eps</code></td>
<td>
<p> convergence criterium </p>
</td></tr>
<tr><td><code id="fit.variogram.gls_+3A_trace">trace</code></td>
<td>
<p> logical; if TRUE, prints parameter trace</p>
</td></tr>
<tr><td><code id="fit.variogram.gls_+3A_ignoreinitial">ignoreInitial</code></td>
<td>
<p> logical; 
if FALSE, initial parameter are taken from model; 
if TRUE, initial values of model are
ignored and taken from variogram cloud: 
nugget: <code>mean(y)/2</code>, sill: <code>mean(y)/2</code>, range <code>median(h0)/4</code>
with <code>y</code> the semivariance cloud value and <code>h0</code> the distances </p>
</td></tr>
<tr><td><code id="fit.variogram.gls_+3A_cutoff">cutoff</code></td>
<td>
<p>maximum distance up to which point pairs are taken into
consideration</p>
</td></tr>
<tr><td><code id="fit.variogram.gls_+3A_plot">plot</code></td>
<td>
<p>logical; if TRUE, a plot is returned with variogram cloud and
fitted model; else, the fitted model is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p> an object of class &quot;variogramModel&quot;; see <a href="#topic+fit.variogram">fit.variogram</a>; if
<code>plot</code> is TRUE, a plot is returned instead. </p>


<h3>Note</h3>

<p>Inspired by the code of Mihael Drinovac, which was again inspired by
code from Ernst Glatzer, author of package vardiag.
</p>


<h3>Author(s)</h3>

<p> Edzer Pebesma </p>


<h3>References</h3>

 
<p>Mueller, W.G., 1999: Least-squares fitting from the variogram
cloud. Statistics and Probability Letters, 43, 93-98.
</p>
<p>Mueller, W.G., 2007: Collecting Spatial Data. Springer, Heidelberg.
</p>


<h3>See Also</h3>

<p><a href="#topic+fit.variogram">fit.variogram</a>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sp)
data(meuse)
coordinates(meuse) = ~x+y
## Not run: 
fit.variogram.gls(log(zinc)~1, meuse[1:40,], vgm(1, "Sph", 900,1))

## End(Not run)
</code></pre>

<hr>
<h2 id='fit.variogram.reml'> REML Fit Direct Variogram Partial Sills to Data </h2><span id='topic+fit.variogram.reml'></span>

<h3>Description</h3>

<p>Fit Variogram Sills to Data, using REML (only for direct variograms;
not for cross variograms)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.variogram.reml(formula, locations, data, model, debug.level = 1, set, degree = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.variogram.reml_+3A_formula">formula</code></td>
<td>
<p>formula defining the response vector and (possible) 
regressors; in case of absence of regressors, use e.g. <code>z~1</code></p>
</td></tr>
<tr><td><code id="fit.variogram.reml_+3A_locations">locations</code></td>
<td>
<p> spatial data locations; a formula with the
coordinate variables in the right hand (dependent variable) side. </p>
</td></tr>
<tr><td><code id="fit.variogram.reml_+3A_data">data</code></td>
<td>
<p>data frame where the names in formula and locations 
are to be found</p>
</td></tr>
<tr><td><code id="fit.variogram.reml_+3A_model">model</code></td>
<td>
<p>variogram model to be fitted, output of <code>vgm</code></p>
</td></tr>
<tr><td><code id="fit.variogram.reml_+3A_debug.level">debug.level</code></td>
<td>
<p>debug level; set to 65 to see the iteration trace and
log likelihood</p>
</td></tr>
<tr><td><code id="fit.variogram.reml_+3A_set">set</code></td>
<td>
<p>additional options that can be set; use <code>set=list(iter=100)</code>
to set the max. number of iterations to 100.  </p>
</td></tr>
<tr><td><code id="fit.variogram.reml_+3A_degree">degree</code></td>
<td>
<p>order of trend surface in the location, between 0 and 3</p>
</td></tr>
</table>


<h3>Value</h3>

<p> an object of class &quot;variogramModel&quot;; see <a href="#topic+fit.variogram">fit.variogram</a> </p>


<h3>Note</h3>

<p>This implementation only uses REML fitting of sill parameters. For each
iteration, an <code class="reqn">n \times n</code> matrix is inverted, with $n$ the number of
observations, so for large data sets this method becomes 
demanding. I guess there is much more to likelihood variogram fitting in 
package <code>geoR</code>, and probably also in <code>nlme</code>.
</p>


<h3>Author(s)</h3>

<p> Edzer Pebesma </p>


<h3>References</h3>

 
<p>Christensen, R. Linear models for multivariate, Time Series,
and Spatial Data, Springer, NY, 1991. 
</p>
<p>Kitanidis, P., Minimum-Variance Quadratic Estimation of Covariances of
Regionalized Variables, Mathematical Geology 17 (2), 195&ndash;208, 1985 </p>


<h3>See Also</h3>

<p><a href="#topic+fit.variogram">fit.variogram</a>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sp)
data(meuse)
fit.variogram.reml(log(zinc)~1, ~x+y, meuse, model = vgm(1, "Sph", 900,1))
</code></pre>

<hr>
<h2 id='fulmar'>Fulmaris glacialis data</h2><span id='topic+fulmar'></span>

<h3>Description</h3>

<p> Airborne counts of Fulmaris glacialis during the
Aug/Sept 1998 and 1999 flights on the Dutch (Netherlands) part of
the North Sea (NCP, Nederlands Continentaal Plat). </p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fulmar)
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>year</dt><dd><p>year of measurement: 1998 or 1999</p>
</dd>
<dt>x</dt><dd><p>x-coordinate in UTM zone 31</p>
</dd> 
<dt>y</dt><dd><p>y-coordinate in UTM zone 31</p>
</dd>
<dt>depth</dt><dd><p>sea water depth, in m</p>
</dd>
<dt>coast</dt><dd><p>distance to coast of the Netherlands, in km.</p>
</dd>
<dt>fulmar</dt><dd><p>observed density (number of birds per square km)</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Dutch National Institute for Coastal and Marine Management (RIKZ) </p>


<h3>See Also</h3>

<p><a href="#topic+ncp.grid">ncp.grid</a>
</p>
<p>E.J. Pebesma, R.N.M. Duin, P.A. Burrough, 2005. Mapping Sea Bird
Densities over the North Sea: Spatially Aggregated Estimates and Temporal
Changes. Environmetrics 16, (6), p 573-587.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fulmar)
summary(fulmar)
## Not run: 
demo(fulmar)

## End(Not run)
</code></pre>

<hr>
<h2 id='get.contr'> Calculate contrasts from multivariable predictions </h2><span id='topic+get.contr'></span>

<h3>Description</h3>

<p> Given multivariable predictions and prediction (co)variances,
calculate contrasts and their (co)variance </p>


<h3>Usage</h3>

<pre><code class='language-R'> get.contr(data, gstat.object, X, ids = names(gstat.object$data)) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.contr_+3A_data">data</code></td>
<td>
<p>data frame, output of <a href="#topic+predict">predict</a> </p>
</td></tr>
<tr><td><code id="get.contr_+3A_gstat.object">gstat.object</code></td>
<td>
<p>object of class <code>gstat</code>, used to
extract ids; may be missing if <code>ids</code> is used </p>
</td></tr>
<tr><td><code id="get.contr_+3A_x">X</code></td>
<td>
<p> contrast vector or matrix; the number of variables in
<code>gstat.object</code> should equal the number of elements in <code>X</code>
if <code>X</code> is a vector, or the number of rows in <code>X</code> if <code>X</code>
is a matrix. </p>
</td></tr>
<tr><td><code id="get.contr_+3A_ids">ids</code></td>
<td>
<p> character vector with (selection of) id names, present in data </p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>From data, we can extract the <code class="reqn">n \times 1</code> vector with multivariable
predictions, say $y$, and its <code class="reqn">n \times n</code> covariance matrix $V$. Given
a contrast matrix in $X$, this function computes the contrast vector 
$C=X'y$ and its variance $Var(C)=X'V X$.
</p>


<h3>Value</h3>

<p>a data frame containing for each row in <code>data</code> the generalized
least squares estimates (named beta.1, beta.2, ...), their
variances (named var.beta.1, var.beta.2, ...) and covariances
(named cov.beta.1.2, cov.beta.1.3, ...)
</p>


<h3>Author(s)</h3>

<p> Edzer Pebesma </p>


<h3>References</h3>

 
<p><a href="http://www.gstat.org/">http://www.gstat.org/</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+predict">predict</a></p>

<hr>
<h2 id='gstat'> Create gstat objects, or subset it </h2><span id='topic+gstat'></span><span id='topic+print.gstat'></span><span id='topic++5B.gstat'></span>

<h3>Description</h3>

<p>Function that creates gstat objects; objects that hold all the information
necessary for univariate or multivariate geostatistical prediction
(simple, ordinary or universal (co)kriging), or its conditional or
unconditional Gaussian or indicator simulation equivalents. Multivariate
gstat object can be subsetted. </p>


<h3>Usage</h3>

<pre><code class='language-R'>gstat(g, id, formula, locations, data, model = NULL, beta,
	nmax = Inf, nmin = 0, omax = 0, maxdist = Inf, force = FALSE,
	dummy = FALSE, set, fill.all = FALSE,
	fill.cross = TRUE, variance = "identity", weights = NULL, merge, 
	degree = 0, vdist = FALSE, lambda = 1.0)
## S3 method for class 'gstat'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gstat_+3A_g">g</code></td>
<td>
<p> gstat object to append to; if missing, a new gstat object
is created </p>
</td></tr>
<tr><td><code id="gstat_+3A_id">id</code></td>
<td>
<p> identifier of new variable; if missing, <code>varn</code> is used with
<code>n</code> the number for this variable. If a cross variogram is entered,
<code>id</code> should be a vector with the two <code>id</code> values , e.g. 
<code>c("zn", "cd")</code>, further only supplying arguments <code>g</code> 
and <code>model</code>. It is advisable not to use expressions, such
as <code>log(zinc)</code>, as identifiers, as this may lead to complications 
later on. </p>
</td></tr>
<tr><td><code id="gstat_+3A_formula">formula</code></td>
<td>
<p> formula that defines the dependent variable as a linear
model of independent variables; suppose the dependent variable has name
<code>z</code>, for ordinary and simple kriging use the formula <code>z~1</code>;
for simple kriging also define <code>beta</code> (see below); for universal
kriging, suppose <code>z</code> is linearly dependent on <code>x</code> and <code>y</code>,
use the formula <code>z~x+y</code></p>
</td></tr>
<tr><td><code id="gstat_+3A_locations">locations</code></td>
<td>
<p> formula with only independent variables that define the
spatial data locations (coordinates), e.g. <code>~x+y</code>; if <code>data</code>
has a <code>coordinates</code> method to extract its coordinates this argument 
can be ignored (see package sp for classes for point or grid data). </p>
</td></tr>
<tr><td><code id="gstat_+3A_data">data</code></td>
<td>
<p> data frame; contains the dependent variable, independent
variables, and locations. </p>
</td></tr>
<tr><td><code id="gstat_+3A_model">model</code></td>
<td>
<p> variogram model for this <code>id</code>; defined by a call to 
<a href="#topic+vgm">vgm</a>; see argument <code>id</code> to see how cross variograms are entered </p>
</td></tr>
<tr><td><code id="gstat_+3A_beta">beta</code></td>
<td>
<p> for simple kriging (and simulation based on simple
kriging): vector with the trend coefficients (including intercept);
if no independent variables are defined the model only contains an
intercept and this should be the expected value; for cross 
variogram computations: mean parameters to be used instead of the 
OLS estimates </p>
</td></tr>
<tr><td><code id="gstat_+3A_nmax">nmax</code></td>
<td>
<p> for local kriging: the number of nearest observations that
should be used for a kriging prediction or simulation, where nearest
is defined in terms of the space of the spatial locations </p>
</td></tr>
<tr><td><code id="gstat_+3A_nmin">nmin</code></td>
<td>
<p> for local kriging: if the number of nearest observations
within distance <code>maxdist</code> is less than <code>nmin</code>, a missing 
value will be generated, unless <code>force==TRUE</code>; see <code>maxdist</code> </p>
</td></tr>
<tr><td><code id="gstat_+3A_omax">omax</code></td>
<td>
<p> maximum number of observations to select per octant (3D) or
quadrant (2D); only relevant if <code>maxdist</code> has been defined as well </p>
</td></tr>
<tr><td><code id="gstat_+3A_maxdist">maxdist</code></td>
<td>
<p> for local kriging: only observations within a distance
of <code>maxdist</code> from the prediction location are used for prediction
or simulation; if combined with <code>nmax</code>, both criteria apply </p>
</td></tr>
<tr><td><code id="gstat_+3A_force">force</code></td>
<td>
<p> for local kriging, force neighbourhood selection: in case
<code>nmin</code> is given, search beyond <code>maxdist</code> until <code>nmin</code>
neighbours are found. A missing value is returned if this is not possible. </p>
</td></tr>
<tr><td><code id="gstat_+3A_dummy">dummy</code></td>
<td>
<p> logical; if TRUE, consider this data as a dummy variable
(only necessary for unconditional simulation) </p>
</td></tr>
<tr><td><code id="gstat_+3A_set">set</code></td>
<td>
<p> named list with optional parameters to be passed to
gstat (only <code>set</code> commands of gstat are allowed, and not all of
them may be relevant; see the manual for gstat stand-alone, URL below ) </p>
</td></tr>
<tr><td><code id="gstat_+3A_x">x</code></td>
<td>
<p> gstat object to print </p>
</td></tr>
<tr><td><code id="gstat_+3A_fill.all">fill.all</code></td>
<td>
<p> logical; if TRUE, fill all of the direct variogram and,
depending on the value of <code>fill.cross</code> also all cross
variogram model slots in <code>g</code> with the given variogram model </p>
</td></tr>
<tr><td><code id="gstat_+3A_fill.cross">fill.cross</code></td>
<td>
<p> logical; if TRUE, fill all of the cross variograms, if
FALSE fill only all direct variogram model slots in <code>g</code> with the 
given variogram model (only if <code>fill.all</code> is used)</p>
</td></tr>
<tr><td><code id="gstat_+3A_variance">variance</code></td>
<td>
<p> character; variance function to transform to non-stationary
covariances; &quot;identity&quot; does not transform, other options are &quot;mu&quot; (Poisson)
and &quot;mu(1-mu)&quot; (binomial) </p>
</td></tr>
<tr><td><code id="gstat_+3A_weights">weights</code></td>
<td>
<p> numeric vector; if present, covariates are present,
and variograms are missing weights are passed to OLS prediction routines
resulting in WLS; if variograms are given, weights should be 1/variance, 
where variance specifies location-specific measurement error; see references 
section below </p>
</td></tr>
<tr><td><code id="gstat_+3A_merge">merge</code></td>
<td>
<p> either character vector of length 2, indicating two ids 
that share a common mean; the more general gstat merging of any two
coefficients across variables is obtained when a list is passed, with
each element a character vector of length 4, in the form 
<code>c("id1", 1,"id2", 2)</code>. This merges the first parameter 
for variable <code>id1</code> to the second of variable <code>id2</code>.</p>
</td></tr>
<tr><td><code id="gstat_+3A_degree">degree</code></td>
<td>
<p>order of trend surface in the location, between 0 and 3</p>
</td></tr>
<tr><td><code id="gstat_+3A_vdist">vdist</code></td>
<td>
<p>logical; if TRUE, instead of Euclidian distance 
variogram distance is used for selecting the nmax nearest neighbours,
after observations within distance maxdist (Euclidian/geographic) have been 
pre-selected </p>
</td></tr>
<tr><td><code id="gstat_+3A_lambda">lambda</code></td>
<td>
<p>test feature; doesn't do anything (yet)</p>
</td></tr>
<tr><td><code id="gstat_+3A_...">...</code></td>
<td>
<p> arguments that are passed to the printing of variogram
models only</p>
</td></tr>
</table>


<h3>Details</h3>

<p> to print the full contents of the object <code>g</code> returned,
use <code>as.list(g)</code> or <code>print.default(g)</code> </p>


<h3>Value</h3>

<p>an object of class <code>gstat</code>, which inherits from <code>list</code>.
Its components are: 
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p>list; each element is a list with the <code>formula</code>, 
<code>locations</code>, <code>data</code>, <code>nvars</code>, <code>beta</code>, etc., for a 
variable</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>list; each element contains a variogram model; names are
those of the elements of <code>data</code>; cross variograms have names of
the pairs of data elements, separated by a <code>.</code> (e.g.: 
<code>var1.var2</code></p>
</td></tr></table>
<p>)
</p>
<table>
<tr><td><code>set</code></td>
<td>
<p>list; named list, corresponding to set <code>name</code>=<code>value</code>;
gstat commands (look up the set command in the gstat manual for a full list)</p>
</td></tr>
</table>


<h3>Note</h3>

 
<p>The function currently copies the data objects into the gstat object, so
this may become a large object. I would like to copy only the name of the
data frame, but could not get this to work. Any help is appreciated.  
</p>
<p>Subsetting (see examples) is done using the <code>id</code>'s of the variables,
or using numeric subsets. Subsetted gstat objects only contain cross
variograms if (i) the original gstat object contained them and (ii) the
order of the subset indexes increases, numerically, or given the order
they have in the gstat object.
</p>
<p>The merge item may seem obscure. Still, for colocated cokriging, it is
needed. See texts by Goovaerts, Wackernagel, Chiles and Delfiner, or
look for standardised ordinary kriging in the 1992 Deutsch and Journel
or Isaaks and Srivastava. In these cases, two variables share a common
mean parameter. Gstat generalises this case: any two variables may share
any of the regression coefficients; allowing for instance analysis of
covariance models, when variograms were left out (see e.g. R. Christensen's
&ldquo;Plane answers&rdquo; book on linear models). The tests directory of the
package contains examples in file merge.R. There is also <code>demo(pcb)</code>
which merges slopes across years, but with year-dependent intercept.
</p>


<h3>Author(s)</h3>

<p> Edzer Pebesma </p>


<h3>References</h3>

 <p><a href="http://www.gstat.org/">http://www.gstat.org/</a> 
Pebesma, E.J., 2004. Multivariable geostatistics in S: the gstat package.
Computers and Geosciences, 30: 683-691.
</p>
<p>for kriging with known, varying measurement errors (<code>weights</code>), see e.g.
Delhomme, J.P.  Kriging in the hydrosciences.  Advances in Water
Resources, 1(5):251-266, 1978; see also the section Kriging with known
measurement errors in the gstat user's manual, <a href="http://www.gstat.org/">http://www.gstat.org/</a>
</p>


<h3>See Also</h3>

 <p><a href="#topic+predict">predict</a>, <a href="#topic+krige">krige</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sp)
data(meuse)
coordinates(meuse) = ~x+y
# let's do some manual fitting of two direct variograms and a cross variogram
g &lt;- gstat(id = "ln.zinc", formula = log(zinc)~1, data = meuse)
g &lt;- gstat(g, id = "ln.lead", formula = log(lead)~1, data = meuse)
# examine variograms and cross variogram:
plot(variogram(g))
# enter direct variograms:
g &lt;- gstat(g, id = "ln.zinc", model = vgm(.55, "Sph", 900, .05))
g &lt;- gstat(g, id = "ln.lead", model = vgm(.55, "Sph", 900, .05))
# enter cross variogram:
g &lt;- gstat(g, id = c("ln.zinc", "ln.lead"), model = vgm(.47, "Sph", 900, .03))
# examine fit:
plot(variogram(g), model = g$model, main = "models fitted by eye")
# see also demo(cokriging) for a more efficient approach
g["ln.zinc"]
g["ln.lead"]
g[c("ln.zinc", "ln.lead")]
g[1]
g[2]

# Inverse distance interpolation with inverse distance power set to .5:
# (kriging variants need a variogram model to be specified)
data(meuse.grid)
gridded(meuse.grid) = ~x+y
meuse.gstat &lt;- gstat(id = "zinc", formula = zinc ~ 1, data = meuse, 
	nmax = 7, set = list(idp = .5))
meuse.gstat
z &lt;- predict(meuse.gstat, meuse.grid)
spplot(z["zinc.pred"])
# see demo(cokriging) and demo(examples) for further examples, 
# and the manuals for predict and image

# local universal kriging
gmeuse &lt;- gstat(id = "log_zinc", formula = log(zinc)~sqrt(dist), data = meuse)
# variogram of residuals
vmeuse.res &lt;- fit.variogram(variogram(gmeuse), vgm(1, "Exp", 300, 1))
# prediction from local neighbourhoods within radius of 170 m or at least 10 points
gmeuse &lt;- gstat(id = "log_zinc", formula = log(zinc)~sqrt(dist),
	data = meuse, maxdist=170, nmin=10, force=TRUE, model=vmeuse.res)
predmeuse &lt;- predict(gmeuse, meuse.grid)
spplot(predmeuse)

</code></pre>

<hr>
<h2 id='gstat-internal'>Gstat Internal Functions</h2><span id='topic+load.variogram.model'></span><span id='topic+gstat.formula'></span><span id='topic+gstat.formula.predict'></span><span id='topic+gstat.debug'></span><span id='topic+gstat.set'></span><span id='topic+cross.name'></span><span id='topic+gstat.load.set'></span>

<h3>Description</h3>

<p>gstat internal functions</p>


<h3>Note</h3>

<p>these functions are not meant to be called by users directly</p>


<h3>Author(s)</h3>

<p>Edzer Pebesma</p>

<hr>
<h2 id='hscat'>
Produce h-scatterplot
</h2><span id='topic+hscat'></span>

<h3>Description</h3>

<p>Produces h-scatterplots, where point pairs having specific separation distances
are plotted. This function is a wrapper around xyplot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hscat(formula, data, breaks, pch = 3, cex = .6, mirror = FALSE, 
	variogram.alpha = 0, as.table = TRUE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hscat_+3A_formula">formula</code></td>
<td>
<p> specifies the dependent variable </p>
</td></tr>
<tr><td><code id="hscat_+3A_data">data</code></td>
<td>
<p> data where the variable in formula is resolved </p>
</td></tr>
<tr><td><code id="hscat_+3A_breaks">breaks</code></td>
<td>
<p> distance class boundaries </p>
</td></tr>
<tr><td><code id="hscat_+3A_pch">pch</code></td>
<td>
<p> plotting symbol </p>
</td></tr>
<tr><td><code id="hscat_+3A_cex">cex</code></td>
<td>
<p> plotting symbol size </p>
</td></tr>
<tr><td><code id="hscat_+3A_mirror">mirror</code></td>
<td>
<p> logical; duplicate all points mirrored along x=y?
(note that correlations are those of the points plotted) </p>
</td></tr>
<tr><td><code id="hscat_+3A_variogram.alpha">variogram.alpha</code></td>
<td>
<p> parameter to be passed as alpha parameter to
<a href="#topic+variogram">variogram</a>; if alpha is specified it will only affect xyplot by
being passed through ...</p>
</td></tr>
<tr><td><code id="hscat_+3A_as.table">as.table</code></td>
<td>
<p>logical; if <code>TRUE</code>, panels plot top-to-bottom </p>
</td></tr>
<tr><td><code id="hscat_+3A_...">...</code></td>
<td>
<p> parameters, passed to variogram and xyplot </p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class trellis; normally the h scatter plot
</p>


<h3>Note</h3>

<p>Data pairs are plotted once, so the h-scatterplot are not symmetric.
</p>


<h3>Author(s)</h3>

<p> Edzer Pebesma </p>


<h3>References</h3>

 <p><a href="http://www.gstat.org/">http://www.gstat.org/</a>
</p>
<p>Pebesma, E.J., 2004. Multivariable geostatistics in S: the gstat package.
Computers and Geosciences, 30: 683-691.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sp)
data(meuse)
coordinates(meuse) = ~x+y
hscat(log(zinc)~1, meuse, c(0, 80, 120, 250, 500, 1000))
</code></pre>

<hr>
<h2 id='image'>
Image Gridded Coordinates in Data Frame
</h2><span id='topic+image.data.frame'></span><span id='topic+image'></span><span id='topic+xyz2img'></span>

<h3>Description</h3>

<p>Image gridded data, held in a data frame, keeping the
right aspect ratio for axes, and the right cell shape
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
image(x, zcol = 3, xcol = 1, ycol = 2, asp = 1, ...)
xyz2img(xyz, zcol = 3, xcol = 1, ycol = 2, tolerance = 10 * .Machine$double.eps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image_+3A_x">x</code></td>
<td>
<p> data frame (or matrix) with x-coordinate,
y-coordinate, and z-coordinate in its columns </p>
</td></tr>
<tr><td><code id="image_+3A_zcol">zcol</code></td>
<td>
<p> column number or name of z-variable </p>
</td></tr>
<tr><td><code id="image_+3A_xcol">xcol</code></td>
<td>
<p> column number or name of x-coordinate </p>
</td></tr>
<tr><td><code id="image_+3A_ycol">ycol</code></td>
<td>
<p> column number or name of y-coordinate </p>
</td></tr>
<tr><td><code id="image_+3A_asp">asp</code></td>
<td>
<p> aspect ratio for the x and y axes </p>
</td></tr>
<tr><td><code id="image_+3A_...">...</code></td>
<td>
<p> arguments, passed to image.default </p>
</td></tr>
<tr><td><code id="image_+3A_xyz">xyz</code></td>
<td>
<p>data frame (same as <code>x</code>)</p>
</td></tr>
<tr><td><code id="image_+3A_tolerance">tolerance</code></td>
<td>
<p> maximum allowed deviation for coordinats from being
exactly on a regularly spaced grid </p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+image.data.frame">image.data.frame</a> plots an image from gridded data, organized
in arbritrary order, in a data frame. It uses <a href="#topic+xyz2img">xyz2img</a> and
<a href="graphics.html#topic+image.default">image.default</a> for this. In the S-Plus version, <a href="#topic+xyz2img">xyz2img</a>
tries to make an image object with a size such that it will plot with
an equal aspect ratio; for the R version, image.data.frame uses the
<code>asp=1</code> argument to guarantee this.
</p>
<p><a href="#topic+xyz2img">xyz2img</a> returns a list with components: <code>z</code>, a matrix
containing the z-values; <code>x</code>, the increasing coordinates of the
rows of <code>z</code>; <code>y</code>, the increasing coordinates of the columns
of <code>z</code>. This list is suitable input to <a href="graphics.html#topic+image.default">image.default</a>.
</p>


<h3>Note</h3>

<p>I wrote this function before I found out about <code>levelplot</code>,
a Lattice/Trellis function that lets you control the aspect ratio by
the <code>aspect</code> argument, and that automatically draws a legend, and
therefore I now prefer levelplot over <code>image</code>. Plotting points
on a levelplots is probably done with providing a panel function and
using <code>lpoints</code>.
</p>
<p>(for S-Plus only &ndash; ) it is hard (if not impossible) to get exactly right
cell shapes (e.g., square for a square grid) without altering the size of
the plotting region, but this function tries hard to do so by extending
the image to plot in either x- or y-direction.  The larger the grid, the
better the approximation. Geographically correct images can be obtained
by modifiying <code>par("pin")</code>. Read the examples, image a 2 x 2 grid,
and play with <code>par("pin")</code> if you want to learn more about this.
</p>


<h3>Author(s)</h3>

<p> Edzer Pebesma </p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sp)
data(meuse)
data(meuse.grid)
g &lt;- gstat(formula=log(zinc)~1,locations=~x+y,data=meuse,model=vgm(1,"Exp",300))
x &lt;- predict(g, meuse.grid)
image(x, 4, main="kriging variance and data points")
points(meuse$x, meuse$y, pch = "+")
</code></pre>

<hr>
<h2 id='jura'>Jura data set</h2><span id='topic+jura'></span><span id='topic+prediction.dat'></span><span id='topic+validation.dat'></span><span id='topic+transect.dat'></span><span id='topic+juragrid.dat'></span><span id='topic+jura.grid'></span><span id='topic+jura.pred'></span><span id='topic+jura.val'></span>

<h3>Description</h3>

<p>The jura data set from Pierre Goovaerts' book (see references
below). It contains four <code>data.frame</code>s: prediction.dat, validation.dat
and transect.dat and juragrid.dat, and three <code>data.frame</code>s with
consistently coded land use and rock type factors, as well as geographic
coordinates. The examples below show how to transform these into
spatial (sp) objects in a local coordinate system and in geographic
coordinates, and how to transform to metric coordinate reference
systems.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(jura)
</code></pre>


<h3>Format</h3>

<p>The <code>data.frames</code> prediction.dat and validation.dat contain the following fields:
</p>

<dl>
<dt>Xloc</dt><dd><p> X coordinate, local grid km </p>
</dd>
<dt>Yloc</dt><dd><p> Y coordinate, local grid km </p>
</dd>
<dt>Landuse</dt><dd><p> see book and below </p>
</dd>
<dt>Rock</dt><dd><p> see book and below </p>
</dd>
<dt>Cd</dt><dd><p> mg cadmium kg^-1 topsoil </p>
</dd>
<dt>Co</dt><dd><p> mg cobalt kg^-1 topsoil </p>
</dd>
<dt>Cr</dt><dd><p> mg chromium kg^-1 topsoil </p>
</dd>
<dt>Cu</dt><dd><p> mg copper kg^-1 topsoil </p>
</dd>
<dt>Ni</dt><dd><p> mg nickel kg^-1 topsoil </p>
</dd>
<dt>Pb</dt><dd><p> mg lead kg^-1 topsoil </p>
</dd>
<dt>Zn</dt><dd><p> mg zinc kg^-1 topsoil </p>
</dd>
</dl>

<p>The <code>data.frame</code> juragrid.dat only has the first four fields.
In addition the <code>data.frame</code>s jura.pred, jura.val and jura.grid also
have inserted third and fourth fields giving geographic coordinates:
</p>

<dl>
<dt>long</dt><dd><p> Longitude, WGS84 datum </p>
</dd>
<dt>lat</dt><dd><p> Latitude, WGS84 datum </p>
</dd>
</dl>
 


<h3>Note</h3>

<p>The points data sets were obtained from
http://home.comcast.net/~pgoovaerts/book.html, which seems to be
no longer available; the grid data were kindly provided by Pierre
Goovaerts.
</p>
<p>The following codes were used to convert <code>prediction.dat</code>
and <code>validation.dat</code> to <code>jura.pred</code> and <code>jura.val</code>
(see examples below):
</p>
<p>Rock Types: 1: Argovian, 2: Kimmeridgian, 3: Sequanian, 4: Portlandian,
5: Quaternary.
</p>
<p>Land uses: 1: Forest, 2: Pasture (Weide(land), Wiese, Grasland),
3: Meadow (Wiese, Flur, Matte, Anger), 4: Tillage (Ackerland,
bestelltes Land)
</p>
<p>Points 22 and 100 in the validation set
(<code>validation.dat[c(22,100),]</code>) seem not to lie exactly on the
grid originally intended, but are kept as such to be consistent with
the book.
</p>
<p>Georeferencing was based on two control points in the Swiss grid system
shown as Figure 1 of Atteia et al. (see above) and further points digitized
on the tentatively georeferenced scanned map. RMSE 2.4 m. Location of points
in the field was less precise.
</p>


<h3>Author(s)</h3>

<p> Data preparation by David Rossiter (dgr2@cornell.edu) 
and Edzer Pebesma; georeferencing by David Rossiter </p>


<h3>References</h3>

 
<p>Goovaerts, P. 1997. Geostatistics for Natural Resources Evaluation. Oxford
Univ. Press, New-York, 483 p. Appendix C describes (and gives) the Jura
data set.
</p>
<p>Atteia, O., Dubois, J.-P., Webster, R., 1994, Geostatistical analysis of
soil contamination in the Swiss Jura: Environmental Pollution 86, 315-327
</p>
<p>Webster, R., Atteia, O., Dubois, J.-P., 1994, Coregionalization of trace
metals in the soil in the Swiss Jura: European Journal of Soil Science
45, 205-218
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(jura)
summary(prediction.dat)
summary(validation.dat)
summary(transect.dat)
summary(juragrid.dat)

# the following commands were used to create objects with factors instead
# of the integer codes for Landuse and Rock:
## Not run: 
  jura.pred = prediction.dat
  jura.val = validation.dat
  jura.grid = juragrid.dat

  jura.pred$Landuse = factor(prediction.dat$Landuse, 
	labels=levels(juragrid.dat$Landuse))
  jura.pred$Rock = factor(prediction.dat$Rock, 
	labels=levels(juragrid.dat$Rock))
  jura.val$Landuse = factor(validation.dat$Landuse, 
	labels=levels(juragrid.dat$Landuse))
  jura.val$Rock = factor(validation.dat$Rock, 
	labels=levels(juragrid.dat$Rock))

## End(Not run)

# the following commands convert data.frame objects into spatial (sp) objects
#   in the local grid:
require(sp)
coordinates(jura.pred) = ~Xloc+Yloc
coordinates(jura.val) = ~Xloc+Yloc
coordinates(jura.grid) = ~Xloc+Yloc
gridded(jura.grid) = TRUE

# the following commands convert the data.frame objects into spatial (sp) objects
#   in WGS84 geographic coordinates
# example is given only for jura.pred, do the same for jura.val and jura.grid
# EPSG codes can be found by searching make_EPSG()
jura.pred &lt;- as.data.frame(jura.pred)
coordinates(jura.pred) = ~ long + lat
proj4string(jura.pred) = CRS("+init=epsg:4326")
</code></pre>

<hr>
<h2 id='krige'> Simple, Ordinary or Universal, global or local, Point or Block Kriging,
or simulation. </h2><span id='topic+krige'></span><span id='topic+krige0'></span><span id='topic+krige.locations'></span><span id='topic+krige.spatial'></span><span id='topic+idw'></span><span id='topic+idw0'></span><span id='topic+idw.locations'></span><span id='topic+idw.spatial'></span><span id='topic+krige-methods'></span><span id='topic+idw-methods'></span><span id='topic+krige+2Cformula+2Cformula-method'></span><span id='topic+krige+2Cformula+2CSpatial-method'></span><span id='topic+krige+2Cformula+2Csf-method'></span><span id='topic+krige+2Cformula+2CNULL-method'></span><span id='topic+idw+2Cformula+2Cformula-method'></span><span id='topic+idw+2Cformula+2CSpatial-method'></span><span id='topic+idw+2Cformula+2Csf-method'></span><span id='topic+idw+2Cformula+2CST-method'></span>

<h3>Description</h3>

<p>Function for simple, ordinary or universal kriging (sometimes called
external drift kriging), kriging in a local neighbourhood, point kriging
or kriging of block mean values (rectangular or irregular blocks), and
conditional (Gaussian or indicator) simulation equivalents for all kriging
varieties, and function for inverse distance weighted interpolation. 
For multivariable prediction, see <a href="#topic+gstat">gstat</a> and <a href="#topic+predict">predict</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>krige(formula, locations, ...)
krige.locations(formula, locations, data, newdata, model, ..., beta, nmax
= Inf, nmin = 0, omax = 0, maxdist = Inf, block, nsim = 0, indicators = FALSE,
na.action = na.pass, debug.level = 1)
krige.spatial(formula, locations, newdata, model, ..., beta, nmax
= Inf, nmin = 0, omax = 0, maxdist = Inf, block, nsim = 0, indicators = FALSE,
na.action = na.pass, debug.level = 1)
krige0(formula, data, newdata, model, beta, y, ..., computeVar = FALSE,
	fullCovariance = FALSE)
idw(formula, locations, ...)
idw.locations(formula, locations, data, newdata, nmax = Inf, 
	nmin = 0, omax = 0, maxdist = Inf, block, na.action = na.pass, idp = 2.0,
	debug.level = 1)
idw.spatial(formula, locations, newdata, nmax = Inf, nmin = 0, 
    omax = 0, maxdist = Inf, block = numeric(0), na.action = na.pass, idp = 2.0,
	debug.level = 1)
idw0(formula, data, newdata, y, idp = 2.0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="krige_+3A_formula">formula</code></td>
<td>
<p> formula that defines the dependent variable as a linear
model of independent variables; suppose the dependent variable has name
<code>z</code>, for ordinary and simple kriging use the formula <code>z~1</code>;
for simple kriging also define <code>beta</code> (see below); for universal
kriging, suppose <code>z</code> is linearly dependent on <code>x</code> and <code>y</code>,
use the formula <code>z~x+y</code></p>
</td></tr>
<tr><td><code id="krige_+3A_locations">locations</code></td>
<td>
<p> object of class <code>Spatial</code> or <code>sf</code>, or (deprecated)
formula defines the spatial data locations (coordinates) such as <code>~x+y</code></p>
</td></tr>
<tr><td><code id="krige_+3A_data">data</code></td>
<td>
<p> data frame: should contain the dependent variable, independent
variables, and coordinates, should be missing if locations contains data. </p>
</td></tr>
<tr><td><code id="krige_+3A_newdata">newdata</code></td>
<td>
<p> object of class <code>Spatial</code>, <code>sf</code> or <code>stars</code> with prediction/simulation 
locations; should contain attributes with the independent variables (if present).  </p>
</td></tr>
<tr><td><code id="krige_+3A_model">model</code></td>
<td>
<p> variogram model of dependent variable (or its residuals), 
defined by a call to <a href="#topic+vgm">vgm</a> or <a href="#topic+fit.variogram">fit.variogram</a>; for <code>krige0</code>
also a user-supplied covariance function is allowed (see example below) </p>
</td></tr>
<tr><td><code id="krige_+3A_beta">beta</code></td>
<td>
<p> for simple kriging (and simulation based on simple
kriging): vector with the trend coefficients (including intercept);
if no independent variables are defined the model only contains an
intercept and beta should be the simple kriging mean </p>
</td></tr>
<tr><td><code id="krige_+3A_nmax">nmax</code></td>
<td>
<p> for local kriging: the number of nearest observations that
should be used for a kriging prediction or simulation, where nearest
is defined in terms of the space of the spatial locations. By default,
all observations are used </p>
</td></tr>
<tr><td><code id="krige_+3A_nmin">nmin</code></td>
<td>
<p> for local kriging: if the number of nearest observations
within distance <code>maxdist</code> is less than <code>nmin</code>, a missing 
value will be generated; see maxdist </p>
</td></tr>
<tr><td><code id="krige_+3A_omax">omax</code></td>
<td>
<p> see <a href="#topic+gstat">gstat</a> </p>
</td></tr>
<tr><td><code id="krige_+3A_maxdist">maxdist</code></td>
<td>
<p> for local kriging: only observations within a distance
of <code>maxdist</code> from the prediction location are used for prediction
or simulation; if combined with <code>nmax</code>, both criteria apply </p>
</td></tr>
<tr><td><code id="krige_+3A_block">block</code></td>
<td>
<p> block size; a vector with 1, 2 or 3 values containing
the size of a rectangular in x-, y- and z-dimension respectively
(0 if not set), or a data frame with 1, 2 or 3 columns, containing
the points that discretize the block in the x-, y- and z-dimension
to define irregular blocks relative to (0,0) or (0,0,0)&mdash;see also the details 
section of <a href="#topic+predict">predict</a>. By default, predictions or simulations 
refer to the support of the data values. </p>
</td></tr>
<tr><td><code id="krige_+3A_nsim">nsim</code></td>
<td>
<p> integer; if set to a non-zero value, conditional simulation
is used instead of kriging interpolation. For this, sequential Gaussian
or indicator simulation is used (depending on the value of 
<code>indicators</code>), following a single random path through the data.  </p>
</td></tr>
<tr><td><code id="krige_+3A_indicators">indicators</code></td>
<td>
<p> logical, only relevant if <code>nsim</code> is non-zero; if
TRUE, use indicator simulation; else use Gaussian simulation </p>
</td></tr>
<tr><td><code id="krige_+3A_na.action">na.action</code></td>
<td>
<p> function determining what should be done with missing
values in 'newdata'.  The default is to predict 'NA'.  Missing values 
in coordinates and predictors are both dealt with. </p>
</td></tr>
<tr><td><code id="krige_+3A_debug.level">debug.level</code></td>
<td>
<p>debug level, passed to <a href="#topic+predict">predict</a>; use -1 
to see progress in percentage, and 0 to suppress all printed information </p>
</td></tr>
<tr><td><code id="krige_+3A_...">...</code></td>
<td>
<p> for krige: arguments that will be passed to <a href="#topic+gstat">gstat</a>;
for <code>krige0</code>: arguments that will be passe to <code>model</code></p>
</td></tr>
<tr><td><code id="krige_+3A_idp">idp</code></td>
<td>
<p>numeric; specify the inverse distance weighting power</p>
</td></tr>
<tr><td><code id="krige_+3A_y">y</code></td>
<td>
<p>matrix; to krige multiple fields in a single step, pass data 
as columns of matrix <code>y</code>. This will ignore the value of the 
response in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="krige_+3A_computevar">computeVar</code></td>
<td>
<p>logical; if TRUE, prediction variances will be returned</p>
</td></tr>
<tr><td><code id="krige_+3A_fullcovariance">fullCovariance</code></td>
<td>
<p>logical; if FALSE a vector with prediction 
variances will be returned, if TRUE the full covariance matrix of 
all predictions will be returned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>krige</code> is a simple wrapper method around <a href="#topic+gstat">gstat</a>
and <a href="#topic+predict">predict</a> for univariate kriging prediction and conditional
simulation methods available in gstat. For multivariate prediction or
simulation, or for other interpolation methods provided by gstat (such as
inverse distance weighted interpolation or trend surface interpolation)
use the functions <a href="#topic+gstat">gstat</a> and <a href="#topic+predict">predict</a> directly.
</p>
<p>Function <code>idw</code> performs just as <code>krige</code> without a model being
passed, but allows direct specification of the inverse distance weighting
power. Don't use with predictors in the formula.
</p>
<p>For further details, see <a href="#topic+predict">predict</a>.
</p>


<h3>Value</h3>

<p>if <code>locations</code> is not a formula, object of the same class as
<code>newdata</code> (deriving from <code>Spatial</code>); else a data frame
containing the coordinates of <code>newdata</code>. Attributes columns
contain prediction and prediction variance (in case of kriging) or the
<code>abs(nsim)</code> columns of the conditional Gaussian or indicator
simulations 
</p>
<p><code>krige0</code> and <code>idw0</code> are alternative functions with reduced
functionality and larger memory requirements; they return numeric vectors
(or matrices, in case of multiple dependent) with predicted values only;
in case <code>computeVar</code> is TRUE, a list with elements <code>pred</code> and
<code>var</code> is returned, containing predictions, and (co)variances (depending
on argument <code>fullCovariance</code>).
</p>


<h3>Methods</h3>


<dl>
<dt>formula = &quot;formula&quot;, locations = &quot;formula&quot;</dt><dd> 
<p>locations specifies which coordinates in <code>data</code> refer to spatial coordinates
</p>
</dd>
<dt>formula = &quot;formula&quot;, locations = &quot;Spatial&quot;</dt><dd> 
<p>Object locations knows about its own spatial locations
</p>
</dd>
<dt>formula = &quot;formula&quot;, locations = &quot;NULL&quot;</dt><dd><p> used in case of unconditional simulations;
newdata needs to be of class Spatial </p>
</dd>
</dl>


<h3>Note</h3>

  
<p>Daniel G. Krige is a South African scientist who was a mining engineer
when he first used generalised least squares prediction with spatial
covariances in the 50's. George Matheron coined the term <code>kriging</code>
in the 60's for the action of doing this, although very similar approaches
had been taken in the field of meteorology. Beside being Krige's name,
I consider &quot;krige&quot; to be to &quot;kriging&quot; what &quot;predict&quot; is to &quot;prediction&quot;.
</p>


<h3>Author(s)</h3>

<p> Edzer Pebesma </p>


<h3>References</h3>

<p> N.A.C. Cressie, 1993, Statistics for Spatial Data,
Wiley. 
</p>
<p><a href="http://www.gstat.org/">http://www.gstat.org/</a>
</p>
<p>Pebesma, E.J., 2004. Multivariable geostatistics in S: the gstat package.
Computers and Geosciences, 30: 683-691.
</p>


<h3>See Also</h3>

 <p><a href="#topic+gstat">gstat</a>, <a href="#topic+predict">predict</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sp)
data(meuse)
coordinates(meuse) = ~x+y
data(meuse.grid)
gridded(meuse.grid) = ~x+y
m &lt;- vgm(.59, "Sph", 874, .04)
# ordinary kriging:
x &lt;- krige(log(zinc)~1, meuse, meuse.grid, model = m)
spplot(x["var1.pred"], main = "ordinary kriging predictions")
spplot(x["var1.var"],  main = "ordinary kriging variance")
# simple kriging:
x &lt;- krige(log(zinc)~1, meuse, meuse.grid, model = m, beta = 5.9)
# residual variogram:
m &lt;- vgm(.4, "Sph", 954, .06)
# universal block kriging:
x &lt;- krige(log(zinc)~x+y, meuse, meuse.grid, model = m, block = c(40,40))
spplot(x["var1.pred"], main = "universal kriging predictions")

# krige0, using user-defined covariance function and multiple responses in y:
# exponential variogram with range 500, defined as covariance function:
v = function(x, y = x) { exp(-spDists(coordinates(x),coordinates(y))/500) }
# krige two variables in a single pass (using 1 covariance model):
y = cbind(meuse$zinc,meuse$copper,meuse$lead,meuse$cadmium)
x &lt;- krige0(zinc~1, meuse, meuse.grid, v, y = y)
meuse.grid$zinc = x[,1]
spplot(meuse.grid["zinc"], main = "zinc")
meuse.grid$copper = x[,2]
spplot(meuse.grid["copper"], main = "copper")

# the following has NOTHING to do with kriging, but --
# return the median of the nearest 11 observations:
x = krige(zinc~1, meuse, meuse.grid, set = list(method = "med"), nmax = 11)
# get 25%- and 75%-percentiles of nearest 11 obs, as prediction and variance:
x = krige(zinc~1, meuse, meuse.grid, nmax = 11, 
	set = list(method = "med", quantile = 0.25))
# get diversity (# of different values) and mode from 11 nearest observations:
x = krige(zinc~1, meuse, meuse.grid, nmax = 11, set = list(method = "div"))
</code></pre>

<hr>
<h2 id='krige.cv'> (co)kriging cross validation, n-fold or leave-one-out </h2><span id='topic+krige.cv'></span><span id='topic+krige.cv.spatial'></span><span id='topic+krige.cv.locations'></span><span id='topic+gstat.cv'></span><span id='topic+krige.cv+2Cformula+2Cformula-method'></span><span id='topic+krige.cv+2Cformula+2CSpatial-method'></span><span id='topic+krige.cv+2Cformula+2Csf-method'></span>

<h3>Description</h3>

<p> Cross validation functions for simple, ordinary or universal
point (co)kriging, kriging in a local neighbourhood.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>gstat.cv(object, nfold, remove.all = FALSE, verbose = interactive(), 
	all.residuals = FALSE, ...)
krige.cv(formula, locations, ...)
krige.cv.locations(formula, locations, data, model = NULL, ..., beta = NULL, 
	nmax = Inf, nmin = 0, maxdist = Inf, nfold = nrow(data), 
	verbose = interactive(), debug.level = 0)
krige.cv.spatial(formula, locations, model = NULL, ..., beta = NULL, 
	nmax = Inf, nmin = 0, maxdist = Inf, nfold = nrow(locations), 
	verbose = interactive(), debug.level = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="krige.cv_+3A_object">object</code></td>
<td>
<p> object of class gstat; see function <a href="#topic+gstat">gstat</a></p>
</td></tr>
<tr><td><code id="krige.cv_+3A_nfold">nfold</code></td>
<td>
<p> integer; if larger than 1, then apply n-fold cross validation; 
if <code>nfold</code> equals <code>nrow(data)</code> (the default), apply leave-one-out cross 
validation; if set to e.g. 5, five-fold cross validation is done. To specify the
folds, pass an integer vector of length <code>nrow(data)</code> with fold indexes. </p>
</td></tr>
<tr><td><code id="krige.cv_+3A_remove.all">remove.all</code></td>
<td>
<p> logical; if TRUE, remove observations at cross validation
locations not only for the first, but for all subsequent variables as well </p>
</td></tr>
<tr><td><code id="krige.cv_+3A_verbose">verbose</code></td>
<td>
<p> logical; if FALSE, progress bar is suppressed </p>
</td></tr>
<tr><td><code id="krige.cv_+3A_all.residuals">all.residuals</code></td>
<td>
<p> logical; if TRUE, residuals for all variables are
returned instead of for the first variable only</p>
</td></tr>
<tr><td><code id="krige.cv_+3A_...">...</code></td>
<td>
<p> other arguments that will be passed to <a href="#topic+predict">predict</a>
in case of <code>gstat.cv</code>, or to <a href="#topic+gstat">gstat</a> in case of <code>krige.cv</code></p>
</td></tr>
<tr><td><code id="krige.cv_+3A_formula">formula</code></td>
<td>
<p> formula that defines the dependent variable as a linear
model of independent variables; suppose the dependent variable has name
<code>z</code>, for ordinary and simple kriging use the formula <code>z~1</code>;
for simple kriging also define <code>beta</code> (see below); for universal
kriging, suppose <code>z</code> is linearly dependent on <code>x</code> and <code>y</code>,
use the formula <code>z~x+y</code></p>
</td></tr>
<tr><td><code id="krige.cv_+3A_locations">locations</code></td>
<td>
<p> data object deriving from class <code>Spatial</code> or <code>sf</code> </p>
</td></tr>
<tr><td><code id="krige.cv_+3A_data">data</code></td>
<td>
<p> data frame (deprecated); should contain the dependent variable, independent
variables, and coordinates; only to be provided if <code>locations</code> is a formula</p>
</td></tr>
<tr><td><code id="krige.cv_+3A_model">model</code></td>
<td>
<p> variogram model of dependent variable (or its residuals), 
defined by a call to <a href="#topic+vgm">vgm</a> or <a href="#topic+fit.variogram">fit.variogram</a></p>
</td></tr>
<tr><td><code id="krige.cv_+3A_beta">beta</code></td>
<td>
<p> only for simple kriging (and simulation based on simple
kriging); vector with the trend coefficients (including intercept);
if no independent variables are defined the model only contains an
intercept and this should be the simple kriging mean </p>
</td></tr>
<tr><td><code id="krige.cv_+3A_nmax">nmax</code></td>
<td>
<p> for local kriging: the number of nearest observations that
should be used for a kriging prediction or simulation, where nearest
is defined in terms of the space of the spatial locations. By default,
all observations are used </p>
</td></tr>
<tr><td><code id="krige.cv_+3A_nmin">nmin</code></td>
<td>
<p> for local kriging: if the number of nearest observations
within distance <code>maxdist</code> is less than <code>nmin</code>, a missing 
value will be generated; see maxdist </p>
</td></tr>
<tr><td><code id="krige.cv_+3A_maxdist">maxdist</code></td>
<td>
<p> for local kriging: only observations within a distance
of <code>maxdist</code> from the prediction location are used for prediction
or simulation; if combined with <code>nmax</code>, both criteria apply </p>
</td></tr>
<tr><td><code id="krige.cv_+3A_debug.level">debug.level</code></td>
<td>
<p> print debugging information; 0 suppresses
debug information </p>
</td></tr>
</table>


<h3>Details</h3>

<p> Leave-one-out cross validation (LOOCV) visits a data point, and
predicts the value at that location by leaving out the observed value,
and proceeds with the next data point. (The observed value is left
out because kriging would otherwise predict the value itself.) N-fold
cross validation makes a partitions the data set in N parts. For all
observation in a part, predictions are made based on the remaining N-1
parts; this is repeated for each of the N parts. N-fold cross validation
may be faster than LOOCV. </p>


<h3>Value</h3>

<p> data frame containing the coordinates of <code>data</code> or those
of the first variable in <code>object</code>, and columns of prediction and
prediction variance of cross validated data points, observed values,
residuals, zscore (residual divided by kriging standard error), and fold.
</p>
<p>If <code>all.residuals</code> is true, a data frame with residuals for all
variables is returned, without coordinates. </p>


<h3>Methods</h3>


<dl>
<dt>formula = &quot;formula&quot;, locations = &quot;formula&quot;</dt><dd> 
<p>locations specifies which coordinates in <code>data</code> refer to spatial coordinates
</p>
</dd>
<dt>formula = &quot;formula&quot;, locations = &quot;Spatial&quot;</dt><dd> 
<p>Object locations knows about its own spatial locations
</p>
</dd>
</dl>


<h3>Note</h3>

<p> Leave-one-out cross validation seems to be much faster in plain
(stand-alone) gstat, apparently quite a bit of the effort is spent moving 
data around from R to gstat. </p>


<h3>Author(s)</h3>

<p> Edzer Pebesma </p>


<h3>References</h3>

 <p><a href="http://www.gstat.org/">http://www.gstat.org/</a> </p>


<h3>See Also</h3>

 <p><a href="#topic+krige">krige</a>, <a href="#topic+gstat">gstat</a>, <a href="#topic+predict">predict</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sp)
data(meuse)
coordinates(meuse) &lt;- ~x+y
m &lt;- vgm(.59, "Sph", 874, .04)
# five-fold cross validation:
x &lt;- krige.cv(log(zinc)~1, meuse, m, nmax = 40, nfold=5)
bubble(x, "residual", main = "log(zinc): 5-fold CV residuals")

# multivariable; thanks to M. Rufino:
meuse.g &lt;- gstat(id = "zn", formula = log(zinc) ~ 1, data = meuse)
meuse.g &lt;- gstat(meuse.g, "cu", log(copper) ~ 1, meuse)
meuse.g &lt;- gstat(meuse.g, model = vgm(1, "Sph", 900, 1), fill.all = TRUE)
x &lt;- variogram(meuse.g, cutoff = 1000)
meuse.fit = fit.lmc(x, meuse.g)
out = gstat.cv(meuse.fit, nmax = 40, nfold = 5) 
summary(out)
out = gstat.cv(meuse.fit, nmax = 40, nfold = c(rep(1,100), rep(2,55))) 
summary(out)
# mean error, ideally 0:
mean(out$residual)
# MSPE, ideally small
mean(out$residual^2)
# Mean square normalized error, ideally close to 1
mean(out$zscore^2)
# correlation observed and predicted, ideally 1
cor(out$observed, out$observed - out$residual)
# correlation predicted and residual, ideally 0
cor(out$observed - out$residual, out$residual)
</code></pre>

<hr>
<h2 id='krigeSimCE'>Simulation based on circulant embedding</h2><span id='topic+krigeSimCE'></span>

<h3>Description</h3>

<p>Simulating a conditional/unconditional Gaussian random field via kriging and circulant embedding</p>


<h3>Usage</h3>

<pre><code class='language-R'>krigeSimCE(formula, data, newdata, model, n = 1, ext = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="krigeSimCE_+3A_formula">formula</code></td>
<td>
<p> the formula of the kriging predictor</p>
</td></tr>
<tr><td><code id="krigeSimCE_+3A_data">data</code></td>
<td>
<p> spatial data frame that conditions the simulation</p>
</td></tr>
<tr><td><code id="krigeSimCE_+3A_newdata">newdata</code></td>
<td>
<p>locations in space where the Gaussian random field shall be simulated</p>
</td></tr>
<tr><td><code id="krigeSimCE_+3A_model">model</code></td>
<td>
<p>a vgm model that defines the spatial covariance structure</p>
</td></tr>
<tr><td><code id="krigeSimCE_+3A_n">n</code></td>
<td>
<p>number of simulations</p>
</td></tr>
<tr><td><code id="krigeSimCE_+3A_ext">ext</code></td>
<td>
<p>extension factor of the circulant embedding, defaults to 2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A spatial data frame as defined in <code>newdata</code> with <code>n</code> simulations.</p>


<h3>Author(s)</h3>

<p>Benedikt Graeler</p>


<h3>References</h3>

<p>Davies, Tilman M., and David Bryant: &quot;On circulant embedding for Gaussian random fields in R.&quot; 
Journal of Statistical Software 55.9 (2013): 1-21.
See i.e. the supplementary files at (retrieved 2018-05-25): 
https://www.jstatsoft.org/index.php/jss/article/downloadSuppFile/v055i09/v55i09.R
</p>


<h3>See Also</h3>

<p><code><a href="#topic+krigeSTSimTB">krigeSTSimTB</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># see demo('circEmbeddingMeuse')</code></pre>

<hr>
<h2 id='krigeST'> Ordinary global Spatio-Temporal Kriging</h2><span id='topic+krigeST'></span><span id='topic+krige+2Cformula+2CST-method'></span><span id='topic+krigeSTTg'></span>

<h3>Description</h3>

<p>Function for ordinary global and local and trans Gaussian spatio-temporal kriging on point support
</p>


<h3>Usage</h3>

<pre><code class='language-R'>krigeST(formula, data, newdata, modelList, beta, y, ...,
        nmax = Inf, stAni = NULL,
        computeVar = FALSE,	fullCovariance = FALSE,
        bufferNmax=2, progress=TRUE)
krigeSTTg(formula, data, newdata, modelList, y, nmax=Inf, stAni=NULL,
                      bufferNmax=2, progress=TRUE, lambda = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="krigeST_+3A_formula">formula</code></td>
<td>
<p> formula that defines the dependent variable as a linear
model of independent variables; suppose the dependent variable has name
<code>z</code>, for ordinary and simple kriging use the formula <code>z~1</code>;
for simple kriging also define <code>beta</code> (see below); for universal
kriging, suppose <code>z</code> is linearly dependent on <code>x</code> and <code>y</code>,
use the formula <code>z~x+y</code></p>
</td></tr>
<tr><td><code id="krigeST_+3A_data">data</code></td>
<td>
<p> ST object: should contain the dependent variable and independent
variables.</p>
</td></tr>
<tr><td><code id="krigeST_+3A_newdata">newdata</code></td>
<td>
<p> ST object with prediction/simulation locations in
space and time; should contain attribute columns with the independent variables
(if present).</p>
</td></tr>
<tr><td><code id="krigeST_+3A_modellist">modelList</code></td>
<td>
<p> object of class <code>StVariogramModel</code>, created by
<code><a href="#topic+vgmST">vgmST</a></code> - see below or the function <code><a href="#topic+vgmAreaST">vgmAreaST</a></code> for area-to-point kriging. For the general kriging case: a list with named elements: <code>space</code>, <code>time</code>
and/or <code>joint</code> depending 
on the spatio-temporal covariance family, and an entry <code>stModel</code>. 
Currently 
implemented families that may be used for <code>stModel</code> 
are <code>separable</code>, <code>productSum</code>, <code>metric</code>, 
<code>sumMetric</code> and <code>simpleSumMetric</code>. 
See the examples section in <code><a href="#topic+fit.StVariogram">fit.StVariogram</a></code> or 
<code><a href="#topic+variogramSurface">variogramSurface</a></code> for details on how to define spatio-temporal 
covariance models. <code>krigeST</code> will look for a &quot;temporal unit&quot; attribute
in the provided modelList in order to adjust the temporal scales.</p>
</td></tr>
<tr><td><code id="krigeST_+3A_y">y</code></td>
<td>
<p>matrix; to krige multiple fields in a single step, pass data 
as columns of matrix <code>y</code>. This will ignore the value of the 
response in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="krigeST_+3A_beta">beta</code></td>
<td>
<p>The (known) mean for simple kriging.</p>
</td></tr>
<tr><td><code id="krigeST_+3A_nmax">nmax</code></td>
<td>
<p>The maximum number of neighbouring locations for a spatio-temporal local neighbourhood</p>
</td></tr>
<tr><td><code id="krigeST_+3A_stani">stAni</code></td>
<td>
<p>a spatio-temporal anisotropy scaling assuming a metric spatio-temporal space. Used only for the selection of the closest neighbours. This scaling needs only to be provided in case the model does not have a stAni parameter, or if a different one should be used for the neighbourhood selection. Mind the correct spatial unit. Currently, no coordinate conversion is made for the neighbourhood selection (i.e. Lat and Lon require a spatio-temporal anisotropy scaling in degrees per second).</p>
</td></tr>
<tr><td><code id="krigeST_+3A_...">...</code></td>
<td>
<p> further arguments used for instance to pass the model into vgmAreaST for area-to-point kriging</p>
</td></tr>
<tr><td><code id="krigeST_+3A_computevar">computeVar</code></td>
<td>
<p>logical; if TRUE, prediction variances will be returned</p>
</td></tr>
<tr><td><code id="krigeST_+3A_fullcovariance">fullCovariance</code></td>
<td>
<p>logical; if FALSE a vector with prediction 
variances will be returned, if TRUE the full covariance matrix of 
all predictions will be returned</p>
</td></tr>
<tr><td><code id="krigeST_+3A_buffernmax">bufferNmax</code></td>
<td>
<p>factor with which nmax is multiplied for an extended search radius (default=2). Set to 1 for no extension of the search radius.</p>
</td></tr>
<tr><td><code id="krigeST_+3A_progress">progress</code></td>
<td>
<p>whether a progress bar shall be printed for local spatio-temporal kriging; default=TRUE</p>
</td></tr>
<tr><td><code id="krigeST_+3A_lambda">lambda</code></td>
<td>
<p>The value of lambda used in the box-cox transformation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>krigeST</code> is a R implementation of the kriging function from 
<a href="#topic+gstat">gstat</a> using spatio-temporal covariance models following the 
implementation of <code><a href="#topic+krige0">krige0</a></code>. Function <code>krigeST</code> offers some 
particular methods for ordinary spatio-temporal (ST) kriging. In particular,
it does not support block kriging or kriging in a distance-based
neighbourhood, and does not provide simulation.
</p>
<p>If <code>data</code> is of class <code>sftime</code>, then <code>newdata</code> MUST be
of class <code>stars</code> or <code>sftime</code>, i.e. mixing form old-style
classes (package spacetime) and new-style classes (sf, stars, sftime)
is not supported.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>newdata</code> (deriving from 
<code><a href="spacetime.html#topic+ST-class">ST</a></code>). Attributes columns contain prediction and prediction 
variance.
</p>


<h3>Author(s)</h3>

<p> Edzer Pebesma, Benedikt Graeler </p>


<h3>References</h3>

 
<p>Benedikt Graeler, Edzer Pebesma, Gerard Heuvelink.  Spatio-Temporal
Geostatistics using gstat.  The R Journal 8(1), 204&ndash;218.
<a href="https://journal.r-project.org/archive/2016/RJ-2016-014/index.html">https://journal.r-project.org/archive/2016/RJ-2016-014/index.html</a>
</p>
<p>N.A.C. Cressie, 1993, Statistics for Spatial Data,
Wiley. 
</p>
<p><a href="http://www.gstat.org/">http://www.gstat.org/</a>
</p>
<p>Pebesma, E.J., 2004. Multivariable geostatistics in S: the gstat package.
Computers and Geosciences, 30: 683-691.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+krige0">krige0</a></code>, <code><a href="#topic+gstat">gstat</a></code>, <code><a href="#topic+predict">predict</a></code>, <code><a href="#topic+krigeTg">krigeTg</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sp)
library(spacetime)
sumMetricVgm &lt;- vgmST("sumMetric",
                      space = vgm( 4.4, "Lin", 196.6,  3),
                      time  = vgm( 2.2, "Lin",   1.1,  2),
                      joint = vgm(34.6, "Exp", 136.6, 12),
                      stAni = 51.7)

data(air)
suppressWarnings(proj4string(stations) &lt;- CRS(proj4string(stations)))
rural = STFDF(stations, dates, data.frame(PM10 = as.vector(air)))

rr &lt;- rural[,"2005-06-01/2005-06-03"]
rr &lt;- as(rr,"STSDF")

x1 &lt;- seq(from=6,to=15,by=1)
x2 &lt;- seq(from=48,to=55,by=1)

DE_gridded &lt;- SpatialPoints(cbind(rep(x1,length(x2)), rep(x2,each=length(x1))), 
                            proj4string=CRS(proj4string(rr@sp)))
gridded(DE_gridded) &lt;- TRUE
DE_pred &lt;- STF(sp=as(DE_gridded,"SpatialPoints"), time=rr@time)
DE_kriged &lt;- krigeST(PM10~1, data=rr, newdata=DE_pred,
                     modelList=sumMetricVgm)
gridded(DE_kriged@sp) &lt;- TRUE
stplot(DE_kriged)
</code></pre>

<hr>
<h2 id='krigeSTSimTB'>conditional/unconditional spatio-temporal simulation</h2><span id='topic+krigeSTSimTB'></span>

<h3>Description</h3>

<p>conditional/unconditional spatio-temporal simulation based on turning bands
</p>


<h3>Usage</h3>

<pre><code class='language-R'>krigeSTSimTB(formula, data, newdata, modelList, nsim, progress = TRUE, 
             nLyrs = 500, tGrid = NULL, sGrid = NULL, ceExt = 2, nmax = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="krigeSTSimTB_+3A_formula">formula</code></td>
<td>
<p>the formula of the kriging predictor</p>
</td></tr>
<tr><td><code id="krigeSTSimTB_+3A_data">data</code></td>
<td>
<p>conditioning data</p>
</td></tr>
<tr><td><code id="krigeSTSimTB_+3A_newdata">newdata</code></td>
<td>
<p>locations in space and time where the simulation is carried out</p>
</td></tr>
<tr><td><code id="krigeSTSimTB_+3A_modellist">modelList</code></td>
<td>
<p>the spatio-temporal variogram (from <code><a href="#topic+vgmST">vgmST</a></code>) defining the spatio-temporal covariance structure of the simulated Gaussian random field</p>
</td></tr>
<tr><td><code id="krigeSTSimTB_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations</p>
</td></tr>
<tr><td><code id="krigeSTSimTB_+3A_progress">progress</code></td>
<td>
<p>boolean; whether the progress should be shown in progress bar</p>
</td></tr>
<tr><td><code id="krigeSTSimTB_+3A_nlyrs">nLyrs</code></td>
<td>
<p>number of layers used in the turning bands approach (default = 500) </p>
</td></tr>
<tr><td><code id="krigeSTSimTB_+3A_tgrid">tGrid</code></td>
<td>
<p>optional explicit temporal griding that shall be used</p>
</td></tr>
<tr><td><code id="krigeSTSimTB_+3A_sgrid">sGrid</code></td>
<td>
<p>optional explicit spatial griding that shall be used</p>
</td></tr>
<tr><td><code id="krigeSTSimTB_+3A_ceext">ceExt</code></td>
<td>
<p>expansion in the circulant embedding, defaults to 2</p>
</td></tr>
<tr><td><code id="krigeSTSimTB_+3A_nmax">nmax</code></td>
<td>
<p>number of nearest neighbours that shall e used, defaults to 'Inf' meaning all available points are used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a spatio-temporal data frame with <code>nSim</code> simulations</p>


<h3>Author(s)</h3>

<p>Benedikt Graeler</p>


<h3>References</h3>

<p>Turning bands
</p>
<p>Lantuejoul, C. (2002) Geostatistical Simulation: Models and Algorithms. Springer.
</p>
<p>Matheron, G. (1973). The intrinsic random functions and their applications. Adv. Appl. Probab., 5, 439-468.
</p>
<p>Strokorb, K., Ballani, F., and Schlather, M. (2014) Tail correlation functions of max-stable processes: Construction principles, recovery and diversity of some mixing max-stable processes with identical TCF. Extremes, Submitted.
</p>
<p>Turning layers
</p>
<p>Schlather, M. (2011) Construction of covariance functions and unconditional simulation of random fields. In Porcu, E., Montero, J.M. and Schlather, M., Space-Time Processes and Challenges Related to Environmental Problems. New York: Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+krigeSimCE">krigeSimCE</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># see demo('circEmbeddingMeuse')
</code></pre>

<hr>
<h2 id='krigeTg'> TransGaussian kriging using Box-Cox transforms </h2><span id='topic+krigeTg'></span>

<h3>Description</h3>

<p>TransGaussian (ordinary) kriging function using Box-Cox transforms  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>krigeTg(formula, locations, newdata, model = NULL, ...,
	nmax = Inf, nmin = 0, maxdist = Inf, block = numeric(0),
	nsim = 0, na.action = na.pass, debug.level = 1,
	lambda = 1.0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="krigeTg_+3A_formula">formula</code></td>
<td>
<p> formula that defines the dependent variable as a linear
model of independent variables; suppose the dependent variable has name
<code>z</code>, for ordinary and use a formula like <code>z~1</code>; the dependent
variable should be NOT transformed.
</p>
</td></tr>
<tr><td><code id="krigeTg_+3A_locations">locations</code></td>
<td>
<p> object of class <code>Spatial</code>, with observations </p>
</td></tr>
<tr><td><code id="krigeTg_+3A_newdata">newdata</code></td>
<td>
<p> Spatial object with prediction/simulation locations; 
the coordinates should have names as defined in <code>locations</code> </p>
</td></tr>
<tr><td><code id="krigeTg_+3A_model">model</code></td>
<td>
<p> variogram model of the TRANSFORMED dependent variable, 
see <a href="#topic+vgm">vgm</a>, or <a href="#topic+fit.variogram">fit.variogram</a></p>
</td></tr>
<tr><td><code id="krigeTg_+3A_nmax">nmax</code></td>
<td>
<p> for local kriging: the number of nearest observations that
should be used for a kriging prediction or simulation, where nearest
is defined in terms of the space of the spatial locations. By default,
all observations are used </p>
</td></tr>
<tr><td><code id="krigeTg_+3A_nmin">nmin</code></td>
<td>
<p> for local kriging: if the number of nearest observations
within distance <code>maxdist</code> is less than <code>nmin</code>, a missing 
value will be generated; see maxdist </p>
</td></tr>
<tr><td><code id="krigeTg_+3A_maxdist">maxdist</code></td>
<td>
<p> for local kriging: only observations within a distance
of <code>maxdist</code> from the prediction location are used for prediction
or simulation; if combined with <code>nmax</code>, both criteria apply </p>
</td></tr>
<tr><td><code id="krigeTg_+3A_block">block</code></td>
<td>
<p> does not function correctly, afaik </p>
</td></tr>
<tr><td><code id="krigeTg_+3A_nsim">nsim</code></td>
<td>
<p> does not function correctly, afaik </p>
</td></tr>
<tr><td><code id="krigeTg_+3A_na.action">na.action</code></td>
<td>
<p> function determining what should be done with missing
values in 'newdata'.  The default is to predict 'NA'.  Missing values 
in coordinates and predictors are both dealt with. </p>
</td></tr>
<tr><td><code id="krigeTg_+3A_lambda">lambda</code></td>
<td>
<p>value for the Box-Cox transform</p>
</td></tr>
<tr><td><code id="krigeTg_+3A_debug.level">debug.level</code></td>
<td>
<p>debug level, passed to <a href="#topic+predict">predict</a>; use -1 
to see progress in percentage, and 0 to suppress all printed information </p>
</td></tr>
<tr><td><code id="krigeTg_+3A_...">...</code></td>
<td>
<p> other arguments that will be passed to <a href="#topic+gstat">gstat</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>krigeTg</code> uses transGaussian kriging as explained in
<a href="http://www.math.umd.edu/~bnk/bak/Splus/kriging.html">http://www.math.umd.edu/~bnk/bak/Splus/kriging.html</a>. 
</p>
<p>As it uses the R/gstat krige function to derive everything, it needs in
addition to ordinary kriging on the transformed scale a simple kriging
step to find m from the difference between the OK and SK prediction
variance, and a kriging/BLUE estimation step to obtain the estimate
of <code class="reqn">\mu</code>.
</p>
<p>For further details, see <a href="#topic+krige">krige</a> and <a href="#topic+predict">predict</a>.
</p>


<h3>Value</h3>

<p>an SpatialPointsDataFrame object containing the fields:
<code>m</code> for the m (Lagrange) parameter for each location;
<code>var1SK.pred</code> the <code class="reqn">c_0 C^{-1}</code> correction obtained by
<code>muhat</code> for the mean estimate at each location;
<code>var1SK.var</code> the simple kriging variance;
<code>var1.pred</code> the OK prediction on the transformed scale;
<code>var1.var</code> the OK kriging variance on the transformed scale;
<code>var1TG.pred</code> the transGaussian kriging predictor;
<code>var1TG.var</code> the transGaussian kriging variance, obtained by
<code class="reqn">\phi'(\hat{\mu},\lambda)^2 \sigma^2_{OK}</code>
</p>


<h3>Author(s)</h3>

<p> Edzer Pebesma </p>


<h3>References</h3>

<p> N.A.C. Cressie, 1993, Statistics for Spatial Data,
Wiley. 
</p>
<p><a href="http://www.gstat.org/">http://www.gstat.org/</a>
</p>


<h3>See Also</h3>

 <p><a href="#topic+gstat">gstat</a>, <a href="#topic+predict">predict</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(sp)
data(meuse)
coordinates(meuse) = ~x+y
data(meuse.grid)
gridded(meuse.grid) = ~x+y
v = vgm(1, "Exp", 300)
x1 = krigeTg(zinc~1,meuse,meuse.grid,v, lambda=1) # no transform
x2 = krige(zinc~1,meuse,meuse.grid,v)
summary(x2$var1.var-x1$var1TG.var)
summary(x2$var1.pred-x1$var1TG.pred)
lambda = -0.25
m = fit.variogram(variogram((zinc^lambda-1)/lambda ~ 1,meuse), vgm(1, "Exp", 300))
x = krigeTg(zinc~1,meuse,meuse.grid,m,lambda=-.25)
spplot(x["var1TG.pred"], col.regions=bpy.colors())
summary(meuse$zinc)
summary(x$var1TG.pred)

</code></pre>

<hr>
<h2 id='map.to.lev'> rearrange data frame for plotting with levelplot </h2><span id='topic+map.to.lev'></span>

<h3>Description</h3>

<p> rearrange data frame for plotting with levelplot </p>


<h3>Usage</h3>

<pre><code class='language-R'>map.to.lev(data, xcol = 1, ycol = 2, zcol = c(3, 4), ns = names(data)[zcol])
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map.to.lev_+3A_data">data</code></td>
<td>
<p> data frame, e.g. output from <a href="#topic+krige">krige</a> or <a href="#topic+predict">predict</a> </p>
</td></tr>
<tr><td><code id="map.to.lev_+3A_xcol">xcol</code></td>
<td>
<p> x-coordinate column number </p>
</td></tr>
<tr><td><code id="map.to.lev_+3A_ycol">ycol</code></td>
<td>
<p> y-coordinate column number </p>
</td></tr>
<tr><td><code id="map.to.lev_+3A_zcol">zcol</code></td>
<td>
<p> z-coordinate column number range </p>
</td></tr>
<tr><td><code id="map.to.lev_+3A_ns">ns</code></td>
<td>
<p>names of the set of z-columns to be viewed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame with the following elements:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p> x-coordinate for each row</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p> y-coordinate for each row</p>
</td></tr> 
<tr><td><code>z</code></td>
<td>
<p> column vector with each of the elements in columns <code>zcol</code>
of <code>data</code> stacked </p>
</td></tr> 
<tr><td><code>name</code></td>
<td>
<p> factor; name of each of the stacked <code>z</code> columns </p>
</td></tr> 
</table>


<h3>See Also</h3>

 
<p><a href="#topic+image.data.frame">image.data.frame</a>, <a href="#topic+krige">krige</a>;
for examples see <a href="#topic+predict">predict</a>;
<code>levelplot</code> in package lattice.
</p>

<hr>
<h2 id='meuse.all'>Meuse river data set &ndash; original, full data set</h2><span id='topic+meuse.all'></span>

<h3>Description</h3>

<p>This data set gives locations and top soil heavy metal concentrations
(ppm), along with a number of soil and landscape variables, collected in
a flood plain of the river Meuse, near the village Stein. Heavy metal
concentrations are bulk sampled from an area of approximately 15 m
x 15 m.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(meuse.all)
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>sample</dt><dd><p>sample number</p>
</dd>
<dt>x</dt><dd><p>a numeric vector; x-coordinate (m)
in RDM (Dutch topographical map coordinates) </p>
</dd>
<dt>y</dt><dd><p>a numeric vector; y-coordinate (m)
in RDM (Dutch topographical map coordinates)</p>
</dd>
<dt>cadmium</dt><dd><p>topsoil cadmium concentration, ppm.; note that zero cadmium
values in the original data set have been shifted to 0.2 (half the lowest 
non-zero value) </p>
</dd>
<dt>copper</dt><dd><p>topsoil copper concentration, ppm. </p>
</dd>
<dt>lead</dt><dd><p>topsoil lead concentration, ppm. </p>
</dd>
<dt>zinc</dt><dd><p>topsoil zinc concentration, ppm. </p>
</dd> 
<dt>elev</dt><dd><p>relative elevation</p>
</dd>
<dt>om</dt><dd><p>organic matter, as percentage </p>
</dd>
<dt>ffreq</dt><dd><p>flooding frequency class</p>
</dd>
<dt>soil</dt><dd><p>soil type</p>
</dd>
<dt>lime</dt><dd><p>lime class</p>
</dd>
<dt>landuse</dt><dd><p>landuse class</p>
</dd>
<dt>dist.m</dt><dd><p>distance to river Meuse (metres), as obtained during
the field survey</p>
</dd>
<dt>in.pit</dt><dd><p>logical; indicates whether this is a sample taken in
a pit</p>
</dd>
<dt>in.meuse155</dt><dd><p>logical; indicates whether the sample is part of
the <code>meuse</code> (i.e., filtered) data set; in addition to the samples
in a pit, an sample (139) with outlying zinc content was removed </p>
</dd>
<dt>in.BMcD</dt><dd><p>logical; indicates whether the sample is used as part
of the subset of 98 points in the various interpolation examples of
Burrough and McDonnell</p>
</dd>
</dl>
 


<h3>Note</h3>

 <p><code>sample</code> refers to original sample number.  Eight samples
were left out because they were not indicative for the metal content of
the soil. They were taken in an old pit. One sample contains an outlying
zinc value, which was also discarded for the meuse (155) data set.
</p>


<h3>Author(s)</h3>

<p> The actual field data were collected by Ruud van Rijn and
Mathieu Rikken; data compiled for R by Edzer Pebesma </p>


<h3>References</h3>

 
<p>P.A. Burrough, R.A. McDonnell, 1998. Principles of Geographical Information
Systems. Oxford University Press.
</p>
<p><a href="http://www.gstat.org/">http://www.gstat.org/</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+meuse.alt">meuse.alt</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meuse.all)
summary(meuse.all)
</code></pre>

<hr>
<h2 id='meuse.alt'>Meuse river altitude data set</h2><span id='topic+meuse.alt'></span>

<h3>Description</h3>

<p>This data set gives a point set with altitudes, digitized from the
1:10,000 topographical map of the Netherlands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(meuse.alt)
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>x</dt><dd><p>a numeric vector; x-coordinate (m) in RDM (Dutch topographical map coordinates) </p>
</dd>
<dt>y</dt><dd><p>a numeric vector; y-coordinate (m) in RDM (Dutch topographical map coordinates)</p>
</dd>
<dt>alt</dt><dd><p>altitude in m. above NAP (Dutch zero for sea level)</p>
</dd>
</dl>



<h3>References</h3>

 
<p><a href="http://www.gstat.org/">http://www.gstat.org/</a> 
</p>


<h3>See Also</h3>

<p><a href="#topic+meuse.all">meuse.all</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(meuse.alt)
library(lattice)
xyplot(y~x, meuse.alt, aspect = "iso")
</code></pre>

<hr>
<h2 id='ncp.grid'>Grid for the NCP, the Dutch part of the North Sea</h2><span id='topic+ncp.grid'></span>

<h3>Description</h3>

<p>Gridded data for the NCP (Nederlands Continentaal Plat, the Dutch
part of the North Sea), for a 5 km x 5 km grid; stored as data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ncp.grid)
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>x</dt><dd><p>x-coordinate, UTM zone 31</p>
</dd>
<dt>y</dt><dd><p>y-coordinate, UTM zone 31</p>
</dd>
<dt>depth</dt><dd><p>sea water depth, m.</p>
</dd>
<dt>coast</dt><dd><p>distance to the coast of the Netherlands, in km.</p>
</dd>
<dt>area</dt><dd><p>identifier for administrative sub-areas</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Dutch National Institute for Coastal and Marine Management (RIKZ);
data compiled for R by Edzer Pebesma </p>


<h3>See Also</h3>

<p><a href="#topic+fulmar">fulmar</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ncp.grid)
summary(ncp.grid)
</code></pre>

<hr>
<h2 id='ossfim'> Kriging standard errors as function of grid spacing and block size</h2><span id='topic+ossfim'></span>

<h3>Description</h3>

<p> Calculate, for a given variogram model, ordinary block
kriging standard errors as a function of sampling spaces and block sizes </p>


<h3>Usage</h3>

<pre><code class='language-R'>ossfim(spacings = 1:5, block.sizes = 1:5, model, nmax = 25, debug = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ossfim_+3A_spacings">spacings</code></td>
<td>
<p>range of grid (data) spacings to be used</p>
</td></tr>
<tr><td><code id="ossfim_+3A_block.sizes">block.sizes</code></td>
<td>
<p> range of block sizes to be used</p>
</td></tr>
<tr><td><code id="ossfim_+3A_model">model</code></td>
<td>
<p>variogram model, output of <code>vgm</code></p>
</td></tr>
<tr><td><code id="ossfim_+3A_nmax">nmax</code></td>
<td>
<p>set the kriging neighbourhood size</p>
</td></tr>
<tr><td><code id="ossfim_+3A_debug">debug</code></td>
<td>
<p>debug level; set to 32 to see a lot of output</p>
</td></tr>
</table>


<h3>Value</h3>

<p> data frame with columns <code>spacing</code> (the grid spacing),
<code>block.size</code> (the block size), and <code>kriging.se</code> (block kriging
standard error) </p>


<h3>Note</h3>

<p> The idea is old, simple, but still of value. If you want to map
a variable with a given accuracy, you will have to sample it. Suppose
the variogram of the variable is known. Given a regular sampling scheme,
the kriging standard error decreases when either (i) the data spacing
is smaller, or (ii) predictions are made for larger blocks. This function
helps quantifying this relationship. Ossfim probably refers to &ldquo;optimal
sampling scheme for isarithmic mapping&rdquo;.
</p>


<h3>Author(s)</h3>

<p> Edzer Pebesma </p>


<h3>References</h3>

 
<p>Burrough, P.A., R.A. McDonnell (1999) Principles of Geographical
Information Systems. Oxford University Press (e.g., figure 10.11 on
page 261)
</p>
<p>Burgess, T.M., R. Webster, A.B. McBratney (1981) Optimal interpolation and
isarithmic mapping of soil properties. IV Sampling strategy.  The journal
of soil science 32(4), 643-660.
</p>
<p>McBratney, A.B., R. Webster (1981) The design of optimal sampling schemes
for local estimation and mapping of regionalized variables: 2 program
and examples. Computers and Geosciences 7: 335-365.
</p>


<h3>See Also</h3>

<p><a href="#topic+krige">krige</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- ossfim(1:15,1:15, model = vgm(1,"Exp",15))
library(lattice)
levelplot(kriging.se~spacing+block.size, x, 
  main = "Ossfim results, variogram 1 Exp(15)")

## End(Not run)
# if you wonder about the decrease in the upper left corner of the graph,
# try the above with nmax set to 100, or perhaps 200.
</code></pre>

<hr>
<h2 id='oxford'>Oxford soil samples</h2><span id='topic+oxford'></span>

<h3>Description</h3>

<p>Data: 126 soil augerings on a 100 x 100m square grid, with 6 columns
and 21 rows. Grid is oriented with long axis North-north-west to
South-south-east Origin of grid is South-south-east point, 100m outside
grid.
</p>
<p>Original data are part of a soil survey carried out by P.A. Burrough in
1967. The survey area is located on the chalk downlands on the Berkshire
Downs in Oxfordshire, UK. Three soil profile units were recognised on
the shallow Rendzina soils; these are Ia - very shallow, grey calcareous
soils less than 40cm deep over chalk;  Ct - shallow to moderately deep,
grey-brown calcareous soils  on calcareous colluvium, and Cr: deep,
moderately acid, red-brown clayey soils.  These soil profile classes
were registered at every augering.
</p>
<p>In addition, an independent landscape soil map was made by interpolating
soil boundaries between these soil types, using information from the
changes in landform.  Because the soil varies over short distances,
this field mapping caused some soil borings to receive a different
classification from the classification based on the point data.
</p>
<p>Also registered at each auger point were the site elevation (m), the
depth to solid chalk rock (in cm) and the depth to lime in cm. Also,
the percent clay content, the Munsell colour components of VALUE and
CHROMA , and the lime content of the soil (as tested using HCl)  were
recorded for the top two soil layers (0-20cm and 20-40cm).
</p>
<p>Samples of topsoil taken as a bulk sample within a circle of radius 2.5m
around each sample point were used for the laboratory determination of Mg
(ppm), OM1 %, CEC as mequ/100g air dry soil, pH, P as ppm and K (ppm).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(oxford)
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>PROFILE</dt><dd><p>profile number</p>
</dd>
<dt>XCOORD</dt><dd><p>x-coordinate, field, non-projected</p>
</dd>
<dt>YCOORD</dt><dd><p>y-coordinate, field, non-projected</p>
</dd>
<dt>ELEV</dt><dd><p>elevation, m.</p>
</dd>
<dt>PROFCLASS</dt><dd><p>soil class, obtained by classifying the soil profile at the
sample site </p>
</dd>
<dt>MAPCLASS</dt><dd><p>soil class, obtained by looking up the site location in the soil map</p>
</dd>
<dt>VAL1</dt><dd><p>Munsell colour component VALUE, 0-20 cm</p>
</dd>
<dt>CHR1</dt><dd><p>Munsell colour component CHROMA, 20-40 cm</p>
</dd>
<dt>LIME1</dt><dd><p>Lime content (tested using HCl), 0-20 cm</p>
</dd>
<dt>VAL2</dt><dd><p>Munsell colour component VALUE, 0-20 cm</p>
</dd>
<dt>CHR2</dt><dd><p>Munsell colour component CHROMA, 20-40 cm</p>
</dd>
<dt>LIME2</dt><dd><p>Lime content (tested using HCl), 20-40 cm</p>
</dd>
<dt>DEPTHCM</dt><dd><p>soil depth, cm </p>
</dd>
<dt>DEP2LIME</dt><dd><p>depth to lime, cm </p>
</dd>
<dt>PCLAY1</dt><dd><p>percentage clay, 0-20 cm</p>
</dd>
<dt>PCLAY2</dt><dd><p>percentage clay, 20-40 cm</p>
</dd>
<dt>MG1</dt><dd><p>Magnesium content (ppm), 0-20 cm</p>
</dd>
<dt>OM1</dt><dd><p>organic matter (%), 0-20 cm</p>
</dd>
<dt>CEC1</dt><dd><p>CES as mequ/100g air dry soil, 0-20 cm</p>
</dd>
<dt>PH1</dt><dd><p>pH, 0-20 cm</p>
</dd>
<dt>PHOS1</dt><dd><p>Phosphorous, 0-20 cm, ppm</p>
</dd>
<dt>POT1</dt><dd><p>K (potassium), 0-20 cm, ppm</p>
</dd>
</dl>



<h3>Note</h3>

 <p><code>oxford.jpg</code>, in the gstat package external directory (see
example below), shows an image of the soil map for the region </p>


<h3>Author(s)</h3>

<p> P.A. Burrough; compiled for R by Edzer Pebesma </p>


<h3>References</h3>

 
<p>P.A. Burrough, R.A. McDonnell, 1998. Principles of Geographical Information
Systems. Oxford University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(oxford)
summary(oxford)
# open the following file with a jpg viewer:
system.file("external/oxford.jpg", package="gstat")
</code></pre>

<hr>
<h2 id='pcb'>PCB138 measurements in sediment at the NCP, the Dutch part of the North Sea</h2><span id='topic+pcb'></span>

<h3>Description</h3>

<p>PCB138 measurements in sediment at the NCP, which is the 
Dutch part of the North Sea
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(pcb)
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>year</dt><dd><p> measurement year </p>
</dd>
<dt>x</dt><dd><p> x-coordinate; UTM zone 31 </p>
</dd>
<dt>y</dt><dd><p> y-coordinate; UTM zone 31 </p>
</dd>
<dt>coast</dt><dd><p> distance to coast of the Netherlands, in km.</p>
</dd>
<dt>depth</dt><dd><p> sea water depth, m. </p>
</dd>
<dt>PCB138</dt><dd><p> PCB-138, measured on the sediment fraction smaller than
63 <code class="reqn">\mu</code>, in <code class="reqn">\mu g/kg</code> dry matter; BUT SEE NOTE BELOW </p>
</dd>
<dt>yf</dt><dd><p> year; as factor</p>
</dd>
</dl>



<h3>Note</h3>

<p> A note of caution: The PCB-138 data are provided only to be able
to re-run the analysis done in Pebesma and Duin (2004; see references
below). If you want to use these data for comparison with PCB measurements
elsewhere, or if you want to compare them to regulation standards, or
want to use these data for any other purpose, you should first contact
<a href="mailto:basisinfodesk@rikz.rws.minvenw.nl">mailto:basisinfodesk@rikz.rws.minvenw.nl</a>.  The reason for this is
that several normalisations were carried out that are not reported here,
nor in the paper below. </p>


<h3>References</h3>

 
<p>Pebesma, E. J., and Duin, R. N. M. (2005). Spatial patterns of temporal
change in North Sea sediment quality on different spatial scales. In
P. Renard, H. Demougeot-Renard and R. Froidevaux (Eds.), Geostatistics for
Environmental Applications: Proceedings of the Fifth European Conference
on Geostatistics for Environmental Applications (pp. 367-378): Springer.
</p>


<h3>See Also</h3>

<p><a href="#topic+ncp.grid">ncp.grid</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pcb)
library(lattice)
xyplot(y~x|as.factor(yf), pcb, aspect = "iso")
# demo(pcb)
</code></pre>

<hr>
<h2 id='plot.gstatVariogram'>
Plot a sample variogram, and possibly a fitted model
</h2><span id='topic+plot.gstatVariogram'></span><span id='topic+plot.variogramMap'></span><span id='topic+plot.StVariogram'></span>

<h3>Description</h3>

<p>Creates a variogram plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gstatVariogram'
plot(x, model = NULL, ylim, xlim, xlab = "distance", 
	ylab = attr(x, "what"), panel = vgm.panel.xyplot, multipanel = TRUE, 
	plot.numbers = FALSE, scales, ids = x$id, group.id = TRUE, skip, 
	layout, ...)
## S3 method for class 'variogramMap'
plot(x, np = FALSE, skip, threshold, ...)
## S3 method for class 'StVariogram'
plot(x, model = NULL, ..., col = bpy.colors(), xlab, ylab, 
	map = TRUE, convertMonths = FALSE, as.table = TRUE, wireframe = FALSE, 
	diff = FALSE, all = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.gstatVariogram_+3A_x">x</code></td>
<td>
<p> object obtained from the method 
<a href="#topic+variogram">variogram</a>, possibly containing directional or cross variograms,
space-time variograms and variogram model information </p>
</td></tr>
<tr><td><code id="plot.gstatVariogram_+3A_model">model</code></td>
<td>
<p>in case of a single variogram: a variogram model, as 
obtained from <a href="#topic+vgm">vgm</a> or <a href="#topic+fit.variogram">fit.variogram</a>, to be drawn as 
a line in the variogram plot; in case of a set of variograms and
cross variograms: a list with variogram models; in the spatio-temporal case,
a single or a list of spatio-temporal models that will be plotted next to each
other for visual comparison.</p>
</td></tr>
<tr><td><code id="plot.gstatVariogram_+3A_ylim">ylim</code></td>
<td>
<p> numeric; vector of length 2, limits of the y-axis</p>
</td></tr>
<tr><td><code id="plot.gstatVariogram_+3A_xlim">xlim</code></td>
<td>
<p> numeric; vector of length 2, limits of the x-axis</p>
</td></tr>
<tr><td><code id="plot.gstatVariogram_+3A_xlab">xlab</code></td>
<td>
<p> character; x-axis label </p>
</td></tr>
<tr><td><code id="plot.gstatVariogram_+3A_ylab">ylab</code></td>
<td>
<p> character; y-axis label </p>
</td></tr>
<tr><td><code id="plot.gstatVariogram_+3A_panel">panel</code></td>
<td>
<p> panel function </p>
</td></tr>
<tr><td><code id="plot.gstatVariogram_+3A_multipanel">multipanel</code></td>
<td>
<p> logical; if TRUE, directional variograms are plotted in
different panels, if FALSE, directional variograms are plotted in the same
graph, using color, colored lines and symbols to distinguish them </p>
</td></tr>
<tr><td><code id="plot.gstatVariogram_+3A_plot.numbers">plot.numbers</code></td>
<td>
<p> logical or numeric; if TRUE, plot number of point pairs next to
each plotted semivariance symbol, if FALSE these are omitted. 
If numeric, TRUE is assumed and the value is passed as the relative distance to be used between symbols
and numeric text values (default 0.03). </p>
</td></tr>
<tr><td><code id="plot.gstatVariogram_+3A_scales">scales</code></td>
<td>
<p> optional argument that will be passed to <code>xyplot</code> in
case of the plotting of variograms and cross variograms; use the value
<code>list(relation = "same")</code> if y-axes need to share scales </p>
</td></tr>
<tr><td><code id="plot.gstatVariogram_+3A_ids">ids</code></td>
<td>
<p> ids of the data variables and variable pairs </p>
</td></tr>
<tr><td><code id="plot.gstatVariogram_+3A_group.id">group.id</code></td>
<td>
<p> logical; control for directional multivariate variograms:
if TRUE, panels divide direction and colors indicate variables
(ids), if FALSE panels divide variables/variable pairs and colors
indicate direction</p>
</td></tr>
<tr><td><code id="plot.gstatVariogram_+3A_skip">skip</code></td>
<td>
<p> logical; can be used to arrange panels, see <code>xyplot</code></p>
</td></tr>
<tr><td><code id="plot.gstatVariogram_+3A_layout">layout</code></td>
<td>
<p> integer vector; can be used to set panel layout: c(ncol,nrow) </p>
</td></tr>
<tr><td><code id="plot.gstatVariogram_+3A_np">np</code></td>
<td>
<p> logical (only for plotting variogram maps); if TRUE, plot number of point pairs, if FALSE plot
semivariances </p>
</td></tr>
<tr><td><code id="plot.gstatVariogram_+3A_threshold">threshold</code></td>
<td>
<p>semivariogram map values based on fewer point pairs
than threshold will not be plotted</p>
</td></tr>
<tr><td><code id="plot.gstatVariogram_+3A_...">...</code></td>
<td>
<p> any arguments that will be passed to the panel plotting functions
(such as <code>auto.key</code> in examples below) </p>
</td></tr>
<tr><td><code id="plot.gstatVariogram_+3A_col">col</code></td>
<td>
<p>colors to use</p>
</td></tr>
<tr><td><code id="plot.gstatVariogram_+3A_map">map</code></td>
<td>
<p>logical; if TRUE, plot space-time variogram map</p>
</td></tr>
<tr><td><code id="plot.gstatVariogram_+3A_convertmonths">convertMonths</code></td>
<td>
<p>logical; if TRUE, <code>yearmon</code> time lags will
be unit converted and plotted as (integer) months, and no longer match the
numeric representation of <code>yearmon</code>, which has years as unit </p>
</td></tr>
<tr><td><code id="plot.gstatVariogram_+3A_as.table">as.table</code></td>
<td>
<p>controls the plotting order for multiple panels, see <code><a href="lattice.html#topic+xyplot">xyplot</a></code> for details.</p>
</td></tr>
<tr><td><code id="plot.gstatVariogram_+3A_wireframe">wireframe</code></td>
<td>
<p>logical; if TRUE, produce a wireframe plot</p>
</td></tr>
<tr><td><code id="plot.gstatVariogram_+3A_diff">diff</code></td>
<td>
<p>logical; if TRUE, plot difference between model and sample variogram; ignores <code>all</code>.</p>
</td></tr>
<tr><td><code id="plot.gstatVariogram_+3A_all">all</code></td>
<td>
<p>logical; if TRUE, plot sample and model variogram(s) in single wireframes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please note that in the spatio-temporal case the levelplot and wireframe plots use the spatial distances averaged for each time lag <code>avgDist</code>. For strongly varying spatial locations over time, please check the distance columns <code>dist</code> and <code>avgDist</code> of the spatio-temporal sample variogram. The <code>lattice::cloud</code> function is one option to plot irregular 3D data.</p>


<h3>Value</h3>

<p>returns (or plots) the variogram plot
</p>


<h3>Note</h3>

<p> currently, plotting models and/or point pair numbers is not
supported when a variogram is both directional and multivariable; also,
three-dimensional directional variograms will probably not be displayed
correctly. </p>


<h3>Author(s)</h3>

<p> Edzer Pebesma </p>


<h3>References</h3>

 <p><a href="http://www.gstat.org">http://www.gstat.org</a></p>


<h3>See Also</h3>

<p><a href="#topic+variogram">variogram</a>,
<a href="#topic+fit.variogram">fit.variogram</a>, 
<a href="#topic+vgm">vgm</a>
<a href="#topic+variogramLine">variogramLine</a>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sp)
data(meuse)
coordinates(meuse) = ~x+y
vgm1 &lt;- variogram(log(zinc)~1, meuse)
plot(vgm1)
model.1 &lt;- fit.variogram(vgm1,vgm(1,"Sph",300,1))
plot(vgm1, model=model.1)
plot(vgm1, plot.numbers = TRUE, pch = "+")
vgm2 &lt;- variogram(log(zinc)~1, meuse, alpha=c(0,45,90,135))
plot(vgm2)
# the following demonstrates plotting of directional models:
model.2 &lt;- vgm(.59,"Sph",926,.06,anis=c(0,0.3))
plot(vgm2, model=model.2)
 
g = gstat(NULL, "zinc &lt; 200", I(zinc&lt;200)~1, meuse)
g = gstat(g, "zinc &lt; 400", I(zinc&lt;400)~1, meuse)
g = gstat(g, "zinc &lt; 800", I(zinc&lt;800)~1, meuse)
# calculate multivariable, directional variogram:
v = variogram(g, alpha=c(0,45,90,135))
plot(v, group.id = FALSE, auto.key = TRUE) # id and id pairs panels
plot(v, group.id = TRUE, auto.key = TRUE)  # direction panels

# variogram maps:
plot(variogram(g, cutoff=1000, width=100, map=TRUE),
    main = "(cross) semivariance maps")
plot(variogram(g, cutoff=1000, width=100, map=TRUE), np=TRUE,
    main = "number of point pairs")
</code></pre>

<hr>
<h2 id='plot.pointPairs'>
Plot a point pairs, identified from a variogram cloud
</h2><span id='topic+plot.pointPairs'></span>

<h3>Description</h3>

<p>Plot a point pairs, identified from a variogram cloud
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pointPairs'
plot(x, data, xcol = data$x, ycol = data$y, xlab = "x coordinate", 
ylab = "y coordinate", col.line = 2, line.pch = 0, main = "selected point pairs", ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.pointPairs_+3A_x">x</code></td>
<td>
<p> object of class &quot;pointPairs&quot;, obtained from the function 
<a href="#topic+plot.variogramCloud">plot.variogramCloud</a>, containing point pair indices </p>
</td></tr>
<tr><td><code id="plot.pointPairs_+3A_data">data</code></td>
<td>
<p> data frame to which the indices refer (from which the
variogram cloud was calculated) </p>
</td></tr>
<tr><td><code id="plot.pointPairs_+3A_xcol">xcol</code></td>
<td>
<p> numeric vector with x-coordinates of data </p>
</td></tr>
<tr><td><code id="plot.pointPairs_+3A_ycol">ycol</code></td>
<td>
<p> numeric vector with y-coordinates of data </p>
</td></tr>
<tr><td><code id="plot.pointPairs_+3A_xlab">xlab</code></td>
<td>
<p> x-axis label </p>
</td></tr>
<tr><td><code id="plot.pointPairs_+3A_ylab">ylab</code></td>
<td>
<p> y-axis label </p>
</td></tr>
<tr><td><code id="plot.pointPairs_+3A_col.line">col.line</code></td>
<td>
<p> color for lines connecting points </p>
</td></tr>
<tr><td><code id="plot.pointPairs_+3A_line.pch">line.pch</code></td>
<td>
<p> if non-zero, symbols are also plotted at the middle of
line segments, to mark lines too short to be visible on the plot;
the color used is <code>col.line</code>; the value passed to this argument
will be used as plotting symbol (pch) </p>
</td></tr>
<tr><td><code id="plot.pointPairs_+3A_main">main</code></td>
<td>
<p> title of plot </p>
</td></tr>
<tr><td><code id="plot.pointPairs_+3A_...">...</code></td>
<td>
<p> arguments, further passed to <code>xyplot</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>plots the data locations, with lines connecting the point pairs identified
(and refered to by indices in) x
</p>


<h3>Author(s)</h3>

<p> Edzer Pebesma </p>


<h3>References</h3>

 <p><a href="http://www.gstat.org">http://www.gstat.org</a></p>


<h3>See Also</h3>

<p><a href="#topic+plot.variogramCloud">plot.variogramCloud</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### The following requires interaction, and is therefore outcommented
#data(meuse)
#coordinates(meuse) = ~x+y
#vgm1 &lt;- variogram(log(zinc)~1, meuse, cloud = TRUE)
#pp &lt;- plot(vgm1, id = TRUE)
### Identify the point pairs
#plot(pp, data = meuse) # meuse has x and y as coordinates
</code></pre>

<hr>
<h2 id='plot.variogramCloud'>
Plot and Identify Data Pairs on Sample Variogram Cloud
</h2><span id='topic+plot.variogramCloud'></span>

<h3>Description</h3>

<p>Plot a sample variogram cloud, possibly with identification of
individual point pairs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'variogramCloud'
plot(x, identify = FALSE, digitize = FALSE, xlim, ylim, xlab, ylab, 
	keep = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.variogramCloud_+3A_x">x</code></td>
<td>
<p> object of class <code>variogramCloud</code></p>
</td></tr>
<tr><td><code id="plot.variogramCloud_+3A_identify">identify</code></td>
<td>
<p> logical; if TRUE, the plot allows identification of
a series of individual point pairs that correspond to individual variogram
cloud points (use left mouse button to select; right mouse button ends) </p>
</td></tr>
<tr><td><code id="plot.variogramCloud_+3A_digitize">digitize</code></td>
<td>
<p> logical; if TRUE, select point pairs by digitizing a
region with the mouse (left mouse button adds a point, right mouse button
ends) </p>
</td></tr>
<tr><td><code id="plot.variogramCloud_+3A_xlim">xlim</code></td>
<td>
<p> limits of x-axis </p>
</td></tr>
<tr><td><code id="plot.variogramCloud_+3A_ylim">ylim</code></td>
<td>
<p> limits of y-axis </p>
</td></tr>
<tr><td><code id="plot.variogramCloud_+3A_xlab">xlab</code></td>
<td>
<p> x axis label </p>
</td></tr>
<tr><td><code id="plot.variogramCloud_+3A_ylab">ylab</code></td>
<td>
<p> y axis label </p>
</td></tr>
<tr><td><code id="plot.variogramCloud_+3A_keep">keep</code></td>
<td>
<p> logical; if TRUE and <code>identify</code> is TRUE, the labels
identified and their position are kept and glued to object x, which is
returned. Subsequent calls to plot this object will now have the labels
shown, e.g. to plot to hardcopy </p>
</td></tr>
<tr><td><code id="plot.variogramCloud_+3A_...">...</code></td>
<td>
<p> parameters that are passed through to <a href="#topic+plot.gstatVariogram">plot.gstatVariogram</a>
(in case of identify = FALSE) or to plot (in case of identify = TRUE) </p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>identify</code> or <code>digitize</code> is TRUE, a data frame of class
<code>pointPairs</code> with in its rows the point pairs identified (pairs of
row numbers in the original data set); if identify is F, a plot of the
variogram cloud, which uses <a href="#topic+plot.gstatVariogram">plot.gstatVariogram</a>
</p>
<p>If in addition to <code>identify</code>, <code>keep</code> is also TRUE, an object
of class <code>variogramCloud</code> is returned, having attached to it attributes
&quot;sel&quot; and &quot;text&quot;, which will be used in subsequent calls to plot.variogramCloud
with <code>identify</code> set to FALSE, to plot the text previously identified.
</p>
<p>If in addition to <code>digitize</code>, <code>keep</code> is also TRUE, an object of
class <code>variogramCloud</code> is returned, having attached to it attribute
&quot;poly&quot;, which will be used in subsequent calls to plot.variogramCloud
with <code>digitize</code> set to FALSE, to plot the digitized line.
</p>
<p>In both of the <code>keep = TRUE</code> cases, the attribute <code>ppairs</code> of
class <code>pointPairs</code> is present, containing the point pairs identified.
</p>


<h3>Author(s)</h3>

<p> Edzer Pebesma </p>


<h3>References</h3>

 
<p><a href="http://www.gstat.org/">http://www.gstat.org/</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+variogram">variogram</a>,
<a href="#topic+plot.gstatVariogram">plot.gstatVariogram</a>,
<a href="#topic+plot.pointPairs">plot.pointPairs</a>,
<a href="graphics.html#topic+identify">identify</a>,
<a href="graphics.html#topic+locator">locator</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sp)
data(meuse)
coordinates(meuse) = ~x+y
plot(variogram(log(zinc)~1, meuse, cloud=TRUE))
## commands that require interaction:
# x &lt;- variogram(log(zinc)~1, loc=~x+y, data=meuse, cloud=TRUE)
# plot(plot(x, identify = TRUE), meuse)
# plot(plot(x, digitize = TRUE), meuse)
</code></pre>

<hr>
<h2 id='predict'> Multivariable Geostatistical Prediction and Simulation </h2><span id='topic+predict'></span><span id='topic+predict.gstat'></span>

<h3>Description</h3>

<p> The function provides the following prediction methods:
simple, ordinary, and universal kriging, simple, ordinary, and universal
cokriging, point- or block-kriging, and conditional simulation equivalents
for each of the kriging methods.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gstat'
predict(object, newdata, block = numeric(0), nsim = 0, 
	indicators = FALSE, BLUE = FALSE, debug.level = 1, mask, 
	na.action = na.pass, sps.args = list(n = 500, type = "regular",
	offset = c(.5, .5)), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_+3A_object">object</code></td>
<td>
<p> object of class <code>gstat</code>, see <a href="#topic+gstat">gstat</a> and
<a href="#topic+krige">krige</a></p>
</td></tr>
<tr><td><code id="predict_+3A_newdata">newdata</code></td>
<td>
<p> data frame with prediction/simulation locations; should 
contain columns with the independent variables (if present) and the
coordinates with names as defined in <code>locations</code>; or: polygons, 
see below</p>
</td></tr>
<tr><td><code id="predict_+3A_block">block</code></td>
<td>
<p> block size; a vector with 1, 2 or 3 values containing
the size of a rectangular in x-, y- and z-dimension respectively
(0 if not set), or a data frame with 1, 2 or 3 columns, containing
the points that discretize the block in the x-, y- and z-dimension
to define irregular blocks relative to (0,0) or (0,0,0)&mdash;see also
the details section below. By default, predictions
or simulations refer to the support of the data values. </p>
</td></tr>
<tr><td><code id="predict_+3A_nsim">nsim</code></td>
<td>
<p> integer; if set to a non-zero value, conditional simulation
is used instead of kriging interpolation. For this, sequential Gaussian
or indicator simulation is used (depending on the value of 
<code>indicators</code>), following a single random path through the data.  </p>
</td></tr>
<tr><td><code id="predict_+3A_indicators">indicators</code></td>
<td>
<p> logical; only relevant if <code>nsim</code> is non-zero; if
TRUE, use indicator simulation, else use Gaussian simulation </p>
</td></tr>
<tr><td><code id="predict_+3A_blue">BLUE</code></td>
<td>
<p> logical; if TRUE return the BLUE trend estimates only, 
if FALSE return the BLUP predictions (kriging) </p>
</td></tr>
<tr><td><code id="predict_+3A_debug.level">debug.level</code></td>
<td>
<p> integer; set gstat internal debug level, see below
for useful values. If set to -1 (or any negative value), a progress counter
is printed </p>
</td></tr>
<tr><td><code id="predict_+3A_mask">mask</code></td>
<td>
<p> not supported anymore &ndash; use na.action; 
logical or numerical vector; pattern with valid values
in newdata (marked as TRUE, non-zero, or non-NA); if mask is specified,
the returned data frame will have the same number and order of rows 
in newdata, and masked rows will be filled with NA's. </p>
</td></tr>
<tr><td><code id="predict_+3A_na.action">na.action</code></td>
<td>
<p> function determining what should be done with missing
values in 'newdata'.  The default is to predict 'NA'.  Missing values 
in coordinates and predictors are both dealt with. </p>
</td></tr>
<tr><td><code id="predict_+3A_sps.args">sps.args</code></td>
<td>
<p> when newdata is of class <code>SpatialPolygons</code> 
or <code>SpatialPolygonsDataFrame</code> this
argument list gets passed to <a href="sp.html#topic+spsample">spsample</a> to
control the discretizing of polygons </p>
</td></tr>
<tr><td><code id="predict_+3A_...">...</code></td>
<td>
<p> ignored (but necessary for the S3 generic/method consistency) </p>
</td></tr>
</table>


<h3>Details</h3>

<p> When a non-stationary (i.e., non-constant) mean is used, both
for simulation and prediction purposes the variogram model defined should
be that of the residual process, not that of the raw observations.
</p>
<p>For irregular block kriging, coordinates should discretize the area
relative to (0), (0,0) or (0,0,0); the coordinates in newdata should give
the centroids around which the block should be located. So, suppose the
block is discretized by points (3,3) (3,5) (5,5) and (5,3), we should
pass point (4,4) in newdata and pass points (-1,-1) (-1,1) (1,1) (1,-1)
to the block argument. Although passing the uncentered block and (0,0)
as newdata may work for global neighbourhoods, neighbourhood selection
is always done relative to the centroid values in newdata.
</p>
<p>If newdata is of class <a href="sp.html#topic+SpatialPolygons">SpatialPolygons</a>  or
<a href="sp.html#topic+SpatialPolygonsDataFrame">SpatialPolygonsDataFrame</a>, then the block
average for each of the polygons or polygon sets is
calculated, using <a href="sp.html#topic+spsample">spsample</a> to discretize the
polygon(s). Argument <code>sps.args</code> controls the parameters
used for <a href="sp.html#topic+spsample">spsample</a>. The &quot;location&quot; with respect to
which neighbourhood selection is done is for each polygon the
SpatialPolygons polygon label point; if you use local neighbourhoods
you should check out where these points are&mdash;it may be well
outside the polygon itself.
</p>
<p>The algorithm used by gstat for simulation random fields is the
sequential simulation algorithm. This algorithm scales well to large or
very large fields (e.g., more than $10^6$ nodes). Its power lies in using
only data and simulated values in a local neighbourhood to approximate the
conditional distribution at that location, see <code>nmax</code> in <a href="#topic+krige">krige</a>
and <a href="#topic+gstat">gstat</a>. The larger <code>nmax</code>, the better the approximation,
the smaller <code>nmax</code>, the faster the simulation process. For selecting
the nearest <code>nmax</code> data or previously simulated points, gstat uses
a bucket PR quadtree neighbourhood search algorithm; see the reference
below.
</p>
<p>For sequential Gaussian or indicator simulations, a random path through
the simulation locations is taken, which is usually done for sequential
simulations. The reason for this is that the local approximation of the
conditional distribution, using only the <code>nmax</code> neareast observed
(or simulated) values may cause spurious correlations when a regular
path would be followed. Following a single path through the locations,
gstat reuses the expensive results (neighbourhood selection and solution
to the kriging equations) for each of the subsequent simulations when
multiple realisations are requested.  You may expect a considerable speed
gain in simulating 1000 fields in a single call to <a href="#topic+predict">predict</a>,
compared to 1000 calls, each for simulating a single field.
</p>
<p>The random number generator used for generating simulations is the native
random number generator of the environment (R, S); fixing randomness by
setting the random number seed with <code>set.seed()</code> works.
</p>
<p>When mean coefficient are not supplied, they are generated as well
from their conditional distribution (assuming multivariate normal,
using the generalized least squares BLUE estimate and its estimation
covariance); for a reference to the algorithm used see Abrahamsen and
Benth, Math. Geol. 33(6), page 742 and leave out all constraints.
</p>
<p>Memory requirements for sequential simulation: let n be the product of
the number of variables, the number of simulation locations, and the
number of simulations required in a single call.  the gstat C function
<code>gstat_predict</code> requires a table of size n * 12 bytes to pass the
simulations back to R, before it can free n * 4 bytes. Hopefully, R does
not have to duplicate the remaining n * 8 bytes when the coordinates
are added as columns, and when the resulting matrix is coerced to
a <code>data.frame</code>.
</p>
<p>Useful values for <code>debug.level</code>: 0: suppres any output except
warning and error messages; 1: normal output (default): short data report,
program action and mode, program progress in %, total execution time;
2: print the value of all global variables, all files read and written,
and include source file name and line number in error messages; 4: print
OLS and WLS fit diagnostics; 8: print all data after reading them; 16:
print the neighbourhood selection for each prediction location; 32:
print (generalised) covariance matrices, design matrices, solutions,
kriging weights, etc.; 64: print variogram fit diagnostics (number
of iterations and variogram model in each iteration step) and order
relation violations (indicator kriging values before and after order
relation correction); 512: print block (or area) discretization data
for each prediction location. To combine settings, sum their respective
values. Negative values for <code>debug.level</code> are equal to positive,
but cause the progress counter to work.
</p>
<p>For data with longitude/latitude coordinates (checked by
<code>is.projected</code>), gstat uses great circle distances in km to compute
spatial distances. The user should make sure that the semivariogram
model used is positive definite on a sphere.
</p>


<h3>Value</h3>

<p>a data frame containing the coordinates of <code>newdata</code>, and columns
of prediction and prediction variance (in case of kriging) or the
columns of the conditional Gaussian or indicator simulations 
</p>


<h3>Author(s)</h3>

<p> Edzer Pebesma </p>


<h3>References</h3>

 
<p>N.A.C. Cressie, 1993, Statistics for Spatial Data, Wiley. 
</p>
<p>Pebesma, E.J., 2004. Multivariable geostatistics in S: the gstat package.
Computers and Geosciences, 30: 683-691.
</p>


<h3>See Also</h3>

<p><a href="#topic+gstat">gstat</a>, <a href="#topic+krige">krige</a></p>


<h3>Examples</h3>

<pre><code class='language-R'># generate 5 conditional simulations
library(sp)
data(meuse)
coordinates(meuse) = ~x+y
v &lt;- variogram(log(zinc)~1, meuse)
m &lt;- fit.variogram(v, vgm(1, "Sph", 300, 1))
plot(v, model = m)
set.seed(131)
data(meuse.grid)
gridded(meuse.grid) = ~x+y
sim &lt;- krige(formula = log(zinc)~1, meuse, meuse.grid, model = m, 
	nmax = 10, beta = 5.9, nsim = 5) # for speed -- 10 is too small!!
# show all 5 simulation
spplot(sim)

# calculate generalised least squares residuals w.r.t. constant trend:
g &lt;- gstat(NULL, "log.zinc", log(zinc)~1, meuse, model = m)
blue0 &lt;- predict(g, newdata = meuse, BLUE = TRUE)
blue0$blue.res &lt;- log(meuse$zinc) - blue0$log.zinc.pred
bubble(blue0, zcol = "blue.res", main = "GLS residuals w.r.t. constant")

# calculate generalised least squares residuals w.r.t. linear trend:
m &lt;- fit.variogram(variogram(log(zinc)~sqrt(dist.m), meuse), 
	vgm(1, "Sph", 300, 1))
g &lt;- gstat(NULL, "log.zinc", log(zinc)~sqrt(dist.m), meuse, model = m)
blue1 &lt;- predict(g, meuse, BLUE = TRUE)
blue1$blue.res &lt;- log(meuse$zinc) - blue1$log.zinc.pred
bubble(blue1, zcol = "blue.res", 
	main = "GLS residuals w.r.t. linear trend")

# unconditional simulation on a 100 x 100 grid
xy &lt;- expand.grid(1:100, 1:100)
names(xy) &lt;- c("x","y")
gridded(xy) = ~x+y
g.dummy &lt;- gstat(formula = z~1, dummy = TRUE, beta = 0,
	model = vgm(1,"Exp",15), nmax = 10) # for speed -- 10 is too small!!
yy &lt;- predict(g.dummy, xy, nsim = 4)
# show one realisation:
spplot(yy[1])
# show all four:
spplot(yy)

</code></pre>

<hr>
<h2 id='progress'> Get or set progress indicator </h2><span id='topic+get_gstat_progress'></span><span id='topic+set_gstat_progress'></span>

<h3>Description</h3>

<p> Get or set progress indicator </p>


<h3>Usage</h3>

<pre><code class='language-R'>get_gstat_progress()
set_gstat_progress(value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="progress_+3A_value">value</code></td>
<td>
<p> logical </p>
</td></tr>
</table>


<h3>Value</h3>

<p>return the logical value indicating whether progress bars should be given
</p>


<h3>Author(s)</h3>

<p> Edzer Pebesma </p>


<h3>Examples</h3>

<pre><code class='language-R'>set_gstat_progress(FALSE)
get_gstat_progress()
</code></pre>

<hr>
<h2 id='show.vgms'>
Plot Variogram Model Functions
</h2><span id='topic+show.vgms'></span>

<h3>Description</h3>

<p>Creates a trellis plot for a range of variogram models, possibly with nugget;
and optionally a set of Matern models with varying smoothness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show.vgms(min = 1e-12 * max, max = 3, n = 50, sill = 1, range = 1,
    models = as.character(vgm()$short[c(1:17)]), nugget = 0, kappa.range = 0.5,
	plot = TRUE, ..., as.groups = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show.vgms_+3A_min">min</code></td>
<td>
<p> numeric; start distance value for semivariance calculation 
beyond the first point at exactly zero  </p>
</td></tr>
<tr><td><code id="show.vgms_+3A_max">max</code></td>
<td>
<p> numeric; maximum distance for semivariance calculation 
and plotting </p>
</td></tr>
<tr><td><code id="show.vgms_+3A_n">n</code></td>
<td>
<p> integer; number of points to calculate distance values </p>
</td></tr>
<tr><td><code id="show.vgms_+3A_sill">sill</code></td>
<td>
<p> numeric; (partial) sill(s) of the variogram model </p>
</td></tr>
<tr><td><code id="show.vgms_+3A_range">range</code></td>
<td>
<p> numeric; range(s) of the variogram model </p>
</td></tr>
<tr><td><code id="show.vgms_+3A_models">models</code></td>
<td>
<p> character; variogram model(s) to be plotted </p>
</td></tr>
<tr><td><code id="show.vgms_+3A_nugget">nugget</code></td>
<td>
<p> numeric; nugget component(s) for variogram models </p>
</td></tr>
<tr><td><code id="show.vgms_+3A_kappa.range">kappa.range</code></td>
<td>
<p> numeric; if this is a vector with more than one
element, only a range of Matern models is plotted with these kappa 
values </p>
</td></tr>
<tr><td><code id="show.vgms_+3A_plot">plot</code></td>
<td>
<p> logical; if TRUE, a plot is returned with the models
specified; if FALSE, the data prepared for this plot is returned </p>
</td></tr>
<tr><td><code id="show.vgms_+3A_...">...</code></td>
<td>
<p> passed on to the call to xyplot </p>
</td></tr>
<tr><td><code id="show.vgms_+3A_as.groups">as.groups</code></td>
<td>
<p> logical; if TRUE, different models are plotted with
different lines in a single panel, else, in one panel per model </p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a (Trellis) plot of the variogram models requested; see
examples. I do currently have strong doubts about the &ldquo;correctness&rdquo;
of the &ldquo;Hol&rdquo; model. The &ldquo;Spl&rdquo; model does seem to need a very
large range value (larger than the study area?) to be of some value.
</p>
<p>If plot is FALSE, a data frame with the data prepared to plot
is being returned.
</p>


<h3>Note</h3>

<p> the <code>min</code> argument is supplied because the variogram
function may be discontinuous at distance zero, surely when a positive
nugget is present. </p>


<h3>Author(s)</h3>

<p> Edzer Pebesma </p>


<h3>References</h3>

 <p><a href="http://www.gstat.org">http://www.gstat.org</a></p>


<h3>See Also</h3>

<p><a href="#topic+vgm">vgm</a>, <a href="#topic+variogramLine">variogramLine</a>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>show.vgms()
show.vgms(models = c("Exp", "Mat", "Gau"), nugget = 0.1)
# show a set of Matern models with different smoothness:
show.vgms(kappa.range = c(.1, .2, .5, 1, 2, 5, 10), max = 10)
# show a set of Exponential class models with different shape parameter:
show.vgms(kappa.range = c(.05, .1, .2, .5, 1, 1.5, 1.8, 1.9, 2), models = "Exc", max = 10)
# show a set of models with different shape parameter of M. Stein's representation of the Matern:
show.vgms(kappa.range = c(.01, .02, .05, .1, .2, .5, 1, 2, 5, 1000), models = "Ste", max = 2)

</code></pre>

<hr>
<h2 id='sic2004'> Spatial Interpolation Comparison 2004 data set: Natural Ambient Radioactivity </h2><span id='topic+sic2004'></span><span id='topic+sic.train'></span><span id='topic+sic.pred'></span><span id='topic+sic.grid'></span><span id='topic+sic.test'></span><span id='topic+sic.val'></span>

<h3>Description</h3>

<p> The text below was copied from the original sic2004
event, which is no longer online available.
</p>
<p>The variable used in the SIC 2004 exercise is natural ambient
radioactivity measured in Germany. The data, provided kindly by the
German Federal Office for Radiation Protection (BfS), are gamma dose rates
reported by means of the national automatic monitoring network (IMIS).
</p>
<p>In the frame of SIC2004,  a rectangular area was used to select 1008
monitoring stations (from a total of around 2000 stations). For these
1008 stations, 11 days of measurements have been randomly selected during
the last 12 months and the average daily dose rates calculated for each
day. Hence, we ended up having 11 data sets.
</p>
<p>Prior information (sic.train): 10 data sets of 200 points that are
identical for what concerns the locations of the monitoring stations
have been prepared. These locations have been randomly selected (see
Figure 1). These data sets differ only by their Z values since each set
corresponds to 1 day of measurement made during the last 14 months. No
information will be provided on the date of measurement.  These 10 data
sets (10 days of measurements) can be used as prior information to tune
the parameters of the mapping algorithms. No other information will be
provided about these sets. Participants are free of course to gather
more information about the variable in the literature and so on.
</p>
<p>The 200 monitoring stations above were randomly taken from a larger set
of 1008 stations. The remaining 808 monitoring stations have a topology
given in sic.pred.  Participants to SIC2004 will have to estimate the
values of the variable taken at these 808 locations.  
</p>
<p>The SIC2004 data (sic.val, variable dayx):
The exercise consists in using 200 measurements made on a 11th day (THE
data of the exercise) to estimate the values observed at the remaining
808 locations (hence the question marks as symbols in the maps shown
in Figure 3). These measurements will be provided only during two weeks
(15th of September until 1st of October 2004) on a web page restricted
to the participants. The true values observed at these 808 locations
will be released only at the end of the exercise to allow participants
to write their manuscripts (sic.test, variables dayx and joker).
</p>
<p>In addition, a joker data set was released (sic.val, variable joker),
which contains an anomaly. The anomaly was generated by a simulation
model, and does not represent measured levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sic2004) # 
</code></pre>


<h3>Format</h3>

<p>The data frames contain the following columns:
</p>

<dl>
<dt>record</dt><dd><p>this integer value is the number (unique value) of
the monitoring station chosen by us.</p>
</dd>
<dt>x</dt><dd><p>X-coordinate of the monitoring station indicated in meters</p>
</dd>
<dt>y</dt><dd><p>Y-coordinate of the monitoring station indicated in meters</p>
</dd>
<dt>day01</dt><dd><p>mean gamma dose rate measured during 24 hours, at day01. Units
are nanoSieverts/hour</p>
</dd>
<dt>day02</dt><dd><p>same, for day 02</p>
</dd>
<dt>day03</dt><dd><p>...</p>
</dd>
<dt>day04</dt><dd><p>...</p>
</dd>
<dt>day05</dt><dd><p>...</p>
</dd>
<dt>day06</dt><dd><p>...</p>
</dd>
<dt>day07</dt><dd><p>...</p>
</dd>
<dt>day08</dt><dd><p>...</p>
</dd>
<dt>day09</dt><dd><p>...</p>
</dd>
<dt>day10</dt><dd><p>...</p>
</dd>
<dt>dayx</dt><dd><p> the data observed at the 11-th day</p>
</dd>
<dt>joker</dt><dd><p> the joker data set, containing an anomaly not present
in the training data</p>
</dd>
</dl>



<h3>Note</h3>

<p>the data set sic.grid provides a set of points on a regular grid (almost
10000 points) covering the area; this is convenient for interpolation;
see the function <code>makegrid</code> in package sp.
</p>
<p>The coordinates have been projected around a point located in the
South West of Germany. Hence, a few coordinates have negative values as
can be guessed from the Figures below.
</p>


<h3>Author(s)</h3>

 
<p>Data: the German Federal Office for Radiation Protection (BfS),
<a href="https://www.bfs.de/EN/home/home_node.html">https://www.bfs.de/EN/home/home_node.html</a>, 
data provided by Gregoire Dubois, R compilation
by Edzer Pebesma.  </p>


<h3>References</h3>

<p><a href="https://wiki.52north.org/bin/view/AI_GEOSTATS/WebHome">https://wiki.52north.org/bin/view/AI_GEOSTATS/WebHome</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sic2004) 
# FIGURE 1. Locations of the 200 monitoring stations for the 11 data sets. 
# The values taken by the variable are known.
plot(y~x,sic.train,pch=1,col="red", asp=1)

# FIGURE 2. Locations of the 808 remaining monitoring stations at which 
# the values of the variable must be estimated.
plot(y~x,sic.pred,pch="?", asp=1, cex=.8) # Figure 2

# FIGURE 3. Locations of the 1008 monitoring stations (exhaustive data sets). 
# Red circles are used to estimate values located at the questions marks
plot(y~x,sic.train,pch=1,col="red", asp=1)
points(y~x, sic.pred, pch="?", cex=.8)

</code></pre>

<hr>
<h2 id='sic97'> Spatial Interpolation Comparison 1997 data set: Swiss Rainfall</h2><span id='topic+sic_obs'></span><span id='topic+sic_full'></span><span id='topic+demstd'></span>

<h3>Description</h3>

<p>The text below is copied from the data item at ai-geostats,
<a href="https://wiki.52north.org/bin/view/AI_GEOSTATS/WebHome">https://wiki.52north.org/bin/view/AI_GEOSTATS/WebHome</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sic97) # 
</code></pre>


<h3>Format</h3>

<p>The data frames contain the following columns:
</p>

<dl>
<dt>ID</dt><dd><p>this integer value is the number (unique value) of
the monitoring station</p>
</dd>
<dt>rainfall</dt><dd><p> rainfall amount, in 10th of mm </p>
</dd>
</dl>



<h3>Note</h3>

<p>See the pdf that accompanies the original file for a description of the data.
The .dxf file with the Swiss border is not included here.
</p>


<h3>Author(s)</h3>

 
<p>Gregoire Dubois and others.
</p>


<h3>References</h3>

 <p><a href="https://wiki.52north.org/bin/view/AI_GEOSTATS/WebHome">https://wiki.52north.org/bin/view/AI_GEOSTATS/WebHome</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sic97) 
image(demstd)
points(sic_full, pch=1)
points(sic_obs, pch=3)
</code></pre>

<hr>
<h2 id='spplot.vcov'> Plot map matrix of prediction error variances and covariances </h2><span id='topic+spplot.vcov'></span>

<h3>Description</h3>

<p>Plot map matrix of prediction error variances and covariances
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spplot.vcov(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spplot.vcov_+3A_x">x</code></td>
<td>
<p> Object of class SpatialPixelsDataFrame or SpatialGridDataFrame,
resulting from a krige call with multiple variables (cokriging </p>
</td></tr>
<tr><td><code id="spplot.vcov_+3A_...">...</code></td>
<td>
<p>remaining arguments passed to spplot </p>
</td></tr>
</table>


<h3>Value</h3>

<p> The plotted object, of class trellis; see <code>spplot</code> in
package <span class="pkg">sp</span>. </p>


<h3>Author(s)</h3>

<p> Edzer Pebesma </p>

<hr>
<h2 id='tull'>SÃ¼dliche Tullnerfeld data set</h2><span id='topic+tull'></span><span id='topic+TULLNREG'></span><span id='topic+tull36'></span><span id='topic+Chlorid92'></span>

<h3>Description</h3>

<p>The SÃ¼dliche Tullnerfeld is a part of the Danube river basin in
central Lower Austria and due to its homogeneous aquifer well suited
for a model-oriented geostatistical analysis. It contains 36 official
water quality measurement stations, which are irregularly spread over the
region. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(tull)
</code></pre>


<h3>Format</h3>

<p>The data frames contain the following columns:
</p>

<dl>
<dt>x</dt><dd><p>X location in meter</p>
</dd>
<dt>y</dt><dd><p>Y location in meter</p>
</dd>
<dt>S411</dt><dd><p>Station name</p>
</dd>
<dt>S429</dt><dd><p>Station name</p>
</dd>
<dt>S849</dt><dd><p>Station name</p>
</dd>
<dt>S854</dt><dd><p>Station name</p>
</dd>
<dt>S1502</dt><dd><p>Station name</p>
</dd>
<dt>S1584</dt><dd><p>Station name</p>
</dd>
<dt>S1591</dt><dd><p>Station name</p>
</dd>
<dt>S2046</dt><dd><p>Station name</p>
</dd>
<dt>S2047</dt><dd><p>Station name</p>
</dd>
<dt>S2048</dt><dd><p>Station name</p>
</dd>
<dt>S2049</dt><dd><p>Station name</p>
</dd>
<dt>S2051</dt><dd><p>Station name</p>
</dd>
<dt>S2052</dt><dd><p>Station name</p>
</dd>
<dt>S2053</dt><dd><p>Station name</p>
</dd>
<dt>S2054</dt><dd><p>Station name</p>
</dd>
<dt>S2055</dt><dd><p>Station name</p>
</dd>
<dt>S2057</dt><dd><p>Station name</p>
</dd>
<dt>S2058</dt><dd><p>Station name</p>
</dd>
<dt>S2059</dt><dd><p>Station name</p>
</dd>
<dt>S2060</dt><dd><p>Station name</p>
</dd>
<dt>S2061</dt><dd><p>Station name</p>
</dd>
<dt>S2062</dt><dd><p>Station name</p>
</dd>
<dt>S2063</dt><dd><p>Station name</p>
</dd>
<dt>S2064</dt><dd><p>Station name</p>
</dd>
<dt>S2065</dt><dd><p>Station name</p>
</dd>
<dt>S2066</dt><dd><p>Station name</p>
</dd>
<dt>S2067</dt><dd><p>Station name</p>
</dd>
<dt>S2070</dt><dd><p>Station name</p>
</dd>
<dt>S2071</dt><dd><p>Station name</p>
</dd>
<dt>S2072</dt><dd><p>Station name</p>
</dd>
<dt>S2128</dt><dd><p>Station name</p>
</dd>
<dt>S5319</dt><dd><p>Station name</p>
</dd>
<dt>S5320</dt><dd><p>Station name</p>
</dd>
<dt>S5321</dt><dd><p>Station name</p>
</dd>
<dt>S5322</dt><dd><p>Station name</p>
</dd>
<dt>S5323</dt><dd><p>Station name</p>
</dd>
</dl>



<h3>Note</h3>

<p>This data set was obtained on May 6, 2008 from
<a href="http://www.ifas.jku.at/e5361/index_ger.html">http://www.ifas.jku.at/e5361/index_ger.html</a>.
The author of the book that uses it is found at:
<a href="http://www.ifas.jku.at/e2571/e2604/index_ger.html">http://www.ifas.jku.at/e2571/e2604/index_ger.html</a>
</p>


<h3>References</h3>

 
<p>Werner G. MÃ¼ller, Collecting Spatial Data, 3rd edition.
Springer Verlag, Heidelberg, 2007
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tull)

# TULLNREG = read.csv("TULLNREG.csv")

# I modified tulln36des.csv, such that the first line only contained: x,y
# resulting in row.names that reflect the station ID, as in
# tull36 = read.csv("tulln36des.csv")

# Chlorid92 was read &amp; converted by:
#Chlorid92=read.csv("Chlorid92.csv")
#Chlorid92$Datum = as.POSIXct(strptime(Chlorid92$Datum, "%d.%m.%y"))

summary(tull36)
summary(TULLNREG)
summary(Chlorid92)

# stack &amp; join data to x,y,Date,Chloride form:
cl.st = stack(Chlorid92[-1])
names(cl.st) = c("Chloride", "Station")
cl.st$Date = rep(Chlorid92$Datum, length(names(Chlorid92))-1)
cl.st$x = tull36[match(cl.st[,"Station"], row.names(tull36)), "x"]
cl.st$y = tull36[match(cl.st[,"Station"], row.names(tull36)), "y"]
# library(lattice)
# xyplot(Chloride~Date|Station, cl.st)
# xyplot(y~x|Date, cl.st, asp="iso", layout=c(16,11))
summary(cl.st)
plot(TULLNREG, pch=3, asp=1)
points(y~x, cl.st, pch=16)
</code></pre>

<hr>
<h2 id='variogram'> Calculate Sample or Residual Variogram or Variogram Cloud </h2><span id='topic+variogram'></span><span id='topic+variogram.gstat'></span><span id='topic+variogram.formula'></span><span id='topic+variogram.default'></span><span id='topic+print.gstatVariogram'></span><span id='topic+print.variogramCloud'></span><span id='topic+as.data.frame.variogramCloud'></span>

<h3>Description</h3>

<p>Calculates the sample variogram from data, or in case of a linear model
is given, for the residuals, with options for directional, robust,
and pooled variogram, and for irregular distance intervals.
</p>
<p>In case spatio-temporal data is provided, the function <code><a href="#topic+variogramST">variogramST</a></code>
is called with a different set of parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gstat'
variogram(object, ...)
## S3 method for class 'formula'
variogram(object, locations = coordinates(data), data, ...)
## Default S3 method:
variogram(object, locations, X, cutoff, width = cutoff/15,
	alpha = 0, beta = 0, tol.hor = 90/length(alpha), tol.ver =
	90/length(beta), cressie = FALSE, dX = numeric(0), boundaries =
	numeric(0), cloud = FALSE, trend.beta = NULL, debug.level = 1,
	cross = TRUE, grid, map = FALSE, g = NULL, ..., projected = TRUE, 
	lambda = 1.0, verbose = FALSE, covariogram = FALSE, PR = FALSE, 
	pseudo = -1)
## S3 method for class 'gstatVariogram'
print(x, ...)
## S3 method for class 'variogramCloud'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variogram_+3A_object">object</code></td>
<td>
<p>object of class <code>gstat</code>; in this form, direct
and cross (residual) variograms are calculated for all variables and
variable pairs defined in <code>object</code>; in case of <code>variogram.formula</code>,
formula defining the response vector and (possible) 
regressors, in case of absence of regressors, use e.g. <code>z~1</code>;
in case of <code>variogram.default</code>: list with for each variable 
the vector with responses (should not be called directly)
</p>
</td></tr>
<tr><td><code id="variogram_+3A_data">data</code></td>
<td>
<p>data frame where the names in formula are to be found</p>
</td></tr>
<tr><td><code id="variogram_+3A_locations">locations</code></td>
<td>
<p> spatial data locations.  For variogram.formula: a
formula with only the coordinate variables in the right hand (explanatory
variable) side e.g. <code>~x+y</code>; see examples.
</p>
<p>For variogram.default: list with coordinate matrices, each with the number
of rows matching that of corresponding vectors in y; the number of columns
should match the number of spatial dimensions spanned by the data (1
(x), 2 (x,y) or 3 (x,y,z)).  </p>
</td></tr>
<tr><td><code id="variogram_+3A_...">...</code></td>
<td>
<p>any other arguments that will be passed to
<a href="#topic+variogram.default">variogram.default</a> (ignored)</p>
</td></tr>
<tr><td><code id="variogram_+3A_x">X</code></td>
<td>
<p> (optional) list with for each variable the matrix with
regressors/covariates; the number of rows should match that of the
correspoding element in y, the number of columns equals the number of
regressors (including intercept) </p>
</td></tr>
<tr><td><code id="variogram_+3A_cutoff">cutoff</code></td>
<td>
<p> spatial separation distance up to which point pairs
are included in semivariance estimates; as a default, the
length of the diagonal of the box spanning the data is divided by three. </p>
</td></tr>
<tr><td><code id="variogram_+3A_width">width</code></td>
<td>
<p> the width of subsequent distance intervals into which
data point pairs are grouped for semivariance estimates </p>
</td></tr>
<tr><td><code id="variogram_+3A_alpha">alpha</code></td>
<td>
<p> direction in  plane (x,y), in positive degrees clockwise
from positive y (North): alpha=0 for direction North (increasing y),
alpha=90 for direction East (increasing x); optional a vector of
directions in (x,y) </p>
</td></tr>
<tr><td><code id="variogram_+3A_beta">beta</code></td>
<td>
<p> direction in z, in positive degrees up from the (x,y) plane; </p>
</td></tr>
</table>
<p>optional a vector of directions
</p>
<table>
<tr><td><code id="variogram_+3A_tol.hor">tol.hor</code></td>
<td>
<p> horizontal tolerance angle in degrees </p>
</td></tr>
<tr><td><code id="variogram_+3A_tol.ver">tol.ver</code></td>
<td>
<p> vertical tolerance angle in degrees </p>
</td></tr>
<tr><td><code id="variogram_+3A_cressie">cressie</code></td>
<td>
<p> logical; if TRUE, use Cressie&rdquo;s robust variogram estimate;
if FALSE use the classical method of moments variogram estimate </p>
</td></tr>
<tr><td><code id="variogram_+3A_dx">dX</code></td>
<td>
<p> include a pair of data points $y(s_1),y(s_2)$ taken at
locations $s_1$ and $s_2$ for sample variogram calculation only when
$||x(s_1)-x(s_2)|| &lt; dX$ with and $x(s_i)$ the vector with regressors at
location $s_i$, and $||.||$ the 2-norm.  This allows pooled estimation of
within-strata variograms (use a factor variable as regressor, and dX=0.5),
or variograms of (near-)replicates in a linear model (addressing point
pairs having similar values for regressors variables) </p>
</td></tr>
<tr><td><code id="variogram_+3A_boundaries">boundaries</code></td>
<td>
<p> numerical vector with distance interval upper boundaries; 
values should be strictly increasing </p>
</td></tr>
<tr><td><code id="variogram_+3A_cloud">cloud</code></td>
<td>
<p> logical; if TRUE, calculate the semivariogram cloud </p>
</td></tr>
<tr><td><code id="variogram_+3A_trend.beta">trend.beta</code></td>
<td>
<p>vector with trend coefficients, in case they are
known. By default, trend coefficients are estimated from the data.</p>
</td></tr>
<tr><td><code id="variogram_+3A_debug.level">debug.level</code></td>
<td>
<p> integer; set gstat internal debug level </p>
</td></tr>
<tr><td><code id="variogram_+3A_cross">cross</code></td>
<td>
<p> logical or character; if FALSE, no cross variograms are computed
when object is of class <code>gstat</code> and has more than one variable; if
TRUE, all direct and cross variograms are computed; if
equal to &quot;ST&quot;, direct and cross variograms are computed for all pairs 
involving the first (non-time lagged) variable; if equal to &quot;ONLY&quot;,
only cross variograms are computed (no direct variograms). </p>
</td></tr>
<tr><td><code id="variogram_+3A_formula">formula</code></td>
<td>
<p>formula, specifying the dependent variable and possible covariates</p>
</td></tr>
<tr><td><code id="variogram_+3A_x">x</code></td>
<td>
<p> object of class <code>variogram</code> or <code>variogramCloud</code>
to be printed</p>
</td></tr>
<tr><td><code id="variogram_+3A_grid">grid</code></td>
<td>
<p> grid parameters, if data are gridded (not to be called
directly; this is filled automatically) </p>
</td></tr>
<tr><td><code id="variogram_+3A_map">map</code></td>
<td>
<p> logical; if TRUE, and <code>cutoff</code> and <code>width</code>
are given, a variogram map is returned. This requires package
sp. Alternatively, a map can be passed, of class SpatialDataFrameGrid
(see sp docs) </p>
</td></tr>
<tr><td><code id="variogram_+3A_g">g</code></td>
<td>
<p> NULL or object of class gstat; may be used to pass settable
parameters and/or variograms; see example </p>
</td></tr>
<tr><td><code id="variogram_+3A_projected">projected</code></td>
<td>
<p>logical; if FALSE, data are assumed to be unprojected,
meaning decimal longitude/latitude. For projected data, Euclidian
distances are computed, for unprojected great circle distances
(km). In <code>variogram.formula</code> or <code>variogram.gstat</code>, for data
deriving from class Spatial, projection is detected automatically using
<code>is.projected</code></p>
</td></tr>
<tr><td><code id="variogram_+3A_lambda">lambda</code></td>
<td>
<p>test feature; not working (yet)</p>
</td></tr>
<tr><td><code id="variogram_+3A_verbose">verbose</code></td>
<td>
<p>logical; print some progress indication</p>
</td></tr>
<tr><td><code id="variogram_+3A_pseudo">pseudo</code></td>
<td>
<p> integer; use pseudo cross variogram for computing
time-lagged spatial variograms? -1: find out from coordinates &ndash; if they
are equal then yes, else no; 0: no; 1: yes. </p>
</td></tr>
<tr><td><code id="variogram_+3A_covariogram">covariogram</code></td>
<td>
<p>logical; compute covariogram instead of variogram?</p>
</td></tr>
<tr><td><code id="variogram_+3A_pr">PR</code></td>
<td>
<p>logical; compute pairwise relative variogram (does NOT check
whether variable is strictly positive)</p>
</td></tr>
</table>


<h3>Value</h3>

<p> If map is TRUE (or a map is passed), a grid map is returned
containing the (cross) variogram map(s). See package sp.
</p>
<p>In other cases, an object of class &quot;gstatVariogram&quot; with the 
following fields:
</p>
<table>
<tr><td><code>np</code></td>
<td>
<p>the number of point pairs for this estimate; 
in case of a <code>variogramCloud</code> see below</p>
</td></tr>
<tr><td><code>dist</code></td>
<td>
<p>the average distance of all point pairs considered
for this estimate</p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p>the actual sample variogram estimate</p>
</td></tr>
<tr><td><code>dir.hor</code></td>
<td>
<p>the horizontal direction</p>
</td></tr>
<tr><td><code>dir.ver</code></td>
<td>
<p>the vertical direction</p>
</td></tr>
<tr><td><code>id</code></td>
<td>
<p>the combined id pair</p>
</td></tr>
</table>
<p>If cloud is TRUE: an object of class <code>variogramCloud</code>, with the field
<code>np</code> encoding the numbers of the point pair that contributed to a
variogram cloud estimate, as follows. The first point is found by 1 + the
integer division of np by the <code>.BigInt</code> attribute of the returned
object, the second point by 1 + the remainder of that division. 
<a href="#topic+as.data.frame.variogramCloud">as.data.frame.variogramCloud</a> returns no <code>np</code> field,
but does the decoding into:
</p>
<table>
<tr><td><code>left</code></td>
<td>
<p>for variogramCloud: data id (row number) of one of 
the data pair</p>
</td></tr>
<tr><td><code>right</code></td>
<td>
<p>for variogramCloud: data id (row number) of the other 
data in the pair</p>
</td></tr>
</table>
<p>In case of a spatio-temporal variogram is sought see <code><a href="#topic+variogramST">variogramST</a></code> 
for details.
</p>


<h3>Note</h3>

 <p><code>variogram.default</code> should not be called by users directly,
as it makes many assumptions about the organization of the data, that
are not fully documented (but of course, can be understood from reading
the source code of the other <code>variogram</code> methods) 
</p>
<p>Successfully setting <code>gridded() &lt;- TRUE</code> may trigger a branch that
will fail unless dx and dy are identical, and not merely similar
to within machine epsilon.  </p>


<h3>Note</h3>

<p><code>variogram.line</code> is DEPRECATED; it is and was never meant as a variogram
method, but works automatically as such by the R dispatch system. Use
variogramLine instead.
</p>


<h3>Author(s)</h3>

<p> Edzer Pebesma </p>


<h3>References</h3>

 
<p>Cressie, N.A.C., 1993, Statistics for Spatial Data, Wiley.
</p>
<p>Cressie, N., C. Wikle, 2011, Statistics for Spatio-temporal Data, Wiley.
</p>
<p><a href="http://www.gstat.org/">http://www.gstat.org/</a>
</p>
<p>Pebesma, E.J., 2004. Multivariable geostatistics in S: the gstat package.
Computers and Geosciences, 30: 683-691.
</p>


<h3>See Also</h3>

<p><a href="#topic+print.gstatVariogram">print.gstatVariogram</a>,
<a href="#topic+plot.gstatVariogram">plot.gstatVariogram</a>,
<a href="#topic+plot.variogramCloud">plot.variogramCloud</a>;
for variogram models: <a href="#topic+vgm">vgm</a>,
to fit a variogram model to a sample variogram: 
<a href="#topic+fit.variogram">fit.variogram</a>
<code><a href="#topic+variogramST">variogramST</a></code> for details on the spatio-temporal sample variogram.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sp)
data(meuse)
# no trend:
coordinates(meuse) = ~x+y
variogram(log(zinc)~1, meuse)
# residual variogram w.r.t. a linear trend:
variogram(log(zinc)~x+y, meuse)
# directional variogram:
variogram(log(zinc)~x+y, meuse, alpha=c(0,45,90,135))
variogram(log(zinc)~1, meuse, width=90, cutoff=1300)

# GLS residual variogram:
v = variogram(log(zinc)~x+y, meuse)
v.fit = fit.variogram(v, vgm(1, "Sph", 700, 1))
v.fit
set = list(gls=1)
v
g = gstat(NULL, "log-zinc", log(zinc)~x+y, meuse, model=v.fit, set = set)
variogram(g)

if (require(sf)) {
  proj4string(meuse) = CRS("+init=epsg:28992")
  meuse.ll = sf::st_transform(sf::st_as_sf(meuse), sf::st_crs("+proj=longlat +datum=WGS84"))
# variogram of unprojected data, using great-circle distances, returning km as units
  print(variogram(log(zinc) ~ 1, meuse.ll))
}

</code></pre>

<hr>
<h2 id='variogramLine'> Semivariance Values For a Given Variogram Model </h2><span id='topic+variogramLine'></span><span id='topic+getGammas'></span>

<h3>Description</h3>

<p> Generates a semivariance values given a variogram model </p>


<h3>Usage</h3>

<pre><code class='language-R'>variogramLine(object, maxdist, n = 200, min = 1.0e-6 * maxdist, 
	dir = c(1,0,0), covariance = FALSE, ..., dist_vector, debug.level = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variogramLine_+3A_object">object</code></td>
<td>
<p> variogram model for which we want semivariance function values </p>
</td></tr>
<tr><td><code id="variogramLine_+3A_maxdist">maxdist</code></td>
<td>
<p> maximum distance for which we want semivariance values </p>
</td></tr>
<tr><td><code id="variogramLine_+3A_n">n</code></td>
<td>
<p> number of points </p>
</td></tr>
<tr><td><code id="variogramLine_+3A_min">min</code></td>
<td>
<p> minimum distance; a value slightly larger than zero is usually
used to avoid the discontinuity at distance zero if a nugget component is
present </p>
</td></tr>
<tr><td><code id="variogramLine_+3A_dir">dir</code></td>
<td>
<p> direction vector: unit length vector pointing the direction in 
x (East-West), y (North-South) and z (Up-Down) </p>
</td></tr>
<tr><td><code id="variogramLine_+3A_covariance">covariance</code></td>
<td>
<p>logical; if TRUE return covariance values, otherwise
return semivariance values </p>
</td></tr>
<tr><td><code id="variogramLine_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="variogramLine_+3A_dist_vector">dist_vector</code></td>
<td>
<p>numeric vector or matrix with distance values</p>
</td></tr>
<tr><td><code id="variogramLine_+3A_debug.level">debug.level</code></td>
<td>
<p>gstat internal debug level</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame of dimension (<code>n</code> x 2), with columns distance and gamma
(semivariances or covariances), or in case <code>dist_vector</code> is a matrix, a
conforming matrix with semivariance/covariance values is returned.
</p>


<h3>Note</h3>

<p>variogramLine is used to generate data for plotting a variogram model.</p>


<h3>Author(s)</h3>

<p> Edzer Pebesma </p>


<h3>See Also</h3>

 <p><a href="#topic+plot.gstatVariogram">plot.gstatVariogram</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>variogramLine(vgm(5, "Exp", 10, 5), 10, 10)
# anisotropic variogram, plotted in E-W direction:
variogramLine(vgm(1, "Sph", 10, anis=c(0,0.5)), 10, 10)
# anisotropic variogram, plotted in N-S direction:
variogramLine(vgm(1, "Sph", 10, anis=c(0,0.5)), 10, 10, dir=c(0,1,0))
variogramLine(vgm(1, "Sph", 10, anis=c(0,0.5)), dir=c(0,1,0), dist_vector = 0.5)
variogramLine(vgm(1, "Sph", 10, anis=c(0,0.5)), dir=c(0,1,0), dist_vector = c(0, 0.5, 0.75))
</code></pre>

<hr>
<h2 id='variogramST'>Calculate Spatio-Temporal Sample Variogram</h2><span id='topic+variogramST'></span>

<h3>Description</h3>

<p>Calculates the sample variogram from spatio-temporal data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variogramST(formula, locations, data, ..., tlags = 0:15,  cutoff,
	width = cutoff/15, boundaries = seq(0, cutoff, width),
	progress = interactive(), pseudo = TRUE, assumeRegular = FALSE, 
	na.omit = FALSE, cores = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variogramST_+3A_formula">formula</code></td>
<td>
<p>formula, specifying the dependent variable.</p>
</td></tr>
<tr><td><code id="variogramST_+3A_locations">locations</code></td>
<td>
<p>A STFDF or STSDF containing the variable; kept for 
compatibility reasons with variogram, either <code>locations</code> or <code>data</code> 
must be provided.</p>
</td></tr>
<tr><td><code id="variogramST_+3A_data">data</code></td>
<td>
<p>A <code><a href="spacetime.html#topic+STFDF-class">STFDF</a></code>, <code><a href="spacetime.html#topic+STSDF-class">STSDF</a></code> or <code><a href="spacetime.html#topic+STIDF-class">STIDF</a></code> containing the variable.</p>
</td></tr>
<tr><td><code id="variogramST_+3A_...">...</code></td>
<td>
<p>any other arguments that will be passed to the underlying 
<code><a href="#topic+variogram">variogram</a></code> function. In case of using data of type <code><a href="spacetime.html#topic+STIDF-class">STIDF</a></code>, the argument <code>tunit</code> is recommended (and only used in the case of STIDF) to set the temporal unit of the <code>tlags</code>. Additionally, <code>twindow</code> can be passed to control the temporal window used for temporal distance calculations. This builds on the property of xts being ordered and only the next <code>twindow</code> instances are considered. This avoids the need of huge temporal distance matrices. The default uses twice the number as the average difference goes into the temporal cutoff.</p>
</td></tr>
<tr><td><code id="variogramST_+3A_tlags">tlags</code></td>
<td>
<p> integer; time lags to consider or in case <code>data</code> is of class <code><a href="spacetime.html#topic+STIDF-class">STIDF</a></code> the actual temporal boundaries with time unit given by <code>tunit</code> otherwise the same unit as <code><a href="base.html#topic+diff">diff</a></code> on the index of the time slot will generate is assumed.</p>
</td></tr>
<tr><td><code id="variogramST_+3A_cutoff">cutoff</code></td>
<td>
<p> spatial separation distance up to which point pairs
are included in semivariance estimates; as a default, the
length of the diagonal of the box spanning the data is divided by three. </p>
</td></tr>
<tr><td><code id="variogramST_+3A_width">width</code></td>
<td>
<p> the width of subsequent distance intervals into which
data point pairs are grouped for semivariance estimates, by default the 
<code>cutoff</code> is divided into 15 equal lags.</p>
</td></tr>
<tr><td><code id="variogramST_+3A_boundaries">boundaries</code></td>
<td>
<p> numerical vector with distance interval upper boundaries; 
values should be strictly increasing </p>
</td></tr>
<tr><td><code id="variogramST_+3A_progress">progress</code></td>
<td>
<p> logical; if TRUE, show text progress bar </p>
</td></tr>
<tr><td><code id="variogramST_+3A_pseudo">pseudo</code></td>
<td>
<p> integer; use pseudo cross variogram for computing
time-lagged spatial variograms? -1: find out from coordinates &ndash; if they
are equal then yes, else no; 0: no; 1: yes. </p>
</td></tr>
<tr><td><code id="variogramST_+3A_assumeregular">assumeRegular</code></td>
<td>
<p>logical; whether the time series should be assumed regular. 
The first time step is assumed to be representative for the whole series. Note,
that temporal lags are considered by index, and no check is made whether pairs
actually have the desired separating distance.</p>
</td></tr>
<tr><td><code id="variogramST_+3A_na.omit">na.omit</code></td>
<td>
<p>shall all <code>NA</code> values in the spatio-temporal variogram be dropped? In case where complete rows or columns in the variogram consists of <code>NA</code> only, <code>plot</code> might produce a distorted picture.</p>
</td></tr>
<tr><td><code id="variogramST_+3A_cores">cores</code></td>
<td>
<p>number of cores to use in parallel</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The spatio-temporal sample variogram contains besides the fields 
<code>np</code>, <code>dist</code> and <code>gamma</code> the spatio-temporal fields, 
<code>timelag</code>, <code>spacelag</code> and <code>avgDist</code>, the first of which indicates the time lag 
used, the second and third different spatial lags. <code>spacelag</code> is the midpoint in the spatial
lag intervals as passed by the parameter <code>boundaries</code>, whereas <code>avgDist</code> is the average 
distance between the point pairs found in a distance interval over all temporal lags (i.e. the 
averages of the values <code>dist</code> per temporal lag.) To compute variograms for space lag $h$ and
time lag $t$, the pseudo cross variogram $(Z_i(s)-Z_i+t(s+h))^2$ is averaged over all time 
lagged observation sets $Z_i$ and $Z_i+t$ available (weighted by the number of pairs involved).
</p>


<h3>Author(s)</h3>

<p> Edzer Pebesma, Benedikt Graeler </p>


<h3>References</h3>

 
<p>Cressie, N.A.C., 1993, Statistics for Spatial Data, Wiley.
</p>
<p>Cressie, N., C. Wikle, 2011, Statistics for Spatio-temporal Data, Wiley.
</p>
<p><a href="http://www.gstat.org/">http://www.gstat.org/</a>
</p>
<p>Pebesma, E.J., 2004. Multivariable geostatistics in S: the gstat package.
Computers and Geosciences, 30: 683-691.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.StVariogram">plot.StVariogram</a></code>,
for variogram models: <code><a href="#topic+vgmST">vgmST</a></code>,
to fit a spatio-temporal variogram model to a spatio-temporal sample variogram: 
<code><a href="#topic+fit.StVariogram">fit.StVariogram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The following spatio-temporal variogram has been calcualted through
# vv = variogram(PM10~1, r5to10, width=20, cutoff = 200, tlags=0:5)
# in the vignette "st".

data(vv)
str(vv)
plot(vv)
</code></pre>

<hr>
<h2 id='variogramSurface'>Semivariance values for a given spatio-temporal variogram model</h2><span id='topic+variogramSurface'></span>

<h3>Description</h3>

<p>Generates a surface of semivariance values given a spatio-temporal variogram model (one of separable, productSum, sumMetric, simpleSumMetric or metric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>variogramSurface(model, dist_grid, covariance = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variogramSurface_+3A_model">model</code></td>
<td>

<p>A spatio-temporal variogram model generated through <code><a href="#topic+vgmST">vgmST</a></code> or <code><a href="#topic+fit.StVariogram">fit.StVariogram</a></code>.
</p>
</td></tr>
<tr><td><code id="variogramSurface_+3A_dist_grid">dist_grid</code></td>
<td>

<p>A data.frame with two columns: <code>spacelag</code> and <code>timelag</code>.
</p>
</td></tr>
<tr><td><code id="variogramSurface_+3A_covariance">covariance</code></td>
<td>

<p>Whether the covariance should be computed instead of the variogram (default: FALSE).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with columns <code>spacelag</code>, <code>timelag</code> and <code>gamma</code>.
</p>


<h3>Author(s)</h3>

<p>Benedikt Graeler
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+variogramLine">variogramLine</a></code> for the spatial version and <code><a href="#topic+fit.StVariogram">fit.StVariogram</a></code> for the estimation of spatio-temporal variograms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>separableModel &lt;- vgmST("separable", 
                        space=vgm(0.86, "Exp", 476, 0.14),
                        time =vgm(   1, "Exp",   3, 0),
                        sill=113)

data(vv)

if(require(lattice)) {
plot(vv, separableModel, wireframe=TRUE, all=TRUE)
}

# plotting of sample and model variogram
plot(vv, separableModel)

</code></pre>

<hr>
<h2 id='vgm'>
Generate, or Add to Variogram Model
</h2><span id='topic+vgm'></span><span id='topic+print.variogramModel'></span><span id='topic+plot.variogramModel'></span><span id='topic+as.vgm.variomodel'></span>

<h3>Description</h3>

<p>Generates a variogram model, or adds to an existing model. 
<code>print.variogramModel</code> prints the essence of a variogram  model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vgm(psill = NA, model, range = NA, nugget, add.to, anis, kappa = 0.5, ..., covtable,
	Err = 0)
## S3 method for class 'variogramModel'
print(x, ...)
## S3 method for class 'variogramModel'
plot(x, cutoff, ..., type = 'l')
as.vgm.variomodel(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vgm_+3A_psill">psill</code></td>
<td>
<p> (partial) sill of the variogram model component, or model: see Details </p>
</td></tr>
<tr><td><code id="vgm_+3A_model">model</code></td>
<td>
<p> model type, e.g. &quot;Exp&quot;, &quot;Sph&quot;, &quot;Gau&quot;, &quot;Mat&quot;. Calling vgm() without
a model argument returns a data.frame with available models. </p>
</td></tr>
<tr><td><code id="vgm_+3A_range">range</code></td>
<td>
<p> range parameter of the variogram model component; in case of anisotropy: major range </p>
</td></tr>
<tr><td><code id="vgm_+3A_kappa">kappa</code></td>
<td>
<p> smoothness parameter for the Matern class of variogram 
models </p>
</td></tr>
<tr><td><code id="vgm_+3A_nugget">nugget</code></td>
<td>
<p> nugget component of the variogram (this basically adds a nugget
compontent to the model); if missing, nugget component is omitted </p>
</td></tr>
<tr><td><code id="vgm_+3A_add.to">add.to</code></td>
<td>
<p> the variogram model to which we want to add a component (structure) </p>
</td></tr>
<tr><td><code id="vgm_+3A_anis">anis</code></td>
<td>
<p> anisotropy parameters: see notes below </p>
</td></tr>
<tr><td><code id="vgm_+3A_x">x</code></td>
<td>
<p> a variogram model to print or plot</p>
</td></tr>
<tr><td><code id="vgm_+3A_...">...</code></td>
<td>
<p> arguments that will be passed to <code>print</code>, e.g. <code>digits</code>
(see examples), or to <code>variogramLine</code> for the plot method </p>
</td></tr>
<tr><td><code id="vgm_+3A_covtable">covtable</code></td>
<td>
<p> if model is <code>Tab</code>, instead of model parameters a one-dimensional 
covariance table can be passed here. See covtable.R in tests directory, and example below. </p>
</td></tr>
<tr><td><code id="vgm_+3A_err">Err</code></td>
<td>
<p> numeric; if larger than zero, the measurement error variance
component that will not be included to the kriging equations, i.e. kriging
will now smooth the process Y instead of predict the measured Z, 
where Z=Y+e, and Err is the variance of e</p>
</td></tr>
<tr><td><code id="vgm_+3A_m">m</code></td>
<td>
<p> object of class <code>variomodel</code>, see <span class="pkg">geoR</span></p>
</td></tr>
<tr><td><code id="vgm_+3A_cutoff">cutoff</code></td>
<td>
<p>maximum distance up to which variogram values are computed</p>
</td></tr>
<tr><td><code id="vgm_+3A_type">type</code></td>
<td>
<p>plot type</p>
</td></tr>
</table>


<h3>Details</h3>

<p> If only the first argument (<code>psill</code>) is given a
<code>character</code> value indicating a model, as in <code>vgm("Sph")</code>,
then this taken as a shorthand form of <code>vgm(NA,"Sph",NA,NA)</code>,
i.e. a spherical variogram with nugget and unknown parameter values;
see examples below. Read <a href="#topic+fit.variogram">fit.variogram</a> to find out how
<code>NA</code> variogram parameters are given initial values for a fitting
a model, based on the sample variogram. Package <code>automap</code>
gives further options for automated variogram modelling. </p>


<h3>Value</h3>

<p>If a single model is passed, an object of class <code>variogramModel</code>
extending <code>data.frame</code>.
</p>
<p>In case a vector ofmodels is passed, an object of class
<code>variogramModelList</code> which is a list of <code>variogramModel</code>
objects.
</p>
<p>When called without a model argument, a data.frame with available models
is returned, having two columns: short (abbreviated names, to be used
as model argument: &quot;Exp&quot;, &quot;Sph&quot; etc) and long (with some description).
</p>
<p>as.vgm.variomodel tries to convert an object of class variomodel (geoR)
to vgm.
</p>


<h3>Note</h3>

 
<p>Geometric anisotropy can be modelled for each individual simple model
by giving two or five anisotropy parameters, two for two-dimensional
and five for three-dimensional data. In any case, the range defined
is the range in the direction of the strongest correlation, or the
major range. Anisotropy parameters define which direction this is (the
main axis), and how much shorter the range is in (the) direction(s)
perpendicular to this main axis.
</p>
<p>In two dimensions, two parameters define an anisotropy ellipse, say
<code>anis = c(30, 0.5)</code>. The first parameter, <code>30</code>, refers to
the main axis direction: it is the angle for the principal direction
of continuity (measured in degrees, clockwise from positive Y, i.e. North).
The second parameter, <code>0.5</code>, is the anisotropy ratio, the ratio
of the minor range to the major range (a value between 0 and 1).  So,
in our example, if the range in the major direction (North-East) is 100,
the range in the minor direction (South-East) is 0.5 x 100 = 50.
</p>
<p>In three dimensions, five values should be given in the form <code>anis
= c(p,q,r,s,t)</code>.  Now, $p$ is the angle for the principal direction of
continuity (measured in degrees, clockwise from Y, in direction of X),
$q$ is the dip angle for the principal direction of continuity (measured
in positive degrees up from horizontal), $r$ is the third rotation angle
to rotate the two minor directions around the principal direction defined
by $p$ and $q$. A positive angle acts counter-clockwise while looking
in the principal direction. Anisotropy ratios $s$ and $t$ are the ratios
between the major range and each of the two minor ranges. The anisotropy code
was taken from GSLIB. Note that in <a href="http://www.gslib.com/sec_gb.html">http://www.gslib.com/sec_gb.html</a>
it is reported that this code has a bug. Quoting from this
site: &ldquo;The third angle in all GSLIB programs operates in the opposite
direction than specified in the GSLIB book.  Explanation - The books
says (pp27) the angle is measured clockwise when looking toward
the origin (from the postive principal direction), but it should be
counter-clockwise. This is a documentation error. Although rarely used,
the correct specification of the third angle is critical if used.&rdquo;
</p>
<p>(Note that <code>anis = c(p,s)</code> is equivalent to <code>anis = c(p,0,0,s,1)</code>.)
</p>
<p>The implementation in gstat for 2D and 3D anisotropy was taken from
the gslib (probably 1992) code.  I have seen a paper where it is argued
that the 3D anisotropy code implemented in gslib (and so in gstat)
is in error, but I have not corrected anything afterwards.
</p>


<h3>Author(s)</h3>

<p> Edzer Pebesma </p>


<h3>References</h3>

 <p><a href="http://www.gstat.org/">http://www.gstat.org/</a> 
</p>
<p>Pebesma, E.J., 2004. Multivariable geostatistics in S: the gstat package.
Computers and Geosciences, 30: 683-691.
</p>
<p>Deutsch, C.V. and Journel, A.G., 1998.  GSLIB: Geostatistical software
library and user's guide, second edition, Oxford University Press.
</p>
<p>For the validity of variogram models on the sphere, see Huang,
Chunfeng, Haimeng Zhang, and Scott M. Robeson. On the validity
of commonly used covariance and variogram functions on the
sphere. Mathematical Geosciences 43.6 (2011): 721-733.
</p>


<h3>See Also</h3>

<p><a href="#topic+show.vgms">show.vgms</a> to view the available models,
<a href="#topic+fit.variogram">fit.variogram</a>,
<a href="#topic+variogramLine">variogramLine</a>,
<a href="#topic+variogram">variogram</a> for the sample variogram.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vgm()
vgm("Sph")
vgm(NA, "Sph", NA, NA)
vgm(, "Sph") # "Sph" is second argument: NO nugget in this case
vgm(10, "Exp", 300)
x &lt;- vgm(10, "Exp", 300)
vgm(10, "Nug", 0)
vgm(10, "Exp", 300, 4.5)
vgm(10, "Mat", 300, 4.5, kappa = 0.7)
vgm( 5, "Exp", 300, add.to = vgm(5, "Exp", 60, nugget = 2.5))
vgm(10, "Exp", 300, anis = c(30, 0.5))
vgm(10, "Exp", 300, anis = c(30, 10, 0, 0.5, 0.3))
# Matern variogram model:
vgm(1, "Mat", 1, kappa=.3)
x &lt;- vgm(0.39527463, "Sph", 953.8942, nugget = 0.06105141)
x
print(x, digits = 3);
# to see all components, do
print.data.frame(x)
vv=vgm(model = "Tab",  covtable = 
	variogramLine(vgm(1, "Sph", 1), 1, n=1e4, min = 0, covariance = TRUE))
vgm(c("Mat", "Sph"))
vgm(, c("Mat", "Sph")) # no nugget
</code></pre>

<hr>
<h2 id='vgm.panel.xyplot'> panel functions for most of the variogram plots through lattice </h2><span id='topic+vgm.panel.xyplot'></span><span id='topic+panel.pointPairs'></span>

<h3>Description</h3>

<p>Variogram plots contain symbols and lines; more control over them can
be gained by writing your own panel functions, or extending the ones
described here; see examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vgm.panel.xyplot(x, y, subscripts, type = "p", pch = plot.symbol$pch, 
    col, col.line = plot.line$col, col.symbol = plot.symbol$col, 
    lty = plot.line$lty, cex = plot.symbol$cex, ids, lwd = plot.line$lwd, 
    model = model, direction = direction, labels, shift = shift, mode = mode, ...) 
panel.pointPairs(x, y, type = "p", pch = plot.symbol$pch, col, col.line = 
	plot.line$col, col.symbol = plot.symbol$col, lty = plot.line$lty, 
	cex = plot.symbol$cex, lwd = plot.line$lwd, pairs = pairs, 
	line.pch = line.pch, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vgm.panel.xyplot_+3A_x">x</code></td>
<td>
<p> x coordinates of points in this panel</p>
</td></tr>
<tr><td><code id="vgm.panel.xyplot_+3A_y">y</code></td>
<td>
<p> y coordinates of points in this panel</p>
</td></tr>
<tr><td><code id="vgm.panel.xyplot_+3A_subscripts">subscripts</code></td>
<td>
<p> subscripts of points in this panel</p>
</td></tr>
<tr><td><code id="vgm.panel.xyplot_+3A_type">type</code></td>
<td>
<p> plot type: &quot;l&quot; for connected lines </p>
</td></tr>
<tr><td><code id="vgm.panel.xyplot_+3A_pch">pch</code></td>
<td>
<p> plotting symbol </p>
</td></tr>
<tr><td><code id="vgm.panel.xyplot_+3A_col">col</code></td>
<td>
<p> symbol and line color (if set) </p>
</td></tr>
<tr><td><code id="vgm.panel.xyplot_+3A_col.line">col.line</code></td>
<td>
<p> line color </p>
</td></tr>
<tr><td><code id="vgm.panel.xyplot_+3A_col.symbol">col.symbol</code></td>
<td>
<p> symbol color </p>
</td></tr>
<tr><td><code id="vgm.panel.xyplot_+3A_lty">lty</code></td>
<td>
<p> line type for variogram model </p>
</td></tr>
<tr><td><code id="vgm.panel.xyplot_+3A_cex">cex</code></td>
<td>
<p> symbol size </p>
</td></tr>
<tr><td><code id="vgm.panel.xyplot_+3A_ids">ids</code></td>
<td>
<p> gstat model ids </p>
</td></tr>
<tr><td><code id="vgm.panel.xyplot_+3A_lwd">lwd</code></td>
<td>
<p> line width </p>
</td></tr>
<tr><td><code id="vgm.panel.xyplot_+3A_model">model</code></td>
<td>
<p> variogram model </p>
</td></tr>
<tr><td><code id="vgm.panel.xyplot_+3A_direction">direction</code></td>
<td>
<p> direction vector <code>c(dir.horizontal, dir.ver)</code></p>
</td></tr>
<tr><td><code id="vgm.panel.xyplot_+3A_labels">labels</code></td>
<td>
<p> labels to plot next to points </p>
</td></tr>
<tr><td><code id="vgm.panel.xyplot_+3A_shift">shift</code></td>
<td>
<p> amount to shift the label right of the symbol </p>
</td></tr>
<tr><td><code id="vgm.panel.xyplot_+3A_mode">mode</code></td>
<td>
<p> to be set by calling function only </p>
</td></tr>
<tr><td><code id="vgm.panel.xyplot_+3A_line.pch">line.pch</code></td>
<td>
<p> symbol type to be used for point of selected point pairs, e.g.
to highlight point pairs with distance close to zero </p>
</td></tr>
<tr><td><code id="vgm.panel.xyplot_+3A_pairs">pairs</code></td>
<td>
<p> two-column matrix with pair indexes to be highlighted </p>
</td></tr>
<tr><td><code id="vgm.panel.xyplot_+3A_...">...</code></td>
<td>
<p> parameters that get passed to <a href="lattice.html#topic+lpoints">lpoints</a> </p>
</td></tr>
</table>


<h3>Value</h3>

<p>ignored; the enclosing function returns a plot of class <code>trellis</code>
</p>


<h3>Author(s)</h3>

<p> Edzer Pebesma </p>


<h3>References</h3>

 <p><a href="http://www.gstat.org/">http://www.gstat.org/</a> </p>


<h3>See Also</h3>

 <p><a href="#topic+plot.gstatVariogram">plot.gstatVariogram</a>, <a href="#topic+vgm">vgm</a></p>


<h3>Examples</h3>

<pre><code class='language-R'> 
library(sp)
data(meuse)
coordinates(meuse) &lt;- c("x", "y")
library(lattice)
mypanel = function(x,y,...) { 
	vgm.panel.xyplot(x,y,...)
	panel.abline(h=var(log(meuse$zinc)), color = 'red')
}
plot(variogram(log(zinc)~1,meuse), panel = mypanel)
</code></pre>

<hr>
<h2 id='vgmArea'> point-point, point-area or area-area semivariance </h2><span id='topic+vgmArea'></span>

<h3>Description</h3>

<p> Compute point-point, point-area or area-area variogram values from point model </p>


<h3>Usage</h3>

<pre><code class='language-R'>vgmArea(x, y = x, vgm, ndiscr = 16, verbose = FALSE, covariance = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vgmArea_+3A_x">x</code></td>
<td>
<p> object of class <a href="sp.html#topic+SpatialPoints">SpatialPoints</a> or <a href="sp.html#topic+SpatialPolygons">SpatialPolygons</a></p>
</td></tr>
<tr><td><code id="vgmArea_+3A_y">y</code></td>
<td>
<p> object of class <a href="sp.html#topic+SpatialPoints">SpatialPoints</a> or <a href="sp.html#topic+SpatialPolygons">SpatialPolygons</a></p>
</td></tr>
<tr><td><code id="vgmArea_+3A_vgm">vgm</code></td>
<td>
<p> variogram model, see <a href="#topic+vgm">vgm</a></p>
</td></tr>
<tr><td><code id="vgmArea_+3A_ndiscr">ndiscr</code></td>
<td>
<p> number of points to discretize an area, using <a href="sp.html#topic+spsample">spsample</a></p>
</td></tr>
<tr><td><code id="vgmArea_+3A_verbose">verbose</code></td>
<td>
<p> give progress bar </p>
</td></tr>
<tr><td><code id="vgmArea_+3A_covariance">covariance</code></td>
<td>
<p> logical; compute covariances, rather than semivariances? </p>
</td></tr>
</table>


<h3>Value</h3>

<p> semivariance or covariance matrix of dimension <code>length(x)</code> x <code>lenght(y)</code></p>


<h3>Author(s)</h3>

<p> Edzer Pebesma </p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sp)
demo(meuse, ask = FALSE, echo = FALSE)
vgmArea(meuse[1:5,], vgm = vgm(1, "Exp", 1000)) # point-point
vgmArea(meuse[1:5,], meuse.area, vgm = vgm(1, "Exp", 1000)) # point-area
</code></pre>

<hr>
<h2 id='vgmAreaST'>
Function that returns the covariances for areas
</h2><span id='topic+vgmAreaST'></span>

<h3>Description</h3>

<p>Function that returns the covariances for areas based on spatio-temporal point variograms for use in the spatio-temporal area-to-point kriging
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vgmAreaST(x, y = x, model, ndiscrSpace = 16, verbose = FALSE, covariance = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vgmAreaST_+3A_x">x</code></td>
<td>
<p>spatio-temporal data frame</p>
</td></tr>
<tr><td><code id="vgmAreaST_+3A_y">y</code></td>
<td>
<p>spatio-temporal data frame</p>
</td></tr>
<tr><td><code id="vgmAreaST_+3A_model">model</code></td>
<td>
<p>spatio-temporal variogram model for point support</p>
</td></tr>
<tr><td><code id="vgmAreaST_+3A_ndiscrspace">ndiscrSpace</code></td>
<td>
<p>number of discretisation in space</p>
</td></tr>
<tr><td><code id="vgmAreaST_+3A_verbose">verbose</code></td>
<td>
<p>Boolean: default to FALSE, set to TRUE for debugging</p>
</td></tr>
<tr><td><code id="vgmAreaST_+3A_covariance">covariance</code></td>
<td>
<p>Boolean: whether the covariance shall be evaluated, currently disfunction and set to TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The covariance between 'x'  and 'y'.</p>


<h3>Author(s)</h3>

<p>Benedikt Graeler</p>


<h3>See Also</h3>

<p><code><a href="#topic+vgmArea">vgmArea</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># see demo('a2pinST')
</code></pre>

<hr>
<h2 id='vgmST'>Constructing a spatio-temporal variogram</h2><span id='topic+vgmST'></span>

<h3>Description</h3>

<p>Constructs a spatio-temporal variogram of a given type checking for a minimal set of parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vgmST(stModel, ..., space, time, joint, sill, k, nugget, stAni, temporalUnit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vgmST_+3A_stmodel">stModel</code></td>
<td>
<p>A string identifying the spatio-temporal variogram model (see details below). Only the string before an optional &quot;_&quot; is used to identify the model. This mechanism can be used to identify different fits of the same model (<code>separable_A</code> and <code>separable_B</code> will be interpreted as separable models, but carry different names).</p>
</td></tr>
<tr><td><code id="vgmST_+3A_...">...</code></td>
<td>
<p>unused, but ensure an exact match of the following parameters.</p>
</td></tr>
<tr><td><code id="vgmST_+3A_space">space</code></td>
<td>
<p>A spatial variogram.</p>
</td></tr>
<tr><td><code id="vgmST_+3A_time">time</code></td>
<td>
<p>A temporal variogram.</p>
</td></tr>
<tr><td><code id="vgmST_+3A_joint">joint</code></td>
<td>
<p>A joint spatio-temporal variogram.</p>
</td></tr>
<tr><td><code id="vgmST_+3A_sill">sill</code></td>
<td>
<p>A joint spatio-temporal sill.</p>
</td></tr>
<tr><td><code id="vgmST_+3A_k">k</code></td>
<td>
<p>The weighting of the product in the product-sum model.</p>
</td></tr>
<tr><td><code id="vgmST_+3A_nugget">nugget</code></td>
<td>
<p>A joint spatio-temporal nugget.</p>
</td></tr>
<tr><td><code id="vgmST_+3A_stani">stAni</code></td>
<td>
<p>A spatio-temporal anisotropy; the number of space units equivalent to one time unit.</p>
</td></tr>
<tr><td><code id="vgmST_+3A_temporalunit">temporalUnit</code></td>
<td>
<p>length one character vector, indicating the temporal unit (like secs)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The different implemented spatio-temporal variogram models have the following required parameters (see as well the example section)
</p>

<dl>
<dt>separable:</dt><dd><p>A variogram for <code>space</code> and <code>time</code> each and a joint spatio-temporal <code>sill</code> (variograms may have a separate nugget effect, but their joint sill will be 1) generating the call
</p>
<pre>vgmST("separable", space, time, sill)</pre></dd>
<dt>productSum:</dt><dd><p>A variogram for <code>space</code> and <code>time</code> each, and the weighting of product <code>k</code> generating the call
</p>
<pre>vgmST("productSum", space, time, k)</pre></dd>
<dt>sumMetric:</dt><dd><p>A variogram (potentially including a nugget effect) for <code>space</code>, <code>time</code> and <code>joint</code> each and a spatio-temporal anisotropy ratio <code>stAni</code> generating the call
</p>
<pre>vgmST("sumMetric", space, time, joint, stAni)</pre></dd>
<dt>simpleSumMetric:</dt><dd><p>A variogram (without nugget effect) for <code>space</code>, <code>time</code> and <code>joint</code> each, a joint spatio-temporal <code>nugget</code> effect and a spatio-temporal anisotropy ratio <code>stAni</code> generating the call
</p>
<pre>vgmST("simpleSumMetric", space, time, joint, nugget, stAni)</pre></dd>
<dt>metric:</dt><dd><p>A spatio-temporal <code>joint</code> variogram (potentially including a nugget effect) and <code>stAni</code> generating the call
</p>
<pre>vgmST("metric", joint, stAni)</pre></dd></dl>



<h3>Value</h3>

<p>Returns an S3 object  of class <code>StVariogramModel</code>.
</p>


<h3>Author(s)</h3>

<p>Benedikt Graeler
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit.StVariogram">fit.StVariogram</a></code> for fitting, <code><a href="#topic+variogramSurface">variogramSurface</a></code> to plot the variogram and <code><a href="#topic+extractParNames">extractParNames</a></code> to better understand the parameter structure of spatio-temporal variogram models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># separable model: spatial and temporal sill will be ignored
# and kept constant at 1-nugget respectively. A joint sill is used.
separableModel &lt;- vgmST("separable", 
                        space=vgm(0.9,"Exp", 147, 0.1),
                        time =vgm(0.9,"Exp", 3.5, 0.1),
                        sill=40)

# product sum model: spatial and temporal nugget will be ignored and kept
# constant at 0. Only a joint nugget is used.
prodSumModel &lt;- vgmST("productSum",
                      space=vgm(39, "Sph", 343, 0),
                      time= vgm(36, "Exp",   3, 0), 
                      k=15)

# sum metric model: spatial, temporal and joint nugget will be estimated
sumMetricModel &lt;- vgmST("sumMetric",
                        space=vgm( 6.9, "Lin", 200, 3.0),
                        time =vgm(10.3, "Lin",  15, 3.6),
                        joint=vgm(37.2, "Exp",  84,11.7),
                        stAni=77.7)
                       
# simplified sumMetric model, only a overall nugget is fitted. The spatial, 
# temporal and jont nuggets are set to 0.
simpleSumMetricModel &lt;- vgmST("simpleSumMetric",
                              space=vgm(20,"Lin", 150, 0),
                              time =vgm(20,"Lin", 10,  0),
                              joint=vgm(20,"Exp", 150, 0),
                              nugget=1, stAni=15)

# metric model
metricModel &lt;- vgmST("metric",
                     joint=vgm(60, "Exp", 150, 10),
                     stAni=60)
</code></pre>

<hr>
<h2 id='vv'>Precomputed variogram for PM10 in data set air</h2><span id='topic+vv'></span>

<h3>Description</h3>

<p>Precomputed variogram for PM10 in data set air
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(vv)
</code></pre>


<h3>Format</h3>

<p>data set structure is explained in <a href="#topic+variogramST">variogramST</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# obtained by:
library(spacetime)
library(gstat)
data(air)
suppressWarnings(proj4string(stations) &lt;- CRS(proj4string(stations)))
rural = STFDF(stations, dates, data.frame(PM10 = as.vector(air)))
rr = rural[,"2005::2010"]
unsel = which(apply(as(rr, "xts"), 2, function(x) all(is.na(x))))
r5to10 = rr[-unsel,]
vv = variogram(PM10~1, r5to10, width=20, cutoff = 200, tlags=0:5)

## End(Not run)
</code></pre>

<hr>
<h2 id='walker'>Walker Lake sample and exhaustive data sets</h2><span id='topic+walker'></span><span id='topic+walker.exh'></span>

<h3>Description</h3>

<p>This is the Walker Lake data sets (sample and exhaustive
data set), used in Isaaks and Srivastava's Applied Geostatistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(walker)
</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>Id</dt><dd><p>Identification Number</p>
</dd>
<dt>X</dt><dd><p>Xlocation in meter</p>
</dd>
<dt>Y</dt><dd><p>Ylocation in meter</p>
</dd>
<dt>V</dt><dd><p>V variable, concentration in ppm</p>
</dd>
<dt>U</dt><dd><p>U variable, concentration in ppm</p>
</dd>
<dt>T</dt><dd><p>T variable, indicator variable</p>
</dd>
</dl>



<h3>Note</h3>

<p>This data sets was obtained from the data sets on
ai-geostats,
<a href="https://wiki.52north.org/bin/view/AI_GEOSTATS/WebHome">https://wiki.52north.org/bin/view/AI_GEOSTATS/WebHome</a>
</p>


<h3>References</h3>

 
<p>Applied Geostatistics
by Edward H. Isaaks, R. Mohan Srivastava;
Oxford University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sp)
data(walker)
summary(walker)
summary(walker.exh)
</code></pre>

<hr>
<h2 id='wind'>Ireland wind data, 1961-1978</h2><span id='topic+wind'></span><span id='topic+wind.loc'></span>

<h3>Description</h3>

<p>Daily average wind speeds for 1961-1978 at 12 synoptic meteorological 
stations in the Republic of Ireland (Haslett and raftery 1989).
Wind speeds are in knots (1 knot = 0.5418 m/s), at each of the 
stations in the order given in Fig.4 of Haslett and Raftery (1989, see below)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wind)
</code></pre>


<h3>Format</h3>

<p>data.frame <code>wind</code> contains the following columns:
</p>

<dl>
<dt>year</dt><dd><p>year, minus 1900</p>
</dd>
<dt>month</dt><dd><p>month (number) of the year</p>
</dd>
<dt>day </dt><dd><p>day</p>
</dd>
<dt>RPT</dt><dd><p>average wind speed in knots at station RPT</p>
</dd>
<dt>VAL</dt><dd><p>average wind speed in knots at station VAL</p>
</dd>
<dt>ROS</dt><dd><p>average wind speed in knots at station ROS</p>
</dd>
<dt>KIL</dt><dd><p>average wind speed in knots at station KIL</p>
</dd>
<dt>SHA</dt><dd><p>average wind speed in knots at station SHA</p>
</dd>
<dt>BIR</dt><dd><p>average wind speed in knots at station BIR</p>
</dd>
<dt>DUB</dt><dd><p>average wind speed in knots at station DUB</p>
</dd>
<dt>CLA</dt><dd><p>average wind speed in knots at station CLA</p>
</dd>
<dt>MUL</dt><dd><p>average wind speed in knots at station MUL</p>
</dd>
<dt>CLO</dt><dd><p>average wind speed in knots at station CLO</p>
</dd>
<dt>BEL</dt><dd><p>average wind speed in knots at station BEL</p>
</dd>
<dt>MAL</dt><dd><p>average wind speed in knots at station MAL</p>
</dd>
</dl>

<p>data.frame <code>wind.loc</code> contains the following columns:
</p>

<dl>
<dt>Station</dt><dd><p>Station name</p>
</dd>
<dt>Code </dt><dd><p>Station code</p>
</dd>
<dt>Latitude</dt><dd><p>Latitude, in DMS, see examples below</p>
</dd>
<dt>Longitude</dt><dd><p>Longitude, in DMS, see examples below</p>
</dd>
<dt>MeanWind</dt><dd><p>mean wind for each station, metres per second </p>
</dd>
</dl>



<h3>Note</h3>

<p> This data set comes with the following message:
&ldquo;Be aware that the dataset is 532494 bytes long (thats over half a
Megabyte).  Please be sure you want the data before you request it.&rdquo;
</p>
<p>The data were obtained on Oct 12, 2008, from:
http://www.stat.washington.edu/raftery/software.html
The data are also available from statlib.
</p>
<p>Locations of 11 of the stations (ROS, Rosslare has
been thrown out because it fits poorly the spatial
correlations of the other stations) were obtained from:
http://www.stat.washington.edu/research/reports/2005/tr475.pdf
</p>
<p>Roslare lat/lon was obtained from google maps, location Roslare. The mean
wind value for Roslare comes from Fig. 1 in the original paper.
</p>
<p>Haslett and Raftery proposed to use a sqrt-transform to stabilize the variance.
</p>


<h3>Author(s)</h3>

<p> Adrian Raftery; imported to R by Edzer Pebesma </p>


<h3>References</h3>

 
<p>These data were analyzed in detail in the following article:
</p>
<p>Haslett, J. and Raftery, A. E. (1989). Space-time Modelling with
Long-memory Dependence: Assessing Ireland's Wind Power Resource
(with Discussion). Applied Statistics 38, 1-50.
</p>
<p>and in many later papers on space-time analysis, for example:
</p>
<p>Tilmann Gneiting, Marc G. Genton, Peter Guttorp: Geostatistical
Space-Time Models, Stationarity, Separability and Full symmetry.
Ch. 4 in: B. Finkenstaedt, L. Held, V. Isham, Statistical Methods
for Spatio-Temporal Systems.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wind)
summary(wind)
wind.loc
library(sp) # char2dms
wind.loc$y = as.numeric(char2dms(as.character(wind.loc[["Latitude"]])))
wind.loc$x = as.numeric(char2dms(as.character(wind.loc[["Longitude"]])))
coordinates(wind.loc) = ~x+y

## Not run: 
# fig 1:
library(maps)
library(mapdata)
map("worldHires", xlim = c(-11,-5.4), ylim = c(51,55.5))
points(wind.loc, pch=16)
text(coordinates(wind.loc), pos=1, label=wind.loc$Station)

## End(Not run)

wind$time = ISOdate(wind$year+1900, wind$month, wind$day)
# time series of e.g. Dublin data:
plot(DUB~time, wind, type= 'l', ylab = "windspeed (knots)", main = "Dublin")

# fig 2:
#wind = wind[!(wind$month == 2 &amp; wind$day == 29),]
wind$jday = as.numeric(format(wind$time, '%j'))
windsqrt = sqrt(0.5148 * as.matrix(wind[4:15]))
Jday = 1:366
windsqrt = windsqrt - mean(windsqrt)
daymeans = sapply(split(windsqrt, wind$jday), mean)
plot(daymeans ~ Jday)
lines(lowess(daymeans ~ Jday, f = 0.1))

# subtract the trend:
meanwind = lowess(daymeans ~ Jday, f = 0.1)$y[wind$jday]
velocity = apply(windsqrt, 2, function(x) { x - meanwind })

# match order of columns in wind to Code in wind.loc:
pts = coordinates(wind.loc[match(names(wind[4:15]), wind.loc$Code),])

# fig 3, but not really yet...
dists = spDists(pts, longlat=TRUE)
corv = cor(velocity)
sel = !(as.vector(dists) == 0)
plot(as.vector(corv[sel]) ~ as.vector(dists[sel]),
	xlim = c(0,500), ylim = c(.4, 1), xlab = "distance (km.)", 
	ylab = "correlation") 
# plots all points twice, ignores zero distance 
# now really get fig 3:
ros = rownames(corv) == "ROS"
dists.nr = dists[!ros,!ros]
corv.nr = corv[!ros,!ros]
sel = !(as.vector(dists.nr) == 0)
plot(as.vector(corv.nr[sel]) ~ as.vector(dists.nr[sel]), pch = 3,
	xlim = c(0,500), ylim = c(.4, 1), xlab = "distance (km.)", 
	ylab = "correlation") 
# add outlier:
points(corv[ros,!ros] ~ dists[ros,!ros], pch=16, cex=.5)
xdiscr = 1:500
# add correlation model:
lines(xdiscr, .968 * exp(- .00134 * xdiscr))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
