<!DOCTYPE html><html><head><title>Help for package BinaryEPPM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BinaryEPPM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BinaryEPPM-package'>
<p>Mean and Scale-Factor Modeling of Under- And Over-Dispersed Binary Data</p></a></li>
<li><a href='#BBprob'>
<p>Calculation of vector of probabilities for the beta binomial distribution.</p></a></li>
<li><a href='#Berkshires.litters'>
<p>The data are of the number of male piglets born in litters of varying sizes for</p>
the Berkshire breed of pigs.</a></li>
<li><a href='#BinaryEPPM'>
<p>Fitting of EPPM models to binary data.</p></a></li>
<li><a href='#CBprob'>
<p>Calculation of vector of probabilities for the correlated binomial distribution.</p></a></li>
<li><a href='#coef.BinaryEPPM'>
<p>Extraction of model coefficients for BinaryEPPM Objects</p></a></li>
<li><a href='#cooks.distance.BinaryEPPM'>
<p>Cook's distance for BinaryEPPM Objects</p></a></li>
<li><a href='#doubexp'>
<p>Double exponential Link Function</p></a></li>
<li><a href='#doubrecip'>
<p>Double reciprocal Link Function</p></a></li>
<li><a href='#EPPMprob'>
<p>Calculation of vector of probabilities for a extended Poisson process model (EPPM).</p></a></li>
<li><a href='#fitted.BinaryEPPM'>
<p>Extraction of fitted values from BinaryEPPM Objects</p></a></li>
<li><a href='#GBprob'>
<p>Calculation of vector of probabilities for the EPPM binomial distribution.</p></a></li>
<li><a href='#hatvalues.BinaryEPPM'>
<p>Extraction of hat matrix values from BinaryEPPM Objects</p></a></li>
<li><a href='#KupperHaseman.case'>
<p>Kupper and Haseman example data</p></a></li>
<li><a href='#LL.gradient'>
<p>Function used to calculate the first derivatives of the log likelihood with respect to the model parameters.</p></a></li>
<li><a href='#LL.Regression.Binary'>
<p>Function called by optim to calculate the log likelihood from the probabilities and hence perform the fitting of</p>
regression models to the binary data.</a></li>
<li><a href='#logLik.BinaryEPPM'>
<p>Extract Log-Likelihood</p></a></li>
<li><a href='#loglog'>
<p>Log-log Link Function</p></a></li>
<li><a href='#Model.BCBinProb'>
<p>Probabilities for beta and correlated binomial distributions given p's and scale-factors.</p></a></li>
<li><a href='#Model.Binary'>
<p>Function for obtaining output from distributional models.</p></a></li>
<li><a href='#Model.GB'>
<p>Probabilities for binomial and EPPM extended binomial distributions given p's and b.</p></a></li>
<li><a href='#Model.JMVGB'>
<p>Probabilities for EPPM extended binomial distributions given p's</p>
and scale-factors.</a></li>
<li><a href='#negcomplog'>
<p>Negative complementary log-log Link Function</p></a></li>
<li><a href='#Parkes.litters'>
<p>The data are of the number of male piglets born in litters of varying sizes for</p>
the Parkes breed of pigs.</a></li>
<li><a href='#plot.BinaryEPPM'>
<p>Diagnostic Plots for BinaryEPPM Objects</p></a></li>
<li><a href='#powerlogit'>
<p>Power Logit Link Function</p></a></li>
<li><a href='#predict.BinaryEPPM'>
<p>Prediction Method for BinaryEPPM Objects</p></a></li>
<li><a href='#print.BinaryEPPM'>
<p>Printing of BinaryEPPM Objects</p></a></li>
<li><a href='#print.summaryBinaryEPPM'>
<p>Printing of summaryBinaryEPPM Objects</p></a></li>
<li><a href='#residuals.BinaryEPPM'>
<p>Residuals for BinaryEPPM Objects</p></a></li>
<li><a href='#ropespores.case'>
<p>Dilution series for the presence of rope spores.</p></a></li>
<li><a href='#ropespores.grouped'>
<p>Dilution series for the presence of rope spores.</p></a></li>
<li><a href='#summary.BinaryEPPM'>
<p>Summary of BinaryEPPM Objects</p></a></li>
<li><a href='#vcov.BinaryEPPM'>
<p>Variance/Covariance Matrix for Coefficients</p></a></li>
<li><a href='#waldtest.BinaryEPPM'>
<p>Wald Test of Nested Models for BinaryEPPM Objects</p></a></li>
<li><a href='#wordcount.case'>
<p>Number of occurences of an article in five-word and ten-word samples from two authors.</p></a></li>
<li><a href='#wordcount.grouped'>
<p>Number of occurences of an article in five-word and ten-word samples from two authors.</p></a></li>
<li><a href='#Yorkshires.litters'>
<p>The data are of the number of male piglets born in litters of varying sizes for</p>
the Yorkshire breed of pigs.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Mean and Scale-Factor Modeling of Under- And Over-Dispersed
Binary Data</td>
</tr>
<tr>
<td>Version:</td>
<td>3.0</td>
</tr>
<tr>
<td>Imports:</td>
<td>Formula, expm, numDeriv, stats, lmtest, grDevices, graphics</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-06-03</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>Under- and over-dispersed binary data are modeled using an extended Poisson 
 process model (EPPM) appropriate for binary data. A feature of the model is that the 
 under-dispersion relative to the binomial distribution only needs to be greater than
 zero, but the over-dispersion is  restricted compared to other distributional models  
 such as the beta and correlated binomials. Because of this, the examples focus on 
 under-dispersed data and how, in combination with the beta or correlated distributions,
 flexible models can be fitted to data displaying both under- and over-dispersion. Using
 Generalized Linear Model (GLM)  terminology, the functions utilize linear predictors for
 the probability of success and scale-factor with various link functions for p, and log 
 link for scale-factor, to fit a variety of models relevant to areas such as bioassay. 
 Details of the EPPM are in Faddy and Smith (2012) &lt;<a href="https://doi.org/10.1002%2Fbimj.201100214">doi:10.1002/bimj.201100214</a>&gt; and 
 Smith and Faddy (2019) &lt;<a href="https://doi.org/10.18637%2Fjss.v090.i08">doi:10.18637/jss.v090.i08</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-03 18:18:25 UTC; dmccs</td>
</tr>
<tr>
<td>Author:</td>
<td>David M. Smith [aut, cre],
  Malcolm J. Faddy [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David M. Smith &lt;dmccsmith@verizon.net&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-04 10:32:25 UTC</td>
</tr>
</table>
<hr>
<h2 id='BinaryEPPM-package'>
Mean and Scale-Factor Modeling of Under- And Over-Dispersed Binary Data
</h2><span id='topic+BinaryEPPM-package'></span>

<h3>Description</h3>

<p>Under- and over-dispersed binary data are modeled using an extended Poisson 
process model (EPPM) appropriate for binary data. A feature of the model is that the 
under-dispersion relative to the binomial distribution only needs to be greater than
zero, but the over-dispersion is  restricted compared to other distributional models  
such as the beta and correlated binomials. Because of this, the examples focus on 
under-dispersed data and how, in combination with the beta or correlated distributions,
flexible models can be fitted to data displaying both under- and over-dispersion. Using
Generalized Linear Model (GLM)  terminology, the functions utilize linear predictors for
the probability of success and scale-factor with various link functions for p, and log 
link for scale-factor, to fit a variety of models relevant to areas such as bioassay.
Details of the EPPM are in Faddy and Smith (2012) and Smith and Faddy (2019). Two 
important changes from version 2.3 are the change to scale-factor rather than 
variance modeling, and the inclusion of a vignette.
</p>


<h3>Details</h3>


<p>Index of help topics:
</p>
<pre>
BBprob                  Calculation of vector of probabilities for the
                        beta binomial distribution.
Berkshires.litters      The data are of the number of male piglets born
                        in litters of varying sizes for the Berkshire
                        breed of pigs.
BinaryEPPM              Fitting of EPPM models to binary data.
BinaryEPPM-package      Mean and Scale-Factor Modeling of Under- And
                        Over-Dispersed Binary Data
CBprob                  Calculation of vector of probabilities for the
                        correlated binomial distribution.
EPPMprob                Calculation of vector of probabilities for a
                        extended Poisson process model (EPPM).
GBprob                  Calculation of vector of probabilities for the
                        EPPM binomial distribution.
KupperHaseman.case      Kupper and Haseman example data
LL.Regression.Binary    Function called by optim to calculate the log
                        likelihood from the probabilities and hence
                        perform the fitting of regression models to the
                        binary data.
LL.gradient             Function used to calculate the first
                        derivatives of the log likelihood with respect
                        to the model parameters.
Model.BCBinProb         Probabilities for beta and correlated binomial
                        distributions given p's and scale-factors.
Model.Binary            Function for obtaining output from
                        distributional models.
Model.GB                Probabilities for binomial and EPPM extended
                        binomial distributions given p's and b.
Model.JMVGB             Probabilities for EPPM extended binomial
                        distributions given p's and scale-factors.
Parkes.litters          The data are of the number of male piglets born
                        in litters of varying sizes for the Parkes
                        breed of pigs.
Yorkshires.litters      The data are of the number of male piglets born
                        in litters of varying sizes for the Yorkshire
                        breed of pigs.
coef.BinaryEPPM         Extraction of model coefficients for BinaryEPPM
                        Objects
cooks.distance.BinaryEPPM
                        Cook's distance for BinaryEPPM Objects
doubexp                 Double exponential Link Function
doubrecip               Double reciprocal Link Function
fitted.BinaryEPPM       Extraction of fitted values from BinaryEPPM
                        Objects
hatvalues.BinaryEPPM    Extraction of hat matrix values from BinaryEPPM
                        Objects
logLik.BinaryEPPM       Extract Log-Likelihood
loglog                  Log-log Link Function
negcomplog              Negative complementary log-log Link Function
plot.BinaryEPPM         Diagnostic Plots for BinaryEPPM Objects
powerlogit              Power Logit Link Function
predict.BinaryEPPM      Prediction Method for BinaryEPPM Objects
print.BinaryEPPM        Printing of BinaryEPPM Objects
print.summaryBinaryEPPM
                        Printing of summaryBinaryEPPM Objects
residuals.BinaryEPPM    Residuals for BinaryEPPM Objects
ropespores.case         Dilution series for the presence of rope
                        spores.
ropespores.grouped      Dilution series for the presence of rope
                        spores.
summary.BinaryEPPM      Summary of BinaryEPPM Objects
vcov.BinaryEPPM         Variance/Covariance Matrix for Coefficients
waldtest.BinaryEPPM     Wald Test of Nested Models for BinaryEPPM
                        Objects
wordcount.case          Number of occurences of an article in five-word
                        and ten-word samples from two authors.
wordcount.grouped       Number of occurences of an article in five-word
                        and ten-word samples from two authors.
</pre>


<h3>Author(s)</h3>

<p>David M. Smith [aut, cre],
  Malcolm J. Faddy [aut]
</p>
<p>Maintainer: David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Cribari-Neto F, Zeileis A. (2010). Beta Regression in R.
<em>Journal of Statistical Software</em>, <b>34</b>(2), 1-24. <a href="https://doi.org/10.18637/jss.v034.i02">doi:10.18637/jss.v034.i02</a>.
</p>
<p>Faddy M, Smith D. (2012). Extended Poisson Process Modeling and 
Analysis of Grouped Binary Data. <em>Biometrical Journal</em>, <b>54</b>, 426-435.
<a href="https://doi.org/10.1002/bimj.201100214">doi:10.1002/bimj.201100214</a>.
</p>
<p>Grun B, Kosmidis I, Zeileis A. (2012). Extended Beta Regression in R: Shaken, Stirred, Mixed, and Partitioned.
<em>Journal of Statistical Software</em>, <b>48</b>(11), 1-25. <a href="https://doi.org/10.18637/jss.v048.i11">doi:10.18637/jss.v048.i11</a>.
</p>
<p>Smith D, Faddy M. (2019). Mean and Variance Modeling of Under-Dispersed and Over-Dispersed
Grouped Binary Data. <em>Journal of Statistical Software</em>, <b>90</b>(8), 1-20.
<a href="https://doi.org/10.18637/jss.v090.i08">doi:10.18637/jss.v090.i08</a>.
</p>
<p>Zeileis A, Croissant Y. (2010). Extended Model Formulas in R: Multiple Parts and Multiple Responses.
<em>Journal of Statistical Software</em>, <b>34</b>(1), 1-13. <a href="https://doi.org/10.18637/jss.v034.i01">doi:10.18637/jss.v034.i01</a>.
</p>


<h3>See Also</h3>

<p><code><a href="CountsEPPM.html#topic+CountsEPPM-package">CountsEPPM</a></code> 
<code><a href="betareg.html#topic+betareg">betareg</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("ropespores.case")
output.fn &lt;- BinaryEPPM(data = ropespores.case,
                  number.spores / number.tested ~ 1 + offset(logdilution),
                  model.type = 'p only', model.name = 'binomial')                 
summary(output.fn) 
</code></pre>

<hr>
<h2 id='BBprob'>
Calculation of vector of probabilities for the beta binomial distribution.
</h2><span id='topic+BBprob'></span>

<h3>Description</h3>

<p>Given a vector of parameters and a scalar of the number of trials the function 
returns a vector of probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BBprob(twoparameter, nt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BBprob_+3A_twoparameter">twoparameter</code></td>
<td>

<p>A vector of the parameters of the beta binomial distribution.
</p>
</td></tr>
<tr><td><code id="BBprob_+3A_nt">nt</code></td>
<td>

<p>The number of trials.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of probabilities
</p>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Smith D (1982). Algorithm AS189. Maximum Likelihood Estimation of the 
Parameters of the Beta Binomial Distribution. Applied Statistics, 32, 196-204.
</p>
<p>Williams D (1996). &quot;Overdispersion in Logistic Linear Models.&quot; In B Mrgan (ed.), 
Statistics in Toxicology, pp75-84. Oxford Science Publications.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>twoparameter &lt;- c(0.96477815,0.7561417)
names(twoparameter) &lt;- c('p','theta')
nt &lt;- 37
BBprob(twoparameter,nt)
</code></pre>

<hr>
<h2 id='Berkshires.litters'>
The data are of the number of male piglets born in litters of varying sizes for
the Berkshire breed of pigs. 
</h2><span id='topic+Berkshires.litters'></span>

<h3>Description</h3>

 
<p>The data are arranged as a list of binomial frequency distributions where the 
listing is by litter size which is included both as a variate (vsize) and as 
a factor (fsize)</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Berkshires.litters")</code></pre>


<h3>Format</h3>

<p>The format is:
List of 3
$ fsize         : Factor w/ 7 levels &quot; size 5&quot;,&quot; size 6&quot;,..: 1 2 3 4 5 6 7
$ vsize         : int [1:7] 5 6 7 8 9 10 11
$ number.success:List of 7
..$ : num [1:6] 8 29 72 65 40 3
..$ : num [1:7] 5 22 89 129 74 35 4
..$ : num [1:8] 1 25 62 131 136 89 26 5
..$ : num [1:9] 1 15 79 179 219 149 71 33 4
..$ : num [1:10] 2 6 47 117 172 181 117 40 9 2
..$ : num [1:11] 2 1 23 65 131 145 120 61 20 3 ...
..$ : num [1:12] 0 3 9 22 53 94 72 54 20 4 ...
</p>


<h3>Source</h3>

<p>Brooks, R.J., James, W.H., Gray, E. (1993). Modelling Sub-Binomial Variation in 
the Frequency of Sex Combinations in Litters of Pigs. Biometrics 47, 403-417. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Berkshires.litters")
</code></pre>

<hr>
<h2 id='BinaryEPPM'>
Fitting of EPPM models to binary data.
</h2><span id='topic+BinaryEPPM'></span>

<h3>Description</h3>

<p>Fits regression models to under- and over-dispersed binary data 
using extended Poisson process models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BinaryEPPM(formula, data, subset = NULL, na.action = NULL, 
       weights = NULL, model.type = "p only", 
       model.name = "EPPM extended binomial", link = "cloglog", 
       initial = NULL, method = "Nelder-Mead", 
       pseudo.r.squared.type = "square of correlation", control = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BinaryEPPM_+3A_formula">formula</code></td>
<td>

<p>Formulae for the probability of a success p and scale-factor. The 
object used is from the package <code><a href="Formula.html#topic+Formula">Formula</a></code> 
of Zeileis and Croissant (2010) which allows multiple 
parts and multiple responses. &quot;formula&quot; should consist of a 
left hand side (lhs) of single response variable and a right hand 
side (rhs) of one or two sets of variables for the linear predictors 
for the mean and (if two sets) the variance. This is as used for 
the R function &quot;glm&quot; and also, for example, as for the package 
&quot;betareg&quot; (Cribari-Neto and Zeileis, 2010). The function identifies 
from the argument data whether a data frame (as for use of &quot;glm&quot;) 
or a list has been input. The list should be exactly the same as 
for a data frame except that the response variable is a list of 
vectors of frequency distributions rather than two vectors of 
paired counts of number responding (r) out of number tested as 
for the data frame. The subordinate functions fit models where 
the response variables are &quot;p.obs&quot;, or &quot;scalef.obs&quot; according 
to the model type being fitted. The values for these response 
variables are not input as part of &quot;data&quot;, they are calculated 
within the function from a list of grouped binary data input.
If the &quot;model.type&quot; is &quot;p only&quot;, &quot;formula&quot; consists of a lhs 
of the response variable and a rhs of the terms of the linear
predictor for the mean model. If the &quot;model.type&quot; is &quot;p and 
scale-factor&quot; there are two sets of terms in the rhs of 
&quot;formula&quot; i.e., &quot;p.obs&quot; and &quot;scalef.obs&quot; together with the 
two sets of terms for the linear predictors of p and scale-factor.
</p>
</td></tr>
<tr><td><code id="BinaryEPPM_+3A_data">data</code></td>
<td>

<p>&quot;data&quot; should be either a data frame (as for use of &quot;glm&quot;) 
or a list. The list should be exactly the same as for a 
data frame except that the response variable is a list 
of vectors of frequency distributions rather than a 
vector of single counts as for the data frame. Only one list
is allowed within &quot;data&quot; as it is identified as the dependent
variable. If other lists are in &quot;data&quot;, for example for use as
weights, they should be removed from &quot;data&quot; prior to calling 
this function. The extracted list can be called using the
&quot;weights&quot; argument to this function. Within the function 
a working list &quot;listcounts&quot; and data frames with components 
such as &quot;p.obs&quot;, &quot;scalef.obs&quot;, &quot;covariates&quot;, &quot;offset.mean&quot;, 
&quot;offset.variance&quot; are set up . The component &quot;covariates&quot; 
is a data frame of vectors of covariates in the model. 
The component &quot;listcounts&quot; is a list of vectors of 
frequency distributions, or the single pairs of r/n in 
grouped form if &quot;data&quot; is a data frame. 
</p>
</td></tr>
<tr><td><code id="BinaryEPPM_+3A_subset">subset</code></td>
<td>

<p>Subsetting commands.
</p>
</td></tr>
<tr><td><code id="BinaryEPPM_+3A_na.action">na.action</code></td>
<td>

<p>Action taken for NAs in data.
</p>
</td></tr>
<tr><td><code id="BinaryEPPM_+3A_weights">weights</code></td>
<td>

<p>Vector of list of lists of weights.
</p>
</td></tr>
<tr><td><code id="BinaryEPPM_+3A_model.type">model.type</code></td>
<td>

<p>Takes one of two values i.e. &quot;p only&quot; or &quot;p and scale-factor&quot;. 
The &quot;p only&quot; value fits a linear predictor function to the 
parameter <em>a</em> in equation (3) of Faddy and Smith (2012). If 
the model type being fitted is binomial, modeling <em>a</em> is the 
same as modeling the mean. For the negative binomial the 
mean is <em>b exp(a)-1)</em>, <em>b</em> also being as in equation (3) 
of Faddy and Smith (2012). The &quot;p and scale-factor&quot; value 
fits linear predictor functions to both the probability 
of a success p and the scale-factor. 
</p>
</td></tr>
<tr><td><code id="BinaryEPPM_+3A_model.name">model.name</code></td>
<td>

<p>If model.type is &quot;p only&quot; the model being fitted is one 
of the four &quot;binomial&quot;, &quot;EPPM extended binomial&quot;, &quot;beta binomial&quot;, &quot;correlated binomial&quot;. 
If model.type is &quot;p and scale-factor&quot; the model being fitted is 
either &quot;EPPM extended binomial&quot; i.e. as equations (4) and (6) of Faddy and Smith (2012)
or one of the two &quot;beta binomial&quot;, &quot;correlated binomial&quot;. 
</p>
</td></tr>
<tr><td><code id="BinaryEPPM_+3A_link">link</code></td>
<td>

<p>Takes one of nine values i.e., 'logit', 'probit', 'cloglog', 'cauchit', 'log',
'loglog', 'double exponential', 'double reciprocal', 'power logit'. 
The default is 'cloglog'. The 'power logit' has an attribute of 'power' for
which the default is 1 i.e., a logit link.
</p>
</td></tr>
<tr><td><code id="BinaryEPPM_+3A_initial">initial</code></td>
<td>

<p>This is a vector of initial values for the parameters. 
If this vector is NULL then initial values based on a 
fitting binomial models using &quot;glm&quot; are calculated 
within the function.
</p>
</td></tr>
<tr><td><code id="BinaryEPPM_+3A_method">method</code></td>
<td>

<p>Takes one of the two values &quot;Nelder-Mead&quot; or &quot;BFGS&quot; these 
being arguments of <code>optim</code>.
</p>
</td></tr>
<tr><td><code id="BinaryEPPM_+3A_pseudo.r.squared.type">pseudo.r.squared.type</code></td>
<td>

<p>Takes one of the three values &quot;square of correlation&quot;, &quot;R square&quot; or &quot;max-rescaled R square&quot;.
The &quot;default&quot; is as used in Cribari-Neto and Zeileis (2010) and is the square of the 
correlation between the observed and predicted values on the GLM linear predictor scale.
The other two are as described in Cox and Snell (1989), and Nagelkerke (1991) and apply to 
logistic regression.
</p>
</td></tr>
<tr><td><code id="BinaryEPPM_+3A_control">control</code></td>
<td>

<p>&quot;control&quot; is a list of control parameters as used in 
&quot;optim&quot;. If this list is NULL the defaults for 
&quot;optim&quot; are set as 
&quot;control &lt;- list(fnscale=-1, trace=0, maxit=1000)&quot;. 
The control parameters that can be changed 
by inputting a variable length list are 
&quot;fnscale, trace, maxit, abstol, reltol, alpha, beta, gamma&quot;. 
Details of &quot;optim&quot; and its control parameters are 
available in the online R help manuals.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;BinaryEPMM&quot; is returned. A list of object items follows.
</p>
<table>
<tr><td><code>data.type</code></td>
<td>
<p>The type of the data i.e., data frame or list</p>
</td></tr>
<tr><td><code>list.data</code></td>
<td>
<p>Data as a list of lists of frequency distributions</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The call of the function</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>The formula argument</p>
</td></tr>
<tr><td><code>model.type</code></td>
<td>
<p>The type of model being fitted</p>
</td></tr>
<tr><td><code>model.name</code></td>
<td>
<p>The model being fitted</p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>The link function</p>
</td></tr>
<tr><td><code>covariates.matrix.p</code></td>
<td>
<p>The design matrix for the probability of a success</p>
</td></tr>
<tr><td><code>covariates.matrix.scalef</code></td>
<td>
<p>The design matrix for the scalefactor</p>
</td></tr>
<tr><td><code>offset.p</code></td>
<td>
<p>The offset vector for the probability of a success</p>
</td></tr>
<tr><td><code>offset.scalef</code></td>
<td>
<p>The offset vector for the scalefactor</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>Estimates of model parameters</p>
</td></tr>
<tr><td><code>loglikelihood</code></td>
<td>
<p>Loglikelihood</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>The variance/covariance matrix</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>The number of observations</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>The number of observations</p>
</td></tr>
<tr><td><code>df.null</code></td>
<td>
<p>The degrees of freedom of the null model</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>The degrees of freedom of the residual</p>
</td></tr>
<tr><td><code>vnmax</code></td>
<td>
<p>Vector of maximums of grouped count data vectors in list.counts</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>Vector or list of weights</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>Whether the iterative process converged, TRUE or FALSE</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>Number of iterations taken</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Method for optim either Nelder-Mead or BFGS</p>
</td></tr>
<tr><td><code>pseudo.r.squared</code></td>
<td>
<p>Pseudo R**2 value</p>
</td></tr>
<tr><td><code>start</code></td>
<td>
<p>Starting values for iterative process</p>
</td></tr>
<tr><td><code>optim</code></td>
<td>
<p>Estimates of model parameters</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>Control parameters for <code>optim</code></p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>Fitted values for probability of success</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Dependent variable</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>Terms in model fitted</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Cox DR, Snell EJ. (1989). <em>Analysis of Binary Data</em>. Second Edition. Chapman &amp; Hall.
</p>
<p>Cribari-Neto F, Zeileis A. (2010). Beta Regression in R.
<em>Journal of Statistical Software</em>, <b>34</b>(2), 1-24. <a href="https://doi.org/10.18637/jss.v034.i02">doi:10.18637/jss.v034.i02</a>.
</p>
<p>Grun B, Kosmidis I, Zeileis A. (2012). Extended Beta Regression in R: Shaken, Stirred, Mixed, and Partitioned.
<em>Journal of Statistical Software</em>, <b>48</b>(11), 1-25. <a href="https://doi.org/10.18637/jss.v048.i11">doi:10.18637/jss.v048.i11</a>.
</p>
<p>Faddy M, Smith D. (2012). Extended Poisson Process Modeling and 
Analysis of Grouped Binary Data. <em>Biometrical Journal</em>, <b>54</b>, 426-435.
<a href="https://doi.org/10.1002/bimj.201100214">doi:10.1002/bimj.201100214</a>.
</p>
<p>Nagelkerke NJD. (1991). A Note on a General Definition of the Coefficient of Determination.
<em>Biometrika</em>, <b>78</b>, 691-692.
</p>
<p>Smith D, Faddy M. (2019). Mean and Variance Modeling of Under-Dispersed and Over-Dispersed
Grouped Binary Data. <em>Journal of Statistical Software</em>, <b>90</b>(8), 1-20.
<a href="https://doi.org/10.18637/jss.v090.i08">doi:10.18637/jss.v090.i08</a>.
</p>
<p>Zeileis A, Croissant Y. (2010). Extended Model Formulas in R: Multiple Parts and Multiple Responses.
<em>Journal of Statistical Software</em>, <b>34</b>(1), 1-13. <a href="https://doi.org/10.18637/jss.v034.i01">doi:10.18637/jss.v034.i01</a>.
</p>


<h3>See Also</h3>

<p><code><a href="CountsEPPM.html#topic+CountsEPPM-package">CountsEPPM</a></code> 
<code><a href="betareg.html#topic+betareg">betareg</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("ropespores.case") 
output.fn &lt;- BinaryEPPM(data = ropespores.case,
                  number.spores / number.tested ~ 1 + offset(logdilution),
                  model.type = "p only", model.name = "binomial")   
summary(output.fn)
</code></pre>

<hr>
<h2 id='CBprob'>
Calculation of vector of probabilities for the correlated binomial distribution.
</h2><span id='topic+CBprob'></span>

<h3>Description</h3>

<p>Given a vector of parameters and a scalar of the number of trials the function 
returns a vector of probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CBprob(twoparameter, nt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CBprob_+3A_twoparameter">twoparameter</code></td>
<td>

<p>A vector of the parameters of the correlated binomial distribution.
</p>
</td></tr>
<tr><td><code id="CBprob_+3A_nt">nt</code></td>
<td>

<p>The number of trials.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of probabilities
</p>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Kupper L, Haseman J (1978). The Use of a Correlated Binomial Model for the 
Analysis of Toxicological Experiments. Biometrics, 34(1), 69-76.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>twoparameter &lt;- c(0.971242852,0.001465007)
names(twoparameter) &lt;- c('p','rho')
nt &lt;- 37
CBprob(twoparameter,nt)
</code></pre>

<hr>
<h2 id='coef.BinaryEPPM'>
Extraction of model coefficients for BinaryEPPM Objects
</h2><span id='topic+coef.BinaryEPPM'></span>

<h3>Description</h3>

<p>Extract the regression model coefficients from models of class &quot;BinaryEPMM&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BinaryEPPM'
coef(object, prtpar = c("full", "p", "scale.factor"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.BinaryEPPM_+3A_object">object</code></td>
<td>

<p>fitted model object of class &quot;BinaryEPPM&quot;.
</p>
</td></tr>
<tr><td><code id="coef.BinaryEPPM_+3A_prtpar">prtpar</code></td>
<td>

<p>character indicating coefficients of the fitted model to be output:
all coefficients (&quot;full&quot;),
coefficients of the model for probability of success (&quot;p&quot;),
coefficients of the model for scale-factor (&quot;scale.factor&quot;)
</p>
</td></tr>
<tr><td><code id="coef.BinaryEPPM_+3A_...">...</code></td>
<td>

<p>some methods for this generic function require additional arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One of a set of standard extractor functions for fitted model objects of class
&quot;BinaryEPPM.
</p>


<h3>Value</h3>

<p>Vector of coefficients of fitted regression model.
</p>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>See Also</h3>

<p><code><a href="betareg.html#topic+betareg">betareg</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("ropespores.case")
output.fn &lt;- BinaryEPPM(data = ropespores.case,
                  number.spores / number.tested ~ 1 + offset(logdilution))   
coef(output.fn, prtpar = "full")
coef(output.fn, prtpar = "p")
coef(output.fn, prtpar = "scale.factor")
</code></pre>

<hr>
<h2 id='cooks.distance.BinaryEPPM'>
Cook's distance for BinaryEPPM Objects
</h2><span id='topic+cooks.distance.BinaryEPPM'></span>

<h3>Description</h3>

<p>Calculates Cook's distances for BinaryEPPM objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BinaryEPPM'
cooks.distance(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cooks.distance.BinaryEPPM_+3A_model">model</code></td>
<td>

<p>fitted model object of class &quot;BinaryEPPM&quot;.
</p>
</td></tr>
<tr><td><code id="cooks.distance.BinaryEPPM_+3A_...">...</code></td>
<td>

<p>some methods for this generic function require additional arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Cook's distances as in GLMs.
</p>


<h3>Value</h3>

<p>A vector of Cook's distances.
</p>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Cribari-Neto F, Zeileis A. (2010). Beta Regression in R.
<em>Journal of Statistical Software</em>, <b>34</b>(2), 1-24. <a href="https://doi.org/10.18637/jss.v034.i02">doi:10.18637/jss.v034.i02</a>.
</p>


<h3>See Also</h3>

<p><code><a href="betareg.html#topic+betareg">betareg</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("ropespores.case") 
output.fn &lt;- BinaryEPPM(data = ropespores.case,
                  number.spores / number.tested ~ 1 + offset(logdilution),
                  model.type = 'p only', model.name = 'binomial')   
cooks.distance(output.fn)
</code></pre>

<hr>
<h2 id='doubexp'>
Double exponential Link Function
</h2><span id='topic+doubexp'></span>

<h3>Description</h3>

<p>Computes the double exponential link function, including its inverse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doubexp()
</code></pre>


<h3>Value</h3>

<p>The double exponential transformation of theta.
</p>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Ford I, Torsney B, Wu C (1992). &quot;The Use of a Canonical Form in the Construction 
of Locally Optimal Designs for Non-linear Problems.&quot; Journal of the Royal 
Statistical Society B, 54, 569-583. <a href="https://doi.org/10.1111/j.2517-6161.1992.tb01897.x">doi:10.1111/j.2517-6161.1992.tb01897.x</a>
</p>

<hr>
<h2 id='doubrecip'>
Double reciprocal Link Function
</h2><span id='topic+doubrecip'></span>

<h3>Description</h3>

<p>Computes the double reciprocal link function, including its inverse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doubrecip()
</code></pre>


<h3>Value</h3>

<p>The double reciprocal transformation of theta.
</p>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Ford I, Torsney B, Wu C (1992). &quot;The Use of a Canonical Form in the Construction 
of Locally Optimal Designs for Non-linear Problems.&quot; Journal of the Royal 
Statistical Society B, 54, 569-583. <a href="https://doi.org/10.1111/j.2517-6161.1992.tb01897.x">doi:10.1111/j.2517-6161.1992.tb01897.x</a>
</p>

<hr>
<h2 id='EPPMprob'>
Calculation of vector of probabilities for a extended Poisson process model (EPPM).
</h2><span id='topic+EPPMprob'></span>

<h3>Description</h3>

<p>Calculates a vector of probabilities given a vector of rates using the matrix 
exponential function from Maechler, Dutang, Goulet, Bates, Firth (2023).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EPPMprob(vlambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EPPMprob_+3A_vlambda">vlambda</code></td>
<td>

<p>a vector of rates of an extended Poisson process.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a similar function to that in Smith and Faddy (2014).
</p>


<h3>Value</h3>

<p>The value returned is a vector of probabilities.
</p>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Maechler M, Dutang C, Goulet V, Bates D, Firth D. (2023). expm: Matrix Exponential. 
R package version 0.999-8, <a href="https://CRAN.R-project.org/package=expm">https://CRAN.R-project.org/package=expm</a>. 
</p>
<p>Smith D, Faddy M (2014). CountsEPPM: Mean and Variance Modeling of Count Data. 
R package version 2.0, <a href="https://CRAN.R-project.org/package=CountsEPPM">https://CRAN.R-project.org/package=CountsEPPM</a>. 
</p>

<hr>
<h2 id='fitted.BinaryEPPM'>
Extraction of fitted values from BinaryEPPM Objects
</h2><span id='topic+fitted.BinaryEPPM'></span>

<h3>Description</h3>

<p>This function is generic. Extract the fitted values from models of class &quot;BinaryEPMM&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BinaryEPPM'
fitted(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.BinaryEPPM_+3A_object">object</code></td>
<td>

<p>fitted model object of class &quot;BinaryEPPM&quot;.
</p>
</td></tr>
<tr><td><code id="fitted.BinaryEPPM_+3A_...">...</code></td>
<td>

<p>currently not used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is included so that function lrtest from package lmtest can be used.
</p>


<h3>Value</h3>

<p>An vector of class &quot;numeric&quot; of the fitted values from the object of class &quot;BinaryEPMM&quot;.
</p>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+stats-package">fitted</a></code> 
</p>

<hr>
<h2 id='GBprob'>
Calculation of vector of probabilities for the EPPM binomial distribution.
</h2><span id='topic+GBprob'></span>

<h3>Description</h3>

<p>Given a vector of parameters and a scalar of the number of trials the function 
returns a vector of probabilities. The name GBprob is used to avoid confusion
with EPPMprob which is the function calculating the probabilties given the
constructed vector vector of lambdas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GBprob(twoparameter, nt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GBprob_+3A_twoparameter">twoparameter</code></td>
<td>

<p>A vector of the parameters of the EPPM binomial distribution.
</p>
</td></tr>
<tr><td><code id="GBprob_+3A_nt">nt</code></td>
<td>

<p>The number of trials.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of probabilities
</p>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Faddy M, Smith D. (2012). Extended Poisson Process Modeling and 
Analysis of Grouped Binary Data. <em>Biometrical Journal</em>, <b>54</b>, 426-435.
<a href="https://doi.org/10.1002/bimj.201100214">doi:10.1002/bimj.201100214</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>twoparameter &lt;- c(0.971242852,0.001465007)
names(twoparameter) &lt;- c('p','b')
nt &lt;- 37
GBprob(twoparameter,nt)
</code></pre>

<hr>
<h2 id='hatvalues.BinaryEPPM'>
Extraction of hat matrix values from BinaryEPPM Objects
</h2><span id='topic+hatvalues.BinaryEPPM'></span>

<h3>Description</h3>

<p>Extract the values of the hat matrix from models of class &quot;BinaryEPMM&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BinaryEPPM'
hatvalues(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hatvalues.BinaryEPPM_+3A_model">model</code></td>
<td>

<p>fitted model object of class &quot;BinaryEPPM&quot;.
</p>
</td></tr>
<tr><td><code id="hatvalues.BinaryEPPM_+3A_...">...</code></td>
<td>

<p>some methods for this generic function require additional arguments.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The calculated hat values for the fitted model. These are used to calculate Cook's distances.
</p>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Cribari-Neto F, Zeileis A. (2010). Beta Regression in R.
<em>Journal of Statistical Software</em>, <b>34</b>(2), 1-24. <a href="https://doi.org/10.18637/jss.v034.i02">doi:10.18637/jss.v034.i02</a>.
</p>


<h3>See Also</h3>

<p><code><a href="betareg.html#topic+betareg">betareg</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("ropespores.case") 
output.fn &lt;- BinaryEPPM(data = ropespores.case,
                  number.spores / number.tested ~ 1 + offset(logdilution),
                  model.type = 'p only', model.name = 'binomial')   
hatvalues(output.fn)
</code></pre>

<hr>
<h2 id='KupperHaseman.case'>
Kupper and Haseman example data
</h2><span id='topic+KupperHaseman.case'></span>

<h3>Description</h3>

<p>Data of the number of deaths out of number of implants for pregnant female mice
for two groups each of size 10.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("KupperHaseman.case")</code></pre>


<h3>Format</h3>

<p>A data frame with 20 observations on the following 3 variables.
</p>

<dl>
<dt><code>Group</code></dt><dd><p>a factor with levels <code>Control</code> <code>Treated</code></p>
</dd>
<dt><code>Number.Deaths</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Number.Implants</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>Kupper L, Haseman J. (1978). The Use of a Correlated Binomial Model for the 
Analysis of Toxicological Experiments. Biometrics, 34(1), 69-76.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("KupperHaseman.case")
</code></pre>

<hr>
<h2 id='LL.gradient'>
Function used to calculate the first derivatives of the log likelihood with respect to the model parameters.
</h2><span id='topic+LL.gradient'></span>

<h3>Description</h3>

<p>Function used to calculate the first derivatives of the log likelihood with respect to the model parameters. 
These are numerical derivatives calculated using the numerical derivative functions of Gilbert and Varadhan (2015). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LL.gradient(parameter, model.type, model.name, link, ntrials, nsuccess,
            covariates.matrix.p, covariates.matrix.scalef, 
            offset.p, offset.scalef, weights, grad.method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LL.gradient_+3A_parameter">parameter</code></td>
<td>
 
<p>A vector of the parameters of the model which is set to initial estimates 
on function call.
</p>
</td></tr>
<tr><td><code id="LL.gradient_+3A_model.type">model.type</code></td>
<td>

<p>Takes one of two values i.e. 'p only' or 'p and scale-factor'. The 'p only' 
value fits linear predictor functions to the probability of a success 'p' 
as in Faddy and Smith (2012). The 'p and scale-factor' value fits linear 
predictor functions to both the 'p' and the scale-factor. The default is
'p and scale-factor'.
</p>
</td></tr>
<tr><td><code id="LL.gradient_+3A_model.name">model.name</code></td>
<td>

<p>If model.type is 'p only' the model being fitted is one of the four 'binomial', 
'EPPM extended binomial', 'beta binomial' or 'correlated binomial'. If model.type
is 'p and scale-factor' the model being fitted is one of the three 
'EPPM extended binomial', 'beta binomial' or 'correlated binomial'. Information 
about these models is given in Faddy and Smith (2012). 
The default is 'EPPM extended binomial'.
</p>
</td></tr>
<tr><td><code id="LL.gradient_+3A_link">link</code></td>
<td>

<p>Takes one of nine values i.e., 'logit', 'probit', 'cloglog', 'cauchit', 'log',
'loglog', 'double exponential', 'double reciprocal', 'power logit'. 
The default is 'cloglog'. The 'power logit' has an attribute of 'power' for
which the default is 1 i.e., a logit link.
</p>
</td></tr>
<tr><td><code id="LL.gradient_+3A_ntrials">ntrials</code></td>
<td>

<p>A vector length 'n+1' representing the number of trials 'n' i.e., a vector 
with all elements equal to 'n'.
</p>
</td></tr>
<tr><td><code id="LL.gradient_+3A_nsuccess">nsuccess</code></td>
<td>

<p>A vector representing the frequency distribution of the binomial 
distribution for fixed number of trials 'n'. 
</p>
</td></tr>
<tr><td><code id="LL.gradient_+3A_covariates.matrix.p">covariates.matrix.p</code></td>
<td>

<p>A matrix of covariates for the mean where rows are the number of values in 
list.binary and columns the covariates. This matrix is extracted from the 
formulae in function BinaryEPPM. However, in the accompanying example it 
is shown how it can be constructed independently of function BinaryEPPM. 
</p>
</td></tr>
<tr><td><code id="LL.gradient_+3A_covariates.matrix.scalef">covariates.matrix.scalef</code></td>
<td>

<p>A matrix of covariates for the variance where rows are the number of 
values in list.binary and columns the covariates. The default is a 
vector of ones. This matrix is extracted from the formulae in function 
BinaryEPPM. However, in the accompanying example it is shown how it 
can be constructed independently of function BinaryEPPM. 
</p>
</td></tr>
<tr><td><code id="LL.gradient_+3A_offset.p">offset.p</code></td>
<td>

<p>An offset vector for the probability of success p. The default 
is a vector of ones.
</p>
</td></tr>
<tr><td><code id="LL.gradient_+3A_offset.scalef">offset.scalef</code></td>
<td>

<p>An offset vector for the scale-factor. The default is a 
vector of ones.
</p>
</td></tr>
<tr><td><code id="LL.gradient_+3A_weights">weights</code></td>
<td>

<p>A vector or list of weights for the modeling of probability of success. The default is a 
vector of ones.
</p>
</td></tr>
<tr><td><code id="LL.gradient_+3A_grad.method">grad.method</code></td>
<td>

<p>Numerical method used to calculate gradients when the optimization method for optim 
is BFGS either simple or Richardson. This is the grad.method attribute of argument 
method of BinaryEPPM. The default is simple.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of numerical first derivatives.
</p>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Gilbert P, Varadhan R. (2015). numDeriv: Accurate Numerical Derivatives. R Package version 2014.2-1, 
<a href="https://CRAN.R-project.org/package=numDeriv">https://CRAN.R-project.org/package=numDeriv</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>link &lt;- 'cloglog'
attr(link, which="p") &lt;- make.link(link)
nsuccess &lt;- list(c(rep(0,5),352,479,530,291,101,17))
ntrials  &lt;- list(c(rep(10,11)))
parameter &lt;- c(0.06363398,-0.47085362)
LL.gradient(parameter, model.type = "p and scale-factor",
     model.name = "EPPM extended binomial", link = link, ntrials = ntrials, nsuccess = nsuccess,
     covariates.matrix.p = matrix(c(1), nrow=1),
     covariates.matrix.scalef = matrix(c(1), nrow=1), 
     offset.p = c(0), offset.scalef = c(0), weights = list(c(rep(1,11))),
     grad.method = "Richardson")
</code></pre>

<hr>
<h2 id='LL.Regression.Binary'>
Function called by optim to calculate the log likelihood from the probabilities and hence perform the fitting of 
regression models to the binary data.
</h2><span id='topic+LL.Regression.Binary'></span>

<h3>Description</h3>

<p>Fits specified regression models to the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LL.Regression.Binary(parameter,model.type,model.name,link,ntrials,nsuccess,
                     covariates.matrix.p,covariates.matrix.scalef,
                     offset.p,offset.scalef,weights,grad.method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LL.Regression.Binary_+3A_parameter">parameter</code></td>
<td>
 
<p>A vector of the parameters of the model which is set to initial estimates 
on function call.
</p>
</td></tr>
<tr><td><code id="LL.Regression.Binary_+3A_model.type">model.type</code></td>
<td>

<p>Takes one of two values i.e. 'p only' or 'p and scale-factor'. The 'p only' 
value fits linear predictor functions to the probability of a success 'p' 
as in Faddy and Smith (2012). The 'p and scale-factor' value fits linear 
predictor functions to both the 'p' and the scale-factor. The default is
'p and scale-factor'.
</p>
</td></tr>
<tr><td><code id="LL.Regression.Binary_+3A_model.name">model.name</code></td>
<td>

<p>If model.type is 'p only' the model being fitted is one of the four 'binomial', 
'EPPM extended binomial', 'beta binomial' or 'correlated binomial'. If model.type
is 'p and scale-factor' the model being fitted is one of the three 
'EPPM extended binomial', 'beta binomial' or 'correlated binomial'. Information 
about these models is given in Faddy and Smith (2012). 
The default is 'EPPM extended binomial'.
</p>
</td></tr>
<tr><td><code id="LL.Regression.Binary_+3A_link">link</code></td>
<td>

<p>Takes one of nine values i.e., 'logit', 'probit', 'cloglog', 'cauchit', 'log',
'loglog', 'double exponential', 'double reciprocal', 'power logit'. 
The default is 'cloglog'. The 'power logit' has an attribute of 'power' for
which the default is 1 i.e., a logit link.
</p>
</td></tr>
<tr><td><code id="LL.Regression.Binary_+3A_ntrials">ntrials</code></td>
<td>

<p>A vector length 'n+1' representing the number of trials 'n' i.e., a vector 
with all elements equal to 'n'.
</p>
</td></tr>
<tr><td><code id="LL.Regression.Binary_+3A_nsuccess">nsuccess</code></td>
<td>

<p>A vector representing the frequency distribution of the binomial 
distribution for fixed number of trials 'n'. 
</p>
</td></tr>
<tr><td><code id="LL.Regression.Binary_+3A_covariates.matrix.p">covariates.matrix.p</code></td>
<td>

<p>A matrix of covariates for the mean where rows are the number of values in 
list.binary and columns the covariates. This matrix is extracted from the 
formulae in function BinaryEPPM. However, in the accompanying example it 
is shown how it can be constructed independently of function BinaryEPPM. 
</p>
</td></tr>
<tr><td><code id="LL.Regression.Binary_+3A_covariates.matrix.scalef">covariates.matrix.scalef</code></td>
<td>

<p>A matrix of covariates for the variance where rows are the number of 
values in list.binary and columns the covariates. The default is a 
vector of ones. This matrix is extracted from the formulae in function 
BinaryEPPM. However, in the accompanying example it is shown how it 
can be constructed independently of function BinaryEPPM. 
</p>
</td></tr>
<tr><td><code id="LL.Regression.Binary_+3A_offset.p">offset.p</code></td>
<td>

<p>An offset vector for the probability of success p. The default 
is a vector of ones.
</p>
</td></tr>
<tr><td><code id="LL.Regression.Binary_+3A_offset.scalef">offset.scalef</code></td>
<td>

<p>An offset vector for the scale-factor. The default is a 
vector of ones.
</p>
</td></tr>
<tr><td><code id="LL.Regression.Binary_+3A_weights">weights</code></td>
<td>

<p>A vector or list of weights for the modeling of probability of success. The default is a vector of ones.
</p>
</td></tr>
<tr><td><code id="LL.Regression.Binary_+3A_grad.method">grad.method</code></td>
<td>

<p>Numerical method used to calculate gradients either simple or Richardson. The default 
is simple.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The log likelihood is returned.
</p>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Faddy M, Smith D. (2012). Extended Poisson Process Modeling and 
Analysis of Grouped Binary Data. <em>Biometrical Journal</em>, <b>54</b>, 426-435.
<a href="https://doi.org/10.1002/bimj.201100214">doi:10.1002/bimj.201100214</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>link &lt;- 'cloglog'
attr(link, which="p") &lt;- make.link(link)
nsuccess &lt;- list(c(rep(0,5),352,479,530,291,101,17))
ntrials  &lt;- list(c(rep(10,11)))
parameter &lt;- c(0.06363398,-0.47085362)
LL.Regression.Binary(parameter, model.type = "p and scale-factor",
            model.name = "EPPM extended binomial", link, ntrials, nsuccess, 
            covariates.matrix.p = matrix(c(1), nrow=1),
            covariates.matrix.scalef = matrix(c(1), nrow=1),
            offset.p = c(0), offset.scalef = c(0),
            weights = list(c(rep(1,11)))) 
</code></pre>

<hr>
<h2 id='logLik.BinaryEPPM'>
Extract Log-Likelihood
</h2><span id='topic+logLik.BinaryEPPM'></span>

<h3>Description</h3>

<p>This function is generic. It is a method for extracting the log-likelihood for objects of class &quot;BinaryEPPM&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BinaryEPPM'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.BinaryEPPM_+3A_object">object</code></td>
<td>

<p>fitted model object of class &quot;BinaryEPPM&quot;.
</p>
</td></tr>
<tr><td><code id="logLik.BinaryEPPM_+3A_...">...</code></td>
<td>

<p>some methods for this generic function require additional arguments
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>logLik is most commonly used for a model fitted by maximum likelihood as is done here.
</p>


<h3>Value</h3>

<p>The log likelihood value for the fitted model object.
</p>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>See Also</h3>

<p><code><a href="betareg.html#topic+betareg">betareg</a></code> 
</p>

<hr>
<h2 id='loglog'>
Log-log Link Function
</h2><span id='topic+loglog'></span>

<h3>Description</h3>

<p>Computes the loglog link function, including its inverse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglog()
</code></pre>


<h3>Details</h3>

<p>Same link function as in Cribari-Neto and Zeileis (2010).
</p>


<h3>Value</h3>

<p>The loglog of theta where the logarithms are to base e.
</p>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Cribari-Neto F, Zeileis A. (2010). Beta Regression in R.
<em>Journal of Statistical Software</em>, <b>34</b>(2), 1-24. 
<a href="https://doi.org/10.18637/jss.v034.i02">doi:10.18637/jss.v034.i02</a>.
</p>

<hr>
<h2 id='Model.BCBinProb'>
Probabilities for beta and correlated binomial distributions given p's and scale-factors. 
</h2><span id='topic+Model.BCBinProb'></span>

<h3>Description</h3>

<p>Calculates the probabilities for beta and correlated binomials given values for p's and 
scale-factors. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Model.BCBinProb(parameter, model.type, model.name, link, ntrials, covariates.matrix.p, 
covariates.matrix.scalef = matrix(c(rep(1, nrow(covariates.matrix.p))), ncol = 1), 
offset.p = c(rep(0, length(ntrials))), offset.scalef = c(rep(0, length(ntrials))))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Model.BCBinProb_+3A_parameter">parameter</code></td>
<td>

<p>A vector of the parameters of the model which is set to initial estimates on function call.
</p>
</td></tr>
<tr><td><code id="Model.BCBinProb_+3A_model.type">model.type</code></td>
<td>

<p>Takes one of two values i.e. 'p only' or 'p and scale-factor'. The 'p only' value fits a 
linear predictor function to the parameter p which is the 'm(1)' in equation (6) of 
Faddy and Smith (2012) divided by 'N'. The 'p and scale-factor' value fits linear predictor 
functions to both p and the scale-factor.
</p>
</td></tr>
<tr><td><code id="Model.BCBinProb_+3A_model.name">model.name</code></td>
<td>

<p>The model being fitted is one of the two 'beta binomial' or 'correlated binomial'. 
</p>
</td></tr>
<tr><td><code id="Model.BCBinProb_+3A_link">link</code></td>
<td>

<p>Takes one of nine values i.e., 'logit', 'probit', 'cloglog', 'cauchit', 'log',
'loglog', 'double exponential', 'double reciprocal', 'power logit'. 
The default is 'cloglog'. The 'power logit' has an attribute of 'power' for
which the default is 1 i.e., a logit link.
</p>
</td></tr>
<tr><td><code id="Model.BCBinProb_+3A_ntrials">ntrials</code></td>
<td>

<p>This is a scalar representing the denominator i.e., the length of the probability 
mass function returned is this scalar + 1.
</p>
</td></tr>
<tr><td><code id="Model.BCBinProb_+3A_covariates.matrix.p">covariates.matrix.p</code></td>
<td>

<p>A matrix of covariates for p where rows are the number of values in listbinary and 
columns the covariates. This matrix is extracted from the formulae in function BinaryEPPM. 
However, in the accompanying example it is shown how it can be constructed independently 
of function BinaryEPPM. 
</p>
</td></tr>
<tr><td><code id="Model.BCBinProb_+3A_covariates.matrix.scalef">covariates.matrix.scalef</code></td>
<td>

<p>A matrix of covariates for the scale-factor where rows are the number of values in listbinary 
and columns the covariates. The default is a vector of ones. This matrix is extracted from the 
formulae in function BinaryEPPM. However, in the accompanying example it is shown how it can 
be constructed independently of function BinaryEPPM. 
</p>
</td></tr>
<tr><td><code id="Model.BCBinProb_+3A_offset.p">offset.p</code></td>
<td>

<p>An offset vector for p. The default is a vector of ones.
</p>
</td></tr>
<tr><td><code id="Model.BCBinProb_+3A_offset.scalef">offset.scalef</code></td>
<td>

<p>An offset vector for the scale-factor. The default is a vector of ones.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of arguments input together with a list of probabilities vectors and a data frame of 
values of p, theta (beta binomial) or rho (correlated binomial) and the limits for theta or rho. 
</p>
<table>
<tr><td><code>model</code></td>
<td>

<p>The model is either 'beta binomial' or 'correlated binomial'. 
</p>
</td></tr>
<tr><td><code>link</code></td>
<td>

<p>The link is either 'logit' or 'cloglog'.
</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>

<p>A vector of the parameters of the model which is set to initial estimates on function call.
</p>
</td></tr>
<tr><td><code>probabilities</code></td>
<td>

<p>A list of the vectors of probabilities of the model.
</p>
</td></tr>
<tr><td><code>probabilities</code></td>
<td>

<p>A data frame of values of p, theta (beta binomial) or rho (correlated binomial) and 
the limits for theta or rho. 
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Hughes G, Madden L (1995). Some methods allowing for aggregated patterns of disease 
incidence in the analysis of data from designed experiments. Plant Pathology, 44, 927-943.
</p>
<p>Kupper L, Haseman J (1978). The use of a correlated binomial model for the analysis 
of toxicological epxeriments. Biometrics, 34(1), 69-76.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>link &lt;- 'cloglog'
attr(link, which="p") &lt;- make.link(link)
parameter &lt;- c(-0.68294630,0.03451481)
names(parameter) &lt;- c('p','rho')
model.type &lt;- 'p and scale-factor'
model.name &lt;- 'correlated binomial'
ntrials    &lt;- list(c(rep(10,11)))
Model.BCBinProb(parameter, model.type, model.name, link, ntrials,
                covariates.matrix.p = matrix(c(1),nrow=1), 
                covariates.matrix.scalef = matrix(c(1),nrow=1),
                offset.p = c(0), offset.scalef = c(0))
</code></pre>

<hr>
<h2 id='Model.Binary'>
Function for obtaining output from distributional models.
</h2><span id='topic+Model.Binary'></span>

<h3>Description</h3>

<p>Produces output of model, parameters and probabilities from the various models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Model.Binary(parameter, model.type, model.name, link, ntrials, covariates.matrix.p, 
covariates.matrix.scalef, offset.p, offset.scalef)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Model.Binary_+3A_parameter">parameter</code></td>
<td>

<p>A vector of the parameters of the model which is set to initial estimates on function call.
</p>
</td></tr>
<tr><td><code id="Model.Binary_+3A_model.type">model.type</code></td>
<td>

<p>Takes one of two values i.e. 'p only' or 'p and scale-factor'. The 'p only' value fits a 
linear predictor function to the parameter p which is the 'm(1)' in equation (6) of 
Faddy and Smith (2012) divided by 'N'. The 'p and scale-factor' value fits linear predictor 
functions to both p and the scale-factor.
</p>
</td></tr>
<tr><td><code id="Model.Binary_+3A_model.name">model.name</code></td>
<td>

<p>If model.type is 'p only' the model being fitted is one of the six 'binomial', 'over-dispersed-one', 
'over-dispersed-two', 'EPPM binomial', 'beta binomial' or 'correlated binomial'. If model.type 
is 'p and scale-factor' the model being fitted is one of the three 'EPPM binomial', 
'beta binomial' or 'correlated binomial'.
</p>
</td></tr>
<tr><td><code id="Model.Binary_+3A_link">link</code></td>
<td>

<p>Takes one of nine values i.e., 'logit', 'probit', 'cloglog', 'cauchit', 'log',
'loglog', 'double exponential', 'double reciprocal', 'power logit'. 
The default is 'cloglog'. The 'power logit' has an attribute of 'power' for
which the default is 1 i.e., a logit link.
</p>
</td></tr>
<tr><td><code id="Model.Binary_+3A_ntrials">ntrials</code></td>
<td>

<p>This is a scalar representing the denominator i.e., the length of the probability mass 
function returned is this scalar + 1.
</p>
</td></tr>
<tr><td><code id="Model.Binary_+3A_covariates.matrix.p">covariates.matrix.p</code></td>
<td>

<p>A matrix of covariates for p where rows are the number of values in listbinary and columns 
the covariates. This matrix is extracted from the formulae in function BinaryEPPM. However, 
in the accompanying example it is shown how it can be constructed independently of function BinaryEPPM. 
</p>
</td></tr>
<tr><td><code id="Model.Binary_+3A_covariates.matrix.scalef">covariates.matrix.scalef</code></td>
<td>

<p>A matrix of covariates for the scale-factor where rows are the number of values in listbinary 
and columns the covariates. The default is a vector of ones. This matrix is extracted from the 
formulae in function BinaryEPPM. However, in the accompanying example it is shown how it can 
be constructed independently of function BinaryEPPM. 
</p>
</td></tr>
<tr><td><code id="Model.Binary_+3A_offset.p">offset.p</code></td>
<td>

<p>An offset vector for p. The default is a vector of ones.
</p>
</td></tr>
<tr><td><code id="Model.Binary_+3A_offset.scalef">offset.scalef</code></td>
<td>

<p>An offset vector for the scale-factor. The default is a vector of ones.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output from either Model.BCBinProb, Model.GB, Model.Binary, Model.JMVGB, or Model.ODB.
</p>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Faddy M, Smith D. (2012). Extended Poisson Process Modeling and 
Analysis of Grouped Binary Data. <em>Biometrical Journal</em>, <b>54</b>, 426-435.
<a href="https://doi.org/10.1002/bimj.201100214">doi:10.1002/bimj.201100214</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>link &lt;- 'cloglog'
attr(link, which="p") &lt;- make.link(link)
parameter &lt;- c(-0.68294630,0.03451481)
names(parameter) &lt;- c('p','rho')
model.type &lt;- 'p and scale-factor'
model.name &lt;- 'correlated binomial'
ntrials    &lt;- list(c(rep(10,11)))
Model.Binary(parameter, model.type, model.name, link, ntrials,
             covariates.matrix.p = matrix(c(1),nrow=1), 
             covariates.matrix.scalef = matrix(c(1),nrow=1),
             offset.p = c(0), offset.scalef = c(0))
</code></pre>

<hr>
<h2 id='Model.GB'>
Probabilities for binomial and EPPM extended binomial distributions given p's and b. 
</h2><span id='topic+Model.GB'></span>

<h3>Description</h3>

<p>Calculates the probabilities for binomial and EPPM extended binomial given values 
for p's and b. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Model.GB(parameter, model.name, link, ntrials, covariates.matrix.p, 
         offset.p = c(rep(0, length(ntrials))))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Model.GB_+3A_parameter">parameter</code></td>
<td>

<p>A vector of the parameters of the model which is set to initial estimates 
on function call.
</p>
</td></tr>
<tr><td><code id="Model.GB_+3A_model.name">model.name</code></td>
<td>

<p>The model being fitted is one of the two 'binomial' or 'EPPM extended binomial'. 
</p>
</td></tr>
<tr><td><code id="Model.GB_+3A_link">link</code></td>
<td>

<p>Takes one of nine values i.e., 'logit', 'probit', 'cloglog', 'cauchit', 'log',
'loglog', 'double exponential', 'double reciprocal', 'power logit'. 
The default is 'cloglog'. The 'power logit' has an attribute of 'power' for
which the default is 1 i.e., a logit link.
</p>
</td></tr>
<tr><td><code id="Model.GB_+3A_ntrials">ntrials</code></td>
<td>

<p>This is a scalar representing the denominator i.e., the length of the 
probability mass function returned is this scalar + 1.
</p>
</td></tr>
<tr><td><code id="Model.GB_+3A_covariates.matrix.p">covariates.matrix.p</code></td>
<td>

<p>A matrix of covariates for p where rows are the number of values in 
listbinary and columns the covariates. This matrix is extracted from 
the formulae in function BinaryEPPM. However, in the accompanying example 
it is shown how it can be constructed independently of function BinaryEPPM. 
</p>
</td></tr>
<tr><td><code id="Model.GB_+3A_offset.p">offset.p</code></td>
<td>

<p>An offset vector for p. The default is a vector of ones.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of arguments input together with a list of probabilities vectors and 
a data frame of values of a and b of Equation (5) of Faddy and Smith (2012). 
</p>
<table>
<tr><td><code>model</code></td>
<td>

<p>The model is either 'binomial' or 'EPPM extended binomial'. 
</p>
</td></tr>
<tr><td><code>link</code></td>
<td>

<p>The link is either 'logit' or 'cloglog'.
</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>

<p>A vector of the parameters of the model which is set to initial estimates 
on function call.
</p>
</td></tr>
<tr><td><code>probabilities</code></td>
<td>

<p>A list of the vectors of probabilities of the model.
</p>
</td></tr>
<tr><td><code>Dparameters</code></td>
<td>

<p>A data frame of values of a and b of Equation (5) of Faddy and Smith (2012).  
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Faddy M, Smith D. (2012). Extended Poisson Process Modeling and 
Analysis of Grouped Binary Data. <em>Biometrical Journal</em>, <b>54</b>, 426-435.
<a href="https://doi.org/10.1002/bimj.201100214">doi:10.1002/bimj.201100214</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>link &lt;- 'cloglog'
attr(link, which="p") &lt;- make.link(link)
parameter &lt;- c(0.9423342,0.5846321)
names(parameter) &lt;- c('p','b')
model.name &lt;- 'EPPM extended binomial'
ntrials &lt;- list(c(rep(10,11)))
Model.GB(parameter, model.name, link, ntrials, 
         covariates.matrix.p = matrix(c(1),ncol=1), 
         offset.p = c(0))
</code></pre>

<hr>
<h2 id='Model.JMVGB'>
Probabilities for EPPM extended binomial distributions given p's 
and scale-factors. 
</h2><span id='topic+Model.JMVGB'></span>

<h3>Description</h3>

<p>Calculates the probabilities for binomial and generalized 
binomial given values for p's and scale-factors. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Model.JMVGB(parameter, model.name, link, ntrials, 
            covariates.matrix.p, covariates.matrix.scalef, 
            offset.p = c(rep(0, length(ntrials))), 
            offset.scalef = c(rep(0, length(ntrials))))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Model.JMVGB_+3A_parameter">parameter</code></td>
<td>

<p>A vector of the parameters of the model which is set to initial 
estimates on function call.
</p>
</td></tr>
<tr><td><code id="Model.JMVGB_+3A_model.name">model.name</code></td>
<td>

<p>The model being fitted is one of the two 'binomial' or 
'EPPM extended binomial'. 
</p>
</td></tr>
<tr><td><code id="Model.JMVGB_+3A_link">link</code></td>
<td>

<p>Takes one of nine values i.e., 'logit', 'probit', 'cloglog', 'cauchit', 'log',
'loglog', 'double exponential', 'double reciprocal', 'power logit'. 
The default is 'cloglog'. The 'power logit' has an attribute of 'power' for
which the default is 1 i.e., a logit link.
</p>
</td></tr>
<tr><td><code id="Model.JMVGB_+3A_ntrials">ntrials</code></td>
<td>

<p>This is a scalar representing the denominator i.e., the 
length of the probability mass function returned is 
this scalar + 1.
</p>
</td></tr>
<tr><td><code id="Model.JMVGB_+3A_covariates.matrix.p">covariates.matrix.p</code></td>
<td>

<p>A matrix of covariates for p where rows are the number of 
values in listbinary and columns the covariates. This 
matrix is extracted from the formulae in function BinaryEPPM. 
However, in the accompanying example it is shown how it 
can be constructed independently of function BinaryEPPM. 
</p>
</td></tr>
<tr><td><code id="Model.JMVGB_+3A_covariates.matrix.scalef">covariates.matrix.scalef</code></td>
<td>

<p>A matrix of covariates for the scale-factor where rows are 
the number of values in listbinary and columns the covariates. 
The default is a vector of ones. This matrix is extracted 
from the formulae in function BinaryEPPM. However, in the 
accompanying example it is shown how it can be constructed 
independently of function BinaryEPPM. 
</p>
</td></tr>
<tr><td><code id="Model.JMVGB_+3A_offset.p">offset.p</code></td>
<td>

<p>An offset vector for p. The default is a vector of ones.
</p>
</td></tr>
<tr><td><code id="Model.JMVGB_+3A_offset.scalef">offset.scalef</code></td>
<td>

<p>An offset vector for the scale-factor. The default is 
a vector of ones.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of arguments input together with a list of probabilities 
vectors and a data frame of values of a and b of Equation (5) 
of Faddy and Smith (2012). 
</p>
<table>
<tr><td><code>model</code></td>
<td>

<p>The model is either 'binomial' or 'EPPM extended binomial'. 
</p>
</td></tr>
<tr><td><code>link</code></td>
<td>

<p>The link is either 'logit' or 'cloglog'.
</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>

<p>A vector of the parameters of the model which is set to 
initial estimates on function call.
</p>
</td></tr>
<tr><td><code>probabilities</code></td>
<td>

<p>A list of the vectors of probabilities of the model.
</p>
</td></tr>
<tr><td><code>Dparameters</code></td>
<td>

<p>A data frame of values of a and b of Equation (5) of 
Faddy and Smith (2012).  
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Faddy M, Smith D. (2012). Extended Poisson Process Modeling and 
Analysis of Grouped Binary Data. <em>Biometrical Journal</em>, <b>54</b>, 426-435.
<a href="https://doi.org/10.1002/bimj.201100214">doi:10.1002/bimj.201100214</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>link &lt;- 'cloglog'
attr(link, which="p") &lt;- make.link(link)
parameter &lt;- c(-0.68294630,0.03451481)
names(parameter) &lt;- c('p','scale-factor')
model.name &lt;- 'EPPM extended binomial'
ntrials &lt;- list(c(rep(10,11)))
Model.JMVGB(parameter, model.name, link, ntrials, 
            covariates.matrix.p = matrix(c(1),nrow=1), 
            covariates.matrix.scalef = matrix(c(1),nrow=1), 
            offset.p = c(0), offset.scalef = c(0))
</code></pre>

<hr>
<h2 id='negcomplog'>
Negative complementary log-log Link Function
</h2><span id='topic+negcomplog'></span>

<h3>Description</h3>

<p>Computes the negative complementary log-log link function, including its inverse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>negcomplog()
</code></pre>


<h3>Value</h3>

<p>The negative complementary log-log of theta.
</p>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Tibshirani RJ, Ciampi A (1983). &quot;A Family of Proportional- and Additive-Hazards Models for Survival Data&quot;. Biometrics 39(1), 141-147.
</p>

<hr>
<h2 id='Parkes.litters'>
The data are of the number of male piglets born in litters of varying sizes for
the Parkes breed of pigs. 
</h2><span id='topic+Parkes.litters'></span>

<h3>Description</h3>

 
<p>The data are arranged as a list of binomial frequency distributions where the 
listing is by litter size which is included both as a variate (vsize) and as 
a factor (fsize)</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Parkes.litters")</code></pre>


<h3>Format</h3>

<p>The format is:
List of 3
$ fsize         : Factor w/ 7 levels &quot; size 5&quot;,&quot; size 6&quot;,..: 1 2 3 4 5 6 7
$ vsize         : int [1:7] 5 6 7 8 9 10 11
$ number.success:List of 7
..$ : num [1:6] 2 20 41 35 14 4
..$ : num [1:7] 3 16 53 78 53 18 0
..$ : num [1:8] 0 21 63 117 104 46 21 2
..$ : num [1:9] 1 8 37 81 162 77 30 5 1
..$ : num [1:10] 0 2 23 72 101 83 46 12 7 0
..$ : num [1:11] 0 7 8 19 79 82 48 24 10 0 ...
..$ : num [1:12] 0 1 3 15 15 33 13 12 8 1 ...
</p>


<h3>Source</h3>

<p>Brooks, R.J., James, W.H., Gray, E. (1993). Modelling Sub-Binomial Variation 
in the Frequency of Sex Combinations in Litters of Pigs. Biometrics 47, 403-417.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Parkes.litters")
</code></pre>

<hr>
<h2 id='plot.BinaryEPPM'>
Diagnostic Plots for BinaryEPPM Objects
</h2><span id='topic+plot.BinaryEPPM'></span>

<h3>Description</h3>

<p>This function is generic. Various types of standard diagnostic plots can be produced, involving various 
types of residuals, influence measures etc. It is a minorly modified version of the generic plot function 
of <span class="pkg">betareg</span> with details of the displays given in Cribari-Neto and Zeileis (2010). The same six displays and arguments list as in Cribari-Neto and Zeileis (2010) are used. The six displays are
&quot;Residuals vs indices of obs&quot;, &quot;Cook's distance plot&quot;, &quot;Leverage vs predicted values&quot;,
&quot;Residuals vs linear predictor&quot;, &quot;Normal Q-Q plot of residuals&quot;, &quot;Predicted vs observed values&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BinaryEPPM'
plot(x, which = 1:4,
    caption = c("Residuals vs indices of obs.", "Cook's distance plot",
    "Leverage vs predicted values", "Residuals vs linear predictor",
    "Normal Q-Q plot of residuals", "Predicted vs observed values"),
    sub.caption = " ", main = "", 
    ask = prod(par("mfcol"), 1) &lt; length(which) &amp;&amp; dev.interactive(),
    ..., type = "spearson")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.BinaryEPPM_+3A_x">x</code></td>
<td>

<p>fitted model object of class &quot;BinaryEPPM&quot;.
</p>
</td></tr>
<tr><td><code id="plot.BinaryEPPM_+3A_which">which</code></td>
<td>

<p>numeric. If a subset of plots is required, specify a subset of the numbers 1:6.
</p>
</td></tr>
<tr><td><code id="plot.BinaryEPPM_+3A_caption">caption</code></td>
<td>

<p>character. Captions to appear above the plots.
</p>
</td></tr>
<tr><td><code id="plot.BinaryEPPM_+3A_sub.caption">sub.caption</code></td>
<td>

<p>character. Common title-above figures if there are multiple.
</p>
</td></tr>
<tr><td><code id="plot.BinaryEPPM_+3A_main">main</code></td>
<td>

<p>character. Title to each plot in addition to the above caption.
</p>
</td></tr>
<tr><td><code id="plot.BinaryEPPM_+3A_ask">ask</code></td>
<td>

<p>logical. If true, the user is asked before each plot.
</p>
</td></tr>
<tr><td><code id="plot.BinaryEPPM_+3A_...">...</code></td>
<td>

<p>other parameters to be passed through to plotting functions.
</p>
</td></tr>
<tr><td><code id="plot.BinaryEPPM_+3A_type">type</code></td>
<td>

<p>character indicating type of residual to be used, see residuals.BinaryEPPM.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plot method for BinaryEPPM objects produces various plots of diagnostic plots similar to those produced by <span class="pkg">betareg</span>. See Cribari-Neto and Zeileis (2010) for further details of the displays of <span class="pkg">betareg</span>.
</p>


<h3>Value</h3>

<p>No return value.</p>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Cribari-Neto F, Zeileis A. (2010). Beta Regression in R.
<em>Journal of Statistical Software</em>, <b>34</b>(2), 1-24. <a href="https://doi.org/10.18637/jss.v034.i02">doi:10.18637/jss.v034.i02</a>.
</p>


<h3>See Also</h3>

<p><code><a href="betareg.html#topic+plot.betareg">plot.betareg</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("ropespores.case") 
output.fn &lt;- BinaryEPPM(data = ropespores.case,
                  number.spores / number.tested ~ 1 + offset(logdilution),
                  model.type = 'p only', model.name = 'binomial')  
plot.BinaryEPPM(output.fn, which = 1, type= "sdeviance")
</code></pre>

<hr>
<h2 id='powerlogit'>
Power Logit Link Function
</h2><span id='topic+powerlogit'></span>

<h3>Description</h3>

<p>Computes the power logit link function, including its inverse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powerlogit(power = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="powerlogit_+3A_power">power</code></td>
<td>

<p>power value for the power logit link function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The power logit transformation of theta. All logarithms are natural ones, i.e., 
to base e.
</p>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Gaudard MA, Karson MJ, Linder E, Tse Sk (1993). Efficient Designs for Estimation 
in the Power Logistic Quantal Response Model.&quot; Statistica Sinica, 3, 233-243.
</p>

<hr>
<h2 id='predict.BinaryEPPM'>
Prediction Method for BinaryEPPM Objects
</h2><span id='topic+predict.BinaryEPPM'></span>

<h3>Description</h3>

<p>Extract various types of predictions from BinaryEPPM regression models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BinaryEPPM'
predict(object, newdata = NULL, type = c("response", 
     "linear.predictor.p", "linear.predictor.scale.factor",
 "p", "scale.factor", "scale.factor.limits", "mean", 
 "variance",   "distribution", "distribution.parameters"), na.action = na.pass, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.BinaryEPPM_+3A_object">object</code></td>
<td>

<p>fitted model object of class &quot;BinaryEPPM&quot;.
</p>
</td></tr>
<tr><td><code id="predict.BinaryEPPM_+3A_newdata">newdata</code></td>
<td>

<p>optionally, a data frame in which to look for variables with which to predict. If omitted, 
the original observations are used.
</p>
</td></tr>
<tr><td><code id="predict.BinaryEPPM_+3A_type">type</code></td>
<td>

<p>character indicating type of predictions: fitted means of responses (&quot;response&quot;), 
linear predictors (&quot;linear.predictor.p&quot;, &quot;linear.predictor.scale.factor&quot;), 
fitted value of probability of success (&quot;p&quot;),
fitted value of scale-factor (&quot;scale.factor&quot;), fitted value of mean (&quot;mean&quot;),
scale factor limits (&quot;scale.factor.limits&quot;), 
fitted value of variance (&quot;variance&quot;), fitted probability distribution (&quot;distribution&quot;),
parameters of fitted distributions (&quot;distribution.parameters&quot;)
</p>
</td></tr>
<tr><td><code id="predict.BinaryEPPM_+3A_na.action">na.action</code></td>
<td>

<p>function determining what should be done with missing values in <em>newdata</em>. The 
default is to predict NA.
</p>
</td></tr>
<tr><td><code id="predict.BinaryEPPM_+3A_...">...</code></td>
<td>

<p>some methods for this generic function require additional arguments.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector or list of the predicted values from the fitted model object.
</p>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Cribari-Neto F, Zeileis A. (2010). Beta Regression in R.
<em>Journal of Statistical Software</em>, <b>34</b>(2), 1-24. <a href="https://doi.org/10.18637/jss.v034.i02">doi:10.18637/jss.v034.i02</a>.
</p>


<h3>See Also</h3>

<p><code><a href="betareg.html#topic+predict.betareg">predict.betareg</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("ropespores.case")
output.fn &lt;- BinaryEPPM(data = ropespores.case,
                  number.spores / number.tested ~ 1 + offset(logdilution),
                  model.type = 'p only', model.name = 'binomial')                 
predict(output.fn, type = "response")
predict(output.fn, type = "linear.predictor.p")
</code></pre>

<hr>
<h2 id='print.BinaryEPPM'>
Printing of BinaryEPPM Objects
</h2><span id='topic+print.BinaryEPPM'></span>

<h3>Description</h3>

<p>Prints objects of class &quot;BinaryEPPM&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BinaryEPPM'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.BinaryEPPM_+3A_x">x</code></td>
<td>

<p>fitted model object of class &quot;BinaryEPPM&quot;.
</p>
</td></tr>
<tr><td><code id="print.BinaryEPPM_+3A_digits">digits</code></td>
<td>

<p>digits of printed output.
</p>
</td></tr>
<tr><td><code id="print.BinaryEPPM_+3A_...">...</code></td>
<td>

<p>not currently used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;BinaryEPPM&quot; is constructed. This object has the following attributes.
</p>
<table>
<tr><td><code>data.type</code></td>
<td>

<p>Indicator of the type of data either 0 &quot;data.frame&quot; or 1 &quot;list&quot;.
</p>
</td></tr>
<tr><td><code>list.data</code></td>
<td>

<p>Regardless of the &quot;data.type&quot;, the data in list form.
</p>
</td></tr>
<tr><td><code>call</code></td>
<td>

<p>The &quot;call&quot; to the function &quot;BinaryEPPM&quot;.
</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>

<p>The model formula in &quot;call&quot;.
</p>
</td></tr>
<tr><td><code>model.type</code></td>
<td>

<p>The model type in &quot;call&quot;.
</p>
</td></tr>
<tr><td><code>model.name</code></td>
<td>

<p>The model name in &quot;call&quot;.
</p>
</td></tr>
<tr><td><code>link</code></td>
<td>

<p>The link function in &quot;call&quot;.
</p>
</td></tr>
<tr><td><code>covariates.matrix.p</code></td>
<td>

<p>The matrix of covariates for the model for p.
</p>
</td></tr>
<tr><td><code>covariates.matrix.scalef</code></td>
<td>

<p>The matrix of covariates for the model for scale-factor.
</p>
</td></tr>
<tr><td><code>offset.p</code></td>
<td>

<p>The vector of offsets for the model for p.
</p>
</td></tr>
<tr><td><code>offset.scalef</code></td>
<td>

<p>The vector of offsets for the model for scale-factor.
</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>

<p>The coefficients of the fitted model.
</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>

<p>The log-likelihood of the fitted model.
</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>

<p>The variance-covariance matrix of the fitted model.
</p>
</td></tr>
<tr><td><code>n</code></td>
<td>

<p>The number of observations. Relabelled duplication of &quot;nobs&quot; needed when calling function &quot;lrtest&quot;. 
</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>

<p>The number of observations.
</p>
</td></tr>
<tr><td><code>df.null</code></td>
<td>

<p>The degrees of freedom of the null model.
</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>

<p>The degrees of freedom of the residual model.
</p>
</td></tr>
<tr><td><code>vnmax</code></td>
<td>

<p>Vector of number of &quot;trials&quot; in each observation.
</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>

<p>Vector of weights for observation.
</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>

<p>Indicator of convergence.
</p>
</td></tr>
<tr><td><code>method</code></td>
<td>

<p>Method used to calculate pseudo.r.squared.
</p>
</td></tr>
<tr><td><code>pseudo.r.squared</code></td>
<td>

<p>The value of the coefficient of determination r squared.
</p>
</td></tr>
<tr><td><code>start</code></td>
<td>

<p>Initial estimates.
</p>
</td></tr>
<tr><td><code>optim</code></td>
<td>

<p>Final model fit.
</p>
</td></tr>
<tr><td><code>control</code></td>
<td>

<p>Control parameters for optimization function &quot;optim&quot;.
</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>

<p>The fitted values.
</p>
</td></tr>
<tr><td><code>y</code></td>
<td>

<p>The dependent variable in the model.
</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>

<p>The terms in the model.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Cribari-Neto F, Zeileis A. (2010). Beta Regression in R.
<em>Journal of Statistical Software</em>, <b>34</b>(2), 1-24. <a href="https://doi.org/10.18637/jss.v034.i02">doi:10.18637/jss.v034.i02</a>.
</p>


<h3>See Also</h3>

<p><code><a href="betareg.html#topic+betareg">betareg</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("ropespores.case") 
BinaryEPPM(data = ropespores.case,
           number.spores / number.tested ~ 1 + offset(logdilution),
           model.type = 'p only', model.name = 'binomial')   
</code></pre>

<hr>
<h2 id='print.summaryBinaryEPPM'>
Printing of summaryBinaryEPPM Objects 
</h2><span id='topic+print.summaryBinaryEPPM'></span>

<h3>Description</h3>

<p>Prints the objects of class &quot;summaryBinaryEPPM&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summaryBinaryEPPM'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summaryBinaryEPPM_+3A_x">x</code></td>
<td>

<p>object output by <code>summary.BinaryEPPM</code>.
</p>
</td></tr>
<tr><td><code id="print.summaryBinaryEPPM_+3A_...">...</code></td>
<td>

<p>not currently used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.</p>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Cribari-Neto F, Zeileis A. (2010). Beta Regression in R.
<em>Journal of Statistical Software</em>, <b>34</b>(2), 1-24. <a href="https://doi.org/10.18637/jss.v034.i02">doi:10.18637/jss.v034.i02</a>.
</p>


<h3>See Also</h3>

<p><code><a href="betareg.html#topic+betareg">betareg</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("ropespores.case") 
output.fn &lt;- BinaryEPPM(data = ropespores.case,
                  number.spores / number.tested ~ 1 + offset(logdilution),
                  model.type = 'p only', model.name = 'binomial')   
print(summary(output.fn))
</code></pre>

<hr>
<h2 id='residuals.BinaryEPPM'>
Residuals for BinaryEPPM Objects
</h2><span id='topic+residuals.BinaryEPPM'></span>

<h3>Description</h3>

<p>This function is generic. Extract various types of residuals from objects of class &quot;BinaryEPPM&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BinaryEPPM'
residuals(object, type = c("spearson", "deviance", "pearson",
        "response", "likelihood", "sdeviance"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.BinaryEPPM_+3A_object">object</code></td>
<td>

<p>Fitted model object of class &quot;BinaryEPPM&quot;.
</p>
</td></tr>
<tr><td><code id="residuals.BinaryEPPM_+3A_type">type</code></td>
<td>

<p>Type of residuals wanted i.e., standardized Pearson &quot;spearson&quot;, deviance &quot;deviance&quot;, 
Pearson &quot;pearson&quot;,response &quot;response&quot;, likelihood &quot;likelihood&quot;, standardized deviance &quot;sdeviance&quot;.
</p>
</td></tr>
<tr><td><code id="residuals.BinaryEPPM_+3A_...">...</code></td>
<td>

<p>Some methods for this generic function require additional arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Residuals as Cribari-Neto and Zeileis (2010).
</p>


<h3>Value</h3>

<p>An vector of class &quot;numeric&quot; of residuals of a specified type from the object of class &quot;BinaryEPMM&quot;.
</p>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Cribari-Neto F, Zeileis A. (2010). Beta Regression in R.
<em>Journal of Statistical Software</em>, <b>34</b>(2), 1-24. <a href="https://doi.org/10.18637/jss.v034.i02">doi:10.18637/jss.v034.i02</a>.
</p>


<h3>See Also</h3>

<p><code><a href="betareg.html#topic+residuals.betareg">residuals.betareg</a></code> 
</p>

<hr>
<h2 id='ropespores.case'>
Dilution series for the presence of rope spores.
</h2><span id='topic+ropespores.case'></span>

<h3>Description</h3>

<p>Dilution series where at each dilution of a suspension of potato flour a number of 
samples were examined for the presence of rope spores. These data are in data frame form. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("ropespores.case")</code></pre>


<h3>Format</h3>

<p>A data frame with 10 observations on the following 5 variables.
</p>

<dl>
<dt><code>vdilution</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>fdilution</code></dt><dd><p>a factor with levels <code>0.25</code> <code>0.5</code> <code>1</code> <code>2</code> <code>4</code> <code>8</code> <code>16</code> <code>32</code> <code>64</code> <code>128</code></p>
</dd>
<dt><code>logdilution</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>number.spores</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>number.tested</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>Finney, D.J. (1971). Statistical Methods in Biological Assay. Griffin, London, 2nd edition.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("ropespores.case")
</code></pre>

<hr>
<h2 id='ropespores.grouped'>
Dilution series for the presence of rope spores.
</h2><span id='topic+ropespores.grouped'></span>

<h3>Description</h3>

<p>Dilution series where at each dilution of a suspension of potato flour a number of samples were examined for the presence of rope spores. These data are in list form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("ropespores.grouped")</code></pre>


<h3>Format</h3>

<p>The format is:
List of 4
$ vdilution    : num [1:10] 0.25 0.5 1 2 4 8 16 32 64 128
$ fdilution    : Factor w/ 10 levels &quot;0.25&quot;,&quot;0.5&quot;,&quot;1&quot;,..: 1 2 3 4 5 6 7 8 9 10
$ offset.p     : num [1:10] 1.386 0.693 0 -0.693 -1.386 ...
$ number.spores:List of 10
..$ : num [1:6] 0 0 0 0 0 1
..$ : num [1:6] 0 0 0 0 0 1
..$ : num [1:6] 0 0 0 0 0 1
..$ : num [1:6] 0 0 0 0 0 1
..$ : num [1:6] 0 0 0 0 1 0
..$ : num [1:6] 0 0 0 1 0 0
..$ : num [1:6] 0 0 1 0 0 0
..$ : num [1:6] 0 0 1 0 0 0
..$ : num [1:6] 1 0 0 0 0 0
..$ : num [1:6] 1 0 0 0 0 0
</p>


<h3>Source</h3>

<p>Finney, D.J. (1971). Statistical Methods in Biological Assay. Griffin, London, 2nd edition.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("ropespores.grouped")
</code></pre>

<hr>
<h2 id='summary.BinaryEPPM'>
Summary of BinaryEPPM Objects
</h2><span id='topic+summary.BinaryEPPM'></span>

<h3>Description</h3>

<p>This function is generic. Summary of objects of class &quot;BinaryEPPM&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BinaryEPPM'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.BinaryEPPM_+3A_object">object</code></td>
<td>

<p>Fitted model object of class &quot;BinaryEPPM&quot;.
</p>
</td></tr>
<tr><td><code id="summary.BinaryEPPM_+3A_...">...</code></td>
<td>

<p>some methods for this generic function require additional arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Similar output to that of <code><a href="stats.html#topic+summary.glm">summary.glm</a></code> &quot;summary.glm&quot; and <code><a href="betareg.html#topic+summary.betareg">summary.betareg</a></code>
Cribari-Neto and Zeileis (2010).
</p>


<h3>Value</h3>

<p>An object of class &quot;summaryBinaryEPPM&quot; is constructed. This object has the following attributes.
</p>
<table>
<tr><td><code>data.type</code></td>
<td>

<p>Indicator of the type of data either 0 &quot;data.frame&quot; or 1 &quot;list&quot;.
</p>
</td></tr>
<tr><td><code>call</code></td>
<td>

<p>The &quot;call&quot; to the function &quot;BinaryEPPM&quot;.
</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>

<p>The model formula in &quot;call&quot;.
</p>
</td></tr>
<tr><td><code>model.type</code></td>
<td>

<p>The model type in &quot;call&quot;.
</p>
</td></tr>
<tr><td><code>model.name</code></td>
<td>

<p>The model name in &quot;call&quot;.
</p>
</td></tr>
<tr><td><code>link</code></td>
<td>

<p>The link function in &quot;call&quot;.
</p>
</td></tr>
<tr><td><code>offset.p</code></td>
<td>

<p>The vector of offsets for the model for p.
</p>
</td></tr>
<tr><td><code>offset.scalef</code></td>
<td>

<p>The vector of offsets for the model for scale-factor.
</p>
</td></tr>
<tr><td><code>coeff.table.p</code></td>
<td>

<p>The coefficients of the fitted model for p.
</p>
</td></tr>
<tr><td><code>coeff.table.scalef</code></td>
<td>

<p>The coefficients of the fitted model for scale-factor.
</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>

<p>The log-likelihood of the fitted model.
</p>
</td></tr>
<tr><td><code>n</code></td>
<td>

<p>The number of observations. Relabelled duplication of &quot;nobs&quot; needed when calling function &quot;lrtest&quot;. 
</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>

<p>The number of observations.
</p>
</td></tr>
<tr><td><code>df.null</code></td>
<td>

<p>The degrees of freedom of the null model.
</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>

<p>The degrees of freedom of the residual model.
</p>
</td></tr>
<tr><td><code>vnmax</code></td>
<td>

<p>Vector of number of &quot;trials&quot; in each observation.
</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>

<p>Vector of weights for observation.
</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>

<p>Indicator of convergence.
</p>
</td></tr>
<tr><td><code>method</code></td>
<td>

<p>Method used to calculate pseudo.r.squared.
</p>
</td></tr>
<tr><td><code>pseudo.r.squared</code></td>
<td>

<p>The value of the coefficient of determination r squared.
</p>
</td></tr>
<tr><td><code>optim</code></td>
<td>

<p>Final model fit.
</p>
</td></tr>
<tr><td><code>control</code></td>
<td>

<p>Control parameters for optimization function &quot;optim&quot;.
</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>

<p>The fitted values.
</p>
</td></tr>
<tr><td><code>y</code></td>
<td>

<p>The dependent variable in the model.
</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>

<p>The terms in the model.
</p>
</td></tr>
<tr><td><code>npar</code></td>
<td>

<p>The number of parameters in the model.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Cribari-Neto F, Zeileis A. (2010). Beta Regression in R.
<em>Journal of Statistical Software</em>, <b>34</b>(2), 1-24. 
<a href="https://doi.org/10.18637/jss.v034.i02">doi:10.18637/jss.v034.i02</a>.
</p>


<h3>See Also</h3>

<p><code><a href="betareg.html#topic+summary.betareg">summary.betareg</a></code> 
<code><a href="#topic+BinaryEPPM-package">print.summaryBinaryEPPM</a></code> 
</p>

<hr>
<h2 id='vcov.BinaryEPPM'>
Variance/Covariance Matrix for Coefficients
</h2><span id='topic+vcov.BinaryEPPM'></span>

<h3>Description</h3>

<p>Variance/covariance matrix for coefficients of fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BinaryEPPM'
vcov(object, model = c("full", "p", "scale.factor"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.BinaryEPPM_+3A_object">object</code></td>
<td>

<p>fitted model object of class &quot;BinaryEPPM&quot;.
</p>
</td></tr>
<tr><td><code id="vcov.BinaryEPPM_+3A_model">model</code></td>
<td>

<p>character indicating variance/covariance matrix for all coefficients to be output: all coefficients (&quot;full&quot;),
variance/covariance matrix for coefficients of probability of success (&quot;p&quot;),
variance/covariance matrix for coefficients of scale-factor (&quot;scale.factor&quot;)
</p>
</td></tr>
<tr><td><code id="vcov.BinaryEPPM_+3A_...">...</code></td>
<td>

<p>other parameters to be passed through to plotting functions.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The variance/covariance matrix of the parameters of the fitted model object.
</p>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Cribari-Neto F, Zeileis A. (2010). Beta Regression in R.
<em>Journal of Statistical Software</em>, <b>34</b>(2), 1-24. <a href="https://doi.org/10.18637/jss.v034.i02">doi:10.18637/jss.v034.i02</a>.
</p>


<h3>See Also</h3>

<p><code><a href="betareg.html#topic+betareg">betareg</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("ropespores.case") 
output.fn &lt;- BinaryEPPM(data = ropespores.case,
                  number.spores / number.tested ~ 1 + offset(logdilution),
                  model.type = 'p only', model.name = 'binomial')   
vcov(output.fn)
</code></pre>

<hr>
<h2 id='waldtest.BinaryEPPM'>
Wald Test of Nested Models for BinaryEPPM Objects
</h2><span id='topic+waldtest.BinaryEPPM'></span>

<h3>Description</h3>

<p><code>waldtest</code> is a generic function for comparisons of nested (generalized) linear models via Wald tests. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BinaryEPPM'
waldtest(object, ..., vcov = NULL,
   test = c("Chisq", "F"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="waldtest.BinaryEPPM_+3A_object">object</code></td>
<td>

<p>an object of class &quot;BinaryEPPM&quot;.
</p>
</td></tr>
<tr><td><code id="waldtest.BinaryEPPM_+3A_...">...</code></td>
<td>

<p>further object specifications passed to methods. See below for details.
</p>
</td></tr>
<tr><td><code id="waldtest.BinaryEPPM_+3A_vcov">vcov</code></td>
<td>

<p>a function for estimating the covariance matrix of the regression coefficients. If only two models are compared it can also be the covariance matrix of the more general model. 
</p>
</td></tr>
<tr><td><code id="waldtest.BinaryEPPM_+3A_test">test</code></td>
<td>

<p>character specifying whether to compute the large sample Chi-squared statistic (with asymptotic Chi-squared distribution) or the finite sample F statistic (with approximate F distribution).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>waldtest</code> is a generic function for comparisons of nested (generalized)linear models via Wald tests. It does not have the same functionality as the versions of <span class="pkg">betareg</span> and <span class="pkg">lmtest</span> with a reduced list of arguments. With these caveats, more details can be obtained from the <b>Details</b> pages of those packages.
</p>


<h3>Value</h3>

<p>An object of class <code>"anova"</code> which contains the residual degrees of freedom, the difference in degrees of freedom, Wald statistic (either <code>"Chisq"</code> or <code>"F"</code>) and corresponding p value.
</p>


<h3>Author(s)</h3>

<p>David M. Smith &lt;dmccsmith@verizon.net&gt;
</p>


<h3>References</h3>

<p>Cribari-Neto F, Zeileis A. (2010). Beta Regression in R.
<em>Journal of Statistical Software</em>, <b>34</b>(2), 1-24. <a href="https://doi.org/10.18637/jss.v034.i02">doi:10.18637/jss.v034.i02</a>.
</p>
<p>Zeileis A, Hothorn T. (2002). Diagnostic Checking in Regression Relationships. <em>R News</em>, <b>2</b>(3), 7-10. <a href="https://CRAN.R-project.org/doc/Rnews/">https://CRAN.R-project.org/doc/Rnews/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="lmtest.html#topic+waldtest">waldtest</a></code> 
<code><a href="betareg.html#topic+betareg">betareg</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("ropespores.case") 
output.fn &lt;- BinaryEPPM(data = ropespores.case,
  number.spores / number.tested ~ 1 + offset(logdilution),
  model.type = 'p only', model.name = 'binomial')  
output.fn.one &lt;- BinaryEPPM(data = ropespores.case,
  number.spores / number.tested ~ 1 + offset(logdilution),
  model.type = 'p only', model.name = 'beta binomial')   
waldtest.BinaryEPPM(output.fn, output.fn.one, test = c("Chisq", "F"),
  vcov =  vcov)        

</code></pre>

<hr>
<h2 id='wordcount.case'>
Number of occurences of an article in five-word and ten-word samples from two authors.
</h2><span id='topic+wordcount.case'></span>

<h3>Description</h3>

<p>The data are the number of occurences of an article in five-word and ten-word samples from 
Macaulay's 'Essay on Milton' and G.K. Chesterton's essay 'About the workers'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("wordcount.case")</code></pre>


<h3>Format</h3>

<p>A data frame with 340 observations on the following 5 variables.
</p>

<dl>
<dt><code>author</code></dt><dd><p>a factor with levels <code> Macaulay</code> <code> Chesterton</code></p>
</dd>
<dt><code>fsize</code></dt><dd><p>a factor with levels <code>5</code> <code>10</code></p>
</dd>
<dt><code>vsize</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>number.words</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>number.tested</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Source</h3>

<p>Bailey, B.J.R. (1990). A model for Function Word Counts. Appl. Statist. 39(1), 107-114.
</p>


<h3>References</h3>

<p>Sellers, K.F., Swift, A.W., Weems, K.S. (2017). A flexible distribution class for count data.
Journal of Statistical Distributions and Applications 41(12), 2616-2626.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wordcount.case)
</code></pre>

<hr>
<h2 id='wordcount.grouped'>
Number of occurences of an article in five-word and ten-word samples from two authors.
</h2><span id='topic+wordcount.grouped'></span>

<h3>Description</h3>

<p>The data are the number of occurences of an article in five-word and ten-word samples from 
Macaulay's 'Essay on Milton' and G.K. Chesterton's essay 'About the workers'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("wordcount.grouped")</code></pre>


<h3>Format</h3>

<p>The format is:
List of 4
$ author      : Factor w/ 2 levels &quot; Macaulay&quot;,&quot; Chesterton&quot;: 1 1 2 2
$ fsize       : Factor w/ 2 levels &quot;5&quot;,&quot;10&quot;: 1 2 1 2
$ vsize       : num [1:4] 5 10 5 10
$ number.words:List of 4
..$ : num [1:6] 45 49 6 0 0 0
..$ : num [1:11] 27 44 26 3 0 0 0 0 0 0 ...
..$ : num [1:6] 32 35 3 0 0 0
..$ : num [1:11] 14 38 16 2 0 0 0 0 0 0 ...
</p>


<h3>Source</h3>

<p>Bailey, B.J.R. (1990). A model for Function Word Counts. Appl. Statist. 39(1), 107-114.
</p>


<h3>References</h3>

<p>Sellers, K.F., Swift, A.W., Weems, K.S. (2017). A flexible distribution class for count data.
Journal of Statistical Distributions and Applications 41(12), 2616-2626.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wordcount.grouped)
</code></pre>

<hr>
<h2 id='Yorkshires.litters'>
The data are of the number of male piglets born in litters of varying sizes for 
the Yorkshire breed of pigs. 
</h2><span id='topic+Yorkshires.litters'></span>

<h3>Description</h3>

 
<p>The data are arranged as a list of binomial frequency distributions where the 
listing is by litter size which is included both as a variate (vsize) and as a factor (fsize)</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Yorkshires.litters")</code></pre>


<h3>Format</h3>

<p>The format is:
List of 3
$ fsize         : Factor w/ 9 levels &quot; size 5&quot;,&quot; size 6&quot;,..: 1 2 3 4 5 6 7 8 9
$ vsize         : int [1:9] 5 6 7 8 9 10 11 12 13
$ number.success:List of 9
..$ : num [1:6] 3 22 30 37 13 5
..$ : num [1:7] 7 18 44 62 27 17 4
..$ : num [1:8] 2 14 25 63 69 41 12 5
..$ : num [1:9] 2 15 32 70 127 90 45 18 1
..$ : num [1:10] 0 8 33 63 106 115 62 30 11 1
..$ : num [1:11] 0 3 20 49 79 119 91 59 23 4 ...
..$ : num [1:12] 0 0 7 20 60 94 100 47 31 9 ...
..$ : num [1:13] 0 1 6 16 29 52 66 43 34 22 ...
..$ : num [1:14] 0 2 2 2 14 19 44 45 22 13 ...
</p>


<h3>Source</h3>

<p>Brooks, R.J., James, W.H., Gray, E. (1993). Modelling Sub-Binomial Variation in 
the Frequency of Sex Combinations in Litters of Pigs. Biometrics 47, 403-417.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Yorkshires.litters")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
