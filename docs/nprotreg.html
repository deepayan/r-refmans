<!DOCTYPE html><html><head><title>Help for package nprotreg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nprotreg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#convert_cartesian_to_spherical'><p>Converts Cartesian to Spherical Coordinates.</p></a></li>
<li><a href='#convert_spherical_to_cartesian'><p>Converts Spherical to Cartesian Coordinates.</p></a></li>
<li><a href='#cross_validate_concentration'><p>Cross-validates The Concentration Parameter In A 3D Spherical Regression.</p></a></li>
<li><a href='#expm'><p>Computes the Exponential of a 3D Skew Symmetric Matrix.</p></a></li>
<li><a href='#fit_regression'><p>Fits a 3D Spherical Regression.</p></a></li>
<li><a href='#get_equally_spaced_points'><p>Generates Equally Spaced Points On A 3D Sphere.</p></a></li>
<li><a href='#get_skew_symmetric_matrix'><p>Gets a 3-by-3 Skew Symmetric Matrix.</p></a></li>
<li><a href='#logm'><p>Computes the Logarithm of a 3D Rotation Matrix.</p></a></li>
<li><a href='#nprotreg'><p>nprotreg: Nonparametric Rotations for Sphere-Sphere Regression.</p></a></li>
<li><a href='#simulate_regression'><p>Simulates a 3D Spherical Regression.</p></a></li>
<li><a href='#simulate_rigid_regression'><p>Simulates a Rigid 3D Spherical Regression.</p></a></li>
<li><a href='#weight_explanatory_points'><p>Weights the Specified Explanatory Points in a 3D Spherical Regression.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Nonparametric Rotations for Sphere-Sphere Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Fits sphere-sphere regression models by estimating locally weighted
    rotations. Simulation of sphere-sphere data according to non-rigid rotation
    models. Provides methods for bias reduction applying iterative procedures
    within a Newton-Raphson learning scheme. Cross-validation is exploited to select
    smoothing parameters. See Marco Di Marzio, Agnese Panzera &amp; Charles C. Taylor
    (2018) &lt;<a href="https://doi.org/10.1080%2F01621459.2017.1421542">doi:10.1080/01621459.2017.1421542</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>Imports:</td>
<td>foreach, methods, stats</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-28 08:19:05 UTC; giova</td>
</tr>
<tr>
<td>Author:</td>
<td>Charles C. Taylor [aut],
  Giovanni Lafratta [aut, cre],
  Stefania Fensore [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Giovanni Lafratta &lt;giovanni.lafratta@unich.it&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-28 08:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='convert_cartesian_to_spherical'>Converts Cartesian to Spherical Coordinates.</h2><span id='topic+convert_cartesian_to_spherical'></span>

<h3>Description</h3>

<p>The Cartesian coordinates of points on a 3-dimensional
sphere with unit radius and center at the origin are
converted to the
equivalent longitude and latitude coordinates, measured in radians.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_cartesian_to_spherical(cartesian_coords)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_cartesian_to_spherical_+3A_cartesian_coords">cartesian_coords</code></td>
<td>
<p>A matrix whose rows contain the Cartesian coordinates
of the specified points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of rows containing the longitude and
latitude of specific points on a 3-dimensional sphere.
</p>


<h3>See Also</h3>

<p><a href="http://mathworld.wolfram.com/SphericalCoordinates.html">http://mathworld.wolfram.com/SphericalCoordinates.html</a>.
</p>
<p>Other Conversion functions: 
<code><a href="#topic+convert_spherical_to_cartesian">convert_spherical_to_cartesian</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(nprotreg)

# Define the Cartesian coordinates of the North and South Poles.

north_pole &lt;- cbind(0, 0, 1)
south_pole &lt;- cbind(0, 0, -1)
cartesian_coords &lt;- rbind(north_pole, south_pole)

# Get the corresponding Spherical coordinates.

spherical_coords &lt;- convert_cartesian_to_spherical(cartesian_coords)
</code></pre>

<hr>
<h2 id='convert_spherical_to_cartesian'>Converts Spherical to Cartesian Coordinates.</h2><span id='topic+convert_spherical_to_cartesian'></span>

<h3>Description</h3>

<p>The longitude and latitude coordinates of points on a 3-dimensional
sphere with unit radius and center at the origin
are converted to the
equivalent Cartesian coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_spherical_to_cartesian(spherical_coords)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_spherical_to_cartesian_+3A_spherical_coords">spherical_coords</code></td>
<td>
<p>A matrix of rows containing the longitude and
latitude, measured in radians, of specific points on a 3-dimensional sphere.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix whose rows contain the Cartesian coordinates
of the specified points.
</p>


<h3>See Also</h3>

<p><a href="http://mathworld.wolfram.com/SphericalCoordinates.html">http://mathworld.wolfram.com/SphericalCoordinates.html</a>.
</p>
<p>Other Conversion functions: 
<code><a href="#topic+convert_cartesian_to_spherical">convert_cartesian_to_spherical</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(nprotreg)

# Define the Spherical coordinates of the North and South Poles.

north_pole &lt;- cbind(0, pi / 2)
south_pole &lt;- cbind(0, - pi / 2)
spherical_coords &lt;- rbind(north_pole, south_pole)

# Get the corresponding Cartesian coordinates.

cartesian_coords &lt;- convert_spherical_to_cartesian(spherical_coords)
</code></pre>

<hr>
<h2 id='cross_validate_concentration'>Cross-validates The Concentration Parameter In A 3D Spherical Regression.</h2><span id='topic+cross_validate_concentration'></span>

<h3>Description</h3>

<p>Returns a cross-validated value for the concentration parameter in
a 3D regression, relating specific explanatory points to response
ones, given a weighting scheme for the observed data set.
This function supports the method for sphere-sphere regression
proposed by Di Marzio et al. (2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross_validate_concentration(
  concentration_upper_bound = 10,
  explanatory_points,
  response_points,
  weights_generator = weight_explanatory_points,
  number_of_expansion_terms = 1,
  number_of_iterations = 1,
  allow_reflections = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cross_validate_concentration_+3A_concentration_upper_bound">concentration_upper_bound</code></td>
<td>
<p>A scalar numeric value representing
the upper end-point of the interval to be searched for the required minimizer.
Defaults to <code>10</code>.</p>
</td></tr>
<tr><td><code id="cross_validate_concentration_+3A_explanatory_points">explanatory_points</code></td>
<td>
<p>An <em>m</em>-by-3 matrix whose rows contain
the Cartesian coordinates of the explanatory points used to
calculate the regression estimators.</p>
</td></tr>
<tr><td><code id="cross_validate_concentration_+3A_response_points">response_points</code></td>
<td>
<p>An <em>m</em>-by-<em>3</em> matrix whose rows contain
the Cartesian coordinates of the response points corresponding
to the explanatory points.</p>
</td></tr>
<tr><td><code id="cross_validate_concentration_+3A_weights_generator">weights_generator</code></td>
<td>
<p>A function that, given a matrix of <em>n</em>
evaluation points, returns an <em>m</em>-by-<em>n</em> matrix whose
<em>j</em>-th column contains
the weights assigned to the explanatory points while analyzing the
<em>j</em>-th evaluation point. Defaults to <code><a href="#topic+weight_explanatory_points">weight_explanatory_points</a></code>.</p>
</td></tr>
<tr><td><code id="cross_validate_concentration_+3A_number_of_expansion_terms">number_of_expansion_terms</code></td>
<td>
<p>The number of terms to be included
in the expansion of the matrix exponential applied while
approximating a local rotation matrix. Must be <code>1</code> or <code>2</code>.
Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="cross_validate_concentration_+3A_number_of_iterations">number_of_iterations</code></td>
<td>
<p>The number of
rotation fitting steps to be executed.
At each step, the points estimated during the previous step
are exploited as the current explanatory points. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="cross_validate_concentration_+3A_allow_reflections">allow_reflections</code></td>
<td>
<p>A logical scalar value. If set to <code>TRUE</code> signals
that reflections are allowed. Defaults to <code>FALSE</code>. It is ignored if
<code>number_of_expansion_terms</code> is <code>2</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>weights_generator</code> must be prototyped as having the
following three arguments:
</p>

<dl>
<dt><code>evaluation_points</code></dt><dd><p>a matrix whose <em>n</em> rows are the Cartesian coordinates of
given evaluation points.</p>
</dd>
<dt><code>explanatory_points</code></dt><dd><p>a matrix whose <em>m</em> rows are the Cartesian coordinates of
given explanatory points.</p>
</dd>
<dt><code>concentration</code></dt><dd><p>A non negative scalar whose reciprocal value
is proportional to the bandwidth applied while estimating
a spherical regression model.</p>
</dd>
</dl>

<p>It is also expected that <code>weights_generator</code> will return
a non <code>NULL</code> numerical <em>m</em>-by-<em>n</em> matrix whose <em>j</em>-th column contains
the weights assigned to the explanatory points while analyzing the
<em>j</em>-th evaluation point.
</p>


<h3>Value</h3>

<p>A list having two components,
<code>concentration</code>, a scalar, numeric value representing the cross-validated
concentration for the specified 3D regression, and
<code>objective</code>, the value of the cross-validating objective function at argument <code>concentration</code>.
</p>


<h3>References</h3>

<p>Marco Di Marzio, Agnese Panzera &amp; Charles C. Taylor (2018)
Nonparametric rotations for sphere-sphere regression,
Journal of the American Statistical Association,
&lt;doi:10.1080/01621459.2017.1421542&gt;.
</p>


<h3>See Also</h3>

<p>Other Regression functions: 
<code><a href="#topic+fit_regression">fit_regression</a>()</code>,
<code><a href="#topic+get_equally_spaced_points">get_equally_spaced_points</a>()</code>,
<code><a href="#topic+get_skew_symmetric_matrix">get_skew_symmetric_matrix</a>()</code>,
<code><a href="#topic+simulate_regression">simulate_regression</a>()</code>,
<code><a href="#topic+simulate_rigid_regression">simulate_rigid_regression</a>()</code>,
<code><a href="#topic+weight_explanatory_points">weight_explanatory_points</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(nprotreg)

# Define a matrix of explanatory points.

number_of_explanatory_points &lt;- 50

explanatory_points &lt;- get_equally_spaced_points(
  number_of_explanatory_points)

# Define a matrix of response points by simulation.

local_rotation_composer &lt;- function(point) {
  independent_components &lt;- (1 / 2) *
    c(exp(2.0 * point[3]), - exp(2.0 * point[2]), exp(2.0 * point[1]))
}

local_error_sampler &lt;- function(point) {
  rnorm(3)
}

response_points &lt;- simulate_regression(explanatory_points,
                                       local_rotation_composer,
                                       local_error_sampler)

# Define an upper bound for concentration.

concentration_upper_bound &lt;- 1

# Use default weights generator.

weights_generator &lt;- weight_explanatory_points

# Cross-validate concentration parameter.

cv_info &lt;- cross_validate_concentration(
  concentration_upper_bound,
  explanatory_points,
  response_points,
  weights_generator,
  number_of_expansion_terms = 1,
  number_of_iterations = 2,
  allow_reflections = FALSE
)

# Get the cross-validated concentration value.

cat("cross-validated concentration value: \n")
print(cv_info$concentration)
</code></pre>

<hr>
<h2 id='expm'>Computes the Exponential of a 3D Skew Symmetric Matrix.</h2><span id='topic+expm'></span>

<h3>Description</h3>

<p>The exponential of a skew-symmetric matrix is computed by means
of the Rodrigues' formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expm(skew_symmetric_matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expm_+3A_skew_symmetric_matrix">skew_symmetric_matrix</code></td>
<td>
<p>A 3-by-3 skew-symmetric matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 3-by-3 rotation matrix representing the exponential 
of the specified skew-symmetric matrix.
</p>

<hr>
<h2 id='fit_regression'>Fits a 3D Spherical Regression.</h2><span id='topic+fit_regression'></span>

<h3>Description</h3>

<p>Returns 3D spherical points obtained by locally rotating
the specified evaluation
points, given an approximated model for local rotations
and a weighting scheme for the observed data set.
This function implements the method for sphere-sphere regression
proposed by Di Marzio et al. (2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_regression(
  evaluation_points,
  explanatory_points,
  response_points,
  concentration,
  weights_generator = weight_explanatory_points,
  number_of_expansion_terms = 1,
  number_of_iterations = 1,
  allow_reflections = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_regression_+3A_evaluation_points">evaluation_points</code></td>
<td>
<p>An <em>n</em>-by-3 matrix whose rows contain
the Cartesian coordinates of the points at which the regression
will be estimated.</p>
</td></tr>
<tr><td><code id="fit_regression_+3A_explanatory_points">explanatory_points</code></td>
<td>
<p>An <em>m</em>-by-3 matrix whose rows contain
the Cartesian coordinates of the explanatory points used to
calculate the regression estimators.</p>
</td></tr>
<tr><td><code id="fit_regression_+3A_response_points">response_points</code></td>
<td>
<p>An <em>m</em>-by-<em>3</em> matrix whose rows contain
the Cartesian coordinates of the response points corresponding
to the explanatory points.</p>
</td></tr>
<tr><td><code id="fit_regression_+3A_concentration">concentration</code></td>
<td>
<p>A non negative scalar whose reciprocal value
is proportional to the bandwidth applied while estimating
a spherical regression model.</p>
</td></tr>
<tr><td><code id="fit_regression_+3A_weights_generator">weights_generator</code></td>
<td>
<p>A function that, given a matrix of <em>n</em>
evaluation points, returns an <em>m</em>-by-<em>n</em> matrix whose
<em>j</em>-th column contains
the weights assigned to the explanatory points while analyzing the
<em>j</em>-th evaluation point. Defaults to <code><a href="#topic+weight_explanatory_points">weight_explanatory_points</a></code>.</p>
</td></tr>
<tr><td><code id="fit_regression_+3A_number_of_expansion_terms">number_of_expansion_terms</code></td>
<td>
<p>The number of terms to be included
in the expansion of the matrix exponential applied while
approximating a local rotation matrix. Must be <code>1</code> or <code>2</code>.
Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="fit_regression_+3A_number_of_iterations">number_of_iterations</code></td>
<td>
<p>The number of
rotation fitting steps to be executed.
At each step, the points estimated during the previous step
are exploited as the current explanatory points. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="fit_regression_+3A_allow_reflections">allow_reflections</code></td>
<td>
<p>A logical scalar value. If set to <code>TRUE</code> signals
that reflections are allowed. Defaults to <code>FALSE</code>. It is ignored if
<code>number_of_expansion_terms</code> is <code>2</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>weights_generator</code> must be prototyped as having the
following three arguments:
</p>

<dl>
<dt><code>evaluation_points</code></dt><dd><p>a matrix whose <em>n</em> rows are the Cartesian coordinates of
given evaluation points.</p>
</dd>
<dt><code>explanatory_points</code></dt><dd><p>a matrix whose <em>m</em> rows are the Cartesian coordinates of
given explanatory points.</p>
</dd>
<dt><code>concentration</code></dt><dd><p>A non negative scalar whose reciprocal value
is proportional to the bandwidth applied while estimating
a spherical regression model.</p>
</dd>
</dl>

<p>It is also expected that <code>weights_generator</code> will return
a non <code>NULL</code> numerical <em>m</em>-by-<em>n</em> matrix whose <em>j</em>-th column contains
the weights assigned to the explanatory points while analyzing the
<em>j</em>-th evaluation point.
</p>
<p>Function <code>fit_regression</code> supports parallel execution.
To setup parallelization, you can exploit the
<a href="https://cran.r-project.org/package=doParallel">doParallel</a> package.
Otherwise, <code>fit_regression</code>  will be executed sequentially and, when called the 
first time, you will receive the following 
</p>
<p><code>## Warning: executing %dopar% sequentially: no parallel backend registered</code>
</p>
<p>This is completely safe and by design.
</p>


<h3>Value</h3>

<p>A <code>number_of_iterations</code>-length vector of lists, with the <code>s</code>-th
list having two components,
<code>fitted_response_points</code>, an <em>n</em>-by-<em>3</em> matrix whose rows contain
the Cartesian coordinates of the fitted points at iteration <code>s</code>, and
<code>explanatory_points</code>, an <em>m</em>-by-<em>3</em> matrix whose rows contain
the Cartesian coordinates of the points exploited as explanatory at
iteration <code>s</code>.
</p>


<h3>References</h3>

<p>Marco Di Marzio, Agnese Panzera &amp; Charles C. Taylor (2018)
Nonparametric rotations for sphere-sphere regression,
Journal of the American Statistical Association,
&lt;doi:10.1080/01621459.2017.1421542&gt;.
</p>


<h3>See Also</h3>

<p>Other Regression functions: 
<code><a href="#topic+cross_validate_concentration">cross_validate_concentration</a>()</code>,
<code><a href="#topic+get_equally_spaced_points">get_equally_spaced_points</a>()</code>,
<code><a href="#topic+get_skew_symmetric_matrix">get_skew_symmetric_matrix</a>()</code>,
<code><a href="#topic+simulate_regression">simulate_regression</a>()</code>,
<code><a href="#topic+simulate_rigid_regression">simulate_rigid_regression</a>()</code>,
<code><a href="#topic+weight_explanatory_points">weight_explanatory_points</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(nprotreg)

# Create 100 equally spaced design points on the sphere.

number_of_explanatory_points &lt;- 100

explanatory_points &lt;- get_equally_spaced_points(
  number_of_explanatory_points
)

# Define the regression model, where the rotation for a given "point"
# is obtained from the exponential of a skew-symmetric matrix with the
# following components.

local_rotation_composer &lt;- function(point) {
  independent_components &lt;- (1 / 8) *
    c(exp(2.0 * point[3]), - exp(2.0 * point[2]), exp(2.0 * point[1]))
}

# Define an error term given by a small rotation, similarly defined
# from a skew-symmetric matrix with random entries.

local_error_sampler &lt;- function(point) {
  rnorm(3, sd = .01)
}

# Generate the matrix of responses, using the regression model
# and the error model.

response_points &lt;- simulate_regression(
  explanatory_points,
  local_rotation_composer,
  local_error_sampler
)

# Create some "test data" for which the response will be predicted.

evaluation_points &lt;- rbind(
  cbind(.5, 0, .8660254),
  cbind(-.5, 0, .8660254),
  cbind(1, 0, 0),
  cbind(0, 1, 0),
  cbind(-1, 0, 0),
  cbind(0, -1, 0),
  cbind(.5, 0, -.8660254),
  cbind(-.5, 0, -.8660254)
)

# Define a weight function for nonparametric fit.

weights_generator &lt;- weight_explanatory_points

# Set the concentration parameter.

concentration &lt;- 5

# Or obtain this by cross-validation: see
# the `cross_validate_concentration` function.

# Fit regression.

fitted_model &lt;- fit_regression(
  evaluation_points,
  explanatory_points,
  response_points,
  concentration,
  weights_generator,
  number_of_expansion_terms = 1,
  number_of_iterations = 2
)

# Extract the point corresponding to the
# second evaluation point fitted at
# the first iteration.

cat("Point fitted at iteration 1 corresponding to the second evaluation point: \n")
cat(fitted_model[[1]]$fitted_response_points[2, ], "\n")

## Not run: 
# Create some plots to view the results.

# 3D plot.

library(rgl)

plot3d(
  explanatory_points,
  type = "n",
  xlab = "x",
  ylab = "y",
  zlab = "z",
  box = TRUE,
  axes = TRUE
)
spheres3d(0, 0, 0, radius = 1, lit = FALSE, color = "white")
spheres3d(0, 0, 0, radius = 1.01, lit = FALSE, color = "black", front = "culled")
text3d(c(0, 0, 1), text = "N", adj = 0)

ll &lt;- 10
vv1 &lt;- (ll - (0:(ll))) / ll
vv2 &lt;- 1 - vv1
plot3d(explanatory_points, add = TRUE, col = 2)
for (i in 1:dim(explanatory_points)[1]) {
  m &lt;- outer(vv1, explanatory_points[i,], "*") +
    outer(vv2, response_points[i,], "*")
  m &lt;- m / sqrt(apply(m ^ 2, 1, sum))
  lines3d(m, col = 3)
}

plot3d(evaluation_points, add = TRUE, col = 4)

for (i in 1:dim(evaluation_points)[1]) {
  m &lt;- outer(vv1, evaluation_points[i,], "*") +
    outer(vv2, fitted_model[[1]]$fitted_response_points[i,], "*")
  m &lt;- m / sqrt(apply(m ^ 2, 1, sum))
  lines3d(m, col = 1)
}

# 2D plot.

explanatory_spherical_coords &lt;- convert_cartesian_to_spherical(explanatory_points)
response_spherical_coords &lt;- convert_cartesian_to_spherical(response_points)

plot(
  x = explanatory_spherical_coords[, 1],
  y = explanatory_spherical_coords[, 2],
  pch = 20,
  cex = .7,
  col = 2,
  xlab = "longitude",
  ylab = "latitude"
)

for (i in 1:dim(explanatory_spherical_coords)[1]) {
  column &lt;- 1
  if ((explanatory_spherical_coords[i, 1] - response_spherical_coords[i, 1]) ^ 2 +
      (explanatory_spherical_coords[i, 2] - response_spherical_coords[i, 2]) ^ 2 &gt; 4)
        column &lt;- "grey"
  lines(
    c(explanatory_spherical_coords[i, 1], response_spherical_coords[i, 1]),
    c(explanatory_spherical_coords[i, 2], response_spherical_coords[i, 2]),
    col = column
  )
}

evaluation_spherical_coords &lt;- convert_cartesian_to_spherical(
  evaluation_points
)

fitted_response_spherical_coords &lt;- convert_cartesian_to_spherical(
  fitted_model[[1]]$fitted_response_points
)

points(
  x = evaluation_spherical_coords[, 1],
  y = evaluation_spherical_coords[, 2],
  pch = 20,
  cex = .7,
  col = 4
)

for (i in 1:dim(evaluation_spherical_coords)[1]) {
  column &lt;- 3
  if ((evaluation_spherical_coords[i, 1] - fitted_response_spherical_coords[i, 1]) ^ 2 +
      (evaluation_spherical_coords[i, 2] - fitted_response_spherical_coords[i, 2]) ^ 2 &gt; 4)
        column &lt;- "grey"
  lines(
    c(evaluation_spherical_coords[i, 1], fitted_response_spherical_coords[i, 1]),
    c(evaluation_spherical_coords[i, 2], fitted_response_spherical_coords[i, 2]),
    col = column
  )
}


## End(Not run) 
</code></pre>

<hr>
<h2 id='get_equally_spaced_points'>Generates Equally Spaced Points On A 3D Sphere.</h2><span id='topic+get_equally_spaced_points'></span>

<h3>Description</h3>

<p>Generates points approximately equally spaced on a 3D sphere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_equally_spaced_points(number_of_points)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_equally_spaced_points_+3A_number_of_points">number_of_points</code></td>
<td>
<p>A scalar, positive integer
representing the number of points to get.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>number_of_points</code>-by-3 matrix whose rows
contain the Cartesian coordinates
of the equally spaced points.
</p>


<h3>See Also</h3>

<p>Other Regression functions: 
<code><a href="#topic+cross_validate_concentration">cross_validate_concentration</a>()</code>,
<code><a href="#topic+fit_regression">fit_regression</a>()</code>,
<code><a href="#topic+get_skew_symmetric_matrix">get_skew_symmetric_matrix</a>()</code>,
<code><a href="#topic+simulate_regression">simulate_regression</a>()</code>,
<code><a href="#topic+simulate_rigid_regression">simulate_rigid_regression</a>()</code>,
<code><a href="#topic+weight_explanatory_points">weight_explanatory_points</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(nprotreg)

# Define the number of points to get.

number_of_points &lt;- 5

# Get the Cartesian coordinates of the equally spaced points.

equally_spaced_points &lt;- get_equally_spaced_points(number_of_points)
</code></pre>

<hr>
<h2 id='get_skew_symmetric_matrix'>Gets a 3-by-3 Skew Symmetric Matrix.</h2><span id='topic+get_skew_symmetric_matrix'></span>

<h3>Description</h3>

<p>Returns the 3-by-3 skew symmetric matrix having the specified
independent components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_skew_symmetric_matrix(independent_components)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_skew_symmetric_matrix_+3A_independent_components">independent_components</code></td>
<td>
<p>A vector containing
the independent components of the matrix to get.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a vector of components, say  <code class="reqn">[x,y,z]</code>, this function
will return matrix
</p>

<table>
<tr>
 <td style="text-align: right;">
 <code class="reqn">0</code> </td><td style="text-align: right;"> </td><td style="text-align: right;"> <code class="reqn">-z</code> </td><td style="text-align: right;"> </td><td style="text-align: right;"> <code class="reqn">y</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
 <code class="reqn">z</code> </td><td style="text-align: right;"> </td><td style="text-align: right;"> <code class="reqn">0</code>  </td><td style="text-align: right;"> </td><td style="text-align: right;"> <code class="reqn">-x</code></td>
</tr>
<tr>
 <td style="text-align: right;">
<code class="reqn">-y</code> </td><td style="text-align: right;"> </td><td style="text-align: right;"> <code class="reqn">x</code>  </td><td style="text-align: right;"> </td><td style="text-align: right;"> <code class="reqn">0</code></td>
</tr>

</table>



<h3>Value</h3>

<p>The 3-by-3 skew symmetric matrix corresponding to
the specified independent components.
</p>


<h3>See Also</h3>

<p><a href="https://en.wikipedia.org/wiki/Skew-symmetric_matrix">https://en.wikipedia.org/wiki/Skew-symmetric_matrix</a>.
</p>
<p>Other Regression functions: 
<code><a href="#topic+cross_validate_concentration">cross_validate_concentration</a>()</code>,
<code><a href="#topic+fit_regression">fit_regression</a>()</code>,
<code><a href="#topic+get_equally_spaced_points">get_equally_spaced_points</a>()</code>,
<code><a href="#topic+simulate_regression">simulate_regression</a>()</code>,
<code><a href="#topic+simulate_rigid_regression">simulate_rigid_regression</a>()</code>,
<code><a href="#topic+weight_explanatory_points">weight_explanatory_points</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(nprotreg)

# Define a vector of independent components.

independent_components &lt;- cbind(1, 2, 3)

# Get the corresponding 3-by-3 skew symmetric matrix.

m &lt;- get_skew_symmetric_matrix(independent_components)
</code></pre>

<hr>
<h2 id='logm'>Computes the Logarithm of a 3D Rotation Matrix.</h2><span id='topic+logm'></span>

<h3>Description</h3>

<p>Computes the Logarithm of a 3D Rotation Matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logm(rotation_matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logm_+3A_rotation_matrix">rotation_matrix</code></td>
<td>
<p>A 3-by-3 rotation matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 3-by-3 skew-symmetric matrix representing the logarithm 
of the specified rotation matrix.
</p>

<hr>
<h2 id='nprotreg'>nprotreg: Nonparametric Rotations for Sphere-Sphere Regression.</h2><span id='topic+nprotreg'></span><span id='topic+nprotreg-package'></span>

<h3>Description</h3>

<p>The nprotreg package provides several categories of functions.
</p>


<h3>Regression functions</h3>

<p>Regression functions provide support for simulating and
fitting 3-dimensional spherical regression models.
</p>

<ul>
<li> <p><code><a href="#topic+cross_validate_concentration">cross_validate_concentration</a></code>
</p>
</li>
<li> <p><code><a href="#topic+fit_regression">fit_regression</a></code>
</p>
</li>
<li> <p><code><a href="#topic+get_equally_spaced_points">get_equally_spaced_points</a></code>
</p>
</li>
<li> <p><code><a href="#topic+get_skew_symmetric_matrix">get_skew_symmetric_matrix</a></code>
</p>
</li>
<li> <p><code><a href="#topic+simulate_regression">simulate_regression</a></code>
</p>
</li>
<li> <p><code><a href="#topic+simulate_rigid_regression">simulate_rigid_regression</a></code>
</p>
</li>
<li> <p><code><a href="#topic+weight_explanatory_points">weight_explanatory_points</a></code>
</p>
</li></ul>



<h3>Conversion functions</h3>

<p>Conversion functions transform coordinates of points
on a 3-dimensional sphere with unit radius and center at the origin.
</p>

<ul>
<li> <p><code><a href="#topic+convert_cartesian_to_spherical">convert_cartesian_to_spherical</a></code>
</p>
</li>
<li> <p><code><a href="#topic+convert_spherical_to_cartesian">convert_spherical_to_cartesian</a></code>
</p>
</li></ul>


<hr>
<h2 id='simulate_regression'>Simulates a 3D Spherical Regression.</h2><span id='topic+simulate_regression'></span>

<h3>Description</h3>

<p>Returns the response points corresponding to the specified explanatory
points, given a model for local rotations
and an error term sampler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_regression(
  explanatory_points,
  local_rotation_composer,
  local_error_sampler
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_regression_+3A_explanatory_points">explanatory_points</code></td>
<td>
<p>An <em>m</em>-by-3 matrix whose rows contain
the Cartesian coordinates of the points at which the regression
will be simulated.</p>
</td></tr>
<tr><td><code id="simulate_regression_+3A_local_rotation_composer">local_rotation_composer</code></td>
<td>
<p>A function that returns a
3-length numeric vector representing the independent components of a
skew symmetric matrix local to an explanatory point, given its
Cartesian coordinates.</p>
</td></tr>
<tr><td><code id="simulate_regression_+3A_local_error_sampler">local_error_sampler</code></td>
<td>
<p>A function that returns a 3-length numeric vector
representing a sampled error term local to an explanatory point,
given its Cartesian coordinates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">E</code> be
the <em>m</em>-by-3 matrix of explanatory points.
This function will return
an <em>m</em>-by-<em>3</em> matrix whose <code class="reqn">i</code>-th row is obtained by
transposition of the following expression:
</p>
<p style="text-align: center;"><code class="reqn">exp(\Phi(\epsilon(x))) exp(\Phi(s(x))) x</code>
</p>

<p>where <code class="reqn">x</code> is the transpose of the <code class="reqn">i</code>-th row of
<code class="reqn">E</code>. Terms <code class="reqn">\epsilon(x)</code> and <code class="reqn">s(x)</code> are obtained by
evaluating at <code class="reqn">x</code> functions <code>local_error_sampler</code> and
<code>local_rotation_composer</code>, respectively, while
matrix <code class="reqn">\Phi(c)</code>, for a 3-length numeric vector <code class="reqn">c</code>, is
the skew symmetric matrix having its independent components
represented by the entries of <code class="reqn">c</code> (for a thorough discussion,
see function
<code><a href="#topic+get_skew_symmetric_matrix">get_skew_symmetric_matrix</a></code>).
</p>
<p>Functions <code>local_error_sampler</code> and <code>local_rotation_composer</code>
must be prototyped as having one argument, <code>point</code>,
representing the Cartesian coordinates of a point on a 3D sphere,
and returning a non <code>NULL</code> numerical object having length
equal to <code>3</code>.
</p>


<h3>Value</h3>

<p>An <em>m</em>-by-<em>3</em> matrix whose rows contain
the Cartesian coordinates of the response points corresponding
to the explanatory points.
</p>


<h3>See Also</h3>

<p>Other Regression functions: 
<code><a href="#topic+cross_validate_concentration">cross_validate_concentration</a>()</code>,
<code><a href="#topic+fit_regression">fit_regression</a>()</code>,
<code><a href="#topic+get_equally_spaced_points">get_equally_spaced_points</a>()</code>,
<code><a href="#topic+get_skew_symmetric_matrix">get_skew_symmetric_matrix</a>()</code>,
<code><a href="#topic+simulate_rigid_regression">simulate_rigid_regression</a>()</code>,
<code><a href="#topic+weight_explanatory_points">weight_explanatory_points</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(nprotreg)

# Define a matrix of explanatory points.

explanatory_points &lt;- rbind(
  cbind(.5, 0, .8660254),
  cbind(-.5, 0, .8660254),
  cbind(1, 0, 0),
  cbind(0, 1, 0),
  cbind(-1, 0, 0),
  cbind(0, -1, 0),
  cbind(.5, 0, -.8660254),
  cbind(-.5, 0, -.8660254)
)

# Define a local rotation composer.

local_rotation_composer &lt;- function(point) {
  independent_components &lt;- (1 / 2) *
    c(exp(2.0 * point[3]), - exp(2.0 * point[2]), exp(2.0 * point[1]))
}

# Define a local error sampler.

local_error_sampler &lt;- function(point) {
  rnorm(3)
}

# Get the corresponding 8-by-3 matrix of response points.
# Rows corresponds to explanatory points,
# columns to Cartesian coordinates.

response_points &lt;- simulate_regression(explanatory_points,
                                       local_rotation_composer,
                                       local_error_sampler)

# Get the response point corresponding to the second
# explanatory point.

cat("Response point corresponding to the second explanatory point: \n")
cat(response_points[2, ], "\n")
</code></pre>

<hr>
<h2 id='simulate_rigid_regression'>Simulates a Rigid 3D Spherical Regression.</h2><span id='topic+simulate_rigid_regression'></span>

<h3>Description</h3>

<p>Returns the response points corresponding to the specified explanatory
points, given a rigid rotation model
and an error term sampler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_rigid_regression(
  explanatory_points,
  rotation_matrix,
  local_error_sampler
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_rigid_regression_+3A_explanatory_points">explanatory_points</code></td>
<td>
<p>An <em>m</em>-by-3 matrix whose rows contain
the Cartesian coordinates of the points at which the regression
will be simulated.</p>
</td></tr>
<tr><td><code id="simulate_rigid_regression_+3A_rotation_matrix">rotation_matrix</code></td>
<td>
<p>A 3-by-3 rotation matrix.</p>
</td></tr>
<tr><td><code id="simulate_rigid_regression_+3A_local_error_sampler">local_error_sampler</code></td>
<td>
<p>A function that returns a 3-length numeric vector
representing a sampled error term local to an explanatory point,
given its Cartesian coordinates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">E</code> be
the <em>m</em>-by-3 matrix of explanatory points.
This function will return
an <em>m</em>-by-<em>3</em> matrix whose <code class="reqn">i</code>-th row is obtained by
transposition of the following expression:
</p>
<p style="text-align: center;"><code class="reqn">exp(\Phi(\epsilon(x))) R x</code>
</p>

<p>where <code class="reqn">x</code> is the transpose of the <code class="reqn">i</code>-th row of
<code class="reqn">E</code> and <code class="reqn">R</code> is <code>rotation_matrix</code>.
Term <code class="reqn">\epsilon(x)</code> is obtained by
evaluating at <code class="reqn">x</code> function <code>local_error_sampler</code>, while
matrix <code class="reqn">\Phi(c)</code>, for a 3-length numeric vector <code class="reqn">c</code>, is
the skew symmetric matrix having its independent components
represented by the entries of <code class="reqn">c</code> (for a thorough discussion,
see function
<code><a href="#topic+get_skew_symmetric_matrix">get_skew_symmetric_matrix</a></code>).
</p>
<p>Function <code>local_error_sampler</code>
must be prototyped as having one argument, <code>point</code>,
representing the Cartesian coordinates of a point on a 3D sphere,
and returning a non <code>NULL</code> numerical object having length
equal to <code>3</code>.
</p>


<h3>Value</h3>

<p>An <em>m</em>-by-<em>3</em> matrix whose rows contain
the Cartesian coordinates of the response points corresponding
to the explanatory points.
</p>


<h3>See Also</h3>

<p>Other Regression functions: 
<code><a href="#topic+cross_validate_concentration">cross_validate_concentration</a>()</code>,
<code><a href="#topic+fit_regression">fit_regression</a>()</code>,
<code><a href="#topic+get_equally_spaced_points">get_equally_spaced_points</a>()</code>,
<code><a href="#topic+get_skew_symmetric_matrix">get_skew_symmetric_matrix</a>()</code>,
<code><a href="#topic+simulate_regression">simulate_regression</a>()</code>,
<code><a href="#topic+weight_explanatory_points">weight_explanatory_points</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(nprotreg)

# Define a matrix of explanatory points.

explanatory_points &lt;- rbind(
  cbind(.5, 0, .8660254),
  cbind(-.5, 0, .8660254),
  cbind(1, 0, 0),
  cbind(0, 1, 0),
  cbind(-1, 0, 0),
  cbind(0, -1, 0),
  cbind(.5, 0, -.8660254),
  cbind(-.5, 0, -.8660254)
)

# Define a rotation matrix.

rotation_matrix &lt;- rbind(
    cbind(-0.69492055764131177575, 0.71352099052778772403, 0.08929285886191218324),
    cbind(-0.19200697279199935297, -0.30378504433947051133, 0.93319235382364695841),
    cbind(0.69297816774177023458, 0.63134969938371787723, 0.34810747783026463331)
)

# Define a local error sampler.

local_error_sampler &lt;- function(point) {
  rnorm(3)
}

# Get the corresponding 8-by-3 matrix of response points.
# Rows corresponds to explanatory points,
# columns to Cartesian coordinates.

response_points &lt;- simulate_rigid_regression(explanatory_points,
                                             rotation_matrix,
                                             local_error_sampler)

# Get the response point corresponding to the second
# explanatory point.

cat("Response point corresponding to the second explanatory point: \n")
cat(response_points[2, ], "\n")
</code></pre>

<hr>
<h2 id='weight_explanatory_points'>Weights the Specified Explanatory Points in a 3D Spherical Regression.</h2><span id='topic+weight_explanatory_points'></span>

<h3>Description</h3>

<p>Returns the weights assigned to the specified explanatory points
for each evaluation point under study, given a concentration parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weight_explanatory_points(evaluation_points, explanatory_points, concentration)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weight_explanatory_points_+3A_evaluation_points">evaluation_points</code></td>
<td>
<p>An <em>n</em>-by-3 matrix whose rows contain
the Cartesian coordinates of the points on which the regression
will be estimated.</p>
</td></tr>
<tr><td><code id="weight_explanatory_points_+3A_explanatory_points">explanatory_points</code></td>
<td>
<p>An <em>m</em>-by-3 matrix whose rows contain
the Cartesian coordinates of the explanatory points used to
calculate the regression estimators.</p>
</td></tr>
<tr><td><code id="weight_explanatory_points_+3A_concentration">concentration</code></td>
<td>
<p>A non negative scalar whose reciprocal value
is proportional to the bandwidth applied while estimating
a spherical regression model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">X</code> be the <em>m</em>-by-3 matrix of explanatory points, and <code class="reqn">E</code>
the <em>n</em>-by-3 matrix of evaluation points, and <code class="reqn">\kappa</code> the
concentration parameter. This function will return
an <em>m</em>-by-<em>n</em> matrix whose <code class="reqn">(i,j)</code> entry is defined as
follows:
</p>
<p style="text-align: center;"><code class="reqn">exp(\kappa (s(i,j) - 1))</code>
</p>

<p>where <code class="reqn">s(i,j)</code> is the scalar product of the <code class="reqn">i</code>-th row of
<code class="reqn">X</code> and the <code class="reqn">j</code>-th row of <code class="reqn">E</code>.
</p>


<h3>Value</h3>

<p>An <em>m</em>-by-<em>n</em> matrix whose <em>j</em>-th column contains
the weights assigned to the explanatory points while analyzing the
<em>j</em>-th evaluation point.
</p>


<h3>See Also</h3>

<p>Other Regression functions: 
<code><a href="#topic+cross_validate_concentration">cross_validate_concentration</a>()</code>,
<code><a href="#topic+fit_regression">fit_regression</a>()</code>,
<code><a href="#topic+get_equally_spaced_points">get_equally_spaced_points</a>()</code>,
<code><a href="#topic+get_skew_symmetric_matrix">get_skew_symmetric_matrix</a>()</code>,
<code><a href="#topic+simulate_regression">simulate_regression</a>()</code>,
<code><a href="#topic+simulate_rigid_regression">simulate_rigid_regression</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(nprotreg)

# Define a matrix of evaluation points.

north_pole &lt;- cbind(0, 0, 1)
south_pole &lt;- cbind(0, 0, -1)
evaluation_points &lt;- rbind(north_pole, south_pole)

# Define a matrix of explanatory points

explanatory_points &lt;- rbind(
  cbind(.5, 0, .8660254),
  cbind(-.5, 0, .8660254),
  cbind(1, 0, 0),
  cbind(0, 1, 0),
  cbind(-1, 0, 0),
  cbind(0, -1, 0),
  cbind(.5, 0, -.8660254),
  cbind(-.5, 0, -.8660254)
)

# Define a value for the concentration parameter.

concentration &lt;- 1.0

# Get the corresponding 8-by-2 matrix of weights.
# Columns corresponds to evaluation points,
# rows to explanatory ones.

weights &lt;- weight_explanatory_points(evaluation_points,
                                     explanatory_points,
                                     concentration)

# Get the weights assigned to the explanatory points
# while analyzing the second evaluation point.

cat("Weights assigned while analyzing the second evaluation point: \n")
cat(weights[, 2], "\n")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
