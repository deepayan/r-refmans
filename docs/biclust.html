<!DOCTYPE html><html lang="en"><head><title>Help for package biclust</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {biclust}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BCBimax'><p>The Bimax Bicluster algorithm</p></a></li>
<li><a href='#BCCC'><p>The CC Bicluster algorithm</p></a></li>
<li><a href='#BCPlaid'><p>The Plaid Model Bicluster algorithm</p></a></li>
<li><a href='#BCQuest'><p>The Questmotif Bicluster algorithm</p></a></li>
<li><a href='#BCSpectral'><p>The Spectral Bicluster algorithm</p></a></li>
<li><a href='#BCXmotifs'><p>The Xmotifs Bicluster algorithm</p></a></li>
<li><a href='#BicatYeast'><p>BicAT Yeast</p></a></li>
<li><a href='#biclust'><p>The biclust Method</p></a></li>
<li><a href='#Biclust-class'><p>The Biclust Class</p></a></li>
<li><a href='#biclustbarchart'><p>Bicluster Barchart</p></a></li>
<li><a href='#bicluster'><p>Extract Bilcuster</p></a></li>
<li><a href='#biclustmember'><p>Bicluster Membership Graph</p></a></li>
<li><a href='#BiclustMethod-class'><p>The BiclustMethod Virtual Class</p></a></li>
<li><a href='#bimax.grid'>
<p>Parameter Grid for BCBimax Biclustering</p></a></li>
<li><a href='#binarize'><p>Binarize</p></a></li>
<li><a href='#bubbleplot'><p>Bubbleplot</p></a></li>
<li><a href='#ChiaKaruturi'>
<p>Chia and Karuturi Function</p></a></li>
<li><a href='#coherence'><p>Coherence measures</p></a></li>
<li><a href='#computeObservedFstat'>
<p>Diagnostic F Statistic Calculation</p></a></li>
<li><a href='#diagnoseColRow'>
<p>Bootstrap Procedure for Bicluster Diagnostics</p></a></li>
<li><a href='#diagnosticPlot'>
<p>Diagnostic F Statistics Visualization</p></a></li>
<li><a href='#diagnosticPlot2'><p>Diagnostics F Statistiics Visualization</p></a></li>
<li><a href='#diagnosticTest'><p>Testing Procedure for Bicluster Diagnostics</p></a></li>
<li><a href='#discretize'><p>Create a discret matrix</p></a></li>
<li><a href='#drawHeatmap'><p>Draw Heatmap</p></a></li>
<li><a href='#EisenYeast'><p>Eisen Yeast</p></a></li>
<li><a href='#ensemble'>
<p>Ensemble Methods for Bicluster Algorithms</p></a></li>
<li><a href='#heatmapBC'><p>Overlapping Heatmap</p></a></li>
<li><a href='#isoverlapp'><p>Is Bicresult overlapping?</p></a></li>
<li><a href='#jaccardind'><p>Jaccardind</p></a></li>
<li><a href='#parallelCoordinates'><p>Parallel Coordinates</p></a></li>
<li><a href='#plaid.grid'>
<p>Parameter Grid for BCPlaid Biclustering</p></a></li>
<li><a href='#plotclust'><p>Barplot of Bicluster</p></a></li>
<li><a href='#predictBimax'><p>Predict from a BCrepBimax Result</p></a></li>
<li><a href='#SyntrenEcoli'><p>SynTReN E. coli</p></a></li>
<li><a href='#writeBiclusterResults'><p>writeBiclusterResults</p></a></li>
<li><a href='#writeclust'><p>Write a Bicluster as a Cluster Result</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>2.0.3.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-05-22</td>
</tr>
<tr>
<td>Author:</td>
<td>Sebastian Kaiser, Rodrigo Santamaria, Tatsiana Khamiakova,
        Martin Sill, Roberto Theron, Luis Quintales, Friedrich
        Leisch, Ewoud De Troyer and Sami Leon.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sebastian Kaiser &lt;dr.sebastian.kaiser@gmail.com&gt;</td>
</tr>
<tr>
<td>Title:</td>
<td>BiCluster Algorithms</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), MASS, grid, colorspace, lattice</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, flexclust, additivityTests, tidyr, ggplot2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>isa2</td>
</tr>
<tr>
<td>Description:</td>
<td>The main function biclust() provides several algorithms to
        find biclusters in two-dimensional data: Cheng and Church (2000, ISBN:1-57735-115-0),
        spectral (2003) &lt;<a href="https://doi.org/10.1101%2Fgr.648603">doi:10.1101/gr.648603</a>&gt;, plaid model (2005) &lt;<a href="https://doi.org/10.1016%2Fj.csda.2004.02.003">doi:10.1016/j.csda.2004.02.003</a>&gt;, xmotifs (2003) &lt;<a href="https://doi.org/10.1142%2F9789812776303_0008">doi:10.1142/9789812776303_0008</a>&gt; and bimax (2006) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtl060">doi:10.1093/bioinformatics/btl060</a>&gt;. In addition, the
        package provides methods for data preprocessing (normalization
        and discretisation), visualisation, and validation of bicluster
        solutions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-13 08:40:36 UTC; ripley</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-19 07:18:34 UTC</td>
</tr>
</table>
<hr>
<h2 id='BCBimax'>The Bimax Bicluster algorithm</h2><span id='topic+BCBimax'></span><span id='topic+Bimax'></span><span id='topic+BCBimax-class'></span><span id='topic+biclust+2Cmatrix+2CBCBimax-method'></span><span id='topic+BCrepBimax'></span><span id='topic+repBimax'></span><span id='topic+BCrepBimax-class'></span><span id='topic+biclust+2Cmatrix+2CBCrepBimax-method'></span>

<h3>Description</h3>

<p>Performs Bimax Biclustering based on the framework by Prelic et. al.(2006). It searches for submatrices of ones in a logical matrix. Uses the original C code of the authors.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix,BCBimax'
biclust(x, method=BCBimax(), minr=2, minc=2, number=100)
## S4 method for signature 'matrix,BCrepBimax'
biclust(x, method=BCrepBimax(), minr=2, minc=2, number=100, maxc=12)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BCBimax_+3A_x">x</code></td>
<td>
<p>A logical matrix which represents the data.</p>
</td></tr>
<tr><td><code id="BCBimax_+3A_method">method</code></td>
<td>
<p>Here BCBimax, to perform Bimax algorithm</p>
</td></tr>
<tr><td><code id="BCBimax_+3A_minr">minr</code></td>
<td>
<p>Minimum row size of resulting bicluster.</p>
</td></tr>
<tr><td><code id="BCBimax_+3A_minc">minc</code></td>
<td>
<p>Minimum column size of resulting bicluster.</p>
</td></tr>
<tr><td><code id="BCBimax_+3A_number">number</code></td>
<td>
<p>Number of Bicluster to be found.</p>
</td></tr>
<tr><td><code id="BCBimax_+3A_maxc">maxc</code></td>
<td>
<p>Maximum column size of resulting bicluster.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>Biclust</code>.
</p>


<h3>Author(s)</h3>

<p>Sebastian Kaiser 
<a href="mailto:sebastian.kaiser@stat.uni-muenchen.de">sebastian.kaiser@stat.uni-muenchen.de</a>
</p>


<h3>References</h3>

<p>Prelic, A.; Bleuler, S.; Zimmermann, P.; Wil, A.; Buhlmann, P.; Gruissem, W.; Hennig, L.; Thiele, L. &amp; Zitzler, E. 
A Systematic Comparison and Evaluation of Biclustering Methods for Gene Expression Data Bioinformatics,
Oxford Univ Press, 2006, 22, 1122-1129
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+biclust">biclust</a></code>, <code><a href="#topic+Biclust">Biclust</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'> test &lt;- matrix(rnorm(5000), 100, 50)
 test[11:20,11:20] &lt;- rnorm(100, 3, 0.1)
 loma &lt;- binarize(test,2)
 res &lt;- biclust(x=loma, method=BCBimax(), minr=4, minc=4, number=10)
 res
</code></pre>

<hr>
<h2 id='BCCC'>The CC Bicluster algorithm</h2><span id='topic+BCCC'></span><span id='topic+CC'></span><span id='topic+BCCC-class'></span><span id='topic+biclust+2Cmatrix+2CBCCC-method'></span>

<h3>Description</h3>

<p>Performs CC Biclustering based on the framework by Cheng and Church (2000). Searches for submatrices with a score lower than a specific treshold in a standardized data matrix. </p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix,BCCC'
biclust(x, method=BCCC(), delta = 1.0, alpha=1.5, number=100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BCCC_+3A_x">x</code></td>
<td>
<p>Data matrix.</p>
</td></tr>
<tr><td><code id="BCCC_+3A_method">method</code></td>
<td>
<p>Here BCCC, to perform CC algorithm</p>
</td></tr>
<tr><td><code id="BCCC_+3A_delta">delta</code></td>
<td>
<p>Maximum of accepted score.</p>
</td></tr>
<tr><td><code id="BCCC_+3A_alpha">alpha</code></td>
<td>
<p>Scaling factor.</p>
</td></tr>
<tr><td><code id="BCCC_+3A_number">number</code></td>
<td>
<p>Number of bicluster to be found.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>Biclust</code>.
</p>


<h3>Author(s)</h3>

<p>Sebastian Kaiser 
<a href="mailto:sebastian.kaiser@stat.uni-muenchen.de">sebastian.kaiser@stat.uni-muenchen.de</a>
</p>


<h3>References</h3>

<p>Cheng, Y. &amp; Church, G.M. 
Biclustering of Expression Data 
Proceedings of the Eighth International Conference on Intelligent Systems for Molecular Biology, 
2000, 1, 93-103
</p>


<h3>See Also</h3>

<p><code><a href="#topic+biclust">biclust</a></code>, <code><a href="#topic+Biclust">Biclust</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>test &lt;- matrix(rbinom(400, 50, 0.4), 20, 20)
res &lt;- biclust(test, method=BCCC(), delta=1.5,  alpha=1, number=10)
res
</code></pre>

<hr>
<h2 id='BCPlaid'>The Plaid Model Bicluster algorithm</h2><span id='topic+BCPlaid'></span><span id='topic+plaid'></span><span id='topic+plaid+20model'></span><span id='topic+BCPlaid-class'></span><span id='topic+turner+20biclustering'></span><span id='topic+biclust+2Cmatrix+2CBCPlaid-method'></span>

<h3>Description</h3>

<p> Performs Plaid Model Biclustering as described in Turner et al., 2003. This is an improvement of original
'Plaid Models for Gene Expression Data' (Lazzeroni and Owen, 2002).
This algorithm models data matrices to a sum of layers, the model is fitted
to data through minimization of error. </p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix,BCPlaid'
biclust(x, method=BCPlaid(), cluster="b", fit.model = y ~ m + a + b,
  background = TRUE, background.layer = NA, background.df = 1, row.release = 0.7, 
  col.release = 0.7, shuffle = 3, back.fit = 0, max.layers = 20, iter.startup = 5,
  iter.layer = 10, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BCPlaid_+3A_x">x</code></td>
<td>
<p>The data matrix where biclusters have to be found</p>
</td></tr>
<tr><td><code id="BCPlaid_+3A_method">method</code></td>
<td>
<p>Here BCPlaid, to perform Plaid algorithm</p>
</td></tr>
<tr><td><code id="BCPlaid_+3A_cluster">cluster</code></td>
<td>
<p>'r', 'c' or 'b', to cluster rows, columns or both (default 'b')</p>
</td></tr>
<tr><td><code id="BCPlaid_+3A_fit.model">fit.model</code></td>
<td>
<p>Model (formula) to fit each layer. Usually, a linear model is used, that
estimates three parameters: m (constant for all elements in the bicluster),
a(contant for all rows in the bicluster) and b (constant for all columns).
Thus, default is: y ~ m + a + b.</p>
</td></tr>
<tr><td><code id="BCPlaid_+3A_background">background</code></td>
<td>
<p>If 'TRUE' the method will consider that a background layer
(constant for all rows and columns) is present in the data matrix.</p>
</td></tr>
<tr><td><code id="BCPlaid_+3A_background.layer">background.layer</code></td>
<td>
<p>If background='TRUE' a own background layer
(Matrix with dimension of x) can be specified.</p>
</td></tr>
<tr><td><code id="BCPlaid_+3A_background.df">background.df</code></td>
<td>
<p>Degrees of Freedom of backround layer if background.layer is specified.</p>
</td></tr>
<tr><td><code id="BCPlaid_+3A_shuffle">shuffle</code></td>
<td>
<p>Before a layer is added, it's statistical significance is compared
against a number of layers obtained by random defined by this parameter. Default is
3, higher numbers could affect time performance. </p>
</td></tr>
<tr><td><code id="BCPlaid_+3A_iter.startup">iter.startup</code></td>
<td>
<p>Number of iterations to find starting values </p>
</td></tr>
<tr><td><code id="BCPlaid_+3A_iter.layer">iter.layer</code></td>
<td>
<p>Number of iterations to find each layer </p>
</td></tr>
<tr><td><code id="BCPlaid_+3A_back.fit">back.fit</code></td>
<td>
<p>After a layer is added, additional iterations can be done to
refine the fitting of the layer (default set to 0)</p>
</td></tr>
<tr><td><code id="BCPlaid_+3A_row.release">row.release</code></td>
<td>
<p>Scalar in [0,1](with interval recommended [0.5-0.7]) used as threshold to prune rows in the layers
depending on row homogeneity</p>
</td></tr>
<tr><td><code id="BCPlaid_+3A_col.release">col.release</code></td>
<td>
<p>As above, with columns </p>
</td></tr>
<tr><td><code id="BCPlaid_+3A_max.layers">max.layers</code></td>
<td>
<p>Maximum number of layer to include in the model </p>
</td></tr>
<tr><td><code id="BCPlaid_+3A_verbose">verbose</code></td>
<td>
<p>If 'TRUE' prints extra information on progress.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an Biclust object.
</p>


<h3>Author(s)</h3>

<p>Adaptation of original code from Heather Turner from Rodrigo Santamaria <a href="mailto:rodri@usal.es">rodri@usal.es</a>.
<a href="mailto:rodri@usal.es">rodri@usal.es</a>
</p>


<h3>References</h3>

<p>Heather Turner et al, &quot;Improved biclustering of microarray data demonstrated through systematic
performance tests&quot;,Computational Statistics and Data Analysis, 2003, vol. 48, pages 235-254.
</p>
<p>Lazzeroni and Owen, &quot;Plaid Models for Gene Expression Data&quot;, Standford University, 2002.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #Random matrix with embedded bicluster
  test &lt;- matrix(rnorm(5000),100,50)
  test[11:20,11:20] &lt;- rnorm(100,3,0.3)
  res&lt;-biclust(test, method=BCPlaid())
  res

  #microarray matrix
  data(BicatYeast)
  res&lt;-biclust(BicatYeast, method=BCPlaid(), verbose=FALSE)
  res
  </code></pre>

<hr>
<h2 id='BCQuest'>The Questmotif Bicluster algorithm</h2><span id='topic+BCQuest'></span><span id='topic+BCQuestord'></span><span id='topic+BCQuestmet'></span><span id='topic+BCQuest-class'></span><span id='topic+BCQuestord-class'></span><span id='topic+BCQuestmet-class'></span><span id='topic+Quest'></span><span id='topic+biclust+2Cmatrix+2CBCQuestord-method'></span><span id='topic+biclust+2Cmatrix+2CBCQuest-method'></span><span id='topic+biclust+2Cmatrix+2CBCQuestmet-method'></span>

<h3>Description</h3>

<p>Performs Questmotif Biclustering a Bicluster algorithm for questionairs based on the framework by Murali and Kasif (2003). Searches subgroups of questionairs with same or similar answer to some questions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S4 method for signature 'matrix,BCQuest'
biclust(x, method=BCQuest(), ns=10, nd=10, sd=5, alpha=0.05, number=100)
## S4 method for signature 'matrix,BCQuestord'
biclust(x, method=BCQuestord(), d=1, ns=10, nd=10, sd=5, alpha=0.05, number=100)
## S4 method for signature 'matrix,BCQuestmet'
biclust(x, method=BCQuestmet(), quant=0.25, vari=1, ns=10, nd=10, sd=5, 
  alpha=0.05, number=100)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BCQuest_+3A_x">x</code></td>
<td>
<p>Data Matrix.</p>
</td></tr>
<tr><td><code id="BCQuest_+3A_method">method</code></td>
<td>
<p>Here BCQuest, to perform Questmotif algorithm</p>
</td></tr>
<tr><td><code id="BCQuest_+3A_ns">ns</code></td>
<td>
<p>Number of questions choosen.</p>
</td></tr>
<tr><td><code id="BCQuest_+3A_nd">nd</code></td>
<td>
<p>Number of repetitions.</p>
</td></tr>
<tr><td><code id="BCQuest_+3A_sd">sd</code></td>
<td>
<p>Sample size in repetitions.</p>
</td></tr>
<tr><td><code id="BCQuest_+3A_alpha">alpha</code></td>
<td>
<p>Scaling factor for column result.</p>
</td></tr>
<tr><td><code id="BCQuest_+3A_number">number</code></td>
<td>
<p>Number of bicluster to be found.</p>
</td></tr>
<tr><td><code id="BCQuest_+3A_d">d</code></td>
<td>
<p>Half margin of intervall question values should be in (Intervall is mean-d,mean+d).</p>
</td></tr>
<tr><td><code id="BCQuest_+3A_quant">quant</code></td>
<td>
<p>Which quantile to use on metric data</p>
</td></tr>
<tr><td><code id="BCQuest_+3A_vari">vari</code></td>
<td>
<p>Which varianz to use for metric data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>Biclust</code>.
</p>


<h3>Extends</h3>

<p>Class <code>"<a href="#topic+BiclustMethod-class">BiclustMethod</a>"</code>, directly.
</p>


<h3>Author(s)</h3>

<p>Sebastian Kaiser 
<a href="mailto:sebastian.kaiser@stat.uni-muenchen.de">sebastian.kaiser@stat.uni-muenchen.de</a>
</p>


<h3>References</h3>

<p>Murali, T. &amp; Kasif, S. 
Extracting Conserved Gene Expression Motifs from Gene Expression Data 
Pacific Symposium on Biocomputing, sullivan.bu.edu, 
2003, 8, 77-88
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+biclust">biclust</a></code>, <code><a href="#topic+Biclust">Biclust</a></code></p>

<hr>
<h2 id='BCSpectral'>The Spectral Bicluster algorithm</h2><span id='topic+BCSpectral'></span><span id='topic+spectral'></span><span id='topic+spectral+20biclustering'></span><span id='topic+Kluger+20biclustering'></span><span id='topic+BCSpectral-class'></span><span id='topic+biclust+2Cmatrix+2CBCSpectral-method'></span>

<h3>Description</h3>

<p> Performs Spectral Biclustering as described in
Kluger et al., 2003. Spectral biclustering supposes that normalized microarray
data matrices have a checkerboard structure that can be discovered by the use
of svd decomposition in eigenvectors, applied to genes (rows) and conditions
(columns).</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix,BCSpectral'
biclust(x, method=BCSpectral(), normalization="log", numberOfEigenvalues=6, 
minr=2, minc=2, withinVar=1, n_clusters = NULL, n_best = 3)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BCSpectral_+3A_x">x</code></td>
<td>
<p>The data matrix where biclusters are to be found</p>
</td></tr>
<tr><td><code id="BCSpectral_+3A_method">method</code></td>
<td>
<p>Here BCSpectral, to perform Spectral algorithm</p>
</td></tr>
<tr><td><code id="BCSpectral_+3A_normalization">normalization</code></td>
<td>
<p>Normalization method to apply to mat. Three methods are
allowed as described by Kluger et al.:
&quot;log&quot; (Logarithmic normalization),
&quot;irrc&quot; (Independent Rescaling of Rows and Columns) and
&quot;bistochastization&quot;. If &quot;log&quot; 
normalization is used, be sure you can
apply logarithm to elements in data matrix, if there are
values under 1, it automatically will sum
to each element in mat (1+abs(min(mat)))
Default is &quot;log&quot;, as recommended by Kluger et al.</p>
</td></tr>
<tr><td><code id="BCSpectral_+3A_numberofeigenvalues">numberOfEigenvalues</code></td>
<td>
<p>the number of eigenValues considered to find
biclusters. Each row (gene) eigenVector will be combined
with all column (condition) eigenVectors for the first
numberOfEigenValues eigenvalues. Note that a high number could increase
dramatically time performance. Usually, only
the first eigenvectors are used.
With &quot;irrc&quot; and &quot;bistochastization&quot; methods, first
eigenvalue contains background (irrelevant) information, so
it is ignored.</p>
</td></tr>
<tr><td><code id="BCSpectral_+3A_minr">minr</code></td>
<td>
<p>minimum number of rows that biclusters must have. The algorithm
will not consider smaller biclusters.</p>
</td></tr>
<tr><td><code id="BCSpectral_+3A_minc">minc</code></td>
<td>
<p>minimum number of columns that biclusters must have. The algorithm
will not consider smaller biclusters.</p>
</td></tr>
<tr><td><code id="BCSpectral_+3A_withinvar">withinVar</code></td>
<td>
<p>maximum within variation allowed. Since spectral biclustering
outputs a checkerboard structure despite of relevance of individual cells, a
filtering of only relevant cells is necessary by means of this within variation
threshold.</p>
</td></tr>
<tr><td><code id="BCSpectral_+3A_n_clusters">n_clusters</code></td>
<td>
<p>vector with first element the number of row clusters and second element the number of column clusters. If <code>n_clusters = NULL</code>, the number of clusters will be estimated.</p>
</td></tr>
<tr><td><code id="BCSpectral_+3A_n_best">n_best</code></td>
<td>
<p>number of eigenvectors to which the data is projected for the final clustering step, recommended values are 2 or 3.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>Biclust</code>.
</p>


<h3>Author(s)</h3>

<p>Sami Leon <a href="mailto:Sami_Leon@URMC.Rochester.edu">Sami_Leon@URMC.Rochester.edu</a>
</p>
<p>Rodrigo Santamaria <a href="mailto:rodri@usal.es">rodri@usal.es</a>
</p>


<h3>References</h3>

<p>Kluger et al., &quot;Spectral Biclustering of Microarray Data: Coclustering Genes and
Conditions&quot;, Genome Research, 2003, vol. 13, pages 703-716
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Random matrix with embedded bicluster  
test &lt;- matrix(rnorm(5000),100,50)
test[11:20,11:20] &lt;- rnorm(100,10,0.1)
image(test)

shuffled_test &lt;- test[sample(nrow(test)), sample(ncol(test))]
image(shuffled_test)

# Without specifying the  number of row and column clusters
res1 &lt;- spectral(shuffled_test,normalization="log", numberOfEigenvalues=6, 
                 minr=2, minc=2, withinVar=1, n_clusters = NULL, n_best = 3)
res1
image(shuffled_test[order(res1@info$row_labels), order(res1@info$column_labels)])


# Specifying the  number of row and column clusters
res2 &lt;- spectral(shuffled_test,normalization="log", numberOfEigenvalues=6, 
                 minr=2, minc=2, withinVar=1, n_clusters = 2, n_best = 3)
res2
image(shuffled_test[order(res2@info$row_labels), order(res2@info$column_labels)])
  </code></pre>

<hr>
<h2 id='BCXmotifs'>The Xmotifs Bicluster algorithm</h2><span id='topic+BCXmotifs'></span><span id='topic+BCXmotifs-class'></span><span id='topic+Xmotif'></span><span id='topic+biclust+2Cmatrix+2CBCXmotifs-method'></span>

<h3>Description</h3>

<p>Performs XMotifs Biclustering based on the framework by Murali and Kasif (2003). Searches for a submatrix where each row as a similar motif through all columns.
The Algorihm needs a discret matrix to perform.</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S4 method for signature 'matrix,BCXmotifs'
biclust(x, method=BCXmotifs(), ns=10, nd=10, sd=5, alpha=0.05, number=100)


</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BCXmotifs_+3A_x">x</code></td>
<td>
<p>Data Matrix.</p>
</td></tr>
<tr><td><code id="BCXmotifs_+3A_method">method</code></td>
<td>
<p>Here BCXmotifs, to perform Xmotifs algorithm</p>
</td></tr>
<tr><td><code id="BCXmotifs_+3A_ns">ns</code></td>
<td>
<p>Number of columns choosen.</p>
</td></tr>
<tr><td><code id="BCXmotifs_+3A_nd">nd</code></td>
<td>
<p>Number of repetitions.</p>
</td></tr>
<tr><td><code id="BCXmotifs_+3A_sd">sd</code></td>
<td>
<p>Sample size in repetitions.</p>
</td></tr>
<tr><td><code id="BCXmotifs_+3A_alpha">alpha</code></td>
<td>
<p>Scaling factor for column result.</p>
</td></tr>
<tr><td><code id="BCXmotifs_+3A_number">number</code></td>
<td>
<p>Number of bicluster to be found.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>Biclust</code>.
</p>


<h3>Extends</h3>

<p>Class <code>"<a href="#topic+BiclustMethod-class">BiclustMethod</a>"</code>, directly.
</p>


<h3>Author(s)</h3>

<p>Sebastian Kaiser 
<a href="mailto:sebastian.kaiser@stat.uni-muenchen.de">sebastian.kaiser@stat.uni-muenchen.de</a>
</p>


<h3>References</h3>

<p>Murali, T. &amp; Kasif, S. 
Extracting Conserved Gene Expression Motifs from Gene Expression Data 
Pacific Symposium on Biocomputing, sullivan.bu.edu, 
2003, 8, 77-88
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+biclust">biclust</a></code>, <code><a href="#topic+Biclust">Biclust</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(BicatYeast)
x&lt;-discretize(BicatYeast)
res &lt;- biclust(x, method=BCXmotifs(), ns=20, nd=20, sd=5, alpha=0.01, number=10)
res
</code></pre>

<hr>
<h2 id='BicatYeast'>BicAT Yeast</h2><span id='topic+BicatYeast'></span><span id='topic+yeast+20microarray+20reduced+20data+20matrix'></span><span id='topic+Saccharomices+20Cerevisiae+20reduced+20data+20matrix'></span>

<h3>Description</h3>

<p>Microarray data matrix for 80 experiments with Saccharomyces Cerevisiae organism
extracted from BicAT example data set.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data(BicatYeast)
  </code></pre>


<h3>Format</h3>

<p>Data structure with information about the expression levels of 419 probesets 
over 70 conditions
Row names follow Affymetrix probeset notation
</p>


<h3>Source</h3>

<p>BicAT datasets at http://www.tik.ee.ethz.ch/sop/bicat/
</p>

<hr>
<h2 id='biclust'>The biclust Method</h2><span id='topic+biclust'></span><span id='topic+biclust-method'></span><span id='topic+biclust+2Cmatrix+2CBiclustMethod-method'></span><span id='topic+biclust+2Cmatrix+2Cfunction-method'></span><span id='topic+biclust+2Cmatrix+2Ccharacter-method'></span>

<h3>Description</h3>

<p>The function <code>biclust</code> is the main function of the package. It calculates the bicluster in a data matrix using the algorithm specified in the method-argument. 
Currently the package contains 5 different methods for the use in <code>biclust</code>. For each algorithm see the class help files for further details.
For some algorithms preproccessing is necessary, e.g. <code>BCBimax</code> only runs with a logical matrix.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'matrix,BiclustMethod'
biclust(x,method,...)
## S4 method for signature 'matrix,character'
biclust(x,method,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="biclust_+3A_x">x</code></td>
<td>
<p>Data matrix.</p>
</td></tr>
<tr><td><code id="biclust_+3A_method">method</code></td>
<td>
<p>An object of class <code>"BiclustMethod"</code> or a character string with the name of a <code>"BiclustMethod"</code>-class.</p>
</td></tr>
<tr><td><code id="biclust_+3A_...">...</code></td>
<td>
<p>Additional Parameters of the <code>"BiclustMethod"</code> </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>Biclust</code>.
</p>


<h3>Author(s)</h3>

<p>Sebastian Kaiser 
<a href="mailto:sebastian.kaiser@stat.uni-muenchen.de">sebastian.kaiser@stat.uni-muenchen.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Biclust-class">Biclust-class</a></code>, <code><a href="#topic+BCCC">BCCC</a></code>, <code><a href="#topic+BCXmotifs">BCXmotifs</a></code>, <code><a href="#topic+BCPlaid">BCPlaid</a></code>, <code><a href="#topic+BCSpectral">BCSpectral</a></code>, <code><a href="#topic+BCBimax">BCBimax</a></code>, <code><a href="#topic+BCQuest">BCQuest</a></code>, <code><a href="#topic+BiclustMethod-class">BiclustMethod-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test &lt;- matrix(rbinom(400, 50, 0.4), 20, 20)
res1 &lt;- biclust(test, method=BCCC(), delta=1.5,  alpha=1, number=10)

</code></pre>

<hr>
<h2 id='Biclust-class'>The Biclust Class</h2><span id='topic+Biclust'></span><span id='topic+Biclust-class'></span><span id='topic+BiclustResult'></span><span id='topic+show+2CBiclust-method'></span><span id='topic+summary+2CBiclust-method'></span>

<h3>Description</h3>

<p>Biclust is the class structure for results of a bicluster algorithm. It contains all information needed for further processing.
The <code>show</code> Method gives the Name of the Algorithm used and the first Bicluster found.
The <code>summary</code> Method gives sizes of all bicluster found.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by performing a bicluster algorithm via the <code>biclust()</code> function.</p>


<h3>Slots</h3>

<p>Objects of class <code>Biclust</code> have the following slots:
</p>

<dl>
<dt><code>Parameters</code>:</dt><dd><p>Saves input Parameters in a list</p>
</dd>
<dt><code>RowxNumber</code>:</dt><dd><p>Logical Matrix which contains 1 in [i,j] if Row i is in Bicluster j</p>
</dd>
<dt><code>NumberxCol</code>:</dt><dd><p>Logical Matrix which contains 1 in [i,j] if Col j is in Bicluster i</p>
</dd>
<dt><code>Number</code>:</dt><dd><p>Number of Bicluster</p>
</dd>
<dt><code>info</code>:</dt><dd><p>Additional Outputs from the different bicluster algorithms</p>
</dd>
</dl>



<h3>Details</h3>

<p><code>RowxNumber</code> and <code>NumberxCol</code> are named after the arrangement of the data they contain. The column results are transposed in order to ensure a easy processing.
</p>


<h3>Author(s)</h3>

<p>Sebastian Kaiser 
<a href="mailto:sebastian.kaiser@stat.uni-muenchen.de">sebastian.kaiser@stat.uni-muenchen.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+biclust">biclust</a></code>, <code><a href="#topic+BiclustMethod-class">BiclustMethod-class</a></code>
</p>

<hr>
<h2 id='biclustbarchart'>Bicluster Barchart</h2><span id='topic+biclustbarchart'></span>

<h3>Description</h3>

<p> Draws a barchart for a Bicluster result representing the columns</p>


<h3>Usage</h3>

<pre><code class='language-R'>biclustbarchart(x, Bicres, which=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="biclustbarchart_+3A_x">x</code></td>
<td>
<p>The data matrix</p>
</td></tr>
<tr><td><code id="biclustbarchart_+3A_bicres">Bicres</code></td>
<td>
<p>BiclustResult object with a bicluster result set. If this value
is set to NULL, the data matrix is drawn as a heatmap, without any reordering. Default NULL.</p>
</td></tr>
<tr><td><code id="biclustbarchart_+3A_which">which</code></td>
<td>
<p>If specified gives the ploting order of the columns from bottom to top</p>
</td></tr>
<tr><td><code id="biclustbarchart_+3A_...">...</code></td>
<td>
<p>Additional plot options passed to barchart</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sebastian Kaiser
<a href="mailto:sebastian.kaiser@stat.uni-muenchen.de">sebastian.kaiser@stat.uni-muenchen.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bubbleplot">bubbleplot</a></code> for simultaneous representation of biclusters,
<code><a href="#topic+parallelCoordinates">parallelCoordinates</a></code>for single representation of biclusters as lines of gene or condition profiles,
<code><a href="#topic+drawHeatmap">drawHeatmap</a></code>for Heatmap representation of biclusters and 
<code><a href="#topic+biclustmember">biclustmember</a></code> for a membership graph.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  set.seed(1)
  x=matrix(rnorm(900),30,30)
  x[1:5,1:5]=rnorm(25,3,0.3)
  x[11:15,11:15]=rnorm(25,-3,0.3)
  x[21:25,21:25]=rnorm(25,6,0.3)
  colnames(x)&lt;-paste("Var.",1:30)
  bics &lt;- biclust(x,BCPlaid(), back.fit = 2, shuffle = 3, fit.model = ~m
+ a + b, iter.startup = 5, iter.layer = 30,  verbose = TRUE)  
  biclustbarchart(x,bics, col="#A3E0D8")
  ord&lt;-bicorder(bics, cols=TRUE, rev=TRUE)
  biclustbarchart(x,bics,which=ord)
  

</code></pre>

<hr>
<h2 id='bicluster'>Extract Bilcuster</h2><span id='topic+bicluster'></span><span id='topic+biclusternumber'></span>

<h3>Description</h3>

<p> Function to extract the bicluster or the row and column numbers from a given bicluster result</p>


<h3>Usage</h3>

<pre><code class='language-R'>bicluster(x, BicRes, number= 1:BicRes@Number)
biclusternumber(BicRes, number= 1:BicRes@Number)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bicluster_+3A_x">x</code></td>
<td>
<p>The data matrix</p>
</td></tr>
<tr><td><code id="bicluster_+3A_bicres">BicRes</code></td>
<td>
<p>BiclustResult object</p>
</td></tr>
<tr><td><code id="bicluster_+3A_number">number</code></td>
<td>
<p>Which bicluster to be extracted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing all extracted bicluster</p>


<h3>Author(s)</h3>

<p>Sebastian Kaiser
<a href="mailto:sebastian.kaiser@stat.uni-muenchen.de">sebastian.kaiser@stat.uni-muenchen.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+writeclust">writeclust</a></code>,<code><a href="#topic+writeBiclusterResults">writeBiclusterResults</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  s2=matrix(rnorm(400),20,20)
  s2[12:16,12:16]=rnorm(25,3,0.3)
  set.seed(1)
  bics &lt;- biclust(s2,BCPlaid(), back.fit = 2, shuffle = 3, fit.model = ~m + a + b,
  iter.startup = 5, iter.layer = 30,  verbose = TRUE)
  bicluster(s2, bics)
  biclusternumber(bics)


</code></pre>

<hr>
<h2 id='biclustmember'>Bicluster Membership Graph</h2><span id='topic+clustmember'></span><span id='topic+biclustmember'></span><span id='topic+bicorder'></span>

<h3>Description</h3>

<p> Draws a membership graph cluster x columns</p>


<h3>Usage</h3>

<pre><code class='language-R'>biclustmember(bicResult, x, mid = T, cl_label = "", which=NA, 
  main = "BiCluster Membership Graph", xlab="Cluster", 
  color=diverge_hcl(101, h = c(0, 130)), ...)

clustmember(res, x, mid = T, cl_label = "", which=NA, 
  main = "Cluster Membership Graph", xlab="Cluster", 
  color=diverge_hcl(101, h = c(0, 130)), ...)

bicorder(bicResult, cols=TRUE, rev=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="biclustmember_+3A_x">x</code></td>
<td>
<p>The data matrix</p>
</td></tr>
<tr><td><code id="biclustmember_+3A_bicresult">bicResult</code></td>
<td>
<p>BiclustResult object with a bicluster result set.</p>
</td></tr>
<tr><td><code id="biclustmember_+3A_res">res</code></td>
<td>
<p>Cluster Result (is converted into a kcca object)</p>
</td></tr>
<tr><td><code id="biclustmember_+3A_mid">mid</code></td>
<td>
<p>If TRUE, shows the value of the remaining objects inside the cluster value, else shows both aside each other.</p>
</td></tr>
<tr><td><code id="biclustmember_+3A_cl_label">cl_label</code></td>
<td>
<p>Ticks of x-axis</p>
</td></tr>
<tr><td><code id="biclustmember_+3A_which">which</code></td>
<td>
<p>If specified gives the ploting order of the columns from bottom to top</p>
</td></tr>
<tr><td><code id="biclustmember_+3A_main">main</code></td>
<td>
<p>Gives the title of the plot</p>
</td></tr>
<tr><td><code id="biclustmember_+3A_xlab">xlab</code></td>
<td>
<p>Label of x-axis</p>
</td></tr>
<tr><td><code id="biclustmember_+3A_color">color</code></td>
<td>
<p>Range of colors for the plot</p>
</td></tr>
<tr><td><code id="biclustmember_+3A_...">...</code></td>
<td>
<p>Additional plot options or if neccessary option for as.kcca</p>
</td></tr>
<tr><td><code id="biclustmember_+3A_cols">cols</code></td>
<td>
<p>If TRUE orders the column by appearance in the bicluster, else orders the rows.</p>
</td></tr>
<tr><td><code id="biclustmember_+3A_rev">rev</code></td>
<td>
<p>If TRUE reverses the order</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sebastian Kaiser
<a href="mailto:sebastian.kaiser@stat.uni-muenchen.de">sebastian.kaiser@stat.uni-muenchen.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bubbleplot">bubbleplot</a></code> for simultaneous representation of biclusters,
<code><a href="#topic+parallelCoordinates">parallelCoordinates</a></code>for single representation of biclusters as lines of gene or condition profiles,
<code><a href="#topic+drawHeatmap">drawHeatmap</a></code>for Heatmap representation of biclusters and
<code><a href="#topic+biclustbarchart">biclustbarchart</a></code> for a barchart.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  set.seed(1)
  x=matrix(rnorm(900),30,30)
  x[1:5,1:5]=rnorm(25,3,0.3)
  x[11:15,11:15]=rnorm(25,-3,0.3)
  x[21:25,21:25]=rnorm(25,6,0.3)
  colnames(x)&lt;-paste("Var.",1:30)
  bics &lt;- biclust(x,BCPlaid(), back.fit = 2, shuffle = 3, fit.model = ~m + a + b,
  iter.startup = 5, iter.layer = 30,  verbose = TRUE)
  
  biclustmember(bics,x)
  
  ord&lt;-bicorder(bics, cols=TRUE, rev=TRUE)
  
  biclustmember(bics,x,which=ord)
  

</code></pre>

<hr>
<h2 id='BiclustMethod-class'>The BiclustMethod Virtual Class</h2><span id='topic+BiclustMethod'></span><span id='topic+BiclustMethod-class'></span>

<h3>Description</h3>

<p>BiclustMethod is the virtual class structure for algorithms provided in the package. In order to use the <code>biclust()</code> function a algorithm has to have a class inherit from here.</p>


<h3>Algorithms</h3>

<p>Currently 6 classes inherit from BiclustMethod:
<code><a href="#topic+BCCC">BCCC</a></code>, <code><a href="#topic+BCXmotifs">BCXmotifs</a></code>, <code><a href="#topic+BCPlaid">BCPlaid</a></code>, <code><a href="#topic+BCSpectral">BCSpectral</a></code>, <code><a href="#topic+BCBimax">BCBimax</a></code>, <code><a href="#topic+BCQuest">BCQuest</a></code>
</p>


<h3>Author(s)</h3>

<p>Sebastian Kaiser 
<a href="mailto:sebastian.kaiser@stat.uni-muenchen.de">sebastian.kaiser@stat.uni-muenchen.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+biclust">biclust</a></code>, <code><a href="#topic+Biclust-class">Biclust-class</a></code>, <code><a href="#topic+BCCC">BCCC</a></code>, <code><a href="#topic+BCXmotifs">BCXmotifs</a></code>, <code><a href="#topic+BCPlaid">BCPlaid</a></code>, <code><a href="#topic+BCSpectral">BCSpectral</a></code>, <code><a href="#topic+BCBimax">BCBimax</a></code>, <code><a href="#topic+BCQuest">BCQuest</a></code>, <code><a href="#topic+BiclustMethod-class">BiclustMethod-class</a></code>
</p>

<hr>
<h2 id='bimax.grid'>
Parameter Grid for BCBimax Biclustering
</h2><span id='topic+bimax.grid'></span>

<h3>Description</h3>

<p>Generates a list containing parameter settings for the ensemble algorithm. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bimax.grid(method = "BCBimax", minr = c(10, 11), minc = c(10, 11), number = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bimax.grid_+3A_method">method</code></td>
<td>
<p>Here BCBimax, to perform Bimax algorithm</p>
</td></tr>
<tr><td><code id="bimax.grid_+3A_minr">minr</code></td>
<td>
<p>Minimum row size of resulting bicluster.</p>
</td></tr>
<tr><td><code id="bimax.grid_+3A_minc">minc</code></td>
<td>
<p>Minimum column size of resulting bicluster.</p>
</td></tr>
<tr><td><code id="bimax.grid_+3A_number">number</code></td>
<td>
<p>Number of Bicluster to be found.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing parameter settings
</p>


<h3>Author(s)</h3>

<p>Sebastian Kaiser 
<a href="mailto:sebastian.kaiser@stat.uni-muenchen.de">sebastian.kaiser@stat.uni-muenchen.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ensemble">ensemble</a></code>, <code><a href="#topic+BCBimax">BCBimax</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bimax.grid()
</code></pre>

<hr>
<h2 id='binarize'>Binarize</h2><span id='topic+binarize'></span><span id='topic+binarizeByPercentage'></span><span id='topic+densityOnes'></span>

<h3>Description</h3>

<p> Methods to convert a real matrix to a binary matrix.</p>


<h3>Usage</h3>

<pre><code class='language-R'>binarize(x, threshold=NA)
binarizeByPercentage(x,percentage, error=0.2, gap=0.1)
densityOnes(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="binarize_+3A_x">x</code></td>
<td>
<p>The data matrix to be binarized.</p>
</td></tr>
<tr><td><code id="binarize_+3A_threshold">threshold</code></td>
<td>
<p>Threshold used to binarize. Values over threshold will be set to 1,
the rest to 0. If threshold is NA, median is used as threshold. Default NA.</p>
</td></tr>
<tr><td><code id="binarize_+3A_percentage">percentage</code></td>
<td>
<p>Percentage of ones against zeros desired in the binary matrix.</p>
</td></tr>
<tr><td><code id="binarize_+3A_error">error</code></td>
<td>
<p>Percentage of ones against zeros in the final matrix will be in [percentage-error, percentage+error]. Default 0.2</p>
</td></tr>
<tr><td><code id="binarize_+3A_gap">gap</code></td>
<td>
<p>Value used for incremental search of threshold. Default 0.1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>binarize</code> function returns a matrix binarized by input threshold, or by the median if no threshold is given.
</p>
<p>The <code>binarizeByPercentage</code> function returns a matrix binarize by input percentage, given as desired density of ones against zeros.
</p>
<p>The <code>densityOnes</code> function returns the percentage of ones against zeros in a logical matrix
</p>


<h3>Author(s)</h3>

<p>Rodrigo Santamaria
<a href="mailto:rodri@usal.es">rodri@usal.es</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(BicatYeast)
  m1=binarize(BicatYeast)
  m2=binarize(BicatYeast, 0.2)
  m3=binarizeByPercentage(BicatYeast, 5)
  densityOnes(m3)
  densityOnes(m2)
  densityOnes(m1)
  drawHeatmap(BicatYeast)
  drawHeatmap(m1)
  drawHeatmap(m2)
  drawHeatmap(m3)
</code></pre>

<hr>
<h2 id='bubbleplot'>Bubbleplot</h2><span id='topic+bubbleplot'></span><span id='topic+bubble+20plot'></span><span id='topic+star+20graph'></span>

<h3>Description</h3>

<p> Draws a bubble plot where each bicluster is represented as a circle
(bubble). Color represents the bicluster set to which bicluster pertains (up to three
bicluster sets can be represented simultaneously). Brightness represents the bicluster homogeneity
(darker, less homogeneous).
Size represents the size of the bicluster, as (number of genes)x(number of conditions).
Location is a 2D-projection of gene and condition profiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bubbleplot(x, bicResult1, bicResult2=NULL, bicResult3=NULL, projection="mean", 
  showLabels=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bubbleplot_+3A_x">x</code></td>
<td>
<p>The data matrix from which biclusters were identified.</p>
</td></tr>
<tr><td><code id="bubbleplot_+3A_bicresult1">bicResult1</code></td>
<td>
<p>BiclustResult object with a bicluster result set whose biclusters will be drawn in green.</p>
</td></tr>
<tr><td><code id="bubbleplot_+3A_bicresult2">bicResult2</code></td>
<td>
<p>BiclustResult object with an optional second bicluster result set. Will be drawn in red (default NULL)</p>
</td></tr>
<tr><td><code id="bubbleplot_+3A_bicresult3">bicResult3</code></td>
<td>
<p>BiclustResult object with an optional third bicluster result set. Will be drawn in blue (default NULL)</p>
</td></tr>
<tr><td><code id="bubbleplot_+3A_projection">projection</code></td>
<td>
<p> Projection algorithm used to position bubbles. Allowed projections are
'mean', 'isomds' and 'cmdscale' (default 'mean').
See details section for a broader explanation.</p>
</td></tr>
<tr><td><code id="bubbleplot_+3A_showlabels">showLabels</code></td>
<td>
<p> If 'TRUE', puts a label over each bubble that tells the number within the
corresponding bicluster result (default 'FALSE').</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Position of circles depend on a
2D projection of the multidimensional point formed by rows and columns present
in the bicluster.
For example, if we have a 3x3  matrix to analyze and we find a bicluster with
rows 1 and 3 and columns 2 and 3, the corresponding multidimensional point
will be p=(1,0,1,0,1,1).
For this example, 'mean' projection will map the bicluster with the point 
x=(1+3)/2=2 and y=(2+3)/2=2,5. Other projections will take the point
p and project it following the corresponding algorithms (see the
corresponding help pages for details)
</p>


<h3>Note</h3>

<p>Bubbleplot 2D-projection, as any multidimensional scaling, loses information,
trying to take the main relationships and trends of n-dimensional data. Thus,
locations and intersections between bubbles-biclusters are only an estimate of its
similarity. This visualization should be used just as a help to understand overall
behavior of biclustering methods, detect trends and outliers, etc.</p>


<h3>Author(s)</h3>

<p>Rodrigo Santamaria
<a href="mailto:rodri@usal.es">rodri@usal.es</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+drawHeatmap">drawHeatmap</a></code> for single representation of biclusters inside data matrix,
<code><a href="#topic+parallelCoordinates">parallelCoordinates</a></code> for single representation of biclusters as lines of gene or condition profiles, <code>cmdscale, isomds</code> for multidimensional scaling and <code>plot</code> for other point representations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
  #Simplified yeast microarray data
  ## Not run:  
  data(BicatYeast)
  set.seed(1)
  bics1 &lt;- biclust(BicatYeast,BCPlaid(), back.fit = 2, shuffle = 3, fit.model = ~m + a + b,
  row.release = 0.7, col.release = 0.7,
  verbose = FALSE, max.layers = 10, iter.startup = 5,
  iter.layer = 30)
  bubbleplot(BicatYeast,bics1, showLabels=TRUE)

  loma=binarize(BicatYeast,2)
  bics2=biclust(loma,BCBimax(), minr=4, minc=4, number=10)
  bubbleplot(BicatYeast,bics1,bics2)
  
## End(Not run)
  </code></pre>

<hr>
<h2 id='ChiaKaruturi'>
Chia and Karuturi Function
</h2><span id='topic+ChiaKaruturi'></span>

<h3>Description</h3>

<p>Function computing scores as described in the paper of Chia and Karuturi (2010)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ChiaKaruturi(x, bicResult, number)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ChiaKaruturi_+3A_x">x</code></td>
<td>

<p>Data Matrix
</p>
</td></tr>
<tr><td><code id="ChiaKaruturi_+3A_bicresult">bicResult</code></td>
<td>

<p><code>Biclust</code> object from <code>biclust</code> package
</p>
</td></tr>
<tr><td><code id="ChiaKaruturi_+3A_number">number</code></td>
<td>

<p>Number of bicluster in the output for computing the scores
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes row (T) and column (B) effects for a chosen bicluster. The scores for columns within bicluster have index 1, the scores 
for columns outside the bicluster have index 2. Ranking score is SB, stratification score is TS. 
</p>


<h3>Value</h3>

<p>Data.Frame with 6 slots: T, B scores for within and outside bicluster, SB and TS scores 
</p>


<h3>Author(s)</h3>

<p>Tatsiana KHAMIAKOVA <a href="mailto:tatsiana.khamiakova@uhasselt.be">tatsiana.khamiakova@uhasselt.be</a>
</p>


<h3>References</h3>

<p>Chia, B. K. H. and Karuturi, R. K. M. (2010) Differential co-expression framework to quantify goodness of biclusters and compare biclustering algorithms. Algorithms for Molecular Biology, 5, 23.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diagnosticPlot">diagnosticPlot</a></code>, <code><a href="#topic+computeObservedFstat">computeObservedFstat</a></code>, <code><a href="#topic+diagnoseColRow">diagnoseColRow</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#---simulate dataset with 1 bicluster ---#
xmat&lt;-matrix(rnorm(50*50,0,0.25),50,50) # background noise only 
rowSize &lt;- 20 #number of rows in a bicluster 
colSize &lt;- 10 #number of columns in a bicluster
a1&lt;-rnorm(rowSize,1,0.1) #sample row effect from N(0,0.1) #adding a coherent values bicluster:
b1&lt;-rnorm((colSize),2,0.25)  #sample column effect from N(0,0.05)
mu&lt;-0.01 #constant value signal
 for ( i in 1 : rowSize){
 	for(j in 1: (colSize)){
 		xmat[i,j] &lt;- xmat[i,j] + mu + a1[i] + b1[j] 	
 	}
 }
 #--obtain a bicluster by running an algorithm---# 
plaidmab &lt;- biclust(x=xmat, method=BCPlaid(), cluster="b", fit.model = y ~ m + a+ b,  
background = TRUE, row.release = 0.6, col.release = 0.7, shuffle = 50, back.fit = 5, 
max.layers = 1, iter.startup = 100, iter.layer = 100, verbose = TRUE)

#Get Chia and Karuturi scores:
ChiaKaruturi(x=xmat, bicResult = plaidmab, number = 1)
</code></pre>

<hr>
<h2 id='coherence'>Coherence measures</h2><span id='topic+coherence'></span><span id='topic+constantVariance'></span><span id='topic+additiveVariance'></span><span id='topic+multiplicativeVariance'></span><span id='topic+signVariance'></span>

<h3>Description</h3>

<p> Different preliminary measures of how much constant or
(additive, multiplicative, sign) coherent a bicluster is, following
Madeira and Oliveira classification of biclusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constantVariance(x, resultSet, number, dimension="both")
additiveVariance(x, resultSet, number, dimension="both")
multiplicativeVariance(x, resultSet, number, dimension="both")
signVariance(x, resultSet, number, dimension="both")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coherence_+3A_x">x</code></td>
<td>
<p>The data matrix from which biclusters were identified</p>
</td></tr>
<tr><td><code id="coherence_+3A_resultset">resultSet</code></td>
<td>
<p>BiclustResult object with a bicluster result set where is the bicluster to measure</p>
</td></tr>
<tr><td><code id="coherence_+3A_number">number</code></td>
<td>
<p>Number of the bicluster withing the result set</p>
</td></tr>
<tr><td><code id="coherence_+3A_dimension">dimension</code></td>
<td>
<p>&quot;both&quot; for determining overall variance, &quot;row&quot; for gene variance and &quot;col&quot; for column variance. Default &quot;both&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns the corresponding variance of genes or conditions as the average of the sum of euclidean
distances between all rows and/or columns of the bicluster.
For additive, multiplicative and sign variance first a transformation of the
bicluster is done, so variance is computed on a matrix that reflects difference,
rest or change of sign between rows, columns or both.
</p>
<p>The lower the value returned, the more constant or coherent the bicluster is.
If the value returned is 0, the bicluster is ideally constant or coherent.
Usually, a value above 1-1.5 is enough to determine the bicluster is not
constant or coherent.
</p>


<h3>Note</h3>

<p>There are preliminary measures for coherence. Since transformations are
different, measures are not normalized and comparison between, for example,
additive and multiplicative variance is not meaningful. Only comparisons between
different measures of the same kind of variance are reliable by now.</p>


<h3>Author(s)</h3>

<p>Rodrigo Santamaria
<a href="mailto:rodri@usal.es">rodri@usal.es</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #Simplified yeast microarray data
  data(BicatYeast)
  set.seed(1)
  bics1 &lt;- biclust(BicatYeast,BCPlaid(), back.fit = 2, shuffle = 3, fit.model = ~m + a + b,
  row.release = 0.7, col.release = 0.7,
  verbose = FALSE, max.layers = 10, iter.startup = 5,
  iter.layer = 30)
  
  constantVariance(BicatYeast, bics1,1,"row")
  constantVariance(BicatYeast, bics1,1,"col")
  constantVariance(BicatYeast, bics1,1,"both")
  additiveVariance(BicatYeast, bics1,1,"both")
  multiplicativeVariance(BicatYeast, bics1,1,"both")
  signVariance(BicatYeast, bics1,1,"both")
  </code></pre>

<hr>
<h2 id='computeObservedFstat'>
Diagnostic F Statistic Calculation
</h2><span id='topic+computeObservedFstat'></span>

<h3>Description</h3>

<p>Functions for obtaining F statistics within bicluster and the significance levels. The main effects considered are row, column and interaction effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeObservedFstat(x, bicResult, number)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computeObservedFstat_+3A_x">x</code></td>
<td>

<p>Data Matrix
</p>
</td></tr>
<tr><td><code id="computeObservedFstat_+3A_bicresult">bicResult</code></td>
<td>

<p><code>Biclust</code> object from <code>biclust</code> package
</p>
</td></tr>
<tr><td><code id="computeObservedFstat_+3A_number">number</code></td>
<td>

<p>Number of bicluster in the output for computing observed statistics 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>F-statistics are calculated from the two-way ANOVA mode with row anc column effect. The full model with interaction is unidentifiable, thus, Tukey's test for non-additivity is used to detect an  interaction within a bicluster. 
p-values are obtained from assymptotic F distributions.
</p>


<h3>Value</h3>

<p>Data frame with three rows (&quot;Row Effect&quot;, &quot;Column Effect&quot;, &quot;Tukey test&quot;) and 2 columns for corresponding statistics (Fstat) and their p-values (PValue).
2
</p>


<h3>Author(s)</h3>

<p>Tatsiana KHAMIAKOVA <a href="mailto:tatsiana.khamiakova@uhasselt.be">tatsiana.khamiakova@uhasselt.be</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diagnosticTest">diagnosticTest</a></code>, <code><a href="#topic+diagnosticPlot2">diagnosticPlot2</a></code>, <code><a href="#topic+ChiaKaruturi">ChiaKaruturi</a></code>, <code><a href="#topic+diagnoseColRow">diagnoseColRow</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#---simulate dataset with 1 bicluster ---#
xmat&lt;-matrix(rnorm(50*50,0,0.25),50,50) # background noise only 
rowSize &lt;- 20 #number of rows in a bicluster 
colSize &lt;- 10 #number of columns in a bicluster
a1&lt;-rnorm(rowSize,1,0.1) #sample row effect from N(0,0.1) #adding a coherent values bicluster:
b1&lt;-rnorm((colSize),2,0.25)  #sample column effect from N(0,0.05)
mu&lt;-0.01 #constant value signal
 for ( i in 1 : rowSize){
 	for(j in 1: (colSize)){
 		xmat[i,j] &lt;- xmat[i,j] + mu + a1[i] + b1[j] 	
 	}
 }
 #--obtain a bicluster by running an algorithm---# 
plaidmab &lt;- biclust(x=xmat, method=BCPlaid(), cluster="b", fit.model = y ~ m + a+ b,  
background = TRUE, row.release = 0.6, col.release = 0.7, shuffle = 50, back.fit = 5, 
max.layers = 1, iter.startup = 100, iter.layer = 100, verbose = TRUE)

#Calculate statistics and their p-values to infer about the structure within bicluster:
Structure &lt;- computeObservedFstat(x=xmat, bicResult = plaidmab, number = 1)

</code></pre>

<hr>
<h2 id='diagnoseColRow'>
Bootstrap Procedure for Bicluster Diagnostics
</h2><span id='topic+diagnoseColRow'></span>

<h3>Description</h3>

<p>Calculate the significance of the discovered patter in the data based on the bootstrapping procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagnoseColRow(x, bicResult, number, nResamplings, replace = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diagnoseColRow_+3A_x">x</code></td>
<td>

<p>data matrix, which <code>biclust</code> function was applied to
</p>
</td></tr>
<tr><td><code id="diagnoseColRow_+3A_bicresult">bicResult</code></td>
<td>

<p>object of class <code>biclust</code>, containing result of a biclustering algorithm
</p>
</td></tr>
<tr><td><code id="diagnoseColRow_+3A_number">number</code></td>
<td>

<p>number of bicluster from the output for the diagnostics
</p>
</td></tr>
<tr><td><code id="diagnoseColRow_+3A_nresamplings">nResamplings</code></td>
<td>

<p>number of bootstrap replicates
</p>
</td></tr>
<tr><td><code id="diagnoseColRow_+3A_replace">replace</code></td>
<td>

<p>logical flag for bootstrap (TRUE), or sampling without replacement (FALSE)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes observed F statistics for row and column effect based on two-way ANOVA model. Bootstrap procedure is used to evaluate the significance of discovered bicluster.
Based on <code>nResamplings</code> replicates, the disribution of F statistics for row and column effects are obtained. The p-value is computed as
</p>
<p style="text-align: center;"><code class="reqn">
  P(A) =
  \frac{ \# \left \{ F^{*}(A)_{b} &gt; F(A)^{obs} \right \} }
  {nResamplings+1}
</code>
</p>

<p>Low p-values denote non-random selection of columns for a given bicluster. Large p-values show that in other columns for a given set of genes in the bicluster structure is similar. 
Hence, bicluster columns were just randomly picked by an algorithm for a set of co-regulated genes.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>bootstrapFstats</code></td>
<td>

<p>matrix with two columns, containing values of bootstrap F-statistics. The first column corresponds to row, the second column corresponds to column.
</p>
</td></tr>
<tr><td><code>observedFstatRow</code></td>
<td>

<p>observed F-statistics for the row effect
</p>
</td></tr> 
<tr><td><code>observedFstatCol</code></td>
<td>

<p>observed F-statistics for the column effect
</p>
</td></tr>
<tr><td><code>bootstrapPvalueRow</code></td>
<td>

<p>bootstrap p value for row effect
</p>
</td></tr>
<tr><td><code>bootstrapPvalueCol</code></td>
<td>

<p>bootstrap p value for column effect
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Tatsiana KHAMIAKOVA <a href="mailto:tatsiana.khamiakova@uhasselt.be">tatsiana.khamiakova@uhasselt.be</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diagnosticTest">diagnosticTest</a></code>, <code><a href="#topic+diagnosticPlot2">diagnosticPlot2</a></code>, <code><a href="#topic+diagnosticPlot">diagnosticPlot</a></code>, <code><a href="#topic+computeObservedFstat">computeObservedFstat</a></code>, <code><a href="#topic+ChiaKaruturi">ChiaKaruturi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#---simulate dataset with 1 bicluster ---#
xmat&lt;-matrix(rnorm(50*50,0,0.25),50,50) # background noise only 
rowSize &lt;- 20 #number of rows in a bicluster 
colSize &lt;- 10 #number of columns in a bicluster
a1&lt;-rnorm(rowSize,1,0.1) #sample row effect from N(0,0.1) #adding a coherent values bicluster:
b1&lt;-rnorm((colSize),2,0.25)  #sample column effect from N(0,0.05)
mu&lt;-0.01 #constant value signal
 for ( i in 1 : rowSize){
 	for(j in 1: (colSize)){
 		xmat[i,j] &lt;- xmat[i,j] + mu + a1[i] + b1[j] 	
 	}
 }
 #--obtain a bicluster by running an algorithm---# 
plaidmab &lt;- biclust(x=xmat, method=BCPlaid(), cluster="b", fit.model = y ~ m + a+ b,  
background = TRUE, row.release = 0.6, col.release = 0.7, shuffle = 50, back.fit = 5, 
max.layers = 1, iter.startup = 100, iter.layer = 100, verbose = TRUE)

#Run boosotrap procedure:
Bootstrap &lt;- diagnoseColRow(x=xmat, bicResult = plaidmab, number = 1, nResamplings = 999,
  replace = TRUE)
diagnosticPlot(bootstrapOutput = Bootstrap) 	# plotting distribution of bootstrap replicates

</code></pre>

<hr>
<h2 id='diagnosticPlot'>
Diagnostic F Statistics Visualization
</h2><span id='topic+diagnosticPlot'></span>

<h3>Description</h3>

<p>Plots distributions of bootstrap replicates of F-statistics for row and column effect and highlights the observed statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagnosticPlot(bootstrapOutput)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diagnosticPlot_+3A_bootstrapoutput">bootstrapOutput</code></td>
<td>

<p>output of <code><a href="#topic+diagnoseColRow">diagnoseColRow</a></code> function, containing bootstrap replicates and observed F-statistics
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned. The plot is constructed in a current device.
</p>


<h3>Author(s)</h3>

<p>Tatsiana KHAMIAKOVA <a href="mailto:tatsiana.khamiakova@uhasselt.be">tatsiana.khamiakova@uhasselt.be</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diagnoseColRow">diagnoseColRow</a></code>, <code><a href="#topic+computeObservedFstat">computeObservedFstat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#---simulate dataset with 1 bicluster ---#
xmat&lt;-matrix(rnorm(50*50,0,0.25),50,50) # background noise only 
rowSize &lt;- 20 #number of rows in a bicluster 
colSize &lt;- 10 #number of columns in a bicluster
a1&lt;-rnorm(rowSize,1,0.1) #sample row effect from N(0,0.1) #adding a coherent values bicluster:
b1&lt;-rnorm((colSize),2,0.25)  #sample column effect from N(0,0.05)
mu&lt;-0.01 #constant value signal
 for ( i in 1 : rowSize){
 	for(j in 1: (colSize)){
 		xmat[i,j] &lt;- xmat[i,j] + mu + a1[i] + b1[j] 	
 	}
 }
 #--obtain a bicluster by running an algorithm---# 
plaidmab &lt;- biclust(x=xmat, method=BCPlaid(), cluster="b", fit.model = y ~ m + a+ b,  
background = TRUE, row.release = 0.6, col.release = 0.7, shuffle = 50, back.fit = 5, 
max.layers = 1, iter.startup = 100, iter.layer = 100, verbose = TRUE)

#Run bootsrap procedure:
Bootstrap &lt;- diagnoseColRow(x=xmat, bicResult = plaidmab, number = 1, 
  nResamplings = 999, replace = TRUE)

# plotting distribution of bootstrap replicates
diagnosticPlot(bootstrapOutput = Bootstrap) 	

</code></pre>

<hr>
<h2 id='diagnosticPlot2'>Diagnostics F Statistiics Visualization</h2><span id='topic+diagnosticPlot2'></span>

<h3>Description</h3>

<p>Plots distributions of bootstrap replicates of F-statistics for row, column and multiplicative effects obtained from <code><a href="#topic+diagnosticTest">diagnosticTest</a></code> (when <code>save_F=TRUE</code>). 
Contains an option to highlight the observed statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagnosticPlot2(diagnosticTest, number = 1, StatVal = TRUE,
  binwidth = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diagnosticPlot2_+3A_diagnostictest">diagnosticTest</code></td>
<td>
<p>output of <code><a href="#topic+diagnosticTest">diagnosticTest</a></code> with <code>save_F=TRUE</code> which contains the F-statistics and sampling replicates.</p>
</td></tr>
<tr><td><code id="diagnosticPlot2_+3A_number">number</code></td>
<td>
<p>Number of which BC to plot. This needs to be one of the Biclusters requested in in <code><a href="#topic+diagnosticTest">diagnosticTest</a></code>.</p>
</td></tr>
<tr><td><code id="diagnosticPlot2_+3A_statval">StatVal</code></td>
<td>
<p>Boolean value to draw the observed statistic on the distribution plots.</p>
</td></tr>
<tr><td><code id="diagnosticPlot2_+3A_binwidth">binwidth</code></td>
<td>
<p>The width of the bins.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>ggplot</code> object.
</p>


<h3>Author(s)</h3>

<p>Ewoud De Troyer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


## Not run: 
#Random matrix with embedded bicluster (with multiplicative effect)
test &lt;- matrix(rnorm(5000),100,50)
roweff &lt;- sample(1:5,10,replace=TRUE)
coleff &lt;- sample(1:5,10,replace=TRUE)
test[11:20,11:20] &lt;- test[11:20,11:20] +
  matrix(coleff,nrow=10,ncol=10,byrow=TRUE) +
  matrix(roweff,nrow=10,ncol=10) +
  roweff %*% t(coleff)


#Apply Plaid Biclustering
res &lt;- biclust(test, method=BCPlaid())

#Apply default diagnosticTest
out &lt;- diagnosticTest(BCresult=res, data=test, save_F=TRUE, number=1,
                      statistics=c("F","Tukey","ModTukey","Tusell","Mandel","LBI","JandG"),
                      samplingtypes=c("Permutation","SemiparPerm","SemiparBoot",
                      "PermutationCor","SamplingCor","NormSim"))

#Plot Distributions
diagnosticPlot2(out,number=1)

## End(Not run)

</code></pre>

<hr>
<h2 id='diagnosticTest'>Testing Procedure for Bicluster Diagnostics</h2><span id='topic+diagnosticTest'></span>

<h3>Description</h3>

<p>Calculate the statistical value of the row, column and multiplicative effect based on discovered biclusters in the data. 
Additionally multiple sampling methods are available to compute the statistical significance through p-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagnosticTest(BCresult, data, number = 1:BCresult@Number, verbose = TRUE,
  statistics = c("F", "Tukey"), sampling = TRUE, samplingtypes = NULL,
  nSim = 1000, alpha = 0.05, save_F = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="diagnosticTest_+3A_bcresult">BCresult</code></td>
<td>
<p>An object of class <code>biclust</code> containing the result of a biclustering algorithm</p>
</td></tr>
<tr><td><code id="diagnosticTest_+3A_data">data</code></td>
<td>
<p>data matrix, which <code>biclust</code> function was applied to</p>
</td></tr>
<tr><td><code id="diagnosticTest_+3A_number">number</code></td>
<td>
<p>Vector of bicluster numbers of which the diagnostics should be calculated. (default = all available biclusters)</p>
</td></tr>
<tr><td><code id="diagnosticTest_+3A_verbose">verbose</code></td>
<td>
<p>Boolean value to print progression of computed statistics.</p>
</td></tr>
<tr><td><code id="diagnosticTest_+3A_statistics">statistics</code></td>
<td>
<p>Vector select which statistics to compute. (default = <code>c("F","Tukey")</code>)
</p>

<ul>
<li> <p><code>"F"</code> (Row and column F statistics of two-way ANOVA with one replicate for cell)
</p>
</li>
<li> <p><code>"Tukey"</code> (Tukey's test for non-additivity)
</p>
</li>
<li> <p><code>"ModTukey"</code> (<code><a href="additivityTests.html#topic+mtukey.test">mtukey.test</a></code>)
</p>
</li>
<li> <p><code>"Tusell"</code> (<code><a href="additivityTests.html#topic+tusell.test">tusell.test</a></code>)
</p>
</li>
<li> <p><code>"Mandel"</code> (<code><a href="additivityTests.html#topic+mandel.test">mandel.test</a></code>)
</p>
</li>
<li> <p><code>"LBI"</code> (<code><a href="additivityTests.html#topic+lbi.test">lbi.test</a></code>)
</p>
</li>
<li> <p><code>"JandG"</code> (<code><a href="additivityTests.html#topic+johnson.graybill.test">johnson.graybill.test</a></code>)
</p>
</li></ul>
</td></tr>
<tr><td><code id="diagnosticTest_+3A_sampling">sampling</code></td>
<td>
<p>Boolean value to apply sampling methods to compute statistical significance (default=<code>TRUE</code>). 
If <code>FALSE</code> only the <code>"Theoretical"</code> p-values are computed. 
If <code>TRUE</code>, both the <code>"Theoretical"</code> and <code>samplingtypes</code> p-values are computed.</p>
</td></tr>
<tr><td><code id="diagnosticTest_+3A_samplingtypes">samplingtypes</code></td>
<td>
<p>Vector of sampling methods for <code>sampling=TRUE</code>. (default=<code>NULL</code>=<code>c("Permutation","SemiparPerm")</code>)
</p>

<ul>
<li> <p><code>"Permutation"</code> 
</p>
</li>
<li> <p><code>"SemiparPerm"</code> 
</p>
</li>
<li> <p><code>"SemiparBoot"</code> 
</p>
</li>
<li> <p><code>"PermutationCor"</code> 
</p>
</li>
<li> <p><code>"SamplingCor"</code>
</p>
</li>
<li> <p><code>"NormSim"</code>  
</p>
</li></ul>

<p>See Details for more info.</p>
</td></tr>
<tr><td><code id="diagnosticTest_+3A_nsim">nSim</code></td>
<td>
<p>Number of permutations/bootstraps.</p>
</td></tr>
<tr><td><code id="diagnosticTest_+3A_alpha">alpha</code></td>
<td>
<p>Significance level (default=0.05)</p>
</td></tr>
<tr><td><code id="diagnosticTest_+3A_save_f">save_F</code></td>
<td>
<p>Option to save the permuted/bootstraped statistics. This is necessary for <code><a href="#topic+diagnosticPlot2">diagnosticPlot2</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Due to the uncertainty of discovering the true bicluster(s) in the data, it's often advisable to not rely on the theoretical p-values but instead retrieve the p-values through a sampling procedure.
</p>
<p>Available p-values/sampling types for each statistical method:
</p>

<ul>
<li> <p><code>"F"</code>: <code>"Theoretical"</code> and <code>"Permutation"</code> for both row and column effect.
</p>
</li>
<li> <p><code>"Tukey"</code>: <code>"Theoretical"</code>, <code>"SemiparPerm"</code> and <code>"SemiparBoot"</code>.
</p>
</li>
<li> <p><code>"ModTukey"</code>: <code>"Theoretical"</code>, <code>"SemiparPerm"</code>, <code>"SemiparBoot"</code>, <code>"PermutationCor"</code> and <code>"SamplingCor"</code>.
</p>
</li>
<li> <p><code>"Tusell"</code>: <code>"SemiparPerm"</code>, <code>"SemiparBoot"</code> and <code>"NormSim"</code>.
</p>
</li>
<li> <p><code>"Mandel"</code>: <code>"Theoretical"</code>, <code>"SemiparPerm"</code> and <code>"SemiparBoot"</code>.
</p>
</li>
<li> <p><code>"LBI"</code>: <code>"SemiparPerm"</code>, <code>"SemiparBoot"</code> and <code>"NormSim"</code>.
</p>
</li>
<li> <p><code>"JandG"</code>: <code>"SemiparPerm"</code>, <code>"SemiparBoot"</code> and <code>"NormSim"</code>.
</p>
</li></ul>
 
<p>More info on the sampling types can be found in the secion below.
If available, the <code>"Theoretical"</code> will always be computed.
By default when <code>sampling=TRUE</code>, a sampling method without replacement is chosen, namely <code>"Permutation"</code> and <code>"SemiparPerm"</code>.
</p>
<p>When <code>save_F=TRUE</code>, the null distributions of the statistics can be visualised with <code><a href="#topic+diagnosticPlot2">diagnosticPlot2</a></code>.
</p>
<p><em>Disclaimer:</em> While their functionality did not change, some functions of the <code>additivityTests</code> package were altered in order to be able to return the permuted/bootstrapped statistics and p-values.
</p>


<h3>Value</h3>

<p>Returns a list with <code>length(number)</code> elements. 
Each element corresponds with the requested biclusters and is a list containing:
</p>

<ul>
<li> <p><code>table</code>: a data frame where each row is <code>statistics</code> and <code>samplingtypes</code> (including Theoretical) combination. The data frame contains the <code>Method</code>, <code>Type</code> (p-value type), <code>StatVal</code> (statistical value), <code>CritVal</code> (critical value), <code>pVal</code> and <code>Sign</code> (0/1 significance indicator based on <code>alpha</code>).
</p>
</li>
<li> <p><code>save_F</code>: if <code>save_F=TRUE</code>, a (<code>nSim</code> x number of permuted/bootstrapped p-values) matrix contained the sampled statistics.
</p>
</li></ul>



<h3>Sampling Types</h3>

<p>For each sampling type a permuted/bootstrapped BC is created as following:
</p>

<ul>
<li> <p><code>"Permutation"</code>: Sample a BC from the entire dataset with replacement.
</p>
</li>
<li> <p><code>"SemiparPerm"</code>: A semi-parametric permutation procedure. Two-way ANOVA is applied on the original BC and the residual matrix extracted. A new residual matrix is created by sampling <em>without replacement</em> from the original residual matrix. The sampled BC is then generated by adding this sampled residual matrix on top the mean, row and column effect of the ANOVA procedure of the original BC.
</p>
</li>
<li> <p><code>"SemiparBoot"</code>: A semi-parametric bootstrapping procedure. Two-way ANOVA is applied on the original BC and the residual matrix extracted. A new residual matrix is created by sampling <em>with replacement</em> from the original residual matrix. The sampled BC is then generated by adding this sampled residual matrix on top the mean, row and column effect of the ANOVA procedure of the original BC.
</p>
</li>
<li> <p><code>"PermutationCor"</code>: See <code>correction=1</code> parameter of <code><a href="additivityTests.html#topic+mtukey.test">mtukey.test</a></code>. More info in Simecek and Simeckova (2012).
</p>
</li>
<li> <p><code>"SamplingCor"</code>: See <code>correction=2</code> parameter of <code><a href="additivityTests.html#topic+mtukey.test">mtukey.test</a></code>. More info in Simecek and Simeckova (2012).
</p>
</li>
<li> <p><code>"NormSim"</code>: Sample a BC from a standard normal distribution. This sampling procedure is used for some methods in the <code>additivityTests</code> package.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Ewoud De Troyer
</p>


<h3>References</h3>

<p>Tukey, J.W.: One Degree of Freedom for Non-additivity, <em>Biometrics</em> <strong>5</strong>, pp. 232-242, 1949.
</p>
<p>Simecek, Petr, and Simeckova, Marie. &quot;Modification of Tukey's additivity test.&quot; <em>Journal of Statistical Planning and Inference</em>, <strong>2012</strong>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 
#Random matrix with embedded bicluster (with multiplicative effect)
test &lt;- matrix(rnorm(5000),100,50)
roweff &lt;- sample(1:5,10,replace=TRUE)
coleff &lt;- sample(1:5,10,replace=TRUE)
test[11:20,11:20] &lt;- test[11:20,11:20] +
  matrix(coleff,nrow=10,ncol=10,byrow=TRUE) +
  matrix(roweff,nrow=10,ncol=10) +
  roweff %*% t(coleff)


#Apply Plaid Biclustering
res &lt;- biclust(test, method=BCPlaid())

#Apply default diagnosticTest
out &lt;- diagnosticTest(BCresult=res, data=test, save_F=TRUE, number=1,
                      statistics=c("F","Tukey","ModTukey","Tusell","Mandel","LBI","JandG"),
                      samplingtypes=c("Permutation","SemiparPerm","SemiparBoot",
                      "PermutationCor","SamplingCor","NormSim"))

out[[1]]$table

## End(Not run)

</code></pre>

<hr>
<h2 id='discretize'>Create a discret matrix</h2><span id='topic+discretize'></span>

<h3>Description</h3>

<p> Some biclusteralgorithms need a discret matrix to perform well.
This function delivers a discret matrix with either a given number of levels of equally spaced intervals from minimum to maximum, or levels of same size using the quantiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discretize(x,nof=10,quant=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="discretize_+3A_x">x</code></td>
<td>
<p>The data matrix from which should be dicretized</p>
</td></tr>
<tr><td><code id="discretize_+3A_nof">nof</code></td>
<td>
<p>Number of levels</p>
</td></tr>
<tr><td><code id="discretize_+3A_quant">quant</code></td>
<td>
<p>If TRUE using the quantiles, else using equally spaced levels</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sebastian Kaiser
<a href="mailto:sebastian.kaiser@stat.uni-muenchen.de">sebastian.kaiser@stat.uni-muenchen.de</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #Discretize yeast microarray data
  data(BicatYeast)
  discretize(BicatYeast[1:10,1:10])

  </code></pre>

<hr>
<h2 id='drawHeatmap'>Draw Heatmap</h2><span id='topic+drawHeatmap'></span><span id='topic+drawHeatmap2'></span><span id='topic+heatmap'></span>

<h3>Description</h3>

<p> Draws a microarray data matrix as a heatmap, with rows and colums
reordered so the rows and columns of the input bicluster will be at top-left
of the matrix.</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawHeatmap(x,bicResult=NULL,number=NA,local=TRUE, beamercolor=FALSE,paleta,...)
drawHeatmap2(x,bicResult=NULL,number=NA,plotAll=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drawHeatmap_+3A_x">x</code></td>
<td>
<p>The data matrix where the bicluster is to be drawn.</p>
</td></tr>
<tr><td><code id="drawHeatmap_+3A_bicresult">bicResult</code></td>
<td>
<p>BiclustResult object with a bicluster result set. If this value
is set to NULL, the data matrix is drawn as a heatmap, without any reordering. Default NULL.</p>
</td></tr>
<tr><td><code id="drawHeatmap_+3A_number">number</code></td>
<td>
<p>Bicluster to be drawn from the result set 'bicResult'. If bicResult is set to
NULL, this value is ignored. Default NA</p>
</td></tr>
<tr><td><code id="drawHeatmap_+3A_local">local</code></td>
<td>
<p>If TRUE, only rows and columns of the bicluster were drawn.</p>
</td></tr>
<tr><td><code id="drawHeatmap_+3A_plotall">plotAll</code></td>
<td>
<p>If TRUE, all Bicluster of result set 'bicResult' were drawn.</p>
</td></tr>
<tr><td><code id="drawHeatmap_+3A_beamercolor">beamercolor</code></td>
<td>
<p>If TRUE, palete colors are used.</p>
</td></tr>
<tr><td><code id="drawHeatmap_+3A_paleta">paleta</code></td>
<td>
<p>Colors</p>
</td></tr>
<tr><td><code id="drawHeatmap_+3A_...">...</code></td>
<td>
<p>Additional plot options</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'plotAll' only works if there is a exclusive rows and column Result!</p>


<h3>Author(s)</h3>

<p>Rodrigo Santamaria <a href="mailto:rodri@usal.es">rodri@usal.es</a>,
Sebastian Kaiser
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bubbleplot">bubbleplot</a></code> for simultaneous representation of biclusters.\
<code><a href="#topic+parallelCoordinates">parallelCoordinates</a></code>for single representation of biclusters as lines of gene or condition profiles.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #Random 100x50 matrix with a single, up-regulated 10x10 bicluster
  s2=matrix(rnorm(5000),100,50)
  s2[11:20,11:20]=rnorm(100,3,0.3)
  set.seed(1)
  bics &lt;- biclust(s2,BCPlaid(), back.fit = 2, shuffle = 3, fit.model = ~m + a + b,
  iter.startup = 5, iter.layer = 30,  verbose = TRUE)
  drawHeatmap(s2,bics,1)

</code></pre>

<hr>
<h2 id='EisenYeast'>Eisen Yeast</h2><span id='topic+EisenYeast'></span><span id='topic+yeast+20microarray+20data+20matrix'></span><span id='topic+Saccharomices+20Cerevisiae+20data+20matrix'></span>

<h3>Description</h3>

<p>Microarray data matrix for 80 experiments with Saccharomyces Cerevisiae organism
by Eisen Lab.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data(EisenYeast)
  </code></pre>


<h3>Format</h3>

<p>Data frame with information about the expression levels of 6221 genes over 80 conditions.
Missing values have been imputed using k-nearest neighbor averaging implemented in
impute.knn() from library 'impute' (using default k=10).
Gene names follow ORF (Open Reading Format) notation.
</p>


<h3>Source</h3>

<p>Eisen Lab at http://rana.lbl.gov/EisenData.htm</p>

<hr>
<h2 id='ensemble'>
Ensemble Methods for Bicluster Algorithms
</h2><span id='topic+ensemble'></span>

<h3>Description</h3>

<p>Calculates an ensemble of biclusters from different parameter setting of
possible different bicluster algorithms. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ensemble(x, confs, rep = 1, maxNum = 5, similar = jaccard2, thr = 0.8, simthr =0.7,
  subs = c(1, 1), bootstrap = FALSE, support = 0, combine=firstcome, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ensemble_+3A_x">x</code></td>
<td>

<p>Data Matrix</p>
</td></tr>
<tr><td><code id="ensemble_+3A_confs">confs</code></td>
<td>

<p>Matrix containing parameter sets
</p>
</td></tr>
<tr><td><code id="ensemble_+3A_rep">rep</code></td>
<td>

<p>Number of repetitions for each parameter set
</p>
</td></tr>
<tr><td><code id="ensemble_+3A_maxnum">maxNum</code></td>
<td>

<p>Maximum number of biclusters taken from each run
</p>
</td></tr>
<tr><td><code id="ensemble_+3A_similar">similar</code></td>
<td>

<p>Function to produce a similarity matrix of bicluster
</p>
</td></tr>
<tr><td><code id="ensemble_+3A_thr">thr</code></td>
<td>

<p>Threshold for similarity
</p>
</td></tr>
<tr><td><code id="ensemble_+3A_simthr">simthr</code></td>
<td>

<p>Proportion of row column combinations in bicluster
</p>
</td></tr>
<tr><td><code id="ensemble_+3A_subs">subs</code></td>
<td>

<p>Vector of proportion of rows and columns for subsampling. Default c(1,1)
means no subsampling.
</p>
</td></tr>
<tr><td><code id="ensemble_+3A_bootstrap">bootstrap</code></td>
<td>

<p>Should bootstrap sampling be used (logical: replace=bootstrap).
</p>
</td></tr>
<tr><td><code id="ensemble_+3A_support">support</code></td>
<td>

<p>Which proportion of the runs must contain the bicluster to have enough support to report it (between 0 and 1).
</p>
</td></tr>
<tr><td><code id="ensemble_+3A_combine">combine</code></td>
<td>

<p>Function to combine the single bicluster only firstcome and hcl for hierarchical clustering are possible at the moment.
</p>
</td></tr>
<tr><td><code id="ensemble_+3A_...">...</code></td>
<td>

<p>Arguments past to the combine function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two different kinds (or both combined) of ensembling is
possible. Ensemble of repeated runs or ensemble of runs on subsamples. 
</p>


<h3>Value</h3>

<p>Return an object of class Biclust
</p>


<h3>Author(s)</h3>

<p>Sebastian Kaiser 
<a href="mailto:sebastian.kaiser@stat.uni-muenchen.de">sebastian.kaiser@stat.uni-muenchen.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Biclust-class">Biclust-class</a></code>, <code><a href="#topic+plaid.grid">plaid.grid</a></code>,  <code><a href="#topic+bimax.grid">bimax.grid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(BicatYeast)
ensemble.plaid &lt;- ensemble(BicatYeast,plaid.grid()[1:5],rep=1,maxNum=2, thr=0.5, subs = c(1,1))
ensemble.plaid
x &lt;- binarize(BicatYeast)
ensemble.bimax &lt;- ensemble(x,bimax.grid(),rep=10,maxNum=2,thr=0.5, subs = c(0.8,0.8))
ensemble.bimax

## End(Not run)
</code></pre>

<hr>
<h2 id='heatmapBC'>Overlapping Heatmap</h2><span id='topic+heatmapBC'></span>

<h3>Description</h3>

<p>Other than <code><a href="#topic+drawHeatmap">drawHeatmap</a></code> this function plots all or a chosen number of bicluster in one plot even if they were overlapping.</p>


<h3>Usage</h3>

<pre><code class='language-R'>heatmapBC(x, bicResult, number = 0, local = TRUE, order = FALSE, 
          outside = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="heatmapBC_+3A_x">x</code></td>
<td>
<p>The data matrix where the bicluster is to be drawn.</p>
</td></tr>
<tr><td><code id="heatmapBC_+3A_bicresult">bicResult</code></td>
<td>
<p>BiclustResult object with a bicluster result set.</p>
</td></tr>
<tr><td><code id="heatmapBC_+3A_number">number</code></td>
<td>
<p> Number of bicluster to be drawn from the result set
'bicResult'. If the default 0 is chosen all bicluster of the
bicResult are drawn.</p>
</td></tr>
<tr><td><code id="heatmapBC_+3A_local">local</code></td>
<td>
<p>If <code>TRUE</code>, only rows and columns of the bicluster are drawn. This argument is only used if number is not set to 0.</p>
</td></tr>
<tr><td><code id="heatmapBC_+3A_order">order</code></td>
<td>
<p>If <code>TRUE</code>, rows and
columns are ordered by their values.</p>
</td></tr>
<tr><td><code id="heatmapBC_+3A_outside">outside</code></td>
<td>
<p>If <code>TRUE</code>, Boxes are drawn for overlapping</p>
</td></tr>
<tr><td><code id="heatmapBC_+3A_...">...</code></td>
<td>
<p>Additional plot options</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Overlap plotting only works for two neighbor bicluster defined
by the order in the number slot.</p>


<h3>Author(s)</h3>

<p>Sebastian Kaiser
</p>


<h3>See Also</h3>

<p><code><a href="#topic+drawHeatmap">drawHeatmap</a></code>,<code><a href="#topic+parallelCoordinates">parallelCoordinates</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  set.seed(1234)
  data(BicatYeast)
  resplaid &lt;- biclust(BicatYeast, BCPlaid(), verbose = FALSE)
  heatmapBC(x = BicatYeast, bicResult = resplaid)

</code></pre>

<hr>
<h2 id='isoverlapp'>Is Bicresult overlapping?</h2><span id='topic+isoverlapp'></span>

<h3>Description</h3>

<p>Checks if Biclusterresult includes overlapping rows or columns</p>


<h3>Usage</h3>

<pre><code class='language-R'>isoverlapp(bicResult)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isoverlapp_+3A_bicresult">bicResult</code></td>
<td>
<p>Result of biclust function</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Overlapping</code></td>
<td>
<p>Is there overlapping</p>
</td></tr>
<tr><td><code>Max.bicluster.Rows</code></td>
<td>
<p>Maximal number of bicluster a single row is in</p>
</td></tr>
<tr><td><code>Max.bicluster.Cols</code></td>
<td>
<p>Maximal number of bicluster a single col is in</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sebastian Kaiser 
<a href="mailto:sebastian.kaiser@stat.uni-muenchen.de">sebastian.kaiser@stat.uni-muenchen.de</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+drawHeatmap">drawHeatmap</a></code></p>

<hr>
<h2 id='jaccardind'>Jaccardind</h2><span id='topic+jaccardind'></span><span id='topic+jaccard2'></span>

<h3>Description</h3>

<p> An adaption of the Jaccard Index for clustering is calculated.</p>


<h3>Usage</h3>

<pre><code class='language-R'>jaccardind(bicres1,bicres2)
jaccard2(Rows, Cols)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jaccardind_+3A_bicres1">bicres1</code></td>
<td>
<p>A object of class Biclust</p>
</td></tr>
<tr><td><code id="jaccardind_+3A_bicres2">bicres2</code></td>
<td>
<p>A object of class Biclust</p>
</td></tr>
<tr><td><code id="jaccardind_+3A_rows">Rows</code></td>
<td>
<p>Matrix containing rows of biclusters</p>
</td></tr>
<tr><td><code id="jaccardind_+3A_cols">Cols</code></td>
<td>
<p>Matrix containing cols of biclusters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calculates the percentage of datapoints in the same bicluster structure from all datapoints at least included in one bicluster.
</p>


<h3>Value</h3>

<p><code>jaccardind</code> calculates the Jaccard index
<code>jaccard2</code> returns a similarity matrix containing the Jaccard
index between all biclusters (upper triangle matrix)
</p>


<h3>Author(s)</h3>

<p>Sebastian Kaiser
<a href="mailto:sebastian.kaiser@stat.uni-muenchen.de">sebastian.kaiser@stat.uni-muenchen.de</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(BicatYeast)
res1&lt;-biclust(BicatYeast, method=BCPlaid(), back.fit = 2, shuffle = 3,
  fit.model = ~m + a + b,iter.startup = 5, iter.layer = 30,  verbose = TRUE)
res2&lt;-biclust(BicatYeast, method=BCCC())
jaccardind(res1,res2)


## End(Not run)
</code></pre>

<hr>
<h2 id='parallelCoordinates'>Parallel Coordinates</h2><span id='topic+parallelCoordinates'></span><span id='topic+parallel+20coordinates'></span>

<h3>Description</h3>

<p>Represents expression levels through gene and/or condition profiles in
a bicluster as lines.</p>


<h3>Usage</h3>

<pre><code class='language-R'>parallelCoordinates(x, bicResult, number, plotBoth = FALSE, plotcol = TRUE,
compare = TRUE, info = F, bothlab = c("Rows", "Columns"), order = FALSE,
order2 = 0,ylab = "Value" , col=1,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parallelCoordinates_+3A_x">x</code></td>
<td>
<p>The data matrix of the bicluster to be drawn</p>
</td></tr>
<tr><td><code id="parallelCoordinates_+3A_bicresult">bicResult</code></td>
<td>
<p>BiclustResult object with a bicluster result set</p>
</td></tr>
<tr><td><code id="parallelCoordinates_+3A_number">number</code></td>
<td>
<p>Bicluster to be drawn from the result set 'bicResult'</p>
</td></tr>
<tr><td><code id="parallelCoordinates_+3A_plotboth">plotBoth</code></td>
<td>
<p>If 'TRUE', Parallel Coordinates of rows (Genes) and columns (Conditions) were drawn one below the other.</p>
</td></tr>
<tr><td><code id="parallelCoordinates_+3A_plotcol">plotcol</code></td>
<td>
<p>If 'TRUE', columns profiles are drawn, so each line represents one of the columns in the bicluster. Otherwise, row profiles are drawn. Default 'TRUE'</p>
</td></tr>
<tr><td><code id="parallelCoordinates_+3A_compare">compare</code></td>
<td>
<p>If 'TRUE',  values of the complete data matrix are considered and drawn as shaded lines. Default 'TRUE'</p>
</td></tr>
<tr><td><code id="parallelCoordinates_+3A_info">info</code></td>
<td>
<p>If 'TRUE', a prepared Title is drawn</p>
</td></tr>
<tr><td><code id="parallelCoordinates_+3A_bothlab">bothlab</code></td>
<td>
<p>Names of the x Axis if PlotBoth</p>
</td></tr>
<tr><td><code id="parallelCoordinates_+3A_order">order</code></td>
<td>
<p>Rows and/or Columns are in increasing order.</p>
</td></tr>
<tr><td><code id="parallelCoordinates_+3A_order2">order2</code></td>
<td>
<p>Which ordering.</p>
</td></tr>
<tr><td><code id="parallelCoordinates_+3A_ylab">ylab</code></td>
<td>
<p>ylab</p>
</td></tr>
<tr><td><code id="parallelCoordinates_+3A_col">col</code></td>
<td>
<p>col</p>
</td></tr>
<tr><td><code id="parallelCoordinates_+3A_...">...</code></td>
<td>
<p>Plot Parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rodrigo Santamaria, Martin Sill and Sebastian Kaiser
<a href="mailto:sebastian.kaiser@stat.uni-muenchen.de">sebastian.kaiser@stat.uni-muenchen.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+drawHeatmap">drawHeatmap</a></code> for alternative representation of biclusters and <code><a href="#topic+bubbleplot">bubbleplot</a></code> for simultaneous representation of biclusters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #Random 100x50 matrix with a single, up-regulated 10x10 bicluster
  s2=matrix(rnorm(5000),100,50)
  s2[11:20,11:20]=rnorm(100,3,0.3)
  set.seed(1)
  bics &lt;- biclust(s2,BCPlaid(), back.fit = 2, shuffle = 3, fit.model = ~m + a + b,
  iter.startup = 5, iter.layer = 30,  verbose = TRUE)
  parallelCoordinates(x=s2,bicResult=bics,number=1, plotBoth=TRUE,
plotcol=TRUE, compare=TRUE, info=TRUE,bothlab=c("Genes Bicluster
1","Conditions Bicluster 1"), order =TRUE)
  parallelCoordinates(x=s2,bicResult=bics,number=1, plotBoth=FALSE, plotcol=TRUE, 
    compare=FALSE, info=TRUE)
</code></pre>

<hr>
<h2 id='plaid.grid'>
Parameter Grid for BCPlaid Biclustering
</h2><span id='topic+plaid.grid'></span>

<h3>Description</h3>

<p>Generates a list containing parameter settings for the ensemble algorithm. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plaid.grid(method = "BCPlaid", cluster = "b", fit.model = y ~ m + a + b, 
  background = TRUE, background.layer = NA, background.df = 1, 
  row.release = c(0.5, 0.6, 0.7), col.release = c(0.5, 0.6, 0.7), 
  shuffle = 3, back.fit = 0, max.layers = 20, iter.startup = 5, 
  iter.layer = 10, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plaid.grid_+3A_method">method</code></td>
<td>
<p>Here BCPlaid, to perform Plaid algorithm</p>
</td></tr>
<tr><td><code id="plaid.grid_+3A_cluster">cluster</code></td>
<td>
<p>'r', 'c' or 'b', to cluster rows, columns or both (default 'b')</p>
</td></tr>
<tr><td><code id="plaid.grid_+3A_fit.model">fit.model</code></td>
<td>
<p>Model (formula) to fit each layer. Usually, a linear model is used, that
estimates three parameters: m (constant for all elements in the bicluster),
a(contant for all rows in the bicluster) and b (constant for all columns).
Thus, default is: y ~ m + a + b.</p>
</td></tr>
<tr><td><code id="plaid.grid_+3A_background">background</code></td>
<td>
<p>If 'TRUE' the method will consider that a background layer
(constant for all rows and columns) is present in the data matrix.</p>
</td></tr>
<tr><td><code id="plaid.grid_+3A_background.layer">background.layer</code></td>
<td>
<p>If background='TRUE' a own background layer
(Matrix with dimension of x) can be specified.</p>
</td></tr>
<tr><td><code id="plaid.grid_+3A_background.df">background.df</code></td>
<td>
<p>Degrees of Freedom of backround layer if background.layer is specified.</p>
</td></tr>
<tr><td><code id="plaid.grid_+3A_shuffle">shuffle</code></td>
<td>
<p>Before a layer is added, it's statistical significance is compared
against a number of layers obtained by random defined by this parameter. Default is
3, higher numbers could affect time performance. </p>
</td></tr>
<tr><td><code id="plaid.grid_+3A_iter.startup">iter.startup</code></td>
<td>
<p>Number of iterations to find starting values </p>
</td></tr>
<tr><td><code id="plaid.grid_+3A_iter.layer">iter.layer</code></td>
<td>
<p>Number of iterations to find each layer </p>
</td></tr>
<tr><td><code id="plaid.grid_+3A_back.fit">back.fit</code></td>
<td>
<p>After a layer is added, additional iterations can be done to
refine the fitting of the layer (default set to 0)</p>
</td></tr>
<tr><td><code id="plaid.grid_+3A_row.release">row.release</code></td>
<td>
<p>Scalar in [0,1](with interval recommended [0.5-0.7]) used as threshold to prune rows in the layers
depending on row homogeneity</p>
</td></tr>
<tr><td><code id="plaid.grid_+3A_col.release">col.release</code></td>
<td>
<p>As above, with columns </p>
</td></tr>
<tr><td><code id="plaid.grid_+3A_max.layers">max.layers</code></td>
<td>
<p>Maximum number of layer to include in the model </p>
</td></tr>
<tr><td><code id="plaid.grid_+3A_verbose">verbose</code></td>
<td>
<p>If 'TRUE' prints extra information on progress.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing parameter settings
</p>


<h3>Author(s)</h3>

<p>Sebastian Kaiser 
<a href="mailto:sebastian.kaiser@stat.uni-muenchen.de">sebastian.kaiser@stat.uni-muenchen.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ensemble">ensemble</a></code>, <code><a href="#topic+BCPlaid">BCPlaid</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plaid.grid()
</code></pre>

<hr>
<h2 id='plotclust'>Barplot of Bicluster</h2><span id='topic+plotclust'></span>

<h3>Description</h3>

<p> Draws a graph to compare the values inside the diffrent biclusters with the values outside the bicluster</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotclust(res,x,bicluster=TRUE,legende=FALSE,noC=5,wyld=3,Titel="Plotclust",...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotclust_+3A_x">x</code></td>
<td>
<p>The data matrix</p>
</td></tr>
<tr><td><code id="plotclust_+3A_res">res</code></td>
<td>
<p>BiclustResult object if bicluster=TRUE else a normal kcca object.</p>
</td></tr>
<tr><td><code id="plotclust_+3A_bicluster">bicluster</code></td>
<td>
<p>If TRUE,res is treated as a BiclustResult object</p>
</td></tr>
<tr><td><code id="plotclust_+3A_legende">legende</code></td>
<td>
<p>Draws a legend.</p>
</td></tr>
<tr><td><code id="plotclust_+3A_noc">noC</code></td>
<td>
<p>Number of Clusters drawn</p>
</td></tr>
<tr><td><code id="plotclust_+3A_wyld">wyld</code></td>
<td>
<p>Gives the distance between plot and axis.</p>
</td></tr>
<tr><td><code id="plotclust_+3A_titel">Titel</code></td>
<td>
<p>Gives the title of the plot.</p>
</td></tr>
<tr><td><code id="plotclust_+3A_...">...</code></td>
<td>
<p>Additional plot options</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sebastian Kaiser
<a href="mailto:sebastian.kaiser@stat.uni-muenchen.de">sebastian.kaiser@stat.uni-muenchen.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bubbleplot">bubbleplot</a></code> for simultaneous representation of biclusters.
<code><a href="#topic+parallelCoordinates">parallelCoordinates</a></code>for single representation of biclusters as lines of gene or condition profiles.
<code><a href="#topic+drawHeatmap">drawHeatmap</a></code>for Heatmap representation of biclusters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  s2=matrix(rnorm(400),20,20)
  s2[12:16,12:16]=rnorm(25,3,0.3)
  set.seed(1)
  bics &lt;- biclust(s2,BCPlaid(), back.fit = 2, shuffle = 3, fit.model = ~m + a + b,
  iter.startup = 5, iter.layer = 30,  verbose = TRUE)
  plotclust(bics,s2)

</code></pre>

<hr>
<h2 id='predictBimax'>Predict from a BCrepBimax Result</h2><span id='topic+predictBimax'></span>

<h3>Description</h3>

<p>Predicts cluster membership for new data rows given a BCrepBimax Result</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictBimax(BCrepBimax, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predictBimax_+3A_bcrepbimax">BCrepBimax</code></td>
<td>
<p>Result of biclust function with method BCrepBimax</p>
</td></tr>
<tr><td><code id="predictBimax_+3A_x">x</code></td>
<td>
<p>The data matrix which clustermembership should be predicted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector with clustermembership of data x of class.
</p>


<h3>Author(s)</h3>

<p>Sebastian Kaiser 
<a href="mailto:sebastian.kaiser@stat.uni-muenchen.de">sebastian.kaiser@stat.uni-muenchen.de</a>
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+BCrepBimax">BCrepBimax</a></code></p>

<hr>
<h2 id='SyntrenEcoli'>SynTReN E. coli</h2><span id='topic+SyntrenEcoli'></span><span id='topic+E.+20coli+20microarray+20synthetic+20data+20matrix'></span><span id='topic+Escherichia+20Coly+20data+20matrix+20generated+20by+20SynTReN'></span>

<h3>Description</h3>

<p>Synthetic microarray data matrix generated by Syntren for 20 experiments
using 200 genes from Transcription Regulatory Network of Shen-Orr et al. (2002).</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data(SyntrenEcoli)
  </code></pre>


<h3>Format</h3>

<p>Data structure with information about the expression levels of 200 genes over 20 conditions.
Conditions are named as C1... C20
</p>


<h3>Source</h3>

<p>SynTReN software can be downloaded at http://homes.esat.kuleuven.be/~kmarchal/SynTReN/index.html
</p>


<h3>References</h3>

<p>Shen-Orr et al., &quot;Network motifs in the transcriptional regulation network of Escherichia coli&quot;,
Nature Genetics 2002, volume 31, pages 64-68.
</p>
<p>Tim Van den Bulcke et al., &quot;SynTReN: a generator of synthetic gene expression data for design
and analysis of structure learning algorithms&quot;, BMC Bioinformatics, 2006,
volume 7, number 43.
</p>

<hr>
<h2 id='writeBiclusterResults'>writeBiclusterResults</h2><span id='topic+writeBiclusterResults'></span><span id='topic+writeBiclusters'></span>

<h3>Description</h3>

<p> Write bicluster results to a file</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeBiclusterResults(fileName, bicResult, bicName, geneNames, arrayNames,
  append=FALSE, delimiter=" ")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="writeBiclusterResults_+3A_filename">fileName</code></td>
<td>
<p>Path to the file were biclusters are written.</p>
</td></tr>
<tr><td><code id="writeBiclusterResults_+3A_bicresult">bicResult</code></td>
<td>
<p>Biclusters results as a Biclust class.</p>
</td></tr>
<tr><td><code id="writeBiclusterResults_+3A_bicname">bicName</code></td>
<td>
<p>Brief description for the biclustering algorithm used.</p>
</td></tr>
<tr><td><code id="writeBiclusterResults_+3A_genenames">geneNames</code></td>
<td>
<p>Array of strings with gene (row) names in the analyzed data matrix</p>
</td></tr>
<tr><td><code id="writeBiclusterResults_+3A_arraynames">arrayNames</code></td>
<td>
<p>Array of strings with condition (column) names in the analyzed data matrix</p>
</td></tr>
<tr><td><code id="writeBiclusterResults_+3A_append">append</code></td>
<td>
<p>If true, adds the bicluster results to previous information in the text file, if it exists. Default false.</p>
</td></tr>
<tr><td><code id="writeBiclusterResults_+3A_delimiter">delimiter</code></td>
<td>
<p>delimiter string between gene and condition names. Default &quot; &quot;.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rodrigo Santamaria
<a href="mailto:rodri@usal.es">rodri@usal.es</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
  data(BicatYeast)
  res &lt;- biclust(BicatYeast, method=BCCC(), delta=1.5,  alpha=1, number=10)
  writeBiclusterResults("results.txt", res,"CC with delta 1.5", dimnames(BicatYeast)[1][[1]],
    dimnames(BicatYeast)[2][[1]])
  
## End(Not run)
  </code></pre>

<hr>
<h2 id='writeclust'>Write a Bicluster as a Cluster Result</h2><span id='topic+writeclust'></span>

<h3>Description</h3>

<p> Draws a graph to compare the values inside the diffrent biclusters with the values outside the bicluster</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeclust(Biclusterresult,row=TRUE,noC=10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="writeclust_+3A_biclusterresult">Biclusterresult</code></td>
<td>
<p>BiclustResult object</p>
</td></tr>
<tr><td><code id="writeclust_+3A_row">row</code></td>
<td>
<p>If TRUE, cluster of rows were written.</p>
</td></tr>
<tr><td><code id="writeclust_+3A_noc">noC</code></td>
<td>
<p>Number of Clusters written</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sebastian Kaiser
<a href="mailto:sebastian.kaiser@stat.uni-muenchen.de">sebastian.kaiser@stat.uni-muenchen.de</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  s2=matrix(rnorm(400),20,20)
  s2[12:16,12:16]=rnorm(25,3,0.3)
  set.seed(1)
  bics &lt;- biclust(s2,BCPlaid(), back.fit = 2, shuffle = 3, fit.model = ~m + a + b,
  iter.startup = 5, iter.layer = 30,  verbose = TRUE)
  writeclust(bics)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
