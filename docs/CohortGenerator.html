<!DOCTYPE html><html lang="en-US"><head><title>Help for package CohortGenerator</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CohortGenerator}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CohortGenerator-package'><p>CohortGenerator: Cohort Generation for the OMOP Common Data Model</p></a></li>
<li><a href='#addCohortSubsetDefinition'><p>Add cohort subset definition to a cohort definition set</p></a></li>
<li><a href='#checkAndFixCohortDefinitionSetDataTypes'><p>Check if a cohort definition set is using the proper data types</p></a></li>
<li><a href='#CohortSubsetDefinition'><p>Cohort Subset Definition</p></a></li>
<li><a href='#CohortSubsetOperator'><p>Cohort Subset Operator</p></a></li>
<li><a href='#computeChecksum'><p>Computes the checksum for a value</p></a></li>
<li><a href='#createCohortSubset'><p>A definition of subset functions to be applied to a set of cohorts</p></a></li>
<li><a href='#createCohortSubsetDefinition'><p>Create Subset Definition</p></a></li>
<li><a href='#createCohortTables'><p>Create cohort tables</p></a></li>
<li><a href='#createDemographicSubset'><p>Create createDemographicSubset Subset</p></a></li>
<li><a href='#createEmptyCohortDefinitionSet'><p>Create an empty cohort definition set</p></a></li>
<li><a href='#createEmptyNegativeControlOutcomeCohortSet'><p>Create an empty negative control outcome cohort set</p></a></li>
<li><a href='#createLimitSubset'><p>Create Limit Subset</p></a></li>
<li><a href='#createResultsDataModel'><p>Create the results data model tables on a database server.</p></a></li>
<li><a href='#createSubsetCohortWindow'><p>A definition of subset functions to be applied to a set of cohorts</p></a></li>
<li><a href='#DemographicSubsetOperator'><p>Demographic Subset Operator</p></a></li>
<li><a href='#dropCohortStatsTables'><p>Drop cohort statistics tables</p></a></li>
<li><a href='#exportCohortStatsTables'><p>Export the cohort statistics tables to the file system</p></a></li>
<li><a href='#generateCohortSet'><p>Generate a set of cohorts</p></a></li>
<li><a href='#generateNegativeControlOutcomeCohorts'><p>Generate a set of negative control outcome cohorts</p></a></li>
<li><a href='#getCohortCounts'><p>Count the cohort(s)</p></a></li>
<li><a href='#getCohortDefinitionSet'><p>Get a cohort definition set</p></a></li>
<li><a href='#getCohortInclusionRules'><p>Get Cohort Inclusion Rules from a cohort definition set</p></a></li>
<li><a href='#getCohortStats'><p>Get Cohort Inclusion Stats Table Data</p></a></li>
<li><a href='#getCohortTableNames'><p>Used to get a list of cohort table names to use when creating the cohort</p>
tables</a></li>
<li><a href='#getDataMigrator'><p>Get database migrations instance</p></a></li>
<li><a href='#getRequiredTasks'><p>Get a list of tasks required when running in incremental mode</p></a></li>
<li><a href='#getResultsDataModelSpecifications'><p>Get specifications for CohortGenerator results data model</p></a></li>
<li><a href='#getSubsetDefinitions'><p>Get cohort subset definitions from a cohort definition set</p></a></li>
<li><a href='#insertInclusionRuleNames'><p>Used to insert the inclusion rule names from a cohort definition set</p>
when generating cohorts that include cohort statistics</a></li>
<li><a href='#isCamelCase'><p>Used to check if a string is in lower camel case</p></a></li>
<li><a href='#isCohortDefinitionSet'><p>Is the data.frame a cohort definition set?</p></a></li>
<li><a href='#isFormattedForDatabaseUpload'><p>Is the data.frame formatted for uploading to a database?</p></a></li>
<li><a href='#isSnakeCase'><p>Used to check if a string is in snake case</p></a></li>
<li><a href='#isTaskRequired'><p>Is a task required when running in incremental mode</p></a></li>
<li><a href='#LimitSubsetOperator'><p>Limit Subset Operator</p></a></li>
<li><a href='#migrateDataModel'><p>Migrate Data model</p></a></li>
<li><a href='#readCsv'><p>Used to read a .csv file</p></a></li>
<li><a href='#recordTasksDone'><p>Record a task as complete</p></a></li>
<li><a href='#runCohortGeneration'><p>Run a cohort generation and export results</p></a></li>
<li><a href='#sampleCohortDefinitionSet'><p>Sample Cohort Definition Set</p></a></li>
<li><a href='#saveCohortDefinitionSet'><p>Save the cohort definition set to the file system</p></a></li>
<li><a href='#saveCohortSubsetDefinition'><p>Save cohort subset definitions to json</p></a></li>
<li><a href='#saveIncremental'><p>Used in incremental mode to save values to a file</p></a></li>
<li><a href='#SubsetCohortWindow'><p>Time Window For Cohort Subset Operator</p></a></li>
<li><a href='#SubsetOperator'><p>Abstract base class for subsets.</p></a></li>
<li><a href='#uploadResults'><p>Upload results to the database server.</p></a></li>
<li><a href='#writeCsv'><p>Used to write a .csv file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Cohort Generation for the OMOP Common Data Model</td>
</tr>
<tr>
<td>Version:</td>
<td>0.11.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-09-30</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Anthony Sena &lt;sena@ohdsi.org&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Generate cohorts and subsets using an Observational 
  Medical Outcomes Partnership (OMOP) Common Data Model (CDM) Database. 
  Cohorts are  defined using 'CIRCE' (<a href="https://github.com/ohdsi/circe-be">https://github.com/ohdsi/circe-be</a>) or 
  SQL compatible with 'SqlRender' (<a href="https://github.com/OHDSI/SqlRender">https://github.com/OHDSI/SqlRender</a>).</td>
</tr>
<tr>
<td>Depends:</td>
<td>DatabaseConnector (&ge; 5.0.0), R (&ge; 3.6.0), R6</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate, digest, dplyr, lubridate, methods, ParallelLogger
(&ge; 3.0.0), readr (&ge; 2.1.0), rlang, RJSONIO, jsonlite,
ResultModelManager, SqlRender (&ge; 1.11.1), stringi (&ge; 1.7.6),
tibble</td>
</tr>
<tr>
<td>Suggests:</td>
<td>CirceR (&ge; 1.1.1), Eunomia, knitr, rmarkdown, testthat,
withr, zip</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/LICENSE-1.1">Apache License version 1.1</a> | <a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License version 2.0</a> [expanded from: Apache License]</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://ohdsi.github.io/CohortGenerator/">https://ohdsi.github.io/CohortGenerator/</a>,
<a href="https://github.com/OHDSI/CohortGenerator">https://github.com/OHDSI/CohortGenerator</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/OHDSI/CohortGenerator/issues">https://github.com/OHDSI/CohortGenerator/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-30 16:03:28 UTC; asena5</td>
</tr>
<tr>
<td>Author:</td>
<td>Anthony Sena [aut, cre],
  Jamie Gilbert [aut],
  Gowtham Rao [aut],
  Martijn Schuemie [aut],
  Observational Health Data Science and Informatics [cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-30 19:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='CohortGenerator-package'>CohortGenerator: Cohort Generation for the OMOP Common Data Model</h2><span id='topic+CohortGenerator'></span><span id='topic+CohortGenerator-package'></span>

<h3>Description</h3>

<p>Generate cohorts and subsets using an Observational Medical Outcomes Partnership (OMOP) Common Data Model (CDM) Database. Cohorts are defined using 'CIRCE' (<a href="https://github.com/ohdsi/circe-be">https://github.com/ohdsi/circe-be</a>) or SQL compatible with 'SqlRender' (<a href="https://github.com/OHDSI/SqlRender">https://github.com/OHDSI/SqlRender</a>).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Anthony Sena <a href="mailto:sena@ohdsi.org">sena@ohdsi.org</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Jamie Gilbert
</p>
</li>
<li><p> Gowtham Rao <a href="mailto:gowthamrao@gmail.com">gowthamrao@gmail.com</a>
</p>
</li>
<li><p> Martijn Schuemie <a href="mailto:schuemie@ohdsi.org">schuemie@ohdsi.org</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Observational Health Data Science and Informatics [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://ohdsi.github.io/CohortGenerator/">https://ohdsi.github.io/CohortGenerator/</a>
</p>
</li>
<li> <p><a href="https://github.com/OHDSI/CohortGenerator">https://github.com/OHDSI/CohortGenerator</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/OHDSI/CohortGenerator/issues">https://github.com/OHDSI/CohortGenerator/issues</a>
</p>
</li></ul>


<hr>
<h2 id='addCohortSubsetDefinition'>Add cohort subset definition to a cohort definition set</h2><span id='topic+addCohortSubsetDefinition'></span>

<h3>Description</h3>

<p>Given a subset definition and cohort definition set, this function returns a modified cohortDefinitionSet
That contains cohorts that's have parent's contained within the base cohortDefinitionSet
</p>
<p>Also adds the columns subsetParent and isSubset that denote if the cohort is a subset and what the parent definition
is.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addCohortSubsetDefinition(
  cohortDefinitionSet,
  cohortSubsetDefintion,
  targetCohortIds = NULL,
  overwriteExisting = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addCohortSubsetDefinition_+3A_cohortdefinitionset">cohortDefinitionSet</code></td>
<td>
<p>data.frame that conforms to CohortDefinitionSet</p>
</td></tr>
<tr><td><code id="addCohortSubsetDefinition_+3A_cohortsubsetdefintion">cohortSubsetDefintion</code></td>
<td>
<p>CohortSubsetDefinition instance</p>
</td></tr>
<tr><td><code id="addCohortSubsetDefinition_+3A_targetcohortids">targetCohortIds</code></td>
<td>
<p>Cohort ids to apply subset definition to. If not set, subset definition is applied
to all base cohorts in set (i.e. those that are not defined by subsetOperators).
Applying to cohorts that are already subsets is permitted, however, this should be
done with care and identifiers must be specified manually</p>
</td></tr>
<tr><td><code id="addCohortSubsetDefinition_+3A_overwriteexisting">overwriteExisting</code></td>
<td>
<p>Overwrite existing subset definition of the same definitionId if present</p>
</td></tr>
</table>

<hr>
<h2 id='checkAndFixCohortDefinitionSetDataTypes'>Check if a cohort definition set is using the proper data types</h2><span id='topic+checkAndFixCohortDefinitionSetDataTypes'></span>

<h3>Description</h3>

<p>This function checks a data.frame to verify it holds the expected format
for a cohortDefinitionSet's data types and can optionally fix data types
that do not match the specification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkAndFixCohortDefinitionSetDataTypes(
  x,
  fixDataTypes = TRUE,
  emitWarning = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkAndFixCohortDefinitionSetDataTypes_+3A_x">x</code></td>
<td>
<p>The cohortDefinitionSet data.frame to check</p>
</td></tr>
<tr><td><code id="checkAndFixCohortDefinitionSetDataTypes_+3A_fixdatatypes">fixDataTypes</code></td>
<td>
<p>When TRUE, this function will attempt to fix the data types
to match the specification. @seealso [createEmptyCohortDefinitionSet()].</p>
</td></tr>
<tr><td><code id="checkAndFixCohortDefinitionSetDataTypes_+3A_emitwarning">emitWarning</code></td>
<td>
<p>When TRUE, this function will emit warning messages when problems are
encountered.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list() of the following form:
</p>
<p>list(
dataTypesMatch = TRUE/FALSE,
x = data.frame()
)
</p>
<p>dataTypesMatch == TRUE when the supplied data.frame x matches the cohortDefinitionSet
specification's data types.
</p>
<p>If fixDataTypes == TRUE, x will hold the original data from x with the
data types corrected. Otherwise x will hold the original value passed to this
function.
</p>

<hr>
<h2 id='CohortSubsetDefinition'>Cohort Subset Definition</h2><span id='topic+CohortSubsetDefinition'></span>

<h3>Description</h3>

<p>Set of subset definitions
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>targetOutputPairs</code></dt><dd><p>list of pairs of integers - (targetCohortId, outputCohortId)</p>
</dd>
<dt><code>subsetOperators</code></dt><dd><p>list of subset operations</p>
</dd>
<dt><code>name</code></dt><dd><p>name of definition</p>
</dd>
<dt><code>subsetCohortNameTemplate</code></dt><dd><p>template string for formatting resulting cohort names</p>
</dd>
<dt><code>operatorNameConcatString</code></dt><dd><p>string used when concatenating operator names together</p>
</dd>
<dt><code>definitionId</code></dt><dd><p>numeric definition id</p>
</dd>
<dt><code>identifierExpression</code></dt><dd><p>expression that can be evaluated from</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-CohortSubsetDefinition-new"><code>CohortSubsetDefinition$new()</code></a>
</p>
</li>
<li> <p><a href="#method-CohortSubsetDefinition-toList"><code>CohortSubsetDefinition$toList()</code></a>
</p>
</li>
<li> <p><a href="#method-CohortSubsetDefinition-toJSON"><code>CohortSubsetDefinition$toJSON()</code></a>
</p>
</li>
<li> <p><a href="#method-CohortSubsetDefinition-addSubsetOperator"><code>CohortSubsetDefinition$addSubsetOperator()</code></a>
</p>
</li>
<li> <p><a href="#method-CohortSubsetDefinition-getSubsetQuery"><code>CohortSubsetDefinition$getSubsetQuery()</code></a>
</p>
</li>
<li> <p><a href="#method-CohortSubsetDefinition-getSubsetCohortName"><code>CohortSubsetDefinition$getSubsetCohortName()</code></a>
</p>
</li>
<li> <p><a href="#method-CohortSubsetDefinition-setTargetOutputPairs"><code>CohortSubsetDefinition$setTargetOutputPairs()</code></a>
</p>
</li>
<li> <p><a href="#method-CohortSubsetDefinition-getJsonFileName"><code>CohortSubsetDefinition$getJsonFileName()</code></a>
</p>
</li>
<li> <p><a href="#method-CohortSubsetDefinition-clone"><code>CohortSubsetDefinition$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-CohortSubsetDefinition-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>CohortSubsetDefinition$new(definition = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>definition</code></dt><dd><p>json or list representation of object
to List</p>
</dd>
</dl>

</div>


<hr>
<a id="method-CohortSubsetDefinition-toList"></a>



<h4>Method <code>toList()</code></h4>

<p>List representation of object
to JSON
</p>


<h5>Usage</h5>

<div class="r"><pre>CohortSubsetDefinition$toList()</pre></div>


<hr>
<a id="method-CohortSubsetDefinition-toJSON"></a>



<h4>Method <code>toJSON()</code></h4>

<p>json serialized representation of object
add Subset Operator
</p>


<h5>Usage</h5>

<div class="r"><pre>CohortSubsetDefinition$toJSON()</pre></div>


<hr>
<a id="method-CohortSubsetDefinition-addSubsetOperator"></a>



<h4>Method <code>addSubsetOperator()</code></h4>

<p>add subset to class - checks if equivalent id is present
Will throw an error if a matching ID is found but reference object is different
</p>


<h5>Usage</h5>

<div class="r"><pre>CohortSubsetDefinition$addSubsetOperator(subsetOperator)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>subsetOperator</code></dt><dd><p>a SubsetOperator instance</p>
</dd>
<dt><code>overwrite</code></dt><dd><p>if a subset operator of the same ID is present, replace it with a new definition
get query for a given target output pair</p>
</dd>
</dl>

</div>


<hr>
<a id="method-CohortSubsetDefinition-getSubsetQuery"></a>



<h4>Method <code>getSubsetQuery()</code></h4>

<p>Returns vector of join, logic, having statements returned by subset operations
</p>


<h5>Usage</h5>

<div class="r"><pre>CohortSubsetDefinition$getSubsetQuery(targetOutputPair)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>targetOutputPair</code></dt><dd><p>Target output pair
Get name of an output cohort</p>
</dd>
</dl>

</div>


<hr>
<a id="method-CohortSubsetDefinition-getSubsetCohortName"></a>



<h4>Method <code>getSubsetCohortName()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>CohortSubsetDefinition$getSubsetCohortName(
  cohortDefinitionSet,
  targetOutputPair
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>cohortDefinitionSet</code></dt><dd><p>Cohort definition set containing base names</p>
</dd>
<dt><code>targetOutputPair</code></dt><dd><p>Target output pair
Set the targetOutputPairs to be added to a cohort definition set</p>
</dd>
</dl>

</div>


<hr>
<a id="method-CohortSubsetDefinition-setTargetOutputPairs"></a>



<h4>Method <code>setTargetOutputPairs()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>CohortSubsetDefinition$setTargetOutputPairs(targetIds)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>targetIds</code></dt><dd><p>list of cohort ids to apply subsetting operations to
Get json file name for subset definition in folder</p>
</dd>
</dl>

</div>


<hr>
<a id="method-CohortSubsetDefinition-getJsonFileName"></a>



<h4>Method <code>getJsonFileName()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>CohortSubsetDefinition$getJsonFileName(
  subsetJsonFolder = "inst/cohort_subset_definitions/"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>subsetJsonFolder</code></dt><dd><p>path to folder to place file</p>
</dd>
</dl>

</div>


<hr>
<a id="method-CohortSubsetDefinition-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>CohortSubsetDefinition$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='CohortSubsetOperator'>Cohort Subset Operator</h2><span id='topic+CohortSubsetOperator'></span>

<h3>Description</h3>

<p>A subset of type cohort - subset a population to only those contained within defined cohort
to List
</p>


<h3>Super class</h3>

<p><code><a href="#topic+SubsetOperator">CohortGenerator::SubsetOperator</a></code> -&gt; <code>CohortSubsetOperator</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>cohortIds</code></dt><dd><p>Integer ids of cohorts to subset to</p>
</dd>
<dt><code>cohortCombinationOperator</code></dt><dd><p>How to combine the cohorts</p>
</dd>
<dt><code>negate</code></dt><dd><p>Inverse the subset rule? TRUE will take the patients NOT in the subset</p>
</dd>
<dt><code>startWindow</code></dt><dd><p>The time window to use evaluating the subset cohort
start relative to the target cohort</p>
</dd>
<dt><code>endWindow</code></dt><dd><p>The time window to use evaluating the subset cohort
end relative to the target cohort</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-CohortSubsetOperator-toList"><code>CohortSubsetOperator$toList()</code></a>
</p>
</li>
<li> <p><a href="#method-CohortSubsetOperator-getAutoGeneratedName"><code>CohortSubsetOperator$getAutoGeneratedName()</code></a>
</p>
</li>
<li> <p><a href="#method-CohortSubsetOperator-clone"><code>CohortSubsetOperator$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="CohortGenerator" data-topic="SubsetOperator" data-id="classname"><a href='../../CohortGenerator/html/SubsetOperator.html#method-SubsetOperator-classname'><code>CohortGenerator::SubsetOperator$classname()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CohortGenerator" data-topic="SubsetOperator" data-id="getQueryBuilder"><a href='../../CohortGenerator/html/SubsetOperator.html#method-SubsetOperator-getQueryBuilder'><code>CohortGenerator::SubsetOperator$getQueryBuilder()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CohortGenerator" data-topic="SubsetOperator" data-id="initialize"><a href='../../CohortGenerator/html/SubsetOperator.html#method-SubsetOperator-initialize'><code>CohortGenerator::SubsetOperator$initialize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CohortGenerator" data-topic="SubsetOperator" data-id="isEqualTo"><a href='../../CohortGenerator/html/SubsetOperator.html#method-SubsetOperator-isEqualTo'><code>CohortGenerator::SubsetOperator$isEqualTo()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CohortGenerator" data-topic="SubsetOperator" data-id="publicFields"><a href='../../CohortGenerator/html/SubsetOperator.html#method-SubsetOperator-publicFields'><code>CohortGenerator::SubsetOperator$publicFields()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CohortGenerator" data-topic="SubsetOperator" data-id="toJSON"><a href='../../CohortGenerator/html/SubsetOperator.html#method-SubsetOperator-toJSON'><code>CohortGenerator::SubsetOperator$toJSON()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-CohortSubsetOperator-toList"></a>



<h4>Method <code>toList()</code></h4>

<p>List representation of object
Get auto generated name
</p>


<h5>Usage</h5>

<div class="r"><pre>CohortSubsetOperator$toList()</pre></div>


<hr>
<a id="method-CohortSubsetOperator-getAutoGeneratedName"></a>



<h4>Method <code>getAutoGeneratedName()</code></h4>

<p>name generated from subset operation properties
</p>


<h5>Usage</h5>

<div class="r"><pre>CohortSubsetOperator$getAutoGeneratedName()</pre></div>



<h5>Returns</h5>

<p>character
</p>


<hr>
<a id="method-CohortSubsetOperator-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>CohortSubsetOperator$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='computeChecksum'>Computes the checksum for a value</h2><span id='topic+computeChecksum'></span>

<h3>Description</h3>

<p>This is used as part of the incremental operations to hash a value
to store in a record keeping file. This function leverages the md5
hash from the digest package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeChecksum(val)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computeChecksum_+3A_val">val</code></td>
<td>
<p>The value to hash. It is converted to a character to perform
the hash.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a string containing the checksum
</p>

<hr>
<h2 id='createCohortSubset'>A definition of subset functions to be applied to a set of cohorts</h2><span id='topic+createCohortSubset'></span>

<h3>Description</h3>

<p>A definition of subset functions to be applied to a set of cohorts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createCohortSubset(
  name = NULL,
  cohortIds,
  cohortCombinationOperator,
  negate,
  startWindow,
  endWindow
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createCohortSubset_+3A_name">name</code></td>
<td>
<p>optional name of operator</p>
</td></tr>
<tr><td><code id="createCohortSubset_+3A_cohortids">cohortIds</code></td>
<td>
<p>integer - set of cohort ids to subset to</p>
</td></tr>
<tr><td><code id="createCohortSubset_+3A_cohortcombinationoperator">cohortCombinationOperator</code></td>
<td>
<p>&quot;any&quot; or &quot;all&quot; if using more than one cohort id allow a subject to be in any cohort
or require that they are in all cohorts in specified windows</p>
</td></tr>
<tr><td><code id="createCohortSubset_+3A_negate">negate</code></td>
<td>
<p>The opposite of this definition - include patients who do NOT meet the specified criteria</p>
</td></tr>
<tr><td><code id="createCohortSubset_+3A_startwindow">startWindow</code></td>
<td>
<p>A SubsetCohortWindow that patients must fall inside (see createSubsetCohortWindow)</p>
</td></tr>
<tr><td><code id="createCohortSubset_+3A_endwindow">endWindow</code></td>
<td>
<p>A SubsetCohortWindow that patients must fall inside (see createSubsetCohortWindow)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a CohortSubsetOperator instance
</p>

<hr>
<h2 id='createCohortSubsetDefinition'>Create Subset Definition</h2><span id='topic+createCohortSubsetDefinition'></span>

<h3>Description</h3>

<p>Create subset definition from subset objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createCohortSubsetDefinition(
  name,
  definitionId,
  subsetOperators,
  identifierExpression = NULL,
  operatorNameConcatString = "",
  subsetCohortNameTemplate = ""
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createCohortSubsetDefinition_+3A_name">name</code></td>
<td>
<p>Name of definition</p>
</td></tr>
<tr><td><code id="createCohortSubsetDefinition_+3A_definitionid">definitionId</code></td>
<td>
<p>Definition identifier</p>
</td></tr>
<tr><td><code id="createCohortSubsetDefinition_+3A_subsetoperators">subsetOperators</code></td>
<td>
<p>list of subsetOperator instances to apply</p>
</td></tr>
<tr><td><code id="createCohortSubsetDefinition_+3A_identifierexpression">identifierExpression</code></td>
<td>
<p>Expression (or string that converts to expression) that returns an id for an output cohort
the default is dplyr::expr(targetId * 1000 + definitionId)</p>
</td></tr>
<tr><td><code id="createCohortSubsetDefinition_+3A_operatornameconcatstring">operatorNameConcatString</code></td>
<td>
<p>(optional) String to concatenate operator names together when outputting resulting cohort
name</p>
</td></tr>
<tr><td><code id="createCohortSubsetDefinition_+3A_subsetcohortnametemplate">subsetCohortNameTemplate</code></td>
<td>
<p>(optional) SqlRender string template for formatting names of resulting subset cohorts
Can use the variables @baseCohortName, @subsetDefinitionName and @operatorNames.
This is applied when adding the subset definition to a cohort definition set.</p>
</td></tr>
</table>

<hr>
<h2 id='createCohortTables'>Create cohort tables</h2><span id='topic+createCohortTables'></span>

<h3>Description</h3>

<p>This function creates an empty cohort table and empty tables for
cohort statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createCohortTables(
  connectionDetails = NULL,
  connection = NULL,
  cohortDatabaseSchema,
  cohortTableNames = getCohortTableNames(),
  incremental = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createCohortTables_+3A_connectiondetails">connectionDetails</code></td>
<td>
<p>An object of type <code>connectionDetails</code> as created using the
<code><a href="DatabaseConnector.html#topic+createConnectionDetails">createConnectionDetails</a></code> function in the
DatabaseConnector package. Can be left NULL if <code>connection</code> is
provided.</p>
</td></tr>
<tr><td><code id="createCohortTables_+3A_connection">connection</code></td>
<td>
<p>An object of type <code>connection</code> as created using the
<code><a href="DatabaseConnector.html#topic+connect">connect</a></code> function in the
DatabaseConnector package. Can be left NULL if <code>connectionDetails</code>
is provided, in which case a new connection will be opened at the start
of the function, and closed when the function finishes.</p>
</td></tr>
<tr><td><code id="createCohortTables_+3A_cohortdatabaseschema">cohortDatabaseSchema</code></td>
<td>
<p>Schema name where your cohort tables reside. Note that for SQL Server,
this should include both the database and schema name, for example
'scratch.dbo'.</p>
</td></tr>
<tr><td><code id="createCohortTables_+3A_cohorttablenames">cohortTableNames</code></td>
<td>
<p>The names of the cohort tables. See <code><a href="#topic+getCohortTableNames">getCohortTableNames</a></code>
for more details.</p>
</td></tr>
<tr><td><code id="createCohortTables_+3A_incremental">incremental</code></td>
<td>
<p>When set to TRUE, this function will check to see
if the cohortTableNames exists in the cohortDatabaseSchema
and if they exist, it will skip creating the tables.</p>
</td></tr>
</table>

<hr>
<h2 id='createDemographicSubset'>Create createDemographicSubset Subset</h2><span id='topic+createDemographicSubset'></span>

<h3>Description</h3>

<p>Create createDemographicSubset Subset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createDemographicSubset(
  name = NULL,
  ageMin = 0,
  ageMax = 99999,
  gender = NULL,
  race = NULL,
  ethnicity = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createDemographicSubset_+3A_name">name</code></td>
<td>
<p>Optional char name</p>
</td></tr>
<tr><td><code id="createDemographicSubset_+3A_agemin">ageMin</code></td>
<td>
<p>The minimum age</p>
</td></tr>
<tr><td><code id="createDemographicSubset_+3A_agemax">ageMax</code></td>
<td>
<p>The maximum age</p>
</td></tr>
<tr><td><code id="createDemographicSubset_+3A_gender">gender</code></td>
<td>
<p>Gender demographics - concepts - 0, 8532, 8507, 0, &quot;female&quot;, &quot;male&quot;.
Any string that is not &quot;male&quot; or &quot;female&quot; (case insensitive) is converted to gender concept 0.
https://athena.ohdsi.org/search-terms/terms?standardConcept=Standard&amp;domain=Gender&amp;page=1&amp;pageSize=15&amp;query=
Specific concept ids not in this set can be used but are not explicitly validated</p>
</td></tr>
<tr><td><code id="createDemographicSubset_+3A_race">race</code></td>
<td>
<p>Race demographics - concept ID list</p>
</td></tr>
<tr><td><code id="createDemographicSubset_+3A_ethnicity">ethnicity</code></td>
<td>
<p>Ethnicity demographics - concept ID list</p>
</td></tr>
</table>

<hr>
<h2 id='createEmptyCohortDefinitionSet'>Create an empty cohort definition set</h2><span id='topic+createEmptyCohortDefinitionSet'></span>

<h3>Description</h3>

<p>This function creates an empty cohort set data.frame for use
with <code>generateCohortSet</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createEmptyCohortDefinitionSet(verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createEmptyCohortDefinitionSet_+3A_verbose">verbose</code></td>
<td>
<p>When TRUE, descriptions of each field in the data.frame are
returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns an empty cohort set data.frame
</p>

<hr>
<h2 id='createEmptyNegativeControlOutcomeCohortSet'>Create an empty negative control outcome cohort set</h2><span id='topic+createEmptyNegativeControlOutcomeCohortSet'></span>

<h3>Description</h3>

<p>This function creates an empty cohort set data.frame for use
with <code>generateNegativeControlOutcomeCohorts</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createEmptyNegativeControlOutcomeCohortSet(verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createEmptyNegativeControlOutcomeCohortSet_+3A_verbose">verbose</code></td>
<td>
<p>When TRUE, descriptions of each field in the data.frame are
returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns an empty negative control outcome cohort set data.frame
</p>

<hr>
<h2 id='createLimitSubset'>Create Limit Subset</h2><span id='topic+createLimitSubset'></span>

<h3>Description</h3>

<p>Subset cohorts using specified limit criteria
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createLimitSubset(
  name = NULL,
  priorTime = 0,
  followUpTime = 0,
  limitTo = "all",
  calendarStartDate = NULL,
  calendarEndDate = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createLimitSubset_+3A_name">name</code></td>
<td>
<p>Name of operation</p>
</td></tr>
<tr><td><code id="createLimitSubset_+3A_priortime">priorTime</code></td>
<td>
<p>Required prior observation window (specified as a positive integer)</p>
</td></tr>
<tr><td><code id="createLimitSubset_+3A_followuptime">followUpTime</code></td>
<td>
<p>Required post observation window (specified as a positive integer)</p>
</td></tr>
<tr><td><code id="createLimitSubset_+3A_limitto">limitTo</code></td>
<td>
<p>character one of:
&quot;firstEver&quot; - only first entry in patient history
&quot;earliestRemaining&quot; - only first entry after washout set by priorTime
&quot;latestRemaining&quot; -  the latest remaining after washout set by followUpTime
&quot;lastEver&quot; - only last entry in patient history inside
</p>
<p>Note, when using firstEver and lastEver with follow up and washout, patients with events
outside this will be censored. The &quot;firstEver&quot; and &quot;lastEver&quot; are applied first.
The &quot;earliestRemaining&quot; and &quot;latestRemaining&quot; are applied after all other limit
criteria are applied (i.e. after applying prior/post time and calendar time).</p>
</td></tr>
<tr><td><code id="createLimitSubset_+3A_calendarstartdate">calendarStartDate</code></td>
<td>
<p>End date to allow periods (e.g. 2020/1/1/)</p>
</td></tr>
<tr><td><code id="createLimitSubset_+3A_calendarenddate">calendarEndDate</code></td>
<td>
<p>Start date to allow period (e.g. 2015/1/1)</p>
</td></tr>
</table>

<hr>
<h2 id='createResultsDataModel'>Create the results data model tables on a database server.</h2><span id='topic+createResultsDataModel'></span>

<h3>Description</h3>

<p>Create the results data model tables on a database server.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createResultsDataModel(
  connectionDetails = NULL,
  databaseSchema,
  tablePrefix = ""
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createResultsDataModel_+3A_connectiondetails">connectionDetails</code></td>
<td>
<p>DatabaseConnector connectionDetails instance @seealso[DatabaseConnector::createConnectionDetails]</p>
</td></tr>
<tr><td><code id="createResultsDataModel_+3A_databaseschema">databaseSchema</code></td>
<td>
<p>The schema on the server where the tables will be created.</p>
</td></tr>
<tr><td><code id="createResultsDataModel_+3A_tableprefix">tablePrefix</code></td>
<td>
<p>(Optional)  string to insert before table names for database table names</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only PostgreSQL and SQLite servers are supported.
</p>

<hr>
<h2 id='createSubsetCohortWindow'>A definition of subset functions to be applied to a set of cohorts</h2><span id='topic+createSubsetCohortWindow'></span>

<h3>Description</h3>

<p>A definition of subset functions to be applied to a set of cohorts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createSubsetCohortWindow(startDay, endDay, targetAnchor)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createSubsetCohortWindow_+3A_startday">startDay</code></td>
<td>
<p>The start day for the window</p>
</td></tr>
<tr><td><code id="createSubsetCohortWindow_+3A_endday">endDay</code></td>
<td>
<p>The end day for the window</p>
</td></tr>
<tr><td><code id="createSubsetCohortWindow_+3A_targetanchor">targetAnchor</code></td>
<td>
<p>To anchor using the target cohort's start date or end date</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a SubsetCohortWindow instance
</p>

<hr>
<h2 id='DemographicSubsetOperator'>Demographic Subset Operator</h2><span id='topic+DemographicSubsetOperator'></span>

<h3>Description</h3>

<p>Operators for subsetting a cohort by demographic criteria
</p>


<h3>Value</h3>

<p>char vector
Get auto generated name
</p>


<h3>Super class</h3>

<p><code><a href="#topic+SubsetOperator">CohortGenerator::SubsetOperator</a></code> -&gt; <code>DemographicSubsetOperator</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>ageMin</code></dt><dd><p>Int between 0 and 99999 - minimum age</p>
</dd>
<dt><code>ageMax</code></dt><dd><p>Int between 0 and 99999 - maximum age</p>
</dd>
<dt><code>gender</code></dt><dd><p>vector of gender concept IDs</p>
</dd>
<dt><code>race</code></dt><dd><p>character string denoting race</p>
</dd>
<dt><code>ethnicity</code></dt><dd><p>character string denoting ethnicity</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-DemographicSubsetOperator-toList"><code>DemographicSubsetOperator$toList()</code></a>
</p>
</li>
<li> <p><a href="#method-DemographicSubsetOperator-mapGenderConceptsToNames"><code>DemographicSubsetOperator$mapGenderConceptsToNames()</code></a>
</p>
</li>
<li> <p><a href="#method-DemographicSubsetOperator-getAutoGeneratedName"><code>DemographicSubsetOperator$getAutoGeneratedName()</code></a>
</p>
</li>
<li> <p><a href="#method-DemographicSubsetOperator-toJSON"><code>DemographicSubsetOperator$toJSON()</code></a>
</p>
</li>
<li> <p><a href="#method-DemographicSubsetOperator-isEqualTo"><code>DemographicSubsetOperator$isEqualTo()</code></a>
</p>
</li>
<li> <p><a href="#method-DemographicSubsetOperator-getGender"><code>DemographicSubsetOperator$getGender()</code></a>
</p>
</li>
<li> <p><a href="#method-DemographicSubsetOperator-getRace"><code>DemographicSubsetOperator$getRace()</code></a>
</p>
</li>
<li> <p><a href="#method-DemographicSubsetOperator-getEthnicity"><code>DemographicSubsetOperator$getEthnicity()</code></a>
</p>
</li>
<li> <p><a href="#method-DemographicSubsetOperator-clone"><code>DemographicSubsetOperator$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="CohortGenerator" data-topic="SubsetOperator" data-id="classname"><a href='../../CohortGenerator/html/SubsetOperator.html#method-SubsetOperator-classname'><code>CohortGenerator::SubsetOperator$classname()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CohortGenerator" data-topic="SubsetOperator" data-id="getQueryBuilder"><a href='../../CohortGenerator/html/SubsetOperator.html#method-SubsetOperator-getQueryBuilder'><code>CohortGenerator::SubsetOperator$getQueryBuilder()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CohortGenerator" data-topic="SubsetOperator" data-id="initialize"><a href='../../CohortGenerator/html/SubsetOperator.html#method-SubsetOperator-initialize'><code>CohortGenerator::SubsetOperator$initialize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CohortGenerator" data-topic="SubsetOperator" data-id="publicFields"><a href='../../CohortGenerator/html/SubsetOperator.html#method-SubsetOperator-publicFields'><code>CohortGenerator::SubsetOperator$publicFields()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-DemographicSubsetOperator-toList"></a>



<h4>Method <code>toList()</code></h4>

<p>List representation of object
Map gender concepts to names
</p>


<h5>Usage</h5>

<div class="r"><pre>DemographicSubsetOperator$toList()</pre></div>


<hr>
<a id="method-DemographicSubsetOperator-mapGenderConceptsToNames"></a>



<h4>Method <code>mapGenderConceptsToNames()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>DemographicSubsetOperator$mapGenderConceptsToNames(
  mapping = list(`8507` = "males", `8532` = "females", `0` = "unknown gender")
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>mapping</code></dt><dd><p>optional list of mappings for concept id to nouns</p>
</dd>
</dl>

</div>


<hr>
<a id="method-DemographicSubsetOperator-getAutoGeneratedName"></a>



<h4>Method <code>getAutoGeneratedName()</code></h4>

<p>name generated from subset operation properties
</p>


<h5>Usage</h5>

<div class="r"><pre>DemographicSubsetOperator$getAutoGeneratedName()</pre></div>



<h5>Returns</h5>

<p>character
</p>


<hr>
<a id="method-DemographicSubsetOperator-toJSON"></a>



<h4>Method <code>toJSON()</code></h4>

<p>json serialized representation of object
</p>


<h5>Usage</h5>

<div class="r"><pre>DemographicSubsetOperator$toJSON()</pre></div>


<hr>
<a id="method-DemographicSubsetOperator-isEqualTo"></a>



<h4>Method <code>isEqualTo()</code></h4>

<p>Compare Subset to another
</p>


<h5>Usage</h5>

<div class="r"><pre>DemographicSubsetOperator$isEqualTo(criteria)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>criteria</code></dt><dd><p>DemographicSubsetOperator instance</p>
</dd>
</dl>

</div>


<hr>
<a id="method-DemographicSubsetOperator-getGender"></a>



<h4>Method <code>getGender()</code></h4>

<p>Gender getter - used when constructing SQL to default
NULL to an empty string
</p>


<h5>Usage</h5>

<div class="r"><pre>DemographicSubsetOperator$getGender()</pre></div>


<hr>
<a id="method-DemographicSubsetOperator-getRace"></a>



<h4>Method <code>getRace()</code></h4>

<p>Race getter - used when constructing SQL to default
NULL to an empty string
</p>


<h5>Usage</h5>

<div class="r"><pre>DemographicSubsetOperator$getRace()</pre></div>


<hr>
<a id="method-DemographicSubsetOperator-getEthnicity"></a>



<h4>Method <code>getEthnicity()</code></h4>

<p>Ethnicity getter - used when constructing SQL to default
NULL to an empty string
</p>


<h5>Usage</h5>

<div class="r"><pre>DemographicSubsetOperator$getEthnicity()</pre></div>


<hr>
<a id="method-DemographicSubsetOperator-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>DemographicSubsetOperator$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='dropCohortStatsTables'>Drop cohort statistics tables</h2><span id='topic+dropCohortStatsTables'></span>

<h3>Description</h3>

<p>This function drops the cohort statistics tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dropCohortStatsTables(
  connectionDetails = NULL,
  connection = NULL,
  cohortDatabaseSchema,
  cohortTableNames = getCohortTableNames(),
  dropCohortTable = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dropCohortStatsTables_+3A_connectiondetails">connectionDetails</code></td>
<td>
<p>An object of type <code>connectionDetails</code> as created using the
<code><a href="DatabaseConnector.html#topic+createConnectionDetails">createConnectionDetails</a></code> function in the
DatabaseConnector package. Can be left NULL if <code>connection</code> is
provided.</p>
</td></tr>
<tr><td><code id="dropCohortStatsTables_+3A_connection">connection</code></td>
<td>
<p>An object of type <code>connection</code> as created using the
<code><a href="DatabaseConnector.html#topic+connect">connect</a></code> function in the
DatabaseConnector package. Can be left NULL if <code>connectionDetails</code>
is provided, in which case a new connection will be opened at the start
of the function, and closed when the function finishes.</p>
</td></tr>
<tr><td><code id="dropCohortStatsTables_+3A_cohortdatabaseschema">cohortDatabaseSchema</code></td>
<td>
<p>Schema name where your cohort tables reside. Note that for SQL Server,
this should include both the database and schema name, for example
'scratch.dbo'.</p>
</td></tr>
<tr><td><code id="dropCohortStatsTables_+3A_cohorttablenames">cohortTableNames</code></td>
<td>
<p>The names of the cohort tables. See <code><a href="#topic+getCohortTableNames">getCohortTableNames</a></code>
for more details.</p>
</td></tr>
<tr><td><code id="dropCohortStatsTables_+3A_dropcohorttable">dropCohortTable</code></td>
<td>
<p>Optionally drop cohort table in addition to stats tables (defaults to FALSE)</p>
</td></tr>
</table>

<hr>
<h2 id='exportCohortStatsTables'>Export the cohort statistics tables to the file system</h2><span id='topic+exportCohortStatsTables'></span>

<h3>Description</h3>

<p>This function retrieves the data from the cohort statistics tables and
writes them to the inclusion statistics folder specified in the function
call. NOTE: inclusion rule names are handled in one of two ways:
</p>
<p>1. You can specify the cohortDefinitionSet parameter and the inclusion rule
names will be extracted from the data.frame.
2. You can insert the inclusion rule names into the database using the
insertInclusionRuleNames function of this package.
</p>
<p>The first approach is preferred as to avoid the warning emitted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exportCohortStatsTables(
  connectionDetails,
  connection = NULL,
  cohortDatabaseSchema,
  cohortTableNames = getCohortTableNames(),
  cohortStatisticsFolder,
  snakeCaseToCamelCase = TRUE,
  fileNamesInSnakeCase = FALSE,
  incremental = FALSE,
  databaseId = NULL,
  minCellCount = 5,
  cohortDefinitionSet = NULL,
  tablePrefix = ""
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exportCohortStatsTables_+3A_connectiondetails">connectionDetails</code></td>
<td>
<p>An object of type <code>connectionDetails</code> as created using the
<code><a href="DatabaseConnector.html#topic+createConnectionDetails">createConnectionDetails</a></code> function in the
DatabaseConnector package. Can be left NULL if <code>connection</code> is
provided.</p>
</td></tr>
<tr><td><code id="exportCohortStatsTables_+3A_connection">connection</code></td>
<td>
<p>An object of type <code>connection</code> as created using the
<code><a href="DatabaseConnector.html#topic+connect">connect</a></code> function in the
DatabaseConnector package. Can be left NULL if <code>connectionDetails</code>
is provided, in which case a new connection will be opened at the start
of the function, and closed when the function finishes.</p>
</td></tr>
<tr><td><code id="exportCohortStatsTables_+3A_cohortdatabaseschema">cohortDatabaseSchema</code></td>
<td>
<p>Schema name where your cohort tables reside. Note that for SQL Server,
this should include both the database and schema name, for example
'scratch.dbo'.</p>
</td></tr>
<tr><td><code id="exportCohortStatsTables_+3A_cohorttablenames">cohortTableNames</code></td>
<td>
<p>The names of the cohort tables. See <code><a href="#topic+getCohortTableNames">getCohortTableNames</a></code>
for more details.</p>
</td></tr>
<tr><td><code id="exportCohortStatsTables_+3A_cohortstatisticsfolder">cohortStatisticsFolder</code></td>
<td>
<p>The path to the folder where the cohort statistics folder
where the results will be written</p>
</td></tr>
<tr><td><code id="exportCohortStatsTables_+3A_snakecasetocamelcase">snakeCaseToCamelCase</code></td>
<td>
<p>Should column names in the exported files
convert from snake_case to camelCase? Default is FALSE</p>
</td></tr>
<tr><td><code id="exportCohortStatsTables_+3A_filenamesinsnakecase">fileNamesInSnakeCase</code></td>
<td>
<p>Should the exported files use snake_case? Default is FALSE</p>
</td></tr>
<tr><td><code id="exportCohortStatsTables_+3A_incremental">incremental</code></td>
<td>
<p>If <code>incremental = TRUE</code>, results are written to update values instead of
overwriting an existing results</p>
</td></tr>
<tr><td><code id="exportCohortStatsTables_+3A_databaseid">databaseId</code></td>
<td>
<p>Optional - when specified, the databaseId will be added
to the exported results</p>
</td></tr>
<tr><td><code id="exportCohortStatsTables_+3A_mincellcount">minCellCount</code></td>
<td>
<p>To preserve privacy: the minimum number of subjects contributing
to a count before it can be included in the results. If the
count is below this threshold, it will be set to '-minCellCount'.</p>
</td></tr>
<tr><td><code id="exportCohortStatsTables_+3A_cohortdefinitionset">cohortDefinitionSet</code></td>
<td>
<p>The <code>cohortDefinitionSet</code> argument must be a data frame with 
the following columns: </p>

<dl>
<dt>cohortId</dt><dd><p>The unique integer identifier of the cohort</p>
</dd> 
<dt>cohortName</dt><dd><p>The cohort's name</p>
</dd>
<dt>sql</dt><dd><p>The OHDSI-SQL used to generate the cohort</p>
</dd></dl>

<p>Optionally, this data frame may contain: </p>

<dl>
<dt>json</dt><dd><p>The Circe JSON representation of the cohort</p>
</dd></dl>
</td></tr>
<tr><td><code id="exportCohortStatsTables_+3A_tableprefix">tablePrefix</code></td>
<td>
<p>Optional - allows to append a prefix to the exported
file names.</p>
</td></tr>
</table>

<hr>
<h2 id='generateCohortSet'>Generate a set of cohorts</h2><span id='topic+generateCohortSet'></span>

<h3>Description</h3>

<p>This function generates a set of cohorts in the cohort table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateCohortSet(
  connectionDetails = NULL,
  connection = NULL,
  cdmDatabaseSchema,
  tempEmulationSchema = getOption("sqlRenderTempEmulationSchema"),
  cohortDatabaseSchema = cdmDatabaseSchema,
  cohortTableNames = getCohortTableNames(),
  cohortDefinitionSet = NULL,
  stopOnError = TRUE,
  incremental = FALSE,
  incrementalFolder = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generateCohortSet_+3A_connectiondetails">connectionDetails</code></td>
<td>
<p>An object of type <code>connectionDetails</code> as created using the
<code><a href="DatabaseConnector.html#topic+createConnectionDetails">createConnectionDetails</a></code> function in the
DatabaseConnector package. Can be left NULL if <code>connection</code> is
provided.</p>
</td></tr>
<tr><td><code id="generateCohortSet_+3A_connection">connection</code></td>
<td>
<p>An object of type <code>connection</code> as created using the
<code><a href="DatabaseConnector.html#topic+connect">connect</a></code> function in the
DatabaseConnector package. Can be left NULL if <code>connectionDetails</code>
is provided, in which case a new connection will be opened at the start
of the function, and closed when the function finishes.</p>
</td></tr>
<tr><td><code id="generateCohortSet_+3A_cdmdatabaseschema">cdmDatabaseSchema</code></td>
<td>
<p>Schema name where your patient-level data in OMOP CDM format resides.
Note that for SQL Server, this should include both the database and
schema name, for example 'cdm_data.dbo'.</p>
</td></tr>
<tr><td><code id="generateCohortSet_+3A_tempemulationschema">tempEmulationSchema</code></td>
<td>
<p>Some database platforms like Oracle and Impala do not truly support
temp tables. To emulate temp tables, provide a schema with write
privileges where temp tables can be created.</p>
</td></tr>
<tr><td><code id="generateCohortSet_+3A_cohortdatabaseschema">cohortDatabaseSchema</code></td>
<td>
<p>Schema name where your cohort tables reside. Note that for SQL Server,
this should include both the database and schema name, for example
'scratch.dbo'.</p>
</td></tr>
<tr><td><code id="generateCohortSet_+3A_cohorttablenames">cohortTableNames</code></td>
<td>
<p>The names of the cohort tables. See <code><a href="#topic+getCohortTableNames">getCohortTableNames</a></code>
for more details.</p>
</td></tr>
<tr><td><code id="generateCohortSet_+3A_cohortdefinitionset">cohortDefinitionSet</code></td>
<td>
<p>The <code>cohortDefinitionSet</code> argument must be a data frame with 
the following columns: </p>

<dl>
<dt>cohortId</dt><dd><p>The unique integer identifier of the cohort</p>
</dd> 
<dt>cohortName</dt><dd><p>The cohort's name</p>
</dd>
<dt>sql</dt><dd><p>The OHDSI-SQL used to generate the cohort</p>
</dd></dl>

<p>Optionally, this data frame may contain: </p>

<dl>
<dt>json</dt><dd><p>The Circe JSON representation of the cohort</p>
</dd></dl>
</td></tr>
<tr><td><code id="generateCohortSet_+3A_stoponerror">stopOnError</code></td>
<td>
<p>If an error happens while generating one of the cohorts in the
cohortDefinitionSet, should we stop processing the other
cohorts? The default is TRUE; when set to FALSE, failures will
be identified in the return value from this function.</p>
</td></tr>
<tr><td><code id="generateCohortSet_+3A_incremental">incremental</code></td>
<td>
<p>Create only cohorts that haven't been created before?</p>
</td></tr>
<tr><td><code id="generateCohortSet_+3A_incrementalfolder">incrementalFolder</code></td>
<td>
<p>If <code>incremental = TRUE</code>, specify a folder where records are
kept of which definition has been executed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame consisting of the following columns:
</p>

<dl>
<dt>cohortId</dt><dd><p>The unique integer identifier of the cohort</p>
</dd>
<dt>cohortName</dt><dd><p>The cohort's name</p>
</dd>
<dt>generationStatus</dt><dd><p>The status of the generation task which may be one of the following:
</p>

<dl>
<dt>COMPLETE</dt><dd><p>The generation completed successfully</p>
</dd>
<dt>FAILED</dt><dd><p>The generation failed (see logs for details)</p>
</dd>
<dt>SKIPPED</dt><dd><p>If using incremental == 'TRUE', this status indicates
that the cohort's generation was skipped since it
was previously completed.</p>
</dd>
</dl>
</dd>
<dt>startTime</dt><dd><p>The start time of the cohort generation. If the generationStatus == 'SKIPPED', the startTime will be NA.</p>
</dd>
<dt>endTime</dt><dd><p>The end time of the cohort generation. If the generationStatus == 'FAILED', the endTime will be the time of the failure.
If the generationStatus == 'SKIPPED', endTime will be NA.</p>
</dd>
</dl>


<hr>
<h2 id='generateNegativeControlOutcomeCohorts'>Generate a set of negative control outcome cohorts</h2><span id='topic+generateNegativeControlOutcomeCohorts'></span>

<h3>Description</h3>

<p>This function generate a set of negative control outcome cohorts.
For more information please see [Chapter 12 - Population Level Estimation](https://ohdsi.github.io/TheBookOfOhdsi/PopulationLevelEstimation.html)
for more information how these cohorts are utilized in a study design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateNegativeControlOutcomeCohorts(
  connectionDetails = NULL,
  connection = NULL,
  cdmDatabaseSchema,
  tempEmulationSchema = getOption("sqlRenderTempEmulationSchema"),
  cohortDatabaseSchema = cdmDatabaseSchema,
  cohortTable = getCohortTableNames()$cohortTable,
  negativeControlOutcomeCohortSet,
  occurrenceType = "all",
  incremental = FALSE,
  incrementalFolder = NULL,
  detectOnDescendants = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generateNegativeControlOutcomeCohorts_+3A_connectiondetails">connectionDetails</code></td>
<td>
<p>An object of type <code>connectionDetails</code> as created using the
<code><a href="DatabaseConnector.html#topic+createConnectionDetails">createConnectionDetails</a></code> function in the
DatabaseConnector package. Can be left NULL if <code>connection</code> is
provided.</p>
</td></tr>
<tr><td><code id="generateNegativeControlOutcomeCohorts_+3A_connection">connection</code></td>
<td>
<p>An object of type <code>connection</code> as created using the
<code><a href="DatabaseConnector.html#topic+connect">connect</a></code> function in the
DatabaseConnector package. Can be left NULL if <code>connectionDetails</code>
is provided, in which case a new connection will be opened at the start
of the function, and closed when the function finishes.</p>
</td></tr>
<tr><td><code id="generateNegativeControlOutcomeCohorts_+3A_cdmdatabaseschema">cdmDatabaseSchema</code></td>
<td>
<p>Schema name where your patient-level data in OMOP CDM format resides.
Note that for SQL Server, this should include both the database and
schema name, for example 'cdm_data.dbo'.</p>
</td></tr>
<tr><td><code id="generateNegativeControlOutcomeCohorts_+3A_tempemulationschema">tempEmulationSchema</code></td>
<td>
<p>Some database platforms like Oracle and Impala do not truly support
temp tables. To emulate temp tables, provide a schema with write
privileges where temp tables can be created.</p>
</td></tr>
<tr><td><code id="generateNegativeControlOutcomeCohorts_+3A_cohortdatabaseschema">cohortDatabaseSchema</code></td>
<td>
<p>Schema name where your cohort tables reside. Note that for SQL Server,
this should include both the database and schema name, for example
'scratch.dbo'.</p>
</td></tr>
<tr><td><code id="generateNegativeControlOutcomeCohorts_+3A_cohorttable">cohortTable</code></td>
<td>
<p>Name of the cohort table.</p>
</td></tr>
<tr><td><code id="generateNegativeControlOutcomeCohorts_+3A_negativecontroloutcomecohortset">negativeControlOutcomeCohortSet</code></td>
<td>
<p>The <code>negativeControlOutcomeCohortSet</code> argument must be a data frame with 
the following columns: </p>

<dl>
<dt>cohortId</dt><dd><p>The unique integer identifier of the cohort</p>
</dd> 
<dt>cohortName</dt><dd><p>The cohort's name</p>
</dd>
<dt>outcomeConceptId</dt><dd><p>The concept_id in the condition domain to use for the negative control outcome.</p>
</dd></dl>
</td></tr>
<tr><td><code id="generateNegativeControlOutcomeCohorts_+3A_occurrencetype">occurrenceType</code></td>
<td>
<p>The occurrenceType will detect either: the first time an outcomeConceptId occurs
or all times the outcomeConceptId occurs for a person. Values accepted: 'all' or 'first'.</p>
</td></tr>
<tr><td><code id="generateNegativeControlOutcomeCohorts_+3A_incremental">incremental</code></td>
<td>
<p>Create only cohorts that haven't been created before?</p>
</td></tr>
<tr><td><code id="generateNegativeControlOutcomeCohorts_+3A_incrementalfolder">incrementalFolder</code></td>
<td>
<p>If <code>incremental = TRUE</code>, specify a folder where records are
kept of which definition has been executed.</p>
</td></tr>
<tr><td><code id="generateNegativeControlOutcomeCohorts_+3A_detectondescendants">detectOnDescendants</code></td>
<td>
<p>When set to TRUE, detectOnDescendants will use the vocabulary to find negative control
outcomes using the outcomeConceptId and all descendants via the concept_ancestor table.
When FALSE, only the exact outcomeConceptId will be used to detect the outcome.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns an empty negative control outcome cohort set data.frame
</p>

<hr>
<h2 id='getCohortCounts'>Count the cohort(s)</h2><span id='topic+getCohortCounts'></span>

<h3>Description</h3>

<p>Computes the subject and entry count per cohort. Note the cohortDefinitionSet
parameter is optional - if you specify the cohortDefinitionSet, the cohort
counts will be joined to the cohortDefinitionSet to include attributes
like the cohortName.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCohortCounts(
  connectionDetails = NULL,
  connection = NULL,
  cohortDatabaseSchema,
  cohortTable = "cohort",
  cohortIds = c(),
  cohortDefinitionSet = NULL,
  databaseId = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getCohortCounts_+3A_connectiondetails">connectionDetails</code></td>
<td>
<p>An object of type <code>connectionDetails</code> as created using the
<code><a href="DatabaseConnector.html#topic+createConnectionDetails">createConnectionDetails</a></code> function in the
DatabaseConnector package. Can be left NULL if <code>connection</code> is
provided.</p>
</td></tr>
<tr><td><code id="getCohortCounts_+3A_connection">connection</code></td>
<td>
<p>An object of type <code>connection</code> as created using the
<code><a href="DatabaseConnector.html#topic+connect">connect</a></code> function in the
DatabaseConnector package. Can be left NULL if <code>connectionDetails</code>
is provided, in which case a new connection will be opened at the start
of the function, and closed when the function finishes.</p>
</td></tr>
<tr><td><code id="getCohortCounts_+3A_cohortdatabaseschema">cohortDatabaseSchema</code></td>
<td>
<p>Schema name where your cohort table resides. Note that for SQL Server,
this should include both the database and schema name, for example
'scratch.dbo'.</p>
</td></tr>
<tr><td><code id="getCohortCounts_+3A_cohorttable">cohortTable</code></td>
<td>
<p>The name of the cohort table.</p>
</td></tr>
<tr><td><code id="getCohortCounts_+3A_cohortids">cohortIds</code></td>
<td>
<p>The cohort Id(s) used to reference the cohort in the cohort
table. If left empty and no 'cohortDefinitionSet' argument is
specified, all cohorts in the table will be included. If
you specify the 'cohortIds' AND 'cohortDefinitionSet', the counts will
reflect the 'cohortIds' from the 'cohortDefinitionSet'.</p>
</td></tr>
<tr><td><code id="getCohortCounts_+3A_cohortdefinitionset">cohortDefinitionSet</code></td>
<td>
<p>The <code>cohortDefinitionSet</code> argument must be a data frame with 
the following columns: </p>

<dl>
<dt>cohortId</dt><dd><p>The unique integer identifier of the cohort</p>
</dd> 
<dt>cohortName</dt><dd><p>The cohort's name</p>
</dd>
<dt>sql</dt><dd><p>The OHDSI-SQL used to generate the cohort</p>
</dd></dl>

<p>Optionally, this data frame may contain: </p>

<dl>
<dt>json</dt><dd><p>The Circe JSON representation of the cohort</p>
</dd></dl>
</td></tr>
<tr><td><code id="getCohortCounts_+3A_databaseid">databaseId</code></td>
<td>
<p>Optional - when specified, the databaseId will be added
to the exported results</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with cohort counts
</p>

<hr>
<h2 id='getCohortDefinitionSet'>Get a cohort definition set</h2><span id='topic+getCohortDefinitionSet'></span>

<h3>Description</h3>

<p>This function supports the legacy way of retrieving a cohort definition set
from the file system or in a package. This function supports the legacy way of
storing a cohort definition set in a package with a CSV file, JSON files,
and SQL files in the 'inst' folder.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCohortDefinitionSet(
  settingsFileName = "Cohorts.csv",
  jsonFolder = "cohorts",
  sqlFolder = "sql/sql_server",
  cohortFileNameFormat = "%s",
  cohortFileNameValue = c("cohortId"),
  subsetJsonFolder = "inst/cohort_subset_definitions/",
  packageName = NULL,
  warnOnMissingJson = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getCohortDefinitionSet_+3A_settingsfilename">settingsFileName</code></td>
<td>
<p>The name of the CSV file that will hold the cohort information
including the cohortId and cohortName</p>
</td></tr>
<tr><td><code id="getCohortDefinitionSet_+3A_jsonfolder">jsonFolder</code></td>
<td>
<p>The name of the folder that will hold the JSON representation
of the cohort if it is available in the cohortDefinitionSet</p>
</td></tr>
<tr><td><code id="getCohortDefinitionSet_+3A_sqlfolder">sqlFolder</code></td>
<td>
<p>The name of the folder that will hold the SQL representation
of the cohort.</p>
</td></tr>
<tr><td><code id="getCohortDefinitionSet_+3A_cohortfilenameformat">cohortFileNameFormat</code></td>
<td>
<p>Defines the format string  for naming the cohort
JSON and SQL files. The format string follows the
standard defined in the base sprintf function.</p>
</td></tr>
<tr><td><code id="getCohortDefinitionSet_+3A_cohortfilenamevalue">cohortFileNameValue</code></td>
<td>
<p>Defines the columns in the cohortDefinitionSet to use
in conjunction with the cohortFileNameFormat parameter.</p>
</td></tr>
<tr><td><code id="getCohortDefinitionSet_+3A_subsetjsonfolder">subsetJsonFolder</code></td>
<td>
<p>Defines the folder to store the subset JSON</p>
</td></tr>
<tr><td><code id="getCohortDefinitionSet_+3A_packagename">packageName</code></td>
<td>
<p>The name of the package containing the cohort definitions.</p>
</td></tr>
<tr><td><code id="getCohortDefinitionSet_+3A_warnonmissingjson">warnOnMissingJson</code></td>
<td>
<p>Provide a warning if a .JSON file is not found for a
cohort in the settings file</p>
</td></tr>
<tr><td><code id="getCohortDefinitionSet_+3A_verbose">verbose</code></td>
<td>
<p>When TRUE, extra logging messages are emitted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a cohort set data.frame
</p>

<hr>
<h2 id='getCohortInclusionRules'>Get Cohort Inclusion Rules from a cohort definition set</h2><span id='topic+getCohortInclusionRules'></span>

<h3>Description</h3>

<p>This function returns a data frame of the inclusion rules defined
in a cohort definition set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCohortInclusionRules(cohortDefinitionSet)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getCohortInclusionRules_+3A_cohortdefinitionset">cohortDefinitionSet</code></td>
<td>
<p>The <code>cohortDefinitionSet</code> argument must be a data frame with 
the following columns: </p>

<dl>
<dt>cohortId</dt><dd><p>The unique integer identifier of the cohort</p>
</dd> 
<dt>cohortName</dt><dd><p>The cohort's name</p>
</dd>
<dt>sql</dt><dd><p>The OHDSI-SQL used to generate the cohort</p>
</dd></dl>

<p>Optionally, this data frame may contain: </p>

<dl>
<dt>json</dt><dd><p>The Circe JSON representation of the cohort</p>
</dd></dl>
</td></tr>
</table>

<hr>
<h2 id='getCohortStats'>Get Cohort Inclusion Stats Table Data</h2><span id='topic+getCohortStats'></span>

<h3>Description</h3>

<p>This function returns a data frame of the data in the Cohort Inclusion Tables.
Results are organized in to a list with 5 different data frames:
</p>

<ul>
<li><p> cohortInclusionTable
</p>
</li>
<li><p> cohortInclusionResultTable
</p>
</li>
<li><p> cohortInclusionStatsTable
</p>
</li>
<li><p> cohortSummaryStatsTable
</p>
</li>
<li><p> cohortCensorStatsTable
</p>
</li></ul>

<p>These can be optionally specified with the <code>outputTables</code>.
See <code>exportCohortStatsTables</code> function for saving data to csv.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCohortStats(
  connectionDetails,
  connection = NULL,
  cohortDatabaseSchema,
  databaseId = NULL,
  snakeCaseToCamelCase = TRUE,
  outputTables = c("cohortInclusionTable", "cohortInclusionResultTable",
    "cohortInclusionStatsTable", "cohortInclusionStatsTable", "cohortSummaryStatsTable",
    "cohortCensorStatsTable"),
  cohortTableNames = getCohortTableNames()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getCohortStats_+3A_connectiondetails">connectionDetails</code></td>
<td>
<p>An object of type <code>connectionDetails</code> as created using the
<code><a href="DatabaseConnector.html#topic+createConnectionDetails">createConnectionDetails</a></code> function in the
DatabaseConnector package. Can be left NULL if <code>connection</code> is
provided.</p>
</td></tr>
<tr><td><code id="getCohortStats_+3A_connection">connection</code></td>
<td>
<p>An object of type <code>connection</code> as created using the
<code><a href="DatabaseConnector.html#topic+connect">connect</a></code> function in the
DatabaseConnector package. Can be left NULL if <code>connectionDetails</code>
is provided, in which case a new connection will be opened at the start
of the function, and closed when the function finishes.</p>
</td></tr>
<tr><td><code id="getCohortStats_+3A_cohortdatabaseschema">cohortDatabaseSchema</code></td>
<td>
<p>Schema name where your cohort tables reside. Note that for SQL Server,
this should include both the database and schema name, for example
'scratch.dbo'.</p>
</td></tr>
<tr><td><code id="getCohortStats_+3A_databaseid">databaseId</code></td>
<td>
<p>Optional - when specified, the databaseId will be added
to the exported results</p>
</td></tr>
<tr><td><code id="getCohortStats_+3A_snakecasetocamelcase">snakeCaseToCamelCase</code></td>
<td>
<p>Convert column names from snake case to camel case.</p>
</td></tr>
<tr><td><code id="getCohortStats_+3A_outputtables">outputTables</code></td>
<td>
<p>Character vector. One or more of &quot;cohortInclusionTable&quot;, &quot;cohortInclusionResultTable&quot;,
&quot;cohortInclusionStatsTable&quot;, &quot;cohortInclusionStatsTable&quot;, &quot;cohortSummaryStatsTable&quot;
or &quot;cohortCensorStatsTable&quot;. Output is limited to these tables. Cannot export, for,
example, the cohort table. Defaults to all stats tables.</p>
</td></tr>
<tr><td><code id="getCohortStats_+3A_cohorttablenames">cohortTableNames</code></td>
<td>
<p>The names of the cohort tables. See <code><a href="#topic+getCohortTableNames">getCohortTableNames</a></code>
for more details.</p>
</td></tr>
</table>

<hr>
<h2 id='getCohortTableNames'>Used to get a list of cohort table names to use when creating the cohort
tables</h2><span id='topic+getCohortTableNames'></span>

<h3>Description</h3>

<p>This function creates a list of table names used by <code><a href="#topic+createCohortTables">createCohortTables</a></code> to specify
the table names to create. Use this function to specify the names of the main cohort table
and cohort statistics tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCohortTableNames(
  cohortTable = "cohort",
  cohortSampleTable = cohortTable,
  cohortInclusionTable = paste0(cohortTable, "_inclusion"),
  cohortInclusionResultTable = paste0(cohortTable, "_inclusion_result"),
  cohortInclusionStatsTable = paste0(cohortTable, "_inclusion_stats"),
  cohortSummaryStatsTable = paste0(cohortTable, "_summary_stats"),
  cohortCensorStatsTable = paste0(cohortTable, "_censor_stats")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getCohortTableNames_+3A_cohorttable">cohortTable</code></td>
<td>
<p>Name of the cohort table.</p>
</td></tr>
<tr><td><code id="getCohortTableNames_+3A_cohortsampletable">cohortSampleTable</code></td>
<td>
<p>Name of the cohort table for sampled cohorts (defaults to the same as the cohort table).</p>
</td></tr>
<tr><td><code id="getCohortTableNames_+3A_cohortinclusiontable">cohortInclusionTable</code></td>
<td>
<p>Name of the inclusion table, one of the tables for storing
inclusion rule statistics.</p>
</td></tr>
<tr><td><code id="getCohortTableNames_+3A_cohortinclusionresulttable">cohortInclusionResultTable</code></td>
<td>
<p>Name of the inclusion result table, one of the tables for
storing inclusion rule statistics.</p>
</td></tr>
<tr><td><code id="getCohortTableNames_+3A_cohortinclusionstatstable">cohortInclusionStatsTable</code></td>
<td>
<p>Name of the inclusion stats table, one of the tables for storing
inclusion rule statistics.</p>
</td></tr>
<tr><td><code id="getCohortTableNames_+3A_cohortsummarystatstable">cohortSummaryStatsTable</code></td>
<td>
<p>Name of the summary stats table, one of the tables for storing
inclusion rule statistics.</p>
</td></tr>
<tr><td><code id="getCohortTableNames_+3A_cohortcensorstatstable">cohortCensorStatsTable</code></td>
<td>
<p>Name of the censor stats table, one of the tables for storing
inclusion rule statistics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the table names as specified in the parameters to this function.
</p>

<hr>
<h2 id='getDataMigrator'>Get database migrations instance</h2><span id='topic+getDataMigrator'></span>

<h3>Description</h3>

<p>Returns ResultModelManager DataMigrationsManager instance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDataMigrator(connectionDetails, databaseSchema, tablePrefix = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getDataMigrator_+3A_connectiondetails">connectionDetails</code></td>
<td>
<p>DatabaseConnector connection details object</p>
</td></tr>
<tr><td><code id="getDataMigrator_+3A_databaseschema">databaseSchema</code></td>
<td>
<p>String schema where database schema lives</p>
</td></tr>
<tr><td><code id="getDataMigrator_+3A_tableprefix">tablePrefix</code></td>
<td>
<p>(Optional) Use if a table prefix is used before table names (e.g. &quot;cg_&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Instance of ResultModelManager::DataMigrationManager that has interface for converting existing data models
</p>

<hr>
<h2 id='getRequiredTasks'>Get a list of tasks required when running in incremental mode</h2><span id='topic+getRequiredTasks'></span>

<h3>Description</h3>

<p>This function will attempt to check the <code>recordKeepingFile</code>
to determine if a list of operations have completed by comparing the
keys passed into the function with the checksum supplied
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRequiredTasks(..., checksum, recordKeepingFile)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getRequiredTasks_+3A_...">...</code></td>
<td>
<p>Parameter values used to identify the key
in the incremental record keeping file</p>
</td></tr>
<tr><td><code id="getRequiredTasks_+3A_checksum">checksum</code></td>
<td>
<p>The checksum representing the operation to check</p>
</td></tr>
<tr><td><code id="getRequiredTasks_+3A_recordkeepingfile">recordKeepingFile</code></td>
<td>
<p>A file path to a CSV file containing the record
keeping information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of outstanding tasks based on inspecting the full contents
of the record keeping file
</p>

<hr>
<h2 id='getResultsDataModelSpecifications'>Get specifications for CohortGenerator results data model</h2><span id='topic+getResultsDataModelSpecifications'></span>

<h3>Description</h3>

<p>Get specifications for CohortGenerator results data model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getResultsDataModelSpecifications()
</code></pre>


<h3>Value</h3>

<p>A tibble data frame object with specifications
</p>

<hr>
<h2 id='getSubsetDefinitions'>Get cohort subset definitions from a cohort definition set</h2><span id='topic+getSubsetDefinitions'></span>

<h3>Description</h3>

<p>Get the subset definitions (if any) applied to a cohort definition set.
Note that these subset definitions are a copy of those applied to the cohort set.
Modifying these definitions will not modify the base cohort set.
To apply a modification, reapply the subset definition to the cohort definition set data.frame with
<code>addCohortSubsetDefinition</code> with 'overwriteExisting = TRUE'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSubsetDefinitions(cohortDefinitionSet)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getSubsetDefinitions_+3A_cohortdefinitionset">cohortDefinitionSet</code></td>
<td>
<p>A valid cohortDefinitionSet</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of cohort subset definitions or empty list
</p>

<hr>
<h2 id='insertInclusionRuleNames'>Used to insert the inclusion rule names from a cohort definition set
when generating cohorts that include cohort statistics</h2><span id='topic+insertInclusionRuleNames'></span>

<h3>Description</h3>

<p>This function will take a cohortDefinitionSet that inclusions the Circe JSON
representation of each cohort, parse the InclusionRule property to obtain
the inclusion rule name and sequence number and insert the values into the
cohortInclusionTable. This function is only required when generating cohorts
that include cohort statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insertInclusionRuleNames(
  connectionDetails = NULL,
  connection = NULL,
  cohortDefinitionSet,
  cohortDatabaseSchema,
  cohortInclusionTable = getCohortTableNames()$cohortInclusionTable
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="insertInclusionRuleNames_+3A_connectiondetails">connectionDetails</code></td>
<td>
<p>An object of type <code>connectionDetails</code> as created using the
<code><a href="DatabaseConnector.html#topic+createConnectionDetails">createConnectionDetails</a></code> function in the
DatabaseConnector package. Can be left NULL if <code>connection</code> is
provided.</p>
</td></tr>
<tr><td><code id="insertInclusionRuleNames_+3A_connection">connection</code></td>
<td>
<p>An object of type <code>connection</code> as created using the
<code><a href="DatabaseConnector.html#topic+connect">connect</a></code> function in the
DatabaseConnector package. Can be left NULL if <code>connectionDetails</code>
is provided, in which case a new connection will be opened at the start
of the function, and closed when the function finishes.</p>
</td></tr>
<tr><td><code id="insertInclusionRuleNames_+3A_cohortdefinitionset">cohortDefinitionSet</code></td>
<td>
<p>The <code>cohortDefinitionSet</code> argument must be a data frame with 
the following columns: </p>

<dl>
<dt>cohortId</dt><dd><p>The unique integer identifier of the cohort</p>
</dd> 
<dt>cohortName</dt><dd><p>The cohort's name</p>
</dd>
<dt>sql</dt><dd><p>The OHDSI-SQL used to generate the cohort</p>
</dd></dl>

<p>Optionally, this data frame may contain: </p>

<dl>
<dt>json</dt><dd><p>The Circe JSON representation of the cohort</p>
</dd></dl>
</td></tr>
<tr><td><code id="insertInclusionRuleNames_+3A_cohortdatabaseschema">cohortDatabaseSchema</code></td>
<td>
<p>Schema name where your cohort tables reside. Note that for SQL Server,
this should include both the database and schema name, for example
'scratch.dbo'.</p>
</td></tr>
<tr><td><code id="insertInclusionRuleNames_+3A_cohortinclusiontable">cohortInclusionTable</code></td>
<td>
<p>Name of the inclusion table, one of the tables for storing
inclusion rule statistics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the inclusion rules by cohort and sequence ID
</p>

<hr>
<h2 id='isCamelCase'>Used to check if a string is in lower camel case</h2><span id='topic+isCamelCase'></span>

<h3>Description</h3>

<p>This function is used check if a string conforms to
the lower camel case format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isCamelCase(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isCamelCase_+3A_x">x</code></td>
<td>
<p>The string to evaluate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if the string is in lower camel case
</p>

<hr>
<h2 id='isCohortDefinitionSet'>Is the data.frame a cohort definition set?</h2><span id='topic+isCohortDefinitionSet'></span>

<h3>Description</h3>

<p>This function checks a data.frame to verify it holds the expected format
for a cohortDefinitionSet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isCohortDefinitionSet(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isCohortDefinitionSet_+3A_x">x</code></td>
<td>
<p>The data.frame to check</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns TRUE if the input is a cohortDefinitionSet or returns FALSE
with warnings on any violations
</p>

<hr>
<h2 id='isFormattedForDatabaseUpload'>Is the data.frame formatted for uploading to a database?</h2><span id='topic+isFormattedForDatabaseUpload'></span>

<h3>Description</h3>

<p>This function is used to check a data.frame to ensure all
column names are in snake case format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isFormattedForDatabaseUpload(x, warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isFormattedForDatabaseUpload_+3A_x">x</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="isFormattedForDatabaseUpload_+3A_warn">warn</code></td>
<td>
<p>When TRUE, display a warning of any columns are not in snake
case format</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns TRUE if all columns are snake case format. If warn == TRUE,
the function will emit a warning on the column names that are not in snake
case format.
</p>

<hr>
<h2 id='isSnakeCase'>Used to check if a string is in snake case</h2><span id='topic+isSnakeCase'></span>

<h3>Description</h3>

<p>This function is used check if a string conforms to
the snake case format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isSnakeCase(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isSnakeCase_+3A_x">x</code></td>
<td>
<p>The string to evaluate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if the string is in snake case
</p>

<hr>
<h2 id='isTaskRequired'>Is a task required when running in incremental mode</h2><span id='topic+isTaskRequired'></span>

<h3>Description</h3>

<p>This function will attempt to check the <code>recordKeepingFile</code>
to determine if an individual operation has completed by comparing the
keys passed into the function with the checksum supplied
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isTaskRequired(..., checksum, recordKeepingFile, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isTaskRequired_+3A_...">...</code></td>
<td>
<p>Parameter values used to identify the key
in the incremental record keeping file</p>
</td></tr>
<tr><td><code id="isTaskRequired_+3A_checksum">checksum</code></td>
<td>
<p>The checksum representing the operation to check</p>
</td></tr>
<tr><td><code id="isTaskRequired_+3A_recordkeepingfile">recordKeepingFile</code></td>
<td>
<p>A file path to a CSV file containing the record
keeping information.</p>
</td></tr>
<tr><td><code id="isTaskRequired_+3A_verbose">verbose</code></td>
<td>
<p>When TRUE, this function will output if a particular operation
has completed based on inspecting the recordKeepingFile.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns TRUE if the operation has completed according to the contents of
the record keeping file.
</p>

<hr>
<h2 id='LimitSubsetOperator'>Limit Subset Operator</h2><span id='topic+LimitSubsetOperator'></span>

<h3>Description</h3>

<p>operator to apply limiting subset operations (e.g. washout periods, calendar ranges or earliest entries)
</p>
<p>Get auto generated name
</p>


<h3>Super class</h3>

<p><code><a href="#topic+SubsetOperator">CohortGenerator::SubsetOperator</a></code> -&gt; <code>LimitSubsetOperator</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>priorTime</code></dt><dd><p>minimum washout time in days</p>
</dd>
<dt><code>followUpTime</code></dt><dd><p>minimum required follow up time in days</p>
</dd>
<dt><code>limitTo</code></dt><dd><p>character one of:
&quot;firstEver&quot; - only first entry in patient history
&quot;earliestRemaining&quot; - only first entry after washout set by priorTime
&quot;latestRemaining&quot; -  the latest remaining after washout set by followUpTime
&quot;lastEver&quot; - only last entry in patient history inside
</p>
<p>Note, when using firstEver and lastEver with follow up and washout, patients with events
outside this will be censored.</p>
</dd>
<dt><code>calendarStartDate</code></dt><dd><p>The calendar start date for limiting by date</p>
</dd>
<dt><code>calendarEndDate</code></dt><dd><p>The calendar end date for limiting by date</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-LimitSubsetOperator-getAutoGeneratedName"><code>LimitSubsetOperator$getAutoGeneratedName()</code></a>
</p>
</li>
<li> <p><a href="#method-LimitSubsetOperator-toList"><code>LimitSubsetOperator$toList()</code></a>
</p>
</li>
<li> <p><a href="#method-LimitSubsetOperator-clone"><code>LimitSubsetOperator$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="CohortGenerator" data-topic="SubsetOperator" data-id="classname"><a href='../../CohortGenerator/html/SubsetOperator.html#method-SubsetOperator-classname'><code>CohortGenerator::SubsetOperator$classname()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CohortGenerator" data-topic="SubsetOperator" data-id="getQueryBuilder"><a href='../../CohortGenerator/html/SubsetOperator.html#method-SubsetOperator-getQueryBuilder'><code>CohortGenerator::SubsetOperator$getQueryBuilder()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CohortGenerator" data-topic="SubsetOperator" data-id="initialize"><a href='../../CohortGenerator/html/SubsetOperator.html#method-SubsetOperator-initialize'><code>CohortGenerator::SubsetOperator$initialize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CohortGenerator" data-topic="SubsetOperator" data-id="isEqualTo"><a href='../../CohortGenerator/html/SubsetOperator.html#method-SubsetOperator-isEqualTo'><code>CohortGenerator::SubsetOperator$isEqualTo()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CohortGenerator" data-topic="SubsetOperator" data-id="publicFields"><a href='../../CohortGenerator/html/SubsetOperator.html#method-SubsetOperator-publicFields'><code>CohortGenerator::SubsetOperator$publicFields()</code></a></span></li>
<li><span class="pkg-link" data-pkg="CohortGenerator" data-topic="SubsetOperator" data-id="toJSON"><a href='../../CohortGenerator/html/SubsetOperator.html#method-SubsetOperator-toJSON'><code>CohortGenerator::SubsetOperator$toJSON()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-LimitSubsetOperator-getAutoGeneratedName"></a>



<h4>Method <code>getAutoGeneratedName()</code></h4>

<p>name generated from subset operation properties
</p>


<h5>Usage</h5>

<div class="r"><pre>LimitSubsetOperator$getAutoGeneratedName()</pre></div>



<h5>Returns</h5>

<p>character
To List
</p>


<hr>
<a id="method-LimitSubsetOperator-toList"></a>



<h4>Method <code>toList()</code></h4>

<p>List representation of object
</p>


<h5>Usage</h5>

<div class="r"><pre>LimitSubsetOperator$toList()</pre></div>


<hr>
<a id="method-LimitSubsetOperator-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>LimitSubsetOperator$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='migrateDataModel'>Migrate Data model</h2><span id='topic+migrateDataModel'></span>

<h3>Description</h3>

<p>Migrate data from current state to next state
</p>
<p>It is strongly advised that you have a backup of all data (either sqlite files, a backup database (in the case you
are using a postgres backend) or have kept the csv/zip files from your data generation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>migrateDataModel(connectionDetails, databaseSchema, tablePrefix = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="migrateDataModel_+3A_connectiondetails">connectionDetails</code></td>
<td>
<p>DatabaseConnector connection details object</p>
</td></tr>
<tr><td><code id="migrateDataModel_+3A_databaseschema">databaseSchema</code></td>
<td>
<p>String schema where database schema lives</p>
</td></tr>
<tr><td><code id="migrateDataModel_+3A_tableprefix">tablePrefix</code></td>
<td>
<p>(Optional) Use if a table prefix is used before table names (e.g. &quot;cg_&quot;)</p>
</td></tr>
</table>

<hr>
<h2 id='readCsv'>Used to read a .csv file</h2><span id='topic+readCsv'></span>

<h3>Description</h3>

<p>This function is used to centralize the function for reading
.csv files across the HADES ecosystem. This function will automatically
convert from snake_case in the file to camelCase in the data.frame returned
as is the standard described in:
https://ohdsi.github.io/Hades/codeStyle.html#Interfacing_between_R_and_SQL
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readCsv(file, warnOnCaseMismatch = TRUE, colTypes = readr::cols())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readCsv_+3A_file">file</code></td>
<td>
<p>The .csv file to read.</p>
</td></tr>
<tr><td><code id="readCsv_+3A_warnoncasemismatch">warnOnCaseMismatch</code></td>
<td>
<p>When TRUE, raise a warning if column headings
in the .csv are not in snake_case format</p>
</td></tr>
<tr><td><code id="readCsv_+3A_coltypes">colTypes</code></td>
<td>
<p>Corresponds to the 'col_types' in the 'readr::read_csv' function.
One of 'NULL', a [readr::cols()] specification, or
a string. See 'vignette(&quot;readr&quot;)' for more details.
</p>
<p>If 'NULL', all column types will be inferred from 'guess_max' rows of the
input, interspersed throughout the file. This is convenient (and fast),
but not robust. If the guessed types are wrong, you'll need to increase
'guess_max' or supply the correct types yourself.
</p>
<p>Column specifications created by [list()] or [cols()] must contain
one column specification for each column.
</p>
<p>Alternatively, you can use a compact string representation where each
character represents one column:
- c = character
- i = integer
- n = number
- d = double
- l = logical
- f = factor
- D = date
- T = date time
- t = time
- ? = guess
- _ or - = skip
</p>
<p>By default, reading a file without a column specification will print a
message showing what 'readr' guessed they were. To remove this message,
set 'show_col_types = FALSE' or set 'options(readr.show_col_types = FALSE)'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with the .csv contents
</p>

<hr>
<h2 id='recordTasksDone'>Record a task as complete</h2><span id='topic+recordTasksDone'></span>

<h3>Description</h3>

<p>This function will record a task as completed in the <code>recordKeepingFile</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recordTasksDone(..., checksum, recordKeepingFile, incremental = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recordTasksDone_+3A_...">...</code></td>
<td>
<p>Parameter values used to identify the key
in the incremental record keeping file</p>
</td></tr>
<tr><td><code id="recordTasksDone_+3A_checksum">checksum</code></td>
<td>
<p>The checksum representing the operation to check</p>
</td></tr>
<tr><td><code id="recordTasksDone_+3A_recordkeepingfile">recordKeepingFile</code></td>
<td>
<p>A file path to a CSV file containing the record
keeping information.</p>
</td></tr>
<tr><td><code id="recordTasksDone_+3A_incremental">incremental</code></td>
<td>
<p>When TRUE, this function will record tasks otherwise
it will return without attempting to perform any action</p>
</td></tr>
</table>

<hr>
<h2 id='runCohortGeneration'>Run a cohort generation and export results</h2><span id='topic+runCohortGeneration'></span>

<h3>Description</h3>

<p>Run a cohort generation and export results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runCohortGeneration(
  connectionDetails,
  cdmDatabaseSchema,
  tempEmulationSchema = getOption("sqlRenderTempEmulationSchema"),
  cohortDatabaseSchema = cdmDatabaseSchema,
  cohortTableNames = getCohortTableNames(),
  cohortDefinitionSet = NULL,
  negativeControlOutcomeCohortSet = NULL,
  occurrenceType = "all",
  detectOnDescendants = FALSE,
  stopOnError = TRUE,
  outputFolder,
  databaseId = 1,
  minCellCount = 5,
  incremental = FALSE,
  incrementalFolder = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="runCohortGeneration_+3A_connectiondetails">connectionDetails</code></td>
<td>
<p>An object of type <code>connectionDetails</code> as created using the
<code><a href="DatabaseConnector.html#topic+createConnectionDetails">createConnectionDetails</a></code> function in the
DatabaseConnector package.</p>
</td></tr>
<tr><td><code id="runCohortGeneration_+3A_cdmdatabaseschema">cdmDatabaseSchema</code></td>
<td>
<p>Schema name where your patient-level data in OMOP CDM format resides.
Note that for SQL Server, this should include both the database and
schema name, for example 'cdm_data.dbo'.</p>
</td></tr>
<tr><td><code id="runCohortGeneration_+3A_tempemulationschema">tempEmulationSchema</code></td>
<td>
<p>Some database platforms like Oracle and Impala do not truly support
temp tables. To emulate temp tables, provide a schema with write
privileges where temp tables can be created.</p>
</td></tr>
<tr><td><code id="runCohortGeneration_+3A_cohortdatabaseschema">cohortDatabaseSchema</code></td>
<td>
<p>Schema name where your cohort tables reside. Note that for SQL Server,
this should include both the database and schema name, for example
'scratch.dbo'.</p>
</td></tr>
<tr><td><code id="runCohortGeneration_+3A_cohorttablenames">cohortTableNames</code></td>
<td>
<p>The names of the cohort tables. See <code><a href="#topic+getCohortTableNames">getCohortTableNames</a></code>
for more details.</p>
</td></tr>
<tr><td><code id="runCohortGeneration_+3A_cohortdefinitionset">cohortDefinitionSet</code></td>
<td>
<p>The <code>cohortDefinitionSet</code> argument must be a data frame with 
the following columns: </p>

<dl>
<dt>cohortId</dt><dd><p>The unique integer identifier of the cohort</p>
</dd> 
<dt>cohortName</dt><dd><p>The cohort's name</p>
</dd>
<dt>sql</dt><dd><p>The OHDSI-SQL used to generate the cohort</p>
</dd></dl>

<p>Optionally, this data frame may contain: </p>

<dl>
<dt>json</dt><dd><p>The Circe JSON representation of the cohort</p>
</dd></dl>
</td></tr>
<tr><td><code id="runCohortGeneration_+3A_negativecontroloutcomecohortset">negativeControlOutcomeCohortSet</code></td>
<td>
<p>The <code>negativeControlOutcomeCohortSet</code> argument must be a data frame with 
the following columns: </p>

<dl>
<dt>cohortId</dt><dd><p>The unique integer identifier of the cohort</p>
</dd> 
<dt>cohortName</dt><dd><p>The cohort's name</p>
</dd>
<dt>outcomeConceptId</dt><dd><p>The concept_id in the condition domain to use for the negative control outcome.</p>
</dd></dl>
</td></tr>
<tr><td><code id="runCohortGeneration_+3A_occurrencetype">occurrenceType</code></td>
<td>
<p>For negative controls outcomes, the occurrenceType
will detect either: the first time an
outcomeConceptId occurs or all times the
outcomeConceptId occurs for a person. Values
accepted: 'all' or 'first'.</p>
</td></tr>
<tr><td><code id="runCohortGeneration_+3A_detectondescendants">detectOnDescendants</code></td>
<td>
<p>For negative controls outcomes, when set to TRUE,
detectOnDescendants will use the vocabulary to
find negative control outcomes using the
outcomeConceptId and all descendants via the
concept_ancestor table. When FALSE, only the exact
outcomeConceptId will be used to detect the
outcome.</p>
</td></tr>
<tr><td><code id="runCohortGeneration_+3A_stoponerror">stopOnError</code></td>
<td>
<p>If an error happens while generating one of the
cohorts in the cohortDefinitionSet, should we
stop processing the other cohorts? The default is
TRUE; when set to FALSE, failures will be
identified in the return value from this function.</p>
</td></tr>
<tr><td><code id="runCohortGeneration_+3A_outputfolder">outputFolder</code></td>
<td>
<p>Name of the folder where all the outputs will written to.</p>
</td></tr>
<tr><td><code id="runCohortGeneration_+3A_databaseid">databaseId</code></td>
<td>
<p>A unique ID for the database. This will be appended to
most tables.</p>
</td></tr>
<tr><td><code id="runCohortGeneration_+3A_mincellcount">minCellCount</code></td>
<td>
<p>To preserve privacy: the minimum number of subjects contributing
to a count before it can be included in the results. If the
count is below this threshold, it will be set to '-minCellCount'.</p>
</td></tr>
<tr><td><code id="runCohortGeneration_+3A_incremental">incremental</code></td>
<td>
<p>Create only cohorts that haven't been created before?</p>
</td></tr>
<tr><td><code id="runCohortGeneration_+3A_incrementalfolder">incrementalFolder</code></td>
<td>
<p>If <code>incremental = TRUE</code>, specify a folder where
records are kept of which definition has been
executed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Run a cohort generation for a set of cohorts and negative control outcomes.
This function will also export the results of the run to the 'outputFolder'.
</p>

<hr>
<h2 id='sampleCohortDefinitionSet'>Sample Cohort Definition Set</h2><span id='topic+sampleCohortDefinitionSet'></span>

<h3>Description</h3>

<p>Create 1 or more sample of size n of a cohort definition set
</p>
<p>Subsetted cohorts can be sampled, as with any other subset form.
However, subsetting a sampled cohort is not recommended and not currently supported at this time.
In the case where n &gt; cohort count the entire cohort is copied unmodified
</p>
<p>As different databases have different forms of randomness, the random selection is computed in
R, based on the count for each cohort. This is, therefore, db platform independent
</p>
<p>Note, this function assumes cohorts have already been generated.
</p>
<p>Lifecycle Note: This functionality is considered experimental and not intended for use inside analytic packages
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleCohortDefinitionSet(
  cohortDefinitionSet,
  cohortIds = cohortDefinitionSet$cohortId,
  connectionDetails = NULL,
  connection = NULL,
  tempEmulationSchema = getOption("sqlRenderTempEmulationSchema"),
  cohortDatabaseSchema,
  outputDatabaseSchema = cohortDatabaseSchema,
  cohortTableNames = getCohortTableNames(),
  n = NULL,
  sampleFraction = NULL,
  seed = 64374,
  seedArgs = NULL,
  identifierExpression = "cohortId * 1000 + seed",
  incremental = FALSE,
  incrementalFolder = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sampleCohortDefinitionSet_+3A_cohortdefinitionset">cohortDefinitionSet</code></td>
<td>
<p>The <code>cohortDefinitionSet</code> argument must be a data frame with 
the following columns: </p>

<dl>
<dt>cohortId</dt><dd><p>The unique integer identifier of the cohort</p>
</dd> 
<dt>cohortName</dt><dd><p>The cohort's name</p>
</dd>
<dt>sql</dt><dd><p>The OHDSI-SQL used to generate the cohort</p>
</dd></dl>

<p>Optionally, this data frame may contain: </p>

<dl>
<dt>json</dt><dd><p>The Circe JSON representation of the cohort</p>
</dd></dl>
</td></tr>
<tr><td><code id="sampleCohortDefinitionSet_+3A_cohortids">cohortIds</code></td>
<td>
<p>Optional subset of cohortIds to generate. By default this function will sample all cohorts</p>
</td></tr>
<tr><td><code id="sampleCohortDefinitionSet_+3A_connectiondetails">connectionDetails</code></td>
<td>
<p>An object of type <code>connectionDetails</code> as created using the
<code><a href="DatabaseConnector.html#topic+createConnectionDetails">createConnectionDetails</a></code> function in the
DatabaseConnector package. Can be left NULL if <code>connection</code> is
provided.</p>
</td></tr>
<tr><td><code id="sampleCohortDefinitionSet_+3A_connection">connection</code></td>
<td>
<p>An object of type <code>connection</code> as created using the
<code><a href="DatabaseConnector.html#topic+connect">connect</a></code> function in the
DatabaseConnector package. Can be left NULL if <code>connectionDetails</code>
is provided, in which case a new connection will be opened at the start
of the function, and closed when the function finishes.</p>
</td></tr>
<tr><td><code id="sampleCohortDefinitionSet_+3A_tempemulationschema">tempEmulationSchema</code></td>
<td>
<p>Some database platforms like Oracle and Impala do not truly support
temp tables. To emulate temp tables, provide a schema with write
privileges where temp tables can be created.</p>
</td></tr>
<tr><td><code id="sampleCohortDefinitionSet_+3A_cohortdatabaseschema">cohortDatabaseSchema</code></td>
<td>
<p>Schema name where your cohort tables reside. Note that for SQL Server,
this should include both the database and schema name, for example
'scratch.dbo'.</p>
</td></tr>
<tr><td><code id="sampleCohortDefinitionSet_+3A_outputdatabaseschema">outputDatabaseSchema</code></td>
<td>
<p>optional schema to output cohorts to (if different from cohortDatabaseSchema)</p>
</td></tr>
<tr><td><code id="sampleCohortDefinitionSet_+3A_cohorttablenames">cohortTableNames</code></td>
<td>
<p>The names of the cohort tables. See <code><a href="#topic+getCohortTableNames">getCohortTableNames</a></code>
for more details.</p>
</td></tr>
<tr><td><code id="sampleCohortDefinitionSet_+3A_n">n</code></td>
<td>
<p>Sample size. Ignored if sample fraction is set</p>
</td></tr>
<tr><td><code id="sampleCohortDefinitionSet_+3A_samplefraction">sampleFraction</code></td>
<td>
<p>Fraction of cohort to sample</p>
</td></tr>
<tr><td><code id="sampleCohortDefinitionSet_+3A_seed">seed</code></td>
<td>
<p>Vector of seeds to give to the R pseudorandom number generator</p>
</td></tr>
<tr><td><code id="sampleCohortDefinitionSet_+3A_seedargs">seedArgs</code></td>
<td>
<p>optional arguments to pass to set.seed</p>
</td></tr>
<tr><td><code id="sampleCohortDefinitionSet_+3A_identifierexpression">identifierExpression</code></td>
<td>
<p>Optional string R expression used to compute output cohort id. Can only use variables
cohortId and seed. Default is &quot;cohortId * 1000 + seed&quot;, which is substituted and evaluated</p>
</td></tr>
<tr><td><code id="sampleCohortDefinitionSet_+3A_incremental">incremental</code></td>
<td>
<p>Create only cohorts that haven't been created before?</p>
</td></tr>
<tr><td><code id="sampleCohortDefinitionSet_+3A_incrementalfolder">incrementalFolder</code></td>
<td>
<p>If <code>incremental = TRUE</code>, specify a folder where records are
kept of which definition has been executed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sampledCohortDefinitionSet - a data.frame like object that contains the resulting identifiers and modified names of cohorts
</p>

<hr>
<h2 id='saveCohortDefinitionSet'>Save the cohort definition set to the file system</h2><span id='topic+saveCohortDefinitionSet'></span>

<h3>Description</h3>

<p>This function saves a cohortDefinitionSet to the file system and provides
options for specifying where to write the individual elements: the settings
file will contain the cohort information as a CSV specified by the
settingsFileName, the cohort JSON is written to the jsonFolder and the SQL
is written to the sqlFolder. We also provide a way to specify the
json/sql file name format using the cohortFileNameFormat and
cohortFileNameValue parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveCohortDefinitionSet(
  cohortDefinitionSet,
  settingsFileName = "inst/Cohorts.csv",
  jsonFolder = "inst/cohorts",
  sqlFolder = "inst/sql/sql_server",
  cohortFileNameFormat = "%s",
  cohortFileNameValue = c("cohortId"),
  subsetJsonFolder = "inst/cohort_subset_definitions/",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="saveCohortDefinitionSet_+3A_cohortdefinitionset">cohortDefinitionSet</code></td>
<td>
<p>The <code>cohortDefinitionSet</code> argument must be a data frame with 
the following columns: </p>

<dl>
<dt>cohortId</dt><dd><p>The unique integer identifier of the cohort</p>
</dd> 
<dt>cohortName</dt><dd><p>The cohort's name</p>
</dd>
<dt>sql</dt><dd><p>The OHDSI-SQL used to generate the cohort</p>
</dd></dl>

<p>Optionally, this data frame may contain: </p>

<dl>
<dt>json</dt><dd><p>The Circe JSON representation of the cohort</p>
</dd></dl>
</td></tr>
<tr><td><code id="saveCohortDefinitionSet_+3A_settingsfilename">settingsFileName</code></td>
<td>
<p>The name of the CSV file that will hold the cohort information
including the cohortId and cohortName</p>
</td></tr>
<tr><td><code id="saveCohortDefinitionSet_+3A_jsonfolder">jsonFolder</code></td>
<td>
<p>The name of the folder that will hold the JSON representation
of the cohort if it is available in the cohortDefinitionSet</p>
</td></tr>
<tr><td><code id="saveCohortDefinitionSet_+3A_sqlfolder">sqlFolder</code></td>
<td>
<p>The name of the folder that will hold the SQL representation
of the cohort.</p>
</td></tr>
<tr><td><code id="saveCohortDefinitionSet_+3A_cohortfilenameformat">cohortFileNameFormat</code></td>
<td>
<p>Defines the format string  for naming the cohort
JSON and SQL files. The format string follows the
standard defined in the base sprintf function.</p>
</td></tr>
<tr><td><code id="saveCohortDefinitionSet_+3A_cohortfilenamevalue">cohortFileNameValue</code></td>
<td>
<p>Defines the columns in the cohortDefinitionSet to use
in conjunction with the cohortFileNameFormat parameter.</p>
</td></tr>
<tr><td><code id="saveCohortDefinitionSet_+3A_subsetjsonfolder">subsetJsonFolder</code></td>
<td>
<p>Defines the folder to store the subset JSON</p>
</td></tr>
<tr><td><code id="saveCohortDefinitionSet_+3A_verbose">verbose</code></td>
<td>
<p>When TRUE, logging messages are emitted to indicate export
progress.</p>
</td></tr>
</table>

<hr>
<h2 id='saveCohortSubsetDefinition'>Save cohort subset definitions to json</h2><span id='topic+saveCohortSubsetDefinition'></span>

<h3>Description</h3>

<p>This is generally used as part of saveCohortDefinitionSet
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveCohortSubsetDefinition(
  subsetDefinition,
  subsetJsonFolder = "inst/cohort_subset_definitions/"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="saveCohortSubsetDefinition_+3A_subsetdefinition">subsetDefinition</code></td>
<td>
<p>The subset definition object @seealso[CohortSubsetDefinition]</p>
</td></tr>
<tr><td><code id="saveCohortSubsetDefinition_+3A_subsetjsonfolder">subsetJsonFolder</code></td>
<td>
<p>Defines the folder to store the subset JSON</p>
</td></tr>
</table>

<hr>
<h2 id='saveIncremental'>Used in incremental mode to save values to a file</h2><span id='topic+saveIncremental'></span>

<h3>Description</h3>

<p>When running in incremental mode, we may need to update results in a CSV
file. This function will replace the <code>data</code> in <code>fileName</code> based
on the key parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveIncremental(data, fileName, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="saveIncremental_+3A_data">data</code></td>
<td>
<p>The data to record in the file</p>
</td></tr>
<tr><td><code id="saveIncremental_+3A_filename">fileName</code></td>
<td>
<p>A CSV holding results in the same structure as the data
parameter</p>
</td></tr>
<tr><td><code id="saveIncremental_+3A_...">...</code></td>
<td>
<p>Parameter values used to identify the key
in the results file</p>
</td></tr>
</table>

<hr>
<h2 id='SubsetCohortWindow'>Time Window For Cohort Subset Operator</h2><span id='topic+SubsetCohortWindow'></span>

<h3>Description</h3>

<p>Representation of a time window to use when subsetting a target cohort with a subset cohort
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>startDay</code></dt><dd><p>Integer</p>
</dd>
<dt><code>endDay</code></dt><dd><p>Integer</p>
</dd>
<dt><code>targetAnchor</code></dt><dd><p>Boolean</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SubsetCohortWindow-toList"><code>SubsetCohortWindow$toList()</code></a>
</p>
</li>
<li> <p><a href="#method-SubsetCohortWindow-toJSON"><code>SubsetCohortWindow$toJSON()</code></a>
</p>
</li>
<li> <p><a href="#method-SubsetCohortWindow-isEqualTo"><code>SubsetCohortWindow$isEqualTo()</code></a>
</p>
</li>
<li> <p><a href="#method-SubsetCohortWindow-clone"><code>SubsetCohortWindow$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-SubsetCohortWindow-toList"></a>



<h4>Method <code>toList()</code></h4>

<p>List representation of object
To JSON
</p>


<h5>Usage</h5>

<div class="r"><pre>SubsetCohortWindow$toList()</pre></div>


<hr>
<a id="method-SubsetCohortWindow-toJSON"></a>



<h4>Method <code>toJSON()</code></h4>

<p>json serialized representation of object
Is Equal to
</p>


<h5>Usage</h5>

<div class="r"><pre>SubsetCohortWindow$toJSON()</pre></div>


<hr>
<a id="method-SubsetCohortWindow-isEqualTo"></a>



<h4>Method <code>isEqualTo()</code></h4>

<p>Compare SubsetCohortWindow to another
</p>


<h5>Usage</h5>

<div class="r"><pre>SubsetCohortWindow$isEqualTo(criteria)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>criteria</code></dt><dd><p>SubsetCohortWindow instance</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SubsetCohortWindow-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SubsetCohortWindow$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='SubsetOperator'>Abstract base class for subsets.</h2><span id='topic+SubsetOperator'></span>

<h3>Description</h3>

<p>Abstract Base Class for subsets. Subsets should inherit from this and implement their own requirements.
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>name</code></dt><dd><p>name of subset operation - should describe what the operation does e.g. &quot;Males under the age of 18&quot;, &quot;Exposed to Celecoxib&quot;</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-SubsetOperator-new"><code>SubsetOperator$new()</code></a>
</p>
</li>
<li> <p><a href="#method-SubsetOperator-classname"><code>SubsetOperator$classname()</code></a>
</p>
</li>
<li> <p><a href="#method-SubsetOperator-getAutoGeneratedName"><code>SubsetOperator$getAutoGeneratedName()</code></a>
</p>
</li>
<li> <p><a href="#method-SubsetOperator-getQueryBuilder"><code>SubsetOperator$getQueryBuilder()</code></a>
</p>
</li>
<li> <p><a href="#method-SubsetOperator-publicFields"><code>SubsetOperator$publicFields()</code></a>
</p>
</li>
<li> <p><a href="#method-SubsetOperator-isEqualTo"><code>SubsetOperator$isEqualTo()</code></a>
</p>
</li>
<li> <p><a href="#method-SubsetOperator-toList"><code>SubsetOperator$toList()</code></a>
</p>
</li>
<li> <p><a href="#method-SubsetOperator-toJSON"><code>SubsetOperator$toJSON()</code></a>
</p>
</li>
<li> <p><a href="#method-SubsetOperator-clone"><code>SubsetOperator$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-SubsetOperator-new"></a>



<h4>Method <code>new()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>SubsetOperator$new(definition = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>definition</code></dt><dd><p>json character or list - definition of subset operator</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>instance of object
Class Name
</p>


<hr>
<a id="method-SubsetOperator-classname"></a>



<h4>Method <code>classname()</code></h4>

<p>Class name of object
Get auto generated name
</p>


<h5>Usage</h5>

<div class="r"><pre>SubsetOperator$classname()</pre></div>


<hr>
<a id="method-SubsetOperator-getAutoGeneratedName"></a>



<h4>Method <code>getAutoGeneratedName()</code></h4>

<p>Not intended to be used - should be implemented in subclasses
Return query builder instance
</p>


<h5>Usage</h5>

<div class="r"><pre>SubsetOperator$getAutoGeneratedName()</pre></div>


<hr>
<a id="method-SubsetOperator-getQueryBuilder"></a>



<h4>Method <code>getQueryBuilder()</code></h4>

<p>Return query builder instance
Public Fields
</p>


<h5>Usage</h5>

<div class="r"><pre>SubsetOperator$getQueryBuilder(id)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>- integer that should be unique in the sql (e.g. increment it by one for each subset operation in set)</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SubsetOperator-publicFields"></a>



<h4>Method <code>publicFields()</code></h4>

<p>Publicly settable fields of object
Is Equal to
</p>


<h5>Usage</h5>

<div class="r"><pre>SubsetOperator$publicFields()</pre></div>


<hr>
<a id="method-SubsetOperator-isEqualTo"></a>



<h4>Method <code>isEqualTo()</code></h4>

<p>Compare Subsets - are they identical or not?
Checks all fields and settings
</p>


<h5>Usage</h5>

<div class="r"><pre>SubsetOperator$isEqualTo(subsetOperatorB)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>subsetOperatorB</code></dt><dd><p>A subset to test equivalence to
To list</p>
</dd>
</dl>

</div>


<hr>
<a id="method-SubsetOperator-toList"></a>



<h4>Method <code>toList()</code></h4>

<p>convert to List representation
To Json
</p>


<h5>Usage</h5>

<div class="r"><pre>SubsetOperator$toList()</pre></div>


<hr>
<a id="method-SubsetOperator-toJSON"></a>



<h4>Method <code>toJSON()</code></h4>

<p>convert to json serialized representation
</p>


<h5>Usage</h5>

<div class="r"><pre>SubsetOperator$toJSON()</pre></div>



<h5>Returns</h5>

<p>list representation of object as json character
</p>


<hr>
<a id="method-SubsetOperator-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>SubsetOperator$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>CohortSubsetOperator
</p>
<p>DemographicSubsetOperator
</p>
<p>LimitSubsetOperator
</p>

<hr>
<h2 id='uploadResults'>Upload results to the database server.</h2><span id='topic+uploadResults'></span>

<h3>Description</h3>

<p>Requires the results data model tables have been created using the <code><a href="#topic+createResultsDataModel">createResultsDataModel</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uploadResults(
  connectionDetails,
  schema,
  resultsFolder,
  forceOverWriteOfSpecifications = FALSE,
  purgeSiteDataBeforeUploading = TRUE,
  tablePrefix = "",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uploadResults_+3A_connectiondetails">connectionDetails</code></td>
<td>
<p>An object of type <code>connectionDetails</code> as created using the
<code><a href="DatabaseConnector.html#topic+createConnectionDetails">createConnectionDetails</a></code> function in the
DatabaseConnector package.</p>
</td></tr>
<tr><td><code id="uploadResults_+3A_schema">schema</code></td>
<td>
<p>The schema on the server where the tables have been created.</p>
</td></tr>
<tr><td><code id="uploadResults_+3A_resultsfolder">resultsFolder</code></td>
<td>
<p>The folder holding the results in .csv files</p>
</td></tr>
<tr><td><code id="uploadResults_+3A_forceoverwriteofspecifications">forceOverWriteOfSpecifications</code></td>
<td>
<p>If TRUE, specifications of the phenotypes, cohort definitions, and analysis
will be overwritten if they already exist on the database. Only use this if these specifications
have changed since the last upload.</p>
</td></tr>
<tr><td><code id="uploadResults_+3A_purgesitedatabeforeuploading">purgeSiteDataBeforeUploading</code></td>
<td>
<p>If TRUE, before inserting data for a specific databaseId all the data for
that site will be dropped. This assumes the resultsFolder file contains the full data for that
data site.</p>
</td></tr>
<tr><td><code id="uploadResults_+3A_tableprefix">tablePrefix</code></td>
<td>
<p>(Optional)  string to insert before table names for database table names</p>
</td></tr>
<tr><td><code id="uploadResults_+3A_...">...</code></td>
<td>
<p>See ResultModelManager::uploadResults</p>
</td></tr>
</table>

<hr>
<h2 id='writeCsv'>Used to write a .csv file</h2><span id='topic+writeCsv'></span>

<h3>Description</h3>

<p>This function is used to centralize the function for writing
.csv files across the HADES ecosystem. This function will automatically
convert from camelCase in the data.frame to snake_case column names
in the resulting .csv file as is the standard
described in:
https://ohdsi.github.io/Hades/codeStyle.html#Interfacing_between_R_and_SQL
</p>
<p>This function may also raise warnings if the data is stored in a format
that will not work with the HADES standard for uploading to a results database.
Specifically file names should be in snake_case format, all column headings
are in snake_case format and where possible the file name should not be plural.
See <code>isFormattedForDatabaseUpload</code> for a helper function to check a
data.frame for rules on the column names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeCsv(
  x,
  file,
  append = FALSE,
  warnOnCaseMismatch = TRUE,
  warnOnFileNameCaseMismatch = TRUE,
  warnOnUploadRuleViolations = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="writeCsv_+3A_x">x</code></td>
<td>
<p>A data frame or tibble to write to disk.</p>
</td></tr>
<tr><td><code id="writeCsv_+3A_file">file</code></td>
<td>
<p>The .csv file to write.</p>
</td></tr>
<tr><td><code id="writeCsv_+3A_append">append</code></td>
<td>
<p>When TRUE, append the values of x to an existing file.</p>
</td></tr>
<tr><td><code id="writeCsv_+3A_warnoncasemismatch">warnOnCaseMismatch</code></td>
<td>
<p>When TRUE, raise a warning if columns in the
data.frame are NOT in camelCase format.</p>
</td></tr>
<tr><td><code id="writeCsv_+3A_warnonfilenamecasemismatch">warnOnFileNameCaseMismatch</code></td>
<td>
<p>When TRUE, raise a warning if the file
name specified is not in snake_case format.</p>
</td></tr>
<tr><td><code id="writeCsv_+3A_warnonuploadruleviolations">warnOnUploadRuleViolations</code></td>
<td>
<p>When TRUE, this function will provide
warning messages that may indicate if the data is stored in a format in the
.csv that may cause problems when uploading to a database.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the input x invisibly.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
