<!DOCTYPE html><html><head><title>Help for package LMMstar</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {LMMstar}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#LMMstar-package'><p>LMMstar package: repeated measurement models for discrete times</p></a></li>
<li><a href='#abetaL'><p>Data From The Bland Altman Study (Long Format)</p></a></li>
<li><a href='#abetaW'><p>Data From The abeta Study (Wide Format)</p></a></li>
<li><a href='#add'><p>Add Columns to Output</p></a></li>
<li><a href='#anova.lmm'><p>Multivariate Tests For Linear Mixed Model</p></a></li>
<li><a href='#autoplot.lmm'><p>Graphical Display For Linear Mixed Models</p></a></li>
<li><a href='#autoplot.partialCor'><p>Graphical Display For Partial Correlation</p></a></li>
<li><a href='#autoplot.profile_lmm'><p>Graphical Display of Profile Likelihood</p></a></li>
<li><a href='#autoplot.residuals_lmm'><p>Graphical Display of the Residuals</p></a></li>
<li><a href='#autoplot.summarize'><p>Graphical Display of the Descriptive Statistics</p></a></li>
<li><a href='#autoplot.summarizeNA'><p>Graphical Display of Missing Data Pattern</p></a></li>
<li><a href='#autoplot.Wald_lmm'><p>Graphical Display For Linear Hypothesis Test</p></a></li>
<li><a href='#baselineAdjustment'><p>Perform Baseline Adjustment</p></a></li>
<li><a href='#blandAltmanL'><p>Data From The Bland Altman Study (Long Format)</p></a></li>
<li><a href='#blandAltmanW'><p>Data From The Bland Altman Study (Wide Format)</p></a></li>
<li><a href='#bloodpressureL'><p>Data From The Blood Pressure Study (Long Format)</p></a></li>
<li><a href='#calciumL'><p>Data From The Calcium Supplements Study (Long Format)</p></a></li>
<li><a href='#calciumW'><p>Data From The Calcium Supplements Study (Wide Format)</p></a></li>
<li><a href='#ckdL'><p>CKD long</p></a></li>
<li><a href='#ckdW'><p>CKD wide</p></a></li>
<li><a href='#coef.lmm'><p>Extract Coefficients From a Linear Mixed Model</p></a></li>
<li><a href='#coef.mlmm'><p>Extract Coefficients From a Linear Mixed Model</p></a></li>
<li><a href='#confint.lmm'><p>Statistical Inference for Linear Mixed Model</p></a></li>
<li><a href='#confint.mlmm'><p>Confidence Intervals for Multiple Linear Mixed Model.</p></a></li>
<li><a href='#confint.Wald_lmm'><p>Confidence Intervals for Multivariate Wald Tests</p></a></li>
<li><a href='#CS'><p>Compound Symmetry Structure</p></a></li>
<li><a href='#CUSTOM'><p>Custom Structure</p></a></li>
<li><a href='#df.residual.lmm'><p>Residuals Degrees of Freedom</p></a></li>
<li><a href='#effects.lmm'><p>Effects Derived For Linear Mixed Model</p></a></li>
<li><a href='#estfun.lmm'><p>Extract the Score Function for Multcomp</p></a></li>
<li><a href='#estimate.lmm'><p>Delta Method for Mixed Models</p></a></li>
<li><a href='#fitted.lmm'><p>Predicted Mean Value For Linear Mixed Model.</p></a></li>
<li><a href='#gastricbypassL'><p>Data From The Gastric Bypass Study (Long Format)</p></a></li>
<li><a href='#gastricbypassW'><p>Data From The Gastric Bypass Study (Wide Format)</p></a></li>
<li><a href='#ID'><p>identity Structure</p></a></li>
<li><a href='#iid.lmm'><p>Extract the Influence Function From a Linear Mixed Model</p></a></li>
<li><a href='#IND'><p>Independence Structure</p></a></li>
<li><a href='#information.lmm'><p>Extract The Information From a Linear Mixed Model</p></a></li>
<li><a href='#levels.lmm'><p>Contrasts and Reference Level</p></a></li>
<li><a href='#lmm'><p>Fit Linear Mixed Model</p></a></li>
<li><a href='#lmmCC'><p>Fit Linear Mixed Model on Complete Case data</p></a></li>
<li><a href='#LMMstar.options'><p>Global options for LMMstar package</p></a></li>
<li><a href='#logLik.lmm'><p>Extract The Log-Likelihood From a Linear Mixed Model</p></a></li>
<li><a href='#manifest.lmm'><p>Variables Involved in a Linear Mixed Model</p></a></li>
<li><a href='#mlmm'><p>Fit Multiple Linear Mixed Model</p></a></li>
<li><a href='#model.frame.lmm'><p>Extracting the Model Frame from a Linear Mixed Model</p></a></li>
<li><a href='#model.matrix.lmm'><p>Design Matrix for Linear Mixed Model</p></a></li>
<li><a href='#model.tables.lmm'><p>Statistical Inference for Linear Mixed Model</p></a></li>
<li><a href='#mt.test'><p>Multiple Student's t-Test</p></a></li>
<li><a href='#ncgsL'><p>Data From National Cooperative Gallstone Study (Long Format)</p></a></li>
<li><a href='#ncgsW'><p>Data From National Cooperative Gallstone Study (Wide Format)</p></a></li>
<li><a href='#nobs.lmm'><p>Number of Observations from a Linear Mixed Model</p></a></li>
<li><a href='#partialCor'><p>Partial Correlation</p></a></li>
<li><a href='#potassiumRepeatedL'><p>Data From The Potassium Intake Study (Long Format with intermediate measurements)</p></a></li>
<li><a href='#potassiumSingleL'><p>Data From The Potassium Intake Study (Long Format)</p></a></li>
<li><a href='#potassiumSingleW'><p>Data From The Potassium Intake Study (Wide Format)</p></a></li>
<li><a href='#predict.lmm'><p>Predicted Mean Value With Uncertainty For Linear Mixed Model</p></a></li>
<li><a href='#profile.lmm'><p>Evaluate Contour of the Log-Likelihood</p></a></li>
<li><a href='#proportion'><p>Proportion of Significant Findings</p></a></li>
<li><a href='#ranef.lmm'><p>Estimate Random Effect From a Linear Mixed Model</p></a></li>
<li><a href='#rbind.Wald_lmm'><p>Linear Hypothesis Testing Across Linear Mixed Models</p></a></li>
<li><a href='#RE'><p>Random Effect Structure</p></a></li>
<li><a href='#remove'><p>Remove Columns from Output</p></a></li>
<li><a href='#resample'><p>Inference via Resampling for Linear Mixed Model</p></a></li>
<li><a href='#residuals'><p>Extract The Residuals From a Linear Mixed Model</p></a></li>
<li><a href='#restaureNA'><p>Restaure NA</p></a></li>
<li><a href='#sampleRem'><p>Sample Longuitudinal Data</p></a></li>
<li><a href='#scatterplot'><p>Scatterplot for Continuous Variables</p></a></li>
<li><a href='#schoolL'><p>Simulated Data with 3-level struture (Long Format)</p></a></li>
<li><a href='#score.lmm'><p>Extract The Score From a Linear Mixed Model</p></a></li>
<li><a href='#sigma.lmm'><p>Extract The Residuals Variance-Covariance Matrix From a Linear Mixed Model</p></a></li>
<li><a href='#summarize'><p>Compute summary statistics</p></a></li>
<li><a href='#summarizeNA'><p>Summarize missing data patterns</p></a></li>
<li><a href='#summary.lmm'><p>Summary Output for a Linear Mixed Model</p></a></li>
<li><a href='#summary.mlmm'><p>Summary of Multiple Linear Mixed Models</p></a></li>
<li><a href='#summary.partialCor'><p>Summary for partial correlation</p></a></li>
<li><a href='#summary.Wald_lmm'><p>Summary of Testing for a Linear Mixed Models</p></a></li>
<li><a href='#swabsL'><p>Data From The SWABS Study (Long Format)</p></a></li>
<li><a href='#swabsW'><p>Data From The SWABS Study (Wide Format)</p></a></li>
<li><a href='#terms.lmm'><p>Model Terms For Linear Mixed Models</p></a></li>
<li><a href='#TOEPLITZ'><p>Toeplitz Structure</p></a></li>
<li><a href='#UN'><p>Unstructured Structure</p></a></li>
<li><a href='#vasscoresL'><p>Data From The VAS Study (Long Format)</p></a></li>
<li><a href='#vasscoresW'><p>Data From The VAS Study (Wide Format)</p></a></li>
<li><a href='#vcov.lmm'><p>Extract The Variance-Covariance Matrix From a Linear Mixed Model</p></a></li>
<li><a href='#vitaminL'><p>Data From The Vitamin Study (Long Format)</p></a></li>
<li><a href='#vitaminW'><p>Data From The Vitamin Study (Wide Format)</p></a></li>
<li><a href='#weights.Wald_lmm'><p>Extract Weights Used to Pool Estimates</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Repeated Measurement Models for Discrete Times</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-05-12</td>
</tr>
<tr>
<td>Description:</td>
<td>Companion R package for the course "Statistical analysis of correlated and repeated measurements for health science researchers"
	     taught by the section of Biostatistics of the University of Copenhagen.
	     It implements linear mixed models where the model for the variance-covariance of the residuals is specified via patterns (compound symmetry, toeplitz, unstructured, ...).
	     Statistical inference for mean, variance, and correlation parameters is performed based on the observed information and a Satterthwaite approximation of the degrees of freedom.
	     Normalized residuals are provided to assess model misspecification.
	     Statistical inference can be performed for arbitrary linear or non-linear combination(s) of model coefficients.
	     Predictions can be computed conditional to covariates only or also to outcome values. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/bozenne/LMMstar">https://github.com/bozenne/LMMstar</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/bozenne/LMMstar/issues">https://github.com/bozenne/LMMstar/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>copula, doParallel, foreach, ggplot2, grid, lava, Matrix,
multcomp, nlme, numDeriv, parallel, rlang,</td>
</tr>
<tr>
<td>Suggests:</td>
<td>asht, data.table, ggh4x, ggpubr, lattice, mvtnorm, lme4,
lmerTest, mice, nlmeU, optimx, pbapply, psych, Publish, qqtest,
R.rsp, reshape2, rmcorr, scales, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Collate:</td>
<td>'0-onload.R' 'BuyseTest_discreteRoot.R' 'LMMstar-package.R'
'LMMstar.options.R' 'add.R' 'anova.R' 'autoplot.R'
'backtransform.R' 'baselineAdjustment.R' 'coef.R' 'confint.R'
'constrain.R' 'df.R' 'discreteRoot.R' 'doc-data.R' 'effects.R'
'estimate.R' 'findPatterns.R' 'fitted.R' 'formula.R' 'iid.R'
'information.R' 'levels.R' 'lmm.R' 'lmmCC.R' 'logLik.R'
'manifest.R' 'mlmm.R' 'model.frame.R' 'model.matrix.R'
'model.tables.R' 'moments.R' 'mt.test.R' 'multcomp.R'
'namePatterns.R' 'nobs.R' 'operator.R' 'partialCor.R' 'plot.R'
'precompute.R' 'predict.R' 'print.R' 'profile.R' 'proportion.R'
'ranef.R' 'rbind.R' 'reformat.R' 'remove.R' 'reparametrize.R'
'resample.R' 'residuals.R' 'restaureNA.R' 'sampleRem.R'
'scatterplot.R' 'score.R' 'sigma.R' 'structure-calc_Omega.R'
'structure-calc_d2Omega.R' 'structure-calc_dOmega.R'
'structure-initialization.R' 'structure-skeleton.R'
'structure-skeletonK.R' 'structure-skeletonRho.R'
'structure-skeletonSigma.R' 'structure-update.R' 'structure.R'
'summarize.R' 'summarizeNA.R' 'summary.R' 'terms.R' 'utils.R'
'vcov.R' 'weights.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-12 21:11:58 UTC; bozenne</td>
</tr>
<tr>
<td>Author:</td>
<td>Brice Ozenne <a href="https://orcid.org/0000-0001-9694-2956"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Julie Forman <a href="https://orcid.org/0000-0001-7368-0869"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Brice Ozenne &lt;brice.mh.ozenne@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-12 21:43:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='LMMstar-package'>LMMstar package: repeated measurement models for discrete times</h2><span id='topic+LMMstar'></span><span id='topic+LMMstar-package'></span>

<h3>Description</h3>

<p>Companion R package for the course &quot;Statistical analysis
of correlated and repeated measurements for health science
researchers&quot; taught by the section of Biostatistics of the University
of Copenhagen. It implements linear mixed models where the model for the variance-covariance of the residuals
is specified via patterns (compound symmetry, toeplitz, unstructured, ...). Statistical inference for mean, variance, and correlation parameters
is performed based on the observed information and a Satterthwaite approximation of the degrees of freedom.
Normalized residuals are provided to assess model misspecification.
Statistical inference can be performed for arbitrary linear or non-linear combination(s) of model coefficients.
Predictions can be computed conditional to covariates only or also to outcome values. <br /> <br />
</p>


<h3>Details</h3>

<p><strong>Notations</strong>: the linear mixed model estimated by <code><a href="#topic+lmm">lmm</a></code> is denoted:
</p>
<p style="text-align: center;"><code class="reqn"> \mathbf{Y}_{i} = \mathbf{X}_{i}\beta+\boldsymbol{\varepsilon}_i </code>
</p>

<p>where
</p>

<ul>
<li> <p><code class="reqn">\mathbf{Y}=(Y_1,\ldots,Y_m)</code>: vector of outcomes.
</p>
</li>
<li> <p><code class="reqn">\mathbf{X}=(X_1,\ldots,X_p)</code>: design matrix (extractor: <code>model.matrix.lmm</code>).
</p>
</li>
<li> <p><code class="reqn">\boldsymbol{\varepsilon}</code>: vector of residuals with 0-mean and variance <code class="reqn">\Omega_i</code> (extractor: <code><a href="#topic+residuals.lmm">residuals.lmm</a></code>).
</p>
</li>
<li> <p><code class="reqn">\beta</code>: estimated mean coefficients relative to <code class="reqn">X</code> (extractor: <code><a href="#topic+coef.lmm">coef.lmm</a></code>).
</p>
</li>
<li> <p><code class="reqn">\Omega</code>: the modeled variance-covariance of the residuals with diagonal elements <code class="reqn">\sigma^2_{j}</code>  (extractor: <code><a href="#topic+sigma.lmm">sigma.lmm</a></code>).
</p>
</li>
<li> <p><code class="reqn">i</code> indexes the cluster (level where replicates are assumed independent).
</p>
</li>
<li> <p><code class="reqn">j</code> indexes the repetitions, e.g. the variance of <code class="reqn">\varepsilon_{ij}</code> is <code class="reqn">\sigma^2_{ij}</code>.
</p>
</li></ul>

<p><strong>Covariance patterns</strong>: <code class="reqn">\Omega</code> can be parametrized as: </p>

<ul>
<li> <p><code><a href="#topic+ID">ID</a></code>: identity (no correlation, constant variance).
</p>
</li>
<li> <p><code><a href="#topic+IND">IND</a></code>: independent (no correlation, time-specific variance).
</p>
</li>
<li> <p><code><a href="#topic+CS">CS</a></code>: compound symmetry (constant correlation and variance). Can also be used to specify a nested random effect structure or a block specific correlation and variance.
</p>
</li>
<li> <p><code><a href="#topic+RE">RE</a></code>: random effects.
</p>
</li>
<li> <p><code><a href="#topic+TOEPLITZ">TOEPLITZ</a></code>: toeplitz (lag-specific correlation, time-specific variance).
</p>
</li>
<li> <p><code><a href="#topic+UN">UN</a></code>: unstructured (time-specific correlation, time-specific variance).
</p>
</li></ul>

<p>It possible to stratify each structure with respect to a categorical variable. <br /> <br />
</p>
<p><strong>Optimizer</strong>: the default optimizer, <code>"FS"</code>, implements a fisher scoring algorithm descent with back-tracking in case of decreasing or undefined log-likelihood.
It does not constrain <code class="reqn">\Omega</code> to be positive definite which may cause problem in small sample or complex models.
It is possible to use other optimizer inferfaced by <code>optimx::optimx</code>.
</p>
<p><strong>Keywords</strong>: documented methods/functions are classified according to the following keywords </p>

<ul>
<li><p> models: function fitting a statistical model based on a dataset (e.g. <code><a href="#topic+lmm">lmm</a></code>, <code><a href="#topic+lmmCC">lmmCC</a></code>, <code><a href="#topic+mlmm">mlmm</a></code>, <code><a href="#topic+mt.test">mt.test</a></code>, <code><a href="#topic+partialCor">partialCor</a></code>)
</p>
</li>
<li><p> htest: methods performing statistical inference based on an existing model (e.g. <code><a href="#topic+anova.lmm">anova.lmm</a></code>, <code><a href="#topic+estimate.lmm">estimate.lmm</a></code>, <code><a href="#topic+effects.lmm">effects.lmm</a></code>, <code><a href="#topic+profile.lmm">profile.lmm</a></code>, <code><a href="#topic+proportion">proportion</a></code>, <code><a href="#topic+rbind.Wald_lmm">rbind.Wald_lmm</a></code>, <code><a href="#topic+resample.lmm">resample.lmm</a></code>)
</p>
</li>
<li><p> methods: extractors (e.g. <code><a href="#topic+coef.lmm">coef.lmm</a></code>, <code><a href="#topic+confint.lmm">confint.lmm</a></code>, <code><a href="#topic+df.residual.lmm">df.residual.lmm</a></code>, <code><a href="#topic+fitted.lmm">fitted.lmm</a></code>, <code><a href="#topic+iid.lmm">iid.lmm</a></code>, <code><a href="#topic+information.lmm">information.lmm</a></code>, <code><a href="#topic+levels.lmm">levels.lmm</a></code>, <code><a href="#topic+logLik.lmm">logLik.lmm</a></code>, <code><a href="#topic+manifest.lmm">manifest.lmm</a></code>, <code><a href="#topic+model.frame.lmm">model.frame.lmm</a></code>, <code><a href="#topic+model.matrix.lmm">model.matrix.lmm</a></code>, <code><a href="#topic+model.tables.lmm">model.tables.lmm</a></code>, <code><a href="#topic+nobs.lmm">nobs.lmm</a></code>, <code><a href="#topic+predict.lmm">predict.lmm</a></code>, <code><a href="#topic+ranef.lmm">ranef.lmm</a></code>, <code><a href="#topic+residuals.lmm">residuals.lmm</a></code>, <code><a href="#topic+score.lmm">score.lmm</a></code>, <code><a href="#topic+sigma.lmm">sigma.lmm</a></code>, <code><a href="#topic+summary.lmm">summary.lmm</a></code>, <code><a href="#topic+vcov.lmm">vcov.lmm</a></code>, <code><a href="#topic+weights.Wald_lmm">weights.Wald_lmm</a></code>)
</p>
</li>
<li><p> utilities: function used to facilitate the user interface (e.g. <code><a href="#topic+add">add</a></code>, <code><a href="#topic+baselineAdjustment">baselineAdjustment</a></code>, <code><a href="#topic+LMMstar.options">LMMstar.options</a></code>, <code><a href="#topic+remove">remove</a></code>, <code><a href="#topic+scatterplot">scatterplot</a></code>, <code><a href="#topic+summarize">summarize</a></code>, <code><a href="#topic+summarizeNA">summarizeNA</a></code>)
</p>
</li>
<li><p> datasets: dataset stored in the package  (e.g. <code><a href="#topic+abetaW">abetaW</a></code>)
</p>
</li>
<li><p> hplot: graphical display (e.g. <code><a href="#topic+autoplot.lmm">autoplot.lmm</a></code> or <code><a href="#topic+plot.lmm">plot.lmm</a></code>)
</p>
</li>
<li><p> datagen: function for generating data sets (e.g. <code><a href="#topic+sampleRem">sampleRem</a></code>)
</p>
</li>
<li><p> multivariate: covariance patterns (e.g. <code><a href="#topic+ID">ID</a></code>, <code><a href="#topic+IND">IND</a></code>, <code><a href="#topic+CS">CS</a></code>, <code><a href="#topic+RE">RE</a></code>, <code><a href="#topic+TOEPLITZ">TOEPLITZ</a></code>, <code><a href="#topic+UN">UN</a></code>, <code><a href="#topic+CUSTOM">CUSTOM</a></code>)
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Brice Ozenne <a href="mailto:brice.mh.ozenne@gmail.com">brice.mh.ozenne@gmail.com</a> (<a href="https://orcid.org/0000-0001-9694-2956">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Julie Forman <a href="mailto:jufo@sund.ku.dk">jufo@sund.ku.dk</a> (<a href="https://orcid.org/0000-0001-7368-0869">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/bozenne/LMMstar">https://github.com/bozenne/LMMstar</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/bozenne/LMMstar/issues">https://github.com/bozenne/LMMstar/issues</a>
</p>
</li></ul>


<hr>
<h2 id='abetaL'>Data From The Bland Altman Study (Long Format)</h2><span id='topic+abetaL'></span>

<h3>Description</h3>

<p>Extract data from a longitudinal case control study including 87 patients newly diagnosed with bipolar disorder and 44 age and sex matched healthy controls.
Contains demographic data and lifestyle factors at baseline, as well as measures of psychosocial functioning at baseline and 1 year follow-up.
This dataset is in the long format (i.e. one line per measurement).
</p>

<ul>
<li> <p><code>id</code>: study participant.
</p>
</li>
<li> <p><code>sex</code>: male (M) or female (F).
</p>
</li>
<li> <p><code>age</code>: age in years.
</p>
</li>
<li> <p><code>group</code>: bipolar disorder (BD) or healthy control (HC).
</p>
</li>
<li> <p><code>episode</code>: whether the patient experience an affective episode during follow-up.
</p>
</li>
<li> <p><code>visit</code>: index of time at which pss, fast, and qol measurements where performed.
</p>
</li>
<li> <p><code>year</code>: time at which pss, fast, and qol measurements where performed.
</p>
</li>
<li> <p><code>pss</code>: perceived stress score.
</p>
</li>
<li> <p><code>fast</code>: functioning assessment short test.
</p>
</li>
<li> <p><code>qol</code>: WHO quality of life score.
</p>
</li>
<li> <p><code>educationyears</code>: years of education including basic school.
</p>
</li>
<li> <p><code>alcohol</code>: daily alcohol consumption.
</p>
</li>
<li> <p><code>missingreason</code>: reason of drop out or missed visit.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(abetaL)
</code></pre>


<h3>References</h3>

<p>Pech, Josefine, et al. The impact of a new affective episode on psychosocial functioning, quality of life and perceived stress in newly diagnosed patients with bipolar disorder: A prospective one-year case-control study.Journal of Affective Disorders 277 (2020): 486-494.
</p>

<hr>
<h2 id='abetaW'>Data From The abeta Study (Wide Format)</h2><span id='topic+abetaW'></span>

<h3>Description</h3>

<p>Extract data from a longitudinal case control study including 87 patients newly diagnosed with bipolar disorder and 44 age and sex matched healthy controls.
Contains demographic data and lifestyle factors at baseline, as well as measures of psychosocial functioning at baseline and 1 year follow-up.
This dataset is in the wide format (i.e. one line per participant).
</p>

<ul>
<li> <p><code>id</code>: study participant.
</p>
</li>
<li> <p><code>sex</code>: male (M) or female (F).
</p>
</li>
<li> <p><code>age</code>: age in years.
</p>
</li>
<li> <p><code>group</code>: bipolar disorder (BD) or healthy control (HC).
</p>
</li>
<li> <p><code>episode</code>: whether the patient experience an affective episode during follow-up.
</p>
</li>
<li> <p><code>fast0</code>,<code>fast1</code>: functioning assessment short test at baseline and follow-up.
</p>
</li>
<li> <p><code>qol0</code>,<code>qol1</code>: WHO quality of life score at baseline and follow-up.
</p>
</li>
<li> <p><code>pss0</code>,<code>pss1</code>: perceived stress score at baseline and follow-up.
</p>
</li>
<li> <p><code>educationyears</code>: years of education including basic school.
</p>
</li>
<li> <p><code>alcohol</code>: daily alcohol consumption.
</p>
</li>
<li> <p><code>missingreason</code>: reason of drop out or missed visit.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(abetaW)
</code></pre>


<h3>References</h3>

<p>Pech, Josefine, et al. &quot;The impact of a new affective episode on psychosocial functioning, quality of life and perceived stress in newly diagnosed patients with bipolar disorder: A prospective one-year case-control study.&quot;Journal of Affective Disorders 277 (2020): 486-494.
</p>

<hr>
<h2 id='add'>Add Columns to Output</h2><span id='topic+add'></span>

<h3>Description</h3>

<p>Auxiliary function that can be used when specifying the argument <code>columns</code> (e.g. calling <code>confint.lmm</code>) to add columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_+3A_...">...</code></td>
<td>
<p>[character vector] name of the columns to be added to the default output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(10)
dW &lt;- sampleRem(25, n.times = 1, format = "long")
e.lmm &lt;- lmm(Y~X1, data = dW)

confint(e.lmm, columns = add("statistic"))
</code></pre>

<hr>
<h2 id='anova.lmm'>Multivariate Tests For Linear Mixed Model</h2><span id='topic+anova.lmm'></span>

<h3>Description</h3>

<p>Simultaneous tests of linear combinations of the model paramaters using Wald tests or Likelihood Ratio Test (LRT).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmm'
anova(
  object,
  effects = NULL,
  robust = FALSE,
  multivariate = TRUE,
  rhs = NULL,
  df = !is.null(object$df),
  ci = TRUE,
  transform.sigma = NULL,
  transform.k = NULL,
  transform.rho = NULL,
  transform.names = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova.lmm_+3A_object">object</code></td>
<td>
<p>a <code>lmm</code> object. Only relevant for the anova function.</p>
</td></tr>
<tr><td><code id="anova.lmm_+3A_effects">effects</code></td>
<td>
<p>[character or numeric matrix] Should the Wald test be computed for all variables (<code>"all"</code>),
or only variables relative to the mean (<code>"mean"</code> or <code>"fixed"</code>),
or only variables relative to the variance structure (<code>"variance"</code>),
or only variables relative to the correlation structure (<code>"correlation"</code>).
or average counterfactual outcome with respect to the value of a covariate X at each repetition  (<code>"ACO_X"</code>),
or the contrast between average counterfactual outcome for any pair of value of a covariate X (<code>"ATE_X"</code>).
Can also be use to specify linear combinations of coefficients or a contrast matrix, similarly to the <code>linfct</code> argument of the <code>multcomp::glht</code> function.</p>
</td></tr>
<tr><td><code id="anova.lmm_+3A_robust">robust</code></td>
<td>
<p>[logical] Should robust standard errors (aka sandwich estimator) be output instead of the model-based standard errors.</p>
</td></tr>
<tr><td><code id="anova.lmm_+3A_multivariate">multivariate</code></td>
<td>
<p>[logical] Should all hypotheses be simultaneously tested using a multivariate Wald test?</p>
</td></tr>
<tr><td><code id="anova.lmm_+3A_rhs">rhs</code></td>
<td>
<p>[numeric vector] the right hand side of the hypothesis. Only used when the argument effects is a matrix.</p>
</td></tr>
<tr><td><code id="anova.lmm_+3A_df">df</code></td>
<td>
<p>[logical] Should a F-distribution be used to model the distribution of the Wald statistic. Otherwise a chi-squared distribution is used.</p>
</td></tr>
<tr><td><code id="anova.lmm_+3A_ci">ci</code></td>
<td>
<p>[logical] Should an estimate, standard error, confidence interval, and p-value be output for each hypothesis?</p>
</td></tr>
<tr><td><code id="anova.lmm_+3A_transform.sigma">transform.sigma</code>, <code id="anova.lmm_+3A_transform.k">transform.k</code>, <code id="anova.lmm_+3A_transform.rho">transform.rho</code>, <code id="anova.lmm_+3A_transform.names">transform.names</code></td>
<td>
<p>are passed to the <code>vcov</code> method. See details section in <code><a href="#topic+coef.lmm">coef.lmm</a></code>.</p>
</td></tr>
<tr><td><code id="anova.lmm_+3A_...">...</code></td>
<td>
<p>Not used. For compatibility with the generic method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default adjustment of confidence intervals and p-values for multiple comparisons is based on the distribution of the maximum-statistic.
This is refered to as a single-step Dunnett multiple testing procedures in table II of Dmitrienko et al. (2013).
It is performed using the multcomp package with the option <code>test = adjusted("single-step")</code> with equal degrees of freedom
or by simulation using a Student's t copula with unequal degrees of freedom (more in the note of the details section of <code><a href="#topic+confint.Wald_lmm">confint.Wald_lmm</a></code>).
</p>


<h3>Value</h3>

<p>A data.frame (LRT) or a list of containing the following elements (Wald):</p>

<ul>
<li> <p><code>multivariate</code>: data.frame containing the multivariate Wald test.
The column <code>df.num</code> refers to the degrees of freedom for the numerator (i.e. number of hypotheses)
wherease the column <code>df.denum</code> refers to the degrees of freedom for the denominator (i.e. Satterthwaite approximation).
</p>
</li>
<li> <p><code>univariate</code>: data.frame containing each univariate Wald test.
</p>
</li>
<li> <p><code>glht</code>: used internally to call functions from the multcomp package.
</p>
</li>
<li> <p><code>object</code>: list containing key information about the linear mixed model.
</p>
</li>
<li> <p><code>vcov</code>: variance-covariance matrix associated to each parameter of interest (i.e. hypothesis).
</p>
</li>
<li> <p><code>iid</code>: matrix containing the influence function relative to each parameter of interest (i.e. hypothesis).
</p>
</li>
<li> <p><code>args</code>: list containing argument values from the function call.
</p>
</li></ul>



<h3>References</h3>

<p>Dmitrienko, A. and D'Agostino, R., Sr (2013), Traditional multiplicity adjustment methods in clinical trials. Statist. Med., 32: 5172-5218. https://doi.org/10.1002/sim.5990.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.Wald_lmm">summary.Wald_lmm</a></code> or <code><a href="#topic+confint.Wald_lmm">confint.Wald_lmm</a></code> for a summary of the results. <br />
<code><a href="#topic+autoplot.Wald_lmm">autoplot.Wald_lmm</a></code> for a graphical display of the results. <br />
<code><a href="#topic+rbind.Wald_lmm">rbind.Wald_lmm</a></code> for combining result across models and adjust for multiple comparisons. <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### simulate data in the long format ####
set.seed(10)
dL &lt;- sampleRem(100, n.times = 3, format = "long")

#### fit Linear Mixed Model ####
eUN.lmm &lt;- lmm(Y ~ visit + X1 + X2 + X5,
               repetition = ~visit|id, structure = "UN", data = dL)

#### Multivariate Wald test ####
## F-tests
anova(eUN.lmm)
anova(eUN.lmm, effects = "all")
anova(eUN.lmm, robust = TRUE, df = FALSE)
summary(anova(eUN.lmm), method = "bonferroni")

## user defined F-test
summary(anova(eUN.lmm, effects = c("X1=0","X2+X5=10")))

## chi2-tests
anova(eUN.lmm, df = FALSE)

## with standard contrast
if(require(multcomp)){
amod &lt;- lmm(breaks ~ tension, data = warpbreaks)
e.amod &lt;- anova(amod, effect = mcp(tension = "Tukey"))
summary(e.amod)
}

#### Likelihood ratio test ####
eUN0.lmm &lt;- lmm(Y ~ X1 + X2, repetition = ~visit|id, structure = "UN", data = dL)
anova(eUN.lmm, eUN0.lmm) 

eCS.lmm &lt;- lmm(Y ~ X1 + X2 + X5, repetition = ~visit|id, structure = "CS", data = dL)
anova(eUN.lmm, eCS.lmm)
</code></pre>

<hr>
<h2 id='autoplot.lmm'>Graphical Display For Linear Mixed Models</h2><span id='topic+autoplot.lmm'></span><span id='topic+plot.lmm'></span>

<h3>Description</h3>

<p>Display fitted values or residual plot for the mean, variance, and correlation structure.
Can also display quantile-quantile plot relative to the normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmm'
autoplot(
  object,
  type = "fit",
  type.residual = NULL,
  obs.alpha = 0,
  obs.size = NULL,
  facet = NULL,
  facet_nrow = NULL,
  facet_ncol = NULL,
  scales = "fixed",
  labeller = "label_value",
  at = NULL,
  time.var = NULL,
  color = NULL,
  position = NULL,
  ci = TRUE,
  ci.alpha = NULL,
  ylim = NULL,
  mean.size = c(3, 1),
  size.text = 16,
  position.errorbar = "identity",
  ...
)

## S3 method for class 'lmm'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.lmm_+3A_object">object</code>, <code id="autoplot.lmm_+3A_x">x</code></td>
<td>
<p>a <code>lmm</code> object.</p>
</td></tr>
<tr><td><code id="autoplot.lmm_+3A_type">type</code></td>
<td>
<p>[character] the type of plot </p>

<ul>
<li> <p><code>"fit"</code>: fitted values over repetitions.
</p>
</li>
<li> <p><code>"qqplot"</code>: quantile quantile plot of the normalized residuals
</p>
</li>
<li> <p><code>"correlation"</code>: residual correlation over repetitions
</p>
</li>
<li> <p><code>"scatterplot"</code>: normalized residuals vs. fitted values (diagnostic for missing non-linear effects),
</p>
</li>
<li> <p><code>"scatterplot2"</code>: square root of the normalized residuals vs. fitted values (diagnostic for heteroschedasticity),
</p>
</li>
<li> <p><code>"partial"</code>: partial residual plot.
</p>
</li></ul>
</td></tr>
<tr><td><code id="autoplot.lmm_+3A_type.residual">type.residual</code></td>
<td>
<p>[character] the type of residual to be used. Not relevant for <code>type="fit"</code>.
By default, normalized residuals are used except when requesting a partial residual plot
where this argument specify the variable relative to which the partial residuals are computed (argument <code>variable</code> in <code><a href="#topic+residuals.lmm">residuals.lmm</a></code>).</p>
</td></tr>
<tr><td><code id="autoplot.lmm_+3A_obs.alpha">obs.alpha</code></td>
<td>
<p>[numeric, 0-1] When not NA, transparency parameter used to display the original data by cluster.</p>
</td></tr>
<tr><td><code id="autoplot.lmm_+3A_obs.size">obs.size</code></td>
<td>
<p>[numeric vector of length 2] size of the point and line for the original data.</p>
</td></tr>
<tr><td><code id="autoplot.lmm_+3A_facet">facet</code></td>
<td>
<p>[formula] split the plot into a matrix of panels defined by the variables in the formula.
Internally it calls <code>ggplot2::facet_wrap</code> or <code>ggplot2::facet_grid</code> depending on whether the formula contains a variable on the left hand side.</p>
</td></tr>
<tr><td><code id="autoplot.lmm_+3A_facet_nrow">facet_nrow</code></td>
<td>
<p>[integer] number of rows of panels in the graphical display.</p>
</td></tr>
<tr><td><code id="autoplot.lmm_+3A_facet_ncol">facet_ncol</code></td>
<td>
<p>[integer] number of columns of panels  in the graphical display.</p>
</td></tr>
<tr><td><code id="autoplot.lmm_+3A_scales">scales</code>, <code id="autoplot.lmm_+3A_labeller">labeller</code></td>
<td>
<p>[character] Passed to <code>ggplot2::facet_wrap</code>.</p>
</td></tr>
<tr><td><code id="autoplot.lmm_+3A_at">at</code></td>
<td>
<p>[data.frame] values for the covariates at which to evaluate the fitted values or partial residuals.</p>
</td></tr>
<tr><td><code id="autoplot.lmm_+3A_time.var">time.var</code></td>
<td>
<p>[character] x-axis variable for the plot.</p>
</td></tr>
<tr><td><code id="autoplot.lmm_+3A_color">color</code></td>
<td>
<p>[character] name of the variable in the dataset used to color the curve. No color is used when set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="autoplot.lmm_+3A_position">position</code></td>
<td>
<p>[character] relative position of the points when colored according to a variable.</p>
</td></tr>
<tr><td><code id="autoplot.lmm_+3A_ci">ci</code></td>
<td>
<p>[logical] should confidence intervals be displayed?</p>
</td></tr>
<tr><td><code id="autoplot.lmm_+3A_ci.alpha">ci.alpha</code></td>
<td>
<p>[numeric, 0-1] When not NA, transparency parameter used to display the confidence intervals.</p>
</td></tr>
<tr><td><code id="autoplot.lmm_+3A_ylim">ylim</code></td>
<td>
<p>[numeric vector of length 2] the lower and higher value of the vertical axis.</p>
</td></tr>
<tr><td><code id="autoplot.lmm_+3A_mean.size">mean.size</code></td>
<td>
<p>[numeric vector of length 2] size of the point and line for the mean trajectory.</p>
</td></tr>
<tr><td><code id="autoplot.lmm_+3A_size.text">size.text</code></td>
<td>
<p>[numeric, &gt;0] size of the font used to display text.</p>
</td></tr>
<tr><td><code id="autoplot.lmm_+3A_position.errorbar">position.errorbar</code></td>
<td>
<p>[character] relative position of the errorbars.</p>
</td></tr>
<tr><td><code id="autoplot.lmm_+3A_...">...</code></td>
<td>
<p>arguments passed to the <code>predict.lmm</code> or <code>autoplot.residual_lmm</code> functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements </p>

<ul>
<li> <p><code>data</code>: data used to create the graphical display.
</p>
</li>
<li> <p><code>plot</code>: ggplot object.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>plot(lmm)</code>: Graphical Display For Linear Mixed Models
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+plot.lmm">plot.lmm</a></code> for other graphical display (residual plots, partial residual plots).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require(ggplot2)){

#### simulate data in the long format ####
set.seed(10)
dL &lt;- sampleRem(100, n.times = 3, format = "long")
dL$X1 &lt;- as.factor(dL$X1)

#### fit Linear Mixed Model ####
eCS.lmm &lt;- lmm(Y ~ visit + X1 + X6,
               repetition = ~visit|id, structure = "CS", data = dL, df = FALSE)

#### model fit ####
plot(eCS.lmm, type = "fit", facet =~X1)
## customize display
gg &lt;- autoplot(eCS.lmm, type = "fit", facet =~X1)$plot
gg + coord_cartesian(ylim = c(0,6))
## restrict to specific covariate value
plot(eCS.lmm, type = "fit", at = data.frame(X6=1), color = "X1")

#### qqplot ####
plot(eCS.lmm, type = "qqplot")
plot(eCS.lmm, type = "qqplot", engine.qqplot = "qqtest")

#### residual correlation ####
plot(eCS.lmm, type = "correlation")

#### residual trend ####
plot(eCS.lmm, type = "scatterplot")

#### residual heteroschedasticity ####
plot(eCS.lmm, type = "scatterplot2")

#### partial residuals ####
plot(eCS.lmm, type = "partial", type.residual = "visit") 
plot(eCS.lmm, type = "partial", type.residual = c("(Intercept)","X1","visit"))
plot(eCS.lmm, type = "partial", type.residual = c("(Intercept)","X1","visit"),
facet = ~X1)
}
</code></pre>

<hr>
<h2 id='autoplot.partialCor'>Graphical Display For Partial Correlation</h2><span id='topic+autoplot.partialCor'></span><span id='topic+plot.partialCor'></span>

<h3>Description</h3>

<p>Extract and display the correlation modeled via the linear mixed model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'partialCor'
autoplot(
  object,
  size.text = 16,
  limits = c(-1, 1.00001),
  low = "blue",
  mid = "white",
  high = "red",
  midpoint = 0,
  ...
)

## S3 method for class 'partialCor'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.partialCor_+3A_object">object</code>, <code id="autoplot.partialCor_+3A_x">x</code></td>
<td>
<p>a <code>partialCor</code> object.</p>
</td></tr>
<tr><td><code id="autoplot.partialCor_+3A_size.text">size.text</code></td>
<td>
<p>[numeric, &gt;0] size of the font used to display text.</p>
</td></tr>
<tr><td><code id="autoplot.partialCor_+3A_limits">limits</code></td>
<td>
<p>[numeric vector of length 2] minimum and maximum value of the colorscale relative to the correlation.</p>
</td></tr>
<tr><td><code id="autoplot.partialCor_+3A_low">low</code>, <code id="autoplot.partialCor_+3A_mid">mid</code>, <code id="autoplot.partialCor_+3A_high">high</code></td>
<td>
<p>[character] color for the the colorscale relative to the correlation.</p>
</td></tr>
<tr><td><code id="autoplot.partialCor_+3A_midpoint">midpoint</code></td>
<td>
<p>[numeric] correlation value associated with the color defined by argument <code>mid</code>.</p>
</td></tr>
<tr><td><code id="autoplot.partialCor_+3A_...">...</code></td>
<td>
<p>Not used. For compatibility with the generic method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements </p>

<ul>
<li> <p><code>data</code>: data used to create the graphical display.
</p>
</li>
<li> <p><code>plot</code>: ggplot object.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>plot(partialCor)</code>: Graphical Display For Partial Correlation
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>if(require(ggplot2)){
data(gastricbypassL, package = "LMMstar")

e.pCor &lt;- partialCor(c(weight,glucagonAUC)~time, repetition = ~visit|id,
                     data = gastricbypassL)
plot(e.pCor)
}

</code></pre>

<hr>
<h2 id='autoplot.profile_lmm'>Graphical Display of Profile Likelihood</h2><span id='topic+autoplot.profile_lmm'></span><span id='topic+plot.profile_lmm'></span>

<h3>Description</h3>

<p>Graphical representation of the profile likelihood from a linear mixed model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'profile_lmm'
autoplot(
  object,
  type = "logLik",
  quadratic = TRUE,
  ci = FALSE,
  size = c(3, 2, 1, 1),
  linetype = c("dashed", "dashed", "dashed"),
  shape = 19,
  scales = "free",
  nrow = NULL,
  ncol = NULL,
  ...
)

## S3 method for class 'profile_lmm'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.profile_lmm_+3A_object">object</code>, <code id="autoplot.profile_lmm_+3A_x">x</code></td>
<td>
<p>an object of class <code>profile_lmm</code>, output of the <code>profile.lmm</code> function.</p>
</td></tr>
<tr><td><code id="autoplot.profile_lmm_+3A_type">type</code></td>
<td>
<p>[character] Should the log-likelihood (<code>"logLik"</code>) or the ratio to the maximum likelihood (<code>"ratio"</code>) be displayed?</p>
</td></tr>
<tr><td><code id="autoplot.profile_lmm_+3A_quadratic">quadratic</code></td>
<td>
<p>[logical] Should a quadratic approximation of the likelihood be displayed?</p>
</td></tr>
<tr><td><code id="autoplot.profile_lmm_+3A_ci">ci</code></td>
<td>
<p>[logical] Should a 95% confidence intervals obtained from the Wald test (vertical lines) and Likelihood ratio test (horizontal line) be displayed?</p>
</td></tr>
<tr><td><code id="autoplot.profile_lmm_+3A_size">size</code></td>
<td>
<p>[numeric vector of length 4] Size of the point for the MLE,
width of the line representing the likelihood,
width of the corresponding quadratic approximation,
and width of the line representing the confidence intervals.</p>
</td></tr>
<tr><td><code id="autoplot.profile_lmm_+3A_linetype">linetype</code></td>
<td>
<p>[integer vector of length 2] type of line used to represent the quadratic approximation of the likelihood
and the confidence intervals.</p>
</td></tr>
<tr><td><code id="autoplot.profile_lmm_+3A_shape">shape</code></td>
<td>
<p>[integer, &gt;0] type of point used to represent the MLE.</p>
</td></tr>
<tr><td><code id="autoplot.profile_lmm_+3A_scales">scales</code>, <code id="autoplot.profile_lmm_+3A_nrow">nrow</code>, <code id="autoplot.profile_lmm_+3A_ncol">ncol</code></td>
<td>
<p>argument passed to <code>ggplot2::facet_wrap</code>.</p>
</td></tr>
<tr><td><code id="autoplot.profile_lmm_+3A_...">...</code></td>
<td>
<p>Not used. For compatibility with the generic method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with three elements </p>

<ul>
<li> <p><code>data.fit</code>: data containing the quadratice approximation of the log-likelihood
</p>
</li>
<li> <p><code>data.ci</code>: data containing the confidence intervals.
</p>
</li>
<li> <p><code>plot</code>: ggplot object.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>plot(profile_lmm)</code>: Display Contour of the log-Likelihood
</p>
</li></ul>

<hr>
<h2 id='autoplot.residuals_lmm'>Graphical Display of the Residuals</h2><span id='topic+autoplot.residuals_lmm'></span><span id='topic+plot.residuals_lmm'></span>

<h3>Description</h3>

<p>Graphical representation of the residuals from a linear mixed model.
Require a long format (except for the correlation where both format are accepted) and having exported the dataset along with the residual (argument <code>keep.data</code> when calling <code>residuals.lmm</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'residuals_lmm'
autoplot(
  object,
  type = NULL,
  type.residual = NULL,
  time.var = NULL,
  facet = NULL,
  facet_nrow = NULL,
  facet_ncol = NULL,
  engine.qqplot = "ggplot2",
  add.smooth = TRUE,
  digits.cor = 2,
  size.text = 16,
  color = NULL,
  obs.size = NULL,
  mean.size = c(3, 1),
  ci.alpha = 0.25,
  position = NULL,
  scales = "fixed",
  labeller = "label_value",
  ...
)

## S3 method for class 'residuals_lmm'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.residuals_lmm_+3A_object">object</code>, <code id="autoplot.residuals_lmm_+3A_x">x</code></td>
<td>
<p>an object of class <code>residuals_lmm</code>, output of the <code>residuals.lmm</code> function.</p>
</td></tr>
<tr><td><code id="autoplot.residuals_lmm_+3A_type">type</code></td>
<td>
<p>[character] Should a qqplot (<code>"qqplot"</code>), or a heatmap of the correlation between residuals  (<code>"correlation"</code>, require wide format), or a plot of residuals along the fitted values (<code>"scatterplot"</code>, require long format) be displayed?</p>
</td></tr>
<tr><td><code id="autoplot.residuals_lmm_+3A_type.residual">type.residual</code></td>
<td>
<p>[character] Type of residual for which the graphical representation should be made.</p>
</td></tr>
<tr><td><code id="autoplot.residuals_lmm_+3A_time.var">time.var</code></td>
<td>
<p>[character] x-axis variable for the plot. Only relevant when argument type is one of <code>"scatterplot"</code>, <code>"scatterplot2"</code>, <code>"partial"</code>, <code>"partial-center"</code>,</p>
</td></tr>
<tr><td><code id="autoplot.residuals_lmm_+3A_facet">facet</code></td>
<td>
<p>[formula] split the plot into a matrix of panels defined by the variables in the formula.
Internally it calls <code>ggplot2::facet_wrap</code> or <code>ggplot2::facet_grid</code> depending on whether the formula contains a variable on the left hand side.</p>
</td></tr>
<tr><td><code id="autoplot.residuals_lmm_+3A_facet_nrow">facet_nrow</code></td>
<td>
<p>[integer] number of rows of panels in the graphical display.</p>
</td></tr>
<tr><td><code id="autoplot.residuals_lmm_+3A_facet_ncol">facet_ncol</code></td>
<td>
<p>[integer] number of columns of panels  in the graphical display.</p>
</td></tr>
<tr><td><code id="autoplot.residuals_lmm_+3A_engine.qqplot">engine.qqplot</code></td>
<td>
<p>[character] Should ggplot2 or qqtest be used to display quantile-quantile plots?
Only used when argument <code>type</code> is <code>"qqplot"</code>.</p>
</td></tr>
<tr><td><code id="autoplot.residuals_lmm_+3A_add.smooth">add.smooth</code></td>
<td>
<p>[logical] should a local smoother be used to display the mean of the residual values across the fitted values.
Only relevant for when argument <code>type</code> is <code>"scatterplot"</code>.</p>
</td></tr>
<tr><td><code id="autoplot.residuals_lmm_+3A_digits.cor">digits.cor</code></td>
<td>
<p>[integer, &gt;0] Number of digit used to display the correlation coefficients?
No correlation coefficient is displayed when set to 0. Only used when argument <code>plot</code> is <code>"correlation"</code>.</p>
</td></tr>
<tr><td><code id="autoplot.residuals_lmm_+3A_size.text">size.text</code></td>
<td>
<p>[numeric, &gt;0] Size of the font used to displayed text when using ggplot2.</p>
</td></tr>
<tr><td><code id="autoplot.residuals_lmm_+3A_color">color</code></td>
<td>
<p>[character] color of the dots representing the observations.
When displaying partial residuals, should contain a second color indicating how to display the model fit.</p>
</td></tr>
<tr><td><code id="autoplot.residuals_lmm_+3A_obs.size">obs.size</code></td>
<td>
<p>[numeric vector] size of the dots representing the observations.</p>
</td></tr>
<tr><td><code id="autoplot.residuals_lmm_+3A_mean.size">mean.size</code></td>
<td>
<p>[numeric vector of length 2] size of the point and line for the mean trajectory.</p>
</td></tr>
<tr><td><code id="autoplot.residuals_lmm_+3A_ci.alpha">ci.alpha</code></td>
<td>
<p>[numeric, 0-1] When not NA, transparency parameter used to display the confidence intervals.</p>
</td></tr>
<tr><td><code id="autoplot.residuals_lmm_+3A_position">position</code></td>
<td>
<p>[character] relative position of the points when colored according to a variable.</p>
</td></tr>
<tr><td><code id="autoplot.residuals_lmm_+3A_scales">scales</code>, <code id="autoplot.residuals_lmm_+3A_labeller">labeller</code></td>
<td>
<p>[character] Passed to <code>ggplot2::facet_wrap</code>.</p>
</td></tr>
<tr><td><code id="autoplot.residuals_lmm_+3A_...">...</code></td>
<td>
<p>Not used. For compatibility with the generic method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements </p>

<ul>
<li> <p><code>data</code>: data used to generate the plot.
</p>
</li>
<li> <p><code>plot</code>: ggplot object.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>plot(residuals_lmm)</code>: Graphical Display of the Residuals
</p>
</li></ul>

<hr>
<h2 id='autoplot.summarize'>Graphical Display of the Descriptive Statistics</h2><span id='topic+autoplot.summarize'></span><span id='topic+plot.summarize'></span>

<h3>Description</h3>

<p>Graphical representation of the descriptive statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summarize'
autoplot(
  object,
  type = "mean",
  variable = NULL,
  size.text = 16,
  linewidth = 1.25,
  size = 3,
  ...
)

## S3 method for class 'summarize'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.summarize_+3A_object">object</code>, <code id="autoplot.summarize_+3A_x">x</code></td>
<td>
<p>an object of class <code>summarize</code>, output of the <code>summarize</code> function.</p>
</td></tr>
<tr><td><code id="autoplot.summarize_+3A_type">type</code></td>
<td>
<p>[character] the summary statistic that should be displayed: <code>"mean"</code>, <code>"sd"</code>, ...</p>
</td></tr>
<tr><td><code id="autoplot.summarize_+3A_variable">variable</code></td>
<td>
<p>[character] type outcome relative to which the summary statistic should be displayed.
Only relevant when multiple variables have been used on the left hand side of the formula when calling <code>summarize</code>.</p>
</td></tr>
<tr><td><code id="autoplot.summarize_+3A_size.text">size.text</code></td>
<td>
<p>[numeric, &gt;0] size of the text in the legend, x- and y- labels.</p>
</td></tr>
<tr><td><code id="autoplot.summarize_+3A_linewidth">linewidth</code></td>
<td>
<p>[numeric, &gt;0] thickness of the line connecting the points.</p>
</td></tr>
<tr><td><code id="autoplot.summarize_+3A_size">size</code></td>
<td>
<p>[numeric, &gt;0] width of the points.</p>
</td></tr>
<tr><td><code id="autoplot.summarize_+3A_...">...</code></td>
<td>
<p>additional arguments passed to .ggHeatmap when displaying the correlation: </p>

<ul>
<li><p> name.time [character] title for the x- and y- axis.
</p>
</li>
<li><p> digits.cor [integer, &gt;0] number of digits used to display the correlation.
</p>
</li>
<li><p> name.legend [character] title for the color scale.
</p>
</li>
<li><p> title [character] title for the graph.
</p>
</li>
<li><p> scale [function] color scale used for the correlation.
</p>
</li>
<li><p> type.cor [character] should the whole correlation matrix be displayed (<code>"both"</code>),
or only the element in the lower or upper triangle (<code>"lower"</code>, <code>"upper"</code>).
</p>
</li>
<li><p> args.scale [list] arguments to be passed to the color scale.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements </p>

<ul>
<li> <p><code>data</code>: data used to generate the plot.
</p>
</li>
<li> <p><code>plot</code>: ggplot object.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>plot(summarize)</code>: Graphical Display of Missing Data Pattern
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>data(gastricbypassL, package = "LMMstar")
dtS &lt;- summarize(weight ~ time, data = gastricbypassL)
plot(dtS)
dtS &lt;- summarize(glucagonAUC + weight ~ time|id, data = gastricbypassL, na.rm = TRUE)
plot(dtS, variable = "glucagonAUC")
plot(dtS, variable = "glucagonAUC", type = "correlation", size.text = 1)
</code></pre>

<hr>
<h2 id='autoplot.summarizeNA'>Graphical Display of Missing Data Pattern</h2><span id='topic+autoplot.summarizeNA'></span><span id='topic+plot.summarizeNA'></span>

<h3>Description</h3>

<p>Graphical representation of the possible missing data patterns in the dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summarizeNA'
autoplot(
  object,
  variable = NULL,
  size.text = 16,
  add.missing = " missing",
  order.pattern = NULL,
  ...
)

## S3 method for class 'summarizeNA'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.summarizeNA_+3A_object">object</code>, <code id="autoplot.summarizeNA_+3A_x">x</code></td>
<td>
<p>a <code>summarizeNA</code> object, output of the <code><a href="#topic+summarizeNA">summarizeNA</a></code> function.</p>
</td></tr>
<tr><td><code id="autoplot.summarizeNA_+3A_variable">variable</code></td>
<td>
<p>[character] variable for which the missing patterns should be displayed.
Only required when the argument <code>repetition</code> has been specified when calling <code>summarizeNA</code>.</p>
</td></tr>
<tr><td><code id="autoplot.summarizeNA_+3A_size.text">size.text</code></td>
<td>
<p>[numeric, &gt;0] size of the font used to display text.</p>
</td></tr>
<tr><td><code id="autoplot.summarizeNA_+3A_add.missing">add.missing</code></td>
<td>
<p>[logical] should the number of missing values per variable be added to the x-axis tick labels.</p>
</td></tr>
<tr><td><code id="autoplot.summarizeNA_+3A_order.pattern">order.pattern</code></td>
<td>
<p>[numeric vector or character] in which order the missing data pattern should be displayed. Can either be a numeric vector indexing the patterns or a character refering to order the patterns per number of missing values (<code>"n.missing"</code>) or number of observations (<code>"frequency"</code>).</p>
</td></tr>
<tr><td><code id="autoplot.summarizeNA_+3A_...">...</code></td>
<td>
<p>Not used. For compatibility with the generic method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements </p>

<ul>
<li> <p><code>data</code>: data used to create the graphical display.
</p>
</li>
<li> <p><code>plot</code>: ggplot object.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>plot(summarizeNA)</code>: Graphical Display of Missing Data Pattern
</p>
</li></ul>

<hr>
<h2 id='autoplot.Wald_lmm'>Graphical Display For Linear Hypothesis Test</h2><span id='topic+autoplot.Wald_lmm'></span><span id='topic+plot.Wald_lmm'></span>

<h3>Description</h3>

<p>Graphical Display For Linear Hypothesis Test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Wald_lmm'
autoplot(object, type = "forest", size.text = 16, add.args = NULL, ...)

## S3 method for class 'Wald_lmm'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autoplot.Wald_lmm_+3A_object">object</code>, <code id="autoplot.Wald_lmm_+3A_x">x</code></td>
<td>
<p>a <code>Wald_lmm</code> object.</p>
</td></tr>
<tr><td><code id="autoplot.Wald_lmm_+3A_type">type</code></td>
<td>
<p>[character] what to display: a forest plot (<code>"forest"</code>) or a heatmap (<code>"heat"</code>).</p>
</td></tr>
<tr><td><code id="autoplot.Wald_lmm_+3A_size.text">size.text</code></td>
<td>
<p>[numeric, &gt;0] size of the font used to display text.</p>
</td></tr>
<tr><td><code id="autoplot.Wald_lmm_+3A_add.args">add.args</code></td>
<td>
<p>[list] additional arguments used to customized the graphical display.
Must be a named list. See details.</p>
</td></tr>
<tr><td><code id="autoplot.Wald_lmm_+3A_...">...</code></td>
<td>
<p>arguments passed to the confint method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument <strong>add.args</strong>: parameters specific to the forest plot: </p>

<ul>
<li> <p><code>color</code>: [logical] should the estimates be colored by global null hypothesis, e.g. when testing the effect of a 3 factor covariate, the two corresponding coefficient will have the same color. Alternatively a vector of positive integers giving the color with which each estimator should be displayed.
</p>
</li>
<li> <p><code>color</code>: [logical] should the estimates be represented by a different shape per global null hypothesis, e.g. when testing the effect of a 3 factor covariate, the two corresponding coefficient will have the same type of point. Alternatively a vector of positive integers describing the shape to be used for each estimator.
</p>
</li>
<li> <p><code>ci</code>: [logical] should confidence intervals be displayed?
</p>
</li>
<li> <p><code>size.estimate</code>: [numeric, &gt;0] size of the dot used to display the estimates.
</p>
</li>
<li> <p><code>size.ci</code>: [numeric, &gt;0] thickness of the line used to display the confidence intervals.
</p>
</li>
<li> <p><code>width.ci</code>: [numeric, &gt;0] width of the line used to display the confidence intervals.
</p>
</li>
<li> <p><code>size.null</code>: [numeric, &gt;0] thickness of the line used to display the null hypothesis. 
</p>
</li></ul>

<p>Parameters specific to the heatmap plot: </p>

<ul>
<li> <p><code>limits</code>: [numeric vector of length 2] minimum and maximum value of the colorscale relative to the correlation.
</p>
</li>
<li> <p><code>low</code>, <code>mid</code>, <code>high</code>: [character] color for the the colorscale relative to the correlation.
</p>
</li>
<li> <p><code>midpoint</code>: [numeric] correlation value associated with the color defined by argument <code>mid</code>
</p>
</li></ul>



<h3>Value</h3>

<p>A list with two elements </p>

<ul>
<li> <p><code>data</code>: data used to create the graphical display.
</p>
</li>
<li> <p><code>plot</code>: ggplot object.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>plot(Wald_lmm)</code>: Graphical Display For Linear Hypothesis Test
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>## From the multcomp package
if(require(datasets) &amp;&amp; require(ggplot2)){

## only tests with 1 df
ff &lt;- Fertility ~ Agriculture + Examination + Education + Catholic + Infant.Mortality
e.lmm &lt;- lmm(ff, data = swiss)
e.aovlmm &lt;- anova(e.lmm)

autoplot(e.aovlmm, type = "forest")
autoplot(e.aovlmm, type = "heat") ## 3 color gradient
autoplot(e.aovlmm, type = "heat", add.args = list(mid = NULL)) ## 2 color gradient

## test with more than 1 df
e.lmm2 &lt;- lmm(breaks ~ tension + wool, data = warpbreaks)
e.aovlmm2 &lt;- anova(e.lmm2)
autoplot(e.aovlmm2)
autoplot(e.aovlmm2, add.args = list(color = FALSE, shape = FALSE))
}

</code></pre>

<hr>
<h2 id='baselineAdjustment'>Perform Baseline Adjustment</h2><span id='topic+baselineAdjustment'></span>

<h3>Description</h3>

<p>Create a new variable based on a time variable and a group variable where groups are constrained to be equal at specific timepoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baselineAdjustment(
  object,
  variable,
  repetition,
  constrain,
  new.level = NULL,
  collapse.time = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="baselineAdjustment_+3A_object">object</code></td>
<td>
<p>[data.frame] dataset</p>
</td></tr>
<tr><td><code id="baselineAdjustment_+3A_variable">variable</code></td>
<td>
<p>[character] Column in the dataset to be constrained at specific timepoints.</p>
</td></tr>
<tr><td><code id="baselineAdjustment_+3A_repetition">repetition</code></td>
<td>
<p>[formula] Time and cluster structure, typically <code>~time|id</code>. See examples below.</p>
</td></tr>
<tr><td><code id="baselineAdjustment_+3A_constrain">constrain</code></td>
<td>
<p>[vector] Levels of the time variable at which the variable is constained.</p>
</td></tr>
<tr><td><code id="baselineAdjustment_+3A_new.level">new.level</code></td>
<td>
<p>[character or numeric] Level used at the constraint. If <code>NULL</code>, then the first level of the variable argument is used.</p>
</td></tr>
<tr><td><code id="baselineAdjustment_+3A_collapse.time">collapse.time</code></td>
<td>
<p>[character] When not <code>NULL</code> character used to combine the time and argument variable into a new (interaction) variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length the number of rows of the dataset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ncgsL, package = "LMMstar")
ncgsL$group &lt;- relevel(ncgsL$group, "placebo")

## baseline adjustment 1
ncgsL$treat &lt;- baselineAdjustment(ncgsL, variable = "group",
               repetition= ~ visit|id, constrain = 1)
table(treat = ncgsL$treat, visit = ncgsL$visit, group = ncgsL$group)

ncgsL$treattime &lt;- baselineAdjustment(ncgsL, variable = "group",
                   repetition= ~ visit|id, constrain = 1, collapse.time = ".")
table(treattime = ncgsL$treattime, visit = ncgsL$visit, group = ncgsL$group)

## baseline adjustment 2
ncgsL$treat2 &lt;- baselineAdjustment(ncgsL, variable = "group",
                 new.level = "baseline",
                 repetition= ~ visit|id, constrain = 1)
table(treat = ncgsL$treat2, visit = ncgsL$visit, group = ncgsL$group)

ncgsL$treattime2 &lt;- baselineAdjustment(ncgsL, variable = "group",
                   new.level = "baseline",
                   repetition= ~ visit|id, constrain = 1, collapse.time = ".")
table(treattime = ncgsL$treattime2, visit = ncgsL$visit, group = ncgsL$group)

</code></pre>

<hr>
<h2 id='blandAltmanL'>Data From The Bland Altman Study (Long Format)</h2><span id='topic+blandAltmanL'></span>

<h3>Description</h3>

<p>Data From The Bland Altman Study where two methods to measure the peak expiratory flow rate (PEFR) where compared.
This dataset is in the long format (i.e. one line per measurement).
</p>

<ul>
<li> <p><code>id</code>: patient identifier.
</p>
</li>
<li> <p><code>replicate</code>: index of the measurement (first or second).
</p>
</li>
<li> <p><code>method</code>: device used to make the measurement (Wright peak flow meter or mini Wright peak flow meter).
</p>
</li>
<li> <p><code>pefr</code>: measurement (peak expiratory flow rate).
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(blandAltmanL)
</code></pre>


<h3>References</h3>

<p>Bland &amp; Altman, Statistical methods for assessing agreement between two methods of clinical measurement, Lancet, 1986; i: 307-310.
</p>

<hr>
<h2 id='blandAltmanW'>Data From The Bland Altman Study (Wide Format)</h2><span id='topic+blandAltmanW'></span>

<h3>Description</h3>

<p>Data From The Bland Altman Study where two methods to measure the peak expiratory flow rate (PEFR) where compared.
This dataset is in the wide format (i.e. one line per patient).
</p>

<ul>
<li> <p><code>id</code>: patient identifier.
</p>
</li>
<li> <p><code>wright1</code>: first measurement made with a Wright peak flow meter.
</p>
</li>
<li> <p><code>wright2</code>: second measurement made with a Wright peak flow meter.
</p>
</li>
<li> <p><code>mini1</code>: first measurement made with a mini Wright peak flow meter.
</p>
</li>
<li> <p><code>mini2</code>: second measurement made with a mini Wright peak flow meter.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(blandAltmanW)
</code></pre>


<h3>References</h3>

<p>Bland &amp; Altman, Statistical methods for assessing agreement between two methods of clinical measurement, Lancet, 1986; i: 307-310.
</p>

<hr>
<h2 id='bloodpressureL'>Data From The Blood Pressure Study (Long Format)</h2><span id='topic+bloodpressureL'></span>

<h3>Description</h3>

<p>Data from a cross-over trial comparing the impact of three formulations of a drug on the blood pressure.
The study was conducted on 12 male volunteers randomly divided into tree groups
and receiving each of the three formulations with a wash-out period of one week.
</p>

<ul>
<li> <p><code>id</code>: patient identifier.
</p>
</li>
<li> <p><code>sequence</code>: sequence of treatment .
</p>
</li>
<li> <p><code>treatment</code>: formulation of the treatment
A (50 mg tablet)
B (100 mg tablet)
C (sustained-release formulation capsule)
</p>
</li>
<li> <p><code>period</code>: time period (in weeks).
</p>
</li>
<li> <p><code>duration</code>: duration of the drug (in hours).
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(bloodpressureL)
</code></pre>


<h3>References</h3>

<p>TO ADD
</p>

<hr>
<h2 id='calciumL'>Data From The Calcium Supplements Study (Long Format)</h2><span id='topic+calciumL'></span>

<h3>Description</h3>

<p>Data from a randomized study including 112 girls at age 11 investigate the effect of a calcium supplement (n=55) vs. placebo (n=57)
on bone mineral density over a 2 year follow-up. The clinical question is: does a calcium supplement help to increase bone gain in adolescent women?
This dataset is in the long format (i.e. one line per measurement).
</p>

<ul>
<li> <p><code>girl</code>: patient identifier.
</p>
</li>
<li> <p><code>grp</code>: treatment group: calcium supplement (coded <code>C</code>) or placebo (coded <code>P</code>).
</p>
</li>
<li> <p><code>visit</code>: visit index.
</p>
</li>
<li> <p><code>bmd</code>: bone mineral density (mg/cm3).
</p>
</li>
<li> <p><code>time.obs</code>: visit time (in years).
</p>
</li>
<li> <p><code>time.num</code>: scheduled visit time (numeric variable, in years).
</p>
</li>
<li> <p><code>time.fac</code>: scheduled visit time (factor variable).
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(calciumL)
</code></pre>


<h3>References</h3>

<p>TO ADD
</p>

<hr>
<h2 id='calciumW'>Data From The Calcium Supplements Study (Wide Format)</h2><span id='topic+calciumW'></span>

<h3>Description</h3>

<p>Data from a randomized study including 112 girls at age 11 investigate the effect of a calcium supplement (n=55) vs. placebo (n=57)
on bone mineral density over a 2 year follow-up. The clinical question is: does a calcium supplement help to increase bone gain in adolescent women?
This dataset is in the wide format (i.e. one line per patient).
</p>

<ul>
<li> <p><code>girl</code>: patient identifier
</p>
</li>
<li> <p><code>grp</code>: treatment group: calcium supplement (coded <code>C</code>) or placebo (coded <code>P</code>).
</p>
</li>
<li> <p><code>obstime1</code>: time after the start of the study at which the first visit took place (in years).
</p>
</li>
<li> <p><code>obstime2</code>: time after the start of the study at which the second visit took place (in years).
</p>
</li>
<li> <p><code>obstime3</code>: time after the start of the study at which the third visit took place (in years).
</p>
</li>
<li> <p><code>obstime4</code>: time after the start of the study at which the fourth visit took place (in years).
</p>
</li>
<li> <p><code>obstime5</code>: time after the start of the study at which the fifth visit took place (in years).
</p>
</li>
<li> <p><code>bmd1</code>: bone mineral density measured at the first visit (in mg/cm3).
</p>
</li>
<li> <p><code>bmd2</code>: bone mineral density measured at the second visit (in mg/cm3).
</p>
</li>
<li> <p><code>bmd3</code>: bone mineral density measured at the third visit (in mg/cm3).
</p>
</li>
<li> <p><code>bmd4</code>: bone mineral density measured at the fourth visit (in mg/cm3).
</p>
</li>
<li> <p><code>bmd5</code>: bone mineral density measured at the fifth visit (in mg/cm3).
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(calciumW)
</code></pre>


<h3>References</h3>

<p>Vonesh and Chinchilli 1997. Linear and Nonlinear models for the analysis of repeated measurement (Table 5.4.1 on page 228). New York: Marcel Dekker.
</p>

<hr>
<h2 id='ckdL'>CKD long</h2><span id='topic+ckdL'></span>

<h3>Description</h3>

<p>TODO
</p>

<ul>
<li> <p><code>id</code>: patient identifier.
</p>
</li>
<li> <p><code>allocation</code>:
</p>
</li>
<li> <p><code>sex</code>:
</p>
</li>
<li> <p><code>age</code>:
</p>
</li>
<li> <p><code>visit</code>:
</p>
</li>
<li> <p><code>time</code>:
</p>
</li>
<li> <p><code>pwv</code>:
</p>
</li>
<li> <p><code>aix</code>:
</p>
</li>
<li> <p><code>dropout</code>:
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(ckdL)
</code></pre>


<h3>References</h3>

<p>TO ADD
</p>

<hr>
<h2 id='ckdW'>CKD wide</h2><span id='topic+ckdW'></span>

<h3>Description</h3>

<p>TODO
</p>

<ul>
<li> <p><code>id</code>: patient identifier.
</p>
</li>
<li> <p><code>allocation</code>:
</p>
</li>
<li> <p><code>sex</code>:
</p>
</li>
<li> <p><code>age</code>:
</p>
</li>
<li> <p><code>pwv0</code>:
</p>
</li>
<li> <p><code>pwv12</code>:
</p>
</li>
<li> <p><code>pwv24</code>:
</p>
</li>
<li> <p><code>aix0</code>:
</p>
</li>
<li> <p><code>aix12</code>:
</p>
</li>
<li> <p><code>aix24</code>:
</p>
</li>
<li> <p><code>dropout</code>:
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(ckdW)
</code></pre>


<h3>References</h3>

<p>TO ADD
</p>

<hr>
<h2 id='coef.lmm'>Extract Coefficients From a Linear Mixed Model</h2><span id='topic+coef.lmm'></span>

<h3>Description</h3>

<p>Extract coefficients from a linear mixed model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmm'
coef(
  object,
  effects = NULL,
  p = NULL,
  transform.sigma = "none",
  transform.k = "none",
  transform.rho = "none",
  transform.names = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.lmm_+3A_object">object</code></td>
<td>
<p>a <code>lmm</code> object.</p>
</td></tr>
<tr><td><code id="coef.lmm_+3A_effects">effects</code></td>
<td>
<p>[character] Should all coefficients be output (<code>"all"</code>),
or only coefficients relative to the mean (<code>"mean"</code> or <code>"fixed"</code>),
or only coefficients relative to the variance structure (<code>"variance"</code>),
or only coefficients relative to the correlation structure (<code>"correlation"</code>).
Can also be <code>"ranef"</code> to output random effect (only for <code>CS</code> structure).</p>
</td></tr>
<tr><td><code id="coef.lmm_+3A_p">p</code></td>
<td>
<p>[numeric vector] value of the model coefficients to be used. Only relevant if differs from the fitted values.</p>
</td></tr>
<tr><td><code id="coef.lmm_+3A_transform.sigma">transform.sigma</code></td>
<td>
<p>[character] Transformation used on the variance coefficient for the reference level. One of <code>"none"</code>, <code>"log"</code>, <code>"square"</code>, <code>"logsquare"</code> - see details.</p>
</td></tr>
<tr><td><code id="coef.lmm_+3A_transform.k">transform.k</code></td>
<td>
<p>[character] Transformation used on the variance coefficients relative to the other levels. One of <code>"none"</code>, <code>"log"</code>, <code>"square"</code>, <code>"logsquare"</code>, <code>"sd"</code>, <code>"logsd"</code>, <code>"var"</code>, <code>"logvar"</code> - see details.</p>
</td></tr>
<tr><td><code id="coef.lmm_+3A_transform.rho">transform.rho</code></td>
<td>
<p>[character] Transformation used on the correlation coefficients. One of <code>"none"</code>, <code>"atanh"</code>, <code>"cov"</code> - see details.</p>
</td></tr>
<tr><td><code id="coef.lmm_+3A_transform.names">transform.names</code></td>
<td>
<p>[logical] Should the name of the coefficients be updated to reflect the transformation that has been used?</p>
</td></tr>
<tr><td><code id="coef.lmm_+3A_...">...</code></td>
<td>
<p>Not used. For compatibility with the generic method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>transform.sigma</b>: <br />
</p>

<ul>
<li> <p><code>"none"</code> ouput residual standard error.
</p>
</li>
<li> <p><code>"log"</code> ouput log-transformed residual standard error.
</p>
</li>
<li> <p><code>"square"</code> ouput residual variance.
</p>
</li>
<li> <p><code>"logsquare"</code> ouput log-transformed residual variance.
</p>
</li></ul>

<p><b>transform.k</b>: <br />
</p>

<ul>
<li> <p><code>"none"</code> ouput ratio between the residual standard error of the current level and the reference level.
</p>
</li>
<li> <p><code>"log"</code> ouput log-transformed ratio between the residual standard errors.
</p>
</li>
<li> <p><code>"square"</code> ouput ratio between the residual variances.
</p>
</li>
<li> <p><code>"logsquare"</code> ouput log-transformed ratio between the residual variances.
</p>
</li>
<li> <p><code>"sd"</code> ouput residual standard error of the current level.
</p>
</li>
<li> <p><code>"logsd"</code> ouput residual log-transformed standard error of the current level.
</p>
</li>
<li> <p><code>"var"</code> ouput residual variance of the current level.
</p>
</li>
<li> <p><code>"logvar"</code> ouput residual log-transformed variance of the current level.
</p>
</li></ul>

<p><b>transform.rho</b>: <br />
</p>

<ul>
<li> <p><code>"none"</code> ouput correlation coefficient.
</p>
</li>
<li> <p><code>"atanh"</code> ouput correlation coefficient after tangent hyperbolic transformation.
</p>
</li>
<li> <p><code>"cov"</code> ouput covariance coefficient.
</p>
</li></ul>

<p>When using a (pure) compound symmetry covariance structure (<code>structure = "CS"</code>),
estimated random effects can be extracted by setting argument <code>effects</code> to <code>"ranef"</code>.
</p>


<h3>Value</h3>

<p>A vector with the value of the model coefficients.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+confint.lmm">confint.lmm</a></code> or <code><a href="#topic+model.tables.lmm">model.tables.lmm</a></code> for a data.frame containing estimates with their uncertainty. <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simulate data in the long format
set.seed(10)
dL &lt;- sampleRem(100, n.times = 3, format = "long")

## fit linear mixed model
eUN.lmm &lt;- lmm(Y ~ X1 + X2 + X5, repetition = ~visit|id, structure = "UN", data = dL, df = FALSE)

## output coefficients
coef(eUN.lmm)
coef(eUN.lmm, effects = "mean")
coef(eUN.lmm, transform.sigma = "none", transform.k = "none", transform.rho = "none")
</code></pre>

<hr>
<h2 id='coef.mlmm'>Extract Coefficients From a Linear Mixed Model</h2><span id='topic+coef.mlmm'></span>

<h3>Description</h3>

<p>Extract coefficients from a linear mixed model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mlmm'
coef(object, effects = "contrast", ordering = "parameter", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.mlmm_+3A_object">object</code></td>
<td>
<p>a <code>mlmm</code> object.</p>
</td></tr>
<tr><td><code id="coef.mlmm_+3A_effects">effects</code></td>
<td>
<p>[character] By default will output the estimate for the hypothesis being tests.
But can also output all model coefficients (<code>"all"</code>),
or only coefficients relative to the mean (<code>"mean"</code> or <code>"fixed"</code>),
or only coefficients relative to the variance structure (<code>"variance"</code>),
or only coefficients relative to the correlation structure (<code>"correlation"</code>).</p>
</td></tr>
<tr><td><code id="coef.mlmm_+3A_ordering">ordering</code></td>
<td>
<p>[character] should the output be ordered by type of parameter (<code>parameter</code>) or by model (<code>by</code>).</p>
</td></tr>
<tr><td><code id="coef.mlmm_+3A_...">...</code></td>
<td>
<p>passed to <code>coef.Wald_lmm</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='confint.lmm'>Statistical Inference for Linear Mixed Model</h2><span id='topic+confint.lmm'></span>

<h3>Description</h3>

<p>Compute confidence intervals (CIs) and p-values for the coefficients of a linear mixed model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmm'
confint(
  object,
  parm = NULL,
  level = 0.95,
  effects = NULL,
  robust = FALSE,
  null = NULL,
  columns = NULL,
  df = NULL,
  type.information = NULL,
  transform.sigma = NULL,
  transform.k = NULL,
  transform.rho = NULL,
  transform.names = TRUE,
  backtransform = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.lmm_+3A_object">object</code></td>
<td>
<p>a <code>lmm</code> object.</p>
</td></tr>
<tr><td><code id="confint.lmm_+3A_parm">parm</code></td>
<td>
<p>Not used. For compatibility with the generic method.</p>
</td></tr>
<tr><td><code id="confint.lmm_+3A_level">level</code></td>
<td>
<p>[numeric,0-1] the confidence level of the confidence intervals.</p>
</td></tr>
<tr><td><code id="confint.lmm_+3A_effects">effects</code></td>
<td>
<p>[character] Should the CIs/p-values for all coefficients be output (<code>"all"</code>),
or only for mean coefficients (<code>"mean"</code> or <code>"fixed"</code>),
or only for variance coefficients (<code>"variance"</code>),
or only for correlation coefficients (<code>"correlation"</code>).</p>
</td></tr>
<tr><td><code id="confint.lmm_+3A_robust">robust</code></td>
<td>
<p>[logical] Should robust standard errors (aka sandwich estimator) be output instead of the model-based standard errors. Not feasible for variance or correlation coefficients estimated by REML.</p>
</td></tr>
<tr><td><code id="confint.lmm_+3A_null">null</code></td>
<td>
<p>[numeric vector] the value of the null hypothesis relative to each coefficient.</p>
</td></tr>
<tr><td><code id="confint.lmm_+3A_columns">columns</code></td>
<td>
<p>[character vector] Columns to be output.
Can be any of <code>"estimate"</code>, <code>"se"</code>, <code>"statistic"</code>, <code>"df"</code>, <code>"null"</code>, <code>"lower"</code>, <code>"upper"</code>, <code>"p.value"</code>.</p>
</td></tr>
<tr><td><code id="confint.lmm_+3A_df">df</code></td>
<td>
<p>[logical] Should a Student's t-distribution be used to model the distribution of the coefficient. Otherwise a normal distribution is used.</p>
</td></tr>
<tr><td><code id="confint.lmm_+3A_type.information">type.information</code>, <code id="confint.lmm_+3A_transform.sigma">transform.sigma</code>, <code id="confint.lmm_+3A_transform.k">transform.k</code>, <code id="confint.lmm_+3A_transform.rho">transform.rho</code>, <code id="confint.lmm_+3A_transform.names">transform.names</code></td>
<td>
<p>are passed to the <code>vcov</code> method. See details section in <code><a href="#topic+coef.lmm">coef.lmm</a></code>.</p>
</td></tr>
<tr><td><code id="confint.lmm_+3A_backtransform">backtransform</code></td>
<td>
<p>[logical] should the variance/covariance/correlation coefficient be backtransformed?</p>
</td></tr>
<tr><td><code id="confint.lmm_+3A_...">...</code></td>
<td>
<p>Not used. For compatibility with the generic method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame containing some of the following coefficient (in rows): </p>

<ul>
<li><p> column estimate: the estimate.
</p>
</li>
<li><p> column se: the standard error.
</p>
</li>
<li><p> column statistic: the test statistic.
</p>
</li>
<li><p> column df: the degree of freedom.
</p>
</li>
<li><p> column lower: the lower bound of the confidence interval.
</p>
</li>
<li><p> column upper: the upper bound of the confidence interval.
</p>
</li>
<li><p> column null: the null hypothesis.
</p>
</li>
<li><p> column p.value: the p-value relative to the null hypothesis.
</p>
</li></ul>



<h3>See Also</h3>

<p>the function <code>anova</code> to perform inference about linear combinations of coefficients and adjust for multiple comparisons.
</p>
<p><code><a href="#topic+coef.lmm">coef.lmm</a></code> for a simpler output (e.g. only estimates). <br />
<code><a href="#topic+model.tables.lmm">model.tables.lmm</a></code> for a more detailed output (e.g. with p-value). <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### simulate data in the long format ####
set.seed(10)
dL &lt;- sampleRem(100, n.times = 3, format = "long")

#### fit Linear Mixed Model ####
eUN.lmm &lt;- lmm(Y ~ X1 + X2 + X5, repetition = ~visit|id, structure = "UN", data = dL)

#### Confidence intervals ####
## based on a Student's t-distribution with transformation
confint(eUN.lmm, effects = "all")
## based on a Student's t-distribution without transformation
confint(eUN.lmm, effects = "all",
        transform.sigma = "none", transform.k = "none", transform.rho = "none")
## based on a Student's t-distribution transformation but not backtransformed
confint(eUN.lmm, effects = "all", backtransform = FALSE)
## based on a Normal distribution with transformation
confint(eUN.lmm, df = FALSE)

</code></pre>

<hr>
<h2 id='confint.mlmm'>Confidence Intervals for Multiple Linear Mixed Model.</h2><span id='topic+confint.mlmm'></span>

<h3>Description</h3>

<p>Compute confidence intervals for several linear mixed models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mlmm'
confint(
  object,
  parm = NULL,
  level = 0.95,
  method = NULL,
  ordering = "parameter",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.mlmm_+3A_object">object</code></td>
<td>
<p>an <code>mlmm</code> object, output of <code>mlmm</code>.</p>
</td></tr>
<tr><td><code id="confint.mlmm_+3A_parm">parm</code></td>
<td>
<p>Not used. For compatibility with the generic method.</p>
</td></tr>
<tr><td><code id="confint.mlmm_+3A_level">level</code></td>
<td>
<p>[numeric,0-1] the confidence level of the confidence intervals.</p>
</td></tr>
<tr><td><code id="confint.mlmm_+3A_method">method</code></td>
<td>
<p>[character] type of adjustment for multiple comparisons: one of <code>"none"</code>, <code>"bonferroni"</code>, <code>"single-step"</code>, <code>"single-step2"</code>, or <code>"pool"</code>.</p>
</td></tr>
<tr><td><code id="confint.mlmm_+3A_ordering">ordering</code></td>
<td>
<p>[character] should the output be ordered by type of parameter (<code>parameter</code>) or by model (<code>by</code>).
Only relevant for <code>mlmm</code> objects.</p>
</td></tr>
<tr><td><code id="confint.mlmm_+3A_...">...</code></td>
<td>
<p>other arguments are passed to <code><a href="#topic+confint.Wald_lmm">confint.Wald_lmm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Statistical inference following pooling is performed according to Rubin's rule whose validity requires the congeniality condition of Meng (1994).
</p>


<h3>References</h3>

<p>Meng X. L.(1994). Multiple-imputation inferences with uncongenial sources of input. Statist. Sci.9, 538–58.
</p>

<hr>
<h2 id='confint.Wald_lmm'>Confidence Intervals for Multivariate Wald Tests</h2><span id='topic+confint.Wald_lmm'></span>

<h3>Description</h3>

<p>Compute confidence intervals for linear hypothesis tests, possibly with adjustment for multiple comparisons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Wald_lmm'
confint(
  object,
  parm,
  level = 0.95,
  method = NULL,
  columns = NULL,
  backtransform = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.Wald_lmm_+3A_object">object</code></td>
<td>
<p>a <code>Wald_lmm</code> object</p>
</td></tr>
<tr><td><code id="confint.Wald_lmm_+3A_parm">parm</code></td>
<td>
<p>Not used. For compatibility with the generic method.</p>
</td></tr>
<tr><td><code id="confint.Wald_lmm_+3A_level">level</code></td>
<td>
<p>[numeric, 0-1] nominal coverage of the confidence intervals.</p>
</td></tr>
<tr><td><code id="confint.Wald_lmm_+3A_method">method</code></td>
<td>
<p>[character] type of adjustment for multiple comparisons, one of <code>"none"</code>, <code>"bonferroni"</code>, ..., <code>"fdr"</code>, <code>"single-step"</code>, <code>"single-step2"</code>.
Alternatively, a method for combining the estimates, one of <code>"average"</code>, <code>"pool.se"</code>, <code>"pool.gls"</code>, <code>"pool.gls1"</code>, <code>"pool.rubin"</code>.</p>
</td></tr>
<tr><td><code id="confint.Wald_lmm_+3A_columns">columns</code></td>
<td>
<p>[character vector] Columns to be output.
Can be any of <code>"estimate"</code>, <code>"se"</code>, <code>"statistic"</code>, <code>"df"</code>, <code>"null"</code>, <code>"lower"</code>, <code>"upper"</code>, <code>"p.value"</code>.</p>
</td></tr>
<tr><td><code id="confint.Wald_lmm_+3A_backtransform">backtransform</code></td>
<td>
<p>[logical] should the estimates, standard errors, and confidence intervals be backtransformed?</p>
</td></tr>
<tr><td><code id="confint.Wald_lmm_+3A_...">...</code></td>
<td>
<p>Not used. For compatibility with the generic method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>Adjustment for multiple comparisons</b>: available methods are:
</p>

<ul>
<li> <p><code>"none"</code>, <code>"bonferroni"</code>, <code>"single-step2"</code>
</p>
</li>
<li> <p><code>"holm"</code>, <code>"hochberg"</code>, <code>"hommel"</code>, <code>"BH"</code>, <code>"BY"</code>, <code>"fdr"</code>: adjustment performed by [stats::p.adjust()], no confidence interval is computed.
</p>
</li>
<li> <p><code>"single-step"</code>, <code>"free"</code>, <code>"Westfall"</code>, <code>"Shaffer"</code>: adjustment performed by [multcomp::glht()],  for all but the first method no confidence interval is computed.
</p>
</li></ul>

<p>Note: method <code>"single-step"</code> adjusts for multiple comparisons using equicoordinate quantiles of the multivariate Student's t-distribution over all tests, instead of the univariate quantiles. It assumes equal degrees of freedom in the marginal and is described in section 7.1 of Dmitrienko et al. (2013) under the name single-step Dunnett procedure. The name <code>"single-step"</code> is borrowed from the multcomp package. In the book Bretz et al. (2010) written by the authors of the package, the procedure is refered to as max-t tests which is the terminology adopted in the LMMstar package.  <br />
When degrees of freedom differs between individual hypotheses, method <code>"single-step2"</code> is recommended. It simulates data using copula whose marginal distributions are Student's t-distribution (with possibly different degrees of freedom) and elliptical copula with parameters the estimated correlation between the test statistics (via the copula package). It then computes the frequency at which the simulated maximum exceed the observed maximum and appropriate quantile of simulated maximum for the confidence interval.
</p>
<p><b>Pooling estimates</b>: available methods are:
</p>

<ul>
<li> <p><code>"average"</code>: average estimates
</p>
</li>
<li> <p><code>"pool.fixse"</code>: weighted average of the estimates, with weights being the inverse of the squared standard error. The uncertainty about the weights is neglected.
</p>
</li>
<li> <p><code>"pool.se"</code>: weighted average of the estimates, with weights being the inverse of the squared standard error. The uncertainty about the weights is computed under independence of the variance parameters between models. 
</p>
</li>
<li> <p><code>"pool.gls"</code>: weighted average of the estimates, with weights being based on the variance-covariance matrix of the estimates. When this matrix is singular, its spectral decomposition is truncated when the correspodning eigenvalues are below <code class="reqn">10^{-12}</code>. The uncertainty about the weights is neglected. 
</p>
</li>
<li> <p><code>"pool.gls1"</code>: similar to <code>"pool.gls"</code> but ensure that the weights are at most 1 in absolute value by shrinking toward the average.
</p>
</li>
<li> <p><code>"pool.rubin"</code>: average of the estimates and compute the uncertainty according to Rubin's rule (Barnard et al. 1999).
</p>
</li></ul>



<h3>References</h3>

<p>Barnard and Rubin, <b>Small-sample degrees of freedom with multiple imputation</b>. <em>Biometrika</em> (1999), 86(4):948-955. <br />
Dmitrienko, A. and D'Agostino, R., Sr (2013), <b>Traditional multiplicity adjustment methods in clinical trials</b>. <em>Statist. Med.</em>, 32: 5172-5218.
Frank Bretz, Torsten Hothorn and Peter Westfall (2010), <b>Multiple Comparisons Using R</b>, <em>CRC Press</em>, Boca Raton.
</p>

<hr>
<h2 id='CS'>Compound Symmetry Structure</h2><span id='topic+CS'></span>

<h3>Description</h3>

<p>Variance-covariance structure where the variance and correlation of the residuals is constant within covariate levels.
Can be stratified on a categorical variable.
The default has no covariate and therefore the variance and correlation are constant within cluster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CS(formula, var.cluster, var.time, type = NULL, group.type = NULL, add.time)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CS_+3A_formula">formula</code></td>
<td>
<p>formula indicating on which variable to stratify the residual variance and correlation (left hand side)
and variables influencing the residual variance and correlation (right hand side).</p>
</td></tr>
<tr><td><code id="CS_+3A_var.cluster">var.cluster</code></td>
<td>
<p>[character] cluster variable.</p>
</td></tr>
<tr><td><code id="CS_+3A_var.time">var.time</code></td>
<td>
<p>[character] time variable.</p>
</td></tr>
<tr><td><code id="CS_+3A_type">type</code></td>
<td>
<p>[character] </p>

<ul>
<li> <p><code>"ho"</code>, <code>"homo"</code>, or <code>"homogeneous"</code>: constant variance and covariate-specific correlation.
Analogous to crossed or nested random effects.
</p>
</li>
<li> <p><code>"he"</code>, <code>"hetero"</code>, or <code>"heterogeneous"</code>: variance and correlation specific to the level of covariates.
Can be seen as more flexible crossed or nested random effects model.
</p>
</li></ul>
</td></tr>
<tr><td><code id="CS_+3A_group.type">group.type</code></td>
<td>
<p>[integer vector] grouping of the regressor for the correlation structure.
A constant value corresponds to nested random effects (default) and a regressor-specific value to crossed random effects</p>
</td></tr>
<tr><td><code id="CS_+3A_add.time">add.time</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A typical formula would be <code>~1</code>, indicating a variance constant over time and the same correlation between all pairs of times.
</p>


<h3>Value</h3>

<p>An object of class <code>CS</code> that can be passed to the argument <code>structure</code> of the <code>lmm</code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## no covariates
CS(~1, var.cluster = "id", var.time = "time")
CS(gender~1, var.cluster = "id", var.time = "time")

## covariates
CS(~time, var.cluster = "id", var.time = "time")
CS(gender~time, var.cluster = "id", var.time = "time")
CS(list(~time,~1), var.cluster = "id", var.time = "time")
CS(list(gender~time,gender~1), var.cluster = "id", var.time = "time")

</code></pre>

<hr>
<h2 id='CUSTOM'>Custom Structure</h2><span id='topic+CUSTOM'></span>

<h3>Description</h3>

<p>Variance-covariance structure specified by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CUSTOM(
  formula,
  var.cluster,
  var.time,
  FCT.sigma,
  dFCT.sigma = NULL,
  d2FCT.sigma = NULL,
  init.sigma,
  FCT.rho,
  dFCT.rho = NULL,
  d2FCT.rho = NULL,
  init.rho,
  add.time
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CUSTOM_+3A_formula">formula</code></td>
<td>
<p>formula indicating variables influencing the residual variance and correlation (right hand side).</p>
</td></tr>
<tr><td><code id="CUSTOM_+3A_var.cluster">var.cluster</code></td>
<td>
<p>[character] cluster variable.</p>
</td></tr>
<tr><td><code id="CUSTOM_+3A_var.time">var.time</code></td>
<td>
<p>[character] time variable.</p>
</td></tr>
<tr><td><code id="CUSTOM_+3A_fct.sigma">FCT.sigma</code></td>
<td>
<p>[function] take as argument the model parameters, time, and design matrix.
Output the vector of residuals standard deviations.</p>
</td></tr>
<tr><td><code id="CUSTOM_+3A_dfct.sigma">dFCT.sigma</code></td>
<td>
<p>[list of vectors] list whose elements are the first derivative of argument <code>FCT.sigma</code>.</p>
</td></tr>
<tr><td><code id="CUSTOM_+3A_d2fct.sigma">d2FCT.sigma</code></td>
<td>
<p>[list of vectors] list whose elements are the second derivative of argument <code>FCT.sigma</code> (no cross-terms).</p>
</td></tr>
<tr><td><code id="CUSTOM_+3A_init.sigma">init.sigma</code></td>
<td>
<p>[numeric vector] initial value for the variance parameters.</p>
</td></tr>
<tr><td><code id="CUSTOM_+3A_fct.rho">FCT.rho</code></td>
<td>
<p>[function] take as argument the model parameters, time, and design matrix.
Output the matrix of residuals correlation.</p>
</td></tr>
<tr><td><code id="CUSTOM_+3A_dfct.rho">dFCT.rho</code></td>
<td>
<p>[list of matrices] list whose elements are the first derivative of argument <code>FCT.rho</code>.</p>
</td></tr>
<tr><td><code id="CUSTOM_+3A_d2fct.rho">d2FCT.rho</code></td>
<td>
<p>[list of matrices] list whose elements are the second derivative of argument <code>FCT.rho</code> (no cross-terms).</p>
</td></tr>
<tr><td><code id="CUSTOM_+3A_init.rho">init.rho</code></td>
<td>
<p>[numeric vector] initial value for the correlation parameters.</p>
</td></tr>
<tr><td><code id="CUSTOM_+3A_add.time">add.time</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>CUSTOM</code> that can be passed to the argument <code>structure</code> of the <code>lmm</code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Compound symmetry structure
CUSTOM(~1,
       FCT.sigma = function(p,n.time,X){rep(p,n.time)},
       init.sigma = c("sigma"=1),
       dFCT.sigma = function(p,n.time,X){list(sigma = rep(1,n.time))},  
       d2FCT.sigma = function(p,n.time,X){list(sigma = rep(0,n.time))},  
       FCT.rho = function(p,n.time,X){
           matrix(p,n.time,n.time)+diag(1-p,n.time,n.time)
       },
       init.rho = c("rho"=0.5),
       dFCT.rho = function(p,n.time,X){
            list(rho = matrix(1,n.time,n.time)-diag(1,n.time,n.time))
       },
       d2FCT.rho = function(p,n.time,X){list(rho = matrix(0,n.time,n.time))}
)

## 2 block structure
rho.2block &lt;- function(p,n.time,X){
   rho &lt;- matrix(0, nrow = n.time, ncol = n.time)
   rho[1,2] &lt;- rho[2,1] &lt;- rho[4,5] &lt;- rho[5,4] &lt;- p["rho1"]
   rho[1,3] &lt;- rho[3,1] &lt;- rho[4,6] &lt;- rho[6,4] &lt;- p["rho2"]
   rho[2,3] &lt;- rho[3,2] &lt;- rho[5,6] &lt;- rho[6,5] &lt;- p["rho3"]
   rho[4:6,1:3] &lt;- rho[1:3,4:6] &lt;- p["rho4"]
   return(rho)
}
drho.2block &lt;- function(p,n.time,X){
   drho &lt;- list(rho1 = matrix(0, nrow = n.time, ncol = n.time),
                rho2 = matrix(0, nrow = n.time, ncol = n.time),
                rho3 = matrix(0, nrow = n.time, ncol = n.time),
                rho4 = matrix(0, nrow = n.time, ncol = n.time))   
   drho$rho1[1,2] &lt;- drho$rho1[2,1] &lt;- drho$rho1[4,5] &lt;- drho$rho1[5,4] &lt;- 1
   drho$rho2[1,3] &lt;- drho$rho2[3,1] &lt;- drho$rho2[4,6] &lt;- drho$rho2[6,4] &lt;- 1
   drho$rho3[2,3] &lt;- drho$rho3[3,2] &lt;- drho$rho3[5,6] &lt;- drho$rho3[6,5] &lt;- 1
   drho$rho4[4:6,1:3] &lt;- drho$rho4[1:3,4:6] &lt;- 1
   return(drho)
}
d2rho.2block &lt;- function(p,n.time,X){
   d2rho &lt;- list(rho1 = matrix(0, nrow = n.time, ncol = n.time),
                 rho2 = matrix(0, nrow = n.time, ncol = n.time),
                 rho3 = matrix(0, nrow = n.time, ncol = n.time),
                 rho4 = matrix(0, nrow = n.time, ncol = n.time))   
   return(d2rho)
}

CUSTOM(~variable,
       FCT.sigma = function(p,n.time,X){rep(p,n.time)},
       dFCT.sigma = function(p,n.time,X){list(sigma=rep(1,n.time))},
       d2FCT.sigma = function(p,n.time,X){list(sigma=rep(0,n.time))},
       init.sigma = c("sigma"=1),
       FCT.rho = rho.2block,
       dFCT.rho = drho.2block,
       d2FCT.rho = d2rho.2block,
       init.rho = c("rho1"=0.25,"rho2"=0.25,"rho3"=0.25,"rho4"=0.25))

</code></pre>

<hr>
<h2 id='df.residual.lmm'>Residuals Degrees of Freedom</h2><span id='topic+df.residual.lmm'></span>

<h3>Description</h3>

<p>Residuals degrees of freedom. Computed as the sum of squared normalized residuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmm'
df.residual(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="df.residual.lmm_+3A_object">object</code></td>
<td>
<p>a <code>lmm</code> object.</p>
</td></tr>
<tr><td><code id="df.residual.lmm_+3A_...">...</code></td>
<td>
<p>Passed to <code>residuals.lmm</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value
</p>

<hr>
<h2 id='effects.lmm'>Effects Derived For Linear Mixed Model</h2><span id='topic+effects.lmm'></span>

<h3>Description</h3>

<p>Estimate average counterfactual outcome or contrast of outcome from linear mixed models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmm'
effects(
  object,
  variable,
  newdata = NULL,
  type = c("identity", "none"),
  conditional = NULL,
  rhs = NULL,
  repetition = NULL,
  multivariate = FALSE,
  prefix.time = NULL,
  prefix.var = TRUE,
  sep.var = ",",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="effects.lmm_+3A_object">object</code></td>
<td>
<p>a <code>lmm</code> object.</p>
</td></tr>
<tr><td><code id="effects.lmm_+3A_variable">variable</code></td>
<td>
<p>[character] the variable relative to which the effect should be computed.</p>
</td></tr>
<tr><td><code id="effects.lmm_+3A_newdata">newdata</code></td>
<td>
<p>[data.frame] a dataset reflecting the covariate distribution relative to which the average outcome or contrast should be computed.</p>
</td></tr>
<tr><td><code id="effects.lmm_+3A_type">type</code></td>
<td>
<p>[character] should the average counterfactual outcome for each variable level be evaluated (<code>"identity"</code>)?
Or the difference in average counterfactual outcome between each pair of  variable level (<code>"difference"</code>)?
Can have an second element to consider a transformation of the outcome:
the change from baseline (<code>"change"</code>),
area under the outcome curve (<code>"auc"</code>),
or area under the outcome curve minus baseline (<code>"auc-b"</code>).</p>
</td></tr>
<tr><td><code id="effects.lmm_+3A_conditional">conditional</code></td>
<td>
<p>[character] variable conditional to which the average conterfactual outcome or treatment effect should be computed.</p>
</td></tr>
<tr><td><code id="effects.lmm_+3A_rhs">rhs</code></td>
<td>
<p>[numeric] the right hand side of the hypothesis.</p>
</td></tr>
<tr><td><code id="effects.lmm_+3A_repetition">repetition</code></td>
<td>
<p>[character vector] repetition at which the effect should be assessed. By default it will be assessed at all repetitions.</p>
</td></tr>
<tr><td><code id="effects.lmm_+3A_multivariate">multivariate</code></td>
<td>
<p>[logical] should a multivariate Wald test be used to simultaneously test all null hypotheses.</p>
</td></tr>
<tr><td><code id="effects.lmm_+3A_prefix.time">prefix.time</code></td>
<td>
<p>[character] When naming the estimates, text to be pasted before the value of the repetition variable.
Only relevant when <code>type = "aoc"</code> or <code>type = "ate"</code>.</p>
</td></tr>
<tr><td><code id="effects.lmm_+3A_prefix.var">prefix.var</code></td>
<td>
<p>[logical] When naming the estimates, should the variable name be added or only the value?</p>
</td></tr>
<tr><td><code id="effects.lmm_+3A_sep.var">sep.var</code></td>
<td>
<p>[character] When naming the estimates, text to be pasted between the values to condition on.
Only relevant when <code>type = "aoc"</code> or <code>type = "ate"</code>.</p>
</td></tr>
<tr><td><code id="effects.lmm_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+anova.lmm">anova.lmm</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#### simulate data in the long format ####
set.seed(10)
dL &lt;- sampleRem(100, n.times = 3, format = "long")

#### Linear Mixed Model ####
eUN.lmm &lt;- lmm(Y ~ visit + X1 + X2 + X5,
               repetition = ~visit|id, structure = "UN", data = dL)

## outcome
effects(eUN.lmm, variable = "X1")
effects(eUN.lmm, type = "difference", variable = "X1")
effects(eUN.lmm, type = "difference", variable = "X1", repetition = "3")

## change
effects(eUN.lmm, type = "change", variable = "X1")
effects(eUN.lmm, type = "change", variable = "X1", conditional = NULL)
effects(eUN.lmm, type = c("change","difference"), variable = "X1")

## auc
effects(eUN.lmm, type = "auc", variable = "X1")
effects(eUN.lmm, type = c("auc","difference"), variable = "X1")

#### fit Linear Mixed Model with interaction ####
dL$X1.factor &lt;- as.factor(dL$X1)
dL$X2.factor &lt;- as.factor(dL$X2)
eUN.lmmI &lt;- lmm(Y ~ visit * X1.factor + X2.factor + X5,
               repetition = ~visit|id, structure = "UN", data = dL)

## average counterfactual conditional to a categorical covariate
effects(eUN.lmmI, variable = "X1.factor",
        conditional = c("X2.factor"), repetition = "3")
effects(eUN.lmmI, type = "change", variable = "X1.factor",
        conditional = c("X2.factor"), repetition = "3")
effects(eUN.lmmI, type = "auc", variable = "X1.factor",
        conditional = c("X2.factor"), repetition = "3")

## average difference in counterfactual conditional to a categorical covariate
effects(eUN.lmmI, type = "difference", variable = "X1.factor",
        conditional = c("X2.factor"), repetition = "3")
effects(eUN.lmmI, type = c("change","difference"), variable = "X1.factor",
        conditional = c("X2.factor"), repetition = "3")
effects(eUN.lmmI, type = c("auc","difference"), variable = "X1.factor",
        conditional = c("X2.factor"), repetition = "3")

## average difference in counterfactual conditional to a covariate
effects(eUN.lmmI, type = "difference", variable = "X1.factor",
        conditional = list(X5=0:2), repetition = "3")
effects(eUN.lmmI, type = c("difference","change"), variable = "X1.factor",
        conditional = list(X5=0:2))
</code></pre>

<hr>
<h2 id='estfun.lmm'>Extract the Score Function for Multcomp</h2><span id='topic+estfun.lmm'></span>

<h3>Description</h3>

<p>Extract the Score Function for Multcomp. For internal use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmm'
estfun(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estfun.lmm_+3A_x">x</code></td>
<td>
<p>a <code>lmm</code> object.</p>
</td></tr>
<tr><td><code id="estfun.lmm_+3A_...">...</code></td>
<td>
<p>Not used. For compatibility with the generic method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the score function for each model parameter (columns) relative to each cluster (rows).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simulate data in the long format
set.seed(10)
dL &lt;- sampleRem(100, n.times = 3, format = "long")

## fit Linear Mixed Model
eUN.lmm &lt;- lmm(Y ~ X1 + X2 + X5, repetition = ~visit|id, structure = "UN", data = dL, df = FALSE)

## test multiple linear hypotheses
if(require(multcomp)){
LMMstar.options(effects = c("mean"))
e.glht &lt;- multcomp::glht(eUN.lmm)
e.glht$linfct
}

</code></pre>

<hr>
<h2 id='estimate.lmm'>Delta Method for Mixed Models</h2><span id='topic+estimate.lmm'></span>

<h3>Description</h3>

<p>Perform a first order delta method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmm'
estimate(
  x,
  f,
  df = !is.null(x$df),
  robust = FALSE,
  type.information = NULL,
  level = 0.95,
  method.numDeriv = NULL,
  average = FALSE,
  transform.sigma = NULL,
  transform.k = NULL,
  transform.rho = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate.lmm_+3A_x">x</code></td>
<td>
<p>a <code>lmm</code> object.</p>
</td></tr>
<tr><td><code id="estimate.lmm_+3A_f">f</code></td>
<td>
<p>[function] function of the model coefficient computing the parameter(s) of interest. Can accept extra-arguments.</p>
</td></tr>
<tr><td><code id="estimate.lmm_+3A_df">df</code></td>
<td>
<p>[logical] Should degree of freedom, computed using Satterthwaite approximation, for the parameter of interest be output.
Can also be a numeric vector providing providing the degrees of freedom relative to each estimate.</p>
</td></tr>
<tr><td><code id="estimate.lmm_+3A_robust">robust</code></td>
<td>
<p>[logical] Should robust standard errors (aka sandwich estimator) be output instead of the model-based standard errors.</p>
</td></tr>
<tr><td><code id="estimate.lmm_+3A_type.information">type.information</code></td>
<td>
<p>[character] Should the expected information be used  (i.e. minus the expected second derivative) or the observed inforamtion (i.e. minus the second derivative).</p>
</td></tr>
<tr><td><code id="estimate.lmm_+3A_level">level</code></td>
<td>
<p>[numeric,0-1] the confidence level of the confidence intervals.</p>
</td></tr>
<tr><td><code id="estimate.lmm_+3A_method.numderiv">method.numDeriv</code></td>
<td>
<p>[character] method used to approximate the gradient: either <code>"simple"</code> or <code>"Richardson"</code>.
Passed to <code>numDeriv::jacobian</code>.</p>
</td></tr>
<tr><td><code id="estimate.lmm_+3A_average">average</code></td>
<td>
<p>[logical] is the estimand the average output of argument <code>f</code>?
Otherwise consider each individual output of argument <code>f</code>.</p>
</td></tr>
<tr><td><code id="estimate.lmm_+3A_transform.sigma">transform.sigma</code></td>
<td>
<p>[character] Transformation used on the variance coefficient for the reference level. One of <code>"none"</code>, <code>"log"</code>, <code>"square"</code>, <code>"logsquare"</code> - see details.</p>
</td></tr>
<tr><td><code id="estimate.lmm_+3A_transform.k">transform.k</code></td>
<td>
<p>[character] Transformation used on the variance coefficients relative to the other levels. One of <code>"none"</code>, <code>"log"</code>, <code>"square"</code>, <code>"logsquare"</code>, <code>"sd"</code>, <code>"logsd"</code>, <code>"var"</code>, <code>"logvar"</code> - see details.</p>
</td></tr>
<tr><td><code id="estimate.lmm_+3A_transform.rho">transform.rho</code></td>
<td>
<p>[character] Transformation used on the correlation coefficients. One of <code>"none"</code>, <code>"atanh"</code>, <code>"cov"</code> - see details.</p>
</td></tr>
<tr><td><code id="estimate.lmm_+3A_...">...</code></td>
<td>
<p>extra arguments passed to <code>f</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if(require(lava) &amp;&amp; require(nlme)){

#### Random effect ####
set.seed(10)
dL &lt;- sampleRem(1e2, n.times = 3, format = "long")
e.lmm1 &lt;- lmm(Y ~ X1+X2+X3 + (1|id), repetition = ~visit|id, data = dL)
nlme::ranef(e.lmm1, se = TRUE)
e.ranef &lt;- estimate(e.lmm1, f  = function(p){nlme::ranef(e.lmm1, p = p)})
e.ranef

if(require(ggplot2)){
df.gg &lt;- cbind(index = 1:NROW(e.ranef), e.ranef)
gg.ranef &lt;- ggplot(df.gg, aes(x = index, y=estimate, ymin=lower, ymax = upper))
gg.ranef + geom_point() + geom_errorbar() + ylab("estimated random effect") + xlab("id")
}

#### ANCOVA via mixed model ####
set.seed(10)
d &lt;- sampleRem(1e2, n.time = 2)
e.ANCOVA1 &lt;- lm(Y2~Y1+X1, data = d)

if(require(reshape2)){
   dL2 &lt;- melt(d, id.vars = c("id","X1"),  measure.vars = c("Y1","Y2"),
               value.name = "Y", variable.name = "time")
   dL2$time &lt;- factor(dL2$time, levels = c("Y1","Y2"), labels = c("1","2"))

   ## estimated treatment effect (no baseline constraint)
   e.lmm &lt;- lmm(Y ~ time + time:X1, data = dL2, repetition = ~time|id)

   e.delta &lt;- estimate(e.lmm, function(p){
       c(Y1 = p["rho(1,2)"]*p["k.2"],
         X1 = p["time2:X1"]-p["k.2"]*p["rho(1,2)"]*p["time1:X1"])
   }) ## same estimate and similar standard errors. 
   e.delta ## Degrees of freedom are a bit off though
   cbind(summary(e.ANCOVA1)$coef, df = df.residual(e.ANCOVA1))

   ## estimated treatment effect (baseline constraint)
   dL2$time2 &lt;- as.numeric(dL2$time=="2")
   e.lmmC &lt;- lmm(Y ~ time2 + time2:X1, data = dL2, repetition = ~time|id)
   e.deltaC &lt;- estimate(e.lmmC, function(p){
       c(Y1 = p["rho(1,2)"]*p["k.2"],
         X1 = p["time2:X1"])
   })
   e.deltaC ## Degrees of freedom are a bit more accurate
}

}
</code></pre>

<hr>
<h2 id='fitted.lmm'>Predicted Mean Value For Linear Mixed Model.</h2><span id='topic+fitted.lmm'></span>

<h3>Description</h3>

<p>Evaluate the expected mean conditional to covariates or the expected outcome values when missing conditional to observed outcome and covariates.
Similar to <code><a href="#topic+predict.lmm">predict.lmm</a></code> where the values to condition on are, by default, taking from the dataset used to fit the Linear Mixed Model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmm'
fitted(
  object,
  newdata = NULL,
  type = "mean",
  se = NULL,
  df = NULL,
  keep.data = NULL,
  format = "long",
  seed = NULL,
  simplify = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.lmm_+3A_object">object</code></td>
<td>
<p>a <code>lmm</code> object.</p>
</td></tr>
<tr><td><code id="fitted.lmm_+3A_newdata">newdata</code></td>
<td>
<p>[data.frame] the covariate values for each cluster.</p>
</td></tr>
<tr><td><code id="fitted.lmm_+3A_type">type</code></td>
<td>
<p>[character] By default fitted values are output (<code>NULL</code>).
Can also output the expected outcome (for missing outcomes) based on covariates and other outcome values from the same cluster (<code>"impute"</code>),
the change or expected change between baseline and each follow-up (<code>"change"</code>),
or the area under the curve of the outcome (<code>"auc"</code>, require a numeric repetition variable).</p>
</td></tr>
<tr><td><code id="fitted.lmm_+3A_se">se</code></td>
<td>
<p>[character] passed to <code>predict.lmm</code> to evaluate the standard error of the fitted value, expected outcome, change in expected outcome, or area under the curve.</p>
</td></tr>
<tr><td><code id="fitted.lmm_+3A_df">df</code></td>
<td>
<p>[logical] should a Student's t-distribution be used to model the distribution of the predicted mean. Otherwise a normal distribution is used.</p>
</td></tr>
<tr><td><code id="fitted.lmm_+3A_keep.data">keep.data</code></td>
<td>
<p>[logical] Should the dataset relative to which the predictions are evaluated be output along side the predicted values?
Only possible in the long format.</p>
</td></tr>
<tr><td><code id="fitted.lmm_+3A_format">format</code></td>
<td>
<p>[character] Should the prediction be output
in a matrix format with clusters in row and timepoints in columns (<code>"wide"</code>),
or in a data.frame/vector with as many rows as observations (<code>"long"</code>)</p>
</td></tr>
<tr><td><code id="fitted.lmm_+3A_seed">seed</code></td>
<td>
<p>[integer, &gt;0] Random number generator (RNG) state used when starting imputation. If NULL no state is set.</p>
</td></tr>
<tr><td><code id="fitted.lmm_+3A_simplify">simplify</code></td>
<td>
<p>[logical] Simplify the data format (vector instead of data.frame) and column names (no mention of the time variable) when possible.</p>
</td></tr>
<tr><td><code id="fitted.lmm_+3A_...">...</code></td>
<td>
<p>Additional argument passed the <code><a href="#topic+predict.lmm">predict.lmm</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When <code>format="wide"</code>, a data.frame with as many rows as clusters.
When <code>format="long"</code>, a data.frame with as many rows as observations (<code>keep.data==TRUE</code>)
or a vector of length the number of observations (<code>keep.data==TRUE</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### single arm trial ####
data(gastricbypassL, package = "LMMstar")
gastricbypassL &lt;- gastricbypassL[order(gastricbypassL$id,gastricbypassL$visit),]
gastricbypassL$weight0 &lt;- unlist(tapply(gastricbypassL$weight,gastricbypassL$id,
function(x){rep(x[1],length(x))}))

eUN.lmm &lt;- lmm(glucagonAUC ~ visit + weight0, repetition = ~visit|id,
               data = gastricbypassL, df = FALSE)

## fitted mean (conditional on covariates only)
fitted(eUN.lmm)
fitted(eUN.lmm, newdata = data.frame(visit = "3", weight0 = 0))
fitted(eUN.lmm, newdata = data.frame(visit = "3", weight0 = 0),
       keep.data = TRUE)

## fitted outcome value (conditional on covariates and covariates)
fitted(eUN.lmm, type = "outcome")
gastricbypassL.O &lt;- fitted(eUN.lmm, type = "outcome", keep.data = TRUE)

if(require(ggplot2)){
gg.outcome &lt;- ggplot(gastricbypassL.O,
                     aes(x=time, y = glucagonAUC, color = impute, group = id))
gg.outcome &lt;- gg.outcome + geom_point() + geom_line()## + facet_wrap(~id)
gg.outcome
}

tapply(gastricbypassL.O$glucagonAUC, gastricbypassL.O$time, mean)
effects(eUN.lmm, variable = NULL)

## fitted change value (conditional on covariates and covariates)
gastricbypassL.C &lt;- fitted(eUN.lmm, type = "change", keep.data = TRUE)

if(require(ggplot2)){
gg.change &lt;- ggplot(gastricbypassL.C,
                    aes(x=time, y = glucagonAUC, color = impute, group = id))
gg.change &lt;- gg.change + geom_point() + geom_line()
gg.change
}

tapply(gastricbypassL.C$glucagonAUC, gastricbypassL.O$time, mean)
effects(eUN.lmm, type = "change", variable = NULL)

## fitted auc (conditional on covariates and covariates)
gastricbypassL.AUC &lt;- fitted(eUN.lmm, type = "auc", keep.data = TRUE)

if(require(ggplot2)){
gg.auc &lt;- ggplot(gastricbypassL.AUC,
                    aes(x = "auc", y = glucagonAUC, color = impute))
gg.auc &lt;- gg.auc + geom_point()
gg.auc
}

mean(gastricbypassL.AUC$glucagonAUC)
effects(eUN.lmm, type = "auc", variable = NULL)

#### two arm trial ####
## Not run: 
if(require(nlmeU) &amp; require(reshape2)){
data(armd.wide, package = "nlmeU")
armd.long &lt;- melt(armd.wide,
                  measure.vars = paste0("visual",c(0,4,12,24,52)),
                  id.var = c("subject","lesion","treat.f","miss.pat"),
                  variable.name = "week",
                  value.name = "visual")

armd.long$week &lt;- factor(armd.long$week, 
                         level = paste0("visual",c(0,4,12,24,52)),
                         labels = c(0,4,12,24,52))

eUN2.lmm &lt;- lmm(visual ~ treat.f*week + lesion,
               repetition = ~week|subject, structure = "UN",
               data = armd.long)

## fitted outcome value (conditional on covariates and covariates)
armd.O &lt;- fitted(eUN2.lmm, type = "outcome", keep.data = TRUE)

gg2.outcome &lt;- ggplot(armd.O,
                     aes(x=week, y = visual, color = impute, group = subject))
gg2.outcome &lt;- gg2.outcome + geom_point() + geom_line() + facet_wrap(~treat.f)
gg2.outcome

aggregate(visual ~ week + treat.f, FUN = mean, data = armd.O)
effects(eUN2.lmm, variable = "treat.f") ## mismatch due to adjustment on lesion

## fitted change value (conditional on covariates and covariates)
armd.C &lt;- fitted(eUN2.lmm, type = "change", keep.data = TRUE)

gg.change &lt;- ggplot(armd.C,
                    aes(x=week, y = visual, color = impute, group = subject))
gg.change &lt;- gg.change + geom_point() + geom_line() + facet_wrap(~treat.f)
gg.change

coef(eUN2.lmm)
effects(eUN2.lmm, type = "change", variable = "treat.f")
effects(eUN2.lmm, type = c("change","difference"), variable = "treat.f")

## fitted auc (conditional on covariates and covariates)
armd.AUC &lt;- fitted(eUN2.lmm, type = "auc", keep.data = TRUE)

gg.auc &lt;- ggplot(armd.AUC, aes(x = treat.f, y = visual, color = impute))
gg.auc &lt;- gg.auc + geom_point()
gg.auc

aggregate(visual ~ treat.f, data = armd.AUC, FUN = "mean")
effects(eUN2.lmm, type = "auc", variable = "treat.f") ## adjusted for lesion
effects(eUN2.lmm, type = c("auc","difference"), variable = "treat.f")
}
## End(Not run)
</code></pre>

<hr>
<h2 id='gastricbypassL'>Data From The Gastric Bypass Study (Long Format)</h2><span id='topic+gastricbypassL'></span>

<h3>Description</h3>

<p>Data from the gastric bypass study
where the bodyweight and serum glucagon (a gut hormone) were measured in 20 obese subjects prior and after gastric bypass surgery.
This dataset is in the long format (i.e. one line per measurement).
</p>

<ul>
<li> <p><code>id</code>: patient identifier.
</p>
</li>
<li> <p><code>visit</code>: the visit index (factor).
</p>
</li>
<li> <p><code>time</code>: the week at which the visit took place (numeric).
</p>
</li>
<li> <p><code>weight</code>: bodyweight (in kg) measured during the visit.
</p>
</li>
<li> <p><code>glucagonAUC</code>: glucagon measured during the visit.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(gastricbypassL)
</code></pre>


<h3>References</h3>

<p>The effect of Roux-en-Y gastric bypass surgery on the gut mucosal gene expression profile and circulating gut hormones. <a href="https://easddistribute.m-anage.com/from.storage?image=4iBH9mRQm1kfeEHULC2CxovdlyCtA1EHeVDdoffnZrAUGG9SHTO-U4ItnLU078eVkF1ZUZgYTy7THlTW3KSgFA2">https://easddistribute.m-anage.com/from.storage?image=4iBH9mRQm1kfeEHULC2CxovdlyCtA1EHeVDdoffnZrAUGG9SHTO-U4ItnLU078eVkF1ZUZgYTy7THlTW3KSgFA2</a>
</p>

<hr>
<h2 id='gastricbypassW'>Data From The Gastric Bypass Study (Wide Format)</h2><span id='topic+gastricbypassW'></span>

<h3>Description</h3>

<p>Data from the gastric bypass study
where the bodyweight and serum glucagon (a gut hormone) were measured in 20 obese subjects prior and after gastric bypass surgery.
This dataset is in the wide format (i.e. one line per patient).
</p>

<ul>
<li> <p><code>id</code>: patient identifier.
</p>
</li>
<li> <p><code>weight1</code>: bodyweight (in kg) 3 months before surgery.
</p>
</li>
<li> <p><code>weight2</code>: bodyweight (in kg) 1 week before surgery.
</p>
</li>
<li> <p><code>weight3</code>: bodyweight (in kg) 1 week after surgery.
</p>
</li>
<li> <p><code>weight4</code>: bodyweight (in kg) 3 months after surgery.
</p>
</li>
<li> <p><code>glucagonAUC1</code>: glucagon  (in pmol/l x hours) 3 months before surgery.
</p>
</li>
<li> <p><code>glucagonAUC2</code>: glucagon  (in pmol/l x hours) 1 week before surgery.
</p>
</li>
<li> <p><code>glucagonAUC3</code>: glucagon  (in pmol/l x hours) 1 week after surgery.
</p>
</li>
<li> <p><code>glucagonAUC4</code>: glucagon  (in pmol/l x hours) 3 months after surgery.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(gastricbypassW)
</code></pre>


<h3>References</h3>

<p>The effect of Roux-en-Y gastric bypass surgery on the gut mucosal gene expression profile and circulating gut hormones. <a href="https://easddistribute.m-anage.com/from.storage?image=4iBH9mRQm1kfeEHULC2CxovdlyCtA1EHeVDdoffnZrAUGG9SHTO-U4ItnLU078eVkF1ZUZgYTy7THlTW3KSgFA2">https://easddistribute.m-anage.com/from.storage?image=4iBH9mRQm1kfeEHULC2CxovdlyCtA1EHeVDdoffnZrAUGG9SHTO-U4ItnLU078eVkF1ZUZgYTy7THlTW3KSgFA2</a>
</p>

<hr>
<h2 id='ID'>identity Structure</h2><span id='topic+ID'></span>

<h3>Description</h3>

<p>Variance-covariance structure where the residuals are independent and identically distributed.
Can be stratified on a categorical variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ID(formula, var.cluster, var.time, add.time)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ID_+3A_formula">formula</code></td>
<td>
<p>formula indicating on which variable to stratify the residual variance (left hand side).</p>
</td></tr>
<tr><td><code id="ID_+3A_var.cluster">var.cluster</code></td>
<td>
<p>[character] cluster variable.</p>
</td></tr>
<tr><td><code id="ID_+3A_var.time">var.time</code></td>
<td>
<p>[character] time variable.</p>
</td></tr>
<tr><td><code id="ID_+3A_add.time">add.time</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A typical formula would be <code>~1</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>IND</code> that can be passed to the argument <code>structure</code> of the <code>lmm</code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ID(NULL, var.cluster = "id", var.time = "time")
ID(~1, var.cluster = "id", var.time = "time")
ID(~gender, var.cluster = "id", var.time = "time")
ID(gender~1, var.cluster = "id", var.time = "time")
</code></pre>

<hr>
<h2 id='iid.lmm'>Extract the Influence Function From a Linear Mixed Model</h2><span id='topic+iid.lmm'></span>

<h3>Description</h3>

<p>Extract the influence function from a linear mixed model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmm'
iid(
  x,
  effects = "mean",
  robust = TRUE,
  type.information = NULL,
  transform.sigma = NULL,
  transform.k = NULL,
  transform.rho = NULL,
  transform.names = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iid.lmm_+3A_x">x</code></td>
<td>
<p>a <code>lmm</code> object.</p>
</td></tr>
<tr><td><code id="iid.lmm_+3A_effects">effects</code></td>
<td>
<p>[character] Should the variance-covariance matrix for all coefficients be output (<code>"all"</code>),
or only for coefficients relative to the mean (<code>"mean"</code> or <code>"fixed"</code>),
or only for coefficients relative to the variance structure (<code>"variance"</code>),
or only for coefficients relative to the correlation structure (<code>"correlation"</code>).</p>
</td></tr>
<tr><td><code id="iid.lmm_+3A_robust">robust</code></td>
<td>
<p>[logical] If <code>FALSE</code> the influence function is rescaled to match the model-based standard errors.
The correlation however will not (necessarily) match the model-based correlation.</p>
</td></tr>
<tr><td><code id="iid.lmm_+3A_type.information">type.information</code></td>
<td>
<p>[character] Should the expected information be used  (i.e. minus the expected second derivative) or the observed inforamtion (i.e. minus the second derivative).</p>
</td></tr>
<tr><td><code id="iid.lmm_+3A_transform.sigma">transform.sigma</code></td>
<td>
<p>[character] Transformation used on the variance coefficient for the reference level. One of <code>"none"</code>, <code>"log"</code>, <code>"square"</code>, <code>"logsquare"</code> - see details.</p>
</td></tr>
<tr><td><code id="iid.lmm_+3A_transform.k">transform.k</code></td>
<td>
<p>[character] Transformation used on the variance coefficients relative to the other levels. One of <code>"none"</code>, <code>"log"</code>, <code>"square"</code>, <code>"logsquare"</code>, <code>"sd"</code>, <code>"logsd"</code>, <code>"var"</code>, <code>"logvar"</code> - see details.</p>
</td></tr>
<tr><td><code id="iid.lmm_+3A_transform.rho">transform.rho</code></td>
<td>
<p>[character] Transformation used on the correlation coefficients. One of <code>"none"</code>, <code>"atanh"</code>, <code>"cov"</code> - see details.</p>
</td></tr>
<tr><td><code id="iid.lmm_+3A_transform.names">transform.names</code></td>
<td>
<p>[logical] Should the name of the coefficients be updated to reflect the transformation that has been used?</p>
</td></tr>
<tr><td><code id="iid.lmm_+3A_...">...</code></td>
<td>
<p>Not used. For compatibility with the generic method.</p>
</td></tr>
</table>

<hr>
<h2 id='IND'>Independence Structure</h2><span id='topic+IND'></span>

<h3>Description</h3>

<p>Variance-covariance structure where the residuals are independent but may have different variance.
Can be stratified on a categorical variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IND(formula, var.cluster, var.time, add.time)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IND_+3A_formula">formula</code></td>
<td>
<p>formula indicating variables influencing the residual variance,
using either as a multiplicative factor (right hand side) or stratification (left hand side) to model their effect.</p>
</td></tr>
<tr><td><code id="IND_+3A_var.cluster">var.cluster</code></td>
<td>
<p>[character] cluster variable.</p>
</td></tr>
<tr><td><code id="IND_+3A_var.time">var.time</code></td>
<td>
<p>[character] time variable.</p>
</td></tr>
<tr><td><code id="IND_+3A_add.time">add.time</code></td>
<td>
<p>Should the default formula (i.e. when <code>NULL</code>) contain a time effect.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A typical formula would be either <code>~1</code> indicating constant variance
or <code>~time</code> indicating a time dependent variance.
</p>


<h3>Value</h3>

<p>An object of class <code>IND</code> that can be passed to the argument <code>structure</code> of the <code>lmm</code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>IND(NULL, var.cluster = "id", var.time = "time", add.time = TRUE)
IND(~1, var.cluster = "id", var.time = "time")
IND(gender~1, var.cluster = "id", var.time = "time")
IND(gender~time, var.cluster = "id", var.time = "time")
IND(~gender+time, var.cluster = "id", var.time = "time")

</code></pre>

<hr>
<h2 id='information.lmm'>Extract The Information From a Linear Mixed Model</h2><span id='topic+information.lmm'></span>

<h3>Description</h3>

<p>Extract or compute the (expected) second derivative of the log-likelihood of a linear mixed model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmm'
information(
  x,
  effects = NULL,
  newdata = NULL,
  p = NULL,
  indiv = FALSE,
  type.information = NULL,
  transform.sigma = NULL,
  transform.k = NULL,
  transform.rho = NULL,
  transform.names = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="information.lmm_+3A_x">x</code></td>
<td>
<p>a <code>lmm</code> object.</p>
</td></tr>
<tr><td><code id="information.lmm_+3A_effects">effects</code></td>
<td>
<p>[character] Should the information relative to all coefficients be output (<code>"all"</code> or <code>"fixed"</code>),
or only coefficients relative to the mean (<code>"mean"</code>),
or only coefficients relative to the variance and correlation structure (<code>"variance"</code> or <code>"correlation"</code>).</p>
</td></tr>
<tr><td><code id="information.lmm_+3A_newdata">newdata</code></td>
<td>
<p>[data.frame] dataset relative to which the information should be computed. Only relevant if differs from the dataset used to fit the model.</p>
</td></tr>
<tr><td><code id="information.lmm_+3A_p">p</code></td>
<td>
<p>[numeric vector] value of the model coefficients at which to evaluate the information. Only relevant if differs from the fitted values.</p>
</td></tr>
<tr><td><code id="information.lmm_+3A_indiv">indiv</code></td>
<td>
<p>[logical] Should the contribution of each cluster to the information be output? Otherwise output the sum of all clusters of the derivatives.</p>
</td></tr>
<tr><td><code id="information.lmm_+3A_type.information">type.information</code></td>
<td>
<p>[character] Should the expected information be computed  (i.e. minus the expected second derivative) or the observed inforamtion (i.e. minus the second derivative).</p>
</td></tr>
<tr><td><code id="information.lmm_+3A_transform.sigma">transform.sigma</code></td>
<td>
<p>[character] Transformation used on the variance coefficient for the reference level. One of <code>"none"</code>, <code>"log"</code>, <code>"square"</code>, <code>"logsquare"</code> - see details.</p>
</td></tr>
<tr><td><code id="information.lmm_+3A_transform.k">transform.k</code></td>
<td>
<p>[character] Transformation used on the variance coefficients relative to the other levels. One of <code>"none"</code>, <code>"log"</code>, <code>"square"</code>, <code>"logsquare"</code>, <code>"sd"</code>, <code>"logsd"</code>, <code>"var"</code>, <code>"logvar"</code> - see details.</p>
</td></tr>
<tr><td><code id="information.lmm_+3A_transform.rho">transform.rho</code></td>
<td>
<p>[character] Transformation used on the correlation coefficients. One of <code>"none"</code>, <code>"atanh"</code>, <code>"cov"</code> - see details.</p>
</td></tr>
<tr><td><code id="information.lmm_+3A_transform.names">transform.names</code></td>
<td>
<p>[logical] Should the name of the coefficients be updated to reflect the transformation that has been used?</p>
</td></tr>
<tr><td><code id="information.lmm_+3A_...">...</code></td>
<td>
<p>Not used. For compatibility with the generic method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details about the arguments <b>transform.sigma</b>, <b>transform.k</b>, <b>transform.rho</b>, see the documentation of the <a href="#topic+coef.lmm">coef.lmm</a> function.
</p>


<h3>Value</h3>

<p>When argument indiv is <code>FALSE</code>, a matrix with the value of the infroamtion relative to each pair of coefficient (in rows and columns) and each cluster (in rows).
When argument indiv is <code>TRUE</code>, a 3-dimensional array with the value of the information relative to each pair of coefficient (dimension 2 and 3) and each cluster (dimension 1).
</p>

<hr>
<h2 id='levels.lmm'>Contrasts and Reference Level</h2><span id='topic+levels.lmm'></span>

<h3>Description</h3>

<p>Contrasts and reference level used when modeling the mean in a linear mixed modek.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmm'
levels(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="levels.lmm_+3A_x">x</code></td>
<td>
<p>an <code>lmm</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with two elements </p>

<ul>
<li><p> all: contrast matrix for each categorical or factor variable
</p>
</li>
<li><p> reference: reference level: one value for each categorical variable
</p>
</li></ul>


<hr>
<h2 id='lmm'>Fit Linear Mixed Model</h2><span id='topic+lmm'></span>

<h3>Description</h3>

<p>Fit a linear mixed model defined by a mean and a covariance structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmm(
  formula,
  repetition,
  structure,
  data,
  weights = NULL,
  scale.Omega = NULL,
  method.fit = NULL,
  df = NULL,
  type.information = NULL,
  trace = NULL,
  control = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmm_+3A_formula">formula</code></td>
<td>
<p>[formula] Specify the model for the mean.
On the left hand side the outcome and on the right hand side the covariates affecting the mean value.
E.g. Y ~ Gender + Gene.</p>
</td></tr>
<tr><td><code id="lmm_+3A_repetition">repetition</code></td>
<td>
<p>[formula] Specify the structure of the data: the time/repetition variable and the grouping variable, e.g. ~ time|id.</p>
</td></tr>
<tr><td><code id="lmm_+3A_structure">structure</code></td>
<td>
<p>[character] type of covariance structure, either <code>"CS"</code> (compound symmetry) or <code>"UN"</code> (unstructured).</p>
</td></tr>
<tr><td><code id="lmm_+3A_data">data</code></td>
<td>
<p>[data.frame] dataset (in the long format) containing the observations.</p>
</td></tr>
<tr><td><code id="lmm_+3A_weights">weights</code></td>
<td>
<p>[formula or character] variable in the dataset used to weight the log-likelihood and its derivative. Should be constant within cluster.</p>
</td></tr>
<tr><td><code id="lmm_+3A_scale.omega">scale.Omega</code></td>
<td>
<p>[formula or character] variable in the dataset used to rescale the residual variance-covariance matrix. Should be constant within cluster.</p>
</td></tr>
<tr><td><code id="lmm_+3A_method.fit">method.fit</code></td>
<td>
<p>[character] Should Restricted Maximum Likelihoood (<code>"REML"</code>) or Maximum Likelihoood (<code>"ML"</code>) be used to estimate the model parameters?</p>
</td></tr>
<tr><td><code id="lmm_+3A_df">df</code></td>
<td>
<p>[logical] Should the degree of freedom be computed using a Satterthwaite approximation?</p>
</td></tr>
<tr><td><code id="lmm_+3A_type.information">type.information</code></td>
<td>
<p>[character] Should the expected information be computed  (i.e. minus the expected second derivative) or the observed inforamtion (i.e. minus the second derivative).</p>
</td></tr>
<tr><td><code id="lmm_+3A_trace">trace</code></td>
<td>
<p>[interger, &gt;0] Show the progress of the execution of the function.</p>
</td></tr>
<tr><td><code id="lmm_+3A_control">control</code></td>
<td>
<p>[list] Control values for the optimization method.
The element <code>optimizer</code> indicates which optimizer to use and additional argument will be pass to the optimizer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>Computation time</b> the <code>lmm</code> has not been developped to be a fast function as, by default, it uses REML estimation with the observed information matrix and uses a Satterthwaite approximation to compute degrees of freedom (this require to compute the third derivative of the log-likelihood which is done by numerical differentiation). The computation time can be substantially reduced by using ML estimation with the expected information matrix and no calculation of degrees of freedom: arguments <code>method.fit="ML"</code>, <code>type.information="expected"</code>, <code>df=FALSE</code>. This will, however, lead to less accurate p-values and confidence intervals in small samples.
</p>
<p>By default, the estimation of the model parameters will be made using a Newton Raphson algorithm.
This algorithm does not ensure that the residual covariance matrix is positive definite and therefore may sometimes fail.
See argument optimizer in <code><a href="#topic+LMMstar.options">LMMstar.options</a></code>.
</p>
<p><b>Argument control:</b> when using the optimizer <code>"FS"</code>, the following elements can be used
</p>

<ul>
<li> <p><code>init</code>: starting values for the model parameters.
</p>
</li>
<li> <p><code>n.iter</code>: maximum number of interations of the optimization algorithm.
</p>
</li>
<li> <p><code>tol.score</code>: score value below which convergence has been reached.
</p>
</li>
<li> <p><code>tol.param</code>: difference in estimated parameters from two successive iterations below which convergence has been reached.
</p>
</li>
<li> <p><code>trace</code>: display progress of the optimization procedure.
</p>
</li></ul>

<p><b>Argument repetition:</b> when numeric, it will be converted into a factor variable, possibly adding a leading 0 to preserve the ordering.
This transformation may cause inconsistency when combining results between different <code>lmm</code> object. 
This is why the grouping variable should preferably be of type character or factor.
</p>


<h3>Value</h3>

<p>an object of class <code>lmm</code> containing the estimated parameter values, the residuals, and relevant derivatives of the likelihood.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.lmm">summary.lmm</a></code> for a summary of the model fit. <br />
<code><a href="#topic+model.tables.lmm">model.tables.lmm</a></code> for a data.frame containing estimates with their uncertainty. <br />
<code><a href="#topic+plot.lmm">plot.lmm</a></code> for a graphical display of the model fit or diagnostic plots. <br />
<code><a href="#topic+levels.lmm">levels.lmm</a></code> to display the reference level. <br />
<code><a href="#topic+anova.lmm">anova.lmm</a></code> for testing linear combinations of coefficients (F-test, multiple Wald tests) <br />
<code><a href="#topic+effects.lmm">effects.lmm</a></code> for evaluating average marginal or counterfactual effects <br />
<code><a href="#topic+sigma.lmm">sigma.lmm</a></code> for extracting estimated residual variance-covariance matrices. <br />
<code><a href="#topic+residuals.lmm">residuals.lmm</a></code> for extracting residuals or creating residual plots (e.g. qqplots). <br />
<code><a href="#topic+predict.lmm">predict.lmm</a></code> for evaluating mean and variance of the outcome conditional on covariates or other outcome values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### 1- simulate data in the long format ####
set.seed(10)
dL &lt;- sampleRem(100, n.times = 3, format = "long")
dL$X1 &lt;- as.factor(dL$X1)
dL$X2 &lt;- as.factor(dL$X2)

#### 2- fit Linear Mixed Model ####
eCS.lmm &lt;- lmm(Y ~ X1 * X2 + X5, repetition = ~visit|id, structure = "CS", data = dL)

logLik(eCS.lmm) ## -670.9439
summary(eCS.lmm)


#### 3- estimates ####
## reference level
levels(eCS.lmm)$reference
## mean parameters
coef(eCS.lmm)
model.tables(eCS.lmm)
confint(eCS.lmm)

## all parameters
coef(eCS.lmm, effects = "all")
model.tables(eCS.lmm, effects = "all")
confint(eCS.lmm, effects = "all")

## variance-covariance structure
sigma(eCS.lmm)

#### 4- diagnostic plots ####
quantile(residuals(eCS.lmm))
quantile(residuals(eCS.lmm, type = "normalized"))

## Not run: 
if(require(ggplot2)){
  ## investigate misspecification of the mean structure
  plot(eCS.lmm, type = "scatterplot")
  ## investigate misspecification of the variance structure
  plot(eCS.lmm, type = "scatterplot2")
  ## investigate misspecification of the correlation structure
  plot(eCS.lmm, type = "correlation")
  ## investigate misspecification of the residual distribution
  plot(eCS.lmm, type = "qqplot")
}

## End(Not run)

#### 5- statistical inference ####
anova(eCS.lmm) ## effect of each variable
anova(eCS.lmm, effects = "X11-X21=0") ## test specific coefficient
## test several hypothese with adjustment for multiple comparisons
summary(anova(eCS.lmm, effects = c("X11=0","X21=0")))

#### 6- prediction ####
## conditional on covariates
newd &lt;- dL[1:3,]
predict(eCS.lmm, newdata = newd, keep.data = TRUE)
## conditional on covariates and outcome
newd &lt;- dL[1:3,]
newd$Y[3] &lt;- NA
predict(eCS.lmm, newdata = newd, type = "dynamic", keep.data = TRUE)

#### EXTRA ####
if(require(mvtnorm)){
## model for the average over m replicates
## (only works with independent replicates)
Sigma1 &lt;- diag(1,1,1); Sigma5 &lt;- diag(1,5,5)
n &lt;- 100
dfW &lt;- rbind(data.frame(id = 1:n, rep = 5, Y = rowMeans(rmvnorm(n, sigma = Sigma5))),
             data.frame(id = (n+1):(2*n), rep = 1, Y = rmvnorm(n, sigma = Sigma1)))

e.lmmW &lt;- lmm(Y~1, data = dfW, scale.Omega=~rep, control = list(optimizer = "FS"))
e.lmm0 &lt;- lmm(Y~1, data = dfW, control = list(optimizer = "FS"))
model.tables(e.lmmW, effects = "all")
model.tables(e.lmm0, effects = "all")
## TRUE standard error is 1

}

</code></pre>

<hr>
<h2 id='lmmCC'>Fit Linear Mixed Model on Complete Case data</h2><span id='topic+lmmCC'></span><span id='topic+lmmCC.formula'></span><span id='topic+lmmCC.lm'></span>

<h3>Description</h3>

<p>Fit a linear mixed model on the complete case data.
Mostly useful as a sanity check, to match the results of a univariate analysis on the change.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmmCC(object, ...)

## S3 method for class 'formula'
lmmCC(
  object,
  repetition,
  data,
  lm.change = FALSE,
  df = NULL,
  trace = TRUE,
  control = NULL,
  ...
)

## S3 method for class 'lm'
lmmCC(
  object,
  repetition,
  data,
  name.time = "time",
  df = NULL,
  trace = TRUE,
  control = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmmCC_+3A_object">object</code></td>
<td>
<p>[formula] Specify the model for the mean.
On the left hand side the outcome and on the right hand side the covariates affecting the mean value.
E.g. Y ~ Gender + Gene.</p>
</td></tr>
<tr><td><code id="lmmCC_+3A_...">...</code></td>
<td>
<p>Not used. For compatibility with the generic method.</p>
</td></tr>
<tr><td><code id="lmmCC_+3A_repetition">repetition</code></td>
<td>
<p>[formula] Specify the structure of the data: the time/repetition variable and the grouping variable, e.g. ~ time|id.</p>
</td></tr>
<tr><td><code id="lmmCC_+3A_data">data</code></td>
<td>
<p>[data.frame] dataset (in the long format) containing the observations.</p>
</td></tr>
<tr><td><code id="lmmCC_+3A_lm.change">lm.change</code></td>
<td>
<p>[logical] Should a linear model on the change in outcome be estimated. Only possible with two repetitions.
Will match the mixed model if the later includes repetition-dependent effects for all covariates.</p>
</td></tr>
<tr><td><code id="lmmCC_+3A_df">df</code></td>
<td>
<p>[logical] Should the degree of freedom be computed using a Satterthwaite approximation?</p>
</td></tr>
<tr><td><code id="lmmCC_+3A_trace">trace</code></td>
<td>
<p>[interger, &gt;0] Show the progress of the execution of the function.</p>
</td></tr>
<tr><td><code id="lmmCC_+3A_control">control</code></td>
<td>
<p>[list] Control values for the optimization method.
The element <code>optimizer</code> indicates which optimizer to use and additional argument will be pass to the optimizer.</p>
</td></tr>
<tr><td><code id="lmmCC_+3A_name.time">name.time</code></td>
<td>
<p>[character] name of the time variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>lmmCC</code> object, which inherits from <code>lmm</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### 1- simulate data in the wide format ####
set.seed(10)
dW &lt;- sampleRem(100, n.times = 3, format = "wide")
dW$Y3[1:10] &lt;- NA
dW$change2 &lt;- dW$Y2 - dW$Y1
dW$change3 &lt;- dW$Y3 - dW$Y1

e.lm2 &lt;- lm(change2 ~ X1 + X2, data = dW)
summary(e.lm2)$coef
e.lm3 &lt;- lm(change3 ~ X1 + X2, data = dW)
summary(e.lm3)$coef

#### 2- complete case LMM from LM ####
e.lmmCC2 &lt;- lmmCC(e.lm2, repetition = change2~Y2-Y1)
model.tables(e.lmmCC2)
e.lmmCC3 &lt;- lmmCC(e.lm3, repetition = change3~Y3-Y1)
model.tables(e.lmmCC3)

#### 3- complete case LMM ####
dL &lt;- reshape(dW[,c("id","X1","X2","Y1","Y2","Y3")],
              direction = "long", 
              varying = c("Y1","Y2","Y3"), sep = "", idvar = "id")
dL$time &lt;- as.character(dL$time)

e.lmm2 &lt;- lmmCC(Y ~ time + time*X1 + time*X2, repetition = ~time|id,
                data = dL[dL$time %in% 1:2,])
model.tables(e.lmm2)
e.lmm3.bis &lt;- lmmCC(Y ~ time + time*X1 + time*X2, repetition = ~time|id,
                data = dL[dL$time %in% c(1,3),], lm.change = TRUE)
model.tables(e.lmm3.bis)
e.lmm3.bis$lm.change

</code></pre>

<hr>
<h2 id='LMMstar.options'>Global options for LMMstar package</h2><span id='topic+LMMstar.options'></span>

<h3>Description</h3>

<p>Update or select global options for the LMMstar package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LMMstar.options(..., reinitialise = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LMMstar.options_+3A_...">...</code></td>
<td>
<p>options to be selected or updated</p>
</td></tr>
<tr><td><code id="LMMstar.options_+3A_reinitialise">reinitialise</code></td>
<td>
<p>should all the global parameters be set to their default value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The options are: </p>

<ul>
<li><p> backtransform.confint [logical]: should variance/covariance/correlation estimates be back-transformed when they are transformed on the log or atanh scale. Used by <code>confint</code>.
</p>
</li>
<li><p> columns.anova [character vector]: columns to ouput when using <code>anova</code> with argument <code>ci=TRUE</code>.
</p>
</li>
<li><p> columns.confint [character vector]: columns to ouput when using <code>confint</code>.
</p>
</li>
<li><p> columns.summary [character vector]: columns to ouput when displaying the model coefficients using <code>summary</code>.
</p>
</li>
<li><p> df [logical]: should approximate degrees of freedom be computed for Wald and F-tests. Used by <code>lmm</code>, <code>anova</code>, <code>predict</code>, and <code>confint</code>.
</p>
</li>
<li><p> drop.X [logical]: should columns causing non-identifiability of the model coefficients be dropped from the design matrix. Used by <code>lmm</code>.
</p>
</li>
<li><p> effects [character]: parameters relative to which estimates, score, information should be output.
</p>
</li>
<li><p> min.df [integer]: minimum possible degree of freedom. Used by <code>confint</code>.
</p>
</li>
<li><p> method.fit [character]: objective function when fitting the Linear Mixed Model (REML or ML). Used by <code>lmm</code>.
</p>
</li>
<li><p> method.numDeriv [character]: type used to approximate the third derivative of the log-likelihood (when computing the degrees of freedom). Can be <code>"simple"</code> or <code>"Richardson"</code>. See <code>numDeriv::jacobian</code> for more details. Used by <code>lmm</code>.
</p>
</li>
<li><p> n.sampleCopula [integer]: number of samples used to compute confidence intervals and p-values adjusted for multiple comparisons via <code>"single-step2"</code>. Used by <code>confint.Wald_lmm</code>.
</p>
</li>
<li><p> optimizer [character]: method used to estimate the model parameters. Either <code>"FS"</code>, an home-made fisher scoring algorithm, or a method from <code>optimx:optimx</code> like <code>"BFGS"</code>or <code>Nelder-Mead</code>.
</p>
</li>
<li><p> param.optimizer [numeric vector]: default option for the <code>FS</code> optimization routine: maximum number of gradient descent iterations (<code>n.iter</code>), maximum acceptable score value (<code>tol.score</code>), maximum acceptable change in parameter value (<code>tol.param</code>).
</p>
</li>
<li><p> precompute.moments [logical]: Should the cross terms between the residuals and design matrix be pre-computed. Useful when the number of subject is substantially larger than the number of mean paramters.
</p>
</li>
<li><p> sep [character vector]: character used to combined two strings of characters in various functions (lp: .vcov.model.matrix, k.cov/k.strata: .skeletonK, pattern: .findUpatterns, rho.name/rho.strata: .skeletonRho, reformat: .reformat ).
</p>
</li>
<li><p> trace [logical]: Should the progress of the execution of the <code>lmm</code> function be displayed?
</p>
</li>
<li><p> tranform.sigma, tranform.k, tranform.rho: transformation used to compute the confidence intervals/p-values for the variance and correlation parameters. See the detail section of the coef function for more information.
Used by <code>lmm</code>, <code>anova</code> and <code>confint</code>.
</p>
</li>
<li><p> type.information [character]: Should the expected or observed information (<code>"expected"</code> or <code>"observed"</code>) be used to perform statistical inference? Used by <code>lmm</code>, <code>anova</code> and <code>confint</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>A list containing the default options.
</p>

<hr>
<h2 id='logLik.lmm'>Extract The Log-Likelihood From a Linear Mixed Model</h2><span id='topic+logLik.lmm'></span>

<h3>Description</h3>

<p>Extract or compute the log-likelihood of a linear mixed model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmm'
logLik(object, newdata = NULL, p = NULL, indiv = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.lmm_+3A_object">object</code></td>
<td>
<p>a <code>lmm</code> object.</p>
</td></tr>
<tr><td><code id="logLik.lmm_+3A_newdata">newdata</code></td>
<td>
<p>[data.frame] dataset relative to which the log-likelihood should be computed. Only relevant if differs from the dataset used to fit the model.</p>
</td></tr>
<tr><td><code id="logLik.lmm_+3A_p">p</code></td>
<td>
<p>[numeric vector] value of the model coefficients at which to evaluate the log-likelihood. Only relevant if differs from the fitted values.</p>
</td></tr>
<tr><td><code id="logLik.lmm_+3A_indiv">indiv</code></td>
<td>
<p>[logical] Should the contribution of each cluster to the log-likelihood be output? Otherwise output the sum of all clusters of the derivatives.</p>
</td></tr>
<tr><td><code id="logLik.lmm_+3A_...">...</code></td>
<td>
<p>Not used. For compatibility with the generic method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>indiv</b>: only relevant when using maximum likelihood. Must be <code>FALSE</code> when using restricted maximum likelihood.
</p>


<h3>Value</h3>

<p>A numeric value (total logLikelihood) or a vector of numeric values, one for each cluster (cluster specific logLikelihood).
</p>

<hr>
<h2 id='manifest.lmm'>Variables Involved in a Linear Mixed Model</h2><span id='topic+manifest.lmm'></span>

<h3>Description</h3>

<p>Extract the variables used by the linear mixed model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmm'
manifest(x, effects = "all", original = TRUE, simplify = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="manifest.lmm_+3A_x">x</code></td>
<td>
<p>a <code>lmm</code> object.</p>
</td></tr>
<tr><td><code id="manifest.lmm_+3A_effects">effects</code></td>
<td>
<p>[character] Should all variable be output (<code>"all"</code>),
or only those related to the outcome (<code>"outcome"</code>), mean (<code>"mean"</code>), variance (<code>"variance"</code>),
correlation (<code>"correlation"</code>), time (<code>"time"</code>), cluster (<code>"cluster"</code>), strata (<code>"strata"</code>)?</p>
</td></tr>
<tr><td><code id="manifest.lmm_+3A_original">original</code></td>
<td>
<p>[logical] Should only the variables present in the original data be output?
When <code>FALSE</code>, variables internally created are output instead of the original variable for time, cluster, and strata.</p>
</td></tr>
<tr><td><code id="manifest.lmm_+3A_simplify">simplify</code></td>
<td>
<p>[logical] Should the list be converted into a vector if a single <code>effects</code> is requested?</p>
</td></tr>
<tr><td><code id="manifest.lmm_+3A_...">...</code></td>
<td>
<p>not used. For compatibility with the generic function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of character vectors or a character vector.
</p>

<hr>
<h2 id='mlmm'>Fit Multiple Linear Mixed Model</h2><span id='topic+mlmm'></span>

<h3>Description</h3>

<p>Fit several linear mixed models, extract relevant coefficients, and combine them into a single table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlmm(
  ...,
  data,
  by,
  contrast.rbind = NULL,
  effects = NULL,
  robust = FALSE,
  df = TRUE,
  ci = TRUE,
  name.short = c(TRUE, TRUE),
  transform.sigma = NULL,
  transform.k = NULL,
  transform.rho = NULL,
  transform.names = TRUE,
  trace = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mlmm_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="#topic+lmm">lmm</a></code>.</p>
</td></tr>
<tr><td><code id="mlmm_+3A_data">data</code></td>
<td>
<p>[data.frame] dataset (in the long format) containing the observations.</p>
</td></tr>
<tr><td><code id="mlmm_+3A_by">by</code></td>
<td>
<p>[character] variable used to split the dataset. On each split a seperate linear mixed model is fit.</p>
</td></tr>
<tr><td><code id="mlmm_+3A_contrast.rbind">contrast.rbind</code></td>
<td>
<p>[character or numeric matrix] Contrast to be be applied to compare the groups.
Argument passed to the argument <code>effects</code> of <code><a href="#topic+rbind.Wald_lmm">rbind.Wald_lmm</a></code>.
Right hand side can be specified via an attribute <code>"rhs"</code>.</p>
</td></tr>
<tr><td><code id="mlmm_+3A_effects">effects</code></td>
<td>
<p>[character or numeric matrix] Linear combinations of coefficients relative to which Wald test should be computed.
Argument passed to <code><a href="#topic+anova.lmm">anova.lmm</a></code>.
Right hand side can be specified via an attribute <code>"rhs"</code>.</p>
</td></tr>
<tr><td><code id="mlmm_+3A_robust">robust</code></td>
<td>
<p>[logical] Should robust standard errors (aka sandwich estimator) be output instead of the model-based standard errors.
Argument passed to <code><a href="#topic+anova.lmm">anova.lmm</a></code>.</p>
</td></tr>
<tr><td><code id="mlmm_+3A_df">df</code></td>
<td>
<p>[logical] Should the degree of freedom be computed using a Satterthwaite approximation?
Argument passed to <code><a href="#topic+anova.lmm">anova.lmm</a></code>.</p>
</td></tr>
<tr><td><code id="mlmm_+3A_ci">ci</code></td>
<td>
<p>[logical] Should a confidence interval be output for each hypothesis?
Argument passed to <code><a href="#topic+anova.lmm">anova.lmm</a></code>.</p>
</td></tr>
<tr><td><code id="mlmm_+3A_name.short">name.short</code></td>
<td>
<p>[logical vector of length 2] use short names for the output coefficients:
omit the name of the by variable, omit the regression variable name when the same regression variable is used in all models.</p>
</td></tr>
<tr><td><code id="mlmm_+3A_transform.sigma">transform.sigma</code>, <code id="mlmm_+3A_transform.k">transform.k</code>, <code id="mlmm_+3A_transform.rho">transform.rho</code>, <code id="mlmm_+3A_transform.names">transform.names</code></td>
<td>
<p>[character] transformation used on certain type of parameters.</p>
</td></tr>
<tr><td><code id="mlmm_+3A_trace">trace</code></td>
<td>
<p>[interger, &gt;0] Show the progress of the execution of the function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>Grouping variable</b> in argument repetition: when numeric, it will be converted into a factor variable, possibly adding a leading 0 to preserve the ordering.
This transformation may cause inconsistency when combining results between different <code>lmm</code> object. 
This is why the grouping variable should preferably be of type character or factor.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+confint.mlmm">confint.mlmm</a></code> for a data.frame containing estimates with their uncertainty. <br />
<code><a href="#topic+summary.mlmm">summary.mlmm</a></code> for a summary of the model and estimates. <br />
<code><a href="#topic+autoplot.Wald_lmm">autoplot.Wald_lmm</a></code> for a graphical display. <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### univariate regression ####
if(require(lava) &amp;&amp; require(multcomp)){

set.seed(10)
d1 &lt;- cbind(sim(lvm(Y~0.5*X1), 25), group = "A")
d2 &lt;- cbind(sim(lvm(Y~0.1*X1), 100), group = "B")
d3 &lt;- cbind(sim(lvm(Y~0.01*X1), 1000), group = "C")
d1$id &lt;- 1:NROW(d1)
d2$id &lt;- 1:NROW(d2)
d3$id &lt;- 1:NROW(d3)

d &lt;- rbind(d1,d2,d3)

e.mlmm &lt;- mlmm(Y~X1, data = d, by = "group", effects = "X1=0")
summary(e.mlmm)
summary(e.mlmm, method = "single-step")
summary(e.mlmm, method = "single-step2")

## re-work contrast
summary(anova(e.mlmm, effects = mcp(X1 = "Dunnett")), method = "none")
## summary(mlmm(Y~X1, data = d, by = "group", effects = mcp(X1="Dunnett")))
}

#### multivariate regression ####
set.seed(10)
dL &lt;- sampleRem(250, n.times = 3, format = "long")

e.mlmm &lt;- mlmm(Y~X1+X2+X6, repetition = ~visit|id, data = dL,
               by = "X4", structure = "CS")
summary(e.mlmm)

e.mlmmX1 &lt;- mlmm(Y~X1+X2+X6, repetition = ~visit|id, data = dL,
               by = "X4", effects = "X1=0", structure = "CS")
summary(e.mlmmX1)
summary(e.mlmmX1, method = "single-step")

</code></pre>

<hr>
<h2 id='model.frame.lmm'>Extracting the Model Frame from a Linear Mixed Model</h2><span id='topic+model.frame.lmm'></span>

<h3>Description</h3>

<p>Variables needed to fit the Linear Mixed Model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmm'
model.frame(
  formula,
  newdata = NULL,
  type = NULL,
  add.index = FALSE,
  na.rm = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.frame.lmm_+3A_formula">formula</code></td>
<td>
<p>[lmm] linear mixed model object</p>
</td></tr>
<tr><td><code id="model.frame.lmm_+3A_newdata">newdata</code></td>
<td>
<p>[data.frame] dataset relative to which the model frame should be constructed.</p>
</td></tr>
<tr><td><code id="model.frame.lmm_+3A_type">type</code></td>
<td>
<p>[character] By default returns the processed dataset used to fit the Linear Mixed Model (<code>NULL</code>).
Can be used to add rows relative to missing repetitions (<code>"add.NA"</code>)
or obtain a dataset with unique sets of covariates (<code>"unique"</code>) with respect to the mean structure.</p>
</td></tr>
<tr><td><code id="model.frame.lmm_+3A_add.index">add.index</code></td>
<td>
<p>[logical] Should columns indexing the row number from the original dataset, time variable, cluster variable, strata variable
be added to the output?</p>
</td></tr>
<tr><td><code id="model.frame.lmm_+3A_na.rm">na.rm</code></td>
<td>
<p>[logical] Should rows containing missing values for the variables used in the linear mixed model be removed?
Not relevant when argument type is <code>"unique"</code>.</p>
</td></tr>
<tr><td><code id="model.frame.lmm_+3A_...">...</code></td>
<td>
<p>Not used. For compatibility with the generic method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Column <code>"XXindexXX"</code> refers to the row of the original dataset (i.e. passed to argument <code>data</code> when calling <code><a href="#topic+lmm">lmm</a></code>).
When adding rows relative to missing repetitions, since there is no row in the original dataset, a negative sign is used.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("armd.wide", package = "nlmeU")
e.lmH &lt;- lmm(visual52 ~ lesion, structure = IND(~treat.f), data = armd.wide)
model.frame(e.lmH)
model.frame(e.lmH, add.index = TRUE)
model.frame(e.lmH, type = "unique")

data("gastricbypassL", package = "LMMstar")
dfL.NNA &lt;- na.omit(gastricbypassL)
e.lmm &lt;- lmm(glucagonAUC ~ time, repetition = ~visit|id, data = dfL.NNA, df = FALSE)
model.frame(e.lmm, type = "unique")
model.frame(e.lmm, type = c("unique","correlation"))
model.frame(e.lmm, type = "add.NA", add.index = TRUE)
</code></pre>

<hr>
<h2 id='model.matrix.lmm'>Design Matrix for Linear Mixed Model</h2><span id='topic+model.matrix.lmm'></span>

<h3>Description</h3>

<p>Extract or construct design matrices for Linear Mixed Model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmm'
model.matrix(
  object,
  newdata = NULL,
  effects = "mean",
  simplify = TRUE,
  drop.X = NULL,
  na.rm = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.matrix.lmm_+3A_object">object</code></td>
<td>
<p>an lmm object</p>
</td></tr>
<tr><td><code id="model.matrix.lmm_+3A_newdata">newdata</code></td>
<td>
<p>[data.frame] dataset relative to which the design matrix should be constructed.</p>
</td></tr>
<tr><td><code id="model.matrix.lmm_+3A_effects">effects</code></td>
<td>
<p>[character] design matrix relative to the mean model (<code>"mean"</code>), variance model (<code>"variance"</code>), correlation model (<code>"correlation"</code>),
or all the previous (<code>"all"</code>).
Can also be <code>"index"</code> to only output the normalize data and the cluster, time, strata indexes.</p>
</td></tr>
<tr><td><code id="model.matrix.lmm_+3A_simplify">simplify</code></td>
<td>
<p>[logical] simplify the data format of the output (matrix instead of a list of matrix) when possible.</p>
</td></tr>
<tr><td><code id="model.matrix.lmm_+3A_drop.x">drop.X</code></td>
<td>
<p>[logical] when the design matrix does not have full rank, should columns be dropped?</p>
</td></tr>
<tr><td><code id="model.matrix.lmm_+3A_na.rm">na.rm</code></td>
<td>
<p>[logical] Should row containing missing values for the variables used in the linear mixed model be removed?</p>
</td></tr>
<tr><td><code id="model.matrix.lmm_+3A_...">...</code></td>
<td>
<p>Not used. For compatibility with the generic method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When <code>simplify</code> is <code>FALSE</code>, a list with the followin elements: </p>

<ul>
<li> <p><code>mean</code>: design matrix for the mean model
</p>
</li>
<li> <p><code>Y</code>: vector of outcome values
</p>
</li>
<li> <p><code>vcov</code>: list of elements for the variance and correlation models.
</p>
</li>
<li> <p><code>index.cluster</code>: list containing, for each cluster, the location of the corresponding observations in the processed dataset.
</p>
</li>
<li> <p><code>index.clusterTime</code>: list containing, for each cluster, the repetition index corresponding observations.
</p>
</li>
<li> <p><code>index.clusterStrata</code>: list containing, for each cluster, the strata index corresponding observations.
</p>
</li>
<li> <p><code>param</code>: data.frame describing the modle parameters.
</p>
</li>
<li> <p><code>drop.X</code>: logical value indicating whether columns in the design matrix should be dropped if it has not full rank.
</p>
</li>
<li> <p><code>precompute.XX</code>, <code>precompute.XY</code>: moments of X and Y 
</p>
</li></ul>

<p>When <code>simplify</code> is <code>TRUE</code>, this list will be simplified into a list with three elements: </p>

<ul>
<li> <p><code>mean</code>: design matrix for the mean model
</p>
</li>
<li> <p><code>variance</code>: design matrix for the variance model
</p>
</li>
<li> <p><code>correlation</code>: design matrix for the correlation model
</p>
</li></ul>

<p>or a single design matrixx.
</p>

<hr>
<h2 id='model.tables.lmm'>Statistical Inference for Linear Mixed Model</h2><span id='topic+model.tables.lmm'></span>

<h3>Description</h3>

<p>Export estimates, standard errors, degrees of freedom, confidence intervals (CIs) and p-values for the mean coefficients of a linear mixed model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmm'
model.tables(x, columns, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.tables.lmm_+3A_x">x</code></td>
<td>
<p>a <code>lmm</code> object.</p>
</td></tr>
<tr><td><code id="model.tables.lmm_+3A_columns">columns</code></td>
<td>
<p>[character vector] Columns to be output.
Can be any of <code>"estimate"</code>, <code>"se"</code>, <code>"statistic"</code>, <code>"df"</code>, <code>"null"</code>, <code>"lower"</code>, <code>"upper"</code>, <code>"p.value"</code>.</p>
</td></tr>
<tr><td><code id="model.tables.lmm_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the <code>confint</code> method. Should not contain the argument <code>column</code>.</p>
</td></tr>
<tr><td><code id="model.tables.lmm_+3A_method">method</code></td>
<td>
<p>[character] type of adjustment for multiple comparisons, one of <code>"none"</code>, <code>"bonferroni"</code>, ..., <code>"fdr"</code>, <code>"single-step"</code>, <code>"single-step2"</code>.
Alternatively, method for combining the estimates, one of <code>"average"</code>, <code>"pool.se"</code>, <code>"pool.gls"</code>, <code>"pool.rubin"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simply calls <code><a href="stats.html#topic+confint">confint</a></code> with a specific value for the argument <code>column</code>.
</p>

<hr>
<h2 id='mt.test'>Multiple Student's t-Test</h2><span id='topic+mt.test'></span>

<h3>Description</h3>

<p>Perform multiple Student's t-Test via heteroschedastic linear regression
and combine the results, possibly adjusted for multiplicity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mt.test(formula, data, method = NULL, level = 0.95, trace = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mt.test_+3A_formula">formula</code></td>
<td>
<p>A formula like <code>Y1+Y2+Y3~X|id</code> with: </p>

<ul>
<li><p> the outcome on the left hand side (separated with +)
</p>
</li>
<li><p> the group variable on the right hand side
</p>
</li>
<li><p> a variable identifying each line in the dataset (optional)
</p>
</li></ul>
</td></tr>
<tr><td><code id="mt.test_+3A_data">data</code></td>
<td>
<p>dataset in the wide format. Should inherit from data.frame.</p>
</td></tr>
<tr><td><code id="mt.test_+3A_method">method</code></td>
<td>
<p>[character] type of adjustment for multiple comparisons, one of <code>"none"</code>, <code>"bonferroni"</code>, ..., <code>"fdr"</code>, <code>"single-step"</code>, <code>"single-step2"</code>.
See <code><a href="#topic+confint.Wald_lmm">confint.Wald_lmm</a></code> for more details.
By default <code>"single-step"</code> when the test statistics have equal degrees of freedom and otherwise <code>"single-step2"</code>.</p>
</td></tr>
<tr><td><code id="mt.test_+3A_level">level</code></td>
<td>
<p>[numeric,0-1] the confidence level of the confidence intervals.</p>
</td></tr>
<tr><td><code id="mt.test_+3A_trace">trace</code></td>
<td>
<p>[logical] should a message be displayed in the console when there are missing data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In presence of missing values, performs a outcome specific complete case analysis.
</p>


<h3>Value</h3>

<p>A data.frame with the estimates, confidence intervals, and p-values relative to each outcome.
Depending on the argument <code>method</code> confidence intervals and p-values may be adjusted for multiple comparisons.
The data.frame has an attribute <code>mlmm</code> containing the underlying regression models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(calciumW, package = "LMMstar")

t.test(bmd1 ~ grp, data = calciumW)

mt.test(bmd1+bmd2+bmd3+bmd4+bmd5 ~ grp, data = calciumW)
mt.test(bmd1+bmd2+bmd3+bmd4+bmd5 ~ grp|girl, data = calciumW)
mt.test(bmd1+bmd2+bmd3+bmd4+bmd5 ~ grp|girl, data = calciumW, method = "none")
</code></pre>

<hr>
<h2 id='ncgsL'>Data From National Cooperative Gallstone Study (Long Format)</h2><span id='topic+ncgsL'></span>

<h3>Description</h3>

<p>Data from the National Cooperative Gallstone Study (NCGS),
a randomized study where the level of serum cholesterol was measured at baseline and after intake of high-dose chenondiol (750mg/day) or placebo.
This dataset is in the long format (i.e. one line per measurement).
</p>

<ul>
<li> <p><code>group</code>: treatment group (highdose or placebo).
</p>
</li>
<li> <p><code>id</code>: patient identifier.
</p>
</li>
<li> <p><code>visit</code>: visit index.
</p>
</li>
<li> <p><code>cholest</code>: cholesterol measurement.
</p>
</li>
<li> <p><code>time</code>: time after the start of the study at which the measurement has been done (in month). Treatment is given at 0+.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(ncgsL)
</code></pre>


<h3>References</h3>

<p>Grundy SM, Lan SP, Lachin J. The effects of chenodiol on biliary lipids and their association with gallstone dissolution in the National Cooperative Gallstone Study (NCGS). J Clin Invest. 1984 Apr;73(4):1156-66. doi: 10.1172/JCI111301.
</p>

<hr>
<h2 id='ncgsW'>Data From National Cooperative Gallstone Study (Wide Format)</h2><span id='topic+ncgsW'></span>

<h3>Description</h3>

<p>Data from the National Cooperative Gallstone Study (NCGS),
a randomized study where the level of serum cholesterol was measured at baseline and after intake of high-dose chenondiol (750mg/day) or placebo.
This dataset is in the wide format (i.e. one line per patient).
</p>

<ul>
<li> <p><code>group</code>: treatment group (highdose or placebo).
</p>
</li>
<li> <p><code>id</code>: patient identifier.
</p>
</li>
<li> <p><code>cholest1</code>: cholesterol measurement at baseline (before treatment).
</p>
</li>
<li> <p><code>cholest2</code>: cholesterol measurement at 6 months (after treatment).
</p>
</li>
<li> <p><code>cholest3</code>: cholesterol measurement at 12 months (after treatment).
</p>
</li>
<li> <p><code>cholest4</code>: cholesterol measurement at 20 months (after treatment).
</p>
</li>
<li> <p><code>cholest5</code>: cholesterol measurement at 24 months (after treatment).
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(ncgsW)
</code></pre>


<h3>References</h3>

<p>Grundy SM, Lan SP, Lachin J. The effects of chenodiol on biliary lipids and their association with gallstone dissolution in the National Cooperative Gallstone Study (NCGS). J Clin Invest. 1984 Apr;73(4):1156-66. doi: 10.1172/JCI111301.
</p>

<hr>
<h2 id='nobs.lmm'>Number of Observations from a Linear Mixed Model</h2><span id='topic+nobs.lmm'></span>

<h3>Description</h3>

<p>Extract the number of observations from a Linear Mixed Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmm'
nobs(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nobs.lmm_+3A_object">object</code></td>
<td>
<p>an lmm object.</p>
</td></tr>
<tr><td><code id="nobs.lmm_+3A_...">...</code></td>
<td>
<p>Not used. For compatibility with the generic method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with 4 elements: </p>

<ul>
<li> <p><code>obs</code>: the number of repetitions with full data
</p>
</li>
<li> <p><code>cluster</code>: the number of clusters with a least one repetition with full data
</p>
</li>
<li> <p><code>missing.obs</code>: the number of repetitions with missing data
</p>
</li>
<li> <p><code>missing.cluster</code>: the number of cluster with only missing data
</p>
</li></ul>


<hr>
<h2 id='partialCor'>Partial Correlation</h2><span id='topic+partialCor'></span><span id='topic+partialCor.list'></span><span id='topic+partialCor.formula'></span><span id='topic+partialCor.lmm'></span>

<h3>Description</h3>

<p>Estimate the partial correlation based on equation 19 of Lloyd et al 2008 (<code>partialCor.lmm</code>) or explicitely modeling the correlation via a linear mixed model  (<code>partialCor.list</code>, <code>partialCor.formula</code>).
The first option is numerically more efficient and exact with a single observation per cluster.
With multiple repetitions, what is being estimated with the first option may not be clear and the second option is therefore preferrable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partialCor(object, ...)

## S3 method for class 'list'
partialCor(
  object,
  data,
  repetition = NULL,
  structure = NULL,
  by = NULL,
  effects = NULL,
  rhs = NULL,
  method = "none",
  df = NULL,
  transform.rho = NULL,
  name.short = c(TRUE, FALSE),
  ...
)

## S3 method for class 'formula'
partialCor(object, repetition, ...)

## S3 method for class 'lmm'
partialCor(object, level = 0.95, R2 = FALSE, se = TRUE, df = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partialCor_+3A_object">object</code></td>
<td>
<p>a formula with in the left hand side the variables for which the correlation should be computed
and on the right hand side the adjustment set. Can also be a list of formula for outcome-specific adjustment set.</p>
</td></tr>
<tr><td><code id="partialCor_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>confint</code> for <code>partialCor.list</code> and  <code>partialCor.formula</code>. Not used for <code>partialCor.lmm</code>.</p>
</td></tr>
<tr><td><code id="partialCor_+3A_data">data</code></td>
<td>
<p>[data.frame] dataset containing the variables.</p>
</td></tr>
<tr><td><code id="partialCor_+3A_repetition">repetition</code></td>
<td>
<p>[formula] Specify the structure of the data: the time/repetition variable and the grouping variable, e.g. ~ time|id.</p>
</td></tr>
<tr><td><code id="partialCor_+3A_structure">structure</code></td>
<td>
<p>[character] Specify the residual variance-covariance structure.
Without repetitions, either <code>"UN"</code> or <code>"CS"</code>.
With repetitions, one of <code>"UN"</code>, <code>"PEARSON"</code>, <code>"HLAG"</code>, <code>"LAG"</code>, <code>"HCS"</code>, <code>"CS"</code>.</p>
</td></tr>
<tr><td><code id="partialCor_+3A_by">by</code></td>
<td>
<p>[character] variable used to stratified the correlation on.</p>
</td></tr>
<tr><td><code id="partialCor_+3A_effects">effects</code></td>
<td>
<p>[character or matrix] type of contrast to be used for comparing the correlation parameters. One of <code>"Dunnett"</code>, <code>"Tukey"</code>, <code>"Sequen"</code>, or a contrast matrix.</p>
</td></tr>
<tr><td><code id="partialCor_+3A_rhs">rhs</code></td>
<td>
<p>[numeric vector] right hand side for the comparison of correlation parameters.</p>
</td></tr>
<tr><td><code id="partialCor_+3A_method">method</code></td>
<td>
<p>[character] adjustment for multiple comparisons (e.g. <code>"single-step"</code>).</p>
</td></tr>
<tr><td><code id="partialCor_+3A_df">df</code></td>
<td>
<p>[logical] Should a Student's t-distribution be used to model the distribution of the coefficient. Otherwise a normal distribution is used.</p>
</td></tr>
<tr><td><code id="partialCor_+3A_transform.rho">transform.rho</code></td>
<td>
<p>[character] scale on which perform statistical inference (e.g. <code>"atanh"</code>)</p>
</td></tr>
<tr><td><code id="partialCor_+3A_name.short">name.short</code></td>
<td>
<p>[logical vector of length 2] use short names for the output coefficients (omit the name of the by variable, omit name of the correlation parameter)</p>
</td></tr>
<tr><td><code id="partialCor_+3A_level">level</code></td>
<td>
<p>[numeric,0-1] the confidence level of the confidence intervals.</p>
</td></tr>
<tr><td><code id="partialCor_+3A_r2">R2</code></td>
<td>
<p>[logical] Should the R2 (coefficient of determination) be computed?</p>
</td></tr>
<tr><td><code id="partialCor_+3A_se">se</code></td>
<td>
<p>[logical] Should the uncertainty about the partial correlation be evaluated? Only relevant for <code>partialCor.lmm</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fit a mixed model to estimate the partial correlation with the following variance-covariance pattern:
</p>

<ul>
<li> <p><b>no repetition</b>: unstructure or compound symmetry structure for M observations, M being the number of variables on the left hand side (i.e. outcomes).
</p>
</li>
<li> <p><b>repetition</b>: structure for M*T observations where M being the number of variables (typically 2) and T the number of repetitions. Can be </p>

<ul>
<li> <p><code>"UN"</code>: unstructured (except the off-diagonal containing the correlation parameter which is constant).
</p>
</li>
<li> <p><code>"PEARSON"</code>: same as unstructured except it only uses a single variance parameter per variable, i.e. it assumes constant variance over repetitions.
</p>
</li>
<li> <p><code>"HLAG"</code>: toeplitz by block with variable and repetition specific variance.
</p>
</li>
<li> <p><code>"LAG"</code>: toeplitz by block, i.e. correlation depending on the gap between repetitions and specific to each variable. It assumes constant variance over repetitions.
</p>
</li>
<li> <p><code>"HCS"</code>: heteroschedastic compound symmetry by block, i.e. variable specific correlation constant over repetitions. A specific parameter is used for the off-diagonal crossing the variables at the same repetition (which is the marginal correlation parameter).
</p>
</li>
<li> <p><code>"CS"</code>: compound symmetry by block. It assumes constant variance and correlation over repetitions.
</p>
</li></ul>
</li></ul>



<h3>Value</h3>

<p>A data.frame with the estimate partial correlation (rho), standard error, degree of freedom, confidence interval, and p-value (test of no correlation).
When <code>structure="CS"</code> or <code>structure="HCS"</code> is used with repeated measurements, a second correlation coefficient (r) is output where the between subject variance has been removed (similar to Bland et al. 1995).
</p>


<h3>References</h3>

<p>Bland J M, Altman D G. Statistics notes: Calculating correlation coefficients with repeated observations: Part 1—correlation within subjects BMJ 1995; 310 :446 doi:10.1136/bmj.310.6977.446
Edwards, L.J., Muller, K.E., Wolfinger, R.D., Qaqish, B.F. and Schabenberger, O. (2008), An R2 statistic for fixed effects in the linear mixed model. Statist. Med., 27: 6137-6157. https://doi.org/10.1002/sim.3429
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### no repetition ####

## example from ppcor::pcor 
y.data &lt;- data.frame(
  hl=c(7,15,19,15,21,22,57,15,20,18),
  disp=c(0.000,0.964,0.000,0.000,0.921,0.000,0.000,1.006,0.000,1.011),
  deg=c(9,2,3,4,1,3,1,3,6,1),
  BC=c(1.78e-02,1.05e-06,1.37e-05,7.18e-03,0.00e+00,0.00e+00,0.00e+00
,  4.48e-03,2.10e-06,0.00e+00)
)
## ppcor::pcor(y.data)

## partial correlation based on a formula
partialCor(c(hl,disp)~BC+deg, data = y.data)
partialCor(hl + disp~BC+deg, data = y.data)
## partial correlation based on a list
partialCor(list(hl~BC+deg,disp~BC+deg), data = y.data)
## via an existing model
e.lm &lt;- lmm(hl~disp+BC+deg, data = y.data)
partialCor(e.lm)

## using a different set of covariates for outcome
partialCor(list(hl~BC+deg, disp~BC), data = y.data)

## statified correlation (using another dataset)
data(gastricbypassW, package = "LMMstar")
gastricbypassW$weight.bin &lt;- gastricbypassW$weight1&gt;=120
partialCor(glucagonAUC1+glucagonAUC2~1, data = gastricbypassW, by = "weight.bin")

## compared correlation between groups
partialCor(glucagonAUC1+glucagonAUC2~1, data = gastricbypassW, by = "weight.bin",
           effects = "Dunnett") 

#### with repetitions ####
## Not run: 
data(gastricbypassL, package = "LMMstar")
## via a mixed model
eUN.lmm &lt;- lmm(weight ~ glucagonAUC+time, repetition =~time|id,
               data = gastricbypassL, structure = "UN")
partialCor(eUN.lmm)

## mean: variable and timepoint specific mean parameter (8)
## variance: variable and timepoint specific variance parameter (8)
## correlation: correlation parameter specific for each variable and time lag (10)
e.cor &lt;- partialCor(weight+glucagonAUC~time, repetition =~time|id,
                    data = gastricbypassL, structure = "LAG")
e.cor
coef(attr(e.cor,"lmm"), effects = "correlation")
if(require(ggplot2)){
autoplot(e.cor)
}

## same except for the mean structure: variable specific mean parameter (2)
e.cor2 &lt;- partialCor(weight+glucagonAUC~time, repetition =~time|id,
                    data = gastricbypassL, structure = "LAG")

## mean: variable and timepoint specific mean parameter (8)
## variance: variable specific variance parameter (2)
## correlation: correlation parameter specific for each variable and some time lag (4)
e.cor3 &lt;- partialCor(weight+glucagonAUC~time, repetition =~time|id,
                     data = gastricbypassL, structure = "CS")
e.cor3
coef(attr(e.cor3,"lmm"), effects = "correlation")
if(require(ggplot2)){
autoplot(e.cor3)
}


## End(Not run)
</code></pre>

<hr>
<h2 id='potassiumRepeatedL'>Data From The Potassium Intake Study (Long Format with intermediate measurements)</h2><span id='topic+potassiumRepeatedL'></span>

<h3>Description</h3>

<p>Data from the potassium intake study,
a randomized placebo-controlled crossover study where the effect of potassium supplement (90 mmol/day) on the renin-angiostensin-aldosteron system (RAAS) was assessed.
This dataset is in the long format (i.e. one line per measurement) and contains measurement over 6 timepoints for each time period.
</p>

<ul>
<li> <p><code>id</code>: patient identifier.
</p>
</li>
<li> <p><code>sequence</code>: treatment group to which the patient has been randomized.
</p>
</li>
<li> <p><code>period</code>: time period.
</p>
</li>
<li> <p><code>treatment</code>: treatment during the time period.
</p>
</li>
<li> <p><code>time</code>: time within each period.
</p>
</li>
<li> <p><code>aldo</code>: ??
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(potassiumRepeatedL)
</code></pre>


<h3>References</h3>

<p>Dreier et al. Effect of increased potassium intake on the reninangiotensinaldosterone system and subcutaneous resistance arteries: a randomized crossover study,
Nephrol Dial Transplant (2020) 110. doi: 10.1093/ndt/gfaa114
</p>

<hr>
<h2 id='potassiumSingleL'>Data From The Potassium Intake Study (Long Format)</h2><span id='topic+potassiumSingleL'></span>

<h3>Description</h3>

<p>Data from the potassium intake study,
a randomized placebo-controlled crossover study where the effect of potassium supplement (90 mmol/day) on the renin-angiostensin-aldosteron system (RAAS) was assessed.
This dataset is in the long format (i.e. one line per measurement).
</p>

<ul>
<li> <p><code>id</code>: patient identifier.
</p>
</li>
<li> <p><code>sequence</code>: treatment group to which the patient has been randomized.
</p>
</li>
<li> <p><code>period</code>: time period.
</p>
</li>
<li> <p><code>treatment</code>: treatment during the time period.
</p>
</li>
<li> <p><code>auc</code>: area under the curve of ?? during the time period.
</p>
</li>
<li> <p><code>bsauc</code>: ??
</p>
</li>
<li> <p><code>aldo</code>: ??
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(potassiumSingleL)
</code></pre>


<h3>References</h3>

<p>Dreier et al. Effect of increased potassium intake on the reninangiotensinaldosterone system and subcutaneous resistance arteries: a randomized crossover study,
Nephrol Dial Transplant (2020) 110. doi: 10.1093/ndt/gfaa114
</p>

<hr>
<h2 id='potassiumSingleW'>Data From The Potassium Intake Study (Wide Format)</h2><span id='topic+potassiumSingleW'></span>

<h3>Description</h3>

<p>Data from the potassium intake study,
a randomized placebo-controlled crossover study where the effect of potassium supplement (90 mmol/day) on the renin-angiostensin-aldosteron system (RAAS) was assessed.
This dataset is in the wide format (i.e. one line per patient).
</p>

<ul>
<li> <p><code>id</code>: patient identifier.
</p>
</li>
<li> <p><code>sequence</code>: treatment group to which the patient has been randomized.
</p>
</li>
<li> <p><code>treatment1</code>: treatment during the first time period.
</p>
</li>
<li> <p><code>treatment2</code>: treatment during the second time period.
</p>
</li>
<li> <p><code>auc1</code>: area under the curve of ?? during the first time period.
</p>
</li>
<li> <p><code>auc2</code>: area under the curve of ?? during the second time period.
</p>
</li>
<li> <p><code>bsauc1</code>: ??
</p>
</li>
<li> <p><code>aldo1</code>: ??
</p>
</li>
<li> <p><code>aldo2</code>: ??
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(potassiumSingleW)
</code></pre>


<h3>References</h3>

<p>Dreier et al. Effect of increased potassium intake on the reninangiotensinaldosterone system and subcutaneous resistance arteries: a randomized crossover study,
Nephrol Dial Transplant (2020) 110. doi: 10.1093/ndt/gfaa114
</p>

<hr>
<h2 id='predict.lmm'>Predicted Mean Value With Uncertainty For Linear Mixed Model</h2><span id='topic+predict.lmm'></span>

<h3>Description</h3>

<p>Predicted mean value conditional on covariates or on covariates and other outcome values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmm'
predict(
  object,
  newdata,
  type = "static",
  p = NULL,
  se = NULL,
  robust = FALSE,
  df = NULL,
  level = 0.95,
  keep.data = NULL,
  format = "long",
  export.vcov = FALSE,
  simplify = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.lmm_+3A_object">object</code></td>
<td>
<p>a <code>lmm</code> object.</p>
</td></tr>
<tr><td><code id="predict.lmm_+3A_newdata">newdata</code></td>
<td>
<p>[data.frame] a dataset containing covariate values to condition on.
When setting the argument 'dynamic' predictions should also contain cluster, timepoint, and outcome values.</p>
</td></tr>
<tr><td><code id="predict.lmm_+3A_type">type</code></td>
<td>
<p>[character] evaluate the expected outcome conditional on covariates only (<code>"static"</code>),
the contribution of each variable to this 'static' prediction (<code>"terms"</code>),
or the expected outcome conditional covariates and outcome values at other timepoints (<code>"dynamic"</code>).
Based on the observed outcome and the 'dynamic' prediction for the missing outcome,
can also evaluate the change from first repetitition (<code>"change"</code>), area under the curve (<code>"auc"</code>), and the area under the curve minus baseline (<code>"auc-b"</code>).</p>
</td></tr>
<tr><td><code id="predict.lmm_+3A_p">p</code></td>
<td>
<p>[numeric vector] value of the model coefficients at which to evaluate the predictions. Only relevant if differs from the fitted values.</p>
</td></tr>
<tr><td><code id="predict.lmm_+3A_se">se</code></td>
<td>
<p>[logical] should the standard error and confidence intervals for the predictions be output?
It can also be a logical vector of length 2 to indicate the type of uncertainty to be accounted for: estimation and residual variance.
In particular <code>c(TRUE,TRUE)</code> provides prediction intervals.</p>
</td></tr>
<tr><td><code id="predict.lmm_+3A_robust">robust</code></td>
<td>
<p>[logical] Should robust standard errors (aka sandwich estimator) be output instead of the model-based standard errors.
Not feasible for dynamic predictions when using REML.</p>
</td></tr>
<tr><td><code id="predict.lmm_+3A_df">df</code></td>
<td>
<p>[logical] should a Student's t-distribution be used to model the distribution of the predicted mean. Otherwise a normal distribution is used.</p>
</td></tr>
<tr><td><code id="predict.lmm_+3A_level">level</code></td>
<td>
<p>[numeric,0-1] the confidence level of the confidence intervals.</p>
</td></tr>
<tr><td><code id="predict.lmm_+3A_keep.data">keep.data</code></td>
<td>
<p>[logical] should the dataset relative to which the predicted means are evaluated be output along side the predicted values?
Only possible in the long format.</p>
</td></tr>
<tr><td><code id="predict.lmm_+3A_format">format</code></td>
<td>
<p>[character] should the prediction be output
in a matrix format with clusters in row and timepoints in columns (<code>"wide"</code>),
or in a data.frame/vector with as many rows as observations (<code>"long"</code>)</p>
</td></tr>
<tr><td><code id="predict.lmm_+3A_export.vcov">export.vcov</code></td>
<td>
<p>[logical] should the variance-covariance matrix of the prediction error be outcome as an attribute (<code>"vcov"</code>)?</p>
</td></tr>
<tr><td><code id="predict.lmm_+3A_simplify">simplify</code></td>
<td>
<p>[logical] simplify the data format (vector instead of data.frame) and column names (no mention of the time variable) when possible.</p>
</td></tr>
<tr><td><code id="predict.lmm_+3A_...">...</code></td>
<td>
<p>Not used. For compatibility with the generic method.</p>
</td></tr>
<tr><td><code id="predict.lmm_+3A_vcov">vcov</code></td>
<td>
<p>[logical] should the variance-covariance matrix of the predictions be output as an attribute.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Static prediction are made using the linear predictor <code class="reqn">X\beta</code> while dynamic prediction uses the conditional normal distribution of the missing outcome given the observed outcomes. So if outcome 1 is observed but not 2, prediction for outcome 2 is obtain by <code class="reqn">X_2\beta + \sigma_{21}\sigma^{-1}_{22}(Y_1-X_1\beta)</code>. In that case, the uncertainty is computed as the sum of the conditional variance <code class="reqn">\sigma_{22}-\sigma_{21}\sigma^{-1}_{22}\sigma_{12}</code> plus the uncertainty about the estimated conditional mean (obtained via delta method using numerical derivatives).
</p>
<p>The model terms are computing similarly to <code>stats::predict.lm</code>, by centering the design matrix around the mean value of the covariates used to fit the model.
Then the centered design matrix is multiplied by the mean coefficients and columns assigned to the same variable (e.g. three level factor variable) are summed together.
</p>


<h3>Value</h3>

<p>When <code>format="long"</code>, a data.frame containing the following columns:</p>

<ul>
<li> <p><code>estimate</code>: predicted mean.
</p>
</li>
<li> <p><code>se</code>: uncertainty about the predicted mean.
</p>
</li>
<li> <p><code>df</code>: degree of freedom
</p>
</li>
<li> <p><code>lower</code>: lower bound of the confidence interval of the predicted mean
</p>
</li>
<li> <p><code>upper</code>: upper bound of the confidence interval of the predicted mean
</p>
</li></ul>

<p>When <code>format="wide"</code>, a matrix containing the predict means (one line per cluster, one column per timepoint).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simulate data in the long format
set.seed(10)
dL &lt;- sampleRem(100, n.times = 3, format = "long")

## fit Linear Mixed Model
eUN.lmm &lt;- lmm(Y ~ visit + X1 + X2 + X5,
               repetition = ~visit|id, structure = "UN", data = dL)

## prediction
newd &lt;- data.frame(X1 = 1, X2 = 2, X5 = 3, visit = factor(1:3, levels = 1:3))
predict(eUN.lmm, newdata = newd)
predict(eUN.lmm, newdata = newd, keep.data = TRUE)
predict(eUN.lmm, newdata = newd, keep.data = TRUE, se = c(TRUE,TRUE))

## dynamic prediction
newd.d1 &lt;- cbind(newd, Y = c(NA,NA,NA))
predict(eUN.lmm, newdata = newd.d1, keep.data = TRUE, type = "dynamic")
newd.d2 &lt;- cbind(newd, Y = c(6.61,NA,NA))
predict(eUN.lmm, newdata = newd.d2, keep.data = TRUE, type = "dynamic")
newd.d3 &lt;- cbind(newd, Y = c(1,NA,NA))
predict(eUN.lmm, newdata = newd.d3, keep.data = TRUE, type = "dynamic")
newd.d4 &lt;- cbind(newd, Y = c(1,1,NA))
predict(eUN.lmm, newdata = newd.d4, keep.data = TRUE, type = "dynamic")
</code></pre>

<hr>
<h2 id='profile.lmm'>Evaluate Contour of the Log-Likelihood</h2><span id='topic+profile.lmm'></span>

<h3>Description</h3>

<p>Display the (restricted) log-likelihood around Maximum Likelihood Estimate (MLE) under specific constrains.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmm'
profile(
  fitted,
  effects = NULL,
  profile.likelihood = FALSE,
  maxpts = NULL,
  conf.level = 0.95,
  trace = FALSE,
  transform.sigma = NULL,
  transform.k = NULL,
  transform.rho = NULL,
  transform.names = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="profile.lmm_+3A_fitted">fitted</code></td>
<td>
<p>a <code>lmm</code> object.</p>
</td></tr>
<tr><td><code id="profile.lmm_+3A_effects">effects</code></td>
<td>
<p>[character vector] name of the parameters who will be constrained.
Alternatively can be the type of parameters, e.g. <code>"mean"</code>, <code>"variance"</code>, <code>"correlation"</code>, or <code>"all"</code>.</p>
</td></tr>
<tr><td><code id="profile.lmm_+3A_profile.likelihood">profile.likelihood</code></td>
<td>
<p>[logical] should profile likelihood be performed? Otherwise varying one parameter at a time around the MLE while keeping the other constant).</p>
</td></tr>
<tr><td><code id="profile.lmm_+3A_maxpts">maxpts</code></td>
<td>
<p>[integer, &gt;0] number of points use to discretize the likelihood, <code>maxpts</code> points smaller than the MLE and <code>maxpts</code> points higher than the MLE.</p>
</td></tr>
<tr><td><code id="profile.lmm_+3A_conf.level">conf.level</code></td>
<td>
<p>[numeric, 0-1] the confidence level of the confidence intervals used to decide about the range of values for each parameter.</p>
</td></tr>
<tr><td><code id="profile.lmm_+3A_trace">trace</code></td>
<td>
<p>[logical] Show the progress of the execution of the function.</p>
</td></tr>
<tr><td><code id="profile.lmm_+3A_transform.sigma">transform.sigma</code></td>
<td>
<p>[character] Transformation used on the variance coefficient for the reference level. One of <code>"none"</code>, <code>"log"</code>, <code>"square"</code>, <code>"logsquare"</code> - see details.</p>
</td></tr>
<tr><td><code id="profile.lmm_+3A_transform.k">transform.k</code></td>
<td>
<p>[character] Transformation used on the variance coefficients relative to the other levels. One of <code>"none"</code>, <code>"log"</code>, <code>"square"</code>, <code>"logsquare"</code>, <code>"sd"</code>, <code>"logsd"</code>, <code>"var"</code>, <code>"logvar"</code> - see details.</p>
</td></tr>
<tr><td><code id="profile.lmm_+3A_transform.rho">transform.rho</code></td>
<td>
<p>[character] Transformation used on the correlation coefficients. One of <code>"none"</code>, <code>"atanh"</code>, <code>"cov"</code> - see details.</p>
</td></tr>
<tr><td><code id="profile.lmm_+3A_transform.names">transform.names</code></td>
<td>
<p>[logical] Should the name of the coefficients be updated to reflect the transformation that has been used?</p>
</td></tr>
<tr><td><code id="profile.lmm_+3A_...">...</code></td>
<td>
<p>Not used. For compatibility with the generic method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each parameter defined by the argument <code>effets</code> is treated separately:</p>

<ul>
<li><p> the confidence interval of a parameter is discretized with <code>maxpt</code> points,
</p>
</li>
<li><p> this parameter is set to a discretization value.
</p>
</li>
<li><p> the other parameters are either set to the (unconstrained) MLE (<code>profile.likelihood=FALSE</code>)
or to constrained MLE  (<code>profile.likelihood=TRUE</code>). The latter case is much more computer intensive as it implies re-running the estimation procedure.
</p>
</li>
<li><p> the (restricted) log-likelihood is evaluated.
</p>
</li></ul>



<h3>Value</h3>

<p>A data.frame object containing the log-likelihood for various parameter values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gastricbypassW, package = "LMMstar")
e.lmm &lt;- lmm(weight2 ~ weight1 + glucagonAUC1,
             data = gastricbypassW, control = list(optimizer = "FS"))

## profile logLiklihood
## Not run: 
e.pro &lt;- profile(e.lmm, effects = "all", maxpts = 10, profile.likelihood = TRUE)
head(e.pro)
plot(e.pro)

## End(Not run)

## along a single parameter axis
e.sliceNone &lt;- profile(e.lmm, effects = "all", maxpts = 10, transform.sigma = "none")
plot(e.sliceNone)
e.sliceLog &lt;- profile(e.lmm, effects = "all", maxpts = 10, transform.sigma = "log")
plot(e.sliceLog)

</code></pre>

<hr>
<h2 id='proportion'>Proportion of Significant Findings</h2><span id='topic+proportion'></span>

<h3>Description</h3>

<p>Evaluate the proportion of test above the statistical significance level
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proportion(object, n.sample, trace, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proportion_+3A_object">object</code></td>
<td>
<p><code>Wald_lmm</code> object</p>
</td></tr>
<tr><td><code id="proportion_+3A_n.sample">n.sample</code></td>
<td>
<p>[numeric,&gt;=0] number of bootstrap sample used to assess the uncertainty.
If 0, then only the point estimate is computed.</p>
</td></tr>
<tr><td><code id="proportion_+3A_trace">trace</code></td>
<td>
<p>[logical] shoudl the execution of the boostrap be trace.</p>
</td></tr>
<tr><td><code id="proportion_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>confint.Wald_lmm</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with the estimated proportion (estimate column), standard error and confidence interval (when boostrap is used).
</p>

<hr>
<h2 id='ranef.lmm'>Estimate Random Effect From a Linear Mixed Model</h2><span id='topic+ranef.lmm'></span>

<h3>Description</h3>

<p>Recover the random effects from the variance-covariance parameter of a linear mixed model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmm'
ranef(
  object,
  effects = "mean",
  scale = "absolute",
  se = FALSE,
  df = NULL,
  transform = (effects %in% c("std", "variance")),
  p = NULL,
  newdata = NULL,
  format = "long",
  simplify = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ranef.lmm_+3A_object">object</code></td>
<td>
<p>a <code>lmm</code> object.</p>
</td></tr>
<tr><td><code id="ranef.lmm_+3A_effects">effects</code></td>
<td>
<p>[character] should the estimated random effects (<code>"mean"</code>) or the estimated variance/standard deviation of the random effects (<code>"variance"</code>,<code>"std"</code>) be output?</p>
</td></tr>
<tr><td><code id="ranef.lmm_+3A_scale">scale</code></td>
<td>
<p>[character] should the total variance, variance relative to each random effect, and residual variance be output (<code>"absolute"</code>).
Or the ratio of these variances relative to the total variance (<code>"relative"</code>).</p>
</td></tr>
<tr><td><code id="ranef.lmm_+3A_se">se</code></td>
<td>
<p>[logical] should standard error and confidence intervals be evaluated using a delta method?
Will slow down the execution of the function.</p>
</td></tr>
<tr><td><code id="ranef.lmm_+3A_df">df</code></td>
<td>
<p>[logical] Should degrees of freedom, computed using Satterthwaite approximation, be output.</p>
</td></tr>
<tr><td><code id="ranef.lmm_+3A_transform">transform</code></td>
<td>
<p>[logical] should confidence intervals for the variance estimates (resp. relative variance estimates) be evaluated using a log-transform (resp. atanh transformation)?</p>
</td></tr>
<tr><td><code id="ranef.lmm_+3A_p">p</code></td>
<td>
<p>[numeric vector] value of the model coefficients to be used. Only relevant if differs from the fitted values.</p>
</td></tr>
<tr><td><code id="ranef.lmm_+3A_newdata">newdata</code></td>
<td>
<p>[data.frame] dataset relative to which the random effects should be computed. Only relevant if differs from the dataset used to fit the model.</p>
</td></tr>
<tr><td><code id="ranef.lmm_+3A_format">format</code></td>
<td>
<p>[character] should each type of random effect be output in a data.frame (<code>format="long"</code>)</p>
</td></tr>
<tr><td><code id="ranef.lmm_+3A_simplify">simplify</code></td>
<td>
<p>[logical] when relevant will convert list with a single element to vectors and omit unessential output.</p>
</td></tr>
<tr><td><code id="ranef.lmm_+3A_...">...</code></td>
<td>
<p>for internal use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider the following mixed model:
</p>
<p style="text-align: center;"><code class="reqn">Y = X\beta + \epsilon = X\beta + Z\eta + \xi</code>
</p>

<p>where the variance of <code class="reqn">\epsilon</code> is denoted <code class="reqn">\Omega</code>,
the variance of <code class="reqn">\eta</code> is denoted <code class="reqn">\Omega_{\eta}</code>,
and the variance of <code class="reqn">\xi</code> is <code class="reqn">\sigma^2 I</code> with <code class="reqn">I</code> is the identity matrix. <br />
The random effets are estimating according to:
</p>
<p style="text-align: center;"><code class="reqn">E[Y|\eta] = \Omega_{\eta} Z^{t} \Omega^{-1} (Y-X\beta)</code>
</p>



<h3>Value</h3>

<p>A data.frame or a list depending on the argument <code>format</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require(nlme)){
data(gastricbypassL, package = "LMMstar")

## random intercept
e.RI &lt;- lmm(weight ~ time + (1|id), data = gastricbypassL)
ranef(e.RI, effects = "mean")
ranef(e.RI, effects = "mean", se = TRUE)

ranef(e.RI, effects = "variance")
ranef(e.RI, effects = "variance", format = "wide")

}
</code></pre>

<hr>
<h2 id='rbind.Wald_lmm'>Linear Hypothesis Testing Across Linear Mixed Models</h2><span id='topic+rbind.Wald_lmm'></span>

<h3>Description</h3>

<p>Linear hypothesis testing accross linear mixed model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Wald_lmm'
rbind(model, ..., effects = NULL, rhs = NULL, name = NULL, sep = ": ")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbind.Wald_lmm_+3A_model">model</code></td>
<td>
<p>a <code>Wald_lmm</code> object (output of <code>anova</code> applied to a <code>lmm</code> object)</p>
</td></tr>
<tr><td><code id="rbind.Wald_lmm_+3A_...">...</code></td>
<td>
<p>possibly other <code>Wald_lmm</code> objects</p>
</td></tr>
<tr><td><code id="rbind.Wald_lmm_+3A_effects">effects</code></td>
<td>
<p>[character or numeric matrix] how to combine the left-hand side of the hypotheses.
By default identity matrix but can also be <code>"Dunnett"</code>,  <code>"Tukey"</code>, or  <code>"Sequen"</code> (see function <code>multcomp::contrMat</code> from the multcomp package).</p>
</td></tr>
<tr><td><code id="rbind.Wald_lmm_+3A_rhs">rhs</code></td>
<td>
<p>[numeric vector] the right hand side of the hypothesis. Should have the same length as the number of row of argument <code>effects</code>.</p>
</td></tr>
<tr><td><code id="rbind.Wald_lmm_+3A_name">name</code></td>
<td>
<p>[character vector or NULL] character used to identify each model in the output.
By default, use the name of the outcome of the model.</p>
</td></tr>
<tr><td><code id="rbind.Wald_lmm_+3A_sep">sep</code></td>
<td>
<p>[character] character used to separate the outcome and the covariate when naming the tests.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>WARNING: in presence of measurements from the same cluster across several models,
the influence function is used to estimate the covariance between the model parameters.
This is why the (robust) standard errors may not match the (model-based) standard error from the linear mixed
Setting the argument <code>robust</code> to <code>FALSE</code> when calling <code>anova.lmm</code> will rescale the (robust) standard errors to mimic the original model-based standard errors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simulate data
set.seed(10)
dL &lt;- sampleRem(1e2, n.times = 3, format = "long")

## estimate mixed models
e.lmm1 &lt;- lmm(Y ~ X1+X2+X3, repetition = ~visit|id, data = dL,
              structure = "CS", df = FALSE)
e.lmm2 &lt;- lmm(Y ~ X1+X8+X9, repetition = ~visit|id, data = dL,
              structure = "CS", df = FALSE)

model.tables(e.lmm1) ## model-based standard errors
model.tables(e.lmm1, robust = TRUE) ## robust standard errors

## select null hypotheses &amp; combine (robust standard errors)
AAA &lt;- anova(e.lmm1, ci = TRUE, effect = c("X1|X2,X3"="X1=0","X2|X1,X3"="X2=0"))
BBB &lt;- anova(e.lmm2, ci = TRUE, effect = c("X1|X8,X9"="X1=0"))

ZZZ &lt;- rbind(AAA,BBB)

## select null hypotheses &amp; combine (model-based like standard errors)
AA &lt;- anova(e.lmm1, ci = TRUE, effect = c("X1|X2,X3"="X1=0","X2|X1,X3"="X2=0"),
             robust = FALSE)
BB &lt;- anova(e.lmm2, ci = TRUE, effect = c("X1|X8,X9"="X1=0"),
             robust = FALSE)
ZZ &lt;- rbind(AA,BB)
</code></pre>

<hr>
<h2 id='RE'>Random Effect Structure</h2><span id='topic+RE'></span>

<h3>Description</h3>

<p>Variance-covariance structure parametrized via random effects.
Can be stratified on a categorical variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RE(formula, var.cluster, var.time, ranef = NULL, add.time)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RE_+3A_formula">formula</code></td>
<td>
<p>formula indicating on which variable to stratify the residual variance and correlation (left hand side)
and variables influencing the residual variance and correlation (right hand side).##'</p>
</td></tr>
<tr><td><code id="RE_+3A_var.cluster">var.cluster</code></td>
<td>
<p>[character] cluster variable.</p>
</td></tr>
<tr><td><code id="RE_+3A_var.time">var.time</code></td>
<td>
<p>[character] time variable.</p>
</td></tr>
<tr><td><code id="RE_+3A_ranef">ranef</code></td>
<td>
<p>[list] characteristics of the random effects</p>
</td></tr>
<tr><td><code id="RE_+3A_add.time">add.time</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A typical formula would be <code>~1</code>, indicating a variance constant over time and the same correlation between all pairs of times.
</p>


<h3>Value</h3>

<p>An object of class <code>CS</code> that can be passed to the argument <code>structure</code> of the <code>lmm</code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RE(~1, var.cluster = "id", var.time = "time")
RE(~gender, var.cluster = "id", var.time = "time")
RE(gender~(1|id), var.time = "time")

</code></pre>

<hr>
<h2 id='remove'>Remove Columns from Output</h2><span id='topic+remove'></span>

<h3>Description</h3>

<p>Auxiliary function that can be used when specifying the argument <code>columns</code> (e.g. calling <code>confint.lmm</code>) to remove columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_+3A_...">...</code></td>
<td>
<p>[character vector] name of the columns to be removed to the default output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(10)
dW &lt;- sampleRem(25, n.times = 1, format = "long")
e.lmm &lt;- lmm(Y~X1, data = dW)

confint(e.lmm, columns = remove("estimate"))

</code></pre>

<hr>
<h2 id='resample'>Inference via Resampling for Linear Mixed Model</h2><span id='topic+resample'></span><span id='topic+resample.lmm'></span>

<h3>Description</h3>

<p>Non-parametric bootstrap or permutation test for Linear Mixed Models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample(object, type, ...)

## S3 method for class 'lmm'
resample(
  object,
  type,
  effects,
  n.sample = 1000,
  studentized = TRUE,
  level = 0.95,
  correction = TRUE,
  trace = TRUE,
  seed = NULL,
  cpus = 1,
  export.cpus = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_+3A_object">object</code></td>
<td>
<p>a <code>lmm</code> object.</p>
</td></tr>
<tr><td><code id="resample_+3A_type">type</code></td>
<td>
<p>[character] should permutation test (<code>"perm-var"</code> or <code>"perm-res"</code>) or non-parametric bootstrap (<code>"boot"</code>) be used?</p>
</td></tr>
<tr><td><code id="resample_+3A_...">...</code></td>
<td>
<p>Not used. For compatibility with the generic method.</p>
</td></tr>
<tr><td><code id="resample_+3A_effects">effects</code></td>
<td>
<p>[character vector] the variable(s) to be permuted or the effect(s) to be tested via non-parametric bootstrap.
Can also be a function of the model parameters when performing non-parametric bootstrap.</p>
</td></tr>
<tr><td><code id="resample_+3A_n.sample">n.sample</code></td>
<td>
<p>[integer] the number of samples used.</p>
</td></tr>
<tr><td><code id="resample_+3A_studentized">studentized</code></td>
<td>
<p>[logical] should a studentized boostrap or permutation test be used?</p>
</td></tr>
<tr><td><code id="resample_+3A_level">level</code></td>
<td>
<p>[numeric,0-1] the confidence level of the confidence intervals.</p>
</td></tr>
<tr><td><code id="resample_+3A_correction">correction</code></td>
<td>
<p>[logical] correction to ensure non-0 p-values, e.g. with permutations the p.value is evaluated as (#more extreme + 1)/(n.sample + 1) instead of (#more extreme)/(n.sample).</p>
</td></tr>
<tr><td><code id="resample_+3A_trace">trace</code></td>
<td>
<p>[logical] should the execution of the resampling be traced?</p>
</td></tr>
<tr><td><code id="resample_+3A_seed">seed</code></td>
<td>
<p>[integer, &gt;0] Random number generator (RNG) state used when starting resampling.</p>
</td></tr>
<tr><td><code id="resample_+3A_cpus">cpus</code></td>
<td>
<p>[integer, &gt;0] number of child-processes for parallel evaluation.
If <code>NULL</code> no state is set.</p>
</td></tr>
<tr><td><code id="resample_+3A_export.cpus">export.cpus</code></td>
<td>
<p>[character vector] name of the variables to export to each cluster.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All approach are carried at the cluster level: </p>

<ul>
<li><p> Bootstrap: sampling with replacement clusters. If a cluster is picked twice then different cluster id is used for each pick.
</p>
</li>
<li><p> Permutation: permuting covariate values between clusters (this only lead to the null hypothesis when the covariate values are constant within clusters)
or assigning new outcome values by, under the null, permuting the normalized residuals, rescaling to residuals, and adding back the permuted fixed effect (any mean effect under H1 would be 0 because of the permutation if the variance-covariance structure is correct). The later procedure originates from Oliver et al (2012).
</p>
</li></ul>

<p>The studentized bootstrap keep the original estimate and standard error but uses the samples to evaluates the quantiles of the distribution used to form the confidence intervals.
The studentized permutation test approximate the distribution of the test statistic under the null (instead of the distribution of the estimate under the null.).
</p>
<p>P-values for the bootstrap are computed by centering the bootstrap distribution of the estimate or test statistic around 0 and evaluating the frequency at which it takes values more extreme than the observed estimate or test statistics.
</p>


<h3>References</h3>

<p>Oliver E. Lee and Thomas M. Braun (2012), <b>Permutation Tests for Random Effects in Linear Mixed Models</b>. <em>Biometrics</em>, Journal 68(2).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

#### univariate linear regression ####
data(gastricbypassW, package = "LMMstar")
## rescale to ease optimization
gastricbypassW$weight1 &lt;- scale(gastricbypassW$weight1)
gastricbypassW$weight2 &lt;- scale(gastricbypassW$weight2)
gastricbypassW$glucagonAUC1 &lt;- scale(gastricbypassW$glucagonAUC1)

e.lm &lt;- lmm(weight2~weight1+glucagonAUC1, data = gastricbypassW)
model.tables(e.lm)

## non-parametric bootstrap
resample(e.lm, type = "boot", effects = c("weight1","glucagonAUC1"), seed = 10)
## permutation test
resample(e.lm, type = "perm-var", effects = "weight1", seed = 10) 
resample(e.lm, type = "perm-var", effects = "glucagonAUC1", seed = 10)
## using multiple cores
resample(e.lm, type = "boot", effects = c("weight1","glucagonAUC1"), cpus = 4)

#### random intercept model ####
data(gastricbypassL, package = "LMMstar")
gastricbypassL$weight &lt;- scale(gastricbypassL$weight)
gastricbypassL$glucagonAUC &lt;- scale(gastricbypassL$glucagonAUC)
gastricbypassL$gender &lt;- as.numeric(gastricbypassL$id) %% 2
gastricbypassLR &lt;- na.omit(gastricbypassL)

eCS.lmm &lt;- lmm(weight~glucagonAUC+gender, data = gastricbypassLR,
               repetition = ~visit|id, structure = "CS")
model.tables(eCS.lmm)

## non-parametric bootstrap
resample(eCS.lmm, type = "boot", effects = c("glucagonAUC","gender"), seed = 10, trace = FALSE)
## permutation test
resample(eCS.lmm, type = "perm-var", effects = "gender", seed = 10)
resample(eCS.lmm, type = "perm-res", effects = "glucagonAUC", seed = 10) 

## End(Not run)

</code></pre>

<hr>
<h2 id='residuals'>Extract The Residuals From a Linear Mixed Model</h2><span id='topic+residuals'></span><span id='topic+residuals.lmm'></span><span id='topic+residuals.clmm'></span><span id='topic+residuals.mlmm'></span>

<h3>Description</h3>

<p>Extract or compute the residuals of a linear mixed model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmm'
residuals(
  object,
  type = "response",
  variable = NULL,
  at = NULL,
  newdata = NULL,
  p = NULL,
  format = "long",
  keep.data = FALSE,
  fitted.ci = FALSE,
  simplify = TRUE,
  var,
  ...
)

## S3 method for class 'clmm'
residuals(object, ...)

## S3 method for class 'mlmm'
residuals(object, simplify = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals_+3A_object">object</code></td>
<td>
<p>a <code>lmm</code> object.</p>
</td></tr>
<tr><td><code id="residuals_+3A_type">type</code></td>
<td>
<p>[character] type of residual to output such as raw residuals (<code>"response"</code>), normalized residuals (<code>"normalized"</code>, partial residuals (<code>"partial"</code>).
Can also be <code>"all"</code> to output all except partial residuals. See detail section.</p>
</td></tr>
<tr><td><code id="residuals_+3A_variable">variable</code></td>
<td>
<p>[character vector] name of the variable relative to which the partial residuals should be computed.</p>
</td></tr>
<tr><td><code id="residuals_+3A_at">at</code></td>
<td>
<p>[data.frame] values for the covariates at which to evaluate the partial residuals.</p>
</td></tr>
<tr><td><code id="residuals_+3A_newdata">newdata</code></td>
<td>
<p>[data.frame] dataset relative to which the residuals should be computed. Only relevant if differs from the dataset used to fit the model.</p>
</td></tr>
<tr><td><code id="residuals_+3A_p">p</code></td>
<td>
<p>[numeric vector] value of the model coefficients at which to evaluate the residuals. Only relevant if differs from the fitted values.</p>
</td></tr>
<tr><td><code id="residuals_+3A_format">format</code></td>
<td>
<p>[character] Should the residuals be output
in a matrix format with clusters in row and timepoints in columns (<code>"wide"</code>),
or in a data.frame/vector with as many rows as observations (<code>"long"</code>)</p>
</td></tr>
<tr><td><code id="residuals_+3A_keep.data">keep.data</code></td>
<td>
<p>[logical] Should the dataset relative to which the residuals are evaluated be output along side the residual values?
Only possible in the long format.</p>
</td></tr>
<tr><td><code id="residuals_+3A_fitted.ci">fitted.ci</code></td>
<td>
<p>[logical] Should the confidence intervals relative to the fitted values be added to the output. Only relevant when argument <code>keep.data=TRUE</code>.</p>
</td></tr>
<tr><td><code id="residuals_+3A_simplify">simplify</code></td>
<td>
<p>[logical] Simplify the data format (vector instead of data.frame) and column names (no mention of the time variable) when possible.
Otherwise, information about the call and reference values used for partial residuals be added as an attribute.</p>
</td></tr>
<tr><td><code id="residuals_+3A_var">var</code></td>
<td>
<p>[Deprecated] Not used anymore, replaced by argument variable.</p>
</td></tr>
<tr><td><code id="residuals_+3A_...">...</code></td>
<td>
<p>Not used. For compatibility with the generic method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>type</code> defines how the residuals are computed:
</p>

<ul>
<li> <p><code>"response"</code>: raw residual, i.e. observed outcome minus fitted value <code class="reqn">\varepsilon_{ij} = Y_{ij} - X_{ij} \hat{\beta}</code>.
</p>
</li>
<li> <p><code>"pearson"</code>: each raw residual is divided by its modeled standard deviation <code class="reqn">\varepsilon_{ij} = \frac{Y_{ij} - X_{ij} \hat{\beta}}{\sqrt{\hat{\omega}_{ij}}}</code>.
</p>
</li>
<li> <p><code>"studentized"</code>: same as <code>"pearson"</code> but excluding the contribution of the cluster in the modeled standard deviation  <code class="reqn">\varepsilon_{ij} = \frac{Y_{ij} - X_{ij} \hat{\beta}}{\sqrt{\hat{\omega}_{ij}-\hat{q}_{ij}}}</code>.
</p>
</li>
<li> <p><code>"normalized"</code>: raw residuals are multiplied, within clusters, by the inverse of the (upper) Cholesky factor of the modeled residual variance covariance matrix <code class="reqn">\varepsilon_{ij} = ( Y_{i} - X_{i} \hat{\beta} )\hat{C}^{-1}</code>.
</p>
</li>
<li> <p><code>"normalized2"</code>: raw residuals are multiplied, within clusters, by the inverse of the modeled residual variance covariance matrix <code class="reqn">\varepsilon_{ij} = ( Y_{i} - X_{i} \hat{\beta} )\hat{Omega}^{-1}</code>.
</p>
</li>
<li> <p><code>"scaled"</code>: scaled residuals (see PROC MIXED in SAS). Numerically identical to <code>"normalized"</code> but computed by sequentially scaling and centering the residuals, to make them conditionally independent of previous residuals from the same cluster at previous repetitions.
</p>
</li>
<li> <p><code>"partial"</code>: partial residuals (<code class="reqn">\gamma E + \hat{\varepsilon}</code>). A reference level can be also be specified via the attribute <code>"reference"</code> to change the absolute level of the partial residuals.
<code>"partial-center"</code>: partial residuals with centered continuous covariates (<code class="reqn">\gamma E + \hat{\varepsilon}</code> where <code class="reqn">E</code> has been centered, i.e., has 0-mean)
</p>
</li></ul>

<p>where
</p>

<ul>
<li> <p><code class="reqn">X=(E,W)</code> the design matrix. For partial residuals, it is split according to the variable(s) in argument <code>variable</code> (<code class="reqn">E</code>) and the rest (<code class="reqn">W</code>).
</p>
</li>
<li> <p><code class="reqn">Y</code> the outcome
</p>
</li>
<li> <p><code class="reqn">\hat{\beta}=(\hat{\gamma},\hat{\delta})</code> the estimated mean coefficients relative to <code class="reqn">X=(E,W)</code>
</p>
</li>
<li> <p><code class="reqn">\hat{\Omega}</code> the modeled variance-covariance of the residuals and <code class="reqn">\hat{\omega}</code> its diagonal elements
</p>
</li>
<li> <p><code class="reqn">\hat{C}</code> the upper Cholesky factor of <code class="reqn">\hat{\Omega}</code>, i.e. upper triangular matrix satisfying <code class="reqn">\hat{C}^{t} \hat{C} = \hat{\Omega}</code>
</p>
</li>
<li> <p><code class="reqn">\hat{Q}_i= X_i (X^{t}\hat{\Omega}X)^{-1}X_i^{t}</code> a cluster specific correction factor, approximating the contribution of cluster i to <code class="reqn">\hat{\Omega}</code>. Its diagonal elements are denoted <code class="reqn">\hat{q}_i</code>.
</p>
</li>
<li> <p><code class="reqn">\hat{D}_i</code> the upper Cholesky factor of <code class="reqn">\hat{\Omega}-\hat{Q}_i</code>
</p>
</li></ul>

<p>Setting argument <code>fitted.ci</code> to <code>TRUE</code>, <code>simplify</code> to <code>FALSE</code>, <code>format</code> to <code>"long"</code> returns an attribute <code>"grad"</code> containing the first order partial derivatives of the residuals with respect to the model parameters.
</p>


<h3>Value</h3>

<p><b>lmm</b>: a vector or a data.frame when <code>format="long"</code> (one line per observation, one column per type of residual),
a matrix when <code>format="wide"</code>  (one line per cluster, one column per timepoint).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### simulate data in the long format ####
set.seed(10)
dL &lt;- sampleRem(100, n.times = 3, format = "long")

#### Linear Model ####
e.lm &lt;- lmm(Y ~ visit + X1 + X2 + X6, data = dL)

## partial residuals
pRes &lt;- residuals(e.lm, type = "partial", variable = "X6")
range(residuals(e.lm) + dL$X6 * coef(e.lm)["X6"] - pRes)
e.reslm &lt;- residuals(e.lm, type = "partial", variable = "X6", keep.data = TRUE, simplify = FALSE)
plot(e.reslm)

## partial residuals with specific reference
residuals(e.lm, type = "partial", variable = "X1",
          at = data.frame(visit=factor(2,1:3),X2=0,X6=3))

## partial residuals with centered covariates
residuals(e.lm, type = "partial-center", variable = "X1")

#### Linear Mixed Model ####
eUN.lmm &lt;- lmm(Y ~ visit + X1 + X2 + X5 + X6,
               repetition = ~visit|id, structure = "UN", data = dL)

## residuals
e.resL &lt;- residuals(eUN.lmm, type = "normalized",
                    keep.data = TRUE, simplify = FALSE)
plot(e.resL, type = "qqplot")
plot(e.resL, type = "scatterplot", labeller = ggplot2::label_both)
e.resW &lt;- residuals(eUN.lmm, format = "wide", type = "normalized",
                    simplify = FALSE)
plot(e.resW, type = "correlation")

## residuals and predicted values
residuals(eUN.lmm, type = "all")
residuals(eUN.lmm, type = "all", keep.data = TRUE)

## partial residuals
residuals(eUN.lmm, type = "partial", variable = c("(Intercept)","visit","X6"))
</code></pre>

<hr>
<h2 id='restaureNA'>Restaure NA</h2><span id='topic+restaureNA'></span>

<h3>Description</h3>

<p>Restaure NA in the user output that have been excluded when fitting the LMM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>restaureNA(object, index.na, level, cluster)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="restaureNA_+3A_object">object</code></td>
<td>
<p>results when NA should be added to match the user input.</p>
</td></tr>
<tr><td><code id="restaureNA_+3A_index.na">index.na</code></td>
<td>
<p>[integer vector] index of the missing values.</p>
</td></tr>
<tr><td><code id="restaureNA_+3A_level">level</code></td>
<td>
<p>[character] Should missing observations, indicated by the argument <code>index.na</code>, be restaured (<code>"obs"</code>)
or should missing clusters, indicated by the discrepancy between the name of the object and the argument <code>cluster</code>, be restaured (<code>"cluster"</code>).</p>
</td></tr>
<tr><td><code id="restaureNA_+3A_cluster">cluster</code></td>
<td>
<p>[list] list containing the number of cluster (<code>n</code>), name of the clusters (<code>levels</code>), and integer associated with each clusters (<code>index</code>).</p>
</td></tr>
</table>

<hr>
<h2 id='sampleRem'>Sample Longuitudinal Data</h2><span id='topic+sampleRem'></span>

<h3>Description</h3>

<p>Sample longuitudinal data with covariates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleRem(
  n,
  n.times,
  mu = 1:n.times,
  sigma = rep(1, n.times),
  lambda = rep(1, n.times),
  beta = c(2, 1, 0, 0, 0, 1, 1, 0, 0, 0),
  gamma = matrix(0, nrow = n.times, ncol = 10),
  format = "wide",
  latent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleRem_+3A_n">n</code></td>
<td>
<p>[integer,&gt;0] sample size</p>
</td></tr>
<tr><td><code id="sampleRem_+3A_n.times">n.times</code></td>
<td>
<p>[integer,&gt;0] number of visits (i.e. measurements per individual).</p>
</td></tr>
<tr><td><code id="sampleRem_+3A_mu">mu</code></td>
<td>
<p>[numeric vector] expected measurement value at each visit (when all covariates are fixed to 0). Must have length <code>n.times</code>.</p>
</td></tr>
<tr><td><code id="sampleRem_+3A_sigma">sigma</code></td>
<td>
<p>[numeric vector,&gt;0] standard error of the measurements at each visit (when all covariates are fixed to 0). Must have length <code>n.times</code>.</p>
</td></tr>
<tr><td><code id="sampleRem_+3A_lambda">lambda</code></td>
<td>
<p>[numeric vector] covariance between the measurement at each visit and the individual latent variable. Must have length <code>n.times</code>.</p>
</td></tr>
<tr><td><code id="sampleRem_+3A_beta">beta</code></td>
<td>
<p>[numeric vector of length 10] regression coefficient between the covariates and the latent variable.</p>
</td></tr>
<tr><td><code id="sampleRem_+3A_gamma">gamma</code></td>
<td>
<p>[numeric matrix with n.times rows and 10 columns] regression coefficient specific to each timepoint (i.e. interaction with time).</p>
</td></tr>
<tr><td><code id="sampleRem_+3A_format">format</code></td>
<td>
<p>[character] Return the data in the wide format (<code>"wide"</code>) or long format (<code>"long"</code>).
Can also be <code>"wide+"</code> or <code>"long+"</code> to export as attributes the function arguments and the latent variable model used to generate the data.</p>
</td></tr>
<tr><td><code id="sampleRem_+3A_latent">latent</code></td>
<td>
<p>[logical] Should the latent variable be output?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The generative model is a latent variable model where each outcome (<code class="reqn">Y_j</code>) load on the latent variable (<code class="reqn">\eta</code>) with a coefficient lambda:
</p>
<p style="text-align: center;"><code class="reqn">Y_j = \mu_j + \lambda_j*\eta + \sigma_j\epsilon_j</code>
</p>

<p>The latent variable is related to the covariates (<code class="reqn">X_1,\ldots,X_(10)</code>):
</p>
<p style="text-align: center;"><code class="reqn">\eta = \alpha + \beta_1 X_1 + ... + \beta_{10} X_{10} + \xi</code>
</p>

<p><code class="reqn">\epsilon_j</code> and <code class="reqn">\xi</code> are independent random variables with standard normal distribution.
</p>


<h3>Value</h3>

<p>a data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### generate data in the wide format ####
set.seed(10)
dW &lt;- sampleRem(100, n.times = 3, format = "wide")
head(dW)

#### generate data in the long format ####
set.seed(10)
dL &lt;- sampleRem(100, n.times = 3, format = "long")
head(dL)
</code></pre>

<hr>
<h2 id='scatterplot'>Scatterplot for Continuous Variables</h2><span id='topic+scatterplot'></span>

<h3>Description</h3>

<p>Produce a matrix of plot for continuous variables: scatterplots, histograms, correlation and missing values.
Inspired from the <code>ggpairs</code> function of the R package GGally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scatterplot(
  data,
  formula,
  columns,
  format = NULL,
  group = NULL,
  transform = NULL,
  facet = "grid",
  alpha.point = 1,
  type.diag = "boxplot",
  bins = NULL,
  position.bar = "identity",
  linewidth.density = NULL,
  alpha.area = NULL,
  method.cor = "pearson",
  name.cor = "r",
  size.cor = NULL,
  digits = c(3, 2),
  display.NA = NULL,
  color = NULL,
  xlim = NULL,
  ylim = NULL,
  size.axis = NULL,
  size.legend = NULL,
  size.facet = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scatterplot_+3A_data">data</code></td>
<td>
<p>[data.frame] dataset containing the variables to be displayed.</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_formula">formula</code></td>
<td>
<p>[formula] formula indicating the variables to be used (outcome~time|id). Long format only.</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_columns">columns</code></td>
<td>
<p>[character vector] Columns whose numerical values are to be displayed. Wide format only.</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_format">format</code></td>
<td>
<p>[character] Is the dataset in the long (<code>"long"</code>) or wide (<code>"wide"</code>) format?</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_group">group</code></td>
<td>
<p>[character] optional group variable used to color the points, stratify the histogram/density and correlation.</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_transform">transform</code></td>
<td>
<p>[character or function] optional transformation to be applied on the outcome.</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_facet">facet</code></td>
<td>
<p>[character] whether to use <code>ggplot:::facet_grid</code> (<code>"grid"</code>) or <code>ggh4x::facet_grid2</code> (<code>"grid2"</code>).</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_alpha.point">alpha.point</code></td>
<td>
<p>[numeric] the transparency level used to display the points in the scatterplot.</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_type.diag">type.diag</code></td>
<td>
<p>[character] type of graphical display on the diagonal: <code>"boxplot"</code>,  <code>"histogram"</code>, or <code>"density"</code>.</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_bins">bins</code></td>
<td>
<p>[character or numeric vector] algorithm or values or number of values used to create the histogram cells.
When using <code>facet="grid2"</code> and <code>density=TRUE</code> a character of length two indicating the bandwith and the kernel to be used.
See <code>ggplot2::stat_density</code>.</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_position.bar">position.bar</code></td>
<td>
<p>[character] passed to <code>geom_histogram</code> (argument <code>position</code>).
Only relevant when having multiple groups and using <code>ggh4x::facet_grid2</code>.</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_linewidth.density">linewidth.density</code></td>
<td>
<p>[numeric,&gt;0] width of the lines on the density plot.</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_alpha.area">alpha.area</code></td>
<td>
<p>[numeric, 0-1] the transparency level used to display the area under the density curve or histogram.</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_method.cor">method.cor</code></td>
<td>
<p>[character] estimator of the correlation. Argument passed to <code>stats::cor</code>.
When <code>NA</code>, the correlation is not displayed.</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_name.cor">name.cor</code></td>
<td>
<p>[character] character used to represent the correlation. By default <code>"r"</code> but can be changed to <code>"\u03C1"</code> to display the greek letter <code class="reqn">\rho</code>.</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_size.cor">size.cor</code></td>
<td>
<p>[numeric,&gt;0] size of the font used to display the correlation or information about missing values.</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_digits">digits</code></td>
<td>
<p>[numeric of length 2] number of digits used to display the correlation or round the percentage of missing values.</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_display.na">display.NA</code></td>
<td>
<p>[0:2 or &quot;only&quot;] Should the number of missing values be displayed. When taking value 2, will also display the percentage of missing values.</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_color">color</code></td>
<td>
<p>[character vector] color used to display the values for each group.</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_xlim">xlim</code></td>
<td>
<p>[numeric,&gt;0 or &quot;common&quot;] range of the x-axis.</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_ylim">ylim</code></td>
<td>
<p>[numeric,&gt;0 or &quot;common&quot;] range of the y-axis.</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_size.axis">size.axis</code></td>
<td>
<p>[numeric,&gt;0] size of the font used to display the tick labels.</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_size.legend">size.legend</code></td>
<td>
<p>[numeric,&gt;0] size of the font used to display the legend. Can have a second element to control the size of the legend key.</p>
</td></tr>
<tr><td><code id="scatterplot_+3A_size.facet">size.facet</code></td>
<td>
<p>[numeric,&gt;0] size of the font used to display the facets (row and column names).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the long format, the outcome variable contains the numerical values to be displayed.
The time variable will be used to spit outcome and display each split separately or jointly with one other split.
The identifier links the outcome values across time.
</p>


<h3>Value</h3>

<p>a list of ggplot objects (<code>facet="grid"</code>) or a ggplot object (<code>facet="grid2"</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gastricbypassL, package = "LMMstar")
gastricbypassL$group &lt;- as.numeric(gastricbypassL$id) %% 3
data(gastricbypassW, package = "LMMstar")

## single group (wide or long format)
scatterplot(gastricbypassL, formula = weight~time|id)
scatterplot(gastricbypassW, columns = paste0("weight",1:4))

## Not run: 
## use histogram instead of boxplot
scatterplot(gastricbypassL, formula = weight~time|id, type.diag = "hist")
scatterplot(gastricbypassL, formula = weight~time|id, type.diag = "hist", bins = 15)

## same scale
scatterplot(gastricbypassL, formula = weight~time|id,
            xlim = "common", ylim = "common")

## transform outcome
scatterplot(gastricbypassL, formula = weight~time|id, transform = "log")

## handling missing values
scatterplot(gastricbypassL, formula = glucagonAUC~time|id)

## coloring per group
scatterplot(gastricbypassL, formula = weight~time|id, group = "group")

## only display NAs
scatterplot(gastricbypassL, formula = glucagonAUC~time|id,
            display.NA = "only", group = "group")
scatterplot(gastricbypassL, formula = glucagonAUC~time|id,
            display.NA = "only", group = "group", size.legend = c(15,2))

## End(Not run)
</code></pre>

<hr>
<h2 id='schoolL'>Simulated Data with 3-level struture (Long Format)</h2><span id='topic+schoolL'></span>

<h3>Description</h3>

<p>Simulated data a nested structure: Student/Class/School and one outcome.
</p>

<ul>
<li> <p><code>school</code>:
</p>
</li>
<li> <p><code>class</code>: 
</p>
</li>
<li> <p><code>student</code>:
</p>
</li>
<li> <p><code>outcome</code>:  
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(schoolL)
</code></pre>

<hr>
<h2 id='score.lmm'>Extract The Score From a Linear Mixed Model</h2><span id='topic+score.lmm'></span>

<h3>Description</h3>

<p>Extract or compute the first derivative of the log-likelihood of a linear mixed model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmm'
score(
  x,
  effects = "mean",
  newdata = NULL,
  p = NULL,
  indiv = FALSE,
  transform.sigma = NULL,
  transform.k = NULL,
  transform.rho = NULL,
  transform.names = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="score.lmm_+3A_x">x</code></td>
<td>
<p>a <code>lmm</code> object.</p>
</td></tr>
<tr><td><code id="score.lmm_+3A_effects">effects</code></td>
<td>
<p>[character] Should the score relative to all coefficients be output (<code>"all"</code>),
or only coefficients relative to the mean (<code>"mean"</code> or <code>"fixed"</code>),
or only coefficients relative to the variance and correlation structure (<code>"variance"</code> or <code>"correlation"</code>).</p>
</td></tr>
<tr><td><code id="score.lmm_+3A_newdata">newdata</code></td>
<td>
<p>[data.frame] dataset relative to which the score should be computed. Only relevant if differs from the dataset used to fit the model.</p>
</td></tr>
<tr><td><code id="score.lmm_+3A_p">p</code></td>
<td>
<p>[numeric vector] value of the model coefficients at which to evaluate the score. Only relevant if differs from the fitted values.</p>
</td></tr>
<tr><td><code id="score.lmm_+3A_indiv">indiv</code></td>
<td>
<p>[logical] Should the contribution of each cluster to the score be output? Otherwise output the sum of all clusters of the derivatives.</p>
</td></tr>
<tr><td><code id="score.lmm_+3A_transform.sigma">transform.sigma</code></td>
<td>
<p>[character] Transformation used on the variance coefficient for the reference level. One of <code>"none"</code>, <code>"log"</code>, <code>"square"</code>, <code>"logsquare"</code> - see details.</p>
</td></tr>
<tr><td><code id="score.lmm_+3A_transform.k">transform.k</code></td>
<td>
<p>[character] Transformation used on the variance coefficients relative to the other levels. One of <code>"none"</code>, <code>"log"</code>, <code>"square"</code>, <code>"logsquare"</code>, <code>"sd"</code>, <code>"logsd"</code>, <code>"var"</code>, <code>"logvar"</code> - see details.</p>
</td></tr>
<tr><td><code id="score.lmm_+3A_transform.rho">transform.rho</code></td>
<td>
<p>[character] Transformation used on the correlation coefficients. One of <code>"none"</code>, <code>"atanh"</code>, <code>"cov"</code> - see details.</p>
</td></tr>
<tr><td><code id="score.lmm_+3A_transform.names">transform.names</code></td>
<td>
<p>[logical] Should the name of the coefficients be updated to reflect the transformation that has been used?</p>
</td></tr>
<tr><td><code id="score.lmm_+3A_...">...</code></td>
<td>
<p>Not used. For compatibility with the generic method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details about the arguments <b>transform.sigma</b>, <b>transform.k</b>, <b>transform.rho</b>, see the documentation of the <a href="#topic+coef.lmm">coef.lmm</a> function.
</p>


<h3>Value</h3>

<p>When argument indiv is <code>FALSE</code>, a vector with the value of the score relative to each coefficient.
When argument indiv is <code>TRUE</code>, a matrix with the value of the score relative to each coefficient (in columns) and each cluster (in rows).
</p>

<hr>
<h2 id='sigma.lmm'>Extract The Residuals Variance-Covariance Matrix From a Linear Mixed Model</h2><span id='topic+sigma.lmm'></span>

<h3>Description</h3>

<p>Extract the unique set of residuals variance-covariance matrices or the one relative to specific clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmm'
sigma(
  object,
  cluster = NULL,
  p = NULL,
  chol = FALSE,
  inverse = FALSE,
  simplify = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sigma.lmm_+3A_object">object</code></td>
<td>
<p>a <code>lmm</code> object.</p>
</td></tr>
<tr><td><code id="sigma.lmm_+3A_cluster">cluster</code></td>
<td>
<p>[character, data.frame, NULL] identifier of the cluster(s) for which to extract the residual variance-covariance matrix.
For new clusters, a dataset containing the information (cluster, time, strata, ...) to be used to generate the residual variance-covariance matrices.
When <code>NULL</code>, will output complete data covariance patterns.</p>
</td></tr>
<tr><td><code id="sigma.lmm_+3A_p">p</code></td>
<td>
<p>[numeric vector] value of the model coefficients at which to evaluate the residual variance-covariance matrix. Only relevant if differs from the fitted values.</p>
</td></tr>
<tr><td><code id="sigma.lmm_+3A_chol">chol</code></td>
<td>
<p>[logical] Output the cholesky factorization of the variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="sigma.lmm_+3A_inverse">inverse</code></td>
<td>
<p>[logical] Output the matrix inverse of the variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="sigma.lmm_+3A_simplify">simplify</code></td>
<td>
<p>[logical] When there is only one variance-covariance matrix, output a matrix instead of a list of matrices.</p>
</td></tr>
<tr><td><code id="sigma.lmm_+3A_...">...</code></td>
<td>
<p>Not used. For compatibility with the generic method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list where each element contains a residual variance-covariance matrix.
Can also be directly a matrix when argument is <code>simplify=TRUE</code> and there is a single residual variance-covariance matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simulate data in the long format
set.seed(10)
dL &lt;- sampleRem(100, n.times = 3, format = "long")
dL$id.fac &lt;- paste0("id",dL$id)

## fit Linear Mixed Model
eUN.lmm &lt;- lmm(Y ~ X1 + X2 + X5, repetition = ~visit|id.fac,
               structure = "UN", data = dL, df = FALSE)

## extract residuals variance covariance matrix
sigma(eUN.lmm) ## unique patterns
sigma(eUN.lmm, cluster = c("id1","id5")) ## existing clusters
sigma(eUN.lmm, cluster = dL[1:7,,drop=FALSE]) ## new clusters
</code></pre>

<hr>
<h2 id='summarize'>Compute summary statistics</h2><span id='topic+summarize'></span>

<h3>Description</h3>

<p>Compute summary statistics for multiple variables and/or multiple groups and save them in a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize(
  formula,
  data,
  na.action = stats::na.pass,
  na.rm = FALSE,
  level = 0.95,
  columns = c("observed", "missing", "pc.missing", "mean", "sd", "min", "q1", "median",
    "q3", "max", "correlation"),
  FUN = NULL,
  skip.reference = TRUE,
  digits = NULL,
  filter = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_+3A_formula">formula</code></td>
<td>
<p>[formula] on the left hand side the outcome(s) and on the right hand side the grouping variables.
E.g. Y1+Y2 ~ Gender + Gene will compute for each gender and gene the summary statistics for Y1 and for Y2.
Passed to the <code>stats::aggregate</code> function.</p>
</td></tr>
<tr><td><code id="summarize_+3A_data">data</code></td>
<td>
<p>[data.frame] dataset containing the observations.</p>
</td></tr>
<tr><td><code id="summarize_+3A_na.action">na.action</code></td>
<td>
<p>[function] a function which indicates what should happen when the data contain 'NA' values.
Passed to the <code>stats::aggregate</code> function.</p>
</td></tr>
<tr><td><code id="summarize_+3A_na.rm">na.rm</code></td>
<td>
<p>[logical] Should the summary statistics be computed by omitting the missing values.</p>
</td></tr>
<tr><td><code id="summarize_+3A_level">level</code></td>
<td>
<p>[numeric,0-1] the confidence level of the confidence intervals.</p>
</td></tr>
<tr><td><code id="summarize_+3A_columns">columns</code></td>
<td>
<p>[character vector] name of the summary statistics to kept in the output.
Can be any of, or a combination of:</p>

<ul>
<li> <p><code>"observed"</code>: number of observations with a measurement.
</p>
</li>
<li> <p><code>"missing"</code>: number of missing observations.
When specifying a grouping variable, it will also attempt to count missing rows in the dataset.
</p>
</li>
<li> <p><code>"pc.missing"</code>: percentage missing observations.
</p>
</li>
<li> <p><code>"mean"</code>, <code>"mean.lower"</code> <code>"mean.upper"</code>: mean with its confidence interval.
</p>
</li>
<li> <p><code>"median"</code>, <code>"median.lower"</code> <code>"median.upper"</code>: median with its confidence interval.
</p>
</li>
<li> <p><code>"sd"</code>: standard deviation.
</p>
</li>
<li> <p><code>"q1"</code>, <code>"q3"</code>, <code>"IQR"</code>: 1st and 3rd quartile, interquartile range.
</p>
</li>
<li> <p><code>"min"</code>, <code>"max"</code>: minimum and maximum observation.
</p>
</li>
<li> <p><code>"predict.lower"</code>, <code>"predict.upper"</code>: prediction interval for normally distributed outcome.
</p>
</li>
<li> <p><code>"correlation"</code>: correlation matrix between the outcomes (when feasible, see detail section).
</p>
</li></ul>
</td></tr>
<tr><td><code id="summarize_+3A_fun">FUN</code></td>
<td>
<p>[function] user-defined function for computing summary statistics.
It should take a vector as an argument and output a named single value or a named vector.</p>
</td></tr>
<tr><td><code id="summarize_+3A_skip.reference">skip.reference</code></td>
<td>
<p>[logical] should the summary statistics for the reference level of categorical variables be omitted?</p>
</td></tr>
<tr><td><code id="summarize_+3A_digits">digits</code></td>
<td>
<p>[integer, &gt;=0] the minimum number of significant digits to be used to display the results. Passed to <code>print.data.frame</code></p>
</td></tr>
<tr><td><code id="summarize_+3A_filter">filter</code></td>
<td>
<p>[character] a regular expression passed to <code>grep</code> to filter the columns of the dataset.
Relevant when using <code>.</code> to indicate all other variables.</p>
</td></tr>
<tr><td><code id="summarize_+3A_...">...</code></td>
<td>
<p>additional arguments passed to argument <code>FUN</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is essentially an interface to the <code>stats::aggregate</code> function. <br />
<b>WARNING:</b> it has the same name as a function from the dplyr package. If you have loaded dplyr already, you should use <code>:::</code> to call summarize i.e. use <code>LMMstar:::summarize</code>.
</p>
<p>Confidence intervals (CI) and prediction intervals (PI) for the mean are computed via <code>stats::t.test</code>.
Confidence intervals (CI) for the median are computed via <code>asht::medianTest</code>.
</p>
<p>Correlation can be assessed when a grouping and ordering variable are given in the formula interface , e.g. Y ~ time|id.
</p>


<h3>Value</h3>

<p>A data frame containing summary statistics (in columns) for each outcome and value of the grouping variables (rows). It has an attribute <code>"correlation"</code> when it was possible to compute the correlation matrix for each outcome with respect to the grouping variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### simulate data (wide format) ####
set.seed(10)
d &lt;- sampleRem(1e2, n.times = 3)
d$treat &lt;-  sample(LETTERS[1:3], NROW(d), replace=TRUE, prob=c(0.3, 0.3, 0.4) )

## add a missing value
d2 &lt;- d
d2[1,"Y2"] &lt;- NA

#### summarize (wide format) ####
summarize(Y1 ~ 1, data = d)
summarize(Y1 ~ 1, data = d, FUN = quantile, p = c(0.25,0.75))
summarize(Y1+Y2 ~ X1, data = d)
summarize(treat ~ 1, data = d)
summarize(treat ~ 1, skip.reference = FALSE, data = d)

summarize(Y1 ~ X1, data = d2)
summarize(Y1+Y2 ~ X1, data = d2, na.rm = TRUE)
summarize(. ~ treat, data = d2, na.rm = TRUE, filter = "Y")

#### summarize (long format) ####
dL &lt;- reshape(d, idvar = "id", direction = "long",
             v.names = "Y", varying = c("Y1","Y2","Y3"))
summarize(Y ~ time + X1, data = dL)

## compute correlations (single time variable)
e.S &lt;- summarize(Y ~ time + X1 | id, data = dL, na.rm = TRUE)
e.S
attr(e.S, "correlation")

## compute correlations (composite time variable)
dL$time2 &lt;- dL$time == 2
dL$time3 &lt;- dL$time == 3
e.S &lt;- summarize(Y ~ time2 + time3 + X1 | id, data = dL, na.rm = TRUE)
e.S
attr(e.S, "correlation")

</code></pre>

<hr>
<h2 id='summarizeNA'>Summarize missing data patterns</h2><span id='topic+summarizeNA'></span>

<h3>Description</h3>

<p>Summarize missing data patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarizeNA(
  data,
  repetition = NULL,
  sep = "",
  newnames = c("variable", "frequency", "missing.pattern", "n.missing"),
  keep.data = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarizeNA_+3A_data">data</code></td>
<td>
<p>[data.frame] dataset containing the observations.</p>
</td></tr>
<tr><td><code id="summarizeNA_+3A_repetition">repetition</code></td>
<td>
<p>[formula] Specify the structure of the data when in the long format: the time/repetition variable and the grouping variable, e.g. ~ time|id.
When specified the missing data pattern is specific to each variable not present in the formula.</p>
</td></tr>
<tr><td><code id="summarizeNA_+3A_sep">sep</code></td>
<td>
<p>[character] character used to separate the missing data indicator (0/1) when naming the missing data patterns.</p>
</td></tr>
<tr><td><code id="summarizeNA_+3A_newnames">newnames</code></td>
<td>
<p>[character vector of length 4] additional column containing the variable name (only when argument <code>repetition</code> is used),
the frequency of the missing data pattern in the dataset, the name of the missing data pattern in the dataset, and the number of missing data per pattern.</p>
</td></tr>
<tr><td><code id="summarizeNA_+3A_keep.data">keep.data</code></td>
<td>
<p>[logical] should the indicator of missing data per variable in the original dataset per pattern be output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+autoplot.summarizeNA">autoplot.summarizeNA</a></code> for a graphical display.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### display missing data pattern (wide format) ####
data(gastricbypassW, package = "LMMstar")
e.SNA &lt;- summarizeNA(gastricbypassW) 
plot(e.SNA)
summarizeNA(gastricbypassW, keep.data = FALSE)

#### display missing data pattern (long format) ####
## example 1
data(gastricbypassL, package = "LMMstar")
e.SNAL &lt;- summarizeNA(gastricbypassL, repetition = ~time|id)
plot(e.SNAL, variable = "glucagonAUC")

## example 2
data(calciumL, package = "LMMstar")
mp &lt;- summarizeNA(calciumL, repetition = ~visit|girl)
plot(mp, variable = "bmd")
summarizeNA(calciumL[,c("visit","girl","bmd")], repetition = ~visit|girl)

## example 3
data(vasscoresW, package = "LMMstar")
summarizeNA(vasscoresW)
</code></pre>

<hr>
<h2 id='summary.lmm'>Summary Output for a Linear Mixed Model</h2><span id='topic+summary.lmm'></span>

<h3>Description</h3>

<p>Summary output for a linear mixed model fitted with <code>lmm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmm'
summary(
  object,
  level = 0.95,
  robust = FALSE,
  print = TRUE,
  columns = NULL,
  digits = 3,
  digits.df = 1,
  digits.p.value = 3,
  hide.data = FALSE,
  hide.fit = FALSE,
  hide.cor = NULL,
  type.cor = NULL,
  hide.var = NULL,
  hide.sd = NULL,
  hide.re = NULL,
  hide.mean = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.lmm_+3A_object">object</code></td>
<td>
<p>[lmm] output of the <code>lmm</code> function.</p>
</td></tr>
<tr><td><code id="summary.lmm_+3A_level">level</code></td>
<td>
<p>[numeric,0-1] confidence level for the confidence intervals.</p>
</td></tr>
<tr><td><code id="summary.lmm_+3A_robust">robust</code></td>
<td>
<p>[logical] Should robust standard errors (aka sandwich estimator) be output instead of the model-based standard errors.</p>
</td></tr>
<tr><td><code id="summary.lmm_+3A_print">print</code></td>
<td>
<p>[logical] should the output be printed in the console.</p>
</td></tr>
<tr><td><code id="summary.lmm_+3A_columns">columns</code></td>
<td>
<p>[character vector] Columns to be output for the fixed effects.
Can be any of <code>"estimate"</code>, <code>"se"</code>, <code>"statistic"</code>, <code>"df"</code>, <code>"null"</code>, <code>"lower"</code>, <code>"upper"</code>, <code>"p.value"</code>.</p>
</td></tr>
<tr><td><code id="summary.lmm_+3A_digits">digits</code></td>
<td>
<p>[interger, &gt;0] number of digits used to display estimates.</p>
</td></tr>
<tr><td><code id="summary.lmm_+3A_digits.df">digits.df</code></td>
<td>
<p>[interger, &gt;0] number of digits used to display degrees of freedom.</p>
</td></tr>
<tr><td><code id="summary.lmm_+3A_digits.p.value">digits.p.value</code></td>
<td>
<p>[interger, &gt;0] number of digits used to display p-values.</p>
</td></tr>
<tr><td><code id="summary.lmm_+3A_hide.data">hide.data</code></td>
<td>
<p>[logical] should information about the dataset not be printed.</p>
</td></tr>
<tr><td><code id="summary.lmm_+3A_hide.fit">hide.fit</code></td>
<td>
<p>[logical] should information about the model fit not be printed.</p>
</td></tr>
<tr><td><code id="summary.lmm_+3A_hide.cor">hide.cor</code></td>
<td>
<p>[logical] should information about the correlation structure not be printed.</p>
</td></tr>
<tr><td><code id="summary.lmm_+3A_type.cor">type.cor</code></td>
<td>
<p>[character] should the correlation matrix be display (<code>"matrix"</code>) or the parameter values (<code>"param"</code>).</p>
</td></tr>
<tr><td><code id="summary.lmm_+3A_hide.var">hide.var</code></td>
<td>
<p>[logical] should information about the variance not be printed.</p>
</td></tr>
<tr><td><code id="summary.lmm_+3A_hide.sd">hide.sd</code></td>
<td>
<p>[logical] should information about the standard deviation not be printed.</p>
</td></tr>
<tr><td><code id="summary.lmm_+3A_hide.re">hide.re</code></td>
<td>
<p>[logical] should information about the random effect not be printed.</p>
</td></tr>
<tr><td><code id="summary.lmm_+3A_hide.mean">hide.mean</code></td>
<td>
<p>[logical] should information about the mean structure not be printed.</p>
</td></tr>
<tr><td><code id="summary.lmm_+3A_...">...</code></td>
<td>
<p>not used. For compatibility with the generic function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing elements displayed in the summary: </p>

<ul>
<li> <p><code>correlation</code>: the correlation structure.
</p>
</li>
<li> <p><code>variance</code>: the variance structure.
</p>
</li>
<li> <p><code>sd</code>: the variance structure expressed in term of standard deviations.
</p>
</li>
<li> <p><code>mean</code>: the mean structure.
</p>
</li></ul>


<hr>
<h2 id='summary.mlmm'>Summary of Multiple Linear Mixed Models</h2><span id='topic+summary.mlmm'></span>

<h3>Description</h3>

<p>Estimates, p-values, and confidence intevals for multiple linear mixed models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mlmm'
summary(
  object,
  digits = 3,
  method = NULL,
  print = NULL,
  hide.data = FALSE,
  hide.fit = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.mlmm_+3A_object">object</code></td>
<td>
<p>an <code>mlmm</code> object, output of <code>mlmm</code>.</p>
</td></tr>
<tr><td><code id="summary.mlmm_+3A_digits">digits</code></td>
<td>
<p>[integer,&gt;0] number of digits used to display numeric values.</p>
</td></tr>
<tr><td><code id="summary.mlmm_+3A_method">method</code></td>
<td>
<p>[character] type of adjustment for multiple comparisons: one of <code>"none"</code>, <code>"bonferroni"</code>, <code>"single-step"</code>, <code>"single-step2"</code>.</p>
</td></tr>
<tr><td><code id="summary.mlmm_+3A_print">print</code></td>
<td>
<p>[logical] should the output be printed in the console.
Can be a vector of length 2 where the first element refer to the global tests and the second to the individual tests.</p>
</td></tr>
<tr><td><code id="summary.mlmm_+3A_hide.data">hide.data</code></td>
<td>
<p>[logical] should information about the dataset not be printed.</p>
</td></tr>
<tr><td><code id="summary.mlmm_+3A_hide.fit">hide.fit</code></td>
<td>
<p>[logical] should information about the model fit not be printed.</p>
</td></tr>
<tr><td><code id="summary.mlmm_+3A_...">...</code></td>
<td>
<p>other arguments are passed to <code><a href="#topic+summary.Wald_lmm">summary.Wald_lmm</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='summary.partialCor'>Summary for partial correlation</h2><span id='topic+summary.partialCor'></span>

<h3>Description</h3>

<p>Display estimated partial correlation and associated p-values and confidence intevals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'partialCor'
summary(object, digits = 3, detail = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.partialCor_+3A_object">object</code></td>
<td>
<p>a <code>partialCor</code> object, output of <code>partialCor</code>.</p>
</td></tr>
<tr><td><code id="summary.partialCor_+3A_digits">digits</code></td>
<td>
<p>[integer,&gt;0] number of digits used to display numeric values.</p>
</td></tr>
<tr><td><code id="summary.partialCor_+3A_detail">detail</code></td>
<td>
<p>[integer,&gt;0] passed to <code>print.confint_lmm</code>. If above 0.5 also display when a back-transformation has been used.</p>
</td></tr>
<tr><td><code id="summary.partialCor_+3A_...">...</code></td>
<td>
<p>other arguments are passed to <code>print.confint_lmm</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='summary.Wald_lmm'>Summary of Testing for a Linear Mixed Models</h2><span id='topic+summary.Wald_lmm'></span>

<h3>Description</h3>

<p>Estimates, p-values, and confidence intevals for linear hypothesis testing, possibly adjusted for multiple comparisons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Wald_lmm'
summary(
  object,
  print = TRUE,
  seed = NULL,
  columns = NULL,
  legend = TRUE,
  digits = 3,
  digits.df = 1,
  digits.p.value = 3,
  sep = ": ",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.Wald_lmm_+3A_object">object</code></td>
<td>
<p>an <code>Wald_lmm</code> object, output of <code>anova</code>.</p>
</td></tr>
<tr><td><code id="summary.Wald_lmm_+3A_print">print</code></td>
<td>
<p>[logical] should the output be printed in the console.
Can be a vector of length 2 where the first element refer to the global tests and the second to the individual tests.</p>
</td></tr>
<tr><td><code id="summary.Wald_lmm_+3A_seed">seed</code></td>
<td>
<p>[integer] value that will be set before adjustment for multiple comparisons to ensure reproducible results.
Can also be <code>NULL</code>: in such a case no seed is set.</p>
</td></tr>
<tr><td><code id="summary.Wald_lmm_+3A_columns">columns</code></td>
<td>
<p>[character vector] Columns to be displayed for each null hypothesis.
Can be any of <code>"type"</code>, <code>"estimate"</code>, <code>"se"</code>, <code>"statistic"</code>, <code>"df"</code>, <code>"null"</code>, <code>"lower"</code>, <code>"upper"</code>, <code>"p.value"</code>.##'</p>
</td></tr>
<tr><td><code id="summary.Wald_lmm_+3A_legend">legend</code></td>
<td>
<p>[logical] should explanations about the content of the table be displayed.</p>
</td></tr>
<tr><td><code id="summary.Wald_lmm_+3A_digits">digits</code></td>
<td>
<p>[interger, &gt;0] number of digits used to display estimates.</p>
</td></tr>
<tr><td><code id="summary.Wald_lmm_+3A_digits.df">digits.df</code></td>
<td>
<p>[interger, &gt;0] number of digits used to display degrees of freedom.</p>
</td></tr>
<tr><td><code id="summary.Wald_lmm_+3A_digits.p.value">digits.p.value</code></td>
<td>
<p>[interger, &gt;0] number of digits used to display p-values.</p>
</td></tr>
<tr><td><code id="summary.Wald_lmm_+3A_sep">sep</code></td>
<td>
<p>[character] character string used to separate the type of test (e.g. mean, variance) and the name of the test.</p>
</td></tr>
<tr><td><code id="summary.Wald_lmm_+3A_...">...</code></td>
<td>
<p>arguments <code>method</code>, <code>level</code>, and <code>backtransform</code> passed to <code><a href="#topic+confint.Wald_lmm">confint.Wald_lmm</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default adjustment for multiple comparisons via a single step max-test adjustment,
either using the multcomp package (equal degrees of freedom, <code>method="single-step"</code>) or the copula package (unequal degrees of freedom, <code>method="single-step2"</code>).
See the argument <code>method</code> of <code><a href="#topic+confint.Wald_lmm">confint.Wald_lmm</a></code> for other adjustments for multiple comparisons. <br />
When multiple multivariate Wald tests are performed, adjustment for multiple comparisons for the univariate Wald tests is performed within each multivariate Wald test.
The number of tests ajusted for equal the first degree of freedom of the multivariate Wald statistic. <br />
</p>
<p>Adding the value <code>"type"</code> in argument <code>"columns"</code> ensures that the type of parameter that is being test (mean, variance, correlation) is output.
</p>


<h3>Value</h3>

<p><code>NULL</code>
</p>

<hr>
<h2 id='swabsL'>Data From The SWABS Study (Long Format)</h2><span id='topic+swabsL'></span>

<h3>Description</h3>

<p>Data from the swabs study,
where the pneumococcus was studied in 18 families with different space available for the household.
This dataset is in the long format (i.e. one line per measurement).
</p>

<ul>
<li> <p><code>crowding</code>: space available in the household.
</p>
</li>
<li> <p><code>family</code>: family serial number
</p>
</li>
<li> <p><code>name</code>: type of family member.
</p>
</li>
<li> <p><code>swabs</code>: number of times the swab measurement was positive.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(swabsL)
</code></pre>


<h3>References</h3>

<p>TODO
</p>

<hr>
<h2 id='swabsW'>Data From The SWABS Study (Wide Format)</h2><span id='topic+swabsW'></span>

<h3>Description</h3>

<p>Data from the swabs study,
where the pneumococcus was studied in 18 families with different space available for the household.
This dataset is in the wide format (i.e. one line per patient).
</p>

<ul>
<li> <p><code>crowding</code>: space available in the household.
</p>
</li>
<li> <p><code>family</code>: family serial number
</p>
</li>
<li> <p><code>mother</code>: number of times the swab measurement was positive for the mother.
</p>
</li>
<li> <p><code>father</code>: number of times the swab measurement was positive for the father.
</p>
</li>
<li> <p><code>child1</code>: number of times the swab measurement was positive for the first child.
</p>
</li>
<li> <p><code>child2</code>: number of times the swab measurement was positive for the second child.
</p>
</li>
<li> <p><code>child3</code>: number of times the swab measurement was positive for the third child.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(swabsW)
</code></pre>


<h3>References</h3>

<p>Grundy SM, Lan SP, Lachin J. The effects of chenodiol on biliary lipids and their association with gallstone dissolution in the National Cooperative Gallstone Study (SWABS). J Clin Invest. 1984 Apr;73(4):1156-66. doi: 10.1172/JCI111301.
</p>

<hr>
<h2 id='terms.lmm'>Model Terms For Linear Mixed Models</h2><span id='topic+terms.lmm'></span>

<h3>Description</h3>

<p>Model terms for linear mixed models. Used by <code>multcomp::glht</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmm'
terms(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="terms.lmm_+3A_x">x</code></td>
<td>
<p>a <code>lmm</code> object</p>
</td></tr>
<tr><td><code id="terms.lmm_+3A_...">...</code></td>
<td>
<p>not used, for compatibility with the generic method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>terms</code> giving a symbolic representation of the mean structure.
</p>

<hr>
<h2 id='TOEPLITZ'>Toeplitz Structure</h2><span id='topic+TOEPLITZ'></span>

<h3>Description</h3>

<p>Variance-covariance structure where the correlation depends on time elapsed between two repetitions.
Can be stratified on a categorical variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TOEPLITZ(formula, var.cluster, var.time, type = "LAG", add.time)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TOEPLITZ_+3A_formula">formula</code></td>
<td>
<p>formula indicating on which variable to stratify the residual variance and correlation (left hand side)
and variables influencing the residual variance and correlation (right hand side).</p>
</td></tr>
<tr><td><code id="TOEPLITZ_+3A_var.cluster">var.cluster</code></td>
<td>
<p>[character] cluster variable.</p>
</td></tr>
<tr><td><code id="TOEPLITZ_+3A_var.time">var.time</code></td>
<td>
<p>[character] time variable.</p>
</td></tr>
<tr><td><code id="TOEPLITZ_+3A_type">type</code></td>
<td>
<p>[character] degree of flexibility of the correlation structure within covariate (<code>"UN","LAG","CS"</code>).
Will also affect the variance structure when not explicit.</p>
</td></tr>
<tr><td><code id="TOEPLITZ_+3A_add.time">add.time</code></td>
<td>
<p>Should the default formula (i.e. when <code>NULL</code>) contain a time effect.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><b>formula</b>: there can only be at most one covariate for the correlation structure.
A typical formula would be <code>~1</code>, indicating a variance constant over time and a correlation specific to each gap time.
</p>
<p><b>type</b>: for a binary covariate the correlation matrix can be decomposed into four blocs: A, B, B, C.
A correspond the correlation within level 0 of the covariate, C within level 1, and B between level 0 and 1.
Different correlation structures can be specified:</p>
 
<ul>
<li> <p><code>"UN"</code>: unstructured matrix except for the diagonal elements of C which are constrained to be equal.
</p>
</li>
<li> <p><code>"LAG"</code>: Toeplitz structure within A, B, and C, i.e. correlation specific to each time lag and covariate level.
</p>
</li>
<li> <p><code>"CS"</code>: block-specific value except for C which has a different value for its diagonal elements.
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class <code>TOEPLITZ</code> that can be passed to the argument <code>structure</code> of the <code>lmm</code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## no covariate
TOEPLITZ(~time, var.cluster = "id", var.time = "time")
TOEPLITZ(gender~time, var.cluster = "id", var.time = "time")
TOEPLITZ(list(~time,~time), var.cluster = "id", var.time = "time")
TOEPLITZ(list(gender~time,gender~time), var.cluster = "id", var.time = "time")

## with covariates
TOEPLITZ(~side, var.cluster = "id", type = "UN",
         var.time = "time", add.time = TRUE)
TOEPLITZ(~side, var.cluster = "id", type = "LAG",
         var.time = "time", add.time = TRUE)
TOEPLITZ(~side, var.cluster = "id", type = "CS",
         var.time = "time", add.time = TRUE)
TOEPLITZ(gender~side, var.cluster = "id", type = "CS",
         var.time = "time", add.time = TRUE)
</code></pre>

<hr>
<h2 id='UN'>Unstructured Structure</h2><span id='topic+UN'></span>

<h3>Description</h3>

<p>Variance-covariance structure where the residuals have time-specific variance and correlation.
Can be stratified on a categorical variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UN(formula, var.cluster, var.time, add.time)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UN_+3A_formula">formula</code></td>
<td>
<p>formula indicating on which variable to stratify the covariance structure.</p>
</td></tr>
<tr><td><code id="UN_+3A_var.cluster">var.cluster</code></td>
<td>
<p>[character] cluster variable.</p>
</td></tr>
<tr><td><code id="UN_+3A_var.time">var.time</code></td>
<td>
<p>[character] time variable.</p>
</td></tr>
<tr><td><code id="UN_+3A_add.time">add.time</code></td>
<td>
<p>Should the default formula (i.e. when <code>NULL</code>) contain a time effect.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A typical formula would be <code>~1</code>, indicating a time-specific variance parameter and a correlation parameter specific to each pair of times.
</p>


<h3>Value</h3>

<p>An object of class <code>UN</code> that can be passed to the argument <code>structure</code> of the <code>lmm</code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>UN(NULL, var.cluster = "id", var.time = "time", add.time = TRUE)
UN(~gender, var.cluster = "id", var.time = "time", add.time = TRUE)
UN(gender ~ 1, var.cluster = "id", var.time = "time", add.time = TRUE)
UN(list(~gender,~1), var.cluster = "id", var.time = "time", add.time = TRUE)
UN(list(gender~age,gender~1), var.cluster = "id", var.time = "time", add.time = TRUE)

</code></pre>

<hr>
<h2 id='vasscoresL'>Data From The VAS Study (Long Format)</h2><span id='topic+vasscoresL'></span>

<h3>Description</h3>

<p>Data from the VAS Study,
a randomized controlled clinial trial assessing the healing effect of topical zink sulfate on epidermal wound.
The study includes 30 heatlhy volunteers with induced wounds on each buttock which where subsequently treated with a different treatment for each wound.
Then the VAS-score (pain sensation on a 0-100mm visual analogue scale) was assessed after each treatment application and summarized by area under the curve.
This dataset is in the long format (i.e. one line per measurement).
</p>

<ul>
<li> <p><code>id</code>: patient identifier.
</p>
</li>
<li> <p><code>group</code>: treatment group to which the patient has been randomized.
</p>
</li>
<li> <p><code>treat.num</code>:
</p>
</li>
<li> <p><code>vas</code>: VAS-score relative to the wound.
</p>
</li>
<li> <p><code>treatment</code>: Treatment used on the wound.
A: active treatment (zink shower gel),
B: placebo treatment (shower gel without zink),
C: control treatment (demineralized water).
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(vasscoresL)
</code></pre>


<h3>References</h3>

<p>TODO
</p>

<hr>
<h2 id='vasscoresW'>Data From The VAS Study (Wide Format)</h2><span id='topic+vasscoresW'></span>

<h3>Description</h3>

<p>Data from the VAS Study,
a randomized controlled clinial trial assessing the healing effect of topical zink sulfate on epidermal wound.
The study includes 30 heatlhy volunteers with induced wounds on each buttock which where subsequently treated with a different treatment for each wound.
Then the VAS-score (pain sensation on a 0-100mm visual analogue scale) was assessed after each treatment application and summarized by area under the curve.
This dataset is in the wide format (i.e. one line per patient).
</p>

<ul>
<li> <p><code>id</code>: patient identifier.
</p>
</li>
<li> <p><code>group</code>: treatment group to which the patient has been randomized.
</p>
</li>
<li> <p><code>vasA</code>: VAS-score when using a zink shower gel.
</p>
</li>
<li> <p><code>vasB</code>: VAS-score when using a placebo treatment (shower gel without zink).
</p>
</li>
<li> <p><code>vasC</code>: VAS-score when using a control treatment with demineralized water.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(vasscoresW)
</code></pre>


<h3>References</h3>

<p>TODO
</p>

<hr>
<h2 id='vcov.lmm'>Extract The Variance-Covariance Matrix From a Linear Mixed Model</h2><span id='topic+vcov.lmm'></span>

<h3>Description</h3>

<p>Extract the variance-covariance matrix of the model coefficients of a linear mixed model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmm'
vcov(
  object,
  effects = "mean",
  robust = FALSE,
  df = FALSE,
  strata = NULL,
  newdata = NULL,
  p = NULL,
  type.information = NULL,
  transform.sigma = NULL,
  transform.k = NULL,
  transform.rho = NULL,
  transform.names = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.lmm_+3A_object">object</code></td>
<td>
<p>a <code>lmm</code> object.</p>
</td></tr>
<tr><td><code id="vcov.lmm_+3A_effects">effects</code></td>
<td>
<p>[character] Should the variance-covariance matrix for all coefficients be output (<code>"all"</code>),
or only for coefficients relative to the mean (<code>"mean"</code> or <code>"fixed"</code>),
or only for coefficients relative to the variance structure (<code>"variance"</code>),
or only for coefficients relative to the correlation structure (<code>"correlation"</code>).</p>
</td></tr>
<tr><td><code id="vcov.lmm_+3A_robust">robust</code></td>
<td>
<p>[logical] Should robust standard errors (aka sandwich estimator) be output instead of the model-based standard errors. Not feasible for variance or correlation coefficients estimated by REML.</p>
</td></tr>
<tr><td><code id="vcov.lmm_+3A_df">df</code></td>
<td>
<p>[logical] Should degree of freedom, computed using Satterthwaite approximation, for the model parameters be output.</p>
</td></tr>
<tr><td><code id="vcov.lmm_+3A_strata">strata</code></td>
<td>
<p>[character vector] When not <code>NULL</code>, only output the variance-covariance matrix for the estimated parameters relative to specific levels of the variable used to stratify the mean and covariance structure.</p>
</td></tr>
<tr><td><code id="vcov.lmm_+3A_newdata">newdata</code></td>
<td>
<p>[data.frame] dataset relative to which the information should be computed. Only relevant if differs from the dataset used to fit the model.</p>
</td></tr>
<tr><td><code id="vcov.lmm_+3A_p">p</code></td>
<td>
<p>[numeric vector] value of the model coefficients at which to evaluate the information. Only relevant if differs from the fitted values.</p>
</td></tr>
<tr><td><code id="vcov.lmm_+3A_type.information">type.information</code></td>
<td>
<p>[character] Should the expected information be used  (i.e. minus the expected second derivative) or the observed inforamtion (i.e. minus the second derivative).</p>
</td></tr>
<tr><td><code id="vcov.lmm_+3A_transform.sigma">transform.sigma</code></td>
<td>
<p>[character] Transformation used on the variance coefficient for the reference level. One of <code>"none"</code>, <code>"log"</code>, <code>"square"</code>, <code>"logsquare"</code> - see details.</p>
</td></tr>
<tr><td><code id="vcov.lmm_+3A_transform.k">transform.k</code></td>
<td>
<p>[character] Transformation used on the variance coefficients relative to the other levels. One of <code>"none"</code>, <code>"log"</code>, <code>"square"</code>, <code>"logsquare"</code>, <code>"sd"</code>, <code>"logsd"</code>, <code>"var"</code>, <code>"logvar"</code> - see details.</p>
</td></tr>
<tr><td><code id="vcov.lmm_+3A_transform.rho">transform.rho</code></td>
<td>
<p>[character] Transformation used on the correlation coefficients. One of <code>"none"</code>, <code>"atanh"</code>, <code>"cov"</code> - see details.</p>
</td></tr>
<tr><td><code id="vcov.lmm_+3A_transform.names">transform.names</code></td>
<td>
<p>[logical] Should the name of the coefficients be updated to reflect the transformation that has been used?</p>
</td></tr>
<tr><td><code id="vcov.lmm_+3A_...">...</code></td>
<td>
<p>Not used. For compatibility with the generic method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details about the arguments <b>transform.sigma</b>, <b>transform.k</b>, <b>transform.rho</b>, see the documentation of the <a href="#topic+coef.lmm">coef.lmm</a> function.
</p>


<h3>Value</h3>

<p>A matrix with an attribute <code>"df"</code> when argument df is set to <code>TRUE</code>.
</p>

<hr>
<h2 id='vitaminL'>Data From The Vitamin Study (Long Format)</h2><span id='topic+vitaminL'></span>

<h3>Description</h3>

<p>Data from the vitamin Study,
a randomized study where the growth of guinea pigs was monitored before and after intake of vitamin E/placebo.
The weight of each guinea pig was recorded at the end of week 1, 3, 4, 5, 6, and 7. Vitamin E/placebo is given at the beginning of week 5.
This dataset is in the long format (i.e. one line per measurement).
</p>

<ul>
<li> <p><code>group</code>: treatment group: vitamin or placebo.
</p>
</li>
<li> <p><code>animal</code>: identifier
</p>
</li>
<li> <p><code>weight1</code>: weight (in g) of the pig at the end of week 1 (before treatment).
</p>
</li>
<li> <p><code>weight3</code>: weight (in g) of the pig at the end of week 3 (before treatment).
</p>
</li>
<li> <p><code>weight4</code>: weight (in g) of the pig at the end of week 4 (before treatment).
</p>
</li>
<li> <p><code>weight5</code>: weight (in g) of the pig at the end of week 5 (after treatment).
</p>
</li>
<li> <p><code>weight6</code>: weight (in g) of the pig at the end of week 6 (after treatment).
</p>
</li>
<li> <p><code>weight7</code>: weight (in g) of the pig at the end of week 7 (after treatment).
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(vitaminL)
</code></pre>


<h3>References</h3>

<p>Crowder and Hand (1990, p. 27) Analysis of Repeated Measures.
</p>

<hr>
<h2 id='vitaminW'>Data From The Vitamin Study (Wide Format)</h2><span id='topic+vitaminW'></span>

<h3>Description</h3>

<p>Data from the vitamin Study,
a randomized study where the growth of guinea pigs was monitored before and after intake of vitamin E/placebo.
The weight of each guinea pig was recorded at the end of week 1, 3, 4, 5, 6, and 7. Vitamin E/placebo is given at the beginning of week 5.
This dataset is in the wide format (i.e. one line per patient).
</p>

<ul>
<li> <p><code>group</code>: treatment group: vitamin or placebo.
</p>
</li>
<li> <p><code>animal</code>: identifier
</p>
</li>
<li> <p><code>weight1</code>: weight (in g) of the pig at the end of week 1 (before treatment).
</p>
</li>
<li> <p><code>weight3</code>: weight (in g) of the pig at the end of week 3 (before treatment).
</p>
</li>
<li> <p><code>weight4</code>: weight (in g) of the pig at the end of week 4 (before treatment).
</p>
</li>
<li> <p><code>weight5</code>: weight (in g) of the pig at the end of week 5 (after treatment).
</p>
</li>
<li> <p><code>weight6</code>: weight (in g) of the pig at the end of week 6 (after treatment).
</p>
</li>
<li> <p><code>weight7</code>: weight (in g) of the pig at the end of week 7 (after treatment).
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(vitaminW)
</code></pre>


<h3>References</h3>

<p>TODO
</p>

<hr>
<h2 id='weights.Wald_lmm'>Extract Weights Used to Pool Estimates</h2><span id='topic+weights.Wald_lmm'></span>

<h3>Description</h3>

<p>Extract weights used to pool estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Wald_lmm'
weights(object, method, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weights.Wald_lmm_+3A_object">object</code></td>
<td>
<p>a <code>Wald_lmm</code> object, output of <code>anova.lmm</code>, or <code>rbind.lmm</code>, or <code>mlmm</code>.</p>
</td></tr>
<tr><td><code id="weights.Wald_lmm_+3A_method">method</code></td>
<td>
<p>[character] method for combining the estimates, one of <code>"average"</code>, <code>"pool.se"</code>, <code>"pool.gls"</code>, <code>"pool.rubin"</code>.</p>
</td></tr>
<tr><td><code id="weights.Wald_lmm_+3A_...">...</code></td>
<td>
<p>Not used. For compatibility with the generic method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector whose elements sum to 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(10)
dL &lt;- sampleRem(250, n.times = 3, format = "long")

e.mlmm &lt;- mlmm(Y~X1+X2+X6, repetition = ~visit|id, data = dL,
               by = "X4", effects = "X1=0", structure = "CS")
weights(e.mlmm, method = "average")
weights(e.mlmm, method = "pool.fixse")
weights(e.mlmm, method = "pool.se")
weights(e.mlmm, method = "pool.gls")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
