<!DOCTYPE html><html><head><title>Help for package MSGARCH</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MSGARCH}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#MSGARCH-package'><p>The R package MSGARCH</p></a></li>
<li><a href='#CreateSpec'><p>Model specification.</p></a></li>
<li><a href='#dem2gbp'><p>DEM/GBP exchange rate log-returns</p></a></li>
<li><a href='#DIC'><p>Deviance Information Criterion (DIC).</p></a></li>
<li><a href='#ExtractStateFit'><p>Single-regime model extractor.</p></a></li>
<li><a href='#FitMCMC'><p>MCMC/Bayesian estimation.</p></a></li>
<li><a href='#FitML'><p>Maximum Likelihood estimation.</p></a></li>
<li><a href='#PIT'><p>Probability integral transform.</p></a></li>
<li><a href='#predict.MSGARCH_SPEC'><p>predict method.</p></a></li>
<li><a href='#PredPdf'><p>Predictive density.</p></a></li>
<li><a href='#Risk'><p>Value-at-Risk and Expected-shortfall.</p></a></li>
<li><a href='#simulate.MSGARCH_SPEC'><p>Simulation of MSGARCH processes.</p></a></li>
<li><a href='#SMI'><p>Swiss market index dataset</p></a></li>
<li><a href='#State'><p>State probabilities.</p></a></li>
<li><a href='#TransMat'><p>Transition matrix.</p></a></li>
<li><a href='#UncVol'><p>Unconditional volatility.</p></a></li>
<li><a href='#Volatility'><p>Volatility filtering.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Markov-Switching GARCH Models</td>
</tr>
<tr>
<td>Version:</td>
<td>2.51</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-12-05</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Keven Bluteau &lt;Keven.Bluteau@usherbrooke.ca&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit (by Maximum Likelihood or MCMC/Bayesian), simulate, and forecast various Markov-Switching GARCH models as described in Ardia et al. (2019) &lt;<a href="https://doi.org/10.18637%2Fjss.v091.i04">doi:10.18637/jss.v091.i04</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/keblu/MSGARCH/issues">https://github.com/keblu/MSGARCH/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/keblu/MSGARCH">https://github.com/keblu/MSGARCH</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, coda, methods, zoo, expm, fanplot, MASS, numDeriv</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>mcmc, testthat</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-05 16:08:40 UTC; Keven</td>
</tr>
<tr>
<td>Author:</td>
<td>David Ardia <a href="https://orcid.org/0000-0003-2823-782X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Keven Bluteau <a href="https://orcid.org/0000-0003-2990-4807"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Kris Boudt <a href="https://orcid.org/0000-0002-1000-5142"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Leopoldo Catania <a href="https://orcid.org/0000-0002-0981-1921"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Alexios Ghalanos [ctb],
  Brian Peterson [ctb],
  Denis-Alexandre Trottier [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-05 18:32:30 UTC</td>
</tr>
</table>
<hr>
<h2 id='MSGARCH-package'>The R package MSGARCH</h2><span id='topic+MSGARCH'></span><span id='topic+MSGARCH-package'></span>

<h3>Description</h3>

<p>The <span class="rlang"><b>R</b></span> package <span class="pkg">MSGARCH</span> implements a comprehensive
set of functionalities for Markov-switching GARCH (Haas et al. 2004a) and Mixture of GARCH (Haas et al. 2004b) models,
This includes fitting, filtering, forecasting, and simulating.
Other functions related to Value-at-Risk and Expected-Shortfall are also available.<br />
The main functions of the package are coded
in <code>C++</code> using <span class="pkg">Rcpp</span> (Eddelbuettel and Francois, 2011)
and <span class="pkg">RcppArmadillo</span> (Eddelbuettel and Sanderson, 2014).<br />
<span class="pkg">MSGARCH</span> focuses on the conditional variance (and higher moments) process.
Hence, there is no equation for the mean.
Therefore, you must pre-filter via AR(1) before applying the model.<br />
The <span class="pkg">MSGARCH</span> package implements a variety of GARCH specifications together with several conditional distributions.
This allows for a rich modeling
environment for Markov-switching GARCH models. Each single-regime process
is a one-lag process (e.g., GARCH(1,1)).
When optimization is performed, we ensure that the variance in each regime is covariance-stationary
and strictly positive (refer to the vignette for more information).<br />
We refer to Ardia et al. (2019a) for a detailed
introduction to the package and its usage. Refer to Ardia et al. (2018) and Ardia et al. (2019b) for
further applications. <br />
The authors acknowledge Google for financial support via the Google Summer of Code 2016 &amp; 2017,
the International Institute of Forecasters and Industrielle-Alliance.
</p>


<h3>Note</h3>

<p>By using <span class="pkg">MSGARCH</span> you agree to the following rules:
</p>

<ul>
<li><p> You must cite Ardia et al. (2019a) in working papers and published papers that use <span class="pkg">MSGARCH</span>.
Use <code>citation("MSGARCH")</code>.
</p>
</li>
<li><p> You must place the following URL in a footnote to help others find <span class="pkg">MSGARCH</span>: 
<a href="https://CRAN.R-project.org/package=MSGARCH">https://CRAN.R-project.org/package=MSGARCH</a>.
</p>
</li>
<li><p> You assume all risk for the use of <span class="pkg">MSGARCH</span>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Keven Bluteau <a href="mailto:Keven.Bluteau@usherbrooke.ca">Keven.Bluteau@usherbrooke.ca</a> (<a href="https://orcid.org/0000-0003-2990-4807">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> David Ardia <a href="mailto:david.ardia.ch@gmail.com">david.ardia.ch@gmail.com</a> (<a href="https://orcid.org/0000-0003-2823-782X">ORCID</a>)
</p>
</li>
<li><p> Leopoldo Catania <a href="mailto:leopoldo.catania@econ.au.dk">leopoldo.catania@econ.au.dk</a> (<a href="https://orcid.org/0000-0002-0981-1921">ORCID</a>)
</p>
</li>
<li><p> Denis-Alexandre Trottier <a href="mailto:denis-alexandre.trottier.1@ulaval.ca">denis-alexandre.trottier.1@ulaval.ca</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Kris Boudt <a href="mailto:kris.boudt@ugent.be">kris.boudt@ugent.be</a> (<a href="https://orcid.org/0000-0002-1000-5142">ORCID</a>) [contributor]
</p>
</li>
<li><p> Alexios Ghalanos <a href="mailto:alexios@4dscape.com">alexios@4dscape.com</a> [contributor]
</p>
</li>
<li><p> Brian Peterson <a href="mailto:brian@braverock.com">brian@braverock.com</a> [contributor]
</p>
</li></ul>



<h3>References</h3>

<p>Ardia, D. Bluteau, K. Boudt, K. Catania, L. (2018).
Forecasting risk with Markov-switching GARCH models: A large-scale performance study.
<em>International Journal of Forecasting</em>, 34(4), 733-747.
doi: <a href="https://doi.org/10.1016/j.ijforecast.2018.05.004">10.1016/j.ijforecast.2018.05.004</a>
</p>
<p>Ardia, D. Bluteau, K. Boudt, K. Catania, L. Trottier, D.-A. (2019a).
Markov-switching GARCH models in <span class="rlang"><b>R</b></span>: The <span class="pkg">MSGARCH</span> package.
<em>Journal of Statistical Software</em>, 91(4), 1-38.
doi: <a href="https://doi.org/10.18637/jss.v091.i04">10.18637/jss.v091.i04</a>
</p>
<p>Ardia, D. Bluteau, K. Ruede, M. (2019b).
Regime changes in Bitcoin GARCH volatility dynamics.
<em>Finance Research Letters</em>, 29, 266-271.
doi: <a href="https://doi.org/10.1016/j.frl.2018.08.009">10.1016/j.frl.2018.08.009</a>
</p>
<p>Eddelbuettel, D. &amp; Francois, R. (2011).
<span class="pkg">Rcpp</span>: Seamless <span class="rlang"><b>R</b></span> and <code>C++</code> integration.
<em>Journal of Statistical Software</em>, 40, 1-18.
doi: <a href="https://doi.org/10.18637/jss.v040.i08">10.18637/jss.v040.i08</a>
</p>
<p>Eddelbuettel, D. &amp; Sanderson, C. (2014).
<span class="pkg">RcppArmadillo</span>: Accelerating <span class="rlang"><b>R</b></span> with high-performance <code>C++</code> linear algebra.
<em>Computational Statistics &amp; Data Analysis</em>, 71, 1054-1063.
doi: <a href="https://doi.org/10.1016/j.csda.2013.02.005">10.1016/j.csda.2013.02.005</a>
</p>
<p>Haas, M. Mittnik, S. &amp; Paolella, MS. (2004).
A new approach to Markov-switching GARCH models.
<em>Journal of Financial Econometrics</em>, 2, 493-530.
doi: <a href="https://doi.org/10.1093/jjfinec/nbh020">10.1093/jjfinec/nbh020</a>
</p>
<p>Haas, M. Mittnik, S. &amp; Paolella, M. S. (2004b).
Mixed normal conditional heteroskedasticity.
<em>Journal of Financial Econometrics</em>, 2, 211-250.
doi: <a href="https://doi.org/10.1093/jjfinec/nbh009">10.1093/jjfinec/nbh009</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/keblu/MSGARCH">https://github.com/keblu/MSGARCH</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/keblu/MSGARCH/issues">https://github.com/keblu/MSGARCH/issues</a>
</p>
</li></ul>


<hr>
<h2 id='CreateSpec'>Model specification.</h2><span id='topic+CreateSpec'></span>

<h3>Description</h3>

<p>Creates a model specification before fitting and
using the <span class="pkg">MSGARCH</span> functionalities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateSpec(
  variance.spec = list(model = c("sGARCH", "sGARCH")),
  distribution.spec = list(distribution = c("norm", "norm")),
  switch.spec = list(do.mix = FALSE, K = NULL),
  constraint.spec = list(fixed = list(), regime.const = NULL),
  prior = list(mean = list(), sd = list())
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CreateSpec_+3A_variance.spec">variance.spec</code></td>
<td>
<p><code>list</code> with element <code>model</code>.
<code>model</code> is a <code>character</code> vector (of size K, number of regimes)
with the variance model specifications. Valid models  are  <code>"sARCH"</code>, <code>"sGARCH"</code>,
<code>"eGARCH"</code>, <code>"gjrGARCH"</code>, and <code>"tGARCH"</code> (see *Details*).
Default: <code>model = c("sGARCH", "sGARCH")</code>.</p>
</td></tr>
<tr><td><code id="CreateSpec_+3A_distribution.spec">distribution.spec</code></td>
<td>
<p><code>list</code> with element <code>distribution</code>.
<code>distribution</code> is a <code>character</code> vector (of size K)
of conditional distributions. Valid distributions are <code>"norm"</code>, <code>"snorm"</code>,
<code>"std"</code>, <code>"sstd"</code>, <code>"ged"</code>, and <code>"sged"</code>  (see *Details*).
The vector must be of the same length as the models' vector in <code>variance.spec</code>.<br />
Default: <code>distribution = c("norm", "norm")</code>.</p>
</td></tr>
<tr><td><code id="CreateSpec_+3A_switch.spec">switch.spec</code></td>
<td>
<p><code>list</code> with element <code>do.mix</code> and <code>K</code>.<br />
<code>do.mix</code> is a <code>logical</code> indicating if the specification is a mixture type.
If <code>do.mix = TRUE</code>, a Mixture of GARCH is created, while if <code>do.mix = FALSE</code>,
a Markov-Switching GARCH is created (see *Details*). Default: <code>do.mix = FALSE</code>.<br />
<code>K</code> is a optional <code>numeric</code> scalar indicating the number of regime.
In the case where a single regime is specified in <code>variance.spec</code> and <code>distribution.spec</code>,
this parameter allows to automatically expand this single regime to <code>K</code> similar
regimes without the need to explicitly define them in <code>variance.spec</code>
and <code>distribution.spec</code> (see *Examples*).</p>
</td></tr>
<tr><td><code id="CreateSpec_+3A_constraint.spec">constraint.spec</code></td>
<td>
<p><code>list</code> with element <code>fixed</code> and <code>regime.const</code>.
Only one of <code>fixed</code> and <code>regime.const</code>
can be set by the user as it is not allowed to set both at the same time. <br />
<code>fixed</code> is a  <code>list</code> with <code>numeric</code> entries and named elements.
This argument controls for fixed parameters defined by the user.  The names of the entries
in the <code>list</code>  have to coincide with the names of the model parameters.<br />
For instance, if <code>contraint.spec  = list(fixed = list(beta_1 = 0))</code>, <code>beta_1</code>
will be fixed to <code>0</code> during optimization. <br />
<code>regime.const</code> is a <code>character</code> vector.
This argument controls for the parameters which are set equal across regimes.
The names of the entries in the <code>list</code>  have to coincide with the names of the model parameters
minus the regime indicator.<br />
For instance, if <code>contraint.spec  = list(regime.const = c("beta"))</code>,
all the parameters named <code>beta</code> will be the same in all regimes during optimization.<br /></p>
</td></tr>
<tr><td><code id="CreateSpec_+3A_prior">prior</code></td>
<td>
<p><code>list</code> with element <code>mean</code> and <code>sd</code>. The element <code>mean</code> and <code>sd</code>
are <code>list</code>  with <code>numeric</code> and named elements that allow to adjust the prior mean and
standard deviation of the truncated Normal prior.
The names of the entries in the lists have to coincide with the names of the model parameters.<br />
For instance, if <code>prior = list(mean = list(beta_1 = 0.7), sd = list(beta_1 = 0.1))</code>,
the prior mean of <code>beta_1</code> will be set to <code>0.7</code> while the prior standard
deviation will set to <code>0.1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Markov-Switching specification is based on the
Haas et al. (2004a) MSGARCH specification. It is a MSGARCH model that is separated
in K single-regime specifications  which are updated in parallel. Under the Haas et al. (2004a)
specification, the conditional variance is a function of past data and the current state.
The Mixture of GARCH option (<code>do.mix = TRUE</code>) is based on Haas et al. (2004b). A Mixture of GARCH is a mixture of distributions
where the variance process of each distribution is a single-regime process.<br />
For the models, <code>"sARCH"</code> is the ARCH(1) model (Engle, 1982), <code>"sGARCH"</code> the GARCH(1,1) model
(Bollerslev, 1986), <code>"eGARCH"</code> the EGARCH(1,1) model (Nelson, 1991), <code>"gjrGARCH"</code>
the GJR(1,1) model (Glosten et al., 1993), and <code>"tGARCH"</code> the TGARCH(1,1) model (Zakoian, 1994).<br />
For the distributions, <code>"norm"</code> is the Normal distribution, <code>"std"</code> the
Student-t distribution, and <code>"ged"</code> the GED distribution.
Their skewed version, implemented via the Fernandez and &amp; Steel (1998) transformation,
are <code>"snorm"</code>, <code>"sstd"</code> and <code>"sged"</code>.
Please see Ardia et al. (2019) for more details on the models and distributions.<br />
The user must choose between <code>fixed</code> or <code>regime.const</code> in <code>contraint.spec</code>
as both cannot be set at the same time. The <code>list</code> <code>fixed.pars</code>
will ensure that the chosen fixed parameters will be fixed during optimization according to
the values set by the user.
Thus only the non-fixed parameters are optimized. The vector <code>regime.const</code> will
ensure that the chosen parameters will be the same across regime during optimization.<br />
The <code>list</code> <code>mean</code> and <code>sd</code> in <code>prior</code> will adjust the prior mean and
prior standard deviation of the truncated Normal prior for MCMC
estimation via <code><a href="#topic+FitMCMC">FitMCMC</a></code> according to the inputed prior mean and standard deviation.
Those prior means and standard deviations that are not set will take on preset default values (a mean 
of zero and a variance of 1,000).
</p>


<h3>Value</h3>

<p>A list of class <code>MSGARCH_SPEC</code> with the following elements:<br />
</p>

<ul>
<li> <p><code>par0</code>: Vector (of size d) of default parameters.
</p>
</li>
<li> <p><code>is.mix</code>: Logical indicating if the specification is a mixture.
</p>
</li>
<li> <p><code>K</code>: Number of regimes.
</p>
</li>
<li> <p><code>lower</code>: Vector (of size d) of lower parameters' bounds.
</p>
</li>
<li> <p><code>upper</code>: Vector (of size d) of upper parameters' bounds.
</p>
</li>
<li> <p><code>n.params</code>:  Vector (of size K) of the total number of parameters by
regime including distributions' parameters.
</p>
</li>
<li> <p><code>n.params.vol</code>:  Vector (of size K) of the total number of parameters
by regime excluding distributions' parameters.
</p>
</li>
<li> <p><code>label</code>: Vector (of size d) of parameters' labels.
</p>
</li>
<li> <p><code>name</code>: Vector (of size K) of model specifications' names.
</p>
</li>
<li> <p><code>func</code>: List of internally used <span class="rlang"><b>R</b></span> functions.
</p>
</li>
<li> <p><code>rcpp.func</code>: List of internally used <code>Rcpp</code> functions.
</p>
</li>
<li> <p><code>fixed.pars</code>: List of user inputed fixed parameters.
</p>
</li>
<li> <p><code>regime.const.pars</code>: Vector of user imputed parameter set equal across regimes.
</p>
</li>
<li> <p><code>regime.fixed.pars</code>: Logical indicating if there is any fixed parameteter set by the user.
</p>
</li>
<li> <p><code>regime.const.pars.bool</code>: Logical indicating if there is any parameteters
equal across regime set by the user.
</p>
</li></ul>

<p>The <code>MSGARCH_SPEC</code> class has the following methods:
</p>

<ul>
<li> <p><code>simulate</code>: Simulation.
</p>
</li>
<li> <p><code><a href="#topic+Volatility">Volatility</a></code>: In-sample conditional volatility.
</p>
</li>
<li> <p><code>predict</code>: Forecast of the conditional volatility (and predictive distribution).
</p>
</li>
<li> <p><code><a href="#topic+UncVol">UncVol</a></code>: Unconditional volatility.
</p>
</li>
<li> <p><code><a href="#topic+PredPdf">PredPdf</a></code>: Predictive density (pdf).
</p>
</li>
<li> <p><code><a href="#topic+PIT">PIT</a></code>: Probability Integral Transform.
</p>
</li>
<li> <p><code><a href="#topic+Risk">Risk</a></code>: Value-at-Risk and Expected-Shortfall.
</p>
</li>
<li> <p><code><a href="#topic+State">State</a></code>: State probabilities (smoothed, filtered, predictive, Viterbi).
</p>
</li>
<li> <p><code><a href="#topic+FitML">FitML</a></code>: Maximum Likelihood estimation.
</p>
</li>
<li> <p><code><a href="#topic+FitMCMC">FitMCMC</a></code>: Bayesian estimation.
</p>
</li>
<li> <p><code>print</code> and <code>summary</code>: Summary of the created specification.
</p>
</li></ul>



<h3>References</h3>

<p>Ardia, D. Bluteau, K. Boudt, K. Catania, L. Trottier, D.-A. (2019).
Markov-switching GARCH models in <span class="rlang"><b>R</b></span>: The <span class="pkg">MSGARCH</span> package.
<em>Journal of Statistical Software</em>, 91(4), 1-38.
doi: <a href="https://doi.org/10.18637/jss.v091.i04">10.18637/jss.v091.i04</a>
</p>
<p>Engle, R. (1982).
Autoregressive conditional heteroscedasticity with estimates of the variance of United Kingdom inflation
<em>Econometrica</em>, 50, 987-1008.
</p>
<p>Bollerslev, T. (1986).
Generalized autoregressive conditional heteroskedasticity.
<em>Journal of Econometrics</em>, 31, 307-327.
doi: <a href="https://doi.org/10.1016/0304-4076(86)90063-1">10.1016/0304-4076(86)90063-1</a>
</p>
<p>Fernandez, C. &amp; Steel, M. F. (1998).
On Bayesian modeling of fat tails and skewness.
<em>Journal of the American Statistical Association</em>, 93, 359-371.
doi: <a href="https://doi.org/10.1080/01621459.1998.10474117">10.1080/01621459.1998.10474117</a>
</p>
<p>Glosten, L. R. Jagannathan, R. &amp; Runkle, D. E. (1993).
On the relation between the expected value and the volatility of the nominal excess return on stocks.
<em>Journal of Finance</em>, 48, 1779-1801.
doi: <a href="https://doi.org/10.1111/j.1540-6261.1993.tb05128.x">10.1111/j.1540-6261.1993.tb05128.x</a>
</p>
<p>Haas, M. Mittnik, S. &amp; Paolella, M. S. (2004a).
A new approach to Markov-switching GARCH models.
<em>Journal of Financial Econometrics</em>, 2, 493-530.
doi: <a href="https://doi.org/10.1093/jjfinec/nbh020">10.1093/jjfinec/nbh020</a>
</p>
<p>Haas, M. Mittnik, S. &amp; Paolella, M. S. (2004b).
Mixed normal conditional heteroskedasticity.
<em>Journal of Financial Econometrics</em>, 2, 211-250.
doi: <a href="https://doi.org/10.1093/jjfinec/nbh009">10.1093/jjfinec/nbh009</a>
</p>
<p>Nelson, D. B. (1991).
Conditional heteroskedasticity in asset returns: A new approach.
<em>Econometrica</em>, 59, 347-370.
</p>
<p>Zakoian, J.-M. (1994).
Threshold heteroskedastic models.
<em>Journal of Economic Dynamics and Control</em>, 18, 931-955.
doi: <a href="https://doi.org/10.1016/0165-1889(94)90039-6">10.1016/0165-1889(94)90039-6</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a Markov-switching specification
# MS-GARCH(1,1)-GJR(1,1)-Student
spec &lt;- CreateSpec(variance.spec = list(model = c("sGARCH","gjrGARCH")),
                   distribution.spec = list(distribution = c("std","std")),
                   switch.spec = list(do.mix = FALSE))
print(spec)

# create a 3-regime Markov-switching specification with the help of variable K
# MS(3)-GARCH(1,1)- Student
spec &lt;- CreateSpec(variance.spec = list(model = c("sGARCH")),
                   distribution.spec = list(distribution = c("std")),
                   switch.spec = list(do.mix = FALSE, K = 3))
print(spec)

# create a mixture specification
# MIX-GARCH(1,1)-GJR(1,1)-Student
spec &lt;- CreateSpec(variance.spec = list(model = c("sGARCH","gjrGARCH")),
                   distribution.spec = list(distribution = c("std","std")),
                   switch.spec = list(do.mix = TRUE))
print(spec)

# setting fixed parameter for the sGARCH beta parameter
# MS-GARCH(1,1)-GJR(1,1)-Student with beta_1 fixed to 0
spec &lt;- CreateSpec(variance.spec = list(model = c("sGARCH","gjrGARCH")),
                   distribution.spec = list(distribution = c("std","std")),
                   switch.spec = list(do.mix = FALSE),
                   constraint.spec = list(fixed = list(beta_1 = 0)))
print(spec)

# setting restriction for the shape parameter of the Student-t across regimes
# MS-GARCH(1,1)-GJR(1,1)-Student with shape parameter constraint across regime
spec &lt;- CreateSpec(variance.spec = list(model = c("sGARCH","gjrGARCH")),
                   distribution.spec = list(distribution = c("std","std")),
                   switch.spec = list(do.mix = FALSE),
                   constraint.spec = list(regime.const = c("nu")))
print(spec)

# setting custom parameter priors for the beta parameters
# MS-GARCH(1,1)-GJR(1,1)-Student with prior modification
spec &lt;- CreateSpec(variance.spec = list(model = c("sGARCH","gjrGARCH")),
                   distribution.spec = list(distribution = c("std","std")),
                   switch.spec = list(do.mix = FALSE),
                   prior = list(mean = list(beta_1 = 0.9, beta_2 = 0.3),
                                sd = list(beta_1 = 0.05, beta_2 = 0.01)))
print(spec)
</code></pre>

<hr>
<h2 id='dem2gbp'>DEM/GBP exchange rate log-returns</h2><span id='topic+dem2gbp'></span>

<h3>Description</h3>

<p>The <code>vector</code> <code>dem2gbp</code> contains daily observations of the Deutschmark vs British Pound foreign exchange
rate log-returns. This dataset has been promoted as an informal benchmark for GARCH
time-series software validation. See McCullough and Renfro (1999), and Brooks, Burke, and Persand
(2001) for details. The nominal returns are expressed in percent as in Bollerslev and Ghysels
(1996). The sample period is from January 3, 1984, to December 31, 1991, for a total of 1974
observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("dem2gbp")
</code></pre>


<h3>Format</h3>

<p><code>vector</code> of size 1,974.
</p>


<h3>References</h3>

<p>Bollerslev T., Ghysels, E. (1996)
Periodic autoregressive conditional heteroscedasticity.
<em>Journal of Business and Economic Statistics</em>, 14, 139-151.
</p>
<p>Brooks C., Burke S. P., Persand G. (2001)
<em>International Journal of Forecasting</em>, 17, 45-57.
doi: <a href="https://doi.org/10.1016/S0169-2070(00)00070-4">10.1016/S0169-2070(00)00070-4</a>
</p>
<p>McCullough B. D., Renfro C. G. (1999)
Benchmarks and software standards: A case study of GARCH procedures. 
<em>Journal of Economic and Social Measurement</em>, 25, 59-71.
doi: <a href="https://doi.org/10.3233/JEM-1999-0160">10.3233/JEM-1999-0160</a>
</p>

<hr>
<h2 id='DIC'>Deviance Information Criterion (DIC).</h2><span id='topic+DIC'></span><span id='topic+DIC.MSGARCH_MCMC_FIT'></span>

<h3>Description</h3>

<p>Method which computes the Deviance Information Criterion (DIC) from a fit object of type
<code>MSGARCH_MCMC_FIT</code> created with <code><a href="#topic+FitMCMC">FitMCMC</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DIC(fit)

## S3 method for class 'MSGARCH_MCMC_FIT'
DIC(fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DIC_+3A_fit">fit</code></td>
<td>
<p>Fit object of type <code>MSGARCH_MCMC_FIT</code> created
with <code><a href="#topic+FitMCMC">FitMCMC</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the Deviance information criterion of Spiegelhalter et al. (2002).
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><code>DIC</code>: Deviance Information Criterion.
</p>
</li>
<li> <p><code>IC</code>: Bayesian Predictive Information Criterion (IC = 2 * pV + D.bar).
</p>
</li>
<li> <p><code>pV</code>: Effective number of parameters (pV = var(D)/2).
</p>
</li>
<li> <p><code>D.bar</code>: Expected value of the deviance over the posterior.
</p>
</li></ul>



<h3>References</h3>

<p>Spiegelhalter, David J., et al. (2002).
Bayesian measures of model complexity and fit.
<em>Journal of the Royal Statistical Society: Series B</em>, 64, 583-639
doi: <a href="https://doi.org/10.1111/1467-9868.00353">10.1111/1467-9868.00353</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create model specification
spec &lt;- CreateSpec()

# load data
data("SMI", package = "MSGARCH")

# fit the model on data by MCMC
set.seed(123)
fit &lt;- FitMCMC(spec = spec, data = SMI, ctr = list(nburn = 500L, nmcmc = 500L))

# compute DIC
DIC(fit)
</code></pre>

<hr>
<h2 id='ExtractStateFit'>Single-regime model extractor.</h2><span id='topic+ExtractStateFit'></span><span id='topic+ExtractStateFit.MSGARCH_ML_FIT'></span><span id='topic+ExtractStateFit.MSGARCH_MCMC_FIT'></span>

<h3>Description</h3>

<p>Extracts each regime from a fitted multiple regime specificaton
and creates a fitted object for each extracted regime.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExtractStateFit(object)

## S3 method for class 'MSGARCH_ML_FIT'
ExtractStateFit(object)

## S3 method for class 'MSGARCH_MCMC_FIT'
ExtractStateFit(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExtractStateFit_+3A_object">object</code></td>
<td>
<p>Fit object of type <code>MSGARCH_ML_FIT</code>
created with <code><a href="#topic+FitML">FitML</a></code> or <code>MSGARCH_MCMC_FIT</code>
created with <code><a href="#topic+FitMCMC">FitMCMC</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>K</code> elements where each element is a fit object of type <code>MSGARCH_ML_FIT</code> or
<code>MSGARCH_MCMC_FIT</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create model specification
spec &lt;- CreateSpec()

# load data
data("SMI", package = "MSGARCH")

# fit the model on the data with ML estimation
fit &lt;- FitML(spec = spec, data = SMI)
SR.fit &lt;- ExtractStateFit(fit)
print(SR.fit)
</code></pre>

<hr>
<h2 id='FitMCMC'>MCMC/Bayesian estimation.</h2><span id='topic+FitMCMC'></span>

<h3>Description</h3>

<p>Method that performs MCMC/Bayesian estimation of
a <code>MSGARCH_SPEC</code> object on a set of observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FitMCMC(spec, data, ctr = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FitMCMC_+3A_spec">spec</code></td>
<td>
<p>Model specification of class <code>MSGARCH_SPEC</code>
created with <code><a href="#topic+CreateSpec">CreateSpec</a></code>.</p>
</td></tr>
<tr><td><code id="FitMCMC_+3A_data">data</code></td>
<td>
<p>Vector (of size T) of observations.</p>
</td></tr>
<tr><td><code id="FitMCMC_+3A_ctr">ctr</code></td>
<td>
<p>A list of control parameters:
</p>

<ul>
<li> <p><code>par0</code>: Vector (of size d) where d must have
the same length as the default parameters of the specification.
It is the starting value for the chain (if empty the
the method automatically set starting parameters; see *Details*).
</p>
</li>
<li> <p><code>nburn</code> (integer &gt;= 0): Number of discarded draws.
(Default: <code>nburn = 5000L</code>)
</p>
</li>
<li> <p><code>nmcmc</code> (integer &gt; 0): Number of draws.
(Default: <code>nmcmc = 10000L</code>)
</p>
</li>
<li> <p><code>nthin</code> (integer &gt; 0): Thinning factor (every <code>nthin</code>
draws are kept). (Default: <code>nthin = 10L</code>)
</p>
</li>
<li> <p><code>do.sort</code> (bool): Logical indicating if the MCMC draws are post-sorted
following Geweke (2007). By default, <code>do.sort = TRUE</code>, such that the
MCMC draws are ordered to ensure that unconditional variance is an 
increasing function of the regime (identification constraint). If the user sets
<code>do.sort = FALSE</code>, no sorting is imposed, and label switching can occur (see *Details*).
</p>
</li>
<li> <p><code>SamplerFUN</code>: Custom MCMC sampler (see *Details*).
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The total number of draws is equal to <code>nmcmc / nthin</code>.
The MCMC/Bayesian estimation relies on an <span class="pkg">Rcpp</span> implementation of the adaptive sampler of Vihola (2012). 
The implementation is based on the R package <span class="pkg">adaptMCMC</span> (Andreas, 2012).
Starting values when <code>par0</code> is not provided are chosen automatically
before sampling (see Ardia et al. (2019) for more details).<br />
<code>SamplerFUN</code> allows for a custom sampler to be used. The function
must take the form: <br /> <code>function(f_posterior, data, spec, par0, ctr)</code>, <br />
where  <code>f_posterior</code> is the function to optimize, <code>data</code> is
the data, <code>spec</code> is the specification,
<code>par0</code> are the starting parameters, and <code>ctr</code> are the control
parameters. The inputs <code>spec</code> and <code>data</code>,
must be passed as inputs in the sampler (see *Examples*).
The custom sampler must output a matrix containing the MCMC chain. <br />
When <code>do.sort = TRUE</code>, sorting of each MCMC draw conditional on the unconditional variance is done across homogeneous regime specification.<br />
</p>


<h3>Value</h3>

<p>A list of class <code>MSGARCH_MCMC_FIT</code> with the following elements:
</p>

<ul>
<li> <p><code>par</code>: The MCMC chain (matrix from the <span class="rlang"><b>R</b></span> package
<code>coda</code> (Plummer et al., 2006) of size <code>nmcmc</code> / <code>nthin</code> x d).
</p>
</li>
<li> <p><code>accept</code>: Acceptance rate of the sampler.
</p>
</li>
<li> <p><code>spec</code>:  Model specification of class <code>MSGARCH_SPEC</code>
created with <code><a href="#topic+CreateSpec">CreateSpec</a></code>.
</p>
</li>
<li> <p><code>data</code>:  Vector (of size T) of observations.
</p>
</li>
<li> <p><code>ctr</code>: <code>list</code> of the control used for the fit.
</p>
</li></ul>

<p>The <code>MSGARCH_MCMC_FIT</code> with the following methods:
</p>

<ul>
<li> <p><code><a href="#topic+DIC">DIC</a></code>: Deviance Information Criterion (DIC).
</p>
</li>
<li> <p><code>simulate</code>: Simulation.
</p>
</li>
<li> <p><code><a href="#topic+Volatility">Volatility</a></code>: In-sample conditional volatility.
</p>
</li>
<li> <p><code>predict</code>: Forecast of the conditional volatility (and predictive distribution).
</p>
</li>
<li> <p><code><a href="#topic+UncVol">UncVol</a></code>: Unconditional volatility.
</p>
</li>
<li> <p><code><a href="#topic+PredPdf">PredPdf</a></code>: Predictive density (pdf).
</p>
</li>
<li> <p><code><a href="#topic+PIT">PIT</a></code>: Probability Integral Transform.
</p>
</li>
<li> <p><code><a href="#topic+Risk">Risk</a></code>: Value-at-Risk and Expected-Shortfall.
</p>
</li>
<li> <p><code><a href="#topic+State">State</a></code>: State probabilities (smoothed, filtered, predictive, Viterbi).
</p>
</li>
<li> <p><code><a href="#topic+ExtractStateFit">ExtractStateFit</a></code>: Single-regime model extractor.
</p>
</li>
<li> <p><code>summary</code>: Summary of the fit.
</p>
</li></ul>



<h3>References</h3>

<p>Andreas, S. (2012).
<code>adaptMCMC</code>: Implementation of a generic adaptive Monte Carlo Markov chain sampler.
<a href="https://cran.r-project.org/package=adaptMCMC">https://cran.r-project.org/package=adaptMCMC</a>
</p>
<p>Ardia, D. Bluteau, K. Boudt, K. Catania, L. Trottier, D.-A. (2019).
Markov-switching GARCH models in <span class="rlang"><b>R</b></span>: The <span class="pkg">MSGARCH</span> package.
<em>Journal of Statistical Software</em>, 91(4), 1-38.
doi: <a href="https://doi.org/10.18637/jss.v091.i04">10.18637/jss.v091.i04</a>
</p>
<p>Geweke J (2007).
Interpretation and Inference in Mixture Models: Simple MCMC Works.
<em>Computational Statistics &amp; Data Analysis</em>, 51(7), 3529-3550.
doi: <a href="https://doi.org/10.1016/j.csda.2006.11.026">10.1016/j.csda.2006.11.026</a>
</p>
<p>MacDonald, I.L., Zucchini, W. (1997).
<em>Hidden Markov and other models for discrete-valued time series</em>.
CRC press.
</p>
<p>Plummer, M. Best, N. Cowles, K. &amp; Vines, K. (2006).
<code>coda</code>: Convergence diagnosis and output analysis for MCMC.
<em>R News</em>, 6, 7-11.
<a href="https://cran.r-project.org/package=coda">https://cran.r-project.org/package=coda</a>
</p>
<p>Vihola, M. (2012).
Robust adaptive Metropolis algorithm with coerced acceptance rate.
<em>Statistics and Computing</em>, 22, 997-1008.
doi: <a href="https://doi.org/10.1007/s11222-011-9269-5">10.1007/s11222-011-9269-5</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create model specification
spec &lt;- CreateSpec()

# load data
data("SMI", package = "MSGARCH")

# fit the model on the data by MCMC
set.seed(123)
fit &lt;- FitMCMC(spec = spec, data = SMI, ctr = list(nburn = 500L, nmcmc = 500L, nthin = 1L))
summary(fit)

# custom sampler example
## Not run: 
library("mcmc")
f_MCMC &lt;- function(f_posterior, data, spec, par0, ctr){
  par &lt;- mcmc::metrop(f_posterior, initial = par0, nbatch = ctr$nmcmc + ctr$nburn,
                        data = data, spec = spec)$batch
  colnames(par) = names(par0)
  return(par)
}

set.seed(123)
fit &lt;- FitMCMC(spec, data = SMI, ctr  = list(SamplerFUN = f_MCMC,
                                             nburn = 500L, nmcmc = 500L, nthin = 1L))
summary(fit)

## End(Not run)
</code></pre>

<hr>
<h2 id='FitML'>Maximum Likelihood estimation.</h2><span id='topic+FitML'></span>

<h3>Description</h3>

<p>Method that performs Maximum Likelihood estimation
of a <code>MSGARCH_SPEC</code> object on a set of observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FitML(spec, data, ctr = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FitML_+3A_spec">spec</code></td>
<td>
<p>Model specification created with <code><a href="#topic+CreateSpec">CreateSpec</a></code>.</p>
</td></tr>
<tr><td><code id="FitML_+3A_data">data</code></td>
<td>
<p>Vector (of size T) of observations.</p>
</td></tr>
<tr><td><code id="FitML_+3A_ctr">ctr</code></td>
<td>
<p>A list of control parameters:
</p>

<ul>
<li> <p><code>par0</code>: Vector (of size d) where d must have
the same length as the default parameters of the specification.
It is the starting value for the optimizer (if empty the
the method automatically set starting parameters; see *Details*).
</p>
</li>
<li> <p><code>do.se</code> Logical. Should standard errors be computed?
(Default: <code>do.se = TRUE</code>).
</p>
</li>
<li> <p><code>do.plm</code> Logical. If <code>do.plm = FALSE</code>, parameter transformation
during the optimization step is performed without ensuring stationarity
for the volatility processes. For combinations of parameters that do not
imply stationarity the likelihood value is fixed at -1e10. If
<code>fixed</code> is defined in the  <code>list</code> <code>contraint.spec</code>
of <a href="#topic+CreateSpec">CreateSpec</a>, <code>do.plm = TRUE</code>
is used. (Default: <code>do.plm = FALSE</code>)
</p>
</li>
<li> <p><code>OptimFUN</code>: Custom optimization function (see *Details*).
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, <code>OptimFUN</code> is set such that optimization is done via the well-known Broyden-
Fletcher-Goldfarb-Shanno (BFGS) algorithm using the <code>optim</code> function with <code>method =
"BFGS"</code>.
Starting values when <code>par0</code> is not provided are chosen automatically
before optimization (see Ardia et al. (2019) for more details)<br />
<code>OptimFUN</code> allows for a custom optimizer to be used. The function must take
the form: <br /> <code>function(vPw, f_nll, spec, data, do.plm)</code>, <br />
where <code>vPw</code> are starting parameters (transformed), <code>f_nll</code> is the function
to be minimize, <code>spec</code> is the specification, <code>data</code> is the data,
and <code>do.plm</code> the originally inputed or default <code>do.plm</code>.
The inputs <code>spec</code>, <code>data</code>, and <code>do.plm</code>
must be passed as inputs in the optimizer (see *Examples*).
It must output a list with the following elements:
</p>

<ul>
<li> <p><code>value</code>: Optimal negative log-likelihood.
</p>
</li>
<li> <p><code>par</code>: Optimal parameters.
</p>
</li></ul>



<h3>Value</h3>

<p>A list of class <code>MSGARCH_ML_FIT</code> with the following elements:
</p>

<ul>
<li> <p><code>par</code>: Vector (of size d) of optimal parameters.
</p>
</li>
<li> <p><code>loglik</code>: Log-likelihood of <code>y</code> given the optimal parameters.
</p>
</li>
<li> <p><code>Inference</code>: <code>list</code> with elements <code>MatCoef</code> and <code>Hessian</code>.
<code>MatCoef</code> is a matrix (of size d x 4) with optimal parameter estimates, standard errors, t-stats, and p-values.
<code>Hessian</code> is the Hessian (matrix of size d x d) of the negative log-likelihood function
evaluated at the optimal parameter estimates <code>par</code>.
</p>
</li>
<li> <p><code>spec</code>: Model specification of class <code>MSGARCH_SPEC</code>
created with <code><a href="#topic+CreateSpec">CreateSpec</a></code>.
</p>
</li>
<li> <p><code>data</code>: Vector (of size T) of observations.
</p>
</li>
<li> <p><code>ctr</code>: <code>list</code> of the control used for the fit.
</p>
</li></ul>

<p>The <code>MSGARCH_ML_FIT</code> with the following methods:
</p>

<ul>
<li> <p><code>AIC</code>: Akaike Information Criterion (AIC).
</p>
</li>
<li> <p><code>BIC</code>: Bayesian Information Criterion (BIC).
</p>
</li>
<li> <p><code>simulate</code>: Simulation.
</p>
</li>
<li> <p><code><a href="#topic+Volatility">Volatility</a></code>: In-sample conditional volatility.
</p>
</li>
<li> <p><code>predict</code>: Forecast of the conditional volatility (and predictive distribution).
</p>
</li>
<li> <p><code><a href="#topic+UncVol">UncVol</a></code>: Unconditional volatility.
</p>
</li>
<li> <p><code><a href="#topic+PredPdf">PredPdf</a></code>: Predictive density (pdf).
</p>
</li>
<li> <p><code><a href="#topic+PIT">PIT</a></code>: Probability Integral Transform.
</p>
</li>
<li> <p><code><a href="#topic+Risk">Risk</a></code>: Value-at-Risk and Expected-Shortfall.
</p>
</li>
<li> <p><code><a href="#topic+State">State</a></code>: State probabilities (smoothed, filtered, predictive, Viterbi).
</p>
</li>
<li> <p><code><a href="#topic+ExtractStateFit">ExtractStateFit</a></code>: Single-regime model extractor.
</p>
</li>
<li> <p><code>summary</code>: Summary of the fit.
</p>
</li></ul>



<h3>References</h3>

<p>Ardia, D. Bluteau, K. Boudt, K. Catania, L. Trottier, D.-A. (2019).
Markov-switching GARCH models in <span class="rlang"><b>R</b></span>: The <span class="pkg">MSGARCH</span> package.
<em>Journal of Statistical Software</em>, 91(4), 1-38.
doi: <a href="https://doi.org/10.18637/jss.v091.i04">10.18637/jss.v091.i04</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create model specification
spec &lt;- CreateSpec()

# load data
data("SMI", package = "MSGARCH")

# fit the model on the data by ML
fit &lt;- FitML(spec = spec, data = SMI)
summary(fit)

# custom optimizer example
## Not run: 
f_custom_optim &lt;- function(vPw, f_nll, spec, data, do.plm){
 out &lt;- stats::optim(vPw, f_nll, spec = spec, data = data,
                     do.plm = do.plm, method = "Nelder-Mead")
 return(out)
}

set.seed(123)
fit &lt;- FitML(spec, data = SMI, ctr = list(OptimFUN = f_custom_optim))
summary(fit)

## End(Not run)
</code></pre>

<hr>
<h2 id='PIT'>Probability integral transform.</h2><span id='topic+PIT'></span><span id='topic+PIT.MSGARCH_SPEC'></span><span id='topic+PIT.MSGARCH_ML_FIT'></span><span id='topic+PIT.MSGARCH_MCMC_FIT'></span>

<h3>Description</h3>

<p>Method returning the probability integral
transform (PIT).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PIT(object, ...)

## S3 method for class 'MSGARCH_SPEC'
PIT(
  object,
  x = NULL,
  par = NULL,
  data = NULL,
  do.norm = FALSE,
  do.its = FALSE,
  nahead = 1L,
  do.cumulative = FALSE,
  ctr = list(),
  ...
)

## S3 method for class 'MSGARCH_ML_FIT'
PIT(
  object,
  x = NULL,
  newdata = NULL,
  do.norm = TRUE,
  do.its = FALSE,
  nahead = 1L,
  do.cumulative = FALSE,
  ctr = list(),
  ...
)

## S3 method for class 'MSGARCH_MCMC_FIT'
PIT(
  object,
  x = NULL,
  newdata = NULL,
  do.norm = TRUE,
  do.its = FALSE,
  nahead = 1L,
  do.cumulative = FALSE,
  ctr = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PIT_+3A_object">object</code></td>
<td>
<p>Model specification of class <code>MSGARCH_SPEC</code>
created with <code><a href="#topic+CreateSpec">CreateSpec</a></code> or fit object of type <code>MSGARCH_ML_FIT</code>
created with <code><a href="#topic+FitML">FitML</a></code> or <code>MSGARCH_MCMC_FIT</code> created with <code><a href="#topic+FitMCMC">FitMCMC</a></code>.</p>
</td></tr>
<tr><td><code id="PIT_+3A_...">...</code></td>
<td>
<p>Not used. Other arguments to <code>PIT</code>.</p>
</td></tr>
<tr><td><code id="PIT_+3A_x">x</code></td>
<td>
<p>Vector (of size n). Used when <code>do.its = FALSE</code>.</p>
</td></tr>
<tr><td><code id="PIT_+3A_par">par</code></td>
<td>
<p>Vector (of size d) or matrix (of size <code>nmcmc</code> x d) of
parameter estimates where d must have
the same length as the default parameters of the specification.</p>
</td></tr>
<tr><td><code id="PIT_+3A_data">data</code></td>
<td>
<p>Vector (of size T) of observations.</p>
</td></tr>
<tr><td><code id="PIT_+3A_do.norm">do.norm</code></td>
<td>
<p>Logical indicating if the PIT values are transformed
into standard Normal variate. (Default: <code>do.norm = FALSE</code>)</p>
</td></tr>
<tr><td><code id="PIT_+3A_do.its">do.its</code></td>
<td>
<p>Logical indicating if the in-sample PIT is returned. (Default: <code>do.its = FALSE</code>)</p>
</td></tr>
<tr><td><code id="PIT_+3A_nahead">nahead</code></td>
<td>
<p>Scalar indicating the number of step-ahead evaluation.
Valid only when <code>do.its = FALSE</code>. (Default: <code>nahead = 1L</code>)</p>
</td></tr>
<tr><td><code id="PIT_+3A_do.cumulative">do.cumulative</code></td>
<td>
<p>Logical indicating if the PIT is computed on the cumulative simulations (typically log-returns, as they can be aggregated).
Only available for <code>do.its = FALSE</code>. (Default: <code>do.cumulative = FALSE</code>)</p>
</td></tr>
<tr><td><code id="PIT_+3A_ctr">ctr</code></td>
<td>
<p>A list of control parameters:
</p>

<ul>
<li> <p><code>nsim</code> (integer &gt;= 0):
Number indicating the number of simulation done for the
evaluation of the PIT at <code>nahead &gt; 1</code>. (Default: <code>nsim = 10000L</code>)
</p>
</li></ul>
</td></tr>
<tr><td><code id="PIT_+3A_newdata">newdata</code></td>
<td>
<p>Vector (of size T*) of new observations. (Default: <code>newdata = NULL</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a matrix of MCMC posterior draws is given, the
Bayesian probability integral transform is calculated.
Two or more step-ahead probability integral
transform are estimated via simulation of <code>nsim</code> paths up to <code>t = T + T* + nahead</code>.
The empirical probability integral transforms is then inferred from these simulations.<br />
If <code>do.its = FALSE</code>, the vector <code>x</code> are evaluated as  <code>t = T + T* + 1, ... ,t = T + T* + nahead</code>
realizations.<br />
If <code>do.its = TRUE</code>, <code>x</code> is evaluated
at each time <code>t</code> up to time <code>t = T + T*</code>.<br />
Finally if <code>x = NULL</code> the vector <code>data</code> is evaluated for sample evaluation of the PIT.<br />
The <code>do.norm</code> argument transforms the PIT value into Normal variates so that normality test can be done.
</p>


<h3>Value</h3>

<p>A vector or matrix of class <code>MSGARCH_PIT</code>. <br />
If <code>do.its = FALSE</code>: Probability integral transform of the
points <code>x</code> at <br /> <code>t = T + T* + 1, ... ,t = T + T* + nahead</code> or Normal variate derived from the probability
integral transform of <code>x</code> (matrix of size <code>nahead</code> x n).<br />
If <code>do.its = TRUE</code>: In-sample  probability integral transform or Normal variate
derived from the probability integral transform of <code>data</code> if <code>x = NULL</code> (vector of
size T + T*) or in-sample  probability integral transform or Normal variate
derived from the probability integral transform of <code>x</code> (matrix of size   (T + T*) x n).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create model specification
spec &lt;- CreateSpec()

# load data
data("SMI", package = "MSGARCH")

# fit the model on the data by ML
fit &lt;- FitML(spec = spec, data = SMI)

# run PIT method in-sample
pit.its &lt;- PIT(object = fit, do.norm = TRUE, do.its = TRUE)

# diagnostic of PIT with qqnorm
qqnorm(pit.its)
qqline(pit.its)

# simulate a serie from the model
set.seed(123)
sim.series &lt;- simulate(object = spec, par = fit$par, nahead= 1000L, nsim = 1L)
sim.series &lt;- as.vector(sim.series$draw)

# run PIT method on the simualed serie with the true par
pit.x &lt;- PIT(object = spec, par = fit$par, data = sim.series, do.norm = TRUE, do.its = TRUE)
qqnorm(pit.x)
qqline(pit.x)
</code></pre>

<hr>
<h2 id='predict.MSGARCH_SPEC'>predict method.</h2><span id='topic+predict.MSGARCH_SPEC'></span><span id='topic+predict.MSGARCH_ML_FIT'></span><span id='topic+predict.MSGARCH_MCMC_FIT'></span>

<h3>Description</h3>

<p>Conditional volatility (and predictive distribution) forecasts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MSGARCH_SPEC'
predict(
  object,
  newdata = NULL,
  nahead = 1L,
  do.return.draw = FALSE,
  par = NULL,
  do.cumulative = FALSE,
  ctr = list(),
  ...
)

## S3 method for class 'MSGARCH_ML_FIT'
predict(
  object,
  newdata = NULL,
  nahead = 1L,
  do.return.draw = FALSE,
  do.cumulative = FALSE,
  ctr = list(),
  ...
)

## S3 method for class 'MSGARCH_MCMC_FIT'
predict(
  object,
  newdata = NULL,
  nahead = 1L,
  do.return.draw = FALSE,
  do.cumulative = FALSE,
  ctr = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.MSGARCH_SPEC_+3A_object">object</code></td>
<td>
<p>Model specification of class <code>MSGARCH_SPEC</code>
created with <code><a href="#topic+CreateSpec">CreateSpec</a></code> or fit object of type <code>MSGARCH_ML_FIT</code>
created with <code><a href="#topic+FitML">FitML</a></code> or <code>MSGARCH_MCMC_FIT</code> created with <code><a href="#topic+FitMCMC">FitMCMC</a></code>.</p>
</td></tr>
<tr><td><code id="predict.MSGARCH_SPEC_+3A_newdata">newdata</code></td>
<td>
<p>Vector (of size T*) of new observations. (Default <code>newdata = NULL</code>)</p>
</td></tr>
<tr><td><code id="predict.MSGARCH_SPEC_+3A_nahead">nahead</code></td>
<td>
<p>Scalar indicating the number of step-ahead evaluation.</p>
</td></tr>
<tr><td><code id="predict.MSGARCH_SPEC_+3A_do.return.draw">do.return.draw</code></td>
<td>
<p>Are simulation draws from the predictive distribution 
returned? (Default <code>do.return.draw = FALSE</code>)</p>
</td></tr>
<tr><td><code id="predict.MSGARCH_SPEC_+3A_par">par</code></td>
<td>
<p>Vector (of size d) or matrix (of size <code>nmcmc</code> x d) of
parameter estimates where d must have
the same length as the default parameters of the specification.</p>
</td></tr>
<tr><td><code id="predict.MSGARCH_SPEC_+3A_do.cumulative">do.cumulative</code></td>
<td>
<p>Logical indicating if the conditional volatility 
prediction is computed on the cumulative simulations (typically log-returns, as they can be aggregated).
(Default: <code>do.cumulative = FALSE</code>)</p>
</td></tr>
<tr><td><code id="predict.MSGARCH_SPEC_+3A_ctr">ctr</code></td>
<td>
<p>A list of control parameters:
</p>

<ul>
<li> <p><code>nsim</code> (integer &gt;= 0):
Number indicating the number of simulation done for the
conditional volatlity forecast at <code>nahead &gt; 1</code>. (Default: <code>nsim = 10000L</code>)
</p>
</li></ul>
</td></tr>
<tr><td><code id="predict.MSGARCH_SPEC_+3A_...">...</code></td>
<td>
<p>Not used. Other arguments to <code>predict</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a matrix of MCMC posterior draws is given, the
Bayesian predictive conditional volatility (and predictive distribution) 
forecasts are returned.
</p>


<h3>Value</h3>

<p>A list of class <code>MSGARCH_FORECAST</code> with the following elements:
</p>

<ul>
<li> <p><code>vol</code>: Condititional volatility forecast (vector of size <code>nahead</code>).
</p>
</li>
<li> <p><code>draw</code>: If <code>do.return.draw = TRUE</code>:<br />
Draws sampled from the predictive distributions (matrix of size <code>nahead</code> x <code>nsim</code>).<br />
If <code>do.return.draw = FALSE</code>:<br />
<code>NULL</code>
</p>
</li></ul>

<p>The <code>MSGARCH_FORECAST</code> class contains the <code>plot</code> method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create specification
spec &lt;- CreateSpec()

# load data
data("SMI", package = "MSGARCH")

# predict from specification
par &lt;- c(0.1, 0.1, 0.8, 0.2, 0.1, 0.8, 0.99, 0.01)
set.seed(1234)
pred &lt;- predict(object = spec, par = par, newdata = SMI, nahead = 5L)
head(pred)
plot(pred)

# predict from ML fit
fit &lt;- FitML(spec = spec, data = SMI)
set.seed(1234)
pred &lt;- predict(object = fit, nahead = 5L, do.return.draw = TRUE)
head(pred)
plot(pred)

## Not run: 
set.seed(1234)
fit &lt;- FitMCMC(spec = spec, data = SMI)
pred &lt;- predict(object = fit, nahead = 5L, do.return.draw = TRUE)
plot(pred)

## End(Not run)
</code></pre>

<hr>
<h2 id='PredPdf'>Predictive density.</h2><span id='topic+PredPdf'></span><span id='topic+PredPdf.MSGARCH_SPEC'></span><span id='topic+PredPdf.MSGARCH_ML_FIT'></span><span id='topic+PredPdf.MSGARCH_MCMC_FIT'></span>

<h3>Description</h3>

<p>Method returning the predictive density (pdf).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PredPdf(object, ...)

## S3 method for class 'MSGARCH_SPEC'
PredPdf(
  object,
  x = NULL,
  par = NULL,
  data = NULL,
  log = FALSE,
  do.its = FALSE,
  nahead = 1L,
  do.cumulative = FALSE,
  ctr = list(),
  ...
)

## S3 method for class 'MSGARCH_ML_FIT'
PredPdf(
  object,
  x = NULL,
  newdata = NULL,
  log = FALSE,
  do.its = FALSE,
  nahead = 1L,
  do.cumulative = FALSE,
  ctr = list(),
  ...
)

## S3 method for class 'MSGARCH_MCMC_FIT'
PredPdf(
  object,
  x = NULL,
  newdata = NULL,
  log = FALSE,
  do.its = FALSE,
  nahead = 1L,
  do.cumulative = FALSE,
  ctr = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PredPdf_+3A_object">object</code></td>
<td>
<p>Model specification of class <code>MSGARCH_SPEC</code> created with <code><a href="#topic+CreateSpec">CreateSpec</a></code>
or fit object of type <code>MSGARCH_ML_FIT</code> created with <code><a href="#topic+FitML">FitML</a></code> or <code>MSGARCH_MCMC_FIT</code>
created with <code><a href="#topic+FitMCMC">FitMCMC</a></code>.</p>
</td></tr>
<tr><td><code id="PredPdf_+3A_...">...</code></td>
<td>
<p>Not used. Other arguments to <code>PredPdf</code>.</p>
</td></tr>
<tr><td><code id="PredPdf_+3A_x">x</code></td>
<td>
<p>Vector (of size n). Used when <code>do.its = FALSE</code>.</p>
</td></tr>
<tr><td><code id="PredPdf_+3A_par">par</code></td>
<td>
<p>Vector (of size d) or matrix (of size <code>nmcmc</code> x d) of parameter
estimates where d must have the same length as the default parameters of the specification.</p>
</td></tr>
<tr><td><code id="PredPdf_+3A_data">data</code></td>
<td>
<p>Vector (of size T) of observations.</p>
</td></tr>
<tr><td><code id="PredPdf_+3A_log">log</code></td>
<td>
<p>Logical indicating if the log-density is returned. (Default: <code>log = FALSE</code>)</p>
</td></tr>
<tr><td><code id="PredPdf_+3A_do.its">do.its</code></td>
<td>
<p>Logical indicating if the in-sample predictive is returned. (Default: <code>do.its = FALSE</code>)</p>
</td></tr>
<tr><td><code id="PredPdf_+3A_nahead">nahead</code></td>
<td>
<p>Scalar indicating the number of step-ahead evaluation.
Valid only when <code>do.its = FALSE</code>. (Default: <code>nahead = 1L</code>)</p>
</td></tr>
<tr><td><code id="PredPdf_+3A_do.cumulative">do.cumulative</code></td>
<td>
<p>Logical indicating if predictive density is computed on the 
cumulative simulations (typically log-returns, as they can be aggregated).
Only available for <code>do.its = FALSE</code>. (Default: <code>do.cumulative = FALSE</code>)</p>
</td></tr>
<tr><td><code id="PredPdf_+3A_ctr">ctr</code></td>
<td>
<p>A list of control parameters:
</p>

<ul>
<li> <p><code>nsim</code> (integer &gt;= 0) :
Number indicating the number of simulation done for the evaluation
of the density at <code>nahead</code> &gt; 1. (Default: <code>nsim = 10000L</code>)
</p>
</li></ul>
</td></tr>
<tr><td><code id="PredPdf_+3A_newdata">newdata</code></td>
<td>
<p>Vector (of size T*) of new observations. (Default <code>newdata = NULL</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a matrix of MCMC posterior draws is given, the Bayesian
predictive probability density  is calculated.
Two or more step-ahead predictive probability density are estimated via simulation of <code>nsim</code> paths up to
<code>t = T + T* +  nahead</code>. The predictive distribution are then inferred from these
simulations via a Gaussian Kernel density.
If <code>do.its = FALSE</code>, the vector <code>x</code> are evaluated as <code>t = T + T* + 1, ... ,t = T + T* + nahead</code>
realization.<br />
If <code>do.its = TRUE</code> and  <code>x</code> is evaluated
at each time <code>t</code> up top time <code>t = T + T*</code>.<br />
Finally, if <code>x = NULL</code> the vector <code>data</code> is evaluated for sample 
evaluation of the predictive denisty ((log-)likelihood of each sample points).
</p>


<h3>Value</h3>

<p>A vector or matrix of class <code>MSGARCH_PRED</code>.<br />
If <code>do.its = FALSE</code>: (Log-)predictive of
the points <code>x</code> at <code>t = T + T* + 1, ... ,t = T + T* + nahead</code> (matrix of
size <code>nahead</code> x n).<br />
If <code>do.its = TRUE</code>: In-sample predictive of <code>data</code> if <code>x = NULL</code>
(vector of size T + T*) or in-sample predictive of <code>x</code> (matrix of size (T + T*) x n).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create model specification
spec &lt;- CreateSpec()

# load data
data("SMI", package = "MSGARCH")

# fit the model on the data by ML
fit &lt;- FitML(spec = spec, data = SMI)

# run PredPdf method in-sample
pred.its &lt;- PredPdf(object = fit, log = TRUE, do.its = TRUE)

# create a mesh
x &lt;- seq(-3,3,0.01)

# run PredPdf method on mesh at T + 1
pred.x &lt;- PredPdf(object = fit, x = x, log = TRUE, do.its = FALSE)
</code></pre>

<hr>
<h2 id='Risk'>Value-at-Risk and Expected-shortfall.</h2><span id='topic+Risk'></span><span id='topic+Risk.MSGARCH_SPEC'></span><span id='topic+Risk.MSGARCH_ML_FIT'></span><span id='topic+Risk.MSGARCH_MCMC_FIT'></span>

<h3>Description</h3>

<p>Method returning the Value-at-Risk and Expected-shortfall risk measures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Risk(object, ...)

## S3 method for class 'MSGARCH_SPEC'
Risk(
  object,
  par,
  data,
  alpha = c(0.01, 0.05),
  nahead = 1L,
  do.es = TRUE,
  do.its = FALSE,
  do.cumulative = FALSE,
  ctr = list(),
  ...
)

## S3 method for class 'MSGARCH_ML_FIT'
Risk(
  object,
  newdata = NULL,
  alpha = c(0.01, 0.05),
  do.es = TRUE,
  do.its = FALSE,
  nahead = 1L,
  do.cumulative = FALSE,
  ctr = list(),
  ...
)

## S3 method for class 'MSGARCH_MCMC_FIT'
Risk(
  object,
  newdata = NULL,
  alpha = c(0.01, 0.05),
  do.es = TRUE,
  do.its = FALSE,
  nahead = 1L,
  do.cumulative = FALSE,
  ctr = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Risk_+3A_object">object</code></td>
<td>
<p>Model specification of class <code>MSGARCH_SPEC</code>
created with <code><a href="#topic+CreateSpec">CreateSpec</a></code> or fit object of type <code>MSGARCH_ML_FIT</code>
created with <code><a href="#topic+FitML">FitML</a></code> or <code>MSGARCH_MCMC_FIT</code>
created with <code><a href="#topic+FitMCMC">FitMCMC</a></code>.</p>
</td></tr>
<tr><td><code id="Risk_+3A_...">...</code></td>
<td>
<p>Not used. Other arguments to <code>Risk</code>.</p>
</td></tr>
<tr><td><code id="Risk_+3A_par">par</code></td>
<td>
<p>Vector (of size d) or matrix (of size <code>nmcmc</code> x d) of parameter estimates
where d must have
the same length as the default parameters of the specification.</p>
</td></tr>
<tr><td><code id="Risk_+3A_data">data</code></td>
<td>
<p>Vector (of size T) of observations.</p>
</td></tr>
<tr><td><code id="Risk_+3A_alpha">alpha</code></td>
<td>
<p>Vector (of size R) of Value-at-risk and Expected-shortfall levels.<br />
(Default: <code>alpha = c(0.01, 0.05)</code>)</p>
</td></tr>
<tr><td><code id="Risk_+3A_nahead">nahead</code></td>
<td>
<p>Scalar indicating the number of step-ahead evaluation. (Default: <code>nahead = 1L</code>). Not used when
<code>do.its = TRUE</code> as it only returns in-sample one-step ahead risk measures.</p>
</td></tr>
<tr><td><code id="Risk_+3A_do.es">do.es</code></td>
<td>
<p>Logical indicating if Expected-shortfall is also calculated.
(Default: <code>do.es = TRUE</code>)</p>
</td></tr>
<tr><td><code id="Risk_+3A_do.its">do.its</code></td>
<td>
<p>Logical indicating if the in-sample risk estimators are returned.
(Default: <code>do.its = FALSE</code>).</p>
</td></tr>
<tr><td><code id="Risk_+3A_do.cumulative">do.cumulative</code></td>
<td>
<p>Logical indicating if the risk measures are computed on the 
cumulative simulations (typically log-returns, as they can be aggregated).
Only available for <code>do.its = FALSE</code>. (Default: <code>do.cumulative = FALSE</code>)</p>
</td></tr>
<tr><td><code id="Risk_+3A_ctr">ctr</code></td>
<td>
<p>A list of control parameters:
</p>

<ul>
<li> <p><code>nmesh</code> (integer &gt;= 0) : Number of points for density
evaluation. (Default: <code>nmesh = 1000L</code>)
</p>
</li>
<li> <p><code>nsim</code> (integer &gt;= 0) :
Number indicating the number of simulation done for estimation of the
density at <code>nahead &gt; 1</code>. (Default: <code>nsim = 10000L</code>)
</p>
</li></ul>
</td></tr>
<tr><td><code id="Risk_+3A_newdata">newdata</code></td>
<td>
<p>Vector (of size T*) of new observations. (Default <code>newdata = NULL</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a matrix of MCMC posterior draws is given, the
Bayesian Value-at-Risk and Expected-shortfall are calculated.
Two or more step ahead risk measures are estimated via simulation of <code>nsim</code> paths up to
<code>t = T + T* + nahead</code>.
If <code>do.its = FALSE</code>, the risk estimators at <code>t = T + T* + 1, ... ,t = T + T* + nahead</code>
are computed. <code>do.cumulative = TRUE</code> indicate the function to compute the risk meausre 
over aggregated period up to <code>nahead</code> period using the <code>cumsum</code> function on the simulated data.
</p>


<h3>Value</h3>

<p>A list of class <code>MSGARCH_RISK</code> with the following elements:
</p>

<ul>
<li> <p><code>VaR</code>:<br />
If <code>do.its = FALSE</code>: Value-at-Risk at <code>t = T + T* + 1, ... ,t = T + T* + nahead</code> at the
chosen levels (matrix of size <code>nahead</code> x R).<br />
If <code>do.its = TRUE</code>: In-sample Value-at-Risk at the chosen levels (Matrix of size (T + T*) x R).
</p>
</li>
<li> <p><code>ES</code>:<br />
If <code>do.its = FALSE</code>: Expected-shortfall at <code>t = T + T* + 1, ... ,t = T + T* + nahead</code> at the
chosen levels (matrix of size <code>nahead</code> x R).<br />
If <code>do.its = TRUE</code>: In-sample Expected-shortfall at the chosen levels (Matrix of size (T + T*) x R).
</p>
</li></ul>

<p>The <code>MSGARCH_RISK</code> contains the <code>plot</code> method.
Note that the MCMC/Bayesian risk estimator can take long time to calculate
depending on the size of the MCMC chain.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create specification
spec &lt;- CreateSpec()

# load data
data("SMI", package = "MSGARCH")

# risk from specification
par &lt;- c(0.1, 0.1, 0.8, 0.2, 0.1, 0.8, 0.99, 0.01)
set.seed(1234)
risk &lt;- Risk(object = spec, par = par, data = SMI, nahead = 5L)
head(risk)
plot(risk)

# risk from ML fit
fit &lt;- FitML(spec = spec, data = SMI)
set.seed(1234)
risk &lt;- Risk(object = fit, nahead = 5L)
head(risk)
plot(risk)

## Not run: 
# risk from MCMC fit
set.seed(1234)
fit &lt;- FitMCMC(spec = spec, data = SMI)
risk &lt;- Risk(object = fit, nahead = 5L)
head(risk)
plot(risk)

## End(Not run)
</code></pre>

<hr>
<h2 id='simulate.MSGARCH_SPEC'>Simulation of MSGARCH processes.</h2><span id='topic+simulate.MSGARCH_SPEC'></span><span id='topic+simulate.MSGARCH_ML_FIT'></span><span id='topic+simulate.MSGARCH_MCMC_FIT'></span>

<h3>Description</h3>

<p>Method for simulating <code>MSGARCH</code> processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MSGARCH_SPEC'
simulate(
  object,
  nsim = 1L,
  seed = NULL,
  nahead = 1L,
  par = NULL,
  nburn = 500L,
  ...
)

## S3 method for class 'MSGARCH_ML_FIT'
simulate(object, nsim = 1L, seed = NULL, nahead = 1L, nburn = 500L, ...)

## S3 method for class 'MSGARCH_MCMC_FIT'
simulate(object, nsim = 1L, seed = NULL, nahead = 1L, nburn = 500L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.MSGARCH_SPEC_+3A_object">object</code></td>
<td>
<p>Model specification of class <code>MSGARCH_SPEC</code> created with <code><a href="#topic+CreateSpec">CreateSpec</a></code>
or fit object of type <code>MSGARCH_ML_FIT</code> created with <code><a href="#topic+FitML">FitML</a></code> or <code>MSGARCH_MCMC_FIT</code>
created with <code><a href="#topic+FitMCMC">FitMCMC</a></code>.</p>
</td></tr>
<tr><td><code id="simulate.MSGARCH_SPEC_+3A_nsim">nsim</code></td>
<td>
<p>Number of simulations. (Default: <code>nsim = 1L</code>)</p>
</td></tr>
<tr><td><code id="simulate.MSGARCH_SPEC_+3A_seed">seed</code></td>
<td>
<p>Integer indicating if and how the random number generator should be initialized. 
If <code>seed = NULL</code>, the state of the random generator will not change. (Default: <code>seed = NULL</code>)</p>
</td></tr>
<tr><td><code id="simulate.MSGARCH_SPEC_+3A_nahead">nahead</code></td>
<td>
<p>Simulation length. (Default: <code>nahead = 1L</code>)</p>
</td></tr>
<tr><td><code id="simulate.MSGARCH_SPEC_+3A_par">par</code></td>
<td>
<p>Vector (of size d) or matrix (of size <code>nahead</code> x d) of parameter</p>
</td></tr>
<tr><td><code id="simulate.MSGARCH_SPEC_+3A_nburn">nburn</code></td>
<td>
<p>Burnin period discarded (first simulation draws).</p>
</td></tr>
<tr><td><code id="simulate.MSGARCH_SPEC_+3A_...">...</code></td>
<td>
<p>Not used. Other arguments to <code>simulate</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a matrix of parameters estimates is provided, <code>nsim</code> simuations will be done for each row.
</p>


<h3>Value</h3>

<p>A list of class <code>MSGARCH_SIM</code> with the following elements:.
</p>

<ul>
<li> <p><code>draw</code>: Matrix (of size <code>nahead</code> x <code>nsim</code>) of simulated draws.
</p>
</li>
<li> <p><code>state</code>: Matrix (of size <code>nahead</code> x <code>nsim</code>) of simulated states.
</p>
</li>
<li> <p><code>CondVol</code>: Array (of size <code>nahead</code> x <code>nsim</code> x K) of simulated conditional volatilities.  
</p>
</li></ul>

<p>The <code>MSGARCH_SIM</code> class contains the <code>plot</code> method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create specification
spec &lt;- CreateSpec()

# simulation from specification
par &lt;- c(0.1, 0.1, 0.8, 0.2, 0.1, 0.8, 0.99, 0.01)
set.seed(1234)
sim &lt;- simulate(object = spec, nsim = 1L, nahead = 1000L, 
                nburn = 500L, par = par)
head(sim)
plot(sim)

# load data
data("SMI", package = "MSGARCH")

# simulation from ML fit
fit &lt;- FitML(spec = spec, data = SMI)
set.seed(1234)
sim &lt;- simulate(object = fit, nsim = 1L, nahead = 1000L, 
                nburn = 500L)
head(sim)
plot(sim)

## Not run: 
# simulation from MCMC fit
fit &lt;- FitMCMC(spec = spec, data = SMI)
set.seed(1234)
sim &lt;- simulate(object = fit, nahead = 100L, nburn = 500L)
head(sim)
plot(sim)

## End(Not run)
</code></pre>

<hr>
<h2 id='SMI'>Swiss market index dataset</h2><span id='topic+SMI'></span>

<h3>Description</h3>

<p>See Mullen et al. (2011) for a description of this dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("SMI")
</code></pre>


<h3>Format</h3>

<p><code>zoo</code> object containing 2,500 observations ranging from 1990-11-12 to 2000-10-20.
</p>


<h3>Source</h3>

<p><code>DEoptim</code> package
</p>


<h3>References</h3>

<p>Mullen, K.M, Ardia, D., Gil, D., Windover, D., Cline, J. (2011).
<code>DEoptim</code>: An R Package for Global Optimization by Differential Evolution. 
<em>Journal of Statistical Software</em>, 40(6), 1-26.
doi: <a href="https://doi.org/10.18637/jss.v040.i06">10.18637/jss.v040.i06</a>
</p>

<hr>
<h2 id='State'>State probabilities.</h2><span id='topic+State'></span><span id='topic+State.MSGARCH_SPEC'></span><span id='topic+State.MSGARCH_ML_FIT'></span><span id='topic+State.MSGARCH_MCMC_FIT'></span>

<h3>Description</h3>

<p>Method returning the filtered, predictive, and smoothed probabilities of the states,
and the most probable path computed with the Viterbi algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>State(object, ...)

## S3 method for class 'MSGARCH_SPEC'
State(object, par, data, ...)

## S3 method for class 'MSGARCH_ML_FIT'
State(object, newdata = NULL, ...)

## S3 method for class 'MSGARCH_MCMC_FIT'
State(object, newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="State_+3A_object">object</code></td>
<td>
<p>Model specification of class <code>MSGARCH_SPEC</code>
created with <code><a href="#topic+CreateSpec">CreateSpec</a></code> or fit object of type <code>MSGARCH_ML_FIT</code>
created with <code><a href="#topic+FitML">FitML</a></code> or <code>MSGARCH_MCMC_FIT</code>
created with <code><a href="#topic+FitMCMC">FitMCMC</a></code>.</p>
</td></tr>
<tr><td><code id="State_+3A_...">...</code></td>
<td>
<p>Not used. Other arguments to <code>State</code>.</p>
</td></tr>
<tr><td><code id="State_+3A_par">par</code></td>
<td>
<p>Vector (of size d) or matrix (of size <code>nmcmc</code> x d) of parameter estimates
where d must have
the same length as the default parameters of the specification.</p>
</td></tr>
<tr><td><code id="State_+3A_data">data</code></td>
<td>
<p>Vector (of size T) of observations.</p>
</td></tr>
<tr><td><code id="State_+3A_newdata">newdata</code></td>
<td>
<p>Vector (of size T*) of new observations. (Default <code>newdata = NULL</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a matrix of parameter estimates is given, each parameter
estimate (each row) is evaluated individually.
</p>


<h3>Value</h3>

<p>A list of class <code>MSGARCH_PSTATE</code> with the following elements:
</p>

<ul>
<li> <p><code>FiltProb</code>: Filtered probabilities (array of size (T + T*) x (<code>nmcmc or 1</code>) x K).
</p>
</li>
<li> <p><code>PredProb</code>: Predictive probabilities (array of size (T + T* + 1) x (<code>nmcmc or 1</code>) x K).
</p>
</li>
<li> <p><code>SmoothProb</code>: Smoothed probabilities (array of size (T + T* + 1) x (<code>nmcmc or 1</code>) x K).
</p>
</li>
<li> <p><code>Viterbi</code>:  Most likely path (matrix of size (T + T*) x (<code>nmcmc</code> or 1)).
</p>
</li></ul>

<p>The class <code>MSGARCH_PSTATE</code> contains the <code>plot</code> method. The plot method contains
as input <code>type.prob</code> which is one of <code>"filtered", "predictive", "smoothed", "viterbi"</code>.
(Default: <code>type.prob = "smoothed"</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create specification
spec &lt;- CreateSpec()

# load data
data("SMI", package = "MSGARCH")

# state from specification
par &lt;- c(0.1, 0.1, 0.8, 0.2, 0.1, 0.8, 0.99, 0.01)
state &lt;- State(object = spec, par = par, data = SMI)
plot(state, type.prob = "filtered")

# state from ML fit
fit &lt;- FitML(spec = spec, data = SMI)
state &lt;- State(object = fit)
plot(state, type.prob = "smoothed")

## Not run: 
# state from MCMC fit
set.seed(1234)
fit &lt;- FitMCMC(spec = spec, data = SMI)
state &lt;- State(object = fit)
plot(state, type.prob = "smoothed")

## End(Not run)
</code></pre>

<hr>
<h2 id='TransMat'>Transition matrix.</h2><span id='topic+TransMat'></span><span id='topic+TransMat.MSGARCH_SPEC'></span><span id='topic+TransMat.MSGARCH_ML_FIT'></span>

<h3>Description</h3>

<p>Method returning the transition matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TransMat(object, ...)

## S3 method for class 'MSGARCH_SPEC'
TransMat(object, par = NULL, nahead = 1L, ...)

## S3 method for class 'MSGARCH_ML_FIT'
TransMat(object, nahead = 1L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TransMat_+3A_object">object</code></td>
<td>
<p>Model specification of class <code>MSGARCH_SPEC</code>
created with <code><a href="#topic+CreateSpec">CreateSpec</a></code>
or fit object of type <code>MSGARCH_ML_FIT</code> created with <code><a href="#topic+FitML">FitML</a></code>.</p>
</td></tr>
<tr><td><code id="TransMat_+3A_...">...</code></td>
<td>
<p>Not used. Other arguments to <code>TransMat</code>.</p>
</td></tr>
<tr><td><code id="TransMat_+3A_par">par</code></td>
<td>
<p>Vector (of size d) of
parameter estimates (not required when using a fit object) where d must have
the same length as the default parameters of the specification.</p>
</td></tr>
<tr><td><code id="TransMat_+3A_nahead">nahead</code></td>
<td>
<p>Number of steps ahead. (Default: <code>nahead = 1L</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix (of size K x K) in the case of a Markov-Switching model
or a vector (of size K) in the case of a Mixture of GARCH model.
The row indicates the starting states while the columns indicates the transition states.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create model specification
spec &lt;- CreateSpec()

# load data
data("SMI", package = "MSGARCH")

# fit the model on the data by ML
fit &lt;- FitML(spec = spec, data = SMI)

# Extract the transition matrix 10 steps ahead
trans.mat &lt;- TransMat(fit, nahead = 10)
print(trans.mat)
</code></pre>

<hr>
<h2 id='UncVol'>Unconditional volatility.</h2><span id='topic+UncVol'></span><span id='topic+UncVol.MSGARCH_SPEC'></span><span id='topic+UncVol.MSGARCH_ML_FIT'></span><span id='topic+UncVol.MSGARCH_MCMC_FIT'></span>

<h3>Description</h3>

<p>Method returning the unconditional volatility of the process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UncVol(object, ...)

## S3 method for class 'MSGARCH_SPEC'
UncVol(object, par = NULL, ctr = list(), ...)

## S3 method for class 'MSGARCH_ML_FIT'
UncVol(object, ctr = list(), ...)

## S3 method for class 'MSGARCH_MCMC_FIT'
UncVol(object, ctr = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UncVol_+3A_object">object</code></td>
<td>
<p>Model specification of class <code>MSGARCH_SPEC</code>
created with <code><a href="#topic+CreateSpec">CreateSpec</a></code> or fit object of type <code>MSGARCH_ML_FIT</code>
created with <code><a href="#topic+FitML">FitML</a></code> or <code>MSGARCH_MCMC_FIT</code>
created with <code><a href="#topic+FitMCMC">FitMCMC</a></code>.</p>
</td></tr>
<tr><td><code id="UncVol_+3A_...">...</code></td>
<td>
<p>Not used. Other arguments to <code>UncVol</code>.</p>
</td></tr>
<tr><td><code id="UncVol_+3A_par">par</code></td>
<td>
<p>Vector (of size d) or matrix (of size <code>nmcmc</code> x d) of parameter
estimates where d must have
the same length as the default parameters of the specification.</p>
</td></tr>
<tr><td><code id="UncVol_+3A_ctr">ctr</code></td>
<td>
<p>A list of control parameters:
</p>

<ul>
<li> <p><code>nsim</code> (integer &gt;= 0) :
Number of simulations used for the estimation of the
unconditional volatility. (Default: <code>nsim = 250L</code>)
</p>
</li>
<li> <p><code>nahead</code> (integer &gt;= 0) :
Number of step ahead performed to estimate the
unconditional volatility .(Default: <code>nahead = 5000L</code>)
</p>
</li>
<li> <p><code>nburn</code> (integer &gt;= 0) :
Number of discarded step to estimate the
unconditional volatility. (Default: <code>nburn = 1000L</code>)
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>If a matrix of MCMC posterior draws is given, the
Bayesian unconditional volatility is calculated.
The unconditional volatility is estimated by first simulating <code>nsim</code>
paths up to <code>nburn + nahead</code>,
calculating a forecast of the conditional volatility at each step ahead,
discarding the first <code>nburn</code> step ahead conditional volatilities forecasts,
and computing the mean of the remaining <code>nahead - nburn</code> conditional
volatilites forecasts. This method is based on the fact that
the conditional volatility forecast will converge to the unconditional volatilty
the further the forecast his from the starting point.
We take the average as a way to remove the noise that comes with the simulation process.
Overall, this method allows to compute the unconditional volatilty complex models.
</p>


<h3>Value</h3>

<p>A <code>scalar</code> of unconditional volatility.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create specification
spec &lt;- CreateSpec()

## Not run: 
# unconditional volatility from specification
par &lt;- c(0.1, 0.1, 0.8, 0.2, 0.1, 0.8, 0.99, 0.01)
UncVol(object = spec, par = par)

# load data
data("SMI", package = "MSGARCH")

# unconditional volatility from ML fit
fit &lt;- FitML(spec = spec, data = SMI)
UncVol(object = fit)
var(SMI)

# unconditional volatility from MCMC fit
set.seed(1234)
fit &lt;- FitMCMC(spec = spec, data = SMI)
UncVol(object = fit)

## End(Not run)
</code></pre>

<hr>
<h2 id='Volatility'>Volatility filtering.</h2><span id='topic+Volatility'></span><span id='topic+Volatility.MSGARCH_SPEC'></span><span id='topic+Volatility.MSGARCH_ML_FIT'></span><span id='topic+Volatility.MSGARCH_MCMC_FIT'></span>

<h3>Description</h3>

<p>Method returning the in-sample conditional volatility.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Volatility(object, ...)

## S3 method for class 'MSGARCH_SPEC'
Volatility(object, par, data, ...)

## S3 method for class 'MSGARCH_ML_FIT'
Volatility(object, newdata = NULL, ...)

## S3 method for class 'MSGARCH_MCMC_FIT'
Volatility(object, newdata = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Volatility_+3A_object">object</code></td>
<td>
<p>Model specification of class <code>MSGARCH_SPEC</code>
created with <code><a href="#topic+CreateSpec">CreateSpec</a></code> or fit object of type <code>MSGARCH_ML_FIT</code>
created with <code><a href="#topic+FitML">FitML</a></code> or <code>MSGARCH_MCMC_FIT</code> created with <code><a href="#topic+FitMCMC">FitMCMC</a></code>.</p>
</td></tr>
<tr><td><code id="Volatility_+3A_...">...</code></td>
<td>
<p>Not used. Other arguments to <code>Volatility</code>.</p>
</td></tr>
<tr><td><code id="Volatility_+3A_par">par</code></td>
<td>
<p>Vector (of size d) or matrix (of size <code>nmcmc</code> x d) of parameter
estimates where d must have the same length as the default parameters of the specification.</p>
</td></tr>
<tr><td><code id="Volatility_+3A_data">data</code></td>
<td>
<p>Vector (of size T) of observations.</p>
</td></tr>
<tr><td><code id="Volatility_+3A_newdata">newdata</code></td>
<td>
<p>Vector (of size T*) of new observations. (Default <code>newdata = NULL</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a matrix of MCMC posterior draws is given, the
Bayesian predictive conditional volatility is calculated.
</p>


<h3>Value</h3>

<p>In-sample condititional volatility (vector of size T + T*) of class <code>MSGARCH_CONDVOL</code>.<br />
The <code>MSGARCH_CONDVOL</code> class contains the <code>plot</code> method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create specification
spec &lt;- CreateSpec()

# load data
data("SMI", package = "MSGARCH")

# in-sample volatility from specification
par &lt;- c(0.1, 0.1, 0.8, 0.2, 0.1, 0.8, 0.99, 0.01)
vol &lt;- Volatility(object = spec, par = par, data = SMI)
head(vol)
plot(vol)

# in-sample volatility from ML fit
fit &lt;- FitML(spec = spec, data = SMI)
vol &lt;- Volatility(object = fit)
head(vol)
plot(vol)

## Not run: 
# in-sample volatility from MCMC fit
set.seed(1234)
fit &lt;- FitMCMC(spec = spec, data = SMI)
vol &lt;- Volatility(object = fit)
head(vol)
plot(vol)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
