<!DOCTYPE html><html><head><title>Help for package vsp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {vsp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#vsp-package'><p>vsp: Vintage Sparse PCA for Semi-Parametric Factor Analysis</p></a></li>
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#bff'><p>Find features most associated with cluster membership</p></a></li>
<li><a href='#bind_varimax_z'><p>Add Z factor loadings to node table of tidygraph</p></a></li>
<li><a href='#get_svd_u'><p>Get left singular vectors in a tibble</p></a></li>
<li><a href='#get_z_hubs'><p>Get most important hubs for each Z factor</p></a></li>
<li><a href='#make_skew_positive'><p>Make factors columnwise skew positive</p></a></li>
<li><a href='#plot_ipr_pairs'><p>Plot pairs of inverse participation ratios for singular vectors</p></a></li>
<li><a href='#plot_mixing_matrix'><p>Plot the mixing matrix B</p></a></li>
<li><a href='#plot_varimax_z_pairs'><p>Create a pairs plot of select Y factors</p></a></li>
<li><a href='#safe_row_l2_normalize'><p>Safe L2 row normalization</p></a></li>
<li><a href='#screeplot.vsp_fa'><p>Create a screeplot from a factor analysis object</p></a></li>
<li><a href='#set_z_factor_names'><p>Give the dimensions of Z factors informative names</p></a></li>
<li><a href='#vsp'><p>Semi-Parametric Factor Analysis via Vintage Sparse PCA</p></a></li>
<li><a href='#vsp_fa'><p>Create a vintage sparse factor analysis object</p></a></li>
<li><a href='#vsp.svd_like'><p>Perform varimax rotation on a low rank matrix factorization</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Vintage Sparse PCA for Semi-Parametric Factor Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides fast spectral estimation of latent factors in random
    dot product graphs using the vsp estimator. Under mild assumptions,
    the vsp estimator is consistent for (degree-corrected) stochastic
    blockmodels, (degree-corrected) mixed-membership stochastic
    blockmodels, and degree-corrected overlapping stochastic blockmodels.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/RoheLab/vsp">https://github.com/RoheLab/vsp</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/RoheLab/vsp/issues">https://github.com/RoheLab/vsp/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, glue, invertiforms, LRMF3, magrittr, Matrix, rlang,
RSpectra, stats, tibble, withr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, dplyr, GGally, igraph, igraphdata, knitr, purrr,
rmarkdown, scales, testthat (&ge; 3.0.0), tidygraph, tidyr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-04 21:09:56 UTC; alex</td>
</tr>
<tr>
<td>Author:</td>
<td>Karl Rohe [aut],
  Muzhe Zeng [aut],
  Alex Hayes <a href="https://orcid.org/0000-0002-4985-5160"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre, cph],
  Fan Chen [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alex Hayes &lt;alexpghayes@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-05 16:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='vsp-package'>vsp: Vintage Sparse PCA for Semi-Parametric Factor Analysis</h2><span id='topic+vsp-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>Provides fast spectral estimation of latent factors in random dot product graphs using the vsp estimator. Under mild assumptions, the vsp estimator is consistent for (degree-corrected) stochastic blockmodels, (degree-corrected) mixed-membership stochastic blockmodels, and degree-corrected overlapping stochastic blockmodels.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Alex Hayes <a href="mailto:alexpghayes@gmail.com">alexpghayes@gmail.com</a> (<a href="https://orcid.org/0000-0002-4985-5160">ORCID</a>) [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Karl Rohe <a href="mailto:karlrohe@stat.wisc.edu">karlrohe@stat.wisc.edu</a>
</p>
</li>
<li><p> Muzhe Zeng <a href="mailto:mzeng6@wisc.edu">mzeng6@wisc.edu</a>
</p>
</li>
<li><p> Fan Chen
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/RoheLab/vsp">https://github.com/RoheLab/vsp</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/RoheLab/vsp/issues">https://github.com/RoheLab/vsp/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='bff'>Find features most associated with cluster membership</h2><span id='topic+bff'></span>

<h3>Description</h3>

<p>Find features most associated with cluster membership
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bff(loadings, features, num_best)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bff_+3A_loadings">loadings</code></td>
<td>
<p>An <code>n</code> by <code>k</code> matrix of weights that indicates how
important that ith user is to the jth cluster, i.e., the <code>Z</code> or <code>Y</code>
matrix calculated by <code><a href="#topic+vsp">vsp()</a></code>.</p>
</td></tr>
<tr><td><code id="bff_+3A_features">features</code></td>
<td>
<p>An <code>n</code> by <code>d</code> matrix of features measured for each
node in the network.</p>
</td></tr>
<tr><td><code id="bff_+3A_num_best">num_best</code></td>
<td>
<p>An integer indicating how many of the top features
for differentiating between loadings you want.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>vignette("bff")</code>.
</p>


<h3>Value</h3>

<p>An <code>n</code> by <code>k</code> matrix whose <code style="white-space: pre;">&#8288;[i, j]&#8288;</code> entry is the
ith &quot;most important&quot; feature for cluster j.
</p>

<hr>
<h2 id='bind_varimax_z'>Add Z factor loadings to node table of tidygraph</h2><span id='topic+bind_varimax_z'></span><span id='topic+bind_varimax_y'></span><span id='topic+bind_svd_u'></span><span id='topic+bind_svd_v'></span>

<h3>Description</h3>

<p>Add Z factor loadings to node table of tidygraph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bind_varimax_z(graph, fa, ...)

bind_varimax_y(graph, fa, ...)

bind_svd_u(graph, fa, ...)

bind_svd_v(graph, fa, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bind_varimax_z_+3A_graph">graph</code></td>
<td>
<p>A <a href="tidygraph.html#topic+tbl_graph">tidygraph::tbl_graph</a> object.</p>
</td></tr>
<tr><td><code id="bind_varimax_z_+3A_fa">fa</code></td>
<td>
<p>Optionally, a <a href="#topic+vsp">vsp</a> object to extract varimax loadings from. If
you do not passed a <a href="#topic+vsp">vsp</a> object, one will be created.</p>
</td></tr>
<tr><td><code id="bind_varimax_z_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="#topic+vsp">vsp</a></code>
</p>

<dl>
<dt><code>x</code></dt><dd><p>Either a graph adjacency matrix, <a href="igraph.html#topic+aaa-igraph-package">igraph::igraph</a> or
<a href="tidygraph.html#topic+tbl_graph">tidygraph::tbl_graph</a>. If <code>x</code> is a <a href="base.html#topic+matrix">matrix</a> or <a href="Matrix.html#topic+Matrix">Matrix::Matrix</a>
then <code>x[i, j]</code> should correspond to the edge going from node <code>i</code>
to node <code>j</code>.</p>
</dd>
<dt><code>rank</code></dt><dd><p>The number of factors to calculate.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>The same <code>graph</code> object with columns <code>factor1</code>, ..., <code style="white-space: pre;">&#8288;factor{rank}&#8288;</code>
in the table of node information.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>bind_varimax_y</code>: Add Y factor loadings to node table of tidygraph
</p>
</li>
<li> <p><code>bind_svd_u</code>: Add left singular vectors to node table of tidygraph
</p>
</li>
<li> <p><code>bind_svd_v</code>: Add right singular vectors to node table of tidygraph
</p>
</li></ul>

<hr>
<h2 id='get_svd_u'>Get left singular vectors in a tibble</h2><span id='topic+get_svd_u'></span><span id='topic+get_svd_v'></span><span id='topic+get_varimax_z'></span><span id='topic+get_varimax_y'></span>

<h3>Description</h3>

<p>Get left singular vectors in a tibble
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_svd_u(fa, factors = 1:fa$rank)

get_svd_v(fa, factors = 1:fa$rank)

get_varimax_z(fa, factors = 1:fa$rank)

get_varimax_y(fa, factors = 1:fa$rank)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_svd_u_+3A_fa">fa</code></td>
<td>
<p>A <code><a href="#topic+vsp_fa">vsp_fa()</a></code> object.</p>
</td></tr>
<tr><td><code id="get_svd_u_+3A_factors">factors</code></td>
<td>
<p>The specific columns to index into. The most reliable
option here is to index with an integer vector of column indices,
but you could also use a character vector if columns have been named.
By default returns all factors/singular vectors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with one row for each node, and one column
containing each of the requested factor or singular vector, plus
an additional <code>id</code> column.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>get_svd_v</code>: Get right singular vectors in a tibble
</p>
</li>
<li> <p><code>get_varimax_z</code>: Get varimax Y factors in a tibble
</p>
</li>
<li> <p><code>get_varimax_y</code>: Get varimax Z factors in a tibble
</p>
</li></ul>

<hr>
<h2 id='get_z_hubs'>Get most important hubs for each Z factor</h2><span id='topic+get_z_hubs'></span><span id='topic+get_y_hubs'></span>

<h3>Description</h3>

<p>Get most important hubs for each Z factor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_z_hubs(fa, hubs_per_factor = 10, factors = 1:fa$rank)

get_y_hubs(fa, hubs_per_factor = 10, factors = 1:fa$rank)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_z_hubs_+3A_fa">fa</code></td>
<td>
<p>A <code><a href="#topic+vsp_fa">vsp_fa()</a></code> object.</p>
</td></tr>
<tr><td><code id="get_z_hubs_+3A_hubs_per_factor">hubs_per_factor</code></td>
<td>
<p>The number of important nodes to get per
latent factor. Defaults to <code>10</code>.</p>
</td></tr>
<tr><td><code id="get_z_hubs_+3A_factors">factors</code></td>
<td>
<p>The specific columns to index into. The most reliable
option here is to index with an integer vector of column indices,
but you could also use a character vector if columns have been named.
By default returns all factors/singular vectors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> where each row corresponds to a single
hub, and three columns:
</p>

<ul>
<li> <p><code>id</code>: Node id of hub node
</p>
</li>
<li> <p><code>factor</code>: Which factor that node is a hub for. Nodes can be hubs
of multiple factors.
</p>
</li>
<li> <p><code>loading</code>: The actual value of the hubs factor loading for that factor.
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>get_y_hubs</code>: Get most important hubs for each Y factor
</p>
</li></ul>

<hr>
<h2 id='make_skew_positive'>Make factors columnwise skew positive</h2><span id='topic+make_skew_positive'></span>

<h3>Description</h3>

<p>Given a factor analysis like object, flip
signs so that columns of <code>Z</code> and <code>Y</code> are
skew positive. Note that this also causes
corresponding sign flips in <code>B</code>. This
helps with interpretability of factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_skew_positive(fa)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_skew_positive_+3A_fa">fa</code></td>
<td>
<p>A <code><a href="LRMF3.html#topic+fa_like">fa_like()</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new <code><a href="LRMF3.html#topic+fa_like">fa_like()</a></code> object where the columns
of <code>Z</code> and <code>Y</code> has positive skew, that is otherwise
equivalent to the original object.
</p>

<hr>
<h2 id='plot_ipr_pairs'>Plot pairs of inverse participation ratios for singular vectors</h2><span id='topic+plot_ipr_pairs'></span>

<h3>Description</h3>

<p>When IPR for a given singular vector is O(1) rather than O(1 / sqrt(n)),
this can indicate that the singular vector is localizing on a small
subset of nodes. Oftentimes this localization indicates overfitting.
If you see IPR values that are not close to zero (where &quot;close to zero&quot;
is something you sort of have to pick up over time), then you need
to some further investigation to see if you have localization and that
localization corresponds to overfitting. Note, however, that not all
localization is overfitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_ipr_pairs(fa)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_ipr_pairs_+3A_fa">fa</code></td>
<td>
<p>A <code><a href="#topic+vsp_fa">vsp_fa()</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with one row for each node, and one column
containing each of the requested factor or singular vector, plus
an additional <code>id</code> column.
</p>

<hr>
<h2 id='plot_mixing_matrix'>Plot the mixing matrix B</h2><span id='topic+plot_mixing_matrix'></span>

<h3>Description</h3>

<p>Plot the mixing matrix B
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_mixing_matrix(fa)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_mixing_matrix_+3A_fa">fa</code></td>
<td>
<p>A <code><a href="#topic+vsp_fa">vsp_fa()</a></code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with one row for each node, and one column
containing each of the requested factor or singular vector, plus
an additional <code>id</code> column.
</p>

<hr>
<h2 id='plot_varimax_z_pairs'>Create a pairs plot of select Y factors</h2><span id='topic+plot_varimax_z_pairs'></span><span id='topic+plot_varimax_y_pairs'></span><span id='topic+plot_svd_u'></span><span id='topic+plot_svd_v'></span>

<h3>Description</h3>

<p>To avoid overplotting, plots data for a maximum of 1000 nodes. If there
are more than 1000 nodes, samples 1000 nodes randomly proportional to
row norms (i.e. nodes with embeddings larger in magniture are more likely
to be sampled).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_varimax_z_pairs(fa, factors = 1:min(5, fa$rank), ...)

plot_varimax_y_pairs(fa, factors = 1:min(5, fa$rank), ...)

plot_svd_u(fa, factors = 1:min(5, fa$rank))

plot_svd_v(fa, factors = 1:min(5, fa$rank))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_varimax_z_pairs_+3A_fa">fa</code></td>
<td>
<p>A <code><a href="#topic+vsp_fa">vsp_fa()</a></code> object.</p>
</td></tr>
<tr><td><code id="plot_varimax_z_pairs_+3A_factors">factors</code></td>
<td>
<p>The specific columns to index into. The most reliable
option here is to index with an integer vector of column indices,
but you could also use a character vector if columns have been named.
By default returns all factors/singular vectors.</p>
</td></tr>
<tr><td><code id="plot_varimax_z_pairs_+3A_...">...</code></td>
<td>

<p>Arguments passed on to <code><a href="GGally.html#topic+ggpairs">GGally::ggpairs</a></code>
</p>

<dl>
<dt><code>data</code></dt><dd><p>data set using.  Can have both numerical and categorical data.</p>
</dd>
<dt><code>mapping</code></dt><dd><p>aesthetic mapping (besides <code>x</code> and <code>y</code>).  See <code><a href="ggplot2.html#topic+aes">aes</a>()</code>.  If <code>mapping</code> is numeric, <code>columns</code> will be set to the <code>mapping</code> value and <code>mapping</code> will be set to <code>NULL</code>.</p>
</dd>
<dt><code>columns</code></dt><dd><p>which columns are used to make plots.  Defaults to all columns.</p>
</dd>
<dt><code>title</code></dt><dd><p>title, x label, and y label for the graph</p>
</dd>
<dt><code>xlab</code></dt><dd><p>title, x label, and y label for the graph</p>
</dd>
<dt><code>ylab</code></dt><dd><p>title, x label, and y label for the graph</p>
</dd>
<dt><code>upper</code></dt><dd><p>see Details</p>
</dd>
<dt><code>lower</code></dt><dd><p>see Details</p>
</dd>
<dt><code>diag</code></dt><dd><p>see Details</p>
</dd>
<dt><code>params</code></dt><dd><p>deprecated.  Please see <code><a href="GGally.html#topic+wrap_fn_with_param_arg">wrap_fn_with_param_arg</a></code></p>
</dd>
<dt><code>axisLabels</code></dt><dd><p>either &quot;show&quot; to display axisLabels, &quot;internal&quot; for labels in the diagonal plots, or &quot;none&quot; for no axis labels</p>
</dd>
<dt><code>columnLabels</code></dt><dd><p>label names to be displayed.  Defaults to names of columns being used.</p>
</dd>
<dt><code>labeller</code></dt><dd><p>labeller for facets. See <code><a href="ggplot2.html#topic+labellers">labellers</a></code>. Common values are <code>"label_value"</code> (default) and <code>"label_parsed"</code>.</p>
</dd>
<dt><code>switch</code></dt><dd><p>switch parameter for facet_grid. See <code>ggplot2::<a href="ggplot2.html#topic+facet_grid">facet_grid</a></code>.  By default, the labels are displayed on the top and right of the plot. If <code>"x"</code>, the top labels will be displayed to the bottom. If <code>"y"</code>, the right-hand side labels will be displayed to the left. Can also be set to <code>"both"</code></p>
</dd>
<dt><code>showStrips</code></dt><dd><p>boolean to determine if each plot's strips should be displayed. <code>NULL</code> will default to the top and right side plots only. <code>TRUE</code> or <code>FALSE</code> will turn all strips on or off respectively.</p>
</dd>
<dt><code>legend</code></dt><dd><p>May be the two objects described below or the default <code>NULL</code> value.  The legend position can be moved by using ggplot2's theme element <code>pm + theme(legend.position = "bottom")</code> </p>
<dl>
<dt>a numeric vector of length 2</dt><dd><p>provides the location of the plot to use the legend for the plot matrix's legend. Such as <code>legend = c(3,5)</code> which will use the legend from the plot in the third row and fifth column</p>
</dd><dt>a single numeric value</dt><dd><p>provides the location of a plot according to the display order. Such as <code>legend = 3</code> in a plot matrix with 2 rows and 5 columns displayed by column will return the plot in position <code>c(1,2)</code></p>
</dd><dt>a object from <code><a href="GGally.html#topic+grab_legend">grab_legend</a>()</code></dt><dd><p>a predetermined plot legend that will be displayed directly</p>
</dd></dl>
</dd>
<dt><code>cardinality_threshold</code></dt><dd><p>maximum number of levels allowed in a character / factor column.  Set this value to NULL to not check factor columns. Defaults to 15</p>
</dd>
<dt><code>progress</code></dt><dd><p><code>NULL</code> (default) for a progress bar in interactive sessions with more than 15 plots, <code>TRUE</code> for a progress bar, <code>FALSE</code> for no progress bar, or a function that accepts at least a plot matrix and returns a new <code>progress::<a href="progress.html#topic+progress_bar">progress_bar</a></code>.  See <code><a href="GGally.html#topic+ggmatrix_progress">ggmatrix_progress</a></code>.</p>
</dd>
<dt><code>proportions</code></dt><dd><p>Value to change how much area is given for each plot. Either <code>NULL</code> (default), numeric value matching respective length, <code>grid::<a href="grid.html#topic+unit">unit</a></code> object with matching respective length or <code>"auto"</code> for automatic relative proportions based on the number of levels for categorical variables.</p>
</dd>
<dt><code>legends</code></dt><dd><p>deprecated</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code> plot or <code><a href="GGally.html#topic+ggpairs">GGally::ggpairs()</a></code> plot.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>plot_varimax_y_pairs</code>: Create a pairs plot of select Z factors
</p>
</li>
<li> <p><code>plot_svd_u</code>: Create a pairs plot of select left singular vectors
</p>
</li>
<li> <p><code>plot_svd_v</code>: Create a pairs plot of select right singular vectors
</p>
</li></ul>

<hr>
<h2 id='safe_row_l2_normalize'>Safe L2 row normalization</h2><span id='topic+safe_row_l2_normalize'></span>

<h3>Description</h3>

<p>Helper function for Kaiser normalization to handle rows with zero (or
numerically zero) norm, which results in a divide by zero error
in the <code>stats::varimax()</code> implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>safe_row_l2_normalize(x, eps = 1e-10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="safe_row_l2_normalize_+3A_x">x</code></td>
<td>
<p>A matrix to row normalize.</p>
</td></tr>
<tr><td><code id="safe_row_l2_normalize_+3A_eps">eps</code></td>
<td>
<p>Tolerance to use when assessing if squared L2 row norm is
numerically larger or smaller than zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The row-rescaled matrix
</p>

<hr>
<h2 id='screeplot.vsp_fa'>Create a screeplot from a factor analysis object</h2><span id='topic+screeplot.vsp_fa'></span>

<h3>Description</h3>

<p>Create a screeplot from a factor analysis object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vsp_fa'
screeplot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="screeplot.vsp_fa_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+vsp_fa">vsp_fa()</a></code> object.</p>
</td></tr>
<tr><td><code id="screeplot.vsp_fa_+3A_...">...</code></td>
<td>
<p>Ignored, included only for consistency with S3 generic.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="tibble.html#topic+tibble">tibble::tibble()</a></code> with one row for each node, and one column
containing each of the requested factor or singular vector, plus
an additional <code>id</code> column.
</p>

<hr>
<h2 id='set_z_factor_names'>Give the dimensions of Z factors informative names</h2><span id='topic+set_z_factor_names'></span><span id='topic+set_y_factor_names'></span>

<h3>Description</h3>

<p>Give the dimensions of Z factors informative names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_z_factor_names(fa, names)

set_y_factor_names(fa, names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_z_factor_names_+3A_fa">fa</code></td>
<td>
<p>A <code><a href="#topic+vsp_fa">vsp_fa()</a></code> object.</p>
</td></tr>
<tr><td><code id="set_z_factor_names_+3A_names">names</code></td>
<td>
<p>Describe new names for Z/Y factors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new <code><a href="#topic+vsp_fa">vsp_fa()</a></code> object, but the columns names of <code>Z</code> and the
row names of <code>B</code> have been set to <code>names</code> (for <code>set_z_factor_names</code>),
and the column names of <code>B</code> and the column names of <code>Y</code> have been
set to <code>names</code> (for <code>set_y_factor_names</code>).
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>set_y_factor_names</code>: Give the dimensions of Y factors informative names
</p>
</li></ul>

<hr>
<h2 id='vsp'>Semi-Parametric Factor Analysis via Vintage Sparse PCA</h2><span id='topic+vsp'></span><span id='topic+vsp.default'></span><span id='topic+vsp.matrix'></span><span id='topic+vsp.Matrix'></span><span id='topic+vsp.dgCMatrix'></span><span id='topic+vsp.igraph'></span>

<h3>Description</h3>

<p>This code implements TODO.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vsp(x, rank, ...)

## Default S3 method:
vsp(x, rank, ...)

## S3 method for class 'matrix'
vsp(
  x,
  rank,
  ...,
  center = FALSE,
  recenter = FALSE,
  degree_normalize = TRUE,
  renormalize = FALSE,
  tau_row = NULL,
  tau_col = NULL,
  kaiser_normalize_u = FALSE,
  kaiser_normalize_v = FALSE,
  rownames = NULL,
  colnames = NULL
)

## S3 method for class 'Matrix'
vsp(
  x,
  rank,
  ...,
  center = FALSE,
  recenter = FALSE,
  degree_normalize = TRUE,
  renormalize = FALSE,
  tau_row = NULL,
  tau_col = NULL,
  kaiser_normalize_u = FALSE,
  kaiser_normalize_v = FALSE,
  rownames = NULL,
  colnames = NULL
)

## S3 method for class 'dgCMatrix'
vsp(
  x,
  rank,
  ...,
  center = FALSE,
  recenter = FALSE,
  degree_normalize = TRUE,
  renormalize = FALSE,
  tau_row = NULL,
  tau_col = NULL,
  kaiser_normalize_u = FALSE,
  kaiser_normalize_v = FALSE,
  rownames = NULL,
  colnames = NULL
)

## S3 method for class 'igraph'
vsp(x, rank, ..., edge_weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vsp_+3A_x">x</code></td>
<td>
<p>Either a graph adjacency matrix, <a href="igraph.html#topic+aaa-igraph-package">igraph::igraph</a> or
<a href="tidygraph.html#topic+tbl_graph">tidygraph::tbl_graph</a>. If <code>x</code> is a <a href="base.html#topic+matrix">matrix</a> or <a href="Matrix.html#topic+Matrix">Matrix::Matrix</a>
then <code>x[i, j]</code> should correspond to the edge going from node <code>i</code>
to node <code>j</code>.</p>
</td></tr>
<tr><td><code id="vsp_+3A_rank">rank</code></td>
<td>
<p>The number of factors to calculate.</p>
</td></tr>
<tr><td><code id="vsp_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="vsp_+3A_center">center</code></td>
<td>
<p>Should the adjacency matrix be row <em>and</em> column centered?
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="vsp_+3A_recenter">recenter</code></td>
<td>
<p>Should the varimax factors be re-centered around the
original factor means? Only used when <code>center = TRUE</code>, defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="vsp_+3A_degree_normalize">degree_normalize</code></td>
<td>
<p>Should the regularized graph laplacian be used instead of the
raw adjacency matrix? Defaults to <code>TRUE</code>. If <code>center = TRUE</code>, <code>A</code> will
first be centered and then normalized.</p>
</td></tr>
<tr><td><code id="vsp_+3A_renormalize">renormalize</code></td>
<td>
<p>Should the regularized graph laplacian be used instead of the
raw adjacency matrix? Defaults to <code>TRUE</code>. If <code>center = TRUE</code>, <code>A</code> will
first be centered and then normalized.</p>
</td></tr>
<tr><td><code id="vsp_+3A_tau_row">tau_row</code></td>
<td>
<p>Row regularization term. Default is <code>NULL</code>, in which case
we use the row degree. Ignored when <code>degree_normalize = FALSE</code>.</p>
</td></tr>
<tr><td><code id="vsp_+3A_tau_col">tau_col</code></td>
<td>
<p>Column regularization term. Default is <code>NULL</code>, in which case
we use the column degree. Ignored when <code>degree_normalize = FALSE</code>.</p>
</td></tr>
<tr><td><code id="vsp_+3A_kaiser_normalize_u">kaiser_normalize_u</code></td>
<td>
<p>Whether or not to use Kaiser normalization
when rotating the left singular vectors <code>U</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="vsp_+3A_kaiser_normalize_v">kaiser_normalize_v</code></td>
<td>
<p>Whether or not to use Kaiser normalization
when rotating the right singular vectors <code>V</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="vsp_+3A_rownames">rownames</code></td>
<td>
<p>Character vector of row names of <code>x</code>. These row names
are propagated into the row names of the <code>U</code> and <code>Z</code>. Defaults
to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="vsp_+3A_colnames">colnames</code></td>
<td>
<p>Character vector of column names of <code>x</code>. These column names
are propagated into the row names of the <code>V</code> and <code>Y</code>. Defaults
to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="vsp_+3A_edge_weights">edge_weights</code></td>
<td>
<p>When <code>x</code> is an <a href="igraph.html#topic+aaa-igraph-package">igraph::igraph</a>, an edge attribute
to use to form a weighted adjacency matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sparse SVDs use <code>RSpectra</code> for performance.
</p>


<h3>Value</h3>

<p>An object of class <code>vsp</code>. TODO: Details
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(LRMF3)

vsp(ml100k, rank = 2)

</code></pre>

<hr>
<h2 id='vsp_fa'>Create a vintage sparse factor analysis object</h2><span id='topic+vsp_fa'></span>

<h3>Description</h3>

<p><code>vsp_fa</code> objects are a subclass of <code><a href="LRMF3.html#topic+fa_like">LRMF3::fa_like()</a></code>, with additional
fields <code>u</code>, <code>d</code>, <code>v</code>, <code>transformers</code>, <code>R_U</code>, and <code>R_V</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vsp_fa(
  u,
  d,
  v,
  Z,
  B,
  Y,
  transformers,
  R_U,
  R_V,
  rownames = NULL,
  colnames = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vsp_fa_+3A_u">u</code></td>
<td>
<p>A <code><a href="base.html#topic+matrix">matrix()</a></code> of &quot;left singular-ish&quot; vectors.</p>
</td></tr>
<tr><td><code id="vsp_fa_+3A_d">d</code></td>
<td>
<p>A <code><a href="base.html#topic+numeric">numeric()</a></code> vector of &quot;singular-ish&quot; values.</p>
</td></tr>
<tr><td><code id="vsp_fa_+3A_v">v</code></td>
<td>
<p>A <code><a href="base.html#topic+matrix">matrix()</a></code> of &quot;right singular-ish&quot; vectors.</p>
</td></tr>
<tr><td><code id="vsp_fa_+3A_z">Z</code></td>
<td>
<p>A <em>matrix</em> of embeddings for each observation.</p>
</td></tr>
<tr><td><code id="vsp_fa_+3A_b">B</code></td>
<td>
<p>A mixing <em>matrix</em> describing how observation embeddings
and topics interact. Does not have to be diagonal!</p>
</td></tr>
<tr><td><code id="vsp_fa_+3A_y">Y</code></td>
<td>
<p>A <em>matrix</em> describing the compositions of various topics
or factors.</p>
</td></tr>
<tr><td><code id="vsp_fa_+3A_transformers">transformers</code></td>
<td>
<p>A list of transformatioms from the <a href="invertiforms.html#topic+invertiforms">invertiforms</a>
package.</p>
</td></tr>
<tr><td><code id="vsp_fa_+3A_r_u">R_U</code></td>
<td>
<p>Varimax rotation matrix use to transform <code>u</code> into <code>Z</code>.</p>
</td></tr>
<tr><td><code id="vsp_fa_+3A_r_v">R_V</code></td>
<td>
<p>Varimax rotation matrix use to transform <code>v</code> into <code>Y</code>.</p>
</td></tr>
<tr><td><code id="vsp_fa_+3A_rownames">rownames</code></td>
<td>
<p>Identifying names for each row of the original
data. Defaults to <code>NULL</code>, in which cases each row is given a
row number left-padded with zeros as a name.</p>
</td></tr>
<tr><td><code id="vsp_fa_+3A_colnames">colnames</code></td>
<td>
<p>Identifying names for each column of the original
data. Defaults to <code>NULL</code>, in which cases each column is given a
row column left-padded with zeros as a name.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>svd_fa</code> object.
</p>

<hr>
<h2 id='vsp.svd_like'>Perform varimax rotation on a low rank matrix factorization</h2><span id='topic+vsp.svd_like'></span>

<h3>Description</h3>

<p>Perform varimax rotation on a low rank matrix factorization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'svd_like'
vsp(
  x,
  rank,
  ...,
  centerer = NULL,
  scaler = NULL,
  recenter = FALSE,
  renormalize = FALSE,
  kaiser_normalize_u = FALSE,
  kaiser_normalize_v = FALSE,
  rownames = NULL,
  colnames = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vsp.svd_like_+3A_x">x</code></td>
<td>
<p>Either a graph adjacency matrix, <a href="igraph.html#topic+aaa-igraph-package">igraph::igraph</a> or
<a href="tidygraph.html#topic+tbl_graph">tidygraph::tbl_graph</a>. If <code>x</code> is a <a href="base.html#topic+matrix">matrix</a> or <a href="Matrix.html#topic+Matrix">Matrix::Matrix</a>
then <code>x[i, j]</code> should correspond to the edge going from node <code>i</code>
to node <code>j</code>.</p>
</td></tr>
<tr><td><code id="vsp.svd_like_+3A_rank">rank</code></td>
<td>
<p>The number of factors to calculate.</p>
</td></tr>
<tr><td><code id="vsp.svd_like_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="vsp.svd_like_+3A_centerer">centerer</code></td>
<td>
<p>TODO</p>
</td></tr>
<tr><td><code id="vsp.svd_like_+3A_scaler">scaler</code></td>
<td>
<p>TODO</p>
</td></tr>
<tr><td><code id="vsp.svd_like_+3A_recenter">recenter</code></td>
<td>
<p>Should the varimax factors be re-centered around the
original factor means? Only used when <code>center = TRUE</code>, defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="vsp.svd_like_+3A_renormalize">renormalize</code></td>
<td>
<p>Should the regularized graph laplacian be used instead of the
raw adjacency matrix? Defaults to <code>TRUE</code>. If <code>center = TRUE</code>, <code>A</code> will
first be centered and then normalized.</p>
</td></tr>
<tr><td><code id="vsp.svd_like_+3A_kaiser_normalize_u">kaiser_normalize_u</code></td>
<td>
<p>Whether or not to use Kaiser normalization
when rotating the left singular vectors <code>U</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="vsp.svd_like_+3A_kaiser_normalize_v">kaiser_normalize_v</code></td>
<td>
<p>Whether or not to use Kaiser normalization
when rotating the right singular vectors <code>V</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="vsp.svd_like_+3A_rownames">rownames</code></td>
<td>
<p>Character vector of row names of <code>x</code>. These row names
are propagated into the row names of the <code>U</code> and <code>Z</code>. Defaults
to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="vsp.svd_like_+3A_colnames">colnames</code></td>
<td>
<p>Character vector of column names of <code>x</code>. These column names
are propagated into the row names of the <code>V</code> and <code>Y</code>. Defaults
to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(LRMF3)
library(RSpectra)

s &lt;- svds(ml100k, k = 2)
mf &lt;- as_svd_like(s)
fa &lt;- vsp(mf, rank = 2)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
