<!DOCTYPE html><html><head><title>Help for package goeveg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {goeveg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#clean_matrix'><p>Clean species matrix</p></a></li>
<li><a href='#cov2per'><p>Conversion between cover-abundance codes and percentage cover</p></a></li>
<li><a href='#cv'><p>Coefficient of variation (CV)</p></a></li>
<li><a href='#deg2rad'><p>Conversion between degrees and radians</p></a></li>
<li><a href='#merge_taxa'><p>Merge taxa with identical names</p></a></li>
<li><a href='#ordiselect'><p>Species selection for ordination plots</p></a></li>
<li><a href='#racurve'><p>Rank-abundance curves</p></a></li>
<li><a href='#racurves'><p>Multiple rank-abundance curves</p></a></li>
<li><a href='#scale_tabs'><p>Conversion tables for cover-abundance scales</p></a></li>
<li><a href='#schedenenv'><p>Header data for Vegetation releves from Scheden</p></a></li>
<li><a href='#schedenveg'><p>Vegetation releves from Scheden</p></a></li>
<li><a href='#screeplot_NMDS'><p>Scree plot/Stress plot for NMDS</p></a></li>
<li><a href='#sem'><p>Standard error of the mean (SEM)</p></a></li>
<li><a href='#specresponse'><p>Species response curves</p></a></li>
<li><a href='#synsort'><p>Sorting functions for synoptic tables</p></a></li>
<li><a href='#syntable'><p>Synoptic tables and calculation of cluster-wise frequencies, fidelity and</p>
differential species character</a></li>
<li><a href='#trans_matrix'><p>Transpose species matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Functions for Community Data and Ordinations</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-05-17</td>
</tr>
<tr>
<td>Author:</td>
<td>Friedemann von Lampe [aut, cre],
  Jenny Schellenberg [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Friedemann von Lampe &lt;fvonlampe@uni-goettingen.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of functions useful in (vegetation) community analyses and ordinations. Includes automatic species selection for ordination diagrams, NMDS stress/scree plots, species response curves, merging of taxa as well as calculation and sorting of synoptic tables.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>vegan, fields, mgcv, Hmisc</td>
</tr>
<tr>
<td>Suggests:</td>
<td>vegdata, BiodiversityR, cluster</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/fvlampe/goeveg/">https://github.com/fvlampe/goeveg/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/fvlampe/goeveg/issues">https://github.com/fvlampe/goeveg/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-17 08:35:02 UTC; Friedemann von Lampe</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-17 08:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='clean_matrix'>Clean species matrix</h2><span id='topic+clean_matrix'></span>

<h3>Description</h3>

<p>The function cleans a species matrix by removing species without occurrence (frequency = 0) and samples without any species (species number = 0) in one step.
</p>
<p>It will also subset the corresponding observations of environmental data (samples in rows) or species trait data (species in rows), if passed to the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_matrix(matrix, env = NULL, traits = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_matrix_+3A_matrix">matrix</code></td>
<td>
<p>Community data, a matrix-like object with samples in rows and species in columns. Missing values (NA) or empty character cell values will be transformed to 0.</p>
</td></tr>
<tr><td><code id="clean_matrix_+3A_env">env</code></td>
<td>
<p>Optionally, a data frame of environmental variables, with samples in rows and variables in columns</p>
</td></tr>
<tr><td><code id="clean_matrix_+3A_traits">traits</code></td>
<td>
<p>Optionally, a data frame of species traits, with species in rows and trait variables in columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If only a species matrix is provided, the return will be a cleaned species matrix. 
If environmental and/or trait data are also provided, the result will be a list of the cleaned and subsetted matrices/data frames.
</p>


<h3>Author(s)</h3>

<p>Friedemann von Lampe (<a href="mailto:fvonlampe@uni-goettingen.de">fvonlampe@uni-goettingen.de</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Clean species matrix
schedenveg.clean &lt;- clean_matrix(schedenveg)

# Clean species matrix and subset environmental data
scheden.clean &lt;- clean_matrix(schedenveg, schedenenv)
schedenveg.clean &lt;- scheden.clean$matrix
schedenenv.clean &lt;- scheden.clean$env

</code></pre>

<hr>
<h2 id='cov2per'>Conversion between cover-abundance codes and percentage cover</h2><span id='topic+cov2per'></span><span id='topic+per2cov'></span>

<h3>Description</h3>

<p>These functions perform a conversion between cover-abundance codes from different survey scales and percentage cover. They can be applied on a matrix-like object or a single vector.
</p>
<p><code>cov2per</code> performs conversion from cover-abundance to percentage values
</p>
<p><code>per2cov</code> performs conversion from percentage to cover-abundance values
</p>
<p>You may chose between a set of scales with pre-defined conversion values, in <code><a href="#topic+scale_tabs">scale_tabs</a></code> or define your own conversion table following the same format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov2per(matrix, scale = "braun.blanquet", multiscale = FALSE)

per2cov(matrix, scale = "braun.blanquet", multiscale = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cov2per_+3A_matrix">matrix</code></td>
<td>
<p>Community data, a vector or matrix-like object with cover-abundance values</p>
</td></tr>
<tr><td><code id="cov2per_+3A_scale">scale</code></td>
<td>
<p>Cover-abundance scale (from <code><a href="#topic+scale_tabs">scale_tabs</a></code>) or dataframe with custom conversion table following the same format.</p>
</td></tr>
<tr><td><code id="cov2per_+3A_multiscale">multiscale</code></td>
<td>
<p>A logical evaluation to <code>FALSE</code> <em>(default)</em> or <code>TRUE</code> indicating whether individual scales per sample should be used. For individual scales, you must provide a vector of the same length as the number of samples to the <code>scale</code> argument, defining the scale (from <code><a href="#topic+scale_tabs">scale_tabs</a></code>) for each sample (with samples as rows in matrix).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe or vector containing the transformed data
</p>


<h3>Details</h3>

<p>If scales are not only cover-based but also abundance-based (e.g. Braun-Blanquet, Kohler) there are often no unique definitions about their conversion
into percentage cover. Therefore it is necessary to define and give reference to the applied conversion table.
</p>
<p>Cover-abundance codes are transformed into the mean percentage cover of their class.
For the conversion of percentage cover to cover-abundance codes, all values between the lower and upper border of the class are transformed into the corresponding code.
</p>
<p>The included cover-abundance scales and the associated conversion tables with references are explained in <code><a href="#topic+scale_tabs">scale_tabs</a></code>. On this site you also find definitions for defining a custom table.
</p>


<h3>Author(s)</h3>

<p>Friedemann von Lampe (<a href="mailto:fvonlampe@uni-goettingen.de">fvonlampe@uni-goettingen.de</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scale_tabs">scale_tabs</a></code> for explanation and references of included conversion tables
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Conversion of species matrix with percentage cover to Braun-Blanquet values
schedenveg.bb &lt;- per2cov(schedenveg)

## Conversion of only 10 samples to Londo values
schedenveg.londo &lt;- per2cov(schedenveg[, 1:10], scale = "londo")

## Conversion of species matrix with Braun-Blanquet values to percentage cover
schedenveg.per &lt;- cov2per(schedenveg.bb)

</code></pre>

<hr>
<h2 id='cv'>Coefficient of variation (CV)</h2><span id='topic+cv'></span>

<h3>Description</h3>

<p>Compute the coefficient of variation (CV). The CV, also known as relative standard deviation (RSD), is a standardized measure of dispersion of a probability distribution or frequency distribution.
It is defined as the ratio of the standard deviation to the mean and is often expressed as a percentage.
In contrast to the standard deviation, it enables comparison between datasets as the CV is independent of the unit in which the measurement has been taken.
If <code>na.rm</code> is <code>TRUE</code> then missing values are removed before computation proceeds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv(x, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="cv_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Should missing values be removed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric scalar &ndash; the sample coefficient of variation.
</p>


<h3>Details</h3>

<p>The coefficient of variation (CV) should be computed only for data measured on a ratio scale (i.e. data with an absolute zero). The CV may not have any meaning for data on an interval scale.
</p>
<p>According to <cite>Dormann 2017</cite> CV-values below 0.05 (5%) indicate very high precision of the data, values above 0.2 (20%) low precision.
However, this is considered as a rule of thumb. In studies of highly variable systems (e.g. some ecological studies) CV values above 1 may occur.
</p>
<p>The CV of a zero-length vector (after removal of <code>NA</code>s if <code>na.rm = TRUE</code>) is not defined and gives an error.
If there is only a single value, <code>sd</code> is <code>NA</code> and <code>cv</code> returns <code>NA</code>.
</p>


<h3>References</h3>

<p>Dormann, C. (2017). Parametrische Statistik. Verteilungen, maximum likelihood und GLM in R. <em>Springer</em>. <a href="https://doi.org/10.1007/978-3-662-54684-0">doi:10.1007/978-3-662-54684-0</a>
</p>
<p>Frost, J. (2023). Coefficient of variation in statistics. Statistics by Jim. <a href="https://statisticsbyjim.com/basics/coefficient-variation/">https://statisticsbyjim.com/basics/coefficient-variation/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+sd">sd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Calculate CV for variable soil depth
cv(schedenenv$soil_depth)
</code></pre>

<hr>
<h2 id='deg2rad'>Conversion between degrees and radians</h2><span id='topic+deg2rad'></span><span id='topic+rad2deg'></span>

<h3>Description</h3>

<p><code>deg2rad</code> performs conversion from degrees to radians.
</p>
<p><code>rad2deg</code> performs conversion from radians to degrees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deg2rad(x)

rad2deg(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deg2rad_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector the same length as <code>x</code>
</p>


<h3>Details</h3>

<p>Radians and degrees are both units used for measuring angles.
</p>
<p>A degree is a measure of angle equal to 1/360th of a revolution, or circle.
A radian is the measurement of angle equal to the length of an arc divided by the radius of the circle or arc.
A circle is comprised of 2*pi radians, which is the equivalent of 360 degrees.
</p>
<p>A common application in ecological studies is the conversion of measured exposition (in degrees) of plots into statistically meaningful measures, such as the north value or the east value.
For this, the cosine (for northness) or sine (for eastness) is applied to the radian of the exposition.
</p>


<h3>References</h3>

<p>BIPM (2019): The International System of Units (SI). Bureau international des poids et mesures, ninth edition. <a href="https://www.bipm.org/en/publications/si-brochure">https://www.bipm.org/en/publications/si-brochure</a>, ISBN 978-92-822-2272-0
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Covert the value pi to degrees
rad2deg(pi)

# Calculate north and east values based on exposition measured in degrees
north &lt;- cos(deg2rad(schedenenv$exp))
east &lt;- sin(deg2rad(schedenenv$exp))


</code></pre>

<hr>
<h2 id='merge_taxa'>Merge taxa with identical names</h2><span id='topic+merge_taxa'></span>

<h3>Description</h3>

<p>The function offers a simple way to merge taxa with identical names in a vegetation table, e.g. due to necessary harmonization of the taxon level, to combine taxa of different layers or to remove duplicates.
The original cover-abundance scales are maintained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_taxa(
  vegtable,
  scale = "percentage",
  layers = "FALSE",
  method = "independent",
  clean_matrix = FALSE,
  backtransform = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_taxa_+3A_vegtable">vegtable</code></td>
<td>
<p>Data frame with samples in columns and taxa in rows. Taxon names must be in the first column.</p>
</td></tr>
<tr><td><code id="merge_taxa_+3A_scale">scale</code></td>
<td>
<p>Cover-abundance scale(s) of data. Default is percentage cover (values between 0 and 100) (<code>"percentage"</code>). Alternatively it can be one of the included scales in <code><a href="#topic+scale_tabs">scale_tabs</a></code> (e.g. <code>"braun.blanquet"</code>) or a custom scale defined as data frame following the same format.
You can also provide a vector of the same length as the number of samples, to define individual scales (from <code><a href="#topic+scale_tabs">scale_tabs</a></code>) for each sample.</p>
</td></tr>
<tr><td><code id="merge_taxa_+3A_layers">layers</code></td>
<td>
<p>A logical evaluation to <code>TRUE</code> or <code>FALSE</code> <em>(default)</em> indicating whether vegetation layers are to be included with layer information stored in the second column.</p>
</td></tr>
<tr><td><code id="merge_taxa_+3A_method">method</code></td>
<td>
<p>Choice of method to combine cover. <code>"independent"</code> <em>(default)</em> or <code>"exclusive"</code>. See details for methods.</p>
</td></tr>
<tr><td><code id="merge_taxa_+3A_clean_matrix">clean_matrix</code></td>
<td>
<p>A logical evaluation to <code>TRUE</code> or <code>FALSE</code> <em>(default)</em> indicating whether taxa that do not occur (i.e. sum of abundances is zero) or samples that are empty (i.e. do not have any taxa present) are to be removed.</p>
</td></tr>
<tr><td><code id="merge_taxa_+3A_backtransform">backtransform</code></td>
<td>
<p>A logical evaluation to <code>TRUE</code> <em>(default)</em> or <code>FALSE</code> indicating whether cover-abundance values should be back-transformed into their original cover-abundance scale or left as percentage cover.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame based on <code>vegtable</code> with merged taxa.
</p>


<h3>Details</h3>

<p>The format required for this function is a data frame with samples in columns and taxa in rows, which corresponds to the export format of vegetation tables from Turboveg (Hennekens &amp; Schaminee 2001).
Taxon names must be in the first column of the table (not row names as these do not allow duplicates).
If vegetation layers are to be included, layer information must be stored in the second column of the table. Taxa will then be merged only within the defined layers.
</p>
<p>If a cover-abundance scale from <code><a href="#topic+scale_tabs">scale_tabs</a></code> is defined, all cover-abundance values will be transformed into percentage cover for the merging process, and then back-transformed into the original cover-abundance scale.
</p>
<p>When combining cover values there are two possibilities following Fischer (2014) and Tichý &amp; Holt (2011).
</p>

<ul>
<li> <p><code>method = "independent" </code> <em>(default)</em> assumes that covers can overlap and that they do so independently of each other (e.g. individuals of the lower layer are growing beneath individuals of the upper layer).
In case of two layers the sum of the cover of layer 1 and layer 2 is the sum of the covers minus the overlap. ($p1 + p2- p1 * p2)
Usually the choice when merging the same taxon from different (sub-)layers.
</p>
</li>
<li> <p><code>method = "exclusive" </code> assumes the covers are mutually exclusive, cover values will be simply summed up (e.g. individuals grow side by side).
Usually the chouce when merging within layers, e.g. aggregating distinct taxa.
</p>
</li></ul>

<p>Percentage cover values will eventually be truncated to 100
</p>
<p>You may use the function <code><a href="#topic+trans_matrix">trans_matrix</a></code> to easily transpose the resulting vegetation table into a statistically analyzable species matrix.
</p>


<h3>Author(s)</h3>

<p>Friedemann von Lampe (<a href="mailto:fvonlampe@uni-goettingen.de">fvonlampe@uni-goettingen.de</a>)
</p>


<h3>References</h3>

<p>Fischer, H. S. (2015): On the combination of species cover values from different vegetation layers.
<em>Applied Vegetation Science</em>, <strong>18</strong>: 169–170. <a href="https://doi.org/10.1111/avsc.12130">doi:10.1111/avsc.12130</a>
</p>
<p>Tichý, L. &amp; Holt, J. (2011): JUICE. Program for management, analysis and classification of ecological data. Vegetation Science Group, Masaryk University Brno, CZ.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Merge taxa with identical names without any layer information
# Transpose table to required format
schedenveg.t &lt;- data.frame(species = names(schedenveg), t(schedenveg))
# Add two duplicated taxa
schedenveg.t &lt;- rbind(schedenveg.t, schedenveg.t[c(55, 61), ])

# Merge duplicated taxa using default 'independent' method
schedenveg.merged &lt;- merge_taxa(schedenveg.t, scale = "percentage")

</code></pre>

<hr>
<h2 id='ordiselect'>Species selection for ordination plots</h2><span id='topic+ordiselect'></span>

<h3>Description</h3>

<p>This function simplifies the selection of relevant species in ordination diagrams. It works with result objects from the <code>vegan</code> package. The selection can be based upon cover abundances, frequency values and/or species fit to multivariate analysis (see Details).
The result is a vector of names of the selected species and can be used for the <code>select</code> argument in ordination plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordiselect(
  matrix,
  ord,
  ablim = 1,
  fitlim = 1,
  choices = c(1, 2),
  freq = FALSE,
  na.rm = FALSE,
  method = "axes",
  env,
  p.max = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ordiselect_+3A_matrix">matrix</code></td>
<td>
<p>Community data, a matrix-like object with samples in rows and species in columns.</p>
</td></tr>
<tr><td><code id="ordiselect_+3A_ord">ord</code></td>
<td>
<p><code>vegan</code> ordination result object (e.g. from <code><a href="vegan.html#topic+decorana">decorana</a></code>, <code><a href="vegan.html#topic+cca">cca</a></code> or <code><a href="vegan.html#topic+metaMDS">metaMDS</a></code>).</p>
</td></tr>
<tr><td><code id="ordiselect_+3A_ablim">ablim</code></td>
<td>
<p>Proportion of species with highest abundances to be displayed. Value between 0 and 1. Use negative sign for selection of lowest abundances, i.e. rarest species.</p>
</td></tr>
<tr><td><code id="ordiselect_+3A_fitlim">fitlim</code></td>
<td>
<p>Proportion of species with best fit to be displayed. Value between 0 and 1.</p>
</td></tr>
<tr><td><code id="ordiselect_+3A_choices">choices</code></td>
<td>
<p>Axes shown.</p>
</td></tr>
<tr><td><code id="ordiselect_+3A_freq">freq</code></td>
<td>
<p>Whether to use cover abundances (= default) or frequencies of <code>matrix</code>. If <code>TRUE</code>, frequencies of species are used.</p>
</td></tr>
<tr><td><code id="ordiselect_+3A_na.rm">na.rm</code></td>
<td>
<p>Set to <code>TRUE</code> if your ordination object contains NA (e.g. due to selection)</p>
</td></tr>
<tr><td><code id="ordiselect_+3A_method">method</code></td>
<td>
<p>The species fit method: <code>"axes"</code> (= default) or <code>"factors"</code>. See details for methods.</p>
</td></tr>
<tr><td><code id="ordiselect_+3A_env">env</code></td>
<td>
<p>Fitted environmental variables (result object of <code><a href="vegan.html#topic+envfit">envfit</a></code>) for <code>method = "factors"</code>. Only factor variables are used.</p>
</td></tr>
<tr><td><code id="ordiselect_+3A_p.max">p.max</code></td>
<td>
<p>Significance limit for variables used in <code>method = "factors"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of variable length containing the names of selected species from matrix.
</p>


<h3>Details</h3>

<p>Two methods for species fit are implemented.
</p>
<ul>
<li><p> In <code>method = "axes"</code> (default) species scores are used for selecting best fitting species. The basic assumption is that species that show high correlations to ordination axes provide a good fit to the assumed gradients, Hence high scores along ordination axes mean high correlation. All species with highest axis scores, defined by the threshold given in argument <code>fitlim</code>, will be filtered from the total ordination result.
</p>
</li>
<li><p> In <code>method = "factors"</code>, Euclidean distances between species and environmental variable centroids are calculated. Only factor variables are used from <code><a href="vegan.html#topic+envfit">envfit</a></code> output. The species with smallest distances, defined by <code>fitlim</code> argument as a threshold, will be filtered from the ordination result.
The <code>p.max</code> argument allows selection of only significant variables, default is <code>p.max = 0.05</code>.</p>
</li></ul>

<p>The species fit methods work well both in eigenvalue-based and in distance-based ordinations and provide good option of objective reduction of visible species in ordination plot for better interpretation issues.
If axes fit should be applied on distance-based ordination, species scores need to be calculated during the analysis, e.g. by selecting <code>wascores = TRUE</code> in <code><a href="vegan.html#topic+metaMDS">metaMDS</a></code>. It is mostly recommendable to combine the species fit limit with an abundance limit to avoid overinterpretation of rare species.
</p>
<p>For the abundance limit, note that the final proportion of the selected species may be higher than the indicated proportion if there are identical values in the abundances.
For selection of least abundant (rarest) species you can use a negative sign, e.g. <code>ablim = -0.3</code> for the 30 percent least abundant species.
</p>
<p>If both limits are defined only species meeting both conditions are selected.
If no limit is defined for one of the arguments <code>ablim, fitlim</code>, all species are displayed.
</p>
<p>The default for <code>matrix</code> input is a cover-abundance-matrix. This matrix should also be used for ordination.
</p>


<h3>Author(s)</h3>

<p>Friedemann von Lampe (<a href="mailto:fvonlampe@uni-goettingen.de">fvonlampe@uni-goettingen.de</a>) and Jenny Schellenberg
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Calculate DCA
library(vegan)
scheden.dca &lt;- decorana(schedenveg)

## Select the 30% most abundant species and call the result
limited &lt;- ordiselect(schedenveg, scheden.dca, ablim = 0.3)
limited

# Use the result in plotting
plot(scheden.dca, display="n")
points(scheden.dca, display="sites")
points(scheden.dca, display="species",
   select = limited, pch = 3, col = "red", cex = 0.7)
ordipointlabel(scheden.dca, display="species",
    select = limited, col="red", cex = 0.7, add = TRUE)


## Select the 70% of the species with the best fit to the axes (highest species scores)
## AND belonging to the 30% most frequent species
limited &lt;- ordiselect(schedenveg, scheden.dca, ablim = 0.3,
   fitlim = 0.7, freq = TRUE)

## Select the 30% least frequent species and call the result
limited &lt;- ordiselect(schedenveg, scheden.dca, ablim = -0.3, freq = TRUE)
limited

## Select the 20% of species with the best fit to community assignment
## AND belonging to the 50% most abundant
## in NDMS for axes 1 &amp; 3
nmds &lt;- metaMDS(schedenveg, k = 3)   # run NMDS
env13 &lt;- envfit(nmds, schedenenv, choices = c(1, 3))
limited13 &lt;- ordiselect(schedenveg, nmds, method = "factors",
                       fitlim = 0.1, ablim = 1,
                       choices = c(1,3), env = env13)

# Use the result in plotting
plot(nmds, display="sites", choices = c(1, 3))
plot(env13, p.max = 0.05)
points(nmds, display="species", choices = c(1,3),
    select = limited13, pch = 3, col="red", cex=0.7)
ordipointlabel(nmds, display="species", choices = c(1,3),
    select = limited13, col="red", cex=0.7, add = TRUE)

</code></pre>

<hr>
<h2 id='racurve'>Rank-abundance curves</h2><span id='topic+racurve'></span>

<h3>Description</h3>

<p>This function draws a rank-abundance curve for community data. You can optionally add labels for a selected number of species.
If you wish to draw multiple rank-abundance curves for selected samples use <code><a href="#topic+racurves">racurves</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>racurve(
  matrix,
  main = "Rank-abundance diagram",
  nlab = 0,
  ylog = FALSE,
  frequency = FALSE,
  ylim = NULL,
  xlim = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="racurve_+3A_matrix">matrix</code></td>
<td>
<p>Community data, a matrix-like object with samples in rows.</p>
</td></tr>
<tr><td><code id="racurve_+3A_main">main</code></td>
<td>
<p>The main title (optional).</p>
</td></tr>
<tr><td><code id="racurve_+3A_nlab">nlab</code></td>
<td>
<p>Number of labeled species (default = 0). Species are labeled in decreasing order beginning from the highest relative abundance.</p>
</td></tr>
<tr><td><code id="racurve_+3A_ylog">ylog</code></td>
<td>
<p>If set on <code>TRUE</code> the y-axis is displayed on a log-scale.</p>
</td></tr>
<tr><td><code id="racurve_+3A_frequency">frequency</code></td>
<td>
<p>If set on <code>TRUE</code> frequencies of species are calculated instead of relative abundances.</p>
</td></tr>
<tr><td><code id="racurve_+3A_xlim">xlim</code>, <code id="racurve_+3A_ylim">ylim</code></td>
<td>
<p>Define axis limits</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an (invisible) list composed of:
</p>
<table>
<tr><td><code>abund</code></td>
<td>
<p>abundances of each species (in decreasing order)</p>
</td></tr>
<tr><td><code>rel.abund</code></td>
<td>
<p>relative abundances of each species (in decreasing order)</p>
</td></tr>
<tr><td><code>freq</code></td>
<td>
<p>frequency of each species (in decreasing order)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Rank abundance curves or Whittaker plots (see <cite>Whittaker 1965</cite>) are used to display relative species abundance as biodiversity component.
They are a means to visualize species richness and species evenness.
</p>


<h3>Author(s)</h3>

<p>Friedemann von Lampe (<a href="mailto:fvonlampe@uni-goettingen.de">fvonlampe@uni-goettingen.de</a>)
</p>


<h3>References</h3>

<p>Whittaker, R. H. (1965). Dominance and Diversity in Land Plant Communities: Numerical relations of species express the importance of competition in community function and evolution. <em>Science</em> <strong>147 :</strong> 250-260. <a href="https://doi.org/10.1126/science.147.3655.250">doi:10.1126/science.147.3655.250</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+racurves">racurves</a></code> for multiple curves and <code><a href="BiodiversityR.html#topic+rankabundance">rankabundance</a></code> from package <code>BiodiversityR</code> for a more sophisticated function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Draw rank-abundance curve
racurve(schedenveg)

## Draw rank-abundance curve and label first 5 species
racurve(schedenveg, nlab = 5)

## Draw rank-abundance curve with log-scaled axis
racurve(schedenveg, ylog = TRUE)

## Draw rank-abundance curve with frequencies and no main title
racurve(schedenveg, frequency = TRUE, nlab = 1, main = "")
</code></pre>

<hr>
<h2 id='racurves'>Multiple rank-abundance curves</h2><span id='topic+racurves'></span>

<h3>Description</h3>

<p>This function draws multiple rank-abundance curves for selected samples into one diagram.
If you wish to draw a simple rank-abundance curve see <code><a href="#topic+racurve">racurve</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>racurves(matrix, main = "Rank-abundance diagram", bw = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="racurves_+3A_matrix">matrix</code></td>
<td>
<p>Community data, a matrix-like object with samples in rows and species in columns. Rank-abundance curves are drawn for all selected rows (samples).</p>
</td></tr>
<tr><td><code id="racurves_+3A_main">main</code></td>
<td>
<p>The main title (optional).</p>
</td></tr>
<tr><td><code id="racurves_+3A_bw">bw</code></td>
<td>
<p>If set on <code>FALSE</code> the lines will be drawn in colors instead of black/white lines with different line types.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, only diagram.
</p>


<h3>Details</h3>

<p>Rank abundance curves or Whittaker plots (see <cite>Whittaker 1965</cite>) are used to display relative species abundance as biodiversity component.
They are a means to visualize species richness and species evenness.
</p>
<p>The axes of the diagram will be scaled according automatically.
As the line type is used to differentiate between samples, a maximum of 6 curves per diagram is feasible in black/white mode.
</p>


<h3>Author(s)</h3>

<p>Friedemann von Lampe (<a href="mailto:fvonlampe@uni-goettingen.de">fvonlampe@uni-goettingen.de</a>)
</p>


<h3>References</h3>

<p>Whittaker, R. H. (1965). Dominance and Diversity in Land Plant Communities: Numerical relations of species express the importance of competition in community function and evolution. <em>Science</em> <strong>147 :</strong> 250-260. <a href="https://doi.org/10.1126/science.147.3655.250">doi:10.1126/science.147.3655.250</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+racurve">racurve</a></code> for a simple curve and <code><a href="BiodiversityR.html#topic+rankabundance">rankabundance</a></code> from package <code>BiodiversityR</code> for a more sophisticated function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Draw multiple rank-abundance curves for selected samples
racurves(schedenveg[c(1,7,20,25), ])

## Draw multiple rank-abundance curves for selected samples with coloured lines
racurves(schedenveg[c(1,7,20,25), ], bw = FALSE)
</code></pre>

<hr>
<h2 id='scale_tabs'>Conversion tables for cover-abundance scales</h2><span id='topic+scale_tabs'></span>

<h3>Description</h3>

<p>Dataset containing the conversion tables for cover-abundance scales
used by the functions of this package, e.g. <code><a href="#topic+cov2per">cov2per</a></code> and <code><a href="#topic+merge_taxa">merge_taxa</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(scale_tabs)
</code></pre>


<h3>Format</h3>

<p>A list of 6 dataframes, each containing one conversion table
</p>

<ul>
<li> <p><code>"braun.blanquet" </code>- Braun-Blanquet scale (Braun-Blanquet 1929, 1964). Conversion based on default values of the Turboveg program (Hennekens &amp; Schaminee 2001).
</p>
</li>
<li> <p><code>"braun.blanquet2" </code>- Extended Braun-Blanquet scale (Reichelt &amp; Wilmanns 1973). Conversion based on default values of the Turboveg program (Hennekens &amp; Schaminee 2001).
</p>
</li>
<li> <p><code>"kohler" </code>- Kohler scale (Kohler 1978). Own conversion adapted from Lüderitz et al. (2009) and Janauer &amp; Heindl (1998).
</p>
</li>
<li> <p><code>"kohler.zeltner" </code>- Simplified 3-level Kohler scale (Kohler &amp; Zeltner 1974). Own conversion.
</p>
</li>
<li> <p><code>"londo" </code>- Londo scale (Londo 1976).
</p>
</li>
<li> <p><code>"niwap" </code>- Scale used by Lower Saxony species survey programs (Schacherer 2001). Own conversion as approximation based on a/b-values, which are based on individual counts. Needs to be adapted to sample sizes. 
</p>
</li>
<li> <p><code>"pa" </code>- Presence/absence data (1/0).
</p>
</li></ul>

<p>Each dataframe has three columns:
</p>

<ul>
<li> <p><code>"code" </code>- Cover-abundance code of scale
</p>
</li>
<li> <p><code>"cov_mean" </code>- Mean percentage cover of class for transformation into percentage values. All code values will be transformed to the corresponding value by  <code><a href="#topic+cov2per">cov2per</a></code>
</p>
</li>
<li> <p><code>"cov_max" </code>- Maximum percentage cover of class. All values greater then the next lower class value up to this value will be transformed to the corresponding code by <code><a href="#topic+per2cov">per2cov</a></code>
</p>
</li></ul>



<h3>References</h3>

<p>Braun-Blanquet, J. (1964): Pflanzensoziologie: Grundzüge der Vegetationskunde (3. Aufl.). Wien-New York: Springer.
<a href="https://doi.org/10.1007/978-3-7091-8110-2">doi:10.1007/978-3-7091-8110-2</a>
</p>
<p>Hennekens, S. M. &amp; Schaminée, J. H. (2001): TURBOVEG, a comprehensive data base management system for vegetation data.
<em>Journal of Vegetation Science</em>, <strong>12</strong>: 589–591. <a href="https://doi.org/10.2307/3237010">doi:10.2307/3237010</a>
</p>
<p>Janauer, G. A. &amp; Heindl, E. (1998): Die Schätzskala nach Kohler: Zur Gültigkeit der Funktion f(y) = ax3 als Maß für die Pflanzenmenge von Makrophyten.
<em>Verhandlungen der zoologisch-botanischen Gesellschaft in Wien</em>, <strong>135</strong>: 117–128.
</p>
<p>Londo, G. (1976): The decimal scale for releves of permanent quadrats.
<em>Vegetatio</em>, <strong>33</strong>: 61–64. <a href="https://doi.org/10.1007/BF00055300">doi:10.1007/BF00055300</a>
</p>
<p>Lüderitz, V., Langheinrich, U., &amp; Kunz, C. (Eds.) (2009): Flussaltwässer: Ökologie und Sanierung (1. Aufl.).
Wiesbaden: Vieweg + Teubner.
</p>
<p>Kohler, A. (1978): Methoden der Kartierung von Flora und Vegetation von Süßwasserbiotopen.
<em>Landschaft + Stadt</em>, <strong>10</strong>: 73–85.
</p>
<p>Kohler, A. &amp; Zeltner, G. (1974): Verbreitung und Ökologie von Makrophyten in Weichwasserflüssen des Oberpfälzer Waldes.
<em>Hoppea</em>, <strong>33</strong>: 171–232.
</p>
<p>Reichelt, G. &amp; Wilmanns, O. (1973): Vegetationsgeographie. Braunschweig: Westermann.
</p>
<p>Tichý, L., Hennekens, S. M., Novák, P., Rodwell, J. S., Schaminée, J. H. J. &amp; Chytrý, M. (2020):
Optimal transformation of species cover for vegetation classification. <em>Applied Vegetation Science</em>, <strong>23</strong>: 710–717. <a href="https://doi.org/10.1111/avsc.12510">doi:10.1111/avsc.12510</a>
</p>
<p>Schacherer, A. (2001): Das Niedersächsische Pflanzenartenerfassungsprogramm. Herausgegeben vom Niedersächsischen Landesamt für Ökologie - Fachbehörde für Naturschutz. 
<em>Informationsdienst Naturschutz Niedersachsen</em>, <strong>21(5 - Supplement Pflanzen)</strong>: 1–20.
</p>

<hr>
<h2 id='schedenenv'>Header data for Vegetation releves from Scheden</h2><span id='topic+schedenenv'></span>

<h3>Description</h3>

<p>An example vegetation dataset containing 28 grassland releves from Scheden, Niedersachsen, Germany.
The releves were done May 2016 during a students field course at the University of Goettingen.
Locations at the study site are based on the diploma thesis from <cite>Eichholz (1997)</cite>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(schedenenv)
</code></pre>


<h3>Format</h3>

<p>A data frame with 28 rows (samples) and 10 variables
</p>

<ul>
<li> <p><strong>comm:</strong> Plant community as defined in 1997: <em>Arrhenatheretum</em> (A) or <em>Gentiano-Koelerietum</em> (GK)
</p>
</li>
<li> <p><strong>altit:</strong> Altitude (m)
</p>
</li>
<li> <p><strong>exp:</strong> Exposition of plot (degrees)
</p>
</li>
<li> <p><strong>north:</strong> North value as cosine of aspect
</p>
</li>
<li> <p><strong>slope:</strong> Slope (degrees)
</p>
</li>
<li> <p><strong>cov_herb:</strong> Cover of herb layer (%)
</p>
</li>
<li> <p><strong>cov_litt:</strong> Cover of litter (%)
</p>
</li>
<li> <p><strong>cov_moss:</strong> Cover of mosses (%)
</p>
</li>
<li> <p><strong>cov_opensoil:</strong> Cover of open soil (%)
</p>
</li>
<li> <p><strong>height_herb:</strong> Average height of herb layer (cm)
</p>
</li>
<li> <p><strong>soil_depth:</strong> Soil depth (cm)
</p>
</li></ul>



<h3>References</h3>

<p>Eichholz, A. (1997): Wiesen und Magerrasen am Suedhang des Hohen Hagen. Diplomarbeit Biologie, University of Goettingen.
</p>

<hr>
<h2 id='schedenveg'>Vegetation releves from Scheden</h2><span id='topic+schedenveg'></span>

<h3>Description</h3>

<p>An example vegetation dataset containing 28 grassland releves from Scheden, Niedersachsen, Germany.
The releves were done May 2016 during a students field course at the University of Goettingen.
Locations at the study site are based on the diploma thesis from <cite>Eichholz (1997)</cite>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(schedenveg)
</code></pre>


<h3>Format</h3>

<p>A data frame with 28 rows (samples) and 155 variables (species)
</p>


<h3>References</h3>

<p>Eichholz, A. (1997): Wiesen und Magerrasen am Suedhang des Hohen Hagen. Diplomarbeit Biologie, University of Goettingen.
</p>

<hr>
<h2 id='screeplot_NMDS'>Scree plot/Stress plot for NMDS</h2><span id='topic+screeplot_NMDS'></span><span id='topic+dimcheckMDS'></span>

<h3>Description</h3>

<p>This function provides a plot of stress values against a given number of tested dimensions (default <code>k = 6</code>) in NMDS.
This scree plot (or stress plot) shows the decrease in ordination stress with an increase in the number of ordination dimensions.
It is based on function <code><a href="vegan.html#topic+metaMDS">metaMDS</a></code> (<code>vegan</code> package) and uses the <code>monoMDS</code> engine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>screeplot_NMDS(
  matrix,
  distance = "bray",
  k = 6,
  trymax = 20,
  autotransform = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="screeplot_NMDS_+3A_matrix">matrix</code></td>
<td>
<p>Community data, a matrix-like object with samples in rows and species in columns.</p>
</td></tr>
<tr><td><code id="screeplot_NMDS_+3A_distance">distance</code></td>
<td>
<p>Dissimilarity index used in vegdist.</p>
</td></tr>
<tr><td><code id="screeplot_NMDS_+3A_k">k</code></td>
<td>
<p>Number of dimensions (default <code>k = 6</code>).</p>
</td></tr>
<tr><td><code id="screeplot_NMDS_+3A_trymax">trymax</code></td>
<td>
<p>Maximum number of random configuration for iterative search search of stable solution.</p>
</td></tr>
<tr><td><code id="screeplot_NMDS_+3A_autotransform">autotransform</code></td>
<td>
<p>Whether to use transformation (see <code><a href="vegan.html#topic+metaMDS">metaMDS</a></code>) or not. Default is <code>autotransform = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length <em>k</em> containing stress values for <em>k</em> dimensions.
</p>


<h3>Details</h3>

<p>The simplest indicator for the goodness of non-metric multidimensional scaling (NMDS) is the stress value. Stress is a value between 0 and 1 and expresses a proportion between the distance in the original dissimilarity matrix and the fitted distance in ordination space.
The lower the stress value, the better is the fit. Details and exact formula are found under function <code><a href="vegan.html#topic+monoMDS">monoMDS</a></code>.
Stress value depends on dimensionality: it is decreasing with increasing dimensionality. On the other hand, stress-reduction does not mean to maximize interpretation capability.
Low-dimensional projections are often better to interpret and are so preferable for interpretation issues.
</p>
<p>A scree plot (or sometimes also called stress plot) is a diagnostic plot to explore both, dimensionality and interpretative value.
Often the 'elbow' of the plot is an indicator to determine the optimal number of dimensions to capture most information contained in the data.
However, for ecological data this is rarely seen, so that the following rule of thumb under consideration of the interpretability can be used.
</p>
<p><cite>Clarke 1993</cite> suggests the following guidelines for stress values:
&lt;0.05 = excellent, &lt;0.10 = good, &lt;0.20 = usable without putting too much reliance on details, &gt;0.20 = could be dangerous to interpret, &gt; 0.35 = samples effectively randomly placed.
The plot shows the border of the 0.20 stress value limit. Solutions with higher stress values should be interpreted with caution and those with stress above 0.35 are highly suspect.
</p>
<p>It should be taken into account that the stress value naturally increases with the number of samples and/or variables: “The greater the number of samples, the harder it will be to reflect the complexity of their inter-relationship in a two-dimensional plot” (Clarke 1993, p. 125).
Furthermore high stress values can be attributed to all points or only to few or even single points, that represent samples different to the others.
</p>
<p>The scree plot is not an exclusive method to determine the optimal number of dimensions.
The effect of individual points on the stress value can be explored with the <code><a href="vegan.html#topic+goodness.metaMDS">goodness</a></code>-function.
Large values indicate poor fit and can be easily visualized in an ordination diagram.
</p>
<p>Another diagnostic plot is the the Shepard diagram (<code><a href="vegan.html#topic+goodness.metaMDS">stressplot</a></code>), which is a scatterplot of the (Euclidean) distances in ordination space against the original dissimilarities.
However, as the number of pairwise elements increases rapidly with the number of samples, the Shepard diagram will mostly lead to a high ‘correlation-like' fit and lacks therefore a reliable and precise interpretability.
</p>


<h3>Author(s)</h3>

<p>Friedemann von Lampe (<a href="mailto:fvonlampe@uni-goettingen.de">fvonlampe@uni-goettingen.de</a>) and Jenny Schellenberg
</p>


<h3>References</h3>

<p>Clarke, K. R. (1993). Non-parametric multivariate analysis of changes in community structure. <em>Austral J Ecol</em> <strong>18:</strong> 117-143. <a href="https://doi.org/10.1111/j.1442-9993.1993.tb00438.x">doi:10.1111/j.1442-9993.1993.tb00438.x</a>
</p>


<h3>See Also</h3>

<p><code><a href="vegan.html#topic+metaMDS">metaMDS</a></code> <code><a href="vegan.html#topic+goodness.metaMDS">stressplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Use of function with default values
screeplot_NMDS(schedenveg)

## Use of function for testing 10 dimensions
screeplot_NMDS(schedenveg, k = 10)

## Alternative diagnostic plots
library(vegan)
nmds &lt;- metaMDS(schedenveg, k = 2)

# Draw Shepard plot
stressplot(nmds)

# Calculate goodness of fit
gof &lt;- goodness(object = nmds)

# Draw NMDS ordination diagram with sites
plot(nmds, display = "sites", type = "n", cex = 0.7)
# Add the points with size reflecting goodness of fit (bigger = worse fit)
points(nmds, display = "sites", cex = 2*gof/mean(gof))

</code></pre>

<hr>
<h2 id='sem'>Standard error of the mean (SEM)</h2><span id='topic+sem'></span>

<h3>Description</h3>

<p>Compute the standard error of the mean (SEM). The SEM is the standard deviation of the sample-mean's estimate of a population mean.
It therefore describes the accuracy of the calculation of a sample's mean.
If <code>na.rm</code> is <code>TRUE</code> then missing values are removed before computation proceeds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sem(x, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sem_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="sem_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Should missing values be removed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric scalar &ndash; the standard error of the mean.
</p>


<h3>Details</h3>

<p>The SEM of a zero-length vector (after removal of <code>NA</code>s if <code>na.rm = TRUE</code>) is not defined and gives an error.
The SEM of a length-one vector is <code>NA</code>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+sd">sd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Calculate mean and SEM for variable soil depth
mean(schedenenv$soil_depth)
sem(schedenenv$soil_depth)
</code></pre>

<hr>
<h2 id='specresponse'>Species response curves</h2><span id='topic+specresponse'></span>

<h3>Description</h3>

<p>This function fits species response curves to visualize species responses to environmental gradients or ordination axes.
It is based on Logistic Regression (binomial family) using Generalized Linear Models (GLMs) or Generalized Additive Models (GAMs) with integrated smoothness estimation.
The function can draw response curves for single or multiple species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>specresponse(
  species,
  var,
  main,
  xlab,
  model = "auto",
  method = "env",
  axis = 1,
  points = FALSE,
  bw = FALSE,
  lwd = NULL,
  na.action = na.omit
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="specresponse_+3A_species">species</code></td>
<td>
<p>Species data (either a community matrix object with samples in rows and species in columns - response curves are drawn for all (selected) columns; or a single vector containing species abundances per plot).</p>
</td></tr>
<tr><td><code id="specresponse_+3A_var">var</code></td>
<td>
<p>Vector containing environmental variable (per plot) <strong>OR</strong> <code>vegan</code> ordination result object if <code>method = "ord"</code>.</p>
</td></tr>
<tr><td><code id="specresponse_+3A_main">main</code></td>
<td>
<p>Optional: Main title.</p>
</td></tr>
<tr><td><code id="specresponse_+3A_xlab">xlab</code></td>
<td>
<p>Optional: Label of x-axis.</p>
</td></tr>
<tr><td><code id="specresponse_+3A_model">model</code></td>
<td>
<p>Defining the assumed species response: Default <code>model = "auto"</code> selects the model automatically based on AIC. Other methods are <code>model = "linear"</code> (linear response), <code>model = "unimodal"</code> (unimodal response), <code>model = "bimodal"</code> (bimodal response) and <code>model = "gam"</code> (using GAM with regression smoother).</p>
</td></tr>
<tr><td><code id="specresponse_+3A_method">method</code></td>
<td>
<p>Method defining the type of variable. Default <code>method = "env"</code> fits a response curve to environmental variables. Alternatively <code>method = "ord"</code> fits a response along ordination axes.</p>
</td></tr>
<tr><td><code id="specresponse_+3A_axis">axis</code></td>
<td>
<p>Ordination axis (only if <code>method = "ord"</code>).</p>
</td></tr>
<tr><td><code id="specresponse_+3A_points">points</code></td>
<td>
<p>If set on <code>TRUE</code> the species occurrences are shown as transparent points (the darker the point the more samples at this x-value). To avoid overlapping they are shown with vertical offset when multiple species are displayed.</p>
</td></tr>
<tr><td><code id="specresponse_+3A_bw">bw</code></td>
<td>
<p>If set on <code>TRUE</code> the lines will be drawn in black/white with different line types instead of colors.</p>
</td></tr>
<tr><td><code id="specresponse_+3A_lwd">lwd</code></td>
<td>
<p>Optional: Graphical parameter defining the line width.</p>
</td></tr>
<tr><td><code id="specresponse_+3A_na.action">na.action</code></td>
<td>
<p>Optional: a function which indicates what should happen when the data contain NAs. The default is 'na.omit' (removes incomplete cases).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an (invisible) list with results for all calculated models. This list can be stored by assigning the result.
For each model short information on type, parameters, explained deviance and corresponding p-value (based on chi-squared test) are printed.
</p>


<h3>Details</h3>

<p>For response curves based on environmental gradients the argument <code>var</code> takes a single vector containing the variable corresponding to the species abundances.
</p>
<p>For a response to ordination axis (<code>method = "ord"</code>) the argument <code>var</code> requires a <code>vegan</code> ordination result object (e.g. from <code><a href="vegan.html#topic+decorana">decorana</a></code>, <code><a href="vegan.html#topic+cca">cca</a></code> or <code><a href="vegan.html#topic+metaMDS">metaMDS</a></code>).
First axis is used as default.
</p>
<p>By default the response curves are drawn with automatic GLM model selection based on AIC out of GLMs with 1 - 3 polynomial degrees (thus excluding bimodal responses which must be manually defined). The GAM model is more flexible and chooses automatically between an upper limit of 3 - 6 degrees of freedom for the regression smoother.
</p>
<p>Available information about species is reduced to presence-absence as species abundances can contain much noise (being affected by complex factors) and the results of Logistic Regression are easier to interpret showing the &quot;probabilities of occurrence&quot;.
Be aware that response curves are only a simplification of reality (model) and their shape is strongly dependent on the available dataset.
</p>


<h3>Author(s)</h3>

<p>Friedemann von Lampe (<a href="mailto:fvonlampe@uni-goettingen.de">fvonlampe@uni-goettingen.de</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Draw species response curve for one species on environmental variable
## with points of occurrences
specresponse(schedenveg$ArrElat, schedenenv$soil_depth, points = TRUE)

## Draw species response curve on environmental variable with custom labels
specresponse(schedenveg$ArrElat, schedenenv$soil_depth, points = TRUE,
       main = "Arrhenatherum elatius", xlab = "Soil depth")

## Draw species response curve on ordination axes
## First calculate DCA
library(vegan)
scheden.dca &lt;- decorana(schedenveg)

# Using a linear model on first axis
specresponse(schedenveg$ArrElat, scheden.dca, method = "ord", model = "linear")
# Using an unimodal model on second axis
specresponse(schedenveg$ArrElat, scheden.dca, method = "ord", axis = 2, model = "unimodal")

## Community data: species (columns) need to be selected; call names() to get column numbers
names(schedenveg)
## Draw multiple species response curves on variable in black/white and store the results
res &lt;- specresponse(schedenveg[ ,c(9,18,14,19)], schedenenv$height_herb, bw = TRUE)
# Call the results for Anthoxanthum odoratum
summary(res$AntOdor)

## Draw the same curves based on GAM
specresponse(schedenveg[ ,c(9,18,14,19)], schedenenv$height_herb, bw = TRUE, model = "gam")

## Draw multiple species response curves on variable with
## custom x-axis label and points of occurrences
specresponse(schedenveg[ ,c(9,18,14,19)], schedenenv$height_herb,
    xlab = "Height of herb layer (cm)", points = TRUE)

## Draw multiple species response curves on ordination axes
specresponse(schedenveg[ ,c(9,18,14,19)], scheden.dca, method = "ord")
specresponse(schedenveg[ ,c(9,18,14,19)], scheden.dca, method = "ord", axis = 2)

</code></pre>

<hr>
<h2 id='synsort'>Sorting functions for synoptic tables</h2><span id='topic+synsort'></span>

<h3>Description</h3>

<p>This function sorts synoptic tables from <code><a href="#topic+syntable">syntable</a></code> function output. Sorting criteria
can be either numerical values in synoptic tables, such as cluster-wise frequencies or fidelity
measures, as well as combined criteria that also take into account differential character (according to
the criteria defined by Tsiripidis et al., 2009).
</p>
<p>The algorithm aims to sort species to blocked structure considering the defined criteria and input
tables, with the best characterizing species on the top of the block, followed by species with
descending importance for plant community description.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>synsort(
  syn1,
  syn2 = syn1,
  matrix,
  cluster,
  method = "allspec",
  min1 = 0,
  min2 = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="synsort_+3A_syn1">syn1</code></td>
<td>
<p>Input synoptic table 1, a data frame with numerical data format, usually from
<code><a href="#topic+syntable">syntable</a></code> function output. See Details for input table format.
The values of this table will be displayed in the final output table.</p>
</td></tr>
<tr><td><code id="synsort_+3A_syn2">syn2</code></td>
<td>
<p>Optional second input table with additional numeric or differential character
sorting criteria.</p>
</td></tr>
<tr><td><code id="synsort_+3A_matrix">matrix</code></td>
<td>
<p>Species-sample matrix, already used for <code><a href="#topic+syntable">syntable</a></code> function input</p>
</td></tr>
<tr><td><code id="synsort_+3A_cluster">cluster</code></td>
<td>
<p>Integer or character vector/factor with classification cluster identity. Ensure matching order of
cluster identity and samples in matrix for correct allocation of cluster numbers to samples.</p>
</td></tr>
<tr><td><code id="synsort_+3A_method">method</code></td>
<td>
<p>Sorting algorithm and synoptic table output options (<code>method = c("allspec", "alldiff")</code>).
See Details.</p>
</td></tr>
<tr><td><code id="synsort_+3A_min1">min1</code></td>
<td>
<p>Cluster-wise threshold minimum value for species shown in the final sorted synoptic table.
Species below that minimum will be listed in the output (<code>$others</code> section).</p>
</td></tr>
<tr><td><code id="synsort_+3A_min2">min2</code></td>
<td>
<p>Threshold minimum value for considering species values of a numerical second input table <code>syn2</code>.
Species below that minimum will not be displayed in final synoptic table, but will be listed in the
output (<code>$others</code> section).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an (invisible) list composed of:
</p>

<ul>
<li> <p><code>$output</code> Sorting method description
</p>
</li>
<li> <p><code>$species</code> Information to species included in the output table
</p>
</li>
<li> <p><code>$samplesize</code> Sample sizes in clusters
</p>
</li>
<li> <p><code>$syntable</code> Sorted synoptic table, with the numeric values of <code>syn1</code> in the left-side columns
and differential character of species on the right-side of the output table. See Tsiripidis et al. (2009) for
details and criteria for the assignment of a differential species as p = positive, n = negative,
pn = positive/negative.
</p>
</li>
<li> <p><code>$others</code> Species that are omitted in Synoptic table due to their failing
reaching the given threshold values <code>min1</code> and <code>min2</code>. Sorted alphabetically.
</p>
</li>
<li> <p><code>$samples</code> Sorted original species-sample matrix, with original Plot-IDs (as column
names) and the cluster identity (Cluster_No as first row of output samples table)
</p>
</li></ul>



<h3>Details</h3>

<p>Two types of sorted synoptic tables can be created with this function:
</p>

<ul>
<li> <p><code>method = "allspec"</code> (<em>default</em>) creates a sorted synoptic table basing on one or
two numeric input tables, e.g. percentage or absolute frequencies, or phi fidelity values.
Sorting criteria can be either given by only one input table by using only <code>syn1</code>
argument, as well as by two input tables with specifying <code>syn2</code>, too.
Thereby, only values of <code>syn1</code> will be shown in the final sorted table.
</p>
</li>
<li> <p><code>method = "alldiff"</code>: With including differential species
character as sorting criteria, <code>syn1</code> must be numeric (e.g. percentage frequency) and
<code>syn2</code> must contain information on differential character (output from <code><a href="#topic+syntable">syntable</a></code>
function with defined <code>type = "diffspec"</code>). The result table shows ALL diagnostic and
non-diagnostic species, as long as they match the <code>min1</code> and <code>min2</code> thresholds.
The algorithm detects highest cluster values of species calculated from
<code>syn1</code> as base for sorting, but will consider differential character criterion
from <code>syn2</code> as well. Species with high values in <code>syn1</code> AND
positive differential character will then be listed on the top of a species block.
Within such a block, the differentiating and high-abundant species are sorted in a way favoring
species that are positive in only one or at least few clusters.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Jenny Schellenberg (<a href="mailto:jschell@gwdg.de">jschell@gwdg.de</a>)
</p>


<h3>References</h3>

<p>Bruelheide, H. (2000): A new measure of fidelity and its application to defining species groups.
<em>Journal of Vegetation Science</em> <strong>11</strong>: 167-178. <a href="https://doi.org/10.2307/3236796">doi:10.2307/3236796</a>
</p>
<p>Chytry, M., Tichy, L., Holt, J., Botta-Dukat, Z. (2002): Determination of diagnostic species with
statistical fidelity measures. <em>Journal of Vegetation Science</em> <strong>13</strong>: 79-90. <a href="https://doi.org/10.1111/j.1654-1103.2002.tb02025.x">doi:10.1111/j.1654-1103.2002.tb02025.x</a>
</p>
<p>Sokal, R.R. &amp; Rohlf, F.J. (1995): Biometry. 3rd edition Freemann, New York.
</p>
<p>Tsiripidis, I., Bergmeier, E., Fotiadis, G. &amp; Dimopoulos, P. (2009): A new algorithm for the
determination of differential taxa. <em>Journal of Vegetation Science</em> <strong>20</strong>: 233-240. <a href="https://doi.org/10.1111/j.1654-1103.2009.05273.x">doi:10.1111/j.1654-1103.2009.05273.x</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+syntable">syntable</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Synoptic table of Scheden vegetation data using syntable()-function:
# classification to create a vector of cluster identity
library(cluster)
pam1 &lt;- pam(schedenveg, 4)


### One input table for sorting:
## Synoptic table with percentage frequency of species in clusters, all species
unordered &lt;- syntable(schedenveg, pam1$clustering, abund = "percentage",
                      type = "percfreq")   # Unordered synoptic percentage frequency table
sorted &lt;- synsort(syn1 = unordered$syntable, matrix = schedenveg,
                  cluster = pam1$clustering, method = "allspec", min1 = 0)
sorted             # view results
## Not run: 
# Export sorted synoptic table
write.csv(sorted$syntab, "syntab.csv")
# Export sorted species-sample matrix with original releve data for postprocessing
write.csv(sorted$samples, "output_species_sample.csv")
## End(Not run)

## Synoptic table with only phi values
phi &lt;- syntable(schedenveg, pam1$clustering, abund = "percentage",
                     type = "phi")         # calculates cluster-wise phi for each species
phi_table &lt;- synsort(syn1 = phi$syntable, matrix = schedenveg, cluster = pam1$clustering,
                     method = "allspec", min1 = 0.3)
phi_table     # view results


### Two numerical tables for sorting:
## Synoptic table showing percentage frequencies, but only for species with minimum phi-value
## of 0.3 AND exclude species with less than 25% percentage frequency

unordered &lt;- syntable(schedenveg, pam1$clustering, abund = "percentage",
                      type = "percfreq")   # Unordered synoptic percentage frequency table
phitable &lt;- syntable(schedenveg, pam1$clustering, abund = "percentage",
                     type = "phi")         # calculates cluster-wise phi for each species
# now sorting and arranging
phi_complete &lt;- synsort(syn1 = unordered$syntable, syn2 = phitable$syntable,
                       matrix = schedenveg, cluster = pam1$clustering, method = "allspec",
                       min1 = 25, min2 = 0.3)
phi_complete      # view results

### Differential species analysis
differential &lt;- syntable(schedenveg, pam1$clustering, abund = "percentage",
                         type = "diffspec")

## Synoptic table with percentage frequency (only species &gt;25%) and
## differential character.
complete &lt;- synsort(syn1 = unordered$syntable, syn2 = differential$syntable,
                    matrix = schedenveg, cluster = pam1$clustering,
                    method = "alldiff", min1 = 25)
complete            # view result table
differential$differentials  # list differential species for clusters

</code></pre>

<hr>
<h2 id='syntable'>Synoptic tables and calculation of cluster-wise frequencies, fidelity and
differential species character</h2><span id='topic+syntable'></span>

<h3>Description</h3>

<p>Synoptic tables are a tool for the visualization and interpretation of previously
defined plant species groups (clusters), e.g. from cluster analysis, classification methods or
pre-defined categories, e.g. spatial distribution units.
They help to determine characteristic patterning of species occurrences in plant communities
by calculating cluster-wise percentage or absolute frequencies, mean/median cover values, fidelity
(phi) or differential species character.
</p>
<p><code>syntable</code> function calculates an unordered synoptic table for plant community analysis, using
an input species-sample data frame and a vector of cluster identity input.
The unordered output table can be sorted automatically with <code><a href="#topic+synsort">synsort</a></code> function
in this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>syntable(matrix, cluster, abund = "percentage", type = "percfreq", digits = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="syntable_+3A_matrix">matrix</code></td>
<td>
<p>Species matrix or data frame with species in columns and samples in rows.
Missing values (NA) will be transformed to 0.
If non-numeric abundance values are present, the matrix will be transformed to presence/absence with all
non-zero values defined as 1.
Species and sample names must be defined as column- and row names, respectively.</p>
</td></tr>
<tr><td><code id="syntable_+3A_cluster">cluster</code></td>
<td>
<p>Integer or character vector/factor with classification cluster identity. Ensure matching order of
cluster identity and samples in matrix for correct allocation of cluster numbers to samples.</p>
</td></tr>
<tr><td><code id="syntable_+3A_abund">abund</code></td>
<td>
<p>Type of abundances. Define whether input species matrix or data frame is percentage cover (<code>abund = "percentage"</code>, default)
or presence/absence data (<code>abund = "pa"</code>, with values 0/1). You may use function <code><a href="#topic+cov2per">cov2per</a></code> to transform
cover-abundance values from different scales into percentage cover.</p>
</td></tr>
<tr><td><code id="syntable_+3A_type">type</code></td>
<td>
<p>Type of synoptic table output <code>type = c("percfreq", "totalfreq", "mean",
"median", "diffspec", "phi")</code>. See Details.</p>
</td></tr>
<tr><td><code id="syntable_+3A_digits">digits</code></td>
<td>
<p>Integer indicating the number of decimal places to be displayed in result tables (default 0)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an (invisible) list of result components.
</p>
<table>
<tr><td><code>$syntable</code></td>
<td>
<p>unordered synoptic table for given species and clusters</p>
</td></tr>
<tr><td><code>$samplesize</code></td>
<td>
<p>total number of samples per cluster</p>
</td></tr>
</table>
<p>Additionally for differential species character calculation:
</p>
<table>
<tr><td><code>$onlydiff</code></td>
<td>
<p>Synoptic table only with differential species</p>
</td></tr>
<tr><td><code>$others</code></td>
<td>
<p>List of non-differential species</p>
</td></tr>
<tr><td><code>$differentials</code></td>
<td>
<p>Lists differential species for each cluster</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For synoptic table calculation, six types are available.
</p>

<ul>
<li> <p><code>type = "percfreq" </code> Creates a percentage frequency table <em>(default)</em>
</p>
</li>
<li> <p><code>type = "totalfreq" </code> Creates an absolute frequency table
</p>
</li>
<li> <p><code>type = "mean" </code>  Calculates mean of species values given in <code>matrix</code> per cluster
</p>
</li>
<li> <p><code>type = "median" </code>  Calculates median of species values given in <code>matrix</code> per
cluster
</p>
</li>
<li> <p><code>type = "diffspec" </code> Calculates differential character of species according to
Tsiripidis et al. 2009, with resulting character p = positive, n = negative, pn = positive-
negative or no differential character (-). Consider that differential character is always
restricted to some and not necessarily all of the other units, thus considering percentage
frequency is essential for correct interpretation of the diagnostic species character.
This calculation needs at least three groups.
</p>
</li>
<li> <p><code>type = "phi" </code> Calculates fidelity measure phi (algorithm basing on Sokal &amp; Rohlf
1995, Bruelheide 2000). Values are ranging between -1 and 1 with high values near 1 indicating
high fidelity.
</p>
</li></ul>

<p>For sorting the output synoptic table, use <code><a href="#topic+synsort">synsort</a></code> function, providing several
options.
</p>


<h3>Author(s)</h3>

<p>Jenny Schellenberg (<a href="mailto:jschell@gwdg.de">jschell@gwdg.de</a>) and Friedemann von Lampe
</p>


<h3>References</h3>

<p>Bruelheide, H. (2000): A new measure of fidelity and its application to defining species groups.
<em>Journal of Vegetation Science</em> <strong>11</strong>: 167-178. <a href="https://doi.org/10.2307/3236796">doi:10.2307/3236796</a>
</p>
<p>Chytry, M., Tichy, L., Holt, J., Botta-Dukat, Z. (2002): Determination of diagnostic species with
statistical fidelity measures. <em>Journal of Vegetation Science</em> <strong>13</strong>: 79-90. <a href="https://doi.org/10.1111/j.1654-1103.2002.tb02025.x">doi:10.1111/j.1654-1103.2002.tb02025.x</a>
</p>
<p>Sokal, R.R. &amp; Rohlf, F.J. (1995): Biometry. 3rd edition Freemann, New York.
</p>
<p>Tsiripidis, I., Bergmeier, E., Fotiadis, G. &amp; Dimopoulos, P. (2009): A new algorithm for the
determination of differential taxa. <em>Journal of Vegetation Science</em> <strong>20</strong>: 233-240. <a href="https://doi.org/10.1111/j.1654-1103.2009.05273.x">doi:10.1111/j.1654-1103.2009.05273.x</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+synsort">synsort</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Synoptic table of Scheden vegetation data
library(cluster)
pam1 &lt;- pam(schedenveg, 4)  # PAM clustering with 4 clusters output

## 1) Unordered synoptic percentage frequency table
percfreq &lt;- syntable(schedenveg, pam1$clustering, abund = "percentage",
                         type = "percfreq")
                         percfreq                   # view results

## 2) Differential species analysis
differential &lt;- syntable(schedenveg, pam1$clustering, abund = "percentage",
                             type = "diffspec")
# show complete table with differential character of species
differential$syntable
# list differential species for second cluster
differential$differentials[2]

## 3) Synoptic table with phi fidelity
phitable &lt;- syntable(schedenveg, pam1$clustering, abund = "percentage",
                         type = "phi")
phitable

## 4) Synoptic percentage frequency table based on historical classification from 1997
percfreq &lt;- syntable(schedenveg, schedenenv$comm, abund = "percentage",
                         type = "percfreq")
percfreq

</code></pre>

<hr>
<h2 id='trans_matrix'>Transpose species matrix</h2><span id='topic+trans_matrix'></span>

<h3>Description</h3>

<p>The function transposes a species matrix, while preserving correct species and sample names. 
The new column names must be stored as row names of the data frame. They may also be stored in the first column, when chosing the argument <code>row.names = F</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trans_matrix(matrix, row.names = T, rmchar = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trans_matrix_+3A_matrix">matrix</code></td>
<td>
<p>Community data, a data frame.</p>
</td></tr>
<tr><td><code id="trans_matrix_+3A_row.names">row.names</code></td>
<td>
<p>A logical evaluation indicating whether the new column names are stored as row names of the data frame <code>TRUE</code> <em>(default)</em> or in the first column <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="trans_matrix_+3A_rmchar">rmchar</code></td>
<td>
<p>A logical evaluation indicating whether the first character of the original column names should be removed (default: <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A transposed data frame.
</p>


<h3>Details</h3>

<p>Sometimes vegetation data is organized as a data frame with samples in columns and taxa in rows, with taxon names stored in the first column, e.g. as result of the function <code><a href="#topic+merge_taxa">merge_taxa</a></code>.
In this case you can use <code>row.names = F</code> to directly convert this species matrix into a statistically analyzable format, e.g. with <code>vegan</code>.
</p>
<p>If your dataframe contains prepended “X” to each header due to numbered samples, you can use <code>rmchar = TRUE</code> to remove the first character of the column names during transposing. 
(You may also avoid this problem at all by using <code>check.names = FALSE</code> when loading the data in <code><a href="utils.html#topic+read.table">read.table</a></code>)
</p>


<h3>Author(s)</h3>

<p>Friedemann von Lampe (<a href="mailto:fvonlampe@uni-goettingen.de">fvonlampe@uni-goettingen.de</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Transpose species matrix
schedenveg.trans &lt;- trans_matrix(schedenveg)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
