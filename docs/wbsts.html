<!DOCTYPE html><html lang="en"><head><title>Help for package wbsts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {wbsts}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#wbsts-package'>
<p>Multiple change-point detection for nonstationary time series</p></a></li>
<li><a href='#across_fip'><p>The value that maximises the CUSUM statistic across all the scales (C++ version)</p></a></li>
<li><a href='#cr.rand.max.inner.prod'><p>The value that maximises the random CUSUM statistic across all the scales</p>
</p></a></li>
<li><a href='#cusum'>
<p>A C++ implementation of the CUSUM statistic</p></a></li>
<li><a href='#ews.trans'>
<p>Computation of the Evolutionary Wavelet Spectrum (EWS)</p></a></li>
<li><a href='#finner_prod_maxp'><p>The function finds the value which yields the maximum inner product</p>
(CUSUM) of a a time series located between <code class="reqn">100(1-p)\%</code> and <code class="reqn">100p\%</code> of its support</a></li>
<li><a href='#get.thres'>
<p>Universal thresholds calculation</p></a></li>
<li><a href='#get.thres.ar'>
<p>Selection of thresholds by fitting an AR(p) model</p></a></li>
<li><a href='#hello'><p>Hello, World!</p></a></li>
<li><a href='#multi_across_fip'><p>The value that maximises the random CUSUM statistic across all the scales (C++ version)</p></a></li>
<li><a href='#post.processing'>
<p>Post-processing of the change-points</p></a></li>
<li><a href='#sim.pw.ar'><p>Simulation of a piecewise constant AR(1) model</p></a></li>
<li><a href='#sim.pw.ar2'>
<p>Simulation of a piecewise constant AR(2) model</p></a></li>
<li><a href='#sim.pw.arma'>
<p>Simulation of a piecewise constant ARMA(p,q) model for p=2 and q=1</p></a></li>
<li><a href='#tau.fun'>
<p>Universal thresholds</p></a></li>
<li><a href='#uh.wbs'>
<p>The Wild Binary Segmentation algorithm</p></a></li>
<li><a href='#wbs.lsw'>
<p>Change point detection for a nonstationary process using Wild Binary Segmentation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Multiple Change-Point Detection for Nonstationary Time Series</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Karolos Korkas and Piotr Fryzlewicz</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Karolos Korkas &lt;kkorkas@yahoo.co.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements detection for the number and locations of
    the change-points in a time series using the Wild Binary Segmentation and
    the Locally Stationary Wavelet model of Korkas and Fryzlewicz (2017) &lt;<a href="https://doi.org/10.5705%2Fss.202015.0262">doi:10.5705/ss.202015.0262</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>mvtnorm,wavelets, R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.12)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-06-12 09:46:02 UTC; kkork</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-06-12 23:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='wbsts-package'>
Multiple change-point detection for nonstationary time series
</h2><span id='topic+wbsts-package'></span>

<h3>Description</h3>

<p>Implements the Wild Binary Segmentation method of Fryzlewicz (2014) for nostationary time series as described in Korkas and Fryzlewicz (2017). Its purpose is the estimation of the number and locations of the change-points in a time series utilising the wavelet periodogram.
</p>


<h3>Author(s)</h3>

<p>K. Korkas and P. Fryzlewicz
</p>


<h3>References</h3>

<p>P. Fryzlewicz (2014), Wild Binary Segmentation for multiple change-point detection. Annals of
Statistics, 42, 2243-2281. (http://stats.lse.ac.uk/fryzlewicz/wbs/wbs.pdf)
</p>
<p>K. Korkas and P. Fryzlewicz (2017), Multiple change-point detection for non-stationary time series using Wild Binary Segmentation. Statistica Sinica, 27, 287-311. (http://stats.lse.ac.uk/fryzlewicz/WBS_LSW/WBS_LSW.pdf)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### Generate a highly persistent time series with changing variance and of length 5,000
###Location of the change-points
#cps=seq(from=1000,to=2800,by=200)
#y=sim.pw.arma(N =3000,sd_u = c(1,1.5,1,1.5,1,1.5,1,1.5,1,1.5,1),
#b.slope=rep(0.99,11),b.slope2 = rep(0.,11), mac = rep(0.,11),br.loc = cps)[[2]]
###Estimate the change points via Binary Segmentation
#wbs.lsw(y,M=1)$cp.aft
###Estimate the change points via Wild Binary Segmentation
#wbs.lsw(y,M=0)$cp.aft

</code></pre>

<hr>
<h2 id='across_fip'>The value that maximises the CUSUM statistic across all the scales (C++ version)
</h2><span id='topic+across_fip'></span>

<h3>Description</h3>

<p>This function is an internal the non-randomized of multi_across_fip.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>across_fip(X, tau, p, epp, p1, Ts)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="across_fip_+3A_x">X</code></td>
<td>

<p>The wavelet periodogram.
</p>
</td></tr>
<tr><td><code id="across_fip_+3A_ts">Ts</code></td>
<td>

<p>The sample size of the series.
</p>
</td></tr>
<tr><td><code id="across_fip_+3A_tau">tau</code></td>
<td>

<p>The CUSUM threshold.
</p>
</td></tr>
<tr><td><code id="across_fip_+3A_epp">epp</code></td>
<td>

<p>A minimum adjustment for the bias present in <code class="reqn">E^{(i)}_{t,T}</code>.
</p>
</td></tr>
<tr><td><code id="across_fip_+3A_p">p</code></td>
<td>

<p>A scalar in (0.67,1]
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>1</code></td>
<td>
<p>maximum cusum value</p>
</td></tr>
<tr><td><code>2</code></td>
<td>
<p>the location of a point with the maximum cusum value</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>K. Korkas and P. Fryzlewicz
</p>


<h3>References</h3>

<p>K. Korkas and P. Fryzlewicz (2017), Multiple change-point detection for non-stationary time series using Wild Binary Segmentation. Statistica Sinica, 27, 287-311. (http://stats.lse.ac.uk/fryzlewicz/WBS_LSW/WBS_LSW.pdf)
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
cps=seq(from=1000,to=2000,by=200)
y=sim.pw.arma(N =3000,sd_u = c(1,1.5,1,1.5,1,1.5,1),
b.slope=rep(0.99,7),b.slope2 = rep(0.,7), mac = rep(0.,7),br.loc = cps)[[2]]
z=ews.trans(y,scales=c(11,9,8,7,6))
across_fip(X=z, tau=tau.fun(y), p=.75, epp=rep(32,5), p1=5, Ts=length(y))

</code></pre>

<hr>
<h2 id='cr.rand.max.inner.prod'>The value that maximises the random CUSUM statistic across all the scales
</h2><span id='topic+cr.rand.max.inner.prod'></span>

<h3>Description</h3>

<p>The function finds the value which yields the maximum inner product  with the input time series (CUSUM) located between <code class="reqn">100(1-p)\%</code> and <code class="reqn">100p\%</code> of their support across all the wavelet periodogram scales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cr.rand.max.inner.prod(XX,Ts,C_i,epp,M = 0,Plot = FALSE,cstar=0.95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cr.rand.max.inner.prod_+3A_xx">XX</code></td>
<td>

<p>The wavelet periodogram.
</p>
</td></tr>
<tr><td><code id="cr.rand.max.inner.prod_+3A_ts">Ts</code></td>
<td>

<p>The sample size of the series.
</p>
</td></tr>
<tr><td><code id="cr.rand.max.inner.prod_+3A_c_i">C_i</code></td>
<td>

<p>The CUSUM threshold.
</p>
</td></tr>
<tr><td><code id="cr.rand.max.inner.prod_+3A_epp">epp</code></td>
<td>

<p>A minimum adjustment for the bias present in <code class="reqn">E^{(i)}_{t,T}</code>.
</p>
</td></tr>
<tr><td><code id="cr.rand.max.inner.prod_+3A_m">M</code></td>
<td>

<p>Number of random CUSUM to be generated.
</p>
</td></tr>
<tr><td><code id="cr.rand.max.inner.prod_+3A_plot">Plot</code></td>
<td>

<p>Plot the threhsold CUSUM statistics across the wavelet scales.
</p>
</td></tr>
<tr><td><code id="cr.rand.max.inner.prod_+3A_cstar">cstar</code></td>
<td>

<p>A scalar in (0.67,1]
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>1</code></td>
<td>
<p>Candidate change point</p>
</td></tr>
<tr><td><code>2</code></td>
<td>
<p>The maximum CUSUM value</p>
</td></tr>
<tr><td><code>3</code></td>
<td>
<p>The starting point <code class="reqn">s</code> of the favourable draw</p>
</td></tr>
<tr><td><code>4</code></td>
<td>
<p>The ending point <code class="reqn">e</code> of the favourable draw</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>K. Korkas and P. Fryzlewicz
</p>


<h3>References</h3>

<p>K. Korkas and P. Fryzlewicz (2017), Multiple change-point detection for non-stationary time series using Wild Binary Segmentation. Statistica Sinica, 27, 287-311. (http://stats.lse.ac.uk/fryzlewicz/WBS_LSW/WBS_LSW.pdf)
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
#cps=seq(from=1000,to=2000,by=200)
#y=sim.pw.arma(N =3000,sd_u = c(1,1.5,1,1.5,1,1.5,1),
#b.slope=rep(0.99,7),b.slope2 = rep(0.,7), mac = rep(0.,7),br.loc = cps)[[2]]
#z=ews.trans(y,scales=c(11,9,8,7,6))
#out=cr.rand.max.inner.prod(z, Ts = length(y),C_i = tau.fun(y), 
#epp = rep(32,5), M = 2000, cstar = 0.75, Plot = 1)
#abline(v=cps,col="red")
</code></pre>

<hr>
<h2 id='cusum'>
A C++ implementation of the CUSUM statistic
</h2><span id='topic+cusum'></span>

<h3>Description</h3>

<p>This function is an internal C++ function wrapped by finner.prod.iter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cusum(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cusum_+3A_x">x</code></td>
<td>

<p>A time series
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>K. Korkas and P. Fryzlewicz
</p>


<h3>References</h3>

<p>K. Korkas and P. Fryzlewicz (2017), Multiple change-point detection for non-stationary time series using Wild Binary Segmentation. Statistica Sinica, 27, 287-311. (http://stats.lse.ac.uk/fryzlewicz/WBS_LSW/WBS_LSW.pdf)
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
cps=seq(from=1000,to=2000,by=200)
y=sim.pw.arma(N =3000,sd_u = c(1,1.5,1,1.5,1,1.5,1),
b.slope=rep(0.99,7),b.slope2 = rep(0.,7), mac = rep(0.,7),br.loc = cps)[[2]]
z=ews.trans(y,scales=c(11,9,8,7,6))
ts.plot(abs(wbsts::cusum(z[10:2990,2])))

</code></pre>

<hr>
<h2 id='ews.trans'>
Computation of the Evolutionary Wavelet Spectrum (EWS)
</h2><span id='topic+ews.trans'></span>

<h3>Description</h3>

<p>The function computes the EWS from a time series of any (non-dyadic) size by utilising the
maximal overlap discrete wavelet transform; see also W. Constantine and D. Percival (2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ews.trans(x,scales=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ews.trans_+3A_x">x</code></td>
<td>

<p>The time series.
</p>
</td></tr>
<tr><td><code id="ews.trans_+3A_scales">scales</code></td>
<td>

<p>The wavelet periodogram scales to compute starting from the finest.
</p>
</td></tr></table>


<h3>Value</h3>

<p>The evolutionary wavelet spectral estimate of y.
</p>


<h3>References</h3>

<p>Eric Aldrich (2020), wavelets: Functions for Computing Wavelet Filters, Wavelet Transforms and Multiresolution Analyses.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ews=ews.trans(rnorm(1000),c(9,8,7))
barplot(ews[,1])
</code></pre>

<hr>
<h2 id='finner_prod_maxp'>The function finds the value which yields the maximum inner product
(CUSUM) of a a time series located between <code class="reqn">100(1-p)\%</code> and <code class="reqn">100p\%</code> of its support
</h2><span id='topic+finner_prod_maxp'></span>

<h3>Description</h3>

<p>This function is an internal C++ function wrapped by cr.rand.max.inner.prod.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>finner_prod_maxp(x,p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="finner_prod_maxp_+3A_x">x</code></td>
<td>

<p>A time series.
</p>
</td></tr>
<tr><td><code id="finner_prod_maxp_+3A_p">p</code></td>
<td>

<p>A scalar in (0.67,1]
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>1</code></td>
<td>
<p>maximum cusum value</p>
</td></tr>
<tr><td><code>2</code></td>
<td>
<p>the location of a point with the maximum cusum value</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>K. Korkas and P. Fryzlewicz
</p>


<h3>References</h3>

<p>K. Korkas and P. Fryzlewicz (2017), Multiple change-point detection for non-stationary time series using Wild Binary Segmentation. Statistica Sinica, 27, 287-311. (http://stats.lse.ac.uk/fryzlewicz/WBS_LSW/WBS_LSW.pdf)
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
#cps=seq(from=1000,to=2000,by=200)
#y=sim.pw.arma(N =3000,sd_u = c(1,1.5,1,1.5,1,1.5,1),
#b.slope=rep(0.99,7),b.slope2 = rep(0.,7), mac = rep(0.,7),br.loc = cps)[[2]]
#z=ews.trans(y,scales=c(11,9,8,7,6))
##balanced
#finner_prod_maxp(z[,1],0.51)
##unbalanced
#finner_prod_maxp(z[,1],0.99)
</code></pre>

<hr>
<h2 id='get.thres'>
Universal thresholds calculation
</h2><span id='topic+get.thres'></span>

<h3>Description</h3>

<p>The function returns universal thresholds and the method is described in Korkas and Fryzlewicz (2017) and Cho and Fryzlewicz (2012). See also the supplementary material for the former work. The function works for any sample size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.thres(n, q=.95, r=100, scales=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.thres_+3A_n">n</code></td>
<td>

<p>The length of the time series.
</p>
</td></tr>
<tr><td><code id="get.thres_+3A_q">q</code></td>
<td>

<p>The quantile of the r simulations.
</p>
</td></tr>
<tr><td><code id="get.thres_+3A_r">r</code></td>
<td>

<p>Number of simulations.
</p>
</td></tr>
<tr><td><code id="get.thres_+3A_scales">scales</code></td>
<td>

<p>The wavelet periodogram scales to be used. If NULL (DEFAULT) then this is selected as described in the main text.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>K. Korkas and P. Fryzlewicz (2017), Multiple change-point detection for non-stationary time series using Wild Binary Segmentation. Statistica Sinica, 27, 287-311. (http://stats.lse.ac.uk/fryzlewicz/WBS_LSW/WBS_LSW.pdf)
</p>
<p>K. Korkas and P. Fryzlewicz (2017), Supplementary material: Multiple change-point detection for non-stationary time series using Wild Binary Segmentation.
</p>
<p>Cho, H. and Fryzlewicz, P. (2012). Multiscale and multilevel technique for consistent segmentation of nonstationary time series. Statistica Sinica, 22(1), 207-229.
</p>

<hr>
<h2 id='get.thres.ar'>
Selection of thresholds by fitting an AR(p) model
</h2><span id='topic+get.thres.ar'></span>

<h3>Description</h3>

<p>The function returns data-driven thresholds and it is described in Korkas and Fryzlewicz (2015) where
it is referred as Bsp1. See also the supplementary material for this work.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.thres.ar(y, q=.95, r=100, scales=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.thres.ar_+3A_y">y</code></td>
<td>

<p>The time series.
</p>
</td></tr>
<tr><td><code id="get.thres.ar_+3A_q">q</code></td>
<td>

<p>The quantile of the r simulations.
</p>
</td></tr>
<tr><td><code id="get.thres.ar_+3A_r">r</code></td>
<td>

<p>Number of simulations.
</p>
</td></tr>
<tr><td><code id="get.thres.ar_+3A_scales">scales</code></td>
<td>

<p>The wavelet periodogram scales to be used. If NULL (DEFAULT) then this is selected as described in the main text.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>K. Korkas and P. Fryzlewicz
</p>


<h3>References</h3>

<p>K. Korkas and P. Fryzlewicz (2017), Multiple change-point detection for non-stationary time series using Wild Binary Segmentation. Statistica Sinica, 27, 287-311. (http://stats.lse.ac.uk/fryzlewicz/WBS_LSW/WBS_LSW.pdf)
</p>
<p>K. Korkas and P. Fryzlewicz (2017), Supplementary material: Multiple change-point detection for non-stationary time series using Wild Binary Segmentation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#cps=seq(from=100,to=1200,by=350)
#y=sim.pw.arma(N =1200,sd_u = c(1,1.5,1,1.5,1),
#b.slope=rep(0.99,5),b.slope2 = rep(0.,5), mac = rep(0.,5),br.loc = cps)[[2]]
#C_i=get.thres.ar(y=y, q=.95, r=100, scales=NULL)
#wbs.lsw(y,M=1, C_i = C_i)$cp.aft


</code></pre>

<hr>
<h2 id='hello'>Hello, World!</h2><span id='topic+hello'></span>

<h3>Description</h3>

<p>Prints 'Hello, world!'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hello()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>hello()
</code></pre>

<hr>
<h2 id='multi_across_fip'>The value that maximises the random CUSUM statistic across all the scales (C++ version)
</h2><span id='topic+multi_across_fip'></span>

<h3>Description</h3>

<p>This function is an internal C++ function wrapped by cr.rand.max.inner.prod.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi_across_fip(X,M,min_draw,tau,p,epp,Ts)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multi_across_fip_+3A_x">X</code></td>
<td>

<p>The wavelet periodogram.
</p>
</td></tr>
<tr><td><code id="multi_across_fip_+3A_ts">Ts</code></td>
<td>

<p>The sample size of the series.
</p>
</td></tr>
<tr><td><code id="multi_across_fip_+3A_tau">tau</code></td>
<td>

<p>The CUSUM threshold at each scale.
</p>
</td></tr>
<tr><td><code id="multi_across_fip_+3A_min_draw">min_draw</code></td>
<td>

<p>Minimal size of a single draw.
</p>
</td></tr>
<tr><td><code id="multi_across_fip_+3A_epp">epp</code></td>
<td>

<p>A minimum adjustment for the bias present in <code class="reqn">E^{(i)}_{t,T}</code>.
</p>
</td></tr>
<tr><td><code id="multi_across_fip_+3A_m">M</code></td>
<td>

<p>Number of random CUSUM to be generated.
</p>
</td></tr>
<tr><td><code id="multi_across_fip_+3A_p">p</code></td>
<td>

<p>A scalar in (0.67,1]
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>1</code></td>
<td>
<p>Candidate change point</p>
</td></tr>
<tr><td><code>2</code></td>
<td>
<p>The maximum CUSUM value</p>
</td></tr>
<tr><td><code>3</code></td>
<td>
<p>The starting point <code class="reqn">s</code> of the favourable draw</p>
</td></tr>
<tr><td><code>4</code></td>
<td>
<p>The ending point <code class="reqn">e</code> of the favourable draw</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>K. Korkas and P. Fryzlewicz
</p>


<h3>References</h3>

<p>K. Korkas and P. Fryzlewicz (2017), Multiple change-point detection for non-stationary time series using Wild Binary Segmentation. Statistica Sinica, 27, 287-311. (http://stats.lse.ac.uk/fryzlewicz/WBS_LSW/WBS_LSW.pdf)
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
#cps=seq(from=1000,to=2000,by=200)
#y=sim.pw.arma(N =3000,sd_u = c(1,1.5,1,1.5,1,1.5,1),
#b.slope=rep(0.99,7),b.slope2 = rep(0.,7), mac = rep(0.,7),br.loc = cps)[[2]]
#z=ews.trans(y,scales=c(11,9,8,7,6))
#out=multi_across_fip(X=z, M=1000, min_draw=100,
#tau=tau.fun(y), p=c(.95,.95),epp=rep(32,5),Ts= length(y))
</code></pre>

<hr>
<h2 id='post.processing'>
Post-processing of the change-points
</h2><span id='topic+post.processing'></span>

<h3>Description</h3>

<p>A function to control the number of change-points estimated from the WBS algorithm
and to reduce the risk of over-segmentation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>post.processing(z,br,del=-1,epp=-1,C_i=NULL,scales=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="post.processing_+3A_z">z</code></td>
<td>

<p>The wavelet periodogram matrix.
</p>
</td></tr>
<tr><td><code id="post.processing_+3A_br">br</code></td>
<td>

<p>The change-points to be post-processed.
</p>
</td></tr>
<tr><td><code id="post.processing_+3A_del">del</code></td>
<td>

<p>The minimum allowed size of a segment.
</p>
</td></tr>
<tr><td><code id="post.processing_+3A_epp">epp</code></td>
<td>

<p>A minimum adjustment for the bias present in <code class="reqn">E^{(i)}_{t,T}</code>.
</p>
</td></tr>
<tr><td><code id="post.processing_+3A_c_i">C_i</code></td>
<td>

<p>The CUSUM threshold.
</p>
</td></tr>
<tr><td><code id="post.processing_+3A_scales">scales</code></td>
<td>

<p>Which wavelet periodogram scales to be used.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>K. Korkas and P. Fryzlewicz (2017), Multiple change-point detection for non-stationary time series using Wild Binary Segmentation. Statistica Sinica, 27, 287-311. (http://stats.lse.ac.uk/fryzlewicz/WBS_LSW/WBS_LSW.pdf)
</p>

<hr>
<h2 id='sim.pw.ar'>Simulation of a piecewise constant AR(1) model
</h2><span id='topic+sim.pw.ar'></span>

<h3>Description</h3>

<p>The function simulates a piecewise constant AR(1) model with multiple change-points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.pw.ar(N, sd_u, b.slope, br.loc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.pw.ar_+3A_n">N</code></td>
<td>

<p>Length of the series.
</p>
</td></tr>
<tr><td><code id="sim.pw.ar_+3A_sd_u">sd_u</code></td>
<td>

<p>A vector of the innovation standard deviation for every segment.
</p>
</td></tr>
<tr><td><code id="sim.pw.ar_+3A_b.slope">b.slope</code></td>
<td>

<p>A vector of the AR(1) coefficients.
</p>
</td></tr>
<tr><td><code id="sim.pw.ar_+3A_br.loc">br.loc</code></td>
<td>

<p>A vector with the location of the change-points.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A simulated series
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cps=c(400,612)
y=sim.pw.ar(N =1024,sd_u = 1,b.slope=c(0.4,-0.6,0.5),br.loc=cps)[[2]]
ts.plot(y)
abline(v=cps,col="red")

</code></pre>

<hr>
<h2 id='sim.pw.ar2'>
Simulation of a piecewise constant AR(2) model
</h2><span id='topic+sim.pw.ar2'></span>

<h3>Description</h3>

<p>The function simulates a piecewise constant AR(2) model with multiple change-points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.pw.ar2(N, sd_u, b.slope, b.slope2, br.loc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.pw.ar2_+3A_n">N</code></td>
<td>

<p>Length of the series
</p>
</td></tr>
<tr><td><code id="sim.pw.ar2_+3A_sd_u">sd_u</code></td>
<td>

<p>A vector of the innovation standard deviation for every segment
</p>
</td></tr>
<tr><td><code id="sim.pw.ar2_+3A_b.slope">b.slope</code></td>
<td>

<p>A vector of the AR(1) coefficients
</p>
</td></tr>
<tr><td><code id="sim.pw.ar2_+3A_b.slope2">b.slope2</code></td>
<td>

<p>A vector of the AR(2) coefficients
</p>
</td></tr>
<tr><td><code id="sim.pw.ar2_+3A_br.loc">br.loc</code></td>
<td>

<p>A vector with the location of the change-points
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A simulated series
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
cps=c(512,754)
y=sim.pw.ar2(N =1024,sd_u = 1,b.slope=c(0.9,1.68,1.32),
b.slope2 = c(0.0,-0.81,-0.81),br.loc = cps)[[2]]
ts.plot(y)
abline(v=cps,col="red")

</code></pre>

<hr>
<h2 id='sim.pw.arma'>
Simulation of a piecewise constant ARMA(p,q) model for p=2 and q=1
</h2><span id='topic+sim.pw.arma'></span>

<h3>Description</h3>

<p>The function simulates a piecewise constant ARMA model with multiple change-points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.pw.arma(N, sd_u, b.slope, b.slope2, mac, br.loc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.pw.arma_+3A_n">N</code></td>
<td>

<p>Length of the series
</p>
</td></tr>
<tr><td><code id="sim.pw.arma_+3A_sd_u">sd_u</code></td>
<td>

<p>A vector of the innovation standard deviation for every segment
</p>
</td></tr>
<tr><td><code id="sim.pw.arma_+3A_b.slope">b.slope</code></td>
<td>

<p>A vector of the AR(1) coefficients
</p>
</td></tr>
<tr><td><code id="sim.pw.arma_+3A_b.slope2">b.slope2</code></td>
<td>

<p>A vector of the AR(2) coefficients
</p>
</td></tr>
<tr><td><code id="sim.pw.arma_+3A_mac">mac</code></td>
<td>
<p>A vector of the MA(1) coefficients
</p>
</td></tr>
<tr><td><code id="sim.pw.arma_+3A_br.loc">br.loc</code></td>
<td>
<p>A vector with the location of the change-points
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A simulated series
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
cps=c(125,532,704)
y=sim.pw.arma(N = 1024,sd_u = 1,b.slope=c(0.7,0.3,0.9,0.1),
b.slope2 = c(0,0,0,0), mac = c(0.6,0.3,0,-0.5),br.loc = cps)[[2]]
ts.plot(y)
abline(v=cps,col="red")                    
</code></pre>

<hr>
<h2 id='tau.fun'>
Universal thresholds
</h2><span id='topic+tau.fun'></span>

<h3>Description</h3>

<p>The function returns <code class="reqn">C^{(i)}</code>. <code class="reqn">C^{(i)}</code> tends to increase as we move to coarser scales due to
the increasing dependence in the wavelet periodogram sequences. Since the method applies to non-dyadic structures it is reasonable to propose a general rule that will apply in most cases. To accomplish this the <code class="reqn">C^{(i)}</code> are obtained for <code class="reqn">T=50,100,...,6000</code>. Then, for each scale <code class="reqn">i</code> the following regression is fitted 
</p>
<p><code class="reqn">C^{(i)}=c_0^{(i)}+c_1^{(i)} T+ c_2^{(i)} \frac{1}{T} + c_3^{(i)} T^2 +\varepsilon.</code>
</p>
<p>The adjusted <code class="reqn">R^2</code> was above 90% for all the scales. Having estimated the values for <code class="reqn">\hat{c}_0^{(i)}, \hat{c}_1^{(i)}, \hat{c}_2^{(i)}, \hat{c}_3^{(i)}</code> the values can be retrieved for any sample size <code class="reqn">T</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tau.fun(y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tau.fun_+3A_y">y</code></td>
<td>

<p>A time series
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Thresholds for every wavelet scale
</p>


<h3>Author(s)</h3>

<p>K. Korkas and P. Fryzlewicz
</p>


<h3>References</h3>

<p>P. Fryzlewicz (2014), Wild Binary Segmentation for multiple change-point detection. Annals of
Statistics, 42, 2243-2281. (http://stats.lse.ac.uk/fryzlewicz/wbs/wbs.pdf)
</p>
<p>K. Korkas and P. Fryzlewicz (2017), Multiple change-point detection for non-stationary time series using Wild Binary Segmentation. Statistica Sinica, 27, 287-311. (http://stats.lse.ac.uk/fryzlewicz/WBS_LSW/WBS_LSW.pdf)
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
##not run##
#cps=c(400,470)
#set.seed(101)
#y=sim.pw.ar(N =2000,sd_u = 1,b.slope=c(0.4,-0.6,0.5),br.loc=cps)[[2]]
#tau.fun(y) is the default value for C_i
##Binary segmentation
#wbs.lsw(y,M=1)$cp.aft
##Wild binary segmentation
#wbs.lsw(y,M=3500)$cp.aft

</code></pre>

<hr>
<h2 id='uh.wbs'>
The Wild Binary Segmentation algorithm
</h2><span id='topic+uh.wbs'></span>

<h3>Description</h3>

<p>The function implements the Wild Binary Segmentation method and aggregates the change-points across the wavelet periodogram. Currently only the Method 2 of aggregation is implemented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uh.wbs(z,C_i, del=-1, epp, scale,M=0,cstar=0.75)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uh.wbs_+3A_z">z</code></td>
<td>

<p>The wavelet periodogram matrix.
</p>
</td></tr>
<tr><td><code id="uh.wbs_+3A_c_i">C_i</code></td>
<td>

<p>The CUSUM threshold.
</p>
</td></tr>
<tr><td><code id="uh.wbs_+3A_del">del</code></td>
<td>

<p>The minimum allowed size of a segment.
</p>
</td></tr>
<tr><td><code id="uh.wbs_+3A_epp">epp</code></td>
<td>

<p>A minimum adjustment for the bias present in <code class="reqn">E^{(i)}_{t,T}</code>.
</p>
</td></tr>
<tr><td><code id="uh.wbs_+3A_scale">scale</code></td>
<td>

<p>Which wavelet periodogram scales to be used.
</p>
</td></tr>
<tr><td><code id="uh.wbs_+3A_m">M</code></td>
<td>

<p>The maximum number of random intervals drawn. If M=0 (DEFAULT) this is selected to be a linear function of the sample size of y. If M=1 then the segmentation is conducted via the Binary segmentation method.
</p>
</td></tr>
<tr><td><code id="uh.wbs_+3A_cstar">cstar</code></td>
<td>

<p>This refers to the unbalanceness parameter <code class="reqn">c_{\star}</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>cp.bef</code></td>
<td>
<p>Returns the estimated change-points before post-processing</p>
</td></tr>
<tr><td><code>cp.aft</code></td>
<td>
<p>Returns the estimated change-points after post-processing</p>
</td></tr>
</table>


<h3>References</h3>

<p>K. Korkas and P. Fryzlewicz (2017), Multiple change-point detection for non-stationary time series using Wild Binary Segmentation. Statistica Sinica, 27, 287-311. (http://stats.lse.ac.uk/fryzlewicz/WBS_LSW/WBS_LSW.pdf)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### Generate a highly persistent time series with changing variance and of length 5,000
###Location of the change-points
#cps=seq(from=1000,to=2800,by=200)
#y=sim.pw.arma(N =3000,sd_u = c(1,1.5,1,1.5,1,1.5,1,1.5,1,1.5,1),
#b.slope=rep(0.99,11),b.slope2 = rep(0.,11), mac = rep(0.,11),br.loc = cps)[[2]]
###Estimate the change points via Binary Segmentation
#wbs.lsw(y,M=1)$cp.aft
###Estimate the change points via Wild Binary Segmentation
#wbs.lsw(y,M=0)$cp.aft

</code></pre>

<hr>
<h2 id='wbs.lsw'>
Change point detection for a nonstationary process using Wild Binary Segmentation
</h2><span id='topic+wbs.lsw'></span>

<h3>Description</h3>

<p>The function returns the estimated locations of the change-points in a nonstationary time series. Currently only the Method 2 of aggregation is implemented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wbs.lsw(y, C_i = tau.fun(y), scales = NULL, M = 0, cstar = 0.75, lambda = 0.75)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wbs.lsw_+3A_y">y</code></td>
<td>

<p>The time series.
</p>
</td></tr>
<tr><td><code id="wbs.lsw_+3A_c_i">C_i</code></td>
<td>

<p>A vector of threshold parameters for different scales.
</p>
</td></tr>
<tr><td><code id="wbs.lsw_+3A_scales">scales</code></td>
<td>

<p>The wavelet periodogram scales to be used. If NULL (DEFAULT) then this is selected as described in the main text.
</p>
</td></tr>
<tr><td><code id="wbs.lsw_+3A_m">M</code></td>
<td>

<p>The maximum number of random intervals drawn. If M=0 (DEFAULT) this is selected to be a linear function of the sample size of y. If M=1 then the segmentation is conducted via the Binary segmentation method.
</p>
</td></tr>
<tr><td><code id="wbs.lsw_+3A_cstar">cstar</code></td>
<td>

<p>This refers to the unbalanceness parameter <code class="reqn">c_{\star}</code>.
</p>
</td></tr>
<tr><td><code id="wbs.lsw_+3A_lambda">lambda</code></td>
<td>

<p>This parameter defines the maximum number of the wavelet periodogam scales. This is used if scales = NULL.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>cp.bef</code></td>
<td>
<p>Returns the estimated change-points before post-processing</p>
</td></tr>
<tr><td><code>cp.aft</code></td>
<td>
<p>Returns the estimated change-points after post-processing</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>K. Korkas and P. Fryzlewicz
</p>


<h3>References</h3>

<p>K. Korkas and P. Fryzlewicz (2017), Multiple change-point detection for non-stationary time series using Wild Binary Segmentation. Statistica Sinica, 27, 287-311. (http://stats.lse.ac.uk/fryzlewicz/WBS_LSW/WBS_LSW.pdf)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### Generate a highly persistent time series with changing variance and of length 5,000
###Location of the change-points
#cps=seq(from=1000,to=2800,by=200)
#y=sim.pw.arma(N =3000,sd_u = c(1,1.5,1,1.5,1,1.5,1,1.5,1,1.5,1),
#b.slope=rep(0.99,11),b.slope2 = rep(0.,11), mac = rep(0.,11),br.loc = cps)[[2]]
###Estimate the change points via Binary Segmentation
#wbs.lsw(y,M=1)$cp.aft
###Estimate the change points via Wild Binary Segmentation
#wbs.lsw(y,M=0)$cp.aft

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
