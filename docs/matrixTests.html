<!DOCTYPE html><html><head><title>Help for package matrixTests</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {matrixTests}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#andersondarling'><p>Anderson-Darling test</p></a></li>
<li><a href='#bartlett'><p>Bartlett test</p></a></li>
<li><a href='#cortest'><p>Correlation</p></a></li>
<li><a href='#cosinor'><p>Cosinor</p></a></li>
<li><a href='#fligner'><p>Fligner-Killeen test</p></a></li>
<li><a href='#fvar'><p>F Variance test</p></a></li>
<li><a href='#jarquebera'><p>Jarque-Bera test</p></a></li>
<li><a href='#kolmogorov'><p>Kolmogorov-Smirnov test</p></a></li>
<li><a href='#kruskalwallis'><p>Kruskal-Wallis rank sum test</p></a></li>
<li><a href='#levene'><p>Levene test</p></a></li>
<li><a href='#oneway'><p>Oneway ANOVA</p></a></li>
<li><a href='#ttest'><p>t-test</p></a></li>
<li><a href='#waerden'><p>Van der Waerden test</p></a></li>
<li><a href='#wilcoxon'><p>Wilcoxon test</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Fast Statistical Hypothesis Tests on Rows and Columns of
Matrices</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.3</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Karolis Koncevičius &lt;karolis.koncevicius@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to perform fast statistical hypothesis tests on rows/columns of matrices.
  The main goals are: 1) speed via vectorization, 2) output that is detailed and easy to use,
  3) compatibility with tests implemented in R (like those available in the 'stats' package).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>matrixStats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>PMCMRplus, car, cosinor, cosinor2, moments, nortest</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/karoliskoncevicius/matrixTests">https://github.com/karoliskoncevicius/matrixTests</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/karoliskoncevicius/matrixTests/issues">https://github.com/karoliskoncevicius/matrixTests/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-05 19:28:26 UTC; karolis</td>
</tr>
<tr>
<td>Author:</td>
<td>Karolis Koncevičius [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-05 22:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='andersondarling'>Anderson-Darling test</h2><span id='topic+andersondarling'></span><span id='topic+row_andersondarling'></span><span id='topic+col_andersondarling'></span>

<h3>Description</h3>

<p>Performs Anderson-Darling goodness of fit test for normality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_andersondarling(x)

col_andersondarling(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="andersondarling_+3A_x">x</code></td>
<td>
<p>numeric matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>row_andersondarling(x)</code> - Anderson-Darling test on rows.
<code>col_andersondarling(x)</code> - Anderson-Darling test on columns.
</p>
<p>Results should be the same as running <code>nortest::ad.test(x)</code>
on every row (or column) of <code>x</code>
</p>


<h3>Value</h3>

<p>a data.frame where each row contains the results of Anderson-Darling
test performed on the corresponding row/column of x.<br /><br />
Each row contains the following information (in order):<br />
1. obs - number of observations<br />
2. statistic - test statistic<br />
3. pvalue - p-value
</p>


<h3>Author(s)</h3>

<p>Karolis Koncevičius
</p>


<h3>See Also</h3>

<p><code>shapiro.test()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>col_andersondarling(iris[,1:4])
row_andersondarling(t(iris[,1:4]))

</code></pre>

<hr>
<h2 id='bartlett'>Bartlett test</h2><span id='topic+bartlett'></span><span id='topic+row_bartlett'></span><span id='topic+col_bartlett'></span>

<h3>Description</h3>

<p>Performs the Bartlett's test of homogeneity of variances on each row/column
of the input matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_bartlett(x, g)

col_bartlett(x, g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bartlett_+3A_x">x</code></td>
<td>
<p>numeric matrix.</p>
</td></tr>
<tr><td><code id="bartlett_+3A_g">g</code></td>
<td>
<p>a vector specifying group membership for each observation of x.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NA values are always ommited. If values are missing for a whole group - that
group is discarded. Groups with only one observation are also discarded.
</p>
<p><code>row_bartlett(x, g)</code> - Bartlet's test on rows.
<code>col_bartlett(x, g)</code> - Bartlet's test on columns.
</p>
<p>Results should be the same as as running <code>bartlett.test(x, g)</code>
on every row (or column) of <code>x</code>.
</p>


<h3>Value</h3>

<p>a data.frame where each row contains the results of the bartlett test
performed on the corresponding row/column of x.<br /><br />
Each row contains the following information (in order):<br />
1. obs.tot - total number of observations<br />
2. obs.groups - number of groups<br />
3. var.pooled - pooled variance estimate<br />
4. df - degrees of freedom<br />
5. statistic - chi-squared statistic<br />
6. pvalue - p-value
</p>


<h3>Author(s)</h3>

<p>Karolis Koncevičius
</p>


<h3>See Also</h3>

<p><code>bartlett.test()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>col_bartlett(iris[,1:4], iris$Species)
row_bartlett(t(iris[,1:4]), iris$Species)

</code></pre>

<hr>
<h2 id='cortest'>Correlation</h2><span id='topic+cortest'></span><span id='topic+row_cor_pearson'></span><span id='topic+col_cor_pearson'></span>

<h3>Description</h3>

<p>Performs a correlation test on each row/column of a the input matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_cor_pearson(x, y, alternative = "two.sided", conf.level = 0.95)

col_cor_pearson(x, y, alternative = "two.sided", conf.level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cortest_+3A_x">x</code></td>
<td>
<p>numeric matrix.</p>
</td></tr>
<tr><td><code id="cortest_+3A_y">y</code></td>
<td>
<p>numeric matrix for the second group of observations.</p>
</td></tr>
<tr><td><code id="cortest_+3A_alternative">alternative</code></td>
<td>
<p>alternative hypothesis to use for each row/column of x.
A single string or a vector with value for each observation.
Must be one of &quot;two.sided&quot; (default), &quot;greater&quot; or &quot;less&quot;.</p>
</td></tr>
<tr><td><code id="cortest_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence levels used for the confidence intervals.
A single number or a numeric vector with value for each observation.
All values must be in the range of [0;1] or NA.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions to perform various correlation tests for rows/columns of matrices.
Main arguments and results were intentionally matched to the <code>cor.test()</code>
function from default stats package.
</p>
<p><code>row_cor_pearson(x, y)</code> - test for Pearson correlation on rows.
<code>col_cor_pearson(x, y)</code> - test for Pearson correlation on columns.
</p>
<p>Results should be the same as running <code>cor.test(x, y, method="pearson")</code>
on every row (or column) of <code>x</code> and <code>y</code>.
</p>


<h3>Value</h3>

<p>a data.frame where each row contains the results of a correlation
test performed on the corresponding row/column of x.<br /><br />
Each row contains the following information (in order):<br />
1. obs.paired - number of paired observations (present in x and y)<br />
2. cor - estimated correlation coefficient<br />
3. df - degrees of freedom<br />
4. statistic - t statistic<br />
5. pvalue - p-value<br />
6. conf.low - lower confidence interval<br />
7. conf.high - higher confidence interval<br />
8. alternative - chosen alternative hypothesis<br />
9. cor.null - correlation of the null hypothesis (=0)<br />
10. conf.level - chosen confidence level
</p>


<h3>Note</h3>

<p>For a marked increase in computation speed turn off the calculation of
confidence interval by setting <code>conf.level</code> to NA.
</p>


<h3>Author(s)</h3>

<p>Karolis Koncevičius
</p>


<h3>See Also</h3>

<p><code>cor.test()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- iris[iris$Species=="setosa",1:4]
Y &lt;- iris[iris$Species=="virginica",1:4]
col_cor_pearson(X, Y)
row_cor_pearson(t(X), t(Y))

</code></pre>

<hr>
<h2 id='cosinor'>Cosinor</h2><span id='topic+cosinor'></span><span id='topic+row_cosinor'></span><span id='topic+col_cosinor'></span>

<h3>Description</h3>

<p>Performs a Cosinor test for periodicity on each row/column of the input matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_cosinor(x, t, period = 24)

col_cosinor(x, t, period = 24)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cosinor_+3A_x">x</code></td>
<td>
<p>numeric matrix.</p>
</td></tr>
<tr><td><code id="cosinor_+3A_t">t</code></td>
<td>
<p>a vector specifying time variable for each observation of x.</p>
</td></tr>
<tr><td><code id="cosinor_+3A_period">period</code></td>
<td>
<p>oscillation period in the units of <code>t</code> (default = 24, suitable when inspecting diurnal rhythms with hourly data).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>row_cosinor</code> - cosinor test on rows.
<code>col_cosinor</code> - cosinor test on columns.
</p>


<h3>Value</h3>

<p>a data.frame where each row contains the results of a cosinor test
performed on the corresponding row/column of x.<br /><br />
Each row contains the following information (in order):<br />
1. obs - total number of observations<br />
2. mesor - &quot;Midline Estimating Statistic Of Rhythm&quot; - the average value around which the variable oscillates<br />
3. amplitude - difference between mesor and the peak of the rhythm<br />
4. acrophase - time when rhythm reaches its peak<br />
5. rsquared - R-squared<br />
6. df.model - model terms degrees of freedom<br />
7. df.residual - residual degrees of freedom<br />
8. statistic - F statistic for the omnibus test against intercept-only model<br />
9. pvalue - p-value<br />
10. period - the period used within the model<br />
</p>


<h3>Author(s)</h3>

<p>Karolis Koncevičius
</p>


<h3>See Also</h3>

<p><code><a href="cosinor.html#topic+cosinor.lm">cosinor.lm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wave &lt;- sin(2*pi*1:24/24) + rnorm(24)
row_cosinor(wave, 1:24, 24)

</code></pre>

<hr>
<h2 id='fligner'>Fligner-Killeen test</h2><span id='topic+fligner'></span><span id='topic+row_flignerkilleen'></span><span id='topic+col_flignerkilleen'></span>

<h3>Description</h3>

<p>Performs the Fligner-Killeen test of homogeneity of variances (with median
centering of the groups) on each row/column of the input matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_flignerkilleen(x, g)

col_flignerkilleen(x, g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fligner_+3A_x">x</code></td>
<td>
<p>numeric matrix.</p>
</td></tr>
<tr><td><code id="fligner_+3A_g">g</code></td>
<td>
<p>a vector specifying group membership for each observation of x.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NA values are always ommited. If values are missing for a whole group - that
group is discarded. Groups with only one observation are also discarded.
</p>
<p><code>row_flignerkilleen(x, g)</code> - Fligner-Killeen test on rows.
<code>col_flignerkilleen(x, g)</code> - Fligner-Killeen test on columns.
</p>
<p>Results should be the same as as running <code>fligner.test(x, g)</code>
on every row (or column) of <code>x</code>.
</p>


<h3>Value</h3>

<p>a data.frame where each row contains the results of the
Fligner-Killeen test performed on the corresponding row/column of x.<br /><br />
Each row contains the following information (in order):<br />
1. obs.tot - total number of observations<br />
2. obs.groups - number of groups<br />
3. df - degrees of freedom<br />
4. statistic - squared statistic<br />
5. pvalue - p-value
</p>


<h3>Author(s)</h3>

<p>Karolis Koncevičius
</p>


<h3>See Also</h3>

<p><code>fligner.test()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>col_flignerkilleen(iris[,1:4], iris$Species)
row_flignerkilleen(t(iris[,1:4]), iris$Species)

</code></pre>

<hr>
<h2 id='fvar'>F Variance test</h2><span id='topic+fvar'></span><span id='topic+row_f_var'></span><span id='topic+col_f_var'></span>

<h3>Description</h3>

<p>Performs the F test of equality of variances for two normal populations on
each row/column of the two input matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_f_var(x, y, null = 1, alternative = "two.sided", conf.level = 0.95)

col_f_var(x, y, null = 1, alternative = "two.sided", conf.level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fvar_+3A_x">x</code></td>
<td>
<p>numeric matrix.</p>
</td></tr>
<tr><td><code id="fvar_+3A_y">y</code></td>
<td>
<p>numeric matrix for the second group of observations.</p>
</td></tr>
<tr><td><code id="fvar_+3A_null">null</code></td>
<td>
<p>- hypothesized 'x' and 'y' variance ratio.
A single number or numeric vector with values for each observation.</p>
</td></tr>
<tr><td><code id="fvar_+3A_alternative">alternative</code></td>
<td>
<p>alternative hypothesis to use for each row/column of x.
A single string or a vector with values for each observation.
Values must be one of &quot;two.sided&quot; (default), &quot;greater&quot; or &quot;less&quot;.</p>
</td></tr>
<tr><td><code id="fvar_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence levels used for the confidence intervals.
A single number or a numeric vector with values for each observation.
All values must be in the range of [0:1] or NA.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NA values are always ommited.
</p>
<p><code>row_f_var(x, y)</code> - F-test for variance on rows.
<code>col_f_var(x, y)</code> - F-test for variance on columns.
</p>
<p>Results should be the same as as running <code>var.test(x, y)</code>
on every row (or column) of <code>x</code> and <code>y</code>.
</p>


<h3>Value</h3>

<p>a data.frame where each row contains the results of the F variance
test performed on the corresponding row/column of x and y.<br /><br />
Each row contains the following information (in order):<br />
1. obs.x - number of x observations<br />
2. obs.y - number of y observations<br />
3. obs.tot - total number of observations<br />
4. var.x - variance of x<br />
5. var.y - variance of y<br />
6. var.ratio - x/y variance ratio<br />
7. df.num - numerator degrees of freedom<br />
8. df.denom - denominator degrees of freedom<br />
9. statistic - F statistic<br />
10 pvalue - p-value<br />
11. conf.low - lower bound of the confidence interval<br />
12. conf.high - higher bound of the confidence interval<br />
13. ratio.null - variance ratio of the null hypothesis<br />
14. alternative - chosen alternative hypothesis<br />
15. conf.level - chosen confidence level
</p>


<h3>Note</h3>

<p>For a marked increase in computation speed turn off the calculation of
confidence interval by setting <code>conf.level</code> to NA.
</p>


<h3>Author(s)</h3>

<p>Karolis Koncevičius
</p>


<h3>See Also</h3>

<p><code>var.test()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- iris[iris$Species=="setosa",1:4]
Y &lt;- iris[iris$Species=="virginica",1:4]
col_f_var(X, Y)

</code></pre>

<hr>
<h2 id='jarquebera'>Jarque-Bera test</h2><span id='topic+jarquebera'></span><span id='topic+row_jarquebera'></span><span id='topic+col_jarquebera'></span>

<h3>Description</h3>

<p>Performs Jarque-Bera goodness of fit test for normality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_jarquebera(x)

col_jarquebera(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jarquebera_+3A_x">x</code></td>
<td>
<p>numeric matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>row_jarquebera(x)</code> - Jarque-Bera test on rows.
<code>col_jarquebera(x)</code> - Jarque-Bera test on columns.
</p>
<p>Results should be the same as running <code>moments::jarque.test(x)</code>
on every row (or column) of <code>x</code>
</p>


<h3>Value</h3>

<p>a data.frame where each row contains the results of Jarque-Bera
test performed on the corresponding row/column of x.<br /><br />
Each row contains the following information (in order):<br />
1. obs - number of observations<br />
2. skewness - skewness<br />
3. kurtosis - kurtosis<br />
4. df - degrees of freedom<br />
5. statistic - chi-squared statistic<br />
6. pvalue - p-value
</p>


<h3>Author(s)</h3>

<p>Karolis Koncevičius
</p>


<h3>See Also</h3>

<p><code>shapiro.test()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>col_jarquebera(iris[,1:4])
row_jarquebera(t(iris[,1:4]))

</code></pre>

<hr>
<h2 id='kolmogorov'>Kolmogorov-Smirnov test</h2><span id='topic+kolmogorov'></span><span id='topic+row_kolmogorovsmirnov_twosample'></span><span id='topic+col_kolmogorovsmirnov_twosample'></span>

<h3>Description</h3>

<p>Performs a Kolmogorov-Smirnov test on each row/column of the input matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_kolmogorovsmirnov_twosample(x, y, alternative = "two.sided", exact = NA)

col_kolmogorovsmirnov_twosample(x, y, alternative = "two.sided", exact = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kolmogorov_+3A_x">x</code></td>
<td>
<p>numeric matrix.</p>
</td></tr>
<tr><td><code id="kolmogorov_+3A_y">y</code></td>
<td>
<p>numeric matrix for the second group of observations.</p>
</td></tr>
<tr><td><code id="kolmogorov_+3A_alternative">alternative</code></td>
<td>
<p>alternative hypothesis to use for each row/column of x.
A single string or a vector with values for each observation.
Values must be one of &quot;two.sided&quot; (default), &quot;greater&quot; or &quot;less&quot;.</p>
</td></tr>
<tr><td><code id="kolmogorov_+3A_exact">exact</code></td>
<td>
<p>logical or NA (default) indicator whether an exact p-value should be computed (see Details).
A single value or a logical vector with values for each observation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function to perform two sample Kolmogorov-Smirnov test on rows/columns of
matrices. Main arguments and results were intentionally matched to the
<code>ks.test()</code> function from default stats package.
</p>
<p>Results should be the same as running <code>ks.test(x, y)</code> on every row (or
column) of <code>x</code> and <code>y</code>.
</p>
<p>By default if 'exact' argument is set to 'NA', exact p-values are computed
if the product of 'x' and 'y' sample sizes is less than 10000. Otherwise,
asymptotic distributions are used.
</p>
<p>Alternative hypothesis setting specifies null and alternative hypotheses.
The possible values of 'two sided', 'less', and 'greater'.
'two sided' sets the null hypothesis for the distributions of 'x' being equal to the distribution 'y'.
'less' sets the null hypothesis for the distribution of x not being less than the distribution of y.
'greater' sets the null hypothesis for the distribution of x not being greater than the distribution of y.
See <code>help(ks.test)</code> for more details.
</p>


<h3>Value</h3>

<p>a data.frame where each row contains the results of a Kolmogorov-Smirnov test
performed on the corresponding row/column of x and y.
Each row contains the following information (in order):<br />
1. obs.x - number of x observations<br />
2. obs.y - number of y observations<br />
3. obs.tot - total number of observations<br />
5. statistic - Wilcoxon test statistic<br />
6. pvalue - p-value<br />
8. alternative - chosen alternative hypothesis<br />
9. exact - indicates if exact p-value was computed<br />
</p>


<h3>Author(s)</h3>

<p>Karolis Koncevičius
</p>


<h3>See Also</h3>

<p><code>ks.test()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- iris[iris$Species=="setosa", 1:4]
Y &lt;- iris[iris$Species=="virginica", 1:4]
col_kolmogorovsmirnov_twosample(X, Y)

# same column using different alternative hypotheses
col_kolmogorovsmirnov_twosample(X[,c(1,1,1)], Y[,c(1,1,1)], alternative=c("t", "g", "l"))

</code></pre>

<hr>
<h2 id='kruskalwallis'>Kruskal-Wallis rank sum test</h2><span id='topic+kruskalwallis'></span><span id='topic+row_kruskalwallis'></span><span id='topic+col_kruskalwallis'></span>

<h3>Description</h3>

<p>Performs a Kruskal-Wallis rank sum test on each row/column of the input matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_kruskalwallis(x, g)

col_kruskalwallis(x, g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kruskalwallis_+3A_x">x</code></td>
<td>
<p>numeric matrix.</p>
</td></tr>
<tr><td><code id="kruskalwallis_+3A_g">g</code></td>
<td>
<p>a vector specifying group membership for each observation of x.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>row_kruskalwallis(x, g)</code> - Kruskal Wallis test on rows.
<code>col_kruskalwallis(x, g)</code> - Kruskal Wallis test on columns.
</p>
<p>Results should be the same as running <code>kruskal.test(x, g)</code>
on every row (or column) of <code>x</code>
</p>


<h3>Value</h3>

<p>a data.frame where each row contains the results of a Kruskal-Wallis
test performed on the corresponding row/column of x.<br /><br />
Each row contains the following information (in order):<br />
1. obs.tot - total number of observations<br />
2. obs.groups - number of groups<br />
4. df - degrees of freedom<br />
5. statistic - chi-squared statistic<br />
6. pvalue - p.value
</p>


<h3>Author(s)</h3>

<p>Karolis Koncevičius
</p>


<h3>See Also</h3>

<p><code>kruskal.test()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>col_kruskalwallis(iris[,1:4], iris$Species)
row_kruskalwallis(t(iris[,1:4]), iris$Species)

</code></pre>

<hr>
<h2 id='levene'>Levene test</h2><span id='topic+levene'></span><span id='topic+row_levene'></span><span id='topic+col_levene'></span><span id='topic+row_brownforsythe'></span><span id='topic+col_brownforsythe'></span>

<h3>Description</h3>

<p>Levene's test and Brown-Forsythe test for equality of variances
between groups on each row/column of the input matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_levene(x, g)

col_levene(x, g)

row_brownforsythe(x, g)

col_brownforsythe(x, g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="levene_+3A_x">x</code></td>
<td>
<p>numeric matrix.</p>
</td></tr>
<tr><td><code id="levene_+3A_g">g</code></td>
<td>
<p>a vector specifying group membership for each observation of x.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NA values are always ommited.
If values are missing for a whole group - that group is discarded.
</p>
<p><code>row_levene(x, g)</code> - Levene's test on rows.
<code>col_levene(x, g)</code> - Levene's test on columns.
</p>
<p><code>row_brownforsythe(x, g)</code> - Brown-Forsythe test on rows.
<code>col_brownforsythe(x, g)</code> - Brown-Forsythe test on columns.
</p>


<h3>Value</h3>

<p>a data.frame where each row contains the results of the Levene's test
performed on the corresponding row/column of x.<br /><br />
Each row contains the following information (in order):<br />
1. obs.tot - total number of observations<br />
2. obs.groups - number of groups<br />
3. df.between - between group (treatment) degrees of freedom<br />
4. df.within - within group (residual) degrees of freedom<br />
5. statistic - F statistic<br />
6. pvalue - p.value
</p>


<h3>Note</h3>

<p>Difference between Levene's test and Brown-Forsythe test is that
the Brown-Forsythe test uses the median instead of the mean in computing the
spread within each group. Many software implementations use the name
&quot;Levene's test&quot; for both variants.
</p>


<h3>Author(s)</h3>

<p>Karolis Koncevičius
</p>


<h3>See Also</h3>

<p><code><a href="car.html#topic+leveneTest">leveneTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>col_levene(iris[,1:4], iris$Species)
row_brownforsythe(t(iris[,1:4]), iris$Species)

</code></pre>

<hr>
<h2 id='oneway'>Oneway ANOVA</h2><span id='topic+oneway'></span><span id='topic+row_oneway_equalvar'></span><span id='topic+col_oneway_equalvar'></span><span id='topic+row_oneway_welch'></span><span id='topic+col_oneway_welch'></span>

<h3>Description</h3>

<p>Performs an analysis of variance tests on each row/column of the input matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_oneway_equalvar(x, g)

col_oneway_equalvar(x, g)

row_oneway_welch(x, g)

col_oneway_welch(x, g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oneway_+3A_x">x</code></td>
<td>
<p>numeric matrix.</p>
</td></tr>
<tr><td><code id="oneway_+3A_g">g</code></td>
<td>
<p>a vector specifying group membership for each observation of x.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions to perform ONEWAY ANOVA analysis for rows/columns of matrices.
</p>
<p><code>row_oneway_equalvar(x, g)</code> - oneway ANOVA on rows.
<code>col_oneway_equalvar(x, g)</code> - oneway ANOVA on columns.
</p>
<p>Results should be the same as running <code>aov(x ~ g)</code>
on every row (or column) of <code>x</code>
</p>
<p><code>row_oneway_welch(x, g)</code> - oneway ANOVA with Welch correction on rows.
<code>col_oneway_welch(x, g)</code> - oneway ANOVA with Welch correction on columns.
</p>
<p>Results should be the same as running <code>oneway.test(x, g, var.equal=FALSE)</code>
on every row (or column) of <code>x</code>
</p>


<h3>Value</h3>

<p>a data.frame where each row contains the results of an oneway anova
test performed on the corresponding row/column of x.
The columns will vary depending on the type of test performed.<br /><br />
They will contain a subset of the following information:<br />
1. obs.tot - total number of observations<br />
2. obs.groups - number of groups<br />
3. sumsq.between - between group (treatment) sum of squares<br />
4. sumsq.within - within group (residual) sum of squares<br />
5. meansq.between - between group mean squares<br />
6. meansq.within - within group mean squares<br />
7. df.between - between group (treatment) degrees of freedom<br />
8. df.within - within group (residual) degrees of freedom<br />
9. statistic - F statistic<br />
10. pvalue - p.value
</p>


<h3>Author(s)</h3>

<p>Karolis Koncevičius
</p>


<h3>See Also</h3>

<p><code>aov()</code>, <code>oneway.test()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>col_oneway_welch(iris[,1:4], iris$Species)
row_oneway_equalvar(t(iris[,1:4]), iris$Species)

</code></pre>

<hr>
<h2 id='ttest'>t-test</h2><span id='topic+ttest'></span><span id='topic+row_t_equalvar'></span><span id='topic+col_t_equalvar'></span><span id='topic+row_t_welch'></span><span id='topic+col_t_welch'></span><span id='topic+row_t_onesample'></span><span id='topic+col_t_onesample'></span><span id='topic+row_t_paired'></span><span id='topic+col_t_paired'></span>

<h3>Description</h3>

<p>Performs a t-test on each row/column of the input matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_t_equalvar(x, y, null = 0, alternative = "two.sided", conf.level = 0.95)

col_t_equalvar(x, y, null = 0, alternative = "two.sided", conf.level = 0.95)

row_t_welch(x, y, null = 0, alternative = "two.sided", conf.level = 0.95)

col_t_welch(x, y, null = 0, alternative = "two.sided", conf.level = 0.95)

row_t_onesample(x, null = 0, alternative = "two.sided", conf.level = 0.95)

col_t_onesample(x, null = 0, alternative = "two.sided", conf.level = 0.95)

row_t_paired(x, y, null = 0, alternative = "two.sided", conf.level = 0.95)

col_t_paired(x, y, null = 0, alternative = "two.sided", conf.level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ttest_+3A_x">x</code></td>
<td>
<p>numeric matrix.</p>
</td></tr>
<tr><td><code id="ttest_+3A_y">y</code></td>
<td>
<p>numeric matrix for the second group of observations.</p>
</td></tr>
<tr><td><code id="ttest_+3A_null">null</code></td>
<td>
<p>true values of the means for the null hypothesis.
A single number or numeric vector with values for each observation.</p>
</td></tr>
<tr><td><code id="ttest_+3A_alternative">alternative</code></td>
<td>
<p>alternative hypothesis to use for each row/column of x.
A single string or a vector with values for each observation.
Values must be one of &quot;two.sided&quot; (default), &quot;greater&quot; or &quot;less&quot;.</p>
</td></tr>
<tr><td><code id="ttest_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence levels used for the confidence intervals.
A single number or a numeric vector with values for each observation.
All values must be in the range of [0:1] or NA.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions to perform one sample and two sample t-tests for rows/columns of matrices.
Main arguments and results were intentionally matched to the <code>t.test()</code>
function from default stats package. Other arguments were split into separate
functions:
</p>
<p><code>row_t_onesample(x)</code> - one sample t-test on rows.
<code>col_t_onesample(x)</code> - one sample t-test on columns.
</p>
<p>Results should be the same as running <code>t.test(x)</code>
on every row (or column) of <code>x</code>.
</p>
<p><code>row_t_equalvar(x, y)</code> - two sample equal variance t-test on rows.
<code>col_t_equalvar(x, y)</code> - two sample equal variance t-test on columns.
</p>
<p>Results should be the same as running <code>t.test(x, y, var.equal=TRUE)</code>
on every row (or column) of <code>x</code> and <code>y</code>.
</p>
<p><code>row_t_welch(x, y)</code> - two sample t-test with Welch correction on rows.
<code>col_t_welch(x, y)</code> - two sample t-test with Welch correction on columns.
</p>
<p>Results should be the same as running <code>t.test(x, y)</code>
on every row (or column) of <code>x</code> and <code>y</code>.
</p>
<p><code>row_t_paired(x, y)</code> - two sample paired t-test on rows.
<code>col_t_paired(x, y)</code> - two sample paired t-test on columns.
</p>
<p>Results should be the same as running <code>t.test(x, y, paired=TRUE)</code>
on every row (or column) of <code>x</code> and <code>y</code>.
</p>


<h3>Value</h3>

<p>a data.frame where each row contains the results of a t.test
performed on the corresponding row/column of x.
The columns will vary depending on the type of test performed.<br /><br />
They will contain a subset of the following information:<br />
1. obs.x - number of x observations<br />
2. obs.y - number of y observations<br />
3. obs.tot - total number of observations<br />
4. obs.paired - number of paired observations (present in x and y)<br />
5. mean.x - mean estiamte of x<br />
6. mean.y - mean estiamte of y<br />
7. mean.diff - mean estiamte of x-y difference<br />
8. var.x - variance estiamte of x<br />
9. var.y - variance estiamte of y<br />
10. var.diff - variance estiamte of x-y difference<br />
11. var.pooled - pooled variance estimate of x and y<br />
12. stderr - standard error<br />
13. df - degrees of freedom<br />
14. statistic - t statistic<br />
15. pvalue - p-value<br />
16. conf.low - lower bound of the confidence interval<br />
17. conf.high - higher bound of the confidence interval<br />
18. mean.null - mean of the null hypothesis<br />
19. alternative - chosen alternative hypothesis<br />
20. conf.level - chosen confidence level
</p>


<h3>Note</h3>

<p>For a marked increase in computation speed turn off the calculation of
confidence interval by setting <code>conf.level</code> to NA.
</p>


<h3>Author(s)</h3>

<p>Karolis Koncevičius
</p>


<h3>See Also</h3>

<p><code>t.test()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- iris[iris$Species=="setosa",1:4]
Y &lt;- iris[iris$Species=="virginica",1:4]
col_t_welch(X, Y)

# same row using different confidence levels
col_t_equalvar(X[,c(1,1,1)], Y[,c(1,1,1)], conf.level=c(0.9, 0.95, 0.99))

</code></pre>

<hr>
<h2 id='waerden'>Van der Waerden test</h2><span id='topic+waerden'></span><span id='topic+row_waerden'></span><span id='topic+col_waerden'></span>

<h3>Description</h3>

<p>Performs van der Waerden test on each row/column of the input matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_waerden(x, g)

col_waerden(x, g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="waerden_+3A_x">x</code></td>
<td>
<p>numeric matrix.</p>
</td></tr>
<tr><td><code id="waerden_+3A_g">g</code></td>
<td>
<p>a vector specifying group membership for each observation of x.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>row_waerden(x, g)</code> - van der Waerden test on rows.
<code>col_waerden(x, g)</code> - van det Waerden test on columns.
</p>


<h3>Value</h3>

<p>a data.frame where each row contains the results of van det Waerden
test performed on the corresponding row/column of x.<br /><br />
Each row contains the following information (in order):<br />
1. obs.tot - total number of observations<br />
2. obs.groups - number of groups<br />
3. df - degrees of freedome<br />
4. statistic - van det Waerden chi-squared statistic<br />
5. pvalue - p.value
</p>


<h3>Author(s)</h3>

<p>Karolis Koncevičius
</p>


<h3>See Also</h3>

<p><code><a href="PMCMRplus.html#topic+vanWaerdenTest">vanWaerdenTest</a></code>, <code>row_oneway_equalvar</code>, <code>row_kruskalwallis</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>col_waerden(iris[,1:4], iris$Species)
row_waerden(t(iris[,1:4]), iris$Species)

</code></pre>

<hr>
<h2 id='wilcoxon'>Wilcoxon test</h2><span id='topic+wilcoxon'></span><span id='topic+row_wilcoxon_twosample'></span><span id='topic+col_wilcoxon_twosample'></span><span id='topic+row_wilcoxon_onesample'></span><span id='topic+col_wilcoxon_onesample'></span><span id='topic+row_wilcoxon_paired'></span><span id='topic+col_wilcoxon_paired'></span>

<h3>Description</h3>

<p>Performs a Wilcoxon test on each row/column of the input matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_wilcoxon_twosample(
  x,
  y,
  null = 0,
  alternative = "two.sided",
  exact = NA,
  correct = TRUE
)

col_wilcoxon_twosample(
  x,
  y,
  null = 0,
  alternative = "two.sided",
  exact = NA,
  correct = TRUE
)

row_wilcoxon_onesample(
  x,
  null = 0,
  alternative = "two.sided",
  exact = NA,
  correct = TRUE
)

col_wilcoxon_onesample(
  x,
  null = 0,
  alternative = "two.sided",
  exact = NA,
  correct = TRUE
)

row_wilcoxon_paired(
  x,
  y,
  null = 0,
  alternative = "two.sided",
  exact = NA,
  correct = TRUE
)

col_wilcoxon_paired(
  x,
  y,
  null = 0,
  alternative = "two.sided",
  exact = NA,
  correct = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wilcoxon_+3A_x">x</code></td>
<td>
<p>numeric matrix.</p>
</td></tr>
<tr><td><code id="wilcoxon_+3A_y">y</code></td>
<td>
<p>numeric matrix for the second group of observations.</p>
</td></tr>
<tr><td><code id="wilcoxon_+3A_null">null</code></td>
<td>
<p>true values of the location shift for the null hypothesis.
A single number or numeric vector with values for each observation.</p>
</td></tr>
<tr><td><code id="wilcoxon_+3A_alternative">alternative</code></td>
<td>
<p>alternative hypothesis to use for each row/column of x.
A single string or a vector with values for each observation.
Values must be one of &quot;two.sided&quot; (default), &quot;greater&quot; or &quot;less&quot;.</p>
</td></tr>
<tr><td><code id="wilcoxon_+3A_exact">exact</code></td>
<td>
<p>logical or NA (default) indicator whether an exact p-value
should be computed (see Details).
A single value or a logical vector with values for each observation.</p>
</td></tr>
<tr><td><code id="wilcoxon_+3A_correct">correct</code></td>
<td>
<p>logical indicator whether continuity correction should be
applied in the cases where p-values are obtained using normal approximation.
A single value or logical vector with values for each observation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions to perform one sample and two sample Wilcoxon tests on rows/columns of matrices.
Main arguments and results were intentionally matched to the <code>wilcox.test()</code>
function from default stats package. Other arguments were split into separate
functions:
</p>
<p><code>row_wilcoxon_onesample(x)</code> - one sample Wilcoxon test on rows.
<code>col_wilcoxon_onesample(x)</code> - one sample Wilcoxon test on columns.
</p>
<p>Results should be the same as running <code>wilcox.test(x)</code>
on every row (or column) of <code>x</code>.
</p>
<p><code>row_wilcoxon_twosample(x, y)</code> - two sample Wilcoxon test on rows.
<code>col_wilcoxon_twosample(x, y)</code> - two sample Wilcoxon test on columns.
</p>
<p>Results should be the same as running <code>wilcox.test(x, y)</code>
on every row (or column) of <code>x</code> and <code>y</code>.
</p>
<p><code>row_wilcoxon_paired(x, y)</code> - two sample paired Wilcoxon test on rows.
<code>col_wilcoxon_paired(x, y)</code> - two sample paired Wilcoxon test on columns.
</p>
<p>Results should be the same as running <code>wilcox.test(x, y, paired=TRUE)</code>
on every row (or column) of <code>x</code> and <code>y</code>.
</p>
<p>By default if 'exact' argument is set to 'NA', exact p-values are computed
only if both 'x' and 'y' contain less than 50 values and there are no
ties. Single sample and paired tests have additional requirement of not
having zeroe values (values equal to null hypothesis location argument 'mu').
Otherwise, a normal approximation is used. Be wary of using 'exact=TRUE' on
large sample sizes as computations can take a very long time.
</p>
<p>'correct' argument controls the continuity correction of p-values but only
when exact p-values cannot be computed and normal approximation is used.
For cases where exact p-values are returned 'correct' is switched to FALSE.
</p>


<h3>Value</h3>

<p>a data.frame where each row contains the results of a wilcoxon test
performed on the corresponding row/column of x.
The columns will vary depending on the type of test performed.<br /><br />
They will contain a subset of the following information:<br />
1. obs.x - number of x observations<br />
2. obs.y - number of y observations<br />
3. obs.tot - total number of observations<br />
4. obs.paired - number of paired observations (present in x and y)<br />
5. statistic - Wilcoxon test statistic<br />
6. pvalue - p-value<br />
7. location.null - location shift of the null hypothesis<br />
8. alternative - chosen alternative hypothesis<br />
9. exact - indicates if exact p-value was computed<br />
10. correct - indicates if continuity correction was performed
</p>


<h3>Note</h3>

<p>Confidence interval and pseudo-median calculations are not implemented.
</p>


<h3>Author(s)</h3>

<p>Karolis Koncevičius
</p>


<h3>See Also</h3>

<p><code>wilcox.test()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- iris[iris$Species=="setosa",1:4]
Y &lt;- iris[iris$Species=="virginica",1:4]
col_wilcoxon_twosample(X, Y)

# same row using different alternative hypotheses
col_wilcoxon_twosample(X[,c(1,1,1)], Y[,c(1,1,1)], alternative=c("t", "g", "l"))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
