<!DOCTYPE html><html><head><title>Help for package ChainLadder</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ChainLadder}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ABC'><p>Run off triangle of accumulated claims data</p></a></li>
<li><a href='#as.LongTriangle'><p>Convert Triangle from wide to long</p></a></li>
<li><a href='#ata'><p>Calculate Age-to-Age Factors</p></a></li>
<li><a href='#auto'><p>Run off triangle of accumulated claim data</p></a></li>
<li><a href='#AutoBI'><p>Run off triangles of accumulated claim data</p></a></li>
<li><a href='#BootChainLadder'><p> Bootstrap-Chain-Ladder Model</p></a></li>
<li><a href='#BS.paid.adj'><p> Berquist-Sherman Paid Claim Development Adjustment</p></a></li>
<li><a href='#CDR'>
<p>One year claims development result</p></a></li>
<li><a href='#chainladder'><p> Estimate age-to-age factors</p></a></li>
<li><a href='#ChainLadder-package'>
<p>Methods and Models for Claims Reserving</p></a></li>
<li><a href='#checkTriangleInflation'><p> Check Y-o-Y Triangle Inflation Rates</p></a></li>
<li><a href='#ClarkCapeCod'>
<p>Clark Cape Cod method</p></a></li>
<li><a href='#ClarkLDF'>
<p>Clark LDF method</p></a></li>
<li><a href='#CLFMdelta'><p> Find &quot;selection consistent&quot; values of delta</p></a></li>
<li><a href='#coef.ChainLadder'><p> Extract residuals of a ChainLadder model</p></a></li>
<li><a href='#Cumulative and incremental triangles'><p>Cumulative and incremental triangles</p></a></li>
<li><a href='#cyEffTest'><p> Testing for Calendar Year Effect</p></a></li>
<li><a href='#dfCorTest'><p> Testing for Correlations between Subsequent Development Factors</p></a></li>
<li><a href='#GenIns'>
<p>Run off triangle of claims data.</p></a></li>
<li><a href='#getLatestCumulative'>
<p>Triangle information for most recent calendar period.</p></a></li>
<li><a href='#glmReserve'>
<p>GLM-based Reserving Model</p></a></li>
<li><a href='#inflateTriangle'><p> Inflate a Triangle based on an Inflation Rate</p></a></li>
<li><a href='#Join2Fits'><p> Join Two Fitted MultiChainLadder Models</p></a></li>
<li><a href='#JoinFitMse'><p> Join Model Fit and Mse Estimation</p></a></li>
<li><a href='#liab'><p>Run off triangle of accumulated claim data</p></a></li>
<li><a href='#LRfunction'><p> Calculate the Link Ratio Function</p></a></li>
<li><a href='#M3IR5'>
<p>Run off triangle of claims data</p></a></li>
<li><a href='#MackChainLadder'><p> Mack Chain-Ladder Model</p></a></li>
<li><a href='#MCLpaid'><p>Run off triangles of accumulated paid and incurred claims data.</p></a></li>
<li><a href='#MedMal'><p>Run off triangles of accumulated claim data</p></a></li>
<li><a href='#Mortgage'><p>Run off triangle of accumulated claims data</p></a></li>
<li><a href='#Mse-methods'><p> Methods for Generic Function Mse</p></a></li>
<li><a href='#MultiChainLadder'><p> Multivariate Chain-Ladder Models</p></a></li>
<li><a href='#MultiChainLadder-class'><p>Class &quot;MultiChainLadder&quot; of Multivariate Chain-Ladder Results</p></a></li>
<li><a href='#MultiChainLadderFit-class'><p>Class &quot;MultiChainLadderFit&quot;, &quot;MCLFit&quot; and &quot;GMCLFit&quot;</p></a></li>
<li><a href='#MultiChainLadderMse-class'><p>Class &quot;MultiChainLadderMse&quot;</p></a></li>
<li><a href='#MultiChainLadderSummary-class'><p>Class &quot;MultiChainLadderSummary&quot;</p></a></li>
<li><a href='#MunichChainLadder'><p>Munich-chain-ladder Model</p></a></li>
<li><a href='#MW2008'><p>Run-off claims triangle</p></a></li>
<li><a href='#MW2014'><p>Run-off claims triangle</p></a></li>
<li><a href='#NullNum-class'><p>Class &quot;NullNum&quot;, &quot;NullChar&quot; and &quot;NullList&quot;</p></a></li>
<li><a href='#PaidIncurredChain'><p>PaidIncurredChain</p></a></li>
<li><a href='#plot-MultiChainLadder'><p> Methods for Function plot</p></a></li>
<li><a href='#plot.BootChainLadder'><p> Plot method for a BootChainLadder object</p></a></li>
<li><a href='#plot.checkTriangleInflation'><p> Plot method for a checkTriangleInflation object</p></a></li>
<li><a href='#plot.clark'><p>Plot Clark method residuals</p></a></li>
<li><a href='#plot.cyEffTest'><p> Plot method for a cyEffTest object</p></a></li>
<li><a href='#plot.dfCorTest'><p> Plot method for a dfCorTest object</p></a></li>
<li><a href='#plot.MackChainLadder'><p> Plot method for a MackChainLadder object</p></a></li>
<li><a href='#plot.MunichChainLadder'><p>  Plot method for a MunichChainLadder object</p></a></li>
<li><a href='#predict.TriangleModel'><p>Prediction of a claims triangle</p></a></li>
<li><a href='#print.ata'><p>Print Age-to-Age factors</p></a></li>
<li><a href='#print.checkTriangleInflation'><p> Print function for a checkTriangleInflation object</p></a></li>
<li><a href='#print.clark'><p>Print results of Clark methods</p></a></li>
<li><a href='#print.cyEffTest'><p> Print function for a cyEffTest object</p></a></li>
<li><a href='#print.dfCorTest'><p> Print function for a dfCorTest object</p></a></li>
<li><a href='#qpaid'><p>Quarterly run off triangle of accumulated claims data</p></a></li>
<li><a href='#quantile.MackChainLadder'><p> quantile function for Mack-chain-ladder</p></a></li>
<li><a href='#QuantileIFRS17'>
<p>Quantile estimation for the IFRS 17 Risk Adjustment</p></a></li>
<li><a href='#RAA'><p>Run off triangle of accumulated claims data</p></a></li>
<li><a href='#residCov'><p> Generic function for residCov and residCor</p></a></li>
<li><a href='#residuals.MackChainLadder'><p> Extract residuals of a MackChainLadder model</p></a></li>
<li><a href='#summary-methods'><p> Methods for Function summary</p></a></li>
<li><a href='#summary.ata'><p> Summary method for object of class 'ata'</p></a></li>
<li><a href='#summary.BootChainLadder'><p> Methods for BootChainLadder objects</p></a></li>
<li><a href='#summary.checkTriangleInflation'><p> Summary function for a checkTriangleInflation object</p></a></li>
<li><a href='#summary.clark'><p> Summary methods for Clark objects</p></a></li>
<li><a href='#summary.cyEffTest'><p> Summary function for a cyEffTest object</p></a></li>
<li><a href='#summary.dfCorTest'><p> Summary function for a dfCorTest object</p></a></li>
<li><a href='#summary.MackChainLadder'><p> Summary and print function for Mack-chain-ladder</p></a></li>
<li><a href='#summary.MunichChainLadder'><p> Summary and print function for Munich-chain-ladder</p></a></li>
<li><a href='#Table65'>
<p>Functions to Reproduce Clark's Tables</p></a></li>
<li><a href='#triangle S3 Methods'>
<p>Generic functions for triangles</p></a></li>
<li><a href='#triangles-class'><p>S4 Class &quot;triangles&quot;</p></a></li>
<li><a href='#tweedieReserve'>
<p>Tweedie Stochastic Reserving Model</p></a></li>
<li><a href='#tweedieReserve methods'>
<p>Reserve Risk Capital Report</p></a></li>
<li><a href='#UKMotor'>
<p>UK motor claims triangle</p></a></li>
<li><a href='#USAA triangle'>
<p>Example paid and incurred triangle data from CAS web site.</p></a></li>
<li><a href='#vcov.clark'><p>Covariance Matrix of Parameter Estimates &ndash; Clark's methods</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Statistical Methods and Models for Claims Reserving in General
Insurance</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.18</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-06-27</td>
</tr>
<tr>
<td>Description:</td>
<td>Various statistical methods and models which are
    typically used for the estimation of outstanding claims reserves
    in general insurance, including those to estimate the claims
    development result as required under Solvency II.</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, actuar, methods, stats, lattice, grid, tweedie, utils,
systemfit, statmod, cplm (&ge; 0.7-3), ggplot2, MASS</td>
</tr>
<tr>
<td>Suggests:</td>
<td>RUnit, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://mages.github.io/ChainLadder/">https://mages.github.io/ChainLadder/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mages/ChainLadder/issues">https://github.com/mages/ChainLadder/issues</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-27 11:16:44 UTC; mages</td>
</tr>
<tr>
<td>Author:</td>
<td>Markus Gesmann [aut, cre],
  Daniel Murphy [aut],
  Yanwei (Wayne) Zhang [aut],
  Alessandro Carrato [aut],
  Giuseppe Crupi [ctb],
  Christophe Dutang [ctb],
  Arnaud Lacoume [ctb],
  Arthur Charpentier [ctb],
  Mario Wuthrich [aut],
  Fabio Concina [aut],
  Eric Dal Moro [aut],
  Yuriy Krvavych [ctb],
  Vincent Goulet [ctb],
  Marco De Virgilis [ctb],
  Marco Spina [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Markus Gesmann &lt;markus.gesmann@googlemail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-27 11:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ABC'>Run off triangle of accumulated claims data</h2><span id='topic+ABC'></span>

<h3>Description</h3>

<p>Run-off triangle of a worker's compensation portfolio of a large company</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ABC)</code></pre>


<h3>Format</h3>

<p>A matrix with 11 accident years and 11 development years.
</p>


<h3>Source</h3>

<p><cite>B. Zehnwirth and G. Barnett. Best Estimates for Reserves. <em>Proceedings of the CAS.</em> Volume LXXXVII. Number 167.
November 2000.</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ABC
plot(ABC)
plot(ABC, lattice=TRUE)
</code></pre>

<hr>
<h2 id='as.LongTriangle'>Convert Triangle from wide to long</h2><span id='topic+as.LongTriangle'></span>

<h3>Description</h3>

<p>Given a Triangle in matrix (&quot;wide&quot;) format,
convert to data.frame (&quot;long&quot;) format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.LongTriangle(Triangle, varnames = names(dimnames(Triangle)), 
                value.name = "value", na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.LongTriangle_+3A_triangle">Triangle</code></td>
<td>
<p>a loss &quot;triangle&quot;. Must be a <code>matrix</code>.</p>
</td></tr>
<tr><td><code id="as.LongTriangle_+3A_varnames">varnames</code></td>
<td>
<p><code>character</code> names for the columns that will store the 
<code>rownames</code> and <code>colnames</code> of matrix <code>Triangle</code>. 
Defaults to <code>names(dimnames(Triangle))</code> if available.
If not provided, uses c(&quot;origin&quot;, &quot;dev&quot;).</p>
</td></tr>
<tr><td><code id="as.LongTriangle_+3A_value.name">value.name</code></td>
<td>
<p>column name to be given to the matrix
values that will be stored in the data.frame. 
Defaults to &quot;value&quot;.</p>
</td></tr>
<tr><td><code id="as.LongTriangle_+3A_na.rm">na.rm</code></td>
<td>
<p>should NA values be excluded from the data.frame?
Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unlike the as.data.frame.triangle method,
and Unlike the 'melt' method in the 'reshape2' package, 
this function returns a data.frame where the rownames and colnames of Triangle
are stored as <em>factors</em>.
This can be a critical feature when the order of the levels of the columns
is important.
For example, when a Triangle is plotted, the order of the
origin and dev dimensions is important.
See Examples section.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code>.
</p>


<h3>Author(s)</h3>

<p>Daniel Murphy
</p>


<h3>See Also</h3>

<p><code>as.data.frame.triangle</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as.LongTriangle(GenIns)
## Not run: 
ggplot(as.LongTriangle(GenIns), 
       aes(x = dev, y = value, group = origin, color = origin)) + geom_line()

## End(Not run)
</code></pre>

<hr>
<h2 id='ata'>Calculate Age-to-Age Factors</h2><span id='topic+ata'></span>

<h3>Description</h3>

<p>Calculate the matrix of age-to-age factors 
(also called &quot;report-to-report&quot; factors, or &quot;link ratios&quot;)
for an object of class <code>triangle</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ata(Triangle, NArow.rm = TRUE, colname.sep = "-",
        colname.order=c("ascending","descending"))

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ata_+3A_triangle">Triangle</code></td>
<td>
<p>a loss &quot;triangle&quot;. Must be a <code>matrix</code>.</p>
</td></tr>
<tr><td><code id="ata_+3A_narow.rm">NArow.rm</code></td>
<td>
<p><code>logical</code> indicating if 
rows of age-to-age (ata) factors that are all <code>NA</code>
should be removed.
&quot;All-NA&quot; rows typically occur for the most recent origin year
of a loss triangle.</p>
</td></tr>
<tr><td><code id="ata_+3A_colname.sep">colname.sep</code></td>
<td>
<p>a <code>character</code> indicating the separator
character to place between the column names of <code>Triangle</code>
that will be used to lable the columns of the resulting 
matrix of ata factors</p>
</td></tr>
<tr><td><code id="ata_+3A_colname.order">colname.order</code></td>
<td>
<p>&quot;ascending&quot; indicates that the less mature
age comes first in the column labels of the ata matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ata</code> constructs a matrix of age-to-age (ata) factors resulting
from a loss &quot;triangle&quot; or a <code>matrix</code>.
Simple averages and volume weighted averages are saved as 
&quot;smpl&quot; and &quot;vwtd&quot; attributes, respectively.
</p>


<h3>Value</h3>

<p>A <code>matrix</code> with &quot;smpl&quot; and &quot;vwtd&quot; attributes.
</p>


<h3>Author(s)</h3>

<p>Daniel Murphy
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.ata">summary.ata</a></code>, <code><a href="#topic+print.ata">print.ata</a></code> and <code><a href="#topic+chainladder">chainladder</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ata(GenIns)

# Volume weighted average age-to-age factor of the "RAA" data
y &lt;- attr(ata(RAA), "vwtd")
y
# "To ultimate" factors with a 10% tail
y &lt;- rev(cumprod(rev(c(y, 1.1))))
names(y) &lt;- paste(colnames(RAA), "Ult", sep="-")
y

## Label the development columns in "ratio-type" format
ata(RAA, colname.sep=":", colname.order="desc")

</code></pre>

<hr>
<h2 id='auto'>Run off triangle of accumulated claim data</h2><span id='topic+auto'></span>

<h3>Description</h3>

<p>Run-off triangles of Personal Auto and Commercial Auto insurance.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(auto)</code></pre>


<h3>Format</h3>

<p>A list of three matrices, paid Personal Auto, incurred Personal Auto and paid Commercial Auto respectively.
</p>


<h3>Source</h3>

<p><cite>Zhang (2010). A general multivariate chain ladder model. <em>Insurance: Mathematics and Economics</em>, 46, pp. 588-599.</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(auto)
names(auto)
</code></pre>

<hr>
<h2 id='AutoBI'>Run off triangles of accumulated claim data</h2><span id='topic+AutoBI'></span>

<h3>Description</h3>

<p>Run-off triangles of Automobile Bodily Injury Liability.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(AutoBI)</code></pre>


<h3>Format</h3>

<p>Portfolio of automobile bodily injury liability for an experience period of 1969 to 1976. Paid Claims, Closed Claims and Reported Claim Counts respectively
</p>


<h3>Source</h3>

<p><cite>Berquist, J.R. and Sherman, R.E., Loss Reserve Adequacy Testing: A Comprehensive,
Systematic Approach, <em>Proceedings of the Casualty Actuarial Society</em>, LXIV, 1977, pp.123-184.</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(AutoBI)
names(AutoBI)
AutoBI$AutoBIPaid
AutoBI$AutoBIClosed
AutoBI$AutoBIReportedCounts
</code></pre>

<hr>
<h2 id='BootChainLadder'> Bootstrap-Chain-Ladder Model </h2><span id='topic+BootChainLadder'></span>

<h3>Description</h3>

<p>The <code>BootChainLadder</code> procedure provides a predictive
distribution of reserves or IBNRs for a cumulative claims development triangle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BootChainLadder(Triangle, R = 999, process.distr=c("gamma", "od.pois"), seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BootChainLadder_+3A_triangle">Triangle</code></td>
<td>
<p>cumulative claims triangle. Assume columns are the development
period, use transpose otherwise.  A (mxn)-matrix <code class="reqn">C_{ik}</code> 
which is filled for <code class="reqn">k \le n+1-i; i=1,\ldots,m; m\ge n </code>. See
<code><a href="#topic+qpaid">qpaid</a></code> for how to use (mxn)-development triangles with
m&lt;n, say higher development period frequency (e.g quarterly) than
origin period frequency (e.g accident years).</p>
</td></tr>
<tr><td><code id="BootChainLadder_+3A_r">R</code></td>
<td>
<p>the number of bootstrap replicates.</p>
</td></tr>
<tr><td><code id="BootChainLadder_+3A_process.distr">process.distr</code></td>
<td>
<p> character string indicating which process
distribution to be assumed. One of &quot;gamma&quot; (default), 
or &quot;od.pois&quot; (over-dispersed Poisson), can be abbreviated</p>
</td></tr>
<tr><td><code id="BootChainLadder_+3A_seed">seed</code></td>
<td>
<p>optional seed for the random generator</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>BootChainLadder</code> function uses a two-stage
bootstrapping/simulation approach. In the first stage an ordinary
chain-ladder methods is applied to the cumulative claims triangle.
From this we calculate the scaled Pearson residuals which we bootstrap
R times to forecast future incremental claims payments via the
standard chain-ladder method. 
In the second stage we simulate the process error with the bootstrap
value as the mean and using the process distribution assumed. 
The set of reserves obtained in this way forms the predictive distribution, 
from which summary statistics such as mean, prediction error or
quantiles can be derived.
</p>


<h3>Value</h3>

<p>BootChainLadder gives a list with the following elements back:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>matched call</p>
</td></tr>
<tr><td><code>Triangle</code></td>
<td>
<p>input triangle</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>chain-ladder factors</p>
</td></tr>
<tr><td><code>simClaims</code></td>
<td>
<p>array of dimension <code>c(m,n,R)</code> with the simulated claims</p>
</td></tr>	      
<tr><td><code>IBNR.ByOrigin</code></td>
<td>
<p>array of dimension <code>c(m,1,R)</code> with the modeled
IBNRs by origin period</p>
</td></tr>
<tr><td><code>IBNR.Triangles</code></td>
<td>
<p>array of dimension <code>c(m,n,R)</code> with the modeled
IBNR development triangles</p>
</td></tr>
<tr><td><code>IBNR.Totals</code></td>
<td>
<p>vector of R samples of the total IBNRs</p>
</td></tr>
<tr><td><code>ChainLadder.Residuals</code></td>
<td>
<p>adjusted Pearson chain-ladder residuals</p>
</td></tr>
<tr><td><code>process.distr</code></td>
<td>
<p>assumed process distribution</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>the number of bootstrap replicates</p>
</td></tr>
</table>


<h3>Note</h3>

<p> The implementation of <code>BootChainLadder</code> follows closely the
discussion of the bootstrap model in section 8 and appendix 3 of the
paper by England and Verrall (2002).
</p>


<h3>Author(s)</h3>

<p> Markus Gesmann, <a href="mailto:markus.gesmann@gmail.com">markus.gesmann@gmail.com</a> </p>


<h3>References</h3>

<p><cite>England, PD and Verrall, RJ. Stochastic Claims Reserving in
General Insurance (with discussion), <em>British Actuarial Journal</em> 8,
III. 2002 </cite>
</p>
<p><cite>Barnett and Zehnwirth. The need for diagnostic assessment of
bootstrap predictive models, <em>Insureware technical report</em>. 2007</cite>
</p>


<h3>See Also</h3>

<p> See also  
<code><a href="#topic+summary.BootChainLadder">summary.BootChainLadder</a></code>, 
<code><a href="#topic+plot.BootChainLadder">plot.BootChainLadder</a></code> displaying results and finally 
<code><a href="#topic+CDR.BootChainLadder">CDR.BootChainLadder</a></code> for the one year claims development result. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See also the example in section 8 of England &amp; Verrall (2002) on page 55.

B &lt;- BootChainLadder(RAA, R=999, process.distr="gamma")
B
plot(B)
# Compare to MackChainLadder
MackChainLadder(RAA)
quantile(B, c(0.75,0.95,0.99, 0.995))

# fit a distribution to the IBNR
library(MASS)
plot(ecdf(B$IBNR.Totals))
# fit a log-normal distribution 
fit &lt;- fitdistr(B$IBNR.Totals[B$IBNR.Totals&gt;0], "lognormal")
fit
curve(plnorm(x,fit$estimate["meanlog"], fit$estimate["sdlog"]), col="red", add=TRUE)

# See also the ABC example in  Barnett and Zehnwirth (2007) 
A &lt;- BootChainLadder(ABC, R=999, process.distr="gamma")
A
plot(A, log=TRUE)

## One year claims development result
CDR(A)

</code></pre>

<hr>
<h2 id='BS.paid.adj'> Berquist-Sherman Paid Claim Development Adjustment </h2><span id='topic+BS.paid.adj'></span>

<h3>Description</h3>

<p>The B-S Paid Claim Development Adjustment methods adjusts paid claims based on the underlying relation between paid and closed claims.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BS.paid.adj(Triangle.rep.counts = NULL, Triangle.closed, Triangle.paid, 
            ult.counts = NULL, regression.type = "exponential")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BS.paid.adj_+3A_triangle.rep.counts">Triangle.rep.counts</code></td>
<td>
<p>cumulative reported claim counts triangle.  Assume columns are the development
period, use transpose otherwise.
A (mxn)-matrix <code class="reqn">C_{ik}</code> which is filled for <code class="reqn">k \leq n+1-i; i=1,\ldots,m; m\geq n </code>, see
<code><a href="#topic+qpaid">qpaid</a></code> .</p>
</td></tr>
<tr><td><code id="BS.paid.adj_+3A_triangle.closed">Triangle.closed</code></td>
<td>
<p>cumulative closed claim counts triangle.  Assume columns are the development
period, use transpose otherwise.</p>
</td></tr>
<tr><td><code id="BS.paid.adj_+3A_triangle.paid">Triangle.paid</code></td>
<td>
<p>cumulative paid claims triangle.  Assume columns are the development
period, use transpose otherwise.</p>
</td></tr>
<tr><td><code id="BS.paid.adj_+3A_ult.counts">ult.counts</code></td>
<td>
<p>vector of ultimate claim counts.</p>
</td></tr>  
<tr><td><code id="BS.paid.adj_+3A_regression.type">regression.type</code></td>
<td>
<p>Default = &quot;exponential&quot;. Type of regression used in the model, it can take 'exponential' or 'linear'. See also 'Details'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The importance of recognizing the impact of shifts in the rate of settlement of claims upon historical paid loss data 
can materially affect the ultimate projections. 
</p>
<p>This functions adjusts the paid claims based on the numerical method described in the B-S paper. 
</p>
<p>Berquist and Sherman presented a technique to adjust the paid claim development method for changes in settlement rates.
The first step of the paid claims adjustment is to determine the disposal rates by accident year and maturity. 
</p>
<p>The disposal rate is defined as as the cumulative closed claim counts for each accident year-maturity age cell 
divided by the selected ultimate claim count for the particular accident year. 
</p>
<p>If ultimate claim counts have been provided, they will be used to calulate the disposal rates, otherwise ultimate claim counts will be estimated
from the cumulative reported  claim counts triangle with a standard development method. 
</p>
<p>The disposal rates along the latest diagonal will be selected as the basis for adjusting the closed claim count triangle,
The selected disposal rate for each maturity are multiplied by the ultimate number of claims to determine the adjusted triangle 
of closed claim counts. 
</p>
<p>Berquist and Sherman then use regression analysis to identify a mathematical formula that approximates the relationship between the cumulative 
number of closed claims (X) and cumulative paid claims (Y). The algorithm gives the possibility, through the choice of the 'regression.type' field, 
to fit an exponential model, <code class="reqn">Y = a*e^(bX)</code>, or a linear model, <code class="reqn">Y = a+b*X</code>. 
</p>
<p>The relation is estimated based on unadjusted closed claim counts and unadjusted paid claims. Once the regression coefficients are estimated, they will be used to
adjust paid claims based on such coefficients and the adjusted closed claim counts triangle.
</p>


<h3>Value</h3>

<p>BS.paid.adj returns the adjusted paid claim triangle
</p>


<h3>Author(s)</h3>

<p>Marco De Virgilis <a href="mailto:devirgilis.marco@gmail.com">devirgilis.marco@gmail.com</a></p>


<h3>References</h3>

<p><cite>Berquist, J.R. and Sherman, R.E., Loss Reserve Adequacy Testing: A Comprehensive,
Systematic Approach, <em>Proceedings of the Casualty Actuarial Society</em>, LXIV, 1977, pp.123-184.</cite>
</p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+qpaid">qpaid</a></code> for dealing with non-square triangles,  
<code><a href="#topic+inflateTriangle">inflateTriangle</a></code> to inflate a triangle based on an inflation rate,
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Adjust the Triangle of Paid Claims based on Reported Claim Counts

adj_paid &lt;- BS.paid.adj( Triangle.rep.counts = AutoBI$AutoBIReportedCounts,
                         Triangle.closed = AutoBI$AutoBIClosed,
                         Triangle.paid = AutoBI$AutoBIPaid,
                         regression.type = 'exponential' )

# Calculate the IBNR from the standard unadjusted Paid Triangle

std_ibnr &lt;- summary(MackChainLadder(AutoBI$AutoBIPaid))$Totals[4, 1]

# Calculate the IBNR from the adjusted Paid Triangle

adj_ibnr &lt;- summary(MackChainLadder(adj_paid))$Totals[4, 1]

# Compare the two

adj_ibnr
std_ibnr

## For more examples see:
## Not run: 
 demo(BS.paid.adj)

## End(Not run)
</code></pre>

<hr>
<h2 id='CDR'>
One year claims development result
</h2><span id='topic+CDR'></span><span id='topic+CDR.MackChainLadder'></span><span id='topic+CDR.BootChainLadder'></span><span id='topic+CDR.default'></span>

<h3>Description</h3>

<p>Standard deviation of the claims development result after one year 
for the distribution-free chain-ladder model (Mack) and Bootstrap model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CDR(x, ...)
## S3 method for class 'MackChainLadder'
CDR(x, dev=1, ...)
## S3 method for class 'BootChainLadder'
CDR(x, probs=c(0.75, 0.95), ...)
## Default S3 method:
CDR(x, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CDR_+3A_x">x</code></td>
<td>
<p>otput of either <code><a href="#topic+MackChainLadder">MackChainLadder</a></code> or <code><a href="#topic+BootChainLadder">BootChainLadder</a></code></p>
</td></tr>
<tr><td><code id="CDR_+3A_dev">dev</code></td>
<td>
<p>vector of development periods or <code>"all"</code>. 
Currently only applicable for <code>MackChainLadder</code> output. 
Defines the years for which the run off claims development result should be returned.
</p>
</td></tr>
<tr><td><code id="CDR_+3A_probs">probs</code></td>
<td>
<p>only applicable for <code>BootChainLadder</code> output.
Define quantiles to be returned.</p>
</td></tr>
<tr><td><code id="CDR_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Merz &amp; Wüthrich (2008) derived analytic formulae for the mean square error
of prediction of the claims development result for the 
Mack chain-ladder model after one year assuming:
</p>

<ul>
<li>
<p>The opening reserves were set using the pure chain-ladder model 
(no tail)

</p>
</li>
<li>
<p>Claims develop in the year according to the assumptions underlying
Mack's model

</p>
</li>
<li>
<p>Reserves are set after one year using the pure chain-ladder model 
(no tail) 

</p>
</li></ul>



<h3>Value</h3>

<p>A <code>data.frame</code> with various IBNR/reserves and one-year statistics of the 
claims development result.
</p>


<h3>Note</h3>

<p>Tail factors are currently not supported.
</p>


<h3>Author(s)</h3>

<p>Mario Wüthrich and Markus Gesmann 
with contributions from Arthur Charpentier and Arnaud Lacoume 
for <code>CDR.MackChainLadder</code> and Giuseppe Crupi and 
Markus Gesmann for <code>CDR.BootChainLadder</code>.
</p>


<h3>References</h3>

<p><cite>Michael Merz, Mario V. Wüthrich. <em>Modelling the claims development result for solvency purposes.</em> Casualty Actuarial Society E-Forum, Fall 2008.</cite>
</p>
<p><cite>Michael Merz, Mario V. Wüthrich. <em>Claims Run-Off Uncertainty: The Full Picture.</em>  
Swiss Finance Institute Research Paper No. 14-69. <a href="https://www.ssrn.com/abstract=2524352">https://www.ssrn.com/abstract=2524352</a>. 2014</cite>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+MackChainLadder">MackChainLadder</a></code> and <code><a href="#topic+BootChainLadder">BootChainLadder</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example from the 2008 Merz, Wuthrich paper mentioned above
MW2008
M &lt;- MackChainLadder(MW2008, est.sigma="Mack")
plot(M)
CDR(M)
# Return all run-off result developments
CDR(M, dev="all")

# Example from the 2014 Merz, Wuthrich paper mentioned above
MW2014
W &lt;- MackChainLadder(MW2014, est.sigma="Mack")
plot(W)
CDR(W)

# Example with the BootChainLadder function, assuming overdispered Poisson model
B &lt;- BootChainLadder(MW2008, process.distr=c("od.pois"))
B
CDR(B)
</code></pre>

<hr>
<h2 id='chainladder'> Estimate age-to-age factors </h2><span id='topic+chainladder'></span>

<h3>Description</h3>

<p>Basic chain-ladder function to estimate age-to-age factors for a given
cumulative run-off triangle. This function is used by Mack- and MunichChainLadder.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chainladder(Triangle, weights = 1, delta = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chainladder_+3A_triangle">Triangle</code></td>
<td>
<p>cumulative claims triangle.  A (mxn)-matrix <code class="reqn">C_{ik}</code> 
which is filled for <code class="reqn">k \leq n+1-i; i=1,\ldots,m; m\geq n </code>, see
<code><a href="#topic+qpaid">qpaid</a></code> for how to use (mxn)-development triangles with
m&lt;n, say higher development period frequency (e.g quarterly) than
origin period frequency (e.g annual).
</p>
</td></tr>
<tr><td><code id="chainladder_+3A_weights">weights</code></td>
<td>
<p>weights. Default: 1, which sets the weights for all
triangle entries to 1. Otherwise specify weights as a matrix of the same
dimension as <code>Triangle</code> with all weight entries in [0; 1], where entry
<code class="reqn">w_{i,k}</code> corresponds to the point <code class="reqn">C_{i,k+1}/C_{i,k}</code>. 
Hence, any entry set to 0 or <code>NA</code> eliminates that age-to-age factor 
from inclusion in the model. See also 'Details'.</p>
</td></tr>
<tr><td><code id="chainladder_+3A_delta">delta</code></td>
<td>
<p>'weighting' parameters. Default: 1;
delta=1 gives the historical chain-ladder age-to-age factors, 
delta=2 gives the straight average of the
observed individual development factors and delta=0 is the result of
an ordinary regression of <code class="reqn">C_{i,k+1}</code> against <code class="reqn">C_{i,k}</code> with
intercept 0, see Barnett &amp; Zehnwirth (2000).
</p>
<p>Please note that <code><a href="#topic+MackChainLadder">MackChainLadder</a></code> uses the argument <code>alpha</code>, 
with <code>alpha = 2 - delta</code>, following the original paper Mack (1999)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The key idea is to see the chain-ladder algorithm as a special form of a
weighted linear regression through the origin, applied to each development 
period.
</p>
<p>Suppose <code>y</code> is the vector of cumulative claims at development period
<code>i+1</code>, and <code>x</code> at development period <code>i</code>, <code>weights</code> are
weighting factors and <code>F</code> the individual age-to-age factors <code>F=y/x</code>. Then
we get the various age-to-age factors:
</p>

<ul>
<li><p>Basic (unweighted) linear regression through the origin:
<code>lm(y~x + 0)</code> 

</p>
</li>
<li><p>Basic weighted linear regression through the origin:
<code>lm(y~x + 0, weights=weights)</code> 

</p>
</li>
<li><p>Volume weighted chain-ladder age-to-age factors: 
<code>lm(y~x + 0, weights=1/x)</code>

</p>
</li>
<li><p>Simple average of age-to-age factors:
<code>lm(y~x + 0, weights=1/x^2)</code>
 
</p>
</li></ul>

<p>Barnett &amp; Zehnwirth (2000) use delta = 0, 1, 2 to distinguish between the above 
three different regression approaches: <code>lm(y~x + 0, weights=weights/x^delta)</code>.
</p>
<p>Thomas Mack uses the notation <code>alpha = 2 - delta</code> to achieve the same result:
<code>sum(weights*x^alpha*F)/sum(weights*x^alpha) # Mack (1999) notation</code>
</p>


<h3>Value</h3>

<p>chainladder returns a list with the following elements:
</p>
<table>
<tr><td><code>Models</code></td>
<td>
<p>linear regression models for each development period</p>
</td></tr>
<tr><td><code>Triangle</code></td>
<td>
<p>input triangle of cumulative claims</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>weights used</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>deltas used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Markus Gesmann &lt;markus.gesmann@gmail.com&gt;
</p>


<h3>References</h3>

<p><cite>Thomas Mack. The standard error of chain ladder reserve estimates: Recursive calculation and inclusion of a tail factor. <em>Astin Bulletin</em>. Vol. 29. No 2. 1999. pp.361:366</cite>
</p>
<p><cite>G. Barnett and B. Zehnwirth. Best Estimates for
Reserves. <em>Proceedings of the CAS.</em> Volume LXXXVII. Number 167. November 2000.</cite>
</p>


<h3>See Also</h3>

<p>See also
<code><a href="#topic+ata">ata</a></code>,	
<code><a href="#topic+predict.ChainLadder">predict.ChainLadder</a></code>
<code><a href="#topic+MackChainLadder">MackChainLadder</a></code>,  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Concept of different chain-ladder age-to-age factors.
## Compare Mack's and Barnett &amp; Zehnwirth's papers.
x &lt;- RAA[1:9,1]
y &lt;- RAA[1:9,2]

F &lt;- y/x
## wtd. average chain-ladder age-to-age factors
alpha &lt;- 1 ## Mack notation
delta &lt;- 2 - alpha ## Barnett &amp; Zehnwirth notation

sum(x^alpha*F)/sum(x^alpha)
lm(y~x + 0 ,weights=1/x^delta)
summary(chainladder(RAA, delta=delta)$Models[[1]])$coef

## straight average age-to-age factors
alpha &lt;- 0
delta &lt;- 2 - alpha 
sum(x^alpha*F)/sum(x^alpha)
lm(y~x + 0, weights=1/x^(2-alpha))
summary(chainladder(RAA, delta=delta)$Models[[1]])$coef

## ordinary regression age-to-age factors
alpha=2
delta &lt;- 2-alpha
sum(x^alpha*F)/sum(x^alpha)
lm(y~x + 0, weights=1/x^delta)
summary(chainladder(RAA, delta=delta)$Models[[1]])$coef

## Compare different models
CL0 &lt;- chainladder(RAA)
## age-to-age factors
sapply(CL0$Models, function(x) summary(x)$coef["x","Estimate"])
## f.se
sapply(CL0$Models, function(x) summary(x)$coef["x","Std. Error"])
## sigma
sapply(CL0$Models, function(x) summary(x)$sigma)
predict(CL0)

CL1 &lt;- chainladder(RAA, delta=1)
## age-to-age factors
sapply(CL1$Models, function(x) summary(x)$coef["x","Estimate"])
## f.se
sapply(CL1$Models, function(x) summary(x)$coef["x","Std. Error"])
## sigma
sapply(CL1$Models, function(x) summary(x)$sigma)
predict(CL1)

CL2 &lt;- chainladder(RAA, delta=2)
## age-to-age factors
sapply(CL2$Models, function(x) summary(x)$coef["x","Estimate"])
## f.se
sapply(CL2$Models, function(x) summary(x)$coef["x","Std. Error"])
## sigma
sapply(CL2$Models, function(x) summary(x)$sigma)
predict(CL2)

## Set 'weights' parameter to use only the last 5 diagonals, 
## i.e. the last 5 calendar years
calPeriods &lt;- (row(RAA) + col(RAA) - 1)
(weights &lt;- ifelse(calPeriods &lt;= 5, 0, ifelse(calPeriods &gt; 10, NA, 1)))
CL3 &lt;- chainladder(RAA, weights=weights)
summary(CL3$Models[[1]])$coef
predict(CL3)
</code></pre>

<hr>
<h2 id='ChainLadder-package'>
Methods and Models for Claims Reserving
</h2><span id='topic+ChainLadder-package'></span><span id='topic+ChainLadder'></span>

<h3>Description</h3>

<p>ChainLadder provides methods and models which are typically 
used in insurance claims reserving.
</p>
<p>The package grew out of presentations given at the Stochastic 
Reserving Seminar at the Institute of Actuaries in 2007 and 2008 and 
followed by talks at CAS meetings in 2008 and 2010.
</p>
<p>More information is available on the project web site
<a href="https://github.com/mages/ChainLadder">https://github.com/mages/ChainLadder</a> 
</p>
<p>For more financial packages see also CRAN Task View 'Emperical Finance'
at <a href="https://CRAN.R-project.org/view=Finance">https://CRAN.R-project.org/view=Finance</a>.
</p>


<h3>Author(s)</h3>

<p>Maintainer: Markus Gesmann &lt;markus.gesmann@gmail.com&gt;
</p>


<h3>References</h3>

<p><cite>Thomas Mack. Distribution-free calculation of the standard error of chain ladder reserve estimates. <em>Astin Bulletin.</em> Vol. 23. No 2. 1993. pp.213:225</cite>
</p>
<p><cite>Thomas Mack. The standard error of chain ladder reserve estimates: Recursive calculation and inclusion of a tail factor. <em>Astin Bulletin.</em> Vol. 29. No 2. 1999. pp.361:366</cite>
</p>
<p><cite>Gerhard Quarg and Thomas Mack. Munich Chain Ladder. <em>Blatter DGVFM 26.</em> Munich. 2004.</cite>
</p>
<p><cite>England, PD and Verrall, RJ. Stochastic Claims Reserving in General Insurance (with discussion). <em>British Actuarial Journal 8.</em> III. 2002 </cite>
</p>
<p><cite>B. Zehnwirth and G. Barnett. <em>Best Estimates for Reserves</em>. <em>Proceedings of the CAS.</em> Volume LXXXVII. Number 167.November 2000.</cite>
</p>
<p><cite>Clark, David R., &quot;LDF Curve-Fitting and Stochastic Reserving: A Maximum Likelihood Approach,&quot; <em>CAS Forum</em>, Fall 2003.</cite>
</p>
<p><cite>Zhang Y. A general multivariate chain ladder model.<em>Insurance: Mathematics and Economics</em>, 46, pp. 588:599, 2010.</cite>
</p>
<p><cite> Zhang, Y. Likelihood-based and Bayesian Methods for Tweedie Compound Poisson Linear Mixed Models, <em>Statistics and Computing</em>, forthcoming. 
</cite>
</p>
<p><cite>Bardis, Majidi, Murphy. A Family of Chain-Ladder Factor Models for Selected Link Ratios. <em>Variance</em>. Pending. Variance 6:2, 2012, pp. 143-160.</cite>
</p>
<p><cite>Modelling the claims development result for solvency purposes.
Michael Merz, Mario V. Wüthrich. Casualty Actuarial Society E-Forum, Fall 2008.</cite>
</p>
<p><cite>Claims Run-Off Uncertainty: The Full Picture. Michael Merz, 
Mario V. Wüthrich. Swiss Finance Institute Research Paper No. 14-69. <a href="https://www.ssrn.com/abstract=2524352">https://www.ssrn.com/abstract=2524352</a>. 2014</cite>
</p>
<p><cite>Markus Gesmann. Claims Reserving and IBNR. 
<em>Computational Actuarial Science with R</em>. Chapman and Hall/CRC. 2014</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  demo(ChainLadder)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='checkTriangleInflation'> Check Y-o-Y Triangle Inflation Rates </h2><span id='topic+checkTriangleInflation'></span>

<h3>Description</h3>

<p>Check for Year-on-Year Inflation rates down the columns of a run-off triangle
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkTriangleInflation(Triangle)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkTriangleInflation_+3A_triangle">Triangle</code></td>
<td>
<p>average claim amounts triangle. Assume columns are the development
period, use transpose otherwise.
A (mxn)-matrix <code class="reqn">C_{ik}</code> 
which is filled for <code class="reqn">k \leq n+1-i; i=1,\ldots,m; m\geq n </code>, see
<code><a href="#topic+qpaid">qpaid</a></code> for how to use (mxn)-development triangles with
m&lt;n, say higher development period frequency (e.g quarterly) than
origin period frequency (e.g accident years).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sensitivity of projections of ultimate losses based on incurred loss
development factors to changes in the adequacy level of case reserves increases
significantly for the long-tail lines. In particular, if the adequacy of the case reserve
is changing, the estimates of ultimate losses based on reported claims could be severely distorted.
</p>
<p>The function fits an exponential inflation model that takes the form of:
</p>
<p style="text-align: center;"><code class="reqn">Y=a*(1+b)^x</code>
</p>
<p> where <code class="reqn">Y</code> represents the inflated claim amount, <code class="reqn">a</code> represents the claim amount at the beginning of each period (e.g. AY=0), <code class="reqn">b</code> is the inflation rate  and <code class="reqn">x</code> is the time (e.g. AY).
</p>
<p>Fitting such a model on the average level of the case outstanding (or any other average claim amount) for each development period, it is possible to appreciate the inflation rate that has affected the average case reserve.
</p>
<p>It is necessary to check the inflation on average amounts, otherwise the estimates may be distorted due to an increase in the number of claims rather than an actual increase in the inflation level.
</p>
<p>If the level of inflation is material, it would be necessary to adjust each cell in the triangle.<br /> 
This is to to have each diagonal in the triangle at the same level as the latest diagonal (i.e. latest valuation). This adjustment would prevent distortions in the estimates caused by inflation and not by actual variations in the claim experience.
</p>


<h3>Value</h3>

<p>checkTriangleInflation returns a list with the following elements
</p>
<table>
<tr><td><code>Triangle</code></td>
<td>
<p>Input triangle</p>
</td></tr> 
<tr><td><code>summ_table</code></td>
<td>
<p>summary table showing the inflation rate, the <code class="reqn">R^2</code> of the regression and the number of points used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco De Virgilis <a href="mailto:devirgilis.marco@gmail.com">devirgilis.marco@gmail.com</a></p>


<h3>References</h3>

<p><cite>Berquist, J.R. and Sherman, R.E., Loss Reserve Adequacy Testing: A Comprehensive,
Systematic Approach, <em>Proceedings of the Casualty Actuarial Society</em>, LXIV, 1977, pp.123-184.</cite>
</p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+qpaid">qpaid</a></code> for dealing with non-square triangles,  
<code><a href="#topic+inflateTriangle">inflateTriangle</a></code> to inflate a triangle based on an inflation rate,
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a triangle of average outstanding claims as the ratio between O/S Claims 
# and Open Claims (i.e. the number of outstanding claims)
avg &lt;- MedMal$MedMalOutstanding / MedMal$MedMalOpen

# Check the level of average inflation Y-o-Y
test&lt;-checkTriangleInflation(avg)

# Plot the results
# A model of exponential inflation fits quite well the level of average O/S claims
# This is particularly evident for DP 1,2,3
plot(test)

# Get the summary in an analytical way to observe the ratios and the number of points used
summary(test)

# Print the output
print(test) 
# There is an inflation level equal to .15 at the first development period. It would be 
# appropriate to adjust the triangle before proceeding with any estimate method.
</code></pre>

<hr>
<h2 id='ClarkCapeCod'>
Clark Cape Cod method
</h2><span id='topic+ClarkCapeCod'></span>

<h3>Description</h3>

<p>Analyze loss triangle using Clark's Cape Cod method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ClarkCapeCod(Triangle, Premium, cumulative = TRUE, maxage = Inf, 
        adol = TRUE, adol.age = NULL, origin.width = NULL,
        G = "loglogistic")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ClarkCapeCod_+3A_triangle">Triangle</code></td>
<td>

<p>A loss triangle in the form of a matrix.
The number of columns must be at least four;
the number of rows may be as few as 1.
The column names of the matrix should be able to be interpreted
as the &quot;age&quot; of the losses in that column.
The row names of the matrix should uniquely define the year of
origin of the losses in that row.
Losses may be inception-to-date or incremental.
</p>
</td></tr>
<tr><td><code id="ClarkCapeCod_+3A_premium">Premium</code></td>
<td>

<p>The vector of premium to use in the method.
If a scalar (vector of length 1) is given,
that value will be used for all origin periods.
(See &quot;Examples&quot; below.)
If the length is greater than 1 but 
does not equal the number of rows of <code>Triangle</code>
the <code>Premium</code> values will be &quot;recycled&quot; with a warning.
</p>
</td></tr>
<tr><td><code id="ClarkCapeCod_+3A_cumulative">cumulative</code></td>
<td>

<p>If <code>TRUE</code> (the default), values in <code>Triangle</code> are
inception to date.
If <code>FALSE</code>, <code>Triangle</code> holds incremental losses.
</p>
</td></tr>
<tr><td><code id="ClarkCapeCod_+3A_maxage">maxage</code></td>
<td>

<p>The &quot;ultimate&quot; age to which losses should be projected.
</p>
</td></tr>
<tr><td><code id="ClarkCapeCod_+3A_adol">adol</code></td>
<td>

<p>If <code>TRUE</code> (the default), the growth function should be applied
to the length of time from the average date of loss (&quot;adol&quot;)
of losses in the origin year.
If <code>FALSE</code>, the growth function should be applied
to the length of time since the beginning of the origin year.
</p>
</td></tr>
<tr><td><code id="ClarkCapeCod_+3A_adol.age">adol.age</code></td>
<td>

<p>Only pertinent if <code>adol</code> is <code>TRUE</code>.
The age of the average date of losses within an origin period
in the same units as the &quot;ages&quot; of the <code>Triangle</code> matrix.
If <code>NULL</code> (the default) it will be assumed to be half the width
of an origin period (which would be the case if losses can be assumed
to occur uniformly over an origin period).
</p>
</td></tr>
<tr><td><code id="ClarkCapeCod_+3A_origin.width">origin.width</code></td>
<td>

<p>Only pertinent if <code>adol</code> is <code>TRUE</code>.
The width of an origin period
in the same units as the &quot;ages&quot; of the <code>Triangle</code> matrix.
If <code>NULL</code> (the default) it will be assumed to be the mean difference
in the &quot;ages&quot; of the triangle, 
with a warning if not all differences are equal.
</p>
</td></tr>
<tr><td><code id="ClarkCapeCod_+3A_g">G</code></td>
<td>

<p>A <code>character</code> scalar identifying the &quot;growth function.&quot;
The two growth functions defined at this time are &quot;loglogistic&quot;
(the default)
and &quot;weibull&quot;.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Clark's &quot;Cape Cod&quot; method assumes that the 
incremental losses across development periods in a loss triangle
are independent.
He assumes that the expected value of an incremental loss is
equal to the <em>theoretical</em> expected loss ratio (<b>ELR</b>)
times the on-level premium for the origin year
times the change in the <em>theoretical</em>
underlying growth function over the development period.
Clark models the growth function, also called the percent of ultimate,
by either the loglogistic function (a.k.a., &quot;the inverse power curve&quot;) 
or the weibull function.
Clark completes his incremental loss model 
by wrapping the expected values within an 
overdispersed poisson (ODP) process where
the &quot;scale factor&quot; 
sigma^2
is assumed to be a known constant for all 
development periods.
</p>
<p>The parameters of Clark's &quot;Cape Cod&quot; method are therefore:
ELR,
and 
omega
and 
theta
(the parameters of the <b>loglogistic</b> and <b>weibull</b> growth functions).
Finally, Clark uses maximum likelihood to parameterize his model,
uses the ODP process to estimate process risk, and
uses the Cramer-Rao theorem and the &quot;delta method&quot; to estimate parameter risk.
</p>
<p>Clark recommends inspecting the residuals to help assess the 
reasonableness of the model relative to the actual data
(see <code><a href="#topic+plot.clark">plot.clark</a></code> below).
</p>


<h3>Value</h3>

<p>A <code>list</code> of class &quot;ClarkLDF&quot; with the components listed below.
(&quot;Key&quot; to naming convention: all caps represent parameters;
mixed case represent origin-level amounts;
all-lower-case represent observation-level (origin, development age) results.)
</p>
<table>
<tr><td><code>method</code></td>
<td>
<p>&quot;CapeCod&quot;</p>
</td></tr>
<tr><td><code>growthFunction</code></td>
<td>
<p>name of the growth function</p>
</td></tr>
<tr><td><code>Origin</code></td>
<td>
<p>names of the rows of the triangle</p>
</td></tr>
<tr><td><code>Premium</code></td>
<td>
<p>Premium amount for each origin year</p>
</td></tr>
<tr><td><code>CurrentValue</code></td>
<td>
<p>the most mature value for each row</p>
</td></tr>
<tr><td><code>CurrentAge</code></td>
<td>
<p>the most mature &quot;age&quot; for each row</p>
</td></tr>
<tr><td><code>CurrentAge.used</code></td>
<td>
<p>the most mature age used; differs from &quot;CurrentAge&quot;
when adol=TRUE</p>
</td></tr>
<tr><td><code>MAXAGE</code></td>
<td>
<p>same as 'maxage' argument</p>
</td></tr>
<tr><td><code>MAXAGE.USED</code></td>
<td>
<p>the maximum age for development 
from the average date of loss; 
differs from MAXAGE when adol=TRUE</p>
</td></tr>
<tr><td><code>FutureValue</code></td>
<td>
<p>the projected loss amounts (&quot;Reserves&quot; in Clark's paper)</p>
</td></tr>
<tr><td><code>ProcessSE</code></td>
<td>
<p>the process standard error of the FutureValue</p>
</td></tr>
<tr><td><code>ParameterSE</code></td>
<td>
<p>the parameter standard error of the FutureValue</p>
</td></tr>
<tr><td><code>StdError</code></td>
<td>
<p>the total standard error (process + parameter) 
of the FutureValue</p>
</td></tr>
<tr><td><code>Total</code></td>
<td>
<p>a <code>list</code> with amounts that appear on the &quot;Total&quot; row
for components &quot;Origin&quot; (=&quot;Total&quot;), &quot;CurrentValue&quot;, &quot;FutureValue&quot;,
&quot;ProcessSE&quot;, &quot;ParameterSE&quot;, and &quot;StdError&quot;</p>
</td></tr>
<tr><td><code>PAR</code></td>
<td>
<p>the estimated parameters</p>
</td></tr>
<tr><td><code>ELR</code></td>
<td>
<p>the estimated loss ratio parameter</p>
</td></tr>
<tr><td><code>THETAG</code></td>
<td>
<p>the estimated parameters of the growth function</p>
</td></tr>
<tr><td><code>GrowthFunction</code></td>
<td>
<p>value of the growth function as of the 
CurrentAge.used</p>
</td></tr>
<tr><td><code>GrowthFunctionMAXAGE</code></td>
<td>
<p>value of the growth function as of the
MAXAGE.used</p>
</td></tr>
<tr><td><code>FutureGrowthFactor</code></td>
<td>
<p>the (&quot;unreported&quot; or &quot;unpaid&quot;) percent of
ultimate loss that has yet to be recorded</p>
</td></tr>
<tr><td><code>SIGMA2</code></td>
<td>
<p>the estimate of the sigma^2 parameter</p>
</td></tr>
<tr><td><code>Ldf</code></td>
<td>
<p>the &quot;to-ultimate&quot; loss development factor
(sometimes called the &quot;cumulative development factor&quot;)
as defined in Clark's paper for each origin year</p>
</td></tr>
<tr><td><code>LdfMAXAGE</code></td>
<td>
<p>the &quot;to-ultimate&quot; loss development factor as of 
the maximum age used in the model</p>
</td></tr>
<tr><td><code>TruncatedLdf</code></td>
<td>
<p>the &quot;truncated&quot; loss development factor for developing
the current diagonal to
the maximum age used in the model</p>
</td></tr>
<tr><td><code>FutureValueGradient</code></td>
<td>
<p>the gradient of the FutureValue function</p>
</td></tr>
<tr><td><code>origin</code></td>
<td>
<p>the origin year corresponding to each observed value of incremental loss</p>
</td></tr>
<tr><td><code>age</code></td>
<td>
<p>the age of each observed value of incremental loss</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>the expected value of each observed value of incremental loss 
(the &quot;mu's&quot; of Clark's paper)</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the actual minus fitted value for 
each observed incremental loss</p>
</td></tr>
<tr><td><code>stdresid</code></td>
<td>
<p> the standardized residuals for 
each observed incremental loss
(= residuals/sqrt(sigma2*fitted), 
referred to as &quot;normalized residuals&quot; in Clark's paper; see p. 62)</p>
</td></tr>
<tr><td><code>FI</code></td>
<td>
<p>the &quot;Fisher Information&quot; matrix as defined in Clark's paper
(i.e., without the sigma^2 value)</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>the value of the loglikelihood function at the solution point</p>
</td></tr>
<tr><td><code>counts</code></td>
<td>
<p>the number of calls to the loglikelihood function
and its gradient function when numerical convergence was achieved</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Murphy
</p>


<h3>References</h3>

<p>Clark, David R., 
&quot;LDF Curve-Fitting and Stochastic Reserving: A Maximum Likelihood Approach&quot;,
<em>Casualty Actuarial Society Forum</em>, Fall, 2003
<a href="https://www.casact.org/sites/default/files/database/forum_03fforum_03ff041.pdf">https://www.casact.org/sites/default/files/database/forum_03fforum_03ff041.pdf</a> 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ClarkLDF">ClarkLDF</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- GenIns
colnames(X) &lt;- 12*as.numeric(colnames(X))
CC.loglogistic  &lt;- ClarkCapeCod(X, Premium=10000000+400000*0:9, maxage=240)
CC.loglogistic

# Clark's "CapeCod method" also works with triangles that have  
# more development periods than origin periods. The Premium
# is a contrived match to the "made up" 'qincurred' Triangle.
ClarkCapeCod(qincurred, Premium=1250+150*0:11, G="loglogistic")

# Method also works for a "triangle" with only one row:
# 1st row of GenIns; need "drop=FALSE" to avoid becoming a vector.
ClarkCapeCod(GenIns[1, , drop=FALSE], Premium=1000000, maxage=20)

# If one value of Premium is appropriate for all origin years
# (e.g., losses are on-level and adjusted for exposure)
# then only a single value for Premium need be provided.
ClarkCapeCod(GenIns, Premium=1000000, maxage=20)

# Use of the weibull function generates a warning that the parameter risk 
# approximation results in some negative variances. This may be of small 
# concern since it happens only for older years with near-zero 
# estimated reserves, but the warning should not be disregarded 
# if it occurs with real data.
Y &lt;- ClarkCapeCod(qincurred, Premium=1250+150*0:11, G="weibull")

# The plot of the standardized residuals by age indicates that the more
# mature observations are more loosely grouped than the less mature, just
# the opposite of the behavior under the loglogistic curve.
# This suggests that the model might be improved by analyzing the Triangle 
# in two different "blocks": less mature vs. more mature. 
# The QQ-plot shows that the tails of the empirical distribution of
# standardized residuals are "fatter" than a standard normal. 
# The fact that the p-value is essentially zero says that there is 
# virtually no chance that the standardized residuals could be 
# considered draws from a standard normal random variable.
# The overall conclusion is that Clark's ODP-based CapeCod model with 
# the weibull growth function does not match up well with the qincurred 
# triangle and these premiums.
plot(Y) 
</code></pre>

<hr>
<h2 id='ClarkLDF'>
Clark LDF method
</h2><span id='topic+ClarkLDF'></span>

<h3>Description</h3>

<p>Analyze loss triangle using Clark's LDF (loss development factor) method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ClarkLDF(Triangle, cumulative = TRUE, maxage = Inf, 
        adol = TRUE, adol.age = NULL, origin.width = NULL,
        G = "loglogistic")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ClarkLDF_+3A_triangle">Triangle</code></td>
<td>

<p>A loss triangle in the form of a matrix.
The number of columns must be at least four;
the number of rows may be as few as 1.
The column names of the matrix should be able to be interpreted
as the &quot;age&quot; of the losses in that column.
The row names of the matrix should uniquely define the year of
origin of the losses in that row.
Losses may be inception-to-date or incremental.
</p>
<p>The &quot;ages&quot; of the triangle can be &quot;phase shifted&quot; &ndash;
i.e., the first age need not be as at the end of the origin period.
(See the Examples section.)
Nor need the &quot;ages&quot; be uniformly spaced.
However, when the ages are not uniformly spaced, 
it would be prudent to specify the <code>origin.width</code> argument.
</p>
</td></tr>
<tr><td><code id="ClarkLDF_+3A_cumulative">cumulative</code></td>
<td>

<p>If <code>TRUE</code> (the default), values in <code>Triangle</code> are
inception to date.
If <code>FALSE</code>, <code>Triangle</code> holds incremental losses.
</p>
</td></tr>
<tr><td><code id="ClarkLDF_+3A_maxage">maxage</code></td>
<td>

<p>The &quot;ultimate&quot; age to which losses should be projected.
</p>
</td></tr>
<tr><td><code id="ClarkLDF_+3A_adol">adol</code></td>
<td>

<p>If <code>TRUE</code> (the default), the growth function should be applied
to the length of time from the average date of loss (&quot;adol&quot;)
of losses in the origin year.
If <code>FALSE</code>, the growth function should be applied
to the length of time since the beginning of the origin year.
</p>
</td></tr>
<tr><td><code id="ClarkLDF_+3A_adol.age">adol.age</code></td>
<td>

<p>Only pertinent if <code>adol</code> is <code>TRUE</code>.
The age of the average date of losses within an origin period
in the same units as the &quot;ages&quot; of the <code>Triangle</code> matrix.
If <code>NULL</code> (the default) it will be assumed to be half the width
of an origin period (which would be the case if losses can be assumed
to occur uniformly over an origin period).
</p>
</td></tr>
<tr><td><code id="ClarkLDF_+3A_origin.width">origin.width</code></td>
<td>

<p>Only pertinent if <code>adol</code> is <code>TRUE</code>.
The width of an origin period
in the same units as the &quot;ages&quot; of the <code>Triangle</code> matrix.
If <code>NULL</code> (the default) it will be assumed to be the mean difference
in the &quot;ages&quot; of the triangle, 
with a warning if not all differences are equal.
</p>
</td></tr>
<tr><td><code id="ClarkLDF_+3A_g">G</code></td>
<td>

<p>A <code>character</code> scalar identifying the &quot;growth function.&quot;
The two growth functions defined at this time are &quot;loglogistic&quot;
(the default)
and &quot;weibull&quot;.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Clark's &quot;LDF method&quot; assumes that the 
incremental losses across development periods in a loss triangle
are independent.
He assumes that the expected value of an incremental loss is
equal to the <em>theoretical</em> expected ultimate loss (<b>U</b>)
(by origin year)
times the change in the <em>theoretical</em>
underlying growth function over the development period.
Clark models the growth function, also called the percent of ultimate,
by either the loglogistic function (a.k.a., &quot;the inverse power curve&quot;) 
or the weibull function.
Clark completes his incremental loss model 
by wrapping the expected values within an 
overdispersed poisson (ODP) process where
the &quot;scale factor&quot; 
sigma^2
is assumed to be a known constant for all 
development periods.
</p>
<p>The parameters of Clark's &quot;LDF method&quot; are therefore:
U,
and 
omega
and 
theta
(the parameters of the <b>loglogistic</b> and <b>weibull</b> growth functions).
Finally, Clark uses maximum likelihood to parameterize his model,
uses the ODP process to estimate process risk, and
uses the Cramer-Rao theorem and the &quot;delta method&quot; to estimate parameter risk.
</p>
<p>Clark recommends inspecting the residuals to help assess the 
reasonableness of the model relative to the actual data
(see <code><a href="#topic+plot.clark">plot.clark</a></code> below).
</p>


<h3>Value</h3>

<p>A <code>list</code> of class &quot;ClarkLDF&quot; with the components listed below.
(&quot;Key&quot; to naming convention: all caps represent parameters;
mixed case represent origin-level amounts;
all-lower-case represent observation-level (origin, development age) results.)
</p>
<table>
<tr><td><code>method</code></td>
<td>
<p>&quot;LDF&quot;</p>
</td></tr>
<tr><td><code>growthFunction</code></td>
<td>
<p>name of the growth function</p>
</td></tr>
<tr><td><code>Origin</code></td>
<td>
<p>names of the rows of the triangle</p>
</td></tr>
<tr><td><code>CurrentValue</code></td>
<td>
<p>the most mature value for each row</p>
</td></tr>
<tr><td><code>CurrentAge</code></td>
<td>
<p>the most mature &quot;age&quot; for each row</p>
</td></tr>
<tr><td><code>CurrentAge.used</code></td>
<td>
<p>the most mature age used; differs from &quot;CurrentAge&quot;
when adol=TRUE</p>
</td></tr>
<tr><td><code>MAXAGE</code></td>
<td>
<p>same as 'maxage' argument</p>
</td></tr>
<tr><td><code>MAXAGE.USED</code></td>
<td>
<p>the maximum age for development 
from the average date of loss; 
differs from MAXAGE when adol=TRUE</p>
</td></tr>
<tr><td><code>FutureValue</code></td>
<td>
<p>the projected loss amounts (&quot;Reserves&quot; in Clark's paper)</p>
</td></tr>
<tr><td><code>ProcessSE</code></td>
<td>
<p>the process standard error of the FutureValue</p>
</td></tr>
<tr><td><code>ParameterSE</code></td>
<td>
<p>the parameter standard error of the FutureValue</p>
</td></tr>
<tr><td><code>StdError</code></td>
<td>
<p>the total standard error (process + parameter) 
of the FutureValue</p>
</td></tr>
<tr><td><code>Total</code></td>
<td>
<p>a <code>list</code> with amounts that appear on the &quot;Total&quot; row
for components &quot;Origin&quot; (=&quot;Total&quot;), &quot;CurrentValue&quot;, &quot;FutureValue&quot;,
&quot;ProcessSE&quot;, &quot;ParameterSE&quot;, and &quot;StdError&quot;</p>
</td></tr>
<tr><td><code>PAR</code></td>
<td>
<p>the estimated parameters</p>
</td></tr>
<tr><td><code>THETAU</code></td>
<td>
<p>the estimated parameters for the &quot;ultimate loss&quot; by 
origin year (&quot;U&quot; in Clark's notation)</p>
</td></tr>
<tr><td><code>THETAG</code></td>
<td>
<p>the estimated parameters of the growth function</p>
</td></tr>
<tr><td><code>GrowthFunction</code></td>
<td>
<p>value of the growth function as of the 
CurrentAge.used</p>
</td></tr>
<tr><td><code>GrowthFunctionMAXAGE</code></td>
<td>
<p>value of the growth function as of the
MAXAGE.used</p>
</td></tr>
<tr><td><code>SIGMA2</code></td>
<td>
<p>the estimate of the sigma^2 parameter</p>
</td></tr>
<tr><td><code>Ldf</code></td>
<td>
<p>the &quot;to-ultimate&quot; loss development factor
(sometimes called the &quot;cumulative development factor&quot;)
as defined in Clark's paper for each origin year</p>
</td></tr>
<tr><td><code>LdfMAXAGE</code></td>
<td>
<p>the &quot;to-ultimate&quot; loss development factor as of 
the maximum age used in the model</p>
</td></tr>
<tr><td><code>TruncatedLdf</code></td>
<td>
<p>the &quot;truncated&quot; loss development factor for developing
the current diagonal to
the maximum age used in the model</p>
</td></tr>
<tr><td><code>FutureValueGradient</code></td>
<td>
<p>the gradient of the FutureValue function</p>
</td></tr>
<tr><td><code>origin</code></td>
<td>
<p>the origin year corresponding to each observed value of incremental loss</p>
</td></tr>
<tr><td><code>age</code></td>
<td>
<p>the age of each observed value of incremental loss</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>the expected value of each observed value of incremental loss 
(the &quot;mu's&quot; of Clark's paper)</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the actual minus fitted value for 
each observed incremental loss</p>
</td></tr>
<tr><td><code>stdresid</code></td>
<td>
<p> the standardized residuals for 
each observed incremental loss
(= residuals/sqrt(sigma2*fitted), 
referred to as &quot;normalized residuals&quot; in Clark's paper; see p. 62)</p>
</td></tr>
<tr><td><code>FI</code></td>
<td>
<p>the &quot;Fisher Information&quot; matrix as defined in Clark's paper
(i.e., without the sigma^2 value)</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>the value of the loglikelihood function at the solution point</p>
</td></tr>
<tr><td><code>counts</code></td>
<td>
<p>the number of calls to the loglikelihood function
and its gradient function when numerical convergence was achieved</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Murphy
</p>


<h3>References</h3>

<p>Clark, David R., 
&quot;LDF Curve-Fitting and Stochastic Reserving: A Maximum Likelihood Approach&quot;,
<em>Casualty Actuarial Society Forum</em>, Fall, 2003
<a href="https://www.casact.org/sites/default/files/database/forum_03fforum_03ff041.pdf">https://www.casact.org/sites/default/files/database/forum_03fforum_03ff041.pdf</a> 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ClarkCapeCod">ClarkCapeCod</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- GenIns
ClarkLDF(X, maxage=20)

# Clark's "LDF method" also works with triangles that have  
# more development periods than origin periods
ClarkLDF(qincurred, G="loglogistic")

# Method also works for a "triangle" with only one row:
# 1st row of GenIns; need "drop=FALSE" to avoid becoming a vector.
ClarkLDF(GenIns[1, , drop=FALSE], maxage=20)

# The age of the first evaluation may be prior to the end of the origin period.
# Here the ages are in units of "months" and the first evaluation 
# is at the end of the third quarter.
X &lt;- GenIns
colnames(X) &lt;- 12 * as.numeric(colnames(X)) - 3
# The indicated liability increases from 1st example above, 
# but not significantly.
ClarkLDF(X, maxage=240)
# When maxage is infinite, the phase shift has a more noticeable impact:
# a 4-5% increase of the overall CV.
x &lt;- ClarkLDF(GenIns, maxage=Inf)
y &lt;- ClarkLDF(X, maxage=Inf)
# Percent change in the bottom line CV:
(tail(y$Table65$TotalCV, 1) - tail(x$Table65$TotalCV, 1)) / tail(x$Table65$TotalCV, 1)

</code></pre>

<hr>
<h2 id='CLFMdelta'> Find &quot;selection consistent&quot; values of delta  </h2><span id='topic+CLFMdelta'></span>

<h3>Description</h3>

<p>This function finds the values of delta,
one for each development period, 
such that the model coefficients resulting from 
the 'chainladder' function with delta = solution are consistent
with an input vector of 'selected' development age-to-age factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
CLFMdelta(Triangle, selected, tolerance = .0005, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CLFMdelta_+3A_triangle">Triangle</code></td>
<td>
<p>cumulative claims triangle.  A (mxn)-matrix <code class="reqn">C_{ik}</code> 
which is filled for <code class="reqn">k \leq n+1-i; i=1,\ldots,m; m\geq n </code>, see
<code><a href="#topic+qpaid">qpaid</a></code> for how to use (mxn)-development triangles with
m&lt;n, say higher development period frequency (e.g quarterly) than
origin period frequency (e.g accident years).</p>
</td></tr>
<tr><td><code id="CLFMdelta_+3A_selected">selected</code></td>
<td>
<p> a vector of selected age-to-age factors or &quot;link ratios&quot;,
one for each development period of 'Triangle'</p>
</td></tr>
<tr><td><code id="CLFMdelta_+3A_tolerance">tolerance</code></td>
<td>
<p>a 'tolerance' parameters. Default: .0005;
for each element of 'selected' 
a solution 'delta' will be found &ndash; if possible &ndash;
so that the chainladder model indexed by
'delta' results in a multiplicative coefficient within 'tolerance' 
of the 'selected' factor.</p>
</td></tr>

<tr><td><code id="CLFMdelta_+3A_...">...</code></td>
<td>
<p> not in use</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a given input Triangle and vector of selected factors, 
a search is conducted for chainladder models that are &quot;consistent with&quot; the 
selected factors. 
By &quot;consistent with&quot; is meant that the coefficients of the <code><a href="#topic+chainladder">chainladder</a></code> 
function are equivalent to the selected factors.
Not all vectors of selected factors can be considered consistent with a given
Triangle; 
feasibility is subject to restrictions on the 'selected' factors relative to
the input 'Triangle'.
See the References.
</p>
<p>The default average produced by the <code>chainladder</code> function is the 
volume weighted average and corresponds to <code>delta = 1</code> in the call
to that function;
<code>delta = 2</code> produces the simple average; and
<code>delta = 0</code> produces the &quot;regression average&quot;, i.e., 
the slope of a regression line fit to the data 
and running through the origin.
By convention, if the <code>selected</code> value corresponds to 
the volume-weighted average, the simple average, or the regression average,
then the value returned will be 1, 2, and 0, respectively. 
</p>
<p>Other real-number values for <code>delta</code> will produce a different average.
The point of this function is to see if there exists a model as determined
by delta whose average is consistent with the value in the 
<code>selected</code> vector.
That is not always possible. See the References.
</p>
<p>It can be the case that one or more of the above three &quot;standard averages&quot; 
will be quite close to each other 
(indistinguishable within <code>tolerance</code>).
In that case, the value returned will be, in the following priority order
by convention,
1 (volume weighted average),
2 (simple average), or
0 (regression average).
</p>


<h3>Value</h3>

<p>A vector of real numbers, say delta0, such that 
<code>coef(chainladder(Triangle, delta = delta0))</code> = <code>selected</code>
within <code>tolerance</code>.
A <code>logical</code> attribute 'foundSolution' indicates if a solution was
found for each element of <code>selected</code>.
</p>


<h3>Author(s)</h3>

<p>Dan Murphy
</p>


<h3>References</h3>

<p><cite>Bardis, Majidi, Murphy. A Family of Chain-Ladder Factor Models for Selected Link Ratios. <em>Variance</em>. Pending. Variance 6:2, 2012, pp. 143-160.</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- RAA[1:9,1]
y &lt;- RAA[1:9,2]
F &lt;- y/x
CLFMdelta(RAA[1:9, 1:2], selected = mean(F)) # value is 2, 'foundSolution' is TRUE
CLFMdelta(RAA[1:9, 1:2], selected = sum(y) / sum(x)) # value is 1, 'foundSolution' is TRUE

selected &lt;- mean(c(mean(F), sum(y) / sum(x))) # an average of averages
CLFMdelta(RAA[1:9, 1:2], selected) # about 1.725
CLFMdelta(RAA[1:9, 1:2], selected = 2) # negative solutions are possible

# Demonstrating an "unreasonable" selected factor.
CLFMdelta(RAA[1:9, 1:2], selected = 1.9) # NA solution, with warning

</code></pre>

<hr>
<h2 id='coef.ChainLadder'> Extract residuals of a ChainLadder model </h2><span id='topic+coef.ChainLadder'></span>

<h3>Description</h3>

<p>Extract residuals of a <code><a href="#topic+MackChainLadder">MackChainLadder</a></code> model by 
origin-, calendar- and development period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ChainLadder'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.ChainLadder_+3A_object">object</code></td>
<td>
<p>output of the <code><a href="#topic+chainladder">chainladder</a></code> function</p>
</td></tr>
<tr><td><code id="coef.ChainLadder_+3A_...">...</code></td>
<td>
<p>optional arguments which may become named
attributes of the resulting vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a vector of the single-parameter coefficients &ndash; also
called age-to-age (ATA) or report-to-report (RTR) factors &ndash;
of the models produced by running the 'chainladder' function.
</p>


<h3>Author(s)</h3>

<p> Dan Murphy </p>


<h3>See Also</h3>

<p> See Also <code><a href="#topic+chainladder">chainladder</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
coef(chainladder(RAA))

</code></pre>

<hr>
<h2 id='Cumulative+20and+20incremental+20triangles'>Cumulative and incremental triangles</h2><span id='topic+incr2cum'></span><span id='topic+cum2incr'></span>

<h3>Description</h3>

<p>Functions to convert between cumulative and incremental triangles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>incr2cum(Triangle, na.rm=FALSE)
cum2incr(Triangle)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cumulative+2B20and+2B20incremental+2B20triangles_+3A_triangle">Triangle</code></td>
<td>
<p>triangle. Assume columns are the development
period, use transpose otherwise.</p>
</td></tr>
<tr><td><code id="Cumulative+2B20and+2B20incremental+2B20triangles_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Should missing values be removed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>incr2cum</code> transforms an incremental triangle into a cumulative
triangle, <code>cum2incr</code> provides the reserve operation.
</p>


<h3>Value</h3>

<p>Both functions return a <code>triangle</code>.  
</p>


<h3>Author(s)</h3>

<p>Markus Gesmann, Christophe Dutang</p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+as.triangle">as.triangle</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# See the Taylor/Ashe example in Mack's 1993 paper

#original triangle
GenIns

#incremental triangle
cum2incr(GenIns)

#original triangle
incr2cum(cum2incr(GenIns))

# See the example in Mack's 1999 paper

#original triangle
Mortgage
incMortgage &lt;- cum2incr(Mortgage)
#add missing values
incMortgage[1,1] &lt;- NA
incMortgage[2,1] &lt;- NA
incMortgage[1,2] &lt;- NA

#with missing values argument
incr2cum(incMortgage, na.rm=TRUE)

#compared to 
incr2cum(Mortgage)

</code></pre>

<hr>
<h2 id='cyEffTest'> Testing for Calendar Year Effect </h2><span id='topic+cyEffTest'></span>

<h3>Description</h3>

<p>One of the three basic assumptions underlying the chain ladder
method is the independence of the accident years. 
The function tests this assumption.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cyEffTest(Triangle, ci = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cyEffTest_+3A_triangle">Triangle</code></td>
<td>
<p>cumulative claims triangle.  Assume columns are the development
period, use transpose otherwise.
A (mxn)-matrix <code class="reqn">C_{ik}</code> 
which is filled for <code class="reqn">k \leq n+1-i; i=1,\ldots,m; m\geq n </code>, see
<code><a href="#topic+qpaid">qpaid</a></code> for how to use (mxn)-development triangles with
m&lt;n, say higher development period frequency (e.g quarterly) than
origin period frequency (e.g accident years).</p>
</td></tr>
<tr><td><code id="cyEffTest_+3A_ci">ci</code></td>
<td>
<p>confidence interval. Default: .95. A confidence interval is 
a type of interval estimate, computed from the statis tics of the observed data, 
that might contain the true value of an unknown population parameter. 
The interval has an associated confidence level that quantifies 
the level of confidence that the parameter lies in the interval. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main reason why this independence can be violated in practice is the fact that 
there could be certain calendar year effects such as major changes in claims handling or in case reserving or external influences such as substantial changes in court decisions or inflation.
</p>
<p>As described by the Mack's 1994 paper a procedure is designed to test for calendar year influences.
</p>
<p>The procedure returns a summary statistic <code class="reqn">Z</code> which is assumed to be Normally Distributed. It is therefore possible to define a confidence interval threshold in order to evaluate the outcome of the test.
</p>


<h3>Value</h3>

<p>cyEffTest returns a list with the following elements
</p>
<table>
<tr><td><code>test_table</code></td>
<td>
<p>complete table of results</p>
</td></tr> 
<tr><td><code>Z</code></td>
<td>
<p>summary statistic</p>
</td></tr>
<tr><td><code>E</code></td>
<td>
<p>expected value of the resulting distribution</p>
</td></tr>
<tr><td><code>Var</code></td>
<td>
<p>variance of the resulting distribution</p>
</td></tr>
<tr><td><code>Range</code></td>
<td>
<p>vector of the range corresponding the confidence interval threshold selected</p>
</td></tr>
<tr><td><code>ci</code></td>
<td>
<p>confidence interval</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Additional references for further reading:
</p>
<p><cite>Thomas Mack. Distribution-free calculation of the standard error of chain ladder reserve estimates. <em>Astin Bulletin</em>. Vol. 23. No 2. 1993. pp.213:225</cite>
</p>
<p><cite>Thomas Mack. The standard error of chain ladder reserve estimates: Recursive calculation and inclusion of a tail factor. <em>Astin Bulletin</em>. Vol. 29. No 2. 1999. pp.361:366</cite>
</p>


<h3>Author(s)</h3>

<p>Marco De Virgilis <a href="mailto:devirgilis.marco@gmail.com">devirgilis.marco@gmail.com</a></p>


<h3>References</h3>

<p><cite>Mack, T., Measuring the Variability of Chain Ladder Reserve Estimates, <em>Casualty Actuarial Society Forum</em>, Spring 1994</cite>
</p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+qpaid">qpaid</a></code> for dealing with non-square triangles,  
<code><a href="#topic+dfCorTest">dfCorTest</a></code> for the test for correlations between subsequent development factors,
<code><a href="#topic+chainladder">chainladder</a></code> for the chain-ladder method,
<code><a href="#topic+summary.cyEffTest">summary.cyEffTest</a></code>,  
<code><a href="#topic+plot.cyEffTest">plot.cyEffTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Before actually applying the Chain Ladder technique it is necessary to check
# wether the triangle has Calendar Year Effect

# Apply the function to the triangle and save the output into the variable test
test &lt;- cyEffTest(RAA)

# Plot the confidence interval and the test metric
plot(test)

# The metric is within the confidence interval, therefore the triangle doesn't
# have Calendar Year Effect

# Print the summary table
summary(test)

# Print only the main outcomes
print(test)
# The test has returned a negative outcome. This means that the triangle is 
# not affected by Caledar Year Effect and therefore the chain ladder method 
# can be applied.
</code></pre>

<hr>
<h2 id='dfCorTest'> Testing for Correlations between Subsequent Development Factors </h2><span id='topic+dfCorTest'></span>

<h3>Description</h3>

<p>One of the main assumptions underlying the chain ladder
method is the uncorrelation of subsequest development factor. 
The function tests this assumption.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfCorTest(Triangle, ci = .5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dfCorTest_+3A_triangle">Triangle</code></td>
<td>
<p>cumulative claims triangle.  Assume columns are the development
period, use transpose otherwise.
A (mxn)-matrix <code class="reqn">C_{ik}</code> 
which is filled for <code class="reqn">k \leq n+1-i; i=1,\ldots,m; m\geq n </code>, see
<code><a href="#topic+qpaid">qpaid</a></code> for how to use (mxn)-development triangles with
m&lt;n, say higher development period frequency (e.g quarterly) than
origin period frequency (e.g accident years).</p>
</td></tr>
<tr><td><code id="dfCorTest_+3A_ci">ci</code></td>
<td>
<p>confidence interval. Default: .5. A confidence interval is 
a type of interval estimate, computed from the statis tics of the observed data, 
that might contain the true value of an unknown population parameter. 
The interval has an associated confidence level that quantifies 
the level of confidence that the parameter lies in the interval. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As described by the Mack's 1994 paper a procedure is designed to test for calendar year influences.
</p>
<p>The usual test for uncorrelatedness requires that we have identically distributed pairs of observations which come from a  Normal distribution. Both conditions are usually not fulfilled for adjacent columns of development factors. Spearman's correlation coefficient is therefore used.
</p>
<p>The metric calulated by the procudeure described return a statistic <code class="reqn">T</code> that it is assumed to be Normally Distributed. It is therefore possible to define a confidence interval threshold in order to evaluate the outcome of the test.
</p>


<h3>Value</h3>

<p>dfCorTest returns a list with the following elements
</p>
<table>
<tr><td><code>T_stat</code></td>
<td>
<p>summary statistic</p>
</td></tr>
<tr><td><code>Var</code></td>
<td>
<p>variance of the resulting distribution</p>
</td></tr>
<tr><td><code>Range</code></td>
<td>
<p>vector of the range corresponding the confidence interval threshold selected</p>
</td></tr>
<tr><td><code>ci</code></td>
<td>
<p>confidence interval</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Additional references for further reading:
</p>
<p><cite>Thomas Mack. Distribution-free calculation of the standard error of chain ladder reserve estimates. <em>Astin Bulletin</em>. Vol. 23. No 2. 1993. pp.213:225</cite>
</p>
<p><cite>Thomas Mack. The standard error of chain ladder reserve estimates: Recursive calculation and inclusion of a tail factor. <em>Astin Bulletin</em>. Vol. 29. No 2. 1999. pp.361:366</cite>
</p>
<p><cite>Venter, G.G., Testing the Assumptions of Age-to-Age Factors, <em>Proceedings of the Casualty Actuarial Society</em> LXXXV, 1998, pp. 807-847</cite>
</p>


<h3>Author(s)</h3>

<p>Marco De Virgilis <a href="mailto:devirgilis.marco@gmail.com">devirgilis.marco@gmail.com</a></p>


<h3>References</h3>

<p><cite>Mack, T., Measuring the Variability of Chain Ladder Reserve Estimates, <em>Casualty Actuarial Society Forum</em>, Spring 1994</cite>
</p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+qpaid">qpaid</a></code> for dealing with non-square triangles,  
<code><a href="#topic+cyEffTest">cyEffTest</a></code> for the test for calendar year effect,
<code><a href="#topic+chainladder">chainladder</a></code> for the chain-ladder method,
<code><a href="#topic+summary.dfCorTest">summary.dfCorTest</a></code>,  
<code><a href="#topic+plot.dfCorTest">plot.dfCorTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Before actually applying the Chain Ladder technique it is necessary to check
# whether the Development Factors are correlated

# Apply the function to the triangle and save the output into the variable test
test &lt;- dfCorTest(RAA)

# Plot the confidence interval and the test metric
plot(test)

# The metric is within the confidence interval, therefore the Development Factors are nor correlated

# Print the summary table
summary(test)

# Print only the main outcomes
print(test)
# The test has returned a negative outcome. This means that the triangle is 
# not affected by Development Factor Correlation and therefore the chain ladder method 
# can be applied.
</code></pre>

<hr>
<h2 id='GenIns'>
Run off triangle of claims data.
</h2><span id='topic+GenIns'></span><span id='topic+GenInsLong'></span>

<h3>Description</h3>

<p>Run off triangle of accumulated general insurance claims
data. <code>GenInsLong</code> provides the same data in a 'long' format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenIns</code></pre>


<h3>Format</h3>

<p> A matrix with 10 accident years and 10 development years.
</p>


<h3>Source</h3>

<p><cite>TAYLOR, G.C. and ASHE, F.R. (1983) Second Moments of Estimates
of Outstanding Claims.  <em>Journal of Econometrics</em> <b>23</b>, 37-61. </cite>
</p>


<h3>References</h3>

<p>See table 1 in: 
<cite>Distribution-free Calculation of the
Standard Error of Chain Ladder Reserve Estimates, Thomas Mack, 1993,
<em>ASTIN Bulletin</em> <b>23</b>, 213 - 225</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GenIns
plot(GenIns)

plot(GenIns, lattice=TRUE)


head(GenInsLong)

## Convert long format into triangle
## Triangles are usually stored as 'long' tables in data bases
as.triangle(GenInsLong, origin="accyear", dev="devyear", "incurred claims")

</code></pre>

<hr>
<h2 id='getLatestCumulative'>
Triangle information for most recent calendar period.
</h2><span id='topic+getLatestCumulative'></span>

<h3>Description</h3>

<p>Return most recent values for all origin periods of a cumulative development triangle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLatestCumulative(Triangle, na.values = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getLatestCumulative_+3A_triangle">Triangle</code></td>
<td>
<p>a Triangle in matrix format.</p>
</td></tr>
<tr><td><code id="getLatestCumulative_+3A_na.values">na.values</code></td>
<td>
<p>a vector specifying values that should be 
considered synonymous with NA when searching for the rightmost non-NA.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of most recent non-'NA' (and synonyms, if appropriate) values
of a triangle for all origin periods.
The <code>names</code> of the vector equal the origin names of the Triangle.
The vector will have additional attributes:
&quot;latestcol&quot; equalling the index of the column in Triangle corresponding
to the row's rightmost entry;
&quot;rowsname&quot; equalling the name of the row dimension of Triangle, if any;
&quot;colnames&quot; equalling the corresponding column name of Triangle, if any;
&quot;colsname&quot; equalling the name of the column dimension of Triangle, if any.
</p>


<h3>Author(s)</h3>

<p>Ben Escoto, Markus Gesmann, Dan Murphy  
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+as.triangle">as.triangle</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RAA
getLatestCumulative(RAA)
Y &lt;- matrix(c(1,  2,  3,
              4,  5,  0, 
              6, NA, NA), byrow=TRUE, nrow=3)
getLatestCumulative(Y) # c(3, 0, 6) 
getLatestCumulative(Y, na.values = 0) # c(3, 5, 6) 
</code></pre>

<hr>
<h2 id='glmReserve'>
GLM-based Reserving Model 
</h2><span id='topic+glmReserve'></span><span id='topic+plot.glmReserve'></span><span id='topic+summary.glmReserve'></span><span id='topic+print.glmReserve'></span><span id='topic+resid.glmReserve'></span>

<h3>Description</h3>

<p>This function implements loss reserving models within the generalized linear model framework. It takes accident year and development lag as mean predictors in estimating the ultimate loss reserves, and provides both analytical  and bootstrapping methods to compute the associated prediction errors. The bootstrapping approach also generates the full predictive distribution for loss reserves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glmReserve(triangle, var.power = 1, link.power = 0, cum = TRUE, 
      mse.method = c("formula", "bootstrap"),  nsim = 1000, nb = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glmReserve_+3A_triangle">triangle</code></td>
<td>

<p>An object of  class <code><a href="#topic+triangle">triangle</a></code>. 
</p>
</td></tr>
<tr><td><code id="glmReserve_+3A_var.power">var.power</code></td>
<td>

<p>The index (p) of the power variance function <code class="reqn">V(\mu)=\mu^p</code>. Default to <code>p = 1</code>, which is the over-dispersed Poisson model. If <code>NULL</code>, it will be assumed to be in <code>(1, 2)</code> and estimated using the <code>cplm</code> package.  See <code><a href="statmod.html#topic+tweedie">tweedie</a></code>.
</p>
</td></tr>
<tr><td><code id="glmReserve_+3A_link.power">link.power</code></td>
<td>

<p>The index of power link function. The default <code>link.power = 0</code> produces a log link. See <code><a href="statmod.html#topic+tweedie">tweedie</a></code>.
</p>
</td></tr>
<tr><td><code id="glmReserve_+3A_cum">cum</code></td>
<td>

<p>A logical value indicating whether the input triangle is on the
cumulative or the incremental scale. If <code>TRUE</code>, then
<code>triangle</code> is assumed to be on the cumulative scale, and it will
be converted to incremental losses internally before a GLM is fitted. 
</p>
</td></tr>
<tr><td><code id="glmReserve_+3A_mse.method">mse.method</code></td>
<td>

<p>A character indicating whether the prediction error should be computed analytically (<code>mse.method = "formula"</code>) or via bootstrapping (<code>mse.method = "bootstrap"</code>). Partial match is supported. 
</p>
</td></tr>
<tr><td><code id="glmReserve_+3A_nsim">nsim</code></td>
<td>

<p>Number of simulations to be performed in the bootstrapping, with a default value of 1000.
</p>
</td></tr>
<tr><td><code id="glmReserve_+3A_nb">nb</code></td>
<td>

<p>Whether the negative binomial distribution is used. If <code>true</code>, the arguments <code>var.power</code> and <code>link.power</code> are ignored and a negative binomial GLM is fitted using <code>glm.nb</code>. 
</p>
</td></tr>
<tr><td><code id="glmReserve_+3A_...">...</code></td>
<td>

<p>Arguments to be passed onto the function <code><a href="stats.html#topic+glm">glm</a></code> or <code><a href="cplm.html#topic+cpglm">cpglm</a></code> such as <code>contrasts</code> or <code>control</code>. It is important that <code>offset</code> and <code>weight</code> should not be specified. Otherwise, an error will be reported and the program will quit. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes an insurance loss triangle, converts it to incremental losses internally if necessary, transforms it to the long format (see <code>as.data.frame</code>) and fits the resulting loss data with a generalized linear model where the mean structure includes both the accident year and the development lag effects.
The distributions allowed are the exponential family that admits a power variance function, that is, <code class="reqn">V(\mu)=\mu^p</code>.
This subclass of distributions is usually called the Tweedie distribution and includes many commonly used distributions as special cases.
</p>
<p>This function does not allow the user to specify the GLM options through the usual <code><a href="stats.html#topic+family">family</a></code> argument, but instead, it uses the <code><a href="statmod.html#topic+tweedie">tweedie</a></code> family internally and takes two arguments, <code>var.power</code> and <code>link.power</code>, through which the user still has full control of the distribution forms and link functions.
The argument <code>var.power</code> determines which specific distribution is to be used, and <code>link.power</code> determines the form of the link function.
</p>
<p>When the Tweedie compound Poisson distribution <code>1 &lt; p &lt; 2</code> is to be used, the user has the option to specify <code>var.power = NULL</code>, where the variance power <code>p</code> will be estimated from the data using the <code>cplm</code> package. The <code>bcplm</code> function in the <code>cplm</code> package also has an example for the Bayesian compound Poisson loss reserving model.
See details in <code><a href="statmod.html#topic+tweedie">tweedie</a></code>, <code><a href="cplm.html#topic+cpglm">cpglm</a></code> and  <code><a href="cplm.html#topic+bcplm">bcplm</a></code>. 
</p>
<p><code>glmReserve</code> allows certain measures of exposures to be used in an offset term in the underlying GLM.
To do this, the user should not use the usual <code>offset</code> argument in <code>glm</code>.
Instead, one specifies the exposure measure for each accident year through the <code>exposure</code> attribute of <code>triangle</code>. 
Make sure that these exposures are in the original scale (no log transformations for example).
If the vector is named, make sure the names coincide with the rownames/origin of the triangle.
If the vector is unnamed, make sure the exposures are in the order consistent with the accident years, <b>and the character rownames of the Triangle must be convertible to numeric.</b> 
If the <code>exposure</code> attribute is not <code>NULL</code>, the <code>glmReserve</code> function will use these exposures, link-function-transformed, in the offset term of the GLM. 
For example, if the link function is <code>log</code>, then the log of the exposure is used as the offset, not the original exposure. 
See the examples below. 
Moreover, the user MUST NOT supply the typical <code>offset</code> or <code>weight</code> as arguments in the list of additional arguments <code>...</code>. <code>offset</code> should be specified as above, while <code>weight</code> is not implemented (due to prediction reasons). 
</p>
<p>Two methods are available to assess the prediction error of the estimated loss reserves.
One is using the analytical formula (<code>mse.method = "formula"</code>) derived from the first-order Taylor approximation.
The other is using bootstrapping (<code>mse.method = "bootstrap"</code>) that reconstructs the triangle <code>nsim</code> times by sampling with replacement from the GLM (Pearson) residuals.
Each time a new triangle is formed, GLM is fitted and corresponding loss reserves are generated.
Based on these predicted mean loss reserves, and the model assumption about the distribution forms, realizations of the predicted values are generated via the <code>rtweedie</code> function.
Prediction errors as well as other uncertainty measures such as quantiles and predictive intervals can be calculated based on these samples. 
</p>


<h3>Value</h3>

<p>The output is an object of class <code>"glmReserve"</code> that has the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>summary</code></td>
<td>
<p>A data frame containing the predicted loss reserve statistics. Similar to the summary statistics from <code>MackChainLadder</code>.</p>
</td></tr>
<tr><td><code>Triangle</code></td>
<td>
<p>The input triangle.</p>
</td></tr>
<tr><td><code>FullTriangle</code></td>
<td>
<p>The completed triangle, where empty cells in the original triangle are filled with model predictions.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>The fitted GLM, a class of <code>"glm"</code> or <code>"cpglm"</code>. It is most convenient to work with this component when model fit information is wanted. </p>
</td></tr>
<tr><td><code>sims.par</code></td>
<td>
<p>a matrix of the simulated parameter values in the bootstrapping. </p>
</td></tr>
<tr><td><code>sims.reserve.mean</code></td>
<td>
<p>a matrix of the simulated mean loss reserves (without the process variance) for each year in the bootstrapping. </p>
</td></tr>
<tr><td><code>sims.par</code></td>
<td>
<p>a matrix of the simulated realizations of the loss reserves (with the process variance) for each year in the bootstrapping. This can be used to summarize the predictive uncertainty of the loss reserves.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The use of GLM in insurance loss reserving has many compelling aspects, e.g.,
</p>

<ul>
<li><p> when over-dispersed Poisson model is used, it reproduces the estimates from Chain Ladder;
</p>
</li>
<li><p> it provides a more coherent modeling framework than the Mack method;
</p>
</li>
<li><p> all the relevant established statistical theory can be directly applied to perform hypothesis testing and diagnostic checking;
</p>
</li></ul>

<p>However,  the user should be cautious of some of the key assumptions that underlie the GLM model, in order to determine whether this model is appropriate for the problem considered:
</p>

<ul>
<li><p> the GLM model assumes no tail development, and it only projects losses to the latest time point of the observed data. To use a model that enables tail extrapolation, please consider the growth curve model <code><a href="#topic+ClarkLDF">ClarkLDF</a></code> or <code><a href="#topic+ClarkCapeCod">ClarkCapeCod</a></code>;
</p>
</li>
<li><p> the model assumes that each incremental loss is independent of all the others.
This assumption may not be valid in that cells from the same calendar year are usually correlated due to inflation or business operating factors;
</p>
</li>
<li><p> the model tends to be over-parameterized, which may lead to inferior predictive performance. 
</p>
</li></ul>

<p>To solve these potential problems, many variants of the current basic GLM model have been proposed in the actuarial literature.
Some of these may be included in the future release.
</p>
<p>Support of the negative binomial GLM was added since version 0.2.3.  
</p>


<h3>Author(s)</h3>

<p>Wayne Zhang <a href="mailto:actuary_zhang@hotmail.com">actuary_zhang@hotmail.com</a>
</p>


<h3>References</h3>

<p>England P. and Verrall R. (1999). Analytic and bootstrap estimates of prediction errors in claims reserving. <em>Insurance: Mathematics and Economics</em>, 25, 281-293.
</p>


<h3>See Also</h3>

<p>See also <code><a href="stats.html#topic+glm">glm</a></code>, <code><a href="MASS.html#topic+glm.nb">glm.nb</a></code>, <code><a href="statmod.html#topic+tweedie">tweedie</a></code>,  <code><a href="cplm.html#topic+cpglm">cpglm</a></code> and <code><a href="#topic+MackChainLadder">MackChainLadder</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(GenIns)
GenIns &lt;- GenIns / 1000

# over-dispersed Poisson: reproduce ChainLadder estimates
(fit1 &lt;- glmReserve(GenIns))
summary(fit1, type = "model")   # extract the underlying glm

# which:
# 1 Original triangle 
# 2 Full triangle 
# 3 Reserve distribution
# 4 Residual plot
# 5 QQ-plot

# plot original triangle
plot(fit1, which = 1, xlab = "dev year", ylab = "cum loss")

# plot residuals 
plot(fit1, which = 4, xlab = "fitted values", ylab = "residuals")

# Gamma GLM:
(fit2 &lt;- glmReserve(GenIns, var.power = 2))

# compound Poisson GLM (variance function estimated from the data):
(fit3 &lt;- glmReserve(GenIns, var.power = NULL))

# Now suppose we have an exposure measure
# we can put it as an offset term in the model
# to do this, use the "exposure" attribute of the 'triangle'
expos &lt;- (7 + 1:10 * 0.4) * 100
GenIns2 &lt;- GenIns
attr(GenIns2, "exposure") &lt;- expos
(fit4 &lt;- glmReserve(GenIns2))
# If the triangle's rownames are not convertible to numeric,
# supply names to the exposures
GenIns3 &lt;- GenIns2
rownames(GenIns3) &lt;- paste0(2007:2016, "-01-01")
names(expos) &lt;- rownames(GenIns3)
attr(GenIns3, "exposure") &lt;- expos
(fit4b &lt;- glmReserve(GenIns3))

# use bootstrapping to compute prediction error
## Not run: 
set.seed(11)
(fit5 &lt;- glmReserve(GenIns, mse.method = "boot"))

# compute the quantiles of the predicted loss reserves
t(apply(fit5$sims.reserve.pred, 2, quantile, 
        c(0.025, 0.25, 0.5, 0.75, 0.975)))
        
# plot distribution of reserve
plot(fit5, which = 3)

## End(Not run)

# alternative over-dispersed Poisson: negative binomial GLM
(fit6 &lt;- glmReserve(GenIns, nb = TRUE))

</code></pre>

<hr>
<h2 id='inflateTriangle'> Inflate a Triangle based on an Inflation Rate </h2><span id='topic+inflateTriangle'></span>

<h3>Description</h3>

<p>Inflate the amounts of a Triangle from the latest diagonal based on an Inflation Rate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  inflateTriangle(Triangle, rate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inflateTriangle_+3A_triangle">Triangle</code></td>
<td>
<p>claim triangle. Assume columns are the development
period, use transpose otherwise.
A (mxn)-matrix <code class="reqn">C_{ik}</code> 
which is filled for <code class="reqn">k \leq n+1-i; i=1,\ldots,m; m\geq n </code>, see
<code><a href="#topic+qpaid">qpaid</a></code> for how to use (mxn)-development triangles with
m&lt;n, say higher development period frequency (e.g quarterly) than
origin period frequency (e.g accident years).</p>
</td></tr>
<tr><td><code id="inflateTriangle_+3A_rate">rate</code></td>
<td>
<p>Inflation rate to be applied to the triangle according to an exponential model</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sensitivity of projections of ultimate losses based on incurred loss
development factors to changes in the adequacy level of case reserves increases
significantly for the long-tail lines. In particular, if the adequacy of the case reserve
is changing, the estimates of ultimate losses based on reported claims could be severely distorted.
The function deflates the amounts of latest diagonal to each diagonal of the triangle according to the inflation rate provided, 
considering an exponential model.
The purpose of restating the amounts is to have each diagonal in the triangle at the same level as 
the latest diagonal (i.e. latest valuation).
Ideally the metrics that should be restated are average O/S or average claim paid.
</p>


<h3>Value</h3>

<p>inflateTriangle returns the inflated triangle according to the provided rate 
</p>


<h3>Author(s)</h3>

<p>Marco De Virgilis <a href="mailto:devirgilis.marco@gmail.com">devirgilis.marco@gmail.com</a></p>


<h3>References</h3>

<p><cite>Berquist, J.R. and Sherman, R.E., Loss Reserve Adequacy Testing: A Comprehensive,
Systematic Approach, <em>Proceedings of the Casualty Actuarial Society</em>, LXIV, 1977, pp.123-184.</cite>
</p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+qpaid">qpaid</a></code> for dealing with non-square triangles,  
<code><a href="#topic+checkTriangleInflation">checkTriangleInflation</a></code> to check Y-o-Y Triangle Inflation Rates,
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a Triangle of Average Case O/S

avg &lt;- MedMal$MedMalOutstanding / MedMal$MedMalOpen

# Select a rate of 15% and inflate the average =/S Triangle

inflated_tr &lt;- inflateTriangle(Triangle = avg, rate = .15) 

# Multiply it by open claims and add paymnets to calulate the adjusted Reported Claims Trinagle

adj_reported &lt;- inflated_tr * MedMal$MedMalOpen + MedMal$MedMalPaid

# Calculate the IBNR from the unadjusted Triangle

std_ibnr &lt;- summary(MackChainLadder(MedMal$MedMalReported))$Totals[4, 1]

# Calculate the IBNR from the adjusted Triangle

adj_reported_ibnr &lt;- summary(MackChainLadder(adj_reported))$Totals[4, 1]

# Compare the two

std_ibnr - adj_reported_ibnr
</code></pre>

<hr>
<h2 id='Join2Fits'> Join Two Fitted MultiChainLadder Models </h2><span id='topic+Join2Fits'></span>

<h3>Description</h3>

<p>This function is created to facilitate the fitting of the multivariate functions when specifying different models in two different development periods, especially when separate chain-ladder is used in later periods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Join2Fits(object1, object2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Join2Fits_+3A_object1">object1</code></td>
<td>
<p> An object of class &quot;MultiChainLadder&quot; </p>
</td></tr>
<tr><td><code id="Join2Fits_+3A_object2">object2</code></td>
<td>
<p> An object of class &quot;MultiChainLadder&quot; </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The inputs must be of class  &quot;MultiChainLadder&quot; because this function depends on the <code>model</code> slot to determine what kind of object is to be created and returned. If both objects have <code>"MCL"</code>, then an object of class &quot;MCLFit&quot; is created; if one has <code>"GMCL"</code> and one has <code>"MCL"</code>, then an object of class &quot;GMCLFit&quot; is created, where the one with <code>"GMCL"</code> is assumed to come from the first development periods; if both have <code>"GMCL"</code>, then an object of class &quot;GMCLFit&quot; is created. 
</p>


<h3>Author(s)</h3>

<p>Wayne Zhang <a href="mailto:actuary_zhang@hotmail.com">actuary_zhang@hotmail.com</a></p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+MultiChainLadder">MultiChainLadder</a></code>
</p>

<hr>
<h2 id='JoinFitMse'> Join Model Fit and Mse Estimation </h2><span id='topic+JoinFitMse'></span>

<h3>Description</h3>

<p>This function combines first momoent estimation from fitted regression models and second moment estimation from <code>Mse</code> method to construct an object of class &quot;MultiChainLadder&quot;, for which a variety of methods are defined, such as <code>summary</code> and <code>plot</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JoinFitMse(models, mse.models)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="JoinFitMse_+3A_models">models</code></td>
<td>
<p> fitted regression models, either of class &quot;MCLFit&quot; or &quot;GMCLFit&quot;. </p>
</td></tr>
<tr><td><code id="JoinFitMse_+3A_mse.models">mse.models</code></td>
<td>
<p> output from a call to <code>Mse</code>, which is of class &quot;MultiChainLadderMse&quot;. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Wayne Zhang <a href="mailto:actuary_zhang@hotmail.com">actuary_zhang@hotmail.com</a></p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+MultiChainLadder">MultiChainLadder</a>.</code>
</p>

<hr>
<h2 id='liab'>Run off triangle of accumulated claim data</h2><span id='topic+liab'></span>

<h3>Description</h3>

<p>Run-off triangles of General Liability and Auto Liability.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(auto)</code></pre>


<h3>Format</h3>

<p>A list of two matrices, General Liability and Auto Liability respectively.
</p>


<h3>Source</h3>

<p><cite>Braun C (2004). The prediction error of the chain ladder method applied to correlated run off triangles. <em>ASTIN Bulletin</em> 34(2): 399-423</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(liab)
names(liab)
</code></pre>

<hr>
<h2 id='LRfunction'> Calculate the Link Ratio Function  </h2><span id='topic+LRfunction'></span>

<h3>Description</h3>

<p>This calculates the link ratio function per the CLFM paper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LRfunction(x, y, delta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LRfunction_+3A_x">x</code></td>
<td>
<p>beginning value of loss during a development period</p>
</td></tr>
<tr><td><code id="LRfunction_+3A_y">y</code></td>
<td>
<p>ending value of loss during a development period</p>
</td></tr>
<tr><td><code id="LRfunction_+3A_delta">delta</code></td>
<td>
<p>numeric</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculated the link ratios resulting from a chainladder model
over a development period indexed by (possibly vector valued) real number delta.
See formula (5) in the References.
</p>


<h3>Value</h3>

<p>A vector of link ratios.
</p>


<h3>Author(s)</h3>

<p>Dan Murphy
</p>


<h3>References</h3>

<p><cite>Bardis, Majidi, Murphy. A Family of Chain-Ladder Factor Models for Selected Link Ratios. <em>Variance</em>. Pending. 2013. pp.tbd:tbd</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- RAA[1:9,1]
y &lt;- RAA[1:9,2]
delta &lt;- seq(-2, 2, by = .1)
plot(delta, LRfunction(x, y, delta), type = "l")
</code></pre>

<hr>
<h2 id='M3IR5'>
Run off triangle of claims data
</h2><span id='topic+M3IR5'></span>

<h3>Description</h3>

<p>Run off triangle of simulated incremental claims data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(M3IR5)</code></pre>


<h3>Format</h3>

<p>A matrix with simulated incremental claims of 14 accident years and 14 development years.
</p>


<h3>Source</h3>

<p>Appendix A7 in 
<cite> B. Zehnwirth. Probabilistic Development Factor Models
with Applications to Loss Reserve Variability, Prediction
Intervals, and Risk Based Capital. <em>Casualty Actuarial
Science Forum.</em> Spring 1994. Vol. 2.</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
M3IR5
plot(M3IR5)
plot(incr2cum(M3IR5), lattice=TRUE)
</code></pre>

<hr>
<h2 id='MackChainLadder'> Mack Chain-Ladder Model </h2><span id='topic+MackChainLadder'></span>

<h3>Description</h3>

<p>The Mack chain-ladder model forecasts future claims developments
based on a historical cumulative claims development triangle and estimates
the standard error around those.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MackChainLadder(Triangle, weights = 1, alpha=1, est.sigma="log-linear",
tail=FALSE, tail.se=NULL, tail.sigma=NULL, mse.method="Mack")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MackChainLadder_+3A_triangle">Triangle</code></td>
<td>
<p>cumulative claims triangle.  Assume columns are the development
period, use transpose otherwise.
A (mxn)-matrix <code class="reqn">C_{ik}</code> 
which is filled for <code class="reqn">k \leq n+1-i; i=1,\ldots,m; m\geq n </code>, see
<code><a href="#topic+qpaid">qpaid</a></code> for how to use (mxn)-development triangles with
m&lt;n, say higher development period frequency (e.g quarterly) than
origin period frequency (e.g accident years).</p>
</td></tr>
<tr><td><code id="MackChainLadder_+3A_weights">weights</code></td>
<td>
<p> weights. Default: 1, which sets the weights for all
triangle entries to 1. Otherwise specify weights as a matrix of the same
dimension as <code>Triangle</code> with all weight entries in [0; 1].
Hence, any entry set to 0 or <code>NA</code> eliminates that age-to-age factor 
from inclusion in the model. See also 'Details'</p>
</td></tr>
<tr><td><code id="MackChainLadder_+3A_alpha">alpha</code></td>
<td>
<p>'weighting' parameters.
Default: 1 for all development periods; alpha=1 gives the historical 
chain-ladder age-to-age factors, alpha=0 gives the straight average of the
observed individual development factors and alpha=2 is the result of
an ordinary regression of <code class="reqn">C_{i,k+1}</code> against <code class="reqn">C_{i,k}</code> with
intercept 0, see also 'Details' below, <code><a href="#topic+chainladder">chainladder</a></code> and Mack's 1999 paper</p>
</td></tr>
<tr><td><code id="MackChainLadder_+3A_est.sigma">est.sigma</code></td>
<td>
<p>defines how to estimate <code class="reqn">sigma_{n-1}</code>, the
variability of the individual age-to-age factors at development time
<code class="reqn">n-1</code>.
Default is &quot;log-linear&quot; for a log-linear regression, &quot;Mack&quot; for
Mack's approximation from his 1999 paper. Alternatively the user can
provide a numeric value. If the log-linear model appears to be
inappropriate (p-value &gt; 0.05) the 'Mack' method will be used
instead and a warning message printed.
Similarly, if Triangle is so small that log-linear regression is being
attempted on a vector of only one non-NA average link ratio,
the 'Mack' method will be used instead and a warning message printed.
</p>
</td></tr>  
<tr><td><code id="MackChainLadder_+3A_tail">tail</code></td>
<td>
<p>can be logical or a numeric value.
If <code>tail=FALSE</code> no tail factor will be applied, if <code>tail=TRUE</code> 
a tail factor will be estimated via a linear extrapolation of
<code class="reqn">log(chain-ladder factors - 1)</code>, if <code>tail</code> is a numeric
value than this value will be used instead.</p>
</td></tr>
<tr><td><code id="MackChainLadder_+3A_tail.se">tail.se</code></td>
<td>
<p>defines how the standard error of the tail factor is estimated. Only needed if
a tail factor &gt; 1 is provided. Default is <code>NULL</code>. If
<code>tail.se</code> is <code>NULL</code>, <code>tail.se</code> is estimated via
&quot;log-linear&quot; regression, if <code>tail.se</code> is a numeric
value than this value will be used instead.</p>
</td></tr>  
<tr><td><code id="MackChainLadder_+3A_tail.sigma">tail.sigma</code></td>
<td>
<p>defines how to estimate individual tail variability. Only needed if
a tail factor &gt; 1 is provided.
Default is <code>NULL</code>. If <code>tail.sigma</code> is <code>NULL</code>,
<code>tail.sigma</code> 
is estimated via &quot;log-linear&quot; regression, if <code>tail.sigma</code> is a numeric
value than this value will be used instead</p>
</td></tr>  
<tr><td><code id="MackChainLadder_+3A_mse.method">mse.method</code></td>
<td>

<p>method used for the recursive estimate of the parameter risk component 
of the mean square error.
Value &quot;Mack&quot; (default) coincides with Mack's formula;
&quot;Independence&quot; includes the additional cross-product term
as in Murphy and BBMW. 
Refer to References below.
</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>Following Mack's 1999 paper let <code class="reqn">C_{ik}</code> denote the cumulative loss 
amounts of origin period (e.g. accident year) 
<code class="reqn">i=1,\ldots,m</code>, with losses known for development period
(e.g. development year) <code class="reqn">k \le n+1-i</code>.
In order to forecast the amounts <code class="reqn">C_{ik}</code> for
<code class="reqn">k &gt; n+1-i</code> the Mack chain-ladder-model assumes:
</p>
<p style="text-align: center;"><code class="reqn">\mbox{CL1: }  E[ F_{ik}| C_{i1},C_{i2},\ldots,C_{ik} ] = f_k
    \mbox{ with } F_{ik}=\frac{C_{i,k+1}}{C_{ik}}
  </code>
</p>

<p style="text-align: center;"><code class="reqn">\mbox{CL2: }  Var( \frac{C_{i,k+1}}{C_{ik}} | C_{i1},C_{i2},
    \ldots,C_{ik} ) = \frac{\sigma_k^2}{w_{ik} C^\alpha_{ik}}
  </code>
</p>

<p style="text-align: center;"><code class="reqn">\mbox{CL3: }  \{ C_{i1},\ldots,C_{in}\}, \{
    C_{j1},\ldots,C_{jn}\},\mbox{ are independent for origin period } i
    \neq j 
  </code>
</p>

<p>with <code class="reqn">w_{ik} \in [0;1]</code>, <code class="reqn">\alpha \in \{0,1,2\}</code>.   
If these assumptions hold, the Mack chain-ladder gives an
unbiased estimator for IBNR (Incurred But Not Reported) claims.
</p>
<p>Here <code class="reqn">w_{ik} are the \code{weights} from above.</code>
</p>
<p>The Mack chain-ladder model can be regarded as a special form of a 
weighted linear regression
through the origin for each development period:
<code>lm(y ~ x  + 0, weights=weights/x^(2-alpha))</code>, 
where <code>y</code> is the vector of claims at development period
<code class="reqn">k+1</code> and <code>x</code> is  the vector of claims at development period
<code class="reqn">k</code>. 
</p>
<p>It is necessary, before actually applying the model, to check if the main assumptions behind the model (i.e. Calendar Year Effect and Correlation between subsequent Accident Years, see <code><a href="#topic+dfCorTest">dfCorTest</a></code>, <code><a href="#topic+cyEffTest">cyEffTest</a></code>) are verified.
</p>


<h3>Value</h3>

<p>MackChainLadder returns a list with the following elements
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>matched call</p>
</td></tr> 
<tr><td><code>Triangle</code></td>
<td>
<p>input triangle of cumulative claims</p>
</td></tr>
<tr><td><code>FullTriangle</code></td>
<td>
<p>forecasted full triangle</p>
</td></tr>
<tr><td><code>Models</code></td>
<td>
<p>linear regression models for each development period</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>chain-ladder age-to-age factors</p>
</td></tr>
<tr><td><code>f.se</code></td>
<td>
<p>standard errors of the chain-ladder age-to-age factors f
(assumption CL1)</p>
</td></tr>
<tr><td><code>F.se</code></td>
<td>
<p>standard errors of the true chain-ladder age-to-age factors
<code class="reqn">F_{ik}</code> (square root of the variance in assumption CL2)</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>sigma parameter in CL2</p>
</td></tr>
<tr><td><code>Mack.ProcessRisk</code></td>
<td>
<p>variability in the projection of future losses
not explained by the variability of the link ratio estimators (unexplained variation)</p>
</td></tr>
<tr><td><code>Mack.ParameterRisk</code></td>
<td>
<p>variability in the projection of future
losses explained by the variability of the link-ratio estimators
alone (explained variation)</p>
</td></tr>
<tr><td><code>Mack.S.E</code></td>
<td>
<p>total variability in the projection of future losses
by the chain-ladder method; the square root of the mean square error
of the chain-ladder estimate: <code class="reqn">\mbox{Mack.S.E.}^2 = \mbox{Mack.ProcessRisk}^2 +
    \mbox{Mack.ParameterRisk}^2</code></p>
</td></tr>
<tr><td><code>Total.Mack.S.E</code></td>
<td>
<p>total variability of projected loss for all
origin years combined</p>
</td></tr>
<tr><td><code>Total.ProcessRisk</code></td>
<td>
<p>vector of process risk estimate of the total 
of projected loss for all origin years combined by development period</p>
</td></tr>
<tr><td><code>Total.ParameterRisk</code></td>
<td>
<p>vector of parameter risk estimate of the total 
of projected loss for all origin years combined by development period</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>weights used</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>alphas used</p>
</td></tr>
<tr><td><code>tail</code></td>
<td>
<p>tail factor used. If tail was set to TRUE the output will
include the linear model used to estimate the tail factor</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Additional references for further reading:
</p>
<p><cite>England, PD and Verrall, RJ. Stochastic Claims Reserving in
General Insurance (with discussion), <em>British Actuarial Journal</em>
8, III. 2002</cite>
</p>
<p><cite>Barnett and Zehnwirth. Best estimates for reserves. Proceedings
of the CAS, LXXXVI I(167), November 2000.</cite>  
</p>



<h3>Author(s)</h3>

<p>Markus Gesmann <a href="mailto:markus.gesmann@gmail.com">markus.gesmann@gmail.com</a></p>


<h3>References</h3>

<p><cite>Thomas Mack. Distribution-free calculation of the standard error of chain ladder reserve estimates. <em>Astin Bulletin</em>. Vol. 23. No 2. 1993. pp.213:225</cite>
</p>
<p><cite>Thomas Mack. The standard error of chain ladder reserve estimates: Recursive calculation and inclusion of a tail factor. <em>Astin Bulletin</em>. Vol. 29. No 2. 1999. pp.361:366</cite>
</p>
<p><cite>Murphy, Daniel M. Unbiased Loss Development
Factors. <em>Proceedings of the Casualty Actuarial Society Casualty
Actuarial Society</em> - Arlington, Virginia 1994: LXXXI 154-222</cite>
</p>
<p><cite>Buchwalder, Bühlmann, Merz, and Wüthrich.
The Mean Square Error of Prediction in the Chain Ladder Reserving Method
(Mack and Murphy Revisited).
<em>Astin Bulletin</em> Vol. 36. 2006. pp.521:542
</cite>
</p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+qpaid">qpaid</a></code> for dealing with non-square triangles,  
<code><a href="#topic+chainladder">chainladder</a></code> for the underlying chain-ladder method,  
<code><a href="#topic+dfCorTest">dfCorTest</a></code> to check for Calendar Year Effect,
<code><a href="#topic+cyEffTest">cyEffTest</a></code> to check for Development Factor Correlation,
<code><a href="#topic+summary.MackChainLadder">summary.MackChainLadder</a></code>,  
<code><a href="#topic+quantile.MackChainLadder">quantile.MackChainLadder</a></code>,  
<code><a href="#topic+plot.MackChainLadder">plot.MackChainLadder</a></code> and 
<code><a href="#topic+residuals.MackChainLadder">residuals.MackChainLadder</a></code> displaying results, 
<code><a href="#topic+CDR.MackChainLadder">CDR.MackChainLadder</a></code> for the one year claims development result.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See the Taylor/Ashe example in Mack's 1993 paper
GenIns
plot(GenIns)
plot(GenIns, lattice=TRUE)
GNI &lt;- MackChainLadder(GenIns, est.sigma="Mack")
GNI$f
GNI$sigma^2
GNI # compare to table 2 and 3 in Mack's 1993 paper
plot(GNI)
plot(GNI, lattice=TRUE)

## Different weights
## Using alpha=0 will use straight average age-to-age factors 
MackChainLadder(GenIns, alpha=0)$f
# You get the same result via:
apply(GenIns[,-1]/GenIns[,-10],2, mean, na.rm=TRUE)

## Only use the last 5 diagonals, i.e. the last 5 calendar years
calPeriods &lt;- (row(GenIns) + col(GenIns) - 1)
(weights &lt;- ifelse(calPeriods &lt;= 5, 0, ifelse(calPeriods &gt; 10, NA, 1)))
MackChainLadder(GenIns, weights=weights, est.sigma = "Mack")

## Tail
## See the example in Mack's 1999 paper
Mortgage
m &lt;- MackChainLadder(Mortgage)
round(summary(m)$Totals["CV(IBNR)",], 2) ## 26% in Table 6 of paper
plot(Mortgage)
# Specifying the tail and its associated uncertainty parameters
MRT &lt;- MackChainLadder(Mortgage, tail=1.05, tail.sigma=71, tail.se=0.02, est.sigma="Mack")
MRT
plot(MRT, lattice=TRUE)
# Specify just the tail and the uncertainty parameters will be estimated
MRT &lt;- MackChainLadder(Mortgage, tail=1.05)
MRT$f.se[9] # close to the 0.02 specified above
MRT$sigma[9] # less than the 71 specified above
# Note that the overall CV dropped slightly
round(summary(MRT)$Totals["CV(IBNR)",], 2) ## 24%
# tail parameter uncertainty equal to expected value 
MRT &lt;- MackChainLadder(Mortgage, tail=1.05, tail.se = .05)
round(summary(MRT)$Totals["CV(IBNR)",], 2) ## 27%

## Parameter-risk (only) estimate of the total reserve = 3142387
tail(MRT$Total.ParameterRisk, 1) # located in last (ultimate) element
#  Parameter-risk (only) CV is about 19%
tail(MRT$Total.ParameterRisk, 1) / summary(MRT)$Totals["IBNR", ]

## Three terms in the parameter risk estimate
## First, the default (Mack) without the tail
m &lt;- MackChainLadder(RAA, mse.method = "Mack")
summary(m)$Totals["Mack S.E.",]
## Then, with the third term
m &lt;- MackChainLadder(RAA, mse.method = "Independence")
summary(m)$Totals["Mack S.E.",] ## Not significantly greater

## One year claims development results
M &lt;- MackChainLadder(MW2014, est.sigma="Mack")
CDR(M)

## For more examples see:
## Not run: 
 demo(MackChainLadder)

## End(Not run)

</code></pre>

<hr>
<h2 id='MCLpaid'>Run off triangles of accumulated paid and incurred claims data.</h2><span id='topic+MCLpaid'></span><span id='topic+MCLincurred'></span>

<h3>Description</h3>

<p>Run-off triangles based on a fire portfolio</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(MCLpaid)
data(MCLincurred)</code></pre>


<h3>Format</h3>

<p>A matrix with 7 origin years and 7 development years.
</p>


<h3>Source</h3>

<p><cite>
Gerhard Quarg and Thomas Mack. Munich Chain Ladder. <em>Blatter DGVFM</em>. 26,
Munich, 2004.
</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>MCLpaid
MCLincurred
op=par(mfrow=c(2,1))
plot(MCLpaid)
plot(MCLincurred)
par(op)
</code></pre>

<hr>
<h2 id='MedMal'>Run off triangles of accumulated claim data</h2><span id='topic+MedMal'></span>

<h3>Description</h3>

<p>Run-off triangles of Medical Malpractice Data insurance.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(MedMal)</code></pre>


<h3>Format</h3>

<p>U.S. medical malpractice insurance for an experience period of 1969 to 1976. Reported Claims, Paid Claims, Case Outstanding    and Open Claims (i.e. the number of outstanding claims) respectively
</p>


<h3>Source</h3>

<p><cite>Berquist, J.R. and Sherman, R.E., Loss Reserve Adequacy Testing: A Comprehensive,
Systematic Approach, <em>Proceedings of the Casualty Actuarial Society</em>, LXIV, 1977, pp.123-184.</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(MedMal)
names(MedMal)
MedMal$MedMalReported
MedMal$MedMalPaid
MedMal$MedMalOutstanding
MedMal$MedMalOpen
</code></pre>

<hr>
<h2 id='Mortgage'>Run off triangle of accumulated claims data</h2><span id='topic+Mortgage'></span>

<h3>Description</h3>

<p>Development triangle of a mortgage guarantee
business</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Mortgage)</code></pre>


<h3>Format</h3>

<p>A matrix with 9 accident years and 9 development years.
</p>


<h3>Source</h3>

<p><cite>Competition Presented at a London Market Actuaries Dinner,
D.E.A. Sanders, 1990</cite>
</p>


<h3>References</h3>

<p>See table 4 in: 
<cite>Distribution-free Calculation of the
Standard Error of Chain Ladder Reserve Estimates, Thomas Mack, 1993,
<em>ASTIN Bulletin</em> <b>23</b>, 213 - 225</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Mortgage
Mortgage
plot(Mortgage)
plot(Mortgage, lattice=TRUE)
</code></pre>

<hr>
<h2 id='Mse-methods'> Methods for Generic Function Mse </h2><span id='topic+Mse'></span><span id='topic+Mse-methods'></span><span id='topic+Mse+2CGMCLFit+2Ctriangles-method'></span><span id='topic+Mse+2CMCLFit+2Ctriangles-method'></span>

<h3>Description</h3>

<p><code>Mse</code> is a generic function to calculate mean square error estimations in the chain-ladder framework. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mse(ModelFit, FullTriangles, ...)

## S4 method for signature 'GMCLFit,triangles'
Mse(ModelFit, FullTriangles, ...)
## S4 method for signature 'MCLFit,triangles'
Mse(ModelFit, FullTriangles, mse.method="Mack", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mse-methods_+3A_modelfit">ModelFit</code></td>
<td>
<p>An object of class &quot;GMCLFit&quot; or &quot;MCLFit&quot;. </p>
</td></tr>
<tr><td><code id="Mse-methods_+3A_fulltriangles">FullTriangles</code></td>
<td>
<p>An object of class &quot;triangles&quot;. Should be the output from a call of <code>predict</code>. </p>
</td></tr>
<tr><td><code id="Mse-methods_+3A_mse.method">mse.method</code></td>
<td>
<p>Character strings that specify the MSE estimation method. Only works for &quot;MCLFit&quot;. Use <code>"Mack"</code> for the generazliation of the Mack (1993) approach, and <code>"Independence"</code> for the conditional resampling approach in Merz and Wuthrich (2008).   </p>
</td></tr>
<tr><td><code id="Mse-methods_+3A_...">...</code></td>
<td>
<p> Currently not used. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions calculate the conditional mean square errors using the recursive formulas in Zhang (2010), which is a generalization of the Mack (1993, 1999) formulas. In the GMCL model, the conditional  mean square error for single accident years and aggregated accident years are calcualted as:
</p>
<p style="text-align: center;"><code class="reqn">\hat{mse}(\hat{Y}_{i,k+1}|D)=\hat{B}_k \hat{mse}(\hat{Y}_{i,k}|D) \hat{B}_k + (\hat{Y}_{i,k}' \otimes I) \hat{\Sigma}_{B_k} (\hat{Y}_{i,k} \otimes I) +  \hat{\Sigma}_{\epsilon_{i_k}}.</code>
</p>

<p style="text-align: center;"><code class="reqn">\hat{mse}(\sum^I_{i=a_k}\hat{Y}_{i,k+1}|D)=\hat{B}_k \hat{mse}(\sum^I_{i=a_k+1}\hat{Y}_{i,k}|D) \hat{B}_k + (\sum^I_{i=a_k}\hat{Y}_{i,k}' \otimes I) \hat{\Sigma}_{B_k} (\sum^I_{i=a_k}\hat{Y}_{i,k} \otimes I) +  \sum^I_{i=a_k}\hat{\Sigma}_{\epsilon_{i_k}} .</code>
</p>

<p>In the MCL model, the conditional mean square error from Merz and Wüthrich (2008) is also available, which can be shown to be equivalent as the following:
</p>
<p style="text-align: center;"><code class="reqn">\hat{mse}(\hat{Y}_{i,k+1}|D)=(\hat{\beta}_k \hat{\beta}_k') \odot \hat{mse}(\hat{Y}_{i,k}|D)  + \hat{\Sigma}_{\beta_k} \odot (\hat{Y}_{i,k} \hat{Y}_{i,k}') +  \hat{\Sigma}_{\epsilon_{i_k}} +\hat{\Sigma}_{\beta_k} \odot \hat{mse}^E(\hat{Y}_{i,k}|D) .</code>
</p>

<p style="text-align: center;"><code class="reqn">\hat{mse}(\sum^I_{i=a_k}\hat{Y}_{i,k+1}|D)=(\hat{\beta}_k \hat{\beta}_k') \odot \sum^I_{i=a_k+1}\hat{mse}(\hat{Y}_{i,k}|D)  + \hat{\Sigma}_{\beta_k} \odot (\sum^I_{i=a_k}\hat{Y}_{i,k} \sum^I_{i=a_k}\hat{Y}_{i,k}') +  \sum^I_{i=a_k}\hat{\Sigma}_{\epsilon_{i_k}} 
 +\hat{\Sigma}_{\beta_k} \odot \sum^I_{i=a_k}\hat{mse}^E(\hat{Y}_{i,k}|D) .</code>
</p>

<p>For the Mack approach in the MCL model, the cross-product term <code class="reqn">\hat{\Sigma}_{\beta_k} \odot \hat{mse}^E(\hat{Y}_{i,k}|D) </code>in the above two formulas will drop out.
</p>


<h3>Value</h3>

<p><code>Mse</code>  returns an object of class &quot;MultiChainLadderMse&quot; that has  the following elements:
</p>
<table>
<tr><td><code>mse.ay</code></td>
<td>
<p>condtional mse for each accdient year</p>
</td></tr>
<tr><td><code>mse.ay.est</code></td>
<td>
<p>conditional estimation mse for each accdient year</p>
</td></tr>
<tr><td><code>mse.ay.proc</code></td>
<td>
<p>conditional process mse for each accdient year</p>
</td></tr>
<tr><td><code>mse.total</code></td>
<td>
<p>condtional mse for aggregated accdient years</p>
</td></tr>
<tr><td><code>mse.total.est</code></td>
<td>
<p>conditional estimation mse for aggregated accdient years</p>
</td></tr>
<tr><td><code>mse.total.proc</code></td>
<td>
<p>conditional process mse for aggregated accdient years</p>
</td></tr>
<tr><td><code>FullTriangles</code></td>
<td>
<p>completed triangles</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Wayne Zhang <a href="mailto:actuary_zhang@hotmail.com">actuary_zhang@hotmail.com</a></p>


<h3>References</h3>

<p><cite>Zhang Y (2010). A general multivariate chain ladder model.<em>Insurance: Mathematics and Economics</em>, 46, pp. 588-599.</cite>
</p>
<p><cite>Zhang Y (2010). Prediction error of the general multivariate chain ladder model.</cite>
</p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+MultiChainLadder">MultiChainLadder</a>.</code>
</p>

<hr>
<h2 id='MultiChainLadder'> Multivariate Chain-Ladder Models </h2><span id='topic+MultiChainLadder'></span><span id='topic+MultiChainLadder2'></span>

<h3>Description</h3>

<p>The function <code>MultiChainLadder</code> implements multivariate methods to  forecast insurance loss payments based on several cumulative claims development triangles. These methods are multivariate extensions of the chain-ladder technique, which develop several correlated triangles simultaneously in a way that both contemporaneous correlations and structural relationships can be accounted for. The estimated conditional Mean Square Errors (MSE) are also produced. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MultiChainLadder(Triangles, fit.method = "SUR", delta = 1,
  int = NULL, restrict.regMat = NULL, extrap = TRUE, 
  mse.method = "Mack", model = "MCL", ...)
    
MultiChainLadder2(Triangles, mse.method = "Mack", last = 3, 
  type = c("MCL", "MCL+int", "GMCL-int", "GMCL"), ...)    
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MultiChainLadder_+3A_triangles">Triangles</code></td>
<td>
<p>a list of cumulative claims triangles of the same dimensions. </p>
</td></tr>
<tr><td><code id="MultiChainLadder_+3A_fit.method">fit.method</code></td>
<td>
<p>the method used to fit the multivariate regression in each development period. The default is <code>"SUR"</code> - seemingly unrelated regressions. When <code>"OLS"</code> (Ordinary Least Squares) is used, this is the same as developing each triangle separately. </p>
</td></tr> 
<tr><td><code id="MultiChainLadder_+3A_delta">delta</code></td>
<td>
<p>parameter for controlling weights. It is used to determine the covariance structure <code class="reqn">D(Y_{i,k}^{\delta/2})\Sigma_k D(Y_{i,k}^{\delta/2})</code>. The default value <code>1</code> means that the variance is proportional to the cumulative loss from the previous period. </p>
</td></tr>   
<tr><td><code id="MultiChainLadder_+3A_int">int</code></td>
<td>
<p>a numeric vector that indicates which development periods have intercepts specified. This only takes effect for <code>model = "GMCL"</code>. The default <code>NULL</code> means that no intercepts are specified.</p>
</td></tr>   
<tr><td><code id="MultiChainLadder_+3A_restrict.regmat">restrict.regMat</code></td>
<td>
<p>a list of matrix specifying parameter restriction matrix for each period. This is only used for <code>model = "GMCL"</code>. The default value <code>NULL</code> means no restriction is imposed on the development matrix. For example, if there are 3 triangles, there will be 9 parameters in the development matrix for each period if <code>restrict.regMat = NULL</code>. See <code>systemfit</code> for how to specify the appropriate parameter constraints.</p>
</td></tr> 
<tr><td><code id="MultiChainLadder_+3A_extrap">extrap</code></td>
<td>
<p>a logical value indicating whether to use Mack's extrapolation method for the last period to get the residual variance  estimation. It only takes effect for  <code>model = "MCL"</code>. If the data are  trapezoids, it is set to be <code>FALSE</code> automatically and a warning message is given.</p>
</td></tr>
<tr><td><code id="MultiChainLadder_+3A_mse.method">mse.method</code></td>
<td>
<p>method to estimate the mean square error. It can be either <code>"Mack"</code> or <code>"Independence"</code>, which are  the multivariate generalization of Mack's formulas and the conditional re-sampling approach, respectively.</p>
</td></tr>
<tr><td><code id="MultiChainLadder_+3A_model">model</code></td>
<td>
<p>the structure of the model to be fitted. It is either <code>"MCL"</code> or <code>"GMCL"</code>. See details below. </p>
</td></tr>
<tr><td><code id="MultiChainLadder_+3A_last">last</code></td>
<td>
<p>an integer. The <code>MultiChainLadder2</code> function splits the triangles into 2 parts internally (see details below), and the <code>last</code> argument indicates how many of the development periods in the tail go into the second part of the split. The default is <code>3</code>.</p>
</td></tr>
<tr><td><code id="MultiChainLadder_+3A_type">type</code></td>
<td>
<p>the type of the model structure to be specified for the first part of the split model in <code>MultiChainLadder2</code>. <code>"MCL"</code>- the multivariate chain-ladder with diagonal development matrix; <code>"MCL+int"</code>- the multivariate chain-ladder with additional intercepts; <code>"GMCL-int"</code>- the general multivariate chain-ladder without intercepts; and <code>"GMCL"</code> - the full general multivariate chain-ladder with intercepts and non-diagonal development matrix. </p>
</td></tr>
<tr><td><code id="MultiChainLadder_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>systemfit</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements multivariate loss reserving models within the chain-ladder framework.  Two major models are included. One is the Multivariate chain-ladder (MCL) model proposed by Prohl and Schmidt (2005). This is a direct multivariate generalization of the univariate chain-ladder model in that losses from different triangles are assumed to be correlated but the mean development in one triangle only depends on its past values, not on the observed values from other triangles. In contrast, the other model, the General Multivariate chain-ladder (GMCL) model outlined in Zhang (2010), extends the MCL model by allowing development dependencies among different triangles as well as the inclusion of regression intercepts. As a result, structurally related triangles, such as the  paid and incurred loss triangles or the paid loss and case reserve triangles, can be developed together while still accounting for the potential contemporaneous correlations. While the MCL model is a special case of the GMCL model, it is programmed and listed separately because: a) it is an important model for its own sake; b) different MSE methods are only available for the MCL model; c) extrapolation of the residual variance estimation can be implemented for the MCL model, which is considerably difficult for the GMCL model. 
</p>
<p>We introduce some details of the GMCL model in the following. Assume N triangles are available. Denote <code class="reqn">Y_{i,k}=(Y^{(1)}_{i,k}, \ldots ,Y^{(N)}_{i,k})</code> as an <code class="reqn">N \times 1</code> vector of  cumulative losses at accident year i and development year k, where (n) refers to the n-th triangle. The GMCL model in development period k (from development year k to year k+1) is:
</p>
<p style="text-align: center;"><code class="reqn">Y_{i,k+1}=A_k + B_k \cdot Y_{i,k}+\epsilon_{i,k},</code>
</p>

<p>where <code class="reqn">A_k</code> is a column of intercepts and <code class="reqn">B_k</code> is the  <code class="reqn">N \times N</code> development matrix. By default, <code>MultiChainLadder</code> sets <code class="reqn">A_k</code> to be zero. This behavior can be changed by appropriately specifying the <code>int</code> argument.
Assumptions for this model are:
</p>
<p style="text-align: center;"><code class="reqn">E(\epsilon_{i,k}|Y_{i,1},\ldots,Y_{i,I+1-k})=0.</code>
</p>

<p style="text-align: center;"><code class="reqn">cov(\epsilon_{i,k}|Y_{i,1},\ldots,Y_{i,I+1-k})=\Sigma_{\epsilon_{i,k}}=D(Y_{i,k}^{\delta/2})\Sigma_k D(Y_{i,k}^{\delta/2}).</code>
</p>

<p style="text-align: center;"><code class="reqn">\mbox{losses of different accident years are independent}.</code>
</p>

<p style="text-align: center;"><code class="reqn">\epsilon_{i,k} \, \mbox{are symmetrically distributed}.</code>
</p>

<p>The GMCL model structure is generally over-parameterized. Parameter restrictions are usually necessary for the estimation to be feasible, which can be specified through the <code>restrict.regMat</code> argument. We refer the users to the documentation for <code><a href="systemfit.html#topic+systemfit">systemfit</a></code> for details and the demo of the present function for examples. 
</p>
<p>In particular, if one restricts the development matrix to be diagonal, the GMCL model will reduce to the MCL model. When non-diagonal development matrix is used and the GMCL model is applied to paid and incurred loss triangles, it can reflect the development relationship between the two triangles, as described in Quarg and Mack (2004). The full bivariate model is identical to the &quot;double regression&quot; model described by Mack (2003), which is argued by him to be very similar to the Munich chain-ladder (MuCL) model. The GMCL model with intercepts can also help improve model adequacy as described in Barnett and Zehnwirth (2000). 
</p>
<p>Currently, the GMCL model only works for trapezoid data, and only implements <code>mse.method = "Mack"</code>. The MCL model allows an additional mse estimation method that assumes independence among the estimated parameters. Further, the MCL model using <code>fit.method = "OLS"</code> will be equivalent to running univariate chain-ladders separately on each triangle. Indeed, when only one triangle is specified (as a list),  the MCL model is equivalent to <code>MackChainLadder</code>. 
</p>
<p>The GMCL model allows different model structures to be specified in each development period. This is generally achieved through the combination of the <code>int</code> argument, which specifies the periods that have intercepts, and the <code>restrict.regMat</code> argument, which imposes parameter restrictions on the development matrix. 
</p>
<p>In using the multivariate methods, we often specify separate univariate chain-ladders for the tail periods to stabilize the estimation - there are few data points in the tail and running a multivariate model often produces extremely volatile estimates or even fails. In this case, we can use the subset operator <code>"["</code> defined for class <code>triangles</code> to split the input data into two parts. We can specify a multivariate model with rich structures on the first part to reflect the multivariate dependencies, and simply apply multiple univariate chain-ladders on the second part. The two models are subsequently joined together using the <code>Join2Fits</code> function. We can then invoke the <code>predict</code> and <code>Mse</code> methods to produce loss predictions and mean square error estimations. They can further be combined via the <code>JoinFitMse</code> function  to construct an object of class <code>MultiChainLadder</code>. See the demo for such examples. 
</p>
<p>To facilitate such a split-and-join process for most applications, we have created the function <code>MultiChainLadder2</code>. This function splits the data according to the <code>last</code> argument (e.g., if <code>last = 3</code>, the last three periods go into the second part), and fits the first part according to the structure indicated in the <code>type</code> argument. See the 'Arguments' section for details. 
</p>


<h3>Value</h3>

<p><code>MultiChainLadder</code> returns an object of class <code>MultiChainLadder</code>  with the following slots:
</p>
<table>
<tr><td><code>model</code></td>
<td>
<p>the model structure used, either <code>"MCL"</code> or <code>"GMCL"</code></p>
</td></tr>
<tr><td><code>Triangles</code></td>
<td>
<p>input triangles of cumulative claims that are converted to class <code>triangles</code> internally. </p>
</td></tr>
<tr><td><code>models</code></td>
<td>
<p>fitted models for each development period. This is the output from the call of <code>systemfit</code>.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>estimated regression coefficients or development parameters. They are put into the matrix format for the GMCL model.</p>
</td></tr>
<tr><td><code>coefCov</code></td>
<td>
<p>estimated variance-covariance matrix for the regression coefficients.</p>
</td></tr>
<tr><td><code>residCov</code></td>
<td>
<p>estimated residual covariance matrix.</p>
</td></tr>
<tr><td><code>fit.method</code></td>
<td>
<p>multivariate regression estimation method</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>the value of delta</p>
</td></tr>
<tr><td><code>mse.ay</code></td>
<td>
<p>mean square error matrix for each accident year</p>
</td></tr>
<tr><td><code>mse.ay.est</code></td>
<td>
<p>estimation error matrix for each accident year</p>
</td></tr>
<tr><td><code>mse.ay.proc</code></td>
<td>
<p>process error matrix for each accident year</p>
</td></tr>
<tr><td><code>mse.total</code></td>
<td>
<p>mean square error matrix for all accident years combined</p>
</td></tr>
<tr><td><code>mse.total.est</code></td>
<td>
<p>estimation error matrix for all accident years combined</p>
</td></tr>
<tr><td><code>mse.total.proc</code></td>
<td>
<p>process error matrix for all accident years combined</p>
</td></tr>
<tr><td><code>FullTriangles</code></td>
<td>
<p>the forecasted full triangles of class <code>triangles</code></p>
</td></tr>
<tr><td><code>int</code></td>
<td>
<p>intercept indicators</p>
</td></tr>
</table>


<h3>Note</h3>

<p>When <code>MultiChainLadder</code> or <code>MultiChainLadder2</code> fails, the most possible reason is that there is little or no development in the tail periods. That is, the development factor is <code>1</code> or almost equal to <code>1</code>. In this case, the <code>systemfit</code> function may fail even for <code>fit.method = "OLS"</code>, because the residual covariance matrix <code class="reqn">\Sigma_k</code> is singular. The simplest solution is to remove these columns using the <code>"["</code> operator and fit the model on the remaining part. 
</p>
<p>Also, we recommend the use of <code>MultiChainLadder2</code> over <code>MultiChainLadder</code>. The function <code>MultiChainLadder2</code> meets the need for most applications, is relatively easy to use and produces more stable but very similar results to <code>MultiChainLadder</code>. Use <code>MultiChainLadder</code> only when non-standard situation arises, e.g., when different parameter restrictions are needed for different periods. See the demo for such examples.   
</p>


<h3>Author(s)</h3>

<p> Wayne Zhang <a href="mailto:actuary_zhang@hotmail.com">actuary_zhang@hotmail.com</a></p>


<h3>References</h3>

 
<p><cite>Buchwalder M, Bühlmann H, Merz M, Wüthrich M.V (2006). The mean square error of prediction in the chain-ladder reserving method (Mack and Murphy revisited), <em>ASTIN Bulletin</em>, 36(2), 521-542.</cite>
</p>
<p><cite>Prohl C, Schmidt K.D (2005). Multivariate chain-ladder, <em>Dresdner Schriften zur Versicherungsmathematik</em>.</cite>
</p>
<p><cite> Mack T (1993). Distribution-free calculation of the standard error, <em>ASTIN Bulletin</em>, 23, No.2. </cite>
</p>
<p><cite> Mack T (1999). The standard error of chain-ladder reserve estimates: recursive calculation and inclusion of a tail factor, <em>ASTIN Bulletin</em>, 29, No.2, 361-366.</cite>
</p>
<p><cite> Merz M, Wüthrich M (2008). Prediction error of the multivariate chain ladder reserving method, <em>North American Actuarial Journal</em>, 12, No.2, 175-197.</cite>
</p>
<p><cite>Zhang Y (2010). A general multivariate chain-ladder model.<em>Insurance: Mathematics and Economics</em>, 46, pp. 588-599.</cite>
</p>
<p><cite>Zhang Y (2010). Prediction error of the general multivariate chain ladder model.</cite>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+MackChainLadder">MackChainLadder</a></code>, <code><a href="#topic+MunichChainLadder">MunichChainLadder</a></code>, <code><a href="#topic+triangles-class">triangles</a></code>, <code><a href="#topic+MultiChainLadder-class">MultiChainLadder</a></code>, <code><a href="#topic+summary+2CMultiChainLadder-method">summary,MultiChainLadder-method</a></code> and  <code><a href="#topic+plot+2CMultiChainLadder+2Cmissing-method">plot,MultiChainLadder,missing-method</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This shows that the MCL model using "OLS" is equivalent to 
# the MackChainLadder when applied to one triangle 

data(GenIns)
(U1 &lt;- MackChainLadder(GenIns, est.sigma = "Mack"))
(U2 &lt;- MultiChainLadder(list(GenIns), fit.method = "OLS"))

# show plots 
parold &lt;- par(mfrow = c(2, 2))
plot(U2, which.plot = 1:4)
plot(U2, which.plot = 5)
par(parold)


# For mse.method = "Independence", the model is equivalent 
# to that in Buchwalder et al. (2006)

(B1 &lt;- MultiChainLadder(list(GenIns), fit.method = "OLS", 
    mse.method = "Independence"))

# use the unbiased residual covariance estimator 
# in Merz and Wuthrich (2008)
(W1 &lt;- MultiChainLadder2(liab, mse.method = "Independence", 
    		control = systemfit::systemfit.control(methodResidCov = "Theil"))) 

## Not run: 
# use the iterative residual covariance estimator
for (i in 1:5){
  W2 &lt;- MultiChainLadder2(liab, mse.method = "Independence", 
      control = systemfit::systemfit.control(
      methodResidCov = "Theil", maxiter = i))
  print(format(summary(W2)@report.summary[[3]][15, 4:5], 
          digits = 6, big.mark = ","))    
}

# The following fits an MCL model with intercepts for years 1:7
# and separate chain-ladder models for the rest periods
f1 &lt;- MultiChainLadder2(auto, type = "MCL+int")

# compare with the model without intercepts through residual plots
f0 &lt;- MultiChainLadder2(auto, type = "MCL")

parold &lt;- par(mfrow = c(2, 3), mar = c(3, 3, 2, 1))
mt &lt;- list(c("Personal Paid", "Personal Incured", "Commercial Paid"))
plot(f0, which.plot = 3, main = mt)
plot(f1, which.plot = 3, main = mt)
par(parold)

## summary statistics
summary(f1, portfolio = "1+3")@report.summary[[4]]


# model for joint development of paid and incurred triangles 
da &lt;- auto[1:2]
# MCL with diagonal development
M0 &lt;- MultiChainLadder(da)
# non-diagonal development matrix with no intercepts
M1 &lt;- MultiChainLadder2(da, type = "GMCL-int")
# Munich chain-ladder
M2 &lt;- MunichChainLadder(da[[1]], da[[2]])
# compile results and compare projected paid to incurred ratios
r1 &lt;- lapply(list(M0, M1), function(x){
          ult &lt;- summary(x)@Ultimate
          ult[, 1] / ult[, 2]
      })
names(r1) &lt;- c("MCL", "GMCL")
r2 &lt;- summary(M2)[[1]][, 6]
r2 &lt;- c(r2, summary(M2)[[2]][2, 3])
print(do.call(cbind, c(r1, list(MuCl = r2))) * 100, digits = 4)


## End(Not run)

# To reproduce results in Zhang (2010) and see more examples, use:
## Not run: 
 demo(MultiChainLadder)

## End(Not run)

</code></pre>

<hr>
<h2 id='MultiChainLadder-class'>Class &quot;MultiChainLadder&quot; of Multivariate Chain-Ladder Results </h2><span id='topic+MultiChainLadder-class'></span><span id='topic++24+2CMultiChainLadder-method'></span><span id='topic++5B+5B+2CMultiChainLadder+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+5B+2CMultiChainLadder+2Ccharacter+2Cmissing-method'></span><span id='topic+coef+2CMultiChainLadder-method'></span><span id='topic+fitted+2CMultiChainLadder-method'></span><span id='topic+names+2CMultiChainLadder-method'></span><span id='topic+residuals+2CMultiChainLadder-method'></span><span id='topic+resid+2CMultiChainLadder-method'></span><span id='topic+rstandard+2CMultiChainLadder-method'></span><span id='topic+show+2CMultiChainLadder-method'></span><span id='topic+vcov+2CMultiChainLadder-method'></span>

<h3>Description</h3>

<p> This class includes the first and second moment estimation result using the multivariate reserving methods in chain-ladder. Several primitive methods and statistical methods are also created to facilitate further analysis. </p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("MultiChainLadder", ...)</code>, or they could also be a result of calls from <code>MultiChainLadder</code> or <code>JoinFitMse</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"character"</code>. Either &quot;MCL&quot; or &quot;GMCL&quot;.  </p>
</dd>
<dt><code>Triangles</code>:</dt><dd><p>Object of class <code>"triangles"</code>. Input triangles. </p>
</dd>
<dt><code>models</code>:</dt><dd><p>Object of class <code>"list"</code>. Fitted regression models using <code>systemfit</code>.  </p>
</dd>
<dt><code>coefficients</code>:</dt><dd><p>Object of class <code>"list"</code>. Estimated regression coefficients.  </p>
</dd>
<dt><code>coefCov</code>:</dt><dd><p>Object of class <code>"list"</code>. Estimated variance-covariance matrix of coefficients. </p>
</dd>
<dt><code>residCov</code>:</dt><dd><p>Object of class <code>"list"</code>. Estimated residual covariance matrix.  </p>
</dd>
<dt><code>fit.method</code>:</dt><dd><p>Object of class <code>"character"</code>. Could be values of &quot;SUR&quot; or &quot;OLS&quot;.  </p>
</dd>
<dt><code>delta</code>:</dt><dd><p>Object of class <code>"numeric"</code>. Parameter for weights.  </p>
</dd>
<dt><code>int</code>:</dt><dd><p>Object of class <code>"NullNum"</code>. Indicator of which periods have intercepts.  </p>
</dd>
<dt><code>mse.ay</code>:</dt><dd><p>Object of class <code>"matrix"</code>. Conditional mse for each accident year. </p>
</dd>
<dt><code>mse.ay.est</code>:</dt><dd><p>Object of class <code>"matrix"</code>. Conditional estimation mse for each accident year.  </p>
</dd>
<dt><code>mse.ay.proc</code>:</dt><dd><p>Object of class <code>"matrix"</code>. Conditional process mse for each accident year.  </p>
</dd>
<dt><code>mse.total</code>:</dt><dd><p>Object of class <code>"matrix"</code>. Conditional mse for aggregated accident years.  </p>
</dd>
<dt><code>mse.total.est</code>:</dt><dd><p>Object of class <code>"matrix"</code>. Conditional estimation mse for aggregated accident years.  </p>
</dd>
<dt><code>mse.total.proc</code>:</dt><dd><p>Object of class <code>"matrix"</code>. Conditional process mse for aggregated accident years.  </p>
</dd>
<dt><code>FullTriangles</code>:</dt><dd><p>Object of class <code>"triangles"</code>. Completed triangles.  </p>
</dd>
<dt><code>restrict.regMat</code>:</dt><dd><p>Object of class <code>"NullList"</code>  </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+MultiChainLadderFit-class">MultiChainLadderFit</a>"</code>, directly.
Class <code>"<a href="#topic+MultiChainLadderMse-class">MultiChainLadderMse</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>$</dt><dd><p><code>signature(x = "MultiChainLadder")</code>: Method for primitive function <code>"$"</code>. It extracts a slot of <code>x</code> with a specified slot name, just as in list. </p>
</dd>
<dt>[[</dt><dd><p><code>signature(x = "MultiChainLadder", i = "numeric", j = "missing")</code>:  Method for primitive function <code>"[["</code>. It extracts the i-th slot of a <code>"MultiChainLadder"</code> object, just as in list. <code>i</code> could be a vector. </p>
</dd>
<dt>[[</dt><dd><p><code>signature(x = "MultiChainLadder", i = "character", j = "missing")</code>: Method for primitive function <code>"[["</code>. It extracts the slots of a <code>"MultiChainLadder"</code> object with names in <code>i</code>, just as in list. <code>i</code> could be a vector. </p>
</dd>
<dt>coef</dt><dd><p><code>signature(object = "MultiChainLadder")</code>: Method for function <code>coef</code>,  to extract the estimated development matrix. The output is a list.  </p>
</dd>
<dt>fitted</dt><dd><p><code>signature(object = "MultiChainLadder")</code>:  Method for function <code>fitted</code>,  to calculate the fitted values in the original triangles. Note that the return value is a list of fitted valued based on the original scale, not the model scale which is first divided by <code class="reqn">Y_{i,k}^{\delta/2}</code>.  </p>
</dd>
<dt>names</dt><dd><p><code>signature(x = "MultiChainLadder")</code>: Method for function <code>names</code>, which returns the slot names of a <code>"MultiChainLadder"</code> object. </p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "MultiChainLadder", y = "missing")</code>: See <code><a href="#topic+plot+2CMultiChainLadder+2Cmissing-method">plot,MultiChainLadder,missing-method</a></code>.  </p>
</dd>
<dt>residCov</dt><dd><p><code>signature(object = "MultiChainLadder")</code>: S4 generic function and method to extract residual covariance from a <code>"MultiChainLadder"</code> object. </p>
</dd>
<dt>residCor</dt><dd><p><code>signature(object = "MultiChainLadder")</code>: S4 generic function and method to extract residual correlation from a <code>"MultiChainLadder"</code> object. </p>
</dd>
<dt>residuals</dt><dd><p><code>signature(object = "MultiChainLadder")</code>: Method for function <code>residuals</code>, to extract residuals  from a system of regression equations. These residuals are based on model scale, and will not be equivalent to those on the original scale if <code class="reqn">\delta</code> is not set to be 0. One should use <code>rstandard</code> instead, which is independent of the scale.  </p>
</dd>
<dt>resid</dt><dd><p><code>signature(object = "MultiChainLadder")</code>: Same as <code>residuals</code>.  </p>
</dd>
<dt>rstandard</dt><dd><p><code>signature(model = "MultiChainLadder")</code>: S4 generic function and method to extract standardized residuals from a <code>"MultiChainLadder"</code> object.  </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "MultiChainLadder")</code>: Method for <code>show</code>. </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "MultiChainLadder")</code>: See <code><a href="#topic+summary+2CMultiChainLadder-method">summary,MultiChainLadder-method</a></code>. </p>
</dd>
<dt>vcov</dt><dd><p><code>signature(object = "MultiChainLadder")</code>: Method for function <code>vcov</code>, to extract the variance-covariance matrix of a <code>"MultiChainLadder"</code> object. Note that the result is a list of <code>Bcov</code>, that is the variance-covariance matrix of the vectorized <code class="reqn">B</code>. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Wayne Zhang <a href="mailto:actuary_zhang@hotmail.com">actuary_zhang@hotmail.com</a> </p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+MultiChainLadder">MultiChainLadder</a></code>,<code><a href="#topic+summary+2CMultiChainLadder-method">summary,MultiChainLadder-method</a></code> and  <code><a href="#topic+plot+2CMultiChainLadder+2Cmissing-method">plot,MultiChainLadder,missing-method</a></code>.   
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example for class "MultiChainLadder"
data(liab)
fit.liab &lt;-  MultiChainLadder(Triangles = liab)
fit.liab

names(fit.liab)
fit.liab[[1]]
fit.liab$model
fit.liab@model

do.call("rbind",coef(fit.liab))
vcov(fit.liab)[[1]]
residCov(fit.liab)[[1]]
head(do.call("rbind",rstandard(fit.liab)))

</code></pre>

<hr>
<h2 id='MultiChainLadderFit-class'>Class &quot;MultiChainLadderFit&quot;, &quot;MCLFit&quot; and &quot;GMCLFit&quot;  </h2><span id='topic+MultiChainLadderFit-class'></span><span id='topic+MCLFit-class'></span><span id='topic+GMCLFit-class'></span><span id='topic+predict+2CMCLFit-method'></span><span id='topic+predict+2CGMCLFit-method'></span>

<h3>Description</h3>

<p>&quot;MultiChainLadderFit&quot; is a virtual class for the fitted models in the multivariate chain ladder reserving framework, &quot;MCLFit&quot; is a result from the interal call <code>.FitMCL</code> to store results in model <code>MCL</code> and &quot;GMCLFit&quot; is a result from the interal call <code>.FitGMCL</code> to store results in model <code>GMCL</code>. The two classes &quot;MCLFit&quot; and &quot;GMCLFit&quot; differ only in the presentation of <code class="reqn">B_k</code> and <code class="reqn">\Sigma_{B_k}</code>, and different methods of <code>Mse</code> and <code>predict</code> will be dispatched according to these classes.  </p>


<h3>Objects from the Class</h3>

<p>&quot;MultiChainLadderFit&quot; is a virtual Class: No objects may be created from it. For &quot;MCLFit&quot; and &quot;GMCLFit&quot;, objects can be created by calls of the form <code>new("MCLFit", ...)</code> and <code>new("GMCLFit", ...)</code> respectively. </p>


<h3>Slots</h3>


<dl>
<dt><code>Triangles</code>:</dt><dd><p>Object of class <code>"triangles"</code>  </p>
</dd>
<dt><code>models</code>:</dt><dd><p>Object of class <code>"list"</code>  </p>
</dd>
<dt><code>B</code>:</dt><dd><p>Object of class <code>"list"</code>  </p>
</dd>
<dt><code>Bcov</code>:</dt><dd><p>Object of class <code>"list"</code>  </p>
</dd>
<dt><code>ecov</code>:</dt><dd><p>Object of class <code>"list"</code>  </p>
</dd>
<dt><code>fit.method</code>:</dt><dd><p>Object of class <code>"character"</code>  </p>
</dd>
<dt><code>delta</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>int</code>:</dt><dd><p>Object of class <code>"NullNum"</code>  </p>
</dd>
<dt><code>restrict.regMat</code>:</dt><dd><p>Object of class <code>"NullList"</code>  </p>
</dd>
</dl>



<h3>Extends</h3>

<p>&quot;MCLFit&quot; and &quot;GMCLFit&quot; extends class <code>"<a href="#topic+MultiChainLadderFit-class">MultiChainLadderFit</a>"</code>, directly.
</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;MultiChainLadderFit&quot; in the signature.
</p>
<p>For &quot;MCLFit&quot;, the following methods are defined:
</p>

<dl>
<dt><code>Mse</code></dt><dd><p><code>signature(ModelFit = "MCLFit", FullTriangles = "triangles")</code>: Calculate Mse estimations. </p>
</dd>
<dt><code>predict</code></dt><dd><p><code>signature(object = "MCLFit")</code>: Predict ultimate losses and complete the triangles. The output is an object of class &quot;triangles&quot;.</p>
</dd>
</dl>

<p>For &quot;GMCLFit&quot;, the following methods are defined:
</p>

<dl>
<dt><code>Mse</code></dt><dd><p><code>signature(ModelFit = "GMCLFit", FullTriangles = "triangles")</code>: Calculate Mse estimations. </p>
</dd>
<dt><code>predict</code></dt><dd><p><code>signature(object = "GMCLFit")</code>: Predict ultimate losses and complete the triangles. The output is an object of class &quot;triangles&quot;. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Wayne Zhang <a href="mailto:actuary_zhang@hotmail.com">actuary_zhang@hotmail.com</a> </p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+Mse">Mse</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("MultiChainLadderFit")
</code></pre>

<hr>
<h2 id='MultiChainLadderMse-class'>Class &quot;MultiChainLadderMse&quot; </h2><span id='topic+MultiChainLadderMse-class'></span>

<h3>Description</h3>

<p> This class is used to define the structure in storing the MSE results.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("MultiChainLadderMse", ...)</code>, or as a result of a call to <code>Mse</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>mse.ay</code>:</dt><dd><p>Object of class <code>"matrix"</code> </p>
</dd>
<dt><code>mse.ay.est</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>mse.ay.proc</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>mse.total</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>mse.total.est</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>mse.total.proc</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>FullTriangles</code>:</dt><dd><p>Object of class <code>"triangles"</code>  </p>
</dd>
</dl>



<h3>Methods</h3>

<p>No methods defined with class &quot;MultiChainLadderMse&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p> Wayne Zhang <a href="mailto:actuary_zhang@hotmail.com">actuary_zhang@hotmail.com</a> </p>


<h3>See Also</h3>

<p>See Also  <code><a href="#topic+MultiChainLadder-class">MultiChainLadder</a></code> and <code><a href="#topic+Mse">Mse</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("MultiChainLadderMse")
</code></pre>

<hr>
<h2 id='MultiChainLadderSummary-class'>Class &quot;MultiChainLadderSummary&quot;  </h2><span id='topic+MultiChainLadderSummary-class'></span><span id='topic++24+2CMultiChainLadderSummary-method'></span><span id='topic++5B+5B+2CMultiChainLadderSummary+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+5B+2CMultiChainLadderSummary+2Ccharacter+2Cmissing-method'></span><span id='topic+names+2CMultiChainLadderSummary-method'></span><span id='topic+show+2CMultiChainLadderSummary-method'></span>

<h3>Description</h3>

<p>	 This class stores the summary statistics from a &quot;MultiChainLadder&quot; object. These summary statistics include both model summary and report summary. </p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("MultiChainLadderSummary", ...)</code>, or a call from <code>summary</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>Triangles</code>:</dt><dd><p>Object of class <code>"triangles"</code> </p>
</dd>
<dt><code>FullTriangles</code>:</dt><dd><p>Object of class <code>"triangles"</code> </p>
</dd>
<dt><code>S.E.Full</code>:</dt><dd><p>Object of class <code>"list"</code>  </p>
</dd>
<dt><code>S.E.Est.Full</code>:</dt><dd><p>Object of class <code>"list"</code>  </p>
</dd>
<dt><code>S.E.Proc.Full</code>:</dt><dd><p>Object of class <code>"list"</code>  </p>
</dd>
<dt><code>Ultimate</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>IBNR</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>S.E.Ult</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>S.E.Est.Ult</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>S.E.Proc.Ult</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>report.summary</code>:</dt><dd><p>Object of class <code>"list"</code>  </p>
</dd>
<dt><code>coefficients</code>:</dt><dd><p>Object of class <code>"list"</code>  </p>
</dd>
<dt><code>coefCov</code>:</dt><dd><p>Object of class <code>"list"</code>  </p>
</dd>
<dt><code>residCov</code>:</dt><dd><p>Object of class <code>"list"</code>  </p>
</dd>
<dt><code>rstandard</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>fitted.values</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>residCor</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>model.summary</code>:</dt><dd><p>Object of class <code>"matrix"</code>  </p>
</dd>
<dt><code>portfolio</code>:</dt><dd><p>Object of class <code>"NullChar"</code>  </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>$</dt><dd><p><code>signature(x = "MultiChainLadderSummary")</code>: Method for primitive function <code>"$"</code>. It extracts a slot of <code>x</code> with a specified slot name, just as in list. </p>
</dd>
<dt>[[</dt><dd><p><code>signature(x = "MultiChainLadderSummary", i = "numeric", j = "missing")</code>: Method for primitive function <code>"[["</code>. It extracts the i-th slot of a <code>"MultiChainLadder"</code> object, just as in list. <code>i</code> could be a vetor. </p>
</dd>
<dt>[[</dt><dd><p><code>signature(x = "MultiChainLadderSummary", i = "character", j = "missing")</code>: Method for primitive function <code>"[["</code>. It extracts the slots of a <code>"MultiChainLadder"</code> object with names in <code>i</code>, just as in list. <code>i</code> could be a vetor. </p>
</dd>
<dt>names</dt><dd><p><code>signature(x = "MultiChainLadderSummary")</code>:  Method for function <code>names</code>, which returns the slot names of a <code>"MultiChainLadder"</code> object. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "MultiChainLadderSummary")</code>: Method for <code>show</code>. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Wayne Zhang <a href="mailto:actuary_zhang@hotmail.com">actuary_zhang@hotmail.com</a> </p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+summary+2CMultiChainLadder-method">summary,MultiChainLadder-method</a></code>, <code><a href="#topic+MultiChainLadder-class">MultiChainLadder-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("MultiChainLadderSummary")
</code></pre>

<hr>
<h2 id='MunichChainLadder'>Munich-chain-ladder Model </h2><span id='topic+MunichChainLadder'></span>

<h3>Description</h3>

<p>The Munich-chain-ladder model forecasts ultimate claims based on a cumulative
paid and incurred claims triangle. 
The model assumes that the Mack-chain-ladder model is applicable
to the paid and incurred claims triangle, see <code><a href="#topic+MackChainLadder">MackChainLadder</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MunichChainLadder(Paid, Incurred, 
                  est.sigmaP = "log-linear", est.sigmaI = "log-linear", 
                  tailP=FALSE, tailI=FALSE, weights=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MunichChainLadder_+3A_paid">Paid</code></td>
<td>
<p>cumulative paid claims triangle. Assume columns are the development
period, use transpose otherwise. A (mxn)-matrix <code class="reqn">P_{ik}</code> 
which is filled for <code class="reqn">k \leq n+1-i; i=1,\ldots,m; m\geq n</code></p>
</td></tr>
<tr><td><code id="MunichChainLadder_+3A_incurred">Incurred</code></td>
<td>
<p>cumulative incurred claims triangle. Assume columns are the development
period, use transpose otherwise. A (mxn)-matrix
<code class="reqn">I_{ik}</code> which is filled for <code class="reqn">k \leq n+1-i; i=1,\ldots,m,
      m\geq n </code></p>
</td></tr>
<tr><td><code id="MunichChainLadder_+3A_est.sigmap">est.sigmaP</code></td>
<td>
<p>defines how <code class="reqn">sigma_{n-1}</code> for the Paid triangle
is estimated, see <code>est.sigma</code> in <code><a href="#topic+MackChainLadder">MackChainLadder</a></code> for
more details, as <code>est.sigmaP</code> gets passed on to
<code>MackChainLadder</code>
</p>
</td></tr>
<tr><td><code id="MunichChainLadder_+3A_est.sigmai">est.sigmaI</code></td>
<td>
<p>defines how <code class="reqn">sigma_{n-1}</code> for the Incurred triangle
is estimated, see <code>est.sigma</code> in <code><a href="#topic+MackChainLadder">MackChainLadder</a></code> for
more details, as <code>est.sigmaI</code> is passed on to
<code>MackChainLadder</code>
</p>
</td></tr>
<tr><td><code id="MunichChainLadder_+3A_tailp">tailP</code></td>
<td>
<p>defines how the tail of the <code>Paid</code> triangle is estimated and
is passed on to <code><a href="#topic+MackChainLadder">MackChainLadder</a></code>, see <code>tail</code> just there.</p>
</td></tr>
<tr><td><code id="MunichChainLadder_+3A_taili">tailI</code></td>
<td>
<p>defines how the tail of the <code>Incurred</code> triangle is estimated and
is passed on to <code><a href="#topic+MackChainLadder">MackChainLadder</a></code>, see <code>tail</code> just there.</p>
</td></tr>
<tr><td><code id="MunichChainLadder_+3A_weights">weights</code></td>
<td>
<p>weights. Default: 1, which sets the weights for all triangle entries to 1. 
Otherwise specify weights as a matrix of the same dimension as Triangle with all weight entries in [0; 1]. 
Hence, any entry set to 0 or NA eliminates that age-to-age factor from inclusion in the model. See also 'Details' in MackChainladder function.
The weight matrix is the same for Paid and Incurred.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>MunichChainLadder returns a list with the following elements
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>matched call</p>
</td></tr> 
<tr><td><code>Paid</code></td>
<td>
<p>input paid triangle</p>
</td></tr>
<tr><td><code>Incurred</code></td>
<td>
<p>input incurred triangle</p>
</td></tr>
<tr><td><code>MCLPaid</code></td>
<td>
<p>Munich-chain-ladder forecasted full triangle on paid data</p>
</td></tr>
<tr><td><code>MCLIncurred</code></td>
<td>
<p>Munich-chain-ladder forecasted full triangle on incurred data</p>
</td></tr>
<tr><td><code>MackPaid</code></td>
<td>
<p>Mack-chain-ladder output of the paid triangle</p>
</td></tr>
<tr><td><code>MackIncurred</code></td>
<td>
<p>Mack-chain-ladder output of the incurred triangle</p>
</td></tr>
<tr><td><code>PaidResiduals</code></td>
<td>
<p>paid residuals</p>
</td></tr>
<tr><td><code>IncurredResiduals</code></td>
<td>
<p>incurred residuals</p>
</td></tr>
<tr><td><code>QResiduals</code></td>
<td>
<p>paid/incurred residuals</p>
</td></tr>
<tr><td><code>QinverseResiduals</code></td>
<td>
<p>incurred/paid residuals</p>
</td></tr>
<tr><td><code>lambdaP</code></td>
<td>
<p>dependency coefficient between paid chain-ladder
age-to-age factors and
incurred/paid age-to-age factors</p>
</td></tr>
<tr><td><code>lambdaI</code></td>
<td>
<p>dependency coefficient between incurred chain-ladder
ratios and paid/incurred ratios</p>
</td></tr>
<tr><td><code>qinverse.f</code></td>
<td>
<p>chain-ladder-link age-to-age factors of the incurred/paid triangle</p>
</td></tr>
<tr><td><code>rhoP.sigma</code></td>
<td>
<p>estimated conditional deviation around the
paid/incurred age-to-age factors</p>
</td></tr>
<tr><td><code>q.f</code></td>
<td>
<p>chain-ladder age-to-age factors of the paid/incurred triangle</p>
</td></tr>
<tr><td><code>rhoI.sigma</code></td>
<td>
<p>estimated conditional deviation around the
incurred/paid age-to-age factors</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Markus Gesmann <a href="mailto:markus.gesmann@gmail.com">markus.gesmann@gmail.com</a> </p>


<h3>References</h3>

<p><cite>Gerhard Quarg and Thomas Mack. Munich Chain Ladder. <em>Blatter DGVFM</em> 26,
Munich, 2004.</cite>
</p>


<h3>See Also</h3>

<p> See also  
<code><a href="#topic+summary.MunichChainLadder">summary.MunichChainLadder</a></code>, 
<code><a href="#topic+plot.MunichChainLadder">plot.MunichChainLadder</a></code> ,
<code><a href="#topic+MackChainLadder">MackChainLadder</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
MCLpaid
MCLincurred
op &lt;- par(mfrow=c(1,2))
plot(MCLpaid)
plot(MCLincurred)
par(op)

# Following the example in Quarg's (2004) paper:
MCL &lt;- MunichChainLadder(MCLpaid, MCLincurred, est.sigmaP=0.1, est.sigmaI=0.1)
MCL
plot(MCL)
# You can access the standard chain-ladder (Mack) output via
MCL$MackPaid
MCL$MackIncurred

# Input triangles section 3.3.1
MCL$Paid
MCL$Incurred
# Parameters from section 3.3.2
# Standard chain-ladder age-to-age factors
MCL$MackPaid$f
MCL$MackIncurred$f
MCL$MackPaid$sigma
MCL$MackIncurred$sigma
# Check Mack's assumptions graphically
plot(MCL$MackPaid)
plot(MCL$MackIncurred)

MCL$q.f
MCL$rhoP.sigma
MCL$rhoI.sigma

MCL$PaidResiduals
MCL$IncurredResiduals

MCL$QinverseResiduals
MCL$QResiduals

MCL$lambdaP
MCL$lambdaI
# Section 3.3.3 Results
MCL$MCLPaid
MCL$MCLIncurred

</code></pre>

<hr>
<h2 id='MW2008'>Run-off claims triangle</h2><span id='topic+MW2008'></span>

<h3>Description</h3>

<p>Cumulative claims development triangle
</p>


<h3>Format</h3>

<p>A matrix with 9 accident years and 9 development years.
</p>


<h3>Source</h3>

<p><cite>Modelling the claims development result for solvency purposes.
Michael Merz, Mario V. Wüthrich. Casualty Actuarial Society E-Forum, Fall 2008.</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>MW2008
plot(MW2008, lattice=TRUE)
</code></pre>

<hr>
<h2 id='MW2014'>Run-off claims triangle</h2><span id='topic+MW2014'></span>

<h3>Description</h3>

<p>Cumulative claims development triangle
</p>


<h3>Format</h3>

<p>A matrix with 17 accident years and 17 development years.
</p>


<h3>Source</h3>

<p><cite>Claims Run-Off Uncertainty: The Full Picture. Michael Merz, 
Mario V. Wüthrich. Swiss Finance Institute Research Paper No. 14-69. 
<a href="https://www.ssrn.com/abstract=2524352">https://www.ssrn.com/abstract=2524352</a>. 2014</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>MW2014
plot(MW2014, lattice=TRUE)
</code></pre>

<hr>
<h2 id='NullNum-class'>Class &quot;NullNum&quot;, &quot;NullChar&quot; and &quot;NullList&quot; </h2><span id='topic+NullNum-class'></span><span id='topic+NullChar-class'></span><span id='topic+NullList-class'></span>

<h3>Description</h3>

<p>	Virtual class for <code>c("null", "numeric")</code>, <code>c("null","character"</code> and  <code>c("null","list"</code></p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Methods</h3>

<p>No methods defined with class &quot;NullNum&quot; in the signature.
</p>

<hr>
<h2 id='PaidIncurredChain'>PaidIncurredChain</h2><span id='topic+PaidIncurredChain'></span>

<h3>Description</h3>

<p>The Paid-incurred Chain model (Merz, Wuthrich (2010)) combines 
claims payments and incurred losses information to get 
a unified ultimate loss prediction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PaidIncurredChain(triangleP, triangleI)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PaidIncurredChain_+3A_trianglep">triangleP</code></td>
<td>
<p>Cumulative claims payments triangle</p>
</td></tr>
<tr><td><code id="PaidIncurredChain_+3A_trianglei">triangleI</code></td>
<td>
<p>Incurred losses triangle.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method uses some basic properties of multivariate Gaussian distributions
to obtain a mathematically rigorous and consistent model for the combination
of the two information channels.
</p>
<p>We assume as usual that I=J. 
The model assumptions for the Log-Normal PIC Model are the following:
</p>

<ul>
<li><p> Conditionally, given <code class="reqn">\Theta = (\Phi_0,...,\Phi_I,
  \Psi_0,...,\Psi_{I-1},\sigma_0,...,\sigma_{I-1},\tau_0,...,\tau_{I-1})</code>
we have
</p>

<ul>
<li><p> the random vector <code class="reqn">(\xi_{0,0},...,\xi_{I,I},
    \zeta_{0,0},...,\zeta_{I,I-1})</code> has multivariate Gaussian distribution
with uncorrelated components given by
</p>
<p style="text-align: center;"><code class="reqn">\xi_{i,j} \sim N(\Phi_j,\sigma^2_j),</code>
</p>

<p style="text-align: center;"><code class="reqn">\zeta_{k,l} \sim N(\Psi_l,\tau^2_l);</code>
</p>

</li>
<li><p> cumulative payments are given by the recursion
</p>
<p style="text-align: center;"><code class="reqn">P_{i,j} = P_{i,j-1} \exp(\xi_{i,j}),</code>
</p>

<p>with initial value <code class="reqn">P_{i,0} = \exp (\xi_{i,0})</code>;
</p>
</li>
<li><p> incurred losses <code class="reqn">I_{i,j}</code> are given by the backwards
recursion
</p>
<p style="text-align: center;"><code class="reqn">I_{i,j-1} = I_{i,j} \exp(-\zeta_{i,j-1}),</code>
</p>

<p>with initial value <code class="reqn">I_{i,I}=P_{i,I}</code>.
</p>
</li></ul>

</li>
<li><p> The components of <code class="reqn">\Theta</code> are independent and 
<code class="reqn">\sigma_j,\tau_j &gt; 0</code> for all j.
</p>
</li></ul>

<p>Parameters <code class="reqn">\Theta</code> in the model are in general not known and need to be
estimated from observations. They are estimated in a Bayesian framework.
In the Bayesian PIC model they assume that the previous assumptions 
hold true with deterministic <code class="reqn">\sigma_0,...,\sigma_J</code> and 
<code class="reqn">\tau_0,...,\tau_{J-1}</code> and
</p>
<p style="text-align: center;"><code class="reqn">\Phi_m \sim N(\phi_m,s^2_m),</code>
</p>

<p style="text-align: center;"><code class="reqn">\Psi_n \sim N(\psi_n,t^2_n).</code>
</p>

<p>This is not a full Bayesian approach but has the advantage to give
analytical expressions for the posterior distributions and the prediction
uncertainty.
</p>


<h3>Value</h3>

<p>The function returns:
</p>

<ul>
<li> <p><strong>Ult.Loss.Origin</strong> Ultimate losses for different origin years.
</p>
</li>
<li> <p><strong>Ult.Loss</strong> Total ultimate loss.
</p>
</li>
<li> <p><strong>Res.Origin</strong> Claims reserves for different origin years.
</p>
</li>
<li> <p><strong>Res.Tot</strong> Total reserve.
</p>
</li>
<li> <p><strong>s.e.</strong> Square root of mean square error of prediction 
for the total ultimate loss.
</p>
</li></ul>



<h3>Note</h3>

<p>The model is implemented in the special case of non-informative priors.
</p>


<h3>Author(s)</h3>

<p>Fabio Concina, <a href="mailto:fabio.concina@gmail.com">fabio.concina@gmail.com</a>
</p>


<h3>References</h3>

<p>Merz, M., Wuthrich, M. (2010). Paid-incurred chain claims reserving method. 
Insurance: Mathematics and Economics, 46(3), 568-579.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MackChainLadder">MackChainLadder</a></code>,<code><a href="#topic+MunichChainLadder">MunichChainLadder</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>PaidIncurredChain(USAApaid, USAAincurred)
</code></pre>

<hr>
<h2 id='plot-MultiChainLadder'> Methods for Function plot </h2><span id='topic+plot-methods'></span><span id='topic+plot+2CMultiChainLadder+2Cmissing-method'></span>

<h3>Description</h3>

<p>Methods for function <code>plot</code> to produce different diagonostic plots for an object of class &quot;MultiChainLadder&quot;. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S4 method for signature 'MultiChainLadder,missing'
plot(x, y, which.plot=1:4, 
						which.triangle=NULL, 
						main=NULL,  
						portfolio=NULL,
						lowess=TRUE, 
						legend.cex=0.75,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot-MultiChainLadder_+3A_x">x</code></td>
<td>
<p>An object of class &quot;MultiChainLadder&quot;. </p>
</td></tr>
<tr><td><code id="plot-MultiChainLadder_+3A_y">y</code></td>
<td>
<p>&quot;missing&quot; </p>
</td></tr>
<tr><td><code id="plot-MultiChainLadder_+3A_which.plot">which.plot</code></td>
<td>
<p>This specifies which type of plot is desired. Its range is 1:5, but defaults to 1:4. &quot;1&quot; is the barplot of observed losses and predicted IBNR stacked and MSE predictions as error bars;  &quot;2&quot; is a trajectory plot of the development pattern; &quot;3&quot; is the residual plot of standardized residuals against the fitted values; &quot;4&quot; is the Normal-QQ plot of the standardized residuals. &quot;5&quot; is the &quot;xyplot&quot; of development with confidence intervals for each accident year.  Note that &quot;3&quot; and &quot;4&quot; are not available for portfolio. </p>
</td></tr>
<tr><td><code id="plot-MultiChainLadder_+3A_which.triangle">which.triangle</code></td>
<td>
<p>This specifies which triangles are to be plotted. Default value is NULL, where all triangles plus the portfolio result will be plotted.</p>
</td></tr>
<tr><td><code id="plot-MultiChainLadder_+3A_main">main</code></td>
<td>
<p>It should be a list of titles for each plot. If not supplied, use default titles.</p>
</td></tr>
<tr><td><code id="plot-MultiChainLadder_+3A_portfolio">portfolio</code></td>
<td>
<p>It specifies which triangles are to be summed as the portfolio, to be passed on to <code>summary</code>.</p>
</td></tr>
<tr><td><code id="plot-MultiChainLadder_+3A_lowess">lowess</code></td>
<td>
<p>Logical. If <code>TRUE</code>,  smoothing lines will be added on residual plots. </p>
</td></tr>
<tr><td><code id="plot-MultiChainLadder_+3A_legend.cex">legend.cex</code></td>
<td>
<p>plotting parameter to be passes on to <code>cex</code> in <code>legend</code> if <code>which.plot=1</code>. </p>
</td></tr>
<tr><td><code id="plot-MultiChainLadder_+3A_...">...</code></td>
<td>
<p> optional graphical arguments. </p>
</td></tr>
</table>


<h3>See Also</h3>

<p> See also <code><a href="#topic+MultiChainLadder">MultiChainLadder</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(liab)
fit.liab &lt;- MultiChainLadder(liab)

# generate diagonostic plots
par(mfcol=(c(3,2)))
plot(fit.liab,which.plot=1:2)

par(mfrow=(c(2,2)))
plot(fit.liab,which.plot=3:4)

plot(fit.liab,which.triangle=1,which.plot=5)
graphics.off()

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.BootChainLadder'> Plot method for a BootChainLadder object</h2><span id='topic+plot.BootChainLadder'></span>

<h3>Description</h3>

<p><code>plot.BootChainLadder</code>, a method to plot the output of
<code><a href="#topic+BootChainLadder">BootChainLadder</a></code>. It is designed to give a quick overview
of a <code>BootChainLadder</code> object and to check the model assumptions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BootChainLadder'
plot(x, mfrow=NULL, title=NULL, log=FALSE, 
    which=1:4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.BootChainLadder_+3A_x">x</code></td>
<td>
<p>output from <code>BootChainLadder</code></p>
</td></tr>
<tr><td><code id="plot.BootChainLadder_+3A_mfrow">mfrow</code></td>
<td>
<p>see <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="plot.BootChainLadder_+3A_title">title</code></td>
<td>
<p>see <code><a href="graphics.html#topic+title">title</a></code></p>
</td></tr> 
<tr><td><code id="plot.BootChainLadder_+3A_log">log</code></td>
<td>
<p>logical. If <code>TRUE</code> the y-axes of the 'latest
incremental actual vs. simulated' plot will be on a log-scale</p>
</td></tr>
<tr><td><code id="plot.BootChainLadder_+3A_which">which</code></td>
<td>
<p>if a subset of the plots is required, specify a subset of the numbers 1:4.</p>
</td></tr>
<tr><td><code id="plot.BootChainLadder_+3A_...">...</code></td>
<td>
<p> optional arguments. See <code><a href="graphics.html#topic+plot.default">plot.default</a></code> for
more details. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot.BootChainLadder</code> shows four graphs, starting with a histogram
of the total simulated IBNRs over all origin periods, including a rug
plot; a plot of the empirical cumulative distribution of the total
IBNRs over all origin periods; a box-whisker plot of simulated ultimate
claims costs against origin periods; and a box-whisker plot of
simulated incremental claims cost for the latest available calendar period
against actual incremental claims of the same period. In the last plot
the simulated data should follow the same trend as the actual data,
otherwise the original data might have some intrinsic trends which are
not reflected in the model.
</p>


<h3>Note</h3>

<p>The box-whisker plot of latest actual incremental claims against simulated
claims follows is based on ideas from Barnett and Zehnwirth in:
<cite>Barnett and Zehnwirth. The need for diagnostic assessment of
bootstrap predictive models, <em>Insureware technical report</em>. 2007</cite>
</p>


<h3>Author(s)</h3>

<p>Markus Gesmann</p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+BootChainLadder">BootChainLadder</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>B &lt;- BootChainLadder(RAA)
plot(B)
plot(B, log=TRUE)
</code></pre>

<hr>
<h2 id='plot.checkTriangleInflation'> Plot method for a checkTriangleInflation object </h2><span id='topic+plot.checkTriangleInflation'></span>

<h3>Description</h3>

<p><code>plot.checkTriangleInflation</code>, a method to plot the output of
<code><a href="#topic+checkTriangleInflation">checkTriangleInflation</a></code>. It is designed to give a quick overview
of a <code>checkTriangleInflation</code> object and to check the inflation regression curves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'checkTriangleInflation'
plot(x, col.line = "black", type = "b", xlab = "dev. period", ylab = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.checkTriangleInflation_+3A_x">x</code></td>
<td>
<p>output from <code>checkTriangleInflation</code></p>
</td></tr>
<tr><td><code id="plot.checkTriangleInflation_+3A_col.line">col.line</code></td>
<td>
<p>Default: &quot;black&quot;. Line color</p>
</td></tr>
<tr><td><code id="plot.checkTriangleInflation_+3A_type">type</code></td>
<td>
<p>Default: &quot;b&quot;. What type of plot should be drawn</p>
</td></tr>
<tr><td><code id="plot.checkTriangleInflation_+3A_xlab">xlab</code></td>
<td>
<p>Default: &quot;dev. period&quot;. X axis label</p>
</td></tr>
<tr><td><code id="plot.checkTriangleInflation_+3A_ylab">ylab</code></td>
<td>
<p>Default: NULL. Y axis label</p>
</td></tr>
<tr><td><code id="plot.checkTriangleInflation_+3A_...">...</code></td>
<td>
<p>optional arguments. See <code><a href="graphics.html#topic+plot.default">plot.default</a></code> for
more details.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p><code>plot.cyeff.test</code> plots all the columns of the triangle (Development Periods) against the regression curves.
</p>


<h3>Author(s)</h3>

<p>Marco De Virgilis <a href="mailto:devirgilis.marco@gmail.com">devirgilis.marco@gmail.com</a></p>


<h3>See Also</h3>

<p> See Also <code><a href="#topic+checkTriangleInflation">checkTriangleInflation</a></code>,
<code><a href="#topic+summary.checkTriangleInflation">summary.checkTriangleInflation</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>test &lt;- checkTriangleInflation(MedMal$MedMalOutstanding / MedMal$MedMalOpen)
plot(test)
</code></pre>

<hr>
<h2 id='plot.clark'>Plot Clark method residuals</h2><span id='topic+plot.clark'></span>

<h3>Description</h3>

<p>Function to plot the residuals of the Clark LDF and Cape Cod methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'clark'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.clark_+3A_x">x</code></td>
<td>

<p>object resulting from a run of the ClarkLDF or ClarkCapeCod functions.
</p>
</td></tr>
<tr><td><code id="plot.clark_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If Clark's model is appropriate for the actual data,
then the standardized residuals should appear as
independent standard normal random variables.
This function creates four plots of standardized residuals on a single page:
</p>

<ol>
<li><p> By origin
</p>
</li>
<li><p> By age
</p>
</li>
<li><p> By fitted value
</p>
</li>
<li><p> Normal Q-Q plot with results of Shapiro-Wilk test
</p>
</li></ol>

<p>If the model is appropriate then there should not appear to be any trend in the
standardized residuals or any systematic differences in the spread 
about the line y = 0. 
The Shapiro-Wilk p-value shown in the fourth plot gives an indication 
of how closely the standardized residuals can be considered &quot;draws&quot;
from a standard normal random variable.
</p>


<h3>Author(s)</h3>

<p>Daniel Murphy
</p>


<h3>References</h3>

<p>Clark, David R., 
&quot;LDF Curve-Fitting and Stochastic Reserving: A Maximum Likelihood Approach&quot;,
<em>Casualty Actuarial Society Forum</em>, Fall, 2003
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ClarkLDF">ClarkLDF</a></code>, <code><a href="#topic+ClarkCapeCod">ClarkCapeCod</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
X &lt;- GenIns
Y &lt;- ClarkLDF(GenIns, maxage=Inf, G="weibull")
plot(Y)  # One obvious outlier, shapiro test flunked
X[4,4] &lt;- NA  # remove the outlier
Z &lt;- ClarkLDF(GenIns, maxage=Inf, G="weibull")
plot(Z)  # Q-Q plot looks good

</code></pre>

<hr>
<h2 id='plot.cyEffTest'> Plot method for a cyEffTest object </h2><span id='topic+plot.cyEffTest'></span>

<h3>Description</h3>

<p><code>plot.cyEffTest</code>, a method to plot the output of
<code><a href="#topic+cyEffTest">cyEffTest</a></code>. It is designed to give a quick overview
of a <code>cyEffTest</code> object and to check the assumption of independece between calendar years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cyEffTest'
plot(x, type = "l", xlab = "Z", ylab = "Density", 
                          main = "Calendar Year Effect", col.area = "gray", 
                          border = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cyEffTest_+3A_x">x</code></td>
<td>
<p>output from <code>cyEffTest</code></p>
</td></tr>
<tr><td><code id="plot.cyEffTest_+3A_type">type</code></td>
<td>
<p>Default: &quot;l&quot;. What type of plot should be drawn</p>
</td></tr>
<tr><td><code id="plot.cyEffTest_+3A_xlab">xlab</code></td>
<td>
<p>Default: &quot;Z&quot;. X axis label</p>
</td></tr>
<tr><td><code id="plot.cyEffTest_+3A_ylab">ylab</code></td>
<td>
<p>Default: &quot;Density&quot;. Y axis label</p>
</td></tr>
<tr><td><code id="plot.cyEffTest_+3A_main">main</code></td>
<td>
<p>Default: &quot;Calendar Year Effect&quot;. Plot title</p>
</td></tr>
<tr><td><code id="plot.cyEffTest_+3A_col.area">col.area</code></td>
<td>
<p>Default: &quot;gray&quot;. Color of the shaded area.</p>
</td></tr>
<tr><td><code id="plot.cyEffTest_+3A_border">border</code></td>
<td>
<p>Default: NULL, the color to draw the border. Use <code>border = NA</code> to omit borders.</p>
</td></tr>
<tr><td><code id="plot.cyEffTest_+3A_...">...</code></td>
<td>
<p>optional arguments. See <code><a href="graphics.html#topic+plot.default">plot.default</a></code> for
more details.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p><code>plot.cyEffTest</code> shows the underlying distribution, the test statistic <code class="reqn">Z</code> and the relative Confidence Interval.
If the test statistic <code class="reqn">Z</code> is within the highlighted region the hypothesis of dependence between calendar years could be rejected.
</p>


<h3>Author(s)</h3>

<p>Marco De Virgilis <a href="mailto:devirgilis.marco@gmail.com">devirgilis.marco@gmail.com</a></p>


<h3>See Also</h3>

<p> See Also <code><a href="#topic+cyEffTest">cyEffTest</a></code>,
<code><a href="#topic+summary.cyEffTest">summary.cyEffTest</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(cyEffTest(RAA))
</code></pre>

<hr>
<h2 id='plot.dfCorTest'> Plot method for a dfCorTest object </h2><span id='topic+plot.dfCorTest'></span>

<h3>Description</h3>

<p><code>plot.dfCorTest</code>, a method to plot the output of
<code><a href="#topic+dfCorTest">dfCorTest</a></code>. It is designed to give a quick overview
of a <code>dfCorTest</code> object and to check the assumption of independece between development factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dfCorTest'
plot(x, type = "l", xlab = "T", ylab = "Density", 
                          main = "Development Factor Correlation", col.area = "gray",
                          border = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.dfCorTest_+3A_x">x</code></td>
<td>
<p>output from <code>dfCorTest</code></p>
</td></tr>
<tr><td><code id="plot.dfCorTest_+3A_type">type</code></td>
<td>
<p>Default: &quot;l&quot;. What type of plot should be drawn</p>
</td></tr>
<tr><td><code id="plot.dfCorTest_+3A_xlab">xlab</code></td>
<td>
<p>Default: &quot;Z&quot;. X axis label</p>
</td></tr>
<tr><td><code id="plot.dfCorTest_+3A_ylab">ylab</code></td>
<td>
<p>Default: &quot;Density&quot;. Y axis label</p>
</td></tr>
<tr><td><code id="plot.dfCorTest_+3A_main">main</code></td>
<td>
<p>Default: &quot;Development Factor Correlation&quot;. Plot title</p>
</td></tr>
<tr><td><code id="plot.dfCorTest_+3A_col.area">col.area</code></td>
<td>
<p>Default: &quot;gray&quot;. Color of the shaded area.</p>
</td></tr>
<tr><td><code id="plot.dfCorTest_+3A_border">border</code></td>
<td>
<p>Default: NULL, the color to draw the border. Use <code>border = NA</code> to omit borders.</p>
</td></tr>
<tr><td><code id="plot.dfCorTest_+3A_...">...</code></td>
<td>
<p> optional arguments. See <code><a href="graphics.html#topic+plot.default">plot.default</a></code> for
more details.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p><code>plot.dfCorTest</code> shows the underlying distribution, the test statistic <code class="reqn">Z</code> and the relative Confidence Interval.
If the test statistic <code class="reqn">Z</code> is within the highlighted region the hypothesis of correlation between development factors could be rejected.
</p>


<h3>Author(s)</h3>

<p>Marco De Virgilis <a href="mailto:devirgilis.marco@gmail.com">devirgilis.marco@gmail.com</a></p>


<h3>See Also</h3>

<p> See Also <code><a href="#topic+dfCorTest">dfCorTest</a></code>,
<code><a href="#topic+summary.dfCorTest">summary.dfCorTest</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(dfCorTest(RAA))
</code></pre>

<hr>
<h2 id='plot.MackChainLadder'> Plot method for a MackChainLadder object </h2><span id='topic+plot.MackChainLadder'></span>

<h3>Description</h3>

<p><code>plot.MackChainLadder</code>, a method to plot the output of
<code><a href="#topic+MackChainLadder">MackChainLadder</a></code>. It is designed to give a quick overview
of a <code>MackChainLadder</code> object and to check Mack's model assumptions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MackChainLadder'
plot(x, mfrow=NULL, title=NULL, 
lattice=FALSE, which=1:6, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.MackChainLadder_+3A_x">x</code></td>
<td>
<p>output from <code>MackChainLadder</code></p>
</td></tr>
<tr><td><code id="plot.MackChainLadder_+3A_mfrow">mfrow</code></td>
<td>
<p>see <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="plot.MackChainLadder_+3A_title">title</code></td>
<td>
<p>see <code><a href="graphics.html#topic+title">title</a></code></p>
</td></tr>  
<tr><td><code id="plot.MackChainLadder_+3A_lattice">lattice</code></td>
<td>
<p>logical. Default is set to <code>FALSE</code> and plots as
described in the details section are produced. If <code>lattice=TRUE</code>, the function
<code><a href="lattice.html#topic+xyplot">xyplot</a></code> of the lattice package is used to plot
developments by origin period in different panels, plus Mack's S.E.</p>
</td></tr>  
<tr><td><code id="plot.MackChainLadder_+3A_which">which</code></td>
<td>
<p>if a subset of the plots is required, specify a subset of the numbers 1:6.</p>
</td></tr>
<tr><td><code id="plot.MackChainLadder_+3A_...">...</code></td>
<td>
<p> optional arguments. See <code><a href="graphics.html#topic+plot.default">plot.default</a></code> for
more details.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p><code>plot.MackChainLadder</code> shows six graphs, starting from the top left
with a stacked bar-chart of the latest claims position plus IBNR and
Mack's standard error by origin period; next right to it is a
plot of the forecasted development patterns for all origin periods
(numbered, starting with 1 for the oldest origin period),
and 4 residual plots. The residual plots
show the standardised residuals against fitted values, origin period,
calendar period and development period. All residual plot should show
no patterns or directions for Mack's method to be applicable.
Pattern in any direction can be the result of trends and should be
further investigated, see
<cite>Barnett and Zehnwirth. Best estimates for reserves. Proceedings
of the CAS, LXXXVI I(167), November 2000.</cite> for more details on trends.
</p>


<h3>Author(s)</h3>

<p>Markus Gesmann</p>


<h3>See Also</h3>

<p> See Also <code><a href="#topic+MackChainLadder">MackChainLadder</a></code>, 
<code><a href="#topic+residuals.MackChainLadder">residuals.MackChainLadder</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(MackChainLadder(RAA))
</code></pre>

<hr>
<h2 id='plot.MunichChainLadder'>  Plot method for a MunichChainLadder object </h2><span id='topic+plot.MunichChainLadder'></span>

<h3>Description</h3>

<p><code>plot.MunichChainLadder</code>, a method to plot the output of
<code><a href="#topic+MunichChainLadder">MunichChainLadder</a></code> object. It is designed to give a quick
overview of a <code>MunichChainLadder</code> object and to check the
correlation between the paid and incurred residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'MunichChainLadder'
plot(x,  mfrow=c(2,2), title=NULL, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.MunichChainLadder_+3A_x">x</code></td>
<td>
<p>output from <code>MunichChainLadder</code></p>
</td></tr>
<tr><td><code id="plot.MunichChainLadder_+3A_mfrow">mfrow</code></td>
<td>
<p>see <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="plot.MunichChainLadder_+3A_title">title</code></td>
<td>
<p>see <code><a href="graphics.html#topic+title">title</a></code></p>
</td></tr>
<tr><td><code id="plot.MunichChainLadder_+3A_...">...</code></td>
<td>
<p> optional arguments. See <code><a href="graphics.html#topic+plot.default">plot.default</a></code> for
more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot.MunichChainLadder</code> shows four plots, starting from the top
left with a barchart of forecasted ultimate claims costs by
Munich-chain-ladder (MCL) on paid and incurred data by origin period;
the barchart next to it compares the ratio of forecasted ultimate
claims cost on paid and incurred data based on the Mack-chain-ladder and
Munich-chain-ladder methods; the two residual plots at the bottom show the
correlation of (incurred/paid)-chain-ladder factors against the
paid-chain-ladder factors and the correlation of
(paid/incurred)-chain-ladder factors against the incurred-chain-ladder
factors.
</p>


<h3>Note</h3>

<p> The design of the plots follows those in Quarg's (2004) paper:
<cite>Gerhard Quarg and Thomas Mack. Munich Chain Ladder. Blatter DGVFM 26,
Munich, 2004.</cite>
</p>


<h3>Author(s)</h3>

<p> Markus Gesmann</p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+MunichChainLadder">MunichChainLadder</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- MunichChainLadder(MCLpaid, MCLincurred)
plot(M)
</code></pre>

<hr>
<h2 id='predict.TriangleModel'>Prediction of a claims triangle</h2><span id='topic+predict.TriangleModel'></span><span id='topic+predict.ChainLadder'></span>

<h3>Description</h3>

<p>The function is internally used by <code><a href="#topic+MackChainLadder">MackChainLadder</a></code> to forecast future claims.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TriangleModel'
predict(object,...)
## S3 method for class 'ChainLadder'
predict(object,...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.TriangleModel_+3A_object">object</code></td>
<td>
<p>a list with two items: <code>Models</code>, <code>Triangle</code>
</p>

<dl>
<dt><code>Models</code></dt><dd><p>list of linear models for each development period
</p>
</dd>
<dt><code>Triangle</code></dt><dd><p>input triangle to forecast
</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="predict.TriangleModel_+3A_...">...</code></td>
<td>
<p> not in use</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>FullTriangle</code></td>
<td>
<p>forecasted claims triangle</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Markus Gesmann</p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+chainladder">chainladder</a></code>, <code><a href="#topic+MackChainLadder">MackChainLadder</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
RAA

CL &lt;- chainladder(RAA)
CL
predict(CL)
</code></pre>

<hr>
<h2 id='print.ata'>Print Age-to-Age factors</h2><span id='topic+print.ata'></span>

<h3>Description</h3>

<p>Function to print the results
of a call to the <code>ata</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ata'
print(x, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.ata_+3A_x">x</code></td>
<td>
<p>object resulting from a call to the <code><a href="#topic+ata">ata</a></code> function</p>
</td></tr>
<tr><td><code id="print.ata_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>print</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>print.ata</code> simply <code>print</code>s <code><a href="#topic+summary.ata">summary.ata</a></code>.
</p>


<h3>Value</h3>

<p>A <code>summary.ata</code> matrix, invisibly.
</p>


<h3>Author(s)</h3>

<p>Daniel Murphy
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ata">ata</a></code> and <code><a href="#topic+summary.ata">summary.ata</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- ata(GenIns)

## Print ata factors rounded to 3 decimal places, the summary.ata default
print(x) 

## Round to 4 decimal places and print cells corresponding 
## to future observations as blanks.
print(summary(x, digits=4), na.print="") 

</code></pre>

<hr>
<h2 id='print.checkTriangleInflation'> Print function for a checkTriangleInflation object </h2><span id='topic+print.checkTriangleInflation'></span>

<h3>Description</h3>

<p><code>print</code> method for a <code>checkTriangleInflation</code>
object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'checkTriangleInflation'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.checkTriangleInflation_+3A_x">x</code></td>
<td>
<p>object of class <code>checkTriangleInflation</code></p>
</td></tr>
<tr><td><code id="print.checkTriangleInflation_+3A_...">...</code></td>
<td>
<p> optional arguments for a <code>print</code> method </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>print.checkTriangleInflation</code> show the print of a <code>checkTriangleInflation</code> object.
</p>


<h3>Value</h3>

<p><code>print.checkTriangleInflation</code> displays the default information resulting from 
a call of the checkTriangleInflation method
</p>


<h3>Author(s)</h3>

<p>Marco De Virgilis <a href="mailto:devirgilis.marco@gmail.com">devirgilis.marco@gmail.com</a></p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+checkTriangleInflation">checkTriangleInflation</a></code>,
<code><a href="#topic+plot.checkTriangleInflation">plot.checkTriangleInflation</a></code>,
<code><a href="#topic+summary.checkTriangleInflation">summary.checkTriangleInflation</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> test &lt;- checkTriangleInflation(MedMal$MedMalOutstanding / MedMal$MedMalOpen)
 print(test)
</code></pre>

<hr>
<h2 id='print.clark'>Print results of Clark methods</h2><span id='topic+print.clark'></span><span id='topic+print.ClarkLDF'></span><span id='topic+print.ClarkCapeCod'></span>

<h3>Description</h3>

<p>Functions to print the results
of the ClarkLDF and ClarkCapeCod methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'ClarkLDF'
print(x, Amountdigits=0, LDFdigits=3, CVdigits=3, 
            row.names = FALSE, ...)

## S3 method for class 'ClarkCapeCod'
print(x, Amountdigits=0, ELRdigits=3, Gdigits=4, CVdigits=3,
            row.names = FALSE, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.clark_+3A_x">x</code></td>
<td>

<p>object resulting from a run of the ClarkLDF or ClarkCapeCod function.
</p>
</td></tr>
<tr><td><code id="print.clark_+3A_amountdigits">Amountdigits</code></td>
<td>
<p>number of digits to display to the right of the decimal point for &quot;amount&quot; columns</p>
</td></tr>
<tr><td><code id="print.clark_+3A_ldfdigits">LDFdigits</code></td>
<td>
<p>number of digits to display to the right of the decimal point for the
loss development factor (LDF) column</p>
</td></tr>
<tr><td><code id="print.clark_+3A_cvdigits">CVdigits</code></td>
<td>
<p>number of digits to display to the right of the decimal point for the 
coefficient of variation (CV) column</p>
</td></tr>
<tr><td><code id="print.clark_+3A_elrdigits">ELRdigits</code></td>
<td>
<p>number of digits to display to the right of the decimal point for the
expected loss ratio (ELR) column</p>
</td></tr>
<tr><td><code id="print.clark_+3A_gdigits">Gdigits</code></td>
<td>
<p>number of digits to display to the right of the decimal point for the
&quot;growth function factor&quot; column; 
default of 4 conforms with the table on pp. 67, 68 of Clark's paper</p>
</td></tr>
<tr><td><code id="print.clark_+3A_row.names">row.names</code></td>
<td>
<p>logical (or character vector), 
indicating whether (or what) row names should be printed
(same as for <code><a href="base.html#topic+print.data.frame">print.data.frame</a></code>)</p>
</td></tr>
<tr><td><code id="print.clark_+3A_...">...</code></td>
<td>

<p>further arguments passed to <code>print</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Display the default information in &quot;pretty format&quot; resulting from 
a run of the &quot;LDF Method&quot; or &quot;Cape Cod Method&quot; &ndash;
a &quot;Development-type&quot; exhibit for Clark's &quot;LDF Method,&quot; 
a &quot;Bornhuetter-Ferguson-type&quot; exhibit for Clark's &quot;Cape Cod Method.&quot;
</p>
<p>As usual, typing the name of such an object at the console
invokes its <code>print</code> method.
</p>


<h3>Value</h3>

<p><code>data.frame</code>s whose columns are the <code>character</code> representation
of their respective <code><a href="#topic+summary.ClarkLDF">summary.ClarkLDF</a></code> 
or <code><a href="#topic+summary.ClarkCapeCod">summary.ClarkCapeCod</a></code> <code>data.frame</code>s.
</p>


<h3>Author(s)</h3>

<p>Daniel Murphy
</p>


<h3>References</h3>

<p>Clark, David R., 
&quot;LDF Curve-Fitting and Stochastic Reserving: A Maximum Likelihood Approach&quot;,
<em>Casualty Actuarial Society Forum</em>, Fall, 2003
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.ClarkLDF">summary.ClarkLDF</a></code> and <code><a href="#topic+summary.ClarkCapeCod">summary.ClarkCapeCod</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- GenIns
colnames(X) &lt;- 12*as.numeric(colnames(X))
y &lt;- ClarkCapeCod(X, Premium=10000000+400000*0:9, maxage=240)
summary(y) 
print(y)  # (or simply 'y') Same as summary(y) but with "pretty formats"

## Greater growth factors when projecting to infinite maximum age
ClarkCapeCod(X, Premium=10000000+400000*0:9, maxage=Inf)

</code></pre>

<hr>
<h2 id='print.cyEffTest'> Print function for a cyEffTest object </h2><span id='topic+print.cyEffTest'></span>

<h3>Description</h3>

<p><code>print</code> method for a <code>cyEffTest</code>
object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cyEffTest'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.cyEffTest_+3A_x">x</code></td>
<td>
<p>object of class <code>cyEffTest</code></p>
</td></tr>
<tr><td><code id="print.cyEffTest_+3A_...">...</code></td>
<td>
<p> optional arguments for a <code>print</code> method </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>print.cyEffTest</code> show the print of a <code>cyEffTest</code> object.
</p>


<h3>Value</h3>

<p><code>print.cyEffTest</code> displays the default information resulting from 
a call of the cyEffTest method
</p>


<h3>Author(s)</h3>

<p>Marco De Virgilis <a href="mailto:devirgilis.marco@gmail.com">devirgilis.marco@gmail.com</a></p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+cyEffTest">cyEffTest</a></code>,
<code><a href="#topic+plot.cyEffTest">plot.cyEffTest</a></code>,
<code><a href="#topic+summary.cyEffTest">summary.cyEffTest</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> test &lt;- cyEffTest(RAA)
 print(test)
</code></pre>

<hr>
<h2 id='print.dfCorTest'> Print function for a dfCorTest object </h2><span id='topic+print.dfCorTest'></span>

<h3>Description</h3>

<p><code>print</code> method for a <code>dfCorTest</code>
object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dfCorTest'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.dfCorTest_+3A_x">x</code></td>
<td>
<p>object of class <code>dfCorTest</code></p>
</td></tr>
<tr><td><code id="print.dfCorTest_+3A_...">...</code></td>
<td>
<p> optional arguments for a <code>print</code> method </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>print.dfCorTest</code> show the print of a <code>dfCorTest</code> object.
</p>


<h3>Value</h3>

<p><code>print.dfCorTest</code> displays the default information resulting from 
a call of the dfCorTest method
</p>


<h3>Author(s)</h3>

<p>Marco De Virgilis <a href="mailto:devirgilis.marco@gmail.com">devirgilis.marco@gmail.com</a></p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+dfCorTest">dfCorTest</a></code>,
<code><a href="#topic+plot.dfCorTest">plot.dfCorTest</a></code>,
<code><a href="#topic+summary.dfCorTest">summary.dfCorTest</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> test &lt;- dfCorTest(RAA)
 print(test)
</code></pre>

<hr>
<h2 id='qpaid'>Quarterly run off triangle of accumulated claims data</h2><span id='topic+qpaid'></span><span id='topic+qincurred'></span>

<h3>Description</h3>

<p>Sample data to demonstrate how to work with triangles with a higher development period frequency than origin period frequency</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(qpaid); data(qincurred)</code></pre>


<h3>Format</h3>

<p>A matrix with 12 accident years and 45 development quarters of claims costs.
</p>


<h3>Source</h3>

<p>Made up data for testing purpose</p>


<h3>Examples</h3>

<pre><code class='language-R'>dim(qpaid)
dim(qincurred)
op=par(mfrow=c(1,2))
ymax &lt;- max(c(qpaid,qincurred),na.rm=TRUE)*1.05
matplot(t(qpaid), type="l", main="Paid development", 
		  xlab="Dev. quarter", ylab="$", ylim=c(0,ymax))
matplot(t(qincurred), type="l", main="Incurred development", 
		      xlab="Dev. quarter", ylab="$", ylim=c(0,ymax))
par(op)
## MackChainLadder expects a quadratic matrix so let's expand 
## the triangle to a quarterly origin period.
n &lt;- ncol(qpaid)
Paid &lt;- matrix(NA, n, n)
Paid[seq(1,n,4),] &lt;- qpaid
M &lt;- MackChainLadder(Paid)
plot(M)

# We expand the incurred triangle in the same way 
Incurred &lt;- matrix(NA, n, n)
Incurred[seq(1,n,4),] &lt;- qincurred

# With the expanded triangles we can apply MunichChainLadder
MunichChainLadder(Paid, Incurred)

# In the same way we can apply BootChainLadder
# We reduce the size of bootstrap replicates R 
# from the default of 999 to 99 purely to reduce run time.
BootChainLadder(Paid, R=99) 

</code></pre>

<hr>
<h2 id='quantile.MackChainLadder'> quantile function for Mack-chain-ladder </h2><span id='topic+quantile.MackChainLadder'></span>

<h3>Description</h3>

<p><code>quantile</code> methods for a <code>MackChainLadder</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'MackChainLadder'
quantile(x, probs=c(0.75, 0.95), na.rm = FALSE,
              names = TRUE, type = 7,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile.MackChainLadder_+3A_x">x</code></td>
<td>
<p>object of class <code>"MackChainLadder"</code></p>
</td></tr>
<tr><td><code id="quantile.MackChainLadder_+3A_probs">probs</code></td>
<td>
<p>numeric vector of probabilities with values in [0,1],
see <code><a href="stats.html#topic+quantile">quantile</a></code> for more help</p>
</td></tr>
<tr><td><code id="quantile.MackChainLadder_+3A_na.rm">na.rm</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="quantile.MackChainLadder_+3A_names">names</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="quantile.MackChainLadder_+3A_type">type</code></td>
<td>
<p>not used</p>
</td></tr>         
<tr><td><code id="quantile.MackChainLadder_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Reserves at the desired quantile using the Cornish-Fisher expansion. 
</p>
<p>The Cornish-Fisher expansion relies on the first three moments of the reserve risk distribution: The Best estimate resulting from the Chain-Ladder projection, the Mack standard deviation and the skewness of the distribution (for skewness estimation, see references below).
</p>
<p>The quantile estimation requires only that the standard Mack assumptions are met.
</p>
<p>For details of the underlying calculations, see references below.
</p>


<h3>Value</h3>

<p><code>quantile.MackChainLadder</code> gives a list with two elements back:
</p>
<table>
<tr><td><code>ByOrigin</code></td>
<td>
<p>data frame with skewness and quantile statistics by
origin period</p>
</td></tr>
<tr><td><code>Totals</code></td>
<td>
<p>data frame with total skewness and quantile statistics
across all origin periods</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eric Dal Moro <a href="mailto:eric_dal_moro@yahoo.com">eric_dal_moro@yahoo.com</a></p>


<h3>References</h3>

<p><cite>Eric Dal Moro and Yuriy Krvavych.
Probability of sufficiency of Solvency II Reserve risk margins: Practical approximations. <em>ASTIN Bulletin</em>, 47(3), 737-785
</cite>
</p>
<p><cite>Dal Moro, Eric, A Closed-Form Formula for the Skewness Estimation of Non-Life Reserve Risk Distribution (September 15, 2013). Available at SSRN: https://ssrn.com/abstract=2344297 or https://dx.doi.org/10.2139/ssrn.2344297
</cite>
</p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+MackChainLadder">MackChainLadder</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- MackChainLadder(GenIns, est.sigma="Mack")
quantile(M, c(0.65, 0.75, 0.9))
</code></pre>

<hr>
<h2 id='QuantileIFRS17'>
Quantile estimation for the IFRS 17 Risk Adjustment
</h2><span id='topic+QuantileIFRS17'></span>

<h3>Description</h3>

<p>The Quantile IFRS 17 function provides an estimate of the quantile attained on the reserve risk distribution that corresponds to the booked Risk Adjustment plus the Best Estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QuantileIFRS17(MCL, Correlation, RiskMargin)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QuantileIFRS17_+3A_mcl">MCL</code></td>
<td>

<p>a list of <code>MackChainLadder</code> objects
</p>
</td></tr>
<tr><td><code id="QuantileIFRS17_+3A_correlation">Correlation</code></td>
<td>

<p>Correlation matrix depicting the correlations between each triangle imported. The correlation matrix is of dimension n x n, with n the number of items in the list of MackChainLadder objects. For correlation estimations between P&amp;C risks, please refer to the article of Arbenz et al. below.
</p>
</td></tr>
<tr><td><code id="QuantileIFRS17_+3A_riskmargin">RiskMargin</code></td>
<td>

<p>Input the risk margin as a single number. The risk margin corresponds to the IFRS 17 risk adjustment. It is estimated outside this function and can come from e.g. Solvency 2 standard formula. See International Actuarial Association reference below for details on risk adjustment calculations.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The IFRS 17 quantile is a mandatory disclosure when producing Financial Statements under the IFRS 17 framework: Such quantile reflects the Probability of Sufficiency of the reserves defined as Best Estimate plus Risk Adjustment i.e. the probability that the reserves will cover any negative deviations up to the disclosed quantile. 
</p>
<p>When a risk measure other than the quantile measure (Value At risk) is used for determining the Risk Adjustment, the quantile has to be estimated. The purpose of this function is to provide such an estimation on deriving the first three moments of the reserve risk distribution. These moments are estimated on the triangles input into the function. These triangles are projected using chain-ladder methods and the standard Best Estimate, Mack volatility and skewness are estimated. The resulting moments of the different triangles are then aggregated using Fleishman polynomials.  
</p>
<p>On using a Cornish-Fisher expansion based on the three aggregated moments, the Probability of Sufficiency of the reserves including the Risk Adjustment (given as an input to the function) can be easily derived.   
</p>


<h3>Value</h3>

<p>QuantileIFRS17 returns a vector with the following elements
</p>
<table>
<tr><td><code>QuantileIFRS_17</code></td>
<td>
<p>Quantile attained on the reserve risk distribution with the booked Risk Adjustment</p>
</td></tr>
<tr><td><code>Skewness</code></td>
<td>
<p>Skewness of the overall aggregated risk distribution across all triangles</p>
</td></tr>
<tr><td><code>CoV</code></td>
<td>
<p>Coefficient of Variation of the overall aggregated risk distribution across all triangles</p>
</td></tr>
<tr><td><code>Reserve</code></td>
<td>
<p>Sum of reserves of the input MackChainLadder objects</p>
</td></tr>

</table>


<h3>Note</h3>

<p>The use of Fleishman polynomials and Cornish-Fisher expansion imply that the different risks involved in the triangles inputs should be &quot;close to normality&quot;. If the risks involved in the input triangles are far from normal distributions (e.g. extreme events, nat cats ...), the proposed framework will not apply and the quantile derived from the function will not be relevant.   
</p>


<h3>Author(s)</h3>

<p>Eric Dal Moro, Yuriy Krvavych
</p>


<h3>References</h3>

<p><cite>Thomas Mack. Distribution-free calculation of the standard error of chain ladder reserve estimates. <em>Astin Bulletin</em>. Vol. 23. No 2. 1993. pp.213:225</cite>
</p>
<p><cite>Thomas Mack. The standard error of chain ladder reserve estimates: Recursive calculation and inclusion of a tail factor. <em>Astin Bulletin</em>. Vol. 29. No 2. 1999. pp.361:366</cite>
</p>
<p><cite>Dal Moro, Krvavych.
Probability of sufficiency of Solvency II Reserve risk margins: Practical approximations. <em>ASTIN Bulletin</em>, 47(3), 737-785
</cite>
</p>
<p><cite>P. Arbenz, D. Canestraro (2012) 
Estimating Copulas for Insurance from Scarce Observations, Expert Opinion and Prior Information: A Bayesian Approach, <em>Astin Bulletin</em>, vol. 42(1), pages 271-290.
</cite>
</p>
<p><cite>International Actuarial Association (2018)
Risk Adjustments for Insurance Contracts under IFRS 17
</cite>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+MackChainLadder">MackChainLadder</a></code>, 
<code><a href="#topic+quantile.MackChainLadder">quantile.MackChainLadder</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
QuantileIFRS17(MCL=list(M1=MackChainLadder(RAA, est.sigma = "Mack"), 
         M2=MackChainLadder(GenIns/1000, est.sigma = "Mack")), 
         Correlation=matrix(c(1,0.3, 0.3, 1), ncol=2), 
         RiskMargin = 20000)
</code></pre>

<hr>
<h2 id='RAA'>Run off triangle of accumulated claims data</h2><span id='topic+RAA'></span>

<h3>Description</h3>

<p>Run-off triangle of Automatic Factultative business in General Liability</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(RAA)</code></pre>


<h3>Format</h3>

<p>A matrix with 10 accident years and 10 development years.
</p>


<h3>Source</h3>

<p><cite>Historical Loss Development, <em>Reinsurance Association of Ammerica
(RAA)</em>, <b>1991</b>, p.96</cite>
</p>


<h3>References</h3>

<p>See Also: 
<cite>Which Stochastic Model is Underlying
the Chain Ladder Method?, Thomas Mack, <em>Insurance	
Mathematics and Economics</em>,  <b>15, 2/3</b>, pp133-138, 1994	</cite>
</p>
<p><cite>P.D.England and R.J.Verrall, Stochastic Claims Reserving in
General Insurance, <em>British Actuarial Journal</em>, <b>Vol. 8</b>,
pp443-544, 2002</cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RAA
plot(RAA)
plot(RAA, lattice=TRUE)
</code></pre>

<hr>
<h2 id='residCov'> Generic function for residCov and residCor</h2><span id='topic+residCov'></span><span id='topic+residCor'></span><span id='topic+residCov-methods'></span><span id='topic+residCor-methods'></span><span id='topic+residCov+2CMultiChainLadder-method'></span><span id='topic+residCor+2CMultiChainLadder-method'></span>

<h3>Description</h3>

<p><code>residCov</code> and  <code>residCov</code> are a generic functions to extract residual covariance and residual correlation from a system of fitted regressions respectively. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residCov(object,...)
residCor(object,...)

## S4 method for signature 'MultiChainLadder'
residCov(object,...)
## S4 method for signature 'MultiChainLadder'
residCor(object,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residCov_+3A_object">object</code></td>
<td>
<p>An object of class &quot;MultiChainLadder&quot;. </p>
</td></tr>
<tr><td><code id="residCov_+3A_...">...</code></td>
<td>
<p> Currently not used. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Wayne Zhang <a href="mailto:actuary_zhang@hotmail.com">actuary_zhang@hotmail.com</a> </p>


<h3>See Also</h3>

<p>See also  <code><a href="#topic+MultiChainLadder-class">MultiChainLadder</a></code>. </p>

<hr>
<h2 id='residuals.MackChainLadder'> Extract residuals of a MackChainLadder model </h2><span id='topic+residuals.MackChainLadder'></span>

<h3>Description</h3>

<p>Extract residuals of a <code><a href="#topic+MackChainLadder">MackChainLadder</a></code> model by 
origin-, calendar- and development period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MackChainLadder'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.MackChainLadder_+3A_object">object</code></td>
<td>
<p>output of <code><a href="#topic+MackChainLadder">MackChainLadder</a></code></p>
</td></tr>
<tr><td><code id="residuals.MackChainLadder_+3A_...">...</code></td>
<td>
<p>not in use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a <code>data.frame</code> of residuals and standardised residuals 
by origin-, calendar- and development period.
</p>


<h3>Author(s)</h3>

<p> Markus Gesmann </p>


<h3>See Also</h3>

<p> See Also <code><a href="#topic+MackChainLadder">MackChainLadder</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
 RAA
 MCL=MackChainLadder(RAA)
 MCL  

 residuals(MCL)

</code></pre>

<hr>
<h2 id='summary-methods'> Methods for Function summary</h2><span id='topic+summary-methods'></span><span id='topic+summary+2CMultiChainLadder-method'></span>

<h3>Description</h3>

<p>Methods for function <code>summary</code> to calculate summary statistics from a &quot;MultiChainLadder&quot; object. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S4 method for signature 'MultiChainLadder'
summary(object, portfolio=NULL,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary-methods_+3A_object">object</code></td>
<td>
<p>object of class <code>"MultiChainLadder"</code></p>
</td></tr>
<tr><td><code id="summary-methods_+3A_portfolio">portfolio</code></td>
<td>
<p>character strings specifying which triangles to be summed up as portfolio.  </p>
</td></tr>
<tr><td><code id="summary-methods_+3A_...">...</code></td>
<td>
<p> optional arguments to <code>summary</code> methods </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summary</code> calculations the summary statistics for each triangle and the whole portfolio from <code>portfolio</code>. <code>portfolio</code> defaults to the sum of all input triangles. It can also be specified as &quot;i+j&quot; format, which means the sum of the i-th and j-th triangle as portfolio. For example, <code>"1+3"</code> means the sum of the first and third triangle as portfolio.
</p>


<h3>Value</h3>

<p> The <code>summary</code> function returns an object of class &quot;MultiChainLadderSummary&quot; that has the following slots:
</p>
<table>
<tr><td><code>Triangles</code></td>
<td>
<p>input triangles</p>
</td></tr>
<tr><td><code>FullTriangles</code></td>
<td>
<p>predicted triangles</p>
</td></tr>
<tr><td><code>S.E.Full</code></td>
<td>
<p>a list of prediction errors for each cell</p>
</td></tr>
<tr><td><code>S.E.Est.Full</code></td>
<td>
<p>a list of estimation errors for each cell</p>
</td></tr>
<tr><td><code>S.E.Proc.Full</code></td>
<td>
<p>a list of process errors for each cell</p>
</td></tr>
<tr><td><code>Ultimate</code></td>
<td>
<p>predicted ultimate losses for each triangle and portfolio  </p>
</td></tr>
<tr><td><code>Latest</code></td>
<td>
<p> latest observed losses for each triangle and portfolio  </p>
</td></tr>
<tr><td><code>IBNR</code></td>
<td>
<p> predicted IBNR for each triangle and portfolio  </p>
</td></tr>
<tr><td><code>S.E.Ult</code></td>
<td>
<p> a matrix of prediction errors of ultimate losses for each triangle and portfolio  </p>
</td></tr>
<tr><td><code>S.E.Est.Ult</code></td>
<td>
<p> a matrix of estimation errors of ultimate losses for each triangle and portfolio  </p>
</td></tr>
<tr><td><code>S.E.Proc.Ult</code></td>
<td>
<p> a matrix of process errors of ultimate losses for each triangle and portfolio  </p>
</td></tr>
<tr><td><code>report.summary</code></td>
<td>
<p> summary statistics for each triangle and portfolio  </p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>estimated coefficients from <code>systemfit</code>. They are put into the matrix format for GMCL</p>
</td></tr>
<tr><td><code>coefCov</code></td>
<td>
<p>estimated variance-covariance matrix returned by <code>systemfit</code></p>
</td></tr>
<tr><td><code>residCov</code></td>
<td>
<p>estimated residual covariance matrix returned by <code>systemfit</code></p>
</td></tr>
<tr><td><code>rstandard</code></td>
<td>
<p> standardized residuals  </p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p> fitted.values  </p>
</td></tr>
<tr><td><code>residCor</code></td>
<td>
<p> residual correlation  </p>
</td></tr>
<tr><td><code>model.summary</code></td>
<td>
<p> summary statistics for the cofficients including p-values </p>
</td></tr>
<tr><td><code>portfolio</code></td>
<td>
<p>how portfolio is calculated</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Wayne Zhang <a href="mailto:actuary_zhang@hotmail.com">actuary_zhang@hotmail.com</a> </p>


<h3>See Also</h3>

<p> See Also <code><a href="#topic+MultiChainLadder">MultiChainLadder</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(GenIns)
fit.bbmw=MultiChainLadder(list(GenIns),fit.method="OLS", mse.method="Independence")
summary(fit.bbmw)

</code></pre>

<hr>
<h2 id='summary.ata'> Summary method for object of class 'ata' </h2><span id='topic+summary.ata'></span>

<h3>Description</h3>

<p>Summarize the age-to-age factors resulting from a 
call to the <code><a href="#topic+ata">ata</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ata'
summary(object, digits=3, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ata_+3A_object">object</code></td>
<td>
<p>object resulting from a call to <code><a href="#topic+ata">ata</a></code></p>
</td></tr>
<tr><td><code id="summary.ata_+3A_digits">digits</code></td>
<td>
<p>integer indicating the number of decimal places
for rounding the factors.
The default is 3.
<code>NULL</code> indicates that rounding should take place.
</p>
</td></tr>
<tr><td><code id="summary.ata_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A call to <code><a href="#topic+ata">ata</a></code> produces a matrix of age-to-age factors
with two attributes &ndash; 
the simple and volume weighted averages.
<code>summary.ata</code> creates a new matrix with the averages appended
as rows at the bottom.
</p>


<h3>Value</h3>

<p>A <code>matrix</code>.
</p>


<h3>Author(s)</h3>

<p> Dan Murphy </p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+ata">ata</a></code> and <code><a href="#topic+print.ata">print.ata</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- ata(RAA)
summary(y, digits=4)

</code></pre>

<hr>
<h2 id='summary.BootChainLadder'> Methods for BootChainLadder objects </h2><span id='topic+summary.BootChainLadder'></span><span id='topic+print.BootChainLadder'></span><span id='topic+quantile.BootChainLadder'></span><span id='topic+mean.BootChainLadder'></span><span id='topic+residuals.BootChainLadder'></span>

<h3>Description</h3>

<p><code>summary</code>, <code>print</code>, <code>mean</code>, and <code>quantile</code>
methods for <code>BootChainLadder</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'BootChainLadder'
summary(object, probs=c(0.75,0.95), ...)

## S3 method for class 'BootChainLadder'
print(x, probs=c(0.75,0.95), ...)

## S3 method for class 'BootChainLadder'
quantile(x, probs=c(0.75, 0.95), na.rm = FALSE,
              names = TRUE, type = 7,...)

## S3 method for class 'BootChainLadder'
mean(x, ...)

## S3 method for class 'BootChainLadder'
residuals(object, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.BootChainLadder_+3A_x">x</code>, <code id="summary.BootChainLadder_+3A_object">object</code></td>
<td>
<p>output from <code><a href="#topic+BootChainLadder">BootChainLadder</a></code></p>
</td></tr>
<tr><td><code id="summary.BootChainLadder_+3A_probs">probs</code></td>
<td>
<p>numeric vector of probabilities with values in [0,1],
see <code><a href="stats.html#topic+quantile">quantile</a></code> for more help</p>
</td></tr>
<tr><td><code id="summary.BootChainLadder_+3A_na.rm">na.rm</code></td>
<td>
<p>logical; if true, any <code>NA</code> and <code>NaN</code>'s are
removed from 'x' before the quantiles are computed,
see <code><a href="stats.html#topic+quantile">quantile</a></code> for more help</p>
</td></tr>
<tr><td><code id="summary.BootChainLadder_+3A_names">names</code></td>
<td>
<p>logical; if true, the result has a <code>names</code>
attribute. Set to <code>FALSE</code> for speedup with many 'probs',
see <code><a href="stats.html#topic+quantile">quantile</a></code> for more help</p>
</td></tr>
<tr><td><code id="summary.BootChainLadder_+3A_type">type</code></td>
<td>
<p>an integer between 1 and 9 selecting one of the nine quantile
algorithms detailed below to be used, see <code><a href="stats.html#topic+quantile">quantile</a></code></p>
</td></tr>         
<tr><td><code id="summary.BootChainLadder_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>print.BootChainLadder</code> calls <code>summary.BootChainLadder</code> and
prints a formatted version of the summary.
<code>residuals.BootChainLadder</code> gives the residual triangle of
the expected chain-ladder minus the actual triangle back.
</p>


<h3>Value</h3>

<p><code>summary.BootChainLadder</code>, <code>mean.BootChainLadder</code>, and
<code>quantile.BootChainLadder</code>, give a list with two elements back:
</p>
<table>
<tr><td><code>ByOrigin</code></td>
<td>
<p>data frame with summary/mean/quantile statistics by
origin period</p>
</td></tr>
<tr><td><code>Totals</code></td>
<td>
<p>data frame with total summary/mean/quantile statistics
for all origin period</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Markus Gesmann </p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+BootChainLadder">BootChainLadder</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>B &lt;- BootChainLadder(RAA, R=999, process.distr="gamma")
B
summary(B)
mean(B)
quantile(B, c(0.75,0.95,0.99, 0.995))

</code></pre>

<hr>
<h2 id='summary.checkTriangleInflation'> Summary function for a checkTriangleInflation object </h2><span id='topic+summary.checkTriangleInflation'></span>

<h3>Description</h3>

<p><code>summary</code> method for a <code>checkTriangleInflation</code>
object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'checkTriangleInflation'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.checkTriangleInflation_+3A_object">object</code></td>
<td>
<p>object of class <code>checkTriangleInflation</code></p>
</td></tr>
<tr><td><code id="summary.checkTriangleInflation_+3A_...">...</code></td>
<td>
<p> optional arguments for a <code>summary</code> method </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summary.checkTriangleInflation</code> shows the summary of a <code>checkTriangleInflation</code> object.
</p>


<h3>Value</h3>

<p><code>summary.checkTriangleInflation</code> gives a named numeric array of three rows.
</p>
<table>
<tr><td><code>rate</code></td>
<td>
<p>Inflation rate for the specific development period</p>
</td></tr>
<tr><td><code>R2</code></td>
<td>
<p><code class="reqn">R^2</code> coefficient for each regression curve</p>
</td></tr>
<tr><td><code>points</code></td>
<td>
<p>Number of points used</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco De Virgilis <a href="mailto:devirgilis.marco@gmail.com">devirgilis.marco@gmail.com</a></p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+checkTriangleInflation">checkTriangleInflation</a></code>,
<code><a href="#topic+plot.checkTriangleInflation">plot.checkTriangleInflation</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> test &lt;- checkTriangleInflation( MedMal$MedMalOutstanding / MedMal$MedMalOpen )
 summary(test)
</code></pre>

<hr>
<h2 id='summary.clark'> Summary methods for Clark objects </h2><span id='topic+summary.ClarkLDF'></span><span id='topic+summary.ClarkCapeCod'></span>

<h3>Description</h3>

<p><code>summary</code> 
methods for <code>ClarkLDF</code> and <code>ClarkCapeCod</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ClarkLDF'
summary(object, ...)

## S3 method for class 'ClarkCapeCod'
summary(object, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.clark_+3A_object">object</code></td>
<td>
<p>object resulting from a run of the <code><a href="#topic+ClarkLDF">ClarkLDF</a></code> 
or <code><a href="#topic+ClarkCapeCod">ClarkCapeCod</a></code> functions.
</p>
</td></tr>
<tr><td><code id="summary.clark_+3A_...">...</code></td>
<td>
<p>not currently used</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summary.ClarkLDF</code> returns a <code>data.frame</code> that holds the columns of a
typical &quot;Development-type&quot; exhibit.
</p>
<p><code>summary.ClarkCapeCod</code> returns a <code>data.frame</code> that holds the columns of a
typical &quot;Bornhuetter-Ferguson-type&quot; exhibit.
</p>


<h3>Value</h3>

<p><code>summary.ClarkLDF</code> and <code>summary.ClarkCapeCod</code> return 
<code>data.frame</code>s whose columns are objects of the appropriate <code>mode</code>
(i.e., <code>character</code> for &quot;Origin&quot;, otherwise <code>numeric</code>)
</p>


<h3>Author(s)</h3>

<p> Dan Murphy </p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+ClarkLDF">ClarkLDF</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- ClarkLDF(RAA)
summary(y)

</code></pre>

<hr>
<h2 id='summary.cyEffTest'> Summary function for a cyEffTest object </h2><span id='topic+summary.cyEffTest'></span>

<h3>Description</h3>

<p><code>summary</code> method for a <code>cyEffTest</code>
object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cyEffTest'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.cyEffTest_+3A_object">object</code></td>
<td>
<p>object of class <code>cyEffTest</code></p>
</td></tr>
<tr><td><code id="summary.cyEffTest_+3A_...">...</code></td>
<td>
<p> optional arguments for a <code>summary</code> method </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summary.cyEffTest</code> shows the summary of a <code>cyEffTest</code> object.
</p>


<h3>Value</h3>

<p><code>summary.cyEffTest</code> gives a list of three elements back
</p>
<table>
<tr><td><code>Table</code></td>
<td>
<p>data frame containing the statistics for each calendar year</p>
</td></tr>
<tr><td><code>Totals</code></td>
<td>
<p>data frame of totals of the main statistics from the dataframe <code>Table</code></p>
</td></tr>
<tr><td><code>Range</code></td>
<td>
<p>data frame containing the upper and lower limits of the confidence interval range</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco De Virgilis <a href="mailto:devirgilis.marco@gmail.com">devirgilis.marco@gmail.com</a></p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+cyEffTest">cyEffTest</a></code>,
<code><a href="#topic+plot.cyEffTest">plot.cyEffTest</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> test &lt;- cyEffTest(RAA)
 summary(test)
</code></pre>

<hr>
<h2 id='summary.dfCorTest'> Summary function for a dfCorTest object </h2><span id='topic+summary.dfCorTest'></span>

<h3>Description</h3>

<p><code>summary</code> method for a <code>dfCorTest</code>
object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dfCorTest'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.dfCorTest_+3A_object">object</code></td>
<td>
<p>object of class <code>dfCorTest</code></p>
</td></tr>
<tr><td><code id="summary.dfCorTest_+3A_...">...</code></td>
<td>
<p> optional arguments for a <code>summary</code> method </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summary.dfCorTest</code> shows the summary of a <code>dfCorTest</code> object.
</p>


<h3>Value</h3>

<p><code>summary.dfCorTest</code> gives a list of two elements back
</p>
<table>
<tr><td><code>Results</code></td>
<td>
<p>data frame containing the summary statistics</p>
</td></tr>
<tr><td><code>Range</code></td>
<td>
<p>data frame containing the upper and lower limits of the confidence interval range</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco De Virgilis <a href="mailto:devirgilis.marco@gmail.com">devirgilis.marco@gmail.com</a></p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+dfCorTest">dfCorTest</a></code>,
<code><a href="#topic+plot.dfCorTest">plot.dfCorTest</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> test &lt;- dfCorTest(RAA)
 summary(test)
</code></pre>

<hr>
<h2 id='summary.MackChainLadder'> Summary and print function for Mack-chain-ladder </h2><span id='topic+summary.MackChainLadder'></span><span id='topic+print.MackChainLadder'></span>

<h3>Description</h3>

<p><code>summary</code> and <code>print</code> methods for a <code>MackChainLadder</code>
object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'MackChainLadder'
summary(object, ...)

## S3 method for class 'MackChainLadder'
print(x, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.MackChainLadder_+3A_x">x</code>, <code id="summary.MackChainLadder_+3A_object">object</code></td>
<td>
<p>object of class <code>"MackChainLadder"</code></p>
</td></tr>
<tr><td><code id="summary.MackChainLadder_+3A_...">...</code></td>
<td>
<p> optional arguments to <code>print</code> or <code>summary</code> methods </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>print.MackChainLadder</code> calls <code>summary.MackChainLadder</code> and
prints a formatted version of the summary.
</p>


<h3>Value</h3>

<p><code>summary.MackChainLadder</code> gives a list of two elements back
</p>
<table>
<tr><td><code>ByOrigin</code></td>
<td>
<p>data frame with <code>Latest</code> (latest actual claims costs),
<code>Dev.To.Date</code> (chain-ladder development to date),
<code>Ultimate</code> (estimated ultimate claims cost), <code>IBNR</code>
(estimated IBNR), <code>Mack.S.E</code> (Mack's estimation of the standard
error of the IBNR), and <code>CV(IBNR)</code> (Coefficient of Variance=Mack.S.E/IBNR)</p>
</td></tr>
<tr><td><code>Totals</code></td>
<td>
<p>data frame of totals over all origin periods. The items
follow the same naming convention as in <code>ByOrigin</code> above</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Markus Gesmann </p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+MackChainLadder">MackChainLadder</a></code>,
<code><a href="#topic+plot.MackChainLadder">plot.MackChainLadder</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> R &lt;- MackChainLadder(RAA)
 R
 summary(R)
 summary(R)$ByOrigin$Ultimate
</code></pre>

<hr>
<h2 id='summary.MunichChainLadder'> Summary and print function for Munich-chain-ladder</h2><span id='topic+summary.MunichChainLadder'></span><span id='topic+print.MunichChainLadder'></span>

<h3>Description</h3>

<p><code>summary</code> and <code>print</code> methods for a <code>MunichChainLadder</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MunichChainLadder'
summary(object, ...)

## S3 method for class 'MunichChainLadder'
print(x, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.MunichChainLadder_+3A_x">x</code>, <code id="summary.MunichChainLadder_+3A_object">object</code></td>
<td>
<p>object of class <code>"MunichChainLadder"</code></p>
</td></tr>
<tr><td><code id="summary.MunichChainLadder_+3A_...">...</code></td>
<td>
<p> optional arguments to <code>print</code> or <code>summary</code> methods </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>print.MunichChainLadder</code> calls <code>summary.MunichChainLadder</code> and
prints a formatted version of the summary.
</p>


<h3>Value</h3>

<p><code>summary.MunichChainLadder</code> gives a list of two elements back
</p>
<table>
<tr><td><code>ByOrigin</code></td>
<td>
<p>data frame with <em>Latest Paid</em> (latest actual paid
claims costs), <em>Latest Incurred</em> (latest actual incurred
claims position), <em>Latest P/I Ratio</em> (ratio of latest
paid/incurred claims), <em>Ult. Paid</em> (estimate ultimate claims
cost based on the paid triangle), <em>Ult. Incurred</em> (estimate
ultimate claims cost based on the incurred triangle),<em>Ult. P/I
Ratio</em> (ratio of ultimate paid forecast / ultimate incurred forecast)
</p>
</td></tr>
<tr><td><code>Totals</code></td>
<td>
<p>data frame of totals over all origin periods. The items
follow the same naming convention as in <code>ByOrigin</code> above
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Markus Gesmann </p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+MunichChainLadder">MunichChainLadder</a></code>,
<code><a href="#topic+plot.MunichChainLadder">plot.MunichChainLadder</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- MunichChainLadder(MCLpaid, MCLincurred)
M
summary(M)
summary(M)$ByOrigin
</code></pre>

<hr>
<h2 id='Table65'>
Functions to Reproduce Clark's Tables
</h2><span id='topic+Table65'></span><span id='topic+Table64'></span><span id='topic+Table68'></span>

<h3>Description</h3>

<p>Print the tables on pages 64, 65, and 68 of Clark's paper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Table64(x)
Table65(x)
Table68(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Table65_+3A_x">x</code></td>
<td>
<p>an object resulting from <code>ClarkLDF</code> or <code>ClarkCapeCod</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>These exhibits give some of the details behind the calculations producing
the estimates of future values (a.k.a. &quot;Reserves&quot; in Clark's paper).
Table65 works for both the &quot;LDF&quot; and the &quot;CapeCod&quot; methods.
Table64 is specific to &quot;LDF&quot;, Table68 to &quot;CapeCod&quot;.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code>. 
</p>


<h3>Author(s)</h3>

<p>Daniel Murphy
</p>


<h3>References</h3>

<p>Clark, David R., 
&quot;LDF Curve-Fitting and Stochastic Reserving: A Maximum Likelihood Approach&quot;,
<em>Casualty Actuarial Society Forum</em>, Fall, 2003
<a href="https://www.casact.org/sites/default/files/database/forum_03fforum_03ff041.pdf">https://www.casact.org/sites/default/files/database/forum_03fforum_03ff041.pdf</a> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Table65(ClarkLDF(GenIns, maxage=20))
Table64(ClarkLDF(GenIns, maxage=20))

X &lt;- GenIns
colnames(X) &lt;- 12*as.numeric(colnames(X))
Table65(ClarkCapeCod(X, Premium=10000000+400000*0:9, maxage=Inf))
Table68(ClarkCapeCod(X, Premium=10000000+400000*0:9, maxage=Inf))

</code></pre>

<hr>
<h2 id='triangle+20S3+20Methods'>
Generic functions for triangles
</h2><span id='topic+triangle'></span><span id='topic+plot.triangle'></span><span id='topic+as.data.frame.triangle'></span><span id='topic+as.triangle'></span><span id='topic+as.triangle.data.frame'></span><span id='topic+as.triangle.matrix'></span>

<h3>Description</h3>

<p>Functions to ease the work with triangle shaped matrix data. A
'triangle' is a matrix with some generic functions.
</p>
<p><code>triangle</code> creates a triangle from the given set of vectors of
observed data.
</p>
<p><code>as.triangle</code> attempts to turn its argument into a triangle.
Triangles are usually stored in a &ldquo;long&rdquo; format in data bases. The
function can transform a <code>data.frame</code> into a triangle shape.
</p>
<p><code>as.data.frame</code> turns a triangle into a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triangle(..., bycol=FALSE, origin="origin", dev="dev", value="value")

## S3 method for class 'matrix'
as.triangle(Triangle, origin="origin", dev="dev", value="value", ...)
## S3 method for class 'data.frame'
as.triangle(Triangle, origin="origin", dev="dev", value="value", ...)
## S3 method for class 'triangle'
as.data.frame(x, row.names=NULL, optional, lob=NULL, na.rm=FALSE, ...)
as.triangle(Triangle, origin="origin", dev="dev", value="value", ...)
## S3 method for class 'triangle'
plot(x, type = "b", xlab = "dev. period", ylab = NULL, lattice=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="triangle+2B20S3+2B20Methods_+3A_triangle">Triangle</code></td>
<td>
<p>a triangle</p>
</td></tr>
<tr><td><code id="triangle+2B20S3+2B20Methods_+3A_bycol">bycol</code></td>
<td>
<p>logical. If <code>FALSE</code> (the default) the triangle is filled by
rows, otherwise the triangle is filled by columns.</p>
</td></tr>
<tr><td><code id="triangle+2B20S3+2B20Methods_+3A_origin">origin</code></td>
<td>
<p>name of the origin period, default is <code>"origin"</code>.</p>
</td></tr>
<tr><td><code id="triangle+2B20S3+2B20Methods_+3A_dev">dev</code></td>
<td>
<p>name of the development period, default is <code>"dev"</code>.</p>
</td></tr>
<tr><td><code id="triangle+2B20S3+2B20Methods_+3A_value">value</code></td>
<td>
<p>name of the value, default is <code>"value"</code>.</p>
</td></tr>
<tr><td><code id="triangle+2B20S3+2B20Methods_+3A_row.names">row.names</code></td>
<td>
<p>default is set to <code>NULL</code> and will merge origin
and dev. period to create row names.</p>
</td></tr>
<tr><td><code id="triangle+2B20S3+2B20Methods_+3A_lob">lob</code></td>
<td>
<p>default is <code>NULL</code>. The idea is to use <code>lob</code> (line
of business) as an additional column to label a triangle in a long format, see the
examples for more details.</p>
</td></tr>
<tr><td><code id="triangle+2B20S3+2B20Methods_+3A_optional">optional</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="triangle+2B20S3+2B20Methods_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Remove missing values?</p>
</td></tr>
<tr><td><code id="triangle+2B20S3+2B20Methods_+3A_x">x</code></td>
<td>
<p>a matrix of class 'triangle'</p>
</td></tr>



<tr><td><code id="triangle+2B20S3+2B20Methods_+3A_xlab">xlab</code></td>
<td>
<p>a label for the x axis, defaults to 'dev. period'</p>
</td></tr>
<tr><td><code id="triangle+2B20S3+2B20Methods_+3A_ylab">ylab</code></td>
<td>
<p>a label for the y axis, defaults to NULL</p>
</td></tr>
<tr><td><code id="triangle+2B20S3+2B20Methods_+3A_lattice">lattice</code></td>
<td>
<p>logical. If <code>FALSE</code> the function
<code><a href="graphics.html#topic+matplot">matplot</a></code> is used to plot the developments of the
triangle in one graph, otherwise the <code><a href="lattice.html#topic+xyplot">xyplot</a></code> function
of the lattice package is used, to plot developments of each origin
period in a different panel.</p>
</td></tr>
<tr><td><code id="triangle+2B20S3+2B20Methods_+3A_type">type</code></td>
<td>
<p>type, see <code><a href="graphics.html#topic+plot.default">plot.default</a></code></p>
</td></tr>
<tr><td><code id="triangle+2B20S3+2B20Methods_+3A_...">...</code></td>
<td>
<p>vectors of data in <code>triangle</code>, see details;
arguments to be passed to other methods everywhere else.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>triangle</code> builds a triangle matrix from the vectors of
<em>known</em> data provided in <code>...</code>. Normally, each of these
vectors should be one shorter than the preceeding one. The length of
the first vector dictates the number of development periods or origin
periods (respectively when <code>bycol</code> is <code>FALSE</code> or
<code>TRUE</code>). As a special case, the function will build an <code class="reqn">n
    \times n</code> triangle from a single vector of <code class="reqn">n(n + 1)/2</code> data
points.
</p>
<p>The names of the arguments in <code>...</code> for function
<code>triangle</code> (when there are more than one) are retained for
row/column names. Similarly, the names of the elements of the
<em>first</em> argument are used as column/row names.
</p>


<h3>Warning</h3>

<p>Please note that for the function <code>as.triangle</code> the origin and
dev. period columns have to be of type numeric or a character which can be
converted into numeric.
</p>
<p>Also note that when converting from a data.frame to a matrix with 
<code>as.triangle</code>, multiple records with the same <code>origin</code> and 
<code>dev</code> will be aggregated.
</p>


<h3>Author(s)</h3>

<p>Markus Gesmann, Dan Murphy, Vincent Goulet
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GenIns
plot(GenIns)
plot(GenIns, lattice=TRUE)


## Convert long format into triangle
## Triangles are usually stored as 'long' tables in data bases
head(GenInsLong)
as.triangle(GenInsLong, origin="accyear", dev="devyear", "incurred claims")

X &lt;- as.data.frame(RAA)
head(X)

Y &lt;- as.data.frame(RAA, lob="General Liability")
head(Y)

## Basic creation of a triangle from loss development data
triangle(c(100, 150, 175, 180, 200),
         c(110, 168, 192, 205),
         c(115, 169, 202),
         c(125, 185),
         150)

## Same, with named origin periods
triangle("2012" = c(100, 150, 175, 180, 200),
         "2013" = c(110, 168, 192, 205),
         "2014" = c(115, 169, 202),
         "2015" = c(125, 185),
         "2016" = 150)

## Again, with also named development periods
triangle("2012" = c("12 months" = 100,
                    "24 months" = 150,
                    "36 months" = 175,
                    "48 months" = 180,
                    "60 months" = 200),
         "2013" = c(110, 168, 192, 205),
         "2014" = c(115, 169, 202),
         "2015" = c(125, 185),
         "2016" = 150)

## Quick, simplified usage
triangle(c(100, 150, 175, 110, 168, 115))
</code></pre>

<hr>
<h2 id='triangles-class'>S4 Class &quot;triangles&quot;  </h2><span id='topic+triangles-class'></span><span id='topic++5B+2Ctriangles+2Cmissing+2Cnumeric+2Clogical-method'></span><span id='topic++5B+2Ctriangles+2Cmissing+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+2Ctriangles+2Cnumeric+2Cmissing+2Clogical-method'></span><span id='topic++5B+2Ctriangles+2Cnumeric+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2Ctriangles+2Cnumeric+2Cnumeric+2Cmissing-method'></span><span id='topic++5B+3C-+2Ctriangles+2Cnumeric+2Cnumeric+2Clist-method'></span><span id='topic+coerce+2Clist+2Ctriangles-method'></span><span id='topic+dim+2Ctriangles-method'></span><span id='topic+cbind2+2Ctriangles+2Cmissing-method'></span><span id='topic+rbind2+2Ctriangles+2Cmissing-method'></span>

<h3>Description</h3>

<p>This is a S4 class that has &quot;list&quot; in the data part. This class is created to facilitate validation and extraction of data. </p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("triangles", ...)</code>, or use <code>as(...,"triangles")</code>, where <code>...</code> is a &quot;list&quot;.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p>Object of class <code>"list"</code> </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="methods.html#topic+list-class">list</a>"</code>, from data part.
Class <code>"<a href="methods.html#topic+vector-class">vector</a>"</code>, by class &quot;list&quot;, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>Mse</dt><dd><p><code>signature(ModelFit = "GMCLFit", FullTriangles = "triangles")</code>: See <code><a href="#topic+Mse">Mse</a></code> </p>
</dd>
<dt>Mse</dt><dd><p><code>signature(ModelFit = "MCLFit", FullTriangles = "triangles")</code>:  See <code><a href="#topic+Mse">Mse</a></code> </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "triangles", i = "missing", j = "numeric", drop = "logical")</code>: Method for primitive function &quot;[&quot; to subset certain columns. If <code>drop=TRUE</code>, rows composed of all &quot;NA&quot;s are removed. Dimensions are not dropped. </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "triangles", i = "missing", j = "numeric", drop = "missing")</code>: Method for primitive function &quot;[&quot; to subset certain columns, where rows composed of all &quot;NA&quot;s are removed. Dimensions are not dropped. </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "triangles", i = "numeric", j = "missing", drop = "logical")</code>: Method for primitive function &quot;[&quot; to subset certain rows. If <code>drop=TRUE</code>, columns composed of all &quot;NA&quot;s are removed. Dimensions are not dropped. </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "triangles",  i = "numeric", j = "missing", drop = "missing")</code>: Method for primitive function &quot;[&quot; to subset certain rows, where columns composed of all &quot;NA&quot;s are removed. Dimensions are not dropped. </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "triangles", i = "numeric", j = "numeric", drop = "missing")</code>: Method for primitive function &quot;[&quot; to subset certain rows and columns. Dimensions are not dropped. </p>
</dd>
<dt>[&lt;-</dt><dd><p><code>signature(x = "triangles", i = "numeric", j = "numeric", value = "list")</code>: Method for primitive function &quot;[&lt;-&quot; to replace one cell in each triangle  with values specified in <code>value</code>.  </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "list", to = "triangles")</code>: Method to construct a &quot;triangles&quot; object from &quot;list&quot;. </p>
</dd>
<dt>dim</dt><dd><p><code>signature(x = "triangles")</code>: Method to get the dimensions. The return value is a vector of length 3, where the first element is the number of triangles, the sencond is the number of accident years, and the third is the number of development years. </p>
</dd>
<dt>cbind2</dt><dd><p><code>signature(x = "triangles", y="missing")</code>: Method to column bind all triangles using <code>cbind</code> internally.  </p>
</dd>
<dt>rbind2</dt><dd><p><code>signature(x = "triangles", y="missing")</code>:  Method to row bind all triangles using <code>rbind</code> internally.  </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Wayne Zhang <a href="mailto:actuary_zhang@hotmail.com">actuary_zhang@hotmail.com</a></p>


<h3>See Also</h3>

<p> See also <code><a href="#topic+MultiChainLadder">MultiChainLadder</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(auto)

# "coerce"
auto &lt;- as(auto,"triangles")  # transform "list" to be "triangles"

# method for "["
auto[,4:6,drop=FALSE] # rows of all NA's not dropped
auto[,4:6]			# drop rows of all NA's

auto[8:10, ,drop=FALSE] #columns of all NA's not dropped
auto[8:10, ] 			#columns of all NA's  dropped

auto[1:2,1]

# replacement method
auto[1:2,1] &lt;- list(1,2,3)
auto[1,2]
   
dim(auto)

cbind2(auto[1:2,1])
rbind2(auto[1:2,1])
</code></pre>

<hr>
<h2 id='tweedieReserve'>
Tweedie Stochastic Reserving Model
</h2><span id='topic+tweedieReserve'></span>

<h3>Description</h3>

<p>This function implements loss reserving models within the generalized
linear model framework in order to generate the full predictive 
distribution for loss reserves. Besides, it generates also the one year 
risk view useful to derive the reserve risk capital in a Solvency II 
framework. Finally, it allows the user to validate the model error while changing different model parameters, as the regression structure and diagnostics on the Tweedie p parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tweedieReserve(triangle, var.power = 1, 
                    link.power = 0, design.type = c(1, 1, 0), 
                    rereserving = FALSE, cum = TRUE, exposure = FALSE, 
                    bootstrap = 1, boot.adj = 0, nsim = 1000, 
                    proc.err = TRUE, p.optim = FALSE,
                    p.check = c(0, seq(1.1, 2.1, by = 0.1), 3),
                    progressBar = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tweedieReserve_+3A_triangle">triangle</code></td>
<td>

<p>An object of class <code><a href="#topic+triangle">triangle</a></code>.
</p>
</td></tr>
<tr><td><code id="tweedieReserve_+3A_var.power">var.power</code></td>
<td>

<p>The index (p) of the power variance function <code class="reqn">V(\mu)=\mu^p</code>. 
Default to <code>p = 1</code>, which is the over-dispersed Poisson model. 
If <code>NULL</code>, it will be assumed to be in <code>(1, 2)</code> and 
estimated using the <code>cplm</code> package.  
See <code><a href="statmod.html#topic+tweedie">tweedie</a></code>.
</p>
</td></tr>
<tr><td><code id="tweedieReserve_+3A_link.power">link.power</code></td>
<td>

<p>The index of power link function. The default <code>link.power = 0</code> 
produces a log link. See <code><a href="statmod.html#topic+tweedie">tweedie</a></code>.
</p>
</td></tr>
<tr><td><code id="tweedieReserve_+3A_design.type">design.type</code></td>
<td>

<p>It's a 3 dimension array that specifies the design matrix underlying 
the GLM. The dimensions represent respectively: origin period, 
development and calendar period. Accepted values are: <code>0</code> (not   
modelled), <code>1</code> (modelled as factor) and <code>2</code> (modelled as 
variable). Default to <code>c(1,1,0)</code>, which is the common 
specification in actuarial literature (origin and development period 
as factors, calendar period not modelled). If a parameter for the calendar period is specified,       a linear regression on the log CY parameter is fitted to estimate future values, thus is recommended to validate them running a plot of the gamma values (see output <code>gamma_y</code>) . 
</p>
</td></tr>
<tr><td><code id="tweedieReserve_+3A_rereserving">rereserving</code></td>
<td>

<p>Boolean, if <code>TRUE</code> the one year risk view loss reserve 
distribution is derived. Default to <code>FALSE</code>. Note, the runtime 
can materially increase if set to <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="tweedieReserve_+3A_cum">cum</code></td>
<td>

<p>Boolean, indicating whether the input triangle is
cumulative or incremental along the development period. 
If <code>TRUE</code>, then
<code>triangle</code> is assumed to be on the cumulative scale, and it will
be converted to incremental losses internally before a GLM is fitted. 
</p>
</td></tr>
<tr><td><code id="tweedieReserve_+3A_exposure">exposure</code></td>
<td>

<p>Boolean, if <code>TRUE</code> the <code>exposure</code> defined in the 
<code><a href="#topic+triangle">triangle</a></code> object is specified as <code>offset</code> in the GLM 
model specification. Default to <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="tweedieReserve_+3A_bootstrap">bootstrap</code></td>
<td>

<p>Integer, it specifies the type of bootstrap for parameter error.
Accepted values are: <code>0</code> (disabled), <code>1</code> (parametric), 
<code>2</code> (semi-parametric). Default to <code>1</code>.
</p>
</td></tr>
<tr><td><code id="tweedieReserve_+3A_boot.adj">boot.adj</code></td>
<td>

<p>Integer, it specified the methodology when using semi-parametric 
bootstrapping. Accepted values are: <code>0</code> (cycles until all the 
values of the pseudo-triangle are &gt;= 0), <code>1</code> (overwrite negative 
values to 0.01). Default to <code>0</code>. Note, runtime can materially 
increase when set to  <code>0</code>, as it could struggle to find pseudo-triangles &gt;= 0)
</p>
</td></tr>
<tr><td><code id="tweedieReserve_+3A_nsim">nsim</code></td>
<td>

<p>Integer, number of simulations to derive the loss reserve distribution.   
Default to <code>1000</code>. Note, high num of simulations could materially 
increase runtime, in particular if a re-reserving algorithm is used 
as well.
</p>
</td></tr>
<tr><td><code id="tweedieReserve_+3A_proc.err">proc.err</code></td>
<td>

<p>Boolean, if <code>TRUE</code> a process error (coherent with the specified 
model) is added to the forecasted distribution. Default to <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="tweedieReserve_+3A_p.optim">p.optim</code></td>
<td>

<p>Boolean, if <code>TRUE</code> the model estimates the MLE for the Tweedie's 
<code>p</code> parameter. Default to <code>FALSE</code>. Recommended to use to validate the Tweedie's     <code>p</code> parameter.
</p>
</td></tr>
<tr><td><code id="tweedieReserve_+3A_p.check">p.check</code></td>
<td>

<p>If <code>p.optim=TRUE</code>, a vector of <code>p</code> values for consideration. The values must all be larger than one (if the response variable has exact zeros, the values must all be between one and two). Default to <code>c(0,seq(1.1,2.1,by=0.1),3)</code>. As fitting the Tweedie p-value isn't a straightforward process, please refer to <code>tweedie.profile</code>, <code>p.vec</code> argument.
</p>
</td></tr>
<tr><td><code id="tweedieReserve_+3A_progressbar">progressBar</code></td>
<td>

<p>Boolean, if <code>TRUE</code> a progress bar will be shown in the console to 
give an indication of bootstrap progress.
</p>
</td></tr>
<tr><td><code id="tweedieReserve_+3A_...">...</code></td>
<td>

<p>Arguments to be passed onto the function <code><a href="stats.html#topic+glm">glm</a></code> or 
<code>cpglm</code> such as <code>contrasts</code> or <code>control</code>. It is 
important that <code>offset</code> and <code>weight</code> should not be specified. 
Otherwise, an error will be reported and the program will quit.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output is an object of class <code>"glm"</code> that has the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>summary</code></td>
<td>
<p>A data frame containing the predicted loss reserve 
statistics. The following items are displayed: 
</p>

<ul>
<li> <p><code>Latest</code>: Latest paid
</p>
</li>
<li> <p><code>Det.Reserve</code>: Deterministic reserve, i.e. the MLE GLM 
estimate of the Reserve
</p>
</li>
<li> <p><code>Ultimate</code>: Ultimate cost, defined as 
<code>Latest+Det.Reserve</code>
</p>
</li>
<li> <p><code>Dev.To.Date</code>: Development to date, defined as 
<code>Latest/Ultimate</code>
</p>
</li></ul>

<p>The following items are available if <code>bootstrap&gt;0</code>
</p>

<ul>
<li> <p><code>Expected.Reserve</code>: The expected reserve, defined as 
the average of the reserve simulations. 
Should be roughly as <code>Det.Reserve</code>.
</p>
</li>
<li> <p><code>Prediction.Error</code>: The prediction error of the reserve, 
defined as sqrt of the simulations. Please note that if 
<code>proc.err=FALSE</code>, this field contains only the parameter 
error given by the bootstrap.
</p>
</li>
<li> <p><code>CoV</code>: Coefficient of Variation, defined as 
<code>Prediction. Error/Expected.Reserve</code>.
</p>
</li>
<li> <p><code>Expected Ultimate</code>: The expected ultimate, defined as 
<code>Expected.Reserve+Latest</code>.
</p>
</li></ul>

<p>The following items are availbale if <code>bootstrap&gt;0 &amp; reserving=TRUE</code>
</p>

<ul>
<li> <p><code>Expected.Reserve_1yr</code>: The reserve derived as sum of 
next year payment and the expected value of the re-reserve at the 
end of the year. It should be similar to both 
<code>Expected.Reserve</code> and <code>Det.Reserve</code>. If it isn't, it's 
recommended to change regression structure and parameters.
</p>
</li>
<li> <p><code>Prediction.Error_1yr</code>: The prediction error of the 
prospective Claims Development Result (CDR), as defined by 
Wüthrich (CDR=R(0)-X-R(1)). 
</p>
</li>
<li> <p><code>Emergence.Pattern</code>: It's the emergence pattern defined 
as <code>Prediction.Error_1yr/Prediction.Error</code>.
</p>
</li></ul>

</td></tr>
<tr><td><code>Triangle</code></td>
<td>
<p>The input triangle.</p>
</td></tr>
<tr><td><code>FullTriangle</code></td>
<td>
<p>The completed triangle, where empty cells in the 
original triangle are filled with model predictions.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>The fitted GLM, a class of <code>glm</code> or <code>cpglm</code>. 
It is most convenient to work with this component when model fit 
information is wanted. </p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>The dispersion parameter phi</p>
</td></tr>
<tr><td><code>bias</code></td>
<td>
<p>The model bias, defined as <code>bias&lt;-sqrt(n/d.f)</code></p>
</td></tr>
<tr><td><code>GLMReserve</code></td>
<td>
<p>Deterministic reserve, i.e. the MLE GLM estimate 
of the Reserve</p>
</td></tr>
<tr><td><code>gamma_y</code></td>
<td>
<p>When the calendar year is used, it displays the observed 
and fitted calendar year (usually called &quot;gamma&quot;&quot;) factors.</p>
</td></tr>
<tr><td><code>res.diag</code></td>
<td>
<p>It's a data frame for residual diagnostics. It 
contains:
</p>

<ul>
<li> <p><code>unscaled</code>: The GLM Pearson residuals.
</p>
</li>
<li> <p><code>unscaled.biasadj</code>: The GLM Person residuals adjusted by 
the bias, i.e. <code>unscaled.biasadj=unscaled*bias</code>. 
</p>
</li>
<li> <p><code>scaled</code>: The GLM Person scaled residuals, i.e. 
<code>scaled=unscaled/sqrt(phi)</code>.
</p>
</li>
<li> <p><code>scaled, biasadj</code>: The GLM Person scaled residuals 
adjusted by the bias, i.e. <code>scaled.biasadj=scaled*bias</code>. 
</p>
</li>
<li> <p><code>dev</code>: Development year.
</p>
</li>
<li> <p><code>origin</code>: Origin year.
</p>
</li>
<li> <p><code>cy</code>: Calendar year.      
</p>
</li></ul>

</td></tr>
</table>
<p>[If <code>boostrap&gt;1</code>]
</p>
<table>
<tr><td><code>distr.res_ult</code></td>
<td>
<p>The full distribution &quot;Ultimate View&quot;</p>
</td></tr>
</table>
<p>[If <code>rereserve=TRUE</code>] 
</p>
<table>
<tr><td><code>distr.res_1yr</code></td>
<td>
<p>The full distribution &quot;1yr View&quot;</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>Note that the runtime can materially increase for certain parameter
setting. See above for more details.
</p>


<h3>Note</h3>

<p>This function was born initially as a fork of the <code>glmReserve</code> by 
Wayne Zhang. I would like to thank him for his work that permitted me to 
speed up my coding.
</p>


<h3>Author(s)</h3>

<p>Alessandro Carrato MSc FIA OA <a href="mailto:alessandro.carrato@gmail.com">alessandro.carrato@gmail.com</a>
</p>


<h3>References</h3>

<p>Gigante, Sigalotti. <em>Model risk in claims reserving with generalized linear models</em>. 
Giornale dell'Istituto Italiano degli Attuari, Volume LXVIII. 55-87. 2005
</p>
<p>England, Verrall. <em>Stochastic claims reserving in general insurance</em>. 
B.A.J. 8, III. 443-544. 2002
</p>
<p>England, Verrall. <em>Predictive distributions of outstanding liabilities in general insurance</em>.
A.A.S. 1, II. 221-270. 2006
</p>
<p>Peters, Shevchenko, Wüthrich, <em>Model uncertainty in claims reserving within 
Tweedie's compound poisson models</em>. Astin Bulletin 39(1). 1-33. 2009
</p>
<p>Renshaw, Verrall. <em>A stochastic model underlying the chain-ladder technique</em>.
B.A.J. 4, IV. 903-923. 1998
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+summary.tweedieReserve">summary.tweedieReserve</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Verrall's ODP Model is a Tweedie with p=1, log link and 
## origin/development periods as factors, thus c(1,1,0)
res1 &lt;- tweedieReserve(MW2008, var.power=1, link.power=0, 
                           design.type=c(1,1,0), rereserving=TRUE,
                           progressBar=TRUE)

## To get directly ultimate view and respective one year view 
## at selected percentiles
summary(res1) 

#To get other interesting statistics
res1$summary

## In order to validate the Tweedie parameter 'p', it is interesting to 
## review its loglikelihood profile. Please note that, given the nature 
## of our data, it is expected that we may have some fitting issues for 
## given 'p' parameters, thus any results/errors should be considered 
## only indicatively. Considering different regression structures is anyway 
## recommended. Different 'p' values can be defined via the p.check array 
## as input of the function. 
## See help(tweedie.profile), p.vec parameter, for further information.
## Note: The parameters rereserving and bootstrap can be set to 0 to speed up 
## the process, as they aren't needed. 

## Runs a 'p' loglikelihood profile on the parameters 
## p=c(0,1.1,1.2,1.3,1.4,1.5,2,3)
res2 &lt;- tweedieReserve(MW2008, p.optim=TRUE, 
                       p.check=c(0,1.1,1.2,1.3,1.4,1.5,2,3), 
                       design.type=c(1,1,0), 
                        rereserving=FALSE, bootstrap=0, 
                        progressBar=FALSE)

## As it is possible to see in this example, the MLE of p (or xi) results 
## between 0 and 1, which is not possible as Tweedie models aren't 
## defined for 0 &lt; p &lt; 1, thus the Error message. 
## But, despite this, we can conclude that overall the value p=1 could be 
## reasonable for this dataset, as anyway it seems to be near the MLE. 

## In order to consider an inflation parameter across the origin period, 
## it may be interesting to change the regression structure to c(0,1,1) 
## to get the same estimates of the Arithmetic Separation Method, as 
## referred in Gigante/Sigalotti. 
res3 &lt;- tweedieReserve(MW2008, var.power=1, link.power=0, 
                           design.type=c(0,1,1), rereserving=TRUE,
                           progressBar=TRUE)
res3

## An assessment on future fitted calendar year values (usually defined 
## as "gamma") is recommended
plot(res3$gamma_y)

## Model residuals can be plotted using the res.diag output
plot(scaled.biasadj ~ dev, data=res3$res.diag) # Development year
plot(scaled.biasadj ~ cy, data=res3$res.diag) # Calendar year
plot(scaled.biasadj ~ origin, data=res3$res.diag) # Origin year

## End(Not run)
</code></pre>

<hr>
<h2 id='tweedieReserve+20methods'>
Reserve Risk Capital Report
</h2><span id='topic+print.tweedieReserve'></span><span id='topic+summary.tweedieReserve'></span>

<h3>Description</h3>

<p>Main purpose of this function is to create a report to assess the reserve risk 
capital given an object of the <code><a href="#topic+tweedieReserve">tweedieReserve</a></code> class. 
It displays both the ultimate and one year risk views at given percentiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tweedieReserve'
print(x, ...)
## S3 method for class 'tweedieReserve'
summary(object, q = c(0.5, 0.75, 0.9, 0.95, 0.995),...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tweedieReserve+2B20methods_+3A_x">x</code></td>
<td>

<p>An object of class <code><a href="#topic+tweedieReserve">tweedieReserve</a></code>.
</p>
</td></tr>
<tr><td><code id="tweedieReserve+2B20methods_+3A_object">object</code></td>
<td>

<p>An object of class <code><a href="#topic+tweedieReserve">tweedieReserve</a></code>.
</p>
</td></tr>
<tr><td><code id="tweedieReserve+2B20methods_+3A_q">q</code></td>
<td>

<p>Array of percentiles to be displayed.
</p>
</td></tr>
<tr><td><code id="tweedieReserve+2B20methods_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two items 
</p>
<table>
<tr><td><code>Predicton</code></td>
<td>
<p>a data.frame with ultimate view reserve risk 
and the one year view reserve risk at the given percentiles.</p>
</td></tr>
<tr><td><code>Diagnostic</code></td>
<td>
<p>Quick diagnostic to show the deterministic reserve vs ultimate
view and one year view best estimate. If the model is working properly, 
then these three value shouldn't be much different.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alessandro Carrato MSc FIA OA <a href="mailto:alessandro.carrato@gmail.com">alessandro.carrato@gmail.com</a>
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+tweedieReserve">tweedieReserve</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
tw &lt;- tweedieReserve(MW2008, rereserving = TRUE)
summary(tw)
# For comparison 
CDR.BootChainLadder(BootChainLadder(MW2008))

## End(Not run)
</code></pre>

<hr>
<h2 id='UKMotor'>
UK motor claims triangle
</h2><span id='topic+UKMotor'></span>

<h3>Description</h3>

<p>Triangle of cumulative claims payments for four origin (accident) 
years over time (development years).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("UKMotor")</code></pre>


<h3>Format</h3>

<p>A matrix with 7 accident years and 7 development years.
</p>


<h3>Source</h3>

<p><a href="https://www.actuaries.org.uk/system/files/documents/pdf/crm2-D5.pdf">https://www.actuaries.org.uk/system/files/documents/pdf/crm2-D5.pdf</a>
</p>


<h3>References</h3>

<p>Stavros Christofides. Regression models based on log-incremental payments. 
Claims Reserving Manual. Volume 2 D5. September 1997
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(UKMotor)
plot(UKMotor)
MackChainLadder(UKMotor, est.sigma="Mack")
</code></pre>

<hr>
<h2 id='USAA+20triangle'>
Example paid and incurred triangle data from CAS web site.
</h2><span id='topic+USAApaid'></span><span id='topic+USAAincurred'></span>

<h3>Description</h3>

<p>Paid and incurred triangle data from the United Services Automobile Association company for the private passenger auto liability/medical line of business.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("USAApaid")</code></pre>


<h3>Format</h3>

<p>A triangle with 10 accident years and 10 development years.
</p>


<h3>Details</h3>

<p>The claims data comes from Schedule P - Analysis of Losses and Loss Expenses in the National Association of Insurance Commissioners (NAIC) database.
CAS obtained permission from the NAIC to make this data available to all interested researchers on the CAS website.
NAIC Schedule P contains information on claims for major personal and 
commercial lines for all property-casualty insurers that write business in US.
</p>


<h3>Source</h3>

<p><a href="https://www.casact.org">https://www.casact.org</a>
</p>


<h3>References</h3>

<p>CAS website.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(USAApaid)
</code></pre>

<hr>
<h2 id='vcov.clark'>Covariance Matrix of Parameter Estimates &ndash; Clark's methods</h2><span id='topic+vcov.clark'></span>

<h3>Description</h3>

<p>Function to compute the covariance matrix of the parameter estimates
for the ClarkLDF and ClarkCapeCod methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'clark'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.clark_+3A_object">object</code></td>
<td>

<p>object resulting from a run of the ClarkLDF or ClarkCapeCod functions.
</p>
</td></tr>
<tr><td><code id="vcov.clark_+3A_...">...</code></td>
<td>

<p>not used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The covariance matrix of the estimated parameters is estimated
by the inverse of the Information matrix (see Clark, p. 53).
This function uses the &quot;FI&quot; and &quot;sigma2&quot; values returned by 
ClarkLDF and by ClarkCapeCod and calculates the matrix
<br />
-sigma2*FI^-1.
</p>


<h3>Author(s)</h3>

<p>Daniel Murphy
</p>


<h3>References</h3>

<p>Clark, David R., 
&quot;LDF Curve-Fitting and Stochastic Reserving: A Maximum Likelihood Approach&quot;,
<em>Casualty Actuarial Society Forum</em>, Fall, 2003
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ClarkLDF">ClarkLDF</a></code>, <code><a href="#topic+ClarkCapeCod">ClarkCapeCod</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- GenIns
colnames(x) &lt;- 12*as.numeric(colnames(x))
Y &lt;- ClarkCapeCod(x, Premium=10000000+400000*0:9, maxage=240)
round(vcov(Y),6) ## Compare to matrix on p. 69 of Clark's paper

# The estimates of the loglogistic parameters
Y$THETAG
# The standard errors of the estimated parameters
sqrt(tail(diag(vcov(Y)), 2))

# The parameter risks of the estimated reserves are calculated 
# according to the formula on p. 54 of Clark's paper. For example, for
# the 5th accident year, pre- and post-multiply the covariance matrix
# by a matrix consisting of the gradient entries for just that accident year
FVgrad5 &lt;- matrix(Y$FutureValueGradient[, 5], ncol=1)
sqrt(t(FVgrad5) %*% vcov(Y) %*% FVgrad5) ## compares to 314,829 in Clark's paper

# The estimated reserves for accident year 5:
Y$FutureValue[5]   ## compares to 2,046,646 in the paper

# Recalculate the parameter risk CV for all accident years in total (10.6% in paper):
sqrt(sum(t(Y$FutureValueGradient) %*% vcov(Y) %*% Y$FutureValueGradient)) / 
    Y$Total$FutureValue

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
