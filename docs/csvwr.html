<!DOCTYPE html><html lang="en-GB"><head><title>Help for package csvwr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {csvwr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#csvwr'><p>csvwr: Read and write CSV on the Web (CSVW)</p></a></li>
<li><a href='#add_dataframe'><p>Add data frame to csvw table annotation</p></a></li>
<li><a href='#base_uri'><p>Retrieve the base URI from configuration</p></a></li>
<li><a href='#base_url'><p>Determine the base URL for CSVW metadata</p></a></li>
<li><a href='#coalesce_truth'><p>Coalesce value to truthiness</p></a></li>
<li><a href='#compact_json_ld'><p>Compact objects to values</p></a></li>
<li><a href='#create_metadata'><p>Create tabular metadata from a list of tables</p></a></li>
<li><a href='#csvw_to_list'><p>Convert a csvw metadata to a list (csv2json)</p></a></li>
<li><a href='#csvwr_example'><p>Get path to csvwr example</p></a></li>
<li><a href='#datatype_to_type'><p>Map csvw datatypes to R types</p></a></li>
<li><a href='#default_dialect'><p>CSVW default dialect</p></a></li>
<li><a href='#default_schema'><p>Create a default table schema given a csv file and dialect</p></a></li>
<li><a href='#derive_metadata'><p>Derive csvw metadata from a csv file</p></a></li>
<li><a href='#derive_table_schema'><p>Derive csvw table schema from a data frame</p></a></li>
<li><a href='#extract_table'><p>Extract a referenced table from CSVW metadata</p></a></li>
<li><a href='#find_existing_file'><p>Find the first existing file from a set of candidates</p></a></li>
<li><a href='#find_metadata'><p>Find metadata for a tabular file</p></a></li>
<li><a href='#is_absolute_url'><p>Does the string provide an absolute URL</p></a></li>
<li><a href='#is_non_core_annotation'><p>Determine if an annotation is non-core</p></a></li>
<li><a href='#json_ld_to_json'><p>Convert json-ld annotation to json</p></a></li>
<li><a href='#list_of_lists_to_df'><p>Parse list of lists specification into a data frame</p></a></li>
<li><a href='#locate_metadata'><p>Locate metadata for a table</p></a></li>
<li><a href='#locate_table'><p>Locate csv data table</p></a></li>
<li><a href='#location_configuration'><p>Identify metadata location configurations for a tabular file</p></a></li>
<li><a href='#normalise_metadata'><p>Normalise metadata</p></a></li>
<li><a href='#normalise_property'><p>Normalise an annotation property</p></a></li>
<li><a href='#normalise_url'><p>Normalise a URL</p></a></li>
<li><a href='#override_defaults'><p>Override defaults</p></a></li>
<li><a href='#parse_columns'><p>Parse columns schema</p></a></li>
<li><a href='#parse_metadata'><p>Parse metadata</p></a></li>
<li><a href='#read_csvw'><p>Read CSV on the Web</p></a></li>
<li><a href='#read_csvw_dataframe'><p>Read a data frame from the first table in a csvw</p></a></li>
<li><a href='#read_metadata'><p>Read and parse CSVW Metadata</p></a></li>
<li><a href='#render_cell'><p>Serialise cell values for JSON representation</p></a></li>
<li><a href='#render_uri_templates'><p>Render URI templates</p></a></li>
<li><a href='#resolve_url'><p>Resolve one URL against another</p></a></li>
<li><a href='#rlmap'><p>Recursive lmap</p></a></li>
<li><a href='#rmap'><p>Recursive map</p></a></li>
<li><a href='#set_uri_base'><p>Set the base of a URI template</p></a></li>
<li><a href='#table_to_list'><p>Convert a table to a list</p></a></li>
<li><a href='#transform_datetime_format'><p>Transform date/time format string from Unicode TR35 to POSIX 1003.1</p></a></li>
<li><a href='#try_add_dataframe'><p>Try to add a dataframe to the table</p></a></li>
<li><a href='#type_to_datatype'><p>Map R types to csvw datatype</p></a></li>
<li><a href='#unlist1'><p>Unlist unless the list-elements are themselves lists</p></a></li>
<li><a href='#validate_csvw'><p>Validate CSVW specification</p></a></li>
<li><a href='#validate_referential_integrity'><p>Validate the referential integrity of a csvw table group</p></a></li>
<li><a href='#vec_depth'><p>Calculate depth of vector safely</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Read and Write CSV on the Web (CSVW) Tables and Metadata</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.7</td>
</tr>
<tr>
<td>Author:</td>
<td>Robin Gower</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robin Gower &lt;csvwr@infonomics.ltd.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provide functions for reading and writing CSVW - i.e. CSV tables and JSON metadata.
    The metadata helps interpret CSV by setting the types and variable names.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://robsteranium.github.io/csvwr/">https://robsteranium.github.io/csvwr/</a>,
<a href="https://github.com/Robsteranium/csvwr">https://github.com/Robsteranium/csvwr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Robsteranium/csvwr/issues">https://github.com/Robsteranium/csvwr/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), knitr, markdown, rmarkdown</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, magrittr, jsonlite, purrr, readr, stringr, rlang</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-20 13:47:03 UTC; robin</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-21 11:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='csvwr'>csvwr: Read and write CSV on the Web (CSVW)</h2><span id='topic+csvwr'></span><span id='topic+csvwr-package'></span>

<h3>Description</h3>

<p>Read and write csv tables annotated with
<a href="https://w3c.github.io/csvw/metadata/">csvw metadata</a>. This helps to
ensure consistent processing and reduce the amount of manual work needed to
parse and prepare data before it can be used in analysis.
</p>


<h3>Getting started</h3>

<p>The best place to start is the
<a href="../doc/read-write-csvw.html">Reading and Writing CSVW</a> vignette.
</p>


<h3>Reading annotated tables</h3>


<ul>
<li> <p><code><a href="#topic+read_csvw">read_csvw</a></code> Parse a table group
</p>
</li>
<li> <p><code><a href="#topic+read_csvw_dataframe">read_csvw_dataframe</a></code> Parse a table group and extract the first
data frame
</p>
</li></ul>



<h3>Writing table annotations</h3>


<ul>
<li> <p><code><a href="#topic+derive_table_schema">derive_table_schema</a></code> Derive table schema from a data frame
</p>
</li>
<li> <p><code><a href="#topic+create_metadata">create_metadata</a></code> Create a table group annotation
</p>
</li>
<li> <p><code><a href="#topic+derive_metadata">derive_metadata</a></code> Derive an annotation from a csv file
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://robsteranium.github.io/csvwr/">https://robsteranium.github.io/csvwr/</a>
</p>
</li>
<li> <p><a href="https://github.com/Robsteranium/csvwr">https://github.com/Robsteranium/csvwr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/Robsteranium/csvwr/issues">https://github.com/Robsteranium/csvwr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='add_dataframe'>Add data frame to csvw table annotation</h2><span id='topic+add_dataframe'></span>

<h3>Description</h3>

<p>Add data frame to csvw table annotation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_dataframe(table, filename, group)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_dataframe_+3A_table">table</code></td>
<td>
<p>a <code>csvw:Table</code> annotation</p>
</td></tr>
<tr><td><code id="add_dataframe_+3A_filename">filename</code></td>
<td>
<p>a filename/ URL for the csv table</p>
</td></tr>
<tr><td><code id="add_dataframe_+3A_group">group</code></td>
<td>
<p>a list of metadata for the table group to use as a fallback</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a table annotation with a <code>dataframe</code> attribute added with data frame
holding the contents of the table
</p>

<hr>
<h2 id='base_uri'>Retrieve the base URI from configuration</h2><span id='topic+base_uri'></span>

<h3>Description</h3>

<p>Retrieve the base URI from configuration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base_uri()
</code></pre>


<h3>Value</h3>

<p>returns the value of <code>csvwr_base_uri</code> option, defaulting to <code>example.net</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
base_uri() # returns default

options(csvwr_base_uri="http://www.w3.org/2013/csvw/tests/")
base_uri()

## End(Not run)
</code></pre>

<hr>
<h2 id='base_url'>Determine the base URL for CSVW metadata</h2><span id='topic+base_url'></span>

<h3>Description</h3>

<p>Determine the base URL for CSVW metadata
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base_url(metadata, location)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="base_url_+3A_metadata">metadata</code></td>
<td>
<p>the csvw metadata</p>
</td></tr>
<tr><td><code id="base_url_+3A_location">location</code></td>
<td>
<p>where the metadata was originally located</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string containing the base URL
</p>

<hr>
<h2 id='coalesce_truth'>Coalesce value to truthiness</h2><span id='topic+coalesce_truth'></span>

<h3>Description</h3>

<p>Determine whether the input is true, with missing values being interpreted as false.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coalesce_truth(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coalesce_truth_+3A_x">x</code></td>
<td>
<p>logical, <code>NA</code> or <code>NULL</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>FALSE</code> if x is anything but <code>TRUE</code>
</p>

<hr>
<h2 id='compact_json_ld'>Compact objects to values</h2><span id='topic+compact_json_ld'></span>

<h3>Description</h3>

<p>Follows the <a href="https://w3c.github.io/csvw/csv2json/#json-ld-to-json">rules for JSON-LD to JSON conversion set out in the csv2json standard</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compact_json_ld(value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compact_json_ld_+3A_value">value</code></td>
<td>
<p>an element from a list (could be a vector or another list)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A compacted value.
</p>

<hr>
<h2 id='create_metadata'>Create tabular metadata from a list of tables</h2><span id='topic+create_metadata'></span>

<h3>Description</h3>

<p>The table annotations should each be a list with keys for <code>url</code> and <code>tableSchema</code>.
You can use <code>derive_table_schema</code> to derive a schema from a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_metadata(tables)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_metadata_+3A_tables">tables</code></td>
<td>
<p>a list of <code>csvw:table</code> annotations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list describing a tabular metadata annotation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- data.frame(foo="bar")
table &lt;- list(url="filename.csv", tableSchema=derive_table_schema(d))
create_metadata(tables=list(table))
</code></pre>

<hr>
<h2 id='csvw_to_list'>Convert a csvw metadata to a list (csv2json)</h2><span id='topic+csvw_to_list'></span>

<h3>Description</h3>

<p>Convert a csvw metadata to a list (csv2json)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csvw_to_list(csvw)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="csvw_to_list_+3A_csvw">csvw</code></td>
<td>
<p>a csvw metadata list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list following the csv2json translation rules
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
csvw_to_list(read_csvw("example.csv"))

## End(Not run)
</code></pre>

<hr>
<h2 id='csvwr_example'>Get path to csvwr example</h2><span id='topic+csvwr_example'></span>

<h3>Description</h3>

<p>The csvwr package includes some example csvw files in it's <code>inst/extdata</code> directory.
You can use this function to find them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csvwr_example(path = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="csvwr_example_+3A_path">path</code></td>
<td>
<p>The filename. If <code>NULL</code>, the example files will be listed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Inspired by <code><a href="readr.html#topic+readr_example">readr::readr_example()</a></code>
</p>


<h3>Value</h3>

<p>either a file path or a vector of filenames
</p>


<h3>Examples</h3>

<pre><code class='language-R'>csvwr_example()
csvwr_example("computer-scientists.csv")
</code></pre>

<hr>
<h2 id='datatype_to_type'>Map csvw datatypes to R types</h2><span id='topic+datatype_to_type'></span>

<h3>Description</h3>

<p>Translate <a href="https://www.w3.org/TR/tabular-metadata/#datatypes">csvw datatypes</a> to R types.
This implementation currently targets <a href="readr.html#topic+cols">readr::cols</a> column specifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>datatype_to_type(datatypes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="datatype_to_type_+3A_datatypes">datatypes</code></td>
<td>
<p>a list of csvw datatypes</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>readr::cols</code> specification - a list of collectors
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
cspec &lt;- datatype_to_type(list("double", list(base="date", format="yyyy-MM-dd")))
readr::read_csv(readr::readr_example("challenge.csv"), col_types=cspec)

## End(Not run)
</code></pre>

<hr>
<h2 id='default_dialect'>CSVW default dialect</h2><span id='topic+default_dialect'></span>

<h3>Description</h3>

<p>The <a href="https://w3c.github.io/csvw/metadata/#dialect-descriptions">CSVW Default Dialect specification</a>
described in <a href="http://dataprotocols.org/csv-dialect/">CSV Dialect Description Format</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_dialect
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 13.
</p>


<h3>Value</h3>

<p>a list specifying a default csv dialect
</p>

<hr>
<h2 id='default_schema'>Create a default table schema given a csv file and dialect</h2><span id='topic+default_schema'></span>

<h3>Description</h3>

<p>If neither the table nor the group have a <code>tableSchema</code> annotation,
then this default schema will used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_schema(filename, dialect = default_dialect)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="default_schema_+3A_filename">filename</code></td>
<td>
<p>a csv file</p>
</td></tr>
<tr><td><code id="default_schema_+3A_dialect">dialect</code></td>
<td>
<p>specification of the csv's dialect (default: <code>default_dialect</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a table schema
</p>

<hr>
<h2 id='derive_metadata'>Derive csvw metadata from a csv file</h2><span id='topic+derive_metadata'></span>

<h3>Description</h3>

<p>Derive csvw metadata from a csv file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_metadata(filename)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="derive_metadata_+3A_filename">filename</code></td>
<td>
<p>a csv file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of csvw metadata
</p>


<h3>Examples</h3>

<pre><code class='language-R'>derive_metadata(csvwr_example("computer-scientists.csv"))
</code></pre>

<hr>
<h2 id='derive_table_schema'>Derive csvw table schema from a data frame</h2><span id='topic+derive_table_schema'></span>

<h3>Description</h3>

<p>Derive csvw table schema from a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_table_schema(d)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="derive_table_schema_+3A_d">d</code></td>
<td>
<p>a data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list describing a <code>csvw:tableSchema</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>derive_table_schema(data.frame(a=1,b=2))
</code></pre>

<hr>
<h2 id='extract_table'>Extract a referenced table from CSVW metadata</h2><span id='topic+extract_table'></span>

<h3>Description</h3>

<p>Extract a referenced table from CSVW metadata
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_table(csvw, reference)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_table_+3A_csvw">csvw</code></td>
<td>
<p>the metadata</p>
</td></tr>
<tr><td><code id="extract_table_+3A_reference">reference</code></td>
<td>
<p>a foreign key reference expressed as a list containing either a
reference attribute or a schemaReference attribute</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a csvw table
</p>

<hr>
<h2 id='find_existing_file'>Find the first existing file from a set of candidates</h2><span id='topic+find_existing_file'></span>

<h3>Description</h3>

<p>Find the first existing file from a set of candidates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_existing_file(filenames)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_existing_file_+3A_filenames">filenames</code></td>
<td>
<p>a vector of candidates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If one of the filenames passed is found, then the first is returned.
If none of the filenames exist, <code>NULL</code> is returned
</p>

<hr>
<h2 id='find_metadata'>Find metadata for a tabular file</h2><span id='topic+find_metadata'></span>

<h3>Description</h3>

<p>Searches through the default locations attempting to locate metadata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_metadata(filename)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_metadata_+3A_filename">filename</code></td>
<td>
<p>a csv file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a uri for the metadata, or null if none were found
</p>

<hr>
<h2 id='is_absolute_url'>Does the string provide an absolute URL</h2><span id='topic+is_absolute_url'></span>

<h3>Description</h3>

<p>Does the string provide an absolute URL
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_absolute_url(string)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_absolute_url_+3A_string">string</code></td>
<td>
<p>the url, path or template</p>
</td></tr>
</table>


<h3>Value</h3>

<p>true if the string is an absolute url
</p>

<hr>
<h2 id='is_non_core_annotation'>Determine if an annotation is non-core</h2><span id='topic+is_non_core_annotation'></span>

<h3>Description</h3>

<p>Checks if the annotation is non-core, and should thus be treated as a json-ld note.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_non_core_annotation(property)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_non_core_annotation_+3A_property">property</code></td>
<td>
<p>a list element</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> the annotation is core, <code>FALSE</code> otherwise
</p>

<hr>
<h2 id='json_ld_to_json'>Convert json-ld annotation to json</h2><span id='topic+json_ld_to_json'></span>

<h3>Description</h3>

<p>Follows the <a href="https://w3c.github.io/csvw/csv2json/#json-ld-to-json">rules for JSON-LD to JSON conversion set out in the csv2json standard</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>json_ld_to_json(property)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="json_ld_to_json_+3A_property">property</code></td>
<td>
<p>a json-ld annotation (single list element)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A compacted list element
</p>

<hr>
<h2 id='list_of_lists_to_df'>Parse list of lists specification into a data frame</h2><span id='topic+list_of_lists_to_df'></span>

<h3>Description</h3>

<p>Parse list of lists specification into a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_of_lists_to_df(ll)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="list_of_lists_to_df_+3A_ll">ll</code></td>
<td>
<p>a list of lists</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with a row per list
</p>

<hr>
<h2 id='locate_metadata'>Locate metadata for a table</h2><span id='topic+locate_metadata'></span>

<h3>Description</h3>

<p>Follows the procedure defined in the <a href="https://w3c.github.io/csvw/syntax/#locating-metadata">csvw model</a>:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locate_metadata(filename, metadata)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="locate_metadata_+3A_filename">filename</code></td>
<td>
<p>a path for a csv table or a json metadata document</p>
</td></tr>
<tr><td><code id="locate_metadata_+3A_metadata">metadata</code></td>
<td>
<p>optional user metadata</p>
</td></tr>
</table>


<h3>Details</h3>


<ol>
<li><p> Metadata supplied by the user
</p>
</li>
<li><p> Metadata referenced by a link header
</p>
</li>
<li><p> Metadata located through default paths
</p>
</li>
<li><p> Metadata embedded in the file
</p>
</li></ol>

<p>We extend this to use the <a href="#topic+derive_metadata">derive_metadata</a> function to inspect the table itself.
</p>


<h3>Value</h3>

<p>csvw metadata list
</p>

<hr>
<h2 id='locate_table'>Locate csv data table</h2><span id='topic+locate_table'></span>

<h3>Description</h3>

<p>Locate csv data table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locate_table(filename, url)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="locate_table_+3A_filename">filename</code></td>
<td>
<p>the file passed to <code>read_csvw</code> in the first place (could be the csv or json annotations)</p>
</td></tr>
<tr><td><code id="locate_table_+3A_url">url</code></td>
<td>
<p>the location of the the table as defined in the metadata</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The location of the table
</p>

<hr>
<h2 id='location_configuration'>Identify metadata location configurations for a tabular file</h2><span id='topic+location_configuration'></span>

<h3>Description</h3>

<p>Returns default locations. Will ultimately retrieve remote configuration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>location_configuration(filename)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="location_configuration_+3A_filename">filename</code></td>
<td>
<p>a csv file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector of URI templates
</p>

<hr>
<h2 id='normalise_metadata'>Normalise metadata</h2><span id='topic+normalise_metadata'></span>

<h3>Description</h3>

<p>The spec defines a <a href="https://w3c.github.io/csvw/metadata/#normalization">normalisation process</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalise_metadata(metadata, location)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normalise_metadata_+3A_metadata">metadata</code></td>
<td>
<p>a csvw metadata list</p>
</td></tr>
<tr><td><code id="normalise_metadata_+3A_location">location</code></td>
<td>
<p>the location of the metadata</p>
</td></tr>
</table>


<h3>Value</h3>

<p>metadata with normalised properties
</p>

<hr>
<h2 id='normalise_property'>Normalise an annotation property</h2><span id='topic+normalise_property'></span>

<h3>Description</h3>

<p>This follows the <a href="https://w3c.github.io/csvw/metadata/#normalization">normalisation</a>
process set out in the csvw specification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalise_property(property, base_url)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normalise_property_+3A_property">property</code></td>
<td>
<p>an annotation property (a list)</p>
</td></tr>
<tr><td><code id="normalise_property_+3A_base_url">base_url</code></td>
<td>
<p>the base URL for normalisation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a property (list) a
</p>

<hr>
<h2 id='normalise_url'>Normalise a URL</h2><span id='topic+normalise_url'></span>

<h3>Description</h3>

<p>Ensures that a url is specified absolutely with reference to a base
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalise_url(url, base)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normalise_url_+3A_url">url</code></td>
<td>
<p>a string</p>
</td></tr>
<tr><td><code id="normalise_url_+3A_base">base</code></td>
<td>
<p>the base to use for normalisation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string containing a normalised URL
</p>

<hr>
<h2 id='override_defaults'>Override defaults</h2><span id='topic+override_defaults'></span>

<h3>Description</h3>

<p>Merges two lists applying <code>override</code> values on top of the <code>default</code> values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>override_defaults(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="override_defaults_+3A_...">...</code></td>
<td>
<p>any number of lists with configuration values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the values from the first list replacing those in the second and so on
</p>

<hr>
<h2 id='parse_columns'>Parse columns schema</h2><span id='topic+parse_columns'></span>

<h3>Description</h3>

<p>Parse columns schema
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_columns(columns)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_columns_+3A_columns">columns</code></td>
<td>
<p>a list of lists specification of columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with a row per column specification
</p>

<hr>
<h2 id='parse_metadata'>Parse metadata</h2><span id='topic+parse_metadata'></span>

<h3>Description</h3>

<p>Coerces the metadata to ensure it describes a table group.
Retrieves any linked tableSchema.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_metadata(metadata, location)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_metadata_+3A_metadata">metadata</code></td>
<td>
<p>a csvw metadata list</p>
</td></tr>
<tr><td><code id="parse_metadata_+3A_location">location</code></td>
<td>
<p>the location of the metadata</p>
</td></tr>
</table>


<h3>Value</h3>

<p>metadata coerced into a
<a href="https://www.w3.org/TR/tabular-metadata/#dfn-table-group-description">table group description</a>
</p>

<hr>
<h2 id='read_csvw'>Read CSV on the Web</h2><span id='topic+read_csvw'></span>

<h3>Description</h3>

<p>If the argument to <code>filename</code> is a json metadata document, this will be used to find csv files for
each table using the value of <code>csvw:url</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_csvw(filename, metadata = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_csvw_+3A_filename">filename</code></td>
<td>
<p>a path for a csv table or a json metadata document</p>
</td></tr>
<tr><td><code id="read_csvw_+3A_metadata">metadata</code></td>
<td>
<p>optional user metadata</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the argument to <code>filename</code> is a csv file, and no <code>metadata</code> is provided, an attempt is made to
derive metadata.
</p>
<p>If the argument to <code>filename</code> is a csv file, and the <code>metadata</code> is provided, then the given csv will
override the value of <code>csvw:url</code>.
</p>
<p>The csvw metadata is returned as a list. In each table in the table group, an element named
<code>dataframe</code> is added which provides the contents of the csv table parsed into a data frame using
the table schema.
</p>


<h3>Value</h3>

<p>csvw metadata list, with a <code>dataframe</code> property added to each table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
read_csvw("metadata.json")
read_csvw("table.csv", "metadata.json")

## End(Not run)
</code></pre>

<hr>
<h2 id='read_csvw_dataframe'>Read a data frame from the first table in a csvw</h2><span id='topic+read_csvw_dataframe'></span>

<h3>Description</h3>

<p>Wrapper around <code>read_csvw</code> convenient when you're only interested in the data and there's only one table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_csvw_dataframe(filename, metadata = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_csvw_dataframe_+3A_filename">filename</code></td>
<td>
<p>a path for a csv table or a json metadata document</p>
</td></tr>
<tr><td><code id="read_csvw_dataframe_+3A_metadata">metadata</code></td>
<td>
<p>optional user metadata</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame parsed using the table schema
</p>

<hr>
<h2 id='read_metadata'>Read and parse CSVW Metadata</h2><span id='topic+read_metadata'></span>

<h3>Description</h3>

<p>Reads in a json document as a list, transforming columns specifications into a dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_metadata(filename)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_metadata_+3A_filename">filename</code></td>
<td>
<p>a path for a json metadata document</p>
</td></tr>
</table>


<h3>Value</h3>

<p>csvw metadata list
</p>

<hr>
<h2 id='render_cell'>Serialise cell values for JSON representation</h2><span id='topic+render_cell'></span>

<h3>Description</h3>

<p>Serialise cell values for JSON representation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_cell(cell)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="render_cell_+3A_cell">cell</code></td>
<td>
<p>a typed value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a representation comparable with the JSON representation (typically a string)
</p>

<hr>
<h2 id='render_uri_templates'>Render URI templates</h2><span id='topic+render_uri_templates'></span>

<h3>Description</h3>

<p>Interpolate variable bindings into a URI template.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>render_uri_templates(templates, bindings = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="render_uri_templates_+3A_templates">templates</code></td>
<td>
<p>a character vector with URI templates</p>
</td></tr>
<tr><td><code id="render_uri_templates_+3A_bindings">bindings</code></td>
<td>
<p>a list of variable bindings to be interpolated into templates</p>
</td></tr>
<tr><td><code id="render_uri_templates_+3A_...">...</code></td>
<td>
<p>further bindings specified as named function arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This doesn't yet implement the whole of RFC 6570, just enough to make the tests pass
</p>
<p>You can bind variables by passing a list to the explicit <code>bindings</code> argument,
or variadically with <code>...</code> by naming arguments according to the variable name you wish to bind.
</p>


<h3>Value</h3>

<p>a character vector with the expanded URI
</p>


<h3>Examples</h3>

<pre><code class='language-R'>render_uri_templates("{+url}/resource?query=value", list(url="http://example.net"))
render_uri_templates("{+url}", url="http://example.net")
</code></pre>

<hr>
<h2 id='resolve_url'>Resolve one URL against another</h2><span id='topic+resolve_url'></span>

<h3>Description</h3>

<p>Resolve one URL against another
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resolve_url(url1, url2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resolve_url_+3A_url1">url1</code></td>
<td>
<p>the base url</p>
</td></tr>
<tr><td><code id="resolve_url_+3A_url2">url2</code></td>
<td>
<p>a relative url</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single absolute url
</p>

<hr>
<h2 id='rlmap'>Recursive lmap</h2><span id='topic+rlmap'></span>

<h3>Description</h3>

<p>Applies function <code>.f</code> to each list-element in <code>.x</code> as per <code>purrr::lmap</code>.
If the value of the list-element is itself a list, then the function is applied to that in turn.
The process is followed recursively until an atomic value at the leaf nodes of the list is found.
If <code>.f</code> modifies the name, it is thrown away and replaced by the original name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlmap(.x, .f, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rlmap_+3A_.x">.x</code></td>
<td>
<p>a list</p>
</td></tr>
<tr><td><code id="rlmap_+3A_.f">.f</code></td>
<td>
<p>a function (called with elements of <code>.x</code> as the first argument)</p>
</td></tr>
<tr><td><code id="rlmap_+3A_...">...</code></td>
<td>
<p>further arguments passed to the function <code>.f</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list
</p>

<hr>
<h2 id='rmap'>Recursive map</h2><span id='topic+rmap'></span>

<h3>Description</h3>

<p>Applies function <code>.f</code> to each element in <code>.x</code> as per <code>purrr::map</code>.
If the value of the element is itself a list, then the function is applied to that in turn.
The process is followed recursively until an atomic value at the leaf nodes of the list is found.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmap(.x, .f)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rmap_+3A_.x">.x</code></td>
<td>
<p>a list</p>
</td></tr>
<tr><td><code id="rmap_+3A_.f">.f</code></td>
<td>
<p>a function (called with elements of <code>.x</code> as the first argument)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list
</p>

<hr>
<h2 id='set_uri_base'>Set the base of a URI template</h2><span id='topic+set_uri_base'></span>

<h3>Description</h3>

<p>Set the base of a URI template
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_uri_base(t, url)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_uri_base_+3A_t">t</code></td>
<td>
<p>a character vector of URI templates</p>
</td></tr>
<tr><td><code id="set_uri_base_+3A_url">url</code></td>
<td>
<p>a filename url being used as a context (string)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector of templates with base paths/ domains set appropriately
</p>

<hr>
<h2 id='table_to_list'>Convert a table to a list</h2><span id='topic+table_to_list'></span>

<h3>Description</h3>

<p>Follows the pattern for csv2json
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_to_list(table, group)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="table_to_list_+3A_table">table</code></td>
<td>
<p>the csvw table</p>
</td></tr>
<tr><td><code id="table_to_list_+3A_group">group</code></td>
<td>
<p>list of metadata for the group used for a fallback schema and dialect</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list representation of the table's contents
</p>

<hr>
<h2 id='transform_datetime_format'>Transform date/time format string from Unicode TR35 to POSIX 1003.1</h2><span id='topic+transform_datetime_format'></span>

<h3>Description</h3>

<p>As per the <a href="https://www.w3.org/TR/2015/REC-tabular-data-model-20151217/#h-formats-for-dates-and-times">csvw specification for date and time formats</a>
we accept format strings using the <a href="https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table">date field symbols defined in unicode TR35</a>.
These are converted to POSIX 1003.1 date format strings for use in
<code><a href="base.html#topic+strptime">base::strptime()</a></code> or <code><a href="readr.html#topic+parse_datetime">readr::parse_date()</a></code>/<code><a href="readr.html#topic+parse_datetime">readr::parse_datetime()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_datetime_format(format_string)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transform_datetime_format_+3A_format_string">format_string</code></td>
<td>
<p>a UAX35 date format string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a POSIX date format string
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fmt &lt;- transform_datetime_format("dd.MM.yyyy")
strptime("01.01.2001", format=fmt)

## End(Not run)
</code></pre>

<hr>
<h2 id='try_add_dataframe'>Try to add a dataframe to the table</h2><span id='topic+try_add_dataframe'></span>

<h3>Description</h3>

<p>If this fails, a list describing the error is added instead
</p>


<h3>Usage</h3>

<pre><code class='language-R'>try_add_dataframe(table, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="try_add_dataframe_+3A_table">table</code></td>
<td>
<p>a <code>csvw:Table</code> annotation</p>
</td></tr>
<tr><td><code id="try_add_dataframe_+3A_...">...</code></td>
<td>
<p>arguments to <code>add_dataframe</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table annotation with a <code>dataframe</code> attribute added with data frame
holding the contents of the table or an error.
</p>

<hr>
<h2 id='type_to_datatype'>Map R types to csvw datatype</h2><span id='topic+type_to_datatype'></span>

<h3>Description</h3>

<p>Translate R types to <a href="https://www.w3.org/TR/tabular-metadata/#datatypes">csvw datatypes</a>.
Acts as an inverse of <code>datatype_to_type</code> but doesn't provide a 1:1 correspondence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>type_to_datatype(types)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="type_to_datatype_+3A_types">types</code></td>
<td>
<p>a list of R types</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of csvw datatypes
</p>

<hr>
<h2 id='unlist1'>Unlist unless the list-elements are themselves lists</h2><span id='topic+unlist1'></span>

<h3>Description</h3>

<p>Convert a list of elements to a vector. Unlike <code>base::unlist</code> this doesn't
convert the elements of inner lists to vector elements. Thus only a list a single
layer deep is flattened to a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unlist1(l)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unlist1_+3A_l">l</code></td>
<td>
<p>a list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of lists or a vector
</p>

<hr>
<h2 id='validate_csvw'>Validate CSVW specification</h2><span id='topic+validate_csvw'></span>

<h3>Description</h3>

<p>Follows the <a href="https://w3c.github.io/csvw/syntax/#validating-tables">csvw table validation</a>
procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_csvw(csvw)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_csvw_+3A_csvw">csvw</code></td>
<td>
<p>a csvw metadata specification (a list)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a validation report (list)
</p>

<hr>
<h2 id='validate_referential_integrity'>Validate the referential integrity of a csvw table group</h2><span id='topic+validate_referential_integrity'></span>

<h3>Description</h3>

<p>Fails if foreign keys aren't found in the referenced tables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_referential_integrity(csvw)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_referential_integrity_+3A_csvw">csvw</code></td>
<td>
<p>the metadata annotation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list specifying any foreign key violations
</p>

<hr>
<h2 id='vec_depth'>Calculate depth of vector safely</h2><span id='topic+vec_depth'></span>

<h3>Description</h3>

<p>Like <code>purrr::vec_depth</code> but doesn't attempt to descend into errors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_depth(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vec_depth_+3A_x">x</code></td>
<td>
<p>a vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
