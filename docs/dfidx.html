<!DOCTYPE html><html><head><title>Help for package dfidx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dfidx}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dfidx'><p>Data frames with indexes</p></a></li>
<li><a href='#dplyr'><p>Methods for dplyr verbs</p></a></li>
<li><a href='#idx'><p>Index for dfidx</p></a></li>
<li><a href='#idx_name'><p>Get the names of the indexes</p></a></li>
<li><a href='#methods.dfidx'><p>Methods for dfidx</p></a></li>
<li><a href='#model.frame.dfidx'><p>model.frame/matrix for dfidx objects</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#unfold_idx'><p>Fold and Unfold a dfidx object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.0-5</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-06-26</td>
</tr>
<tr>
<td>Title:</td>
<td>Indexed Data Frames</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, Formula</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, AER, mlogit, plm</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides extended data frames, with a special data frame column which contains two indexes, with potentially a nesting structure.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://cran.r-project.org/package=dfidx">https://cran.r-project.org/package=dfidx</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-26 09:45:54 UTC; yves</td>
</tr>
<tr>
<td>Author:</td>
<td>Yves Croissant [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yves Croissant &lt;yves.croissant@univ-reunion.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-28 12:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='dfidx'>Data frames with indexes</h2><span id='topic+dfidx'></span>

<h3>Description</h3>

<p>data frames for which observations are defined by two (potentialy
nested) indexes and for which series have thefore a natural tabular
representation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfidx(
  data,
  idx = NULL,
  drop.index = TRUE,
  as.factor = NULL,
  pkg = NULL,
  fancy.row.names = FALSE,
  subset = NULL,
  idnames = NULL,
  shape = c("long", "wide"),
  choice = NULL,
  varying = NULL,
  sep = ".",
  opposite = NULL,
  levels = NULL,
  ranked = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dfidx_+3A_data">data</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="dfidx_+3A_idx">idx</code></td>
<td>
<p>an index</p>
</td></tr>
<tr><td><code id="dfidx_+3A_drop.index">drop.index</code></td>
<td>
<p>if <code>TRUE</code> (the default), remove the index series
from the data.frame as stand alone series</p>
</td></tr>
<tr><td><code id="dfidx_+3A_as.factor">as.factor</code></td>
<td>
<p>should the indexes be coerced to factors ?</p>
</td></tr>
<tr><td><code id="dfidx_+3A_pkg">pkg</code></td>
<td>
<p>if set, the resulting <code>dfidx</code> object is of class
<code>c("dfidx_pkg", "dfidx")</code> which enables to write specific
classes</p>
</td></tr>
<tr><td><code id="dfidx_+3A_fancy.row.names">fancy.row.names</code></td>
<td>
<p>if <code>TRUE</code>, fancy row names are computed</p>
</td></tr>
<tr><td><code id="dfidx_+3A_subset">subset</code></td>
<td>
<p>a logical which defines a subset of rows to return</p>
</td></tr>
<tr><td><code id="dfidx_+3A_idnames">idnames</code></td>
<td>
<p>the names of the indexes</p>
</td></tr>
<tr><td><code id="dfidx_+3A_shape">shape</code></td>
<td>
<p>either <code>wide</code> or <code>long</code></p>
</td></tr>
<tr><td><code id="dfidx_+3A_choice">choice</code></td>
<td>
<p>the choice</p>
</td></tr>
<tr><td><code id="dfidx_+3A_varying">varying</code>, <code id="dfidx_+3A_sep">sep</code></td>
<td>
<p>relevant for data sets in wide format, these
arguments are passed to reshape</p>
</td></tr>
<tr><td><code id="dfidx_+3A_opposite">opposite</code></td>
<td>
<p>return the opposite of the series</p>
</td></tr>
<tr><td><code id="dfidx_+3A_levels">levels</code></td>
<td>
<p>the levels for the second index</p>
</td></tr>
<tr><td><code id="dfidx_+3A_ranked">ranked</code></td>
<td>
<p>a boolean for ranked data</p>
</td></tr>
<tr><td><code id="dfidx_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Indexes are stored as a <code>data.frame</code> column in the
resulting <code>dfidx</code> object
</p>


<h3>Value</h3>

<p>an object of class <code>"dfidx"</code>
</p>


<h3>Author(s)</h3>

<p>Yves Croissant
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("AER")){
data("TravelMode", package = "AER")

# the first two columns contain the index

TM1 &lt;- dfidx(TravelMode)

# explicitely indicate the two indexes using either a vector or a
# list of two characters

TM2 &lt;- dfidx(TravelMode, idx = c("individual", "mode"))

TM3 &lt;- dfidx(TravelMode, idx = list("individual", "mode"))

# rename one or both indexes

TM3b &lt;- dfidx(TravelMode, idnames = c(NA, "trmode"))

# for balanced data (with observations ordered by the first, then
# by the second index

# use the name of the first index

TM4 &lt;- dfidx(TravelMode, idx = "individual", idnames = c("individual", "mode"))

# or an integer equal to the cardinal of the first index

TM5 &lt;- dfidx(TravelMode, idx = 210, idnames = c("individual", "mode"))

# Indicate the values of the second index using the levels argument

TM5b &lt;- dfidx(TravelMode, idx = 210, idnames = c("individual", "mode"),
levels = c("air", "train", "bus", "car"))
}

# Nesting structure for one of the index
if (requireNamespace("mlogit")){
data("JapaneseFDI", package = "mlogit")
JapaneseFDI &lt;- dplyr::select(JapaneseFDI, 1:8)
JP1b &lt;- dfidx(JapaneseFDI, idx = list("firm", c("region", "country")),
idnames = c("japf", "iso80"))
}
# Data in wide format
if (requireNamespace("mlogit")){
data("Fishing", package = "mlogit")
Fi &lt;- dfidx(Fishing, shape = "wide", varying = 2:9, idnames = c("chid", "alt"))
}
</code></pre>

<hr>
<h2 id='dplyr'>Methods for dplyr verbs</h2><span id='topic+dplyr'></span><span id='topic+arrange.dfidx'></span><span id='topic+filter.dfidx'></span><span id='topic+slice.dfidx'></span><span id='topic+mutate.dfidx'></span><span id='topic+transmute.dfidx'></span><span id='topic+select.dfidx'></span>

<h3>Description</h3>

<p>methods of <code>dplyr</code> verbs for <code>dfidx</code> objects.  Default functions
don't work because most of these functions returns either a
<code>tibble</code> or a <code>data.frame</code> but not a <code>dfidx</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dfidx'
arrange(.data, ...)

## S3 method for class 'dfidx'
filter(.data, ...)

## S3 method for class 'dfidx'
slice(.data, ...)

## S3 method for class 'dfidx'
mutate(.data, ...)

## S3 method for class 'dfidx'
transmute(.data, ...)

## S3 method for class 'dfidx'
select(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dplyr_+3A_.data">.data</code></td>
<td>
<p>a dfidx object,</p>
</td></tr>
<tr><td><code id="dplyr_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These methods always return the data frame column that
contains the indexes and return a <code>dfidx</code> object.
</p>


<h3>Value</h3>

<p>an object of class <code>"dfidx"</code>
</p>


<h3>Author(s)</h3>

<p>Yves Croissant
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("AER")){
data("TravelMode", package = "AER")
TM &lt;- dfidx(TravelMode)
select(TM, - wait, - vcost)
mutate(TM, inc2  = income ^ 2, linc = log(income))
transmute(TM, inc2  = income ^ 2, linc = log(income))
arrange(TM, desc(size), income)
filter(TM, income &gt; 35, size &lt;= 2)
pull(TM, income)
slice(TM, c(1:2, 5:7))
}
</code></pre>

<hr>
<h2 id='idx'>Index for dfidx</h2><span id='topic+idx'></span><span id='topic+idx.dfidx'></span><span id='topic+idx.idx'></span><span id='topic+idx.xseries'></span><span id='topic+format.idx'></span>

<h3>Description</h3>

<p>The index of a <code>dfidx</code> is a dat .frame containing the different
series which define the two indexes (with possibly a nesting
structure). It is stored as a &quot;sticky&quot; data.frame column of the
data.frame and is also inherited by series (of class <code>'xseries'</code>)
which are extracted from a <code>dfidx</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idx(x, n = NULL, m = NULL)

## S3 method for class 'dfidx'
idx(x, n = NULL, m = NULL)

## S3 method for class 'idx'
idx(x, n = NULL, m = NULL)

## S3 method for class 'xseries'
idx(x, n = NULL, m = NULL)

## S3 method for class 'idx'
format(x, size = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idx_+3A_x">x</code></td>
<td>
<p>a <code>dfidx</code> or a <code>xseries</code></p>
</td></tr>
<tr><td><code id="idx_+3A_n">n</code>, <code id="idx_+3A_m">m</code></td>
<td>
<p><code>n</code> is the index to be extracted (1 or 2), <code>m</code> equal to
one to get the index, greater than one to get a nesting
variable.</p>
</td></tr>
<tr><td><code id="idx_+3A_size">size</code></td>
<td>
<p>the number of characters of the indexes for the format
method</p>
</td></tr>
<tr><td><code id="idx_+3A_...">...</code></td>
<td>
<p>further arguments (for now unused)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>idx is defined as a generic with a <code>dfidx</code> and a <code>xseries</code>
method.
</p>


<h3>Value</h3>

<p>a <code>data.frame</code> containing the indexes or a series if a
specific index is selected
</p>


<h3>Author(s)</h3>

<p>Yves Croissant
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("AER")){
data("TravelMode", package = "AER")
TM1 &lt;- dfidx(TravelMode)
idx(TM1)
inc &lt;- TM1$income
idx(inc)
# get the first index
idx(TM1, 1)
# get the second index
idx(TM1, 2)
idx(inc, 2)
}
</code></pre>

<hr>
<h2 id='idx_name'>Get the names of the indexes</h2><span id='topic+idx_name'></span><span id='topic+idx_name.dfidx'></span><span id='topic+idx_name.idx'></span><span id='topic+idx_name.xseries'></span>

<h3>Description</h3>

<p>This function extract the names of the indexes or the name of a
specific index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idx_name(x, n = 1, m = NULL)

## S3 method for class 'dfidx'
idx_name(x, n = NULL, m = NULL)

## S3 method for class 'idx'
idx_name(x, n = NULL, m = NULL)

## S3 method for class 'xseries'
idx_name(x, n = NULL, m = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idx_name_+3A_x">x</code></td>
<td>
<p>a <code>dfidx</code>, a <code>idx</code> or a <code>xseries</code> object</p>
</td></tr>
<tr><td><code id="idx_name_+3A_n">n</code></td>
<td>
<p>the index to be extracted (1 or 2, ignoring the nesting
variables)</p>
</td></tr>
<tr><td><code id="idx_name_+3A_m">m</code></td>
<td>
<p>if &gt; 1, a nesting variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if <code>n</code> is <code>NULL</code>, a named integer which gives the posititon
of the <code>idx</code> column in the <code>dfidx</code> object, otherwise, a
character of length 1
</p>


<h3>Author(s)</h3>

<p>Yves Croissant
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("mlogit")){
data("JapaneseFDI", package = "mlogit")
JapaneseFDI &lt;- dplyr::select(JapaneseFDI, 1:8)
JP1b &lt;- dfidx(JapaneseFDI, idx = list("firm", c("region", "country")),
idnames = c("japf", "iso80"))
# get the position of the idx column
idx_name(JP1b)
# get the name of the first index
idx_name(JP1b, 1)
# get the name of the second index
idx_name(JP1b, 2)
# get the name of the nesting variable for the second index
idx_name(JP1b, 2, 2)
}
</code></pre>

<hr>
<h2 id='methods.dfidx'>Methods for dfidx</h2><span id='topic+methods.dfidx'></span><span id='topic++5B.dfidx'></span><span id='topic+as.data.frame.dfidx'></span><span id='topic+print.dfidx'></span><span id='topic+head.dfidx'></span><span id='topic++5B+5B.dfidx'></span><span id='topic++24.dfidx'></span><span id='topic++24+3C-.dfidx'></span><span id='topic++5B+5B+3C-.dfidx'></span><span id='topic+print.xseries'></span><span id='topic+print.idx'></span><span id='topic+mean.dfidx'></span>

<h3>Description</h3>

<p>A <code>dfidx</code> is a <code>data.frame</code> with a &quot;sticky&quot; data.frame column
which contains the indexes. Specific methods of functions that
extract lines and/or columns of a <code>data.frame</code> are provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dfidx'
x[i, j, drop = TRUE]

## S3 method for class 'dfidx'
as.data.frame(x, row.names = NULL, optional = FALSE, ...)

## S3 method for class 'dfidx'
print(x, ..., n = 10L)

## S3 method for class 'dfidx'
head(x, n = 10L, ...)

## S3 method for class 'dfidx'
x[[y]]

## S3 method for class 'dfidx'
x$y

## S3 replacement method for class 'dfidx'
object$y &lt;- value

## S3 replacement method for class 'dfidx'
object[[y]] &lt;- value

## S3 method for class 'xseries'
print(x, ..., n = 10L)

## S3 method for class 'idx'
print(x, ..., n = 10L)

## S3 method for class 'dfidx'
mean(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="methods.dfidx_+3A_x">x</code>, <code id="methods.dfidx_+3A_object">object</code></td>
<td>
<p>a <code>dfidx</code> object</p>
</td></tr>
<tr><td><code id="methods.dfidx_+3A_i">i</code></td>
<td>
<p>the row index</p>
</td></tr>
<tr><td><code id="methods.dfidx_+3A_j">j</code></td>
<td>
<p>the column index</p>
</td></tr>
<tr><td><code id="methods.dfidx_+3A_drop">drop</code></td>
<td>
<p>if <code>TRUE</code> a vector is returned if the result is a one
column <code>data.frame</code></p>
</td></tr>
<tr><td><code id="methods.dfidx_+3A_row.names">row.names</code>, <code id="methods.dfidx_+3A_optional">optional</code></td>
<td>
<p>arguments of the generic <code>as.data.frame</code>
method, not used</p>
</td></tr>
<tr><td><code id="methods.dfidx_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
<tr><td><code id="methods.dfidx_+3A_n">n</code></td>
<td>
<p>the number of rows for the print method</p>
</td></tr>
<tr><td><code id="methods.dfidx_+3A_y">y</code></td>
<td>
<p>the name or the position of the series one wishes to
extract</p>
</td></tr>
<tr><td><code id="methods.dfidx_+3A_value">value</code></td>
<td>
<p>the value for the replacement method</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>as.data.frame</code> and <code>mean</code> return a <code>data.frame</code>, <code>[[</code> and
<code>$</code> a vector, <code>[</code> either a <code>dfidx</code> or a vector, <code style="white-space: pre;">&#8288;$&lt;-&#8288;</code>
and <code style="white-space: pre;">&#8288;[[&lt;-&#8288;</code> modify the values of an existing column or create a
new column of a <code>dfidx</code> object, <code>print</code> is called for its side
effect
</p>


<h3>Author(s)</h3>

<p>Yves Croissant
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("AER")){
data("TravelMode", package = "AER")
TM &lt;- dfidx(TravelMode)
# extract a series (returns as a xseries object)
TM$wait
# or
TM[["wait"]]
# extract a subset of series (returns as a dfidx object)
TM[c("wait", "income")]
# extract a subset of rows and columns
TM[TM$income &gt; 30, c("wait", "income")]
# dfidx, idx and xseries have print methods as (like tibbles), a n
# argument
print(TM, n = 3)
print(idx(TM), n = 3)
print(TM$income, n = 3)
# a dfidx object can be coerced to a data.frame
head(as.data.frame(TM))
}
</code></pre>

<hr>
<h2 id='model.frame.dfidx'>model.frame/matrix for dfidx objects</h2><span id='topic+model.frame.dfidx'></span><span id='topic+model.matrix.dfidx'></span>

<h3>Description</h3>

<p>Specific model.frame/matrix are provided for dfidx objects. This
leads to an unusual order of arguments compared to the
usage. Actually, the first two arguments of the model.frame method
are a dfidx and a formula and the only main argument of the
model.matrix is a dfidx which should be the result of a call to the
model.frame method, i.e. it should have a term attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dfidx'
model.frame(
  formula,
  data = NULL,
  ...,
  lhs = NULL,
  rhs = NULL,
  dot = "previous",
  alt.subset = NULL,
  reflevel = NULL,
  balanced = FALSE
)

## S3 method for class 'dfidx'
model.matrix(object, ..., lhs = NULL, rhs = 1, dot = "separate")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.frame.dfidx_+3A_formula">formula</code></td>
<td>
<p>a <code>dfidx</code></p>
</td></tr>
<tr><td><code id="model.frame.dfidx_+3A_data">data</code></td>
<td>
<p>a <code>formula</code></p>
</td></tr>
<tr><td><code id="model.frame.dfidx_+3A_...">...</code>, <code id="model.frame.dfidx_+3A_lhs">lhs</code>, <code id="model.frame.dfidx_+3A_rhs">rhs</code>, <code id="model.frame.dfidx_+3A_dot">dot</code></td>
<td>
<p>see the <code>Formula</code> method</p>
</td></tr>
<tr><td><code id="model.frame.dfidx_+3A_alt.subset">alt.subset</code></td>
<td>
<p>a subset of levels for the second index</p>
</td></tr>
<tr><td><code id="model.frame.dfidx_+3A_reflevel">reflevel</code></td>
<td>
<p>a user-defined first level for the second index</p>
</td></tr>
<tr><td><code id="model.frame.dfidx_+3A_balanced">balanced</code></td>
<td>
<p>a boolean indicating if the resulting data.frame
has to be balanced or not</p>
</td></tr>
<tr><td><code id="model.frame.dfidx_+3A_object">object</code></td>
<td>
<p>a dfidx object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>dfidx</code> object for the <code>model.frame</code> method and a matrix
for the <code>model.matrix</code> method.
</p>


<h3>Author(s)</h3>

<p>Yves Croissant
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("AER")){
data("TravelMode", package = "AER")
TM &lt;- dfidx(TravelMode)
mf &lt;- model.frame(TM, choice ~ vcost | income - 1 | travel)
head(model.matrix(mf, rhs = 1))
head(model.matrix(mf, rhs = 2))
head(model.matrix(mf, rhs = 1:3))
}
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+as_tibble'></span><span id='topic++25+3E+25'></span><span id='topic+filter'></span><span id='topic+arrange'></span><span id='topic+slice'></span><span id='topic+pull'></span><span id='topic+mutate'></span><span id='topic+transmute'></span><span id='topic+select'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+reexports">%&gt;%</a></code>, <code><a href="dplyr.html#topic+arrange">arrange</a></code>, <code><a href="dplyr.html#topic+reexports">as_tibble</a></code>, <code><a href="dplyr.html#topic+filter">filter</a></code>, <code><a href="dplyr.html#topic+mutate">mutate</a></code>, <code><a href="dplyr.html#topic+pull">pull</a></code>, <code><a href="dplyr.html#topic+select">select</a></code>, <code><a href="dplyr.html#topic+slice">slice</a></code>, <code><a href="dplyr.html#topic+mutate">transmute</a></code></p>
</dd>
</dl>

<hr>
<h2 id='unfold_idx'>Fold and Unfold a dfidx object</h2><span id='topic+unfold_idx'></span><span id='topic+fold_idx'></span>

<h3>Description</h3>

<p><code>fold_idx</code> takes a dfidx, includes the indexes as stand alone
columns, remove the <code>idx</code> column and return a data.frame, with an
<code>ids</code> attribute that contains the informations about the
indexes. <code>fold_idx</code> performs the opposite operation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unfold_idx(x)

fold_idx(x, pkg = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unfold_idx_+3A_x">x</code></td>
<td>
<p>a <code>dfidx</code> object</p>
</td></tr>
<tr><td><code id="unfold_idx_+3A_pkg">pkg</code></td>
<td>
<p>if not <code>NULL</code>, this argument is passed to <code>dfidx</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> for the <code>unfold_dfidx</code> function, a <code>dfidx</code>
object for the <code>fold_dfidx</code> function
</p>


<h3>Author(s)</h3>

<p>Yves Croissant
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("AER")){
data("TravelMode", package = "AER")
TM &lt;- dfidx(TravelMode)
TM2 &lt;- unfold_idx(TM)
attr(TM2, "ids")
TM3 &lt;- fold_idx(TM2)
identical(TM, TM3)
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
