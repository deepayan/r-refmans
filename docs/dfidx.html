<!DOCTYPE html><html lang="en"><head><title>Help for package dfidx</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dfidx}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dfidx'><p>Data frames with indexes</p></a></li>
<li><a href='#dplyr'><p>Methods for dplyr verbs</p></a></li>
<li><a href='#idx'><p>Index for dfidx</p></a></li>
<li><a href='#idx_name'><p>Get the names of the indexes</p></a></li>
<li><a href='#methods.dfidx'><p>Methods for dfidx</p></a></li>
<li><a href='#model.frame.dfidx'><p>model.frame/matrix for dfidx objects</p></a></li>
<li><a href='#munnell'><p>Productivity in the United States</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#unfold_idx'><p>Fold and Unfold a dfidx object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.1-0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-08-22</td>
</tr>
<tr>
<td>Title:</td>
<td>Indexed Data Frames</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, Formula, vctrs, pillar, glue, Rdpack, tidyselect</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, quarto</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides extended data frames, with a special data frame column which contains two indexes, with potentially a nesting structure.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://cran.r-project.org/package=dfidx">https://cran.r-project.org/package=dfidx</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>quarto</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-08-22 08:31:19 UTC; yves</td>
</tr>
<tr>
<td>Author:</td>
<td>Yves Croissant [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yves Croissant &lt;yves.croissant@univ-reunion.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-08-22 16:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='dfidx'>Data frames with indexes</h2><span id='topic+dfidx'></span>

<h3>Description</h3>

<p>data frames for which observations are defined by two (potentialy
nested) indexes and for which series have thefore a natural tabular
representation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfidx(
  data,
  idx = NULL,
  drop.index = TRUE,
  as.factor = NULL,
  pkg = NULL,
  fancy.row.names = FALSE,
  subset = NULL,
  idnames = NULL,
  shape = c("long", "wide"),
  choice = NULL,
  varying = NULL,
  sep = ".",
  opposite = NULL,
  levels = NULL,
  ranked = FALSE,
  name,
  position,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dfidx_+3A_data">data</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="dfidx_+3A_idx">idx</code></td>
<td>
<p>an index</p>
</td></tr>
<tr><td><code id="dfidx_+3A_drop.index">drop.index</code></td>
<td>
<p>if <code>TRUE</code> (the default), remove the index series
from the data.frame as stand alone series</p>
</td></tr>
<tr><td><code id="dfidx_+3A_as.factor">as.factor</code></td>
<td>
<p>should the indexes be coerced to factors ?</p>
</td></tr>
<tr><td><code id="dfidx_+3A_pkg">pkg</code></td>
<td>
<p>if set, the resulting <code>dfidx</code> object is of class
<code>c("dfidx_pkg", "dfidx")</code> which enables to write specific
classes</p>
</td></tr>
<tr><td><code id="dfidx_+3A_fancy.row.names">fancy.row.names</code></td>
<td>
<p>if <code>TRUE</code>, fancy row names are computed</p>
</td></tr>
<tr><td><code id="dfidx_+3A_subset">subset</code></td>
<td>
<p>a logical which defines a subset of rows to return</p>
</td></tr>
<tr><td><code id="dfidx_+3A_idnames">idnames</code></td>
<td>
<p>the names of the indexes</p>
</td></tr>
<tr><td><code id="dfidx_+3A_shape">shape</code></td>
<td>
<p>either <code>wide</code> or <code>long</code></p>
</td></tr>
<tr><td><code id="dfidx_+3A_choice">choice</code></td>
<td>
<p>the choice</p>
</td></tr>
<tr><td><code id="dfidx_+3A_varying">varying</code>, <code id="dfidx_+3A_sep">sep</code></td>
<td>
<p>relevant for data sets in wide format, these
arguments are passed to reshape</p>
</td></tr>
<tr><td><code id="dfidx_+3A_opposite">opposite</code></td>
<td>
<p>return the opposite of the series</p>
</td></tr>
<tr><td><code id="dfidx_+3A_levels">levels</code></td>
<td>
<p>the levels for the second index</p>
</td></tr>
<tr><td><code id="dfidx_+3A_ranked">ranked</code></td>
<td>
<p>a boolean for ranked data</p>
</td></tr>
<tr><td><code id="dfidx_+3A_name">name</code></td>
<td>
<p>name of the <code>idx</code> column</p>
</td></tr>
<tr><td><code id="dfidx_+3A_position">position</code></td>
<td>
<p>position of the <code>idx</code> column</p>
</td></tr>
<tr><td><code id="dfidx_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Indexes are stored as a <code>data.frame</code> column in the
resulting <code>dfidx</code> object
</p>


<h3>Value</h3>

<p>an object of class <code>"dfidx"</code>
</p>


<h3>Author(s)</h3>

<p>Yves Croissant
</p>


<h3>Examples</h3>

<pre><code class='language-R'># the first two columns contain the index
mn &lt;- dfidx(munnell)

# explicitely indicate the two indexes using either a vector or a
# list of two characters
mn &lt;- dfidx(munnell, idx = c("state", "year"))
mn &lt;- dfidx(munnell, idx = list("state", "year"))

# rename one or both indexes
mn &lt;- dfidx(munnell, idnames = c(NA, "period"))

# for balanced data (with observations ordered by the first, then
# by the second index

# use the name of the first index
mn &lt;- dfidx(munnell, idx = "state", idnames = c("state", "year"))

# or an integer equal to the cardinal of the first index
mn &lt;- dfidx(munnell, idx = 48, idnames = c("state", "year"))

# Indicate the values of the second index using the levels argument
mn &lt;- dfidx(munnell, idx = 48, idnames = c("state", "year"),
            levels = 1970:1986)

# Nesting structure for one of the index
mn &lt;- dfidx(munnell, idx = c(region = "state", president = "year"))

# Data in wide format
mn &lt;- dfidx(munnell_wide, idx = c(region = "state"),
            varying = 3:36, sep = "_", idnames = c(NA, "year"))

# Customize the name and the position of the `idx` column
#dfidx(munnell, position = 3, name = "index")
</code></pre>

<hr>
<h2 id='dplyr'>Methods for dplyr verbs</h2><span id='topic+dplyr'></span><span id='topic+arrange.dfidx'></span><span id='topic+filter.dfidx'></span><span id='topic+slice.dfidx'></span><span id='topic+mutate.dfidx'></span><span id='topic+transmute.dfidx'></span><span id='topic+select.dfidx'></span>

<h3>Description</h3>

<p>methods of <code>dplyr</code> verbs for <code>dfidx</code> objects.  Default functions
don't work because most of these functions returns either a
<code>tibble</code> or a <code>data.frame</code> but not a <code>dfidx</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dfidx'
arrange(.data, ...)

## S3 method for class 'dfidx'
filter(.data, ...)

## S3 method for class 'dfidx'
slice(.data, ...)

## S3 method for class 'dfidx'
mutate(.data, ...)

## S3 method for class 'dfidx'
transmute(.data, ...)

## S3 method for class 'dfidx'
select(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dplyr_+3A_.data">.data</code></td>
<td>
<p>a dfidx object,</p>
</td></tr>
<tr><td><code id="dplyr_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These methods always return the data frame column that
contains the indexes and return a <code>dfidx</code> object.
</p>


<h3>Value</h3>

<p>an object of class <code>"dfidx"</code>
</p>


<h3>Author(s)</h3>

<p>Yves Croissant
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mn &lt;- dfidx(munnell)
select(mn, - gsp, - water)
mutate(mn, lgsp = log(gsp), lgsp2 = lgsp ^ 2)
transmute(mn, lgsp = log(gsp), lgsp2 = lgsp ^ 2)
arrange(mn, desc(unemp), labor)
filter(mn, unemp &gt; 10)
pull(mn, gsp)
slice(mn, c(1:2, 5:7))
</code></pre>

<hr>
<h2 id='idx'>Index for dfidx</h2><span id='topic+idx'></span><span id='topic+idx.dfidx'></span><span id='topic+idx.idx'></span><span id='topic+idx.xseries'></span><span id='topic+format.idx'></span>

<h3>Description</h3>

<p>The index of a <code>dfidx</code> is a data.frame containing the different
series which define the two indexes (with possibly a nesting
structure). It is stored as a &quot;sticky&quot; data.frame column of the
data.frame and is also inherited by series (of class <code>'xseries'</code>)
which are extracted from a <code>dfidx</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idx(x, n = NULL, m = NULL)

## S3 method for class 'dfidx'
idx(x, n = NULL, m = NULL)

## S3 method for class 'idx'
idx(x, n = NULL, m = NULL)

## S3 method for class 'xseries'
idx(x, n = NULL, m = NULL)

## S3 method for class 'idx'
format(x, size = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="idx_+3A_x">x</code></td>
<td>
<p>a <code>dfidx</code> or a <code>xseries</code></p>
</td></tr>
<tr><td><code id="idx_+3A_n">n</code>, <code id="idx_+3A_m">m</code></td>
<td>
<p><code>n</code> is the index to be extracted (1 or 2), <code>m</code> equal to
one to get the index, greater than one to get a nesting
variable.</p>
</td></tr>
<tr><td><code id="idx_+3A_size">size</code></td>
<td>
<p>the number of characters of the indexes for the format
method</p>
</td></tr>
<tr><td><code id="idx_+3A_...">...</code></td>
<td>
<p>further arguments (for now unused)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>idx is defined as a generic with a <code>dfidx</code> and a <code>xseries</code>
method.
</p>


<h3>Value</h3>

<p>a <code>data.frame</code> containing the indexes or a series if a
specific index is selected
</p>


<h3>Author(s)</h3>

<p>Yves Croissant
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mn &lt;- dfidx(munnell, idx = c(region = "state", president = "year"))
idx(mn)
gsp &lt;- mn$gsp
idx(gsp)
# get the first index
idx(mn, 1)
# get the nesting variable of the first index
idx(mn, 1, 2)
</code></pre>

<hr>
<h2 id='idx_name'>Get the names of the indexes</h2><span id='topic+idx_name'></span><span id='topic+idx_name.dfidx'></span><span id='topic+idx_name.idx'></span><span id='topic+idx_name.xseries'></span>

<h3>Description</h3>

<p>This function extract the names of the indexes or the name of a
specific index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idx_name(x, n = 1, m = NULL)

## S3 method for class 'dfidx'
idx_name(x, n = NULL, m = NULL)

## S3 method for class 'idx'
idx_name(x, n = NULL, m = NULL)

## S3 method for class 'xseries'
idx_name(x, n = NULL, m = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="idx_name_+3A_x">x</code></td>
<td>
<p>a <code>dfidx</code>, a <code>idx</code> or a <code>xseries</code> object</p>
</td></tr>
<tr><td><code id="idx_name_+3A_n">n</code></td>
<td>
<p>the index to be extracted (1 or 2, ignoring the nesting
variables)</p>
</td></tr>
<tr><td><code id="idx_name_+3A_m">m</code></td>
<td>
<p>if &gt; 1, a nesting variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if <code>n</code> is <code>NULL</code>, a named integer which gives the posititon
of the <code>idx</code> column in the <code>dfidx</code> object, otherwise, a
character of length 1
</p>


<h3>Author(s)</h3>

<p>Yves Croissant
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mn &lt;- dfidx(munnell, idx = c(region = "state", president = "year"))
# get the position of the idx column
idx_name(mn)
# get the name of the first index
idx_name(mn, 1)
# get the name of the second index
idx_name(mn, 2)
# get the name of the nesting variable for the second index
idx_name(mn, 2, 2)
</code></pre>

<hr>
<h2 id='methods.dfidx'>Methods for dfidx</h2><span id='topic+methods.dfidx'></span><span id='topic++5B.dfidx'></span><span id='topic+as.data.frame.dfidx'></span><span id='topic+print.dfidx'></span><span id='topic+head.dfidx'></span><span id='topic++5B+5B.dfidx'></span><span id='topic++24.dfidx'></span><span id='topic++24+3C-.dfidx'></span><span id='topic++5B+5B+3C-.dfidx'></span><span id='topic+print.xseries'></span><span id='topic+print.idx'></span><span id='topic+mean.dfidx'></span>

<h3>Description</h3>

<p>A <code>dfidx</code> is a <code>data.frame</code> with a &quot;sticky&quot; data.frame column
which contains the indexes. Specific methods of functions that
extract lines and/or columns of a <code>data.frame</code> are provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dfidx'
x[i, j, drop]

## S3 method for class 'dfidx'
as.data.frame(x, row.names = NULL, optional = FALSE, ...)

## S3 method for class 'dfidx'
print(x, ..., n = 10L)

## S3 method for class 'dfidx'
head(x, n = 10L, ...)

## S3 method for class 'dfidx'
x[[y]]

## S3 method for class 'dfidx'
x$y

## S3 replacement method for class 'dfidx'
object$y &lt;- value

## S3 replacement method for class 'dfidx'
object[[y]] &lt;- value

## S3 method for class 'xseries'
print(x, ..., n = 10L)

## S3 method for class 'idx'
print(x, ..., n = 10L)

## S3 method for class 'dfidx'
mean(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="methods.dfidx_+3A_x">x</code>, <code id="methods.dfidx_+3A_object">object</code></td>
<td>
<p>a <code>dfidx</code> object</p>
</td></tr>
<tr><td><code id="methods.dfidx_+3A_i">i</code></td>
<td>
<p>the row index</p>
</td></tr>
<tr><td><code id="methods.dfidx_+3A_j">j</code></td>
<td>
<p>the column index</p>
</td></tr>
<tr><td><code id="methods.dfidx_+3A_drop">drop</code></td>
<td>
<p>if <code>TRUE</code> a vector is returned if the result is a one
column <code>data.frame</code></p>
</td></tr>
<tr><td><code id="methods.dfidx_+3A_row.names">row.names</code>, <code id="methods.dfidx_+3A_optional">optional</code></td>
<td>
<p>arguments of the generic <code>as.data.frame</code>
method, not used</p>
</td></tr>
<tr><td><code id="methods.dfidx_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
<tr><td><code id="methods.dfidx_+3A_n">n</code></td>
<td>
<p>the number of rows for the print method</p>
</td></tr>
<tr><td><code id="methods.dfidx_+3A_y">y</code></td>
<td>
<p>the name or the position of the series one wishes to
extract</p>
</td></tr>
<tr><td><code id="methods.dfidx_+3A_value">value</code></td>
<td>
<p>the value for the replacement method</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>as.data.frame</code> and <code>mean</code> return a <code>data.frame</code>, <code>[[</code> and
<code>$</code> a vector, <code>[</code> either a <code>dfidx</code> or a vector, <code style="white-space: pre;">&#8288;$&lt;-&#8288;</code>
and <code style="white-space: pre;">&#8288;[[&lt;-&#8288;</code> modify the values of an existing column or create a
new column of a <code>dfidx</code> object, <code>print</code> is called for its side
effect
</p>


<h3>Author(s)</h3>

<p>Yves Croissant
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mn &lt;- dfidx(munnell)
# extract a series (returns as a xseries object)
mn$gsp
# or
mn[["gsp"]]
# extract a subset of series (returns as a dfidx object)
mn[c("gsp", "unemp")]
# extract a subset of rows and columns
mn[mn$unemp &gt; 10, c("utilities", "water")]
# dfidx, idx and xseries have print methods as (like tibbles), a n
# argument
print(mn, n = 3)
print(idx(mn), n = 3)
print(mn$gsp, n = 3)
# a dfidx object can be coerced to a data.frame
head(as.data.frame(mn))
</code></pre>

<hr>
<h2 id='model.frame.dfidx'>model.frame/matrix for dfidx objects</h2><span id='topic+model.frame.dfidx'></span><span id='topic+model.matrix.dfidx'></span><span id='topic+print.dfidx_matrix'></span>

<h3>Description</h3>

<p>Specific model.frame/matrix are provided for dfidx objects. This
leads to an unusual order of arguments compared to the
usage. Actually, the first two arguments of the model.frame method
are a dfidx and a formula and the only main argument of the
model.matrix is a dfidx which should be the result of a call to the
model.frame method, i.e. it should have a term attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dfidx'
model.frame(
  formula,
  data = NULL,
  ...,
  lhs = NULL,
  rhs = NULL,
  dot = "previous",
  alt.subset = NULL,
  reflevel = NULL,
  balanced = FALSE
)

## S3 method for class 'dfidx'
model.matrix(object, ..., lhs = NULL, rhs = 1, dot = "separate")

## S3 method for class 'dfidx_matrix'
print(x, ..., n = 10L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model.frame.dfidx_+3A_formula">formula</code></td>
<td>
<p>a <code>dfidx</code></p>
</td></tr>
<tr><td><code id="model.frame.dfidx_+3A_data">data</code></td>
<td>
<p>a <code>formula</code></p>
</td></tr>
<tr><td><code id="model.frame.dfidx_+3A_...">...</code>, <code id="model.frame.dfidx_+3A_lhs">lhs</code>, <code id="model.frame.dfidx_+3A_rhs">rhs</code>, <code id="model.frame.dfidx_+3A_dot">dot</code></td>
<td>
<p>see the <code>Formula</code> method</p>
</td></tr>
<tr><td><code id="model.frame.dfidx_+3A_alt.subset">alt.subset</code></td>
<td>
<p>a subset of levels for the second index</p>
</td></tr>
<tr><td><code id="model.frame.dfidx_+3A_reflevel">reflevel</code></td>
<td>
<p>a user-defined first level for the second index</p>
</td></tr>
<tr><td><code id="model.frame.dfidx_+3A_balanced">balanced</code></td>
<td>
<p>a boolean indicating if the resulting data.frame
has to be balanced or not</p>
</td></tr>
<tr><td><code id="model.frame.dfidx_+3A_object">object</code></td>
<td>
<p>a dfidx object</p>
</td></tr>
<tr><td><code id="model.frame.dfidx_+3A_x">x</code></td>
<td>
<p>a model matrix</p>
</td></tr>
<tr><td><code id="model.frame.dfidx_+3A_n">n</code></td>
<td>
<p>the number of lines to print</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>dfidx</code> object for the <code>model.frame</code> method and a matrix
for the <code>model.matrix</code> method.
</p>


<h3>Author(s)</h3>

<p>Yves Croissant
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mn &lt;- dfidx(munnell)
mf &lt;- model.frame(mn, gsp ~ privatecap | publiccap + utilities | unemp + labor)
model.matrix(mf, rhs = 1)
model.matrix(mf, rhs = 2)
model.matrix(mf, rhs = 1:3)
</code></pre>

<hr>
<h2 id='munnell'>Productivity in the United States</h2><span id='topic+munnell'></span><span id='topic+munnell_wide'></span>

<h3>Description</h3>

<p>a panel data of 48 American States for 17 years, from 1970 to 1986
</p>


<h3>Usage</h3>

<pre><code class='language-R'>munnell

munnell_wide
</code></pre>


<h3>Format</h3>

<p>a tibble containing:
</p>

<ul>
<li><p> state: the state
</p>
</li>
<li><p> year: the year
</p>
</li>
<li><p> region: one of the 9 regions of the United States
</p>
</li>
<li><p> president: the name of the president for the given year
</p>
</li>
<li><p> publiccap: public capital stock
</p>
</li>
<li><p> highway: highway and streets
</p>
</li>
<li><p> water: water and sewer facilities
</p>
</li>
<li><p> utilities: othe public building and structures
</p>
</li>
<li><p> privatecap: private capital stock
</p>
</li>
<li><p> gsp: gross state product
</p>
</li>
<li><p> labor: labor input measured by the employment in non&ndash;agricultural payrolls
</p>
</li>
<li><p> unemp: state unemployment rate
</p>
</li></ul>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 48 rows and 36 columns.
</p>


<h3>Source</h3>

<p>online complements to Baltagi (2001): <a href="https://www.wiley.com/legacy/wileychi/baltagi/">https://www.wiley.com/legacy/wileychi/baltagi/</a>
Online complements to Baltagi (2013): <a href="https://bcs.wiley.com/he-bcs/Books?action=resource&amp;bcsId=4338&amp;itemId=1118672321&amp;resourceId=13452">https://bcs.wiley.com/he-bcs/Books?action=resource&amp;bcsId=4338&amp;itemId=1118672321&amp;resourceId=13452</a>
</p>


<h3>References</h3>

<p>Baltagi BH (2001).
<em>Econometric Analysis of Panel Data</em>, 3rd edition.
John Wiley and Sons ltd.
Baltagi BH (2013).
<em>Econometric Analysis of Panel Data</em>, 5th edition.
John Wiley and Sons ltd.
Baltagi BH, Pinnoi N (1995).
&ldquo;Public capital stock and state productivity growth: further evidence from an error components model.&rdquo;
<em>Empirical Economics</em>, <b>20</b>, 351-359.
Munnell A (1990).
&ldquo;Why Has Productivity Growth Declined? Productivity and Public Investment.&rdquo;
<em>New England Economic Review</em>, 3&ndash;22.
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+as_tibble'></span><span id='topic++25+3E+25'></span><span id='topic+filter'></span><span id='topic+arrange'></span><span id='topic+slice'></span><span id='topic+pull'></span><span id='topic+mutate'></span><span id='topic+transmute'></span><span id='topic+select'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+reexports">%&gt;%</a></code>, <code><a href="dplyr.html#topic+arrange">arrange</a></code>, <code><a href="dplyr.html#topic+reexports">as_tibble</a></code>, <code><a href="dplyr.html#topic+filter">filter</a></code>, <code><a href="dplyr.html#topic+mutate">mutate</a></code>, <code><a href="dplyr.html#topic+pull">pull</a></code>, <code><a href="dplyr.html#topic+select">select</a></code>, <code><a href="dplyr.html#topic+slice">slice</a></code>, <code><a href="dplyr.html#topic+transmute">transmute</a></code></p>
</dd>
</dl>

<hr>
<h2 id='unfold_idx'>Fold and Unfold a dfidx object</h2><span id='topic+unfold_idx'></span><span id='topic+fold_idx'></span>

<h3>Description</h3>

<p><code>fold_idx</code> takes a dfidx, includes the indexes as stand alone
columns, remove the <code>idx</code> column and return a data.frame, with an
<code>ids</code> attribute that contains the informations about the
indexes. <code>fold_idx</code> performs the opposite operation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unfold_idx(x)

fold_idx(x, pkg = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unfold_idx_+3A_x">x</code></td>
<td>
<p>a <code>dfidx</code> object</p>
</td></tr>
<tr><td><code id="unfold_idx_+3A_pkg">pkg</code></td>
<td>
<p>if not <code>NULL</code>, this argument is passed to <code>dfidx</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>data.frame</code> for the <code>unfold_dfidx</code> function, a <code>dfidx</code>
object for the <code>fold_dfidx</code> function
</p>


<h3>Author(s)</h3>

<p>Yves Croissant
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mn &lt;- dfidx(munnell, idx = c(region = "state", "year"), position = 3, name = "index")
mn2 &lt;- unfold_idx(mn)
attr(mn, "ids")
mn3 &lt;- fold_idx(mn2)
identical(mn, mn3)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
