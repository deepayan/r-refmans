<!DOCTYPE html><html><head><title>Help for package readsdr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {readsdr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#create_stan_function'><p>Create a Stan's ODE function from an XMILE file</p></a></li>
<li><a href='#expit'><p>Expit transformation</p></a></li>
<li><a href='#extract_timeseries_stock'><p>Extract the values over time of a stock from a Stan fit</p></a></li>
<li><a href='#extract_timeseries_var'><p>Extract the values over time of a variable from a Stan fit</p></a></li>
<li><a href='#inv'><p>Inverse of a number</p></a></li>
<li><a href='#logit'><p>Logit transformation</p></a></li>
<li><a href='#Maryland'><p>Influenza in Maryland during the 1918 pandemic</p></a></li>
<li><a href='#read_xmile'><p>Read an XMILE file into R</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#sd_Bayes'><p>Create Stan file for Bayesian inference</p></a></li>
<li><a href='#sd_constants'><p>Summarise the information of a model's constants in a data frame</p></a></li>
<li><a href='#sd_data_generator_fun'><p>Function factory for SBC</p></a></li>
<li><a href='#sd_fixed_delay'><p>Fixed delay</p></a></li>
<li><a href='#sd_impact_inputs'><p>Construct inputs for performing structural analysis via the impact method</p></a></li>
<li><a href='#sd_interpret_estimates'><p>Interpret estimates</p></a></li>
<li><a href='#sd_loglik_fun'><p>Generate a log-likelihood function for an SD model</p></a></li>
<li><a href='#sd_measurements'><p>Generate measurements</p></a></li>
<li><a href='#sd_net_change'><p>Estimate the net change of a stock in discrete times</p></a></li>
<li><a href='#sd_posterior_fun'><p>Posterior function</p></a></li>
<li><a href='#sd_prior'><p>SD prior</p></a></li>
<li><a href='#sd_prior_checks'><p>Prior predictive checks</p></a></li>
<li><a href='#sd_pulse_s'><p>Replicate the behaviour of the PULSE function from Stella</p></a></li>
<li><a href='#sd_pulse_train'><p>PULSE TRAIN</p></a></li>
<li><a href='#sd_pulse_v'><p>Replicate the behaviour of the PULSE function from Vensim</p></a></li>
<li><a href='#sd_sensitivity_run'><p>Perform a sensitivity run on a System Dynamics model</p></a></li>
<li><a href='#sd_simulate'><p>Simulate a System Dynamics model</p></a></li>
<li><a href='#sd_stocks'><p>Summarise the information of a model's stocks in a data frame</p></a></li>
<li><a href='#sd_what_if_from_time'><p>What if from time t we change the value of some parameters</p></a></li>
<li><a href='#stan_ode_function'><p>Create Stan ODE function</p></a></li>
<li><a href='#xmile_to_deSolve'><p>Parse XMILE to deSolve components</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Translate Models from System Dynamics Software into 'R'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Description:</td>
<td>The goal of 'readsdr' is to bridge the design capabilities from
    specialised System Dynamics software with the powerful numerical tools 
    offered by 'R' libraries. The package accomplishes this goal by parsing 
    'XMILE' files ('Vensim' and 'Stella') models into 'R' objects to construct 
    networks (graph theory); 'ODE' functions for 'Stan'; and inputs to simulate
    via 'deSolve' as described in Duggan (2016) &lt;<a href="https://doi.org/10.1007%2F978-3-319-34043-2">doi:10.1007/978-3-319-34043-2</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 2.1.0), igraph, knitr, rmarkdown, ggplot2,
tidyr, truncnorm</td>
</tr>
<tr>
<td>Imports:</td>
<td>stringr, xml2, purrr, dplyr, rlang, stringi, magrittr, stats,
deSolve, utils, future, future.apply, progressr</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jandraor/readsdr/issues">https://github.com/jandraor/readsdr/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-05 15:40:16 UTC; jandraor</td>
</tr>
<tr>
<td>Author:</td>
<td>Jair Andrade <a href="https://orcid.org/0000-0002-1412-7868"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jair Andrade &lt;jair.albert.andrade@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-05 15:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='create_stan_function'>Create a Stan's ODE function from an XMILE file</h2><span id='topic+create_stan_function'></span>

<h3>Description</h3>

<p><code>create_stan_function</code> returns a string with the code for a Stan's ODE function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_stan_function(
  filepath,
  func_name,
  pars = NULL,
  override.consts = NULL,
  additional_funs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_stan_function_+3A_filepath">filepath</code></td>
<td>
<p>A string that indicates a path to a file with extension .stmx
or .xmile. Vensim files (.mdl) are not xmile files. They must be exported
from Vensim with extension .xmile</p>
</td></tr>
<tr><td><code id="create_stan_function_+3A_func_name">func_name</code></td>
<td>
<p>A string for naming the ODE function</p>
</td></tr>
<tr><td><code id="create_stan_function_+3A_pars">pars</code></td>
<td>
<p>A character vector that indicates which constants will be
considered as parameters in the ODE function</p>
</td></tr>
<tr><td><code id="create_stan_function_+3A_override.consts">override.consts</code></td>
<td>
<p>A list in which each element is a name-value pair that
replaces values of constants.</p>
</td></tr>
<tr><td><code id="create_stan_function_+3A_additional_funs">additional_funs</code></td>
<td>
<p>A vector of strings. Each string corresponds to a
user-defined function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extracts the xml from the file specified via <code>filepath</code> to
generate the code for an equivalent model in Stan.
</p>


<h3>Value</h3>

<p>A string with the code containing the model's equations in the
format required by Stan.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("models", "SIR.stmx", package = "readsdr")
create_stan_function(path, "my_model")
</code></pre>

<hr>
<h2 id='expit'>Expit transformation</h2><span id='topic+expit'></span>

<h3>Description</h3>

<p>Expit transformation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expit(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expit_+3A_x">x</code></td>
<td>
<p>A real number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number in the range 0 to 1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>expit(-3)
</code></pre>

<hr>
<h2 id='extract_timeseries_stock'>Extract the values over time of a stock from a Stan fit</h2><span id='topic+extract_timeseries_stock'></span>

<h3>Description</h3>

<p>Extract the values over time of a stock from a Stan fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_timeseries_stock(stock_name, posterior_df, all_stocks, ODE_output)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_timeseries_stock_+3A_stock_name">stock_name</code></td>
<td>
<p>A string that indicates the stock's name for which the
function will construct the timeseries.</p>
</td></tr>
<tr><td><code id="extract_timeseries_stock_+3A_posterior_df">posterior_df</code></td>
<td>
<p>A Stan fit object converted into a data frame</p>
</td></tr>
<tr><td><code id="extract_timeseries_stock_+3A_all_stocks">all_stocks</code></td>
<td>
<p>A vector of strings that contains the names of all the
stocks in the model. This vector must have the same order as the differential
equations in the Stan code.</p>
</td></tr>
<tr><td><code id="extract_timeseries_stock_+3A_ode_output">ODE_output</code></td>
<td>
<p>A string that indicates the name of the variable where
model's output in stored in Stan.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>posterior_df &lt;- data.frame(`yhat[1,2]` = rep(0, 2), `yhat[2,2]` = rep(1, 2),
                            check.names = FALSE)
stocks       &lt;- c("S1", "S2")
extract_timeseries_stock("S2", posterior_df, stocks, "yhat")
</code></pre>

<hr>
<h2 id='extract_timeseries_var'>Extract the values over time of a variable from a Stan fit</h2><span id='topic+extract_timeseries_var'></span>

<h3>Description</h3>

<p>Extract the values over time of a variable from a Stan fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_timeseries_var(var_name, posterior_df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_timeseries_var_+3A_var_name">var_name</code></td>
<td>
<p>A string that indicates the variable's name for which the
function will construct the timeseries.</p>
</td></tr>
<tr><td><code id="extract_timeseries_var_+3A_posterior_df">posterior_df</code></td>
<td>
<p>A Stan fit object converted into a data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>posterior_df &lt;- data.frame(`var[1]` = rep(0, 2), `var[2]` = rep(1, 2),
                            check.names = FALSE)
extract_timeseries_var("var", posterior_df)
</code></pre>

<hr>
<h2 id='inv'>Inverse of a number</h2><span id='topic+inv'></span>

<h3>Description</h3>

<p>Inverse of a number
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inv(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inv_+3A_x">x</code></td>
<td>
<p>A real number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A real number
</p>


<h3>Examples</h3>

<pre><code class='language-R'>inv(0.5) # Should return 2
</code></pre>

<hr>
<h2 id='logit'>Logit transformation</h2><span id='topic+logit'></span>

<h3>Description</h3>

<p>Logit transformation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit(p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logit_+3A_p">p</code></td>
<td>
<p>A real number that represents a probability</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An unconstrained real number
</p>


<h3>Examples</h3>

<pre><code class='language-R'>logit(0.5)
</code></pre>

<hr>
<h2 id='Maryland'>Influenza in Maryland during the 1918 pandemic</h2><span id='topic+Maryland'></span>

<h3>Description</h3>

<p>Influenza in Maryland during the 1918 pandemic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Maryland
</code></pre>


<h3>Format</h3>

<p>A data frame with 91 rows and 6 columns:
</p>

<dl>
<dt>Date</dt><dd><p>Date</p>
</dd>
<dt>Baltimore</dt><dd><p>Cases reported in the Baltimore</p>
</dd>
<dt>Cumberland</dt><dd><p>Cases reported in the Cumberland</p>
</dd>
<dt>Lonaconing</dt><dd><p>Cases reported in the Lonaconing</p>
</dd>
<dt>Frederick</dt><dd><p>Cases reported in the Frederick</p>
</dd>
<dt>Salisbury</dt><dd><p>Cases reported in the Salisbury</p>
</dd>
</dl>



<h3>Source</h3>

<p>&lt;https://doi.org/10.2307/4575056&gt;
</p>

<hr>
<h2 id='read_xmile'>Read an XMILE file into R</h2><span id='topic+read_xmile'></span>

<h3>Description</h3>

<p><code>read_xmile</code> returns a list for constructing deSolve functions and graphs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_xmile(filepath, stock_list = NULL, const_list = NULL, graph = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_xmile_+3A_filepath">filepath</code></td>
<td>
<p>A string that indicates a path to a file with extension .stmx
or .xmile. Vensim files (.mdl) are not xmile files. They must be exported
from Vensim with extension .xmile</p>
</td></tr>
<tr><td><code id="read_xmile_+3A_stock_list">stock_list</code></td>
<td>
<p>A list in which each element's name is the name of the
stock to override and the element's value correspond to the new init value.</p>
</td></tr>
<tr><td><code id="read_xmile_+3A_const_list">const_list</code></td>
<td>
<p>A list in which each element's name is the name of the
constant to override and the element's value correspond to the new value.</p>
</td></tr>
<tr><td><code id="read_xmile_+3A_graph">graph</code></td>
<td>
<p>A boolean parameter that indicates whether <code>read_xmile</code>
returns a graph for the model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extracts the xml from the file specified via <code>filepath</code>
to generate a list of objects. Such a list contains a summary of the model,
the inputs for simulating through <a href="deSolve.html#topic+deSolve">deSolve</a>, and the inputs for
creating a <a href="igraph.html#topic+igraph">igraph</a> object.
</p>


<h3>Value</h3>

<p>This function returns a list with three elements. The first element,
<em>description</em>, is a list that contains the simulation parameters, and
the names and equations (including graphical functions) for each stock or
level, variable and constant. The second element, <em>deSolve_components</em>,
is a list that contains initial values, constants and the function for
simulating via deSolve. The third element (optional), <em>igraph</em> contains
the data.frames for creating a graph with igraph.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("models", "SIR.stmx", package = "readsdr")
read_xmile(path)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3E+25'></span><span id='topic+timestep'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>deSolve</dt><dd><p><code><a href="deSolve.html#topic+deSolve-internal">timestep</a></code></p>
</dd>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic+pipe">%&gt;%</a></code></p>
</dd>
</dl>

<hr>
<h2 id='sd_Bayes'>Create Stan file for Bayesian inference</h2><span id='topic+sd_Bayes'></span>

<h3>Description</h3>

<p>Create Stan file for Bayesian inference
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sd_Bayes(
  filepath,
  meas_mdl,
  estimated_params,
  data_params = NULL,
  data_inits = NULL,
  const_list = NULL,
  forecast = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sd_Bayes_+3A_filepath">filepath</code></td>
<td>
<p>A string that indicates a path to a file with extension .stmx
or .xmile. Vensim files (.mdl) are not xmile files. They must be exported
from Vensim with extension .xmile</p>
</td></tr>
<tr><td><code id="sd_Bayes_+3A_meas_mdl">meas_mdl</code></td>
<td>
<p>A list of strings. Each string corresponds to a sampling
statement written in Stan language.</p>
</td></tr>
<tr><td><code id="sd_Bayes_+3A_estimated_params">estimated_params</code></td>
<td>
<p>A list of lists. Each sublist describes each
parameter that will be estimated in the inference stage. To construct this
description, the user can avail of the function 'sd_prior'.</p>
</td></tr>
<tr><td><code id="sd_Bayes_+3A_data_params">data_params</code></td>
<td>
<p>An optional string vector defining which model
parameters will be configured through the Stan data block. That is, the
user will provide fixed values for such parameters at every Stan run.</p>
</td></tr>
<tr><td><code id="sd_Bayes_+3A_data_inits">data_inits</code></td>
<td>
<p>An optional string vector defining which model
parameters that <strong>only affect initial values</strong> (of stocks) will be
configured through the Stan data block. That is, the user will provide fixed
values for such parameters at every Stan run.</p>
</td></tr>
<tr><td><code id="sd_Bayes_+3A_const_list">const_list</code></td>
<td>
<p>A list in which each element's name is the name of the
constant to override and the element's value correspond to the new value.</p>
</td></tr>
<tr><td><code id="sd_Bayes_+3A_forecast">forecast</code></td>
<td>
<p>An optional boolean that indicates whether the Stan file
supports a forecast. If <code>TRUE</code>, the <strong>data</strong> block requires the
user to supply an integer value for <code>n_fcst</code>. This variable corresponds
to the number of periods that will be predicted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string
</p>


<h3>Negative binomial measurement component</h3>

<p>While this package aims to avoid making decisions for users whenever
possible, I have taken the liberty to automate the transformation of phi
(the concentration parameter) when using the Negative Binomial distribution
(<a href="https://mc-stan.org/docs/functions-reference/nbalt.html">alternative parameterisation</a>)
as a measurement component. <code>sd_Bayes()</code> automatically creates an
inverse phi parameter for computational efficiency, which will be subject to
inference (instead of phi). Additionally, I have provided a default prior for
this inv_phi but users can override it as needed.
</p>


<h3>Time</h3>

<p>Simulation of the ordinary differential equation (ODE) model starts at time 0.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  filepath         &lt;- system.file("models/", "SEIR.stmx", package = "readsdr")
  mm1              &lt;- "y ~ neg_binomial_2(net_flow(C), phi)"
  meas_mdl         &lt;- list(mm1)
  estimated_params &lt;- list(
    sd_prior("par_beta", "lognormal", c(0, 1)),
    sd_prior("par_rho", "beta", c(2, 2)),
    sd_prior("I0", "lognormal", c(0, 1), "init"))
  sd_Bayes(filepath, meas_mdl, estimated_params)
</code></pre>

<hr>
<h2 id='sd_constants'>Summarise the information of a model's constants in a data frame</h2><span id='topic+sd_constants'></span>

<h3>Description</h3>

<p>Summarise the information of a model's constants in a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sd_constants(mdl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sd_constants_+3A_mdl">mdl</code></td>
<td>
<p>A list which is the output from read_xmile.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("models", "SIR.stmx", package = "readsdr")
mdl  &lt;- read_xmile(path)
sd_constants(mdl)
</code></pre>

<hr>
<h2 id='sd_data_generator_fun'>Function factory for SBC</h2><span id='topic+sd_data_generator_fun'></span>

<h3>Description</h3>

<p>Function factory for SBC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sd_data_generator_fun(
  filepath,
  estimated_params,
  meas_mdl,
  start_time = NULL,
  stop_time = NULL,
  timestep = NULL,
  integ_method = "euler"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sd_data_generator_fun_+3A_filepath">filepath</code></td>
<td>
<p>A string that indicates a path to a file with extension .stmx
or .xmile. Vensim files (.mdl) are not xmile files. They must be exported
from Vensim with extension .xmile</p>
</td></tr>
<tr><td><code id="sd_data_generator_fun_+3A_estimated_params">estimated_params</code></td>
<td>
<p>A list of lists. Each sublist describes each
parameter that will be estimated in the inference stage. To construct this
description, the user can avail of the function 'sd_prior'.</p>
</td></tr>
<tr><td><code id="sd_data_generator_fun_+3A_meas_mdl">meas_mdl</code></td>
<td>
<p>A list of strings. Each string corresponds to a sampling
statement written in Stan language.</p>
</td></tr>
<tr><td><code id="sd_data_generator_fun_+3A_start_time">start_time</code></td>
<td>
<p>A number indicating the time at which the simulation begins.</p>
</td></tr>
<tr><td><code id="sd_data_generator_fun_+3A_stop_time">stop_time</code></td>
<td>
<p>A number indicating the time at which the simulation ends.</p>
</td></tr>
<tr><td><code id="sd_data_generator_fun_+3A_timestep">timestep</code></td>
<td>
<p>A number indicating the time interval for the simulation.
Also known as <code>dt</code>.</p>
</td></tr>
<tr><td><code id="sd_data_generator_fun_+3A_integ_method">integ_method</code></td>
<td>
<p>A string indicating the integration method. It can be
either &quot;euler&quot; or &quot;rk4&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  filepath &lt;- system.file("models/", "SEIR.stmx", package = "readsdr")
  meas_mdl &lt;- list("y ~ poisson(net_flow(C))")
  estimated_params &lt;- list(
    sd_prior("par_beta", "lognormal", c(0, 1)),
    sd_prior("par_rho", "beta", c(2, 2)),
    sd_prior("I0", "lognormal", c(0, 1), "init"))
  sd_data_generator_fun(filepath, estimated_params, meas_mdl)
</code></pre>

<hr>
<h2 id='sd_fixed_delay'>Fixed delay</h2><span id='topic+sd_fixed_delay'></span>

<h3>Description</h3>

<p>Fixed delay
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sd_fixed_delay(var, time, delay, init, .memory)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sd_fixed_delay_+3A_var">var</code></td>
<td>
<p>A string that indicates the delayed variable.</p>
</td></tr>
<tr><td><code id="sd_fixed_delay_+3A_time">time</code></td>
<td>
<p>A number that indicates current simulation time.</p>
</td></tr>
<tr><td><code id="sd_fixed_delay_+3A_delay">delay</code></td>
<td>
<p>A number that indicates the delay time.</p>
</td></tr>
<tr><td><code id="sd_fixed_delay_+3A_init">init</code></td>
<td>
<p>A number that indicates the function's output value of at the
start of the simulation.</p>
</td></tr>
<tr><td><code id="sd_fixed_delay_+3A_.memory">.memory</code></td>
<td>
<p>A data frame that keeps past values of delayed variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.memory &lt;- data.frame(time = 3, inflow = 3)
rownames(.memory) &lt;- 3
sd_fixed_delay("inflow", 5, 2, 0, .memory)
</code></pre>

<hr>
<h2 id='sd_impact_inputs'>Construct inputs for performing structural analysis via the impact method</h2><span id='topic+sd_impact_inputs'></span>

<h3>Description</h3>

<p>Construct inputs for performing structural analysis via the impact method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sd_impact_inputs(desc_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sd_impact_inputs_+3A_desc_list">desc_list</code></td>
<td>
<p>Element 'description' from the list returned by <code>read_xmile()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of three elements. The first element, <code>flows</code>, is a data
frame that lists all the stock-flow links in the model. Further, this data
frame describes the equation that governs the link and whether the link is
an inflow (+) or an outflow (-). The second element, <code>pathways</code>, is a
data frame that lists all the pathways among stocks. The third element,
<code>velocities</code>, is a data frame in which each row corresponds to a
stock. Each row consists of two columns (name  &amp; equation).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  filepath  &lt;- system.file("models/", "SIR.stmx", package = "readsdr")
  mdl       &lt;- read_xmile(filepath)
  desc_list &lt;- mdl$description
  sd_impact_inputs(desc_list)
</code></pre>

<hr>
<h2 id='sd_interpret_estimates'>Interpret estimates</h2><span id='topic+sd_interpret_estimates'></span>

<h3>Description</h3>

<p>Interpret estimates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sd_interpret_estimates(estimates, par_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sd_interpret_estimates_+3A_estimates">estimates</code></td>
<td>
<p>A list or data frame</p>
</td></tr>
<tr><td><code id="sd_interpret_estimates_+3A_par_list">par_list</code></td>
<td>
<p>A list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  estimates &lt;- c(par_beta = 0,
                 par_rho  = 0.8472979,
                 I0       = 0,
                 inv_phi  = -2.302585)

  par_list &lt;- list(list(par_name  = "par_beta",
                        par_trans = "exp"),
                   list(par_name  = "par_rho",
                        par_trans = "expit"),
                   list(par_name  = "I0",
                        par_trans = "exp"),
                   list(par_name  = "phi",
                        par_trans = c("exp", "inv")))
  sd_interpret_estimates(estimates, par_list)
</code></pre>

<hr>
<h2 id='sd_loglik_fun'>Generate a log-likelihood function for an SD model</h2><span id='topic+sd_loglik_fun'></span>

<h3>Description</h3>

<p>Generate a log-likelihood function for an SD model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sd_loglik_fun(
  filepath,
  unknown_pars,
  meas_data_mdl,
  neg_log = FALSE,
  supplied_pars = NULL,
  start_time = NULL,
  stop_time = NULL,
  timestep = NULL,
  integ_method = "euler",
  const_list = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sd_loglik_fun_+3A_filepath">filepath</code></td>
<td>
<p>A string that indicates a path to a file with extension .stmx
or .xmile. Vensim files (.mdl) are not xmile files. They must be exported
from Vensim with extension .xmile</p>
</td></tr>
<tr><td><code id="sd_loglik_fun_+3A_unknown_pars">unknown_pars</code></td>
<td>
<p>A list of lists. Each second-level list contains at least
the element name <code>name</code>, which corresponds to the parameter's name
subject to estimation. In addition to the element <code>name</code>, users can
incorporate in the sub-list the elements <code>min</code> and <code>max</code>. The
value of <code>min</code> can only be <code>0</code>, whereas the value of <code>max</code>
can only be <code>1</code>.</p>
</td></tr>
<tr><td><code id="sd_loglik_fun_+3A_meas_data_mdl">meas_data_mdl</code></td>
<td>
<p>A list of lists. Each second-level list corresponds to
a sampling statement along with its measurements. Here is an example: <br />
<code>list(formula      = "y ~ neg_binomial_2(net_flow(C), phi)",
           measurements = 1:10))</code></p>
</td></tr>
<tr><td><code id="sd_loglik_fun_+3A_neg_log">neg_log</code></td>
<td>
<p>A boolean that indicates whether the log-likelihood function
returns a positive or negative value. If <code>TRUE</code>, the function
returns a positive value (for minimisation optimisers). If
<code>FALSE</code>, the function returns the original log-likelihood.</p>
</td></tr>
<tr><td><code id="sd_loglik_fun_+3A_supplied_pars">supplied_pars</code></td>
<td>
<p>A string vector indicating the name of parameters whose
values will be supplied to the function. These values will not be subject to
optimisation.</p>
</td></tr>
<tr><td><code id="sd_loglik_fun_+3A_start_time">start_time</code></td>
<td>
<p>A number indicating the time at which the simulation begins.</p>
</td></tr>
<tr><td><code id="sd_loglik_fun_+3A_stop_time">stop_time</code></td>
<td>
<p>A number indicating the time at which the simulation ends.</p>
</td></tr>
<tr><td><code id="sd_loglik_fun_+3A_timestep">timestep</code></td>
<td>
<p>A number indicating the time interval for the simulation.
Also known as <code>dt</code>.</p>
</td></tr>
<tr><td><code id="sd_loglik_fun_+3A_integ_method">integ_method</code></td>
<td>
<p>A string indicating the integration method. It can be
either &quot;euler&quot; or &quot;rk4&quot;</p>
</td></tr>
<tr><td><code id="sd_loglik_fun_+3A_const_list">const_list</code></td>
<td>
<p>A list in which each element's name is the name of the
constant to override and the element's value correspond to the new value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of three elements. The first element, <code>fun</code>, corresponds
to the log likelihood function. The second element, <code>par_names</code>,
indicates the order in which the unknowns are returned. The third element,
<code>sim_params</code>, corresponds to the simulation parameters (start time,
stop time, and the integration step or dt) employed by the solver function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> filepath      &lt;- system.file("models/", "SEIR.stmx", package = "readsdr")
 unknown_pars  &lt;- list(list(par_name = "par_beta", min = 0))
 meas_data_mdl &lt;- list(list(formula      = "y ~ neg_binomial_2(net_flow(C), phi)",
                            measurements = 1:10))
 fun_obj &lt;- sd_loglik_fun(filepath, unknown_pars, meas_data_mdl, neg_log = FALSE,
                          start_time = 0, stop_time = 10, timestep = 1/32)
</code></pre>

<hr>
<h2 id='sd_measurements'>Generate measurements</h2><span id='topic+sd_measurements'></span>

<h3>Description</h3>

<p>Generate measurements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sd_measurements(
  n_meas,
  meas_model,
  ds_inputs,
  start_time = NULL,
  stop_time = NULL,
  timestep = NULL,
  integ_method = "euler"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sd_measurements_+3A_n_meas">n_meas</code></td>
<td>
<p>Number of measurements. An integer.</p>
</td></tr>
<tr><td><code id="sd_measurements_+3A_meas_model">meas_model</code></td>
<td>
<p>Measurement model. A list of strings, in which each string
corresponds to sampling statement in Stan language.</p>
</td></tr>
<tr><td><code id="sd_measurements_+3A_ds_inputs">ds_inputs</code></td>
<td>
<p>A list of deSolve inputs generated by read_xmile</p>
</td></tr>
<tr><td><code id="sd_measurements_+3A_start_time">start_time</code></td>
<td>
<p>A number indicating the time at which the simulation begins.</p>
</td></tr>
<tr><td><code id="sd_measurements_+3A_stop_time">stop_time</code></td>
<td>
<p>A number indicating the time at which the simulation ends.</p>
</td></tr>
<tr><td><code id="sd_measurements_+3A_timestep">timestep</code></td>
<td>
<p>A number indicating the time interval for the simulation.
Also known as <code>dt</code>.</p>
</td></tr>
<tr><td><code id="sd_measurements_+3A_integ_method">integ_method</code></td>
<td>
<p>A string indicating the integration method. It can be
either &quot;euler&quot; or &quot;rk4&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  filepath &lt;- system.file("models/", "SEIR.stmx", package = "readsdr")
  mdl      &lt;- read_xmile(filepath)

  mm1        &lt;- "y ~ poisson(C)"
  meas_model &lt;- list(mm1)

  sd_measurements(n_meas       = 2,
                  meas_model   = meas_model,
                  ds_inputs    = mdl$deSolve_components,
                  start_time   = 0,
                  stop_time    = 10,
                  timestep     = 1/16,
                  integ_method = "rk4")
</code></pre>

<hr>
<h2 id='sd_net_change'>Estimate the net change of a stock in discrete times</h2><span id='topic+sd_net_change'></span>

<h3>Description</h3>

<p>Estimate the net change of a stock in discrete times
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sd_net_change(sim_df, cumulative_var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sd_net_change_+3A_sim_df">sim_df</code></td>
<td>
<p>A data frame with the simulation output</p>
</td></tr>
<tr><td><code id="sd_net_change_+3A_cumulative_var">cumulative_var</code></td>
<td>
<p>A string that indicates to which variable the discrete
change will be estimated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_output &lt;- data.frame(time = seq(0, 2, by = 0.25),
                          C    = c(0, rep(5,4), rep(20, 4)))
sd_net_change(test_output, "C")
</code></pre>

<hr>
<h2 id='sd_posterior_fun'>Posterior function</h2><span id='topic+sd_posterior_fun'></span>

<h3>Description</h3>

<p>Posterior function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sd_posterior_fun(
  filepath,
  meas_data_mdl,
  estimated_params,
  start_time = NULL,
  stop_time = NULL,
  timestep = NULL,
  integ_method = "euler",
  const_list = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sd_posterior_fun_+3A_filepath">filepath</code></td>
<td>
<p>A string that indicates a path to a file with extension .stmx
or .xmile. Vensim files (.mdl) are not xmile files. They must be exported
from Vensim with extension .xmile</p>
</td></tr>
<tr><td><code id="sd_posterior_fun_+3A_meas_data_mdl">meas_data_mdl</code></td>
<td>
<p>A list of lists. Each second-level list corresponds to
a sampling statement along with its measurements. Here is an example: <br />
<code>list(formula      = "y ~ neg_binomial_2(net_flow(C), phi)",
           measurements = 1:10))</code></p>
</td></tr>
<tr><td><code id="sd_posterior_fun_+3A_estimated_params">estimated_params</code></td>
<td>
<p>A list of lists. Each sublist describes each
parameter that will be estimated in the inference stage. To construct this
description, the user can avail of the function 'sd_prior'.</p>
</td></tr>
<tr><td><code id="sd_posterior_fun_+3A_start_time">start_time</code></td>
<td>
<p>A number indicating the time at which the simulation begins.</p>
</td></tr>
<tr><td><code id="sd_posterior_fun_+3A_stop_time">stop_time</code></td>
<td>
<p>A number indicating the time at which the simulation ends.</p>
</td></tr>
<tr><td><code id="sd_posterior_fun_+3A_timestep">timestep</code></td>
<td>
<p>A number indicating the time interval for the simulation.
Also known as <code>dt</code>.</p>
</td></tr>
<tr><td><code id="sd_posterior_fun_+3A_integ_method">integ_method</code></td>
<td>
<p>A string indicating the integration method. It can be
either &quot;euler&quot; or &quot;rk4&quot;</p>
</td></tr>
<tr><td><code id="sd_posterior_fun_+3A_const_list">const_list</code></td>
<td>
<p>A list in which each element's name is the name of the
constant to override and the element's value correspond to the new value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>filepath         &lt;- system.file("models/", "SEIR.stmx", package = "readsdr")
meas_data_mdl &lt;- list(list(formula      = "y ~ neg_binomial_2(net_flow(C), phi)",
                            measurements = 1:10))
estimated_params &lt;- list(
  sd_prior("par_beta", "lognormal", c(0, 1)),
  sd_prior("par_rho", "beta", c(2, 2)),
  sd_prior("I0", "lognormal", c(0, 1), "init"))
fun &lt;- sd_posterior_fun(filepath, meas_data_mdl, estimated_params)
</code></pre>

<hr>
<h2 id='sd_prior'>SD prior</h2><span id='topic+sd_prior'></span>

<h3>Description</h3>

<p>SD prior
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sd_prior(par_name, dist, dist_pars, type = "constant", min_0 = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sd_prior_+3A_par_name">par_name</code></td>
<td>
<p>A string</p>
</td></tr>
<tr><td><code id="sd_prior_+3A_dist">dist</code></td>
<td>
<p>A string</p>
</td></tr>
<tr><td><code id="sd_prior_+3A_dist_pars">dist_pars</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="sd_prior_+3A_type">type</code></td>
<td>
<p>A string. It can be either 'constant' or 'init'. It is 'constant'
by default. 'init' refers to parameters that have only affect the model at
time 0.</p>
</td></tr>
<tr><td><code id="sd_prior_+3A_min_0">min_0</code></td>
<td>
<p>An optional boolean indicating whether the prior has a lower
bound at zero. In the current implementation, this parameter only has an
effect on normal priors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sd_prior("par_beta", "lognormal", c(0, 1))
sd_prior("par_rho", "normal", c(0, 1), min_0 = TRUE)
</code></pre>

<hr>
<h2 id='sd_prior_checks'>Prior predictive checks</h2><span id='topic+sd_prior_checks'></span>

<h3>Description</h3>

<p>Prior predictive checks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sd_prior_checks(
  filepath,
  meas_mdl,
  estimated_params,
  n_draws,
  start_time = NULL,
  stop_time = NULL,
  timestep = NULL,
  integ_method = "euler"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sd_prior_checks_+3A_filepath">filepath</code></td>
<td>
<p>A string that indicates a path to a file with extension .stmx
or .xmile. Vensim files (.mdl) are not xmile files. They must be exported
from Vensim with extension .xmile</p>
</td></tr>
<tr><td><code id="sd_prior_checks_+3A_meas_mdl">meas_mdl</code></td>
<td>
<p>A list of strings. Each string corresponds to a sampling
statement written in Stan language.</p>
</td></tr>
<tr><td><code id="sd_prior_checks_+3A_estimated_params">estimated_params</code></td>
<td>
<p>A list of lists. Each sublist describes each
parameter that will be estimated in the inference stage. To construct this
description, the user can avail of the function 'sd_prior'.</p>
</td></tr>
<tr><td><code id="sd_prior_checks_+3A_n_draws">n_draws</code></td>
<td>
<p>An integer that indicates how many time-series will be
returned.</p>
</td></tr>
<tr><td><code id="sd_prior_checks_+3A_start_time">start_time</code></td>
<td>
<p>A number indicating the time at which the simulation begins.</p>
</td></tr>
<tr><td><code id="sd_prior_checks_+3A_stop_time">stop_time</code></td>
<td>
<p>A number indicating the time at which the simulation ends.</p>
</td></tr>
<tr><td><code id="sd_prior_checks_+3A_timestep">timestep</code></td>
<td>
<p>A number indicating the time interval for the simulation.
Also known as <code>dt</code>.</p>
</td></tr>
<tr><td><code id="sd_prior_checks_+3A_integ_method">integ_method</code></td>
<td>
<p>A string indicating the integration method. It can be
either &quot;euler&quot; or &quot;rk4&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two data frames.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  filepath &lt;- system.file("models/", "SEIR.stmx", package = "readsdr")
  meas_mdl   &lt;- list("y ~ neg_binomial_2(net_flow(C), phi)")
  estimated_params &lt;- list(
    sd_prior("par_beta", "lognormal", c(0, 1)),
    sd_prior("par_rho", "beta", c(2, 2)),
    sd_prior("I0", "lognormal", c(0, 1), "init"))
  sd_prior_checks(filepath, meas_mdl, estimated_params, n_draws = 2,
   start_time = 0, stop_time = 5,
   integ_method = "rk4", timestep = 1/32)
</code></pre>

<hr>
<h2 id='sd_pulse_s'>Replicate the behaviour of the PULSE function from Stella</h2><span id='topic+sd_pulse_s'></span>

<h3>Description</h3>

<p>This function must be placed inside the object that will be passed as the
argument <code>func</code> to deSolve's <code>ode</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sd_pulse_s(time, volume, start_p, interval)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sd_pulse_s_+3A_time">time</code></td>
<td>
<p>A number</p>
</td></tr>
<tr><td><code id="sd_pulse_s_+3A_volume">volume</code></td>
<td>
<p>A number</p>
</td></tr>
<tr><td><code id="sd_pulse_s_+3A_start_p">start_p</code></td>
<td>
<p>A number</p>
</td></tr>
<tr><td><code id="sd_pulse_s_+3A_interval">interval</code></td>
<td>
<p>A number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number
</p>


<h3>Examples</h3>

<pre><code class='language-R'>timestep &lt;- function() 0.25 # replicates timestep() from deSolve
sd_pulse_s(2, 1, 2, 0)

</code></pre>

<hr>
<h2 id='sd_pulse_train'>PULSE TRAIN</h2><span id='topic+sd_pulse_train'></span>

<h3>Description</h3>

<p>PULSE TRAIN
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sd_pulse_train(time, start_pulse, duration_pulse, repeat_pt, end_pulse)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sd_pulse_train_+3A_time">time</code></td>
<td>
<p>A numeric argument that indicates the current simulation time</p>
</td></tr>
<tr><td><code id="sd_pulse_train_+3A_start_pulse">start_pulse</code></td>
<td>
<p>A numeric argument that indicates the start of the pulse</p>
</td></tr>
<tr><td><code id="sd_pulse_train_+3A_duration_pulse">duration_pulse</code></td>
<td>
<p>A numeric argument that indicates the width of the pulse</p>
</td></tr>
<tr><td><code id="sd_pulse_train_+3A_repeat_pt">repeat_pt</code></td>
<td>
<p>A numeric argument that indicates the repetition pattern</p>
</td></tr>
<tr><td><code id="sd_pulse_train_+3A_end_pulse">end_pulse</code></td>
<td>
<p>A numeric argument that indicates the end of the sequence</p>
</td></tr>
</table>


<h3>Value</h3>

<p>1 during the pulse, 0 otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sd_pulse_train(5, 5, 3, 10, 20)
</code></pre>

<hr>
<h2 id='sd_pulse_v'>Replicate the behaviour of the PULSE function from Vensim</h2><span id='topic+sd_pulse_v'></span>

<h3>Description</h3>

<p>Replicate the behaviour of the PULSE function from Vensim
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sd_pulse_v(time, startPulse, duration)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sd_pulse_v_+3A_time">time</code></td>
<td>
<p>A number</p>
</td></tr>
<tr><td><code id="sd_pulse_v_+3A_startpulse">startPulse</code></td>
<td>
<p>A number</p>
</td></tr>
<tr><td><code id="sd_pulse_v_+3A_duration">duration</code></td>
<td>
<p>A number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number
</p>


<h3>Examples</h3>

<pre><code class='language-R'>timestep &lt;- function() 0.25 # replicates timestep() from deSolve
sd_pulse_v(1, 1, 2)
</code></pre>

<hr>
<h2 id='sd_sensitivity_run'>Perform a sensitivity run on a System Dynamics model</h2><span id='topic+sd_sensitivity_run'></span>

<h3>Description</h3>

<p><code>sd_sensitivity_run</code> returns a data frame with the simulation of a
model for several iterations of different inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sd_sensitivity_run(
  ds_inputs,
  consts_df = NULL,
  stocks_df = NULL,
  start_time = NULL,
  stop_time = NULL,
  timestep = NULL,
  integ_method = "euler",
  multicore = FALSE,
  n_cores = NULL,
  reporting_interval = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sd_sensitivity_run_+3A_ds_inputs">ds_inputs</code></td>
<td>
<p>A list of deSolve inputs generated by read_xmile</p>
</td></tr>
<tr><td><code id="sd_sensitivity_run_+3A_consts_df">consts_df</code></td>
<td>
<p>A data frame that contains the values of constants to
simulate. Each column corresponds to a constant and each row to an
iteration. If <code>stocks_df</code> is also supplied, both data frames must have
the same number of rows.</p>
</td></tr>
<tr><td><code id="sd_sensitivity_run_+3A_stocks_df">stocks_df</code></td>
<td>
<p>A data frame that containts the initial value of stocks to
be explored. Each column corresponds to a stock and each row to an
iteration. If <code>consts_df</code> is also supplied, both data frames must have
the same number of rows.</p>
</td></tr>
<tr><td><code id="sd_sensitivity_run_+3A_start_time">start_time</code></td>
<td>
<p>A number indicating the time at which the simulation begins.</p>
</td></tr>
<tr><td><code id="sd_sensitivity_run_+3A_stop_time">stop_time</code></td>
<td>
<p>A number indicating the time at which the simulation ends.</p>
</td></tr>
<tr><td><code id="sd_sensitivity_run_+3A_timestep">timestep</code></td>
<td>
<p>A number indicating the time interval for the simulation.
Also known as <code>dt</code>.</p>
</td></tr>
<tr><td><code id="sd_sensitivity_run_+3A_integ_method">integ_method</code></td>
<td>
<p>A string indicating the integration method. It can be
either &quot;euler&quot; or &quot;rk4&quot;</p>
</td></tr>
<tr><td><code id="sd_sensitivity_run_+3A_multicore">multicore</code></td>
<td>
<p>A boolean value that indicates whether the process
is parallelised.</p>
</td></tr>
<tr><td><code id="sd_sensitivity_run_+3A_n_cores">n_cores</code></td>
<td>
<p>An integer indicating the number of cores for the parallel run.</p>
</td></tr>
<tr><td><code id="sd_sensitivity_run_+3A_reporting_interval">reporting_interval</code></td>
<td>
<p>A real number indicating the interval at which the
simulation results are returned. The default is set to <code>1</code>. For
instance, if the simulation runs from 0 to 10. This function returns the
results at times 0, 1, 2, ..., 10.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path      &lt;- system.file("models", "SIR.stmx", package = "readsdr")
ds_inputs &lt;- xmile_to_deSolve(path)
consts_df &lt;- data.frame(i = c(0.25, 0.30))
sd_sensitivity_run(ds_inputs, consts_df)
</code></pre>

<hr>
<h2 id='sd_simulate'>Simulate a System Dynamics model</h2><span id='topic+sd_simulate'></span>

<h3>Description</h3>

<p>Simulate a System Dynamics model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sd_simulate(
  ds_inputs,
  start_time = NULL,
  stop_time = NULL,
  timestep = NULL,
  integ_method = "euler"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sd_simulate_+3A_ds_inputs">ds_inputs</code></td>
<td>
<p>A list of deSolve inputs generated by read_xmile</p>
</td></tr>
<tr><td><code id="sd_simulate_+3A_start_time">start_time</code></td>
<td>
<p>A number indicating the time at which the simulation begins.</p>
</td></tr>
<tr><td><code id="sd_simulate_+3A_stop_time">stop_time</code></td>
<td>
<p>A number indicating the time at which the simulation ends.</p>
</td></tr>
<tr><td><code id="sd_simulate_+3A_timestep">timestep</code></td>
<td>
<p>A number indicating the time interval for the simulation.
Also known as <code>dt</code>.</p>
</td></tr>
<tr><td><code id="sd_simulate_+3A_integ_method">integ_method</code></td>
<td>
<p>A string indicating the integration method. It can be
either &quot;euler&quot; or &quot;rk4&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path      &lt;- system.file("models", "SIR.stmx", package = "readsdr")
ds_inputs &lt;- xmile_to_deSolve(path)
sd_simulate(ds_inputs, 0, 1, 0.25, "rk4")
</code></pre>

<hr>
<h2 id='sd_stocks'>Summarise the information of a model's stocks in a data frame</h2><span id='topic+sd_stocks'></span>

<h3>Description</h3>

<p>Summarise the information of a model's stocks in a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sd_stocks(mdl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sd_stocks_+3A_mdl">mdl</code></td>
<td>
<p>A list which is the output from read_xmile.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("models", "SIR.stmx", package = "readsdr")
mdl  &lt;- read_xmile(path)
sd_stocks(mdl)
</code></pre>

<hr>
<h2 id='sd_what_if_from_time'>What if from time t we change the value of some parameters</h2><span id='topic+sd_what_if_from_time'></span>

<h3>Description</h3>

<p>What if from time t we change the value of some parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sd_what_if_from_time(
  time,
  up_to_time = Inf,
  par_list,
  ds_inputs,
  start_time = NULL,
  stop_time = NULL,
  timestep = NULL,
  integ_method = "euler"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sd_what_if_from_time_+3A_time">time</code></td>
<td>
<p>Time at which the parameter values change</p>
</td></tr>
<tr><td><code id="sd_what_if_from_time_+3A_up_to_time">up_to_time</code></td>
<td>
<p>Time from which the original values are restored.</p>
</td></tr>
<tr><td><code id="sd_what_if_from_time_+3A_par_list">par_list</code></td>
<td>
<p>A list that indicates which parameters change from time t.
For instance, if you wanted to change the value of parameter <code>c</code> to 4,
you would provide the <code>list(c = 4)</code></p>
</td></tr>
<tr><td><code id="sd_what_if_from_time_+3A_ds_inputs">ds_inputs</code></td>
<td>
<p>A list of deSolve inputs generated by read_xmile</p>
</td></tr>
<tr><td><code id="sd_what_if_from_time_+3A_start_time">start_time</code></td>
<td>
<p>A number indicating the time at which the simulation begins.</p>
</td></tr>
<tr><td><code id="sd_what_if_from_time_+3A_stop_time">stop_time</code></td>
<td>
<p>A number indicating the time at which the simulation ends.</p>
</td></tr>
<tr><td><code id="sd_what_if_from_time_+3A_timestep">timestep</code></td>
<td>
<p>A number indicating the time interval for the simulation.
Also known as <code>dt</code>.</p>
</td></tr>
<tr><td><code id="sd_what_if_from_time_+3A_integ_method">integ_method</code></td>
<td>
<p>A string indicating the integration method. It can be
either &quot;euler&quot; or &quot;rk4&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  filepath       &lt;- system.file("models/", "SIR.stmx", package = "readsdr")
  mdl            &lt;- read_xmile(filepath)
  ds_components  &lt;- mdl$deSolve_components
  output         &lt;- sd_what_if_from_time(3, Inf, list(c = 4), ds_components)
</code></pre>

<hr>
<h2 id='stan_ode_function'>Create Stan ODE function</h2><span id='topic+stan_ode_function'></span>

<h3>Description</h3>

<p>Create Stan ODE function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan_ode_function(
  filepath,
  func_name,
  pars = NULL,
  const_list = NULL,
  extra_funs = NULL,
  XMILE_structure
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stan_ode_function_+3A_filepath">filepath</code></td>
<td>
<p>A string that indicates a path to a file with extension .stmx
or .xmile. Vensim files (.mdl) are not xmile files. They must be exported
from Vensim with extension .xmile</p>
</td></tr>
<tr><td><code id="stan_ode_function_+3A_func_name">func_name</code></td>
<td>
<p>A string for naming the ODE function</p>
</td></tr>
<tr><td><code id="stan_ode_function_+3A_pars">pars</code></td>
<td>
<p>A character vector that indicates which constants will be
considered as parameters in the ODE function</p>
</td></tr>
<tr><td><code id="stan_ode_function_+3A_const_list">const_list</code></td>
<td>
<p>A list in which each element's name is the name of the
constant to override and the element's value correspond to the new value.</p>
</td></tr>
<tr><td><code id="stan_ode_function_+3A_extra_funs">extra_funs</code></td>
<td>
<p>A vector of strings. Each string corresponds to a
user-defined function.</p>
</td></tr>
<tr><td><code id="stan_ode_function_+3A_xmile_structure">XMILE_structure</code></td>
<td>
<p>A list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string with the code containing a function with the model's
equations in the format required by cmdstan 2.24+.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("models", "SIR.stmx", package = "readsdr")
stan_ode_function(path, "my_model")
</code></pre>

<hr>
<h2 id='xmile_to_deSolve'>Parse XMILE to deSolve components</h2><span id='topic+xmile_to_deSolve'></span>

<h3>Description</h3>

<p><code>xmile_to_deSolve</code> returns a list that serves as an input for
deSolve's ODE function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmile_to_deSolve(filepath)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xmile_to_deSolve_+3A_filepath">filepath</code></td>
<td>
<p>A string that indicates a path to a file with extension .stmx
or .xmile. Vensim files (.mdl) are not xmile files. They must be exported
from Vensim with extension .xmile</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extracts the xml from the file specified via <code>filepath</code>
to generate a list with the necessary elements to simulate with
<a href="deSolve.html#topic+deSolve">deSolve</a>.
</p>


<h3>Value</h3>

<p>This function returns a list with at least four elements.
<em>stocks</em>, a numeric vector that contains initial values. <em>consts</em>,
a numeric vector with the model's constants. <em>func</em>, the function that
wraps the model's equations. <em>sim_params</em>, a list with control
parameters. If the model includes a table or graphical function, this
function returns the element <em>graph_funs</em>, a list with these functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- system.file("models", "SIR.stmx", package = "readsdr")
xmile_to_deSolve(path)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
