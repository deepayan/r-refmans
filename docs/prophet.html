<!DOCTYPE html><html><head><title>Help for package prophet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {prophet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_changepoints_to_plot'><p>Get layers to overlay significant changepoints on prophet forecast plot.</p></a></li>
<li><a href='#add_country_holidays'><p>Add in built-in holidays for the specified country.</p></a></li>
<li><a href='#add_group_component'><p>Adds a component with given name that contains all of the components</p>
in group.</a></li>
<li><a href='#add_regressor'><p>Add an additional regressor to be used for fitting and predicting.</p></a></li>
<li><a href='#add_seasonality'><p>Add a seasonal component with specified period, number of Fourier</p>
components, and prior scale.</a></li>
<li><a href='#construct_holiday_dataframe'><p>Construct a dataframe of holiday dates.</p></a></li>
<li><a href='#coverage'><p>Coverage</p></a></li>
<li><a href='#cross_validation'><p>Cross-validation for time series.</p></a></li>
<li><a href='#df_for_plotting'><p>Merge history and forecast for plotting.</p></a></li>
<li><a href='#dyplot.prophet'><p>Plot the prophet forecast.</p></a></li>
<li><a href='#fit.prophet'><p>Fit the prophet model.</p></a></li>
<li><a href='#flat_growth_init'><p>Initialize flat growth.</p></a></li>
<li><a href='#flat_trend'><p>Evaluate the flat trend function.</p></a></li>
<li><a href='#fourier_series'><p>Provides Fourier series components with the specified frequency and order.</p></a></li>
<li><a href='#generate_cutoffs'><p>Generate cutoff dates</p></a></li>
<li><a href='#generated_holidays'><p>holidays table</p></a></li>
<li><a href='#get_holiday_names'><p>Return all possible holiday names of given country</p></a></li>
<li><a href='#initialize_scales_fn'><p>Initialize model scales.</p></a></li>
<li><a href='#linear_growth_init'><p>Initialize constant growth.</p></a></li>
<li><a href='#logistic_growth_init'><p>Initialize logistic growth.</p></a></li>
<li><a href='#mae'><p>Mean absolute error</p></a></li>
<li><a href='#make_all_seasonality_features'><p>Dataframe with seasonality features.</p>
Includes seasonality features, holiday features, and added regressors.</a></li>
<li><a href='#make_future_dataframe'><p>Make dataframe with future dates for forecasting.</p></a></li>
<li><a href='#make_holiday_features'><p>Construct a matrix of holiday features.</p></a></li>
<li><a href='#make_holidays_df'><p>Make dataframe of holidays for given years and countries</p></a></li>
<li><a href='#make_seasonality_features'><p>Data frame with seasonality features.</p></a></li>
<li><a href='#mape'><p>Mean absolute percent error</p></a></li>
<li><a href='#mdape'><p>Median absolute percent error</p></a></li>
<li><a href='#mse'><p>Mean squared error</p></a></li>
<li><a href='#parse_seasonality_args'><p>Get number of Fourier components for built-in seasonalities.</p></a></li>
<li><a href='#performance_metrics'><p>Compute performance metrics from cross-validation results.</p></a></li>
<li><a href='#piecewise_linear'><p>Evaluate the piecewise linear function.</p></a></li>
<li><a href='#piecewise_logistic'><p>Evaluate the piecewise logistic function.</p></a></li>
<li><a href='#plot_cross_validation_metric'><p>Plot a performance metric vs. forecast horizon from cross validation.</p>
Cross validation produces a collection of out-of-sample model predictions
that can be compared to actual values, at a range of different horizons
(distance from the cutoff). This computes a specified performance metric
for each prediction, and aggregated over a rolling window with horizon.</a></li>
<li><a href='#plot_forecast_component'><p>Plot a particular component of the forecast.</p></a></li>
<li><a href='#plot_seasonality'><p>Plot a custom seasonal component.</p></a></li>
<li><a href='#plot_weekly'><p>Plot the weekly component of the forecast.</p></a></li>
<li><a href='#plot_yearly'><p>Plot the yearly component of the forecast.</p></a></li>
<li><a href='#plot.prophet'><p>Plot the prophet forecast.</p></a></li>
<li><a href='#predict_seasonal_components'><p>Predict seasonality components, holidays, and added regressors.</p></a></li>
<li><a href='#predict_trend'><p>Predict trend using the prophet model.</p></a></li>
<li><a href='#predict_uncertainty'><p>Prophet uncertainty intervals for yhat and trend</p></a></li>
<li><a href='#predict.prophet'><p>Predict using the prophet model.</p></a></li>
<li><a href='#predictive_samples'><p>Sample from the posterior predictive distribution.</p></a></li>
<li><a href='#prophet'><p>Prophet forecaster.</p></a></li>
<li><a href='#prophet_copy'><p>Copy Prophet object.</p></a></li>
<li><a href='#prophet_plot_components'><p>Plot the components of a prophet forecast.</p>
Prints a ggplot2 with whichever are available of: trend, holidays, weekly
seasonality, yearly seasonality, and additive and multiplicative extra
regressors.</a></li>
<li><a href='#regressor_coefficients'><p>Summarise the coefficients of the extra regressors used in the model.</p>
For additive regressors, the coefficient represents the incremental impact
on <code>y</code> of a unit increase in the regressor. For multiplicative regressors,
the incremental impact is equal to <code>trend(t)</code> multiplied by the coefficient.</a></li>
<li><a href='#regressor_column_matrix'><p>Dataframe indicating which columns of the feature matrix correspond to</p>
which seasonality/regressor components.</a></li>
<li><a href='#rmse'><p>Root mean squared error</p></a></li>
<li><a href='#rolling_mean_by_h'><p>Compute a rolling mean of x, after first aggregating by h</p></a></li>
<li><a href='#rolling_median_by_h'><p>Compute a rolling median of x, after first aggregating by h</p></a></li>
<li><a href='#sample_model'><p>Simulate observations from the extrapolated generative model.</p></a></li>
<li><a href='#sample_posterior_predictive'><p>Prophet posterior predictive samples.</p></a></li>
<li><a href='#sample_predictive_trend'><p>Simulate the trend using the extrapolated generative model.</p></a></li>
<li><a href='#seasonality_plot_df'><p>Prepare dataframe for plotting seasonal components.</p></a></li>
<li><a href='#set_auto_seasonalities'><p>Set seasonalities that were left on auto.</p></a></li>
<li><a href='#set_changepoints'><p>Set changepoints</p></a></li>
<li><a href='#set_date'><p>Convert date vector</p></a></li>
<li><a href='#setup_dataframe'><p>Prepare dataframe for fitting or predicting.</p></a></li>
<li><a href='#single_cutoff_forecast'><p>Forecast for a single cutoff.</p>
Used in cross_validation function when evaluating for multiple cutoffs.</a></li>
<li><a href='#smape'><p>Symmetric mean absolute percentage error</p>
based on Chen and Yang (2004) formula</a></li>
<li><a href='#time_diff'><p>Time difference between datetimes</p></a></li>
<li><a href='#validate_column_name'><p>Validates the name of a seasonality, holiday, or regressor.</p></a></li>
<li><a href='#validate_inputs'><p>Validates the inputs to Prophet.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Automatic Forecasting Procedure</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-03-08</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements a procedure for forecasting time series data based on
    an additive model where non-linear trends are fit with yearly, weekly, and
    daily seasonality, plus holiday effects. It works best with time series
    that have strong seasonal effects and several seasons of historical data.
    Prophet is robust to missing data and shifts in the trend, and typically
    handles outliers well.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/facebook/prophet">https://github.com/facebook/prophet</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/facebook/prophet/issues">https://github.com/facebook/prophet/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0), Rcpp (&ge; 0.12.0), rlang (&ge; 0.3.0.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr (&ge; 0.7.7), dygraphs (&ge; 1.1.1.4), extraDistr, ggplot2,
grid, lubridate, methods, RcppParallel (&ge; 5.0.1), rstan (&ge;
2.18.1), rstantools (&ge; 2.0.0), scales, StanHeaders, stats,
tidyr (&ge; 0.6.1), xts</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, testthat, readr, rmarkdown</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make, C++11</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH (&ge; 1.66.0), Rcpp (&ge; 0.12.0), RcppParallel (&ge; 5.0.1),
RcppEigen (&ge; 0.3.3.3.0), rstan (&ge; 2.18.1), StanHeaders (&ge;
2.18.0)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-03-30 00:55:01 UTC; seant</td>
</tr>
<tr>
<td>Author:</td>
<td>Sean Taylor [cre, aut],
  Ben Letham [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sean Taylor &lt;sjtz@pm.me&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-03-30 12:10:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_changepoints_to_plot'>Get layers to overlay significant changepoints on prophet forecast plot.</h2><span id='topic+add_changepoints_to_plot'></span>

<h3>Description</h3>

<p>Get layers to overlay significant changepoints on prophet forecast plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_changepoints_to_plot(
  m,
  threshold = 0.01,
  cp_color = "red",
  cp_linetype = "dashed",
  trend = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_changepoints_to_plot_+3A_m">m</code></td>
<td>
<p>Prophet model object.</p>
</td></tr>
<tr><td><code id="add_changepoints_to_plot_+3A_threshold">threshold</code></td>
<td>
<p>Numeric, changepoints where abs(delta) &gt;= threshold are
significant. (Default 0.01)</p>
</td></tr>
<tr><td><code id="add_changepoints_to_plot_+3A_cp_color">cp_color</code></td>
<td>
<p>Character, line color. (Default &quot;red&quot;)</p>
</td></tr>
<tr><td><code id="add_changepoints_to_plot_+3A_cp_linetype">cp_linetype</code></td>
<td>
<p>Character or integer, line type. (Default &quot;dashed&quot;)</p>
</td></tr>
<tr><td><code id="add_changepoints_to_plot_+3A_trend">trend</code></td>
<td>
<p>Logical, if FALSE, do not draw trend line. (Default TRUE)</p>
</td></tr>
<tr><td><code id="add_changepoints_to_plot_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to layers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of ggplot2 layers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plot(m, fcst) + add_changepoints_to_plot(m)

## End(Not run)

</code></pre>

<hr>
<h2 id='add_country_holidays'>Add in built-in holidays for the specified country.</h2><span id='topic+add_country_holidays'></span>

<h3>Description</h3>

<p>These holidays will be included in addition to any specified on model
initialization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_country_holidays(m, country_name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_country_holidays_+3A_m">m</code></td>
<td>
<p>Prophet object.</p>
</td></tr>
<tr><td><code id="add_country_holidays_+3A_country_name">country_name</code></td>
<td>
<p>Name of the country, like 'UnitedStates' or 'US'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Holidays will be calculated for arbitrary date ranges in the history
and future. See the online documentation for the list of countries with
built-in holidays.
</p>
<p>Built-in country holidays can only be set for a single country.
</p>


<h3>Value</h3>

<p>The prophet model with the holidays country set.
</p>

<hr>
<h2 id='add_group_component'>Adds a component with given name that contains all of the components
in group.</h2><span id='topic+add_group_component'></span>

<h3>Description</h3>

<p>Adds a component with given name that contains all of the components
in group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_group_component(components, name, group)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_group_component_+3A_components">components</code></td>
<td>
<p>Dataframe with components.</p>
</td></tr>
<tr><td><code id="add_group_component_+3A_name">name</code></td>
<td>
<p>Name of new group component.</p>
</td></tr>
<tr><td><code id="add_group_component_+3A_group">group</code></td>
<td>
<p>List of components that form the group.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe with components.
</p>

<hr>
<h2 id='add_regressor'>Add an additional regressor to be used for fitting and predicting.</h2><span id='topic+add_regressor'></span>

<h3>Description</h3>

<p>The dataframe passed to 'fit' and 'predict' will have a column with the
specified name to be used as a regressor. When standardize='auto', the
regressor will be standardized unless it is binary. The regression
coefficient is given a prior with the specified scale parameter.
Decreasing the prior scale will add additional regularization. If no
prior scale is provided, holidays.prior.scale will be used.
Mode can be specified as either 'additive' or 'multiplicative'. If not
specified, m$seasonality.mode will be used. 'additive' means the effect of
the regressor will be added to the trend, 'multiplicative' means it will
multiply the trend.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_regressor(m, name, prior.scale = NULL, standardize = "auto", mode = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_regressor_+3A_m">m</code></td>
<td>
<p>Prophet object.</p>
</td></tr>
<tr><td><code id="add_regressor_+3A_name">name</code></td>
<td>
<p>String name of the regressor</p>
</td></tr>
<tr><td><code id="add_regressor_+3A_prior.scale">prior.scale</code></td>
<td>
<p>Float scale for the normal prior. If not provided,
holidays.prior.scale will be used.</p>
</td></tr>
<tr><td><code id="add_regressor_+3A_standardize">standardize</code></td>
<td>
<p>Bool, specify whether this regressor will be standardized
prior to fitting. Can be 'auto' (standardize if not binary), True, or
False.</p>
</td></tr>
<tr><td><code id="add_regressor_+3A_mode">mode</code></td>
<td>
<p>Optional, 'additive' or 'multiplicative'. Defaults to
m$seasonality.mode.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The prophet model with the regressor added.
</p>

<hr>
<h2 id='add_seasonality'>Add a seasonal component with specified period, number of Fourier
components, and prior scale.</h2><span id='topic+add_seasonality'></span>

<h3>Description</h3>

<p>Increasing the number of Fourier components allows the seasonality to change
more quickly (at risk of overfitting). Default values for yearly and weekly
seasonalities are 10 and 3 respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_seasonality(
  m,
  name,
  period,
  fourier.order,
  prior.scale = NULL,
  mode = NULL,
  condition.name = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_seasonality_+3A_m">m</code></td>
<td>
<p>Prophet object.</p>
</td></tr>
<tr><td><code id="add_seasonality_+3A_name">name</code></td>
<td>
<p>String name of the seasonality component.</p>
</td></tr>
<tr><td><code id="add_seasonality_+3A_period">period</code></td>
<td>
<p>Float number of days in one period.</p>
</td></tr>
<tr><td><code id="add_seasonality_+3A_fourier.order">fourier.order</code></td>
<td>
<p>Int number of Fourier components to use.</p>
</td></tr>
<tr><td><code id="add_seasonality_+3A_prior.scale">prior.scale</code></td>
<td>
<p>Optional float prior scale for this component.</p>
</td></tr>
<tr><td><code id="add_seasonality_+3A_mode">mode</code></td>
<td>
<p>Optional 'additive' or 'multiplicative'.</p>
</td></tr>
<tr><td><code id="add_seasonality_+3A_condition.name">condition.name</code></td>
<td>
<p>String name of the seasonality condition.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Increasing prior scale will allow this seasonality component more
flexibility, decreasing will dampen it. If not provided, will use the
seasonality.prior.scale provided on Prophet initialization (defaults to 10).
</p>
<p>Mode can be specified as either 'additive' or 'multiplicative'. If not
specified, m$seasonality.mode will be used (defaults to 'additive').
Additive means the seasonality will be added to the trend, multiplicative
means it will multiply the trend.
</p>
<p>If condition.name is provided, the dataframe passed to 'fit' and 'predict'
should have a column with the specified condition.name containing booleans
which decides when to apply seasonality.
</p>


<h3>Value</h3>

<p>The prophet model with the seasonality added.
</p>

<hr>
<h2 id='construct_holiday_dataframe'>Construct a dataframe of holiday dates.</h2><span id='topic+construct_holiday_dataframe'></span>

<h3>Description</h3>

<p>Construct a dataframe of holiday dates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_holiday_dataframe(m, dates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct_holiday_dataframe_+3A_m">m</code></td>
<td>
<p>Prophet object.</p>
</td></tr>
<tr><td><code id="construct_holiday_dataframe_+3A_dates">dates</code></td>
<td>
<p>Vector with dates used for computing seasonality.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe of holiday dates, in holiday dataframe format used in
initialization.
</p>

<hr>
<h2 id='coverage'>Coverage</h2><span id='topic+coverage'></span>

<h3>Description</h3>

<p>Coverage
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coverage(df, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coverage_+3A_df">df</code></td>
<td>
<p>Cross-validation results dataframe.</p>
</td></tr>
<tr><td><code id="coverage_+3A_w">w</code></td>
<td>
<p>Aggregation window size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Array of coverages
</p>

<hr>
<h2 id='cross_validation'>Cross-validation for time series.</h2><span id='topic+cross_validation'></span>

<h3>Description</h3>

<p>Computes forecasts from historical cutoff points which user can input.If
not provided, these are computed beginning from (end - horizon), and working
backwards making cutoffs with a spacing of period until initial is reached.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross_validation(
  model,
  horizon,
  units,
  period = NULL,
  initial = NULL,
  cutoffs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cross_validation_+3A_model">model</code></td>
<td>
<p>Fitted Prophet model.</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_horizon">horizon</code></td>
<td>
<p>Integer size of the horizon</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_units">units</code></td>
<td>
<p>String unit of the horizon, e.g., &quot;days&quot;, &quot;secs&quot;.</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_period">period</code></td>
<td>
<p>Integer amount of time between cutoff dates. Same units as
horizon. If not provided, 0.5 * horizon is used.</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_initial">initial</code></td>
<td>
<p>Integer size of the first training period. If not provided,
3 * horizon is used. Same units as horizon.</p>
</td></tr>
<tr><td><code id="cross_validation_+3A_cutoffs">cutoffs</code></td>
<td>
<p>Vector of cutoff dates to be used during
cross-validtation. If not provided works beginning from (end - horizon),
works backwards making cutoffs with a spacing of period until initial is
reached.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When period is equal to the time interval of the data, this is the
technique described in https://robjhyndman.com/hyndsight/tscv/ .
</p>


<h3>Value</h3>

<p>A dataframe with the forecast, actual value, and cutoff date.
</p>

<hr>
<h2 id='df_for_plotting'>Merge history and forecast for plotting.</h2><span id='topic+df_for_plotting'></span>

<h3>Description</h3>

<p>Merge history and forecast for plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df_for_plotting(m, fcst)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="df_for_plotting_+3A_m">m</code></td>
<td>
<p>Prophet object.</p>
</td></tr>
<tr><td><code id="df_for_plotting_+3A_fcst">fcst</code></td>
<td>
<p>Data frame returned by prophet predict.</p>
</td></tr>
</table>

<hr>
<h2 id='dyplot.prophet'>Plot the prophet forecast.</h2><span id='topic+dyplot.prophet'></span>

<h3>Description</h3>

<p>Plot the prophet forecast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dyplot.prophet(x, fcst, uncertainty = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dyplot.prophet_+3A_x">x</code></td>
<td>
<p>Prophet object.</p>
</td></tr>
<tr><td><code id="dyplot.prophet_+3A_fcst">fcst</code></td>
<td>
<p>Data frame returned by predict(m, df).</p>
</td></tr>
<tr><td><code id="dyplot.prophet_+3A_uncertainty">uncertainty</code></td>
<td>
<p>Optional boolean indicating if the uncertainty interval for yhat
should be plotted, which will only be done if x$uncertainty.samples &gt; 0. Must be
present in fcst as yhat_lower and yhat_upper.</p>
</td></tr>
<tr><td><code id="dyplot.prophet_+3A_...">...</code></td>
<td>
<p>additional arguments passed to dygraph::dygraph</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dygraph plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
history &lt;- data.frame(
 ds = seq(as.Date('2015-01-01'), as.Date('2016-01-01'), by = 'd'),
 y = sin(1:366/200) + rnorm(366)/10)
m &lt;- prophet(history)
future &lt;- make_future_dataframe(m, periods = 365)
forecast &lt;- predict(m, future)
dyplot.prophet(m, forecast)

## End(Not run)

</code></pre>

<hr>
<h2 id='fit.prophet'>Fit the prophet model.</h2><span id='topic+fit.prophet'></span>

<h3>Description</h3>

<p>This sets m$params to contain the fitted model parameters. It is a list
with the following elements:
k (M array): M posterior samples of the initial slope.
m (M array): The initial intercept.
delta (MxN matrix): The slope change at each of N changepoints.
beta (MxK matrix): Coefficients for K seasonality features.
sigma_obs (M array): Noise level.
Note that M=1 if MAP estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit.prophet(m, df, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit.prophet_+3A_m">m</code></td>
<td>
<p>Prophet object.</p>
</td></tr>
<tr><td><code id="fit.prophet_+3A_df">df</code></td>
<td>
<p>Data frame.</p>
</td></tr>
<tr><td><code id="fit.prophet_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code>optimizing</code> or
<code>sampling</code> functions in Stan.</p>
</td></tr>
</table>

<hr>
<h2 id='flat_growth_init'>Initialize flat growth.</h2><span id='topic+flat_growth_init'></span>

<h3>Description</h3>

<p>Provides a strong initialization for flat growth by setting the
growth to 0 and calculates the offset parameter that pass the 
function through the mean of the the y_scaled values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flat_growth_init(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flat_growth_init_+3A_df">df</code></td>
<td>
<p>Data frame with columns ds (date), y_scaled (scaled time series),
and t (scaled time).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector (k, m) with the rate (k) and offset (m) of the flat
growth function.
</p>

<hr>
<h2 id='flat_trend'>Evaluate the flat trend function.</h2><span id='topic+flat_trend'></span>

<h3>Description</h3>

<p>Evaluate the flat trend function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flat_trend(t, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flat_trend_+3A_t">t</code></td>
<td>
<p>Vector of times on which the function is evaluated.</p>
</td></tr>
<tr><td><code id="flat_trend_+3A_m">m</code></td>
<td>
<p>Float initial offset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector y(t).
</p>

<hr>
<h2 id='fourier_series'>Provides Fourier series components with the specified frequency and order.</h2><span id='topic+fourier_series'></span>

<h3>Description</h3>

<p>Provides Fourier series components with the specified frequency and order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fourier_series(dates, period, series.order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fourier_series_+3A_dates">dates</code></td>
<td>
<p>Vector of dates.</p>
</td></tr>
<tr><td><code id="fourier_series_+3A_period">period</code></td>
<td>
<p>Number of days of the period.</p>
</td></tr>
<tr><td><code id="fourier_series_+3A_series.order">series.order</code></td>
<td>
<p>Number of components.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with seasonality features.
</p>

<hr>
<h2 id='generate_cutoffs'>Generate cutoff dates</h2><span id='topic+generate_cutoffs'></span>

<h3>Description</h3>

<p>Generate cutoff dates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_cutoffs(df, horizon, initial, period)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_cutoffs_+3A_df">df</code></td>
<td>
<p>Dataframe with historical data.</p>
</td></tr>
<tr><td><code id="generate_cutoffs_+3A_horizon">horizon</code></td>
<td>
<p>timediff forecast horizon.</p>
</td></tr>
<tr><td><code id="generate_cutoffs_+3A_initial">initial</code></td>
<td>
<p>timediff initial window.</p>
</td></tr>
<tr><td><code id="generate_cutoffs_+3A_period">period</code></td>
<td>
<p>timediff Simulated forecasts are done with this period.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Array of datetimes.
</p>

<hr>
<h2 id='generated_holidays'>holidays table</h2><span id='topic+generated_holidays'></span>

<h3>Description</h3>

<p>holidays table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generated_holidays
</code></pre>


<h3>Format</h3>

<p>A data frame with five variables: ds, holiday, country, year
</p>

<hr>
<h2 id='get_holiday_names'>Return all possible holiday names of given country</h2><span id='topic+get_holiday_names'></span>

<h3>Description</h3>

<p>Return all possible holiday names of given country
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_holiday_names(country.name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_holiday_names_+3A_country.name">country.name</code></td>
<td>
<p>Country name (character).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of all possible holiday names (unique) of given country.
</p>

<hr>
<h2 id='initialize_scales_fn'>Initialize model scales.</h2><span id='topic+initialize_scales_fn'></span>

<h3>Description</h3>

<p>Sets model scaling factors using df.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initialize_scales_fn(m, initialize_scales, df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialize_scales_fn_+3A_m">m</code></td>
<td>
<p>Prophet object.</p>
</td></tr>
<tr><td><code id="initialize_scales_fn_+3A_initialize_scales">initialize_scales</code></td>
<td>
<p>Boolean set the scales or not.</p>
</td></tr>
<tr><td><code id="initialize_scales_fn_+3A_df">df</code></td>
<td>
<p>Dataframe for setting scales.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prophet object with scales set.
</p>

<hr>
<h2 id='linear_growth_init'>Initialize constant growth.</h2><span id='topic+linear_growth_init'></span>

<h3>Description</h3>

<p>Provides a strong initialization for linear growth by calculating the
growth and offset parameters that pass the function through the first and
last points in the time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linear_growth_init(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linear_growth_init_+3A_df">df</code></td>
<td>
<p>Data frame with columns ds (date), y_scaled (scaled time series),
and t (scaled time).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector (k, m) with the rate (k) and offset (m) of the linear
growth function.
</p>

<hr>
<h2 id='logistic_growth_init'>Initialize logistic growth.</h2><span id='topic+logistic_growth_init'></span>

<h3>Description</h3>

<p>Provides a strong initialization for logistic growth by calculating the
growth and offset parameters that pass the function through the first and
last points in the time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logistic_growth_init(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logistic_growth_init_+3A_df">df</code></td>
<td>
<p>Data frame with columns ds (date), cap_scaled (scaled capacity),
y_scaled (scaled time series), and t (scaled time).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector (k, m) with the rate (k) and offset (m) of the logistic
growth function.
</p>

<hr>
<h2 id='mae'>Mean absolute error</h2><span id='topic+mae'></span>

<h3>Description</h3>

<p>Mean absolute error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mae(df, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mae_+3A_df">df</code></td>
<td>
<p>Cross-validation results dataframe.</p>
</td></tr>
<tr><td><code id="mae_+3A_w">w</code></td>
<td>
<p>Aggregation window size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Array of mean absolute errors.
</p>

<hr>
<h2 id='make_all_seasonality_features'>Dataframe with seasonality features.
Includes seasonality features, holiday features, and added regressors.</h2><span id='topic+make_all_seasonality_features'></span>

<h3>Description</h3>

<p>Dataframe with seasonality features.
Includes seasonality features, holiday features, and added regressors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_all_seasonality_features(m, df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_all_seasonality_features_+3A_m">m</code></td>
<td>
<p>Prophet object.</p>
</td></tr>
<tr><td><code id="make_all_seasonality_features_+3A_df">df</code></td>
<td>
<p>Dataframe with dates for computing seasonality features and any
added regressors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with items
seasonal.features: Dataframe with regressor features,
prior.scales: Array of prior scales for each colum of the features
dataframe.
component.cols: Dataframe with indicators for which regression components
correspond to which columns.
modes: List with keys 'additive' and 'multiplicative' with arrays of
component names for each mode of seasonality.
</p>

<hr>
<h2 id='make_future_dataframe'>Make dataframe with future dates for forecasting.</h2><span id='topic+make_future_dataframe'></span>

<h3>Description</h3>

<p>Make dataframe with future dates for forecasting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_future_dataframe(m, periods, freq = "day", include_history = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_future_dataframe_+3A_m">m</code></td>
<td>
<p>Prophet model object.</p>
</td></tr>
<tr><td><code id="make_future_dataframe_+3A_periods">periods</code></td>
<td>
<p>Int number of periods to forecast forward.</p>
</td></tr>
<tr><td><code id="make_future_dataframe_+3A_freq">freq</code></td>
<td>
<p>'day', 'week', 'month', 'quarter', 'year', 1(1 sec), 60(1 minute) or 3600(1 hour).</p>
</td></tr>
<tr><td><code id="make_future_dataframe_+3A_include_history">include_history</code></td>
<td>
<p>Boolean to include the historical dates in the data
frame for predictions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe that extends forward from the end of m$history for the
requested number of periods.
</p>

<hr>
<h2 id='make_holiday_features'>Construct a matrix of holiday features.</h2><span id='topic+make_holiday_features'></span>

<h3>Description</h3>

<p>Construct a matrix of holiday features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_holiday_features(m, dates, holidays)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_holiday_features_+3A_m">m</code></td>
<td>
<p>Prophet object.</p>
</td></tr>
<tr><td><code id="make_holiday_features_+3A_dates">dates</code></td>
<td>
<p>Vector with dates used for computing seasonality.</p>
</td></tr>
<tr><td><code id="make_holiday_features_+3A_holidays">holidays</code></td>
<td>
<p>Dataframe containing holidays, as returned by
construct_holiday_dataframe.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with entries
holiday.features: dataframe with a column for each holiday.
prior.scales: array of prior scales for each holiday column.
holiday.names: array of names of all holidays.
</p>

<hr>
<h2 id='make_holidays_df'>Make dataframe of holidays for given years and countries</h2><span id='topic+make_holidays_df'></span>

<h3>Description</h3>

<p>Make dataframe of holidays for given years and countries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_holidays_df(years, country.name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_holidays_df_+3A_years">years</code></td>
<td>
<p>List of years for which to include holiday dates.</p>
</td></tr>
<tr><td><code id="make_holidays_df_+3A_country.name">country.name</code></td>
<td>
<p>Country name (character).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe with 'ds' and 'holiday', which can directly feed
to 'holidays' params in Prophet
</p>

<hr>
<h2 id='make_seasonality_features'>Data frame with seasonality features.</h2><span id='topic+make_seasonality_features'></span>

<h3>Description</h3>

<p>Data frame with seasonality features.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_seasonality_features(dates, period, series.order, prefix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_seasonality_features_+3A_dates">dates</code></td>
<td>
<p>Vector of dates.</p>
</td></tr>
<tr><td><code id="make_seasonality_features_+3A_period">period</code></td>
<td>
<p>Number of days of the period.</p>
</td></tr>
<tr><td><code id="make_seasonality_features_+3A_series.order">series.order</code></td>
<td>
<p>Number of components.</p>
</td></tr>
<tr><td><code id="make_seasonality_features_+3A_prefix">prefix</code></td>
<td>
<p>Column name prefix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe with seasonality.
</p>

<hr>
<h2 id='mape'>Mean absolute percent error</h2><span id='topic+mape'></span>

<h3>Description</h3>

<p>Mean absolute percent error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mape(df, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mape_+3A_df">df</code></td>
<td>
<p>Cross-validation results dataframe.</p>
</td></tr>
<tr><td><code id="mape_+3A_w">w</code></td>
<td>
<p>Aggregation window size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Array of mean absolute percent errors.
</p>

<hr>
<h2 id='mdape'>Median absolute percent error</h2><span id='topic+mdape'></span>

<h3>Description</h3>

<p>Median absolute percent error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mdape(df, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mdape_+3A_df">df</code></td>
<td>
<p>Cross-validation results dataframe.</p>
</td></tr>
<tr><td><code id="mdape_+3A_w">w</code></td>
<td>
<p>Aggregation window size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Array of median absolute percent errors.
</p>

<hr>
<h2 id='mse'>Mean squared error</h2><span id='topic+mse'></span>

<h3>Description</h3>

<p>Mean squared error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mse(df, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mse_+3A_df">df</code></td>
<td>
<p>Cross-validation results dataframe.</p>
</td></tr>
<tr><td><code id="mse_+3A_w">w</code></td>
<td>
<p>Aggregation window size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Array of mean squared errors.
</p>

<hr>
<h2 id='parse_seasonality_args'>Get number of Fourier components for built-in seasonalities.</h2><span id='topic+parse_seasonality_args'></span>

<h3>Description</h3>

<p>Get number of Fourier components for built-in seasonalities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_seasonality_args(m, name, arg, auto.disable, default.order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_seasonality_args_+3A_m">m</code></td>
<td>
<p>Prophet object.</p>
</td></tr>
<tr><td><code id="parse_seasonality_args_+3A_name">name</code></td>
<td>
<p>String name of the seasonality component.</p>
</td></tr>
<tr><td><code id="parse_seasonality_args_+3A_arg">arg</code></td>
<td>
<p>'auto', TRUE, FALSE, or number of Fourier components as
provided.</p>
</td></tr>
<tr><td><code id="parse_seasonality_args_+3A_auto.disable">auto.disable</code></td>
<td>
<p>Bool if seasonality should be disabled when 'auto'.</p>
</td></tr>
<tr><td><code id="parse_seasonality_args_+3A_default.order">default.order</code></td>
<td>
<p>Int default Fourier order.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of Fourier components, or 0 for disabled.
</p>

<hr>
<h2 id='performance_metrics'>Compute performance metrics from cross-validation results.</h2><span id='topic+performance_metrics'></span>

<h3>Description</h3>

<p>Computes a suite of performance metrics on the output of cross-validation.
By default the following metrics are included:
'mse': mean squared error,
'rmse': root mean squared error,
'mae': mean absolute error,
'mape': mean percent error,
'mdape': median percent error,
'smape': symmetric mean absolute percentage error,
'coverage': coverage of the upper and lower intervals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>performance_metrics(df, metrics = NULL, rolling_window = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="performance_metrics_+3A_df">df</code></td>
<td>
<p>The dataframe returned by cross_validation.</p>
</td></tr>
<tr><td><code id="performance_metrics_+3A_metrics">metrics</code></td>
<td>
<p>An array of performance metrics to compute. If not provided,
will use c('mse', 'rmse', 'mae', 'mape', 'mdape', 'smape', 'coverage').</p>
</td></tr>
<tr><td><code id="performance_metrics_+3A_rolling_window">rolling_window</code></td>
<td>
<p>Proportion of data to use in each rolling window for
computing the metrics. Should be in [0, 1] to average.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A subset of these can be specified by passing a list of names as the
'metrics' argument.
</p>
<p>Metrics are calculated over a rolling window of cross validation
predictions, after sorting by horizon. Averaging is first done within each
value of the horizon, and then across horizons as needed to reach the
window size. The size of that window (number of simulated forecast points)
is determined by the rolling_window argument, which specifies a proportion
of simulated forecast points to include in each window. rolling_window=0
will compute it separately for each horizon. The default of
rolling_window=0.1 will use 10
rolling_window=1 will compute the metric across all simulated forecast
points. The results are set to the right edge of the window.
</p>
<p>If rolling_window &lt; 0, then metrics are computed at each datapoint with no
averaging (i.e., 'mse' will actually be squared error with no mean).
</p>
<p>The output is a dataframe containing column 'horizon' along with columns
for each of the metrics computed.
</p>


<h3>Value</h3>

<p>A dataframe with a column for each metric, and column 'horizon'.
</p>

<hr>
<h2 id='piecewise_linear'>Evaluate the piecewise linear function.</h2><span id='topic+piecewise_linear'></span>

<h3>Description</h3>

<p>Evaluate the piecewise linear function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>piecewise_linear(t, deltas, k, m, changepoint.ts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="piecewise_linear_+3A_t">t</code></td>
<td>
<p>Vector of times on which the function is evaluated.</p>
</td></tr>
<tr><td><code id="piecewise_linear_+3A_deltas">deltas</code></td>
<td>
<p>Vector of rate changes at each changepoint.</p>
</td></tr>
<tr><td><code id="piecewise_linear_+3A_k">k</code></td>
<td>
<p>Float initial rate.</p>
</td></tr>
<tr><td><code id="piecewise_linear_+3A_m">m</code></td>
<td>
<p>Float initial offset.</p>
</td></tr>
<tr><td><code id="piecewise_linear_+3A_changepoint.ts">changepoint.ts</code></td>
<td>
<p>Vector of changepoint times.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector y(t).
</p>

<hr>
<h2 id='piecewise_logistic'>Evaluate the piecewise logistic function.</h2><span id='topic+piecewise_logistic'></span>

<h3>Description</h3>

<p>Evaluate the piecewise logistic function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>piecewise_logistic(t, cap, deltas, k, m, changepoint.ts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="piecewise_logistic_+3A_t">t</code></td>
<td>
<p>Vector of times on which the function is evaluated.</p>
</td></tr>
<tr><td><code id="piecewise_logistic_+3A_cap">cap</code></td>
<td>
<p>Vector of capacities at each t.</p>
</td></tr>
<tr><td><code id="piecewise_logistic_+3A_deltas">deltas</code></td>
<td>
<p>Vector of rate changes at each changepoint.</p>
</td></tr>
<tr><td><code id="piecewise_logistic_+3A_k">k</code></td>
<td>
<p>Float initial rate.</p>
</td></tr>
<tr><td><code id="piecewise_logistic_+3A_m">m</code></td>
<td>
<p>Float initial offset.</p>
</td></tr>
<tr><td><code id="piecewise_logistic_+3A_changepoint.ts">changepoint.ts</code></td>
<td>
<p>Vector of changepoint times.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector y(t).
</p>

<hr>
<h2 id='plot_cross_validation_metric'>Plot a performance metric vs. forecast horizon from cross validation.
Cross validation produces a collection of out-of-sample model predictions
that can be compared to actual values, at a range of different horizons
(distance from the cutoff). This computes a specified performance metric
for each prediction, and aggregated over a rolling window with horizon.</h2><span id='topic+plot_cross_validation_metric'></span>

<h3>Description</h3>

<p>This uses fbprophet.diagnostics.performance_metrics to compute the metrics.
Valid values of metric are 'mse', 'rmse', 'mae', 'mape', and 'coverage'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_cross_validation_metric(df_cv, metric, rolling_window = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_cross_validation_metric_+3A_df_cv">df_cv</code></td>
<td>
<p>The output from fbprophet.diagnostics.cross_validation.</p>
</td></tr>
<tr><td><code id="plot_cross_validation_metric_+3A_metric">metric</code></td>
<td>
<p>Metric name, one of 'mse', 'rmse', 'mae', 'mape', 'coverage'.</p>
</td></tr>
<tr><td><code id="plot_cross_validation_metric_+3A_rolling_window">rolling_window</code></td>
<td>
<p>Proportion of data to use for rolling average of
metric. In [0, 1]. Defaults to 0.1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>rolling_window is the proportion of data included in the rolling window of
aggregation. The default value of 0.1 means 10
aggregation for computing the metric.
</p>
<p>As a concrete example, if metric='mse', then this plot will show the
squared error for each cross validation prediction, along with the MSE
averaged over rolling windows of 10
</p>


<h3>Value</h3>

<p>A ggplot2 plot.
</p>

<hr>
<h2 id='plot_forecast_component'>Plot a particular component of the forecast.</h2><span id='topic+plot_forecast_component'></span>

<h3>Description</h3>

<p>Plot a particular component of the forecast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_forecast_component(m, fcst, name, uncertainty = TRUE, plot_cap = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_forecast_component_+3A_m">m</code></td>
<td>
<p>Prophet model</p>
</td></tr>
<tr><td><code id="plot_forecast_component_+3A_fcst">fcst</code></td>
<td>
<p>Dataframe output of 'predict'.</p>
</td></tr>
<tr><td><code id="plot_forecast_component_+3A_name">name</code></td>
<td>
<p>String name of the component to plot (column of fcst).</p>
</td></tr>
<tr><td><code id="plot_forecast_component_+3A_uncertainty">uncertainty</code></td>
<td>
<p>Optional boolean to plot uncertainty intervals, which will 
only be done if m$uncertainty.samples &gt; 0.</p>
</td></tr>
<tr><td><code id="plot_forecast_component_+3A_plot_cap">plot_cap</code></td>
<td>
<p>Boolean indicating if the capacity should be shown in the
figure, if available.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 plot.
</p>

<hr>
<h2 id='plot_seasonality'>Plot a custom seasonal component.</h2><span id='topic+plot_seasonality'></span>

<h3>Description</h3>

<p>Plot a custom seasonal component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_seasonality(m, name, uncertainty = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_seasonality_+3A_m">m</code></td>
<td>
<p>Prophet model object.</p>
</td></tr>
<tr><td><code id="plot_seasonality_+3A_name">name</code></td>
<td>
<p>String name of the seasonality.</p>
</td></tr>
<tr><td><code id="plot_seasonality_+3A_uncertainty">uncertainty</code></td>
<td>
<p>Optional boolean to plot uncertainty intervals, which
will only be done if m$uncertainty.samples &gt; 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 plot.
</p>

<hr>
<h2 id='plot_weekly'>Plot the weekly component of the forecast.</h2><span id='topic+plot_weekly'></span>

<h3>Description</h3>

<p>Plot the weekly component of the forecast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_weekly(m, uncertainty = TRUE, weekly_start = 0, name = "weekly")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_weekly_+3A_m">m</code></td>
<td>
<p>Prophet model object</p>
</td></tr>
<tr><td><code id="plot_weekly_+3A_uncertainty">uncertainty</code></td>
<td>
<p>Optional boolean to plot uncertainty intervals, which will
only be done if m$uncertainty.samples &gt; 0.</p>
</td></tr>
<tr><td><code id="plot_weekly_+3A_weekly_start">weekly_start</code></td>
<td>
<p>Integer specifying the start day of the weekly
seasonality plot. 0 (default) starts the week on Sunday. 1 shifts by 1 day
to Monday, and so on.</p>
</td></tr>
<tr><td><code id="plot_weekly_+3A_name">name</code></td>
<td>
<p>Name of seasonality component if previously changed
from default 'weekly'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 plot.
</p>

<hr>
<h2 id='plot_yearly'>Plot the yearly component of the forecast.</h2><span id='topic+plot_yearly'></span>

<h3>Description</h3>

<p>Plot the yearly component of the forecast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_yearly(m, uncertainty = TRUE, yearly_start = 0, name = "yearly")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_yearly_+3A_m">m</code></td>
<td>
<p>Prophet model object.</p>
</td></tr>
<tr><td><code id="plot_yearly_+3A_uncertainty">uncertainty</code></td>
<td>
<p>Optional boolean to plot uncertainty intervals, which
will only be done if m$uncertainty.samples &gt; 0.</p>
</td></tr>
<tr><td><code id="plot_yearly_+3A_yearly_start">yearly_start</code></td>
<td>
<p>Integer specifying the start day of the yearly
seasonality plot. 0 (default) starts the year on Jan 1. 1 shifts by 1 day
to Jan 2, and so on.</p>
</td></tr>
<tr><td><code id="plot_yearly_+3A_name">name</code></td>
<td>
<p>Name of seasonality component if previously changed
from default 'yearly'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 plot.
</p>

<hr>
<h2 id='plot.prophet'>Plot the prophet forecast.</h2><span id='topic+plot.prophet'></span>

<h3>Description</h3>

<p>Plot the prophet forecast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'prophet'
plot(
  x,
  fcst,
  uncertainty = TRUE,
  plot_cap = TRUE,
  xlabel = "ds",
  ylabel = "y",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.prophet_+3A_x">x</code></td>
<td>
<p>Prophet object.</p>
</td></tr>
<tr><td><code id="plot.prophet_+3A_fcst">fcst</code></td>
<td>
<p>Data frame returned by predict(m, df).</p>
</td></tr>
<tr><td><code id="plot.prophet_+3A_uncertainty">uncertainty</code></td>
<td>
<p>Optional boolean indicating if the uncertainty interval for yhat
should be plotted, which will only be done if x$uncertainty.samples &gt; 0.
Must be present in fcst as yhat_lower and yhat_upper.</p>
</td></tr>
<tr><td><code id="plot.prophet_+3A_plot_cap">plot_cap</code></td>
<td>
<p>Boolean indicating if the capacity should be shown in the
figure, if available.</p>
</td></tr>
<tr><td><code id="plot.prophet_+3A_xlabel">xlabel</code></td>
<td>
<p>Optional label for x-axis</p>
</td></tr>
<tr><td><code id="plot.prophet_+3A_ylabel">ylabel</code></td>
<td>
<p>Optional label for y-axis</p>
</td></tr>
<tr><td><code id="plot.prophet_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
history &lt;- data.frame(ds = seq(as.Date('2015-01-01'), as.Date('2016-01-01'), by = 'd'),
                      y = sin(1:366/200) + rnorm(366)/10)
m &lt;- prophet(history)
future &lt;- make_future_dataframe(m, periods = 365)
forecast &lt;- predict(m, future)
plot(m, forecast)

## End(Not run)

</code></pre>

<hr>
<h2 id='predict_seasonal_components'>Predict seasonality components, holidays, and added regressors.</h2><span id='topic+predict_seasonal_components'></span>

<h3>Description</h3>

<p>Predict seasonality components, holidays, and added regressors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_seasonal_components(m, df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_seasonal_components_+3A_m">m</code></td>
<td>
<p>Prophet object.</p>
</td></tr>
<tr><td><code id="predict_seasonal_components_+3A_df">df</code></td>
<td>
<p>Prediction dataframe.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe with seasonal components.
</p>

<hr>
<h2 id='predict_trend'>Predict trend using the prophet model.</h2><span id='topic+predict_trend'></span>

<h3>Description</h3>

<p>Predict trend using the prophet model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_trend(model, df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_trend_+3A_model">model</code></td>
<td>
<p>Prophet object.</p>
</td></tr>
<tr><td><code id="predict_trend_+3A_df">df</code></td>
<td>
<p>Prediction dataframe.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector with trend on prediction dates.
</p>

<hr>
<h2 id='predict_uncertainty'>Prophet uncertainty intervals for yhat and trend</h2><span id='topic+predict_uncertainty'></span>

<h3>Description</h3>

<p>Prophet uncertainty intervals for yhat and trend
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_uncertainty(m, df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_uncertainty_+3A_m">m</code></td>
<td>
<p>Prophet object.</p>
</td></tr>
<tr><td><code id="predict_uncertainty_+3A_df">df</code></td>
<td>
<p>Prediction dataframe.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe with uncertainty intervals.
</p>

<hr>
<h2 id='predict.prophet'>Predict using the prophet model.</h2><span id='topic+predict.prophet'></span>

<h3>Description</h3>

<p>Predict using the prophet model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'prophet'
predict(object, df = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.prophet_+3A_object">object</code></td>
<td>
<p>Prophet object.</p>
</td></tr>
<tr><td><code id="predict.prophet_+3A_df">df</code></td>
<td>
<p>Dataframe with dates for predictions (column ds), and capacity
(column cap) if logistic growth. If not provided, predictions are made on
the history.</p>
</td></tr>
<tr><td><code id="predict.prophet_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with the forecast components.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
history &lt;- data.frame(ds = seq(as.Date('2015-01-01'), as.Date('2016-01-01'), by = 'd'),
                      y = sin(1:366/200) + rnorm(366)/10)
m &lt;- prophet(history)
future &lt;- make_future_dataframe(m, periods = 365)
forecast &lt;- predict(m, future)
plot(m, forecast)

## End(Not run)

</code></pre>

<hr>
<h2 id='predictive_samples'>Sample from the posterior predictive distribution.</h2><span id='topic+predictive_samples'></span>

<h3>Description</h3>

<p>Sample from the posterior predictive distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictive_samples(m, df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictive_samples_+3A_m">m</code></td>
<td>
<p>Prophet object.</p>
</td></tr>
<tr><td><code id="predictive_samples_+3A_df">df</code></td>
<td>
<p>Dataframe with dates for predictions (column ds), and capacity
(column cap) if logistic growth.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with items &quot;trend&quot; and &quot;yhat&quot; containing
posterior predictive samples for that component.
</p>

<hr>
<h2 id='prophet'>Prophet forecaster.</h2><span id='topic+prophet'></span>

<h3>Description</h3>

<p>Prophet forecaster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prophet(
  df = NULL,
  growth = "linear",
  changepoints = NULL,
  n.changepoints = 25,
  changepoint.range = 0.8,
  yearly.seasonality = "auto",
  weekly.seasonality = "auto",
  daily.seasonality = "auto",
  holidays = NULL,
  seasonality.mode = "additive",
  seasonality.prior.scale = 10,
  holidays.prior.scale = 10,
  changepoint.prior.scale = 0.05,
  mcmc.samples = 0,
  interval.width = 0.8,
  uncertainty.samples = 1000,
  fit = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prophet_+3A_df">df</code></td>
<td>
<p>(optional) Dataframe containing the history. Must have columns ds
(date type) and y, the time series. If growth is logistic, then df must
also have a column cap that specifies the capacity at each ds. If not
provided, then the model object will be instantiated but not fit; use
fit.prophet(m, df) to fit the model.</p>
</td></tr>
<tr><td><code id="prophet_+3A_growth">growth</code></td>
<td>
<p>String 'linear', 'logistic', or 'flat' to specify a linear, logistic
or flat trend.</p>
</td></tr>
<tr><td><code id="prophet_+3A_changepoints">changepoints</code></td>
<td>
<p>Vector of dates at which to include potential
changepoints. If not specified, potential changepoints are selected
automatically.</p>
</td></tr>
<tr><td><code id="prophet_+3A_n.changepoints">n.changepoints</code></td>
<td>
<p>Number of potential changepoints to include. Not used
if input 'changepoints' is supplied. If 'changepoints' is not supplied,
then n.changepoints potential changepoints are selected uniformly from the
first 'changepoint.range' proportion of df$ds.</p>
</td></tr>
<tr><td><code id="prophet_+3A_changepoint.range">changepoint.range</code></td>
<td>
<p>Proportion of history in which trend changepoints
will be estimated. Defaults to 0.8 for the first 80
'changepoints' is specified.</p>
</td></tr>
<tr><td><code id="prophet_+3A_yearly.seasonality">yearly.seasonality</code></td>
<td>
<p>Fit yearly seasonality. Can be 'auto', TRUE,
FALSE, or a number of Fourier terms to generate.</p>
</td></tr>
<tr><td><code id="prophet_+3A_weekly.seasonality">weekly.seasonality</code></td>
<td>
<p>Fit weekly seasonality. Can be 'auto', TRUE,
FALSE, or a number of Fourier terms to generate.</p>
</td></tr>
<tr><td><code id="prophet_+3A_daily.seasonality">daily.seasonality</code></td>
<td>
<p>Fit daily seasonality. Can be 'auto', TRUE,
FALSE, or a number of Fourier terms to generate.</p>
</td></tr>
<tr><td><code id="prophet_+3A_holidays">holidays</code></td>
<td>
<p>data frame with columns holiday (character) and ds (date
type)and optionally columns lower_window and upper_window which specify a
range of days around the date to be included as holidays. lower_window=-2
will include 2 days prior to the date as holidays. Also optionally can have
a column prior_scale specifying the prior scale for each holiday.</p>
</td></tr>
<tr><td><code id="prophet_+3A_seasonality.mode">seasonality.mode</code></td>
<td>
<p>'additive' (default) or 'multiplicative'.</p>
</td></tr>
<tr><td><code id="prophet_+3A_seasonality.prior.scale">seasonality.prior.scale</code></td>
<td>
<p>Parameter modulating the strength of the
seasonality model. Larger values allow the model to fit larger seasonal
fluctuations, smaller values dampen the seasonality. Can be specified for
individual seasonalities using add_seasonality.</p>
</td></tr>
<tr><td><code id="prophet_+3A_holidays.prior.scale">holidays.prior.scale</code></td>
<td>
<p>Parameter modulating the strength of the holiday
components model, unless overridden in the holidays input.</p>
</td></tr>
<tr><td><code id="prophet_+3A_changepoint.prior.scale">changepoint.prior.scale</code></td>
<td>
<p>Parameter modulating the flexibility of the
automatic changepoint selection. Large values will allow many changepoints,
small values will allow few changepoints.</p>
</td></tr>
<tr><td><code id="prophet_+3A_mcmc.samples">mcmc.samples</code></td>
<td>
<p>Integer, if greater than 0, will do full Bayesian
inference with the specified number of MCMC samples. If 0, will do MAP
estimation.</p>
</td></tr>
<tr><td><code id="prophet_+3A_interval.width">interval.width</code></td>
<td>
<p>Numeric, width of the uncertainty intervals provided
for the forecast. If mcmc.samples=0, this will be only the uncertainty
in the trend using the MAP estimate of the extrapolated generative model.
If mcmc.samples&gt;0, this will be integrated over all model parameters,
which will include uncertainty in seasonality.</p>
</td></tr>
<tr><td><code id="prophet_+3A_uncertainty.samples">uncertainty.samples</code></td>
<td>
<p>Number of simulated draws used to estimate
uncertainty intervals. Settings this value to 0 or False will disable
uncertainty estimation and speed up the calculation.</p>
</td></tr>
<tr><td><code id="prophet_+3A_fit">fit</code></td>
<td>
<p>Boolean, if FALSE the model is initialized but not fit.</p>
</td></tr>
<tr><td><code id="prophet_+3A_...">...</code></td>
<td>
<p>Additional arguments, passed to <code><a href="#topic+fit.prophet">fit.prophet</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A prophet model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
history &lt;- data.frame(ds = seq(as.Date('2015-01-01'), as.Date('2016-01-01'), by = 'd'),
                      y = sin(1:366/200) + rnorm(366)/10)
m &lt;- prophet(history)

## End(Not run)

</code></pre>

<hr>
<h2 id='prophet_copy'>Copy Prophet object.</h2><span id='topic+prophet_copy'></span>

<h3>Description</h3>

<p>Copy Prophet object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prophet_copy(m, cutoff = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prophet_copy_+3A_m">m</code></td>
<td>
<p>Prophet model object.</p>
</td></tr>
<tr><td><code id="prophet_copy_+3A_cutoff">cutoff</code></td>
<td>
<p>Date, possibly as string. Changepoints are only retained if
changepoints &lt;= cutoff.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An unfitted Prophet model object with the same parameters as the
input model.
</p>

<hr>
<h2 id='prophet_plot_components'>Plot the components of a prophet forecast.
Prints a ggplot2 with whichever are available of: trend, holidays, weekly
seasonality, yearly seasonality, and additive and multiplicative extra
regressors.</h2><span id='topic+prophet_plot_components'></span>

<h3>Description</h3>

<p>Plot the components of a prophet forecast.
Prints a ggplot2 with whichever are available of: trend, holidays, weekly
seasonality, yearly seasonality, and additive and multiplicative extra
regressors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prophet_plot_components(
  m,
  fcst,
  uncertainty = TRUE,
  plot_cap = TRUE,
  weekly_start = 0,
  yearly_start = 0,
  render_plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prophet_plot_components_+3A_m">m</code></td>
<td>
<p>Prophet object.</p>
</td></tr>
<tr><td><code id="prophet_plot_components_+3A_fcst">fcst</code></td>
<td>
<p>Data frame returned by predict(m, df).</p>
</td></tr>
<tr><td><code id="prophet_plot_components_+3A_uncertainty">uncertainty</code></td>
<td>
<p>Optional boolean indicating if the uncertainty interval should be
plotted for the trend, from fcst columns trend_lower and trend_upper.This will
only be done if m$uncertainty.samples &gt; 0.</p>
</td></tr>
<tr><td><code id="prophet_plot_components_+3A_plot_cap">plot_cap</code></td>
<td>
<p>Boolean indicating if the capacity should be shown in the
figure, if available.</p>
</td></tr>
<tr><td><code id="prophet_plot_components_+3A_weekly_start">weekly_start</code></td>
<td>
<p>Integer specifying the start day of the weekly
seasonality plot. 0 (default) starts the week on Sunday. 1 shifts by 1 day
to Monday, and so on.</p>
</td></tr>
<tr><td><code id="prophet_plot_components_+3A_yearly_start">yearly_start</code></td>
<td>
<p>Integer specifying the start day of the yearly
seasonality plot. 0 (default) starts the year on Jan 1. 1 shifts by 1 day
to Jan 2, and so on.</p>
</td></tr>
<tr><td><code id="prophet_plot_components_+3A_render_plot">render_plot</code></td>
<td>
<p>Boolean indicating if the plots should be rendered.
Set to FALSE if you want the function to only return the list of panels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly return a list containing the plotted ggplot objects
</p>

<hr>
<h2 id='regressor_coefficients'>Summarise the coefficients of the extra regressors used in the model.
For additive regressors, the coefficient represents the incremental impact
on <code>y</code> of a unit increase in the regressor. For multiplicative regressors,
the incremental impact is equal to <code>trend(t)</code> multiplied by the coefficient.</h2><span id='topic+regressor_coefficients'></span>

<h3>Description</h3>

<p>Coefficients are measured on the original scale of the training data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regressor_coefficients(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regressor_coefficients_+3A_m">m</code></td>
<td>
<p>Prophet model object, after fitting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Output dataframe columns:
</p>

<ul>
<li><p>regressor: Name of the regressor
</p>
</li>
<li><p>regressor_mode: Whether the regressor has an additive or multiplicative
effect on <code>y</code>.
</p>
</li>
<li><p>center: The mean of the regressor if it was standardized. Otherwise 0.
</p>
</li>
<li><p>coef_lower: Lower bound for the coefficient, estimated from the MCMC samples.
Only different to <code>coef</code> if <code>mcmc_samples &gt; 0</code>.

</p>
</li>
<li><p>coef: Expected value of the coefficient.
</p>
</li>
<li><p>coef_upper: Upper bound for the coefficient, estimated from MCMC samples.
Only to different to <code>coef</code> if <code>mcmc_samples &gt; 0</code>.

</p>
</li></ul>



<h3>Value</h3>

<p>Dataframe with one row per regressor.
</p>

<hr>
<h2 id='regressor_column_matrix'>Dataframe indicating which columns of the feature matrix correspond to
which seasonality/regressor components.</h2><span id='topic+regressor_column_matrix'></span>

<h3>Description</h3>

<p>Includes combination components, like 'additive_terms'. These combination
components will be added to the 'modes' input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regressor_column_matrix(m, seasonal.features, modes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regressor_column_matrix_+3A_m">m</code></td>
<td>
<p>Prophet object.</p>
</td></tr>
<tr><td><code id="regressor_column_matrix_+3A_seasonal.features">seasonal.features</code></td>
<td>
<p>Constructed seasonal features dataframe.</p>
</td></tr>
<tr><td><code id="regressor_column_matrix_+3A_modes">modes</code></td>
<td>
<p>List with keys 'additive' and 'multiplicative' with arrays of
component names for each mode of seasonality.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with items
component.cols: A binary indicator dataframe with columns seasonal
components and rows columns in seasonal.features. Entry is 1 if that
column is used in that component.
modes: Updated input with combination components.
</p>

<hr>
<h2 id='rmse'>Root mean squared error</h2><span id='topic+rmse'></span>

<h3>Description</h3>

<p>Root mean squared error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmse(df, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmse_+3A_df">df</code></td>
<td>
<p>Cross-validation results dataframe.</p>
</td></tr>
<tr><td><code id="rmse_+3A_w">w</code></td>
<td>
<p>Aggregation window size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Array of root mean squared errors.
</p>

<hr>
<h2 id='rolling_mean_by_h'>Compute a rolling mean of x, after first aggregating by h</h2><span id='topic+rolling_mean_by_h'></span>

<h3>Description</h3>

<p>Right-aligned. Computes a single mean for each unique value of h. Each mean
is over at least w samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rolling_mean_by_h(x, h, w, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rolling_mean_by_h_+3A_x">x</code></td>
<td>
<p>Array.</p>
</td></tr>
<tr><td><code id="rolling_mean_by_h_+3A_h">h</code></td>
<td>
<p>Array of horizon for each value in x.</p>
</td></tr>
<tr><td><code id="rolling_mean_by_h_+3A_w">w</code></td>
<td>
<p>Integer window size (number of elements).</p>
</td></tr>
<tr><td><code id="rolling_mean_by_h_+3A_name">name</code></td>
<td>
<p>String name for metric in result dataframe.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe with columns horizon and name, the rolling mean of x.
</p>

<hr>
<h2 id='rolling_median_by_h'>Compute a rolling median of x, after first aggregating by h</h2><span id='topic+rolling_median_by_h'></span>

<h3>Description</h3>

<p>Right-aligned. Computes a single median for each unique value of h. Each median
is over at least w samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rolling_median_by_h(x, h, w, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rolling_median_by_h_+3A_x">x</code></td>
<td>
<p>Array.</p>
</td></tr>
<tr><td><code id="rolling_median_by_h_+3A_h">h</code></td>
<td>
<p>Array of horizon for each value in x.</p>
</td></tr>
<tr><td><code id="rolling_median_by_h_+3A_w">w</code></td>
<td>
<p>Integer window size (number of elements).</p>
</td></tr>
<tr><td><code id="rolling_median_by_h_+3A_name">name</code></td>
<td>
<p>String name for metric in result dataframe.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each h where there are fewer than w samples, we take samples from the previous h,
</p>


<h3>Value</h3>

<p>Dataframe with columns horizon and name, the rolling median of x.
</p>

<hr>
<h2 id='sample_model'>Simulate observations from the extrapolated generative model.</h2><span id='topic+sample_model'></span>

<h3>Description</h3>

<p>Simulate observations from the extrapolated generative model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_model(m, df, seasonal.features, iteration, s_a, s_m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_model_+3A_m">m</code></td>
<td>
<p>Prophet object.</p>
</td></tr>
<tr><td><code id="sample_model_+3A_df">df</code></td>
<td>
<p>Prediction dataframe.</p>
</td></tr>
<tr><td><code id="sample_model_+3A_seasonal.features">seasonal.features</code></td>
<td>
<p>Data frame of seasonal features</p>
</td></tr>
<tr><td><code id="sample_model_+3A_iteration">iteration</code></td>
<td>
<p>Int sampling iteration to use parameters from.</p>
</td></tr>
<tr><td><code id="sample_model_+3A_s_a">s_a</code></td>
<td>
<p>Indicator vector for additive components</p>
</td></tr>
<tr><td><code id="sample_model_+3A_s_m">s_m</code></td>
<td>
<p>Indicator vector for multiplicative components</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of trend and yhat, each a vector like df$t.
</p>

<hr>
<h2 id='sample_posterior_predictive'>Prophet posterior predictive samples.</h2><span id='topic+sample_posterior_predictive'></span>

<h3>Description</h3>

<p>Prophet posterior predictive samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_posterior_predictive(m, df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_posterior_predictive_+3A_m">m</code></td>
<td>
<p>Prophet object.</p>
</td></tr>
<tr><td><code id="sample_posterior_predictive_+3A_df">df</code></td>
<td>
<p>Prediction dataframe.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with posterior predictive samples for the forecast yhat and
for the trend component.
</p>

<hr>
<h2 id='sample_predictive_trend'>Simulate the trend using the extrapolated generative model.</h2><span id='topic+sample_predictive_trend'></span>

<h3>Description</h3>

<p>Simulate the trend using the extrapolated generative model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_predictive_trend(model, df, iteration)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_predictive_trend_+3A_model">model</code></td>
<td>
<p>Prophet object.</p>
</td></tr>
<tr><td><code id="sample_predictive_trend_+3A_df">df</code></td>
<td>
<p>Prediction dataframe.</p>
</td></tr>
<tr><td><code id="sample_predictive_trend_+3A_iteration">iteration</code></td>
<td>
<p>Int sampling iteration to use parameters from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of simulated trend over df$t.
</p>

<hr>
<h2 id='seasonality_plot_df'>Prepare dataframe for plotting seasonal components.</h2><span id='topic+seasonality_plot_df'></span>

<h3>Description</h3>

<p>Prepare dataframe for plotting seasonal components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seasonality_plot_df(m, ds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seasonality_plot_df_+3A_m">m</code></td>
<td>
<p>Prophet object.</p>
</td></tr>
<tr><td><code id="seasonality_plot_df_+3A_ds">ds</code></td>
<td>
<p>Array of dates for column ds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with seasonal components on ds.
</p>

<hr>
<h2 id='set_auto_seasonalities'>Set seasonalities that were left on auto.</h2><span id='topic+set_auto_seasonalities'></span>

<h3>Description</h3>

<p>Turns on yearly seasonality if there is &gt;=2 years of history.
Turns on weekly seasonality if there is &gt;=2 weeks of history, and the
spacing between dates in the history is &lt;7 days.
Turns on daily seasonality if there is &gt;=2 days of history, and the spacing
between dates in the history is &lt;1 day.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_auto_seasonalities(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_auto_seasonalities_+3A_m">m</code></td>
<td>
<p>Prophet object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The prophet model with seasonalities set.
</p>

<hr>
<h2 id='set_changepoints'>Set changepoints</h2><span id='topic+set_changepoints'></span>

<h3>Description</h3>

<p>Sets m$changepoints to the dates of changepoints. Either:
1) The changepoints were passed in explicitly.
A) They are empty.
B) They are not empty, and need validation.
2) We are generating a grid of them.
3) The user prefers no changepoints be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_changepoints(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_changepoints_+3A_m">m</code></td>
<td>
<p>Prophet object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>m with changepoints set.
</p>

<hr>
<h2 id='set_date'>Convert date vector</h2><span id='topic+set_date'></span>

<h3>Description</h3>

<p>Convert the date to POSIXct object. Timezones are stripped and replaced
with GMT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_date(ds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_date_+3A_ds">ds</code></td>
<td>
<p>Date vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of POSIXct object converted from date
</p>

<hr>
<h2 id='setup_dataframe'>Prepare dataframe for fitting or predicting.</h2><span id='topic+setup_dataframe'></span>

<h3>Description</h3>

<p>Adds a time index and scales y. Creates auxillary columns 't', 't_ix',
'y_scaled', and 'cap_scaled'. These columns are used during both fitting
and predicting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup_dataframe(m, df, initialize_scales = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setup_dataframe_+3A_m">m</code></td>
<td>
<p>Prophet object.</p>
</td></tr>
<tr><td><code id="setup_dataframe_+3A_df">df</code></td>
<td>
<p>Data frame with columns ds, y, and cap if logistic growth. Any
specified additional regressors must also be present.</p>
</td></tr>
<tr><td><code id="setup_dataframe_+3A_initialize_scales">initialize_scales</code></td>
<td>
<p>Boolean set scaling factors in m from df.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with items 'df' and 'm'.
</p>

<hr>
<h2 id='single_cutoff_forecast'>Forecast for a single cutoff.
Used in cross_validation function when evaluating for multiple cutoffs.</h2><span id='topic+single_cutoff_forecast'></span>

<h3>Description</h3>

<p>Forecast for a single cutoff.
Used in cross_validation function when evaluating for multiple cutoffs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>single_cutoff_forecast(df, model, cutoff, horizon.dt, predict_columns)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="single_cutoff_forecast_+3A_df">df</code></td>
<td>
<p>Dataframe with history for cutoff.</p>
</td></tr>
<tr><td><code id="single_cutoff_forecast_+3A_model">model</code></td>
<td>
<p>Prophet model object.</p>
</td></tr>
<tr><td><code id="single_cutoff_forecast_+3A_cutoff">cutoff</code></td>
<td>
<p>Datetime of cutoff.</p>
</td></tr>
<tr><td><code id="single_cutoff_forecast_+3A_horizon.dt">horizon.dt</code></td>
<td>
<p>timediff forecast horizon.</p>
</td></tr>
<tr><td><code id="single_cutoff_forecast_+3A_predict_columns">predict_columns</code></td>
<td>
<p>Array of names of columns to be returned in output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe with forecast, actual value, and cutoff.
</p>

<hr>
<h2 id='smape'>Symmetric mean absolute percentage error
based on Chen and Yang (2004) formula</h2><span id='topic+smape'></span>

<h3>Description</h3>

<p>Symmetric mean absolute percentage error
based on Chen and Yang (2004) formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smape(df, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smape_+3A_df">df</code></td>
<td>
<p>Cross-validation results dataframe.</p>
</td></tr>
<tr><td><code id="smape_+3A_w">w</code></td>
<td>
<p>Aggregation window size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Array of symmetric mean absolute percent errors.
</p>

<hr>
<h2 id='time_diff'>Time difference between datetimes</h2><span id='topic+time_diff'></span>

<h3>Description</h3>

<p>Compute time difference of two POSIXct objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_diff(ds1, ds2, units = "days")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_diff_+3A_ds1">ds1</code></td>
<td>
<p>POSIXct object</p>
</td></tr>
<tr><td><code id="time_diff_+3A_ds2">ds2</code></td>
<td>
<p>POSIXct object</p>
</td></tr>
<tr><td><code id="time_diff_+3A_units">units</code></td>
<td>
<p>string units of difference, e.g. 'days' or 'secs'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric time difference
</p>

<hr>
<h2 id='validate_column_name'>Validates the name of a seasonality, holiday, or regressor.</h2><span id='topic+validate_column_name'></span>

<h3>Description</h3>

<p>Validates the name of a seasonality, holiday, or regressor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_column_name(
  m,
  name,
  check_holidays = TRUE,
  check_seasonalities = TRUE,
  check_regressors = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_column_name_+3A_m">m</code></td>
<td>
<p>Prophet object.</p>
</td></tr>
<tr><td><code id="validate_column_name_+3A_name">name</code></td>
<td>
<p>string</p>
</td></tr>
<tr><td><code id="validate_column_name_+3A_check_holidays">check_holidays</code></td>
<td>
<p>bool check if name already used for holiday</p>
</td></tr>
<tr><td><code id="validate_column_name_+3A_check_seasonalities">check_seasonalities</code></td>
<td>
<p>bool check if name already used for seasonality</p>
</td></tr>
<tr><td><code id="validate_column_name_+3A_check_regressors">check_regressors</code></td>
<td>
<p>bool check if name already used for regressor</p>
</td></tr>
</table>

<hr>
<h2 id='validate_inputs'>Validates the inputs to Prophet.</h2><span id='topic+validate_inputs'></span>

<h3>Description</h3>

<p>Validates the inputs to Prophet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_inputs(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_inputs_+3A_m">m</code></td>
<td>
<p>Prophet object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Prophet object.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
