<!DOCTYPE html><html lang="en"><head><title>Help for package eDITH</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {eDITH}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#eDITH-package'>
<p>Model Transport of Environmental DNA In River Networks</p></a></li>
<li><a href='#dataC'><p>eDNA concentration data</p></a></li>
<li><a href='#dataCD'><p>eDNA concentration and direct observation data</p></a></li>
<li><a href='#dataRead'><p>eDNA read number data</p></a></li>
<li><a href='#eval_posterior_eDITH'><p>Evaluate posterior predictions from an eDITH run</p></a></li>
<li><a href='#outSample'><p>Posterior sample from fitted eDITH model</p></a></li>
<li><a href='#posterior_pred_sim_eDITH'><p>Predictive posterior simulations from an eDITH run</p></a></li>
<li><a href='#run_eDITH_BT'><p>Run eDITH with BayesianTools</p></a></li>
<li><a href='#run_eDITH_BT_joint'><p>Run eDITH with BayesianTools  based on joint eDNA and direct sampling data</p></a></li>
<li><a href='#run_eDITH_optim'><p>Optimize eDITH</p></a></li>
<li><a href='#run_eDITH_optim_joint'><p>Optimize eDITH based on joint eDNA and direct sampling data</p></a></li>
<li><a href='#run_eDITH_single'><p>Run eDITH for a single parameter set</p></a></li>
<li><a href='#sampling_strategy_direct'><p>Determine optimal spatial arrangement for direct sampling</p></a></li>
<li><a href='#sampling_strategy_eDNA'><p>Determine optimal spatial arrangement for eDNA sampling</p></a></li>
<li><a href='#wigger'><p>River Wigger</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Model Transport of Environmental DNA in River Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Runs the eDITH (environmental DNA Integrating Transport 
  and Hydrology) model, which implements a mass balance of environmental DNA (eDNA) 
  transport at a river network scale coupled with a species distribution model 
  to obtain maps of species distribution. eDITH can work with both eDNA concentration 
  (e.g., obtained via quantitative polymerase chain reaction) or metabarcoding 
  (read count) data. Parameter estimation can be performed via Bayesian techniques 
  (via the 'BayesianTools' package) or optimization algorithms. An interface to the 
  'DHARMa' package for posterior predictive checks is provided. See Carraro and 
  Altermatt (2024) &lt;<a href="https://doi.org/10.1111%2F2041-210X.14317">doi:10.1111/2041-210X.14317</a>&gt; for a package introduction; 
  Carraro et al. (2018) &lt;<a href="https://doi.org/10.1073%2Fpnas.1813843115">doi:10.1073/pnas.1813843115</a>&gt; and Carraro et al. (2020) 
  &lt;<a href="https://doi.org/10.1038%2Fs41467-020-17337-8">doi:10.1038/s41467-020-17337-8</a>&gt; for methodological details.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, bookdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://lucarraro.github.io/eDITH/">https://lucarraro.github.io/eDITH/</a>,
<a href="https://github.com/lucarraro/eDITH">https://github.com/lucarraro/eDITH</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/lucarraro/eDITH/issues">https://github.com/lucarraro/eDITH/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.10), OCNet (&ge; 1.1.0), rivnet (&ge; 0.4.2),
BayesianTools, LaplacesDemon, DHARMa, terra, fields</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-24 08:22:56 UTC; lucac</td>
</tr>
<tr>
<td>Author:</td>
<td>Luca Carraro [cre, aut],
  Florian Altermatt [aut],
  University of Zurich [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Luca Carraro &lt;luca.carraro@hotmail.it&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-24 09:30:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='eDITH-package'>
Model Transport of Environmental DNA In River Networks
</h2><span id='topic+eDITH-package'></span><span id='topic+eDITH'></span>

<h3>Description</h3>

<p>Runs the eDITH (eDNA Integrating Transport and Hydrology) model,
which implements a mass balance of eDNA transport at a river network scale 
coupled with a species distribution model to obtain maps of species distribution. 
eDITH can work with both eDNA concentration (e.g., obtained via qPCR) or 
metabarcoding (read count) data. Parameter estimation can be performed 
via Bayesian techniques (via the <code>BayesianTools</code> package) or optimization
algorithms. An interface to the <code>DHARMa</code> package for posterior predictive
checks is provided.
</p>


<h3>Author(s)</h3>

<p>Luca Carraro (<a href="mailto:luca.carraro@hotmail.it">luca.carraro@hotmail.it</a>)
</p>


<h3>References</h3>

<p>Carraro, L., Hartikainen, H., Jokela, J., Bertuzzo, E., and Rinaldo, A. (2018). Estimating species distribution and abundance in river networks using environmental DNA. Proceedings of the National Academy of Sciences of the United States of America, 115(46), 11724-11729. doi:10.1073/pnas.1813843115
</p>
<p>Carraro, L., Maechler, E., Wuethrich, R., and Altermatt, F. (2020). Environmental DNA allows upscaling spatial patterns of biodiversity in freshwater ecosystems. Nature Communications, 11(1) doi:10.1038/s41467-020-17337-8
</p>
<p>Carraro, L., Stauffer, J. B., and Altermatt, F. (2021). How to design optimal eDNA sampling strategies for biomonitoring in river networks. Environmental DNA, 3(1), 157-172. doi:10.1002/edn3.137
</p>
<p>Carraro, L., Blackman, R. C., and Altermatt, F. (2023). Modelling environmental DNA transport in rivers reveals highly resolved spatio-temporal biodiversity patterns. Scientific Reports, 13(1) doi:10.1038/s41598-023-35614-6
</p>

<hr>
<h2 id='dataC'>eDNA concentration data</h2><span id='topic+dataC'></span>

<h3>Description</h3>

<p>The dataset consists of triplicate eDNA measurements for each of the 24 sampling sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dataC)
</code></pre>


<h3>Format</h3>

<p>A data frame containing location of eDNA sampling sites for the river Wigger (<code>dataC$ID</code>) and eDNA concentration values (<code>dataC$values</code>) (in mol m-3) for a given taxon.</p>

<hr>
<h2 id='dataCD'>eDNA concentration and direct observation data</h2><span id='topic+dataCD'></span>

<h3>Description</h3>

<p>The dataset consists of triplicate eDNA measurements for each of the 24 sampling sites, plus 13 direct observation measurements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dataCD)
</code></pre>


<h3>Format</h3>

<p>A data frame containing location of sampling sites for the river Wigger (<code>dataCD$ID</code>), respective measured values (<code>dataCD$values</code>) (in mol m-3 for eDNA samples; in m-2 for direct surveys) and data type (<code>dataCD$values</code>) (<code>"e"</code> for eDNA samples; <code>"d"</code> for direct observations) for a given taxon.</p>

<hr>
<h2 id='dataRead'>eDNA read number data</h2><span id='topic+dataRead'></span>

<h3>Description</h3>

<p>The dataset consists of triplicate eDNA measurements for each of the 24 sampling sites.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dataRead)
</code></pre>


<h3>Format</h3>

<p>A data frame containing location of eDNA sampling sites for the river Wigger (<code>dataRead$ID</code>) and eDNA read number values (<code>dataRead$values</code>) for a given taxon.</p>

<hr>
<h2 id='eval_posterior_eDITH'>Evaluate posterior predictions from an eDITH run</h2><span id='topic+eval_posterior_eDITH'></span>

<h3>Description</h3>

<p>Function that evaluates relevant quantities from a posterior sample of the parameters of an eDITH model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_posterior_eDITH(x, river, quant = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eval_posterior_eDITH_+3A_x">x</code></td>
<td>
<p>List as produced by <code><a href="#topic+run_eDITH_BT">run_eDITH_BT</a></code>.</p>
</td></tr>
<tr><td><code id="eval_posterior_eDITH_+3A_river">river</code></td>
<td>
<p>A <code>river</code> object generated via <code>aggregate_river</code>.</p>
</td></tr>
<tr><td><code id="eval_posterior_eDITH_+3A_quant">quant</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output list copies all objects of the input <code>x</code> list. The following objects are added:
</p>
<table role = "presentation">
<tr><td><code>p_quantile</code></td>
<td>
<p>Selected quantiles (along rows) of the posterior distribution of production rates.</p>
</td></tr>
<tr><td><code>C_quantile</code></td>
<td>
<p>Selected quantiles (along rows) of the posterior distribution of eDNA values 
(concentrations or read numbers).</p>
</td></tr>
<tr><td><code>probDet_quantile</code></td>
<td>
<p>Selected quantiles (along rows) of the posterior distribution of detection probability.</p>
</td></tr>
<tr><td><code>p_mean</code></td>
<td>
<p>Mean of the posterior distribution of production rates.</p>
</td></tr>
<tr><td><code>C_mean</code></td>
<td>
<p>Mean of the posterior distribution of eDNA values (concentrations or read numbers).</p>
</td></tr>
<tr><td><code>probDet_mean</code></td>
<td>
<p>Mean of the posterior distribution of detection probability.</p>
</td></tr>
</table>
<p>All of these objects are vectors of length <code>river$AG$nNodes</code>. However, if a custom likelihood was used 
in <code>run_eDITH_BT</code>, then <code>probDet_quantile</code> and <code>probDet_mean</code> are not evaluated, and are 
replaced by a vector of zero length.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rivnet)
data(wigger)
data(outSample)
out &lt;- eval_posterior_eDITH(outSample, wigger)
plot(wigger, out$p_mean)
</code></pre>

<hr>
<h2 id='outSample'>Posterior sample from fitted eDITH model</h2><span id='topic+outSample'></span>

<h3>Description</h3>

<p>It is produced via:
</p>
<p><code>covariates &lt;- data.frame(urban=wigger$SC$locCov$landcover_1,
                         agriculture=wigger$SC$locCov$landcover_2,
                         forest=wigger$SC$locCov$landcover_3,
                         elev=wigger$AG$Z,
                         log_drainageArea=log(wigger$AG$A))</code>
</p>
<p><code>set.seed(1)</code>
</p>
<p><code>outSample &lt;- run_eDITH_BT(dataC, wigger, covariates, 
                           mcmc.settings=list(iterations=9e5, burnin = 6e5, message = TRUE, thin = 30))</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(outSample)
</code></pre>


<h3>Format</h3>

<p>A list.</p>

<hr>
<h2 id='posterior_pred_sim_eDITH'>Predictive posterior simulations from an eDITH run</h2><span id='topic+posterior_pred_sim_eDITH'></span>

<h3>Description</h3>

<p>This function performs predictive posterior simulations from a run of the eDITH model (via <code>run_eDITH_BT</code>).
These can be used for diagnostics purposes, in particular to assess scaled (quantile) residuals via the 
<code>DHARMa</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posterior_pred_sim_eDITH(x, river, nParamSets = 10000, nDrawsPerParamSet = 10, 
	verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="posterior_pred_sim_eDITH_+3A_x">x</code></td>
<td>
<p>List as produced by <code><a href="#topic+run_eDITH_BT">run_eDITH_BT</a></code>.</p>
</td></tr>
<tr><td><code id="posterior_pred_sim_eDITH_+3A_river">river</code></td>
<td>
<p>A <code>river</code> object generated via <code>aggregate_river</code>.</p>
</td></tr>
<tr><td><code id="posterior_pred_sim_eDITH_+3A_nparamsets">nParamSets</code></td>
<td>
<p>Number of unique parameter sets sampled from the posterior distribution.</p>
</td></tr>
<tr><td><code id="posterior_pred_sim_eDITH_+3A_ndrawsperparamset">nDrawsPerParamSet</code></td>
<td>
<p>Number of simulations run per parameter set.</p>
</td></tr>
<tr><td><code id="posterior_pred_sim_eDITH_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Should updates be printed on the console?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nParamSets</code> can be higher than the number of unique parameter sets in the posterior distribution, 
since the sampling of posterior parameter sets is operated with replacement.
</p>


<h3>Value</h3>

<p>A matrix with dimensions <code>length(x$data$ID)</code>-by-<code>nParamSets*nDrawsPerParamSet</code>. Each column is a 
predictive posterior simulation. Each row corresponds to a site where eDNA data were observed 
(corresponding to the entries of argument <code>data</code> in <code><a href="#topic+run_eDITH_BT">run_eDITH_BT</a></code>. Matrix entries are
eDNA values (either concentrations or read numbers) predicted by the model for a given predictive posterior
simulation at a given observational site.
</p>


<h3>See Also</h3>

<p><code>DHARMa</code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(DHARMa)
data(outSample)
data(wigger)
data(dataC)
pps &lt;- posterior_pred_sim_eDITH(outSample, wigger, nParamSets = 1000) 
# reduced nParamSets for illustrative purposes

sim.out &lt;- createDHARMa(pps, dataC$values)
plot(sim.out)
</code></pre>

<hr>
<h2 id='run_eDITH_BT'>Run eDITH with BayesianTools</h2><span id='topic+run_eDITH_BT'></span>

<h3>Description</h3>

<p>Function that runs a Bayesian sampler estimating parameters of an eDITH model 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_eDITH_BT(data, river, covariates = NULL, Z.normalize = TRUE,
           use.AEM = FALSE, n.AEM = NULL, par.AEM = NULL,
           no.det = FALSE, ll.type = "norm", source.area = "AG",
           mcmc.settings = NULL, likelihood = NULL, 
		   prior = NULL, sampler.type = "DREAMzs",
           tau.prior = list(spec = "lnorm", a = 0, b = Inf, 
			meanlog = log(5), sd = sqrt(log(5) - log(4))),
           log_p0.prior = list(spec="unif",min=-20, max=0),
           beta.prior = list(spec="norm",sd=1),
           sigma.prior = list(spec="unif",min=0, max=max(data$values, na.rm = TRUE)),
           omega.prior = list(spec="unif",min=1, max=10*max(data$values, na.rm = TRUE)),
           Cstar.prior = list(spec="unif",min=0, max=max(data$values, na.rm = TRUE)),
		   verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run_eDITH_BT_+3A_data">data</code></td>
<td>
<p>eDNA data. Data frame containing columns <code>ID</code> (index of the AG node/reach where 
the eDNA sample was taken) and <code>values</code> (value of the eDNA measurement, expressed as concentration
or number of reads). </p>
</td></tr>
<tr><td><code id="run_eDITH_BT_+3A_river">river</code></td>
<td>
<p>A <code>river</code> object generated via <code>aggregate_river</code>.</p>
</td></tr>
<tr><td><code id="run_eDITH_BT_+3A_covariates">covariates</code></td>
<td>
<p>Data frame containing covariate values for all <code>river</code> reaches. If <code>NULL</code> (default
option), production rates are estimated via AEMs.</p>
</td></tr>
<tr><td><code id="run_eDITH_BT_+3A_z.normalize">Z.normalize</code></td>
<td>
<p>Logical. Should covariates be Z-normalized?</p>
</td></tr>
<tr><td><code id="run_eDITH_BT_+3A_use.aem">use.AEM</code></td>
<td>
<p>Logical. Should eigenvectors based on AEMs be used as covariates? If <code>covariates = NULL</code>, it is 
set to <code>TRUE</code>. If <code>TRUE</code> and <code>covariates</code> are provided, AEM eigenvectors are appended to the 
<code>covariates</code> data frame.</p>
</td></tr>
<tr><td><code id="run_eDITH_BT_+3A_n.aem">n.AEM</code></td>
<td>
<p>Number of AEM eigenvectors (sorted by the decreasing respective eigenvalue) to be used as covariates. If 
<code>par.AEM$moranI = TRUE</code>, this parameter is not used. Instead, the eigenvectors with significantly positive spatial
autocorrelation are used as AEM covariates.</p>
</td></tr>
<tr><td><code id="run_eDITH_BT_+3A_par.aem">par.AEM</code></td>
<td>
<p>List of additional parameters that are passed to <code>river_to_AEM</code> for calculation of AEMs. 
In particular, <code>par.AEM$moranI = TRUE</code> imposes the use of AEM covariates with significantly positive spatial 
autocorrelation based on Moran's I statistic. </p>
</td></tr>
<tr><td><code id="run_eDITH_BT_+3A_no.det">no.det</code></td>
<td>
<p>Logical. Should a probability of non-detection be included in the model?</p>
</td></tr>
<tr><td><code id="run_eDITH_BT_+3A_ll.type">ll.type</code></td>
<td>
<p>Character. String defining the error distribution used in the log-likelihood formulation. 
Allowed values are <code>norm</code> (for normal distribution), <code>lnorm</code> (for lognormal distribution), 
<code>nbinom</code> (for negative binomial distribution) and <code>geom</code> (for geometric distribution). The two latter choices 
are suited when eDNA data are expressed as read numbers, while <code>norm</code> and <code>lnorm</code> are better suited 
to eDNA concentrations. </p>
</td></tr>
<tr><td><code id="run_eDITH_BT_+3A_source.area">source.area</code></td>
<td>
<p>Defines the extent of the source area of a node. Possible values are <code>"AG"</code> (if the source
area is the reach surface, i.e. length*width), <code>"SC"</code> (if the source area is the subcatchment area), or,
alternatively, a vector with length <code>river$AG$nodes</code>.</p>
</td></tr>
<tr><td><code id="run_eDITH_BT_+3A_mcmc.settings">mcmc.settings</code></td>
<td>
<p>List. It is passed as argument <code>settings</code> in <code>runMCMC</code>. Default is 
<code>list(iterations = 2.7e6, burnin=1.8e6, message = TRUE, thin = 10).</code></p>
</td></tr>
<tr><td><code id="run_eDITH_BT_+3A_likelihood">likelihood</code></td>
<td>
<p>Likelihood function to be passed as <code>likelihood</code> argument to <code>createBayesianSetup</code>.
If not specified, it is generated based on arguments <code>no.det</code> and <code>ll.type</code>. If a custom likelihood is specified, 
a custom <code>prior</code> must also be specified.</p>
</td></tr>
<tr><td><code id="run_eDITH_BT_+3A_prior">prior</code></td>
<td>
<p>Prior function to be passed as <code>prior</code> argument to <code>createBayesianSetup</code>.
If not specified, it is generated based on the <code>*.prior</code> arguments provided. If a user-defined prior is provided,
parameter names must be included in <code>prior$lower</code>, <code>prior$upper</code> (see example).</p>
</td></tr>
<tr><td><code id="run_eDITH_BT_+3A_sampler.type">sampler.type</code></td>
<td>
<p>Character. It is passed as argument <code>sampler</code> in <code>runMCMC</code>.</p>
</td></tr>
<tr><td><code id="run_eDITH_BT_+3A_tau.prior">tau.prior</code></td>
<td>
<p>List that defines the prior distribution for the decay time parameter <code>tau</code>. See details. </p>
</td></tr>
<tr><td><code id="run_eDITH_BT_+3A_log_p0.prior">log_p0.prior</code></td>
<td>
<p>List that defines the prior distribution for the logarithm (in base 10) of the baseline production rate 
<code>p0</code>.  See details. If <code>covariates = NULL</code>, this defines the prior distribution for the logarithm (in base 10) of 
production rates for all <code>river</code> reaches.</p>
</td></tr>
<tr><td><code id="run_eDITH_BT_+3A_beta.prior">beta.prior</code></td>
<td>
<p>List that defines the prior distribution for the covariate effects <code>beta</code>. See details. If a single 
<code>spec</code> is provided, the same prior distribution is specified for all <code>beta</code> parameters. Alternatively, if 
<code>spec</code> (and the other arguments, if provided) is a vector with length equal to the number of covariates included, 
different prior distributions can be specified for the different <code>beta</code> parameters.</p>
</td></tr>
<tr><td><code id="run_eDITH_BT_+3A_sigma.prior">sigma.prior</code></td>
<td>
<p>List that defines the prior distribution for the standard deviation of the measurement error 
when <code>ll.type</code>  is <code>"norm"</code> or <code>"lnorm"</code>. It is not used if <code>ll.type = "nbinom"</code>. See details.</p>
</td></tr>
<tr><td><code id="run_eDITH_BT_+3A_omega.prior">omega.prior</code></td>
<td>
<p>List that defines the prior distribution for the overdispersion parameter <code>omega</code> of the 
measurement error when <code>ll.type = "nbinom"</code>. It is not used if  <code>ll.type</code> is <code>"norm"</code> or <code>"lnorm"</code>.
See details.</p>
</td></tr>
<tr><td><code id="run_eDITH_BT_+3A_cstar.prior">Cstar.prior</code></td>
<td>
<p>List that defines the prior distribution for the <code>Cstar</code> parameter controlling the probability
of no detection. It is only used if <code>no.det = TRUE</code>. See details.</p>
</td></tr>
<tr><td><code id="run_eDITH_BT_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Should console output be displayed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments of the type <code>*.prior</code> consist in the lists  of arguments required by <code>dtrunc</code> 
(except the first argument <code>x</code>).
</p>
<p>By default, AEMs are computed without attributing weights to the edges  of the river network. 
Use e.g. <code>par.AEM = list(weight = "gravity")</code> to attribute weights. 
</p>


<h3>Value</h3>

<p>A list with objects:
</p>
<table role = "presentation">
<tr><td><code>param_map</code></td>
<td>
<p>Vector of named parameters corresponding to the maximum a posteriori estimate. It is the
output of the call to <code>MAP</code>.</p>
</td></tr>
<tr><td><code>p_map</code></td>
<td>
<p>Vector of best-fit eDNA production rates corresponding to the maximum a posteriori parameter 
estimate <code>param_map</code>. It has length equal to <code>river$AG$nNodes</code>.</p>
</td></tr>
<tr><td><code>C_map</code></td>
<td>
<p>Vector of best-fit eDNA values (in the same unit as <code>data$values</code>, i.e. concentrations or read numbers) 
corresponding to the maximum a posteriori parameter  estimate <code>param_map</code>. It has length equal to <code>river$AG$nNodes</code>.</p>
</td></tr>
<tr><td><code>probDet_map</code></td>
<td>
<p>Vector of best-fit detection probabilities corresponding to the maximum a posteriori
parameter estimate <code>param_map</code>. It has length equal to <code>river$AG$nNodes</code>. If a custom <code>likelihood</code> is provided,
this is a vector of null length (in which case the user should calculate the probability of detection independently, based on
the chosen likelihood).</p>
</td></tr>
<tr><td><code>cI</code></td>
<td>
<p>Output of the call to <code>getCredibleIntervals</code>.</p>
</td></tr>
<tr><td><code>gD</code></td>
<td>
<p>Output of the call to <code>gelmanDiagnostics</code>.</p>
</td></tr>
<tr><td><code>covariates</code></td>
<td>
<p>Data frame containing input covariate values (possibly Z-normalized).</p>
</td></tr>
<tr><td><code>source.area</code></td>
<td>
<p>Vector of source area values.</p>
</td></tr>
<tr><td><code>outMCMC</code></td>
<td>
<p>Object of class <code>mcmcSampler</code> returned by the call to <code>runMCMC</code>.</p>
</td></tr> 
</table>
<p>Moreover, arguments <code>ll.type</code> (possibly changed to <code>"custom"</code> if a custom likelihood is specified), <code>no.det</code> 
and <code>data</code> are added to the list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wigger)
data(dataC)
data(dataRead)

# reduce number of iterations for illustrative purposes 
# (use default mcmc.settings to ensure convergence)
settings.short &lt;- list(iterations = 1e3, thin = 10)
set.seed(1)
out &lt;- run_eDITH_BT(dataC, wigger, mcmc.settings = settings.short)


library(rivnet)
# best-fit (maximum a posteriori) map of eDNA production rates
plot(wigger, out$p_map)

# best-fit map (maximum a posteriori) of detection probability
plot(wigger, out$probDet_map)


# compare best-fit vs observed eDNA concentrations
plot(out$C_map[dataC$ID], dataC$values,
	xlab="Modelled (MAP) concentrations", ylab="Observed concentrations")
abline(a=0, b=1) 

## fit eDNA read number data - use AEMs as covariates
out &lt;- run_eDITH_BT(dataRead, wigger, ll.type = "nbinom",
	par.AEM = list(weight = "gravity"),
	mcmc.settings = settings.short) # use default mcmc.settings to ensure convergence

## use user-defined covariates
covariates &lt;- data.frame(urban = wigger$SC$locCov$landcover_1,
                         agriculture = wigger$SC$locCov$landcover_2,
                         forest = wigger$SC$locCov$landcover_3,
                         elev = wigger$AG$Z,
                         log_drainageArea = log(wigger$AG$A))
						 
out.cov &lt;- 	run_eDITH_BT(dataC, wigger, covariates, 
	mcmc.settings = settings.short) # use default mcmc.settings to ensure convergence

# use user-defined covariates and AEMs
out.covAEM &lt;- 	run_eDITH_BT(dataC, wigger, covariates, 
	use.AEM = TRUE, par.AEM = list(weight = "gravity"),
	mcmc.settings = settings.short) # use default mcmc.settings to ensure convergence	

# use AEMs with significantly positive spatial autocorrelation
out.AEM.moran &lt;- run_eDITH_BT(dataC, wigger, use.AEM = TRUE,
	par.AEM = list(weight = "gravity", moranI = TRUE), 
	mcmc.settings = settings.short) # use default mcmc.settings to ensure convergence 

## use posterior sample to specify user-defined prior
library(BayesianTools)
data(outSample)
pp &lt;- createPriorDensity(outSample$outMCMC)
# Important! add parameter names to objects lower, upper
names(pp$lower) &lt;- names(pp$upper) &lt;- colnames(outSample$outMCMC$chain[[1]])[1:8] 
# the three last columns are for log-posterior, log-likelihood, log-prior 
out.new &lt;- run_eDITH_BT(dataC, wigger, covariates, prior = pp, 
	mcmc.settings = settings.short)
	

</code></pre>

<hr>
<h2 id='run_eDITH_BT_joint'>Run eDITH with BayesianTools  based on joint eDNA and direct sampling data</h2><span id='topic+run_eDITH_BT_joint'></span>

<h3>Description</h3>

<p>Function that runs a Bayesian sampler estimating parameters of an eDITH model fitted on both 
eDNA and direct sampling data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_eDITH_BT_joint(data, river, covariates = NULL, Z.normalize = TRUE,
           use.AEM = FALSE, n.AEM = NULL, par.AEM = NULL,
           no.det = FALSE, ll.type = "norm", source.area = "AG",
           mcmc.settings = NULL, likelihood = NULL, prior = NULL, 
		   sampler.type = "DREAMzs",
           tau.prior = list(spec="lnorm",a=0,b=Inf, meanlog=log(5), 
		                    sd=sqrt(log(5)-log(4))),
           log_p0.prior = list(spec="unif",min=-20, max=0),
           beta.prior = list(spec="norm",sd=1),
           sigma.prior = list(spec="unif",min=0, 
			                  max=max(data$values[data$type=="e"], 
							  na.rm = TRUE)),
           omega.prior = list(spec="unif",min=1, 
			                  max=10*max(data$values[data$type=="e"], 
							  na.rm = TRUE)),
           Cstar.prior = list(spec="unif",min=0, 
			                  max=max(data$values[data$type=="e"], 
							  na.rm = TRUE)),
           omega_d.prior = list(spec="unif",min=1,
                                max=10*max(c(0.11, data$values[data$type=="d"]), 
								na.rm = TRUE)),
           alpha.prior = list(spec="unif", min=0, max=1e6),
           verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run_eDITH_BT_joint_+3A_data">data</code></td>
<td>
<p>eDNA and direct observation data. Data frame containing columns <code>ID</code> (index of the AG node/reach where 
the sample was taken), <code>values</code> (value of the eDNA or direct measurement) and <code>type</code> 
(equal to <code>"e"</code> for eDNA data and to <code>"d"</code> for direct observation data). eDNA values 
are expressed as concentration or number of reads; direct observations are expressed as numbers of individuals. </p>
</td></tr>
<tr><td><code id="run_eDITH_BT_joint_+3A_river">river</code></td>
<td>
<p>A <code>river</code> object generated via <code>aggregate_river</code>.</p>
</td></tr>
<tr><td><code id="run_eDITH_BT_joint_+3A_covariates">covariates</code></td>
<td>
<p>Data frame containing covariate values for all <code>river</code> reaches. If <code>NULL</code> (default
option), production rates are estimated via AEMs.</p>
</td></tr>
<tr><td><code id="run_eDITH_BT_joint_+3A_z.normalize">Z.normalize</code></td>
<td>
<p>Logical. Should covariates be Z-normalized?</p>
</td></tr>
<tr><td><code id="run_eDITH_BT_joint_+3A_use.aem">use.AEM</code></td>
<td>
<p>Logical. Should eigenvectors based on AEMs be used as covariates? If <code>covariates = NULL</code>, it is 
set to <code>TRUE</code>. If <code>TRUE</code> and <code>covariates</code> are provided, AEM eigenvectors are appended to the 
<code>covariates</code> data frame.</p>
</td></tr>
<tr><td><code id="run_eDITH_BT_joint_+3A_n.aem">n.AEM</code></td>
<td>
<p>Number of AEM eigenvectors (sorted by the decreasing respective eigenvalue) to be used as covariates. If 
<code>par.AEM$moranI = TRUE</code>, this parameter is not used. Instead, the eigenvectors with significantly positive spatial
autocorrelation are used as AEM covariates.</p>
</td></tr>
<tr><td><code id="run_eDITH_BT_joint_+3A_par.aem">par.AEM</code></td>
<td>
<p>List of additional parameters that are passed to <code>river_to_AEM</code> for calculation of AEMs. 
In particular, <code>par.AEM$moranI = TRUE</code> imposes the use of AEM covariates with significantly positive spatial 
autocorrelation based on Moran's I statistic. </p>
</td></tr>
<tr><td><code id="run_eDITH_BT_joint_+3A_no.det">no.det</code></td>
<td>
<p>Logical. Should a probability of non-detection be included in the model?</p>
</td></tr>
<tr><td><code id="run_eDITH_BT_joint_+3A_ll.type">ll.type</code></td>
<td>
<p>Character. String defining the error distribution used in the log-likelihood formulation. 
Allowed values are <code>norm</code> (for normal distribution), <code>lnorm</code> (for lognormal distribution), 
<code>nbinom</code> (for negative binomial distribution) and <code>geom</code> (for geometric distribution). The two latter choices 
are suited when eDNA data are expressed as read numbers, while <code>norm</code> and <code>lnorm</code> are better suited 
to eDNA concentrations. </p>
</td></tr>
<tr><td><code id="run_eDITH_BT_joint_+3A_source.area">source.area</code></td>
<td>
<p>Defines the extent of the source area of a node. Possible values are <code>"AG"</code> (if the source
area is the reach surface, i.e. length*width), <code>"SC"</code> (if the source area is the subcatchment area), or,
alternatively, a vector with length <code>river$AG$nodes</code>.</p>
</td></tr>
<tr><td><code id="run_eDITH_BT_joint_+3A_mcmc.settings">mcmc.settings</code></td>
<td>
<p>List. It is passed as argument <code>settings</code> in <code>runMCMC</code>. Default is 
<code>list(iterations = 2.7e6, burnin=1.8e6, message = TRUE, thin = 10).</code></p>
</td></tr>
<tr><td><code id="run_eDITH_BT_joint_+3A_likelihood">likelihood</code></td>
<td>
<p>Likelihood function to be passed as <code>likelihood</code> argument to <code>createBayesianSetup</code>.
If not specified, it is generated based on arguments <code>no.det</code> and <code>ll.type</code>. If a custom likelihood is specified, 
a custom <code>prior</code> must also be specified.</p>
</td></tr>
<tr><td><code id="run_eDITH_BT_joint_+3A_prior">prior</code></td>
<td>
<p>Prior function to be passed as <code>prior</code> argument to <code>createBayesianSetup</code>.
If not specified, it is generated based on the <code>*.prior</code> arguments provided. If a user-defined prior is provided,
parameter names must be included in <code>prior$lower</code>, <code>prior$upper</code> (see example).</p>
</td></tr>
<tr><td><code id="run_eDITH_BT_joint_+3A_sampler.type">sampler.type</code></td>
<td>
<p>Character. It is passed as argument <code>sampler</code> in <code>runMCMC</code>.</p>
</td></tr>
<tr><td><code id="run_eDITH_BT_joint_+3A_tau.prior">tau.prior</code></td>
<td>
<p>List that defines the prior distribution for the decay time parameter <code>tau</code>. See details. </p>
</td></tr>
<tr><td><code id="run_eDITH_BT_joint_+3A_log_p0.prior">log_p0.prior</code></td>
<td>
<p>List that defines the prior distribution for the logarithm (in base 10) of the baseline production rate 
<code>p0</code>.  See details. If <code>covariates = NULL</code>, this defines the prior distribution for the logarithm (in base 10) of 
production rates for all <code>river</code> reaches.</p>
</td></tr>
<tr><td><code id="run_eDITH_BT_joint_+3A_beta.prior">beta.prior</code></td>
<td>
<p>List that defines the prior distribution for the covariate effects <code>beta</code>. See details. If a single 
<code>spec</code> is provided, the same prior distribution is specified for all <code>beta</code> parameters. Alternatively, if 
<code>spec</code> (and the other arguments, if provided) is a vector with length equal to the number of covariates included, 
different prior distributions can be specified for the different <code>beta</code> parameters.</p>
</td></tr>
<tr><td><code id="run_eDITH_BT_joint_+3A_sigma.prior">sigma.prior</code></td>
<td>
<p>List that defines the prior distribution for the standard deviation of the measurement error 
when <code>ll.type</code>  is <code>"norm"</code> or <code>"lnorm"</code>. It is not used if <code>ll.type = "nbinom"</code>. See details.</p>
</td></tr>
<tr><td><code id="run_eDITH_BT_joint_+3A_omega.prior">omega.prior</code></td>
<td>
<p>List that defines the prior distribution for the overdispersion parameter <code>omega</code> of the 
measurement error when <code>ll.type = "nbinom"</code>. It is not used if  <code>ll.type</code> is <code>"norm"</code> or <code>"lnorm"</code>.
See details.</p>
</td></tr>
<tr><td><code id="run_eDITH_BT_joint_+3A_cstar.prior">Cstar.prior</code></td>
<td>
<p>List that defines the prior distribution for the <code>Cstar</code> parameter controlling the probability
of no detection. It is only used if <code>no.det = TRUE</code>. See details.</p>
</td></tr>
<tr><td><code id="run_eDITH_BT_joint_+3A_omega_d.prior">omega_d.prior</code></td>
<td>
<p>Prior distribution for the overdispersion parameter for direct sampling density observations.</p>
</td></tr>
<tr><td><code id="run_eDITH_BT_joint_+3A_alpha.prior">alpha.prior</code></td>
<td>
<p>Prior distribution for the inverse DNA shedding rate (i.e., the organismal density 
that sheds a unit eDNA value per unit time).</p>
</td></tr>
<tr><td><code id="run_eDITH_BT_joint_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Should console output be displayed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The arguments of the type <code>*.prior</code> consist in the lists  of arguments required by <code>dtrunc</code> 
(except the first argument <code>x</code>).
</p>
<p>By default, AEMs are computed without attributing weights to the edges  of the river network. 
Use e.g. <code>par.AEM = list(weight = "gravity")</code> to attribute weights. 
</p>


<h3>Value</h3>

<p>A list with objects:
</p>
<table role = "presentation">
<tr><td><code>param_map</code></td>
<td>
<p>Vector of named parameters corresponding to the maximum a posteriori estimate. It is the
output of the call to <code>MAP</code>.</p>
</td></tr>
<tr><td><code>p_map</code></td>
<td>
<p>Vector of best-fit eDNA production rates corresponding to the maximum a posteriori parameter 
estimate <code>param_map</code>. It has length equal to <code>river$AG$nNodes</code>.</p>
</td></tr>
<tr><td><code>C_map</code></td>
<td>
<p>Vector of best-fit eDNA values (in the same unit as <code>data$values</code>, i.e. concentrations or read numbers) 
corresponding to the maximum a posteriori parameter  estimate <code>param_map</code>. It has length equal to <code>river$AG$nNodes</code>.</p>
</td></tr>
<tr><td><code>probDet_map</code></td>
<td>
<p>Vector of best-fit detection probabilities corresponding to the maximum a posteriori
parameter estimate <code>param_map</code>. It has length equal to <code>river$AG$nNodes</code>. If a custom <code>likelihood</code> is provided,
this is a vector of null length (in which case the user should calculate the probability of detection independently, based on
the chosen likelihood).</p>
</td></tr>
<tr><td><code>cI</code></td>
<td>
<p>Output of the call to <code>getCredibleIntervals</code>.</p>
</td></tr>
<tr><td><code>gD</code></td>
<td>
<p>Output of the call to <code>gelmanDiagnostics</code>.</p>
</td></tr>
<tr><td><code>covariates</code></td>
<td>
<p>Data frame containing input covariate values (possibly Z-normalized).</p>
</td></tr>
<tr><td><code>source.area</code></td>
<td>
<p>Vector of source area values.</p>
</td></tr>
<tr><td><code>outMCMC</code></td>
<td>
<p>Object of class <code>mcmcSampler</code> returned by the call to <code>runMCMC</code>.</p>
</td></tr> 
</table>
<p>Moreover, arguments <code>ll.type</code> (possibly changed to <code>"custom"</code> if a custom likelihood is specified), <code>no.det</code> 
and <code>data</code> are added to the list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wigger)
data(dataCD)

# reduce number of iterations for illustrative purposes 
# (use default mcmc.settings to ensure convergence)
settings.short &lt;- list(iterations = 1e3, thin = 10)
set.seed(1)
out &lt;- run_eDITH_BT_joint(dataCD, wigger, mcmc.settings = settings.short)


library(rivnet)
# best-fit (maximum a posteriori) map of eDNA production rates
plot(wigger, out$p_map)

# best-fit map (maximum a posteriori) of detection probability
plot(wigger, out$probDet_map)


# compare best-fit vs observed values
data.e &lt;- which(dataCD$type=="e")
data.d &lt;- which(dataCD$type=="d")

plot(out$C_map[dataCD$ID[data.e]], dataCD$values[data.e],
	xlab="Modelled (MAP) eDNA concentrations", ylab="Observed eDNA concentrations")
abline(a=0, b=1) 

plot(out$p_map[dataCD$ID[data.d]], dataCD$values[data.d],
	xlab="Modelled (MAP) eDNA production rate", ylab="Observed density data")



</code></pre>

<hr>
<h2 id='run_eDITH_optim'>Optimize eDITH</h2><span id='topic+run_eDITH_optim'></span>

<h3>Description</h3>

<p>Function that performs search of optimal parameters of an eDITH model 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_eDITH_optim(data, river, covariates = NULL, Z.normalize = TRUE,
           use.AEM = FALSE, n.AEM = NULL, par.AEM = NULL,
           no.det = FALSE, ll.type = "norm", source.area = "AG",
           likelihood = NULL, sampler = NULL, n.attempts = 100, 
		   n.restarts = round(n.attempts/10), par.optim = NULL, 
		   tau.prior = list(spec="lnorm",a=0,b=Inf,
		   meanlog=log(5), sd=sqrt(log(5)-log(4))),
           log_p0.prior = list(spec="unif",min=-20, max=0),
           beta.prior = list(spec="norm",sd=1),
           sigma.prior = list(spec="unif",min=0, max=1*max(data$values, na.rm = TRUE)),
           omega.prior = list(spec="unif",min=1, max=10*max(data$values, na.rm = TRUE)),
           Cstar.prior = list(spec="unif",min=0, max=1*max(data$values, na.rm = TRUE)),
		   verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run_eDITH_optim_+3A_data">data</code></td>
<td>
<p>eDNA data. Data frame containing columns <code>ID</code> (index of the AG node/reach where 
the eDNA sample was taken) and <code>values</code> (value of the eDNA measurement, expressed as concentration
or number of reads). </p>
</td></tr>
<tr><td><code id="run_eDITH_optim_+3A_river">river</code></td>
<td>
<p>A <code>river</code> object generated via <code>aggregate_river</code>.</p>
</td></tr>
<tr><td><code id="run_eDITH_optim_+3A_covariates">covariates</code></td>
<td>
<p>Data frame containing covariate values for all <code>river</code> reaches. If <code>NULL</code> (default
option), production rates are estimated via AEMs.</p>
</td></tr>
<tr><td><code id="run_eDITH_optim_+3A_z.normalize">Z.normalize</code></td>
<td>
<p>Logical. Should covariates be Z-normalized?</p>
</td></tr>
<tr><td><code id="run_eDITH_optim_+3A_use.aem">use.AEM</code></td>
<td>
<p>Logical. Should eigenvectors based on AEMs be used as covariates? If <code>covariates = NULL</code>, it is 
set to <code>TRUE</code>. If <code>TRUE</code> and <code>covariates</code> are provided, AEM eigenvectors are appended to the 
<code>covariates</code> data frame.</p>
</td></tr>
<tr><td><code id="run_eDITH_optim_+3A_n.aem">n.AEM</code></td>
<td>
<p>Number of AEM eigenvectors (sorted by the decreasing respective eigenvalue) to be used as covariates. If 
<code>par.AEM$moranI = TRUE</code>, this parameter is not used. Instead, the eigenvectors with significantly positive spatial
autocorrelation are used as AEM covariates.</p>
</td></tr>
<tr><td><code id="run_eDITH_optim_+3A_par.aem">par.AEM</code></td>
<td>
<p>List of additional parameters that are passed to <code>river_to_AEM</code> for calculation of AEMs. 
In particular, <code>par.AEM$moranI = TRUE</code> imposes the use of AEM covariates with significantly positive spatial 
autocorrelation based on Moran's I statistic. </p>
</td></tr>
<tr><td><code id="run_eDITH_optim_+3A_no.det">no.det</code></td>
<td>
<p>Logical. Should a probability of non-detection be included in the model?</p>
</td></tr>
<tr><td><code id="run_eDITH_optim_+3A_ll.type">ll.type</code></td>
<td>
<p>Character. String defining the error distribution used in the log-likelihood formulation. 
Allowed values are <code>norm</code> (for normal distribution), <code>lnorm</code> (for lognormal distribution), 
<code>nbinom</code> (for negative binomial distribution) and <code>geom</code> (for geometric distribution). The two latter choices 
are suited when eDNA data are expressed as read numbers, while <code>norm</code> and <code>lnorm</code> are better suited 
to eDNA concentrations. </p>
</td></tr>
<tr><td><code id="run_eDITH_optim_+3A_source.area">source.area</code></td>
<td>
<p>Defines the extent of the source area of a node. Possible values are <code>"AG"</code> (if the source
area is the reach surface, i.e. length*width), <code>"SC"</code> (if the source area is the subcatchment area), or,
alternatively, a vector with length <code>river$AG$nodes</code>.</p>
</td></tr>
<tr><td><code id="run_eDITH_optim_+3A_likelihood">likelihood</code></td>
<td>
<p>Likelihood function. If not specified, it is generated based on 
arguments <code>no.det</code> and <code>ll.type</code>. </p>
</td></tr>
<tr><td><code id="run_eDITH_optim_+3A_sampler">sampler</code></td>
<td>
<p>Function generating sets of initial parameter values for the optimization algorithm. If <code>NULL</code>, 
initial parameter values are drawn from the default prior distributions of <code><a href="#topic+run_eDITH_BT">run_eDITH_BT</a></code>. See details.</p>
</td></tr>
<tr><td><code id="run_eDITH_optim_+3A_n.attempts">n.attempts</code></td>
<td>
<p>Number of times the optimizing function <code>optim</code> is executed. Every time a &quot;restart&quot; happens 
(see <code>n.restarts</code>), <code>sampler</code> is used to draw an initial parameter set. If a &quot;restart&quot; does not happen, 
the optimal parameter set from the previous attempt is used as initial parameter set.</p>
</td></tr>
<tr><td><code id="run_eDITH_optim_+3A_n.restarts">n.restarts</code></td>
<td>
<p>Number of times a random parameter set is drawn as initial condition for <code>optim</code>.</p>
</td></tr>
<tr><td><code id="run_eDITH_optim_+3A_par.optim">par.optim</code></td>
<td>
<p>List of parameters to be passed to <code><a href="stats.html#topic+optim">optim</a></code>. By default, the likelihood is maximized (i.e., 
<code>control$fnscale = -1</code>), and the maximum number of iterations is set to 1e6. The default optimization method is 
&quot;Nelder-Mead&quot; (same default as in <code>optim</code>).</p>
</td></tr>
<tr><td><code id="run_eDITH_optim_+3A_tau.prior">tau.prior</code>, <code id="run_eDITH_optim_+3A_log_p0.prior">log_p0.prior</code>, <code id="run_eDITH_optim_+3A_beta.prior">beta.prior</code>, <code id="run_eDITH_optim_+3A_sigma.prior">sigma.prior</code>, <code id="run_eDITH_optim_+3A_omega.prior">omega.prior</code>, <code id="run_eDITH_optim_+3A_cstar.prior">Cstar.prior</code></td>
<td>
<p>Prior distribution for the relevant
parameters of the eDITH model.</p>
</td></tr>
<tr><td><code id="run_eDITH_optim_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Should console output be displayed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function attempts to maximize the log-posterior (sum of log-likelihood and log-prior) via the 
non-linear optimization function <code><a href="stats.html#topic+optim">optim</a></code>.  
</p>
<p>If specified by the user, <code>sampler</code> must be a function that produces as output a &quot;named num&quot; 
vector of parameters. Parameter names must be same as in the <code>likelihood</code>. See example.
</p>
<p>By default, AEMs are computed without attributing weights to the edges  of the river network. 
Use e.g. <code>par.AEM = list(weight = "gravity")</code> to attribute weights. 
</p>


<h3>Value</h3>

<p>A list with objects:
</p>
<table role = "presentation">
<tr><td><code>p</code></td>
<td>
<p>Vector of best-fit eDNA production rates corresponding to the optimum parameter 
estimates <code>param</code>. It has length equal to <code>river$AG$nNodes</code>.</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>Vector of best-fit eDNA values (in the same unit as <code>data$values</code>, i.e. concentrations or read numbers) 
corresponding to the optimum parameter  estimates <code>param</code>. It has length equal to <code>river$AG$nNodes</code>.</p>
</td></tr>
<tr><td><code>probDet</code></td>
<td>
<p>Vector of best-fit detection probabilities corresponding to the optimum
parameter estimate <code>param_map</code>. It has length equal to <code>river$AG$nNodes</code>. If a custom <code>likelihood</code> is provided,
this is a vector of null length (in which case the user should calculate the probability of detection independently, based on
the chosen likelihood).</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>Vector of named parameters corresponding to the best-fit estimate.</p>
</td></tr>
<tr><td><code>covariates</code></td>
<td>
<p>Data frame containing input covariate values (possibly Z-normalized).</p>
</td></tr>
<tr><td><code>source.area</code></td>
<td>
<p>Vector of source area values.</p>
</td></tr>
<tr><td><code>out_optim</code></td>
<td>
<p>List as provided by <code>optim</code>. Only the result of the call to <code>optim</code> (out of <code>n.attempts</code>)
yielding the highest likelihood is exported.</p>
</td></tr> 
<tr><td><code>attempts.stats</code></td>
<td>
<p>List containing relevant output for the different optimization attempts. It contains <code>lp</code> 
(vector of maximized log-posterior values for each single attempt), <code>counts</code> (total function evaluations), <code>conv</code> 
(convergence flags as produced by <code>optim</code>), and <code>tau</code> (best-fit decay time values in h).</p>
</td></tr> 
</table>
<p>Moreover, arguments <code>ll.type</code> (possibly changed to <code>"custom"</code> if a custom likelihood is specified), <code>no.det</code> 
and <code>data</code> are added to the list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wigger)
data(dataC)
data(dataRead)

## fit eDNA concentration data - use AEMs as covariates
set.seed(9)
out &lt;- run_eDITH_optim(dataC, wigger, n.AEM = 10, 
	n.attempts = 1) # reduced n.AEM, n.attempts for illustrative purposes
	# it is recommended to attempt optimization several times to ensure convergence 

library(rivnet)
# best-fit map of eDNA production rates
plot(wigger, out$p)

# best-fit map of detection probability
plot(wigger, out$probDet)

# compare best-fit vs observed eDNA concentrations
plot(out$C[dataC$ID], dataC$values,
	xlab = "Modelled concentrations", ylab = "Observed concentrations")
abline(a=0, b=1) 

## fit eDNA read number data - use AEMs as covariates
set.seed(5)
out &lt;- run_eDITH_optim(dataRead, wigger, ll.type = "nbinom", 
			par.AEM = list(weight = "gravity"), 
			n.attempts = 1) # reduced n.attempts for illustrative purposes

## use user-defined covariates
covariates &lt;- data.frame(urban = wigger$SC$locCov$landcover_1,
                         agriculture = wigger$SC$locCov$landcover_2,
                         forest = wigger$SC$locCov$landcover_3,
                         elev = wigger$AG$Z,
                         log_drainageArea = log(wigger$AG$A))

set.seed(2)						 
out.cov &lt;- 	run_eDITH_optim(dataC, wigger, covariates, n.attempts = 1) 
# reduced n.attempts for illustrative purposes	

# use user-defined covariates and AEMs
set.seed(1)
out.covAEM &lt;- run_eDITH_optim(dataC, wigger, covariates, use.AEM = TRUE, 
				 par.AEM = list(weight = "gravity"), 
				 n.attempts = 1) # reduced n.attempts for illustrative purposes				 

# use AEMs with significantly positive spatial autocorrelation
set.seed(1)
out.AEM.moran &lt;- run_eDITH_optim(dataC, wigger, use.AEM = TRUE,
	par.AEM = list(weight = "gravity", moranI = TRUE), 
	n.attempts = 1) # reduced n.attempts for illustrative purposes	

# define sampler function when the first 10 AEMs are used as covariates
samp_fun &lt;- function(n){ # input argument needed but not used
    mins = c(0, -20, rep(-5,10), 0)
    maxs = c(10, 0, rep(5,10), 5e-12)
    nams = c("tau", "log_p0", paste0("beta_AEM",1:10), "sigma")
    vec &lt;- runif(numeric(13), min=mins, max=maxs)
    names(vec) &lt;- nams
    return(vec)}
set.seed(1)
out.samp &lt;- run_eDITH_optim(dataC, wigger, n.AEM = 10, 
    sampler = samp_fun,
	n.attempts = 1) # reduced n.attempts for illustrative purposes



</code></pre>

<hr>
<h2 id='run_eDITH_optim_joint'>Optimize eDITH based on joint eDNA and direct sampling data</h2><span id='topic+run_eDITH_optim_joint'></span>

<h3>Description</h3>

<p>Function that performs search of optimal parameters of an eDITH model fitted on both 
eDNA and direct sampling data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_eDITH_optim_joint(data, river, covariates = NULL, Z.normalize = TRUE,
           use.AEM = FALSE, n.AEM = NULL, par.AEM = NULL,
           no.det = FALSE, ll.type = "norm", source.area = "AG",
           likelihood = NULL, sampler = NULL, n.attempts = 100,
           n.restarts = round(n.attempts/10), par.optim = NULL,
           tau.prior = list(spec="lnorm",a=0,b=Inf, meanlog=log(5), 
		                    sd=sqrt(log(5)-log(4))),
           log_p0.prior = list(spec="unif",min=-20, max=0),
           beta.prior = list(spec="norm",sd=1),
           sigma.prior = list(spec="unif",min=0,
                              max=1*max(c(1e-6, data$values[data$type=="e"]), 
							  na.rm = TRUE)),
           omega.prior = list(spec="unif",min=1,
                              max=10*max(c(0.11, data$values[data$type=="e"]), 
							  na.rm = TRUE)),
           Cstar.prior = list(spec="unif",min=0,
                              max=1*max(c(1e-6, data$values[data$type=="e"]), 
							  na.rm = TRUE)),
           omega_d.prior = list(spec="unif",min=1,
                                max=10*max(c(0.11, data$values[data$type=="d"]), 
								na.rm = TRUE)),
           alpha.prior = list(spec="unif", min=0, max=1e6),
           verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run_eDITH_optim_joint_+3A_data">data</code></td>
<td>
<p>eDNA and direct observation data. Data frame containing columns <code>ID</code> (index of the AG node/reach where 
the sample was taken), <code>values</code> (value of the eDNA or direct measurement) and <code>type</code> 
(equal to <code>"e"</code> for eDNA data and to <code>"d"</code> for direct observation data). eDNA values 
are expressed as concentration or number of reads; direct observations are expressed as numbers of individuals. </p>
</td></tr>
<tr><td><code id="run_eDITH_optim_joint_+3A_river">river</code></td>
<td>
<p>A <code>river</code> object generated via <code>aggregate_river</code>.</p>
</td></tr>
<tr><td><code id="run_eDITH_optim_joint_+3A_covariates">covariates</code></td>
<td>
<p>Data frame containing covariate values for all <code>river</code> reaches. If <code>NULL</code> (default
option), production rates are estimated via AEMs.</p>
</td></tr>
<tr><td><code id="run_eDITH_optim_joint_+3A_z.normalize">Z.normalize</code></td>
<td>
<p>Logical. Should covariates be Z-normalized?</p>
</td></tr>
<tr><td><code id="run_eDITH_optim_joint_+3A_use.aem">use.AEM</code></td>
<td>
<p>Logical. Should eigenvectors based on AEMs be used as covariates? If <code>covariates = NULL</code>, it is 
set to <code>TRUE</code>. If <code>TRUE</code> and <code>covariates</code> are provided, AEM eigenvectors are appended to the 
<code>covariates</code> data frame.</p>
</td></tr>
<tr><td><code id="run_eDITH_optim_joint_+3A_n.aem">n.AEM</code></td>
<td>
<p>Number of AEM eigenvectors (sorted by the decreasing respective eigenvalue) to be used as covariates. If 
<code>par.AEM$moranI = TRUE</code>, this parameter is not used. Instead, the eigenvectors with significantly positive spatial
autocorrelation are used as AEM covariates.</p>
</td></tr>
<tr><td><code id="run_eDITH_optim_joint_+3A_par.aem">par.AEM</code></td>
<td>
<p>List of additional parameters that are passed to <code>river_to_AEM</code> for calculation of AEMs. 
In particular, <code>par.AEM$moranI = TRUE</code> imposes the use of AEM covariates with significantly positive spatial 
autocorrelation based on Moran's I statistic. </p>
</td></tr>
<tr><td><code id="run_eDITH_optim_joint_+3A_no.det">no.det</code></td>
<td>
<p>Logical. Should a probability of non-detection be included in the model?</p>
</td></tr>
<tr><td><code id="run_eDITH_optim_joint_+3A_ll.type">ll.type</code></td>
<td>
<p>Character. String defining the error distribution used in the log-likelihood formulation. 
Allowed values are <code>norm</code> (for normal distribution), <code>lnorm</code> (for lognormal distribution), 
<code>nbinom</code> (for negative binomial distribution) and <code>geom</code> (for geometric distribution). The two latter choices 
are suited when eDNA data are expressed as read numbers, while <code>norm</code> and <code>lnorm</code> are better suited 
to eDNA concentrations. </p>
</td></tr>
<tr><td><code id="run_eDITH_optim_joint_+3A_source.area">source.area</code></td>
<td>
<p>Defines the extent of the source area of a node. Possible values are <code>"AG"</code> (if the source
area is the reach surface, i.e. length*width), <code>"SC"</code> (if the source area is the subcatchment area), or,
alternatively, a vector with length <code>river$AG$nodes</code>.</p>
</td></tr>
<tr><td><code id="run_eDITH_optim_joint_+3A_likelihood">likelihood</code></td>
<td>
<p>Likelihood function. If not specified, it is generated based on 
arguments <code>no.det</code> and <code>ll.type</code>. </p>
</td></tr>
<tr><td><code id="run_eDITH_optim_joint_+3A_sampler">sampler</code></td>
<td>
<p>Function generating sets of initial parameter values for the optimization algorithm. If <code>NULL</code>, 
initial parameter values are drawn from the default prior distributions of <code><a href="#topic+run_eDITH_BT">run_eDITH_BT</a></code>. See details.</p>
</td></tr>
<tr><td><code id="run_eDITH_optim_joint_+3A_n.attempts">n.attempts</code></td>
<td>
<p>Number of times the optimizing function <code>optim</code> is executed. Every time a &quot;restart&quot; happens 
(see <code>n.restarts</code>), <code>sampler</code> is used to draw an initial parameter set. If a &quot;restart&quot; does not happen, 
the optimal parameter set from the previous attempt is used as initial parameter set.</p>
</td></tr>
<tr><td><code id="run_eDITH_optim_joint_+3A_n.restarts">n.restarts</code></td>
<td>
<p>Number of times a random parameter set is drawn as initial condition for <code>optim</code>.</p>
</td></tr>
<tr><td><code id="run_eDITH_optim_joint_+3A_par.optim">par.optim</code></td>
<td>
<p>List of parameters to be passed to <code><a href="stats.html#topic+optim">optim</a></code>. By default, the likelihood is maximized (i.e., 
<code>control$fnscale = -1</code>), and the maximum number of iterations is set to 1e6. The default optimization method is 
&quot;Nelder-Mead&quot; (same default as in <code>optim</code>).</p>
</td></tr>
<tr><td><code id="run_eDITH_optim_joint_+3A_tau.prior">tau.prior</code>, <code id="run_eDITH_optim_joint_+3A_log_p0.prior">log_p0.prior</code>, <code id="run_eDITH_optim_joint_+3A_beta.prior">beta.prior</code>, <code id="run_eDITH_optim_joint_+3A_sigma.prior">sigma.prior</code>, <code id="run_eDITH_optim_joint_+3A_omega.prior">omega.prior</code>, <code id="run_eDITH_optim_joint_+3A_cstar.prior">Cstar.prior</code></td>
<td>
<p>Prior distribution for the relevant
parameters of the eDITH model.</p>
</td></tr>
<tr><td><code id="run_eDITH_optim_joint_+3A_omega_d.prior">omega_d.prior</code></td>
<td>
<p>Prior distribution for the overdispersion parameter for direct sampling density observations.</p>
</td></tr>
<tr><td><code id="run_eDITH_optim_joint_+3A_alpha.prior">alpha.prior</code></td>
<td>
<p>Prior distribution for the inverse DNA shedding rate (i.e., the organismal density 
that sheds a unit eDNA value per unit time).</p>
</td></tr>
<tr><td><code id="run_eDITH_optim_joint_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Should console output be displayed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function attempts to maximize the log-posterior (sum of log-likelihood and log-prior) via the 
non-linear optimization function <code><a href="stats.html#topic+optim">optim</a></code>.  
</p>
<p>If specified by the user, <code>sampler</code> must be a function that produces as output a &quot;named num&quot; 
vector of parameters. Parameter names must be same as in the <code>likelihood</code>. See example.
</p>
<p>By default, AEMs are computed without attributing weights to the edges  of the river network. 
Use e.g. <code>par.AEM = list(weight = "gravity")</code> to attribute weights. 
</p>


<h3>Value</h3>

<p>A list with objects:
</p>
<table role = "presentation">
<tr><td><code>p</code></td>
<td>
<p>Vector of best-fit eDNA production rates corresponding to the optimum parameter 
estimates <code>param</code>. It has length equal to <code>river$AG$nNodes</code>.</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>Vector of best-fit eDNA values (in the same unit as <code>data$values</code>, i.e. concentrations or read numbers) 
corresponding to the optimum parameter  estimates <code>param</code>. It has length equal to <code>river$AG$nNodes</code>.</p>
</td></tr>
<tr><td><code>probDet</code></td>
<td>
<p>Vector of best-fit detection probabilities corresponding to the optimum
parameter estimate <code>param_map</code>. It has length equal to <code>river$AG$nNodes</code>. If a custom <code>likelihood</code> is provided,
this is a vector of null length (in which case the user should calculate the probability of detection independently, based on
the chosen likelihood).</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>Vector of named parameters corresponding to the best-fit estimate.</p>
</td></tr>
<tr><td><code>covariates</code></td>
<td>
<p>Data frame containing input covariate values (possibly Z-normalized).</p>
</td></tr>
<tr><td><code>source.area</code></td>
<td>
<p>Vector of source area values.</p>
</td></tr>
<tr><td><code>out_optim</code></td>
<td>
<p>List as provided by <code>optim</code>. Only the result of the call to <code>optim</code> (out of <code>n.attempts</code>)
yielding the highest likelihood is exported.</p>
</td></tr> 
<tr><td><code>attempts.stats</code></td>
<td>
<p>List containing relevant output for the different optimization attempts. It contains <code>lp</code> 
(vector of maximized log-posterior values for each single attempt), <code>counts</code> (total function evaluations), <code>conv</code> 
(convergence flags as produced by <code>optim</code>), and <code>tau</code> (best-fit decay time values in h).</p>
</td></tr> 
</table>
<p>Moreover, arguments <code>ll.type</code> (possibly changed to <code>"custom"</code> if a custom likelihood is specified), <code>no.det</code> 
and <code>data</code> are added to the list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wigger)
data(dataCD)

## fit eDNA concentration and direct observation data - use AEMs as covariates
set.seed(9)
out &lt;- run_eDITH_optim_joint(dataCD, wigger, n.AEM = 10, 
	n.attempts = 1) # reduced n.AEM, n.attempts for illustrative purposes
	# it is recommended to attempt optimization several times to ensure convergence 

library(rivnet)
# best-fit map of eDNA production rates
plot(wigger, out$p)

# best-fit map of detection probability
plot(wigger, out$probDet)

# compare best-fit vs observed values
data.e &lt;- which(dataCD$type=="e")
data.d &lt;- which(dataCD$type=="d")

plot(out$C[dataCD$ID[data.e]], dataCD$values[data.e],
	xlab="Modelled (MAP) eDNA concentrations", ylab="Observed eDNA concentrations")
abline(a=0, b=1) 

plot(out$p[dataCD$ID[data.d]], dataCD$values[data.d],
	xlab="Modelled (MAP) eDNA production rate", ylab="Observed density data")


</code></pre>

<hr>
<h2 id='run_eDITH_single'>Run eDITH for a single parameter set</h2><span id='topic+run_eDITH_single'></span>

<h3>Description</h3>

<p>Function that runs the eDITH model for a given parameter set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_eDITH_single(param, river, covariates,  Z.normalize = TRUE, 
				no.det = FALSE, ll.type = NULL, 
				data = NULL, source.area = "AG",
                tau.prior = list(spec="lnorm",a=0,b=Inf, 
					meanlog=log(5), sd=sqrt(log(5)-log(4))),
                log_p0.prior = list(spec="unif",min=-20, max=0),
                    beta.prior = list(spec="norm",sd=1),
                sigma.prior = list(spec="unif",min=0, 
					max=max(data$values, na.rm = TRUE)),
                omega.prior = list(spec="unif",min=1, 
					max=10*max(data$values, na.rm = TRUE)),
                 Cstar.prior = list(spec="unif",min=0, 
					max=max(data$values, na.rm = TRUE)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run_eDITH_single_+3A_param">param</code></td>
<td>
<p>Parameter set. It has to be a named vector, with names:
</p>

<dl>
<dt><code>tau</code></dt><dd><p>Decay time (expressed in h).</p>
</dd>
<dt><code>log_p0</code></dt><dd><p>Natural logarithm of the baseline production rate.</p>
</dd>
<dt><code>beta_X</code></dt><dd><p>Effect size of covariate <code>X</code>. There must be as many <code>beta_X</code> as columns in <code>covariates</code>. 
<code>X</code> must be the name of the corresponding column in <code>covariates</code>.</p>
</dd>
<dt><code>omega</code>, <code>sigma</code>, <code>Cstar</code></dt><dd><p>Parameters for estimation of the log-likelihood and detection probability. 
Only required if <code>ll.type</code> is provided.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="run_eDITH_single_+3A_river">river</code></td>
<td>
<p>A <code>river</code> object generated via <code>aggregate_river</code>.</p>
</td></tr>
<tr><td><code id="run_eDITH_single_+3A_covariates">covariates</code></td>
<td>
<p>Data frame containing covariate values for all <code>river</code> reaches.</p>
</td></tr>
<tr><td><code id="run_eDITH_single_+3A_z.normalize">Z.normalize</code></td>
<td>
<p>Logical. Should covariates be Z-normalized?</p>
</td></tr>
<tr><td><code id="run_eDITH_single_+3A_no.det">no.det</code></td>
<td>
<p>Logical. Should a probability of non-detection be included in the model?</p>
</td></tr>
<tr><td><code id="run_eDITH_single_+3A_ll.type">ll.type</code></td>
<td>
<p>Character. String defining the error distribution used in the log-likelihood formulation. 
Allowed values are <code>norm</code> (for normal distribution), <code>lnorm</code> (for lognormal distribution), 
<code>nbinom</code> (for negative binomial distribution) and <code>geom</code> (for geometric distribution). The two latter choices 
are suited when eDNA data are expressed as read numbers, while <code>norm</code> and <code>lnorm</code> are better suited 
to eDNA concentrations. </p>
</td></tr>
<tr><td><code id="run_eDITH_single_+3A_data">data</code></td>
<td>
<p>eDNA data. Data frame containing columns <code>ID</code> (index of the AG node/reach where 
the eDNA sample was taken) and <code>values</code> (value of the eDNA measurement, expressed as concentration
or number of reads). </p>
</td></tr>
<tr><td><code id="run_eDITH_single_+3A_source.area">source.area</code></td>
<td>
<p>Defines the extent of the source area of a node. Possible values are <code>"AG"</code> (if the source
area is the reach surface, i.e. length*width), <code>"SC"</code> (if the source area is the subcatchment area), or,
alternatively, a vector with length <code>river$AG$nodes</code>.</p>
</td></tr>
<tr><td><code id="run_eDITH_single_+3A_tau.prior">tau.prior</code>, <code id="run_eDITH_single_+3A_log_p0.prior">log_p0.prior</code>, <code id="run_eDITH_single_+3A_beta.prior">beta.prior</code>, <code id="run_eDITH_single_+3A_sigma.prior">sigma.prior</code>, <code id="run_eDITH_single_+3A_omega.prior">omega.prior</code>, <code id="run_eDITH_single_+3A_cstar.prior">Cstar.prior</code></td>
<td>
<p>Prior distribution for the relevant
parameters of the eDITH model. Only used if both <code>ll.type</code> and <code>data</code> are provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with objects:
</p>
<table role = "presentation">
<tr><td><code>p</code></td>
<td>
<p>Vector of eDNA production rates corresponding to the parameter 
set <code>param</code>. It has length equal to <code>river$AG$nNodes</code>.</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>Vector of eDNA values (concentrations or read numbers) corresponding to the parameter set <code>param</code>. 
It has length equal to <code>river$AG$nNodes</code>.</p>
</td></tr>
<tr><td><code>probDet</code></td>
<td>
<p>Vector of detection probabilities corresponding to the parameter set <code>param</code>. It is only computed if 
<code>ll.type</code> is provided.  It has length equal to <code>river$AG$nNodes</code>. </p>
</td></tr>
<tr><td><code>logprior</code></td>
<td>
<p>Value of the log-prior distribution (computed only if <code>ll.type</code> and <code>data</code> are provided).</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>Value of the log-likelihood distribution (computed only if <code>ll.type</code> and <code>data</code> are provided).</p>
</td></tr>
<tr><td><code>logpost</code></td>
<td>
<p>Value of the log-posterior distribution (computed only if <code>ll.type</code> and <code>data</code> are provided).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>See <code><a href="#topic+run_eDITH_BT">run_eDITH_BT</a></code>, <code><a href="#topic+run_eDITH_optim">run_eDITH_optim</a></code> for details on parameters names and log-likelihood specification.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rivnet)
data(wigger)

# calculate AEMs and use the first 10 as covariates
ae &lt;- river_to_AEM(wigger)
covariates &lt;- data.frame(ae$vectors[,1:10])
names(covariates) &lt;- paste0("AEM",1:10) 
# covariates names must correspond to param names
set.seed(1); param &lt;- c(3,-15, runif(10,-1,1))
names(param) &lt;- c("tau", "log_p0", paste0("beta_AEM",1:10))
# param names must correspond to covariates names

out &lt;- run_eDITH_single(param, wigger, covariates)

# add parameter sigma and compute detection probability
param &lt;- c(param, 5e-12) 
names(param)[length(param)] &lt;- "sigma"
# note that the value of sigma has to be within the range indicated by sigma.prior
out2 &lt;- run_eDITH_single(param, wigger, covariates, ll.type="norm")

# include data and compute logprior, loglikelihood, logposterior
data(dataC)
out3 &lt;- run_eDITH_single(param, wigger, covariates, 
		ll.type="norm", data=dataC)

</code></pre>

<hr>
<h2 id='sampling_strategy_direct'>Determine optimal spatial arrangement for direct sampling</h2><span id='topic+sampling_strategy_direct'></span>

<h3>Description</h3>

<p>Function that determines the optimal spatial arrangement for direct sampling sites
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampling_strategy_direct(river, nSites)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sampling_strategy_direct_+3A_river">river</code></td>
<td>
<p>A <code>river</code> object generated via <code>aggregate_river</code>.</p>
</td></tr>
<tr><td><code id="sampling_strategy_direct_+3A_nsites">nSites</code></td>
<td>
<p>Number of sites to be deployed. Cannot be higher than <code>river$AG$nNodes</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the ID of the <code>nSites</code> selected sites according to this strategy. 
Sites are sorted according to their rank (i.e., the first site in the vector is the first one 
that has been selected).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rivnet)
data(wigger)
wigger &lt;- paths_river(wigger) 
sites &lt;- sampling_strategy_direct(wigger, 20)
plot(wigger)
points_colorscale(wigger$AG$X[sites], wigger$AG$Y[sites], 1:20)
title("Rank of selected sites")
  
</code></pre>

<hr>
<h2 id='sampling_strategy_eDNA'>Determine optimal spatial arrangement for eDNA sampling</h2><span id='topic+sampling_strategy_eDNA'></span>

<h3>Description</h3>

<p>Function that determines the optimal spatial arrangement for eDNA sampling sites
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampling_strategy_eDNA(river, nSites)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sampling_strategy_eDNA_+3A_river">river</code></td>
<td>
<p>A <code>river</code> object generated via <code>paths_river</code>.</p>
</td></tr>
<tr><td><code id="sampling_strategy_eDNA_+3A_nsites">nSites</code></td>
<td>
<p>Number of sites to be deployed. Cannot be higher than <code>river$AG$nNodes</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the ID of the <code>nSites</code> selected sites according to this strategy. 
Sites are sorted according to their rank (i.e., the first site in the vector is the first one 
that has been selected).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rivnet)
data(wigger)
wigger &lt;- paths_river(wigger) 
sites &lt;- sampling_strategy_eDNA(wigger, 20)
plot(wigger)
points_colorscale(wigger$AG$X[sites], wigger$AG$Y[sites], 1:20)
title("Rank of selected sites")
  
</code></pre>

<hr>
<h2 id='wigger'>River Wigger</h2><span id='topic+wigger'></span>

<h3>Description</h3>

<p>It is built via 
</p>
<p><code>wigger &lt;- extract_river(outlet=c(637478,237413),
                    EPSG=21781, 
                    ext=c(6.2e5,6.6e5,2e5,2.5e5),
                    z=9)</code>
</p>
<p><code>wigger &lt;- aggregate_river(wigger, maxReachLength = 2500)</code>
</p>
<p><code>hydrodata &lt;- data.frame(data=c(8, 15), type=c("w","Q"), node=wigger$AG$outlet*c(1,1))</code>
</p>
<p><code>wigger &lt;- hydro_river(hydrodata, wigger)</code>
</p>
<p><code>r1 &lt;- rast(system.file("extdata/landcover.tif", package="rivnet"))</code>
</p>
<p><code>wigger &lt;- covariate_river(r1, wigger)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wigger)
</code></pre>


<h3>Format</h3>

<p>A <code>river</code> object. See <code>extract_river</code> documentation for details.</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
