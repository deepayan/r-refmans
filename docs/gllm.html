<!DOCTYPE html><html lang="en"><head><title>Help for package gllm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gllm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#anova.gllm'><p>Summarize multiple results from gllm</p></a></li>
<li><a href='#boot.gllm'><p> Bootstrap for generalized log-linear modelling</p></a></li>
<li><a href='#boot.table'><p>Produce one bootstrap replicate of a vector of counts</p></a></li>
<li><a href='#emgllm'><p> Generalized log-linear modelling by EM and iterative proportional</p>
fitting</a></li>
<li><a href='#emgllmfitter'><p> Generalized log-linear modelling by EM and iterative proportional</p>
fitting</a></li>
<li><a href='#gllm'><p> Generalized log-linear modelling</p></a></li>
<li><a href='#hildesheim'><p>Invasive Cervical Cancer v exposure to Herpes Simplex Virus</p></a></li>
<li><a href='#ld2'><p>Estimate linkage disequilibrium between two codominant autosomal loci</p></a></li>
<li><a href='#ld2.model'><p>Write design and filter matrices for log-linear model of</p>
linkage disequilibrium between two codominant autosomal loci</a></li>
<li><a href='#lsat'>
<p>Five dichotomous items from the Law School Admission Test (LSAT)</p></a></li>
<li><a href='#scatter'><p>Create a filter matrix from a summary array of indices</p></a></li>
<li><a href='#scoregllm'><p> Generalized log-linear modelling via Fisher scoring</p></a></li>
<li><a href='#summary.gllm'><p>Summarize results of gllm</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.38</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-10-18</td>
</tr>
<tr>
<td>Title:</td>
<td>Generalised log-Linear Model</td>
</tr>
<tr>
<td>Author:</td>
<td>David Duffy &lt;David.Duffy@qimr.edu.au&gt;.  
        C code in emgllmfitter by Andreas Borg &lt;borg@imbei.uni-mainz.de&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Duffy &lt;David.Duffy@qimrberghofer.edu.au&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 0.99)</td>
</tr>
<tr>
<td>Description:</td>
<td>Routines for log-linear models of incomplete contingency tables,
             including some latent class models, via EM and Fisher scoring
             approaches. Allows bootstrapping. See Espeland and Hui (1987)
             &lt;<a href="https://doi.org/10.2307%2F2531553">doi:10.2307/2531553</a>&gt; for general approach.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://genepi.qimr.edu.au/Staff/davidD/#loglin">https://genepi.qimr.edu.au/Staff/davidD/#loglin</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-18 06:05:20 UTC; davidD</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-18 08:02:44 UTC</td>
</tr>
</table>
<hr>
<h2 id='anova.gllm'>Summarize multiple results from gllm</h2><span id='topic+anova.gllm'></span>

<h3>Description</h3>

<p>Compare likelihood ratio test statistics from multiple calls to <code>gllm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gllm'
anova(object, ..., test=c("Chisq","none")) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="anova.gllm_+3A_object">object</code></td>
<td>
<p>is an object output from gllm.</p>
</td></tr>
<tr><td><code id="anova.gllm_+3A_...">...</code></td>
<td>
<p>other objects from gllm.</p>
</td></tr>
<tr><td><code id="anova.gllm_+3A_test">test</code></td>
<td>
<p>evaluate LRTS for model, or nothing.</p>
</td></tr>
</table>


<h3>Value</h3>

 
<p>A list with components:
</p>
<table role = "presentation">
<tr><td><code>Model</code></td>
<td>
<p>name of each object being compared</p>
</td></tr>
<tr><td><code>Resid.df</code></td>
<td>
<p>residual degrees of freedom for each model</p>
</td></tr>
<tr><td><code>Deviance</code></td>
<td>
<p>likelihood ratio test statistic for model versus saturated model</p>
</td></tr>
<tr><td><code>Pr.Fit</code></td>
<td>
<p>chi-square based P-value for model</p>
</td></tr>
<tr><td><code>Test</code></td>
<td>
<p>models compared in stepwise testing</p>
</td></tr>
<tr><td><code>Df</code></td>
<td>
<p>degrees of freedom of model comparson</p>
</td></tr>
<tr><td><code>LRtest</code></td>
<td>
<p>likelihood ratio test statistic comparing models</p>
</td></tr>
<tr><td><code>Prob</code></td>
<td>
<p>chi-square based P-value for LRTS</p>
</td></tr></table>
<p>.
</p>


<h3>Author(s)</h3>

<p> David L Duffy </p>

<hr>
<h2 id='boot.gllm'> Bootstrap for generalized log-linear modelling </h2><span id='topic+boot.gllm'></span>

<h3>Description</h3>

<p>Fits log-linear models for incomplete contingency tables,
including some latent class models, via EM and Fisher scoring approaches.
Performs a bootstrap for the sampling distribution of the 
full unobserved table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.gllm(y,s,X,method="hybrid",em.maxit=1,tol=0.00001,strata=NULL,R=200)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="boot.gllm_+3A_y">y</code></td>
<td>
<p>is the observed contingency table.</p>
</td></tr>
<tr><td><code id="boot.gllm_+3A_s">s</code></td>
<td>
<p>is a vector of indices, one for each cell of the full (unobserved) 
contingency table, representing the appropriate cell of <code>y</code></p>
</td></tr>
<tr><td><code id="boot.gllm_+3A_x">X</code></td>
<td>
<p>is the design matrix, or a formula.</p>
</td></tr>
<tr><td><code id="boot.gllm_+3A_method">method</code></td>
<td>
<p>chooses the EM, Fisher scoring or a hybrid (EM then scoring)
method for fitting the model.</p>
</td></tr>
<tr><td><code id="boot.gllm_+3A_em.maxit">em.maxit</code></td>
<td>
<p>is the number of EM iterations.</p>
</td></tr>
<tr><td><code id="boot.gllm_+3A_tol">tol</code></td>
<td>
<p>is the convergence criterion for the LR criterion.</p>
</td></tr>
<tr><td><code id="boot.gllm_+3A_strata">strata</code></td>
<td>
<p>is a vector identifying the sampling strata.</p>
</td></tr>
<tr><td><code id="boot.gllm_+3A_r">R</code></td>
<td>
<p>is the number of bootstrap replicates.</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>The generalized log-linear model allows for modelling of incomplete
contingency tables, that is tables where one or more dimensions have
been collapsed over.  See <code>gllm</code> for details.
</p>
<p>Often, functions of the full unobserved table are the main focus of the
analysis.  For example, in a double sampling design where there is a
gold standard measure for one part of the data set and only an
unreliable measure for another part, the expected value of the gold
standard in the entire dataset is the outcome of interest.  The standard
error of this statistic may be a complex function of the observed counts
and model parameters.
</p>
<p>Bootstrapping is one way to estimate such standard errors from a complex
sampling design.  The bootstrap sampling may be stratified if the design
implies this, e.g. product-multinomial.
</p>


<h3>Value</h3>

 
<p>A matrix <code class="reqn">R+1</code> by <code>ncol(X)</code> containing the initial estimate
of the full (unobserved) contingency table, and the <code class="reqn">R</code> bootstrap
replicates of the full table.
</p>


<h3>References</h3>

<p>Hochberg Y (1977).  On the use of double sampling schemes in analyzing
categorical data with misclassification errors.  <em>J Am Statist
Ass</em> 72:914-921. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
#
# Fit Hochberg 1977 double sampling data
# 2x2 table of imprecise measures and 2x2x2x2 reliability data
#
# 2x2 table of imprecise measures
#
y1 &lt;-c(1196, 13562,
       7151, 58175)
a2&lt;- 2-as.integer(gl(2,1,4))
b2&lt;- 2-as.integer(gl(2,2,4))
set1&lt;-data.frame(y1,a2,b2)
#
# 2x2x2x2 reliability data
#
y2&lt;-c(17, 3,   10, 258,
       3, 4,    4,  25,
      16, 3,   25, 197,
     100, 13, 107, 1014)

a &lt;- 2-as.integer(gl(2,1,16))
a2&lt;- 2-as.integer(gl(2,2,16))
b &lt;- 2-as.integer(gl(2,4,16))
b2&lt;- 2-as.integer(gl(2,8,16))

set2&lt;-data.frame(y2,a,a2,b,b2)
#
# Combined analysis
#
y&lt;-c(y1,y2)
#
# Map observed table onto underlying 2x2x2x2x2 table
#
s &lt;-c(1, 1, 2, 2, 1, 1, 2, 2, 3, 3, 4, 4, 3, 3, 4, 4,
      5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20)
#
# Model combining the tables is A*A2*B*B2 + L (dummy study variable)
#
a &lt;- 2-as.integer(gl(2,1,32))
a2&lt;- 2-as.integer(gl(2,2,32))
b &lt;- 2-as.integer(gl(2,4,32))
b2&lt;- 2-as.integer(gl(2,8,32))
l &lt;- 2-as.integer(gl(2,16,32))

X &lt;- model.matrix( ~ a*a2*b*b2+l)

#
# Table 1 using unreliable measure
#
res1&lt;-glm(y1 ~ a2*b2, family=poisson(),data=set1)
print(summary(res1))
#
# Table 2 using reliable measure
#
res2a&lt;-glm(y2 ~ a*b, family=poisson(),data=set2)
print(summary(res2a))
#
# Table 2 demonstrating complex relationship between gold standard and
# unreliable measure
#
res2b&lt;-glm(y2 ~ a*a2*b*b2, family=poisson(),data=set2)
print(summary(res2b))
#
# Combined analysis
#
require(gllm)
res12&lt;-gllm(y,s,X)
print(summary.gllm(res12))
#
# Bootstrap the collapsed table to get estimated OR for reliable measures
#
# a and b are binary vectors the length of the *full* table
# and define the variables for which the odds ratio is to be
# estimated, here the reliable measure of injury and seatbelt usage.
#
boot.hochberg &lt;- function (y,s,X,nrep,a,b) {
  z&lt;-boot.gllm(y,s,X,R=nrep)
  boot.tab&lt;-cbind(apply(z[,a &amp; b],1,sum),
                  apply(z[,!a &amp; b],1,sum),
                  apply(z[,a &amp; !b],1,sum),
                  apply(z[,!a &amp; !b],1,sum))
  oddsr&lt;-boot.tab[,1]*boot.tab[,4]/boot.tab[,2]/boot.tab[,3] 
  hochberg.tab&lt;-data.frame( c("yes","yes","no","no"),
                            c("yes","no","yes","no"),
                            boot.tab[1,],
                            apply(boot.tab[2:(1+nrep),],2,sd))
  colnames(hochberg.tab)&lt;-c("Precise Injury","Precise seatbelt usage",
                            "Estimated Count","Bootstrap S.E.")
  print(hochberg.tab)
  cat("\nEstimated OR=",oddsr[1],"\n")
  cat("        Bias=",oddsr[1]-mean(oddsr[2:(1+nrep)]),"\n")
  cat("Bootstrap SE=",sd(oddsr[2:(1+nrep)]),"\n\nQuantiles\n\n")
  quantile(oddsr[2:(1+nrep)],c(0.025,0.50,0.975))
}
boot.hochberg(y,s,X,nrep=20,a,b)
</code></pre>

<hr>
<h2 id='boot.table'>Produce one bootstrap replicate of a vector of counts</h2><span id='topic+boot.table'></span>

<h3>Description</h3>

<p>Given a vector of counts from a contingency table, produce a bootstrap 
replicate.  Sampling zeroes are replaced by 0.5.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.table(y,strata=NULL) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="boot.table_+3A_y">y</code></td>
<td>
<p>is the observed contingency table.</p>
</td></tr>
<tr><td><code id="boot.table_+3A_strata">strata</code></td>
<td>
<p>is a vector defining the strata for a stratified bootstrap.</p>
</td></tr>
</table>


<h3>Value</h3>

 
<p>A vector of counts with the same total.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>boot.table(c(1,3,4,2))
## 0.5 2.0 5.0 3.0
boot.table(c(1,3,4,2),c(1,2,1,2))
## 2 1 3 4
</code></pre>

<hr>
<h2 id='emgllm'> Generalized log-linear modelling by EM and iterative proportional
fitting</h2><span id='topic+emgllm'></span>

<h3>Description</h3>

<p>Fits log-linear models for incomplete contingency tables,
including some latent class models, via an EM approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emgllm(y,s,X,maxit=1000,tol=0.00001) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="emgllm_+3A_y">y</code></td>
<td>
<p>is the observed contingency table.</p>
</td></tr>
<tr><td><code id="emgllm_+3A_s">s</code></td>
<td>
<p>is a vector of indices, one for each cell of the full (unobserved) 
contingency table, representing the appropriate cell of <code>y</code></p>
</td></tr>
<tr><td><code id="emgllm_+3A_x">X</code></td>
<td>
<p>is the design matrix, or a formula.</p>
</td></tr>
<tr><td><code id="emgllm_+3A_maxit">maxit</code></td>
<td>
<p>is the number of EM iterations.</p>
</td></tr>
<tr><td><code id="emgllm_+3A_tol">tol</code></td>
<td>
<p>is the convergence criterion for the LR criterion.</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>The generalized log-linear model allows for modelling of incomplete
contingency tables, that is tables where one or more dimensions have
been collapsed over.  These include situations where imprecise
measures have been calibrated using a &quot;perfect&quot; gold standard, and the
true association between imperfectly measured variables is to be
estimated; where data is missing for a subsample of the population;
latent variable models where latent variables are &quot;errorless&quot; functions
of observed variables - eg ML gene frequency estimation from counts of
observed phenotypes; specialised measurement models eg where observed
counts are mixtures due to perfect measures and error prone measures;
standard latent class analysis; symmetry and quasi-symmetry models for
square tables.
</p>
<p>The general framework underlying these models is summarised by Espeland
(1986), and Espeland &amp; Hui (1987), and is originally due to Thompson &amp;
Baker (1981).  An observed contingency table <code class="reqn">y</code>, which will be
treated as a vector, is modelled as arising from an underlying complete
table <code class="reqn">z</code>, where observed count <code class="reqn">y_j</code> is the sum of a number of
elements of <code class="reqn">z</code>, such that each <code class="reqn">z_i</code> contributes to no more
than one <code class="reqn">y_j</code>. Therefore one can write <code class="reqn">y=F'z</code>, where <code class="reqn">F</code>
is made up of orthogonal columns of ones and zeros.
</p>
<p>We then specify a loglinear model for <code class="reqn">z</code>, so that
<code class="reqn">log(E(z))=X'b</code>, where <code class="reqn">X</code> is a design matrix, and <code class="reqn">b</code> a
vector of loglinear parameters.  The loglinear model for <code class="reqn">z</code> and
thus <code class="reqn">y</code>, can be fitted via an iterative proportional fitting algorithm
for <code class="reqn">b</code> and <code class="reqn">z</code>, with an EM fitting for <code class="reqn">y</code>, <code class="reqn">z</code> and
<code class="reqn">b</code> (Haber 1984).  
</p>
<p>The <code>emgllm</code> function is a wrapper for C code implementing the
approach in Haber (1984).
</p>


<h3>Value</h3>

 
<p>A list with components:
</p>
<table role = "presentation">
<tr><td><code>deviance</code></td>
<td>
<p>the final model deviance (-2 log likelihood)</p>
</td></tr>
<tr><td><code>observed.values</code></td>
<td>
<p>the observed counts in <code>y</code></p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the expected counts under the fitted model</p>
</td></tr>
<tr><td><code>full.table</code></td>
<td>
<p>the expected counts for the full (unobserved) table.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Espeland MA (1986).  A general class of models for discrete multivariate
data. <em>Commun. Statist.-Simula</em> 15:405-424.
</p>
<p>Espeland MA, Hui SL (1987).  A general approach to analyzing epidemiologic
data that contains misclassification errors.  <em>Biometrics</em>
43:1001-1012.
</p>
<p>Haber M (1984).  AS207: Fitting a general log-linear model.  <em>Appl
Statist</em> 33:358-362.
</p>
<p>Thompson R, Baker RJ (1981).  Composite link functions in generalized
linear models.  <em>Appl Stat</em> 30: 125-131.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
#
# latent class analysis: two latent classes
#
# Data matrix 2x2x2x2x2 table of responses to five binary items
#
y&lt;-c( 3,   6,   2,   11,   1,   1,   3,    4,
      1,   8,   0,   16,   0,   3,   2,   15,
     10,  29,  14,   81,   3,  28,  15,   80,
     16,  56,  21,  173,  11,  61,  28,  298)
#
# Scatter matrix: full table is 2x2x2x2x2x2
#
s&lt;-  c(1:32,1:32)
#
# Design matrix: x is the latent variable (2 levels), 
# a-e are the observed variables
#
i&lt;-rep(1,64)
x&lt;-as.integer(gl(2,32,64))-1
a&lt;-as.integer(gl(2,16,64))-1
b&lt;-as.integer(gl(2,8 ,64))-1
c&lt;-as.integer(gl(2,4 ,64))-1
d&lt;-as.integer(gl(2,2 ,64))-1
e&lt;-as.integer(gl(2,1 ,64))-1
X&lt;-cbind(i,x,a,b,c,d,e,x*cbind(a,b,c,d,e))
colnames(X)&lt;-c("Int","X","A","B","C","D","E","AX","BX","CX","DX","EX")
res&lt;-emgllm(y,s,X, tol=0.01)
res
#
# Obtain standard errors for parameter estimates
#
summary(scoregllm(y,s,X,as.array(res$full.table)))
</code></pre>

<hr>
<h2 id='emgllmfitter'> Generalized log-linear modelling by EM and iterative proportional
fitting</h2><span id='topic+emgllmfitter'></span>

<h3>Description</h3>

<p>Fits log-linear models for incomplete contingency tables,
via an EM approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emgllmfitter(y,s,X,maxit,tol) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="emgllmfitter_+3A_y">y</code></td>
<td>
<p>is the observed contingency table.</p>
</td></tr>
<tr><td><code id="emgllmfitter_+3A_s">s</code></td>
<td>
<p>is a vector of indices, one for each cell of the full (unobserved) 
contingency table, representing the appropriate cell of <code>y</code></p>
</td></tr>
<tr><td><code id="emgllmfitter_+3A_x">X</code></td>
<td>
<p>is the design matrix.</p>
</td></tr>
<tr><td><code id="emgllmfitter_+3A_maxit">maxit</code></td>
<td>
<p>is the number of EM iterations.</p>
</td></tr>
<tr><td><code id="emgllmfitter_+3A_tol">tol</code></td>
<td>
<p>is the convergence criterion for the LR criterion.</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>The call to Andreas Borg's C code that fits the model by EM/IPF.  The
algorithm follows the approach in Haber (1984).
</p>


<h3>Value</h3>

 
<p>A list with components:
</p>
<table role = "presentation">
<tr><td><code>y</code></td>
<td>
<p>the observed table</p>
</td></tr>
<tr><td><code>ji</code></td>
<td>
<p>s, the scatter vector</p>
</td></tr>
<tr><td><code>c</code></td>
<td>
<p>the design matrix</p>
</td></tr>
<tr><td><code>istop</code></td>
<td>
<p>maximum EM iterations</p>
</td></tr>
<tr><td><code>conv</code></td>
<td>
<p>the convergence tolerance</p>
</td></tr>
<tr><td><code>e</code></td>
<td>
<p>expected counts for the full (unobserved) table</p>
</td></tr>
<tr><td><code>ni</code></td>
<td>
<p>nrow(X)</p>
</td></tr>
<tr><td><code>nj</code></td>
<td>
<p>length(y)</p>
</td></tr>
<tr><td><code>nk</code></td>
<td>
<p>ncol(X)-1</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>expected counts</p>
</td></tr>
</table>


<h3>References</h3>

<p>Haber M (1984).  AS207: Fitting a general log-linear model.  <em>Appl
Statist</em> 33:358-362.
</p>

<hr>
<h2 id='gllm'> Generalized log-linear modelling </h2><span id='topic+gllm'></span>

<h3>Description</h3>

<p>Fits log-linear models for incomplete contingency tables,
including some latent class models, via EM and Fisher scoring approaches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gllm(y,s,X,method="hybrid",em.maxit=1,tol=0.00001)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gllm_+3A_y">y</code></td>
<td>
<p>is the observed contingency table.</p>
</td></tr>
<tr><td><code id="gllm_+3A_s">s</code></td>
<td>
<p>is a vector of indices, one for each cell of the full (unobserved) 
contingency table, representing the appropriate cell of <code>y</code></p>
</td></tr>
<tr><td><code id="gllm_+3A_x">X</code></td>
<td>
<p>is the design matrix, or a formula.</p>
</td></tr>
<tr><td><code id="gllm_+3A_method">method</code></td>
<td>
<p>chooses the EM, Fisher scoring or a hybrid (EM then scoring)
method for fitting the model.</p>
</td></tr>
<tr><td><code id="gllm_+3A_em.maxit">em.maxit</code></td>
<td>
<p>is the number of EM iterations.</p>
</td></tr>
<tr><td><code id="gllm_+3A_tol">tol</code></td>
<td>
<p>is the convergence criterion for the LR criterion.</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>The generalized log-linear model allows for modelling of incomplete
contingency tables, that is tables where one or more dimensions have
been collapsed over.  These include situations where imprecise
measures have been calibrated using a &quot;perfect&quot; gold standard, and the
true association between imperfectly measured variables is to be
estimated; where data is missing for a subsample of the population;
latent variable models where latent variables are &quot;errorless&quot; functions
of observed variables - eg ML gene frequency estimation from counts of
observed phenotypes; specialised measurement models eg where observed
counts are mixtures due to perfect measures and error prone measures;
standard latent class analysis; symmetry and quasi-symmetry models for
square tables.
</p>
<p>The general framework underlying these models is summarised by Espeland
(1986), and Espeland &amp; Hui (1987), and is originally due to Thompson &amp;
Baker (1981).  An observed contingency table <code class="reqn">y</code>, which will be
treated as a vector, is modelled as arising from an underlying complete
table <code class="reqn">z</code>, where observed count <code class="reqn">y_j</code> is the sum of a number of
elements of <code class="reqn">z</code>, such that each <code class="reqn">z_i</code> contributes to no more
than one <code class="reqn">y_j</code>. Therefore one can write <code class="reqn">y=F'z</code>, where <code class="reqn">F</code>
is made up of orthogonal columns of ones and zeros.
</p>
<p>We then specify a loglinear model for <code class="reqn">z</code>, so that
<code class="reqn">log(E(z))=X'b</code>, where <code class="reqn">X</code> is a design matrix, and <code class="reqn">b</code> a
vector of loglinear parameters.  The loglinear model for <code class="reqn">z</code> and
thus <code class="reqn">y</code>, can be fitted using two methods, both of which are
available in <code>gllm</code>.  The first was presented as AS207 by Michael
Haber (1984) and combines an iterative proportional fitting algorithm
for <code class="reqn">b</code> and <code class="reqn">z</code>, with an EM fitting for <code class="reqn">y</code>, <code class="reqn">z</code> and
<code class="reqn">b</code>.  The second is a Fisher scoring approach, presented in Espeland
(1986).
</p>
<p>The <code>gllm</code> function is actually a simple wrapper for <code>scoregllm()</code>.
</p>


<h3>Value</h3>

 
<p>A list with components:
</p>
<table role = "presentation">
<tr><td><code>iter</code></td>
<td>
<p>the number of scoring iterations until convergence</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>the final model deviance (-2 log likelihood)</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>the model degrees of freedom</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>the model parameter estimates</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>the standard errors for the model parameter estimates</p>
</td></tr>
<tr><td><code>V</code></td>
<td>
<p>the variance-covariance matrix for the model parameter estimates</p>
</td></tr>
<tr><td><code>observed.values</code></td>
<td>
<p>the observed counts in <code>y</code></p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the expected counts under the fitted model</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>Pearsonian residuals under the fitted model</p>
</td></tr>
<tr><td><code>full.table</code></td>
<td>
<p>the expected counts for the full (unobserved) table.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Espeland MA (1986).  A general class of models for discrete multivariate
data. <em>Commun. Statist.-Simula</em> 15:405-424.
</p>
<p>Espeland MA, Hui SL (1987).  A general approach to analyzing epidemiologic
data that contains misclassification errors.  <em>Biometrics</em>
43:1001-1012.
</p>
<p>Haber M (1984).  AS207: Fitting a general log-linear model.  <em>Appl
Statist</em> 33:358-362.
</p>
<p>Thompson R, Baker RJ (1981).  Composite link functions in generalized
linear models.  <em>Appl Statist</em> 30: 125-131.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
#
# latent class analysis: two latent classes
#
# Data matrix 2x2x2x2x2 table of responses to five binary items
# (items 11-15 of sections 6-7 of the Law School Admission Test)
#
y&lt;-c( 3,   6,   2,   11,   1,   1,   3,    4,
      1,   8,   0,   16,   0,   3,   2,   15,
     10,  29,  14,   81,   3,  28,  15,   80,
     16,  56,  21,  173,  11,  61,  28,  298)
#
# Scatter matrix: full table is 2x2x2x2x2x2
#
s&lt;-  c(1:32,1:32)
#
# Design matrix: x is the latent variable (2 levels), 
# a-e are the observed variables
#
x&lt;-as.integer(gl(2,32,64))-1
a&lt;-as.integer(gl(2,16,64))-1
b&lt;-as.integer(gl(2,8 ,64))-1
c&lt;-as.integer(gl(2,4 ,64))-1
d&lt;-as.integer(gl(2,2 ,64))-1
e&lt;-as.integer(gl(2,1 ,64))-1

res1&lt;-gllm(y,s,~x*(a+b+c+d+e),method="em",tol=0.01)
res1
#
# An example of model fitting: gametic association between two diallelic loci
#
# Data matrix
#
y&lt;-c( 187,386,156,
      352,310,20,
      136,0  ,0)
#
# Scatter matrix
#
s&lt;-  c( 1, 2, 2, 3,
        4, 5, 5, 6,
        4, 5, 5, 6,
        7, 8, 8, 9)
#
# Design matrix
#
X&lt;-  matrix(c( 1,0,0,0,0,0,1,
               1,0,1,0,0,0,0,
               1,0,1,0,0,0,0,
               1,0,2,0,1,0,0,
               1,1,0,0,0,0,0,
               1,1,1,0,0,1,0,
               1,1,1,0,0,0,1,
               1,1,2,0,1,1,1,
               1,1,0,0,0,0,0,
               1,1,1,0,0,0,1,
               1,1,1,0,0,1,0,
               1,1,2,0,1,1,1,
               1,2,0,1,0,0,0,
               1,2,1,1,0,1,1,
               1,2,1,1,0,1,1,
               1,2,2,1,1,2,2), byrow=TRUE, ncol=7) 

colnames(X)&lt;-c("Intercept", "A", "B", "P1", "P2", "Delta", "Epsilon")
res2&lt;-gllm(y,s,X[,c(1:6)],method="hybrid",em.maxit=1,tol=0.00001)
res2
#

</code></pre>

<hr>
<h2 id='hildesheim'>Invasive Cervical Cancer v exposure to Herpes Simplex Virus
</h2><span id='topic+hildesheim'></span>

<h3>Description</h3>

<p>The case-control study of Hildesheim et al (1991)
has been reanalysed by several authors (Carroll et al 1993;
Spiegelhalter et al 1999; Prescott et al 2002).  Exposure to Herpes
Simplex Virus in cases suffering from invasive cervical cancer and in
unaffected controls was assessed by Western Blot in all cases and
controls and by a gold-standard refined Western blotting in a subset of 115
subjects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(hildesheim)</code></pre>


<h3>Format</h3>

<p>A data frame table.</p>


<h3>Source</h3>

<p>Hildesheim et al (1991)  Herpes simplex virus type 2: A possible interaction
with human papillomavirus types 16/18 in the development of invasive cervical
cancer.  <em>Int J Cancer</em>  <b>49</b>, 335-340.
</p>


<h3>References</h3>

<p>Carroll NJ, Gail MH, Lubin JH (1993)  Case-control studies with errors in
covariates. <em>J Am Statist Assoc</em> <b>88</b>, 185-199.
</p>
<p>Prescott GJ, Garthwaite PH (2002)  A simple bayesian analysis of misclassified
binary data with a validation substudy.  <em>Biometrics</em> <b>58</b>, 454-458.
</p>
<p>Spiegelhalter DJ, Thomas A, Best NG (1999)  Win-Bugs, Version 1.2.  Technical
Report.  Cambridge: UK.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hildesheim)
ftable(xtabs(Freq ~ case+HSV.inac+HSV.gold, hildesheim))
fisher.test(xtabs(Freq ~ case+HSV.inac, hildesheim))
fisher.test(xtabs(Freq ~ case+HSV.gold, hildesheim, subset=HSV.gold!="?"))

#
# Combined analysis (ordered as incomplete then complete data)
#
y&lt;-hildesheim$Freq[c(3,9,6,12,1,2,7,8,4,5,10,11)]
#
# Map observed table onto underlying 2x2x2x2 table
#
s &lt;-c(1, 1, 2, 2, 3, 3, 4, 4,
      5, 6, 7, 8, 9, 10, 11, 12)
#
substudy  &lt;- 2-as.integer(gl(2,8,16))
hsv.inac  &lt;- 2-as.integer(gl(2,4,16))
hsv.gold  &lt;- 2-as.integer(gl(2,2,16))
cancer    &lt;- 2-as.integer(gl(2,1,16))

require(gllm)
res&lt;-gllm(y,s, ~substudy+hsv.inac*hsv.gold*cancer)
print(summary.gllm(res))
#
# Bootstrap the collapsed table to get estimated OR for reliable measures
#
# a and b are binary vectors the length of the *full* table
# and define the variables for which the odds ratio is to be
# estimated, here the reliable measure of HSV exposure and Ca Cx
#
boot.hildesheim &lt;- function (y,s,X,nrep,a,b) {
  z&lt;-boot.gllm(y,s,X,R=nrep)
  boot.tab&lt;-cbind(apply(z[,a &amp; b],1,sum),
                  apply(z[,!a &amp; b],1,sum),
                  apply(z[,a &amp; !b],1,sum),
                  apply(z[,!a &amp; !b],1,sum))
  oddsr&lt;-boot.tab[,1]*boot.tab[,4]/boot.tab[,2]/boot.tab[,3] 
  hildesheim.tab&lt;-data.frame( c("yes","yes","no","no"),
                              c("yes","no","yes","no"),
                              boot.tab[1,],
                              apply(boot.tab[2:(1+nrep),],2,sd))
  colnames(hildesheim.tab)&lt;-c("Precise HSV","Cervical Cancer",
                            "Estimated Count","Bootstrap S.E.")
  print(hildesheim.tab)
  cat("\nEstimated OR=",oddsr[1],"\n")
  cat("        Bias=",oddsr[1]-mean(oddsr[2:(1+nrep)]),"\n")
  cat("Bootstrap SE=",sd(oddsr[2:(1+nrep)]),"\n\nQuantiles\n\n")
  print(quantile(oddsr[2:(1+nrep)],c(0.025,0.50,0.975)))

  b&lt;-mean(log(oddsr[2:(1+nrep)]))
  se&lt;-sd(log(oddsr[2:(1+nrep)]))
  ztest&lt;-b/se
  cat("\n      Estimated log(OR)=",log(oddsr[1]),"\n",
      "Bootstrap mean log(OR)=",b,"\n",
      "          Bootstrap SE=",se,"\n",
      "                Wald Z=",ztest," (P=",2*pnorm(ztest,lower=FALSE),")\n")
}
boot.hildesheim(y,s,~substudy+hsv.inac*hsv.gold*cancer,nrep=50,cancer,hsv.gold)

</code></pre>

<hr>
<h2 id='ld2'>Estimate linkage disequilibrium between two codominant autosomal loci</h2><span id='topic+ld2'></span><span id='topic+print.ld2'></span>

<h3>Description</h3>

<p>Fits a log-linear model for allelic association between two codominant
autosomal loci.  Measures of LD are odds ratios.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ld2(locus1, locus2) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ld2_+3A_locus1">locus1</code></td>
<td>
<p>is a character vector containing the genotypes at the first
locus, or a RxC contingency table of genotype counts.</p>
</td></tr>
<tr><td><code id="ld2_+3A_locus2">locus2</code></td>
<td>
<p>is a character vector containing the genotypes at the second
locus.</p>
</td></tr>
</table>


<h3>Value</h3>

 
<table role = "presentation">
<tr><td><code>m0</code></td>
<td>
<p>base model</p>
</td></tr>
<tr><td><code>m1</code></td>
<td>
<p>estimating LD coefficient(s) assuming HWE</p>
</td></tr>
<tr><td><code>m2</code></td>
<td>
<p>testing HWE at locus 1</p>
</td></tr>
<tr><td><code>m3</code></td>
<td>
<p>testing HWE at locus 2</p>
</td></tr>
<tr><td><code>m4</code></td>
<td>
<p>estimating LD and HWD coefficient(s)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>MNS&lt;-matrix(c(91,32,5,147,78,17,85,75,7), nr=3)
colnames(MNS)&lt;-c("S/S","S/s","s/s")
rownames(MNS)&lt;-c("M/M","M/N","N/N")
class(MNS)&lt;-"table"
print(MNS)
res&lt;-ld2(MNS)
print(res)
</code></pre>

<hr>
<h2 id='ld2.model'>Write design and filter matrices for log-linear model of
linkage disequilibrium between two codominant autosomal loci</h2><span id='topic+ld2.model'></span>

<h3>Description</h3>

<p>Write design and filter matrices for log-linear model of
linkage disequilibrium between two codominant autosomal loci.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ld2.model(nall1, nall2, formula="~a1+a2+p1+p2+d") 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ld2.model_+3A_nall1">nall1</code></td>
<td>
<p>is number of alleles at first codominant locus.</p>
</td></tr>
<tr><td><code id="ld2.model_+3A_nall2">nall2</code></td>
<td>
<p>is number of alleles at first codominant locus.</p>
</td></tr>
<tr><td><code id="ld2.model_+3A_formula">formula</code></td>
<td>
<p>is character string listing terms to be 
included in model, where a1 denotes allele frequencies for locus 1,
p1 the deviation from Hardy-Weinberg expectations for locus1,
and d the intragametic allelic association parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

 
<p>A list with components:
</p>
<table role = "presentation">
<tr><td><code>Geno</code></td>
<td>
<p>is a dummy contingency table showing the expected order.</p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>is a vector of indices, one for each cell of the full (unobserved) 
contingency table, representing the appropriate cell of <code>y</code></p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>is the design matrix.</p>
</td></tr>
</table>

<hr>
<h2 id='lsat'>
Five dichotomous items from the Law School Admission Test (LSAT)
</h2><span id='topic+lsat'></span>

<h3>Description</h3>

<p>Small dataset (items 11-15 from sections 6 and 7 of the Law School Admission
Test) used by Bock and Lieberman (1970), Christoffersson (1975)
and Joreskog and Sorbom (1986) to test methods for factor analysis
of binary data.
</p>


<h3>Source</h3>

<p>Bock RD, Lieberman M (1970).  Fitting a response model for n dichotomously
scored items.
<em>Psychometrika</em>
<b>35</b>, 179-197.
</p>

<hr>
<h2 id='scatter'>Create a filter matrix from a summary array of indices</h2><span id='topic+scatter'></span>

<h3>Description</h3>

<p>Create a filter matrix that multiplying the vector of counts from a 
complete contingency table, gives a collapsed contingency table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scatter(y,s) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scatter_+3A_y">y</code></td>
<td>
<p>is the observed contingency table. Provides a target length only.</p>
</td></tr>
<tr><td><code id="scatter_+3A_s">s</code></td>
<td>
<p>is a vector of indices, one for each cell of the full (unobserved) 
contingency table, representing the appropriate cell of <code>y</code></p>
</td></tr>
</table>


<h3>Value</h3>

 
<table role = "presentation">
<tr><td><code>S</code></td>
<td>
<p>A matrix of orthogonal columns of 1s and 0s</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> David L Duffy </p>


<h3>Examples</h3>

<pre><code class='language-R'>y&lt;-double(3)
z&lt;-1:5
z %*% scatter(y,c(1,1,2,3,3))
## 1+2, 3, 4+5
</code></pre>

<hr>
<h2 id='scoregllm'> Generalized log-linear modelling via Fisher scoring </h2><span id='topic+scoregllm'></span>

<h3>Description</h3>

<p>Fits log-linear models for incomplete contingency tables,
including some latent class models, via Fisher scoring approaches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scoregllm(y,s,X,m,tol=1e-5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scoregllm_+3A_y">y</code></td>
<td>
<p>is the observed contingency table.</p>
</td></tr>
<tr><td><code id="scoregllm_+3A_s">s</code></td>
<td>
<p>is a vector of indices, one for each cell of the full (unobserved) 
contingency table, representing the appropriate cell of <code>y</code></p>
</td></tr>
<tr><td><code id="scoregllm_+3A_x">X</code></td>
<td>
<p>is the design matrix or a formula.</p>
</td></tr>
<tr><td><code id="scoregllm_+3A_m">m</code></td>
<td>
<p>is a vector of starting values for the full (unobserved)
contingency table.</p>
</td></tr>
<tr><td><code id="scoregllm_+3A_tol">tol</code></td>
<td>
<p>is the convergence criterion for the LR criterion.</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>The generalized log-linear model allows for modelling of incomplete
contingency tables, that is tables where one or more dimensions have
been collapsed over.  These include situations where imprecise
measures have been calibrated using a &quot;perfect&quot; gold standard, and the
true association between imperfectly measured variables is to be
estimated; where data is missing for a subsample of the population;
latent variable models where latent variables are &quot;errorless&quot; functions
of observed variables - eg ML gene frequency estimation from counts of
observed phenotypes; specialised measurement models eg where observed
counts are mixtures due to perfect measures and error prone measures;
standard latent class analysis; symmetry and quasi-symmetry models for
square tables.
</p>
<p>The general framework underlying these models is summarised by Espeland
(1986), and Espeland &amp; Hui (1987), and is originally due to Thompson &amp;
Baker (1981).  An observed contingency table <code class="reqn">y</code>, which will be
treated as a vector, is modelled as arising from an underlying complete
table <code class="reqn">z</code>, where observed count <code class="reqn">y_j</code> is the sum of a number of
elements of <code class="reqn">z</code>, such that each <code class="reqn">z_i</code> contributes to no more
than one <code class="reqn">y_j</code>. Therefore one can write <code class="reqn">y=F'z</code>, where <code class="reqn">F</code>
is made up of orthogonal columns of ones and zeros.
</p>
<p>We then specify a loglinear model for <code class="reqn">z</code>, so that
<code class="reqn">log(E(z))=X'b</code>, where <code class="reqn">X</code> is a design matrix, and <code class="reqn">b</code> a
vector of loglinear parameters.  The loglinear model for <code class="reqn">z</code> and
thus <code class="reqn">y</code>, can be fitted by a Fisher scoring approach, presented in
Espeland (1986).
</p>
<p>The <code>gllm</code> function is actually a simple wrapper for <code>scoregllm()</code>.
</p>


<h3>Value</h3>

 
<p>A list with components:
</p>
<table role = "presentation">
<tr><td><code>iter</code></td>
<td>
<p>the number of scoring iterations until convergence</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>the final model deviance (-2 log likelihood)</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>the model degrees of freedom</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>the model parameter estimates</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>the standard errors for the model parameter estimates</p>
</td></tr>
<tr><td><code>V</code></td>
<td>
<p>the variance-covariance matrix for the model parameter estimates</p>
</td></tr>
<tr><td><code>observed.values</code></td>
<td>
<p>the observed counts in <code>y</code></p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the expected counts under the fitted model</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>Pearsonian residuals under the fitted model</p>
</td></tr>
<tr><td><code>full.table</code></td>
<td>
<p>the expected counts for the full (unobserved) table.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Espeland MA (1986).  A general class of models for discrete multivariate
data. <em>Commun. Statist.-Simula</em> 15:405-424.
</p>
<p>Espeland MA, Hui SL (1987).  A general approach to analyzing epidemiologic
data that contains misclassification errors.  <em>Biometrics</em>
43:1001-1012.
</p>
<p>Thompson R, Baker RJ (1981).  Composite link functions in generalized
linear models.  <em>Appl Statist</em> 30: 125-131.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
#
# An example of model fitting: gametic association between two diallelic loci
# Data matrix
#
y&lt;-c( 187,386,156,
      352,310,20,
      136,0  ,0)
#
# Scatter matrix
#
s&lt;-  c( 1, 2, 2, 3,
        4, 5, 5, 6,
        4, 5, 5, 6,
        7, 8, 8, 9)
#
# Design matrix
#
X&lt;-  matrix(c( 1,0,0,0,0,0,1,
               1,0,1,0,0,0,0,
               1,0,1,0,0,0,0,
               1,0,2,0,1,0,0,
               1,1,0,0,0,0,0,
               1,1,1,0,0,1,0,
               1,1,1,0,0,0,1,
               1,1,2,0,1,1,1,
               1,1,0,0,0,0,0,
               1,1,1,0,0,0,1,
               1,1,1,0,0,1,0,
               1,1,2,0,1,1,1,
               1,2,0,1,0,0,0,
               1,2,1,1,0,1,1,
               1,2,1,1,0,1,1,
               1,2,2,1,1,2,2), byrow=TRUE, ncol=7) 

colnames(X)&lt;-c("Intercept", "A", "B", "P1", "P2", "Delta", "Epsilon")
res&lt;-scoregllm(y,s,X[,c(1:6)], 
               c(255,176,176,121,164,37,113,25,164,113,37,25,90,20,20,5))
summary(res)
#

</code></pre>

<hr>
<h2 id='summary.gllm'>Summarize results of gllm</h2><span id='topic+summary.gllm'></span><span id='topic+print.summary.gllm'></span>

<h3>Description</h3>

<p>Summarizes contents of result of call to <code>gllm</code>.  The print method
pretty prints the summary object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gllm'
summary(object,...) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.gllm_+3A_object">object</code></td>
<td>
<p>is the object output from gllm.</p>
</td></tr>
<tr><td><code id="summary.gllm_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

 
<p>A list with components:
</p>
<table role = "presentation">
<tr><td><code>nobs</code></td>
<td>
<p>the number of cells in the observed table</p>
</td></tr>
<tr><td><code>nfull</code></td>
<td>
<p>the number of cells in the full table</p>
</td></tr>
<tr><td><code>mean.cell</code></td>
<td>
<p>the mean cell count in the observed table</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>the final model deviance (-2 log likelihood)</p>
</td></tr>
<tr><td><code>model.df</code></td>
<td>
<p>the model degrees of freedom</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>the model parameter estimates, standard errors</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>Observed and fitted counts, plus Pearsonian residuals</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> David L Duffy </p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
