<!DOCTYPE html><html><head><title>Help for package genetics</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {genetics}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ci.balance'><p>Experimental Function to Correct Confidence Intervals At or Near</p>
Boundaries of the Parameter Space by 'Sliding' the Interval on the
Quantile Scale.</a></li>
<li><a href='#Depreciated'><p>Depreciated functions</p></a></li>
<li><a href='#diseq'><p>Estimate or Compute Confidence Interval for the Single-Marker Disequilibrium</p></a></li>
<li><a href='#expectedGenotypes'><p>Construct expected genotypes/haplotypes according to known allele</p>
variants</a></li>
<li><a href='#genotype'><p>Genotype or Haplotype Objects.</p></a></li>
<li><a href='#gregorius'><p>Probability of Observing All Alleles with a Given Frequency in a</p>
Sample of a Specified Size.</a></li>
<li><a href='#groupGenotype'><p>Group genotype values</p></a></li>
<li><a href='#homozygote'><p>Extract Features of Genotype objects</p></a></li>
<li><a href='#HWE.chisq'><p>Perform Chi-Square Test for Hardy-Weinberg Equilibrium</p></a></li>
<li><a href='#HWE.exact'><p>Exact Test of Hardy-Weinberg Equilibrium for 2-Allele Markers</p></a></li>
<li><a href='#HWE.test'><p>Estimate Disequilibrium and Test for Hardy-Weinberg Equilibrium</p></a></li>
<li><a href='#LD'><p>Pairwise linkage disequilibrium between genetic markers.</p></a></li>
<li><a href='#locus'><p> Create and Manipulate Locus, Gene, and Marker Objects</p></a></li>
<li><a href='#makeGenotypes'><p>Convert columns in a dataframe to genotypes or haplotypes</p></a></li>
<li><a href='#order.genotype'><p>Order/sort genotype/haplotype object</p></a></li>
<li><a href='#plot.genotype'><p>Plot genotype object</p></a></li>
<li><a href='#print.LD'><p>Textual and graphical display of linkage disequilibrium (LD) objects</p></a></li>
<li><a href='#summary.genotype'><p> Allele and Genotype Frequency from a Genotype or</p>
Haplotype Object</a></li>
<li><a href='#undocumented'><p>Undocumented functions</p></a></li>
<li><a href='#write.pop.file'><p>Create genetics data files</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Population Genetics</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.8.1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2012-11-26</td>
</tr>
<tr>
<td>Author:</td>
<td>Gregory Warnes, with contributions from Gregor Gorjanc,
        Friedrich Leisch, and Michael Man.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gregory Warnes &lt;greg@warnes.net&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>combinat, gdata, gtools, MASS, mvtnorm</td>
</tr>
<tr>
<td>Description:</td>
<td>Classes and methods for handling genetic data. Includes
        classes to represent genotypes and haplotypes at single markers
        up to multiple markers on multiple chromosomes. Function
        include allele frequencies, flagging homo/heterozygotes,
        flagging carriers of certain alleles, estimating and testing
        for Hardy-Weinberg disequilibrium, estimating and testing for
        linkage disequilibrium, ...</td>
</tr>
<tr>
<td>biocViews:</td>
<td>Genetics</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-03-01 06:56:06 UTC; hornik</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-03-01 07:10:07 UTC</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
</table>
<hr>
<h2 id='ci.balance'>Experimental Function to Correct Confidence Intervals At or Near
Boundaries of the Parameter Space by 'Sliding' the Interval on the
Quantile Scale.</h2><span id='topic+ci.balance'></span>

<h3>Description</h3>

<p>Experimental function to correct confidence intervals at or near
boundaries of the parameter space by 'sliding' the interval on the
quantile scale.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci.balance(x, est, confidence=0.95, alpha=1-confidence, minval, maxval,
           na.rm=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ci.balance_+3A_x">x</code></td>
<td>
<p>Bootstrap parameter estimates.</p>
</td></tr>
<tr><td><code id="ci.balance_+3A_est">est</code></td>
<td>
<p>Observed value of the parameter.</p>
</td></tr>
<tr><td><code id="ci.balance_+3A_confidence">confidence</code></td>
<td>
<p>Confidence level for the interval. Defaults to
0.95.</p>
</td></tr>
<tr><td><code id="ci.balance_+3A_alpha">alpha</code></td>
<td>
<p>Type I error rate (size) for the interval. Defaults to
1-<code>confidence</code>.</p>
</td></tr>  
<tr><td><code id="ci.balance_+3A_minval">minval</code></td>
<td>
<p>A numeric value specifying the lower bound of the
parameter space. Leave unspecified (the default) if
there is no lower bound.</p>
</td></tr>
<tr><td><code id="ci.balance_+3A_maxval">maxval</code></td>
<td>
<p>A numeric value specifying the upper bound of the
parameter space. Leave unspecified (the default) if
there is no upper bound.</p>
</td></tr>
<tr><td><code id="ci.balance_+3A_na.rm">na.rm</code></td>
<td>
<p> logical. Should missing values be removed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>EXPERIMENTAL FUNCTION:
</p>
<p>This function attempts to compute a proper <code>conf</code>*100%
confidence interval for parameters at or near the boundary of the
parameter space using bootstrapped parameter estimates by 'sliding'
the confidence interval on the quantile scale.
</p>
<p>This is accomplished by attempting to place a <code>conf</code> *100%
interval symmetrically *on the quantile scale* about the observed
value.  If a symmetric interval would exceed the observed data at the
upper (lower) end, a one-sided interval is computed with the upper
(lower) boundary fixed at the the upper (lower) boundary of the
parameter space.
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>ci</code></td>
<td>
<p>A 2-element vector containing the lower and upper confidence
limits.  The names of the elements of the vector give the actual
quantile values used for the interval or one of the character
strings &quot;Upper Boundary&quot; or &quot;Lower Boundary&quot;.</p>
</td></tr>
<tr><td><code>overflow.upper</code>, <code>overflow.lower</code></td>
<td>
<p>The number of elements beyond
those observed that would be needed to compute a symmetric (on the
quantile scale) confidence interval.</p>
</td></tr>
<tr><td><code>n.above</code>, <code>n.below</code></td>
<td>
<p>The number of bootstrap values which are above
(below) the observed value.</p>
</td></tr>
<tr><td><code>lower.n</code>, <code>upper.n</code></td>
<td>
<p>The index of the value used for the endpoint
of the confidence interval or the character string &quot;Upper Boundary&quot;
(&quot;Lower Boundary&quot;).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Gregory R. Warnes <a href="mailto:greg@warnes.net">greg@warnes.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="boot.html#topic+boot">boot</a></code>,
<code><a href="bootstrap.html#topic+bootstrap">bootstrap</a></code>,
Used by <code><a href="#topic+diseq.ci">diseq.ci</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># These are nonsensical examples which simply exercise the
# computation. See the code to diseq.ci for a real example.
#
# FIXME: Add real example using boot or bootstrap.  

set.seed(7981357)
x &lt;- abs(rnorm(100,1))
ci.balance(x,1, minval=0)
ci.balance(x,1)

x &lt;- rnorm(100,1)
x &lt;- ifelse(x&gt;1, 1, x)
ci.balance(x,1, maxval=1)
ci.balance(x,1)
</code></pre>

<hr>
<h2 id='Depreciated'>Depreciated functions</h2><span id='topic+power.casectrl'></span>

<h3>Description</h3>

<p>These functions are depreciated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power.casectrl(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Depreciated_+3A_...">...</code></td>
<td>
<p>All arguments are ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>power.casectl</code> function contained serious errors.  For some
time, replacements were provided by the BioConductor GeneticsDesign package.
</p>
<p>In specific, the <code>power.casectl</code> function used an expected
contingency table to create the test statistic that was
erroneously based on the underlying null, rather than on the
marginal totals of the observed table. In addition, the modeling of
dominant and recessive modes of inheritance had assumed a &quot;perfect&quot; 
genotype with no disease, whereas in reality a dominant or recessive
mode of inheritance simply means that two of the genotypes will have
an identical odds ratio compared to the 3rd genotype (the other
homozygote). 
</p>

<hr>
<h2 id='diseq'>Estimate or Compute Confidence Interval for the Single-Marker Disequilibrium</h2><span id='topic+diseq'></span><span id='topic+diseq.table'></span><span id='topic+diseq.genotype'></span><span id='topic+diseq.ci'></span><span id='topic+print.diseq'></span>

<h3>Description</h3>

<p>Estimate or compute confidence interval for single-marker disequilibrium.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diseq(x, ...)
## S3 method for class 'diseq'
print(x, show=c("D","D'","r","R^2","table"), ...)
diseq.ci(x, R=1000, conf=0.95, correct=TRUE, na.rm=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diseq_+3A_x">x</code></td>
<td>
<p>genotype or haplotype object.</p>
</td></tr>
<tr><td><code id="diseq_+3A_show">show</code></td>
<td>
<p>a character value or vector indicating which
disequilibrium measures should be displayed.  The default is to show
all of the available measures. <code>show="table"</code> will display
a table of observed, expected, and observed-expected
frequencies.</p>
</td></tr>
<tr><td><code id="diseq_+3A_conf">conf</code></td>
<td>
<p>Confidence level to use when computing the confidence
level for D-hat.  Defaults to 0.95, should be in (0,1). </p>
</td></tr>
<tr><td><code id="diseq_+3A_r">R</code></td>
<td>
<p>Number of bootstrap iterations to use when computing the
confidence interval. Defaults to 1000.</p>
</td></tr>
<tr><td><code id="diseq_+3A_correct">correct</code></td>
<td>
<p>See details.</p>
</td></tr>
<tr><td><code id="diseq_+3A_na.rm">na.rm</code></td>
<td>
<p> logical. Should missing values be removed?</p>
</td></tr>
<tr><td><code id="diseq_+3A_...">...</code></td>
<td>
<p> optional parameters passed to <code>boot.ci</code>
(<code>diseq.ci</code>) or ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a single-gene marker, <code>diseq</code> computes the Hardy-Weinberg
(dis)equilibrium statistic D, D', r (the correlation coefficient), and
<code class="reqn">r^2</code> for each pair of allele values, as well as an overall
summary value for each measure across all alleles.  <code>print.diseq</code>
displays the contents of a <code>diseq</code> object. <code>diseq.ci</code>
computes a bootstrap confidence interval for this estimate.
</p>
<p>For consistency, I have applied the standard definitions for D, D',
and r from the Linkage Disequilibrium case, replacing all marker 
probabilities with the appropriate allele probabilities.
</p>
<p>Thus, for each allele pair,
</p>

<ul>
<li><p>D is defined as the half of the raw difference
in frequency between
the observed number of heterozygotes and the expected number:
</p>
<p style="text-align: center;"><code class="reqn">%
 	D = \frac{1}{2} ( p_{ij} + p_{ji} ) - p_i p_j  %
      </code>
</p>


</li>
<li><p>D' rescales D to span the range [-1,1] 
</p>
<p style="text-align: center;"><code class="reqn">D' = \frac{D}{D_{max} } </code>
</p>

<p>where, if D &gt; 0:
</p>
<p style="text-align: center;"><code class="reqn">%
  	D_{max} = \min{ p_i p_j, p_j p_i } = p_i p_j   %
      </code>
</p>
 
<p>or if D &lt; 0:
</p>
<p style="text-align: center;"><code class="reqn">%
  	D_{max} = \min{ p_i (1 - p_j), p_j (1 - p_i) } %
      </code>
</p>


</li>
<li><p>r is the correlation coefficient between two alleles,

and can be computed by
</p>
<p style="text-align: center;"><code class="reqn">%
 	r = \frac{-D}{\sqrt( p_i * (1-p_i) p(j) (1-p_j ) )} %
      </code>
</p>


</li></ul>

<p>where
</p>

<ul>
<li><p>- <code class="reqn">p_i</code> defined as the observed probability of
allele 'i', 
</p>
</li>
<li><p>-<code class="reqn">p_j</code> defined as the observed probability of
allele 'j', and 
</p>
</li>
<li><p>-<code class="reqn">p_{ij}</code> defined as the observed probability of
the allele pair 'ij'. 
</p>
</li></ul>

<p>When there are more than two alleles, the summary values for these
statistics are obtained by computing a weighted average of the
absolute value of each allele pair, where the weight is determined by
the expected frequency. For example:
</p>
<p style="text-align: center;"><code class="reqn">%
     D_{overall} = \sum_{i \ne j}  |D_{ij}| * p_{ij} % 
   </code>
</p>

<p>Bootstrapping is used to generate confidence interval in order to
avoid reliance on parametric assumptions, which will not hold for
alleles with low frequencies (e.g. <code class="reqn">D'</code> following a a Chi-square 
distribution).  
</p>
<p>See the function <code><a href="#topic+HWE.test">HWE.test</a></code> for testing
Hardy-Weinberg Equilibrium, <code class="reqn">D=0</code>.
</p>


<h3>Value</h3>

<p><code>diseq</code> returns an object of class <code>diseq</code> with components
</p>

<ul>
<li><p>callfunction call used to create this object
</p>
</li>
<li><p>data2-way table of allele pair counts
</p>
</li>
<li><p>D.hatmatrix giving the observed count, expected count,
observed - expected difference, and estimate of disequilibrium for
each pair of alleles as well as an overall disequilibrium value.
</p>
</li>
<li><p>TODOmore slots to be documented
</p>
</li></ul>

<p><code>diseq.ci</code> returns an object of class <code><a href="boot.html#topic+boot.ci">boot.ci</a></code>
</p>


<h3>Author(s)</h3>

<p> Gregory R. Warnes <a href="mailto:greg@warnes.net">greg@warnes.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genotype">genotype</a></code>,
<code><a href="#topic+HWE.test">HWE.test</a></code>,
<code><a href="boot.html#topic+boot">boot</a></code>,
<code><a href="boot.html#topic+boot.ci">boot.ci</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
example.data   &lt;- c("D/D","D/I","D/D","I/I","D/D",
                    "D/D","D/D","D/D","I/I","")
g1  &lt;- genotype(example.data)
g1

diseq(g1)
diseq.ci(g1)
HWE.test(g1)  # does the same, plus tests D-hat=0

three.data   &lt;- c(rep("A/A",8),
                  rep("C/A",20),
                  rep("C/T",20),
                  rep("C/C",10),
                  rep("T/T",3))

g3  &lt;- genotype(three.data)
g3

diseq(g3)
diseq.ci(g3, ci.B=10000, ci.type="bca")

# only show observed vs expected table
print(diseq(g3),show='table')

</code></pre>

<hr>
<h2 id='expectedGenotypes'>Construct expected genotypes/haplotypes according to known allele
variants</h2><span id='topic+expectedGenotypes'></span><span id='topic+expectedHaplotypes'></span>

<h3>Description</h3>

<p><code>expectedGenotypes</code> constructs expected genotypes according to
known allele variants, which can be quite tedious with large number of
allele variants. It can handle different level of ploidy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expectedGenotypes(x, alleles=allele.names(x), ploidy=2, sort=TRUE,
                  haplotype=FALSE)
expectedHaplotypes(x, alleles=allele.names(x), ploidy=2, sort=TRUE,
                   haplotype=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expectedGenotypes_+3A_x">x</code></td>
<td>
<p>genotype or haplotype</p>
</td></tr>
<tr><td><code id="expectedGenotypes_+3A_alleles">alleles</code></td>
<td>
<p>character, vector of allele names</p>
</td></tr>
<tr><td><code id="expectedGenotypes_+3A_ploidy">ploidy</code></td>
<td>
<p>numeric, number of chromosome sets i.e. 2 for human autosomal
genes</p>
</td></tr>
<tr><td><code id="expectedGenotypes_+3A_sort">sort</code></td>
<td>
<p>logical, sort genotypes according to order of alleles in
<code>alleles</code> argument</p>
</td></tr>
<tr><td><code id="expectedGenotypes_+3A_haplotype">haplotype</code></td>
<td>
<p>logical, construct haplotypes i.e. ordered genotype</p>
</td></tr>
</table>
<p>At least one of <code>x</code> or <code>alleles</code> must be given.
</p>


<h3>Details</h3>

<p><code>expectedHaplotypes()</code> just calls <code>expectedGenotypes()</code> with
argument <code>haplotype=TRUE</code>.
</p>


<h3>Value</h3>

<p>A character vector with genotype names as &quot;alele1/alele2&quot; for diploid
example. Length of output is <code class="reqn">(n*(n+1))/2</code> for genotype (unordered
genotype) and <code class="reqn">n*n</code> for haplotype (ordered genotype) for <code class="reqn">n</code>
allele variants.
</p>


<h3>Author(s)</h3>

<p> Gregor Gorjanc </p>


<h3>See Also</h3>

 <p><code><a href="#topic+allele.names">allele.names</a></code>, <code><a href="#topic+genotype">genotype</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## On genotype
  prp &lt;- c("ARQ/ARQ", "ARQ/ARQ", "ARR/ARQ", "AHQ/ARQ", "ARQ/ARQ")
  alleles &lt;- c("ARR", "AHQ", "ARH", "ARQ", "VRR", "VRQ")
  expectedGenotypes(as.genotype(prp))
  expectedGenotypes(as.genotype(prp, alleles=alleles))
  expectedGenotypes(as.genotype(prp, alleles=alleles, reorder="yes"))

  ## Only allele names
  expectedGenotypes(alleles=alleles)
  expectedGenotypes(alleles=alleles, ploidy=4)

  ## Haplotype
  expectedHaplotypes(alleles=alleles)
  expectedHaplotypes(alleles=alleles, ploidy=4)[1:20]
</code></pre>

<hr>
<h2 id='genotype'>Genotype or Haplotype Objects.</h2><span id='topic+genotype'></span><span id='topic+haplotype'></span><span id='topic+is.genotype'></span><span id='topic+is.haplotype'></span><span id='topic+as.genotype'></span><span id='topic+as.haplotype'></span><span id='topic+print.genotype'></span><span id='topic++3D+3D.genotype'></span><span id='topic++3D+3D.haplotype'></span><span id='topic++25in+25'></span><span id='topic++25in+25.default'></span><span id='topic++25in+25.genotype'></span><span id='topic++25in+25.haplotype'></span><span id='topic++5B.genotype'></span><span id='topic++5B.haplotype'></span><span id='topic++5B+3C-.genotype'></span><span id='topic++5B+3C-.haplotype'></span><span id='topic+heterozygote.genotype'></span><span id='topic+homozygote.genotype'></span><span id='topic+print.allele.count'></span><span id='topic+print.allele.genotype'></span><span id='topic+allele.count.genotype'></span><span id='topic+as.genotype.allele.count'></span><span id='topic+as.genotype.character'></span><span id='topic+as.genotype.default'></span><span id='topic+as.genotype.factor'></span><span id='topic+as.genotype.genotype'></span><span id='topic+as.genotype.haplotype'></span><span id='topic+as.genotype.table'></span><span id='topic+nallele'></span>

<h3>Description</h3>

<p><code>genotype</code> creates a genotype object.
</p>
<p><code>haplotype</code> creates a haplotype object.
</p>
<p><code>is.genotype</code> returns <code>TRUE</code> if <code>x</code> is of class
<code>genotype</code>
</p>
<p><code>is.haplotype</code> returns <code>TRUE</code> if <code>x</code> is of class
<code>haplotype</code>
</p>
<p><code>as.genotype</code> attempts to coerce its argument into an object of
class <code>genotype</code>.
</p>
<p><code>as.genotype.allele.count</code> converts allele counts (0,1,2) into
genotype pairs (&quot;A/A&quot;, &quot;A/B&quot;, &quot;B/B&quot;).
</p>
<p><code>as.haplotype</code> attempts to coerce its argument into an object of
class <code>haplotype</code>.
</p>
<p><code>nallele</code> returns the number of alleles in an object of class
<code>genotype</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  genotype(a1, a2=NULL, alleles=NULL, sep="/", remove.spaces=TRUE,
           reorder = c("yes", "no", "default", "ascii", "freq"),
           allow.partial.missing=FALSE, locus=NULL,
           genotypeOrder=NULL)

  haplotype(a1, a2=NULL, alleles=NULL, sep="/", remove.spaces=TRUE,
            reorder="no", allow.partial.missing=FALSE, locus=NULL,
            genotypeOrder=NULL)

  is.genotype(x)

  is.haplotype(x)

  as.genotype(x, ...)

  ## S3 method for class 'allele.count'
as.genotype(x, alleles=c("A","B"), ... )

  as.haplotype(x, ...)

  ## S3 method for class 'genotype'
print(x, ...)

  nallele(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genotype_+3A_x">x</code></td>
<td>
<p> either an object of class <code>genotype</code> or
<code>haplotype</code> or an object to be converted to class <code>genotype</code> or
<code>haplotype</code>.</p>
</td></tr>
<tr><td><code id="genotype_+3A_a1">a1</code>, <code id="genotype_+3A_a2">a2</code></td>
<td>
<p> vector(s) or matrix containing two alleles
for each individual. See details, below.</p>
</td></tr>
<tr><td><code id="genotype_+3A_alleles">alleles</code></td>
<td>
<p> names (and order if <code>reorder="yes"</code>) of possible
alleles.</p>
</td></tr>
<tr><td><code id="genotype_+3A_sep">sep</code></td>
<td>
<p> character separator or column number used to divide
alleles when <code>a1</code> is a vector of strings where each string
holds both alleles. See below for details.</p>
</td></tr>
<tr><td><code id="genotype_+3A_remove.spaces">remove.spaces</code></td>
<td>
<p> logical indicating whether spaces and tabs will
be removed from a1 and a2  before processing.</p>
</td></tr>
<tr><td><code id="genotype_+3A_reorder">reorder</code></td>
<td>
<p>how should alleles within an individual be reordered.
If <code>reorder="no"</code>, use the order specified by the alleles
parameter.  If <code>reorder="freq"</code> or
<code>reorder="yes"</code>, sort alleles within each individual by
observed frequency.  If <code>reorder="ascii"</code>, reorder alleles in
ASCII order (alphabetical, with all upper case before
lower case). The default value for <code>genotype</code>
is <code>"freq"</code>.  The default value for <code>haplotype</code> is
<code>"no"</code>.
</p>
</td></tr>
<tr><td><code id="genotype_+3A_allow.partial.missing">allow.partial.missing</code></td>
<td>
<p>logical indicating whether one allele is
permitted to be missing.  When set to <code>FALSE</code> both alleles
are set to <code>NA</code> when either is missing.</p>
</td></tr>
<tr><td><code id="genotype_+3A_locus">locus</code></td>
<td>
<p> object of class locus, gene, or marker, holding
information about the source of this genotype.</p>
</td></tr>
<tr><td><code id="genotype_+3A_genotypeorder">genotypeOrder</code></td>
<td>
<p>character, vector of genotype/haplotype names so
that further functions can sort genotypes/haplotypes in wanted
order</p>
</td></tr>
<tr><td><code id="genotype_+3A_...">...</code></td>
<td>
<p>optional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Genotype objects hold information on which gene or marker alleles were
observed for different individuals.  For each individual, two alleles
are recorded.
</p>
<p>The genotype class considers the stored alleles to be unordered, i.e., &quot;C/T&quot;
is equivalent to &quot;T/C&quot;.  The haplotype class considers the order of the
alleles to be significant so that &quot;C/T&quot; is distinct from &quot;T/C&quot;.
</p>
<p>When calling <code>genotype</code> or <code>haplotype</code>:
</p>

<ul>
<li><p> If only <code>a1</code> is provided and is a character vector, it is
assumed that each element encodes both alleles. In this case, if
<code>sep</code> is a character string, <code>a1</code> is assumed to be coded
as &quot;Allele1&lt;sep&gt;Allele2&quot;.  If <code>sep</code> is a numeric value, it is
assumed that character locations <code>1:sep</code> contain allele 1 and
that remaining locations contain allele 2.
</p>
</li>
<li><p> If <code>a1</code> is a matrix, it is assumed that column 1 contains
allele 1 and column 2 contains allele 2.
</p>
</li>
<li><p> If <code>a1</code> and <code>a2</code> are both provided, each is assumed to
contain one allele value so that the genotype for an individual is
obtained by <code>paste(a1,a2,sep="/")</code>.
</p>
</li></ul>

<p>If <code>remove.spaces</code> is TRUE, (the default) any whitespace
contained in <code>a1</code> and <code>a2</code> is removed when the genotypes are
created.  If whitespace is used as the separator, (eg &quot;C C&quot;, &quot;C T&quot;,
...), be sure to set remove.spaces to FALSE.
</p>
<p>When the alleles are explicitly specified using the <code>alleles</code>
argument, all potential alleles not present in the list will be
converted to <code>NA</code>.
</p>
<p>NOTE: <code>genotype</code> assumes that the order of the alleles is not important
(E.G., &quot;A/C&quot; == &quot;C/A&quot;).  Use class <code>haplotype</code> if order is significant.
</p>
<p>If <code>genotypeOrder=NULL</code> (the default setting), then
<code><a href="#topic+expectedGenotypes">expectedGenotypes</a></code> is used to get standard sorting order.
Only unique values in <code>genotypeOrder</code> are used, which in turns
means that the first occurrence prevails. When <code>genotypeOrder</code> is
given some genotype names, but not all that appear in the data, the
rest (those in the data and possible combinations based on allele
variants) is automatically added at the end of
<code>genotypeOrder</code>. This puts &quot;missing&quot; genotype names at the end of
sort order. This feature is especially useful when there are a lot of
allele variants and especially in haplotypes. See examples.
</p>


<h3>Value</h3>

<p>The genotype class extends &quot;factor&quot; and haplotype extends
genotype. Both classes have the following attributes:
</p>
<table>
<tr><td><code>levels</code></td>
<td>
<p> character vector of possible genotype/haplotype values
stored coded by <code>paste( allele1, "/", allele2, sep="")</code>.</p>
</td></tr>
<tr><td><code>allele.names</code></td>
<td>
<p> character vector of possible alleles. For a SNP,
these might be c(&quot;A&quot;,&quot;T&quot;).   For a variable length dinucleotyde
repeat this might be c(&quot;136&quot;,&quot;138&quot;,&quot;140&quot;,&quot;148&quot;). </p>
</td></tr>
<tr><td><code>allele.map</code></td>
<td>
<p> matrix encoding how the factor levels correspond to
alleles.  See the source code to <code>allele.genotype()</code> for how to
extract allele values using this matrix.  Better yet, just use
<code>allele.genotype()</code>.</p>
</td></tr>
<tr><td><code>genotypeOrder</code></td>
<td>
<p>character, genotype/haplotype names in
defined order that can used for sorting in various functions. Note
that this slot stores both ordered and unordered genotypes
i.e. &quot;A/B&quot; and &quot;B/A&quot;.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gregory R. Warnes <a href="mailto:greg@warnes.net">greg@warnes.net</a> and
Friedrich Leisch.</p>


<h3>See Also</h3>

<p><code><a href="#topic+HWE.test">HWE.test</a></code>,
<code><a href="#topic+allele">allele</a></code>,
<code><a href="#topic+homozygote">homozygote</a></code>,
<code><a href="#topic+heterozygote">heterozygote</a></code>,
<code><a href="#topic+carrier">carrier</a></code>,
<code><a href="#topic+summary.genotype">summary.genotype</a></code>,
<code><a href="#topic+allele.count">allele.count</a></code>,
<code><a href="#topic+sort.genotype">sort.genotype</a></code>,
<code><a href="#topic+genotypeOrder">genotypeOrder</a></code>,
<code><a href="#topic+locus">locus</a></code>,
<code><a href="#topic+gene">gene</a></code>,
<code><a href="#topic+marker">marker</a></code>, and
<code><a href="#topic++25in+25">%in%</a></code> for default %in% method
</p>


<h3>Examples</h3>

<pre><code class='language-R'># several examples of genotype data in different formats
example.data   &lt;- c("D/D","D/I","D/D","I/I","D/D",
                    "D/D","D/D","D/D","I/I","")
g1  &lt;- genotype(example.data)
g1

example.data2  &lt;- c("C-C","C-T","C-C","T-T","C-C",
                    "C-C","C-C","C-C","T-T","")
g2  &lt;- genotype(example.data2,sep="-")
g2


example.nosep  &lt;- c("DD", "DI", "DD", "II", "DD",
                    "DD", "DD", "DD", "II", "")
g3  &lt;- genotype(example.nosep,sep="")
g3

example.a1 &lt;- c("D",  "D",  "D",  "I",  "D",  "D",  "D",  "D",  "I",  "")
example.a2 &lt;- c("D",  "I",  "D",  "I",  "D",  "D",  "D",  "D",  "I",  "")
g4  &lt;- genotype(example.a1,example.a2)
g4

example.mat &lt;- cbind(a1=example.a1, a1=example.a2)
g5  &lt;- genotype(example.mat)
g5

example.data5  &lt;- c("D   /   D","D   /   I","D   /   D","I   /   I",
                    "D   /   D","D   /   D","D   /   D","D   /   D",
                    "I   /   I","")
g5  &lt;- genotype(example.data5,rem=TRUE)
g5

# show how genotype and haplotype differ
data1 &lt;- c("C/C", "C/T", "T/C")
data2 &lt;- c("C/C", "T/C", "T/C")

test1  &lt;- genotype( data1 )
test2  &lt;- genotype( data2 )

test3  &lt;-  haplotype( data1 )
test4  &lt;-  haplotype( data2 )

test1==test2
test3==test4

test1=="C/T"
test1=="T/C"

test3=="C/T"
test3=="T/C"

## also
test1 
test1 
test3 

test1 
test1 

test3 
test3 

## "Messy" example

m3  &lt;-  c("D D/\t   D D","D\tD/   I",  "D D/   D D","I/   I",
          "D D/   D D","D D/   D D","D D/   D D","D D/   D D",
          "I/   I","/   ","/I")

genotype(m3)
summary(genotype(m3))

m4  &lt;-  c("D D","D I","D D","I I",
          "D D","D D","D D","D D",
          "I I","   ","  I")

genotype(m4,sep=1)
genotype(m4,sep=" ",remove.spaces=FALSE)
summary(genotype(m4,sep=" ",remove.spaces=FALSE))

m5  &lt;-  c("DD","DI","DD","II",
          "DD","DD","DD","DD",
          "II","   "," I")
genotype(m5,sep=1)
haplotype(m5,sep=1,remove.spaces=FALSE)

g5  &lt;- genotype(m5,sep="")
h5  &lt;- haplotype(m5,sep="")

heterozygote(g5)
homozygote(g5)
carrier(g5,"D")

g5[9:10]  &lt;- haplotype(m4,sep=" ",remove=FALSE)[1:2]
g5

g5[9:10]
allele(g5[9:10],1)
allele(g5,1)[9:10]

# drop unused alleles
g5[9:10,drop=TRUE]
h5[9:10,drop=TRUE]

# Convert allele.counts into genotype

x &lt;- c(0,1,2,1,1,2,NA,1,2,1,2,2,2)
g &lt;- as.genotype.allele.count(x, alleles=c("C","T") )
g

# Use of genotypeOrder
example.data   &lt;- c("D/D","D/I","I/D","I/I","D/D",
                    "D/D","D/I","I/D","I/I","")
summary(genotype(example.data))
genotypeOrder(genotype(example.data))

summary(genotype(example.data, genotypeOrder=c("D/D", "I/I", "D/I")))
summary(genotype(example.data, genotypeOrder=c(              "D/I")))
summary(haplotype(example.data, genotypeOrder=c(             "I/D", "D/I")))
example.data &lt;- genotype(example.data)
genotypeOrder(example.data) &lt;- c("D/D", "I/I", "D/I")
genotypeOrder(example.data)

</code></pre>

<hr>
<h2 id='gregorius'>Probability of Observing All Alleles with a Given Frequency in a
Sample of a Specified Size.</h2><span id='topic+gregorius'></span>

<h3>Description</h3>

<p>Probability of observing all alleles with a given frequency in a
sample of a specified size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gregorius(freq, N, missprob, tol = 1e-10, maxN = 10000, maxiter=100, showiter = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gregorius_+3A_freq">freq</code></td>
<td>
<p>(Minimum) Allele frequency (required)</p>
</td></tr>
<tr><td><code id="gregorius_+3A_n">N</code></td>
<td>
<p>Number of sampled genotypes</p>
</td></tr>
<tr><td><code id="gregorius_+3A_missprob">missprob</code></td>
<td>
<p>Desired maximum probability of failing to observe an allele.</p>
</td></tr>
<tr><td><code id="gregorius_+3A_tol">tol</code></td>
<td>
<p>Omit computation for terms which contribute less than this value.</p>
</td></tr>
<tr><td><code id="gregorius_+3A_maxn">maxN</code></td>
<td>
<p>Largest value to consider when searching for N.</p>
</td></tr>
<tr><td><code id="gregorius_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations to use when searching for N.</p>
</td></tr>
<tr><td><code id="gregorius_+3A_showiter">showiter</code></td>
<td>
<p>Boolean flag indicating whether to show the iterations
performed when searching for N.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>freq</code> and <code>N</code> are provided, but <code>missprob</code> is omitted,
this function computes the probability of failing to observe all alleles
with true underlying frequency <code>freq</code> when <code>N</code> diploid
genotypes are sampled.  This is accomplished using the sum provided in
Corollary 2 of Gregorius (1980), omitting terms which contribute less
than <code>tol</code> to the result.
</p>
<p>When <code>freq</code> and <code>missprob</code> are provide, but <code>N</code> is
omitted. A binary search on the range of [1,<code>maxN</code>] is performed
to locate the smallest sample size, <code>N</code>, for which the
probability of failing to observe all alleles with true
underlying frequency <code>freq</code> is at most <code>missprob</code>.  In this
case, <code>maxiter</code> specifies the largest number of iterations to use
in the binary search, and <code>showiter</code> controls whether the
iterations of the search are displayed.
</p>


<h3>Value</h3>

<p>A list containing the following values:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>   Function call used to generate this object.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p> One of the strings, &quot;Compute missprob given N and freq&quot;,
or &quot;Determine minimal N given missprob and freq&quot;, indicating which
type of computation was performed.</p>
</td></tr>
<tr><td><code>retval$freq</code></td>
<td>
<p> Specified allele frequency.</p>
</td></tr>
<tr><td><code>retval$N</code></td>
<td>
<p>    Specified or computed sample size. </p>
</td></tr>
<tr><td><code>retval$missprob</code></td>
<td>
<p> Computed probability of failing to observe all
of the alleles with frequency <code>freq</code>. </p>
</td></tr>
</table>


<h3>Note</h3>

<p>This code produces sample sizes that are slightly larger than those
given in table 1 of Gregorius (1980).  This appears to be due to
rounding of the computed <code>missprob</code>s by the authors of that
paper.
</p>


<h3>Author(s)</h3>

<p> Code submitted by David Duffy <a href="mailto:davidD@qumr.edu.au">davidD@qumr.edu.au</a>,
substantially enhanced by Gregory R. Warnes
<a href="mailto:greg@warnes.net">greg@warnes.net</a>. </p>


<h3>References</h3>

<p>Gregorius, H.R. 1980. The probability of losing an allele when
diploid genotypes are sampled.  Biometrics 36, 643-652.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Compute the probability of missing an allele with frequency 0.15 when
# 20 genotypes are sampled:
gregorius(freq=0.15, N=20)

# Determine what sample size is required to observe all alleles with true
# frequency 0.15 with probability 0.95
gregorius(freq=0.15, missprob=1-0.95)


</code></pre>

<hr>
<h2 id='groupGenotype'>Group genotype values</h2><span id='topic+groupGenotype'></span>

<h3>Description</h3>

<p><code>groupGenotype</code> groups genotype or haplotype values
according to given &quot;grouping/mapping&quot; information</p>


<h3>Usage</h3>

<pre><code class='language-R'>
groupGenotype(x, map, haplotype=FALSE, factor=TRUE, levels=NULL, verbose=FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="groupGenotype_+3A_x">x</code></td>
<td>
<p>genotype or haplotype</p>
</td></tr>
<tr><td><code id="groupGenotype_+3A_map">map</code></td>
<td>
<p>list, mapping information, see details and examples</p>
</td></tr>
<tr><td><code id="groupGenotype_+3A_haplotype">haplotype</code></td>
<td>
<p>logical, should values in a <code>map</code> be treated as
haplotypes or genotypes, see details</p>
</td></tr>
<tr><td><code id="groupGenotype_+3A_factor">factor</code></td>
<td>
<p>logical, should output be a factor or a character</p>
</td></tr>
<tr><td><code id="groupGenotype_+3A_levels">levels</code></td>
<td>
<p>character, optional vector of level names if factor is
produced (<code>factor=TRUE</code>); the default is to use the sort order
of the group names in <code>map</code></p>
</td></tr>
<tr><td><code id="groupGenotype_+3A_verbose">verbose</code></td>
<td>
<p>logical, print genotype names that match entries in
the map - mainly used for debugging</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Examples show how <code>map</code> can be constructed. This are the main
points to be aware of:
</p>

<ul>
<li><p> names of list components are used as new group names
</p>
</li>
<li><p> list components hold genotype names per each group
</p>
</li>
<li><p> genotype names can be specified directly i.e. &quot;A/B&quot; or
abbreviated such as &quot;A/*&quot; or even &quot;*/*&quot;, where &quot;*&quot; matches any
possible allele, but read also further on
</p>
</li>
<li><p> all genotype names that are not specified can be captured
with &quot;.else&quot; (note the dot!)
</p>
</li>
<li><p> genotype names that were not specified (and &quot;.else&quot; was not
used) are changed to <code>NA</code>
</p>
</li></ul>

<p><code>map</code> is inspected before grouping of genotypes is being
done. The following steps are done during inspection:
</p>

<ul>
<li><p> &quot;.else&quot; must be at the end (if not, it is moved) to match
everything that has not yet been defined
</p>
</li>
<li><p> any specifications like &quot;A/*&quot;, &quot;*/A&quot;, or &quot;*/*&quot; are extended to
all possible genotypes based on alleles in argument <code>alleles</code> -
in case of <code>haplotype=FALSE</code>, &quot;A/*&quot; and &quot;*/A&quot; match the same
genotypes
</p>
</li>
<li><p> since use of &quot;*&quot; and &quot;.else&quot; can cause duplicates along the
whole map, duplicates are removed sequentially (first occurrence
is kept)
</p>
</li></ul>

<p>Using &quot;.else&quot; or &quot;*/*&quot; at the end of the map produces the same result,
due to removing duplicates sequentially.
</p>


<h3>Value</h3>

<p>A factor or character vector with genotypes grouped</p>


<h3>Author(s)</h3>

<p>Gregor Gorjanc</p>


<h3>See Also</h3>

<p><code><a href="#topic+genotype">genotype</a></code>,
<code><a href="#topic+haplotype">haplotype</a></code>,
<code><a href="base.html#topic+factor">factor</a></code>, and
<code><a href="base.html#topic+levels">levels</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## --- Setup ---

x &lt;- c("A/A", "A/B", "B/A", "A/C", "C/A", "A/D", "D/A",
       "B/B", "B/C", "C/B", "B/D", "D/B",
       "C/C", "C/D", "D/C",
       "D/D")
g &lt;- genotype(x, reorder="yes")
## "A/A" "A/B" "A/B" "A/C" "A/C" "A/D" "A/D" "B/B" "B/C" "B/C" "B/D" "B/D"
## "C/C" "C/D" "C/D" "D/D"

h &lt;- haplotype(x)
## "A/A" "A/B" "B/A" "A/C" "C/A" "A/D" "D/A" "B/B" "B/C" "C/B" "B/D" "D/B"
## "C/C" "C/D" "D/C" "D/D"

## --- Use of "A/A", "A/*" and ".else" ---

map &lt;- list("homoG"=c("A/A", "B/B", "C/C", "D/D"),
            "heteroA*"=c("A/B", "A/C", "A/D"),
            "heteroB*"=c("B/*"),
            "heteroRest"=".else")

(tmpG &lt;- groupGenotype(x=g, map=map, factor=FALSE))
(tmpH &lt;- groupGenotype(x=h, map=map, factor=FALSE, haplotype=TRUE))

## Show difference between genotype and haplotype treatment
cbind(as.character(h), gen=tmpG, hap=tmpH, diff=!(tmpG == tmpH))
##              gen          hap          diff
##  [1,] "A/A" "homoG"      "homoG"      "FALSE"
##  [2,] "A/B" "heteroA*"   "heteroA*"   "FALSE"
##  [3,] "B/A" "heteroA*"   "heteroB*"   "TRUE"
##  [4,] "A/C" "heteroA*"   "heteroA*"   "FALSE"
##  [5,] "C/A" "heteroA*"   "heteroRest" "TRUE"
##  [6,] "A/D" "heteroA*"   "heteroA*"   "FALSE"
##  [7,] "D/A" "heteroA*"   "heteroRest" "TRUE"
##  [8,] "B/B" "homoG"      "homoG"      "FALSE"
##  [9,] "B/C" "heteroB*"   "heteroB*"   "FALSE"
## [10,] "C/B" "heteroB*"   "heteroRest" "TRUE"
## [11,] "B/D" "heteroB*"   "heteroB*"   "FALSE"
## [12,] "D/B" "heteroB*"   "heteroRest" "TRUE"
## [13,] "C/C" "homoG"      "homoG"      "FALSE"
## [14,] "C/D" "heteroRest" "heteroRest" "FALSE"
## [15,] "D/C" "heteroRest" "heteroRest" "FALSE"
## [16,] "D/D" "homoG"      "homoG"      "FALSE"

map &lt;- list("withA"="A/*", "rest"=".else")
groupGenotype(x=g, map=map, factor=FALSE)
##  [1] "withA" "withA" "withA" "withA" "withA" "withA" "withA" "rest"  "rest"
## [10] "rest"  "rest"  "rest"  "rest"  "rest"  "rest"  "rest"

groupGenotype(x=h, map=map, factor=FALSE, haplotype=TRUE)
##  [1] "withA" "withA" "rest"  "withA" "rest"  "withA" "rest"  "rest"  "rest"
## [10] "rest"  "rest"  "rest"  "rest"  "rest"  "rest"  "rest"

## --- Use of "*/*" ---

map &lt;- list("withA"="A/*", withB="*/*")
groupGenotype(x=g, map=map, factor=FALSE)
##  [1] "withA" "withA" "withA" "withA" "withA" "withA" "withA" "withB" "withB"
## [10] "withB" "withB" "withB" "withB" "withB" "withB" "withB"

## --- Missing genotype specifications produces NA's ---

map &lt;- list("withA"="A/*", withB="B/*")
groupGenotype(x=g, map=map, factor=FALSE)
##  [1] "withA" "withA" "withA" "withA" "withA" "withA" "withA" "withB" "withB"
## [10] "withB" "withB" "withB" NA      NA      NA      NA

groupGenotype(x=h, map=map, factor=FALSE, haplotype=TRUE)
##  [1] "withA" "withA" "withB" "withA" NA      "withA" NA      "withB" "withB"
## [10] NA      "withB" NA      NA      NA      NA      NA

</code></pre>

<hr>
<h2 id='homozygote'>Extract Features of Genotype objects</h2><span id='topic+homozygote'></span><span id='topic+heterozygote'></span><span id='topic+carrier'></span><span id='topic+carrier.genotype'></span><span id='topic+allele'></span><span id='topic+allele.count'></span><span id='topic+allele.names'></span>

<h3>Description</h3>

<p><code>homozygote</code> creates an vector of logicals that are true when the
alleles of the corresponding observation are the identical.
</p>
<p><code>heterozygote </code> creates an vector of logicals that are true when the
alleles of the corresponding observation differ.
</p>
<p><code>carrier</code> create a logical vector or matrix of logicals
indicating whether the specified alleles are present.
</p>
<p><code>allele.count</code> returns the number of copies of the specified
alleles carried by each observation.
</p>
<p><code>allele</code> extract the specified allele(s) as a character vector
or a 2 column matrix.
</p>
<p><code>allele.names</code> extract the set of allele names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>homozygote(x,  allele.name, ...)
heterozygote(x, allele.name, ...)
carrier(x, allele.name, ...)
## S3 method for class 'genotype'
carrier(x, allele.name=allele.names(x),
        any=!missing(allele.name), na.rm=FALSE, ...)
allele.count(x, allele.name=allele.names(x),any=!missing(allele.name),
             na.rm=FALSE)
allele(x, which=c(1,2) )
allele.names(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="homozygote_+3A_x">x</code></td>
<td>
 <p><code>genotype</code> object </p>
</td></tr>
<tr><td><code id="homozygote_+3A_...">...</code></td>
<td>
<p> optional parameters (ignored) </p>
</td></tr>
<tr><td><code id="homozygote_+3A_allele.name">allele.name</code></td>
<td>
<p> character value or vector of allele names</p>
</td></tr>
<tr><td><code id="homozygote_+3A_any">any</code></td>
<td>
<p> logical value.  When <code>TRUE</code>, a single count or
indicator is returned by combining the results for all of the
elements of <code>allele</code>. If <code>FALSE</code> separate counts or
indicators should be returned for each element of
<code>allele</code>.  Defaults to <code>FALSE</code> if <code>allele</code> is
missing. Otherwise defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="homozygote_+3A_na.rm">na.rm</code></td>
<td>
<p> logical value indicating whether to remove missing
values.  When true, any <code>NA</code> values will be replaced by
<code>0</code> or <code>FALSE</code> as appropriate.  Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="homozygote_+3A_which">which</code></td>
<td>
<p> selects which allele to return. For first allele use
<code>1</code>.  For second allele use <code>2</code>.  For both (the default)
use <code>c(1,2)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the <code>allele.name</code> argument is given, heterozygote and
homozygote return <code>TRUE</code> if <em>exactly</em> one or both alleles,
respectively, match the specified allele.name.
</p>


<h3>Value</h3>

<p><code>homozygote</code> and <code>heterozygote </code> return a vector of
logicals.
</p>
<p><code>carrier</code> returns a logical vector if only one allele is
specified, or if <code>any</code> is <code>TRUE</code>.  Otherwise, it returns
matrix of logicals with one row for each element of <code>allele</code>.
</p>
<p><code>allele.count</code> returns a  vector of counts if only one allele is
specified, or if <code>any</code> is <code>TRUE</code>.  Otherwise, it returns
matrix of counts with one row for each element of <code>allele</code>.
</p>
<p><code>allele</code> returns a character vector when one allele is
specified.  When 2 alleles are specified, it returns a 2 column
character matrix.
</p>
<p><code>allele.names</code> returns a character vector containing the set of
allele names.
</p>


<h3>Author(s)</h3>

<p> Gregory R. Warnes <a href="mailto:greg@warnes.net">greg@warnes.net</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+genotype">genotype</a></code>,
<code><a href="#topic+HWE.test">HWE.test</a></code>,
<code><a href="#topic+summary.genotype">summary.genotype</a></code>,

<code><a href="#topic+locus">locus</a></code>
<code><a href="#topic+gene">gene</a></code>
<code><a href="#topic+marker">marker</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
example.data   &lt;- c("D/D","D/I","D/D","I/I","D/D","D/D","D/D","D/D","I/I","")
g1  &lt;- genotype(example.data)
g1

heterozygote(g1)
homozygote(g1)

carrier(g1,"D")
carrier(g1,"D",na.rm=TRUE)

# get count of one allele 
allele.count(g1,"D")

# get count of each allele
allele.count(g1)  # equivalent to
allele.count(g1, c("D","I"), any=FALSE)

# get combined count for both alleles
allele.count(g1,c("I","D"))

# get second allele
allele(g1,2)

# get both alleles
allele(g1)

</code></pre>

<hr>
<h2 id='HWE.chisq'>Perform Chi-Square Test for Hardy-Weinberg Equilibrium</h2><span id='topic+HWE.chisq'></span><span id='topic+HWE.chisq.genotype'></span>

<h3>Description</h3>

<p>Test the null hypothesis that Hardy-Weinberg equilibrium holds using
the Chi-Square method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HWE.chisq(x, ...)
## S3 method for class 'genotype'
HWE.chisq(x, simulate.p.value=TRUE, B=10000, ...)
          
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HWE.chisq_+3A_x">x</code></td>
<td>
<p>genotype or haplotype object.</p>
</td></tr>
<tr><td><code id="HWE.chisq_+3A_simulate.p.value">simulate.p.value</code></td>
<td>
<p>a logical value indicating whether the p-value
should be computed using simulation instead of using the
<code class="reqn">\chi^2</code> approximation. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="HWE.chisq_+3A_b">B</code></td>
<td>
<p>Number of simulation iterations to use when
<code>simulate.p.value=TRUE</code>. Defaults to 10000.</p>
</td></tr>
<tr><td><code id="HWE.chisq_+3A_...">...</code></td>
<td>
<p> optional parameters passed to <code>chisq.test</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates a 2-way table of allele counts, then calls
<code><a href="stats.html#topic+chisq.test">chisq.test</a></code> to compute a p-value for Hardy-Weinberg
Equilibrium.  By default, it uses an unadjusted Chi-Square test
statistic and computes the p-value using a simulation/permutation
method.  When <code>simulate.p.value=FALSE</code>, it computes the test
statistic using the Yates continuity correction and tests it against
the asymptotic Chi-Square distribution with the approproate degrees of
freedom.
</p>
<p>Note: The Yates continuty correction is applied *only* when
<code>simulate.p.value=FALSE</code>, so that the reported test statistics
when <code>simulate.p.value=FALSE</code> and <code>simulate.p.value=TRUE</code>
will differ.
</p>


<h3>Value</h3>

<p>An object of class <code>htest</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HWE.exact">HWE.exact</a></code>,
<code><a href="#topic+HWE.test">HWE.test</a></code>,
<code><a href="#topic+diseq">diseq</a></code>,
<code><a href="#topic+diseq.ci">diseq.ci</a></code>,
<code><a href="#topic+allele">allele</a></code>,
<code><a href="stats.html#topic+chisq.test">chisq.test</a></code>,
<code><a href="boot.html#topic+boot">boot</a></code>,
<code><a href="boot.html#topic+boot.ci">boot.ci</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
example.data   &lt;- c("D/D","D/I","D/D","I/I","D/D",
                    "D/D","D/D","D/D","I/I","")
g1  &lt;- genotype(example.data)
g1

HWE.chisq(g1)
# compare with
HWE.exact(g1)
# and 
HWE.test(g1)

three.data   &lt;- c(rep("A/A",8),
                  rep("C/A",20),
                  rep("C/T",20),
                  rep("C/C",10),
                  rep("T/T",3))

g3  &lt;- genotype(three.data)
g3

HWE.chisq(g3, B=10000)


</code></pre>

<hr>
<h2 id='HWE.exact'>Exact Test of Hardy-Weinberg Equilibrium for 2-Allele Markers</h2><span id='topic+HWE.exact'></span>

<h3>Description</h3>

<p>Exact test of Hardy-Weinberg Equilibrium for 2 Allele Markers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HWE.exact(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HWE.exact_+3A_x">x</code></td>
<td>
<p> Genotype object </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class 'htest'.
</p>


<h3>Note</h3>

<p> This function only works for genotypes with exactly 2 alleles.</p>


<h3>Author(s)</h3>

<p>David Duffy <a href="mailto:davidD@qimr.edu.au">davidD@qimr.edu.au</a> with modifications by Gregory
R. Warnes <a href="mailto:greg@warnes.net">greg@warnes.net</a>
</p>


<h3>References</h3>

<p>Emigh TH. (1980) &quot;Comparison of tests for Hardy-Weinberg Equilibrium&quot;,
Biometrics, 36, 627-642.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HWE.chisq">HWE.chisq</a></code>,
<code><a href="#topic+HWE.test">HWE.test</a></code>,
<code><a href="#topic+diseq">diseq</a></code>,
<code><a href="#topic+diseq.ci">diseq.ci</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example.data   &lt;- c("D/D","D/I","D/D","I/I","D/D",
                    "D/D","D/D","D/D","I/I","")
g1  &lt;- genotype(example.data)
g1

HWE.exact(g1)
# compare with
HWE.chisq(g1)




g2 &lt;- genotype(sample( c("A","C"), 100, p=c(100,10), rep=TRUE),
               sample( c("A","C"), 100, p=c(100,10), rep=TRUE) )
HWE.exact(g2)

</code></pre>

<hr>
<h2 id='HWE.test'>Estimate Disequilibrium and Test for Hardy-Weinberg Equilibrium</h2><span id='topic+HWE.test'></span><span id='topic+HWE.test.genotype'></span><span id='topic+HWE.test.data.frame'></span><span id='topic+print.HWE.test'></span>

<h3>Description</h3>

<p>Estimate disequilibrium parameter and test the null hypothesis that 
Hardy-Weinberg equilibrium holds. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HWE.test(x, ...)
## S3 method for class 'genotype'
HWE.test(x, exact = nallele(x)==2, simulate.p.value=!exact,
         B=10000, conf=0.95, ci.B=1000, ... )
## S3 method for class 'data.frame'
HWE.test(x, ..., do.Allele.Freq=TRUE, do.HWE.test=TRUE)
## S3 method for class 'HWE.test'
print(x, show=c("D","D'","r","table"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HWE.test_+3A_x">x</code></td>
<td>
<p>genotype or haplotype object.</p>
</td></tr>
<tr><td><code id="HWE.test_+3A_exact">exact</code></td>
<td>
<p>a logical value indicated whether the p-value should be
computed using the exact method, which is only available for 2
allele genotypes.</p>
</td></tr>
<tr><td><code id="HWE.test_+3A_simulate.p.value">simulate.p.value</code></td>
<td>
<p>a logical value indicating whether the p-value
should be computed using simulation instead of using the
<code class="reqn">\chi^2</code> approximation. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="HWE.test_+3A_b">B</code></td>
<td>
<p>Number of simulation iterations to use when
<code>simulate.p.value=TRUE</code>. Defaults to 10000.</p>
</td></tr>
<tr><td><code id="HWE.test_+3A_conf">conf</code></td>
<td>
<p>Confidence level to use when computing the confidence
level for D-hat.  Defaults to 0.95, should be in (0,1). </p>
</td></tr>
<tr><td><code id="HWE.test_+3A_ci.b">ci.B</code></td>
<td>
<p>Number of bootstrap iterations to use when computing the
confidence interval. Defaults to 1000.</p>
</td></tr>
<tr><td><code id="HWE.test_+3A_show">show</code></td>
<td>
<p>a character vector containing the names of HWE test
statistics to display from the set of &quot;D&quot;, &quot;D'&quot;, &quot;r&quot;, and &quot;table&quot;.</p>
</td></tr>
<tr><td><code id="HWE.test_+3A_...">...</code></td>
<td>
<p> optional parameters passed to <code>HWE.test</code> (data.frame
method) or <code>chisq.test</code> (base method).</p>
</td></tr>
<tr><td><code id="HWE.test_+3A_do.allele.freq">do.Allele.Freq</code></td>
<td>
<p>logicial indication whether to summarize allele
frequencies.</p>
</td></tr>
<tr><td><code id="HWE.test_+3A_do.hwe.test">do.HWE.test</code></td>
<td>
<p>logicial indication whether to perform HWE tests</p>
</td></tr>
</table>


<h3>Details</h3>

<p>HWE.test calls <code><a href="#topic+diseq">diseq</a></code> to computes the Hardy-Weinberg
(dis)equilibrium statistics D, D', and r (correlation coefficient).
Next it calls <code><a href="#topic+diseq.ci">diseq.ci</a></code> to compute a bootstrap confidence
interval for these estimates.  Finally, it calls
<code><a href="stats.html#topic+chisq.test">chisq.test</a></code> to compute a p-value for Hardy-Weinberg
Equilibrium using a simulation/permutation method.
</p>
<p>Using bootstrapping for the confidence interval and simulation for the
p-value avoids reliance on the assumptions the underlying Chi-square
approximation.  This is particularly important when some allele pairs
have small counts.
</p>
<p>For details on the definition of D, D', and r, see the help page for
<code><a href="#topic+diseq">diseq</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>HWE.test</code> with components
</p>
<table>
<tr><td><code>diseq</code></td>
<td>
<p>A <code><a href="#topic+diseq">diseq</a></code> object providing details on the
disequilibrium estimates.</p>
</td></tr>
<tr><td><code>ci</code></td>
<td>
<p>A <code><a href="#topic+diseq.ci">diseq.ci</a></code> object providing details on the
bootstrap confidence intervals for the disequilibrium estimates.</p>
</td></tr>
<tr><td><code>test</code></td>
<td>
<p>A <code>htest</code> object providing details on the
permutation based Chi-square test.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>function call used to creat this object.</p>
</td></tr>
<tr><td><code>conf</code>, <code>B</code>, <code>ci.B</code>, <code>simulate.p.value</code></td>
<td>
<p>values used for these arguments.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Gregory R. Warnes <a href="mailto:greg@warnes.net">greg@warnes.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genotype">genotype</a></code>,
<code><a href="#topic+diseq">diseq</a></code>,
<code><a href="#topic+diseq.ci">diseq.ci</a></code>,
<code><a href="#topic+HWE.chisq">HWE.chisq</a></code>,
<code><a href="#topic+HWE.exact">HWE.exact</a></code>,
<code><a href="stats.html#topic+chisq.test">chisq.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Marker with two alleles:
example.data   &lt;- c("D/D","D/I","D/D","I/I","D/D",
                    "D/D","D/D","D/D","I/I","")
g1  &lt;- genotype(example.data)
g1

HWE.test(g1)

## Compare with individual calculations:
diseq(g1)
diseq.ci(g1)
HWE.chisq(g1)
HWE.exact(g1)


## Marker with three alleles: A, C, and T
three.data   &lt;- c(rep("A/A",16),
                  rep("C/A",40),
                  rep("C/T",40),
                  rep("C/C",20),
                  rep("T/T",6))

g3  &lt;- genotype(three.data)
g3

HWE.test(g3, ci.B=10000)
</code></pre>

<hr>
<h2 id='LD'>Pairwise linkage disequilibrium between genetic markers.</h2><span id='topic+LD'></span><span id='topic+LD.genotype'></span><span id='topic+LD.data.frame'></span>

<h3>Description</h3>

<p>Compute pairwise linkage disequilibrium between genetic markers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LD(g1, ...)
## S3 method for class 'genotype'
LD(g1,g2,...)
## S3 method for class 'data.frame'
LD(g1,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LD_+3A_g1">g1</code></td>
<td>
<p> genotype object or dataframe containing genotype objects </p>
</td></tr>
<tr><td><code id="LD_+3A_g2">g2</code></td>
<td>
<p> genotype object (ignored if g1 is a dataframe) </p>
</td></tr>
<tr><td><code id="LD_+3A_...">...</code></td>
<td>
<p> optional arguments (ignored) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Linkage disequilibrium (LD) is the non-random association of
marker alleles and can arise from marker proximity or from selection
bias.
</p>
<p><code>LD.genotype</code> estimates the extent of LD for a single pair of
genotypes.  <code>LD.data.frame</code> computes LD for all pairs of
genotypes contained in a data frame.  Before starting,
<code>LD.data.frame</code> checks the class and number of alleles of each
variable in the dataframe.  If the data frame contains non-genotype
objects or genotypes with more or less than 2 alleles, these will be
omitted from the computation and a warning will be generated.
</p>
<p>Three estimators of LD are computed:
</p>

<ul>
<li><p>D raw difference in frequency between the
observed number of AB pairs and the expected number:
</p>
<p style="text-align: center;"><code class="reqn">%
 	D = p_{AB} - p_A p_B %
      </code>
</p>


</li>
<li><p>D' scaled D spanning the range [-1,1] 
</p>
<p style="text-align: center;"><code class="reqn">D' = \frac{D}{D_{max} } </code>
</p>

<p>where, if D &gt; 0:
</p>
<p style="text-align: center;"><code class="reqn">%
  	D_{max} = \min( p_A p_b, p_a p_B )  %
      </code>
</p>
 
<p>or if D &lt; 0:
</p>
<p style="text-align: center;"><code class="reqn">%
  	D_{max} = \max{ -p_A p_B, -p_a p_b }  %
      </code>
</p>


</li>
<li><p>r correlation coefficient between the markers
</p>
<p style="text-align: center;"><code class="reqn">%
 	r = \frac{-D}{\sqrt( p_A * p_a * p_B * p_b  )} %
      </code>
</p>


</li></ul>

<p>where
</p>

<ul>
<li><p>- <code class="reqn">p_A</code> is defined as the observed probability of
allele 'A' for marker 1, 
</p>
</li>
<li><p>- <code class="reqn">p_a=1-p_A</code> is defined as the observed probability of
allele 'a' for marker 1, 
</p>
</li>
<li><p>-<code class="reqn">p_B</code> is defined as the observed probability of
allele 'B' for marker 2, and 
</p>
</li>
<li><p>-<code class="reqn">p_b=1-p_B</code> is defined as the observed probability of
allele 'b' for marker 2, and 
</p>
</li>
<li><p>-<code class="reqn">p_{AB}</code> is defined as the probability of
the marker allele pair 'AB'. 
</p>
</li></ul>

<p>For genotype data, AB/ab cannot be distinguished from
aB/Ab. Consequently, we estimate <code class="reqn">p_{AB}</code> using maximum
likelihood and use this value in the computations.
</p>


<h3>Value</h3>

<p><code>LD.genotype</code> returns a 5 element list:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>Linkage disequilibrium estimate</p>
</td></tr>
<tr><td><code>Dprime</code></td>
<td>
<p>Scaled linkage disequilibrium estimate</p>
</td></tr>
<tr><td><code>corr</code></td>
<td>
<p>Correlation coefficient</p>
</td></tr> 
<tr><td><code>nobs</code></td>
<td>
<p>Number of observations</p>
</td></tr>
<tr><td><code>chisq</code></td>
<td>
<p>Chi-square statistic for linkage
equilibrium (i.e., D=D'=corr=0)</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>Chi-square p-value for marker independence</p>
</td></tr>
</table>
<p><code>LD.data.frame</code> returns a list with the same elements, but each
element is a matrix where the upper off-diagonal elements contain the
estimate for the corresponding pair of markers.  The other matrix
elements are <code>NA</code>.
</p>


<h3>Author(s)</h3>

<p> Gregory R. Warnes <a href="mailto:greg@warnes.net">greg@warnes.net</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+genotype">genotype</a></code>, <code><a href="#topic+HWE.test">HWE.test</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>
g1 &lt;- genotype( c('T/A',    NA, 'T/T',    NA, 'T/A',    NA, 'T/T', 'T/A',
                  'T/T', 'T/T', 'T/A', 'A/A', 'T/T', 'T/A', 'T/A', 'T/T',
                     NA, 'T/A', 'T/A',   NA) )

g2 &lt;- genotype( c('C/A', 'C/A', 'C/C', 'C/A', 'C/C', 'C/A', 'C/A', 'C/A',
                  'C/A', 'C/C', 'C/A', 'A/A', 'C/A', 'A/A', 'C/A', 'C/C',
                  'C/A', 'C/A', 'C/A', 'A/A') )


g3 &lt;- genotype( c('T/A', 'T/A', 'T/T', 'T/A', 'T/T', 'T/A', 'T/A', 'T/A',
                  'T/A', 'T/T', 'T/A', 'T/T', 'T/A', 'T/A', 'T/A', 'T/T',
                  'T/A', 'T/A', 'T/A', 'T/T') )

# Compute LD on a single pair

LD(g1,g2)

# Compute LD table for all 3 genotypes

data &lt;- makeGenotypes(data.frame(g1,g2,g3))
LD(data)
</code></pre>

<hr>
<h2 id='locus'> Create and Manipulate Locus, Gene, and Marker Objects</h2><span id='topic+locus'></span><span id='topic+gene'></span><span id='topic+marker'></span><span id='topic+is.gene'></span><span id='topic+is.locus'></span><span id='topic+is.marker'></span><span id='topic+print.gene'></span><span id='topic+print.locus'></span><span id='topic+print.marker'></span><span id='topic+as.character.locus'></span><span id='topic+as.character.gene'></span><span id='topic+as.character.marker'></span><span id='topic+getlocus'></span><span id='topic+getmarker'></span><span id='topic+getgene'></span><span id='topic+locus+3C-'></span><span id='topic+marker+3C-'></span><span id='topic+gene+3C-'></span>

<h3>Description</h3>

<p><code>locus</code>, <code>gene</code>, and <code>marker</code> create objects to store
information, respectively, about genetic loci, genes, and markers.
</p>
<p><code>is.locus</code>, <code>is.gene</code>, and <code>ismarker</code> test whether an
object is a member of the respective class.
</p>
<p><code>as.character.locus</code>, <code>as.character.gene</code>,
<code>as.character.marker</code> return a character string containing a
compact encoding the object.
</p>
<p><code>getlocus</code>, <code>getgene</code>, <code>getmarker</code> extract locus data
(if present) from another object.
</p>
<p><code>locus&lt;-</code>, <code>marker&lt;-</code>, and <code>gene&lt;-</code> adds locus data to
an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  locus(name, chromosome, arm=c("p", "q", "long", "short", NA),
        index.start, index.end=NULL)

  gene(name, chromosome, arm=c("p", "q", "long", "short"),
       index.start, index.end=NULL)

  marker(name, type, locus.name, bp.start, bp.end = NULL,
         relative.to = NULL, ...)

  is.locus(x)

  is.gene(x)

  is.marker(x)

  ## S3 method for class 'locus'
as.character(x, ...)

  ## S3 method for class 'gene'
as.character(x, ...)

  ## S3 method for class 'marker'
as.character(x, ...)

  getlocus(x, ...)

  locus(x) &lt;- value

  marker(x) &lt;- value

  gene(x) &lt;- value

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="locus_+3A_name">name</code></td>
<td>
<p>character string giving locus, gene, or marker name</p>
</td></tr>
<tr><td><code id="locus_+3A_chromosome">chromosome</code></td>
<td>
<p>integer specifying chromosome number (1:23 for humans).</p>
</td></tr>
<tr><td><code id="locus_+3A_arm">arm</code></td>
<td>
<p>character indicating long or short arm of the chromosome.
Long is be specified by &quot;long&quot; or &quot;p&quot;.  Short is specified by
&quot;short&quot; or &quot;q&quot;.</p>
</td></tr>
<tr><td><code id="locus_+3A_index.start">index.start</code></td>
<td>
<p>integer specifying location of start of locus or
gene on the chromosome.  </p>
</td></tr>
<tr><td><code id="locus_+3A_index.end">index.end</code></td>
<td>
<p>optional integer specifying location of end of locus or
gene on the chromosome.  </p>
</td></tr>
<tr><td><code id="locus_+3A_type">type</code></td>
<td>
<p>character string indicating marker type, e.g. &quot;SNP&quot;</p>
</td></tr>
<tr><td><code id="locus_+3A_locus.name">locus.name</code></td>
<td>
<p>either a character string giving the name of the
locus or gene (other details may be specified using <code>...</code>) or a
<code>locus</code> or <code>gene</code> object.</p>
</td></tr>
<tr><td><code id="locus_+3A_bp.start">bp.start</code></td>
<td>
<p>start location of marker, in base pairs</p>
</td></tr>
<tr><td><code id="locus_+3A_bp.end">bp.end</code></td>
<td>
<p>end location of marker, in base pairs (optional)</p>
</td></tr>
<tr><td><code id="locus_+3A_relative.to">relative.to</code></td>
<td>
<p>location (optional) from which <code>bp.start</code> and
<code>bp.end</code> are calculated. </p>
</td></tr>
<tr><td><code id="locus_+3A_...">...</code></td>
<td>
<p>parameters for <code>locus</code> used to fill in additional
details on the locus or gene within which the marker is located. </p>
</td></tr>
<tr><td><code id="locus_+3A_x">x</code></td>
<td>
<p>an object of class <code>locus</code>, <code>gene</code>, or
<code>marker</code>, or (for <code>getlocus</code>, <code>locus&lt;-</code>,
<code>marker&lt;-</code>, and <code>gene&lt;-</code>) an object that may contain a locus
attribute or field, notably a <code>genotype</code> object.</p>
</td></tr>
<tr><td><code id="locus_+3A_value">value</code></td>
<td>
<p><code>locus</code>, <code>marker</code>, or <code>gene</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>locus</code> and <code>gene</code>are lists with the
elements:
</p>
<table>
<tr><td><code>name</code></td>
<td>
<p>character string giving locus, gene, or marker name</p>
</td></tr>
<tr><td><code>chromosome</code></td>
<td>
<p>integer specifying chromosome number (1:23 for humans).</p>
</td></tr>
<tr><td><code>arm</code></td>
<td>
<p>character indicating long or short arm of the chromosome.
Long is be specified by &quot;long&quot; or &quot;p&quot;.  Short is specified by
&quot;short&quot; or &quot;q&quot;.</p>
</td></tr>
<tr><td><code>index.start</code></td>
<td>
<p>integer specifying location of start of locus or
gene on the chromosome.  </p>
</td></tr>
<tr><td><code>index.end</code></td>
<td>
<p>optional integer specifying location of end of locus or
gene on the chromosome.  </p>
</td></tr>
</table>
<p>Objects of class <code>marker</code> add the additional fields:
</p>
<table>
<tr><td><code>marker.name</code></td>
<td>
<p>character string giving the name of the marker</p>
</td></tr>
<tr><td><code>bp.start</code></td>
<td>
<p>start location of marker, in base pairs</p>
</td></tr>
<tr><td><code>bp.end</code></td>
<td>
<p>end location of marker, in base pairs (optional)</p>
</td></tr>
<tr><td><code>relative.to</code></td>
<td>
<p>location (optional) from which <code>bp.start</code> and
<code>bp.end</code> are calculated. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gregory R. Warnes <a href="mailto:greg@warnes.net">greg@warnes.net</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+genotype">genotype</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ar2  &lt;- gene("AR2",chromosome=7,arm="q",index.start=35)
ar2

par  &lt;- locus(name="AR2 Psedogene",
              chromosome=1,
              arm="q",
              index.start=32,
              index.end=42)
par

c109t  &lt;- marker(name="C-109T",
                 type="SNP",
                 locus.name="AR2",
                 chromosome=7,
                 arm="q",
                 index.start=35,
                 bp.start=-109,
                 relative.to="start of coding region")
c109t

c109t  &lt;- marker(name="C-109T",
                 type="SNP",
                 locus=ar2,
                 bp.start=-109,
                 relative.to="start of coding region")
c109t




example.data   &lt;- c("D/D","D/I","D/D","I/I","D/D",
                    "D/D","D/D","D/D","I/I","")
g1  &lt;- genotype(example.data, locus=ar2)
g1

getlocus(g1)

summary(g1)
HWE.test(g1)

g2  &lt;- genotype(example.data, locus=c109t)
summary(g2)

getlocus(g2)

heterozygote(g2)
homozygote(g1)

allele(g1,1)

carrier(g1,"I")

heterozygote(g2)
</code></pre>

<hr>
<h2 id='makeGenotypes'>Convert columns in a dataframe to genotypes or haplotypes</h2><span id='topic+makeGenotypes'></span><span id='topic+makeHaplotypes'></span>

<h3>Description</h3>

 
<p>Convert columns in a dataframe to genotypes or haplotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeGenotypes(data, convert, sep = "/", tol = 0.5, ..., method=as.genotype)
makeHaplotypes(data, convert, sep = "/", tol = 0.9, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeGenotypes_+3A_data">data</code></td>
<td>
<p>Dataframe containing columns to be converted</p>
</td></tr>
<tr><td><code id="makeGenotypes_+3A_convert">convert</code></td>
<td>
<p>Vector or list of pairs specifying which columns
contain genotype/haplotype data.   See below for details.</p>
</td></tr>
<tr><td><code id="makeGenotypes_+3A_sep">sep</code></td>
<td>
<p>Genotype separator</p>
</td></tr>
<tr><td><code id="makeGenotypes_+3A_tol">tol</code></td>
<td>
<p>See below.</p>
</td></tr>
<tr><td><code id="makeGenotypes_+3A_...">...</code></td>
<td>
<p>Optional arguments to as.genotype function</p>
</td></tr>
<tr><td><code id="makeGenotypes_+3A_method">method</code></td>
<td>
<p>Function used to perform the conversion.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions makeGenotypes and makeHaplotypes allow the conversion of
all of the genetic variables in a dataset to genotypes or haplotypes
in a single step.
</p>
<p>The parameter <code>convert</code> may be missing, a vector of
column names, indexes or true/false indictators, or a list of column
name or index pairs.
</p>
<p>When the argument <code>convert</code> is not provided, the function will
look for columns where at least <code>tol</code>*100% of the records
contain the separator character <code>sep</code> ('/' by default).  These
columns will then be assumed to contain both of the genotype/haplotype
alleles and will be converted in-place to genotype variables.
</p>
<p>When the argument <code>convert</code> is a vector of column names, indexes
or true/false indictators, the corresponding columns will be assumed
to contain both of the genotype/haplotype alleles and will be
converted in-place to genotype variables.
</p>
<p>When the argument <code>convert</code> is a list containing column name or
index pairs, the two elements of each pair will be assumed to contain the
individual alleles of a genotype/haplotype.  The first column
specified in each pair will be replaced with the new
genotype/haplotype variable named <code>name1 + sep + name2</code>.  The
second column will be removed.
</p>
<p>Note that the <code>method</code> argument may be used to supply a
non-standard conversion function, such as
<code>as.genotype.allele.count</code>, which converts from [0,1,2] to
['A/A','A/B','A/C'] (or the specified allele names).  See the example
below.
</p>


<h3>Value</h3>

<p>Dataframe containing converted genotype/haplotype variables. All other
variables will be unchanged.
</p>


<h3>Author(s)</h3>

<p> Gregory R. Warnes <a href="mailto:greg@warnes.net">greg@warnes.net</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+genotype">genotype</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# common case
data &lt;- read.csv(file="genotype_data.csv")
data &lt;- makeGenotypes(data)

## End(Not run)

# Create a test data set where there are several genotypes in columns
# of the form "A/T".
test1 &lt;- data.frame(Tmt=sample(c("Control","Trt1","Trt2"),20, replace=TRUE),
                G1=sample(c("A/T","T/T","T/A",NA),20, replace=TRUE),
                N1=rnorm(20),
                I1=sample(1:100,20,replace=TRUE),
                G2=paste(sample(c("134","138","140","142","146"),20,
                                replace=TRUE),
                         sample(c("134","138","140","142","146"),20,
                                replace=TRUE),
                         sep=" / "),
                G3=sample(c("A /T","T /T","T /A"),20, replace=TRUE),
                comment=sample(c("Possible Bad Data/Lab Error",""),20,
                               rep=TRUE)
                )
test1

# now automatically convert genotype columns
geno1 &lt;- makeGenotypes(test1)
geno1

# Create a test data set where there are several haplotypes with alleles
# in adjacent columns.
test2 &lt;- data.frame(Tmt=sample(c("Control","Trt1","Trt2"),20, replace=TRUE),
                    G1.1=sample(c("A","T",NA),20, replace=TRUE),
                    G1.2=sample(c("A","T",NA),20, replace=TRUE),
                    N1=rnorm(20),
                    I1=sample(1:100,20,replace=TRUE),
                    G2.1=sample(c("134","138","140","142","146"),20,
                                replace=TRUE),
                    G2.2=sample(c("134","138","140","142","146"),20,
                                replace=TRUE),
                    G3.1=sample(c("A ","T ","T "),20, replace=TRUE),
                    G3.2=sample(c("A ","T ","T "),20, replace=TRUE),
                    comment=sample(c("Possible Bad Data/Lab Error",""),20,
                                   rep=TRUE)
                   ) 
test2

# specifly the locations of the columns to be paired for haplotypes
makeHaplotypes(test2, convert=list(c("G1.1","G1.2"),6:7,8:9))

# Create a test data set where the data is coded as numeric allele
# counts (0-2).
test3 &lt;- data.frame(Tmt=sample(c("Control","Trt1","Trt2"),20, replace=TRUE),
                    G1=sample(c(0:2,NA),20, replace=TRUE),
                    N1=rnorm(20),
                    I1=sample(1:100,20,replace=TRUE),
                    G2=sample(0:2,20, replace=TRUE),
                    comment=sample(c("Possible Bad Data/Lab Error",""),20,
                                   rep=TRUE)
                   ) 
test3

# specifly the locations of the columns, and a non-standard conversion
makeGenotypes(test3, convert=c('G1','G2'), method=as.genotype.allele.count)


</code></pre>

<hr>
<h2 id='order.genotype'>Order/sort genotype/haplotype object</h2><span id='topic+order'></span><span id='topic+order.genotype'></span><span id='topic+sort.genotype'></span><span id='topic+genotypeOrder'></span><span id='topic+genotypeOrder+3C-'></span>

<h3>Description</h3>

<p>Order/sort genotype or haplotype object according
to order of allele names or genotypes</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'genotype'
order(..., na.last=TRUE, decreasing=FALSE,
  alleleOrder=allele.names(x), genotypeOrder=NULL)

## S3 method for class 'genotype'
sort(x, decreasing=FALSE, na.last=NA, ...,
  alleleOrder=allele.names(x), genotypeOrder=NULL)

genotypeOrder(x)
genotypeOrder(x) &lt;- value

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="order.genotype_+3A_...">...</code></td>
<td>
<p>genotype or haplotype in <code>order</code> method; not used
for <code>sort</code> method</p>
</td></tr>
<tr><td><code id="order.genotype_+3A_x">x</code></td>
<td>
<p>genotype or haplotype in <code>sort</code> method</p>
</td></tr>
<tr><td><code id="order.genotype_+3A_na.last">na.last</code></td>
<td>
<p>as in default <code><a href="#topic+order">order</a></code> or <code><a href="base.html#topic+sort">sort</a></code></p>
</td></tr>
<tr><td><code id="order.genotype_+3A_decreasing">decreasing</code></td>
<td>
<p>as in default <code><a href="#topic+order">order</a></code> or <code><a href="base.html#topic+sort">sort</a></code></p>
</td></tr>
<tr><td><code id="order.genotype_+3A_alleleorder">alleleOrder</code></td>
<td>
<p>character, vector of allele names in wanted order</p>
</td></tr>
<tr><td><code id="order.genotype_+3A_genotypeorder">genotypeOrder</code></td>
<td>
<p>character, vector of genotype/haplotype names in
wanted order</p>
</td></tr>
<tr><td><code id="order.genotype_+3A_value">value</code></td>
<td>
<p>the same as in argument <code>order.genotype</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument <code>genotypeOrder</code> can be usefull, when you want that some
genotypes appear &quot;together&quot;, whereas they are not &quot;together&quot; by allele
order.
</p>
<p>Both methods (<code>order</code> and <code>sort</code>) work with genotype and
haplotype classes.
</p>
<p>If <code>alleleOrder</code> is given, <code>genotypeOrder</code> has no effect.
</p>
<p>Genotypes/haplotypes, with missing alleles in <code>alleleOrder</code> are
treated as <code>NA</code> and ordered according to <code><a href="#topic+order">order</a></code>
arguments related to <code>NA</code> values. In such cases a warning is issued
(&quot;Found data values not matching specified alleles. Converting to NA.&quot;)
and can be safely ignored. Genotypes present in <code>x</code>, but not
specified in <code>genotypeOrder</code>, are also treated as <code>NA</code>.
</p>
<p>Value of <code>genotypeOrder</code> such as &quot;B/A&quot; matches also &quot;A/B&quot; in case
of genotypes.
</p>
<p>Only unique values in argument <code>alleleOrder</code> or
<code>genotypeOrder</code> are used i.e. first occurrence prevails.
</p>


<h3>Value</h3>

<p>The same as in <code>order</code> or <code>sort</code></p>


<h3>Author(s)</h3>

<p>Gregor Gorjanc</p>


<h3>See Also</h3>

<p><code><a href="#topic+genotype">genotype</a></code>,
<code><a href="#topic+allele.names">allele.names</a></code>,
<code><a href="#topic+order">order</a></code>, and
<code><a href="base.html#topic+sort">sort</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- c("C/C", "A/C", "A/A", NA, "C/B", "B/A", "B/B", "B/C", "A/C")
  alleles &lt;- c("A", "B", "C")

  g &lt;- genotype(x, alleles=alleles, reorder="yes")
  ## "C/C" "A/C" "A/A" NA    "B/C" "A/B" "B/B" "B/C" "A/C"

  h &lt;- haplotype(x, alleles=alleles)
  ## "C/C" "A/C" "A/A" NA    "C/B" "B/A" "B/B" "B/C" "A/C"

  ## --- Standard usage ---

  sort(g)
  ## "A/A" "A/B" "A/C" "A/C" "B/B" "B/C" "B/C" "C/C" NA

  sort(h)
  ## "A/A" "A/C" "A/C" "B/A" "B/B" "B/C" "C/B" "C/C" NA

  ## --- Reversed order of alleles ---

  sort(g, alleleOrder=c("B", "C", "A"))
  ## "B/B" "B/C" "B/C" "A/B" "C/C" "A/C" "A/C" "A/A" NA
  ## note that A/B comes after B/C since it is treated as B/A;
  ## order of alleles (not in alleleOrder!) does not matter for a genotype

  sort(h, alleleOrder=c("B", "C", "A"))
  ## "B/B" "B/C" "B/A" "C/B" "C/C" "A/C" "A/C" "A/A" NA

  ## --- Missing allele(s) in alleleOrder ---

  sort(g, alleleOrder=c("B", "C"))
  ## "B/B" "B/C" "B/C" "C/C" "A/C" "A/A" NA    "A/B" "A/C"

  sort(g, alleleOrder=c("B"))
  ## "B/B" "C/C" "A/C" "A/A" NA    "B/C" "A/B" "B/C" "A/C"
  ## genotypes with missing allele are treated as NA

  sort(h, alleleOrder=c("B", "C"))
  ## "B/B" "B/C" "C/B" "C/C" "A/C" "A/A" NA    "B/A" "A/C"

  sort(h, alleleOrder=c("B"))
  ## "B/B" "C/C" "A/C" "A/A" NA    "C/B" "B/A" "B/C" "A/C"

  ## --- Use of genotypeOrder ---

  sort(g, genotypeOrder=c("A/A", "C/C", "B/B", "A/B", "A/C", "B/C"))
  ## "A/A" "C/C" "B/B" "A/B" "A/C" "A/C" "B/C" "B/C" NA

  sort(h, genotypeOrder=c("A/A", "C/C", "B/B",
                          "A/C", "C/B", "B/A", "B/C"))
  ## "A/A" "C/C" "B/B" "A/C" "A/C" "C/B" "B/A" "B/C" NA

  ## --- Missing genotype(s) in genotypeOrder ---

  sort(g, genotypeOrder=c(       "C/C",        "A/B", "A/C", "B/C"))
  ## "C/C" "A/B" "A/C" "A/C" "B/C" "B/C" "A/A" NA    "B/B"

  sort(h, genotypeOrder=c(       "C/C",        "A/B", "A/C", "B/C"))
  ## "C/C" "A/C" "A/C" "B/C" "A/A" NA    "C/B" "B/A" "B/B"
</code></pre>

<hr>
<h2 id='plot.genotype'>Plot genotype object</h2><span id='topic+plot.genotype'></span>

<h3>Description</h3>

<p><code>plot.genotype</code> can plot genotype or allele frequency of a genotype
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'genotype'
plot(x, type=c("genotype", "allele"),
  what=c("percentage", "number"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.genotype_+3A_x">x</code></td>
<td>
<p>genotype object, as genotype.</p>
</td></tr>
<tr><td><code id="plot.genotype_+3A_type">type</code></td>
<td>
<p>plot &quot;genotype&quot; or &quot;allele&quot; frequency, as character.</p>
</td></tr>
<tr><td><code id="plot.genotype_+3A_what">what</code></td>
<td>
<p>show &quot;percentage&quot; or &quot;number&quot;, as character</p>
</td></tr>
<tr><td><code id="plot.genotype_+3A_...">...</code></td>
<td>
<p>Optional arguments for <code>barplot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same as in <code>barplot</code>.
</p>


<h3>Author(s)</h3>

<p> Gregor Gorjanc </p>


<h3>See Also</h3>

 <p><code><a href="#topic+genotype">genotype</a></code>, <code><a href="graphics.html#topic+barplot">barplot</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  set &lt;- c("A/A", "A/B", "A/B", "B/B", "B/B", "B/B",
           "B/B", "B/C", "C/C", "C/C")
  set &lt;- genotype(set, alleles=c("A", "B", "C"), reorder="yes")
  plot(set)
  plot(set, type="allele", what="number")
</code></pre>

<hr>
<h2 id='print.LD'>Textual and graphical display of linkage disequilibrium (LD) objects</h2><span id='topic+print.LD'></span><span id='topic+print.LD.data.frame'></span><span id='topic+summary.LD.data.frame'></span><span id='topic+print.summary.LD.data.frame'></span><span id='topic+plot.LD.data.frame'></span><span id='topic+LDtable'></span><span id='topic+LDplot'></span>

<h3>Description</h3>

<p>Textual and graphical display of linkage disequilibrium (LD) objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'LD'
print(x, digits = getOption("digits"), ...)
## S3 method for class 'LD.data.frame'
print(x, ...)

## S3 method for class 'data.frame'
summary.LD(object, digits = getOption("digits"),
                      which = c("D", "D'", "r", "X^2", "P-value", "n", " "),
                      rowsep, show.all = FALSE, ...)
## S3 method for class 'summary.LD.data.frame'
print(x, digits = getOption("digits"), ...)

## S3 method for class 'LD.data.frame'
plot(x,digits=3, colorcut=c(0,0.01, 0.025, 0.5, 0.1, 1),
                   colors=heat.colors(length(colorcut)), textcol="black",
                   marker, which="D'", distance,  ...)


LDtable(x, colorcut=c(0,0.01, 0.025, 0.5, 0.1, 1),
        colors=heat.colors(length(colorcut)), textcol="black",
        digits=3, show.all=FALSE, which=c("D", "D'", "r", "X^2",
        "P-value", "n"), colorize="P-value", cex, ...)

LDplot(x, digits=3, marker, distance, which=c("D", "D'", "r", "X^2",
       "P-value", "n", " "), ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.LD_+3A_x">x</code>, <code id="print.LD_+3A_object">object</code></td>
<td>
<p>LD or LD.data.frame object</p>
</td></tr>
<tr><td><code id="print.LD_+3A_digits">digits</code></td>
<td>
<p>Number of significant digits to display</p>
</td></tr>
<tr><td><code id="print.LD_+3A_which">which</code></td>
<td>
<p>Name(s) of LD information items to be displayed</p>
</td></tr>
<tr><td><code id="print.LD_+3A_rowsep">rowsep</code></td>
<td>
<p>Separator between rows of data, use <code>NULL</code> for no
separator.</p>
</td></tr>
<tr><td><code id="print.LD_+3A_colorcut">colorcut</code></td>
<td>
<p>P-value cutoffs points for colorizing LDtable</p>
</td></tr>
<tr><td><code id="print.LD_+3A_colors">colors</code></td>
<td>
<p>Colors for each P-value cutoff given in <code>colorcut</code> for
LDtable</p>
</td></tr>
<tr><td><code id="print.LD_+3A_textcol">textcol</code></td>
<td>
<p>Color for text labels for LDtable</p>
</td></tr>
<tr><td><code id="print.LD_+3A_marker">marker</code></td>
<td>
<p>Marker used as 'comparator' on LDplot.  If
omitted separate lines for each marker will be displayed</p>
</td></tr>
<tr><td><code id="print.LD_+3A_distance">distance</code></td>
<td>
<p>Marker location, used for locating of markers on
LDplot.</p>
</td></tr>
<tr><td><code id="print.LD_+3A_show.all">show.all</code></td>
<td>
<p>If TRUE, show all rows/columns of matrix. Otherwise
omit completely blank rows/columns.</p>
</td></tr>
<tr><td><code id="print.LD_+3A_colorize">colorize</code></td>
<td>
<p>LD parameter used for determining table cell colors</p>
</td></tr>
<tr><td><code id="print.LD_+3A_cex">cex</code></td>
<td>
<p>Scaling factor for table text. If absent, text will be
scaled to fit within the table cells.</p>
</td></tr>
<tr><td><code id="print.LD_+3A_...">...</code></td>
<td>
<p>Optional arguments (<code>plot.LD.data.frame</code> passes
these to <code>LDtable</code> and <code>LDplot</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None.
</p>


<h3>Author(s)</h3>

<p> Gregory R. Warnes <a href="mailto:greg@warnes.net">greg@warnes.net</a> </p>


<h3>See Also</h3>

 <p><code>LD</code>, <code>genotype</code>, <code>HWE.test</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>

g1 &lt;- genotype( c('T/A',    NA, 'T/T',    NA, 'T/A',    NA, 'T/T', 'T/A',
                  'T/T', 'T/T', 'T/A', 'A/A', 'T/T', 'T/A', 'T/A', 'T/T',
                     NA, 'T/A', 'T/A',   NA) )

g2 &lt;- genotype( c('C/A', 'C/A', 'C/C', 'C/A', 'C/C', 'C/A', 'C/A', 'C/A',
                  'C/A', 'C/C', 'C/A', 'A/A', 'C/A', 'A/A', 'C/A', 'C/C',
                  'C/A', 'C/A', 'C/A', 'A/A') )


g3 &lt;- genotype( c('T/A', 'T/A', 'T/T', 'T/A', 'T/T', 'T/A', 'T/A', 'T/A',
                  'T/A', 'T/T', 'T/A', 'T/T', 'T/A', 'T/A', 'T/A', 'T/T',
                  'T/A', 'T/A', 'T/A', 'T/T') )
data &lt;- makeGenotypes(data.frame(g1,g2,g3))

# Compute &amp; display  LD for one marker pair
ld &lt;- LD(g1,g2)
print(ld)

# Compute LD table for all 3 genotypes
ldt &lt;- LD(data)

# display the results
print(ldt)                               # textual display
LDtable(ldt)                            # graphical color-coded table
LDplot(ldt, distance=c(124, 834, 927))  # LD plot vs distance

# more markers makes prettier plots!
data &lt;- list()
nobs &lt;- 1000
ngene &lt;- 20
s &lt;- seq(0,1,length=ngene)
a1 &lt;- a2 &lt;- matrix("", nrow=nobs, ncol=ngene)
for(i in 1:length(s) )
{

  rallele &lt;- function(p) sample( c("A","T"), 1, p=c(p, 1-p))

  if(i==1)
    {
      a1[,i] &lt;- sample( c("A","T"), 1000, p=c(0.5,0.5), replace=TRUE)
      a2[,i] &lt;- sample( c("A","T"), 1000, p=c(0.5,0.5), replace=TRUE)
    }
  else
    {
      p1 &lt;- pmax( pmin( 0.25 + s[i] * as.numeric(a1[,i-1]=="A"),1 ), 0 )
      p2 &lt;- pmax( pmin( 0.25 + s[i] * as.numeric(a2[,i-1]=="A"),1 ), 0 )
      a1[,i] &lt;- sapply(p1, rallele )
      a2[,i] &lt;- sapply(p2, rallele )
    }

  data[[paste("G",i,sep="")]] &lt;- genotype(a1[,i],a2[,i])
}
data &lt;- data.frame(data)
data &lt;- makeGenotypes(data)

ldt &lt;- LD(data)
plot(ldt, digits=2, marker=19) # do LDtable &amp; LDplot on in a single
                               # graphics window
</code></pre>

<hr>
<h2 id='summary.genotype'> Allele and Genotype Frequency from a Genotype or
Haplotype Object</h2><span id='topic+summary.genotype'></span><span id='topic+print.summary.genotype'></span>

<h3>Description</h3>

<p><code>summary.genotype</code> creates an object containing allele and
genotype frequency from a <code>genotype</code> or <code>haplotype</code>
object.  <code>print.summary.genotype</code> displays a
<code>summary.genotype</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'genotype'
summary(object, ..., maxsum)
  ## S3 method for class 'summary.genotype'
print(x,...,round=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.genotype_+3A_object">object</code>, <code id="summary.genotype_+3A_x">x</code></td>
<td>
<p> an object of class <code>genotype</code> or <code>haplotype</code> (for
<code>summary.genotype</code>) or an object of class
<code>summary.genotype</code> (for <code>print.summary.genotype</code>) </p>
</td></tr>
<tr><td><code id="summary.genotype_+3A_...">...</code></td>
<td>
<p> optional parameters.  Ignored by <code>summary.genotype</code>,
passed to <code>print.matrix</code> by <code>print.summary,genotype</code>.</p>
</td></tr>
<tr><td><code id="summary.genotype_+3A_maxsum">maxsum</code></td>
<td>
<p> specifying any value for the parameter
maxsum will cause <code>summary.genotype</code> to fall back to
<code>summary.factor</code>.</p>
</td></tr>
<tr><td><code id="summary.genotype_+3A_round">round</code></td>
<td>
<p> number of digits to use when displaying proportions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Specifying any value for the parameter <code>maxsum</code> will cause fallback
to <code>summary.factor</code>.  This is so that the function
<code>summary.dataframe</code> will give reasonable output when it contains a
genotype column.  (Hopefully we can figure out something better to do
in this case.)
</p>


<h3>Value</h3>

<p>The returned value of <code>summary.genotype</code> is an object of class
<code>summary.genotype</code> which
is a list with the following components:
</p>
<table>
<tr><td><code>locus</code></td>
<td>
<p>locus information field (if present) from <code>x</code></p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code>allele.names</code></td>
<td>
<p> vector of allele names </p>
</td></tr>
<tr><td><code>allele.freq</code></td>
<td>

<p>A two column matrix with one row for each allele, plus one row for
<code>NA</code> values (if present).  The first column, <code>Count</code>,
contains the frequency of the corresponding allele value.  The
second column, <code>Proportion</code>, contains the fraction of alleles
with the corresponding allele value.  Note each observation contains
two alleles, thus the <code>Count</code> field sums to twice the number of
observations.
</p>
</td></tr>
<tr><td><code>genotype.freq</code></td>
<td>

<p>A two column matrix with one row for each genotype, plus one row for
<code>NA</code> values (if present). The first column, <code>Count</code>, contains the
frequency of the corresponding genotype.  The second column,
<code>Proportion</code>, contains the fraction of genotypes with the
corresponding value.
</p>
</td></tr>
</table>
<p><code>print.summary.genotype</code> silently returns the object <code>x</code>.
</p>


<h3>Author(s)</h3>

<p> Gregory R. Warnes <a href="mailto:greg@warnes.net">greg@warnes.net</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+genotype">genotype</a></code>,
<code><a href="#topic+HWE.test">HWE.test</a></code>,
<code><a href="#topic+allele">allele</a></code>,
<code><a href="#topic+homozygote">homozygote</a></code>,
<code><a href="#topic+heterozygote">heterozygote</a></code>,
<code><a href="#topic+carrier">carrier</a></code>,
<code><a href="#topic+allele.count">allele.count</a></code>
<code><a href="#topic+locus">locus</a></code>
<code><a href="#topic+gene">gene</a></code>
<code><a href="#topic+marker">marker</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
example.data   &lt;- c("D/D","D/I","D/D","I/I","D/D",
                    "D/D","D/D","D/D","I/I","")
g1  &lt;- genotype(example.data)
g1

summary(g1)
</code></pre>

<hr>
<h2 id='undocumented'>Undocumented functions</h2><span id='topic+as.factor'></span><span id='topic+allele.count.2.genotype'></span><span id='topic+as.factor.allele.genotype'></span><span id='topic+as.factor.default'></span><span id='topic+as.factor.genotype'></span><span id='topic+shortsummary.genotype'></span><span id='topic+geno.as.array'></span><span id='topic+mknum'></span><span id='topic+hap'></span><span id='topic+hapshuffle'></span><span id='topic+hapenum'></span><span id='topic+hapfreq'></span><span id='topic+hapmcmc'></span><span id='topic+mourant'></span><span id='topic+hapambig'></span>

<h3>Description</h3>

<p>These functions are undocumented.  Some are internal and not intended
for direct use.  Some are not yet ready for end users.  Others simply
haven't been documented yet.
</p>


<h3>Author(s)</h3>

<p>Gregory R. Warnes</p>

<hr>
<h2 id='write.pop.file'>Create genetics data files</h2><span id='topic+write.pop.file'></span><span id='topic+write.pedigree.file'></span><span id='topic+write.marker.file'></span>

<h3>Description</h3>

<p><code>write.pop.file</code> creates a 'pop' data file, as used by the
GenePop (<a href="https://genepop.curtin.edu.au/">https://genepop.curtin.edu.au/</a>) and LinkDos
(<a href="https://genepop.curtin.edu.au/linkC.html">https://genepop.curtin.edu.au/linkC.html</a>) software
packages.
</p>
<p><code>write.pedigree.file</code> creates a 'pedigree' data file, as used
by the QTDT software package
(<a href="http://csg.sph.umich.edu//abecasis/QTDT/">http://csg.sph.umich.edu//abecasis/QTDT/</a>).
</p>
<p><code>write.marker.file</code> creates a 'marker' data file, as used by
the QTDT software package
(<a href="http://csg.sph.umich.edu//abecasis/QTDT/">http://csg.sph.umich.edu//abecasis/QTDT/</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.pop.file(data, file = "", digits = 2, description = "Data from R")
write.pedigree.file(data, family, pid, father, mother, sex,
                    file="pedigree.txt")
write.marker.file(data, location, file="marker.txt")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.pop.file_+3A_data">data</code></td>
<td>
<p>Data frame containing genotype objects to be exported</p>
</td></tr>
<tr><td><code id="write.pop.file_+3A_file">file</code></td>
<td>
<p>Output filename</p>
</td></tr>
<tr><td><code id="write.pop.file_+3A_digits">digits</code></td>
<td>
<p>Number of digits to use in numbering genotypes, either 2
or 3.</p>
</td></tr>
<tr><td><code id="write.pop.file_+3A_description">description</code></td>
<td>
<p>Description to use as the first line of the 'pop'
file.</p>
</td></tr>
<tr><td><code id="write.pop.file_+3A_family">family</code>, <code id="write.pop.file_+3A_pid">pid</code>, <code id="write.pop.file_+3A_father">father</code>, <code id="write.pop.file_+3A_mother">mother</code></td>
<td>
<p>Vector of family, individual,
father, and mother id's, respectively.</p>
</td></tr>
<tr><td><code id="write.pop.file_+3A_sex">sex</code></td>
<td>
<p>Vector giving the sex of the individual (1=Make, 2=Female)</p>
</td></tr>
<tr><td><code id="write.pop.file_+3A_location">location</code></td>
<td>
<p>Location of the marker relative to the gene of
interest, in base pairs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The format of 'Pop' files is documented at
<a href="https://genepop.curtin.edu.au/help_input.html">https://genepop.curtin.edu.au/help_input.html</a>, the format
of 'pedigree' files is documented at <a href="http://csg.sph.umich.edu/abecasis/GOLD/docs/pedigree.html">http://csg.sph.umich.edu/abecasis/GOLD/docs/pedigree.html</a> and the format of 'marker'
files is documented at
<a href="http://csg.sph.umich.edu/abecasis/GOLD/docs/map.html">http://csg.sph.umich.edu/abecasis/GOLD/docs/map.html</a>.
</p>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Author(s)</h3>

<p>Gregory R. Warnes <a href="mailto:greg@warnes.net">greg@warnes.net</a></p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+write.table">write.table</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  # TBA
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
