<!DOCTYPE html><html><head><title>Help for package supcluster</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {supcluster}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#beta.by.gene'><p>Utility to Associate the Value of <code class="reqn">\beta</code> with the Feature it is Assocated With</p></a></li>
<li><a href='#binaryLink'><p>Used with <code>supcluster</code> when the outcome data object is binary</p>
</a></li>
<li><a href='#binaryOutcome'><p>Simulates a binary model for use with <code>generate.cluster.data</code></p>
</a></li>
<li><a href='#compare.chains'><p>Compare Chains to Test Algorithm Coverage</p></a></li>
<li><a href='#concordmap'><p>Calculate the Frequency with which each Pair of Features are in the Same Cluster</p>
</a></li>
<li><a href='#coxLink'><p> Used with <code>supcluster</code> when the outcome data object is a censored survival variable.</p>
</a></li>
<li><a href='#gene_names'><p>Trauma Data for Supervised Clustering</p>
</a></li>
<li><a href='#generate.cluster.data'><p>Function to Generate Data According to the Supcluster Model</p>
</a></li>
<li><a href='#supcluster'><p>Clustering of Features Supervised by an Outcome</p>
</a></li>
<li><a href='#supcluster-package'>
<p>Supervised Cluster Anaysis</p></a></li>
<li><a href='#survivalOutcome'><p>Simulates a survival model for use with <code>generate.cluster.data</code></p>
</a></li>
<li><a href='#tab1'><p>Simulates Supcluster Function</p></a></li>
<li><a href='#trauma_data'><p>Trauma Data for Supervised Clustering</p>
</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Supervised Cluster Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-05-19</td>
</tr>
<tr>
<td>Author:</td>
<td>David A. Schoenfeld,
  Jesse Hsu</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David A. Schoenfeld &lt;dschoenfeld@mgh.harvard.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Clusters features under the assumption that each cluster has a
 random effect and there is an outcome variable that is related to the random 
 effects by a linear regression. In this way the cluster analysis is 
 &ldquo;supervised&rdquo; by the outcome variable. An alternate specification is that 
 features in each cluster have the same compound symmetric normal distribution, 
 and the conditional distribution of the outcome given the features
 has the same coefficient for each feature in a cluster. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>mvtnorm, gtools</td>
</tr>
<tr>
<td>Collate:</td>
<td>'supcluster.R' 'concordmap.R' 'generate.cluster.data.R'
'tab1.R' 'binary_link.R'</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-19 14:33:17 UTC; das15</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-19 14:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='beta.by.gene'>Utility to Associate the Value of <code class="reqn">\beta</code> with the Feature it is Assocated With</h2><span id='topic+beta.by.gene'></span>

<h3>Description</h3>

<p>The model associates the coefficients of the random effects with the cluster number. However the cluster numbers are not unique. This utility associates the coefficient with gene that is in the  cluster, for each cluster number.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta.by.gene(supcluster.list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beta.by.gene_+3A_supcluster.list">supcluster.list</code></td>
<td>
<p> The output of <code>supcluster</code>

</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix is returned with dimensions, the number of MCMC iterations by the number of genes/features +1. The first column is the chain number and the remain columns are the beta value for each of the gene/features</p>


<h3>Author(s)</h3>

<p>David A. Schoenfeld, Jessie Hsu

</p>


<h3>References</h3>

<p> Added latter

</p>


<h3>See Also</h3>

<p><code><a href="#topic+supcluster">supcluster</a></code>,,<code><a href="#topic+compare.chains">compare.chains</a></code>,<code><a href="#topic+concordmap">concordmap</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>dat=generate.cluster.data(1)[[1]]
us=supcluster(dat,outcome="outcome",features=1:50,maxclusters=6,nstart=20,n=40)
vs=beta.by.gene(us)
colMeans(vs[,2:7])
</code></pre>

<hr>
<h2 id='binaryLink'>Used with <code><a href="#topic+supcluster">supcluster</a></code> when the outcome data object is binary

</h2><span id='topic+binaryLink'></span>

<h3>Description</h3>

<p> Calculates the log-likelihood for a logistic model with log-odds <code class="reqn">\mu+x</code> where <code class="reqn">x</code> is a frailty

</p>


<h3>Usage</h3>

<pre><code class='language-R'>binaryLink(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binaryLink_+3A_x">x</code></td>
<td>
<p> A vector of binary data with values of 0 and 1 or <code>TRUE</code>, <code>FALSE</code>

</p>
</td></tr>
</table>


<h3>Value</h3>

<p> A function that given a vector of frialties followed by a value of <code class="reqn">\mu</code> calculates the log-likelihood





</p>


<h3>Author(s)</h3>

<p>David Alan Schoenfeld

</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Note the number of iterations is small to control run time
generatedData=generate.cluster.data(.25,npats=25,clusts=c(12,8),beta=c(-5,5),
                                    outcomeModel=binaryOutcome(0))
usBinary=supcluster(generatedData[[1]],outcome="outcome",
maxclusters=5,nstart=100,n=200,fbeta=FALSE,
linkLikelihood=binaryLink(generatedData[[2]]))
## The function is currently defined as
function (x) 
{
    m = length(x)
    outfcn = function(parm2) {
        bx = parm2[m + 1] + parm2[1:m]
        loglik = sum(x * bx) - sum(log(1 + exp(bx)))
        return(loglik)
    }
    return(outfcn)
  }
</code></pre>

<hr>
<h2 id='binaryOutcome'>Simulates a binary model for use with <code><a href="#topic+generate.cluster.data">generate.cluster.data</a></code>

</h2><span id='topic+binaryOutcome'></span>

<h3>Description</h3>

<p>Given a vector of frailties, say <code class="reqn">x_1,...</code> it creates a binary variable from a logistic model with log odds ratio <code class="reqn">\mu + x</code> 

</p>


<h3>Usage</h3>

<pre><code class='language-R'>binaryOutcome(mu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binaryOutcome_+3A_mu">mu</code></td>
<td>
<p> Constant term <code class="reqn">\mu </code>

</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of binary variables.





</p>


<h3>Author(s)</h3>

<p>David A. Schoenfeld

</p>


<h3>Examples</h3>

<pre><code class='language-R'>generatedData=generate.cluster.data(.25,npats=25,clusts=c(12,8),beta=c(-5,5),
                                    outcomeModel=binaryOutcome(0))
## The function is currently defined as
function (mu) 
{
    outpt = function(x) {
        m = length(x)
        p = exp(mu + x)/(1 + exp(mu + x))
        return(rbinom(m, 1, p))
    }
    return(outpt)
  }
</code></pre>

<hr>
<h2 id='compare.chains'>Compare Chains to Test Algorithm Coverage
</h2><span id='topic+compare.chains'></span>

<h3>Description</h3>

<p>Suppose say 4 chains are run, then the first two and the last two are combined 
and a concord map of each is calculated, for each pair of genes in the concord map the proportion of times these genes are in the same cluster are calculated for each set of chains.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare.chains(supcluster.list,chains1,chains2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare.chains_+3A_supcluster.list">supcluster.list</code></td>
<td>
<p> The output of <code>supcluster</code>

</p>
</td></tr>
<tr><td><code id="compare.chains_+3A_chains1">chains1</code></td>
<td>
<p>The first vector of the chains to be compared</p>
</td></tr>
<tr><td><code id="compare.chains_+3A_chains2">chains2</code></td>
<td>
<p>The second vector of chains to be compared</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A N(N-1)/2 by 4 matrix is returned. The first two columns are each pair of genes and the next two are the proportion of times that each where in the same cluster in group of chains indicted by chain1 and chain2</p>


<h3>Author(s)</h3>

<p>David A. Schoenfeld, Jessie Hsu

</p>


<h3>See Also</h3>

<p><code><a href="#topic+supcluster">supcluster</a></code>,<code><a href="#topic+compare.chains">compare.chains</a></code>,
<code><a href="#topic+beta.by.gene">beta.by.gene</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.
#NOTE: only a small number of MCMC iterations are done due to time constraints

dat=generate.cluster.data(.2,npats=40,clusts=c(12,8,5),
                sig=1,gamma=1,beta=c(-5,0,6))[[1]]
us=supcluster(dat,outcome="outcome",features=1:25,maxclusters=4,nstart=20,n=40,nchains=2) 
ts1=compare.chains(us,chains1=1,chains2=2)
#plot of one chain verses another
plot(ts1[,3],ts1[,4])

</code></pre>

<hr>
<h2 id='concordmap'>Calculate the Frequency with which each Pair of Features are in the Same Cluster

</h2><span id='topic+concordmap'></span>

<h3>Description</h3>

<p>Label switching is a problem in interpreting the results of a cluster analysis that uses MCMC. Two clusterings may be the same but the labels of the clusters may change. In order to avoid this problem we create a square matrix with length and width equal to the number of features. The i,jth element is the proportion of times feature i and j are in the same cluster. A sorting algorythm puts the genes that are clustered together next to each other.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>concordmap(supcluster.list, chains=1, sort.genes = FALSE,criteria=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="concordmap_+3A_supcluster.list">supcluster.list</code></td>
<td>
<p> The output of <code>supcluster</code></p>
</td></tr>
<tr><td><code id="concordmap_+3A_chains">chains</code></td>
<td>
<p>The chains to use in the clustering</p>
</td></tr>
<tr><td><code id="concordmap_+3A_sort.genes">sort.genes</code></td>
<td>
<p>If <code>TRUE</code> Genes that associated are put next to each other</p>
</td></tr>
<tr><td><code id="concordmap_+3A_criteria">criteria</code></td>
<td>
<p>Two genes are in the same cluster when the probability that they are in the same
cluster is greater or equal to the criteria.</p>
</td></tr>

</table>


<h3>Value</h3>

<p>If sort.genes=TRUE a three element list, the first element is a m x m matrix where m is the number of features and the second element is the ordering created by sorting algorythm that this matrix is in. The final element is the cluster membership for each of the genes.  
If sort genes=FALSE only the m x m matrix is returned.





</p>


<h3>Author(s)</h3>

<p>David A. Schoenfeld, Jessie Hsu

</p>


<h3>See Also</h3>

<p><code><a href="#topic+supcluster">supcluster</a></code>,,<code><a href="#topic+compare.chains">compare.chains</a></code>,<code><a href="#topic+beta.by.gene">beta.by.gene</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.
#NOTE: only a small number of MCMC iterations are done due to time constraints
dat=generate.cluster.data(.2,npats=40,clusts=c(12,8,5),
                sig=1,gamma=1,beta=c(-5,0,6))[[1]]
us=supcluster(dat,outcome="outcome",features=1:25,maxclusters=4,nstart=20,n=40,nchains=2)
ts1=concordmap(us,chains=1)
#plot of the concord map
image(1:25,1:25,ts1$map)

</code></pre>

<hr>
<h2 id='coxLink'> Used with <code><a href="#topic+supcluster">supcluster</a></code> when the outcome data object is a censored survival variable.

</h2><span id='topic+coxLink'></span>

<h3>Description</h3>

<p>Calculates the log-partial likelihood for a proportional hazards model with log-hazard <code class="reqn">\mu+\beta x</code> where <code class="reqn">x</code> is a frailty

</p>


<h3>Usage</h3>

<pre><code class='language-R'>coxLink(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coxLink_+3A_data">data</code></td>
<td>
<p> A two variable data frame where the first variable is the survival time and the second
variable is a censoring indicator 1-event happened 0-censored

</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David A. Schoenfeld

</p>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.
generatedData=generate.cluster.data(.25,npats=25,clusts=c(12,8),beta=c(-5,5),
                                    outcomeModel=survivalOutcome(0,1,1,1))
usBinary=supcluster(generatedData[[1]],outcome="outcome",
maxclusters=5,nstart=100,n=200,fbeta=FALSE,
linkLikelihood=coxLink(generatedData[[2]]))
</code></pre>

<hr>
<h2 id='gene_names'>Trauma Data for Supervised Clustering

</h2><span id='topic+gene_names'></span>

<h3>Description</h3>

<p>The data in <code>gene_names</code> is information on each gene in <code>trauma_data</code>
</p>


<h3>Format</h3>


<dl>
<dt><code>Gene.number</code></dt><dd><p>The number of the gene in the trauma.data set</p>
</dd>
<dt><code>Probeset</code></dt><dd><p>The Affymetrix probeset code</p>
</dd>
<dt><code>Gene.symbol.and.name</code></dt><dd><p>The annotation of the probeset</p>
</dd>
<dt><code>Gene.sympbol</code></dt><dd><p>The gene symbol</p>
</dd>
</dl>



<h3>Source</h3>

<p> To be added from Glue grant
https://imcc.mgh.harvard.edu/GlueGrant/trdb.html#nutshell
</p>


<h3>References</h3>

 
<p>Tompkins, Ronald G. &quot;Genomics of injury: the Glue Grant experience.&quot; The journal of trauma and acute care surgery 78.4 (2015): 671.
</p>

<hr>
<h2 id='generate.cluster.data'>Function to Generate Data According to the Supcluster Model

</h2><span id='topic+generate.cluster.data'></span>

<h3>Description</h3>

<p>Generates cluster data according to the used for supervised clustering

</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate.cluster.data(ratio,npats=80,clusts=c(12,8,12,12,6),
        sig=1,gamma=1,beta=c(-5,-2.5,0,2.5,5),outcomeModel=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate.cluster.data_+3A_ratio">ratio</code></td>
<td>
<p>The ratio <code class="reqn">\tau^2/\sigma^2</code> of the variance of the\ random effects to the error variance of the features</p>
</td></tr>

<tr><td><code id="generate.cluster.data_+3A_npats">npats</code></td>
<td>
<p>Number of observations in the data set.

</p>
</td></tr>
<tr><td><code id="generate.cluster.data_+3A_clusts">clusts</code></td>
<td>
<p>The cluster identity of the features</p>
</td></tr>
<tr><td><code id="generate.cluster.data_+3A_sig">sig</code></td>
<td>
<p>The error variance of the features.</p>
</td></tr>
<tr><td><code id="generate.cluster.data_+3A_gamma">gamma</code></td>
<td>
<p>The error variance of the outcome.</p>
</td></tr>
<tr><td><code id="generate.cluster.data_+3A_beta">beta</code></td>
<td>
<p>The value of the regression coefficients</p>
</td></tr>
<tr><td><code id="generate.cluster.data_+3A_outcomemodel">outcomeModel</code></td>
<td>
<p>A function that returns a data frame with <code>npats</code> observations and rows that depend on the data object chosen.  Two outcomeModel programs are provided, <code><a href="#topic+binaryOutcome">binaryOutcome</a></code> and <code><a href="#topic+survivalOutcome">survivalOutcome</a></code>, however users can write their own outcome model.
If NULL no data object is returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with one element if outcomeModel=NULL which is a data frame which is <code>npats</code> times <code>ngens+1</code> the last column is the outcome. Otherwise a list of two data frames, one being the feature data and the other being the outcome data according to what outcomeModel is used.





</p>


<h3>Author(s)</h3>

<p>David A. Schoenfeld</p>


<h3>See Also</h3>

 <p><code><a href="#topic+supcluster">supcluster</a></code>

</p>

<hr>
<h2 id='supcluster'>Clustering of Features Supervised by an Outcome 

</h2><span id='topic+supcluster'></span>

<h3>Description</h3>

<p>We assume that each individual has set of features and an outcome, further we assume that the features are organized in clusters with a random effect for each cluster, and that the outcome is related to the random effects by a linear regression. The function supcluster performs an MCMC to determine the parameters of this model including the cluster membership of each feature. The program can also perform the estimation without considering the outcome. The outcome can be any data object, as long as it is related to the individual through a frialty.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>supcluster(data,outcome,features,log.transform=TRUE,maxclusters=10,
nstart=100,n=500,shape=1,scale=1,alpha=1,betaP=1,fixj="random",
fbeta=FALSE,starting.value=NULL,nchains=1,linkLikelihood = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="supcluster_+3A_data">data</code></td>
<td>
<p> A data frame of the input data </p>
</td></tr>
<tr><td><code id="supcluster_+3A_outcome">outcome</code></td>
<td>
<p>Either the variable number or the variable name of the outcome variable. If <code>fbeta=TRUE</code>, no outcome variable is used. If NULL we assume the outcome is a data object and there is a likelihood relating it to a per-patient frialty variable.  In that case linkLikelihood cannont be NULL</p>
</td></tr>
<tr><td><code id="supcluster_+3A_features">features</code></td>
<td>
<p>A list of features either as variable names or column numbers this can't be mixed</p>
</td></tr>
<tr><td><code id="supcluster_+3A_log.transform">log.transform</code></td>
<td>
<p>Log transform the feature data. Generally used when the features are gene expressons</p>
</td></tr>
<tr><td><code id="supcluster_+3A_maxclusters">maxclusters</code></td>
<td>
<p>The maximum number of clusters used</p>
</td></tr>
<tr><td><code id="supcluster_+3A_nstart">nstart</code></td>
<td>
<p>The first nstart-1 values of each MCMC chain are not reported, that is used as a &ldquo;burn in&rdquo;.

</p>
</td></tr>
<tr><td><code id="supcluster_+3A_n">n</code></td>
<td>
<p>The number of MCMC iterations for each chain</p>
</td></tr>

<tr><td><code id="supcluster_+3A_shape">shape</code></td>
<td>
<p>The shape parameter for the prior on the variance components

</p>
</td></tr>
<tr><td><code id="supcluster_+3A_scale">scale</code></td>
<td>
<p>The starting scale parmeter for the prior on the variance components

</p>
</td></tr>
<tr><td><code id="supcluster_+3A_alpha">alpha</code></td>
<td>
<p>The value to use for the Dirichelet prior parameter</p>
</td></tr>

<tr><td><code id="supcluster_+3A_betap">betaP</code></td>
<td>
<p>The prior precision of the regression parameters.

</p>
</td></tr>
<tr><td><code id="supcluster_+3A_fixj">fixj</code></td>
<td>
<p>If <code>"random"</code>, then the starting value for cluster membership is set at random.  If <code>"kmeans"</code> it uses kmeans to set the starting value.  Otherwise it is matrix of features verses clusters, where a 1 indicates that feature <code class="reqn">i</code> is in cluser <code class="reqn">j</code> and the cluster membership is assumed to be known. <code>fixj</code>
should be set to <code>"random"</code> when multiple chains are run.

</p>
</td></tr>
<tr><td><code id="supcluster_+3A_fbeta">fbeta</code></td>
<td>
<p>If TRUE then the outcome is not used in the clustering algorithm

</p>
</td></tr>
<tr><td><code id="supcluster_+3A_starting.value">starting.value</code></td>
<td>
<p>Starting value for the MCMC. It should be left as NULL when multiple chains are run, in which case the starting cluster membership is determined by <code>fixj</code>.
Otherwise it is parameter vector similar to the one described under &ldquo;value&rdquo; below.  

</p>
</td></tr>
<tr><td><code id="supcluster_+3A_nchains">nchains</code></td>
<td>
<p> Number of chains to run

</p>
</td></tr>
<tr><td><code id="supcluster_+3A_linklikelihood">linkLikelihood</code></td>
<td>
<p>Likelihood function for model linking actual outcome data to the per-patient frialty. The input of the function is a vector of length <code>dim(data)[1]+nparms</code>, where <code>nparms</code> is the number of parameters in the outcome model. The first part of the vector are the frailties and the second part are the parameters of the model.  If NULL then <code>outcome</code> is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A compound list is returned. At the first level is the chain number.  At the second level there are two elements
</p>
<table>
<tr><td><code>inp</code></td>
<td>
<p>This has twp values <code>maxclusters</code> giving the maximum number of clusters and <code>ngenes</code> giving the maximum number of features</p>
</td></tr>
<tr><td><code>parms</code></td>
<td>
<p>This is a <code>n</code> by <code>3+maxclusters+ngenes</code> matrix.  Each row is one MCMC iteration. The first three columns are the values of the variance components <code class="reqn">\sigma^2,\tau^2</code>, and <code class="reqn">\gamma^2</code> the next <code>maxcluster</code> values are the regression coefficients for each cluster and the final <code>ngenes</code> values are the cluster membership of each feature</p>
</td></tr>
</table>


<h3>Note</h3>

<p>When the feature space is large this program runs slowely. In the example only 20 iterations where used for the burn in and only 80 iterations are run. In general this would not be adequate to fully explore the feature space.

</p>


<h3>Author(s)</h3>

<p> David A. Schoenfeld, Jessie Hsu

</p>


<h3>References</h3>

<p>Hsu, Jessie J., Dianne M. Finkelstein, and David A. Schoenfeld. &quot;Outcome-driven cluster analysis with application to microarray data.&quot; PloS one 10.11 (2015): e0141874.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+concordmap">concordmap</a></code>,
<code><a href="#topic+compare.chains">compare.chains</a></code>,<code><a href="#topic+beta.by.gene">beta.by.gene</a></code>

</p>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets
##--Note you need to change nstart and n in example to get enough iterations
#run supcluster on trauma data.  Note: nstart and n must be increased to,say, 2000,3000 
#and maxclusters increased to 20
data("trauma_data")
us=supcluster(trauma_data,outcome="outcome",features=1:87,
              maxclusters=5,nstart=5,n=20,fbeta=FALSE)
#creates plot in paper
usm=concordmap(us,chains=1,sort.genes=TRUE)
image(1:87,1:87,usm$map,xlab='Genes',ylab='Genes',
      main="Trauma Data Example",
      col=gray(16:1 / 16))
#Associate genes with clusters
data("gene_names")
betas=colSums(us[[1]]$parms[,3:22])
outpt=data.frame(cluster.number=usm$clusters,beta=betas[usm$clusters],gene_names[usm$order,])
</code></pre>

<hr>
<h2 id='supcluster-package'>
Supervised Cluster Anaysis 
</h2><span id='topic+supcluster-package'></span>

<h3>Description</h3>

<p>The function clusters features under the assumption that each cluster has a
random effect and there is an outcome variable that is related to the random effects
by a linear regression. In this way the cluster analysis is &ldquo;supervised&rdquo; by the outcome
variable. An alternate specification is that features in each cluster have the same compound
symetric normal distribution, and the conditional distribution of the outcome given the features has the same coefficient for each feature in a cluster. 
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> supcluster</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2015-03-24</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The package consists of a function <code><a href="#topic+supcluster">supcluster</a></code> which reads a data frame whose columns include features and an outcome. It then peforms a cluster analysis that is supervised by the outcome as described above. The cluster analysis is performed using a Markoff Chain Monte Carlo algorythm, the output is a matrix where each row is a parameter vector consisting of the parameters of the multivariate normal distribution described above as well as the cluster membership of each of the features.
</p>
<p>In addition there is function <code><a href="#topic+concordmap">concordmap</a></code> which produces a array with the posterior probability that each pair of features are in the same cluster and a function <code><a href="#topic+compare.chains">compare.chains</a></code> used to compare these arrays for two chains in order to determine whether different chains have converged to the same set of clusters.
</p>


<h3>Author(s)</h3>

<p> David A. Schoenfeld, Jesse Hsu
Maintainer: David A. Schoenfeld &lt;dschoenfeld@mgh.harvard.edu&gt;
~~ The author and/or maintainer of the package ~~
</p>


<h3>References</h3>

<p>~~ Literature or other references for background information ~~
</p>


<h3>See Also</h3>

<p><code><a href="#topic+supcluster">supcluster</a></code>,
<code><a href="#topic+concordmap">concordmap</a></code>,
<code><a href="#topic+compare.chains">compare.chains</a></code>,<code><a href="#topic+beta.by.gene">beta.by.gene</a></code></p>

<hr>
<h2 id='survivalOutcome'>Simulates a survival model for use with <code><a href="#topic+generate.cluster.data">generate.cluster.data</a></code>

</h2><span id='topic+survivalOutcome'></span>

<h3>Description</h3>

<p>Given a vector of frailties, say <code class="reqn">x_1,...</code>, this function generates a censored exponentially distributed random variable with rate equal to <code class="reqn">\mu+\beta x_i</code>.  The censoring distribution is uniform with from <code class="reqn">f</code> to 
<code class="reqn">f+a</code>.

</p>


<h3>Usage</h3>

<pre><code class='language-R'>survivalOutcome(mu, beta, accrual, followUp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survivalOutcome_+3A_mu">mu</code></td>
<td>
<p> The constant term <code class="reqn">\mu</code>

</p>
</td></tr>
<tr><td><code id="survivalOutcome_+3A_beta">beta</code></td>
<td>
<p> The frailty effect <code class="reqn">\beta</code>

</p>
</td></tr>
<tr><td><code id="survivalOutcome_+3A_accrual">accrual</code></td>
<td>
<p> The accrual time <code class="reqn">a</code>, in a clinical study</p>
</td></tr>

<tr><td><code id="survivalOutcome_+3A_followup">followUp</code></td>
<td>
<p> The follow up time <code class="reqn">f</code> in a clinical study

</p>
</td></tr>
</table>


<h3>Value</h3>

<p> A data frame is returned with two columns <code>survival</code> and <code>censor</code>





</p>


<h3>Author(s)</h3>

<p>David A. Schoenfeld

</p>


<h3>See Also</h3>

<p><code><a href="#topic+coxLink">coxLink</a></code>,<code><a href="#topic+binaryOutcome">binaryOutcome</a></code>,<code><a href="#topic+binaryLink">binaryLink</a></code>

</p>


<h3>Examples</h3>

<pre><code class='language-R'>generatedData=generate.cluster.data(.25,npats=25,clusts=c(12,8),beta=c(-5,5),
                                    outcomeModel=survivalOutcome(0,1,1,1))
usBinary=supcluster(generatedData[[1]],outcome="outcome",
maxclusters=5,nstart=100,n=200,fbeta=FALSE,
linkLikelihood=coxLink(generatedData[[2]]))
</code></pre>

<hr>
<h2 id='tab1'>Simulates Supcluster Function</h2><span id='topic+tab1'></span>

<h3>Description</h3>

<p>Produces summary statistics from a simulation of supcluster</p>


<h3>Usage</h3>

<pre><code class='language-R'>tab1(ratio=4,reps=100,n=1000,start=500,fbeta=FALSE,
               maxclusters=5,chains=1,clusts=c(15,15,20),
               sig=1,gamma=1,npats=80,beta=seq(-5,5,5),
               plot=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tab1_+3A_ratio">ratio</code></td>
<td>
<p> The ratio of tau to sigma</p>
</td></tr>
<tr><td><code id="tab1_+3A_reps">reps</code></td>
<td>
<p>The number of runs</p>
</td></tr>
<tr><td><code id="tab1_+3A_n">n</code></td>
<td>
<p>The number of MCMC iterations</p>
</td></tr>
<tr><td><code id="tab1_+3A_start">start</code></td>
<td>
<p>The first MCMC iteration used</p>
</td></tr>
<tr><td><code id="tab1_+3A_fbeta">fbeta</code></td>
<td>
<p>If TRUE the outcome is not used</p>
</td></tr>
<tr><td><code id="tab1_+3A_maxclusters">maxclusters</code></td>
<td>
<p>The maximum number of clusters for the estimation step</p>
</td></tr>
<tr><td><code id="tab1_+3A_chains">chains</code></td>
<td>
<p>The number of chains to run</p>
</td></tr>
<tr><td><code id="tab1_+3A_clusts">clusts</code></td>
<td>
<p>A list of the number of genes in each cluster</p>
</td></tr>
<tr><td><code id="tab1_+3A_sig">sig</code>, <code id="tab1_+3A_gamma">gamma</code>, <code id="tab1_+3A_beta">beta</code></td>
<td>
<p>The parameters sigma,gamma,beta</p>
</td></tr>
<tr><td><code id="tab1_+3A_npats">npats</code></td>
<td>
<p>The number of experimental units(patients)</p>
</td></tr>
<tr><td><code id="tab1_+3A_plot">plot</code></td>
<td>
<p>Plots the first run</p>
</td></tr>

</table>


<h3>Value</h3>

<p>A data frame is returned with the mean parameter value, it's standard error and the mean of it's standard error calculated from the MCMC</p>


<h3>Author(s)</h3>

<p>David A. Schoenfeld, Jessie Hsu

</p>


<h3>See Also</h3>

<p><code><a href="#topic+supcluster">supcluster</a></code>,,<code><a href="#topic+compare.chains">compare.chains</a></code>,<code><a href="#topic+concordmap">concordmap</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#very few iterations done so that this runs in less than 5 seconds.
#You need to change reps=100,start=2000,n=3000 to get enough iterations
tab1(ratio=2,reps=5,n=10,start=1,maxclusters=5)
</code></pre>

<hr>
<h2 id='trauma_data'>Trauma Data for Supervised Clustering

</h2><span id='topic+trauma_data'></span>

<h3>Description</h3>

<p>This is a genomic data set, saved as an R save file, that loaded with <code>data("trauma_data")</code> and  <code>data("gene_names")</code> The data frame <code>trauma_data</code> has 147 observations on patients with trauma. The first 87 columns are gene expression values and the final column labeled outcome is the multiple organ failure score for the patient.  The data in <code>gene_names</code> is information on each gene in <code>trauma_data</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("trauma_data");data("gene_names")</code></pre>


<h3>Format</h3>

<p>A data frame <code>trauma_data</code> with 147 observations the first 87 columns are gene expression data and the last column labeled <code>outcome</code> is the maximum organ failure score. A data frame <code>gene_names</code> with the affymetrix description of the probesets in <code>trauma_data</code>.
</p>


<h3>Source</h3>

<p> N. Rajicic, Dianne M. Finkelstein, and David A. Schoenfeld.(2007) &ldquo;Survival analysis of longitudinal
microarrays.&rdquo; <em>Bioinformatics</em>, 22(21):2643-2649

</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
