<!DOCTYPE html><html lang="en"><head><title>Help for package BEDASSLE</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {BEDASSLE}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#BEDASSLE-package'>
<p>Disentangling the contributions of geographic and ecological isolation to genetic</p>
differentiation</a></li>
<li><a href='#BEDASSLE-internal'><p>Internal BEDASSLE Functions</p></a></li>
<li><a href='#calculate.all.pairwise.Fst'>
<p>Calculates unbiased pairwise Fst between all sampled populations</p></a></li>
<li><a href='#calculate.pairwise.Fst'>
<p>Calculates unbiased pairwise Fst between a pair of populations</p></a></li>
<li><a href='#Covariance'>
<p>The parametric covariance matrix</p></a></li>
<li><a href='#HGDP.bedassle.data'>
<p>The Eurasian subset of the HGDP dataset used in example BEDASSLE analyses</p></a></li>
<li><a href='#link.up.posteriors'>
<p>Links up multiple MCMC output objects</p></a></li>
<li><a href='#make.continuing.params'>
<p>Generates an R object containing the last parameter values of an MCMC run (to be</p>
used for a subsequent run)</a></li>
<li><a href='#MCMC'>
<p>Runs the Markov chain Monte Carlo with the standard (Binomial) model</p></a></li>
<li><a href='#MCMC_BB'>
<p>Runs the Markov chain Monte Carlo with the overdispersion (Beta-Binomial) model</p></a></li>
<li><a href='#mcmc.operators'>
<p>Operator parameters that control the operation of the MCMC</p></a></li>
<li><a href='#plot_acceptance_rate'>
<p>Plots the acceptance rate of a parameter across MCMC generations</p></a></li>
<li><a href='#plot_all_acceptance_rates'>
<p>Plots the acceptance rates of all parameters across MCMC generations</p></a></li>
<li><a href='#plot_all_joint_marginals'>
<p>Plots the joint marginals for all parameter pairs</p></a></li>
<li><a href='#plot_all_marginals'>
<p>Plots the marginal densities for all parameters</p></a></li>
<li><a href='#plot_all_phi_marginals'>
<p>Plot all the marginals for the phi parameters for all populations</p></a></li>
<li><a href='#plot_all_phi_trace'>
<p>Plots all the trace plots for the phi parameters for all populations</p></a></li>
<li><a href='#plot_all_trace'>
<p>Plots all the trace plots for all parameters</p></a></li>
<li><a href='#plot_joint_marginal'>
<p>Plots the joint marginal for a pair of parameters</p></a></li>
<li><a href='#plot_marginal'>
<p>Plots the marginal density of a parameter</p></a></li>
<li><a href='#plot_phi_marginal'>
<p>Plots the marginal for the phi parameter estimated in a single population</p></a></li>
<li><a href='#plot_phi_trace'>
<p>Plots the trace plot for the phi parameter estimated in a single population</p></a></li>
<li><a href='#plot_posterior_predictive_samples'>
<p>Plots posterior predictive sampling</p></a></li>
<li><a href='#plot_trace'>
<p>Plot the trace plot for a parameter</p></a></li>
<li><a href='#posterior.predictive.sample'>
<p>Generates posterior predictive samples</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Quantifies Effects of Geo/Eco Distance on Genetic
Differentiation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-1-09</td>
</tr>
<tr>
<td>Author:</td>
<td>Gideon Bradburd</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gideon Bradburd &lt;bradburd@umich.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions that allow users to quantify the relative 
	contributions of geographic and ecological distances to empirical patterns of genetic 
	differentiation on a landscape.  Specifically, we use a custom Markov chain 
	Monte Carlo (MCMC) algorithm, which is used to estimate the parameters of the 
	inference model, as well as functions for performing MCMC diagnosis and assessing 
	model adequacy.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, matrixcalc, emdbook</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-11 16:05:04 UTC; bradburd</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-11 23:50:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='BEDASSLE-package'>
Disentangling the contributions of geographic and ecological isolation to genetic 
differentiation
</h2><span id='topic+BEDASSLE-package'></span><span id='topic+BEDASSLE'></span>

<h3>Description</h3>

<p>This method models the covariance in allele frequencies between populations on a 
landscape as a decreasing function of their pairwise geographic and ecological distance.  
Allele frequencies are modeled as a spatial Gaussian process with a parametric covariance 
function. The parameters of this covariance function, as well as the spatially smoothed 
allele frequencies, are estimated in a custom Markov chain Monte Carlo.
</p>
<p>The two inference functions are <code>MCMC</code> and <code>MCMC_BB</code>, which call the 
Markov chain Monte Carlo algorithms on the standard and overdispersion (Beta-Binomial)
models, respectively.  To evaluate MCMC performance, there are a number of MCMC diagnosis
and visualization functions, which variously show the trace, plots, marginal and joint
marginal densities, and parameter acceptance rates.  To evaluate model adequacy, there is 
a posterior predictive sample function (<code>posterior.predictive.sample</code>), and an
accompanying function to plot its output and visually assess the model's ability to 
describe the user's data.  
</p>


<h3>Author(s)</h3>

<p>Gideon Bradburd
</p>
<p>Maintainer: 
Gideon Bradburd &lt;gbradburd@ucdavis.edu&gt;
</p>


<h3>References</h3>

<p>Bradburd, G.S., Ralph, P.L., and Coop, G.M. Disentangling the effects of geographic and 
ecological isolation on genetic differentiation. <em>Evolution</em> 2013.
</p>

<hr>
<h2 id='BEDASSLE-internal'>Internal BEDASSLE Functions</h2><span id='topic+a0_gibbs_rate'></span><span id='topic+BB_Likelihood_counts'></span><span id='topic+BB_Prior_prob_phi'></span><span id='topic+BB_Update_mu'></span><span id='topic+BB_Update_phi'></span><span id='topic+BB_Update_thetas'></span><span id='topic+identify_invariant_loci'></span><span id='topic+Initialize.params'></span><span id='topic+Likelihood_counts'></span><span id='topic+Likelihood_thetas'></span><span id='topic+load_MCMC_output'></span><span id='topic+load_posterior_predictive_samples'></span><span id='topic+Prior_prob_alpha0'></span><span id='topic+Prior_prob_alpha2'></span><span id='topic+Prior_prob_alphaD'></span><span id='topic+Prior_prob_alphaE'></span><span id='topic+Prior_prob_beta'></span><span id='topic+Prior_prob_mu'></span><span id='topic+Shift'></span><span id='topic+simulate_allele_count_data'></span><span id='topic+transform_frequencies'></span><span id='topic+Update_a0'></span><span id='topic+Update_a2'></span><span id='topic+Update_aD'></span><span id='topic+Update_aE'></span><span id='topic+Update_beta'></span><span id='topic+Update_mu'></span><span id='topic+Update_thetas'></span>

<h3>Description</h3>

<p>Internal BEDASSLE functions
</p>


<h3>Details</h3>

<p>These functions are called by other functions (mostly
<code>MCMC</code> and <code>MCMC_BB</code>), and will not 
be called directly by the user.
</p>

<hr>
<h2 id='calculate.all.pairwise.Fst'>
Calculates unbiased pairwise Fst between all sampled populations
</h2><span id='topic+calculate.all.pairwise.Fst'></span>

<h3>Description</h3>

<p>This function calculates unbiased <code class="reqn">F_{ST}</code> (based on Weir and Hill's <code class="reqn">\theta</code>, 
2002), between all populations/individuals included in the <code>counts</code> matrix, and 
returns the results in a <code>k</code> by <code>k</code> matrix, where <code>k = nrow(counts)</code>.  
Loci for which either of the populations/individuals has missing data (i.e. - the sample 
size is zero) are excluded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate.all.pairwise.Fst(allele.counts, sample.sizes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate.all.pairwise.Fst_+3A_allele.counts">allele.counts</code></td>
<td>

<p>A matrix of allelic count data, for which <code>nrow = </code> the number of populations
and <code>ncol = </code> the number of bi-allelic loci sampled.  Each cell gives the number 
of times allele &lsquo;1&rsquo; is observed in each population.  The choice of which allele is 
allele &lsquo;1&rsquo; is arbitrary, but must be consistent across all populations at a locus.
</p>
</td></tr>
<tr><td><code id="calculate.all.pairwise.Fst_+3A_sample.sizes">sample.sizes</code></td>
<td>

<p>A matrix of sample sizes, for which <code>nrow = </code> the number of populations
and <code>ncol = </code> the number of bi-allelic loci sampled (i.e. - the dimensions of
<code>sample.sizes</code> must match those of <code>counts</code>).  Each cell gives the number 
of chromosomes successfully genotyped at each locus in each population.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of pairwise, unbiased <code class="reqn">F_{ST}</code>.
</p>


<h3>Author(s)</h3>

<p>Gideon Bradburd
</p>


<h3>References</h3>

<p>Weir,B.S. and W.G. Hill. 2002. Estimating F-statistics. Ann.Rev.Gen. 36:949-952.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#With the HGDP dataset
	data(HGDP.bedassle.data)

#Calculate pairwise Fst between all population pairs
	hgdp.pairwise.Fst &lt;- calculate.all.pairwise.Fst(
		HGDP.bedassle.data$allele.counts,
		HGDP.bedassle.data$sample.sizes
	)	

#Plot pairwise Fst against geographic distance
	plot(HGDP.bedassle.data$GeoDistance,
		hgdp.pairwise.Fst,
		pch=19,
		col=HGDP.bedassle.data$EcoDistance+1,
		ylab="pairwise Fst",
		xlab="geographic distance",
		main="isolation by distance")
			legend(x="bottomright",pch=19,col=c(1,2),
				legend=c("same side of Himalayas",
						"opposite sides of Himalayas"))
</code></pre>

<hr>
<h2 id='calculate.pairwise.Fst'>
Calculates unbiased pairwise Fst between a pair of populations
</h2><span id='topic+calculate.pairwise.Fst'></span>

<h3>Description</h3>

<p>This function calculates unbiased <code class="reqn">F_{ST}</code> (based on Weir and Hill's 
<code class="reqn">\theta</code>, 2002), between a pair of populations/individuals. Loci for which either 
of the populations/individuals has missing data (i.e. - the sample size is zero) are 
excluded.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate.pairwise.Fst(allele.counts, sample.sizes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate.pairwise.Fst_+3A_allele.counts">allele.counts</code></td>
<td>

<p>A matrix of allele counts of dimensions <code>nrow = </code> 2, one for each of the two 
populations/individuals between which pairwise <code class="reqn">F_{ST}</code> is being calculated, and 
<code>ncol = </code> the number of loci genotyped.
</p>
</td></tr>
<tr><td><code id="calculate.pairwise.Fst_+3A_sample.sizes">sample.sizes</code></td>
<td>

<p>A matrix of sample sizes of dimensions <code>nrow = </code> 2, one for each of the two 
populations/individuals between which pairwise <code class="reqn">F_{ST}</code> is being calculated, and 
<code>ncol = </code> the number of loci genotyped (i.e. - the dimensions of
<code>sample.sizes</code> must match those of <code>counts</code>).  Each cell gives the number 
of chromosomes successfully genotyped at each locus in each population.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Pairwise unbiased <code class="reqn">F_{ST}</code> between a pair of populations/individuals
</p>


<h3>Author(s)</h3>

<p>Gideon Bradburd
</p>


<h3>References</h3>

<p>Weir,B.S. and W.G. Hill. 2002. Estimating F-statistics. Ann.Rev.Gen. 36:949-952.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#With the HGDP dataset
	data(HGDP.bedassle.data)

#Draw 2 populations at random from the Eurasian HGDP dataset
	pop1 &lt;- sample(nrow(HGDP.bedassle.data$allele.counts),1)
	pop2 &lt;- sample(nrow(HGDP.bedassle.data$allele.counts),1)

#Calculate unbiased Fst between them
	pairwise.Fst &lt;- calculate.pairwise.Fst(
		HGDP.bedassle.data$allele.counts[c(pop1,pop2),],
		HGDP.bedassle.data$sample.sizes[c(pop1,pop2),]	
	)

#Print that Fst to the console
	print(sprintf("Fst between the %s population and the %s population is %s",
		HGDP.bedassle.data$hgdp.metadata[pop1,1],
		HGDP.bedassle.data$hgdp.metadata[pop2,1],
		round(pairwise.Fst,3))
	 )
</code></pre>

<hr>
<h2 id='Covariance'>
The parametric covariance matrix
</h2><span id='topic+Covariance'></span>

<h3>Description</h3>

<p>This function parameterizes the decay in covariance of transformed allele frequencies
between sampled populations/individuals over their pairwise geographic and ecological
distance.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Covariance(a0, aD, aE, a2, GeoDist, EcoDist, delta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Covariance_+3A_a0">a0</code></td>
<td>

<p>This parameter controls the variance when pairwise distance is zero.  It is the 
variance of the population-specific transformed allelic deviate (theta) when pairwise 
distances are zero (i.e. when <code class="reqn">D_{i,j} + E_{i,j} = 0</code>).
</p>
</td></tr>
<tr><td><code id="Covariance_+3A_ad">aD</code></td>
<td>

<p>This parameter gives the effect size of geographic distance (<code class="reqn">D_{i,j}</code>).
</p>
</td></tr>
<tr><td><code id="Covariance_+3A_ae">aE</code></td>
<td>

<p>This parameter gives the effect size(s) of ecological distance(s) (<code class="reqn">E_{i,j}</code>).
</p>
</td></tr>
<tr><td><code id="Covariance_+3A_a2">a2</code></td>
<td>

<p>This parameter controls the shape of the decay in covariance with distance.
</p>
</td></tr>
<tr><td><code id="Covariance_+3A_geodist">GeoDist</code></td>
<td>

<p>Pairwise geographic distance (<code class="reqn">D_{i,j}</code>).  This may be Euclidean, or, if the 
geographic scale of sampling merits it, great-circle distance.
</p>
</td></tr>
<tr><td><code id="Covariance_+3A_ecodist">EcoDist</code></td>
<td>

<p>Pairwise ecological distance(s) (<code class="reqn">E_{i,j}</code>), which may be continuous (e.g. - 
difference in elevation) or binary (same or opposite side of some hypothesized 
barrier to gene flow).
</p>
</td></tr>
<tr><td><code id="Covariance_+3A_delta">delta</code></td>
<td>

<p>This gives the size of the &quot;delta shift&quot; on the off-diagonal elements of the 
parametric covariance matrix, used to ensure its positive-definiteness (even, for 
example, when there are separate populations sampled at the same 
geographic/ecological coordinates). This value must be large enough that the 
covariance matrix is positive-definite, but, if possible, should be smaller than the 
smallest off-diagonal distance elements, lest it have an undue impact on inference.  
If the user is concerned that the delta shift is too large relative to the pairwise 
distance elements in D and E, she should run subsequent analyses, varying the size of 
delta, to see if it has an impact on model inference.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gideon Bradburd
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#With the HGDP dataset
	data(HGDP.bedassle.data)
	
#Draw random values of the {alpha} parameters from their priors
	alpha0 &lt;- rgamma(1,shape=1,rate=1)
	alphaD &lt;- rexp(1,rate=1)
	alphaE &lt;- matrix(rexp(1,rate=1),nrow=1,ncol=1)
	alpha2 &lt;- runif(1,0.1,2)

#Parameterize the covariance function using the HGDP dataset distances (Geo and Eco)
	example.covariance &lt;- Covariance(a0 = alpha0,aD = alphaD,aE = alphaE,a2 = alpha2,
				GeoDist = HGDP.bedassle.data$GeoDistance,
				EcoDist = list(HGDP.bedassle.data$EcoDistance),
				delta = 0.001)

#Plot the example covariance against geographic distance
	plot(HGDP.bedassle.data$GeoDistance,
		example.covariance,
		pch=19,col=HGDP.bedassle.data$EcoDistance+1,
		main="Covariance in allele frequencies across the Himalayas")
			legend(x="topright",pch=19,col=c(1,2),
				legend=c("same side of Himalayas",
							"opposite sides of Himalayas"))
</code></pre>

<hr>
<h2 id='HGDP.bedassle.data'>
The Eurasian subset of the HGDP dataset used in example BEDASSLE analyses 
</h2><span id='topic+HGDP.bedassle.data'></span>

<h3>Description</h3>

<p>The allelic counts, sample sizes, geographic distances, ecological distances, and 
population metadata from the 38 human populations used in example BEDASSLE 
analyses, subsetted from the Human Genome Diversity Panel (HGDP) dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(HGDP.bedassle.data)</code></pre>


<h3>Format</h3>

<p>The format is:
List of 7
</p>

<dl>
<dt>$ allele.counts        :</dt><dd><p>int [1:38, 1:1000] 12 16 5 17 4 14 20 5 34 ...</p>
</dd>
</dl>

<ul>
<li><p>..- attr(*, &quot;dimnames&quot;)=List of 2
</p>
</li>
<li><p>.. ..$ : chr [1:38] &quot;Adygei&quot; &quot;Basque&quot; &quot;Italian&quot; &quot;French&quot; ...
</p>
</li>
<li><p>.. ..$ : chr [1:1000] &quot;rs13287637&quot; &quot;rs17792496&quot; &quot;rs1968588&quot; ...
</p>
</li></ul>

<dl>
<dt>$ sample.sizes         :</dt><dd><p>int [1:38, 1:1000] 34 48 24 56 30 50 56 ...</p>
</dd>
</dl>

<ul>
<li><p>..- attr(*, &quot;dimnames&quot;)=List of 2
</p>
</li>
<li><p>.. ..$ : chr [1:38] &quot;Adygei&quot; &quot;Basque&quot; &quot;Italian&quot; &quot;French&quot; ...
</p>
</li>
<li><p>.. ..$ : chr [1:1000] &quot;rs13287637&quot; &quot;rs17792496&quot; &quot;rs1968588&quot; ...
</p>
</li></ul>

<dl>
<dt>$ GeoDistance          :</dt><dd><p>num [1:38, 1:38] 0 1.187 0.867 1.101 1.247 ...</p>
</dd>
<dt>$ EcoDistance          :</dt><dd><p>num [1:38, 1:38] 0 0 0 0 0 0 0 0 0 0 ...</p>
</dd>
</dl>

<ul>
<li><p>..- attr(*, &quot;dimnames&quot;)=List of 2
</p>
</li>
<li><p>.. ..$ : chr [1:38] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ...
</p>
</li>
<li><p>.. ..$ : chr [1:38] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; ...
</p>
</li></ul>

<dl>
<dt>$ number.of.populations:</dt><dd><p>int 38</p>
</dd>
<dt>$ number.of.loci       :</dt><dd><p>int 1000</p>
</dd>
<dt>$ hgdp.metadata        :</dt><dd><p>'data.frame':	38 obs. of  3 variables:</p>
</dd>
</dl>

<dl>
<dt>..$ Population:</dt><dd><p> chr [1:38] &quot;Adygei&quot; &quot;Basque&quot; &quot;Italian&quot; ...</p>
</dd>
<dt>..$ Latitude  :</dt><dd><p> chr [1:38] &quot;44&quot; &quot;43&quot; &quot;46&quot; &quot;46&quot; ...</p>
</dd>
<dt>..$ Longitude :</dt><dd><p> chr [1:38] &quot;39&quot; &quot;0&quot; &quot;10&quot; &quot;2&quot; ...</p>
</dd>
</dl>




<h3>Details</h3>


<dl>
<dt>allele.counts</dt><dd><p>A matrix of allelic count data, for which <code>nrow = </code> 
the number of populations and <code>ncol = </code> the number of bi-allelic loci 
sampled.  Each cell gives the number of times allele &lsquo;1&rsquo; is observed in each 
population.  The choice of which allele is allele &lsquo;1&rsquo; is arbitrary, but must 
be consistent across all populations at a locus.</p>
</dd>
<dt>sample.sizes</dt><dd><p>A matrix of sample sizes, for which <code>nrow = </code> the number 
of populations and <code>ncol = </code> the number of bi-allelic loci sampled 
(i.e. - the dimensions of <code>sample.sizes</code> must match those of 
<code>counts</code>).  Each cell gives the number of chromosomes successfully 
genotyped at each locus in each population.</p>
</dd>
<dt>Geo.Distance</dt><dd><p>Pairwise geographic distance (<code class="reqn">D_{i,j}</code>).  This may be 
Euclidean, or, if the geographic scale of sampling merits it, great-circle 
distance.  In the case of this dataset, it is great-circle distance.</p>
</dd>
<dt>Eco.Distance</dt><dd><p>Pairwise ecological distance(s) (<code class="reqn">E_{i,j}</code>), which may 
be continuous (e.g. - difference in elevation) or binary (same or opposite 
side of some hypothesized barrier to gene flow).  In this case, the 
ecological distance is binary, representing whether a pair of populations 
occurs on the same side, or on opposite sides, of the Himalayas.</p>
</dd>
<dt>number.of.populations</dt><dd><p>The number of populations in the analysis.  
This should be equal to <code>nrow(</code>counts<code>)</code>.  In this dataset, there
are 38 populations sampled.</p>
</dd>
<dt>number.of.loci</dt><dd><p>The number of loci in the analysis.  This should be equal 
to <code>ncol(</code>counts<code>)</code>.  In this dataset, there are 1000 loci 
sampled.</p>
</dd>
<dt>hgdp.metadata</dt><dd><p>This data frame contains the metadata on the populations
included in the analysis, including:
</p>

<ul>
<li><p>Population name
</p>
</li>
<li><p>Latitude
</p>
</li>
<li><p>Longitude
</p>
</li></ul>

</dd>
</dl>



<h3>Source</h3>


<ul>
<li><p>Conrad et al. A worldwide survey of haplotype variation and linkage
disequilibrium in the human genome. <em>Nature Genetics</em> 2008.
</p>
</li>
<li><p>Li et al. Worldwide human relationships inferred from genome-wide 
patterns of variation. <em>Science</em> 2008.
</p>
</li></ul>
	


<h3>References</h3>

<p>Bradburd, G.S., Ralph, P.L., and Coop, G.M. Disentangling the effects of 
geographic and ecological isolation on genetic differentiation. 
<em>Evolution</em> 2013.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see \command{MCMC}, \command{MCMC_BB}, \command{calculate.pariwise.Fst}, 
## \command{calculate.all.pairwise.Fst}, and \command{Covariance} for usage.
</code></pre>

<hr>
<h2 id='link.up.posteriors'>
Links up multiple MCMC output objects
</h2><span id='topic+link.up.posteriors'></span>

<h3>Description</h3>

<p>Creates a single MCMC output object that links together the output from 2 different
runs.  To be used when analyses are run serially on a single dataset, with subsequent
runs initiated at the parameter values estimated in the last generation of the 
previous MCMC run.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>link.up.posteriors(MCMC.output1, MCMC.output2, linked.up.output.file.name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="link.up.posteriors_+3A_mcmc.output1">MCMC.output1</code></td>
<td>

<p>The first (chronologically) MCMC output to be incorporated into the linked-up output
object.
</p>
</td></tr>
<tr><td><code id="link.up.posteriors_+3A_mcmc.output2">MCMC.output2</code></td>
<td>

<p>The second (chronologically) MCMC output to be incorporated into the linked-up output
object.
</p>
</td></tr>
<tr><td><code id="link.up.posteriors_+3A_linked.up.output.file.name">linked.up.output.file.name</code></td>
<td>

<p>The linked-up MCMC object file name.  The suffix &quot;.Robj&quot; will be appended to the 
user-specified name.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Acceptance rates are re-calculated to be consistent across the new, larger MCMC 
object. The function is also flexible with respect to the model parameterization 
(e.g. - it will recognize, for example, whether users have specified the standard or 
beta-binomial models, or whether users have specified one, or more than one, alphaE 
parameters).
</p>


<h3>Author(s)</h3>

<p>Gideon Bradburd
</p>

<hr>
<h2 id='make.continuing.params'>
Generates an R object containing the last parameter values of an MCMC run (to be 
used for a subsequent run)
</h2><span id='topic+make.continuing.params'></span>

<h3>Description</h3>

<p>This function creates an R object that contains the parameter values read from the 
last generation of a previous MCMC run.  This R object can then be used to initiate
a subsequent analysis, effectively creating a single long chain.  [A single MCMC
object from both runs can be created using the function 
<code>link.up.posteriors</code>].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.continuing.params(MCMC.output, file.name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make.continuing.params_+3A_mcmc.output">MCMC.output</code></td>
<td>

<p>The standard MCMC output file generated from a BEDASSLE run.
</p>
</td></tr>
<tr><td><code id="make.continuing.params_+3A_file.name">file.name</code></td>
<td>

<p>The user-defined name assigned to the R object of parameters to be used in continuing 
analysis.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Gideon Bradburd
</p>

<hr>
<h2 id='MCMC'>
Runs the Markov chain Monte Carlo with the standard (Binomial) model
</h2><span id='topic+MCMC'></span>

<h3>Description</h3>

<p>This function initiates the Markov chain Monte Carlo (MCMC) for the binomial BEDASSLE
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMC(counts, sample_sizes, D, E, k, loci, delta, aD_stp, aE_stp, a2_stp, thetas_stp,
mu_stp, ngen, printfreq, savefreq, samplefreq, directory = NULL, prefix = "", 
continue = FALSE, continuing.params = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MCMC_+3A_counts">counts</code></td>
<td>

<p>A matrix of allelic count data, for which <code>nrow = </code> the number of populations
and <code>ncol = </code> the number of bi-allelic loci sampled.  Each cell gives the number 
of times allele &lsquo;1&rsquo; is observed in each population.  The choice of which allele is 
allele &lsquo;1&rsquo; is arbitrary, but must be consistent across all populations at a locus.
</p>
</td></tr>
<tr><td><code id="MCMC_+3A_sample_sizes">sample_sizes</code></td>
<td>

<p>A matrix of sample sizes, for which <code>nrow = </code> the number of populations
and <code>ncol = </code> the number of bi-allelic loci sampled (i.e. - the dimensions of
<code>sample.sizes</code> must match those of <code>counts</code>).  Each cell gives the number 
of chromosomes successfully genotyped at each locus in each population.
</p>
</td></tr>
<tr><td><code id="MCMC_+3A_d">D</code></td>
<td>

<p>Pairwise geographic distance (<code class="reqn">D_{i,j}</code>).  This can be two-dimensional Euclidean
distance, or great-circle distance, or, in fact, any positive definite matrix (deriving,
for instance, from a resistance distance).  However, note that the algorithm silently
restricts the prior on the alpha parameters, and specifically the alpha_2 parameter, to
the part of parameter space that results in valid covariance matrices; in the case of
two-dimensional Euclidean distances, this will not happen, since any value of alpha_2
between 0 and 2 is valid (see Guillot et al.'s &quot;Valid covariance models for the analysis
of geographical genetic variation&quot; for more detail on this).
</p>
</td></tr>
<tr><td><code id="MCMC_+3A_e">E</code></td>
<td>

<p>Pairwise ecological distance(s) (<code class="reqn">E_{i,j}</code>), which may be continuous (e.g. - 
difference in elevation) or binary (same or opposite side of some hypothesized 
barrier to gene flow).  Users may specify one or more ecological distance matrices.  
If more than one is specified, they should be formatted as a <code>list</code>.
</p>
</td></tr>
<tr><td><code id="MCMC_+3A_k">k</code></td>
<td>

<p>The number of populations in the analysis.  This should be equal to
<code>nrow(</code>counts<code>)</code>.
</p>
</td></tr>
<tr><td><code id="MCMC_+3A_loci">loci</code></td>
<td>

<p>The number of loci in the analysis.  This should be equal to 
<code>ncol(</code>counts<code>)</code>
</p>
</td></tr>
<tr><td><code id="MCMC_+3A_delta">delta</code></td>
<td>

<p>The size of the &quot;delta shift&quot; on the off-diagonal elements of the parametric
covariance matrix, used to ensure its positive-definiteness (even, for example,
when there are separate populations sampled at the same geographic/ecological 
coordinates).  This value must be large enough that the covariance matrix is 
positive-definite, but, if possible, should be smaller than the smallest off-
diagonal distance elements, lest it have an undue impact on inference.  If the 
user is concerned that the delta shift is too large relative to the pairwise 
distance elements in <code>D</code> and <code>E</code>, she should run subsequent analyses, 
varying the size of delta, to see if it has an impact on model inference.
</p>
</td></tr>
<tr><td><code id="MCMC_+3A_ad_stp">aD_stp</code></td>
<td>

<p>The scale of the tuning parameter on aD (alphaD).  The scale of the tuning 
parameter is the standard deviation of the normal distribution from which small
perturbations are made to those parameters updated via a random-walk sampler.
A larger value of the scale of the tuning parameter will lead to, on average, 
larger proposed moves and lower acceptance rates (for more on acceptance rates,
see <code>plot_acceptance_rate</code>).
</p>
</td></tr>
<tr><td><code id="MCMC_+3A_ae_stp">aE_stp</code></td>
<td>

<p>The scale of the tuning parameter on aE (alphaE).  If there are multiple 
ecological distances included in the analysis, there will be multiple alphaE
parameters (one for each matrix in the list of E).  These may be updated all 
with the same scale of a tuning parameter, or they can each get their own, in 
which case aE_stp should be a vector of length equal to the number of ecological
distance variables.
</p>
</td></tr>
<tr><td><code id="MCMC_+3A_a2_stp">a2_stp</code></td>
<td>

<p>The scale of the tuning parameter on a2 (alpha_2).
</p>
</td></tr>
<tr><td><code id="MCMC_+3A_thetas_stp">thetas_stp</code></td>
<td>

<p>The scale of the tuning parameter on the theta parameters.
</p>
</td></tr>
<tr><td><code id="MCMC_+3A_mu_stp">mu_stp</code></td>
<td>

<p>The scale of the tuning parameter on mu.
</p>
</td></tr>
<tr><td><code id="MCMC_+3A_ngen">ngen</code></td>
<td>

<p>The number of generations over which to run the MCMC (one parameter is updated 
at random per generation, with mu, theta, and phi all counting, for the purposes of 
updates, as one parameter).
</p>
</td></tr>
<tr><td><code id="MCMC_+3A_printfreq">printfreq</code></td>
<td>

<p>The frequency with which MCMC progress is printed to the screen.  If 
<code>printfreq =1000</code>, an update with the MCMC generation number and the posterior 
probability at that generation will print to the screen every 1000 generations.
</p>
</td></tr>
<tr><td><code id="MCMC_+3A_savefreq">savefreq</code></td>
<td>

<p>The frequency with which the MCMC saves its output as an R object (<code>savefreq =
50,000</code>
means that MCMC output is saved every 50,000 generations).  If <code>ngen</code> is large, 
this saving process may be computationally expensive, and so should not be performed 
too frequently.  However, users may wish to evalute MCMC performance while the chain 
is still running, or may be forced to truncate runs early, and should therefore 
specify a <code>savefreq</code> that is less than <code>ngen</code>.  We recommend a
<code>savefreq</code>
of between 1/10th and 1/20th of <code>ngen</code>.
</p>
</td></tr>
<tr><td><code id="MCMC_+3A_samplefreq">samplefreq</code></td>
<td>

<p>The thinning of the MCMC chain (<code>samplefreq = 1000</code> means that the parameter 
values saved in the MCMC output are sampled once every 1000 generations).  A higher 
<code>samplefreq</code> will decrease parameter autocorrelation time.  However, there is 
still information in autocorrelated draws from the joint posterior, so the
<code>samplefreq</code> 
should be viewed merely as a computational convenience, to decrease the size of the 
MCMC output objects.
</p>
</td></tr>
<tr><td><code id="MCMC_+3A_directory">directory</code></td>
<td>

<p>If specified, this points to a directory into which output will be saved.
</p>
</td></tr>
<tr><td><code id="MCMC_+3A_prefix">prefix</code></td>
<td>

<p>If specified, this prefix will be added to all output file names.
</p>
</td></tr>
<tr><td><code id="MCMC_+3A_continue">continue</code></td>
<td>

<p>If <code>TRUE</code>, this will initiate the MCMC chain from the last parameter values of a 
previous analysis.  This option can be used to effectively increase the <code>ngen</code> 
of an initial run.  If <code>FALSE</code>, the MCMC will be initiated from random parameter
values.
</p>
</td></tr>
<tr><td><code id="MCMC_+3A_continuing.params">continuing.params</code></td>
<td>

<p>The list of parameter values used to initiate the MCMC if <code>continue = TRUE</code>.  If 
the user wants to continue an analysis on a dataset, these should be the parameter 
values from the last generation of the previous analysis.  This list may be generated 
using the function <code>make.continuing.params</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function saves an MCMC output object at intervals specified by <code>savefreq</code>.  
This object may be ported into R working memory using the <em>base</em> function 
<code>load</code>.
</p>
<p>As with any MCMC method, it is very important here to perform MCMC diagnosis and 
evaluate chain mixing.  I have provided a number of MCMC diagnosis graphing functions 
for user convenience in visually assessing MCMC output.  These include 
<code>plot_all_trace</code>;<code>plot_all_marginals</code>;
<code>plot_all_joint_marginals</code>;
and <code>plot_all_acceptance_rates</code>.  To evaluate model adequacy, users should 
use <code>posterior.predictive.sample</code> and 
<code>plot_posterior_predictive_sample</code>.  These MCMC diagnosis/model adequacy 
functions all call the standard MCMC output R object that the BEDASSLE MCMC generates 
as their principal argument.
</p>
<p>If users wish to start another MCMC run from where the current run left off, they
should use <code>make.continuing.params</code>, and initiate the new run with option 
<code>continue = TRUE</code> and the <code>continuing.params</code> list from the previous run
specified.
</p>


<h3>Author(s)</h3>

<p>Gideon Bradburd
</p>


<h3>References</h3>

<p>Bradburd, G.S., Ralph, P.L., and Coop, G.M. Disentangling the effects of geographic and
ecological
isolation on genetic differentiation. <em>Evolution</em> 2013.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#With the HGDP dataset and mcmc operators
	data(HGDP.bedassle.data)
	data(mcmc.operators)

#The value of delta may set off warnings, 
#so temporarily disable warnings.
	op &lt;- options("warn")
	options(warn = -1)
	
#Call the Markov chain Monte Carlo for the standard model	
## Not run: 
	MCMC(
		counts = HGDP.bedassle.data$allele.counts,
		sample_sizes = HGDP.bedassle.data$sample.sizes,
		D = HGDP.bedassle.data$GeoDistance,
		E = HGDP.bedassle.data$EcoDistance,
		k = HGDP.bedassle.data$number.of.populations,
		loci = HGDP.bedassle.data$number.of.loci,
		delta = mcmc.operators$delta,
		aD_stp = mcmc.operators$aD_stp,
		aE_stp = mcmc.operators$aE_stp,
		a2_stp = mcmc.operators$a2_stp,
		thetas_stp = mcmc.operators$thetas_stp,
		mu_stp = mcmc.operators$mu_stp,
		ngen = mcmc.operators$ngen,
		printfreq = mcmc.operators$printfreq,
		savefreq = mcmc.operators$savefreq,
		samplefreq = mcmc.operators$samplefreq,
		directory = NULL,
		prefix = mcmc.operators$prefix,
		continue = FALSE,
		continuing.params = NULL
	)

## End(Not run)
#Re-enable warnings
	options(op)
</code></pre>

<hr>
<h2 id='MCMC_BB'>
Runs the Markov chain Monte Carlo with the overdispersion (Beta-Binomial) model 
</h2><span id='topic+MCMC_BB'></span>

<h3>Description</h3>

<p>This function initiates the Markov chain Monte Carlo (MCMC) for the beta-binomial 
BEDASSLE model.  The beta-binomial model allows populations to diverge from the
model's
expectations based on their location and their neighbors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMC_BB(counts, sample_sizes, D, E, k, loci, delta, aD_stp, aE_stp, a2_stp, phi_stp,
thetas_stp, mu_stp, ngen, printfreq, savefreq, samplefreq, directory = NULL, prefix = "", 
continue = FALSE, continuing.params = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MCMC_BB_+3A_counts">counts</code></td>
<td>

<p>A matrix of allelic count data, for which <code>nrow = </code> the number of populations
and <code>ncol = </code> the number of bi-allelic loci sampled.  Each cell gives the number 
of times allele &lsquo;1&rsquo; is observed in each population.  The choice of which allele is 
allele &lsquo;1&rsquo; is arbitrary, but must be consistent across all populations at a locus.
</p>
</td></tr>
<tr><td><code id="MCMC_BB_+3A_sample_sizes">sample_sizes</code></td>
<td>

<p>A matrix of sample sizes, for which <code>nrow = </code> the number of populations
and <code>ncol = </code> the number of bi-allelic loci sampled (i.e. - the dimensions of
<code>sample.sizes</code> must match those of <code>counts</code>).  Each cell gives the number 
of chromosomes successfully genotyped at each locus in each population.
</p>
</td></tr>
<tr><td><code id="MCMC_BB_+3A_d">D</code></td>
<td>

<p>Pairwise geographic distance (<code class="reqn">D_{i,j}</code>).  This can be two-dimensional Euclidean
distance, or great-circle distance, or, in fact, any positive definite matrix (deriving,
for instance, from a resistance distance).  However, note that the algorithm silently
restricts the prior on the alpha parameters, and specifically the alpha_2 parameter, to
the part of parameter space that results in valid covariance matrices; in the case of
two-dimensional Euclidean distances, this will not happen, since any value of alpha_2
between 0 and 2 is valid (see Guillot et al.'s &quot;Valid covariance models for the analysis
of geographical genetic variation&quot; for more detail on this).
</p>
</td></tr>
<tr><td><code id="MCMC_BB_+3A_e">E</code></td>
<td>

<p>Pairwise ecological distance(s) (<code class="reqn">E_{i,j}</code>), which may be continuous (e.g. - 
difference in elevation) or binary (same or opposite side of some hypothesized 
barrier to gene flow).  Users may specify one or more ecological distance matrices.  
If more than one is specified, they should be formatted as a <code>list</code>.
</p>
</td></tr>
<tr><td><code id="MCMC_BB_+3A_k">k</code></td>
<td>

<p>The number of populations in the analysis.  This should be equal to
<code>nrow(</code>counts<code>)</code>.
</p>
</td></tr>
<tr><td><code id="MCMC_BB_+3A_loci">loci</code></td>
<td>

<p>The number of loci in the analysis.  This should be equal to 
<code>ncol(</code>counts<code>)</code>
</p>
</td></tr>
<tr><td><code id="MCMC_BB_+3A_delta">delta</code></td>
<td>

<p>The size of the &quot;delta shift&quot; on the off-diagonal elements of the parametric
covariance matrix, used to ensure its positive-definiteness (even, for example,
when there are separate populations sampled at the same geographic/ecological 
coordinates).  This value must be large enough that the covariance matrix is 
positive-definite, but, if possible, should be smaller than the smallest off-
diagonal distance elements, lest it have an undue impact on inference.  If the 
user is concerned that the delta shift is too large relative to the pairwise 
distance elements in <code>D</code> and <code>E</code>, she should run subsequent analyses, 
varying the size of delta, to see if it has an impact on model inference.
</p>
</td></tr>
<tr><td><code id="MCMC_BB_+3A_ad_stp">aD_stp</code></td>
<td>

<p>The scale of the tuning parameter on aD (alphaD).  The scale of the tuning 
parameter is the standard deviation of the normal distribution from which small
perturbations are made to those parameters updated via a random-walk sampler.
A larger value of the scale of the tuning parameter will lead to, on average, 
larger proposed moves and lower acceptance rates (for more on acceptance rates,
see <code>plot_acceptance_rate</code>).
</p>
</td></tr>
<tr><td><code id="MCMC_BB_+3A_ae_stp">aE_stp</code></td>
<td>

<p>The scale of the tuning parameter on aE (alphaE).  If there are multiple 
ecological distances included in the analysis, there will be multiple alphaE
parameters (one for each matrix in the list of E).  These may be updated all 
with the same scale of a tuning parameter, or they can each get their own, in 
which case aE_stp should be a vector of length equal to the number of ecological
distance variables.
</p>
</td></tr>
<tr><td><code id="MCMC_BB_+3A_a2_stp">a2_stp</code></td>
<td>

<p>The scale of the tuning parameter on a2 (alpha_2).
</p>
</td></tr>
<tr><td><code id="MCMC_BB_+3A_phi_stp">phi_stp</code></td>
<td>

<p>The scale of the tuning parameter on the phi parameters.
</p>
</td></tr>
<tr><td><code id="MCMC_BB_+3A_thetas_stp">thetas_stp</code></td>
<td>

<p>The scale of the tuning parameter on the theta parameters.
</p>
</td></tr>
<tr><td><code id="MCMC_BB_+3A_mu_stp">mu_stp</code></td>
<td>

<p>The scale of the tuning parameter on mu.
</p>
</td></tr>
<tr><td><code id="MCMC_BB_+3A_ngen">ngen</code></td>
<td>

<p>The number of generations over which to run the MCMC (one parameter is updated 
at random per generation, with mu, theta, and phi all counting, for the purposes of 
updates, as one parameter).
</p>
</td></tr>
<tr><td><code id="MCMC_BB_+3A_printfreq">printfreq</code></td>
<td>

<p>The frequency with which MCMC progress is printed to the screen.  If 
<code>printfreq =1000</code>, an update with the MCMC generation number and the posterior 
probability at that generation will print to the screen every 1000 generations.
</p>
</td></tr>
<tr><td><code id="MCMC_BB_+3A_savefreq">savefreq</code></td>
<td>

<p>The frequency with which the MCMC saves its output as an R object (<code>savefreq =
50,000</code>
means that MCMC output is saved every 50,000 generations).  If <code>ngen</code> is large, 
this saving process may be computationally expensive, and so should not be performed 
too frequently.  However, users may wish to evalute MCMC performance while the chain 
is still running, or may be forced to truncate runs early, and should therefore 
specify a <code>savefreq</code> that is less than <code>ngen</code>.  We recommend a
<code>savefreq</code>
of between 1/10th and 1/20th of <code>ngen</code>.
</p>
</td></tr>
<tr><td><code id="MCMC_BB_+3A_samplefreq">samplefreq</code></td>
<td>

<p>The thinning of the MCMC chain (<code>samplefreq = 1000</code> means that the parameter 
values saved in the MCMC output are sampled once every 1000 generations).  A higher 
<code>samplefreq</code> will decrease parameter autocorrelation time.  However, there is 
still information in autocorrelated draws from the joint posterior, so the
<code>samplefreq</code> 
should be viewed merely as a computational convenience, to decrease the size of the 
MCMC output objects.
</p>
</td></tr>
<tr><td><code id="MCMC_BB_+3A_directory">directory</code></td>
<td>

<p>If specified, this points to a directory into which output will be saved.
</p>
</td></tr>
<tr><td><code id="MCMC_BB_+3A_prefix">prefix</code></td>
<td>

<p>If specified, this prefix will be added to all output file names.
</p>
</td></tr>
<tr><td><code id="MCMC_BB_+3A_continue">continue</code></td>
<td>

<p>If <code>TRUE</code>, this will initiate the MCMC chain from the last parameter values of a 
previous analysis.  This option can be used to effectively increase the <code>ngen</code> 
of an initial run.  If <code>FALSE</code>, the MCMC will be initiated from random parameter
values.
</p>
</td></tr>
<tr><td><code id="MCMC_BB_+3A_continuing.params">continuing.params</code></td>
<td>

<p>The list of parameter values used to initiate the MCMC if <code>continue = TRUE</code>.  If 
the user wants to continue an analysis on a dataset, these should be the parameter 
values from the last generation of the previous analysis.  This list may be generated 
using the function <code>make.continuing.params</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function saves an MCMC output object at intervals specified by <code>savefreq</code>.  
This object may be ported into R working memory using the <em>base</em> function 
<code>load</code>.
</p>
<p>As with any MCMC method, it is very important here to perform MCMC diagnosis and 
evaluate chain mixing.  I have provided a number of MCMC diagnosis graphing functions 
for user convenience in visually assessing MCMC output.  These include 
<code>plot_all_trace</code>;<code>plot_all_marginals</code>;
<code>plot_all_joint_marginals</code>;
and <code>plot_all_acceptance_rates</code>.  To evaluate model adequacy, users should 
use <code>posterior.predictive.sample</code> and 
<code>plot_posterior_predictive_sample</code>. These MCMC diagnosis/model adequacy 
functions all call the standard MCMC output R object that the BEDASSLE MCMC generates 
as their principal argument. 
</p>
<p>If users wish to start another MCMC run from where the current run left off, they 
should use <code>make.continuing.params</code>, and initiate the new run with option 
<code>continue = TRUE</code> and the <code>continuing.params</code> list from the previous 
run specified.
</p>


<h3>Author(s)</h3>

<p>Gideon Bradburd
</p>


<h3>References</h3>

<p>Bradburd, G.S., Ralph, P.L., and Coop, G.M. Disentangling the effects of geographic and
ecological
isolation on genetic differentiation. <em>Evolution</em> 2013.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#With the HGDP dataset and mcmc operators

	data(HGDP.bedassle.data)
	data(mcmc.operators)

#The beta-binomial likelihood function may generate "NaNs produced" warnings, 
#so temporarily disable warnings.
	op &lt;- options("warn")
	options(warn = -1)

#Call the Markov chain Monte Carlo for the overdispersion model	
## Not run: 
	MCMC_BB(
		counts = HGDP.bedassle.data$allele.counts,
		sample_sizes = HGDP.bedassle.data$sample.sizes,
		D = HGDP.bedassle.data$GeoDistance,
		E = HGDP.bedassle.data$EcoDistance,
		k = HGDP.bedassle.data$number.of.populations,
		loci = HGDP.bedassle.data$number.of.loci,
		delta = mcmc.operators$delta,
		aD_stp = mcmc.operators$aD_stp,
		aE_stp = mcmc.operators$aE_stp,
		a2_stp = mcmc.operators$a2_stp,
		phi_stp = mcmc.operators$phi_stp,
		thetas_stp = mcmc.operators$thetas_stp,
		mu_stp = mcmc.operators$mu_stp,
		ngen = mcmc.operators$ngen,
		printfreq = mcmc.operators$printfreq,
		savefreq = mcmc.operators$savefreq,
		samplefreq = mcmc.operators$samplefreq,
		directory = NULL,
		prefix = mcmc.operators$prefix,
		continue = FALSE,
		continuing.params = NULL
	)

## End(Not run)
#Re-enable warnings
	options(op)
</code></pre>

<hr>
<h2 id='mcmc.operators'>
Operator parameters that control the operation of the MCMC
</h2><span id='topic+mcmc.operators'></span>

<h3>Description</h3>

<p>These parameters, which are passed to the <code>MCMC</code> and <code>MCMC_BB</code> 
functions, control the operation of the MCMC.  They specify the number of 
generations over which the MCMC runs; the scales of the tuning parameters (stp)
for all parameters updated via random-walk samplers; the save, print, and 
sample frequency of the chain, and the output file names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mcmc.operators)</code></pre>


<h3>Format</h3>

<p>The format is:
List of 12
</p>

<dl>
<dt>$ delta     :</dt><dd><p> num 0.001</p>
</dd>
<dt>$ aD_stp    :</dt><dd><p> num 0.0018</p>
</dd>
<dt>$ aE_stp    :</dt><dd><p> num 0.04</p>
</dd>
<dt>$ a2_stp    :</dt><dd><p> num 0.0035</p>
</dd>
<dt>$ phi_stp   :</dt><dd><p> num 30</p>
</dd>
<dt>$ thetas_stp:</dt><dd><p> num 0.07</p>
</dd>
<dt>$ mu_stp    :</dt><dd><p> num 0.17</p>
</dd>
<dt>$ ngen      :</dt><dd><p> num 100</p>
</dd>
<dt>$ printfreq :</dt><dd><p> num 2</p>
</dd>
<dt>$ savefreq  :</dt><dd><p> num 100</p>
</dd>
<dt>$ samplefreq:</dt><dd><p> num 5</p>
</dd>
<dt>$ prefix    :</dt><dd><p> chr &quot;example_&quot;</p>
</dd>
</dl>



<h3>Details</h3>


<dl>
<dt>delta</dt><dd><p>The size of the &quot;delta shift&quot; on the off-diagonal elements of the 
parametric covariance matrix, used to ensure its positive-definiteness (even, 
for example, when there are separate populations sampled at the same 
geographic/ecological coordinates).  This value must be large enough that the 
covariance matrix is positive-definite, but, if possible, should be smaller 
than the smallest off-diagonal distance elements, lest it have an undue 
impact on inference.  If the user is concerned that the delta shift is too 
large relative to the pairwise distance elements in <code>D</code> and <code>E</code>, 
she should run subsequent analyses, varying the size of delta, to see if it 
has an impact on model inference.</p>
</dd>
<dt>aD_stp</dt><dd><p>The scale of the tuning parameter on aD (alphaD).  The scale of the 
tuning parameter is the standard deviation of the normal distribution from 
which small perturbations are made to those parameters updated via a 
random-walk sampler. A larger value of the scale of the tuning parameter will 
lead to, on average, larger proposed moves and lower acceptance rates (for 
more on acceptance rates, see <code>plot_acceptance_rate</code>).</p>
</dd>
<dt>aE_stp</dt><dd><p>The scale of the tuning parameter on aE (alphaE).  If there are 
multiple ecological distances included in the analysis, there will be 
multiple alphaE parameters (one for each matrix in the list of E).  These may 
be updated all with the same scale of a tuning parameter, or they can each 
get their own, in which case aE_stp should be a vector of length equal to the 
number of ecological distance variables.</p>
</dd>
<dt>a2_stp</dt><dd><p>The scale of the tuning parameter on a2 (alpha_2).</p>
</dd>
<dt>phi_stp</dt><dd><p>The scale of the tuning parameter on the phi parameters.</p>
</dd>
<dt>thetas_stp</dt><dd><p>The scale of the tuning parameter on the theta parameters.</p>
</dd>
<dt>mu_stp</dt><dd><p>The scale of the tuning parameter on mu.</p>
</dd>
<dt>ngen</dt><dd><p>The number of generations over which to run the MCMC (one parameter 
is updated at random per generation, with mu, theta, and phi all counting, 
for the purposes of updates, as one parameter).</p>
</dd>
<dt>printfreq</dt><dd><p>	The frequency with which MCMC progress is printed to the 
screen.  If <code>printfreq =1000</code>, an update with the MCMC generation number 
and the posterior probability at that generation will print to the screen 
every 1000 generations.</p>
</dd>
<dt>savefreq</dt><dd><p>The frequency with which the MCMC saves its output as an R 
object (<code>savefreq =50,000</code> means that MCMC output is saved every 50,000 
generations).  If <code>ngen</code> is large, this saving process may be 
computationally expensive, and so should not be performed too frequently.  
However, users may wish to evalute MCMC performance while the chain is still 
running, or may be forced to truncate runs early, and should therefore 
specify a <code>savefreq</code> that is less than <code>ngen</code>.  We recommend a 
<code>savefreq</code> of between 1/10th and 1/20th of <code>ngen</code>.</p>
</dd>
<dt>samplefreq</dt><dd><p>The thinning of the MCMC chain (<code>samplefreq = 1000</code> means 
that the parameter values saved in the MCMC output are sampled once every 
1000 generations).  A higher <code>samplefreq</code> will decrease parameter 
autocorrelation time.  However, there is still information in autocorrelated 
draws from the joint posterior, so the <code>samplefreq</code> should be viewed 
merely as a computational convenience, to decrease the size of the MCMC 
output objects.</p>
</dd>
<dt>prefix</dt><dd><p>If specified, this prefix will be added to all output file names.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## see \command{MCMC} and \command{MCMC_BB} for example usage.
</code></pre>

<hr>
<h2 id='plot_acceptance_rate'>
Plots the acceptance rate of a parameter across MCMC generations
</h2><span id='topic+plot_acceptance_rate'></span>

<h3>Description</h3>

<p>Creates a plot showing the proportion of proposed moves to accepted moves over the 
duration of the MCMC analysis. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_acceptance_rate(accepted.moves, proposed.moves, param.name =
deparse(substitute(accepted.moves)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_acceptance_rate_+3A_accepted.moves">accepted.moves</code></td>
<td>

<p>A vector giving the number of accepted random-walk moves at each sampled MCMC 
generation.
</p>
</td></tr>
<tr><td><code id="plot_acceptance_rate_+3A_proposed.moves">proposed.moves</code></td>
<td>

<p>A vector giving the number of proposed random-walk moves at each sampled MCMC 
generation.
</p>
</td></tr>
<tr><td><code id="plot_acceptance_rate_+3A_param.name">param.name</code></td>
<td>

<p>The name of the parameter for which the trace plot is being displayed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For optimal mixing, between ~20
samplers should be accepted.  If the acceptance rates fall outside that range, this 
function will automatically highlight that parameter as a potential instance of poor
mixing.  If the acceptance rates are too low, then for subsequent analyses the user 
should <em>decrease</em> the scale of the tuning parameter (or &quot;std,&quot; as in, e.g., 
&quot;aD_std&quot;), and if acceptance rates are too high, the user should <em>increase</em> the 
scale of the tuning parameter.  The scale of the tuning parameter is the standard 
deviation of the normal distribution from which the small random variable is drawn 
and added to the current parameter value to propose a move.  If the acceptance rate 
has not plateaued by the end of an analysis, it is an indication that the chain may 
still be &quot;going somewhere&quot; in parameter space, and subsequent analyses should be 
performed.
</p>


<h3>Author(s)</h3>

<p>Gideon Bradburd
</p>

<hr>
<h2 id='plot_all_acceptance_rates'>
Plots the acceptance rates of all parameters across MCMC generations
</h2><span id='topic+plot_all_acceptance_rates'></span>

<h3>Description</h3>

<p>Creates a series of plots showing the proportion of proposed moves to accepted moves 
over the duration of the MCMC analysis for each parameter updated via a random-walk
sampler. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_all_acceptance_rates(MCMC.output)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_all_acceptance_rates_+3A_mcmc.output">MCMC.output</code></td>
<td>

<p>The standard MCMC output file generated from a BEDASSLE run.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For optimal mixing, between ~20
samplers should be accepted.  If the acceptance rates fall outside that range, this 
function will automatically highlight that parameter as a potential instance of poor
mixing.  If the acceptance rates are too low, then for subsequent analyses the user 
should <em>decrease</em> the scale of the tuning parameter (or &quot;std,&quot; as in, e.g., 
<code>aD_std</code>), and if acceptance rates are too high, the user should <em>increase</em> 
the scale of the tuning parameter.  The scale of the tuning parameter is the standard 
deviation of the normal distribution from which the small random variable is drawn 
and added to the current parameter value to propose a move.   If the acceptance rate 
has not plateaued by the end of an analysis, it is an indication that the chain may 
still be &quot;going somewhere&quot; in parameter space, and subsequent analyses should be 
performed.
</p>


<h3>Author(s)</h3>

<p>Gideon Bradburd
</p>

<hr>
<h2 id='plot_all_joint_marginals'>
Plots the joint marginals for all parameter pairs
</h2><span id='topic+plot_all_joint_marginals'></span>

<h3>Description</h3>

<p>For each sampled MCMC generation, the values estimated for a pair of parameters are 
logged and plotted against one another.  Points are color coded by when in the 
analysis they were sampled, so that users can visually assess mixing.  A joint 
marginal plot is generated for all combinations of parameters, excluding the phi 
parameters estimated in the beta-binomial model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_all_joint_marginals(MCMC.output, percent.burnin = 0, thinning = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_all_joint_marginals_+3A_mcmc.output">MCMC.output</code></td>
<td>

<p>The standard MCMC output file generated from a BEDASSLE run.
</p>
</td></tr>
<tr><td><code id="plot_all_joint_marginals_+3A_percent.burnin">percent.burnin</code></td>
<td>

<p>The percent of the sampled MCMC generations to be discarded as &quot;burn-in.&quot;  If the 
MCMC is run for 1,000,000 generations, and sampled every 1,000 generations, there 
will be 1,000 sampled generations.  A <code>percent.burnin</code> of <code>20</code> will 
discard the first 200 sampled parameter values from that sample.
</p>
</td></tr>
<tr><td><code id="plot_all_joint_marginals_+3A_thinning">thinning</code></td>
<td>

<p>The multiple by which the sampled MCMC generations are thinned.  A <code>thinning</code> of
<code>5</code> will sample every 5th MCMC generation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Visualizations of the joint marginal distributions allow users to (1) assess how well 
the MCMC is mixing, and (2) potentially diagnose instances of non-identifiability in
the model.  Strong linear trends in the joint marginal, or visible &quot;ridges&quot; in the 
likelihood surface, may be indicative of parameter non-identifiability, in which 
multiple combinations of values of these two parameters provide equally reasonable 
fits to the data.
</p>


<h3>Author(s)</h3>

<p>Gideon Bradburd
</p>

<hr>
<h2 id='plot_all_marginals'>
Plots the marginal densities for all parameters
</h2><span id='topic+plot_all_marginals'></span>

<h3>Description</h3>

<p>Plots the posterior marginal density of all parameters.  Users may specify whether 
they want a histogram, a density, or both.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_all_marginals(MCMC.output, percent.burnin = 0, thinning = 1, 
population.names = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_all_marginals_+3A_mcmc.output">MCMC.output</code></td>
<td>

<p>The standard MCMC output file generated from a BEDASSLE run.
</p>
</td></tr>
<tr><td><code id="plot_all_marginals_+3A_percent.burnin">percent.burnin</code></td>
<td>

<p>The percent of the sampled MCMC generations to be discarded as &quot;burn-in.&quot;  If the 
MCMC is run for 1,000,000 generations, and sampled every 1,000 generations, there 
will be 1,000 sampled generations.  A <code>percent.burnin</code> of <code>20</code> will 
discard the first 200 sampled parameter values from that sample.
</p>
</td></tr>
<tr><td><code id="plot_all_marginals_+3A_thinning">thinning</code></td>
<td>

<p>The multiple by which the sampled MCMC generations are thinned.  A <code>thinning</code> of
<code>5</code> will sample every 5th MCMC generation.
</p>
</td></tr>
<tr><td><code id="plot_all_marginals_+3A_population.names">population.names</code></td>
<td>

<p>A vector of length <code>k</code>, where <code>k</code> is the number of populations/individuals 
(i.e. <code>k = nrow(counts)</code>), giving the name or identifier of each 
population/individual included in the analysis.  These will be used to title the 
<code>k</code> marginal plots of the phi parameters estimated for each 
population/individual in the beta-binomial model.  If the binomial model is used, 
<code>population.names</code> will not be used by this function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The marginal plot is another basic visual tool for MCMC diagnosis.  Users should look
for marginal plots that are &quot;smooth as eggs&quot; (indicating that the chain has been run 
long enough) and unimodal (indicating a single peak in the likelihood surface).
</p>


<h3>Author(s)</h3>

<p>Gideon Bradburd
</p>

<hr>
<h2 id='plot_all_phi_marginals'>
Plot all the marginals for the phi parameters for all populations
</h2><span id='topic+plot_all_phi_marginals'></span>

<h3>Description</h3>

<p>Plots the posterior marginal densities of all phi parameters.  Users may specify
whether they want a histogram, a density, or both.  For convenience, the <code class="reqn">F_{k}</code> 
statistic is presented in place of the phi parameter, as this is the statistic users
care about. <code class="reqn">F_{k}</code> is defined as <code class="reqn">\frac{1}{1+phi_{k}}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_all_phi_marginals(phi_mat, percent.burnin = 0, thinning = 1, 
population.names = NULL, pop.index= NULL, histogram = TRUE, density = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_all_phi_marginals_+3A_phi_mat">phi_mat</code></td>
<td>

<p>The <code>k</code> by <code>ngen</code> matrix of phi values estimated for all <code>k</code> 
populations/individuals included in the analysis in each of <code>ngen</code> MCMC
generations.
</p>
</td></tr>
<tr><td><code id="plot_all_phi_marginals_+3A_percent.burnin">percent.burnin</code></td>
<td>

<p>The percent of the sampled MCMC generations to be discarded as &quot;burn-in.&quot;  If the 
MCMC is run for 1,000,000 generations, and sampled every 1,000 generations, there 
will be 1,000 sampled generations.  A <code>percent.burnin</code> of <code>20</code> will discard 
the first 200 sampled parameter values from that sample.
</p>
</td></tr>
<tr><td><code id="plot_all_phi_marginals_+3A_thinning">thinning</code></td>
<td>

<p>The multiple by which the sampled MCMC generations are thinned.  A <code>thinning</code> of
<code>5</code> will sample every 5th MCMC generation.
</p>
</td></tr>
<tr><td><code id="plot_all_phi_marginals_+3A_population.names">population.names</code></td>
<td>

<p>A vector of length <code>k</code>, where <code>k</code> is the number of populations/individuals 
(i.e. <code>k = nrow(counts)</code>), giving the name or identifier of each 
population/individual included in the analysis.  These will be used to title the
<code>k</code>
trace plots of the phi parameters estimated for each population/individual in the
beta-
binomial model. If <code>population.names</code> is not provided (i.e.
<code>population.names =
NULL</code>), 
a population index number will be used to title the plot.
</p>
</td></tr>
<tr><td><code id="plot_all_phi_marginals_+3A_pop.index">pop.index</code></td>
<td>

<p>A population index number generated to title a marginal plot if no
<code>population.names</code>
is specified.
</p>
</td></tr>
<tr><td><code id="plot_all_phi_marginals_+3A_histogram">histogram</code></td>
<td>

<p>A switch that controls whether or not the plot contains a histogram of the values 
estimated for the parameter over the course of the MCMC.  Default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="plot_all_phi_marginals_+3A_density">density</code></td>
<td>

<p>A switch that controls whether or not the plot shows the density of the values 
estimated for the parameter over the course of the MCMC.  Default is <code>TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The marginal plot is another basic visual tool for MCMC diagnosis.  Users should look
for marginal plots that are &quot;smooth as eggs&quot; (indicating that the chain has been run 
long enough) and unimodal (indicating a single peak in the likelihood surface).
</p>


<h3>Author(s)</h3>

<p>Gideon Bradburd
</p>

<hr>
<h2 id='plot_all_phi_trace'>
Plots all the trace plots for the phi parameters for all populations
</h2><span id='topic+plot_all_phi_trace'></span>

<h3>Description</h3>

<p>Plots all trace plots for the phi parameters in all populations.  For convenience, 
the <code class="reqn">F_{k}</code> statistic is presented in place of the phi parameter, as this is the 
statistic users care about.  <code class="reqn">F_{k}</code> is defined as <code class="reqn">\frac{1}{1+phi_{k}}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_all_phi_trace(phi_mat, percent.burnin = 0, thinning = 1, population.names = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_all_phi_trace_+3A_phi_mat">phi_mat</code></td>
<td>

<p>The <code>k</code> by <code>ngen</code> matrix of phi values estimated for all <code>k</code> 
populations/individuals included in the analysis in each of <code>ngen</code> MCMC 
generations.
</p>
</td></tr>
<tr><td><code id="plot_all_phi_trace_+3A_percent.burnin">percent.burnin</code></td>
<td>

<p>The percent of the sampled MCMC generations to be discarded as &quot;burn-in.&quot;  If the 
MCMC is run for 1,000,000 generations, and sampled every 1,000 generations, there 
will be 1,000 sampled generations.  A <code>percent.burnin</code> of <code>20</code> will 
discard the first 200 sampled parameter values from that sample.
</p>
</td></tr>
<tr><td><code id="plot_all_phi_trace_+3A_thinning">thinning</code></td>
<td>

<p>The multiple by which the sampled MCMC generations are thinned.  A <code>thinning</code> of
<code>5</code> will sample every 5th MCMC generation.
</p>
</td></tr>
<tr><td><code id="plot_all_phi_trace_+3A_population.names">population.names</code></td>
<td>

<p>A vector of length <code>k</code>, where <code>k</code> is the number of populations/individuals 
(i.e. <code>k = nrow(counts)</code>), giving the name or identifier of each 
population/individual included in the analysis.  These will be used to title the 
<code>k</code> trace plots of the phi parameters estimated for each population/individual 
in the beta-binomial model. If <code>population.names</code> is not provided 
(i.e. <code>population.names =NULL</code>), a population index number will be used to 
title the plot.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A trace plot is a basic visual tool for assessing MCMC mixing.  If the chain is 
mixing well, the trace plot will resemble a &quot;fuzzy caterpillar.&quot;  If the trace plot 
has not plateaued, it is an indication that the chain has not converged on the 
stationary posterior distribution, and must be run longer.  If the trace plot of a 
parameter exhibits high autocorrelation, the user may wish to either increase or 
decrease the scale of the tuning parameter on that parameter, to decrease or increase 
acceptance rates, respectively.  If the chain appears to be bouncing between areas 
of &quot;fuzzy caterpillar-dom,&quot; it may be an indication of a multi-modal likelihood 
surface.
</p>


<h3>Author(s)</h3>

<p>Gideon Bradburd
</p>

<hr>
<h2 id='plot_all_trace'>
Plots all the trace plots for all parameters
</h2><span id='topic+plot_all_trace'></span>

<h3>Description</h3>

<p>This function plots the parameter value estimated in each sampled generation of the 
MCMC against the index of that sampled generation for each parameter in the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_all_trace(MCMC.output, percent.burnin = 0, thinning = 1, population.names = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_all_trace_+3A_mcmc.output">MCMC.output</code></td>
<td>

<p>The standard MCMC output file generated from a BEDASSLE run.
</p>
</td></tr>
<tr><td><code id="plot_all_trace_+3A_percent.burnin">percent.burnin</code></td>
<td>

<p>The percent of the sampled MCMC generations to be discarded as &quot;burn-in.&quot;  If the 
MCMC is run for 1,000,000 generations, and sampled every 1,000 generations, there 
will be 1,000 sampled generations.  A <code>percent.burnin</code> of <code>20</code> will 
discard the first 200 sampled parameter values from that sample.
</p>
</td></tr>
<tr><td><code id="plot_all_trace_+3A_thinning">thinning</code></td>
<td>

<p>The multiple by which the sampled MCMC generations are thinned.  A <code>thinning</code> of
<code>5</code> will sample every 5th MCMC generation.
</p>
</td></tr>
<tr><td><code id="plot_all_trace_+3A_population.names">population.names</code></td>
<td>

<p>A vector of length <code>k</code>, where <code>k</code> is the number of populations/individuals 
(i.e. <code>k = nrow(counts)</code>), giving the name or identifier of each 
population/individual included in the analysis.  These will be used to title the 
<code>k</code> trace plots of the phi parameters estimated for each population/individual 
in the beta-binomial model.  If the binomial model is used, <code>population.names</code> 
will not be used by this function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A trace plot is a basic visual tool for assessing MCMC mixing.  If the chain is mixing
well, the trace plot will resemble a &quot;fuzzy caterpillar.&quot;  If the trace plot has not 
plateaued, it is an indication that the chain has not converged on the stationary 
posterior distribution, and must be run longer.  If the trace plot of a parameter 
exhibits high autocorrelation, the user may wish to either increase or decrease the 
scale of the tuning parameter on that parameter, to decrease or increase acceptance 
rates, respectively.  If the chain appears to be bouncing between areas of &quot;fuzzy
caterpillar-dom,&quot; it may be an indication of a multi-modal likelihood surface.
</p>


<h3>Author(s)</h3>

<p>Gideon Bradburd
</p>

<hr>
<h2 id='plot_joint_marginal'>
Plots the joint marginal for a pair of parameters
</h2><span id='topic+plot_joint_marginal'></span>

<h3>Description</h3>

<p>For each sampled MCMC generation, the values estimated for a pair of parameters are 
logged and plotted against one another.  Points are color coded by when in the 
analysis they were sampled, so that users can visually assess mixing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_joint_marginal(parameter1, parameter2, percent.burnin = 0, thinning = 1, 
param.name1 = deparse(substitute(parameter1)), 
param.name2 = deparse(substitute(parameter2)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_joint_marginal_+3A_parameter1">parameter1</code></td>
<td>

<p>One of the two parameters for which the joint marginal is being plotted.
</p>
</td></tr>
<tr><td><code id="plot_joint_marginal_+3A_parameter2">parameter2</code></td>
<td>

<p>The other of the two parameters for which the joint marginal is being plotted.
</p>
</td></tr>
<tr><td><code id="plot_joint_marginal_+3A_percent.burnin">percent.burnin</code></td>
<td>

<p>The percent of the sampled MCMC generations to be discarded as &quot;burn-in.&quot;  If the 
MCMC is run for 1,000,000 generations, and sampled every 1,000 generations, there 
will be 1,000 sampled generations.  A <code>percent.burnin</code> of <code>20</code> will discard 
the first 200 sampled parameter values from that sample.
</p>
</td></tr>
<tr><td><code id="plot_joint_marginal_+3A_thinning">thinning</code></td>
<td>

<p>The multiple by which the sampled MCMC generations are thinned.  A <code>thinning</code> of
<code>5</code> will sample every 5th MCMC generation.
</p>
</td></tr>
<tr><td><code id="plot_joint_marginal_+3A_param.name1">param.name1</code></td>
<td>

<p>The name of one of the two parameters for which the joint marginal is being plotted.
</p>
</td></tr>
<tr><td><code id="plot_joint_marginal_+3A_param.name2">param.name2</code></td>
<td>

<p>The name of the other of the two parameters for which the joint marginal is being 
plotted.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Visualizations of the joint marginal distribution allow users to (1) assess how well 
the MCMC is mixing, and (2) potentially diagnose instances of non-identifiability in
the model.  Strong linear trends in the joint marginal, or visible &quot;ridges&quot; in the 
likelihood surface, may be indicative of parameter non-identifiability, in which 
multiple combinations of values of these two parameters provide equally reasonable 
fits to the data.
</p>


<h3>Author(s)</h3>

<p>Gideon Bradburd
</p>

<hr>
<h2 id='plot_marginal'>
Plots the marginal density of a parameter
</h2><span id='topic+plot_marginal'></span>

<h3>Description</h3>

<p>Plots the posterior marginal density of a parameter.  Users may specify whether they 
want a histogram, a density, or both.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_marginal(parameter, percent.burnin = 0, thinning = 1, histogram = TRUE, 
density = TRUE, population.names = NULL, param.name = deparse(substitute(parameter)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_marginal_+3A_parameter">parameter</code></td>
<td>

<p>The parameter for which the marginal plot is being generated.
</p>
</td></tr>
<tr><td><code id="plot_marginal_+3A_percent.burnin">percent.burnin</code></td>
<td>

<p>The percent of the sampled MCMC generations to be discarded as &quot;burn-in.&quot;  If the 
MCMC is run for 1,000,000 generations, and sampled every 1,000 generations, there 
will be 1,000 sampled generations.  A <code>percent.burnin</code> of <code>20</code> will discard 
the first 200 sampled parameter values from that sample.
</p>
</td></tr>
<tr><td><code id="plot_marginal_+3A_thinning">thinning</code></td>
<td>

<p>The multiple by which the sampled MCMC generations are thinned.  A <code>thinning</code> of
<code>5</code> will sample every 5th MCMC generation.
</p>
</td></tr>
<tr><td><code id="plot_marginal_+3A_histogram">histogram</code></td>
<td>

<p>A switch that controls whether or not the plot contains a histogram of the values 
estimated for the parameter over the course of the MCMC.  Default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="plot_marginal_+3A_density">density</code></td>
<td>

<p>A switch that controls whether or not the plot shows the density of the values 
estimated for the parameter over the course of the MCMC.  Default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="plot_marginal_+3A_population.names">population.names</code></td>
<td>

<p>A vector of length <code>k</code>, where <code>k</code> is the number of populations/individuals 
(i.e. <code>k = nrow(counts)</code>), giving the name or identifier of each 
population/individual included in the analysis.  These will be used to title the 
<code>k</code> marginal plots of the phi parameters estimated for each 
population/individual in the beta-binomial model.  If the binomial model is used, 
<code>population.names</code> will not be used by this function.
</p>
</td></tr>
<tr><td><code id="plot_marginal_+3A_param.name">param.name</code></td>
<td>

<p>The name of the parameter for which the trace plot is being displayed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The marginal plot is another basic visual tool for MCMC diagnosis.  Users should look
for marginal plots that are &quot;smooth as eggs&quot; (indicating that the chain has been run 
long enough) and unimodal (indicating a single peak in the likelihood surface).
</p>


<h3>Author(s)</h3>

<p>Gideon Bradburd
</p>

<hr>
<h2 id='plot_phi_marginal'>
Plots the marginal for the phi parameter estimated in a single population
</h2><span id='topic+plot_phi_marginal'></span>

<h3>Description</h3>

<p>Plots the posterior marginal density of a phi parameter.  Users may specify whether 
they want a histogram, a density, or both.  For convenience, the <code class="reqn">F_{k}</code> 
statistic is presented in place of the phi parameter, as this is the statistic users 
care about.  <code class="reqn">F_{k}</code> is defined as <code class="reqn">\frac{1}{1+phi_{k}}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_phi_marginal(phi, percent.burnin = 0, thinning = 1, population.names = NULL, 
pop.index = NULL,histogram = TRUE, density = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_phi_marginal_+3A_phi">phi</code></td>
<td>

<p>The vector of phi values estimated for a single population from an MCMC run.
</p>
</td></tr>
<tr><td><code id="plot_phi_marginal_+3A_percent.burnin">percent.burnin</code></td>
<td>

<p>The percent of the sampled MCMC generations to be discarded as &quot;burn-in.&quot;  If the 
MCMC is run for 1,000,000 generations, and sampled every 1,000 generations, there 
will be 1,000 sampled generations.  A <code>percent.burnin</code> of <code>20</code> will discard 
the first 200 sampled parameter values from that sample.
</p>
</td></tr>
<tr><td><code id="plot_phi_marginal_+3A_thinning">thinning</code></td>
<td>

<p>The multiple by which the sampled MCMC generations are thinned.  A <code>thinning</code> of
<code>5</code> will sample every 5th MCMC generation.
</p>
</td></tr>
<tr><td><code id="plot_phi_marginal_+3A_population.names">population.names</code></td>
<td>

<p>The name of the population/individual for which the marginal density of the phi 
parameter is being plotted. This will be used to title the marginal plot.  If 
<code>population.names</code> is not provided (i.e. <code>population.names = NULL</code>), a 
population index number will be used to title the plot.
</p>
</td></tr>
<tr><td><code id="plot_phi_marginal_+3A_pop.index">pop.index</code></td>
<td>

<p>A population index number generated to title a marginal plot if no 
<code>population.names</code> is specified.
</p>
</td></tr>
<tr><td><code id="plot_phi_marginal_+3A_histogram">histogram</code></td>
<td>

<p>A switch that controls whether or not the plot contains a histogram of the values 
estimated for the parameter over the course of the MCMC.  Default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="plot_phi_marginal_+3A_density">density</code></td>
<td>

<p>A switch that controls whether or not the plot shows the density of the values 
estimated for the parameter over the course of the MCMC.  Default is <code>TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The marginal plot is another basic visual tool for MCMC diagnosis.  Users should look
for marginal plots that are &quot;smooth as eggs&quot; (indicating that the chain has been run 
long enough) and unimodal (indicating a single peak in the likelihood surface).
</p>


<h3>Author(s)</h3>

<p>Gideon Bradburd
</p>

<hr>
<h2 id='plot_phi_trace'>
Plots the trace plot for the phi parameter estimated in a single population
</h2><span id='topic+plot_phi_trace'></span>

<h3>Description</h3>

<p>This function plots the phi parameter value estimated in each sampled generation of 
the MCMC against the index of that sampled generation.  For convenience, the 
<code class="reqn">F_{k}</code> statistic is presented in place of the phi parameter, as this is the 
statistic users care about.  <code class="reqn">F_{k}</code> is defined as <code class="reqn">\frac{1}{1+phi_{k}}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_phi_trace(phi, percent.burnin = 0, thinning = 1, population.names = NULL, 
pop.index = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_phi_trace_+3A_phi">phi</code></td>
<td>

<p>The vector of phi values estimated for a single population from an MCMC run.
</p>
</td></tr>
<tr><td><code id="plot_phi_trace_+3A_percent.burnin">percent.burnin</code></td>
<td>

<p>The percent of the sampled MCMC generations to be discarded as &quot;burn-in.&quot;  If the 
MCMC is run for 1,000,000 generations, and sampled every 1,000 generations, there 
will be 1,000 sampled generations.  A <code>percent.burnin</code> of <code>20</code> will discard 
the first 200 sampled parameter values from that sample.
</p>
</td></tr>
<tr><td><code id="plot_phi_trace_+3A_thinning">thinning</code></td>
<td>

<p>The multiple by which the sampled MCMC generations are thinned.  A <code>thinning</code> of
<code>5</code> will sample every 5th MCMC generation.
</p>
</td></tr>
<tr><td><code id="plot_phi_trace_+3A_population.names">population.names</code></td>
<td>

<p>The name of the population/individual for which the marginal density of the phi 
parameter is being plotted. This will be used to title the marginal plot.  If 
<code>population.names</code> is not provided (i.e. <code>population.names = NULL</code>), a 
population index number will be used to title the plot.
</p>
</td></tr>
<tr><td><code id="plot_phi_trace_+3A_pop.index">pop.index</code></td>
<td>

<p>A population index number generated to title a marginal plot if no 
<code>population.names</code> is specified.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A trace plot is a basic visual tool for assessing MCMC mixing.  If the chain is 
mixing well, the trace plot will resemble a &quot;fuzzy caterpillar.&quot;  If the trace plot 
has not plateaued, it is an indication that the chain has not converged on the 
stationary posterior distribution, and must be run longer.  If the trace plot of a 
parameter exhibits high autocorrelation, the user may wish to either increase or 
decrease the scale of the tuning parameter on that parameter, to decrease or increase 
acceptance rates, respectively.  If the chain appears to be bouncing between areas of 
&quot;fuzzy caterpillar-dom,&quot; it may be an indication of a multi-modal likelihood surface.
</p>


<h3>Author(s)</h3>

<p>Gideon Bradburd
</p>

<hr>
<h2 id='plot_posterior_predictive_samples'>
Plots posterior predictive sampling
</h2><span id='topic+plot_posterior_predictive_samples'></span>

<h3>Description</h3>

<p>This function plots the posterior predictive samples generated by 
<code>posterior.predictive.sample</code> around the observed data, so that users can
evaluate how well the model is able to describe their data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_posterior_predictive_samples(posterior.predictive.sample.file, save.figure = NULL, 
	figure.name = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_posterior_predictive_samples_+3A_posterior.predictive.sample.file">posterior.predictive.sample.file</code></td>
<td>

<p>The output file generated by the function <code>posterior.predictive.sample</code>.
</p>
</td></tr>
<tr><td><code id="plot_posterior_predictive_samples_+3A_save.figure">save.figure</code></td>
<td>

<p>If <code>save.figure = TRUE</code>, a .png file of the posterior predictive sample plot
will be saved, rather than plotted to the default R plotting window. Depending on the 
<code>posterior.predictive.sample.size</code> specified in 
<code>posterior.predictive.sample</code>, this figure may be time-intensive to generate, 
so users may wish to save the figure for future analysis, rather than re-plot it.  If 
<code>save.figure = TRUE</code>, a <code>figure.name</code> must be specified.  
Default is <code>save.figure = NULL</code>.  
</p>
</td></tr>
<tr><td><code id="plot_posterior_predictive_samples_+3A_figure.name">figure.name</code></td>
<td>

<p>If <code>save.figure = TRUE</code>, a .png file of the posterior predictive sample plot
will be saved under the name <code>figure.name</code>. If <code>save.figure = TRUE</code>, a 
<code>figure.name</code> must be specified.  Default is <code>figure.name = NULL</code>. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots posterior predictive unbiased pairwise <code class="reqn">F_{ST}</code> around the 
observed unbiased pairwise <code class="reqn">F_{ST}</code> values to determine how well the model is 
able to describe the user's data.  Users should examine these plots to make sure that 
the model is picking up general trends (e.g. the slopes of isolation by geographic 
distance and isolation by ecological distance), and also to identify specific 
populations whose relationships with their neighbors are being poorly accommodated by 
the model.
</p>


<h3>Author(s)</h3>

<p>Gideon Bradburd
</p>

<hr>
<h2 id='plot_trace'>
Plot the trace plot for a parameter
</h2><span id='topic+plot_trace'></span>

<h3>Description</h3>

<p>This function plots the parameter value estimated in each sampled generation of the 
MCMC against the index of that sampled generation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_trace(parameter, percent.burnin = 0, thinning = 1, 
param.name = deparse(substitute(parameter)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_trace_+3A_parameter">parameter</code></td>
<td>

<p>The parameter for which the trace plot is being generated.
</p>
</td></tr>
<tr><td><code id="plot_trace_+3A_percent.burnin">percent.burnin</code></td>
<td>

<p>The percent of the sampled MCMC generations to be discarded as &quot;burn-in.&quot;  If the 
MCMC is run for 1,000,000 generations, and sampled every 1,000 generations, there 
will be 1,000 sampled generations.  A <code>percent.burnin</code> of <code>20</code> will discard 
the first 200 sampled parameter values from that sample.
</p>
</td></tr>
<tr><td><code id="plot_trace_+3A_thinning">thinning</code></td>
<td>

<p>The multiple by which the sampled MCMC generations are thinned.  A <code>thinning</code> of
<code>5</code> will sample every 5th MCMC generation.
</p>
</td></tr>
<tr><td><code id="plot_trace_+3A_param.name">param.name</code></td>
<td>

<p>The name of the parameter for which the trace plot is being displayed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A trace plot is a basic visual tool for assessing MCMC mixing.  If the chain is 
mixing well, the trace plot will resemble a &quot;fuzzy caterpillar.&quot;  If the trace plot 
has not plateaued, it is an indication that the chain has not converged on the 
stationary posterior distribution, and must be run longer.  If the trace plot of a 
parameter exhibits high autocorrelation, the user may wish to either increase or 
decrease the scale of the tuning parameter on that parameter, to decrease or increase 
acceptance rates, respectively.  If the chain appears to be bouncing between areas of 
&quot;fuzzy caterpillar-dom,&quot; it may be an indication of a multi-modal likelihood surface.
</p>


<h3>Author(s)</h3>

<p>Gideon Bradburd
</p>

<hr>
<h2 id='posterior.predictive.sample'>
Generates posterior predictive samples
</h2><span id='topic+posterior.predictive.sample'></span>

<h3>Description</h3>

<p>This function simulates data using the inference model parameterized from the joint
posterior of the MCMC and the observed independent variables 
(<code class="reqn">D_{ij} and E_{ij}</code>).  These posterior predictive samples can be compared to the
observed data to see how well the model is able to describe the observed data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posterior.predictive.sample(MCMC.output, posterior.predictive.sample.size, output.file, 
prefix = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="posterior.predictive.sample_+3A_mcmc.output">MCMC.output</code></td>
<td>

<p>The standard MCMC output file generated from a BEDASSLE run.
</p>
</td></tr>
<tr><td><code id="posterior.predictive.sample_+3A_posterior.predictive.sample.size">posterior.predictive.sample.size</code></td>
<td>

<p>The number of posterior predictive datasets the user wishes to simulate.
</p>
</td></tr>
<tr><td><code id="posterior.predictive.sample_+3A_output.file">output.file</code></td>
<td>

<p>The name that will be assigned to the R object containing the posterior predictive 
datasets.  The suffix &quot;.Robj&quot; will be appended to the user-specified name.
</p>
</td></tr>
<tr><td><code id="posterior.predictive.sample_+3A_prefix">prefix</code></td>
<td>

<p>If specified, this prefix will be added to the output file name.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simulates datasets like those the user analyzed with BEDASSLE, using
the same independent variables (<code>sample.sizes</code>, <code class="reqn">D_{ij}</code> and <code class="reqn">E_{ij}</code>) 
as in the user's dataset and plugging them into the inference model, which is 
parameterized by randomly drawing parameter values from the joint posterior output of 
the MCMC analysis.  These posterior predictive simulated allelic count data are 
summarized as unbiased pairwise <code class="reqn">F_{ST}</code> 
(using <code>calculate.all.pairwise.Fst</code>), which may then be compared to the 
observed unbiased pairwise <code class="reqn">F_{ST}</code> to determine how well the model is able to 
describe the user's data.  The output of <code>posterior.predictive.sample</code> can be 
visualized using <code>plot.posterior.predictive.sample</code>.
</p>


<h3>Author(s)</h3>

<p>Gideon Bradburd
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
