<!DOCTYPE html><html><head><title>Help for package LaF</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {LaF}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#[,laf-method'><p>Read records from a large file object into R</p></a></li>
<li><a href='#[[,laf-method'><p>Select a column from a LaF object</p></a></li>
<li><a href='#begin'><p>Go to the beginning of the file</p></a></li>
<li><a href='#close,laf-method'><p>Close the connection to the Large File</p></a></li>
<li><a href='#colsum'><p>Calculate simple statistics of column</p></a></li>
<li><a href='#current_line'><p>Get the current line in the file</p></a></li>
<li><a href='#detect_dm_csv'><p>Automatically detect data models for CSV-files</p></a></li>
<li><a href='#determine_nlines'><p>Determine number of lines in a text file</p></a></li>
<li><a href='#get_lines'><p>Read in specified lines from a text file</p></a></li>
<li><a href='#goto'><p>Go to specified line in the file</p></a></li>
<li><a href='#laf_column-class'><p>Column of a Large File Object</p></a></li>
<li><a href='#laf_open'><p>Create a connection to a file using a data model.</p></a></li>
<li><a href='#laf_open_csv'><p>Create a connection to a comma separated value (CSV) file.</p></a></li>
<li><a href='#laf_open_fwf'><p>Create a connection to a fixed width file.</p></a></li>
<li><a href='#laf-class'><p>Large File object</p></a></li>
<li><a href='#levels,laf-method'><p>Get and change the levels of the column in a Large File object</p></a></li>
<li><a href='#names,laf-method'><p>Get and set the names of the columns in a Large File object</p></a></li>
<li><a href='#ncol,laf-method'><p>Get the number of columns in a Large File object</p></a></li>
<li><a href='#next_block'><p>Read the next block of data from a file.</p></a></li>
<li><a href='#nrow,laf-method'><p>Get the number of rows in a Large File object</p></a></li>
<li><a href='#process_blocks'><p>Blockwise processing of file</p></a></li>
<li><a href='#read_dm'><p>Read and write data models for LaF</p></a></li>
<li><a href='#read_dm_blaise'><p>Read in Blaise data models</p></a></li>
<li><a href='#read_lines'><p>Read lines from the file</p></a></li>
<li><a href='#sample_lines'><p>Read in random lines from a text file</p></a></li>
<li><a href='#show,laf-method'><p>Print the Large File object to screen</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fast Access to Large ASCII Files</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-03-22</td>
</tr>
<tr>
<td>Author:</td>
<td>Jan van der Laan</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jan van der Laan &lt;r@eoos.dds.nl&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods for fast access to large ASCII files.  Currently the
    following file formats are supported: comma separated format (CSV) and fixed
    width format. It is assumed that the files are too large to fit into memory,
    although the package can also be used to efficiently access files that do
    fit into memory. Methods are provided to access and process files blockwise.
    Furthermore, an opened file can be accessed as one would an ordinary
    data.frame. The LaF vignette gives an overview of the functionality
    provided.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/djvanderlaan/LaF">https://github.com/djvanderlaan/LaF</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>methods, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, yaml</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.11.1)</td>
</tr>
<tr>
<td>Collate:</td>
<td>'generics.R' 'laf.R' 'laf_column.R' 'meta.R' 'open.R'
'read_dm_blaise.R' 'stats.R' 'textutils.R' 'types.R'
'utility.R'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-03-22 16:42:41 UTC; eoos</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-03-23 11:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='+5B+2Claf-method'>Read records from a large file object into R</h2><span id='topic++5B+2Claf-method'></span><span id='topic++5B+2Claf_column-method'></span>

<h3>Description</h3>

<p>When a connection is opened to a <code>"<a href="#topic+laf-class">laf</a>"</code> object; this
object can then be indexed roughly as one would a <code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'laf'
x[i, j, drop]

## S4 method for signature 'laf_column'
x[i, j, drop]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B2Claf-method_+3A_x">x</code></td>
<td>
<p>an object of type <code>"<a href="#topic+laf-class">laf</a>"</code> or
<code>"<a href="#topic+laf_column-class">laf_column</a>"</code>.</p>
</td></tr>
<tr><td><code id="+2B5B+2B2Claf-method_+3A_i">i</code></td>
<td>
<p>an logical or numeric vector with indices. The rows which should be
selected.</p>
</td></tr>
<tr><td><code id="+2B5B+2B2Claf-method_+3A_j">j</code></td>
<td>
<p>a numeric vector with the columns to select.</p>
</td></tr>
<tr><td><code id="+2B5B+2B2Claf-method_+3A_drop">drop</code></td>
<td>
<p>a logical indicating whether or not to convert the result to a
vector when only one column is selected. As in when indexing a
<code>data.frame</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='+5B+5B+2Claf-method'>Select a column from a LaF object</h2><span id='topic++5B+5B+2Claf-method'></span><span id='topic++24+2Claf-method'></span>

<h3>Description</h3>

<p>Selecting columns from an <code>laf</code> object works as it does for a 
<code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'laf'
x[[i]]

## S4 method for signature 'laf'
x$name
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B5B+2B2Claf-method_+3A_x">x</code></td>
<td>
<p>an object of type <code>laf</code></p>
</td></tr>
<tr><td><code id="+2B5B+2B5B+2B2Claf-method_+3A_i">i</code></td>
<td>
<p>index of column to select. This should be a numeric or character
vector.</p>
</td></tr>
<tr><td><code id="+2B5B+2B5B+2B2Claf-method_+3A_name">name</code></td>
<td>
<p>the name of the column to select.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of type <code>laf_column</code>. This object behaves almost the
same as an <code>laf</code> object except that is it no longer necessary 
(or possible) to specify which column should be used for functions that 
require this.
</p>

<hr>
<h2 id='begin'>Go to the beginning of the file</h2><span id='topic+begin'></span><span id='topic+begin+2Claf-method'></span>

<h3>Description</h3>

<p>Sets the file pointer to the beginning of the file. The next call to 
<code><a href="#topic+next_block">next_block</a></code> returns the first lines of the file. This method is 
usually used in combination with <code><a href="#topic+next_block">next_block</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>begin(x, ...)

## S4 method for signature 'laf'
begin(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="begin_+3A_x">x</code></td>
<td>
<p>an object the supports the <code>begin</code> method, such as an
<code>laf</code> object.</p>
</td></tr>
<tr><td><code id="begin_+3A_...">...</code></td>
<td>
<p>passed to other methods.</p>
</td></tr>
</table>

<hr>
<h2 id='close+2Claf-method'>Close the connection to the Large File</h2><span id='topic+close+2Claf-method'></span>

<h3>Description</h3>

<p>Close the connection to the Large File
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'laf'
close(con, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="close+2B2Claf-method_+3A_con">con</code></td>
<td>
<p>a <code>"<a href="#topic+laf-class">laf</a>"</code> object that can be closed.</p>
</td></tr>
<tr><td><code id="close+2B2Claf-method_+3A_...">...</code></td>
<td>
<p>unused.</p>
</td></tr>
</table>

<hr>
<h2 id='colsum'>Calculate simple statistics of column</h2><span id='topic+colsum'></span><span id='topic+colsum+2Claf-method'></span><span id='topic+colsum+2Claf_column-method'></span><span id='topic+colmean'></span><span id='topic+colmean+2Claf-method'></span><span id='topic+colmean+2Claf_column-method'></span><span id='topic+colfreq'></span><span id='topic+colfreq+2Claf-method'></span><span id='topic+colfreq+2Claf_column-method'></span><span id='topic+colrange'></span><span id='topic+colrange+2Claf-method'></span><span id='topic+colrange+2Claf_column-method'></span><span id='topic+colnmissing'></span><span id='topic+colnmissing+2Claf-method'></span><span id='topic+colnmissing+2Claf_column-method'></span>

<h3>Description</h3>

<p>Methods for calculating simple statistics of columns of a file: mean, sum,
standard deviation, range (min and max), and number of missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colsum(x, ...)

## S4 method for signature 'laf'
colsum(x, columns, na.rm = TRUE, ...)

## S4 method for signature 'laf_column'
colsum(x, na.rm = TRUE, ...)

colmean(x, ...)

## S4 method for signature 'laf'
colmean(x, columns, na.rm = TRUE, ...)

## S4 method for signature 'laf_column'
colmean(x, na.rm = TRUE, ...)

colfreq(x, ...)

## S4 method for signature 'laf'
colfreq(x, columns, useNA = c("ifany", "always", "no"), ...)

## S4 method for signature 'laf_column'
colfreq(x, na.rm = TRUE, ...)

colrange(x, ...)

## S4 method for signature 'laf'
colrange(x, columns, na.rm = TRUE, ...)

## S4 method for signature 'laf_column'
colrange(x, na.rm = TRUE, ...)

colnmissing(x, ...)

## S4 method for signature 'laf'
colnmissing(x, columns, na.rm = TRUE, ...)

## S4 method for signature 'laf_column'
colnmissing(x, na.rm = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colsum_+3A_x">x</code></td>
<td>
<p>an object of type laf or laf_column.</p>
</td></tr>
<tr><td><code id="colsum_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="colsum_+3A_columns">columns</code></td>
<td>
<p>a numeric vector with the columns for which the statistics
should be calculated.</p>
</td></tr>
<tr><td><code id="colsum_+3A_na.rm">na.rm</code></td>
<td>
<p>whether or not to ignore missing values. By default missing
values are ignored.</p>
</td></tr>
<tr><td><code id="colsum_+3A_usena">useNA</code></td>
<td>
<p>method with which to treat missing values: &quot;ifany&quot; adds a field
containing the number of missing values if there are any; &quot;always&quot; will always
add a field with the number of missing values even when there are none; &quot;none&quot;
will never add a field containing the number of missing values.</p>
</td></tr>
</table>

<hr>
<h2 id='current_line'>Get the current line in the file</h2><span id='topic+current_line'></span><span id='topic+current_line+2Claf-method'></span>

<h3>Description</h3>

<p>Get the current line in the file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>current_line(x)

## S4 method for signature 'laf'
current_line(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="current_line_+3A_x">x</code></td>
<td>
<p>an object the supports the <code>current_line</code> method, such as an
<code>laf</code> object.
</p>
<p>Returns the next line that will be read by <code><a href="#topic+next_block">next_block</a></code>. The
current line can be set by the method <code><a href="#topic+goto">goto</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='detect_dm_csv'>Automatically detect data models for CSV-files</h2><span id='topic+detect_dm_csv'></span>

<h3>Description</h3>

<p>Automatically detect data models for CSV-files.  Opening of files using the
data models can be done using <code><a href="#topic+laf_open">laf_open</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detect_dm_csv(
  filename,
  sep = ",",
  dec = ".",
  header = FALSE,
  nrows = 1000,
  nlines = NULL,
  sample = FALSE,
  stringsAsFactors = TRUE,
  factor_fraction = 0.4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detect_dm_csv_+3A_filename">filename</code></td>
<td>
<p>character containing the filename of the csv-file.</p>
</td></tr>
<tr><td><code id="detect_dm_csv_+3A_sep">sep</code></td>
<td>
<p>character vector containing the separator used in the file.</p>
</td></tr>
<tr><td><code id="detect_dm_csv_+3A_dec">dec</code></td>
<td>
<p>the character used for decimal points.</p>
</td></tr>
<tr><td><code id="detect_dm_csv_+3A_header">header</code></td>
<td>
<p>does the first line in the file contain the column names.</p>
</td></tr>
<tr><td><code id="detect_dm_csv_+3A_nrows">nrows</code></td>
<td>
<p>the number of lines that should be read in to detect the column
types. The more lines the more likely that the correct types are detected.</p>
</td></tr>
<tr><td><code id="detect_dm_csv_+3A_nlines">nlines</code></td>
<td>
<p>(only needed when the sample option is used) the expected number
of lines in the file. If not specified the number of lines in the file is
first calculated.</p>
</td></tr>
<tr><td><code id="detect_dm_csv_+3A_sample">sample</code></td>
<td>
<p>by default the first <code>nrows</code> lines are read in for
determining the column types. When sample is used random lines from the file
are used. This is more robust, but takes longer.</p>
</td></tr>
<tr><td><code id="detect_dm_csv_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>passed on to <code><a href="utils.html#topic+read.table">read.table</a></code>. Set to 
<code>FALSE</code> to read all text columns as character. In that case 
<code>factor_fraction</code> is ignored.</p>
</td></tr>
<tr><td><code id="detect_dm_csv_+3A_factor_fraction">factor_fraction</code></td>
<td>
<p>the fraction of unique string in a column below which
the column is converted to a factor/categorical. For more information see
details.</p>
</td></tr>
<tr><td><code id="detect_dm_csv_+3A_...">...</code></td>
<td>
<p>additional arguments are passed on to <code><a href="utils.html#topic+read.table">read.table</a></code>.
However, be careful with using these as some of these arguments are not
supported by <code><a href="#topic+laf_open_csv">laf_open_csv</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>factor_fraction</code> determines the fraction of unique strings
below which the column is converted to factor/categorical. If all column need
to be converted to character a value larger than one can be used. A value
smaller than zero will ensure that all columns will be converted to
categorical. Note that LaF stores the levels of a categorical in memory.
Therefore, for categorical columns with a very large number of (almost) unique
levels can cause memory problems.
</p>


<h3>Value</h3>

<p><code>read_dm</code> returns a data model which can be used by
<code><a href="#topic+laf_open">laf_open</a></code>. The data model can be written to file using
<code><a href="#topic+write_dm">write_dm</a></code>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+write_dm">write_dm</a></code> to write the data model to file.  The data models
can be used to open a file using <code><a href="#topic+laf_open">laf_open</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create temporary filename
tmpcsv  &lt;- tempfile(fileext="csv")

# Generate test data
ntest &lt;- 10
column_types &lt;- c("integer", "integer", "double", "string")
testdata &lt;- data.frame(
    a = 1:ntest,
    b = sample(1:2, ntest, replace=TRUE),
    c = round(runif(ntest), 13),
    d = sample(c("jan", "pier", "tjores", "corneel"), ntest, replace=TRUE),
    stringsAsFactors = FALSE
    )
# Write test data to csv file
write.table(testdata, file=tmpcsv, row.names=FALSE, col.names=TRUE, sep=',')

# Detect data model
model &lt;- detect_dm_csv(tmpcsv, header=TRUE)

# Create LaF-object
laf &lt;- laf_open(model)

# Cleanup
file.remove(tmpcsv)

</code></pre>

<hr>
<h2 id='determine_nlines'>Determine number of lines in a text file</h2><span id='topic+determine_nlines'></span>

<h3>Description</h3>

<p>Determine number of lines in a text file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>determine_nlines(filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="determine_nlines_+3A_filename">filename</code></td>
<td>
<p>character containing the filename of the file of which the
lines are to be counted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The routine counts the number of line endings. If the last line does not
end in a line ending, but does contain character, this line is also counted.
</p>
<p>The file size is not limited by the amount of memory in the computer.
</p>


<h3>Value</h3>

<p>Returns the number of lines in the file.
</p>


<h3>See Also</h3>

<p>See <code><a href="base.html#topic+readLines">readLines</a></code> to read in all lines a text file;
<code><a href="#topic+get_lines">get_lines</a></code> and <code><a href="#topic+sample_lines">sample_lines</a></code> can be used to read in
specified, or random lines.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create temporary filename
tmpcsv  &lt;- tempfile(fileext="csv")

# Generate file
writeLines(letters[1:20], con=tmpcsv)

# Count the lines
determine_nlines(tmpcsv)

# Cleanup
file.remove(tmpcsv)

</code></pre>

<hr>
<h2 id='get_lines'>Read in specified lines from a text file</h2><span id='topic+get_lines'></span>

<h3>Description</h3>

<p>Read in specified lines from a text file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_lines(filename, line_numbers)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_lines_+3A_filename">filename</code></td>
<td>
<p>character containing the filename of the file from which the
lines should be read.</p>
</td></tr>
<tr><td><code id="get_lines_+3A_line_numbers">line_numbers</code></td>
<td>
<p>A vector containing the lines that should be read.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Line numbers larger than the number of lines in the file are ignored. Missing
values are returned for these.
</p>


<h3>Value</h3>

<p>Returns a character vector with the specified lines.
</p>


<h3>See Also</h3>

<p>See <code><a href="base.html#topic+readLines">readLines</a></code> to read in all lines a text file;
<code><a href="#topic+sample_lines">sample_lines</a></code> can be used to read in random lines.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create temporary filename
tmpcsv  &lt;- tempfile(fileext="csv")

writeLines(letters[1:20], con=tmpcsv)
get_lines(tmpcsv, c(1, 10))

# Cleanup
file.remove(tmpcsv)

</code></pre>

<hr>
<h2 id='goto'>Go to specified line in the file</h2><span id='topic+goto'></span><span id='topic+goto+2Claf+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Sets the current line to the line number specified. The next call to 
<code><a href="#topic+next_block">next_block</a></code> will return the data on the specified line in the 
first row. The number of the current line can be obtained using 
<code><a href="#topic+current_line">current_line</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>goto(x, i, ...)

## S4 method for signature 'laf,numeric'
goto(x, i, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="goto_+3A_x">x</code></td>
<td>
<p>an object the supports the <code>goto</code> method, such as an <code>laf</code>
object.</p>
</td></tr>
<tr><td><code id="goto_+3A_i">i</code></td>
<td>
<p>the line number .</p>
</td></tr>
<tr><td><code id="goto_+3A_...">...</code></td>
<td>
<p>additional parameters passed to other methods.</p>
</td></tr>
</table>

<hr>
<h2 id='laf_column-class'>Column of a Large File Object</h2><span id='topic+laf_column-class'></span>

<h3>Description</h3>

<p>Representation of a column in a Large File object. This class itself is a
subclass of the class <code>laf</code>. In principle all methods that can be used
with a <code>laf</code> object can also be used with a <code>laf_column</code> object
except the the <code>column</code> or <code>columns</code> arguments of these methods are
not needed.
</p>


<h3>Objects from the Class</h3>

<p>Object of this class are usually created by using the <code>$</code> operator on
<code>laf</code> objects.
</p>

<hr>
<h2 id='laf_open'>Create a connection to a file using a data model.</h2><span id='topic+laf_open'></span>

<h3>Description</h3>

<p>Uses a data model to create a connection to a file. The data model contains
all the information needed to open the file (column types, column widths,
etc.).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>laf_open(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="laf_open_+3A_model">model</code></td>
<td>
<p>a data model, such as one returned by <a href="#topic+read_dm">read_dm</a> or
<a href="#topic+detect_dm_csv">detect_dm_csv</a>.</p>
</td></tr>
<tr><td><code id="laf_open_+3A_...">...</code></td>
<td>
<p>additional arguments can be used to overwrite the values specified
by the data model. These are listed in the argument documentation for
<code><a href="#topic+laf_open_csv">laf_open_csv</a></code> and <code><a href="#topic+laf_open_fwf">laf_open_fwf</a></code>, e.g.
see <code>ignore_failed_conversion</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on the field &lsquo;type&rsquo; <code>laf_open</code> uses <code><a href="#topic+laf_open_csv">laf_open_csv</a></code>
and <code><a href="#topic+laf_open_fwf">laf_open_fwf</a></code> to open the file. The data model should contain
all information needed by these routines to open the file.
</p>


<h3>Value</h3>

<p>Object of type <code><a href="#topic+laf-class">laf</a></code>. Values can be extracted from this
object using indexing, and methods such as <code><a href="#topic+read_lines">read_lines</a></code>,
<code><a href="#topic+next_block">next_block</a></code>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+read_dm">read_dm</a></code> and <code><a href="#topic+detect_dm_csv">detect_dm_csv</a></code> for ways of creating
data models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create some temporary files
tmpcsv  &lt;- tempfile(fileext="csv")
tmp2csv &lt;- tempfile(fileext="csv")
tmpyaml &lt;- tempfile(fileext="yaml")

# Generate test data
ntest &lt;- 10
column_types &lt;- c("integer", "integer", "double", "string")
testdata &lt;- data.frame(
    a = 1:ntest,
    b = sample(1:2, ntest, replace=TRUE),
    c = round(runif(ntest), 13),
    d = sample(c("jan", "pier", "tjores", "corneel"), ntest, replace=TRUE)
    )
# Write test data to csv file
write.table(testdata, file=tmpcsv, row.names=FALSE, col.names=FALSE, sep=',')

# Create LaF-object
laf &lt;- laf_open_csv(tmpcsv, column_types=column_types)

# Write data model to file
write_dm(laf, tmpyaml)

# Read data model and open file
laf &lt;- laf_open(read_dm(tmpyaml))

# Write test data to second csv file
write.table(testdata, file=tmp2csv, row.names=FALSE, col.names=FALSE, sep=',')

# Read data model and open second file, demonstrating the use of the optional
# arguments to laf_open
laf2 &lt;- laf_open(read_dm(tmpyaml), filename=tmp2csv)

# Cleanup
file.remove(tmpcsv)
file.remove(tmp2csv)
file.remove(tmpyaml)

</code></pre>

<hr>
<h2 id='laf_open_csv'>Create a connection to a comma separated value (CSV) file.</h2><span id='topic+laf_open_csv'></span>

<h3>Description</h3>

<p>A connection to the file filename is created. Column types have to be
specified. These are not determined automatically as for example read.csv
does.  This has been done to increase speed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>laf_open_csv(
  filename,
  column_types,
  column_names = paste("V", seq_len(length(column_types)), sep = ""),
  sep = ",",
  dec = ".",
  trim = FALSE,
  skip = 0,
  ignore_failed_conversion = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="laf_open_csv_+3A_filename">filename</code></td>
<td>
<p>character containing the filename of the CSV-file</p>
</td></tr>
<tr><td><code id="laf_open_csv_+3A_column_types">column_types</code></td>
<td>
<p>character vector containing the types of data in each of
the columns. Valid types are: double, integer, categorical and string.</p>
</td></tr>
<tr><td><code id="laf_open_csv_+3A_column_names">column_names</code></td>
<td>
<p>optional character vector containing the names of the
columns.</p>
</td></tr>
<tr><td><code id="laf_open_csv_+3A_sep">sep</code></td>
<td>
<p>optional character specifying the field separator used in the
file.</p>
</td></tr>
<tr><td><code id="laf_open_csv_+3A_dec">dec</code></td>
<td>
<p>optional character specifying the decimal mark.</p>
</td></tr>
<tr><td><code id="laf_open_csv_+3A_trim">trim</code></td>
<td>
<p>optional logical specifying whether or not white space at the end
of factor levels or character strings should be trimmed.</p>
</td></tr>
<tr><td><code id="laf_open_csv_+3A_skip">skip</code></td>
<td>
<p>optional numeric specifying the number of lines at the beginning 
of the file that should be skipped.</p>
</td></tr>
<tr><td><code id="laf_open_csv_+3A_ignore_failed_conversion">ignore_failed_conversion</code></td>
<td>
<p>ignore (set to <code>NA</code>) fields that could 
not be converted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After the connection is created data can be extracted using indexing (as in a
normal data.frame) or methods such as <code><a href="#topic+read_lines">read_lines</a></code> and 
<code><a href="#topic+next_block">next_block</a></code> can be used to read in blocks. For processing the 
file in blocks the convenience function <code><a href="#topic+process_blocks">process_blocks</a></code> can be 
used.
</p>
<p>The CSV-file should not contain headers. Use the <code>skip</code> option to skip 
any headers.
</p>


<h3>Value</h3>

<p>Object of type <code><a href="#topic+laf-class">laf</a></code>. Values can be extracted from this
object using indexing, and methods such as <code><a href="#topic+read_lines">read_lines</a></code>,
<code><a href="#topic+next_block">next_block</a></code>.
</p>


<h3>See Also</h3>

<p>See <code><a href="utils.html#topic+read.csv">read.csv</a></code> for conventional access of CSV files. And 
<code><a href="#topic+detect_dm_csv">detect_dm_csv</a></code> to automatically determine the column types.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create temporary filename
tmpcsv  &lt;- tempfile(fileext="csv")

# Generate test data
ntest &lt;- 10
column_types &lt;- c("integer", "integer", "double", "string")
testdata &lt;- data.frame(
    a = 1:ntest,
    b = sample(1:2, ntest, replace=TRUE),
    c = round(runif(ntest), 13),
    d = sample(c("jan", "pier", "tjores", "corneel"), ntest, replace=TRUE)
    )
# Write test data to csv file
write.table(testdata, file=tmpcsv, row.names=FALSE, col.names=FALSE, sep=',')

# Create LaF-object
laf &lt;- laf_open_csv(tmpcsv, column_types=column_types)

# Read from file using indexing
first_column &lt;- laf[ , 1]
first_row    &lt;- laf[1, ]

# Read from file using blockwise operators
begin(laf)
first_block &lt;- next_block(laf, nrows=2)
second_block &lt;- next_block(laf, nrows=2)

# Cleanup
file.remove(tmpcsv)

</code></pre>

<hr>
<h2 id='laf_open_fwf'>Create a connection to a fixed width file.</h2><span id='topic+laf_open_fwf'></span>

<h3>Description</h3>

<p>A connection to the file filename is created. Column types have to be 
specified. These are not determined automatically as for example 
read.fwf does. This has been done to increase speed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>laf_open_fwf(
  filename,
  column_types,
  column_widths,
  column_names = paste("V", seq_len(length(column_types)), sep = ""),
  dec = ".",
  trim = TRUE,
  ignore_failed_conversion = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="laf_open_fwf_+3A_filename">filename</code></td>
<td>
<p>character containing the filename of the CSV-file.</p>
</td></tr>
<tr><td><code id="laf_open_fwf_+3A_column_types">column_types</code></td>
<td>
<p>character vector containing the types of data in each of 
the columns. Valid types are: double, integer, categorical and string.</p>
</td></tr>
<tr><td><code id="laf_open_fwf_+3A_column_widths">column_widths</code></td>
<td>
<p>numeric vector containing the width in number of character
of each of the columns.</p>
</td></tr>
<tr><td><code id="laf_open_fwf_+3A_column_names">column_names</code></td>
<td>
<p>optional character vector containing the names of the 
columns.</p>
</td></tr>
<tr><td><code id="laf_open_fwf_+3A_dec">dec</code></td>
<td>
<p>optional character specifying the decimal mark.</p>
</td></tr>
<tr><td><code id="laf_open_fwf_+3A_trim">trim</code></td>
<td>
<p>optional logical specifying whether or not whitespace at the end
of factor levels or character strings should be trimmed.</p>
</td></tr>
<tr><td><code id="laf_open_fwf_+3A_ignore_failed_conversion">ignore_failed_conversion</code></td>
<td>
<p>ignore (set to <code>NA</code>) fields that could 
not be converted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After the connection is created data can be extracted using indexing (as in a
normal data.frame) or methods such as read_lines and next_block can be used 
to read in blocks. For processing the file in blocks the (faster) convenience
function process_blocks can be used.
</p>
<p>Only use <code>ignore_failed_conversion </code> when you are sure that the column
specification is correct. Otherwise, this option can hide an incorrect 
specification.
</p>


<h3>Value</h3>

<p>Object of type <code><a href="#topic+laf-class">laf</a></code>. Values can be extracted from this object 
using indexing, and methods such as <code><a href="#topic+read_lines">read_lines</a></code>, <code><a href="#topic+next_block">next_block</a></code>.
</p>


<h3>See Also</h3>

<p>See <code><a href="utils.html#topic+read.fwf">read.fwf</a></code> for conventional access of fixed width files.
</p>

<hr>
<h2 id='laf-class'>Large File object</h2><span id='topic+laf-class'></span>

<h3>Description</h3>

<p>A Large File object. This is a reference to a dataset on disk. The data
itself is not read into memory (yet). This can be done by the methods for
blockwise processing or by indexing the object as a data.frame. The code has
been optimised for fast access.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by opening a file using one of the methods 
<code><a href="#topic+laf_open_csv">laf_open_csv</a></code> or <code><a href="#topic+laf_open_fwf">laf_open_fwf</a></code>. These create a 
reference to either a CSV file or a fixed width file. The data in these
files can either be accessed using blockwise operations using the methods
<code>begin</code>, <code>next_block</code> and <code>goto</code>. Or by indexing the laf 
object as you would a data.frame. In the following example a CSV file
is opened and its first column (of type integer) is read into memory:
</p>
<pre>
   laf &lt;- laf_open_csv("file.csv", column_types=c("integer", "double"))
   data &lt;- laf[ , 1]
 </pre>

<hr>
<h2 id='levels+2Claf-method'>Get and change the levels of the column in a Large File object</h2><span id='topic+levels+2Claf-method'></span><span id='topic+levels+3C-+2Claf-method'></span><span id='topic+levels+2Claf_column-method'></span><span id='topic+levels+3C-+2Claf_column-method'></span>

<h3>Description</h3>

<p>Get and change the levels of the column in a Large File object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'laf'
levels(x)

## S4 replacement method for signature 'laf'
levels(x) &lt;- value

## S4 method for signature 'laf_column'
levels(x)

## S4 replacement method for signature 'laf_column'
levels(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="levels+2B2Claf-method_+3A_x">x</code></td>
<td>
<p>a <code>"<a href="#topic+laf-class">laf</a>"</code> object.</p>
</td></tr>
<tr><td><code id="levels+2B2Claf-method_+3A_value">value</code></td>
<td>
<p>a list with the levels for each column.</p>
</td></tr>
</table>

<hr>
<h2 id='names+2Claf-method'>Get and set the names of the columns in a Large File object</h2><span id='topic+names+2Claf-method'></span><span id='topic+names+3C-+2Claf-method'></span>

<h3>Description</h3>

<p>Get and set the names of the columns in a Large File object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'laf'
names(x)

## S4 replacement method for signature 'laf'
names(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="names+2B2Claf-method_+3A_x">x</code></td>
<td>
<p>a <code>"<a href="#topic+laf-class">laf</a>"</code> object.</p>
</td></tr>
<tr><td><code id="names+2B2Claf-method_+3A_value">value</code></td>
<td>
<p>a character vector with the new column names</p>
</td></tr>
</table>

<hr>
<h2 id='ncol+2Claf-method'>Get the number of columns in a Large File object</h2><span id='topic+ncol+2Claf-method'></span>

<h3>Description</h3>

<p>Get the number of columns in a Large File object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'laf'
ncol(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ncol+2B2Claf-method_+3A_x">x</code></td>
<td>
<p>a <code>"<a href="#topic+laf-class">laf</a>"</code> object.</p>
</td></tr>
</table>

<hr>
<h2 id='next_block'>Read the next block of data from a file.</h2><span id='topic+next_block'></span><span id='topic+next_block+2Claf-method'></span><span id='topic+next_block+2Claf_column-method'></span>

<h3>Description</h3>

<p>Read the next block of data from a file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>next_block(x, ...)

## S4 method for signature 'laf'
next_block(x, columns = 1:ncol(x), nrows = 5000, ...)

## S4 method for signature 'laf_column'
next_block(x, nrows = 5000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="next_block_+3A_x">x</code></td>
<td>
<p>an object the supports the <code>next_block</code> method, such as an
<code>laf</code> object.</p>
</td></tr>
<tr><td><code id="next_block_+3A_...">...</code></td>
<td>
<p>passed to other methods.
</p>
<p>Reads the next block of lines from a file. The method returns a
<code>data.frame</code>. The first line in the <code>data.frame</code> is the line
corresponding to the current line in the file. When the end of the file is
reached a <code>data.frame</code> with zero rows is returned. This can be used to
check whether the end of the file is reached.</p>
</td></tr>
<tr><td><code id="next_block_+3A_columns">columns</code></td>
<td>
<p>an integer vector with the columns that should be read in.</p>
</td></tr>
<tr><td><code id="next_block_+3A_nrows">nrows</code></td>
<td>
<p>the (maximum) number of rows to read in one block</p>
</td></tr>
</table>

<hr>
<h2 id='nrow+2Claf-method'>Get the number of rows in a Large File object</h2><span id='topic+nrow+2Claf-method'></span>

<h3>Description</h3>

<p>Get the number of rows in a Large File object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'laf'
nrow(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nrow+2B2Claf-method_+3A_x">x</code></td>
<td>
<p>a <code>"<a href="#topic+laf-class">laf</a>"</code> object.</p>
</td></tr>
</table>

<hr>
<h2 id='process_blocks'>Blockwise processing of file</h2><span id='topic+process_blocks'></span><span id='topic+process_blocks+2Claf-method'></span>

<h3>Description</h3>

<p>Reads the specified file block by block and feeds each block to the 
specified function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_blocks(x, fun, ...)

## S4 method for signature 'laf'
process_blocks(
  x,
  fun,
  columns = 1:ncol(x),
  nrows = 5000,
  allow_interupt = FALSE,
  progress = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="process_blocks_+3A_x">x</code></td>
<td>
<p>an object the supports the <code>process_blocks</code> method, such as an
<code>laf</code> object.</p>
</td></tr>
<tr><td><code id="process_blocks_+3A_fun">fun</code></td>
<td>
<p>a function to apply to each block (see details).</p>
</td></tr>
<tr><td><code id="process_blocks_+3A_...">...</code></td>
<td>
<p>additional parameters are passed on to <code>fun</code>.</p>
</td></tr>
<tr><td><code id="process_blocks_+3A_columns">columns</code></td>
<td>
<p>an integer vector with the columns that should be read in.</p>
</td></tr>
<tr><td><code id="process_blocks_+3A_nrows">nrows</code></td>
<td>
<p>the (maximum) number of rows to read in one block</p>
</td></tr>
<tr><td><code id="process_blocks_+3A_allow_interupt">allow_interupt</code></td>
<td>
<p>when TRUE the function <code>fun</code> is expected to 
return a list. The second element is the result of the function. The first
element should be a logical value indication whether <code>process_blocks</code>
should continue (FALSE) or stop (TRUE). When interrupted the function is 
not called a last time with an empty <code>data.frame</code> to finalize the 
result.</p>
</td></tr>
<tr><td><code id="process_blocks_+3A_progress">progress</code></td>
<td>
<p>show a progress bar. Note that this triggers a calculation
of the number of lines in the file which for CSV files can take some time. 
When numeric <code>code</code> is used as the style of the progress bar (see
<code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function should accept as the first argument the next block of data. When
the end of the file is reached this is an empty (zero row) <code>data.frame</code>.
As the second argument the function should accept the output of the previous
call to the function. The first time the function is called the second
argument has the value <code>NULL</code>.
</p>

<hr>
<h2 id='read_dm'>Read and write data models for LaF</h2><span id='topic+read_dm'></span><span id='topic+write_dm'></span>

<h3>Description</h3>

<p>Using these routines data models can be written and read. These data models
can be used to create LaF object without the need to specify all arguments
(column names, column types etc.). Opening of files using the data models can
be done using <code><a href="#topic+laf_open">laf_open</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_dm(modelfile, ...)

write_dm(model, modelfile)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_dm_+3A_modelfile">modelfile</code></td>
<td>
<p>character containing the filename of the file the model is to
be written to/read from.</p>
</td></tr>
<tr><td><code id="read_dm_+3A_...">...</code></td>
<td>
<p>additional arguments are added to the data model or, when they are
also present in the file are used to overwrite the values specified in the
file.</p>
</td></tr>
<tr><td><code id="read_dm_+3A_model">model</code></td>
<td>
<p>a data model or an object of type <code><a href="#topic+laf-class">laf</a></code>. See
details for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A data model is a list containing information which open routine should be
used (e.g. <code><a href="#topic+laf_open_csv">laf_open_csv</a></code> or <code><a href="#topic+laf_open_fwf">laf_open_fwf</a></code>), and the
arguments needed for these routines. Required elements are &lsquo;type&rsquo;, which can
(currently) be &lsquo;csv&rsquo;, or &lsquo;fwf&rsquo;, and &lsquo;columns&rsquo;, which should be a
<code>data.frame</code> containing at least the columns &lsquo;name&rsquo; and &lsquo;type&rsquo;, and for
fwf &lsquo;width&rsquo;. These columns correspond to the arguments <code>column_names</code>,
<code>column_types</code> and <code>column_widths</code> respectively. Other arguments of
the <code>laf_open_*</code> routines can be specified as additional elements of the
list. 
</p>
<p><code>write_dm</code> can also be used to write a data model that is created
from an object of type <code><a href="#topic+laf-class">laf</a></code>. This is probably one of the
easiest ways to create a data model.
</p>
<p>The data model is stored in a text file in YAML format which is a format in
which data structures can be stored in a readable and editable format.
</p>


<h3>Value</h3>

<p><code>read_dm</code> returns a data model which can be used by
<code><a href="#topic+laf_open">laf_open</a></code>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+detect_dm_csv">detect_dm_csv</a></code> for a routine which can automatically
create a data model from a CSV-file. The data models can be used to open a
file using <code><a href="#topic+laf_open">laf_open</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create some temporary files
tmpcsv  &lt;- tempfile(fileext="csv")
tmp2csv &lt;- tempfile(fileext="csv")
tmpyaml &lt;- tempfile(fileext="yaml")

# Generate test data
ntest &lt;- 10
column_types &lt;- c("integer", "integer", "double", "string")
testdata &lt;- data.frame(
    a = 1:ntest,
    b = sample(1:2, ntest, replace=TRUE),
    c = round(runif(ntest), 13),
    d = sample(c("jan", "pier", "tjores", "corneel"), ntest, replace=TRUE)
    )
# Write test data to csv file
write.table(testdata, file=tmpcsv, row.names=FALSE, col.names=FALSE, sep=',')

# Create LaF-object
laf &lt;- laf_open_csv(tmpcsv, column_types=column_types)

# Write data model to stdout() (screen)
write_dm(laf, stdout())

# Write data model to file
write_dm(laf, tmpyaml)

# Read data model and open file
laf2 &lt;- laf_open(read_dm(tmpyaml))

# Write test data to second csv file
write.table(testdata, file=tmp2csv, row.names=FALSE, col.names=FALSE, sep=',')

# Read data model and open seconde file, demonstrating the use of the optional
# arguments to read_dm
laf2 &lt;- laf_open(read_dm(tmpyaml, filename=tmp2csv))

# Cleanup
file.remove(tmpcsv)
file.remove(tmp2csv)
file.remove(tmpyaml)

</code></pre>

<hr>
<h2 id='read_dm_blaise'>Read in Blaise data models</h2><span id='topic+read_dm_blaise'></span>

<h3>Description</h3>

<p>Read in Blaise data models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_dm_blaise(filename, datafilename = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_dm_blaise_+3A_filename">filename</code></td>
<td>
<p>the filename of the file containing the data model.</p>
</td></tr>
<tr><td><code id="read_dm_blaise_+3A_datafilename">datafilename</code></td>
<td>
<p>the filename of the data file to which the data model
belongs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function reads the data model from file and returns a list that can be
used by <code><a href="#topic+laf_open">laf_open</a></code> to open the file for reading. Only a subset of
the most common features found in Blaise files are supported. If part of the
data model can not be parsed a warning is given.
</p>


<h3>Value</h3>

<p>Returns a data model (which is a list containing all the relevant information
to open a file using <code><a href="#topic+laf_open">laf_open</a></code>. When the file contains more than
one data model a list of data models is returned and a warning issued.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+write_dm">write_dm</a></code> to write the data model to file.  The data models
can be used to open a file using <code><a href="#topic+laf_open">laf_open</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create some temporary files
tmpdat &lt;- tempfile(fileext="dat")
tmpbla &lt;- tempfile(fileext="bla")

# Generate test data
lines &lt;- c(
    " 1M 1.45Rotterdam ",
    " 2F12.00Amsterdam ",
    " 3  .22 Berlin    ",
    "  M22   Paris     ",
    " 4F12345London    ",
    " 5M     Copenhagen",
    " 6M-12.1          ",
    " 7F   -1Oslo      ")
writeLines(lines, con=tmpdat)

# Create a file containing the data model
writeLines(c( 
    "DATAMODEL test", 
    "FIELDS", 
    "  id     : INTEGER[2]", 
    "  gender : STRING[1]", 
    "  x      : REAL[5] {comment}", 
    "  city   : STRING[10]", 
    "ENDMODEL"), con=tmpbla)
model &lt;- read_dm_blaise(tmpbla, datafilename=tmpdat)
laf &lt;- laf_open(model)

# Cleanup
file.remove(tmpbla)
file.remove(tmpdat)

</code></pre>

<hr>
<h2 id='read_lines'>Read lines from the file</h2><span id='topic+read_lines'></span><span id='topic+read_lines+2Claf-method'></span><span id='topic+read_lines+2Claf_column-method'></span>

<h3>Description</h3>

<p>Reads the specified lines and columns from the data file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_lines(x, ...)

## S4 method for signature 'laf'
read_lines(x, rows, columns = 1:ncol(x), ...)

## S4 method for signature 'laf_column'
read_lines(x, rows, columns = 1:ncol(x), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_lines_+3A_x">x</code></td>
<td>
<p>an object the supports the <code>read_lines</code> method, such as an
<code>laf</code> object.</p>
</td></tr>
<tr><td><code id="read_lines_+3A_...">...</code></td>
<td>
<p>passed on to other methods.</p>
</td></tr>
<tr><td><code id="read_lines_+3A_rows">rows</code></td>
<td>
<p>a numeric vector with the rows that should be read from the
file.</p>
</td></tr>
<tr><td><code id="read_lines_+3A_columns">columns</code></td>
<td>
<p>an integer vector with the columns that should be read in.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that when scanning through the complete file next_block is much faster. 
Also note that random file access can be slow (and is always much slower 
than sequential file access), especially for certain file types such as 
comma separated. Reading is generally faster when the lines that should be
read are sorted.
</p>

<hr>
<h2 id='sample_lines'>Read in random lines from a text file</h2><span id='topic+sample_lines'></span>

<h3>Description</h3>

<p>Read in random lines from a text file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_lines(filename, n, nlines = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_lines_+3A_filename">filename</code></td>
<td>
<p>character containing the filename of the file from which the
lines should be read.</p>
</td></tr>
<tr><td><code id="sample_lines_+3A_n">n</code></td>
<td>
<p>The number of lines that should be sampled from the file.</p>
</td></tr>
<tr><td><code id="sample_lines_+3A_nlines">nlines</code></td>
<td>
<p>The total number of lines in the file. If not specified or
<code>NULL</code> the number of lines is first determined using
<code><a href="#topic+determine_nlines">determine_nlines</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>nlines</code> is not specified, the total number of lines is first
determined. This can take quite some time. Therefore, specifying the number of
lines can cause a significant speed up. It can also be used to sample lines
from the first <code>nlines</code> line by specifying a value for <code>nlines</code> that
is smaller than the number of lines in the file.
</p>


<h3>Value</h3>

<p>Returns a character vector with the sampled lines.
</p>


<h3>See Also</h3>

<p>See <code><a href="base.html#topic+readLines">readLines</a></code> to read in all lines a text file;
<code><a href="#topic+get_lines">get_lines</a></code> can be used to read in specified lines.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create temporary filename
tmpcsv  &lt;- tempfile(fileext="csv")

writeLines(letters[1:20], con=tmpcsv)
sample_lines(tmpcsv, 10)

# Cleanup
file.remove(tmpcsv)

</code></pre>

<hr>
<h2 id='show+2Claf-method'>Print the Large File object to screen</h2><span id='topic+show+2Claf-method'></span><span id='topic+show+2Claf_column-method'></span>

<h3>Description</h3>

<p>Print the Large File object to screen
</p>
<p>Print a column of a Large File object to screen
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'laf'
show(object)

## S4 method for signature 'laf_column'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2Claf-method_+3A_object">object</code></td>
<td>
<p>the object to print to screen.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
