<!DOCTYPE html><html lang="en"><head><title>Help for package loa</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {loa}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#loa-package'>
<p>loa</p></a></li>
<li><a href='#1.1.loaPlot'>
<p>loaPlot, XYZ plots for lattice</p></a></li>
<li><a href='#1.2.loaMapPlot.and.geoplotting.tools'>
<p>Map plotting for lattice</p></a></li>
<li><a href='#1.3.trianglePlot'>
<p>Triangle plots</p></a></li>
<li><a href='#1.4.stackPlot'>
<p>Stack plots</p></a></li>
<li><a href='#1.5.loaBarPlot'>
<p>loaBarPlot</p></a></li>
<li><a href='#2.1.specialist.panels'>
<p>Special panel functions 01</p></a></li>
<li><a href='#2.2.specialist.panels'>
<p>Special panel functions 02</p></a></li>
<li><a href='#2.3.specialist.panels'>
<p>Special panel functions 03</p></a></li>
<li><a href='#2.4.specialist.panels'>
<p>Special panel functions 04</p></a></li>
<li><a href='#3.1.example.data'>
<p>Example data for use with loa</p></a></li>
<li><a href='#4.1.panel.pal'>
<p>panelPal</p></a></li>
<li><a href='#4.2.plot.structure.handlers'>
<p>Handler functions for plot structure arguments.</p></a></li>
<li><a href='#4.3.lims.and.scales.handlers'>
<p>Plot lims and scales handlers</p></a></li>
<li><a href='#4.4.cond.handlers'>
<p>Plot Conditioning</p></a></li>
<li><a href='#4.5.plot.argument.handlers'>
<p>Common plot argument handlers</p></a></li>
<li><a href='#4.6.key.handlers'>
<p>Key handling</p></a></li>
<li><a href='#4.7.other.panel.functions'>
<p>Other panel functions argument handlers</p></a></li>
<li><a href='#4.8.list.handlers'>
<p>List manipulation</p></a></li>
<li><a href='#4.9.loa.shapes'>
<p>loa shapes</p></a></li>
<li><a href='#5.1.plot.interactives'>
<p>Interactive plot functions</p></a></li>
<li><a href='#5.2.plot.add.functions'>
<p>General plot add... functions</p></a></li>
<li><a href='#5.3.plot.add.XYFit.functions'>
<p>Plot add.XY...Fit functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Lattice Options and Add-Ins</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-12-20</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://loa.r-forge.r-project.org/">https://loa.r-forge.r-project.org/</a></td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Karl Ropkins &lt;karl.ropkins@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Various plots and functions that make use of the lattice/trellis plotting framework. 
   The plots, which include loaPlot(), loaMapPlot() and trianglePlot(), and use panelPal(), a function that 
   extends 'lattice' and 'hexbin' package methods to automate plot subscript and panel-to-panel 
   and panel-to-key synchronization/management.   </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>lattice, methods, MASS, grid, png, RgoogleMaps, OpenStreetMap,
sp(&ge; 2.1-1), RColorBrewer, mgcv, plyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>sf</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-21 05:53:01 UTC; trakradmin</td>
</tr>
<tr>
<td>Author:</td>
<td>Karl Ropkins <a href="https://orcid.org/0000-0002-0294-6997"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-21 07:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='loa-package'>
loa 
</h2><span id='topic+loa-package'></span><span id='topic+loa'></span>

<h3>Description</h3>

<p>The loa package contains various plots, options and 
add-ins for use with the <code><a href="lattice.html#topic+lattice">lattice</a></code> package.  
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> loa</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.3.1.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-12-20</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p><code><a href="lattice.html#topic+lattice">lattice</a></code> provides an elegant and highly powerful implementation 
of the Trellis plotting structure described by Cleveland and colleagues. 
In particular the combination of <code>panel...</code> functions, which can be 
layered within plots to generate novel visualisations, and simple-to-use 
conditioning make it a hugely effective tool when working with data.
</p>
<p>The <code>loa</code> package contains a number of plot functions developed to make 
use of this framework. These are summarized in section 1 of this manual, and include:
</p>
<p>1.1. <code><a href="#topic+loaPlot">loaPlot</a></code> for various XYZ plots.
</p>
<p>1.2. <code><a href="#topic+loaMapPlot">loaMapPlot</a></code> and associated geoplotting functions.
</p>
<p>1.3. <code><a href="#topic+trianglePlot">trianglePlot</a></code> and associated functions.
</p>
<p>1.4. <code><a href="#topic+stackPlot">stackPlot</a></code> and associated functions.
</p>
<p>1.5. <code><a href="#topic+loaBarPlot">loaBarPlot</a></code> and associated functions.
</p>
<p>Other <code>panel...</code> functions and example data are summarized in sections 2 and 
3, respectively:
</p>
<p>2.1. Specialist panels, e.g. <code><a href="#topic+panel.kernelDensity">panel.kernelDensity</a></code>, 
</p>
<p>2.2. Specialist panels for polar plotting, e.g. <code><a href="#topic+panel.polarPlot">panel.polarPlot</a></code>.
</p>
<p>3.1. Example data, e.g. <code><a href="#topic+lat.lon.meuse">lat.lon.meuse</a></code>.
</p>
<p>While such 'stand alone' plot functions are of obvious value, the code framework is 
of possibly wider interest because it provides a template for the rapid third-party 
development of novel visualization functions and a highly flexible 'test bed' for 
the comparison of different data handling strategies. 
</p>
<p>Therefore, the functions in this package have been written in a relatively dissaggregated 
fashion so code can be easily rearranged or modified by others to quickly develop 
alternative plots within the <code><a href="lattice.html#topic+lattice">lattice</a></code> framework. Firstly, plot functions 
in section 1 have where possible been supplied as main plot functions and plot component 
functions that handle data, axes, panels, etc. Secondly, the workhorse functions, those common 
functions used through-out the package to simplify many routine operations have been grouped 
together and summarized in section 4:
</p>
<p>4.1. <code><a href="#topic+panelPal">panelPal</a></code>
</p>
<p>4.2. plot structure handlers: <code><a href="#topic+formulaHandler">formulaHandler</a></code>, etc.
</p>
<p>4.3. Plot lim(s) and scale(s) handlers: <code><a href="#topic+limsHandler">limsHandler</a></code>, <code><a href="#topic+localScalesHandler">localScalesHandler</a></code>, etc.
</p>
<p>4.4. Plot conditioning handlers: <code><a href="#topic+condsPanelHandler">condsPanelHandler</a></code>, etc.
</p>
<p>4.5. Common plot argument handlers: <code><a href="#topic+cexHandler">cexHandler</a></code>, <code><a href="#topic+colHandler">colHandler</a></code>, 
<code><a href="#topic+zHandler">zHandler</a></code>, etc.
</p>
<p>4.6. Key handlers: <code><a href="#topic+keyHandler">keyHandler</a></code>, etc.
</p>
<p>4.7. Other panel functions: <code><a href="#topic+getArgs">getArgs</a></code>, etc.
</p>
<p>4.8. List handlers: <code><a href="#topic+listHandler">listHandler</a></code>, etc.
</p>
<p>And, finally, functions used for working with data post-plotting, are summarized in section 5: 
</p>
<p>5.1. Interactive functions for working with plot outputs: <code><a href="#topic+getXY">getXY</a></code>, etc.
</p>
<p>This package is very much intended to be an evolutionary exercise. I use it on a routine 
basis to develop plots for use elsewhere and compare data visualization methods. However, 
that working pattern can generate some very 'developer-centric' code. So, I would 
be very pleased to hear from others - what they did and did not like about the 
package; what they would have liked to have been different; and, perhaps most interesting 
for me what they are using it to do. 
</p>


<h3>Author(s)</h3>

<p>Karl Ropkins &lt;k.ropkins@its.leeds.ac.uk&gt;
</p>


<h3>References</h3>

<p>Functions in <code>loa</code> make extensive use of code developed by others. 
In particular, I gratefully acknowledge the huge contributions of: 
</p>
<p>lattice:
Sarkar, Deepayan (2008) Lattice: Multivariate Data
Visualization with R. Springer, New York. ISBN
978-0-387-75968-5
</p>
<p>Trellis Plotting:
Becker, R. A., Cleveland, W. S., Shyu, M. J. (1996). The Visual Design and 
Control of Trellis Display, Journal of Computational and Graphical Statistics, 
5(2), 123-155.
Cleveland, W.S. (1993) Visualizing Data, Hobart Press, Summit, New Jersey.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loaPlot">loaPlot</a></code>, <code><a href="#topic+loaMapPlot">loaMapPlot</a></code>, <code><a href="#topic+trianglePlot">trianglePlot</a></code>
</p>

<hr>
<h2 id='1.1.loaPlot'>
loaPlot, XYZ plots for lattice
</h2><span id='topic+1.1.loaPlot'></span><span id='topic+loaPlot'></span><span id='topic+panel.loaPlot'></span><span id='topic+panel.loaPlot2'></span><span id='topic+panel.loa'></span><span id='topic+panel.loaGrid'></span>

<h3>Description</h3>

<p>loaPlot is a standard XYZ plotting function, where X and Y are the axes of 
a conventional XY plot and Z is an element (or elements if supplied in the 
form Z1 + Z2 + Z3...) visualized at associated XY coordinates. By default, 
loaPlot links Z to plot point size and color to generate a bubbleplot style 
output, or using modified plot calls other plot types.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  loaPlot(x, data = NULL, panel = panel.loaPlot, 
        ..., local.scales = FALSE, reset.xylims = TRUE, 
        load.lists = NULL, by.group = NULL, by.zcase = NULL, 
        preprocess = TRUE)

  #standard panels

  panel.loaPlot(..., loa.settings = FALSE)
  panel.loaPlot2(..., loa.settings = FALSE)
  panel.loa(..., loa.settings = FALSE)

  #grids

  panel.loaGrid(grid.x = NULL, grid.y = NULL,
        xlim = NULL, ylim = NULL, ..., 
        grid = NULL, panel.scales = NULL)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="1.1.loaPlot_+3A_x">x</code></td>
<td>
<p> A formula with the general structure 
<code>z ~ x * y | cond</code> applied like in the <code><a href="lattice.html#topic+lattice">lattice</a></code> 
function <code><a href="lattice.html#topic+levelplot">levelplot</a></code> or a matrix. For a formula, <code>x</code> 
and <code>y</code> are the horizontal and vertical axes, <code>z</code> is any 
additional information to be used in point, symbol, surface or glyph 
generation, and <code>cond</code> is any additional conditioning to be applied. 
<code>x</code> and <code>y</code> are required elements; <code>z</code> and <code>cond</code> are 
typically optional.<br />
(Note: this element of the plot is handled by <code><a href="#topic+formulaHandler">formulaHandler</a></code>).
</p>
</td></tr>
<tr><td><code id="1.1.loaPlot_+3A_data">data</code></td>
<td>
<p> If supplied, the assumed source of elements of <code>x</code>, 
typically a <code>data.frame</code>.
</p>
</td></tr>
<tr><td><code id="1.1.loaPlot_+3A_panel">panel</code></td>
<td>
 <p><code>panel</code> is the function to be used when generating 
the content of the individual panels within the <code><a href="lattice.html#topic+lattice">lattice</a></code> 
plot. By default, this is the <code>loa</code> panel function <code>panel.loaPlot</code>. 
</p>
</td></tr>
<tr><td><code id="1.1.loaPlot_+3A_...">...</code></td>
<td>
<p> Additional arguments are passed on to related functions. 
</p>
<p>For <code>loaPlot</code> these are <code><a href="#topic+colHandler">colHandler</a></code>, 
<code><a href="#topic+cexHandler">cexHandler</a></code> and the function set by <code>panel</code>.
</p>
<p>This mechanism provides access to most common plot parameters, e.g. <code>col</code>, 
<code>pch</code>, and <code>cex</code> for plot symbol color, type and size, respectively.
By default, both data point color and size are <code>z</code>-scaled for <code>loaPlot</code>. 
If <code>z</code> is supplied, and <code>cex</code> and <code>col</code> are not set by the user in the 
plot command, these plot properties are managed by <code><a href="#topic+cexHandler">cexHandler</a></code> and 
<code><a href="#topic+colHandler">colHandler</a></code>, respectively. <code><a href="#topic+cexHandler">cexHandler</a></code> and 
<code><a href="#topic+colHandler">colHandler</a></code> arguments can be also be passed directly as part of the 
<code>loaPlot</code> command to fine-tune these, e.g. <code>cex.range</code> to change the <code>cex</code> 
range that <code>z</code> values are scaled to and <code>col.region</code> to change the color range 
that is applied to <code>z</code> when coloring points. See associated Help documents for further 
information.
</p>
</td></tr>
<tr><td><code id="1.1.loaPlot_+3A_local.scales">local.scales</code></td>
<td>
<p>For <code>loaPlot</code> only, logical. If <code>TRUE</code>, this removes the 
standard <code>lattice</code> axis from the plot. It is intended to be used with <code>panel</code> 
functions which generate their own axes or have no axes.
</p>
</td></tr>
<tr><td><code id="1.1.loaPlot_+3A_reset.xylims">reset.xylims</code></td>
<td>
<p>For <code>loaPlot</code> only, logical or character vector. If a logical, if 
the panel outputs are preprocessed (using <code>panelPal</code>), should the x and y limits be 
reset? If a character vector, one or more terms controlling post-processing plot range 
management: <code>refit.xylims</code>, equivalent to <code>reset.xylims = TRUE</code>; and <code>max.xylims</code>, 
to reset both x and y ranges to maximum.<br />
(Note: If <code>xlim</code> or <code>ylim</code> are supplied in the plot call, these will typically 
override all <code>reset.xylims</code> settings.) 
</p>
</td></tr>
<tr><td><code id="1.1.loaPlot_+3A_load.lists">load.lists</code></td>
<td>
<p>For <code>loaPlot</code> only, character vector. In-development alternative to 
list based arguments. This option identifies plot call arguments that <code>loaPlot</code> should 
manage using <code><a href="#topic+listLoad">listLoad</a></code>. See associated help documentation for further details.   
</p>
</td></tr>
<tr><td><code id="1.1.loaPlot_+3A_by.group">by.group</code>, <code id="1.1.loaPlot_+3A_by.zcase">by.zcase</code></td>
<td>
<p>For <code>loaPlot</code> only. Arguments for routine 
by group and by zcase handling of plot inputs.<br /> 
Important: These are current under review.
</p>
</td></tr>
<tr><td><code id="1.1.loaPlot_+3A_preprocess">preprocess</code></td>
<td>
<p>For <code>loaPlot</code> only, logical, passed to <code><a href="#topic+panelPal">panelPal</a></code>. If 
<code>TRUE</code>, and used with a correctly configured <code>panel</code> function, this processes 
the plot input before generating the plot. This means color scales in the different plot 
panels and the key are automatically aligned and the associated trellis object output 
contains the <code>panel</code> function outputs rather than the inputs. See <code><a href="#topic+panelPal">panelPal</a></code> 
Help documents for further information.
</p>
</td></tr>
<tr><td><code id="1.1.loaPlot_+3A_loa.settings">loa.settings</code></td>
<td>
<p>For <code>panel...</code> functions only, logical, passed to <code><a href="#topic+panelPal">panelPal</a></code> 
to manage plot reworking. See associated Help documents for further information.
</p>
</td></tr> 
<tr><td><code id="1.1.loaPlot_+3A_grid.x">grid.x</code>, <code id="1.1.loaPlot_+3A_grid.y">grid.y</code>, <code id="1.1.loaPlot_+3A_xlim">xlim</code>, <code id="1.1.loaPlot_+3A_ylim">ylim</code>, <code id="1.1.loaPlot_+3A_grid">grid</code>, <code id="1.1.loaPlot_+3A_panel.scales">panel.scales</code></td>
<td>
<p>For <code>panel.loaGrid</code> only, grid 
settings, typically recovered by <code>loaPlot</code>. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>loaPlot</code> provides lattice-style conditioning/handling for a range of 
commonly used XYZ plotting options. It is perhaps easiest pictured as a 
'mid point' alternative somewhere between the standard <code><a href="lattice.html#topic+lattice">lattice</a></code> 
plot functions <code><a href="lattice.html#topic+xyplot">xyplot</a></code> and <code><a href="lattice.html#topic+levelplot">levelplot</a></code>.
</p>
<p>The default form of the plot uses an extension of the subscripting methods 
described by Deepayan Sarkar in Chapter 5 of Lattice (see sections on 
scatterplots and extensions). The default output is a bubble plot (see example 1 
below). 
</p>


<h3>Value</h3>

<p><code>loaPlot</code> returns a trellis object, much like a conventional <code>lattice</code> 
plot function.
</p>


<h3>Note</h3>

<p><code>panel.loaPlot2</code> and <code>panel.loaPlot2</code> are alternative versions of 
<code>panel.loaPlot</code> that is currently under revision. 
</p>
<p><code>loaPlot</code> arguments <code>by.group</code> and <code>by.zcase</code> are currently in 
revision. Please use with care. 
</p>


<h3>Author(s)</h3>

<p>Karl Ropkins
</p>


<h3>References</h3>

<p>These functions make extensive use of code developed by others.  
</p>
<p>lattice:
Sarkar, Deepayan (2008) Lattice: Multivariate Data
Visualization with R. Springer, New York. ISBN
978-0-387-75968-5
</p>
<p>RColorBrewer:
Erich Neuwirth &lt;erich.neuwirth@univie.ac.at&gt; (2011). RColorBrewer:
ColorBrewer palettes. R package version 1.0-5.
http://CRAN.R-project.org/package=RColorBrewer
</p>


<h3>See Also</h3>

<p>In <code>loa</code>: <code><a href="#topic+panelPal">panelPal</a></code> 
</p>
<p>In other packages, see
</p>
<p><code><a href="lattice.html#topic+lattice">lattice</a></code>: <code><a href="lattice.html#topic+xyplot">xyplot</a></code>; and <code><a href="lattice.html#topic+levelplot">levelplot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example 1
## Basic usage

loaPlot(Ozone~Solar.R*Temp|Wind&gt;8, 
        data=airquality, 
        col.regions="Blues")

# Notes:
# Formula structure z ~ x * y |cond like levelplot.
# Data (and groups) assignment like in standard lattice plots.
# By default z is linked to col and cex. 
# Unless overridden by user inputs or group or zcase setting. 
# Plot passed via ...Handler functions to provide shortcut plot 
# reworking, e.g. here colHandler handles color scales 
# using col.region to generate a color range. 
# (Here, arguments like "Blues" and c("green", "red") are 
# allowed and handled using functions in the RColorBrewer 
# package.)

# Formula stuctures:
# ~ x * y                like xyplot y ~ x
# ~ x * y | cond         like xyplot y ~ x | cond
# z ~ x * y              like xyplot y ~ x, col=f(z), cex=f(z)
# z ~ x * y | cond       like xyplot y ~ x | cond, col=f(z), cex=f(z)
# z ~ x * y, groups = g  like xyplot y ~ x, groups=g, cex=f(z)
# z1 + z2 ~ x * y        (zcases)
# etc


## Example 2 
## Basic modifications

loaPlot(Ozone~Solar.R*Temp, groups=airquality$Wind&gt;8, 
        data=airquality) 

# When groups are applied, by default group id is linked to col.
# The follow example illustrates three options:

loaPlot(Ozone~Solar.R*Temp, groups=airquality$Wind&gt;8, 
        data=airquality,  
        group.args=c("pch"), pch=c(1,4), 
        col="blue")

# notes:
# Here, group.args is used to change the default group arguments.
# (So, pch rather than col is used to identify groups.)
# pch is then assigned by group rather than by (x,y) case or z case. 
# (See panelPal Help further further details of assignments in loa.)
# col supplied by the user supercedes the default z linkage.
# (So, here cex remains z scales but col is fixed as blue.)


## Example 3 
## Key handling

loaPlot(Ozone~Solar.R*Temp, data=airquality, 
        col.regions=c("green", "red"))

# Key settings are by the key argument (as in lattice) 
# or key... arguments via keyHandler and listLoad, so e.g.:

loaPlot(Ozone~Solar.R*Temp, data=airquality, 
        col.regions=c("green", "red"), 
        key.fun = draw.loaColorKey)

# Notes:
# By default the loaPlot uses draw.loaPlotZKey to generate 
# its color key unless an alternative is supplied via key.fun.
# (Here, the draw.colorKey wrapper draw.loaColorKey is used to 
# generate a color bar similar to that in levelplot.)



## Example 4
## panels

loaPlot(Ozone~Solar.R*Temp|Wind&gt;8, data=airquality, 
        col.regions="Reds")

# The combined use of loaPlot, panelPal and appropriately configured 
# panel functions provides automatical handling of a range of plot 
# elements, e.g.:

loaPlot(Ozone~Solar.R*Temp|Wind&gt;8, data=airquality, 
        col.regions="Reds", panel=panel.binPlot)

# Notes:
# Here, the choice of default key is set by the panel... function;
# the panel by default bins data by location and for each bin cell
# calculates the mean Ozone concentration just like a standard 
# lattice panel would, but it also tracks these values (calculated 
# within the panels) and scales panel-to-panel and panel-to-key 
# so users do not have to do that retrospectively; and, finally, 
# it retains in-panel calculations so users can recover them.
# (See associated helps for further details: ?panelPal about methods; 
# and ?panel.binPlot about the panel function.)
 
</code></pre>

<hr>
<h2 id='1.2.loaMapPlot.and.geoplotting.tools'>
Map plotting for lattice
</h2><span id='topic+1.2.loaMapPlot.and.geoplotting.tools'></span><span id='topic+loaMapPlot'></span><span id='topic+RgoogleMapsPlot'></span><span id='topic+OpenStreetMapPlot'></span><span id='topic+GoogleMap'></span><span id='topic+googleMap'></span><span id='topic+getRGMapArg'></span><span id='topic+getOSMapArg'></span><span id='topic+panel.loaBGMapPlotRaster'></span><span id='topic+panel.loaBGMapPlot'></span><span id='topic+getMapArg'></span><span id='topic+makeMapArg'></span><span id='topic+loaMapArg'></span><span id='topic+LatLon2MercatorXY'></span><span id='topic+MercatorXY2LatLon'></span><span id='topic+axis.components.loaMap'></span><span id='topic+xscale.components.loaMap'></span><span id='topic+yscale.components.loaMap'></span>

<h3>Description</h3>

<p>Plotting georeferenced data on maps using lattice, RgoogleMaps and OpenStreetMap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
  loaMapPlot(x, data = NULL, panel = panel.loaPlot, map = NULL, 
        map.panel = panel.loaBGMapPlotRaster, recolor.map = FALSE, 
        show.axes = FALSE, ..., map.source = getOSMapArg, 
        lon.lat = FALSE)

  RgoogleMapsPlot(x, data = NULL, ...)

  OpenStreetMapPlot(x, data = NULL, ...)
  
  #map handlers
  getRGMapArg(ylim, xlim, ..., lim.borders = 0.1)
  getOSMapArg(ylim, xlim, ..., lim.borders = 0.1)
  loaMapArg(object = NULL)

  #map panels
  panel.loaBGMapPlotRaster(map)
  panel.loaBGMapPlot(map)
  
  #scaling and axis handlers
  LatLon2MercatorXY(latitude, longitude, ...)
  MercatorXY2LatLon(mx, my, ...)
  axis.components.loaMap(map, xlim = NULL, ylim = NULL, ...)
  xscale.components.loaMap(lim, ..., map = map)
  yscale.components.loaMap(lim, ..., map = map)
  
  #legacy functions
  googleMap(...)
  GoogleMap(...)
  makeMapArg(...)
  getMapArg(object = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="1.2.loaMapPlot.and.geoplotting.tools_+3A_x">x</code></td>
<td>
<p> For <code>MapPlot</code>s only. A formula setting the plot 
structure, by default <code>z ~ latitude * longitude | cond</code>.
The axis elements <code>latitude</code> and <code>longitude</code> are required, 
while <code>z</code> and conditioning <code>cond</code> are optional. 
</p>
</td></tr>
<tr><td><code id="1.2.loaMapPlot.and.geoplotting.tools_+3A_data">data</code></td>
<td>
<p> For <code>MapPlot</code>s only. If supplied, the assumed source 
of the elements of formula <code>x</code>, typically a <code>data.frame</code>.
</p>
</td></tr>
<tr><td><code id="1.2.loaMapPlot.and.geoplotting.tools_+3A_panel">panel</code>, <code id="1.2.loaMapPlot.and.geoplotting.tools_+3A_map.panel">map.panel</code></td>
<td>
<p> For <code>MapPlots</code> only. The panels to use 
when generating the plot data and map layers, respectively. <code>panel</code> 
is by default the standard <code>loa</code> scatter plot panel 
<code><a href="#topic+panel.loaPlot">panel.loaPlot</a></code>. <code>map.panel</code> can 
be the default <code>panel.loaBGMapPlotRaster</code> or the alternative 
<code>panel.loaBGMapPlot</code>. 
</p>
</td></tr>
<tr><td><code id="1.2.loaMapPlot.and.geoplotting.tools_+3A_map">map</code>, <code id="1.2.loaMapPlot.and.geoplotting.tools_+3A_map.source">map.source</code></td>
<td>
<p>For <code>MapPlot</code>s and related functions only. 
If supplied, <code>map</code> is a modified <code>RgoogleMaps</code> or 
<code>OpenStreetMap</code> output, generated using either package and 
<code>getRSMapArg</code> or <code>getOSMapArg</code>, respectively. If <code>NULL</code> 
(default), the <code>MapPlot</code> using the <code>get</code> function assigned 
using <code>map.source</code> to get the map.  
</p>
</td></tr>
<tr><td><code id="1.2.loaMapPlot.and.geoplotting.tools_+3A_recolor.map">recolor.map</code></td>
<td>
<p>For <code>MapPlot</code>s only. If supplied, a vector of 
elements that R can treat as colors, used as a color scale to recolor 
<code>map</code>. This uses standard <code><a href="RColorBrewer.html#topic+RColorBrewer">RColorBrewer</a></code> functions, 
so can handle arguments like <code>recolor.map</code> <code>= c("white", "grey")</code> 
for greyscale, etc. Disabled by the default, or <code>FALSE</code> or <code>NULL</code> 
settings.    
</p>
</td></tr>
<tr><td><code id="1.2.loaMapPlot.and.geoplotting.tools_+3A_show.axes">show.axes</code></td>
<td>
<p>For <code>MapPlot</code>s only. Logical (default <code>FALSE</code>) to 
include or exclude latitude and longitude axes and associated labelling from 
<code>MapPlot</code>s.    
</p>
</td></tr>
<tr><td><code id="1.2.loaMapPlot.and.geoplotting.tools_+3A_...">...</code></td>
<td>
<p> Additional arguments are passed on to related functions. 
</p>
<p>For <code>MapPlot</code>s these are <code>getRSMapArg</code> or <code>getOSMapArg</code>, 
<code><a href="#topic+colHandler">colHandler</a></code>, <code><a href="#topic+cexHandler">cexHandler</a></code> and <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.
</p>
<p>By default both data point colour and size are <code>z</code>-scaled for <code>MapPlot</code>s. 
So, if <code>z</code> is supplied, these plot properties are managed by 
<code><a href="#topic+cexHandler">cexHandler</a></code> and <code><a href="#topic+colHandler">colHandler</a></code>, respectively, unless defined 
in the call or <code>panel</code> setup. <code><a href="#topic+cexHandler">cexHandler</a></code> and 
<code><a href="#topic+colHandler">colHandler</a></code> arguments can also be passed direct as part of a 
<code>MapPlot</code> command to fine-tune <code>z</code>-scaling, e.g. <code>cex.range</code> to 
change the <code>cex</code> range that <code>z</code> values are scaled across and 
<code>col.region</code> to change the color range that is applied to <code>z</code>. 
See associated Help documents for further information.
</p>
<p>Similarly, argument passing to <code><a href="lattice.html#topic+xyplot">xyplot</a></code> in both <code>MapPlot</code>s 
provides access to most common plot parameters, e.g. <code>col</code>, 
<code>pch</code>, and <code>cex</code> for plot symbol color, type and size, respectively. 
</p>
<p><code>getMap</code> functions pass arguments to related <code>RgoogleMaps</code> or 
<code>OpenStreetMap</code> functions.
</p>
</td></tr> 
<tr><td><code id="1.2.loaMapPlot.and.geoplotting.tools_+3A_lon.lat">lon.lat</code></td>
<td>
<p>For <code>MapPlot</code>s only, logical. If <code>TRUE</code> applies 
<code>z ~ lon * lat | cond</code>? This operation is handled 
using the <code>formula.type</code> argument in <code><a href="#topic+formulaHandler">formulaHandler</a></code>    
</p>
</td></tr>
<tr><td><code id="1.2.loaMapPlot.and.geoplotting.tools_+3A_ylim">ylim</code>, <code id="1.2.loaMapPlot.and.geoplotting.tools_+3A_xlim">xlim</code>, <code id="1.2.loaMapPlot.and.geoplotting.tools_+3A_lim.borders">lim.borders</code>, <code id="1.2.loaMapPlot.and.geoplotting.tools_+3A_lim">lim</code></td>
<td>
<p>The latitude and longitude plot ranges. 
<code>ylim</code> and <code>xlim</code> are only required by <code>get</code> functions, which 
use these to set the requested map size. The additional argument 
<code>lim.borders</code>, sets the borders to be added. The default <code>0.1</code> adds 
a 10% border to both axes, while two-element vectors allow provide separate 
control of the axes. For the axis handlers (<code>yscale...</code> and <code>xscale...</code>) 
the local alternative <code>lim</code> is used for both <code>ylim</code> and <code>xlim</code> in 
generic code.
</p>
</td></tr> 
<tr><td><code id="1.2.loaMapPlot.and.geoplotting.tools_+3A_object">object</code></td>
<td>
<p> For <code>loaMapArg</code>, the <code>MatPlot</code> plot to extract a 
<code>map</code> from. (If not supplied, this is assumed to last <code>lattice</code> plot.)
</p>
</td></tr>
<tr><td><code id="1.2.loaMapPlot.and.geoplotting.tools_+3A_latitude">latitude</code>, <code id="1.2.loaMapPlot.and.geoplotting.tools_+3A_longitude">longitude</code></td>
<td>
<p> For <code>LatLon2MercaptorXY</code>, paired latitude and 
longitude time-series to be converted to paired Mercaptor X and Y time-series.  
</p>
</td></tr>
<tr><td><code id="1.2.loaMapPlot.and.geoplotting.tools_+3A_mx">mx</code>, <code id="1.2.loaMapPlot.and.geoplotting.tools_+3A_my">my</code></td>
<td>
<p> For <code>MercaptorXYLatLon</code>, paired Mercaptor X and Y time-series 
to be converted to paired latitude and longitude time-series.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>loaMapPlot</code> provides lattice-style conditioning/handling for 
<code>RgoogleMaps</code> and <code>OpenStreetMap</code> outputs. This uses 
<code><a href="#topic+loaPlot">loaPlot</a></code> and <code><a href="#topic+panelPal">panelPal</a></code> to manage default 
panel and key settings.  
</p>
<p><code>RgoogleMapsPlot</code> is a shortcut for using <code>loaMapPlot</code> with 
maps produced by <code>RgoogleMaps</code>. 
</p>
<p><code>OpenStreetMapPlot</code> is a shortcut for using <code>loaMapPlot</code> with 
maps produced by <code>OpenStreetMap</code>. 
</p>
<p><code>getMap...</code> functions accept latitude and longitude ranges and 
related <code>RgoogleMaps</code> or <code>OpenStreetMap</code> function arguments, 
and produces an output suitable for use as the <code>map</code> argument in 
subsequent (same area) <code>MapPlot</code>s or in <code>panel.loaBGMapPlotRaster</code> 
or <code>panel.loaBGMapPlot</code> panel function calls.
</p>
<p><code>LatLon2MercatorXY</code> converts supplied latitude and longitude time-series 
to Mercator X and Y time-series. <code>MercatorXY2LatLon</code> converts supplied 
Mercator X and Y time-series to latitude and longitude time-series. Both output 
results as lists containing <code>newX</code> and <code>newY</code> elements.
</p>
<p><code>panel.loaBGMapPlotRaster</code> and <code>panel.loaBGMapPlotMaps</code> are 
<code>lattice</code> panel functions that generate map layers for a lattice 
plot using <code>getMap...</code> function outputs.
</p>
<p><code>yscale.components.loaMap</code> and <code>xscale.components.loaMap</code> 
are y- and x-axis handlers for use with the above panels.
</p>
<p><code>axis.components.loaMap</code> is a wrapper that combines 
<code>yscale.components.loaMap</code> and <code>xscale.components.loaMap</code> 
and allows both axis to be set from the <code>lattice</code> function 
argument <code>axis</code> rather than each individually, via 
<code>yscale.components</code> and <code>xscale.components</code>.
</p>
<p>NOTE: The <code>MapPlot</code>s and related panel and axis handling functions 
are in development functions that have been subject to changes.
</p>
<p><code>googleMap</code> and <code>GoogleMap</code> are <code>RgoogleMapsPlot</code> wrappers, 
included these were names of earlier versions of this function, that have 
been documented in previously published code.
</p>
<p><code>getMapArg</code> was the earlier name for <code>loaMapArg</code>. 
</p>
<p><code>quickMap</code>, a crude map plot function intended to demonstrate the use 
of the 'handler' functions, is no longer packaged but the code is included 
in the examples below.
</p>


<h3>Value</h3>

<p><code>MapPlot</code>s return trellis objects, 
much like conventional <code>lattice</code> plot functions.
</p>
<p><code>get...MapArg</code>s return <code>list</code>s for use as <code>map</code>s 
in <code>...MapPlot</code> calls.
</p>
<p><code>getMapArg</code> recovers the <code>map</code> from an existing 
<code>GoogleMap</code> output.
</p>
<p><code>panel.GoogleMapsRaster</code> and <code>panel.GoogleMaps</code>  
generate panel outputs suitable for use in standard <code>lattice</code> 
panel functions.
</p>
<p><code>yscale.components.GoogleMaps</code>, <code>xscale.components.GoogleMaps</code> 
generate suitable latitude, longitude scales for use with map layers. 
<code>axis.components.GoogleMaps</code> is a wrapper for their routine use.    
</p>


<h3>Note</h3>

<p>Google Maps outputs are 2D projections of curve sections of 
the Earth's surface. Therefore, the assignment of points 
within panels and the annotation of latitudes and 
longitudes along axis needs to be locally handled to 
account for this.
</p>
<p><code>LatLon2MercatorXY</code> and <code>MercatorXY2LatLon</code> are 
used to locally scale both axis and data in these plots. These 
apply methods and code in the <code>"sp"</code> package. 
</p>
<p>Important: Users wanting to add data to these plots, e.g. using 
<code>update</code> or <code>layers</code> in <code>latticeExtra</code>, 
should first rescale the data. Likewise, users wanting to add 
maps to other plots will need to rescale plotted data to use these 
maps. See Example 1 below.
</p>
<p>Important: map APIs often return a map panel larger than the 
data (latitude, longitude) range requested. This means you may get back 
a map that is large than necessary. As <code>xlim</code> and <code>ylim</code> 
are passed to the API when they are called reseting these can 
produce similar effects (so you may not get exactly the map range 
you ask for! If you want to manually optimise an <code>RgoogleMapsPlot</code> 
map range, the best option is currently to start with: 
</p>
<p><code>RgoogleMapsPlot(..., size=c(640,640))</code> 
</p>
<p>...and then change either or both <code>size</code> values until you generate 
an appropriate map size.  
</p>


<h3>Author(s)</h3>

<p>Karl Ropkins
</p>


<h3>References</h3>

<p>This function makes extensive use of code developed by others.  
</p>
<p>lattice:
Sarkar, Deepayan (2008) Lattice: Multivariate Data
Visualization with R. Springer, New York. ISBN
978-0-387-75968-5
</p>
<p>RColorBrewer:
Erich Neuwirth &lt;erich.neuwirth@univie.ac.at&gt; (2011). RColorBrewer:
ColorBrewer palettes. R package version 1.0-5.
http://CRAN.R-project.org/package=RColorBrewer
</p>
<p>RgoogleMaps:
Markus Loecher and Sense Networks (2011).
RgoogleMaps: Overlays on Google map tiles in R. R
package version 1.1.9.6.
http://CRAN.R-project.org/package=RgoogleMaps
</p>
<p>OpenStreetMap:
Ian Fellows and using the JMapViewer library by Jan Peter Stotz (2019).
OpenStreetMap: Access to Open Street Map Raster Images. R package version 0.3.4.
https://CRAN.R-project.org/package=OpenStreetMap
</p>
<p>sp:
Pebesma, E.J., R.S. Bivand, 2005. 
Classes and methods for spatial data in R. R News 5 (2). 
https://cran.r-project.org/doc/Rnews/.
</p>
<p>Roger S. Bivand, Edzer Pebesma, Virgilio Gomez-Rubio, 2013. 
Applied spatial data analysis with R, Second edition. Springer, NY. 
http://www.asdar-book.org/
</p>
<p>Users should also always cite map sources when using outputs from 
these <code>MapPlot</code>s:
</p>
<p>For GoogleMaps:
Map layer: Map data (c) [year] Google
</p>
<p>For OpenStreetMap
Map layer (c) OpenStreetMap contributors
</p>


<h3>See Also</h3>

  
<p>In other packages, see
</p>
<p><code>RgoogleMaps</code>: <code><a href="RgoogleMaps.html#topic+GetMap">GetMap</a></code>.
</p>
<p><code>OpenStreetMap</code>: <code><a href="OpenStreetMap.html#topic+openmap">openmap</a></code>.
</p>
<p><code>sp</code>: <code><a href="sp.html#topic+coordinates">coordinates</a></code>; <code><a href="sp.html#topic+proj4string">proj4string</a></code>; and, 
<code><a href="sp.html#topic+spTransform">spTransform</a></code>.
</p>
<p><code>lattice</code>: <code><a href="lattice.html#topic+xyplot">xyplot</a></code>; <code><a href="lattice.html#topic+panel.xyplot">panel.xyplot</a></code>; and 
<code><a href="lattice.html#topic+panel.levelplot">panel.levelplot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example 1
## quickMap code
## as example of third-party use of functions

quickMap &lt;- function(lat, lon, show.data = FALSE, ...){

    #get map
    map &lt;- getRGMapArg(lat, lon, ...)

    #scale axis for map projection
    map.axis.comps &lt;- axis.components.loaMap(map)
    map.axis &lt;- function(components, ...) 
                   axis.default(components = map.axis.comps, ...)

    #scale data for map projection
    temp &lt;- LatLon2MercaptorXY(lat, lon)
    lat &lt;- temp$newY
    lon &lt;- temp$newX

    #plot data on map
    xyplot(lat~lon, 
           xlim = map$xlim, ylim = map$ylim,
           aspect = map$aspect, 
           axis = map.axis,
           panel = function(...){
               panel.loaGBMapPlotRaster(map)
               if(show.data)
                   panel.xyplot(...)
           }, ...)
}

## Example 2
## Off-line loaMapPlot example:

loaMapPlot(zinc~latitude*longitude, col.regions=c("grey", "darkred"), 
           data=lat.lon.meuse, map=roadmap.meuse)

#  Note 1:
#  Here, the map argument is supplied so example works off-line. 
#  If not supplied and R is on-line, the MapPlots will get map 
#  from either Google or OpenStreetMap API. Repeat any of above 
#  without map argument   when on-line. For example:
## Not run: 
loaMapPlot(zinc~latitude*longitude, col.regions=c("grey", "darkred"), 
           data=lat.lon.meuse)
## End(Not run)
#  (The map will appear slightly different because non-default 
#  size and maptype settings were used to make roadmap.meuse. See 
#  ?roadmap.meuse for details.)  

#  Note 2:
#  To make a map for use with panel.loaBGMapPlotRaster or panel.loaBGMapPlotRaster  
#  without plotting use makeRGMapArg() or makeOSMapArg(). 
#  To recover a map from a previously plotted loa MapPloy use loaMapArg(). 

#  Note 3:
#  Other example loaMapPlots (also not run):   
#  using panel.binPlot to change data layer
## Not run: 
loaMapPlot(zinc~latitude*longitude, col.regions=c("grey", "darkred"),
           panel=panel.binPlot, data=lat.lon.meuse)
## End(Not run)
#  using zcase panelling to handle multiple z terms 
## Not run: 
loaMapPlot(cadmium*50+copper*10+lead*2+zinc~latitude*longitude, 
           col.regions=c("grey", "darkred"), key.z.main="Concentrations", 
           panel.zcases = TRUE, data=lat.lon.meuse)
## End(Not run)
#   using a specialist panel to handle multiple z terms 
#   (Please note: This will take a while...)
## Not run: 
loaMapPlot(cadmium*50+copper*10+lead*2+zinc~latitude*longitude, 
           col.regions=c("grey", "darkred"), panel=panel.zcasePiePlot,
           data=lat.lon.meuse)
## End(Not run)

#  Note 4: 
#  For all maps generated in above examples, the Map layer is 
#  (c) OpenStreetMap contributors

</code></pre>

<hr>
<h2 id='1.3.trianglePlot'>
Triangle plots
</h2><span id='topic+1.3.triangle.plots'></span><span id='topic+trianglePlot'></span><span id='topic+panel.trianglePlot'></span><span id='topic+panel.triangleByGroupPolygon'></span><span id='topic+panel.triangleKernelDensity'></span><span id='topic+panel.triangleSurfaceSmooth'></span><span id='topic+panel.trianglePlotFrame'></span><span id='topic+panel.trianglePlotAxes'></span><span id='topic+panel.trianglePlotGrid'></span><span id='topic+triLimsReset'></span><span id='topic+triABC2XY'></span><span id='topic+triXY2ABC'></span><span id='topic+triABCSquareGrid'></span>

<h3>Description</h3>

<p>Triangle plot functions for Lattice. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
   trianglePlot(x, data = NULL, ..., ref.cols = TRUE)

   #standard panels

   panel.trianglePlot(x = NULL, y = NULL, a0 = NULL, b0 = NULL, 
            c0 = NULL, ..., loa.settings = FALSE, plot = TRUE, 
            process = TRUE)
   panel.trianglePlotFrame(...,  grid = NULL, axes = NULL)
   panel.trianglePlotGrid(alim = NULL, blim = NULL, clim = NULL, 
            ..., grid = TRUE, panel.scales = NULL)
   panel.trianglePlotAxes(alim = NULL, blim = NULL, clim = NULL, 
            ..., axes = TRUE, ticks=TRUE, annotation=TRUE, 
            panel.scales = NULL)  

   #other panels
   panel.triangleByGroupPolygon(x = NULL, y = NULL, a0 = NULL, 
            b0 = NULL, c0 = NULL, ..., loa.settings = FALSE, 
            plot = TRUE, process = TRUE) 
   panel.triangleKernelDensity(x = NULL, y = NULL, a0 = NULL, 
            b0 = NULL, c0 = NULL, ..., loa.settings = FALSE, 
            plot = TRUE, process = TRUE) 
   panel.triangleSurfaceSmooth(x = NULL, y = NULL, z = NULL, 
            a0 = NULL, b0 = NULL, c0 = NULL, ..., loa.settings = FALSE, 
            plot = TRUE, process = TRUE) 

   #data handlers

   triABC2XY(a, b = NULL, c = NULL, ..., force.abc = TRUE, 
            if.na = "remove.row", if.neg = "remove.row", 
            verbose = FALSE)
   triXY2ABC(x, y = NULL, ..., force.xy = TRUE, 
            verbose = FALSE)
   triLimsReset(ans)
   triABCSquareGrid(a, b = NULL, c = NULL, ..., n=100)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="1.3.trianglePlot_+3A_x">x</code></td>
<td>
<p> For <code>trianglePlot</code> only, a formula in structure 
<code>z ~ a0 + b0 + c0 | cond</code>. The elements <code>a0</code>, <code>b0</code> 
and <code>c0</code>, the inputs for the three axis on the triangle plot, 
are required, while <code>z</code> and conditioning (<code>cond</code>) are optional. 
(For other functions, <code>x</code> may be used as the pair to <code>y</code>. 
See <code>y</code> below.)  
</p>
</td></tr>
<tr><td><code id="1.3.trianglePlot_+3A_data">data</code></td>
<td>
<p> For <code>trianglePlot</code> only, if supplied, the assumed source 
of the elements of formula <code>x</code>, typically a <code>data.frame</code>.
</p>
</td></tr>
<tr><td><code id="1.3.trianglePlot_+3A_...">...</code></td>
<td>
<p> Additional arguments. 
</p>
</td></tr>
<tr><td><code id="1.3.trianglePlot_+3A_ref.cols">ref.cols</code></td>
<td>
<p> Either a logical to turn off/on grid color-coding or a 
vector of colors to be applied to a0, b0 and c0 axes and grids. These are 
applied to the grid lines and axes tick and annotation components. Some users, 
particularly those less familiar with triangle plots, can find such color 
referencing helpful when analyzing such plots. By default, the colorings are 
quite subtle, so users can see the effect if them look for it but it does not 
take over the plot when it is not focused on. Finer control can be achieved using 
<code>axes</code>, <code>ticks</code>, <code>grid</code>, etc. (See below).  
</p>
</td></tr>
<tr><td><code id="1.3.trianglePlot_+3A_y">y</code>, <code id="1.3.trianglePlot_+3A_a">a</code>, <code id="1.3.trianglePlot_+3A_a0">a0</code>, <code id="1.3.trianglePlot_+3A_b">b</code>, <code id="1.3.trianglePlot_+3A_b0">b0</code>, <code id="1.3.trianglePlot_+3A_c">c</code>, <code id="1.3.trianglePlot_+3A_c0">c0</code>, <code id="1.3.trianglePlot_+3A_z">z</code></td>
<td>
<p>(and <code>x</code> in relevant functions). <code>a/a0</code> , <code>b/b0</code> and 
<code>c/c0</code> are the three scales of the triangle plot, and <code>x</code> and <code>y</code> 
are the equivalent 2-D projections. The arguments are typically options in panel functions 
(<code>panel...</code> functions), conversion functions (<code>triABC2XY</code> and <code>triXY2ABC</code>) and 
the scaling function <code>triLimsReset</code>. <code>z</code> is the z-case from the plot formula.  
</p>
</td></tr>
<tr><td><code id="1.3.trianglePlot_+3A_loa.settings">loa.settings</code>, <code id="1.3.trianglePlot_+3A_plot">plot</code>, <code id="1.3.trianglePlot_+3A_process">process</code></td>
<td>
<p><code><a href="#topic+loaPlot">loaPlot</a></code> arguments used to manage 
<code><a href="#topic+panelPal">panelPal</a></code> activity.
</p>
</td></tr>  
<tr><td><code id="1.3.trianglePlot_+3A_grid">grid</code>, <code id="1.3.trianglePlot_+3A_axes">axes</code>, <code id="1.3.trianglePlot_+3A_ticks">ticks</code>, <code id="1.3.trianglePlot_+3A_annotation">annotation</code></td>
<td>
<p> User-resets for the axes, grid, tick and annotation 
elements of the plots. These can be <code>NULL</code> or <code>FALSE</code> to turn off, <code>TRUE</code> to show, 
a vector (in which case they are assumed to be color assignments) or a list of standard plot 
parameters, e.g. <code>col</code>, <code>lty</code>, <code>lwd</code>, etc. for color, line type and line thickness, 
etc. Plot parameter assignments are applied to all axes unless specific axes are identified. For 
example, <code>trianglePlot</code> calls including <code>grid.col = 2</code> make 
all axes red, while calls including <code>grid.a0.col = 2</code> only 
recolor the first (a0) axis.
</p>
</td></tr>
<tr><td><code id="1.3.trianglePlot_+3A_alim">alim</code>, <code id="1.3.trianglePlot_+3A_blim">blim</code>, <code id="1.3.trianglePlot_+3A_clim">clim</code></td>
<td>
<p> Delimiters for a, b and c scales, equivalent to <code>xlim</code> 
and <code>ylim</code> in conventional plots, but less flexible. See Details below for 
more information.
</p>
</td></tr>
<tr><td><code id="1.3.trianglePlot_+3A_panel.scales">panel.scales</code></td>
<td>
<p> A local argument, typically a list, that controls the 
appearance of the a0/b0/c0 axes. This is roughly equivalent to the <code>scales</code> 
argument used by conventional <code>lattice</code> plots to handle x and y axis, 
but intended for non-standard scales, such as the triangle axes used here. 
It can be set directly or used in combination with the local scale(s) handler 
function <code><a href="#topic+localScalesHandler">localScalesHandler</a></code> to override/hijack standard scales 
operations. (See note below).
</p>
</td></tr>
<tr><td><code id="1.3.trianglePlot_+3A_force.abc">force.abc</code>, <code id="1.3.trianglePlot_+3A_force.xy">force.xy</code></td>
<td>
<p>Logicals. If a list or data.frame is supplied 
to <code>triABC2XY</code> or <code>triXY2ABC</code> as a source or a/b/c or x/y respectively 
should appropriately named elements be used regardless of order? See Note below.
</p>
</td></tr> 
<tr><td><code id="1.3.trianglePlot_+3A_if.na">if.na</code></td>
<td>
<p> Character. Handling method to be used if <code>NAs</code> are present. 
The default option <code>'remove.row'</code> replaces all enteries in the same row with 
<code>NAs</code>. (Note: this is different from <code><a href="stats.html#topic+na.omit">na.omit</a></code> which would 
remove the whole row. Here, the row is retained as <code>NAs</code> to maintain 
indices for conditioning.) Other options currently include: <code>'make.zero'</code> 
to replace the <code>NA</code> with <code>0</code>; and <code>'keep.as.is'</code> to leave 
unchanged. 
</p>
</td></tr> 
<tr><td><code id="1.3.trianglePlot_+3A_if.neg">if.neg</code></td>
<td>
<p> Character. Like <code>if.na</code> but for negative values: 
<code>'remove.row'</code> to replace all enteries in the same row with 
<code>NAs</code>; <code>'make.zero'</code> to replace all negative values with 
<code>0</code>; <code>'rescale.col'</code> recales any column (i.e., <code>a</code>, <code>b</code> or 
<code>c</code>) that contains a negative from zero by subtracting the minimum.
</p>
</td></tr> 
<tr><td><code id="1.3.trianglePlot_+3A_verbose">verbose</code></td>
<td>
<p> Logical, default <code>FALSE</code>. Should a full output be returned? 
The alternative <code>FALSE</code> generates a minimal report. 
</p>
</td></tr> 
<tr><td><code id="1.3.trianglePlot_+3A_ans">ans</code></td>
<td>
<p>For <code>triLimsReset</code> only, a trellis ouput, e.g. a <code>lattice</code> plot, 
to be scaled and plotted based on the assumption that it is a <code>trianglePlot</code>.
</p>
</td></tr>
<tr><td><code id="1.3.trianglePlot_+3A_n">n</code></td>
<td>
<p>For <code>triABCSquareGrid</code> only, number of points to divide each axes by 
when generating the data grid.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>trianglePlot</code> generates a triangle plot using the lattice framework.
</p>
<p><code>panel.trianglePlot...</code> functions handle the appearance of triangle plot
outputs. 
</p>
<p><code>panel.trianglePlot</code>, which is assigned as the default <code>panel</code> 
manages both the data layer of the plot and the plot frame (axes, grid, annotation, 
etc). 
</p>
<p><code>panel.trianglePlotAxes</code> and <code>panel.trianglePlotGrid</code> generate 
axes and grid componets of the plot, and <code>panel.trianglePlotFrame</code> is 
a wrapper for these. The data layer, which by default is <code>panel.loaPlot</code>, 
can be accessed separately using the <code>data.panel</code> argument. 
</p>
<p><code>triangleKernelDensity</code> generates a kernel density surface for supplied <code>a0</code>, 
<code>b0</code> and <code>c0</code> cases. 
</p>
<p><code>triangleSurfaceSmooth</code> generates a smoothed surface for supplied <code>a0</code>, 
<code>b0</code>, <code>c0</code> and <code>z</code> cases. 
</p>
<p><code>triABC2XY</code> converts supplied (a, b, c) coordinates to an (x, y) scale suitable 
for use with triangle plot functions. 
</p>
<p><code>triXY2ABC</code> converts supplied (x,y) coordinates from triangle plots to the associated 
proportional (a, b, c) scale. 
</p>
<p>There are various options for range limiting with <code>triABC2XY</code>, <code>triXY2ABC</code>, 
and therefore triangle plots. Firstly, limits can be set individually with 
<code>alim</code>, <code>blim</code> and <code>clim</code>, much like with <code>xlim</code> and <code>ylim</code> for 
conventional plots. However, they can also be set at once using <code>lims</code>, as in e.g. 
<code>lims = c(0, 1)</code> to set all axes to full ranges, or on the basis of minimum and maximum 
cut-offs using <code>abc.mins</code> and <code>abc.maxs</code>, respectively.    
</p>
<p><code>trianglePlot</code> uses <code><a href="#topic+localScalesHandler">localScalesHandler</a></code> to override normal 
<code>lattice</code> handling of <code>scales</code>. This allows parameters for axes other 
than <code>'x'</code> and <code>'y'</code> to be passed via the <code>scales</code> argument for 
axis generation within the plot panel itself. The function does this by recovering 
the information for each of the local axes (here <code>a0</code>, <code>b0</code> and <code>c0</code>) 
from <code>scales</code>, and passing this on to the plot as the argument 
<code>panel.scales</code> which can then be evaluated by an appropriate <code>panel...</code> 
function like <code>panel.trianglePlotAxes</code>. At the same time it also resets 
<code>scales</code> to stop the standard axes being generated. The intention here is two-fold. 
Firstly, to provide plot users with an axes control mechanism like the standard 
<code>scales</code> control of <code>x</code> and <code>y</code> that they already know. And, secondly, 
to provide developers with a simple framework for the quick addition of non-standard axes 
or scales. See <code><a href="#topic+localScalesHandler">localScalesHandler</a></code> and <code><a href="#topic+panel.localScale">panel.localScale</a></code> for 
further details.
</p>
<p><code>trianglePlot</code> uses <code><a href="#topic+getPlotArgs">getPlotArgs</a></code> to manage <code>lattice</code> defaults and 
plot developer and user resets for the different plot components (axes, ticks, grid, 
annotation). As with <code>localScalesHandler</code>, the intention here is to provide more 
routine access to higher level plot control.    
</p>


<h3>Value</h3>

<p><code>trianglePlot</code> returns trellis objects, much like 
conventional <code>lattice</code> plot functions.
</p>
<p><code>panel.trianglePlot...</code> functions are intended for use 
within a <code>trianglePlot</code> function call. 
</p>
<p><code>triABC2XY</code> returns a list containing the named 
components <code>x</code> and <code>y</code>, which are the 2-D (x,y) transformations 
of supplied (a,b,c) <code>trianglePlot</code> elements.
</p>
<p><code>triXY2ABC</code> returns a list containing the named 
components <code>a</code>, <code>b</code> and <code>c</code>, which are the (a,b,c) 
triangle plot coordinates associated with supplied 2-D (x, y) that 
<code>trianglePlot</code> would generate.
</p>
<p><code>resetTriLims</code> returns a supplied trellis object, rescaled 
based on the assumption that it is a triangle plot.
</p>


<h3>Note</h3>

<p>General: 
</p>
<p>With triangle plots, the (a0, b0, c0) scales are proportional. So regardless of the 
absolute sizes of a coordinate set (a,b,c), values are plotted and handled 
as proportions, i.e. a/(a+b+c), b/(a+b+c) and c/(a+b+c), respectively. This means 
that absolute values of <code>a</code>, <code>b</code> and <code>c</code> are lost when points are 
plotted on these axes. So, the function <code>triXY2ABC</code> returns the relative proportions 
of <code>a</code>, <code>b</code> and <code>c</code>, not the absolute amounts, when translating a 2-D 
(x,y) coordinates into the associated (a, b, c) coordinates.  
</p>
<p>Development:
</p>
<p>This is an in-development plot, and 'best handling' strategies have not been decided for 
several elements. So, future versions of these functions may differ significantly from the 
current version. 
</p>
<p>In particular:
</p>
<p>Current axes assignments, e.g. (a, b, c) versus (a0, b0, c0), etc., have not be finalised. 
So, these may change in future versions of the function. 
</p>
<p>Currently, <code>trianglePlot</code> scale adjustment options have been limited. Options under 
evaluation include: (1) by <code>alim</code>, <code>blim</code>, <code>clim</code> setting, equivalent to 
<code>xlim</code> and <code>ylim</code>, (2) by <code>lims</code> to set all axes ranges the same, and 
(3) by <code>maxs</code> to setting all axes range maximums and <code>mins</code> to set all axes 
range minimums, etc. 
</p>
<p>These options are currently only avialable via the data converters. 
</p>
<p>One of the issues here is that the axes ranges are all inter-linked. The range of one axes 
is a function of the other two axes ranges. So, setting these can generate contradictions. 
For example, <code>lims=c(0,0.1)</code> should in theory set all ranges to (0, 0.1). But, the triangle 
<code>a = b = c = c(0, 0.1)</code> cannot exist. Therefore, the plot would attempt to recover 
the extended range that includes all the requested ranges (<code>a = c(0, 0.1)</code>, 
<code>b = c(0, 0.1)</code>  and <code>c = c(0, 0.1)</code>), which in this case is the full 
range: <code>a = b = c = c(0, 1)</code>. Suggestions on this topic are very welcome. 
</p>
<p><code>trianglePlot</code>:
</p>
<p>As part of the <code>loa</code> version 0.2.19 update, <code>trianglePlot</code> was rewritten to run 
with the most recent version of <code><a href="#topic+panelPal">panelPal</a></code> function. This means all plot 
functions in <code>loa</code> now use the most recent version of <code><a href="#topic+panelPal">panelPal</a></code>. 
</p>
<p>This update should provide improved plot handling similar to recent versions of <code><a href="#topic+loaPlot">loaPlot</a></code> 
and <code><a href="#topic+GoogleMap">GoogleMap</a></code> functions which both already (from versions 0.2.0 onwards) use the latest 
version of <code>panelPal</code>.
</p>
<p><code>panel.trianglePlotAxes</code>: 
</p>
<p>Code currently in revision. Please handle with care.
</p>
<p><code>triABC2XY, triABCSquareGrid</code>: 
</p>
<p>Code currently in revision. Please handle with care.
</p>


<h3>Author(s)</h3>

<p>Karl Ropkins
</p>


<h3>References</h3>

<p>These function makes extensive use of code developed by others.  
</p>
<p>Currently, several triangle plotting methods are under evaluation for use within 
this package. These are: 
</p>
<p>The tri-plot method of Graham and Mudgley:
</p>
<p>Graham, David J. and Mudgley, Nicholas, G. Graphical representation of particle 
shape using triangular diagrams: An Excel spreadsheet method. Earth Surface 
Processes and Landforms, 25, 1473-1477, 2000.
</p>
<p>The triangle.param method of Chessel (as coded in R package 'ade4')
</p>
<p>Dray, S. and Dufour, A.B.(2007). The ade4 package: implementing the 
duality diagram for ecologists. Journal of Statistical, Software. 22(4): 1-20.
</p>
<p>Chessel, D. and Dufour, A.B. and Thioulouse, J. (2004). The ade4 package - I - 
One-table methods. R News. 4: 5-10.
</p>
<p>Dray, S. and Dufour, A.B. and  Chessel, D. (2007). The ade4 package-II: Two-table 
and K-table methods. R News. 7(2): 47-52.
</p>
<p>And the trilinear plot of Allen as reported by Zhu:
</p>
<p>Zhu, M. (2008). How to draw a trilinear Plot. Statistical Computing &amp; Graphics, 19(1), 
June, 2008.  
</p>
<p>In this version of the package tri-plot methods are used for the <code>triABC2XY</code> and 
<code>triXY2ABC</code> transforms and a modification <code>triangle.param</code> methods is used 
to calculate suitable values for <code>alim</code>, <code>blim</code> and <code>clim</code>.
</p>
<p>As elsewhere, the use of <code>lattice</code> is also gratefully acknowledged:
</p>
<p>lattice:
Sarkar, Deepayan (2008). Lattice: Multivariate Data
Visualization with R. Springer, New York. ISBN
978-0-387-75968-5
</p>


<h3>See Also</h3>

<p>In <code>loa</code>: For in-panel axis/scale generation, see <code><a href="#topic+loaPlot">loaPlot</a></code>, <code><a href="#topic+panelPal">panelPal</a></code>, 
<code><a href="#topic+localScalesHandler">localScalesHandler</a></code> and <code><a href="#topic+panel.localScale">panel.localScale</a></code>. 
</p>
<p>In other packages: <code><a href="lattice.html#topic+xyplot">xyplot</a></code> in <code><a href="lattice.html#topic+lattice">lattice</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example 1
## Basic triangle plot usage

trianglePlot(cadmium~copper+lead+zinc|lime, 
             data=lat.lon.meuse)

# Notes:
# Formula structure z ~ a0 + b0 + c0 |cond, where a0, b0 and 
# c0 are the three axes of the triangle plot 
# Data (and groups) assignment like in standard lattice plots.
# By default z is linked to col and cex. 
# Unless overridden by user inputs or group or zcase setting. 
# Plot handling is similar to loaPlot 
# (So, see ?loaPlot and ?panelPal for further details.)

# Formula variations:
# basic triangle plot without z values assignment
# trianglePlot(~a0+b0+c0, ...) 
# ... with z values set
# trianglePlot(z~a0+b0+c0, ...)
# ... with grouping 
# trianglePlot(z~a0+b0+c0, groups=grps, ...)


## Example 2 
## Basic frame (axes, grid, tick, annotation) management 

  trianglePlot(~1+1+1, type="n", 
               grid.alpha = 0.2, 
               ticks.alpha = 0.2)         ## grid and tick alpha reset

# notes:
# Here, grid and ticks arguments are used to remove or modify these 
# elements of the plot frame individually.  
# Setting can be management in list form like in normal lattice or 
# in a loa shorthand where e.g. the argument grid.a0.lty = 1 is equivalent 
# to grid = list(a0 = list(lty = 1))
# (So, quicker if you are only changing a small number of elements.)
 
</code></pre>

<hr>
<h2 id='1.4.stackPlot'>
Stack plots
</h2><span id='topic+1.4.stack.plots'></span><span id='topic+stackPlot'></span><span id='topic+panel.stackPlot'></span>

<h3>Description</h3>

<p>Stack plot functions for Lattice. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
   
   stackPlot(x, data = NULL, ...)

   #standard panels

   panel.stackPlot(..., process=TRUE, plot=TRUE, 
            loa.settings = FALSE) 

   #data handlers
   ##currently not exported
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="1.4.stackPlot_+3A_x">x</code></td>
<td>
<p> For <code>stackPlot</code> only, a formula of general structure 
<code>y1 + y2 ~ x | cond</code>, etc. The elements 
<code>y1</code>, <code>y2</code>, etc are stacked on the y-axis, and plotted against x. 
Both are required.   
</p>
</td></tr>
<tr><td><code id="1.4.stackPlot_+3A_data">data</code></td>
<td>
<p> For <code>stackPlot</code> only, if supplied, the assumed source 
of the elements of formula <code>x</code>, typically a <code>data.frame</code>.
</p>
</td></tr>
<tr><td><code id="1.4.stackPlot_+3A_...">...</code></td>
<td>
<p> Additional arguments. 
</p>
</td></tr>
<tr><td><code id="1.4.stackPlot_+3A_loa.settings">loa.settings</code>, <code id="1.4.stackPlot_+3A_plot">plot</code>, <code id="1.4.stackPlot_+3A_process">process</code></td>
<td>
<p><code><a href="#topic+loaPlot">loaPlot</a></code> arguments used to manage 
<code><a href="#topic+panelPal">panelPal</a></code> activity.
</p>
</td></tr>  
</table>


<h3>Details</h3>

<p><code>stackPlot</code> generates a stack plot using the lattice framework.
</p>
<p><code>panel.stackPlot</code> handles the appearance of triangle plot
outputs. 
</p>


<h3>Value</h3>

<p><code>stackPlot</code> returns trellis objects, much like 
conventional <code>lattice</code> plot functions.
</p>
<p><code>panel.stackPlot</code> is intended for use 
within a <code>trianglePlot</code> function call. 
</p>


<h3>Note</h3>

<p>Development:
</p>
<p>This is an in-development plot, and 'best handling' strategies have not 
been decided for several elements. So, future versions of these functions 
may differ significantly from the current version. 
</p>
<p>In particular:
</p>
<p><code>stackPlot</code>:
</p>
<p>The <code>stackPlot</code> argument <code>x</code> may include conditioning in the form 
<code>y ~ x | cond</code>. However, exact handling is has not been defined, so may 
subject to change.   
</p>
<p>To generate the stacks, <code>stackPlot</code> resets <code>y</code> values by applying 
<code>y - min(y)</code> to each layer and then stacks them. It also generates a 
second element <code>y0</code> of asociated baselines. This is then used in 
the form <code>x = c(x, rev(x))</code>, <code>y = c(y, rev(y0))</code> with 
<code>panel.polygon</code> to generate the stack layers.   
</p>
<p><code>panel.stackPlot</code>: 
</p>
<p>Code currently in revision. Please handle with care.
</p>


<h3>Author(s)</h3>

<p>Karl Ropkins
</p>


<h3>References</h3>

<p>These function makes extensive use of code developed by others.  
</p>
<p>As elsewhere, the use of <code>lattice</code> is also gratefully acknowledged:
</p>
<p>lattice:
Sarkar, Deepayan (2008). Lattice: Multivariate Data
Visualization with R. Springer, New York. ISBN
978-0-387-75968-5
</p>


<h3>See Also</h3>

<p>In <code>loa</code>: <code><a href="#topic+loaPlot">loaPlot</a></code> and <code><a href="#topic+panelPal">panelPal</a></code>. 
</p>
<p>In other packages: <code><a href="lattice.html#topic+xyplot">xyplot</a></code> and 
<code><a href="lattice.html#topic+panel.polygon">panel.polygon</a></code>  in <code><a href="lattice.html#topic+lattice">lattice</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example 1
## Basic stack plot usage

## Not run: 
  stackPlot(lead~dist.m, data=lat.lon.meuse)
  stackPlot(cadmium+copper+lead+zinc~dist.m, data=lat.lon.meuse)
## End(Not run)

  stackPlot(cadmium*40+copper*5+lead+zinc~dist.m, data=lat.lon.meuse)
 
</code></pre>

<hr>
<h2 id='1.5.loaBarPlot'>
loaBarPlot
</h2><span id='topic+1.5.loaBarPlot'></span><span id='topic+loaBarPlot'></span>

<h3>Description</h3>

<p>Bar plot variation using for Student Project. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   loaBarPlot(x, y=NULL, groups=NULL, cond=NULL, 
            data=NULL, ..., drop.nas=TRUE, stat=NULL)  
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="1.5.loaBarPlot_+3A_x">x</code></td>
<td>
<p> Either the x case for the bar plot or a plot formula. If the x case, 
typically a vector of factor or grouping terms, used to assign x positions in 
bar plot. If a plot formula, a plot description in the format y~x|cond, where 
x is a factor or grouping term and y and cond are optional.</p>
</td></tr>
<tr><td><code id="1.5.loaBarPlot_+3A_y">y</code></td>
<td>
<p> (Optional) The y case for the bar plot, typically a vector of numeric 
terms, used with <code>stat</code> when calculating summary information for bar plots.</p>
</td></tr>
<tr><td><code id="1.5.loaBarPlot_+3A_groups">groups</code>, <code id="1.5.loaBarPlot_+3A_cond">cond</code></td>
<td>
<p> (Optional) The group case for the bar plot, typically a vector 
of factor or grouping terms.</p>
</td></tr>
<tr><td><code id="1.5.loaBarPlot_+3A_data">data</code></td>
<td>
<p> (Optional) if supplied, the assumed source 
of the plot elements, <code>x</code>, <code>y</code>, <code>groups</code> and <code>cond</code>, 
typically a <code>data.frame</code>.
</p>
</td></tr>
<tr><td><code id="1.5.loaBarPlot_+3A_...">...</code></td>
<td>
<p> Additional arguments, passed on to <code>lattice</code> function.
</p>
</td></tr>
<tr><td><code id="1.5.loaBarPlot_+3A_drop.nas">drop.nas</code></td>
<td>
<p> Option to drop <code>NAs</code> before plotting results, default 
<code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="1.5.loaBarPlot_+3A_stat">stat</code></td>
<td>
<p> If supplied, the function used to summarise <code>y</code> data after grouping 
by <code>x</code>, <code>groups</code> and <code>cond</code>. By default, this counts <code>x</code> cases 
if <code>y</code> is not supplied, or calculates sum of <code>y</code> values if these are 
supplied.
</p>
</td></tr>  
</table>


<h3>Details</h3>

<p><code>loaBarPlot</code> summarises supplied plot data and generates a bar plot using the 
lattice framework.
</p>


<h3>Value</h3>

<p><code>loaBarPlot</code> returns trellis objects, much like 
conventional <code>lattice</code> plot functions.
</p>


<h3>Note</h3>

<p>Development:
</p>
<p>This is an in-development plot, and 'best handling' strategies have not 
been decided for several elements. So, future versions of these functions 
may differ significantly from the current version. 
</p>
<p>In particular:
</p>
<p><code>loaBarPlot</code>:
</p>
<p>This is for student project, may not be staying.
</p>
<p>Code currently in revision. Please handle with care.
</p>


<h3>Author(s)</h3>

<p>Karl Ropkins
</p>


<h3>References</h3>

<p>These function makes extensive use of code developed by others.  
</p>
<p>As elsewhere, the use of <code>lattice</code> is also gratefully acknowledged:
</p>
<p>lattice:
Sarkar, Deepayan (2008). Lattice: Multivariate Data
Visualization with R. Springer, New York. ISBN
978-0-387-75968-5
</p>


<h3>See Also</h3>

<p>In <code>loa</code>: <code><a href="#topic+listUpdate">listUpdate</a></code> and <code><a href="#topic+colHandler">colHandler</a></code>. 
</p>
<p>In other packages: <code><a href="lattice.html#topic+barchart">barchart</a></code> in <code><a href="lattice.html#topic+lattice">lattice</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example 1
## Basic bar plot usage

  loaBarPlot(Species, Sepal.Width, data=iris, stat=mean)

#or equivalent using formula 
## Not run: 
  loaBarPlot(Sepal.Width~Species, data=iris, stat=mean)
## End(Not run)
 
</code></pre>

<hr>
<h2 id='2.1.specialist.panels'>
Special panel functions 01
</h2><span id='topic+2.1.specialist.panels'></span><span id='topic+panel.kernelDensity'></span><span id='topic+panel.binPlot'></span><span id='topic+panel.surfaceSmooth'></span><span id='topic+panel.loaLevelPlot'></span>

<h3>Description</h3>

<p>Specialist panel functions for use with lattice and loa plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>

panel.loaLevelPlot(x = NULL, y = NULL, z = NULL, ..., 
         loa.settings = FALSE)

panel.surfaceSmooth(x = NULL, y = NULL, z = NULL, 
         breaks = 200, x.breaks = breaks, y.breaks = breaks, 
         smooth.fun = NULL, too.far=0, ..., 
         plot = TRUE, process = TRUE, loa.settings = FALSE)

panel.kernelDensity(x, y, z = NULL, ..., n = 20, 
         local.wt = TRUE, kernel.fun = NULL, too.far = 0, 
         panel.range = TRUE, process = TRUE, plot = TRUE, 
         loa.settings = FALSE)

panel.binPlot(x = NULL, y = NULL, z = NULL, 
         breaks=20, x.breaks = breaks, y.breaks = breaks,
         x1=NULL, x2=NULL, y1=NULL, y2=NULL,
         statistic = NULL, pad.grid = FALSE, ...,
         plot = TRUE, process = TRUE, loa.settings = FALSE)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="2.1.specialist.panels_+3A_x">x</code>, <code id="2.1.specialist.panels_+3A_y">y</code>, <code id="2.1.specialist.panels_+3A_z">z</code></td>
<td>
 <p><code>lattice</code> function arguments passed down to 
individual panels. 
</p>
</td></tr>
<tr><td><code id="2.1.specialist.panels_+3A_...">...</code></td>
<td>
<p> Additional arguments, typically passed on. See below.
</p>
</td></tr> 
<tr><td><code id="2.1.specialist.panels_+3A_loa.settings">loa.settings</code>, <code id="2.1.specialist.panels_+3A_process">process</code>, <code id="2.1.specialist.panels_+3A_plot">plot</code></td>
<td>
<p> For <code>panel...</code> functions that 
intended to be handled using <code><a href="#topic+panelPal">panelPal</a></code>. <code>loa.settings</code>, 
a logical indicating if the safe mode setting should be returned. 
<code>process</code> and <code>plot</code>, logicals, indicating if the process and 
plot sections of the panel function should be run. See below and 
<code><a href="#topic+panelPal">panelPal</a></code> help documents for further details. 
</p>
</td></tr>
<tr><td><code id="2.1.specialist.panels_+3A_breaks">breaks</code>, <code id="2.1.specialist.panels_+3A_x.breaks">x.breaks</code>, <code id="2.1.specialist.panels_+3A_y.breaks">y.breaks</code></td>
<td>
<p> (For <code>panel.surfaceSmooth</code> and 
<code>panel.binPlot</code>) How many break points to introduce when smoothing 
a surface or binning data. <code>breaks</code> can be used to set the same number 
of breaks on both axes, while <code>x.breaks</code> and <code>y.breaks</code> can be 
used to set these separately. 
</p>
</td></tr>
<tr><td><code id="2.1.specialist.panels_+3A_smooth.fun">smooth.fun</code></td>
<td>
<p> (For <code>panel.surfaceSmooth</code>) A function that can fit 
a surface estimate to <code>(x,y,z)</code> data. See notes below for further 
details.
</p>
</td></tr> 
<tr><td><code id="2.1.specialist.panels_+3A_too.far">too.far</code></td>
<td>
<p> (For <code>panel.surfaceSmooth</code> and <code>panel.kernelDensity</code>) The distance from original data 
at which to stop predicting surface values. See notes below for further 
details.  
</p>
</td></tr>
<tr><td><code id="2.1.specialist.panels_+3A_n">n</code></td>
<td>
<p> (For <code>panel.kernelDensity</code>) the number of x and y 
cases to estimate when estimating density.  
</p>
</td></tr> 
<tr><td><code id="2.1.specialist.panels_+3A_local.wt">local.wt</code></td>
<td>
<p> (For <code>panel.kernelDensity</code>) A logical (default <code>TRUE</code>)
indicating if kernel density estimates should be weighed relative to other 
groups, panels, etc.  
</p>
</td></tr> 
<tr><td><code id="2.1.specialist.panels_+3A_kernel.fun">kernel.fun</code></td>
<td>
<p> (For <code>panel.kernelDensity</code>) A function that can 
estimate kernel densities. 
</p>
</td></tr> 
<tr><td><code id="2.1.specialist.panels_+3A_panel.range">panel.range</code></td>
<td>
<p> (For <code>panel.kernelDensity</code>) A logical (default 
<code>FALSE</code>) indicating if the kernel density estimation data range 
should be forced to the full panel range. See Below.   
</p>
</td></tr>
<tr><td><code id="2.1.specialist.panels_+3A_x1">x1</code>, <code id="2.1.specialist.panels_+3A_x2">x2</code>, <code id="2.1.specialist.panels_+3A_y1">y1</code>, <code id="2.1.specialist.panels_+3A_y2">y2</code></td>
<td>
<p> (For <code>panel.binPlot</code>) Vectors giving the 
bin cell dimensions used when binning <code>x</code> and <code>y</code> elements. 
Typically ignored and calculated within the plot call.
</p>
</td></tr>
<tr><td><code id="2.1.specialist.panels_+3A_statistic">statistic</code></td>
<td>
<p> (For <code>panel.binPlot</code>) the function to use when 
calculating <code>z</code> values for each set of binned. By default, this is 
<code>mean</code>. So, if a <code>z</code> element is supplied in the plot call, the 
data is binned according to <code>x</code> and <code>y</code> values, and the mean of 
<code>z</code> values within each bin reported/plotted. If <code>z</code> is not 
supplied, <code>statistic</code> is reset to <code>length</code> to generate a frequency 
plot and a warning generated.  
</p>
</td></tr>
<tr><td><code id="2.1.specialist.panels_+3A_pad.grid">pad.grid</code></td>
<td>
<p> For <code>panel.binPlot</code>, Logical, should empty bins be 
reported? If <code>TRUE</code>, they are reported as <code>NAs</code>; if <code>FALSE</code>, 
they are not reported.      
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>panel.loaLevelPlot</code> is intended for plot data structured 
for use with the <code><a href="lattice.html#topic+lattice">lattice</a></code> function <code><a href="lattice.html#topic+levelplot">levelplot</a></code>, 
e.g. regularised <code>(x,y,z)</code> or a <code>matrix</code>:
</p>
<p><code>loaPlot(..., panel = panel.loaLevelPlot)</code><br />
<code>levelplot(...) #in lattice</code><br />
</p>
<p>Other specialist <code>panel...</code> functions can be used with the 
<code><a href="lattice.html#topic+lattice">lattice</a></code> function <code><a href="lattice.html#topic+xyplot">xyplot</a></code>:
</p>
<p><code>xyplot(..., panel = panel.kernelDensity)</code><br />
<code>xyplot(..., n = 50, panel = panel.kernelDensity)</code><br />
<code>xyplot(..., panel = function(...) panel.kernelDensity(..., n = 50))</code><br />
<code>#etc</code>
</p>
<p>However, they are intended for use with <code>loa</code> plots that incorporate
<code><a href="#topic+panelPal">panelPal</a></code>. This combination provides a mechanism for the 
routine preprocessing of panel data, the association of specialist keys, 
and the routine alignment of panel and legend settings in cases where 
values are reworked within the panel function call:
</p>
<p><code>loaPlot(..., panel = panel.kernelDensity)</code><br />
<code>#etc</code>
</p>
<p><code>panel.surfaceSmooth</code> and other similar <code>panel...</code> functions 
generate smoothed surfaces using supplied <code>(x,y,z)</code> data and pass 
this to <code>panel.loaLevelPlot</code> to plot.
</p>
<p>By default, <code>panel.surfaceSmooth</code> uses <code>stats</code> function 
<code><a href="stats.html#topic+loess">loess</a></code> to generate a surface. Alternative smooths 
can be set using the <code>smooth.fun</code> argument, and the surface 
range can to controlled using the <code>too.far</code> argument. 
</p>
<p><code>panel.kernelDensity</code> generates kernel density estimations 
based on the supplied <code>x</code> and <code>y</code> data ranges. Because it is 
density plot, it counts the number of <code>z</code> values. So, <code>z</code> values 
are ignored. It is intended to be used in the form:
</p>
<p><code>loaPlot(~x*y, ..., panel = panel.kernelDensity)</code> 
</p>
<p>So, if any <code>z</code> information is supplied, users are warned that it has 
been ignored, e.g: 
</p>
<p><code>loaPlot(z~x*y, ..., panel = panel.kernelDensity)</code><br />
<code>#warning generated</code>
</p>
<p><code>panel.binPlot</code> bins supplied <code>z</code> data according to <code>x</code> and 
<code>y</code> values and associated break points (set by <code>break</code> arguments), 
and then calculates the required statistic for each of these. By default, 
this is <code><a href="base.html#topic+mean">mean</a></code>, but alternative functions can be set using the 
<code>statistic</code> argument. It is intended to be used in form:
</p>
<p><code>loaPlot(z~x*y, ..., panel = panel.binPlot)</code> 
</p>
<p>If no <code>z</code> values are supplied, as in:
</p>
<p><code>loaPlot(~x*y, ..., panel = panel.binPlot)</code> 
</p>
<p>... <code>panel.binPlot</code> resets <code>statistic</code> to <code><a href="base.html#topic+length">length</a></code> 
(again with a warning) and gives a count of the number of elements in 
each bin.
</p>


<h3>Value</h3>

<p>As with other <code>panel...</code> functions in this package, output are suitable 
for use as the <code>panel</code> argument in <code>loa</code> (and sometimes 
<code>lattice</code>) plot calls.   
</p>


<h3>Note</h3>

<p>All these <code>panel...</code> functions treat <code>col</code> and <code>col.regions</code>, 
etc, as discrete arguments. Typically, <code>col</code> links to lines (contour 
lines for surfaces, bin borders for binned data) and <code>col.regions</code> 
links any generates surface region. 
</p>
<p><code>panel.surfaceSmooth</code> passes additional arguments on to the 
<code>smooth.fun</code> to estimate surface smooths and the <code>lattice</code> 
function <code>panel.levelplot</code> to generate the associated plot. 
If no <code>kernel.fun</code> is supplied in the <code>panel</code> call, the 
<code>stats</code> function <code>loess</code> is used to estimate surface smooth.
The <code>too.far</code> argument is based on same in <code><a href="mgcv.html#topic+vis.gam">vis.gam</a></code> 
function in the <code>mgcv</code> package.
</p>
<p><code>panel.kernelDensity</code> passes additional arguments on to the 
<code>kernel.fun</code> to estimate kerenel density and the <code>lattice</code> 
function <code>panel.contourplot</code> to generate the associated plot. 
If no <code>kernel.fun</code> is supplied in the <code>panel</code> call, the 
<code>MASS</code> function <code>kde2d</code> is used to estimate kernel density.
</p>
<p><code>panel.binPlot</code> passes limited arguments on to <code>lrect</code>.
</p>
<p><code>panel.kernelDensity</code> and <code>panel.binPlot</code> are currently under 
review. 
</p>


<h3>Author(s)</h3>

<p>Karl Ropkins
</p>


<h3>References</h3>

<p>These function makes extensive use of code developed by others.  
</p>
<p>lattice:
Sarkar, Deepayan (2008) Lattice: Multivariate Data
Visualization with R. Springer, New York. ISBN
978-0-387-75968-5
</p>
<p>(for <code>panel.kernelDensity</code>) MASS package:
Venables, W. N. and Ripley, B. D. (2002) Modern Applied Statistics 
with S. Fourth edition. Springer. 
</p>
<p>(for <code>panel.surfaceSmooth</code>) mgcv package and too.far argument:
Wood, S.N. (2004) Stable and efficient multiple smoothing parameter
estimation for generalized additive models.Journal of the American
Statistical Association. 99:673-686.
Also http://www.maths.bath.ac.uk/~sw283/
</p>


<h3>See Also</h3>

<p>In <code>loa</code>: <code><a href="#topic+panelPal">panelPal</a></code>
</p>
<p>In <code><a href="lattice.html#topic+lattice">lattice</a></code>: <code><a href="lattice.html#topic+xyplot">xyplot</a></code>, 
<code><a href="lattice.html#topic+levelplot">levelplot</a></code>, 
<code><a href="lattice.html#topic+panel.contourplot">panel.contourplot</a></code>, <code><a href="lattice.html#topic+lrect">lrect</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example 1
## for data already set up for levelplot

loaPlot(volcano, panel=panel.loaLevelPlot)

## Example 2
## Surface smooth

loaPlot(copper~longitude*latitude, data= lat.lon.meuse, 
        panel=panel.surfaceSmooth, grid=TRUE, 
        too.far=0.1, col.regions=3:2)

</code></pre>

<hr>
<h2 id='2.2.specialist.panels'>
Special panel functions 02
</h2><span id='topic+2.2.specialist.panels'></span><span id='topic+panel.polarPlot'></span><span id='topic+panel.polarFrame'></span><span id='topic+panel.polarAxes'></span><span id='topic+panel.polarGrid'></span><span id='topic+panel.polarLabels'></span>

<h3>Description</h3>

<p>In development specialist panel functions for polar plotting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
panel.polarPlot(x = NULL, y = NULL, r = NULL, theta = NULL, ..., 
         data.panel = panel.loaPlot, loa.settings = FALSE, 
         plot = TRUE, process = TRUE)


#grid, axes and axes labelling

panel.polarFrame(..., grid = TRUE, axes = TRUE, labels = TRUE, 
         panel.scales = NULL, grid.panel = panel.polarGrid, 
         axes.panel = panel.polarAxes, labels.panel = panel.polarLabels)

panel.polarAxes(axes.theta = NULL, axes.r = NULL, thetalim = NULL, 
         rlim = NULL, ..., axes = NULL, panel.scales = NULL)

panel.polarGrid(grid.theta = NULL, grid.r = NULL,
         thetalim = NULL, rlim = NULL, ..., grid = NULL, 
         panel.scales = NULL)

panel.polarLabels(labels.theta = NULL, labels.r = NULL,
         thetalim = NULL, rlim = NULL, ..., labels = NULL, 
         panel.scales = NULL)


</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="2.2.specialist.panels_+3A_x">x</code>, <code id="2.2.specialist.panels_+3A_y">y</code></td>
<td>
<p> The <code>x</code> and <code>y</code> coordinates of plot points. 
</p>
</td></tr>
<tr><td><code id="2.2.specialist.panels_+3A_r">r</code>, <code id="2.2.specialist.panels_+3A_theta">theta</code></td>
<td>
<p> The equivalent polar coordinates of the plot 
points. If these are not supplied, <code>x</code> and <code>y</code> are 
assumed to be polar coordinates and these are calculated 
by the function. 
</p>
</td></tr>
<tr><td><code id="2.2.specialist.panels_+3A_...">...</code></td>
<td>
<p> Additional arguments, typically passed on. For 
<code>panel.polarPlot</code> these are passed to the <code>data.panel</code>. 
See below.  
</p>
</td></tr> 
<tr><td><code id="2.2.specialist.panels_+3A_data.panel">data.panel</code></td>
<td>
<p> The panel to use to handle data once polar 
coordinates have been checked for or generated. For 
<code>panel.polarPlot</code>, by default this is <code>panel.loaPlot</code>.  
</p>
</td></tr> 
<tr><td><code id="2.2.specialist.panels_+3A_loa.settings">loa.settings</code>, <code id="2.2.specialist.panels_+3A_plot">plot</code>, <code id="2.2.specialist.panels_+3A_process">process</code></td>
<td>
 <p><code>loa</code> panel management 
arguments, handled by <code><a href="#topic+panelPal">panelPal</a></code>. See associated 
help documentation for further details. 
</p>
</td></tr> 
<tr><td><code id="2.2.specialist.panels_+3A_grid">grid</code>, <code id="2.2.specialist.panels_+3A_axes">axes</code>, <code id="2.2.specialist.panels_+3A_labels">labels</code></td>
<td>
<p> plot management options for the grid, axis 
and axis label elements of the plot. These can be logicals (<code>TRUE</code> 
to include the element or <code>FALSE</code> to remove it) or lists of plot 
parameters.
</p>
</td></tr>
<tr><td><code id="2.2.specialist.panels_+3A_panel.scales">panel.scales</code></td>
<td>
 <p><code>loa</code> plot management argument used when 
generating grids, axes and labels within the plot panel.
</p>
</td></tr>
<tr><td><code id="2.2.specialist.panels_+3A_grid.panel">grid.panel</code>, <code id="2.2.specialist.panels_+3A_axes.panel">axes.panel</code>, <code id="2.2.specialist.panels_+3A_labels.panel">labels.panel</code></td>
<td>
<p> Used by the <code>panel...Frame</code> 
functions to identify the <code>panel...</code> functions to use when 
generating the grid, axes and axis labelling elements of the plot.
</p>
</td></tr>
<tr><td><code id="2.2.specialist.panels_+3A_axes.theta">axes.theta</code>, <code id="2.2.specialist.panels_+3A_axes.r">axes.r</code>, <code id="2.2.specialist.panels_+3A_thetalim">thetalim</code>, <code id="2.2.specialist.panels_+3A_rlim">rlim</code></td>
<td>
<p> For <code>panel.polarAxes</code> 
axes settings. <code>axes.theta</code> and <code>axes.r</code> are the <code>theta</code> and 
<code>r</code> coordinates of the axis reference points, tick marks, etc. 
<code>thetalim</code> and <code>rlim</code> are the plot/axes ranges (like <code>xlim</code> and 
<code>ylim</code> in standard <code>lattice</code> plots).
</p>
</td></tr>
<tr><td><code id="2.2.specialist.panels_+3A_grid.theta">grid.theta</code>, <code id="2.2.specialist.panels_+3A_grid.r">grid.r</code></td>
<td>
<p> Like <code>axes.theta</code> and <code>axes.r</code> but for 
grid.
</p>
</td></tr> 
<tr><td><code id="2.2.specialist.panels_+3A_labels.theta">labels.theta</code>, <code id="2.2.specialist.panels_+3A_labels.r">labels.r</code></td>
<td>
<p> Like <code>axes.theta</code> and <code>axes.r</code> but for 
labels.
</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The <code>panel.polar...</code> series of the functions are intended for 
use with <code><a href="#topic+loaPlot">loaPlot</a></code>. 
</p>
<p><code>panel.polarPlot</code> generates a 'bubble plot' style output on 
polar coordinates. It generates axes and annonation within each 
plot panel using the other panel functions.
</p>
<p><code>panel.polarGrids</code>, <code>panel.polarAxes</code> and <code>panel.polarLabels</code> 
generate plot grid, axes and axes labelling elements of the plot. 
<code>panel.polarFrame</code> provides a wrapper for these plot elements. 
</p>
<p>Users can fine-tune axes, grids and labels by supplying additional arguments 
in plot calls, or replace these elements with purpose written functions 
to more completely modify plot appearance.
</p>


<h3>Value</h3>

<p>The <code>panel.polar...</code> functions are intended to be used as the 
<code>panel</code> argument in <code>loa</code> plot calls. So, e.g.:
</p>
<p><code>a &lt;- 1:360</code><br />
<code>loaPlot(a~a*a, panel=panel.polarPlot)</code>
</p>
<p>They can also be used with relatively simple <code>lattice</code> plots. 
However, some features of <code>loa</code> plots managed by 
<code><a href="#topic+panelPal">panelPal</a></code>, e.g. default plot appearance management, 
automatic grouping and panel and key alignment will not be available.     
</p>


<h3>Note</h3>

<p><code>panel.polarPlot</code> is in-development. Function arguments may change. 
</p>


<h3>Author(s)</h3>

<p>Karl Ropkins
</p>


<h3>References</h3>

<p>These function makes extensive use of code developed by others.  
</p>
<p>lattice:
Sarkar, Deepayan (2008) Lattice: Multivariate Data
Visualization with R. Springer, New York. ISBN
978-0-387-75968-5
</p>


<h3>See Also</h3>

<p>In <code>loa</code>: <code><a href="#topic+loaPlot">loaPlot</a></code>; and <code><a href="#topic+panelPal">panelPal</a></code>.
</p>
<p>In other packages: <code><a href="lattice.html#topic+xyplot">xyplot</a></code> in <code><a href="lattice.html#topic+lattice">lattice</a></code>.
</p>

<hr>
<h2 id='2.3.specialist.panels'>
Special panel functions 03
</h2><span id='topic+2.3.specialist.panels'></span><span id='topic+panel.zcasePiePlot'></span><span id='topic+panel.zcasePieSegmentPlot'></span>

<h3>Description</h3>

<p>In development specialist panel functions for generating zcase glyph structures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
panel.zcasePiePlot(..., loa.settings = FALSE)

panel.zcasePieSegmentPlot(..., zcase.rescale=TRUE, 
         loa.settings = FALSE)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="2.3.specialist.panels_+3A_...">...</code></td>
<td>
<p> Additional arguments, typically setting the color and 
properties of the plotted glyphs. See below.  
</p>
</td></tr> 
<tr><td><code id="2.3.specialist.panels_+3A_zcase.rescale">zcase.rescale</code></td>
<td>
<p> Should the glyph element be rescaled? See below.</p>
</td></tr>
<tr><td><code id="2.3.specialist.panels_+3A_loa.settings">loa.settings</code></td>
<td>
<p> loa options, to be handled by <code>panelPal</code>. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All these <code>panel...</code> functions generate glyphs using <code>z</code> inputs and plot these 
at the associated (x, y) location. So, for example a called which used one of the panels 
and the plot formula: 
</p>
<p><code>z1 + z2+ z3 + z4 ~ x * y</code> 
</p>
<p>... would plot a series of glyphs, each containing four elements that would be scaled 
according to <code>z1</code>, <code>z2</code>, <code>z3</code> and <code>z4</code>, and each at the associated 
(x, y) location. This means there will be one discrete glyph for each row of data supplied 
to the plot call.  
</p>
<p><code>panel.zcasePiePlot</code> generates a series of x/y referenced pie graphs. By default, pie 
dimensions are assigned as: Pie size (radius) proportional to sum of z cases and scaled using 
<code><a href="#topic+cexHandler">cexHandler</a></code> (z1 + z2 + z3 + z4 for the above formula); Number of Pie segments 
equal to number of z cases (so, 4 for the above formula); Pie segment width (phi) proportional to 
the individual zcase (so, z1 / (z1 + z2 + z3 + z4)  * 360 for first pie segment for the above 
formula). 
</p>
<p><code>panel.zcasePieSegmentPlot</code> is a variation on the conventional pie plot where segement radius 
rather than segment width is varying by zcase.    
</p>


<h3>Value</h3>

<p>These <code>panel...</code> functions are intended to be used as the 
<code>panel</code> argument in <code>loa</code> plot calls. So, e.g.:
</p>
<p><code>a &lt;- 1:10</code><br />
<code>b &lt;- 10:1</code><br />
<code>loaPlot(a+b~a*a, panel=panel.zcasePiePlot)</code><br />     
<code>loaPlot(a+b~a*a, panel=panel.zcasePieSegmentPlot)</code><br />
</p>


<h3>Note</h3>

<p>Functions in development. Arguments may change, e.g.: 
</p>
<p><code>panel.zcasePieSegmentPlot</code> includes the argument <code>zcase.rescale</code>. 
This normalises data within each zcase before generating the pie segments. This 
might not stay. 
</p>


<h3>Author(s)</h3>

<p>Karl Ropkins
</p>


<h3>References</h3>

<p>These function makes extensive use of code developed by others.  
</p>
<p>lattice:
Sarkar, Deepayan (2008) Lattice: Multivariate Data
Visualization with R. Springer, New York. ISBN
978-0-387-75968-5
</p>


<h3>See Also</h3>

<p>In <code>loa</code>: <code><a href="#topic+loaPlot">loaPlot</a></code>, <code><a href="#topic+panelPal">panelPal</a></code>
</p>
<p>In other packages: <code><a href="lattice.html#topic+xyplot">xyplot</a></code> in <code><a href="lattice.html#topic+lattice">lattice</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example 1
## plotting georeferenced pie plots

#  Using a subsample of lat.lon.meuse
temp &lt;- lat.lon.meuse[sample(1:155, 15),]

## Not run: 
#  plot Cu/Pb/Zn pie plots at sampling locations
   loaPlot(copper+lead+zinc~longitude*latitude, 
           panel=panel.zcasePiePlot, data=temp)
#  then rescale smaller pie segments on the fly
## End(Not run)

loaPlot(copper*10+lead*4+zinc~longitude*latitude, 
        panel=panel.zcasePiePlot, data=temp)

</code></pre>

<hr>
<h2 id='2.4.specialist.panels'>
Special panel functions 04
</h2><span id='topic+2.4.specialist.panels'></span><span id='topic+panel.compareZcases'></span>

<h3>Description</h3>

<p>In development specialist panel functions 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
panel.compareZcases(x=x, y=y, z=NULL, ..., 
         loa.settings = FALSE) 

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="2.4.specialist.panels_+3A_x">x</code>, <code id="2.4.specialist.panels_+3A_y">y</code>, <code id="2.4.specialist.panels_+3A_z">z</code></td>
<td>
<p> Standard plot data series, typically vectors.
</p>
</td></tr>
<tr><td><code id="2.4.specialist.panels_+3A_...">...</code></td>
<td>
<p> Additional arguments, typically passed on.  
</p>
</td></tr> 
<tr><td><code id="2.4.specialist.panels_+3A_loa.settings">loa.settings</code></td>
<td>
<p> loa options, to be handled by <code>panelPal</code>. 
</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>The <code>panel.compareZcases</code> generates a simple plot which 
compares <code>z</code> and <code>y</code> elements.
</p>


<h3>Value</h3>

<p>These <code>panel...</code> functions are intended to be used as the 
<code>panel</code> argument in <code>loa</code> plot calls. So, e.g.:
</p>
<p><code>x &lt;- 1:10</code><br />
<code>y &lt;- 1:10</code><br />
<code>z &lt;- y + rnorm(10)</code><br />
<code>loaPlot(z~x*y, panel=panel.compareZcases, col.regions="Reds")</code><br />
</p>


<h3>Note</h3>

<p>These are ad hoc <code>panel...</code> functions. Not sure of their 
life expectancy... 
</p>


<h3>Author(s)</h3>

<p>Karl Ropkins
</p>


<h3>References</h3>

<p>These function makes extensive use of code developed by others.  
</p>
<p>lattice:
Sarkar, Deepayan (2008) Lattice: Multivariate Data
Visualization with R. Springer, New York. ISBN
978-0-387-75968-5
</p>


<h3>See Also</h3>

<p>In <code>loa</code>: <code><a href="#topic+loaPlot">loaPlot</a></code>, <code><a href="#topic+panelPal">panelPal</a></code>.
</p>
<p>In other packages: <code><a href="lattice.html#topic+xyplot">xyplot</a></code> in <code><a href="lattice.html#topic+lattice">lattice</a></code>.
</p>

<hr>
<h2 id='3.1.example.data'>
Example data for use with loa
</h2><span id='topic+3.1.example.data'></span><span id='topic+example.data'></span><span id='topic+lat.lon.meuse'></span><span id='topic+roadmap.meuse'></span>

<h3>Description</h3>

<p>Example data intended for use with examples in <code>loa</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
   lat.lon.meuse

   roadmap.meuse

</code></pre>


<h3>Format</h3>

<p><code>lat.lon.meuse</code> is a modified form of the <code>meuse</code> data set 
taken from the <code>sp</code> package. Here, coordinate (x,y) elements 
have been transformed to latitudes and longtiudes and the object 
class has been converted from <code>SpatialPointsDataFrame</code> to 
<code>data.frame</code>. 
</p>
<p><code>roadmap.meuse</code> is a previously downloaded map intended for 
use with off-line plot examples using <code>lat.lon.meuse</code>.
</p>


<h3>Details</h3>

<p><code>lat.lon.meuse</code> was generated using method based on <code>mzn</code> object 
production in <a href="https://github.com/etes/Geoprocessing/blob/master/heatmap.R">https://github.com/etes/Geoprocessing/blob/master/heatmap.R</a>.
</p>
<p><code>library(sp); library(gstat); library(rgdal)</code> <br />
<code> data(meuse) </code> <br /> 
<code> coordinates(meuse) =~ x + y </code> <br /> 
<code> proj4string(meuse) = CRS("+init=epsg:28992") </code> <br />      
<code> meuse1 = spTransform(meuse, CRS("+init=epsg:4326")) </code> <br />   
<code> meuse2=as.data.frame(meuse1) </code> <br />   
<code> mzn=meuse2[,c(14,13,4)] </code> <br />   
<code> names(mzn)&lt;-c("Latitude","Longitude","zinc") </code> <br />   
</p>
<p><code>roadmap.meuse</code> was generated using:
</p>
<p><code>RgoogleMapsPlot(zinc~latitude*longitude, data=lat.lon.meuse, size=c(450,500), maptype="roadmap")</code> <br />
<code>roadmap.meuse &lt;- loaMapArg()</code> <br />
</p>


<h3>References</h3>

<p>For <code>meuse</code>:
</p>
<p>M G J Rikken and R P G Van Rijn, 1993. Soil pollution with heavy metals - an inquiry 
into spatial variation, cost of mapping and the risk evaluation of copper, cadmium, 
lead and zinc in the floodplains of the Meuse west of Stein, the Netherlands. 
Doctoraalveldwerkverslag, Dept. of Physical Geography, Utrecht University 
</p>
<p>P.A. Burrough, R.A. McDonnell, 1998. Principles of Geographical Information Systems. 
Oxford University Press. 
</p>
<p>Stichting voor Bodemkartering (Stiboka), 1970. Bodemkaart van Nederland : Blad 59 Peer, 
Blad 60 West en 60 Oost Sittard: schaal 1 : 50 000. Wageningen, Stiboka. 
</p>
<p>For <code>sp</code>:
</p>
<p>Roger S. Bivand, Edzer J. Pebesma, Virgilio Gomez-Rubio, 2008.
Applied spatial data analysis with R. Springer, NY.
http://www.asdar-book.org/
</p>
<p>Pebesma, E.J., R.S. Bivand, 2005. Classes and methods for spatial
data in R. R News 5 (2), http://cran.r-project.org/doc/Rnews/.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## data structure of lat.lon.meuse

head(lat.lon.meuse)

##  Use a subsample of lat.lon.meuse

temp &lt;- lat.lon.meuse[sample(1:155, 15),]


## various loaPlot examples 
## using lat.lon.meuse

loaPlot(~longitude*latitude, data=temp)

loaPlot(cadmium~longitude*latitude, data=temp)

loaPlot(cadmium~longitude*latitude, col.regions=c("green", "red"), 
        data=temp)

loaPlot(cadmium*50+copper*10+lead*2+zinc~longitude*latitude, panel.zcases = TRUE, 
        col.regions=c("green", "red"), 
        key.z.main="Concentrations", data=temp)


## (off line) GoogleMap example
## using lat.lon.meuse and roadmap.meuse

GoogleMap(zinc~latitude*longitude, data=temp, 
          map=roadmap.meuse, col.regions=c("grey", "darkred"))

#  Note 1:
#  With loaPlot and GoogleMap, note latitude, longitude axes 
#  assignments: 
#  loaPlot plots z ~ x * y | cond. 
#  GoogleMap plots z ~ lat * lon | cond (z ~ y * x | cond)

#  Note 2:
#  Here, the map argument is supplied so example works off-line. 
#  If not supplied and R is on-line, GoogleMap will (try to) get map 
#  from the Google API. Look at:
## Not run: 
   GoogleMap(zinc~latitude*longitude, data=lat.lon.meuse, 
             col.regions=c("grey", "darkred"))
## End(Not run)
#  (The map will appear slightly different, because non-default 
#  size and maptype settings were used to make roadmap.meuse. See above.)  

</code></pre>

<hr>
<h2 id='4.1.panel.pal'>
panelPal
</h2><span id='topic+4.1.panel.pal'></span><span id='topic+panelPal.old'></span><span id='topic+panelPal'></span><span id='topic+loaHandler'></span>

<h3>Description</h3>

<p><code>lattice</code> plot management using the <code>loa</code> function <code>panelPal</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
panelPal(ans, panel = NULL, preprocess = FALSE, 
         reset.xylims = FALSE, legend = NULL,
         by.group = NULL, by.zcase = NULL, ...)

panelPal.old(x, y, subscripts, at, col.regions, ..., 
         panel = panel.xyplot, ignore = NULL, 
         group.fun = NULL)

loaHandler(panel = NULL,...)


</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="4.1.panel.pal_+3A_ans">ans</code></td>
<td>
<p> For <code>panelPal</code> only, a stanard <code>trellis</code> object, such 
as that generated by <code><a href="lattice.html#topic+lattice">lattice</a></code> function <code><a href="lattice.html#topic+xyplot">xyplot</a></code>.  
</p>
</td></tr>
<tr><td><code id="4.1.panel.pal_+3A_panel">panel</code></td>
<td>
<p> A panel function, e.g. <code>panel.xyplot</code>. If supplied in 
<code>panelPal</code> call, typically the one used to generate <code>ans</code>. If 
supplied in <code>panelPal.old</code>, the panel that is intended to used 
when generating a plot.  
</p>
</td></tr> 
<tr><td><code id="4.1.panel.pal_+3A_preprocess">preprocess</code>, <code id="4.1.panel.pal_+3A_reset.xylims">reset.xylims</code>, <code id="4.1.panel.pal_+3A_legend">legend</code>, <code id="4.1.panel.pal_+3A_by.group">by.group</code>, <code id="4.1.panel.pal_+3A_by.zcase">by.zcase</code></td>
<td>
<p> For 
<code>panelPal</code> only, <code>loa</code> plot management arguments. 
<code>proprocess</code>: Logical, should the supplied <code>panel</code> function 
be preprocessed? <code>reset.xylims</code>: Logical, should the plot dimensions 
be reset if changed, e.g. by preprocessing? <code>legend</code>: the legend as 
with standard <code>lattice</code> plots, <code>by.group</code>: a vector of plot 
argument names to be linked to any group conditioning, <code>by.zcase</code>: 
a vector of plot argument names to be linked to any z case conditioning     
See Details below. 
</p>
</td></tr>
<tr><td><code id="4.1.panel.pal_+3A_...">...</code></td>
<td>
<p> Additional arguments, typically passed on.
</p>
</td></tr> 
<tr><td><code id="4.1.panel.pal_+3A_x">x</code>, <code id="4.1.panel.pal_+3A_y">y</code>, <code id="4.1.panel.pal_+3A_subscripts">subscripts</code>, <code id="4.1.panel.pal_+3A_at">at</code>, <code id="4.1.panel.pal_+3A_col.regions">col.regions</code></td>
<td>
<p> For <code>panelPal.old</code> only, 
panel arguments passed down to individual panels. 
</p>
</td></tr>
<tr><td><code id="4.1.panel.pal_+3A_ignore">ignore</code></td>
<td>
<p> Any additional arguments that <code>panelPal.old</code> 
should ignore and pass on to <code>panel</code> unchecked/unmodified. 
</p>
</td></tr> 
<tr><td><code id="4.1.panel.pal_+3A_group.fun">group.fun</code></td>
<td>
<p> Fine control of the standard <code>lattice</code> 
plot argument <code>group</code>. It can be a vector or list containing the 
same number of elements as there as groups. These can be functions (or 
the names of functions as characters) setting individual functions for 
group or sets of parameters to be evaluated using the <code>panel</code> 
function. For example, the current <code>NULL</code> default generates a list 
of <code>col</code> and <code>pch</code> settings that produce a conventional grouped 
scatter plot output when the <code>group</code> argument is applied to the 
<code>panel</code> default <code>panel.xyplot</code>. See Details below. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>panelPal</code> provides a range of generic plot management features. 
</p>
<p>Firstly, it allows plot as well as panel defaults to be managed by the 
<code>panel...</code> function. This allows the panel developer to control 
plot-level components of the plot output, e.g. which key to use with the 
plot and what default settings to apply to it. See example 1 below.
</p>
<p>Secondly, it uses a generalised extension of the subscripting methods described 
by Deepayan Sarkar in Chapter 5 of Lattice (see sections on scatterplots and 
extensions) to automatically handle plot argument subscripting, demonstrated 
in example 2 below. 
</p>
<p>Thirdly, it applies an extension of the method used by the hexbin lattice panel 
to pass hex cell counts (calculated in panels) to the plot key and standardise 
the assignment of associated parameters within all panels to provide more 
general panel-to-panel and panel-to-scale. The method is briefly discussed in 
Chapter 14 of Sarkar. 
</p>
<p>This method has also been extended by isolating processing and plot components 
of the <code>panel...</code> function operation allowing results of any calculations 
made in-panel to be retained rather than lost when plot is generated.
</p>
<p>Fourly, <code>group...</code> and <code>zcase...</code> arguments can used to manage plot 
group and zcase based plot outputs.   
</p>
<p>Some <code>panelPal</code> are implemented if specially structured (or loa-friendly) 
<code>panel...</code> functions are supplied. These are illustrated in the final 
example below.
</p>
<p><code>loaHandler</code> is a workhorse that assesses information in 'loa' friendly 
<code>panel...</code> functions. As well as checking this, <code>loaHandler</code> also 
checks the supplied panel for any default plot settings. This allows users to 
manage the appearance of a plot from the panel or automatically associated 
color keys.  
</p>


<h3>Value</h3>

<p>Both <code>panelPal</code> and <code>panelPal.old</code> are intended to be used with 
<code>trellis</code> plot outputs.
</p>
<p><code>panelPal</code> should be employed retrospectively. So, for example:
</p>
<p><code>p1 &lt;- xyplot(...)</code><br />
<code>panelPanel(p1, ...)</code>
</p>
<p>The previous version, currently retained as <code>panelPal.old</code>, was employed 
developed as a <code>panel...</code> function wrapper and intended to be employed 
within the plot call. So, for example:
</p>
<p><code>xyplot(..., panel = function(...) panelPal(..., panel=panel))</code> 
</p>
<p>Because it is run within the plot call, and therefore within each panel called, 
it does not provide features that require panel-to-plot, panel-to-key or 
panel-to-panel communication.
</p>
<p><code>loaHandler</code> returns either a logical (<code>FALSE</code> if not loa 'friendly'; 
<code>TRUE</code> if loa 'friendly') or a list of default arguments to be used when 
plotting. 
</p>


<h3>Note</h3>

<p>The <code>by.group</code> and <code>by.zcase</code> arguments of <code>panelPal</code> and 
the <code>group.fun</code> argument of <code>panelPal.old</code> are all currently 
under review. Please do not use these.
</p>


<h3>Author(s)</h3>

<p>Karl Ropkins
</p>


<h3>References</h3>

<p>These function makes extensive use of code developed by others.  
</p>
<p>lattice:<br />
Sarkar, Deepayan (2008) Lattice: Multivariate Data
Visualization with R. Springer, New York. ISBN
978-0-387-75968-5
</p>
<p>hexbin:<br />
Dan Carr, ported by Nicholas Lewin-Koh and Martin Maechler (2013).
hexbin: Hexagonal Binning Routines. R package version 1.26.2.
http://CRAN.R-project.org/package=hexbin
</p>
<p><code>panelPal.old</code> and <code>panelPal</code> both apply an extension 
of the subscripting methods described by Deepayan Sarkar in Chapter 
5 of Lattice (see sections on scatterplots and extensions) to 
automatically handle plot argument subscripting.
</p>
<p><code>panelPal</code> applies an extension of the method used by 
hex bin lattice panel to comunicate hex cell counts (calculated 
in panels) panel-to-panel and panel-to-scale. The method is 
briefly discussed in Chapter 14 of Sarkar.
</p>


<h3>See Also</h3>

<p><code><a href="lattice.html#topic+lattice">lattice</a></code>, <code><a href="lattice.html#topic+xyplot">xyplot</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## the combination of panelPal and specially 
## structured panel... functions provides 
## several additional plot features:

require(lattice)

## example 1
## plot management from the panel... functions.

# loaHandler can used to see if a panel is loa-friendly

loaHandler(panel.xyplot)  #FALSE
loaHandler(panel.loaPlot) #panel defaults

# note that these include a list called 
# default.settings. These are settings that are  
# automatically added to the plot call.

# Here this assigns a specialist key to that 
# panel. However, the same mechanism can also 
# be used to turn off plot elements like the 
# standard lattice axes, when using in panel 
# alternatives

# first some silly data

a &lt;- rnorm(1000)
b &lt;- rnorm(1000)

# now compare:  

# default plot 
# note bubble plot style key

loaPlot(a~a*b) 

# bin plot
# with classic color key

loaPlot(a~a*b, panel = panel.binPlot) 

 
## example 2
## automatic subscripting with loa

# Other arguments are not automatically 
# aligned with the main plots. 

# For example, consider the data:

a &lt;- 1:10
ref &lt;- rep(1:2, each=5)

# and associated lattice xyplot output:

xyplot(a~a|ref, col=ref, pch=19)

# Here, the 'col' argument does not 
# automatically track plot conditioning. 

# With lattice plots you need to assign
# arguments you want to track in this 
# manner using subscripts, as discussed 
# in Lattice Chapter 5.

# Now compare a similar loaPlot:

loaPlot(~a*a|ref, col=ref, pch=19)

# Here, panelPal automatically handles 
# such subscripting. It extends this 
# assumption to all supplied arguments.  

# For example, try
## Not run: 
  loaPlot(~a*a|ref, col=ref, pch=ref)
  loaPlot(~a*a|ref, col=ref, pch=1:10)
## End(Not run)

</code></pre>

<hr>
<h2 id='4.2.plot.structure.handlers'>
Handler functions for plot structure arguments.
</h2><span id='topic+4.2.plot.structure.handlers'></span><span id='topic+formulaHandler'></span><span id='topic+matrixHandler'></span><span id='topic+stripHandler'></span><span id='topic+getZcaseDimensions'></span>

<h3>Description</h3>

<p>Function(s) for handling (front end) plot arguments like x and strip that manage 
the plot structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
  formulaHandler(x, data = NULL, groups = NULL, ..., 
        expand.plot.args = TRUE, formula.type = "z~x*y|cond", panel.zcases = FALSE, 
        coord.conversion = NULL, lattice.like = NULL, check.xy.dimensions = TRUE, 
        check.coord.dimensions = TRUE, get.zcase.dimensions = TRUE, 
        output = "extra.args")

  matrixHandler(x, data = NULL, row.values=NULL, column.values=NULL, 
                ...)

  stripHandler(..., striplab=NULL)

  getZcaseDimensions(...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="4.2.plot.structure.handlers_+3A_x">x</code></td>
<td>
<p> (For <code>formulaHandler</code>) A formula or matrix (<code>matrixHandler</code>) 
intended to be used to generate a lattice plot. See Below.
</p>
</td></tr>
<tr><td><code id="4.2.plot.structure.handlers_+3A_data">data</code></td>
<td>
<p> If supplied, the assumed source of the elements of formula 
<code>x</code>, typically a <code>data.frame</code>.
</p>
</td></tr>
<tr><td><code id="4.2.plot.structure.handlers_+3A_groups">groups</code></td>
<td>
<p> If supplied, the grouping argument to be used with 
<code>x</code> and <code>data</code>.
</p>
</td></tr>
<tr><td><code id="4.2.plot.structure.handlers_+3A_...">...</code></td>
<td>
<p> Additional arguments are passed on to related functions. 
</p>
</td></tr>
<tr><td><code id="4.2.plot.structure.handlers_+3A_expand.plot.args">expand.plot.args</code></td>
<td>
<p>For <code>formulaHandler</code> only, logical. Should any 
short elements of the plot structure be expanded? 
</p>
</td></tr>
<tr><td><code id="4.2.plot.structure.handlers_+3A_formula.type">formula.type</code></td>
<td>
<p>For <code>formulaHandler</code> only, character vector or function. 
The plot structure to be used when generating the plot, e.g. <code>z ~ x * y | cond</code> for 
<code><a href="#topic+loaPlot">loaPlot</a></code>  
</p>
</td></tr>
<tr><td><code id="4.2.plot.structure.handlers_+3A_panel.zcases">panel.zcases</code></td>
<td>
<p>For <code>formulaHandler</code> only, logical. Should zcase arguments, 
e.g. <code>z1</code> and <code>z2</code> in <code>z1 + z2 ~ x * y | cond</code>, be treated as 
panel conditioning terms rather than grouping terms?  
</p>
</td></tr>
<tr><td><code id="4.2.plot.structure.handlers_+3A_coord.conversion">coord.conversion</code></td>
<td>
<p>For <code>formulaHandler</code> only, function. If supplied, the 
conversion to use to convert coordinate information supplied using other 
coordinate systems to <code>(x, y)</code>.   
</p>
</td></tr>
<tr><td><code id="4.2.plot.structure.handlers_+3A_lattice.like">lattice.like</code></td>
<td>
<p>For <code>formulaHandler</code> only, list. For preprocessing, a list of 
plot terms that can be passed directly to <code>lattice/loa</code> plots.        
</p>
</td></tr>
<tr><td><code id="4.2.plot.structure.handlers_+3A_check.xy.dimensions">check.xy.dimensions</code>, <code id="4.2.plot.structure.handlers_+3A_check.coord.dimensions">check.coord.dimensions</code></td>
<td>
<p>For <code>formulaHandler</code> only, logicals. 
Should the formula structure be tested before attempting to generate the plot? See Note below.  
</p>
</td></tr>
<tr><td><code id="4.2.plot.structure.handlers_+3A_get.zcase.dimensions">get.zcase.dimensions</code></td>
<td>
<p>For <code>formulaHandler</code> only, logical. Should the dimensions 
of any multiple <code>zcases</code> b calculated? See Note below.  
</p>
</td></tr>
<tr><td><code id="4.2.plot.structure.handlers_+3A_output">output</code></td>
<td>
<p>For <code>formulaHandler</code> only, character vector. The format to return 
function output in.
</p>
</td></tr>
<tr><td><code id="4.2.plot.structure.handlers_+3A_row.values">row.values</code>, <code id="4.2.plot.structure.handlers_+3A_column.values">column.values</code></td>
<td>
<p>For <code>matrixHandler</code> only, row and column 
values to be assigned to supplied matrix <code>x</code>.
</p>
</td></tr>
<tr><td><code id="4.2.plot.structure.handlers_+3A_striplab">striplab</code></td>
<td>
<p>For <code>stripHandler</code> only, character vector. If supplied, the 
label to add to the panel strip when conditioning is applied. By default, it applies 
the standard <code>lattice</code> convention, i.e., show for numerics.   
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>formulaHandler</code> manages the formula component or <code>x</code> element of 
of loa plot functions. 
</p>
<p>For example, for <code>loaPlot</code> it assumes the general formula structure 
<code>z ~ x * y | cond</code>, and applies it in a similar fashion to the 
<code><a href="lattice.html#topic+lattice">lattice</a></code> function <code><a href="lattice.html#topic+levelplot">levelplot</a></code>. 
</p>
<p>Within the formula part of the plot call <code>x</code> and <code>y</code> are the 
horizontal and vertical axes, <code>z</code> is any additional information to be 
used in point, symbol, surface or glyph generation, and <code>cond</code> any 
additional conditioning to be applied. (The coordinates, <code>x</code> and 
<code>y</code>, are required elements; <code>z</code> and <code>cond</code> are typically 
optional.) 
</p>
<p><code>matrixHandler</code> converts a matrix supplied as <code>x</code> element of a 
loa plot to a formula and associated <code>data</code>. If <code>row.values</code> and 
<code>column.values</code> are supplied, these are used as <code>(x,y)</code>  
values for the supplied matrix. 
</p>
<p><code>stripHandler</code> manages the strip component of loa plot functions.
</p>
<p><code>getZcaseDimensions</code> tracks the dimensions of multiple <code>z</code> 
</p>


<h3>Value</h3>

<p><code>formulaHandler</code> returns a list, containing the plot elements 
defined in the supplied formula.
</p>
<p><code>matrixHandler</code> returns a list containing all supplied arguments, 
subject to the following modifications: matrix <code>x</code> converted to formula 
(<code>z~x*y</code>); <code>data</code>, replaced with supplied matrix content; 
<code>xlim</code> and <code>ylim</code>, added is not suppied.
</p>
<p><code>stripHandler</code> returns a list containing all supplied arguments, 
subject to the following modifications: <code>strip</code>, Updated or generated 
if not supplied; <code>striplab</code>, added to <code>strip</code> via the <code>strip</code> 
argument <code>var.name</code>, if this is undeclared in call.
</p>
<p><code>getZcaseDimensions</code> returns a list containing all the supplied 
arguments, plus two additions arguments (if supplied in the call): 
<code>zcase.zlim</code> and <code>z.rowsum.lim</code>. <code>zcase.zlim</code> is a 
list of <code>lim</code> values, one for each <code>zcase</code>. 
<code>z.rowsum.lim</code> is the range of 'by-row' sums of <code>zcases</code>.  
These are calculated using any <code>zcase</code> information supplied in 
the call.  
</p>


<h3>Note</h3>

<p>These function are in development and may be subject to changes.
</p>
<p>The current version of <code>formulaHandler</code> includes code from the 
<code>stats</code> function <code>get_all_vars</code>. It operates in a similar 
fashion to the previous version but checks zcase dimensions.
</p>
<p>The previous version of <code>formulaHandler</code> was a wrapper for 
the <code>lattice</code> function <code>latticeParseFormula</code>. This 
version of <code>formulaHandler</code> was updated to simplify multiple 
<code>z</code> argument handling.
</p>
<p>The latest version of <code>formulaHandler</code> includes more flexible 
<code>formula.type</code> handling. For example, it can now handle formulas 
that have more than two coordinates. As a result the 
<code>check.xy.dimensions</code> argument was replaced with a 
<code>check.coord.dimensions</code> argument. The previous argument 
will however remain in the function formals and function as before 
until all related code has been updated.
</p>
<p>The latest version of <code>formulaHandler</code> uses <code>getZcaseDimensions</code> 
to calculate the dimensions of <code>z</code> if it is multi-part, e.g. 
<code>z1 + z2 + etc ~ x * y</code> rather than <code>z ~ x * y</code>.
</p>
<p>The current version of <code>matrixHandler</code> is based on code from 
levelplot.matrix in <code><a href="lattice.html#topic+lattice">lattice</a></code>. If used with <code>x</code> and 
<code>data</code> arguments it will overwrite <code>data</code> with the matrix 
content.     
</p>


<h3>Author(s)</h3>

<p>Karl Ropkins
</p>


<h3>References</h3>

<p>This function makes extensive use of code developed by others.  
</p>
<p>lattice:
Sarkar, Deepayan (2008) Lattice: Multivariate Data
Visualization with R. Springer, New York. ISBN
978-0-387-75968-5
</p>


<h3>See Also</h3>

<p>In loa: <code><a href="#topic+loaPlot">loaPlot</a></code>; <code><a href="#topic+panelPal">panelPal</a></code>
</p>
<p>In other packages: <code><a href="lattice.html#topic+levelplot">levelplot</a></code> in <code><a href="lattice.html#topic+lattice">lattice</a></code>.
</p>

<hr>
<h2 id='4.3.lims.and.scales.handlers'>
Plot lims and scales handlers
</h2><span id='topic+4.3.lims.and.scales.handlers'></span><span id='topic+limsHandler'></span><span id='topic+localScalesHandler'></span><span id='topic+panel.localScale'></span><span id='topic+yscale.component.log10'></span><span id='topic+xscale.component.log10'></span>

<h3>Description</h3>

<p>In development functions for lims and scales handling with lattice plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>

limsHandler(x=NULL, y=NULL, z=NULL, ..., lim.borders = 0.05)

localScalesHandler(scales = NULL, ..., allowed.scales =c("x", "y"),  
         disallowed.scales = NULL, remove.box = FALSE)

panel.localScale(x.loc, y.loc, lim, ..., panel.scale = NULL, 
         label.before = TRUE, x.offset = NULL, y.offset = NULL, 
         axis = TRUE, ticks = TRUE, annotation = TRUE)

yscale.component.log10(...)

xscale.component.log10(...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="4.3.lims.and.scales.handlers_+3A_x">x</code>, <code id="4.3.lims.and.scales.handlers_+3A_y">y</code>, <code id="4.3.lims.and.scales.handlers_+3A_z">z</code></td>
<td>
<p><code>x</code>, <code>y</code> and/or <code>z</code> data series.
</p>
</td></tr>
<tr><td><code id="4.3.lims.and.scales.handlers_+3A_lim.borders">lim.borders</code></td>
<td>
<p>numeric vector, giving the relative border to 
extend <code>...lim</code> ranges by when generating axes or scales. The 
<code>lim.borders</code> are relative proportions. So, the default setting 
of 0.05 adds an extra +/- 5% to the data range. If multiple values 
are supplied the first three are treated as <code>x</code>, <code>y</code> and 
<code>z</code> lim.borders, respectively. If less than three values are 
supplied, the three values are generated by wrapping. So, the default 
setting of 0.05 is equivalent to c(0.05, 0.05, 0.05).
</p>
</td></tr>
<tr><td><code id="4.3.lims.and.scales.handlers_+3A_scales">scales</code>, <code id="4.3.lims.and.scales.handlers_+3A_panel.scale">panel.scale</code></td>
<td>
<p> A list of elements like the <code>scales</code> 
argument used with <code>lattice</code> functions. Current 
default elements <code>draw (= TRUE)</code>, <code>arrows (= FALSE)</code>, 
<code>tick.number (= 5)</code>, <code>abbreviate (= FALSE)</code>, 
<code>minlength (= 4)</code>, and <code>tck (= 1)</code>.
</p>
</td></tr>
<tr><td><code id="4.3.lims.and.scales.handlers_+3A_...">...</code></td>
<td>
<p> Additional arguments. 
</p>
</td></tr> 
<tr><td><code id="4.3.lims.and.scales.handlers_+3A_allowed.scales">allowed.scales</code></td>
<td>
<p> A character vector containing the names 
of the axes to be generated for as part of a local axis.  
</p>
</td></tr> 
<tr><td><code id="4.3.lims.and.scales.handlers_+3A_disallowed.scales">disallowed.scales</code></td>
<td>
<p> A character vector containing the names 
of any axes that are not required. Note: If found, these are 
removed from <code>scales</code> before evaluation.
</p>
</td></tr> 
<tr><td><code id="4.3.lims.and.scales.handlers_+3A_remove.box">remove.box</code></td>
<td>
<p> A logical, default <code>FALSE</code>. Should the 
box <code>lattice</code> typically places around standard plots be 
removed? This can be useful if you are using a <code>panel...</code> 
function to generate axes within the plot.
</p>
</td></tr>
<tr><td><code id="4.3.lims.and.scales.handlers_+3A_x.loc">x.loc</code>, <code id="4.3.lims.and.scales.handlers_+3A_y.loc">y.loc</code>, <code id="4.3.lims.and.scales.handlers_+3A_lim">lim</code></td>
<td>
<p> two member vectors setting the <code>x</code> 
and <code>y</code> locations where the scale is to be drawn (<code>x.loc</code> 
ans <code>y.loc</code>), and the limits of the range to be annotated on the 
scale (<code>lim</code>). Note: These are currently handled 'as is', i.e. 
for both locations and limit, the first element is the start point 
and the second is the end point, and any other elements are ignored.  
</p>
</td></tr>
<tr><td><code id="4.3.lims.and.scales.handlers_+3A_label.before">label.before</code>, <code id="4.3.lims.and.scales.handlers_+3A_x.offset">x.offset</code>, <code id="4.3.lims.and.scales.handlers_+3A_y.offset">y.offset</code></td>
<td>
<p> Scale annotation overrides. 
<code>label.before</code> is a logical, which controls the position of 
annotation, tick marks and/or arrows, etc relative to the scale 
line (i.e., above/left before or below/right after). By default 
<code>panel.localScale</code> generates tick marks and labels at right 
angles to the scale line/axis. <code>x.offset</code> and <code>y.offset</code> 
force the offsets when adding tick marks and annotation.  
</p>
</td></tr>
<tr><td><code id="4.3.lims.and.scales.handlers_+3A_axis">axis</code>, <code id="4.3.lims.and.scales.handlers_+3A_ticks">ticks</code>, <code id="4.3.lims.and.scales.handlers_+3A_annotation">annotation</code></td>
<td>
<p>If supplied, fine controls for the 
appearance of the axis line, axis tick marks and axis annotation 
on the generated scale. These can be vectors, in which they are 
assumed to be color assignments, or lists of common plot parameters, 
such as <code>col</code>, <code>lty</code>, <code>lwd</code>, etc.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>limsHander</code> generates <code>xlim</code>, <code>ylim</code> and/or <code>zlim</code> 
ranges for axes or color scales for use in a range of plots. 
</p>
<p><code>localScalesHandler</code> provides a relatively crude mechanism 
for the removal of conventional <code>lattice</code> plot axes and 
the generation of alternative axes using a <code>panel...</code> function 
like <code>panel.localScale</code>. 
</p>


<h3>Value</h3>

<p><code>limsHandler</code> returns a list containing <code>...lim</code> ranges for 
any of the elements <code>x</code>, <code>y</code> and/or <code>z</code> supplied to it. 
</p>
<p><code>localScalesHandler</code> returns a list containing the 
elements: <code>scales</code>, <code>panel.scales</code> and possibly 
<code>par.settings</code>. <code>scales</code> turns off the standard 
axes annotation. <code>panel.scales</code> is a list of named elements, one 
per named axis, describing the axis layout. If 
<code>remove.box = TRUE</code>, the additional argument <code>par.settings</code> 
is also supplied. 
</p>
<p>All arguments should be passed on to the associated plot. 
</p>
<p><code>panel.scales</code> or axis-specific elements in <code>panel.scales</code> 
can then be evaluated by an associated <code>panel...</code> function run 
from within the lattice plot call. This would typically 
take the form: 
</p>
<p><code>panel.my.axis(panel.scale = panel.scale$axis, ...)</code> 
</p>
<p><code>panel.localScale</code> is a local axis/scale plotter. It can be used 
in combination with <code>localScalesHandler</code>, and should called 
once for each axis that is required, or it can be used 'stand alone' 
panel to add a local scale to a lattice plot.
</p>
<p><code>yscale.component.log10</code> and <code>xscale.component.log10</code> are 
simple axis transforms for use with log to the base 10 transformed 
plot axes.
</p>


<h3>Note</h3>

<p><code>panel.localScale</code> is currently in revision. Scale arrows are 
currently not available. 
</p>


<h3>Author(s)</h3>

<p>Karl Ropkins
</p>


<h3>References</h3>

<p>These function makes extensive use of code developed by others.  
</p>
<p>lattice:
Sarkar, Deepayan (2008) Lattice: Multivariate Data
Visualization with R. Springer, New York. ISBN
978-0-387-75968-5
</p>


<h3>See Also</h3>

<p>In other packages: <code><a href="lattice.html#topic+xyplot">xyplot</a></code> in <code><a href="lattice.html#topic+lattice">lattice</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## See trianglePlot Example 2 for example application

</code></pre>

<hr>
<h2 id='4.4.cond.handlers'>
Plot Conditioning
</h2><span id='topic+4.4.cond.handlers'></span><span id='topic+4.4.conditioning.handlers'></span><span id='topic+condsPanelHandler'></span><span id='topic+groupsPanelHandler'></span><span id='topic+zcasesPanelHandler'></span><span id='topic+groupsAndZcasesPanelHandler'></span><span id='topic+groupsHandler'></span><span id='topic+zcasesHandler'></span><span id='topic+groupsAndZcasesHandler'></span><span id='topic+stepwiseZcasesGlyphHandler'></span>

<h3>Description</h3>

<p>Plot conditioning handling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
  condsPanelHandler(..., conds = NULL, panel = NULL, 
         by.cond = NULL, process = TRUE, plot = TRUE)

  groupsPanelHandler(..., groups = NULL, panel = NULL, 
         by.group = NULL, process = TRUE, plot = TRUE)

  zcasesPanelHandler(..., zcases = NULL, panel = NULL, 
         by.zcase = NULL, process = TRUE, plot = TRUE)

  groupsAndZcasesPanelHandler(panel=NULL, ..., 
         plot = TRUE, process = TRUE)  

  groupsHandler(z = NULL, groups = NULL, ..., group.ids = NULL, 
         handler = "zzz")

  zcasesHandler(z = NULL, zcases = NULL, ..., zcases.ids = NULL, 
         handler = "zzz")

  groupsAndZcasesHandler(..., loa.settings = NULL)

  stepwiseZcasesGlyphHandler(zcases = NULL, ..., zcase.ids = NULL, 
         panel.elements = NULL, loaGlyph = NULL)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="4.4.cond.handlers_+3A_...">...</code></td>
<td>
<p> Additional arguments. See Notes below.
</p>
</td></tr>
<tr><td><code id="4.4.cond.handlers_+3A_conds">conds</code>, <code id="4.4.cond.handlers_+3A_panel">panel</code>, <code id="4.4.cond.handlers_+3A_by.cond">by.cond</code></td>
<td>
<p> For all supplied additional arguments, 
<code>conds</code> is a vector of conditioning indices. This is 
typically a logical, numeric, factor or character vector which can 
be used to assign other elements undeclared call arguments to specific 
subsets. <code>panel</code> identifies the <code>panel...</code> function, and 
should also be supplied so loa can manage processing and plot activities 
correctly. <code>by.cond</code> identifies routine plot operations associated 
with the requested conditioning. This can be a list of plot arguments or 
<code>panel...</code> functions that should be associated with the requested 
conditoning. See <code>process</code> and <code>plot</code> below and associated Notes.
</p>
</td></tr>
<tr><td><code id="4.4.cond.handlers_+3A_plot">plot</code>, <code id="4.4.cond.handlers_+3A_process">process</code>, <code id="4.4.cond.handlers_+3A_loa.settings">loa.settings</code></td>
<td>
<p>Passed to and handled by <code><a href="#topic+panelPal">panelPal</a></code>. 
For panels that can be preprocessed, <code>plot</code> and <code>process</code> turn off or 
on processing and the plotting steps of the panel code. See <code><a href="#topic+panelPal">panelPal</a></code> Help 
documentation from further details. 
</p>
</td></tr>
<tr><td><code id="4.4.cond.handlers_+3A_groups">groups</code>, <code id="4.4.cond.handlers_+3A_by.group">by.group</code></td>
<td>
<p> As <code>conds</code> and <code>by.cond</code> but for 
grouping. 
</p>
</td></tr>
<tr><td><code id="4.4.cond.handlers_+3A_zcases">zcases</code>, <code id="4.4.cond.handlers_+3A_by.zcase">by.zcase</code></td>
<td>
<p> As <code>conds</code> and <code>by.cond</code> but for 
zcase condition. 
</p>
</td></tr>
<tr><td><code id="4.4.cond.handlers_+3A_z">z</code>, <code id="4.4.cond.handlers_+3A_handler">handler</code></td>
<td>
<p> The <code>z</code> data series and any associated plot arguments that 
need special handling.
</p>
</td></tr>
<tr><td><code id="4.4.cond.handlers_+3A_group.ids">group.ids</code>, <code id="4.4.cond.handlers_+3A_zcases.ids">zcases.ids</code>, <code id="4.4.cond.handlers_+3A_zcase.ids">zcase.ids</code></td>
<td>
<p> If given, vectors of the unique cases in 
<code>groups</code> and <code>zcases</code>, respectively.
</p>
</td></tr>
<tr><td><code id="4.4.cond.handlers_+3A_panel.elements">panel.elements</code></td>
<td>
<p> If given, the names of all plot arguments that have been 
vectorized by <code>panelPal</code>.
</p>
</td></tr>
<tr><td><code id="4.4.cond.handlers_+3A_loaglyph">loaGlyph</code></td>
<td>
<p> (For <code>stepwiseZcasesGlyphHandler</code> only), the loa glyph to 
drawn. See <code><a href="#topic+loa.glyphs">loa.glyphs</a></code> for further details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NOTE: These functions are currently in development and may be subject to changes.
</p>
<p><code>condsPanelHandler</code> is a general purpose function that can be used to routinely 
manage plot conditioning within a <code>panel...</code> function call. It takes all undeclared 
arguments are supplied to it, and subsets them by unique case in the supplied <code>conds</code> 
argument. Then it modifies each of these based on the associated elements of <code>by.cond</code> 
and processes and/or plots the results depending on <code>process</code> and <code>plot</code> settings.
</p>
<p><code>groupsPanelHandler</code> is similar but is intended for use with the plot call argument 
<code>groups</code>.
</p>
<p><code>zcasesPanelHandler</code> is similar but is intended for use with arguments conditioned 
within the z term of the plot formula. So, for example, for unique handling of <code>z1</code> 
and <code>z2</code> cases in the plot <code>loaPlot(z1+z2~x*y)</code>.
</p>
<p><code>groupsAndZcasesPanelHandler</code> is a wrapper for <code>groups</code> and <code>zcase</code> that 
allows users to simultaneously and uniquely handle both types of conditioning.
</p>
<p><code>stepwiseZcasesGlyphHandler</code> is a <code>...Handler</code> function for generating gylph plots 
based on multiple z inputs. 
</p>


<h3>Value</h3>

<p>All <code>..PanelHandlers</code> functions are intended for use with <code><a href="#topic+panelPal">panelPal</a></code>. 
Using different combinations of these allows plot developers a high degree of 
flexibility. 
</p>


<h3>Note</h3>

<p>This function is in development and may be subject to changes.
</p>


<h3>Author(s)</h3>

<p>Karl Ropkins
</p>


<h3>References</h3>

<p>This function makes extensive use of code developed by others.  
</p>
<p>lattice:
Sarkar, Deepayan (2008) Lattice: Multivariate Data
Visualization with R. Springer, New York. ISBN
978-0-387-75968-5
</p>


<h3>See Also</h3>

<p><code><a href="#topic+panelPal">panelPal</a></code>
</p>
<p>For information on related functions in other packages, see
</p>
<p><code><a href="lattice.html#topic+lattice">lattice</a></code>: <code><a href="lattice.html#topic+xyplot">xyplot</a></code>; 
<code><a href="lattice.html#topic+panel.xyplot">panel.xyplot</a></code>; and 
<code><a href="lattice.html#topic+panel.levelplot">panel.levelplot</a></code>.
</p>

<hr>
<h2 id='4.5.plot.argument.handlers'>
Common plot argument handlers
</h2><span id='topic+4.5.plot.argument.handlers'></span><span id='topic+cexHandler'></span><span id='topic+colHandler'></span><span id='topic+colRegionsHandler'></span><span id='topic+pchHandler'></span><span id='topic+scalesHandler'></span><span id='topic+zHandler'></span>

<h3>Description</h3>

<p>Functions for use the routine handling of some common plot arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
cexHandler(z = NULL, cex = NULL, 
           cex.range = NULL, expand.outputs = TRUE, 
           ref = NULL, ..., zlim = NULL)

colHandler(z = NULL, col = NULL, 
           region = NULL, colorkey = FALSE, legend = NULL,
           pretty = FALSE, at = NULL, cuts = 20,
           col.regions = NULL, alpha.regions = NULL,
           expand.outputs = TRUE, ref = NULL, 
           ..., zlim = NULL, output="col")

colRegionsHandler(...)

pchHandler(z = NULL, pch = NULL, pch.order = NULL, 
           expand.outputs = TRUE, ref = NULL, ..., 
           zlim = NULL)

scalesHandler(...)

zHandler(z = NULL, expand.outputs = TRUE, 
           ref = NULL, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="4.5.plot.argument.handlers_+3A_z">z</code></td>
<td>
<p>If supplied, a vector of values intended to used as a scale 
when assigning a property.
</p>
<p>For <code>cexHandler</code>, the cex of, e.g., points on a 
scatter plot. Here, size scales are managed using a reference range 
<code>cex.range</code>, but superseded by <code>cex</code> settings, if also 
supplied.
</p>
<p>For <code>colHandler</code>, the color of, e.g., points on a 
scatter plot. Here, color scales are managed using a <code>colorkey</code> method 
similar to that used by the <code><a href="lattice.html#topic+lattice">lattice</a></code> function <code><a href="lattice.html#topic+levelplot">levelplot</a></code>, 
see below (arguments <code>region</code>, <code>colorkey</code>, <code>pretty</code>, <code>at</code>, 
<code>cuts</code>, <code>col.regions</code> and <code>alpha.regions</code>). If <code>z</code> is 
<code>NULL</code> or not supplied, all colors are set by <code>col</code> if supplied 
or as the default lattice symbol color if both <code>z</code> and <code>col</code> 
are not supplied.
</p>
<p>For <code>pchHandler</code>, the pch of, e.g., points on a scatter plot. 
Here, plot symbols are managed using a reference vector  
<code>pch.order</code>, but superseded by <code>pch</code> settings, if also 
supplied.
</p>
<p>For <code>zHandler</code>, any vector that should to expanded by wrapping to a given 
length, e.g. the length of the x (or y) data series to plotting.
</p>
</td></tr> 
<tr><td><code id="4.5.plot.argument.handlers_+3A_cex">cex</code>, <code id="4.5.plot.argument.handlers_+3A_col">col</code>, <code id="4.5.plot.argument.handlers_+3A_pch">pch</code></td>
<td>
<p> For associated handlers, the parameter value(s) to be managed (i.e., 
<code>cex</code> for <code>cexHandler</code>, etc. Note: In all cases if these are not 
<code>NULL</code> these supersede any supplied <code>z</code> or 
<code>...Handler</code> modification.  
</p>
</td></tr> 
<tr><td><code id="4.5.plot.argument.handlers_+3A_cex.range">cex.range</code></td>
<td>
<p> If supplied, the range for <code>z</code> to be rescaled to when using this 
to generate a <code>cex</code> scale. NOTE: <code>cex.range = FALSE</code> disables this <code>cex</code> 
scaling and uses <code>z</code> values directly; <code>cex.range = TRUE</code> applied default scaling, 
equivalent to <code>cex.range = c(0.75, 3)</code>. 
</p>
</td></tr> 
<tr><td><code id="4.5.plot.argument.handlers_+3A_region">region</code>, <code id="4.5.plot.argument.handlers_+3A_colorkey">colorkey</code>, <code id="4.5.plot.argument.handlers_+3A_legend">legend</code>, <code id="4.5.plot.argument.handlers_+3A_pretty">pretty</code>, <code id="4.5.plot.argument.handlers_+3A_at">at</code>, <code id="4.5.plot.argument.handlers_+3A_cuts">cuts</code>, <code id="4.5.plot.argument.handlers_+3A_col.regions">col.regions</code>, <code id="4.5.plot.argument.handlers_+3A_alpha.regions">alpha.regions</code></td>
<td>
<p> The 
colorscale settings to be used when generating a colorkey. The most useful of 
these are probably <code>col.regions</code> which can be used to reset the color scale, 
<code>alpha.regions</code> which sets the col.region alpha transparency (0 for 
invisible to 1 for solid) and <code>colorkey</code> which can be a logical (forcing 
the colorkey on or off) or a list of components that can be used to fine-tune the 
appearance of the colorkey. 
Note: The generation of colorscales is handled by <code><a href="RColorBrewer.html#topic+RColorBrewer">RColorBrewer</a></code>.
</p>
</td></tr>
<tr><td><code id="4.5.plot.argument.handlers_+3A_pch.order">pch.order</code></td>
<td>
<p> A vector of symbol ids (typically the numbers 1 to 24) to used 
when plotting points if, e.g. using a scatter plot. By default, all points are 
plotted using the first of these pch ids unless any conditioning (e.g. grouping or 
zcase handling) is declared and linked to <code>pch</code>, in which symbols are assigned 
in series from <code>pch.order</code>. 
</p>
</td></tr>
<tr><td><code id="4.5.plot.argument.handlers_+3A_expand.outputs">expand.outputs</code>, <code id="4.5.plot.argument.handlers_+3A_ref">ref</code></td>
<td>
<p><code>expand.outputs</code> is a Logical (default <code>TRUE</code>): 
should outputs be expanded to the same length as <code>ref</code>? This can be useful if, 
e.g., coloring points on a scatter plot that may be conditioned and therefore may 
require <code>subscript</code> handling, in which case <code>ref</code> could be the x 
or y data series, or any other vector of the same length. Note: if 
<code>ref</code> is not supplied <code>expand.outputs</code> is ignored. 
</p>
</td></tr>
<tr><td><code id="4.5.plot.argument.handlers_+3A_zlim">zlim</code></td>
<td>
<p>The range over which the scale is to be applied if not <code>range(z)</code>.
</p>
</td></tr> 
<tr><td><code id="4.5.plot.argument.handlers_+3A_output">output</code></td>
<td>
<p> For <code>colHandler</code>. The function output. Either the <code>col</code> vector 
alone (<code>output='col'</code>) or the full list of color parameters.
</p>
</td></tr> 
<tr><td><code id="4.5.plot.argument.handlers_+3A_...">...</code></td>
<td>
<p> Additional arguments, often ignored.
</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The <code>...Handler</code> functions are argument handlers intended to 
routinely handle some common activities associated with plotting 
data. 
</p>
<p><code>cexHandler</code> manages symbol sizes. It generates a (hopefully) 
sensible <code>cex</code> scale for handling plot symbol size based on 
a supplied input (<code>z</code>). 
</p>
<p><code>colHandler</code> manages colors. It works like the colorkey in 
<code><a href="lattice.html#topic+levelplot">levelplot</a></code> in <code><a href="lattice.html#topic+lattice">lattice</a></code>, to generate a 
colorscale based on a supplied input (<code>z</code>).
</p>
<p><code>colRegionsHandler</code> is a wrapper for <code>colHandler</code> that 
can be used to with the <code>col.regions</code> argument.   
</p>
<p><code>scalesHandler</code> is a crude method to avoid scales argument 
list structures.
</p>
<p><code>zHandler</code> expands (by wrapping) or foreshortens vectors. 
</p>


<h3>Value</h3>

<p><code>cexHandler</code> returns a vector, which can be used as 
the <code>cex</code> argument in many common plotting functions 
(e.g. <code><a href="base.html#topic+plot">plot</a></code>, <code><a href="lattice.html#topic+xyplot">xyplot</a></code>).
</p>
<p><code>colHandler</code> depending on <code>output</code> setting returns 
either the <code>col</code> vector or a list containing elements (<code>z</code>, 
<code>col</code>, <code>legend</code>, <code>at</code>, <code>col.regions</code> and 
<code>alpha.regions</code>), which can be used to create a <code>col</code> 
series scaled by <code>z</code> and an associated colorkey 
like that generated by <code><a href="lattice.html#topic+levelplot">levelplot</a></code> for other 
<code><a href="lattice.html#topic+lattice">lattice</a></code> functions (e.g. <code><a href="lattice.html#topic+xyplot">xyplot</a></code>).
</p>
<p><code>colRegionsHandler</code> returns a vector of color values suitable 
for use with the <code>col.regions</code> argument.
</p>
<p><code>scalesHandler</code> returns the supplied arguments modified as follows: 
all <code>scales...</code> arguments are converted into a single <code>list(...)</code>; all 
<code>scales.x...</code> and <code>scales.y...</code> argument are converted into 
<code>list(x=list(...))</code> and <code>list(y=list(...))</code>, respectively. so e.g. 
<code>scales.x.rot=45</code> generates scales=list(x=list(rot=45)).
</p>
<p><code>pchHandler</code> returns a vector of <code>pch</code> values of an 
appropriate length, depending on <code>expand.outputs</code> and <code>ref</code> 
settings.
</p>


<h3>Note</h3>

<p><code>cexHandler</code> recently revised. Default cex range now smaller, in line 
with feedback. 
</p>
<p><code>scalesHandler</code> might not be staying.
</p>


<h3>Author(s)</h3>

<p>Karl Ropkins
</p>


<h3>References</h3>

<p>These function makes extensive use of code developed by others.  
</p>
<p>lattice:
Sarkar, Deepayan (2008) Lattice: Multivariate Data
Visualization with R. Springer, New York. ISBN
978-0-387-75968-5
</p>
<p>RColorBrewer:
Erich Neuwirth &lt;erich.neuwirth@univie.ac.at&gt; (2011). RColorBrewer:
ColorBrewer palettes. R package version 1.0-5.
http://CRAN.R-project.org/package=RColorBrewer
</p>


<h3>See Also</h3>

<p>In other packages: See <code><a href="lattice.html#topic+xyplot">xyplot</a></code> in <code><a href="lattice.html#topic+lattice">lattice</a></code>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#some trivial data
a &lt;- 1:10


##  Example 1
##  Simple plot with cex handling

myplot1 &lt;- function(x, y, z = NULL, cex = NULL, 
                    cex.range = NULL, ...){

    #set cex
    cex &lt;- cexHandler(z, cex, cex.range)

    #plot (xyplot in lattice)
    lattice::xyplot(y~x, cex = cex,...)
}

myplot1(a, a, a)

#  compare
## Not run:  
  myplot1(a, a)             #like plot(x, y)    
  myplot1(a, a, a*100)      #as myplot1(a, a, a)
                            #because cex scaled by range
  myplot1(a, b, c, 
      cex.range = c(1,5))   #cex range reset
  myplot1(a, b, c, 
      cex.range = c(10,50), 
      cex = 1)              #cex supersedes all else if supplied
## End(Not run)


## Example2
## plot function using lists/listUpdates

myplot2 &lt;- function(x, y, z = NULL, ...){

    #my default plot
    default.args &lt;- list(x = y~x, z = z, 
                         pch = 20, cex = 4)

    #update with whatever user supplied
    plot.args &lt;- listUpdate(default.args, list(...))

    #col Management
    plot.args$col &lt;- do.call(colHandler, plot.args)
    do.call(lattice::xyplot, plot.args)
}


#with colorkey based on z case
myplot2(a, a, a) 

#  compare 
## Not run: 
   myplot2(a, b, c, 
       col.regions = "Blues") #col.regions recoloring  
   myplot2(a, b, c, 
       col = "red")           ##but (again) col supersedes if supplied
## End(Not run)

#  Note:
#  See also example in ?listUpdate

</code></pre>

<hr>
<h2 id='4.6.key.handlers'>
Key handling
</h2><span id='topic+4.6.key.handlers'></span><span id='topic+keyHandler'></span><span id='topic+draw.loaPlotZKey'></span><span id='topic+draw.loaKey02'></span><span id='topic+draw.loaColorKey'></span><span id='topic+draw.loaColorRegionsKey'></span><span id='topic+draw.zcasePlotKey'></span><span id='topic+draw.ycasePlotKey'></span><span id='topic+draw.groupPlotKey'></span><span id='topic+draw.key.log10'></span>

<h3>Description</h3>

<p>Workhorse functions for routine use of keys in plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
keyHandler(key = NULL, ..., output = "key")

#keys

draw.loaPlotZKey(key = NULL, draw = FALSE, vp = NULL, ...)

draw.loaKey02(key = NULL, draw = FALSE, vp = NULL, ...)

draw.loaColorKey(key = NULL, draw = FALSE, vp = NULL, ...)

draw.loaColorRegionsKey(key = NULL, draw = FALSE, vp = NULL, ...)

draw.zcasePlotKey(key = NULL, draw = FALSE, vp = NULL, ...)

draw.ycasePlotKey(key = NULL, draw = FALSE, vp = NULL, ...)

draw.groupPlotKey(key = NULL, draw = FALSE, vp = NULL, ...) 

draw.key.log10(key = NULL, draw = FALSE, vp = NULL, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="4.6.key.handlers_+3A_key">key</code></td>
<td>
<p> The key to be used.
</p>
</td></tr> 
<tr><td><code id="4.6.key.handlers_+3A_...">...</code></td>
<td>
<p> Any additional arguments to be used to modify the 
the <code>key</code> before plotting.
</p>
</td></tr> 
<tr><td><code id="4.6.key.handlers_+3A_output">output</code></td>
<td>
<p> The format to return the function output in. This is 
<code>'key'</code> for all routine (in plot) use.  
</p>
</td></tr> 
<tr><td><code id="4.6.key.handlers_+3A_draw">draw</code>, <code id="4.6.key.handlers_+3A_vp">vp</code></td>
<td>
 <p><code>lattice</code> and <code>grid</code> arguments using when 
plotting <code>GROB</code> objects. Generally, these can be ignored.  
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>keyHandler</code> is a general function that rotuine generates 
defaults arguments for add a key to a plot.  
</p>
<p><code>draw...key</code> functions are all specialist plots keys. They are 
typically modifications of or variations on similar functions in 
<code>lattice</code>, e.g. <code>draw.key</code> and <code>draw.colorkey</code>.
</p>
<p><code>draw.loaPlotZKey</code> is the default 'bubble plot' key used with 
<code><a href="#topic+loaPlot">loaPlot</a></code>.
</p>
<p><code>draw.loaColorKey</code> and <code>draw.loaColorRegionsKey</code> are variations 
on the <code>draw.colorkey</code> function in <code><a href="lattice.html#topic+lattice">lattice</a></code>.
</p>
<p><code>draw.zcasePlotKey</code>, <code>draw.ycasePlotKey</code> and <code>draw.groupPlotKey</code> 
are simple legends based on <code>zcase</code>, <code>ycase</code> and <code>group</code> 
annotation.
</p>
<p><code>draw.key.log10</code> is a simple legend for use with log to the base 
10 transformed <code>z</code> scale.
</p>


<h3>Value</h3>

<p><code>keyHandler</code> return a list of plot arguments to be used to generate 
a key .
</p>
<p>When run within plot calls, the <code>draw...key</code> functions associated 
color keys. If they are used with <code>loa</code> plots and suitable 
<code>panel...</code> functions, color scales are automatically aligned. 
</p>


<h3>Note</h3>

<p>In Development: Function structures may change in future 
package updates.
</p>


<h3>Author(s)</h3>

<p>Karl Ropkins
</p>


<h3>References</h3>

<p>These functions make extensive use of code developed by others.  
</p>
<p>lattice:
Sarkar, Deepayan (2008) Lattice: Multivariate Data
Visualization with R. Springer, New York. ISBN
978-0-387-75968-5
</p>


<h3>See Also</h3>

<p>In other packages: See <code><a href="lattice.html#topic+xyplot">xyplot</a></code> in <code><a href="lattice.html#topic+lattice">lattice</a></code>. 
</p>

<hr>
<h2 id='4.7.other.panel.functions'>
Other panel functions argument handlers
</h2><span id='topic+4.7.other.panel.functions'></span><span id='topic+getArgs'></span><span id='topic+getPlotArgs'></span><span id='topic+isGood4LOA'></span><span id='topic+parHandler'></span>

<h3>Description</h3>

<p>In development panel functions for use with lattice
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
parHandler(scheme = NULL, ...)


#related

getArgs(source = TRUE, local.resets = TRUE, 
         user.resets = TRUE, is.scales.lines = FALSE, 
         elements = NULL, ..., defaults = list(), 
         defaults.only = FALSE)

getPlotArgs(defaults.as = "axis.line", source = TRUE, 
         local.resets = TRUE, user.resets = TRUE, 
         elements = NULL, ..., is.scales.lines = NULL, 
         defaults.only = TRUE)

isGood4LOA(arg)





</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="4.7.other.panel.functions_+3A_scheme">scheme</code></td>
<td>
<p> The color scheme to apply. This can be a list of parameters to apply 
or a character vector for a pre-defined scheme. Current pre-defined schemes include 
<code>'greyscale'</code> (for black and white figures).
</p>
</td></tr> 
<tr><td><code id="4.7.other.panel.functions_+3A_source">source</code>, <code id="4.7.other.panel.functions_+3A_local.resets">local.resets</code>, <code id="4.7.other.panel.functions_+3A_user.resets">user.resets</code></td>
<td>
<p> When recovering plot arguments 
with <code>getArgs</code> or <code>getPlotArgs</code>, places to search for relevant 
parameters. If supplied these would typically be vectors or lists. If vectors, 
they are assumed to be <code>col</code> setting. If lists, they are assumed to be lists 
of named parameters for inclusion. There are two cases that need to be handed 
specially: (1) some <code>sources</code>, <code>local.resets</code> and/or <code>user.resets</code> 
may contain both axis-specific and general information, e.g. For a <code>scales</code> list, 
parameters to be applied just to the x axis in <code>scales$x</code> and parameters to be 
applied to all scales in <code>scales</code>. In such cases these need to be checked in 
order (see <code>elements</code> below.) (2) Some sources, e.g. axis <code>scales</code>, contain 
both text and line parameters, with e.g. line settings declared as <code>col.line</code>, 
etc., rather than <code>col</code>, etc., (which are intended for use with text.) When 
supplied these need to be handled correctly (see <code>is.scales.lines</code> below). 
<code>local.resets</code> and <code>user.resets</code> are intended as overrides for the code 
developer and user, respectively. These can be logicals as well as vectors or lists. 
If logicals they turn on/off the associated plot components (using <code>isGood4LOA</code>). 
The check/update order is <code>source</code>, then <code>source$element</code>, then 
<code>local.reset</code>, then <code>local.reset$element</code>, then <code>user.reset</code>, then 
<code>user.reset$element</code>. This means that the developer always has last say regarding 
the default appearance of a plot component and the user always has the very last say 
from the command line if the local.reset is included as a formal argument in that plot.
</p>
</td></tr>
<tr><td><code id="4.7.other.panel.functions_+3A_is.scales.lines">is.scales.lines</code></td>
<td>
<p> When recovering arguments with <code>getArgs</code> or <code>getPlotArgs</code>, 
should <code>source</code> be treated as a lattice <code>scales</code> list? If so, and <code>source</code> 
is checked for line parameters, line-specific terms such as <code>col.line</code>, etc., will be 
recovered as <code>col</code>, etc., while general terms (meant for text in <code>scales</code> lists) 
will be ignored. (Note: <code>getPlotArgs</code> guesses this based on <code>defaults.as</code> if 
not supplied.)
</p>
</td></tr> 
<tr><td><code id="4.7.other.panel.functions_+3A_elements">elements</code></td>
<td>
<p> When recovering arguments with <code>getArgs</code> or <code>getPlotArgs</code>, this 
identifies the elements in <code>source</code>, <code>local.resets</code> and <code>user.resets</code> that 
may contain case-specific information. As with <code>lattice</code> handling of <code>scales</code> 
axis-specific information in <code>source$element(s)</code> is assumed to take priority over 
general information in <code>source</code>. (Note: if <code>elements</code> are not declared only 
general/top level information in <code>source</code>, <code>local.resets</code> and <code>user.resets</code> 
is considered at present.) 
</p>
</td></tr> 
<tr><td><code id="4.7.other.panel.functions_+3A_...">...</code></td>
<td>
<p> Other arguments, often ignored.
</p>
</td></tr> 
<tr><td><code id="4.7.other.panel.functions_+3A_defaults">defaults</code>, <code id="4.7.other.panel.functions_+3A_defaults.only">defaults.only</code>, <code id="4.7.other.panel.functions_+3A_defaults.as">defaults.as</code></td>
<td>
<p> When recovering arguments with <code>getArgs</code>, 
<code>defaults</code> is an optional 'fall-back' in case nothing is recovered from <code>source</code>, 
<code>local.resets</code> and <code>user.resets</code>. <code>defaults.only</code> is a logical: if <code>TRUE</code> 
only parameters named in <code>defaults</code> are searched for, otherwise all parameters are 
recovered. With <code>getPlotArgs</code>, <code>defaults.as</code> selects an appropriate default. This 
should be a trellis parameter name, e.g. <code>'axis.line'</code>, <code>'axis.text'</code>, etc. The 
function uses this to identify appropriate plot parameters to search for/select, e.g. 
<code>pch</code>, <code>col</code>, <code>cex</code>, etc for <code>'plot.symbol'</code>, and to identify default 
values for each of these (if <code>defaults.only = TRUE</code>).
</p>
</td></tr>
<tr><td><code id="4.7.other.panel.functions_+3A_arg">arg</code></td>
<td>
<p> For <code>isGood4LOA</code> a plot argument that can used 
to turn a plot panel or panel component on or off. 
</p>
</td></tr>  
</table>


<h3>Details</h3>

<p><code>getArgs</code> returns a list of parameters/values based on 
<code>lattice</code>, developer and user settings. If multiple 
elements are identified as containing case-specific information, 
the list will contain one list of plot parameters for each named 
element. 
</p>
<p><code>getPlotArgs</code> is a variation of <code>getArgs</code> 
intended for use with <code>panel...</code> and <code>l...</code> type 
<code>lattice</code> functions. It returns a list of plot parameters 
for different plot components, e.g. symbols, lines, or text. 
</p>
<p><code>isGood4LOA</code> is a simple workhorse that checks if a 
supplied <code>arg</code> should be used by <code>loa</code>. (See value and 
note below.)
</p>
<p><code>parHandler</code> manages the default appearance of plots.  
</p>


<h3>Value</h3>

<p><code>getArgs</code> and <code>getPlotArgs</code> return lists of located 
parameters/values. For example, the call
</p>
<p><code>getPlotArgs(default.as = "axis.line")</code> 
</p>
<p>returns a list containing the <code>lattice</code> defaults for an axis 
line (<code>alpha</code>, <code>col</code>, <code>lty</code> and <code>lwd</code>) These 
can then be used in combination with appropriate <code>x</code> and 
<code>y</code> values in <code>llines</code>, or <code>panel.lines</code> calls. 
The arguments <code>local.resets</code> and <code>user.resets</code> can 
be added into the call to provide developer and user overrides. 
(See note below.)
</p>
<p><code>isGood4LOA</code> returns a logical (<code>TRUE</code> or <code>FALSE</code>), 
depending on the type of a supplied argument. This returns 
<code>FALSE</code> for <code>NULL</code>, for all <code>FALSE</code> logicals, and 
any arg that has previously been tagged as 'not wanted'.
</p>
<p><code>parHandler</code> returns a list a list suitable for use as 
<code>par.settings</code> with most <code><a href="lattice.html#topic+lattice">lattice</a></code> plots. 
</p>


<h3>Note</h3>

<p><code>getPlotArgs</code> is intended as a 'workhorse' for plot developers, 
to recover <code>lattice</code> settings, impose their own preferences on 
these, and in turn to provide users with similar options to quickly 
override developer settings.    
</p>
<p><code>isGood4LOA</code> only exists because I, perhaps wrongly, 
equate <code>arg = NULL</code> with <code>arg = FALSE</code> when that 
argument is a component of a plot defined in the plot formals. 
For example, in <code><a href="#topic+trianglePlot">trianglePlot</a></code> I want 
<code>grids = NULL</code> to turn off the plot grids much like 
<code>grids = FALSE</code>, but got fed up always writing the same 
everywhere. Does not mean it is right, particularly useful or 
even clever...
</p>
<p>The <code>getPlotArgs</code>/<code>isGood4LOA</code> combination is a first attempt 
at providing plot developers with a simple tool to integrate plot argument 
management by lattice, the plot developer and the plot user. It is intended 
to be applied in the form shown in the Examples below. 
</p>
<p>Axis, tick, grid and annotation handling in <code><a href="#topic+trianglePlot">trianglePlot</a></code> is 
intended to illustrate this type of application.  
</p>


<h3>Author(s)</h3>

<p>Karl Ropkins
</p>


<h3>References</h3>

<p>These function makes extensive use of code developed by others.  
</p>
<p>lattice:
Sarkar, Deepayan (2008) Lattice: Multivariate Data
Visualization with R. Springer, New York. ISBN
978-0-387-75968-5
</p>


<h3>See Also</h3>

<p>In other packages: See <code><a href="lattice.html#topic+xyplot">xyplot</a></code> in <code><a href="lattice.html#topic+lattice">lattice</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#getPlotArgs/isGood4LOA notes

#in formals
#my.plot &lt;- function(..., user.reset = TRUE, ...) 

#in main code body
#local.resets &lt;- [what developer wants] 
#plot.arg &lt;- getPlotArgs("[type]", source, local.reset, user.reset)

#in panel call
#(for panel off/on control)
#if(isGood4LOA(plot.arg)) panel...(..., plot.arg,...)

#in panel... function
#for panel component off/on control)
#if(isGood4LOA(plot.arg1)) panel...(..., plot.arg1,...)
#if(isGood4LOA(plot.arg2)) l...(..., plot.arg2,...)
#etc.

</code></pre>

<hr>
<h2 id='4.8.list.handlers'>
List manipulation
</h2><span id='topic+4.8.list.handlers'></span><span id='topic+listHandler'></span><span id='topic+listUpdate'></span><span id='topic+listExpand'></span><span id='topic+listLoad'></span>

<h3>Description</h3>

<p>Workhorse functions for routine list handling in loa and elsewhere.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
listHandler(a, use = NULL, ignore = NULL, 
            drop.dots=TRUE)

listUpdate(a, b, use = NULL, ignore = NULL,
            use.a = use, use.b = use,
            ignore.a = ignore, ignore.b = ignore, 
            drop.dots = TRUE)

listExpand(a, ref = NULL, use = NULL, 
            ignore = NULL, drop.dots = TRUE)

listLoad(..., load = NULL)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="4.8.list.handlers_+3A_a">a</code></td>
<td>
<p> A required list. The list to be modified.
</p>
</td></tr> 
<tr><td><code id="4.8.list.handlers_+3A_b">b</code></td>
<td>
<p> For <code>listUpdate</code> only, a required second list, the contents of 
which are used to update <code>a</code> with.
</p>
</td></tr> 
<tr><td><code id="4.8.list.handlers_+3A_use">use</code>, <code id="4.8.list.handlers_+3A_use.a">use.a</code>, <code id="4.8.list.handlers_+3A_use.b">use.b</code></td>
<td>
<p> Vectors, all defaults <code>NULL</code>. If supplied, 
a vector of the names of list enteries to be used. Other enteries are 
then discarded. <code>use</code> is applied to all supplied lists, while 
<code>use.a</code>, <code>use.b</code>, etc. can be used to subset <code>a</code> and 
<code>b</code> lists individually.  
</p>
</td></tr> 
<tr><td><code id="4.8.list.handlers_+3A_ignore">ignore</code>, <code id="4.8.list.handlers_+3A_ignore.a">ignore.a</code>, <code id="4.8.list.handlers_+3A_ignore.b">ignore.b</code></td>
<td>
<p> Vectors, default <code>NULL</code>. As with 
<code>use</code>, etc, but for enteries to be ignored/not passed on for 
modification.  
</p>
</td></tr> 
<tr><td><code id="4.8.list.handlers_+3A_ref">ref</code></td>
<td>
<p>For <code>listExpand</code> only, a vector, default <code>NULL</code>. A reference 
data series, the length of which is used as the expansion length to be 
applied when wrapping of list enteries.  
</p>
</td></tr> 
<tr><td><code id="4.8.list.handlers_+3A_drop.dots">drop.dots</code></td>
<td>
<p> Logical, default <code>TRUE</code>. If <code>TRUE</code>, this 
removes <code>"..."</code> entries from list names before updating. 
</p>
</td></tr> 
<tr><td><code id="4.8.list.handlers_+3A_...">...</code></td>
<td>
<p> For <code>listLoad</code> only, any additional arguments.  
</p>
</td></tr> 
<tr><td><code id="4.8.list.handlers_+3A_load">load</code></td>
<td>
<p> For <code>listLoad</code> only, a character vector, default <code>NULL</code>. The 
names of any lists to be automatically generated from the additional arguments 
supplied as part of the command call.  
</p>
</td></tr> 
</table>


<h3>Details</h3>

<p><code>listHandler</code> is a general function used by other <code>list...</code> 
functions for routine list preprocessing.
</p>
<p><code>listUpdate</code> is a list handler intended for use when managing 
user updates for default options (see examples).
</p>
<p><code>listExpand</code> is a list handler that expands vectors to 
a given reference length, intended for use for data wrapping. 
</p>
<p><code>listLoad</code> is a list generator. See Note below.
</p>


<h3>Value</h3>

<p>By default, all <code>list...</code> functions return results as lists.
</p>
<p><code>listHandler</code>, <code>listUpdate</code> and <code>listExpand</code> functions 
all return a modified (or updated) version of supplied list <code>a</code>. 
</p>
<p><code>listLoad</code> (in-development) returns modified (or updated) version 
of additional arguments as a list. See Note below.
</p>


<h3>Note</h3>

<p><code>listLoad</code> is an in-development workhorse function 
that generates lists based on the supplied <code>load</code> argument. 
</p>
<p>It assumes each element of <code>load</code> is the name of an expected list 
and searches the associated additional arguments for arguments to 
populate it with using the rule '<code>[load].[arg]</code> is an element of list 
<code>[load]</code>'. So, for example, for a call including the arguments 
<code>load = 'key'</code> and <code>key.fun = draw.colorkey</code>, it would strip out 
both arguments and return <code>key = list(fun=draw.colorkey)</code>. Used in 
functions, it allowed list-in-list args that can be commonplace 
when modifying, for example, key elements of conventional <code>lattice</code> 
plots to be simplified. 
</p>


<h3>Author(s)</h3>

<p>Karl Ropkins
</p>


<h3>References</h3>

<p>These functions make extensive use of code developed by others.  
</p>
<p>lattice:
Sarkar, Deepayan (2008) Lattice: Multivariate Data
Visualization with R. Springer, New York. ISBN
978-0-387-75968-5
</p>


<h3>See Also</h3>

<p><code><a href="lattice.html#topic+lattice">lattice</a></code>, <code><a href="lattice.html#topic+xyplot">xyplot</a></code>, 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Example 1
## general

#  two lists
list1 &lt;- list(a = 1:10, b = FALSE)
list2 &lt;- list(b = TRUE, c = "new")

#  updating a with b
#  keeps unchanged list1 entry, a
#  updates changed list1 entry, b
#  adds new (list2) entry, c
listUpdate(list1, list2)


## Example2
## use in plot functions
## to simplify formals

## Not run: 
#  some data
a &lt;- 1:10
b &lt;- rnorm(10,5,2)

#a bad plot function

badplot &lt;- function(x, ...){

    #setting defaults in xyplot call itself
    xyplot(x = x, pch = 20, col = "red",
                   panel = function(...){
                           panel.grid(-1, -1)
                           panel.xyplot(...)
                           panel.abline(0,1)
                   }, ...)
}

  badplot(a~b)                 #OK

#  compare with 
  badplot(a~b, xlim = c(1,20)) #OK
  badplot(a~b, col = "blue")   #not OK

#  because col hardcoded into badplot function
#  It is duplicated in call and '...'
#  so user cannot update col 


#a standard correction

stdplot &lt;- function(x, pch = 20, col = "red", ...){

    #setting defaults in xyplot call itself
    xyplot(x = x, pch = 20, col = "red",
                   panel = function(x=x, pch=pch, col=col, ...){
                           panel.grid(-1, -1)
                           panel.xyplot(x=x, pch=pch, col=col, ...)
                           panel.abline(0,1)
                   }, ...)
}

  stdplot(a~b)                  #OK
  stdplot(a~b, col = "blue", 
          xlim=c(1:20))         #also OK
 

#  An alternative correction using lists and 
#  listUpdate that removes the need for formal 
#  definition of all modified plot arguments 

myplot &lt;- function(x, ...){

    #defaults I set for myplot form of xyplot
    mylist &lt;- list(x = x, pch = 20, col = "red",
                   panel = function(...){
                           panel.grid(-1, -1)
                           panel.xyplot(...)
                           panel.abline(0,1)
                   })
    #plot
    do.call(xyplot, listUpdate(mylist, list(...)))
}


  myplot(a~b)                 #OK
  myplot(a~b, col = "blue", 
         xlim = c(1,20))      #also OK

## End(Not run)

</code></pre>

<hr>
<h2 id='4.9.loa.shapes'>
loa shapes
</h2><span id='topic+4.9.loa.shapes'></span><span id='topic+loa.shapes'></span><span id='topic+loa.glyphs'></span><span id='topic+loaPolygon'></span><span id='topic+loaCircle'></span><span id='topic+loaPieSegment'></span>

<h3>Description</h3>

<p>Simple shapes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
loaPolygon(x, y, z=NULL, rot=NULL, ..., 
            polygon = NULL, loa.scale = NULL)

loaCircle(..., polygon = NULL, radius = 1)

loaPieSegment(..., polygon = NULL, start = 0, 
            angle=360, radius = 1, center=TRUE)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="4.9.loa.shapes_+3A_x">x</code>, <code id="4.9.loa.shapes_+3A_y">y</code></td>
<td>
<p> The <code>x</code> and <code>y</code> points at which to plot the 
requested shape.
</p>
</td></tr> 
<tr><td><code id="4.9.loa.shapes_+3A_z">z</code></td>
<td>
<p> If supplied a <code>z</code> term, most often used to set 
the size of the polygon.
</p>
</td></tr>
<tr><td><code id="4.9.loa.shapes_+3A_rot">rot</code></td>
<td>
<p> The angle to rotate the polygon by before drawing it.
</p>
</td></tr>  
<tr><td><code id="4.9.loa.shapes_+3A_...">...</code></td>
<td>
<p> Any additional arguments, usually passed on.
</p>
</td></tr> 
<tr><td><code id="4.9.loa.shapes_+3A_polygon">polygon</code></td>
<td>
<p> A list with elements <code>x</code> and <code>y</code> giving the 
polygon/shape to be plotted.
</p>
</td></tr> 
<tr><td><code id="4.9.loa.shapes_+3A_loa.scale">loa.scale</code></td>
<td>
<p> A list of parameters that can be used to fine-tune the 
<code>polygon</code> plotting.  
</p>
</td></tr> 
<tr><td><code id="4.9.loa.shapes_+3A_radius">radius</code></td>
<td>
<p> The radius to used when drawing either circles or pie segments.
</p>
</td></tr>
<tr><td><code id="4.9.loa.shapes_+3A_start">start</code>, <code id="4.9.loa.shapes_+3A_angle">angle</code></td>
<td>
<p> When drawing pie segments, <code>angle</code> the angle of 
of the segment and <code>start</code> point.
</p>
</td></tr>
<tr><td><code id="4.9.loa.shapes_+3A_center">center</code></td>
<td>
<p> Should the segement begin and end at the center?  
</p>
</td></tr> 
</table>


<h3>Details</h3>

<p><code>loaPolygon</code> is a general function for drawing polygons. It is 
intended as an alternative to <code>lpolygon</code>, and other standard 
<code>loa...</code> shapes are typically wrappers for this function.
</p>
<p><code>loaCircle</code> draws a circle with an origin at (<code>x</code>, <code>y</code>).
</p>
<p><code>loaPieSegment</code> draws a pie segment (or slice of cake) shape. It 
is typically used as building block for pie plots and other similar 
glyph structures.
</p>


<h3>Value</h3>

<p>All these functions generate simple shapes and are intended to be run 
within <code>panel...</code> functions as building blocks for more complex 
glyph type structures.
</p>


<h3>Author(s)</h3>

<p>Karl Ropkins
</p>


<h3>References</h3>

<p>These functions make extensive use of code developed by others.  
</p>
<p>lattice:
Sarkar, Deepayan (2008) Lattice: Multivariate Data
Visualization with R. Springer, New York. ISBN
978-0-387-75968-5
</p>


<h3>See Also</h3>

<p>In other packages: See <code><a href="lattice.html#topic+lrect">lrect</a></code>, and similar, in <code><a href="lattice.html#topic+lattice">lattice</a></code> 
</p>

<hr>
<h2 id='5.1.plot.interactives'>
Interactive plot functions
</h2><span id='topic+5.1.plot.interactives'></span><span id='topic+getXY'></span><span id='topic+getLatLon'></span><span id='topic+screenLatticePlot'></span>

<h3>Description</h3>

<p>Recovering information from existing lattice plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
getXY(n = -1, ..., unit = "native", scale.correction = NULL)

getLatLon(...,   
          scale.correction = function(x) {
                                temp &lt;- MercatorXY2LatLon(x$x, x$y)
                                as.list(as.data.frame(temp))
                            })

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="5.1.plot.interactives_+3A_n">n</code></td>
<td>
<p> If positive, the maximum number of points to locate. If negative 
(default), unlimited. 
</p>
</td></tr> 
<tr><td><code id="5.1.plot.interactives_+3A_unit">unit</code></td>
<td>
<p> The unit to use when reporting located points, by 
default <code>"native"</code>.
</p>
</td></tr> 
<tr><td><code id="5.1.plot.interactives_+3A_scale.correction">scale.correction</code></td>
<td>
<p> The correction to apply if the plot has 
locally scaled axes. See Note below.  
</p>
</td></tr> 
<tr><td><code id="5.1.plot.interactives_+3A_...">...</code></td>
<td>
<p> Additional arguments, passed on to related functions.
</p>
<p>These may be subject to revision, but are currently: 
<code><a href="lattice.html#topic+trellis.focus">trellis.focus</a></code> for panel selection (if working with multi-panel 
plots) and <code><a href="lattice.html#topic+lpoints">lpoints</a></code> to set point properties (if marking selected 
points). For <code>getLatLon</code>, additional arguments are also passed to 
<code><a href="RgoogleMaps.html#topic+XY2LatLon">XY2LatLon</a></code> for x, y to latitude, longitude rescaling.
</p>
</td></tr> 
</table>


<h3>Details</h3>

<p><code>getXY</code> is an interactive function which returns 
the locations of points on a plot selected using the 
mouse (left click to select points; right click and 
stop to end point collection; escape to abort without 
returning any values). 
</p>
<p>It is a wrapper for the <code>grid</code> function 
<code><a href="grid.html#topic+grid.locator">grid.locator</a></code> that behaves more like 
<code><a href="graphics.html#topic+locator">locator</a></code>, the equivalent function intended 
for use with <code><a href="base.html#topic+plot">plot</a></code> outputs. 
</p>
<p>By default <code>getXY</code> selections are not automatically 
marked. Adding common plot parameters to the function 
call overrides this behaviour, e.g. to add red symbols 
and lines.  
</p>
<p><code>ans &lt;- getXY(col = "red", pch = 4, type = "b")</code> 
</p>
<p><code>getXY</code> also provides a mechanism to handle data plotted on 
locally scaled axes. See Note below.
</p>
<p><code>getLatLon</code> is wrapper for <code>getXY</code> for use 
with <code>loaMapPlot</code> and other similarly 
georeferenced plots. See Note below.
</p>


<h3>Value</h3>

<p><code>getXY</code> returns the x and y coordinates of 
the selected points on a plot as a list containing two 
components, <code>x</code> and <code>y</code>.
</p>
<p><code>getLatLon</code> returns the latitude and longitude 
values of the selected points on a map as a list 
containing two components, <code>lat</code> and <code>lon</code>.
</p>


<h3>Note</h3>

<p><code>getXY</code> recovers the (x, y) coordinates of points selected 
on a previously generated plot.
</p>
<p>Some plots, use local scaling. For example, when plotting 
latitude, longitude data on a map a scale correction may be 
used to account for the curvature of the Earth. Similarly, if 
different data series are plotted on primary and secondary axes 
in a single plot, some or all data may be normalised. In such 
cases scaling may be local, i.e. what you actually plot may not be 
exactly what the annotation says it is. 
</p>
<p>Using <code>getXY</code> on such plots would recover the actual (x, y) 
coordinates of the points selected.      
</p>
<p>However, corrections can be applied using <code>scale.correction</code>, 
if it is supplied, to convert these to the same scale as the axes 
annotation. The correction should be a function that can be 
applied directly to a standard <code>getXY</code> output (a list of 
<code>x</code> and <code>y</code> values) and rescale x and y to give 
their 'corrected' values.
</p>
<p><code>getLatLon</code> provides an example of the mechanism, and is 
for use with georeferenced plots that have been locally scaled 
using <code><a href="#topic+LatLon2MercatorXY">LatLon2MercatorXY</a></code>. <code>getLatLon</code> uses 
<code><a href="#topic+MercatorXY2LatLon">MercatorXY2LatLon</a></code> to rescale <code>x</code> and <code>y</code> 
values and then <code>as...</code> functions to convert the outputs of 
this step to a list format like that generated by <code>locator</code>, 
<code>grid.locator</code> or <code>getXY</code>.    
</p>


<h3>Author(s)</h3>

<p>Karl Ropkins
</p>


<h3>References</h3>

<p>This function makes extensive use of code developed by others.
</p>
<p>lattice:
Sarkar, Deepayan (2008) Lattice: Multivariate Data
Visualization with R. Springer, New York. ISBN
978-0-387-75968-5
</p>
<p>RgoogleMaps:
Markus Loecher and Sense Networks (2011).
RgoogleMaps: Overlays on Google map tiles in R. R
package version 1.1.9.6.
http://CRAN.R-project.org/package=RgoogleMaps
</p>


<h3>See Also</h3>

<p>In other packages: See <code><a href="grid.html#topic+grid.locator">grid.locator</a></code>; 
<code><a href="lattice.html#topic+trellis.focus">trellis.focus</a></code> and <code><a href="lattice.html#topic+lpoints">lpoints</a></code> in <code><a href="lattice.html#topic+lattice">lattice</a></code>.    
</p>

<hr>
<h2 id='5.2.plot.add.functions'>
General plot add... functions
</h2><span id='topic+5.2.plot.add.functions'></span><span id='topic+add.functions'></span><span id='topic+add.XYZGhosts'></span><span id='topic+add.Y2Axis'></span><span id='topic+add.XYPolygon'></span><span id='topic+add.LonLatMap'></span>

<h3>Description</h3>

<p>General functions for adding extra layers to existing 
plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
add.XYZGhosts(object = NULL, 
              ..., unit = "native", 
              ghost.panel = panel.loaPlot) 

add.Y2Axis(object = NULL, 
              ..., unit = "native", 
              rescale = NULL) 

add.XYPolygon(object = NULL,
              x = NULL, y = NULL, data = NULL,
              ..., unit = "native",
              y2.scale=FALSE, first=FALSE)

add.LonLatMap(object = NULL,
              ..., map = NULL, recolor.map=FALSE,
              show.axes = FALSE, unit = "native",
              first = TRUE)
                        
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="5.2.plot.add.functions_+3A_object">object</code></td>
<td>
<p> The plot to add an extra plot layer or 
layers to. This defaults to last lattice plot produced 
if not set in call. 
</p>
</td></tr> 
<tr><td><code id="5.2.plot.add.functions_+3A_...">...</code></td>
<td>
<p> Additional arguments, passed on to related 
functions.
</p>
</td></tr> 
<tr><td><code id="5.2.plot.add.functions_+3A_unit">unit</code></td>
<td>
<p> The plot units, by default native.
</p>
</td></tr> 
<tr><td><code id="5.2.plot.add.functions_+3A_ghost.panel">ghost.panel</code></td>
<td>
<p> The plot panel to use when adding 
ghost points (lines, etc). 
</p>
</td></tr>
<tr><td><code id="5.2.plot.add.functions_+3A_rescale">rescale</code></td>
<td>
<p> For <code>add.Y2Axis</code>, y data-series 
rescaling, by default NULL/none.  
</p>
</td></tr> 
<tr><td><code id="5.2.plot.add.functions_+3A_x">x</code>, <code id="5.2.plot.add.functions_+3A_y">y</code></td>
<td>
<p> x and y data-series to be used.  
</p>
</td></tr> 
<tr><td><code id="5.2.plot.add.functions_+3A_data">data</code></td>
<td>
<p> If supplied, the expected source of x 
and y data-series.  
</p>
</td></tr> 
<tr><td><code id="5.2.plot.add.functions_+3A_y2.scale">y2.scale</code></td>
<td>
<p> When building the Plot, use the second 
y axis if that exists, default FALSE.  
</p>
</td></tr>
<tr><td><code id="5.2.plot.add.functions_+3A_first">first</code></td>
<td>
<p> When building the plot add the new plot 
layer first, default varies. 
</p>
</td></tr>
<tr><td><code id="5.2.plot.add.functions_+3A_map">map</code>, <code id="5.2.plot.add.functions_+3A_recolor.map">recolor.map</code>, <code id="5.2.plot.add.functions_+3A_show.axes">show.axes</code></td>
<td>
<p> Options when adding 
a map layer, see loaMapPlot documentations.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>add.loaGhosts</code> adds ghost points showing the 
locations of all points in all panels.
</p>
<p><code>add.Y2Axis</code> adds a second y axis. 
</p>
<p><code>add.XYPolygon</code> adds a supplied (x,y) polygon.
</p>
<p><code>add.LonLatMap</code> adds a map layer.
</p>


<h3>Value</h3>

<p><code>add...</code> functions returns the supplied (or last) 
lattice plot with an additional plot layer added.
</p>


<h3>Note</h3>

<p><code>add.XYZGhosts</code> and <code>add.LonLatMap</code> are 
in-development and may change significantly in 
future package versions.
</p>


<h3>Author(s)</h3>

<p>Karl Ropkins
</p>


<h3>References</h3>

<p>These functions make extensive use of code developed 
by others.
</p>
<p>lattice:
Sarkar, Deepayan (2008) Lattice: Multivariate Data
Visualization with R. Springer, New York. ISBN
978-0-387-75968-5
</p>
<p>Grid (part of base R):
R Core Team (2017). R: A language and environment 
for statistical computing. R Foundation for 
Statistical Computing, Vienna, Austria.
URL https://www.R-project.org/.
</p>

<hr>
<h2 id='5.3.plot.add.XYFit.functions'>
Plot add.XY...Fit functions
</h2><span id='topic+5.3.plot.add.XYFit.functions'></span><span id='topic+add.XYFit.functions'></span><span id='topic+add.XYLMFit'></span><span id='topic+add.XYLOESSFit'></span><span id='topic+add.XYFit_prep'></span><span id='topic+loaXYFit_lm'></span><span id='topic+loaXYFit_loess'></span><span id='topic+panel.loaXYFit'></span><span id='topic+add.loaPanel'></span>

<h3>Description</h3>

<p>Functions for adding XY fit model layers to existing plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
#main functions

add.loaPanel(lattice.plot = NULL, 
           preprocess = NULL, panel = NULL, 
           postprocess = NULL, ..., 
           use = NULL, ignore = NULL) 

add.XYLMFit(lattice.plot = NULL,
           preprocess = add.XYFit_prep,
           panel = panel.loaXYFit, ...)

add.XYLOESSFit(lattice.plot = NULL,
           preprocess = add.XYFit_prep, 
           model.method = loaXYFit_loess,
           panel = panel.loaXYFit, ...)

#others

add.XYFit_prep(lattice.plot = NULL,
           model.method = loaXYFit_lm, ...)

loaXYFit_lm(x, y, output.len = 25, formula.signif = 2, 
           r2.digits = 3, group.id = NULL, ...)

loaXYFit_loess(x, y, output.len = 25, r2.digits = 3, 
           group.id = NULL, ...)

panel.loaXYFit(...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="5.3.plot.add.XYFit.functions_+3A_lattice.plot">lattice.plot</code></td>
<td>
<p> The plot to add an extra layer or 
layers to. This defaults to last lattice plot produced 
if not set in call. 
</p>
</td></tr> 
<tr><td><code id="5.3.plot.add.XYFit.functions_+3A_preprocess">preprocess</code></td>
<td>
<p> If set, a function to apply to 
<code>lattice.plot</code> before adding new panel.
</p>
</td></tr> 
<tr><td><code id="5.3.plot.add.XYFit.functions_+3A_panel">panel</code></td>
<td>
<p> If set, a new <code>panel...</code> function to 
add to <code>lattice.plot</code> after the current 
<code>lattice.plot</code> panel. 
</p>
</td></tr> 
<tr><td><code id="5.3.plot.add.XYFit.functions_+3A_postprocess">postprocess</code></td>
<td>
<p> If set, a function to apply to 
<code>lattice.plot</code> after the new panel.
</p>
</td></tr> 
<tr><td><code id="5.3.plot.add.XYFit.functions_+3A_...">...</code></td>
<td>
<p> Additional arguments, passed on to 
daughter functions.
</p>
</td></tr> 
<tr><td><code id="5.3.plot.add.XYFit.functions_+3A_model.method">model.method</code></td>
<td>
<p> Function to use on XY data 
to generate fit reports.
</p>
</td></tr> 
<tr><td><code id="5.3.plot.add.XYFit.functions_+3A_use">use</code>, <code id="5.3.plot.add.XYFit.functions_+3A_ignore">ignore</code></td>
<td>
<p> if set, the names of arguments 
supplied to the previous plot that should be used 
or ignored, respectively, by panel being added.
</p>
</td></tr>
<tr><td><code id="5.3.plot.add.XYFit.functions_+3A_x">x</code>, <code id="5.3.plot.add.XYFit.functions_+3A_y">y</code></td>
<td>
<p> XY data from plot, typically filtered 
by both panel and group.
</p>
</td></tr>
<tr><td><code id="5.3.plot.add.XYFit.functions_+3A_output.len">output.len</code></td>
<td>
<p> Number of XY pairs to use when 
making fit line standard error bands.  
</p>
</td></tr>
<tr><td><code id="5.3.plot.add.XYFit.functions_+3A_formula.signif">formula.signif</code>, <code id="5.3.plot.add.XYFit.functions_+3A_r2.digits">r2.digits</code></td>
<td>
<p> When number of 
significant numbers and digits to use when reporting 
the fit formula and r.squared, respectively.
</p>
</td></tr>
<tr><td><code id="5.3.plot.add.XYFit.functions_+3A_group.id">group.id</code></td>
<td>
<p> When XY data is grouped, the group 
identity.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>add.loaPanel</code> adds a plot panel to an existing 
loaPlot output. 
</p>
<p><code>add.XYLMFit</code> and <code>add.XYLFit</code> add linear 
and loess model fit surfaces to exiting lattice plot.  
</p>
<p>Both functions are intended to be used in form:
</p>
<p>[make plot, e.g. loaPlot(...) then] addXYLMFit(...)
</p>
<p><code>loaXYFit_lm</code> and <code>loaXYFit_lm</code> generate fit and 
report information for linear and loess fit surfaces. 
</p>
<p>Other functions contain code structure common to all 
<code>addXYFit</code> functions.     
</p>


<h3>Value</h3>

<p><code>add.XYLMFit</code> returns the supply (or last) lattice plot 
with an added linear fit surface layer, generated using 
<code>lm()</code>.
</p>
<p><code>add.XYLMFit</code> returns the supply (or last) lattice plot 
with an added linear fit surface layer, generated using 
<code>loess()</code>.
</p>
<p>The elements of the XYFit layers are <code>fit</code> the fit line, 
<code>se</code> the standard error bands, and <code>report</code> the 
fit report panels. These track properties, e.g. <code>col</code>, etc, 
of the plot they add to unless these terms are reset in the 
addXYFit call. They can also be removed by setting to FALSE, 
e.g. <code>fit=FALSE</code>, or updated individually using e.g. 
<code>fit.col=2</code> to change just the fit line color to red.  
</p>
<p>The report position within the plot panel can be set using   
report.position which uses a relative (x=0-1, y=0-1) scale 
to position the report.
</p>


<h3>Note</h3>

<p>These functions are in-development aand may change 
significantly in future pacakge versions.
</p>


<h3>Author(s)</h3>

<p>Karl Ropkins
</p>


<h3>References</h3>

<p>This function makes extensive use of code developed by others.
</p>
<p>lattice:
Sarkar, Deepayan (2008) Lattice: Multivariate Data
Visualization with R. Springer, New York. ISBN
978-0-387-75968-5
</p>
<p>lm() and loess() in stats (part of base R):
R Core Team (2017). R: A language and environment for statistical
computing. R Foundation for Statistical Computing, Vienna, Austria.
URL https://www.R-project.org/.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# add lm fit a loaPlot
add.XYLMFit(loaPlot(cadmium~copper*zinc, data=lat.lon.meuse))

## Not run: 

loaPlot(cadmium~copper*zinc, data=lat.lon.meuse)
add.XYLOESSFit(col="red")

p &lt;- loaPlot(cadmium~copper*zinc, data=lat.lon.meuse)
add.XYLMFit(p, se.col="grey", report.position=c(0.95, 0.22))


## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
