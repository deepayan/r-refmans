<!DOCTYPE html><html><head><title>Help for package uGMAR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {uGMAR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_data'><p>Add data to object of class 'gsmar' defining a GMAR, StMAR, or G-StMAR model</p></a></li>
<li><a href='#add_dfs'><p>Add random dfs to a vector</p></a></li>
<li><a href='#all_pos_ints'><p>Check whether all arguments are strictly positive natural numbers</p></a></li>
<li><a href='#alt_gsmar'><p>Construct a GSMAR model based on results from an arbitrary estimation round of <code>fitGSMAR</code></p></a></li>
<li><a href='#calc_gradient'><p>Calculate gradient or Hessian matrix</p></a></li>
<li><a href='#change_parametrization'><p>Change parametrization of a parameter vector</p></a></li>
<li><a href='#change_regime'><p>Change the specified regime of parameter vector to the given regime-parameter vector</p></a></li>
<li><a href='#check_and_correct_data'><p>Check that the data is set correctly and correct if not</p></a></li>
<li><a href='#check_constraint_mat'><p>Check the constraint matrices</p></a></li>
<li><a href='#check_data'><p>Check that given object contains data</p></a></li>
<li><a href='#check_gsmar'><p>Check that given object has class attribute 'gsmar'</p></a></li>
<li><a href='#check_model'><p>Check that the argument 'model' is correctly specified.</p></a></li>
<li><a href='#check_params_length'><p>Check that the parameter vector has the correct dimension</p></a></li>
<li><a href='#check_pM'><p>Check that p and M are correctly set</p></a></li>
<li><a href='#cond_moment_plot'><p>Conditional mean or variance plot for GMAR, StMAR, and G-StMAR models</p></a></li>
<li><a href='#cond_moments'><p>Calculate conditional moments of GMAR, StMAR, or G-StMAR model</p></a></li>
<li><a href='#condmomentPlot'><p>DEPRECATED, USE <code>cond_moment_plot</code> INSTEAD! Conditional mean or variance plot for GMAR, StMAR, and G-StMAR models</p></a></li>
<li><a href='#condMoments'><p>DEPRECATED, USE <code>cond_moments</code> INSTEAD! Calculate conditional moments of GMAR, StMAR, or G-StMAR model</p></a></li>
<li><a href='#diagnostic_plot'><p>Quantile residual based diagnostic plots for GMAR, StMAR, and G-StMAR models</p></a></li>
<li><a href='#diagnosticPlot'><p>DEPRECATED, USE <code>diagnostic_plot</code> INSTEAD! Quantile residual based diagnostic plots for GMAR, StMAR, and G-StMAR models</p></a></li>
<li><a href='#extract_regime'><p>Extract regime from a parameter vector</p></a></li>
<li><a href='#fitGSMAR'><p>Estimate Gaussian or Student's t Mixture Autoregressive model</p></a></li>
<li><a href='#format_valuef'><p>Function factory for formatting values</p></a></li>
<li><a href='#GAfit'><p>Genetic algorithm for preliminary estimation of GMAR, StMAR, or G-StMAR model</p></a></li>
<li><a href='#get_alpha_mt'><p>Get mixing weights alpha_mt (this function is for internal use)</p></a></li>
<li><a href='#get_ar_roots'><p>Calculate absolute values of the roots of the AR characteristic polynomials</p></a></li>
<li><a href='#get_IC'><p>Calculate AIC, HQIC and BIC</p></a></li>
<li><a href='#get_minval'><p>Returns the default smallest allowed log-likelihood for given data.</p></a></li>
<li><a href='#get_regime_autocovs'><p>Calculate regime specific autocovariances <strong><code class="reqn">\gamma</code></strong><code class="reqn">_{m,p}</code></p></a></li>
<li><a href='#get_regime_means'><p>Calculate regime specific means <code class="reqn">\mu_{m}</code></p></a></li>
<li><a href='#get_regime_vars'><p>Calculate regime specific variances <code class="reqn">\gamma_{m,0}</code></p></a></li>
<li><a href='#get_test_Omega'><p>Generate the covariance matrix Omega for quantile residual tests</p></a></li>
<li><a href='#get_varying_h'><p>Get differences 'h' which are adjusted for overly large degrees of freedom parameters</p></a></li>
<li><a href='#GSMAR'><p>Create object of class 'gsmar' defining a GMAR, StMAR, or G-StMAR model</p></a></li>
<li><a href='#is_stationary'><p>Check the stationary condition of specified GMAR, StMAR, or G-StMAR model.</p></a></li>
<li><a href='#is_stationary_int'><p>Check the stationarity and identification conditions of specified GMAR, StMAR, or G-StMAR model.</p></a></li>
<li><a href='#isStationary'><p>DEPRECATED, USE <code>is_stationary</code> INSTEAD! Check the stationary condition of specified GMAR, StMAR, or G-StMAR model.</p></a></li>
<li><a href='#iterate_more'><p>Maximum likelihood estimation of GMAR, StMAR, or G-StMAR model with preliminary estimates</p></a></li>
<li><a href='#loglikelihood'><p>Compute the log-likelihood of GMAR, StMAR, or G-StMAR model</p></a></li>
<li><a href='#loglikelihood_int'><p>Compute the log-likelihood of GMAR, StMAR, or G-StMAR model</p></a></li>
<li><a href='#LR_test'><p>Perform likelihood ratio test</p></a></li>
<li><a href='#M10Y1Y'><p>Spread between 10-Year and 1-Year Treasury rates: M10Y1Y</p></a></li>
<li><a href='#mixing_weights'><p>Calculate mixing weights of GMAR, StMAR or G-StMAR model</p></a></li>
<li><a href='#mixing_weights_int'><p>Calculate mixing weights of a GMAR, StMAR, or G-StMAR model</p></a></li>
<li><a href='#mixingWeights'><p>DEPRECATED, USE <code>mixing_weights</code> INSTEAD! Calculate mixing weights of GMAR, StMAR or G-StMAR model</p></a></li>
<li><a href='#n_params'><p>Calculate the number of parameters</p></a></li>
<li><a href='#parameter_checks'><p>Check the parameter vector is specified correctly</p></a></li>
<li><a href='#pick_alphas'><p>Pick mixing weights parameters from parameter vector</p></a></li>
<li><a href='#pick_dfs'><p>Pick degrees of freedom parameters from a parameter vector</p></a></li>
<li><a href='#pick_pars'><p>Pick <code class="reqn">\phi_0</code> (or <code class="reqn">\mu</code>), AR-coefficients, and variance parameters from a parameter vector</p></a></li>
<li><a href='#pick_phi0'><p>Pick phi0 or mean parameters from parameter vector</p></a></li>
<li><a href='#plot.gsmarpred'><p>Plot method for class 'gsmarpred' objects</p></a></li>
<li><a href='#plot.qrtest'><p>Quantile residual tests for GMAR, StMAR , and G-StMAR models</p></a></li>
<li><a href='#predict.gsmar'><p>Forecast GMAR, StMAR, or G-StMAR process</p></a></li>
<li><a href='#print.gsmarpred'><p>Print method for class 'gsmarpred' objects</p></a></li>
<li><a href='#print.gsmarsum'><p>Print method from objects of class 'gsmarsum'</p></a></li>
<li><a href='#profile_logliks'><p>Plot profile log-likelihoods around the estimates</p></a></li>
<li><a href='#quantile_residual_plot'><p>Plot quantile residual time series and histogram</p></a></li>
<li><a href='#quantile_residuals'><p>Compute quantile residuals of GMAR, StMAR, or G-StMAR model</p></a></li>
<li><a href='#quantile_residuals_int'><p>Compute quantile residuals of GMAR, StMAR, or G-StMAR model</p></a></li>
<li><a href='#quantileResidualPlot'><p>DEPRECATED, USE <code>quantile_residual_plot</code> INSTEAD! Plot quantile residual time series and histogram</p></a></li>
<li><a href='#quantileResiduals'><p>DEPRECATED, USE <code>quantile_residuals</code> INSTEAD! Compute quantile residuals of GMAR, StMAR, or G-StMAR model</p></a></li>
<li><a href='#quantileResidualTests'><p>DEPRECATED, USE <code>quantile_residual_tests</code> INSTEAD! Quantile residual tests for GMAR, StMAR , and G-StMAR models</p></a></li>
<li><a href='#random_arcoefs'><p>Create random AR coefficients</p></a></li>
<li><a href='#random_ind'><p>Create random GMAR, StMAR, or G-StMAR model compatible parameter vector</p></a></li>
<li><a href='#random_ind_int'><p>Create random GMAR, StMAR, or G-StMAR model compatible parameter vector</p></a></li>
<li><a href='#random_regime'><p>Create random regime parameters</p></a></li>
<li><a href='#randomIndividual'><p>DEPRECATED, USE <code>random_ind</code> OR <code>smart_ind</code> INSTEAD!</p>
Create random GMAR, StMAR, or G-StMAR model compatible parameter vector</a></li>
<li><a href='#reform_constrained_pars'><p>Reform parameter vector with linear constraints to correspond non-constrained parameter vector.</p></a></li>
<li><a href='#reform_parameters'><p>Reform any parameter vector into standard form.</p></a></li>
<li><a href='#reform_restricted_pars'><p>Reform parameter vector with restricted autoregressive parameters to correspond non-restricted parameter vector.</p></a></li>
<li><a href='#regime_distance'><p>Calculate &quot;distance&quot; between two regimes</p></a></li>
<li><a href='#remove_all_constraints'><p>Transform constrained and restricted parameter vector into the regular form</p></a></li>
<li><a href='#simudata'><p>Simulated data</p></a></li>
<li><a href='#simulate.gsmar'><p>Simulate obsercations from GMAR, StMAR, and G-StMAR processes</p></a></li>
<li><a href='#simulateGSMAR'><p>DEPRECATED, USE <code>simulate.gsmar</code> INSTEAD! Simulate observations from GMAR, StMAR, and G-StMAR processes</p></a></li>
<li><a href='#sort_components'><p>Sort the mixture components of a GMAR, StMAR, or G-StMAR model</p></a></li>
<li><a href='#standard_errors'><p>Calculate standard errors for estimates of a GMAR, StMAR, or G-StMAR model</p></a></li>
<li><a href='#stmar_to_gstmar'><p>Estimate a G-StMAR model based on a StMAR model with large degrees of freedom parameters</p></a></li>
<li><a href='#stmarpars_to_gstmar'><p>Transform a StMAR or G-StMAR model parameter vector to a corresponding G-StMAR model parameter vector</p>
with large dfs parameters reduced.</a></li>
<li><a href='#swap_parametrization'><p>Swap the parametrization of object of class 'gsmar' defining a GMAR, StMAR, or G-StMAR model</p></a></li>
<li><a href='#T10Y1Y'><p>Spread between 10-Year and 1-Year Treasury rates: T10Y1Y</p></a></li>
<li><a href='#TBFF'><p>Spread between the 3-month Treasury bill rate and the effective federal funds rate: TBFF</p></a></li>
<li><a href='#uGMAR-package'><p>uGMAR: Estimate Univariate Gaussian and Student's t Mixture Autoregressive Models</p></a></li>
<li><a href='#uncond_moments'><p>Calculate unconditional mean, variance, first p autocovariances and autocorrelations of the GSMAR process.</p></a></li>
<li><a href='#uncond_moments_int'><p>Calculate unconditional mean, variance, and the first p autocovariances and autocorrelations</p>
of a GSMAR process.</a></li>
<li><a href='#Wald_test'><p>Perform Wald test</p></a></li>
<li><a href='#warn_ar_roots'><p>Warn about near-unit-roots in some regimes</p></a></li>
<li><a href='#warn_dfs'><p>Warn about large degrees of freedom parameter values</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Estimate Univariate Gaussian and Student's t Mixture
Autoregressive Models</td>
</tr>
<tr>
<td>Version:</td>
<td>3.4.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Maximum likelihood estimation of univariate Gaussian Mixture Autoregressive (GMAR),
    Student's t Mixture Autoregressive (StMAR), and Gaussian and Student's t Mixture Autoregressive (G-StMAR) models, 
    quantile residual tests, graphical diagnostics, forecast and simulate from GMAR, StMAR and G-StMAR processes. 
    Leena Kalliovirta, Mika Meitz, Pentti Saikkonen (2015) &lt;<a href="https://doi.org/10.1111%2Fjtsa.12108">doi:10.1111/jtsa.12108</a>&gt;, 
    Mika Meitz, Daniel Preve, Pentti Saikkonen (2023) &lt;<a href="https://doi.org/10.1080%2F03610926.2021.1916531">doi:10.1080/03610926.2021.1916531</a>&gt;,
    Savi Virolainen (2022) &lt;<a href="https://doi.org/10.1515%2Fsnde-2020-0060">doi:10.1515/snde-2020-0060</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/saviviro/uGMAR/issues">https://github.com/saviviro/uGMAR/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>Brobdingnag (&ge; 1.2-4), parallel, pbapply (&ge; 1.3-2), stats
(&ge; 3.3.2), gsl (&ge; 1.9-10.3)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-19 10:12:43 UTC; savi</td>
</tr>
<tr>
<td>Author:</td>
<td>Savi Virolainen [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Savi Virolainen &lt;savi.virolainen@helsinki.fi&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-19 10:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_data'>Add data to object of class 'gsmar' defining a GMAR, StMAR, or G-StMAR model</h2><span id='topic+add_data'></span>

<h3>Description</h3>

<p><code>add_data</code> adds or updates data to object of class '<code>gsmar</code>' that defines a GMAR, StMAR,
or G-StMAR model. Also calculates empirical mixing weights, conditional moments, and quantile residuals accordingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_data(
  data,
  gsmar,
  calc_qresiduals = TRUE,
  calc_cond_moments = TRUE,
  calc_std_errors = FALSE,
  custom_h = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_data_+3A_data">data</code></td>
<td>
<p>a numeric vector or class <code>'ts'</code> object containing the data. <code>NA</code> values are not supported.</p>
</td></tr>
<tr><td><code id="add_data_+3A_gsmar">gsmar</code></td>
<td>
<p>a class 'gsmar' object, typically generated by <code>fitGSMAR</code> or <code>GSMAR</code>.</p>
</td></tr>
<tr><td><code id="add_data_+3A_calc_qresiduals">calc_qresiduals</code></td>
<td>
<p>should quantile residuals be calculated? Default is <code>TRUE</code> iff the model contains data.</p>
</td></tr>
<tr><td><code id="add_data_+3A_calc_cond_moments">calc_cond_moments</code></td>
<td>
<p>should conditional means and variances be calculated? Default is <code>TRUE</code> iff the model contains data.</p>
</td></tr>
<tr><td><code id="add_data_+3A_calc_std_errors">calc_std_errors</code></td>
<td>
<p>should approximate standard errors be calculated?</p>
</td></tr>
<tr><td><code id="add_data_+3A_custom_h">custom_h</code></td>
<td>
<p>A numeric vector with same the length as the parameter vector: i:th element of custom_h is the difference
used in central difference approximation for partial differentials of the log-likelihood function for the i:th parameter.
If <code>NULL</code> (default), then the difference used for differentiating overly large degrees of freedom parameters
is adjusted to avoid numerical problems, and the difference is <code>6e-6</code> for the other parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class 'gsmar' defining the GMAR, StMAR, or G-StMAR model with the data added to the model.
If the object already contained data, the data will be updated. Does not modify the 'gsmar' object given as argument!
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2015. Gaussian Mixture Autoregressive model for univariate time series.
<em>Journal of Time Series Analysis</em>, <strong>36</strong>(2), 247-266.
</p>
</li>
<li><p> Meitz M., Preve D., Saikkonen P. 2023. A mixture autoregressive model based on Student's t-distribution.
<em>Communications in Statistics - Theory and Methods</em>, <strong>52</strong>(2), 499-515.
</p>
</li>
<li><p> Virolainen S. 2022. A mixture autoregressive model based on Gaussian and Student's t-distributions.
Studies in Nonlinear Dynamics &amp; Econometrics, <strong>26</strong>(4) 559-580.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+fitGSMAR">fitGSMAR</a></code>, <code><a href="#topic+GSMAR">GSMAR</a></code>, <code><a href="#topic+iterate_more">iterate_more</a></code>, <code><a href="#topic+get_gradient">get_gradient</a></code>,
<code><a href="#topic+get_regime_means">get_regime_means</a></code>, <code><a href="#topic+swap_parametrization">swap_parametrization</a></code>, <code><a href="#topic+stmar_to_gstmar">stmar_to_gstmar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># G-StMAR model without data
params42gs &lt;- c(0.04, 1.34, -0.59, 0.54, -0.36, 0.01, 0.06, 1.28, -0.36,
                0.2, -0.15, 0.04, 0.19, 9.75)
gstmar42 &lt;- GSMAR(p=4, M=c(1, 1), params=params42gs, model="G-StMAR")
gstmar42

# Add data to the model
gstmar42 &lt;- add_data(data=M10Y1Y, gsmar=gstmar42)
gstmar42
</code></pre>

<hr>
<h2 id='add_dfs'>Add random dfs to a vector</h2><span id='topic+add_dfs'></span>

<h3>Description</h3>

<p><code>add_dfs</code> adds random degrees of freedom parameters to a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_dfs(x, how_many)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_dfs_+3A_x">x</code></td>
<td>
<p>a vector to add the dfs to</p>
</td></tr>
<tr><td><code id="add_dfs_+3A_how_many">how_many</code></td>
<td>
<p>how many dfs?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Read the source code for details.
</p>


<h3>Value</h3>

<p>Returns <code>c(x, dfs)</code> with <code>how_many</code> dfs-elements.
</p>

<hr>
<h2 id='all_pos_ints'>Check whether all arguments are strictly positive natural numbers</h2><span id='topic+all_pos_ints'></span>

<h3>Description</h3>

<p><code>all_pos_ints</code> tells whether all the elements in a vector
are strictly positive natural numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_pos_ints(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_pos_ints_+3A_x">x</code></td>
<td>
<p>a vector containing the elements to be tested.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>TRUE</code> or <code>FALSE</code> accordingly.
</p>

<hr>
<h2 id='alt_gsmar'>Construct a GSMAR model based on results from an arbitrary estimation round of <code>fitGSMAR</code></h2><span id='topic+alt_gsmar'></span>

<h3>Description</h3>

<p><code>alt_gsmar</code> constructs a GSMAR model based on results from an arbitrary estimation round of <code>fitGSMAR</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alt_gsmar(
  gsmar,
  which_round = 1,
  which_largest,
  calc_qresiduals = TRUE,
  calc_cond_moments = TRUE,
  calc_std_errors = TRUE,
  custom_h = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alt_gsmar_+3A_gsmar">gsmar</code></td>
<td>
<p>a class 'gsmar' object, typically generated by <code>fitGSMAR</code> or <code>GSMAR</code>.</p>
</td></tr>
<tr><td><code id="alt_gsmar_+3A_which_round">which_round</code></td>
<td>
<p>based on which estimation round should the model be constructed? An integer value in 1,...,<code>ncalls</code>.</p>
</td></tr>
<tr><td><code id="alt_gsmar_+3A_which_largest">which_largest</code></td>
<td>
<p>based on estimation round with which largest log-likelihood should the model be constructed?
An integer value in 1,...,<code>ncalls</code>. For example, <code>which_largest=2</code> would take the second largest log-likelihood
and construct the model based on the corresponding estimates. If specified, then <code>which_round</code> is ignored.</p>
</td></tr>
<tr><td><code id="alt_gsmar_+3A_calc_qresiduals">calc_qresiduals</code></td>
<td>
<p>should quantile residuals be calculated? Default is <code>TRUE</code> iff the model contains data.</p>
</td></tr>
<tr><td><code id="alt_gsmar_+3A_calc_cond_moments">calc_cond_moments</code></td>
<td>
<p>should conditional means and variances be calculated? Default is <code>TRUE</code> iff the model contains data.</p>
</td></tr>
<tr><td><code id="alt_gsmar_+3A_calc_std_errors">calc_std_errors</code></td>
<td>
<p>should approximate standard errors be calculated?</p>
</td></tr>
<tr><td><code id="alt_gsmar_+3A_custom_h">custom_h</code></td>
<td>
<p>A numeric vector with same the length as the parameter vector: i:th element of custom_h is the difference
used in central difference approximation for partial differentials of the log-likelihood function for the i:th parameter.
If <code>NULL</code> (default), then the difference used for differentiating overly large degrees of freedom parameters
is adjusted to avoid numerical problems, and the difference is <code>6e-6</code> for the other parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It's sometimes useful to examine other estimates than the one with the highest log-likelihood value. This function
is just a simple wrapper to <code>GSMAR</code> that picks the correct estimates from an object returned by <code>fitGSMAR</code>.
</p>
<p>In addition to the S3 methods listed under the topic &quot;Methods (by generic)&quot;, the <code>predict</code> and simulate methods
are also available for the class 'gsmar' objects (see <code>?predict.gsmar</code> and <code>?simulate.gsmar</code>).
</p>


<h3>Value</h3>

<p>Returns an object of class <code>'gsmar'</code> defining the specified GMAR, StMAR, or G-StMAR model. If data is supplied,
the returned object contains (by default) empirical mixing weights, some conditional and unconditional moments, and quantile
residuals. Note that the first p observations are taken as the initial values so the mixing weights, conditional moments, and
quantile residuals start from the p+1:th observation (interpreted as t=1).
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2015. Gaussian Mixture Autoregressive model for univariate time series.
<em>Journal of Time Series Analysis</em>, <strong>36</strong>(2), 247-266.
</p>
</li>
<li><p> Meitz M., Preve D., Saikkonen P. 2023. A mixture autoregressive model based on Student's t-distribution.
<em>Communications in Statistics - Theory and Methods</em>, <strong>52</strong>(2), 499-515.
</p>
</li>
<li><p> Virolainen S. 2022. A mixture autoregressive model based on Gaussian and Student's t-distributions.
Studies in Nonlinear Dynamics &amp; Econometrics, <strong>26</strong>(4) 559-580.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+fitGSMAR">fitGSMAR</a></code>, <code><a href="#topic+GSMAR">GSMAR</a></code>, <code><a href="#topic+iterate_more">iterate_more</a></code>, <code><a href="#topic+get_gradient">get_gradient</a></code>,
<code><a href="#topic+get_regime_means">get_regime_means</a></code>, <code><a href="#topic+swap_parametrization">swap_parametrization</a></code>, <code><a href="#topic+stmar_to_gstmar">stmar_to_gstmar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # These are long running examples that take approximately ...
 fit42t &lt;- fitGSMAR(data=M10Y1Y, p=4, M=2, model="StMAR", ncalls=2,
                    seeds=c(1, 6))
 fit42t # Bad estimate in the boundary of the stationarity region!

 # So we build a model based on the next-best local maximum point:
 fit42t_alt &lt;- alt_gsmar(fit42t, which_largest=2)
 fit42t_alt # Overly large degrees of freedom paramter estimate

 # Switch to the appropriate G-StMAR model:
 fit42gs &lt;- stmar_to_gstmar(fit42t_alt)
 fit42gs

</code></pre>

<hr>
<h2 id='calc_gradient'>Calculate gradient or Hessian matrix</h2><span id='topic+calc_gradient'></span><span id='topic+calc_hessian'></span><span id='topic+get_gradient'></span><span id='topic+get_foc'></span><span id='topic+get_hessian'></span><span id='topic+get_soc'></span>

<h3>Description</h3>

<p><code>calc_gradient</code> or <code>calc_hessian</code> calculates the gradient or Hessian matrix
of the given function at the given point using central difference numerical approximation.
<code>get_gradient</code> (and <code>get_foc</code>) or <code>get_hessian</code> calculates the gradient or Hessian matrix of the
log-likelihood function at the parameter values of a class <code>'gsmar'</code> object.
<code>get_soc</code> returns eigenvalues of the Hessian matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_gradient(x, fn, h = 6e-06, varying_h = NULL, ...)

calc_hessian(x, fn, h = 6e-06, varying_h = NULL, ...)

get_gradient(gsmar, custom_h = NULL)

get_foc(gsmar, custom_h = NULL)

get_hessian(gsmar, custom_h = NULL)

get_soc(gsmar, custom_h = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_gradient_+3A_x">x</code></td>
<td>
<p>a numeric vector specifying the point at which the gradient or Hessian should be evaluated.</p>
</td></tr>
<tr><td><code id="calc_gradient_+3A_fn">fn</code></td>
<td>
<p>a function that takes in the argument <code>x</code> as the <strong>first</strong> argument.</p>
</td></tr>
<tr><td><code id="calc_gradient_+3A_h">h</code></td>
<td>
<p>the difference used to approximate the derivatives.</p>
</td></tr>
<tr><td><code id="calc_gradient_+3A_varying_h">varying_h</code></td>
<td>
<p>a numeric vector with the same length as <code>x</code> specifying the difference <code>h</code>
for each dimension separately. If <code>NULL</code> (default), then the difference given as parameter <code>h</code>
will be used for all dimensions.</p>
</td></tr>
<tr><td><code id="calc_gradient_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code>fn</code>.</p>
</td></tr>
<tr><td><code id="calc_gradient_+3A_gsmar">gsmar</code></td>
<td>
<p>a class 'gsmar' object, typically generated by <code>fitGSMAR</code> or <code>GSMAR</code>.</p>
</td></tr>
<tr><td><code id="calc_gradient_+3A_custom_h">custom_h</code></td>
<td>
<p>same as <code>varying_h</code> but if <code>NULL</code> (default), then the difference <code>h</code> used for differentiating
overly large degrees of freedom parameters is adjusted to avoid numerical problems, and the difference is <code>6e-6</code> for the other
parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In particular, the functions <code>get_foc</code> and <code>get_soc</code> can be used to check whether
the found estimates denote a (local) maximum point, a saddle point, or something else.
</p>


<h3>Value</h3>

<p>The gradient functions return numerical approximation of the gradient, and the Hessian functions return
numerical approximation of the Hessian. <code>get_soc</code> returns eigenvalues of the Hessian matrix, <code>get_foc</code>
is the same as <code>get_gradient</code> but named conveniently.
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>


<h3>See Also</h3>

<p><code><a href="#topic+profile_logliks">profile_logliks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple function
foo &lt;- function(x) x^2 + x
calc_gradient(x=1, fn=foo)
calc_gradient(x=-0.5, fn=foo)
calc_hessian(x=2, fn=foo)

# More complicated function
foo &lt;- function(x, a, b) a*x[1]^2 - b*x[2]^2
calc_gradient(x=c(1, 2), fn=foo, a=0.3, b=0.1)
calc_hessian(x=c(1, 2), fn=foo, a=0.3, b=0.1)

# GMAR model
params12 &lt;- c(1.70, 0.85, 0.30, 4.12, 0.73, 1.98, 0.63)
gmar12 &lt;- GSMAR(data=simudata, p=1, M=2, params=params12, model="GMAR")
get_gradient(gmar12)
get_foc(gmar12)
get_hessian(gmar12)
get_soc(gmar12)
</code></pre>

<hr>
<h2 id='change_parametrization'>Change parametrization of a parameter vector</h2><span id='topic+change_parametrization'></span>

<h3>Description</h3>

<p><code>change_parametrization</code> changes the parametrization of the given parameter
vector to <code>change_to</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>change_parametrization(
  p,
  M,
  params,
  model = c("GMAR", "StMAR", "G-StMAR"),
  restricted = FALSE,
  constraints = NULL,
  change_to = c("intercept", "mean")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="change_parametrization_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="change_parametrization_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMAR</strong> and <strong>StMAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMAR type</em> components <code>M1</code> in the
first element and <em>StMAR type</em> components <code>M2</code> in the second element. The total number of mixture components is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="change_parametrization_+3A_params">params</code></td>
<td>
<p>a real valued parameter vector specifying the model.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(M(p+3)+M-M1-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=</code>(<strong><code class="reqn">\upsilon_{1}</code></strong><code class="reqn">,...,</code><strong><code class="reqn">\upsilon_{M}</code></strong>,
<code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>) where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn">=(\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,</code><code class="reqn">\sigma_{m}^2)</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p}), m=1,...,M</code>
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMAR type regimes.
</p>
</li></ul>

<p>In the <strong>GMAR</strong> model, <code class="reqn">M1=M</code> and the parameter <strong><code class="reqn">\nu</code></strong> dropped. In the <strong>StMAR</strong> model, <code class="reqn">M1=0</code>.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vectors <strong><code class="reqn">\phi_{m}</code></strong> with the vectors <strong><code class="reqn">\psi_{m}</code></strong> that satisfy
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(3M+M-M1+p-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=(\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">,</code>
<code class="reqn">\sigma_{1}^2,...,\sigma_{M}^2,</code><code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where <strong><code class="reqn">\phi</code></strong>=<code class="reqn">(\phi_{1},...,\phi_{p})</code>
contains the AR coefficients, which are common for all regimes.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vector <strong><code class="reqn">\phi</code></strong> with the vector <strong><code class="reqn">\psi</code></strong> that satisfies
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
</dl>

<p>Symbol <code class="reqn">\phi</code> denotes an AR coefficient, <code class="reqn">\sigma^2</code> a variance, <code class="reqn">\alpha</code> a mixing weight, and <code class="reqn">\nu</code> a degrees of
freedom parameter. If <code>parametrization=="mean"</code>, just replace each intercept term <code class="reqn">\phi_{m,0}</code> with the regimewise mean
<code class="reqn">\mu_m = \phi_{m,0}/(1-\sum\phi_{i,m})</code>. In the <strong>G-StMAR</strong> model, the first <code>M1</code> components are <em>GMAR type</em>
and the rest <code>M2</code> components are <em>StMAR type</em>.
Note that in the case <strong>M=1</strong>, the mixing weight parameters <code class="reqn">\alpha</code> are dropped, and in the case of <strong>StMAR</strong> or <strong>G-StMAR</strong> model,
the degrees of freedom parameters <code class="reqn">\nu</code> have to be larger than <code class="reqn">2</code>.</p>
</td></tr>
<tr><td><code id="change_parametrization_+3A_model">model</code></td>
<td>
<p>is &quot;GMAR&quot;, &quot;StMAR&quot;, or &quot;G-StMAR&quot; model considered? In the G-StMAR model, the first <code>M1</code> components
are <em>GMAR type</em> and the rest <code>M2</code> components are <em>StMAR type</em>.</p>
</td></tr>
<tr><td><code id="change_parametrization_+3A_restricted">restricted</code></td>
<td>
<p>a logical argument stating whether the AR coefficients <code class="reqn">\phi_{m,1},...,\phi_{m,p}</code> are restricted
to be the same for all regimes.</p>
</td></tr>
<tr><td><code id="change_parametrization_+3A_constraints">constraints</code></td>
<td>
<p>specifies linear constraints imposed to each regime's autoregressive parameters separately.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd><p>a list of size <code class="reqn">(pxq_{m})</code> constraint matrices <strong><code class="reqn">C_{m}</code></strong> of full column rank
satisfying <strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> for all <code class="reqn">m=1,...,M</code>, where
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p})</code> and <strong><code class="reqn">\psi_{m}</code></strong><code class="reqn">=(\psi_{m,1},...,\psi_{m,q_{m}})</code>.</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd><p>a size <code class="reqn">(pxq)</code> constraint matrix <strong><code class="reqn">C</code></strong> of full column rank satisfying
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong>, where <strong><code class="reqn">\phi</code></strong><code class="reqn">=(\phi_{1},...,\phi_{p})</code> and
<strong><code class="reqn">\psi</code></strong><code class="reqn">=\psi_{1},...,\psi_{q}</code>.</p>
</dd>
</dl>

<p>The symbol <code class="reqn">\phi</code> denotes an AR coefficient. Note that regardless of any constraints, the autoregressive order
is always <code>p</code> for all regimes.
Ignore or set to <code>NULL</code> if applying linear constraints is not desired.</p>
</td></tr>
<tr><td><code id="change_parametrization_+3A_change_to">change_to</code></td>
<td>
<p>either &quot;intercept&quot; or &quot;mean&quot; specifying to which parametrization it should be switched to.
If set to <code>"intercept"</code>, it's assumed that <code>params</code> is mean-parametrized, and if set to <code>"mean"</code>
it's assumed that <code>params</code> is intercept-parametrized.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns parameter vector described in <code>params</code> but with parametrization changed from intercept to mean
(when <code>change_to==mean</code>) or from mean to intercept (when <code>change_to==intercept</code>).
</p>


<h3>Warning</h3>

<p>No argument checks!
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2015. Gaussian Mixture Autoregressive model for univariate time series.
<em>Journal of Time Series Analysis</em>, <strong>36</strong>(2), 247-266.
</p>
</li>
<li><p> Meitz M., Preve D., Saikkonen P. 2023. A mixture autoregressive model based on Student's t-distribution.
<em>Communications in Statistics - Theory and Methods</em>, <strong>52</strong>(2), 499-515.
</p>
</li>
<li><p> Virolainen S. 2022. A mixture autoregressive model based on Gaussian and Student's t-distributions.
Studies in Nonlinear Dynamics &amp; Econometrics, <strong>26</strong>(4) 559-580.
</p>
</li></ul>


<hr>
<h2 id='change_regime'>Change the specified regime of parameter vector to the given regime-parameter vector</h2><span id='topic+change_regime'></span>

<h3>Description</h3>

<p><code>change_regime</code> changes the specified regime of the parameter vector to correspond the given
regime-parameter vector and returns the modified parameter vector. Does not affect mixing weight parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>change_regime(
  p,
  M,
  params,
  model = c("GMAR", "StMAR", "G-StMAR"),
  restricted = FALSE,
  constraints = NULL,
  regime_params,
  regime
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="change_regime_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="change_regime_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMAR</strong> and <strong>StMAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMAR type</em> components <code>M1</code> in the
first element and <em>StMAR type</em> components <code>M2</code> in the second element. The total number of mixture components is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="change_regime_+3A_params">params</code></td>
<td>
<p>a real valued parameter vector specifying the model.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(M(p+3)+M-M1-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=</code>(<strong><code class="reqn">\upsilon_{1}</code></strong><code class="reqn">,...,</code><strong><code class="reqn">\upsilon_{M}</code></strong>,
<code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>) where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn">=(\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,</code><code class="reqn">\sigma_{m}^2)</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p}), m=1,...,M</code>
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMAR type regimes.
</p>
</li></ul>

<p>In the <strong>GMAR</strong> model, <code class="reqn">M1=M</code> and the parameter <strong><code class="reqn">\nu</code></strong> dropped. In the <strong>StMAR</strong> model, <code class="reqn">M1=0</code>.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vectors <strong><code class="reqn">\phi_{m}</code></strong> with the vectors <strong><code class="reqn">\psi_{m}</code></strong> that satisfy
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(3M+M-M1+p-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=(\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">,</code>
<code class="reqn">\sigma_{1}^2,...,\sigma_{M}^2,</code><code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where <strong><code class="reqn">\phi</code></strong>=<code class="reqn">(\phi_{1},...,\phi_{p})</code>
contains the AR coefficients, which are common for all regimes.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vector <strong><code class="reqn">\phi</code></strong> with the vector <strong><code class="reqn">\psi</code></strong> that satisfies
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
</dl>

<p>Symbol <code class="reqn">\phi</code> denotes an AR coefficient, <code class="reqn">\sigma^2</code> a variance, <code class="reqn">\alpha</code> a mixing weight, and <code class="reqn">\nu</code> a degrees of
freedom parameter. If <code>parametrization=="mean"</code>, just replace each intercept term <code class="reqn">\phi_{m,0}</code> with the regimewise mean
<code class="reqn">\mu_m = \phi_{m,0}/(1-\sum\phi_{i,m})</code>. In the <strong>G-StMAR</strong> model, the first <code>M1</code> components are <em>GMAR type</em>
and the rest <code>M2</code> components are <em>StMAR type</em>.
Note that in the case <strong>M=1</strong>, the mixing weight parameters <code class="reqn">\alpha</code> are dropped, and in the case of <strong>StMAR</strong> or <strong>G-StMAR</strong> model,
the degrees of freedom parameters <code class="reqn">\nu</code> have to be larger than <code class="reqn">2</code>.</p>
</td></tr>
<tr><td><code id="change_regime_+3A_model">model</code></td>
<td>
<p>is &quot;GMAR&quot;, &quot;StMAR&quot;, or &quot;G-StMAR&quot; model considered? In the G-StMAR model, the first <code>M1</code> components
are <em>GMAR type</em> and the rest <code>M2</code> components are <em>StMAR type</em>.</p>
</td></tr>
<tr><td><code id="change_regime_+3A_restricted">restricted</code></td>
<td>
<p>a logical argument stating whether the AR coefficients <code class="reqn">\phi_{m,1},...,\phi_{m,p}</code> are restricted
to be the same for all regimes.</p>
</td></tr>
<tr><td><code id="change_regime_+3A_constraints">constraints</code></td>
<td>
<p>specifies linear constraints imposed to each regime's autoregressive parameters separately.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd><p>a list of size <code class="reqn">(pxq_{m})</code> constraint matrices <strong><code class="reqn">C_{m}</code></strong> of full column rank
satisfying <strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> for all <code class="reqn">m=1,...,M</code>, where
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p})</code> and <strong><code class="reqn">\psi_{m}</code></strong><code class="reqn">=(\psi_{m,1},...,\psi_{m,q_{m}})</code>.</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd><p>a size <code class="reqn">(pxq)</code> constraint matrix <strong><code class="reqn">C</code></strong> of full column rank satisfying
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong>, where <strong><code class="reqn">\phi</code></strong><code class="reqn">=(\phi_{1},...,\phi_{p})</code> and
<strong><code class="reqn">\psi</code></strong><code class="reqn">=\psi_{1},...,\psi_{q}</code>.</p>
</dd>
</dl>

<p>The symbol <code class="reqn">\phi</code> denotes an AR coefficient. Note that regardless of any constraints, the autoregressive order
is always <code>p</code> for all regimes.
Ignore or set to <code>NULL</code> if applying linear constraints is not desired.</p>
</td></tr>
<tr><td><code id="change_regime_+3A_regime_params">regime_params</code></td>
<td>
<p>a numeric vector specifying the parameter values that should be inserted to the specified regime.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd>

<dl>
<dt>For <strong>GMAR</strong> model:</dt><dd><p>Size <code class="reqn">(p+2x1)</code> vector <code class="reqn">(\phi_{m,0},\phi_{m,1},...,\phi_{m,p}, \sigma_{m}^2)</code>.</p>
</dd>
<dt>For <strong>StMAR</strong> model:</dt><dd><p>Size <code class="reqn">(p+3x1)</code> vector <code class="reqn">(\phi_{m,0},\phi_{m,1},...,\phi_{m,p}, \sigma_{m}^2, \nu_{m})</code>.</p>
</dd>
<dt>For <strong>G-StMAR</strong> model:</dt><dd><p>Same as GMAR for GMAR type regimes and same as StMAR for StMAR type regimes.</p>
</dd>
<dt>With <strong>linear constraints</strong>:</dt><dd><p>Parameter vector as described above, but vector <strong><code class="reqn">\phi_{m}</code></strong> replaced with
vector <strong><code class="reqn">\psi_{m}</code></strong> that satisfies <strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">R_{m}\psi_{m}</code></strong>.</p>
</dd>
</dl>

</dd>
<dt>For <strong>restricted</strong> models:</dt><dd>

<dl>
<dt>For <strong>GMAR</strong> model:</dt><dd><p>Size <code class="reqn">(2x1)</code> vector <code class="reqn">(\phi_{m,0}, \sigma_{m}^2)</code>.</p>
</dd>
<dt>For <strong>StMAR</strong> model:</dt><dd><p>Size <code class="reqn">(3x1)</code> vector <code class="reqn">(\phi_{m,0}, \sigma_{m}^2, \nu_{m})</code>.</p>
</dd>
<dt>For <strong>G-StMAR</strong> model:</dt><dd><p>Same as GMAR for GMAR type regimes and same as StMAR for StMAR type regimes.</p>
</dd>
<dt>With <strong>linear constraints</strong>:</dt><dd><p>Parameter vector as described above.</p>
</dd>
</dl>

</dd>
</dl>
</td></tr>
<tr><td><code id="change_regime_+3A_regime">regime</code></td>
<td>
<p>a positive integer in the interval [1, M] defining which regime should be changed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns modified parameter vector of the form described in <code>params</code>.
</p>

<hr>
<h2 id='check_and_correct_data'>Check that the data is set correctly and correct if not</h2><span id='topic+check_and_correct_data'></span>

<h3>Description</h3>

<p><code>check_and_correct_data</code> checks that the data is set correctly and
throws an error if there is something wrong with the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_and_correct_data(data, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_and_correct_data_+3A_data">data</code></td>
<td>
<p>a numeric vector or class <code>'ts'</code> object containing the data. <code>NA</code> values are not supported.</p>
</td></tr>
<tr><td><code id="check_and_correct_data_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the data as a class 'ts' object.
</p>

<hr>
<h2 id='check_constraint_mat'>Check the constraint matrices</h2><span id='topic+check_constraint_mat'></span>

<h3>Description</h3>

<p><code>check_constraint_mat</code> checks for some parts that the constraint matrices are correctly set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_constraint_mat(p, M, restricted = FALSE, constraints = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_constraint_mat_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="check_constraint_mat_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMAR</strong> and <strong>StMAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMAR type</em> components <code>M1</code> in the
first element and <em>StMAR type</em> components <code>M2</code> in the second element. The total number of mixture components is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="check_constraint_mat_+3A_restricted">restricted</code></td>
<td>
<p>a logical argument stating whether the AR coefficients <code class="reqn">\phi_{m,1},...,\phi_{m,p}</code> are restricted
to be the same for all regimes.</p>
</td></tr>
<tr><td><code id="check_constraint_mat_+3A_constraints">constraints</code></td>
<td>
<p>specifies linear constraints imposed to each regime's autoregressive parameters separately.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd><p>a list of size <code class="reqn">(pxq_{m})</code> constraint matrices <strong><code class="reqn">C_{m}</code></strong> of full column rank
satisfying <strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> for all <code class="reqn">m=1,...,M</code>, where
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p})</code> and <strong><code class="reqn">\psi_{m}</code></strong><code class="reqn">=(\psi_{m,1},...,\psi_{m,q_{m}})</code>.</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd><p>a size <code class="reqn">(pxq)</code> constraint matrix <strong><code class="reqn">C</code></strong> of full column rank satisfying
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong>, where <strong><code class="reqn">\phi</code></strong><code class="reqn">=(\phi_{1},...,\phi_{p})</code> and
<strong><code class="reqn">\psi</code></strong><code class="reqn">=\psi_{1},...,\psi_{q}</code>.</p>
</dd>
</dl>

<p>The symbol <code class="reqn">\phi</code> denotes an AR coefficient. Note that regardless of any constraints, the autoregressive order
is always <code>p</code> for all regimes.
Ignore or set to <code>NULL</code> if applying linear constraints is not desired.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Doesn't return anything but throws an informative error if finds out that something is wrong.
</p>

<hr>
<h2 id='check_data'>Check that given object contains data</h2><span id='topic+check_data'></span>

<h3>Description</h3>

<p><code>check_data</code> checks that a given object contains data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_data(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_data_+3A_object">object</code></td>
<td>
<p>an object to be tested</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Doesn't return anything but throws and error if something is wrong.
</p>

<hr>
<h2 id='check_gsmar'>Check that given object has class attribute 'gsmar'</h2><span id='topic+check_gsmar'></span>

<h3>Description</h3>

<p><code>check_gsmar</code> checks that the given object has class attribute 'gsmar'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_gsmar(object, object_name = "gsmar")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_gsmar_+3A_object">object</code></td>
<td>
<p>an object to be tested</p>
</td></tr>
<tr><td><code id="check_gsmar_+3A_object_name">object_name</code></td>
<td>
<p>the name of the tested object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Doesn't return anything but throws and error if something is wrong.
</p>

<hr>
<h2 id='check_model'>Check that the argument 'model' is correctly specified.</h2><span id='topic+check_model'></span>

<h3>Description</h3>

<p><code>check_model</code> checks that the argument 'model' is correctly specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_model(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_model_+3A_model">model</code></td>
<td>
<p>is &quot;GMAR&quot;, &quot;StMAR&quot;, or &quot;G-StMAR&quot; model considered? In the G-StMAR model, the first <code>M1</code> components
are <em>GMAR type</em> and the rest <code>M2</code> components are <em>StMAR type</em>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Doesn't return anything but throws and error if something is wrong.
</p>

<hr>
<h2 id='check_params_length'>Check that the parameter vector has the correct dimension</h2><span id='topic+check_params_length'></span>

<h3>Description</h3>

<p><code>check_model</code> checks that the parameter vector has the correct dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_params_length(
  p,
  M,
  params,
  model = c("GMAR", "StMAR", "G-StMAR"),
  restricted = FALSE,
  constraints = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_params_length_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="check_params_length_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMAR</strong> and <strong>StMAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMAR type</em> components <code>M1</code> in the
first element and <em>StMAR type</em> components <code>M2</code> in the second element. The total number of mixture components is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="check_params_length_+3A_params">params</code></td>
<td>
<p>a real valued parameter vector specifying the model.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(M(p+3)+M-M1-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=</code>(<strong><code class="reqn">\upsilon_{1}</code></strong><code class="reqn">,...,</code><strong><code class="reqn">\upsilon_{M}</code></strong>,
<code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>) where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn">=(\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,</code><code class="reqn">\sigma_{m}^2)</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p}), m=1,...,M</code>
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMAR type regimes.
</p>
</li></ul>

<p>In the <strong>GMAR</strong> model, <code class="reqn">M1=M</code> and the parameter <strong><code class="reqn">\nu</code></strong> dropped. In the <strong>StMAR</strong> model, <code class="reqn">M1=0</code>.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vectors <strong><code class="reqn">\phi_{m}</code></strong> with the vectors <strong><code class="reqn">\psi_{m}</code></strong> that satisfy
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(3M+M-M1+p-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=(\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">,</code>
<code class="reqn">\sigma_{1}^2,...,\sigma_{M}^2,</code><code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where <strong><code class="reqn">\phi</code></strong>=<code class="reqn">(\phi_{1},...,\phi_{p})</code>
contains the AR coefficients, which are common for all regimes.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vector <strong><code class="reqn">\phi</code></strong> with the vector <strong><code class="reqn">\psi</code></strong> that satisfies
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
</dl>

<p>Symbol <code class="reqn">\phi</code> denotes an AR coefficient, <code class="reqn">\sigma^2</code> a variance, <code class="reqn">\alpha</code> a mixing weight, and <code class="reqn">\nu</code> a degrees of
freedom parameter. If <code>parametrization=="mean"</code>, just replace each intercept term <code class="reqn">\phi_{m,0}</code> with the regimewise mean
<code class="reqn">\mu_m = \phi_{m,0}/(1-\sum\phi_{i,m})</code>. In the <strong>G-StMAR</strong> model, the first <code>M1</code> components are <em>GMAR type</em>
and the rest <code>M2</code> components are <em>StMAR type</em>.
Note that in the case <strong>M=1</strong>, the mixing weight parameters <code class="reqn">\alpha</code> are dropped, and in the case of <strong>StMAR</strong> or <strong>G-StMAR</strong> model,
the degrees of freedom parameters <code class="reqn">\nu</code> have to be larger than <code class="reqn">2</code>.</p>
</td></tr>
<tr><td><code id="check_params_length_+3A_model">model</code></td>
<td>
<p>is &quot;GMAR&quot;, &quot;StMAR&quot;, or &quot;G-StMAR&quot; model considered? In the G-StMAR model, the first <code>M1</code> components
are <em>GMAR type</em> and the rest <code>M2</code> components are <em>StMAR type</em>.</p>
</td></tr>
<tr><td><code id="check_params_length_+3A_restricted">restricted</code></td>
<td>
<p>a logical argument stating whether the AR coefficients <code class="reqn">\phi_{m,1},...,\phi_{m,p}</code> are restricted
to be the same for all regimes.</p>
</td></tr>
<tr><td><code id="check_params_length_+3A_constraints">constraints</code></td>
<td>
<p>specifies linear constraints imposed to each regime's autoregressive parameters separately.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd><p>a list of size <code class="reqn">(pxq_{m})</code> constraint matrices <strong><code class="reqn">C_{m}</code></strong> of full column rank
satisfying <strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> for all <code class="reqn">m=1,...,M</code>, where
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p})</code> and <strong><code class="reqn">\psi_{m}</code></strong><code class="reqn">=(\psi_{m,1},...,\psi_{m,q_{m}})</code>.</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd><p>a size <code class="reqn">(pxq)</code> constraint matrix <strong><code class="reqn">C</code></strong> of full column rank satisfying
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong>, where <strong><code class="reqn">\phi</code></strong><code class="reqn">=(\phi_{1},...,\phi_{p})</code> and
<strong><code class="reqn">\psi</code></strong><code class="reqn">=\psi_{1},...,\psi_{q}</code>.</p>
</dd>
</dl>

<p>The symbol <code class="reqn">\phi</code> denotes an AR coefficient. Note that regardless of any constraints, the autoregressive order
is always <code>p</code> for all regimes.
Ignore or set to <code>NULL</code> if applying linear constraints is not desired.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Doesn't return anything but throws and error if something is wrong.
</p>

<hr>
<h2 id='check_pM'>Check that p and M are correctly set</h2><span id='topic+check_pM'></span>

<h3>Description</h3>

<p><code>check_pM</code> checks that the arguments p and M are correctly set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_pM(p, M, model = c("GMAR", "StMAR", "G-StMAR"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_pM_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="check_pM_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMAR</strong> and <strong>StMAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMAR type</em> components <code>M1</code> in the
first element and <em>StMAR type</em> components <code>M2</code> in the second element. The total number of mixture components is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="check_pM_+3A_model">model</code></td>
<td>
<p>is &quot;GMAR&quot;, &quot;StMAR&quot;, or &quot;G-StMAR&quot; model considered? In the G-StMAR model, the first <code>M1</code> components
are <em>GMAR type</em> and the rest <code>M2</code> components are <em>StMAR type</em>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Doesn't return anything but throws an informative error if something is wrong.
</p>

<hr>
<h2 id='cond_moment_plot'>Conditional mean or variance plot for GMAR, StMAR, and G-StMAR models</h2><span id='topic+cond_moment_plot'></span>

<h3>Description</h3>

<p><code>cond_moment_plot</code> plots the one-step in-sample conditional means/variances of the model along with
the time series contained in the model (e.g. the time series the model was fitted to). Also plots
the regimewise conditional means/variances multiplied with the mixing weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cond_moment_plot(gsmar, which_moment = c("mean", "variance"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cond_moment_plot_+3A_gsmar">gsmar</code></td>
<td>
<p>a class 'gsmar' object, typically generated by <code>fitGSMAR</code> or <code>GSMAR</code>.</p>
</td></tr>
<tr><td><code id="cond_moment_plot_+3A_which_moment">which_moment</code></td>
<td>
<p>should conditional means or variances be plotted?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The conditional mean plot works best if the data contains positive values only.
</p>


<h3>Value</h3>

<p><code>cond_moment_plot</code> only plots to a graphical device and does not return anything. Numerical values
of the conditional means/variances can be extracted from the model with the dollar sign.
</p>


<h3>References</h3>


<ul>
<li><p> Galbraith, R., Galbraith, J. 1974. On the inverses of some patterned matrices arising
in the theory of stationary time series. <em>Journal of Applied Probability</em> <strong>11</strong>, 63-71.
</p>
</li>
<li><p> Kalliovirta L. (2012) Misspecification tests based on quantile residuals.
<em>The Econometrics Journal</em>, <strong>15</strong>, 358-393.
</p>
</li>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2015. Gaussian Mixture Autoregressive model for univariate time series.
<em>Journal of Time Series Analysis</em>, <strong>36</strong>(2), 247-266.
</p>
</li>
<li><p> Meitz M., Preve D., Saikkonen P. 2023. A mixture autoregressive model based on Student's t-distribution.
<em>Communications in Statistics - Theory and Methods</em>, <strong>52</strong>(2), 499-515.
</p>
</li>
<li><p> Virolainen S. 2022. A mixture autoregressive model based on Gaussian and Student's t-distributions.
Studies in Nonlinear Dynamics &amp; Econometrics, <strong>26</strong>(4) 559-580.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+profile_logliks">profile_logliks</a></code>, <code><a href="#topic+diagnostic_plot">diagnostic_plot</a></code>, <code><a href="#topic+fitGSMAR">fitGSMAR</a></code>, <code><a href="#topic+GSMAR">GSMAR</a></code>, <code><a href="#topic+quantile_residual_tests">quantile_residual_tests</a></code>,
<code><a href="#topic+quantile_residual_plot">quantile_residual_plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># GMAR model
params12 &lt;- c(1.70, 0.85, 0.30, 4.12, 0.73, 1.98, 0.63)
gmar12 &lt;- GSMAR(data=simudata, p=1, M=2, params=params12, model="GMAR")
cond_moment_plot(gmar12, which_moment="mean")
cond_moment_plot(gmar12, which_moment="variance")

# G-StMAR model
params42gs &lt;- c(0.04, 1.34, -0.59, 0.54, -0.36, 0.01, 0.06, 1.28, -0.36,
                0.2, -0.15, 0.04, 0.19, 9.75)
gstmar42 &lt;- GSMAR(data=M10Y1Y, p=4, M=c(1, 1), params=params42gs,
                  model="G-StMAR")
cond_moment_plot(gstmar42, which_moment="mean")
cond_moment_plot(gstmar42, which_moment="variance")
</code></pre>

<hr>
<h2 id='cond_moments'>Calculate conditional moments of GMAR, StMAR, or G-StMAR model</h2><span id='topic+cond_moments'></span>

<h3>Description</h3>

<p><code>cond_moments</code> calculates the regime specific conditional means and variances and total
conditional means and variances of the specified GMAR, StMAR or G-StMAR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cond_moments(
  data,
  p,
  M,
  params,
  model = c("GMAR", "StMAR", "G-StMAR"),
  restricted = FALSE,
  constraints = NULL,
  parametrization = c("intercept", "mean"),
  to_return = c("regime_cmeans", "regime_cvars", "total_cmeans", "total_cvars")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cond_moments_+3A_data">data</code></td>
<td>
<p>a numeric vector or class <code>'ts'</code> object containing the data. <code>NA</code> values are not supported.</p>
</td></tr>
<tr><td><code id="cond_moments_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="cond_moments_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMAR</strong> and <strong>StMAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMAR type</em> components <code>M1</code> in the
first element and <em>StMAR type</em> components <code>M2</code> in the second element. The total number of mixture components is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="cond_moments_+3A_params">params</code></td>
<td>
<p>a real valued parameter vector specifying the model.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(M(p+3)+M-M1-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=</code>(<strong><code class="reqn">\upsilon_{1}</code></strong><code class="reqn">,...,</code><strong><code class="reqn">\upsilon_{M}</code></strong>,
<code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>) where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn">=(\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,</code><code class="reqn">\sigma_{m}^2)</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p}), m=1,...,M</code>
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMAR type regimes.
</p>
</li></ul>

<p>In the <strong>GMAR</strong> model, <code class="reqn">M1=M</code> and the parameter <strong><code class="reqn">\nu</code></strong> dropped. In the <strong>StMAR</strong> model, <code class="reqn">M1=0</code>.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vectors <strong><code class="reqn">\phi_{m}</code></strong> with the vectors <strong><code class="reqn">\psi_{m}</code></strong> that satisfy
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(3M+M-M1+p-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=(\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">,</code>
<code class="reqn">\sigma_{1}^2,...,\sigma_{M}^2,</code><code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where <strong><code class="reqn">\phi</code></strong>=<code class="reqn">(\phi_{1},...,\phi_{p})</code>
contains the AR coefficients, which are common for all regimes.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vector <strong><code class="reqn">\phi</code></strong> with the vector <strong><code class="reqn">\psi</code></strong> that satisfies
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
</dl>

<p>Symbol <code class="reqn">\phi</code> denotes an AR coefficient, <code class="reqn">\sigma^2</code> a variance, <code class="reqn">\alpha</code> a mixing weight, and <code class="reqn">\nu</code> a degrees of
freedom parameter. If <code>parametrization=="mean"</code>, just replace each intercept term <code class="reqn">\phi_{m,0}</code> with the regimewise mean
<code class="reqn">\mu_m = \phi_{m,0}/(1-\sum\phi_{i,m})</code>. In the <strong>G-StMAR</strong> model, the first <code>M1</code> components are <em>GMAR type</em>
and the rest <code>M2</code> components are <em>StMAR type</em>.
Note that in the case <strong>M=1</strong>, the mixing weight parameters <code class="reqn">\alpha</code> are dropped, and in the case of <strong>StMAR</strong> or <strong>G-StMAR</strong> model,
the degrees of freedom parameters <code class="reqn">\nu</code> have to be larger than <code class="reqn">2</code>.</p>
</td></tr>
<tr><td><code id="cond_moments_+3A_model">model</code></td>
<td>
<p>is &quot;GMAR&quot;, &quot;StMAR&quot;, or &quot;G-StMAR&quot; model considered? In the G-StMAR model, the first <code>M1</code> components
are <em>GMAR type</em> and the rest <code>M2</code> components are <em>StMAR type</em>.</p>
</td></tr>
<tr><td><code id="cond_moments_+3A_restricted">restricted</code></td>
<td>
<p>a logical argument stating whether the AR coefficients <code class="reqn">\phi_{m,1},...,\phi_{m,p}</code> are restricted
to be the same for all regimes.</p>
</td></tr>
<tr><td><code id="cond_moments_+3A_constraints">constraints</code></td>
<td>
<p>specifies linear constraints imposed to each regime's autoregressive parameters separately.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd><p>a list of size <code class="reqn">(pxq_{m})</code> constraint matrices <strong><code class="reqn">C_{m}</code></strong> of full column rank
satisfying <strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> for all <code class="reqn">m=1,...,M</code>, where
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p})</code> and <strong><code class="reqn">\psi_{m}</code></strong><code class="reqn">=(\psi_{m,1},...,\psi_{m,q_{m}})</code>.</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd><p>a size <code class="reqn">(pxq)</code> constraint matrix <strong><code class="reqn">C</code></strong> of full column rank satisfying
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong>, where <strong><code class="reqn">\phi</code></strong><code class="reqn">=(\phi_{1},...,\phi_{p})</code> and
<strong><code class="reqn">\psi</code></strong><code class="reqn">=\psi_{1},...,\psi_{q}</code>.</p>
</dd>
</dl>

<p>The symbol <code class="reqn">\phi</code> denotes an AR coefficient. Note that regardless of any constraints, the autoregressive order
is always <code>p</code> for all regimes.
Ignore or set to <code>NULL</code> if applying linear constraints is not desired.</p>
</td></tr>
<tr><td><code id="cond_moments_+3A_parametrization">parametrization</code></td>
<td>
<p>is the model parametrized with the &quot;intercepts&quot; <code class="reqn">\phi_{m,0}</code> or
&quot;means&quot; <code class="reqn">\mu_{m} = \phi_{m,0}/(1-\sum\phi_{i,m})</code>?</p>
</td></tr>
<tr><td><code id="cond_moments_+3A_to_return">to_return</code></td>
<td>
<p>calculate regimewise conditional means (<code>regime_cmeans</code>), regimewise conditional variances
(<code>regime_cvars</code>), total conditional means (<code>total_cmeans</code>), or total conditional variances (<code>total_cvars</code>)?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Note that the first p observations are taken as the initial values so the conditional moments
start form the p+1:th observation (interpreted as t=1).
</p>

<dl>
<dt>if <code>to_return=="regime_cmeans"</code>:</dt><dd><p>a size ((n_obs-p)xM) matrix containing the regime specific conditional means.</p>
</dd>
<dt>if <code>to_return=="regime_cvars"</code>:</dt><dd><p>a size ((n_obs-p)xM) matrix containing the regime specific conditional variances.</p>
</dd>
<dt>if <code>to_return=="total_cmeans"</code>:</dt><dd><p>a size ((n_obs-p)x1) vector containing the total conditional means.</p>
</dd>
<dt>if <code>to_return=="total_cvars"</code>:</dt><dd><p>a size ((n_obs-p)x1) vector containing the total conditional variances.</p>
</dd>
</dl>



<h3>References</h3>


<ul>
<li><p> Galbraith, R., Galbraith, J. 1974. On the inverses of some patterned matrices arising
in the theory of stationary time series. <em>Journal of Applied Probability</em> <strong>11</strong>, 63-71.
</p>
</li>
<li><p> Kalliovirta L. (2012) Misspecification tests based on quantile residuals.
<em>The Econometrics Journal</em>, <strong>15</strong>, 358-393.
</p>
</li>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2015. Gaussian Mixture Autoregressive model for univariate time series.
<em>Journal of Time Series Analysis</em>, <strong>36</strong>(2), 247-266.
</p>
</li>
<li><p> Meitz M., Preve D., Saikkonen P. 2023. A mixture autoregressive model based on Student's t-distribution.
<em>Communications in Statistics - Theory and Methods</em>, <strong>52</strong>(2), 499-515.
</p>
</li>
<li><p> Virolainen S. 2022. A mixture autoregressive model based on Gaussian and Student's t-distributions.
Studies in Nonlinear Dynamics &amp; Econometrics, <strong>26</strong>(4) 559-580.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other moment functions: 
<code><a href="#topic+get_regime_autocovs">get_regime_autocovs</a>()</code>,
<code><a href="#topic+get_regime_means">get_regime_means</a>()</code>,
<code><a href="#topic+get_regime_vars">get_regime_vars</a>()</code>,
<code><a href="#topic+uncond_moments">uncond_moments</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># GMAR model, regimewise conditional means and variances
params12 &lt;- c(1.70, 0.85, 0.30, 4.12, 0.73, 1.98, 0.63)
cond_moments(simudata, p=1, M=2, params=params12, model="GMAR",
             to_return="regime_cmeans")
cond_moments(simudata, p=1, M=2, params=params12, model="GMAR",
             to_return="regime_cvars")

# G-StMAR-model, total conditional means and variances
params42gs &lt;- c(0.04, 1.34, -0.59, 0.54, -0.36, 0.01, 0.06, 1.28, -0.36,
                0.2, -0.15, 0.04, 0.19, 9.75)
cond_moments(M10Y1Y, p=4, M=c(1, 1), params=params42gs, model="G-StMAR",
             to_return="total_cmeans")
cond_moments(M10Y1Y, p=4, M=c(1, 1), params=params42gs, model="G-StMAR",
             to_return="total_cvars")
</code></pre>

<hr>
<h2 id='condmomentPlot'>DEPRECATED, USE <code>cond_moment_plot</code> INSTEAD! Conditional mean or variance plot for GMAR, StMAR, and G-StMAR models</h2><span id='topic+condmomentPlot'></span>

<h3>Description</h3>

<p><code>condmomentPlot</code> plots the one-step in-sample conditional means/variances of the model along with
the time series contained in the model (e.g. the time series the model was fitted to). Also plots
the regimewise conditional means/variances multiplied with the mixing weights.
DEPRECATED, USE <code>cond_moment_plot</code> INSTEAD!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>condmomentPlot(gsmar, which_moment = c("mean", "variance"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="condmomentPlot_+3A_gsmar">gsmar</code></td>
<td>
<p>a class 'gsmar' object, typically generated by <code>fitGSMAR</code> or <code>GSMAR</code>.</p>
</td></tr>
<tr><td><code id="condmomentPlot_+3A_which_moment">which_moment</code></td>
<td>
<p>should conditional means or variances be plotted?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>DEPRECATED, USE <code>cond_moment_plot</code> INSTEAD!
</p>


<h3>Value</h3>

<p><code>cond_moment_plot</code> only plots to a graphical device and does not return anything. Numerical values
of the conditional means/variances can be extracted from the model with the dollar sign.
</p>


<h3>References</h3>


<ul>
<li><p> Galbraith, R., Galbraith, J. 1974. On the inverses of some patterned matrices arising
in the theory of stationary time series. <em>Journal of Applied Probability</em> <strong>11</strong>, 63-71.
</p>
</li>
<li><p> Kalliovirta L. (2012) Misspecification tests based on quantile residuals.
<em>The Econometrics Journal</em>, <strong>15</strong>, 358-393.
</p>
</li>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2015. Gaussian Mixture Autoregressive model for univariate time series.
<em>Journal of Time Series Analysis</em>, <strong>36</strong>(2), 247-266.
</p>
</li>
<li><p> Meitz M., Preve D., Saikkonen P. 2023. A mixture autoregressive model based on Student's t-distribution.
<em>Communications in Statistics - Theory and Methods</em>, <strong>52</strong>(2), 499-515.
</p>
</li>
<li><p> Virolainen S. 2022. A mixture autoregressive model based on Gaussian and Student's t-distributions.
Studies in Nonlinear Dynamics &amp; Econometrics, <strong>26</strong>(4) 559-580.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+profile_logliks">profile_logliks</a></code>, <code><a href="#topic+diagnostic_plot">diagnostic_plot</a></code>, <code><a href="#topic+fitGSMAR">fitGSMAR</a></code>, <code><a href="#topic+GSMAR">GSMAR</a></code>, <code><a href="#topic+quantile_residual_tests">quantile_residual_tests</a></code>,
<code><a href="#topic+quantileResidualPlot">quantileResidualPlot</a></code>
</p>

<hr>
<h2 id='condMoments'>DEPRECATED, USE <code>cond_moments</code> INSTEAD! Calculate conditional moments of GMAR, StMAR, or G-StMAR model</h2><span id='topic+condMoments'></span>

<h3>Description</h3>

<p><code>condMoments</code> calculates the regime specific conditional means and variances and total
conditional means and variances of the specified GMAR, StMAR or G-StMAR model.
DEPRECATED, USE <code>cond_moments</code> INSTEAD!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>condMoments(
  data,
  p,
  M,
  params,
  model = c("GMAR", "StMAR", "G-StMAR"),
  restricted = FALSE,
  constraints = NULL,
  parametrization = c("intercept", "mean"),
  to_return = c("regime_cmeans", "regime_cvars", "total_cmeans", "total_cvars")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="condMoments_+3A_data">data</code></td>
<td>
<p>a numeric vector or class <code>'ts'</code> object containing the data. <code>NA</code> values are not supported.</p>
</td></tr>
<tr><td><code id="condMoments_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="condMoments_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMAR</strong> and <strong>StMAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMAR type</em> components <code>M1</code> in the
first element and <em>StMAR type</em> components <code>M2</code> in the second element. The total number of mixture components is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="condMoments_+3A_params">params</code></td>
<td>
<p>a real valued parameter vector specifying the model.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(M(p+3)+M-M1-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=</code>(<strong><code class="reqn">\upsilon_{1}</code></strong><code class="reqn">,...,</code><strong><code class="reqn">\upsilon_{M}</code></strong>,
<code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>) where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn">=(\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,</code><code class="reqn">\sigma_{m}^2)</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p}), m=1,...,M</code>
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMAR type regimes.
</p>
</li></ul>

<p>In the <strong>GMAR</strong> model, <code class="reqn">M1=M</code> and the parameter <strong><code class="reqn">\nu</code></strong> dropped. In the <strong>StMAR</strong> model, <code class="reqn">M1=0</code>.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vectors <strong><code class="reqn">\phi_{m}</code></strong> with the vectors <strong><code class="reqn">\psi_{m}</code></strong> that satisfy
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(3M+M-M1+p-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=(\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">,</code>
<code class="reqn">\sigma_{1}^2,...,\sigma_{M}^2,</code><code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where <strong><code class="reqn">\phi</code></strong>=<code class="reqn">(\phi_{1},...,\phi_{p})</code>
contains the AR coefficients, which are common for all regimes.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vector <strong><code class="reqn">\phi</code></strong> with the vector <strong><code class="reqn">\psi</code></strong> that satisfies
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
</dl>

<p>Symbol <code class="reqn">\phi</code> denotes an AR coefficient, <code class="reqn">\sigma^2</code> a variance, <code class="reqn">\alpha</code> a mixing weight, and <code class="reqn">\nu</code> a degrees of
freedom parameter. If <code>parametrization=="mean"</code>, just replace each intercept term <code class="reqn">\phi_{m,0}</code> with the regimewise mean
<code class="reqn">\mu_m = \phi_{m,0}/(1-\sum\phi_{i,m})</code>. In the <strong>G-StMAR</strong> model, the first <code>M1</code> components are <em>GMAR type</em>
and the rest <code>M2</code> components are <em>StMAR type</em>.
Note that in the case <strong>M=1</strong>, the mixing weight parameters <code class="reqn">\alpha</code> are dropped, and in the case of <strong>StMAR</strong> or <strong>G-StMAR</strong> model,
the degrees of freedom parameters <code class="reqn">\nu</code> have to be larger than <code class="reqn">2</code>.</p>
</td></tr>
<tr><td><code id="condMoments_+3A_model">model</code></td>
<td>
<p>is &quot;GMAR&quot;, &quot;StMAR&quot;, or &quot;G-StMAR&quot; model considered? In the G-StMAR model, the first <code>M1</code> components
are <em>GMAR type</em> and the rest <code>M2</code> components are <em>StMAR type</em>.</p>
</td></tr>
<tr><td><code id="condMoments_+3A_restricted">restricted</code></td>
<td>
<p>a logical argument stating whether the AR coefficients <code class="reqn">\phi_{m,1},...,\phi_{m,p}</code> are restricted
to be the same for all regimes.</p>
</td></tr>
<tr><td><code id="condMoments_+3A_constraints">constraints</code></td>
<td>
<p>specifies linear constraints imposed to each regime's autoregressive parameters separately.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd><p>a list of size <code class="reqn">(pxq_{m})</code> constraint matrices <strong><code class="reqn">C_{m}</code></strong> of full column rank
satisfying <strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> for all <code class="reqn">m=1,...,M</code>, where
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p})</code> and <strong><code class="reqn">\psi_{m}</code></strong><code class="reqn">=(\psi_{m,1},...,\psi_{m,q_{m}})</code>.</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd><p>a size <code class="reqn">(pxq)</code> constraint matrix <strong><code class="reqn">C</code></strong> of full column rank satisfying
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong>, where <strong><code class="reqn">\phi</code></strong><code class="reqn">=(\phi_{1},...,\phi_{p})</code> and
<strong><code class="reqn">\psi</code></strong><code class="reqn">=\psi_{1},...,\psi_{q}</code>.</p>
</dd>
</dl>

<p>The symbol <code class="reqn">\phi</code> denotes an AR coefficient. Note that regardless of any constraints, the autoregressive order
is always <code>p</code> for all regimes.
Ignore or set to <code>NULL</code> if applying linear constraints is not desired.</p>
</td></tr>
<tr><td><code id="condMoments_+3A_parametrization">parametrization</code></td>
<td>
<p>is the model parametrized with the &quot;intercepts&quot; <code class="reqn">\phi_{m,0}</code> or
&quot;means&quot; <code class="reqn">\mu_{m} = \phi_{m,0}/(1-\sum\phi_{i,m})</code>?</p>
</td></tr>
<tr><td><code id="condMoments_+3A_to_return">to_return</code></td>
<td>
<p>calculate regimewise conditional means (<code>regime_cmeans</code>), regimewise conditional variances
(<code>regime_cvars</code>), total conditional means (<code>total_cmeans</code>), or total conditional variances (<code>total_cvars</code>)?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Note that the first p observations are taken as the initial values so the conditional moments
start form the p+1:th observation (interpreted as t=1).
</p>

<dl>
<dt>if <code>to_return=="regime_cmeans"</code>:</dt><dd><p>a size ((n_obs-p)xM) matrix containing the regime specific conditional means.</p>
</dd>
<dt>if <code>to_return=="regime_cvars"</code>:</dt><dd><p>a size ((n_obs-p)xM) matrix containing the regime specific conditional variances.</p>
</dd>
<dt>if <code>to_return=="total_cmeans"</code>:</dt><dd><p>a size ((n_obs-p)x1) vector containing the total conditional means.</p>
</dd>
<dt>if <code>to_return=="total_cvars"</code>:</dt><dd><p>a size ((n_obs-p)x1) vector containing the total conditional variances.</p>
</dd>
</dl>



<h3>References</h3>


<ul>
<li><p> Galbraith, R., Galbraith, J. 1974. On the inverses of some patterned matrices arising
in the theory of stationary time series. <em>Journal of Applied Probability</em> <strong>11</strong>, 63-71.
</p>
</li>
<li><p> Kalliovirta L. (2012) Misspecification tests based on quantile residuals.
<em>The Econometrics Journal</em>, <strong>15</strong>, 358-393.
</p>
</li>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2015. Gaussian Mixture Autoregressive model for univariate time series.
<em>Journal of Time Series Analysis</em>, <strong>36</strong>(2), 247-266.
</p>
</li>
<li><p> Meitz M., Preve D., Saikkonen P. 2023. A mixture autoregressive model based on Student's t-distribution.
<em>Communications in Statistics - Theory and Methods</em>, <strong>52</strong>(2), 499-515.
</p>
</li>
<li><p> Virolainen S. 2022. A mixture autoregressive model based on Gaussian and Student's t-distributions.
Studies in Nonlinear Dynamics &amp; Econometrics, <strong>26</strong>(4) 559-580.
</p>
</li></ul>


<hr>
<h2 id='diagnostic_plot'>Quantile residual based diagnostic plots for GMAR, StMAR, and G-StMAR models</h2><span id='topic+diagnostic_plot'></span>

<h3>Description</h3>

<p><code>diagnostic_plot</code> plots quantile residual time series, normal QQ-plot, autocorrelation function,
and squared quantile residual autocorrelation function. There is an option to also plot the individual statistics
associated with the quantile residual tests (for autocorrelation and conditional heteroskedasticity) divided by
their approximate standard errors with their approximate 95% critical bounds (see Kalliovirta 2012, Section 3).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagnostic_plot(gsmar, nlags = 20, nsimu = 1, plot_indstats = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagnostic_plot_+3A_gsmar">gsmar</code></td>
<td>
<p>a class 'gsmar' object, typically generated by <code>fitGSMAR</code> or <code>GSMAR</code>.</p>
</td></tr>
<tr><td><code id="diagnostic_plot_+3A_nlags">nlags</code></td>
<td>
<p>a positive integer specifying how many lags should be calculated for the autocorrelation and
conditional heteroscedasticity statistics.</p>
</td></tr>
<tr><td><code id="diagnostic_plot_+3A_nsimu">nsimu</code></td>
<td>
<p>a positive integer specifying to how many simulated values from the process the covariance
matrix &quot;Omega&quot; (used to compute the tests) should be based on. Larger number of simulations may result
more reliable tests but takes longer to compute. If smaller than data size, then &quot;Omega&quot; will be based
on the given data. Ignored if <code>plot_indstats==FALSE</code>.</p>
</td></tr>
<tr><td><code id="diagnostic_plot_+3A_plot_indstats">plot_indstats</code></td>
<td>
<p>set <code>TRUE</code> if the individual statistics discussed in Kalliovirta (2012) should be
plotted with their approximate 95% critical bounds (this may take some time).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sometimes the individual statistics are not plotted because it was not (numerically) possible
to calculate all the required statistics. This may suggest that the model is misspecified.
</p>
<p>The dashed lines plotted with autocorrelation functions (for quantile residuals and their squares) are
plus-minus <code class="reqn">1.96*T^{-1/2}</code> where <code class="reqn">T</code> is the sample size (minus the <code class="reqn">p</code> initial values for
conditional models).
</p>


<h3>Value</h3>

<p><code>diagnostic_plot</code> only plots to a graphical device and does not return anything. Use the
function <code>quantile_residual_tests</code> in order to obtain the individual statistics.
</p>


<h3>Suggested packages</h3>

<p>Install the suggested package &quot;gsl&quot; for faster evaluations in the cases of StMAR and G-StMAR models.
For large StMAR and G-StMAR models with large data the calculations to obtain the individual statistics
may take a significantly long time without the package &quot;gsl&quot;.
</p>


<h3>References</h3>


<ul>
<li><p> Galbraith, R., Galbraith, J. 1974. On the inverses of some patterned matrices arising
in the theory of stationary time series. <em>Journal of Applied Probability</em> <strong>11</strong>, 63-71.
</p>
</li>
<li><p> Kalliovirta L. (2012) Misspecification tests based on quantile residuals.
<em>The Econometrics Journal</em>, <strong>15</strong>, 358-393.
</p>
</li>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2015. Gaussian Mixture Autoregressive model for univariate time series.
<em>Journal of Time Series Analysis</em>, <strong>36</strong>(2), 247-266.
</p>
</li>
<li><p> Meitz M., Preve D., Saikkonen P. 2023. A mixture autoregressive model based on Student's t-distribution.
<em>Communications in Statistics - Theory and Methods</em>, <strong>52</strong>(2), 499-515.
</p>
</li>
<li><p> Virolainen S. 2022. A mixture autoregressive model based on Gaussian and Student's t-distributions.
Studies in Nonlinear Dynamics &amp; Econometrics, <strong>26</strong>(4) 559-580.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+profile_logliks">profile_logliks</a></code>, <code><a href="#topic+get_foc">get_foc</a></code>, <code><a href="#topic+fitGSMAR">fitGSMAR</a></code>, <code><a href="#topic+cond_moment_plot">cond_moment_plot</a></code>, <code><a href="#topic+quantile_residual_tests">quantile_residual_tests</a></code>,
<code><a href="#topic+quantile_residual_plot">quantile_residual_plot</a></code>, <code><a href="#topic+simulate.gsmar">simulate.gsmar</a></code>, <code><a href="#topic+LR_test">LR_test</a></code>, <code><a href="#topic+Wald_test">Wald_test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The below examples the approximately 30 seconds to run.

# G-StMAR model with one GMAR type and one StMAR type regime
fit42gs &lt;- fitGSMAR(M10Y1Y, p=4, M=c(1, 1), model="G-StMAR",
                    ncalls=1, seeds=4)
diagnostic_plot(fit42gs)

# Restricted StMAR model: plot also the individual statistics with
# their approximate critical bounds using the given data (and not
# simulation procedure)
fit42tr &lt;- fitGSMAR(M10Y1Y, p=4, M=2, model="StMAR", restricted=TRUE,
                    ncalls=1, seeds=1)
diagnostic_plot(fit42tr, nlags=10, nsimu=1, plot_indstats=TRUE)

# GMAR model, plot 30 lags.
fit12 &lt;- fitGSMAR(data=simudata, p=1, M=2, model="GMAR", ncalls=1, seeds=1)
diagnostic_plot(fit12, nlags=30)

</code></pre>

<hr>
<h2 id='diagnosticPlot'>DEPRECATED, USE <code>diagnostic_plot</code> INSTEAD! Quantile residual based diagnostic plots for GMAR, StMAR, and G-StMAR models</h2><span id='topic+diagnosticPlot'></span>

<h3>Description</h3>

<p><code>diagnosticPlot</code> plots quantile residual time series, normal QQ-plot, autocorrelation function,
and squared quantile residual autocorrelation function. There is an option to also plot the individual statistics
associated with the quantile residual tests (for autocorrelation and conditional heteroskedasticity) divided by
their approximate standard errors with their approximate 95% critical bounds (see Kalliovirta 2012, Section 3).
DEPRECATED, USE <code>diagnostic_plot</code> INSTEAD!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagnosticPlot(gsmar, nlags = 20, nsimu = 1, plot_indstats = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagnosticPlot_+3A_gsmar">gsmar</code></td>
<td>
<p>a class 'gsmar' object, typically generated by <code>fitGSMAR</code> or <code>GSMAR</code>.</p>
</td></tr>
<tr><td><code id="diagnosticPlot_+3A_nlags">nlags</code></td>
<td>
<p>a positive integer specifying how many lags should be calculated for the autocorrelation and
conditional heteroscedasticity statistics.</p>
</td></tr>
<tr><td><code id="diagnosticPlot_+3A_nsimu">nsimu</code></td>
<td>
<p>a positive integer specifying to how many simulated values from the process the covariance
matrix &quot;Omega&quot; (used to compute the tests) should be based on. Larger number of simulations may result
more reliable tests but takes longer to compute. If smaller than data size, then &quot;Omega&quot; will be based
on the given data. Ignored if <code>plot_indstats==FALSE</code>.</p>
</td></tr>
<tr><td><code id="diagnosticPlot_+3A_plot_indstats">plot_indstats</code></td>
<td>
<p>set <code>TRUE</code> if the individual statistics discussed in Kalliovirta (2012) should be
plotted with their approximate 95% critical bounds (this may take some time).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>DEPRECATED, USE <code>diagnostic_plot</code> INSTEAD!
</p>
<p>Sometimes the individual statistics are not plotted because it was not (numerically) possible
to calculate all the required statistics. This may suggest that the model is misspecified.
</p>
<p>The dashed lines plotted with autocorrelation functions (for quantile residuals and their squares) are
plus-minus <code class="reqn">1.96*T^{-1/2}</code> where <code class="reqn">T</code> is the sample size (minus the <code class="reqn">p</code> initial values for
conditional models).
</p>


<h3>Value</h3>

<p><code>diagnostic_plot</code> only plots to a graphical device and does not return anything. Use the
function <code>quantile_residual_tests</code> in order to obtain the individual statistics.
</p>


<h3>Suggested packages</h3>

<p>Install the suggested package &quot;gsl&quot; for faster evaluations in the cases of StMAR and G-StMAR models.
For large StMAR and G-StMAR models with large data the calculations to obtain the individual statistics
may take a significantly long time without the package &quot;gsl&quot;.
</p>


<h3>References</h3>


<ul>
<li><p> Galbraith, R., Galbraith, J. 1974. On the inverses of some patterned matrices arising
in the theory of stationary time series. <em>Journal of Applied Probability</em> <strong>11</strong>, 63-71.
</p>
</li>
<li><p> Kalliovirta L. (2012) Misspecification tests based on quantile residuals.
<em>The Econometrics Journal</em>, <strong>15</strong>, 358-393.
</p>
</li>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2015. Gaussian Mixture Autoregressive model for univariate time series.
<em>Journal of Time Series Analysis</em>, <strong>36</strong>(2), 247-266.
</p>
</li>
<li><p> Meitz M., Preve D., Saikkonen P. 2023. A mixture autoregressive model based on Student's t-distribution.
<em>Communications in Statistics - Theory and Methods</em>, <strong>52</strong>(2), 499-515.
</p>
</li>
<li><p> Virolainen S. 2022. A mixture autoregressive model based on Gaussian and Student's t-distributions.
Studies in Nonlinear Dynamics &amp; Econometrics, <strong>26</strong>(4) 559-580.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+profile_logliks">profile_logliks</a></code>, <code><a href="#topic+get_foc">get_foc</a></code>, <code><a href="#topic+fitGSMAR">fitGSMAR</a></code>, <code><a href="#topic+cond_moment_plot">cond_moment_plot</a></code>, <code><a href="#topic+quantile_residual_tests">quantile_residual_tests</a></code>,
<code><a href="#topic+quantile_residual_plot">quantile_residual_plot</a></code>, <code><a href="#topic+simulate.gsmar">simulate.gsmar</a></code>, <code><a href="#topic+LR_test">LR_test</a></code>, <code><a href="#topic+Wald_test">Wald_test</a></code>
</p>

<hr>
<h2 id='extract_regime'>Extract regime from a parameter vector</h2><span id='topic+extract_regime'></span>

<h3>Description</h3>

<p><code>extract_regime</code> extracts the specified regime from the GMAR, StMAR, or G-StMAR model parameter vector.
Doesn't extract mixing weight parameter <code class="reqn">\alpha</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_regime(
  p,
  M,
  params,
  model = c("GMAR", "StMAR", "G-StMAR"),
  restricted = FALSE,
  constraints = NULL,
  regime,
  with_dfs = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_regime_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="extract_regime_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMAR</strong> and <strong>StMAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMAR type</em> components <code>M1</code> in the
first element and <em>StMAR type</em> components <code>M2</code> in the second element. The total number of mixture components is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="extract_regime_+3A_params">params</code></td>
<td>
<p>a real valued parameter vector specifying the model.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(M(p+3)+M-M1-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=</code>(<strong><code class="reqn">\upsilon_{1}</code></strong><code class="reqn">,...,</code><strong><code class="reqn">\upsilon_{M}</code></strong>,
<code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>) where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn">=(\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,</code><code class="reqn">\sigma_{m}^2)</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p}), m=1,...,M</code>
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMAR type regimes.
</p>
</li></ul>

<p>In the <strong>GMAR</strong> model, <code class="reqn">M1=M</code> and the parameter <strong><code class="reqn">\nu</code></strong> dropped. In the <strong>StMAR</strong> model, <code class="reqn">M1=0</code>.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vectors <strong><code class="reqn">\phi_{m}</code></strong> with the vectors <strong><code class="reqn">\psi_{m}</code></strong> that satisfy
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(3M+M-M1+p-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=(\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">,</code>
<code class="reqn">\sigma_{1}^2,...,\sigma_{M}^2,</code><code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where <strong><code class="reqn">\phi</code></strong>=<code class="reqn">(\phi_{1},...,\phi_{p})</code>
contains the AR coefficients, which are common for all regimes.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vector <strong><code class="reqn">\phi</code></strong> with the vector <strong><code class="reqn">\psi</code></strong> that satisfies
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
</dl>

<p>Symbol <code class="reqn">\phi</code> denotes an AR coefficient, <code class="reqn">\sigma^2</code> a variance, <code class="reqn">\alpha</code> a mixing weight, and <code class="reqn">\nu</code> a degrees of
freedom parameter. If <code>parametrization=="mean"</code>, just replace each intercept term <code class="reqn">\phi_{m,0}</code> with the regimewise mean
<code class="reqn">\mu_m = \phi_{m,0}/(1-\sum\phi_{i,m})</code>. In the <strong>G-StMAR</strong> model, the first <code>M1</code> components are <em>GMAR type</em>
and the rest <code>M2</code> components are <em>StMAR type</em>.
Note that in the case <strong>M=1</strong>, the mixing weight parameters <code class="reqn">\alpha</code> are dropped, and in the case of <strong>StMAR</strong> or <strong>G-StMAR</strong> model,
the degrees of freedom parameters <code class="reqn">\nu</code> have to be larger than <code class="reqn">2</code>.</p>
</td></tr>
<tr><td><code id="extract_regime_+3A_model">model</code></td>
<td>
<p>is &quot;GMAR&quot;, &quot;StMAR&quot;, or &quot;G-StMAR&quot; model considered? In the G-StMAR model, the first <code>M1</code> components
are <em>GMAR type</em> and the rest <code>M2</code> components are <em>StMAR type</em>.</p>
</td></tr>
<tr><td><code id="extract_regime_+3A_restricted">restricted</code></td>
<td>
<p>a logical argument stating whether the AR coefficients <code class="reqn">\phi_{m,1},...,\phi_{m,p}</code> are restricted
to be the same for all regimes.</p>
</td></tr>
<tr><td><code id="extract_regime_+3A_constraints">constraints</code></td>
<td>
<p>specifies linear constraints imposed to each regime's autoregressive parameters separately.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd><p>a list of size <code class="reqn">(pxq_{m})</code> constraint matrices <strong><code class="reqn">C_{m}</code></strong> of full column rank
satisfying <strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> for all <code class="reqn">m=1,...,M</code>, where
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p})</code> and <strong><code class="reqn">\psi_{m}</code></strong><code class="reqn">=(\psi_{m,1},...,\psi_{m,q_{m}})</code>.</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd><p>a size <code class="reqn">(pxq)</code> constraint matrix <strong><code class="reqn">C</code></strong> of full column rank satisfying
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong>, where <strong><code class="reqn">\phi</code></strong><code class="reqn">=(\phi_{1},...,\phi_{p})</code> and
<strong><code class="reqn">\psi</code></strong><code class="reqn">=\psi_{1},...,\psi_{q}</code>.</p>
</dd>
</dl>

<p>The symbol <code class="reqn">\phi</code> denotes an AR coefficient. Note that regardless of any constraints, the autoregressive order
is always <code>p</code> for all regimes.
Ignore or set to <code>NULL</code> if applying linear constraints is not desired.</p>
</td></tr>
<tr><td><code id="extract_regime_+3A_regime">regime</code></td>
<td>
<p>a positive integer in the interval [1, M] defining which regime should be extracted.</p>
</td></tr>
<tr><td><code id="extract_regime_+3A_with_dfs">with_dfs</code></td>
<td>
<p>Should the degrees of freedom parameter (if any) be included?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric vector corresponding to the regime with...
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd>

<dl>
<dt>For <strong>GMAR</strong> model:</dt><dd><p>Size <code class="reqn">(p+2x1)</code> vector <code class="reqn">(\phi_{m,0},\phi_{m,1},...,\phi_{m,p}, \sigma_{m}^2)</code>.</p>
</dd>
<dt>For <strong>StMAR</strong> model:</dt><dd><p>Size <code class="reqn">(p+3x1)</code> vector <code class="reqn">(\phi_{m,0},\phi_{m,1},...,\phi_{m,p}, \sigma_{m}^2, \nu_{m})</code>.</p>
</dd>
<dt>For <strong>G-StMAR</strong> model:</dt><dd><p>Same as GMAR for GMAR type regimes and same as StMAR for StMAR type regimes.</p>
</dd>
<dt>With <strong>linear constraints</strong>:</dt><dd><p>Parameter vector as described above, but vector <strong><code class="reqn">\phi_{m}</code></strong> replaced with
vector <strong><code class="reqn">\psi_{m}</code></strong> that satisfies <strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">R_{m}\psi_{m}</code></strong>.</p>
</dd>
</dl>

</dd>
<dt>For <strong>restricted</strong> models:</dt><dd>

<dl>
<dt>For <strong>GMAR</strong> model:</dt><dd><p>Size <code class="reqn">(2x1)</code> vector <code class="reqn">(\phi_{m,0}, \sigma_{m}^2)</code>.</p>
</dd>
<dt>For <strong>StMAR</strong> model:</dt><dd><p>Size <code class="reqn">(3x1)</code> vector <code class="reqn">(\phi_{m,0}, \sigma_{m}^2, \nu_{m})</code>.</p>
</dd>
<dt>For <strong>G-StMAR</strong> model:</dt><dd><p>Same as GMAR for GMAR type regimes and same as StMAR for StMAR type regimes.</p>
</dd>
<dt>With <strong>linear constraints</strong>:</dt><dd><p>Parameter vector as described above.</p>
</dd>
</dl>

</dd>
</dl>


<hr>
<h2 id='fitGSMAR'>Estimate Gaussian or Student's t Mixture Autoregressive model</h2><span id='topic+fitGSMAR'></span>

<h3>Description</h3>

<p><code>fitGSMAR</code> estimates GMAR, StMAR, or G-StMAR model in two phases. In the first phase, a genetic algorithm is employed
to find starting values for a gradient based method. In the second phase, the gradient based variable metric algorithm is utilized to
accurately converge to a local maximum or a saddle point near each starting value. Parallel computing is used to conduct multiple
rounds of estimations in parallel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitGSMAR(
  data,
  p,
  M,
  model = c("GMAR", "StMAR", "G-StMAR"),
  restricted = FALSE,
  constraints = NULL,
  conditional = TRUE,
  parametrization = c("intercept", "mean"),
  ncalls = round(10 + 9 * log(sum(M))),
  ncores = 2,
  maxit = 300,
  seeds = NULL,
  print_res = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitGSMAR_+3A_data">data</code></td>
<td>
<p>a numeric vector or class <code>'ts'</code> object containing the data. <code>NA</code> values are not supported.</p>
</td></tr>
<tr><td><code id="fitGSMAR_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="fitGSMAR_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMAR</strong> and <strong>StMAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMAR type</em> components <code>M1</code> in the
first element and <em>StMAR type</em> components <code>M2</code> in the second element. The total number of mixture components is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="fitGSMAR_+3A_model">model</code></td>
<td>
<p>is &quot;GMAR&quot;, &quot;StMAR&quot;, or &quot;G-StMAR&quot; model considered? In the G-StMAR model, the first <code>M1</code> components
are <em>GMAR type</em> and the rest <code>M2</code> components are <em>StMAR type</em>.</p>
</td></tr>
<tr><td><code id="fitGSMAR_+3A_restricted">restricted</code></td>
<td>
<p>a logical argument stating whether the AR coefficients <code class="reqn">\phi_{m,1},...,\phi_{m,p}</code> are restricted
to be the same for all regimes.</p>
</td></tr>
<tr><td><code id="fitGSMAR_+3A_constraints">constraints</code></td>
<td>
<p>specifies linear constraints imposed to each regime's autoregressive parameters separately.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd><p>a list of size <code class="reqn">(pxq_{m})</code> constraint matrices <strong><code class="reqn">C_{m}</code></strong> of full column rank
satisfying <strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> for all <code class="reqn">m=1,...,M</code>, where
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p})</code> and <strong><code class="reqn">\psi_{m}</code></strong><code class="reqn">=(\psi_{m,1},...,\psi_{m,q_{m}})</code>.</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd><p>a size <code class="reqn">(pxq)</code> constraint matrix <strong><code class="reqn">C</code></strong> of full column rank satisfying
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong>, where <strong><code class="reqn">\phi</code></strong><code class="reqn">=(\phi_{1},...,\phi_{p})</code> and
<strong><code class="reqn">\psi</code></strong><code class="reqn">=\psi_{1},...,\psi_{q}</code>.</p>
</dd>
</dl>

<p>The symbol <code class="reqn">\phi</code> denotes an AR coefficient. Note that regardless of any constraints, the autoregressive order
is always <code>p</code> for all regimes.
Ignore or set to <code>NULL</code> if applying linear constraints is not desired.</p>
</td></tr>
<tr><td><code id="fitGSMAR_+3A_conditional">conditional</code></td>
<td>
<p>a logical argument specifying whether the conditional or exact log-likelihood function should be used.</p>
</td></tr>
<tr><td><code id="fitGSMAR_+3A_parametrization">parametrization</code></td>
<td>
<p>is the model parametrized with the &quot;intercepts&quot; <code class="reqn">\phi_{m,0}</code> or
&quot;means&quot; <code class="reqn">\mu_{m} = \phi_{m,0}/(1-\sum\phi_{i,m})</code>?</p>
</td></tr>
<tr><td><code id="fitGSMAR_+3A_ncalls">ncalls</code></td>
<td>
<p>a positive integer specifying how many rounds of estimation should be conducted.
The estimation results may vary from round to round because of multimodality of the log-likelihood function
and the randomness associated with the genetic algorithm.</p>
</td></tr>
<tr><td><code id="fitGSMAR_+3A_ncores">ncores</code></td>
<td>
<p>the number of CPU cores to be used in the estimation process.</p>
</td></tr>
<tr><td><code id="fitGSMAR_+3A_maxit">maxit</code></td>
<td>
<p>the maximum number of iterations for the variable metric algorithm.</p>
</td></tr>
<tr><td><code id="fitGSMAR_+3A_seeds">seeds</code></td>
<td>
<p>a length <code>ncalls</code> vector containing the random number generator seed for each call to the genetic algorithm,
or <code>NULL</code> for not initializing the seed. Exists for the purpose of creating reproducible results.</p>
</td></tr>
<tr><td><code id="fitGSMAR_+3A_print_res">print_res</code></td>
<td>
<p>should the estimation results be printed?</p>
</td></tr>
<tr><td><code id="fitGSMAR_+3A_...">...</code></td>
<td>
<p>additional settings passed to the function <code>GAfit</code> employing the genetic algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Because of complexity and multimodality of the log-likelihood function, it's <strong>not guaranteed</strong> that the estimation
algorithm will end up in the global maximum point. It's often expected that most of the estimation rounds will end up in
some local maximum point instead, and therefore a number of estimation rounds is required for reliable results. Because
of the nature of the models, the estimation may fail particularly in the cases where the number of mixture components is
chosen too large. Note that the genetic algorithm is designed to avoid solutions with mixing weights of some regimes
too close to zero at almost all times (&quot;redundant regimes&quot;) but the settings can, however, be adjusted (see ?GAfit).
</p>
<p>If the iteration limit for the variable metric algorithm (<code>maxit</code>) is reached, one can continue the estimation by
iterating more with the function <code>iterate_more</code>.
</p>
<p>The core of the genetic algorithm is mostly based on the description by <em>Dorsey and Mayer (1995)</em>. It utilizes
a slightly modified version the individually adaptive crossover and mutation rates described by <em>Patnaik and Srinivas (1994)</em>
and employs (50%) fitness inheritance discussed by <em>Smith, Dike and Stegmann (1995)</em>. Large (in absolute value) but stationary
AR parameter values are generated with the algorithm proposed by Monahan (1984).
</p>
<p>The variable metric algorithm (or quasi-Newton method, Nash (1990, algorithm 21)) used in the second phase is implemented
with function the <code>optim</code> from the package <code>stats</code>.
</p>
<p><strong>Additional Notes about the estimates:</strong>
</p>
<p>Sometimes the found MLE is very close to the boundary of the stationarity region some regime, the related variance parameter
is very small, and the associated mixing weights are &quot;spiky&quot;. This kind of estimates often maximize the log-likelihood function
for a technical reason that induces by the endogenously determined mixing weights. In such cases, it might be more appropriate
to consider the next-best local maximum point of the log-likelihood function that is well inside the parameter space. Models based
local-only maximum points can be built with the function <code>alt_gsmar</code> by adjusting the argument <code>which_largest</code>
accordingly.
</p>
<p>Some mixture components of the StMAR model may sometimes get very large estimates for the degrees of freedom parameters. Such parameters
are weakly identified and induce various numerical problems. However, mixture components with large degree of freedom parameters are
similar to the mixture components of the GMAR model. It's hence advisable to further estimate a G-StMAR model by allowing the mixture
components with large degrees of freedom parameter estimates to be GMAR type with the function <code>stmar_to_gstmar</code>.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>'gsmar'</code> defining the estimated GMAR, StMAR or G-StMAR model. The returned object contains
estimated mixing weights, some conditional and unconditional moments, and quantile residuals. Note that the first <code>p</code>
observations are taken as the initial values, so the mixing weights, conditional moments, and quantile residuals start from
the <code>p+1</code>:th observation (interpreted as t=1). In addition, the returned object contains the estimates and log-likelihoods
from all of the estimation rounds. See <code>?GSMAR</code> for the form of the parameter vector, if needed.
</p>


<h3>S3 methods</h3>

<p>The following S3 methods are supported for class <code>'gsmar'</code> objects: <code>print</code>, <code>summary</code>, <code>plot</code>,
<code>predict</code>, <code>simulate</code>, <code>logLik</code>, <code>residuals</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Dorsey R. E. and Mayer W. J. 1995. Genetic algorithms for estimation problems with multiple optima,
nondifferentiability, and other irregular features. <em>Journal of Business &amp; Economic Statistics</em>,
<strong>13</strong>, 53-66.
</p>
</li>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2015. Gaussian Mixture Autoregressive model for univariate time series.
<em>Journal of Time Series Analysis</em>, <strong>36</strong>(2), 247-266.
</p>
</li>
<li><p> Meitz M., Preve D., Saikkonen P. 2023. A mixture autoregressive model based on Student's t-distribution.
<em>Communications in Statistics - Theory and Methods</em>, <strong>52</strong>(2), 499-515.
</p>
</li>
<li><p> Monahan J.F. 1984. A Note on Enforcing Stationarity in Autoregressive-Moving Average Models.
<em>Biometrica</em> <strong>71</strong>, 403-404.
</p>
</li>
<li><p> Nash J. 1990. Compact Numerical Methods for Computers. Linear algebra and Function Minimization.
<em>Adam Hilger</em>.
</p>
</li>
<li><p> Patnaik L.M. and Srinivas M. 1994. Adaptive Probabilities of Crossover and Mutation in Genetic Algorithms.
<em>Transactions on Systems, Man and Cybernetics</em> <strong>24</strong>, 656-667.
</p>
</li>
<li><p> Smith R.E., Dike B.A., Stegmann S.A. 1995. Fitness inheritance in genetic algorithms.
<em>Proceedings of the 1995 ACM Symposium on Applied Computing</em>, 345-350.
</p>
</li>
<li><p> Virolainen S. 2022. A mixture autoregressive model based on Gaussian and Student's t-distributions.
Studies in Nonlinear Dynamics &amp; Econometrics, <strong>26</strong>(4) 559-580.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+GSMAR">GSMAR</a></code>, <code><a href="#topic+iterate_more">iterate_more</a></code>, , <code><a href="#topic+stmar_to_gstmar">stmar_to_gstmar</a></code>, <code><a href="#topic+add_data">add_data</a></code>,
<code><a href="#topic+profile_logliks">profile_logliks</a></code>, <code><a href="#topic+swap_parametrization">swap_parametrization</a></code>, <code><a href="#topic+get_gradient">get_gradient</a></code>, <code><a href="#topic+simulate.gsmar">simulate.gsmar</a></code>, <code><a href="#topic+predict.gsmar">predict.gsmar</a></code>,
<code><a href="#topic+diagnostic_plot">diagnostic_plot</a></code>, <code><a href="#topic+quantile_residual_tests">quantile_residual_tests</a></code>, <code><a href="#topic+cond_moments">cond_moments</a></code>, <code><a href="#topic+uncond_moments">uncond_moments</a></code>, <code><a href="#topic+LR_test">LR_test</a></code>, <code><a href="#topic+Wald_test">Wald_test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## These are long running examples that use parallel computing.
## The below examples take approximately 90 seconds to run.

## Note that the number of estimation rounds (ncalls) is relatively small
## in the below examples to reduce the time required for running the examples.
## For reliable results, a large number of estimation
## rounds is recommended!

# GMAR model
fit12 &lt;- fitGSMAR(data=simudata, p=1, M=2, model="GMAR", ncalls=4, seeds=1:4)
summary(fit12)
plot(fit12)
profile_logliks(fit12)
diagnostic_plot(fit12)

# StMAR model (boundary estimate + large degrees of freedom)
fit42t &lt;- fitGSMAR(data=M10Y1Y, p=4, M=2, model="StMAR", ncalls=2, seeds=c(1, 6))
summary(fit42t, digits=4) # Four almost-unit roots in the 2nd regime!
plot(fit42t) # Spiking mixing weights!
fit42t_alt &lt;- alt_gsmar(fit42t, which_largest=2) # The second largest local max
summary(fit42t_alt) # Overly large 2nd regime degrees of freedom estimate!
fit42gs &lt;- stmar_to_gstmar(fit42t_alt) # Switch to G-StMAR model
summary(fit42gs) # Finally, an appropriate model!
plot(fit42gs)

# Restricted StMAR model
fit42r &lt;- fitGSMAR(M10Y1Y, p=4, M=2, model="StMAR", restricted=TRUE,
                   ncalls=2, seeds=1:2)
fit42r

# G-StMAR model with one GMAR type and one StMAR type regime
fit42gs &lt;- fitGSMAR(M10Y1Y, p=4, M=c(1, 1), model="G-StMAR",
                    ncalls=1, seeds=4)
fit42gs

# The following three examples demonstrate how to apply linear constraints
# to the autoregressive (AR) parameters.

# Two-regime GMAR p=2 model with the second AR coeffiecient of
# of the second regime contrained to zero.
C22 &lt;- list(diag(1, ncol=2, nrow=2), as.matrix(c(1, 0)))
fit22c &lt;- fitGSMAR(M10Y1Y, p=2, M=2, constraints=C22, ncalls=1, seeds=6)
fit22c

# StMAR(3, 1) model with the second order AR coefficient constrained to zero.
C31 &lt;- list(matrix(c(1, 0, 0, 0, 0, 1), ncol=2))
fit31tc &lt;- fitGSMAR(M10Y1Y, p=3, M=1, model="StMAR", constraints=C31,
                    ncalls=1, seeds=1)
fit31tc

# Such StMAR(3, 2) model that the AR coefficients are restricted to be
# the same for both regimes and the second AR coefficients are
# constrained to zero.
fit32rc &lt;- fitGSMAR(M10Y1Y, p=3, M=2, model="StMAR", restricted=TRUE,
                    constraints=matrix(c(1, 0, 0, 0, 0, 1), ncol=2),
                    ncalls=1, seeds=1)
fit32rc

</code></pre>

<hr>
<h2 id='format_valuef'>Function factory for formatting values</h2><span id='topic+format_valuef'></span>

<h3>Description</h3>

<p><code>format_valuef</code> generates functions that format
values so that they print out with the desired number of digits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_valuef(digits)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_valuef_+3A_digits">digits</code></td>
<td>
<p>number of digits to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a function that takes an atomic vector as its argument
and returns it formatted to character with <code>digits</code> decimals.
</p>

<hr>
<h2 id='GAfit'>Genetic algorithm for preliminary estimation of GMAR, StMAR, or G-StMAR model</h2><span id='topic+GAfit'></span>

<h3>Description</h3>

<p><code>GAfit</code> estimates specified GMAR, StMAR, or G-StMAR model using a genetic algorithm.
The employed genetic algorithm is designed to find starting values for gradient based methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GAfit(
  data,
  p,
  M,
  model = c("GMAR", "StMAR", "G-StMAR"),
  restricted = FALSE,
  constraints = NULL,
  parametrization = c("intercept", "mean"),
  conditional = TRUE,
  ngen = 200,
  popsize,
  smart_mu = min(100, ceiling(0.5 * ngen)),
  mu_scale,
  sigma_scale,
  initpop = NULL,
  regime_force_scale = 1,
  red_criteria = c(0.05, 0.01),
  to_return = c("alt_ind", "best_ind"),
  minval,
  seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GAfit_+3A_data">data</code></td>
<td>
<p>a numeric vector or class <code>'ts'</code> object containing the data. <code>NA</code> values are not supported.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMAR</strong> and <strong>StMAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMAR type</em> components <code>M1</code> in the
first element and <em>StMAR type</em> components <code>M2</code> in the second element. The total number of mixture components is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="GAfit_+3A_model">model</code></td>
<td>
<p>is &quot;GMAR&quot;, &quot;StMAR&quot;, or &quot;G-StMAR&quot; model considered? In the G-StMAR model, the first <code>M1</code> components
are <em>GMAR type</em> and the rest <code>M2</code> components are <em>StMAR type</em>.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_restricted">restricted</code></td>
<td>
<p>a logical argument stating whether the AR coefficients <code class="reqn">\phi_{m,1},...,\phi_{m,p}</code> are restricted
to be the same for all regimes.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_constraints">constraints</code></td>
<td>
<p>specifies linear constraints imposed to each regime's autoregressive parameters separately.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd><p>a list of size <code class="reqn">(pxq_{m})</code> constraint matrices <strong><code class="reqn">C_{m}</code></strong> of full column rank
satisfying <strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> for all <code class="reqn">m=1,...,M</code>, where
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p})</code> and <strong><code class="reqn">\psi_{m}</code></strong><code class="reqn">=(\psi_{m,1},...,\psi_{m,q_{m}})</code>.</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd><p>a size <code class="reqn">(pxq)</code> constraint matrix <strong><code class="reqn">C</code></strong> of full column rank satisfying
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong>, where <strong><code class="reqn">\phi</code></strong><code class="reqn">=(\phi_{1},...,\phi_{p})</code> and
<strong><code class="reqn">\psi</code></strong><code class="reqn">=\psi_{1},...,\psi_{q}</code>.</p>
</dd>
</dl>

<p>The symbol <code class="reqn">\phi</code> denotes an AR coefficient. Note that regardless of any constraints, the autoregressive order
is always <code>p</code> for all regimes.
Ignore or set to <code>NULL</code> if applying linear constraints is not desired.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_parametrization">parametrization</code></td>
<td>
<p>is the model parametrized with the &quot;intercepts&quot; <code class="reqn">\phi_{m,0}</code> or
&quot;means&quot; <code class="reqn">\mu_{m} = \phi_{m,0}/(1-\sum\phi_{i,m})</code>?</p>
</td></tr>
<tr><td><code id="GAfit_+3A_conditional">conditional</code></td>
<td>
<p>a logical argument specifying whether the conditional or exact log-likelihood function should be used.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_ngen">ngen</code></td>
<td>
<p>a positive integer specifying the number of generations to be ran through in the genetic algorithm.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_popsize">popsize</code></td>
<td>
<p>a positive even integer specifying the population size in the genetic algorithm.
Default is <code>10*d</code> where <code>d</code> is the number of parameters.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_smart_mu">smart_mu</code></td>
<td>
<p>a positive integer specifying the generation after which the random mutations in the genetic algorithm are &quot;smart&quot;.
This means that mutating individuals will mostly mutate fairly close (or partially close) to the best fitting individual so far.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_mu_scale">mu_scale</code></td>
<td>
<p>a real valued vector of length two specifying the mean (the first element) and standard deviation (the second element)
of the normal distribution from which the <code class="reqn">\mu_{m}</code> mean-parameters are generated in random mutations in the genetic algorithm.
Default is <code>c(mean(data), sd(data))</code>.
Note that the genetic algorithm optimizes with mean-parametrization even when <code>parametrization=="intercept"</code>, but
input (in <code>initpop</code>) and output (return value) parameter vectors may be intercept-parametrized.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_sigma_scale">sigma_scale</code></td>
<td>
<p>a positive real number specifying the standard deviation of the (zero mean, positive only by taking absolute value)
normal distribution from which the component variance parameters are generated in the random mutations in the genetic algorithm.
Default is <code>var(stats::ar(data, order.max=10)$resid, na.rm=TRUE)</code>.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_initpop">initpop</code></td>
<td>
<p>a list of parameter vectors from which the initial population of the genetic algorithm will be generated from.
The parameter vectors should be of form...
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(M(p+3)+M-M1-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=</code>(<strong><code class="reqn">\upsilon_{1}</code></strong><code class="reqn">,...,</code><strong><code class="reqn">\upsilon_{M}</code></strong>,
<code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>) where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn">=(\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,</code><code class="reqn">\sigma_{m}^2)</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p}), m=1,...,M</code>
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMAR type regimes.
</p>
</li></ul>

<p>In the <strong>GMAR</strong> model, <code class="reqn">M1=M</code> and the parameter <strong><code class="reqn">\nu</code></strong> dropped. In the <strong>StMAR</strong> model, <code class="reqn">M1=0</code>.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vectors <strong><code class="reqn">\phi_{m}</code></strong> with the vectors <strong><code class="reqn">\psi_{m}</code></strong> that satisfy
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(3M+M-M1+p-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=(\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">,</code>
<code class="reqn">\sigma_{1}^2,...,\sigma_{M}^2,</code><code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where <strong><code class="reqn">\phi</code></strong>=<code class="reqn">(\phi_{1},...,\phi_{p})</code>
contains the AR coefficients, which are common for all regimes.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vector <strong><code class="reqn">\phi</code></strong> with the vector <strong><code class="reqn">\psi</code></strong> that satisfies
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
</dl>

<p>Symbol <code class="reqn">\phi</code> denotes an AR coefficient, <code class="reqn">\sigma^2</code> a variance, <code class="reqn">\alpha</code> a mixing weight, and <code class="reqn">\nu</code> a degrees of
freedom parameter. If <code>parametrization=="mean"</code>, just replace each intercept term <code class="reqn">\phi_{m,0}</code> with the regimewise mean
<code class="reqn">\mu_m = \phi_{m,0}/(1-\sum\phi_{i,m})</code>. In the <strong>G-StMAR</strong> model, the first <code>M1</code> components are <em>GMAR type</em>
and the rest <code>M2</code> components are <em>StMAR type</em>.
Note that in the case <strong>M=1</strong>, the mixing weight parameters <code class="reqn">\alpha</code> are dropped, and in the case of <strong>StMAR</strong> or <strong>G-StMAR</strong> model,
the degrees of freedom parameters <code class="reqn">\nu</code> have to be larger than <code class="reqn">2</code>.
If not specified (or <code>NULL</code> as is default), the initial population will be drawn randomly.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_regime_force_scale">regime_force_scale</code></td>
<td>
<p>a non-negative real number specifying how much should natural selection favor individuals
with less regimes that have almost all mixing weights (practically) at zero (see <code>red_criteria</code>), i.e., with
less &quot;redundant regimes&quot;.
Set to zero for no favoring or large number for heavy favoring. Without any favoring the genetic algorithm gets more often stuck
in an area of the parameter space where some regimes are wasted, but with too much favoring the best genes might never mix into the
population and the algorithm might converge poorly. Default is <code>1</code> and it gives <code class="reqn">2x</code> larger surviving probability weights for
individuals with no wasted regimes compared to individuals with one wasted regime. Number <code>2</code> would give <code class="reqn">3x</code> larger probabilities etc.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_red_criteria">red_criteria</code></td>
<td>
<p>a length 2 numeric vector specifying the criteria that is used to determine whether a regime is redundant or not.
Any regime <code>m</code> which satisfies <code>sum(mixing_weights[,m] &gt; red_criteria[1]) &lt; red_criteria[2]*n_obs</code> will be considered &quot;redundant&quot;.
One should be careful when adjusting this argument (set <code>c(0, 0)</code> to fully disable the 'redundant regime' features from the algorithm).</p>
</td></tr>
<tr><td><code id="GAfit_+3A_to_return">to_return</code></td>
<td>
<p>should the genetic algorithm return the best fitting individual which has the least &quot;redundant&quot; regimes (<code>"alt_ind"</code>)
or the individual which has the highest log-likelihood in general (<code>"best_ind"</code>) but might have more wasted regimes?</p>
</td></tr>
<tr><td><code id="GAfit_+3A_minval">minval</code></td>
<td>
<p>a real number defining the minimum value of the log-likelihood function that will be considered.
Values smaller than this will be treated as they were <code>minval</code> and the corresponding individuals will never survive.
The default is <code>-(10^(ceiling(log10(length(data))) + 1) - 1)</code>, and one should be very careful if adjusting this.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_seed">seed</code></td>
<td>
<p>a single value, interpreted as an integer, or NULL, that sets seed for the random number generator in the beginning of
the function call. If calling <code>GAfit</code> from <code>fitGSMAR</code>, use the argument <code>seeds</code> instead of passing the argument <code>seed</code>.</p>
</td></tr>
<tr><td><code id="GAfit_+3A_...">...</code></td>
<td>
<p>We currently use this to catch deprecated arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The core of the genetic algorithm is mostly based on the description by <em>Dorsey and Mayer (1995)</em>.
It utilizes a slightly modified version of the individually adaptive crossover and mutation rates described
by <em>Patnaik and Srinivas (1994)</em> and employs (50%) fitness inheritance discussed by <em>Smith, Dike and Stegmann (1995)</em>.
Large (in absolute value) but stationary AR parameter values are generated with the algorithm proposed by Monahan (1984).
</p>
<p>By &quot;redundant&quot; or &quot;wasted&quot; regimes we mean regimes that have the time varying mixing weights basically at zero for all t.
The model with redundant regimes would have approximately the same log-likelihood value without the redundant regimes
and there is no purpose to have redundant regimes in the model.
</p>


<h3>Value</h3>

<p>Returns estimated parameter vector with the form described in <code>initpop</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Dorsey R. E. and Mayer W. J. 1995. Genetic algorithms for estimation problems with multiple optima,
nondifferentiability, and other irregular features. <em>Journal of Business &amp; Economic Statistics</em>,
<strong>13</strong>, 53-66.
</p>

<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2015. Gaussian Mixture Autoregressive model for univariate time series.
<em>Journal of Time Series Analysis</em>, <strong>36</strong>(2), 247-266.
</p>
</li>
<li><p> Meitz M., Preve D., Saikkonen P. 2023. A mixture autoregressive model based on Student's t-distribution.
<em>Communications in Statistics - Theory and Methods</em>, <strong>52</strong>(2), 499-515.
</p>
</li>
<li><p> Monahan J.F. 1984. A Note on Enforcing Stationarity in Autoregressive-Moving Average Models.
<em>Biometrica</em> <strong>71</strong>, 403-404.
</p>
</li>
<li><p> Patnaik L.M. and Srinivas M. 1994. Adaptive Probabilities of Crossover and Mutation in Genetic Algorithms.
<em>Transactions on Systems, Man and Cybernetics</em> <strong>24</strong>, 656-667.
</p>
</li>
<li><p> Smith R.E., Dike B.A., Stegmann S.A. 1995. Fitness inheritance in genetic algorithms.
<em>Proceedings of the 1995 ACM Symposium on Applied Computing</em>, 345-350.
</p>
</li>
<li><p> Virolainen S. 2022. A mixture autoregressive model based on Gaussian and Student's t-distributions.
Studies in Nonlinear Dynamics &amp; Econometrics, <strong>26</strong>(4) 559-580.
</p>
</li></ul>

</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
## These are long running examples

# Preliminary estimation of GMAR p=1, M=2, model with the genetic algorithm
# using only 100 generations (200 is recommended):
pars12_ga &lt;- GAfit(data=simudata, p=1, M=2, model="GMAR", ngen=100, seed=1)
pars12_ga # Returns a parameter vector, not a class 'gsmar' object.

</code></pre>

<hr>
<h2 id='get_alpha_mt'>Get mixing weights alpha_mt (this function is for internal use)</h2><span id='topic+get_alpha_mt'></span>

<h3>Description</h3>

<p><code>get_alpha_mt</code> computes the mixing weights based on
the logarithm of the multivariate normal densities in the definition of
the mixing weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_alpha_mt(
  M,
  log_mvnvalues,
  alphas,
  epsilon,
  conditional,
  to_return,
  also_l_0 = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_alpha_mt_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMAR</strong> and <strong>StMAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMAR type</em> components <code>M1</code> in the
first element and <em>StMAR type</em> components <code>M2</code> in the second element. The total number of mixture components is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="get_alpha_mt_+3A_log_mvnvalues">log_mvnvalues</code></td>
<td>
<p><code class="reqn">T x M</code> matrix containing the log multivariate normal densities.</p>
</td></tr>
<tr><td><code id="get_alpha_mt_+3A_alphas">alphas</code></td>
<td>
<p><code class="reqn">M x 1</code> vector containing the mixing weight pa</p>
</td></tr>
<tr><td><code id="get_alpha_mt_+3A_epsilon">epsilon</code></td>
<td>
<p>the smallest number such that its exponent is wont classified as numerically zero
(around <code>-698</code> is used).</p>
</td></tr>
<tr><td><code id="get_alpha_mt_+3A_conditional">conditional</code></td>
<td>
<p>a logical argument specifying whether the conditional or exact log-likelihood function should be used.</p>
</td></tr>
<tr><td><code id="get_alpha_mt_+3A_to_return">to_return</code></td>
<td>
<p>should the returned object be the log-likelihood value, mixing weights, mixing weights including
value for <code class="reqn">alpha_{m,T+1}</code>, a list containing log-likelihood value and mixing weights, the terms <code class="reqn">l_{t}: t=1,..,T</code>
in the log-likelihood function (see <em>KMS 2015, eq.(13)</em>), the densities in the terms, regimewise conditional means,
regimewise conditional variances, total conditional means, total conditional variances, or quantile residuals?</p>
</td></tr>
<tr><td><code id="get_alpha_mt_+3A_also_l_0">also_l_0</code></td>
<td>
<p>return also l_0 (the first term in the exact log-likelihood function)?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that we index the time series as <code class="reqn">-p+1,...,0,1,...,T</code> as in Kalliovirta et al. (2015).
</p>


<h3>Value</h3>

<p>Returns the mixing weights a matrix of the same dimension as <code>log_mvnvalues</code> so
that the t:th row is for the time point t and m:th column is for the regime m.
</p>


<h3>References</h3>


<ul>
<li><p> Galbraith, R., Galbraith, J. 1974. On the inverses of some patterned matrices arising
in the theory of stationary time series. <em>Journal of Applied Probability</em> <strong>11</strong>, 63-71.
</p>
</li>
<li><p> Kalliovirta L. (2012) Misspecification tests based on quantile residuals.
<em>The Econometrics Journal</em>, <strong>15</strong>, 358-393.
</p>
</li>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2015. Gaussian Mixture Autoregressive model for univariate time series.
<em>Journal of Time Series Analysis</em>, <strong>36</strong>(2), 247-266.
</p>
</li>
<li><p> Meitz M., Preve D., Saikkonen P. 2023. A mixture autoregressive model based on Student's t-distribution.
<em>Communications in Statistics - Theory and Methods</em>, <strong>52</strong>(2), 499-515.
</p>
</li>
<li><p> Virolainen S. 2022. A mixture autoregressive model based on Gaussian and Student's t-distributions.
Studies in Nonlinear Dynamics &amp; Econometrics, <strong>26</strong>(4) 559-580.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+loglikelihood_int">loglikelihood_int</a></code>
</p>

<hr>
<h2 id='get_ar_roots'>Calculate absolute values of the roots of the AR characteristic polynomials</h2><span id='topic+get_ar_roots'></span>

<h3>Description</h3>

<p><code>get_ar_roots</code> calculates the absolute values of the roots of the AR
characteristic polynomials for each mixture component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ar_roots(gsmar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_ar_roots_+3A_gsmar">gsmar</code></td>
<td>
<p>a class 'gsmar' object, typically generated by <code>fitGSMAR</code> or <code>GSMAR</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with <code>M</code> elements each containing the absolute values of the roots
of the AR characteristic polynomial corresponding to each mixture component.
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2015. Gaussian Mixture Autoregressive model for univariate time series.
<em>Journal of Time Series Analysis</em>, <strong>36</strong>(2), 247-266.
</p>
</li>
<li><p> Meitz M., Preve D., Saikkonen P. 2023. A mixture autoregressive model based on Student's t-distribution.
<em>Communications in Statistics - Theory and Methods</em>, <strong>52</strong>(2), 499-515.
</p>
</li>
<li><p> Virolainen S. 2022. A mixture autoregressive model based on Gaussian and Student's t-distributions.
Studies in Nonlinear Dynamics &amp; Econometrics, <strong>26</strong>(4) 559-580.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>params12 &lt;- c(1.70, 0.85, 0.30, 4.12, 0.73, 1.98, 0.63)
gmar12 &lt;- GSMAR(data=simudata, p=1, M=2, params=params12, model="GMAR")
get_ar_roots(gmar12)
</code></pre>

<hr>
<h2 id='get_IC'>Calculate AIC, HQIC and BIC</h2><span id='topic+get_IC'></span>

<h3>Description</h3>

<p><code>get_IC</code> calculates AIC, HQIC and BIC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_IC(loglik, npars, obs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_IC_+3A_loglik">loglik</code></td>
<td>
<p>log-likelihood value</p>
</td></tr>
<tr><td><code id="get_IC_+3A_npars">npars</code></td>
<td>
<p>the number of (freely estimated) parameters in the model.</p>
</td></tr>
<tr><td><code id="get_IC_+3A_obs">obs</code></td>
<td>
<p>the number of observations with initial values excluded for conditional models.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame containing the information criteria values.
</p>

<hr>
<h2 id='get_minval'>Returns the default smallest allowed log-likelihood for given data.</h2><span id='topic+get_minval'></span>

<h3>Description</h3>

<p><code>get_minval</code> returns the default smallest allowed log-likelihood for given data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_minval(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_minval_+3A_data">data</code></td>
<td>
<p>a numeric vector or class <code>'ts'</code> object containing the data. <code>NA</code> values are not supported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function exists simply to avoid duplication inside the package.
</p>


<h3>Value</h3>

<p>Returns <code>-(10^(ceiling(log10(length(data))) + 1) - 1)</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitGSMAR">fitGSMAR</a></code>, <code><a href="#topic+GAfit">GAfit</a></code>
</p>

<hr>
<h2 id='get_regime_autocovs'>Calculate regime specific autocovariances <strong><code class="reqn">\gamma</code></strong><code class="reqn">_{m,p}</code></h2><span id='topic+get_regime_autocovs'></span>

<h3>Description</h3>

<p><code>get_regime_autocovs</code> calculates the first p regime specific autocovariances <strong><code class="reqn">\gamma</code></strong><code class="reqn">_{m,p}</code>
for the given GMAR, StMAR, or G-StMAR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_regime_autocovs(gsmar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_regime_autocovs_+3A_gsmar">gsmar</code></td>
<td>
<p>a class 'gsmar' object, typically generated by <code>fitGSMAR</code> or <code>GSMAR</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a size <code class="reqn">(pxM)</code> matrix containing the first p autocovariances of the components processes:
i:th autocovariance in the i:th row and m:th component process in the m:th column.
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2015. Gaussian Mixture Autoregressive model for univariate time series.
<em>Journal of Time Series Analysis</em>, <strong>36</strong>(2), 247-266.
</p>
</li>
<li><p> Meitz M., Preve D., Saikkonen P. 2023. A mixture autoregressive model based on Student's t-distribution.
<em>Communications in Statistics - Theory and Methods</em>, <strong>52</strong>(2), 499-515.
</p>
</li>
<li><p> Virolainen S. 2022. A mixture autoregressive model based on Gaussian and Student's t-distributions.
Studies in Nonlinear Dynamics &amp; Econometrics, <strong>26</strong>(4) 559-580.
</p>
</li>
<li><p> Ltkepohl H. 2005. New Introduction to Multiple Time Series Analysis. <em>Springer</em>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other moment functions: 
<code><a href="#topic+cond_moments">cond_moments</a>()</code>,
<code><a href="#topic+get_regime_means">get_regime_means</a>()</code>,
<code><a href="#topic+get_regime_vars">get_regime_vars</a>()</code>,
<code><a href="#topic+uncond_moments">uncond_moments</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># GMAR model
params13 &lt;- c(1.4, 0.88, 0.26, 2.46, 0.82, 0.74, 5.0, 0.68, 5.2, 0.72, 0.2)
gmar13 &lt;- GSMAR(p=1, M=3, params=params13, model="GMAR")
get_regime_autocovs(gmar13)

# StMAR model
params12t &lt;- c(1.38, 0.88, 0.27, 3.8, 0.74, 3.15, 0.8, 100, 3.6)
stmar12t &lt;- GSMAR(p=1, M=2, params=params12t, model="StMAR")
get_regime_autocovs(stmar12t)

# G-StMAR model (similar to the StMAR model above)
params12gs &lt;- c(1.38, 0.88, 0.27, 3.8, 0.74, 3.15, 0.8, 3.6)
gstmar12 &lt;- GSMAR(p=1, M=c(1, 1), params=params12gs, model="G-StMAR")
get_regime_autocovs(gstmar12)
</code></pre>

<hr>
<h2 id='get_regime_means'>Calculate regime specific means <code class="reqn">\mu_{m}</code></h2><span id='topic+get_regime_means'></span>

<h3>Description</h3>

<p><code>get_regime_means</code> calculates the regime means <code class="reqn">\mu_{m} = \phi_{m,0}/(1-\sum\phi_{i,m})</code>
for the given GMAR, StMAR, or G-StMAR model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_regime_means(gsmar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_regime_means_+3A_gsmar">gsmar</code></td>
<td>
<p>a class 'gsmar' object, typically generated by <code>fitGSMAR</code> or <code>GSMAR</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a length <code>M</code> vector containing the regime mean <code class="reqn">\mu_{m}</code> in the m:th element.
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2015. Gaussian Mixture Autoregressive model for univariate time series.
<em>Journal of Time Series Analysis</em>, <strong>36</strong>(2), 247-266.
</p>
</li>
<li><p> Meitz M., Preve D., Saikkonen P. 2023. A mixture autoregressive model based on Student's t-distribution.
<em>Communications in Statistics - Theory and Methods</em>, <strong>52</strong>(2), 499-515.
</p>
</li>
<li><p> Virolainen S. 2022. A mixture autoregressive model based on Gaussian and Student's t-distributions.
Studies in Nonlinear Dynamics &amp; Econometrics, <strong>26</strong>(4) 559-580.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+cond_moments">cond_moments</a></code>, <code><a href="#topic+uncond_moments">uncond_moments</a></code>, <code><a href="#topic+get_regime_vars">get_regime_vars</a></code>,
<code><a href="#topic+get_regime_autocovs">get_regime_autocovs</a></code>
</p>
<p>Other moment functions: 
<code><a href="#topic+cond_moments">cond_moments</a>()</code>,
<code><a href="#topic+get_regime_autocovs">get_regime_autocovs</a>()</code>,
<code><a href="#topic+get_regime_vars">get_regime_vars</a>()</code>,
<code><a href="#topic+uncond_moments">uncond_moments</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># GMAR model
params13 &lt;- c(1.4, 0.88, 0.26, 2.46, 0.82, 0.74, 5.0, 0.68, 5.2, 0.72, 0.2)
gmar13 &lt;- GSMAR(p=1, M=3, params=params13, model="GMAR")
get_regime_means(gmar13)

# StMAR model
params12t &lt;- c(1.38, 0.88, 0.27, 3.8, 0.74, 3.15, 0.8, 100, 3.6)
stmar12t &lt;- GSMAR(p=1, M=2, params=params12t, model="StMAR")
get_regime_means(stmar12t)

# G-StMAR model (similar to the StMAR model above)
params12gs &lt;- c(1.38, 0.88, 0.27, 3.8, 0.74, 3.15, 0.8, 3.6)
gstmar12 &lt;- GSMAR(p=1, M=c(1, 1), params=params12gs, model="G-StMAR")
get_regime_means(gstmar12)
</code></pre>

<hr>
<h2 id='get_regime_vars'>Calculate regime specific variances <code class="reqn">\gamma_{m,0}</code></h2><span id='topic+get_regime_vars'></span>

<h3>Description</h3>

<p><code>get_regime_vars</code> calculates the unconditional regime specific variances <code class="reqn">\gamma_{m,0}</code>
for the given GMAR, StMAR, or G-StMAR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_regime_vars(gsmar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_regime_vars_+3A_gsmar">gsmar</code></td>
<td>
<p>a class 'gsmar' object, typically generated by <code>fitGSMAR</code> or <code>GSMAR</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a length M vector containing the unconditional variances of the components processes:
m:th element for the m:th regime.
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2015. Gaussian Mixture Autoregressive model for univariate time series.
<em>Journal of Time Series Analysis</em>, <strong>36</strong>(2), 247-266.
</p>
</li>
<li><p> Meitz M., Preve D., Saikkonen P. 2023. A mixture autoregressive model based on Student's t-distribution.
<em>Communications in Statistics - Theory and Methods</em>, <strong>52</strong>(2), 499-515.
</p>
</li>
<li><p> Virolainen S. 2022. A mixture autoregressive model based on Gaussian and Student's t-distributions.
Studies in Nonlinear Dynamics &amp; Econometrics, <strong>26</strong>(4) 559-580.
</p>
</li>
<li><p> Ltkepohl H. 2005. New Introduction to Multiple Time Series Analysis. <em>Springer</em>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other moment functions: 
<code><a href="#topic+cond_moments">cond_moments</a>()</code>,
<code><a href="#topic+get_regime_autocovs">get_regime_autocovs</a>()</code>,
<code><a href="#topic+get_regime_means">get_regime_means</a>()</code>,
<code><a href="#topic+uncond_moments">uncond_moments</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># GMAR model
params13 &lt;- c(1.4, 0.88, 0.26, 2.46, 0.82, 0.74, 5.0, 0.68, 5.2, 0.72, 0.2)
gmar13 &lt;- GSMAR(p=1, M=3, params=params13, model="GMAR")
get_regime_vars(gmar13)

# StMAR model
params12t &lt;- c(1.38, 0.88, 0.27, 3.8, 0.74, 3.15, 0.8, 100, 3.6)
stmar12t &lt;- GSMAR(p=1, M=2, params=params12t, model="StMAR")
get_regime_vars(stmar12t)

# G-StMAR model (similar to the StMAR model above)
params12gs &lt;- c(1.38, 0.88, 0.27, 3.8, 0.74, 3.15, 0.8, 3.6)
gstmar12 &lt;- GSMAR(p=1, M=c(1, 1), params=params12gs, model="G-StMAR")
get_regime_vars(gstmar12)
</code></pre>

<hr>
<h2 id='get_test_Omega'>Generate the covariance matrix Omega for quantile residual tests</h2><span id='topic+get_test_Omega'></span>

<h3>Description</h3>

<p><code>get_test_Omega</code> generates the covariance matrix Omega used in the quantile residual tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_test_Omega(
  data,
  p,
  M,
  params,
  model = c("GMAR", "StMAR", "G-StMAR"),
  restricted = FALSE,
  constraints = NULL,
  parametrization = c("intercept", "mean"),
  g,
  dim_g
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_test_Omega_+3A_data">data</code></td>
<td>
<p>a numeric vector or class <code>'ts'</code> object containing the data. <code>NA</code> values are not supported.</p>
</td></tr>
<tr><td><code id="get_test_Omega_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="get_test_Omega_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMAR</strong> and <strong>StMAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMAR type</em> components <code>M1</code> in the
first element and <em>StMAR type</em> components <code>M2</code> in the second element. The total number of mixture components is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="get_test_Omega_+3A_params">params</code></td>
<td>
<p>a real valued parameter vector specifying the model.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(M(p+3)+M-M1-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=</code>(<strong><code class="reqn">\upsilon_{1}</code></strong><code class="reqn">,...,</code><strong><code class="reqn">\upsilon_{M}</code></strong>,
<code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>) where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn">=(\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,</code><code class="reqn">\sigma_{m}^2)</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p}), m=1,...,M</code>
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMAR type regimes.
</p>
</li></ul>

<p>In the <strong>GMAR</strong> model, <code class="reqn">M1=M</code> and the parameter <strong><code class="reqn">\nu</code></strong> dropped. In the <strong>StMAR</strong> model, <code class="reqn">M1=0</code>.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vectors <strong><code class="reqn">\phi_{m}</code></strong> with the vectors <strong><code class="reqn">\psi_{m}</code></strong> that satisfy
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(3M+M-M1+p-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=(\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">,</code>
<code class="reqn">\sigma_{1}^2,...,\sigma_{M}^2,</code><code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where <strong><code class="reqn">\phi</code></strong>=<code class="reqn">(\phi_{1},...,\phi_{p})</code>
contains the AR coefficients, which are common for all regimes.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vector <strong><code class="reqn">\phi</code></strong> with the vector <strong><code class="reqn">\psi</code></strong> that satisfies
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
</dl>

<p>Symbol <code class="reqn">\phi</code> denotes an AR coefficient, <code class="reqn">\sigma^2</code> a variance, <code class="reqn">\alpha</code> a mixing weight, and <code class="reqn">\nu</code> a degrees of
freedom parameter. If <code>parametrization=="mean"</code>, just replace each intercept term <code class="reqn">\phi_{m,0}</code> with the regimewise mean
<code class="reqn">\mu_m = \phi_{m,0}/(1-\sum\phi_{i,m})</code>. In the <strong>G-StMAR</strong> model, the first <code>M1</code> components are <em>GMAR type</em>
and the rest <code>M2</code> components are <em>StMAR type</em>.
Note that in the case <strong>M=1</strong>, the mixing weight parameters <code class="reqn">\alpha</code> are dropped, and in the case of <strong>StMAR</strong> or <strong>G-StMAR</strong> model,
the degrees of freedom parameters <code class="reqn">\nu</code> have to be larger than <code class="reqn">2</code>.</p>
</td></tr>
<tr><td><code id="get_test_Omega_+3A_model">model</code></td>
<td>
<p>is &quot;GMAR&quot;, &quot;StMAR&quot;, or &quot;G-StMAR&quot; model considered? In the G-StMAR model, the first <code>M1</code> components
are <em>GMAR type</em> and the rest <code>M2</code> components are <em>StMAR type</em>.</p>
</td></tr>
<tr><td><code id="get_test_Omega_+3A_restricted">restricted</code></td>
<td>
<p>a logical argument stating whether the AR coefficients <code class="reqn">\phi_{m,1},...,\phi_{m,p}</code> are restricted
to be the same for all regimes.</p>
</td></tr>
<tr><td><code id="get_test_Omega_+3A_constraints">constraints</code></td>
<td>
<p>specifies linear constraints imposed to each regime's autoregressive parameters separately.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd><p>a list of size <code class="reqn">(pxq_{m})</code> constraint matrices <strong><code class="reqn">C_{m}</code></strong> of full column rank
satisfying <strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> for all <code class="reqn">m=1,...,M</code>, where
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p})</code> and <strong><code class="reqn">\psi_{m}</code></strong><code class="reqn">=(\psi_{m,1},...,\psi_{m,q_{m}})</code>.</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd><p>a size <code class="reqn">(pxq)</code> constraint matrix <strong><code class="reqn">C</code></strong> of full column rank satisfying
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong>, where <strong><code class="reqn">\phi</code></strong><code class="reqn">=(\phi_{1},...,\phi_{p})</code> and
<strong><code class="reqn">\psi</code></strong><code class="reqn">=\psi_{1},...,\psi_{q}</code>.</p>
</dd>
</dl>

<p>The symbol <code class="reqn">\phi</code> denotes an AR coefficient. Note that regardless of any constraints, the autoregressive order
is always <code>p</code> for all regimes.
Ignore or set to <code>NULL</code> if applying linear constraints is not desired.</p>
</td></tr>
<tr><td><code id="get_test_Omega_+3A_parametrization">parametrization</code></td>
<td>
<p>is the model parametrized with the &quot;intercepts&quot; <code class="reqn">\phi_{m,0}</code> or
&quot;means&quot; <code class="reqn">\mu_{m} = \phi_{m,0}/(1-\sum\phi_{i,m})</code>?</p>
</td></tr>
<tr><td><code id="get_test_Omega_+3A_g">g</code></td>
<td>
<p>a function specifying the transformation.</p>
</td></tr>
<tr><td><code id="get_test_Omega_+3A_dim_g">dim_g</code></td>
<td>
<p>output dimension of the transformation <code>g</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used for quantile residuals tests in <code>quantile_residual_tests</code>.
</p>


<h3>Value</h3>

<p>Returns size (<code>dim_g</code>x<code>dim_g</code>) covariance matrix Omega.
</p>


<h3>References</h3>


<ul>
<li><p> Galbraith, R., Galbraith, J. 1974. On the inverses of some patterned matrices arising
in the theory of stationary time series. <em>Journal of Applied Probability</em> <strong>11</strong>, 63-71.
</p>
</li>
<li><p> Kalliovirta L. (2012) Misspecification tests based on quantile residuals.
<em>The Econometrics Journal</em>, <strong>15</strong>, 358-393.
</p>
</li>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2015. Gaussian Mixture Autoregressive model for univariate time series.
<em>Journal of Time Series Analysis</em>, <strong>36</strong>(2), 247-266.
</p>
</li>
<li><p> Meitz M., Preve D., Saikkonen P. 2023. A mixture autoregressive model based on Student's t-distribution.
<em>Communications in Statistics - Theory and Methods</em>, <strong>52</strong>(2), 499-515.
</p>
</li>
<li><p> Virolainen S. 2022. A mixture autoregressive model based on Gaussian and Student's t-distributions.
Studies in Nonlinear Dynamics &amp; Econometrics, <strong>26</strong>(4) 559-580.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+quantile_residual_tests">quantile_residual_tests</a></code>
</p>

<hr>
<h2 id='get_varying_h'>Get differences 'h' which are adjusted for overly large degrees of freedom parameters</h2><span id='topic+get_varying_h'></span>

<h3>Description</h3>

<p><code>get_varying_h</code> adjusts differences for overly large degrees of freedom parameters
for finite difference approximation of the derivatives of the log-likelihood function. StMAR and
G-StMAR models are supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_varying_h(p, M, params, model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_varying_h_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="get_varying_h_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMAR</strong> and <strong>StMAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMAR type</em> components <code>M1</code> in the
first element and <em>StMAR type</em> components <code>M2</code> in the second element. The total number of mixture components is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="get_varying_h_+3A_params">params</code></td>
<td>
<p>a real valued parameter vector specifying the model.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(M(p+3)+M-M1-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=</code>(<strong><code class="reqn">\upsilon_{1}</code></strong><code class="reqn">,...,</code><strong><code class="reqn">\upsilon_{M}</code></strong>,
<code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>) where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn">=(\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,</code><code class="reqn">\sigma_{m}^2)</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p}), m=1,...,M</code>
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMAR type regimes.
</p>
</li></ul>

<p>In the <strong>GMAR</strong> model, <code class="reqn">M1=M</code> and the parameter <strong><code class="reqn">\nu</code></strong> dropped. In the <strong>StMAR</strong> model, <code class="reqn">M1=0</code>.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vectors <strong><code class="reqn">\phi_{m}</code></strong> with the vectors <strong><code class="reqn">\psi_{m}</code></strong> that satisfy
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(3M+M-M1+p-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=(\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">,</code>
<code class="reqn">\sigma_{1}^2,...,\sigma_{M}^2,</code><code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where <strong><code class="reqn">\phi</code></strong>=<code class="reqn">(\phi_{1},...,\phi_{p})</code>
contains the AR coefficients, which are common for all regimes.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vector <strong><code class="reqn">\phi</code></strong> with the vector <strong><code class="reqn">\psi</code></strong> that satisfies
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
</dl>

<p>Symbol <code class="reqn">\phi</code> denotes an AR coefficient, <code class="reqn">\sigma^2</code> a variance, <code class="reqn">\alpha</code> a mixing weight, and <code class="reqn">\nu</code> a degrees of
freedom parameter. If <code>parametrization=="mean"</code>, just replace each intercept term <code class="reqn">\phi_{m,0}</code> with the regimewise mean
<code class="reqn">\mu_m = \phi_{m,0}/(1-\sum\phi_{i,m})</code>. In the <strong>G-StMAR</strong> model, the first <code>M1</code> components are <em>GMAR type</em>
and the rest <code>M2</code> components are <em>StMAR type</em>.
Note that in the case <strong>M=1</strong>, the mixing weight parameters <code class="reqn">\alpha</code> are dropped, and in the case of <strong>StMAR</strong> or <strong>G-StMAR</strong> model,
the degrees of freedom parameters <code class="reqn">\nu</code> have to be larger than <code class="reqn">2</code>.</p>
</td></tr>
<tr><td><code id="get_varying_h_+3A_model">model</code></td>
<td>
<p>is &quot;GMAR&quot;, &quot;StMAR&quot;, or &quot;G-StMAR&quot; model considered? In the G-StMAR model, the first <code>M1</code> components
are <em>GMAR type</em> and the rest <code>M2</code> components are <em>StMAR type</em>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used for approximating gradient and Hessian of a StMAR or G-StMAR model. Large
degrees of freedom parameters cause significant numerical error if too small differences are used.
</p>


<h3>Value</h3>

<p>Returns a vector with the same length as <code>params</code>. For other parameters than degrees
of freedom parameters larger than 100, the differences will be <code>6e-6</code>. For the large degrees of
freedom parameters, the difference will be <code>signif(df/1000, digits=2)</code>.
</p>

<hr>
<h2 id='GSMAR'>Create object of class 'gsmar' defining a GMAR, StMAR, or G-StMAR model</h2><span id='topic+GSMAR'></span><span id='topic+logLik.gsmar'></span><span id='topic+residuals.gsmar'></span><span id='topic+summary.gsmar'></span><span id='topic+plot.gsmar'></span><span id='topic+print.gsmar'></span>

<h3>Description</h3>

<p><code>GSMAR</code> creates an S3 object of class <code>'gsmar'</code> that defines a GMAR, StMAR, or G-StMAR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GSMAR(
  data,
  p,
  M,
  params,
  model = c("GMAR", "StMAR", "G-StMAR"),
  restricted = FALSE,
  constraints = NULL,
  conditional = TRUE,
  parametrization = c("intercept", "mean"),
  calc_qresiduals,
  calc_cond_moments,
  calc_std_errors = FALSE,
  custom_h = NULL
)

## S3 method for class 'gsmar'
logLik(object, ...)

## S3 method for class 'gsmar'
residuals(object, ...)

## S3 method for class 'gsmar'
summary(object, ..., digits = 2)

## S3 method for class 'gsmar'
plot(x, ..., include_dens = TRUE)

## S3 method for class 'gsmar'
print(x, ..., digits = 2, summary_print = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GSMAR_+3A_data">data</code></td>
<td>
<p>a numeric vector or class <code>'ts'</code> object containing the data. <code>NA</code> values are not supported.</p>
</td></tr>
<tr><td><code id="GSMAR_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="GSMAR_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMAR</strong> and <strong>StMAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMAR type</em> components <code>M1</code> in the
first element and <em>StMAR type</em> components <code>M2</code> in the second element. The total number of mixture components is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="GSMAR_+3A_params">params</code></td>
<td>
<p>a real valued parameter vector specifying the model.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(M(p+3)+M-M1-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=</code>(<strong><code class="reqn">\upsilon_{1}</code></strong><code class="reqn">,...,</code><strong><code class="reqn">\upsilon_{M}</code></strong>,
<code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>) where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn">=(\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,</code><code class="reqn">\sigma_{m}^2)</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p}), m=1,...,M</code>
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMAR type regimes.
</p>
</li></ul>

<p>In the <strong>GMAR</strong> model, <code class="reqn">M1=M</code> and the parameter <strong><code class="reqn">\nu</code></strong> dropped. In the <strong>StMAR</strong> model, <code class="reqn">M1=0</code>.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vectors <strong><code class="reqn">\phi_{m}</code></strong> with the vectors <strong><code class="reqn">\psi_{m}</code></strong> that satisfy
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(3M+M-M1+p-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=(\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">,</code>
<code class="reqn">\sigma_{1}^2,...,\sigma_{M}^2,</code><code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where <strong><code class="reqn">\phi</code></strong>=<code class="reqn">(\phi_{1},...,\phi_{p})</code>
contains the AR coefficients, which are common for all regimes.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vector <strong><code class="reqn">\phi</code></strong> with the vector <strong><code class="reqn">\psi</code></strong> that satisfies
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
</dl>

<p>Symbol <code class="reqn">\phi</code> denotes an AR coefficient, <code class="reqn">\sigma^2</code> a variance, <code class="reqn">\alpha</code> a mixing weight, and <code class="reqn">\nu</code> a degrees of
freedom parameter. If <code>parametrization=="mean"</code>, just replace each intercept term <code class="reqn">\phi_{m,0}</code> with the regimewise mean
<code class="reqn">\mu_m = \phi_{m,0}/(1-\sum\phi_{i,m})</code>. In the <strong>G-StMAR</strong> model, the first <code>M1</code> components are <em>GMAR type</em>
and the rest <code>M2</code> components are <em>StMAR type</em>.
Note that in the case <strong>M=1</strong>, the mixing weight parameters <code class="reqn">\alpha</code> are dropped, and in the case of <strong>StMAR</strong> or <strong>G-StMAR</strong> model,
the degrees of freedom parameters <code class="reqn">\nu</code> have to be larger than <code class="reqn">2</code>.</p>
</td></tr>
<tr><td><code id="GSMAR_+3A_model">model</code></td>
<td>
<p>is &quot;GMAR&quot;, &quot;StMAR&quot;, or &quot;G-StMAR&quot; model considered? In the G-StMAR model, the first <code>M1</code> components
are <em>GMAR type</em> and the rest <code>M2</code> components are <em>StMAR type</em>.</p>
</td></tr>
<tr><td><code id="GSMAR_+3A_restricted">restricted</code></td>
<td>
<p>a logical argument stating whether the AR coefficients <code class="reqn">\phi_{m,1},...,\phi_{m,p}</code> are restricted
to be the same for all regimes.</p>
</td></tr>
<tr><td><code id="GSMAR_+3A_constraints">constraints</code></td>
<td>
<p>specifies linear constraints imposed to each regime's autoregressive parameters separately.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd><p>a list of size <code class="reqn">(pxq_{m})</code> constraint matrices <strong><code class="reqn">C_{m}</code></strong> of full column rank
satisfying <strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> for all <code class="reqn">m=1,...,M</code>, where
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p})</code> and <strong><code class="reqn">\psi_{m}</code></strong><code class="reqn">=(\psi_{m,1},...,\psi_{m,q_{m}})</code>.</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd><p>a size <code class="reqn">(pxq)</code> constraint matrix <strong><code class="reqn">C</code></strong> of full column rank satisfying
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong>, where <strong><code class="reqn">\phi</code></strong><code class="reqn">=(\phi_{1},...,\phi_{p})</code> and
<strong><code class="reqn">\psi</code></strong><code class="reqn">=\psi_{1},...,\psi_{q}</code>.</p>
</dd>
</dl>

<p>The symbol <code class="reqn">\phi</code> denotes an AR coefficient. Note that regardless of any constraints, the autoregressive order
is always <code>p</code> for all regimes.
Ignore or set to <code>NULL</code> if applying linear constraints is not desired.</p>
</td></tr>
<tr><td><code id="GSMAR_+3A_conditional">conditional</code></td>
<td>
<p>a logical argument specifying whether the conditional or exact log-likelihood function should be used.</p>
</td></tr>
<tr><td><code id="GSMAR_+3A_parametrization">parametrization</code></td>
<td>
<p>is the model parametrized with the &quot;intercepts&quot; <code class="reqn">\phi_{m,0}</code> or
&quot;means&quot; <code class="reqn">\mu_{m} = \phi_{m,0}/(1-\sum\phi_{i,m})</code>?</p>
</td></tr>
<tr><td><code id="GSMAR_+3A_calc_qresiduals">calc_qresiduals</code></td>
<td>
<p>should quantile residuals be calculated? Default is <code>TRUE</code> iff the model contains data.</p>
</td></tr>
<tr><td><code id="GSMAR_+3A_calc_cond_moments">calc_cond_moments</code></td>
<td>
<p>should conditional means and variances be calculated? Default is <code>TRUE</code> iff the model contains data.</p>
</td></tr>
<tr><td><code id="GSMAR_+3A_calc_std_errors">calc_std_errors</code></td>
<td>
<p>should approximate standard errors be calculated?</p>
</td></tr>
<tr><td><code id="GSMAR_+3A_custom_h">custom_h</code></td>
<td>
<p>A numeric vector with same the length as the parameter vector: i:th element of custom_h is the difference
used in central difference approximation for partial differentials of the log-likelihood function for the i:th parameter.
If <code>NULL</code> (default), then the difference used for differentiating overly large degrees of freedom parameters
is adjusted to avoid numerical problems, and the difference is <code>6e-6</code> for the other parameters.</p>
</td></tr>
<tr><td><code id="GSMAR_+3A_object">object</code></td>
<td>
<p>object of class <code>'gsmar'</code> created with <code>fitGSMAR</code> or <code>GSMAR</code>.</p>
</td></tr>
<tr><td><code id="GSMAR_+3A_...">...</code></td>
<td>
<p>in the plot method: arguments passed to the function <code>density</code> which
calculates the kernel density estimate of the data.</p>
</td></tr>
<tr><td><code id="GSMAR_+3A_digits">digits</code></td>
<td>
<p>number of digits to be printed (max 20)</p>
</td></tr>
<tr><td><code id="GSMAR_+3A_x">x</code></td>
<td>
<p>object of class <code>'gsmar'</code> created with <code>fitGSMAR</code> or <code>GSMAR</code>.</p>
</td></tr>
<tr><td><code id="GSMAR_+3A_include_dens">include_dens</code></td>
<td>
<p>Plot also kernel density estimate of the data and model implied stationary
density with regimewise densities? See the details.</p>
</td></tr>
<tr><td><code id="GSMAR_+3A_summary_print">summary_print</code></td>
<td>
<p>if set to <code>TRUE</code> then the print will include approximate
standard errors for the estimates, log-likelihood, information criteria values,
modulus of the roots of the characteristic AR polynomials for each regime, and
several unconditional moments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Models can be built without data, e.q., in order to simulate from the process, but some things such as quantile
residuals and conditional moments can't be calculated without data.
</p>
<p>If <code>include_dens == TRUE</code>, the kernel density estimate of the data is calculated
with the function <code>density</code> from the package <code>stats</code>. By default, the default
settings of that function are used, including the usage of Gaussian kernel. Use the dot
parameters to adjust the settings if desired.
</p>
<p>By the model implied stationary density we mean the stationary one-dimensional mixture
density of M regimes (see KMS 2015, Theorem 1 and the discussion following it for the Gaussian
case and Theorem 2 in PMS 2018 for the Student's t case). The regimewise densities (i.e. each
density 1,...,M in the stationary mixture density) are multiplied with the mixing weight
parameters accordingly.
</p>
<p>In the density plot black represents the kernel density estimate of the data, grey dashed line the
model implied density, and the colored dotted lines the regime wise densities.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>'gsmar'</code> defining the specified GMAR, StMAR, or G-StMAR model. If data is supplied,
the returned object contains (by default) empirical mixing weights, some conditional and unconditional moments, and quantile
residuals. Note that the first p observations are taken as the initial values so the mixing weights, conditional moments, and
quantile residuals start from the p+1:th observation (interpreted as t=1).
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>logLik(gsmar)</code>: Log-likelihood method
</p>
</li>
<li> <p><code>residuals(gsmar)</code>: residuals method to extract quantile residuals
</p>
</li>
<li> <p><code>summary(gsmar)</code>: summary method, standard errors in brackets
</p>
</li>
<li> <p><code>plot(gsmar)</code>: Plot method for class 'gsmar'
</p>
</li>
<li> <p><code>print(gsmar)</code>: print method
</p>
</li></ul>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2015. Gaussian Mixture Autoregressive model for univariate time series.
<em>Journal of Time Series Analysis</em>, <strong>36</strong>(2), 247-266.
</p>
</li>
<li><p> Meitz M., Preve D., Saikkonen P. 2023. A mixture autoregressive model based on Student's t-distribution.
<em>Communications in Statistics - Theory and Methods</em>, <strong>52</strong>(2), 499-515.
</p>
</li>
<li><p> Virolainen S. 2022. A mixture autoregressive model based on Gaussian and Student's t-distributions.
Studies in Nonlinear Dynamics &amp; Econometrics, <strong>26</strong>(4) 559-580.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+fitGSMAR">fitGSMAR</a></code>, <code><a href="#topic+iterate_more">iterate_more</a></code>, <code><a href="#topic+add_data">add_data</a></code>, <code><a href="#topic+stmar_to_gstmar">stmar_to_gstmar</a></code>,
<code><a href="#topic+swap_parametrization">swap_parametrization</a></code>, <code><a href="#topic+get_gradient">get_gradient</a></code>, <code><a href="#topic+simulate.gsmar">simulate.gsmar</a></code>,
<code><a href="#topic+predict.gsmar">predict.gsmar</a></code>, <code><a href="#topic+cond_moments">cond_moments</a></code>, <code><a href="#topic+uncond_moments">uncond_moments</a></code>, <code><a href="#topic+LR_test">LR_test</a></code>, <code><a href="#topic+Wald_test">Wald_test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># GMAR model without data
params22 &lt;- c(0.9, 0.4, 0.2, 0.5, 0.7, 0.5, -0.2, 0.7, 0.7)
gmar22 &lt;- GSMAR(p=2, M=2, params=params22, model="GMAR")
gmar22

# StMAR model, without data
params12t &lt;- c(1.38, 0.88, 0.27, 3.8, 0.74, 3.15, 0.8, 300, 3.6)
stmar12t &lt;- GSMAR(p=1, M=2, params=params12t, model="StMAR")
stmar12t

# G-StMAR model with data
params42gs &lt;- c(0.04, 1.34, -0.59, 0.54, -0.36, 0.01, 0.06, 1.28, -0.36,
                0.2, -0.15, 0.04, 0.19, 9.75)
gstmar42 &lt;- GSMAR(data=M10Y1Y, p=4, M=c(1, 1), params=params42gs,
                  model="G-StMAR")
gstmar42

# Restricted G-StMAR model with data
params42gsr &lt;- c(0.13, 0.03, 1.29, -0.4, 0.25, -0.2, 0.03, 0.05, 0.51, 2.76)
gstmar42r &lt;- GSMAR(data=M10Y1Y, p=4, M=c(1, 1), params=params42gsr,
                   model="G-StMAR", restricted=TRUE)
gstmar42r
</code></pre>

<hr>
<h2 id='is_stationary'>Check the stationary condition of specified GMAR, StMAR, or G-StMAR model.</h2><span id='topic+is_stationary'></span>

<h3>Description</h3>

<p><code>is_stationary</code> checks the stationarity condition of the specified GMAR, StMAR, or G-StMAR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_stationary(
  p,
  M,
  params,
  model = c("GMAR", "StMAR", "G-StMAR"),
  restricted = FALSE,
  constraints = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_stationary_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="is_stationary_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMAR</strong> and <strong>StMAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMAR type</em> components <code>M1</code> in the
first element and <em>StMAR type</em> components <code>M2</code> in the second element. The total number of mixture components is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="is_stationary_+3A_params">params</code></td>
<td>
<p>a real valued parameter vector specifying the model.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(M(p+3)+M-M1-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=</code>(<strong><code class="reqn">\upsilon_{1}</code></strong><code class="reqn">,...,</code><strong><code class="reqn">\upsilon_{M}</code></strong>,
<code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>) where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn">=(\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,</code><code class="reqn">\sigma_{m}^2)</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p}), m=1,...,M</code>
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMAR type regimes.
</p>
</li></ul>

<p>In the <strong>GMAR</strong> model, <code class="reqn">M1=M</code> and the parameter <strong><code class="reqn">\nu</code></strong> dropped. In the <strong>StMAR</strong> model, <code class="reqn">M1=0</code>.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vectors <strong><code class="reqn">\phi_{m}</code></strong> with the vectors <strong><code class="reqn">\psi_{m}</code></strong> that satisfy
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(3M+M-M1+p-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=(\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">,</code>
<code class="reqn">\sigma_{1}^2,...,\sigma_{M}^2,</code><code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where <strong><code class="reqn">\phi</code></strong>=<code class="reqn">(\phi_{1},...,\phi_{p})</code>
contains the AR coefficients, which are common for all regimes.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vector <strong><code class="reqn">\phi</code></strong> with the vector <strong><code class="reqn">\psi</code></strong> that satisfies
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
</dl>

<p>Symbol <code class="reqn">\phi</code> denotes an AR coefficient, <code class="reqn">\sigma^2</code> a variance, <code class="reqn">\alpha</code> a mixing weight, and <code class="reqn">\nu</code> a degrees of
freedom parameter. If <code>parametrization=="mean"</code>, just replace each intercept term <code class="reqn">\phi_{m,0}</code> with the regimewise mean
<code class="reqn">\mu_m = \phi_{m,0}/(1-\sum\phi_{i,m})</code>. In the <strong>G-StMAR</strong> model, the first <code>M1</code> components are <em>GMAR type</em>
and the rest <code>M2</code> components are <em>StMAR type</em>.
Note that in the case <strong>M=1</strong>, the mixing weight parameters <code class="reqn">\alpha</code> are dropped, and in the case of <strong>StMAR</strong> or <strong>G-StMAR</strong> model,
the degrees of freedom parameters <code class="reqn">\nu</code> have to be larger than <code class="reqn">2</code>.</p>
</td></tr>
<tr><td><code id="is_stationary_+3A_model">model</code></td>
<td>
<p>is &quot;GMAR&quot;, &quot;StMAR&quot;, or &quot;G-StMAR&quot; model considered? In the G-StMAR model, the first <code>M1</code> components
are <em>GMAR type</em> and the rest <code>M2</code> components are <em>StMAR type</em>.</p>
</td></tr>
<tr><td><code id="is_stationary_+3A_restricted">restricted</code></td>
<td>
<p>a logical argument stating whether the AR coefficients <code class="reqn">\phi_{m,1},...,\phi_{m,p}</code> are restricted
to be the same for all regimes.</p>
</td></tr>
<tr><td><code id="is_stationary_+3A_constraints">constraints</code></td>
<td>
<p>specifies linear constraints imposed to each regime's autoregressive parameters separately.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd><p>a list of size <code class="reqn">(pxq_{m})</code> constraint matrices <strong><code class="reqn">C_{m}</code></strong> of full column rank
satisfying <strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> for all <code class="reqn">m=1,...,M</code>, where
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p})</code> and <strong><code class="reqn">\psi_{m}</code></strong><code class="reqn">=(\psi_{m,1},...,\psi_{m,q_{m}})</code>.</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd><p>a size <code class="reqn">(pxq)</code> constraint matrix <strong><code class="reqn">C</code></strong> of full column rank satisfying
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong>, where <strong><code class="reqn">\phi</code></strong><code class="reqn">=(\phi_{1},...,\phi_{p})</code> and
<strong><code class="reqn">\psi</code></strong><code class="reqn">=\psi_{1},...,\psi_{q}</code>.</p>
</dd>
</dl>

<p>The symbol <code class="reqn">\phi</code> denotes an AR coefficient. Note that regardless of any constraints, the autoregressive order
is always <code>p</code> for all regimes.
Ignore or set to <code>NULL</code> if applying linear constraints is not desired.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function falsely returns <code>FALSE</code> for stationary models when the parameter is extremely close
to the boundary of the stationarity region.
</p>


<h3>Value</h3>

<p>Returns <code>TRUE</code> or <code>FALSE</code> accordingly.
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2015. Gaussian Mixture Autoregressive model for univariate time series.
<em>Journal of Time Series Analysis</em>, <strong>36</strong>(2), 247-266.
</p>
</li>
<li><p> Meitz M., Preve D., Saikkonen P. 2023. A mixture autoregressive model based on Student's t-distribution.
<em>Communications in Statistics - Theory and Methods</em>, <strong>52</strong>(2), 499-515.
</p>
</li>
<li><p> Virolainen S. 2022. A mixture autoregressive model based on Gaussian and Student's t-distributions.
Studies in Nonlinear Dynamics &amp; Econometrics, <strong>26</strong>(4) 559-580.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># GMAR model
params22 &lt;- c(0.4, 0.39, 0.6, 0.3, 0.4, 0.1, 0.6, 0.3, 0.8)
is_stationary(p=2, M=2, params=params22)

# StMAR model
params12t &lt;- c(-0.3, 1, 0.9, 0.1, 0.8, 0.6, 0.7, 10, 12)
is_stationary(p=1, M=2, params=params12t, model="StMAR")

# G-StMAR model
params12gs &lt;- c(1, 0.1, 1, 2, 0.2, 2, 0.8, 20)
is_stationary(p=1, M=c(1, 1), params=params12gs, model="G-StMAR")

# Restricted GMAR model
params13r &lt;- c(0.1, 0.2, 0.3, -0.99, 0.1, 0.2, 0.3, 0.5, 0.3)
is_stationary(p=1, M=3, params=params13r, restricted=TRUE)

# Such StMAR(3, 2) that the AR coefficients are restricted to be the
# same for both regimes and that the second AR coefficients are
# constrained to zero.
params32trc &lt;- c(1, 2, 0.8, -0.3, 1, 2, 0.7, 11, 12)
is_stationary(p=3, M=2, params=params32trc, model="StMAR", restricted=TRUE,
              constraints=matrix(c(1, 0, 0, 0, 0, 1), ncol=2))
</code></pre>

<hr>
<h2 id='is_stationary_int'>Check the stationarity and identification conditions of specified GMAR, StMAR, or G-StMAR model.</h2><span id='topic+is_stationary_int'></span><span id='topic+is_identifiable'></span>

<h3>Description</h3>

<p><code>is_stationary_int</code> checks the stationarity condition and <code>is_identifiable</code> checks the identification condition
of the specified GMAR, StMAR, or G-StMAR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_stationary_int(p, M, params, restricted = FALSE)

is_identifiable(
  p,
  M,
  params,
  model = c("GMAR", "StMAR", "G-StMAR"),
  restricted = FALSE,
  constraints = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_stationary_int_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="is_stationary_int_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMAR</strong> and <strong>StMAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMAR type</em> components <code>M1</code> in the
first element and <em>StMAR type</em> components <code>M2</code> in the second element. The total number of mixture components is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="is_stationary_int_+3A_params">params</code></td>
<td>
<p>a real valued parameter vector specifying the model.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(M(p+3)+M-M1-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=</code>(<strong><code class="reqn">\upsilon_{1}</code></strong><code class="reqn">,...,</code><strong><code class="reqn">\upsilon_{M}</code></strong>,
<code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>) where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn">=(\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,</code><code class="reqn">\sigma_{m}^2)</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p}), m=1,...,M</code>
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMAR type regimes.
</p>
</li></ul>

<p>In the <strong>GMAR</strong> model, <code class="reqn">M1=M</code> and the parameter <strong><code class="reqn">\nu</code></strong> dropped. In the <strong>StMAR</strong> model, <code class="reqn">M1=0</code>.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vectors <strong><code class="reqn">\phi_{m}</code></strong> with the vectors <strong><code class="reqn">\psi_{m}</code></strong> that satisfy
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(3M+M-M1+p-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=(\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">,</code>
<code class="reqn">\sigma_{1}^2,...,\sigma_{M}^2,</code><code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where <strong><code class="reqn">\phi</code></strong>=<code class="reqn">(\phi_{1},...,\phi_{p})</code>
contains the AR coefficients, which are common for all regimes.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vector <strong><code class="reqn">\phi</code></strong> with the vector <strong><code class="reqn">\psi</code></strong> that satisfies
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
</dl>

<p>Symbol <code class="reqn">\phi</code> denotes an AR coefficient, <code class="reqn">\sigma^2</code> a variance, <code class="reqn">\alpha</code> a mixing weight, and <code class="reqn">\nu</code> a degrees of
freedom parameter. If <code>parametrization=="mean"</code>, just replace each intercept term <code class="reqn">\phi_{m,0}</code> with the regimewise mean
<code class="reqn">\mu_m = \phi_{m,0}/(1-\sum\phi_{i,m})</code>. In the <strong>G-StMAR</strong> model, the first <code>M1</code> components are <em>GMAR type</em>
and the rest <code>M2</code> components are <em>StMAR type</em>.
Note that in the case <strong>M=1</strong>, the mixing weight parameters <code class="reqn">\alpha</code> are dropped, and in the case of <strong>StMAR</strong> or <strong>G-StMAR</strong> model,
the degrees of freedom parameters <code class="reqn">\nu</code> have to be larger than <code class="reqn">2</code>.</p>
</td></tr>
<tr><td><code id="is_stationary_int_+3A_restricted">restricted</code></td>
<td>
<p>a logical argument stating whether the AR coefficients <code class="reqn">\phi_{m,1},...,\phi_{m,p}</code> are restricted
to be the same for all regimes.</p>
</td></tr>
<tr><td><code id="is_stationary_int_+3A_model">model</code></td>
<td>
<p>is &quot;GMAR&quot;, &quot;StMAR&quot;, or &quot;G-StMAR&quot; model considered? In the G-StMAR model, the first <code>M1</code> components
are <em>GMAR type</em> and the rest <code>M2</code> components are <em>StMAR type</em>.</p>
</td></tr>
<tr><td><code id="is_stationary_int_+3A_constraints">constraints</code></td>
<td>
<p>specifies linear constraints imposed to each regime's autoregressive parameters separately.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd><p>a list of size <code class="reqn">(pxq_{m})</code> constraint matrices <strong><code class="reqn">C_{m}</code></strong> of full column rank
satisfying <strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> for all <code class="reqn">m=1,...,M</code>, where
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p})</code> and <strong><code class="reqn">\psi_{m}</code></strong><code class="reqn">=(\psi_{m,1},...,\psi_{m,q_{m}})</code>.</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd><p>a size <code class="reqn">(pxq)</code> constraint matrix <strong><code class="reqn">C</code></strong> of full column rank satisfying
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong>, where <strong><code class="reqn">\phi</code></strong><code class="reqn">=(\phi_{1},...,\phi_{p})</code> and
<strong><code class="reqn">\psi</code></strong><code class="reqn">=\psi_{1},...,\psi_{q}</code>.</p>
</dd>
</dl>

<p>The symbol <code class="reqn">\phi</code> denotes an AR coefficient. Note that regardless of any constraints, the autoregressive order
is always <code>p</code> for all regimes.
Ignore or set to <code>NULL</code> if applying linear constraints is not desired.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>is_stationary_int</code> does not support models imposing linear constraints. In order to use it for a model imposing linear
constraints, one needs to expand the constraints first to obtain an unconstrained parameter vector.
</p>
<p>Note that <code>is_stationary_int</code> returns <code>FALSE</code> for stationary parameter vectors if they are extremely close to the boundary
of the stationarity region.
</p>
<p><code>is_identifiable</code> checks that the regimes are sorted according to the mixing weight parameters and that there are no duplicate
regimes.
</p>


<h3>Value</h3>

<p>Returns <code>TRUE</code> or <code>FALSE</code> accordingly.
</p>


<h3>Warning</h3>

<p>These functions don't have any argument checks!
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2015. Gaussian Mixture Autoregressive model for univariate time series.
<em>Journal of Time Series Analysis</em>, <strong>36</strong>(2), 247-266.
</p>
</li>
<li><p> Meitz M., Preve D., Saikkonen P. 2023. A mixture autoregressive model based on Student's t-distribution.
<em>Communications in Statistics - Theory and Methods</em>, <strong>52</strong>(2), 499-515.
</p>
</li>
<li><p> Virolainen S. 2022. A mixture autoregressive model based on Gaussian and Student's t-distributions.
Studies in Nonlinear Dynamics &amp; Econometrics, <strong>26</strong>(4) 559-580.
</p>
</li></ul>


<hr>
<h2 id='isStationary'>DEPRECATED, USE <code>is_stationary</code> INSTEAD! Check the stationary condition of specified GMAR, StMAR, or G-StMAR model.</h2><span id='topic+isStationary'></span>

<h3>Description</h3>

<p><code>isStationary</code> checks the stationarity condition of the specified GMAR, StMAR, or G-StMAR model.
DEPRECATED, USE <code>is_stationary</code> INSTEAD!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isStationary(
  p,
  M,
  params,
  model = c("GMAR", "StMAR", "G-StMAR"),
  restricted = FALSE,
  constraints = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isStationary_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="isStationary_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMAR</strong> and <strong>StMAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMAR type</em> components <code>M1</code> in the
first element and <em>StMAR type</em> components <code>M2</code> in the second element. The total number of mixture components is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="isStationary_+3A_params">params</code></td>
<td>
<p>a real valued parameter vector specifying the model.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(M(p+3)+M-M1-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=</code>(<strong><code class="reqn">\upsilon_{1}</code></strong><code class="reqn">,...,</code><strong><code class="reqn">\upsilon_{M}</code></strong>,
<code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>) where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn">=(\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,</code><code class="reqn">\sigma_{m}^2)</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p}), m=1,...,M</code>
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMAR type regimes.
</p>
</li></ul>

<p>In the <strong>GMAR</strong> model, <code class="reqn">M1=M</code> and the parameter <strong><code class="reqn">\nu</code></strong> dropped. In the <strong>StMAR</strong> model, <code class="reqn">M1=0</code>.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vectors <strong><code class="reqn">\phi_{m}</code></strong> with the vectors <strong><code class="reqn">\psi_{m}</code></strong> that satisfy
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(3M+M-M1+p-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=(\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">,</code>
<code class="reqn">\sigma_{1}^2,...,\sigma_{M}^2,</code><code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where <strong><code class="reqn">\phi</code></strong>=<code class="reqn">(\phi_{1},...,\phi_{p})</code>
contains the AR coefficients, which are common for all regimes.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vector <strong><code class="reqn">\phi</code></strong> with the vector <strong><code class="reqn">\psi</code></strong> that satisfies
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
</dl>

<p>Symbol <code class="reqn">\phi</code> denotes an AR coefficient, <code class="reqn">\sigma^2</code> a variance, <code class="reqn">\alpha</code> a mixing weight, and <code class="reqn">\nu</code> a degrees of
freedom parameter. If <code>parametrization=="mean"</code>, just replace each intercept term <code class="reqn">\phi_{m,0}</code> with the regimewise mean
<code class="reqn">\mu_m = \phi_{m,0}/(1-\sum\phi_{i,m})</code>. In the <strong>G-StMAR</strong> model, the first <code>M1</code> components are <em>GMAR type</em>
and the rest <code>M2</code> components are <em>StMAR type</em>.
Note that in the case <strong>M=1</strong>, the mixing weight parameters <code class="reqn">\alpha</code> are dropped, and in the case of <strong>StMAR</strong> or <strong>G-StMAR</strong> model,
the degrees of freedom parameters <code class="reqn">\nu</code> have to be larger than <code class="reqn">2</code>.</p>
</td></tr>
<tr><td><code id="isStationary_+3A_model">model</code></td>
<td>
<p>is &quot;GMAR&quot;, &quot;StMAR&quot;, or &quot;G-StMAR&quot; model considered? In the G-StMAR model, the first <code>M1</code> components
are <em>GMAR type</em> and the rest <code>M2</code> components are <em>StMAR type</em>.</p>
</td></tr>
<tr><td><code id="isStationary_+3A_restricted">restricted</code></td>
<td>
<p>a logical argument stating whether the AR coefficients <code class="reqn">\phi_{m,1},...,\phi_{m,p}</code> are restricted
to be the same for all regimes.</p>
</td></tr>
<tr><td><code id="isStationary_+3A_constraints">constraints</code></td>
<td>
<p>specifies linear constraints imposed to each regime's autoregressive parameters separately.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd><p>a list of size <code class="reqn">(pxq_{m})</code> constraint matrices <strong><code class="reqn">C_{m}</code></strong> of full column rank
satisfying <strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> for all <code class="reqn">m=1,...,M</code>, where
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p})</code> and <strong><code class="reqn">\psi_{m}</code></strong><code class="reqn">=(\psi_{m,1},...,\psi_{m,q_{m}})</code>.</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd><p>a size <code class="reqn">(pxq)</code> constraint matrix <strong><code class="reqn">C</code></strong> of full column rank satisfying
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong>, where <strong><code class="reqn">\phi</code></strong><code class="reqn">=(\phi_{1},...,\phi_{p})</code> and
<strong><code class="reqn">\psi</code></strong><code class="reqn">=\psi_{1},...,\psi_{q}</code>.</p>
</dd>
</dl>

<p>The symbol <code class="reqn">\phi</code> denotes an AR coefficient. Note that regardless of any constraints, the autoregressive order
is always <code>p</code> for all regimes.
Ignore or set to <code>NULL</code> if applying linear constraints is not desired.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>DEPRECATED, USE <code>is_stationary</code> INSTEAD!
This function falsely returns <code>FALSE</code> for stationary models when the parameter is extremely close
to the boundary of the stationarity region.
</p>


<h3>Value</h3>

<p>Returns <code>TRUE</code> or <code>FALSE</code> accordingly.
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2015. Gaussian Mixture Autoregressive model for univariate time series.
<em>Journal of Time Series Analysis</em>, <strong>36</strong>(2), 247-266.
</p>
</li>
<li><p> Meitz M., Preve D., Saikkonen P. 2023. A mixture autoregressive model based on Student's t-distribution.
<em>Communications in Statistics - Theory and Methods</em>, <strong>52</strong>(2), 499-515.
</p>
</li>
<li><p> Virolainen S. 2022. A mixture autoregressive model based on Gaussian and Student's t-distributions.
Studies in Nonlinear Dynamics &amp; Econometrics, <strong>26</strong>(4) 559-580.
</p>
</li></ul>


<hr>
<h2 id='iterate_more'>Maximum likelihood estimation of GMAR, StMAR, or G-StMAR model with preliminary estimates</h2><span id='topic+iterate_more'></span>

<h3>Description</h3>

<p><code>iterate_more</code> uses a variable metric algorithm to finalize maximum likelihood
estimation of a GMAR, StMAR or G-StMAR model (object of class <code>'gsmar'</code>) which already has
preliminary estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iterate_more(gsmar, maxit = 100, custom_h = NULL, calc_std_errors = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iterate_more_+3A_gsmar">gsmar</code></td>
<td>
<p>a class 'gsmar' object, typically generated by <code>fitGSMAR</code> or <code>GSMAR</code>.</p>
</td></tr>
<tr><td><code id="iterate_more_+3A_maxit">maxit</code></td>
<td>
<p>the maximum number of iterations for the variable metric algorithm.</p>
</td></tr>
<tr><td><code id="iterate_more_+3A_custom_h">custom_h</code></td>
<td>
<p>A numeric vector with same the length as the parameter vector: i:th element of custom_h is the difference
used in central difference approximation for partial differentials of the log-likelihood function for the i:th parameter.
If <code>NULL</code> (default), then the difference used for differentiating overly large degrees of freedom parameters
is adjusted to avoid numerical problems, and the difference is <code>6e-6</code> for the other parameters.</p>
</td></tr>
<tr><td><code id="iterate_more_+3A_calc_std_errors">calc_std_errors</code></td>
<td>
<p>should approximate standard errors be calculated?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main purpose of <code>iterate_more</code> is to provide a simple and convenient tool to finalize
the estimation when the maximum number of iterations is reached when estimating a model with the
main estimation function <code>fitGSMAR</code>. <code>iterate_more</code> is essentially a wrapper for the functions
<code>optim</code> from the package <code>stats</code> and <code>GSMAR</code> from the package <code>uGMAR</code>.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>'gsmar'</code> defining the estimated model.
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2015. Gaussian Mixture Autoregressive model for univariate time series.
<em>Journal of Time Series Analysis</em>, <strong>36</strong>(2), 247-266.
</p>
</li>
<li><p> Meitz M., Preve D., Saikkonen P. 2023. A mixture autoregressive model based on Student's t-distribution.
<em>Communications in Statistics - Theory and Methods</em>, <strong>52</strong>(2), 499-515.
</p>
</li>
<li><p> Virolainen S. 2022. A mixture autoregressive model based on Gaussian and Student's t-distributions.
Studies in Nonlinear Dynamics &amp; Econometrics, <strong>26</strong>(4) 559-580.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+fitGSMAR">fitGSMAR</a></code>, <code><a href="#topic+GSMAR">GSMAR</a></code>, <code><a href="#topic+stmar_to_gstmar">stmar_to_gstmar</a></code>,
<code><a href="#topic+profile_logliks">profile_logliks</a></code>, <code><a href="stats.html#topic+optim">optim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Estimate GMAR model with on only 1 iteration in variable metric algorithm
fit12 &lt;- fitGSMAR(simudata, p=1, M=2, maxit=1, ncalls=1, seeds=1)
fit12

# Iterate more since iteration limit was reached
fit12 &lt;- iterate_more(fit12)
fit12

</code></pre>

<hr>
<h2 id='loglikelihood'>Compute the log-likelihood of GMAR, StMAR, or G-StMAR model</h2><span id='topic+loglikelihood'></span>

<h3>Description</h3>

<p><code>loglikelihood</code> computes the log-likelihood of the specified GMAR, StMAR, or G-StMAR model.
Exists for convenience if one wants to for example plot profile log-likelihoods or employ other estimation algorithms.
Use <code>minval</code> to control what happens when the parameter vector is outside the parameter space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglikelihood(
  data,
  p,
  M,
  params,
  model = c("GMAR", "StMAR", "G-StMAR"),
  restricted = FALSE,
  constraints = NULL,
  conditional = TRUE,
  parametrization = c("intercept", "mean"),
  return_terms = FALSE,
  minval = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loglikelihood_+3A_data">data</code></td>
<td>
<p>a numeric vector or class <code>'ts'</code> object containing the data. <code>NA</code> values are not supported.</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMAR</strong> and <strong>StMAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMAR type</em> components <code>M1</code> in the
first element and <em>StMAR type</em> components <code>M2</code> in the second element. The total number of mixture components is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="loglikelihood_+3A_params">params</code></td>
<td>
<p>a real valued parameter vector specifying the model.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(M(p+3)+M-M1-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=</code>(<strong><code class="reqn">\upsilon_{1}</code></strong><code class="reqn">,...,</code><strong><code class="reqn">\upsilon_{M}</code></strong>,
<code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>) where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn">=(\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,</code><code class="reqn">\sigma_{m}^2)</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p}), m=1,...,M</code>
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMAR type regimes.
</p>
</li></ul>

<p>In the <strong>GMAR</strong> model, <code class="reqn">M1=M</code> and the parameter <strong><code class="reqn">\nu</code></strong> dropped. In the <strong>StMAR</strong> model, <code class="reqn">M1=0</code>.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vectors <strong><code class="reqn">\phi_{m}</code></strong> with the vectors <strong><code class="reqn">\psi_{m}</code></strong> that satisfy
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(3M+M-M1+p-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=(\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">,</code>
<code class="reqn">\sigma_{1}^2,...,\sigma_{M}^2,</code><code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where <strong><code class="reqn">\phi</code></strong>=<code class="reqn">(\phi_{1},...,\phi_{p})</code>
contains the AR coefficients, which are common for all regimes.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vector <strong><code class="reqn">\phi</code></strong> with the vector <strong><code class="reqn">\psi</code></strong> that satisfies
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
</dl>

<p>Symbol <code class="reqn">\phi</code> denotes an AR coefficient, <code class="reqn">\sigma^2</code> a variance, <code class="reqn">\alpha</code> a mixing weight, and <code class="reqn">\nu</code> a degrees of
freedom parameter. If <code>parametrization=="mean"</code>, just replace each intercept term <code class="reqn">\phi_{m,0}</code> with the regimewise mean
<code class="reqn">\mu_m = \phi_{m,0}/(1-\sum\phi_{i,m})</code>. In the <strong>G-StMAR</strong> model, the first <code>M1</code> components are <em>GMAR type</em>
and the rest <code>M2</code> components are <em>StMAR type</em>.
Note that in the case <strong>M=1</strong>, the mixing weight parameters <code class="reqn">\alpha</code> are dropped, and in the case of <strong>StMAR</strong> or <strong>G-StMAR</strong> model,
the degrees of freedom parameters <code class="reqn">\nu</code> have to be larger than <code class="reqn">2</code>.</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_model">model</code></td>
<td>
<p>is &quot;GMAR&quot;, &quot;StMAR&quot;, or &quot;G-StMAR&quot; model considered? In the G-StMAR model, the first <code>M1</code> components
are <em>GMAR type</em> and the rest <code>M2</code> components are <em>StMAR type</em>.</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_restricted">restricted</code></td>
<td>
<p>a logical argument stating whether the AR coefficients <code class="reqn">\phi_{m,1},...,\phi_{m,p}</code> are restricted
to be the same for all regimes.</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_constraints">constraints</code></td>
<td>
<p>specifies linear constraints imposed to each regime's autoregressive parameters separately.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd><p>a list of size <code class="reqn">(pxq_{m})</code> constraint matrices <strong><code class="reqn">C_{m}</code></strong> of full column rank
satisfying <strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> for all <code class="reqn">m=1,...,M</code>, where
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p})</code> and <strong><code class="reqn">\psi_{m}</code></strong><code class="reqn">=(\psi_{m,1},...,\psi_{m,q_{m}})</code>.</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd><p>a size <code class="reqn">(pxq)</code> constraint matrix <strong><code class="reqn">C</code></strong> of full column rank satisfying
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong>, where <strong><code class="reqn">\phi</code></strong><code class="reqn">=(\phi_{1},...,\phi_{p})</code> and
<strong><code class="reqn">\psi</code></strong><code class="reqn">=\psi_{1},...,\psi_{q}</code>.</p>
</dd>
</dl>

<p>The symbol <code class="reqn">\phi</code> denotes an AR coefficient. Note that regardless of any constraints, the autoregressive order
is always <code>p</code> for all regimes.
Ignore or set to <code>NULL</code> if applying linear constraints is not desired.</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_conditional">conditional</code></td>
<td>
<p>a logical argument specifying whether the conditional or exact log-likelihood function should be used.</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_parametrization">parametrization</code></td>
<td>
<p>is the model parametrized with the &quot;intercepts&quot; <code class="reqn">\phi_{m,0}</code> or
&quot;means&quot; <code class="reqn">\mu_{m} = \phi_{m,0}/(1-\sum\phi_{i,m})</code>?</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_return_terms">return_terms</code></td>
<td>
<p>should the terms <code class="reqn">l_{t}: t=1,..,T</code> in the log-likelihood function (see <em>KMS 2015, eq.(13)</em>
or MPS 2018, eq.(15)) be returned instead of the log-likelihood value?</p>
</td></tr>
<tr><td><code id="loglikelihood_+3A_minval">minval</code></td>
<td>
<p>this will be returned when the parameter vector is outside the parameter space and <code>boundaries==TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the log-likelihood value or the terms described in <code>return_terms</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Galbraith, R., Galbraith, J. 1974. On the inverses of some patterned matrices arising
in the theory of stationary time series. <em>Journal of Applied Probability</em> <strong>11</strong>, 63-71.
</p>
</li>
<li><p> Kalliovirta L. (2012) Misspecification tests based on quantile residuals.
<em>The Econometrics Journal</em>, <strong>15</strong>, 358-393.
</p>
</li>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2015. Gaussian Mixture Autoregressive model for univariate time series.
<em>Journal of Time Series Analysis</em>, <strong>36</strong>(2), 247-266.
</p>
</li>
<li><p> Meitz M., Preve D., Saikkonen P. 2023. A mixture autoregressive model based on Student's t-distribution.
<em>Communications in Statistics - Theory and Methods</em>, <strong>52</strong>(2), 499-515.
</p>
</li>
<li><p> Virolainen S. 2022. A mixture autoregressive model based on Gaussian and Student's t-distributions.
Studies in Nonlinear Dynamics &amp; Econometrics, <strong>26</strong>(4) 559-580.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+fitGSMAR">fitGSMAR</a></code>, <code><a href="#topic+GSMAR">GSMAR</a></code>, <code><a href="#topic+quantile_residuals">quantile_residuals</a></code>,
<code><a href="#topic+mixing_weights">mixing_weights</a></code>, <code><a href="#topic+calc_gradient">calc_gradient</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># GMAR model
params12 &lt;- c(1.70, 0.85, 0.30, 4.12, 0.73, 1.98, 0.63)
loglikelihood(simudata, p=1, M=2, params=params12, model="GMAR")

# G-StMAR-model
params42gs &lt;- c(0.04, 1.34, -0.59, 0.54, -0.36, 0.01, 0.06, 1.28, -0.36,
                0.2, -0.15, 0.04, 0.19, 9.75)
loglikelihood(M10Y1Y, p=4, M=c(1, 1), params=params42gs, model="G-StMAR")
</code></pre>

<hr>
<h2 id='loglikelihood_int'>Compute the log-likelihood of GMAR, StMAR, or G-StMAR model</h2><span id='topic+loglikelihood_int'></span>

<h3>Description</h3>

<p><code>loglikelihood_int</code> computes the log-likelihood of the specified GMAR, StMAR, or G-StMAR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglikelihood_int(
  data,
  p,
  M,
  params,
  model = c("GMAR", "StMAR", "G-StMAR"),
  restricted = FALSE,
  constraints = NULL,
  conditional = TRUE,
  parametrization = c("intercept", "mean"),
  boundaries = TRUE,
  checks = TRUE,
  to_return = c("loglik", "mw", "mw_tplus1", "loglik_and_mw", "terms", "term_densities",
    "regime_cmeans", "regime_cvars", "total_cmeans", "total_cvars", "qresiduals"),
  minval
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loglikelihood_int_+3A_data">data</code></td>
<td>
<p>a numeric vector or class <code>'ts'</code> object containing the data. <code>NA</code> values are not supported.</p>
</td></tr>
<tr><td><code id="loglikelihood_int_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="loglikelihood_int_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMAR</strong> and <strong>StMAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMAR type</em> components <code>M1</code> in the
first element and <em>StMAR type</em> components <code>M2</code> in the second element. The total number of mixture components is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="loglikelihood_int_+3A_params">params</code></td>
<td>
<p>a real valued parameter vector specifying the model.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(M(p+3)+M-M1-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=</code>(<strong><code class="reqn">\upsilon_{1}</code></strong><code class="reqn">,...,</code><strong><code class="reqn">\upsilon_{M}</code></strong>,
<code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>) where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn">=(\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,</code><code class="reqn">\sigma_{m}^2)</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p}), m=1,...,M</code>
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMAR type regimes.
</p>
</li></ul>

<p>In the <strong>GMAR</strong> model, <code class="reqn">M1=M</code> and the parameter <strong><code class="reqn">\nu</code></strong> dropped. In the <strong>StMAR</strong> model, <code class="reqn">M1=0</code>.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vectors <strong><code class="reqn">\phi_{m}</code></strong> with the vectors <strong><code class="reqn">\psi_{m}</code></strong> that satisfy
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(3M+M-M1+p-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=(\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">,</code>
<code class="reqn">\sigma_{1}^2,...,\sigma_{M}^2,</code><code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where <strong><code class="reqn">\phi</code></strong>=<code class="reqn">(\phi_{1},...,\phi_{p})</code>
contains the AR coefficients, which are common for all regimes.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vector <strong><code class="reqn">\phi</code></strong> with the vector <strong><code class="reqn">\psi</code></strong> that satisfies
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
</dl>

<p>Symbol <code class="reqn">\phi</code> denotes an AR coefficient, <code class="reqn">\sigma^2</code> a variance, <code class="reqn">\alpha</code> a mixing weight, and <code class="reqn">\nu</code> a degrees of
freedom parameter. If <code>parametrization=="mean"</code>, just replace each intercept term <code class="reqn">\phi_{m,0}</code> with the regimewise mean
<code class="reqn">\mu_m = \phi_{m,0}/(1-\sum\phi_{i,m})</code>. In the <strong>G-StMAR</strong> model, the first <code>M1</code> components are <em>GMAR type</em>
and the rest <code>M2</code> components are <em>StMAR type</em>.
Note that in the case <strong>M=1</strong>, the mixing weight parameters <code class="reqn">\alpha</code> are dropped, and in the case of <strong>StMAR</strong> or <strong>G-StMAR</strong> model,
the degrees of freedom parameters <code class="reqn">\nu</code> have to be larger than <code class="reqn">2</code>.</p>
</td></tr>
<tr><td><code id="loglikelihood_int_+3A_model">model</code></td>
<td>
<p>is &quot;GMAR&quot;, &quot;StMAR&quot;, or &quot;G-StMAR&quot; model considered? In the G-StMAR model, the first <code>M1</code> components
are <em>GMAR type</em> and the rest <code>M2</code> components are <em>StMAR type</em>.</p>
</td></tr>
<tr><td><code id="loglikelihood_int_+3A_restricted">restricted</code></td>
<td>
<p>a logical argument stating whether the AR coefficients <code class="reqn">\phi_{m,1},...,\phi_{m,p}</code> are restricted
to be the same for all regimes.</p>
</td></tr>
<tr><td><code id="loglikelihood_int_+3A_constraints">constraints</code></td>
<td>
<p>specifies linear constraints imposed to each regime's autoregressive parameters separately.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd><p>a list of size <code class="reqn">(pxq_{m})</code> constraint matrices <strong><code class="reqn">C_{m}</code></strong> of full column rank
satisfying <strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> for all <code class="reqn">m=1,...,M</code>, where
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p})</code> and <strong><code class="reqn">\psi_{m}</code></strong><code class="reqn">=(\psi_{m,1},...,\psi_{m,q_{m}})</code>.</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd><p>a size <code class="reqn">(pxq)</code> constraint matrix <strong><code class="reqn">C</code></strong> of full column rank satisfying
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong>, where <strong><code class="reqn">\phi</code></strong><code class="reqn">=(\phi_{1},...,\phi_{p})</code> and
<strong><code class="reqn">\psi</code></strong><code class="reqn">=\psi_{1},...,\psi_{q}</code>.</p>
</dd>
</dl>

<p>The symbol <code class="reqn">\phi</code> denotes an AR coefficient. Note that regardless of any constraints, the autoregressive order
is always <code>p</code> for all regimes.
Ignore or set to <code>NULL</code> if applying linear constraints is not desired.</p>
</td></tr>
<tr><td><code id="loglikelihood_int_+3A_conditional">conditional</code></td>
<td>
<p>a logical argument specifying whether the conditional or exact log-likelihood function should be used.</p>
</td></tr>
<tr><td><code id="loglikelihood_int_+3A_parametrization">parametrization</code></td>
<td>
<p>is the model parametrized with the &quot;intercepts&quot; <code class="reqn">\phi_{m,0}</code> or
&quot;means&quot; <code class="reqn">\mu_{m} = \phi_{m,0}/(1-\sum\phi_{i,m})</code>?</p>
</td></tr>
<tr><td><code id="loglikelihood_int_+3A_boundaries">boundaries</code></td>
<td>
<p>a logical argument. If <code>TRUE</code>, then <code>loglikelihood</code> returns <code>minval</code> if...
</p>

<ul>
<li><p> some component variance is not larger than zero,
</p>
</li>
<li><p> some parametrized mixing weight <code class="reqn">\alpha_{1},...,\alpha_{M-1}</code> is not larger than zero,
</p>
</li>
<li><p> sum of the parametrized mixing weights is not smaller than one,
</p>
</li>
<li><p> if the model is not stationary,
</p>
</li>
<li><p> or if <code>model=="StMAR"</code> or <code>model=="G-StMAR"</code> and some degrees of freedom parameter <code class="reqn">\nu_{m}</code> is not larger than two.
</p>
</li></ul>

<p>Argument <code>minval</code> will be used only if <code>boundaries==TRUE</code>.</p>
</td></tr>
<tr><td><code id="loglikelihood_int_+3A_checks">checks</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> specifying whether argument checks, such as stationarity checks, should be done.</p>
</td></tr>
<tr><td><code id="loglikelihood_int_+3A_to_return">to_return</code></td>
<td>
<p>should the returned object be the log-likelihood value, mixing weights, mixing weights including
value for <code class="reqn">alpha_{m,T+1}</code>, a list containing log-likelihood value and mixing weights, the terms <code class="reqn">l_{t}: t=1,..,T</code>
in the log-likelihood function (see <em>KMS 2015, eq.(13)</em>), the densities in the terms, regimewise conditional means,
regimewise conditional variances, total conditional means, total conditional variances, or quantile residuals?</p>
</td></tr>
<tr><td><code id="loglikelihood_int_+3A_minval">minval</code></td>
<td>
<p>this will be returned when the parameter vector is outside the parameter space and <code>boundaries==TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Note that the first p observations are taken as the initial values so the mixing weights and conditional moments start
from the p+1:th observation (interpreted as t=1).
</p>

<dl>
<dt>By default:</dt><dd><p>log-likelihood value of the specified model,</p>
</dd>
<dt>If <code>to_return=="mw"</code>:</dt><dd><p>a size ((n_obs-p)xM) matrix containing the mixing weights: for m:th component in the m:th column.</p>
</dd>
<dt>If <code>to_return=="mw_tplus1"</code>:</dt><dd><p>a size ((n_obs-p+1)xM) matrix containing the mixing weights: for m:th component in the m:th column.
The last row is for <code class="reqn">\alpha_{m,T+1}</code>.</p>
</dd>
<dt>If <code>to_return=="loglik_and_mw"</code>:</dt><dd><p>a list of two elements. The first element contains the log-likelihood value and the
second element contains the mixing weights.</p>
</dd>
<dt>If <code>to_return=="terms"</code>:</dt><dd><p>a size ((n_obs-p)x1) numeric vector containing the terms <code class="reqn">l_{t}</code>.</p>
</dd>
<dt>If <code>to_return=="term_densities"</code>:</dt><dd><p>a size ((n_obs-p)xM) matrix containing the conditional densities that summed over
in the terms <code class="reqn">l_{t}</code>, as <code>[t, m]</code>.</p>
</dd>
<dt>If <code>to_return=="regime_cmeans"</code>:</dt><dd><p>a size ((n_obs-p)xM) matrix containing the regime specific conditional means.</p>
</dd>
<dt>If <code>to_return=="regime_cvars"</code>:</dt><dd><p>a size ((n_obs-p)xM) matrix containing the regime specific conditional variances.</p>
</dd>
<dt>If <code>to_return=="total_cmeans"</code>:</dt><dd><p>a size ((n_obs-p)x1) vector containing the total conditional means.</p>
</dd>
<dt>If <code>to_return=="total_cvars"</code>:</dt><dd><p>a size ((n_obs-p)x1) vector containing the total conditional variances.</p>
</dd>
<dt>If <code>to_return=="qresiduals"</code>:</dt><dd><p>a size ((n_obs-p)x1) vector containing the quantile residuals.</p>
</dd>
</dl>



<h3>References</h3>


<ul>
<li><p> Galbraith, R., Galbraith, J. 1974. On the inverses of some patterned matrices arising
in the theory of stationary time series. <em>Journal of Applied Probability</em> <strong>11</strong>, 63-71.
</p>
</li>
<li><p> Kalliovirta L. (2012) Misspecification tests based on quantile residuals.
<em>The Econometrics Journal</em>, <strong>15</strong>, 358-393.
</p>
</li>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2015. Gaussian Mixture Autoregressive model for univariate time series.
<em>Journal of Time Series Analysis</em>, <strong>36</strong>(2), 247-266.
</p>
</li>
<li><p> Meitz M., Preve D., Saikkonen P. 2023. A mixture autoregressive model based on Student's t-distribution.
<em>Communications in Statistics - Theory and Methods</em>, <strong>52</strong>(2), 499-515.
</p>
</li>
<li><p> Virolainen S. 2022. A mixture autoregressive model based on Gaussian and Student's t-distributions.
Studies in Nonlinear Dynamics &amp; Econometrics, <strong>26</strong>(4) 559-580.
</p>
</li></ul>


<hr>
<h2 id='LR_test'>Perform likelihood ratio test</h2><span id='topic+LR_test'></span>

<h3>Description</h3>

<p><code>LR_test</code> performs a likelihood ratio test for a GMAR, StMAR, or G-StMAR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LR_test(gsmar1, gsmar2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LR_test_+3A_gsmar1">gsmar1</code></td>
<td>
<p>an object of class <code>'gsmar'</code> generated by <code>fitGSMAR</code> or <code>GSMAR</code>, containing
the <strong>unconstrained</strong> model.</p>
</td></tr>
<tr><td><code id="LR_test_+3A_gsmar2">gsmar2</code></td>
<td>
<p>an object of class <code>'gsmar'</code> generated by <code>fitGSMAR</code> or <code>GSMAR</code>, containing
the <strong>constrained</strong> model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs a likelihood ratio test, testing the null hypothesis that the true parameter value lies
in the constrained parameter space specified by constraints imposed to the model <code>gsmar2</code>.
Under the null, the test statistic is asymptotically <code class="reqn">\chi^2</code>-distributed with <code class="reqn">k</code> degrees of freedom,
<code class="reqn">k</code> being the difference in the dimensions of the unconstrained and constrained parameter spaces.
</p>
<p>Note that this function does <strong>not</strong> verify that the two models are actually nested. Notably, GSMAR models
with different autoregressive orders are not nested, whereas testing models with different numbers of regimes
induce an identification problem and thereby unreliable test results (see the discussion related to Theorem 2
in Virolainen, 2021).
</p>


<h3>Value</h3>

<p>A list with class &quot;htest&quot; containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the likelihood ratio statistics.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the degrees of freedom of the likelihood ratio statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating the type of the test (likelihood ratio test).</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the names of the supplied models, gsmar1 and gsmar2.</p>
</td></tr>
<tr><td><code>gsmar1</code></td>
<td>
<p>the supplied argument gsmar1</p>
</td></tr>
<tr><td><code>gsmar2</code></td>
<td>
<p>the supplied argument gsmar2</p>
</td></tr>
</table>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2015. Gaussian Mixture Autoregressive model for univariate time series.
<em>Journal of Time Series Analysis</em>, <strong>36</strong>(2), 247-266.
</p>
</li>
<li><p> Meitz M., Preve D., Saikkonen P. 2023. A mixture autoregressive model based on Student's t-distribution.
<em>Communications in Statistics - Theory and Methods</em>, <strong>52</strong>(2), 499-515.
</p>
</li>
<li><p> Virolainen S. 2022. A mixture autoregressive model based on Gaussian and Student's t-distributions.
Studies in Nonlinear Dynamics &amp; Econometrics, <strong>26</strong>(4) 559-580.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+Wald_test">Wald_test</a></code>, <code><a href="#topic+fitGSMAR">fitGSMAR</a></code>, <code><a href="#topic+GSMAR">GSMAR</a></code>, <code><a href="#topic+diagnostic_plot">diagnostic_plot</a></code>,
<code><a href="#topic+profile_logliks">profile_logliks</a></code>, <code><a href="#topic+quantile_residual_tests">quantile_residual_tests</a></code>, <code><a href="#topic+cond_moment_plot">cond_moment_plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# GMAR p=1, M=2 model:
fit12 &lt;- fitGSMAR(simudata, p=1, M=2, model="GMAR", ncalls=1, seeds=1)

# GMAR p=1, M=2 model with AR parameters restricted to be the same in both
# regimes:
fit12r &lt;- fitGSMAR(simudata, p=1, M=2, model="GMAR", restricted=TRUE,
                   ncalls=1, seeds=1)

# Test with likelihood ratio test whether the AR parameters are the same in
# both regimes:
LR_test(fit12, fit12r)

</code></pre>

<hr>
<h2 id='M10Y1Y'>Spread between 10-Year and 1-Year Treasury rates: M10Y1Y</h2><span id='topic+M10Y1Y'></span>

<h3>Description</h3>

<p>A dataset containing monthly U.S. interest rate spread between the 10-Year Treasury constant
maturity rate and 1-Year Treasury constant maturity rate from 1982 January to 2020 December.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>M10Y1Y
</code></pre>


<h3>Format</h3>

<p>A class 'ts' time series object containing 468 observations.
</p>


<h3>Source</h3>

<p><a href="https://fred.stlouisfed.org/series/GS10">https://fred.stlouisfed.org/series/GS10</a> <a href="https://fred.stlouisfed.org/series/GS1">https://fred.stlouisfed.org/series/GS1</a>
</p>

<hr>
<h2 id='mixing_weights'>Calculate mixing weights of GMAR, StMAR or G-StMAR model</h2><span id='topic+mixing_weights'></span>

<h3>Description</h3>

<p><code>mixing_weights</code> calculates the mixing weights of the specified GMAR, StMAR or G-StMAR model and returns them as a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixing_weights(
  data,
  p,
  M,
  params,
  model = c("GMAR", "StMAR", "G-StMAR"),
  restricted = FALSE,
  constraints = NULL,
  parametrization = c("intercept", "mean")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixing_weights_+3A_data">data</code></td>
<td>
<p>a numeric vector or class <code>'ts'</code> object containing the data. <code>NA</code> values are not supported.</p>
</td></tr>
<tr><td><code id="mixing_weights_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="mixing_weights_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMAR</strong> and <strong>StMAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMAR type</em> components <code>M1</code> in the
first element and <em>StMAR type</em> components <code>M2</code> in the second element. The total number of mixture components is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="mixing_weights_+3A_params">params</code></td>
<td>
<p>a real valued parameter vector specifying the model.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(M(p+3)+M-M1-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=</code>(<strong><code class="reqn">\upsilon_{1}</code></strong><code class="reqn">,...,</code><strong><code class="reqn">\upsilon_{M}</code></strong>,
<code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>) where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn">=(\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,</code><code class="reqn">\sigma_{m}^2)</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p}), m=1,...,M</code>
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMAR type regimes.
</p>
</li></ul>

<p>In the <strong>GMAR</strong> model, <code class="reqn">M1=M</code> and the parameter <strong><code class="reqn">\nu</code></strong> dropped. In the <strong>StMAR</strong> model, <code class="reqn">M1=0</code>.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vectors <strong><code class="reqn">\phi_{m}</code></strong> with the vectors <strong><code class="reqn">\psi_{m}</code></strong> that satisfy
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(3M+M-M1+p-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=(\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">,</code>
<code class="reqn">\sigma_{1}^2,...,\sigma_{M}^2,</code><code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where <strong><code class="reqn">\phi</code></strong>=<code class="reqn">(\phi_{1},...,\phi_{p})</code>
contains the AR coefficients, which are common for all regimes.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vector <strong><code class="reqn">\phi</code></strong> with the vector <strong><code class="reqn">\psi</code></strong> that satisfies
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
</dl>

<p>Symbol <code class="reqn">\phi</code> denotes an AR coefficient, <code class="reqn">\sigma^2</code> a variance, <code class="reqn">\alpha</code> a mixing weight, and <code class="reqn">\nu</code> a degrees of
freedom parameter. If <code>parametrization=="mean"</code>, just replace each intercept term <code class="reqn">\phi_{m,0}</code> with the regimewise mean
<code class="reqn">\mu_m = \phi_{m,0}/(1-\sum\phi_{i,m})</code>. In the <strong>G-StMAR</strong> model, the first <code>M1</code> components are <em>GMAR type</em>
and the rest <code>M2</code> components are <em>StMAR type</em>.
Note that in the case <strong>M=1</strong>, the mixing weight parameters <code class="reqn">\alpha</code> are dropped, and in the case of <strong>StMAR</strong> or <strong>G-StMAR</strong> model,
the degrees of freedom parameters <code class="reqn">\nu</code> have to be larger than <code class="reqn">2</code>.</p>
</td></tr>
<tr><td><code id="mixing_weights_+3A_model">model</code></td>
<td>
<p>is &quot;GMAR&quot;, &quot;StMAR&quot;, or &quot;G-StMAR&quot; model considered? In the G-StMAR model, the first <code>M1</code> components
are <em>GMAR type</em> and the rest <code>M2</code> components are <em>StMAR type</em>.</p>
</td></tr>
<tr><td><code id="mixing_weights_+3A_restricted">restricted</code></td>
<td>
<p>a logical argument stating whether the AR coefficients <code class="reqn">\phi_{m,1},...,\phi_{m,p}</code> are restricted
to be the same for all regimes.</p>
</td></tr>
<tr><td><code id="mixing_weights_+3A_constraints">constraints</code></td>
<td>
<p>specifies linear constraints imposed to each regime's autoregressive parameters separately.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd><p>a list of size <code class="reqn">(pxq_{m})</code> constraint matrices <strong><code class="reqn">C_{m}</code></strong> of full column rank
satisfying <strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> for all <code class="reqn">m=1,...,M</code>, where
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p})</code> and <strong><code class="reqn">\psi_{m}</code></strong><code class="reqn">=(\psi_{m,1},...,\psi_{m,q_{m}})</code>.</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd><p>a size <code class="reqn">(pxq)</code> constraint matrix <strong><code class="reqn">C</code></strong> of full column rank satisfying
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong>, where <strong><code class="reqn">\phi</code></strong><code class="reqn">=(\phi_{1},...,\phi_{p})</code> and
<strong><code class="reqn">\psi</code></strong><code class="reqn">=\psi_{1},...,\psi_{q}</code>.</p>
</dd>
</dl>

<p>The symbol <code class="reqn">\phi</code> denotes an AR coefficient. Note that regardless of any constraints, the autoregressive order
is always <code>p</code> for all regimes.
Ignore or set to <code>NULL</code> if applying linear constraints is not desired.</p>
</td></tr>
<tr><td><code id="mixing_weights_+3A_parametrization">parametrization</code></td>
<td>
<p>is the model parametrized with the &quot;intercepts&quot; <code class="reqn">\phi_{m,0}</code> or
&quot;means&quot; <code class="reqn">\mu_{m} = \phi_{m,0}/(1-\sum\phi_{i,m})</code>?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first p observations are taken to be the initial values.
</p>


<h3>Value</h3>


<dl>
<dt>If <code>to_return=="mw"</code>:</dt><dd><p>a size ((n_obs-p)xM) matrix containing the mixing weights: for m:th component in m:th column.</p>
</dd>
<dt>If <code>to_return=="mw_tplus1"</code>:</dt><dd><p>a size ((n_obs-p+1)xM) matrix containing the mixing weights: for m:th component in m:th column.
The last row is for <code class="reqn">\alpha_{m,T+1}</code></p>
</dd></dl>
<p>.

</p>


<h3>References</h3>


<ul>
<li><p> Galbraith, R., Galbraith, J. 1974. On the inverses of some patterned matrices arising
in the theory of stationary time series. <em>Journal of Applied Probability</em> <strong>11</strong>, 63-71.
</p>
</li>
<li><p> Kalliovirta L. (2012) Misspecification tests based on quantile residuals.
<em>The Econometrics Journal</em>, <strong>15</strong>, 358-393.
</p>
</li>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2015. Gaussian Mixture Autoregressive model for univariate time series.
<em>Journal of Time Series Analysis</em>, <strong>36</strong>(2), 247-266.
</p>
</li>
<li><p> Meitz M., Preve D., Saikkonen P. 2023. A mixture autoregressive model based on Student's t-distribution.
<em>Communications in Statistics - Theory and Methods</em>, <strong>52</strong>(2), 499-515.
</p>
</li>
<li><p> Virolainen S. 2022. A mixture autoregressive model based on Gaussian and Student's t-distributions.
Studies in Nonlinear Dynamics &amp; Econometrics, <strong>26</strong>(4) 559-580.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># GMAR model
params12 &lt;- c(1.70, 0.85, 0.30, 4.12, 0.73, 1.98, 0.63)
mixing_weights(simudata, p=1, M=2, params=params12, model="GMAR")

# G-StMAR-model
params42gs &lt;- c(0.04, 1.34, -0.59, 0.54, -0.36, 0.01, 0.06, 1.28, -0.36,
                0.2, -0.15, 0.04, 0.19, 9.75)
mixing_weights(M10Y1Y, p=4, M=c(1, 1), params=params42gs, model="G-StMAR")
</code></pre>

<hr>
<h2 id='mixing_weights_int'>Calculate mixing weights of a GMAR, StMAR, or G-StMAR model</h2><span id='topic+mixing_weights_int'></span>

<h3>Description</h3>

<p><code>mixing_weights_int</code> calculates the mixing weights of the specified GMAR, StMAR, or G-StMAR model
and returns them as a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixing_weights_int(
  data,
  p,
  M,
  params,
  model = c("GMAR", "StMAR", "G-StMAR"),
  restricted = FALSE,
  constraints = NULL,
  parametrization = c("intercept", "mean"),
  checks = TRUE,
  to_return = c("mw", "mw_tplus1")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixing_weights_int_+3A_data">data</code></td>
<td>
<p>a numeric vector or class <code>'ts'</code> object containing the data. <code>NA</code> values are not supported.</p>
</td></tr>
<tr><td><code id="mixing_weights_int_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="mixing_weights_int_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMAR</strong> and <strong>StMAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMAR type</em> components <code>M1</code> in the
first element and <em>StMAR type</em> components <code>M2</code> in the second element. The total number of mixture components is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="mixing_weights_int_+3A_params">params</code></td>
<td>
<p>a real valued parameter vector specifying the model.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(M(p+3)+M-M1-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=</code>(<strong><code class="reqn">\upsilon_{1}</code></strong><code class="reqn">,...,</code><strong><code class="reqn">\upsilon_{M}</code></strong>,
<code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>) where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn">=(\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,</code><code class="reqn">\sigma_{m}^2)</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p}), m=1,...,M</code>
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMAR type regimes.
</p>
</li></ul>

<p>In the <strong>GMAR</strong> model, <code class="reqn">M1=M</code> and the parameter <strong><code class="reqn">\nu</code></strong> dropped. In the <strong>StMAR</strong> model, <code class="reqn">M1=0</code>.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vectors <strong><code class="reqn">\phi_{m}</code></strong> with the vectors <strong><code class="reqn">\psi_{m}</code></strong> that satisfy
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(3M+M-M1+p-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=(\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">,</code>
<code class="reqn">\sigma_{1}^2,...,\sigma_{M}^2,</code><code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where <strong><code class="reqn">\phi</code></strong>=<code class="reqn">(\phi_{1},...,\phi_{p})</code>
contains the AR coefficients, which are common for all regimes.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vector <strong><code class="reqn">\phi</code></strong> with the vector <strong><code class="reqn">\psi</code></strong> that satisfies
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
</dl>

<p>Symbol <code class="reqn">\phi</code> denotes an AR coefficient, <code class="reqn">\sigma^2</code> a variance, <code class="reqn">\alpha</code> a mixing weight, and <code class="reqn">\nu</code> a degrees of
freedom parameter. If <code>parametrization=="mean"</code>, just replace each intercept term <code class="reqn">\phi_{m,0}</code> with the regimewise mean
<code class="reqn">\mu_m = \phi_{m,0}/(1-\sum\phi_{i,m})</code>. In the <strong>G-StMAR</strong> model, the first <code>M1</code> components are <em>GMAR type</em>
and the rest <code>M2</code> components are <em>StMAR type</em>.
Note that in the case <strong>M=1</strong>, the mixing weight parameters <code class="reqn">\alpha</code> are dropped, and in the case of <strong>StMAR</strong> or <strong>G-StMAR</strong> model,
the degrees of freedom parameters <code class="reqn">\nu</code> have to be larger than <code class="reqn">2</code>.</p>
</td></tr>
<tr><td><code id="mixing_weights_int_+3A_model">model</code></td>
<td>
<p>is &quot;GMAR&quot;, &quot;StMAR&quot;, or &quot;G-StMAR&quot; model considered? In the G-StMAR model, the first <code>M1</code> components
are <em>GMAR type</em> and the rest <code>M2</code> components are <em>StMAR type</em>.</p>
</td></tr>
<tr><td><code id="mixing_weights_int_+3A_restricted">restricted</code></td>
<td>
<p>a logical argument stating whether the AR coefficients <code class="reqn">\phi_{m,1},...,\phi_{m,p}</code> are restricted
to be the same for all regimes.</p>
</td></tr>
<tr><td><code id="mixing_weights_int_+3A_constraints">constraints</code></td>
<td>
<p>specifies linear constraints imposed to each regime's autoregressive parameters separately.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd><p>a list of size <code class="reqn">(pxq_{m})</code> constraint matrices <strong><code class="reqn">C_{m}</code></strong> of full column rank
satisfying <strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> for all <code class="reqn">m=1,...,M</code>, where
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p})</code> and <strong><code class="reqn">\psi_{m}</code></strong><code class="reqn">=(\psi_{m,1},...,\psi_{m,q_{m}})</code>.</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd><p>a size <code class="reqn">(pxq)</code> constraint matrix <strong><code class="reqn">C</code></strong> of full column rank satisfying
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong>, where <strong><code class="reqn">\phi</code></strong><code class="reqn">=(\phi_{1},...,\phi_{p})</code> and
<strong><code class="reqn">\psi</code></strong><code class="reqn">=\psi_{1},...,\psi_{q}</code>.</p>
</dd>
</dl>

<p>The symbol <code class="reqn">\phi</code> denotes an AR coefficient. Note that regardless of any constraints, the autoregressive order
is always <code>p</code> for all regimes.
Ignore or set to <code>NULL</code> if applying linear constraints is not desired.</p>
</td></tr>
<tr><td><code id="mixing_weights_int_+3A_parametrization">parametrization</code></td>
<td>
<p>is the model parametrized with the &quot;intercepts&quot; <code class="reqn">\phi_{m,0}</code> or
&quot;means&quot; <code class="reqn">\mu_{m} = \phi_{m,0}/(1-\sum\phi_{i,m})</code>?</p>
</td></tr>
<tr><td><code id="mixing_weights_int_+3A_checks">checks</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> specifying whether argument checks, such as stationarity checks, should be done.</p>
</td></tr>
<tr><td><code id="mixing_weights_int_+3A_to_return">to_return</code></td>
<td>
<p>should the returned object contain mixing weights for t=1,..,T (<code>"mw"</code>) or for t=1,..,T+1 (<code>"mw_tplus1"</code>)?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first p observations are taken to be the initial values.
</p>


<h3>Value</h3>


<dl>
<dt>If <code>to_return=="mw"</code>:</dt><dd><p>a size ((n_obs-p)xM) matrix containing the mixing weights: for m:th component in m:th column.</p>
</dd>
<dt>If <code>to_return=="mw_tplus1"</code>:</dt><dd><p>a size ((n_obs-p+1)xM) matrix containing the mixing weights: for m:th component in m:th column.
The last row is for <code class="reqn">\alpha_{m,T+1}</code></p>
</dd></dl>
<p>.

</p>


<h3>References</h3>


<ul>
<li><p> Galbraith, R., Galbraith, J. 1974. On the inverses of some patterned matrices arising
in the theory of stationary time series. <em>Journal of Applied Probability</em> <strong>11</strong>, 63-71.
</p>
</li>
<li><p> Kalliovirta L. (2012) Misspecification tests based on quantile residuals.
<em>The Econometrics Journal</em>, <strong>15</strong>, 358-393.
</p>
</li>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2015. Gaussian Mixture Autoregressive model for univariate time series.
<em>Journal of Time Series Analysis</em>, <strong>36</strong>(2), 247-266.
</p>
</li>
<li><p> Meitz M., Preve D., Saikkonen P. 2023. A mixture autoregressive model based on Student's t-distribution.
<em>Communications in Statistics - Theory and Methods</em>, <strong>52</strong>(2), 499-515.
</p>
</li>
<li><p> Virolainen S. 2022. A mixture autoregressive model based on Gaussian and Student's t-distributions.
Studies in Nonlinear Dynamics &amp; Econometrics, <strong>26</strong>(4) 559-580.
</p>
</li></ul>


<hr>
<h2 id='mixingWeights'>DEPRECATED, USE <code>mixing_weights</code> INSTEAD! Calculate mixing weights of GMAR, StMAR or G-StMAR model</h2><span id='topic+mixingWeights'></span>

<h3>Description</h3>

<p><code>mixingWeights</code> calculates the mixing weights of the specified GMAR, StMAR or G-StMAR model
and returns them as a matrix. DEPRECATED, USE <code>mixing_weights</code> INSTEAD!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixingWeights(
  data,
  p,
  M,
  params,
  model = c("GMAR", "StMAR", "G-StMAR"),
  restricted = FALSE,
  constraints = NULL,
  parametrization = c("intercept", "mean")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixingWeights_+3A_data">data</code></td>
<td>
<p>a numeric vector or class <code>'ts'</code> object containing the data. <code>NA</code> values are not supported.</p>
</td></tr>
<tr><td><code id="mixingWeights_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="mixingWeights_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMAR</strong> and <strong>StMAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMAR type</em> components <code>M1</code> in the
first element and <em>StMAR type</em> components <code>M2</code> in the second element. The total number of mixture components is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="mixingWeights_+3A_params">params</code></td>
<td>
<p>a real valued parameter vector specifying the model.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(M(p+3)+M-M1-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=</code>(<strong><code class="reqn">\upsilon_{1}</code></strong><code class="reqn">,...,</code><strong><code class="reqn">\upsilon_{M}</code></strong>,
<code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>) where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn">=(\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,</code><code class="reqn">\sigma_{m}^2)</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p}), m=1,...,M</code>
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMAR type regimes.
</p>
</li></ul>

<p>In the <strong>GMAR</strong> model, <code class="reqn">M1=M</code> and the parameter <strong><code class="reqn">\nu</code></strong> dropped. In the <strong>StMAR</strong> model, <code class="reqn">M1=0</code>.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vectors <strong><code class="reqn">\phi_{m}</code></strong> with the vectors <strong><code class="reqn">\psi_{m}</code></strong> that satisfy
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(3M+M-M1+p-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=(\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">,</code>
<code class="reqn">\sigma_{1}^2,...,\sigma_{M}^2,</code><code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where <strong><code class="reqn">\phi</code></strong>=<code class="reqn">(\phi_{1},...,\phi_{p})</code>
contains the AR coefficients, which are common for all regimes.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vector <strong><code class="reqn">\phi</code></strong> with the vector <strong><code class="reqn">\psi</code></strong> that satisfies
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
</dl>

<p>Symbol <code class="reqn">\phi</code> denotes an AR coefficient, <code class="reqn">\sigma^2</code> a variance, <code class="reqn">\alpha</code> a mixing weight, and <code class="reqn">\nu</code> a degrees of
freedom parameter. If <code>parametrization=="mean"</code>, just replace each intercept term <code class="reqn">\phi_{m,0}</code> with the regimewise mean
<code class="reqn">\mu_m = \phi_{m,0}/(1-\sum\phi_{i,m})</code>. In the <strong>G-StMAR</strong> model, the first <code>M1</code> components are <em>GMAR type</em>
and the rest <code>M2</code> components are <em>StMAR type</em>.
Note that in the case <strong>M=1</strong>, the mixing weight parameters <code class="reqn">\alpha</code> are dropped, and in the case of <strong>StMAR</strong> or <strong>G-StMAR</strong> model,
the degrees of freedom parameters <code class="reqn">\nu</code> have to be larger than <code class="reqn">2</code>.</p>
</td></tr>
<tr><td><code id="mixingWeights_+3A_model">model</code></td>
<td>
<p>is &quot;GMAR&quot;, &quot;StMAR&quot;, or &quot;G-StMAR&quot; model considered? In the G-StMAR model, the first <code>M1</code> components
are <em>GMAR type</em> and the rest <code>M2</code> components are <em>StMAR type</em>.</p>
</td></tr>
<tr><td><code id="mixingWeights_+3A_restricted">restricted</code></td>
<td>
<p>a logical argument stating whether the AR coefficients <code class="reqn">\phi_{m,1},...,\phi_{m,p}</code> are restricted
to be the same for all regimes.</p>
</td></tr>
<tr><td><code id="mixingWeights_+3A_constraints">constraints</code></td>
<td>
<p>specifies linear constraints imposed to each regime's autoregressive parameters separately.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd><p>a list of size <code class="reqn">(pxq_{m})</code> constraint matrices <strong><code class="reqn">C_{m}</code></strong> of full column rank
satisfying <strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> for all <code class="reqn">m=1,...,M</code>, where
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p})</code> and <strong><code class="reqn">\psi_{m}</code></strong><code class="reqn">=(\psi_{m,1},...,\psi_{m,q_{m}})</code>.</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd><p>a size <code class="reqn">(pxq)</code> constraint matrix <strong><code class="reqn">C</code></strong> of full column rank satisfying
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong>, where <strong><code class="reqn">\phi</code></strong><code class="reqn">=(\phi_{1},...,\phi_{p})</code> and
<strong><code class="reqn">\psi</code></strong><code class="reqn">=\psi_{1},...,\psi_{q}</code>.</p>
</dd>
</dl>

<p>The symbol <code class="reqn">\phi</code> denotes an AR coefficient. Note that regardless of any constraints, the autoregressive order
is always <code>p</code> for all regimes.
Ignore or set to <code>NULL</code> if applying linear constraints is not desired.</p>
</td></tr>
<tr><td><code id="mixingWeights_+3A_parametrization">parametrization</code></td>
<td>
<p>is the model parametrized with the &quot;intercepts&quot; <code class="reqn">\phi_{m,0}</code> or
&quot;means&quot; <code class="reqn">\mu_{m} = \phi_{m,0}/(1-\sum\phi_{i,m})</code>?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>DEPRECATED, USE <code>mixing_weights</code> INSTEAD!
</p>


<h3>Value</h3>


<dl>
<dt>If <code>to_return=="mw"</code>:</dt><dd><p>a size ((n_obs-p)xM) matrix containing the mixing weights: for m:th component in m:th column.</p>
</dd>
<dt>If <code>to_return=="mw_tplus1"</code>:</dt><dd><p>a size ((n_obs-p+1)xM) matrix containing the mixing weights: for m:th component in m:th column.
The last row is for <code class="reqn">\alpha_{m,T+1}</code></p>
</dd></dl>
<p>.

</p>


<h3>References</h3>


<ul>
<li><p> Galbraith, R., Galbraith, J. 1974. On the inverses of some patterned matrices arising
in the theory of stationary time series. <em>Journal of Applied Probability</em> <strong>11</strong>, 63-71.
</p>
</li>
<li><p> Kalliovirta L. (2012) Misspecification tests based on quantile residuals.
<em>The Econometrics Journal</em>, <strong>15</strong>, 358-393.
</p>
</li>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2015. Gaussian Mixture Autoregressive model for univariate time series.
<em>Journal of Time Series Analysis</em>, <strong>36</strong>(2), 247-266.
</p>
</li>
<li><p> Meitz M., Preve D., Saikkonen P. 2023. A mixture autoregressive model based on Student's t-distribution.
<em>Communications in Statistics - Theory and Methods</em>, <strong>52</strong>(2), 499-515.
</p>
</li>
<li><p> Virolainen S. 2022. A mixture autoregressive model based on Gaussian and Student's t-distributions.
Studies in Nonlinear Dynamics &amp; Econometrics, <strong>26</strong>(4) 559-580.
</p>
</li></ul>


<hr>
<h2 id='n_params'>Calculate the number of parameters</h2><span id='topic+n_params'></span>

<h3>Description</h3>

<p><code>n_params</code> calculates the number of parameters that should be in the parameter vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_params(
  p,
  M,
  model = c("GMAR", "StMAR", "G-StMAR"),
  restricted = FALSE,
  constraints = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_params_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="n_params_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMAR</strong> and <strong>StMAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMAR type</em> components <code>M1</code> in the
first element and <em>StMAR type</em> components <code>M2</code> in the second element. The total number of mixture components is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="n_params_+3A_model">model</code></td>
<td>
<p>is &quot;GMAR&quot;, &quot;StMAR&quot;, or &quot;G-StMAR&quot; model considered? In the G-StMAR model, the first <code>M1</code> components
are <em>GMAR type</em> and the rest <code>M2</code> components are <em>StMAR type</em>.</p>
</td></tr>
<tr><td><code id="n_params_+3A_restricted">restricted</code></td>
<td>
<p>a logical argument stating whether the AR coefficients <code class="reqn">\phi_{m,1},...,\phi_{m,p}</code> are restricted
to be the same for all regimes.</p>
</td></tr>
<tr><td><code id="n_params_+3A_constraints">constraints</code></td>
<td>
<p>specifies linear constraints imposed to each regime's autoregressive parameters separately.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd><p>a list of size <code class="reqn">(pxq_{m})</code> constraint matrices <strong><code class="reqn">C_{m}</code></strong> of full column rank
satisfying <strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> for all <code class="reqn">m=1,...,M</code>, where
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p})</code> and <strong><code class="reqn">\psi_{m}</code></strong><code class="reqn">=(\psi_{m,1},...,\psi_{m,q_{m}})</code>.</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd><p>a size <code class="reqn">(pxq)</code> constraint matrix <strong><code class="reqn">C</code></strong> of full column rank satisfying
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong>, where <strong><code class="reqn">\phi</code></strong><code class="reqn">=(\phi_{1},...,\phi_{p})</code> and
<strong><code class="reqn">\psi</code></strong><code class="reqn">=\psi_{1},...,\psi_{q}</code>.</p>
</dd>
</dl>

<p>The symbol <code class="reqn">\phi</code> denotes an AR coefficient. Note that regardless of any constraints, the autoregressive order
is always <code>p</code> for all regimes.
Ignore or set to <code>NULL</code> if applying linear constraints is not desired.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the number of parameters.
</p>

<hr>
<h2 id='parameter_checks'>Check the parameter vector is specified correctly</h2><span id='topic+parameter_checks'></span>

<h3>Description</h3>

<p><code>parameter_checks</code> checks dimension, restrictions, and stationarity of the given parameter
of a GMAR, StMAR, or G-StMAR model. Throws an error if any check fails. Does NOT consider the identifiability
condition!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parameter_checks(
  p,
  M,
  params,
  model = c("GMAR", "StMAR", "G-StMAR"),
  restricted = FALSE,
  constraints = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parameter_checks_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="parameter_checks_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMAR</strong> and <strong>StMAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMAR type</em> components <code>M1</code> in the
first element and <em>StMAR type</em> components <code>M2</code> in the second element. The total number of mixture components is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="parameter_checks_+3A_params">params</code></td>
<td>
<p>a real valued parameter vector specifying the model.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(M(p+3)+M-M1-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=</code>(<strong><code class="reqn">\upsilon_{1}</code></strong><code class="reqn">,...,</code><strong><code class="reqn">\upsilon_{M}</code></strong>,
<code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>) where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn">=(\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,</code><code class="reqn">\sigma_{m}^2)</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p}), m=1,...,M</code>
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMAR type regimes.
</p>
</li></ul>

<p>In the <strong>GMAR</strong> model, <code class="reqn">M1=M</code> and the parameter <strong><code class="reqn">\nu</code></strong> dropped. In the <strong>StMAR</strong> model, <code class="reqn">M1=0</code>.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vectors <strong><code class="reqn">\phi_{m}</code></strong> with the vectors <strong><code class="reqn">\psi_{m}</code></strong> that satisfy
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(3M+M-M1+p-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=(\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">,</code>
<code class="reqn">\sigma_{1}^2,...,\sigma_{M}^2,</code><code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where <strong><code class="reqn">\phi</code></strong>=<code class="reqn">(\phi_{1},...,\phi_{p})</code>
contains the AR coefficients, which are common for all regimes.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vector <strong><code class="reqn">\phi</code></strong> with the vector <strong><code class="reqn">\psi</code></strong> that satisfies
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
</dl>

<p>Symbol <code class="reqn">\phi</code> denotes an AR coefficient, <code class="reqn">\sigma^2</code> a variance, <code class="reqn">\alpha</code> a mixing weight, and <code class="reqn">\nu</code> a degrees of
freedom parameter. If <code>parametrization=="mean"</code>, just replace each intercept term <code class="reqn">\phi_{m,0}</code> with the regimewise mean
<code class="reqn">\mu_m = \phi_{m,0}/(1-\sum\phi_{i,m})</code>. In the <strong>G-StMAR</strong> model, the first <code>M1</code> components are <em>GMAR type</em>
and the rest <code>M2</code> components are <em>StMAR type</em>.
Note that in the case <strong>M=1</strong>, the mixing weight parameters <code class="reqn">\alpha</code> are dropped, and in the case of <strong>StMAR</strong> or <strong>G-StMAR</strong> model,
the degrees of freedom parameters <code class="reqn">\nu</code> have to be larger than <code class="reqn">2</code>.</p>
</td></tr>
<tr><td><code id="parameter_checks_+3A_model">model</code></td>
<td>
<p>is &quot;GMAR&quot;, &quot;StMAR&quot;, or &quot;G-StMAR&quot; model considered? In the G-StMAR model, the first <code>M1</code> components
are <em>GMAR type</em> and the rest <code>M2</code> components are <em>StMAR type</em>.</p>
</td></tr>
<tr><td><code id="parameter_checks_+3A_restricted">restricted</code></td>
<td>
<p>a logical argument stating whether the AR coefficients <code class="reqn">\phi_{m,1},...,\phi_{m,p}</code> are restricted
to be the same for all regimes.</p>
</td></tr>
<tr><td><code id="parameter_checks_+3A_constraints">constraints</code></td>
<td>
<p>specifies linear constraints imposed to each regime's autoregressive parameters separately.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd><p>a list of size <code class="reqn">(pxq_{m})</code> constraint matrices <strong><code class="reqn">C_{m}</code></strong> of full column rank
satisfying <strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> for all <code class="reqn">m=1,...,M</code>, where
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p})</code> and <strong><code class="reqn">\psi_{m}</code></strong><code class="reqn">=(\psi_{m,1},...,\psi_{m,q_{m}})</code>.</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd><p>a size <code class="reqn">(pxq)</code> constraint matrix <strong><code class="reqn">C</code></strong> of full column rank satisfying
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong>, where <strong><code class="reqn">\phi</code></strong><code class="reqn">=(\phi_{1},...,\phi_{p})</code> and
<strong><code class="reqn">\psi</code></strong><code class="reqn">=\psi_{1},...,\psi_{q}</code>.</p>
</dd>
</dl>

<p>The symbol <code class="reqn">\phi</code> denotes an AR coefficient. Note that regardless of any constraints, the autoregressive order
is always <code>p</code> for all regimes.
Ignore or set to <code>NULL</code> if applying linear constraints is not desired.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Throws an informative error if any check fails. Does not return anything.
</p>

<hr>
<h2 id='pick_alphas'>Pick mixing weights parameters from parameter vector</h2><span id='topic+pick_alphas'></span>

<h3>Description</h3>

<p><code>pick_alphas</code> picks and returns the mixing weights parameters
(including the non-parametrized one for the last component) from the given
parameter vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pick_alphas(
  p,
  M,
  params,
  model = c("GMAR", "StMAR", "G-StMAR"),
  restricted = FALSE,
  constraints = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pick_alphas_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="pick_alphas_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMAR</strong> and <strong>StMAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMAR type</em> components <code>M1</code> in the
first element and <em>StMAR type</em> components <code>M2</code> in the second element. The total number of mixture components is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="pick_alphas_+3A_params">params</code></td>
<td>
<p>a real valued parameter vector specifying the model.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(M(p+3)+M-M1-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=</code>(<strong><code class="reqn">\upsilon_{1}</code></strong><code class="reqn">,...,</code><strong><code class="reqn">\upsilon_{M}</code></strong>,
<code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>) where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn">=(\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,</code><code class="reqn">\sigma_{m}^2)</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p}), m=1,...,M</code>
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMAR type regimes.
</p>
</li></ul>

<p>In the <strong>GMAR</strong> model, <code class="reqn">M1=M</code> and the parameter <strong><code class="reqn">\nu</code></strong> dropped. In the <strong>StMAR</strong> model, <code class="reqn">M1=0</code>.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vectors <strong><code class="reqn">\phi_{m}</code></strong> with the vectors <strong><code class="reqn">\psi_{m}</code></strong> that satisfy
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(3M+M-M1+p-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=(\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">,</code>
<code class="reqn">\sigma_{1}^2,...,\sigma_{M}^2,</code><code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where <strong><code class="reqn">\phi</code></strong>=<code class="reqn">(\phi_{1},...,\phi_{p})</code>
contains the AR coefficients, which are common for all regimes.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vector <strong><code class="reqn">\phi</code></strong> with the vector <strong><code class="reqn">\psi</code></strong> that satisfies
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
</dl>

<p>Symbol <code class="reqn">\phi</code> denotes an AR coefficient, <code class="reqn">\sigma^2</code> a variance, <code class="reqn">\alpha</code> a mixing weight, and <code class="reqn">\nu</code> a degrees of
freedom parameter. If <code>parametrization=="mean"</code>, just replace each intercept term <code class="reqn">\phi_{m,0}</code> with the regimewise mean
<code class="reqn">\mu_m = \phi_{m,0}/(1-\sum\phi_{i,m})</code>. In the <strong>G-StMAR</strong> model, the first <code>M1</code> components are <em>GMAR type</em>
and the rest <code>M2</code> components are <em>StMAR type</em>.
Note that in the case <strong>M=1</strong>, the mixing weight parameters <code class="reqn">\alpha</code> are dropped, and in the case of <strong>StMAR</strong> or <strong>G-StMAR</strong> model,
the degrees of freedom parameters <code class="reqn">\nu</code> have to be larger than <code class="reqn">2</code>.</p>
</td></tr>
<tr><td><code id="pick_alphas_+3A_model">model</code></td>
<td>
<p>is &quot;GMAR&quot;, &quot;StMAR&quot;, or &quot;G-StMAR&quot; model considered? In the G-StMAR model, the first <code>M1</code> components
are <em>GMAR type</em> and the rest <code>M2</code> components are <em>StMAR type</em>.</p>
</td></tr>
<tr><td><code id="pick_alphas_+3A_restricted">restricted</code></td>
<td>
<p>a logical argument stating whether the AR coefficients <code class="reqn">\phi_{m,1},...,\phi_{m,p}</code> are restricted
to be the same for all regimes.</p>
</td></tr>
<tr><td><code id="pick_alphas_+3A_constraints">constraints</code></td>
<td>
<p>specifies linear constraints imposed to each regime's autoregressive parameters separately.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd><p>a list of size <code class="reqn">(pxq_{m})</code> constraint matrices <strong><code class="reqn">C_{m}</code></strong> of full column rank
satisfying <strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> for all <code class="reqn">m=1,...,M</code>, where
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p})</code> and <strong><code class="reqn">\psi_{m}</code></strong><code class="reqn">=(\psi_{m,1},...,\psi_{m,q_{m}})</code>.</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd><p>a size <code class="reqn">(pxq)</code> constraint matrix <strong><code class="reqn">C</code></strong> of full column rank satisfying
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong>, where <strong><code class="reqn">\phi</code></strong><code class="reqn">=(\phi_{1},...,\phi_{p})</code> and
<strong><code class="reqn">\psi</code></strong><code class="reqn">=\psi_{1},...,\psi_{q}</code>.</p>
</dd>
</dl>

<p>The symbol <code class="reqn">\phi</code> denotes an AR coefficient. Note that regardless of any constraints, the autoregressive order
is always <code>p</code> for all regimes.
Ignore or set to <code>NULL</code> if applying linear constraints is not desired.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of length <code>M</code> containing the mixing weight parameters <code class="reqn">\alpha_m</code>.
</p>

<hr>
<h2 id='pick_dfs'>Pick degrees of freedom parameters from a parameter vector</h2><span id='topic+pick_dfs'></span>

<h3>Description</h3>

<p><code>pick_dfs</code> picks and returns the degrees of freedom parameters from
the given parameter vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pick_dfs(p, M, params, model = c("GMAR", "StMAR", "G-StMAR"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pick_dfs_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="pick_dfs_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMAR</strong> and <strong>StMAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMAR type</em> components <code>M1</code> in the
first element and <em>StMAR type</em> components <code>M2</code> in the second element. The total number of mixture components is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="pick_dfs_+3A_params">params</code></td>
<td>
<p>a real valued parameter vector specifying the model.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(M(p+3)+M-M1-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=</code>(<strong><code class="reqn">\upsilon_{1}</code></strong><code class="reqn">,...,</code><strong><code class="reqn">\upsilon_{M}</code></strong>,
<code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>) where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn">=(\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,</code><code class="reqn">\sigma_{m}^2)</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p}), m=1,...,M</code>
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMAR type regimes.
</p>
</li></ul>

<p>In the <strong>GMAR</strong> model, <code class="reqn">M1=M</code> and the parameter <strong><code class="reqn">\nu</code></strong> dropped. In the <strong>StMAR</strong> model, <code class="reqn">M1=0</code>.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vectors <strong><code class="reqn">\phi_{m}</code></strong> with the vectors <strong><code class="reqn">\psi_{m}</code></strong> that satisfy
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(3M+M-M1+p-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=(\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">,</code>
<code class="reqn">\sigma_{1}^2,...,\sigma_{M}^2,</code><code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where <strong><code class="reqn">\phi</code></strong>=<code class="reqn">(\phi_{1},...,\phi_{p})</code>
contains the AR coefficients, which are common for all regimes.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vector <strong><code class="reqn">\phi</code></strong> with the vector <strong><code class="reqn">\psi</code></strong> that satisfies
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
</dl>

<p>Symbol <code class="reqn">\phi</code> denotes an AR coefficient, <code class="reqn">\sigma^2</code> a variance, <code class="reqn">\alpha</code> a mixing weight, and <code class="reqn">\nu</code> a degrees of
freedom parameter. If <code>parametrization=="mean"</code>, just replace each intercept term <code class="reqn">\phi_{m,0}</code> with the regimewise mean
<code class="reqn">\mu_m = \phi_{m,0}/(1-\sum\phi_{i,m})</code>. In the <strong>G-StMAR</strong> model, the first <code>M1</code> components are <em>GMAR type</em>
and the rest <code>M2</code> components are <em>StMAR type</em>.
Note that in the case <strong>M=1</strong>, the mixing weight parameters <code class="reqn">\alpha</code> are dropped, and in the case of <strong>StMAR</strong> or <strong>G-StMAR</strong> model,
the degrees of freedom parameters <code class="reqn">\nu</code> have to be larger than <code class="reqn">2</code>.</p>
</td></tr>
<tr><td><code id="pick_dfs_+3A_model">model</code></td>
<td>
<p>is &quot;GMAR&quot;, &quot;StMAR&quot;, or &quot;G-StMAR&quot; model considered? In the G-StMAR model, the first <code>M1</code> components
are <em>GMAR type</em> and the rest <code>M2</code> components are <em>StMAR type</em>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of length <code>M</code> or <code>M2</code> containing the degrees of freedom parameters.
</p>

<hr>
<h2 id='pick_pars'>Pick <code class="reqn">\phi_0</code> (or <code class="reqn">\mu</code>), AR-coefficients, and variance parameters from a parameter vector</h2><span id='topic+pick_pars'></span>

<h3>Description</h3>

<p><code>pick_pars</code> picks <code class="reqn">\phi_0</code>/<code class="reqn">\mu</code>, AR-coefficients, and variance parameters from
the given parameter vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pick_pars(
  p,
  M,
  params,
  model = c("GMAR", "StMAR", "G-StMAR"),
  restricted = FALSE,
  constraints = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pick_pars_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="pick_pars_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMAR</strong> and <strong>StMAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMAR type</em> components <code>M1</code> in the
first element and <em>StMAR type</em> components <code>M2</code> in the second element. The total number of mixture components is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="pick_pars_+3A_params">params</code></td>
<td>
<p>a real valued parameter vector specifying the model.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(M(p+3)+M-M1-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=</code>(<strong><code class="reqn">\upsilon_{1}</code></strong><code class="reqn">,...,</code><strong><code class="reqn">\upsilon_{M}</code></strong>,
<code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>) where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn">=(\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,</code><code class="reqn">\sigma_{m}^2)</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p}), m=1,...,M</code>
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMAR type regimes.
</p>
</li></ul>

<p>In the <strong>GMAR</strong> model, <code class="reqn">M1=M</code> and the parameter <strong><code class="reqn">\nu</code></strong> dropped. In the <strong>StMAR</strong> model, <code class="reqn">M1=0</code>.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vectors <strong><code class="reqn">\phi_{m}</code></strong> with the vectors <strong><code class="reqn">\psi_{m}</code></strong> that satisfy
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(3M+M-M1+p-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=(\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">,</code>
<code class="reqn">\sigma_{1}^2,...,\sigma_{M}^2,</code><code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where <strong><code class="reqn">\phi</code></strong>=<code class="reqn">(\phi_{1},...,\phi_{p})</code>
contains the AR coefficients, which are common for all regimes.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vector <strong><code class="reqn">\phi</code></strong> with the vector <strong><code class="reqn">\psi</code></strong> that satisfies
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
</dl>

<p>Symbol <code class="reqn">\phi</code> denotes an AR coefficient, <code class="reqn">\sigma^2</code> a variance, <code class="reqn">\alpha</code> a mixing weight, and <code class="reqn">\nu</code> a degrees of
freedom parameter. If <code>parametrization=="mean"</code>, just replace each intercept term <code class="reqn">\phi_{m,0}</code> with the regimewise mean
<code class="reqn">\mu_m = \phi_{m,0}/(1-\sum\phi_{i,m})</code>. In the <strong>G-StMAR</strong> model, the first <code>M1</code> components are <em>GMAR type</em>
and the rest <code>M2</code> components are <em>StMAR type</em>.
Note that in the case <strong>M=1</strong>, the mixing weight parameters <code class="reqn">\alpha</code> are dropped, and in the case of <strong>StMAR</strong> or <strong>G-StMAR</strong> model,
the degrees of freedom parameters <code class="reqn">\nu</code> have to be larger than <code class="reqn">2</code>.</p>
</td></tr>
<tr><td><code id="pick_pars_+3A_model">model</code></td>
<td>
<p>is &quot;GMAR&quot;, &quot;StMAR&quot;, or &quot;G-StMAR&quot; model considered? In the G-StMAR model, the first <code>M1</code> components
are <em>GMAR type</em> and the rest <code>M2</code> components are <em>StMAR type</em>.</p>
</td></tr>
<tr><td><code id="pick_pars_+3A_restricted">restricted</code></td>
<td>
<p>a logical argument stating whether the AR coefficients <code class="reqn">\phi_{m,1},...,\phi_{m,p}</code> are restricted
to be the same for all regimes.</p>
</td></tr>
<tr><td><code id="pick_pars_+3A_constraints">constraints</code></td>
<td>
<p>specifies linear constraints imposed to each regime's autoregressive parameters separately.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd><p>a list of size <code class="reqn">(pxq_{m})</code> constraint matrices <strong><code class="reqn">C_{m}</code></strong> of full column rank
satisfying <strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> for all <code class="reqn">m=1,...,M</code>, where
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p})</code> and <strong><code class="reqn">\psi_{m}</code></strong><code class="reqn">=(\psi_{m,1},...,\psi_{m,q_{m}})</code>.</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd><p>a size <code class="reqn">(pxq)</code> constraint matrix <strong><code class="reqn">C</code></strong> of full column rank satisfying
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong>, where <strong><code class="reqn">\phi</code></strong><code class="reqn">=(\phi_{1},...,\phi_{p})</code> and
<strong><code class="reqn">\psi</code></strong><code class="reqn">=\psi_{1},...,\psi_{q}</code>.</p>
</dd>
</dl>

<p>The symbol <code class="reqn">\phi</code> denotes an AR coefficient. Note that regardless of any constraints, the autoregressive order
is always <code>p</code> for all regimes.
Ignore or set to <code>NULL</code> if applying linear constraints is not desired.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code class="reqn">((p+2)xM)</code> matrix containing the parameters, column for each component.
The first row for <code class="reqn">\phi_0</code> or <code class="reqn">\mu</code> depending on the parametrization, the second row
for <code class="reqn">\phi_1</code>, ..., the second to last row for <code class="reqn">\phi_p</code>, and the last row for <code class="reqn">\sigma^2</code>.
@keywords internal
</p>

<hr>
<h2 id='pick_phi0'>Pick phi0 or mean parameters from parameter vector</h2><span id='topic+pick_phi0'></span>

<h3>Description</h3>

<p><code>pick_phi0</code> picks and returns the phi0 or mean parameters from parameter vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pick_phi0(
  p,
  M,
  params,
  model = c("GMAR", "StMAR", "G-StMAR"),
  restricted = FALSE,
  constraints = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pick_phi0_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="pick_phi0_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMAR</strong> and <strong>StMAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMAR type</em> components <code>M1</code> in the
first element and <em>StMAR type</em> components <code>M2</code> in the second element. The total number of mixture components is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="pick_phi0_+3A_params">params</code></td>
<td>
<p>a real valued parameter vector specifying the model.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(M(p+3)+M-M1-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=</code>(<strong><code class="reqn">\upsilon_{1}</code></strong><code class="reqn">,...,</code><strong><code class="reqn">\upsilon_{M}</code></strong>,
<code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>) where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn">=(\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,</code><code class="reqn">\sigma_{m}^2)</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p}), m=1,...,M</code>
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMAR type regimes.
</p>
</li></ul>

<p>In the <strong>GMAR</strong> model, <code class="reqn">M1=M</code> and the parameter <strong><code class="reqn">\nu</code></strong> dropped. In the <strong>StMAR</strong> model, <code class="reqn">M1=0</code>.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vectors <strong><code class="reqn">\phi_{m}</code></strong> with the vectors <strong><code class="reqn">\psi_{m}</code></strong> that satisfy
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(3M+M-M1+p-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=(\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">,</code>
<code class="reqn">\sigma_{1}^2,...,\sigma_{M}^2,</code><code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where <strong><code class="reqn">\phi</code></strong>=<code class="reqn">(\phi_{1},...,\phi_{p})</code>
contains the AR coefficients, which are common for all regimes.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vector <strong><code class="reqn">\phi</code></strong> with the vector <strong><code class="reqn">\psi</code></strong> that satisfies
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
</dl>

<p>Symbol <code class="reqn">\phi</code> denotes an AR coefficient, <code class="reqn">\sigma^2</code> a variance, <code class="reqn">\alpha</code> a mixing weight, and <code class="reqn">\nu</code> a degrees of
freedom parameter. If <code>parametrization=="mean"</code>, just replace each intercept term <code class="reqn">\phi_{m,0}</code> with the regimewise mean
<code class="reqn">\mu_m = \phi_{m,0}/(1-\sum\phi_{i,m})</code>. In the <strong>G-StMAR</strong> model, the first <code>M1</code> components are <em>GMAR type</em>
and the rest <code>M2</code> components are <em>StMAR type</em>.
Note that in the case <strong>M=1</strong>, the mixing weight parameters <code class="reqn">\alpha</code> are dropped, and in the case of <strong>StMAR</strong> or <strong>G-StMAR</strong> model,
the degrees of freedom parameters <code class="reqn">\nu</code> have to be larger than <code class="reqn">2</code>.</p>
</td></tr>
<tr><td><code id="pick_phi0_+3A_model">model</code></td>
<td>
<p>is &quot;GMAR&quot;, &quot;StMAR&quot;, or &quot;G-StMAR&quot; model considered? In the G-StMAR model, the first <code>M1</code> components
are <em>GMAR type</em> and the rest <code>M2</code> components are <em>StMAR type</em>.</p>
</td></tr>
<tr><td><code id="pick_phi0_+3A_restricted">restricted</code></td>
<td>
<p>a logical argument stating whether the AR coefficients <code class="reqn">\phi_{m,1},...,\phi_{m,p}</code> are restricted
to be the same for all regimes.</p>
</td></tr>
<tr><td><code id="pick_phi0_+3A_constraints">constraints</code></td>
<td>
<p>specifies linear constraints imposed to each regime's autoregressive parameters separately.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd><p>a list of size <code class="reqn">(pxq_{m})</code> constraint matrices <strong><code class="reqn">C_{m}</code></strong> of full column rank
satisfying <strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> for all <code class="reqn">m=1,...,M</code>, where
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p})</code> and <strong><code class="reqn">\psi_{m}</code></strong><code class="reqn">=(\psi_{m,1},...,\psi_{m,q_{m}})</code>.</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd><p>a size <code class="reqn">(pxq)</code> constraint matrix <strong><code class="reqn">C</code></strong> of full column rank satisfying
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong>, where <strong><code class="reqn">\phi</code></strong><code class="reqn">=(\phi_{1},...,\phi_{p})</code> and
<strong><code class="reqn">\psi</code></strong><code class="reqn">=\psi_{1},...,\psi_{q}</code>.</p>
</dd>
</dl>

<p>The symbol <code class="reqn">\phi</code> denotes an AR coefficient. Note that regardless of any constraints, the autoregressive order
is always <code>p</code> for all regimes.
Ignore or set to <code>NULL</code> if applying linear constraints is not desired.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of length <code>M</code> containing the phi0 or mean parameters depending
parametrization.
</p>

<hr>
<h2 id='plot.gsmarpred'>Plot method for class 'gsmarpred' objects</h2><span id='topic+plot.gsmarpred'></span>

<h3>Description</h3>

<p><code>plot.gsmarpred</code> is plot method for class 'gsmarpred' objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gsmarpred'
plot(x, ..., nt, mix_weights = TRUE, add_grid = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.gsmarpred_+3A_x">x</code></td>
<td>
<p>object of class <code>'gsmarpred'</code> created with <code>predict.gsmar</code>.</p>
</td></tr>
<tr><td><code id="plot.gsmarpred_+3A_...">...</code></td>
<td>
<p>arguments passed to function <code>grid</code>.</p>
</td></tr>
<tr><td><code id="plot.gsmarpred_+3A_nt">nt</code></td>
<td>
<p>a positive integer specifying the number of observations to be plotted
along with the prediction. Default is <code>round(length(data)*0.15)</code>.</p>
</td></tr>
<tr><td><code id="plot.gsmarpred_+3A_mix_weights">mix_weights</code></td>
<td>
<p><code>TRUE</code> if forecasts for mixing weights should be plotted, <code>FALSE</code> in not.</p>
</td></tr>
<tr><td><code id="plot.gsmarpred_+3A_add_grid">add_grid</code></td>
<td>
<p>should grid a be added to the plots?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method is intended for plotting forecasts of GSMAR processes.
</p>

<hr>
<h2 id='plot.qrtest'>Quantile residual tests for GMAR, StMAR , and G-StMAR models</h2><span id='topic+plot.qrtest'></span><span id='topic+print.qrtest'></span><span id='topic+quantile_residual_tests'></span>

<h3>Description</h3>

<p><code>quantile_residual_tests</code> performs quantile residual tests for GMAR, StMAR,
and G-StMAR models, testing normality, autocorrelation, and conditional heteroscedasticity
of the quantile residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'qrtest'
plot(x, ...)

## S3 method for class 'qrtest'
print(x, ..., digits = 3)

quantile_residual_tests(
  gsmar,
  lags_ac = c(1, 3, 6, 12),
  lags_ch = lags_ac,
  nsimu = 1,
  print_res = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.qrtest_+3A_x">x</code></td>
<td>
<p>object of class <code>'qrtest'</code> created with the function <code>quantile_residual_tests</code>.</p>
</td></tr>
<tr><td><code id="plot.qrtest_+3A_...">...</code></td>
<td>
<p>graphical parameters passed to <code>segments</code> in <code>plot.qrtest</code>.
Currently not used in <code>print.qrtest</code></p>
</td></tr>
<tr><td><code id="plot.qrtest_+3A_digits">digits</code></td>
<td>
<p>the number of digits to be print</p>
</td></tr>
<tr><td><code id="plot.qrtest_+3A_gsmar">gsmar</code></td>
<td>
<p>a class 'gsmar' object, typically generated by <code>fitGSMAR</code> or <code>GSMAR</code>.</p>
</td></tr>
<tr><td><code id="plot.qrtest_+3A_lags_ac">lags_ac</code></td>
<td>
<p>a numeric vector of positive integers specifying the lags for which autocorrelation is tested.</p>
</td></tr>
<tr><td><code id="plot.qrtest_+3A_lags_ch">lags_ch</code></td>
<td>
<p>a numeric vector of positive integers specifying the lags for which conditional heteroscedasticity
is tested.</p>
</td></tr>
<tr><td><code id="plot.qrtest_+3A_nsimu">nsimu</code></td>
<td>
<p>a positive integer specifying to how many simulated observations the covariance matrix Omega
(see Kalliovirta (2012)) should be based on. If smaller than data size, then omega will be based on the
given data and not on simulated data. Having the covariance matrix omega based on a large simulated sample
might improve the tests size properties.</p>
</td></tr>
<tr><td><code id="plot.qrtest_+3A_print_res">print_res</code></td>
<td>
<p>a logical argument defining whether the results should be printed or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a correctly specified GSMAR model employing the maximum likelihood estimator, the quantile residuals
are asymptotically independent with standard normal distribution. They can hence be used in a similar
manner to conventional Pearson's residuals. For more details about quantile residual based diagnostics,
and in particular, about the quantile residual tests, see the cited article by <em>Kalliovirta (2012)</em>.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>'qrtest'</code> containing the test results in data frames. In the cases
of autocorrelation and conditional heteroscedasticity tests, the returned object also contains the
associated individual statistics and their standard errors, discussed in <em>Kalliovirta (2012)</em> at
the pages 369-370.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>plot(qrtest)</code>: Plot p-values of the autocorrelation and conditional
heteroskedasticity tests.
</p>
</li>
<li> <p><code>print(qrtest)</code>: Print method for class 'qrtest' objects
</p>
</li></ul>


<h3>References</h3>


<ul>
<li><p> Galbraith, R., Galbraith, J. 1974. On the inverses of some patterned matrices arising
in the theory of stationary time series. <em>Journal of Applied Probability</em> <strong>11</strong>, 63-71.
</p>
</li>
<li><p> Kalliovirta L. (2012) Misspecification tests based on quantile residuals.
<em>The Econometrics Journal</em>, <strong>15</strong>, 358-393.
</p>
</li>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2015. Gaussian Mixture Autoregressive model for univariate time series.
<em>Journal of Time Series Analysis</em>, <strong>36</strong>(2), 247-266.
</p>
</li>
<li><p> Meitz M., Preve D., Saikkonen P. 2023. A mixture autoregressive model based on Student's t-distribution.
<em>Communications in Statistics - Theory and Methods</em>, <strong>52</strong>(2), 499-515.
</p>
</li>
<li><p> Virolainen S. 2022. A mixture autoregressive model based on Gaussian and Student's t-distributions.
Studies in Nonlinear Dynamics &amp; Econometrics, <strong>26</strong>(4) 559-580.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+profile_logliks">profile_logliks</a></code>, <code><a href="#topic+fitGSMAR">fitGSMAR</a></code>, <code><a href="#topic+GSMAR">GSMAR</a></code>, <code><a href="#topic+diagnostic_plot">diagnostic_plot</a></code>,
<code><a href="#topic+predict.gsmar">predict.gsmar</a></code>, <code><a href="#topic+get_test_Omega">get_test_Omega</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The below examples take approximately 30 seconds to run.

# G-StMAR model with one GMAR type and one StMAR type regime
fit42gs &lt;- fitGSMAR(data=M10Y1Y, p=4, M=c(1, 1), model="G-StMAR",
                    ncalls=1, seeds=4)

# Tests based on the observed data (without simulation procedure) with the
# default lags:
qrt1 &lt;- quantile_residual_tests(fit42gs)

# Tests based on the simulation procedure using sample size 10000 and with
# the lags specified by hand:
set.seed(1)
qrt2 &lt;- quantile_residual_tests(fit42gs, lags_ac=c(1, 6), nsimu=10000)

# GMAR model
fit12 &lt;- fitGSMAR(data=simudata, p=1, M=2, model="GMAR", ncalls=1, seeds=1)
qrt3 &lt;- quantile_residual_tests(fit12, lags_ac=c(1, 5, 10, 15))

</code></pre>

<hr>
<h2 id='predict.gsmar'>Forecast GMAR, StMAR, or G-StMAR process</h2><span id='topic+predict.gsmar'></span>

<h3>Description</h3>

<p><code>predict.gsmar</code> forecasts the specified GMAR, StMAR, or G-StMAR process by using the given
data to simulate its possible future values. For one-step forecasts using the exact formula for conditional
mean is supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gsmar'
predict(
  object,
  ...,
  n_ahead,
  nsimu = 10000,
  pi = c(0.95, 0.8),
  pred_type = c("median", "mean", "cond_mean"),
  pi_type = c("two-sided", "upper", "lower", "none"),
  plot_res = TRUE,
  mix_weights = TRUE,
  nt
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.gsmar_+3A_object">object</code></td>
<td>
<p>object of class <code>'gsmar'</code> created with function <code>fitGSMAR</code> or <code>GSMAR</code>.</p>
</td></tr>
<tr><td><code id="predict.gsmar_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>grid</code> (ignored if <code>plot_res==FALSE</code>).</p>
</td></tr>
<tr><td><code id="predict.gsmar_+3A_n_ahead">n_ahead</code></td>
<td>
<p>a positive integer specifying how many steps in the future should be forecasted.</p>
</td></tr>
<tr><td><code id="predict.gsmar_+3A_nsimu">nsimu</code></td>
<td>
<p>a positive integer specifying to how many simulations the forecast should be based on.</p>
</td></tr>
<tr><td><code id="predict.gsmar_+3A_pi">pi</code></td>
<td>
<p>a numeric vector specifying confidence levels for the prediction intervals.</p>
</td></tr>
<tr><td><code id="predict.gsmar_+3A_pred_type">pred_type</code></td>
<td>
<p>should the prediction be based on sample &quot;median&quot; or &quot;mean&quot;? Or should it
be one-step-ahead forecast based on the exact conditional mean (<code>"cond_mean"</code>)? prediction
intervals won't be calculated if the exact conditional mean is used.</p>
</td></tr>
<tr><td><code id="predict.gsmar_+3A_pi_type">pi_type</code></td>
<td>
<p>should the prediction intervals be &quot;two-sided&quot;, &quot;upper&quot;, or &quot;lower&quot;?</p>
</td></tr>
<tr><td><code id="predict.gsmar_+3A_plot_res">plot_res</code></td>
<td>
<p>a logical argument defining whether the forecast should be plotted or not.</p>
</td></tr>
<tr><td><code id="predict.gsmar_+3A_mix_weights">mix_weights</code></td>
<td>
<p><code>TRUE</code> if forecasts for mixing weights should be plotted, <code>FALSE</code> in not.</p>
</td></tr>
<tr><td><code id="predict.gsmar_+3A_nt">nt</code></td>
<td>
<p>a positive integer specifying the number of observations to be plotted
along with the prediction. Default is <code>round(length(data)*0.15)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>predict.gsmar</code> uses the last <code>p</code> values of the data to simulate <code>nsimu</code>
possible future values for each step-ahead. The point prediction is then obtained by calculating
the sample median or mean for each step and the prediction intervals are obtained from the
empirical fractiles.
</p>
<p>The function <code>simulate.gsmar</code> can also be used directly for quantile based forecasting.
</p>


<h3>Value</h3>

<p>Returns a class <code>'gsmarpred'</code> object containing, among the specifications,...
</p>
<table>
<tr><td><code>$pred</code></td>
<td>
<p>Point forecasts</p>
</td></tr>
<tr><td><code>$pred_ints</code></td>
<td>
<p>Prediction intervals</p>
</td></tr>
<tr><td><code>$mix_pred</code></td>
<td>
<p>Point forecasts for mixing weights</p>
</td></tr>
<tr><td><code>mix_pred_ints</code></td>
<td>
<p>Individual prediction intervals for mixing weights, as <code>[, , m]</code>, m=1,..,M.</p>
</td></tr>
</table>


<h3>References</h3>


<ul>
<li><p> Galbraith, R., Galbraith, J. 1974. On the inverses of some patterned matrices arising
in the theory of stationary time series. <em>Journal of Applied Probability</em> <strong>11</strong>, 63-71.
</p>
</li>
<li><p> Kalliovirta L. (2012) Misspecification tests based on quantile residuals.
<em>The Econometrics Journal</em>, <strong>15</strong>, 358-393.
</p>
</li>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2015. Gaussian Mixture Autoregressive model for univariate time series.
<em>Journal of Time Series Analysis</em>, <strong>36</strong>(2), 247-266.
</p>
</li>
<li><p> Meitz M., Preve D., Saikkonen P. 2023. A mixture autoregressive model based on Student's t-distribution.
<em>Communications in Statistics - Theory and Methods</em>, <strong>52</strong>(2), 499-515.
</p>
</li>
<li><p> Virolainen S. 2022. A mixture autoregressive model based on Gaussian and Student's t-distributions.
Studies in Nonlinear Dynamics &amp; Econometrics, <strong>26</strong>(4) 559-580.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+simulate.gsmar">simulate.gsmar</a></code>, <code><a href="#topic+cond_moments">cond_moments</a></code>, <code><a href="#topic+fitGSMAR">fitGSMAR</a></code>, <code><a href="#topic+GSMAR">GSMAR</a></code>,
<code><a href="#topic+quantile_residual_tests">quantile_residual_tests</a></code>, <code><a href="#topic+diagnostic_plot">diagnostic_plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## These examples take approximately 30 seconds to run.

# G-StMAR model with one GMAR type and one StMAR type regime
fit42gs &lt;- fitGSMAR(M10Y1Y, p=4, M=c(1, 1), model="G-StMAR",
                    ncalls=1, seeds=4)

# Forecast 12 steps ahead based on 10000 simulated sample paths, prediction
# interval confidence levels 0.95 and 0.8, prediction based on sample median,
# and two-sided prediction intevals:
mypred &lt;- predict(fit42gs, n_ahead=12, nsimu=10000, pi=c(0.95, 0.8),
                  pred_type="median", pi_type="two-sided")
mypred
plot(mypred)

# Forecast 24 steps ahead based on 1000 simulated sample paths, prediction
# interval confidence level 0.99 and 0.9, prediction based on sample mean,
# and upper prediction intevals:
mypred2 &lt;- predict(fit42gs, n_ahead=24, nsimu=1000, pi=c(0.99, 0.9),
                   pred_type="mean", pi_type="upper")

# Forecast 24 steps ahead based on 1000 simulated sample paths, prediction
# interval confidence level 0.99, 0.95, 0.9 and 0.8, prediction based on
# sample median, and lower prediction intevals:
mypred3 &lt;- predict(fit42gs, n_ahead=24, nsimu=1000, pi=c(0.99, 0.95, 0.9, 0.8),
                   pred_type="median", pi_type="lower")

# GMAR model
params12 &lt;- c(1.70, 0.85, 0.30, 4.12, 0.73, 1.98, 0.63)
gmar12 &lt;- GSMAR(data=simudata, p=1, M=2, params=params12, model="GMAR")
pred12 &lt;- predict(gmar12, n_ahead=10, nsimu=1000, pi=c(0.95, 0.9, 0.8),
                  pred_type="median", pi_type="two-sided")
pred12
plot(pred12)

# One-step prediction based on the exact conditional mean:
predict(gmar12, n_ahead=1, pred_type="cond_mean", plot_res=FALSE)

</code></pre>

<hr>
<h2 id='print.gsmarpred'>Print method for class 'gsmarpred' objects</h2><span id='topic+print.gsmarpred'></span>

<h3>Description</h3>

<p><code>print.gsmarpred</code> is a print method for call 'gsmarpred'
objects created with <code>predict.gsmar</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gsmarpred'
print(x, ..., digits = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.gsmarpred_+3A_x">x</code></td>
<td>
<p>object of class <code>'gsmarpred'</code> generated by <code>predict.gsmar</code>.</p>
</td></tr>
<tr><td><code id="print.gsmarpred_+3A_...">...</code></td>
<td>
<p>currently not in use.</p>
</td></tr>
<tr><td><code id="print.gsmarpred_+3A_digits">digits</code></td>
<td>
<p>the number of digits to be printed</p>
</td></tr>
</table>

<hr>
<h2 id='print.gsmarsum'>Print method from objects of class 'gsmarsum'</h2><span id='topic+print.gsmarsum'></span>

<h3>Description</h3>

<p><code>print.gsmarsum</code> is a print method for objects of class 'gsmarsum'
created with the summary method <code>summary.gsmar</code>. Approximate standard errors
are printed in brackets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gsmarsum'
print(x, ..., digits)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.gsmarsum_+3A_x">x</code></td>
<td>
<p>object of class 'gsmarsum' generated by <code>summary.gsmar</code>.</p>
</td></tr>
<tr><td><code id="print.gsmarsum_+3A_...">...</code></td>
<td>
<p>currently not in use.</p>
</td></tr>
<tr><td><code id="print.gsmarsum_+3A_digits">digits</code></td>
<td>
<p>the number of digits to be printed</p>
</td></tr>
</table>

<hr>
<h2 id='profile_logliks'>Plot profile log-likelihoods around the estimates</h2><span id='topic+profile_logliks'></span>

<h3>Description</h3>

<p><code>profile_logliks</code> plots profile log-likelihoods around the estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>profile_logliks(gsmar, scale = 0.02, nrows, ncols, precision = 200)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="profile_logliks_+3A_gsmar">gsmar</code></td>
<td>
<p>a class 'gsmar' object, typically generated by <code>fitGSMAR</code> or <code>GSMAR</code>.</p>
</td></tr>
<tr><td><code id="profile_logliks_+3A_scale">scale</code></td>
<td>
<p>a numeric scalar specifying the interval plotted for each estimate: the estimate plus-minus <code>abs(scale*estimate)</code>.</p>
</td></tr>
<tr><td><code id="profile_logliks_+3A_nrows">nrows</code></td>
<td>
<p>how many rows should be in the plot-matrix? The default is <code>max(ceiling(log2(nparams) - 1), 1)</code>.</p>
</td></tr>
<tr><td><code id="profile_logliks_+3A_ncols">ncols</code></td>
<td>
<p>how many columns should be in the plot-matrix? The default is <code>ceiling(nparams/nrows)</code>.
Note that <code>nrows*ncols</code> should not be smaller than the number of parameters.</p>
</td></tr>
<tr><td><code id="profile_logliks_+3A_precision">precision</code></td>
<td>
<p>at how many points should each profile log-likelihood be evaluated at?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The red vertical line points the estimate.
</p>
<p>Be aware that the profile log-likelihood function is subject to a numerical error due to limited float-point
precision when considering extremely large parameter values, say, overly large degrees freedom estimates.
</p>


<h3>Value</h3>

<p>Only plots to a graphical device and doesn't return anything.
</p>


<h3>References</h3>


<ul>
<li><p> Galbraith, R., Galbraith, J. 1974. On the inverses of some patterned matrices arising
in the theory of stationary time series. <em>Journal of Applied Probability</em> <strong>11</strong>, 63-71.
</p>
</li>
<li><p> Kalliovirta L. (2012) Misspecification tests based on quantile residuals.
<em>The Econometrics Journal</em>, <strong>15</strong>, 358-393.
</p>
</li>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2015. Gaussian Mixture Autoregressive model for univariate time series.
<em>Journal of Time Series Analysis</em>, <strong>36</strong>(2), 247-266.
</p>
</li>
<li><p> Meitz M., Preve D., Saikkonen P. 2023. A mixture autoregressive model based on Student's t-distribution.
<em>Communications in Statistics - Theory and Methods</em>, <strong>52</strong>(2), 499-515.
</p>
</li>
<li><p> Virolainen S. 2022. A mixture autoregressive model based on Gaussian and Student's t-distributions.
Studies in Nonlinear Dynamics &amp; Econometrics, <strong>26</strong>(4) 559-580.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+quantile_residual_plot">quantile_residual_plot</a></code>, <code><a href="#topic+diagnostic_plot">diagnostic_plot</a></code>, <code><a href="#topic+cond_moment_plot">cond_moment_plot</a></code>, <code><a href="#topic+GSMAR">GSMAR</a></code>,
<code><a href="#topic+quantile_residual_tests">quantile_residual_tests</a></code>, <code><a href="#topic+simulate.gsmar">simulate.gsmar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The below examples the approximately 15 seconds to run.

# G-StMAR model with one GMAR type and one StMAR type regime
fit42gs &lt;- fitGSMAR(M10Y1Y, p=4, M=c(1, 1), model="G-StMAR",
                    ncalls=1, seeds=4)
profile_logliks(fit42gs)

# GMAR model, graphs zoomed in closer.
fit12 &lt;- fitGSMAR(data=simudata, p=1, M=2, model="GMAR", ncalls=1, seeds=1)
profile_logliks(fit12, scale=0.001)

</code></pre>

<hr>
<h2 id='quantile_residual_plot'>Plot quantile residual time series and histogram</h2><span id='topic+quantile_residual_plot'></span>

<h3>Description</h3>

<p><code>quantile_residualsPlot</code> plots quantile residual time series and histogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantile_residual_plot(gsmar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile_residual_plot_+3A_gsmar">gsmar</code></td>
<td>
<p>a class 'gsmar' object, typically generated by <code>fitGSMAR</code> or <code>GSMAR</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Only plots to a graphical device and doesn't return anything.
</p>


<h3>References</h3>


<ul>
<li><p> Galbraith, R., Galbraith, J. 1974. On the inverses of some patterned matrices arising
in the theory of stationary time series. <em>Journal of Applied Probability</em> <strong>11</strong>, 63-71.
</p>
</li>
<li><p> Kalliovirta L. (2012) Misspecification tests based on quantile residuals.
<em>The Econometrics Journal</em>, <strong>15</strong>, 358-393.
</p>
</li>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2015. Gaussian Mixture Autoregressive model for univariate time series.
<em>Journal of Time Series Analysis</em>, <strong>36</strong>(2), 247-266.
</p>
</li>
<li><p> Meitz M., Preve D., Saikkonen P. 2023. A mixture autoregressive model based on Student's t-distribution.
<em>Communications in Statistics - Theory and Methods</em>, <strong>52</strong>(2), 499-515.
</p>
</li>
<li><p> Virolainen S. 2022. A mixture autoregressive model based on Gaussian and Student's t-distributions.
Studies in Nonlinear Dynamics &amp; Econometrics, <strong>26</strong>(4) 559-580.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+profile_logliks">profile_logliks</a></code>, <code><a href="#topic+diagnostic_plot">diagnostic_plot</a></code>, <code><a href="#topic+fitGSMAR">fitGSMAR</a></code>, <code><a href="#topic+GSMAR">GSMAR</a></code>,
<code><a href="#topic+quantile_residual_tests">quantile_residual_tests</a></code>, <code><a href="#topic+simulate.gsmar">simulate.gsmar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The below examples the approximately 15 seconds to run.

# G-StMAR model with one GMAR type and one StMAR type regime
fit42gs &lt;- fitGSMAR(M10Y1Y, p=4, M=c(1, 1), model="G-StMAR",
                    ncalls=1, seeds=4)
quantile_residual_plot(fit42gs)

# GMAR model
fit12 &lt;- fitGSMAR(data=simudata, p=1, M=2, model="GMAR", ncalls=1, seeds=1)
quantile_residual_plot(fit12)

</code></pre>

<hr>
<h2 id='quantile_residuals'>Compute quantile residuals of GMAR, StMAR, or G-StMAR model</h2><span id='topic+quantile_residuals'></span>

<h3>Description</h3>

<p><code>quantile_residuals</code> computes the quantile residuals of the specified GMAR, StMAR, or G-StMAR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantile_residuals(
  data,
  p,
  M,
  params,
  model = c("GMAR", "StMAR", "G-StMAR"),
  restricted = FALSE,
  constraints = NULL,
  parametrization = c("intercept", "mean")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile_residuals_+3A_data">data</code></td>
<td>
<p>a numeric vector or class <code>'ts'</code> object containing the data. <code>NA</code> values are not supported.</p>
</td></tr>
<tr><td><code id="quantile_residuals_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="quantile_residuals_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMAR</strong> and <strong>StMAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMAR type</em> components <code>M1</code> in the
first element and <em>StMAR type</em> components <code>M2</code> in the second element. The total number of mixture components is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="quantile_residuals_+3A_params">params</code></td>
<td>
<p>a real valued parameter vector specifying the model.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(M(p+3)+M-M1-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=</code>(<strong><code class="reqn">\upsilon_{1}</code></strong><code class="reqn">,...,</code><strong><code class="reqn">\upsilon_{M}</code></strong>,
<code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>) where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn">=(\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,</code><code class="reqn">\sigma_{m}^2)</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p}), m=1,...,M</code>
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMAR type regimes.
</p>
</li></ul>

<p>In the <strong>GMAR</strong> model, <code class="reqn">M1=M</code> and the parameter <strong><code class="reqn">\nu</code></strong> dropped. In the <strong>StMAR</strong> model, <code class="reqn">M1=0</code>.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vectors <strong><code class="reqn">\phi_{m}</code></strong> with the vectors <strong><code class="reqn">\psi_{m}</code></strong> that satisfy
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(3M+M-M1+p-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=(\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">,</code>
<code class="reqn">\sigma_{1}^2,...,\sigma_{M}^2,</code><code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where <strong><code class="reqn">\phi</code></strong>=<code class="reqn">(\phi_{1},...,\phi_{p})</code>
contains the AR coefficients, which are common for all regimes.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vector <strong><code class="reqn">\phi</code></strong> with the vector <strong><code class="reqn">\psi</code></strong> that satisfies
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
</dl>

<p>Symbol <code class="reqn">\phi</code> denotes an AR coefficient, <code class="reqn">\sigma^2</code> a variance, <code class="reqn">\alpha</code> a mixing weight, and <code class="reqn">\nu</code> a degrees of
freedom parameter. If <code>parametrization=="mean"</code>, just replace each intercept term <code class="reqn">\phi_{m,0}</code> with the regimewise mean
<code class="reqn">\mu_m = \phi_{m,0}/(1-\sum\phi_{i,m})</code>. In the <strong>G-StMAR</strong> model, the first <code>M1</code> components are <em>GMAR type</em>
and the rest <code>M2</code> components are <em>StMAR type</em>.
Note that in the case <strong>M=1</strong>, the mixing weight parameters <code class="reqn">\alpha</code> are dropped, and in the case of <strong>StMAR</strong> or <strong>G-StMAR</strong> model,
the degrees of freedom parameters <code class="reqn">\nu</code> have to be larger than <code class="reqn">2</code>.</p>
</td></tr>
<tr><td><code id="quantile_residuals_+3A_model">model</code></td>
<td>
<p>is &quot;GMAR&quot;, &quot;StMAR&quot;, or &quot;G-StMAR&quot; model considered? In the G-StMAR model, the first <code>M1</code> components
are <em>GMAR type</em> and the rest <code>M2</code> components are <em>StMAR type</em>.</p>
</td></tr>
<tr><td><code id="quantile_residuals_+3A_restricted">restricted</code></td>
<td>
<p>a logical argument stating whether the AR coefficients <code class="reqn">\phi_{m,1},...,\phi_{m,p}</code> are restricted
to be the same for all regimes.</p>
</td></tr>
<tr><td><code id="quantile_residuals_+3A_constraints">constraints</code></td>
<td>
<p>specifies linear constraints imposed to each regime's autoregressive parameters separately.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd><p>a list of size <code class="reqn">(pxq_{m})</code> constraint matrices <strong><code class="reqn">C_{m}</code></strong> of full column rank
satisfying <strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> for all <code class="reqn">m=1,...,M</code>, where
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p})</code> and <strong><code class="reqn">\psi_{m}</code></strong><code class="reqn">=(\psi_{m,1},...,\psi_{m,q_{m}})</code>.</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd><p>a size <code class="reqn">(pxq)</code> constraint matrix <strong><code class="reqn">C</code></strong> of full column rank satisfying
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong>, where <strong><code class="reqn">\phi</code></strong><code class="reqn">=(\phi_{1},...,\phi_{p})</code> and
<strong><code class="reqn">\psi</code></strong><code class="reqn">=\psi_{1},...,\psi_{q}</code>.</p>
</dd>
</dl>

<p>The symbol <code class="reqn">\phi</code> denotes an AR coefficient. Note that regardless of any constraints, the autoregressive order
is always <code>p</code> for all regimes.
Ignore or set to <code>NULL</code> if applying linear constraints is not desired.</p>
</td></tr>
<tr><td><code id="quantile_residuals_+3A_parametrization">parametrization</code></td>
<td>
<p>is the model parametrized with the &quot;intercepts&quot; <code class="reqn">\phi_{m,0}</code> or
&quot;means&quot; <code class="reqn">\mu_{m} = \phi_{m,0}/(1-\sum\phi_{i,m})</code>?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Numerical integration is employed if the quantile residuals cannot be obtained analytically with the
hypergeometric function using the package 'gsl'.
</p>


<h3>Value</h3>

<p>Returns a <code class="reqn">(Tx1)</code> numeric vector containing the quantile residuals of the specified GMAR, StMAR or G-StMAR model.
Note that there are no quantile residuals for the first <code>p</code> observations as they are the initial values.
</p>


<h3>References</h3>


<ul>
<li><p> Galbraith, R., Galbraith, J. 1974. On the inverses of some patterned matrices arising
in the theory of stationary time series. <em>Journal of Applied Probability</em> <strong>11</strong>, 63-71.
</p>
</li>
<li><p> Kalliovirta L. (2012) Misspecification tests based on quantile residuals.
<em>The Econometrics Journal</em>, <strong>15</strong>, 358-393.
</p>
</li>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2015. Gaussian Mixture Autoregressive model for univariate time series.
<em>Journal of Time Series Analysis</em>, <strong>36</strong>(2), 247-266.
</p>
</li>
<li><p> Meitz M., Preve D., Saikkonen P. 2023. A mixture autoregressive model based on Student's t-distribution.
<em>Communications in Statistics - Theory and Methods</em>, <strong>52</strong>(2), 499-515.
</p>
</li>
<li><p> Virolainen S. 2022. A mixture autoregressive model based on Gaussian and Student's t-distributions.
Studies in Nonlinear Dynamics &amp; Econometrics, <strong>26</strong>(4) 559-580.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># GMAR model
params12 &lt;- c(1.70, 0.85, 0.30, 4.12, 0.73, 1.98, 0.63)
quantile_residuals(simudata, p=1, M=2, params=params12, model="GMAR")

# G-StMAR-model
params42gs &lt;- c(0.04, 1.34, -0.59, 0.54, -0.36, 0.01, 0.06, 1.28, -0.36,
                0.2, -0.15, 0.04, 0.19, 9.75)
quantile_residuals(M10Y1Y, p=4, M=c(1, 1), params=params42gs, model="G-StMAR")
</code></pre>

<hr>
<h2 id='quantile_residuals_int'>Compute quantile residuals of GMAR, StMAR, or G-StMAR model</h2><span id='topic+quantile_residuals_int'></span>

<h3>Description</h3>

<p><code>quantile_residuals_int</code> computes the quantile residuals of the specified GMAR, StMAR, or G-StMAR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantile_residuals_int(
  data,
  p,
  M,
  params,
  model = c("GMAR", "StMAR", "G-StMAR"),
  restricted = FALSE,
  constraints = NULL,
  parametrization = c("intercept", "mean")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile_residuals_int_+3A_data">data</code></td>
<td>
<p>a numeric vector or class <code>'ts'</code> object containing the data. <code>NA</code> values are not supported.</p>
</td></tr>
<tr><td><code id="quantile_residuals_int_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="quantile_residuals_int_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMAR</strong> and <strong>StMAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMAR type</em> components <code>M1</code> in the
first element and <em>StMAR type</em> components <code>M2</code> in the second element. The total number of mixture components is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="quantile_residuals_int_+3A_params">params</code></td>
<td>
<p>a real valued parameter vector specifying the model.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(M(p+3)+M-M1-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=</code>(<strong><code class="reqn">\upsilon_{1}</code></strong><code class="reqn">,...,</code><strong><code class="reqn">\upsilon_{M}</code></strong>,
<code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>) where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn">=(\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,</code><code class="reqn">\sigma_{m}^2)</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p}), m=1,...,M</code>
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMAR type regimes.
</p>
</li></ul>

<p>In the <strong>GMAR</strong> model, <code class="reqn">M1=M</code> and the parameter <strong><code class="reqn">\nu</code></strong> dropped. In the <strong>StMAR</strong> model, <code class="reqn">M1=0</code>.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vectors <strong><code class="reqn">\phi_{m}</code></strong> with the vectors <strong><code class="reqn">\psi_{m}</code></strong> that satisfy
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(3M+M-M1+p-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=(\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">,</code>
<code class="reqn">\sigma_{1}^2,...,\sigma_{M}^2,</code><code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where <strong><code class="reqn">\phi</code></strong>=<code class="reqn">(\phi_{1},...,\phi_{p})</code>
contains the AR coefficients, which are common for all regimes.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vector <strong><code class="reqn">\phi</code></strong> with the vector <strong><code class="reqn">\psi</code></strong> that satisfies
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
</dl>

<p>Symbol <code class="reqn">\phi</code> denotes an AR coefficient, <code class="reqn">\sigma^2</code> a variance, <code class="reqn">\alpha</code> a mixing weight, and <code class="reqn">\nu</code> a degrees of
freedom parameter. If <code>parametrization=="mean"</code>, just replace each intercept term <code class="reqn">\phi_{m,0}</code> with the regimewise mean
<code class="reqn">\mu_m = \phi_{m,0}/(1-\sum\phi_{i,m})</code>. In the <strong>G-StMAR</strong> model, the first <code>M1</code> components are <em>GMAR type</em>
and the rest <code>M2</code> components are <em>StMAR type</em>.
Note that in the case <strong>M=1</strong>, the mixing weight parameters <code class="reqn">\alpha</code> are dropped, and in the case of <strong>StMAR</strong> or <strong>G-StMAR</strong> model,
the degrees of freedom parameters <code class="reqn">\nu</code> have to be larger than <code class="reqn">2</code>.</p>
</td></tr>
<tr><td><code id="quantile_residuals_int_+3A_model">model</code></td>
<td>
<p>is &quot;GMAR&quot;, &quot;StMAR&quot;, or &quot;G-StMAR&quot; model considered? In the G-StMAR model, the first <code>M1</code> components
are <em>GMAR type</em> and the rest <code>M2</code> components are <em>StMAR type</em>.</p>
</td></tr>
<tr><td><code id="quantile_residuals_int_+3A_restricted">restricted</code></td>
<td>
<p>a logical argument stating whether the AR coefficients <code class="reqn">\phi_{m,1},...,\phi_{m,p}</code> are restricted
to be the same for all regimes.</p>
</td></tr>
<tr><td><code id="quantile_residuals_int_+3A_constraints">constraints</code></td>
<td>
<p>specifies linear constraints imposed to each regime's autoregressive parameters separately.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd><p>a list of size <code class="reqn">(pxq_{m})</code> constraint matrices <strong><code class="reqn">C_{m}</code></strong> of full column rank
satisfying <strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> for all <code class="reqn">m=1,...,M</code>, where
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p})</code> and <strong><code class="reqn">\psi_{m}</code></strong><code class="reqn">=(\psi_{m,1},...,\psi_{m,q_{m}})</code>.</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd><p>a size <code class="reqn">(pxq)</code> constraint matrix <strong><code class="reqn">C</code></strong> of full column rank satisfying
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong>, where <strong><code class="reqn">\phi</code></strong><code class="reqn">=(\phi_{1},...,\phi_{p})</code> and
<strong><code class="reqn">\psi</code></strong><code class="reqn">=\psi_{1},...,\psi_{q}</code>.</p>
</dd>
</dl>

<p>The symbol <code class="reqn">\phi</code> denotes an AR coefficient. Note that regardless of any constraints, the autoregressive order
is always <code>p</code> for all regimes.
Ignore or set to <code>NULL</code> if applying linear constraints is not desired.</p>
</td></tr>
<tr><td><code id="quantile_residuals_int_+3A_parametrization">parametrization</code></td>
<td>
<p>is the model parametrized with the &quot;intercepts&quot; <code class="reqn">\phi_{m,0}</code> or
&quot;means&quot; <code class="reqn">\mu_{m} = \phi_{m,0}/(1-\sum\phi_{i,m})</code>?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Numerical integration is employed if the quantile residuals cannot be obtained analytically with the
hypergeometric function using the package 'gsl'.
</p>


<h3>Value</h3>

<p>Returns a <code class="reqn">(Tx1)</code> numeric vector containing the quantile residuals of the specified GMAR, StMAR or G-StMAR model.
Note that there are no quantile residuals for the first <code>p</code> observations as they are the initial values.
</p>


<h3>References</h3>


<ul>
<li><p> Galbraith, R., Galbraith, J. 1974. On the inverses of some patterned matrices arising
in the theory of stationary time series. <em>Journal of Applied Probability</em> <strong>11</strong>, 63-71.
</p>
</li>
<li><p> Kalliovirta L. (2012) Misspecification tests based on quantile residuals.
<em>The Econometrics Journal</em>, <strong>15</strong>, 358-393.
</p>
</li>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2015. Gaussian Mixture Autoregressive model for univariate time series.
<em>Journal of Time Series Analysis</em>, <strong>36</strong>(2), 247-266.
</p>
</li>
<li><p> Meitz M., Preve D., Saikkonen P. 2023. A mixture autoregressive model based on Student's t-distribution.
<em>Communications in Statistics - Theory and Methods</em>, <strong>52</strong>(2), 499-515.
</p>
</li>
<li><p> Virolainen S. 2022. A mixture autoregressive model based on Gaussian and Student's t-distributions.
Studies in Nonlinear Dynamics &amp; Econometrics, <strong>26</strong>(4) 559-580.
</p>
</li></ul>


<hr>
<h2 id='quantileResidualPlot'>DEPRECATED, USE <code>quantile_residual_plot</code> INSTEAD! Plot quantile residual time series and histogram</h2><span id='topic+quantileResidualPlot'></span>

<h3>Description</h3>

<p><code>quantileResidualsPlot</code> plots quantile residual time series and histogram.
DEPRECATED, USE <code>quantile_residual_plot</code> INSTEAD!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantileResidualPlot(gsmar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantileResidualPlot_+3A_gsmar">gsmar</code></td>
<td>
<p>a class 'gsmar' object, typically generated by <code>fitGSMAR</code> or <code>GSMAR</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>DEPRECATED, USE <code>quantile_residual_plot</code> INSTEAD!
</p>


<h3>Value</h3>

<p>Only plots to a graphical device and doesn't return anything.
</p>


<h3>References</h3>


<ul>
<li><p> Galbraith, R., Galbraith, J. 1974. On the inverses of some patterned matrices arising
in the theory of stationary time series. <em>Journal of Applied Probability</em> <strong>11</strong>, 63-71.
</p>
</li>
<li><p> Kalliovirta L. (2012) Misspecification tests based on quantile residuals.
<em>The Econometrics Journal</em>, <strong>15</strong>, 358-393.
</p>
</li>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2015. Gaussian Mixture Autoregressive model for univariate time series.
<em>Journal of Time Series Analysis</em>, <strong>36</strong>(2), 247-266.
</p>
</li>
<li><p> Meitz M., Preve D., Saikkonen P. 2023. A mixture autoregressive model based on Student's t-distribution.
<em>Communications in Statistics - Theory and Methods</em>, <strong>52</strong>(2), 499-515.
</p>
</li>
<li><p> Virolainen S. 2022. A mixture autoregressive model based on Gaussian and Student's t-distributions.
Studies in Nonlinear Dynamics &amp; Econometrics, <strong>26</strong>(4) 559-580.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+profile_logliks">profile_logliks</a></code>, <code><a href="#topic+diagnostic_plot">diagnostic_plot</a></code>, <code><a href="#topic+fitGSMAR">fitGSMAR</a></code>, <code><a href="#topic+GSMAR">GSMAR</a></code>,
<code><a href="#topic+quantile_residual_tests">quantile_residual_tests</a></code>, <code><a href="#topic+simulate.gsmar">simulate.gsmar</a></code>
</p>

<hr>
<h2 id='quantileResiduals'>DEPRECATED, USE <code>quantile_residuals</code> INSTEAD! Compute quantile residuals of GMAR, StMAR, or G-StMAR model</h2><span id='topic+quantileResiduals'></span>

<h3>Description</h3>

<p><code>quantileResiduals</code> computes the quantile residuals of the specified GMAR, StMAR, or G-StMAR model.
DEPRECATED, USE <code>quantile_residuals</code> INSTEAD!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantileResiduals(
  data,
  p,
  M,
  params,
  model = c("GMAR", "StMAR", "G-StMAR"),
  restricted = FALSE,
  constraints = NULL,
  parametrization = c("intercept", "mean")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantileResiduals_+3A_data">data</code></td>
<td>
<p>a numeric vector or class <code>'ts'</code> object containing the data. <code>NA</code> values are not supported.</p>
</td></tr>
<tr><td><code id="quantileResiduals_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="quantileResiduals_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMAR</strong> and <strong>StMAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMAR type</em> components <code>M1</code> in the
first element and <em>StMAR type</em> components <code>M2</code> in the second element. The total number of mixture components is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="quantileResiduals_+3A_params">params</code></td>
<td>
<p>a real valued parameter vector specifying the model.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(M(p+3)+M-M1-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=</code>(<strong><code class="reqn">\upsilon_{1}</code></strong><code class="reqn">,...,</code><strong><code class="reqn">\upsilon_{M}</code></strong>,
<code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>) where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn">=(\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,</code><code class="reqn">\sigma_{m}^2)</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p}), m=1,...,M</code>
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMAR type regimes.
</p>
</li></ul>

<p>In the <strong>GMAR</strong> model, <code class="reqn">M1=M</code> and the parameter <strong><code class="reqn">\nu</code></strong> dropped. In the <strong>StMAR</strong> model, <code class="reqn">M1=0</code>.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vectors <strong><code class="reqn">\phi_{m}</code></strong> with the vectors <strong><code class="reqn">\psi_{m}</code></strong> that satisfy
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(3M+M-M1+p-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=(\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">,</code>
<code class="reqn">\sigma_{1}^2,...,\sigma_{M}^2,</code><code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where <strong><code class="reqn">\phi</code></strong>=<code class="reqn">(\phi_{1},...,\phi_{p})</code>
contains the AR coefficients, which are common for all regimes.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vector <strong><code class="reqn">\phi</code></strong> with the vector <strong><code class="reqn">\psi</code></strong> that satisfies
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
</dl>

<p>Symbol <code class="reqn">\phi</code> denotes an AR coefficient, <code class="reqn">\sigma^2</code> a variance, <code class="reqn">\alpha</code> a mixing weight, and <code class="reqn">\nu</code> a degrees of
freedom parameter. If <code>parametrization=="mean"</code>, just replace each intercept term <code class="reqn">\phi_{m,0}</code> with the regimewise mean
<code class="reqn">\mu_m = \phi_{m,0}/(1-\sum\phi_{i,m})</code>. In the <strong>G-StMAR</strong> model, the first <code>M1</code> components are <em>GMAR type</em>
and the rest <code>M2</code> components are <em>StMAR type</em>.
Note that in the case <strong>M=1</strong>, the mixing weight parameters <code class="reqn">\alpha</code> are dropped, and in the case of <strong>StMAR</strong> or <strong>G-StMAR</strong> model,
the degrees of freedom parameters <code class="reqn">\nu</code> have to be larger than <code class="reqn">2</code>.</p>
</td></tr>
<tr><td><code id="quantileResiduals_+3A_model">model</code></td>
<td>
<p>is &quot;GMAR&quot;, &quot;StMAR&quot;, or &quot;G-StMAR&quot; model considered? In the G-StMAR model, the first <code>M1</code> components
are <em>GMAR type</em> and the rest <code>M2</code> components are <em>StMAR type</em>.</p>
</td></tr>
<tr><td><code id="quantileResiduals_+3A_restricted">restricted</code></td>
<td>
<p>a logical argument stating whether the AR coefficients <code class="reqn">\phi_{m,1},...,\phi_{m,p}</code> are restricted
to be the same for all regimes.</p>
</td></tr>
<tr><td><code id="quantileResiduals_+3A_constraints">constraints</code></td>
<td>
<p>specifies linear constraints imposed to each regime's autoregressive parameters separately.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd><p>a list of size <code class="reqn">(pxq_{m})</code> constraint matrices <strong><code class="reqn">C_{m}</code></strong> of full column rank
satisfying <strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> for all <code class="reqn">m=1,...,M</code>, where
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p})</code> and <strong><code class="reqn">\psi_{m}</code></strong><code class="reqn">=(\psi_{m,1},...,\psi_{m,q_{m}})</code>.</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd><p>a size <code class="reqn">(pxq)</code> constraint matrix <strong><code class="reqn">C</code></strong> of full column rank satisfying
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong>, where <strong><code class="reqn">\phi</code></strong><code class="reqn">=(\phi_{1},...,\phi_{p})</code> and
<strong><code class="reqn">\psi</code></strong><code class="reqn">=\psi_{1},...,\psi_{q}</code>.</p>
</dd>
</dl>

<p>The symbol <code class="reqn">\phi</code> denotes an AR coefficient. Note that regardless of any constraints, the autoregressive order
is always <code>p</code> for all regimes.
Ignore or set to <code>NULL</code> if applying linear constraints is not desired.</p>
</td></tr>
<tr><td><code id="quantileResiduals_+3A_parametrization">parametrization</code></td>
<td>
<p>is the model parametrized with the &quot;intercepts&quot; <code class="reqn">\phi_{m,0}</code> or
&quot;means&quot; <code class="reqn">\mu_{m} = \phi_{m,0}/(1-\sum\phi_{i,m})</code>?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>DEPRECATED, USE <code>quantile_residuals</code> INSTEAD!
</p>


<h3>Value</h3>

<p>Returns a <code class="reqn">(Tx1)</code> numeric vector containing the quantile residuals of the specified GMAR, StMAR or G-StMAR model.
Note that there are no quantile residuals for the first <code>p</code> observations as they are the initial values.
</p>


<h3>Suggested packages</h3>

<p>Install the suggested package &quot;gsl&quot; for faster evaluation of the quantile residuals of StMAR and G-StMAR models.
</p>


<h3>References</h3>


<ul>
<li><p> Galbraith, R., Galbraith, J. 1974. On the inverses of some patterned matrices arising
in the theory of stationary time series. <em>Journal of Applied Probability</em> <strong>11</strong>, 63-71.
</p>
</li>
<li><p> Kalliovirta L. (2012) Misspecification tests based on quantile residuals.
<em>The Econometrics Journal</em>, <strong>15</strong>, 358-393.
</p>
</li>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2015. Gaussian Mixture Autoregressive model for univariate time series.
<em>Journal of Time Series Analysis</em>, <strong>36</strong>(2), 247-266.
</p>
</li>
<li><p> Meitz M., Preve D., Saikkonen P. 2023. A mixture autoregressive model based on Student's t-distribution.
<em>Communications in Statistics - Theory and Methods</em>, <strong>52</strong>(2), 499-515.
</p>
</li>
<li><p> Virolainen S. 2022. A mixture autoregressive model based on Gaussian and Student's t-distributions.
Studies in Nonlinear Dynamics &amp; Econometrics, <strong>26</strong>(4) 559-580.
</p>
</li></ul>


<hr>
<h2 id='quantileResidualTests'>DEPRECATED, USE <code>quantile_residual_tests</code> INSTEAD! Quantile residual tests for GMAR, StMAR , and G-StMAR models</h2><span id='topic+quantileResidualTests'></span>

<h3>Description</h3>

<p><code>quantileResidualTests</code> performs quantile residual tests for GMAR, StMAR,
and G-StMAR models, testing normality, autocorrelation, and conditional heteroscedasticity
of the quantile residuals. DEPRECATED, USE <code>quantile_residual_tests</code> INSTEAD!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantileResidualTests(
  gsmar,
  lags_ac = c(1, 3, 6, 12),
  lags_ch = lags_ac,
  nsimu = 1,
  print_res = TRUE,
  lagsAC = NULL,
  lagsCH = NULL,
  printRes = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantileResidualTests_+3A_gsmar">gsmar</code></td>
<td>
<p>a class 'gsmar' object, typically generated by <code>fitGSMAR</code> or <code>GSMAR</code>.</p>
</td></tr>
<tr><td><code id="quantileResidualTests_+3A_lags_ac">lags_ac</code></td>
<td>
<p>a numeric vector of positive integers specifying the lags for which autocorrelation is tested.</p>
</td></tr>
<tr><td><code id="quantileResidualTests_+3A_lags_ch">lags_ch</code></td>
<td>
<p>a numeric vector of positive integers specifying the lags for which conditional heteroscedasticity
is tested.</p>
</td></tr>
<tr><td><code id="quantileResidualTests_+3A_nsimu">nsimu</code></td>
<td>
<p>a positive integer specifying to how many simulated observations the covariance matrix Omega
(see Kalliovirta (2012)) should be based on. If smaller than data size, then omega will be based on the
given data and not on simulated data. Having the covariance matrix omega based on a large simulated sample
might improve the tests size properties.</p>
</td></tr>
<tr><td><code id="quantileResidualTests_+3A_print_res">print_res</code></td>
<td>
<p>a logical argument defining whether the results should be printed or not.</p>
</td></tr>
<tr><td><code id="quantileResidualTests_+3A_lagsac">lagsAC</code></td>
<td>
<p>deprecated! Use <code>lags_ac</code> instead.</p>
</td></tr>
<tr><td><code id="quantileResidualTests_+3A_lagsch">lagsCH</code></td>
<td>
<p>deprecated! Use <code>lags_ch</code> instead.</p>
</td></tr>
<tr><td><code id="quantileResidualTests_+3A_printres">printRes</code></td>
<td>
<p>deprecated! Use <code>print_res</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>DEPRECATED! USE <code>quantile_residual_tests</code> INSTEAD!
</p>
<p>For a correctly specified GSMAR model employing the maximum likelihood estimator, the quantile residuals
are asymptotically independent with standard normal distribution. They can hence be used in a similar
manner to conventional Pearson's residuals. For more details about quantile residual based diagnostics,
and in particular, about the quantile residual tests, see the cited article by <em>Kalliovirta (2012)</em>.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>'qrtest'</code> containing the test results in data frames. In the cases
of autocorrelation and conditional heteroscedasticity tests, the returned object also contains the
associated individual statistics and their standard errors, discussed in <em>Kalliovirta (2012)</em> at
the pages 369-370.
</p>


<h3>Suggested packages</h3>

<p>Install the suggested package &quot;gsl&quot; for faster evaluations in the cases of StMAR and G-StMAR models.
For large StMAR and G-StMAR models with large data, the evaluations may take significantly long time
without the package &quot;gsl&quot;.
</p>


<h3>References</h3>


<ul>
<li><p> Galbraith, R., Galbraith, J. 1974. On the inverses of some patterned matrices arising
in the theory of stationary time series. <em>Journal of Applied Probability</em> <strong>11</strong>, 63-71.
</p>
</li>
<li><p> Kalliovirta L. (2012) Misspecification tests based on quantile residuals.
<em>The Econometrics Journal</em>, <strong>15</strong>, 358-393.
</p>
</li>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2015. Gaussian Mixture Autoregressive model for univariate time series.
<em>Journal of Time Series Analysis</em>, <strong>36</strong>(2), 247-266.
</p>
</li>
<li><p> Meitz M., Preve D., Saikkonen P. 2023. A mixture autoregressive model based on Student's t-distribution.
<em>Communications in Statistics - Theory and Methods</em>, <strong>52</strong>(2), 499-515.
</p>
</li>
<li><p> Virolainen S. 2022. A mixture autoregressive model based on Gaussian and Student's t-distributions.
Studies in Nonlinear Dynamics &amp; Econometrics, <strong>26</strong>(4) 559-580.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+profile_logliks">profile_logliks</a></code>, <code><a href="#topic+fitGSMAR">fitGSMAR</a></code>, <code><a href="#topic+GSMAR">GSMAR</a></code>, <code><a href="#topic+diagnostic_plot">diagnostic_plot</a></code>,
<code><a href="#topic+predict.gsmar">predict.gsmar</a></code>, <code><a href="#topic+get_test_Omega">get_test_Omega</a></code>,
</p>

<hr>
<h2 id='random_arcoefs'>Create random AR coefficients</h2><span id='topic+random_arcoefs'></span>

<h3>Description</h3>

<p><code>random_arcoefs</code> generates random AR coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_arcoefs(p, forcestat = FALSE, sd = 0.6/p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_arcoefs_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="random_arcoefs_+3A_forcestat">forcestat</code></td>
<td>
<p>use the algorithm by Monahan (1984) to force stationarity on the AR parameters (slower)?</p>
</td></tr>
<tr><td><code id="random_arcoefs_+3A_sd">sd</code></td>
<td>
<p>if <code>forcestat==FALSE</code>, then AR parameters are drawn from zero mean normal distribution with sd given by this parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>forcestat==TRUE</code>, then the AR coefficients are relatively large, otherwise they are usually relatively small.
</p>


<h3>Value</h3>

<p>Returns <code class="reqn">px1</code> vector containing random AR coefficients.
</p>


<h3>References</h3>


<ul>
<li><p> Monahan J.F. 1984. A Note on Enforcing Stationarity in Autoregressive-Moving Average Models.
<em>Biometrica</em> <strong>71</strong>, 403-404.
</p>
</li></ul>


<hr>
<h2 id='random_ind'>Create random GMAR, StMAR, or G-StMAR model compatible parameter vector</h2><span id='topic+random_ind'></span><span id='topic+smart_ind'></span>

<h3>Description</h3>

<p><code>random_ind</code> creates a random GMAR, StMAR, or G-StMAR model compatible mean-parametrized parameter vector.
</p>
<p><code>smart_ind</code> creates a random GMAR, StMAR, or G-StMAR model compatible parameter vector close to argument <code>params</code>.
Sometimes returns exactly the given parameter vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_ind(
  p,
  M,
  model = c("GMAR", "StMAR", "G-StMAR"),
  restricted = FALSE,
  constraints = NULL,
  mu_scale,
  sigma_scale,
  forcestat = FALSE
)

smart_ind(
  p,
  M,
  params,
  model = c("GMAR", "StMAR", "G-StMAR"),
  restricted = FALSE,
  constraints = NULL,
  mu_scale,
  sigma_scale,
  accuracy,
  which_random = numeric(0),
  forcestat = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_ind_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="random_ind_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMAR</strong> and <strong>StMAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMAR type</em> components <code>M1</code> in the
first element and <em>StMAR type</em> components <code>M2</code> in the second element. The total number of mixture components is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="random_ind_+3A_model">model</code></td>
<td>
<p>is &quot;GMAR&quot;, &quot;StMAR&quot;, or &quot;G-StMAR&quot; model considered? In the G-StMAR model, the first <code>M1</code> components
are <em>GMAR type</em> and the rest <code>M2</code> components are <em>StMAR type</em>.</p>
</td></tr>
<tr><td><code id="random_ind_+3A_restricted">restricted</code></td>
<td>
<p>a logical argument stating whether the AR coefficients <code class="reqn">\phi_{m,1},...,\phi_{m,p}</code> are restricted
to be the same for all regimes.</p>
</td></tr>
<tr><td><code id="random_ind_+3A_constraints">constraints</code></td>
<td>
<p>specifies linear constraints imposed to each regime's autoregressive parameters separately.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd><p>a list of size <code class="reqn">(pxq_{m})</code> constraint matrices <strong><code class="reqn">C_{m}</code></strong> of full column rank
satisfying <strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> for all <code class="reqn">m=1,...,M</code>, where
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p})</code> and <strong><code class="reqn">\psi_{m}</code></strong><code class="reqn">=(\psi_{m,1},...,\psi_{m,q_{m}})</code>.</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd><p>a size <code class="reqn">(pxq)</code> constraint matrix <strong><code class="reqn">C</code></strong> of full column rank satisfying
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong>, where <strong><code class="reqn">\phi</code></strong><code class="reqn">=(\phi_{1},...,\phi_{p})</code> and
<strong><code class="reqn">\psi</code></strong><code class="reqn">=\psi_{1},...,\psi_{q}</code>.</p>
</dd>
</dl>

<p>The symbol <code class="reqn">\phi</code> denotes an AR coefficient. Note that regardless of any constraints, the autoregressive order
is always <code>p</code> for all regimes.
Ignore or set to <code>NULL</code> if applying linear constraints is not desired.</p>
</td></tr>
<tr><td><code id="random_ind_+3A_mu_scale">mu_scale</code></td>
<td>
<p>a real valued vector of length two specifying the mean (the first element) and standard deviation (the second element)
of the normal distribution from which the <code class="reqn">\phi_{m,0}</code> <strong>or</strong> <code class="reqn">\mu_{m}</code> (depending on the desired parametrization)
parameters (for random regimes) should be generated.</p>
</td></tr>
<tr><td><code id="random_ind_+3A_sigma_scale">sigma_scale</code></td>
<td>
<p>a positive real number specifying the standard deviation of the (zero mean, positive only by taking absolute value)
normal distribution from which the component variance parameters (for random regimes) should be generated.</p>
</td></tr>
<tr><td><code id="random_ind_+3A_forcestat">forcestat</code></td>
<td>
<p>use the algorithm by Monahan (1984) to force stationarity on the AR parameters (slower) for random regimes?
Not supported for constrained models.</p>
</td></tr>
<tr><td><code id="random_ind_+3A_params">params</code></td>
<td>
<p>a real valued parameter vector specifying the model.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(M(p+3)+M-M1-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=</code>(<strong><code class="reqn">\upsilon_{1}</code></strong><code class="reqn">,...,</code><strong><code class="reqn">\upsilon_{M}</code></strong>,
<code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>) where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn">=(\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,</code><code class="reqn">\sigma_{m}^2)</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p}), m=1,...,M</code>
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMAR type regimes.
</p>
</li></ul>

<p>In the <strong>GMAR</strong> model, <code class="reqn">M1=M</code> and the parameter <strong><code class="reqn">\nu</code></strong> dropped. In the <strong>StMAR</strong> model, <code class="reqn">M1=0</code>.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vectors <strong><code class="reqn">\phi_{m}</code></strong> with the vectors <strong><code class="reqn">\psi_{m}</code></strong> that satisfy
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(3M+M-M1+p-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=(\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">,</code>
<code class="reqn">\sigma_{1}^2,...,\sigma_{M}^2,</code><code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where <strong><code class="reqn">\phi</code></strong>=<code class="reqn">(\phi_{1},...,\phi_{p})</code>
contains the AR coefficients, which are common for all regimes.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vector <strong><code class="reqn">\phi</code></strong> with the vector <strong><code class="reqn">\psi</code></strong> that satisfies
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
</dl>

<p>Symbol <code class="reqn">\phi</code> denotes an AR coefficient, <code class="reqn">\sigma^2</code> a variance, <code class="reqn">\alpha</code> a mixing weight, and <code class="reqn">\nu</code> a degrees of
freedom parameter. If <code>parametrization=="mean"</code>, just replace each intercept term <code class="reqn">\phi_{m,0}</code> with the regimewise mean
<code class="reqn">\mu_m = \phi_{m,0}/(1-\sum\phi_{i,m})</code>. In the <strong>G-StMAR</strong> model, the first <code>M1</code> components are <em>GMAR type</em>
and the rest <code>M2</code> components are <em>StMAR type</em>.
Note that in the case <strong>M=1</strong>, the mixing weight parameters <code class="reqn">\alpha</code> are dropped, and in the case of <strong>StMAR</strong> or <strong>G-StMAR</strong> model,
the degrees of freedom parameters <code class="reqn">\nu</code> have to be larger than <code class="reqn">2</code>.</p>
</td></tr>
<tr><td><code id="random_ind_+3A_accuracy">accuracy</code></td>
<td>
<p>a real number larger than zero specifying how close to <code>params</code> the generated parameter vector should be.
Standard deviation of the normal distribution from which new parameter values are drawn from will be corresponding parameter
value divided by <code>accuracy</code>.</p>
</td></tr>
<tr><td><code id="random_ind_+3A_which_random">which_random</code></td>
<td>
<p>a numeric vector of maximum length <code>M</code> specifying which regimes should be random instead of &quot;smart&quot; when
using <code>smart_ind</code>. Does not affect mixing weight parameters. Default in none.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions can be used, for example, to create initial populations for the genetic algorithm. Mean-parametrization
(instead of intercept terms <code class="reqn">\phi_{m,0}</code>) is assumed.
</p>


<h3>Value</h3>

<p>Returns estimated parameter vector with the form described in <code>initpop</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Monahan J.F. 1984. A Note on Enforcing Stationarity in Autoregressive-Moving Average Models.
<em>Biometrica</em> <strong>71</strong>, 403-404.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)

# GMAR model parameter vector
params22 &lt;- random_ind(p=2, M=2, mu_scale=c(0, 1), sigma_scale=1)
smart22 &lt;- smart_ind(p=2, M=2, params22, accuracy=10)
cbind(params22, smart22)

# Restricted GMAR parameter vector
params12r &lt;- random_ind(p=1, M=2, restricted=TRUE, mu_scale=c(-2, 2), sigma_scale=2)
smart12r &lt;- smart_ind(p=1, M=2, params12r, restricted=TRUE, accuracy=20)
cbind(params12r, smart12r)

# StMAR parameter vector: first regime is random in the "smart individual"
params13t &lt;- random_ind(p=1, M=3, model="StMAR", mu_scale=c(3, 1), sigma_scale=3)
smart13t &lt;- smart_ind(p=1, M=3, params13t, model="StMAR", accuracy=15,
                      mu_scale=c(3, 3), sigma_scale=3, which_random=1)
cbind(params13t, smart13t)

# Restricted StMAR parameter vector
params22tr &lt;- random_ind(p=2, M=2, model="StMAR", restricted=TRUE,
                         mu_scale=c(3, 2), sigma_scale=0.5)
smart22tr &lt;- smart_ind(p=2, M=2, params22tr, model="StMAR", restricted=TRUE,
                       accuracy=30)
cbind(params22tr, smart22tr)

# G-StMAR parameter vector
params12gs &lt;- random_ind(p=1, M=c(1, 1), model="G-StMAR", mu_scale=c(0, 1),
                         sigma_scale=1)
smart12gs &lt;- smart_ind(p=1, M=c(1, 1), params12gs, model="G-StMAR",
                       accuracy=20)
cbind(params12gs, smart12gs)

# Such StMAR(3,2) that the AR coefficients are restricted to be
# the same for both regimes and that the second AR coefficients are
# constrained to zero. Second regime is random in the "smart individual".
params32trc &lt;- random_ind(p=3, M=2, model="StMAR", restricted=TRUE,
                          constraints=matrix(c(1, 0, 0, 0, 0, 1), ncol=2),
                          mu_scale=c(-2, 0.5), sigma_scale=4)
smart32trc &lt;- smart_ind(p=3, M=2, params32trc, model="StMAR", restricted=TRUE,
                        constraints=matrix(c(1, 0, 0, 0, 0, 1), ncol=2),
                        mu_scale=c(0, 0.1), sigma_scale=0.1, which_random=2,
                        accuracy=20)
cbind(params32trc, smart32trc)
</code></pre>

<hr>
<h2 id='random_ind_int'>Create random GMAR, StMAR, or G-StMAR model compatible parameter vector</h2><span id='topic+random_ind_int'></span><span id='topic+smart_ind_int'></span>

<h3>Description</h3>

<p><code>random_ind_int</code> creates a random GMAR, StMAR, or G-StMAR model compatible parameter vector.
</p>
<p><code>smart_ind_int</code> creates a random GMAR, StMAR, or G-StMAR model compatible parameter vector close to argument <code>params</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_ind_int(
  p,
  M,
  model = c("GMAR", "StMAR", "G-StMAR"),
  restricted = FALSE,
  constraints = NULL,
  mu_scale,
  sigma_scale,
  forcestat = FALSE
)

smart_ind_int(
  p,
  M,
  params,
  model = c("GMAR", "StMAR", "G-StMAR"),
  restricted = FALSE,
  constraints = NULL,
  mu_scale,
  sigma_scale,
  accuracy,
  which_random,
  forcestat = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_ind_int_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="random_ind_int_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMAR</strong> and <strong>StMAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMAR type</em> components <code>M1</code> in the
first element and <em>StMAR type</em> components <code>M2</code> in the second element. The total number of mixture components is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="random_ind_int_+3A_model">model</code></td>
<td>
<p>is &quot;GMAR&quot;, &quot;StMAR&quot;, or &quot;G-StMAR&quot; model considered? In the G-StMAR model, the first <code>M1</code> components
are <em>GMAR type</em> and the rest <code>M2</code> components are <em>StMAR type</em>.</p>
</td></tr>
<tr><td><code id="random_ind_int_+3A_restricted">restricted</code></td>
<td>
<p>a logical argument stating whether the AR coefficients <code class="reqn">\phi_{m,1},...,\phi_{m,p}</code> are restricted
to be the same for all regimes.</p>
</td></tr>
<tr><td><code id="random_ind_int_+3A_constraints">constraints</code></td>
<td>
<p>specifies linear constraints imposed to each regime's autoregressive parameters separately.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd><p>a list of size <code class="reqn">(pxq_{m})</code> constraint matrices <strong><code class="reqn">C_{m}</code></strong> of full column rank
satisfying <strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> for all <code class="reqn">m=1,...,M</code>, where
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p})</code> and <strong><code class="reqn">\psi_{m}</code></strong><code class="reqn">=(\psi_{m,1},...,\psi_{m,q_{m}})</code>.</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd><p>a size <code class="reqn">(pxq)</code> constraint matrix <strong><code class="reqn">C</code></strong> of full column rank satisfying
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong>, where <strong><code class="reqn">\phi</code></strong><code class="reqn">=(\phi_{1},...,\phi_{p})</code> and
<strong><code class="reqn">\psi</code></strong><code class="reqn">=\psi_{1},...,\psi_{q}</code>.</p>
</dd>
</dl>

<p>The symbol <code class="reqn">\phi</code> denotes an AR coefficient. Note that regardless of any constraints, the autoregressive order
is always <code>p</code> for all regimes.
Ignore or set to <code>NULL</code> if applying linear constraints is not desired.</p>
</td></tr>
<tr><td><code id="random_ind_int_+3A_mu_scale">mu_scale</code></td>
<td>
<p>a real valued vector of length two specifying the mean (the first element) and standard deviation (the second element)
of the normal distribution from which the <code class="reqn">\phi_{m,0}</code> <strong>or</strong> <code class="reqn">\mu_{m}</code> (depending on the desired parametrization)
parameters (for random regimes) should be generated.</p>
</td></tr>
<tr><td><code id="random_ind_int_+3A_sigma_scale">sigma_scale</code></td>
<td>
<p>a positive real number specifying the standard deviation of the (zero mean, positive only by taking absolute value)
normal distribution from which the component variance parameters (for random regimes) should be generated.</p>
</td></tr>
<tr><td><code id="random_ind_int_+3A_forcestat">forcestat</code></td>
<td>
<p>use the algorithm by Monahan (1984) to force stationarity on the AR parameters (slower) for random regimes?
Not supported for constrained models.</p>
</td></tr>
<tr><td><code id="random_ind_int_+3A_params">params</code></td>
<td>
<p>a real valued parameter vector specifying the model.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(M(p+3)+M-M1-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=</code>(<strong><code class="reqn">\upsilon_{1}</code></strong><code class="reqn">,...,</code><strong><code class="reqn">\upsilon_{M}</code></strong>,
<code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>) where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn">=(\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,</code><code class="reqn">\sigma_{m}^2)</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p}), m=1,...,M</code>
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMAR type regimes.
</p>
</li></ul>

<p>In the <strong>GMAR</strong> model, <code class="reqn">M1=M</code> and the parameter <strong><code class="reqn">\nu</code></strong> dropped. In the <strong>StMAR</strong> model, <code class="reqn">M1=0</code>.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vectors <strong><code class="reqn">\phi_{m}</code></strong> with the vectors <strong><code class="reqn">\psi_{m}</code></strong> that satisfy
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(3M+M-M1+p-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=(\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">,</code>
<code class="reqn">\sigma_{1}^2,...,\sigma_{M}^2,</code><code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where <strong><code class="reqn">\phi</code></strong>=<code class="reqn">(\phi_{1},...,\phi_{p})</code>
contains the AR coefficients, which are common for all regimes.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vector <strong><code class="reqn">\phi</code></strong> with the vector <strong><code class="reqn">\psi</code></strong> that satisfies
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
</dl>

<p>Symbol <code class="reqn">\phi</code> denotes an AR coefficient, <code class="reqn">\sigma^2</code> a variance, <code class="reqn">\alpha</code> a mixing weight, and <code class="reqn">\nu</code> a degrees of
freedom parameter. If <code>parametrization=="mean"</code>, just replace each intercept term <code class="reqn">\phi_{m,0}</code> with the regimewise mean
<code class="reqn">\mu_m = \phi_{m,0}/(1-\sum\phi_{i,m})</code>. In the <strong>G-StMAR</strong> model, the first <code>M1</code> components are <em>GMAR type</em>
and the rest <code>M2</code> components are <em>StMAR type</em>.
Note that in the case <strong>M=1</strong>, the mixing weight parameters <code class="reqn">\alpha</code> are dropped, and in the case of <strong>StMAR</strong> or <strong>G-StMAR</strong> model,
the degrees of freedom parameters <code class="reqn">\nu</code> have to be larger than <code class="reqn">2</code>.</p>
</td></tr>
<tr><td><code id="random_ind_int_+3A_accuracy">accuracy</code></td>
<td>
<p>a real number larger than zero specifying how close to <code>params</code> the generated parameter vector should be.
Standard deviation of the normal distribution from which new parameter values are drawn from will be corresponding parameter
value divided by <code>accuracy</code>.</p>
</td></tr>
<tr><td><code id="random_ind_int_+3A_which_random">which_random</code></td>
<td>
<p>a numeric vector of maximum length <code>M</code> specifying which regimes should be random instead of &quot;smart&quot; when
using <code>smart_ind</code>. Does not affect mixing weight parameters. Default in none.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns estimated parameter vector with the form described in <code>initpop</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Monahan J.F. 1984. A Note on Enforcing Stationarity in Autoregressive-Moving Average Models.
<em>Biometrica</em> <strong>71</strong>, 403-404.
</p>
</li></ul>


<hr>
<h2 id='random_regime'>Create random regime parameters</h2><span id='topic+random_regime'></span>

<h3>Description</h3>

<p><code>random_regime</code> generates random regime parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_regime(
  p,
  mu_scale,
  sigma_scale,
  restricted = FALSE,
  constraints = NULL,
  m,
  forcestat = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_regime_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="random_regime_+3A_mu_scale">mu_scale</code></td>
<td>
<p>a real valued vector of length two specifying the mean (the first element) and standard deviation (the second element)
of the normal distribution from which the <code class="reqn">\mu_{m}</code> mean-parameters are generated in random mutations in the genetic algorithm.
Default is <code>c(mean(data), sd(data))</code>.
Note that the genetic algorithm optimizes with mean-parametrization even when <code>parametrization=="intercept"</code>, but
input (in <code>initpop</code>) and output (return value) parameter vectors may be intercept-parametrized.</p>
</td></tr>
<tr><td><code id="random_regime_+3A_sigma_scale">sigma_scale</code></td>
<td>
<p>a positive real number specifying the standard deviation of the (zero mean, positive only by taking absolute value)
normal distribution from which the component variance parameters are generated in the random mutations in the genetic algorithm.
Default is <code>var(stats::ar(data, order.max=10)$resid, na.rm=TRUE)</code>.</p>
</td></tr>
<tr><td><code id="random_regime_+3A_restricted">restricted</code></td>
<td>
<p>a logical argument stating whether the AR coefficients <code class="reqn">\phi_{m,1},...,\phi_{m,p}</code> are restricted
to be the same for all regimes.</p>
</td></tr>
<tr><td><code id="random_regime_+3A_constraints">constraints</code></td>
<td>
<p>specifies linear constraints imposed to each regime's autoregressive parameters separately.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd><p>a list of size <code class="reqn">(pxq_{m})</code> constraint matrices <strong><code class="reqn">C_{m}</code></strong> of full column rank
satisfying <strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> for all <code class="reqn">m=1,...,M</code>, where
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p})</code> and <strong><code class="reqn">\psi_{m}</code></strong><code class="reqn">=(\psi_{m,1},...,\psi_{m,q_{m}})</code>.</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd><p>a size <code class="reqn">(pxq)</code> constraint matrix <strong><code class="reqn">C</code></strong> of full column rank satisfying
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong>, where <strong><code class="reqn">\phi</code></strong><code class="reqn">=(\phi_{1},...,\phi_{p})</code> and
<strong><code class="reqn">\psi</code></strong><code class="reqn">=\psi_{1},...,\psi_{q}</code>.</p>
</dd>
</dl>

<p>The symbol <code class="reqn">\phi</code> denotes an AR coefficient. Note that regardless of any constraints, the autoregressive order
is always <code>p</code> for all regimes.
Ignore or set to <code>NULL</code> if applying linear constraints is not desired.</p>
</td></tr>
<tr><td><code id="random_regime_+3A_m">m</code></td>
<td>
<p>which regime? This is required for models with constraints for which a list of possibly differing
constraint matrices is provided.</p>
</td></tr>
<tr><td><code id="random_regime_+3A_forcestat">forcestat</code></td>
<td>
<p>use the algorithm by Monahan (1984) to force stationarity on the AR parameters (slower)?
Not supported for constrained models.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>forcestat==TRUE</code>, then the AR coefficients are relatively large, otherwise they are usually relatively small.
</p>


<h3>Value</h3>


<dl>
<dt>Regular models:</dt><dd><p><strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn">=(\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,\sigma_{m}^2)</code>
where <strong><code class="reqn">\phi_{m}</code></strong>=<code class="reqn">(\phi_{m,1},...,\phi_{m,p})</code>.</p>
</dd>
<dt>Restricted models:</dt><dd><p>Not supported!</p>
</dd>
<dt>Constrained models:</dt><dd><p>Replace the vectors <strong><code class="reqn">\phi_{m}</code></strong> with vectors <strong><code class="reqn">\psi_{m}</code></strong>.</p>
</dd>
</dl>



<h3>References</h3>


<ul>
<li><p> Monahan J.F. 1984. A Note on Enforcing Stationarity in Autoregressive-Moving Average Models.
<em>Biometrica</em> <strong>71</strong>, 403-404.
</p>
</li></ul>


<hr>
<h2 id='randomIndividual'>DEPRECATED, USE <code>random_ind</code> OR <code>smart_ind</code> INSTEAD!
Create random GMAR, StMAR, or G-StMAR model compatible parameter vector</h2><span id='topic+randomIndividual'></span><span id='topic+smartIndividual'></span>

<h3>Description</h3>

<p><code>randomIndividual</code> creates a random GMAR, StMAR, or G-StMAR model compatible mean-parametrized parameter vector.
DEPRECATED, USE <code>random_ind</code> INSTEAD!
</p>
<p><code>smartIndividual</code> creates a random GMAR, StMAR, or G-StMAR model compatible parameter vector close to argument <code>params</code>.
Sometimes returns exactly the given parameter vector.  DEPRECATED, USE <code>smart_ind</code> INSTEAD!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomIndividual(
  p,
  M,
  model = c("GMAR", "StMAR", "G-StMAR"),
  restricted = FALSE,
  constraints = NULL,
  mu_scale,
  sigma_scale,
  forcestat = FALSE,
  meanscale = NULL,
  sigmascale = NULL
)

smartIndividual(
  p,
  M,
  params,
  model = c("GMAR", "StMAR", "G-StMAR"),
  restricted = FALSE,
  constraints = NULL,
  mu_scale,
  sigma_scale,
  accuracy,
  which_random = numeric(0),
  forcestat = FALSE,
  whichRandom = NULL,
  meanscale = NULL,
  sigmascale = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randomIndividual_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="randomIndividual_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMAR</strong> and <strong>StMAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMAR type</em> components <code>M1</code> in the
first element and <em>StMAR type</em> components <code>M2</code> in the second element. The total number of mixture components is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="randomIndividual_+3A_model">model</code></td>
<td>
<p>is &quot;GMAR&quot;, &quot;StMAR&quot;, or &quot;G-StMAR&quot; model considered? In the G-StMAR model, the first <code>M1</code> components
are <em>GMAR type</em> and the rest <code>M2</code> components are <em>StMAR type</em>.</p>
</td></tr>
<tr><td><code id="randomIndividual_+3A_restricted">restricted</code></td>
<td>
<p>a logical argument stating whether the AR coefficients <code class="reqn">\phi_{m,1},...,\phi_{m,p}</code> are restricted
to be the same for all regimes.</p>
</td></tr>
<tr><td><code id="randomIndividual_+3A_constraints">constraints</code></td>
<td>
<p>specifies linear constraints imposed to each regime's autoregressive parameters separately.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd><p>a list of size <code class="reqn">(pxq_{m})</code> constraint matrices <strong><code class="reqn">C_{m}</code></strong> of full column rank
satisfying <strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> for all <code class="reqn">m=1,...,M</code>, where
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p})</code> and <strong><code class="reqn">\psi_{m}</code></strong><code class="reqn">=(\psi_{m,1},...,\psi_{m,q_{m}})</code>.</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd><p>a size <code class="reqn">(pxq)</code> constraint matrix <strong><code class="reqn">C</code></strong> of full column rank satisfying
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong>, where <strong><code class="reqn">\phi</code></strong><code class="reqn">=(\phi_{1},...,\phi_{p})</code> and
<strong><code class="reqn">\psi</code></strong><code class="reqn">=\psi_{1},...,\psi_{q}</code>.</p>
</dd>
</dl>

<p>The symbol <code class="reqn">\phi</code> denotes an AR coefficient. Note that regardless of any constraints, the autoregressive order
is always <code>p</code> for all regimes.
Ignore or set to <code>NULL</code> if applying linear constraints is not desired.</p>
</td></tr>
<tr><td><code id="randomIndividual_+3A_mu_scale">mu_scale</code></td>
<td>
<p>a real valued vector of length two specifying the mean (the first element) and standard deviation (the second element)
of the normal distribution from which the <code class="reqn">\phi_{m,0}</code> <strong>or</strong> <code class="reqn">\mu_{m}</code> (depending on the desired parametrization)
parameters (for random regimes) should be generated.</p>
</td></tr>
<tr><td><code id="randomIndividual_+3A_sigma_scale">sigma_scale</code></td>
<td>
<p>a positive real number specifying the standard deviation of the (zero mean, positive only by taking absolute value)
normal distribution from which the component variance parameters (for random regimes) should be generated.</p>
</td></tr>
<tr><td><code id="randomIndividual_+3A_forcestat">forcestat</code></td>
<td>
<p>use the algorithm by Monahan (1984) to force stationarity on the AR parameters (slower) for random regimes?
Not supported for constrained models.</p>
</td></tr>
<tr><td><code id="randomIndividual_+3A_meanscale">meanscale</code></td>
<td>
<p>deprecated! Use <code>mu_scale</code> instead!</p>
</td></tr>
<tr><td><code id="randomIndividual_+3A_sigmascale">sigmascale</code></td>
<td>
<p>deprecated! Use <code>sigma_scale</code> instead!</p>
</td></tr>
<tr><td><code id="randomIndividual_+3A_params">params</code></td>
<td>
<p>a real valued parameter vector specifying the model.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(M(p+3)+M-M1-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=</code>(<strong><code class="reqn">\upsilon_{1}</code></strong><code class="reqn">,...,</code><strong><code class="reqn">\upsilon_{M}</code></strong>,
<code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>) where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn">=(\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,</code><code class="reqn">\sigma_{m}^2)</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p}), m=1,...,M</code>
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMAR type regimes.
</p>
</li></ul>

<p>In the <strong>GMAR</strong> model, <code class="reqn">M1=M</code> and the parameter <strong><code class="reqn">\nu</code></strong> dropped. In the <strong>StMAR</strong> model, <code class="reqn">M1=0</code>.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vectors <strong><code class="reqn">\phi_{m}</code></strong> with the vectors <strong><code class="reqn">\psi_{m}</code></strong> that satisfy
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(3M+M-M1+p-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=(\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">,</code>
<code class="reqn">\sigma_{1}^2,...,\sigma_{M}^2,</code><code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where <strong><code class="reqn">\phi</code></strong>=<code class="reqn">(\phi_{1},...,\phi_{p})</code>
contains the AR coefficients, which are common for all regimes.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vector <strong><code class="reqn">\phi</code></strong> with the vector <strong><code class="reqn">\psi</code></strong> that satisfies
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
</dl>

<p>Symbol <code class="reqn">\phi</code> denotes an AR coefficient, <code class="reqn">\sigma^2</code> a variance, <code class="reqn">\alpha</code> a mixing weight, and <code class="reqn">\nu</code> a degrees of
freedom parameter. If <code>parametrization=="mean"</code>, just replace each intercept term <code class="reqn">\phi_{m,0}</code> with the regimewise mean
<code class="reqn">\mu_m = \phi_{m,0}/(1-\sum\phi_{i,m})</code>. In the <strong>G-StMAR</strong> model, the first <code>M1</code> components are <em>GMAR type</em>
and the rest <code>M2</code> components are <em>StMAR type</em>.
Note that in the case <strong>M=1</strong>, the mixing weight parameters <code class="reqn">\alpha</code> are dropped, and in the case of <strong>StMAR</strong> or <strong>G-StMAR</strong> model,
the degrees of freedom parameters <code class="reqn">\nu</code> have to be larger than <code class="reqn">2</code>.</p>
</td></tr>
<tr><td><code id="randomIndividual_+3A_accuracy">accuracy</code></td>
<td>
<p>a real number larger than zero specifying how close to <code>params</code> the generated parameter vector should be.
Standard deviation of the normal distribution from which new parameter values are drawn from will be corresponding parameter
value divided by <code>accuracy</code>.</p>
</td></tr>
<tr><td><code id="randomIndividual_+3A_which_random">which_random</code></td>
<td>
<p>a numeric vector of maximum length <code>M</code> specifying which regimes should be random instead of &quot;smart&quot; when
using <code>smart_ind</code>. Does not affect mixing weight parameters. Default in none.</p>
</td></tr>
<tr><td><code id="randomIndividual_+3A_whichrandom">whichRandom</code></td>
<td>
<p>deprecated! Use <code>which_random</code> instead!</p>
</td></tr>
</table>


<h3>Details</h3>

<p>DEPRECATED, USE <code>random_ind</code> OR <code>smart_ind</code> INSTEAD!
</p>
<p>These functions can be used, for example, to create initial populations for the genetic algorithm. Mean-parametrization
(instead of intercept terms <code class="reqn">\phi_{m,0}</code>) is assumed.
</p>


<h3>Value</h3>

<p>Returns estimated parameter vector with the form described in <code>initpop</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Monahan J.F. 1984. A Note on Enforcing Stationarity in Autoregressive-Moving Average Models.
<em>Biometrica</em> <strong>71</strong>, 403-404.
</p>
</li></ul>


<hr>
<h2 id='reform_constrained_pars'>Reform parameter vector with linear constraints to correspond non-constrained parameter vector.</h2><span id='topic+reform_constrained_pars'></span>

<h3>Description</h3>

<p><code>reform_constrained_pars</code> reforms the parameter vector of a model with linear constrains
to the &quot;standard form&quot; so that it's comparable with non-constrained models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reform_constrained_pars(
  p,
  M,
  params,
  model = c("GMAR", "StMAR", "G-StMAR"),
  restricted = FALSE,
  constraints = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reform_constrained_pars_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="reform_constrained_pars_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMAR</strong> and <strong>StMAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMAR type</em> components <code>M1</code> in the
first element and <em>StMAR type</em> components <code>M2</code> in the second element. The total number of mixture components is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="reform_constrained_pars_+3A_params">params</code></td>
<td>
<p>a real valued parameter vector specifying the model.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(M(p+3)+M-M1-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=</code>(<strong><code class="reqn">\upsilon_{1}</code></strong><code class="reqn">,...,</code><strong><code class="reqn">\upsilon_{M}</code></strong>,
<code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>) where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn">=(\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,</code><code class="reqn">\sigma_{m}^2)</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p}), m=1,...,M</code>
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMAR type regimes.
</p>
</li></ul>

<p>In the <strong>GMAR</strong> model, <code class="reqn">M1=M</code> and the parameter <strong><code class="reqn">\nu</code></strong> dropped. In the <strong>StMAR</strong> model, <code class="reqn">M1=0</code>.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vectors <strong><code class="reqn">\phi_{m}</code></strong> with the vectors <strong><code class="reqn">\psi_{m}</code></strong> that satisfy
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(3M+M-M1+p-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=(\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">,</code>
<code class="reqn">\sigma_{1}^2,...,\sigma_{M}^2,</code><code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where <strong><code class="reqn">\phi</code></strong>=<code class="reqn">(\phi_{1},...,\phi_{p})</code>
contains the AR coefficients, which are common for all regimes.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vector <strong><code class="reqn">\phi</code></strong> with the vector <strong><code class="reqn">\psi</code></strong> that satisfies
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
</dl>

<p>Symbol <code class="reqn">\phi</code> denotes an AR coefficient, <code class="reqn">\sigma^2</code> a variance, <code class="reqn">\alpha</code> a mixing weight, and <code class="reqn">\nu</code> a degrees of
freedom parameter. If <code>parametrization=="mean"</code>, just replace each intercept term <code class="reqn">\phi_{m,0}</code> with the regimewise mean
<code class="reqn">\mu_m = \phi_{m,0}/(1-\sum\phi_{i,m})</code>. In the <strong>G-StMAR</strong> model, the first <code>M1</code> components are <em>GMAR type</em>
and the rest <code>M2</code> components are <em>StMAR type</em>.
Note that in the case <strong>M=1</strong>, the mixing weight parameters <code class="reqn">\alpha</code> are dropped, and in the case of <strong>StMAR</strong> or <strong>G-StMAR</strong> model,
the degrees of freedom parameters <code class="reqn">\nu</code> have to be larger than <code class="reqn">2</code>.</p>
</td></tr>
<tr><td><code id="reform_constrained_pars_+3A_model">model</code></td>
<td>
<p>is &quot;GMAR&quot;, &quot;StMAR&quot;, or &quot;G-StMAR&quot; model considered? In the G-StMAR model, the first <code>M1</code> components
are <em>GMAR type</em> and the rest <code>M2</code> components are <em>StMAR type</em>.</p>
</td></tr>
<tr><td><code id="reform_constrained_pars_+3A_restricted">restricted</code></td>
<td>
<p>a logical argument stating whether the AR coefficients <code class="reqn">\phi_{m,1},...,\phi_{m,p}</code> are restricted
to be the same for all regimes.</p>
</td></tr>
<tr><td><code id="reform_constrained_pars_+3A_constraints">constraints</code></td>
<td>
<p>specifies linear constraints imposed to each regime's autoregressive parameters separately.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd><p>a list of size <code class="reqn">(pxq_{m})</code> constraint matrices <strong><code class="reqn">C_{m}</code></strong> of full column rank
satisfying <strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> for all <code class="reqn">m=1,...,M</code>, where
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p})</code> and <strong><code class="reqn">\psi_{m}</code></strong><code class="reqn">=(\psi_{m,1},...,\psi_{m,q_{m}})</code>.</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd><p>a size <code class="reqn">(pxq)</code> constraint matrix <strong><code class="reqn">C</code></strong> of full column rank satisfying
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong>, where <strong><code class="reqn">\phi</code></strong><code class="reqn">=(\phi_{1},...,\phi_{p})</code> and
<strong><code class="reqn">\psi</code></strong><code class="reqn">=\psi_{1},...,\psi_{q}</code>.</p>
</dd>
</dl>

<p>The symbol <code class="reqn">\phi</code> denotes an AR coefficient. Note that regardless of any constraints, the autoregressive order
is always <code>p</code> for all regimes.
Ignore or set to <code>NULL</code> if applying linear constraints is not desired.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns such parameter vector corresponding to the input vector that is the form described in <code>params</code>
for non-restricted or restricted models (for non-constrained models), and can hence be used just as the
parameter vectors of non-constrained models.
</p>

<hr>
<h2 id='reform_parameters'>Reform any parameter vector into standard form.</h2><span id='topic+reform_parameters'></span>

<h3>Description</h3>

<p><code>reform_parameters</code> takes a parameter vector of any (non-constrained) GMAR, StMAR, or G-StMAR model
and returns a list with the parameter vector in the standard form, parameter matrix containing AR coefficients and
component variances, mixing weights alphas, and in case of StMAR or G-StMAR model also degrees of freedom parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reform_parameters(
  p,
  M,
  params,
  model = c("GMAR", "StMAR", "G-StMAR"),
  restricted = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reform_parameters_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="reform_parameters_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMAR</strong> and <strong>StMAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMAR type</em> components <code>M1</code> in the
first element and <em>StMAR type</em> components <code>M2</code> in the second element. The total number of mixture components is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="reform_parameters_+3A_params">params</code></td>
<td>
<p>a real valued parameter vector specifying the model.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(M(p+3)+M-M1-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=</code>(<strong><code class="reqn">\upsilon_{1}</code></strong><code class="reqn">,...,</code><strong><code class="reqn">\upsilon_{M}</code></strong>,
<code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>) where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn">=(\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,</code><code class="reqn">\sigma_{m}^2)</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p}), m=1,...,M</code>
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMAR type regimes.
</p>
</li></ul>

<p>In the <strong>GMAR</strong> model, <code class="reqn">M1=M</code> and the parameter <strong><code class="reqn">\nu</code></strong> dropped. In the <strong>StMAR</strong> model, <code class="reqn">M1=0</code>.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vectors <strong><code class="reqn">\phi_{m}</code></strong> with the vectors <strong><code class="reqn">\psi_{m}</code></strong> that satisfy
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(3M+M-M1+p-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=(\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">,</code>
<code class="reqn">\sigma_{1}^2,...,\sigma_{M}^2,</code><code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where <strong><code class="reqn">\phi</code></strong>=<code class="reqn">(\phi_{1},...,\phi_{p})</code>
contains the AR coefficients, which are common for all regimes.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vector <strong><code class="reqn">\phi</code></strong> with the vector <strong><code class="reqn">\psi</code></strong> that satisfies
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
</dl>

<p>Symbol <code class="reqn">\phi</code> denotes an AR coefficient, <code class="reqn">\sigma^2</code> a variance, <code class="reqn">\alpha</code> a mixing weight, and <code class="reqn">\nu</code> a degrees of
freedom parameter. If <code>parametrization=="mean"</code>, just replace each intercept term <code class="reqn">\phi_{m,0}</code> with the regimewise mean
<code class="reqn">\mu_m = \phi_{m,0}/(1-\sum\phi_{i,m})</code>. In the <strong>G-StMAR</strong> model, the first <code>M1</code> components are <em>GMAR type</em>
and the rest <code>M2</code> components are <em>StMAR type</em>.
Note that in the case <strong>M=1</strong>, the mixing weight parameters <code class="reqn">\alpha</code> are dropped, and in the case of <strong>StMAR</strong> or <strong>G-StMAR</strong> model,
the degrees of freedom parameters <code class="reqn">\nu</code> have to be larger than <code class="reqn">2</code>.</p>
</td></tr>
<tr><td><code id="reform_parameters_+3A_model">model</code></td>
<td>
<p>is &quot;GMAR&quot;, &quot;StMAR&quot;, or &quot;G-StMAR&quot; model considered? In the G-StMAR model, the first <code>M1</code> components
are <em>GMAR type</em> and the rest <code>M2</code> components are <em>StMAR type</em>.</p>
</td></tr>
<tr><td><code id="reform_parameters_+3A_restricted">restricted</code></td>
<td>
<p>a logical argument stating whether the AR coefficients <code class="reqn">\phi_{m,1},...,\phi_{m,p}</code> are restricted
to be the same for all regimes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function does not support models imposing linear constraints. No argument checks in this function.
</p>


<h3>Value</h3>

<p>Returns a list with...
</p>

<dl>
<dt><code>$params</code></dt><dd><p>parameter vector in the standard form.</p>
</dd>
<dt><code>$pars</code></dt><dd><p>corresponding parameter matrix containing AR coefficients and
component variances. First row for phi0 or means depending on the parametrization. Column for each component.</p>
</dd>
<dt><code>$alphas</code></dt><dd><p>numeric vector containing mixing weight parameters for all of the components (also for the last one).</p>
</dd>
<dt><code>$dfs</code></dt><dd><p>numeric vector containing degrees of freedom parameters for all of components.
Returned only if <code>model == "StMAR"</code> or <code>model == "G-StMAR"</code>.</p>
</dd>
</dl>

<p>@keywords internal
</p>

<hr>
<h2 id='reform_restricted_pars'>Reform parameter vector with restricted autoregressive parameters to correspond non-restricted parameter vector.</h2><span id='topic+reform_restricted_pars'></span>

<h3>Description</h3>

<p><code>reform_restricted_pars</code> reforms parameter vector with restricted autoregressive parameters to correspond
non-restricted parameter vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reform_restricted_pars(
  p,
  M,
  params,
  model = c("GMAR", "StMAR", "G-StMAR"),
  restricted = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reform_restricted_pars_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="reform_restricted_pars_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMAR</strong> and <strong>StMAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMAR type</em> components <code>M1</code> in the
first element and <em>StMAR type</em> components <code>M2</code> in the second element. The total number of mixture components is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="reform_restricted_pars_+3A_params">params</code></td>
<td>
<p>a real valued parameter vector specifying the model.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(M(p+3)+M-M1-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=</code>(<strong><code class="reqn">\upsilon_{1}</code></strong><code class="reqn">,...,</code><strong><code class="reqn">\upsilon_{M}</code></strong>,
<code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>) where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn">=(\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,</code><code class="reqn">\sigma_{m}^2)</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p}), m=1,...,M</code>
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMAR type regimes.
</p>
</li></ul>

<p>In the <strong>GMAR</strong> model, <code class="reqn">M1=M</code> and the parameter <strong><code class="reqn">\nu</code></strong> dropped. In the <strong>StMAR</strong> model, <code class="reqn">M1=0</code>.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vectors <strong><code class="reqn">\phi_{m}</code></strong> with the vectors <strong><code class="reqn">\psi_{m}</code></strong> that satisfy
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(3M+M-M1+p-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=(\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">,</code>
<code class="reqn">\sigma_{1}^2,...,\sigma_{M}^2,</code><code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where <strong><code class="reqn">\phi</code></strong>=<code class="reqn">(\phi_{1},...,\phi_{p})</code>
contains the AR coefficients, which are common for all regimes.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vector <strong><code class="reqn">\phi</code></strong> with the vector <strong><code class="reqn">\psi</code></strong> that satisfies
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
</dl>

<p>Symbol <code class="reqn">\phi</code> denotes an AR coefficient, <code class="reqn">\sigma^2</code> a variance, <code class="reqn">\alpha</code> a mixing weight, and <code class="reqn">\nu</code> a degrees of
freedom parameter. If <code>parametrization=="mean"</code>, just replace each intercept term <code class="reqn">\phi_{m,0}</code> with the regimewise mean
<code class="reqn">\mu_m = \phi_{m,0}/(1-\sum\phi_{i,m})</code>. In the <strong>G-StMAR</strong> model, the first <code>M1</code> components are <em>GMAR type</em>
and the rest <code>M2</code> components are <em>StMAR type</em>.
Note that in the case <strong>M=1</strong>, the mixing weight parameters <code class="reqn">\alpha</code> are dropped, and in the case of <strong>StMAR</strong> or <strong>G-StMAR</strong> model,
the degrees of freedom parameters <code class="reqn">\nu</code> have to be larger than <code class="reqn">2</code>.</p>
</td></tr>
<tr><td><code id="reform_restricted_pars_+3A_model">model</code></td>
<td>
<p>is &quot;GMAR&quot;, &quot;StMAR&quot;, or &quot;G-StMAR&quot; model considered? In the G-StMAR model, the first <code>M1</code> components
are <em>GMAR type</em> and the rest <code>M2</code> components are <em>StMAR type</em>.</p>
</td></tr>
<tr><td><code id="reform_restricted_pars_+3A_restricted">restricted</code></td>
<td>
<p>a logical argument stating whether the AR coefficients <code class="reqn">\phi_{m,1},...,\phi_{m,p}</code> are restricted
to be the same for all regimes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns such parameter vector corresponding to the input vector that is the form described in <code>params</code>
for non-restricted models (for non-constrained models). Linear constraints are not supported.
</p>

<hr>
<h2 id='regime_distance'>Calculate &quot;distance&quot; between two regimes</h2><span id='topic+regime_distance'></span>

<h3>Description</h3>

<p><code>regime_distance</code> scales each regime parameter to the same magnitude
and then calculates distance between scaled <code>regime_pars1</code> and <code>regime_pars2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regime_distance(regime_pars1, regime_pars2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regime_distance_+3A_regime_pars1">regime_pars1</code></td>
<td>
<p>a numeric vector representing a regime.</p>
</td></tr>
<tr><td><code id="regime_distance_+3A_regime_pars2">regime_pars2</code></td>
<td>
<p>a numeric vector representing another regime, same length as <code>regime_pars1</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns &quot;distance&quot; between <code>regime_pars1</code> and <code>regime_pars2</code>. Values are scaled
to the same magnitude before calculating the &quot;distance&quot;. Read the source code for details.
</p>

<hr>
<h2 id='remove_all_constraints'>Transform constrained and restricted parameter vector into the regular form</h2><span id='topic+remove_all_constraints'></span>

<h3>Description</h3>

<p><code>remove_all_constraints</code> transforms constrained and restricted parameter vector into the regular form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_all_constraints(
  p,
  M,
  params,
  model = c("GMAR", "StMAR", "G-StMAR"),
  restricted = FALSE,
  constraints = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_all_constraints_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="remove_all_constraints_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMAR</strong> and <strong>StMAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMAR type</em> components <code>M1</code> in the
first element and <em>StMAR type</em> components <code>M2</code> in the second element. The total number of mixture components is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="remove_all_constraints_+3A_params">params</code></td>
<td>
<p>a real valued parameter vector specifying the model.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(M(p+3)+M-M1-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=</code>(<strong><code class="reqn">\upsilon_{1}</code></strong><code class="reqn">,...,</code><strong><code class="reqn">\upsilon_{M}</code></strong>,
<code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>) where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn">=(\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,</code><code class="reqn">\sigma_{m}^2)</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p}), m=1,...,M</code>
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMAR type regimes.
</p>
</li></ul>

<p>In the <strong>GMAR</strong> model, <code class="reqn">M1=M</code> and the parameter <strong><code class="reqn">\nu</code></strong> dropped. In the <strong>StMAR</strong> model, <code class="reqn">M1=0</code>.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vectors <strong><code class="reqn">\phi_{m}</code></strong> with the vectors <strong><code class="reqn">\psi_{m}</code></strong> that satisfy
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(3M+M-M1+p-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=(\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">,</code>
<code class="reqn">\sigma_{1}^2,...,\sigma_{M}^2,</code><code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where <strong><code class="reqn">\phi</code></strong>=<code class="reqn">(\phi_{1},...,\phi_{p})</code>
contains the AR coefficients, which are common for all regimes.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vector <strong><code class="reqn">\phi</code></strong> with the vector <strong><code class="reqn">\psi</code></strong> that satisfies
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
</dl>

<p>Symbol <code class="reqn">\phi</code> denotes an AR coefficient, <code class="reqn">\sigma^2</code> a variance, <code class="reqn">\alpha</code> a mixing weight, and <code class="reqn">\nu</code> a degrees of
freedom parameter. If <code>parametrization=="mean"</code>, just replace each intercept term <code class="reqn">\phi_{m,0}</code> with the regimewise mean
<code class="reqn">\mu_m = \phi_{m,0}/(1-\sum\phi_{i,m})</code>. In the <strong>G-StMAR</strong> model, the first <code>M1</code> components are <em>GMAR type</em>
and the rest <code>M2</code> components are <em>StMAR type</em>.
Note that in the case <strong>M=1</strong>, the mixing weight parameters <code class="reqn">\alpha</code> are dropped, and in the case of <strong>StMAR</strong> or <strong>G-StMAR</strong> model,
the degrees of freedom parameters <code class="reqn">\nu</code> have to be larger than <code class="reqn">2</code>.</p>
</td></tr>
<tr><td><code id="remove_all_constraints_+3A_model">model</code></td>
<td>
<p>is &quot;GMAR&quot;, &quot;StMAR&quot;, or &quot;G-StMAR&quot; model considered? In the G-StMAR model, the first <code>M1</code> components
are <em>GMAR type</em> and the rest <code>M2</code> components are <em>StMAR type</em>.</p>
</td></tr>
<tr><td><code id="remove_all_constraints_+3A_restricted">restricted</code></td>
<td>
<p>a logical argument stating whether the AR coefficients <code class="reqn">\phi_{m,1},...,\phi_{m,p}</code> are restricted
to be the same for all regimes.</p>
</td></tr>
<tr><td><code id="remove_all_constraints_+3A_constraints">constraints</code></td>
<td>
<p>specifies linear constraints imposed to each regime's autoregressive parameters separately.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd><p>a list of size <code class="reqn">(pxq_{m})</code> constraint matrices <strong><code class="reqn">C_{m}</code></strong> of full column rank
satisfying <strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> for all <code class="reqn">m=1,...,M</code>, where
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p})</code> and <strong><code class="reqn">\psi_{m}</code></strong><code class="reqn">=(\psi_{m,1},...,\psi_{m,q_{m}})</code>.</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd><p>a size <code class="reqn">(pxq)</code> constraint matrix <strong><code class="reqn">C</code></strong> of full column rank satisfying
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong>, where <strong><code class="reqn">\phi</code></strong><code class="reqn">=(\phi_{1},...,\phi_{p})</code> and
<strong><code class="reqn">\psi</code></strong><code class="reqn">=\psi_{1},...,\psi_{q}</code>.</p>
</dd>
</dl>

<p>The symbol <code class="reqn">\phi</code> denotes an AR coefficient. Note that regardless of any constraints, the autoregressive order
is always <code>p</code> for all regimes.
Ignore or set to <code>NULL</code> if applying linear constraints is not desired.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns such parameter vector corresponding to the input vector that is the form described in <code>params</code>
for non-restricted and non-constrained models.
</p>

<hr>
<h2 id='simudata'>Simulated data</h2><span id='topic+simudata'></span>

<h3>Description</h3>

<p>A dataset containing 200 observations simulated from a GMAR p=1, M=2 process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simudata
</code></pre>


<h3>Format</h3>

<p>A numeric vector of length 200.
</p>


<h3>Source</h3>

<p>Simulated
</p>

<hr>
<h2 id='simulate.gsmar'>Simulate obsercations from GMAR, StMAR, and G-StMAR processes</h2><span id='topic+simulate.gsmar'></span>

<h3>Description</h3>

<p><code>simulate.gsmar</code> simulates observations from the specified GMAR, StMAR, or G-StMAR process.
Can be utilized for forecasting future values of the process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gsmar'
simulate(
  object,
  nsim = 1,
  seed = NULL,
  ...,
  init_values = NULL,
  ntimes = 1,
  drop = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.gsmar_+3A_object">object</code></td>
<td>
<p>object of class <code>'gsmar'</code>, typically created with the function <code>fitGSMAR</code> or <code>GSMAR</code>.</p>
</td></tr>
<tr><td><code id="simulate.gsmar_+3A_nsim">nsim</code></td>
<td>
<p>a positive integer specifying how many values (ahead from <code>init_values</code>) will be simulated.</p>
</td></tr>
<tr><td><code id="simulate.gsmar_+3A_seed">seed</code></td>
<td>
<p>an integer that specifies the seed for the random number generator. Ignored if <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="simulate.gsmar_+3A_...">...</code></td>
<td>
<p>currently not in use.</p>
</td></tr>
<tr><td><code id="simulate.gsmar_+3A_init_values">init_values</code></td>
<td>
<p>a numeric vector with length <code>&gt;=p</code> specifying the initial values for the simulation. The <strong>last</strong>
element will be used as the initial value for the first lag, the second last element will be initial value for the second lag, etc.
If <code>NULL</code>, initial values will be simulated from the process's stationary distribution.</p>
</td></tr>
<tr><td><code id="simulate.gsmar_+3A_ntimes">ntimes</code></td>
<td>
<p>a positive integer specifying how many sets of simulations should be performed.</p>
</td></tr>
<tr><td><code id="simulate.gsmar_+3A_drop">drop</code></td>
<td>
<p>if <code>TRUE</code> (default) then the components of the returned list are coerced to lower dimension if <code>ntimes==1</code>,
i.e., <code>$sample</code> and <code>$component</code> will be vectors and <code>$mixing_weights</code> will be matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>ntimes</code> is intended for forecasting: a GSMAR process can be forecasted by simulating its
possible future values. One can perform a large number of sets of simulations and calculate the sample quantiles from
the simulated values to obtain prediction intervals. See the forecasting example below for a hand-on demonstration.
</p>


<h3>Value</h3>

<p>If <code>drop==TRUE</code> and <code>ntimes==1</code> (default): <code>$sample</code> and <code>$component</code> are vectors
and <code>$mixing_weights</code> is a (<code>nsim</code><code class="reqn">xM</code>) matrix. Otherwise, returns a list with...
</p>

<dl>
<dt><code>$sample</code></dt><dd><p>a size (<code>nsim</code><code class="reqn">x</code><code>ntimes</code>) matrix containing the simulated values.</p>
</dd>
<dt><code>$component</code></dt><dd><p>a size (<code>nsim</code><code class="reqn">x</code><code>ntimes</code>) matrix containing the information from which
mixture component each value was generated from.</p>
</dd>
<dt><code>$mixing_weights</code></dt><dd><p>a size (<code>nsim</code><code class="reqn">xMx</code><code>ntimes</code>) array containing the mixing weights corresponding to the
sample: the dimension <code>[i, , ]</code> is the time index, the dimension <code>[, i, ]</code> indicates the regime, and the dimension
<code>[, , i]</code> indicates the i:th set of simulations.</p>
</dd>
</dl>



<h3>References</h3>


<ul>
<li><p> Galbraith, R., Galbraith, J. 1974. On the inverses of some patterned matrices arising
in the theory of stationary time series. <em>Journal of Applied Probability</em> <strong>11</strong>, 63-71.
</p>
</li>
<li><p> Kalliovirta L. (2012) Misspecification tests based on quantile residuals.
<em>The Econometrics Journal</em>, <strong>15</strong>, 358-393.
</p>
</li>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2015. Gaussian Mixture Autoregressive model for univariate time series.
<em>Journal of Time Series Analysis</em>, <strong>36</strong>(2), 247-266.
</p>
</li>
<li><p> Meitz M., Preve D., Saikkonen P. 2023. A mixture autoregressive model based on Student's t-distribution.
<em>Communications in Statistics - Theory and Methods</em>, <strong>52</strong>(2), 499-515.
</p>
</li>
<li><p> Virolainen S. 2022. A mixture autoregressive model based on Gaussian and Student's t-distributions.
Studies in Nonlinear Dynamics &amp; Econometrics, <strong>26</strong>(4) 559-580.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+fitGSMAR">fitGSMAR</a></code>, <code><a href="#topic+GSMAR">GSMAR</a></code>, <code><a href="#topic+predict.gsmar">predict.gsmar</a></code>,
<code><a href="#topic+add_data">add_data</a></code>, <code><a href="#topic+cond_moments">cond_moments</a></code>, <code><a href="#topic+mixing_weights">mixing_weights</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)

# GMAR model:
params22 &lt;- c(0.9, 0.4, 0.2, 0.5, 0.7, 0.5, -0.2, 0.7, 0.7)
mod22 &lt;- GSMAR(p=2, M=2, params=params22, model="GMAR")
mysim &lt;- simulate(mod22, nsim=500)
ts.plot(mysim$sample)
ts.plot(mysim$component)
ts.plot(mysim$mixing_weights, col=rainbow(2), lty=2)


# G-StMAR model, with initial values:
params42gs &lt;- c(0.04, 1.34, -0.59, 0.54, -0.36, 0.01, 0.06, 1.28, -0.36,
                0.2, -0.15, 0.04, 0.19, 9.75)
gstmar42 &lt;- GSMAR(data=M10Y1Y, p=4, M=c(1, 1), params=params42gs,
                  model="G-StMAR")
sim42gs &lt;- simulate(gstmar42, nsim=500, init_values=1:4)
ts.plot(sim42gs$sample)
ts.plot(sim42gs$component)
ts.plot(sim42gs$mixing_weights, col=rainbow(2), lty=2)


# FORECASTING EXAMPLE:
# GMAR model, 1000 sets of simulations with initial values from the data:
params12 &lt;- c(1.70, 0.85, 0.30, 4.12, 0.73, 1.98, 0.63)
gmar12 &lt;- GSMAR(data=simudata, p=1, M=2, params=params12, model="GMAR")
sim12 &lt;- simulate(gmar12, nsim=5, init_val=gmar12$data, ntimes=1000)
apply(sim12$sample, MARGIN=1, FUN=median) # Point prediction
apply(sim12$sample, MARGIN=1, FUN=quantile, probs=c(0.025, 0.975)) # 95% pi
apply(sim12$mixing_weights, MARGIN=1:2, FUN=median) # mix.weight point pred
apply(sim12$mixing_weights, MARGIN=1:2, FUN=quantile,
      probs=c(0.025, 0.975)) # mix.weight 95% prediction intervals
</code></pre>

<hr>
<h2 id='simulateGSMAR'>DEPRECATED, USE <code>simulate.gsmar</code> INSTEAD! Simulate observations from GMAR, StMAR, and G-StMAR processes</h2><span id='topic+simulateGSMAR'></span>

<h3>Description</h3>

<p><code>simulateGSMAR</code> simulates observations from the specified GMAR, StMAR, or G-StMAR process.
Can be utilized for forecasting future values of the process. DEPRECATED, USE <code>simulate.gsmar</code> INSTEAD!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateGSMAR(
  object,
  nsim,
  init_values = NULL,
  ntimes = 1,
  drop = TRUE,
  gsmar = NULL,
  nsimu = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulateGSMAR_+3A_object">object</code></td>
<td>
<p>object of class <code>'gsmar'</code>, typically created with the function <code>fitGSMAR</code> or <code>GSMAR</code>.</p>
</td></tr>
<tr><td><code id="simulateGSMAR_+3A_nsim">nsim</code></td>
<td>
<p>a positive integer specifying how many values (ahead from <code>init_values</code>) will be simulated.</p>
</td></tr>
<tr><td><code id="simulateGSMAR_+3A_init_values">init_values</code></td>
<td>
<p>a numeric vector with length <code>&gt;=p</code> specifying the initial values for the simulation. The <strong>last</strong>
element will be used as the initial value for the first lag, the second last element will be initial value for the second lag, etc.
If <code>NULL</code>, initial values will be simulated from the process's stationary distribution.</p>
</td></tr>
<tr><td><code id="simulateGSMAR_+3A_ntimes">ntimes</code></td>
<td>
<p>a positive integer specifying how many sets of simulations should be performed.</p>
</td></tr>
<tr><td><code id="simulateGSMAR_+3A_drop">drop</code></td>
<td>
<p>if <code>TRUE</code> (default) then the components of the returned list are coerced to lower dimension if <code>ntimes==1</code>,
i.e., <code>$sample</code> and <code>$component</code> will be vectors and <code>$mixing_weights</code> will be matrix.</p>
</td></tr>
<tr><td><code id="simulateGSMAR_+3A_gsmar">gsmar</code></td>
<td>
<p>a class 'gsmar' object, typically generated by <code>fitGSMAR</code> or <code>GSMAR</code>.</p>
</td></tr>
<tr><td><code id="simulateGSMAR_+3A_nsimu">nsimu</code></td>
<td>
<p>a positive integer specifying how many values (ahead from <code>init_values</code>) will be simulated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>DEPRECATED, USE <code>simulate.gsmar</code> INSTEAD!
</p>
<p>The argument <code>ntimes</code> is intended for forecasting: a GSMAR process can be forecasted by simulating its
possible future values. One can perform a large number of sets of simulations and calculate the sample quantiles from
the simulated values to obtain prediction intervals. See the forecasting example below for a hand-on demonstration.
</p>


<h3>Value</h3>

<p>If <code>drop==TRUE</code> and <code>ntimes==1</code> (default): <code>$sample</code> and <code>$component</code> are vectors
and <code>$mixing_weights</code> is a (<code>nsim</code><code class="reqn">xM</code>) matrix. Otherwise, returns a list with...
</p>

<dl>
<dt><code>$sample</code></dt><dd><p>a size (<code>nsim</code><code class="reqn">x</code><code>ntimes</code>) matrix containing the simulated values.</p>
</dd>
<dt><code>$component</code></dt><dd><p>a size (<code>nsim</code><code class="reqn">x</code><code>ntimes</code>) matrix containing the information from which
mixture component each value was generated from.</p>
</dd>
<dt><code>$mixing_weights</code></dt><dd><p>a size (<code>nsim</code><code class="reqn">xMx</code><code>ntimes</code>) array containing the mixing weights corresponding to the
sample: the dimension <code>[i, , ]</code> is the time index, the dimension <code>[, i, ]</code> indicates the regime, and the dimension
<code>[, , i]</code> indicates the i:th set of simulations.</p>
</dd>
</dl>



<h3>References</h3>


<ul>
<li><p> Galbraith, R., Galbraith, J. 1974. On the inverses of some patterned matrices arising
in the theory of stationary time series. <em>Journal of Applied Probability</em> <strong>11</strong>, 63-71.
</p>
</li>
<li><p> Kalliovirta L. (2012) Misspecification tests based on quantile residuals.
<em>The Econometrics Journal</em>, <strong>15</strong>, 358-393.
</p>
</li>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2015. Gaussian Mixture Autoregressive model for univariate time series.
<em>Journal of Time Series Analysis</em>, <strong>36</strong>(2), 247-266.
</p>
</li>
<li><p> Meitz M., Preve D., Saikkonen P. 2023. A mixture autoregressive model based on Student's t-distribution.
<em>Communications in Statistics - Theory and Methods</em>, <strong>52</strong>(2), 499-515.
</p>
</li>
<li><p> Virolainen S. 2022. A mixture autoregressive model based on Gaussian and Student's t-distributions.
Studies in Nonlinear Dynamics &amp; Econometrics, <strong>26</strong>(4) 559-580.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+fitGSMAR">fitGSMAR</a></code>, <code><a href="#topic+GSMAR">GSMAR</a></code>, <code><a href="#topic+predict.gsmar">predict.gsmar</a></code>,
<code><a href="#topic+add_data">add_data</a></code>, <code><a href="#topic+cond_moments">cond_moments</a></code>, <code><a href="#topic+mixing_weights">mixing_weights</a></code>
</p>

<hr>
<h2 id='sort_components'>Sort the mixture components of a GMAR, StMAR, or G-StMAR model</h2><span id='topic+sort_components'></span>

<h3>Description</h3>

<p><code>sort_components</code> sorts mixture components of the specified GMAR, StMAR, or G-StMAR model
according to the mixing weight parameters when the parameter vector has the &quot;standard/regular form&quot; for
restricted or non-restricted models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sort_components(
  p,
  M,
  params,
  model = c("GMAR", "StMAR", "G-StMAR"),
  restricted = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort_components_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="sort_components_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMAR</strong> and <strong>StMAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMAR type</em> components <code>M1</code> in the
first element and <em>StMAR type</em> components <code>M2</code> in the second element. The total number of mixture components is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="sort_components_+3A_params">params</code></td>
<td>
<p>a real valued parameter vector specifying the model.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(M(p+3)+M-M1-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=</code>(<strong><code class="reqn">\upsilon_{1}</code></strong><code class="reqn">,...,</code><strong><code class="reqn">\upsilon_{M}</code></strong>,
<code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>) where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn">=(\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,</code><code class="reqn">\sigma_{m}^2)</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p}), m=1,...,M</code>
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMAR type regimes.
</p>
</li></ul>

<p>In the <strong>GMAR</strong> model, <code class="reqn">M1=M</code> and the parameter <strong><code class="reqn">\nu</code></strong> dropped. In the <strong>StMAR</strong> model, <code class="reqn">M1=0</code>.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vectors <strong><code class="reqn">\phi_{m}</code></strong> with the vectors <strong><code class="reqn">\psi_{m}</code></strong> that satisfy
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(3M+M-M1+p-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=(\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">,</code>
<code class="reqn">\sigma_{1}^2,...,\sigma_{M}^2,</code><code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where <strong><code class="reqn">\phi</code></strong>=<code class="reqn">(\phi_{1},...,\phi_{p})</code>
contains the AR coefficients, which are common for all regimes.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vector <strong><code class="reqn">\phi</code></strong> with the vector <strong><code class="reqn">\psi</code></strong> that satisfies
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
</dl>

<p>Symbol <code class="reqn">\phi</code> denotes an AR coefficient, <code class="reqn">\sigma^2</code> a variance, <code class="reqn">\alpha</code> a mixing weight, and <code class="reqn">\nu</code> a degrees of
freedom parameter. If <code>parametrization=="mean"</code>, just replace each intercept term <code class="reqn">\phi_{m,0}</code> with the regimewise mean
<code class="reqn">\mu_m = \phi_{m,0}/(1-\sum\phi_{i,m})</code>. In the <strong>G-StMAR</strong> model, the first <code>M1</code> components are <em>GMAR type</em>
and the rest <code>M2</code> components are <em>StMAR type</em>.
Note that in the case <strong>M=1</strong>, the mixing weight parameters <code class="reqn">\alpha</code> are dropped, and in the case of <strong>StMAR</strong> or <strong>G-StMAR</strong> model,
the degrees of freedom parameters <code class="reqn">\nu</code> have to be larger than <code class="reqn">2</code>.</p>
</td></tr>
<tr><td><code id="sort_components_+3A_model">model</code></td>
<td>
<p>is &quot;GMAR&quot;, &quot;StMAR&quot;, or &quot;G-StMAR&quot; model considered? In the G-StMAR model, the first <code>M1</code> components
are <em>GMAR type</em> and the rest <code>M2</code> components are <em>StMAR type</em>.</p>
</td></tr>
<tr><td><code id="sort_components_+3A_restricted">restricted</code></td>
<td>
<p>a logical argument stating whether the AR coefficients <code class="reqn">\phi_{m,1},...,\phi_{m,p}</code> are restricted
to be the same for all regimes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function does not support models imposing linear constraints.
</p>


<h3>Value</h3>

<p>Returns a parameter vector sorted according to its mixing weight parameters,
described in <code>params</code>.
</p>

<hr>
<h2 id='standard_errors'>Calculate standard errors for estimates of a GMAR, StMAR, or G-StMAR model</h2><span id='topic+standard_errors'></span>

<h3>Description</h3>

<p><code>standard_errors</code> numerically approximates standard errors for the given estimates of GMAR, StMAR, or GStMAR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standard_errors(
  data,
  p,
  M,
  params,
  model = c("GMAR", "StMAR", "G-StMAR"),
  restricted = FALSE,
  constraints = NULL,
  conditional = TRUE,
  parametrization = c("intercept", "mean"),
  custom_h = NULL,
  minval
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standard_errors_+3A_data">data</code></td>
<td>
<p>a numeric vector or class <code>'ts'</code> object containing the data. <code>NA</code> values are not supported.</p>
</td></tr>
<tr><td><code id="standard_errors_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="standard_errors_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMAR</strong> and <strong>StMAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMAR type</em> components <code>M1</code> in the
first element and <em>StMAR type</em> components <code>M2</code> in the second element. The total number of mixture components is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="standard_errors_+3A_params">params</code></td>
<td>
<p>a real valued parameter vector specifying the model.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(M(p+3)+M-M1-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=</code>(<strong><code class="reqn">\upsilon_{1}</code></strong><code class="reqn">,...,</code><strong><code class="reqn">\upsilon_{M}</code></strong>,
<code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>) where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn">=(\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,</code><code class="reqn">\sigma_{m}^2)</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p}), m=1,...,M</code>
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMAR type regimes.
</p>
</li></ul>

<p>In the <strong>GMAR</strong> model, <code class="reqn">M1=M</code> and the parameter <strong><code class="reqn">\nu</code></strong> dropped. In the <strong>StMAR</strong> model, <code class="reqn">M1=0</code>.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vectors <strong><code class="reqn">\phi_{m}</code></strong> with the vectors <strong><code class="reqn">\psi_{m}</code></strong> that satisfy
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(3M+M-M1+p-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=(\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">,</code>
<code class="reqn">\sigma_{1}^2,...,\sigma_{M}^2,</code><code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where <strong><code class="reqn">\phi</code></strong>=<code class="reqn">(\phi_{1},...,\phi_{p})</code>
contains the AR coefficients, which are common for all regimes.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vector <strong><code class="reqn">\phi</code></strong> with the vector <strong><code class="reqn">\psi</code></strong> that satisfies
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
</dl>

<p>Symbol <code class="reqn">\phi</code> denotes an AR coefficient, <code class="reqn">\sigma^2</code> a variance, <code class="reqn">\alpha</code> a mixing weight, and <code class="reqn">\nu</code> a degrees of
freedom parameter. If <code>parametrization=="mean"</code>, just replace each intercept term <code class="reqn">\phi_{m,0}</code> with the regimewise mean
<code class="reqn">\mu_m = \phi_{m,0}/(1-\sum\phi_{i,m})</code>. In the <strong>G-StMAR</strong> model, the first <code>M1</code> components are <em>GMAR type</em>
and the rest <code>M2</code> components are <em>StMAR type</em>.
Note that in the case <strong>M=1</strong>, the mixing weight parameters <code class="reqn">\alpha</code> are dropped, and in the case of <strong>StMAR</strong> or <strong>G-StMAR</strong> model,
the degrees of freedom parameters <code class="reqn">\nu</code> have to be larger than <code class="reqn">2</code>.</p>
</td></tr>
<tr><td><code id="standard_errors_+3A_model">model</code></td>
<td>
<p>is &quot;GMAR&quot;, &quot;StMAR&quot;, or &quot;G-StMAR&quot; model considered? In the G-StMAR model, the first <code>M1</code> components
are <em>GMAR type</em> and the rest <code>M2</code> components are <em>StMAR type</em>.</p>
</td></tr>
<tr><td><code id="standard_errors_+3A_restricted">restricted</code></td>
<td>
<p>a logical argument stating whether the AR coefficients <code class="reqn">\phi_{m,1},...,\phi_{m,p}</code> are restricted
to be the same for all regimes.</p>
</td></tr>
<tr><td><code id="standard_errors_+3A_constraints">constraints</code></td>
<td>
<p>specifies linear constraints imposed to each regime's autoregressive parameters separately.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd><p>a list of size <code class="reqn">(pxq_{m})</code> constraint matrices <strong><code class="reqn">C_{m}</code></strong> of full column rank
satisfying <strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> for all <code class="reqn">m=1,...,M</code>, where
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p})</code> and <strong><code class="reqn">\psi_{m}</code></strong><code class="reqn">=(\psi_{m,1},...,\psi_{m,q_{m}})</code>.</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd><p>a size <code class="reqn">(pxq)</code> constraint matrix <strong><code class="reqn">C</code></strong> of full column rank satisfying
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong>, where <strong><code class="reqn">\phi</code></strong><code class="reqn">=(\phi_{1},...,\phi_{p})</code> and
<strong><code class="reqn">\psi</code></strong><code class="reqn">=\psi_{1},...,\psi_{q}</code>.</p>
</dd>
</dl>

<p>The symbol <code class="reqn">\phi</code> denotes an AR coefficient. Note that regardless of any constraints, the autoregressive order
is always <code>p</code> for all regimes.
Ignore or set to <code>NULL</code> if applying linear constraints is not desired.</p>
</td></tr>
<tr><td><code id="standard_errors_+3A_conditional">conditional</code></td>
<td>
<p>a logical argument specifying whether the conditional or exact log-likelihood function should be used.</p>
</td></tr>
<tr><td><code id="standard_errors_+3A_parametrization">parametrization</code></td>
<td>
<p>is the model parametrized with the &quot;intercepts&quot; <code class="reqn">\phi_{m,0}</code> or
&quot;means&quot; <code class="reqn">\mu_{m} = \phi_{m,0}/(1-\sum\phi_{i,m})</code>?</p>
</td></tr>
<tr><td><code id="standard_errors_+3A_custom_h">custom_h</code></td>
<td>
<p>a numeric vector with the same length as <code>params</code> specifying the difference 'h' used in finite difference approximation
for each parameter separately. If <code>NULL</code> (default), then the difference used for differentiating overly large degrees of freedom
parameters is adjusted to avoid numerical problems, and the difference is <code>6e-6</code> for the other parameters.</p>
</td></tr>
<tr><td><code id="standard_errors_+3A_minval">minval</code></td>
<td>
<p>this will be returned when the parameter vector is outside the parameter space and <code>boundaries==TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns approximate standard errors of the parameter values in a numeric vector.
</p>

<hr>
<h2 id='stmar_to_gstmar'>Estimate a G-StMAR model based on a StMAR model with large degrees of freedom parameters</h2><span id='topic+stmar_to_gstmar'></span>

<h3>Description</h3>

<p><code>stmar_to_gstmar</code> estimates a G-StMAR model based on a StMAR model with large degree
of freedom parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stmar_to_gstmar(
  gsmar,
  maxdf = 100,
  estimate,
  calc_std_errors,
  maxit = 100,
  custom_h = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stmar_to_gstmar_+3A_gsmar">gsmar</code></td>
<td>
<p>a class 'gsmar' object, typically generated by <code>fitGSMAR</code> or <code>GSMAR</code>.</p>
</td></tr>
<tr><td><code id="stmar_to_gstmar_+3A_maxdf">maxdf</code></td>
<td>
<p>regimes with degrees of freedom parameter value larger than this will be turned into
GMAR type.</p>
</td></tr>
<tr><td><code id="stmar_to_gstmar_+3A_estimate">estimate</code></td>
<td>
<p>set <code>TRUE</code> if the new model should be estimated with a variable metric algorithm
using the StMAR model parameter value as the initial value. By default <code>TRUE</code> iff the model
contains data.</p>
</td></tr>
<tr><td><code id="stmar_to_gstmar_+3A_calc_std_errors">calc_std_errors</code></td>
<td>
<p>set <code>TRUE</code> if the approximate standard errors should be calculated.
By default <code>TRUE</code> iff the model contains data.</p>
</td></tr>
<tr><td><code id="stmar_to_gstmar_+3A_maxit">maxit</code></td>
<td>
<p>the maximum number of iterations for the variable metric algorithm. Ignored if <code>estimate==FALSE</code>.</p>
</td></tr>
<tr><td><code id="stmar_to_gstmar_+3A_custom_h">custom_h</code></td>
<td>
<p>A numeric vector with same the length as the parameter vector: i:th element of custom_h is the difference
used in central difference approximation for partial differentials of the log-likelihood function for the i:th parameter.
If <code>NULL</code> (default), then the difference used for differentiating overly large degrees of freedom parameters
is adjusted to avoid numerical problems, and the difference is <code>6e-6</code> for the other parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a StMAR model contains large estimates for the degrees of freedom parameters,
one should consider switching to the corresponding G-StMAR model that lets the corresponding
regimes to be GMAR type. <code>stmar_to_gstmar</code> does this switch conveniently.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>'gsmar'</code> defining the specified GMAR, StMAR, or G-StMAR model. If data is supplied,
the returned object contains (by default) empirical mixing weights, some conditional and unconditional moments, and quantile
residuals. Note that the first p observations are taken as the initial values so the mixing weights, conditional moments, and
quantile residuals start from the p+1:th observation (interpreted as t=1).
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2015. Gaussian Mixture Autoregressive model for univariate time series.
<em>Journal of Time Series Analysis</em>, <strong>36</strong>(2), 247-266.
</p>
</li>
<li><p> Meitz M., Preve D., Saikkonen P. 2023. A mixture autoregressive model based on Student's t-distribution.
<em>Communications in Statistics - Theory and Methods</em>, <strong>52</strong>(2), 499-515.
</p>
</li>
<li><p> Virolainen S. 2022. A mixture autoregressive model based on Gaussian and Student's t-distributions.
Studies in Nonlinear Dynamics &amp; Econometrics, <strong>26</strong>(4) 559-580.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+fitGSMAR">fitGSMAR</a></code>, <code><a href="#topic+GSMAR">GSMAR</a></code>, <code><a href="#topic+iterate_more">iterate_more</a></code>, <code><a href="#topic+get_gradient">get_gradient</a></code>,
<code><a href="#topic+get_regime_means">get_regime_means</a></code>, <code><a href="#topic+swap_parametrization">swap_parametrization</a></code>, <code><a href="#topic+stmar_to_gstmar">stmar_to_gstmar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # These are long running example that take approximately 15 seconds to run.
 fit42t &lt;- fitGSMAR(data=M10Y1Y, p=4, M=2, model="StMAR", ncalls=1, seeds=6)
 fit42t # Overly large degrees of freedom estimate!

 # Switch to the appropriate G-StMAR model:
 fit42gs &lt;- stmar_to_gstmar(fit42t)
 fit42gs

</code></pre>

<hr>
<h2 id='stmarpars_to_gstmar'>Transform a StMAR or G-StMAR model parameter vector to a corresponding G-StMAR model parameter vector
with large dfs parameters reduced.</h2><span id='topic+stmarpars_to_gstmar'></span>

<h3>Description</h3>

<p><code>stmarpars_to_gstmar</code> transforms a StMAR model parameter vector to a corresponding
G-StMAR model parameter vector with large dfs parameters reduced by switching the related regimes
to be GMAR type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stmarpars_to_gstmar(
  p,
  M,
  params,
  model = c("GMAR", "StMAR", "G-StMAR"),
  restricted = FALSE,
  constraints = NULL,
  maxdf = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stmarpars_to_gstmar_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="stmarpars_to_gstmar_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMAR</strong> and <strong>StMAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMAR type</em> components <code>M1</code> in the
first element and <em>StMAR type</em> components <code>M2</code> in the second element. The total number of mixture components is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="stmarpars_to_gstmar_+3A_params">params</code></td>
<td>
<p>a real valued parameter vector specifying the model.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(M(p+3)+M-M1-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=</code>(<strong><code class="reqn">\upsilon_{1}</code></strong><code class="reqn">,...,</code><strong><code class="reqn">\upsilon_{M}</code></strong>,
<code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>) where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn">=(\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,</code><code class="reqn">\sigma_{m}^2)</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p}), m=1,...,M</code>
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMAR type regimes.
</p>
</li></ul>

<p>In the <strong>GMAR</strong> model, <code class="reqn">M1=M</code> and the parameter <strong><code class="reqn">\nu</code></strong> dropped. In the <strong>StMAR</strong> model, <code class="reqn">M1=0</code>.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vectors <strong><code class="reqn">\phi_{m}</code></strong> with the vectors <strong><code class="reqn">\psi_{m}</code></strong> that satisfy
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(3M+M-M1+p-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=(\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">,</code>
<code class="reqn">\sigma_{1}^2,...,\sigma_{M}^2,</code><code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where <strong><code class="reqn">\phi</code></strong>=<code class="reqn">(\phi_{1},...,\phi_{p})</code>
contains the AR coefficients, which are common for all regimes.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vector <strong><code class="reqn">\phi</code></strong> with the vector <strong><code class="reqn">\psi</code></strong> that satisfies
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
</dl>

<p>Symbol <code class="reqn">\phi</code> denotes an AR coefficient, <code class="reqn">\sigma^2</code> a variance, <code class="reqn">\alpha</code> a mixing weight, and <code class="reqn">\nu</code> a degrees of
freedom parameter. If <code>parametrization=="mean"</code>, just replace each intercept term <code class="reqn">\phi_{m,0}</code> with the regimewise mean
<code class="reqn">\mu_m = \phi_{m,0}/(1-\sum\phi_{i,m})</code>. In the <strong>G-StMAR</strong> model, the first <code>M1</code> components are <em>GMAR type</em>
and the rest <code>M2</code> components are <em>StMAR type</em>.
Note that in the case <strong>M=1</strong>, the mixing weight parameters <code class="reqn">\alpha</code> are dropped, and in the case of <strong>StMAR</strong> or <strong>G-StMAR</strong> model,
the degrees of freedom parameters <code class="reqn">\nu</code> have to be larger than <code class="reqn">2</code>.</p>
</td></tr>
<tr><td><code id="stmarpars_to_gstmar_+3A_model">model</code></td>
<td>
<p>is &quot;GMAR&quot;, &quot;StMAR&quot;, or &quot;G-StMAR&quot; model considered? In the G-StMAR model, the first <code>M1</code> components
are <em>GMAR type</em> and the rest <code>M2</code> components are <em>StMAR type</em>.</p>
</td></tr>
<tr><td><code id="stmarpars_to_gstmar_+3A_restricted">restricted</code></td>
<td>
<p>a logical argument stating whether the AR coefficients <code class="reqn">\phi_{m,1},...,\phi_{m,p}</code> are restricted
to be the same for all regimes.</p>
</td></tr>
<tr><td><code id="stmarpars_to_gstmar_+3A_constraints">constraints</code></td>
<td>
<p>specifies linear constraints imposed to each regime's autoregressive parameters separately.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd><p>a list of size <code class="reqn">(pxq_{m})</code> constraint matrices <strong><code class="reqn">C_{m}</code></strong> of full column rank
satisfying <strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> for all <code class="reqn">m=1,...,M</code>, where
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p})</code> and <strong><code class="reqn">\psi_{m}</code></strong><code class="reqn">=(\psi_{m,1},...,\psi_{m,q_{m}})</code>.</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd><p>a size <code class="reqn">(pxq)</code> constraint matrix <strong><code class="reqn">C</code></strong> of full column rank satisfying
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong>, where <strong><code class="reqn">\phi</code></strong><code class="reqn">=(\phi_{1},...,\phi_{p})</code> and
<strong><code class="reqn">\psi</code></strong><code class="reqn">=\psi_{1},...,\psi_{q}</code>.</p>
</dd>
</dl>

<p>The symbol <code class="reqn">\phi</code> denotes an AR coefficient. Note that regardless of any constraints, the autoregressive order
is always <code>p</code> for all regimes.
Ignore or set to <code>NULL</code> if applying linear constraints is not desired.</p>
</td></tr>
<tr><td><code id="stmarpars_to_gstmar_+3A_maxdf">maxdf</code></td>
<td>
<p>regimes with degrees of freedom parameter value larger than this will be turned into
GMAR type.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with three elements: <code>$params</code> contains the corresponding G-StMAR model
parameter vector, <code>$reg_order</code> contains the permutation that was applied to the regimes
(GMAR type components first, and decreasing ordering by mixing weight parameters), and
<code>$M</code> a vector of length two containing the number of GMAR type regimes in the first element
and the number of StMAR type regimes in the second.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> params12 &lt;- c(2, 0.9, 0.1, 0.8, 0.5, 0.5, 0.4, 12, 300)
 stmarpars_to_gstmar(p=1, M=2, params=params12, model="StMAR", maxdf=100)
</code></pre>

<hr>
<h2 id='swap_parametrization'>Swap the parametrization of object of class 'gsmar' defining a GMAR, StMAR, or G-StMAR model</h2><span id='topic+swap_parametrization'></span>

<h3>Description</h3>

<p><code>swap_parametrization</code> swaps the parametrization of object of class '<code>gsmar</code>'
to <code>"mean"</code> if the current parametrization is <code>"intercept"</code>, and vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swap_parametrization(gsmar, calc_std_errors = TRUE, custom_h = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="swap_parametrization_+3A_gsmar">gsmar</code></td>
<td>
<p>a class 'gsmar' object, typically generated by <code>fitGSMAR</code> or <code>GSMAR</code>.</p>
</td></tr>
<tr><td><code id="swap_parametrization_+3A_calc_std_errors">calc_std_errors</code></td>
<td>
<p>should approximate standard errors be calculated?</p>
</td></tr>
<tr><td><code id="swap_parametrization_+3A_custom_h">custom_h</code></td>
<td>
<p>A numeric vector with same the length as the parameter vector: i:th element of custom_h is the difference
used in central difference approximation for partial differentials of the log-likelihood function for the i:th parameter.
If <code>NULL</code> (default), then the difference used for differentiating overly large degrees of freedom parameters
is adjusted to avoid numerical problems, and the difference is <code>6e-6</code> for the other parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>swap_parametrization</code> is a convenient tool if you have estimated the model in
&quot;intercept&quot;-parametrization but wish to work with &quot;mean&quot;-parametrization in the future,
or vice versa. For example, approximate standard errors are readily available for
parametrized parameters only.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>'gsmar'</code> defining the specified GMAR, StMAR, or G-StMAR model. If data is supplied,
the returned object contains (by default) empirical mixing weights, some conditional and unconditional moments, and quantile
residuals. Note that the first p observations are taken as the initial values so the mixing weights, conditional moments, and
quantile residuals start from the p+1:th observation (interpreted as t=1).
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2015. Gaussian Mixture Autoregressive model for univariate time series.
<em>Journal of Time Series Analysis</em>, <strong>36</strong>(2), 247-266.
</p>
</li>
<li><p> Meitz M., Preve D., Saikkonen P. 2023. A mixture autoregressive model based on Student's t-distribution.
<em>Communications in Statistics - Theory and Methods</em>, <strong>52</strong>(2), 499-515.
</p>
</li>
<li><p> Virolainen S. 2022. A mixture autoregressive model based on Gaussian and Student's t-distributions.
Studies in Nonlinear Dynamics &amp; Econometrics, <strong>26</strong>(4) 559-580.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+fitGSMAR">fitGSMAR</a></code>, <code><a href="#topic+GSMAR">GSMAR</a></code>, <code><a href="#topic+iterate_more">iterate_more</a></code>, <code><a href="#topic+get_gradient">get_gradient</a></code>,
<code><a href="#topic+get_regime_means">get_regime_means</a></code>, <code><a href="#topic+swap_parametrization">swap_parametrization</a></code>, <code><a href="#topic+stmar_to_gstmar">stmar_to_gstmar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># G-StMAR model with intercept parametrization
params42gs &lt;- c(0.04, 1.34, -0.59, 0.54, -0.36, 0.01, 0.06, 1.28, -0.36,
                0.2, -0.15, 0.04, 0.19, 9.75)
gstmar42 &lt;- GSMAR(data=M10Y1Y, p=4, M=c(1, 1), params=params42gs,
                  model="G-StMAR")
summary(gstmar42)

# Swap to mean parametrization
gstmar42 &lt;- swap_parametrization(gstmar42)
summary(gstmar42)
</code></pre>

<hr>
<h2 id='T10Y1Y'>Spread between 10-Year and 1-Year Treasury rates: T10Y1Y</h2><span id='topic+T10Y1Y'></span>

<h3>Description</h3>

<p>A dataset containing monthly U.S. interest rate spread between the 10-Year Treasury constant
maturity rate and 1-Year Treasury constant maturity rate from 1953IV to 2020II.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>T10Y1Y
</code></pre>


<h3>Format</h3>

<p>A class 'ts' time series object containing 803 observations.
</p>


<h3>Source</h3>

<p><a href="https://fred.stlouisfed.org/series/GS10">https://fred.stlouisfed.org/series/GS10</a> <a href="https://fred.stlouisfed.org/series/GS1">https://fred.stlouisfed.org/series/GS1</a>
</p>

<hr>
<h2 id='TBFF'>Spread between the 3-month Treasury bill rate and the effective federal funds rate: TBFF</h2><span id='topic+TBFF'></span>

<h3>Description</h3>

<p>A dataset containing the monthly U.S. interest rate spread between the 3-month Treasury bill secondary
market rate and the effective federal funds rate from 1954 July to 2019 July (781 observations).
This series was studied in the empirical application of Virolainen (2021) introducing the
G-StMAR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TBFF
</code></pre>


<h3>Format</h3>

<p>A class 'ts' time series object containing 781 observations.
</p>


<h3>Source</h3>

<p><a href="https://fred.stlouisfed.org/series/TB3SMFFM">https://fred.stlouisfed.org/series/TB3SMFFM</a>
</p>


<h3>References</h3>


<ul>
<li><p> Virolainen S. 2021. A mixture autoregressive model based on Gaussian and Student's t-distributions.
Studies in Nonlinear Dynamics &amp; Econometrics, doi: 10.1515/snde-2020-0060
</p>
</li></ul>


<hr>
<h2 id='uGMAR-package'>uGMAR: Estimate Univariate Gaussian and Student's t Mixture Autoregressive Models</h2><span id='topic+uGMAR'></span><span id='topic+uGMAR-package'></span>

<h3>Description</h3>

<p><code>uGMAR</code> is a package for estimating univariate Gaussian mixture autoregressive (GMAR),
Student's t mixture autoregressive (StMAR), and Gaussian and Student's t mixture autoregressive (G-StMAR) models.
In addition to unconstrained and constrained estimation, <code>uGMAR</code> provides tools for quantile residual based model
diagnostics, forecasting, simulation, and more.
</p>
<p>The readme file or the vignette is a good place to start.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Savi Virolainen <a href="mailto:savi.virolainen@helsinki.fi">savi.virolainen@helsinki.fi</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li><p> Report bugs at <a href="https://github.com/saviviro/uGMAR/issues">https://github.com/saviviro/uGMAR/issues</a>
</p>
</li></ul>


<hr>
<h2 id='uncond_moments'>Calculate unconditional mean, variance, first p autocovariances and autocorrelations of the GSMAR process.</h2><span id='topic+uncond_moments'></span>

<h3>Description</h3>

<p><code>uncond_moments</code> calculates the unconditional mean, variance, and the first p autocovariances
and autocorrelations of the GSMAR process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uncond_moments(gsmar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uncond_moments_+3A_gsmar">gsmar</code></td>
<td>
<p>a class 'gsmar' object, typically generated by <code>fitGSMAR</code> or <code>GSMAR</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing the unconditional mean, variance, and the first p autocovariances and
autocorrelations. Note that the lag-zero autocovariance/correlation is not included in the &quot;first p&quot;
but is given in the <code>uncond_variance</code> component separately.
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2015. Gaussian Mixture Autoregressive model for univariate time series.
<em>Journal of Time Series Analysis</em>, <strong>36</strong>(2), 247-266.
</p>
</li>
<li><p> Meitz M., Preve D., Saikkonen P. 2023. A mixture autoregressive model based on Student's t-distribution.
<em>Communications in Statistics - Theory and Methods</em>, <strong>52</strong>(2), 499-515.
</p>
</li>
<li><p> Virolainen S. 2022. A mixture autoregressive model based on Gaussian and Student's t-distributions.
Studies in Nonlinear Dynamics &amp; Econometrics, <strong>26</strong>(4) 559-580.
</p>
</li>
<li><p> Ltkepohl H. 2005. New Introduction to Multiple Time Series Analysis. <em>Springer</em>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other moment functions: 
<code><a href="#topic+cond_moments">cond_moments</a>()</code>,
<code><a href="#topic+get_regime_autocovs">get_regime_autocovs</a>()</code>,
<code><a href="#topic+get_regime_means">get_regime_means</a>()</code>,
<code><a href="#topic+get_regime_vars">get_regime_vars</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># GMAR model
params13 &lt;- c(1.4, 0.88, 0.26, 2.46, 0.82, 0.74, 5.0, 0.68, 5.2, 0.72, 0.2)
gmar13 &lt;- GSMAR(p=1, M=3, params=params13, model="GMAR")
uncond_moments(gmar13)

# StMAR model
params12t &lt;- c(1.38, 0.88, 0.27, 3.8, 0.74, 3.15, 0.8, 100, 3.6)
stmar12t &lt;- GSMAR(p=1, M=2, params=params12t, model="StMAR")
uncond_moments(stmar12t)

# G-StMAR model (similar to the StMAR model above)
params12gs &lt;- c(1.38, 0.88, 0.27, 3.8, 0.74, 3.15, 0.8, 3.6)
gstmar12 &lt;- GSMAR(p=1, M=c(1, 1), params=params12gs, model="G-StMAR")
uncond_moments(gstmar12)
</code></pre>

<hr>
<h2 id='uncond_moments_int'>Calculate unconditional mean, variance, and the first p autocovariances and autocorrelations
of a GSMAR process.</h2><span id='topic+uncond_moments_int'></span>

<h3>Description</h3>

<p><code>uncond_moments_int</code> calculates the unconditional mean, variance, and the first p
autocovariances and autocorrelations of the specified GSMAR process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uncond_moments_int(
  p,
  M,
  params,
  model = c("GMAR", "StMAR", "G-StMAR"),
  restricted = FALSE,
  constraints = NULL,
  parametrization = c("intercept", "mean")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uncond_moments_int_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="uncond_moments_int_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMAR</strong> and <strong>StMAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMAR type</em> components <code>M1</code> in the
first element and <em>StMAR type</em> components <code>M2</code> in the second element. The total number of mixture components is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="uncond_moments_int_+3A_params">params</code></td>
<td>
<p>a real valued parameter vector specifying the model.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(M(p+3)+M-M1-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=</code>(<strong><code class="reqn">\upsilon_{1}</code></strong><code class="reqn">,...,</code><strong><code class="reqn">\upsilon_{M}</code></strong>,
<code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>) where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn">=(\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,</code><code class="reqn">\sigma_{m}^2)</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p}), m=1,...,M</code>
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMAR type regimes.
</p>
</li></ul>

<p>In the <strong>GMAR</strong> model, <code class="reqn">M1=M</code> and the parameter <strong><code class="reqn">\nu</code></strong> dropped. In the <strong>StMAR</strong> model, <code class="reqn">M1=0</code>.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vectors <strong><code class="reqn">\phi_{m}</code></strong> with the vectors <strong><code class="reqn">\psi_{m}</code></strong> that satisfy
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(3M+M-M1+p-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=(\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">,</code>
<code class="reqn">\sigma_{1}^2,...,\sigma_{M}^2,</code><code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where <strong><code class="reqn">\phi</code></strong>=<code class="reqn">(\phi_{1},...,\phi_{p})</code>
contains the AR coefficients, which are common for all regimes.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vector <strong><code class="reqn">\phi</code></strong> with the vector <strong><code class="reqn">\psi</code></strong> that satisfies
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
</dl>

<p>Symbol <code class="reqn">\phi</code> denotes an AR coefficient, <code class="reqn">\sigma^2</code> a variance, <code class="reqn">\alpha</code> a mixing weight, and <code class="reqn">\nu</code> a degrees of
freedom parameter. If <code>parametrization=="mean"</code>, just replace each intercept term <code class="reqn">\phi_{m,0}</code> with the regimewise mean
<code class="reqn">\mu_m = \phi_{m,0}/(1-\sum\phi_{i,m})</code>. In the <strong>G-StMAR</strong> model, the first <code>M1</code> components are <em>GMAR type</em>
and the rest <code>M2</code> components are <em>StMAR type</em>.
Note that in the case <strong>M=1</strong>, the mixing weight parameters <code class="reqn">\alpha</code> are dropped, and in the case of <strong>StMAR</strong> or <strong>G-StMAR</strong> model,
the degrees of freedom parameters <code class="reqn">\nu</code> have to be larger than <code class="reqn">2</code>.</p>
</td></tr>
<tr><td><code id="uncond_moments_int_+3A_model">model</code></td>
<td>
<p>is &quot;GMAR&quot;, &quot;StMAR&quot;, or &quot;G-StMAR&quot; model considered? In the G-StMAR model, the first <code>M1</code> components
are <em>GMAR type</em> and the rest <code>M2</code> components are <em>StMAR type</em>.</p>
</td></tr>
<tr><td><code id="uncond_moments_int_+3A_restricted">restricted</code></td>
<td>
<p>a logical argument stating whether the AR coefficients <code class="reqn">\phi_{m,1},...,\phi_{m,p}</code> are restricted
to be the same for all regimes.</p>
</td></tr>
<tr><td><code id="uncond_moments_int_+3A_constraints">constraints</code></td>
<td>
<p>specifies linear constraints imposed to each regime's autoregressive parameters separately.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd><p>a list of size <code class="reqn">(pxq_{m})</code> constraint matrices <strong><code class="reqn">C_{m}</code></strong> of full column rank
satisfying <strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> for all <code class="reqn">m=1,...,M</code>, where
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p})</code> and <strong><code class="reqn">\psi_{m}</code></strong><code class="reqn">=(\psi_{m,1},...,\psi_{m,q_{m}})</code>.</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd><p>a size <code class="reqn">(pxq)</code> constraint matrix <strong><code class="reqn">C</code></strong> of full column rank satisfying
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong>, where <strong><code class="reqn">\phi</code></strong><code class="reqn">=(\phi_{1},...,\phi_{p})</code> and
<strong><code class="reqn">\psi</code></strong><code class="reqn">=\psi_{1},...,\psi_{q}</code>.</p>
</dd>
</dl>

<p>The symbol <code class="reqn">\phi</code> denotes an AR coefficient. Note that regardless of any constraints, the autoregressive order
is always <code>p</code> for all regimes.
Ignore or set to <code>NULL</code> if applying linear constraints is not desired.</p>
</td></tr>
<tr><td><code id="uncond_moments_int_+3A_parametrization">parametrization</code></td>
<td>
<p>is the model parametrized with the &quot;intercepts&quot; <code class="reqn">\phi_{m,0}</code> or
&quot;means&quot; <code class="reqn">\mu_{m} = \phi_{m,0}/(1-\sum\phi_{i,m})</code>?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Differs from the function <code>uncond_moments</code> in arguments. This function exists for technical
reasons only.
</p>


<h3>Value</h3>

<p>Returns a list containing the unconditional mean, variance, and the first p autocovariances and
autocorrelations. Note that the lag-zero autocovariance/correlation is not included in the &quot;first p&quot;
but is given in the <code>uncond_variance</code> component separately.
</p>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2015. Gaussian Mixture Autoregressive model for univariate time series.
<em>Journal of Time Series Analysis</em>, <strong>36</strong>(2), 247-266.
</p>
</li>
<li><p> Meitz M., Preve D., Saikkonen P. 2023. A mixture autoregressive model based on Student's t-distribution.
<em>Communications in Statistics - Theory and Methods</em>, <strong>52</strong>(2), 499-515.
</p>
</li>
<li><p> Virolainen S. 2022. A mixture autoregressive model based on Gaussian and Student's t-distributions.
Studies in Nonlinear Dynamics &amp; Econometrics, <strong>26</strong>(4) 559-580.
</p>
</li>
<li><p> Ltkepohl H. 2005. New Introduction to Multiple Time Series Analysis. <em>Springer</em>.
</p>
</li></ul>


<hr>
<h2 id='Wald_test'>Perform Wald test</h2><span id='topic+Wald_test'></span>

<h3>Description</h3>

<p><code>Wald_test</code> performs a Wald test for a GMAR, StMAR, or G-StMAR model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Wald_test(gsmar, A, c, h = 6e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Wald_test_+3A_gsmar">gsmar</code></td>
<td>
<p>a class 'gsmar' object, typically generated by <code>fitGSMAR</code> or <code>GSMAR</code>.</p>
</td></tr>
<tr><td><code id="Wald_test_+3A_a">A</code></td>
<td>
<p>a size <code class="reqn">(k x n_params)</code> matrix with full row rank specifying a part of the null hypothesis,
where <code class="reqn">n_params</code> is the number of parameters in the (unconstrained) model.
See details for more information.</p>
</td></tr>
<tr><td><code id="Wald_test_+3A_c">c</code></td>
<td>
<p>a length <code class="reqn">k</code> vector specifying a part of the null hypothesis. See details for more information.</p>
</td></tr>
<tr><td><code id="Wald_test_+3A_h">h</code></td>
<td>
<p>the difference used to approximate the derivatives.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Denoting the true parameter value by <code class="reqn">\theta_{0}</code>, we test the null hypothesis <code class="reqn">A\theta_{0}=c</code>.
Under the null, the test statistic is asymptotically <code class="reqn">\chi^2</code>-distributed with <code class="reqn">k</code>
(<code>=nrow(A)</code>) degrees of freedom. The parameter <code class="reqn">\theta_{0}</code> is assumed to have the same form as in
the model supplied in the argument <code>gsmar</code> and it is presented in the documentation of the argument
<code>params</code> in the function <code>GSMAR</code> (see <code>?GSMAR</code>).
</p>
<p>Note that this function does <strong>not</strong> check whether the specified constraints are feasible (e.g., whether
the implied constrained model would be stationary or have positive definite error term covariance matrices).
</p>


<h3>Value</h3>

<p>A list with class &quot;htest&quot; containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the Wald statistics.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the degrees of freedom of the Wald statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating the type of the test (Wald test).</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the names of the supplied model, constraint matrix A, and vector c.</p>
</td></tr>
<tr><td><code>gsmar</code></td>
<td>
<p>the supplied argument gsmar.</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>the supplied argument A.</p>
</td></tr>
<tr><td><code>c</code></td>
<td>
<p>the supplied argument c.</p>
</td></tr>
<tr><td><code>h</code></td>
<td>
<p>the supplied argument h.</p>
</td></tr>
</table>


<h3>References</h3>


<ul>
<li><p> Kalliovirta L., Meitz M. and Saikkonen P. 2015. Gaussian Mixture Autoregressive model for univariate time series.
<em>Journal of Time Series Analysis</em>, <strong>36</strong>(2), 247-266.
</p>
</li>
<li><p> Meitz M., Preve D., Saikkonen P. 2023. A mixture autoregressive model based on Student's t-distribution.
<em>Communications in Statistics - Theory and Methods</em>, <strong>52</strong>(2), 499-515.
</p>
</li>
<li><p> Virolainen S. 2022. A mixture autoregressive model based on Gaussian and Student's t-distributions.
Studies in Nonlinear Dynamics &amp; Econometrics, <strong>26</strong>(4) 559-580.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+LR_test">LR_test</a></code>, <code><a href="#topic+fitGSMAR">fitGSMAR</a></code>, <code><a href="#topic+GSMAR">GSMAR</a></code>, <code><a href="#topic+diagnostic_plot">diagnostic_plot</a></code>,
<code><a href="#topic+profile_logliks">profile_logliks</a></code>, <code><a href="#topic+quantile_residual_tests">quantile_residual_tests</a></code>, <code><a href="#topic+cond_moment_plot">cond_moment_plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# GMAR p=1, M=2 model:
fit12 &lt;- fitGSMAR(simudata, p=1, M=2, model="GMAR", ncalls=1, seeds=1)

# Test with Wald test whether the AR coefficients are the same in both
# regimes:
# There are 7 parameters in the model and the AR coefficient of the
# first regime is the 2nd element, whereas the AR coefficient of the second
# regime is in the 5th element.
A &lt;- matrix(c(0, 1, 0, 0, -1, 0, 0), nrow=1, ncol=7)
c &lt;- 0
Wald_test(fit12, A=A, c=c)

</code></pre>

<hr>
<h2 id='warn_ar_roots'>Warn about near-unit-roots in some regimes</h2><span id='topic+warn_ar_roots'></span>

<h3>Description</h3>

<p><code>warn_ar_roots</code> warns if the model contains near-unit-roots in some regimes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>warn_ar_roots(gsmar, tol = 0.005)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="warn_ar_roots_+3A_tol">tol</code></td>
<td>
<p>if some root is smaller that <code>1 + tol</code>, a warning is thrown</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Warns if some moduli of the autoregressive polynomial's roots are close to one.
</p>


<h3>Value</h3>

<p>Doesn't return anything.
</p>

<hr>
<h2 id='warn_dfs'>Warn about large degrees of freedom parameter values</h2><span id='topic+warn_dfs'></span>

<h3>Description</h3>

<p><code>warn_dfs</code> warns if the model contains large degrees of freedom parameter values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>warn_dfs(
  object,
  p,
  M,
  params,
  model = c("GMAR", "StMAR", "G-StMAR"),
  warn_about = c("derivs", "errors")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="warn_dfs_+3A_object">object</code></td>
<td>
<p>an object to be tested</p>
</td></tr>
<tr><td><code id="warn_dfs_+3A_p">p</code></td>
<td>
<p>a positive integer specifying the autoregressive order of the model.</p>
</td></tr>
<tr><td><code id="warn_dfs_+3A_m">M</code></td>
<td>

<dl>
<dt>For <strong>GMAR</strong> and <strong>StMAR</strong> models:</dt><dd><p>a positive integer specifying the number of mixture components.</p>
</dd>
<dt>For <strong>G-StMAR</strong> models:</dt><dd><p>a size (2x1) integer vector specifying the number of <em>GMAR type</em> components <code>M1</code> in the
first element and <em>StMAR type</em> components <code>M2</code> in the second element. The total number of mixture components is <code>M=M1+M2</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="warn_dfs_+3A_params">params</code></td>
<td>
<p>a real valued parameter vector specifying the model.
</p>

<dl>
<dt>For <strong>non-restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(M(p+3)+M-M1-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=</code>(<strong><code class="reqn">\upsilon_{1}</code></strong><code class="reqn">,...,</code><strong><code class="reqn">\upsilon_{M}</code></strong>,
<code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>) where
</p>

<ul>
<li> <p><strong><code class="reqn">\upsilon_{m}</code></strong><code class="reqn">=(\phi_{m,0},</code><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">,</code><code class="reqn">\sigma_{m}^2)</code>
</p>
</li>
<li> <p><strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=(\phi_{m,1},...,\phi_{m,p}), m=1,...,M</code>
</p>
</li>
<li> <p><strong><code class="reqn">\nu</code></strong><code class="reqn">=(\nu_{M1+1},...,\nu_{M})</code>
</p>
</li>
<li> <p><code class="reqn">M1</code> is the number of GMAR type regimes.
</p>
</li></ul>

<p>In the <strong>GMAR</strong> model, <code class="reqn">M1=M</code> and the parameter <strong><code class="reqn">\nu</code></strong> dropped. In the <strong>StMAR</strong> model, <code class="reqn">M1=0</code>.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vectors <strong><code class="reqn">\phi_{m}</code></strong> with the vectors <strong><code class="reqn">\psi_{m}</code></strong> that satisfy
<strong><code class="reqn">\phi_{m}</code></strong><code class="reqn">=</code><strong><code class="reqn">C_{m}\psi_{m}</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
<dt>For <strong>restricted</strong> models:</dt><dd>
<p>Size <code class="reqn">(3M+M-M1+p-1x1)</code> vector <strong><code class="reqn">\theta</code></strong><code class="reqn">=(\phi_{1,0},...,\phi_{M,0},</code><strong><code class="reqn">\phi</code></strong><code class="reqn">,</code>
<code class="reqn">\sigma_{1}^2,...,\sigma_{M}^2,</code><code class="reqn">\alpha_{1},...,\alpha_{M-1},</code><strong><code class="reqn">\nu</code></strong>), where <strong><code class="reqn">\phi</code></strong>=<code class="reqn">(\phi_{1},...,\phi_{p})</code>
contains the AR coefficients, which are common for all regimes.
</p>
<p>If the model imposes <strong>linear constraints</strong> on the autoregressive parameters:
Replace the vector <strong><code class="reqn">\phi</code></strong> with the vector <strong><code class="reqn">\psi</code></strong> that satisfies
<strong><code class="reqn">\phi</code></strong><code class="reqn">=</code><strong><code class="reqn">C\psi</code></strong> (see the argument <code>constraints</code>).
</p>
</dd>
</dl>

<p>Symbol <code class="reqn">\phi</code> denotes an AR coefficient, <code class="reqn">\sigma^2</code> a variance, <code class="reqn">\alpha</code> a mixing weight, and <code class="reqn">\nu</code> a degrees of
freedom parameter. If <code>parametrization=="mean"</code>, just replace each intercept term <code class="reqn">\phi_{m,0}</code> with the regimewise mean
<code class="reqn">\mu_m = \phi_{m,0}/(1-\sum\phi_{i,m})</code>. In the <strong>G-StMAR</strong> model, the first <code>M1</code> components are <em>GMAR type</em>
and the rest <code>M2</code> components are <em>StMAR type</em>.
Note that in the case <strong>M=1</strong>, the mixing weight parameters <code class="reqn">\alpha</code> are dropped, and in the case of <strong>StMAR</strong> or <strong>G-StMAR</strong> model,
the degrees of freedom parameters <code class="reqn">\nu</code> have to be larger than <code class="reqn">2</code>.</p>
</td></tr>
<tr><td><code id="warn_dfs_+3A_model">model</code></td>
<td>
<p>is &quot;GMAR&quot;, &quot;StMAR&quot;, or &quot;G-StMAR&quot; model considered? In the G-StMAR model, the first <code>M1</code> components
are <em>GMAR type</em> and the rest <code>M2</code> components are <em>StMAR type</em>.</p>
</td></tr>
<tr><td><code id="warn_dfs_+3A_warn_about">warn_about</code></td>
<td>
<p>warn about inaccurate derivatives or standard errors?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Either provide a class 'gsmar' object or specify the model by hand.
</p>


<h3>Value</h3>

<p>Doesn't return anything but throws a warning if any degrees of freedom parameters have value
larger than 100.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
