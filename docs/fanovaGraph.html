<!DOCTYPE html><html><head><title>Help for package fanovaGraph</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fanovaGraph}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#estimateGraph'><p>FANOVA graph estimation.</p></a></li>
<li><a href='#fanovaGraph-package'><p>Building Kriging models with FANOVA graphs</p></a></li>
<li><a href='#i2Index'><p>Estimation of pure second order indices</p></a></li>
<li><a href='#kmAdditive'><p>Constrained MLE Optimization</p></a></li>
<li><a href='#kmPredictWrapper'>
<p>Wrapper for the Kriging model prediction</p></a></li>
<li><a href='#L'>
<p>LHS Dataset</p></a></li>
<li><a href='#plot.graphlist'><p>Plot Graph via Package <code>igraph</code></p></a></li>
<li><a href='#plotDeltaJumps'>
<p>Delta Jump Plot</p></a></li>
<li><a href='#plotGraphChange+2C+20plotTk+2C+20plotManipulate'><p>Plot Graph as It Changes with Delta</p></a></li>
<li><a href='#predictAdditive'><p>Prediction Function with Modified Kernel</p></a></li>
<li><a href='#simAdditive'>
<p>Simulate GP values from block-addtive kernel</p></a></li>
<li><a href='#threshold'><p>Threshold indices</p></a></li>
<li><a href='#thresholdIdentification'>
<p>Function to identify a suitable threshold for an <code>estimateGraph</code> object</p></a></li>
<li><a href='#totalIndex'><p>Estimation of main index indices</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Building Kriging Models from FANOVA Graphs</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-10-01</td>
</tr>
<tr>
<td>Author:</td>
<td>Jana Fruth, Thomas Muehlenstaedt, Olivier Roustant, Malte Jastrow, Sonja Kuhnt</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sonja Kuhnt &lt;sonja.kuhnt@fh-dortmund.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimation and plotting of a function's FANOVA graph to identify the interaction structure and fitting, prediction and simulation of a Kriging model modified by the identified structure. The interactive function plotManipulate() can only be run on the 'RStudio IDE' with 'RStudio' package 'manipulate' loaded. 'RStudio' is freely available (<a href="https://rstudio.com/">https://rstudio.com/</a>), and includes package 'manipulate'. The equivalent function plotTk() bases on CRAN Repository packages only. For further information on the method see Fruth, J., Roustant, O., Kuhnt, S. (2014) &lt;<a href="https://doi.org/10.1016%2Fj.jspi.2013.11.007">doi:10.1016/j.jspi.2013.11.007</a>&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>sensitivity, igraph, DiceKriging (&ge; 1.4)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>manipulate, testthat</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-10-06 15:30:48 UTC; Sonja</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-10-07 12:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='estimateGraph'>FANOVA graph estimation.
</h2><span id='topic+estimateGraph'></span><span id='topic+print.graphlist'></span>

<h3>Description</h3>

<p>Estimates the structure of the FANOVA graph by estimating the total interaction indices for the graph edges (a particular case of superset importance introduced by Liu and Owen, 2006), the main effect indices for the graph vertices and the overall variance for normalizing the indices and finding the clique structure of the estimated graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimateGraph(f.mat, d, q = NULL, q.arg = NULL, n.tot = NULL, method = "LiuOwen", 
n.lo = NULL, n.mc = NULL, n.fast = 500, L = NULL, M = 6, n.pf = NULL, n.main = 1000, 
confint = TRUE, print.loop.index = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimateGraph_+3A_f.mat">f.mat</code></td>
<td>
<p>vectorized function for which the FANOVA graph shall be estimated
</p>
</td></tr>
<tr><td><code id="estimateGraph_+3A_d">d</code></td>
<td>
<p>integer, number of input factors (vertices)
</p>
</td></tr>
<tr><td><code id="estimateGraph_+3A_q">q</code></td>
<td>
<p>a vector of character strings of quantile functions corresponding to the factors distributions, it can be a single character string meaning same distribution for all, if not specified <code>"qunif"</code> is taken
</p>
</td></tr>
<tr><td><code id="estimateGraph_+3A_q.arg">q.arg</code></td>
<td>
<p>a list of lists of quantile functions parameters of the distributions in <code>q</code>, it can be a single list meaning same parameters for all, if not specified the default values of the respective distributions are taken
</p>
</td></tr>
<tr><td><code id="estimateGraph_+3A_n.tot">n.tot</code></td>
<td>
<p>optional integer, total number of function evaluations, instead of <code>n.tot</code> method related parameters (<code>n.lo</code>, <code>n.mc</code>, <code>L</code> or <code>n.sobol</code>) can be provided</p>
</td></tr>
<tr><td><code id="estimateGraph_+3A_method">method</code></td>
<td>
<p>character string specifying the estimation method of the total interaction indices, to be chosen between <code>"LiuOwen"</code>, <code>"FixFast"</code>, <code>"RBD"</code> and <code>"PickFreeze"</code>, defaults to <code>"LiuOwen"</code>, see references for further details</p>
</td></tr>
<tr><td><code id="estimateGraph_+3A_n.lo">n.lo</code></td>
<td>
<p>optional integer, only if <code>method="LiuOwen"</code>, number of Monte Carlo simulations in method of Liu and Owen</p>
</td></tr>
<tr><td><code id="estimateGraph_+3A_n.mc">n.mc</code></td>
<td>
<p>optional integer, only if <code>method="FixFast"</code>, number of Monte Carlo simulations for the expectation in fixing method using FAST</p>
</td></tr>
<tr><td><code id="estimateGraph_+3A_n.fast">n.fast</code></td>
<td>
<p>optional integer, only if <code>method="FixFast"</code>, number of design points for FAST algorithm, defaults to 500</p>
</td></tr>
<tr><td><code id="estimateGraph_+3A_l">L</code></td>
<td>
<p>optional integer, only if <code>method="RBD"</code>, parameter L in RBD-FAST method</p>
</td></tr>
<tr><td><code id="estimateGraph_+3A_m">M</code></td>
<td>
<p>optional integer, only if <code>method="RBD"</code>, parameter M in RBD-FAST method</p>
</td></tr>
<tr><td><code id="estimateGraph_+3A_n.pf">n.pf</code></td>
<td>
<p>optional integer, only if <code>method="PickFreeze"</code>, number of Monte Carlo simulations in pick-and-freeze method</p>
</td></tr>
<tr><td><code id="estimateGraph_+3A_n.main">n.main</code></td>
<td>
<p>integer, number of Monte Carlo Simulations for computing main effect indices </p>
</td></tr>
<tr><td><code id="estimateGraph_+3A_confint">confint</code></td>
<td>
<p>optional Boolean, if <code>TRUE</code>, standard error and 95% confidence intervals of the indices are computed additionally for <code>method="LiuOwen"</code>, defaults to TRUE</p>
</td></tr>
<tr><td><code id="estimateGraph_+3A_print.loop.index">print.loop.index</code></td>
<td>
<p>optional Boolean, if <code>TRUE</code>, loop indices are printed</p>
</td></tr>
<tr><td><code id="estimateGraph_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the function <code>f.mat</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>graphlist</code> containing the graph structure which includes
</p>
<table>
<tr><td><code>d</code></td>
<td>
<p>number of input factors</p>
</td></tr>
<tr><td><code>tii</code></td>
<td>
<p>matrix containing the unscaled total interaction indices and if <code>confint = TRUE</code> their standard error and lower and upper confidence limits</p>
</td></tr>
<tr><td><code>i1</code></td>
<td>
<p>matrix containing the unscaled main effect indices</p>
</td></tr>
<tr><td><code>V</code></td>
<td>
<p>overall variance</p>
</td></tr>
<tr><td><code>tii.scaled</code></td>
<td>
<p>matrix containing the scaled total interaction indices</p>
</td></tr>
<tr><td><code>cliques</code></td>
<td>
<p>list of cliques</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J. Fruth, T. Muehlenstaedt
</p>


<h3>References</h3>

<p>Fruth, J.; Roustant, O.; Kuhnt, S. (2013+) Total interaction index: A variance-based sensitivity index for second-order interaction screening.
</p>
<p>Janon, A.; Klein, T.; Lagnoux, A.; Nodet, M.; Prieur, C. (2013) Asymptotic normality and efficiency of two Sobol index estimators.
</p>
<p>Liu, R.; Owen, A.B. (2006) Estimating mean dimensionality of analysis of variance decompositions, <em>Journal of the American Statistical Association</em>, <b>101</b> 474, 712-721.
</p>
<p>Mara, T.A (2009) Extension of the RBD-FAST method to the computation of global sensitivity indices, <em>Reliability Engineering &amp; System Safety</em>, <b>94</b> no. 8, 1274-1281.
</p>
<p>Muehlenstaedt, T.; Roustant, O.; Carraro, L.; Kuhnt, S. (2011) Data-driven Kriging models based on FANOVA-decomposition, <em>Statistics and Computing</em>.
</p>
<p>Sobol', I. M. (1993) Sensitivity estimates for nonlinear mathematical models, <em>Mathematical Modeling and Computational Experiment</em>, <b>1</b>, 407-414.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Ishigami function, true analytical values: D12 = D23 = 0, D13 =~ 3.374
q.arg = list(list(min=-pi, max=pi), list(min=-pi, max=pi), list(min=-pi, max=pi)) 
estimateGraph(f.mat=ishigami.fun, d=3, q.arg=q.arg, n.tot=10000, method="LiuOwen")
estimateGraph(f.mat=ishigami.fun, d=3, q.arg=q.arg, n.tot=10000, method="FixFast")
estimateGraph(f.mat=ishigami.fun, d=3, q.arg=q.arg, n.tot=10000, method="RBD")
estimateGraph(f.mat=ishigami.fun, d=3, q.arg=q.arg, n.tot=10000, method="PickFreeze")
</code></pre>

<hr>
<h2 id='fanovaGraph-package'>Building Kriging models with FANOVA graphs
</h2><span id='topic+fanovaGraph'></span>

<h3>Description</h3>

<p>Estimates and plots the FANOVA graph of a function to identify its interaction structure and fits a kriging model modified by the identified structure
</p>


<h3>Details</h3>

<p>Important functions:
</p>

<table>
<tr>
 <td style="text-align: left;">
         <code><a href="#topic+estimateGraph">estimateGraph</a></code> </td><td style="text-align: left;"> Estimate indices for the graph, create graph structure</td>
</tr>
<tr>
 <td style="text-align: left;">
         <code><a href="#topic+threshold">threshold</a></code> </td><td style="text-align: left;"> Set indices below a threshold to zero </td>
</tr>
<tr>
 <td style="text-align: left;">
         <code><a href="#topic+plot.graphlist">plot.graphlist</a></code> </td><td style="text-align: left;"> Plot a given graph structure </td>
</tr>
<tr>
 <td style="text-align: left;">
         <code><a href="#topic+plotDeltaJumps">plotDeltaJumps</a></code> </td><td style="text-align: left;"> Provide plots for the choice of the threshold </td>
</tr>
<tr>
 <td style="text-align: left;">
         <code><a href="#topic+kmAdditive">kmAdditive</a></code> </td><td style="text-align: left;"> Kriging model estimation with block-additive kernel </td>
</tr>
<tr>
 <td style="text-align: left;">
         <code><a href="#topic+predictAdditive">predictAdditive</a></code> </td><td style="text-align: left;"> Prediction function from Kriging model with block-additive kernel </td>
</tr>
<tr>
 <td style="text-align: left;">
         <code><a href="#topic+simAdditive">simAdditive</a></code> </td><td style="text-align: left;"> Simulation from Kriging model with block-additive kernel
       </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>J. Fruth, T. Muehlenstaedt, O. Roustant, M. Jastrow
</p>


<h3>References</h3>

<p>Fruth, J.; Roustant, O.; Kuhnt, S. (2013+) Total interaction index: A variance-based sensitivity index for second-order interaction screening.
</p>
<p>Janon, A.; Klein, T.; Lagnoux-Renaudie, A.; Nodet, M.; Prieur, C. (2012+) Asymptotic normality and efficiency of two Sobol index estimators.
</p>
<p>Liu, R.; Owen, A.B. (2006) Estimating mean dimensionality of analysis of variance decompositions, <em>Journal of the American Statistical Association</em>, <b>101</b> 474, 712-721.
</p>
<p>Mara, T.A (2009) Extension of the RBD-FAST method to the computation of global sensitivity indices, <em>Reliability Engineering &amp; System Safety</em>, <b>94</b> no. 8, 1274-1281.
</p>
<p>Muehlenstaedt, T.; Roustant, O.; Carraro, L.; Kuhnt, S. (2011) Data-driven Kriging models based on FANOVA-decomposition, <em>Statistics and Computing</em>.
</p>
<p>Sobol', I. M. (1993) Sensitivity estimates for nonlinear mathematical models, <em>Mathematical Modeling and Computational Experiment</em>, <b>1</b>, 407-414.
</p>


<h3>See Also</h3>

<p><code><a href="DiceKriging.html#topic+DiceKriging-package">DiceKriging</a></code>, 
<code><a href="sensitivity.html#topic+sensitivity-package">sensitivity</a></code>,
<code><a href="igraph.html#topic+igraph-package">igraph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#demo(ExampleIshigami)
#demo(Example6D)
#demo(Estimation)
#demo(Threshold)
</code></pre>

<hr>
<h2 id='i2Index'>Estimation of pure second order indices
</h2><span id='topic+i2Index'></span>

<h3>Description</h3>

<p>Estimation of the unscaled pure second order Sobol indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>i2Index(f.mat, d, q = NULL, q.arg = NULL, n.i2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="i2Index_+3A_f.mat">f.mat</code></td>
<td>
<p>vectorized function of which indices shall be estimated
</p>
</td></tr>
<tr><td><code id="i2Index_+3A_d">d</code></td>
<td>
<p>integer, number of input factors (vertices)
</p>
</td></tr>
<tr><td><code id="i2Index_+3A_q">q</code></td>
<td>
<p>a vector of character strings of quantile functions corresponding to the factors distributions, it can be a single character string meaning same distribution for all, if not specified <code>"qunif"</code> is taken
</p>
</td></tr>
<tr><td><code id="i2Index_+3A_q.arg">q.arg</code></td>
<td>
<p>a list of lists of quantile functions parameters of the distributions in <code>q</code>, it can be a single list meaning same parameters for all, if not specified the default values of the respective distributions are taken
</p>
</td></tr>
<tr><td><code id="i2Index_+3A_n.i2">n.i2</code></td>
<td>
<p>number of Monte Carlo evaluations
</p>
</td></tr>
<tr><td><code id="i2Index_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the function <code>f.mat</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the unscaled pure second order indices
</p>


<h3>Author(s)</h3>

<p>J. Fruth
</p>


<h3>References</h3>

<p>Sobol', I. M. (1993) Sensitivity estimates for nonlinear mathematical models, <em>Mathematical Modeling and Computational Experiment</em>, <b>1</b>, 407-414.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimateGraph">estimateGraph</a></code>
<code><a href="#topic+totalIndex">totalIndex</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>i2Index(f.mat=ishigami.fun, d=3, q.arg=list(min=-pi,max=pi), n.i2=10000)
</code></pre>

<hr>
<h2 id='kmAdditive'>Constrained MLE Optimization
</h2><span id='topic+kmAdditive'></span>

<h3>Description</h3>

<p>Constrained MLE optimization for kernels defined by cliques using <code><a href="stats.html#topic+constrOptim">constrOptim</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kmAdditive(x, y, n.initial.tries = 50, limits = NULL, eps.R = 1e-08, cl, 
covtype = "gauss", eps.Var = 1e-06, max.it = 1000, iso = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kmAdditive_+3A_x">x</code></td>
<td>
<p>a design matrix of input variables, number of columns should be number of variables
</p>
</td></tr>
<tr><td><code id="kmAdditive_+3A_y">y</code></td>
<td>
<p>a vector of output variables of the same length as the columns of <code>x</code>
</p>
</td></tr>
<tr><td><code id="kmAdditive_+3A_n.initial.tries">n.initial.tries</code></td>
<td>
<p>number of random initial parameters for optimization, defaults to 50
</p>
</td></tr>
<tr><td><code id="kmAdditive_+3A_limits">limits</code></td>
<td>
<p>a list with items lower, upper containing boundaries for the covariance parameter vector theta, if <code>NULL</code> suitable bounds are computed from the range of <code>x</code>
</p>
</td></tr>
<tr><td><code id="kmAdditive_+3A_eps.r">eps.R</code></td>
<td>
<p>small positive number indicating the nugget effect added to the covariance matrix diagonalk, defaults to <code>eps.R = 1e-08</code>
</p>
</td></tr>
<tr><td><code id="kmAdditive_+3A_cl">cl</code></td>
<td>
<p>list of cliques, can be obtained by function <code><a href="#topic+threshold">threshold</a></code>
</p>
</td></tr>
<tr><td><code id="kmAdditive_+3A_covtype">covtype</code></td>
<td>
<p>an optional character string specifying the covariance structure to be used, 
to be chosen between &quot;gauss&quot;, &quot;matern5_2&quot;, &quot;matern3_2&quot;, &quot;exp&quot; or &quot;powexp&quot; (see <code><a href="DiceKriging.html#topic+DiceKriging-package">DiceKriging</a></code>), defaults to &quot;gauss&quot;
</p>
</td></tr>
<tr><td><code id="kmAdditive_+3A_eps.var">eps.Var</code></td>
<td>
<p>small positive number providing the limits for the alpha parameters in order to guarantee strict inequalities (0+eps.Var &lt;= alpha &lt;= 1-esp.Var), defaults to <code>eps.Var = 1e-06</code>
</p>
</td></tr>
<tr><td><code id="kmAdditive_+3A_max.it">max.it</code></td>
<td>
<p>maximum number of iterations for optimization, defaults to <code>max.it=1000</code>
</p>
</td></tr>
<tr><td><code id="kmAdditive_+3A_iso">iso</code></td>
<td>
<p>boolean vector indicating for each clique if it is isotropic (TRUE) or anisotropic (FALSE), defaults to <code>iso = FALSE</code> (all cliques anisotropic)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of estimated parameter 'alpha' and 'theta' corresponding to the clique structure in 'cl'</p>


<h3>Author(s)</h3>

<p>T. Muehlenstadt, O. Roustant, J. Fruth
</p>


<h3>References</h3>

<p>Muehlenstaedt, T.; Roustant, O.; Carraro, L.; Kuhnt, S. (2011) Data-driven Kriging models based on FANOVA-decomposition, <em>Statistics and Computing</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predictAdditive">predictAdditive</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### example for ishigami function with cliques {1,3} and {2}
d &lt;- 3
x &lt;- matrix(runif(100*d,-pi,pi),nc=d)
y &lt;- ishigami.fun(x)

cl &lt;- list(c(2), c(1,3))

# constrained ML optimation with kernel defined by the cliques
parameter &lt;- kmAdditive(x, y, cl = cl)

# prediction with the new model
xpred &lt;- matrix(runif(500 * d,-pi,pi), ncol = d)
ypred &lt;- predictAdditive(xpred, x, y, parameter, cl=cl)
yexact &lt;- ishigami.fun(xpred)

# rmse
sqrt(mean((ypred[,1]- yexact)^2))

# scatterplot
par(mfrow=c(1,1))
plot(yexact, ypred[,1], asp = 1)
abline(0, 1)

### compare to one single clique {1,2,3}
cl &lt;- list(c(1,2,3))

# constrained ML optimation with kernel defined by the cliques
parameter &lt;- kmAdditive(x, y, cl = cl)

# prediction with the new model
ypred &lt;- predictAdditive(xpred, x, y, parameter, cl=cl)

# rmse
sqrt(mean((ypred$mean- yexact)^2))

# scatterplot
par(mfrow=c(1,1))
plot(yexact, ypred$mean, asp = 1)
abline(0, 1)

### isotropic cliques

cl &lt;- list(c(2),c(1,3))
parameter &lt;- kmAdditive(x, y, cl = cl, iso=c(FALSE,TRUE))
ypred &lt;- predictAdditive(xpred, x, y, parameter, cl=cl, iso=c(FALSE,TRUE))
sqrt(mean((ypred$mean- yexact)^2))

# the same since first clique has length 1
parameter &lt;- kmAdditive(x, y, cl = cl, iso=c(TRUE,TRUE))
ypred &lt;- predictAdditive(xpred, x, y, parameter, cl=cl, iso=c(TRUE,TRUE))
sqrt(mean((ypred$mean- yexact)^2))
</code></pre>

<hr>
<h2 id='kmPredictWrapper'>
Wrapper for the Kriging model prediction
</h2><span id='topic+kmPredictWrapper'></span>

<h3>Description</h3>

<p>Wrapper for the Kriging model prediction function <code><a href="DiceKriging.html#topic+predict.km">predict.km</a></code> from package <code><a href="DiceKriging.html#topic+DiceKriging-package">DiceKriging</a></code> to simplify the use of Kriging prediction functions as arguments for functions like <code><a href="#topic+estimateGraph">estimateGraph</a></code> or <code><a href="sensitivity.html#topic+fast99">fast99</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kmPredictWrapper(newdata, km.object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kmPredictWrapper_+3A_newdata">newdata</code></td>
<td>
<p>a vector, matrix or data frame containing the points where to perform predictions
</p>
</td></tr>
<tr><td><code id="kmPredictWrapper_+3A_km.object">km.object</code></td>
<td>
<p>an object of class <code>km</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>kriging mean computed at <code>newdata</code>
</p>


<h3>Author(s)</h3>

<p>J. Fruth, O. Roustant
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimateGraph">estimateGraph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### graph estimation of a kriging prediction of the ishigami function
set.seed(1)
x &lt;- matrix(runif(150,-pi,pi),100,3)
y &lt;- ishigami.fun(x)
KM &lt;- km(~1, design = data.frame(x), response = y)

g &lt;- estimateGraph(f.mat = kmPredictWrapper, d = 3, n.tot = 10000, q.arg = 
  list(min = -pi, max = pi), method = "LiuOwen", km.object = KM) 
print(g$tii)
</code></pre>

<hr>
<h2 id='L'>
LHS Dataset
</h2><span id='topic+L'></span>

<h3>Description</h3>

<p>6-dimensional Latin Hypercube Sampling Dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(L)</code></pre>


<h3>Format</h3>

<p>The format is:
num [1:100, 1:6] -0.7105 -0.7739 -0.5017 0.6158 0.0245 ...
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(L)
## str(L) ; pairs(L) ...
</code></pre>

<hr>
<h2 id='plot.graphlist'>Plot Graph via Package <code><a href="igraph.html#topic+igraph-package">igraph</a></code>
</h2><span id='topic+plot.graphlist'></span><span id='topic+plot'></span>

<h3>Description</h3>

<p>Plot FANOVA graphs using functions from package <code><a href="igraph.html#topic+igraph-package">igraph</a></code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'graphlist'
plot(x, names = NULL, i2 = NULL, layout = NULL, plot.i1=TRUE, max.thickness=15, 
circle.diameter=40, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.graphlist_+3A_x">x</code></td>
<td>
<p>an object of class <code>graphlist</code> as obtained from <code><a href="#topic+estimateGraph">estimateGraph</a></code>
</p>
</td></tr>
<tr><td><code id="plot.graphlist_+3A_names">names</code></td>
<td>
<p>optional character string, names of vertices, defaults to <code>1:d</code>
</p>
</td></tr>
<tr><td><code id="plot.graphlist_+3A_i2">i2</code></td>
<td>
<p>optional vector of second order interaction indices (thickness of inner edges)
</p>
</td></tr>
<tr><td><code id="plot.graphlist_+3A_plot.i1">plot.i1</code></td>
<td>
<p>optional boolean, if TRUE main effects are drawn in the graph by vertices thicknesses, should be set to FALSE when only total interaction indices are of interest
</p>
</td></tr>
<tr><td><code id="plot.graphlist_+3A_layout">layout</code></td>
<td>
<p>optional layout for the graph as in <code><a href="igraph.html#topic+igraph-package">igraph</a></code>,
default is <code>layout.fruchterman.reingold</code>
</p>
</td></tr>
<tr><td><code id="plot.graphlist_+3A_max.thickness">max.thickness</code></td>
<td>
<p>optional value for the maximal line thickness, defaults to 20
</p>
</td></tr>
<tr><td><code id="plot.graphlist_+3A_circle.diameter">circle.diameter</code></td>
<td>
<p>optional value for the circle diameter, defaults to 40
</p>
</td></tr>
<tr><td><code id="plot.graphlist_+3A_...">...</code></td>
<td>
<p>additional arguments, passed to <code><a href="#topic+plot">plot</a></code>
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J. Fruth, O. Roustant, S. Hess, S. Neumaerker
</p>


<h3>References</h3>

<p>Muehlenstaedt, T.; Roustant, O.; Carraro, L.; Kuhnt, S. (2011) Data-driven Kriging models based on FANOVA-decomposition, <em>Statistics and Computing</em>.
</p>
<p>Csardi, G.; Nepusz, T. (2006) The igraph software package for complex network research, <em>InterJournal Complex Systems</em>, <b>Complex Systems</b>, 1695.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotGraphChange">plotGraphChange</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>op &lt;- par(no.readonly=TRUE)
g1 &lt;- estimateGraph(f.mat=ishigami.fun, d=3, q.arg=list(min=-pi,max=pi), n.tot=10000)
plot(g1)
plot(g1, names=c("A","B","C"))
plot(g1, names=c("A","B","C"), plot.i1 = FALSE)

# include pure second order indices
g2 &lt;- estimateGraph(f.mat=function(x) x[,1]*x[,2]*x[,3]+x[,2]*x[,3], d=3, 
  q.arg=list(min=-1,max=1), n.tot=10000)

plot(g2)
plot(g2, i2 = c(0.001, 0.001, 0.05))

# equal layouts and different edge thicknesses and circle diameters
g3 &lt;- estimateGraph(f.mat=function(x) x[,1]*x[,2]*x[,3]*x[,4]*x[,5], d=5, 
  q.arg=list(min=-1,max=1), n.tot=10000)

g4 &lt;- estimateGraph(f.mat=function(x) x[,1]*x[,2]*x[,3]+x[,4]*x[,5], d=5, 
  q.arg=list(min=-1,max=1), n.tot=10000)

graphClassIgraph &lt;- graph.full(n = 5, directed = FALSE)
layout &lt;- layout.circle(graphClassIgraph)

plot(g3, max.thickness= 10, circle.diameter= 30, layout=layout)
plot(g4, max.thickness= 30, circle.diameter= 50, layout=layout)
</code></pre>

<hr>
<h2 id='plotDeltaJumps'>
Delta Jump Plot
</h2><span id='topic+plotDeltaJumps'></span>

<h3>Description</h3>

<p>Threshold discision plot. <code>plotDeltaJumps</code> plots the threshold steps (the values of delta at which the graph changes) equidistant against the number of cliques and the values of delta on the real axis. The indices are assumed to be scaled for the threshold cuts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDeltaJumps(graphlist, interval = c(0, 1), mean.clique.size = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotDeltaJumps_+3A_graphlist">graphlist</code></td>
<td>
<p>an object of class <code>graphlist</code> as obtained from <code><a href="#topic+estimateGraph">estimateGraph</a></code>
</p>
</td></tr>
<tr><td><code id="plotDeltaJumps_+3A_interval">interval</code></td>
<td>
<p>an optional vector of size 2, range for the values of delta to be shown in the plot, defaults to c(0,1)
</p>
</td></tr>
<tr><td><code id="plotDeltaJumps_+3A_mean.clique.size">mean.clique.size</code></td>
<td>
<p>logical, if TRUE (default) an additional line is drawn representing 
the mean of the number of vertices in the cliques
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plots shall give help in the choice for the treshold. In the first plot a small number of cliques might be preferable in order to have less parameters to estimate. If several values result in the same number of cliques the ones with higher mean clique size are possibly preferable. 
</p>
<p>In the second plot a high jump indicates a point of big distance between two successive edge indices and thus a clear change in the graph structure. The intervals with notable jumps are highlighted in green, the higher the jump the darker the colour. Those highlighted intervals together with a small number of cliques are probably good choices for the threshold.
</p>
<p>Use <code><a href="#topic+plotGraphChange">plotGraphChange</a></code> to visualize the graph structure for possible threshold values.
</p>


<h3>Author(s)</h3>

<p>J. Fruth, O. Roustant
</p>


<h3>See Also</h3>

<p><code><a href="#topic+thresholdIdentification">thresholdIdentification</a></code>, <code><a href="#topic+plotGraphChange">plotGraphChange</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tii &lt;- matrix(c(0.0018, 0.0265, 0.0017, 0.0277, 0.0018, 0.001, 0.028, 0.0013, 
  0.0212, 0.002, 0.0372, 0.0024, 0.0022, 0.0157, 0.003))
g &lt;- list(d = 6, 
tii = tii,
i1 = matrix(c(0.0901, 0.1288, 0.0683, 0.0979, 0.0882, 0.1572)),
V = 0.8,
tii.scaled = tii/0.8,
cliques = list(1:6))

### Delta Jump Plot (jump between 0.0038 and 0.0196)
plotDeltaJumps(g)


</code></pre>

<hr>
<h2 id='plotGraphChange+2C+20plotTk+2C+20plotManipulate'>Plot Graph as It Changes with Delta
</h2><span id='topic+plotGraphChange'></span><span id='topic+plotTk'></span><span id='topic+plotManipulate'></span>

<h3>Description</h3>

<p>Graphs are plottet depending on a change on delta, the threshold for edges to appear in the graph, to enable a visual decision for delta by graph behavior.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotGraphChange(graphlist, fix.layout = TRUE, delta.layout = 0.01)
plotTk(graphlist, delta.layout=0.01)
plotManipulate(graphlist, delta.layout=0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotGraphChange+2B2C+2B20plotTk+2B2C+2B20plotManipulate_+3A_graphlist">graphlist</code></td>
<td>
<p>an object of class <code>graphlist</code> as obtained from <code><a href="#topic+estimateGraph">estimateGraph</a></code>
</p>
</td></tr>
<tr><td><code id="plotGraphChange+2B2C+2B20plotTk+2B2C+2B20plotManipulate_+3A_fix.layout">fix.layout</code></td>
<td>
<p>logical, if TRUE (default) the position of the vertices is fixed for all plots such that the positions are optimal for delta = delta.layout
</p>
</td></tr>
<tr><td><code id="plotGraphChange+2B2C+2B20plotTk+2B2C+2B20plotManipulate_+3A_delta.layout">delta.layout</code></td>
<td>
<p>optional value between 0 and 1, see <code>fix.layout</code>, defaults to 0.01
</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>plotGraphChange</code> shows the changing of the graph step by step by changing plots as in <code>demo</code>, <code>plotTk</code> is an interactive version using <code><a href="tcltk.html#topic+tcltk-package">tcltk</a></code>, <code>plotManipulate</code> is an interactive version using <code>manipulate</code>
</p>


<h3>Author(s)</h3>

<p>J. Fruth, O. Roustant
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotDeltaJumps">plotDeltaJumps</a></code>, <code><a href="#topic+plot.graphlist">plot.graphlist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see demo(Threshold)
</code></pre>

<hr>
<h2 id='predictAdditive'>Prediction Function with Modified Kernel
</h2><span id='topic+predictAdditive'></span>

<h3>Description</h3>

<p>Standard kriging prediction function for the modified correlation functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictAdditive(newdata, x, y, parameter, covtype = "gauss", eps.R = 1e-08, 
    cl, iso = FALSE, se.compute=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictAdditive_+3A_newdata">newdata</code></td>
<td>
<p>matrix containing the points where to perform predictions
</p>
</td></tr>
<tr><td><code id="predictAdditive_+3A_x">x</code></td>
<td>
<p>matrix of input data
</p>
</td></tr>
<tr><td><code id="predictAdditive_+3A_y">y</code></td>
<td>
<p>vector of output data
</p>
</td></tr>
<tr><td><code id="predictAdditive_+3A_parameter">parameter</code></td>
<td>
<p>(by <code><a href="#topic+kmAdditive">kmAdditive</a></code> estimated) kriging parameters,
list of size of 'cl' containing for each clique a list of parameters alpha (single value) and theta (numeric vector of values)
</p>
</td></tr>
<tr><td><code id="predictAdditive_+3A_covtype">covtype</code></td>
<td>
<p>an optional character string specifying the covariance structure to be used, 
to be chosen between &quot;gauss&quot;, &quot;matern5_2&quot;, &quot;matern3_2&quot;, &quot;exp&quot; or &quot;powexp&quot; (see DiceKriging), defaults to &quot;gauss&quot;
</p>
</td></tr>
<tr><td><code id="predictAdditive_+3A_eps.r">eps.R</code></td>
<td>
<p>small positive number indicating the nugget effect added to the covariance matrix diagonalk, defaults to <code>eps.R = 1e-08</code>
</p>
</td></tr>
<tr><td><code id="predictAdditive_+3A_cl">cl</code></td>
<td>
<p>list of cliques
</p>
</td></tr>
<tr><td><code id="predictAdditive_+3A_iso">iso</code></td>
<td>
<p>boolean vector indicating for each clique if it is isotropic (TRUE) or anisotropic (FALSE), defaults to <code>iso = FALSE</code> (all cliques anisotropic)
</p>
</td></tr>
<tr><td><code id="predictAdditive_+3A_se.compute">se.compute</code></td>
<td>
<p>optional boolean. If FALSE, only the kriging mean is computed. If TRUE, the kriging variance (actually, the corresponding standard deviation) is computed, too</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>mean</code></td>
<td>
<p> kriging mean computed at <code>newdata</code>. </p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p> kriging standard deviation computed at <code>newdata</code>. Only computed if 
<code>se.compute=TRUE</code>. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>T. Muehlenstaedt, O. Roustant, J. Fruth
</p>


<h3>References</h3>

<p>Muehlenstaedt, T.; Roustant, O.; Carraro, L.; Kuhnt, S. (2011) Data-driven Kriging models based on FANOVA-decomposition, <em>Statistics and Computing</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kmAdditive">kmAdditive</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### example for ishigami function with cliques {1,3} and {2}
d &lt;- 3
x &lt;- matrix(runif(100*d,-pi,pi),nc=d)
y &lt;- ishigami.fun(x)

cl &lt;- list(c(2), c(1,3))

# constrained ML optimation with kernel defined by the cliques
parameter &lt;- kmAdditive(x, y, cl = cl)

# prediction with the new model
xpred &lt;- matrix(runif(500 * d,-pi,pi), ncol = d)
ypred &lt;- predictAdditive(xpred, x, y, parameter, cl=cl)
yexact &lt;- ishigami.fun(xpred)

# rmse
sqrt(mean((ypred[,1]- yexact)^2))

# scatterplot
par(mfrow=c(1,1))
plot(yexact, ypred[,1], asp = 1)
abline(0, 1)

### compare to one single clique {1,2,3}
cl &lt;- list(c(1,2,3))

# constrained ML optimation with kernel defined by the cliques
parameter &lt;- kmAdditive(x, y, cl = cl)

# prediction with the new model
ypred &lt;- predictAdditive(xpred, x, y, parameter, cl=cl)

# rmse
sqrt(mean((ypred$mean- yexact)^2))

# scatterplot
par(mfrow=c(1,1))
plot(yexact, ypred$mean, asp = 1)
abline(0, 1)

### isotropic cliques

cl &lt;- list(c(2),c(1,3))
parameter &lt;- kmAdditive(x, y, cl = cl, iso=c(FALSE,TRUE))
ypred &lt;- predictAdditive(xpred, x, y, parameter, cl=cl, iso=c(FALSE,TRUE))
sqrt(mean((ypred$mean- yexact)^2))

# the same since first clique has length 1
parameter &lt;- kmAdditive(x, y, cl = cl, iso=c(TRUE,TRUE))
ypred &lt;- predictAdditive(xpred, x, y, parameter, cl=cl, iso=c(TRUE,TRUE))
sqrt(mean((ypred$mean- yexact)^2))
</code></pre>

<hr>
<h2 id='simAdditive'>
Simulate GP values from block-addtive kernel
</h2><span id='topic+simAdditive'></span>

<h3>Description</h3>

<p>Simulate Gaussian process values from a given block-additive kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simAdditive(newdata, mu, parameter, covtype, cl, iso = FALSE, eps.R = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simAdditive_+3A_newdata">newdata</code></td>
<td>

<p>matrix containing the points where to perform simulations
</p>
</td></tr>
<tr><td><code id="simAdditive_+3A_mu">mu</code></td>
<td>

<p>trend parameter
</p>
</td></tr>
<tr><td><code id="simAdditive_+3A_parameter">parameter</code></td>
<td>

<p>list of size of 'cl' containing for each clique a list of parameters alpha (single value) and theta (numeric vector of values)
</p>
</td></tr>
<tr><td><code id="simAdditive_+3A_covtype">covtype</code></td>
<td>

<p>character string specifying the covariance structure to be used, to be chosen between &quot;gauss&quot;, &quot;matern5_2&quot;, &quot;matern3_2&quot;, &quot;exp&quot; or &quot;powexp&quot; (see DiceKriging)
</p>
</td></tr>
<tr><td><code id="simAdditive_+3A_cl">cl</code></td>
<td>

<p>list of cliques
</p>
</td></tr>
<tr><td><code id="simAdditive_+3A_iso">iso</code></td>
<td>

<p>boolean vector indicating for each clique if it is isotropic (TRUE) or anisotropic (FALSE), defaults to iso = FALSE (all cliques anisotropic)
</p>
</td></tr>
<tr><td><code id="simAdditive_+3A_eps.r">eps.R</code></td>
<td>

<p>small positive number indicating the nugget effect added to the covariance matrix diagonalk, defaults to eps.R = 1e-08
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector containing the simulated values
</p>


<h3>Author(s)</h3>

<p>J. Fruth
</p>


<h3>References</h3>

<p>Muehlenstaedt, T.; Roustant, O.; Carraro, L.; Kuhnt, S. (2011) Data-driven Kriging models based on FANOVA-decomposition, <em>Statistics and Computing</em>.
</p>
<p>Rasmussen, C. E.; Williams, C. K. I. (2006), <em>Gaussian processes for machine learning</em>, MIT Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kmAdditive">kmAdditive</a></code>, <code><a href="DiceKriging.html#topic+simulate">simulate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### 2 dimensional simulation
x1 &lt;- x2 &lt;- seq(-1,1,,20)
x &lt;- expand.grid(x1,x2)
covtype &lt;- "matern3_2"
mu &lt;- 0

op &lt;- par(no.readonly=TRUE); par(mfrow=c(1,2), mar=c(1,1,1,1))
# non-additive simulation
parameter &lt;- list(list(alpha=1, theta=c(0.8,0.8)))
cl &lt;- list(1:2)
set.seed(1)
y &lt;- simAdditive(x, mu, parameter, covtype, cl)
persp(x1,x2, matrix(y,20), theta=-40, col="lightblue", zlab="y")

# additive simulation
parameter &lt;- list(list(alpha=0.5, theta=0.8),
                  list(alpha=0.5, theta=0.8))
cl &lt;- list(1,2)
set.seed(1)
y &lt;- simAdditive(x, mu, parameter, covtype, cl)
persp(x1,x2, matrix(y,20), theta=-40, col="lightblue", zlab="y")

par(op)
</code></pre>

<hr>
<h2 id='threshold'>Threshold indices
</h2><span id='topic+threshold'></span>

<h3>Description</h3>

<p>All indices below a treshold are set to be zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>threshold(graphlist, delta, scaled = TRUE, robust = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="threshold_+3A_graphlist">graphlist</code></td>
<td>
<p>an object of class <code>graphlist</code> as obtained from <code><a href="#topic+estimateGraph">estimateGraph</a></code>
</p>
</td></tr>
<tr><td><code id="threshold_+3A_delta">delta</code></td>
<td>
<p>numeric threshold, between 0 and 1 if <code>scaled = TRUE</code>
</p>
</td></tr>
<tr><td><code id="threshold_+3A_scaled">scaled</code></td>
<td>
<p>optional boolean, if TRUE, indices are normalized by the overall variance before for threshold cut, defaults to TRUE
</p>
</td></tr>
<tr><td><code id="threshold_+3A_robust">robust</code></td>
<td>
<p>optional boolean, if TRUE, upper confidence intervals limits are used for the threshold cut instead of indices themselves, confidence intervals must be provided in <code>graphlist</code>, defaults to FALSE
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>graphlist</code> where the indices are thresholded the clique structure is updated respectively, see <code><a href="#topic+estimateGraph">estimateGraph</a></code> for a detailed description
</p>


<h3>Warning</h3>

<p>The threshold cut is by default performed on scaled indices. For a cut on the original unscaled indices set <code>scaled = FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>J. Fruth, T. Muehlenstaedt, O. Roustant
</p>


<h3>References</h3>

<p>Muehlenstaedt, T.; Roustant, O.; Carraro, L.; Kuhnt, S. (2011) Data-driven Kriging models based on FANOVA-decomposition, <em>Statistics and Computing</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Kriging model prediction
x &lt;- matrix(runif(100*3,-pi,pi),100,3)
KM &lt;- km(~1, design = data.frame(x), response = ishigami.fun(x))
krigingMean &lt;- function(Xnew) predict(object = KM, newdata = Xnew, 
    type = "UK", se.compute = FALSE, checkNames = FALSE)$mean
    
# full graph estimation
g &lt;- estimateGraph(krigingMean, d=3, n.tot=10000, q.arg=list(min=-pi, max=pi))
print(g[c(2,6)])
# threshold graph
g.cut &lt;- threshold(g, delta = 0.1)
print(g.cut[c(2,6)])
</code></pre>

<hr>
<h2 id='thresholdIdentification'>
Function to identify a suitable threshold for an <code>estimateGraph</code> object
</h2><span id='topic+thresholdIdentification'></span>

<h3>Description</h3>

<p>From an <code>estimateGraph</code> object and a corresponding data set, candidate treshold values are compared on the prediction performance of the corresponding additive Kriging model. The candidate thresholds are chosen by the biggest jumps in <code>plotDeltaJumps</code> together with 0 (the full model) and 1 (the complete additive model). For each of them the Kriging model with corresponding kernel is estimated and the leave-one-out
crossvalidiations on the original data sets are compared on scatterplots and RMSE-values. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thresholdIdentification(g, x, y, n.cand = 3, covtype = "matern5_2", KM = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thresholdIdentification_+3A_g">g</code></td>
<td>
<p>object of class <code>graphlist</code> as obtained from <code>estimateGraph</code></p>
</td></tr>
<tr><td><code id="thresholdIdentification_+3A_x">x</code></td>
<td>
<p>design matrix of input variables corresponding to <code>g</code>, number of columns should be number of variables</p>
</td></tr>
<tr><td><code id="thresholdIdentification_+3A_y">y</code></td>
<td>
<p>vector of output variables of the same length as the columns of <code>x</code></p>
</td></tr>
<tr><td><code id="thresholdIdentification_+3A_n.cand">n.cand</code></td>
<td>
<p>integer, the <code>n.cand</code> biggest jumps are chosen as candidate threshold values. The default value is <code>3</code></p>
</td></tr>
<tr><td><code id="thresholdIdentification_+3A_covtype">covtype</code></td>
<td>
<p>optional character string specifying the covariance structure to be used. The default is <code>"matern5_2"</code></p>
</td></tr>
<tr><td><code id="thresholdIdentification_+3A_km">KM</code></td>
<td>
<p>optional object of class <code>km</code>, the full kriging model corresponding to <code>g</code>. With default value <code>NULL</code>, this kriging model is computed by the function itself</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list including
</p>
<table>
<tr><td><code>delta</code></td>
<td>
<p>vector of threshold candidates</p>
</td></tr>
<tr><td><code>models</code></td>
<td>
<p>list of full model and models with applied thresholds</p>
</td></tr>
<tr><td><code>y.cv</code></td>
<td>
<p>list of vectors containing crossvalidation predictions for each model</p>
</td></tr>
<tr><td><code>RMSE</code></td>
<td>
<p>vector of residual mean squared errors for each model</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>J. Fruth, M. Jastrow
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotDeltaJumps">plotDeltaJumps</a></code>, <code><a href="#topic+plotGraphChange">plotGraphChange</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>############ simple 3-dimensional example with one interaction

### data (usually existing)
x &lt;- matrix(seq(0,1,,20), 20, 3)
x &lt;- apply(x,2,sample)
y &lt;- 2*(x[,1]-0.5) * (x[,2]-0.5) + 0.1*sin(10*x[,3])

### FANVOA graph (usually estimated from a meta model over the data)
g &lt;- list(d=3, 
  tii = matrix(c(0.0140, 0.0008, 0.0002)),
  V = 0.0222, 
  tii.scaled = matrix(c(0.6976, 0.0432, 0.0113))
)
class(g) &lt;- "graphlist"

### plot complete graph
plot(g, plot.i1=FALSE)

### Compare candidate thresholds on prediction performance
set.seed(1)
comparison &lt;- thresholdIdentification(g, x, y, n.cand = 1)</code></pre>

<hr>
<h2 id='totalIndex'>Estimation of main index indices
</h2><span id='topic+totalIndex'></span>

<h3>Description</h3>

<p>Estimation of the unscaled total Sobol index of all main indices by method Liu &amp; Owen (superset importance of main indices).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>totalIndex(f.mat, d, q = NULL, q.arg = NULL, n.mc, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="totalIndex_+3A_f.mat">f.mat</code></td>
<td>
<p>vectorized function of which indices shall be estimated
</p>
</td></tr>
<tr><td><code id="totalIndex_+3A_d">d</code></td>
<td>
<p>integer, number of input factors (vertices)
</p>
</td></tr>
<tr><td><code id="totalIndex_+3A_q">q</code></td>
<td>
<p>a vector of character strings of quantile functions corresponding to the factors distributions, it can be a single character string meaning same distribution for all, if not specified <code>"qunif"</code> is taken
</p>
</td></tr>
<tr><td><code id="totalIndex_+3A_q.arg">q.arg</code></td>
<td>
<p>a list of lists of quantile functions parameters of the distributions in <code>q</code>, it can be a single list meaning same parameters for all, if not specified the default values of the respective distributions are taken
</p>
</td></tr>
<tr><td><code id="totalIndex_+3A_n.mc">n.mc</code></td>
<td>
<p>number of Monte Carlo evaluations
</p>
</td></tr>
<tr><td><code id="totalIndex_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the function <code>f.mat</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the unscaled total Sobol indices</p>


<h3>Author(s)</h3>

<p>J. Fruth
</p>


<h3>References</h3>

<p>Liu, R.; Owen, A.B. (2006) Estimating mean dimensionality of analysis of variance decompositions, <em>Journal of the American Statistical Association</em>, <b>101</b> 474, 712-721.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimateGraph">estimateGraph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>totalIndex(f.mat=ishigami.fun, d=3, q.arg=list(min=-pi,max=pi), n.mc=10000)
totalIndex(f.mat=sobol.fun, d=8, q.arg=list(min=0,max=1), n.mc=10000)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
