<!DOCTYPE html><html lang="en"><head><title>Help for package CDM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CDM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CDM-package'>
<p>Cognitive Diagnosis Modeling</p></a></li>
<li><a href='#anova'>
<p>Likelihood Ratio Test for Model Comparisons</p></a></li>
<li><a href='#cdi.kli'>
<p>Cognitive Diagnostic Indices based on Kullback-Leibler Information</p></a></li>
<li><a href='#CDM-utilities'><p>Utility Functions in <span class="pkg">CDM</span></p></a></li>
<li><a href='#cdm.est.class.accuracy'>
<p>Classification Reliability in a CDM</p></a></li>
<li><a href='#coef'><p>Extract Estimated Item Parameters and Skill Class Distribution</p>
Parameters</a></li>
<li><a href='#Data-sim'>
<p>Artificial Data: DINA and DINO</p></a></li>
<li><a href='#data.cdm'>
<p>Several Datasets for the <span class="pkg">CDM</span> Package</p></a></li>
<li><a href='#data.dcm'>
<p>Dataset from Book 'Diagnostic Measurement' of Rupp, Templin and</p>
Henson (2010)</a></li>
<li><a href='#data.dtmr'>
<p>DTMR Fraction Data (Bradshaw et al., 2014)</p></a></li>
<li><a href='#data.ecpe'>
<p>Dataset ECPE</p></a></li>
<li><a href='#data.fraction'>
<p>Fraction Subtraction Dataset with Different Subsets of Data and Different</p>
Q-Matrices</a></li>
<li><a href='#data.hr'>
<p>Dataset <code>data.hr</code> (Ravand et al., 2013)</p></a></li>
<li><a href='#data.jang'>
<p>Dataset Jang (2009)</p></a></li>
<li><a href='#data.melab'>
<p>MELAB Data (Li, 2011)</p></a></li>
<li><a href='#data.mg'>
<p>Large-Scale Dataset with Multiple Groups</p></a></li>
<li><a href='#data.pgdina'>
<p>Dataset for Polytomous GDINA Model</p></a></li>
<li><a href='#data.pisa00R'>
<p>PISA 2000 Reading Study (Chen &amp; de la Torre, 2014)</p></a></li>
<li><a href='#data.sda6'>
<p>Dataset SDA6 (Jurich &amp; Bradshaw, 2014)</p></a></li>
<li><a href='#data.Students'>
<p>Dataset Student Questionnaire</p></a></li>
<li><a href='#data.timss03.G8.su'>
<p>TIMSS 2003 Mathematics 8th Grade (Su et al., 2013)</p></a></li>
<li><a href='#data.timss07.G4.lee'>
<p>TIMSS 2007 Mathematics 4th Grade (Lee et al., 2011)</p></a></li>
<li><a href='#data.timss11.G4.AUT'>
<p>TIMSS 2011 Mathematics 4th Grade Austrian Students</p></a></li>
<li><a href='#deltaMethod'>
<p>Variance Matrix of a Nonlinear Estimator Using the Delta Method</p></a></li>
<li><a href='#din'>
<p>Parameter Estimation for Mixed DINA/DINO Model</p></a></li>
<li><a href='#din_identifiability'>
<p>Identifiability Conditions of the DINA Model</p></a></li>
<li><a href='#din.deterministic'>
<p>Deterministic Classification and Joint Maximum Likelihood Estimation</p>
of the Mixed DINA/DINO Model</a></li>
<li><a href='#din.equivalent.class'>
<p>Calculation of Equivalent Skill Classes in the DINA/DINO Model</p></a></li>
<li><a href='#din.validate.qmatrix'>
<p>Q-Matrix Validation (Q-Matrix Modification) for Mixed DINA/DINO Model</p></a></li>
<li><a href='#discrim.index'>
<p>Discrimination Indices at Item-Attribute, Item and Test Level</p></a></li>
<li><a href='#entropy.lca'>
<p>Test-specific and Item-specific Entropy for Latent Class Models</p></a></li>
<li><a href='#equivalent.dina'>
<p>Determination of a Statistically Equivalent DINA Model</p></a></li>
<li><a href='#eval_likelihood'>
<p>Evaluation of Likelihood</p></a></li>
<li><a href='#fraction.subtraction.data'>
<p>Fraction Subtraction Data</p></a></li>
<li><a href='#fraction.subtraction.qmatrix'>
<p>Fraction Subtraction Q-Matrix</p></a></li>
<li><a href='#gdd'>
<p>Generalized Distance Discriminating Method</p></a></li>
<li><a href='#gdina'>
<p>Estimating the Generalized DINA (GDINA) Model</p></a></li>
<li><a href='#gdina.dif'>
<p>Differential Item Functioning in the GDINA Model</p></a></li>
<li><a href='#gdina.wald'>
<p>Wald Statistic for Item Fit of the DINA and ACDM Rule for GDINA Model</p></a></li>
<li><a href='#gdm'>
<p>General Diagnostic Model</p></a></li>
<li><a href='#ideal.response.pattern'>
<p>Ideal Response Pattern</p></a></li>
<li><a href='#IRT.anova'>
<p>Helper Function for Conducting Likelihood Ratio Tests</p></a></li>
<li><a href='#IRT.classify'>
<p>Individual Classification for Fitted Models</p></a></li>
<li><a href='#IRT.compareModels'>
<p>Comparisons of Several Models</p></a></li>
<li><a href='#IRT.data'>
<p>S3 Method for Extracting Used Item Response Dataset</p></a></li>
<li><a href='#IRT.expectedCounts'>
<p>S3 Method for Extracting Expected Counts</p></a></li>
<li><a href='#IRT.factor.scores'>
<p>S3 Methods for Extracting Factor Scores (Person Classifications)</p></a></li>
<li><a href='#IRT.frequencies'>
<p>S3 Method for Computing Observed and Expected Frequencies of Univariate and</p>
Bivariate Marginals</a></li>
<li><a href='#IRT.IC'>
<p>Information Criteria</p></a></li>
<li><a href='#IRT.irfprob'>
<p>S3 Methods for Extracting Item Response Functions</p></a></li>
<li><a href='#IRT.irfprobPlot'>
<p>Plot Item Response Functions</p></a></li>
<li><a href='#IRT.itemfit'>
<p>S3 Methods for Computing Item Fit</p></a></li>
<li><a href='#IRT.jackknife'>
<p>Jackknifing an Item Response Model</p></a></li>
<li><a href='#IRT.likelihood'>
<p>S3 Methods for Extracting of the Individual Likelihood and the Individual Posterior</p></a></li>
<li><a href='#IRT.marginal_posterior'>
<p>S3 Method for Computation of Marginal Posterior Distribution</p></a></li>
<li><a href='#IRT.modelfit'>
<p>S3 Methods for Assessing Model Fit</p></a></li>
<li><a href='#IRT.parameterTable'>
<p>S3 Method for Extracting a Parameter Table</p></a></li>
<li><a href='#IRT.repDesign'>
<p>Generation of a Replicate Design for <code>IRT.jackknife</code></p></a></li>
<li><a href='#IRT.RMSD'>
<p>Root Mean Square Deviation (RMSD) Item Fit Statistic</p></a></li>
<li><a href='#item_by_group'>
<p>Create Dataset with Group-Specific Items</p></a></li>
<li><a href='#itemfit.rmsea'>
<p>RMSEA Item Fit</p></a></li>
<li><a href='#itemfit.sx2'>
<p>S-X2 Item Fit Statistic for Dichotomous Data</p></a></li>
<li><a href='#logLik'><p>Extract Log-Likelihood</p></a></li>
<li><a href='#mcdina'>
<p>Multiple Choice DINA Model</p></a></li>
<li><a href='#modelfit.cor'>
<p>Assessing Model Fit and Local Dependence by Comparing Observed and Expected</p>
Item Pair Correlations</a></li>
<li><a href='#numerical_Hessian'>
<p>Numerical Computation of the Hessian Matrix</p></a></li>
<li><a href='#osink'>
<p>Opens and Closes a <code>sink</code> Connection</p></a></li>
<li><a href='#personfit.appropriateness'>
<p>Appropriateness Statistic for Person Fit Assessment</p></a></li>
<li><a href='#plot_item_mastery'>
<p>S3 Methods for Plotting Item Probabilities</p></a></li>
<li><a href='#plot.din'>
<p>Plot Method for Objects of Class din</p></a></li>
<li><a href='#predict'>
<p>Expected Values and Predicted Probabilities from Item Response Response Models</p></a></li>
<li><a href='#print.summary.din'>
<p>Print Method for Objects of Class summary.din</p></a></li>
<li><a href='#reglca'>
<p>Regularized Latent Class Analysis</p></a></li>
<li><a href='#sequential.items'>
<p>Constructing a Dataset with Sequential Pseudo Items for Ordered</p>
Item Responses</a></li>
<li><a href='#sim_model'>
<p>Simulate an Item Response Model</p></a></li>
<li><a href='#sim.din'>
<p>Data Simulation Tool for DINA, DINO and mixed DINA and DINO Data</p></a></li>
<li><a href='#sim.gdina'>
<p>Simulation of the GDINA model</p></a></li>
<li><a href='#skill.cor'>
<p>Tetrachoric or Polychoric Correlations between Attributes</p></a></li>
<li><a href='#skillspace.approximation'>
<p>Skill Space Approximation</p></a></li>
<li><a href='#skillspace.hierarchy'>
<p>Creation of a Hierarchical Skill Space</p></a></li>
<li><a href='#slca'>
<p>Structured Latent Class Analysis (SLCA)</p></a></li>
<li><a href='#summary_sink'>
<p>Prints <code>summary</code> and <code>sink</code> Output in a File</p></a></li>
<li><a href='#summary.din'>
<p>Summary Method for Objects of Class din</p></a></li>
<li><a href='#vcov'><p>Asymptotic Covariance Matrix, Standard Errors and Confidence Intervals</p></a></li>
<li><a href='#WaldTest'>
<p>Wald Test for a Linear Hypothesis</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Cognitive Diagnosis Modeling</td>
</tr>
<tr>
<td>Version:</td>
<td>8.2-6</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-08-25 15:43:23</td>
</tr>
<tr>
<td>Author:</td>
<td>
    Alexander Robitzsch [aut, cre], Thomas Kiefer [aut],
    Ann Cathrice George [aut], Ali Uenlue [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexander Robitzsch &lt;robitzsch@ipn.uni-kiel.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>
    Functions for cognitive diagnosis modeling and multidimensional item response modeling 
    for dichotomous and polytomous item responses. This package enables the estimation of 
    the DINA and DINO model (Junker &amp; Sijtsma, 2001, &lt;<a href="https://doi.org/10.1177%2F01466210122032064">doi:10.1177/01466210122032064</a>&gt;),
    the multiple group (polytomous) GDINA model (de la Torre, 2011, 
    &lt;<a href="https://doi.org/10.1007%2Fs11336-011-9207-7">doi:10.1007/s11336-011-9207-7</a>&gt;), the multiple choice DINA model (de la Torre, 2009, 
    &lt;<a href="https://doi.org/10.1177%2F0146621608320523">doi:10.1177/0146621608320523</a>&gt;), the general diagnostic model (GDM; von Davier, 2008, 
    &lt;<a href="https://doi.org/10.1348%2F000711007X193957">doi:10.1348/000711007X193957</a>&gt;), the structured latent class model (SLCA; Formann, 1992, 
    &lt;<a href="https://doi.org/10.1080%2F01621459.1992.10475229">doi:10.1080/01621459.1992.10475229</a>&gt;) and regularized latent class analysis 
    (Chen, Li, Liu, &amp; Ying, 2017, &lt;<a href="https://doi.org/10.1007%2Fs11336-016-9545-6">doi:10.1007/s11336-016-9545-6</a>&gt;). 
    See George, Robitzsch, Kiefer, Gross, and Uenlue (2017) &lt;<a href="https://doi.org/10.18637%2Fjss.v074.i02">doi:10.18637/jss.v074.i02</a>&gt; 
    or Robitzsch and George (2019, &lt;<a href="https://doi.org/10.1007%2F978-3-030-05584-4_26">doi:10.1007/978-3-030-05584-4_26</a>&gt;)     
    for further details on estimation and the package structure.
    For tutorials on how to use the CDM package see 
    George and Robitzsch (2015, &lt;<a href="https://doi.org/10.20982%2Ftqmp.11.3.p189">doi:10.20982/tqmp.11.3.p189</a>&gt;) as well as
    Ravand and Robitzsch (2015).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1), mvtnorm</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, methods, polycor, Rcpp, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>BIFIEsurvey, lattice, MASS, miceadds, ROI, sfsmisc</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Enhances:</td>
<td>dina, GDINA, mirt, rrum</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/alexanderrobitzsch/CDM">https://github.com/alexanderrobitzsch/CDM</a>,
<a href="https://sites.google.com/site/alexanderrobitzsch2/software">https://sites.google.com/site/alexanderrobitzsch2/software</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/alexanderrobitzsch/CDM/issues?state=open">https://github.com/alexanderrobitzsch/CDM/issues?state=open</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-25 13:46:46 UTC; sunpn563</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-25 15:12:43 UTC</td>
</tr>
</table>
<hr>
<h2 id='CDM-package'>
Cognitive Diagnosis Modeling
</h2><span id='topic+CDM-package'></span><span id='topic+CDM'></span>

<h3>Description</h3>


<p>    Functions for cognitive diagnosis modeling and multidimensional item response modeling 
    for dichotomous and polytomous item responses. This package enables the estimation of 
    the DINA and DINO model (Junker &amp; Sijtsma, 2001, &lt;doi:10.1177/01466210122032064&gt;),
    the multiple group (polytomous) GDINA model (de la Torre, 2011, 
    &lt;doi:10.1007/s11336-011-9207-7&gt;), the multiple choice DINA model (de la Torre, 2009, 
    &lt;doi:10.1177/0146621608320523&gt;), the general diagnostic model (GDM; von Davier, 2008, 
    &lt;doi:10.1348/000711007X193957&gt;), the structured latent class model (SLCA; Formann, 1992, 
    &lt;doi:10.1080/01621459.1992.10475229&gt;) and regularized latent class analysis 
    (Chen, Li, Liu, &amp; Ying, 2017, &lt;doi:10.1007/s11336-016-9545-6&gt;). 
    See George, Robitzsch, Kiefer, Gross, and Uenlue (2017) &lt;doi:10.18637/jss.v074.i02&gt; 
    or Robitzsch and George (2019, &lt;doi:10.1007/978-3-030-05584-4_26&gt;)     
    for further details on estimation and the package structure.
    For tutorials on how to use the CDM package see 
    George and Robitzsch (2015, &lt;doi:10.20982/tqmp.11.3.p189&gt;) as well as
    Ravand and Robitzsch (2015).
</p>


<h3>Details</h3>

<p>Cognitive diagnosis models (CDMs) are restricted latent class models.
They represent model-based classification approaches, which aim at
assigning respondents to different attribute profile groups.  The latent
classes correspond to the possible attribute profiles, and the
conditional item parameters model atypical response behavior in the sense
of slipping and guessing errors.  The core CDMs in particular differ in
the utilized condensation rule, conjunctive / non-compensatory versus
disjunctive / compensatory, where in the model structure these two
types of response error parameters enter and what restrictions are
imposed on them.  The confirmatory character of CDMs is apparent in the
Q-matrix, which can be seen as an operationalization of the latent
concepts of an underlying theory.  The Q-matrix allows incorporating
qualitative prior knowledge and typically has as its rows the items and
as the columns the attributes, with entries 1 or 0, depending on whether
an attribute is measured by an item or not, respectively.
</p>
<p>CDMs as compared to common psychometric models (e.g., IRT) contain
categorical instead of continuous latent variables.  The results of
analyses using CDMs differ from the results obtained under continuous
latent variable models.  CDMs estimate in a direct manner the
probabilistic attribute profile of a respondent, that is, the
multivariate vector of the conditional probabilities for possessing the
individual attributes, given her / his response pattern.  Based on these
probabilities, simplified deterministic attribute profiles can be
derived, showing whether an individual attribute is essentially possessed
or not by a respondent.  As compared to alternative two-step
discretization approaches, which estimate continuous scores and discretize
the continua based on cut scores, with CDMs the classification error can
generally be reduced.
</p>
<p>The package <code>CDM</code> implements parameter estimation procedures for the
DINA and DINO model (e.g.,de la Torre &amp;
Douglas, 2004; Junker &amp; Sijtsma, 2001; Templin &amp;
Henson, 2006; the generalized DINA model for dichotomous attributes
(GDINA, de la Torre, 2011) and for polytomous attributes
(pGDINA, Chen &amp; de la Torre, 2013);
the general diagnostic model (GDM, von Davier, 2008) and its extension
to the multidimensional latent class IRT model (Bartolucci, 2007),
the structure latent class model (Formann, 1992),
and tools for analyzing data under the models.
These and related concepts are explained in detail in the
book about diagnostic measurement and CDMs by
Rupp, Templin and Henson (2010), and in such survey articles as
DiBello, Roussos and Stout (2007) and
Rupp and Templin (2008).
</p>
<p>The package <code>CDM</code> is implemented based on the S3 system.  It comes
with a namespace and consists of several external functions (functions the
package exports).
The package contains a utility method for the simulation of artificial data based
on a CDM model (<code><a href="#topic+sim.din">sim.din</a></code>).  It also contains seven internal functions
(functions not exported by the package): this are <code>plot</code>, <code>print</code>, and
<code>summary</code> methods for objects of the class <code>din</code> (<code><a href="#topic+plot.din">plot.din</a></code>,
<code><a href="#topic+print.din">print.din</a></code>, <code><a href="#topic+summary.din">summary.din</a></code>), a <code>print</code> method for
objects of the class <code>summary.din</code> (<code><a href="#topic+print.summary.din">print.summary.din</a></code>),
and three functions for checking the input format and computing intermediate
information.  The features of the package <code>CDM</code> are
illustrated with an accompanying real dataset and Q-matrix
(<code><a href="#topic+fraction.subtraction.data">fraction.subtraction.data</a></code> and <code><a href="#topic+fraction.subtraction.qmatrix">fraction.subtraction.qmatrix</a></code>)
and artificial examples (<code><a href="#topic+Data-sim">Data-sim</a></code>).
</p>
<p>See George et al. (2016) and Robitzsch and George (2019) 
for an overview and some computational details
of the <span class="pkg">CDM</span> package.
</p>


<h3>Author(s)</h3>


<p>    Alexander Robitzsch [aut, cre], Thomas Kiefer [aut],
    Ann Cathrice George [aut], Ali Uenlue [aut]
</p>
<p>Maintainer: Alexander Robitzsch &lt;robitzsch@ipn.uni-kiel.de&gt;
</p>


<h3>References</h3>

<p>Bartolucci, F. (2007). A class of multidimensional IRT models for testing
unidimensionality and clustering items. <em>Psychometrika, 72</em>, 141-157.
</p>
<p>Chen, J., &amp; de la Torre, J. (2013).
A general cognitive diagnosis model for expert-defined polytomous attributes.
<em>Applied Psychological Measurement, 37</em>, 419-437.
</p>
<p>Chen, Y., Li, X., Liu, J., &amp; Ying, Z. (2017).
Regularized latent class analysis with application in cognitive diagnosis.
<em>Psychometrika, 82</em>, 660-692.
</p>
<p>de la Torre, J., &amp; Douglas, J. (2004). Higher-order latent trait models
for cognitive diagnosis. <em>Psychometrika, 69</em>, 333&ndash;353.
</p>
<p>de la Torre, J. (2009). A cognitive diagnosis model for cognitively based
multiple-choice options. <em>Applied Psychological Measurement,
33</em>, 163-183.
</p>
<p>de la Torre, J. (2011). The generalized DINA model framework.
<em>Psychometrika, 76</em>, 179&ndash;199.
</p>
<p>DiBello, L. V., Roussos, L. A., &amp; Stout, W. F. (2007). Review of
cognitively diagnostic assessment and a summary of psychometric models.
In C. R. Rao and S. Sinharay (Eds.), <em>Handbook of Statistics</em>,
Vol. 26 (pp. 979&ndash;1030). Amsterdam: Elsevier.
</p>
<p>Formann, A. K. (1992). Linear logistic latent class analysis for polytomous data.
<em>Journal of the American Statistical Association, 87</em>, 476-486.
</p>
<p>George, A. C., &amp; Robitzsch, A. (2015) Cognitive diagnosis models in R: A didactic.
<em>The Quantitative Methods for Psychology, 11</em>, 189-205.
doi:10.20982/tqmp.11.3.p189
</p>
<p>George, A. C., Robitzsch, A., Kiefer, T., Gross, J., &amp; Uenlue, A. (2016).
The R package CDM for cognitive diagnosis models.
<em>Journal of Statistical Software, 74</em>(2), 1-24.
</p>
<p>Junker, B. W., &amp; Sijtsma, K. (2001). Cognitive assessment models with few
assumptions, and connections with nonparametric item response theory.
<em>Applied Psychological Measurement, 25</em>, 258&ndash;272.
</p>
<p>Ravand, H., &amp; Robitzsch, A.(2015). Cognitive diagnostic modeling using R.
<em>Practical Assessment, Research &amp; Evaluation, 20</em>(11).
Available online: http://pareonline.net/getvn.asp?v=20&amp;n=11
</p>
<p>Robitzsch, A., &amp; George, A. C. (2019). The R package CDM.
In M. von Davier &amp; Y.-S. Lee (Eds.). <em>Handbook of diagnostic
classification models</em> (pp. 549-572). Cham: Springer.
doi: <a href="https://doi.org/10.1007/978-3-030-05584-4_26">10.1007/978-3-030-05584-4_26</a>
</p>
<p>Rupp, A. A., &amp; Templin, J. (2008). Unique characteristics of
diagnostic classification models: A comprehensive review of the current
state-of-the-art. <em>Measurement: Interdisciplinary Research and
Perspectives, 6</em>, 219&ndash;262.
</p>
<p>Rupp, A. A., Templin, J., &amp; Henson, R. A. (2010). <em>Diagnostic
Measurement: Theory, Methods, and Applications</em>. New York: The Guilford
Press.
</p>
<p>Templin, J., &amp; Henson, R. (2006). Measurement of
psychological disorders using cognitive diagnosis
models. <em>Psychological Methods, 11</em>, 287&ndash;305.
</p>
<p>von Davier, M. (2008). A general diagnostic model applied to
language testing data. <em>British Journal
of Mathematical and Statistical Psychology, 61</em>, 287-307.
</p>


<h3>See Also</h3>

<p>See the <span class="pkg">GDINA</span> package for comprehensive functions for the
GDINA model.
</p>
<p>See also the <span class="pkg">ACTCD</span> and <span class="pkg">NPCD</span> packages for nonparametric cognitive
diagnostic models.
</p>
<p>See the <span class="pkg">dina</span> package for estimating the DINA model with a Gibbs sampler.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
##   **********************************
##   ** CDM 2.5-16 (2013-11-29)      **
##   ** Cognitive Diagnostic Models  **
##   **********************************
##
</code></pre>

<hr>
<h2 id='anova'>
Likelihood Ratio Test for Model Comparisons
</h2><span id='topic+anova.din'></span><span id='topic+anova.gdina'></span><span id='topic+anova.mcdina'></span><span id='topic+anova.gdm'></span><span id='topic+anova.slca'></span><span id='topic+anova.reglca'></span>

<h3>Description</h3>

<p>This function compares two models estimated with <code>din</code>, <code>gdina</code>
or <code>gdm</code> using a likelihood ratio test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'din'
anova(object,...)

## S3 method for class 'gdina'
anova(object,...)

## S3 method for class 'gdm'
anova(object,...)

## S3 method for class 'mcdina'
anova(object,...)

## S3 method for class 'reglca'
anova(object,...)

## S3 method for class 'slca'
anova(object,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="anova_+3A_object">object</code></td>
<td>

<p>Two objects of class <code>din</code>, <code>gdina</code>, <code>mcdina</code>,
<code>slca</code>, <code>gdm</code>, <code>reglca</code>
</p>
</td></tr>
<tr><td><code id="anova_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is based on <code><a href="#topic+IRT.anova">IRT.anova</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+din">din</a></code>, <code><a href="#topic+gdina">gdina</a></code>, <code><a href="#topic+gdm">gdm</a></code>,
<code><a href="#topic+mcdina">mcdina</a></code>, <code><a href="#topic+slca">slca</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: anova with din objects
#############################################################################

# Model 1
d1 &lt;- CDM::din(sim.dina, q.matr=sim.qmatrix )
# Model 2 with equal guessing and slipping parameters
d2 &lt;- CDM::din(sim.dina, q.matr=sim.qmatrix, guess.equal=TRUE, slip.equal=TRUE)
# model comparison
anova(d1,d2)
  ##     Model   loglike Deviance Npars      AIC      BIC    Chisq df  p
  ##   2    d2 -2176.482 4352.963     9 4370.963 4406.886 268.2071 16  0
  ##   1    d1 -2042.378 4084.756    25 4134.756 4234.543       NA NA NA

## Not run: 
#############################################################################
# EXAMPLE 2: anova with gdina objects
#############################################################################

# Model 3: GDINA model
d3 &lt;- CDM::gdina( sim.dina, q.matr=sim.qmatrix )

# Model 4: DINA model
d4 &lt;- CDM::gdina( sim.dina, q.matr=sim.qmatrix, rule="DINA")

# model comparison
anova(d3,d4)
  ##     Model   loglike Deviance Npars      AIC      BIC    Chisq df       p
  ##   2    d4 -2042.293 4084.586    25 4134.586 4234.373 31.31995 16 0.01224
  ##   1    d3 -2026.633 4053.267    41 4135.266 4298.917       NA NA      NA

## End(Not run)
</code></pre>

<hr>
<h2 id='cdi.kli'>
Cognitive Diagnostic Indices based on Kullback-Leibler Information
</h2><span id='topic+cdi.kli'></span><span id='topic+summary.cdi.kli'></span>

<h3>Description</h3>

<p>This function computes several cognitive diagnostic indices grounded
on the Kullback-Leibler information (Rupp, Henson
&amp; Templin, 2009, Ch. 13) at the test, item, attribute and item-attribute level.
See Henson and Douglas (2005) and Henson, Roussos, Douglas and He (2008)
for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdi.kli(object)

## S3 method for class 'cdi.kli'
summary(object, digits=2,  ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cdi.kli_+3A_object">object</code></td>
<td>

<p>Object of class <code><a href="#topic+din">din</a></code> or <code><a href="#topic+gdina">gdina</a></code>.
For the <code>summary</code> method, it is the result of <code>cdi.kli</code>.
</p>
</td></tr>
<tr><td><code id="cdi.kli_+3A_digits">digits</code></td>
<td>
<p>Number of digits for rounding</p>
</td></tr>
<tr><td><code id="cdi.kli_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with following entries
</p>
<table role = "presentation">
<tr><td><code>test_disc</code></td>
<td>
<p>Test discrimination which is the sum of all global
item discrimination indices</p>
</td></tr>
<tr><td><code>attr_disc</code></td>
<td>
<p>Attribute discriminations</p>
</td></tr>
<tr><td><code>glob_item_disc</code></td>
<td>
<p>Global item discriminations (Cognitive diagnostic
index)</p>
</td></tr>
<tr><td><code>attr_item_disc</code></td>
<td>
<p>Attribute-specific item discrimination</p>
</td></tr>
<tr><td><code>KLI</code></td>
<td>
<p>Array with Kullback-Leibler informations of all items (first dimension)
and skill classes (in the second and third dimension)</p>
</td></tr>
<tr><td><code>skillclasses</code></td>
<td>
<p>Matrix containing all used skill classes in the model</p>
</td></tr>
<tr><td><code>hdist</code></td>
<td>
<p>Matrix containing Hamming distance between skill classes</p>
</td></tr>
<tr><td><code>pjk</code></td>
<td>
<p>Used probabilities</p>
</td></tr>
<tr><td><code>q.matrix</code></td>
<td>
<p>Used Q-matrix</p>
</td></tr>
<tr><td><code>summary</code></td>
<td>
<p>Data frame with test- and item-specific
discrimination statistics</p>
</td></tr>
</table>


<h3>References</h3>

<p>Henson, R., DiBello, L., &amp; Stout, B. (2018). A generalized approach to defining item
discrimination for DCMs.
<em>Measurement: Interdisciplinary Research and Perspectives, 16</em>(1), 18-29.
http://dx.doi.org/10.1080/15366367.2018.1436855
</p>
<p>Henson, R., &amp; Douglas, J. (2005). Test construction for cognitive diagnosis.
<em>Applied Psychological Measurement, 29</em>, 262-277.
http://dx.doi.org/10.1177/0146621604272623
</p>
<p>Henson, R., Roussos, L., Douglas, J., &amp; He, X. (2008).
Cognitive diagnostic attribute-level discrimination indices.
<em>Applied Psychological Measurement, 32</em>, 275-288.
http://dx.doi.org/10.1177/0146621607302478
</p>
<p>Rupp, A. A., Templin, J., &amp; Henson, R. A. (2010). <em>Diagnostic
Measurement: Theory, Methods, and Applications</em>.  New York: The Guilford
Press.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+discrim.index">discrim.index</a></code> for computing discrimination indices at the
probability metric.
</p>
<p>See Henson, DiBello and Stout (2018) for an overview of different discrimination
indices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: Examples based on CDM::sim.dina
#############################################################################

data(sim.dina, package="CDM")
data(sim.qmatrix, package="CDM")

mod &lt;- CDM::din( sim.dina, q.matrix=sim.qmatrix )
summary(mod)
  ##  Item parameters
  ##         item guess  slip   IDI rmsea
  ##  Item1 Item1 0.086 0.210 0.704 0.014
  ##  Item2 Item2 0.109 0.239 0.652 0.034
  ##  Item3 Item3 0.129 0.185 0.686 0.028
  ##  Item4 Item4 0.226 0.218 0.556 0.019
  ##  Item5 Item5 0.059 0.000 0.941 0.002
  ##  Item6 Item6 0.248 0.500 0.252 0.036
  ##  Item7 Item7 0.243 0.489 0.268 0.041
  ##  Item8 Item8 0.278 0.125 0.597 0.109
  ##  Item9 Item9 0.317 0.027 0.656 0.065

cmod &lt;- CDM::cdi.kli( mod )

# attribute discrimination indices
round( cmod$attr_disc, 3 )
  ##      V1     V2     V3
  ##   1.966  2.506 11.169

# look at global item discrimination indices
round( cmod$glob_item_disc, 3 )
  ##  &gt; round( cmod$glob_item_disc, 3 )
  ##  Item1 Item2 Item3 Item4 Item5 Item6 Item7 Item8 Item9
  ##  0.594 0.486 0.533 0.465 5.913 0.093 0.040 0.397 0.656

# correlation of IDI and global item discrimination
stats::cor( cmod$glob_item_disc, mod$IDI )
  ##  [1] 0.6927274

# attribute-specific item indices
round( cmod$attr_item_disc, 3 )
  ##           V1    V2    V3
  ##  Item1 0.648 0.648 0.000
  ##  Item2 0.000 0.530 0.530
  ##  Item3 0.581 0.000 0.581
  ##  Item4 0.697 0.000 0.000
  ##  Item5 0.000 0.000 8.870
  ##  Item6 0.000 0.140 0.000
  ##  Item7 0.040 0.040 0.040
  ##  Item8 0.000 0.433 0.433
  ##  Item9 0.000 0.715 0.715

## Note that attributes with a zero entry for an item
## do not differ from zero for the attribute specific item index
</code></pre>

<hr>
<h2 id='CDM-utilities'>Utility Functions in <span class="pkg">CDM</span></h2><span id='topic+CDM-utilities'></span><span id='topic+CDM_require_namespace'></span><span id='topic+CDM_rmvnorm'></span><span id='topic+cdm_pem_inits'></span><span id='topic+cdm_pem_inits_assign_parmlist'></span><span id='topic+cdm_pem_acceleration'></span><span id='topic+cdm_pem_acceleration_assign_output_parameters'></span><span id='topic+cdm_print_summary_data_frame'></span><span id='topic+cdm_fa1'></span><span id='topic+cdm_print_summary_call'></span><span id='topic+cdm_print_summary_computation_time'></span><span id='topic+cdm_parameter_regularization'></span><span id='topic+cdm_penalty_values'></span><span id='topic+cdm_penalty_threshold_scad'></span><span id='topic+cdm_penalty_threshold_lasso'></span><span id='topic+cdm_fit_normal'></span><span id='topic+cdm_penalty_threshold_ridge'></span><span id='topic+cdm_penalty_threshold_elnet'></span><span id='topic+cdm_penalty_threshold_scadL2'></span><span id='topic+cdm_penalty_threshold_tlp'></span><span id='topic+cdm_penalty_threshold_mcp'></span><span id='topic+CDM_rbind_fill'></span><span id='topic+cdm_matrix2'></span><span id='topic+cdm_matrix1'></span><span id='topic+abs_approx'></span><span id='topic+abs_approx_D1'></span><span id='topic+cdm_matrixstring'></span><span id='topic+cdm_calc_information_criteria'></span><span id='topic+cdm_print_summary_information_criteria'></span><span id='topic+cat_paste'></span><span id='topic+cdm_attach_internal_function'></span>

<h3>Description</h3>

<p>Utility functions in <span class="pkg">CDM</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## requireNamespace with package message for needed installation
CDM_require_namespace(pkg)
## attach internal function in a package
cdm_attach_internal_function(pack, fun)

## print function in summary
cdm_print_summary_data_frame(obji, from=NULL, to=NULL, digits=3, rownames_null=FALSE)
## print summary call
cdm_print_summary_call(object, call_name="call")
## print computation time
cdm_print_summary_computation_time(object, time_name="time", time_start="s1",
         time_end="s2")

## string vector of matrix entries
cdm_matrixstring( matr, string )

## mvtnorm::rmvnorm with vector conversion for n=1
CDM_rmvnorm(n, mean=NULL, sigma, ...)
## fit univariate and multivariate normal distribution
cdm_fit_normal(x, w)

## fit unidimensional factor analysis by unweighted least squares
cdm_fa1(Sigma, method=1, maxit=50, conv=1E-5)

## another rbind.fill implementation
CDM_rbind_fill( x, y )
## fills a vector row-wise into a matrix
cdm_matrix2( x, nrow )
## fills a vector column-wise into a matrix
cdm_matrix1( x, ncol )

## SCAD thresholding operator
cdm_penalty_threshold_scad(beta, lambda, a=3.7)
## lasso thresholding operator
cdm_penalty_threshold_lasso(val, eta )
## ridge thresholding operator
cdm_penalty_threshold_ridge(beta, lambda)
## elastic net threshold operator
cdm_penalty_threshold_elnet( beta, lambda, alpha )
## SCAD-L2 thresholding operator
cdm_penalty_threshold_scadL2(beta, lambda, alpha, a=3.7)
## truncated L1 penalty thresholding operator
cdm_penalty_threshold_tlp( beta, tau, lambda )
## MCP thresholding operator
cdm_penalty_threshold_mcp(beta, lambda, a=3.7)

## general thresholding operator for regularization
cdm_parameter_regularization(x, regular_type, regular_lam, regular_alpha=NULL,
         regular_tau=NULL )
## values of penalty function
cdm_penalty_values(x, regular_type, regular_lam, regular_tau=NULL,
       regular_alpha=NULL)
## thresholding operators regularization
cdm_parameter_regularization(x, regular_type, regular_lam, regular_alpha=NULL,
       regular_tau=NULL)

## utility functions for P-EM acceleration
cdm_pem_inits(parmlist)
cdm_pem_inits_assign_parmlist(pem_pars, envir)
cdm_pem_acceleration( iter, pem_parameter_index, pem_parameter_sequence, pem_pars,
      PEM_itermax, parmlist, ll_fct, ll_args, deviance.history=NULL )
cdm_pem_acceleration_assign_output_parameters(res_ll_fct, vars, envir, update)

## approximation of absolute value function and its derivative
abs_approx(x, eps=1e-05)
abs_approx_D1(x, eps=1e-05)

## information criteria
cdm_calc_information_criteria(ic)
cdm_print_summary_information_criteria(object, digits_crit=0, digits_penalty=2)

## string pasting
cat_paste(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CDM-utilities_+3A_pkg">pkg</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> package</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_pack">pack</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> package</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_fun">fun</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> function</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_obji">obji</code></td>
<td>
<p>Object</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_from">from</code></td>
<td>
<p>Integer</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_to">to</code></td>
<td>
<p>Integer</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_digits">digits</code></td>
<td>
<p>Number of digits used for printing</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_rownames_null">rownames_null</code></td>
<td>
<p>Logical</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_call_name">call_name</code></td>
<td>
<p>Character</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_time_name">time_name</code></td>
<td>
<p>Character</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_time_start">time_start</code></td>
<td>
<p>Character</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_time_end">time_end</code></td>
<td>
<p>Character</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_matr">matr</code></td>
<td>
<p>Matrix</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_string">string</code></td>
<td>
<p>String</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_object">object</code></td>
<td>
<p>Object</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_n">n</code></td>
<td>
<p>Integer</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_mean">mean</code></td>
<td>
<p>Mean vector or matrix if separate means for cases are provided. In this case,
<code>n</code> can be missing.</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_sigma">sigma</code></td>
<td>
<p>Covariance matrix</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_...">...</code></td>
<td>
<p>More arguments to be passed (or a list of arguments)</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_x">x</code></td>
<td>
<p>Matrix or vector</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_y">y</code></td>
<td>
<p>Matrix or vector</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_w">w</code></td>
<td>
<p>Vector of sampling weights</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_nrow">nrow</code></td>
<td>
<p>Integer</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_ncol">ncol</code></td>
<td>
<p>Integer</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_sigma">Sigma</code></td>
<td>
<p>Covariance matrix</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_method">method</code></td>
<td>
<p>Method <code>1</code> indicates estimation of different
item loadings, method <code>2</code> estimation of same item loadings.</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_conv">conv</code></td>
<td>
<p>Convergence criterion</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_beta">beta</code></td>
<td>
<p>Numeric</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_lambda">lambda</code></td>
<td>
<p>Regularization parameter</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_alpha">alpha</code></td>
<td>
<p>Regularization parameter</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_a">a</code></td>
<td>
<p>Parameter</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_tau">tau</code></td>
<td>
<p>Regularization parameter</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_val">val</code></td>
<td>
<p>Numeric</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_eta">eta</code></td>
<td>
<p>Regularization parameter</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_regular_type">regular_type</code></td>
<td>
<p>Type of regularization</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_regular_lam">regular_lam</code></td>
<td>
<p>Regularization parameter <code class="reqn">\lambda</code></p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_regular_tau">regular_tau</code></td>
<td>
<p>Regularization parameter <code class="reqn">\tau</code></p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_regular_alpha">regular_alpha</code></td>
<td>
<p>Regularization parameter <code class="reqn">\alpha</code></p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_parmlist">parmlist</code></td>
<td>
<p>List containing parameters</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_pem_pars">pem_pars</code></td>
<td>
<p>Vector containing parameter names</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_envir">envir</code></td>
<td>
<p>Environment</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_update">update</code></td>
<td>
<p>Logical</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_iter">iter</code></td>
<td>
<p>Iteration number</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_pem_parameter_index">pem_parameter_index</code></td>
<td>
<p>List with parameter indices</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_pem_parameter_sequence">pem_parameter_sequence</code></td>
<td>
<p>List with updated parameter sequence</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_pem_itermax">PEM_itermax</code></td>
<td>
<p>Maximum number of iterations for PEM</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_ll_fct">ll_fct</code></td>
<td>
<p>Name of log-likelihood function</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_ll_args">ll_args</code></td>
<td>
<p>Arguments of log-likelihood function</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_deviance.history">deviance.history</code></td>
<td>
<p>Deviance history, a data frame.</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_res_ll_fct">res_ll_fct</code></td>
<td>
<p>Result of maximized log-likelihood function</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_vars">vars</code></td>
<td>
<p>Vector containing parameter names</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_eps">eps</code></td>
<td>
<p>Numeric</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_ic">ic</code></td>
<td>
<p>List</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_digits_crit">digits_crit</code></td>
<td>
<p>Integer</p>
</td></tr>
<tr><td><code id="CDM-utilities_+3A_digits_penalty">digits_penalty</code></td>
<td>
<p>Integer</p>
</td></tr>
</table>

<hr>
<h2 id='cdm.est.class.accuracy'>
Classification Reliability in a CDM
</h2><span id='topic+cdm.est.class.accuracy'></span>

<h3>Description</h3>

<p>This function computes the classification accuracy and
consistency originally proposed by Cui, Gierl and Chang (2012;
see also Wang et al., 2015).
The function computes both statistics by estimators of Johnson and Sinharay (2018;
see also Sinharay &amp; Johnson, 2019) and simulation based estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdm.est.class.accuracy(cdmobj, n.sims=0, version=2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cdm.est.class.accuracy_+3A_cdmobj">cdmobj</code></td>
<td>

<p>Object of class <code>din</code> or <code>gdina</code>
</p>
</td></tr>
<tr><td><code id="cdm.est.class.accuracy_+3A_n.sims">n.sims</code></td>
<td>

<p>Number of simulated persons. If <code>n.sims=0</code>, then the number
of persons in the original data is used as the sample size.
In case of missing item responses, for every simulated dataset this sample
size is used.
</p>
</td></tr>
<tr><td><code id="cdm.est.class.accuracy_+3A_version">version</code></td>
<td>
<p>Correct classification reliability statistics can be obtained
using the default <code>version=2</code>. For backward compatibility,
<code>version=1</code> contains estimators for <span class="pkg">CDM</span> (&lt;=6.2) which
have been shown to be biased (Johnson &amp; Sinharay, 2018).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The item parameters and the probability distribution of
latent classes is used as the basis of the simulation.
Accuracy and consistency is estimated for both MLE and MAP
classification estimators. In addition, classification accuracy measures
are available for the separate classification of all skills.
</p>


<h3>Value</h3>

<p>A data frame for MLE, MAP and MAP (Skill 1, ..., Skill <code class="reqn">K</code>)
classification reliability for the whole latent class pattern and
marginal skill classification with following columns:
</p>
<table role = "presentation">
<tr><td><code>Pa_est</code></td>
<td>
<p>Classification accuracy (Cui et al., 2012) using
the estimator of Johnson and Sinharay, 2018</p>
</td></tr>
<tr><td><code>Pa_sim</code></td>
<td>
<p>Classification accuracy based on simulated data
(only for <code>din</code> models)</p>
</td></tr>
<tr><td><code>Pc</code></td>
<td>
<p>Classification consistency (Cui et al., 2012) using
the estimator of Johnson and Sinharay, 2018</p>
</td></tr>
<tr><td><code>Pc_sim</code></td>
<td>
<p>Classification consistency based on simulated data
(only for <code>din</code> models)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Cui, Y., Gierl, M. J., &amp; Chang, H.-H. (2012).
Estimating classification consistency and accuracy for cognitive
diagnostic assessment.
<em>Journal of Educational Measurement, 49</em>, 19-38.
doi: <a href="https://doi.org/10.1111/j.1745-3984.2011.00158.x">10.1111/j.1745-3984.2011.00158.x</a>
</p>
<p>Johnson, M. S., &amp; Sinharay, S. (2018). Measures of agreement to assess attribute-level
classification accuracy and consistency for cognitive diagnostic assessments.
<em>Journal of Educational Measurement, 45</em>(4), 635-664.
doi: <a href="https://doi.org/10.1111/jedm.12196">10.1111/jedm.12196</a>
</p>
<p>Sinharay, S., &amp; Johnson, M. S. (2019). Measures of agreement:
Reliability, classification accuracy, and classification consistency.
In M. von Davier &amp; Y.-S. Lee (Eds.). <em>Handbook of diagnostic
classification models</em> (pp. 359-377). Cham: Springer.
doi: <a href="https://doi.org/10.1007/978-3-030-05584-4_17">10.1007/978-3-030-05584-4_17</a>
</p>
<p>Wang, W., Song, L., Chen, P., Meng, Y., &amp; Ding, S. (2015). Attribute-level and
pattern-level classification consistency and accuracy indices for cognitive diagnostic
assessment. <em>Journal of Educational Measurement, 52</em>(4), 457-476.
doi: <a href="https://doi.org/10.1111/jedm.12096">10.1111/jedm.12096</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: DINO data example
#############################################################################

data(sim.dino, package="CDM")
data(sim.qmatrix, package="CDM")

#***
# Model 1: estimate DINO model with din
mod1 &lt;- CDM::din( sim.dino, q.matrix=sim.qmatrix, rule="DINO")
# estimate classification reliability
cdm.est.class.accuracy( mod1, n.sims=5000)

#***
# Model 2: estimate DINO model with gdina
mod2 &lt;- CDM::gdina( sim.dino, q.matrix=sim.qmatrix, rule="DINO")
# estimate classification reliability
cdm.est.class.accuracy( mod2 )

m1 &lt;- mod1$coef[, c("guess", "slip" ) ]
m2 &lt;- mod2$coef
m2 &lt;- cbind( m1, m2[ seq(1,18,2), "est" ],
          1 - m2[ seq(1,18,2), "est" ]  - m2[ seq(2,18,2), "est" ]  )
colnames(m2) &lt;- c("g.M1", "s.M1", "g.M2", "s.M2" )
  ##   &gt; round( m2, 3 )
  ##          g.M1  s.M1  g.M2  s.M2
  ##   Item1 0.109 0.192 0.109 0.191
  ##   Item2 0.073 0.234 0.072 0.234
  ##   Item3 0.139 0.238 0.146 0.238
  ##   Item4 0.124 0.065 0.124 0.009
  ##   Item5 0.125 0.035 0.125 0.037
  ##   Item6 0.214 0.523 0.214 0.529
  ##   Item7 0.193 0.514 0.192 0.514
  ##   Item8 0.246 0.100 0.246 0.100
  ##   Item9 0.201 0.032 0.195 0.032
# Note that s (the slipping parameter) substantially differs for Item4
# for DINO estimation in 'din' and 'gdina'

## End(Not run)
</code></pre>

<hr>
<h2 id='coef'>Extract Estimated Item Parameters and Skill Class Distribution
Parameters</h2><span id='topic+coef.din'></span><span id='topic+coef.gdina'></span><span id='topic+coef.mcdina'></span><span id='topic+coef.gdm'></span><span id='topic+coef.slca'></span>

<h3>Description</h3>

<p>Extracts the estimated parameters from either
<code>din</code>, <code>gdina</code>,  <code>gdina</code> or <code>gdm</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'din'
coef(object, ...)

## S3 method for class 'gdina'
coef(object, ...)

## S3 method for class 'mcdina'
coef(object, ...)

## S3 method for class 'gdm'
coef(object, ...)

## S3 method for class 'slca'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef_+3A_object">object</code></td>
<td>
<p>An object inheriting from either class <code>din</code>,
class <code>gdina</code>, class <code>mcdina</code>, class <code>slca</code>
or class <code>gdm</code>.
</p>
</td></tr>
<tr><td><code id="coef_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector, a matrix or a data frame of the estimated parameters for the fitted model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+din">din</a></code>, <code><a href="#topic+gdina">gdina</a></code>, <code><a href="#topic+gdm">gdm</a></code>,
<code><a href="#topic+mcdina">mcdina</a></code>, <code><a href="#topic+slca">slca</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sim.dina, package="CDM")
data(sim.qmatrix, package="CDM")

# DINA model
d1 &lt;- CDM::din( sim.dina, q.matrix=sim.qmatrix)
coef(d1)

## Not run: 
# GDINA model
d2 &lt;- CDM::gdina( sim.dina, q.matrix=sim.qmatrix)
coef(d2)

# GDM model
theta.k &lt;- seq(-4,4,len=11)
d3 &lt;- CDM::gdm( sim.dina, irtmodel="2PL", theta.k=theta.k,
            Qmatrix=as.matrix(sim.qmatrix),  centered.latent=TRUE)
coef(d3)

## End(Not run)
</code></pre>

<hr>
<h2 id='Data-sim'>
Artificial Data: DINA and DINO
</h2><span id='topic+Data-sim'></span><span id='topic+sim.dina'></span><span id='topic+sim.dino'></span><span id='topic+sim.qmatrix'></span>

<h3>Description</h3>

<p>Artificial data: dichotomously coded fictitious answers of 400 respondents
to 9 items assuming 3 underlying attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data(sim.dina)
  data(sim.dino)
  data(sim.qmatrix)
</code></pre>


<h3>Format</h3>

<p>The <code>sim.dina</code> and <code>sim.dino</code> data sets include dichotomous
answers of <code class="reqn">N=400</code> respondents to <code class="reqn">J=9</code> items, thus they are
<code class="reqn">400 \times 9</code> data matrices.  For both data sets <code class="reqn">K=3</code>
attributes are assumed to underlie the process of responding, stored
in <code>sim.qmatrix</code>.
</p>
<p>The <code>sim.dina</code> data set is simulated according to the DINA condensation
rule, whereas the <code>sim.dino</code> data set is simulated according to the
DINO condensation rule.  The slipping errors for the items 1 to 9 in both
data sets are <code>0.20, 0.20, 0.20, 0.20, 0.00, 0.50, 0.50, 0.10, 0.03</code>
and the guessing errors are <code>0.10, 0.125, 0.15, 0.175, 0.2, 0.225,
  0.25, 0.275, 0.3</code>.  The attributes are assumed to be mastered with expected
probabilities of <code>-0.4, 0.2, 0.6</code>, respectively.  The correlation of
the attributes is <code>0.3</code> for attributes 1 and 2, <code>0.4</code> for
attributes 1 and 3 and <code>0.1</code> for attributes 2 and 3.
</p>


<h3>Example Index</h3>

<p><em>Dataset</em> <code>sim.dina</code>
</p>
<p><code><a href="stats.html#topic+anova">anova</a></code> (Examples 1, 2),
<code><a href="#topic+cdi.kli">cdi.kli</a></code> (Example 1),
<code><a href="#topic+din">din</a></code> (Examples 2, 4, 5),
<code><a href="#topic+gdina">gdina</a></code> (Example 1),
<code><a href="#topic+itemfit.sx2">itemfit.sx2</a></code> (Example 2),
<code><a href="#topic+modelfit.cor.din">modelfit.cor.din</a></code> (Example 1)
<br />
</p>
<p><em>Dataset</em> <code>sim.dino</code>
</p>
<p><code><a href="#topic+cdm.est.class.accuracy">cdm.est.class.accuracy</a></code> (Example 1),
<code><a href="#topic+din">din</a></code> (Example 3), <code><a href="#topic+gdina">gdina</a></code> (Examples 2, 3, 4),
</p>


<h3>References</h3>

<p>Rupp, A. A., Templin, J. L., &amp; Henson, R. A. (2010) <em>Diagnostic
Measurement: Theory, Methods, and Applications</em>. New York: The Guilford
Press.
</p>

<hr>
<h2 id='data.cdm'>
Several Datasets for the <span class="pkg">CDM</span> Package
</h2><span id='topic+data.cdm'></span><span id='topic+data.cdm01'></span><span id='topic+data.cdm02'></span><span id='topic+data.cdm03'></span><span id='topic+data.cdm04'></span><span id='topic+data.cdm05'></span><span id='topic+data.cdm06'></span><span id='topic+data.cdm07'></span><span id='topic+data.cdm08'></span><span id='topic+data.cdm09'></span><span id='topic+data.cdm10'></span>

<h3>Description</h3>

<p>Several datasets for the <span class="pkg">CDM</span> package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data.cdm01)
data(data.cdm02)
data(data.cdm03)
data(data.cdm04)
data(data.cdm05)
data(data.cdm06)
data(data.cdm07)
data(data.cdm08)
data(data.cdm09)
data(data.cdm10)
</code></pre>


<h3>Format</h3>


<ul>
<li><p> Dataset <code>data.cdm01</code>
</p>
<p>This dataset is a multiple choice dataset and used in the <code><a href="#topic+mcdina">mcdina</a></code>
function. The format is:
</p>
<p><code>List of 3</code> <br />
<code> $ data    :'data.frame':</code> <br />
<code>  ..$ I1 : int [1:5003] 3 3 4 1 1 1 1 1 1 1 ...</code> <br />
<code>  ..$ I2 : int [1:5003] 1 1 3 1 1 2 1 1 2 1 ...</code> <br />
<code>  ..$ I3 : int [1:5003] 4 3 2 3 2 2 2 2 1 2 ...</code> <br />
<code>  ..$ I4 : int [1:5003] 3 3 3 2 2 2 2 3 3 1 ...</code> <br />
<code>  ..$ I5 : int [1:5003] 2 2 2 3 1 1 2 3 2 1 ...</code> <br />
<code>  ..$ I6 : int [1:5003] 3 1 1 1 1 2 1 1 1 1 ...</code> <br />
<code>  ..$ I7 : int [1:5003] 1 1 2 2 1 3 1 1 1 3 ...</code> <br />
<code>  ..$ I8 : int [1:5003] 1 1 1 1 1 2 1 4 3 3 ...</code> <br />
<code>  ..$ I9 : int [1:5003] 3 2 1 1 1 1 3 3 1 3 ...</code> <br />
<code>  ..$ I10: int [1:5003] 2 1 2 1 1 2 2 2 2 1 ...</code> <br />
<code>  ..$ I11: int [1:5003] 2 2 2 2 1 2 1 2 1 1 ...</code> <br />
<code>  ..$ I12: int [1:5003] 1 2 1 1 2 1 1 1 1 2 ...</code> <br />
<code>  ..$ I13: int [1:5003] 2 1 1 1 2 1 2 2 1 1 ...</code> <br />
<code>  ..$ I14: int [1:5003] 1 1 1 1 1 2 1 1 2 1 ...</code> <br />
<code>  ..$ I15: int [1:5003] 1 2 1 1 1 1 1 1 1 1 ...</code> <br />
<code>  ..$ I16: int [1:5003] 1 2 2 1 2 2 2 1 1 1 ...</code> <br />
<code>  ..$ I17: int [1:5003] 1 1 1 1 1 1 1 1 1 1 ...</code> <br />
<code> $ group   : int [1:5003] 1 1 1 1 1 1 1 1 1 1 ...</code> <br />
<code> $ q.matrix:'data.frame':</code> <br />
<code>  ..$ item : int [1:52] 1 1 1 1 2 2 2 2 3 3 ...</code> <br />
<code>  ..$ categ: int [1:52] 1 2 3 4 1 2 3 4 1 2 ...</code> <br />
<code>  ..$ A1   : int [1:52] 0 1 0 1 0 1 1 1 0 0 ...</code> <br />
<code>  ..$ A2   : int [1:52] 0 0 1 1 0 0 0 1 0 0 ...</code> <br />
<code>  ..$ A3   : int [1:52] 0 0 0 0 0 0 0 0 0 0 ...</code> <br />
</p>
</li>
<li><p> Dataset <code>data.cdm02</code>
</p>
<p>Multiple choice dataset with a Q-matrix designed for polytomous
attributes.
</p>
<p><code>List of 2</code> <br />
<code> $ data    :'data.frame':</code> <br />
<code>  ..$ I1 : int [1:3000] 3 3 4 1 1 1 1 1 1 1 ...</code> <br />
<code>  ..$ I2 : int [1:3000] 1 1 3 1 1 2 1 1 2 1 ...</code> <br />
<code>  ..$ I3 : int [1:3000] 4 3 2 3 2 2 2 2 1 2 ...</code> <br />
<code>  [...] </code> <br />
<code>  ..$ B17: num [1:3000] 1 1 1 1 1 1 1 1 1 1 ...</code> <br />
<code>  ..$ B18: num [1:3000] 1 1 1 1 2 2 2 2 2 2 ...</code> <br />
<code> $ q.matrix:'data.frame':</code> <br />
<code>  ..$ item : int [1:100] 1 1 1 1 2 2 2 2 3 3 ...</code> <br />
<code>  ..$ categ: int [1:100] 1 2 3 4 1 2 3 4 1 2 ...</code> <br />
<code>  ..$ A1   : num [1:100] 0 1 0 1 0 1 1 1 0 0 ...</code> <br />
<code>  ..$ A2   : num [1:100] 0 0 1 1 0 0 0 1 0 0 ...</code> <br />
<code>  ..$ A3   : num [1:100] 0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ B1   : num [1:100] 0 0 0 0 0 0 0 0 0 0 ...</code> <br />
</p>
</li>
<li><p> Dataset <code>data.cdm03</code>:
</p>
<p>This is a resimulated dataset from Chiu, Koehn and Wu (2016) where
the data generating model is a reduced RUM model. See Example 1.
</p>
<p><code>List of 2</code> <br />
<code> $ data   : num [1:725, 1:16] 0 1 1 1 1 1 1 1 1 1 ...</code> <br />
<code>  ..- attr(*, "dimnames")=List of 2</code> <br />
<code>  .. ..$ : NULL</code> <br />
<code>  .. ..$ : chr [1:16] "I01" "I02" "I03" "I04" ...</code> <br />
<code> $ qmatrix:'data.frame':        16 obs. of  6 variables:</code> <br />
<code>  ..$ item: Factor w/ 16 levels "I01","I02","I03",..: 1 2 3 4 5 6 7 8 9 10 ...</code> <br />
<code>  ..$ A1  : int [1:16] 1 0 0 0 0 0 0 0 1 1 ...</code> <br />
<code>  ..$ A2  : int [1:16] 0 1 0 0 1 1 0 0 0 0 ...</code> <br />
<code>  ..$ A3  : int [1:16] 0 0 1 1 1 1 0 0 0 0 ...</code> <br />
<code>  ..$ A4  : int [1:16] 0 0 0 0 0 0 1 1 1 1 ...</code> <br />
<code>  ..$ A5  : int [1:16] 0 0 0 0 0 0 0 0 0 0 ...</code> <br />
</p>
</li>
<li><p> Dataset <code>data.cdm04</code>:
</p>
<p>Simulated dataset for the sequential DINA model
(as described in Ma &amp; de la Torre, 2016).
The dataset contains 1000 persons and 12 items which measure 2 skills.
</p>
<p><code>List of 3</code> <br />
<code> $ data     : num [1:1000, 1:12] 0 0 0 1 1 0 0 0 0 0 ...</code> <br />
<code>  ..- attr(*, "dimnames")=List of 2</code> <br />
<code>  .. ..$ : NULL</code> <br />
<code>  .. ..$ : chr [1:12] "I1" "I2" "I3" "I4" ...</code> <br />
<code> $ q.matrix1:'data.frame':      18 obs. of  4 variables:</code> <br />
<code>  ..$ Item: chr [1:18] "I1" "I2" "I3" "I4" ...</code> <br />
<code>  ..$ Cat : int [1:18] 1 1 1 1 1 1 1 2 1 2 ...</code> <br />
<code>  ..$ A1  : int [1:18] 1 1 1 0 0 0 1 1 1 1 ...</code> <br />
<code>  ..$ A2  : int [1:18] 0 0 0 1 1 1 0 0 0 0 ...</code> <br />
<code> $ q.matrix2:'data.frame':      18 obs. of  4 variables:</code> <br />
<code>  ..$ Item: chr [1:18] "I1" "I2" "I3" "I4" ...</code> <br />
<code>  ..$ Cat : int [1:18] 1 1 1 1 1 1 1 2 1 2 ...</code> <br />
<code>  ..$ A1  : num [1:18] 1 1 1 0 0 0 1 1 1 1 ...</code> <br />
<code>  ..$ A2  : num [1:18] 0 0 0 1 1 1 0 0 0 0 ...</code> <br />
</p>
</li>
<li><p> Dataset <code>data.cdm05</code>:
</p>
<p>Example dataset used in Philipp, Strobl, de la Torre and Zeileis (2018).
This dataset is a sub-dataset of the <code>probability</code> dataset in
the <span class="pkg">pks</span> package (Heller &amp; Wickelmaier, 2013).
</p>
<p><code>List of 3</code> <br />
<code> $ data    :'data.frame':       504 obs. of  12 variables:</code> <br />
<code>  ..$ b101: num [1:504] 1 1 1 1 1 1 1 1 1 1 ...</code> <br />
<code>  ..$ b102: num [1:504] 1 1 1 1 1 1 1 1 1 1 ...</code> <br />
<code>  ..$ b103: num [1:504] 1 1 1 1 1 1 1 1 1 1 ...</code> <br />
<code>  ..$ b104: num [1:504] 1 1 1 1 0 1 0 0 0 1 ...</code> <br />
<code>  ..$ b105: num [1:504] 1 0 1 1 1 1 0 1 1 1 ...</code> <br />
<code>  ..$ b106: num [1:504] 1 1 1 1 1 1 1 1 1 1 ...</code> <br />
<code>  ..$ b107: num [1:504] 1 1 1 1 1 1 1 1 1 1 ...</code> <br />
<code>  ..$ b108: num [1:504] 1 1 1 1 1 1 0 1 1 1 ...</code> <br />
<code>  ..$ b109: num [1:504] 1 1 0 1 1 0 0 1 1 0 ...</code> <br />
<code>  ..$ b110: num [1:504] 0 0 0 1 0 0 0 0 0 1 ...</code> <br />
<code>  ..$ b111: num [1:504] 0 1 0 0 0 1 0 0 0 0 ...</code> <br />
<code>  ..$ b112: num [1:504] 1 1 0 1 0 1 0 1 0 0 ...</code> <br />
<code> $ q.matrix:'data.frame':       12 obs. of  4 variables:</code> <br />
<code>  ..$ pb: num [1:12] 1 0 0 0 1 1 1 1 1 0 ...</code> <br />
<code>  ..$ cp: num [1:12] 0 1 0 0 1 1 0 0 0 1 ...</code> <br />
<code>  ..$ un: num [1:12] 0 0 1 0 0 0 1 1 0 0 ...</code> <br />
<code>  ..$ id: num [1:12] 0 0 0 1 0 0 0 0 1 1 ...</code> <br />
<code> $ skills  : Named chr [1:4] "how to calculate the classic probability "</code> <br />
<code>  ..- attr(*, "names")=chr [1:4] "pb" "cp" "un" "id"</code> <br />
</p>
</li>
<li><p> Dataset <code>data.cdm06</code>:
</p>
<p>Resimulated example dataset from Chen and Chen (2017).
</p>
<p><code>List of 3</code> <br />
<code> $ data    :'data.frame':       2733 obs. of  15 variables:</code> <br />
<code>  ..$ I01: num [1:2733] 1 0 0 1 0 0 0 1 1 1 ...</code> <br />
<code>  ..$ I02: num [1:2733] 1 0 0 1 1 0 1 0 0 1 ...</code> <br />
<code>  ..$ I03: num [1:2733] 0 0 0 1 1 0 1 0 1 0 ...</code> <br />
<code>  ..$ I04: num [1:2733] 1 1 0 0 0 0 1 1 1 0 ...</code> <br />
<code>  ..$ I05: num [1:2733] 1 0 1 1 0 1 1 1 1 1 ...</code> <br />
<code>  ..$ I06: num [1:2733] 0 0 0 1 1 0 0 0 1 1 ...</code> <br />
<code>  ..$ I07: num [1:2733] 1 1 1 0 0 1 1 0 1 1 ...</code> <br />
<code>  ..$ I08: num [1:2733] 0 0 0 0 0 0 0 0 1 1 ...</code> <br />
<code>  ..$ I09: num [1:2733] 1 0 0 1 1 1 0 1 0 1 ...</code> <br />
<code>  ..$ I10: num [1:2733] 0 0 0 1 0 1 1 0 1 1 ...</code> <br />
<code>  ..$ I11: num [1:2733] 0 1 0 1 1 1 1 0 1 1 ...</code> <br />
<code>  ..$ I12: num [1:2733] 0 1 0 1 0 0 0 1 1 1 ...</code> <br />
<code>  ..$ I13: num [1:2733] 0 0 1 1 0 1 0 0 0 1 ...</code> <br />
<code>  ..$ I14: num [1:2733] 0 0 0 1 1 0 1 1 0 0 ...</code> <br />
<code>  ..$ I15: num [1:2733] 0 0 0 1 0 0 1 0 1 1 ...</code> <br />
<code> $ q.matrix:'data.frame':       15 obs. of  5 variables:</code> <br />
<code>  ..$ RI: num [1:15] 1 1 1 0 1 1 1 1 0 0 ...</code> <br />
<code>  ..$ JS: num [1:15] 1 0 0 1 0 0 0 0 0 1 ...</code> <br />
<code>  ..$ GI: num [1:15] 0 1 0 1 0 0 1 1 1 1 ...</code> <br />
<code>  ..$ II: num [1:15] 0 1 1 0 1 0 1 0 0 0 ...</code> <br />
<code>  ..$ MI: num [1:15] 0 0 1 0 0 0 0 0 1 0 ...</code> <br />
<code> $ skills  : chr [1:5, 1:2] "Retrieving explicit information "  ...</code> <br />
<code>  ..- attr(*, "dimnames")=List of 2</code> <br />
<code>  .. ..$ : chr [1:5] "RI" "JS" "GI" "II" ...</code> <br />
<code>  .. ..$ : chr [1:2] "skill" "description"</code> <br />
</p>
</li>
<li><p> Dataset <code>data.cdm07</code>:
</p>
<p>This is a resimulated dataset from the social anxiety disorder data
concerning social phobia which involve 13 dichotomous questions
(Fang, Liu &amp; Ling, 2017). The simulation was based on a latent class
model with five classes. The dataset was also used in Chen, Li, Liu
and Ying (2017).
</p>
<p><code> $ data    : num [1:863, 1:13] 1 0 1 1 1 1 1 1 1 1 ...</code> <br />
<code>  ..- attr(*, "dimnames")=List of 2</code> <br />
<code>  .. ..$ : NULL</code> <br />
<code>  .. ..$ : chr [1:13] "I1" "I2" "I3" "I4" ...</code> <br />
<code> $ q.matrix: num [1:13, 1:3] 1 1 1 1 0 0 0 0 0 0 ...</code> <br />
<code>  ..- attr(*, "dimnames")=List of 2</code> <br />
<code>  .. ..$ : chr [1:13] "I1" "I2" "I3" "I4" ...</code> <br />
<code>  .. ..$ : chr [1:3] "A1" "A2" "A3"</code> <br />
<code> $ items   : atomic [1:13] 1 speaking in front of other people? ...</code> <br />
<code>  ..- attr(*, "stem")=chr "Have you ever had a strong fear or avoidance of ..."</code> <br />
</p>
</li>
<li><p> Dataset <code>data.cdm08</code>:
</p>
<p>This is a simulated dataset involving four skills and three misconceptions
for the model for simultaneously identifying skills and
misconceptions (SISM; Kuo, Chen &amp; de la Torre, 2018). The Q-matrix follows
the specification in their simulation study.
</p>
<p><code>List of 2</code> <br />
<code> $ data    :'data.frame':       1300 obs. of  20 variables:</code> <br />
<code>  ..$ I01: num [1:1300] 1 0 0 1 1 1 1 1 1 1 ...</code> <br />
<code>  ..$ I02: num [1:1300] 0 0 0 0 1 1 1 1 1 1 ...</code> <br />
<code>  ..$ I03: num [1:1300] 0 0 0 0 1 1 1 1 1 1 ...</code> <br />
<code>  ..$ I04: num [1:1300] 1 1 0 1 0 1 1 0 1 1 ...</code> <br />
<code>  ..$ I05: num [1:1300] 1 1 1 0 1 1 0 1 1 1 ...</code> <br />
<code>  ..[...] </code> <br />
<code>  ..$ I18: num [1:1300] 0 1 0 0 0 0 0 0 0 1 ...</code> <br />
<code>  ..$ I19: num [1:1300] 1 1 0 0 0 0 0 1 1 1 ...</code> <br />
<code>  ..$ I20: num [1:1300] 1 1 0 0 0 1 0 1 0 1 ...</code> <br />
<code> $ q.matrix:'data.frame':       20 obs. of  7 variables:</code> <br />
<code>  ..$ S1: num [1:20] 1 0 0 0 0 0 0 1 0 0 ...</code> <br />
<code>  ..$ S2: num [1:20] 0 1 0 0 0 0 0 0 1 0 ...</code> <br />
<code>  ..$ S3: num [1:20] 0 0 1 0 0 0 0 0 0 1 ...</code> <br />
<code>  ..$ S4: num [1:20] 0 0 0 1 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ B1: num [1:20] 0 0 0 0 1 0 0 1 1 0 ...</code> <br />
<code>  ..$ B2: num [1:20] 0 0 0 0 0 1 0 0 0 0 ...</code> <br />
<code>  ..$ B3: num [1:20] 0 0 0 0 0 0 1 0 0 1 ...</code> <br />
</p>
</li>
<li><p> Dataset <code>data.cdm09</code>:
This is a simulated dataset involving polytomous skills which is adapted
from the empirical example (proportional reasoning data)
of Chen and de la Torre (2013).
</p>
<p><code>List of 2</code> <br />
<code> $ data    : num [1:500, 1:15] 1 0 1 1 0 1 1 1 1 1 ...</code> <br />
<code>  ..- attr(*, "dimnames")=List of 2</code> <br />
<code>  .. ..$ : NULL</code> <br />
<code>  .. ..$ : chr [1:15] "I1" "I2" "I3" "I4" ...</code> <br />
<code> $ q.matrix:'data.frame':       15 obs. of  4 variables:</code> <br />
<code>  ..$ A1: int [1:15] 0 0 0 0 2 0 0 2 1 1 ...</code> <br />
<code>  ..$ A2: int [1:15] 1 0 2 0 0 1 2 0 1 1 ...</code> <br />
<code>  ..$ A3: int [1:15] 0 0 0 1 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ A4: int [1:15] 0 1 1 0 0 0 0 0 0 0 ...</code> <br />
</p>
</li>
<li><p> Dataset <code>data.cdm10</code>:
This is a simulated dataset involving a hierarchical skill structure.
Skill A has four levels, skill B possesses two levels and skill C has three levels.
</p>
<p><code>List of 2</code> <br />
<code> $ data    : num [1:1500, 1:15] 1 1 0 0 0 1 1 0 0 1 ...</code> <br />
<code>  ..- attr(*, "dimnames")=List of 2</code> <br />
<code>  .. ..$ : NULL</code> <br />
<code>  .. ..$ : chr [1:15] "I1" "I2" "I3" "I4" ...</code> <br />
<code> $ q.matrix: num [1:15, 1:6] 1 1 1 1 1 1 0 0 0 0 ...</code> <br />
<code>  ..- attr(*, "dimnames")=List of 2</code> <br />
<code>  .. ..$ : chr [1:15] "I1" "I2" "I3" "I4" ...</code> <br />
<code>  .. ..$ : chr [1:6] "A1" "A2" "A3" "B1" ...</code> <br />
</p>
</li></ul>



<h3>References</h3>

<p>Chen, H., &amp; Chen, J. (2017). Cognitive diagnostic research on chinese
students' English listening skills and implications on skill training.
<em>English Language Teaching, 10</em>(12), 107-115.
http://dx.doi.org/10.5539/elt.v10n12p107
</p>
<p>Chen, J., &amp; de la Torre, J. (2013). A general cognitive diagnosis model for
expert-defined polytomous attributes. <em>Applied Psychological Measurement, 37</em>,
419-437.
http://dx.doi.org/10.1177/0146621613479818
</p>
<p>Chen, Y., Li, X., Liu, J., &amp; Ying, Z. (2017).
Regularized latent class analysis with application in cognitive diagnosis.
<em>Psychometrika, 82</em>, 660-692.
http://dx.doi.org/10.1007/s11336-016-9545-6
</p>
<p>Chiu, C.-Y., Koehn, H.-F., &amp; Wu, H.-M. (2016).
Fitting the reduced RUM with Mplus: A tutorial.
<em>International Journal of Testing, 16</em>(4), 331-351.
http://dx.doi.org/10.1080/15305058.2016.1148038
</p>
<p>Fang, G., Liu, J., &amp; Ying, Z. (2017). On the identifiability of
diagnostic classification models. <em>arXiv</em>, 1706.01240.
https://arxiv.org/abs/1706.01240
</p>
<p>Heller, J. and Wickelmaier, F. (2013). Minimum discrepancy estimation in
probabilistic knowledge structures.
<em>Electronic Notes in Discrete Mathematics, 42</em>, 49-56.
<br /> http://dx.doi.org/10.1016/j.endm.2013.05.145
</p>
<p>Kuo, B.-C., Chen, C.-H., &amp; de la Torre, J. (2018).
A cognitive diagnosis model for identifying coexisting skills and misconceptions.
<em>Applied Psychological Measurement, 42</em>(3), 179-191.
http://dx.doi.org/10.1177/0146621617722791
</p>
<p>Ma, W., &amp; de la Torre, J. (2016).
A sequential cognitive diagnosis model for polytomous responses.
<em>British Journal of Mathematical and Statistical Psychology, 69</em>(3), 253-275.
<br /> https://doi.org/10.1111/bmsp.12070
</p>
<p>Philipp, M., Strobl, C., de la Torre, J., &amp; Zeileis, A. (2018).
On the estimation of standard errors in cognitive diagnosis models.
<em>Journal of Educational and Behavioral Statistics, 43</em>(1), 88-115.
http://dx.doi.org/10.3102/1076998617719728
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Reduced RUM model, Chiu et al. (2016)
#############################################################################

data(data.cdm03, package="CDM")
dat &lt;- data.cdm03$data
qmatrix &lt;- data.cdm03$qmatrix

#*** Model 1: Reduced RUM
mod1 &lt;- CDM::gdina( dat, q.matrix=qmatrix[,-1], rule="RRUM" )
summary(mod1)

#*** Model 2: Additive model with identity link function
mod2 &lt;- CDM::gdina( dat, q.matrix=qmatrix[,-1], rule="ACDM" )
summary(mod2)

#*** Model 3: Additive model with logit link function
mod3 &lt;- CDM::gdina( dat, q.matrix=qmatrix[,-1], rule="ACDM", linkfct="logit")
summary(mod3)

#############################################################################
# EXAMPLE 2: GDINA model - probability dataset from the pks package
#############################################################################

data(data.cdm05, package="CDM")
dat &lt;- data.cdm05$data
Q &lt;- data.cdm05$q.matrix

#* estimate model
mod1 &lt;- CDM::gdina( dat, q.matrix=Q )
summary(mod1)

## End(Not run)
</code></pre>

<hr>
<h2 id='data.dcm'>
Dataset from Book 'Diagnostic Measurement' of Rupp, Templin and
Henson (2010)
</h2><span id='topic+data.dcm'></span>

<h3>Description</h3>

<p>Dataset from Chapter 9 of the book 'Diagnostic Measurement'
(Rupp, Templin &amp; Henson, 2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data.dcm)
</code></pre>


<h3>Format</h3>

<p>The format of the data is a list containing the dichotomous item
response data <code>data</code> (10000 persons at 7 items)
and the Q-matrix <code>q.matrix</code> (7 items and 3 skills):
</p>
<p><code>List of 2</code> <br />
<code> $ data    :'data.frame':</code> <br />
<code>  ..$ id: int [1:10000] 1 2 3 4 5 6 7 8 9 10 ...</code> <br />
<code>  ..$ D1: num [1:10000] 0 0 0 0 1 0 1 0 0 1 ...</code> <br />
<code>  ..$ D2: num [1:10000] 0 0 0 0 0 1 1 1 0 1 ...</code> <br />
<code>  ..$ D3: num [1:10000] 1 0 1 0 1 1 0 0 0 1 ...</code> <br />
<code>  ..$ D4: num [1:10000] 0 0 1 0 0 1 1 1 0 0 ...</code> <br />
<code>  ..$ D5: num [1:10000] 1 0 0 0 1 1 1 0 1 0 ...</code> <br />
<code>  ..$ D6: num [1:10000] 0 0 0 0 1 1 1 0 0 1 ...</code> <br />
<code>  ..$ D7: num [1:10000] 0 0 0 0 0 1 1 0 1 1 ...</code> <br />
<code> $ q.matrix: num [1:7, 1:3] 1 0 0 1 1 0 1 0 1 0 ...</code> <br />
<code>  ..- attr(*, "dimnames")=List of 2</code> <br />
<code>  .. ..$ : chr [1:7] "D1" "D2" "D3" "D4" ...</code> <br />
<code>  .. ..$ : chr [1:3] "skill1" "skill2" "skill3"</code> <br />
</p>


<h3>Source</h3>

<p>For supplementary material of the Rupp, Templin and Henson book (2010)
see <a href="http://dcm.coe.uga.edu/">http://dcm.coe.uga.edu/</a>.
</p>
<p>The dataset was downloaded from
<a href="http://dcm.coe.uga.edu/supplemental/chapter9.html">http://dcm.coe.uga.edu/supplemental/chapter9.html</a>.
</p>


<h3>References</h3>

<p>Rupp, A. A., Templin, J., &amp; Henson, R. A. (2010). <em>Diagnostic
Measurement: Theory, Methods, and Applications</em>. New York: The Guilford
Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(data.dcm, package="CDM")

dat &lt;- data.dcm$data[,-1]
Q &lt;- data.dcm$q.matrix

#*****************************************************
# Model 1: DINA model
#*****************************************************
mod1 &lt;- CDM::din( dat, q.matrix=Q )
summary(mod1)

#--------
# Model 1m: estimate model in mirt package
library(mirt)
library(sirt)

  #** define theta grid of skills
  # use the function skillspace.hierarchy just for convenience
hier &lt;- "skill1 &gt; skill2"
skillspace &lt;- CDM::skillspace.hierarchy( hier, skill.names=colnames(Q) )
Theta &lt;- as.matrix(skillspace$skillspace.complete)
  #** create mirt model
mirtmodel &lt;- mirt::mirt.model("
      skill1=1
      skill2=2
      skill3=3
      (skill1*skill2)=4
      (skill1*skill3)=5
      (skill2*skill3)=6
      (skill1*skill2*skill3)=7
          " )
  #** mirt parameter table
mod.pars &lt;- mirt::mirt( dat, mirtmodel, pars="values")
  # use starting values of .20 for guessing parameter
ind &lt;- which( mod.pars$name=="d" )
mod.pars[ind,"value"] &lt;- stats::qlogis(.20) # guessing parameter on the logit metric
  # use starting values of .80 for anti-slipping parameter
ind &lt;- which( ( mod.pars$name %in% paste0("a",1:20 ) ) &amp; (mod.pars$est) )
mod.pars[ind,"value"] &lt;- stats::qlogis(.80) - stats::qlogis(.20)
mod.pars
  #** prior for the skill space distribution
I &lt;- ncol(dat)
lca_prior &lt;- function(Theta,Etable){
  TP &lt;- nrow(Theta)
  if ( is.null(Etable) ){ prior &lt;- rep( 1/TP, TP ) }
  if ( ! is.null(Etable) ){
    prior &lt;- ( rowSums(Etable[, seq(1,2*I,2)]) + rowSums(Etable[,seq(2,2*I,2)]) )/I
  }
  prior &lt;- prior / sum(prior)
  return(prior)
 }

 #** estimate model in mirt
mod1m &lt;- mirt::mirt(dat, mirtmodel, pars=mod.pars, verbose=TRUE,
            technical=list( customTheta=Theta, customPriorFun=lca_prior) )
  # The number of estimated parameters is incorrect because mirt does not correctly count
  # estimated parameters from the user customized  prior distribution.
mod1m@nest &lt;- as.integer(sum(mod.pars$est) + nrow(Theta) - 1)
  # extract log-likelihood
mod1m@logLik
  # compute AIC and BIC
( AIC &lt;- -2*mod1m@logLik+2*mod1m@nest )
( BIC &lt;- -2*mod1m@logLik+log(mod1m@Data$N)*mod1m@nest )
  #** extract item parameters
cmod1m &lt;- sirt::mirt.wrapper.coef(mod1m)$coef
# compare estimated guessing and slipping parameters
dfr &lt;- data.frame(    "din.guess"=mod1$guess$est,
                  "mirt.guess"=plogis(cmod1m$d), "din.slip"=mod1$slip$est,
                  "mirt.slip"=1-plogis( rowSums( cmod1m[, c("d", paste0("a",1:7) ) ] ) )
                    )
round(t(dfr),3)
  ##               [,1]  [,2]  [,3]  [,4]  [,5]  [,6]  [,7]
  ##   din.guess  0.217 0.193 0.189 0.135 0.143 0.135 0.162
  ##   mirt.guess 0.226 0.189 0.184 0.132 0.142 0.132 0.158
  ##   din.slip   0.338 0.331 0.334 0.220 0.222 0.211 0.042
  ##   mirt.slip  0.339 0.333 0.336 0.223 0.225 0.214 0.044

# compare estimated skill class distribution
dfr &lt;- data.frame("din"=mod1$attribute.patt$class.prob,
                    "mirt"=mod1m@Prior[[1]] )
round(t(dfr),3)
  ##         [,1]  [,2]  [,3]  [,4]  [,5]  [,6]  [,7]  [,8]
  ##   din  0.113 0.083 0.094 0.092 0.064 0.059 0.065 0.429
  ##   mirt 0.116 0.074 0.095 0.064 0.095 0.058 0.066 0.433

#** extract estimated classifications
fsc1m &lt;- sirt::mirt.wrapper.fscores( mod1m )
#- estimated reliabilities
fsc1m$EAP.rel
  ##      skill1    skill2    skill3
  ##   0.5479942 0.5362595 0.5357961
#- estimated classfications: EAPs, MLEs and MAPs
head( round(fsc1m$person,3) )
  ##     case     M EAP.skill1 SE.EAP.skill1 EAP.skill2 SE.EAP.skill2 EAP.skill3 SE.EAP.skill3
  ##   1    1 0.286      0.508         0.500      0.067         0.251      0.820         0.384
  ##   2    2 0.000      0.162         0.369      0.191         0.393      0.190         0.392
  ##   3    3 0.286      0.200         0.400      0.211         0.408      0.607         0.489
  ##   4    4 0.000      0.162         0.369      0.191         0.393      0.190         0.392
  ##   5    5 0.571      0.802         0.398      0.267         0.443      0.928         0.258
  ##   6    6 0.857      0.998         0.045      1.000         0.019      1.000         0.020
  ##     MLE.skill1 MLE.skill2 MLE.skill3 MAP.skill1 MAP.skill2 MAP.skill3
  ##   1          1          0          1          1          0          1
  ##   2          0          0          0          0          0          0
  ##   3          0          0          1          0          0          1
  ##   4          0          0          0          0          0          0
  ##   5          1          0          1          1          0          1
  ##   6          1          1          1          1          1          1

#** estimate model fit in mirt
( fit1m &lt;- mirt::M2( mod1m ) )

#*****************************************************
# Model 2: DINO model
#*****************************************************
mod2 &lt;- CDM::din( dat, q.matrix=Q, rule="DINO")
summary(mod2)

#*****************************************************
# Model 3: log-linear model (LCDM): this model is the GDINA model with the
#    logit link function
#*****************************************************
mod3 &lt;- CDM::gdina( dat, q.matrix=Q, link="logit")
summary(mod3)

#*****************************************************
# Model 4: GDINA model with identity link function
#*****************************************************
mod4 &lt;- CDM::gdina( dat, q.matrix=Q )
summary(mod4)

#*****************************************************
# Model 5: GDINA additive model identity link function
#*****************************************************
mod5 &lt;- CDM::gdina( dat, q.matrix=Q, rule="ACDM")
summary(mod5)

#*****************************************************
# Model 6: GDINA additive model logit link function
#*****************************************************
mod6 &lt;- CDM::gdina( dat, q.matrix=Q, link="logit", rule="ACDM")
summary(mod6)

#--------
# Model 6m: GDINA additive model in mirt package
# use data specifications from Model 1m)
  #** create mirt model
mirtmodel &lt;- mirt::mirt.model("
      skill1=1,4,5,7
      skill2=2,4,6,7
      skill3=3,5,6,7
          " )
  #** mirt parameter table
mod.pars &lt;- mirt::mirt( dat, mirtmodel, pars="values")
 #** estimate model in mirt
 # Theta and lca_prior as defined as in Model 1m
mod6m &lt;- mirt::mirt(dat, mirtmodel, pars=mod.pars, verbose=TRUE,
            technical=list( customTheta=Theta, customPriorFun=lca_prior) )
mod6m@nest &lt;- as.integer(sum(mod.pars$est) + nrow(Theta) - 1)
  # extract log-likelihood
mod6m@logLik
  # compute AIC and BIC
( AIC &lt;- -2*mod6m@logLik+2*mod6m@nest )
( BIC &lt;- -2*mod6m@logLik+log(mod6m@Data$N)*mod6m@nest )
  #** skill distribution
  mod6m@Prior[[1]]
  #** extract item parameters
cmod6m &lt;- mirt.wrapper.coef(mod6m)$coef
print(cmod6m,digits=4)
  ##     item    a1    a2    a3       d g u
  ##   1   D1 1.882 0.000 0.000 -0.9330 0 1
  ##   2   D2 0.000 2.049 0.000 -1.0430 0 1
  ##   3   D3 0.000 0.000 2.028 -0.9915 0 1
  ##   4   D4 2.697 2.525 0.000 -2.9925 0 1
  ##   5   D5 2.524 0.000 2.478 -2.7863 0 1
  ##   6   D6 0.000 2.818 2.791 -3.1324 0 1
  ##   7   D7 3.113 2.918 2.785 -4.2794 0 1

#*****************************************************
# Model 7: Reduced RUM model
#*****************************************************
mod7 &lt;- CDM::gdina( dat, q.matrix=Q, rule="RRUM")
summary(mod7)

#*****************************************************
# Model 8: latent class model with 3 classes and 4 sets of starting values
#*****************************************************

#-- Model 8a: randomLCA package
library(randomLCA)
mod8a &lt;- randomLCA::randomLCA( dat, nclass=3, verbose=TRUE, notrials=4)

#-- Model8b: rasch.mirtlc function in sirt package
library(sirt)
mod8b &lt;- sirt::rasch.mirtlc( dat, Nclasses=3, nstarts=4 )
summary(mod8a)
summary(mod8b)

## End(Not run)
</code></pre>

<hr>
<h2 id='data.dtmr'>
DTMR Fraction Data (Bradshaw et al., 2014)
</h2><span id='topic+data.dtmr'></span>

<h3>Description</h3>

<p>This is a simulated dataset of the DTMR fraction data described
in Bradshaw, Izsak, Templin and Jacobson (2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data.dtmr)
</code></pre>


<h3>Format</h3>

<p>The format is:
</p>
<p><code>List of 5</code> <br />
<code> $ data              : num [1:5000, 1:27] 0 0 0 0 0 1 0 0 1 1 ...</code> <br />
<code>  ..- attr(*, "dimnames")=List of 2</code> <br />
<code>  .. ..$ : NULL</code> <br />
<code>  .. ..$ : chr [1:27] "M1" "M2" "M3" "M4" ...</code> <br />
<code> $ q.matrix          :'data.frame':     27 obs. of  4 variables:</code> <br />
<code>  ..$ RU : int [1:27] 1 0 0 1 1 0 1 0 0 0 ...</code> <br />
<code>  ..$ PI : int [1:27] 0 0 1 0 0 1 0 0 0 0 ...</code> <br />
<code>  ..$ APP: int [1:27] 0 1 0 0 0 0 0 1 1 1 ...</code> <br />
<code>  ..$ MC : int [1:27] 0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code> $ skill.distribution:'data.frame':     16 obs. of  5 variables:</code> <br />
<code>  ..$ RU  : int [1:16] 0 0 0 0 0 0 0 0 1 1 ...</code> <br />
<code>  ..$ PI  : int [1:16] 0 0 0 0 1 1 1 1 0 0 ...</code> <br />
<code>  ..$ APP : int [1:16] 0 0 1 1 0 0 1 1 0 0 ...</code> <br />
<code>  ..$ MC  : int [1:16] 0 1 0 1 0 1 0 1 0 1 ...</code> <br />
<code>  ..$ freq: int [1:16] 1064 350 280 406 196 126 238 770 14 28 ...</code> <br />
<code> $ itempars          :'data.frame':     27 obs. of  7 variables:</code> <br />
<code>  ..$ item : chr [1:27] "M1" "M2" "M3" "M4" ...</code> <br />
<code>  ..$ lam0 : num [1:27] -1.12 0.59 -2.07 -1.19 -1.67 -3.81 -0.73 -0.62 -0.09 0.28 ...</code> <br />
<code>  ..$ RU   : num [1:27] 2.24 0 0 0.65 1.52 0 1.2 0 0 0 ...</code> <br />
<code>  ..$ PI   : num [1:27] 0 0 1.7 0 0 2.08 0 0 0 0 ...</code> <br />
<code>  ..$ APP  : num [1:27] 0 1.27 0 0 0 0 0 4.25 2.16 0.87 ...</code> <br />
<code>  ..$ MC   : num [1:27] 0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ RU.PI: num [1:27] 0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code> $ sim_data          :function (N, skill.distribution, itempars)  </code> <br />
<code>  ..- attr(*, "srcref")='srcref' int [1:8] 1 13 20 1 13 1 1 20</code> <br />
<code>  .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' &lt;environment: 0x00000000298a8ed0&gt; </code> <br />
</p>
<p>The attribute definition are as follows
</p>
<p><code>RU</code>: Referent units
</p>
<p><code>PI</code>: Partitioning and iterating attribute
</p>
<p><code>APP</code>: Appropriateness attribute
</p>
<p><code>MC</code>: Multiplicative Comparison attribute
</p>


<h3>Source</h3>

<p>Simulated dataset according to Bradshaw et al. (2014).
</p>


<h3>References</h3>

<p>Bradshaw, L., Izsak, A., Templin, J., &amp; Jacobson, E. (2014).
Diagnosing teachers' understandings of rational numbers: Building a
multidimensional test within the diagnostic classification framework.
<em>Educational Measurement: Issues and Practice, 33</em>, 2-14.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Model comparisons data.dtmr
#############################################################################

data(data.dtmr, package="CDM")
data &lt;- data.dtmr$data
q.matrix &lt;- data.dtmr$q.matrix
I &lt;- ncol(data)

#*** Model 1: LCDM
# define item wise rules
rule &lt;- rep( "ACDM", I )
names(rule) &lt;- colnames(data)
rule[ c("M14","M17") ] &lt;- "GDINA2"
# estimate model
mod1 &lt;- CDM::gdina( data, q.matrix, linkfct="logit", rule=rule)
summary(mod1)

#*** Model 2: DINA model
mod2 &lt;- CDM::gdina( data, q.matrix, rule="DINA" )
summary(mod2)

#*** Model 3: RRUM model
mod3 &lt;- CDM::gdina( data, q.matrix, rule="RRUM" )
summary(mod3)

#--- model comparisons

# LCDM vs. DINA
anova(mod1,mod2)
  ##       Model   loglike Deviance Npars      AIC      BIC    Chisq df  p
  ##   2 Model 2 -76570.89 153141.8    69 153279.8 153729.5 1726.645 10  0
  ##   1 Model 1 -75707.57 151415.1    79 151573.1 152088.0       NA NA NA

# LCDM vs. RRUM
anova(mod1,mod3)
  ##       Model   loglike Deviance Npars      AIC      BIC    Chisq df  p
  ##   2 Model 2 -75746.13 151492.3    77 151646.3 152148.1 77.10994  2  0
  ##   1 Model 1 -75707.57 151415.1    79 151573.1 152088.0       NA NA NA

#--- model fit
summary( CDM::modelfit.cor.din( mod1 ) )
  ##   Test of Global Model Fit
  ##          type   value       p
  ##   1   max(X2) 7.74382 1.00000
  ##   2 abs(fcor) 0.04056 0.72707
  ##
  ##   Fit Statistics
  ##                       est
  ##   MADcor          0.00959
  ##   SRMSR           0.01217
  ##   MX2             0.75696
  ##   100*MADRESIDCOV 0.20283
  ##   MADQ3           0.02220

#############################################################################
# EXAMPLE 2: Simulating data of structure data.dtmr
#############################################################################

data(data.dtmr, package="CDM")

# draw sample of N=200
set.seed(87)
data.dtmr$sim_data(N=200, skill.distribution=data.dtmr$skill.distribution,
             itempars=data.dtmr$itempars)

## End(Not run)
</code></pre>

<hr>
<h2 id='data.ecpe'>
Dataset ECPE
</h2><span id='topic+data.ecpe'></span>

<h3>Description</h3>

<p>ECPE dataset from the Templin and Hoffman (2013) tutorial of
specifying cognitive diagnostic models in Mplus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data.ecpe)
</code></pre>


<h3>Format</h3>

<p>The format of the data is a list containing the dichotomous item
response data <code>data</code> (2922 persons at 28 items)
and the Q-matrix <code>q.matrix</code> (28 items and 3 skills):
</p>
<p><code>List of 2</code> <br />
<code> $ data    :'data.frame':</code> <br />
<code>  ..$ id : int [1:2922] 1 2 3 4 5 6 7 8 9 10 ...</code> <br />
<code>  ..$ E1 : int [1:2922] 1 1 1 1 1 1 1 0 1 1 ...</code> <br />
<code>  ..$ E2 : int [1:2922] 1 1 1 1 1 1 1 1 1 1 ...</code> <br />
<code>  ..$ E3 : int [1:2922] 1 1 1 1 1 1 1 1 1 1 ...</code> <br />
<code>  ..$ E4 : int [1:2922] 0 1 1 1 1 1 1 1 1 1 ...</code> <br />
<code>  [...] </code> <br />
<code>  ..$ E27: int [1:2922] 1 1 1 1 1 1 1 0 1 1 ...</code> <br />
<code>  ..$ E28: int [1:2922] 1 1 1 1 1 1 1 1 1 1 ...</code> <br />
<code> $ q.matrix:'data.frame':</code> <br />
<code>  ..$ skill1: int [1:28] 1 0 1 0 0 0 1 0 0 1 ...</code> <br />
<code>  ..$ skill2: int [1:28] 1 1 0 0 0 0 0 1 0 0 ...</code> <br />
<code>  ..$ skill3: int [1:28] 0 0 1 1 1 1 1 0 1 0 ...</code> <br />
</p>
<p>The skills are
</p>
<p><code>skill1</code>: Morphosyntactic rules
</p>
<p><code>skill2</code>: Cohesive rules
</p>
<p><code>skill3</code>: Lexical rules.
</p>


<h3>Details</h3>

<p>The dataset has been used in Templin and Hoffman (2013), and
Templin and Bradshaw (2014).
</p>


<h3>Source</h3>

<p>The dataset was downloaded from
<em>http://psych.unl.edu/jtemplin/teaching/dcm/dcm12ncme/</em>.
</p>


<h3>References</h3>

<p>Templin, J., &amp; Bradshaw, L. (2014). Hierarchical diagnostic classification
models: A family of models for estimating and testing attribute
hierarchies. <em>Psychometrika, 79</em>, 317-339.
</p>
<p>Templin, J., &amp; Hoffman, L. (2013).
Obtaining diagnostic classification model estimates using Mplus.
<em>Educational Measurement: Issues and Practice, 32</em>, 37-50.
</p>


<h3>See Also</h3>

<p><code><a href="GDINA.html#topic+ecpe">GDINA::ecpe</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(data.ecpe, package="CDM")

dat &lt;- data.ecpe$data[,-1]
Q &lt;- data.ecpe$q.matrix

#*** Model 1: LCDM model
mod1 &lt;- CDM::gdina( dat, q.matrix=Q, link="logit")
summary(mod1)

#*** Model 2: DINA model
mod2 &lt;- CDM::gdina( dat, q.matrix=Q, rule="DINA")
summary(mod2)

# Model comparison using likelihood ratio test
anova(mod1,mod2)
  ##       Model   loglike Deviance Npars      AIC      BIC    Chisq df  p
  ##   2 Model 2 -42841.61 85683.23    63 85809.23 86185.97 206.0359 18  0
  ##   1 Model 1 -42738.60 85477.19    81 85639.19 86123.57       NA NA NA

#*** Model 3: Hierarchical LCDM (HLCDM) | Templin and Bradshaw (2014)
#      Testing a linear hierarchy
hier &lt;- "skill3 &gt; skill2 &gt; skill1"
skill.names &lt;- colnames(Q)
# define skill space with hierarchy
skillspace &lt;- CDM::skillspace.hierarchy( hier, skill.names=skill.names )
skillspace$skillspace.reduced
  ##        skill1 skill2 skill3
  ##   A000      0      0      0
  ##   A001      0      0      1
  ##   A011      0      1      1
  ##   A111      1      1      1
zeroprob.skillclasses &lt;- skillspace$zeroprob.skillclasses

# define user-defined parameters in LCDM: hierarchical LCDM (HLCDM)
Mj.user &lt;- mod1$Mj
# select items with require two attributes
items &lt;- which( rowSums(Q) &gt; 1 )
# modify design matrix for item parameters
for (ii in items){
    m1 &lt;- Mj.user[[ii]]
    Mj.user[[ii]][[1]] &lt;- (m1[[1]])[,-2]
    Mj.user[[ii]][[2]] &lt;- (m1[[2]])[-2]
}

# estimate model
#    note that avoid.zeroprobs is set to TRUE to avoid algorithmic instabilities
mod3 &lt;- CDM::gdina( dat, q.matrix=Q, link="logit",
            zeroprob.skillclasses=zeroprob.skillclasses, Mj=Mj.user,
            avoid.zeroprobs=TRUE )
summary(mod3)

#*****************************************
#** estimate further models

#*** Model 4: RRUM model
mod4 &lt;- CDM::gdina( dat, q.matrix=Q, rule="RRUM")
summary(mod4)
# compare some models
IRT.compareModels(mod1, mod2, mod3, mod4 )

#*** Model 5a: GDINA model with identity link
mod5a &lt;- CDM::gdina( dat, q.matrix=Q, link="identity")
summary(mod5a)
#*** Model 5b: GDINA model with logit link
mod5b &lt;- CDM::gdina( dat, q.matrix=Q, link="logit")
summary(mod5b)
#*** Model 5c: GDINA model with log link
mod5c &lt;- CDM::gdina( dat, q.matrix=Q, link="log")
summary(mod5c)
# compare models
IRT.compareModels(mod5a, mod5b, mod5c)

## End(Not run)
</code></pre>

<hr>
<h2 id='data.fraction'>
Fraction Subtraction Dataset with Different Subsets of Data and Different
Q-Matrices
</h2><span id='topic+data.fraction'></span><span id='topic+data.fraction1'></span><span id='topic+data.fraction2'></span><span id='topic+data.fraction3'></span><span id='topic+data.fraction4'></span><span id='topic+data.fraction5'></span>

<h3>Description</h3>

<p>Contains different sub-datasets of the fraction subtraction data of Tatsuoka
with different Q-matrix specifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data.fraction1)
data(data.fraction2)
data(data.fraction3)
data(data.fraction4)
data(data.fraction5)
</code></pre>


<h3>Format</h3>


<ul>
<li><p> The dataset <code>data.fraction1</code> is the fraction subtraction data set with
536 students and 15 items. The Q-matrix was defined in de la Torre (2009).
This dataset is a list with the dataset (<code>data</code>) and
the Q-matrix as entries.
</p>
<p>The format is:
</p>
<p><code>List of 2</code> <br />
<code> $ data    :'data.frame':</code> <br />
<code>  ..$ T01: int [1:536] 0 1 1 1 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ T02: int [1:536] 1 1 1 1 1 0 0 1 0 0 ...</code> <br />
<code>  ..$ T03: int [1:536] 0 1 1 1 1 1 0 0 0 0 ...</code> <br />
<code>  ..$ T04: int [1:536] 1 1 1 0 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ T05: int [1:536] 0 1 0 0 0 1 1 0 1 1 ...</code> <br />
<code>  ..$ T06: int [1:536] 1 1 0 1 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ T07: int [1:536] 1 1 0 1 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ T08: int [1:536] 1 1 0 1 1 0 0 0 1 1 ...</code> <br />
<code>  ..$ T09: int [1:536] 1 1 1 1 0 1 0 0 1 0 ...</code> <br />
<code>  ..$ T10: int [1:536] 1 1 1 0 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ T11: int [1:536] 1 1 1 1 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ T12: int [1:536] 0 1 0 0 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ T13: int [1:536] 1 1 0 1 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ T14: int [1:536] 1 1 0 0 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ T15: int [1:536] 1 1 0 1 0 0 0 0 0 0 ...</code> <br />
<code> $ q.matrix: int [1:15, 1:5] 1 1 1 1 0 1 1 1 1 1 ...</code> <br />
<code>  ..- attr(*, "dimnames")=List of 2</code> <br />
<code>  .. ..$ : chr [1:15] "T01" "T02" "T03" "T04" ...</code> <br />
<code>  .. ..$ : chr [1:5] "QT1" "QT2" "QT3" "QT4" ...</code> <br />
</p>
</li>
<li><p> The dataset <code>data.fraction2</code> is the fraction subtraction data set
with 536 students and 11 items. For this data set, several <code class="reqn">Q</code> matrices are
available. The data is a list. The first entry <code>data</code>
contains the data frame. The entry <code>q.matrix1</code> contains
the Q-matrix of Henson, Templin and Willse (2009).
The third entry <code>q.matrix2</code> is an alternative
Q-matrix of de la Torre (2009). The fourth entry is a
modified Q-matrix of <code>q.matrix1</code>.
</p>
<p>The format is:
</p>
<p><code> $ data     :'data.frame':</code> <br />
<code>  ..$ H01: int [1:536] 1 1 1 1 1 0 0 1 0 0 ...</code> <br />
<code>  ..$ H02: int [1:536] 1 1 1 0 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ H03: int [1:536] 0 1 0 0 0 1 1 0 1 1 ...</code> <br />
<code>  ..$ H04: int [1:536] 1 1 0 1 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ H05: int [1:536] 1 1 0 1 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ H06: int [1:536] 1 1 0 1 1 0 0 0 1 1 ...</code> <br />
<code>  ..$ H08: int [1:536] 1 1 1 0 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ H09: int [1:536] 1 1 1 1 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ H10: int [1:536] 0 1 0 0 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ H11: int [1:536] 1 1 0 1 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ H13: int [1:536] 1 1 0 1 0 0 0 0 0 0 ...</code> <br />
<code> $ q.matrix1: int [1:11, 1:3] 1 1 1 1 1 1 1 1 1 1 ...</code> <br />
<code>  ..- attr(*, "dimnames")=List of 2</code> <br />
<code>  .. ..$ : chr [1:11] "H01" "H02" "H03" "H04" ...</code> <br />
<code>  .. ..$ : chr [1:3] "QH1" "QH2" "QH3"</code> <br />
<code> $ q.matrix2: int [1:11, 1:5] 1 1 0 1 1 1 1 1 1 1 ...</code> <br />
<code>  ..- attr(*, "dimnames")=List of 2</code> <br />
<code>  .. ..$ : chr [1:11] "H01" "H02" "H03" "H04" ...</code> <br />
<code>  .. ..$ : chr [1:5] "QT1" "QT2" "QT3" "QT4" ...</code> <br />
<code> $ q.matrix3: num [1:11, 1:3] 0 0 0 1 0 0 0 0 1 1 ...</code> <br />
<code>  ..- attr(*, "dimnames")=List of 2</code> <br />
<code>  .. ..$ : chr [1:11] "H01" "H02" "H03" "H04" ...</code> <br />
<code>  .. ..$ : chr [1:3] "Dim1" "Dim2" "Dim3"</code> <br />
</p>
</li>
<li><p> The dataset <code>data.fraction3</code> contains 12 items and was
used in de la Torre (2011).
</p>
<p><code>List of 2</code> <br />
<code> $ data    :'data.frame':       536 obs. of  12 variables:</code> <br />
<code>  ..$ B01: int [1:536] 0 1 1 1 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ B02: int [1:536] 1 1 1 1 1 0 0 1 0 0 ...</code> <br />
<code>  ..$ B03: int [1:536] 0 1 1 1 1 1 0 0 0 0 ...</code> <br />
<code>  ..$ B04: int [1:536] 0 1 0 0 0 1 1 0 1 1 ...</code> <br />
<code>  ..$ B05: int [1:536] 1 1 0 1 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ B06: int [1:536] 1 1 0 1 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ B07: int [1:536] 1 1 0 1 1 0 0 0 1 1 ...</code> <br />
<code>  ..$ B08: int [1:536] 1 1 1 1 0 1 0 0 1 0 ...</code> <br />
<code>  ..$ B09: int [1:536] 1 1 1 1 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ B10: int [1:536] 0 1 0 0 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ B11: int [1:536] 1 1 0 1 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ B12: int [1:536] 1 1 0 1 0 0 0 0 0 0 ...</code> <br />
<code> $ q.matrix:'data.frame':       12 obs. of  5 variables:</code> <br />
<code>  ..$ item: Factor w/ 13 levels "","B01","B02",..: 2 3 4 5 6 7 8 9 10 11 ...</code> <br />
<code>  ..$ QA1 : int [1:12] 1 1 1 1 1 1 1 1 1 1 ...</code> <br />
<code>  ..$ QA2 : int [1:12] 0 1 0 0 1 1 1 0 0 0 ...</code> <br />
<code>  ..$ QA3 : int [1:12] 0 1 0 1 1 1 0 1 1 1 ...</code> <br />
<code>  ..$ QA4 : int [1:12] 0 1 0 0 1 1 0 0 0 1 ...</code> <br />
</p>
</li>
<li><p> The dataset <code>data.fraction4</code> contains 17 items and was
used in de la Torre and Douglas (2004) and Chen, Liu, Xu and Ying (2015).
</p>
<p><code>List of 2</code> <br />
<code> $ data    :'data.frame':       536 obs. of  17 variables:</code> <br />
<code>  ..$ A01: int [1:536] 0 0 0 1 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ A02: int [1:536] 0 1 1 1 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ A03: int [1:536] 0 1 1 1 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ A04: int [1:536] 1 1 1 1 1 0 0 1 0 0 ...</code> <br />
<code>  ..$ A05: int [1:536] 1 1 0 1 1 0 0 0 1 1 ...</code> <br />
<code>  ..$ A06: int [1:536] 1 1 1 1 0 1 0 0 1 0 ...</code> <br />
<code>  ..$ A07: int [1:536] 1 1 1 1 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ A08: int [1:536] 0 0 0 1 0 0 0 0 0 1 ...</code> <br />
<code>  ..$ A09: int [1:536] 1 1 1 0 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ A10: int [1:536] 1 1 1 0 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ A11: int [1:536] 1 1 0 1 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ A12: int [1:536] 1 1 0 1 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ A13: int [1:536] 0 1 0 0 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ A14: int [1:536] 1 1 0 1 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ A15: int [1:536] 1 1 0 0 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ A16: int [1:536] 1 1 0 1 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ A17: int [1:536] 0 1 0 0 0 0 0 0 0 0 ...</code> <br />
<code> $ q.matrix:'data.frame':       17 obs. of  9 variables:</code> <br />
<code>  ..$ item: Factor w/ 18 levels "","A01","A02",..: 2 3 4 5 6 7 8 9 10 11 ...</code> <br />
<code>  ..$ QA1 : int [1:17] 0 0 0 0 0 0 0 0 1 0 ...</code> <br />
<code>  ..$ QA2 : int [1:17] 0 0 0 1 0 1 1 1 1 1 ...</code> <br />
<code>  ..$ QA3 : int [1:17] 0 0 0 1 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ QA4 : int [1:17] 1 1 1 0 0 0 0 1 0 0 ...</code> <br />
<code>  ..$ QA5 : int [1:17] 0 0 0 1 0 0 1 0 0 1 ...</code> <br />
<code>  ..$ QA6 : int [1:17] 1 0 0 0 0 0 1 0 0 0 ...</code> <br />
<code>  ..$ QA7 : int [1:17] 1 1 1 1 1 1 1 1 1 1 ...</code> <br />
<code>  ..$ QA8 : int [1:17] 0 0 0 0 1 0 0 1 0 0 ...</code> <br />
</p>
</li>
<li><p> The dataset <code>data.fraction5</code> contains 15 items and was
used as an example for the multiple strategy DINA model in
de la Torre and Douglas (2008) and Hou and de la Torre (2014).
The two Q-matrices for coding the multiple strategies are contained
in one matrix <code>q.matrix</code> by joining the columns of both matrices.
</p>
<p><code>List of 2</code> <br />
<code> $ data    :'data.frame':       536 obs. of  15 variables:</code> <br />
<code>  ..$ T01: int [1:536] 0 1 1 1 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ T02: int [1:536] 1 1 1 1 1 0 0 1 0 0 ...</code> <br />
<code>  ..$ T03: int [1:536] 0 1 1 1 1 1 0 0 0 0 ...</code> <br />
<code>  ..$ T04: int [1:536] 1 1 1 0 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ T05: int [1:536] 0 1 0 0 0 1 1 0 1 1 ...</code> <br />
<code>  ..$ T06: int [1:536] 1 1 0 1 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ T07: int [1:536] 1 1 0 1 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ T08: int [1:536] 1 1 0 1 1 0 0 0 1 1 ...</code> <br />
<code>  ..$ T09: int [1:536] 1 1 1 1 0 1 0 0 1 0 ...</code> <br />
<code>  ..$ T10: int [1:536] 1 1 1 0 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ T11: int [1:536] 1 1 1 1 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ T12: int [1:536] 0 1 0 0 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ T13: int [1:536] 1 1 0 1 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ T14: int [1:536] 1 1 0 0 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ T15: int [1:536] 1 1 0 1 0 0 0 0 0 0 ...</code> <br />
<code> $ q.matrix:'data.frame':       15 obs. of  15 variables:</code> <br />
<code>  ..$ item: Factor w/ 16 levels "","T01","T02",..: 2 3 4 5 6 7 8 9 10 11 ...</code> <br />
<code>  ..$ SA1 : int [1:15] 0 1 1 1 0 1 1 1 1 1 ...</code> <br />
<code>  ..$ SA2 : int [1:15] 0 1 0 1 0 1 1 1 0 0 ...</code> <br />
<code>  ..$ SA3 : int [1:15] 0 1 0 1 1 1 1 0 1 1 ...</code> <br />
<code>  ..$ SA4 : int [1:15] 0 1 0 1 0 1 1 0 0 1 ...</code> <br />
<code>  ..$ SA5 : int [1:15] 0 0 0 1 0 0 0 0 0 1 ...</code> <br />
<code>  ..$ SA6 : int [1:15] 0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ SA7 : int [1:15] 0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ SB1 : int [1:15] 0 1 1 1 0 1 1 1 1 1 ...</code> <br />
<code>  ..$ SB2 : int [1:15] 0 0 0 0 1 1 1 1 0 1 ...</code> <br />
<code>  ..$ SB3 : int [1:15] 0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ SB4 : int [1:15] 0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ SB5 : int [1:15] 0 0 0 1 1 0 0 0 0 1 ...</code> <br />
<code>  ..$ SB6 : int [1:15] 0 1 0 1 1 1 1 0 1 0 ...</code> <br />
<code>  ..$ SB7 : int [1:15] 0 0 0 0 1 0 0 0 0 0 ...</code> <br />
</p>
</li></ul>



<h3>Source</h3>

<p>See <code><a href="#topic+fraction.subtraction.data">fraction.subtraction.data</a></code> for more information
about the data source.
</p>


<h3>References</h3>

<p>Chen, Y., Liu, J., Xu, G. and Ying, Z. (2015).
Statistical analysis of Q-matrix based diagnostic classification models.
<em>Journal of the American Statistical Association, 110</em>(510),
850-866.
</p>
<p>de la Torre, J. (2009). DINA model parameter estimation:
A didactic. <em>Journal of Educational and Behavioral
Statistics, 34</em>, 115-130.
</p>
<p>de la Torre, J. (2011). The generalized DINA model framework.
<em>Psychometrika, 76</em>, 179-199.
</p>
<p>de la Torre, J., &amp; Douglas, J. A. (2004).
Higher-order latent trait models for cognitive diagnosis.
<em>Psychometrika, 69</em>, 333-353.
</p>
<p>de la Torre, J., &amp; Douglas, J. A. (2008).
Model evaluation and multiple strategies in cognitive diagnosis:
An analysis of fraction subtraction data.
<em>Psychometrika, 73</em>, 595-624.
</p>
<p>Henson, R. A., Templin, J. T., &amp; Willse, J. T. (2009).
Defining a family of cognitive diagnosis models using
log-linear models with latent variables.
<em>Psychometrika, 74</em>, 191-210.
</p>
<p>Huo, Y., &amp; de la Torre, J. (2014). Estimating a cognitive diagnostic model for
multiple strategies via the EM algorithm.
<em>Applied Psychological Measurement, 38</em>, 464-485.
</p>


<h3>See Also</h3>

<p><code><a href="GDINA.html#topic+frac20">GDINA::frac20</a></code>
</p>

<hr>
<h2 id='data.hr'>
Dataset <code>data.hr</code> (Ravand et al., 2013)
</h2><span id='topic+data.hr'></span>

<h3>Description</h3>

<p>Dataset <code>data.hr</code> used for illustrating some functionalities
of the <span class="pkg">CDM</span> package (Ravand, Barati, &amp; Widhiarso, 2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data.hr)
</code></pre>


<h3>Format</h3>

<p>The format of the dataset is:
</p>
<p><code>List of 2</code> <br />
<code> $ data    : num [1:1550, 1:35] 1 0 1 1 1 0 1 1 1 0 ...</code> <br />
<code> $ q.matrix:'data.frame':</code> <br />
<code>  ..$ Skill1: int [1:35] 0 0 0 0 0 0 1 0 0 0 ...</code> <br />
<code>  ..$ Skill2: int [1:35] 0 0 0 0 1 0 0 0 0 0 ...</code> <br />
<code>  ..$ Skill3: int [1:35] 0 1 1 1 1 0 0 1 0 0 ...</code> <br />
<code>  ..$ Skill4: int [1:35] 1 0 0 0 0 0 0 0 1 1 ...</code> <br />
<code>  ..$ Skill5: int [1:35] 0 0 0 0 0 1 0 0 1 1 ...</code> <br />
</p>


<h3>Source</h3>

<p>Simulated data according to Ravand et al. (2013).
</p>


<h3>References</h3>

<p>Ravand, H., Barati, H., &amp; Widhiarso, W. (2013). Exploring diagnostic capacity
of a high stakes reading comprehension test: A pedagogical demonstration.
<em>Iranian Journal of Language Testing, 3</em>(1), 1-27.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(data.hr, package="CDM")

dat &lt;- data.hr$data
Q &lt;- data.hr$q.matrix

#*************
# Model 1: DINA model
mod1 &lt;- CDM::din( dat, q.matrix=Q )
summary(mod1)       # summary

# plot results
plot(mod1)

# inspect coefficients
coef(mod1)

# posterior distribution
posterior &lt;- mod1$posterior
round( posterior[ 1:5, ], 4 )  # first 5 entries

# estimate class probabilities
mod1$attribute.patt

# individual classifications
mod1$pattern[1:5,]   # first 5 entries

#*************
# Model 2: GDINA model
mod2 &lt;- CDM::gdina( dat, q.matrix=Q)
summary(mod2)

#*************
# Model 3: Reduced RUM model
mod3 &lt;- CDM::gdina( dat, q.matrix=Q, rule="RRUM" )
summary(mod3)

#--------
# model comparisons

# DINA vs GDINA
anova( mod1, mod2 )
  ##       Model   loglike Deviance Npars      AIC      BIC    Chisq df  p
  ##   1 Model 1 -31391.27 62782.54   101 62984.54 63524.49 195.9099 20  0
  ##   2 Model 2 -31293.32 62586.63   121 62828.63 63475.50       NA NA NA

# RRUM vs. GDINA
anova( mod2, mod3 )
  ##       Model   loglike Deviance Npars      AIC      BIC    Chisq df  p
  ##   2 Model 2 -31356.22 62712.43   105 62922.43 63483.76 125.7924 16  0
  ##   1 Model 1 -31293.32 62586.64   121 62828.64 63475.50       NA NA NA

# DINA vs. RRUM
anova(mod1,mod3)
  ##       Model   loglike Deviance Npars      AIC      BIC    Chisq df  p
  ##   1 Model 1 -31391.27 62782.54   101 62984.54 63524.49 70.11246  4  0
  ##   2 Model 2 -31356.22 62712.43   105 62922.43 63483.76       NA NA NA

#-------
# model fit

# DINA
fmod1 &lt;- CDM::modelfit.cor.din( mod1, jkunits=0)
summary(fmod1)
  ##   Test of Global Model Fit
  ##          type    value       p
  ##   1   max(X2) 16.35495 0.03125
  ##   2 abs(fcor)  0.10341 0.01416
  ##
  ##   Fit Statistics
  ##                       est
  ##   MADcor          0.01911
  ##   SRMSR           0.02445
  ##   MX2             0.93157
  ##   100*MADRESIDCOV 0.39100
  ##   MADQ3           0.02373

# GDINA
fmod2 &lt;- CDM::modelfit.cor.din( mod2, jkunits=0)
summary(fmod2)
  ##   Test of Global Model Fit
  ##          type   value p
  ##   1   max(X2) 7.73670 1
  ##   2 abs(fcor) 0.07215 1
  ##
  ##   Fit Statistics
  ##                       est
  ##   MADcor          0.01830
  ##   SRMSR           0.02300
  ##   MX2             0.82584
  ##   100*MADRESIDCOV 0.37390
  ##   MADQ3           0.02383

# RRUM
fmod3 &lt;- CDM::modelfit.cor.din( mod3, jkunits=0)
summary(fmod3)
  ##   Test of Global Model Fit
  ##          type    value       p
  ##   1   max(X2) 15.49369 0.04925
  ##   2 abs(fcor)  0.10076 0.02201
  ##
  ##   Fit Statistics
  ##                       est
  ##   MADcor          0.01868
  ##   SRMSR           0.02374
  ##   MX2             0.87999
  ##   100*MADRESIDCOV 0.38409
  ##   MADQ3           0.02416

## End(Not run)
</code></pre>

<hr>
<h2 id='data.jang'>
Dataset Jang (2009)
</h2><span id='topic+data.jang'></span>

<h3>Description</h3>

<p>Simulated dataset according to the Jang (2005) L2 reading comprehension
study.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data.jang)
</code></pre>


<h3>Format</h3>

<p>The format is:
</p>
<p><code>List of 2</code> <br />
<code> $ data    : num [1:1500, 1:37] 1 1 1 1 1 1 1 1 1 1 ...</code> <br />
<code>  ..- attr(*, "dimnames")=List of 2</code> <br />
<code>  .. ..$ : NULL</code> <br />
<code>  .. ..$ : chr [1:37] "I1" "I2" "I3" "I4" ...</code> <br />
<code> $ q.matrix:'data.frame':</code> <br />
<code>  ..$ CDV: int [1:37] 1 0 0 1 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ CIV: int [1:37] 0 0 1 0 0 0 1 0 1 1 ...</code> <br />
<code>  ..$ SSL: int [1:37] 1 1 1 1 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ TEI: int [1:37] 0 0 0 0 0 0 0 1 0 0 ...</code> <br />
<code>  ..$ TIM: int [1:37] 0 0 0 1 1 1 0 0 0 0 ...</code> <br />
<code>  ..$ INF: int [1:37] 0 1 0 0 0 0 1 0 0 0 ...</code> <br />
<code>  ..$ NEG: int [1:37] 0 0 0 0 1 0 1 0 0 0 ...</code> <br />
<code>  ..$ SUM: int [1:37] 0 0 0 0 1 0 0 0 0 0 ...</code> <br />
<code>  ..$ MCF: int [1:37] 0 0 0 0 0 0 0 0 0 0 ...</code> <br />
</p>


<h3>Source</h3>

<p>Simulated dataset.
</p>


<h3>References</h3>

<p>Jang, E. E. (2009). Cognitive diagnostic assessment of L2 reading comprehension
ability: Validity arguments for Fusion Model application to LanguEdge assessment.
<em>Language Testing, 26</em>, 31-73.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(data.jang, package="CDM")

data &lt;- data.jang$data
q.matrix &lt;- data.jang$q.matrix

#*** Model 1: Reduced RUM model
mod1 &lt;- CDM::gdina( data, q.matrix, rule="RRUM", conv.crit=.001, increment.factor=1.025 )
summary(mod1)

#*** Model 2: Additive model (identity link)
mod2 &lt;- CDM::gdina( data, q.matrix, rule="ACDM", conv.crit=.001, linkfct="identity" )
summary(mod2)

#*** Model 3: DINA model
mod3 &lt;- CDM::gdina( data, q.matrix, rule="DINA", conv.crit=.001 )
summary(mod3)

anova(mod1,mod2)
  ##       Model   loglike Deviance Npars      AIC      BIC    Chisq df  p
  ##   1 Model 1 -30315.03 60630.06   153 60936.06 61748.98 88.29627  0  0
  ##   2 Model 2 -30270.88 60541.76   153 60847.76 61660.68       NA NA NA
anova(mod1,mod3)
  ##       Model   loglike Deviance Npars      AIC      BIC    Chisq df  p
  ##   2 Model 2 -30373.99 60747.97   129 61005.97 61691.38 117.9128 24  0
  ##   1 Model 1 -30315.03 60630.06   153 60936.06 61748.98       NA NA NA

# RRUM
summary( CDM::modelfit.cor.din( mod1, jkunits=0) )
  ##          type    value       p
  ##   1   max(X2) 11.79073 0.39645
  ##   2 abs(fcor)  0.09541 0.07422
  ##                       est
  ##   MADcor          0.01834
  ##   SRMSR           0.02300
  ##   MX2             0.86718
  ##   100*MADRESIDCOV 0.38690
  ##   MADQ3           0.02413

# additive model (identity)
summary( CDM::modelfit.cor.din( mod2, jkunits=0) )
  ##          type   value       p
  ##   1   max(X2) 9.78958 1.00000
  ##   2 abs(fcor) 0.08770 0.22993
  ##                       est
  ##   MADcor          0.01721
  ##   SRMSR           0.02158
  ##   MX2             0.69163
  ##   100*MADRESIDCOV 0.36343
  ##   MADQ3           0.02423

# DINA model
summary( CDM::modelfit.cor.din( mod3, jkunits=0) )
  ##          type    value       p
  ##   1   max(X2) 13.48449 0.16020
  ##   2 abs(fcor)  0.10651 0.01256
  ##                       est
  ##   MADcor          0.01999
  ##   SRMSR           0.02495
  ##   MX2             0.92820
  ##   100*MADRESIDCOV 0.42226
  ##   MADQ3           0.02258

## End(Not run)
</code></pre>

<hr>
<h2 id='data.melab'>
MELAB Data (Li, 2011)
</h2><span id='topic+data.melab'></span>

<h3>Description</h3>

<p>This is a simulated dataset according to the MELAB reading
study (Li, 2011; Li &amp; Suen, 2013). Li (2011) investigated the Fusion
model (RUM model) for calibrating this dataset. The dataset in this package
is simulated assuming the reduced RUM model (RRUM).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data.melab)
</code></pre>


<h3>Format</h3>

<p>The format of the dataset is:
</p>
<p><code>List of 3</code> <br />
<code> $ data        : num [1:2019, 1:20] 0 1 0 1 1 0 0 0 1 1 ...</code> <br />
<code>  ..- attr(*, "dimnames")=List of 2</code> <br />
<code>  .. ..$ : NULL</code> <br />
<code>  .. ..$ : chr [1:20] "I1" "I2" "I3" "I4" ...</code> <br />
<code> $ q.matrix    :'data.frame':</code> <br />
<code>  ..$ skill1: int [1:20] 1 1 0 0 1 1 0 1 0 1 ...</code> <br />
<code>  ..$ skill2: int [1:20] 0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ skill3: int [1:20] 0 0 0 1 0 1 1 0 1 0 ...</code> <br />
<code>  ..$ skill4: int [1:20] 1 0 1 0 1 0 0 1 0 1 ...</code> <br />
<code> $ skill.labels:'data.frame':</code> <br />
<code>  ..$ skill      : Factor w/ 4 levels "skill1","skill2",..: 1 2 3 4</code> <br />
<code>  ..$ skill.label: Factor w/ 4 levels "connecting and synthesizing",..: 4 3 2 1</code> <br />
</p>


<h3>Source</h3>

<p>Simulated data according to Li (2011).
</p>


<h3>References</h3>

<p>Li, H. (2011). A cognitive diagnostic analysis of the MELAB reading test.
<em>Spaan Fellow, 9</em>, 17-46.
</p>
<p>Li, H., &amp; Suen, H. K. (2013). Constructing and validating a Q-matrix for
cognitive diagnostic analyses of a reading test.
<em>Educational Assessment, 18</em>, 1-25.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(data.melab, package="CDM")

data &lt;- data.melab$data
q.matrix &lt;- data.melab$q.matrix

#*** Model 1: Reduced RUM model
mod1 &lt;- CDM::gdina( data, q.matrix, rule="RRUM" )
summary(mod1)

#*** Model 2: GDINA model
mod2 &lt;- CDM::gdina( data, q.matrix, rule="GDINA" )
summary(mod2)

#*** Model 3: DINA model
mod3 &lt;- CDM::gdina( data, q.matrix, rule="DINA" )
summary(mod3)

#*** Model 4: 2PL model
mod4 &lt;- CDM::gdm( data, theta.k=seq(-6,6,len=21), center )
summary(mod4)

#----
# Model comparisons

#*** RRUM vs. GDINA
anova(mod1,mod2)
  ##       Model   loglike Deviance Npars      AIC      BIC    Chisq df       p
  ##   1 Model 1 -20252.74 40505.48    69 40643.48 41030.60 30.88801 18 0.02966
  ##   2 Model 2 -20237.30 40474.59    87 40648.59 41136.69       NA NA      NA

  ##  -&gt; GDINA is not superior to RRUM (according to AIC and BIC)

#*** DINA vs. RRUM
anova(mod1,mod3)
  ##       Model   loglike Deviance Npars      AIC      BIC    Chisq df  p
  ##   2 Model 2 -20332.52 40665.04    55 40775.04 41083.61 159.5566 14  0
  ##   1 Model 1 -20252.74 40505.48    69 40643.48 41030.60       NA NA NA

  ##  -&gt; RRUM fits the data significantly better than the DINA model

#*** RRUM vs. 2PL (use only AIC and BIC for comparison)
anova(mod1,mod4)
  ##       Model   loglike Deviance Npars      AIC      BIC    Chisq df  p
  ##   2 Model 2 -20390.19 40780.38    43 40866.38 41107.62 274.8962 26  0
  ##   1 Model 1 -20252.74 40505.48    69 40643.48 41030.60       NA NA NA

  ## -&gt; RRUM fits the data better than 2PL

#----
# Model fit statistics

# RRUM
fmod1 &lt;- CDM::modelfit.cor.din( mod1, jkunits=0)
summary(fmod1)
  ##   Test of Global Model Fit
  ##          type    value       p
  ##   1   max(X2) 10.10408 0.28109
  ##   2 abs(fcor)  0.06726 0.24023
  ##
  ##   Fit Statistics
  ##                       est
  ##   MADcor          0.01708
  ##   SRMSR           0.02158
  ##   MX2             0.96590
  ##   100*MADRESIDCOV 0.27269
  ##   MADQ3           0.02781

  ##  -&gt; not a significant misfit of the RRUM model

# GDINA
fmod2 &lt;- CDM::modelfit.cor.din( mod2, jkunits=0)
summary(fmod2)
  ##   Test of Global Model Fit
  ##          type    value       p
  ##   1   max(X2) 10.40294 0.23905
  ##   2 abs(fcor)  0.06817 0.20964
  ##
  ##   Fit Statistics
  ##                       est
  ##   MADcor          0.01703
  ##   SRMSR           0.02151
  ##   MX2             0.94468
  ##   100*MADRESIDCOV 0.27105
  ##   MADQ3           0.02713

## End(Not run)
</code></pre>

<hr>
<h2 id='data.mg'>
Large-Scale Dataset with Multiple Groups
</h2><span id='topic+data.mg'></span>

<h3>Description</h3>

<p>Large-scale dataset with multiple groups, survey weights and 11 polytomous
items.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data.mg)</code></pre>


<h3>Format</h3>

<p>A data frame with 38243 observations on the following 14 variables.
</p>

<dl>
<dt><code>idstud</code></dt><dd><p>Student identifier</p>
</dd>
<dt><code>group</code></dt><dd><p>Group identifier</p>
</dd>
<dt><code>weight</code></dt><dd><p>Survey weight</p>
</dd>
<dt><code>I1</code></dt><dd><p>Item 1</p>
</dd>
<dt><code>I2</code></dt><dd><p>Item 2</p>
</dd>
<dt><code>I3</code></dt><dd><p>Item 3</p>
</dd>
<dt><code>I4</code></dt><dd><p>Item 4</p>
</dd>
<dt><code>I5</code></dt><dd><p>Item 5</p>
</dd>
<dt><code>I6</code></dt><dd><p>Item 6</p>
</dd>
<dt><code>I7</code></dt><dd><p>Item 7</p>
</dd>
<dt><code>I8</code></dt><dd><p>Item 8</p>
</dd>
<dt><code>I9</code></dt><dd><p>Item 9</p>
</dd>
<dt><code>I10</code></dt><dd><p>Item 10</p>
</dd>
<dt><code>I11</code></dt><dd><p>Item 11</p>
</dd>
</dl>



<h3>Source</h3>

<p>Subsample of a large-scale dataset of 11 survey questions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(psych)
data(dat.mg, package="CDM")
psych::describe( data.mg )
  ##   &gt; psych::describe(data.mg)
  ##          var     n       mean       sd     median    trimmed      mad        min        max
  ##   idstud   1 38243 1039653.91 19309.80 1037899.00 1039927.73 30240.59 1007168.00 1069949.00
  ##   group    2 38243       8.06     4.07       7.00       8.06     5.93       2.00      14.00
  ##   weight   3 38243      28.76    19.25      31.88      27.92    19.12       0.79     191.89
  ##   I1       4 37665       0.88     0.32       1.00       0.98     0.00       0.00       1.00
  ##   I2       5 37639       0.93     0.25       1.00       1.00     0.00       0.00       1.00
  ##   I3       6 37473       0.76     0.43       1.00       0.83     0.00       0.00       1.00
  ##   I4       7 37687       1.88     0.39       2.00       2.00     0.00       0.00       2.00
  ##   I5       8 37638       1.36     0.75       2.00       1.44     0.00       0.00       2.00
  ##   I6       9 37587       1.05     0.82       1.00       1.06     1.48       0.00       2.00
  ##   I7      10 37576       1.55     0.85       2.00       1.57     1.48       0.00       3.00
  ##   I8      11 37044       0.45     0.50       0.00       0.44     0.00       0.00       1.00
  ##   I9      12 37249       0.48     0.50       0.00       0.47     0.00       0.00       1.00
  ##   I10     13 37318       0.63     0.48       1.00       0.66     0.00       0.00       1.00
  ##   I11     14 37412       1.35     0.80       1.00       1.35     1.48       0.00       3.00

## End(Not run)
</code></pre>

<hr>
<h2 id='data.pgdina'>
Dataset for Polytomous GDINA Model
</h2><span id='topic+data.pgdina'></span>

<h3>Description</h3>

<p>Dataset for the estimation of the polytomous GDINA model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data.pgdina)</code></pre>


<h3>Format</h3>

<p>The dataset is a list with the item response data and the Q-matrix.
The format is:
</p>
<p><code>List of 2</code> <br />
<code> $ dat     : num [1:1000, 1:30] 1 1 1 1 1 0 1 1 1 1 ...</code> <br />
<code>  ..- attr(*, "dimnames")=List of 2</code> <br />
<code>  .. ..$ : NULL</code> <br />
<code>  .. ..$ : chr [1:30] "I1" "I2" "I3" "I4" ...</code> <br />
<code> $ q.matrix: num [1:30, 1:5] 1 0 0 0 0 1 0 0 0 2 ...</code> <br />
</p>


<h3>Details</h3>

<p>The dataset was simulated by the following <span class="rlang"><b>R</b></span> code:
</p>
<p><code>set.seed(89)</code> <br />
<code># define Q-matrix</code> <br />
<code>Qmatrix &lt;- matrix(c(1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,</code> <br />
<code>    1,1,2,0,0,0,0,1,2,0,0,0,0,1,2,0,0,0,0,1,1,2,0,0,0,1,2,2,0,1,0,2,</code> <br />
<code>    1,0,0,1,1,0,2,2,0,0,2,1,0,1,0,0,2,2,1,2,0,0,0,0,0,2,0,0,0,0,0,2,</code> <br />
<code>    0,0,0,0,0,2,0,0,0,0,0,1,2,0,2,0,0,0,2,0,2,0,0,0,2,0,1,2,0,0,2,0,</code> <br />
<code>    0,2,0,0,1,1,0,0,1,1,0,1,1,1,0,1,1,1,0,0,0,1,0,1,1,1,0,1,0,1), </code> <br />
<code>    nrow=30, ncol=5, byrow=TRUE )</code> <br />
<code># define covariance matrix between attributes</code> <br />
<code>Sigma &lt;- matrix(c(1,.6,.6,.3,.3,.6,1,.6,.3,.3,.6,.6,1,</code> <br />
<code>        .3,.3,.3,.3,.3,1,.8,.3,.3,.3,.8,1), 5,5, byrow=TRUE )</code> <br />
<code># define thresholds for attributes</code> <br />
<code>q1 &lt;- c( -.5, .9 )  # attributes 1,...,4</code> <br />
<code>q2 &lt;- c(0)           # attribute 5</code> <br />
<code># number of persons</code> <br />
<code>N &lt;- 1000</code> <br />
<code># simulate latent attributes</code> <br />
<code>alpha1 &lt;- mvrnorm(n=N,  mu=rep(0,5), Sigma=Sigma)</code> <br />
<code>alpha &lt;- 0*alpha1</code> <br />
<code>for (aa in 1:4){</code> <br />
<code>   alpha[ alpha1[,aa] &gt; q1[1], aa ] &lt;- 1</code> <br />
<code>   alpha[ alpha1[,aa] &gt; q1[2], aa ] &lt;- 2</code> <br />
<code>               }</code> <br />
<code>aa &lt;- 5 ; alpha[ alpha1[,aa] &gt; q2[1], aa ] &lt;- 1</code> <br />
<code># define item parameters</code> <br />
<code>guess &lt;- c(.07,.01,.34,.07,.11,.23,.27,.07,.08,.34,.19,.19,.25,.04,.34,</code> <br />
<code>        .03,.29,.05,.01,.17,.15,.35,.19,.16,.08,.18,.19,.07,.17,.34)</code> <br />
<code>slip &lt;- c(0,.11,.14,.09,.03,.09,.03,.1,.14,.07,.06,.19,.09,.19,.07,.08,</code> <br />
<code>        .16,.18,.16,.02,.11,.12,.16,.14,.18,.01,.18,.14,.05,.18)</code> <br />
<code># simulate item responses</code> <br />
<code>I &lt;- 30     # number of items</code> <br />
<code>dat &lt;- latresp &lt;- matrix( 0, N, I, byrow=TRUE)</code> <br />
<code>for (ii in 1:I){</code> <br />
<code>#    ii &lt;- 2</code> <br />
<code>    # latent response matrix</code> <br />
<code>    latresp[,ii] &lt;- 1*( rowMeans( alpha &gt;=matrix( Qmatrix[ ii, ], nrow=N, </code> <br />
<code>                ncol=5, byrow=TRUE ) )==1 )</code> <br />
<code>    # response probability</code> <br />
<code>    prob &lt;- ifelse( latresp[,ii]==1, 1-slip[ii], guess[ii] )</code> <br />
<code>    # simulate item responses</code> <br />
<code>    dat[,ii] &lt;- 1 * ( runif(N ) &lt; prob )</code> <br />
<code>                }</code> <br />
<code>colnames(dat) &lt;- paste0("I",1:I)</code> <br />
</p>


<h3>References</h3>

<p>Chen, J., &amp; de la Torre, J. (2013).
A general cognitive diagnosis model for expert-defined polytomous attributes.
<em>Applied Psychological Measurement, 37</em>, 419-437.
</p>

<hr>
<h2 id='data.pisa00R'>
PISA 2000 Reading Study (Chen &amp; de la Torre, 2014)
</h2><span id='topic+data.pisa00R.ct'></span><span id='topic+data.pisa00R.cc'></span>

<h3>Description</h3>

<p>This is a sub-dataset of the PISA 2000 of German students
including 26 items of the reading test. The 26 items was analyzed in
Chen and de la Torre (2014) and a subset of 20 items was
analyzed in Chen and Chen (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data.pisa00R.ct)
data(data.pisa00R.cc)
</code></pre>


<h3>Format</h3>


<ul>
<li><p> The format of the dataset <code>data.pisa00R.ct</code>
(Chen &amp; de la Torre, 2014) is:
</p>
<p><code>List of 3</code> <br />
<code> $ data    :'data.frame':       1095 obs. of  111 variables:</code> <br />
<code>  .. [list output truncated]</code> <br />
<code> $ q.matrix: num [1:26, 1:8] 0 1 0 0 0 1 0 0 0 1 ...</code> <br />
<code>  ..- attr(*, "dimnames")=List of 2</code> <br />
<code> $ skills  : chr [1:8] "Locating information"  ...</code> <br />
</p>
</li>
<li><p> The format of the dataset <code>data.pisa00R.cc</code>
(Q-matrix in Chen and Chen, 2016)
</p>
<p><code>List of 2</code> <br />
<code> $ q.matrix:'data.frame':       20 obs. of  5 variables:</code> <br />
<code>  ..$ A1: num [1:20] 1 1 0 0 1 1 1 0 0 0 ...</code> <br />
<code>  ..$ A2: num [1:20] 0 0 0 1 0 1 1 1 1 1 ...</code> <br />
<code>  ..$ A3: num [1:20] 1 1 0 1 1 0 1 0 1 0 ...</code> <br />
<code>  ..$ A4: num [1:20] 0 1 1 1 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ A5: num [1:20] 0 0 1 0 0 0 0 1 0 1 ...</code> <br />
<code> $ skills  : Named chr [1:5] "Identifying Explicit Information"  ...</code> <br />
<code>  ..- attr(*, "names")=chr [1:5] "A1" "A2" "A3" "A4" ...</code> <br />
</p>
</li></ul>



<h3>References</h3>

<p>Chen, H., &amp; Chen, J. (2016). Exploring reading comprehension skill
relationships through the G-DINA model.
<em>Educational Psychology, 36</em>(6), 1049-1064.
</p>
<p>Chen, J., &amp; de la Torre, J. (2014). A procedure for diagnostically modeling
extant large-scale assessment data: the case of the programme for international
student assessment in reading. <em>Psychology, 5</em>(18), 1967-1978.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: PISA items from Chen and de la Torre (2014)
#            dichotomize item responses
#############################################################################

data(data.pisa00R.ct, package="CDM")
dat &lt;- data.pisa00R.ct$data
Q &lt;- data.pisa00R.ct$q.matrix
resp &lt;- dat[, rownames(Q)]

#** extract item-wise maximum
maxK &lt;- apply( resp, 2, max, na.rm=TRUE )
#** dichotomize response data
resp1 &lt;- resp
for (ii in seq(1,ncol(resp)) ){
    resp1[,ii] &lt;- 1 * ( resp[,ii]==maxK[ii] )
}
</code></pre>

<hr>
<h2 id='data.sda6'>
Dataset SDA6 (Jurich &amp; Bradshaw, 2014)
</h2><span id='topic+data.sda6'></span>

<h3>Description</h3>

<p>This is a simulated dataset of the SDA6 study according to informations
given in Jurich and Bradshaw (2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data.sda6)
</code></pre>


<h3>Format</h3>

<p>The datasets contains 17 items observed at 1710 students.
</p>
<p>The format is:
</p>
<p><code>List of 2</code> <br />
<code> $ data    : num [1:1710, 1:17] 0 1 0 1 0 0 0 0 1 0 ...</code> <br />
<code>  ..- attr(*, "dimnames")=List of 2</code> <br />
<code>  .. ..$ : NULL</code> <br />
<code>  .. ..$ : chr [1:17] "MCM01" "MCM03" "MCM13" "MCM17" ...</code> <br />
<code> $ q.matrix:'data.frame':</code> <br />
<code>  ..$ CM: int [1:17] 1 1 1 1 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ II: int [1:17] 0 0 0 0 1 1 1 1 0 0 ...</code> <br />
<code>  ..$ PP: int [1:17] 0 0 0 0 0 0 0 0 1 1 ...</code> <br />
<code>  ..$ DG: int [1:17] 0 0 0 0 0 0 0 0 0 0 ...</code> <br />
</p>
<p>The meaning of the skills is
</p>
<p><code>CM</code> &ndash; Critique Methods
</p>
<p><code>II</code> &ndash; Identify Improvements
</p>
<p><code>PP</code> &ndash; Protect Participants
</p>
<p><code>DG</code> &ndash; Discern Generalizability
</p>


<h3>Source</h3>

<p>Simulated data
</p>


<h3>References</h3>

<p>Jurich, D. P., &amp; Bradshaw, L. P. (2014). An illustration of diagnostic
classification modeling in student learning outcomes assessment.
<em>International Journal of Testing, 14</em>, 49-72.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(data.sda6, package="CDM")

data &lt;- data.sda6$data
q.matrix &lt;- data.sda6$q.matrix

#*** Model 1a: LCDM with gdina
mod1a &lt;- CDM::gdina( data, q.matrix, rule="ACDM", linkfct="logit",
                  reduced.skillspace=FALSE )
summary(mod1a)

#*** Model 1b: estimate LCDM with gdm
mod1b &lt;- CDM::gdm( data, q.matrix=q.matrix, theta.k=c(0,1) )
summary(mod1b)

#*** Model 2: LCDM with hierarchy II &gt; CM
B &lt;- "II &gt; CM"
ss2 &lt;- CDM::skillspace.hierarchy(B=B, skill.names=colnames(q.matrix ) )
mod2 &lt;- CDM::gdina( data, q.matrix, rule="ACDM", linkfct="logit",
                skillclasses=ss2$skillspace.reduced,
                reduced.skillspace=FALSE )
summary(mod2)

#*** Model 3: LCDM with hierarchy II &gt; CM and DG &gt; CM
B &lt;- "II &gt; CM
      DG &gt; CM"
ss2 &lt;- CDM::skillspace.hierarchy(B=B, skill.names=colnames(q.matrix ) )
mod3 &lt;- CDM::gdina( data, q.matrix, rule="ACDM", linkfct="logit",
               skillclasses=ss2$skillspace.reduced,
               reduced.skillspace=FALSE )
summary(mod3)

# model comparisons
anova(mod1a,mod2)
anova(mod1a,mod3)
# model fit
summary( CDM::modelfit.cor.din(mod1a))
summary( CDM::modelfit.cor.din(mod2) )
summary( CDM::modelfit.cor.din(mod3) )

## End(Not run)
</code></pre>

<hr>
<h2 id='data.Students'>
Dataset Student Questionnaire
</h2><span id='topic+data.Students'></span>

<h3>Description</h3>

<p>This dataset contains item responses of students at
a scale of cultural activities (<code>act</code>),
mathematics self concept (<code>sc</code>) and
mathematics joyment (<code>mj</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data.Students)</code></pre>


<h3>Format</h3>

<p>A data frame with 2400 observations on the following 15 variables.
</p>

<dl>
<dt><code>urban</code></dt><dd><p>Urbanization level: 1=town, 0=otherwise</p>
</dd>
<dt><code>female</code></dt><dd><p>A dummy variable for female student</p>
</dd>
<dt><code>act1</code></dt><dd><p>Visit a museum (0=never, 1=once or twice a year,
2=more than twice a year)</p>
</dd>
<dt><code>act2</code></dt><dd><p>Visit a theater or classical concert (0,1,2)</p>
</dd>
<dt><code>act3</code></dt><dd><p>Visit a rock or pop concert (0,1,2)</p>
</dd>
<dt><code>act4</code></dt><dd><p>Visit a cinema (0,1,2)</p>
</dd>
<dt><code>act5</code></dt><dd><p>Visit a public library (0,1,2)</p>
</dd>
<dt><code>sc1</code></dt><dd><p>Item 1 self concept &quot;I am usually good at math.&quot;
(0=do not agree at all,
1=rather do not agree, 2=rather agree, 3=completely agree)</p>
</dd>
<dt><code>sc2</code></dt><dd><p>Item 2 self concept: &quot;Mathematics is harder for me than many of my
classmates.&quot; (0,1,2,3) (reversed)</p>
</dd>
<dt><code>sc3</code></dt><dd><p>Item 3 self concept: &quot;I am just not good at math.&quot;
(0,1,2,3) (reversed)</p>
</dd>
<dt><code>sc4</code></dt><dd><p>Item 4 self concept: &quot;I'm learning fast in math.&quot; (0,1,2,3)</p>
</dd>
<dt><code>mj1</code></dt><dd><p>Item 1 mathematics joyment:
&quot;I would like more math at school.&quot; (0,1,2,3)</p>
</dd>
<dt><code>mj2</code></dt><dd><p>Item 2 mathematics joyment:
&quot;I like to learn mathematics.&quot; (0,1,2,3)</p>
</dd>
<dt><code>mj3</code></dt><dd><p>Item 3 mathematics joyment:
&quot;Math is boring.&quot; (0,1,2,3) (reversed)</p>
</dd>
<dt><code>mj4</code></dt><dd><p>Item 4 mathematics joyment: &quot;I like math.&quot; (0,1,2,3)</p>
</dd>
</dl>



<h3>Source</h3>

<p>Subsample of students from an Austrian survey
of 8th grade students.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(psych)
data(data.Students, package="CDM")
psych::describe(data.Students)
  ##          var    n mean   sd median trimmed  mad min max range  skew kurtosis   se
  ##   urban    1 2400 0.31 0.46    0.0    0.27 0.00   0   1     1  0.81    -1.34 0.01
  ##   female   2 2400 0.51 0.50    1.0    0.51 0.00   0   1     1 -0.03    -2.00 0.01
  ##   act1     3 2248 0.65 0.73    0.5    0.56 0.74   0   2     2  0.64    -0.88 0.02
  ##   act2     4 2230 0.47 0.69    0.0    0.34 0.00   0   2     2  1.13    -0.06 0.01
  ##   act3     5 2218 0.33 0.60    0.0    0.21 0.00   0   2     2  1.62     1.48 0.01
  ##   act4     6 2342 1.35 0.76    2.0    1.44 0.00   0   2     2 -0.69    -0.96 0.02
  ##   act5     7 2223 0.52 0.74    0.0    0.40 0.00   0   2     2  1.05    -0.41 0.02
  ##   sc1      8 2352 0.96 0.80    1.0    0.91 1.48   0   3     3  0.45    -0.39 0.02
  ##   sc2      9 2347 0.90 0.88    1.0    0.81 1.48   0   3     3  0.66    -0.41 0.02
  ##   sc3     10 2335 0.86 0.96    1.0    0.73 1.48   0   3     3  0.84    -0.35 0.02
  ##   sc4     11 2337 1.29 0.90    1.0    1.24 1.48   0   3     3  0.24    -0.71 0.02
  ##   mj1     12 2351 2.26 0.82    2.0    2.37 1.48   0   3     3 -0.94     0.28 0.02
  ##   mj2     13 2345 1.89 0.91    2.0    1.95 1.48   0   3     3 -0.35    -0.80 0.02
  ##   mj3     14 2334 1.47 1.02    1.0    1.47 1.48   0   3     3  0.10    -1.11 0.02
  ##   mj4     15 2346 1.59 0.99    2.0    1.62 1.48   0   3     3 -0.03    -1.06 0.02

## End(Not run)
</code></pre>

<hr>
<h2 id='data.timss03.G8.su'>
TIMSS 2003 Mathematics 8th Grade (Su et al., 2013)
</h2><span id='topic+data.timss03.G8.su'></span>

<h3>Description</h3>

<p>This is a dataset with a subset of 23 Mathematics items from TIMSS 2003 items
used in Su, Choi, Lee, Choi and McAninch (2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data.timss03.G8.su)
</code></pre>


<h3>Format</h3>

<p>The data contains scored item responses (<code>data</code>),
the Q-matrix (<code>q.matrix</code>) and further item informations (<code>iteminfo</code>).
</p>
<p>The format is
</p>
<p><code>List of 3</code> <br />
<code> $ data    :'data.frame':</code> <br />
<code>  ..$ idstud  : num [1:757] 1e+07 1e+07 1e+07 1e+07 1e+07 ...</code> <br />
<code>  ..$ idbook  : num [1:757] 1 1 1 1 1 1 1 1 1 1 ...</code> <br />
<code>  ..$ M012001 : num [1:757] 0 1 0 0 1 0 1 0 0 0 ...</code> <br />
<code>  ..$ M012002 : num [1:757] 1 1 0 1 0 0 1 1 1 1 ...</code> <br />
<code>  ..$ M012004 : num [1:757] 0 1 1 1 1 0 1 1 0 0 ...</code> <br />
<code>   [...]</code> <br />
<code>  ..$ M022234B: num [1:757] 0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ M022251 : num [1:757] 0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ M032570 : num [1:757] 1 1 0 1 0 0 1 1 1 1 ...</code> <br />
<code>  ..$ M032643 : num [1:757] 1 0 0 0 0 0 1 1 0 0 ...</code> <br />
<code> $ q.matrix: int [1:23, 1:13] 1 0 0 0 0 0 1 0 0 0 ...</code> <br />
<code>  ..- attr(*, "dimnames")=List of 2</code> <br />
<code>  .. ..$ : chr [1:23] "M012001" "M012002" "M012004" "M012016" ...</code> <br />
<code>  .. ..$ : chr [1:13] "S1" "S2" "S3" "S4" ...</code> <br />
<code> $ iteminfo: chr [1:23, 1:9] "M012001" "M012002" "M012004" "M012016" ...</code> <br />
<code>  ..- attr(*, "dimnames")=List of 2</code> <br />
<code>  .. ..$ : NULL</code> <br />
<code>  .. ..$ : chr [1:9] "item" "ItemType" "reporting_category" "content" ...</code> <br />
</p>
<p>For a detailed description of skills <code>S1</code>, <code>S2</code>, ..., <code>S15</code>
see Su et al. (2013, Table 2).
</p>


<h3>Source</h3>

<p>Subset of US 8th graders (Booklet 1) in the TIMSS 2003 mathematics study
</p>


<h3>References</h3>

<p>Skaggs, G., Wilkins, J. L. M., &amp; Hein, S. F. (2016).
Grain size and parameter recovery with TIMSS and the general diagnostic model.
<em>International Journal of Testing, 16</em>(4), 310-330.
</p>
<p>Su, Y.-L., Choi, K. M., Lee, W.-C., Choi, T., &amp; McAninch, M. (2013).
<em>Hierarchical cognitive diagnostic analysis for TIMSS 2003 mathematics</em>.
CASMA Research Report 35. Center for Advanced Studies in
Measurement and Assessment (CASMA), University of Iowa.
</p>


<h3>See Also</h3>

<p>The TIMSS 2003 dataset for 8th graders (with a larger number of items)
was also analyzed in Skaggs, Wilkins and Hein (2016).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Data Su et al. (2013)
#############################################################################

data(data.timss03.G8.su, package="CDM")
data &lt;- data.timss03.G8.su$data[,-c(1,2)]
q.matrix &lt;- data.timss03.G8.su$q.matrix

#*** Model 1: DINA model with complete skill space of 2^13=8192 skill classes
mod1 &lt;- CDM::din( data, q.matrix )

#*** Model 2: Skill space approximation with 3000 skill classes instead of
#    2^13=8192 classes as in Model 1
ss2 &lt;- CDM::skillspace.approximation( L=3000, K=ncol(q.matrix) )
mod2 &lt;- CDM::din( data, q.matrix, skillclasses=ss2 )

#*** Model 3: DINA model with a hierarchical skill space
#   see Su et al. (2013): Fig. 6
B &lt;- "S1 &gt; S2 &gt; S7 &gt; S8
      S15 &gt; S9
      S3 &gt; S9
      S13 &gt; S4 &gt; S9
      S14 &gt; S5 &gt; S6 &gt; S11"
# Note that S10 and S12 are not included in the dataset contained in this package
skill.names &lt;- colnames(q.matrix)
ss3 &lt;- CDM::skillspace.hierarchy(B=B, skill.names=skill.names)
# The reduced skill space "only" contains 325 skill classes
mod3 &lt;- CDM::din( data, q.matrix, skillclasses=ss3$skillspace.reduced )

## End(Not run)
</code></pre>

<hr>
<h2 id='data.timss07.G4.lee'>
TIMSS 2007 Mathematics 4th Grade (Lee et al., 2011)
</h2><span id='topic+data.timss07.G4.lee'></span><span id='topic+data.timss07.G4.py'></span><span id='topic+data.timss07.G4.Qdomains'></span>

<h3>Description</h3>

<p>TIMSS 2007 (Grade 4) dataset with 25 mathematics (dichotomized) items used
in Lee, Park and Taylan (2011), Park and Lee (2014) and Park, Xing and
Lee (2018). The dataset includes a sample of 698 Austrian students.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data.timss07.G4.lee)
data(data.timss07.G4.py)
data(data.timss07.G4.Qdomains)
</code></pre>


<h3>Format</h3>


<ul>
<li><p> The dataset <code>data.timss07.G4.lee</code> is a
list containing dichotomous item responses (<code>data</code>;
information on booklet and gender included),
the Q-matrix (<code>q.matrix</code>) and descriptions
of the skills (<code>skillinfo</code>) used in Lee et al. (2011).
</p>
<p>The format is:
</p>
<p><code>List of 3</code> <br />
<code> $ data     :'data.frame':</code> <br />
<code>  ..$ idstud  : int [1:698] 10110 10111 20105 20106 30203 30204 40106 40107 60111 60112 ...</code> <br />
<code>  ..$ idbook  : int [1:698] 4 5 4 5 4 5 4 5 4 5 ...</code> <br />
<code>  ..$ girl    : int [1:698] 0 0 1 1 0 1 0 1 1 1 ...</code> <br />
<code>  ..$ M041052 : num [1:698] 1 NA 1 NA 0 NA 1 NA 1 NA ...</code> <br />
<code>  ..$ M041056 : num [1:698] 1 NA 0 NA 0 NA 0 NA 1 NA ...</code> <br />
<code>  ..$ M041069 : num [1:698] 0 NA 0 NA 0 NA 0 NA 1 NA ...</code> <br />
<code>  ..$ M041076 : num [1:698] 1 NA 0 NA 1 NA 1 NA 0 NA ...</code> <br />
<code>  ..$ M041281 : num [1:698] 1 NA 0 NA 1 NA 1 NA 0 NA ...</code> <br />
<code>  ..$ M041164 : num [1:698] 1 NA 1 NA 0 NA 1 NA 1 NA ...</code> <br />
<code>  ..$ M041146 : num [1:698] 0 NA 0 NA 1 NA 1 NA 0 NA ...</code> <br />
<code>  ..$ M041152 : num [1:698] 1 NA 1 NA 1 NA 0 NA 1 NA ...</code> <br />
<code>  ..$ M041258A: num [1:698] 0 NA 1 NA 1 NA 0 NA 1 NA ...</code> <br />
<code>  ..$ M041258B: num [1:698] 1 NA 0 NA 1 NA 0 NA 1 NA ...</code> <br />
<code>  ..$ M041131 : num [1:698] 0 NA 0 NA 1 NA 1 NA 1 NA ...</code> <br />
<code>  ..$ M041275 : num [1:698] 1 NA 0 NA 0 NA 1 NA 1 NA ...</code> <br />
<code>  ..$ M041186 : num [1:698] 1 NA 0 NA 1 NA 1 NA 0 NA ...</code> <br />
<code>  ..$ M041336 : num [1:698] 1 NA 1 NA 0 NA 1 NA 0 NA ...</code> <br />
<code>  ..$ M031303 : num [1:698] 1 1 0 1 0 1 1 1 0 0 ...</code> <br />
<code>  ..$ M031309 : num [1:698] 1 0 1 1 1 1 1 1 0 0 ...</code> <br />
<code>  ..$ M031245 : num [1:698] 0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ M031242A: num [1:698] 1 1 0 1 1 1 1 1 0 0 ...</code> <br />
<code>  ..$ M031242B: num [1:698] 0 1 0 1 1 1 1 1 1 0 ...</code> <br />
<code>  ..$ M031242C: num [1:698] 1 1 0 1 1 1 1 1 1 0 ...</code> <br />
<code>  ..$ M031247 : num [1:698] 0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ M031219 : num [1:698] 1 1 1 0 1 1 1 1 1 0 ...</code> <br />
<code>  ..$ M031173 : num [1:698] 1 1 0 0 0 1 1 1 1 0 ...</code> <br />
<code>  ..$ M031085 : num [1:698] 1 0 0 1 1 1 0 0 0 1 ...</code> <br />
<code>  ..$ M031172 : num [1:698] 1 0 0 1 1 1 1 1 1 0 ...</code> <br />
<code> $ q.matrix : int [1:25, 1:15] 1 0 0 0 0 0 0 1 0 0 ...</code> <br />
<code>  ..- attr(*, "dimnames")=List of 2</code> <br />
<code>  .. ..$ : chr [1:25] "M041052" "M041056" "M041069" "M041076" ...</code> <br />
<code>  .. ..$ : chr [1:15] "NWN01" "NWN02" "NWN03" "NWN04" ...</code> <br />
<code> $ skillinfo:'data.frame':</code> <br />
<code>  ..$ skillindex      : int [1:15] 1 2 3 4 5 6 7 8 9 10 ...</code> <br />
<code>  ..$ skill           : Factor w/ 15 levels "DOR15","DRI13",..: 12 13 14 15 8 9 10 11 4 6 ...</code> <br />
<code>  ..$ content         : Factor w/ 3 levels "D","G","N": 3 3 3 3 3 3 3 3 2 2 ...</code> <br />
<code>  ..$ content_label   : Factor w/ 3 levels "Data Display",..: 3 3 3 3 3 3 3 3 2 2 ...</code> <br />
<code>  ..$ subcontent      : Factor w/ 9 levels "FD","LA","LM",..: 9 9 9 9 1 1 4 6 2 8 ...</code> <br />
<code>  ..$ subcontent_label: Factor w/ 9 levels "Fractions and Decimals",..: 9 9 9 9 1 1 4 6 2 8 ...</code> <br />
</p>
</li>
<li><p> The dataset <code>data.timss07.G4.py</code> uses the same items as
<code>data.timss07.G4.lee</code> but employs a simplified Q-matrix with 7 skills.
This Q-matrix was used in Park and Lee (2014) and Park et al. (2018).
</p>
<p><code>List of 3</code> <br />
<code> $ q.matrix:'data.frame':       25 obs. of  7 variables:</code> <br />
<code>  ..$ N1: num [1:25] 1 0 1 1 1 0 0 1 0 0 ...</code> <br />
<code>  ..$ N2: num [1:25] 0 1 1 1 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ N3: num [1:25] 0 0 0 0 1 0 0 0 0 0 ...</code> <br />
<code>  ..$ G4: num [1:25] 0 0 0 0 0 0 1 0 0 1 ...</code> <br />
<code>  ..$ G5: num [1:25] 0 0 0 0 0 1 1 1 1 1 ...</code> <br />
<code>  ..$ G6: num [1:25] 0 0 0 0 0 1 1 0 0 0 ...</code> <br />
<code>  ..$ D7: num [1:25] 0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code> $ domains : Named chr [1:3] "Number" "Geometric Shapes and Measures" "Data Display"</code> <br />
<code>  ..- attr(*, "names")=chr [1:3] "N" "G" "D"</code> <br />
<code> $ skills  : Named chr [1:7] "Whole Numbers" ...</code> <br />
<code>  ..- attr(*, "names")=chr [1:7] "N1" "N2" "N3" "G4" ...</code> <br />
</p>
</li>
<li><p> The Q-matrix <code>data.timss07.G4.Qdomains</code> is a simplification
of <code>data.timss07.G4.py$q.matrix</code> to 3 domains and involves a
simple structure of skills.
</p>
<p><code> num [1:25, 1:3] 1 1 1 1 1 0 0 1 0 0 ...</code> <br />
<code> - attr(*, "dimnames")=List of 2</code> <br />
<code>  ..$ : chr [1:25] "M041052" "M041056" "M041069" "M041076" ...</code> <br />
<code>  ..$ : chr [1:3] "N" "G" "D"</code> <br />
</p>
</li></ul>



<h3>Source</h3>

<p>TIMSS 2007 study, 4th Grade, Austrian sample on booklets 4 and 5
</p>


<h3>References</h3>

<p>Lee, Y. S., Park, Y. S., &amp; Taylan, D. (2011).
A cognitive diagnostic modeling of attribute mastery in Massachusetts,
Minnesota, and the US national sample using the TIMSS 2007.
<em>International Journal of Testing, 11</em>, 144-177.
</p>
<p>Park, Y. S., &amp; Lee, Y. S. (2014). An extension of the DINA model using
covariates: Examining factors affecting response probability and latent
classification. <em>Applied Psychological Measurement, 38</em>(5), 376-390.
</p>
<p>Park, Y. S., Xing, K., &amp; Lee, Y. S. (2018). Explanatory cognitive
diagnostic models: Incorporating latent and observed predictors.
<em>Applied Psychological Measurement, 42</em>(5), 376-392.
</p>
<p>Yamaguchi, K., &amp; Okada, K. (2018). Comparison among cognitive diagnostic models
for the TIMSS 2007 fourth grade mathematics assessment.
<em>PloS ONE, 13</em>(2), e0188691.
</p>


<h3>See Also</h3>

<p>A comparison of several countries based on the 25 items is conducted in
Yamaguchi and Okada (2018).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: DINA model Lee et al. (2011) - 15 skills
#############################################################################

data(data.timss07.G4.lee, package="CDM")
dat &lt;- data.timss07.G4.lee$data
q.matrix &lt;- data.timss07.G4.lee$q.matrix
# extract items
items &lt;- grep( "M0", colnames(dat), value=TRUE )

#*** Model 1: estimate DINA model
mod1 &lt;- CDM::din( dat[,items], q.matrix )
summary(mod1)

#############################################################################
# EXAMPLE 2: DINA models Park and Lee (2014) - 7 skills and 3 skills
#############################################################################

data(data.timss07.G4.lee, package="CDM")
data(data.timss07.G4.py, package="CDM")
data(data.timss07.G4.Qdomains, package="CDM")

dat &lt;- data.timss07.G4.lee$data
q.matrix &lt;- data.timss07.G4.py$q.matrix
items &lt;- rownames(q.matrix)

#*** Model 1: estimate DINA model
mod1 &lt;- CDM::din( dat[,items], q.matrix )
summary(mod1)

#*** Model 2: estimate DINA model with Q-matrix defined by domains
Q &lt;- data.timss07.G4.Qdomains
mod2 &lt;- CDM::din( dat[,items], q.matrix=Q )
summary(mod2)

## End(Not run)
</code></pre>

<hr>
<h2 id='data.timss11.G4.AUT'>
TIMSS 2011 Mathematics 4th Grade Austrian Students
</h2><span id='topic+data.timss11.G4.AUT'></span><span id='topic+data.timss11.G4.AUT.part'></span><span id='topic+data.timss11.G4.sa'></span>

<h3>Description</h3>

<p>This is the TIMSS 2011 dataset of 4668 Austrian fourth-graders.
See George and Robitzsch (2014, 2015, 2018) for publications using the
TIMSS 2011 dataset for cognitive diagnosis modeling. The dataset has
also been analyzed by Sedat and Arican (2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data.timss11.G4.AUT)
data(data.timss11.G4.AUT.part)
data(data.timss11.G4.sa)
</code></pre>


<h3>Format</h3>


<ul>
<li><p> The format of the dataset <code>data.timss11.G4.AUT</code> is:
</p>
<p><code>List of 4</code> <br />
<code> $ data     :'data.frame':</code> <br />
<code>  ..$ uidschool: int [1:4668] 10040001 10040001 10040001 10040001 10040001 10040001 10040001 10040001 10040001 10040001 ...</code> <br />
<code>  ..$ uidstud  : num [1:4668] 1e+13 1e+13 1e+13 1e+13 1e+13 ...</code> <br />
<code>  ..$ IDCNTRY  : int [1:4668] 40 40 40 40 40 40 40 40 40 40 ...</code> <br />
<code>  ..$ IDBOOK   : int [1:4668] 10 12 13 14 1 2 3 4 5 6 ...</code> <br />
<code>  ..$ IDSCHOOL : int [1:4668] 1 1 1 1 1 1 1 1 1 1 ...</code> <br />
<code>  ..$ IDCLASS  : int [1:4668] 102 102 102 102 102 102 102 102 102 102 ...</code> <br />
<code>  ..$ IDSTUD   : int [1:4668] 10201 10203 10204 10205 10206 10207 10208 10209 10210 10211 ...</code> <br />
<code>  ..$ TOTWGT   : num [1:4668] 17.5 17.5 17.5 17.5 17.5 ...</code> <br />
<code>  ..$ HOUWGT   : num [1:4668] 1.04 1.04 1.04 1.04 1.04 ...</code> <br />
<code>  ..$ SENWGT   : num [1:4668] 0.111 0.111 0.111 0.111 0.111 ...</code> <br />
<code>  ..$ SCHWGT   : num [1:4668] 11.6 11.6 11.6 11.6 11.6 ...</code> <br />
<code>  ..$ STOTWGTU : num [1:4668] 524 524 524 524 524 ...</code> <br />
<code>  ..$ WGTADJ1  : int [1:4668] 1 1 1 1 1 1 1 1 1 1 ...</code> <br />
<code>  ..$ WGTFAC1  : num [1:4668] 11.6 11.6 11.6 11.6 11.6 ...</code> <br />
<code>  ..$ JKCREP   : int [1:4668] 1 1 1 1 1 1 1 1 1 1 ...</code> <br />
<code>  ..$ JKCZONE  : int [1:4668] 1 1 1 1 1 1 1 1 1 1 ...</code> <br />
<code>  ..$ female   : int [1:4668] 1 0 1 1 1 1 1 1 0 0 ...</code> <br />
<code>  ..$ M031346A : int [1:4668] NA NA NA 1 1 NA NA NA NA NA ...</code> <br />
<code>  ..$ M031346B : int [1:4668] NA NA NA 0 0 NA NA NA NA NA ...</code> <br />
<code>  ..$ M031346C : int [1:4668] NA NA NA 1 1 NA NA NA NA NA ...</code> <br />
<code>  ..$ M031379  : int [1:4668] NA NA NA 0 0 NA NA NA NA NA ...</code> <br />
<code>  ..$ M031380  : int [1:4668] NA NA NA 0 0 NA NA NA NA NA ...</code> <br />
<code>  ..$ M031313  : int [1:4668] NA NA NA 1 1 NA NA NA NA NA ...</code> <br />
<code>  .. [list output truncated]</code> <br />
<code> $ q.matrix1:'data.frame':</code> <br />
<code>  ..$ item : Factor w/ 174 levels "M031004","M031009",..: 29 30 31 32 33 25 8 5 17 163 ...</code> <br />
<code>  ..$ Co_DA: int [1:174] 0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ Co_DK: int [1:174] 0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ Co_DR: int [1:174] 0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ Co_GA: int [1:174] 0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ Co_GK: int [1:174] 0 0 0 0 0 0 1 1 0 0 ...</code> <br />
<code>  ..$ Co_GR: int [1:174] 0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ Co_NA: int [1:174] 1 0 0 0 0 1 0 0 0 1 ...</code> <br />
<code>  ..$ Co_NK: int [1:174] 0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ Co_NR: int [1:174] 0 1 1 1 1 0 0 0 1 0 ...</code> <br />
<code> $ q.matrix2:'data.frame':</code> <br />
<code>  ..$ item  : Factor w/ 174 levels "M031004","M031009",..: 29 30 31 32 33 25 8 5 17 163 ...</code> <br />
<code>  ..$ CONT_D: int [1:174] 0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ CONT_G: int [1:174] 0 0 0 0 0 0 1 1 0 0 ...</code> <br />
<code>  ..$ CONT_N: int [1:174] 1 1 1 1 1 1 0 0 1 1 ...</code> <br />
<code> $ q.matrix3:'data.frame':      174 obs. of  4 variables:</code> <br />
<code>  ..$ item  : Factor w/ 174 levels "M031004","M031009",..: 29 30 31 32 33 25 8 5 17 163 ...</code> <br />
<code>  ..$ COGN_A: int [1:174] 1 0 0 0 0 1 0 0 0 1 ...</code> <br />
<code>  ..$ COGN_K: int [1:174] 0 0 0 0 0 0 1 1 0 0 ...</code> <br />
<code>  ..$ COGN_R: int [1:174] 0 1 1 1 1 0 0 0 1 0 ...</code> <br />
</p>
</li>
<li><p> The dataset <code>data.timss11.G4.AUT.part</code> is a part of
<code>data.timss11.G4.AUT</code> and contains only the first
three booklets (with N=1010 students). The format is
</p>
<p><code>List of 4</code> <br />
<code> $ data     :'data.frame':      1010 obs. of  109 variables:</code> <br />
<code>  ..$ uidschool: int [1:1010] 10040001 10040001 10040001 10040001  ...</code> <br />
<code>  ..$ uidstud  : num [1:1010] 1e+13 1e+13 1e+13 1e+13 1e+13 ...</code> <br />
<code>  ..$ IDCNTRY  : int [1:1010] 40 40 40 40 40 40 40 40 40 40 ...</code> <br />
<code>  ..$ IDBOOK   : int [1:1010] 1 2 3 1 2 1 2 3 1 2 ...</code> <br />
<code>  ..$ IDSCHOOL : int [1:1010] 1 1 1 1 1 2 2 2 3 3 ...</code> <br />
<code>  ..$ IDCLASS  : int [1:1010] 102 102 102 102 102 ...</code> <br />
<code>  ..$ IDSTUD   : int [1:1010] 10206 10207 10208 10220 ...</code> <br />
<code>  ..$ TOTWGT   : num [1:1010] 17.5 17.5 17.5 17.5 17.5 ...</code> <br />
<code>  ..$ HOUWGT   : num [1:1010] 1.04 1.04 1.04 1.04 1.04 ...</code> <br />
<code>  ..$ SENWGT   : num [1:1010] 0.111 0.111 0.111 0.111 0.111 ...</code> <br />
<code>  ..$ SCHWGT   : num [1:1010] 11.6 11.6 11.6 11.6 11.6 ...</code> <br />
<code>  ..$ STOTWGTU : num [1:1010] 524 524 524 524 524 ...</code> <br />
<code>  ..$ WGTADJ1  : int [1:1010] 1 1 1 1 1 1 1 1 1 1 ...</code> <br />
<code>  ..$ WGTFAC1  : num [1:1010] 11.6 11.6 11.6 11.6 11.6 ...</code> <br />
<code>  ..$ JKCREP   : int [1:1010] 1 1 1 1 1 0 0 0 0 0 ...</code> <br />
<code>  ..$ JKCZONE  : int [1:1010] 1 1 1 1 1 1 1 1 2 2 ...</code> <br />
<code>  ..$ female   : int [1:1010] 1 1 1 1 0 1 1 1 1 1 ...</code> <br />
<code>  ..$ M031346A : int [1:1010] 1 NA NA 1 NA 1 NA NA 1 NA ...</code> <br />
<code>  ..$ M031346B : int [1:1010] 0 NA NA 1 NA 0 NA NA 0 NA ...</code> <br />
<code>  ..$ M031346C : int [1:1010] 1 NA NA 0 NA 0 NA NA 0 NA ...</code> <br />
<code>  ..$ M031379  : int [1:1010] 0 NA NA 0 NA 0 NA NA 1 NA ...</code> <br />
<code>  ..$ M031380  : int [1:1010] 0 NA NA 0 NA 0 NA NA 0 NA ...</code> <br />
<code>  ..$ M031313  : int [1:1010] 1 NA NA 0 NA 1 NA NA 0 NA ...</code> <br />
<code>  ..$ M031083  : int [1:1010] 1 NA NA 1 NA 1 NA NA 1 NA ...</code> <br />
<code>  ..$ M031071  : int [1:1010] 0 NA NA 0 NA 1 NA NA 0 NA ...</code> <br />
<code>  ..$ M031185  : int [1:1010] 0 NA NA 1 NA 0 NA NA 0 NA ...</code> <br />
<code>  ..$ M051305  : int [1:1010] 1 1 NA 1 0 0 0 NA 0 1 ...</code> <br />
<code>  ..$ M051091  : int [1:1010] 1 1 NA 1 1 1 1 NA 1 0 ...</code> <br />
<code>  .. [list output truncated]</code> <br />
<code> $ q.matrix1:'data.frame':      47 obs. of  10 variables:</code> <br />
<code>  ..$ item : Factor w/ 174 levels "M031004","M031009",..: 29 30 31 32 33 25 8 5 17 163 ...</code> <br />
<code>  ..$ Co_DA: int [1:47] 0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ Co_DK: int [1:47] 0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ Co_DR: int [1:47] 0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ Co_GA: int [1:47] 0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ Co_GK: int [1:47] 0 0 0 0 0 0 1 1 0 0 ...</code> <br />
<code>  ..$ Co_GR: int [1:47] 0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ Co_NA: int [1:47] 1 0 0 0 0 1 0 0 0 1 ...</code> <br />
<code>  ..$ Co_NK: int [1:47] 0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ Co_NR: int [1:47] 0 1 1 1 1 0 0 0 1 0 ...</code> <br />
<code> $ q.matrix2:'data.frame':      47 obs. of  4 variables:</code> <br />
<code>  ..$ item  : Factor w/ 174 levels "M031004","M031009",..: 29 30 31 32 33 25 8 5 17 163 ...</code> <br />
<code>  ..$ CONT_D: int [1:47] 0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ CONT_G: int [1:47] 0 0 0 0 0 0 1 1 0 0 ...</code> <br />
<code>  ..$ CONT_N: int [1:47] 1 1 1 1 1 1 0 0 1 1 ...</code> <br />
<code> $ q.matrix3:'data.frame':      47 obs. of  4 variables:</code> <br />
<code>  ..$ item  : Factor w/ 174 levels "M031004","M031009",..: 29 30 31 32 33 25 8 5 17 163 ...</code> <br />
<code>  ..$ COGN_A: int [1:47] 1 0 0 0 0 1 0 0 0 1 ...</code> <br />
<code>  ..$ COGN_K: int [1:47] 0 0 0 0 0 0 1 1 0 0 ...</code> <br />
<code>  ..$ COGN_R: int [1:47] 0 1 1 1 1 0 0 0 1 0 ...</code> <br />
</p>
</li>
<li><p> The dataset <code>data.timss11.G4.sa</code> contains the Q-matrix
used in Sedat and Arican (2015).
</p>
<p><code>List of 2</code> <br />
<code> $ q.matrix:'data.frame':       31 obs. of  13 variables:</code> <br />
<code>  ..$ N1 : num [1:31] 1 0 0 1 1 0 0 0 0 0 ...</code> <br />
<code>  ..$ N2 : num [1:31] 1 1 0 0 1 0 0 0 0 0 ...</code> <br />
<code>  ..$ N3 : num [1:31] 0 0 0 0 1 0 0 0 0 0 ...</code> <br />
<code>  ..$ A4 : num [1:31] 0 0 1 0 0 1 1 1 0 0 ...</code> <br />
<code>  ..$ A5 : num [1:31] 0 0 0 0 0 1 0 1 0 0 ...</code> <br />
<code>  ..$ A6 : num [1:31] 0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ A7 : num [1:31] 0 0 1 0 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ G8 : num [1:31] 0 0 0 0 0 0 0 0 1 1 ...</code> <br />
<code>  ..$ G9 : num [1:31] 0 0 0 0 0 0 0 0 1 1 ...</code> <br />
<code>  ..$ G10: num [1:31] 0 0 0 0 0 0 0 0 1 1 ...</code> <br />
<code>  ..$ G11: num [1:31] 0 0 0 0 0 1 0 0 0 0 ...</code> <br />
<code>  ..$ D12: num [1:31] 0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code>  ..$ D13: num [1:31] 0 0 0 0 0 0 0 0 0 0 ...</code> <br />
<code> $ skills  : Named chr [1:13] "Possesses understanding of"  __truncated__ ...</code> <br />
<code>  ..- attr(*, "names")=chr [1:13] "N1" "N2" "N3" "A4" ...</code> <br />
</p>
</li></ul>



<h3>References</h3>

<p>George, A. C., &amp; Robitzsch, A. (2014). Multiple group cognitive diagnosis models,
with an emphasis on differential item functioning.
<em>Psychological Test and Assessment Modeling, 56</em>(4), 405-432.
</p>
<p>George, A. C., &amp; Robitzsch, A. (2015) Cognitive diagnosis models in R: A didactic.
<em>The Quantitative Methods for Psychology, 11</em>, 189-205.
</p>
<p>George, A. C., &amp; Robitzsch, A. (2018). Focusing on interactions between content
and cognition: A new perspective on gender differences in mathematical
sub-competencies. <em>Applied Measurement in Education, 31</em>(1), 79-97.
</p>
<p>Sedat, S. E. N., &amp; Arican, M. (2015). A diagnostic comparison of Turkish and
Korean students' Mathematics performances on the TIMSS 2011 assessment.
<em>Journal of Measurement and Evaluation in Education and Psychology, 6</em>(2),
238-253.
</p>

<hr>
<h2 id='deltaMethod'>
Variance Matrix of a Nonlinear Estimator Using the Delta Method
</h2><span id='topic+deltaMethod'></span>

<h3>Description</h3>

<p>Computes the variance of a nonlinear parameter using the
delta method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deltaMethod(derived.pars, est, Sigma, h=1e-05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deltaMethod_+3A_derived.pars">derived.pars</code></td>
<td>

<p>Vector of derived parameters written in <span class="rlang"><b>R</b></span> formula framework
(see Examples).
</p>
</td></tr>
<tr><td><code id="deltaMethod_+3A_est">est</code></td>
<td>

<p>Vector of parameter estimates
</p>
</td></tr>
<tr><td><code id="deltaMethod_+3A_sigma">Sigma</code></td>
<td>

<p>Covariance matrix of parameters
</p>
</td></tr>
<tr><td><code id="deltaMethod_+3A_h">h</code></td>
<td>

<p>Numerical differentiation parameter
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>coef</code></td>
<td>
<p>Vector of nonlinear parameters</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>Covariance matrix of nonlinear parameters</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>Vector of standard errors</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>First derivative of nonlinear transformation</p>
</td></tr>
<tr><td><code>univarTest</code></td>
<td>
<p>Data frame containing univariate summary of
nonlinear parameters</p>
</td></tr>
<tr><td><code>WaldTest</code></td>
<td>
<p>Multivariate parameter test for nonlinear parameter</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>See <code>car::deltaMethod</code> or <code>msm::deltamethod</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: Nonlinear parameter
#############################################################################

#-- parameter estimate
est &lt;- c( 510.67, 102.57)
names(est) &lt;- c("mu", "sigma")
#-- covariance matrix
Sigma &lt;- matrix( c(5.83, 0.45, 0.45, 3.21 ), nrow=2, ncol=2 )
colnames(Sigma) &lt;- rownames(Sigma) &lt;- names(est)
#-- define derived nonlinear parameters
derived.pars &lt;- list( "d"=~ I( ( mu - 508 ) / sigma ),
                      "dsig"=~ I( sigma / 100 - 1) )

#*** apply delta method
res &lt;- CDM::deltaMethod( derived.pars, est, Sigma )
res
</code></pre>

<hr>
<h2 id='din'>
Parameter Estimation for Mixed DINA/DINO Model
</h2><span id='topic+din'></span><span id='topic+print.din'></span>

<h3>Description</h3>

<p><code>din</code> provides parameter estimation for cognitive
diagnosis models of the types &ldquo;DINA&rdquo;, &ldquo;DINO&rdquo; and &ldquo;mixed DINA
and DINO&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>din(data, q.matrix, skillclasses=NULL,
      conv.crit=0.001, dev.crit=10^(-5), maxit=500,
      constraint.guess=NULL, constraint.slip=NULL,
      guess.init=rep(0.2, ncol(data)), slip.init=guess.init,
      guess.equal=FALSE, slip.equal=FALSE, zeroprob.skillclasses=NULL,
      weights=rep(1, nrow(data)), rule="DINA",
      wgt.overrelax=0, wgtest.overrelax=FALSE, param.history=FALSE,
      seed=0, progress=TRUE, guess.min=0, slip.min=0, guess.max=1, slip.max=1)

## S3 method for class 'din'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="din_+3A_data">data</code></td>
<td>
<p>A required <code class="reqn">N \times J</code> data matrix
containing the binary responses, 0 or 1, of <code class="reqn">N</code> respondents to <code class="reqn">J</code>
test items, where 1 denotes a correct response and 0 an incorrect one. The
nth row of the matrix represents the binary response pattern of respondent
n.  <code>NA</code> values are allowed.  </p>
</td></tr>
<tr><td><code id="din_+3A_q.matrix">q.matrix</code></td>
<td>
<p>A required binary <code class="reqn">J \times K</code> containing the
attributes not required or required, 0 or 1, to master the items.  The
jth row of the matrix is a binary indicator vector indicating which
attributes are not required (coded by 0) and which attributes are
required (coded by 1) to master item <code class="reqn">j</code>.  </p>
</td></tr>
<tr><td><code id="din_+3A_skillclasses">skillclasses</code></td>
<td>
<p>An optional matrix for determining the skill space.
The argument can be used if a user wants less than <code class="reqn">2^K</code> skill classes.
</p>
</td></tr>
<tr><td><code id="din_+3A_conv.crit">conv.crit</code></td>
<td>
<p>A numeric which defines the termination criterion
of iterations in the parameter
estimation process.  Iteration ends if the maximal change in parameter
estimates is below this value.  </p>
</td></tr>
<tr><td><code id="din_+3A_dev.crit">dev.crit</code></td>
<td>
<p>A numeric value which defines the termination criterion
of iterations in relative change in deviance.</p>
</td></tr>
<tr><td><code id="din_+3A_maxit">maxit</code></td>
<td>
<p>An integer which defines the maximum number
of iterations in the estimation process.  </p>
</td></tr>
<tr><td><code id="din_+3A_constraint.guess">constraint.guess</code></td>
<td>
<p>An optional matrix of fixed guessing
parameters.  The first column of this matrix indicates the numbers of the
items whose guessing parameters are fixed and the second
column the values the guessing parameters are fixed to.  </p>
</td></tr>
<tr><td><code id="din_+3A_constraint.slip">constraint.slip</code></td>
<td>
<p>An optional matrix of fixed slipping
parameters.  The first column of this matrix indicates the numbers of the
items whose slipping parameters are fixed and the second column
the values the slipping parameters are fixed to.  </p>
</td></tr>
<tr><td><code id="din_+3A_guess.init">guess.init</code></td>
<td>
<p>An optional initial vector of guessing parameters.
Guessing parameters are bounded between 0 and 1.  </p>
</td></tr>
<tr><td><code id="din_+3A_slip.init">slip.init</code></td>
<td>
<p>An optional initial vector of slipping parameters.
Slipping parameters are bounded between 0 and 1.  </p>
</td></tr>
<tr><td><code id="din_+3A_guess.equal">guess.equal</code></td>
<td>
<p>An optional logical indicating if all guessing parameters
are equal to each other. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="din_+3A_slip.equal">slip.equal</code></td>
<td>
<p>An optional logical indicating if all slipping parameters
are equal to each other. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="din_+3A_zeroprob.skillclasses">zeroprob.skillclasses</code></td>
<td>
<p>An optional vector of integers which indicates
which skill classes should have zero probability. Default is <code>NULL</code>
(no skill classes with zero probability).</p>
</td></tr>
<tr><td><code id="din_+3A_weights">weights</code></td>
<td>
<p>An optional vector of weights for the response pattern.
Non-integer weights allow for different sampling schemes.  </p>
</td></tr>
<tr><td><code id="din_+3A_rule">rule</code></td>
<td>
<p>An optional character string or vector of character strings
specifying the model rule that is used. The character strings must be
of <code>"DINA"</code> or <code>"DINO"</code>.  If a vector of character strings is
specified, implying an item wise condensation rule, the vector must
be of length <code class="reqn">J</code>, which is the number of items.  The default is
the condensation rule <code>"DINA"</code> for all items.  </p>
</td></tr>
<tr><td><code id="din_+3A_wgt.overrelax">wgt.overrelax</code></td>
<td>
<p>A parameter which is relevant when an overrelaxation
algorithm is used</p>
</td></tr>
<tr><td><code id="din_+3A_wgtest.overrelax">wgtest.overrelax</code></td>
<td>
<p>A logical which indicates if the overrelexation
parameter being estimated during iterations</p>
</td></tr>
<tr><td><code id="din_+3A_param.history">param.history</code></td>
<td>
<p>A logical which indicates if the parameter history during
iterations should be saved. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="din_+3A_seed">seed</code></td>
<td>
<p>Simulation seed for initial parameters. A value of zero corresponds
to deterministic starting values, an integer value different from
zero to random initial values with <code>set.seed(seed)</code>.</p>
</td></tr>
<tr><td><code id="din_+3A_progress">progress</code></td>
<td>
<p>An optional logical indicating whether the function
should print the progress of iteration in the estimation process.  </p>
</td></tr>
<tr><td><code id="din_+3A_guess.min">guess.min</code></td>
<td>
<p>Minimum value of guessing parameters to be estimated.</p>
</td></tr>
<tr><td><code id="din_+3A_slip.min">slip.min</code></td>
<td>
<p>Minimum value of slipping parameters to be estimated.</p>
</td></tr>
<tr><td><code id="din_+3A_guess.max">guess.max</code></td>
<td>
<p>Maximum value of guessing parameters to be estimated.</p>
</td></tr>
<tr><td><code id="din_+3A_slip.max">slip.max</code></td>
<td>
<p>Maximum value of slipping parameters to be estimated.</p>
</td></tr>
<tr><td><code id="din_+3A_x">x</code></td>
<td>
<p>Object of class <code>din</code></p>
</td></tr>
<tr><td><code id="din_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the CDM DINA (deterministic-input, noisy-and-gate; de la Torre &amp;
Douglas, 2004) and DINO (deterministic-input, noisy-or-gate; Templin &amp;
Henson, 2006) models endorsement probabilities are modeled
based on guessing and slipping parameters, given the different skill
classes.  The probability of respondent <code class="reqn">n</code> (or corresponding respondents class <code class="reqn">n</code>)
for solving item <code class="reqn">j</code> is calculated as a function of the
respondent's latent response <code class="reqn">\eta_{nj}</code>
and the guessing and slipping rates <code class="reqn">g_j</code> and <code class="reqn">s_j</code> for item
<code class="reqn">j</code> conditional on the respondent's skill class <code class="reqn">\alpha_n</code>:
</p>
<p style="text-align: center;"><code class="reqn"> P(X_{nj}=1 | \alpha_n)=g_j^{(1- \eta_{nj})}(1 - s_j) ^{\eta_{nj}}.  </code>
</p>

<p>The respondent's latent response (class) <code class="reqn">\eta_{nj}</code> is a binary number,
0 or 1, where 1 indicates presence of all (<code>rule="DINO"</code>)
or at least one (<code>rule="DINO"</code>) required skill(s) for
item <code class="reqn">j</code>, respectively.
</p>
<p>DINA and DINO parameter estimation is performed by
maximization of the marginal likelihood of the data.  The
a priori distribution of the skill vectors is a uniform distribution.
The implementation follows the EM algorithm by de la Torre (2009).
</p>
<p>The function <code>din</code> returns an object of the class
<code>din</code> (see &lsquo;Value&rsquo;), for which <code>plot</code>,
<code>print</code>, and <code>summary</code> methods are provided;
<code><a href="#topic+plot.din">plot.din</a></code>, <code><a href="#topic+print.din">print.din</a></code>, and
<code><a href="#topic+summary.din">summary.din</a></code>, respectively.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>coef</code></td>
<td>
<p>Estimated model parameters. Note that only freely
estimated parameters are included.</p>
</td></tr>
<tr><td><code>item</code></td>
<td>
<p>A data frame giving for each item condensation rule, the
estimated guessing and slipping parameters and their standard errors.
All entries are rounded to 3 digits.  </p>
</td></tr>
<tr><td><code>guess</code></td>
<td>
<p>A data frame giving the estimated guessing parameters
and their standard errors for each item.  </p>
</td></tr>
<tr><td><code>slip</code></td>
<td>
<p>A data frame giving the estimated slipping parameters
and their standard errors for each item.  </p>
</td></tr>
<tr><td><code>IDI</code></td>
<td>
<p>A matrix giving the item discrimination
index (IDI; Lee, de la Torre &amp; Park, 2012) for each item <code class="reqn">j</code>
</p>
<p style="text-align: center;"><code class="reqn"> IDI_j=1 - s_j - g_j, </code>
</p>

<p>where a high IDI corresponds to good test items
which have both low guessing and slipping rates.  Note that
a negative IDI indicates violation of the monotonicity condition
<code class="reqn">g_j &lt; 1 - s_j</code>.  See <code><a href="#topic+din">din</a></code> for help.  </p>
</td></tr>
<tr><td><code>itemfit.rmsea</code></td>
<td>
<p>The RMSEA item fit index (see <code><a href="#topic+itemfit.rmsea">itemfit.rmsea</a></code>).
</p>
</td></tr>
<tr><td><code>mean.rmsea</code></td>
<td>
<p>Mean of RMSEA item fit indexes.
</p>
</td></tr>
<tr><td><code>loglike</code></td>
<td>
<p>A numeric giving the value of the maximized
log likelihood.  </p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>A numeric giving the AIC value of the model.  </p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>A numeric giving the BIC value of the model.  </p>
</td></tr>
<tr><td><code>Npars</code></td>
<td>
<p>Number of estimated parameters</p>
</td></tr>
<tr><td><code>posterior</code></td>
<td>
<p>A matrix given the posterior skill distribution
for all respondents.  The nth row of the matrix gives the probabilities for
respondent n to possess any of the <code class="reqn">2^K</code> skill classes.  </p>
</td></tr>
<tr><td><code>like</code></td>
<td>
<p>A matrix giving the values of the maximized likelihood
for all respondents.  </p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The input matrix of binary response data.</p>
</td></tr>
<tr><td><code>q.matrix</code></td>
<td>
<p>The input matrix of the required attributes.  </p>
</td></tr>
<tr><td><code>pattern</code></td>
<td>
<p>A matrix giving the skill classes leading to highest endorsement
probability for the respective response pattern (<code>mle.est</code>) with the
corresponding posterior class probability (<code>mle.post</code>), the attribute
classes having the highest occurrence posterior probability given the
response pattern (<code>map.est</code>) with the corresponding posterior class
probability (<code>map.post</code>), and the estimated posterior for each
response pattern (<code>pattern</code>).  </p>
</td></tr>
<tr><td><code>attribute.patt</code></td>
<td>
<p>A data frame giving the estimated occurrence
probabilities of the skill classes and the expected frequency of the
attribute classes given the model.  </p>
</td></tr>
<tr><td><code>skill.patt</code></td>
<td>
<p>A matrix given the population prevalences of the
skills.  </p>
</td></tr>
<tr><td><code>subj.pattern</code></td>
<td>
<p>A vector of strings indicating the item response
pattern for each subject.  </p>
</td></tr>
<tr><td><code>attribute.patt.splitted</code></td>
<td>
<p>A dataframe giving the skill class
of the respondents.  </p>
</td></tr>
<tr><td><code>display</code></td>
<td>
<p>A character giving the model specified under
<code>rule</code>.  </p>
</td></tr>
<tr><td><code>item.patt.split</code></td>
<td>
<p>A matrix giving the splitted response pattern.  </p>
</td></tr>
<tr><td><code>item.patt.freq</code></td>
<td>
<p>A numeric vector given the frequencies of the response
pattern in <code>item.patt.split</code>.  </p>
</td></tr>
<tr><td><code>seed</code></td>
<td>
<p>Used simulation seed for initial parameters</p>
</td></tr>
<tr><td><code>partable</code></td>
<td>
<p>Parameter table which is used for <code>coef</code> and <code>vcov</code>.</p>
</td></tr>
<tr><td><code>vcov.derived</code></td>
<td>
<p>Design matrix for extended set of parameters in
<code>vcov</code>.</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>Logical indicating whether convergence was achieved.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>Optimization parameters used in estimation</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The calculation of standard errors using sampling weights which
represent multistage sampling schemes is not correct.  Please use
replication methods (like Jackknife) instead.
</p>


<h3>References</h3>

<p>de la Torre, J. (2009). DINA model parameter estimation:
A didactic. <em>Journal of Educational and Behavioral
Statistics, 34</em>, 115&ndash;130.
</p>
<p>de la Torre, J., &amp; Douglas, J. (2004). Higher-order latent trait models
for cognitive diagnosis. <em>Psychometrika, 69</em>, 333&ndash;353.
</p>
<p>Lee, Y.-S., de la Torre, J., &amp; Park, Y. S. (2012).
Relationships between cognitive diagnosis, CTT, and IRT indices:
An empirical investigation. <em>Asia Pacific Educational Research, 13</em>, 333-345.
</p>
<p>Rupp, A. A., Templin, J., &amp; Henson, R. A. (2010). <em>Diagnostic
Measurement: Theory, Methods, and Applications</em>.  New York: The Guilford
Press.
</p>
<p>Templin, J., &amp; Henson, R. (2006). Measurement of
psychological disorders using cognitive diagnosis
models. <em>Psychological Methods, 11</em>, 287&ndash;305.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.din">plot.din</a></code>, the S3 method for plotting objects of
the class <code>din</code>; <code><a href="#topic+print.din">print.din</a></code>, the S3 method
for printing objects of the class <code>din</code>;
<code><a href="#topic+summary.din">summary.din</a></code>, the S3 method for summarizing objects
of the class <code>din</code>, which creates objects of the class
<code>summary.din</code>; <code><a href="#topic+din">din</a></code>, the main function for
DINA and DINO parameter estimation, which creates objects of the class
<code>din</code>.
</p>
<p>See the <code><a href="#topic+gdina">gdina</a></code> function for the estimation of
the generalized DINA (GDINA) model.
</p>
<p>For assessment of model fit see <code><a href="#topic+modelfit.cor.din">modelfit.cor.din</a></code> and
<code><a href="#topic+anova.din">anova.din</a></code>.
</p>
<p>See <code><a href="#topic+itemfit.sx2">itemfit.sx2</a></code> for item fit statistics.
</p>
<p>See <code><a href="#topic+discrim.index">discrim.index</a></code> for computing discrimination indices.
</p>
<p>See also <code><a href="#topic+CDM-package">CDM-package</a></code> for general
information about this package.
</p>
<p>See the <code>NPCD::JMLE</code> function in the <span class="pkg">NPCD</span> package for
joint maximum likelihood estimation
of the DINA, DINO and NIDA model.
</p>
<p>See the <code>dina::DINA_Gibbs</code> function in the <span class="pkg">dina</span>
package for MCMC based estimation of the DINA model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: Examples based on dataset fractions.subtraction.data
#############################################################################

## dataset fractions.subtraction.data and corresponding Q-Matrix
head(fraction.subtraction.data)
fraction.subtraction.qmatrix

## Misspecification in parameter specification for method CDM::din()
## leads to warnings and terminates estimation procedure. E.g.,

# See Q-Matrix specification
fractions.dina.warning1 &lt;- CDM::din(data=fraction.subtraction.data,
  q.matrix=t(fraction.subtraction.qmatrix))

# See guess.init specification
fractions.dina.warning2 &lt;- CDM::din(data=fraction.subtraction.data,
  q.matrix=fraction.subtraction.qmatrix, guess.init=rep(1.2,
  ncol(fraction.subtraction.data)))

# See rule specification
fractions.dina.warning3 &lt;- CDM::din(data=fraction.subtraction.data,
  q.matrix=fraction.subtraction.qmatrix, rule=c(rep("DINA",
  10), rep("DINO", 9)))

## Parameter estimation of DINA model
# rule="DINA" is default
fractions.dina &lt;- CDM::din(data=fraction.subtraction.data,
  q.matrix=fraction.subtraction.qmatrix, rule="DINA")
attributes(fractions.dina)
str(fractions.dina)

## For instance assessing the guessing parameters through
## assignment
fractions.dina$guess

## corresponding summaries, including IDI,
## most frequent skill classes and information
## criteria AIC and BIC
summary(fractions.dina)

## In particular, assessing detailed summary through assignment
detailed.summary.fs &lt;- summary(fractions.dina)
str(detailed.summary.fs)

## Item discrimination index of item 8 is too low. This is also
## visualized in the first plot
plot(fractions.dina)

## The reason therefore is a high guessing parameter
round(fractions.dina$guess[,1], 2)

## Estimate DINA model with different random initial parameters using seed=1345
fractions.dina1 &lt;- CDM::din(data=fraction.subtraction.data,
  q.matrix=fraction.subtraction.qmatrix, rule="DINA", seed=1345)

## Fix the guessing parameters of items 5, 8 and 9 equal to .20
# define a constraint.guess matrix
constraint.guess &lt;-  matrix(c(5,8,9, rep(0.2, 3)), ncol=2)
fractions.dina.fixed &lt;- CDM::din(data=fraction.subtraction.data,
  q.matrix=fraction.subtraction.qmatrix,
  constraint.guess=constraint.guess)

## The second plot shows the expected (MAP) and observed skill
## probabilities. The third plot visualizes the skill class
## occurrence probabilities; Only the 'top.n.skill.classes' most frequent
## skill classes are labeled; it is obvious that the skill class '11111111'
## (all skills are mastered) is the most probable in this population.
## The fourth plot shows the skill probabilities conditional on response
## patterns; in this population the skills 3 and 6 seem to be
## mastered easier than the others. The fourth plot shows the
## skill probabilities conditional on a specified response
## pattern; it is shown whether a skill is mastered (above
## .5+'uncertainty') unclassifiable (within the boundaries) or
## not mastered (below .5-'uncertainty'). In this case, the
## 527th respondent was chosen; if no response pattern is
## specified, the plot will not be shown (of course)
pattern &lt;- paste(fraction.subtraction.data[527, ], collapse="")
plot(fractions.dina, pattern=pattern, display.nr=4)

#uncertainty=0.1, top.n.skill.classes=6 are default
plot(fractions.dina.fixed, uncertainty=0.1, top.n.skill.classes=6,
  pattern=pattern)

## Not run: 
#############################################################################
# EXAMPLE 2: Examples based on dataset sim.dina
#############################################################################

# DINA Model
d1 &lt;- CDM::din(sim.dina, q.matr=sim.qmatrix, rule="DINA",
  conv.crit=0.01, maxit=500, progress=TRUE)
summary(d1)

# DINA model with hierarchical skill classes (Hierarchical DINA model)
# 1st step:  estimate an initial full model to look at the indexing
#    of skill classes
d0 &lt;- CDM::din(sim.dina, q.matr=sim.qmatrix, maxit=1)
d0$attribute.patt.splitted
#      [,1] [,2] [,3]
# [1,]    0    0    0
# [2,]    1    0    0
# [3,]    0    1    0
# [4,]    0    0    1
# [5,]    1    1    0
# [6,]    1    0    1
# [7,]    0    1    1
# [8,]    1    1    1
#
# In this example, following hierarchical skill classes are only allowed:
# 000, 001, 011, 111
# We define therefore a vector of indices for skill classes with
# zero probabilities (see entries in the rows of the matrix
# d0$attribute.patt.splitted above)
zeroprob.skillclasses &lt;- c(2,3,5,6)     # classes 100, 010, 110, 101
# estimate the hierarchical DINA model
d1a &lt;- CDM::din(sim.dina, q.matr=sim.qmatrix,
          zeroprob.skillclasses=zeroprob.skillclasses )
summary(d1a)

# Mixed DINA and DINO Model
d1b &lt;- CDM::din(sim.dina, q.matr=sim.qmatrix, rule=
          c(rep("DINA", 7), rep("DINO", 2)), conv.crit=0.01,
          maxit=500, progress=FALSE)
summary(d1b)

# DINO Model
d2 &lt;- CDM::din(sim.dina, q.matr=sim.qmatrix, rule="DINO",
  conv.crit=0.01, maxit=500, progress=FALSE)
summary(d2)

# Comparison of DINA and DINO estimates
lapply(list("guessing"=rbind("DINA"=d1$guess[,1],
  "DINO"=d2$guess[,1]), "slipping"=rbind("DINA"=
  d1$slip[,1], "DINO"=d2$slip[,1])), round, 2)

# Comparison of the information criteria
c("DINA"=d1$AIC, "MIXED"=d1b$AIC, "DINO"=d2$AIC)

# following estimates:
d1$coef            # guessing and slipping parameter
d1$guess           # guessing parameter
d1$slip            # slipping parameter
d1$skill.patt      # probabilities for skills
d1$attribute.patt  # skill classes with probabilities
d1$subj.pattern    # pattern per subject

# posterior probabilities for every response pattern
d1$posterior

# Equal guessing parameters
d2a &lt;- CDM::din( data=sim.dina, q.matrix=sim.qmatrix,
            guess.equal=TRUE, slip.equal=FALSE )
d2a$coef

# Equal guessing and slipping parameters
d2b &lt;- CDM::din( data=sim.dina, q.matrix=sim.qmatrix,
            guess.equal=TRUE, slip.equal=TRUE )
d2b$coef

#############################################################################
# EXAMPLE 3: Examples based on dataset sim.dino
#############################################################################

# DINO Estimation
d3 &lt;- CDM::din(sim.dino, q.matr=sim.qmatrix, rule="DINO",
        conv.crit=0.005, progress=FALSE)

# Mixed DINA and DINO Model
d3b &lt;- CDM::din(sim.dino, q.matr=sim.qmatrix,
          rule=c(rep("DINA", 4), rep("DINO", 5)), conv.crit=0.001,
          progress=FALSE)

# DINA Estimation
d4 &lt;- CDM::din(sim.dino, q.matr=sim.qmatrix, rule="DINA",
  conv.crit=0.005, progress=FALSE)

# Comparison of DINA and DINO estimates
lapply(list("guessing"=rbind("DINO"=d3$guess[,1],  "DINA"=d4$guess[,1]),
       "slipping"=rbind("DINO"=d3$slip[,1], "DINA"=d4$slip[,1])), round, 2)

# Comparison of the information criteria
c("DINO"=d3$AIC, "MIXED"=d3b$AIC, "DINA"=d4$AIC)

#############################################################################
# EXAMPLE 4: Example estimation with weights based on dataset sim.dina
#############################################################################

# Here, a weighted maximum likelihood estimation is used
# This could be useful for survey data.

# i.e. first 200 persons have weight 2, the other have weight 1
(weights &lt;- c(rep(2, 200), rep(1, 200)))

d5 &lt;- CDM::din(sim.dina, sim.qmatrix, rule="DINA", conv.crit=
  0.005, weights=weights, progress=FALSE)

# Comparison of the information criteria
c("DINA"=d1$AIC, "WEIGHTS"=d5$AIC)

#############################################################################
# EXAMPLE 5: Example estimation within a balanced incomplete
##           block (BIB) design generated on dataset sim.dina
#############################################################################

# generate BIB data

# The next example shows that the din function works for
# (relatively arbitrary) missing value pattern

# Here, a missing by design is generated in the dataset dinadat.bib
sim.dina.bib &lt;- sim.dina
sim.dina.bib[1:100, 1:3] &lt;- NA
sim.dina.bib[101:300, 4:8] &lt;- NA
sim.dina.bib[301:400, c(1,2,9)] &lt;- NA

d6 &lt;- CDM::din(sim.dina.bib, sim.qmatrix, rule="DINA",
         conv.crit=0.0005, weights=weights, maxit=200)

d7 &lt;- CDM::din(sim.dina.bib, sim.qmatrix, rule="DINO",
         conv.crit=0.005, weights=weights)

# Comparison of DINA and DINO estimates
lapply(list("guessing"=rbind("DINA"=d6$guess[,1],
  "DINO"=d7$guess[,1]), "slipping"=rbind("DINA"=
  d6$slip[,1], "DINO"=d7$slip[,1])), round, 2)

#############################################################################
# EXAMPLE 6: DINA model with attribute hierarchy
#############################################################################

set.seed(987)
# assumed skill distribution: P(000)=P(100)=P(110)=P(111)=.245 and
#     "deviant pattern": P(010)=.02
K &lt;- 3 # number of skills

# define alpha
alpha &lt;- scan()
    0 0 0
    1 0 0
    1 1 0
    1 1 1
    0 1 0

alpha &lt;- matrix( alpha, length(alpha)/K, K, byrow=TRUE )
alpha &lt;- alpha[ c( rep(1:4,each=245), rep(5,20) ),  ]

# define Q-matrix
q.matrix &lt;- scan()
    1 0 0   1 0 0   1 0 0
    0 1 0   0 1 0   0 1 0
    0 0 1   0 1 0   0 0 1
    1 1 0   1 0 1   0 1 1

q.matrix &lt;- matrix( q.matrix, nrow=length(q.matrix)/K, ncol=K, byrow=TRUE )

# simulate DINA data
dat &lt;- CDM::sim.din( alpha=alpha, q.matrix=q.matrix )$dat

#*** Model 1: estimate DINA model | no skill space restriction
mod1 &lt;- CDM::din( dat, q.matrix )

#*** Model 2: DINA model | hierarchy A2 &gt; A3
B &lt;- "A2 &gt; A3"
skill.names &lt;- paste0("A",1:3)
skillspace &lt;- CDM::skillspace.hierarchy( B, skill.names )$skillspace.reduced
mod2 &lt;- CDM::din( dat, q.matrix, skillclasses=skillspace )

#*** Model 3: DINA model | linear hierarchy A1 &gt; A2 &gt; A3
#   This is a misspecied model because due to P(010)=.02 the relation A1&gt;A2
#   does not hold.
B &lt;- "A1 &gt; A2
      A2 &gt; A3"
skill.names &lt;- paste0("A",1:3)
skillspace &lt;- CDM::skillspace.hierarchy( B, skill.names )$skillspace.reduced
mod3 &lt;- CDM::din( dat, q.matrix, skillclasses=skillspace )

#*** Model 4: 2PL model in gdm
mod4 &lt;- CDM::gdm( dat, theta.k=seq(-5,5,len=21),
           decrease.increments=TRUE, skillspace="normal" )
summary(mod4)

anova(mod1,mod2)
  ##       Model   loglike Deviance Npars      AIC      BIC  Chisq df       p
  ##   2 Model 2 -7052.460 14104.92    29 14162.92 14305.24 0.9174  2 0.63211
  ##   1 Model 1 -7052.001 14104.00    31 14166.00 14318.14     NA NA      NA

anova(mod2,mod3)
  ##       Model   loglike Deviance Npars      AIC      BIC    Chisq df       p
  ##   2 Model 2 -7059.058 14118.12    27 14172.12 14304.63 13.19618  2 0.00136
  ##   1 Model 1 -7052.460 14104.92    29 14162.92 14305.24       NA NA      NA

anova(mod2,mod4)
  ##       Model  loglike Deviance Npars      AIC      BIC    Chisq df  p
  ##   2 Model 2 -7220.05 14440.10    24 14488.10 14605.89 335.1805  5  0
  ##   1 Model 1 -7052.46 14104.92    29 14162.92 14305.24       NA NA NA

# compare fit statistics
summary( CDM::modelfit.cor.din( mod2 ) )
summary( CDM::modelfit.cor.din( mod4 ) )

#############################################################################
# EXAMPLE 7: Fitting the basic local independence model (BLIM) with din
#############################################################################

library(pks)
data(DoignonFalmagne7, package="pks")
  ##  str(DoignonFalmagne7)
  ##    $ K  : int [1:9, 1:5] 0 1 0 1 1 1 1 1 1 0 ...
  ##     ..- attr(*, "dimnames")=List of 2
  ##     .. ..$ : chr [1:9] "00000" "10000" "01000" "11000" ...
  ##     .. ..$ : chr [1:5] "a" "b" "c" "d" ...
  ##    $ N.R: Named int [1:32] 80 92 89 3 2 1 89 16 18 10 ...
  ##     ..- attr(*, "names")=chr [1:32] "00000" "10000" "01000" "00100" ...

# The idea is to fit the local independence model with the din function.
# This can be accomplished by specifying a DINO model with
# prespecified skill classes.

# extract dataset
dat &lt;- as.numeric( unlist( sapply( names(DoignonFalmagne7$N.R),
    FUN=function( ll){ strsplit( ll, split="") } ) ) )
dat &lt;- matrix( dat, ncol=5, byrow=TRUE )
colnames(dat) &lt;- colnames(DoignonFalmagne7$K)
rownames(dat) &lt;- names(DoignonFalmagne7$N.R)

# sample weights
weights &lt;- DoignonFalmagne7$N.R

# define Q-matrix
q.matrix &lt;- t(DoignonFalmagne7$K)
v1 &lt;- colnames(q.matrix) &lt;- paste0("S", colnames(q.matrix))
q.matrix &lt;- q.matrix[, - 1] # remove S00000

# define skill classes
SC &lt;- ncol(q.matrix)
skillclasses &lt;- matrix( 0, nrow=SC+1, ncol=SC)
colnames(skillclasses) &lt;- colnames(q.matrix)
rownames(skillclasses) &lt;- v1
skillclasses[ cbind( 2:(SC+1), 1:SC ) ] &lt;- 1

# estimate BLIM with din function
mod1 &lt;- CDM::din(data=dat, q.matrix=q.matrix, skillclasses=skillclasses,
            rule="DINO", weights=weights   )
summary(mod1)
  ##   Item parameters
  ##     item guess  slip   IDI rmsea
  ##   a    a 0.158 0.162 0.680 0.011
  ##   b    b 0.145 0.159 0.696 0.009
  ##   c    c 0.008 0.181 0.811 0.001
  ##   d    d 0.012 0.129 0.859 0.001
  ##   e    e 0.025 0.146 0.828 0.007

# estimate basic local independence model with pks package
mod2 &lt;- pks::blim(K, N.R, method="ML") # maximum likelihood estimation by EM algorithm
mod2
  ##   Error and guessing parameters
  ##         beta      eta
  ##   a 0.164871 0.103065
  ##   b 0.163113 0.095074
  ##   c 0.188839 0.000004
  ##   d 0.079835 0.000003
  ##   e 0.088648 0.019910

## End(Not run)
</code></pre>

<hr>
<h2 id='din_identifiability'>
Identifiability Conditions of the DINA Model
</h2><span id='topic+din_identifiability'></span><span id='topic+summary.din_identifiability'></span>

<h3>Description</h3>

<p>Check necessary and sufficient identifiability conditions of the DINA model
according Gu and Xu (xxxx) for a given Q-matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>din_identifiability(q.matrix)

## S3 method for class 'din_identifiability'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="din_identifiability_+3A_q.matrix">q.matrix</code></td>
<td>

<p>Q-matrix
</p>
</td></tr>
<tr><td><code id="din_identifiability_+3A_object">object</code></td>
<td>
<p>Object of class <code>din_identifiability</code></p>
</td></tr>
<tr><td><code id="din_identifiability_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with values
</p>
<table role = "presentation">
<tr><td><code>dina_identified</code></td>
<td>
<p>Logical indicating whether the DINA model is identified</p>
</td></tr>
<tr><td><code>index_single</code></td>
<td>
<p>Condition 1: vector of logicals indicating whether skills
are measured by at least one item with a single loading</p>
</td></tr>
<tr><td><code>is_three_items</code></td>
<td>
<p>Condition 2: vector of logicals indicating whether skills
are measured by at least three items</p>
</td></tr>
<tr><td><code>submat_distinct</code></td>
<td>
<p>Condition 3: logical indicating whether all columns
of the submatrix <code class="reqn">Q^\ast</code> are distinct.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Gu, Y., &amp; Xu, G. (2018). The sufficient and necessary condition for the identifiability
and estimability of the DINA model. <em>Psychometrika, xx</em>(xx), xxx-xxx.
https://doi.org/10.1007/s11336-018-9619-8
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+din.equivalent.class">din.equivalent.class</a></code> for equivalent (i.e., non-distinguishable)
skill classes in the DINA model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: Some examples of Gu and Xu (2019)
#############################################################################

#* Matrix 1 in Equation (5) of Gu &amp; Xu (2019)
Q1 &lt;- diag(3)
Q2 &lt;- matrix( scan(text="1 1 0 1 0 1 1 1 1 1 1 1"), ncol=3, byrow=TRUE)
Q &lt;- rbind(Q1, Q2)

res &lt;- CDM::din_identifiability(q.matrix=Q)
summary(res)

# remove two items
res &lt;- CDM::din_identifiability(q.matrix=Q[-c(2,5),])
summary(res)

#* Matrix 1 in Equation (6) of Gu &amp; Xu (2019)
Q1 &lt;- diag(3)
Q2 &lt;- matrix( c(1,1,1), nrow=4, ncol=3, byrow=TRUE)
Q &lt;- rbind(Q1, Q2)

res &lt;- CDM::din_identifiability(q.matrix=Q)
summary(res)
</code></pre>

<hr>
<h2 id='din.deterministic'>
Deterministic Classification and Joint Maximum Likelihood Estimation
of the Mixed DINA/DINO Model
</h2><span id='topic+din.deterministic'></span>

<h3>Description</h3>

<p>This function allows the estimation of the mixed DINA/DINO model by
joint maximum likelihood and a deterministic classification based
on ideal latent responses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>din.deterministic(dat, q.matrix, rule="DINA", method="JML", conv=0.001,
    maxiter=300, increment.factor=1.05, progress=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="din.deterministic_+3A_dat">dat</code></td>
<td>

<p>Data frame of dichotomous item responses
</p>
</td></tr>
<tr><td><code id="din.deterministic_+3A_q.matrix">q.matrix</code></td>
<td>

<p>Q-matrix with binary entries (see <code><a href="#topic+din">din</a></code>).
</p>
</td></tr>
<tr><td><code id="din.deterministic_+3A_rule">rule</code></td>
<td>
<p>The condensation rule (see <code><a href="#topic+din">din</a></code>).
</p>
</td></tr>
<tr><td><code id="din.deterministic_+3A_method">method</code></td>
<td>

<p>Estimation method. The default is joint maximum likelihood estimation
(<code>JML</code>). Other options include an adaptive estimation of guessing and
slipping parameters (<code>adaptive</code>) while using these estimated parameters
as weights in the individual deviation function and classification based on
the Hamming distance (<code>hamming</code>) and the weighted Hamming
distance (<code>weighted.hamming</code>) (see Chiu &amp; Douglas, 2013).
</p>
</td></tr>
<tr><td><code id="din.deterministic_+3A_conv">conv</code></td>
<td>

<p>Convergence criterion for guessing and slipping parameters
</p>
</td></tr>
<tr><td><code id="din.deterministic_+3A_maxiter">maxiter</code></td>
<td>

<p>Maximum number of iterations
</p>
</td></tr>
<tr><td><code id="din.deterministic_+3A_increment.factor">increment.factor</code></td>
<td>

<p>A numeric value of at least one which could help to improve convergence
behavior and decreases parameter increments in every iteration. This option is
disabled by setting this argument to 1.
</p>
</td></tr>
<tr><td><code id="din.deterministic_+3A_progress">progress</code></td>
<td>
<p>An optional logical indicating whether the function
should print the progress of iteration in the estimation process.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with following entries
</p>
<table role = "presentation">
<tr><td><code>attr.est</code></td>
<td>
<p>Estimated attribute patterns</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>Criterion of the classification function.
For joint maximum likelihood it is the deviance.</p>
</td></tr>
<tr><td><code>guess</code></td>
<td>
<p>Estimated guessing parameters</p>
</td></tr>
<tr><td><code>slip</code></td>
<td>
<p>Estimated slipping parameters</p>
</td></tr>
<tr><td><code>prederror</code></td>
<td>
<p>Average individual prediction error</p>
</td></tr>
<tr><td><code>q.matrix</code></td>
<td>
<p>Used Q-matrix</p>
</td></tr>
<tr><td><code>dat</code></td>
<td>
<p>Used data frame</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chiu, C. Y., &amp; Douglas, J. (2013). A nonparametric approach to
cognitive diagnosis by proximity to ideal response patterns.
<em>Journal of Classification, 30</em>, 225-250.
</p>


<h3>See Also</h3>

<p>For estimating the mixed DINA/DINO model using marginal maximum
likelihood estimation see <code><a href="#topic+din">din</a></code>.
</p>
<p>See also the <code>NPCD::JMLE</code> function in the <span class="pkg">NPCD</span> package for
joint maximum likelihood estimation of the DINA or the DINO model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: 13 items and 3 attributes
#############################################################################

set.seed(679)
N &lt;- 3000
# specify true Q-matrix
q.matrix &lt;- matrix( 0, 13, 3 )
q.matrix[1:3,1] &lt;- 1
q.matrix[4:6,2] &lt;- 1
q.matrix[7:9,3] &lt;- 1
q.matrix[10,] &lt;- c(1,1,0)
q.matrix[11,] &lt;- c(1,0,1)
q.matrix[12,] &lt;- c(0,1,1)
q.matrix[13,] &lt;- c(1,1,1)
q.matrix &lt;- rbind( q.matrix, q.matrix )
colnames(q.matrix) &lt;- paste0("Attr",1:ncol(q.matrix))

# simulate data according to the DINA model
dat &lt;- CDM::sim.din( N=N, q.matrix)$dat

# Joint maximum likelihood estimation (the default: method="JML")
res1 &lt;- CDM::din.deterministic( dat, q.matrix )

# Adaptive estimation of guessing and slipping parameters
res &lt;- CDM::din.deterministic( dat, q.matrix, method="adaptive" )

# Classification using Hamming distance
res &lt;- CDM::din.deterministic( dat, q.matrix, method="hamming" )

# Classification using weighted Hamming distance
res &lt;- CDM::din.deterministic( dat, q.matrix, method="weighted.hamming" )

## Not run: 
#********* load NPCD library for JML estimation
library(NPCD)

# DINA model
res &lt;- NPCD::JMLE( Y=dat[1:100,], Q=q.matrix, model="DINA" )
as.data.frame(res$par.est )   # item parameters
res$alpha.est                 # skill classifications

# RRUM model
res &lt;- NPCD::JMLE( Y=dat[1:100,], Q=q.matrix, model="RRUM" )
as.data.frame(res$par.est )

## End(Not run)
</code></pre>

<hr>
<h2 id='din.equivalent.class'>
Calculation of Equivalent Skill Classes in the DINA/DINO Model
</h2><span id='topic+din.equivalent.class'></span>

<h3>Description</h3>

<p>This function computes indistinguishable skill classes for the DINA and
DINO model (Gross &amp; George, 2014; Zhang, DeCarlo &amp; Ying, 2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>din.equivalent.class(q.matrix, rule="DINA")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="din.equivalent.class_+3A_q.matrix">q.matrix</code></td>
<td>
<p>The Q-matrix (see <code><a href="#topic+din">din</a></code>).</p>
</td></tr>
<tr><td><code id="din.equivalent.class_+3A_rule">rule</code></td>
<td>

<p>The condensation rule. If it is a string, then the rule applies
to all items. If it is a vector, then for each item <code>DINA</code>
or <code>DINO</code> rule can be chosen.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with following entries:
</p>
<table role = "presentation">
<tr><td><code>latent.responseM</code></td>
<td>
<p>Matrix of latent responses</p>
</td></tr>
<tr><td><code>latent.response</code></td>
<td>
<p>Latent responses represented as a string</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>Matrix containing all skill classes</p>
</td></tr>
<tr><td><code>gini</code></td>
<td>
<p>Gini coefficient of the frequency distribution of
identifiable skill classes which result in the same latent response
</p>
</td></tr>
<tr><td><code>skillclasses</code></td>
<td>
<p>Data frame with skill class (<code>skillclass</code>),
latent responses (<code>latent.response</code>) and an identifier for
distinguishable skill classes (<code>distinguish.class</code>).
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Gross, J. &amp; George, A. C. (2014). On prerequisite relations between
attributes in noncompensatory diagnostic classification.
<em>Methodology, 10</em>(3), 100-107.
</p>
<p>Zhang, S. S., DeCarlo, L. T., &amp; Ying, Z. (2013).
Non-identifiability, equivalence classes, and attribute-specific classification
in Q-matrix based cognitive diagnosis models.
<em>arXiv preprint</em>, <em>arXiv:1303.0426</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: Equivalency classes for DINA model for fraction subtraction data
#############################################################################

#-- DINA models

data(data.fraction2, package="CDM")

# first Q-matrix
Q1 &lt;- data.fraction2$q.matrix1
m1 &lt;- CDM::din.equivalent.class( q.matrix=Q1, rule="DINA" )
  ## 8 Skill classes | 5  distinguishable skill classes | Gini coefficient=0.3

# second Q-matrix
Q1 &lt;- data.fraction2$q.matrix2
m1 &lt;- CDM::din.equivalent.class( q.matrix=Q1, rule="DINA" )
  ## 32 Skill classes | 9  distinguishable skill classes | Gini coefficient=0.5

# third Q-matrix
Q1 &lt;- data.fraction2$q.matrix3
m1 &lt;- CDM::din.equivalent.class( q.matrix=Q1, rule="DINA" )
  ## 8 Skill classes | 8  distinguishable skill classes | Gini coefficient=0

# original fraction subtraction data
m1 &lt;- CDM::din.equivalent.class( q.matrix=CDM::fraction.subtraction.qmatrix, rule="DINA")
  ## 256 Skill classes | 58  distinguishable skill classes | Gini coefficient=0.659
</code></pre>

<hr>
<h2 id='din.validate.qmatrix'>
Q-Matrix Validation (Q-Matrix Modification) for Mixed DINA/DINO Model
</h2><span id='topic+din.validate.qmatrix'></span>

<h3>Description</h3>

<p>Q-matrix entries can be modified by the Q-matrix validation method
of de la Torre (2008). After estimating a mixed DINA/DINO model
using the <code><a href="#topic+din">din</a></code> function, item parameters and the item
discrimination parameters <code class="reqn">IDI_j</code> are recalculated. Q-matrix rows
are determined by maximizing the estimated item discrimination index
<code class="reqn">IDI_j=1-s_j -g_j</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>din.validate.qmatrix(object, IDI_diff=.02, print=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="din.validate.qmatrix_+3A_object">object</code></td>
<td>

<p>Object of class <code>din</code>
</p>
</td></tr>
<tr><td><code id="din.validate.qmatrix_+3A_idi_diff">IDI_diff</code></td>
<td>

<p>Minimum difference in IDI values for choosing a new Q-matrix vector
</p>
</td></tr>
<tr><td><code id="din.validate.qmatrix_+3A_print">print</code></td>
<td>
<p>An optional logical indicating whether the function
should print the progress of iteration in the estimation process.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with following entries:
</p>
<table role = "presentation">
<tr><td><code>coef.modified</code></td>
<td>
<p>Estimated parameters by applying Q-matrix
modifications</p>
</td></tr>
<tr><td><code>coef.modified.short</code></td>
<td>
<p>A shortened matrix of <code>coef.modified</code>.
Only Q-matrix rows which increase the <code class="reqn">IDI</code> are displayed.
</p>
</td></tr>
<tr><td><code>q.matrix.prop</code></td>
<td>
<p>The proposed Q-matrix by Q-matrix validation.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chiu, C. Y. (2013). Statistical refinement of the Q-matrix in cognitive
diagnosis. <em>Applied Psychological Measurement, 37</em>, 598-618.
</p>
<p>de la Torre, J. (2008). An empirically based method of Q-matrix
validation for the DINA model: Development and applications.
<em>Journal of Educational Measurement, 45</em>, 343-362.
</p>


<h3>See Also</h3>

<p>The mixed DINA/DINO model can be estimated with <code><a href="#topic+din">din</a></code>.
</p>
<p>See Chiu (2013) for an alternative estimation approach based on
residual sum of squares which is implemented
<code>NPCD::Qrefine</code> function in the <span class="pkg">NPCD</span> package.
</p>
<p>See the <code><a href="GDINA.html#topic+Qval">GDINA::Qval</a></code> function in the
<span class="pkg">GDINA</span> package for extended functionality.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: Detection of a mis-specified Q-matrix
#############################################################################

set.seed(679)
# specify true Q-matrix
q.matrix &lt;- matrix( 0, 12, 3 )
q.matrix[1:3,1] &lt;- 1
q.matrix[4:6,2] &lt;- 1
q.matrix[7:9,3] &lt;- 1
q.matrix[10,] &lt;- c(1,1,0)
q.matrix[11,] &lt;- c(1,0,1)
q.matrix[12,] &lt;- c(0,1,1)
# simulate data
dat &lt;- CDM::sim.din( N=4000, q.matrix)$dat
# incorrectly modify Q-matrix rows 1 and 10
Q1 &lt;- q.matrix
Q1[1,] &lt;- c(1,1,0)
Q1[10,] &lt;- c(1,0,0)
# estimate DINA model
mod &lt;- CDM::din( dat, q.matr=Q1, rule="DINA")
# apply Q-matrix validation
res &lt;- CDM::din.validate.qmatrix( mod )
  ## item itemindex Skill1 Skill2 Skill3 guess  slip   IDI qmatrix.orig IDI.orig delta.IDI max.IDI
  ## I001         1      1      0      0 0.309 0.251 0.440            0    0.431     0.009   0.440
  ## I010        10      1      1      0 0.235 0.329 0.437            0    0.320     0.117   0.437
  ## I010        10      1      1      1 0.296 0.301 0.403            0    0.320     0.083   0.437
  ##
  ##   Proposed Q-matrix:
  ##
  ##          Skill1 Skill2 Skill3
  ##   Item1       1      0      0
  ##   Item2       1      0      0
  ##   Item3       1      0      0
  ##   Item4       0      1      0
  ##   Item5       0      1      0
  ##   Item6       0      1      0
  ##   Item7       0      0      1
  ##   Item8       0      0      1
  ##   Item9       0      0      1
  ##   Item10      1      1      0
  ##   Item11      1      0      1
  ##   Item12      0      1      1

## Not run: 
#*****************
# Q-matrix estimation ('Qrefine') in the NPCD package
# See Chiu (2013, APM).
#*****************

library(NPCD)
Qrefine.out &lt;- NPCD::Qrefine( dat, Q1, gate="AND", max.ite=50)
print(Qrefine.out)
  ##   The modified Q-matrix
  ##           Attribute 1 Attribute 2 Attribute 3
  ##   Item 1            1           0           0
  ##   Item 2            1           0           0
  ##   Item 3            1           0           0
  ##   Item 4            0           1           0
  ##   Item 5            0           1           0
  ##   Item 6            0           1           0
  ##   Item 7            0           0           1
  ##   Item 8            0           0           1
  ##   Item 9            0           0           1
  ##   Item 10           1           1           0
  ##   Item 11           1           0           1
  ##   Item 12           0           1           1
  ##
  ##   The modified entries
  ##        Item Attribute
  ##   [1,]    1         2
  ##   [2,]   10         2

plot(Qrefine.out)

## End(Not run)
</code></pre>

<hr>
<h2 id='discrim.index'>
Discrimination Indices at Item-Attribute, Item and Test Level
</h2><span id='topic+discrim.index'></span><span id='topic+discrim.index.din'></span><span id='topic+discrim.index.gdina'></span><span id='topic+discrim.index.mcdina'></span><span id='topic+summary.discrim.index'></span>

<h3>Description</h3>

<p>Computes discrimination indices at the probability metric
(de la Torre, 2008; Henson, DiBello &amp; Stout, 2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discrim.index(object, ...)

## S3 method for class 'din'
discrim.index(object, ...)

## S3 method for class 'gdina'
discrim.index(object, ...)

## S3 method for class 'mcdina'
discrim.index(object, ...)

## S3 method for class 'discrim.index'
summary(object, file=NULL, digits=3,  ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="discrim.index_+3A_object">object</code></td>
<td>

<p>Object of class <code><a href="#topic+din">din</a></code> or <code><a href="#topic+gdina">gdina</a></code>.
</p>
</td></tr>
<tr><td><code id="discrim.index_+3A_file">file</code></td>
<td>
<p>Optional file name for a file in which the summary
output should be sunk</p>
</td></tr>
<tr><td><code id="discrim.index_+3A_digits">digits</code></td>
<td>
<p>Number of digits for rounding</p>
</td></tr>
<tr><td><code id="discrim.index_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If item <code class="reqn">j</code> possesses <code class="reqn">H_j</code> categories, the item-attribute
specific discrimination for attribute <code class="reqn">k</code>
according to Henson et al. (2018) is defined as
</p>
<p style="text-align: center;"><code class="reqn"> DI_{jk}=\frac{1}{2} \max_{ \bm{\alpha} }
\left(  \sum_{h=1}^{H_j} | P(X_j=h| \bm{\alpha} ) -
P(X_j=h| \bm{\alpha}^{(-k)} ) |
\right )   </code>
</p>

<p>where <code class="reqn">\bm{\alpha}^{(-k)}</code> and <code class="reqn">\bm{\alpha}</code> differ only
in attribute <code class="reqn">k</code>. The index <code class="reqn">DI_{jk}</code> can be found as the
value <code>discrim_item_attribute</code>. The test-level discrimination index
is defined as
</p>
<p style="text-align: center;"><code class="reqn">\overline{DI}=\frac{1}{J} \sum_{j=1}^J \max_k DI_{jk} </code>
</p>
<p> and can be found
in <code>discrim_test</code>.
</p>
<p>According to de la Torre (2008) and de la Torre, Rossi and van der Ark (2018),
the item discrimination index (IDI) is defined as
</p>
<p style="text-align: center;"><code class="reqn">IDI_j=\max_{ \bm{\alpha}_1,\bm{\alpha}_2, h}
     | P(X_j=h| \bm{\alpha}_1 ) - P(X_j=h| \bm{\alpha}_2 ) |</code>
</p>

<p>and can be found as <code>idi</code> in the values list.
</p>


<h3>Value</h3>

<p>A list with following entries
</p>
<table role = "presentation">
<tr><td><code>discrim_item_attribute</code></td>
<td>
<p>Discrimination indices <code class="reqn">DI_{jk}</code>
at item level for each attribute</p>
</td></tr>
<tr><td><code>idi</code></td>
<td>
<p>Item discrimination index <code class="reqn">IDI_j</code></p>
</td></tr>
<tr><td><code>discrim_test</code></td>
<td>
<p>Discrimination index at test level</p>
</td></tr>
</table>


<h3>References</h3>

<p>de la Torre, J. (2008). An empirically based method of Q-matrix validation
for the DINA model: Development and applications.
<em>Journal of Educational Measurement, 45</em>, 343-362.
<br /> http://dx.doi.org/10.1111/j.1745-3984.2008.00069.x
</p>
<p>de la Torre, J., van der Ark, L. A., &amp; Rossi, G. (2018).
Analysis of clinical data from a cognitive diagnosis modeling framework.
<em>Measurement and Evaluation in Counseling and Development, 51</em>(4),
281-296.
https://doi.org/10.1080/07481756.2017.1327286
</p>
<p>Henson, R., DiBello, L., &amp; Stout, B. (2018). A generalized approach to defining item
discrimination for DCMs.
<em>Measurement: Interdisciplinary Research and Perspectives, 16</em>(1), 18-29.
<br /> http://dx.doi.org/10.1080/15366367.2018.1436855
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+cdi.kli">cdi.kli</a></code> for discrimination indices based on the
Kullback-Leibler information.
</p>
<p>For a fitted model <code>mod</code> in the <span class="pkg">GDINA</span> package, discrimination indices can be
extracted by the method <code>extract(mod,"discrim")</code>
(<code><a href="GDINA.html#topic+extract">GDINA::extract</a></code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: DINA and GDINA model
#############################################################################

data(sim.dina, package="CDM")
data(sim.qmatrix, package="CDM")

#-- fit GDINA and DINA model
mod1 &lt;- CDM::gdina( sim.dina, q.matrix=sim.qmatrix )
mod2 &lt;- CDM::din( sim.dina, q.matrix=sim.qmatrix )

#-- compute discrimination indices
dimod1 &lt;- CDM::discrim.index(mod1)
dimod2 &lt;- CDM::discrim.index(mod2)
summary(dimod1)
summary(dimod2)

## End(Not run)
</code></pre>

<hr>
<h2 id='entropy.lca'>
Test-specific and Item-specific Entropy for Latent Class Models
</h2><span id='topic+entropy.lca'></span><span id='topic+summary.entropy.lca'></span>

<h3>Description</h3>

<p>Computes test-specific and item-specific entropy as test-diagnostic
criteria of cognitive diagnostic models (Asparouhov &amp; Muthen, 2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>entropy.lca(object)

## S3 method for class 'entropy.lca'
summary(object, digits=2,  ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="entropy.lca_+3A_object">object</code></td>
<td>

<p>Object of class <code><a href="#topic+din">din</a></code>, <code><a href="#topic+gdina">gdina</a></code> or <code><a href="#topic+mcdina">mcdina</a></code>.
For the <code>summary</code> method, it is the result of <code>entropy.lca</code>.
</p>
</td></tr>
<tr><td><code id="entropy.lca_+3A_digits">digits</code></td>
<td>
<p>Number of digits to round</p>
</td></tr>
<tr><td><code id="entropy.lca_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the data frame <code>entropy</code> as an entry.
</p>


<h3>References</h3>

<p>Asparouhov, T. &amp; Muthen, B. (2014). <em>Variable-specific entropy
contribution</em>. Technical Appendix. http://www.statmodel.com/7_3_papers.shtml
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+cdi.kli">cdi.kli</a></code> for test diagnostic indices based on the
Kullback-Leibler information and <code><a href="#topic+cdm.est.class.accuracy">cdm.est.class.accuracy</a></code>
for calculating the classification accuracy.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: Entropy for DINA model
#############################################################################

data(sim.dina, package="CDM")
data(sim.qmatrix, package="CDM")

# fit DINA Model
mod1 &lt;- CDM::din( sim.dina, q.matrix=sim.qmatrix, rule="DINA")
summary(mod1)
# compute entropy for test and items
emod1 &lt;- CDM::entropy.lca( mod1 )
summary(emod1)

## Not run: 
#############################################################################
# EXAMPLE 2: Entropy for polytomous GDINA model
#############################################################################

data(data.pgdina, package="CDM")

dat &lt;- data.pgdina$dat
q.matrix &lt;- data.pgdina$q.matrix

# pGDINA model with "DINA rule"
mod1 &lt;- CDM::gdina( dat, q.matrix=q.matrix, rule="DINA")
summary(mod1)

# compute entropy
emod1 &lt;- CDM::entropy.lca( mod1 )
summary(emod1)

#############################################################################
# EXAMPLE 3: Entropy for MCDINA model
#############################################################################

data(data.cdm02, package="CDM")

dat &lt;- data.cdm02$data
q.matrix &lt;- data.cdm02$q.matrix

# estimate model with polytomous atribute
mod1 &lt;- CDM::mcdina( dat, q.matrix=q.matrix )
summary(mod1)
# computre entropy
emod1 &lt;- CDM::entropy.lca( mod1 )
summary(emod1)

## End(Not run)
</code></pre>

<hr>
<h2 id='equivalent.dina'>
Determination of a Statistically Equivalent DINA Model
</h2><span id='topic+equivalent.dina'></span>

<h3>Description</h3>

<p>This function determines a statistically equivalent DINA model
given a Q-matrix using the method of von Davier (2014).
Thereby, the dimension of the skill space is expanded, but in the
reparameterized version, the Q-matrix has a simple structure
or the IRT model is no longer be conjuctive (like in DINA) due
to a redefinition of the skill space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equivalent.dina(q.matrix, reparameterization="B")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="equivalent.dina_+3A_q.matrix">q.matrix</code></td>
<td>

<p>The Q-matrix (see <code><a href="#topic+din">din</a></code>)
</p>
</td></tr>
<tr><td><code id="equivalent.dina_+3A_reparameterization">reparameterization</code></td>
<td>

<p>The used reparameterization (see von Davier, 2014). <code>A</code> and <code>B</code>
are possible reparameterizations.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with following entries
</p>
<table role = "presentation">
<tr><td><code>q.matrix</code></td>
<td>
<p>Original Q-matrix</p>
</td></tr>
<tr><td><code>q.matrix.ast</code></td>
<td>
<p>Reparameterized Q-matrix</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>Original skill space</p>
</td></tr>
<tr><td><code>alpha.ast</code></td>
<td>
<p>Reparameterized skill space</p>
</td></tr>
</table>


<h3>References</h3>

<p>von Davier, M. (2014). The DINA model as a constrained general
diagnostic model: Two variants of a model equivalency.
<em>British Journal of Mathematical and Statistical Psychology, 67</em>, 49-71.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: Toy example
#############################################################################

# define a Q-matrix
Q &lt;- matrix( c( 1,0,0,  0,1,0,
        0,0,1,   1,0,1,  1,1,1 ), byrow=TRUE, ncol=3 )
Q &lt;- Q[ rep(1:(nrow(Q)),each=2), ]

# equivalent DINA model (using the default reparameterization B)
res1 &lt;- CDM::equivalent.dina( q.matrix=Q )
res1

# equivalent DINA model (reparametrization A)
res2 &lt;- CDM::equivalent.dina( q.matrix=Q, reparameterization="A")
res2

## Not run: 
#############################################################################
# EXAMPLE 2: Estimation with two equivalent DINA models
#############################################################################

# simulate data
set.seed(789)
D &lt;- ncol(Q)
mean.alpha &lt;- c( -.5, .5, 0  )
r1 &lt;- .5
Sigma.alpha &lt;- matrix( r1, D, D ) + diag(1-r1,D)
dat1 &lt;- CDM::sim.din( N=2000, q.matrix=Q, mean=mean.alpha, Sigma=Sigma.alpha )

# estimate DINA model
mod1 &lt;- CDM::din( dat1$dat, q.matrix=Q )

# estimate equivalent DINA model
mod2 &lt;- CDM::din( dat1$dat, q.matrix=res1$q.matrix.ast, skillclasses=res1$alpha.ast)
# restricted skill space must be defined by using the argument 'skillclasses'

# compare model summaries
summary(mod2)
summary(mod1)

# compare estimated item parameters
cbind( mod2$coef, mod1$coef )

# compare estimated skill class probabilities
round( cbind( mod2$attribute.patt, mod1$attribute.patt ), 4 )


#############################################################################
# EXAMPLE 3: Examples from von Davier (2014)
#############################################################################

# define Q-matrix
Q &lt;- matrix( 0, nrow=8, ncol=3 )
Q[2, ] &lt;- c(1,0,0)
Q[3, ] &lt;- c(0,1,0)
Q[4, ] &lt;- c(1,1,0)
Q[5, ] &lt;- c(0,0,1)
# Q[6, ] &lt;- c(1,0,1)
Q[6, ] &lt;- c(0,0,1)
Q[7, ] &lt;- c(0,1,1)
Q[8, ] &lt;- c(1,1,1)

#- parametrization A
res1 &lt;- CDM::equivalent.dina(q.matrix=Q, reparameterization="A")
res1

#- parametrization B
res2 &lt;- CDM::equivalent.dina(q.matrix=Q, reparameterization="B")
res2

## End(Not run)
</code></pre>

<hr>
<h2 id='eval_likelihood'>
Evaluation of Likelihood
</h2><span id='topic+eval_likelihood'></span><span id='topic+prep_data_long_format'></span>

<h3>Description</h3>

<p>The function <code>eval_likelihood</code> evaluates the likelihood given item
responses and item response probabilities.
</p>
<p>The function <code>prep_data_long_format</code> stores the matrix of
item responses in a long format omitted all missing responses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_likelihood(data, irfprob, prior=NULL, normalization=FALSE, N=NULL)

prep_data_long_format(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eval_likelihood_+3A_data">data</code></td>
<td>

<p>Dataset containing item responses in wide format or long format
(generated by <code>prep_data_long_format</code>).
</p>
</td></tr>
<tr><td><code id="eval_likelihood_+3A_irfprob">irfprob</code></td>
<td>

<p>Array containing item responses probabilities, format
see <code><a href="#topic+IRT.irfprob">IRT.irfprob</a></code>
</p>
</td></tr>
<tr><td><code id="eval_likelihood_+3A_prior">prior</code></td>
<td>

<p>Optional prior (matrix or vector)
</p>
</td></tr>
<tr><td><code id="eval_likelihood_+3A_normalization">normalization</code></td>
<td>

<p>Logical indicating whether posterior should be normalized
</p>
</td></tr>
<tr><td><code id="eval_likelihood_+3A_n">N</code></td>
<td>
<p>Number of persons (optional)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Likelihood data.ecpe
#############################################################################

data(data.ecpe, package="CDM")
dat &lt;- data.ecpe$dat[,-1]
Q &lt;- data.ecpe$q.matrix

#*** store data matrix in long format
data_long &lt;- CDM::prep_data_long_format(data)
str(data_long)

#** estimate GDINA model
mod &lt;- CDM::gdina(dat, q.matrix=Q)
summary(mod)

#** extract data, item response functions and prior
data &lt;- CDM::IRT.data(mod)
irfprob &lt;- CDM::IRT.irfprob(mod)
prob_theta &lt;- attr( irfprob, "prob.theta")

#** compute likelihood
lmod &lt;- CDM::eval_likelihood(data=data, irfprob=irfprob)
max( abs( lmod - CDM::IRT.likelihood(mod) ))

#** compute posterior
pmod &lt;- CDM::eval_likelihood(data=data, irfprob=irfprob, prior=prob.theta,
            normalization=TRUE)
max( abs( pmod - CDM::IRT.posterior(mod) ))

## End(Not run)
</code></pre>

<hr>
<h2 id='fraction.subtraction.data'>
Fraction Subtraction Data
</h2><span id='topic+fraction.subtraction.data'></span>

<h3>Description</h3>

<p>Tatsuoka's (1984) fraction subtraction data set is comprised of
responses to <code class="reqn">J=20</code> fraction subtraction test items from <code class="reqn">N=536</code>
middle school students.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data(fraction.subtraction.data)
</code></pre>


<h3>Format</h3>

<p>The <code>fraction.subtraction.data</code> data frame consists of 536
rows and 20 columns, representing the responses of the <code class="reqn">N=536</code>
students to each of the <code class="reqn">J=20</code> test items.  Each row in the data set
corresponds to the responses of a particular student.  Thereby a &quot;1&quot;
denotes that a correct response was recorded, while &quot;0&quot; denotes an
incorrect response.  The other way round, each column corresponds
to all responses to a particular item.
</p>


<h3>Details</h3>

<p>The items used for the fraction subtraction test originally appeared
in Tatsuoka (1984) and are published in Tatsuoka (2002).  They
can also be found in DeCarlo (2011).  All test items are based on 8
attributes (e.g. convert a whole number to a fraction, separate a whole
number from a fraction or simplify before subtracting).  The complete
list of skills can be found in <code><a href="#topic+fraction.subtraction.qmatrix">fraction.subtraction.qmatrix</a></code>.
</p>


<h3>Source</h3>

<p>The Royal Statistical Society Datasets Website, Series C,
Applied Statistics, Data analytic methods for latent partially
ordered classification models:<br />
URL: <em>http://www.blackwellpublishing.com/rss/Volumes/Cv51p2_read2.htm</em>
</p>


<h3>References</h3>

<p>DeCarlo, L. T. (2011). On the analysis of fraction subtraction data:
The DINA Model, classification, latent class sizes, and the Q-Matrix.
<em>Applied Psychological Measurement, 35</em>, 8&ndash;26.
</p>
<p>Tatsuoka, C. (2002). Data analytic methods for latent partially ordered classification
models. <em>Journal of the Royal Statistical Society, Series C, Applied Statistics,
51</em>, 337&ndash;350.
</p>
<p>Tatsuoka, K. (1984). <em>Analysis of errors in fraction addition and subtraction
problems</em>. Final Report for NIE-G-81-0002, University of Illinois, Urbana-Champaign.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fraction.subtraction.qmatrix">fraction.subtraction.qmatrix</a></code> for the corresponding Q-matrix.
</p>

<hr>
<h2 id='fraction.subtraction.qmatrix'>
Fraction Subtraction Q-Matrix
</h2><span id='topic+fraction.subtraction.qmatrix'></span>

<h3>Description</h3>

<p>The Q-Matrix corresponding to Tatsuoka (1984) fraction subtraction data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data(fraction.subtraction.qmatrix)
</code></pre>


<h3>Format</h3>

<p>The <code>fraction.subtraction.qmatrix</code> data frame consists of <code class="reqn">J=20</code>
rows and <code class="reqn">K=8</code> columns, specifying the attributes that are believed to be
involved in solving the items.  Each row in the data frame represents an item
and the entries in the row indicate whether an attribute is needed to master
the item (denoted by a &quot;1&quot;) or not (denoted by a &quot;0&quot;).  The attributes for the
fraction subtraction data set are the following:
</p>

<dl>
<dt><code>alpha1</code></dt><dd><p>convert a whole number to a fraction, </p>
</dd>
<dt><code>alpha2</code></dt><dd><p>separate a whole number from a fraction, </p>
</dd>
<dt><code>alpha3</code></dt><dd><p>simplify before subtracting, </p>
</dd>
<dt><code>alpha4</code></dt><dd><p>find a common denominator, </p>
</dd>
<dt><code>alpha5</code></dt><dd><p>borrow from whole number part, </p>
</dd>
<dt><code>alpha6</code></dt><dd><p>column borrow to subtract the second numerator from the first, </p>
</dd>
<dt><code>alpha7</code></dt><dd><p>subtract numerators, </p>
</dd>
<dt><code>alpha8</code></dt><dd><p>reduce answers to simplest form.  </p>
</dd>
</dl>



<h3>Details</h3>

<p>This Q-matrix can be found in DeCarlo (2011).  It is the same used by
de la Torre and Douglas (2004).
</p>


<h3>Source</h3>

<p>DeCarlo, L. T. (2011). On the analysis of fraction subtraction data:
The DINA Model, classification, latent class sizes, and the Q-Matrix.
<em>Applied Psychological Measurement</em>, <b>35</b>, 8&ndash;26.
</p>


<h3>References</h3>

<p>de la Torre, J. and Douglas, J. (2004). Higher-order latent trait models
for cognitive diagnosis. <em>Psychometrika, 69</em>, 333&ndash;353.
</p>
<p>Tatsuoka, C. (2002). Data analytic methods for latent partially ordered classification
models. <em>Journal of the Royal Statistical Society, Series C, Applied Statistics,
51</em>, 337&ndash;350.
</p>
<p>Tatsuoka, K. (1984) <em>Analysis of errors in fraction addition and subtraction
problems</em>. Final Report for NIE-G-81-0002, University of Illinois, Urbana-Champaign.
</p>

<hr>
<h2 id='gdd'>
Generalized Distance Discriminating Method
</h2><span id='topic+gdd'></span>

<h3>Description</h3>

<p>Performs the generalized distance discriminating method
(GDD; Sun, Xin, Zhang, &amp; de la Torre, 2013) for
dichotomous data which is a method for classifying students into
skill profiles based on a preliminary unidimensional calibration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdd(data, q.matrix, theta, b, a, skillclasses=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gdd_+3A_data">data</code></td>
<td>

<p>Data frame with <code class="reqn">N \times J</code> item responses
</p>
</td></tr>
<tr><td><code id="gdd_+3A_q.matrix">q.matrix</code></td>
<td>

<p>The Q-matrix
</p>
</td></tr>
<tr><td><code id="gdd_+3A_theta">theta</code></td>
<td>

<p>Estimated person ability
</p>
</td></tr>
<tr><td><code id="gdd_+3A_b">b</code></td>
<td>

<p>Estimated item intercept from a 2PL model (see Details)
</p>
</td></tr>
<tr><td><code id="gdd_+3A_a">a</code></td>
<td>

<p>Estimated item slope from a 2PL model (see Details)
</p>
</td></tr>
<tr><td><code id="gdd_+3A_skillclasses">skillclasses</code></td>
<td>

<p>Optional matrix of skill classes used for estimation
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the parameters in the arguments follow the item response model
</p>
<p style="text-align: center;"><code class="reqn"> logit P( X_{nj}=1 | \theta_n )=b_j + a_j \theta_n </code>
</p>

<p>which is employed in the <code>gdm</code> function.
</p>


<h3>Value</h3>

<p>A list with following entries
</p>
<table role = "presentation">
<tr><td><code>skillclass.est</code></td>
<td>
<p>Estimated skill class</p>
</td></tr>
<tr><td><code>distmatrix</code></td>
<td>
<p>Distances for every person and every skill class</p>
</td></tr>
<tr><td><code>skillspace</code></td>
<td>
<p>Used skill space for estimation</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>Used person parameter estimate</p>
</td></tr>
</table>


<h3>References</h3>

<p>Sun, J., Xin, T., Zhang, S., &amp; de la Torre, J. (2013).
A polytomous extension of the generalized distance discriminating method.
<em>Applied Psychological Measurement, 37</em>, 503-521.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: GDD for sim.dina
#############################################################################

data(sim.dina, package="CDM")
data(sim.qmatrix, package="CDM")

data &lt;- sim.dina
q.matrix &lt;- sim.qmatrix

# estimate 1PL (use irtmodel="2PL" for 2PL estimation)
mod &lt;- CDM::gdm( data, irtmodel="1PL", theta.k=seq(-6,6,len=21),
                    decrease.increments=TRUE, conv=.001, globconv=.001)
# extract item parameters in parametrization b + a*theta
b &lt;- mod$b[,1]
a &lt;- mod$a[,,1]
# extract person parameter estimate
theta &lt;- mod$person$EAP.F1

# generalized distance discriminating method
res &lt;- CDM::gdd( data, q.matrix, theta=theta, b=b, a=a )
</code></pre>

<hr>
<h2 id='gdina'>
Estimating the Generalized DINA (GDINA) Model
</h2><span id='topic+gdina'></span><span id='topic+summary.gdina'></span><span id='topic+plot.gdina'></span><span id='topic+print.gdina'></span>

<h3>Description</h3>

<p>This function implements the generalized DINA model for dichotomous
attributes (GDINA; de la Torre, 2011) and polytomous attributes
(pGDINA; Chen &amp; de la Torre, 2013, 2018).
In addition, multiple group estimation
is also possible using the <code>gdina</code> function. This function also
allows for the estimation of a higher order GDINA model
(de la Torre &amp; Douglas, 2004).
Polytomous item responses are treated by specifying a sequential
GDINA model (Ma &amp; de la Torre, 2016; Tutz, 1997).
The simulataneous modeling of skills and misconceptions (bugs) can be
also estimated within the GDINA framework (see Kuo, Chen &amp; de la Torre, 2018;
see argument <code>rule</code>).
</p>
<p>The estimation can also be conducted by posing monotonocity
constraints (Hong, Chang, &amp; Tsai, 2016) using the argument <code>mono.constr</code>.
Moreover, regularization methods SCAD, lasso, ridge, SCAD-L2 and
truncated <code class="reqn">L_1</code> penalty (TLP) for item parameters
can be employed (Xu &amp; Shang, 2018).
</p>
<p>Normally distributed priors can be specified for item parameters
(item intercepts and item slopes). Note that (for convenience) the
prior specification holds simultaneously for all items.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdina(data, q.matrix, skillclasses=NULL, conv.crit=0.0001, dev.crit=.1,  maxit=1000,
    linkfct="identity", Mj=NULL, group=NULL, invariance=TRUE,method=NULL,
    delta.init=NULL, delta.fixed=NULL, delta.designmatrix=NULL,
    delta.basispar.lower=NULL, delta.basispar.upper=NULL, delta.basispar.init=NULL,
    zeroprob.skillclasses=NULL, attr.prob.init=NULL, attr.prob.fixed=NULL,
    reduced.skillspace=NULL, reduced.skillspace.method=2, HOGDINA=-1, Z.skillspace=NULL,
    weights=rep(1, nrow(data)), rule="GDINA", bugs=NULL, regular_lam=0,
    regular_type="none", regular_alpha=NA, regular_tau=NA, regular_weights=NULL,
    mono.constr=FALSE, prior_intercepts=NULL, prior_slopes=NULL, progress=TRUE,
    progress.item=FALSE, mstep_iter=10, mstep_conv=1E-4, increment.factor=1.01,
    fac.oldxsi=0, max.increment=.3, avoid.zeroprobs=FALSE, seed=0,
    save.devmin=TRUE, calc.se=TRUE, se_version=1, PEM=TRUE, PEM_itermax=maxit,
    cd=FALSE, cd_steps=1, mono_maxiter=10, freq_weights=FALSE, optimizer="CDM", ...)

## S3 method for class 'gdina'
summary(object, digits=4, file=NULL,  ...)

## S3 method for class 'gdina'
plot(x, ask=FALSE,  ...)

## S3 method for class 'gdina'
print(x,  ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gdina_+3A_data">data</code></td>
<td>
<p>A required <code class="reqn">N \times J</code> data matrix
containing integer responses, 0, 1, ..., K. Polytomous
item responses are treated by the sequential GDINA model.
<code>NA</code> values are allowed.
</p>
</td></tr>
<tr><td><code id="gdina_+3A_q.matrix">q.matrix</code></td>
<td>
<p>A required integer <code class="reqn">J \times K</code> matrix containing
attributes not required or required, 0 or 1, to master the items in case
of dichotomous attributes or integers in case of polytomous attributes.
For polytomous item responses the Q-matrix must also include the
item name and item category, see Example 11.
</p>
</td></tr>
<tr><td><code id="gdina_+3A_skillclasses">skillclasses</code></td>
<td>
<p>An optional matrix for determining the skill space.
The argument can be used if a user wants less than <code class="reqn">2^K</code> skill classes.
</p>
</td></tr>
<tr><td><code id="gdina_+3A_conv.crit">conv.crit</code></td>
<td>

<p>Convergence criterion for maximum absolute change in item parameters
</p>
</td></tr>
<tr><td><code id="gdina_+3A_dev.crit">dev.crit</code></td>
<td>

<p>Convergence criterion for maximum absolute change in deviance
</p>
</td></tr>
<tr><td><code id="gdina_+3A_maxit">maxit</code></td>
<td>

<p>Maximum number of iterations
</p>
</td></tr>
<tr><td><code id="gdina_+3A_linkfct">linkfct</code></td>
<td>

<p>A string which indicates the link function for the GDINA model.
Options are <code>"identity"</code> (identity link),
<code>"logit"</code> (logit link) and <code>"log"</code> (log link). The default is the
<code>"identity"</code> link. Note that the link function is chosen
for the whole model (i.e. for all items).
</p>
</td></tr>
<tr><td><code id="gdina_+3A_mj">Mj</code></td>
<td>

<p>A list of design matrices and labels for each item.
The definition of <code>Mj</code> follows the
definition of <code class="reqn">M_j</code> in de la Torre (2011).
Please study the value <code>Mj</code> of the function in
default analysis. See Example 3.
</p>
</td></tr>
<tr><td><code id="gdina_+3A_group">group</code></td>
<td>
<p>A vector of group identifiers for multiple group
estimation. Default is <code>NULL</code> (no multiple group estimation).
</p>
</td></tr>
<tr><td><code id="gdina_+3A_invariance">invariance</code></td>
<td>
<p>Logical indicating whether invariance of item parameters
is assumed for multiple group models. If a subset of items should
be treated as noninvariant, then <code>invariance</code> can be a vector
of item names.
</p>
</td></tr>
<tr><td><code id="gdina_+3A_method">method</code></td>
<td>
<p>Estimation method for item parameters (see)
(de la Torre, 2011). The default <code>"WLS"</code>
weights probabilities attribute classes by a weighting
matrix <code class="reqn">W_j</code> of expected frequencies,
whereas the method <code>"ULS"</code> perform unweighted least squares
estimation on expected frequencies.
The method <code>"ML"</code> directly maximizes the log-likelihood
function.  The <code>"ML"</code> method is a bit slower but can be
much more stable, especially in the case of the RRUM model.
Only for the RRUM model, the default is changed to
<code>method="ML"</code> if not specified otherwise.
</p>
</td></tr>
<tr><td><code id="gdina_+3A_delta.init">delta.init</code></td>
<td>
<p>List with initial <code class="reqn">\delta</code> parameters</p>
</td></tr>
<tr><td><code id="gdina_+3A_delta.fixed">delta.fixed</code></td>
<td>
<p>List with fixed <code class="reqn">\delta</code> parameters.
For free estimated parameters <code>NA</code> must be declared.</p>
</td></tr>
<tr><td><code id="gdina_+3A_delta.designmatrix">delta.designmatrix</code></td>
<td>

<p>A design matrix for restrictions on delta. See Example 4.
</p>
</td></tr>
<tr><td><code id="gdina_+3A_delta.basispar.lower">delta.basispar.lower</code></td>
<td>

<p>Lower bounds for delta basis parameters.
</p>
</td></tr>
<tr><td><code id="gdina_+3A_delta.basispar.upper">delta.basispar.upper</code></td>
<td>

<p>Upper bounds for delta basis parameters.
</p>
</td></tr>
<tr><td><code id="gdina_+3A_delta.basispar.init">delta.basispar.init</code></td>
<td>

<p>An optional vector of starting values for the basis parameters of delta.
This argument only applies when using a designmatrix for delta,
i.e. <code>delta.designmatrix</code> is not <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="gdina_+3A_zeroprob.skillclasses">zeroprob.skillclasses</code></td>
<td>
<p>An optional vector of integers which indicates which skill
classes should have zero probability. Default is NULL
(no skill classes with zero probability).</p>
</td></tr>
<tr><td><code id="gdina_+3A_attr.prob.init">attr.prob.init</code></td>
<td>
<p>Initial probabilities of skill distribution.</p>
</td></tr>
<tr><td><code id="gdina_+3A_attr.prob.fixed">attr.prob.fixed</code></td>
<td>
<p>Vector or matrix with fixed probabilities of skill distribution.</p>
</td></tr>
<tr><td><code id="gdina_+3A_reduced.skillspace">reduced.skillspace</code></td>
<td>
<p>A logical which indicates if the latent class skill space dimension
should be reduced (see Xu &amp; von Davier, 2008). The default is <code>NULL</code>
which applies skill space reduction for more than four skills.
The dimensional reduction is only well defined for more than three skills.
If the argument <code>zeroprob.skillclasses</code> is not <code>NULL</code>, then
<code>reduced.skillspace</code> is set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="gdina_+3A_reduced.skillspace.method">reduced.skillspace.method</code></td>
<td>
<p>Computation method for skill space reduction
in case of <code>reduced.skillspace=TRUE</code>. The default is <code>2</code>
which is computationally more efficient but introduced in <span class="pkg">CDM</span> 2.6.
For reasons of compatibility of former <span class="pkg">CDM</span> versions (<code class="reqn">\le</code> 2.5),
<code>reduced.skillspace.method=1</code> uses the older implemented
method. In case of non-convergence with the new method, please try
the older method.
</p>
</td></tr>
<tr><td><code id="gdina_+3A_hogdina">HOGDINA</code></td>
<td>
<p>Values of -1, 0 or 1 indicating if a higher order GDINA
model (see Details) should be estimated.
The default value of -1 corresponds to the case that no higher order
factor is assumed to exist. A value of 0 corresponds to independent
attributes. A value of 1 assumes the existence of a higher order
factor. </p>
</td></tr>
<tr><td><code id="gdina_+3A_z.skillspace">Z.skillspace</code></td>
<td>
<p>A user specified design matrix for the skill space reduction
as described in Xu and von Davier (2008). See in the Examples section for
applications. See Example 6.
</p>
</td></tr>
<tr><td><code id="gdina_+3A_weights">weights</code></td>
<td>

<p>An optional vector of sample weights.
</p>
</td></tr>
<tr><td><code id="gdina_+3A_rule">rule</code></td>
<td>

<p>A string or a vector of itemwise condensation rules. Allowed entries are
<code>GDINA</code>, <code>DINA</code>, <code>DINO</code>, <code>ACDM</code> (additive
cognitive diagnostic model) and <code>RRUM</code> (reduced reparametrized
unified model, RRUM, see Details).
The rule <code>GDINA1</code> applies
only main effects in the GDINA model which is equivalent to <code>ACDM</code>.
The rule <code>GDINA2</code> applies to all main effects and second-order
interactions of the attributes. If some item is specified as <code>RRUM</code>,
then for all the items the reduced RUM will be estimated which means
that the log link function and the <code>ACDM</code> condensation rule is used.
In the output, the entry <code>rrum.params</code> contains the parameters
transformed in the RUM parametrization.
If <code>rule</code> is a string, the condensation rule applies to all items.
If <code>rule</code> is a vector, condensation rules can be specified itemwise.
The default is <code>GDINA</code> for all items.
</p>
</td></tr>
<tr><td><code id="gdina_+3A_bugs">bugs</code></td>
<td>
<p>Character vector indicating which columns in the Q-matrix
refer to bugs (misconceptions). This is only available if some <code>rule</code>
is set to <code>"SISM"</code>. Note that bugs must be included as last columns
in the Q-matrix.</p>
</td></tr>
<tr><td><code id="gdina_+3A_regular_lam">regular_lam</code></td>
<td>
<p>Regularization parameter <code class="reqn">\lambda</code></p>
</td></tr>
<tr><td><code id="gdina_+3A_regular_type">regular_type</code></td>
<td>
<p>Type of regularization. Can be <code>scad</code> (SCAD penalty),
<code>lasso</code> (lasso penalty), <code>ridge</code> (ridge penalty),
<code>elnet</code> (elastic net), <code>scadL2</code> (SCAD-<code class="reqn">L_2</code>;
Zeng &amp; Xie, 2014), <code>tlp</code> (truncated <code class="reqn">L_1</code> penalty; Xu &amp; Shang, 2018;
Shen, Pan, &amp; Zhu, 2012), <code>mcp</code> (MCP penalty; Zhang, 2010)
or <code>none</code> (no regularization).</p>
</td></tr>
<tr><td><code id="gdina_+3A_regular_alpha">regular_alpha</code></td>
<td>
<p>Regularization parameter <code class="reqn">\alpha</code>
(applicable for elastic net or SCAD-L2.</p>
</td></tr>
<tr><td><code id="gdina_+3A_regular_tau">regular_tau</code></td>
<td>
<p>Regularization parameter <code class="reqn">\tau</code> for truncated
<code class="reqn">L_1</code> penalty.</p>
</td></tr>
<tr><td><code id="gdina_+3A_regular_weights">regular_weights</code></td>
<td>
<p>Optional list of item parameter weights used for
penalties in regularized estimation (see Example 13)</p>
</td></tr>
<tr><td><code id="gdina_+3A_mono.constr">mono.constr</code></td>
<td>
<p>Logical indicating whether monotonicity constraints
should be fulfilled in estimation (implemented by the increasing penalty method; see
Nash, 2014, p. 156).</p>
</td></tr>
<tr><td><code id="gdina_+3A_prior_intercepts">prior_intercepts</code></td>
<td>
<p>Vector with mean and standard deviation for prior
of random intercepts (applies to all items)</p>
</td></tr>
<tr><td><code id="gdina_+3A_prior_slopes">prior_slopes</code></td>
<td>
<p>Vector with mean and standard deviation for prior
of random slopes (applies to all items and all parameters)</p>
</td></tr>
<tr><td><code id="gdina_+3A_progress">progress</code></td>
<td>
<p>An optional logical indicating whether the function
should print the progress of iteration in the estimation process.  </p>
</td></tr>
<tr><td><code id="gdina_+3A_progress.item">progress.item</code></td>
<td>

<p>An optional logical indicating whether item wise progress should
be displayed
</p>
</td></tr>
<tr><td><code id="gdina_+3A_mstep_iter">mstep_iter</code></td>
<td>
<p>Number of iterations in M-step if <code>method="ML"</code>.</p>
</td></tr>
<tr><td><code id="gdina_+3A_mstep_conv">mstep_conv</code></td>
<td>
<p>Convergence criterion in M-step if <code>method="ML"</code>.</p>
</td></tr>
<tr><td><code id="gdina_+3A_increment.factor">increment.factor</code></td>
<td>
<p>A factor larger than 1 (say 1.1) to control
maximum increments in item parameters. This parameter
can be used in case of nonconvergence.
</p>
</td></tr>
<tr><td><code id="gdina_+3A_fac.oldxsi">fac.oldxsi</code></td>
<td>
<p>A convergence acceleration factor between 0 and 1 which
defines the weight of previously estimated values in
current parameter updates.</p>
</td></tr>
<tr><td><code id="gdina_+3A_max.increment">max.increment</code></td>
<td>
<p>Maximum size of change in increments in M steps
of EM algorithm when <code>method="ML"</code> is used.</p>
</td></tr>
<tr><td><code id="gdina_+3A_avoid.zeroprobs">avoid.zeroprobs</code></td>
<td>
<p>An optional logical indicating whether for estimating
item parameters probabilities occur. Especially if
not a skill classes are used, it is recommended to switch
the argument to <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="gdina_+3A_seed">seed</code></td>
<td>
<p>Simulation seed for initial parameters. A value of zero corresponds
to deterministic starting values, an integer value different from
zero to random initial values with <code>set.seed(seed)</code>.</p>
</td></tr>
<tr><td><code id="gdina_+3A_save.devmin">save.devmin</code></td>
<td>
<p>An optional logical indicating whether intermediate
estimates should be saved corresponding to minimal deviance.
Setting the argument to <code>FALSE</code> could help for preventing
working memory overflow.</p>
</td></tr>
<tr><td><code id="gdina_+3A_calc.se">calc.se</code></td>
<td>
<p>Optional logical indicating whether standard
errors should be calculated.</p>
</td></tr>
<tr><td><code id="gdina_+3A_se_version">se_version</code></td>
<td>
<p>Integer for calculation method of standard errors.
<code>se_version=1</code> is based on the observed log likelihood and included
since <span class="pkg">CDM</span> 5.1 and is the default. Comparability with
previous <span class="pkg">CDM</span> versions can be obtained with <code>se_version=0</code>.
</p>
</td></tr>
<tr><td><code id="gdina_+3A_pem">PEM</code></td>
<td>
<p>Logical indicating whether the P-EM acceleration should be
applied (Berlinet &amp; Roland, 2012).</p>
</td></tr>
<tr><td><code id="gdina_+3A_pem_itermax">PEM_itermax</code></td>
<td>
<p>Number of iterations in which the P-EM method should be
applied.</p>
</td></tr>
<tr><td><code id="gdina_+3A_cd">cd</code></td>
<td>
<p>Logical indicating whether coordinate descent algorithm should be used.</p>
</td></tr>
<tr><td><code id="gdina_+3A_cd_steps">cd_steps</code></td>
<td>
<p>Number of steps for each parameter in coordinate descent algorithm</p>
</td></tr>
<tr><td><code id="gdina_+3A_mono_maxiter">mono_maxiter</code></td>
<td>
<p>Maximum number of iterations for fulfilling the
monotonicity constraint</p>
</td></tr>
<tr><td><code id="gdina_+3A_freq_weights">freq_weights</code></td>
<td>
<p>Logical indicating whether frequency weights should
be used. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="gdina_+3A_optimizer">optimizer</code></td>
<td>
<p>String indicating which optimizer should be used in
M-step estimation in case of <code>method="ML"</code>.
The internal optimizer of <span class="pkg">CDM</span> can be requested by
<code>optimizer="CDM"</code>. The optimization with <code>stats::optim</code>
can be requested by <code>optimizer="optim"</code>.
For the RRUM model, it is always chosen
<code>optimizer="optim"</code>. </p>
</td></tr>
<tr><td><code id="gdina_+3A_object">object</code></td>
<td>
<p>A required object of class <code>gdina</code>, obtained
from a call to the function <code><a href="#topic+gdina">gdina</a></code>.  </p>
</td></tr>
<tr><td><code id="gdina_+3A_digits">digits</code></td>
<td>
<p>Number of digits after decimal separator to display.  </p>
</td></tr>
<tr><td><code id="gdina_+3A_file">file</code></td>
<td>
<p>Optional file name for a file in which <code>summary</code>
should be sinked.</p>
</td></tr>
<tr><td><code id="gdina_+3A_x">x</code></td>
<td>
<p>A required object of class <code>gdina</code> </p>
</td></tr>
<tr><td><code id="gdina_+3A_ask">ask</code></td>
<td>
<p>A logical indicating whether every separate item should
be displayed in <code>plot.gdina</code></p>
</td></tr>
<tr><td><code id="gdina_+3A_...">...</code></td>
<td>
<p>Optional parameters to be passed to or from other
methods will be ignored.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The estimation is based on an EM algorithm as described in de la Torre (2011).
Item parameters are contained in the <code>delta</code> vector which is a list where
the <code class="reqn">j</code>th entry corresponds to item parameters of the <code class="reqn">j</code>th item.
</p>
<p>The following description refers to the case of dichotomous attributes.
For using polytomous attributes see Chen and de la Torre (2013) and
Example 7 for a definition of the Q-matrix. In this case, <code class="reqn">Q_{ik}=l</code>
means that the <code class="reqn">i</code>th item requires the mastery (at least) of level
<code class="reqn">l</code> of attribute <code class="reqn">k</code>.
</p>
<p>Assume that two skills <code class="reqn">\alpha_1</code> and <code class="reqn">\alpha_2</code> are required for
mastering item <code class="reqn">j</code>. Then the GDINA model can be written as
</p>
<p style="text-align: center;"><code class="reqn"> g [ P( X_{nj}=1 | \alpha_n ) ]=\delta_{j0} + \delta_{j1} \alpha_{n1} +
            \delta_{j2} \alpha_{n2} + \delta_{j12} \alpha_{n1} \alpha_{n2}
        </code>
</p>

<p>which is a two-way GDINA-model (the <code>rule="GDINA2"</code> specification) with a
link function <code class="reqn">g</code> (which can be the identity, logit or logarithmic link).
If the specification
<code>ACDM</code> is chosen, then <code class="reqn">\delta_{j12}=0</code>.
The DINA model (<code>rule="DINA"</code>) assumes <code class="reqn"> \delta_{j1}=\delta_{j2}=0</code>.
</p>
<p>For the reduced RUM model (<code>rule="RRUM"</code>), the item response model is
</p>
<p style="text-align: center;"><code class="reqn">P(X_{nj}=1 | \alpha_n )=\pi_i^\ast \cdot r_{i1}^{1-\alpha_{i1} }
    \cdot r_{i2}^{1-\alpha_{i2} } </code>
</p>
<p> From this equation, it is obvious, that
this model is equivalent to an additive model (<code>rule="ACDM"</code>) with
a logarithmic link function (<code>linkfct="log"</code>).
</p>
<p>If a reduced skillspace (<code>reduced.skillspace=TRUE</code>) is employed, then the
logarithm of probability distribution of the attributes is modeled as a
log-linear model:
</p>
<p style="text-align: center;"><code class="reqn"> \log P[ ( \alpha_{n1}, \alpha_{n2}, \ldots, \alpha_{nK} ) ]
    =\gamma_0 + \sum_k \gamma_k \alpha_{nk} +
      \sum_{k &lt; l} \gamma_{kl} \alpha_{nk} \alpha_{nl} </code>
</p>

<p>If a higher order DINA model is assumed (<code>HOGDINA=1</code>), then a higher order
factor <code class="reqn">\theta_n</code> for the attributes is assumed:
</p>
<p style="text-align: center;"><code class="reqn">P( \alpha_{nk}=1 | \theta_n )=\Phi ( a_k \theta_n + b_k ) </code>
</p>

<p>For <code>HOGDINA=0</code>, all attributes <code class="reqn">\alpha_{nk}</code> are assumed to be
independent of each other:
</p>
<p style="text-align: center;"><code class="reqn"> P[ ( \alpha_{n1}, \alpha_{n2}, \ldots, \alpha_{nK} ) ]
    =\prod_k P( \alpha_{nk} ) </code>
</p>

<p>Note that the noncompensatory reduced RUM (NC-RRUM) according
to Rupp and Templin (2008) is the GDINA model with the arguments
<code>rule="ACDM"</code> and <code>linkfct="log"</code>. NC-RRUM can also be
obtained by choosing <code>rule="RRUM"</code>.
</p>
<p>The compensatory RUM (C-RRUM) can be obtained by using the arguments
<code>rule="ACDM"</code> and <code>linkfct="logit"</code>.
</p>
<p>The cognitive diagnosis model for identifying
skills and misconceptions (SISM; Kuo, Chen &amp; de la Torre, 2018) can be
estimated with <code>rule="SISM"</code> (see Example 12).
</p>
<p>The <code>gdina</code> function internally parameterizes the GDINA model as
</p>
<p style="text-align: center;"><code class="reqn"> g [ P( X_{nj}=1 | \alpha_n ) ]=\bm{M}_j ( \alpha _n )
    \bm{\delta}_j
        </code>
</p>

<p>with item-specific design matrices <code class="reqn">\bm{M}_j (\alpha _n ) </code> and item parameters
<code class="reqn">\bm{\delta}_j</code>. Only those attributes are modelled which correspond
to non-zero entries in the Q-matrix. Because the Q-matrix (in <code>q.matrix</code>)
and the design matrices (in <code>M_j</code>; see Example 3) can be
specified by the user, several
cognitive diagnosis models can be estimated. Therefore, some additional extensions
of the DINA model can also be estimated using the <code>gdina</code> function.
These models include the DINA model with multiple strategies
(Huo &amp; de la Torre, 2014)
</p>


<h3>Value</h3>

<p>An object of class <code>gdina</code> with following entries
</p>
<table role = "presentation">
<tr><td><code>coef</code></td>
<td>
<p>Data frame of item parameters</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>List with basis item parameters</p>
</td></tr>
<tr><td><code>se.delta</code></td>
<td>
<p>Standard errors of basis item parameters</p>
</td></tr>
<tr><td><code>probitem</code></td>
<td>
<p>Data frame with model implied conditional item probabilities
<code class="reqn">P(X_i=1 | \bm{\alpha})</code>. These probabilities are displayed
in <code>plot.gdina</code>.
</p>
</td></tr>
<tr><td><code>itemfit.rmsea</code></td>
<td>
<p>The RMSEA item fit index (see <code><a href="#topic+itemfit.rmsea">itemfit.rmsea</a></code>).
</p>
</td></tr>
<tr><td><code>mean.rmsea</code></td>
<td>
<p>Mean of RMSEA item fit indexes.
</p>
</td></tr>
<tr><td><code>loglike</code></td>
<td>
<p>Log-likelihood</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>Deviance</p>
</td></tr>
<tr><td><code>G</code></td>
<td>
<p>Number of groups</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>Sample size</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>AIC</p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>BIC</p>
</td></tr>
<tr><td><code>CAIC</code></td>
<td>
<p>CAIC</p>
</td></tr>
<tr><td><code>Npars</code></td>
<td>
<p>Total number of parameters</p>
</td></tr>
<tr><td><code>Nipar</code></td>
<td>
<p>Number of item parameters</p>
</td></tr>
<tr><td><code>Nskillpar</code></td>
<td>
<p>Number of parameters for skill class distribution</p>
</td></tr>
<tr><td><code>Nskillclasses</code></td>
<td>
<p>Number of skill classes</p>
</td></tr>
<tr><td><code>varmat.delta</code></td>
<td>
<p>Covariance matrix of <code class="reqn">\delta</code> item parameters</p>
</td></tr>
<tr><td><code>posterior</code></td>
<td>
<p>Individual posterior distribution</p>
</td></tr>
<tr><td><code>like</code></td>
<td>
<p>Individual likelihood</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>Original data</p>
</td></tr>
<tr><td><code>q.matrix</code></td>
<td>
<p>Used Q-matrix</p>
</td></tr>
<tr><td><code>pattern</code></td>
<td>
<p>Individual patterns, individual MLE and MAP classifications
and their corresponding probabilities</p>
</td></tr>
<tr><td><code>attribute.patt</code></td>
<td>
<p>Probabilities of skill classes</p>
</td></tr>
<tr><td><code>skill.patt</code></td>
<td>
<p>Marginal skill probabilities</p>
</td></tr>
<tr><td><code>subj.pattern</code></td>
<td>
<p>Individual subject pattern</p>
</td></tr>
<tr><td><code>attribute.patt.splitted</code></td>
<td>
<p>Splitted attribute pattern</p>
</td></tr>
<tr><td><code>pjk</code></td>
<td>
<p>Array of item response probabilities</p>
</td></tr>
<tr><td><code>Mj</code></td>
<td>
<p>Design matrix <code class="reqn">M_j</code> in GDINA algorithm (see de la Torre, 2011)</p>
</td></tr>
<tr><td><code>Aj</code></td>
<td>
<p>Design matrix <code class="reqn">A_j</code> in GDINA algorithm (see de la Torre, 2011)</p>
</td></tr>
<tr><td><code>rule</code></td>
<td>
<p>Used condensation rules</p>
</td></tr>
<tr><td><code>linkfct</code></td>
<td>
<p>Used link function</p>
</td></tr>
<tr><td><code>delta.designmatrix</code></td>
<td>
<p>Designmatrix for item parameters</p>
</td></tr>
<tr><td><code>reduced.skillspace</code></td>
<td>
<p>A logical if skillspace reduction was performed</p>
</td></tr>
<tr><td><code>Z.skillspace</code></td>
<td>
<p>Design matrix for skillspace reduction</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>Parameters <code class="reqn">\delta</code> for skill class representation</p>
</td></tr>
<tr><td><code>covbeta</code></td>
<td>
<p>Standard errors of <code class="reqn">\delta</code> parameters</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Number of iterations</p>
</td></tr>
<tr><td><code>rrum.params</code></td>
<td>
<p>Parameters in the parametrization of the reduced RUM model
if <code>rule="RRUM"</code>.</p>
</td></tr>
<tr><td><code>group.stat</code></td>
<td>
<p>Group statistics (sample sizes, group labels)</p>
</td></tr>
<tr><td><code>HOGDINA</code></td>
<td>
<p>The used value of <code>HOGDINA</code></p>
</td></tr>
<tr><td><code>mono.constr</code></td>
<td>
<p>Monotonicity constraint</p>
</td></tr>
<tr><td><code>regularization</code></td>
<td>
<p>Logical indicating whether regularization is used</p>
</td></tr>
<tr><td><code>regular_lam</code></td>
<td>
<p>Regularization parameter</p>
</td></tr>
<tr><td><code>numb_bound_mono</code></td>
<td>
<p>Number of items with parameters at boundary of
monotonicity constraints</p>
</td></tr>
<tr><td><code>numb_regular_pars</code></td>
<td>
<p>Number of regularized item parameters</p>
</td></tr>
<tr><td><code>delta_regularized</code></td>
<td>
<p>List indicating which item parameters
are regularized</p>
</td></tr>
<tr><td><code>cd_algorithm</code></td>
<td>
<p>Logical indicating whether coordinate descent algorithm is
used</p>
</td></tr>
<tr><td><code>cd_steps</code></td>
<td>
<p>Number of steps for each parameter in coordinate descent algorithm</p>
</td></tr>
<tr><td><code>seed</code></td>
<td>
<p>Used simulation seed</p>
</td></tr>
<tr><td><code>a.attr</code></td>
<td>
<p>Attribute parameters <code class="reqn">a_k</code> in case of <code>HOGDINA&gt;=0</code></p>
</td></tr>
<tr><td><code>b.attr</code></td>
<td>
<p>Attribute parameters <code class="reqn">b_k</code> in case of <code>HOGDINA&gt;=0</code></p>
</td></tr>
<tr><td><code>attr.rf</code></td>
<td>
<p>Attribute response functions. This matrix contains all
<code class="reqn">a_k</code> and <code class="reqn">b_k</code> parameters</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>Logical indicating whether convergence was achieved.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>Optimization parameters used in estimation</p>
</td></tr>
<tr><td><code>partable</code></td>
<td>
<p>Parameter table for <code>gdina</code> function</p>
</td></tr>
<tr><td><code>polychor</code></td>
<td>
<p>Group-wise matrices with polychoric correlations</p>
</td></tr>
<tr><td><code>sequential</code></td>
<td>
<p>Logical indicating whether a sequential GDINA model
is applied for polytomous item responses</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>Further values</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The function <code><a href="#topic+din">din</a></code> does not allow for multiple group estimation.
Use this <code>gdina</code> function instead and choose the appropriate <code>rule="DINA"</code>
as an argument.
</p>
<p>Standard error calculation in analyses which use sample weights or
designmatrix for delta parameters (<code>delta.designmatrix!=NULL</code>) is not yet
correctly implemented. Please use replication methods instead.
</p>


<h3>References</h3>

<p>Berlinet, A. F., &amp; Roland, C. (2012).
Acceleration of the EM algorithm: P-EM versus epsilon algorithm.
<em>Computational Statistics &amp; Data Analysis, 56</em>(12), 4122-4137.
</p>
<p>Chen, J., &amp; de la Torre, J. (2013).
A general cognitive diagnosis model for expert-defined polytomous attributes.
<em>Applied Psychological Measurement, 37</em>, 419-437.
</p>
<p>Chen, J., &amp; de la Torre, J. (2018). Introducing the general polytomous diagnosis
modeling framework.
<em>Frontiers in Psychology | Quantitative Psychology and Measurement, 9</em>(1474).
</p>
<p>de la Torre, J., &amp; Douglas, J. A. (2004). Higher-order latent trait models
for cognitive diagnosis. <em>Psychometrika, 69</em>, 333-353.
</p>
<p>de la Torre, J. (2011). The generalized DINA model framework.
<em>Psychometrika, 76</em>, 179-199.
</p>
<p>Hong, C. Y., Chang, Y. W., &amp; Tsai, R. C. (2016). Estimation of generalized DINA
model with order restrictions. <em>Journal of Classification, 33</em>(3), 460-484.
</p>
<p>Huo, Y., de la Torre, J. (2014). Estimating a cognitive diagnostic model for
multiple strategies via the EM algorithm.
<em>Applied Psychological Measurement, 38</em>, 464-485.
</p>
<p>Kuo, B.-C., Chen, C.-H., &amp; de la Torre, J. (2018).
A cognitive diagnosis model for identifying coexisting skills and misconceptions.
<em>Applied Psychological Measurement, 42</em>(3), 179-191.
</p>
<p>Ma, W., &amp; de la Torre, J. (2016).
A sequential cognitive diagnosis model for polytomous responses.
<em>British Journal of Mathematical and Statistical Psychology, 69</em>(3),
253-275.
</p>
<p>Nash, J. C. (2014). <em>Nonlinear parameter optimization using <span class="rlang"><b>R</b></span> tools</em>.
West Sussex: Wiley.
</p>
<p>Rupp, A. A., &amp; Templin, J. (2008). Unique characteristics of
diagnostic classification models: A comprehensive review of the current
state-of-the-art. <em>Measurement: Interdisciplinary Research and
Perspectives, 6</em>, 219-262.
</p>
<p>Shen, X., Pan, W., &amp; Zhu, Y. (2012). Likelihood-based selection and sharp
parameter estimation.
<em>Journal of the American Statistical Association, 107</em>, 223-232.
</p>
<p>Tutz, G. (1997). Sequential models for ordered responses.
In W. van der Linden &amp; R. K. Hambleton.
<em>Handbook of modern item response theory</em> (pp. 139-152).
New York: Springer.
</p>
<p>Xu, G., &amp; Shang, Z. (2018). Identifying latent structures in
restricted latent class models.
<em>Journal of the American Statistical Association, 523</em>, 1284-1295.
</p>
<p>Xu, X., &amp; von Davier, M. (2008). <em>Fitting the structured general diagnostic
model to NAEP data</em>. ETS Research Report ETS RR-08-27. Princeton, ETS.
</p>
<p>Zeng, L., &amp; Xie, J. (2014). Group variable selection via
SCAD-<code class="reqn">L_2</code>. <em>Statistics, 48</em>, 49-66.
</p>
<p>Zhang, C.-H. (2010). Nearly unbiased variable selection under minimax concave
penalty. <em>Annals of Statistics, 38</em>, 894-942.
</p>


<h3>See Also</h3>

<p>See also the <code><a href="#topic+din">din</a></code> function (for DINA and DINO estimation).
</p>
<p>For assessment of model fit see <code><a href="#topic+modelfit.cor.din">modelfit.cor.din</a></code> and
<code><a href="#topic+anova.gdina">anova.gdina</a></code>.
</p>
<p>See <code><a href="#topic+itemfit.sx2">itemfit.sx2</a></code> for item fit statistics.
</p>
<p>See <code><a href="#topic+sim.gdina">sim.gdina</a></code> for simulating the GDINA model.
</p>
<p>See <code><a href="#topic+gdina.wald">gdina.wald</a></code> for a Wald test for testing the DINA and ACDM
rules at the item-level.
</p>
<p>See <code><a href="#topic+gdina.dif">gdina.dif</a></code> for assessing differential item
functioning.
</p>
<p>See <code><a href="#topic+discrim.index">discrim.index</a></code> for computing discrimination indices.
</p>
<p>See the <code><a href="GDINA.html#topic+GDINA">GDINA::GDINA</a></code> function in the
<span class="pkg">GDINA</span> package for similar functionality.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: Simulated DINA data | different condensation rules
#############################################################################

data(sim.dina, package="CDM")
data(sim.qmatrix, package="CDM")

dat &lt;- sim.dina
Q &lt;- sim.qmatrix

#***
# Model 1: estimation of the GDINA model (identity link)
mod1 &lt;- CDM::gdina( data=dat,  q.matrix=Q)
summary(mod1)
plot(mod1) # apply plot function

## Not run: 
# Model 1a: estimate model with different simulation seed
mod1a &lt;- CDM::gdina( data=dat,  q.matrix=Q, seed=9089)
summary(mod1a)

# Model 1b: estimate model with some fixed delta parameters
delta.fixed &lt;- as.list( rep(NA,9) )        # List for parameters of 9 items
delta.fixed[[2]] &lt;- c( 0, .15, .15, .45 )
delta.fixed[[6]] &lt;- c( .25, .25 )
mod1b &lt;- CDM::gdina( data=dat,  q.matrix=Q, delta.fixed=delta.fixed)
summary(mod1b)

# Model 1c: fix all delta parameters to previously fitted model
mod1c &lt;- CDM::gdina( data=dat,  q.matrix=Q, delta.fixed=mod1$delta)
summary(mod1c)

# Model 1d: estimate GDINA model with GDINA package
mod1d &lt;- GDINA::GDINA( dat=dat, Q=Q, model="GDINA" )
summary(mod1d)
# extract item parameters
GDINA::itemparm(mod1d)
GDINA::itemparm(mod1d, what="delta")
# compare likelihood
logLik(mod1)
logLik(mod1d)

#***
# Model 2: estimation of the DINA model with gdina function
mod2 &lt;- CDM::gdina( data=dat,  q.matrix=Q, rule="DINA")
summary(mod2)
plot(mod2)

#***
# Model 2b: compare results with din function
mod2b &lt;- CDM::din( data=dat,  q.matrix=Q, rule="DINA")
summary(mod2b)

# Model 2: estimation of the DINO model with gdina function
mod3 &lt;- CDM::gdina( data=dat,  q.matrix=Q, rule="DINO")
summary(mod3)

#***
# Model 4: DINA model with logit link
mod4 &lt;- CDM::gdina( data=dat, q.matrix=Q, rule="DINA", linkfct="logit" )
summary(mod4)

#***
# Model 5: DINA model log link
mod5 &lt;- CDM::gdina( data=dat, q.matrix=Q, rule="DINA", linkfct="log")
summary(mod5)

#***
# Model 6: RRUM model
mod6 &lt;- CDM::gdina( data=dat, q.matrix=Q, rule="RRUM")
summary(mod6)

#***
# Model 7: Higher order GDINA model
mod7 &lt;- CDM::gdina( data=dat, q.matrix=Q, HOGDINA=1)
summary(mod7)

#***
# Model 8: GDINA model with independent attributes
mod8 &lt;- CDM::gdina( data=dat, q.matrix=Q, HOGDINA=0)
summary(mod8)

#***
# Model 9: Estimating the GDINA model with monotonicity constraints
mod9 &lt;- CDM::gdina( data=dat, q.matrix=Q, rule="GDINA",
              mono.constr=TRUE, linkfct="logit")
summary(mod9)

#***
# Model 10: Estimating the ACDM model with SCAD penalty and regularization
#           parameter of .05
mod10 &lt;- CDM::gdina( data=dat, q.matrix=Q, rule="ACDM",
                linkfct="logit", regular_type="scad", regular_lam=.05 )
summary(mod10)

#***
# Model 11: Estimation of GDINA model with prior distributions

# N(0,10^2) prior for item intercepts
prior_intercepts &lt;- c(0,10)
# N(0,1^2) prior for item slopes
prior_slopes &lt;- c(0,1)
# estimate model
mod11 &lt;- CDM::gdina( data=dat, q.matrix=Q, rule="GDINA",
              prior_intercepts=prior_intercepts, prior_slopes=prior_slopes)
summary(mod11)

#############################################################################
# EXAMPLE 2: Simulated DINO data
#    additive cognitive diagnosis model with different link functions
#############################################################################

data(sim.dino, package="CDM")
data(sim.matrix, package="CDM")

dat &lt;- sim.dino
Q &lt;- sim.qmatrix

#***
# Model 1: additive cognitive diagnosis model (ACDM; identity link)
mod1 &lt;- CDM::gdina( data=dat, q.matrix=Q,  rule="ACDM")
summary(mod1)

#***
# Model 2: ACDM logit link
mod2 &lt;- CDM::gdina( data=dat, q.matrix=Q, rule="ACDM", linkfct="logit")
summary(mod2)

#***
# Model 3: ACDM log link
mod3 &lt;- CDM::gdina( data=dat, q.matrix=Q, rule="ACDM", linkfct="log")
summary(mod3)

#***
# Model 4: Different condensation rules per item
I &lt;- 9      # number of items
rule &lt;- rep( "GDINA", I )
rule[1] &lt;- "DINO"   # 1st item: DINO model
rule[7] &lt;- "GDINA2" # 7th item: GDINA model with first- and second-order interactions
rule[8] &lt;- "ACDM"   # 8ht item: additive CDM
rule[9] &lt;- "DINA"   # 9th item: DINA model
mod4 &lt;- CDM::gdina( data=dat, q.matrix=Q, rule=rule )
summary(mod4)

#############################################################################
# EXAMPLE 3: Model with user-specified design matrices
#############################################################################

data(sim.dino, package="CDM")
data(sim.qmatrix, package="CDM")

dat &lt;- sim.dino
Q &lt;- sim.qmatrix

# do a preliminary analysis and modify obtained design matrices
mod0 &lt;- CDM::gdina( data=dat,  q.matrix=Q,  maxit=1)

# extract default design matrices
Mj &lt;- mod0$Mj
Mj.user &lt;- Mj   # these user defined design matrices are modified.
#~~~  For the second item, the following model should hold
#     X1 ~ V2 + V2*V3
mj &lt;- Mj[[2]][[1]]
mj.lab &lt;- Mj[[2]][[2]]
mj &lt;- mj[,-3]
mj.lab &lt;- mj.lab[-3]
Mj.user[[2]] &lt;- list( mj, mj.lab )
#    [[1]]
#        [,1] [,2] [,3]
#    [1,]    1    0    0
#    [2,]    1    1    0
#    [3,]    1    0    0
#    [4,]    1    1    1
#    [[2]]
#    [1] "0"   "1"   "1-2"
#~~~  For the eight item an equality constraint should hold
#     X8 ~ a*V2 + a*V3 + V2*V3
mj &lt;- Mj[[8]][[1]]
mj.lab &lt;- Mj[[8]][[2]]
mj[,2] &lt;- mj[,2] + mj[,3]
mj &lt;- mj[,-3]
mj.lab &lt;- c("0", "1=2", "1-2" )
Mj.user[[8]] &lt;- list( mj, mj.lab )
Mj.user[[8]]
  ##   [[1]]
  ##        [,1] [,2] [,3]
  ##   [1,]    1    0    0
  ##   [2,]    1    1    0
  ##   [3,]    1    1    0
  ##   [4,]    1    2    1
  ##
  ##   [[2]]
  ##   [1] "0"   "1=2" "1-2"
mod &lt;- CDM::gdina( data=dat,  q.matrix=Q,
                    Mj=Mj.user,  maxit=200 )
summary(mod)

#############################################################################
# EXAMPLE 4: Design matrix for delta parameters
#############################################################################

data(sim.dino, package="CDM")
data(sim.qmatrix, package="CDM")

#~~~ estimate an initial model
mod0 &lt;- CDM::gdina( data=dat,  q.matrix=Q, rule="ACDM", maxit=1)
# extract coefficients
c0 &lt;- mod0$coef
I &lt;- 9  # number of items
delta.designmatrix &lt;- matrix( 0, nrow=nrow(c0), ncol=nrow(c0) )
diag( delta.designmatrix) &lt;- 1
# set intercept of item 1 and item 3 equal to each other
delta.designmatrix[ 7, 1 ] &lt;- 1 ; delta.designmatrix[,7] &lt;- 0
# set loading of V1 of item1 and item 3 equal
delta.designmatrix[ 8, 2 ] &lt;- 1 ; delta.designmatrix[,8] &lt;- 0
delta.designmatrix &lt;- delta.designmatrix[, -c(7:8) ]
                # exclude original parameters with indices 7 and 8

#***
# Model 1: ACDM with designmatrix
mod1 &lt;- CDM::gdina( data=dat,  q.matrix=Q,  rule="ACDM",
            delta.designmatrix=delta.designmatrix )
summary(mod1)

#***
# Model 2: Same model, but with logit link instead of identity link function
mod2 &lt;- CDM::gdina( data=dat,  q.matrix=Q,  rule="ACDM",
            delta.designmatrix=delta.designmatrix, linkfct="logit")
summary(mod2)

#############################################################################
# EXAMPLE 5: Multiple group estimation
#############################################################################

# simulate data
set.seed(9279)
N1 &lt;- 200 ; N2 &lt;- 100   # group sizes
I &lt;- 10                 # number of items
q.matrix &lt;- matrix(0,I,2)   # create Q-matrix
q.matrix[1:7,1] &lt;- 1 ; q.matrix[ 5:10,2] &lt;- 1
# simulate first group
dat1 &lt;- CDM::sim.din(N1, q.matrix=q.matrix, mean=c(0,0) )$dat
# simulate second group
dat2 &lt;- CDM::sim.din(N2, q.matrix=q.matrix, mean=c(-.3, -.7) )$dat
# merge data
dat &lt;- rbind( dat1, dat2 )
# group indicator
group &lt;- c( rep(1,N1), rep(2,N2) )

# estimate GDINA model with multiple groups assuming invariant item parameters
mod1 &lt;- CDM::gdina( data=dat, q.matrix=q.matrix,  group=group)
summary(mod1)

# estimate DINA model with multiple groups assuming invariant item parameters
mod2 &lt;- CDM::gdina( data=dat, q.matrix=q.matrix, group=group, rule="DINA")
summary(mod2)

# estimate GDINA model with noninvariant item parameters
mod3 &lt;- CDM::gdina( data=dat, q.matrix=q.matrix,  group=group, invariance=FALSE)
summary(mod3)

# estimate GDINA model with some invariant item parameters (I001, I006, I008)
mod4 &lt;- CDM::gdina( data=dat, q.matrix=q.matrix,  group=group,
            invariance=c("I001", "I006","I008") )

#--- model comparison
IRT.compareModels(mod1,mod2,mod3,mod4)

# estimate GDINA model with non-invariant item parameters except for the
# items I001, I006, I008
mod5 &lt;- CDM::gdina( data=dat, q.matrix=q.matrix,  group=group,
            invariance=setdiff( colnames(dat), c("I001", "I006","I008") ) )

#############################################################################
# EXAMPLE 6: User specified reduced skill space
#############################################################################

#   Some correlations between attributes should be set to zero.
q.matrix &lt;- expand.grid( c(0,1), c(0,1), c(0,1), c(0,1) )
colnames(q.matrix) &lt;- colnames( paste("Attr", 1:4,sep=""))
q.matrix &lt;- q.matrix[ -1, ]
Sigma &lt;- matrix( .5, nrow=4, ncol=4 )
diag(Sigma) &lt;- 1
Sigma[3,2] &lt;- Sigma[2,3] &lt;- 0 # set correlation of attribute A2 and A3 to zero
dat &lt;- CDM::sim.din( N=1000, q.matrix=q.matrix, Sigma=Sigma)$dat

#~~~ Step 1: initial estimation
mod1a &lt;- CDM::gdina( data=dat, q.matrix=q.matrix, maxit=1, rule="DINA")
# estimate also "full" model
mod1 &lt;- CDM::gdina( data=dat, q.matrix=q.matrix, rule="DINA")

#~~~ Step 2: modify designmatrix for reduced skillspace
Z.skillspace &lt;- data.frame( mod1a$Z.skillspace )
# set correlations of A2/A4 and A3/A4 to zero
vars &lt;- c("A2_A3","A2_A4")
for (vv in vars){ Z.skillspace[,vv] &lt;- NULL }

#~~~ Step 3: estimate model with reduced skillspace
mod2 &lt;- CDM::gdina( data=dat, q.matrix=q.matrix,
              Z.skillspace=Z.skillspace, rule="DINA")

#~~~ eliminate all covariances
Z.skillspace &lt;- data.frame( mod1$Z.skillspace )
colnames(Z.skillspace)
Z.skillspace &lt;- Z.skillspace[, -grep( "_", colnames(Z.skillspace),fixed=TRUE)]
colnames(Z.skillspace)

mod3 &lt;- CDM::gdina( data=dat, q.matrix=q.matrix,
               Z.skillspace=Z.skillspace, rule="DINA")
summary(mod1)
summary(mod2)
summary(mod3)

#############################################################################
# EXAMPLE 7: Polytomous GDINA model (Chen &amp; de la Torre, 2013)
#############################################################################

data(data.pgdina, package="CDM")

dat &lt;- data.pgdina$dat
q.matrix &lt;- data.pgdina$q.matrix

# pGDINA model with "DINA rule"
mod1 &lt;- CDM::gdina( dat, q.matrix=q.matrix, rule="DINA")
summary(mod1)
# no reduced skill space
mod1a &lt;- CDM::gdina( dat, q.matrix=q.matrix, rule="DINA",reduced.skillspace=FALSE)
summary(mod1)

# pGDINA model with "GDINA rule"
mod2 &lt;- CDM::gdina( dat, q.matrix=q.matrix, rule="GDINA")
summary(mod2)

#############################################################################
# EXAMPLE 8: Fraction subtraction data: DINA and HO-DINA model
#############################################################################

data(fraction.subtraction.data, package="CDM")
data(fraction.subtraction.qmatrix, package="CDM")

dat &lt;- fraction.subtraction.data
Q &lt;- fraction.subtraction.qmatrix

# Model 1: DINA model
mod1 &lt;- CDM::gdina( dat, q.matrix=Q, rule="DINA")
summary(mod1)

# Model 2: HO-DINA model
mod2 &lt;- CDM::gdina( dat, q.matrix=Q, HOGDINA=1, rule="DINA")
summary(mod2)

#############################################################################
# EXAMPLE 9: Skill space approximation data.jang
#############################################################################

data(data.jang, package="CDM")

data &lt;- data.jang$data
q.matrix &lt;- data.jang$q.matrix

#*** Model 1: Reduced RUM model
mod1 &lt;- CDM::gdina( data, q.matrix, rule="RRUM", conv.crit=.001, maxit=500 )

#*** Model 2: Reduced RUM model with skill space approximation
# use 300 instead of 2^9=512 skill classes
skillspace &lt;- CDM::skillspace.approximation( L=300, K=ncol(q.matrix) )
mod2 &lt;- CDM::gdina( data, q.matrix, rule="RRUM", conv.crit=.001,
            skillclasses=skillspace )
  ##   &gt; logLik(mod1)
  ##   'log Lik.' -30318.08 (df=153)
  ##   &gt; logLik(mod2)
  ##   'log Lik.' -30326.52 (df=153)

#############################################################################
# EXAMPLE 10: CDM with a linear hierarchy
#############################################################################
# This model is equivalent to a unidimensional IRT model with an ordered
# ordinal latent trait and is actually a probabilistic Guttman model.
set.seed(789)

# define 3 competency levels
alpha &lt;- scan()
   0 0 0   1 0 0   1 1 0   1 1 1

# define skill class distribution
K &lt;- 3
skillspace &lt;- alpha &lt;- matrix( alpha, K + 1,  K, byrow=TRUE )
alpha &lt;- alpha[ rep(  1:4,  c(300,300,200,200) ), ]
# P(000)=P(100)=.3, P(110)=P(111)=.2
# define Q-matrix
Q &lt;- scan()
    1 0 0   1 1 0   1 1 1

Q &lt;- matrix( Q, nrow=K,  ncol=K, byrow=TRUE )
Q &lt;- Q[ rep(1:K, each=4 ), ]
colnames(skillspace) &lt;- colnames(Q) &lt;- paste0("A",1:K)
I &lt;- nrow(Q)

# define guessing and slipping parameters
guess &lt;- stats::runif( I, 0, .3 )
slip &lt;- stats::runif( I, 0, .2 )
# simulate data
dat &lt;- CDM::sim.din( q.matrix=Q, alpha=alpha, slip=slip, guess=guess )$dat

#*** Model 1: DINA model with linear hierarchy
mod1 &lt;- CDM::din( dat, q.matrix=Q, rule="DINA",  skillclasses=skillspace )
summary(mod1)

#*** Model 2: pGDINA model with 3 levels
#    The multidimensional CDM with a linear hierarchy is a unidimensional
#    polytomous GDINA model.
Q2 &lt;- matrix( rowSums(Q), nrow=I, ncol=1 )
mod2 &lt;- CDM::gdina( dat, q.matrix=Q2, rule="DINA" )
summary(mod2)

#*** Model 3: estimate probabilistic Guttman model in sirt
#    Proctor, C. H. (1970). A probabilistic formulation and statistical
#    analysis for Guttman scaling. Psychometrika, 35, 73-78.
library(sirt)
mod3 &lt;- sirt::prob.guttman( dat, itemlevel=Q2[,1] )
summary(mod3)
# -&gt; The three models result in nearly equivalent fit.

#############################################################################
# EXAMPLE 11: Sequential GDINA model (Ma &amp; de la Torre, 2016)
#############################################################################

data(data.cdm04, package="CDM")

#** attach dataset
dat &lt;- data.cdm04$data    # polytomous item responses
q.matrix1 &lt;- data.cdm04$q.matrix1
q.matrix2 &lt;- data.cdm04$q.matrix2

#-- DINA model with first Q-matrix
mod1 &lt;- CDM::gdina( dat, q.matrix=q.matrix1, rule="DINA")
summary(mod1)
#-- DINA model with second Q-matrix
mod2 &lt;- CDM::gdina( dat, q.matrix=q.matrix2, rule="DINA")
#-- GDINA model
mod3 &lt;- CDM::gdina( dat, q.matrix=q.matrix2, rule="GDINA")

#** model comparison
IRT.compareModels(mod1,mod2,mod3)

#############################################################################
# EXAMPLE 12: Simulataneous modeling of skills and misconceptions (Kuo et al., 2018)
#############################################################################

data(data.cdm08, package="CDM")
dat &lt;- data.cdm08$data
q.matrix &lt;- data.cdm08$q.matrix

#*** estimate model
mod &lt;- CDM::gdina( dat0, q.matrix, rule="SISM", bugs=colnames(q.matrix)[5:7] )
summary(mod)

#############################################################################
# EXAMPLE 13: Regularized estimation in GDINA model data.dtmr
#############################################################################

data(data.dtmr, package="CDM")
dat &lt;- data.dtmr$data
q.matrix &lt;- data.dtmr$q.matrix

#***** LASSO regularization with lambda parameter of .02
mod1 &lt;- CDM::gdina(dat, q.matrix=q.matrix, rule="GDINA", regular_lam=.02,
                  regular_type="lasso")
summary(mod1)
mod$delta_regularized

#***** using starting values from previuos estimation
delta.init &lt;- mod1$delta
attr.prob.init &lt;- mod1$attr.prob
mod2 &lt;- CDM::gdina(dat, q.matrix=q.matrix, rule="GDINA", regular_lam=.02, regular_type="lasso",
                delta.init=delta.init, attr.prob.init=attr.prob.init)
summary(mod2)

#***** final estimation fixing regularized estimates to zero and estimate all other
#***** item parameters unregularized
regular_weights &lt;- mod2$delta_regularized
delta.init &lt;- mod2$delta
attr.prob.init &lt;- mod2$attr.prob

mod3 &lt;- CDM::gdina(dat, q.matrix=q.matrix, rule="GDINA", regular_lam=1E5, regular_type="lasso",
                delta.init=delta.init, attr.prob.init=attr.prob.init,
                regular_weights=regular_weights)
summary(mod3)

## End(Not run)
</code></pre>

<hr>
<h2 id='gdina.dif'>
Differential Item Functioning in the GDINA Model
</h2><span id='topic+gdina.dif'></span><span id='topic+summary.gdina.dif'></span>

<h3>Description</h3>

<p>This function assesses item-wise differential item functioning
in the GDINA model by using the Wald test (de la Torre, 2011;
Hou, de la Torre &amp; Nandakumar, 2014).
It is necessary that a multiple group GDINA model is previously
fitted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdina.dif(object)

## S3 method for class 'gdina.dif'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gdina.dif_+3A_object">object</code></td>
<td>

<p>Object of class <code><a href="#topic+gdina">gdina</a></code>
</p>
</td></tr>
<tr><td><code id="gdina.dif_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The p values are also calculated by a Holm adjustment
for multiple comparisons (see <code>p.holm</code> in
output <code>difstats</code>).
</p>
<p>In the case of two groups, an effect size of differential item functioning
(labeled as <code>UA</code> (unsigned area) in <code>difstats</code> value) is defined as
the weighted absolute difference of item response functions. The DIF measure
for item <code class="reqn">j</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">UA_j=\sum_l w( \alpha_l ) | P( X_j=1 | \alpha_l, G=1 ) -
     P( X_j=1 | \alpha_l, G=2 ) | </code>
</p>

<p>where <code class="reqn">w( \alpha_l )=[ P( \alpha_l | G=1 ) + P( \alpha_l | G=2 ) ]/2</code>.
</p>


<h3>Value</h3>

<p>A list with following entries
</p>
<table role = "presentation">
<tr><td><code>difstats</code></td>
<td>
<p>Data frame containing results of item-wise Wald tests</p>
</td></tr>
<tr><td><code>coef</code></td>
<td>
<p>Data frame containing all (group-wise) item parameters</p>
</td></tr>
<tr><td><code>delta_all</code></td>
<td>
<p>List of <code class="reqn">\delta</code> vectors containing all item parameters</p>
</td></tr>
<tr><td><code>varmat_all</code></td>
<td>
<p>List of covariance matrices of all
<code class="reqn">\delta</code> item parameters</p>
</td></tr>
<tr><td><code>prob.exp.group</code></td>
<td>
<p>List with groups and items containing expected latent class
sizes and expected probabilities for each group and each item.
Based on this information, effect sizes of differential item
functioning can be calculated.</p>
</td></tr>
</table>


<h3>References</h3>

<p>de la Torre, J. (2011). The generalized DINA model framework.
<em>Psychometrika, 76</em>, 179-199.
</p>
<p>Hou, L., de la Torre, J., &amp; Nandakumar, R. (2014).
Differential item functioning assessment in cognitive
diagnostic modeling: Application of the Wald test to
investigate DIF in the DINA model.
<em>Journal of Educational Measurement, 51</em>, 98-125.
</p>


<h3>See Also</h3>

<p>See the <code><a href="GDINA.html#topic+dif">GDINA::dif</a></code> function in the
<span class="pkg">GDINA</span> package for similar functionality.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: DIF for DINA simulated data
#############################################################################

# simulate some data
set.seed(976)
N &lt;- 2000    # number of persons in a group
I &lt;- 9       # number of items
q.matrix &lt;- matrix( 0, 9,2 )
q.matrix[1:3,1] &lt;- 1
q.matrix[4:6,2] &lt;- 1
q.matrix[7:9,c(1,2)] &lt;- 1
# simulate first group
guess &lt;- rep( .2, I )
slip &lt;- rep(.1, I)
dat1 &lt;- CDM::sim.din( N=N, q.matrix=q.matrix, guess=guess, slip=slip,
               mean=c(0,0) )$dat
# simulate second group with some DIF items (items 1, 7 and 8)
guess[ c(1,7)] &lt;- c(.3, .35 )
slip[8] &lt;- .25
dat2 &lt;- CDM::sim.din( N=N, q.matrix=q.matrix, guess=guess, slip=slip,
               mean=c(0.4,.25) )$dat
group &lt;- rep(1:2, each=N )
dat &lt;- rbind( dat1, dat2 )

#*** estimate multiple group GDINA model
mod1 &lt;- CDM::gdina( dat, q.matrix=q.matrix, rule="DINA", group=group )
summary(mod1)

#*** assess differential item functioning
dmod1 &lt;- CDM::gdina.dif( mod1)
summary(dmod1)
  ##     item      X2 df      p p.holm     UA
  ##   1 I001 10.1711  2 0.0062 0.0495 0.0428
  ##   2 I002  1.9933  2 0.3691 1.0000 0.0276
  ##   3 I003  0.0313  2 0.9845 1.0000 0.0040
  ##   4 I004  0.0290  2 0.9856 1.0000 0.0044
  ##   5 I005  2.3230  2 0.3130 1.0000 0.0142
  ##   6 I006  1.8330  2 0.3999 1.0000 0.0159
  ##   7 I007 40.6851  2 0.0000 0.0000 0.1184
  ##   8 I008  6.7912  2 0.0335 0.2346 0.0710
  ##   9 I009  1.1538  2 0.5616 1.0000 0.0180

## End(Not run)

</code></pre>

<hr>
<h2 id='gdina.wald'>
Wald Statistic for Item Fit of the DINA and ACDM Rule for GDINA Model
</h2><span id='topic+gdina.wald'></span><span id='topic+summary.gdina.wald'></span>

<h3>Description</h3>

<p>This function tests with a Wald test for the GDINA model whether a DINA or a ACDM
condensation rule leads to a sufficient item fit compared
to the saturated GDINA rule (de la Torre &amp; Lee, 2013). The Wald test
is accompanied by the RMSEA fit and weighted and unweighted
distance measures (<code>wgtdist</code>, <code>uwgtdist</code>), see Details
(compare Ma, Iaconangelo, &amp; de la Torre, 2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdina.wald(object)

## S3 method for class 'gdina.wald'
summary(object, digits=3,
    vars=c("X2", "p", "sig", "RMSEA", "wgtdist"),  ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gdina.wald_+3A_object">object</code></td>
<td>

<p>A fitted <code><a href="#topic+gdina">gdina</a></code> model
</p>
</td></tr>
<tr><td><code id="gdina.wald_+3A_digits">digits</code></td>
<td>
<p>Number of digits after decimal used
for rounding.</p>
</td></tr>
<tr><td><code id="gdina.wald_+3A_vars">vars</code></td>
<td>
<p>Vector including variables which should
be displayed in <code>summary</code>. See the output <code>stats</code>.
</p>
</td></tr>
<tr><td><code id="gdina.wald_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">P_j( \alpha _l)</code> the estimated item response function for the
GDINA model and <code class="reqn">\hat{P}_j( \alpha _l)</code> the item response
model for the approximated model (DINA, DINO or ACDM).
The unweighted distance <code>uwgtdist</code> as a measure of misfit is defined as
</p>
<p style="text-align: center;"><code class="reqn">uwgtdist=\frac{1}{2^K} \sum_l ( P_j( \alpha _l) - \hat{P}_j( \alpha _l) )^2</code>
</p>

<p>The weighted distance    <code>wgtdist</code> measures the discrepancy
with respected to the probabilities <code class="reqn">w_l=P( \alpha_l)</code> of estimated
skill classes
</p>
<p style="text-align: center;"><code class="reqn">wgtdist=\sum_l w_l (P_j( \alpha _l) - \hat{P}_j( \alpha _l) )^2</code>
</p>



<h3>Value</h3>

<table role = "presentation">
<tr><td><code>stats</code></td>
<td>
<p>Data frame with Wald statistic for every item,
corresponding p values and a RMSEA fit statistic</p>
</td></tr>
</table>


<h3>References</h3>

<p>de la Torre, J., &amp; Lee, Y. S. (2013). Evaluating the Wald test for
item-level comparison of saturated and reduced models in cognitive diagnosis.
<em>Journal of Educational Measurement, 50</em>, 355-373.
</p>
<p>Ma, W., Iaconangelo, C., &amp; de la Torre, J. (2016). Model similarity,
model selection, and attribute classification.
<em>Applied Psychological Measurement, 40</em>(3), 200-217.
</p>


<h3>See Also</h3>

<p>See the <code><a href="GDINA.html#topic+modelcomp">GDINA::modelcomp</a></code> function in the
<span class="pkg">GDINA</span> package for similar functionality.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Wald test for DINA simulated data sim.dina
#############################################################################

data(sim.dina, package="CDM")
data(sim.qmatrix, package="CDM")

# Model 1: estimate GDINA model
mod1 &lt;- CDM::gdina( sim.dina, q.matrix=sim.qmatrix,  rule="GDINA")
summary(mod1)

# perform Wald test
res1 &lt;- CDM::gdina.wald( mod1 )
summary(res1)
# -&gt; results show that all but one item fit according to the DINA rule

# select some output
summary(res1, vars=c("wgtdist", "p") )

## End(Not run)
</code></pre>

<hr>
<h2 id='gdm'>
General Diagnostic Model
</h2><span id='topic+gdm'></span><span id='topic+summary.gdm'></span><span id='topic+print.gdm'></span><span id='topic+plot.gdm'></span>

<h3>Description</h3>

<p>This function estimates the general diagnostic model
(von Davier, 2008; Xu &amp; von Davier, 2008) which handles
multidimensional item response models with ordered discrete
or continuous latent variables for polytomous item
responses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdm( data, theta.k, irtmodel="2PL", group=NULL, weights=rep(1, nrow(data)),
    Qmatrix=NULL, thetaDes=NULL, skillspace="loglinear",
    b.constraint=NULL, a.constraint=NULL,
    mean.constraint=NULL, Sigma.constraint=NULL, delta.designmatrix=NULL,
    standardized.latent=FALSE, centered.latent=FALSE,
    centerintercepts=FALSE, centerslopes=FALSE,
    maxiter=1000,  conv=1e-5, globconv=1e-5, msteps=4, convM=.0005,
    decrease.increments=FALSE, use.freqpatt=FALSE, progress=TRUE,
    PEM=FALSE, PEM_itermax=maxiter, ...)

## S3 method for class 'gdm'
summary(object, file=NULL, ...)

## S3 method for class 'gdm'
print(x, ...)

## S3 method for class 'gdm'
plot(x, perstype="EAP", group=1, barwidth=.1, histcol=1,
       cexcor=3, pchpers=16, cexpers=.7, ... )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gdm_+3A_data">data</code></td>
<td>

<p>An <code class="reqn">N \times I</code> matrix of polytomous item
responses with categories <code class="reqn">k=0,1,...,K</code>
</p>
</td></tr>
<tr><td><code id="gdm_+3A_theta.k">theta.k</code></td>
<td>

<p>In the one-dimensional case it must be a vector.
For multidimensional models it has to be a list
of skill vectors if the theta grid differs between
dimensions. If not, a vector input can be supplied.
If an estimated skillspace (<code>skillspace="est"</code> should be estimated,
a vector or a matrix <code>theta.k</code> will be used as initial values of the estimated
<code class="reqn">\bold{\theta}</code> grid.
</p>
</td></tr>
<tr><td><code id="gdm_+3A_irtmodel">irtmodel</code></td>
<td>

<p>The default <code>2PL</code> corresponds to the model
where item slopes on dimensions are equal for all
item categories. If item-category slopes should
be estimated, use <code>2PLcat</code>. If no item slopes
should be estimated then <code>1PL</code> can be selected.
Note that fixed item slopes can be specified in
the Q-matrix (argument <code>Qmatrix</code>).
</p>
</td></tr>
<tr><td><code id="gdm_+3A_group">group</code></td>
<td>

<p>An optional vector of group identifiers for
multiple group estimation.
For <code>plot.gdm</code> it is an integer indicating which
group should be used for plotting.
</p>
</td></tr>
<tr><td><code id="gdm_+3A_weights">weights</code></td>
<td>

<p>An optional vector of sample weights
</p>
</td></tr>
<tr><td><code id="gdm_+3A_qmatrix">Qmatrix</code></td>
<td>

<p>An optional array of dimension <code class="reqn">I \times D \times K</code>
which indicates pre-specified item loadings
on dimensions. The default for category <code class="reqn">k</code> is the score <code class="reqn">k</code>, i.e.
the scoring in the (generalized) partial credit model.
</p>
</td></tr>
<tr><td><code id="gdm_+3A_thetades">thetaDes</code></td>
<td>

<p>A design matrix for specifying nonlinear item response
functions (see Example 1, Models 4 and 5)
</p>
</td></tr>
<tr><td><code id="gdm_+3A_skillspace">skillspace</code></td>
<td>

<p>The parametric assumption of the skillspace.
If <code>skillspace="normal"</code> then a univariate or
multivariate normal distribution is assumed.
The default <code>"loglinear"</code> corresponds to log-linear
smoothing of the skillspace distribution (Xu &amp; von Davier, 2008).
If <code>skillspace="full"</code>, then all probabilities of the skill space
are nonparametrically estimated. If <code>skillspace="est"</code>, then the
<code class="reqn">\bold{\theta}</code> distribution vectors will be estimated
(see Details and Examples 4 and 5; Bartolucci, 2007).
</p>
</td></tr>
<tr><td><code id="gdm_+3A_b.constraint">b.constraint</code></td>
<td>

<p>In this optional matrix with <code class="reqn">C_b</code> rows and three columns,
<code class="reqn">C_b</code> item intercepts <code class="reqn">b_{ik}</code> can be fixed.
1st column: item index, 2nd column: category index,
3rd column: fixed item thresholds
</p>
</td></tr>
<tr><td><code id="gdm_+3A_a.constraint">a.constraint</code></td>
<td>

<p>In this optional matrix with <code class="reqn">C_a</code> rows and four columns,
<code class="reqn">C_a</code> item intercepts <code class="reqn">a_{idk}</code> can be fixed.
1st column: item index, 2nd column: dimension index,
3rd column: category index, 4th column: fixed item slopes <br />
</p>
</td></tr>
<tr><td><code id="gdm_+3A_mean.constraint">mean.constraint</code></td>
<td>
<p>A <code class="reqn">C \times 3</code> matrix for
constraining <code class="reqn">C</code> means in the
normal distribution assumption (<code>skillspace="normal"</code>).
1st column: Dimension, 2nd column: Group, 3rd column: Value
</p>
</td></tr>
<tr><td><code id="gdm_+3A_sigma.constraint">Sigma.constraint</code></td>
<td>
<p>A <code class="reqn">C \times 4</code> matrix for
constraining <code class="reqn">C</code> covariances in the
normal distribution assumption (<code>skillspace="normal"</code>).
1st column: Dimension 1, 2nd column: Dimension 2,
3rd column: Group, 4th column: Value
</p>
</td></tr>
<tr><td><code id="gdm_+3A_delta.designmatrix">delta.designmatrix</code></td>
<td>

<p>The design matrix of <code class="reqn">\delta</code> parameters
for the reduced skillspace estimation (see Xu &amp;
von Davier, 2008)
</p>
</td></tr>
<tr><td><code id="gdm_+3A_standardized.latent">standardized.latent</code></td>
<td>
<p>A logical indicating whether in a uni- or multidimensional
model all latent variables of the first group should be normally distributed
and standardized. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="gdm_+3A_centered.latent">centered.latent</code></td>
<td>

<p>A logical indicating whether in a uni- or multidimensional
model all latent variables of the first group should be normally
distributed and do have zero means? The default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="gdm_+3A_centerintercepts">centerintercepts</code></td>
<td>

<p>A logical indicating whether intercepts should be centered to have a
mean of 0 for all dimensions. This argument does not (yet) work properly
for varying numbers of item categories.
</p>
</td></tr>
<tr><td><code id="gdm_+3A_centerslopes">centerslopes</code></td>
<td>

<p>A logical indicating whether item slopes should be centered to have
a mean of 1 for all dimensions. This argument only works for
<code>irtmodel="2PL"</code>. The default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="gdm_+3A_maxiter">maxiter</code></td>
<td>

<p>Maximum number of iterations
</p>
</td></tr>
<tr><td><code id="gdm_+3A_conv">conv</code></td>
<td>

<p>Convergence criterion for item parameters and
distribution parameters
</p>
</td></tr>
<tr><td><code id="gdm_+3A_globconv">globconv</code></td>
<td>

<p>Global deviance convergence criterion
</p>
</td></tr>
<tr><td><code id="gdm_+3A_msteps">msteps</code></td>
<td>

<p>Maximum number of M steps in estimating <code class="reqn">b</code> and
<code class="reqn">a</code> item parameters. The default is to use 4 M steps.
</p>
</td></tr>
<tr><td><code id="gdm_+3A_convm">convM</code></td>
<td>

<p>Convergence criterion in M step
</p>
</td></tr>
<tr><td><code id="gdm_+3A_decrease.increments">decrease.increments</code></td>
<td>
<p>Should in the M step the increments
of <code class="reqn">a</code> and <code class="reqn">b</code> parameters decrease during iterations?
The default is <code>FALSE</code>. If there is an increase in deviance
during estimation, setting <code>decrease.increments</code> to <code>TRUE</code>
is recommended.
</p>
</td></tr>
<tr><td><code id="gdm_+3A_use.freqpatt">use.freqpatt</code></td>
<td>

<p>A logical indicating whether frequencies of unique item response patterns
should be used. In case of large data set <code>use.freqpatt=TRUE</code>
can speed calculations (depending on the problem).
Note that in this case, not all person parameters are calculated
as usual in the output.
</p>
</td></tr>
<tr><td><code id="gdm_+3A_progress">progress</code></td>
<td>

<p>An optional logical indicating whether the function should print the
progress of iteration in the estimation process.
</p>
</td></tr>
<tr><td><code id="gdm_+3A_pem">PEM</code></td>
<td>
<p>Logical indicating whether the P-EM acceleration should be
applied (Berlinet &amp; Roland, 2012).</p>
</td></tr>
<tr><td><code id="gdm_+3A_pem_itermax">PEM_itermax</code></td>
<td>
<p>Number of iterations in which the P-EM method should be
applied.</p>
</td></tr>
<tr><td><code id="gdm_+3A_object">object</code></td>
<td>
<p>A required object of class <code>gdm</code></p>
</td></tr>
<tr><td><code id="gdm_+3A_file">file</code></td>
<td>
<p>Optional file name for a file in which <code>summary</code>
should be sinked.</p>
</td></tr>
<tr><td><code id="gdm_+3A_x">x</code></td>
<td>
<p>A required object of class <code>gdm</code></p>
</td></tr>
<tr><td><code id="gdm_+3A_perstype">perstype</code></td>
<td>
<p>Person parameter estimate type. Can be either
<code>"EAP"</code>, <code>"MAP"</code> or <code>"MLE"</code>.</p>
</td></tr>
<tr><td><code id="gdm_+3A_barwidth">barwidth</code></td>
<td>
<p>Bar width in <code>plot.gdm</code></p>
</td></tr>
<tr><td><code id="gdm_+3A_histcol">histcol</code></td>
<td>
<p>Color of histogram bars in <code>plot.gdm</code></p>
</td></tr>
<tr><td><code id="gdm_+3A_cexcor">cexcor</code></td>
<td>
<p>Font size for print of correlation in <code>plot.gdm</code></p>
</td></tr>
<tr><td><code id="gdm_+3A_pchpers">pchpers</code></td>
<td>
<p>Point type for scatter plot of person
parameters in <code>plot.gdm</code></p>
</td></tr>
<tr><td><code id="gdm_+3A_cexpers">cexpers</code></td>
<td>
<p>Point size for scatter plot of person
parameters in <code>plot.gdm</code></p>
</td></tr>
<tr><td><code id="gdm_+3A_...">...</code></td>
<td>
<p>Optional parameters to be passed to or from other
methods will be ignored.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Case <code>irtmodel="1PL"</code>: <br />
Equal item slopes of 1 are assumed in this model. Therefore,
it corresponds to a generalized multidimensional Rasch model.
</p>
<p style="text-align: center;"><code class="reqn">logit P( X_{nj}=k | \theta_n )=b_{j0} +
    \sum_d q_{jdk} \theta_{nd} </code>
</p>

<p>The Q-matrix entries <code class="reqn">q_{jdk}</code> are pre-specified by the user.
</p>
<p>Case <code>irtmodel="2PL"</code>: <br />
For each item and each dimension, different item slopes <code class="reqn">a_{jd}</code>
are estimated:
</p>
<p style="text-align: center;"><code class="reqn">logit P( X_{nj}=k | \theta_n )=b_{j0} +
    \sum_d a_{jd} q_{jdk} \theta_{nd} </code>
</p>

<p>Case <code>irtmodel="2PLcat"</code>: <br />
For each item, each dimension and each category,
different item slopes <code class="reqn">a_{jdk}</code>
are estimated:
</p>
<p style="text-align: center;"><code class="reqn">logit P( X_{nj}=k | \theta_n )=b_{j0} +
    \sum_d a_{jdk} q_{jdk} \theta_{nd} </code>
</p>

<p>Note that this model can be generalized to include terms of
any transformation <code class="reqn">t_h</code> of the <code class="reqn">\theta_n</code> vector (e.g. quadratic terms,
step functions or interaction) such that the model can be formulated as
</p>
<p style="text-align: center;"><code class="reqn">logit P( X_{nj}=k | \theta_n )=b_{j0} +
    \sum_h a_{jhk} q_{jhk} t_h( \theta_{n} ) </code>
</p>

<p>In general, the number of functions <code class="reqn">t_1, ..., t_H</code> will be
larger than the <code class="reqn">\theta</code> dimension of <code class="reqn">D</code>.
</p>
<p>The estimation follows an EM algorithm as described in von Davier and
Yamamoto (2004) and von Davier (2008).
</p>
<p>In case of <code>skillspace="est"</code>, the <code class="reqn">\bold{\theta}</code> vectors
(the grid of the theta distribution) are estimated (Bartolucci, 2007;
Bacci, Bartolucci &amp; Gnaldi, 2012). This model is called a multidimensional
latent class item response model.
</p>


<h3>Value</h3>

<p>An object of class <code>gdm</code>. The list contains the
following entries:
</p>
<table role = "presentation">
<tr><td><code>item</code></td>
<td>
<p>Data frame with item parameters</p>
</td></tr>
<tr><td><code>person</code></td>
<td>
<p>Data frame with person parameters:
<code>EAP</code> denotes the mean of the individual posterior distribution,
<code>SE.EAP</code> the corresponding standard error,
<code>MLE</code> the maximum likelihood estimate at <code>theta.k</code>
and <code>MAP</code> the mode of the posterior distribution
</p>
</td></tr>
<tr><td><code>EAP.rel</code></td>
<td>
<p>Reliability of the EAP</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>Deviance</p>
</td></tr>
<tr><td><code>ic</code></td>
<td>
<p>Information criteria, number of estimated parameters</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>Item intercepts <code class="reqn">b_{jk}</code></p>
</td></tr>
<tr><td><code>se.b</code></td>
<td>
<p>Standard error of item intercepts <code class="reqn">b_{jk}</code></p>
</td></tr>
<tr><td><code>a</code></td>
<td>
<p>Item slopes <code class="reqn">a_{jd}</code> resp. <code class="reqn">a_{jdk}</code></p>
</td></tr>
<tr><td><code>se.a</code></td>
<td>
<p>Standard error of item slopes <code class="reqn">a_{jd}</code> resp. <code class="reqn">a_{jdk}</code></p>
</td></tr>
<tr><td><code>itemfit.rmsea</code></td>
<td>
<p>The RMSEA item fit index (see <code><a href="#topic+itemfit.rmsea">itemfit.rmsea</a></code>).
This entry comes as a list with total and group-wise item fit
statistics.
</p>
</td></tr>
<tr><td><code>mean.rmsea</code></td>
<td>
<p>Mean of RMSEA item fit indexes.
</p>
</td></tr>
<tr><td><code>Qmatrix</code></td>
<td>
<p>Used Q-matrix</p>
</td></tr>
<tr><td><code>pi.k</code></td>
<td>
<p>Trait distribution</p>
</td></tr>
<tr><td><code>mean.trait</code></td>
<td>
<p>Means of trait distribution</p>
</td></tr>
<tr><td><code>sd.trait</code></td>
<td>
<p>Standard deviations of trait distribution</p>
</td></tr>
<tr><td><code>skewness.trait</code></td>
<td>
<p>Skewnesses of trait distribution</p>
</td></tr>
<tr><td><code>correlation.trait</code></td>
<td>
<p>List of correlation matrices of trait distribution
corresponding to each group</p>
</td></tr>
<tr><td><code>pjk</code></td>
<td>
<p>Item response probabilities evaluated at grid <code>theta.k</code></p>
</td></tr>
<tr><td><code>n.ik</code></td>
<td>
<p>An array of expected counts <code class="reqn">n_{cikg}</code> of ability class <code class="reqn">c</code>
at item <code class="reqn">i</code> at category <code class="reqn">k</code> in group <code class="reqn">g</code></p>
</td></tr>
<tr><td><code>G</code></td>
<td>
<p>Number of groups</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>Number of dimension of <code class="reqn">\bold{\theta}</code></p>
</td></tr>
<tr><td><code>I</code></td>
<td>
<p>Number of items</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>Number of persons</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>Parameter estimates for skillspace representation</p>
</td></tr>
<tr><td><code>covdelta</code></td>
<td>
<p>Covariance matrix of parameter estimates for
skillspace representation</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>Original data frame</p>
</td></tr>
<tr><td><code>group.stat</code></td>
<td>
<p>Group statistics (sample sizes, group labels)</p>
</td></tr>
<tr><td><code>p.xi.aj</code></td>
<td>
<p>Individual likelihood</p>
</td></tr>
<tr><td><code>posterior</code></td>
<td>
<p>Individual posterior distribution</p>
</td></tr>
<tr><td><code>skill.levels</code></td>
<td>
<p>Number of skill levels per dimension</p>
</td></tr>
<tr><td><code>K.item</code></td>
<td>
<p>Maximal category per item</p>
</td></tr>
<tr><td><code>theta.k</code></td>
<td>
<p>Used theta design or estimated theta trait distribution
in case of <code>skillspace="est"</code> </p>
</td></tr>
<tr><td><code>thetaDes</code></td>
<td>
<p>Used theta design for item responses</p>
</td></tr>
<tr><td><code>se.theta.k</code></td>
<td>
<p>Estimated standard errors of <code>theta.k</code> if it is
estimated</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>Info about computation time</p>
</td></tr>
<tr><td><code>skillspace</code></td>
<td>
<p>Used skillspace parametrization</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Number of iterations</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>Logical indicating whether convergence was achieved.</p>
</td></tr>
<tr><td><code>object</code></td>
<td>
<p>Object of class <code>gdm</code></p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>Object of class <code>gdm</code></p>
</td></tr>
<tr><td><code>perstype</code></td>
<td>
<p>Person paramter estimate type. Can be either
<code>"EAP"</code>, <code>"MAP"</code> or <code>"MLE"</code>.</p>
</td></tr>
<tr><td><code>group</code></td>
<td>
<p>Group which should be used for <code>plot.gdm</code></p>
</td></tr>
<tr><td><code>barwidth</code></td>
<td>
<p>Bar width in <code>plot.gdm</code></p>
</td></tr>
<tr><td><code>histcol</code></td>
<td>
<p>Color of histogram bars in <code>plot.gdm</code></p>
</td></tr>
<tr><td><code>cexcor</code></td>
<td>
<p>Font size for print of correlation in <code>plot.gdm</code></p>
</td></tr>
<tr><td><code>pchpers</code></td>
<td>
<p>Point type for scatter plot of person
parameters in <code>plot.gdm</code></p>
</td></tr>
<tr><td><code>cexpers</code></td>
<td>
<p>Point size for scatter plot of person
parameters in <code>plot.gdm</code></p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>Optional parameters to be passed to or from other
methods will be ignored.  </p>
</td></tr>
</table>


<h3>References</h3>

<p>Bacci, S., Bartolucci, F., &amp; Gnaldi, M. (2012).
A class of multidimensional latent class IRT models for ordinal
polytomous item responses. <em>arXiv preprint</em>, <em>arXiv:1201.4667</em>.
</p>
<p>Bartolucci, F. (2007). A class of multidimensional IRT models for testing
unidimensionality and clustering items. <em>Psychometrika, 72</em>, 141-157.
</p>
<p>Berlinet, A. F., &amp; Roland, C. (2012).
Acceleration of the EM algorithm: P-EM versus epsilon algorithm.
<em>Computational Statistics &amp; Data Analysis</em>, <b>56</b>(12), 4122-4137.
</p>
<p>von Davier, M. (2008). A general diagnostic model applied to
language testing data. <em>British Journal
of Mathematical and Statistical Psychology, 61</em>, 287-307.
</p>
<p>von Davier, M., &amp; Yamamoto, K. (2004). Partially observed mixtures of IRT models:
An extension of the generalized partial-credit model.
<em>Applied Psychological Measurement, 28</em>, 389-406.
</p>
<p>Xu, X., &amp; von Davier, M. (2008). <em>Fitting the structured general diagnostic
model to NAEP data</em>. ETS Research Report ETS RR-08-27. Princeton, ETS.
</p>


<h3>See Also</h3>

<p>Cognitive diagnostic models for dichotomous data can be estimated
with <code><a href="#topic+din">din</a></code> (DINA or DINO model) or <code><a href="#topic+gdina">gdina</a></code>
(GDINA model, which contains many CDMs as special cases).
</p>
<p>For assessment of model fit see <code><a href="#topic+modelfit.cor.din">modelfit.cor.din</a></code> and
<code><a href="#topic+anova.gdm">anova.gdm</a></code>.
</p>
<p>See <code><a href="#topic+itemfit.sx2">itemfit.sx2</a></code> for item fit statistics.
</p>
<p>For the estimation of the multidimensional
latent class item response model see the <span class="pkg">MultiLCIRT</span> package
and <b>sirt</b> package (function <code>sirt::rasch.mirtlc</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: Fraction Dataset 1
#      Unidimensional Models for dichotomous data
#############################################################################

data(data.fraction1, package="CDM")
dat &lt;- data.fraction1$data
theta.k &lt;- seq( -6, 6, len=15 )   # discretized ability

#***
# Model 1: Rasch model (normal distribution)
mod1 &lt;- CDM::gdm( dat, irtmodel="1PL", theta.k=theta.k, skillspace="normal",
               centered.latent=TRUE)
summary(mod1)
plot(mod1)

#***
# Model 2: Rasch model (log-linear smoothing)
# set the item difficulty of the 8th item to zero
b.constraint &lt;- matrix( c(8,1,0), 1, 3 )
mod2 &lt;- CDM::gdm( dat, irtmodel="1PL", theta.k=theta.k,
               skillspace="loglinear", b.constraint=b.constraint  )
summary(mod2)

#***
# Model 3: 2PL model
mod3 &lt;- CDM::gdm( dat, irtmodel="2PL", theta.k=theta.k,
               skillspace="normal", standardized.latent=TRUE  )
summary(mod3)

## Not run: 
#***
# Model 4: include quadratic term in item response function
#   using the argument decrease.increments=TRUE leads to a more
#   stable estimate
thetaDes &lt;- cbind( theta.k, theta.k^2 )
colnames(thetaDes) &lt;- c( "F1", "F1q" )
mod4 &lt;- CDM::gdm( dat, irtmodel="2PL", theta.k=theta.k,
          thetaDes=thetaDes, skillspace="normal",
          standardized.latent=TRUE, decrease.increments=TRUE)
summary(mod4)

#***
# Model 5: step function for ICC
#          two different probabilities theta &lt; 0 and theta &gt; 0
thetaDes &lt;- matrix( 1*(theta.k&gt;0), ncol=1 )
colnames(thetaDes) &lt;- c( "Fgrm1" )
mod5 &lt;- CDM::gdm( dat, irtmodel="2PL", theta.k=theta.k,
          thetaDes=thetaDes, skillspace="normal" )
summary(mod5)

#***
# Model 6: DINA model with din function
mod6 &lt;- CDM::din( dat, q.matrix=matrix( 1, nrow=ncol(dat),ncol=1 ) )
summary(mod6)

#***
# Model 7: Estimating a version of the DINA model with gdm
theta.k &lt;- c(-.5,.5)
mod7 &lt;- CDM::gdm( dat, irtmodel="2PL", theta.k=theta.k, skillspace="loglinear" )
summary(mod7)

#############################################################################
# EXAMPLE 2: Cultural Activities - data.Students
#      Unidimensional Models for polytomous data
#############################################################################

data(data.Students, package="CDM")
dat &lt;- data.Students

dat &lt;- dat[, grep( "act", colnames(dat) ) ]
theta.k &lt;- seq( -4, 4, len=11 )   # discretized ability

#***
# Model 1: Partial Credit Model (PCM)
mod1 &lt;- CDM::gdm( dat, irtmodel="1PL", theta.k=theta.k, skillspace="normal",
           centered.latent=TRUE)
summary(mod1)
plot(mod1)

#***
# Model 1b: PCM using frequency patterns
mod1b &lt;- CDM::gdm( dat, irtmodel="1PL", theta.k=theta.k, skillspace="normal",
           centered.latent=TRUE, use.freqpatt=TRUE)
summary(mod1b)

#***
# Model 2: PCM with two groups
mod2 &lt;- CDM::gdm( dat, irtmodel="1PL", theta.k=theta.k,
            group=CDM::data.Students$urban + 1, skillspace="normal",
            centered.latent=TRUE)
summary(mod2)

#***
# Model 3: PCM with loglinear smoothing
b.constraint &lt;- matrix( c(1,2,0), ncol=3 )
mod3 &lt;- CDM::gdm( dat, irtmodel="1PL", theta.k=theta.k,
    skillspace="loglinear", b.constraint=b.constraint )
summary(mod3)

#***
# Model 4: Model with pre-specified item weights in Q-matrix
Qmatrix &lt;- array( 1, dim=c(5,1,2) )
Qmatrix[,1,2] &lt;- 2     # default is score 2 for category 2
# now change the scoring of category 2:
Qmatrix[c(2,4),1,1] &lt;- .74
Qmatrix[c(2,4),1,2] &lt;- 2.3
# for items 2 and 4 the score for category 1 is .74 and for category 2 it is 2.3
mod4 &lt;- CDM::gdm( dat, irtmodel="1PL", theta.k=theta.k, Qmatrix=Qmatrix,
           skillspace="normal", centered.latent=TRUE)
summary(mod4)

#***
# Model 5: Generalized partial credit model
mod5 &lt;- CDM::gdm( dat, irtmodel="2PL", theta.k=theta.k,
          skillspace="normal", standardized.latent=TRUE )
summary(mod5)

#***
# Model 6: Item-category slope estimation
mod6 &lt;- CDM::gdm( dat, irtmodel="2PLcat", theta.k=theta.k,  skillspace="normal",
                 standardized.latent=TRUE, decrease.increments=TRUE)
summary(mod6)

#***
# Models 7: items with different number of categories
dat0 &lt;- dat
dat0[ paste(dat0[,1])==2, 1 ] &lt;- 1 # 1st item has only two categories
dat0[ paste(dat0[,3])==2, 3 ] &lt;- 1 # 3rd item has only two categories

# Model 7a: PCM
mod7a &lt;- CDM::gdm( dat0, irtmodel="1PL", theta.k=theta.k,  centered.latent=TRUE )
summary(mod7a)

# Model 7b: Item category slopes
mod7b &lt;- CDM::gdm( dat0, irtmodel="2PLcat", theta.k=theta.k,
                 standardized.latent=TRUE, decrease.increments=TRUE )
summary(mod7b)

#############################################################################
# EXAMPLE 3: Fraction Dataset 2
#      Multidimensional Models for dichotomous data
#############################################################################

data(data.fraction2, package="CDM")
dat &lt;- data.fraction2$data
Qmatrix &lt;- data.fraction2$q.matrix3

#***
# Model 1: One-dimensional Rasch model
theta.k &lt;- seq( -4, 4, len=11 )   # discretized ability
mod1 &lt;- CDM::gdm( dat, irtmodel="1PL", theta.k=theta.k,  centered.latent=TRUE)
summary(mod1)
plot(mod1)

#***
# Model 2: One-dimensional 2PL model
mod2 &lt;- CDM::gdm( dat, irtmodel="2PL", theta.k=theta.k, standardized.latent=TRUE)
summary(mod2)
plot(mod2)

#***
# Model 3: 3-dimensional Rasch Model (normal distribution)
mod3 &lt;- CDM::gdm( dat, irtmodel="1PL", theta.k=theta.k, Qmatrix=Qmatrix,
            centered.latent=TRUE,  globconv=5*1E-3, conv=1E-4 )
summary(mod3)

#***
# Model 4: 3-dimensional Rasch model (loglinear smoothing)
# set some item parameters of items 4,1 and 2 to zero
b.constraint &lt;- cbind( c(4,1,2), 1, 0 )
mod4 &lt;- CDM::gdm( dat, irtmodel="1PL", theta.k=theta.k, Qmatrix=Qmatrix,
              b.constraint=b.constraint, skillspace="loglinear" )
summary(mod4)

#***
# Model 5: define a different theta grid for each dimension
theta.k &lt;- list( "Dim1"=seq( -5, 5, len=11 ),
                 "Dim2"=seq(-5,5,len=8),
                 "Dim3"=seq( -3,3,len=6) )
mod5 &lt;- CDM::gdm( dat, irtmodel="1PL", theta.k=theta.k, Qmatrix=Qmatrix,
                 b.constraint=b.constraint,  skillspace="loglinear")
summary(mod5)

#***
# Model 6: multdimensional 2PL model (normal distribution)
theta.k &lt;- seq( -5, 5, len=13 )
a.constraint &lt;- cbind( c(8,1,3), 1:3, 1, 1 ) # fix some slopes to 1
mod6 &lt;- CDM::gdm( dat, irtmodel="2PL", theta.k=theta.k,  Qmatrix=Qmatrix,
            centered.latent=TRUE, a.constraint=a.constraint, decrease.increments=TRUE,
            skillspace="normal")
summary(mod6)

#***
# Model 7: multdimensional 2PL model (loglinear distribution)
a.constraint &lt;- cbind( c(8,1,3), 1:3, 1, 1 )
b.constraint &lt;- cbind( c(8,1,3), 1, 0 )
mod7 &lt;- CDM::gdm( dat, irtmodel="2PL", theta.k=theta.k,  Qmatrix=Qmatrix,
               b.constraint=b.constraint,  a.constraint=a.constraint,
               decrease.increments=FALSE, skillspace="loglinear")
summary(mod7)

#############################################################################
# EXAMPLE 4: Unidimensional latent class 1PL IRT model
#############################################################################

# simulate data
set.seed(754)
I &lt;- 20     # number of items
N &lt;- 2000   # number of persons
theta &lt;- c( -2, 0, 1, 2 )
theta &lt;- rep( theta, c(N/4,N/4, 3*N/8, N/8)  )
b &lt;- seq(-2,2,len=I)
library(sirt)   # use function sim.raschtype from sirt package
dat &lt;- sirt::sim.raschtype( theta=theta, b=b )

theta.k &lt;- seq(-1, 1, len=4)      # initial vector of theta
# estimate model
mod1 &lt;- CDM::gdm( dat, theta.k=theta.k, skillspace="est", irtmodel="1PL",
            centerintercepts=TRUE, maxiter=200)
summary(mod1)
  ##   Estimated Skill Distribution
  ##         F1    pi.k
  ##   1 -1.988 0.24813
  ##   2 -0.055 0.23313
  ##   3  0.940 0.40059
  ##   4  2.000 0.11816

#############################################################################
# EXAMPLE 5: Multidimensional latent class IRT model
#############################################################################

# We simulate a two-dimensional IRT model in which theta vectors
# are observed at a fixed discrete grid (see below).

# simulate data
set.seed(754)
I &lt;- 13     # number of items
N &lt;- 2400   # number of persons

# simulate Dimension 1 at 4 discrete theta points
theta &lt;- c( -2, 0, 1, 2 )
theta &lt;- rep( theta, c(N/4,N/4, 3*N/8, N/8)  )
b &lt;- seq(-2,2,len=I)
library(sirt)  # use simulation function from sirt package
dat1 &lt;- sirt::sim.raschtype( theta=theta, b=b )
# simulate Dimension 2 at 4 discrete theta points
theta &lt;- c( -3, 0, 1.5, 2 )
theta &lt;- rep( theta, c(N/4,N/4, 3*N/8, N/8)  )
dat2 &lt;- sirt::sim.raschtype( theta=theta, b=b )
colnames(dat2) &lt;- gsub( "I", "U", colnames(dat2))
dat &lt;- cbind( dat1, dat2 )

# define Q-matrix
Qmatrix &lt;- matrix(0,2*I,2)
Qmatrix[ cbind( 1:(2*I), rep(1:2, each=I) ) ] &lt;- 1

theta.k &lt;- seq(-1, 1, len=4)      # initial matrix
theta.k &lt;- cbind( theta.k, theta.k )
colnames(theta.k) &lt;- c("Dim1","Dim2")

# estimate model
mod2 &lt;- CDM::gdm( dat, theta.k=theta.k, skillspace="est", irtmodel="1PL",
              Qmatrix=Qmatrix, centerintercepts=TRUE)
summary(mod2)
  ##   Estimated Skill Distribution
  ##     theta.k.Dim1 theta.k.Dim2    pi.k
  ##   1       -2.022       -3.035 0.25010
  ##   2        0.016        0.053 0.24794
  ##   3        0.956        1.525 0.36401
  ##   4        1.958        1.919 0.13795

#############################################################################
# EXAMPLE 6: Large-scale dataset data.mg
#############################################################################

data(data.mg, package="CDM")
dat &lt;- data.mg[, paste0("I", 1:11 ) ]
theta.k &lt;- seq(-6,6,len=21)

#***
# Model 1: Generalized partial credit model with multiple groups
mod1 &lt;- CDM::gdm( dat, irtmodel="2PL", theta.k=theta.k, group=CDM::data.mg$group,
              skillspace="normal", standardized.latent=TRUE)
summary(mod1)

## End(Not run)
</code></pre>

<hr>
<h2 id='ideal.response.pattern'>
Ideal Response Pattern
</h2><span id='topic+ideal.response.pattern'></span>

<h3>Description</h3>

<p>This function computes the ideal response pattern which is the latent
item response <code class="reqn">\eta_{lj}=\prod_{k=1}^K \alpha_{lk}</code> for a person
with skill profile <code class="reqn">l</code> at item <code class="reqn">j</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ideal.response.pattern(q.matrix, skillspace=NULL, rule="DINA")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ideal.response.pattern_+3A_q.matrix">q.matrix</code></td>
<td>

<p>The Q-matrix
</p>
</td></tr>
<tr><td><code id="ideal.response.pattern_+3A_skillspace">skillspace</code></td>
<td>

<p>An optional skill space matrix. If it is not provided, then all skill
classes are used for creating an ideal response pattern.
</p>
</td></tr>
<tr><td><code id="ideal.response.pattern_+3A_rule">rule</code></td>
<td>

<p>Chosen condensation rule for the CDM. Can be <code>"DINA"</code> or <code>"DINO"</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with following entries
</p>
<table role = "presentation">
<tr><td><code>idealresp</code></td>
<td>
<p>A matrix with ideal response patterns</p>
</td></tr>
<tr><td><code>skillspace</code></td>
<td>
<p>Used skill space</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: Ideal response pattern sim.qmatrix
#############################################################################

data(sim.qmatrix, package="CDM")
q.matrix &lt;- sim.qmatrix

#- ideal response pattern for DINA model
CDM::ideal.response.pattern(q.matrix)

#- ideal response pattern for DINO model
CDM::ideal.response.pattern( q.matrix, rule="DINO" )

# compute ideal responses for a reduced skill space
skillspace &lt;- matrix( c( 0,1,0,
                         1,1,0 ), 2,3, byrow=TRUE )
CDM::ideal.response.pattern( q.matrix, skillspace=skillspace)
</code></pre>

<hr>
<h2 id='IRT.anova'>
Helper Function for Conducting Likelihood Ratio Tests
</h2><span id='topic+IRT.anova'></span>

<h3>Description</h3>

<p>This is a helper function for conducting likelihood ratio tests
and can be generally used for objects for which the
<code><a href="stats.html#topic+logLik">logLik</a></code> method is defined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IRT.anova(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IRT.anova_+3A_object">object</code></td>
<td>

<p>Object for which the <code><a href="stats.html#topic+logLik">logLik</a></code>
method is defined.
</p>
</td></tr>
<tr><td><code id="IRT.anova_+3A_...">...</code></td>
<td>

<p>A further object to be passed
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>See also <code><a href="#topic+IRT.compareModels">IRT.compareModels</a></code> for model comparisons
of several models.
</p>
<p>See also as <code><a href="#topic+anova.din">anova.din</a></code>.
</p>

<hr>
<h2 id='IRT.classify'>
Individual Classification for Fitted Models
</h2><span id='topic+IRT.classify'></span>

<h3>Description</h3>

<p>Computes individual classifications based on a fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IRT.classify(object, type="MLE")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IRT.classify_+3A_object">object</code></td>
<td>

<p>Fitted model for which methods <code><a href="#topic+IRT.likelihood">IRT.likelihood</a></code> and
<code><a href="#topic+IRT.posterior">IRT.posterior</a></code> are defined.
</p>
</td></tr>
<tr><td><code id="IRT.classify_+3A_type">type</code></td>
<td>

<p>Type of classification: <code>"MLE"</code> (maximum likelihood estimate) or
<code>"MAP"</code> (maximum of posterior distribution)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with entries
</p>
<table role = "presentation">
<tr><td><code>class_theta</code></td>
<td>
<p>Individual classification</p>
</td></tr>
<tr><td><code>class_index</code></td>
<td>
<p>Class index of individual classification</p>
</td></tr>
<tr><td><code>class_maxval</code></td>
<td>
<p>Maximum value corresponding to individual classification</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>See <code><a href="#topic+IRT.factor.scores">IRT.factor.scores</a></code> for similar functionality.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Individual classification data.ecpe
#############################################################################

data(data.ecpe, package="CDM")
dat &lt;- data.ecpe$dat[,-1]
Q &lt;- data.ecpe$q.matrix

#** estimate GDINA model
mod &lt;- CDM::gdina(dat, q.matrix=Q)
summary(mod)

#** classify individuals
cmod &lt;- CDM::IRT.classify(mod)
str(cmod)

## End(Not run)
</code></pre>

<hr>
<h2 id='IRT.compareModels'>
Comparisons of Several Models
</h2><span id='topic+IRT.compareModels'></span><span id='topic+summary.IRT.compareModels'></span>

<h3>Description</h3>

<p>Performs model comparisons based on information criteria and likelihood
ratio test. This function allows all objects for which the
<code><a href="stats.html#topic+logLik">logLik</a></code> (<span class="pkg">stats</span>) S3 method is defined.
The output of <code><a href="#topic+IRT.modelfit">IRT.modelfit</a></code> can also be used as
input for this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IRT.compareModels(object, ...)

## S3 method for class 'IRT.compareModels'
summary(object, extended=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IRT.compareModels_+3A_object">object</code></td>
<td>

<p>Object
</p>
</td></tr>
<tr><td><code id="IRT.compareModels_+3A_extended">extended</code></td>
<td>
<p>Optional logical indicating whether all or or only
a subset of fit statistics should be printed.</p>
</td></tr>
<tr><td><code id="IRT.compareModels_+3A_...">...</code></td>
<td>

<p>Further objects to be passed.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with following entries
</p>
<table role = "presentation">
<tr><td><code>IC</code></td>
<td>
<p>Data frame with information criteria</p>
</td></tr>
<tr><td><code>LRtest</code></td>
<td>
<p>Data frame with all (useful) pairwise
likelihood ratio tests</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>The function is based on <code><a href="#topic+IRT.IC">IRT.IC</a></code>.
</p>
<p>For comparing two models see <code><a href="#topic+anova.din">anova.din</a></code>.
</p>
<p>For computing absolute model fit see <code><a href="#topic+IRT.modelfit">IRT.modelfit</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Model comparison sim.dina dataset
#############################################################################

data(sim.dina, package="CDM")
data(sim.qmatrix, package="CDM")

dat &lt;- sim.dina
q.matrix &lt;- sim.qmatrix

#*** Model 0: DINA model with equal guessing and slipping parameters
mod0 &lt;- CDM::din( dat, q.matrix, guess.equal=TRUE, slip.equal=TRUE )
summary(mod0)

#*** Model 1: DINA model
mod1 &lt;- CDM::din( dat, q.matrix )
summary(mod1)

#*** Model 2: DINO model
mod2 &lt;- CDM::din( dat, q.matrix, rule="DINO")
summary(mod2)

#*** Model 3: Additive GDINA model
mod3 &lt;- CDM::gdina( dat, q.matrix, rule="ACDM")
summary(mod3)

#*** Model 4: GDINA model
mod4 &lt;- CDM::gdina( dat, q.matrix, rule="GDINA")
summary(mod4)

# model comparisons
res &lt;- CDM::IRT.compareModels( mod0, mod1, mod2, mod3, mod4 )
res
  ##   &gt; res
  ##   $IC
  ##     Model   loglike Deviance Npars Nobs      AIC      BIC     AIC3     AICc     CAIC
  ##   1  mod0 -2176.482 4352.963     9  400 4370.963 4406.886 4379.963 4371.425 4415.886
  ##   2  mod1 -2042.378 4084.756    25  400 4134.756 4234.543 4159.756 4138.232 4259.543
  ##   3  mod2 -2086.805 4173.610    25  400 4223.610 4323.396 4248.610 4227.086 4348.396
  ##   4  mod3 -2048.233 4096.466    32  400 4160.466 4288.193 4192.466 4166.221 4320.193
  ##   5  mod4 -2026.633 4053.266    41  400 4135.266 4298.917 4176.266 4144.887 4339.917
  ##
# -&gt; The DINA model (mod1) performed best in terms of AIC.
  ##   $LRtest
  ##     Model1 Model2      Chi2 df            p
  ##   1   mod0   mod1 268.20713 16 0.000000e+00
  ##   2   mod0   mod2 179.35362 16 0.000000e+00
  ##   3   mod0   mod3 256.49745 23 0.000000e+00
  ##   4   mod0   mod4 299.69671 32 0.000000e+00
  ##   5   mod1   mod3 -11.70967  7 1.000000e+00
  ##   6   mod1   mod4  31.48959 16 1.164415e-02
  ##   7   mod2   mod3  77.14383  7 5.262457e-14
  ##   8   mod2   mod4 120.34309 16 0.000000e+00
  ##   9   mod3   mod4  43.19926  9 1.981445e-06
  ##
# -&gt; The GDINA model (mod4) was superior to the other models in terms
#    of the likelihood ratio test.

# get an overview with summary
summary(res)
summary(res,extended=FALSE)

#*******************
# applying model comparison for objects of class IRT.modelfit

# compute model fit statistics
fmod0 &lt;- CDM::IRT.modelfit(mod0)
fmod1 &lt;- CDM::IRT.modelfit(mod1)
fmod4 &lt;- CDM::IRT.modelfit(mod4)

# model comparison
res &lt;- CDM::IRT.compareModels( fmod0, fmod1,  fmod4 )
res
  ##   $IC
  ##        Model   loglike Deviance Npars Nobs      AIC      BIC     AIC3
  ##   mod0  mod0 -2176.482 4352.963     9  400 4370.963 4406.886 4379.963
  ##   mod1  mod1 -2042.378 4084.756    25  400 4134.756 4234.543 4159.756
  ##   mod4  mod4 -2026.633 4053.266    41  400 4135.266 4298.917 4176.266
  ##            AICc     CAIC      maxX2   p_maxX2     MADcor      SRMSR
  ##   mod0 4371.425 4415.886 118.172707 0.0000000 0.09172287 0.10941300
  ##   mod1 4138.232 4259.543   8.728248 0.1127943 0.03025354 0.03979948
  ##   mod4 4144.887 4339.917   2.397241 1.0000000 0.02284029 0.02989669
  ##        X100.MADRESIDCOV      MADQ3     MADaQ3
  ##   mod0        1.9749936 0.08840892 0.08353917
  ##   mod1        0.6713952 0.06184332 0.05923058
  ##   mod4        0.5148707 0.07477337 0.07145600
  ##
  ##   $LRtest
  ##     Model1 Model2      Chi2 df          p
  ##   1   mod0   mod1 268.20713 16 0.00000000
  ##   2   mod0   mod4 299.69671 32 0.00000000
  ##   3   mod1   mod4  31.48959 16 0.01164415

## End(Not run)
</code></pre>

<hr>
<h2 id='IRT.data'>
S3 Method for Extracting Used Item Response Dataset
</h2><span id='topic+IRT.data'></span><span id='topic+IRT.data.din'></span><span id='topic+IRT.data.gdina'></span><span id='topic+IRT.data.mcdina'></span><span id='topic+IRT.data.gdm'></span><span id='topic+IRT.data.slca'></span><span id='topic+IRT.data.reglca'></span>

<h3>Description</h3>

<p>This S3 method extracts the used dataset with item responses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IRT.data(object, ...)

## S3 method for class 'din'
IRT.data(object, ...)

## S3 method for class 'gdina'
IRT.data(object, ...)

## S3 method for class 'gdm'
IRT.data(object, ...)

## S3 method for class 'mcdina'
IRT.data(object, ...)

## S3 method for class 'reglca'
IRT.data(object, ...)

## S3 method for class 'slca'
IRT.data(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IRT.data_+3A_object">object</code></td>
<td>

<p>Object of classes <code><a href="#topic+din">din</a></code>, <code><a href="#topic+gdina">gdina</a></code>,
<code><a href="#topic+mcdina">mcdina</a></code>, <code><a href="#topic+gdm">gdm</a></code>, <code><a href="#topic+slca">slca</a></code>,
<code><a href="#topic+reglca">reglca</a></code>.
</p>
</td></tr>
<tr><td><code id="IRT.data_+3A_...">...</code></td>
<td>

<p>More arguments to be passed.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix (or data frame) with item responses and group identifier and
weights vector as attributes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Several models for sim.dina data
#############################################################################

data(sim.dina, package="CDM")
data(sim.qmatrix, package="CDM")

dat &lt;- sim.dina
q.matrix &lt;- sim.qmatrix

#--- Model 1: GDINA model
mod1 &lt;- CDM::gdina( data=dat, q.matrix=q.matrix)
summary(mod1)
dmod1 &lt;- CDM::IRT.data(mod1)
str(dmod1)

#--- Model 2: DINA model
mod2 &lt;- CDM::din( data=dat, q.matrix=q.matrix)
summary(mod2)
dmod2 &lt;- CDM::IRT.data(mod2)

#--- Model 3: Rasch model with gdm function
mod3 &lt;- CDM::gdm( data=dat, irtmodel="1PL", theta.k=seq(-4,4,length=11),
                centered.latent=TRUE )
summary(mod3)
dmod3 &lt;- CDM::IRT.data(mod3)

#--- Model 4: Latent class model with two classes

dat &lt;- sim.dina
I &lt;- ncol(dat)

# define design matrices
TP &lt;- 2     # two classes
# The idea is that latent classes refer to two different "dimensions".
# Items load on latent class indicators 1 and 2, see below.
Xdes &lt;- array(0, dim=c(I,2,2,2*I) )
items &lt;- colnames(dat)
dimnames(Xdes)[[4]] &lt;- c(paste0( colnames(dat), "Class", 1),
          paste0( colnames(dat), "Class", 2) )
    # items, categories, classes, parameters
# probabilities for correct solution
for (ii in 1:I){
    Xdes[ ii, 2, 1, ii ] &lt;- 1    # probabilities class 1
    Xdes[ ii, 2, 2, ii+I ] &lt;- 1  # probabilities class 2
}
# estimate model
mod4 &lt;- CDM::slca( dat, Xdes=Xdes)
summary(mod4)
dmod4 &lt;- CDM::IRT.data(mod4)

## End(Not run)
</code></pre>

<hr>
<h2 id='IRT.expectedCounts'>
S3 Method for Extracting Expected Counts
</h2><span id='topic+IRT.expectedCounts'></span><span id='topic+IRT.expectedCounts.din'></span><span id='topic+IRT.expectedCounts.gdina'></span><span id='topic+IRT.expectedCounts.mcdina'></span><span id='topic+IRT.expectedCounts.gdm'></span><span id='topic+IRT.expectedCounts.slca'></span><span id='topic+IRT.expectedCounts.reglca'></span>

<h3>Description</h3>

<p>This S3 method extracts expected counts from model output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IRT.expectedCounts(object, ...)

## S3 method for class 'din'
IRT.expectedCounts(object, ...)

## S3 method for class 'gdina'
IRT.expectedCounts(object, ...)

## S3 method for class 'gdm'
IRT.expectedCounts(object, ...)

## S3 method for class 'mcdina'
IRT.expectedCounts(object, ...)

## S3 method for class 'slca'
IRT.expectedCounts(object, ...)

## S3 method for class 'reglca'
IRT.expectedCounts(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IRT.expectedCounts_+3A_object">object</code></td>
<td>

<p>Object of classes <code><a href="#topic+din">din</a></code>, <code><a href="#topic+gdina">gdina</a></code>,
<code><a href="#topic+mcdina">mcdina</a></code>, <code><a href="#topic+gdm">gdm</a></code> or <code><a href="#topic+slca">slca</a></code>.
</p>
</td></tr>
<tr><td><code id="IRT.expectedCounts_+3A_...">...</code></td>
<td>

<p>More arguments to be passed.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array with expected counts. The dimensions are items,
categories, latent classes and groups.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Expected counts gdm function
#############################################################################

data(data.fraction1, package="CDM")
dat &lt;- data.fraction1$data
theta.k &lt;- seq( -6, 6, len=11 )   # discretized ability

#--- Model 1: Rasch model
mod1 &lt;- CDM::gdm( dat, irtmodel="1PL", theta.k=theta.k, skillspace="normal",
               centered.latent=TRUE )
emod1 &lt;- CDM::IRT.expectedCounts(mod1)
str(emod1)

#############################################################################
# EXAMPLE 2: Expected counts gdina function
#############################################################################

data(sim.dina, package="CDM")
data(sim.qmatrix, package="CDM")

#--- Model 1: estimation of the GDINA model
mod1 &lt;- CDM::gdina( data=sim.dina, q.matrix=sim.qmatrix)
summary(mod1)
emod1 &lt;- CDM::IRT.expectedCounts(mod1)
str(emod1)

#--- Model 2: GDINA model with two groups
mod2 &lt;- CDM::gdina( data=CDM::sim.dina, q.matrix=CDM::sim.qmatrix,
                   group=rep(1:2, each=200) )
summary(mod2)
emod2 &lt;- CDM::IRT.expectedCounts( mod2 )
str(emod2)

## End(Not run)
</code></pre>

<hr>
<h2 id='IRT.factor.scores'>
S3 Methods for Extracting Factor Scores (Person Classifications)
</h2><span id='topic+IRT.factor.scores'></span><span id='topic+IRT.factor.scores.din'></span><span id='topic+IRT.factor.scores.gdina'></span><span id='topic+IRT.factor.scores.mcdina'></span><span id='topic+IRT.factor.scores.gdm'></span><span id='topic+IRT.factor.scores.slca'></span>

<h3>Description</h3>

<p>This S3 method extracts factor scores or skill classifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IRT.factor.scores(object, ...)

## S3 method for class 'din'
IRT.factor.scores(object, type="MLE", ...)

## S3 method for class 'gdina'
IRT.factor.scores(object, type="MLE", ...)

## S3 method for class 'mcdina'
IRT.factor.scores(object, type="MLE", ...)

## S3 method for class 'gdm'
IRT.factor.scores(object, type="EAP", ...)

## S3 method for class 'slca'
IRT.factor.scores(object, type="MLE", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IRT.factor.scores_+3A_object">object</code></td>
<td>

<p>Object of classes <code><a href="#topic+din">din</a></code>, <code><a href="#topic+gdina">gdina</a></code>,
<code><a href="#topic+mcdina">mcdina</a></code>, <code><a href="#topic+gdm">gdm</a></code> or <code><a href="#topic+slca">slca</a></code>.
</p>
</td></tr>
<tr><td><code id="IRT.factor.scores_+3A_type">type</code></td>
<td>
<p>Type of estimated factor score. This can be
<code>"MLE"</code>, <code>"MAP"</code> or <code>"EAP"</code>.
The type <code>EAP</code> cannot be used for objects of class <code>slca</code>.
</p>
</td></tr>
<tr><td><code id="IRT.factor.scores_+3A_...">...</code></td>
<td>

<p>More arguments to be passed.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or a vector with classified scores.
</p>


<h3>See Also</h3>

<p>For extracting the individual likelihood or the individual posterior see
<code><a href="#topic+IRT.likelihood">IRT.likelihood</a></code> or <code><a href="#topic+IRT.posterior">IRT.posterior</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: Extracting factor scores in the DINA model
#############################################################################

data(sim.dina, package="CDM")
data(sim.qmatrix, package="CDM")

# estimate DINA model
mod1 &lt;- CDM::din( sim.dina, q.matrix=sim.qmatrix)
summary(mod1)
# MLE
fsc1a &lt;- CDM::IRT.factor.scores(mod1)
# MAP
fsc1b &lt;- CDM::IRT.factor.scores(mod1, type="MAP")
# EAP
fsc1c &lt;- CDM::IRT.factor.scores(mod1, type="EAP")
# compare classification for skill 1
stats::xtabs( ~ fsc1a[,1] + fsc1b[,1] )
graphics::boxplot( fsc1c[,1] ~ fsc1a[,1] )
</code></pre>

<hr>
<h2 id='IRT.frequencies'>
S3 Method for Computing Observed and Expected Frequencies of Univariate and
Bivariate Marginals
</h2><span id='topic+IRT.frequencies'></span><span id='topic+IRT_frequencies_default'></span><span id='topic+IRT_frequencies_wrapper'></span><span id='topic+IRT.frequencies.din'></span><span id='topic+IRT.frequencies.gdina'></span><span id='topic+IRT.frequencies.slca'></span><span id='topic+IRT.frequencies.mcdina'></span><span id='topic+IRT.frequencies.gdm'></span>

<h3>Description</h3>

<p>This S3 method computes observed and expected frequencies for univariate and
bivariate distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IRT.frequencies(object, ...)

IRT_frequencies_default(data, post, probs, weights=NULL)

IRT_frequencies_wrapper(object, ...)

## S3 method for class 'din'
IRT.frequencies(object, ...)

## S3 method for class 'gdina'
IRT.frequencies(object, ...)

## S3 method for class 'mcdina'
IRT.frequencies(object, ...)

## S3 method for class 'gdm'
IRT.frequencies(object, ...)

## S3 method for class 'slca'
IRT.frequencies(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IRT.frequencies_+3A_object">object</code></td>
<td>

<p>Object of classes <code><a href="#topic+din">din</a></code>, <code><a href="#topic+gdina">gdina</a></code>,
<code><a href="#topic+mcdina">mcdina</a></code>, <code><a href="#topic+gdm">gdm</a></code> or <code><a href="#topic+slca">slca</a></code>.
</p>
</td></tr>
<tr><td><code id="IRT.frequencies_+3A_...">...</code></td>
<td>

<p>More arguments to be passed.
</p>
</td></tr>
<tr><td><code id="IRT.frequencies_+3A_data">data</code></td>
<td>
<p>Item response data as extracted by <code><a href="#topic+IRT.data">IRT.data</a></code></p>
</td></tr>
<tr><td><code id="IRT.frequencies_+3A_post">post</code></td>
<td>
<p>Individual posterior distribution as extracted by <code><a href="#topic+IRT.posterior">IRT.posterior</a></code></p>
</td></tr>
<tr><td><code id="IRT.frequencies_+3A_probs">probs</code></td>
<td>
<p>Individual posterior distribution as extracted by <code><a href="#topic+IRT.irfprob">IRT.irfprob</a></code></p>
</td></tr>
<tr><td><code id="IRT.frequencies_+3A_weights">weights</code></td>
<td>
<p>Optional vector of weights as included as the attribute <code>weights</code>
in <code><a href="#topic+IRT.data">IRT.data</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with following entries
</p>
<table role = "presentation">
<tr><td><code>uni_obs</code></td>
<td>
<p>Univariate observed distribution</p>
</td></tr>
<tr><td><code>uni_exp</code></td>
<td>
<p>Univariate expected distribution</p>
</td></tr>
<tr><td><code>M_obs</code></td>
<td>
<p>Univariate observed means</p>
</td></tr>
<tr><td><code>M_exp</code></td>
<td>
<p>Univariate expected means</p>
</td></tr>
<tr><td><code>SD_obs</code></td>
<td>
<p>Univariate observed standard deviations</p>
</td></tr>
<tr><td><code>SD_exp</code></td>
<td>
<p>Univariate expected standard deviations</p>
</td></tr>
<tr><td><code>biv_obs</code></td>
<td>
<p>Bivariate observed frequencies</p>
</td></tr>
<tr><td><code>biv_exp</code></td>
<td>
<p>Bivariate expected frequencies</p>
</td></tr>
<tr><td><code>biv_N</code></td>
<td>
<p>Bivariate sample size</p>
</td></tr>
<tr><td><code>cov_obs</code></td>
<td>
<p>Observed covariances</p>
</td></tr>
<tr><td><code>cov_cor</code></td>
<td>
<p>Expected covariances</p>
</td></tr>
<tr><td><code>cor_obs</code></td>
<td>
<p>Observed correlations</p>
</td></tr>
<tr><td><code>cor_exp</code></td>
<td>
<p>Expected correlations</p>
</td></tr>
<tr><td><code>chisq</code></td>
<td>
<p>Chi square statistic of local independence</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Usage IRT.frequencies
#############################################################################

data(sim.dina, package="CDM")
data(sim.qmatrix, package="CDM")

# estimate GDINA model
mod1 &lt;- CDM::gdina( data=sim.dina,  q.matrix=sim.qmatrix)
summary(mod1)

# direct usage of IRT.frequencies
fres1 &lt;- CDM::IRT.frequencies(mod1)

# use of the default function with input data
data &lt;- CDM::IRT.data(object)
post &lt;- CDM::IRT.posterior(object)
probs &lt;- CDM::IRT.irfprob(object)
fres2 &lt;- CDM::IRT_frequencies_default(data=data, post=post, probs=probs)

## End(Not run)
</code></pre>

<hr>
<h2 id='IRT.IC'>
Information Criteria
</h2><span id='topic+IRT.IC'></span>

<h3>Description</h3>

<p>Computes several information criteria for objects which do have
the <code><a href="stats.html#topic+logLik">logLik</a></code> (<span class="pkg">stats</span>) S3 method
(e.g. <code><a href="#topic+din">din</a></code>, <code><a href="#topic+gdina">gdina</a></code>, <code><a href="#topic+gdm">gdm</a></code>, ...) .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IRT.IC(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IRT.IC_+3A_object">object</code></td>
<td>

<p>Objects which do have the <code><a href="stats.html#topic+logLik">logLik</a></code> (<span class="pkg">stats</span>)
S3 method.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with deviance and several information criteria.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+anova.din">anova.din</a></code> for model comparisons.
A general method is defined in <code><a href="#topic+IRT.compareModels">IRT.compareModels</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: DINA example information criteria
#############################################################################

data(sim.dina, package="CDM")
data(sim.qmatrix, package="CDM")

#*** Model 1: DINA model
mod1 &lt;- CDM::din( sim.dina, q.matrix=sim.qmatrix )
summary(mod1)
IRT.IC(mod1)
</code></pre>

<hr>
<h2 id='IRT.irfprob'>
S3 Methods for Extracting Item Response Functions
</h2><span id='topic+IRT.irfprob'></span><span id='topic+IRT.irfprob.din'></span><span id='topic+IRT.irfprob.gdina'></span><span id='topic+IRT.irfprob.mcdina'></span><span id='topic+IRT.irfprob.gdm'></span><span id='topic+IRT.irfprob.slca'></span><span id='topic+IRT.irfprob.reglca'></span>

<h3>Description</h3>

<p>This S3 method extracts item response functions evaluated
at a grid of abilities (skills). Item response functions can
be plotted using the <code><a href="#topic+IRT.irfprobPlot">IRT.irfprobPlot</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IRT.irfprob(object, ...)

## S3 method for class 'din'
IRT.irfprob(object, ...)

## S3 method for class 'gdina'
IRT.irfprob(object, ...)

## S3 method for class 'gdm'
IRT.irfprob(object, ...)

## S3 method for class 'mcdina'
IRT.irfprob(object, ...)

## S3 method for class 'reglca'
IRT.irfprob(object, ...)

## S3 method for class 'slca'
IRT.irfprob(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IRT.irfprob_+3A_object">object</code></td>
<td>

<p>Object of classes <code><a href="#topic+din">din</a></code>, <code><a href="#topic+gdina">gdina</a></code>,
<code><a href="#topic+mcdina">mcdina</a></code>, <code><a href="#topic+gdm">gdm</a></code>, <code><a href="#topic+slca">slca</a></code>,
<code><a href="#topic+reglca">reglca</a></code>.
</p>
</td></tr>
<tr><td><code id="IRT.irfprob_+3A_...">...</code></td>
<td>

<p>More arguments to be passed.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array with item response probabilities (items <code class="reqn">\times</code>
categories <code class="reqn">\times</code> skill classes [<code class="reqn">\times</code> group]) and attributes
</p>
<table role = "presentation">
<tr><td><code>theta</code></td>
<td>
<p>Uni- or multidimensional skill space (theta grid in
item response models).</p>
</td></tr>
<tr><td><code>prob.theta</code></td>
<td>
<p>Probability distribution of <code>theta</code></p>
</td></tr>
<tr><td><code>skillspace</code></td>
<td>
<p>Design matrix and estimated parameters for
skill space distribution (only for <code>IRT.posterior.slca</code>)</p>
</td></tr>
<tr><td><code>G</code></td>
<td>
<p>Number of groups</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Plot functions for item response curves: <code><a href="#topic+IRT.irfprobPlot">IRT.irfprobPlot</a></code>.
</p>
<p>For extracting the individual likelihood or posterior see
<code><a href="#topic+IRT.likelihood">IRT.likelihood</a></code> or <code><a href="#topic+IRT.posterior">IRT.posterior</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Extracting item response functions mcdina model
#############################################################################

data(data.cdm02, package="CDM")

dat &lt;- data.cdm02$data
q.matrix &lt;- data.cdm02$q.matrix

#-- estimate model
mod1 &lt;- CDM::mcdina( dat, q.matrix=q.matrix)
#-- extract item response functions
prmod1 &lt;- CDM::IRT.irfprob(mod1)
str(prmod1)

## End(Not run)
</code></pre>

<hr>
<h2 id='IRT.irfprobPlot'>
Plot Item Response Functions
</h2><span id='topic+IRT.irfprobPlot'></span>

<h3>Description</h3>

<p>This function plots item response functions for fitted
item response models for which the <code><a href="#topic+IRT.irfprob">IRT.irfprob</a></code>
method is defined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IRT.irfprobPlot( object, items=NULL, min.theta=-4, max.theta=4, cumul=FALSE,
     smooth=TRUE, ask=TRUE,  n.theta=40, package="lattice",... )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IRT.irfprobPlot_+3A_object">object</code></td>
<td>

<p>Fitted item response model for which the <code><a href="#topic+IRT.irfprob">IRT.irfprob</a></code>
method is defined
</p>
</td></tr>
<tr><td><code id="IRT.irfprobPlot_+3A_items">items</code></td>
<td>
<p>Vector of indices of selected items.</p>
</td></tr>
<tr><td><code id="IRT.irfprobPlot_+3A_min.theta">min.theta</code></td>
<td>
<p>Minimum theta to be displayed.</p>
</td></tr>
<tr><td><code id="IRT.irfprobPlot_+3A_max.theta">max.theta</code></td>
<td>
<p>Maximum theta to be displayed.</p>
</td></tr>
<tr><td><code id="IRT.irfprobPlot_+3A_cumul">cumul</code></td>
<td>
<p>Optional logical indicating whether cumulated
item response functions <code class="reqn">P( X \ge k | \theta )</code>
should be displayed.</p>
</td></tr>
<tr><td><code id="IRT.irfprobPlot_+3A_smooth">smooth</code></td>
<td>
<p>Optional logical indicating whether item response
functions should be smoothed for plotting.</p>
</td></tr>
<tr><td><code id="IRT.irfprobPlot_+3A_ask">ask</code></td>
<td>
<p>Logical for asking for a new plot.</p>
</td></tr>
<tr><td><code id="IRT.irfprobPlot_+3A_n.theta">n.theta</code></td>
<td>
<p>Number of theta points if <code>smooth=TRUE</code> is chosen.</p>
</td></tr>
<tr><td><code id="IRT.irfprobPlot_+3A_package">package</code></td>
<td>
<p>String indicating which package should be used for plotting
the item response curves. Options are <code>"lattice"</code>
or <code>"graphics"</code>.</p>
</td></tr>
<tr><td><code id="IRT.irfprobPlot_+3A_...">...</code></td>
<td>

<p>More arguments to be passed for the plot in <span class="pkg">lattice</span>.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Plot item response functions from a unidimensional model
#############################################################################

data(data.Students, package="CDM")

dat &lt;- data.Students
resp &lt;- dat[, paste0("sc",1:4) ]
resp[ paste(resp[,1])==3,1] &lt;-  2
psych::describe(resp)

#--- Model 1: PCM in CDM::gdm
theta.k &lt;- seq( -5, 5, len=21 )
mod1 &lt;- CDM::gdm( dat=resp, irtmodel="1PL", theta.k=theta.k, skillspace="normal",
           centered.latent=TRUE)
summary(mod1)

# plot
IRT.irfprobPlot( mod1 )
# plot in graphics package (which comes with R base version)
IRT.irfprobPlot( mod1, package="graphics")
# plot first and third item and do not smooth discretized item response
# functions in IRT.irfprob
IRT.irfprobPlot( mod1, items=c(1,3), smooth=FALSE )
# cumulated IRF
IRT.irfprobPlot( mod1, cumul=TRUE )

#############################################################################
# EXAMPLE 2: Fitted mutidimensional model with gdm
#############################################################################

dat &lt;- CDM::data.fraction2$data
Qmatrix &lt;- CDM::data.fraction2$q.matrix3

# Model 1: 3-dimensional Rasch Model (normal distribution)
theta.k &lt;- seq( -4, 4, len=11 )   # discretized ability
mod1 &lt;- CDM::gdm( dat, irtmodel="1PL", theta.k=theta.k, Qmatrix=Qmatrix,
              centered.latent=TRUE, maxiter=10 )
summary(mod1)

# unsmoothed curves
IRT.irfprobPlot(mod1, smooth=FALSE)
# smoothed curves
IRT.irfprobPlot(mod1)

## End(Not run)
</code></pre>

<hr>
<h2 id='IRT.itemfit'>
S3 Methods for Computing Item Fit
</h2><span id='topic+IRT.itemfit'></span><span id='topic+IRT.itemfit.din'></span><span id='topic+IRT.itemfit.gdina'></span><span id='topic+IRT.itemfit.gdm'></span><span id='topic+IRT.itemfit.slca'></span><span id='topic+IRT.itemfit.reglca'></span>

<h3>Description</h3>

<p>This S3 method computes some selected item fit statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IRT.itemfit(object, ...)

## S3 method for class 'din'
IRT.itemfit(object, method="RMSEA", ...)

## S3 method for class 'gdina'
IRT.itemfit(object, method="RMSEA", ...)

## S3 method for class 'gdm'
IRT.itemfit(object, method="RMSEA", ...)

## S3 method for class 'reglca'
IRT.itemfit(object, method="RMSEA", ...)

## S3 method for class 'slca'
IRT.itemfit(object, method="RMSEA", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IRT.itemfit_+3A_object">object</code></td>
<td>

<p>Object of classes <code><a href="#topic+din">din</a></code>, <code><a href="#topic+gdina">gdina</a></code>,
<code><a href="#topic+gdm">gdm</a></code>, <code><a href="#topic+slca">slca</a></code>, <code><a href="#topic+reglca">reglca</a></code>.
</p>
</td></tr>
<tr><td><code id="IRT.itemfit_+3A_method">method</code></td>
<td>
<p>Method for computing item fit statistic. Until now,
only <code>method="RMSEA"</code> (see <code><a href="#topic+itemfit.rmsea">itemfit.rmsea</a></code>)
can be used.
</p>
</td></tr>
<tr><td><code id="IRT.itemfit_+3A_...">...</code></td>
<td>

<p>More arguments to be passed.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector or data frame with item fit statistics.
</p>


<h3>See Also</h3>

<p>For extracting the individual likelihood or posterior see
<code><a href="#topic+IRT.likelihood">IRT.likelihood</a></code> or <code><a href="#topic+IRT.posterior">IRT.posterior</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: DINA model item fit
#############################################################################

data(sim.dina, package="CDM")
data(sim.qmatrix, package="CDM")

# estimate model
mod1 &lt;- CDM::din( sim.dina, q.matrix=sim.qmatrix)
# compute item fit
IRT.itemfit( mod1 )

## End(Not run)
</code></pre>

<hr>
<h2 id='IRT.jackknife'>
Jackknifing an Item Response Model
</h2><span id='topic+IRT.jackknife'></span><span id='topic+IRT.jackknife.gdina'></span><span id='topic+coef.IRT.jackknife'></span><span id='topic+vcov.IRT.jackknife'></span><span id='topic+IRT.derivedParameters'></span>

<h3>Description</h3>

<p>This function performs a Jackknife procedure for estimating
standard errors for an item response model. The replication
design must be defined by <code><a href="#topic+IRT.repDesign">IRT.repDesign</a></code>.
Model fit is also assessed via Jackknife.
</p>
<p>Statistical inference for derived parameters is performed
by <code>IRT.derivedParameters</code> with a fitted object of
class <code>IRT.jackknife</code> and a list with defining formulas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IRT.jackknife(object,repDesign, ... )

IRT.derivedParameters(jkobject, derived.parameters )

## S3 method for class 'gdina'
IRT.jackknife(object, repDesign, ...)

## S3 method for class 'IRT.jackknife'
coef(object, bias.corr=FALSE, ...)

## S3 method for class 'IRT.jackknife'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IRT.jackknife_+3A_object">object</code></td>
<td>

<p>Objects for which S3 method <code>IRT.jackknife</code> is defined.
</p>
</td></tr>
<tr><td><code id="IRT.jackknife_+3A_repdesign">repDesign</code></td>
<td>
<p>Replication design generated by <code><a href="#topic+IRT.repDesign">IRT.repDesign</a></code>.</p>
</td></tr>
<tr><td><code id="IRT.jackknife_+3A_jkobject">jkobject</code></td>
<td>
<p>Object of class <code>IRT.jackknife</code>.</p>
</td></tr>
<tr><td><code id="IRT.jackknife_+3A_derived.parameters">derived.parameters</code></td>
<td>
<p>List with defined derived parameters
(see Example 2, Model 2).</p>
</td></tr>
<tr><td><code id="IRT.jackknife_+3A_bias.corr">bias.corr</code></td>
<td>
<p>Optional logical indicating whether a bias correction
should be employed.</p>
</td></tr>
<tr><td><code id="IRT.jackknife_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with following entries
</p>
<table role = "presentation">
<tr><td><code>jpartable</code></td>
<td>
<p>Parameter table with Jackknife estimates</p>
</td></tr>
<tr><td><code>parsM</code></td>
<td>
<p>Matrix with replicated statistics</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>Variance covariance matrix of parameters</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(BIFIEsurvey)

#############################################################################
# EXAMPLE 1: Multiple group DINA model with TIMSS data | Cluster sample
#############################################################################

data(data.timss11.G4.AUT.part, package="CDM")

dat &lt;- data.timss11.G4.AUT.part$data
q.matrix &lt;- data.timss11.G4.AUT.part$q.matrix2
# extract items
items &lt;- paste(q.matrix$item)

# generate replicate design
rdes &lt;- CDM::IRT.repDesign( data=dat,  wgt="TOTWGT", jktype="JK_TIMSS",
                   jkzone="JKCZONE", jkrep="JKCREP" )

#--- Model 1: fit multiple group GDINA model
mod1 &lt;- CDM::gdina( dat[,items], q.matrix=q.matrix[,-1],
            weights=dat$TOTWGT, group=dat$female +1  )
# jackknife Model 1
jmod1 &lt;- CDM::IRT.jackknife( object=mod1, repDesign=rdes )
summary(jmod1)
coef(jmod1)
vcov(jmod1)

#############################################################################
# EXAMPLE 2: DINA model | Simple random sampling
#############################################################################

data(sim.dina, package="CDM")
data(sim.qmatrix, package="CDM")
dat &lt;- sim.dina
q.matrix &lt;- sim.qmatrix

# generate replicate design with 50 jackknife zones (50 random groups)
rdes &lt;- CDM::IRT.repDesign( data=dat,  jktype="JK_RANDOM", ngr=50 )

#--- Model 1: DINA model
mod1 &lt;- CDM::gdina( dat, q.matrix=q.matrix, rule="DINA")
summary(mod1)
# jackknife DINA model
jmod1 &lt;- CDM::IRT.jackknife( object=mod1, repDesign=rdes )
summary(jmod1)

#--- Model 2: DINO model
mod2 &lt;- CDM::gdina( dat, q.matrix=q.matrix, rule="DINO")
summary(mod2)
# jackknife DINA model
jmod2 &lt;- CDM::IRT.jackknife( object=mod2, repDesign=rdes )
summary(jmod2)
IRT.compareModels( mod1, mod2 )

# statistical inference for derived parameters
derived.parameters &lt;- list( "skill1"=~ 0 + I(prob_skillV1_lev1_group1),
    "skilldiff12"=~ 0 + I( prob_skillV2_lev1_group1 - prob_skillV1_lev1_group1 ),
    "skilldiff13"=~ 0 + I( prob_skillV3_lev1_group1 - prob_skillV1_lev1_group1 )
                    )
jmod2a &lt;- CDM::IRT.derivedParameters( jmod2, derived.parameters=derived.parameters )
summary(jmod2a)
coef(jmod2a)

## End(Not run)
</code></pre>

<hr>
<h2 id='IRT.likelihood'>
S3 Methods for Extracting of the Individual Likelihood and the Individual Posterior
</h2><span id='topic+IRT.likelihood'></span><span id='topic+IRT.posterior'></span><span id='topic+IRT.likelihood.din'></span><span id='topic+IRT.likelihood.gdina'></span><span id='topic+IRT.likelihood.mcdina'></span><span id='topic+IRT.likelihood.gdm'></span><span id='topic+IRT.likelihood.slca'></span><span id='topic+IRT.likelihood.reglca'></span><span id='topic+IRT.posterior.din'></span><span id='topic+IRT.posterior.gdina'></span><span id='topic+IRT.posterior.mcdina'></span><span id='topic+IRT.posterior.gdm'></span><span id='topic+IRT.posterior.slca'></span><span id='topic+IRT.posterior.reglca'></span>

<h3>Description</h3>

<p>Functions for extracting the individual likelihood and
individual posterior distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IRT.likelihood(object, ...)

IRT.posterior(object, ...)

## S3 method for class 'din'
IRT.likelihood(object, ...)
## S3 method for class 'din'
IRT.posterior(object, ...)

## S3 method for class 'gdina'
IRT.likelihood(object, ...)
## S3 method for class 'gdina'
IRT.posterior(object, ...)

## S3 method for class 'gdm'
IRT.likelihood(object, ...)
## S3 method for class 'gdm'
IRT.posterior(object, ...)

## S3 method for class 'mcdina'
IRT.likelihood(object, ...)
## S3 method for class 'mcdina'
IRT.posterior(object, ...)

## S3 method for class 'reglca'
IRT.likelihood(object, ...)
## S3 method for class 'reglca'
IRT.posterior(object, ...)

## S3 method for class 'slca'
IRT.likelihood(object, ...)
## S3 method for class 'slca'
IRT.posterior(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IRT.likelihood_+3A_object">object</code></td>
<td>

<p>Object of classes <code><a href="#topic+din">din</a></code>, <code><a href="#topic+gdina">gdina</a></code>,
<code><a href="#topic+mcdina">mcdina</a></code>, <code><a href="#topic+gdm">gdm</a></code>, <code><a href="#topic+slca">slca</a></code>,
<code><a href="#topic+reglca">reglca</a></code>.
</p>
</td></tr>
<tr><td><code id="IRT.likelihood_+3A_...">...</code></td>
<td>

<p>More arguments to be passed.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For both functions <code>IRT.likelihood</code> and <code>IRT.posterior</code>,
it is a matrix with attributes
</p>
<table role = "presentation">
<tr><td><code>theta</code></td>
<td>
<p>Uni- or multidimensional skill space (theta grid in
item response models).</p>
</td></tr>
<tr><td><code>prob.theta</code></td>
<td>
<p>Probability distribution of <code>theta</code></p>
</td></tr>
<tr><td><code>skillspace</code></td>
<td>
<p>Design matrix and estimated parameters for
skill space distribution (only for <code>IRT.posterior.slca</code>)</p>
</td></tr>
<tr><td><code>G</code></td>
<td>
<p>Number of groups</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="GDINA.html#topic+indlogLik">GDINA::indlogLik</a></code>,
<code><a href="GDINA.html#topic+indlogPost">GDINA::indlogPost</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: Extracting likelihood and posterior from a DINA model
#############################################################################

data(sim.dina, package="CDM")
data(sim.qmatrix, package="CDM")

#*** estimate model
mod1 &lt;- CDM::din( sim.dina, q.matrix=sim.qmatrix, rule="DINA")
#*** extract likelihood
likemod1 &lt;- CDM::IRT.likelihood(mod1)
str(likemod1)
# extract theta
attr(likemod1, "theta" )
#*** extract posterior
pomod1 &lt;- CDM::IRT.posterior( mod1 )
str(pomod1)
</code></pre>

<hr>
<h2 id='IRT.marginal_posterior'>
S3 Method for Computation of Marginal Posterior Distribution
</h2><span id='topic+IRT.marginal_posterior'></span><span id='topic+IRT.marginal_posterior.din'></span><span id='topic+IRT.marginal_posterior.gdina'></span><span id='topic+IRT.marginal_posterior.mcdina'></span>

<h3>Description</h3>

<p>Computes marginal posterior distributions for fitted models in the
<span class="pkg">CDM</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IRT.marginal_posterior(object, dim, remove_zeroprobs=TRUE, ...)

## S3 method for class 'din'
IRT.marginal_posterior(object, dim, remove_zeroprobs=TRUE, ...)
## S3 method for class 'gdina'
IRT.marginal_posterior(object, dim, remove_zeroprobs=TRUE, ...)
## S3 method for class 'mcdina'
IRT.marginal_posterior(object, dim, remove_zeroprobs=TRUE, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IRT.marginal_posterior_+3A_object">object</code></td>
<td>

<p>Object of class <code><a href="#topic+din">din</a></code>, <code><a href="#topic+gdina">gdina</a></code>, <code><a href="#topic+mcdina">mcdina</a></code>
</p>
</td></tr>
<tr><td><code id="IRT.marginal_posterior_+3A_dim">dim</code></td>
<td>

<p>Numeric or character vector indicating dimensions of posterior distribution
which should be marginalized
</p>
</td></tr>
<tr><td><code id="IRT.marginal_posterior_+3A_remove_zeroprobs">remove_zeroprobs</code></td>
<td>

<p>Logical indicating whether classes with zero probabilities should
be removed
</p>
</td></tr>
<tr><td><code id="IRT.marginal_posterior_+3A_...">...</code></td>
<td>

<p>Further arguments to be passed
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with entries
</p>
<table role = "presentation">
<tr><td><code>marg_post</code></td>
<td>
<p>Marginal posterior distribution</p>
</td></tr>
<tr><td><code>map</code></td>
<td>
<p>MAP estimate (individual classification)</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>Skill classes</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+IRT.posterior">IRT.posterior</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Dataset with three hierarchical skills
#############################################################################

# simulated data with hierarchical skills:
# skill A with 4 levels, skill B with 2 levels and skill C with 3 levels

data(data.cdm10, package="CDM"")
dat &lt;- data.cdm10$data
Q &lt;- data.cdm10$q.matrix
print(Q)

# define hierarchical skill structure
B &lt;- "A1 &gt; A2 &gt; A3
      C1 &gt; C2"
skill_space &lt;- CDM::skillspace.hierarchy(B=B, skill.names=colnames(Q))
zeroprob.skillclasses &lt;- skill_space$zeroprob.skillclasses

# estimate DINA model
mod1 &lt;- CDM::gdina( dat, q.matrix=Q, zeroprob.skillclasses=zeroprob.skillclasses, rule="DINA")
summary(mod1)

# classification for skill A
res &lt;- CDM::IRT.marginal_posterior(object=mod1, dim=c("A1","A2","A3") )
table(res$map)

# classification for skill B
res &lt;- CDM::IRT.marginal_posterior(object=mod1, dim=c("B") )
table(res$map)

# classification for skill C
res &lt;- CDM::IRT.marginal_posterior(object=mod1, dim=c("C1","C2") )
table(res$map)

## End(Not run)
</code></pre>

<hr>
<h2 id='IRT.modelfit'>
S3 Methods for Assessing Model Fit
</h2><span id='topic+IRT.modelfit'></span><span id='topic+IRT.modelfit.din'></span><span id='topic+IRT.modelfit.gdina'></span><span id='topic+summary.IRT.modelfit.din'></span><span id='topic+summary.IRT.modelfit.gdina'></span>

<h3>Description</h3>

<p>This S3 method assesses global (absolute) model fit using
the methods described in <code><a href="#topic+modelfit.cor.din">modelfit.cor.din</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IRT.modelfit(object, ...)

## S3 method for class 'din'
IRT.modelfit(object, ...)
## S3 method for class 'gdina'
IRT.modelfit(object, ...)

## S3 method for class 'IRT.modelfit.din'
summary(object, ...)
## S3 method for class 'IRT.modelfit.gdina'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IRT.modelfit_+3A_object">object</code></td>
<td>

<p>Object of classes <code><a href="#topic+din">din</a></code> or <code><a href="#topic+gdina">gdina</a></code>.
</p>
</td></tr>
<tr><td><code id="IRT.modelfit_+3A_...">...</code></td>
<td>

<p>More arguments to be passed.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See output of <code><a href="#topic+modelfit.cor.din">modelfit.cor.din</a></code>.
</p>


<h3>See Also</h3>

<p>For extracting the individual likelihood or posterior see
<code><a href="#topic+IRT.likelihood">IRT.likelihood</a></code> or <code><a href="#topic+IRT.posterior">IRT.posterior</a></code>.
</p>
<p>The model fit of objects of class <code><a href="#topic+gdm">gdm</a></code> can be obtained
by using the
<code>TAM::tam.modelfit.IRT</code> function in the <b>TAM</b> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Absolute model fit
#############################################################################

data(sim.dina, package="CDM")
data(sim.qmatrix, package="CDM")

#*** Model 1: DINA model for DINA simulated data
mod1 &lt;- CDM::din( sim.dina, q.matrix=sim.qmatrix, rule="DINA" )
fmod1 &lt;- CDM::IRT.modelfit( mod1 )
summary(fmod1)
  ##  Test of Global Model Fit
  ##         type value     p
  ##  1   max(X2) 8.728 0.113
  ##  2 abs(fcor) 0.143 0.080
  ##
  ##  Fit Statistics
  ##                    est
  ##  MADcor          0.030
  ##  SRMSR           0.040
  ##  100*MADRESIDCOV 0.671
  ##  MADQ3           0.062
  ##  MADaQ3          0.059

#*** Model 2: GDINA model
mod2 &lt;- CDM::gdina( sim.dina, q.matrix=sim.qmatrix, rule="GDINA" )
fmod2 &lt;- CDM::IRT.modelfit( mod2 )
summary(fmod2)
  ##  Test of Global Model Fit
  ##         type value p
  ##  1   max(X2) 2.397 1
  ##  2 abs(fcor) 0.078 1
  ##
  ##  Fit Statistics
  ##                    est
  ##  MADcor          0.023
  ##  SRMSR           0.030
  ##  100*MADRESIDCOV 0.515
  ##  MADQ3           0.075
  ##  MADaQ3          0.071

## End(Not run)
</code></pre>

<hr>
<h2 id='IRT.parameterTable'>
S3 Method for Extracting a Parameter Table
</h2><span id='topic+IRT.parameterTable'></span>

<h3>Description</h3>

<p>S3 method which extracts a parameter table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IRT.parameterTable(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IRT.parameterTable_+3A_object">object</code></td>
<td>

<p>Object of model classes
</p>
</td></tr>
<tr><td><code id="IRT.parameterTable_+3A_...">...</code></td>
<td>

<p>More arguments to be passed.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A parameter table
</p>

<hr>
<h2 id='IRT.repDesign'>
Generation of a Replicate Design for <code>IRT.jackknife</code>
</h2><span id='topic+IRT.repDesign'></span>

<h3>Description</h3>

<p>This function generates a Jackknife replicate design which is
necessary to use the <code>IRT.jackknife</code> function. The function
is a wrapper to <code>BIFIE.data.jack</code> in the <span class="pkg">BIFIEsurvey</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IRT.repDesign(data, wgt=NULL, jktype="JK_TIMSS", jkzone=NULL, jkrep=NULL,
   jkfac=NULL, fayfac=1, wgtrep="W_FSTR", ngr=100, Nboot=200, seed=.Random.seed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IRT.repDesign_+3A_data">data</code></td>
<td>

<p>Dataset which must contain weights and item responses
</p>
</td></tr>
<tr><td><code id="IRT.repDesign_+3A_wgt">wgt</code></td>
<td>

<p>Vector with sample weights
</p>
</td></tr>
<tr><td><code id="IRT.repDesign_+3A_jktype">jktype</code></td>
<td>

<p>Type of jackknife procedure for creating the BIFIE.data object.
<code>jktype="JK_TIMSS"</code> refers to TIMSS/PIRLS datasets.
The type <code>"JK_GROUP"</code> creates jackknife weights based on a user defined grouping,
the type <code>"JK_RANDOM"</code> creates random groups.
The number of random groups can be defined in ngr.
The argument <code>type="RW_PISA"</code> extracts the replicated design with
balanced repeated replicate weights from PISA datasets into objects of
class <code>IRT.repDesign</code>.
Bootstrap samples can be obtained by <code>type="BOOT"</code>.
</p>
</td></tr>
<tr><td><code id="IRT.repDesign_+3A_jkzone">jkzone</code></td>
<td>

<p>Variable name for jackknife zones.
If <code>jktype="JK_TIMSS"</code>, then <code>jkzone="JKZONE"</code>. However,
this default can be overwritten.
</p>
</td></tr>
<tr><td><code id="IRT.repDesign_+3A_jkrep">jkrep</code></td>
<td>

<p>Variable name containing Jackknife replicates
</p>
</td></tr>
<tr><td><code id="IRT.repDesign_+3A_jkfac">jkfac</code></td>
<td>

<p>Factor for multiplying jackknife replicate weights.
If <code>jktype="JK_TIMSS"</code>, then <code>jkfac=2</code>.
</p>
</td></tr>
<tr><td><code id="IRT.repDesign_+3A_fayfac">fayfac</code></td>
<td>

<p>Fay factor. For Jackknife, the default is 1. For a Bootstrap with
<code class="reqn">R</code> samples with replacement, the Fay factor is <code class="reqn">1/R</code>.
</p>
</td></tr>
<tr><td><code id="IRT.repDesign_+3A_wgtrep">wgtrep</code></td>
<td>

<p>Already available replicate design
</p>
</td></tr>
<tr><td><code id="IRT.repDesign_+3A_ngr">ngr</code></td>
<td>

<p>Number of groups
</p>
</td></tr>
<tr><td><code id="IRT.repDesign_+3A_nboot">Nboot</code></td>
<td>
<p>Number of bootstrap samples</p>
</td></tr>
<tr><td><code id="IRT.repDesign_+3A_seed">seed</code></td>
<td>

<p>Random seed
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with following entries
</p>
<table role = "presentation">
<tr><td><code>wgt</code></td>
<td>
<p>Vector with weights</p>
</td></tr>
<tr><td><code>wgtrep</code></td>
<td>
<p>Matrix containing the replicate design</p>
</td></tr>
<tr><td><code>fayfac</code></td>
<td>
<p>Fay factor needed for Jackknife calculations</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>See <code><a href="#topic+IRT.jackknife">IRT.jackknife</a></code> for further examples.
</p>
<p>See the <code>BIFIE.data.jack</code> function in the <span class="pkg">BIFIEsurvey</span> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# load the BIFIEsurvey package
library(BIFIEsurvey)

#############################################################################
# EXAMPLE 1: Design with Jackknife replicate weights in TIMSS
#############################################################################

data(data.timss11.G4.AUT, package="CDM")
dat &lt;- CDM::data.timss11.G4.AUT$data
# generate design
rdes &lt;- CDM::IRT.repDesign( data=dat,  wgt="TOTWGT", jktype="JK_TIMSS",
             jkzone="JKCZONE", jkrep="JKCREP" )
str(rdes)

#############################################################################
# EXAMPLE 2: Bootstrap resampling
#############################################################################

data(sim.qmatrix, package="CDM")
q.matrix &lt;- CDM::sim.qmatrix

# simulate data according to the DINA model
dat &lt;- CDM::sim.din(N=2000, q.matrix=q.matrix )$dat

# bootstrap with 300 random samples
rdes &lt;- CDM::IRT.repDesign( data=dat, jktype="BOOT", Nboot=300 )

## End(Not run)
</code></pre>

<hr>
<h2 id='IRT.RMSD'>
Root Mean Square Deviation (RMSD) Item Fit Statistic
</h2><span id='topic+IRT.RMSD'></span><span id='topic+summary.IRT.RMSD'></span><span id='topic+IRT_RMSD_calc_rmsd'></span>

<h3>Description</h3>

<p>Computed the item fit statistics root mean square deviation (RMSD),
mean absolute deviation (MAD) and mean deviation (MD).
See Oliveri and von Davier (2011) for details.
</p>
<p>The RMSD statistics was denoted as the RMSEA statistic in older
publications, see <code><a href="#topic+itemfit.rmsea">itemfit.rmsea</a></code>.
</p>
<p>If multiple groups are defined in the model object, a weighted item fit
statistic (WRMSD; Yamamoto, Khorramdel, &amp; von Davier, 2013;
von Davier, Weeks, Chen, Allen &amp; van der Velden, 2013) is
additionally computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IRT.RMSD(object)

## S3 method for class 'IRT.RMSD'
summary(object, file=NULL, digits=3, ...)

## core computation function
IRT_RMSD_calc_rmsd( n.ik, pi.k, probs, eps=1E-30 )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IRT.RMSD_+3A_object">object</code></td>
<td>

<p>Object for which the methods <code>IRT.expectedCounts</code> and
<code>IRT.irfprob</code> can be applied.
</p>
</td></tr>
<tr><td><code id="IRT.RMSD_+3A_n.ik">n.ik</code></td>
<td>
<p>Expected counts</p>
</td></tr>
<tr><td><code id="IRT.RMSD_+3A_pi.k">pi.k</code></td>
<td>
<p>Probabilities trait distribution</p>
</td></tr>
<tr><td><code id="IRT.RMSD_+3A_probs">probs</code></td>
<td>
<p>Item response probabilities</p>
</td></tr>
<tr><td><code id="IRT.RMSD_+3A_eps">eps</code></td>
<td>
<p>Numerical constant avoiding division by zero</p>
</td></tr>
<tr><td><code id="IRT.RMSD_+3A_digits">digits</code></td>
<td>
<p>Number of digits used for rounding</p>
</td></tr>
<tr><td><code id="IRT.RMSD_+3A_file">file</code></td>
<td>
<p>Optional file name for a file in which <code>summary</code>
should be sinked.</p>
</td></tr>
<tr><td><code id="IRT.RMSD_+3A_...">...</code></td>
<td>
<p>Optional parameters to be passed.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The RMSD and MD statistics are in operational use in PISA studies
since PISA 2015. These fit statistics can also be used for investigating
uniform and nonuniform differential item functioning.
</p>


<h3>Value</h3>

<p>List with entries
</p>
<table role = "presentation">
<tr><td><code>RMSD</code></td>
<td>
<p>Item-wise and group-wise RMSD statistic</p>
</td></tr>
<tr><td><code>RMSD_bc</code></td>
<td>
<p>Item-wise and group-wise RMSD statistic with analytical
bias correction</p>
</td></tr>
<tr><td><code>MAD</code></td>
<td>
<p>Item-wise and group-wise MAD statistic</p>
</td></tr>
<tr><td><code>MD</code></td>
<td>
<p>Item-wise and group-wise MD statistic</p>
</td></tr>
<tr><td><code>chisquare_stat</code></td>
<td>
<p>Item-wise and group-wise <code class="reqn">\chi^2</code> statistic</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>Further values</p>
</td></tr>
</table>


<h3>References</h3>

<p>Oliveri, M. E., &amp; von Davier, M. (2011).
Investigation of model fit and score scale comparability in
international assessments.
<em>Psychological Test and Assessment Modeling, 53</em>, 315-333.
</p>
<p>von Davier, M., Weeks, J., Chen, H., Allen, J., &amp; van der Velden, R. (2013).
Creating simple and complex derived variables and validation of background
questionnaire data.
In OECD (Eds.). <em>Technical Report of the Survey of Adults Skills (PIAAC)</em>
(Ch. 20). Paris: OECD.
</p>
<p>Yamamoto, K., Khorramdel, L., &amp; von Davier, M. (2013).
Scaling PIAAC cognitive data.
In OECD (Eds.). <em>Technical Report of the Survey of Adults Skills (PIAAC)</em>
(Ch. 17). Paris: OECD.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+itemfit.rmsea">itemfit.rmsea</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: data.read | 1PL model in TAM
#############################################################################

data(data.read, package="sirt")
dat &lt;- data.read

#*** Model 1: 1PL model
mod1 &lt;- TAM::tam.mml( resp=dat )
summary(mod1)

# item fit statistics
imod1 &lt;- CDM::IRT.RMSD(mod1)
summary(imod1)

#############################################################################
# EXAMPLE 2: data.math| RMSD and MD statistic for assessing DIF
#############################################################################

data(data.math, package="sirt")
dat &lt;- data.math$data
items &lt;- grep("M[A-Z]", colnames(dat), value=TRUE )

#-- fit multiple group Rasch model
mod &lt;- TAM::tam.mml( dat[,items], group=dat$female )
summary(mod)

#-- fit statistics
rmod &lt;- CDM::IRT.RMSD(mod)
summary(rmod)

#############################################################################
# EXAMPLE 3: RMSD statistic DINA model
#############################################################################

data(sim.dina)
data(sim.qmatrix)
dat &lt;- sim.dina
Q &lt;- sim.qmatrix

#-- fit DINA model
mod1 &lt;- CDM::gdina( dat, q.matrix=Q, rule="DINA" )
summary(mod1)

#-- compute RMSD fit statistic
rmod1 &lt;- CDM::IRT.RMSD(mod1)
summary(rmod1)

## End(Not run)
</code></pre>

<hr>
<h2 id='item_by_group'>
Create Dataset with Group-Specific Items
</h2><span id='topic+item_by_group'></span>

<h3>Description</h3>

<p>Creates a dataset with group-specific items which can be used for multiple
group comparisons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>item_by_group(dat, group, invariant=NULL, rm.empty=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="item_by_group_+3A_dat">dat</code></td>
<td>

<p>Dataset with item responses
</p>
</td></tr>
<tr><td><code id="item_by_group_+3A_group">group</code></td>
<td>

<p>Vector of group identifiers
</p>
</td></tr>
<tr><td><code id="item_by_group_+3A_invariant">invariant</code></td>
<td>

<p>Optional vector of variables which should
not be made group-specific, i.e. which should be treated
as invariant across groups.
</p>
</td></tr>
<tr><td><code id="item_by_group_+3A_rm.empty">rm.empty</code></td>
<td>

<p>Logical indicating whether empty columns should be removed
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Extended dataset with item responses
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Create dataset with group-specific item responses
#############################################################################

data(data.mg, package="CDM")
dat &lt;- data.mg

#-- create dataset with group-specific item responses
dat0 &lt;- CDM::item_by_group( dat=dat[,paste0("I",1:5)], group=dat$group )

#-- summary statistics
summary(dat0)
colnames(dat0)

#-- set some items to invariant
invariant_items &lt;- c("I1","I4")
dat1 &lt;- CDM::item_by_group( dat=dat[,paste0("I",1:5)], group=dat$group,
            invariant=invariant_items)
colnames(dat1)

## End(Not run)
</code></pre>

<hr>
<h2 id='itemfit.rmsea'>
RMSEA Item Fit
</h2><span id='topic+itemfit.rmsea'></span>

<h3>Description</h3>

<p>This function estimates a chi squared based measure of item fit
in cognitive diagnosis models similar to the RMSEA itemfit
implemented in mdltm (von Davier, 2005;
cited in Kunina-Habenicht, Rupp &amp; Wilhelm, 2009).
</p>
<p>The RMSEA statistic is also called as the RMSD statistic, see
<code><a href="#topic+IRT.RMSD">IRT.RMSD</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>itemfit.rmsea(n.ik, pi.k, probs, itemnames=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="itemfit.rmsea_+3A_n.ik">n.ik</code></td>
<td>

<p>An array of four dimensions: Classes x items x categories x groups
</p>
</td></tr>
<tr><td><code id="itemfit.rmsea_+3A_pi.k">pi.k</code></td>
<td>

<p>An array of two dimensions: Classes x groups
</p>
</td></tr>
<tr><td><code id="itemfit.rmsea_+3A_probs">probs</code></td>
<td>

<p>An array of three dimensions: Classes x items x categories
</p>
</td></tr>
<tr><td><code id="itemfit.rmsea_+3A_itemnames">itemnames</code></td>
<td>

<p>An optional vector of item names. Default is <code>NULL</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For item <code class="reqn">j</code>, the RMSEA itemfit in this function is calculated
as follows:
</p>
<p style="text-align: center;"><code class="reqn"> RMSEA_j=\sqrt{ \sum_k \sum_c \pi ( \bold{\theta}_c)
    \left( P_j ( \bold{\theta}_c ) -
\frac{n_{jkc}}{N_{jc}} \right)^2 } </code>
</p>

<p>where <code class="reqn">c</code> denotes the class of the skill vector
<code class="reqn">\bold{\theta}</code>, <code class="reqn">k</code> is the item category,
<code class="reqn">\pi ( \bold{\theta}_c)</code> is the estimated class probability
of <code class="reqn">\bold{\theta}_c</code>,
<code class="reqn">P_j</code> is the estimated item response function,
<code class="reqn">n_{jkc}</code> is the expected number of students with
skill <code class="reqn">\bold{\theta}_c</code> on
item <code class="reqn">j</code> in category <code class="reqn">k</code> and
<code class="reqn">N_{jc}</code> is the expected number of students with
skill <code class="reqn">\bold{\theta}_c</code> on
item <code class="reqn">j</code>.
</p>


<h3>Value</h3>

<p>A list with two entries:
</p>
<table role = "presentation">
<tr><td><code>rmsea</code></td>
<td>
<p>Vector of RMSEA item statistics</p>
</td></tr>
<tr><td><code>rmsea.groups</code></td>
<td>
<p>Matrix of group-wise RMSEA item statistics</p>
</td></tr>
</table>


<h3>References</h3>

<p>Kunina-Habenicht, O., Rupp, A. A., &amp; Wilhelm, O. (2009).
A practical illustration of multidimensional diagnostic skills profiling:
Comparing results from confirmatory factor analysis and diagnostic
classification models.
<em>Studies in Educational Evaluation, 35</em>, 64&ndash;70.
</p>
<p>von Davier, M. (2005). <em>A general diagnostic model applied to language
testing data</em>. ETS Research Report RR-05-16. ETS, Princeton, NJ: ETS.
</p>


<h3>See Also</h3>

<p>This function is used in <code><a href="#topic+din">din</a></code>, <code><a href="#topic+gdina">gdina</a></code> and
<code><a href="#topic+gdm">gdm</a></code>.
</p>

<hr>
<h2 id='itemfit.sx2'>
S-X2 Item Fit Statistic for Dichotomous Data
</h2><span id='topic+itemfit.sx2'></span><span id='topic+summary.itemfit.sx2'></span><span id='topic+plot.itemfit.sx2'></span>

<h3>Description</h3>

<p>Computes the S-X2 item fit statistic (Orlando &amp; Thissen; 2000, 2003)
for dichotomous data. Note that completely observed data is
necessary for applying this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>itemfit.sx2(object, Eik_min=1, progress=TRUE)

## S3 method for class 'itemfit.sx2'
summary(object, ...)

## S3 method for class 'itemfit.sx2'
plot(x, ask=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="itemfit.sx2_+3A_object">object</code></td>
<td>

<p>Object of class <code><a href="#topic+din">din</a></code>, <code><a href="#topic+gdina">gdina</a></code>, <code><a href="#topic+gdm">gdm</a></code>,
<code>sirt::rasch.mml</code>,
<code>sirt::smirt</code> or <code>TAM::tam.mml</code>
</p>
</td></tr>
<tr><td><code id="itemfit.sx2_+3A_x">x</code></td>
<td>

<p>Object of class <code><a href="#topic+din">din</a></code>, <code><a href="#topic+gdina">gdina</a></code>, <code><a href="#topic+gdm">gdm</a></code>,
<code>sirt::rasch.mml</code>,
<code>sirt::smirt</code> or <code>TAM::tam.mml</code>
</p>
</td></tr>
<tr><td><code id="itemfit.sx2_+3A_eik_min">Eik_min</code></td>
<td>

<p>The minimum expected cell size for merging score groups.
</p>
</td></tr>
<tr><td><code id="itemfit.sx2_+3A_progress">progress</code></td>
<td>

<p>An optional logical indicating whether progress should be displayed.
</p>
</td></tr>
<tr><td><code id="itemfit.sx2_+3A_ask">ask</code></td>
<td>
<p>An optional logical indicating whether every item should be
separately displayed.</p>
</td></tr>
<tr><td><code id="itemfit.sx2_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The S-X2 item fit statistic compares observed and expected proportions
<code class="reqn">O_{jk}</code> and <code class="reqn">E_{jk}</code> for item <code class="reqn">j</code> and
each score group <code class="reqn">k</code> and forms a chi-square distributed statistic
</p>
<p style="text-align: center;"><code class="reqn">S-X_j^2=\sum_{k=1}^{J-1} N_k \frac{ ( O_{jk} - E_{jk} )^2 }
    { E_{jk} ( 1 - E_{jk} ) } </code>
</p>

<p>The degrees of freedom are <code class="reqn">J-1-P_j</code> where <code class="reqn">P_j</code> denotes
the number of estimated item parameters.
</p>


<h3>Value</h3>

<p>A list with following entries
</p>
<table role = "presentation">
<tr><td><code>itemfit.stat</code></td>
<td>
<p>Data frame containing item fit statistics</p>
</td></tr>
<tr><td><code>itemtable</code></td>
<td>
<p>Data frame with expected and observed proportions
for each score group and each item. Beside the ordinary p value,
an adjusted p value obtained by correction due to multiple testing
is provided (<code>p.holm</code>, see
<code><a href="stats.html#topic+p.adjust">stats::p.adjust</a></code>.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function does not work properly for multiple groups.
</p>


<h3>Author(s)</h3>

<p>Alexander Robitzsch
</p>


<h3>References</h3>

<p>Li, Y., &amp; Rupp, A. A. (2011). Performance of the S-X2 statistic for
full-information bifactor models.
<em>Educational and Psychological Measurement, 71</em>, 986-1005.
</p>
<p>Orlando, M., &amp; Thissen, D. (2000). Likelihood-based item-fit indices for
dichotomous item response theory models.
<em>Applied Psychological Measurement, 24</em>, 50-64.
</p>
<p>Orlando, M., &amp; Thissen, D. (2003). Further investigation of the performance of
S-X2: An item fit index for use with dichotomous item response theory models.
<em>Applied Psychological Measurement, 27</em>, 289-298.
</p>
<p>Zhang, B., &amp; Stone, C. A. (2008). Evaluating item fit for multidimensional
item response models. <em>Educational and Psychological Measurement,
68</em>, 181-196.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Items with unequal item slopes
#############################################################################

# simulate data
set.seed(9871)
I &lt;- 11
b &lt;- seq( -1.5, 1.5, length=I)
a &lt;- rep(1,I)
a[4] &lt;- .4
N &lt;- 1000
library(sirt)
dat &lt;- sirt::sim.raschtype( theta=stats::rnorm(N), b=b, fixed.a=a)

#*** 1PL model estimated with gdm
mod1 &lt;- CDM::gdm( dat, theta.k=seq(-6,6,len=21), irtmodel="1PL" )
summary(mod1)
# estimate item fit statistic
fitmod1 &lt;- CDM::itemfit.sx2(mod1)
summary(fitmod1)
  ##       item itemindex   S-X2 df     p S-X2_df RMSEA Nscgr Npars p.holm
  ##   1  I0001         1  4.173  9 0.900   0.464 0.000    10     1  1.000
  ##   2  I0002         2 12.365  9 0.193   1.374 0.019    10     1  1.000
  ##   3  I0003         3  6.158  9 0.724   0.684 0.000    10     1  1.000
  ##   4  I0004         4 37.759  9 0.000   4.195 0.057    10     1  0.000
  ##   5  I0005         5 12.307  9 0.197   1.367 0.019    10     1  1.000
  ##   6  I0006         6 19.358  9 0.022   2.151 0.034    10     1  0.223
  ##   7  I0007         7 14.610  9 0.102   1.623 0.025    10     1  0.818
  ##   8  I0008         8 15.568  9 0.076   1.730 0.027    10     1  0.688
  ##   9  I0009         9  8.471  9 0.487   0.941 0.000    10     1  1.000
  ##   10 I0010        10  8.330  9 0.501   0.926 0.000    10     1  1.000
  ##   11 I0011        11 12.351  9 0.194   1.372 0.019    10     1  1.000
  ##
  ##   -- Average Item Fit Statistics --
  ##   S-X2=13.768 | S-X2_df=1.53
# -&gt; 4th item does not fit to the 1PL model

# plot item fit
plot(fitmod1)

#*** 2PL model estimated with gdm
mod2 &lt;- CDM::gdm( dat, theta.k=seq(-6,6,len=21), irtmodel="2PL", maxiter=100 )
summary(mod2)
# estimate item fit statistic
fitmod2 &lt;- CDM::itemfit.sx2(mod2)
summary(fitmod2)
  ##       item itemindex   S-X2 df     p S-X2_df RMSEA Nscgr Npars p.holm
  ##   1  I0001         1  4.083  8 0.850   0.510 0.000    10     2  1.000
  ##   2  I0002         2 13.580  8 0.093   1.697 0.026    10     2  0.747
  ##   3  I0003         3  6.236  8 0.621   0.780 0.000    10     2  1.000
  ##   4  I0004         4  6.049  8 0.642   0.756 0.000    10     2  1.000
  ##   5  I0005         5 12.792  8 0.119   1.599 0.024    10     2  0.834
  ##   6  I0006         6 14.397  8 0.072   1.800 0.028    10     2  0.648
  ##   7  I0007         7 15.046  8 0.058   1.881 0.030    10     2  0.639
  ##   [...]
  ##
  ##   -- Average Item Fit Statistics --
  ##   S-X2=10.22 | S-X2_df=1.277

#*** 1PL model estimation in smirt (sirt package)
Qmatrix &lt;- matrix(1, nrow=I, ncol=1 )
mod1a &lt;- sirt::smirt( dat, Qmatrix=Qmatrix )
summary(mod1a)
# item fit statistic
fitmod1a &lt;- CDM::itemfit.sx2(mod1a)
summary(fitmod1a)

#*** 2PL model estimation in smirt (sirt package)
mod2a &lt;- sirt::smirt( dat, Qmatrix=Qmatrix, est.a="2PL")
summary(mod2a)
# item fit statistic
fitmod2a &lt;- CDM::itemfit.sx2(mod2a)
summary(fitmod2a)

#*** 1PL model estimated with rasch.mml2 (in sirt)
mod1b &lt;- sirt::rasch.mml2(dat)
summary(mod1b)
# estimate item fit statistic
fitmod1b &lt;- CDM::itemfit.sx2(mod1b)
summary(fitmod1b)

#*** 1PL estimated in TAM
library(TAM)
mod1c &lt;- TAM::tam.mml( resp=dat )
summary(mod1c)
# item fit
summary( CDM::itemfit.sx2( mod1c) )
# conversion to mirt object
library(sirt)
library(mirt)
cmod1c &lt;- sirt::tam2mirt( mod1c )
# item fit in mirt
mirt::itemfit( cmod1c$mirt )

#*** 2PL estimated in TAM
mod2c &lt;- TAM::tam.mml.2pl( resp=dat )
summary(mod2c)
# item fit
summary( CDM::itemfit.sx2( mod2c) )
# conversion to mirt object and item fit in mirt
cmod2c &lt;- sirt::tam2mirt( mod2c )
mirt::itemfit( cmod2c$mirt )

# estimation in mirt
mod1d &lt;- mirt::mirt( dat, 1, itemtype="Rasch" )
mirt::itemfit( mod1d )    # compute item fit

#############################################################################
# EXAMPLE 2: Item fit statistics sim.dina dataset
#############################################################################

data(sim.dina, package="CDM")
data(sim.qmatrix, package="CDM")

#*** Model 1: DINA model (correctly specified model)
mod1 &lt;- CDM::din( data=sim.dina, q.matrix=sim.qmatrix )
summary(mod1)
# item fit statistic
summary( CDM::itemfit.sx2( mod1 ) )
  ##   -- Average Item Fit Statistics --
  ##   S-X2=7.397 | S-X2_df=1.233

#*** Model 2: Mixed DINA/DINO model
#***  1th item is misspecified according to DINO rule
I &lt;- ncol(CDM::sim.dina)
rule &lt;- rep("DINA", I )
rule[1] &lt;- "DINO"
mod2 &lt;- CDM::din( data=CDM::sim.dina, q.matrix=CDM::sim.qmatrix, rule=rule)
summary(mod2)
# item fit statistic
summary( CDM::itemfit.sx2( mod2 ) )
  ##   -- Average Item Fit Statistics --
  ##   S-X2=9.925 | S-X2_df=1.654

#*** Model 3: Additive GDINA model
mod3 &lt;- CDM::gdina( data=CDM::sim.dina, q.matrix=CDM::sim.qmatrix, rule="ACDM")
summary(mod3)
# item fit statistic
summary( CDM::itemfit.sx2( mod3 ) )
  ##   -- Average Item Fit Statistics --
  ##   S-X2=8.416 | S-X2_df=1.678

## End(Not run)
</code></pre>

<hr>
<h2 id='logLik'>Extract Log-Likelihood</h2><span id='topic+logLik.din'></span><span id='topic+logLik.gdina'></span><span id='topic+logLik.mcdina'></span><span id='topic+logLik.gdm'></span><span id='topic+logLik.slca'></span><span id='topic+logLik.reglca'></span>

<h3>Description</h3>

<p>Extracts the log-likelihood from either <code>din</code>, <code>gdina</code>,
<code>mcdina</code>, <code>slca</code> or <code>gdm</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'din'
logLik(object, ...)

## S3 method for class 'gdina'
logLik(object, ...)

## S3 method for class 'mcdina'
logLik(object, ...)

## S3 method for class 'gdm'
logLik(object, ...)

## S3 method for class 'slca'
logLik(object, ...)

## S3 method for class 'reglca'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik_+3A_object">object</code></td>
<td>
<p> An object inheriting from either class <code>din</code>,
<code>gdina</code>, <code>slca</code>, <code>reglca</code> or <code>gdm</code>.
</p>
</td></tr>
<tr><td><code id="logLik_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+din">din</a></code>, <code><a href="#topic+gdina">gdina</a></code>, <code><a href="#topic+gdm">gdm</a></code>,
<code><a href="#topic+mcdina">mcdina</a></code>, <code><a href="#topic+slca">slca</a></code>, <code><a href="#topic+reglca">reglca</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sim.dina, package="CDM")
data(sim.qmatrix, package="CDM")

# logLik method | DINA model
d1 &lt;- CDM::din( sim.dina, q.matrix=sim.qmatrix, rule="DINA")
summary(d1)
lld1 &lt;- logLik(d1)
  ##   &gt; lld1
  ##   'log Lik.' -2042.378 (df=25)
  ##   &gt; attr(lld1,"df")
  ##   [1] 25
  ##   &gt; attr(lld1,"nobs")
  ##   [1] 400
nobs(lld1)

# AIC and BIC
AIC(lld1)
BIC(lld1)
</code></pre>

<hr>
<h2 id='mcdina'>
Multiple Choice DINA Model
</h2><span id='topic+mcdina'></span><span id='topic+summary.mcdina'></span><span id='topic+print.mcdina'></span>

<h3>Description</h3>

<p>The function <code>mcdina</code> implements the multiple choice DINA model
(de la Torre, 2009; see also Ozaki, 2015; Chen &amp; Zhou, 2017)
for multiple groups. Note that the dataset must contain
integer values <code class="reqn">1,\ldots, K_j</code> for each item. The multiple choice
DINA model assumes that each item category possesses different diagnostic capacity.
Using this modeling approach, different distractors of a
multiple choice item can be of different diagnostic value. The Q-matrix can also
contain integer values which allows the definition of polytomous attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcdina(dat, q.matrix, group=NULL, itempars="gr", weights=NULL,
    skillclasses=NULL, zeroprob.skillclasses=NULL,
    reduced.skillspace=TRUE, conv.crit=1e-04,
    dev.crit=0.1, maxit=1000, progress=TRUE)

## S3 method for class 'mcdina'
summary(object, digits=4, file=NULL,  ...)

## S3 method for class 'mcdina'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcdina_+3A_dat">dat</code></td>
<td>

<p>A required <code class="reqn">N \times J</code> data matrix containing integer responses
(1, 2, <code class="reqn">\ldots</code>, <code class="reqn">K</code>) of <code class="reqn">N</code> respondents to <code class="reqn">J</code> test items.
</p>
</td></tr>
<tr><td><code id="mcdina_+3A_q.matrix">q.matrix</code></td>
<td>

<p>A required matrix specifying which item category is intended to measure which skill.
The Q-matrix has <code class="reqn">K+2</code> columns for a model with <code class="reqn">K</code> skills.
In the first column should be the item index, in the second column the
category integer and the rest of the columns contains the 'ordinary'
Q-matrix specification. See <code>data.cdm01$q.matrix</code> for the layout of such a
Q-matrix. </p>
</td></tr>
<tr><td><code id="mcdina_+3A_group">group</code></td>
<td>

<p>An optional vector of group identifiers for multiple group estimation.
</p>
</td></tr>
<tr><td><code id="mcdina_+3A_itempars">itempars</code></td>
<td>

<p>A character or a character vector of length <code class="reqn">J</code> indicating whether
item parameters should separately estimated within each group. The default
is <code>"gr"</code>, for group-invariant item parameters choose <code>"jo"</code>.
</p>
</td></tr>
<tr><td><code id="mcdina_+3A_weights">weights</code></td>
<td>

<p>An optional vector of sample weights.
</p>
</td></tr>
<tr><td><code id="mcdina_+3A_skillclasses">skillclasses</code></td>
<td>

<p>An optional matrix for determining the skill space. The argument can be used
if a user wants less than the prespecified number of <code class="reqn">2^K</code> skill classes.
</p>
</td></tr>
<tr><td><code id="mcdina_+3A_zeroprob.skillclasses">zeroprob.skillclasses</code></td>
<td>

<p>An optional vector of integers which indicates which skill classes should have
zero probability. Default is <code>NULL</code> (no skill classes with zero probability).
</p>
</td></tr>
<tr><td><code id="mcdina_+3A_reduced.skillspace">reduced.skillspace</code></td>
<td>
<p>An optional logical indicating whether the
skill space should be reduced to cover only bivariate associations
among skills (see Xu &amp; von Davier, 2008).</p>
</td></tr>
<tr><td><code id="mcdina_+3A_conv.crit">conv.crit</code></td>
<td>

<p>Convergence criterion for change in item parameter values
</p>
</td></tr>
<tr><td><code id="mcdina_+3A_dev.crit">dev.crit</code></td>
<td>

<p>Convergence criterion for change in deviance values
</p>
</td></tr>
<tr><td><code id="mcdina_+3A_maxit">maxit</code></td>
<td>

<p>Maximum number of iterations.
</p>
</td></tr>
<tr><td><code id="mcdina_+3A_progress">progress</code></td>
<td>

<p>An optional logical indicating whether the function should print the
progress of iteration in the estimation process.
</p>
</td></tr>
<tr><td><code id="mcdina_+3A_object">object</code></td>
<td>

<p>Object of class <code>mcdina</code>.
</p>
</td></tr>
<tr><td><code id="mcdina_+3A_digits">digits</code></td>
<td>

<p>Number of digits to display in <code>summary.mcdina</code>
</p>
</td></tr>
<tr><td><code id="mcdina_+3A_file">file</code></td>
<td>
<p>Optional file name for a file in which <code>summary</code>
should be sinked.</p>
</td></tr>
<tr><td><code id="mcdina_+3A_x">x</code></td>
<td>
<p>Object of class <code>mcdina</code></p>
</td></tr>
<tr><td><code id="mcdina_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The multiple choice DINA model defines for each item category <code class="reqn">jc</code> the
necessary skills to master this attribute. Therefore, the vector of skills
<code class="reqn">\bold{\alpha}</code> is transformed into item-specific latent responses
<code class="reqn">\eta_{j}</code> which are functions of
<code class="reqn">\bold{\alpha}</code> and Q-matrix entries <code class="reqn">q_{jc}</code>
(just like in the DINA model). If there are <code class="reqn">K_j</code> item categories for item <code class="reqn">j</code>,
then there exist at most <code class="reqn">K_j</code> values of the latent response <code class="reqn">\eta_j</code>.
</p>
<p>The multiple choice DINA model estimates the item response function as
</p>
<p style="text-align: center;"><code class="reqn"> P( X_{nj}=k | \eta_{nj}=l )=p_{jkl}  </code>
</p>

<p>with the constraint <code class="reqn">\sum_k p_{jkl}=1 </code>.
</p>


<h3>Value</h3>

<p>A list with following entries
</p>
<table role = "presentation">
<tr><td><code>item</code></td>
<td>
<p>Data frame with item parameters</p>
</td></tr>
<tr><td><code>posterior</code></td>
<td>
<p>Individual posterior distribution</p>
</td></tr>
<tr><td><code>likelihood</code></td>
<td>
<p>Individual likelihood</p>
</td></tr>
<tr><td><code>ic</code></td>
<td>
<p>List with information criteria</p>
</td></tr>
<tr><td><code>q.matrix</code></td>
<td>
<p>Used Q-matrix</p>
</td></tr>
<tr><td><code>pik</code></td>
<td>
<p>Array of item-category probabilities</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>Array of item parameters</p>
</td></tr>
<tr><td><code>se.delta</code></td>
<td>
<p>Array of standard errors of item parameters</p>
</td></tr>
<tr><td><code>itemstat</code></td>
<td>
<p>Data frame containing item definitions</p>
</td></tr>
<tr><td><code>n.ik</code></td>
<td>
<p>Array of expected counts</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>Deviance</p>
</td></tr>
<tr><td><code>attribute.patt</code></td>
<td>
<p>Probabilities of latent classes</p>
</td></tr>
<tr><td><code>attribute.patt.splitted</code></td>
<td>
<p>Splitted attribute pattern</p>
</td></tr>
<tr><td><code>skill.patt</code></td>
<td>
<p>Marginal skill probabilities</p>
</td></tr>
<tr><td><code>MLE.class</code></td>
<td>
<p>Classified skills for each student (MLE)</p>
</td></tr>
<tr><td><code>MAP.class</code></td>
<td>
<p>Classified skills for each student (MAP)</p>
</td></tr>
<tr><td><code>EAP.class</code></td>
<td>
<p>Classified skills for each student (EAP)</p>
</td></tr>
<tr><td><code>dat</code></td>
<td>
<p>Used dataset</p>
</td></tr>
<tr><td><code>skillclasses</code></td>
<td>
<p>Used skill classes</p>
</td></tr>
<tr><td><code>group</code></td>
<td>
<p>Used group identifiers</p>
</td></tr>
<tr><td><code>lc</code></td>
<td>
<p>Data frame containing definitions of each item category</p>
</td></tr>
<tr><td><code>lr</code></td>
<td>
<p>Data frame containing the relation of each latent class and each item category</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Number of iterations</p>
</td></tr>
<tr><td><code>itempars</code></td>
<td>
<p>Used specification of item parameter estimation type</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>Logical indicating whether convergence was achieved.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If <code>dat</code> and <code>q.matrix</code> correspond to the 'ordinary format' which is used
in <code>gdina</code>, then the function <code>mcdina</code> will detect it and convert it
into the necessary format (see Example 2).
</p>


<h3>References</h3>

<p>Chen, J., &amp; Zhou, H. (2017) Test designs and modeling under the general
nominal diagnosis model framework. <em>PLoS ONE 12</em>(6), e0180016.
</p>
<p>de la Torre, J. (2009). A cognitive diagnosis model for cognitively based
multiple-choice options. <em>Applied Psychological Measurement, 33</em>, 163-183.
</p>
<p>Ozaki, K. (2015). DINA models for multiple-choice items with few parameters:
Considering incorrect answers.
<em>Applied Psychological Measurement, 39</em>(6), 431-447.
</p>
<p>Xu, X., &amp; von Davier, M. (2008). <em>Fitting the structured general diagnostic
model to NAEP data</em>. ETS Research Report ETS RR-08-27. Princeton, ETS.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+din">din</a></code> for estimating the DINA/DINO model and <code><a href="#topic+gdina">gdina</a></code>
for estimating the GDINA model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: Multiple choice DINA model for data.cdm01 dataset
#############################################################################

data(data.cdm01, package="CDM")

dat &lt;- data.cdm01$data
group &lt;- data.cdm01$group
q.matrix &lt;- data.cdm01$q.matrix

#*** Model 1: Single group model
mod1 &lt;- CDM::mcdina( dat=dat, q.matrix=q.matrix )
summary(mod1)

#*** Model 2: Multiple group model with group-invariant item parameters
mod2 &lt;- CDM::mcdina( dat=dat, q.matrix=q.matrix, group=group, itempars="jo")
summary(mod2)

## Not run: 
#*** Model 3: Multiple group model with group-specific item parameters
mod3 &lt;- CDM::mcdina( dat=dat, q.matrix=q.matrix, group=group, itempars="gr")
summary(mod3)

#*** Model 4: Multiple group model with some group-specific item parameters
itempars &lt;- rep("jo", ncol(dat))
itempars[ c( 2, 7, 9) ] &lt;- "gr" # set items 2,7 and 9 group specific
mod4 &lt;- CDM::mcdina( dat=dat, q.matrix=q.matrix, group=group, itempars=itempars)
summary(mod4)

#*** Model 5: Reduced skill space

# define skill classes
skillclasses &lt;- scan(nlines=1)  # read only one line
    0 0 0    1 0 0    0 1 0    0 0 1    1 1 0     1 1 1
skillclasses &lt;- matrix( skillclasses, ncol=3, byrow=TRUE )
mod5 &lt;- CDM::mcdina( dat, q.matrix=q.matrix, group=group0,  skillclasses=skillclasses )
summary(mod5)

#*** Model 6: Reduced skill space with setting zero probabilities
#             for some latent classes

# set probabilities of classes P101 P011 (6th and 7th class) to zero
zeroprob.skillclasses &lt;- c(6,7)
mod6 &lt;- CDM::mcdina( dat, q.matrix, group=group, zeroprob.skillclasses=zeroprob.skillclasses )
summary(mod6)

#############################################################################
# EXAMPLE 2: Using the mcdina function for estimating the DINA model
#############################################################################

data(sim.dina, package="CDM")
data(sim.qmatrix, package="CDM")

# estimate the DINA model
mod &lt;- CDM::mcdina( sim.dina, q.matrix=sim.qmatrix )
summary(mod)

#############################################################################
# EXAMPLE 3: MCDINA model with polytomous attributes
#############################################################################

data(data.cdm02, package="CDM")
dat &lt;- data.cdm02$data
q.matrix &lt;- data.cdm02$q.matrix

# estimate model with polytomous attribute B1
mod1 &lt;- CDM::mcdina( dat, q.matrix=q.matrix )
summary(mod1)

## End(Not run)
</code></pre>

<hr>
<h2 id='modelfit.cor'>
Assessing Model Fit and Local Dependence by Comparing Observed and Expected
Item Pair Correlations
</h2><span id='topic+modelfit.cor'></span><span id='topic+modelfit.cor2'></span><span id='topic+modelfit.cor.din'></span><span id='topic+summary.modelfit.cor.din'></span>

<h3>Description</h3>

<p>This function computes several measures of absolute model fit and local
dependence indices for dichotomous item responses which are
based on comparing observed and expected frequencies of item pairs
(Chen, de la Torre &amp; Zhang, 2013; see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelfit.cor(data, posterior, probs)
modelfit.cor2(data, posterior, probs)

modelfit.cor.din( dinobj, jkunits=0 )

## S3 method for class 'modelfit.cor.din'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modelfit.cor_+3A_data">data</code></td>
<td>

<p>An <code class="reqn">N \times I</code> data frame of dichotomous item responses
</p>
</td></tr>
<tr><td><code id="modelfit.cor_+3A_posterior">posterior</code></td>
<td>

<p>A matrix containing the posterior distribution (e.g. obtained as
an output of the <code><a href="#topic+din">din</a></code> function).
</p>
</td></tr>
<tr><td><code id="modelfit.cor_+3A_probs">probs</code></td>
<td>

<p>An array of dimension [items,categories,attribute classes]
containing probabilities
</p>
</td></tr>
<tr><td><code id="modelfit.cor_+3A_dinobj">dinobj</code></td>
<td>

<p>An object of class <code><a href="#topic+din">din</a></code>, <code><a href="#topic+gdina">gdina</a></code> or
<code><a href="#topic+gdm">gdm</a></code> (only for dichotomous item responses)
</p>
</td></tr>
<tr><td><code id="modelfit.cor_+3A_object">object</code></td>
<td>

<p>An object of class <code><a href="#topic+din">din</a></code>, <code><a href="#topic+gdina">gdina</a></code> or
<code><a href="#topic+gdm">gdm</a></code> (only for dichotomous item responses)
</p>
</td></tr>
<tr><td><code id="modelfit.cor_+3A_jkunits">jkunits</code></td>
<td>
<p>Number of Jackknife units. The default is to use 0 units
(no use of jackknifing). If jackknife estimation should be
employed, use (say) at least 20 jackknife units.
The input <code>jkunits</code> can be also a vector of jackknife unit identifiers.
</p>
</td></tr>
<tr><td><code id="modelfit.cor_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fit statistics are based on predictions of the pairwise table
<code class="reqn">(X_i, X_j)</code> of item responses. The <code class="reqn">\chi^2</code> statistic <code>X2</code> for
item pairs <code class="reqn">i</code> and <code class="reqn">j</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn"> \chi^2_{ij}=\sum_{k=0}^1 \sum_{l=0}^1 \frac{ (n_{ij,kl}-e_{ij,kl}) ^2 }{ e_{ij,kl} }</code>
</p>

<p>where <code class="reqn">n_{ij,kl}</code> is the absolute frequency of <code class="reqn">\{ X_{i}=k,X_j=l\}</code>
and <code class="reqn">e_{ij,kl}</code> is the expected frequency using the estimated model.
Note that for calculating <code class="reqn">e_{ij,kl}</code>, individual posterior distributions
are evaluated.  The <code class="reqn">\chi^2_{ij} </code> statistic is chi-square distributed with one
degree of freedom and can be used for testing whether items <code class="reqn">i</code> and
<code class="reqn">j</code> are locally dependent. To control for multiple comparisons,
p-value adjustments according to the Holm and FDR method are conducted
(see <code><a href="stats.html#topic+p.adjust">stats::p.adjust</a></code>).
</p>
<p>The residual covariance <code>RESIDCOV</code> of item pairs <code class="reqn">(i,j)</code> is calculated
as </p>
<p style="text-align: center;"><code class="reqn"> RESIDCOV_{ij}=
    \frac{ n_{ij,11} n_{ij,00} - n_{ij,10} n_{ij,01} }{n^2 } -
        \frac{ e_{ij,11} e_{ij,00} - e_{ij,10} e_{ij,01} }{n^2 } </code>
</p>

<p>where <code>MRESIDCOV</code> is the average of all <code>RESIDCOV</code> statistics
and is the total sample size.
</p>
<p>The statistic <code>MADcor</code> denotes the average absolute deviation between
observed correlations <code class="reqn">r_{ij}</code> and model predicted correlations
<code class="reqn">\hat{r}_{ij}</code> of item pairs <code class="reqn">(i,j)</code>:
</p>
<p style="text-align: center;"><code class="reqn"> MADcor=\frac{1}{ J(J-1)/2 } \sum_{i &lt; j} | r_{ij} - \hat{r}_{ij} |</code>
</p>

<p>The SRMSR (standardized root mean square root of squared residuals,
Maydeu-Olivares, 2013) is also based on comparing these correlations
</p>
<p style="text-align: center;"><code class="reqn"> SRMSR=\sqrt{ \frac{1}{ J(J-1)/2 } \sum_{i &lt; j}
    ( r_{ij} - \hat{r}_{ij} )^2 } </code>
</p>

<p>For calculating <code>MADQ3</code> and <code>MADaQ3</code>,
residuals <code class="reqn">\varepsilon_{ni}=X_{ni} - e_{ni}</code> of
observed and expected responses for respondents <code class="reqn">n</code> and items <code class="reqn">i</code> are
constructed. Then, the average of the absolute values of pairwise correlations
of these residuals is computed for <code>MADQ3</code>. For <code>MADaQ3</code>, the average
of the centered pairwise values (i.e. by subtracting the average Q3 statistic)
is calculated.
</p>
<p>The difference of Fisher transformed correlations (Chen et al., 2013) is also
computed and used for assessing statistical inference.
</p>
<p>For every of the fit statistics <code>MADcor</code>, <code>MADacor</code>, <code>SRMSR</code>, <code>MX2</code>,
<code>100*MADRESIDCOV</code> and <code>MADQ3</code> it holds that smaller values
(values near to zero) indicate better fit.
</p>
<p>Standard errors and confidence intervals of fit statistics are obtained
by Jackknife estimation.
</p>


<h3>Value</h3>

<p>A list with following entries
</p>
<table role = "presentation">
<tr><td><code>modelfit.stat</code></td>
<td>
<p>Model fit statistics:
</p>
<p><code>MADcor</code>: mean of absolute deviations in observed and expected correlations
(DiBello, Roussos &amp; Stout, 2007)
</p>
<p><code>SRMSR</code>: standardized mean square root of squared residuals
(Maydeu-Olivares, 2013; Maydeu-Olivares &amp; Joe, 2014)
</p>
<p><code>MADRESIDCOV</code>: Mean of absolute deviations of residual covariances
(McDonald &amp; Mok, 1995)
</p>
<p><code>MADQ3</code>: Mean of absolute values of <code class="reqn">Q_3</code> statistic (Yen, 1984)
</p>
<p><code>MADaQ3</code>: Mean of absolute values of centered <code class="reqn">Q_3</code> statistic
</p>
</td></tr>
<tr><td><code>modelfit.test</code></td>
<td>
<p>Test of global absolute model fit using test
statistics of all item pairs. The statistic <code>max(X2)</code> is the
maximum of all <code class="reqn">\chi^2_{ij}</code> statistics accompanied with a p value
obtained by the Holm procedure. A similar statistic <code>abs(fcor)</code>
is created as the absolute value of the deviations of Fisher
transformed correlations as used in Chen et al. (2013).
</p>
</td></tr>
<tr><td><code>itempairs</code></td>
<td>

<p>Fit of itempairs which can be used for inspection of local
dependence. The <code class="reqn">\chi^2_{ij}</code> statistic is denoted by <code>X2</code>
(Chen &amp; Thissen, 1997), the statistic <code class="reqn">r_{ij}</code> based on absolute
deviations of observed and predicted correlations is <code>fcor</code>
(Chen et al., 2013).
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The function does not handle sample weights properly.
</p>
<p>The function <code>modelfit.cor2</code> has the same functionality as
<code>modelfit.cor</code> but it is much faster because it is based on
<span class="pkg">Rcpp</span> code.
</p>


<h3>References</h3>

<p>Chen, J., de la Torre, J., &amp; Zhang, Z. (2013).
Relative and absolute fit evaluation in cognitive diagnosis modeling.
<em>Journal of Educational Measurement, 50</em>, 123-140.
</p>
<p>Chen, W., &amp; Thissen, D. (1997). Local dependence indexes for item pairs
using item response theory. <em>Journal of Educational and Behavioral Statistics,
22</em>, 265-289.
</p>
<p>DiBello, L. V., Roussos, L. A., &amp; Stout, W. F. (2007). Review of
cognitively diagnostic assessment and a summary of psychometric models.
In C. R. Rao and S. Sinharay (Eds.), <em>Handbook of Statistics</em>,
Vol. 26 (pp. 979&ndash;1030). Amsterdam: Elsevier.
</p>
<p>Maydeu-Olivares, A. (2013). Goodness-of-fit assessment of item response
theory models (with discussion).
<em>Measurement: Interdisciplinary Research and Perspectives,
11</em>, 71-137.
</p>
<p>Maydeu-Olivares, A., &amp; Joe, H. (2014). Assessing approximate fit in categorical
data analysis. <em>Multivariate Behavioral Research, 49</em>, 305-328.
</p>
<p>McDonald, R. P., &amp; Mok, M. M.-C. (1995). Goodness of fit in item response models.
<em>Multivariate Behavioral Research, 30</em>, 23-40.
</p>
<p>Yen, W. M. (1984). Effects of local item dependence on the fit and equating
performance of the three-parameter logistic model.
<em>Applied Psychological Measurement, 8</em>, 125-145.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Model fit for sim.dina
#############################################################################

data(sim.dina, package="CDM")
data(sim.qmatrix, package="CDM")
dat &lt;- sim.dina
q.matrix &lt;- sim.qmatrix

#*** Model 1: DINA model for DINA simulated data
mod1 &lt;- CDM::din(dat, q.matrix=q.matrix, rule="DINA" )
fmod1 &lt;- CDM::modelfit.cor.din(mod1, jkunits=10)
summary(fmod1)
  ##   Test of Global Model Fit
  ##          type value     p
  ##   1   max(X2) 8.728 0.113
  ##   2 abs(fcor) 0.143 0.080
  ##
  ##   Fit Statistics
  ##                     est jkunits jk_est jk_se est_low est_upp
  ##   MADcor          0.030      10  0.020 0.005   0.010   0.030
  ##   SRMSR           0.040      10  0.023 0.006   0.011   0.035
  ##   100*MADRESIDCOV 0.671      10  0.445 0.125   0.200   0.690
  ##   MADQ3           0.062      10  0.037 0.008   0.021   0.052
  ##   MADaQ3          0.059      10  0.034 0.008   0.019   0.050

# look at first five item pairs with highest degree of local dependence
itempairs &lt;- fmod1$itempairs
itempairs &lt;- itempairs[ order( itempairs$X2, decreasing=TRUE ), ]
itempairs[ 1:5, c("item1","item2", "X2", "X2_p", "X2_p.holm", "Q3") ]
  ##      item1 item2       X2        X2_p X2_p.holm          Q3
  ##   29 Item5 Item8 8.728248 0.003133174 0.1127943 -0.26616414
  ##   32 Item6 Item8 2.644912 0.103881881 1.0000000  0.04873154
  ##   21 Item3 Item9 2.195011 0.138458201 1.0000000  0.05948456
  ##   10 Item2 Item4 1.449106 0.228671389 1.0000000 -0.08036216
  ##   30 Item5 Item9 1.393583 0.237800911 1.0000000 -0.01934420

#*** Model 2: DINO model for DINA simulated data
mod2 &lt;- CDM::din(dat, q.matrix=q.matrix, rule="DINO" )
fmod2 &lt;- CDM::modelfit.cor.din(mod2, jkunits=10 )   # 10 jackknife units
summary(fmod2)
  ##   Test of Global Model Fit
  ##          type  value     p
  ##   1   max(X2) 13.139 0.010
  ##   2 abs(fcor)  0.199 0.001
  ##
  ##   Fit Statistics
  ##                     est jkunits jk_est jk_se est_low est_upp
  ##   MADcor          0.056      10  0.041 0.007   0.026   0.055
  ##   SRMSR           0.072      10  0.045 0.019   0.007   0.083
  ##   100*MADRESIDCOV 1.225      10  0.878 0.183   0.519   1.236
  ##   MADQ3           0.073      10  0.055 0.012   0.031   0.080
  ##   MADaQ3          0.073      10  0.066 0.012   0.042   0.089

#*** Model 3: estimate DINA model with gdina function
mod3 &lt;- CDM::gdina( dat, q.matrix=q.matrix, rule="DINA" )
fmod3 &lt;- CDM::modelfit.cor.din( mod3, jkunits=0 )  # no Jackknife estimation
summary(fmod3)
  ##   Test of Global Model Fit
  ##          type value     p
  ##   1   max(X2) 8.756 0.111
  ##   2 abs(fcor) 0.143 0.078
  ##
  ##   Fit Statistics
  ##                     est
  ##   MADcor          0.030
  ##   SRMSR           0.040
  ##   MX2             0.719
  ##   100*MADRESIDCOV 0.668
  ##   MADQ3           0.062
  ##   MADaQ3          0.059

#############################################################################
# EXAMPLE 2: Simulated Example DINA model
#############################################################################

set.seed(9765)
# specify Q-matrix
Q &lt;- matrix( c(1,0, 0,1, 1,1 ), nrow=3, ncol=2, byrow=TRUE )
q.matrix &lt;- Q[ rep(1:3,4), ]
I &lt;- nrow(q.matrix)

# simulate data
guess &lt;- stats::runif(I, 0, .3 )
slip &lt;- stats::runif( I, 0, .4 )
N &lt;- 150   # number of persons
dat &lt;- CDM::sim.din( N=N, q.matrix=q.matrix, slip=slip, guess=guess )$dat

#*** estmate DINA model
mod1 &lt;- CDM::din( dat, q.matrix=q.matrix, rule="DINA" )
fmod1 &lt;- CDM::modelfit.cor.din(mod1, jkunits=10)
summary(fmod1)
  ##  Test of Global Model Fit
  ##         type  value     p
  ##  1   max(X2) 10.697 0.071
  ##  2 abs(fcor)  0.277 0.026
  ##
  ##  Fit Statistics
  ##                    est jkunits jk_est jk_se est_low est_upp
  ##  MADcor          0.052      10  0.026 0.010   0.006   0.045
  ##  SRMSR           0.074      10  0.048 0.013   0.022   0.074
  ##  100*MADRESIDCOV 1.259      10  0.646 0.213   0.228   1.063
  ##  MADQ3           0.080      10  0.047 0.010   0.027   0.068
  ##  MADaQ3          0.079      10  0.046 0.010   0.027   0.065

## End(Not run)
</code></pre>

<hr>
<h2 id='numerical_Hessian'>
Numerical Computation of the Hessian Matrix
</h2><span id='topic+numerical_Hessian'></span><span id='topic+numerical_Hessian_partial'></span><span id='topic+numerical_gradient'></span>

<h3>Description</h3>

<p>Computes numerically the Hessian matrix of a given function for
all coordinates (<code>numerical_Hessian</code>), for a selected
direction (<code>numerical_Hessian_partial</code>) or the gradient
of a multivariate function (<code>numerical_gradient</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numerical_Hessian(par, FUN, h=1e-05, gradient=FALSE,
       hessian=TRUE, diag_only=FALSE, ...)

numerical_Hessian_partial(par, FUN, h=1e-05, coordinate=1, ... )

numerical_gradient(par, FUN, h=1E-5, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="numerical_Hessian_+3A_par">par</code></td>
<td>

<p>Parameter vector
</p>
</td></tr>
<tr><td><code id="numerical_Hessian_+3A_fun">FUN</code></td>
<td>

<p>Specified function with argument vector <code>x</code>
</p>
</td></tr>
<tr><td><code id="numerical_Hessian_+3A_h">h</code></td>
<td>

<p>Numerical differentiation parameter. Can be also a vector.
The increment in the numerical approximation of the derivative is
defined as <code class="reqn">h_i \max ( 1, \theta_i)</code> where <code class="reqn">\theta_i</code>
denotes the <code class="reqn">i</code>th parameter.
</p>
</td></tr>
<tr><td><code id="numerical_Hessian_+3A_gradient">gradient</code></td>
<td>

<p>Logical indicating whether the gradient should be calculated.
</p>
</td></tr>
<tr><td><code id="numerical_Hessian_+3A_hessian">hessian</code></td>
<td>
<p>Logical indicating whether the Hessian
matrix should be calculated.</p>
</td></tr>
<tr><td><code id="numerical_Hessian_+3A_diag_only">diag_only</code></td>
<td>
<p>Logical indicating whether only the diagonal of the
hessian should be computed.</p>
</td></tr>
<tr><td><code id="numerical_Hessian_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code>FUN</code>.</p>
</td></tr>
<tr><td><code id="numerical_Hessian_+3A_coordinate">coordinate</code></td>
<td>
<p>Coordinate index for partial derivative</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Gradient vector or Hessian matrix or a list of both elements
</p>


<h3>See Also</h3>

<p>See the <span class="pkg">numDeriv</span> package and the
<code><a href="mirt.html#topic+numerical_deriv">mirt::numerical_deriv</a></code>
function from the <span class="pkg">mirt</span> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: Toy example for Hessian matrix
#############################################################################

# define function
f &lt;- function(x){
     3*x[1]^3 - 4*x[2]^2 - 5*x[1]*x[2] + 10 * x[1] * x[3]^2 + 6*x[2]*sqrt(x[3])
}
# define point for evaluating partial derivatives
par &lt;- c(3,8,4)

#--- compute gradient
CDM::numerical_Hessian( par=par, FUN=f, gradient=TRUE, hessian=FALSE)
## Not run: 
mirt::numerical_deriv(par=par, f=f, gradient=TRUE)

#--- compute Hessian matrix
CDM::numerical_Hessian( par=par, FUN=f )
mirt::numerical_deriv(par=par, f=f, gradient=FALSE)
numerical_Hessian( par=par, FUN=f, h=1E-4 )

#--- compute gradient and Hessian matrix
CDM::numerical_Hessian( par=par, FUN=f, gradient=TRUE, hessian=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='osink'>
Opens and Closes a <code>sink</code> Connection
</h2><span id='topic+osink'></span><span id='topic+csink'></span>

<h3>Description</h3>

<p>Opens and closes a <code>sink</code> connection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>osink(file, suffix, append=FALSE)

csink(file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="osink_+3A_file">file</code></td>
<td>

<p>File name. No <code>sink</code> is done if it has the value <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="osink_+3A_suffix">suffix</code></td>
<td>

<p>Suffix which should be put next to the file name
</p>
</td></tr>
<tr><td><code id="osink_+3A_append">append</code></td>
<td>
<p>Optional logical indicating whether console output should
be appended to an already existing file. See argument <code>append</code> in
<code><a href="base.html#topic+sink">base::sink</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="base.html#topic+sink">base::sink</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The function 'osink' is currently defined as
function (file, suffix){
    if (!is.null(file)) {
        base::sink(paste0(file, suffix), split=TRUE)
       }
  }

## The function 'csink' is currently defined as
function (file){
    if (!is.null(file)) {
        base::sink()
        }
  }
</code></pre>

<hr>
<h2 id='personfit.appropriateness'>
Appropriateness Statistic for Person Fit Assessment
</h2><span id='topic+personfit.appropriateness'></span><span id='topic+summary.personfit.appropriateness'></span><span id='topic+plot.personfit.appropriateness'></span>

<h3>Description</h3>

<p>This function computes the person fit appropriateness statistics
(Levine &amp; Drasgow, 1988) as proposed for cognitive diagnostic
models by Liu, Douglas and Henson (2009). The appropriateness statistic
assesses spuriously high scorers (<code>attr.type=1</code>) and
spuriously low scorers (<code>attr.type=0</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>personfit.appropriateness(data, probs, skillclassprobs, h=0.001, eps=1e-10,
    maxiter=30, conv=1e-05, max.increment=0.1, progress=TRUE)

## S3 method for class 'personfit.appropriateness'
summary(object, digits=3,  ...)

## S3 method for class 'personfit.appropriateness'
plot(x, cexpch=.65,  ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="personfit.appropriateness_+3A_data">data</code></td>
<td>

<p>Data frame of dichotomous item responses
</p>
</td></tr>
<tr><td><code id="personfit.appropriateness_+3A_probs">probs</code></td>
<td>

<p>Probabilities evaluated at skill space (abilities <code class="reqn">\theta</code>)
</p>
</td></tr>
<tr><td><code id="personfit.appropriateness_+3A_skillclassprobs">skillclassprobs</code></td>
<td>

<p>Probabilities of skill classes
</p>
</td></tr>
<tr><td><code id="personfit.appropriateness_+3A_h">h</code></td>
<td>

<p>Numerical differentiation parameter
</p>
</td></tr>
<tr><td><code id="personfit.appropriateness_+3A_eps">eps</code></td>
<td>

<p>Constant which is added to probabilities avoiding zero probability
</p>
</td></tr>
<tr><td><code id="personfit.appropriateness_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
<tr><td><code id="personfit.appropriateness_+3A_conv">conv</code></td>
<td>

<p>Convergence criterion
</p>
</td></tr>
<tr><td><code id="personfit.appropriateness_+3A_max.increment">max.increment</code></td>
<td>

<p>Maximum increment in iteration
</p>
</td></tr>
<tr><td><code id="personfit.appropriateness_+3A_progress">progress</code></td>
<td>

<p>Optional logical indicating whether iteration progress should
be displayed.
</p>
</td></tr>
<tr><td><code id="personfit.appropriateness_+3A_object">object</code></td>
<td>
<p>Object of class <code>personfit.appropriateness</code></p>
</td></tr>
<tr><td><code id="personfit.appropriateness_+3A_digits">digits</code></td>
<td>
<p>Number of digits for rounding</p>
</td></tr>
<tr><td><code id="personfit.appropriateness_+3A_x">x</code></td>
<td>
<p>Object of class <code>personfit.appropriateness</code></p>
</td></tr>
<tr><td><code id="personfit.appropriateness_+3A_cexpch">cexpch</code></td>
<td>
<p>Point size in plot</p>
</td></tr>
<tr><td><code id="personfit.appropriateness_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with following entries
</p>
<table role = "presentation">
<tr><td><code>summary</code></td>
<td>
<p>Summaries of person fit statistic</p>
</td></tr>
<tr><td><code>personfit.appr.type1</code></td>
<td>
<p>Statistic for spuriously high scorers
(<code>appr.type=1</code>) evaluated for every person.</p>
</td></tr>
<tr><td><code>personfit.appr.type0</code></td>
<td>
<p>Statistic for spuriously low scorers
(<code>appr.type=0</code>) evaluated for every person.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Levine, M. V., &amp; Drasgow, F. (1988). Optimal appropriateness measurement.
<em>Psychometrika, 53</em>, 161-176.
</p>
<p>Liu, Y., Douglas, J. A., &amp; Henson, R. A. (2009). Testing person fit in cognitive
diagnosis. <em>Applied Psychological Measurement, 33</em>(8), 579-598.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: DINA model data.ecpe
#############################################################################

data(data.ecpe, package="CDM")

# fit DINA model
mod1 &lt;- CDM::din( CDM::data.ecpe$data[,-1], q.matrix=CDM::data.ecpe$q.matrix )
summary(mod1)

# person fit appropriateness statistic
data &lt;- mod1$data
probs &lt;- mod1$pjk
skillclassprobs &lt;- mod1$attribute.patt[,1]
res &lt;- CDM::personfit.appropriateness( data, probs, skillclassprobs, maxiter=8)
                 # only few iterations
summary(res)
plot(res)

## Not run: 
#############################################################################
# EXAMPLE 2: Person fit 2PL model
#############################################################################

data(data.read, package="sirt")
dat &lt;- data.read
I &lt;- ncol(dat)

# fit 2PL model
mod1 &lt;- sirt::rasch.mml2( dat, est.a=1:I)
# person fit statistic
data &lt;- mod1$dat
probs0 &lt;- t(mod1$pjk)
probs &lt;- array( 0, dim=c( I, 2, dim(probs0)[2] ) )
probs[,2,] &lt;- probs0
probs[,1,] &lt;- 1 - probs0
skillclassprobs &lt;- mod1$trait.distr$pi.k
res &lt;- CDM::personfit.appropriateness( data, probs, skillclassprobs )
summary(res)
plot(res)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot_item_mastery'>
S3 Methods for Plotting Item Probabilities
</h2><span id='topic+plot_item_mastery'></span><span id='topic+plot_item_mastery.din'></span><span id='topic+plot_item_mastery.gdina'></span>

<h3>Description</h3>

<p>This S3 method plots item probabilities for non-masters and masters of an item.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_item_mastery(object, pch=c(16,17), lty=c(1,2), ...)

## S3 method for class 'din'
plot_item_mastery(object, pch=c(16,17), lty=c(1,2), ...)

## S3 method for class 'gdina'
plot_item_mastery(object, pch=c(16,17), lty=c(1,2), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_item_mastery_+3A_object">object</code></td>
<td>

<p>Object of classes <code><a href="#topic+din">din</a></code> or <code><a href="#topic+gdina">gdina</a></code>
</p>
</td></tr>
<tr><td><code id="plot_item_mastery_+3A_pch">pch</code></td>
<td>
<p>Point symbols for both groups</p>
</td></tr>
<tr><td><code id="plot_item_mastery_+3A_lty">lty</code></td>
<td>
<p>Line symbols for both groups</p>
</td></tr>
<tr><td><code id="plot_item_mastery_+3A_...">...</code></td>
<td>

<p>More arguments to be passed.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot
</p>


<h3>See Also</h3>

<p>Plot functions for item response curves: <code><a href="#topic+IRT.irfprobPlot">IRT.irfprobPlot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Plot item mastery
#############################################################################

data(sim.dina)
data(sim.qmatrix)

#* estimate DINA Model
mod1 &lt;- CDM::din(sim.dina, q.matrix=sim.qmatrix, rule="DINA")
#* estimate GDINA model
mod2 &lt;- CDM::gdina(sim.dina, q.matrix=sim.qmatrix)

#* plots
plot_item_mastery(mod1)
plot_item_mastery(mod2)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.din'>
Plot Method for Objects of Class din
</h2><span id='topic+plot.din'></span>

<h3>Description</h3>

<p>S3 method to plot objects of the class <code>din</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'din'
plot(x, items=c(1:ncol(x$data)), pattern="",
    uncertainty=0.1, top.n.skill.classes=6, pdf.file="",
    hide.obs=FALSE, display.nr=1:4, ask=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.din_+3A_x">x</code></td>
<td>
<p>A required object of class <code>din</code>, obtained from a
call to the function <code><a href="#topic+din">din</a></code>.  </p>
</td></tr>
<tr><td><code id="plot.din_+3A_items">items</code></td>
<td>
<p>An index vector giving the items to be visualized in the first
plot, see &lsquo;Details&rsquo;.  The default is
<code>items=c(1:ncol(x$data))</code>, which is all items.  </p>
</td></tr>
<tr><td><code id="plot.din_+3A_pattern">pattern</code></td>
<td>
<p>An optional character or a numeric vector specifying a response pattern
of an respondent, whose attributes are analyzed in a separate
graphic.  It is required to choose a pattern from the empirical
data set (see Example).  </p>
</td></tr>
<tr><td><code id="plot.din_+3A_uncertainty">uncertainty</code></td>
<td>
<p>A numeric between 0 and 0.5 giving the
uncertainty bounds for deriving the observed skill occurrence probabilities
in plot 2 and the simplified deterministic attribute profiles in plot 4.  </p>
</td></tr>
<tr><td><code id="plot.din_+3A_top.n.skill.classes">top.n.skill.classes</code></td>
<td>
<p>A numeric, specifying the number of skill classes,
starting with the most frequent, to be labeled in plot 3.
Default value is 6.  </p>
</td></tr>
<tr><td><code id="plot.din_+3A_pdf.file">pdf.file</code></td>
<td>
<p>An optional character string. If specified the graphics
obtained from the function <code>plot.din</code> are provided in a pdf file.
The default is <code>pdf.file=""</code>, which is not providing a pdf file.
Otherwise specify a directory and filename ending with <code>.pdf</code> where to
write the document.  </p>
</td></tr>
<tr><td><code id="plot.din_+3A_hide.obs">hide.obs</code></td>
<td>
<p>An optional logical value. If set to <code>TRUE</code>, the
polygonal chain for observed frequencies of skill class probabilities in the
second graphic is not displayed.  </p>
</td></tr>
<tr><td><code id="plot.din_+3A_display.nr">display.nr</code></td>
<td>
<p>An optional numeric or numeric vector. If specified, only the plots in
<code>display.nr</code> are displayed. Default is <code>display.nr=1:4</code> causing the display of
all four plots.   </p>
</td></tr>
<tr><td><code id="plot.din_+3A_ask">ask</code></td>
<td>
<p>An optional logical indicating whether a request for a user input
is necessary before the next figure is drawn.</p>
</td></tr>
<tr><td><code id="plot.din_+3A_...">...</code></td>
<td>
<p>Optional graphical parameters to be passed to or from other
methods will be ignored.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>plot</code> method graphs the results obtained from a CDM analysis.
Four graphics to analyze the fitted model are produced, respectively.
</p>
<p>The first graphic depicts the parameter estimates their diagnostic accuracy
for each of chosen the items in <code>items</code>.  Parameter estimates are
splitted in guessing and slipping errors for each item.  See <code><a href="#topic+din">din</a></code>
for further information.
</p>
<p>The second graphic shows the estimated occurrence probabilities of the attributes
underlying the items.
</p>
<p>The third graphic illustrates the distribution of the skill class occurrence
probabilities.  The <br /> <code>top.n.skill.classes</code> most frequent skill classes are labeled.
</p>
<p>The forth plot is a parallel coordinate plot of the individual skill profiles.
Each line represents an individual skill profile.  For each of these skill profiles
on the vertical lines the individual probabilities of mastering the corresponding
attributes are drawn.
</p>
<p>If in <code>pattern</code> an empirical response pattern is specified, the fifth plot
shows the individual skill profile of an examinee having this response pattern.
For each attribute, having a mastering probability below <code class="reqn">0.5 - uncertainty</code>
the examinee is classified as non-master of the corresponding attribute.  For
mastering probabilities higher than <code class="reqn">0.5 + uncertainty</code> the examinee is
classified as master of the corresponding attribute.
</p>


<h3>Value</h3>

<p>If the argument <code>x</code> is of required type,
and if the optional arguments <code>items</code>, <code>uncertainty</code>,<br />
<code>top.n.skill.classes</code> and <code>pdf.file</code> are specified as required, the
<code>plot.din</code> produces several graphics to analyze a CDM model.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.din">print.din</a></code>, the S3 method for printing objects of
the class <code>din</code>; <code><a href="#topic+summary.din">summary.din</a></code>, the S3
method for summarizing objects of the class <code>din</code>, which
creates objects of the class <code>summary.din</code>;
<code><a href="#topic+print.summary.din">print.summary.din</a></code>, the S3 method for printing
objects of the class <code>summary.din</code>; <code><a href="#topic+din">din</a></code>,
the main function for DINA and DINO parameter estimation, which
creates objects of the class <code>din</code>.  See also <code><a href="#topic+CDM-package">CDM-package</a></code>
for general information about this package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## (1) examples based on dataset fractions.subtraction.data
##

data(fraction.subtraction.data)
data(fraction.subtraction.qmatrix)

## Fix the guessing parameters of items 5, 8 and 9 equal to .20
# define a constraint.guess matrix
constraint.guess &lt;-  matrix(c(5,8,9, rep(0.2, 3)), ncol=2)
fractions.dina.fixed &lt;- CDM::din(data=fraction.subtraction.data,
  q.matrix=fraction.subtraction.qmatrix,
  constraint.guess=constraint.guess)

## The second plot shows the expected (MAP) and observed skill
## probabilities. The third plot visualizes the skill class
## occurrence probabilities; Only the 'top.n.skill.classes' most frequent
## skill classes are labeled; it is obvious that the skill class '11111111'
## (all skills are mastered) is the most probable in this population.
## The fourth plot shows the skill probabilities conditional on response
## patterns; in this population the skills 3 and 6 seem to be
## mastered easier than the others. The fifth plot shows the
## skill probabilities conditional on a specified response
## pattern; it is shown whether a skill is mastered (above
## .5+'uncertainty') unclassifiable (within the boundaries) or
## not mastered (below .5-'uncertainty'). In this case, the
## 527th respondent was chosen; if no response pattern is
## specified, the plot will not be shown (of course)
pattern &lt;- paste(fraction.subtraction.data[527, ], collapse="")
plot(fractions.dina.fixed, pattern=pattern, display.nr=4)

# It is also possible to input a vector of item responses
plot(fractions.dina.fixed, pattern=fraction.subtraction.data[527, ],display.nr=4)

#uncertainty=0.1, top.n.skill.classes=6 are default
plot(fractions.dina.fixed, uncertainty=0.1, top.n.skill.classes=6,
  pattern=pattern)
</code></pre>

<hr>
<h2 id='predict'>
Expected Values and Predicted Probabilities from Item Response Response Models
</h2><span id='topic+IRT.predict'></span><span id='topic+predict.din'></span><span id='topic+predict.gdina'></span><span id='topic+predict.mcdina'></span><span id='topic+predict.gdm'></span><span id='topic+predict.slca'></span>

<h3>Description</h3>

<p>This function computes expected values for each person and each
item based on the individual posterior distribution. The output
of this function can be the basis of creating item and
person fit statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IRT.predict(object, dat, group=1)

## S3 method for class 'din'
predict(object, group=1, ...)

## S3 method for class 'gdina'
predict(object, group=1, ...)

## S3 method for class 'mcdina'
predict(object, group=1, ...)

## S3 method for class 'gdm'
predict(object, group=1, ...)

## S3 method for class 'slca'
predict(object, group=1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict_+3A_object">object</code></td>
<td>

<p>Object for the S3 methods <code><a href="#topic+IRT.irfprob">IRT.irfprob</a></code> and
<code><a href="#topic+IRT.posterior">IRT.posterior</a></code> are defined. In the <span class="pkg">CDM</span> packages,
these are the objects of class <code>din</code>, <code>gdina</code>, <code>mcdina</code>,
<code>slca</code> or <code>gdm</code>.
</p>
</td></tr>
<tr><td><code id="predict_+3A_dat">dat</code></td>
<td>

<p>Dataset with item responses
</p>
</td></tr>
<tr><td><code id="predict_+3A_group">group</code></td>
<td>
<p>Group index for use</p>
</td></tr>
<tr><td><code id="predict_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with following entries
</p>
<table role = "presentation">
<tr><td><code>expected</code></td>
<td>
<p>Array with expected values (persons <code class="reqn">\times</code>
classes <code class="reqn">\times</code> items)</p>
</td></tr>
<tr><td><code>probs.categ</code></td>
<td>
<p>Array with expected probabilities for
each category (persons <code class="reqn">\times</code> categories <code class="reqn">\times</code>
classes <code class="reqn">\times</code> items)</p>
</td></tr>
<tr><td><code>variance</code></td>
<td>
<p>Array with variance in predicted values for each
person and each item.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>Array with residuals for each person and each item</p>
</td></tr>
<tr><td><code>stand.resid</code></td>
<td>
<p>Array with standardized residuals for each
person and each item</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Fitted Rasch model in TAM package
#############################################################################

#--- Model 1: Rasch model
library(TAM)
mod1 &lt;- TAM::tam.mml(resp=TAM::sim.rasch)
# apply IRT.predict function
prmod1 &lt;- CDM::IRT.predict(mod1, mod1$resp )
str(prmod1)

## End(Not run)

#############################################################################
# EXAMPLE 2: Predict function for din
#############################################################################

# DINA Model
mod1 &lt;- CDM::din( CDM::sim.dina, q.matr=CDM::sim.qmatrix, rule="DINA" )
summary(mod1)
# apply predict method
prmod1 &lt;- CDM::IRT.predict( mod1, sim.dina )
str(prmod1)
</code></pre>

<hr>
<h2 id='print.summary.din'>
Print Method for Objects of Class summary.din
</h2><span id='topic+print.summary.din'></span>

<h3>Description</h3>

<p>S3 method to print objects of the class <code>summary.din</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'summary.din'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.din_+3A_x">x</code></td>
<td>
<p>A required object of class <code>summary.din</code>, obtained
from a call to the function <code><a href="#topic+summary.din">summary.din</a></code> (through
generic function <code><a href="base.html#topic+summary">summary</a></code>).  </p>
</td></tr>
<tr><td><code id="print.summary.din_+3A_...">...</code></td>
<td>
<p>Optional parameters to be passed to or from other
methods will be ignored.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>print</code> method prints the summary information about objects
of the class <code>din</code> computed by <code><a href="#topic+summary.din">summary.din</a></code>,
which are the item discriminations indices, the most frequent
skill classes and the model information criteria AIC and BIC.
Specific summary information details such as
individual items with their discrimination index can be accessed through
assignment (see &lsquo;Examples&rsquo;).
</p>


<h3>Value</h3>

<p>If the argument <code>x</code> is of required type,
<code>print.summary.din</code> prints the summary
information in &lsquo;Details&rsquo;, and invisibly returns <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.din">plot.din</a></code>, the S3 method for plotting objects of
the class <code>din</code>; <code><a href="#topic+print.din">print.din</a></code>, the S3 method
for printing objects of the class <code>din</code>;
<code><a href="#topic+summary.din">summary.din</a></code>, the S3 method for summarizing objects
of the class <code>din</code>, which creates objects of the class
<code>summary.din</code>; <code><a href="#topic+din">din</a></code>, the main function for
DINA and DINO parameter estimation, which creates objects of the class
<code>din</code>.  See also <code><a href="#topic+CDM-package">CDM-package</a></code> for general
information about this package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## (1) examples based on dataset fractions.subtraction.data
##

## In particular, accessing detailed summary through assignment
mod &lt;- CDM::din(data=CDM::fraction.subtraction.data,
          q.matrix=CDM::fraction.subtraction.qmatrix, rule="DINA")
smod &lt;- summary(mod)
str(smod)
</code></pre>

<hr>
<h2 id='reglca'>
Regularized Latent Class Analysis
</h2><span id='topic+reglca'></span><span id='topic+summary.reglca'></span>

<h3>Description</h3>

<p>Estimates the regularized latent class model for dichotomous
responses based on regularization methods
(Chen, Liu, Xu, &amp; Ying, 2015; Chen, Li, Liu, &amp; Ying, 2017).
The SCAD and MCP penalty functions are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reglca(dat, nclasses, weights=NULL, group=NULL, regular_type="scad",
   regular_lam=0, sd_noise_init=1, item_probs_init=NULL, class_probs_init=NULL,
   random_starts=1, random_iter=20, conv=1e-05, h=1e-04, mstep_iter=10,
   maxit=1000, verbose=TRUE, prob_min=.0001)

## S3 method for class 'reglca'
summary(object, digits=4, file=NULL,  ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reglca_+3A_dat">dat</code></td>
<td>

<p>Matrix with dichotomous item responses. <code>NA</code>s are allowed.
</p>
</td></tr>
<tr><td><code id="reglca_+3A_nclasses">nclasses</code></td>
<td>

<p>Number of classes
</p>
</td></tr>
<tr><td><code id="reglca_+3A_weights">weights</code></td>
<td>

<p>Optional vector of sampling weights
</p>
</td></tr>
<tr><td><code id="reglca_+3A_group">group</code></td>
<td>

<p>Optional vector for grouping variable
</p>
</td></tr>
<tr><td><code id="reglca_+3A_regular_type">regular_type</code></td>
<td>

<p>Regularization type. Can be <code>scad</code> or <code>mcp</code>. See <code><a href="#topic+gdina">gdina</a></code> for
more information.
</p>
</td></tr>
<tr><td><code id="reglca_+3A_regular_lam">regular_lam</code></td>
<td>

<p>Regularization parameter <code class="reqn">\lambda</code>
</p>
</td></tr>
<tr><td><code id="reglca_+3A_sd_noise_init">sd_noise_init</code></td>
<td>

<p>Standard deviation for amount of noise in generating random starting values
</p>
</td></tr>
<tr><td><code id="reglca_+3A_item_probs_init">item_probs_init</code></td>
<td>

<p>Optional matrix of initial item response probabilities
</p>
</td></tr>
<tr><td><code id="reglca_+3A_class_probs_init">class_probs_init</code></td>
<td>

<p>Optional vector of class probabilities
</p>
</td></tr>
<tr><td><code id="reglca_+3A_random_starts">random_starts</code></td>
<td>

<p>Number of random starts
</p>
</td></tr>
<tr><td><code id="reglca_+3A_random_iter">random_iter</code></td>
<td>

<p>Number of initial iterations for random starts
</p>
</td></tr>
<tr><td><code id="reglca_+3A_conv">conv</code></td>
<td>

<p>Convergence criterion
</p>
</td></tr>
<tr><td><code id="reglca_+3A_h">h</code></td>
<td>

<p>Numerical differentiation parameter
</p>
</td></tr>
<tr><td><code id="reglca_+3A_mstep_iter">mstep_iter</code></td>
<td>

<p>Number of iterations in the M-step
</p>
</td></tr>
<tr><td><code id="reglca_+3A_maxit">maxit</code></td>
<td>

<p>Maximum number of iterations
</p>
</td></tr>
<tr><td><code id="reglca_+3A_verbose">verbose</code></td>
<td>

<p>Logical indicating whether convergence progress should be displayed
</p>
</td></tr>
<tr><td><code id="reglca_+3A_prob_min">prob_min</code></td>
<td>
<p>Lower bound for probabilities in estimation</p>
</td></tr>
<tr><td><code id="reglca_+3A_object">object</code></td>
<td>
<p>A required object of class <code>gdina</code>, obtained
from a call to the function <code><a href="#topic+gdina">gdina</a></code>.  </p>
</td></tr>
<tr><td><code id="reglca_+3A_digits">digits</code></td>
<td>
<p>Number of digits after decimal separator to display.  </p>
</td></tr>
<tr><td><code id="reglca_+3A_file">file</code></td>
<td>
<p>Optional file name for a file in which <code>summary</code>
should be sinked.</p>
</td></tr>
<tr><td><code id="reglca_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The regularized latent class model for dichotomous item responses assumes <code class="reqn">C</code>
latent classes. The item response probabilities <code class="reqn">P(X_i=1|c)=p_{ic}</code> are estimated
in such a way such that the number of different <code class="reqn">p_{ic}</code> values per item is
minimized. This approach eases interpretability and enables to recover the
structure of a true (but unknown) cognitive diagnostic model.
</p>


<h3>Value</h3>

<p>A list containing following elements (selection):
</p>
<table role = "presentation">
<tr><td><code>item_probs</code></td>
<td>
<p>Item response probabilities</p>
</td></tr>
<tr><td><code>class_probs</code></td>
<td>
<p>Latent class probabilities</p>
</td></tr>
<tr><td><code>p.aj.xi</code></td>
<td>
<p>Individual posterior</p>
</td></tr>
<tr><td><code>p.xi.aj</code></td>
<td>
<p>Individual likelihood</p>
</td></tr>
<tr><td><code>loglike</code></td>
<td>
<p>Log-likelihood value</p>
</td></tr>
<tr><td><code>Npars</code></td>
<td>
<p>Number of estimated parameters</p>
</td></tr>
<tr><td><code>Nskillpar</code></td>
<td>
<p>Number of skill class parameters</p>
</td></tr>
<tr><td><code>G</code></td>
<td>
<p>Number of groups</p>
</td></tr>
<tr><td><code>n.ik</code></td>
<td>
<p>Expected counts</p>
</td></tr>
<tr><td><code>Nipar</code></td>
<td>
<p>Number of item parameters</p>
</td></tr>
<tr><td><code>n_reg</code></td>
<td>
<p>Number of regularized parameters</p>
</td></tr>
<tr><td><code>n_reg_item</code></td>
<td>
<p>Number of regularized parameters per item</p>
</td></tr>
<tr><td><code>item</code></td>
<td>
<p>Data frame with item parameters</p>
</td></tr>
<tr><td><code>pjk</code></td>
<td>
<p>Item response probabilities (in an array)</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>Number of persons</p>
</td></tr>
<tr><td><code>I</code></td>
<td>
<p>Number of items</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chen, Y., Liu, J., Xu, G., &amp; Ying, Z. (2015). Statistical analysis of Q-matrix
based diagnostic classification models.
<em>Journal of the American Statistical Association, 110</em>, 850-866.
</p>
<p>Chen, Y., Li, X., Liu, J., &amp; Ying, Z. (2017).
Regularized latent class analysis with application in cognitive diagnosis.
<em>Psychometrika, 82</em>, 660-692.
</p>


<h3>See Also</h3>

<p>See also the <code><a href="#topic+gdina">gdina</a></code> and <code><a href="#topic+slca">slca</a></code> functions
for regularized estimation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Estimating a regularized LCA for DINA data
#############################################################################

#---- simulate data
I &lt;- 12  # number of items
# define Q-matrix
q.matrix &lt;- matrix(0,I,2)
q.matrix[ 1:(I/3), 1 ] &lt;- 1
q.matrix[ I/3 + 1:(I/3), 2 ] &lt;- 1
q.matrix[ 2*I/3 + 1:(I/3), c(1,2) ] &lt;- 1
N &lt;- 1000  # number of persons
guess &lt;- rep(seq(.1,.3,length=I/3), 3)
slip &lt;- .1
rho &lt;- 0.3  # skill correlation
set.seed(987)
dat &lt;- CDM::sim.din( N=N, q.matrix=q.matrix, guess=guess, slip=slip,
           mean=0*c( .2, -.2 ), Sigma=matrix( c( 1, rho,rho,1), 2, 2 ) )
dat &lt;- dat$dat

#--- Model 1: Four latent classes without regularization
mod1 &lt;- CDM::reglca(dat=dat, nclasses=4, regular_lam=0, random_starts=3,
               random_iter=10, conv=1E-4)
summary(mod1)

#--- Model 2: Four latent classes with regularization and lambda=.08
mod2 &lt;- CDM::reglca(dat=dat, nclasses=4, regular_lam=0.08, regular_type="scad",
               random_starts=3, random_iter=10, conv=1E-4)
summary(mod2)

#--- Model 3: Four latent classes with regularization and lambda=.05 with warm start

# "warm start" -&gt; use initial parameters from fitted model with higher lambda value
item_probs_init &lt;- mod2$item_probs
class_probs_init &lt;- mod2$class_probs
mod3 &lt;- CDM::reglca(dat=dat, nclasses=4, regular_lam=0.05, regular_type="scad",
               item_probs_init=item_probs_init, class_probs_init=class_probs_init,
               random_starts=3, random_iter=10, conv=1E-4)

## End(Not run)
</code></pre>

<hr>
<h2 id='sequential.items'>
Constructing a Dataset with Sequential Pseudo Items for Ordered
Item Responses
</h2><span id='topic+sequential.items'></span>

<h3>Description</h3>

<p>This function constructs dichotomous pseudo items from polytomous ordered
items (Tutz, 1997). Using this method, developed test models for dichotomous
data can be applied for polytomous item responses after transforming them
into dichotomous data. See Details for the construction.
</p>
<p>Ma and de la Torre (2016) proposed a sequential GDINA model.
Interestingly, the proposed model can be fitted with the
<code>gdina</code> function in this <span class="pkg">CDM</span> package while item responses
has to be transformed with the <code>sequential.items</code> function for
obtaining dichotomous pseudoitems. The Q-matrix for the sequential model of Ma and
de la Torre (2016) can be used in the GDINA model for the
dichotomous pseudoitems. This approach is implemented for automatic
use in <code><a href="#topic+gdina">gdina</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sequential.items(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sequential.items_+3A_data">data</code></td>
<td>

<p>A data frame with item responses
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assume that item <code class="reqn">j</code> possesses <code class="reqn">K \geq 3</code> categories. We label these
categories as <code class="reqn">k=0,1,\ldots,K-1</code>. The original item responses <code class="reqn">X_{nj}</code>
for person <code class="reqn">n</code> at item <code class="reqn">j</code> is then transformed into <code class="reqn">K-1</code> pseudo
items <code class="reqn">Y_{j1}, \ldots, Y_{j,K-1}</code>.
</p>
<p>The first pseudo item response <code class="reqn">Y_{nj1}</code> is defined as 1 iff
<code class="reqn">X_{nj} \geq 1</code>. The second item responses <code class="reqn">Y_{nj2}</code> is 1 iff
<code class="reqn">X_{nj} \geq 2</code>, it is 0 iff <code class="reqn">X_{nj}=1</code> and it is missing
(<code>NA</code> in the dataset) iff <code class="reqn">X_{nj}=0</code>. The construction proceeds
in the same manner for other categories (see Tutz, 1997). The pseudo items can be
recognized as 'hurdles' a participant has to master to get a score of <code class="reqn">k</code>
for the original item.
</p>
<p>The pseudo items are treated as conditionally independent which implies that
IRT models or CDMs which assume local independence can be employed for estimation.
</p>
<p>For deriving  item response probabilities of the original items from response
probabilities of the pseudo items see Tutz (1997, p. 141ff.).
</p>


<h3>Value</h3>

<p>A list with following entries
</p>
<table role = "presentation">
<tr><td><code>dat.expand</code></td>
<td>
<p>A data frame with dichotomous pseudo items</p>
</td></tr>
<tr><td><code>iteminfo</code></td>
<td>
<p>A data frame containing some item information</p>
</td></tr>
<tr><td><code>maxK</code></td>
<td>
<p>Vector with maximum number of categories per item</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ma, W., &amp; de la Torre, J. (2016).
A sequential cognitive diagnosis model for polytomous responses.
<em>British Journal of Mathematical and Statistical Psychology, 69</em>(3),
253-275.
</p>
<p>Tutz, G. (1997). Sequential models for ordered responses.
In W. van der Linden &amp; R. K. Hambleton.
<em>Handbook of modern item response theory</em> (pp. 139-152).
New York: Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: Constructing sequential pseudo items for data.mg
#############################################################################

data(data.mg, package="CDM")
dat &lt;- data.mg
items &lt;- colnames(dat)[ which( substring( colnames(dat),1,1)=="I" ) ]
##    [1] "I1"  "I2"  "I3"  "I4"  "I5"  "I6"  "I7"  "I8"  "I9"  "I10" "I11"
data &lt;- dat[,items]

# construct sequential dichotomous pseudo items
res &lt;- CDM::sequential.items(data)

# item information table
res$iteminfo
  ##      item itemindex category pseudoitem
  ##   1    I1         1        1         I1
  ##   2    I2         2        1         I2
  ##   3    I3         3        1         I3
  ##   4    I4         4        1    I4_Cat1
  ##   5    I4         4        2    I4_Cat2
  ##   6    I5         5        1    I5_Cat1
  ##   7    I5         5        2    I5_Cat2
  ##     [...]

# extract dataset with pseudo items
dat.expand &lt;- res$dat.expand
colnames(dat.expand)
  ##    [1] "I1"       "I2"       "I3"       "I4_Cat1"  "I4_Cat2"  "I5_Cat1"
  ##    [7] "I5_Cat2"  "I6_Cat1"  "I6_Cat2"  "I7_Cat1"  "I7_Cat2"  "I7_Cat3"
  ##   [13] "I8"       "I9"       "I10"      "I11_Cat1" "I11_Cat2" "I11_Cat3"

# compare original items and pseudoitems

#**** Item I1
stats::xtabs( ~ paste(data$I1) + paste(dat.expand$I1) )
  ##                 paste(dat.expand$I1)
  ##   paste(data$I1)     0     1    NA
  ##               0   4339     0     0
  ##               1      0 33326     0
  ##               NA     0     0   578

#**** Item I7

stats::xtabs( ~ paste(data$I7) + paste(dat.expand$I7_Cat1) )
  ##                 paste(dat.expand$I7_Cat1)
  ##   paste(data$I7)     0     1    NA
  ##               0   3825     0     0
  ##               1      0 14241     0
  ##               2      0 14341     0
  ##               3      0  5169     0
  ##               NA     0     0   667

stats::xtabs( ~ paste(data$I7) + paste(dat.expand$I7_Cat2) )
  ##                 paste(dat.expand$I7_Cat2)
  ##   paste(data$I7)     0     1    NA
  ##               0      0     0  3825
  ##               1  14241     0     0
  ##               2      0 14341     0
  ##               3      0  5169     0
  ##               NA     0     0   667

stats::xtabs( ~ paste(data$I7) + paste(dat.expand$I7_Cat3) )
  ##                 paste(dat.expand$I7_Cat3)
  ##   paste(data$I7)     0     1    NA
  ##               0      0     0  3825
  ##               1      0     0 14241
  ##               2  14341     0     0
  ##               3      0  5169     0
  ##               NA     0     0   667

## Not run: 
#*** Model 1: Rasch model for sequentially created pseudo items
mod &lt;- CDM::gdm( dat.expand, irtmodel="1PL", theta.k=seq(-5,5,len=21),
             skillspace="normal", decrease.increments=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='sim_model'>
Simulate an Item Response Model
</h2><span id='topic+sim_model'></span>

<h3>Description</h3>

<p>Simulates an item response model given a fitted object or input of item response
probabilities and skill class probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_model(object=NULL, irfprob=NULL, theta_index=NULL, prob.theta=NULL,
      data=NULL, N_sim=NULL )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_model_+3A_object">object</code></td>
<td>

<p>Fitted object for which the methods <code><a href="#topic+IRT.posterior">IRT.posterior</a></code>,
and <code><a href="#topic+IRT.data">IRT.data</a></code> are defined.
</p>
</td></tr>
<tr><td><code id="sim_model_+3A_irfprob">irfprob</code></td>
<td>
<p>Array of item response function values (items <code class="reqn">\times</code> categories
<code class="reqn">\times</code> skill classes)</p>
</td></tr>
<tr><td><code id="sim_model_+3A_theta_index">theta_index</code></td>
<td>
<p>Skill class index for sampling</p>
</td></tr>
<tr><td><code id="sim_model_+3A_prob.theta">prob.theta</code></td>
<td>
<p>Skill class probabilities</p>
</td></tr>
<tr><td><code id="sim_model_+3A_data">data</code></td>
<td>
<p>Original dataset, only relevant for simulating item response pattern
with missing values</p>
</td></tr>
<tr><td><code id="sim_model_+3A_n_sim">N_sim</code></td>
<td>
<p>Number of subjects to be simulated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing elements
</p>
<table role = "presentation">
<tr><td><code>dat</code></td>
<td>
<p>Simulated item responses</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>Simulated skill classes</p>
</td></tr>
<tr><td><code>theta_index</code></td>
<td>
<p>Corresponding indices to <code>theta</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: GDINA model simulation
#############################################################################

data(sim.dina, package="CDM")
data(sim.qmatrix, package="CDM")
dat &lt;- sim.dina
Q &lt;- sim.qmatrix

# fit DINA model
mod &lt;- CDM::gdina( dat, q.matrix=Q, rule="DINA")
summary(mod)

#** simulate new item responses (N equals observed sample size)
dat1 &lt;- CDM::sim_model(mod)

#*** simulate item responses for N=2000 subjects
dat2 &lt;- CDM::sim_model(mod, N_sim=2000)
str(dat2)

#*** simulate item responses based on input item response probabilities
#*** and theta_index
irfprob &lt;- CDM::IRT.irfprob(mod)
prob.theta &lt;- attr(irfprob, "prob.theta")
TP &lt;- length(prob.theta)
theta_index &lt;- sample(1:TP, size=1000, prob=prob.theta, replace=TRUE )
#-- simulate
dat3 &lt;- CDM::sim_model(irfprob=irfprob, theta_index=theta_index)
str(dat3)

## End(Not run)
</code></pre>

<hr>
<h2 id='sim.din'>
Data Simulation Tool for DINA, DINO and mixed DINA and DINO Data
</h2><span id='topic+sim.din'></span>

<h3>Description</h3>

<p><code>sim.din</code> can be used to simulate dichotomous response data according to a CDM
model.  The model type DINA or DINO can be specified item wise.  The number of items,
the sample size, and two parameters for each item,
the slipping and guessing parameters, can be set explicitly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  sim.din(N=0, q.matrix, guess=rep(0.2, nrow(q.matrix)),
    slip=guess, mean=rep(0, ncol(q.matrix)), Sigma=diag(ncol(q.matrix)),
    rule="DINA", alpha=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.din_+3A_n">N</code></td>
<td>
<p>A numeric value specifying the number <code class="reqn">N</code> of requested
response patterns. If <code>alpha</code> is specified, then <code>N</code> is set
by default to 0.</p>
</td></tr>
<tr><td><code id="sim.din_+3A_q.matrix">q.matrix</code></td>
<td>
<p>A required binary <code class="reqn">J \times K</code> matrix describing which
of the <code class="reqn">K</code> attributes are required, coded by 1, and which attributes
are not required, coded by 0, to master the items.   </p>
</td></tr>
<tr><td><code id="sim.din_+3A_guess">guess</code></td>
<td>
<p>An optional vector of guessing parameters.  Default is
0.2 for each item.  </p>
</td></tr>
<tr><td><code id="sim.din_+3A_slip">slip</code></td>
<td>
<p>An optional vector of slipping parameters.  Default is
0.2 for each item.  </p>
</td></tr>
<tr><td><code id="sim.din_+3A_mean">mean</code></td>
<td>
<p>A numeric vector of length <code>ncol(q.matrix)</code> indicating
the mean vector of the continuous version of the dichotomous skill vector.
Default is <code>rep(0, length=ncol(q.matrix))</code>.
That is, having a probability of <code>0.5</code> for possessing each of the
attributes.  </p>
</td></tr>
<tr><td><code id="sim.din_+3A_sigma">Sigma</code></td>
<td>
<p>A matrix of dimension <code>ncol(q.matrix)</code> times <code>ncol(q.matrix)</code>
specifying the covariance matrix of the continuous version of the dichotomous skill
vector (i.e., the tetrachoric correlation of the dichotomous skill vector).
Default is <code>diag( 1, ncol(q.matrix))</code>.  That is, by default the possession of
the attributes is assumed to be uncorrelated.  </p>
</td></tr>
<tr><td><code id="sim.din_+3A_rule">rule</code></td>
<td>
<p>An optional character string or vector of character strings
specifying the model rule that is used.  The character strings must be
of <code>"DINA"</code> or <code>"DINO"</code>.  If a vector of character strings is
specified, implying an itemwise condensation rule, the vector must
be of length <code class="reqn">J</code>, which is the number of used items.  The default is
the condensation rule <code>"DINA"</code> for all items.  </p>
</td></tr>
<tr><td><code id="sim.din_+3A_alpha">alpha</code></td>
<td>
<p>A matrix of attribute patterns which can be given as an input
instead of underlying latent variables. If <code>alpha</code> is not <code>NULL</code>,
then <code>mean</code> and <code>Sigma</code> are ignored.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with following entries
</p>
<table role = "presentation">
<tr><td><code>dat</code></td>
<td>
<p>A matrix of simulated dichotomous response data
according to the specified CDM model.
</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>Simulated attributes</p>
</td></tr>
</table>


<h3>References</h3>

<p>Rupp, A. A., Templin, J. L., &amp; Henson, R. A. (2010). <em>Diagnostic
Measurement: Theory, Methods, and Applications</em>. New York: The Guilford
Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Data-sim">Data-sim</a></code> for artificial date set simulated with the help of this
method; <code><a href="#topic+plot.din">plot.din</a></code>, the S3 method for plotting objects of
the class <code>din</code>; <code><a href="#topic+summary.din">summary.din</a></code>, the S3
method for summarizing objects of the class <code>din</code>, which
creates objects of the class <code>summary.din</code>;
<code><a href="#topic+print.summary.din">print.summary.din</a></code>, the S3 method for printing
objects of the class <code>summary.din</code>; <code><a href="#topic+din">din</a></code>,
the main function for DINA and DINO parameter estimation,
which creates objects of the class <code>din</code>.  See also
<code><a href="#topic+CDM-package">CDM-package</a></code> for general information about this package.
</p>
<p>See <code><a href="#topic+sim_model">sim_model</a></code> for a general simulation function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
## EXAMPLE 1: simulate DINA/DINO data according to a tetrachoric correlation
#############################################################################

# define Q-matrix for 4 items and 2 attributes
q.matrix &lt;- matrix(c(1,0,0,1,1,1,1,1), ncol=2, nrow=4)

# Slipping parameters
slip &lt;- c(0.2,0.3,0.4,0.3)

# Guessing parameters
guess &lt;- c(0,0.1,0.05,0.2)

set.seed(1567) # fix random numbers
dat1 &lt;- CDM::sim.din(N=200, q.matrix, slip=slip, guess=guess,
  # Possession of the attributes with high probability
  mean=c(0.5,0.2),
  # Possession of the attributes is weakly correlated
  Sigma=matrix(c(1,0.2,0.2,1), ncol=2), rule="DINA")$dat
head(dat1)

set.seed(15367) # fix random numbers
res &lt;- CDM::sim.din(N=200, q.matrix, slip=slip, guess=guess, mean=c(0.5,0.2),
         Sigma=matrix(c(1,0.2,0.2,1), ncol=2), rule="DINO")

# extract simulated data
dat2 &lt;- res$dat
# extract attribute patterns
head( res$alpha )
  ##        [,1] [,2]
  ##   [1,]    1    1
  ##   [2,]    1    1
  ##   [3,]    1    1
  ##   [4,]    1    1
  ##   [5,]    1    1
  ##   [6,]    1    0

#  simulate data based on given attributes
#          -&gt; 5 persons with 2 attributes -&gt; see the Q-matrix above
alpha &lt;- matrix( c(1,0,1,0,1,1,0,1,1,1),
    nrow=5,ncol=2, byrow=TRUE )
CDM::sim.din(  q.matrix=q.matrix, alpha=alpha )

## Not run: 
#############################################################################
# EXAMPLE 2: Simulation based on attribute vectors
#############################################################################
set.seed(76)
# define Q-matrix
Qmatrix &lt;- matrix(c(1,0,1,0,1,0,0,1,0,1,0,1,1,1,1,1), 8, 2, byrow=TRUE)
colnames(Qmatrix) &lt;- c("Attr1","Attr2")
# define skill patterns
alpha.patt &lt;- matrix(c(0,0,1,0,0,1,1,1), 4,2,byrow=TRUE )
AP &lt;- nrow(alpha.patt)
# define pattern probabilities
alpha.prob &lt;- c( .20, .40, .10, .30 )
# simulate alpha latent responses
N &lt;- 1000     # number of persons
ind &lt;- sample( x=1:AP, size=N, replace=TRUE, prob=alpha.prob)
alpha &lt;- alpha.patt[ ind, ]    # (true) latent responses
# define guessing and slipping parameters
guess &lt;- c(.26,.3,.07,.23,.24,.34,.05,.1)
slip &lt;- c(.05,.16,.19,.03,.03,.19,.15,.05)
# simulation of the DINA model
dat &lt;- CDM::sim.din(N=0, q.matrix=Qmatrix, guess=guess,
              slip=slip, alpha=alpha)$dat
# estimate model
res &lt;- CDM::din( dat, q.matrix=Qmatrix )
# extract maximum likelihood estimates for individual classifications
est &lt;- paste( res$pattern$mle.est )
# calculate classification accuracy
mean( est==apply( alpha, 1, FUN=function(ll){ paste0(ll[1],ll[2] ) } ) )
  ##   [1] 0.935

#############################################################################
# EXAMPLE 3: Simulation based on already estimated DINA model for data.ecpe
#############################################################################

dat &lt;- CDM::data.ecpe$data
q.matrix &lt;- CDM::data.ecpe$q.matrix

#***
# (1) estimate DINA model
mod &lt;- CDM::din( data=dat[,-1], q.matrix=q.matrix, rule="DINA")

#***
# (2) simulate data according to DINA model
set.seed(977)
# number of subjects to be simulated
n &lt;- 3000
# simulate attribute patterns
probs &lt;- mod$attribute.patt$class.prob   # probabilities
patt &lt;- mod$attribute.patt.splitted      # response patterns
alpha &lt;- patt[ sample( 1:(length(probs) ), n, prob=probs, replace=TRUE), ]
# simulate data using estimated item parameters
res &lt;- CDM::sim.din(N=n, q.matrix=q.matrix, guess=mod$guess$est, slip=mod$slip$est,
              rule="DINA", alpha=alpha)
# extract data
dat &lt;- res$dat

## End(Not run)
</code></pre>

<hr>
<h2 id='sim.gdina'>
Simulation of the GDINA model
</h2><span id='topic+sim.gdina'></span><span id='topic+sim.gdina.prepare'></span>

<h3>Description</h3>

<p>The function <code>sim.gdina.prepare</code> creates necessary design matrices
<code>Mj</code>, <code>Aj</code> and <code>necc.attr</code>. In most cases, only the list
of item parameters <code>delta</code> must be modified by the user when
applying the simulation function <code>sim.gdina</code>. The distribution of latent
classes <code class="reqn">\alpha</code> is represented by an underlying multivariate normal distribution
<code class="reqn">\alpha^\ast</code> for which a mean vector <code>thresh.alpha</code> and a
covariance matrix <code>cov.alpha</code> must be specified.
Alternatively, a matrix of skill classes <code>alpha</code>
can be given as an input.
</p>
<p>Note that this version of <code>sim.gdina</code> only works for dichotomous attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.gdina(n, q.matrix, delta, link="identity",  thresh.alpha=NULL,
    cov.alpha=NULL, alpha=NULL, Mj, Aj, necc.attr)

sim.gdina.prepare( q.matrix )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.gdina_+3A_n">n</code></td>
<td>

<p>Number of persons
</p>
</td></tr>
<tr><td><code id="sim.gdina_+3A_q.matrix">q.matrix</code></td>
<td>

<p>Q-matrix (see <code><a href="#topic+sim.din">sim.din</a></code>)
</p>
</td></tr>
<tr><td><code id="sim.gdina_+3A_delta">delta</code></td>
<td>

<p>List with <code class="reqn">J</code> entries where <code class="reqn">J</code> is the number of items.
Every list element corresponds to the parameter of an item.
</p>
</td></tr>
<tr><td><code id="sim.gdina_+3A_link">link</code></td>
<td>

<p>Link function. Choices are <code>identity</code> (default), <code>logit</code> and <code>log</code>.
</p>
</td></tr>
<tr><td><code id="sim.gdina_+3A_thresh.alpha">thresh.alpha</code></td>
<td>

<p>Vector of thresholds (means) of <code class="reqn">\alpha^\ast</code>
</p>
</td></tr>
<tr><td><code id="sim.gdina_+3A_cov.alpha">cov.alpha</code></td>
<td>

<p>Covariance matrix of <code class="reqn">\alpha^\ast</code>
</p>
</td></tr>
<tr><td><code id="sim.gdina_+3A_alpha">alpha</code></td>
<td>

<p>Matrix of skill classes if they should not be simulated
</p>
</td></tr>
<tr><td><code id="sim.gdina_+3A_mj">Mj</code></td>
<td>

<p>Design matrix, see <code><a href="#topic+gdina">gdina</a></code>
</p>
</td></tr>
<tr><td><code id="sim.gdina_+3A_aj">Aj</code></td>
<td>

<p>Design matrix, see <code><a href="#topic+gdina">gdina</a></code>
</p>
</td></tr>
<tr><td><code id="sim.gdina_+3A_necc.attr">necc.attr</code></td>
<td>

<p>List with <code class="reqn">J</code> entries containing necessary attributes
for each item
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output of <code>sim.gdina</code> is a list with following entries:
</p>
<table role = "presentation">
<tr><td><code>data</code></td>
<td>
<p>Simulated item responses</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>Data frame with simulated attributes</p>
</td></tr>
<tr><td><code>q.matrix</code></td>
<td>
<p>Used Q-matrix</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>Used delta item parameters</p>
</td></tr>
<tr><td><code>Aj</code></td>
<td>
<p>Design matrices <code class="reqn">A_j</code></p>
</td></tr>
<tr><td><code>Mj</code></td>
<td>
<p>Design matrices <code class="reqn">M_j</code></p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>Used link function</p>
</td></tr>
</table>
<p>The function <code>sim.gdina.prepare</code> possesses the following values as output
in a list: <code>delta</code>, <code>necc.attr</code>, <code>Aj</code> and <code>Mj</code>.
</p>


<h3>References</h3>

<p>de la Torre, J. (2011). The generalized DINA model framework.
<em>Psychometrika, 76</em>, 179&ndash;199.
</p>


<h3>See Also</h3>

<p>For estimating the GDINA model see <code><a href="#topic+gdina">gdina</a></code>.
</p>
<p>See the <code><a href="GDINA.html#topic+simGDINA">GDINA::simGDINA</a></code> function in the
<span class="pkg">GDINA</span> package for similar functionality.
</p>
<p>See <code><a href="#topic+sim_model">sim_model</a></code> for a general simulation function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: Simulating the GDINA model
#############################################################################

n &lt;- 50             # number of persons
# define Q-matrix
q.matrix &lt;- matrix(  c(1,1,0, 0,1,1, 1,0,1, 1,0,0,
    0,0,1, 0,1,0,  1,1,1,  0,1,1, 0,1,1), ncol=3, byrow=TRUE)
# thresholds for attributes alpha^\ast
thresh.alpha &lt;- c( .65, 0, -.30 )
# covariance matrix for alpha^\ast
cov.alpha &lt;- matrix(1,3,3)
cov.alpha[1,2] &lt;- cov.alpha[2,1] &lt;- .4
cov.alpha[1,3] &lt;- cov.alpha[3,1] &lt;- .6
cov.alpha[3,2] &lt;- cov.alpha[2,3] &lt;- .8

# prepare design matrix by applying sim.gdina.prepare function
rp &lt;- CDM::sim.gdina.prepare( q.matrix )
delta &lt;- rp$delta
necc.attr &lt;- rp$necc.attr
Aj &lt;- rp$Aj
Mj &lt;- rp$Mj
# define delta parameters
# intercept - main effects - second order interactions - ...
str(delta)  #=&gt; modify the delta parameter list which contains only zeroes as default
##   List of 9
##    $ : num [1:4] 0 0 0 0
##    $ : num [1:4] 0 0 0 0
##    $ : num [1:4] 0 0 0 0
##    $ : num [1:2] 0 0
##    $ : num [1:2] 0 0
##    $ : num [1:2] 0 0
##    $ : num [1:8] 0 0 0 0 0 0 0 0
##    $ : num [1:4] 0 0 0 0
##    $ : num [1:4] 0 0 0 0
delta[[1]] &lt;- c( .2, .1, .15, .4 )
delta[[2]] &lt;- c( .2, .3, .3, -.2 )
delta[[3]] &lt;- c( .2, .2, .2, 0 )
delta[[4]] &lt;- c( .15, .6 )
delta[[5]] &lt;- c( .1, .7 )
delta[[6]] &lt;- c( .25, .65 )
delta[[7]] &lt;- c( .25, .1, .1, .1, 0, 0, 0, .25 )
delta[[8]] &lt;- c( .2, 0, .3, -.1 )
delta[[9]] &lt;- c( .2, .2, 0, .3 )

#******************************************
# Now, the "real simulation" starts
sim.res &lt;- CDM::sim.gdina( n=n, q.matrix=q.matrix, delta=delta, link="identity",
                thresh.alpha=thresh.alpha, cov.alpha=cov.alpha,
                Mj=Mj, Aj=Aj, necc.attr=necc.attr)
# sim.res$data      # simulated data
# sim.res$alpha     # simulated alpha

## Not run: 
#############################################################################
# EXAMPLE 2: Simulation based on already estimated GDINA model for data.ecpe
#############################################################################

data(data.ecpe)
dat &lt;- data.ecpe$data
q.matrix &lt;- data.ecpe$q.matrix

#***
# (1) estimate GDINA model
mod &lt;- CDM::gdina( data=dat[,-1], q.matrix=q.matrix )

#***
# (2) simulate data according to GDINA model
set.seed(977)

# prepare design matrix by applying sim.gdina.prepare function
rp &lt;- CDM::sim.gdina.prepare( q.matrix )
necc.attr &lt;- rp$necc.attr

# number of subjects to be simulated
n &lt;- 3000
# simulate attribute patterns
probs &lt;- mod$attribute.patt$class.prob   # probabilities
patt &lt;- mod$attribute.patt.splitted      # response patterns
alpha &lt;- patt[ sample( 1:(length(probs) ), n, prob=probs, replace=TRUE), ]

# simulate data using estimated item parameters
sim.res &lt;- CDM::sim.gdina( n=n, q.matrix=q.matrix, delta=mod$delta, link="identity",
                alpha=alpha, Mj=mod$Mj, Aj=mod$Aj, necc.attr=rp$necc.attr)
# extract data
dat &lt;- sim.res$data

#############################################################################
# EXAMPLE 3: Simulation based on already estimated RRUM model for data.ecpe
#############################################################################

dat &lt;- CDM::data.ecpe$data
q.matrix &lt;- CDM::data.ecpe$q.matrix

#***
# (1) estimate reduced RUM model
mod &lt;- CDM::gdina( data=dat[,-1], q.matrix=q.matrix, rule="RRUM" )
summary(mod)

#***
# (2) simulate data according to RRUM model
set.seed(977)

# prepare design matrix by applying sim.gdina.prepare function
rp &lt;- CDM::sim.gdina.prepare( q.matrix )
necc.attr &lt;- rp$necc.attr

# number of subjects to be simulated
n &lt;- 5000
# simulate attribute patterns
probs &lt;- mod$attribute.patt$class.prob   # probabilities
patt &lt;- mod$attribute.patt.splitted      # response patterns
alpha &lt;- patt[ sample( 1:(length(probs) ), n, prob=probs, replace=TRUE), ]

# simulate data using estimated item parameters
sim.res &lt;- CDM::sim.gdina( n=n, q.matrix=q.matrix, delta=mod$delta, link=mod$link,
                alpha=alpha, Mj=mod$Mj, Aj=mod$Aj, necc.attr=rp$necc.attr)
# extract data
dat &lt;- sim.res$data

## End(Not run)
</code></pre>

<hr>
<h2 id='skill.cor'>
Tetrachoric or Polychoric Correlations between Attributes
</h2><span id='topic+skill.cor'></span><span id='topic+skill.polychor'></span>

<h3>Description</h3>

<p>This function takes the results of <code>din</code> or <code>gdina</code> and
computes tetrachoric or polychoric correlations between attributes (see e.g.
Templin &amp; Henson, 2006).
</p>


<h3>Usage</h3>

<pre><code class='language-R'># tetrachoric correlations
skill.cor(object)

# polychoric correlations
skill.polychor(object, colindex=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="skill.cor_+3A_object">object</code></td>
<td>

<p>Object of class <code>din</code> or <code>gdina</code>
</p>
</td></tr>
<tr><td><code id="skill.cor_+3A_colindex">colindex</code></td>
<td>
<p>Index which can used for group-wise calculation
of polychoric correlations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with following entries:
</p>
<table role = "presentation">
<tr><td><code>conttable.skills</code></td>
<td>
<p>Bivariate contingency table of all skill pairs</p>
</td></tr>
<tr><td><code>cor.skills</code></td>
<td>
<p>Tetrachoric correlation matrix for skill
distribution</p>
</td></tr>
</table>


<h3>References</h3>

<p>Templin, J., &amp; Henson, R. (2006). Measurement of psychological disorders
using cognitive diagnosis models. <em>Psychological Methods, 11</em>, 287-305.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sim.dino, package="CDM")
data(sim.qmatrix, package="CDM")

# estimate model
d4 &lt;- CDM::din( sim.dino, q.matrix=sim.qmatrix)
# compute tetrachoric correlations
CDM::skill.cor(d4)
  ## estimated tetrachoric correlations
  ##   $cor.skills
  ##             V1        V2        V3
  ##   V1 1.0000000 0.2567718 0.2552958
  ##   V2 0.2567718 1.0000000 0.9842188
  ##   V3 0.2552958 0.9842188 1.0000000
</code></pre>

<hr>
<h2 id='skillspace.approximation'>
Skill Space Approximation
</h2><span id='topic+skillspace.approximation'></span>

<h3>Description</h3>

<p>This function approximates the skill space with <code class="reqn">K</code> skills to
approximate a (typically high-dimensional) skill space of <code class="reqn">2^K</code> classes by
<code class="reqn">L</code> classes <code class="reqn">(L &lt; 2^K)</code>. The large number of latent classes are
represented by underlying continuous latent variables for the
dichotomous skills (see George &amp; Robitzsch, 2014, for more details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skillspace.approximation(L, K, nmax=5000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="skillspace.approximation_+3A_l">L</code></td>
<td>

<p>Number of skill classes used for approximation
</p>
</td></tr>
<tr><td><code id="skillspace.approximation_+3A_k">K</code></td>
<td>

<p>Number of skills
</p>
</td></tr>
<tr><td><code id="skillspace.approximation_+3A_nmax">nmax</code></td>
<td>

<p>Number of quasi-randomly generated skill classes using the <code>QUnif</code>
function in <span class="pkg">sfsmisc</span>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing skill classes in rows
</p>


<h3>Note</h3>

<p>This function uses the <code>sfsmisc::QUnif</code> function from the <span class="pkg">sfsmisc</span>
package.
</p>


<h3>References</h3>

<p>George, A. C., &amp; Robitzsch, A. (2014). Multiple group cognitive diagnosis models,
with an emphasis on differential item functioning.
<em>Psychological Test and Assessment Modeling, 56</em>(4), 405-432.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+gdina">gdina</a></code> (Example 9).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: Approximate a skill space of K=8 eight skills by 20 classes
#############################################################################

#=&gt; 2^8=256 latent classes if all latent classes would be used
CDM::skillspace.approximation( L=20, K=8 )
  ##             [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8]
  ##   P00000000    0    0    0    0    0    0    0    0
  ##   P00000001    0    0    0    0    0    0    0    1
  ##   P00001011    0    0    0    0    1    0    1    1
  ##   P00010011    0    0    0    1    0    0    1    1
  ##   P00101001    0    0    1    0    1    0    0    1
  ##   [...]
  ##   P11011110    1    1    0    1    1    1    1    0
  ##   P11100110    1    1    1    0    0    1    1    0
  ##   P11111111    1    1    1    1    1    1    1    1
</code></pre>

<hr>
<h2 id='skillspace.hierarchy'>
Creation of a Hierarchical Skill Space
</h2><span id='topic+skillspace.hierarchy'></span><span id='topic+skillspace.full'></span>

<h3>Description</h3>

<p>The function <code>skillspace.hierarchy</code> defines a reduced skill space
for hierarchies in skills (see e.g. Leighton, Gierl, &amp; Hunka, 2004).
The function <code>skillspace.full</code> defines a full skill space
for dichotomous skills.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skillspace.hierarchy(B, skill.names)

skillspace.full(skill.names)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="skillspace.hierarchy_+3A_b">B</code></td>
<td>

<p>A matrix or a string containing restrictions of the hierarchy.
If <code>B</code> is a <code class="reqn">K \times K</code> matrix containing where <code class="reqn">K</code>
denotes the number of skills, then <code>B[ii,jj]=1</code> means that if an examinee
mastered skill <code>jj</code>, then he or she should also master skill <code>ii</code>.
</p>
<p>Alternatively, a string can be also conveniently used for defining a
hierarchy (see Examples).
</p>
</td></tr>
<tr><td><code id="skillspace.hierarchy_+3A_skill.names">skill.names</code></td>
<td>

<p>Vector of names in skills
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The reduced skill space output can be used as an argument in <code><a href="#topic+din">din</a></code>
or <code><a href="#topic+gdina">gdina</a></code> to directly test for a hierarchy in attributes.
</p>


<h3>Value</h3>

<p>A list with following entries
</p>
<table role = "presentation">
<tr><td><code>R</code></td>
<td>
<p>Reachability matrix</p>
</td></tr>
<tr><td><code>skillspace.reduced</code></td>
<td>
<p>Reduced skill space fulfilling the specified
hierarchy</p>
</td></tr>
<tr><td><code>skillspace.complete</code></td>
<td>
<p>Complete skill space</p>
</td></tr>
<tr><td><code>zeroprob.skillclasses</code></td>
<td>
<p>Indices of skill patterns in
<code>skillspace.complete</code> which were removed for defining
<code>skillspace.reduced</code>
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Leighton, J. P., Gierl, M. J., &amp; Hunka, S. M. (2004).
The attribute hierarchy method for cognitive assessment:
A variation on Tatsuoka's rule space approach.
<em>Journal of Educational Measurement, 41</em>, 205-237.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+din">din</a></code> (Example 6) for an application of
<code>skillspace.hierarchy</code> for model comparisons.
</p>
<p>See the <code><a href="GDINA.html#topic+att.structure">GDINA::att.structure</a></code> function in the
<span class="pkg">GDINA</span> package for similar functionality.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: Toy example with 3 skills
#############################################################################

K &lt;- 3 # number of skills
skill.names &lt;- paste0("A", 1:K )  # names of skills

# create a zero matrix for hierarchy definition
B0 &lt;- 0*diag(K)
rownames(B0) &lt;- colnames(B0) &lt;- skill.names

#*** Model 1: A1 &gt; A2 &gt; A3
B &lt;- B0
B[1,2] &lt;- 1     # A1 &gt; A2
B[2,3] &lt;- 1     # A2 &gt; A3

sp1 &lt;- CDM::skillspace.hierarchy( B=B, skill.names=skill.names )
sp1$skillspace.reduced
  ##     A1 A2 A3
  ##   1  0  0  0
  ##   2  1  0  0
  ##   4  1  1  0
  ##   8  1  1  1

#*** Model 2:  A1 &gt; A2 and A1 &gt; A3
B &lt;- B0
B[1,2] &lt;- 1     # A1 &gt; A2
B[1,3] &lt;- 1     # A1 &gt; A3

sp2 &lt;- CDM::skillspace.hierarchy( B=B, skill.names=skill.names )
sp2$skillspace.reduced
  ##     A1 A2 A3
  ##   1  0  0  0
  ##   2  1  0  0
  ##   4  1  1  0
  ##   6  1  0  1
  ##   8  1  1  1

#*** Model 3: A1 &gt; A3, A2 is not included in a hierarchical way
B &lt;- B0
B[1,3] &lt;- 1     # A1 &gt; A3

sp3 &lt;- CDM::skillspace.hierarchy( B=B, skill.names=skill.names )
sp3$skillspace.reduced
  ##     A1 A2 A3
  ##   1  0  0  0
  ##   2  1  0  0
  ##   3  0  1  0
  ##   4  1  1  0
  ##   6  1  0  1
  ##   8  1  1  1

#~~~ Hierarchy specification using strings

#*** Model 1: A1 &gt; A2 &gt; A3
B &lt;- "A1 &gt; A2
      A2 &gt; A3"
sp1 &lt;- CDM::skillspace.hierarchy( B=B, skill.names=skill.names )
sp1$skillspace.reduced

# Model 1 can be also written in one line for B
B &lt;- "A1 &gt; A2 &gt; A3"
sp1b &lt;- CDM::skillspace.hierarchy( B=B, skill.names=skill.names )
sp1b$skillspace.reduced

#*** Model 2:  A1 &gt; A2 and A1 &gt; A3
B &lt;- "A1 &gt; A2
      A1 &gt; A3"
sp2 &lt;- CDM::skillspace.hierarchy( B=B, skill.names=skill.names )
sp2$skillspace.reduced

#*** Model 3: A1 &gt; A3
B &lt;- "A1 &gt; A3"
sp3 &lt;- CDM::skillspace.hierarchy( B=B, skill.names=skill.names )
sp3$skillspace.reduced

## Not run: 
#############################################################################
# EXAMPLE 2: Examples from Leighton et al. (2004): Fig. 1 (p. 210)
#############################################################################

skill.names &lt;- paste0("A",1:6) # 6 skills

#*** Model 1: Linear hierarchy (A)
B &lt;- "A1 &gt; A2 &gt; A3 &gt; A4 &gt; A5 &gt; A6"
sp1 &lt;- CDM::skillspace.hierarchy( B=B, skill.names=skill.names )
sp1$skillspace.reduced

#*** Model 2: Convergent hierarchy (B)
B &lt;- "A1 &gt; A2 &gt; A3
      A2 &gt; A4
      A3 &gt; A5 &gt; A6
      A4 &gt; A5 &gt; A6"
sp2 &lt;- CDM::skillspace.hierarchy( B=B, skill.names=skill.names )
sp2$skillspace.reduced

#*** Model 3: Divergent hierarchy (C)
B &lt;- "A1 &gt; A2 &gt; A3
      A1 &gt; A4 &gt; A5
      A1 &gt; A4 &gt; A6"
sp3 &lt;- CDM::skillspace.hierarchy( B=B, skill.names=skill.names )
sp3$skillspace.reduced

#*** Model 4: Unstructured hierarchy (D)
B &lt;- "A1 &gt; A2 \n A1 &gt; A3 \n A1 &gt; A4 \n A1 &gt; A5 \n A1 &gt; A6"
# This specification of B is equivalent to writing separate lines:
# B &lt;- "A1 &gt; A2
#       A1 &gt; A3
#       A1 &gt; A4
#       A1 &gt; A5
#       A1 &gt; A6"
sp4 &lt;- CDM::skillspace.hierarchy( B=B, skill.names=skill.names )
sp4$skillspace.reduced

## End(Not run)
</code></pre>

<hr>
<h2 id='slca'>
Structured Latent Class Analysis (SLCA)
</h2><span id='topic+slca'></span><span id='topic+summary.slca'></span><span id='topic+print.slca'></span><span id='topic+plot.slca'></span>

<h3>Description</h3>

<p>This function implements a structured latent class model for
polytomous item responses (Formann, 1985, 1992). Lasso estimation for the
item parameters is included (Chen, Liu, Xu &amp; Ying, 2015;
Chen, Li, Liu &amp; Ying, 2017; Sun, Chen, Liu, Ying &amp; Xin,  2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slca(data, group=NULL, weights=rep(1, nrow(data)), Xdes,
  Xlambda.init=NULL, Xlambda.fixed=NULL, Xlambda.constr.V=NULL,
  Xlambda.constr.c=NULL,  delta.designmatrix=NULL,
  delta.init=NULL, delta.fixed=NULL, delta.linkfct="log",
  Xlambda_positive=NULL, regular_type="lasso", regular_lam=0, regular_w=NULL,
  regular_n=nrow(data), maxiter=1000, conv=1e-5, globconv=1e-5, msteps=10,
  convM=5e-04, decrease.increments=FALSE, oldfac=0, dampening_factor=1.01,
  seed=NULL, progress=TRUE, PEM=TRUE, PEM_itermax=maxiter, ...)

## S3 method for class 'slca'
summary(object, file=NULL, ...)

## S3 method for class 'slca'
print(x, ...)

## S3 method for class 'slca'
plot(x, group=1, ... )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slca_+3A_data">data</code></td>
<td>

<p>Matrix of polytomous item responses
</p>
</td></tr>
<tr><td><code id="slca_+3A_group">group</code></td>
<td>

<p>Optional vector of group identifiers. For <code>plot.slca</code> it is
a single integer group identified.
</p>
</td></tr>
<tr><td><code id="slca_+3A_weights">weights</code></td>
<td>

<p>Optional vector of sample weights
</p>
</td></tr>
<tr><td><code id="slca_+3A_xdes">Xdes</code></td>
<td>

<p>Design matrix for <code class="reqn">x_{ijh}</code> with <code class="reqn"> q_{ihjv}</code> entries.
Therefore, it must be an array with four dimensions referring to
items (<code class="reqn">i</code>), categories (<code class="reqn">h</code>), latent classes (<code class="reqn">j</code>) and
<code class="reqn">\lambda</code> parameters (<code class="reqn">v</code>).
</p>
</td></tr>
<tr><td><code id="slca_+3A_xlambda.init">Xlambda.init</code></td>
<td>

<p>Initial <code class="reqn">\lambda_x</code> parameters
</p>
</td></tr>
<tr><td><code id="slca_+3A_xlambda.fixed">Xlambda.fixed</code></td>
<td>

<p>Fixed <code class="reqn">\lambda_x</code> parameters. These must be provided by a matrix
with two columns: 1st column &ndash; Parameter index, 2nd column:
Fixed value.
</p>
</td></tr>
<tr><td><code id="slca_+3A_xlambda.constr.v">Xlambda.constr.V</code></td>
<td>
<p>A design matrix for linear restrictions of the
form <code class="reqn">V_x \lambda_x=c_x</code> for the <code class="reqn">\lambda_x</code> parameter.</p>
</td></tr>
<tr><td><code id="slca_+3A_xlambda.constr.c">Xlambda.constr.c</code></td>
<td>
<p>A vector for the linear restriction
<code class="reqn">V_x \lambda_x=c_x</code> of the <code class="reqn">\lambda_x</code> parameter.</p>
</td></tr>
<tr><td><code id="slca_+3A_delta.designmatrix">delta.designmatrix</code></td>
<td>

<p>Design matrix for delta parameters <code class="reqn">\delta</code>
parameterizing the latent class distribution by log-linear smoothing
(Xu &amp; von Davier, 2008)
</p>
</td></tr>
<tr><td><code id="slca_+3A_delta.init">delta.init</code></td>
<td>

<p>Initial <code class="reqn">\delta</code> parameters
</p>
</td></tr>
<tr><td><code id="slca_+3A_delta.fixed">delta.fixed</code></td>
<td>

<p>Fixed <code class="reqn">\delta</code> parameters. This must be a matrix with three columns:
1st column: Parameter index, 2nd column: Group index, 3rd column: Fixed value
</p>
</td></tr>
<tr><td><code id="slca_+3A_delta.linkfct">delta.linkfct</code></td>
<td>
<p>Link function for skill space reduction.
This can be the log-linear link (<code>log</code>) or the
logistic link function (<code>logit</code>).
</p>
</td></tr>
<tr><td><code id="slca_+3A_xlambda_positive">Xlambda_positive</code></td>
<td>
<p>Optional vector of logical indicating which
elements of <code class="reqn">\bold{\lambda}_x</code> should be constrained to be
positive.</p>
</td></tr>
<tr><td><code id="slca_+3A_regular_type">regular_type</code></td>
<td>
<p>Regularization method which can be <code>lasso</code>,
<code>scad</code> or <code>mcp</code>. See <code><a href="#topic+gdina">gdina</a></code> for more
information and references.</p>
</td></tr>
<tr><td><code id="slca_+3A_regular_lam">regular_lam</code></td>
<td>
<p>Numeric. Regularization parameter</p>
</td></tr>
<tr><td><code id="slca_+3A_regular_w">regular_w</code></td>
<td>
<p>Vector for weighting the regularization penalty</p>
</td></tr>
<tr><td><code id="slca_+3A_regular_n">regular_n</code></td>
<td>
<p>Vector of regularization factor. This will be
typically the sample size.</p>
</td></tr>
<tr><td><code id="slca_+3A_maxiter">maxiter</code></td>
<td>

<p>Maximum number of iterations
</p>
</td></tr>
<tr><td><code id="slca_+3A_conv">conv</code></td>
<td>

<p>Convergence criterion for item parameters and
distribution parameters
</p>
</td></tr>
<tr><td><code id="slca_+3A_globconv">globconv</code></td>
<td>

<p>Global deviance convergence criterion
</p>
</td></tr>
<tr><td><code id="slca_+3A_msteps">msteps</code></td>
<td>

<p>Maximum number of M steps in estimating <code class="reqn">b</code> and
<code class="reqn">a</code> item parameters. The default is to use 4 M steps.
</p>
</td></tr>
<tr><td><code id="slca_+3A_convm">convM</code></td>
<td>

<p>Convergence criterion in M step
</p>
</td></tr>
<tr><td><code id="slca_+3A_decrease.increments">decrease.increments</code></td>
<td>
<p>Should in the M step the increments
of <code class="reqn">a</code> and <code class="reqn">b</code> parameters decrease during iterations?
The default is <code>FALSE</code>. If there is an increase in deviance
during estimation, setting <code>decrease.increments</code> to <code>TRUE</code>
is recommended.
</p>
</td></tr>
<tr><td><code id="slca_+3A_oldfac">oldfac</code></td>
<td>
<p>Factor <code class="reqn">f</code> between 0 and 1 to control convergence behavior.
If <code class="reqn">x_t</code> denotes the estimated parameter in iteration <code class="reqn">t</code>,
then the regularized estimate <code class="reqn">x_t^{\ast}</code> is obtained by
<code class="reqn">x_t^{\ast}=f x_{t-1} + (1-f) x_t</code>. Therefore, values of
<code>oldfac</code> near to one only allow for small changes in estimated
parameters from in succeeding iterations.</p>
</td></tr>
<tr><td><code id="slca_+3A_dampening_factor">dampening_factor</code></td>
<td>
<p>Factor larger than one defining the specified decrease in
decrements in iterations.</p>
</td></tr>
<tr><td><code id="slca_+3A_seed">seed</code></td>
<td>
<p>Simulation seed for initial parameters. The default
of <code>NULL</code> corresponds to a random seed.</p>
</td></tr>
<tr><td><code id="slca_+3A_progress">progress</code></td>
<td>
<p>An optional logical indicating whether the function
should print the progress of iteration in the estimation process.  </p>
</td></tr>
<tr><td><code id="slca_+3A_pem">PEM</code></td>
<td>
<p>Logical indicating whether the P-EM acceleration should be
applied (Berlinet &amp; Roland, 2012).</p>
</td></tr>
<tr><td><code id="slca_+3A_pem_itermax">PEM_itermax</code></td>
<td>
<p>Number of iterations in which the P-EM method should be
applied.</p>
</td></tr>
<tr><td><code id="slca_+3A_object">object</code></td>
<td>
<p>A required object of class <code>slca</code></p>
</td></tr>
<tr><td><code id="slca_+3A_file">file</code></td>
<td>
<p>Optional file name for a file in which <code>summary</code>
should be sinked.</p>
</td></tr>
<tr><td><code id="slca_+3A_x">x</code></td>
<td>
<p>A required object of class <code>slca</code></p>
</td></tr>
<tr><td><code id="slca_+3A_...">...</code></td>
<td>
<p>Optional parameters to be passed to or from other
methods will be ignored.  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The structured latent class model allows for general constraints of items
<code class="reqn">i</code> in categories <code class="reqn">h</code> and classes <code class="reqn">j</code>. The item response model is
</p>
<p style="text-align: center;"><code class="reqn">P( X_{i}=h | j )=\frac{ \exp( x_{ihj} ) }{ \sum_l \exp( x_{ilj} ) }</code>
</p>

<p>with linear constraints on the class specific probabilities
</p>
<p style="text-align: center;"><code class="reqn">  x_{ihj}=\sum_v  q_{ihjv} \lambda_{xv} </code>
</p>

<p>Linear restrictions on the <code class="reqn">\lambda_x</code> parameter can be specified by
a matrix equation <code class="reqn">V_x \lambda_x=c_x</code> (see <code>Xlambda.constr.V</code> and
<code>Xlambda.constr.c</code>; Neuhaus, 1996).
</p>
<p>The latent class distribution can be smoothed by a log-linear
link function (Xu &amp; von Davier, 2008) or a logistic link function
(Formann, 1992). For class <code class="reqn">j</code>
in group <code class="reqn">g</code> employing a link function <code class="reqn">h</code>, it holds that
</p>
<p style="text-align: center;"><code class="reqn"> h [ P( j| g) ] \propto \sum_w   r_{jw}  \delta_{gw} </code>
</p>

<p>where group-specific distributions are allowed. The values
<code class="reqn">r_{jw}</code> are specified in the design matrix <code>delta.designmatrix</code>.
</p>
<p>This model contains classical uni- and multidimensional latent trait models,
latent class analysis, located latent class analysis, cognitive diagnostic
models, the general diagnostic model and mixture item response models as
special cases (see Formann &amp; Kohlmann, 1998; Formann, 2007).
</p>
<p>The function also allows for regularization of <code class="reqn">\lambda_{xv}</code> parameters
using the lasso approach (Sun et al., 2016).
More formally, the penalty function can be written as
</p>
<p style="text-align: center;"><code class="reqn">pen( \bold{\lambda}_x )=p_\lambda \sum_v n_v w_v | \lambda_{xv} | </code>
</p>

<p>where <code class="reqn">p_\lambda</code> can be specified with <code>regular_lam</code>,
<code class="reqn">w_v</code> can be specified with <code>regular_w</code>, and
<code class="reqn">n_v</code> can be specified with <code>regular_n</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>slca</code>. The list contains the
following entries:
</p>
<table role = "presentation">
<tr><td><code>item</code></td>
<td>
<p>Data frame with conditional item probabilities</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>Deviance</p>
</td></tr>
<tr><td><code>ic</code></td>
<td>
<p>Information criteria, number of estimated parameters</p>
</td></tr>
<tr><td><code>Xlambda</code></td>
<td>
<p>Estimated <code class="reqn">\lambda_x</code> parameters </p>
</td></tr>
<tr><td><code>se.Xlambda</code></td>
<td>
<p>Standard error of <code class="reqn">\lambda_x</code> parameters
</p>
</td></tr>
<tr><td><code>pi.k</code></td>
<td>
<p>Trait distribution</p>
</td></tr>
<tr><td><code>pjk</code></td>
<td>
<p>Item response probabilities evaluated for all classes</p>
</td></tr>
<tr><td><code>n.ik</code></td>
<td>
<p>An array of expected counts <code class="reqn">n_{cikg}</code> of ability class <code class="reqn">c</code>
at item <code class="reqn">i</code> at category <code class="reqn">k</code> in group <code class="reqn">g</code></p>
</td></tr>
<tr><td><code>G</code></td>
<td>
<p>Number of groups</p>
</td></tr>
<tr><td><code>I</code></td>
<td>
<p>Number of items</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>Number of persons</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>Parameter estimates for skillspace representation</p>
</td></tr>
<tr><td><code>covdelta</code></td>
<td>
<p>Covariance matrix of parameter estimates for
skillspace representation</p>
</td></tr>
<tr><td><code>MLE.class</code></td>
<td>
<p>Classified skills for each student (MLE)</p>
</td></tr>
<tr><td><code>MAP.class</code></td>
<td>
<p>Classified skills for each student (MAP)</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>Original data frame</p>
</td></tr>
<tr><td><code>group.stat</code></td>
<td>
<p>Group statistics (sample sizes, group labels)</p>
</td></tr>
<tr><td><code>p.xi.aj</code></td>
<td>
<p>Individual likelihood</p>
</td></tr>
<tr><td><code>posterior</code></td>
<td>
<p>Individual posterior distribution</p>
</td></tr>
<tr><td><code>K.item</code></td>
<td>
<p>Maximal category per item</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>Info about computation time</p>
</td></tr>
<tr><td><code>skillspace</code></td>
<td>
<p>Used skillspace parametrization</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Number of iterations</p>
</td></tr>
<tr><td><code>seed.used</code></td>
<td>
<p>Used simulation seed</p>
</td></tr>
<tr><td><code>Xlambda.init</code></td>
<td>
<p>Used initial lambda parameters</p>
</td></tr>
<tr><td><code>delta.init</code></td>
<td>
<p>Used initial delta parameters</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>Logical indicating whether convergence was achieved.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If some items have differing number of categories, appropriate
class probabilities in non-existing categories per items can be
practically set to zero by loading an item for all skill classes
on a fixed <code class="reqn">\lambda_x</code> parameter of a small number, e.g. <code>-999</code>.
</p>
<p>The implementation of the model builds on pieces work of Anton Formann.
See <a href="http://www.antonformann.at/">http://www.antonformann.at/</a> for more information.
</p>


<h3>References</h3>

<p>Berlinet, A. F., &amp; Roland, C. (2012).
Acceleration of the EM algorithm: P-EM versus epsilon algorithm.
<em>Computational Statistics &amp; Data Analysis, 56</em>(12), 4122-4137.
</p>
<p>Chen, Y., Liu, J., Xu, G., &amp; Ying, Z. (2015).
Statistical analysis of Q-matrix based diagnostic classification models.
<em>Journal of the American Statistical Association, 110</em>, 850-866.
</p>
<p>Chen, Y., Li, X., Liu, J., &amp; Ying, Z. (2017). Regularized latent class analysis
with application in cognitive diagnosis. <em>Psychometrika,
82</em>, 660-692.
</p>
<p>Formann, A. K. (1985). Constrained latent class models: Theory and applications.
<em>British Journal of Mathematical and Statistical Psychology,
38</em>, 87-111.
</p>
<p>Formann, A. K. (1992). Linear logistic latent class analysis for polytomous data.
<em>Journal of the American Statistical Association, 87</em>, 476-486.
</p>
<p>Formann, A. K. (2007). (Almost) Equivalence between conditional and mixture maximum
likelihood estimates for some models of the Rasch type. In M. von Davier &amp; C. H. Carstensen
(Eds.), <em>Multivariate and mixture distribution Rasch models</em> (pp. 177-189).
New York: Springer.
</p>
<p>Formann, A. K., &amp; Kohlmann, T. (1998). Structural latent class models.
<em>Sociological Methods &amp; Research, 26</em>, 530-565.
</p>
<p>Neuhaus, W. (1996). Optimal estimation under
linear constraints. <em>Astin Bulletin, 26</em>, 233-245.
</p>
<p>Sun, J., Chen, Y., Liu, J., Ying, Z., &amp; Xin, T. (2016).
Latent variable selection for multidimensional item response theory models
via <code class="reqn">L_1</code> regularization. <em>Psychometrika, 81</em>(4), 921-939.
</p>
<p>Xu, X., &amp; von Davier, M. (2008). <em>Fitting the structured general diagnostic
model to NAEP data</em>. ETS Research Report ETS RR-08-27. Princeton, ETS.
</p>


<h3>See Also</h3>

<p>For latent trait models with continuous latent variables see the
<span class="pkg">mirt</span> or <b>TAM</b> packages. For a discrete trait distribution see
the <span class="pkg">MultiLCIRT</span> package.
</p>
<p>For latent class models see the <span class="pkg">poLCA</span>, <span class="pkg">covLCA</span> or <span class="pkg">randomLCA</span>
package.
</p>
<p>For mixture Rasch or mixture IRT models see the <span class="pkg">psychomix</span> or
<span class="pkg">mRm</span> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: data.Students | (Generalized) Partial Credit Model
#############################################################################

data(data.Students, package="CDM")

dat &lt;- data.Students[, c("mj1","mj2","mj3","mj4","sc1", "sc2") ]
# define discretized ability
theta.k &lt;- seq( -6, 6, len=21 )

#*** Model 1: Partial credit model

# define design matrix for lambda
I &lt;- ncol(dat)
maxK &lt;- 4
TP &lt;- length(theta.k)
NXlam &lt;- I*(maxK-1) + 1       # number of estimated parameters
       # last parameter is joint slope parameter
Xdes &lt;- array( 0, dim=c(I, maxK, TP,  NXlam ) )
# Item1Cat1, ..., Item1Cat3, Item2Cat1, ...,
dimnames(Xdes)[[1]] &lt;- colnames(dat)
dimnames(Xdes)[[2]] &lt;- paste0("Cat", 1:(maxK) )
dimnames(Xdes)[[3]] &lt;- paste0("Class", 1:TP )
v2 &lt;- unlist( sapply( 1:I, FUN=function(ii){ # ii
    paste0( paste0( colnames(dat)[ii], "_b"  ), "Cat", 1:(maxK-1) )
                }, simplify=FALSE) )
dimnames(Xdes)[[4]] &lt;- c( v2, "a" )
# define theta design and item discriminations
for (ii in 1:I){
    for (hh in 1:(maxK-1) ){
        Xdes[ii, hh + 1,, NXlam ] &lt;- hh * theta.k
    }
}
# item intercepts
for (ii in 1:I){
    for (hh in 1:(maxK-1) ){
        # ii &lt;- 1  # Item    # hh &lt;- 1  # category
        Xdes[ii,hh+1,, ( ii - 1)*(maxK-1) + hh] &lt;- 1
    }
}
#****
# skill space designmatrix
TP &lt;- length(theta.k)
w1 &lt;- stats::dnorm(theta.k)
w1 &lt;- w1 / sum(w1)
delta.designmatrix &lt;- matrix( 1, nrow=TP, ncol=1 )
delta.designmatrix[,1] &lt;- log(w1)

# initial lambda parameters
Xlambda.init &lt;- c( stats::rnorm( dim(Xdes)[[4]] - 1 ), 1 )
# fixed delta parameter
delta.fixed &lt;- cbind( 1, 1,1 )

# estimate model
mod1 &lt;- CDM::slca( dat, Xdes=Xdes, delta.designmatrix=delta.designmatrix,
            Xlambda.init=Xlambda.init, delta.fixed=delta.fixed )
summary(mod1)
plot(mod1, cex.names=.7 )

## Not run: 
#*** Model 2: Partial credit model with some parameter constraints
# fixed lambda parameters
Xlambda.fixed &lt;- cbind( c(1,19), c(3.2,1.52 ) )
# 1st parameter=3.2
# 19th parameter=1.52 (joint item slope)
mod2 &lt;- CDM::slca( dat, Xdes=Xdes, delta.designmatrix=delta.designmatrix,
            delta.init=delta.init, Xlambda.init=Xlambda.init, delta.fixed=delta.fixed,
            Xlambda.fixed=Xlambda.fixed, maxiter=70 )

#*** Model 3: Partial credit model with non-normal distribution
Xlambda.fixed &lt;- cbind(  c(1,19), c(3.2,1) ) # fix item slope to one
delta.designmatrix &lt;- cbind( 1, theta.k, theta.k^2, theta.k^3 )
mod3 &lt;- CDM::slca( dat, Xdes=Xdes,  delta.designmatrix=delta.designmatrix,
            Xlambda.fixed=Xlambda.fixed,  maxiter=200 )
summary(mod3)

# non-normal distribution with convergence regularizing factor oldfac
mod3a &lt;- CDM::slca( dat, Xdes=Xdes,  delta.designmatrix=delta.designmatrix,
            Xlambda.fixed=Xlambda.fixed, maxiter=500, oldfac=.95 )
summary(mod3a)

#*** Model 4: Generalized Partial Credit Model

# estimate generalized partial credit model without restrictions on trait
# distribution and item parameters to ensure better convergence behavior
# Note that two parameters are not identifiable and information criteria
# have to be adapted.

#---
# define design matrix for lambda
I &lt;- ncol(dat)
maxK &lt;- 4
TP &lt;- length(theta.k)
NXlam &lt;- I*(maxK-1) + I       # number of estimated parameters
Xdes &lt;- array( 0, dim=c(I, maxK, TP,  NXlam ) )
# Item1Cat1, ..., Item1Cat3, Item2Cat1, ...,
dimnames(Xdes)[[1]] &lt;- colnames(dat)
dimnames(Xdes)[[2]] &lt;- paste0("Cat", 1:(maxK) )
dimnames(Xdes)[[3]] &lt;- paste0("Class", 1:TP )
v2 &lt;- unlist( sapply( 1:I, FUN=function(ii){ # ii
    paste0( paste0( colnames(dat)[ii], "_b"  ), "Cat", 1:(maxK-1) )
                }, simplify=FALSE) )
dimnames(Xdes)[[4]] &lt;- c( v2, paste0( colnames(dat),"_a") )
dimnames(Xdes)
# define theta design and item discriminations
for (ii in 1:I){
    for (hh in 1:(maxK-1) ){
        Xdes[ii, hh + 1,, I*(maxK-1) + ii ] &lt;- hh * theta.k
    }
}
# item intercepts
for (ii in 1:I){
    for (hh in 1:(maxK-1) ){
        Xdes[ii,hh+1,, ( ii - 1)*(maxK-1) + hh] &lt;- 1
    }
}
#****
# skill space designmatrix
delta.designmatrix &lt;- cbind( 1, theta.k,theta.k^2 )
# initial lambda parameters from partial credit model
Xlambda.init &lt;- mod1$Xlambda
Xlambda.init &lt;- c( mod1$Xlambda[ - length(Xlambda.init) ],
         rep( Xlambda.init[ length(Xlambda.init)  ],I) )

# estimate model
mod4 &lt;- CDM::slca( dat, Xdes=Xdes, Xlambda.init=Xlambda.init,
             delta.designmatrix=delta.designmatrix, decrease.increments=TRUE,
             maxiter=300 )

#############################################################################
# EXAMPLE 2: Latent class model with two classes
#############################################################################

set.seed(9876)
I &lt;- 7    # number of items
# simulate response probabilities
a1 &lt;- stats::runif(I, 0, .4 )
a2 &lt;- stats::runif(I, .6, 1 )
N &lt;- 1000    # sample size
# simulate data in two classes of proportions .3 and .7
N1 &lt;- round(.3*N)
dat1 &lt;- 1 * ( matrix(a1,N1,I,byrow=TRUE) &gt; matrix( stats::runif( N1 * I), N1, I ) )
N2 &lt;- round(.7*N)
dat2 &lt;- 1 * ( matrix(a2,N2,I,byrow=TRUE) &gt; matrix( stats::runif( N2 * I), N2, I ) )
dat &lt;- rbind( dat1, dat2 )
colnames(dat) &lt;- paste0("I", 1:I)

# define design matrices
TP &lt;- 2     # two classes
# The idea is that latent classes refer to two different "dimensions".
# Items load on latent class indicators 1 and 2, see below.
Xdes &lt;- array(0, dim=c(I,2,2,2*I) )
items &lt;- colnames(dat)
dimnames(Xdes)[[4]] &lt;- c(paste0( colnames(dat), "Class", 1),
          paste0( colnames(dat), "Class", 2) )
    # items, categories, classes, parameters
# probabilities for correct solution
for (ii in 1:I){
    Xdes[ ii, 2, 1, ii ] &lt;- 1    # probabilities class 1
    Xdes[ ii, 2, 2, ii+I ] &lt;- 1  # probabilities class 2
}
# estimate model
mod1 &lt;- CDM::slca( dat, Xdes=Xdes )
summary(mod1)

#############################################################################
# EXAMPLE 3: Mixed Rasch model with two classes
#############################################################################

set.seed(987)
library(sirt)
# simulate two latent classes of Rasch populations
I &lt;- 15  # 6 items
b1 &lt;- seq( -1.5, 1.5, len=I)      # difficulties latent class 1
b2 &lt;- b1    # difficulties latent class 2
b2[ c(4,7, 9, 11, 12, 13) ] &lt;- c(1, -.5, -.5, .33, .33, -.66 )
N &lt;- 3000    # number of persons
wgt &lt;- .25       # class probability for class 1
# class 1
dat1 &lt;- sirt::sim.raschtype( stats::rnorm( wgt*N ), b1 )
# class 2
dat2 &lt;- sirt::sim.raschtype( stats::rnorm( (1-wgt)*N, mean=1, sd=1.7), b2 )
dat &lt;- rbind( dat1, dat2 )
# theta grid
theta.k &lt;- seq( -5, 5, len=9 )
TP &lt;- length(theta.k)

#*** Model 1: Rasch model with normal distribution
maxK &lt;- 2
NXlam &lt;- I +1
Xdes &lt;- array( 0, dim=c(I, maxK, TP,  NXlam ) )
dimnames(Xdes)[[1]] &lt;- colnames(dat)
dimnames(Xdes)[[2]] &lt;- paste0("Cat", 1:(maxK) )
dimnames(Xdes)[[4]] &lt;- c( paste0( "b_", colnames(dat)[1:I] ), "a" )
# define item difficulties
for (ii in 1:I){
    Xdes[ii, 2,, ii ] &lt;- -1
}
# theta design
for (tt in 1:TP){
    Xdes[1:I, 2, tt, I + 1] &lt;- theta.k[tt]
}

# skill space definition
delta.designmatrix &lt;- cbind( 1, theta.k^2 )
delta.fixed &lt;- NULL
Xlambda.init &lt;- c( stats::runif( I, -.8, .8 ), 1 )
Xlambda.fixed &lt;- cbind( I+1, 1 )
# estimate model
mod1 &lt;- CDM::slca( dat, Xdes=Xdes, delta.designmatrix=delta.designmatrix,
            delta.fixed=delta.fixed, Xlambda.fixed=Xlambda.fixed,
            Xlambda.init=Xlambda.init, decrease.increments=TRUE, maxiter=200 )
summary(mod1)

#*** Model 1b: Constraint the sum of item difficulties to zero

# change skill space definition
delta.designmatrix &lt;- cbind( 1, theta.k, theta.k^2 )
delta.fixed &lt;- NULL
# constrain sum of difficulties Xlambda parameters to zero
Xlambda.constr.V &lt;- matrix( 1, nrow=I+1, ncol=1 )
Xlambda.constr.V[I+1,1] &lt;- 0
Xlambda.constr.c &lt;- c(0)
# estimate model
mod1b &lt;- CDM::slca( dat, Xdes=Xdes, delta.designmatrix=delta.designmatrix,
            Xlambda.fixed=Xlambda.fixed, Xlambda.constr.V=Xlambda.constr.V,
            Xlambda.constr.c=Xlambda.constr.c  )
summary(mod1b)

#*** Model 2: Mixed Rasch model with two latent classes
NXlam &lt;- 2*I +2
Xdes &lt;- array( 0, dim=c(I, maxK, 2*TP,  NXlam ) )
dimnames(Xdes)[[1]] &lt;- colnames(dat)
dimnames(Xdes)[[2]] &lt;- paste0("Cat", 1:(maxK) )
dimnames(Xdes)[[4]] &lt;- c( paste0( "bClass1_", colnames(dat)[1:I] ),
        paste0( "bClass2_", colnames(dat)[1:I] ), "aClass1", "aClass2" )
# define item difficulties
for (ii in 1:I){
    Xdes[ii, 2, 1:TP, ii ] &lt;- -1  # first class
    Xdes[ii, 2, TP + 1:TP, I+ii ] &lt;- -1  # second class
}
# theta design
for (tt in 1:TP){
    Xdes[1:I, 2, tt, 2*I+1 ] &lt;- theta.k[tt]
    Xdes[1:I, 2, TP+tt, 2*I+2 ] &lt;- theta.k[tt]
}
# skill space definition
delta.designmatrix &lt;- matrix( 0, nrow=2*TP, ncol=4 )
delta.designmatrix[1:TP,1] &lt;- 1
delta.designmatrix[1:TP,2] &lt;- theta.k^2
delta.designmatrix[TP + 1:TP,3] &lt;- 1
delta.designmatrix[TP+ 1:TP,4] &lt;- theta.k^2
b1 &lt;- stats::qnorm( colMeans(dat) )
Xlambda.init &lt;- c( stats::runif( 2*I, -1.8, 1.8 ), 1,1 )
Xlambda.fixed &lt;- cbind( c(2*I+1, 2*I+2), 1 )
# estimate model
mod2 &lt;- CDM::slca( dat, Xdes=Xdes,  delta.designmatrix=delta.designmatrix,
            Xlambda.fixed=Xlambda.fixed, decrease.increments=TRUE,
            Xlambda.init=Xlambda.init, maxiter=1000 )
summary(mod2)
summary(mod1)
# latent class proportions
stats::aggregate( mod2$pi.k, list( rep(1:2, each=TP)), sum )

#*** Model 2b: Different parametrization with sum constraint on item difficulties

# skill space definition
delta.designmatrix &lt;- matrix( 0, nrow=2*TP, ncol=6 )
delta.designmatrix[1:TP,1] &lt;- 1
delta.designmatrix[1:TP,2] &lt;- theta.k
delta.designmatrix[1:TP,3] &lt;- theta.k^2
delta.designmatrix[TP+ 1:TP,4] &lt;- 1
delta.designmatrix[TP+ 1:TP,5] &lt;- theta.k
delta.designmatrix[TP+ 1:TP,6] &lt;- theta.k^2
Xlambda.fixed &lt;- cbind( c(2*I+1,2*I+2), c(1,1) )
b1 &lt;- stats::qnorm( colMeans( dat ) )
Xlambda.init &lt;- c( b1, b1 + stats::runif(I, -1, 1 ), 1, 1 )
# constraints on item difficulties
Xlambda.constr.V &lt;- matrix( 0, nrow=NXlam, ncol=2)
Xlambda.constr.V[1:I, 1 ] &lt;- 1
Xlambda.constr.V[I + 1:I, 2 ] &lt;- 1
Xlambda.constr.c &lt;- c(0,0)
# estimate model
mod2b &lt;- CDM::slca( dat, Xdes=Xdes, delta.designmatrix=delta.designmatrix,
            Xlambda.fixed=Xlambda.fixed,  Xlambda.init=Xlambda.init,
            Xlambda.constr.V=Xlambda.constr.V, Xlambda.constr.c=Xlambda.constr.c,
            decrease.increments=TRUE, maxiter=1000 )
summary(mod2b)
stats::aggregate( mod2b$pi.k, list( rep(1:2, each=TP)), sum )

#*** Model 2c: Estimation with mRm package
library(mRm)
mod2c &lt;- mRm::mrm(data.matrix=dat, cl=2)
plot(mod2c)
print(mod2c)

#*** Model 2d: Estimation with psychomix package
library(psychomix)
mod2d &lt;- psychomix::raschmix(data=dat, k=2, verbose=TRUE )
summary(mod2d)
plot(mod2d)

#############################################################################
# EXAMPLE 4: Located latent class model, Rasch model
#############################################################################

set.seed(487)
library(sirt)
I &lt;- 15  # I items
b1 &lt;- seq( -2, 2, len=I)      # item difficulties
N &lt;- 4000    # number of persons
# simulate 4 theta classes
theta0 &lt;- c( -2.5, -1, 0.3, 1.3 )  # skill classes
probs0 &lt;- c( .1, .4, .2, .3 )
TP &lt;- length(theta0)
theta &lt;- theta0[ rep(1:TP, round(probs0*N)  ) ]
dat &lt;- sirt::sim.raschtype( theta, b1 )

#*** Model 1: Located latent class model with 4 classes
maxK &lt;- 2
NXlam &lt;- I + TP
Xdes &lt;- array( 0, dim=c(I, maxK, TP,  NXlam ) )
dimnames(Xdes)[[1]] &lt;- colnames(dat)
dimnames(Xdes)[[2]] &lt;- paste0("Cat", 1:(maxK) )
dimnames(Xdes)[[3]] &lt;- paste0("Class", 1:TP )
dimnames(Xdes)[[4]] &lt;- c( paste0( "b_", colnames(dat)[1:I] ), paste0("theta", 1:TP) )
# define item difficulties
for (ii in 1:I){
    Xdes[ii, 2,, ii ] &lt;- -1
}
# theta design
for (tt in 1:TP){
    Xdes[1:I, 2, tt, I + tt] &lt;- 1
}

# skill space definition
delta.designmatrix &lt;- diag(TP)
Xlambda.init &lt;- c( - stats::qnorm( colMeans(dat) ), seq(-2,1,len=TP)  )
# constraint on item difficulties
Xlambda.constr.V &lt;- matrix( 0, nrow=NXlam, ncol=1)
Xlambda.constr.V[1:I,1] &lt;- 1
Xlambda.constr.c &lt;- c(0)
delta.init &lt;- matrix( c(1,1,1,1), TP, 1 )
# estimate model
mod1 &lt;- CDM::slca( dat, Xdes=Xdes, delta.designmatrix=delta.designmatrix,
            delta.init=delta.init, Xlambda.init=Xlambda.init,
            Xlambda.constr.V=Xlambda.constr.V, Xlambda.constr.c=Xlambda.constr.c,
            decrease.increments=TRUE,  maxiter=400 )
summary(mod1)
# compare estimated and simulated theta class locations
cbind( mod1$Xlambda[ - c(1:I) ], theta0 )
# compare estimated and simulated latent class proportions
cbind( mod1$pi.k, probs0 )

#############################################################################
# EXAMPLE 5: DINA model with two skills
#############################################################################

set.seed(487)
N &lt;- 3000   # number of persons
# define Q-matrix
I &lt;- 9  # 9 items
NS &lt;- 2 # 2 skills
TP &lt;- 4 # number of skill classes
Q &lt;- scan( nlines=3)
  1 0   1 0   1 0
  0 1   0 1   0 1
  1 1   1 1   1 1
Q &lt;- matrix(Q, I, ncol=NS,byrow=TRUE)
# define skill distribution
alpha0 &lt;- matrix( c(0,0,1,0,0,1,1,1), nrow=4,ncol=2,byrow=TRUE)
prob0 &lt;- c( .2, .4, .1, .3 )
alpha &lt;- alpha0[ rep( 1:TP, prob0*N),]
# define guessing and slipping parameters
guess &lt;- round( stats::runif(I, 0, .4 ), 2 )
slip &lt;- round( stats::runif(I, 0, .3 ), 2 )
# simulate data according to the DINA model
dat &lt;- CDM::sim.din( q.matrix=Q, alpha=alpha, slip=slip, guess=guess )$dat

# define Xlambda design matrix
maxK &lt;- 2
NXlam &lt;- 2*I
Xdes &lt;- array( 0, dim=c(I, maxK, TP,  NXlam ) )
dimnames(Xdes)[[1]] &lt;- colnames(dat)
dimnames(Xdes)[[2]] &lt;- paste0("Cat", 1:(maxK) )
dimnames(Xdes)[[3]] &lt;- c("S00","S10","S01","S11")
dimnames(Xdes)[[4]] &lt;- c( paste0("guess",1:I ), paste0( "antislip", 1:I ) )
dimnames(Xdes)
# define item difficulties
for (ii in 1:I){
        # define latent responses
        latresp &lt;- 1*( alpha0 %*% Q[ii,]==sum(Q[ii,]) )[,1]
        # model slipping parameters
        Xdes[ii, 2, latresp==1, I+ii ] &lt;- 1
        # guessing parameters
        Xdes[ii, 2, latresp==0, ii ] &lt;- 1
}
Xdes[1,2,,]
Xdes[7,2,,]
# skill space definition
delta.designmatrix &lt;- diag(TP)
Xlambda.init &lt;- c( rep( stats::qlogis( .2 ), I ), rep( stats::qlogis( .8 ), I ) )

# estimate DINA model with slca function
mod1 &lt;- CDM::slca( dat, Xdes=Xdes, delta.designmatrix=delta.designmatrix,
            Xlambda.init=Xlambda.init, decrease.increments=TRUE, maxiter=400 )
summary(mod1)

# compare estimated and simulated latent class proportions
cbind( mod1$pi.k, probs0 )
# compare estimated and simulated guessing parameters
cbind( mod1$pjk[1,,2], guess )
# compare estimated and simulated slipping parameters
cbind( 1 - mod1$pjk[4,,2], slip )

#############################################################################
# EXAMPLE 6: Investigating differential item functioning in Rasch models
#            with regularization
#############################################################################

#---- simulate data
set.seed(987)
N &lt;- 1000   # number of persons in a group
I &lt;- 20    # number of items
#* population parameters of two groups
mu1 &lt;- 0
mu2 &lt;- .6
sd1 &lt;- 1.4
sd2 &lt;- 1
# item difficulties
b &lt;- seq( -1.1, 1.1, len=I )
# define some DIF effects
dif &lt;- rep(0,I)
dif[ c(3,6,9,12)] &lt;- c( .6, -1, .75, -.35 )
print(dif)
#* simulate datasets
dat1 &lt;- sirt::sim.raschtype( rnorm(N, mean=mu1, sd=sd1), b=b - dif /2 )
colnames(dat1) &lt;- paste0("I", 1:I, "_G1")
dat2 &lt;- sirt::sim.raschtype( rnorm(N, mean=mu2, sd=sd2), b=b + dif /2 )
colnames(dat2) &lt;- paste0("I", 1:I, "_G2")
dat &lt;- CDM::CDM_rbind_fill( dat1, dat2 )
dat &lt;- data.frame( "group"=rep(1:2, each=N), dat )

#-- nodes for distribution
theta.k &lt;- seq(-4, 4, len=11)
# define design matrix for lambda
nitems &lt;- ncol(dat) - 1
maxK &lt;- 2
TP &lt;- length(theta.k)
NXlam &lt;- 2*I + 1
Xdes &lt;- array( 0, dim=c( nitems, maxK, TP,  NXlam  ) )
dimnames(Xdes)[[1]] &lt;- colnames(dat)[-1]
dimnames(Xdes)[[2]] &lt;- paste0("Cat", 0:(maxK-1) )
dimnames(Xdes)[[3]] &lt;- paste0("Theta", 1:TP )
dimnames(Xdes)[[4]] &lt;- c( paste0("b", 1:I ), paste0("dif", 1:I ), "const" )
# define theta design
for (ii in 1:nitems){
    Xdes[ii,2,,NXlam ] &lt;- theta.k
}
# item intercepts and DIF effects
for (ii in 1:I){
    Xdes[c(ii,ii+I),2,, ii ] &lt;- -1
    Xdes[ii,2,,ii+I] &lt;- - 1/2
    Xdes[ii+I,2,,ii+I] &lt;- 1/2
}
#--- skill space designmatrix
TP &lt;- length(theta.k)
w1 &lt;- stats::dnorm(theta.k)
w1 &lt;- w1 / sum(w1)
delta.designmatrix &lt;- matrix( 1, nrow=TP, ncol=2 )
delta.designmatrix[,2] &lt;- log(w1)

# fixed lambda parameters
Xlambda.fixed &lt;- cbind(NXlam, 1 )
# initial Xlambda parameters
dif_sim &lt;- 0*stats::rnorm(I, sd=.2)
Xlambda.init &lt;- c( - stats::qnorm( colMeans(dat1) ), dif_sim, 1 )

# delta.fixed
delta.fixed &lt;- cbind( 1, 1, 0 )
# regularization parameter
regular_lam &lt;- .2
# weighting vector: regularize only DIF effects
regular_w &lt;- c( rep(0,I), rep(1,I), 0 )

#--- estimation model with scad penalty
mod1 &lt;- CDM::slca( dat[,-1], group=dat$group, Xdes=Xdes,
            delta.designmatrix=delta.designmatrix, regular_type="scad",
            Xlambda.init=Xlambda.init, delta.fixed=delta.fixed, Xlambda.fixed=Xlambda.fixed,
            regular_lam=regular_lam, regular_w=regular_w )
# compare true and estimated DIF effects
cbind( "true"=dif, "estimated"=round(coef(mod1)[seq(I+1,2*I)],2) )
summary(mod1)

## End(Not run)
</code></pre>

<hr>
<h2 id='summary_sink'>
Prints <code>summary</code> and <code>sink</code> Output in a File
</h2><span id='topic+summary_sink'></span>

<h3>Description</h3>

<p>Prints <code>summary</code> and <code>sink</code> output in a File
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_sink( object, file, append=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary_sink_+3A_object">object</code></td>
<td>

<p>Object for which a <code>summary</code> method is defined
</p>
</td></tr>
<tr><td><code id="summary_sink_+3A_file">file</code></td>
<td>

<p>File name
</p>
</td></tr>
<tr><td><code id="summary_sink_+3A_append">append</code></td>
<td>
<p>Optional logical indicating whether console output should
be appended to an already existing file. See argument <code>append</code> in
<code><a href="base.html#topic+sink">base::sink</a></code>.</p>
</td></tr>
<tr><td><code id="summary_sink_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>summary</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="base.html#topic+sink">base::sink</a></code>,
<code><a href="base.html#topic+summary">base::summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: summary_sink example for lm function
#############################################################################

#--- simulate some data
set.seed(997)
N &lt;- 200
x &lt;- stats::rnorm( N )
y &lt;- .4 * x + stats::rnorm(N, sd=.5 )

#--- fit a linear model and sink summary into a file
mod1 &lt;- stats::lm( y ~ x )
CDM::summary_sink(mod1, file="my_model")

#--- fit a second model and append it to file
mod2 &lt;- stats::lm( y ~ x + I(x^2) )
CDM::summary_sink(mod2, file="my_model", append=TRUE )

## End(Not run)
</code></pre>

<hr>
<h2 id='summary.din'>
Summary Method for Objects of Class din
</h2><span id='topic+summary.din'></span>

<h3>Description</h3>

<p>S3 method to summarize objects of the class <code>din</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'din'
summary(object, top.n.skill.classes=6, overwrite=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.din_+3A_object">object</code></td>
<td>
<p>A required object of class <code>din</code>, obtained
from a call to the function <code><a href="#topic+din">din</a></code>.  </p>
</td></tr>
<tr><td><code id="summary.din_+3A_top.n.skill.classes">top.n.skill.classes</code></td>
<td>
<p>A numeric, specifying the number of skill
classes, starting with the most frequent, to be returned.
Default value is 6.  </p>
</td></tr>
<tr><td><code id="summary.din_+3A_overwrite">overwrite</code></td>
<td>
<p>An optional boolean, specifying wether or not
the method is supposed to overwrite an existing <code>log.file</code>.
If the <code>log.file</code> exists and <code>overwrite</code> is
<code>FALSE</code>, the user is asked to confirm the overwriting.  </p>
</td></tr>
<tr><td><code id="summary.din_+3A_...">...</code></td>
<td>
<p>Optional parameters to be passed to or from other
methods will be ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>summary.din</code> returns an object of the class
<code>summary.din</code> (see &lsquo;Value&rsquo;), for which a
<code>print</code> method, <code><a href="#topic+print.summary.din">print.summary.din</a></code>, is
provided.  Specific summary information details such as
individual item parameters and their discrimination indices
can be accessed through assignment (see &lsquo;Examples&rsquo;).
</p>


<h3>Value</h3>

<p>If the argument <code>object</code> is of required type,
<code>summary.din</code> returns a named list, of the class
<code>summary.din</code>, consisting of the following seven components:
</p>
<table role = "presentation">
<tr><td><code>CALL</code></td>
<td>
<p>A character specifying the model rule, the number of
items and the number of attributes underlying the items.  </p>
</td></tr>
<tr><td><code>IDI</code></td>
<td>
<p>A matrix giving the item discrimination
index (IDI; Lee, de la Torre &amp; Park, 2012) for each item <code class="reqn">j</code>
</p>
<p style="text-align: center;"><code class="reqn"> IDI_j=1 - s_j - g_j, </code>
</p>

<p>where a high IDI corresponds to favorable test items
which have both low guessing and slipping rates. </p>
</td></tr>
<tr><td><code>SKILL.CLASSES</code></td>
<td>
<p>A vector giving the <code>top.n.skill.classes</code>
most frequent skill classes and the corresponding class probability.  </p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>A numeric giving the AIC of the specified model
<code>object</code>.  </p>
</td></tr>
<tr><td><code>BIC</code></td>
<td>
<p>A numeric giving the BIC of the specified model
<code>object</code>.  </p>
</td></tr>
<tr><td><code>log.file</code></td>
<td>
<p>A character giving the path and file of a specified
log file.  </p>
</td></tr>
<tr><td><code>din.object</code></td>
<td>
<p>The object of class <code>din</code> for which the summary
was requested.  </p>
</td></tr>
</table>


<h3>References</h3>

<p>Lee, Y.-S., de la Torre, J., &amp; Park, Y. S. (2012). Relationships between
cognitive diagnosis, CTT, and IRT indices: An empirical investigation.
<em>Asia Pacific Educational Research, 13</em>, 333-345.
</p>
<p>Rupp, A. A., Templin, J. L., &amp; Henson, R. A. (2010) <em>Diagnostic
Measurement: Theory, Methods, and Applications</em>.  New York: The Guilford
Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.din">plot.din</a></code>, the S3 method for plotting objects of
the class <code>din</code>; <code><a href="#topic+print.din">print.din</a></code>, the S3 method
for printing objects of the class <code>din</code>;
<code><a href="#topic+summary.din">summary.din</a></code>, the S3 method for summarizing objects
of the class <code>din</code>, which creates objects of the class
<code>summary.din</code>; <code><a href="#topic+din">din</a></code>, the main function for
DINA and DINO parameter estimation, which creates objects of the class
<code>din</code>.  See also <code><a href="#topic+CDM-package">CDM-package</a></code> for general
information about this package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##
## (1) examples based on dataset fractions.subtraction.data
##

## Parameter estimation of DINA model
# rule="DINA" is default
fractions.dina &lt;- CDM::din(data=CDM::fraction.subtraction.data,
           q.matrix=CDM::fraction.subtraction.qmatrix, rule="DINA")

## corresponding summaries, including diagnostic accuracies,
## most frequent skill classes and information
## criteria AIC and BIC
summary(fractions.dina)

## In particular, accessing detailed summary through assignment
detailed.summary.fs &lt;- summary(fractions.dina)
str(detailed.summary.fs)
</code></pre>

<hr>
<h2 id='vcov'>Asymptotic Covariance Matrix, Standard Errors and Confidence Intervals</h2><span id='topic+vcov.din'></span><span id='topic+confint.din'></span><span id='topic+IRT.se'></span><span id='topic+IRT.se.din'></span>

<h3>Description</h3>

<p>Computes the asymptotic covariance matrix for
<code>din</code> objects. The covariance matrix is computed using the
empirical cross-product approach (see Paek &amp; Cai, 2014).
</p>
<p>In addition, an S3 method <code>IRT.se</code> is defined which produces
an extended output including <code>vcov</code> and <code>confint</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'din'
vcov(object, extended=FALSE, infomat=FALSE,ind.item.skillprobs=TRUE,
       ind.item=FALSE, diagcov=FALSE, h=.001,...)

## S3 method for class 'din'
confint(object, parm, level=.95, extended=FALSE,
      ind.item.skillprobs=TRUE, ind.item=FALSE, diagcov=FALSE, h=.001, ... )

IRT.se(object, ...)

## S3 method for class 'din'
IRT.se( object, extended=FALSE, parm=NULL, level=.95,
      infomat=FALSE, ind.item.skillprobs=TRUE, ind.item=FALSE,
      diagcov=FALSE, h=.001, ... )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcov_+3A_object">object</code></td>
<td>
<p>An object inheriting from class <code>din</code>.
</p>
</td></tr>
<tr><td><code id="vcov_+3A_extended">extended</code></td>
<td>
<p>An optional logical indicating whether the covariance
matrix should be calculated for an extended set of parameters
(estimated and derived parameters).
</p>
</td></tr>
<tr><td><code id="vcov_+3A_infomat">infomat</code></td>
<td>
<p>An optional logical indicating whether the
information matrix instead of the covariance matrix should be
the output.</p>
</td></tr>
<tr><td><code id="vcov_+3A_ind.item.skillprobs">ind.item.skillprobs</code></td>
<td>
<p>Optional logical indicating whether the covariance
between item parameters and skill class probabilities are assumed
to be zero.</p>
</td></tr>
<tr><td><code id="vcov_+3A_ind.item">ind.item</code></td>
<td>
<p>Optional logical indicating whether covariances of
item parameters between different items are zero.</p>
</td></tr>
<tr><td><code id="vcov_+3A_diagcov">diagcov</code></td>
<td>
<p>Optional logical indicating whether all covariances
between estimated parameters are set to zero.</p>
</td></tr>
<tr><td><code id="vcov_+3A_h">h</code></td>
<td>
<p>Parameter used for numerical differentiation for computing
the derivative of the log-likelihood function.</p>
</td></tr>
<tr><td><code id="vcov_+3A_parm">parm</code></td>
<td>
<p>Vector of parameters. If it is missing, then for all estimated
parameters a confidence interval is calculated.</p>
</td></tr>
<tr><td><code id="vcov_+3A_level">level</code></td>
<td>
<p>Confidence level</p>
</td></tr>
<tr><td><code id="vcov_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>coef</code>: A vector of parameters.
</p>
<p><code>vcov</code>: A covariance matrix. The corresponding coefficients can be extracted
as the attribute <code>coef</code> from this object.
</p>
<p><code>IRT.se</code>: A data frame containing coefficients, standard errors
and confidence intervals for all parameters.
</p>


<h3>References</h3>

<p>Paek, I., &amp; Cai, L. (2014). A comparison of item parameter standard error
estimation procedures for unidimensional and multidimensional item response
theory modeling. <em>Educational and Psychological Measurement, 74</em>(1),
58-76.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+din">din</a></code>, <code><a href="#topic+coef.din">coef.din</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: DINA model sim.dina
#############################################################################

data(sim.dina, package="CDM")
data(sim.qmatrix, package="CDM")

dat &lt;- sim.dina
q.matrix &lt;- sim.qmatrix

#****** Model 1: DINA Model
mod1 &lt;- CDM::din( dat, q.matrix=q.matrix, rule="DINA")
# look into parameter table of the model
mod1$partable
# covariance matrix
covmat1 &lt;- vcov(mod1 )
# extract coefficients
coef(mod1)
# extract standard errors
sqrt( diag( covmat1))
# compute confidence intervals
confint( mod1, level=.90 )
# output table with standard errors
IRT.se( mod1, extended=TRUE )

#****** Model 2: Constrained DINA Model

# fix some slipping parameters
constraint.slip &lt;- cbind( c(2,3,5), c(.15,.20,.25) )
# set some skill class probabilities to zero
zeroprob.skillclasses &lt;- c(2,4)
# estimate model
mod2 &lt;- CDM::din( dat, q.matrix=q.matrix, guess.equal=TRUE,
     constraint.slip=constraint.slip, zeroprob.skillclasses=zeroprob.skillclasses)
# parameter table
mod2$partable
# freely estimated coefficients
coef(mod2)
# covariance matrix (estimated parameters)
vmod2a &lt;- vcov(mod2)
sqrt( diag( vmod2a))        # standard errors
colnames( vmod2a )
names( attr( vmod2a, "coef") )    # extract coefficients

# covariance matrix (more parameters, extended=TRUE)
vmod2b &lt;- vcov(mod2, extended=TRUE)
sqrt( diag( vmod2b))
attr( vmod2b, "coef")
# attach standard errors to parameter table
partable2 &lt;- mod2$partable
partable2 &lt;- partable2[ ! duplicated( partable2$parnames ), ]
partable2 &lt;- data.frame( partable2, "se"=sqrt( diag( vmod2b)) )
partable2

# confidence interval for parameter "skill1" which is not in the model
#   cannot be calculated!
confint(mod2, parm=c( "skill1", "all_guess" ) )
# confidence interval for only some parameters
confint(mod2, parm=paste0("prob_skill", 1:3 ) )

# compute only information matrix
infomod2 &lt;- vcov(mod2, infomat=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='WaldTest'>
Wald Test for a Linear Hypothesis
</h2><span id='topic+WaldTest'></span>

<h3>Description</h3>

<p>Computes a Wald Test for a parameter <code class="reqn">\bold{\theta}</code>
with respect to a linear hypothesis
<code class="reqn"> \bold{R} \bold{\theta}=\bold{c}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WaldTest( delta, vcov, R, nobs, cvec=NULL, eps=1E-10 )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="WaldTest_+3A_delta">delta</code></td>
<td>

<p>Estimated parameter
</p>
</td></tr>
<tr><td><code id="WaldTest_+3A_vcov">vcov</code></td>
<td>
<p>Estimated covariance matrix</p>
</td></tr>
<tr><td><code id="WaldTest_+3A_r">R</code></td>
<td>
<p>Hypothesis matrix</p>
</td></tr>
<tr><td><code id="WaldTest_+3A_nobs">nobs</code></td>
<td>
<p>Number of observations</p>
</td></tr>
<tr><td><code id="WaldTest_+3A_cvec">cvec</code></td>
<td>
<p>Hypothesis vector</p>
</td></tr>
<tr><td><code id="WaldTest_+3A_eps">eps</code></td>
<td>
<p>Numerical value is added as ridge parameter of
the covariance matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the <code class="reqn">\chi^2</code> statistic (<code>X2</code>),
degrees of freedom (<code>df</code>),
p value (<code>p</code>) and RMSEA statistic (<code>RMSEA</code>).
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
