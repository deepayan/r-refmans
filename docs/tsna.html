<!DOCTYPE html><html lang="en"><head><title>Help for package tsna</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tsna}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.network.tPath'>
<p>Create a network object from a <code>tPath</code> object &ndash; the results of a path search</p></a></li>
<li><a href='#duration'>
<p>Compute Observed Activity Durations or Event Counts for Edges or Vertices</p></a></li>
<li><a href='#formation_and_dissolution'>
<p>Counts or fractions of edge transitions in a networkDynamic object</p></a></li>
<li><a href='#moodyContactSim'>
<p>Jim Moody's example dynamic contact simulation network</p></a></li>
<li><a href='#paths'>
<p>Temporally Reachable Paths in a networkDynamic Object</p></a></li>
<li><a href='#plotPaths'>
<p>Network Plots a Highlighting Temporal Path(s) .</p></a></li>
<li><a href='#pShiftCount'>
<p>Compute Counts of Gibson's Participation Shifts</p></a></li>
<li><a href='#reachable'>
<p>Find the set of vertices reachable from a given set using only paths moving forward in time</p></a></li>
<li><a href='#tDegree'>
<p>Report momentary degree of a networkDynamic object at multiple timepoints</p></a></li>
<li><a href='#temporal+20density'>
<p>Functions to compute temporal density-related measures on dynamic networks</p></a></li>
<li><a href='#tErgmStats'>
<p>Calculate network summary statistics at multiple time points</p></a></li>
<li><a href='#tiedDuration'>
<p>Compute the duration of time (or count of events) that each vertex is tied/connected to others by an edge</p></a></li>
<li><a href='#timeProjectedNetwork'>
<p>Construct a time-projected (&quot;multi-slice&quot;) network by binning a networkDynamic object</p></a></li>
<li><a href='#tReach'>
<p>computes sizes of temporally reachable sets in a dynamicNetwork</p></a></li>
<li><a href='#tsna'>
<p>Tools for Temporal Social Network Analysis</p></a></li>
<li><a href='#tSnaStats'>
<p>Apply the sna package's static graph- and vertex-level network descriptive statistics at multiple time points</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.3.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-10-31</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Temporal Social Network Analysis</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Depends:</td>
<td>network (&ge; 1.13), networkDynamic (&ge; 0.9), R (&ge; 3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>statnet.common</td>
</tr>
<tr>
<td>Suggests:</td>
<td>networkDynamicData, testthat, sna, knitr, rmarkdown,
relevent, ergm (&ge; 3.10)</td>
</tr>
<tr>
<td>Description:</td>
<td>Temporal SNA tools for continuous- and discrete-time longitudinal networks having vertex, edge, and attribute dynamics stored in the 'networkDynamic' format. This work was supported by grant R01HD68395 from the National Institute of Health.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://statnet.org/">http://statnet.org/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/statnet/tsna/issues">https://github.com/statnet/tsna/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-10-31 15:32:46 UTC; skyebend</td>
</tr>
<tr>
<td>Author:</td>
<td>Skye Bender-deMoll [aut, cre],
  Martina Morris [aut],
  James Moody [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Skye Bender-deMoll &lt;skyebend@uw.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-11-01 16:10:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.network.tPath'>
Create a network object from a <code>tPath</code> object &ndash; the results of a path search
</h2><span id='topic+as.network.tPath'></span>

<h3>Description</h3>

<p>Takes the results of a temporal path search (a <code><a href="#topic+tPath">tPath</a></code>) as input and creates a new network object representing the path tree which can be plotted for debugging, etc. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'tPath'
as.network(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.network.tPath_+3A_x">x</code></td>
<td>

<p>A <code>tPath</code> list with several elements, the output of a path search.
</p>
</td></tr>
<tr><td><code id="as.network.tPath_+3A_...">...</code></td>
<td>
<p>possible additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Attributes of original network are not copied
</p>


<h3>Value</h3>

<p>a directed <code>networkDynamic</code> object representing the path information from the input. Each edge has the onset time indicated by its distance in the path. 
</p>


<h3>Note</h3>

<p>this is probably not the final form of this function
</p>


<h3>Author(s)</h3>

<p>skyebend
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+paths">paths</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(moodyContactSim)
  v1path&lt;-tPath(moodyContactSim,v=1)
  v1tree&lt;-as.network(v1path)
  plot(v1tree,displaylabels=TRUE)
</code></pre>

<hr>
<h2 id='duration'>
Compute Observed Activity Durations or Event Counts for Edges or Vertices
</h2><span id='topic+duration'></span><span id='topic+edgeDuration'></span><span id='topic+vertexDuration'></span>

<h3>Description</h3>

<p>Computes observed activity durations or event counts for edges or vertices, aggregating at the edges, spell, or dyads level.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edgeDuration(nd, mode = c("duration", "counts"), subject = c("edges", "spells", "dyads"),
          e = seq_along(nd$mel), start = NULL, end = NULL, active.default = TRUE)
          
vertexDuration(nd, mode = c("duration", "counts"), subject = c("vertices", "spells"),
     v = seq_len(network.size(nd)), active.default = TRUE)           
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="duration_+3A_nd">nd</code></td>
<td>

<p>networkDynamic object to be evaluated
</p>
</td></tr>
<tr><td><code id="duration_+3A_mode">mode</code></td>
<td>

<p>option determining if the <code>'duration'</code> of the spells should be summed, or simply the <code>'counts'</code> of the number of spells.  The later option is useful when the network contains events of zero duration. 
</p>
</td></tr>
<tr><td><code id="duration_+3A_subject">subject</code></td>
<td>

<p>option describing the unit of analysis that the durations or counts should be aggregated at. <code>'spells'</code> considers each event independently. For <code>tVertexDuration</code>, <code>'vertices'</code> sums all the spells corresponding to a single vertex id.  For <code>edgeDuration</code>, <code>'edges'</code> sums all of the spells corresponding to a single edge id and <code>'dyads'</code> sums all of the spells coresponding to a single (directed) tail-head pair (this means spells from multiplex edges conecting the same vertices will be added together).
</p>
</td></tr>
<tr><td><code id="duration_+3A_e">e</code></td>
<td>

<p>numeric vector of edge ids to consider. 
</p>
</td></tr>
<tr><td><code id="duration_+3A_v">v</code></td>
<td>

<p>numeric vector of vertex ids to consider. 
</p>
</td></tr>
<tr><td><code id="duration_+3A_start">start</code></td>
<td>

<p>optional numeric value to be used to censor onset times. (not yet supported for vertices, must use <code><a href="networkDynamic.html#topic+net.obs.period">net.obs.period</a></code> instead.)
</p>
</td></tr>
<tr><td><code id="duration_+3A_end">end</code></td>
<td>

<p>optional numeric value to be used to censor terminus times. (not yet supported for vertices, must use <code><a href="networkDynamic.html#topic+net.obs.period">net.obs.period</a></code> instead.)
</p>
</td></tr>
<tr><td><code id="duration_+3A_active.default">active.default</code></td>
<td>

<p>logial, should edges or vertices with no timing information be considered always active by default?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function sums the durations of edge or vertex events or,in order to provide a useful metric for networks having zero-duration events, simply counts them.  It is implemented by wrapping a call to <code><a href="networkDynamic.html#topic+as.data.frame.networkDynamic">as.data.frame.networkDynamic</a></code> or <code><a href="networkDynamic.html#topic+get.vertex.activity">get.vertex.activity</a></code>. In many cases the output of the function will be fed to another statistical summary function like <code>summary</code> or <code>hist</code>. The level of aggregation can be selected by setting the subject to either <code>spells</code>, <code>edges</code>, or <code>dyads</code>.
</p>
<p>Note that the 'observed' durations may not match the 'true' (statistically estimated) durations for a network due to the censoring of edges/vertices.
</p>


<h3>Value</h3>

<p>A vector of values corresponding to the selected subjects with the count or duration of events. If the network contains no edges/vertices, <code>numeric(0)</code> will be returned. 
</p>


<h3>Note</h3>

<p>This is an early implementation of the function and its name and arguments are subject to change
</p>


<h3>Author(s)</h3>

<p>skyebend
</p>


<h3>See Also</h3>

<p>See also <code><a href="networkDynamic.html#topic+as.data.frame.networkDynamic">as.data.frame.networkDynamic</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# look at the distributions of edge durations for
# a real-world contact network
## Not run: 
require(networkDynamicData)
data(hospital_contact)
summary(edgeDuration(hospital,subject='edges'))
summary(edgeDuration(hospital,mode='counts',subject='edges'))

## End(Not run)
# look at the vertex durations for a network were 
# vertices are not present every day
require(networkDynamic)
data(windsurfers)
vertexDuration(windsurfers)
</code></pre>

<hr>
<h2 id='formation_and_dissolution'>
Counts or fractions of edge transitions in a networkDynamic object
</h2><span id='topic+tEdgeFormation'></span><span id='topic+tEdgeDissolution'></span>

<h3>Description</h3>

<p>The functions <code>tEdgeFormation</code> and <code>tEdgeDissolution</code> evaluate a network object at multiple time points and return counts (or fractions) of the number of edges forming (edge onset at time point) and dissolving (edge terminus at time point). The counts are returned as numeric vector which is a time-series object (class <code><a href="stats.html#topic+ts">ts</a></code>). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tEdgeFormation(nd, start, end, time.interval = 1, 
               result.type=c('count','fraction'), include.censored=FALSE)

tEdgeDissolution(nd, start, end, time.interval = 1, 
               result.type=c('count','fraction'), include.censored=FALSE)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="formation_and_dissolution_+3A_nd">nd</code></td>
<td>

<p>a <code><a href="networkDynamic.html#topic+networkDynamic">networkDynamic</a></code> object
</p>
</td></tr>
<tr><td><code id="formation_and_dissolution_+3A_start">start</code></td>
<td>

<p>optional numeric time value at which evaluation should start (default is first observed time)
</p>
</td></tr>
<tr><td><code id="formation_and_dissolution_+3A_end">end</code></td>
<td>

<p>optional numeric time value at which evaluation should end (default is last observed time)
</p>
</td></tr>
<tr><td><code id="formation_and_dissolution_+3A_time.interval">time.interval</code></td>
<td>

<p>optional numeric value giving time interval between evaluations (default is 1)
</p>
</td></tr>
<tr><td><code id="formation_and_dissolution_+3A_result.type">result.type</code></td>
<td>
<p> either <code>'count'</code> indicating that results should be returned as counts of tie changes or <code>'fraction'</code> meaning that results should be returned as fraction of ties dissolving (for dissolution) or fraction of empty dyads forming ties (for formation). In the later case the number of dyads is corrected for network directedness, loops, and bipartite partition size. 
</p>
</td></tr>
<tr><td><code id="formation_and_dissolution_+3A_include.censored">include.censored</code></td>
<td>

<p>logical, should ties with truncated/censored onset or termination times be included in the respective formation or dissolution counts?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code>as.data.frame.networkDynamic</code> internally.  TODO: dyad formation rate is not yet corrected for vertex activity, uses the aggregate, not the momentary, network size. 
</p>
<p>When <code>result.type='fraction'</code>:
</p>

<ul>
<li><p> formation returns the ratio of number of  ties forming to the number of possible empty dyads that could have formed ties. So value of 1 would mean all empty dyads formed ties, value of 0 means no ties formed.  In sparse networks, the numbers will tend to be very, very small.    
</p>
</li>
<li><p> dissolution returns the ratio of the number of ties dissolving to the number preexisting ties that could have dissolved. So value of 1 means all ties disolved, 0 means no ties disolved. 
</p>
</li></ul>

<p>When <code>include.censored=FALSE</code> spells of edges which onset outside of the query range will not be included in formation counts. 
</p>


<h3>Value</h3>

<p>For <code>tEdgeFormation</code> and <code>tEdgeDissolution</code>, a numeric vector of class <code>ts</code> giving the formation and dissolution counts (respectively) as a time-series.  For <code>edgeFormationAt</code> and <code>edgeDissolutionsAt</code>, a single numeric value
</p>


<h3>Note</h3>

<p>should add additional args to allow binning other than 'at' for working with non-discrete time, options to deal with how censored edges are calculated.  
</p>


<h3>Author(s)</h3>

<p>skyebend@uw.edu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  library(networkDynamicData)
  data(concurrencyComparisonNets)
  # plot formation and dissolution counts time-series
  plot(tEdgeFormation(base),col='green', 
    main='edge formation and dissolution rates per timestep of base')
  points(tEdgeDissolution(base),col='red',type='l')
  ## Not run: 
  # compute fraction of ties dissolving every 10 steps
  tEdgeDissolution(base,time.interval = 10,result.type = 'fraction')
  # compute fraction of empty dyads forming ties every 10 steps
  tEdgeFormation(base,time.interval = 10,result.type = 'fraction')
  
## End(Not run)
  
</code></pre>

<hr>
<h2 id='moodyContactSim'>
Jim Moody's example dynamic contact simulation network
</h2><span id='topic+moodyContactSim'></span>

<h3>Description</h3>

<p>A <code>networkDynamic</code> object containing the output of a simulation of 1000 timestep simulation of a sex contact network with 16 vertices and 18 edges. Each edge has a single activity spell. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(moodyContactSim)</code></pre>


<h3>Format</h3>

<p>A <code>networkDynamic</code> object.
</p>


<h3>Details</h3>

<p>The object has a <code>net.obs.period</code> attribute describing the observation model. This is a useful network for testing path-based algorithms because it is small enough to visually inspect. 
</p>


<h3>Source</h3>

<p>Figure 5 of James Moody (2008) &quot;Static Representations of Dynamic Networks&quot; Duke Population Research Institute
On-line Working Paper Series. <a href="http://www.soc.duke.edu/~jmoody77/StatDyn_5.pdf">http://www.soc.duke.edu/~jmoody77/StatDyn_5.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(moodyContactSim)
# plot a view of network with edge and vertex labels
plot(moodyContactSim,
     displaylabels=TRUE,
     label.cex=0.8,
     label.pos=5,
     vertex.col='white',
     vertex.cex=2,
     edge.label=sapply(get.edge.activity(moodyContactSim),function(e){
       paste('(',e[,1],'-',e[,2],')',sep='')
     }),
     edge.label.col='blue',
     edge.label.cex=0.8
   )
## Not run: 
# data object was created with
moodyContactSim&lt;-network.initialize(16,directed=FALSE)
tel&lt;-matrix(c(674,701,1,9,
              214,247,1,11,
              621,651,1,12,
              583,615,1,16,
              749,793,11,8,
              719,745,8,13,
              712,739,13,5,
              634,660,13,3,
              769,795,13,7,
              453,479,13,4,
              494,524,13,2,
              224,256,7,10,
              40,72,10,4,
              665,692,4,14,
              709,740,2,15,
              575,599,2,16,
              748,782,4,16,
              701,733,16,6),
            ncol=4,byrow=TRUE)
moodyContactSim&lt;-networkDynamic(moodyContactSim,edge.spells=tel)
obs&lt;-moodyContactSim%n%'net.obs.period'
obs$mode&lt;-'discrete'
obs$time.increment&lt;-1
obs$time.unit&lt;-'step'
obs$observations&lt;-list(c(0,1000))
moodyContactSim%n%'net.obs.period'&lt;-obs

## End(Not run)   
</code></pre>

<hr>
<h2 id='paths'>
Temporally Reachable Paths in a networkDynamic Object
</h2><span id='topic+paths'></span><span id='topic+tPath'></span><span id='topic+temporalPath'></span><span id='topic+is.tPath'></span>

<h3>Description</h3>

<p>Functions to search out the sequence and distances of vertices in a <code>networkDynamic</code> object reachable from an initial vertex by following paths constrained by edge timing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tPath(nd, v, direction=c('fwd','bkwd'), 
                 type=c('earliest.arrive', 'latest.depart'),
                 start, end, active.default = TRUE, graph.step.time = 0)

is.tPath(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="paths_+3A_nd">nd</code></td>
<td>

<p>networkDynamic object to be searched for temporal paths
</p>
</td></tr>
<tr><td><code id="paths_+3A_v">v</code></td>
<td>

<p>integer id of the vertex to be used as the starting point of the search
</p>
</td></tr>
<tr><td><code id="paths_+3A_direction">direction</code></td>
<td>

<p>option indicating the temporal direction in which the network should be searched: <code>'fwd'</code> means search forwards in time and forward along edge directions, <code>'bkwd'</code> means search backwards in time and backwards along edge directions.
</p>
</td></tr>
<tr><td><code id="paths_+3A_type">type</code></td>
<td>

<p>option indicating the type of path (temporal constraint of the path) be searched for:
</p>

<ul>
<li> <p><code>'earliest.arrive'</code> will find the paths that arrive first at the target vertices, 
</p>
</li>
<li> <p><code>'latest.depart'</code> will find the paths that leave the source vertex at the latest possible time.  
</p>
</li></ul>

<p>Additional options will be added as implemented. 
</p>
</td></tr>
<tr><td><code id="paths_+3A_start">start</code></td>
<td>

<p>time at which to begin searching. Edges that terminate before this time will not be considered. If not specified, defaults to earliest time observed on the network according to <code>get.change.times</code>.
</p>
</td></tr>
<tr><td><code id="paths_+3A_end">end</code></td>
<td>

<p>time to end the path search.  Edges that onset on or after this time will not be considered in the path search.
</p>
</td></tr>
<tr><td><code id="paths_+3A_active.default">active.default</code></td>
<td>

<p>Boolean, default TRUE. Should edges with no timing information be considered active by default?
</p>
</td></tr>
<tr><td><code id="paths_+3A_graph.step.time">graph.step.time</code></td>
<td>

<p>numeric.  How much time should be added for each edge traversal (graph hop)? Default is 0, meaning that path distances returned will be purely temporal and will not incorporate graph path distances and 'transmission' can cross multiple edges in a single instant.  A value of 1 would correspond to counting path distances like a traditional centrality score or discrete time simulation.  
</p>
</td></tr>
<tr><td><code id="paths_+3A_x">x</code></td>
<td>
<p>an object to be tested for inheriting the class <code>'tPath'</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <em>temporal path</em> in a dynamic network is a sequence of vertices and edges such that the onset times of successive elements are greater than or equal than those of the previous. In other words, the path is a directed traversal of the network that respects the constraints of edge activity spells and permits 'waiting' at intermediate vertices for 'future' edges to form.
</p>
<p>When set to use <code>direction='fwd'</code> , <code>type='earliest.arrive'</code> <code>tPath</code> performs a time-minimizing Dijkstra's style Depth First Search to find the set of vertices reachable on a <em>forward temporal path</em> from the initial seed vertex <code>v</code> while respecting the constraints of edge timing.The path found is a <em>earliest arriving</em> (in contrast to the <em>earliest leaving</em> or <em>quickest</em> or <em>latest arriving</em> path). When there are multiple equivalent paths only a single one will be arbitrarily returned.   NOTE THAT THE PATH-FINDING ALGORITHM WILL NOT GIVE CORRECT RESULTS IF ANY SPELLS CONTAIN VALUES LESS THAN 0.
</p>
<p>When set to <code>direction='bkwd'</code> and <code>type='latest.depart'</code> the path will be found by searching backwards in time from the <code>end</code> point. In other words, it returns the set of vertices that can reach <code>v</code>, along with latest possible departure times from those vertices.  Note that in this case the elapsed time values returned for <code>tdist</code> will be negative, indicating time measured backwards from the <code>end</code> bound. 
</p>
<p>When set to <code>type='fewest.steps'</code> the path returned will be a 'shortest' (fewest steps/graph hops) time-respecting path.  This would not be necessiairly the quickest or earliest route, but would pass across the fewest possible number of edges (requires the fewest number of transmission steps).   
</p>
<p>The <code>graph.step.time</code> parmeter allows specifying an explicit duration for edge traversals.  In this case the algorithm considers both the onset and terminus times of activity spells to ensure that suffecient time remains for an edge traversal to be made.  If <code>graph.step.time</code> &gt; the remaining duration of an edge's activity spell, the edge is considered non-traverseable. The primary use case for this parameter is to align the paths discovered with those that might be found by a discrete time transmission simulation in which a path can only spread a single graph hop per model timestep. 
</p>
<p>Vertex activity is currently ignored, and it is assumed that once a path reaches a vertex, all future edges from the vertex are accessible.  The path search can be constrained in time using the <code>start</code> and <code>end</code> parameters to bound the time span to be explored by the path search.
</p>
<p><code>'bwkd'</code> <code>'latest.depart'</code> is essentially the inverse of fwd earliest arrive.  It finds the latest time paths backwards from the initial seed vertex. This is the <em>latest-leaving</em> time. Note that the distance returned are positive, but represent the latest distance back in time from the <code>end</code> parameter time at which a vertex can reach <code>v</code>. 
</p>
<p>The <code>is.tPath</code> function checks if an object has the class <code>tPath</code>.
</p>


<h3>Value</h3>

<p>Currently an object of class <code>tPath</code> which is essentially list with several elements providing information on the path found. 
</p>
<table role = "presentation">
<tr><td><code>tdist</code></td>
<td>
<p>A numeric vector with length equal to network size in which each element contains the earliest/latest <em>temporal</em> distance at which the corresponding vertex could reach / be reached from the seed vertex. Values are elapsed time, as measured from the <code>start</code> parameter. Unreachable vertices are marked with <code>Inf</code></p>
</td></tr>
<tr><td><code>previous</code></td>
<td>
<p>A numeric vector with length equal to network size in which each element indicates the previous vertex along (a possible)  reachable path. Can be used to reconstruct the path tree. The initial vertex and unreachable vertices are marked with <code>0</code></p>
</td></tr>
<tr><td><code>gsteps</code></td>
<td>
<p>A numeric vector (of length equal to network size) in which each element indicates the number of steps in the path (number of graph hops) to the vertex along the temporal path found starting at the seed vertex.</p>
</td></tr>
<tr><td><code>start</code></td>
<td>
<p>the numeric start value that was used as the earliest bound for the path calculation (may not have been explicitly set)</p>
</td></tr>
<tr><td><code>end</code></td>
<td>
<p>the numerid end value that was used as the latest bound for the path calculation (may not have been explicitly set)</p>
</td></tr>
<tr><td><code>direction</code></td>
<td>
<p>The direction <code>'fwd'</code> or <code>'bkwd'</code> of the path</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>The type of temporal constraint for the path</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Temporal distances are in terms of time measured from the <code>start</code> parameter, so to recover the model times at which each vertex was reached for forward paths use <code>$tdist+start</code> and backward paths with <code>end- $tdist</code>. This is an early draft of the function, its name and arguments are subject to change before release. 
</p>


<h3>Author(s)</h3>

<p>Skye Bender-deMoll
</p>


<h3>References</h3>

<p>Unpublished discussions with James Moody and Martina Morris and the statnet team.  
</p>
<p>Useful background information (for a slightly different algorithm) can be found in:
B. Bui Xuan, Afonso Ferreira, Aubin Jarry. &quot;Computing shortest, fastest, and foremost journeys
in dynamic networks.&quot; RR-4589, 2002. https://hal.inria.fr/inria-00071996/document
</p>
<p>B. Bui Xuan, Afonso Ferreira, Aubin Jarry. Evolving graphs and least cost journeys in dynamic
networks. WiOpt'03: Modeling and Optimization in Mobile, Ad Hoc and Wireless Networks,
Mar 2003, Sophia Antipolis, France. 10 p., 2003
https://hal.inria.fr/inria-00466676/document
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(networkDynamicData)
data(hospital_contact)
hosPath&lt;-tPath(hospital,v=1)
</code></pre>

<hr>
<h2 id='plotPaths'>
Network Plots a Highlighting Temporal Path(s) .
</h2><span id='topic+plotPaths'></span><span id='topic+plot.tPath'></span>

<h3>Description</h3>

<p>Wrapper for <code><a href="network.html#topic+plot.network">plot.network</a></code> with appropriate defaults to plot a highlighted path, or over-plot highlighted paths on a on top of a static aggregate network plot. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPaths(nd, paths,  path.col = rainbow(length(paths), alpha = 0.5), 
           displaylabels = TRUE, coord=NULL, ...)
           
## S3 method for class 'tPath'
plot(x, edge.col = "red", 
              edge.label.col = edge.col, 
              edge.lwd = 10, 
              edge.label.cex = 0.7, 
              displaylabels = TRUE, 
              displayisolates = FALSE, 
              jitter = FALSE, 
              vertex.lwd = (x$gsteps == 0) * 4 + 1, 
              vertex.cex = (x$gsteps == 0) * 1.5, 
              vertex.col = NA, ...) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotPaths_+3A_nd">nd</code></td>
<td>

<p>a <code>networkDynamic</code> object to be plotted. 
</p>
</td></tr>
<tr><td><code id="plotPaths_+3A_paths">paths</code></td>
<td>

<p>a <code>tPath</code> object containing temporal path (presumably extracted from <code>nd</code>) to be plotted over the network, or a list of paths to be plotted together on the same network.
</p>
</td></tr>
<tr><td><code id="plotPaths_+3A_path.col">path.col</code></td>
<td>

<p>vector of valid colors (possibly transparent) to be used for each path. Default will created semi-transparent colors from the rainbow palette.
</p>
</td></tr> 
<tr><td><code id="plotPaths_+3A_x">x</code></td>
<td>
<p>object (assumed to be <code><a href="#topic+tPath">tPath</a></code>) to be plotted on top of a static aggregate network plot</p>
</td></tr>
<tr><td><code id="plotPaths_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code><a href="network.html#topic+plot.network">plot.network</a></code> and <code><a href="#topic+plot.tPath">plot.tPath</a></code>.
</p>
</td></tr>
<tr><td><code id="plotPaths_+3A_coord">coord</code></td>
<td>
<p>optional numeric matrix of coordinates for positioning vertices. See <code><a href="network.html#topic+plot.network">plot.network</a></code></p>
</td></tr>
<tr><td><code id="plotPaths_+3A_edge.col">edge.col</code></td>
<td>
<p>color for drawing edges (paths). See <code><a href="network.html#topic+plot.network">plot.network</a></code></p>
</td></tr>
<tr><td><code id="plotPaths_+3A_edge.label.col">edge.label.col</code></td>
<td>
<p>color for edge labels. Default to same color as edges. See <code><a href="network.html#topic+plot.network">plot.network</a></code></p>
</td></tr> 
<tr><td><code id="plotPaths_+3A_edge.lwd">edge.lwd</code></td>
<td>
<p>numeric expansion factor for edge line widths. See <code><a href="network.html#topic+plot.network">plot.network</a></code></p>
</td></tr>
<tr><td><code id="plotPaths_+3A_edge.label.cex">edge.label.cex</code></td>
<td>
<p>numeric expansion factor for edge labels. See <code><a href="network.html#topic+plot.network">plot.network</a></code></p>
</td></tr> 
<tr><td><code id="plotPaths_+3A_displaylabels">displaylabels</code></td>
<td>
<p>logical, should vertex labels be included on the plot? See <code><a href="network.html#topic+plot.network">plot.network</a></code></p>
</td></tr> 
<tr><td><code id="plotPaths_+3A_displayisolates">displayisolates</code></td>
<td>
<p>logical, should isolated vertices be included in the plot? See <code><a href="network.html#topic+plot.network">plot.network</a></code></p>
</td></tr> 
<tr><td><code id="plotPaths_+3A_jitter">jitter</code></td>
<td>
<p>adds random noise to positions (disabled by default) See <code><a href="network.html#topic+plot.network">plot.network</a></code></p>
</td></tr>
<tr><td><code id="plotPaths_+3A_vertex.lwd">vertex.lwd</code></td>
<td>
<p>Vertex border line with. See <code><a href="network.html#topic+plot.network">plot.network</a></code></p>
</td></tr> 
<tr><td><code id="plotPaths_+3A_vertex.cex">vertex.cex</code></td>
<td>
<p>Vertex expansion factor. Default is to scale up the origin vertex for the path, and not draw the other vertices. See <code><a href="network.html#topic+plot.network">plot.network</a></code></p>
</td></tr> 
<tr><td><code id="plotPaths_+3A_vertex.col">vertex.col</code></td>
<td>
<p>Color for vertices. Default is to leave them un-colored. See <code><a href="network.html#topic+plot.network">plot.network</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plotPaths</code> plots the <code>networkDynamic</code> object using the normal <code>plot.network</code> function and <code>...</code> arguments.  Then calls <code><a href="#topic+plot.tPath">plot.tPath</a></code> for each <code><a href="#topic+tPath">tPath</a></code> object in <code>paths</code> to over-plot the edges of path onto the network plot using the corresponding <code>path.col</code> color.  Use of semi-transparent colors can help (somewhat) improve readability when paths overlap on the same edges.  
</p>
<p><code>plot.tPath</code> plots the path information encoded in a single <code><a href="#topic+tPath">tPath</a></code> object.  It first creates a network using <code><a href="#topic+as.network.tPath">as.network.tPath</a></code> and then calls <code><a href="network.html#topic+plot.network">plot.network</a></code>  with suitable defaults for drawing (or over-drawing) the path (doesn't display isolated vertices, draws times as edge labels, draws a color around the source vertex, etc. )
</p>


<h3>Value</h3>

<p>Generates a network plot with a highlighted path, invisibly returns the plot coordinates. 
</p>


<h3>Author(s)</h3>

<p>skyebend
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+tPath">tPath</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(moodyContactSim)
v10path&lt;-tPath(moodyContactSim,v=10,start=0)
# plot just the path from v10
plot(v10path)

# plot the path from v10 on top of the network
plotPaths(moodyContactSim,v10path)

# plot the paths from both v10 and v1
v1path&lt;-tPath(moodyContactSim,v=1,start=0)
plotPaths(moodyContactSim,list(v10path,v1path))

# if ndtv package is installed, along with Graphviz system library,
# nice hierarchical trees can be drawn
## Not run: 
plot(v10path,
     coord=network.layout.animate.Graphviz(
                   as.network(v10path),
                   layout.par = list(gv.engine='dot')
            ),
            jitter=FALSE
    )

## End(Not run)

</code></pre>

<hr>
<h2 id='pShiftCount'>
Compute Counts of Gibson's Participation Shifts
</h2><span id='topic+pShiftCount'></span>

<h3>Description</h3>

<p>Uses the <code>relevent</code> package to compute counts of dyadic turn-taking events using a typology outlined by Gibson (2003)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pShiftCount(nd, start = NULL, end = NULL, output = c("final", "full"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pShiftCount_+3A_nd">nd</code></td>
<td>

<p><code>networkDynamic</code> object to be evaluated
</p>
</td></tr>
<tr><td><code id="pShiftCount_+3A_start">start</code></td>
<td>

<p>numeric initial time point to start evaluation from
</p>
</td></tr>
<tr><td><code id="pShiftCount_+3A_end">end</code></td>
<td>

<p>numeric ending time point to finish evaluation
</p>
</td></tr>
<tr><td><code id="pShiftCount_+3A_output">output</code></td>
<td>

<p>chracter value indicating if only the <code>'final'</code> counts should be reported, or the <code>'full'</code> matrix with updated counts for each event. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses the <code>accum.ps</code> function in the package <code>relevent</code> to build counts of accumulated dyad participation shifts (turn-taking changes) using the dynamic information on tie changes represented in a directed <code>networkDynamic</code> object.   The P-shifts are given in the order used in Gibson's 2003 Social Forces paper, namely:
</p>

<ul>
<li> 
<p>Turn Receiving:
</p>
<ul>
<li><p> [1] AB-&gt;BA  (Alex talks to Brett, then Brett replies)
</p>
</li>
<li><p> [2] AB-&gt;B0  (Alex talks to Brett, then Brett addresses the group)
</p>
</li>
<li><p> [3] AB-&gt;BY  (Alex talks to Brett, then Brett talks to Yuki)
</p>
</li></ul>

</li>
<li> 
<p>Turn Claiming:
</p>
<ul>
<li><p> [4] A0-&gt;X0  (Alex talks to the group, then Xuan talks to the group)
</p>
</li>
<li><p> [5] A0-&gt;XA  (Alex talks to the group, then Xuan talks to Alex)
</p>
</li>
<li><p> [6] A0-&gt;XY  (Alex talks to the group, then Xuan talks to Yuki)
</p>
</li></ul>

</li>
<li> 
<p>Turn Usurping:
</p>
<ul>
<li><p> [7] AB-&gt;X0  (Alex talks to Brett, then Xuan talks to the group)
</p>
</li>
<li><p> [8] AB-&gt;XA  (Alex talks to Brett, then Xuan talks to Alex)
</p>
</li>
<li><p> [9] AB-&gt;XB  (Alex talks to Brett, then Xuan talks to Brett)
</p>
</li>
<li><p> [10] AB-&gt;XY (Alex talks to Brett, then Xuan talks to Yuki)
</p>
</li></ul>

</li>
<li> 
<p>Turn Continuing:
</p>
<ul>
<li><p> [11] A0-&gt;AY (Alex talks to the group, then addresses Yuki)
</p>
</li>
<li><p> [12] AB-&gt;A0 (Alex talks to Brett, then makes remark to the group)
</p>
</li>
<li><p> [13] AB-&gt;AY (Alex talks to Brett, then to Yuki)
</p>
</li></ul>

</li></ul>

<p>This uses Gibson's notation, in which A is the initial source, B is the
initial target, X is a new (shifted) speaker, Y is a new (shifted) target,
and 0 is used where no well-defined speaker or target is present.  (Here, this
would occurs when NA is given for source or destination, not currently supported)
</p>
<p>It is worth noting that not all adjacent event pairs induce P-shifts, and hence
the shift counts will not increment with every event.  In particular, the first
event does not induce a shift (since there is no prior event), and neither does
a repetition of a previous event (e.g., AB-&gt;AB or A0-&gt;A0).  The full set is
thus affinely independent in general, although they will have a near (or 
even full) dimension of affine dependence on most data sets.
</p>
<p>Event order is determined by sorting the network's edge spells by on the onset time of edge and then by the terminus.  Gibson's typology assumes that edges/ties directed 'at the group' are distinguishable those directed at individuals, and has a strong assumption of sequential non-simultaneous events. Because the <code>networkDynamic</code> object does not explicitly clode for 'group' utterences, simultaneous edges originating from a speaker (same onset,terminus, and tail vertex) are assumed to be directed at the group, even if not all group members are reached by the ties.  
</p>


<h3>Value</h3>

<p>For <code>output='final'</code> (the default), the output is a matrix with one row containing counts for each of the 13 P-shift types accumulated over the time period requested. For <code>ouptut='full'</code>, the output is a data.frame with rows corresponding to each edge spell event. The first 13 rows are the counts of P-shift types, and the remaining four rows are the 'onset', 'terminus', 'tail', 'head', and a 'group' column indicating if the event was considered as a group-directed. 
</p>


<h3>Author(s)</h3>

<p>Carter Butts buttsc@uci.edu, Skye Bender-deMoll skyebend@uw.edu
</p>


<h3>References</h3>

<p>Gibson, D.R. (2003) 'Participation Shifts: Order and Differentiation in Group Conversation'  
Social Forces  81 (4): 1335-1380 <code>https://doi.org/10.1353/sof.2003.0055</code>
</p>
<p>Carter T. Butts (2008). A Relational Event Framework for Social Action. Sociological Methodology, 38(1), 155&ndash;200.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(McFarland_cls33_10_16_96)
pShiftCount(cls33_10_16_96)

</code></pre>

<hr>
<h2 id='reachable'>
Find the set of vertices reachable from a given set using only paths moving forward in time
</h2><span id='topic+forward.reachable'></span>

<h3>Description</h3>

<p>Does a breadth-first search from the specified set of vertices, respecting the direction and timing of edges. TODO: vertex activity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forward.reachable(nd, v, start = NULL, end = NULL, per.step.depth = Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reachable_+3A_nd">nd</code></td>
<td>

<p>a <code>network</code> (usually a <code>networkDynamic</code>) object
</p>
</td></tr>
<tr><td><code id="reachable_+3A_v">v</code></td>
<td>

<p>numeric vector giving the set of initial vertex.ids to start from
</p>
</td></tr>
<tr><td><code id="reachable_+3A_start">start</code></td>
<td>

<p>The beginning of the time range to start from 
</p>
</td></tr>
<tr><td><code id="reachable_+3A_end">end</code></td>
<td>

<p>End of the time range to search to
</p>
</td></tr>
<tr><td><code id="reachable_+3A_per.step.depth">per.step.depth</code></td>
<td>

<p>How many steps (default=1) to search per unit of time.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default value of <code>per.step.depth=Inf</code> is equivilent to assuming that the &lsquo;process&rsquo; takes no time to travel along vertices
</p>


<h3>Value</h3>

<p>A numeric vector of vertex.ids reachable from the initial set of vertex.id by &lsquo;traveling&rsquo; forward in time along active vertices and edges subject to bounding paramters.
</p>


<h3>Note</h3>

<p>This is a pure R implementation, probably very slow.
</p>
<p>This function could be ill-defined when using non-Inf <code>per.step.depth</code> with networks with instantaneous (onset=terminus) spells as it will treat elements active at time t as active until the next change in the network. 
</p>
<p>TODO:  should be able to specifiy edge weight attribute to be included in time calcualtions. 
</p>


<h3>Author(s)</h3>

<p>skyebend
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+tPath">tPath</a></code> for a dramatically faster implementation
</p>

<hr>
<h2 id='tDegree'>
Report momentary degree of a networkDynamic object at multiple timepoints
</h2><span id='topic+tDegree'></span>

<h3>Description</h3>

<p>Calculates the degree of vertices at a sequence of time points over a network's temporal evolution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tDegree(nd, start, end, time.interval = 1, cmode = c("freeman", "indegree", "outdegree"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tDegree_+3A_nd">nd</code></td>
<td>

<p>the <code><a href="networkDynamic.html#topic+networkDynamic">networkDynamic</a></code> object to be evaluated
</p>
</td></tr>
<tr><td><code id="tDegree_+3A_start">start</code></td>
<td>

<p>optional numeric time value at which evaluation should start (default is first observed time)
</p>
</td></tr>
<tr><td><code id="tDegree_+3A_end">end</code></td>
<td>

<p>optional numeric time value at which evaluation should end (default is last observed time)
</p>
</td></tr>
<tr><td><code id="tDegree_+3A_time.interval">time.interval</code></td>
<td>

<p>optional numeric value giving time interval between evaluations (default is 1)
</p>
</td></tr>
<tr><td><code id="tDegree_+3A_cmode">cmode</code></td>
<td>

<p>mode for evaluating degree.  one of  <code>"freeman", "indegree", "outdegree"</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Evaluates the momentary degrees of a network at multiple time points and returns results in a form suitable for sumarizing the distributions. If a vertex is not active at a time point, its degree will be recorded as <code>NA</code>.
</p>


<h3>Value</h3>

<p>A <code><a href="stats.html#topic+ts">ts</a></code> (time series) object, a numeric matrix with giving the momentary degree of each vertex at each time point. Columns coresponding to each vertex in the input network and row corresponding to each time point at which degree was evaluated.
</p>


<h3>Author(s)</h3>

<p>skyebend
</p>


<h3>See Also</h3>

<p>See also <code>tSnaStats(nd,'degree')</code> and <code>tErgmStats(nd,'sociality')</code> for alternate ways to compute degree using external packages. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(McFarland_cls33_10_16_96)
tDegree(cls33_10_16_96)
# compute mean temporal degree
mean(tDegree(cls33_10_16_96),na.rm=TRUE)
## Not run: 
library(networkDynamicData)
data(concurrencyComparisonNets)
# compute mean for each network, sampled at 11 time points
mean(colMeans(tDegree(base,start = 0,end=102,time.interval = 10)))
mean(colMeans(tDegree(middle,start = 0,end=102,time.interval = 10)))
mean(colMeans(tDegree(monog,start = 0,end=102,time.interval = 10)))

# plot distribution of vertices' mean momentary degree
hist(rowMeans(tDegree(base,start = 0,end=102,time.interval = 10)))

# plot distribution of momentary degrees of vertices
hist(tDegree(base,start = 0,end=102,time.interval = 10))

## End(Not run)

</code></pre>

<hr>
<h2 id='temporal+20density'>
Functions to compute temporal density-related measures on dynamic networks
</h2><span id='topic+tEdgeDensity'></span>

<h3>Description</h3>

<p>These functions provide various network-level statistics giving information on the fraction of time edges are active in <code>networkDynamic</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tEdgeDensity(nd,mode=c('duration','event'),
              agg.unit=c('edge','dyad'),active.default=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="temporal+2B20density_+3A_nd">nd</code></td>
<td>

<p>a <code><a href="networkDynamic.html#topic+networkDynamic">networkDynamic</a></code> object to evaluate density on
</p>
</td></tr>
<tr><td><code id="temporal+2B20density_+3A_mode">mode</code></td>
<td>

<p>option indicating if <code>'duration'</code> of edge spells should be considered or only the <code>'event'</code> count (for networks in which events have zero-durations)
</p>
</td></tr>
<tr><td><code id="temporal+2B20density_+3A_agg.unit">agg.unit</code></td>
<td>

<p>option indicating how to calculate the possible observable time to be used as the denominator: <code>'edge'</code> only counts existing edges <code>'dyad'</code> counts all possible dyads. 
</p>
</td></tr>
<tr><td><code id="temporal+2B20density_+3A_active.default">active.default</code></td>
<td>

<p>logical, default TRUE.  should edges without explicit timing information be considered active by default?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>tEdgeDensity</code> measure by default (<code>mode='duration', agg.unit='edge'</code>) computes the total duration of activity of all the edges in the network and divides by the total amount of observable time for all the dyads <em>between which edges are ever observed</em>. Can be interpreted as the average fraction of observed edges active at any time. A value of 1 corresponds to a network in which all of the observed edges are always active (but the network still may be topologically sparse, having a low density)
</p>
<p>The <code>tEdgeDensity</code> function with <code>mode='event'</code> computes the number of events (spells) occurring on each edge the network and divides it by the total amount of observable time per dyad ever observed to have an edge within the time bounds of the network.  Can be interpreted as the fraction of existing ties toggling in a unit time step?
</p>
<p>The <code>agg.unit='dyad'</code> measure computes the total duration (or count of events) of activity of all the edges in the network, and divides by the total amount of observable time for all the <em>possible dyads</em> (existing and non-existing edges). Value of 1 corresponds to a fully-connected network in which all edges are always active, value of 0 would be a network with no active edges. Can be interpreted as the average fraction of possible edges active at any time. 
</p>
<p>For networks with instantaneous spells, the event measures would be used in preference to the duration measures, as all of the events will have zero durations. 
</p>
<p>Note that all of these measures depend on having an accurate value for the temporal bounds of the network.  If a <code>net.obs.period</code> exists, it will determine the range of observations.  If it does not exist, the range will be the (non-Inf) range of earliest and latest events found on the network by <code>get.change.times</code>. If no non-Inf range exists (presumably because all ties are always active or always inactive), the range (0-1) will be used. 
</p>
<p>For sensible results on discrete networks, the measures are effectively making the assumption that the time increment is 1. TODO: read time increment from net.obs.period if it exits?
</p>
<p>Networks with no edges or vertices will return 0, although they are technically undefined. 
</p>
<p>Behavior with multiplex ties? dyad measures could range above 1, edge measures will re-normalize.
</p>


<h3>Value</h3>

<p>A numeric value representing the network-level measure of the density metric applied
</p>


<h3>Note</h3>

<p>These are experimental functions, names and arguments still subject to change.  Should these be collapsed to a single measure with multiple arguments?
</p>


<h3>Author(s)</h3>

<p>skyebend
</p>


<h3>References</h3>

<p>none yet
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(networkDynamicData)
data(hospital_contact)
tEdgeDensity(hospital)

## End(Not run)
</code></pre>

<hr>
<h2 id='tErgmStats'>
Calculate network summary statistics at multiple time points
</h2><span id='topic+tErgmStats'></span>

<h3>Description</h3>

<p>Applies a ergm-style formula of network statistics to cross-sectional networks collapsed from a networkDynamic at multiple time points to construct a matrix of values describing the change in statistics over time. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tErgmStats(nd, formula, start, end, time.interval = 1, aggregate.dur, rule)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tErgmStats_+3A_nd">nd</code></td>
<td>

<p><code><a href="networkDynamic.html#topic+networkDynamic">networkDynamic</a></code> object to be evaluated
</p>
</td></tr>
<tr><td><code id="tErgmStats_+3A_formula">formula</code></td>
<td>

<p>a character string providing an ergm term name or the 'right hand side' of an ergm formula. For example <code>'~ edges + concurrent'</code>
</p>
</td></tr>
<tr><td><code id="tErgmStats_+3A_start">start</code></td>
<td>

<p>optional numeric time value at which evaluation should start (default is first observed time)
</p>
</td></tr>
<tr><td><code id="tErgmStats_+3A_end">end</code></td>
<td>

<p>optional numeric time value at which evaluation should end (default is last observed time)
</p>
</td></tr>
<tr><td><code id="tErgmStats_+3A_time.interval">time.interval</code></td>
<td>

<p>optional numeric value giving time interval between evaluations (default is 1)
</p>
</td></tr>
<tr><td><code id="tErgmStats_+3A_aggregate.dur">aggregate.dur</code></td>
<td>

<p>optional numeric value giving the duration of time bin to aggregate over for each evaluation (default 0). See <code><a href="networkDynamic.html#topic+network.collapse">network.collapse</a></code>
</p>
</td></tr>
<tr><td><code id="tErgmStats_+3A_rule">rule</code></td>
<td>

<p>character vector describing rule to be used if multiple attribute values are encountred when using non-zero <code>aggregate.dur</code>. Default is <code>latest</code>. See <code><a href="networkDynamic.html#topic+network.collapse">network.collapse</a></code> for details
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Constructs a set of times to evaluate based on <code>start</code>,<code>end</code> and <code>time.interval</code>. Extracts a static network at each time point and uses it to construct a formula with <code>f</code>. The formula is passed to ergm's <code><a href="ergm.html#topic+summary_formula">summary_formula</a></code> function to calculate the net value of the change statistics for each term in the formula.  The values of the statistics are grouped into a time-series object (class <code><a href="stats.html#topic+ts">ts</a></code>). The ts object can be thought of as a matrix such that each column is a formula term and each row is the time point at which the statistics were evaluated. See <code><a href="ergm.html#topic+ergm-terms">ergm-terms</a></code> for a list of available term statistics.  The <code>aggregate.dur</code> can be used to specifiy the duration of the aggregation bin, especially useful when working with continuous time networks.  Usually the <code>time.interval</code> would be set to the same value to ensure non-overlapping bins. 
</p>
<p>Be aware that if the network's vertex activity dynamics imply cross-sectional networks of different sizes, the interpretation of the statistic at each time point may not be the same.  
</p>


<h3>Value</h3>

<p>A time-series (<code><a href="stats.html#topic+ts">ts</a></code>) object containing term statistics in which each column corresponds to a statistic and each row is the time point at which the statistic was evaluated
</p>


<h3>Author(s)</h3>

<p>skyebend@uw.edu
</p>


<h3>See Also</h3>

<p>See also <code><a href="ergm.html#topic+summary_formula">summary_formula</a></code> and <code><a href="ergm.html#topic+ergm-terms">ergm-terms</a></code>. For more information about time-series objects, see <code><a href="stats.html#topic+ts">ts</a></code> and <code><a href="stats.html#topic+plot.ts">plot.ts</a></code> for plotting quickly plotting timelines for multiple statistics.  The <code>summary_formula.networkDynamic</code> function in the <code>tergm</code> package offers very similar functionality.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
 data(windsurfers)
 tErgmStats(windsurfers,'~edges+degree(c(1,2))')
 library(networkDynamicData)
 data(concurrencyComparisonNets)
 tErgmStats(base,'~edges+concurrent',
               start=0,end=100,time.interval = 10)
 # show as multiple plots
 plot(
   tErgmStats(base,'~edges+concurrent',
                start=0,end=100,time.interval = 10),
                
                )
  
## End(Not run)

 
</code></pre>

<hr>
<h2 id='tiedDuration'>
Compute the duration of time (or count of events) that each vertex is tied/connected to others by an edge
</h2><span id='topic+tiedDuration'></span>

<h3>Description</h3>

<p>Computes the total duration that each vertex in the network is tied to other vertices by incident edges.  Alternately, if <code>mode="counts"</code>, computes the total number of incident edge spells each vertex is tied by.  The later is especially useful for continuous time networks tied by edges with 0-duration events. For directed networks, the durations can be filtered using the <code>neighborhood</code> argument to include only incoming, outgoing, or all ties combined in order to return out-tiedor in-tied durations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tiedDuration(nd, mode = c("duration", "counts"), 
                     active.default = TRUE, 
                     neighborhood = c("out", "in", "combined"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tiedDuration_+3A_nd">nd</code></td>
<td>

<p>a <code><a href="networkDynamic.html#topic+networkDynamic">networkDynamic</a></code> object describing the network for which durations should be calculated
</p>
</td></tr>
<tr><td><code id="tiedDuration_+3A_mode">mode</code></td>
<td>

<p>either <code>"duration"</code> or <code>"count"</code> indicating if the sum of edge durations or the count of the number of edge events should be returned
</p>
</td></tr>
<tr><td><code id="tiedDuration_+3A_active.default">active.default</code></td>
<td>

<p>logical, should edges with no defined activity spells be considered active by default?
</p>
</td></tr>
<tr><td><code id="tiedDuration_+3A_neighborhood">neighborhood</code></td>
<td>

<p>value of <code>"out"</code>, <code>"in"</code> or <code>"combined"</code> indicating if &ndash; for directed networks &ndash; the durations (counts) should be limited to the vertices' ties outgoing, incoming, or combined (both).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implemented internally using the <code><a href="networkDynamic.html#topic+as.data.frame.networkDynamic">as.data.frame.networkDynamic</a></code> function and so follows the same truncation conventions for handling censored edges (edges that are active before or after the observation window of the network)
</p>


<h3>Value</h3>

<p>a numeric vector of length equal to the number of vertices in the network with a value equal to the sum of durations (or counts) of active edges incident upon the vertex. 
</p>


<h3>Note</h3>

<p>Should the default neighborhood for directed network be 'combined'?
</p>


<h3>Author(s)</h3>

<p>skyebend@uw.edu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(moodyContactSim)
  tiedDuration(moodyContactSim)
  
  data(McFarland_cls33_10_16_96)
  # compute ratio of incoming vs. outgoing speach acts
  outDur &lt;- tiedDuration(cls33_10_16_96, mode='counts',neighborhood = 'out') 
  inDur &lt;- tiedDuration(cls33_10_16_96, mode='counts',neighborhood = 'in')
  outDur / inDur
</code></pre>

<hr>
<h2 id='timeProjectedNetwork'>
Construct a time-projected (&quot;multi-slice&quot;) network by binning a networkDynamic object
</h2><span id='topic+timeProjectedNetwork'></span>

<h3>Description</h3>

<p>Builds a new static representation of a dynamic network constructed by binning the dynamic network into static slices and constructing new directed 'identity-arcs' between the vertices' realizations in successive time slices. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timeProjectedNetwork(nd, start = NULL, end = NULL, 
                        time.increment = NULL, onsets = NULL, termini = NULL, 
                        ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="timeProjectedNetwork_+3A_nd">nd</code></td>
<td>

<p>the <code><a href="networkDynamic.html#topic+networkDynamic">networkDynamic</a></code> object for which the time projected network should be constructed
</p>
</td></tr>
<tr><td><code id="timeProjectedNetwork_+3A_start">start</code></td>
<td>

<p>optional numeric start time to be use as lower bound for binning interval (default is what is observed in network)
</p>
</td></tr>
<tr><td><code id="timeProjectedNetwork_+3A_end">end</code></td>
<td>

<p>optional numeric end time to be use as upper bound for binning interval (default is what is observed in network)
</p>
</td></tr>
<tr><td><code id="timeProjectedNetwork_+3A_time.increment">time.increment</code></td>
<td>

<p>value for the offset (and duration) between successive samples. Will default to 1 if not otherwise specified
</p>
</td></tr>
<tr><td><code id="timeProjectedNetwork_+3A_onsets">onsets</code></td>
<td>

<p>A numeric vector containing the onset times of the networks to be extracted. This must be accompanied by <code>termini</code> of the same length.
</p>
</td></tr>
<tr><td><code id="timeProjectedNetwork_+3A_termini">termini</code></td>
<td>

<p>A numeric vector containing the terminus times of the networks to be extracted. This must be accompanied by <code>onsets</code> of the same length.
</p>
</td></tr>
<tr><td><code id="timeProjectedNetwork_+3A_...">...</code></td>
<td>

<p>Additional arguments to <code><a href="networkDynamic.html#topic+network.collapse">network.collapse</a></code> (such as <code>rule</code>,<code>active.default</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code><a href="networkDynamic.html#topic+network.collapse">network.collapse</a></code> to bin the <code>nd</code> network into a list of static networks, aggregates them into a new network with size equal to original network size X number of slices.  To assist with plotting, an edge attribute <code>edge.type</code> is added to all of the edges, having the value <code>'within_slice'</code> for edges existing the the original network and <code>'identity_arc'</code> for edges linking the vertices in time.  Vertex attributes (possibly collapsed TEAs) are copied from the original network to the projected network.  Because of the assumed directionality of time, the output network will always be directed, with the identity arcs pointing forward in time.  If the input network is undirected, two corresponding directed edges (one in each direction) will be added in the projected network. Edge attributes (possibly collapsed TEAs) will be copied from the original network to the corresponding  within-slice edges in the projected network.   
</p>
<p>Vertex activity is currently ignored in the projected network (<code>retain.all.vertices</code> is set to TRUE internally to force all time slice networks to have the same size).
</p>
<p>As with all discrete representations of dynamic processes, the time projected graph is an approximation and may over- or under-represent some transmission potential depending on the choice of bin size. Binning is performed by <code><a href="networkDynamic.html#topic+get.networks">get.networks</a></code>, so will use its defaults if not specified.
</p>


<h3>Value</h3>

<p>a <code><a href="network.html#topic+network">network</a></code> object that encodes a discrete time representation of the temporal evolution of the input <code><a href="networkDynamic.html#topic+networkDynamic">networkDynamic</a></code> object. 
</p>


<h3>Author(s)</h3>

<p>Skye Bender-deMoll (skyebend@uw.edu), James Moody
</p>


<h3>References</h3>

 
<p>James Moody (2015) Static Representations of Dynamic Networks (DRAFT)
</p>
<p>Earlier citations?
</p>


<h3>See Also</h3>

<p><code><a href="networkDynamic.html#topic+network.collapse">network.collapse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(moodyContactSim)


# use slices at each changing time point
library(networkDynamicData)
data(vanDeBunt_students)
times&lt;-get.change.times(vanDeBunt_students)
vanDProj&lt;-timeProjectedNetwork(vanDeBunt_students,onsets = times,termini = times)
# plot it with gray for the time edges
plot(vanDProj,
    arrowhead.cex = 0,
     edge.col=ifelse(vanDProj%e%'edge.type'=='within_slice','black','gray'),
     vertex.cex=0.7,mode='kamadakawai')
## Not run: 

# compute shortest temporal path distances from each vertex in first slice
# to each vertex in last slice
library(sna)
geodist(vanDProj)$gdist[1:32,193:224]

# bin the moody sim into 100 timestep chunks
# (this will over-represent some transmission potential)
moodyProj&lt;-timeProjectedNetwork(moodyContactSim,time.increment=100)
plot(moodyProj,arrowhead.cex = 0,
    edge.col=ifelse(moodyProj%e%'edge.type'=='within_slice','black','gray'),
    vertex.cex=0.7,displaylabels = TRUE,label.cex=0.6)

## End(Not run)    
    
</code></pre>

<hr>
<h2 id='tReach'>
computes sizes of temporally reachable sets in a dynamicNetwork
</h2><span id='topic+tReach'></span>

<h3>Description</h3>

<p>computes sizes of temporally reachable sets in a dynamicNetwork, using either a full census or sample of starting vertices of the specified size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tReach(nd, direction = c("fwd","bkwd"), sample=network.size(nd),
      start, end,  graph.step.time=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tReach_+3A_nd">nd</code></td>
<td>

<p>a networkDynamic object
</p>
</td></tr>
<tr><td><code id="tReach_+3A_direction">direction</code></td>
<td>

<p>currently only <code>'fwd'</code> works, to calculate the sizes forward-reachable sets (as opposed to backwards-reachable)
</p>
</td></tr>
<tr><td><code id="tReach_+3A_sample">sample</code></td>
<td>

<p>numeric, indicates the size of the sample of vertices to use to calculate the reachable sets
</p>
</td></tr>
<tr><td><code id="tReach_+3A_start">start</code></td>
<td>
<p>optional numeric start time to begin path search</p>
</td></tr>
<tr><td><code id="tReach_+3A_end">end</code></td>
<td>
<p>optional numeric time to end path search </p>
</td></tr>
<tr><td><code id="tReach_+3A_graph.step.time">graph.step.time</code></td>
<td>
<p>How much time should be added for each edge traversal (graph hop)? See <code><a href="#topic+tPath">tPath</a></code> for details.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p><code>tReach</code> calls <code>link{tPath}</code> on with each starting vertex to determine the sizes of the sets of vertices that are reachable. If <code>sample</code> is set to something less than the size of the network, it will sample that many vertices instead of doing the (expensive) full census.  Note that when the vertices are chosen as a sample, results may vary between calls to this function
</p>


<h3>Value</h3>

<p>a vector of length equal to <code>sample</code> giving the sizes of the set of vertices reachable from each seed vertex within the specified time bounds
</p>


<h3>Note</h3>

<p>Needs implementation of backwards sets
</p>


<h3>Author(s)</h3>

<p>skyebend
</p>


<h3>See Also</h3>

<p>See also as <code><a href="#topic+tPath">tPath</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(moodyContactSim)
tReach(moodyContactSim)

# only sample 3 paths
tReach(moodyContactSim,sample=3)

# what fraction of the network could each vertex reach?
tReach(moodyContactSim)/network.size(moodyContactSim)

# what fraction of the network could each vertex be reached by?
tReach(moodyContactSim,direction='bkwd')/network.size(moodyContactSim)
</code></pre>

<hr>
<h2 id='tsna'>
Tools for Temporal Social Network Analysis
</h2><span id='topic+tsna'></span>

<h3>Description</h3>

<p>Temporal SNA tools for continuous- and discrete-time longitudinal networks. having vertex, edge, and attribute dynamics stored in the networkDynamic format. This work was supported by grant R01HD68395 from the National Institute of Health.
</p>


<h3>Details</h3>

<p>This package provides tools for working with longitudinal network data in <code><a href="networkDynamic.html#topic+networkDynamic-package">networkDynamic-package</a></code> format. This data structure is essentially a list in the <code><a href="network.html#topic+network">network</a></code> format in which elements also have an attached <code><a href="networkDynamic.html#topic+activity.attribute">activity.attribute</a></code>, a matrix of spells indicating when vertex or edge is active.  The networkDynamic package provides tools (<code><a href="networkDynamic.html#topic+networkDynamic">networkDynamic</a></code>) for translating longitudinal data from various formats (timed edge lists, lists of toggles, sets of matrices, etc).
</p>
<p>Currently the package consists of several groups of functions
</p>

<ul>
<li><p>wrappers for 'static' social network analysis metrics and apply them at multiple time points
</p>
</li>
<li><p>functions that construct or use temporal paths through networks 
</p>
</li>
<li><p>basic tools for measuring durations of ties, rates of change, etc 
</p>
</li>
<li><p>utility functions for plotting, etc 
</p>
</li></ul>

<p>The sections below provide some additional details.  The package vignette (<code>browseVignettes(package='tsna')</code>) gives additional examples and illustrations of key concepts.
</p>
<p>It is the intention that, like the <code>networkDynamic</code> package, tsna should support both continuous time and discrete time representations of networks.  However, we are prioritizing development of discrete time measures suitable for use with simulation data (i.e. <code>stergm</code> models) so many of the functions are still missing the necessary arguments to facilitate binning. 
</p>


<h3>Standard 'static' Sna metrics</h3>

<p>These functions operate by collapsing the dynamic network into a static network at a series of regular intervals and returning the results as a time series <code><a href="stats.html#topic+ts">ts</a></code> object. They can provide general description of trends in a network dataset.  Generally assumes that vertex set is not substantially changing. 
</p>

<ul>
<li> <p><code><a href="#topic+tErgmStats">tErgmStats</a></code> &ndash; descriptive stats (ergm terms) from the <code>ergm</code> package
</p>
</li>
<li> <p><code><a href="#topic+tSnaStats">tSnaStats</a></code> &ndash; descriptive stats from the <code>sna</code> package. Both graph- and vertex-level measures.  centralities, components, reciprocity, betweenness, triad-census, etc. 
</p>
</li></ul>



<h3>Temporal path based metrics</h3>

<p>These functions compute and use temporal paths (network geodesics that are constrained by the activity times of edges) through a network. 
</p>

<ul>
<li> <p><code><a href="#topic+tPath">tPath</a></code>
</p>
</li>
<li> <p><code><a href="#topic+tReach">tReach</a></code>
</p>
</li></ul>



<h3>Rates and Duration</h3>

<p>These functions can be used to compute distributions of (observed) activity durations in a data structure. Note that due to censoring (edges that begin before or end after the time observation window for the network) the observed durations may be biased away from the 'real' values (or model parameters).  The duration estimate functions use various types of survival analysis to return estimates of these values.  
</p>

<ul>
<li> <p><code><a href="#topic+edgeDuration">edgeDuration</a></code>
</p>
</li>
<li> <p><code><a href="#topic+vertexDuration">vertexDuration</a></code>
</p>
</li>
<li> <p><code><a href="#topic+tiedDuration">tiedDuration</a></code>
</p>
</li>
<li> <p><code><a href="#topic+tEdgeDissolution">tEdgeDissolution</a></code>
</p>
</li>
<li> <p><code><a href="#topic+tEdgeFormation">tEdgeFormation</a></code>
</p>
</li>
<li> <p><code><a href="#topic+tiedDuration">tiedDuration</a></code>
</p>
</li></ul>



<h3>tsna Utilities</h3>


<ul>
<li> <p><code><a href="#topic+as.network.tPath">as.network.tPath</a></code>
</p>
</li>
<li> <p><code><a href="#topic+plotPaths">plotPaths</a></code>
</p>
</li>
<li> <p><code><a href="#topic+timeProjectedNetwork">timeProjectedNetwork</a></code>
</p>
</li></ul>



<h3>Data Sets</h3>


<ul>
<li> <p><code><a href="#topic+moodyContactSim">moodyContactSim</a></code>
</p>
</li>
<li><p> additional useful datasets provided by the <code>networkDynamicData</code> and <code>networkDynamic</code> packages
</p>
</li></ul>



<h3>Source</h3>

<p>This package is part of the statnet suite of packages <a href="http://statnet.org">http://statnet.org</a>.  For citation information see <code>citation('tsna')</code>.
</p>

<hr>
<h2 id='tSnaStats'>
Apply the sna package's static graph- and vertex-level network descriptive statistics at multiple time points
</h2><span id='topic+tSnaStats'></span>

<h3>Description</h3>

<p>Samples collapsed static networks at regular intervals along a network dynamic object, applies the named static <code><a href="sna.html#topic+sna">sna</a></code> descriptive statistic function to each network, and returns the result as a time series. Additional arguments to the function can be included via <code>...</code> . Set the sna function's directedness and self-loops flags appropriately by default. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tSnaStats(nd, snafun, start, end, time.interval = 1, aggregate.dur=0, rule='latest', ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tSnaStats_+3A_nd">nd</code></td>
<td>

<p>a <code>networkDynamic</code> object to be evaluated
</p>
</td></tr>
<tr><td><code id="tSnaStats_+3A_snafun">snafun</code></td>
<td>

<p>character string giving the name of the <code><a href="sna.html#topic+sna">sna</a></code> package function to be applied. i.e 'mutuality'
</p>
</td></tr>
<tr><td><code id="tSnaStats_+3A_start">start</code></td>
<td>

<p>optional numeric time value at which evaluation should start (default is first observed time)
</p>
</td></tr>
<tr><td><code id="tSnaStats_+3A_end">end</code></td>
<td>

<p>optional numeric time value at which evaluation should end (default is last observed time)
</p>
</td></tr>
<tr><td><code id="tSnaStats_+3A_time.interval">time.interval</code></td>
<td>

<p>optional numeric value giving time interval between evaluations (default is 1)
</p>
</td></tr>
<tr><td><code id="tSnaStats_+3A_aggregate.dur">aggregate.dur</code></td>
<td>

<p>optional numeric value giving the duration of time bin to aggregate over for each evaluation (default 0). See <code><a href="networkDynamic.html#topic+network.collapse">network.collapse</a></code>
</p>
</td></tr>
<tr><td><code id="tSnaStats_+3A_rule">rule</code></td>
<td>

<p>character vector describing rule to be used if multiple attribute values are encountred when using non-zero <code>aggregate.dur</code>. Default is <code>latest</code>. See <code><a href="networkDynamic.html#topic+network.collapse">network.collapse</a></code> for details
</p>
</td></tr>
<tr><td><code id="tSnaStats_+3A_...">...</code></td>
<td>

<p>additional arguments to be passed on to the sna function. See docs for each function for possible arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This wrapper directly calls functions in the <code><a href="sna.html#topic+sna">sna</a></code> package, so it will only work if that package is installed. Below is a list of supported functions:
</p>
<p>Graph-Level statistics:
</p>

<ul>
<li> <p><code><a href="sna.html#topic+components">components</a></code> Number of (Maximal) Components Within a Given Graph
</p>
</li>
<li> <p><code><a href="sna.html#topic+triad.census">triad.census</a></code> Davis and Leinhardt Triad Census
</p>
</li>
<li> <p><code><a href="sna.html#topic+connectedness">connectedness</a></code> Graph Connectedness Scores
</p>
</li>
<li> <p><code><a href="sna.html#topic+dyad.census">dyad.census</a></code> Holland and Leinhardt MAN Dyad Census
</p>
</li>
<li> <p><code><a href="sna.html#topic+efficiency">efficiency</a></code> Graph Efficiency Scores
</p>
</li>
<li> <p><code><a href="sna.html#topic+gden">gden</a></code> Graph Density
</p>
</li>
<li> <p><code><a href="sna.html#topic+grecip">grecip</a></code> Graph Reciprocity
</p>
</li>
<li> <p><code><a href="sna.html#topic+gtrans">gtrans</a></code> Graph Transitivity
</p>
</li>
<li> <p><code><a href="sna.html#topic+hierarchy">hierarchy</a></code> Graph Hierarchy Scores
</p>
</li>
<li> <p><code><a href="sna.html#topic+lubness">lubness</a></code> Graph LUBness Scores
</p>
</li>
<li> <p><code><a href="sna.html#topic+mutuality">mutuality</a></code> Graph Mutuality
</p>
</li>
<li> <p><code><a href="sna.html#topic+centralization">centralization</a></code> Graph Centralization (must provide centrality measure)
</p>
</li></ul>

<p>Vertex-level statistics:
</p>

<ul>
<li> <p><code><a href="sna.html#topic+closeness">closeness</a></code> Vertex Closeness Centrality Scores
</p>
</li>
<li> <p><code><a href="sna.html#topic+betweenness">betweenness</a></code> Vertex Betweenness Centrality Scores
</p>
</li>
<li> <p><code><a href="sna.html#topic+bonpow">bonpow</a></code> Vertex Bonacich Power Centrality Scores
</p>
</li>
<li> <p><code><a href="sna.html#topic+degree">degree</a></code> Vertex Degree Centrality Scores
</p>
</li>
<li> <p><code><a href="sna.html#topic+evcent">evcent</a></code> Vertex Eigenvector Centrality Scores
</p>
</li>
<li> <p><code><a href="sna.html#topic+flowbet">flowbet</a></code> Vertex Flow Betweenness Scores
</p>
</li>
<li> <p><code><a href="sna.html#topic+graphcent">graphcent</a></code> Vertex (Harary) Graph Centrality Scores
</p>
</li>
<li> <p><code><a href="sna.html#topic+infocent">infocent</a></code> Vertex Information Centrality Scores 
</p>
</li>
<li> <p><code><a href="sna.html#topic+loadcent">loadcent</a></code> Vertex Load Centrality Scores
</p>
</li>
<li> <p><code><a href="sna.html#topic+prestige">prestige</a></code> Vertex Prestige Scores
</p>
</li></ul>

<p>Most of the sna functions involve converting the network to a matrix and can be quite expensive to calculate for a single time point, so use care when applying to large or long-duration networks.
</p>
<p>Some of the sna functions are undefined or produce numerical errors when applied to networks with certain configurations (such as zero edges).
</p>
<p>The sna functions generally cannot handle networks with no vertices, so stats will be replaced with NA when they are encountered. 
</p>
<p>There may be some overlap with ergm terms available through <code><a href="#topic+tErgmStats">tErgmStats</a></code> and the ergm version will generally be faster
</p>


<h3>Value</h3>

<p>a <code><a href="stats.html#topic+ts">ts</a></code> (time series) object. A matrix in which rows correspond to the time points evaluated and columns correspond to values of statistics produced.  In the case of vertex-level indices, there will be one column per vertex. For the census measures, each column will correspond to a census element.
</p>


<h3>Note</h3>

<p>Note that this is an early DRAFT implementation.  Does not yet include binning options needed for non-discrete time networks, and has not been tested with networks that have changing vertex activity. 
</p>


<h3>Author(s)</h3>

<p>skyebend@uw.edu
</p>


<h3>References</h3>

<p>Carter T. Butts (2014). sna: Tools for Social Network Analysis. R package version
2.3-2. http://CRAN.R-project.org/package=sna
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+tErgmStats">tErgmStats</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(networkDynamicData)
data(harry_potter_support)

# compute triad census scores for each time point
tSnaStats(harry_potter_support,snafun='triad.census')

# compute graph transitivities
tSnaStats(harry_potter_support,snafun='gtrans')
## Not run: 
data(concurrencyComparisonNets)
# since thes are big nets, with lots of timepoints, 
# set time.interval to avoid evaluating every step
tSnaStats(base,'prestige',time.interval=25,rescale=TRUE)

# since it is time series, easy to plot
plot(tSnaStats(base,'components',time.interval=10))

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
