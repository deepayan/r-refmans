<!DOCTYPE html><html><head><title>Help for package markovchain</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {markovchain}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#markovchain-package'><p>Easy Handling Discrete Time Markov Chains</p></a></li>
<li><a href='#absorptionProbabilities'><p>Absorption probabilities</p></a></li>
<li><a href='#blanden'><p>Mobility between income quartiles</p></a></li>
<li><a href='#committorAB'><p>Calculates committor of a markovchain object with respect to set A, B</p></a></li>
<li><a href='#conditionalDistribution'><p><code>conditionalDistribution</code> of a Markov Chain</p></a></li>
<li><a href='#craigsendi'><p>CD4 cells counts on HIV Infects between zero and six month</p></a></li>
<li><a href='#createSequenceMatrix'><p>Function to fit a discrete Markov chain</p></a></li>
<li><a href='#ctmc-class'><p>Continuous time Markov Chains class</p></a></li>
<li><a href='#ctmcFit'><p>Function to fit a CTMC</p></a></li>
<li><a href='#expectedRewards'><p>Expected Rewards for a markovchain</p></a></li>
<li><a href='#expectedRewardsBeforeHittingA'><p>Expected first passage Rewards for a set of states in a markovchain</p></a></li>
<li><a href='#ExpectedTime'><p>Returns expected hitting time from state i to state j</p></a></li>
<li><a href='#firstPassage'><p>First passage across states</p></a></li>
<li><a href='#firstPassageMultiple'><p>function to calculate first passage probabilities</p></a></li>
<li><a href='#fitHigherOrder'><p>Functions to fit a higher order Markov chain</p></a></li>
<li><a href='#fitHighOrderMultivarMC'><p>Function to fit Higher Order Multivariate Markov chain</p></a></li>
<li><a href='#freq2Generator'><p>Returns a generator matrix corresponding to frequency matrix</p></a></li>
<li><a href='#generatorToTransitionMatrix'><p>Function to obtain the transition matrix from the generator</p></a></li>
<li><a href='#HigherOrderMarkovChain-class'><p>Higher order Markov Chains class</p></a></li>
<li><a href='#hittingProbabilities'><p>Hitting probabilities for markovchain</p></a></li>
<li><a href='#holson'><p>Holson data set</p></a></li>
<li><a href='#hommc-class'><p>An S4 class for representing High Order Multivariate Markovchain (HOMMC)</p></a></li>
<li><a href='#ictmc-class'><p>An S4 class for representing Imprecise Continuous Time Markovchains</p></a></li>
<li><a href='#impreciseProbabilityatT'><p>Calculating full conditional probability using lower rate transition matrix</p></a></li>
<li><a href='#inferHyperparam'><p>Function to infer the hyperparameters for Bayesian inference from an a priori matrix or a data set</p></a></li>
<li><a href='#is.accessible'><p>Verify if a state j is reachable from state i.</p></a></li>
<li><a href='#is.CTMCirreducible'><p>Check if CTMC is irreducible</p></a></li>
<li><a href='#is.irreducible'><p>Function to check if a Markov chain is irreducible (i.e. ergodic)</p></a></li>
<li><a href='#is.regular'><p>Check if a DTMC is regular</p></a></li>
<li><a href='#is.TimeReversible'><p>checks if ctmc object is time reversible</p></a></li>
<li><a href='#kullback'><p>Example from Kullback and Kupperman Tests for Contingency Tables</p></a></li>
<li><a href='#markovchain-class'><p>Markov Chain class</p></a></li>
<li><a href='#markovchainList-class'><p>Non homogeneus discrete time Markov Chains class</p></a></li>
<li><a href='#markovchainListFit'><p>markovchainListFit</p></a></li>
<li><a href='#markovchainSequence'><p>Function to generate a sequence of states from homogeneous Markov chains.</p></a></li>
<li><a href='#meanAbsorptionTime'><p>Mean absorption time</p></a></li>
<li><a href='#meanFirstPassageTime'><p>Mean First Passage Time for irreducible Markov chains</p></a></li>
<li><a href='#meanNumVisits'><p>Mean num of visits for markovchain, starting at each state</p></a></li>
<li><a href='#meanRecurrenceTime'><p>Mean recurrence time</p></a></li>
<li><a href='#multinomialConfidenceIntervals'><p>A function to compute multinomial confidence intervals of DTMC</p></a></li>
<li><a href='#name'><p>Method to retrieve name of markovchain object</p></a></li>
<li><a href='#name&lt;-'><p>Method to set name of markovchain object</p></a></li>
<li><a href='#names,markovchain-method'><p>Returns the states for a Markov chain object</p></a></li>
<li><a href='#noofVisitsDist'><p>return a joint pdf of the number of visits to the various states of the DTMC</p></a></li>
<li><a href='#ones'><p>Returns an Identity matrix</p></a></li>
<li><a href='#period'><p>Various function to perform structural analysis of DTMC</p></a></li>
<li><a href='#predictHommc'><p>Simulate a higher order multivariate markovchain</p></a></li>
<li><a href='#predictiveDistribution'><p>predictiveDistribution</p></a></li>
<li><a href='#preproglucacon'><p>Preprogluccacon DNA protein bases sequences</p></a></li>
<li><a href='#priorDistribution'><p>priorDistribution</p></a></li>
<li><a href='#probabilityatT'><p>Calculating probability from a ctmc object</p></a></li>
<li><a href='#rain'><p>Alofi island daily rainfall</p></a></li>
<li><a href='#rctmc'><p>rctmc</p></a></li>
<li><a href='#rmarkovchain'><p>Function to generate a sequence of states from homogeneous or non-homogeneous Markov chains.</p></a></li>
<li><a href='#sales'><p>Sales Demand Sequences</p></a></li>
<li><a href='#show,hommc-method'><p>Function to display the details of hommc object</p></a></li>
<li><a href='#states'><p>Defined states of a transition matrix</p></a></li>
<li><a href='#steadyStates'><p>Stationary states of a <code>markovchain</code> object</p></a></li>
<li><a href='#tm_abs'><p>Single Year Corporate Credit Rating Transititions</p></a></li>
<li><a href='#transition2Generator'><p>Return the generator matrix for a corresponding transition matrix</p></a></li>
<li><a href='#transitionProbability'><p>Function to get the transition probabilities from initial</p>
to subsequent states.</a></li>
<li><a href='#verifyMarkovProperty'><p>Various functions to perform statistical inference of DTMC</p></a></li>
<li><a href='#zeros'><p>Matrix to create zeros</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Easy Handling Discrete Time Markov Chains</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.5</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Giorgio Alfredo Spedicato &lt;spedicato_giorgio@yahoo.it&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions and S4 methods to create and manage discrete time Markov
    chains more easily. In addition functions to perform statistical (fitting
    and drawing random variates) and probabilistic (analysis of their structural
    proprieties) analysis are provided. See Spedicato (2017) &lt;<a href="https://doi.org/10.32614%2FRJ-2017-036">doi:10.32614/RJ-2017-036</a>&gt;.
    Some functions for continuous times Markov chains depends on the suggested ctmcd package, that, 
    as May 2023, can be retrieved from <a href="https://cran.r-project.org/src/contrib/Archive/ctmcd/ctmcd_1.4.2.tar.gz">https://cran.r-project.org/src/contrib/Archive/ctmcd/ctmcd_1.4.2.tar.gz</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>igraph, Matrix (&ge; 1.5-0), expm, stats4, parallel, Rcpp (&ge;
1.0.2), RcppParallel, utils, stats, grDevices</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, testthat, diagram, DiagrammeR, msm, Rsolnp, rmarkdown,
ctmcd, bookdown, rticles</td>
</tr>
<tr>
<td>Enhances:</td>
<td>etm</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>rmarkdown, knitr, bookdown, rticles</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppParallel, RcppArmadillo (&ge; 0.9.600.4.0)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/spedygiorgio/markovchain/issues">https://github.com/spedygiorgio/markovchain/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/spedygiorgio/markovchain/">https://github.com/spedygiorgio/markovchain/</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-24 08:41:22 UTC; giorgio</td>
</tr>
<tr>
<td>Author:</td>
<td>Giorgio Alfredo Spedicato
    <a href="https://orcid.org/0000-0002-0315-8888"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Tae Seung Kang [aut],
  Sai Bhargav Yalamanchi [aut],
  Mildenberger Thoralf
    <a href="https://orcid.org/0000-0001-7242-1873"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Deepak Yadav [aut],
  Ignacio Cordón <a href="https://orcid.org/0000-0002-3152-0231"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Vandit Jain [ctb],
  Toni Giorgino <a href="https://orcid.org/0000-0001-6449-0596"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Richèl J.C. Bilderbeek
    <a href="https://orcid.org/0000-0003-1107-7049"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Daniel Ebbert <a href="https://orcid.org/0000-0003-3666-7205"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Shreyash Maheshwari [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-24 09:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='markovchain-package'>Easy Handling Discrete Time Markov Chains</h2><span id='topic+markovchain-package'></span>

<h3>Description</h3>

<p>The package contains classes and method to create and manage
(plot, print, export for example) discrete time Markov chains (DTMC). In
addition it provide functions to perform statistical (fitting and drawing
random variates) and probabilistic (analysis of DTMC proprieties) analysis
</p>


<h3>Author(s)</h3>

<p>Giorgio Alfredo Spedicato 
Maintainer: Giorgio Alfredo Spedicato &lt;spedicato_giorgio@yahoo.it&gt;
</p>


<h3>References</h3>

<p>Discrete-Time Markov Models, Bremaud, Springer 1999
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create some markov chains
statesNames=c("a","b")
mcA&lt;-new("markovchain", transitionMatrix=matrix(c(0.7,0.3,0.1,0.9),byrow=TRUE,
         nrow=2, dimnames=list(statesNames,statesNames)))
         
statesNames=c("a","b","c")
mcB&lt;-new("markovchain", states=statesNames, transitionMatrix=
         matrix(c(0.2,0.5,0.3,0,1,0,0.1,0.8,0.1), nrow=3, 
         byrow=TRUE, dimnames=list(statesNames, statesNames)))

statesNames=c("a","b","c","d")
matrice&lt;-matrix(c(0.25,0.75,0,0,0.4,0.6,0,0,0,0,0.1,0.9,0,0,0.7,0.3), nrow=4, byrow=TRUE)
mcC&lt;-new("markovchain", states=statesNames, transitionMatrix=matrice)
mcD&lt;-new("markovchain", transitionMatrix=matrix(c(0,1,0,1), nrow=2,byrow=TRUE))


#operations with S4 methods
mcA^2
steadyStates(mcB)
absorbingStates(mcB)
markovchainSequence(n=20, markovchain=mcC, include=TRUE)
</code></pre>

<hr>
<h2 id='absorptionProbabilities'>Absorption probabilities</h2><span id='topic+absorptionProbabilities'></span>

<h3>Description</h3>

<p>Computes the absorption probability from each transient
state to each recurrent one (i.e. the (i, j) entry or (j, i), in a 
stochastic matrix by columns, represents the probability that the
first not transient state we can go from the transient state i is j
(and therefore we are going to be absorbed in the communicating
recurrent class of j)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>absorptionProbabilities(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="absorptionProbabilities_+3A_object">object</code></td>
<td>
<p>the markovchain object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector with the expected number of steps to go from a
transient state to any of the recurrent ones
</p>


<h3>Author(s)</h3>

<p>Ignacio Cordón
</p>


<h3>References</h3>

<p>C. M. Grinstead and J. L. Snell. Introduction to Probability.
American Mathematical Soc., 2012.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(c(1/2, 1/2, 0,
              1/2, 1/2, 0,
                0, 1/2, 1/2), ncol = 3, byrow = TRUE)
mc &lt;- new("markovchain", states = letters[1:3], transitionMatrix = m)
absorptionProbabilities(mc)

</code></pre>

<hr>
<h2 id='blanden'>Mobility between income quartiles</h2><span id='topic+blanden'></span>

<h3>Description</h3>

<p>This table show mobility between income quartiles for father and sons for the 1970 cohort born
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(blanden)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>table</code> with 4 rows and 4 columns.
</p>


<h3>Details</h3>

<p>The rows represent fathers' income quartile when the son is aged 16, whilst the columns represent sons' income quartiles when he is aged 30 (in 2000).
</p>


<h3>Source</h3>

<p>Personal reworking
</p>


<h3>References</h3>

<p>Jo Blanden, Paul Gregg and Stephen Machin, Intergenerational Mobility in Europe and North America, Center for Economic Performances (2005)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(blanden)
mobilityMc&lt;-as(blanden, "markovchain")
</code></pre>

<hr>
<h2 id='committorAB'>Calculates committor of a markovchain object with respect to set A, B</h2><span id='topic+committorAB'></span>

<h3>Description</h3>

<p>Returns the probability of hitting states rom set A before set B 
with different initial states
</p>


<h3>Usage</h3>

<pre><code class='language-R'>committorAB(object,A,B,p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="committorAB_+3A_object">object</code></td>
<td>
<p>a markovchain class object</p>
</td></tr>
<tr><td><code id="committorAB_+3A_a">A</code></td>
<td>
<p>a set of states</p>
</td></tr>
<tr><td><code id="committorAB_+3A_b">B</code></td>
<td>
<p>a set of states</p>
</td></tr>
<tr><td><code id="committorAB_+3A_p">p</code></td>
<td>
<p>initial state (default value : 1)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function solves a system of linear equations to calculate probaility that the process hits
a state from set A before any state from set B
</p>


<h3>Value</h3>

<p>Return a vector of probabilities in case initial state is not provided else returns a number
</p>


<h3>Examples</h3>

<pre><code class='language-R'>transMatr &lt;- matrix(c(0,0,0,1,0.5,
                      0.5,0,0,0,0,
                      0.5,0,0,0,0,
                      0,0.2,0.4,0,0,
                      0,0.8,0.6,0,0.5),
                      nrow = 5)
object &lt;- new("markovchain", states=c("a","b","c","d","e"),transitionMatrix=transMatr)
committorAB(object,c(5),c(3))

</code></pre>

<hr>
<h2 id='conditionalDistribution'><code>conditionalDistribution</code> of a Markov Chain</h2><span id='topic+conditionalDistribution'></span>

<h3>Description</h3>

<p>It extracts the conditional distribution of the subsequent state, 
given current state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conditionalDistribution(object, state)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conditionalDistribution_+3A_object">object</code></td>
<td>
<p>A <code>markovchain</code> object.</p>
</td></tr>
<tr><td><code id="conditionalDistribution_+3A_state">state</code></td>
<td>
<p>Subsequent state.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named probability vector
</p>


<h3>Author(s)</h3>

<p>Giorgio Spedicato, Deepak Yadav
</p>


<h3>References</h3>

<p>A First Course in Probability (8th Edition), Sheldon Ross, Prentice Hall 2010
</p>


<h3>See Also</h3>

<p><code><a href="#topic+markovchain-class">markovchain</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define a markov chain
statesNames &lt;- c("a", "b", "c")
markovB &lt;- new("markovchain", states = statesNames, transitionMatrix = 
               matrix(c(0.2, 0.5, 0.3, 0, 1, 0, 0.1, 0.8, 0.1),nrow = 3, 
                      byrow = TRUE, dimnames = list(statesNames, statesNames)))
                      
conditionalDistribution(markovB, "b")                       

</code></pre>

<hr>
<h2 id='craigsendi'>CD4 cells counts on HIV Infects between zero and six month</h2><span id='topic+craigsendi'></span>

<h3>Description</h3>

<p>This is the table shown in Craig and Sendi paper showing zero and six month CD4 cells count in six brakets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(craigsendi)
</code></pre>


<h3>Format</h3>

<p>The format is:
table [1:3, 1:3] 682 154 19 33 64 19 25 47 43
- attr(*, &quot;dimnames&quot;)=List of 2
..$ : chr [1:3] &quot;0-49&quot; &quot;50-74&quot; &quot;75-UP&quot;
..$ : chr [1:3] &quot;0-49&quot; &quot;50-74&quot; &quot;75-UP&quot;
</p>


<h3>Details</h3>

<p>Rows represent counts at the beginning, cols represent counts after six months.
</p>


<h3>Source</h3>

<p>Estimation of the transition matrix of a discrete time Markov chain, Bruce A. Craig and Peter P. Sendi, Health Economics 11, 2002.
</p>


<h3>References</h3>

<p>see source
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(craigsendi)
csMc&lt;-as(craigsendi, "markovchain")
steadyStates(csMc)
</code></pre>

<hr>
<h2 id='createSequenceMatrix'>Function to fit a discrete Markov chain</h2><span id='topic+createSequenceMatrix'></span><span id='topic+markovchainFit'></span>

<h3>Description</h3>

<p>Given a sequence of states arising from a stationary state, 
it fits the underlying Markov chain distribution using either MLE (also using a 
Laplacian smoother), bootstrap or by MAP (Bayesian) inference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createSequenceMatrix(
  stringchar,
  toRowProbs = FALSE,
  sanitize = FALSE,
  possibleStates = character()
)

markovchainFit(
  data,
  method = "mle",
  byrow = TRUE,
  nboot = 10L,
  laplacian = 0,
  name = "",
  parallel = FALSE,
  confidencelevel = 0.95,
  confint = TRUE,
  hyperparam = matrix(),
  sanitize = FALSE,
  possibleStates = character()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createSequenceMatrix_+3A_stringchar">stringchar</code></td>
<td>
<p>It can be a n x n matrix or a character vector or a list</p>
</td></tr>
<tr><td><code id="createSequenceMatrix_+3A_torowprobs">toRowProbs</code></td>
<td>
<p>converts a sequence matrix into a probability matrix</p>
</td></tr>
<tr><td><code id="createSequenceMatrix_+3A_sanitize">sanitize</code></td>
<td>
<p>put 1 in all rows having rowSum equal to zero</p>
</td></tr>
<tr><td><code id="createSequenceMatrix_+3A_possiblestates">possibleStates</code></td>
<td>
<p>Possible states which are not present in the given sequence</p>
</td></tr>
<tr><td><code id="createSequenceMatrix_+3A_data">data</code></td>
<td>
<p>It can be a character vector or a n x n matrix or a n x n data frame or a list</p>
</td></tr>
<tr><td><code id="createSequenceMatrix_+3A_method">method</code></td>
<td>
<p>Method used to estimate the Markov chain. Either &quot;mle&quot;, &quot;map&quot;, &quot;bootstrap&quot; or &quot;laplace&quot;</p>
</td></tr>
<tr><td><code id="createSequenceMatrix_+3A_byrow">byrow</code></td>
<td>
<p>it tells whether the output Markov chain should show the transition probabilities by row.</p>
</td></tr>
<tr><td><code id="createSequenceMatrix_+3A_nboot">nboot</code></td>
<td>
<p>Number of bootstrap replicates in case &quot;bootstrap&quot; is used.</p>
</td></tr>
<tr><td><code id="createSequenceMatrix_+3A_laplacian">laplacian</code></td>
<td>
<p>Laplacian smoothing parameter, default zero. It is only used when &quot;laplace&quot; method 
is chosen.</p>
</td></tr>
<tr><td><code id="createSequenceMatrix_+3A_name">name</code></td>
<td>
<p>Optional character for name slot.</p>
</td></tr>
<tr><td><code id="createSequenceMatrix_+3A_parallel">parallel</code></td>
<td>
<p>Use parallel processing when performing Boostrap estimates.</p>
</td></tr>
<tr><td><code id="createSequenceMatrix_+3A_confidencelevel">confidencelevel</code></td>
<td>
<p style="text-align: center;"><code class="reqn">\alpha</code>
</p>
<p> level for conficence intervals width. 
Used only when <code>method</code> equal to &quot;mle&quot;.</p>
</td></tr>
<tr><td><code id="createSequenceMatrix_+3A_confint">confint</code></td>
<td>
<p>a boolean to decide whether to compute Confidence Interval or not.</p>
</td></tr>
<tr><td><code id="createSequenceMatrix_+3A_hyperparam">hyperparam</code></td>
<td>
<p>Hyperparameter matrix for the a priori distribution. If none is provided, 
default value of 1 is assigned to each parameter. This must be of size
k x k where k is the number of states in the chain and the values
should typically be non-negative integers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Disabling confint would lower the computation time on large datasets. If <code>data</code> or <code>stringchar</code> 
contain <code>NAs</code>, the related <code>NA</code> containing transitions will be ignored.
</p>


<h3>Value</h3>

<p>A list containing an estimate, log-likelihood, and, when &quot;bootstrap&quot; method is used, a matrix 
of standards deviations and the bootstrap samples. When the &quot;mle&quot;, &quot;bootstrap&quot; or &quot;map&quot; method 
is used, the lower and upper confidence bounds are returned along with the standard error. 
The &quot;map&quot; method also returns the expected value of the parameters with respect to the 
posterior distribution.
</p>


<h3>Note</h3>

<p>This function has been rewritten in Rcpp. Bootstrap algorithm has been defined &quot;heuristically&quot;. 
In addition, parallel facility is not complete, involving only a part of the bootstrap process.
When <code>data</code> is either a <code>data.frame</code> or a <code>matrix</code> object, only MLE fit is 
currently available.
</p>


<h3>Author(s)</h3>

<p>Giorgio Spedicato, Tae Seung Kang, Sai Bhargav Yalamanchi
</p>


<h3>References</h3>

<p>A First Course in Probability (8th Edition), Sheldon Ross, Prentice Hall 2010
</p>
<p>Inferring Markov Chains: Bayesian Estimation, Model Comparison, Entropy Rate, 
and Out-of-Class Modeling, Christopher C. Strelioff, James P. Crutchfield, 
Alfred Hubler, Santa Fe Institute
</p>
<p>Yalamanchi SB, Spedicato GA (2015). Bayesian Inference of First Order Markov Chains. R
package version 0.2.5
</p>


<h3>See Also</h3>

<p><code><a href="#topic+markovchainSequence">markovchainSequence</a></code>, <code><a href="#topic+markovchainListFit">markovchainListFit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sequence &lt;- c("a", "b", "a", "a", "a", "a", "b", "a", "b", "a", "b", "a", "a", 
              "b", "b", "b", "a")        
sequenceMatr &lt;- createSequenceMatrix(sequence, sanitize = FALSE)
mcFitMLE &lt;- markovchainFit(data = sequence)
mcFitBSP &lt;- markovchainFit(data = sequence, method = "bootstrap", nboot = 5, name = "Bootstrap Mc")

na.sequence &lt;- c("a", NA, "a", "b")
# There will be only a (a,b) transition        
na.sequenceMatr &lt;- createSequenceMatrix(na.sequence, sanitize = FALSE)
mcFitMLE &lt;- markovchainFit(data = na.sequence)

# data can be a list of character vectors
sequences &lt;- list(x = c("a", "b", "a"), y = c("b", "a", "b", "a", "c"))
mcFitMap &lt;- markovchainFit(sequences, method = "map")
mcFitMle &lt;- markovchainFit(sequences, method = "mle")
</code></pre>

<hr>
<h2 id='ctmc-class'>Continuous time Markov Chains class</h2><span id='topic+ctmc-class'></span><span id='topic+dim+2Cctmc-method'></span><span id='topic+initialize+2Cctmc_method'></span><span id='topic+states+2Cctmc-method'></span><span id='topic+steadyStates+2Cctmc-method'></span><span id='topic+plot+2Cctmc+2Cmissing-method'></span>

<h3>Description</h3>

<p>The S4 class that describes <code>ctmc</code> (continuous 
time Markov chain) objects.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctmc-class_+3A_states">states</code></td>
<td>
<p>Name of the states. Must be the same of
<code>colnames</code> and <code>rownames</code> of the generator matrix</p>
</td></tr>
<tr><td><code id="ctmc-class_+3A_byrow">byrow</code></td>
<td>
<p>TRUE or FALSE. Indicates whether the given matrix is
stochastic by rows or by columns</p>
</td></tr>
<tr><td><code id="ctmc-class_+3A_generator">generator</code></td>
<td>
<p>Square generator matrix</p>
</td></tr>
<tr><td><code id="ctmc-class_+3A_name">name</code></td>
<td>
<p>Optional character name of the Markov chain</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>dim</dt><dd><p><code>signature(x = "ctmc")</code>: method to get the size</p>
</dd> 
<dt>initialize</dt><dd><p><code>signature(.Object = "ctmc")</code>: initialize
method </p>
</dd>
<dt>states</dt><dd><p><code>signature(object = "ctmc")</code>: states method. </p>
</dd>
<dt>steadyStates</dt><dd><p><code>signature(object = "ctmc")</code>: method to get the
steady state vector. </p>
</dd> 
<dt>plot</dt><dd><p><code>signature(x = "ctmc", y = "missing")</code>: plot method 
for <code>ctmc</code> objects </p>
</dd>
</dl>



<h3>Note</h3>


<ol>
<li> <p><code>ctmc</code> classes are written using S4 classes
</p>
</li>
<li><p> Validation method is used to assess whether either columns or rows totals to zero. 
Rounding is used up to 5th decimal. If state names are not properly defined
for a generator  <code>matrix</code>, coercing to <code>ctmc</code> object leads to overriding
states name with artificial &quot;s1&quot;, &quot;s2&quot;, ... sequence
</p>
</li></ol>



<h3>References</h3>

<p>Introduction to Stochastic Processes with Applications in the Biosciences
(2013), David F. Anderson, University of Wisconsin at Madison. Sai Bhargav
Yalamanchi, Giorgio Spedicato
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generatorToTransitionMatrix">generatorToTransitionMatrix</a></code>,<code><a href="#topic+rctmc">rctmc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>energyStates &lt;- c("sigma", "sigma_star")
byRow &lt;- TRUE
gen &lt;- matrix(data = c(-3, 3,
                       1, -1), nrow = 2,
              byrow = byRow, dimnames = list(energyStates, energyStates))
molecularCTMC &lt;- new("ctmc", states = energyStates, 
                     byrow = byRow, generator = gen, 
                     name = "Molecular Transition Model")
                     steadyStates(molecularCTMC)
## Not run: plot(molecularCTMC)

</code></pre>

<hr>
<h2 id='ctmcFit'>Function to fit a CTMC</h2><span id='topic+ctmcFit'></span>

<h3>Description</h3>

<p>This function fits the underlying CTMC give the state
transition data and the transition times using the maximum likelihood
method (MLE)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ctmcFit(data, byrow = TRUE, name = "", confidencelevel = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ctmcFit_+3A_data">data</code></td>
<td>
<p>It is a list of two elements. The first element is a character
vector denoting the states. The second is a numeric vector denoting the
corresponding transition times.</p>
</td></tr>
<tr><td><code id="ctmcFit_+3A_byrow">byrow</code></td>
<td>
<p>Determines if the output transition probabilities of the
underlying embedded DTMC are by row.</p>
</td></tr>
<tr><td><code id="ctmcFit_+3A_name">name</code></td>
<td>
<p>Optional name for the CTMC.</p>
</td></tr>
<tr><td><code id="ctmcFit_+3A_confidencelevel">confidencelevel</code></td>
<td>
<p>Confidence level for the confidence interval
construnction.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that in data, there must exist an element wise corresponding
between the two elements of the list and that data[[2]][1] is always 0.
</p>


<h3>Value</h3>

<p>It returns a list containing the CTMC object and the confidence intervals.
</p>


<h3>Author(s)</h3>

<p>Sai Bhargav Yalamanchi
</p>


<h3>References</h3>

<p>Continuous Time Markov Chains (vignette), Sai Bhargav Yalamanchi, Giorgio Alfredo Spedicato 2015
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rctmc">rctmc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- list(c("a", "b", "c", "a", "b", "a", "c", "b", "c"), c(0, 0.8, 2.1, 2.4, 4, 5, 5.9, 8.2, 9))
ctmcFit(data)

</code></pre>

<hr>
<h2 id='expectedRewards'>Expected Rewards for a markovchain</h2><span id='topic+expectedRewards'></span>

<h3>Description</h3>

<p>Given a markovchain object and reward values for every state,
function calculates expected reward value after n steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expectedRewards(markovchain,n,rewards)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expectedRewards_+3A_markovchain">markovchain</code></td>
<td>
<p>the markovchain-class object</p>
</td></tr>
<tr><td><code id="expectedRewards_+3A_n">n</code></td>
<td>
<p>no of steps of the process</p>
</td></tr>
<tr><td><code id="expectedRewards_+3A_rewards">rewards</code></td>
<td>
<p>vector depicting rewards coressponding to states</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the function uses a dynamic programming approach to solve a 
recursive equation described in reference.
</p>


<h3>Value</h3>

<p>returns a vector of expected rewards for different initial states
</p>


<h3>Author(s)</h3>

<p>Vandit Jain
</p>


<h3>References</h3>

<p>Stochastic Processes: Theory for Applications, Robert G. Gallager,
Cambridge University Press
</p>


<h3>Examples</h3>

<pre><code class='language-R'>transMatr&lt;-matrix(c(0.99,0.01,0.01,0.99),nrow=2,byrow=TRUE)
simpleMc&lt;-new("markovchain", states=c("a","b"),
             transitionMatrix=transMatr)
expectedRewards(simpleMc,1,c(0,1))
</code></pre>

<hr>
<h2 id='expectedRewardsBeforeHittingA'>Expected first passage Rewards for a set of states in a markovchain</h2><span id='topic+expectedRewardsBeforeHittingA'></span>

<h3>Description</h3>

<p>Given a markovchain object and reward values for every state,
function calculates expected reward value for a set A of states after n 
steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expectedRewardsBeforeHittingA(markovchain, A, state, rewards, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expectedRewardsBeforeHittingA_+3A_markovchain">markovchain</code></td>
<td>
<p>the markovchain-class object</p>
</td></tr>
<tr><td><code id="expectedRewardsBeforeHittingA_+3A_a">A</code></td>
<td>
<p>set of states for first passage expected reward</p>
</td></tr>
<tr><td><code id="expectedRewardsBeforeHittingA_+3A_state">state</code></td>
<td>
<p>initial state</p>
</td></tr>
<tr><td><code id="expectedRewardsBeforeHittingA_+3A_rewards">rewards</code></td>
<td>
<p>vector depicting rewards coressponding to states</p>
</td></tr>
<tr><td><code id="expectedRewardsBeforeHittingA_+3A_n">n</code></td>
<td>
<p>no of steps of the process</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns the value of expected first passage 
rewards given rewards coressponding to every state, an initial state
and number of steps.
</p>


<h3>Value</h3>

<p>returns a expected reward (numerical value) as described above
</p>


<h3>Author(s)</h3>

<p>Sai Bhargav Yalamanchi, Vandit Jain
</p>

<hr>
<h2 id='ExpectedTime'>Returns expected hitting time from state i to state j</h2><span id='topic+ExpectedTime'></span>

<h3>Description</h3>

<p>Returns expected hitting time from state i to state j
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExpectedTime(C,i,j,useRCpp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExpectedTime_+3A_c">C</code></td>
<td>
<p>A CTMC S4 object</p>
</td></tr>
<tr><td><code id="ExpectedTime_+3A_i">i</code></td>
<td>
<p>Initial state i</p>
</td></tr>
<tr><td><code id="ExpectedTime_+3A_j">j</code></td>
<td>
<p>Final state j</p>
</td></tr>
<tr><td><code id="ExpectedTime_+3A_usercpp">useRCpp</code></td>
<td>
<p>logical whether to use Rcpp</p>
</td></tr>
</table>


<h3>Details</h3>

<p>According to the theorem, holding times for all states except j should be greater than 0.
</p>


<h3>Value</h3>

<p>A numerical value that returns expected hitting times from i to j
</p>


<h3>Author(s)</h3>

<p>Vandit Jain
</p>


<h3>References</h3>

<p>Markovchains, J. R. Norris, Cambridge University Press
</p>


<h3>Examples</h3>

<pre><code class='language-R'>states &lt;- c("a","b","c","d")
byRow &lt;- TRUE
gen &lt;- matrix(data = c(-1, 1/2, 1/2, 0, 1/4, -1/2, 0, 1/4, 1/6, 0, -1/3, 1/6, 0, 0, 0, 0),
nrow = 4,byrow = byRow, dimnames = list(states,states))
ctmc &lt;- new("ctmc",states = states, byrow = byRow, generator = gen, name = "testctmc")
ExpectedTime(ctmc,1,4,TRUE)

</code></pre>

<hr>
<h2 id='firstPassage'>First passage across states</h2><span id='topic+firstPassage'></span>

<h3>Description</h3>

<p>This function compute the first passage probability in states
</p>


<h3>Usage</h3>

<pre><code class='language-R'>firstPassage(object, state, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="firstPassage_+3A_object">object</code></td>
<td>
<p>A <code>markovchain</code> object</p>
</td></tr>
<tr><td><code id="firstPassage_+3A_state">state</code></td>
<td>
<p>Initial state</p>
</td></tr>
<tr><td><code id="firstPassage_+3A_n">n</code></td>
<td>
<p>Number of rows on which compute the distribution</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on Feres' Matlab listings
</p>


<h3>Value</h3>

<p>A matrix of size 1:n x number of states showing the probability of the 
first time of passage in states to be exactly the number in the row.
</p>


<h3>Author(s)</h3>

<p>Giorgio Spedicato
</p>


<h3>References</h3>

<p>Renaldo Feres, Notes for Math 450 Matlab listings for Markov chains
</p>


<h3>See Also</h3>

<p><code><a href="#topic+conditionalDistribution">conditionalDistribution</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>simpleMc &lt;- new("markovchain", states = c("a", "b"),
                 transitionMatrix = matrix(c(0.4, 0.6, .3, .7), 
                                    nrow = 2, byrow = TRUE))
firstPassage(simpleMc, "b", 20)

</code></pre>

<hr>
<h2 id='firstPassageMultiple'>function to calculate first passage probabilities</h2><span id='topic+firstPassageMultiple'></span>

<h3>Description</h3>

<p>The function calculates first passage probability for a subset of
states given an initial state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>firstPassageMultiple(object, state, set, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="firstPassageMultiple_+3A_object">object</code></td>
<td>
<p>a markovchain-class object</p>
</td></tr>
<tr><td><code id="firstPassageMultiple_+3A_state">state</code></td>
<td>
<p>intital state of the process (charactervector)</p>
</td></tr>
<tr><td><code id="firstPassageMultiple_+3A_set">set</code></td>
<td>
<p>set of states A, first passage of which is to be calculated</p>
</td></tr>
<tr><td><code id="firstPassageMultiple_+3A_n">n</code></td>
<td>
<p>Number of rows on which compute the distribution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of size n showing the first time proabilities
</p>


<h3>Author(s)</h3>

<p>Vandit Jain
</p>


<h3>References</h3>

<p>Renaldo Feres, Notes for Math 450 Matlab listings for Markov chains;
MIT OCW, course - 6.262, Discrete Stochastic Processes, course-notes, chap -05
</p>


<h3>See Also</h3>

<p><code><a href="#topic+firstPassage">firstPassage</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>statesNames &lt;- c("a", "b", "c")
markovB &lt;- new("markovchain", states = statesNames, transitionMatrix =
matrix(c(0.2, 0.5, 0.3,
         0, 1, 0,
         0.1, 0.8, 0.1), nrow = 3, byrow = TRUE,
       dimnames = list(statesNames, statesNames)
))
firstPassageMultiple(markovB,"a",c("b","c"),4)  

</code></pre>

<hr>
<h2 id='fitHigherOrder'>Functions to fit a higher order Markov chain</h2><span id='topic+fitHigherOrder'></span><span id='topic+seq2freqProb'></span><span id='topic+seq2matHigh'></span>

<h3>Description</h3>

<p>Given a sequence of states arising from a stationary state, it
fits the underlying Markov chain distribution with higher order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitHigherOrder(sequence, order = 2)
seq2freqProb(sequence)
seq2matHigh(sequence, order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitHigherOrder_+3A_sequence">sequence</code></td>
<td>
<p>A character list.</p>
</td></tr>
<tr><td><code id="fitHigherOrder_+3A_order">order</code></td>
<td>
<p>Markov chain order</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing lambda, Q, and X.
</p>


<h3>Author(s)</h3>

<p>Giorgio Spedicato, Tae Seung Kang
</p>


<h3>References</h3>

<p>Ching, W. K., Huang, X., Ng, M. K., &amp; Siu, T. K. (2013). Higher-order markov 
chains. In Markov Chains (pp. 141-176). Springer US.
</p>
<p>Ching, W. K., Ng, M. K., &amp; Fung, E. S. (2008). Higher-order multivariate
Markov chains and their applications. Linear Algebra and its Applications,
428(2), 492-507.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sequence&lt;-c("a", "a", "b", "b", "a", "c", "b", "a", "b", "c", "a", "b",
            "c", "a", "b", "c", "a", "b", "a", "b")
fitHigherOrder(sequence)

</code></pre>

<hr>
<h2 id='fitHighOrderMultivarMC'>Function to fit Higher Order Multivariate Markov chain</h2><span id='topic+fitHighOrderMultivarMC'></span>

<h3>Description</h3>

<p>Given a matrix of categorical sequences it fits 
Higher Order Multivariate Markov chain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitHighOrderMultivarMC(seqMat, order = 2, Norm = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitHighOrderMultivarMC_+3A_seqmat">seqMat</code></td>
<td>
<p>a matrix or a data frame where each column 
is a categorical sequence</p>
</td></tr>
<tr><td><code id="fitHighOrderMultivarMC_+3A_order">order</code></td>
<td>
<p>Multivariate Markov chain order. Default is 2.</p>
</td></tr>
<tr><td><code id="fitHighOrderMultivarMC_+3A_norm">Norm</code></td>
<td>
<p>Norm to be used. Default is 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an hommc object
</p>


<h3>Author(s)</h3>

<p>Giorgio Spedicato, Deepak Yadav
</p>


<h3>References</h3>

<p>W.-K. Ching et al. / Linear Algebra and its Applications
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- matrix(c('2', '1', '3', '3', '4', '3', '2', '1', '3', '3', '2', '1', 
               c('2', '4', '4', '4', '4', '2', '3', '3', '1', '4', '3', '3')), 
               ncol = 2, byrow = FALSE)
               
fitHighOrderMultivarMC(data, order = 2, Norm = 2)                

</code></pre>

<hr>
<h2 id='freq2Generator'>Returns a generator matrix corresponding to frequency matrix</h2><span id='topic+freq2Generator'></span>

<h3>Description</h3>

<p>The function provides interface to calculate generator matrix corresponding to 
a frequency matrix and time taken
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freq2Generator(P, t = 1, method = "QO", logmethod = "Eigen")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freq2Generator_+3A_p">P</code></td>
<td>
<p>relative frequency matrix</p>
</td></tr>
<tr><td><code id="freq2Generator_+3A_t">t</code></td>
<td>
<p>(default value = 1)</p>
</td></tr>
<tr><td><code id="freq2Generator_+3A_method">method</code></td>
<td>
<p>one among &quot;QO&quot;(Quasi optimaisation), &quot;WA&quot;(weighted adjustment), &quot;DA&quot;(diagonal adjustment)</p>
</td></tr>
<tr><td><code id="freq2Generator_+3A_logmethod">logmethod</code></td>
<td>
<p>method for computation of matrx algorithm (by default : Eigen)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a generator matix with same dimnames
</p>


<h3>References</h3>

<p>E. Kreinin and M. Sidelnikova: Regularization Algorithms for
Transition Matrices. Algo Research Quarterly 4(1):23-40, 2001
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sample &lt;- matrix(c(150,2,1,1,1,200,2,1,2,1,175,1,1,1,1,150),nrow = 4,byrow = TRUE)
sample_rel = rbind((sample/rowSums(sample))[1:dim(sample)[1]-1,],c(rep(0,dim(sample)[1]-1),1)) 
freq2Generator(sample_rel,1)

data(tm_abs)
tm_rel=rbind((tm_abs/rowSums(tm_abs))[1:7,],c(rep(0,7),1))
## Derive quasi optimization generator matrix estimate
freq2Generator(tm_rel,1)

</code></pre>

<hr>
<h2 id='generatorToTransitionMatrix'>Function to obtain the transition matrix from the generator</h2><span id='topic+generatorToTransitionMatrix'></span>

<h3>Description</h3>

<p>The transition matrix of the embedded DTMC is inferred from the CTMC's generator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generatorToTransitionMatrix(gen, byrow = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generatorToTransitionMatrix_+3A_gen">gen</code></td>
<td>
<p>The generator matrix</p>
</td></tr>
<tr><td><code id="generatorToTransitionMatrix_+3A_byrow">byrow</code></td>
<td>
<p>Flag to determine if rows (columns) sum to 0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the transition matrix.
</p>


<h3>Author(s)</h3>

<p>Sai Bhargav Yalamanchi
</p>


<h3>References</h3>

<p>Introduction to Stochastic Processes with Applications in the Biosciences (2013), David F.
Anderson, University of Wisconsin at Madison
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rctmc">rctmc</a></code>,<code><a href="#topic+ctmc-class">ctmc-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>energyStates &lt;- c("sigma", "sigma_star")
byRow &lt;- TRUE
gen &lt;- matrix(data = c(-3, 3, 1, -1), nrow = 2,
              byrow = byRow, dimnames = list(energyStates, energyStates))
generatorToTransitionMatrix(gen)

</code></pre>

<hr>
<h2 id='HigherOrderMarkovChain-class'>Higher order Markov Chains class</h2><span id='topic+HigherOrderMarkovChain-class'></span>

<h3>Description</h3>

<p>The S4 class that describes <code>HigherOrderMarkovChain</code> objects.
</p>

<hr>
<h2 id='hittingProbabilities'>Hitting probabilities for markovchain</h2><span id='topic+hittingProbabilities'></span>

<h3>Description</h3>

<p>Given a markovchain object,
this function calculates the probability of ever arriving from state i to j
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hittingProbabilities(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hittingProbabilities_+3A_object">object</code></td>
<td>
<p>the markovchain-class object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of hitting probabilities
</p>


<h3>Author(s)</h3>

<p>Ignacio Cordón
</p>


<h3>References</h3>

<p>R. Vélez, T. Prieto, Procesos Estocásticos, Librería UNED, 2013
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- markovchain:::zeros(5)
M[1,1] &lt;- M[5,5] &lt;- 1
M[2,1] &lt;- M[2,3] &lt;- 1/2
M[3,2] &lt;- M[3,4] &lt;- 1/2
M[4,2] &lt;- M[4,5] &lt;- 1/2

mc &lt;- new("markovchain", transitionMatrix = M)
hittingProbabilities(mc)

</code></pre>

<hr>
<h2 id='holson'>Holson data set</h2><span id='topic+holson'></span>

<h3>Description</h3>

<p>A data set containing 1000 life histories trajectories and a categorical status (1,2,3) observed on eleven evenly spaced steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(holson)
</code></pre>


<h3>Format</h3>

<p>A data frame with 1000 observations on the following 12 variables.
</p>

<dl>
<dt><code>id</code></dt><dd><p>unique id</p>
</dd>
<dt><code>time1</code></dt><dd><p>observed status at i-th time</p>
</dd>
<dt><code>time2</code></dt><dd><p>observed status at i-th time</p>
</dd>
<dt><code>time3</code></dt><dd><p>observed status at i-th time</p>
</dd>
<dt><code>time4</code></dt><dd><p>observed status at i-th time</p>
</dd>
<dt><code>time5</code></dt><dd><p>observed status at i-th time</p>
</dd>
<dt><code>time6</code></dt><dd><p>observed status at i-th time</p>
</dd>
<dt><code>time7</code></dt><dd><p>observed status at i-th time</p>
</dd>
<dt><code>time8</code></dt><dd><p>observed status at i-th time</p>
</dd>
<dt><code>time9</code></dt><dd><p>observed status at i-th time</p>
</dd>
<dt><code>time10</code></dt><dd><p>observed status at i-th time</p>
</dd>
<dt><code>time11</code></dt><dd><p>observed status at i-th time</p>
</dd>
</dl>



<h3>Details</h3>

<p>The example can be used to fit a <code>markovchain</code> or a <code>markovchainList</code> object.
</p>


<h3>Source</h3>

<p>Private communications
</p>


<h3>References</h3>

<p>Private communications
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(holson)
head(holson)
</code></pre>

<hr>
<h2 id='hommc-class'>An S4 class for representing High Order Multivariate Markovchain (HOMMC)</h2><span id='topic+hommc-class'></span><span id='topic+hommc'></span>

<h3>Description</h3>

<p>An S4 class for representing High Order Multivariate Markovchain (HOMMC)
</p>


<h3>Slots</h3>


<dl>
<dt><code>order</code></dt><dd><p>an integer equal to order of Multivariate Markovchain</p>
</dd>
<dt><code>states</code></dt><dd><p>a vector of states present in the HOMMC model</p>
</dd>
<dt><code>P</code></dt><dd><p>array of transition matrices</p>
</dd>
<dt><code>Lambda</code></dt><dd><p>a vector which stores the weightage of each transition matrices in P</p>
</dd>
<dt><code>byrow</code></dt><dd><p>if FALSE each column sum of transition matrix is 1 else row sum = 1</p>
</dd>
<dt><code>name</code></dt><dd><p>a name given to hommc</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Giorgio Spedicato, Deepak Yadav
</p>


<h3>Examples</h3>

<pre><code class='language-R'>statesName &lt;- c("a", "b")

P &lt;- array(0, dim = c(2, 2, 4), dimnames = list(statesName, statesName))
P[,,1] &lt;- matrix(c(0, 1, 1/3, 2/3), byrow = FALSE, nrow = 2)
P[,,2] &lt;- matrix(c(1/4, 3/4, 0, 1), byrow = FALSE, nrow = 2)
P[,,3] &lt;- matrix(c(1, 0, 1/3, 2/3), byrow = FALSE, nrow = 2)
P[,,4] &lt;- matrix(c(3/4, 1/4, 0, 1), byrow = FALSE, nrow = 2)

Lambda &lt;- c(0.8, 0.2, 0.3, 0.7)

ob &lt;- new("hommc", order = 1, states = statesName, P = P, 
          Lambda = Lambda, byrow = FALSE, name = "FOMMC")
          
</code></pre>

<hr>
<h2 id='ictmc-class'>An S4 class for representing Imprecise Continuous Time Markovchains</h2><span id='topic+ictmc-class'></span><span id='topic+ictmc'></span>

<h3>Description</h3>

<p>An S4 class for representing Imprecise Continuous Time Markovchains
</p>


<h3>Slots</h3>


<dl>
<dt><code>states</code></dt><dd><p>a vector of states present in the ICTMC model</p>
</dd>
<dt><code>Q</code></dt><dd><p>matrix representing the generator demonstrated in the form of variables</p>
</dd>
<dt><code>range</code></dt><dd><p>a matrix that stores values of range of variables</p>
</dd>
<dt><code>name</code></dt><dd><p>name given to ICTMC</p>
</dd>
</dl>

<hr>
<h2 id='impreciseProbabilityatT'>Calculating full conditional probability using lower rate transition matrix</h2><span id='topic+impreciseProbabilityatT'></span>

<h3>Description</h3>

<p>This function calculates full conditional probability at given 
time s using lower rate transition matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impreciseProbabilityatT(C,i,t,s,error,useRCpp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impreciseProbabilityatT_+3A_c">C</code></td>
<td>
<p>a ictmc class object</p>
</td></tr>
<tr><td><code id="impreciseProbabilityatT_+3A_i">i</code></td>
<td>
<p>initial state at time t</p>
</td></tr>
<tr><td><code id="impreciseProbabilityatT_+3A_t">t</code></td>
<td>
<p>initial time t. Default value = 0</p>
</td></tr>
<tr><td><code id="impreciseProbabilityatT_+3A_s">s</code></td>
<td>
<p>final time</p>
</td></tr>
<tr><td><code id="impreciseProbabilityatT_+3A_error">error</code></td>
<td>
<p>error rate. Default value = 0.001</p>
</td></tr>
<tr><td><code id="impreciseProbabilityatT_+3A_usercpp">useRCpp</code></td>
<td>
<p>logical whether to use RCpp implementation; by default TRUE</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Vandit Jain
</p>


<h3>References</h3>

<p>Imprecise Continuous-Time Markov Chains, Thomas Krak et al., 2016
</p>


<h3>Examples</h3>

<pre><code class='language-R'>states &lt;- c("n","y")
Q &lt;- matrix(c(-1,1,1,-1),nrow = 2,byrow = TRUE,dimnames = list(states,states))
range &lt;- matrix(c(1/52,3/52,1/2,2),nrow = 2,byrow = 2)
name &lt;- "testictmc"
ictmc &lt;- new("ictmc",states = states,Q = Q,range = range,name = name)
impreciseProbabilityatT(ictmc,2,0,1,10^-3,TRUE)
</code></pre>

<hr>
<h2 id='inferHyperparam'>Function to infer the hyperparameters for Bayesian inference from an a priori matrix or a data set</h2><span id='topic+inferHyperparam'></span>

<h3>Description</h3>

<p>Since the Bayesian inference approach implemented in the package is based on conjugate priors, 
hyperparameters must be provided to model the prior probability distribution of the chain 
parameters. The hyperparameters are inferred from a given a priori matrix under the assumption 
that the matrix provided corresponds to the mean (expected) values of the chain parameters. A 
scaling factor vector must be provided too. Alternatively, the hyperparameters can be inferred 
from a data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inferHyperparam(transMatr = matrix(), scale = numeric(), data = character())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inferHyperparam_+3A_transmatr">transMatr</code></td>
<td>
<p>A valid transition matrix, with dimension names.</p>
</td></tr>
<tr><td><code id="inferHyperparam_+3A_scale">scale</code></td>
<td>
<p>A vector of scaling factors, each element corresponds to the row names of the provided transition 
matrix transMatr, in the same order.</p>
</td></tr>
<tr><td><code id="inferHyperparam_+3A_data">data</code></td>
<td>
<p>A data set from which the hyperparameters are inferred.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>transMatr and scale need not be provided if data is provided.
</p>


<h3>Value</h3>

<p>Returns the hyperparameter matrix in a list.
</p>


<h3>Note</h3>

<p>The hyperparameter matrix returned is such that the row and column names are sorted alphanumerically, 
and the elements in the matrix are correspondingly permuted.
</p>


<h3>Author(s)</h3>

<p>Sai Bhargav Yalamanchi, Giorgio Spedicato
</p>


<h3>References</h3>

<p>Yalamanchi SB, Spedicato GA (2015). Bayesian Inference of First Order Markov Chains. R
package version 0.2.5
</p>


<h3>See Also</h3>

<p><code><a href="#topic+markovchainFit">markovchainFit</a></code>, <code><a href="#topic+predictiveDistribution">predictiveDistribution</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rain, package = "markovchain")
inferHyperparam(data = rain$rain)
 
weatherStates &lt;- c("sunny", "cloudy", "rain")
weatherMatrix &lt;- matrix(data = c(0.7, 0.2, 0.1, 
                                 0.3, 0.4, 0.3, 
                                 0.2, 0.4, 0.4), 
                        byrow = TRUE, nrow = 3, 
                        dimnames = list(weatherStates, weatherStates))
inferHyperparam(transMatr = weatherMatrix, scale = c(10, 10, 10))
 
</code></pre>

<hr>
<h2 id='is.accessible'>Verify if a state j is reachable from state i.</h2><span id='topic+is.accessible'></span>

<h3>Description</h3>

<p>This function verifies if a state is reachable from another, i.e., 
if there exists a path that leads to state j leaving from state i with 
positive probability
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.accessible(object, from, to)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.accessible_+3A_object">object</code></td>
<td>
<p>A <code>markovchain</code> object.</p>
</td></tr>
<tr><td><code id="is.accessible_+3A_from">from</code></td>
<td>
<p>The name of state &quot;i&quot; (beginning state).</p>
</td></tr>
<tr><td><code id="is.accessible_+3A_to">to</code></td>
<td>
<p>The name of state &quot;j&quot; (ending state).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It wraps an internal function named <code>reachabilityMatrix</code>.
</p>


<h3>Value</h3>

<p>A boolean value.
</p>


<h3>Author(s)</h3>

<p>Giorgio Spedicato, Ignacio Cordón
</p>


<h3>References</h3>

<p>James Montgomery, University of Madison
</p>


<h3>See Also</h3>

<p><code>is.irreducible</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>statesNames &lt;- c("a", "b", "c")
markovB &lt;- new("markovchain", states = statesNames, 
               transitionMatrix = matrix(c(0.2, 0.5, 0.3,
                                             0,   1,   0,
                                           0.1, 0.8, 0.1), nrow = 3, byrow = TRUE, 
                                         dimnames = list(statesNames, statesNames)
                                        )
               )
is.accessible(markovB, "a", "c")

</code></pre>

<hr>
<h2 id='is.CTMCirreducible'>Check if CTMC is irreducible</h2><span id='topic+is.CTMCirreducible'></span>

<h3>Description</h3>

<p>This function verifies whether a CTMC object is irreducible
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.CTMCirreducible(ctmc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.CTMCirreducible_+3A_ctmc">ctmc</code></td>
<td>
<p>a ctmc-class object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a boolean value as described above.
</p>


<h3>Author(s)</h3>

<p>Vandit Jain
</p>


<h3>References</h3>

<p>Continuous-Time Markov Chains, Karl Sigman, Columbia University
</p>


<h3>Examples</h3>

<pre><code class='language-R'>energyStates &lt;- c("sigma", "sigma_star")
byRow &lt;- TRUE
gen &lt;- matrix(data = c(-3, 3,
                       1, -1), nrow = 2,
              byrow = byRow, dimnames = list(energyStates, energyStates))
molecularCTMC &lt;- new("ctmc", states = energyStates, 
                     byrow = byRow, generator = gen, 
                     name = "Molecular Transition Model")
is.CTMCirreducible(molecularCTMC)

</code></pre>

<hr>
<h2 id='is.irreducible'>Function to check if a Markov chain is irreducible (i.e. ergodic)</h2><span id='topic+is.irreducible'></span>

<h3>Description</h3>

<p>This function verifies whether a <code>markovchain</code> object transition matrix 
is composed by only one communicating class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.irreducible(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.irreducible_+3A_object">object</code></td>
<td>
<p>A <code>markovchain</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is based on <code>.communicatingClasses</code> internal function.
</p>


<h3>Value</h3>

<p>A boolean values.
</p>


<h3>Author(s)</h3>

<p>Giorgio Spedicato
</p>


<h3>References</h3>

<p>Feres, Matlab listings for Markov Chains.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+summary">summary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>statesNames &lt;- c("a", "b")
mcA &lt;- new("markovchain", transitionMatrix = matrix(c(0.7,0.3,0.1,0.9),
                                             byrow = TRUE, nrow = 2, 
                                             dimnames = list(statesNames, statesNames)
           ))
is.irreducible(mcA)

</code></pre>

<hr>
<h2 id='is.regular'>Check if a DTMC is regular</h2><span id='topic+is.regular'></span>

<h3>Description</h3>

<p>Function to check wether a DTCM is regular
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.regular(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.regular_+3A_object">object</code></td>
<td>
<p>a markovchain object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A Markov chain is regular if some of the powers of its matrix has all elements 
strictly positive
</p>


<h3>Value</h3>

<p>A boolean value
</p>


<h3>Author(s)</h3>

<p>Ignacio Cordón
</p>


<h3>References</h3>

<p>Matrix Analysis. Roger A.Horn, Charles R.Johnson. 2nd edition. 
Corollary 8.5.8, Theorem 8.5.9
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.irreducible">is.irreducible</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P &lt;- matrix(c(0.5,  0.25, 0.25,
              0.5,     0, 0.5,
              0.25, 0.25, 0.5), nrow = 3)
colnames(P) &lt;- rownames(P) &lt;- c("R","N","S")
ciao &lt;- as(P, "markovchain")
is.regular(ciao)

</code></pre>

<hr>
<h2 id='is.TimeReversible'>checks if ctmc object is time reversible</h2><span id='topic+is.TimeReversible'></span>

<h3>Description</h3>

<p>The function returns checks if provided function is time reversible
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.TimeReversible(ctmc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.TimeReversible_+3A_ctmc">ctmc</code></td>
<td>
<p>a ctmc-class object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a boolean value stating whether ctmc object is time reversible
</p>
<p>a boolean value as described above
</p>


<h3>Author(s)</h3>

<p>Vandit Jain
</p>


<h3>References</h3>

<p>INTRODUCTION TO STOCHASTIC PROCESSES WITH R, ROBERT P. DOBROW, Wiley
</p>


<h3>Examples</h3>

<pre><code class='language-R'>energyStates &lt;- c("sigma", "sigma_star")
byRow &lt;- TRUE
gen &lt;- matrix(data = c(-3, 3,
                       1, -1), nrow = 2,
              byrow = byRow, dimnames = list(energyStates, energyStates))
molecularCTMC &lt;- new("ctmc", states = energyStates, 
                     byrow = byRow, generator = gen, 
                     name = "Molecular Transition Model")
is.TimeReversible(molecularCTMC)

</code></pre>

<hr>
<h2 id='kullback'>Example from Kullback and Kupperman Tests for Contingency Tables</h2><span id='topic+kullback'></span>

<h3>Description</h3>

<p>A list of two matrices representing raw transitions between two states
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(kullback)
</code></pre>


<h3>Format</h3>

<p>A list containing two 6x6 non - negative integer matrices
</p>

<hr>
<h2 id='markovchain-class'>Markov Chain class</h2><span id='topic+markovchain-class'></span><span id='topic++2A+2Cmarkovchain+2Cmarkovchain-method'></span><span id='topic++2A+2Cmarkovchain+2Cmatrix-method'></span><span id='topic++2A+2Cmarkovchain+2Cnumeric-method'></span><span id='topic++2A+2Cmatrix+2Cmarkovchain-method'></span><span id='topic++2A+2Cnumeric+2Cmarkovchain-method'></span><span id='topic++3D+3D+2Cmarkovchain+2Cmarkovchain-method'></span><span id='topic++21+3D+2Cmarkovchain+2Cmarkovchain-method'></span><span id='topic+absorbingStates+2Cmarkovchain-method'></span><span id='topic+transientStates+2Cmarkovchain-method'></span><span id='topic+recurrentStates+2Cmarkovchain-method'></span><span id='topic+transientClasses+2Cmarkovchain-method'></span><span id='topic+recurrentClasses+2Cmarkovchain-method'></span><span id='topic+communicatingClasses+2Cmarkovchain-method'></span><span id='topic+steadyStates+2Cmarkovchain-method'></span><span id='topic+meanNumVisits+2Cmarkovchain-method'></span><span id='topic+is.regular+2Cmarkovchain-method'></span><span id='topic+is.irreducible+2Cmarkovchain-method'></span><span id='topic+is.accessible+2Cmarkovchain+2Ccharacter+2Ccharacter-method'></span><span id='topic+is.accessible+2Cmarkovchain+2Cmissing+2Cmissing-method'></span><span id='topic+absorptionProbabilities+2Cmarkovchain-method'></span><span id='topic+meanFirstPassageTime+2Cmarkovchain+2Ccharacter-method'></span><span id='topic+meanFirstPassageTime+2Cmarkovchain+2Cmissing-method'></span><span id='topic+meanAbsorptionTime+2Cmarkovchain-method'></span><span id='topic+meanRecurrenceTime+2Cmarkovchain-method'></span><span id='topic+conditionalDistribution+2Cmarkovchain-method'></span><span id='topic+hittingProbabilities+2Cmarkovchain-method'></span><span id='topic+canonicForm+2Cmarkovchain-method'></span><span id='topic+coerce+2Cdata.frame+2Cmarkovchain-method'></span><span id='topic+coerce+2Cmarkovchain+2Cdata.frame-method'></span><span id='topic+coerce+2Ctable+2Cmarkovchain-method'></span><span id='topic+coerce+2Cmarkovchain+2Cigraph-method'></span><span id='topic+coerce+2Cmarkovchain+2Cmatrix-method'></span><span id='topic+coerce+2Cmarkovchain+2CsparseMatrix-method'></span><span id='topic+coerce+2CsparseMatrix+2Cmarkovchain-method'></span><span id='topic+coerce+2Cmatrix+2Cmarkovchain-method'></span><span id='topic+coerce+2Cmsm+2Cmarkovchain-method'></span><span id='topic+coerce+2Cmsm.est+2Cmarkovchain-method'></span><span id='topic+coerce+2Cetm+2Cmarkovchain-method'></span><span id='topic+dim+2Cmarkovchain-method'></span><span id='topic+initialize+2Cmarkovchain-method'></span><span id='topic+names+3C-+2Cmarkovchain-method'></span><span id='topic+plot+2Cmarkovchain+2Cmissing-method'></span><span id='topic+predict+2Cmarkovchain-method'></span><span id='topic+print+2Cmarkovchain-method'></span><span id='topic+show+2Cmarkovchain-method'></span><span id='topic+summary+2Cmarkovchain-method'></span><span id='topic+sort+2Cmarkovchain-method'></span><span id='topic+t+2Cmarkovchain-method'></span><span id='topic++5B+2Cmarkovchain+2CANY+2CANY+2CANY-method'></span><span id='topic++5E+2Cmarkovchain+2Cnumeric-method'></span>

<h3>Description</h3>

<p>The S4 class that describes <code>markovchain</code> objects.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="markovchain-class_+3A_states">states</code></td>
<td>
<p>Name of the states. Must be the same of <code>colnames</code> and <code>rownames</code> of the transition matrix</p>
</td></tr>
<tr><td><code id="markovchain-class_+3A_byrow">byrow</code></td>
<td>
<p>TRUE or FALSE indicating whether the supplied matrix 
is either stochastic by rows or by columns</p>
</td></tr>
<tr><td><code id="markovchain-class_+3A_transitionmatrix">transitionMatrix</code></td>
<td>
<p>Square transition matrix</p>
</td></tr>
<tr><td><code id="markovchain-class_+3A_name">name</code></td>
<td>
<p>Optional character name of the Markov chain</p>
</td></tr>
</table>


<h3>Creation of objects</h3>

<p>Objects can be created by calls of the form <code>new("markovchain", states, byrow, transitionMatrix, ...)</code>.
</p>


<h3>Methods</h3>


<dl>
<dt>*</dt><dd><p><code>signature(e1 = "markovchain", e2 = "markovchain")</code>: multiply two <code>markovchain</code> objects</p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "markovchain", e2 = "matrix")</code>: markovchain by matrix multiplication</p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "markovchain", e2 = "numeric")</code>: markovchain by numeric vector multiplication </p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "matrix", e2 = "markovchain")</code>: matrix by markov chain</p>
</dd>
<dt>*</dt><dd><p><code>signature(e1 = "numeric", e2 = "markovchain")</code>: numeric vector by <code>markovchain</code> multiplication   </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "markovchain", i = "ANY", j = "ANY", drop = "ANY")</code>: ... </p>
</dd>
<dt>^</dt><dd><p><code>signature(e1 = "markovchain", e2 = "numeric")</code>: power of a <code>markovchain</code> object</p>
</dd>
<dt>==</dt><dd><p><code>signature(e1 = "markovchain", e2 = "markovchain")</code>: equality of two <code>markovchain</code> object</p>
</dd>
<dt>!=</dt><dd><p><code>signature(e1 = "markovchain", e2 = "markovchain")</code>: non-equality of two <code>markovchain</code> object</p>
</dd>
<dt>absorbingStates</dt><dd><p><code>signature(object = "markovchain")</code>: method to get absorbing states </p>
</dd>
<dt>canonicForm</dt><dd><p><code>signature(object = "markovchain")</code>: return a <code>markovchain</code> object into canonic form </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "markovchain", to = "data.frame")</code>: coerce method from markovchain to <code>data.frame</code></p>
</dd>
<dt>conditionalDistribution</dt><dd><p><code>signature(object = "markovchain")</code>: returns the conditional probability of subsequent states given a state</p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "data.frame", to = "markovchain")</code>: coerce method from <code>data.frame</code> to <code>markovchain</code></p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "table", to = "markovchain")</code>: coerce method from <code>table</code> to <code>markovchain</code> </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "msm", to = "markovchain")</code>: coerce method from <code>msm</code> to <code>markovchain</code> </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "msm.est", to = "markovchain")</code>: coerce method from <code>msm.est</code> (but only from a Probability Matrix) to <code>markovchain</code> </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "etm", to = "markovchain")</code>: coerce method from <code>etm</code> to <code>markovchain</code> </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "sparseMatrix", to = "markovchain")</code>: coerce method from <code>sparseMatrix</code> to <code>markovchain</code> </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "markovchain", to = "igraph")</code>: coercing to <code>igraph</code> objects </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "markovchain", to = "matrix")</code>: coercing to <code>matrix</code> objects </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "markovchain", to = "sparseMatrix")</code>: coercing to <code>sparseMatrix</code> objects </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "matrix", to = "markovchain")</code>: coercing to <code>markovchain</code> objects from <code>matrix</code> one </p>
</dd>
<dt>dim</dt><dd><p><code>signature(x = "markovchain")</code>: method to get the size</p>
</dd>
<dt>names</dt><dd><p><code>signature(x = "markovchain")</code>: method to get the names of states</p>
</dd>
<dt>names&lt;-</dt><dd><p><code>signature(x = "markovchain", value = "character")</code>: method to set the names of states</p>
</dd>
<dt>initialize</dt><dd><p><code>signature(.Object = "markovchain")</code>: initialize method </p>
</dd>
<dt>plot</dt><dd><p><code>signature(x = "markovchain", y = "missing")</code>: plot method for <code>markovchain</code> objects </p>
</dd>
<dt>predict</dt><dd><p><code>signature(object = "markovchain")</code>: predict method </p>
</dd>
<dt>print</dt><dd><p><code>signature(x = "markovchain")</code>: print method. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "markovchain")</code>: show method. </p>
</dd>
<dt>sort</dt><dd><p><code>signature(x = "markovchain", decreasing=FALSE)</code>: sorting the transition matrix. </p>
</dd>
<dt>states</dt><dd><p><code>signature(object = "markovchain")</code>: returns the names of states (as <code>names</code>. </p>
</dd>
<dt>steadyStates</dt><dd><p><code>signature(object = "markovchain")</code>: method to get the steady vector. </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "markovchain")</code>: method to summarize structure of the markov chain </p>
</dd>
<dt>transientStates</dt><dd><p><code>signature(object = "markovchain")</code>: method to get the transient states. </p>
</dd>
<dt>t</dt><dd><p><code>signature(x = "markovchain")</code>: transpose matrix </p>
</dd>
<dt>transitionProbability</dt><dd><p><code>signature(object = "markovchain")</code>: transition probability </p>
</dd>
</dl>



<h3>Note</h3>


<ol>
<li> <p><code>markovchain</code> object are backed by S4 Classes.
</p>
</li>
<li><p> Validation method is used to assess whether either columns or rows totals to one. 
Rounding is used up to <code>.Machine$double.eps * 100</code>. If state names are not properly
defined for a probability  <code>matrix</code>, coercing to <code>markovhcain</code> object leads 
to overriding states name with artificial &quot;s1&quot;, &quot;s2&quot;, ... sequence. In addition, operator
overloading has been applied for <code class="reqn">+,*,^,==,!=</code> operators.
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Giorgio Spedicato
</p>


<h3>References</h3>

<p>A First Course in Probability (8th Edition), Sheldon Ross, Prentice Hall 2010
</p>


<h3>See Also</h3>

<p><code><a href="#topic+markovchainSequence">markovchainSequence</a></code>,<code><a href="#topic+markovchainFit">markovchainFit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#show markovchain definition
showClass("markovchain")
#create a simple Markov chain
transMatr&lt;-matrix(c(0.4,0.6,.3,.7),nrow=2,byrow=TRUE)
simpleMc&lt;-new("markovchain", states=c("a","b"),
              transitionMatrix=transMatr, 
              name="simpleMc")
#power
simpleMc^4
#some methods
steadyStates(simpleMc)
absorbingStates(simpleMc)
simpleMc[2,1]
t(simpleMc)
is.irreducible(simpleMc)
#conditional distributions
conditionalDistribution(simpleMc, "b")
#example for predict method
sequence&lt;-c("a", "b", "a", "a", "a", "a", "b", "a", "b", "a", "b", "a", "a", "b", "b", "b", "a")
mcFit&lt;-markovchainFit(data=sequence)
predict(mcFit$estimate, newdata="b",n.ahead=3)
#direct conversion
myMc&lt;-as(transMatr, "markovchain")

#example of summary
summary(simpleMc)
## Not run: plot(simpleMc)

</code></pre>

<hr>
<h2 id='markovchainList-class'>Non homogeneus discrete time Markov Chains class</h2><span id='topic+markovchainList-class'></span><span id='topic++5B+5B+2CmarkovchainList-method'></span><span id='topic+dim+2CmarkovchainList-method'></span><span id='topic+predict+2CmarkovchainList-method'></span><span id='topic+print+2CmarkovchainList-method'></span><span id='topic+show+2CmarkovchainList-method'></span>

<h3>Description</h3>

<p>A class to handle non homogeneous discrete Markov chains
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="markovchainList-class_+3A_markovchains">markovchains</code></td>
<td>
<p>Object of class <code>"list"</code>: a list of markovchains</p>
</td></tr>
<tr><td><code id="markovchainList-class_+3A_name">name</code></td>
<td>
<p>Object of class <code>"character"</code>: optional name of the class</p>
</td></tr>
</table>


<h3>Objects from the Class</h3>

<p>A <code>markovchainlist</code> is a list of <code>markovchain</code> objects. They can
be used to model non homogeneous discrete time Markov Chains, when
transition probabilities (and possible states) change by time.
</p>


<h3>Methods</h3>


<dl>
<dt>[[</dt><dd><p><code>signature(x = "markovchainList")</code>: extract the
i-th <code>markovchain</code> </p>
</dd>
<dt>dim</dt><dd><p><code>signature(x = "markovchainList")</code>: number 
of <code>markovchain</code> underlying the matrix </p>
</dd>
<dt>predict</dt><dd><p><code>signature(object = "markovchainList")</code>: predict 
from a <code>markovchainList</code> </p>
</dd>
<dt>print</dt><dd><p><code>signature(x = "markovchainList")</code>: prints the list 
of markovchains </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "markovchainList")</code>: same as <code>print</code> </p>
</dd>
</dl>



<h3>Note</h3>

<p>The class consists in a list of <code>markovchain</code> objects. 
It is aimed at working with non homogeneous Markov chains.
</p>


<h3>Author(s)</h3>

<p>Giorgio Spedicato
</p>


<h3>References</h3>

<p>A First Course in Probability (8th Edition), Sheldon Ross, Prentice Hall 2010
</p>


<h3>See Also</h3>

<p><code><a href="#topic+markovchain-class">markovchain</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("markovchainList")
#define a markovchainList
statesNames=c("a","b")

mcA&lt;-new("markovchain",name="MCA", 
         transitionMatrix=matrix(c(0.7,0.3,0.1,0.9),
                          byrow=TRUE, nrow=2, 
                          dimnames=list(statesNames,statesNames))
        )
                                                           
mcB&lt;-new("markovchain", states=c("a","b","c"), name="MCB",
         transitionMatrix=matrix(c(0.2,0.5,0.3,0,1,0,0.1,0.8,0.1),
         nrow=3, byrow=TRUE))
 
mcC&lt;-new("markovchain", states=c("a","b","c","d"), name="MCC",
         transitionMatrix=matrix(c(0.25,0.75,0,0,0.4,0.6,
                                   0,0,0,0,0.1,0.9,0,0,0.7,0.3), 
                                 nrow=4, byrow=TRUE)
)
mcList&lt;-new("markovchainList",markovchains=list(mcA, mcB, mcC), 
           name="Non - homogeneous Markov Chain")

</code></pre>

<hr>
<h2 id='markovchainListFit'>markovchainListFit</h2><span id='topic+markovchainListFit'></span>

<h3>Description</h3>

<p>Given a data frame or a matrix (rows are observations, by cols 
the temporal sequence), it fits a non - homogeneous discrete time markov chain 
process (storing row). In particular a markovchainList of size = ncol - 1 is obtained
estimating transitions from the n samples given by consecutive column pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>markovchainListFit(data, byrow = TRUE, laplacian = 0, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="markovchainListFit_+3A_data">data</code></td>
<td>
<p>Either a matrix or a data.frame or a list object.</p>
</td></tr>
<tr><td><code id="markovchainListFit_+3A_byrow">byrow</code></td>
<td>
<p>Indicates whether distinc stochastic processes trajectiories are shown in distinct rows.</p>
</td></tr>
<tr><td><code id="markovchainListFit_+3A_laplacian">laplacian</code></td>
<td>
<p>Laplacian correction (default 0).</p>
</td></tr>
<tr><td><code id="markovchainListFit_+3A_name">name</code></td>
<td>
<p>Optional name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>data</code> contains <code>NAs</code> then the transitions containing <code>NA</code> will be ignored.
</p>


<h3>Value</h3>

<p>A list containing two slots:
estimate (the estimate)
name
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# using holson dataset
data(holson)
# fitting a single markovchain
singleMc &lt;- markovchainFit(data = holson[,2:12])
# fitting a markovchainList
mclistFit &lt;- markovchainListFit(data = holson[, 2:12], name = "holsonMcList")
</code></pre>

<hr>
<h2 id='markovchainSequence'>Function to generate a sequence of states from homogeneous Markov chains.</h2><span id='topic+markovchainSequence'></span>

<h3>Description</h3>

<p>Provided any <code>markovchain</code> object, it returns a sequence of 
states coming from the underlying stationary distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>markovchainSequence(
  n,
  markovchain,
  t0 = sample(markovchain@states, 1),
  include.t0 = FALSE,
  useRCpp = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="markovchainSequence_+3A_n">n</code></td>
<td>
<p>Sample size</p>
</td></tr>
<tr><td><code id="markovchainSequence_+3A_markovchain">markovchain</code></td>
<td>
<p><code>markovchain</code> object</p>
</td></tr>
<tr><td><code id="markovchainSequence_+3A_t0">t0</code></td>
<td>
<p>The initial state</p>
</td></tr>
<tr><td><code id="markovchainSequence_+3A_include.t0">include.t0</code></td>
<td>
<p>Specify if the initial state shall be used</p>
</td></tr>
<tr><td><code id="markovchainSequence_+3A_usercpp">useRCpp</code></td>
<td>
<p>Boolean. Should RCpp fast implementation being used? Default is yes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A sequence of size n is sampled.
</p>


<h3>Value</h3>

<p>A Character Vector
</p>


<h3>Author(s)</h3>

<p>Giorgio Spedicato
</p>


<h3>References</h3>

<p>A First Course in Probability (8th Edition), Sheldon Ross, Prentice Hall 2010
</p>


<h3>See Also</h3>

<p><code><a href="#topic+markovchainFit">markovchainFit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define the markovchain object
statesNames &lt;- c("a", "b", "c")
mcB &lt;- new("markovchain", states = statesNames, 
   transitionMatrix = matrix(c(0.2, 0.5, 0.3, 0, 0.2, 0.8, 0.1, 0.8, 0.1), 
   nrow = 3, byrow = TRUE, dimnames = list(statesNames, statesNames)))

# show the sequence
outs &lt;- markovchainSequence(n = 100, markovchain = mcB, t0 = "a")

</code></pre>

<hr>
<h2 id='meanAbsorptionTime'>Mean absorption time</h2><span id='topic+meanAbsorptionTime'></span>

<h3>Description</h3>

<p>Computes the expected number of steps to go from any of the
transient states to any of the recurrent states. The Markov chain should
have at least one transient state for this method to work
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanAbsorptionTime(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meanAbsorptionTime_+3A_object">object</code></td>
<td>
<p>the markovchain object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector with the expected number of steps to go from a
transient state to any of the recurrent ones
</p>


<h3>Author(s)</h3>

<p>Ignacio Cordón
</p>


<h3>References</h3>

<p>C. M. Grinstead and J. L. Snell. Introduction to Probability.
American Mathematical Soc., 2012.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(c(1/2, 1/2, 0,
              1/2, 1/2, 0,
                0, 1/2, 1/2), ncol = 3, byrow = TRUE)
mc &lt;- new("markovchain", states = letters[1:3], transitionMatrix = m)
times &lt;- meanAbsorptionTime(mc)

</code></pre>

<hr>
<h2 id='meanFirstPassageTime'>Mean First Passage Time for irreducible Markov chains</h2><span id='topic+meanFirstPassageTime'></span>

<h3>Description</h3>

<p>Given an irreducible (ergodic) markovchain object, this function
calculates the expected number of steps to reach other states
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanFirstPassageTime(object, destination)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meanFirstPassageTime_+3A_object">object</code></td>
<td>
<p>the markovchain object</p>
</td></tr>
<tr><td><code id="meanFirstPassageTime_+3A_destination">destination</code></td>
<td>
<p>a character vector representing the states respect to
which we want to compute the mean first passage time. Empty by default</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For an ergodic Markov chain it computes: 
</p>
 
<ul>
<li><p> If destination is empty, the average first time (in steps) that takes
the Markov chain to go from initial state i to j. (i, j) represents that 
value in case the Markov chain is given row-wise, (j, i) in case it is given
col-wise. 
</p>
</li>
<li><p> If destination is not empty, the average time it takes us from the 
remaining states to reach the states in <code>destination</code> 
</p>
</li></ul>



<h3>Value</h3>

<p>a Matrix of the same size with the average first passage times if
destination is empty, a vector if destination is not
</p>


<h3>Author(s)</h3>

<p>Toni Giorgino, Ignacio Cordón
</p>


<h3>References</h3>

<p>C. M. Grinstead and J. L. Snell. Introduction to Probability.
American Mathematical Soc., 2012.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(1 / 10 * c(6,3,1,
                       2,3,5,
                       4,1,5), ncol = 3, byrow = TRUE)
mc &lt;- new("markovchain", states = c("s","c","r"), transitionMatrix = m)
meanFirstPassageTime(mc, "r")


# Grinstead and Snell's "Oz weather" worked out example
mOz &lt;- matrix(c(2,1,1,
                2,0,2,
                1,1,2)/4, ncol = 3, byrow = TRUE)

mcOz &lt;- new("markovchain", states = c("s", "c", "r"), transitionMatrix = mOz)
meanFirstPassageTime(mcOz)

</code></pre>

<hr>
<h2 id='meanNumVisits'>Mean num of visits for markovchain, starting at each state</h2><span id='topic+meanNumVisits'></span>

<h3>Description</h3>

<p>Given a markovchain object, this function calculates 
a matrix where the element (i, j) represents the expect number of visits
to the state j if the chain starts at i (in a Markov chain by columns it
would be the element (j, i) instead)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanNumVisits(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meanNumVisits_+3A_object">object</code></td>
<td>
<p>the markovchain-class object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with the expect number of visits to each state
</p>


<h3>Author(s)</h3>

<p>Ignacio Cordón
</p>


<h3>References</h3>

<p>R. Vélez, T. Prieto, Procesos Estocásticos, Librería UNED, 2013
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- markovchain:::zeros(5)
M[1,1] &lt;- M[5,5] &lt;- 1
M[2,1] &lt;- M[2,3] &lt;- 1/2
M[3,2] &lt;- M[3,4] &lt;- 1/2
M[4,2] &lt;- M[4,5] &lt;- 1/2

mc &lt;- new("markovchain", transitionMatrix = M)
meanNumVisits(mc)

</code></pre>

<hr>
<h2 id='meanRecurrenceTime'>Mean recurrence time</h2><span id='topic+meanRecurrenceTime'></span>

<h3>Description</h3>

<p>Computes the expected time to return to a recurrent state
in case the Markov chain starts there
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanRecurrenceTime(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meanRecurrenceTime_+3A_object">object</code></td>
<td>
<p>the markovchain object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For a Markov chain it outputs is a named vector with the expected 
time to first return to a state when the chain starts there.
States present in the vector are only the recurrent ones. If the matrix
is ergodic (i.e. irreducible), then all states are present in the output
and order is the same as states order for the Markov chain
</p>


<h3>Author(s)</h3>

<p>Ignacio Cordón
</p>


<h3>References</h3>

<p>C. M. Grinstead and J. L. Snell. Introduction to Probability.
American Mathematical Soc., 2012.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(1 / 10 * c(6,3,1,
                       2,3,5,
                       4,1,5), ncol = 3, byrow = TRUE)
mc &lt;- new("markovchain", states = c("s","c","r"), transitionMatrix = m)
meanRecurrenceTime(mc)

</code></pre>

<hr>
<h2 id='multinomialConfidenceIntervals'>A function to compute multinomial confidence intervals of DTMC</h2><span id='topic+multinomialConfidenceIntervals'></span>

<h3>Description</h3>

<p>Return estimated transition matrix assuming a Multinomial Distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multinomialConfidenceIntervals(
  transitionMatrix,
  countsTransitionMatrix,
  confidencelevel = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multinomialConfidenceIntervals_+3A_transitionmatrix">transitionMatrix</code></td>
<td>
<p>An estimated transition matrix.</p>
</td></tr>
<tr><td><code id="multinomialConfidenceIntervals_+3A_countstransitionmatrix">countsTransitionMatrix</code></td>
<td>
<p>Empirical (conts) transition matrix, on which the <code>transitionMatrix</code> was performed.</p>
</td></tr>
<tr><td><code id="multinomialConfidenceIntervals_+3A_confidencelevel">confidencelevel</code></td>
<td>
<p>confidence interval level.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Two matrices containing the confidence intervals.
</p>


<h3>References</h3>

<p>Constructing two-sided simultaneous confidence intervals 
for multinomial proportions for small counts in a large number of cells. 
Journal of Statistical Software 5(6) (2000)
</p>


<h3>See Also</h3>

<p><code>markovchainFit</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seq&lt;-c("a", "b", "a", "a", "a", "a", "b", "a", "b", "a", "b", "a", "a", "b", "b", "b", "a")
mcfit&lt;-markovchainFit(data=seq,byrow=TRUE)
seqmat&lt;-createSequenceMatrix(seq)
multinomialConfidenceIntervals(mcfit$estimate@transitionMatrix, seqmat, 0.95)
</code></pre>

<hr>
<h2 id='name'>Method to retrieve name of markovchain object</h2><span id='topic+name'></span><span id='topic+name+2Cmarkovchain-method'></span>

<h3>Description</h3>

<p>This method returns the name of a markovchain object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>name(object)

## S4 method for signature 'markovchain'
name(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="name_+3A_object">object</code></td>
<td>
<p>A markovchain object</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Giorgio Spedicato, Deepak Yadav
</p>


<h3>Examples</h3>

<pre><code class='language-R'>statesNames &lt;- c("a", "b", "c")
markovB &lt;- new("markovchain", states = statesNames, transitionMatrix =
                matrix(c(0.2, 0.5, 0.3, 0, 1, 0, 0.1, 0.8, 0.1), nrow = 3,
                byrow = TRUE, dimnames=list(statesNames,statesNames)),
                name = "A markovchain Object" 
)
name(markovB)

</code></pre>

<hr>
<h2 id='name+26lt+3B-'>Method to set name of markovchain object</h2><span id='topic+name+3C-'></span><span id='topic+name+3C-+2Cmarkovchain-method'></span>

<h3>Description</h3>

<p>This method modifies the existing name of markovchain object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>name(object) &lt;- value

## S4 replacement method for signature 'markovchain'
name(object) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="name+2B26lt+2B3B-_+3A_object">object</code></td>
<td>
<p>A markovchain object</p>
</td></tr>
<tr><td><code id="name+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>New name of markovchain object</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Giorgio Spedicato, Deepak Yadav
</p>


<h3>Examples</h3>

<pre><code class='language-R'>statesNames &lt;- c("a", "b", "c")
markovB &lt;- new("markovchain", states = statesNames, transitionMatrix =
                matrix(c(0.2, 0.5, 0.3, 0, 1, 0, 0.1, 0.8, 0.1), nrow = 3,
                byrow = TRUE, dimnames=list(statesNames,statesNames)),
                name = "A markovchain Object" 
)
name(markovB) &lt;- "dangerous mc"

</code></pre>

<hr>
<h2 id='names+2Cmarkovchain-method'>Returns the states for a Markov chain object</h2><span id='topic+names+2Cmarkovchain-method'></span>

<h3>Description</h3>

<p>Returns the states for a Markov chain object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'markovchain'
names(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="names+2B2Cmarkovchain-method_+3A_x">x</code></td>
<td>
<p>object we want to return states for</p>
</td></tr>
</table>

<hr>
<h2 id='noofVisitsDist'>return a joint pdf of the number of visits to the various states of the DTMC</h2><span id='topic+noofVisitsDist'></span>

<h3>Description</h3>

<p>This function would return a joint pdf of the number of visits to
the various states of the DTMC during the first N steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>noofVisitsDist(markovchain,N,state)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="noofVisitsDist_+3A_markovchain">markovchain</code></td>
<td>
<p>a markovchain-class object</p>
</td></tr>
<tr><td><code id="noofVisitsDist_+3A_n">N</code></td>
<td>
<p>no of steps</p>
</td></tr>
<tr><td><code id="noofVisitsDist_+3A_state">state</code></td>
<td>
<p>the initial state</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function would return a joint pdf of the number of visits to
the various states of the DTMC during the first N steps.
</p>


<h3>Value</h3>

<p>a numeric vector depicting the above described probability density function.
</p>


<h3>Author(s)</h3>

<p>Vandit Jain
</p>


<h3>Examples</h3>

<pre><code class='language-R'>transMatr&lt;-matrix(c(0.4,0.6,.3,.7),nrow=2,byrow=TRUE)
simpleMc&lt;-new("markovchain", states=c("a","b"),
             transitionMatrix=transMatr, 
             name="simpleMc")   
noofVisitsDist(simpleMc,5,"a")

</code></pre>

<hr>
<h2 id='ones'>Returns an Identity matrix</h2><span id='topic+ones'></span>

<h3>Description</h3>

<p>Returns an Identity matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ones(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ones_+3A_n">n</code></td>
<td>
<p>size of the matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a identity matrix
</p>

<hr>
<h2 id='period'>Various function to perform structural analysis of DTMC</h2><span id='topic+period'></span><span id='topic+communicatingClasses'></span><span id='topic+transientStates'></span><span id='topic+recurrentStates'></span><span id='topic+absorbingStates'></span><span id='topic+transientClasses'></span><span id='topic+recurrentClasses'></span><span id='topic+canonicForm'></span>

<h3>Description</h3>

<p>These functions return absorbing and transient states of the <code>markovchain</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>period(object)

communicatingClasses(object)

recurrentClasses(object)

transientClasses(object)

transientStates(object)

recurrentStates(object)

absorbingStates(object)

canonicForm(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="period_+3A_object">object</code></td>
<td>
<p>A <code>markovchain</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt><code>period</code></dt><dd><p>returns a integer number corresponding to the periodicity of the Markov 
chain (if it is irreducible)</p>
</dd>
<dt><code>absorbingStates</code></dt><dd><p>returns a character vector with the names of the absorbing 
states in the Markov chain</p>
</dd>
<dt><code>communicatingClasses</code></dt><dd><p>returns a list in which each slot contains the names of
the states that are in that communicating class</p>
</dd>
<dt><code>recurrentClasses</code></dt><dd><p>analogously to <code>communicatingClasses</code>, but with 
recurrent classes</p>
</dd>
<dt><code>transientClasses</code></dt><dd><p>analogously to <code>communicatingClasses</code>, but with 
transient classes</p>
</dd>
<dt><code>transientStates</code></dt><dd><p>returns a character vector with all the transient states
for the Markov chain</p>
</dd>
<dt><code>recurrentStates</code></dt><dd><p>returns a character vector with all the recurrent states 
for the Markov chain</p>
</dd>
<dt><code>canonicForm</code></dt><dd><p>returns the Markov chain reordered by a permutation of states 
so that we have blocks submatrices for each of the recurrent classes and a collection 
of rows in the end for the transient states</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giorgio Alfredo Spedicato, Ignacio Cordón
</p>


<h3>References</h3>

<p>Feres, Matlab listing for markov chain.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+markovchain-class">markovchain</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>statesNames &lt;- c("a", "b", "c")
mc &lt;- new("markovchain", states = statesNames, transitionMatrix =
          matrix(c(0.2, 0.5, 0.3,
                   0,   1,   0,
                   0.1, 0.8, 0.1), nrow = 3, byrow = TRUE,
                 dimnames = list(statesNames, statesNames))
         )

communicatingClasses(mc)
recurrentClasses(mc)
recurrentClasses(mc)
absorbingStates(mc)
transientStates(mc)
recurrentStates(mc)
canonicForm(mc)

# periodicity analysis
A &lt;- matrix(c(0, 1, 0, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0, 0.5, 0, 0, 1, 0), 
            nrow = 4, ncol = 4, byrow = TRUE)
mcA &lt;- new("markovchain", states = c("a", "b", "c", "d"), 
          transitionMatrix = A,
          name = "A")

is.irreducible(mcA) #true
period(mcA) #2

# periodicity analysis
B &lt;- matrix(c(0, 0, 1/2, 1/4, 1/4, 0, 0,
                   0, 0, 1/3, 0, 2/3, 0, 0,
                   0, 0, 0, 0, 0, 1/3, 2/3,
                   0, 0, 0, 0, 0, 1/2, 1/2,
                   0, 0, 0, 0, 0, 3/4, 1/4,
                   1/2, 1/2, 0, 0, 0, 0, 0,
                   1/4, 3/4, 0, 0, 0, 0, 0), byrow = TRUE, ncol = 7)
mcB &lt;- new("markovchain", transitionMatrix = B)
period(mcB)

</code></pre>

<hr>
<h2 id='predictHommc'>Simulate a higher order multivariate markovchain</h2><span id='topic+predictHommc'></span>

<h3>Description</h3>

<p>This function provides a prediction of states for a higher order 
multivariate markovchain object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictHommc(hommc,t,init)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictHommc_+3A_hommc">hommc</code></td>
<td>
<p>a hommc-class object</p>
</td></tr>
<tr><td><code id="predictHommc_+3A_t">t</code></td>
<td>
<p>no of iterations to predict</p>
</td></tr>
<tr><td><code id="predictHommc_+3A_init">init</code></td>
<td>
<p>matrix of previous states size of which depends on hommc</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The user is required to provide a matrix of giving n previous coressponding
every categorical sequence. Dimensions of the init are s X n, where s is 
number of categorical sequences and n is order of the homc.
</p>


<h3>Value</h3>

<p>The function returns a matrix of size s X t displaying t predicted states 
in each row coressponding to every categorical sequence.
</p>


<h3>Author(s)</h3>

<p>Vandit Jain
</p>

<hr>
<h2 id='predictiveDistribution'>predictiveDistribution</h2><span id='topic+predictiveDistribution'></span>

<h3>Description</h3>

<p>The function computes the probability of observing a new data
set, given a data set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictiveDistribution(stringchar, newData, hyperparam = matrix())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictiveDistribution_+3A_stringchar">stringchar</code></td>
<td>
<p>This is the data using which the Bayesian inference is
performed.</p>
</td></tr>
<tr><td><code id="predictiveDistribution_+3A_newdata">newData</code></td>
<td>
<p>This is the data whose predictive probability is computed.</p>
</td></tr>
<tr><td><code id="predictiveDistribution_+3A_hyperparam">hyperparam</code></td>
<td>
<p>This determines the shape of the prior distribution of the
parameters. If none is provided, default value of 1 is assigned to each
parameter. This must be of size kxk where k is the number of states in the
chain and the values should typically be non-negative integers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The underlying method is Bayesian inference. The probability is
computed by averaging the likelihood of the new data with respect to the
posterior. Since the method assumes conjugate priors, the result can be
represented in a closed form (see the vignette for more details), which is
what is returned.
</p>


<h3>Value</h3>

<p>The log of the probability is returned.
</p>


<h3>Author(s)</h3>

<p>Sai Bhargav Yalamanchi
</p>


<h3>References</h3>

<p>Inferring Markov Chains: Bayesian Estimation, Model Comparison, Entropy Rate, 
and Out-of-Class Modeling, Christopher C. Strelioff, James P.
Crutchfield, Alfred Hubler, Santa Fe Institute
</p>
<p>Yalamanchi SB, Spedicato GA (2015). Bayesian Inference of First Order Markov 
Chains. R package version 0.2.5
</p>


<h3>See Also</h3>

<p><code><a href="#topic+markovchainFit">markovchainFit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sequence&lt;- c("a", "b", "a", "a", "a", "a", "b", "a", "b", "a", "b", "a", "a", 
             "b", "b", "b", "a")
hyperMatrix&lt;-matrix(c(1, 2, 1, 4), nrow = 2,dimnames=list(c("a","b"),c("a","b")))
predProb &lt;- predictiveDistribution(sequence[1:10], sequence[11:17], hyperparam =hyperMatrix )
hyperMatrix2&lt;-hyperMatrix[c(2,1),c(2,1)]
predProb2 &lt;- predictiveDistribution(sequence[1:10], sequence[11:17], hyperparam =hyperMatrix2 )
predProb2==predProb
</code></pre>

<hr>
<h2 id='preproglucacon'>Preprogluccacon DNA protein bases sequences</h2><span id='topic+preproglucacon'></span>

<h3>Description</h3>

<p>Sequence of bases for preproglucacon DNA protein
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(preproglucacon)
</code></pre>


<h3>Format</h3>

<p>A data frame with 1572 observations on the following 2 variables.
</p>

<dl>
<dt><code>V1</code></dt><dd><p>a numeric vector, showing original coding</p>
</dd>
<dt><code>preproglucacon</code></dt><dd><p>a character vector, showing initial of DNA bases (Adenine, Cytosine, Guanine, Thymine)</p>
</dd>
</dl>



<h3>Source</h3>

<p>Avery Henderson
</p>


<h3>References</h3>

<p>Averuy Henderson, Fitting markov chain models on discrete time series such as DNA sequences
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(preproglucacon)
preproglucaconMc&lt;-markovchainFit(data=preproglucacon$preproglucacon)
</code></pre>

<hr>
<h2 id='priorDistribution'>priorDistribution</h2><span id='topic+priorDistribution'></span>

<h3>Description</h3>

<p>Function to evaluate the prior probability of a transition
matrix. It is based on conjugate priors and therefore a Dirichlet
distribution is used to model the transitions of each state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>priorDistribution(transMatr, hyperparam = matrix())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="priorDistribution_+3A_transmatr">transMatr</code></td>
<td>
<p>The transition matrix whose probability is the parameter of
interest.</p>
</td></tr>
<tr><td><code id="priorDistribution_+3A_hyperparam">hyperparam</code></td>
<td>
<p>The hyperparam matrix (optional). If not provided, a
default value of 1 is assumed for each and therefore the resulting
probability distribution is uniform.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The states (dimnames) of the transition matrix and the hyperparam
may be in any order.
</p>


<h3>Value</h3>

<p>The log of the probabilities for each state is returned in a numeric
vector. Each number in the vector represents the probability (log) of
having a probability transition vector as specified in corresponding the
row of the transition matrix.
</p>


<h3>Note</h3>

<p>This function can be used in conjunction with inferHyperparam. For
example, if the user has a prior data set and a prior transition matrix,
he can infer the hyperparameters using inferHyperparam and then compute
the probability of their prior matrix using the inferred hyperparameters
with priorDistribution.
</p>


<h3>Author(s)</h3>

<p>Sai Bhargav Yalamanchi, Giorgio Spedicato
</p>


<h3>References</h3>

<p>Yalamanchi SB, Spedicato GA (2015). Bayesian Inference of First
Order Markov Chains. R package version 0.2.5
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predictiveDistribution">predictiveDistribution</a></code>, <code><a href="#topic+inferHyperparam">inferHyperparam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>priorDistribution(matrix(c(0.5, 0.5, 0.5, 0.5), 
                  nrow = 2, 
                  dimnames = list(c("a", "b"), c("a", "b"))), 
                  matrix(c(2, 2, 2, 2), 
                  nrow = 2, 
                  dimnames = list(c("a", "b"), c("a", "b"))))
</code></pre>

<hr>
<h2 id='probabilityatT'>Calculating probability from a ctmc object</h2><span id='topic+probabilityatT'></span>

<h3>Description</h3>

<p>This function returns the probability of every state at time t under different conditions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>probabilityatT(C,t,x0,useRCpp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="probabilityatT_+3A_c">C</code></td>
<td>
<p>A CTMC S4 object</p>
</td></tr>
<tr><td><code id="probabilityatT_+3A_t">t</code></td>
<td>
<p>final time t</p>
</td></tr>
<tr><td><code id="probabilityatT_+3A_x0">x0</code></td>
<td>
<p>initial state</p>
</td></tr>
<tr><td><code id="probabilityatT_+3A_usercpp">useRCpp</code></td>
<td>
<p>logical whether to use RCpp implementation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The initial state is not mandatory, In case it is not provided, 
function returns a matrix of transition function at time <code>t</code> else it returns
vector of probaabilities of transition to different states if initial state was <code>x0</code>
</p>


<h3>Value</h3>

<p>returns a vector or a matrix in case <code>x0</code> is provided or not respectively.
</p>


<h3>Author(s)</h3>

<p>Vandit Jain
</p>


<h3>References</h3>

<p>INTRODUCTION TO STOCHASTIC PROCESSES WITH R, ROBERT P. DOBROW, Wiley
</p>


<h3>Examples</h3>

<pre><code class='language-R'>states &lt;- c("a","b","c","d")
byRow &lt;- TRUE
gen &lt;- matrix(data = c(-1, 1/2, 1/2, 0, 1/4, -1/2, 0, 1/4, 1/6, 0, -1/3, 1/6, 0, 0, 0, 0),
nrow = 4,byrow = byRow, dimnames = list(states,states))
ctmc &lt;- new("ctmc",states = states, byrow = byRow, generator = gen, name = "testctmc")
probabilityatT(ctmc,1,useRCpp = TRUE)

</code></pre>

<hr>
<h2 id='rain'>Alofi island daily rainfall</h2><span id='topic+rain'></span>

<h3>Description</h3>

<p>Rainfall measured in Alofi Island
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(rain)
</code></pre>


<h3>Format</h3>

<p>A data frame with 1096 observations on the following 2 variables.
</p>

<dl>
<dt><code>V1</code></dt><dd><p>a numeric vector, showing original coding</p>
</dd>
<dt><code>rain</code></dt><dd><p>a character vector, showing daily rainfall millilitres brackets</p>
</dd>
</dl>



<h3>Source</h3>

<p>Avery Henderson
</p>


<h3>References</h3>

<p>Avery Henderson, Fitting markov chain models on discrete time series such as DNA sequences
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rain)
rainMc&lt;-markovchainFit(data=rain$rain)
</code></pre>

<hr>
<h2 id='rctmc'>rctmc</h2><span id='topic+rctmc'></span>

<h3>Description</h3>

<p>The function generates random CTMC transitions as per the
provided generator matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rctmc(n, ctmc, initDist = numeric(), T = 0, include.T0 = TRUE,
  out.type = "list")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rctmc_+3A_n">n</code></td>
<td>
<p>The number of samples to generate.</p>
</td></tr>
<tr><td><code id="rctmc_+3A_ctmc">ctmc</code></td>
<td>
<p>The CTMC S4 object.</p>
</td></tr>
<tr><td><code id="rctmc_+3A_initdist">initDist</code></td>
<td>
<p>The initial distribution of states.</p>
</td></tr>
<tr><td><code id="rctmc_+3A_t">T</code></td>
<td>
<p>The time up to which the simulation runs (all transitions after time
T are not returned).</p>
</td></tr>
<tr><td><code id="rctmc_+3A_include.t0">include.T0</code></td>
<td>
<p>Flag to determine if start state is to be included.</p>
</td></tr>
<tr><td><code id="rctmc_+3A_out.type">out.type</code></td>
<td>
<p>&quot;list&quot; or &quot;df&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to use the T0 argument, set n to Inf.
</p>


<h3>Value</h3>

<p>Based on out.type, a list or a data frame is returned. The returned
list has two elements - a character vector (states) and a numeric vector
(indicating time of transitions). The data frame is similarly structured.
</p>


<h3>Author(s)</h3>

<p>Sai Bhargav Yalamanchi
</p>


<h3>References</h3>

<p>Introduction to Stochastic Processes with Applications in the Biosciences 
(2013), David F. Anderson, University of Wisconsin at Madison
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generatorToTransitionMatrix">generatorToTransitionMatrix</a></code>,<code><a href="#topic+ctmc-class">ctmc-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>energyStates &lt;- c("sigma", "sigma_star")
byRow &lt;- TRUE
gen &lt;- matrix(data = c(-3, 3, 1, -1), nrow = 2,
             byrow = byRow, dimnames = list(energyStates, energyStates))
molecularCTMC &lt;- new("ctmc", states = energyStates, 
                     byrow = byRow, generator = gen, 
                     name = "Molecular Transition Model")   

statesDist &lt;- c(0.8, 0.2)
rctmc(n = Inf, ctmc = molecularCTMC, T = 1)
rctmc(n = 5, ctmc = molecularCTMC, initDist = statesDist, include.T0 = FALSE)
</code></pre>

<hr>
<h2 id='rmarkovchain'>Function to generate a sequence of states from homogeneous or non-homogeneous Markov chains.</h2><span id='topic+rmarkovchain'></span>

<h3>Description</h3>

<p>Provided any <code>markovchain</code> or <code>markovchainList</code> objects, it returns a sequence of 
states coming from the underlying stationary distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmarkovchain(
  n,
  object,
  what = "data.frame",
  useRCpp = TRUE,
  parallel = FALSE,
  num.cores = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmarkovchain_+3A_n">n</code></td>
<td>
<p>Sample size</p>
</td></tr>
<tr><td><code id="rmarkovchain_+3A_object">object</code></td>
<td>
<p>Either a <code>markovchain</code> or a <code>markovchainList</code> object</p>
</td></tr>
<tr><td><code id="rmarkovchain_+3A_what">what</code></td>
<td>
<p>It specifies whether either a <code>data.frame</code> or a <code>matrix</code> 
(each rows represent a simulation) or a <code>list</code> is returned.</p>
</td></tr>
<tr><td><code id="rmarkovchain_+3A_usercpp">useRCpp</code></td>
<td>
<p>Boolean. Should RCpp fast implementation being used? Default is yes.</p>
</td></tr>
<tr><td><code id="rmarkovchain_+3A_parallel">parallel</code></td>
<td>
<p>Boolean. Should parallel implementation being used? Default is yes.</p>
</td></tr>
<tr><td><code id="rmarkovchain_+3A_num.cores">num.cores</code></td>
<td>
<p>Number of Cores to be used</p>
</td></tr>
<tr><td><code id="rmarkovchain_+3A_...">...</code></td>
<td>
<p>additional parameters passed to the internal sampler</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When a homogeneous process is assumed (<code>markovchain</code> object) a sequence is 
sampled of size n. When a non - homogeneous process is assumed,
n samples are taken but the process is assumed to last from the begin to the end of the 
non-homogeneous markov process.
</p>


<h3>Value</h3>

<p>Character Vector, data.frame, list or matrix
</p>


<h3>Note</h3>

<p>Check the type of input
</p>


<h3>Author(s)</h3>

<p>Giorgio Spedicato
</p>


<h3>References</h3>

<p>A First Course in Probability (8th Edition), Sheldon Ross, Prentice Hall 2010
</p>


<h3>See Also</h3>

<p><code><a href="#topic+markovchainFit">markovchainFit</a></code>, <code><a href="#topic+markovchainSequence">markovchainSequence</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define the markovchain object
statesNames &lt;- c("a", "b", "c")
mcB &lt;- new("markovchain", states = statesNames, 
   transitionMatrix = matrix(c(0.2, 0.5, 0.3, 0, 0.2, 0.8, 0.1, 0.8, 0.1), 
   nrow = 3, byrow = TRUE, dimnames = list(statesNames, statesNames)))

# show the sequence
outs &lt;- rmarkovchain(n = 100, object = mcB, what = "list")


#define markovchainList object
statesNames &lt;- c("a", "b", "c")
mcA &lt;- new("markovchain", states = statesNames, transitionMatrix = 
   matrix(c(0.2, 0.5, 0.3, 0, 0.2, 0.8, 0.1, 0.8, 0.1), nrow = 3, 
   byrow = TRUE, dimnames = list(statesNames, statesNames)))
mcB &lt;- new("markovchain", states = statesNames, transitionMatrix = 
   matrix(c(0.2, 0.5, 0.3, 0, 0.2, 0.8, 0.1, 0.8, 0.1), nrow = 3, 
   byrow = TRUE, dimnames = list(statesNames, statesNames)))
mcC &lt;- new("markovchain", states = statesNames, transitionMatrix = 
   matrix(c(0.2, 0.5, 0.3, 0, 0.2, 0.8, 0.1, 0.8, 0.1), nrow = 3, 
   byrow = TRUE, dimnames = list(statesNames, statesNames)))
mclist &lt;- new("markovchainList", markovchains = list(mcA, mcB, mcC)) 

# show the list of sequence
rmarkovchain(100, mclist, "list")
     
</code></pre>

<hr>
<h2 id='sales'>Sales Demand Sequences</h2><span id='topic+sales'></span>

<h3>Description</h3>

<p>Sales demand sequences of five products (A, B, C, D, E).
Each row corresponds to a sequence. First row corresponds to Sequence A, 
Second row to Sequence B and so on.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("sales")
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 269 rows and 5 columns.
</p>


<h3>Details</h3>

<p>The example can be used to fit High order multivariate
markov chain.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sales")
# fitHighOrderMultivarMC(seqMat = sales, order = 2, Norm = 2)

</code></pre>

<hr>
<h2 id='show+2Chommc-method'>Function to display the details of hommc object</h2><span id='topic+show+2Chommc-method'></span>

<h3>Description</h3>

<p>This is a convenience function to display the slots of hommc object
in proper format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'hommc'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2Chommc-method_+3A_object">object</code></td>
<td>
<p>An object of class hommc</p>
</td></tr>
</table>

<hr>
<h2 id='states'>Defined states of a transition matrix</h2><span id='topic+states'></span><span id='topic+states+2Cmarkovchain-method'></span>

<h3>Description</h3>

<p>This method returns the states of a transition matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>states(object)

## S4 method for signature 'markovchain'
states(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="states_+3A_object">object</code></td>
<td>
<p>A discrete <code>markovchain</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The character vector corresponding to states slot.
</p>


<h3>Author(s)</h3>

<p>Giorgio Spedicato
</p>


<h3>References</h3>

<p>A First Course in Probability (8th Edition), Sheldon Ross, Prentice Hall 2010
</p>


<h3>See Also</h3>

<p><code><a href="#topic+markovchain-class">markovchain</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>statesNames &lt;- c("a", "b", "c")
markovB &lt;- new("markovchain", states = statesNames, transitionMatrix =
                matrix(c(0.2, 0.5, 0.3, 0, 1, 0, 0.1, 0.8, 0.1), nrow = 3,
                byrow = TRUE, dimnames=list(statesNames,statesNames)),
                name = "A markovchain Object" 
)
states(markovB)
names(markovB)

</code></pre>

<hr>
<h2 id='steadyStates'>Stationary states of a <code>markovchain</code> object</h2><span id='topic+steadyStates'></span>

<h3>Description</h3>

<p>This method returns the stationary vector in matricial form of a markovchain object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>steadyStates(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="steadyStates_+3A_object">object</code></td>
<td>
<p>A discrete <code>markovchain</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix corresponding to the stationary states
</p>


<h3>Note</h3>

<p>The steady states are identified starting from which eigenvectors correspond 
to identity eigenvalues and then normalizing them to sum up to unity. When negative values are found 
in the matrix, the eigenvalues extraction is performed on the recurrent classes submatrix.
</p>


<h3>Author(s)</h3>

<p>Giorgio Spedicato
</p>


<h3>References</h3>

<p>A First Course in Probability (8th Edition), Sheldon Ross, Prentice Hall 2010
</p>


<h3>See Also</h3>

<p><code><a href="#topic+markovchain-class">markovchain</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>statesNames &lt;- c("a", "b", "c")
markovB &lt;- new("markovchain", states = statesNames, transitionMatrix =
                matrix(c(0.2, 0.5, 0.3, 0, 1, 0, 0.1, 0.8, 0.1), nrow = 3,
                byrow = TRUE, dimnames=list(statesNames,statesNames)),
               name = "A markovchain Object" 
)       
steadyStates(markovB)

</code></pre>

<hr>
<h2 id='tm_abs'>Single Year Corporate Credit Rating Transititions</h2><span id='topic+tm_abs'></span>

<h3>Description</h3>

<p>Matrix of Standard and Poor's Global Corporate Rating Transition Frequencies 2000 (NR Removed)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(tm_abs)
</code></pre>


<h3>Format</h3>

<p>The format is:
num [1:8, 1:8] 17 2 0 0 0 0 0 0 1 455 ...
- attr(*, &quot;dimnames&quot;)=List of 2
..$ : chr [1:8] &quot;AAA&quot; &quot;AA&quot; &quot;A&quot; &quot;BBB&quot; ...
..$ : chr [1:8] &quot;AAA&quot; &quot;AA&quot; &quot;A&quot; &quot;BBB&quot; ...
</p>


<h3>References</h3>

<p>European Securities and Markets Authority, 2016 
https://cerep.esma.europa.eu/cerep-web/statistics/transitionMatrice.xhtml
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(tm_abs)
</code></pre>

<hr>
<h2 id='transition2Generator'>Return the generator matrix for a corresponding transition matrix</h2><span id='topic+transition2Generator'></span>

<h3>Description</h3>

<p>Calculate the generator matrix for a 
corresponding transition matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transition2Generator(P, t = 1, method = "logarithm")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transition2Generator_+3A_p">P</code></td>
<td>
<p>transition matrix between time 0 and t</p>
</td></tr>
<tr><td><code id="transition2Generator_+3A_t">t</code></td>
<td>
<p>time of observation</p>
</td></tr>
<tr><td><code id="transition2Generator_+3A_method">method</code></td>
<td>
<p>&quot;logarithm&quot; returns the Matrix logarithm of the transition matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix that represent the generator of P
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rctmc">rctmc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mymatr &lt;- matrix(c(.4, .6, .1, .9), nrow = 2, byrow = TRUE)
Q &lt;- transition2Generator(P = mymatr)
expm::expm(Q)
 
</code></pre>

<hr>
<h2 id='transitionProbability'>Function to get the transition probabilities from initial 
to subsequent states.</h2><span id='topic+transitionProbability'></span><span id='topic+transitionProbability+2Cmarkovchain-method'></span>

<h3>Description</h3>

<p>This is a convenience function to get transition probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transitionProbability(object, t0, t1)

## S4 method for signature 'markovchain'
transitionProbability(object, t0, t1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transitionProbability_+3A_object">object</code></td>
<td>
<p>A <code>markovchain</code> object.</p>
</td></tr>
<tr><td><code id="transitionProbability_+3A_t0">t0</code></td>
<td>
<p>Initial state.</p>
</td></tr>
<tr><td><code id="transitionProbability_+3A_t1">t1</code></td>
<td>
<p>Subsequent state.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric Vector
</p>


<h3>Author(s)</h3>

<p>Giorgio Spedicato
</p>


<h3>References</h3>

<p>A First Course in Probability (8th Edition), 
Sheldon Ross, Prentice Hall 2010
</p>


<h3>See Also</h3>

<p><code><a href="#topic+markovchain-class">markovchain</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>statesNames &lt;- c("a", "b", "c")
markovB &lt;- new("markovchain", states = statesNames, transitionMatrix =
                matrix(c(0.2, 0.5, 0.3, 0, 1, 0, 0.1, 0.8, 0.1), nrow = 3,
                byrow = TRUE, dimnames=list(statesNames,statesNames)),
               name = "A markovchain Object" 
)    
transitionProbability(markovB,"b", "c")
</code></pre>

<hr>
<h2 id='verifyMarkovProperty'>Various functions to perform statistical inference of DTMC</h2><span id='topic+verifyMarkovProperty'></span><span id='topic+assessOrder'></span><span id='topic+assessStationarity'></span><span id='topic+verifyEmpiricalToTheoretical'></span><span id='topic+verifyHomogeneity'></span>

<h3>Description</h3>

<p>These functions verify the Markov property, assess 
the order and stationarity of the Markov chain.
</p>
<p>This function tests whether an empirical transition matrix is statistically compatible
with a theoretical one. It is a chi-square based test. In case a cell in the empirical transition matrix is &gt;0
that is 0 in the theoretical transition matrix the null hypothesis is rejected.
</p>
<p>Verifies that the s elements in the input list belongs to the same DTMC
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verifyMarkovProperty(sequence, verbose = TRUE)

assessOrder(sequence, verbose = TRUE)

assessStationarity(sequence, nblocks, verbose = TRUE)

verifyEmpiricalToTheoretical(data, object, verbose = TRUE)

verifyHomogeneity(inputList, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verifyMarkovProperty_+3A_sequence">sequence</code></td>
<td>
<p>An empirical sequence.</p>
</td></tr>
<tr><td><code id="verifyMarkovProperty_+3A_verbose">verbose</code></td>
<td>
<p>Should test results be printed out?</p>
</td></tr>
<tr><td><code id="verifyMarkovProperty_+3A_nblocks">nblocks</code></td>
<td>
<p>Number of blocks.</p>
</td></tr>
<tr><td><code id="verifyMarkovProperty_+3A_data">data</code></td>
<td>
<p>matrix, character or list to be converted in a raw transition matrix</p>
</td></tr>
<tr><td><code id="verifyMarkovProperty_+3A_object">object</code></td>
<td>
<p>a markovchain object</p>
</td></tr>
<tr><td><code id="verifyMarkovProperty_+3A_inputlist">inputList</code></td>
<td>
<p>A list of items that can coerced to transition matrices</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Verification result
</p>
<p>a list with following slots: statistic (the chi - square statistic), dof (degrees of freedom), and corresponding p-value. In case a cell in the empirical transition matrix is &gt;0
that is 0 in the theoretical transition matrix the null hypothesis is rejected. In that case a p-value of 0 and statistic and dof of NA are returned.
</p>
<p>a list of transition matrices?
</p>


<h3>Author(s)</h3>

<p>Tae Seung Kang, Giorgio Alfredo Spedicato
</p>


<h3>References</h3>

<p>Anderson and Goodman.
</p>


<h3>See Also</h3>

<p><code>markovchain</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sequence &lt;- c("a", "b", "a", "a", "a", "a", "b", "a", "b",
              "a", "b", "a", "a", "b", "b", "b", "a")
mcFit &lt;- markovchainFit(data = sequence, byrow = FALSE)
verifyMarkovProperty(sequence)
assessOrder(sequence)
assessStationarity(sequence, 1)



#Example taken from Kullback Kupperman Tests for Contingency Tables and Markov Chains

sequence&lt;-c(0,1,2,2,1,0,0,0,0,0,0,1,2,2,2,1,0,0,1,0,0,0,0,0,0,1,1,
2,0,0,2,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,2,1,0,
0,2,1,0,0,0,0,0,0,1,1,1,2,2,0,0,2,1,1,1,1,2,1,1,1,1,1,1,1,1,1,0,2,
0,1,1,0,0,0,1,2,2,0,0,0,0,0,0,2,2,2,1,1,1,1,0,1,1,1,1,0,0,2,1,1,
0,0,0,0,0,2,2,1,1,1,1,1,2,1,2,0,0,0,1,2,2,2,0,0,0,1,1)

mc=matrix(c(5/8,1/4,1/8,1/4,1/2,1/4,1/4,3/8,3/8),byrow=TRUE, nrow=3)
rownames(mc)&lt;-colnames(mc)&lt;-0:2; theoreticalMc&lt;-as(mc, "markovchain")

verifyEmpiricalToTheoretical(data=sequence,object=theoreticalMc)


data(kullback)
verifyHomogeneity(inputList=kullback,verbose=TRUE)

</code></pre>

<hr>
<h2 id='zeros'>Matrix to create zeros</h2><span id='topic+zeros'></span>

<h3>Description</h3>

<p>Matrix to create zeros
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zeros(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zeros_+3A_n">n</code></td>
<td>
<p>size of the matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a square matrix of zeros
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
