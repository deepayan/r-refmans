<!DOCTYPE html><html lang="en"><head><title>Help for package PINSPlus</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PINSPlus}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#PINSPlus-package'>
<p>Perturbation Clustering for data INtegration and disease Subtyping</p></a></li>
<li><a href='#AML2004'><p>Acute myelogenous leukemia dataset</p></a></li>
<li><a href='#KIRC'><p>Kidney renal clear cell carcinoma dataset</p></a></li>
<li><a href='#PerturbationClustering'><p>Perturbation clustering</p></a></li>
<li><a href='#SubtypingOmicsData'><p>Subtyping multi-omics data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Clustering Algorithm for Data Integration and Disease Subtyping</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-04-04</td>
</tr>
<tr>
<td>Author:</td>
<td>Hung Nguyen, Bang Tran, Duc Tran and Tin Nguyen</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Van-Dung Pham &lt;dvp0001@auburn.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a robust approach for omics data integration and disease subtyping. PINSPlus is fast and supports the analysis of large datasets with hundreds of thousands of samples and features. The software automatically determines the optimal number of clusters and then partitions the samples in a way such that the results are robust against noise and data perturbation (Nguyen et al. (2019) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbty1049">doi:10.1093/bioinformatics/bty1049</a>&gt;, Nguyen et al. (2017)&lt;<a href="https://doi.org/10.1101%2Fgr.215129.116">doi:10.1101/gr.215129.116</a>&gt;, Nguyen et al. (2021)&lt;<a href="https://doi.org/10.3389%2Ffonc.2021.725133">doi:10.3389/fonc.2021.725133</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2">LGPL-2</a> | <a href="https://www.r-project.org/Licenses/LGPL-2.1">LGPL-2.1</a> | <a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a> [expanded from: LGPL]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>foreach, entropy , doParallel, matrixStats, Rcpp,
RcppParallel, FNN, cluster, irlba, mclust, impute</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, survival, markdown</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppParallel</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-04 20:06:00 UTC; dungp</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-05 14:53:04 UTC</td>
</tr>
</table>
<hr>
<h2 id='PINSPlus-package'>
Perturbation Clustering for data INtegration and disease Subtyping
</h2><span id='topic+PINSPlus-package'></span><span id='topic+PINSPlus'></span>

<h3>Description</h3>

<p>This package implements clustering algorithms proposed by Nguyen et al. (2017, 2019). Perturbation Clustering for data INtegration and disease Subtyping (PINS) is an approach for integraton of data and classification of diseases into various subtypes. PINS+ provides algorithms supporting both single data type clustering and multi-omics data type. PINSPlus is an improved version of PINS by allowing users to customize the based clustering algorithm and perturbation methods. Furthermore, PINSPlus is fast and supports the analysis or large datasets with millions of samples and features.
</p>


<h3>Details</h3>

<p>PINS+ provides <code><a href="#topic+PerturbationClustering">PerturbationClustering</a></code> and <code><a href="#topic+SubtypingOmicsData">SubtypingOmicsData</a></code> functions for single data type clustering and multi-omics data type clustering. PINS makes use of different clustering algorithms such as <code>kmeans</code> and <code>pam</code> to perform clustering actions. The principle of PINS is to find the optimum number of clusters and location of each sample in the clusters based on perturbation methods such as <code>noise</code> or <code>subsampling</code>. PINS+ allows users to pass their own clustering algorithm and perturbation method.
</p>


<h3>References</h3>

<p>H Nguyen, S Shrestha, S Draghici, &amp; T Nguyen. PINSPlus: a tool for tumor subtype discovery in integrated genomic data. Bioinformatics, 35(16), 2843-2846, (2019).
</p>
<p>T Nguyen, R Tagett, D Diaz, S Draghici. A novel method for data integration and disease subtyping. 
Genome Research, 27(12):2025-2039, 2017.
</p>
<p>Nguyen, H., Shrestha, S., Draghici, S., &amp; Nguyen, T. (2019). PINSPlus: a tool for tumor subtype discovery in integrated genomic data. Bioinformatics, 35(16), 2843-2846.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PerturbationClustering">PerturbationClustering</a></code>, <code><a href="#topic+SubtypingOmicsData">SubtypingOmicsData</a></code>
</p>

<hr>
<h2 id='AML2004'>Acute myelogenous leukemia dataset</h2><span id='topic+AML2004'></span>

<h3>Description</h3>

<p>Acute myelogenous leukemia dataset
</p>


<h3>Format</h3>

<p>A list containing properties:
</p>

<table>
<tr>
 <td style="text-align: right;">
        Name          </td><td style="text-align: left;"> Type           </td><td style="text-align: left;"> Description</td>
</tr>
<tr>
 <td style="text-align: right;">
        Gene          </td><td style="text-align: left;"> data.frame     </td><td style="text-align: left;"> mRNA expression data</td>
</tr>
<tr>
 <td style="text-align: right;">
        Group         </td><td style="text-align: left;"> data.frame     </td><td style="text-align: left;"> Data frame indicating the cluster to which each sample is allocated</td>
</tr>
<tr>
 <td style="text-align: right;">
    </td>
</tr>

</table>



<h3>Source</h3>

<p><a href="https://www.pnas.org/doi/full/10.1073/pnas.0308531101">https://www.pnas.org/doi/full/10.1073/pnas.0308531101</a></p>


<h3>References</h3>

<p>Brunet, J. P., Tamayo, P., Golub, T. R., &amp; Mesirov, J. P. (2004). Metagenes and molecular pattern discovery using matrix factorization. Proceedings of the national academy of sciences, 101(12), 4164-4169.
</p>

<hr>
<h2 id='KIRC'>Kidney renal clear cell carcinoma dataset</h2><span id='topic+KIRC'></span>

<h3>Description</h3>

<p>The Cancer Genome Atlas Kidney Renal Clear Cell Carcinoma (TCGA-KIRC) data collection is part of a larger effort to build a research community focused on connecting cancer phenotypes to genotypes by providing clinical images matched to subjects from The Cancer Genome Atlas (TCGA). Clinical, genetic, and pathological data resides in the Genomic Data Commons (GDC) Data Portal while the radiological data is stored on The Cancer Imaging Archive (TCIA).
</p>
<p>This embed version of KIRC in PINPlus package is the reduced version of KIRC using Principle Component Analysis.
</p>


<h3>Format</h3>

<p>A list containing properties:
</p>

<table>
<tr>
 <td style="text-align: right;">
        Name          </td><td style="text-align: left;"> Type       </td><td style="text-align: left;"> Description</td>
</tr>
<tr>
 <td style="text-align: right;">
        GE            </td><td style="text-align: left;"> data.frame </td><td style="text-align: left;"> mRNA expression  data</td>
</tr>
<tr>
 <td style="text-align: right;">
        ME            </td><td style="text-align: left;"> data.frame </td><td style="text-align: left;"> DNA Methylation data</td>
</tr>
<tr>
 <td style="text-align: right;">
        MI            </td><td style="text-align: left;"> data.frame </td><td style="text-align: left;"> miRNA expression  data</td>
</tr>
<tr>
 <td style="text-align: right;">
        survival      </td><td style="text-align: left;"> data.frame </td><td style="text-align: left;"> Clinical survival data</td>
</tr>
<tr>
 <td style="text-align: right;">
    </td>
</tr>

</table>



<h3>Source</h3>

<p><a href="https://portal.gdc.cancer.gov/projects/TCGA-KIRC">https://portal.gdc.cancer.gov/projects/TCGA-KIRC</a></p>


<h3>References</h3>

<p>The results shown here are in whole or part based upon data generated by the TCGA Research Network: https://www.cancer.gov/tcga.
</p>

<hr>
<h2 id='PerturbationClustering'>Perturbation clustering</h2><span id='topic+PerturbationClustering'></span>

<h3>Description</h3>

<p>Perform subtyping using one type of high-dimensional data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PerturbationClustering(
  data,
  kMin = 2,
  kMax = 5,
  k = NULL,
  verbose = T,
  ncore = 1,
  clusteringMethod = "kmeans",
  clusteringFunction = NULL,
  clusteringOptions = NULL,
  perturbMethod = "noise",
  perturbFunction = NULL,
  perturbOptions = NULL,
  PCAFunction = NULL,
  iterMin = 20,
  iterMax = 200,
  madMin = 0.001,
  msdMin = 1e-06,
  sampledSetSize = 2000,
  knn.k = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PerturbationClustering_+3A_data">data</code></td>
<td>
<p>Input matrix. The rows represent items while the columns represent features.</p>
</td></tr>
<tr><td><code id="PerturbationClustering_+3A_kmin">kMin</code></td>
<td>
<p>The minimum number of clusters used for automatically detecting the number of clusters. Default value is <code>2</code>.</p>
</td></tr>
<tr><td><code id="PerturbationClustering_+3A_kmax">kMax</code></td>
<td>
<p>The maximum number of clusters used for automatically detecting the number of clusters. Default value is <code>5</code>.</p>
</td></tr>
<tr><td><code id="PerturbationClustering_+3A_k">k</code></td>
<td>
<p>The number of clusters. If k is set then kMin and kMax will be ignored.</p>
</td></tr>
<tr><td><code id="PerturbationClustering_+3A_verbose">verbose</code></td>
<td>
<p>Boolean value indicating the algorithm to run with or without logging. Default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="PerturbationClustering_+3A_ncore">ncore</code></td>
<td>
<p>Number of cores that the algorithm should use. Default value is <code>1</code>.</p>
</td></tr>
<tr><td><code id="PerturbationClustering_+3A_clusteringmethod">clusteringMethod</code></td>
<td>
<p>The name of built-in clustering algorithm that PerturbationClustering will use. Currently supported algorithm are <code>kmeans</code>, <code>pam</code> and <code>hclust</code>. Default value is &quot;<code>kmeans</code>&quot;.</p>
</td></tr>
<tr><td><code id="PerturbationClustering_+3A_clusteringfunction">clusteringFunction</code></td>
<td>
<p>The clustering algorithm function that will be used instead of built-in algorithms.</p>
</td></tr>
<tr><td><code id="PerturbationClustering_+3A_clusteringoptions">clusteringOptions</code></td>
<td>
<p>A list of parameter will be passed to the clustering algorithm in <code>clusteringMethod</code>.</p>
</td></tr>
<tr><td><code id="PerturbationClustering_+3A_perturbmethod">perturbMethod</code></td>
<td>
<p>The name of built-in perturbation method that PerturbationClustering will use, currently supported methods are <code>noise</code> and <code>subsampling</code>. Default value is &quot;<code>noise</code>&quot;.</p>
</td></tr>
<tr><td><code id="PerturbationClustering_+3A_perturbfunction">perturbFunction</code></td>
<td>
<p>The perturbation method function that will be used instead of built-in ones.</p>
</td></tr>
<tr><td><code id="PerturbationClustering_+3A_perturboptions">perturbOptions</code></td>
<td>
<p>A list of parameter will be passed to the perturbation method in <code>perturbMethod</code>.</p>
</td></tr>
<tr><td><code id="PerturbationClustering_+3A_pcafunction">PCAFunction</code></td>
<td>
<p>The customized PCA function that user can manually define.</p>
</td></tr>
<tr><td><code id="PerturbationClustering_+3A_itermin">iterMin</code></td>
<td>
<p>The minimum number of iterations. Default value is <code>20</code>.</p>
</td></tr>
<tr><td><code id="PerturbationClustering_+3A_itermax">iterMax</code></td>
<td>
<p>The maximum number of iterations. Default value is <code>200</code>.</p>
</td></tr>
<tr><td><code id="PerturbationClustering_+3A_madmin">madMin</code></td>
<td>
<p>The minimum of Mean Absolute Deviation of <code>AUC</code> of Connectivity matrix for each <code>k</code>. Default value is <code>1e-03</code>.</p>
</td></tr>
<tr><td><code id="PerturbationClustering_+3A_msdmin">msdMin</code></td>
<td>
<p>The minimum of Mean Square Deviation of <code>AUC</code> of Connectivity matrix for each <code>k</code>. Default value is <code>1e-06</code>.</p>
</td></tr>
<tr><td><code id="PerturbationClustering_+3A_sampledsetsize">sampledSetSize</code></td>
<td>
<p>The number of sample size used for the sampling process when dataset is big. Default value is <code>2000</code>.</p>
</td></tr>
<tr><td><code id="PerturbationClustering_+3A_knn.k">knn.k</code></td>
<td>
<p>The value of k of the k-nearest neighbors algorithm. If knn.k is not set then it will be used the elbow method to calculate k.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>PerturbationClustering implements the Perturbation Clustering algorithm of Nguyen et al. (2017),  Nguyen et al. (2019), and Nguyen et al. (2021).
It aims to determine the optimum cluster number and location of each sample in the clusters in an unsupervised analysis.
</p>
<p>PerturbationClustering takes input as a numerical matrix or data frame of items as rows and features as columns.
It uses a clustering algorithm as the based algorithm.
Current built-in algorithms that users can use directly are <code>kmeans</code>, <code>pam</code> and <code>hclust</code>.
The default parameters for built-in <code>kmeans</code> are <code>nstart = 20 and iter.max = 1000</code>.
Users can change the parameters of built-in clustering algorithm by passing the value into <code>clusteringOptions</code>.
</p>
<p>PerturbationClustering also allows users to pass their own clustering algorithm instead of using built-in ones by using <code>clusteringFunction</code> parameter. 
Once <code>clust?eringFunction</code> is specified, <code>clusteringMethod</code> will be skipped.
The value of <code>clusteringFunction</code> must be a function that takes two arguments: <code>data</code> and <code>k</code>, 
where <code>data</code> is a numeric matrix or data frame containing data that need to be clustered, and <code>k</code> is the number of clusters.
<code>clusteringFunction</code> must return a vector of labels indicating the cluster to which each sample is allocated.
</p>
<p>PerturbationClustering uses a perturbation method to perturb clustering input data.
There are two built-in methods are <code>noise</code> and <code>subsampling</code> that users can use directly by passing to <code>perturbMethod</code> parameter.
Users can change the default value of built-in perturbation methods by passing new value into <code>perturbOptions</code>:
</p>
<p>1. <code>noise</code> perturbation method takes two arguments: <code>noise</code> and <code>noisePercent</code>. The default values are <code>noise = NULL and noisePercent = "median"</code>.
If <code>noise</code> is specified. <code>noisePercent</code> will be skipped.<br />
2. <code>subsampling</code> perturbation method takes one argument <code>percent</code> which has default value of <code>80</code>
</p>
<p>Users can also use their own perturbation methods by passing them into <code>perturbFunction</code>. 
Once <code>perturbFunction</code> is specified, <code>perturbMethod</code> will be skipped.
The value of <code>perturbFunction</code> must be a function that takes one argument <code>data</code>
- a numeric matrix or data frame containing data that need to be perturbed.
<code>perturbFunction</code> must return an object list which is as follows:
</p>
<p>1. <code>data</code>: the perturbed data<br />
2. <code>ConnectivityMatrixHandler</code>: a function that takes three arguments:
<code>connectivityMatrix</code> - the connectivity matrix generated after clustering returned <code>data</code>, 
<code>iter</code> - the current iteration and <code>k</code> - the number of cluster. 
This function must return a compatible connectivity matrix with the original connectivity matrix. 
This function aims to correct the <code>connectivityMatrix</code> if needed and returns the corrected version of it.<br />
3. <code>MergeConnectivityMatrices</code>: a function that takes four arguments: <code>oldMatrix</code>, <code>newMatrix</code>, <code>k</code> and <code>iter</code>. 
The <code>oldMatrix</code> and <code>newMatrix</code> are two connectivity matrices that need to be merged,
<code>k</code> is the cluster number and <code>iter</code> is the current number of iteration.
This function must returns a connectivity matrix that is merged from <code>oldMatrix</code> and <code>newMatrix</code>
</p>
<p>The parameters <code>sampledSetSize</code> and <code>knn.k</code> are used for subsampling procedure when clustering big data. Please consult Nguyen et al. (2021) for details.
</p>


<h3>Value</h3>

<p><code>PerturbationClustering</code> returns a list with at least the following components:
</p>
<table role = "presentation">
<tr><td><code>k</code></td>
<td>
<p>The optimal number of clusters</p>
</td></tr>
<tr><td><code>cluster</code></td>
<td>
<p>A vector of labels indicating the cluster to which each sample is allocated</p>
</td></tr>
<tr><td><code>origS</code></td>
<td>
<p>A list of original connectivity matrices</p>
</td></tr>
<tr><td><code>pertS</code></td>
<td>
<p>A list of perturbed connectivity matrices</p>
</td></tr>
</table>


<h3>References</h3>

<p>1. H Nguyen, S Shrestha, S Draghici, &amp; T Nguyen. PINSPlus: a tool for tumor subtype discovery in integrated genomic data. Bioinformatics, 35(16), 2843-2846, (2019).
</p>
<p>2. T Nguyen, R Tagett, D Diaz, S Draghici. A novel method for data integration and disease subtyping. Genome Research, 27(12):2025-2039, 2017.
</p>
<p>3. T. Nguyen, &quot;Horizontal and vertical integration of bio-molecular data&quot;, PhD thesis, Wayne State University, 2017.
</p>
<p>4. H Nguyen, D Tran, B Tran, M Roy, A Cassell, S Dascalu, S Draghici &amp; T Nguyen. SMRT: Randomized Data Transformation for Cancer Subtyping and Big Data Analysis. Frontiers in oncology. 2021.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+kmeans">kmeans</a></code>, <code><a href="cluster.html#topic+pam">pam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load the dataset AML2004
data(AML2004)
data &lt;- as.matrix(AML2004$Gene)
# Perform the clustering
result &lt;- PerturbationClustering(data = data)

# Plot the result
condition = seq(unique(AML2004$Group[, 2]))
names(condition) &lt;- unique(AML2004$Group[, 2])
plot(
    prcomp(data)$x,
    col = result$cluster,
    pch = condition[AML2004$Group[, 2]],
    main = "AML2004"
)
legend(
    "bottomright",
    legend = paste("Cluster ", sort(unique(result$cluster)), sep = ""),
    fill = sort(unique(result$cluster))
)
legend("bottomleft", legend = names(condition), pch = condition)

# Change kmeans parameters
result &lt;- PerturbationClustering(
    data = data,
    clusteringMethod = "kmeans",
    clusteringOptions = list(
        iter.max = 500,
        nstart = 50
    )
)

# Change to use pam
result &lt;- PerturbationClustering(data = data, clusteringMethod = "pam")

# Change to use hclust
result &lt;- PerturbationClustering(data = data, clusteringMethod = "hclust")

# Pass a user-defined clustering algorithm
result &lt;- PerturbationClustering(data = data, clusteringFunction = function(data, k){
    # this function must return a vector of cluster
    kmeans(x = data, centers = k, nstart = k*10, iter.max = 2000)$cluster
})      

# Use noise as the perturb method
result &lt;- PerturbationClustering(data = data, 
                                 perturbMethod = "noise", 
                                 perturbOptions = list(noise = 0.3))
# or
result &lt;- PerturbationClustering(data = data, 
                                 perturbMethod = "noise", 
                                 perturbOptions = list(noisePercent = 10))

# Change to use subsampling
result &lt;- PerturbationClustering(data = data, 
                                 perturbMethod = "subsampling", 
                                 perturbOptions = list(percent = 90))

# Users can pass their own perturb method
result &lt;- PerturbationClustering(data = data, perturbFunction = function(data){
   rowNum &lt;- nrow(data)
   colNum &lt;- ncol(data)
   epsilon &lt;-
       matrix(
           data = rnorm(rowNum * colNum, mean = 0, sd = 1.234),
           nrow = rowNum,
           ncol = colNum
       )
   
   list(
       data = data + epsilon,
       ConnectivityMatrixHandler = function(connectivityMatrix, ...) {
           connectivityMatrix
       },
       MergeConnectivityMatrices = function(oldMatrix, newMatrix, iter, ...){
           return((oldMatrix*(iter-1) + newMatrix)/iter)
       }
   )
})

# Clustering on simulation data
# Load necessary library

if (!require("mclust")) install.packages("mclust")
library(mclust)
library(irlba)

#Generate a simulated data matrix with the size of 50,000 x 5,000
sampleNum &lt;- 50000 # Number of samples
geneNum &lt;- 5000 # Number of genes
subtypeNum &lt;- 3 # Number of subtypes

# Generate expression matrix
exprs &lt;- matrix(rnorm(sampleNum*geneNum, 0, 1), nrow = sampleNum, ncol = geneNum) 
rownames(exprs) &lt;- paste0("S", 1:sampleNum) # Assign unique names for samples

# Generate subtypes
group &lt;- sort(rep(1:subtypeNum, sampleNum/subtypeNum + 1)[1:sampleNum])
names(group) &lt;- rownames(exprs)

# Make subtypes separate
for (i in 1:subtypeNum) {
   exprs[group == i, 1:100 + 100*(i-1)] &lt;- exprs[group == i, 1:100 + 100*(i-1)] + 2
}

# Plot the data
library(irlba)
exprs.pca &lt;- irlba::prcomp_irlba(exprs, n = 2)$x
plot(exprs.pca, main = "PCA")

#Run PINSPlus clustering:

set.seed(1)
t1 &lt;- Sys.time()
result &lt;- PerturbationClustering(data = exprs.pca, ncore = 1)
t2 &lt;- Sys.time()


#Print out the running time:

time&lt;- t2-t1

#Print out the number of clusters:

result$k

#Get cluster assignment

subtype &lt;- result$cluster

# Here we assess the clustering accurracy using Adjusted Rand Index (ARI). 
#ARI takes values from -1 to 1 where 0 stands for a random clustering and 1 
#stands for a perfect partition result. 
if (!require("mclust")) install.packages("mclust")
library(mclust)
ari &lt;- mclust::adjustedRandIndex(subtype, group)

#Plot the cluster assginments

colors &lt;- as.numeric(as.character(factor(subtype)))

plot(exprs.pca, col = colors, main = "Cluster assigments for simulation data")

legend("topright", legend = paste("ARI:", ari))

legend("bottomright", fill = unique(colors),
      legend = paste("Group ", 
                     levels(factor(subtype)), ": ", 
                     table(subtype)[levels(factor(subtype))], sep = "" )
)

</code></pre>

<hr>
<h2 id='SubtypingOmicsData'>Subtyping multi-omics data</h2><span id='topic+SubtypingOmicsData'></span>

<h3>Description</h3>

<p>Perform subtyping using multiple types of data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SubtypingOmicsData(
  dataList,
  kMin = 2,
  kMax = 5,
  k = NULL,
  agreementCutoff = 0.5,
  ncore = 1,
  verbose = T,
  sampledSetSize = 2000,
  knn.k = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SubtypingOmicsData_+3A_datalist">dataList</code></td>
<td>
<p>a list of data matrices. Each matrix represents a data type where the rows are items and the columns are features. The matrices must have the same set of items.</p>
</td></tr>
<tr><td><code id="SubtypingOmicsData_+3A_kmin">kMin</code></td>
<td>
<p>The minimum number of clusters used for automatically detecting the number of clusters in <code>PerturbationClustering</code>. This paramter is passed to <code>PerturbationClustering</code> and does not affect the final number of cluster in <code>SubtypingOmicsData</code>. Default value is <code>2</code>.</p>
</td></tr>
<tr><td><code id="SubtypingOmicsData_+3A_kmax">kMax</code></td>
<td>
<p>The maximum number of clusters used for automatically detecting the number of clusters in <code>PerturbationClustering</code>. This paramter is passed to <code>PerturbationClustering</code> and does not affect the final number of cluster in <code>SubtypingOmicsData</code>. Default value is <code>5</code>.</p>
</td></tr>
<tr><td><code id="SubtypingOmicsData_+3A_k">k</code></td>
<td>
<p>The number of clusters. If k is set then kMin and kMax will be ignored.</p>
</td></tr>
<tr><td><code id="SubtypingOmicsData_+3A_agreementcutoff">agreementCutoff</code></td>
<td>
<p>agreement threshold to be considered consistent. Default value is <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="SubtypingOmicsData_+3A_ncore">ncore</code></td>
<td>
<p>Number of cores that the algorithm should use. Default value is <code>1</code>.</p>
</td></tr>
<tr><td><code id="SubtypingOmicsData_+3A_verbose">verbose</code></td>
<td>
<p>set it to <code>TRUE</code> of <code>FALSE</code> to get more or less details respectively.</p>
</td></tr>
<tr><td><code id="SubtypingOmicsData_+3A_sampledsetsize">sampledSetSize</code></td>
<td>
<p>The number of sample size used for the sampling process when dataset is big. Default value is <code>2000</code>.</p>
</td></tr>
<tr><td><code id="SubtypingOmicsData_+3A_knn.k">knn.k</code></td>
<td>
<p>The value of k of the k-nearest neighbors algorithm. If knn.k is not set then it will be used elbow method to calculate the k.</p>
</td></tr>
<tr><td><code id="SubtypingOmicsData_+3A_...">...</code></td>
<td>
<p>these arguments will be passed to <code>PerturbationClustering</code> algorithm. See details for more information</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>SubtypingOmicsData</code> implements the Subtyping multi-omic data that are based on Perturbaion clustering algorithm of Nguyen et al (2017), Nguyen et al (2019) and Nguyen, et al. (2021).
The input is  a list of data matrices where each matrix represents the molecular measurements of a data type. The input matrices must have the same number of rows. 
<code>SubtypingOmicsData</code> aims to find the optimum number of subtypes and location of each sample in the clusters from integrated input data <code>dataList</code> through two processing stages:
</p>
<p>1. Stage I: The algorithm first partitions each data type using the function <code>PerturbationClustering</code>.
It then merges the connectivities across data types into similarity matrices.
Both kmeans and similarity-based clustering algorithms - partitioning around medoids <code>pam</code> are used to partition the built similarity.
The algorithm returns the partitioning that agrees the most with individual data types.<br />
2. Stage II: The algorithm attempts to split each discovered group if there is a strong agreement between data types,
or if the subtyping in Stage I is very unbalanced.
</p>
<p>When clustering a large number of samples, this function uses a subsampling technique to reduce the computational complexity with the two parameters <code>sampledSetSize</code> and <code>knn.k</code>. Please consult Nguyen et al. (2021) for details.
</p>


<h3>Value</h3>

<p><code>SubtypingOmicsData</code> returns a list with at least the following components:
</p>
<table role = "presentation">
<tr><td><code>cluster1</code></td>
<td>
<p>A vector of labels indicating the cluster to which each sample is allocated in Stage I</p>
</td></tr>
<tr><td><code>cluster2</code></td>
<td>
<p>A vector of labels indicating the cluster to which each sample is allocated in Stage II</p>
</td></tr>
<tr><td><code>dataTypeResult</code></td>
<td>
<p>A list of results for individual data type. Each element of the list is the result of the <code>PerturbationClustering</code> for the corresponding data matrix provided in dataList.</p>
</td></tr>
</table>


<h3>References</h3>

<p>1. H Nguyen, S Shrestha, S Draghici, &amp; T Nguyen. PINSPlus: a tool for tumor subtype discovery in integrated genomic data. Bioinformatics, 35(16), 2843-2846, (2019).
</p>
<p>2. T Nguyen, R Tagett, D Diaz, S Draghici. A novel method for data integration and disease subtyping. Genome Research, 27(12):2025-2039, 2017.
</p>
<p>3. T. Nguyen, &quot;Horizontal and vertical integration of bio-molecular data&quot;, PhD thesis, Wayne State University, 2017.
</p>
<p>4. H Nguyen, D Tran, B Tran, M Roy, A Cassell, S Dascalu, S Draghici &amp; T Nguyen. SMRT: Randomized Data Transformation for Cancer Subtyping and Big Data Analysis. Frontiers in oncology. 2021.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+PerturbationClustering">PerturbationClustering</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load the kidney cancer carcinoma data
data(KIRC)

# Perform subtyping on the multi-omics data
dataList &lt;- list (as.matrix(KIRC$GE), as.matrix(KIRC$ME), as.matrix(KIRC$MI)) 
names(dataList) &lt;- c("GE", "ME", "MI")
result &lt;- SubtypingOmicsData(dataList = dataList)

# Change Pertubation clustering algorithm's arguments
result &lt;- SubtypingOmicsData(
    dataList = dataList, 
    clusteringMethod = "kmeans", 
    clusteringOptions = list(nstart = 50)
)

# Plot the Kaplan-Meier curves and calculate Cox p-value
library(survival)
cluster1=result$cluster1;cluster2=result$cluster2
a &lt;- intersect(unique(cluster2), unique(cluster1))
names(a) &lt;- intersect(unique(cluster2), unique(cluster1))
a[setdiff(unique(cluster2), unique(cluster1))] &lt;- seq(setdiff(unique(cluster2), unique(cluster1))) 
                                                  + max(cluster1)
colors &lt;- a[levels(factor(cluster2))]
coxFit &lt;- coxph(
 Surv(time = Survival, event = Death) ~ as.factor(cluster2),
 data = KIRC$survival,
 ties = "exact"
)
mfit &lt;- survfit(Surv(Survival, Death == 1) ~ as.factor(cluster2), data = KIRC$survival)
plot(
 mfit, col = colors,
 main = "Survival curves for KIRC, level 2",
 xlab = "Days", ylab = "Survival",lwd = 2
)
legend("bottomright", 
    legend = paste(
        "Cox p-value:", 
        round(summary(coxFit)$sctest[3], digits = 5), 
        sep = ""
    )
)
legend(
    "bottomleft",
    fill = colors,
    legend = paste(
        "Group ",
        levels(factor(cluster2)),": ", table(cluster2)[levels(factor(cluster2))], 
        sep =""
    )
)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
