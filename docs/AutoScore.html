<!DOCTYPE html><html><head><title>Help for package AutoScore</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {AutoScore}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_baseline'><p>Internal Function: Add baselines after second-step logistic regression (part of AutoScore Module 3)</p></a></li>
<li><a href='#assign_score'><p>Internal Function: Automatically assign scores to each subjects given new data set and scoring table (Used for intermediate and final evaluation)</p></a></li>
<li><a href='#AutoScore_fine_tuning'><p>AutoScore STEP(iv): Fine-tune the score by revising cut_vec with domain knowledge (AutoScore Module 5)</p></a></li>
<li><a href='#AutoScore_fine_tuning_Ordinal'><p>AutoScore STEP(iv) for ordinal outcomes: Fine-tune the score by</p>
revising <code>cut_vec</code> with domain knowledge (AutoScore Module 5)</a></li>
<li><a href='#AutoScore_fine_tuning_Survival'><p>AutoScore STEP(iv) for survival outcomes: Fine-tune the score by</p>
revising cut_vec with domain knowledge (AutoScore Module 5)</a></li>
<li><a href='#AutoScore_parsimony'><p>AutoScore STEP(ii): Select the best model with parsimony plot (AutoScore Modules 2+3+4)</p></a></li>
<li><a href='#AutoScore_parsimony_Ordinal'><p>AutoScore STEP(ii) for ordinal outcomes: Select the best model with</p>
parsimony plot (AutoScore Modules 2+3+4)</a></li>
<li><a href='#AutoScore_parsimony_Survival'><p>AutoScore STEP(ii) for survival outcomes: Select the best model with</p>
parsimony plot (AutoScore Modules 2+3+4)</a></li>
<li><a href='#AutoScore_rank'><p>AutoScore STEP(i): Rank variables with machine learning (AutoScore Module 1)</p></a></li>
<li><a href='#AutoScore_rank_Ordinal'><p>AutoScore STEP (i) for ordinal outcomes: Generate variable ranking</p>
list by machine learning (AutoScore Module 1)</a></li>
<li><a href='#AutoScore_rank_Survival'><p>AutoScore STEP (1) for survival outcomes: Generate variable ranking</p>
List by machine learning (Random Survival Forest) (AutoScore Module 1)</a></li>
<li><a href='#AutoScore_testing'><p>AutoScore STEP(v): Evaluate the final score with ROC analysis (AutoScore Module 6)</p></a></li>
<li><a href='#AutoScore_testing_Ordinal'><p>AutoScore STEP(v) for ordinal outcomes: Evaluate the final score</p>
(AutoScore Module 6)</a></li>
<li><a href='#AutoScore_testing_Survival'><p>AutoScore STEP(v) for survival outcomes: Evaluate the final score with</p>
ROC analysis (AutoScore Module 6)</a></li>
<li><a href='#AutoScore_weighting'><p>AutoScore STEP(iii): Generate the initial score with the final list of variables (Re-run AutoScore Modules 2+3)</p></a></li>
<li><a href='#AutoScore_weighting_Ordinal'><p>AutoScore STEP(iii) for ordinal outcomes: Generate the initial score</p>
with the final list of variables (Re-run AutoScore Modules 2+3)</a></li>
<li><a href='#AutoScore_weighting_Survival'><p>AutoScore STEP(iii) for survival outcomes: Generate the initial score</p>
with the final list of variables (Re-run AutoScore Modules 2+3)</a></li>
<li><a href='#change_reference'><p>Internal Function: Change Reference category after first-step logistic regression (part of AutoScore Module 3)</p></a></li>
<li><a href='#check_data'><p>AutoScore function for datasets with binary outcomes: Check whether the input dataset fulfill the requirement of the AutoScore</p></a></li>
<li><a href='#check_data_ordinal'><p>AutoScore function for ordinal outcomes: Check whether the input</p>
dataset fulfil the requirement of the AutoScore</a></li>
<li><a href='#check_data_survival'><p>AutoScore function for survival data: Check whether the input</p>
dataset fulfill the requirement of the AutoScore</a></li>
<li><a href='#check_link'><p>Internal function: Check link function</p></a></li>
<li><a href='#check_predictor'><p>Internal function: Check predictors</p></a></li>
<li><a href='#compute_auc_val'><p>Internal function: Compute AUC based on validation set for plotting parsimony (AutoScore Module 4)</p></a></li>
<li><a href='#compute_auc_val_ord'><p>Internal function: Compute mean AUC for ordinal outcomes based on</p>
validation set for plotting parsimony</a></li>
<li><a href='#compute_auc_val_survival'><p>Internal function for survival outcomes: Compute AUC based on validation set for plotting parsimony</p></a></li>
<li><a href='#compute_descriptive_table'><p>AutoScore function: Descriptive Analysis</p></a></li>
<li><a href='#compute_final_score_ord'><p>Internal function: Compute risk scores for ordinal data given variables</p>
selected, cut-off values and scoring table</a></li>
<li><a href='#compute_mauc_ord'><p>Internal function: Compute mAUC for ordinal predictions</p></a></li>
<li><a href='#compute_multi_variable_table'><p>AutoScore function: Multivariate Analysis</p></a></li>
<li><a href='#compute_multi_variable_table_ordinal'><p>AutoScore-Ordinal function: Multivariate Analysis</p></a></li>
<li><a href='#compute_multi_variable_table_survival'><p>AutoScore function for survival outcomes: Multivariate Analysis</p></a></li>
<li><a href='#compute_prob_observed'><p>Internal function: Based on given labels and scores, compute proportion of</p>
subjects observed in each outcome category in given score intervals.</a></li>
<li><a href='#compute_prob_predicted'><p>Internal function: Based on given labels and scores, compute average</p>
predicted risks in given score intervals.</a></li>
<li><a href='#compute_score_table'><p>Internal function: Compute scoring table based on training dataset (AutoScore Module 3)</p></a></li>
<li><a href='#compute_score_table_ord'><p>Internal function: Compute scoring table for ordinal outcomes based on</p>
training dataset</a></li>
<li><a href='#compute_score_table_survival'><p>Internal function: Compute scoring table for survival outcomes based on training dataset</p></a></li>
<li><a href='#compute_uni_variable_table'><p>AutoScore function: Univariable Analysis</p></a></li>
<li><a href='#compute_uni_variable_table_ordinal'><p>AutoScore-Ordinal function: Univariable Analysis</p></a></li>
<li><a href='#compute_uni_variable_table_survival'><p>AutoScore function for survival outcomes: Univariate Analysis</p></a></li>
<li><a href='#conversion_table'><p>AutoScore function: Print conversion table based on final performance evaluation</p></a></li>
<li><a href='#conversion_table_ordinal'><p>AutoScore function: Print conversion table for ordinal outcomes to map score to risk</p></a></li>
<li><a href='#conversion_table_survival'><p>AutoScore function for survival outcomes: Print conversion table</p></a></li>
<li><a href='#estimate_p_mat'><p>Internal function: generate probability matrix for ordinal outcomes given</p>
thresholds, linear predictor and link function</a></li>
<li><a href='#eva_performance_iauc'><p>Internal function survival outcome: Calculate iAUC for validation set</p></a></li>
<li><a href='#evaluate_model_ord'><p>Internal function: Evaluate model performance on ordinal data</p></a></li>
<li><a href='#extract_or_ci_ord'><p>Extract OR, CI and p-value from a proportional odds model</p></a></li>
<li><a href='#find_one_inds'><p>Internal function: Find column indices in design matrix that should be 1</p></a></li>
<li><a href='#find_possible_scores'><p>Internal function: Compute all scores attainable.</p></a></li>
<li><a href='#get_cut_vec'><p>Internal function: Calculate cut_vec from the training set (AutoScore Module 2)</p></a></li>
<li><a href='#group_score'><p>Internal function: Group scores based on given score breaks, and use friendly</p>
names for first and last intervals.</a></li>
<li><a href='#induce_informative_missing'><p>Internal function: induce informative missing to sample data in the package</p>
to demonstrate how AutoScore handles missing as a separate category</a></li>
<li><a href='#induce_median_missing'><p>Internal function: induce informative missing in a single variable</p></a></li>
<li><a href='#inv_cloglog'><p>Internal function: Inverse cloglog link</p></a></li>
<li><a href='#inv_logit'><p>Internal function: Inverse logit link</p></a></li>
<li><a href='#inv_probit'><p>Internal function: Inverse probit link</p></a></li>
<li><a href='#make_design_mat'><p>Internal function: Based on <code>find_one_inds</code>, make a design matrix to</p>
compute all scores attainable.</a></li>
<li><a href='#plot_auc'><p>Internal function: Make parsimony plot</p></a></li>
<li><a href='#plot_importance'><p>Internal Function: Print plotted variable importance</p></a></li>
<li><a href='#plot_predicted_risk'><p>AutoScore function for binary and ordinal outcomes: Plot predicted risk</p></a></li>
<li><a href='#plot_roc_curve'><p>Internal Function: Plotting ROC curve</p></a></li>
<li><a href='#plot_survival_km'><p>AutoScore function for survival outcomes: Print scoring performance (KM curve)</p></a></li>
<li><a href='#print_performance_ci_survival'><p>AutoScore function for survival outcomes: Print predictive performance with confidence intervals</p></a></li>
<li><a href='#print_performance_ordinal'><p>AutoScore function for ordinal outcomes: Print predictive performance</p></a></li>
<li><a href='#print_performance_survival'><p>AutoScore function for survival outcomes: Print predictive performance</p></a></li>
<li><a href='#print_roc_performance'><p>AutoScore function: Print receiver operating characteristic (ROC) performance</p></a></li>
<li><a href='#print_scoring_table'><p>AutoScore Function: Print scoring tables for visualization</p></a></li>
<li><a href='#sample_data'><p>20000 simulated ICU admission data, with the same distribution as the data in the MIMIC-III ICU database</p></a></li>
<li><a href='#sample_data_ordinal'><p>Simulated ED data with ordinal outcome</p></a></li>
<li><a href='#sample_data_ordinal_small'><p>Simulated ED data with ordinal outcome (small sample size)</p></a></li>
<li><a href='#sample_data_small'><p>1000 simulated ICU admission data, with the same distribution as the data in the MIMIC-III ICU database</p></a></li>
<li><a href='#sample_data_survival'><p>20000 simulated MIMIC sample data with survival outcomes</p></a></li>
<li><a href='#sample_data_survival_small'><p>1000 simulated MIMIC sample data with survival outcomes</p></a></li>
<li><a href='#sample_data_with_missing'><p>20000 simulated ICU admission data with missing values</p></a></li>
<li><a href='#split_data'><p>AutoScore Function: Automatically splitting dataset to train,</p>
validation and test set, possibly stratified by label</a></li>
<li><a href='#transform_df_fixed'><p>Internal function: Categorizing continuous variables based on cut_vec (AutoScore Module 2)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>An Interpretable Machine Learning-Based Automatic Clinical Score
Generator</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-10-08</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/nliulab/AutoScore">https://github.com/nliulab/AutoScore</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/nliulab/AutoScore/issues">https://github.com/nliulab/AutoScore/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>A novel interpretable machine learning-based framework to automate the development of a clinical scoring model for predefined outcomes. Our novel framework consists of six modules: variable ranking with machine learning, variable transformation, score derivation, model selection, domain knowledge-based score fine-tuning, and performance evaluation.The The original AutoScore structure is described in the research paper&lt;<a href="https://doi.org/10.2196%2F21798">doi:10.2196/21798</a>&gt;. A full tutorial can be found here<a href="https://nliulab.github.io/AutoScore/">https://nliulab.github.io/AutoScore/</a>. Users or clinicians could seamlessly generate parsimonious sparse-score risk models (i.e., risk scores), which can be easily implemented and validated in clinical practice. We hope to see its application in various medical case studies.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>tableone, pROC, randomForest, ggplot2, knitr, Hmisc, car,
coxed, dplyr, ordinal, survival, tidyr, plotly, magrittr,
randomForestSRC, rlang, survAUC, survminer</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rpart, rmarkdown</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-14 18:06:47 UTC; xxxxf</td>
</tr>
<tr>
<td>Author:</td>
<td>Feng Xie <a href="https://orcid.org/0000-0002-0215-667X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Yilin Ning <a href="https://orcid.org/0000-0002-6758-4472"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Han Yuan <a href="https://orcid.org/0000-0002-2674-6068"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Mingxuan Liu <a href="https://orcid.org/0000-0002-4274-9613"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Seyed Ehsan Saffari
    <a href="https://orcid.org/0000-0002-6473-4375"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Siqi Li <a href="https://orcid.org/0000-0002-1660-105X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Bibhas Chakraborty
    <a href="https://orcid.org/0000-0002-7366-0478"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Nan Liu <a href="https://orcid.org/0000-0003-3610-4883"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Feng Xie &lt;xief@u.duke.nus.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-15 22:15:26 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_baseline'>Internal Function: Add baselines after second-step logistic regression (part of AutoScore Module 3)</h2><span id='topic+add_baseline'></span>

<h3>Description</h3>

<p>Internal Function: Add baselines after second-step logistic regression (part of AutoScore Module 3)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_baseline(df, coef_vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_baseline_+3A_df">df</code></td>
<td>
<p>A <code>data.frame</code> used for logistic regression</p>
</td></tr>
<tr><td><code id="add_baseline_+3A_coef_vec">coef_vec</code></td>
<td>
<p>Generated from logistic regression</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Processed <code>vector</code> for generating the scoring table
</p>

<hr>
<h2 id='assign_score'>Internal Function: Automatically assign scores to each subjects given new data set and scoring table (Used for intermediate and final evaluation)</h2><span id='topic+assign_score'></span>

<h3>Description</h3>

<p>Internal Function: Automatically assign scores to each subjects given new data set and scoring table (Used for intermediate and final evaluation)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assign_score(df, score_table)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assign_score_+3A_df">df</code></td>
<td>
<p>A <code>data.frame</code> used for testing, where variables keep before categorization</p>
</td></tr>
<tr><td><code id="assign_score_+3A_score_table">score_table</code></td>
<td>
<p>A <code>vector</code> containing the scoring table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Processed <code>data.frame</code> with assigned scores for each variables
</p>

<hr>
<h2 id='AutoScore_fine_tuning'>AutoScore STEP(iv): Fine-tune the score by revising cut_vec with domain knowledge (AutoScore Module 5)</h2><span id='topic+AutoScore_fine_tuning'></span>

<h3>Description</h3>

<p>Domain knowledge is essential in guiding risk model development.
For continuous variables, the variable transformation is a data-driven process (based on &quot;quantile&quot; or &quot;kmeans&quot; ).
In this step, the automatically generated cutoff values for each continuous variable can be fine-tuned
by combining, rounding, and adjusting according to the standard clinical norm.  Revised <code>cut_vec</code> will be input with domain knowledge to
update scoring table. User can choose any cut-off values/any number of categories. Then final Scoring table will be generated. Run <code>vignette("Guide_book", package = "AutoScore")</code> to see the guidebook or vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AutoScore_fine_tuning(
  train_set,
  validation_set,
  final_variables,
  cut_vec,
  max_score = 100,
  metrics_ci = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AutoScore_fine_tuning_+3A_train_set">train_set</code></td>
<td>
<p>A processed <code>data.frame</code> that contains data to be analyzed, for training.</p>
</td></tr>
<tr><td><code id="AutoScore_fine_tuning_+3A_validation_set">validation_set</code></td>
<td>
<p>A processed <code>data.frame</code> that contains data for validation purpose.</p>
</td></tr>
<tr><td><code id="AutoScore_fine_tuning_+3A_final_variables">final_variables</code></td>
<td>
<p>A vector containing the list of selected variables, selected from Step(ii) <code><a href="#topic+AutoScore_parsimony">AutoScore_parsimony</a></code>. Run <code>vignette("Guide_book", package = "AutoScore")</code> to see the guidebook or vignette.</p>
</td></tr>
<tr><td><code id="AutoScore_fine_tuning_+3A_cut_vec">cut_vec</code></td>
<td>
<p>Generated from STEP(iii) <code><a href="#topic+AutoScore_weighting">AutoScore_weighting</a></code>.Please follow the guidebook</p>
</td></tr>
<tr><td><code id="AutoScore_fine_tuning_+3A_max_score">max_score</code></td>
<td>
<p>Maximum total score (Default: 100).</p>
</td></tr>
<tr><td><code id="AutoScore_fine_tuning_+3A_metrics_ci">metrics_ci</code></td>
<td>
<p>whether to calculate confidence interval for the metrics of sensitivity, specificity, etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Generated final table of scoring model for downstream testing
</p>


<h3>References</h3>


<ul>
<li><p>Xie F, Chakraborty B, Ong MEH, Goldstein BA, Liu N. AutoScore: A Machine Learning-Based Automatic Clinical Score Generator and
Its Application to Mortality Prediction Using Electronic Health Records. JMIR Medical Informatics 2020;8(10):e21798
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+AutoScore_rank">AutoScore_rank</a></code>, <code><a href="#topic+AutoScore_parsimony">AutoScore_parsimony</a></code>, <code><a href="#topic+AutoScore_weighting">AutoScore_weighting</a></code>, <code><a href="#topic+AutoScore_testing">AutoScore_testing</a></code>,Run <code>vignette("Guide_book", package = "AutoScore")</code> to see the guidebook or vignette.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Please see the guidebook or vignettes
</code></pre>

<hr>
<h2 id='AutoScore_fine_tuning_Ordinal'>AutoScore STEP(iv) for ordinal outcomes: Fine-tune the score by
revising <code>cut_vec</code> with domain knowledge (AutoScore Module 5)</h2><span id='topic+AutoScore_fine_tuning_Ordinal'></span>

<h3>Description</h3>

<p>Domain knowledge is essential in guiding risk model development.
For continuous variables, the variable transformation is a data-driven process (based on &quot;quantile&quot; or &quot;kmeans&quot; ).
In this step, the automatically generated cutoff values for each continuous variable can be fine-tuned
by combining, rounding, and adjusting according to the standard clinical norm.  Revised <code>cut_vec</code> will be input with domain knowledge to
update scoring table. User can choose any cut-off values/any number of categories. Then final Scoring table will be generated. Run <code>vignette("Guide_book", package = "AutoScore")</code> to see the guidebook or vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AutoScore_fine_tuning_Ordinal(
  train_set,
  validation_set,
  final_variables,
  link = "logit",
  cut_vec,
  max_score = 100,
  n_boot = 100,
  report_cindex = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AutoScore_fine_tuning_Ordinal_+3A_train_set">train_set</code></td>
<td>
<p>A processed <code>data.frame</code> that contains data to be analyzed, for training.</p>
</td></tr>
<tr><td><code id="AutoScore_fine_tuning_Ordinal_+3A_validation_set">validation_set</code></td>
<td>
<p>A processed <code>data.frame</code> that contains data for validation purpose.</p>
</td></tr>
<tr><td><code id="AutoScore_fine_tuning_Ordinal_+3A_final_variables">final_variables</code></td>
<td>
<p>A vector containing the list of selected variables,
selected from Step(ii) <code><a href="#topic+AutoScore_parsimony_Ordinal">AutoScore_parsimony_Ordinal</a></code>.</p>
</td></tr>
<tr><td><code id="AutoScore_fine_tuning_Ordinal_+3A_link">link</code></td>
<td>
<p>The link function used to model ordinal outcomes. Default is
<code>"logit"</code> for proportional odds model. Other options are
<code>"cloglog"</code> (proportional hazards model) and <code>"probit"</code>.</p>
</td></tr>
<tr><td><code id="AutoScore_fine_tuning_Ordinal_+3A_cut_vec">cut_vec</code></td>
<td>
<p>Generated from STEP(iii) <code><a href="#topic+AutoScore_weighting_Ordinal">AutoScore_weighting_Ordinal</a></code>.</p>
</td></tr>
<tr><td><code id="AutoScore_fine_tuning_Ordinal_+3A_max_score">max_score</code></td>
<td>
<p>Maximum total score (Default: 100).</p>
</td></tr>
<tr><td><code id="AutoScore_fine_tuning_Ordinal_+3A_n_boot">n_boot</code></td>
<td>
<p>Number of bootstrap cycles to compute 95% CI for performance
metrics.</p>
</td></tr>
<tr><td><code id="AutoScore_fine_tuning_Ordinal_+3A_report_cindex">report_cindex</code></td>
<td>
<p>Whether to report generalized c-index for model
evaluation (Default:FALSE for faster evaluation).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Generated final table of scoring model for downstream testing
</p>


<h3>References</h3>


<ul>
<li><p>Saffari SE, Ning Y, Feng X, Chakraborty B, Volovici V, Vaughan R, Ong
ME, Liu N, AutoScore-Ordinal: An interpretable machine learning framework for
generating scoring models for ordinal outcomes, arXiv:2202.08407
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+AutoScore_rank_Ordinal">AutoScore_rank_Ordinal</a></code>,
<code><a href="#topic+AutoScore_parsimony_Ordinal">AutoScore_parsimony_Ordinal</a></code>,
<code><a href="#topic+AutoScore_weighting_Ordinal">AutoScore_weighting_Ordinal</a></code>,
<code><a href="#topic+AutoScore_testing_Ordinal">AutoScore_testing_Ordinal</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Please see the guidebook or vignettes
</code></pre>

<hr>
<h2 id='AutoScore_fine_tuning_Survival'>AutoScore STEP(iv) for survival outcomes: Fine-tune the score by
revising cut_vec with domain knowledge (AutoScore Module 5)</h2><span id='topic+AutoScore_fine_tuning_Survival'></span>

<h3>Description</h3>

<p>Domain knowledge is essential in guiding risk model development.
For continuous variables, the variable transformation is a data-driven process (based on &quot;quantile&quot; or &quot;kmeans&quot; ).
In this step, the automatically generated cutoff values for each continuous variable can be fine-tuned
by combining, rounding, and adjusting according to the standard clinical norm.  Revised <code>cut_vec</code> will be input with domain knowledge to
update scoring table. User can choose any cut-off values/any number of categories. Then final Scoring table will be generated. Run <code>vignette("Guide_book", package = "AutoScore")</code> to see the guidebook or vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AutoScore_fine_tuning_Survival(
  train_set,
  validation_set,
  final_variables,
  cut_vec,
  max_score = 100,
  time_point = c(1, 3, 7, 14, 30, 60, 90)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AutoScore_fine_tuning_Survival_+3A_train_set">train_set</code></td>
<td>
<p>A processed <code>data.frame</code> that contains data to be analyzed, for training.</p>
</td></tr>
<tr><td><code id="AutoScore_fine_tuning_Survival_+3A_validation_set">validation_set</code></td>
<td>
<p>A processed <code>data.frame</code> that contains data for validation purpose.</p>
</td></tr>
<tr><td><code id="AutoScore_fine_tuning_Survival_+3A_final_variables">final_variables</code></td>
<td>
<p>A vector containing the list of selected variables, selected from Step(ii) <code><a href="#topic+AutoScore_parsimony">AutoScore_parsimony</a></code>. Run <code>vignette("Guide_book", package = "AutoScore")</code> to see the guidebook or vignette.</p>
</td></tr>
<tr><td><code id="AutoScore_fine_tuning_Survival_+3A_cut_vec">cut_vec</code></td>
<td>
<p>Generated from STEP(iii)
<code>AutoScore_weighting_Survival()</code>.Please follow the guidebook</p>
</td></tr>
<tr><td><code id="AutoScore_fine_tuning_Survival_+3A_max_score">max_score</code></td>
<td>
<p>Maximum total score (Default: 100).</p>
</td></tr>
<tr><td><code id="AutoScore_fine_tuning_Survival_+3A_time_point">time_point</code></td>
<td>
<p>The time points to be evaluated using time-dependent AUC(t).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Generated final table of scoring model for downstream testing
</p>


<h3>References</h3>


<ul>
<li><p>Xie F, Ning Y, Yuan H, et al. AutoScore-Survival: Developing
interpretable machine learning-based time-to-event scores with right-censored
survival data. J Biomed Inform. 2022;125:103959. doi:10.1016/j.jbi.2021.103959
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+AutoScore_rank_Survival">AutoScore_rank_Survival</a></code>,
<code><a href="#topic+AutoScore_parsimony_Survival">AutoScore_parsimony_Survival</a></code>,
<code><a href="#topic+AutoScore_weighting_Survival">AutoScore_weighting_Survival</a></code>,
<code><a href="#topic+AutoScore_testing_Survival">AutoScore_testing_Survival</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Please see the guidebook or vignettes
</code></pre>

<hr>
<h2 id='AutoScore_parsimony'>AutoScore STEP(ii): Select the best model with parsimony plot (AutoScore Modules 2+3+4)</h2><span id='topic+AutoScore_parsimony'></span>

<h3>Description</h3>

<p>AutoScore STEP(ii): Select the best model with parsimony plot (AutoScore Modules 2+3+4)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AutoScore_parsimony(
  train_set,
  validation_set,
  rank,
  max_score = 100,
  n_min = 1,
  n_max = 20,
  cross_validation = FALSE,
  fold = 10,
  categorize = "quantile",
  quantiles = c(0, 0.05, 0.2, 0.8, 0.95, 1),
  max_cluster = 5,
  do_trace = FALSE,
  auc_lim_min = 0.5,
  auc_lim_max = "adaptive"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AutoScore_parsimony_+3A_train_set">train_set</code></td>
<td>
<p>A processed <code>data.frame</code> that contains data to be analyzed, for training.</p>
</td></tr>
<tr><td><code id="AutoScore_parsimony_+3A_validation_set">validation_set</code></td>
<td>
<p>A processed <code>data.frame</code> that contains data for validation purpose.</p>
</td></tr>
<tr><td><code id="AutoScore_parsimony_+3A_rank">rank</code></td>
<td>
<p>the raking result generated from AutoScore STEP(i) <code><a href="#topic+AutoScore_rank">AutoScore_rank</a></code></p>
</td></tr>
<tr><td><code id="AutoScore_parsimony_+3A_max_score">max_score</code></td>
<td>
<p>Maximum total score (Default: 100).</p>
</td></tr>
<tr><td><code id="AutoScore_parsimony_+3A_n_min">n_min</code></td>
<td>
<p>Minimum number of selected variables (Default: 1).</p>
</td></tr>
<tr><td><code id="AutoScore_parsimony_+3A_n_max">n_max</code></td>
<td>
<p>Maximum number of selected variables (Default: 20).</p>
</td></tr>
<tr><td><code id="AutoScore_parsimony_+3A_cross_validation">cross_validation</code></td>
<td>
<p>If set to <code>TRUE</code>, cross-validation would be used for generating parsimony plot, which is
suitable for small-size data. Default to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="AutoScore_parsimony_+3A_fold">fold</code></td>
<td>
<p>The number of folds used in cross validation (Default: 10). Available if <code>cross_validation = TRUE</code>.</p>
</td></tr>
<tr><td><code id="AutoScore_parsimony_+3A_categorize">categorize</code></td>
<td>
<p>Methods for categorize continuous variables. Options include &quot;quantile&quot; or &quot;kmeans&quot; (Default: &quot;quantile&quot;).</p>
</td></tr>
<tr><td><code id="AutoScore_parsimony_+3A_quantiles">quantiles</code></td>
<td>
<p>Predefined quantiles to convert continuous variables to categorical ones. (Default: c(0, 0.05, 0.2, 0.8, 0.95, 1)) Available if <code>categorize = "quantile"</code>.</p>
</td></tr>
<tr><td><code id="AutoScore_parsimony_+3A_max_cluster">max_cluster</code></td>
<td>
<p>The max number of cluster (Default: 5). Available if <code>categorize = "kmeans"</code>.</p>
</td></tr>
<tr><td><code id="AutoScore_parsimony_+3A_do_trace">do_trace</code></td>
<td>
<p>If set to TRUE, all results based on each fold of cross-validation would be printed out and plotted (Default: FALSE). Available if <code>cross_validation = TRUE</code>.</p>
</td></tr>
<tr><td><code id="AutoScore_parsimony_+3A_auc_lim_min">auc_lim_min</code></td>
<td>
<p>Min y_axis limit in the parsimony plot (Default: 0.5).</p>
</td></tr>
<tr><td><code id="AutoScore_parsimony_+3A_auc_lim_max">auc_lim_max</code></td>
<td>
<p>Max y_axis limit in the parsimony plot (Default: &quot;adaptive&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the second step of the general AutoScore workflow, to generate the parsimony plot to help select a parsimonious model.
In this step, it goes through AutoScore Module 2,3 and 4 multiple times and to evaluate the performance under different variable list.
The generated parsimony plot would give researcher an intuitive figure to choose the best models.
If data size is small (ie, &lt;5000), an independent validation set may not be a wise choice. Then, we suggest using cross-validation
to maximize the utility of data. Set <code>cross_validation=TRUE</code>. Run <code>vignette("Guide_book", package = "AutoScore")</code> to see the guidebook or vignette.
</p>


<h3>Value</h3>

<p>List of AUC value for different number of variables
</p>


<h3>References</h3>


<ul>
<li><p>Xie F, Chakraborty B, Ong MEH, Goldstein BA, Liu N, AutoScore: A Machine Learning-Based Automatic Clinical
Score Generator and Its Application to Mortality Prediction Using Electronic Health Records,
JMIR Med Inform 2020;8(10):e21798, doi: 10.2196/21798
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+AutoScore_rank">AutoScore_rank</a></code>, <code><a href="#topic+AutoScore_weighting">AutoScore_weighting</a></code>, <code><a href="#topic+AutoScore_fine_tuning">AutoScore_fine_tuning</a></code>, <code><a href="#topic+AutoScore_testing">AutoScore_testing</a></code>, Run <code>vignette("Guide_book", package = "AutoScore")</code> to see the guidebook or vignette.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# see AutoScore Guidebook for the whole 5-step workflow
data("sample_data")
names(sample_data)[names(sample_data) == "Mortality_inpatient"] &lt;- "label"
out_split &lt;- split_data(data = sample_data, ratio = c(0.7, 0.1, 0.2))
train_set &lt;- out_split$train_set
validation_set &lt;- out_split$validation_set
ranking &lt;- AutoScore_rank(train_set, ntree=100)
AUC &lt;- AutoScore_parsimony(
train_set,
validation_set,
rank = ranking,
max_score = 100,
n_min = 1,
n_max = 20,
categorize = "quantile",
quantiles = c(0, 0.05, 0.2, 0.8, 0.95, 1)
)
</code></pre>

<hr>
<h2 id='AutoScore_parsimony_Ordinal'>AutoScore STEP(ii) for ordinal outcomes: Select the best model with
parsimony plot (AutoScore Modules 2+3+4)</h2><span id='topic+AutoScore_parsimony_Ordinal'></span>

<h3>Description</h3>

<p>AutoScore STEP(ii) for ordinal outcomes: Select the best model with
parsimony plot (AutoScore Modules 2+3+4)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AutoScore_parsimony_Ordinal(
  train_set,
  validation_set,
  rank,
  link = "logit",
  max_score = 100,
  n_min = 1,
  n_max = 20,
  cross_validation = FALSE,
  fold = 10,
  categorize = "quantile",
  quantiles = c(0, 0.05, 0.2, 0.8, 0.95, 1),
  max_cluster = 5,
  do_trace = FALSE,
  auc_lim_min = 0.5,
  auc_lim_max = "adaptive"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AutoScore_parsimony_Ordinal_+3A_train_set">train_set</code></td>
<td>
<p>A processed <code>data.frame</code> that contains data to be analyzed, for training.</p>
</td></tr>
<tr><td><code id="AutoScore_parsimony_Ordinal_+3A_validation_set">validation_set</code></td>
<td>
<p>A processed <code>data.frame</code> that contains data for validation purpose.</p>
</td></tr>
<tr><td><code id="AutoScore_parsimony_Ordinal_+3A_rank">rank</code></td>
<td>
<p>The raking result generated from AutoScore STEP(i) for ordinal
outcomes (<code><a href="#topic+AutoScore_rank_Ordinal">AutoScore_rank_Ordinal</a></code>).</p>
</td></tr>
<tr><td><code id="AutoScore_parsimony_Ordinal_+3A_link">link</code></td>
<td>
<p>The link function used to model ordinal outcomes. Default is
<code>"logit"</code> for proportional odds model. Other options are
<code>"cloglog"</code> (proportional hazards model) and <code>"probit"</code>.</p>
</td></tr>
<tr><td><code id="AutoScore_parsimony_Ordinal_+3A_max_score">max_score</code></td>
<td>
<p>Maximum total score (Default: 100).</p>
</td></tr>
<tr><td><code id="AutoScore_parsimony_Ordinal_+3A_n_min">n_min</code></td>
<td>
<p>Minimum number of selected variables (Default: 1).</p>
</td></tr>
<tr><td><code id="AutoScore_parsimony_Ordinal_+3A_n_max">n_max</code></td>
<td>
<p>Maximum number of selected variables (Default: 20).</p>
</td></tr>
<tr><td><code id="AutoScore_parsimony_Ordinal_+3A_cross_validation">cross_validation</code></td>
<td>
<p>If set to <code>TRUE</code>, cross-validation would be used for generating parsimony plot, which is
suitable for small-size data. Default to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="AutoScore_parsimony_Ordinal_+3A_fold">fold</code></td>
<td>
<p>The number of folds used in cross validation (Default: 10). Available if <code>cross_validation = TRUE</code>.</p>
</td></tr>
<tr><td><code id="AutoScore_parsimony_Ordinal_+3A_categorize">categorize</code></td>
<td>
<p>Methods for categorize continuous variables. Options include &quot;quantile&quot; or &quot;kmeans&quot; (Default: &quot;quantile&quot;).</p>
</td></tr>
<tr><td><code id="AutoScore_parsimony_Ordinal_+3A_quantiles">quantiles</code></td>
<td>
<p>Predefined quantiles to convert continuous variables to categorical ones. (Default: c(0, 0.05, 0.2, 0.8, 0.95, 1)) Available if <code>categorize = "quantile"</code>.</p>
</td></tr>
<tr><td><code id="AutoScore_parsimony_Ordinal_+3A_max_cluster">max_cluster</code></td>
<td>
<p>The max number of cluster (Default: 5). Available if <code>categorize = "kmeans"</code>.</p>
</td></tr>
<tr><td><code id="AutoScore_parsimony_Ordinal_+3A_do_trace">do_trace</code></td>
<td>
<p>If set to TRUE, all results based on each fold of cross-validation would be printed out and plotted (Default: FALSE). Available if <code>cross_validation = TRUE</code>.</p>
</td></tr>
<tr><td><code id="AutoScore_parsimony_Ordinal_+3A_auc_lim_min">auc_lim_min</code></td>
<td>
<p>Min y_axis limit in the parsimony plot (Default: 0.5).</p>
</td></tr>
<tr><td><code id="AutoScore_parsimony_Ordinal_+3A_auc_lim_max">auc_lim_max</code></td>
<td>
<p>Max y_axis limit in the parsimony plot (Default: &quot;adaptive&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the second step of the general AutoScore workflow for
ordinal outcomes, to generate the parsimony plot to help select a
parsimonious model. In this step, it goes through AutoScore Module 2,3 and
4 multiple times and to evaluate the performance under different variable
list. The generated parsimony plot would give researcher an intuitive
figure to choose the best models. If data size is small (eg, &lt;5000), an
independent validation set may not be a wise choice. Then, we suggest using
cross-validation to maximize the utility of data. Set
<code>cross_validation=TRUE</code>.
</p>


<h3>Value</h3>

<p>List of mAUC (ie, the average AUC of dichotomous classifications)
value for different number of variables
</p>


<h3>References</h3>


<ul>
<li><p>Saffari SE, Ning Y, Feng X, Chakraborty B, Volovici V, Vaughan R, Ong
ME, Liu N, AutoScore-Ordinal: An interpretable machine learning framework for
generating scoring models for ordinal outcomes, arXiv:2202.08407
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+AutoScore_rank_Ordinal">AutoScore_rank_Ordinal</a></code>,
<code><a href="#topic+AutoScore_weighting_Ordinal">AutoScore_weighting_Ordinal</a></code>,
<code><a href="#topic+AutoScore_fine_tuning_Ordinal">AutoScore_fine_tuning_Ordinal</a></code>,
<code><a href="#topic+AutoScore_testing_Ordinal">AutoScore_testing_Ordinal</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# see AutoScore-Ordinal Guidebook for the whole 5-step workflow
data("sample_data_ordinal") # Output is named `label`
out_split &lt;- split_data(data = sample_data_ordinal, ratio = c(0.7, 0.1, 0.2))
train_set &lt;- out_split$train_set
validation_set &lt;- out_split$validation_set
ranking &lt;- AutoScore_rank_Ordinal(train_set, ntree=100)
mAUC &lt;- AutoScore_parsimony_Ordinal(
  train_set = train_set, validation_set = validation_set,
  rank = ranking, max_score = 100, n_min = 1, n_max = 20,
  categorize = "quantile", quantiles = c(0, 0.05, 0.2, 0.8, 0.95, 1)
)

## End(Not run)
</code></pre>

<hr>
<h2 id='AutoScore_parsimony_Survival'>AutoScore STEP(ii) for survival outcomes: Select the best model with
parsimony plot (AutoScore Modules 2+3+4)</h2><span id='topic+AutoScore_parsimony_Survival'></span>

<h3>Description</h3>

<p>AutoScore STEP(ii) for survival outcomes: Select the best model with
parsimony plot (AutoScore Modules 2+3+4)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AutoScore_parsimony_Survival(
  train_set,
  validation_set,
  rank,
  max_score = 100,
  n_min = 1,
  n_max = 20,
  cross_validation = FALSE,
  fold = 10,
  categorize = "quantile",
  quantiles = c(0, 0.05, 0.2, 0.8, 0.95, 1),
  max_cluster = 5,
  do_trace = FALSE,
  auc_lim_min = 0.5,
  auc_lim_max = "adaptive"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AutoScore_parsimony_Survival_+3A_train_set">train_set</code></td>
<td>
<p>A processed <code>data.frame</code> that contains data to be analyzed, for training.</p>
</td></tr>
<tr><td><code id="AutoScore_parsimony_Survival_+3A_validation_set">validation_set</code></td>
<td>
<p>A processed <code>data.frame</code> that contains data for validation purpose.</p>
</td></tr>
<tr><td><code id="AutoScore_parsimony_Survival_+3A_rank">rank</code></td>
<td>
<p>the raking result generated from AutoScore STEP(i) for survival
outcomes (<code><a href="#topic+AutoScore_rank_Survival">AutoScore_rank_Survival</a></code>).</p>
</td></tr>
<tr><td><code id="AutoScore_parsimony_Survival_+3A_max_score">max_score</code></td>
<td>
<p>Maximum total score (Default: 100).</p>
</td></tr>
<tr><td><code id="AutoScore_parsimony_Survival_+3A_n_min">n_min</code></td>
<td>
<p>Minimum number of selected variables (Default: 1).</p>
</td></tr>
<tr><td><code id="AutoScore_parsimony_Survival_+3A_n_max">n_max</code></td>
<td>
<p>Maximum number of selected variables (Default: 20).</p>
</td></tr>
<tr><td><code id="AutoScore_parsimony_Survival_+3A_cross_validation">cross_validation</code></td>
<td>
<p>If set to <code>TRUE</code>, cross-validation would be used for generating parsimony plot, which is
suitable for small-size data. Default to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="AutoScore_parsimony_Survival_+3A_fold">fold</code></td>
<td>
<p>The number of folds used in cross validation (Default: 10). Available if <code>cross_validation = TRUE</code>.</p>
</td></tr>
<tr><td><code id="AutoScore_parsimony_Survival_+3A_categorize">categorize</code></td>
<td>
<p>Methods for categorize continuous variables. Options include &quot;quantile&quot; or &quot;kmeans&quot; (Default: &quot;quantile&quot;).</p>
</td></tr>
<tr><td><code id="AutoScore_parsimony_Survival_+3A_quantiles">quantiles</code></td>
<td>
<p>Predefined quantiles to convert continuous variables to categorical ones. (Default: c(0, 0.05, 0.2, 0.8, 0.95, 1)) Available if <code>categorize = "quantile"</code>.</p>
</td></tr>
<tr><td><code id="AutoScore_parsimony_Survival_+3A_max_cluster">max_cluster</code></td>
<td>
<p>The max number of cluster (Default: 5). Available if <code>categorize = "kmeans"</code>.</p>
</td></tr>
<tr><td><code id="AutoScore_parsimony_Survival_+3A_do_trace">do_trace</code></td>
<td>
<p>If set to TRUE, all results based on each fold of cross-validation would be printed out and plotted (Default: FALSE). Available if <code>cross_validation = TRUE</code>.</p>
</td></tr>
<tr><td><code id="AutoScore_parsimony_Survival_+3A_auc_lim_min">auc_lim_min</code></td>
<td>
<p>Min y_axis limit in the parsimony plot (Default: 0.5).</p>
</td></tr>
<tr><td><code id="AutoScore_parsimony_Survival_+3A_auc_lim_max">auc_lim_max</code></td>
<td>
<p>Max y_axis limit in the parsimony plot (Default: &quot;adaptive&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the second step of the general AutoScore-Survival workflow for
ordinal outcomes, to generate the parsimony plot to help select a
parsimonious model. In this step, it goes through AutoScore-Survival Module 2,3 and
4 multiple times and to evaluate the performance under different variable
list. The generated parsimony plot would give researcher an intuitive
figure to choose the best models. If data size is small (eg, &lt;5000), an
independent validation set may not be a wise choice. Then, we suggest using
cross-validation to maximize the utility of data. Set
<code>cross_validation=TRUE</code>.
</p>


<h3>Value</h3>

<p>List of iAUC (ie, the integrated AUC by integral under a time-dependent AUC curve
for different number of variables
</p>


<h3>References</h3>


<ul>
<li><p>Xie F, Ning Y, Yuan H, et al. AutoScore-Survival: Developing
interpretable machine learning-based time-to-event scores with right-censored
survival data. J Biomed Inform. 2022;125:103959. doi:10.1016/j.jbi.2021.103959
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+AutoScore_rank_Survival">AutoScore_rank_Survival</a></code>,
<code><a href="#topic+AutoScore_weighting_Survival">AutoScore_weighting_Survival</a></code>,
<code><a href="#topic+AutoScore_fine_tuning_Survival">AutoScore_fine_tuning_Survival</a></code>,
<code><a href="#topic+AutoScore_testing_Survival">AutoScore_testing_Survival</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# see AutoScore-Survival Guidebook for the whole 5-step workflow
data("sample_data_survival")
out_split &lt;- split_data(data = sample_data_survival, ratio = c(0.7, 0.1, 0.2))
train_set &lt;- out_split$train_set
validation_set &lt;- out_split$validation_set
ranking &lt;- AutoScore_rank_Survival(train_set, ntree=10)
iAUC &lt;- AutoScore_parsimony_Survival(
  train_set = train_set, validation_set = validation_set,
  rank = ranking, max_score = 100, n_min = 1, n_max = 20,
  categorize = "quantile", quantiles = c(0, 0.05, 0.2, 0.8, 0.95, 1)
)

## End(Not run)
</code></pre>

<hr>
<h2 id='AutoScore_rank'>AutoScore STEP(i): Rank variables with machine learning (AutoScore Module 1)</h2><span id='topic+AutoScore_rank'></span>

<h3>Description</h3>

<p>AutoScore STEP(i): Rank variables with machine learning (AutoScore Module 1)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AutoScore_rank(train_set, validation_set = NULL, method = "rf", ntree = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AutoScore_rank_+3A_train_set">train_set</code></td>
<td>
<p>A processed <code>data.frame</code> that contains data to be analyzed, for training.</p>
</td></tr>
<tr><td><code id="AutoScore_rank_+3A_validation_set">validation_set</code></td>
<td>
<p>A processed <code>data.frame</code> that contains data to be analyzed, only for auc-based ranking.</p>
</td></tr>
<tr><td><code id="AutoScore_rank_+3A_method">method</code></td>
<td>
<p>method for ranking. Options: 1. 'rf' - random forest (default), 2. 'auc' - auc-based (required validation set). For &quot;auc&quot;, univariate models will be built based on the train set, and the variable ranking is constructed via the AUC performance of corresponding univariate models on the validation set ('validation_set').</p>
</td></tr>
<tr><td><code id="AutoScore_rank_+3A_ntree">ntree</code></td>
<td>
<p>Number of trees in the random forest (Default: 100).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first step in the AutoScore framework is variable ranking. We use random forest (RF),
an ensemble machine learning algorithm, to identify the top-ranking predictors for subsequent score generation.
This step correspond to Module 1 in the AutoScore paper.
</p>


<h3>Value</h3>

<p>Returns a vector containing the list of variables and its ranking generated by machine learning (random forest)
</p>


<h3>References</h3>


<ul>
<li><p>Breiman, L. (2001), Random Forests, Machine Learning 45(1), 5-32
</p>
</li>
<li><p>Xie F, Chakraborty B, Ong MEH, Goldstein BA, Liu N. AutoScore: A Machine Learning-Based Automatic Clinical Score Generator and
Its Application to Mortality Prediction Using Electronic Health Records. JMIR Medical Informatics 2020;8(10):e21798
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+AutoScore_parsimony">AutoScore_parsimony</a></code>, <code><a href="#topic+AutoScore_weighting">AutoScore_weighting</a></code>, <code><a href="#topic+AutoScore_fine_tuning">AutoScore_fine_tuning</a></code>, <code><a href="#topic+AutoScore_testing">AutoScore_testing</a></code>, Run <code>vignette("Guide_book", package = "AutoScore")</code> to see the guidebook or vignette.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see AutoScore Guidebook for the whole 5-step workflow
data("sample_data")
names(sample_data)[names(sample_data) == "Mortality_inpatient"] &lt;- "label"
ranking &lt;- AutoScore_rank(sample_data, ntree = 50)
</code></pre>

<hr>
<h2 id='AutoScore_rank_Ordinal'>AutoScore STEP (i) for ordinal outcomes: Generate variable ranking
list by machine learning (AutoScore Module 1)</h2><span id='topic+AutoScore_rank_Ordinal'></span>

<h3>Description</h3>

<p>AutoScore STEP (i) for ordinal outcomes: Generate variable ranking
list by machine learning (AutoScore Module 1)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AutoScore_rank_Ordinal(train_set, ntree = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AutoScore_rank_Ordinal_+3A_train_set">train_set</code></td>
<td>
<p>A processed <code>data.frame</code> that contains data to be analyzed, for training.</p>
</td></tr>
<tr><td><code id="AutoScore_rank_Ordinal_+3A_ntree">ntree</code></td>
<td>
<p>Number of trees in the random forest (Default: 100).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first step in the AutoScore framework is variable ranking. We
use random forest (RF) for multiclass classification to identify the
top-ranking predictors for subsequent score generation. This step
corresponds to Module 1 in the AutoScore-Ordinal paper.
</p>


<h3>Value</h3>

<p>Returns a vector containing the list of variables and its ranking generated by machine learning (random forest)
</p>


<h3>References</h3>


<ul>
<li><p>Breiman, L. (2001), Random Forests, Machine Learning 45(1), 5-32
</p>
</li>
<li><p>Saffari SE, Ning Y, Feng X, Chakraborty B, Volovici V, Vaughan R, Ong
ME, Liu N, AutoScore-Ordinal: An interpretable machine learning framework for
generating scoring models for ordinal outcomes, arXiv:2202.08407
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+AutoScore_parsimony_Ordinal">AutoScore_parsimony_Ordinal</a></code>,
<code><a href="#topic+AutoScore_weighting_Ordinal">AutoScore_weighting_Ordinal</a></code>,
<code><a href="#topic+AutoScore_fine_tuning_Ordinal">AutoScore_fine_tuning_Ordinal</a></code>,
<code><a href="#topic+AutoScore_testing_Ordinal">AutoScore_testing_Ordinal</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# see AutoScore-Ordinal Guidebook for the whole 5-step workflow
data("sample_data_ordinal") # Output is named `label`
ranking &lt;- AutoScore_rank_ordinal(sample_data_ordinal, ntree = 50)

## End(Not run)
</code></pre>

<hr>
<h2 id='AutoScore_rank_Survival'>AutoScore STEP (1) for survival outcomes: Generate variable ranking
List by machine learning (Random Survival Forest) (AutoScore Module 1)</h2><span id='topic+AutoScore_rank_Survival'></span>

<h3>Description</h3>

<p>AutoScore STEP (1) for survival outcomes: Generate variable ranking
List by machine learning (Random Survival Forest) (AutoScore Module 1)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AutoScore_rank_Survival(train_set, ntree = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AutoScore_rank_Survival_+3A_train_set">train_set</code></td>
<td>
<p>A processed <code>data.frame</code> that contains data to be analyzed, for training.</p>
</td></tr>
<tr><td><code id="AutoScore_rank_Survival_+3A_ntree">ntree</code></td>
<td>
<p>Number of trees in the random forest (Default: 100).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first step in the AutoScore framework is variable ranking. We
use Random Survival Forest (RSF) for survival outcome to identify the
top-ranking predictors for subsequent score generation. This step
correspond to Module 1 in the AutoScore-Survival paper.
</p>


<h3>Value</h3>

<p>Returns a vector containing the list of variables and its ranking generated by machine learning (random forest)
</p>


<h3>References</h3>


<ul>
<li><p>Ishwaran, H., Kogalur, U. B., Blackstone, E. H., &amp; Lauer, M. S. (2008).
Random survival forests. The annals of applied statistics, 2(3), 841-860.
</p>
</li>
<li><p>Xie F, Ning Y, Yuan H, et al. AutoScore-Survival: Developing
interpretable machine learning-based time-to-event scores with right-censored
survival data. J Biomed Inform. 2022;125:103959. doi:10.1016/j.jbi.2021.103959
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+AutoScore_parsimony_Survival">AutoScore_parsimony_Survival</a></code>,
<code><a href="#topic+AutoScore_weighting_Survival">AutoScore_weighting_Survival</a></code>,
<code><a href="#topic+AutoScore_fine_tuning_Survival">AutoScore_fine_tuning_Survival</a></code>,
<code><a href="#topic+AutoScore_testing_Survival">AutoScore_testing_Survival</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# see AutoScore-Survival Guidebook for the whole 5-step workflow
data("sample_data_survival") # Output is named `label_time` and `label_status`
ranking &lt;- AutoScore_rank_Survival(sample_data_survival, ntree = 50)

## End(Not run)
</code></pre>

<hr>
<h2 id='AutoScore_testing'>AutoScore STEP(v): Evaluate the final score with ROC analysis (AutoScore Module 6)</h2><span id='topic+AutoScore_testing'></span>

<h3>Description</h3>

<p>AutoScore STEP(v): Evaluate the final score with ROC analysis (AutoScore Module 6)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AutoScore_testing(
  test_set,
  final_variables,
  cut_vec,
  scoring_table,
  threshold = "best",
  with_label = TRUE,
  metrics_ci = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AutoScore_testing_+3A_test_set">test_set</code></td>
<td>
<p>A processed <code>data.frame</code> that contains data for testing purpose. This <code>data.frame</code> should have same format as
<code>train_set</code> (same variable names and outcomes)</p>
</td></tr>
<tr><td><code id="AutoScore_testing_+3A_final_variables">final_variables</code></td>
<td>
<p>A vector containing the list of selected variables, selected from Step(ii) <code><a href="#topic+AutoScore_parsimony">AutoScore_parsimony</a></code>. Run <code>vignette("Guide_book", package = "AutoScore")</code> to see the guidebook or vignette.</p>
</td></tr>
<tr><td><code id="AutoScore_testing_+3A_cut_vec">cut_vec</code></td>
<td>
<p>Generated from STEP(iii) <code><a href="#topic+AutoScore_weighting">AutoScore_weighting</a></code>.Please follow the guidebook</p>
</td></tr>
<tr><td><code id="AutoScore_testing_+3A_scoring_table">scoring_table</code></td>
<td>
<p>The final scoring table after fine-tuning, generated from STEP(iv) <code><a href="#topic+AutoScore_fine_tuning">AutoScore_fine_tuning</a></code>.Please follow the guidebook</p>
</td></tr>
<tr><td><code id="AutoScore_testing_+3A_threshold">threshold</code></td>
<td>
<p>Score threshold for the ROC analysis to generate sensitivity, specificity, etc. If set to &quot;best&quot;, the optimal threshold will be calculated (Default:&quot;best&quot;).</p>
</td></tr>
<tr><td><code id="AutoScore_testing_+3A_with_label">with_label</code></td>
<td>
<p>Set to TRUE if there are labels in the test_set and performance will be evaluated accordingly (Default:TRUE).
Set it to &quot;FALSE&quot; if there are not &quot;label&quot; in the &quot;test_set&quot; and the final predicted scores will be the output without performance evaluation.</p>
</td></tr>
<tr><td><code id="AutoScore_testing_+3A_metrics_ci">metrics_ci</code></td>
<td>
<p>whether to calculate confidence interval for the metrics of sensitivity, specificity, etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with predicted score and the outcome for downstream visualization.
</p>


<h3>References</h3>


<ul>
<li><p>Xie F, Chakraborty B, Ong MEH, Goldstein BA, Liu N. AutoScore: A Machine Learning-Based Automatic Clinical Score Generator and
Its Application to Mortality Prediction Using Electronic Health Records. JMIR Medical Informatics 2020;8(10):e21798
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+AutoScore_rank">AutoScore_rank</a></code>, <code><a href="#topic+AutoScore_parsimony">AutoScore_parsimony</a></code>, <code><a href="#topic+AutoScore_weighting">AutoScore_weighting</a></code>, <code><a href="#topic+AutoScore_fine_tuning">AutoScore_fine_tuning</a></code>, <code><a href="#topic+print_roc_performance">print_roc_performance</a></code>, Run <code>vignette("Guide_book", package = "AutoScore")</code> to see the guidebook or vignette.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Please see the guidebook or vignettes
</code></pre>

<hr>
<h2 id='AutoScore_testing_Ordinal'>AutoScore STEP(v) for ordinal outcomes: Evaluate the final score
(AutoScore Module 6)</h2><span id='topic+AutoScore_testing_Ordinal'></span>

<h3>Description</h3>

<p>AutoScore STEP(v) for ordinal outcomes: Evaluate the final score
(AutoScore Module 6)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AutoScore_testing_Ordinal(
  test_set,
  final_variables,
  link = "logit",
  cut_vec,
  scoring_table,
  with_label = TRUE,
  n_boot = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AutoScore_testing_Ordinal_+3A_test_set">test_set</code></td>
<td>
<p>A processed data.frame that contains data for testing
purpose. This data.frame should have same format as train_set (same
variable names and outcomes)</p>
</td></tr>
<tr><td><code id="AutoScore_testing_Ordinal_+3A_final_variables">final_variables</code></td>
<td>
<p>A vector containing the list of selected variables,
selected from Step(ii) <code><a href="#topic+AutoScore_parsimony_Ordinal">AutoScore_parsimony_Ordinal</a></code>.</p>
</td></tr>
<tr><td><code id="AutoScore_testing_Ordinal_+3A_link">link</code></td>
<td>
<p>The link function used to model ordinal outcomes. Default is
<code>"logit"</code> for proportional odds model. Other options are
<code>"cloglog"</code> (proportional hazards model) and <code>"probit"</code>.</p>
</td></tr>
<tr><td><code id="AutoScore_testing_Ordinal_+3A_cut_vec">cut_vec</code></td>
<td>
<p>Generated from STEP(iii) <code><a href="#topic+AutoScore_weighting_Ordinal">AutoScore_weighting_Ordinal</a></code>.</p>
</td></tr>
<tr><td><code id="AutoScore_testing_Ordinal_+3A_scoring_table">scoring_table</code></td>
<td>
<p>The final scoring table after fine-tuning, generated
from STEP(iv) <code><a href="#topic+AutoScore_fine_tuning_Ordinal">AutoScore_fine_tuning_Ordinal</a></code>.Please follow the
guidebook</p>
</td></tr>
<tr><td><code id="AutoScore_testing_Ordinal_+3A_with_label">with_label</code></td>
<td>
<p>Set to TRUE if there are labels in the test_set and
performance will be evaluated accordingly (Default:TRUE).</p>
</td></tr>
<tr><td><code id="AutoScore_testing_Ordinal_+3A_n_boot">n_boot</code></td>
<td>
<p>Number of bootstrap cycles to compute 95% CI for performance
metrics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with predicted score and the outcome for downstream visualization.
</p>


<h3>References</h3>


<ul>
<li><p>Saffari SE, Ning Y, Feng X, Chakraborty B, Volovici V, Vaughan R, Ong
ME, Liu N, AutoScore-Ordinal: An interpretable machine learning framework for
generating scoring models for ordinal outcomes, arXiv:2202.08407
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+AutoScore_rank_Ordinal">AutoScore_rank_Ordinal</a></code>,
<code><a href="#topic+AutoScore_parsimony_Ordinal">AutoScore_parsimony_Ordinal</a></code>,
<code><a href="#topic+AutoScore_weighting_Ordinal">AutoScore_weighting_Ordinal</a></code>,
<code><a href="#topic+AutoScore_fine_tuning_Ordinal">AutoScore_fine_tuning_Ordinal</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Please see the guidebook or vignettes
</code></pre>

<hr>
<h2 id='AutoScore_testing_Survival'>AutoScore STEP(v) for survival outcomes: Evaluate the final score with
ROC analysis (AutoScore Module 6)</h2><span id='topic+AutoScore_testing_Survival'></span>

<h3>Description</h3>

<p>AutoScore STEP(v) for survival outcomes: Evaluate the final score with
ROC analysis (AutoScore Module 6)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AutoScore_testing_Survival(
  test_set,
  final_variables,
  cut_vec,
  scoring_table,
  threshold = "best",
  with_label = TRUE,
  time_point = c(1, 3, 7, 14, 30, 60, 90)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AutoScore_testing_Survival_+3A_test_set">test_set</code></td>
<td>
<p>A processed <code>data.frame</code> that contains data for testing purpose. This <code>data.frame</code> should have same format as
<code>train_set</code> (same variable names and outcomes)</p>
</td></tr>
<tr><td><code id="AutoScore_testing_Survival_+3A_final_variables">final_variables</code></td>
<td>
<p>A vector containing the list of selected variables, selected from Step(ii) <code><a href="#topic+AutoScore_parsimony">AutoScore_parsimony</a></code>. Run <code>vignette("Guide_book", package = "AutoScore")</code> to see the guidebook or vignette.</p>
</td></tr>
<tr><td><code id="AutoScore_testing_Survival_+3A_cut_vec">cut_vec</code></td>
<td>
<p>Generated from STEP(iii)
<code>AutoScore_weighting_Survival()</code>.Please follow the guidebook</p>
</td></tr>
<tr><td><code id="AutoScore_testing_Survival_+3A_scoring_table">scoring_table</code></td>
<td>
<p>The final scoring table after fine-tuning, generated from STEP(iv) <code><a href="#topic+AutoScore_fine_tuning">AutoScore_fine_tuning</a></code>.Please follow the guidebook</p>
</td></tr>
<tr><td><code id="AutoScore_testing_Survival_+3A_threshold">threshold</code></td>
<td>
<p>Score threshold for the ROC analysis to generate sensitivity, specificity, etc. If set to &quot;best&quot;, the optimal threshold will be calculated (Default:&quot;best&quot;).</p>
</td></tr>
<tr><td><code id="AutoScore_testing_Survival_+3A_with_label">with_label</code></td>
<td>
<p>Set to TRUE if there are labels('label_time' and 'label_status') in the test_set and
performance will be evaluated accordingly (Default:TRUE).</p>
</td></tr>
<tr><td><code id="AutoScore_testing_Survival_+3A_time_point">time_point</code></td>
<td>
<p>The time points to be evaluated using time-dependent AUC(t).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with predicted score and the outcome for downstream visualization.
</p>


<h3>References</h3>


<ul>
<li><p>Xie F, Ning Y, Yuan H, et al. AutoScore-Survival: Developing
interpretable machine learning-based time-to-event scores with right-censored
survival data. J Biomed Inform. 2022;125:103959. doi:10.1016/j.jbi.2021.103959
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+AutoScore_rank_Survival">AutoScore_rank_Survival</a></code>,
<code><a href="#topic+AutoScore_parsimony_Survival">AutoScore_parsimony_Survival</a></code>,
<code><a href="#topic+AutoScore_weighting_Survival">AutoScore_weighting_Survival</a></code>,
<code><a href="#topic+AutoScore_fine_tuning_Survival">AutoScore_fine_tuning_Survival</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Please see the guidebook or vignettes
</code></pre>

<hr>
<h2 id='AutoScore_weighting'>AutoScore STEP(iii): Generate the initial score with the final list of variables (Re-run AutoScore Modules 2+3)</h2><span id='topic+AutoScore_weighting'></span>

<h3>Description</h3>

<p>AutoScore STEP(iii): Generate the initial score with the final list of variables (Re-run AutoScore Modules 2+3)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AutoScore_weighting(
  train_set,
  validation_set,
  final_variables,
  max_score = 100,
  categorize = "quantile",
  max_cluster = 5,
  quantiles = c(0, 0.05, 0.2, 0.8, 0.95, 1),
  metrics_ci = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AutoScore_weighting_+3A_train_set">train_set</code></td>
<td>
<p>A processed <code>data.frame</code> that contains data to be analyzed, for training.</p>
</td></tr>
<tr><td><code id="AutoScore_weighting_+3A_validation_set">validation_set</code></td>
<td>
<p>A processed <code>data.frame</code> that contains data for validation purpose.</p>
</td></tr>
<tr><td><code id="AutoScore_weighting_+3A_final_variables">final_variables</code></td>
<td>
<p>A vector containing the list of selected variables, selected from Step(ii)<code><a href="#topic+AutoScore_parsimony">AutoScore_parsimony</a></code>. Run <code>vignette("Guide_book", package = "AutoScore")</code> to see the guidebook or vignette.</p>
</td></tr>
<tr><td><code id="AutoScore_weighting_+3A_max_score">max_score</code></td>
<td>
<p>Maximum total score (Default: 100).</p>
</td></tr>
<tr><td><code id="AutoScore_weighting_+3A_categorize">categorize</code></td>
<td>
<p>Methods for categorize continuous variables. Options include &quot;quantile&quot; or &quot;kmeans&quot; (Default: &quot;quantile&quot;).</p>
</td></tr>
<tr><td><code id="AutoScore_weighting_+3A_max_cluster">max_cluster</code></td>
<td>
<p>The max number of cluster (Default: 5). Available if <code>categorize = "kmeans"</code>.</p>
</td></tr>
<tr><td><code id="AutoScore_weighting_+3A_quantiles">quantiles</code></td>
<td>
<p>Predefined quantiles to convert continuous variables to categorical ones. (Default: c(0, 0.05, 0.2, 0.8, 0.95, 1)) Available if <code>categorize = "quantile"</code>.</p>
</td></tr>
<tr><td><code id="AutoScore_weighting_+3A_metrics_ci">metrics_ci</code></td>
<td>
<p>whether to calculate confidence interval for the metrics of sensitivity, specificity, etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Generated <code>cut_vec</code> for downstream fine-tuning process STEP(iv) <code><a href="#topic+AutoScore_fine_tuning">AutoScore_fine_tuning</a></code>.
</p>


<h3>References</h3>


<ul>
<li><p>Xie F, Chakraborty B, Ong MEH, Goldstein BA, Liu N. AutoScore: A Machine Learning-Based Automatic Clinical Score Generator and
Its Application to Mortality Prediction Using Electronic Health Records. JMIR Medical Informatics 2020;8(10):e21798
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+AutoScore_rank">AutoScore_rank</a></code>, <code><a href="#topic+AutoScore_parsimony">AutoScore_parsimony</a></code>, <code><a href="#topic+AutoScore_fine_tuning">AutoScore_fine_tuning</a></code>, <code><a href="#topic+AutoScore_testing">AutoScore_testing</a></code>, Run <code>vignette("Guide_book", package = "AutoScore")</code> to see the guidebook or vignette.
</p>

<hr>
<h2 id='AutoScore_weighting_Ordinal'>AutoScore STEP(iii) for ordinal outcomes: Generate the initial score
with the final list of variables (Re-run AutoScore Modules 2+3)</h2><span id='topic+AutoScore_weighting_Ordinal'></span>

<h3>Description</h3>

<p>AutoScore STEP(iii) for ordinal outcomes: Generate the initial score
with the final list of variables (Re-run AutoScore Modules 2+3)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AutoScore_weighting_Ordinal(
  train_set,
  validation_set,
  final_variables,
  link = "logit",
  max_score = 100,
  categorize = "quantile",
  quantiles = c(0, 0.05, 0.2, 0.8, 0.95, 1),
  max_cluster = 5,
  n_boot = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AutoScore_weighting_Ordinal_+3A_train_set">train_set</code></td>
<td>
<p>A processed <code>data.frame</code> that contains data to be analyzed, for training.</p>
</td></tr>
<tr><td><code id="AutoScore_weighting_Ordinal_+3A_validation_set">validation_set</code></td>
<td>
<p>A processed <code>data.frame</code> that contains data for validation purpose.</p>
</td></tr>
<tr><td><code id="AutoScore_weighting_Ordinal_+3A_final_variables">final_variables</code></td>
<td>
<p>A vector containing the list of selected variables,
selected from Step(ii) <code><a href="#topic+AutoScore_parsimony_Ordinal">AutoScore_parsimony_Ordinal</a></code>.</p>
</td></tr>
<tr><td><code id="AutoScore_weighting_Ordinal_+3A_link">link</code></td>
<td>
<p>The link function used to model ordinal outcomes. Default is
<code>"logit"</code> for proportional odds model. Other options are
<code>"cloglog"</code> (proportional hazards model) and <code>"probit"</code>.</p>
</td></tr>
<tr><td><code id="AutoScore_weighting_Ordinal_+3A_max_score">max_score</code></td>
<td>
<p>Maximum total score (Default: 100).</p>
</td></tr>
<tr><td><code id="AutoScore_weighting_Ordinal_+3A_categorize">categorize</code></td>
<td>
<p>Methods for categorize continuous variables. Options include &quot;quantile&quot; or &quot;kmeans&quot; (Default: &quot;quantile&quot;).</p>
</td></tr>
<tr><td><code id="AutoScore_weighting_Ordinal_+3A_quantiles">quantiles</code></td>
<td>
<p>Predefined quantiles to convert continuous variables to categorical ones. (Default: c(0, 0.05, 0.2, 0.8, 0.95, 1)) Available if <code>categorize = "quantile"</code>.</p>
</td></tr>
<tr><td><code id="AutoScore_weighting_Ordinal_+3A_max_cluster">max_cluster</code></td>
<td>
<p>The max number of cluster (Default: 5). Available if <code>categorize = "kmeans"</code>.</p>
</td></tr>
<tr><td><code id="AutoScore_weighting_Ordinal_+3A_n_boot">n_boot</code></td>
<td>
<p>Number of bootstrap cycles to compute 95% CI for performance
metrics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Generated <code>cut_vec</code> for downstream fine-tuning process STEP(iv)
<code><a href="#topic+AutoScore_fine_tuning_Ordinal">AutoScore_fine_tuning_Ordinal</a></code>.
</p>


<h3>References</h3>


<ul>
<li><p>Saffari SE, Ning Y, Feng X, Chakraborty B, Volovici V, Vaughan R, Ong
ME, Liu N, AutoScore-Ordinal: An interpretable machine learning framework for
generating scoring models for ordinal outcomes, arXiv:2202.08407
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+AutoScore_rank_Ordinal">AutoScore_rank_Ordinal</a></code>,
<code><a href="#topic+AutoScore_parsimony_Ordinal">AutoScore_parsimony_Ordinal</a></code>,
<code><a href="#topic+AutoScore_fine_tuning_Ordinal">AutoScore_fine_tuning_Ordinal</a></code>,
<code><a href="#topic+AutoScore_testing_Ordinal">AutoScore_testing_Ordinal</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("sample_data_ordinal") # Output is named `label`
out_split &lt;- split_data(data = sample_data_ordinal, ratio = c(0.7, 0.1, 0.2))
train_set &lt;- out_split$train_set
validation_set &lt;- out_split$validation_set
ranking &lt;- AutoScore_rank_Ordinal(train_set, ntree=100)
num_var &lt;- 6
final_variables &lt;- names(ranking[1:num_var])
cut_vec &lt;- AutoScore_weighting_Ordinal(
  train_set = train_set, validation_set = validation_set,
  final_variables = final_variables, max_score = 100,
  categorize = "quantile", quantiles = c(0, 0.05, 0.2, 0.8, 0.95, 1)
)

## End(Not run)
</code></pre>

<hr>
<h2 id='AutoScore_weighting_Survival'>AutoScore STEP(iii) for survival outcomes: Generate the initial score
with the final list of variables (Re-run AutoScore Modules 2+3)</h2><span id='topic+AutoScore_weighting_Survival'></span>

<h3>Description</h3>

<p>AutoScore STEP(iii) for survival outcomes: Generate the initial score
with the final list of variables (Re-run AutoScore Modules 2+3)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AutoScore_weighting_Survival(
  train_set,
  validation_set,
  final_variables,
  max_score = 100,
  categorize = "quantile",
  max_cluster = 5,
  quantiles = c(0, 0.05, 0.2, 0.8, 0.95, 1),
  time_point = c(1, 3, 7, 14, 30, 60, 90)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AutoScore_weighting_Survival_+3A_train_set">train_set</code></td>
<td>
<p>A processed <code>data.frame</code> that contains data to be analyzed, for training.</p>
</td></tr>
<tr><td><code id="AutoScore_weighting_Survival_+3A_validation_set">validation_set</code></td>
<td>
<p>A processed <code>data.frame</code> that contains data for validation purpose.</p>
</td></tr>
<tr><td><code id="AutoScore_weighting_Survival_+3A_final_variables">final_variables</code></td>
<td>
<p>A vector containing the list of selected variables, selected from Step(ii)<code><a href="#topic+AutoScore_parsimony">AutoScore_parsimony</a></code>. Run <code>vignette("Guide_book", package = "AutoScore")</code> to see the guidebook or vignette.</p>
</td></tr>
<tr><td><code id="AutoScore_weighting_Survival_+3A_max_score">max_score</code></td>
<td>
<p>Maximum total score (Default: 100).</p>
</td></tr>
<tr><td><code id="AutoScore_weighting_Survival_+3A_categorize">categorize</code></td>
<td>
<p>Methods for categorize continuous variables. Options include &quot;quantile&quot; or &quot;kmeans&quot; (Default: &quot;quantile&quot;).</p>
</td></tr>
<tr><td><code id="AutoScore_weighting_Survival_+3A_max_cluster">max_cluster</code></td>
<td>
<p>The max number of cluster (Default: 5). Available if <code>categorize = "kmeans"</code>.</p>
</td></tr>
<tr><td><code id="AutoScore_weighting_Survival_+3A_quantiles">quantiles</code></td>
<td>
<p>Predefined quantiles to convert continuous variables to categorical ones. (Default: c(0, 0.05, 0.2, 0.8, 0.95, 1)) Available if <code>categorize = "quantile"</code>.</p>
</td></tr>
<tr><td><code id="AutoScore_weighting_Survival_+3A_time_point">time_point</code></td>
<td>
<p>The time points to be evaluated using time-dependent AUC(t).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Generated <code>cut_vec</code> for downstream fine-tuning process STEP(iv) <code><a href="#topic+AutoScore_fine_tuning">AutoScore_fine_tuning</a></code>.
</p>


<h3>References</h3>


<ul>
<li><p>Xie F, Ning Y, Yuan H, et al. AutoScore-Survival: Developing
interpretable machine learning-based time-to-event scores with right-censored
survival data. J Biomed Inform. 2022;125:103959. doi:10.1016/j.jbi.2021.103959
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+AutoScore_rank_Survival">AutoScore_rank_Survival</a></code>,
<code><a href="#topic+AutoScore_parsimony_Survival">AutoScore_parsimony_Survival</a></code>,
<code><a href="#topic+AutoScore_fine_tuning_Survival">AutoScore_fine_tuning_Survival</a></code>,
<code><a href="#topic+AutoScore_testing_Survival">AutoScore_testing_Survival</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("sample_data_survival") #
out_split &lt;- split_data(data = sample_data_survival, ratio = c(0.7, 0.1, 0.2))
train_set &lt;- out_split$train_set
validation_set &lt;- out_split$validation_set
ranking &lt;- AutoScore_rank_Survival(train_set, ntree=5)
num_var &lt;- 6
final_variables &lt;- names(ranking[1:num_var])
cut_vec &lt;- AutoScore_weighting_Survival(
  train_set = train_set, validation_set = validation_set,
  final_variables = final_variables, max_score = 100,
  categorize = "quantile", quantiles = c(0, 0.05, 0.2, 0.8, 0.95, 1),
  time_point = c(1,3,7,14,30,60,90)
)

## End(Not run)
</code></pre>

<hr>
<h2 id='change_reference'>Internal Function: Change Reference category after first-step logistic regression (part of AutoScore Module 3)</h2><span id='topic+change_reference'></span>

<h3>Description</h3>

<p>Internal Function: Change Reference category after first-step logistic regression (part of AutoScore Module 3)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>change_reference(df, coef_vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="change_reference_+3A_df">df</code></td>
<td>
<p>A <code>data.frame</code> used for logistic regression</p>
</td></tr>
<tr><td><code id="change_reference_+3A_coef_vec">coef_vec</code></td>
<td>
<p>Generated from logistic regression</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Processed <code>data.frame</code> after changing reference category
</p>

<hr>
<h2 id='check_data'>AutoScore function for datasets with binary outcomes: Check whether the input dataset fulfill the requirement of the AutoScore</h2><span id='topic+check_data'></span>

<h3>Description</h3>

<p>AutoScore function for datasets with binary outcomes: Check whether the input dataset fulfill the requirement of the AutoScore
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_data(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_data_+3A_data">data</code></td>
<td>
<p>The data to be checked</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, the result of the checking will be printed out.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sample_data")
names(sample_data)[names(sample_data) == "Mortality_inpatient"] &lt;- "label"
check_data(sample_data)
</code></pre>

<hr>
<h2 id='check_data_ordinal'>AutoScore function for ordinal outcomes: Check whether the input
dataset fulfil the requirement of the AutoScore</h2><span id='topic+check_data_ordinal'></span>

<h3>Description</h3>

<p>AutoScore function for ordinal outcomes: Check whether the input
dataset fulfil the requirement of the AutoScore
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_data_ordinal(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_data_ordinal_+3A_data">data</code></td>
<td>
<p>The data to be checked</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, the result of the checking will be printed out.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sample_data_ordinal")
check_data_ordinal(sample_data_ordinal)
</code></pre>

<hr>
<h2 id='check_data_survival'>AutoScore function for survival data: Check whether the input
dataset fulfill the requirement of the AutoScore</h2><span id='topic+check_data_survival'></span>

<h3>Description</h3>

<p>AutoScore function for survival data: Check whether the input
dataset fulfill the requirement of the AutoScore
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_data_survival(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_data_survival_+3A_data">data</code></td>
<td>
<p>The data to be checked</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, the result of the checking will be printed out.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sample_data_survival")
check_data_survival(sample_data_survival)
</code></pre>

<hr>
<h2 id='check_link'>Internal function: Check link function</h2><span id='topic+check_link'></span>

<h3>Description</h3>

<p>Internal function: Check link function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_link(link)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_link_+3A_link">link</code></td>
<td>
<p>The link function used to model ordinal outcomes. Default is
<code>"logit"</code> for proportional odds model. Other options are
<code>"cloglog"</code> (proportional hazards model) and <code>"probit"</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='check_predictor'>Internal function: Check predictors</h2><span id='topic+check_predictor'></span>

<h3>Description</h3>

<p>Internal function: Check predictors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_predictor(data_predictor)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_predictor_+3A_data_predictor">data_predictor</code></td>
<td>
<p>Predictors to be checked</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, the result of the checking will be printed out.
</p>

<hr>
<h2 id='compute_auc_val'>Internal function: Compute AUC based on validation set for plotting parsimony (AutoScore Module 4)</h2><span id='topic+compute_auc_val'></span>

<h3>Description</h3>

<p>Compute AUC based on validation set for plotting parsimony
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_auc_val(
  train_set_1,
  validation_set_1,
  variable_list,
  categorize,
  quantiles,
  max_cluster,
  max_score
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_auc_val_+3A_train_set_1">train_set_1</code></td>
<td>
<p>Processed training set</p>
</td></tr>
<tr><td><code id="compute_auc_val_+3A_validation_set_1">validation_set_1</code></td>
<td>
<p>Processed validation set</p>
</td></tr>
<tr><td><code id="compute_auc_val_+3A_variable_list">variable_list</code></td>
<td>
<p>List of included variables</p>
</td></tr>
<tr><td><code id="compute_auc_val_+3A_categorize">categorize</code></td>
<td>
<p>Methods for categorize continuous variables. Options include &quot;quantile&quot; or &quot;kmeans&quot;</p>
</td></tr>
<tr><td><code id="compute_auc_val_+3A_quantiles">quantiles</code></td>
<td>
<p>Predefined quantiles to convert continuous variables to categorical ones. Available if <code>categorize = "quantile"</code>.</p>
</td></tr>
<tr><td><code id="compute_auc_val_+3A_max_cluster">max_cluster</code></td>
<td>
<p>The max number of cluster (Default: 5). Available if <code>categorize = "kmeans"</code>.</p>
</td></tr>
<tr><td><code id="compute_auc_val_+3A_max_score">max_score</code></td>
<td>
<p>Maximum total score</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A List of AUC for parsimony plot
</p>

<hr>
<h2 id='compute_auc_val_ord'>Internal function: Compute mean AUC for ordinal outcomes based on
validation set for plotting parsimony</h2><span id='topic+compute_auc_val_ord'></span>

<h3>Description</h3>

<p>Compute mean AUC based on validation set for plotting parsimony
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_auc_val_ord(
  train_set_1,
  validation_set_1,
  variable_list,
  link,
  categorize,
  quantiles,
  max_cluster,
  max_score
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_auc_val_ord_+3A_train_set_1">train_set_1</code></td>
<td>
<p>Processed training set</p>
</td></tr>
<tr><td><code id="compute_auc_val_ord_+3A_validation_set_1">validation_set_1</code></td>
<td>
<p>Processed validation set</p>
</td></tr>
<tr><td><code id="compute_auc_val_ord_+3A_variable_list">variable_list</code></td>
<td>
<p>List of included variables</p>
</td></tr>
<tr><td><code id="compute_auc_val_ord_+3A_link">link</code></td>
<td>
<p>The link function used to model ordinal outcomes. Default is
<code>"logit"</code> for proportional odds model. Other options are
<code>"cloglog"</code> (proportional hazards model) and <code>"probit"</code>.</p>
</td></tr>
<tr><td><code id="compute_auc_val_ord_+3A_categorize">categorize</code></td>
<td>
<p>Methods for categorize continuous variables. Options include &quot;quantile&quot; or &quot;kmeans&quot;</p>
</td></tr>
<tr><td><code id="compute_auc_val_ord_+3A_quantiles">quantiles</code></td>
<td>
<p>Predefined quantiles to convert continuous variables to categorical ones. Available if <code>categorize = "quantile"</code>.</p>
</td></tr>
<tr><td><code id="compute_auc_val_ord_+3A_max_cluster">max_cluster</code></td>
<td>
<p>The max number of cluster (Default: 5). Available if <code>categorize = "kmeans"</code>.</p>
</td></tr>
<tr><td><code id="compute_auc_val_ord_+3A_max_score">max_score</code></td>
<td>
<p>Maximum total score</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of mAUC for parsimony plot
</p>

<hr>
<h2 id='compute_auc_val_survival'>Internal function for survival outcomes: Compute AUC based on validation set for plotting parsimony</h2><span id='topic+compute_auc_val_survival'></span>

<h3>Description</h3>

<p>Compute AUC based on validation set for plotting parsimony (survival outcomes)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_auc_val_survival(
  train_set_1,
  validation_set_1,
  variable_list,
  categorize,
  quantiles,
  max_cluster,
  max_score
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_auc_val_survival_+3A_train_set_1">train_set_1</code></td>
<td>
<p>Processed training set</p>
</td></tr>
<tr><td><code id="compute_auc_val_survival_+3A_validation_set_1">validation_set_1</code></td>
<td>
<p>Processed validation set</p>
</td></tr>
<tr><td><code id="compute_auc_val_survival_+3A_variable_list">variable_list</code></td>
<td>
<p>List of included variables</p>
</td></tr>
<tr><td><code id="compute_auc_val_survival_+3A_categorize">categorize</code></td>
<td>
<p>Methods for categorize continuous variables. Options include &quot;quantile&quot; or &quot;kmeans&quot;</p>
</td></tr>
<tr><td><code id="compute_auc_val_survival_+3A_quantiles">quantiles</code></td>
<td>
<p>Predefined quantiles to convert continuous variables to categorical ones. Available if <code>categorize = "quantile"</code>.</p>
</td></tr>
<tr><td><code id="compute_auc_val_survival_+3A_max_cluster">max_cluster</code></td>
<td>
<p>The max number of cluster (Default: 5). Available if <code>categorize = "kmeans"</code>.</p>
</td></tr>
<tr><td><code id="compute_auc_val_survival_+3A_max_score">max_score</code></td>
<td>
<p>Maximum total score</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A List of AUC for parsimony plot
</p>

<hr>
<h2 id='compute_descriptive_table'>AutoScore function: Descriptive Analysis</h2><span id='topic+compute_descriptive_table'></span>

<h3>Description</h3>

<p>Compute descriptive table (usually Table 1 in the medical
literature) for the dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_descriptive_table(df, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_descriptive_table_+3A_df">df</code></td>
<td>
<p>data frame after checking and fulfilling the requirement of AutoScore</p>
</td></tr>
<tr><td><code id="compute_descriptive_table_+3A_...">...</code></td>
<td>
<p>additional parameters to pass to
<code><a href="tableone.html#topic+print.TableOne">print.TableOne</a></code> and <code><a href="knitr.html#topic+kable">kable</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value and the result of the descriptive analysis will be printed out.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sample_data")
names(sample_data)[names(sample_data) == "Mortality_inpatient"] &lt;- "label"
compute_descriptive_table(sample_data)
# Report median and IQR (instead of default mean and SD) for Age, and add a
# caption to printed table:
compute_descriptive_table(sample_data, nonnormal = "Age",
                          caption = "Table 1. Patient characteristics")
</code></pre>

<hr>
<h2 id='compute_final_score_ord'>Internal function: Compute risk scores for ordinal data given variables
selected, cut-off values and scoring table</h2><span id='topic+compute_final_score_ord'></span>

<h3>Description</h3>

<p>Internal function: Compute risk scores for ordinal data given variables
selected, cut-off values and scoring table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_final_score_ord(data, final_variables, cut_vec, scoring_table)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_final_score_ord_+3A_data">data</code></td>
<td>
<p>A processed <code>data.frame</code> that contains data for validation
or testing purpose. This <code>data.frame</code> must have variable <code>label</code>
and should have same format as <code>train_set</code> (same variable names and
outcomes)</p>
</td></tr>
<tr><td><code id="compute_final_score_ord_+3A_final_variables">final_variables</code></td>
<td>
<p>A vector containing the list of selected variables,
selected from Step(ii) <code><a href="#topic+AutoScore_parsimony_Ordinal">AutoScore_parsimony_Ordinal</a></code>.</p>
</td></tr>
<tr><td><code id="compute_final_score_ord_+3A_cut_vec">cut_vec</code></td>
<td>
<p>Generated from STEP(iii) <code><a href="#topic+AutoScore_weighting_Ordinal">AutoScore_weighting_Ordinal</a></code>.</p>
</td></tr>
<tr><td><code id="compute_final_score_ord_+3A_scoring_table">scoring_table</code></td>
<td>
<p>The final scoring table after fine-tuning, generated
from STEP(iv) <code><a href="#topic+AutoScore_fine_tuning_Ordinal">AutoScore_fine_tuning_Ordinal</a></code>.Please follow the
guidebook</p>
</td></tr>
</table>

<hr>
<h2 id='compute_mauc_ord'>Internal function: Compute mAUC for ordinal predictions</h2><span id='topic+compute_mauc_ord'></span>

<h3>Description</h3>

<p>Internal function: Compute mAUC for ordinal predictions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_mauc_ord(y, fx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_mauc_ord_+3A_y">y</code></td>
<td>
<p>An ordered factor representing the ordinal outcome, with length n
and J categories.</p>
</td></tr>
<tr><td><code id="compute_mauc_ord_+3A_fx">fx</code></td>
<td>
<p>Either (i) a numeric vector of predictor (e.g., predicted scores)
of length n or (ii) a numeric matrix of predicted cumulative probabilities
with n rows and (J-1) columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The mean AUC of J-1 cumulative AUCs (i.e., when evaluating
the prediction of Y&lt;=j, j=1,...,J-1).
</p>

<hr>
<h2 id='compute_multi_variable_table'>AutoScore function: Multivariate Analysis</h2><span id='topic+compute_multi_variable_table'></span>

<h3>Description</h3>

<p>Generate tables for multivariate analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_multi_variable_table(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_multi_variable_table_+3A_df">df</code></td>
<td>
<p>data frame after checking</p>
</td></tr>
</table>


<h3>Value</h3>

<p>result of the multivariate analysis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sample_data")
names(sample_data)[names(sample_data) == "Mortality_inpatient"] &lt;- "label"
multi_table&lt;-compute_multi_variable_table(sample_data)
</code></pre>

<hr>
<h2 id='compute_multi_variable_table_ordinal'>AutoScore-Ordinal function: Multivariate Analysis</h2><span id='topic+compute_multi_variable_table_ordinal'></span>

<h3>Description</h3>

<p>Generate tables for multivariate analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_multi_variable_table_ordinal(df, link = "logit", n_digits = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_multi_variable_table_ordinal_+3A_df">df</code></td>
<td>
<p>data frame after checking</p>
</td></tr>
<tr><td><code id="compute_multi_variable_table_ordinal_+3A_link">link</code></td>
<td>
<p>The link function used to model ordinal outcomes. Default is
<code>"logit"</code> for proportional odds model. Other options are
<code>"cloglog"</code> (proportional hazards model) and <code>"probit"</code>.</p>
</td></tr>
<tr><td><code id="compute_multi_variable_table_ordinal_+3A_n_digits">n_digits</code></td>
<td>
<p>Number of digits to print for OR or exponentiated
coefficients (Default:3).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>result of the multivariate analysis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sample_data_ordinal")
# Using just a few variables to demonstrate usage:
multi_table&lt;-compute_multi_variable_table_ordinal(sample_data_ordinal[, 1:3])
</code></pre>

<hr>
<h2 id='compute_multi_variable_table_survival'>AutoScore function for survival outcomes: Multivariate Analysis</h2><span id='topic+compute_multi_variable_table_survival'></span>

<h3>Description</h3>

<p>Generate tables for multivariate analysis for survival outcomes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_multi_variable_table_survival(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_multi_variable_table_survival_+3A_df">df</code></td>
<td>
<p>data frame after checking</p>
</td></tr>
</table>


<h3>Value</h3>

<p>result of the multivariate analysis for survival outcomes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sample_data_survival")
multi_table&lt;-compute_multi_variable_table_survival(sample_data_survival)
</code></pre>

<hr>
<h2 id='compute_prob_observed'>Internal function: Based on given labels and scores, compute proportion of
subjects observed in each outcome category in given score intervals.</h2><span id='topic+compute_prob_observed'></span>

<h3>Description</h3>

<p>Internal function: Based on given labels and scores, compute proportion of
subjects observed in each outcome category in given score intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_prob_observed(
  pred_score,
  link = "logit",
  max_score = 100,
  score_breaks = seq(from = 5, to = 70, by = 5)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_prob_observed_+3A_pred_score">pred_score</code></td>
<td>
<p>A <code>data.frame</code> with outcomes and final scores
generated from <code><a href="#topic+AutoScore_fine_tuning_Ordinal">AutoScore_fine_tuning_Ordinal</a></code></p>
</td></tr>
<tr><td><code id="compute_prob_observed_+3A_link">link</code></td>
<td>
<p>The link function used to model ordinal outcomes. Default is
<code>"logit"</code> for proportional odds model. Other options are
<code>"cloglog"</code> (proportional hazards model) and <code>"probit"</code>.</p>
</td></tr>
<tr><td><code id="compute_prob_observed_+3A_max_score">max_score</code></td>
<td>
<p>Maximum attainable value of final scores.</p>
</td></tr>
<tr><td><code id="compute_prob_observed_+3A_score_breaks">score_breaks</code></td>
<td>
<p>A vector of score breaks to group scores. The average
predicted risk will be reported for each score interval in the lookup
table. Users are advised to first visualise the predicted risk for all
attainable scores to determine <code>scores</code> (see
<code><a href="#topic+plot_predicted_risk">plot_predicted_risk</a></code>)</p>
</td></tr>
</table>

<hr>
<h2 id='compute_prob_predicted'>Internal function: Based on given labels and scores, compute average
predicted risks in given score intervals.</h2><span id='topic+compute_prob_predicted'></span>

<h3>Description</h3>

<p>Internal function: Based on given labels and scores, compute average
predicted risks in given score intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_prob_predicted(
  pred_score,
  link = "logit",
  max_score = 100,
  score_breaks = seq(from = 5, to = 70, by = 5)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_prob_predicted_+3A_pred_score">pred_score</code></td>
<td>
<p>A <code>data.frame</code> with outcomes and final scores
generated from <code><a href="#topic+AutoScore_fine_tuning_Ordinal">AutoScore_fine_tuning_Ordinal</a></code></p>
</td></tr>
<tr><td><code id="compute_prob_predicted_+3A_link">link</code></td>
<td>
<p>The link function used to model ordinal outcomes. Default is
<code>"logit"</code> for proportional odds model. Other options are
<code>"cloglog"</code> (proportional hazards model) and <code>"probit"</code>.</p>
</td></tr>
<tr><td><code id="compute_prob_predicted_+3A_max_score">max_score</code></td>
<td>
<p>Maximum attainable value of final scores.</p>
</td></tr>
<tr><td><code id="compute_prob_predicted_+3A_score_breaks">score_breaks</code></td>
<td>
<p>A vector of score breaks to group scores. The average
predicted risk will be reported for each score interval in the lookup
table. Users are advised to first visualise the predicted risk for all
attainable scores to determine <code>scores</code> (see
<code><a href="#topic+plot_predicted_risk">plot_predicted_risk</a></code>)</p>
</td></tr>
</table>

<hr>
<h2 id='compute_score_table'>Internal function: Compute scoring table based on training dataset (AutoScore Module 3)</h2><span id='topic+compute_score_table'></span>

<h3>Description</h3>

<p>Compute scoring table based on training dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_score_table(train_set_2, max_score, variable_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_score_table_+3A_train_set_2">train_set_2</code></td>
<td>
<p>Processed training set after variable transformation (AutoScore Module 2)</p>
</td></tr>
<tr><td><code id="compute_score_table_+3A_max_score">max_score</code></td>
<td>
<p>Maximum total score</p>
</td></tr>
<tr><td><code id="compute_score_table_+3A_variable_list">variable_list</code></td>
<td>
<p>List of included variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scoring table
</p>

<hr>
<h2 id='compute_score_table_ord'>Internal function: Compute scoring table for ordinal outcomes based on
training dataset</h2><span id='topic+compute_score_table_ord'></span>

<h3>Description</h3>

<p>Compute scoring table based on training dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_score_table_ord(train_set_2, max_score, variable_list, link)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_score_table_ord_+3A_train_set_2">train_set_2</code></td>
<td>
<p>Processed training set after variable transformation</p>
</td></tr>
<tr><td><code id="compute_score_table_ord_+3A_max_score">max_score</code></td>
<td>
<p>Maximum total score</p>
</td></tr>
<tr><td><code id="compute_score_table_ord_+3A_variable_list">variable_list</code></td>
<td>
<p>List of included variables</p>
</td></tr>
<tr><td><code id="compute_score_table_ord_+3A_link">link</code></td>
<td>
<p>The link function used to model ordinal outcomes. Default is
<code>"logit"</code> for proportional odds model. Other options are
<code>"cloglog"</code> (proportional hazards model) and <code>"probit"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scoring table
</p>

<hr>
<h2 id='compute_score_table_survival'>Internal function: Compute scoring table for survival outcomes based on training dataset</h2><span id='topic+compute_score_table_survival'></span>

<h3>Description</h3>

<p>Compute scoring table for survival outcomes based on training dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_score_table_survival(train_set_2, max_score, variable_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_score_table_survival_+3A_train_set_2">train_set_2</code></td>
<td>
<p>Processed training set after variable transformation (AutoScore Module 2)</p>
</td></tr>
<tr><td><code id="compute_score_table_survival_+3A_max_score">max_score</code></td>
<td>
<p>Maximum total score</p>
</td></tr>
<tr><td><code id="compute_score_table_survival_+3A_variable_list">variable_list</code></td>
<td>
<p>List of included variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scoring table
</p>

<hr>
<h2 id='compute_uni_variable_table'>AutoScore function: Univariable Analysis</h2><span id='topic+compute_uni_variable_table'></span>

<h3>Description</h3>

<p>Perform univariable analysis and generate the result table with odd ratios.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_uni_variable_table(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_uni_variable_table_+3A_df">df</code></td>
<td>
<p>data frame after checking</p>
</td></tr>
</table>


<h3>Value</h3>

<p>result of univariate analysis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sample_data")
names(sample_data)[names(sample_data) == "Mortality_inpatient"] &lt;- "label"
uni_table&lt;-compute_uni_variable_table(sample_data)
</code></pre>

<hr>
<h2 id='compute_uni_variable_table_ordinal'>AutoScore-Ordinal function: Univariable Analysis</h2><span id='topic+compute_uni_variable_table_ordinal'></span>

<h3>Description</h3>

<p>Perform univariable analysis and generate the result table with
odd ratios from proportional odds models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_uni_variable_table_ordinal(df, link = "logit", n_digits = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_uni_variable_table_ordinal_+3A_df">df</code></td>
<td>
<p>data frame after checking</p>
</td></tr>
<tr><td><code id="compute_uni_variable_table_ordinal_+3A_link">link</code></td>
<td>
<p>The link function used to model ordinal outcomes. Default is
<code>"logit"</code> for proportional odds model. Other options are
<code>"cloglog"</code> (proportional hazards model) and <code>"probit"</code>.</p>
</td></tr>
<tr><td><code id="compute_uni_variable_table_ordinal_+3A_n_digits">n_digits</code></td>
<td>
<p>Number of digits to print for OR or exponentiated
coefficients (Default:3).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>result of univariate analysis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sample_data_ordinal")
# Using just a few variables to demonstrate usage:
uni_table&lt;-compute_uni_variable_table_ordinal(sample_data_ordinal[, 1:3])
</code></pre>

<hr>
<h2 id='compute_uni_variable_table_survival'>AutoScore function for survival outcomes: Univariate Analysis</h2><span id='topic+compute_uni_variable_table_survival'></span>

<h3>Description</h3>

<p>Generate tables for Univariate analysis for survival outcomes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_uni_variable_table_survival(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_uni_variable_table_survival_+3A_df">df</code></td>
<td>
<p>data frame after checking</p>
</td></tr>
</table>


<h3>Value</h3>

<p>result of the Univariate analysis for survival outcomes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sample_data_survival")
uni_table&lt;-compute_uni_variable_table_survival(sample_data_survival)
</code></pre>

<hr>
<h2 id='conversion_table'>AutoScore function: Print conversion table based on final performance evaluation</h2><span id='topic+conversion_table'></span>

<h3>Description</h3>

<p>Print conversion table based on final performance evaluation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conversion_table(
  pred_score,
  by = "risk",
  values = c(0.01, 0.05, 0.1, 0.2, 0.5)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conversion_table_+3A_pred_score">pred_score</code></td>
<td>
<p>a vector with outcomes and final scores generated from <code><a href="#topic+AutoScore_testing">AutoScore_testing</a></code></p>
</td></tr>
<tr><td><code id="conversion_table_+3A_by">by</code></td>
<td>
<p>specify correct method for categorizing the threshold:  by &quot;risk&quot; or &quot;score&quot;.Default to &quot;risk&quot;</p>
</td></tr>
<tr><td><code id="conversion_table_+3A_values">values</code></td>
<td>
<p>A vector of threshold for analyze sensitivity, specificity and other metrics. Default to &quot;c(0.01,0.05,0.1,0.2,0.5)&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value and the conversion will be printed out directly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AutoScore_testing">AutoScore_testing</a></code>
</p>

<hr>
<h2 id='conversion_table_ordinal'>AutoScore function: Print conversion table for ordinal outcomes to map score to risk</h2><span id='topic+conversion_table_ordinal'></span>

<h3>Description</h3>

<p>AutoScore function: Print conversion table for ordinal outcomes to map score to risk
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conversion_table_ordinal(
  pred_score,
  link = "logit",
  max_score = 100,
  score_breaks = seq(from = 5, to = 70, by = 5),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conversion_table_ordinal_+3A_pred_score">pred_score</code></td>
<td>
<p>A <code>data.frame</code> with outcomes and final scores
generated from <code><a href="#topic+AutoScore_fine_tuning_Ordinal">AutoScore_fine_tuning_Ordinal</a></code></p>
</td></tr>
<tr><td><code id="conversion_table_ordinal_+3A_link">link</code></td>
<td>
<p>The link function used to model ordinal outcomes. Default is
<code>"logit"</code> for proportional odds model. Other options are
<code>"cloglog"</code> (proportional hazards model) and <code>"probit"</code>.</p>
</td></tr>
<tr><td><code id="conversion_table_ordinal_+3A_max_score">max_score</code></td>
<td>
<p>Maximum attainable value of final scores.</p>
</td></tr>
<tr><td><code id="conversion_table_ordinal_+3A_score_breaks">score_breaks</code></td>
<td>
<p>A vector of score breaks to group scores. The average
predicted risk will be reported for each score interval in the lookup
table. Users are advised to first visualise the predicted risk for all
attainable scores to determine <code>scores</code> (see
<code><a href="#topic+plot_predicted_risk">plot_predicted_risk</a></code>)</p>
</td></tr>
<tr><td><code id="conversion_table_ordinal_+3A_...">...</code></td>
<td>
<p>Additional parameters to pass to <code><a href="knitr.html#topic+kable">kable</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value and the conversion will be printed out directly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AutoScore_testing_Ordinal">AutoScore_testing_Ordinal</a></code>
</p>

<hr>
<h2 id='conversion_table_survival'>AutoScore function for survival outcomes: Print conversion table</h2><span id='topic+conversion_table_survival'></span>

<h3>Description</h3>

<p>Print conversion table for survival outcomes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conversion_table_survival(
  pred_score,
  score_cut = c(40, 50, 60),
  time_point = c(7, 14, 30, 60, 90)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conversion_table_survival_+3A_pred_score">pred_score</code></td>
<td>
<p>a data frame with outcomes and final scores generated from <code><a href="#topic+AutoScore_testing_Survival">AutoScore_testing_Survival</a></code></p>
</td></tr>
<tr><td><code id="conversion_table_survival_+3A_score_cut">score_cut</code></td>
<td>
<p>Score cut-offs to be used for generating conversion table</p>
</td></tr>
<tr><td><code id="conversion_table_survival_+3A_time_point">time_point</code></td>
<td>
<p>The time points to be evaluated using time-dependent AUC(t).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>conversion table and the it will also be printed out directly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AutoScore_testing_Survival">AutoScore_testing_Survival</a></code>
</p>

<hr>
<h2 id='estimate_p_mat'>Internal function: generate probability matrix for ordinal outcomes given
thresholds, linear predictor and link function</h2><span id='topic+estimate_p_mat'></span>

<h3>Description</h3>

<p>Internal function: generate probability matrix for ordinal outcomes given
thresholds, linear predictor and link function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_p_mat(theta, z, link)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_p_mat_+3A_theta">theta</code></td>
<td>
<p>numeric vector of thresholds</p>
</td></tr>
<tr><td><code id="estimate_p_mat_+3A_z">z</code></td>
<td>
<p>numeric vector of linear predictor</p>
</td></tr>
<tr><td><code id="estimate_p_mat_+3A_link">link</code></td>
<td>
<p>The link function used to model ordinal outcomes. Default is
<code>"logit"</code> for proportional odds model. Other options are
<code>"cloglog"</code> (proportional hazards model) and <code>"probit"</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='eva_performance_iauc'>Internal function survival outcome: Calculate iAUC for validation set</h2><span id='topic+eva_performance_iauc'></span>

<h3>Description</h3>

<p>Internal function survival outcome: Calculate iAUC for validation set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eva_performance_iauc(score, validation_set, print = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eva_performance_iauc_+3A_score">score</code></td>
<td>
<p>Predicted score</p>
</td></tr>
<tr><td><code id="eva_performance_iauc_+3A_validation_set">validation_set</code></td>
<td>
<p>Dataset for generating performance</p>
</td></tr>
<tr><td><code id="eva_performance_iauc_+3A_print">print</code></td>
<td>
<p>Whether to print out the final iAUC result</p>
</td></tr>
</table>

<hr>
<h2 id='evaluate_model_ord'>Internal function: Evaluate model performance on ordinal data</h2><span id='topic+evaluate_model_ord'></span>

<h3>Description</h3>

<p>Internal function: Evaluate model performance on ordinal data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_model_ord(label, score, n_boot, report_cindex = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_model_ord_+3A_label">label</code></td>
<td>
<p>outcome variable</p>
</td></tr>
<tr><td><code id="evaluate_model_ord_+3A_score">score</code></td>
<td>
<p>predicted score</p>
</td></tr>
<tr><td><code id="evaluate_model_ord_+3A_n_boot">n_boot</code></td>
<td>
<p>Number of bootstrap cycles to compute 95% CI for performance
metrics.</p>
</td></tr>
<tr><td><code id="evaluate_model_ord_+3A_report_cindex">report_cindex</code></td>
<td>
<p>If generalized c-index should be reported alongside
mAUC (Default:FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of the mAUC (mauc) and generalized c-index (cindex, if
requested for) and their 95
</p>

<hr>
<h2 id='extract_or_ci_ord'>Extract OR, CI and p-value from a proportional odds model</h2><span id='topic+extract_or_ci_ord'></span>

<h3>Description</h3>

<p>Extract OR, CI and p-value from a proportional odds model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_or_ci_ord(model, n_digits = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_or_ci_ord_+3A_model">model</code></td>
<td>
<p>An ordinal regression model fitted using <code><a href="ordinal.html#topic+clm">clm</a></code>.</p>
</td></tr>
<tr><td><code id="extract_or_ci_ord_+3A_n_digits">n_digits</code></td>
<td>
<p>Number of digits to print for OR or exponentiated
coefficients (Default:3).</p>
</td></tr>
</table>

<hr>
<h2 id='find_one_inds'>Internal function: Find column indices in design matrix that should be 1</h2><span id='topic+find_one_inds'></span>

<h3>Description</h3>

<p>Internal function: Find column indices in design matrix that should be 1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_one_inds(x_inds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_one_inds_+3A_x_inds">x_inds</code></td>
<td>
<p>A list of column indices corresponding to each final variable.</p>
</td></tr>
</table>

<hr>
<h2 id='find_possible_scores'>Internal function: Compute all scores attainable.</h2><span id='topic+find_possible_scores'></span>

<h3>Description</h3>

<p>Internal function: Compute all scores attainable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_possible_scores(final_variables, scoring_table)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_possible_scores_+3A_final_variables">final_variables</code></td>
<td>
<p>A vector containing the list of selected variables.</p>
</td></tr>
<tr><td><code id="find_possible_scores_+3A_scoring_table">scoring_table</code></td>
<td>
<p>The final scoring table after fine-tuning.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric vector of all scores attainable.
</p>

<hr>
<h2 id='get_cut_vec'>Internal function: Calculate cut_vec from the training set (AutoScore Module 2)</h2><span id='topic+get_cut_vec'></span>

<h3>Description</h3>

<p>Internal function: Calculate cut_vec from the training set (AutoScore Module 2)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_cut_vec(
  df,
  quantiles = c(0, 0.05, 0.2, 0.8, 0.95, 1),
  max_cluster = 5,
  categorize = "quantile"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_cut_vec_+3A_df">df</code></td>
<td>
<p>training set to be used for calculate the cut vector</p>
</td></tr>
<tr><td><code id="get_cut_vec_+3A_quantiles">quantiles</code></td>
<td>
<p>Predefined quantiles to convert continuous variables to categorical ones. (Default: c(0, 0.05, 0.2, 0.8, 0.95, 1)) Available if <code>categorize = "quantile"</code>.</p>
</td></tr>
<tr><td><code id="get_cut_vec_+3A_max_cluster">max_cluster</code></td>
<td>
<p>The max number of cluster (Default: 5). Available if <code>categorize = "kmeans"</code>.</p>
</td></tr>
<tr><td><code id="get_cut_vec_+3A_categorize">categorize</code></td>
<td>
<p>Methods for categorize continuous variables. Options include &quot;quantile&quot; or &quot;kmeans&quot; (Default: &quot;quantile&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>cut_vec for <code>transform_df_fixed</code>
</p>

<hr>
<h2 id='group_score'>Internal function: Group scores based on given score breaks, and use friendly
names for first and last intervals.</h2><span id='topic+group_score'></span>

<h3>Description</h3>

<p>Internal function: Group scores based on given score breaks, and use friendly
names for first and last intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_score(score, max_score, score_breaks)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_score_+3A_score">score</code></td>
<td>
<p>numeric vector of scores.</p>
</td></tr>
<tr><td><code id="group_score_+3A_max_score">max_score</code></td>
<td>
<p>Maximum attainable value of final scores.</p>
</td></tr>
<tr><td><code id="group_score_+3A_score_breaks">score_breaks</code></td>
<td>
<p>A vector of score breaks to group scores. The average
predicted risk will be reported for each score interval in the lookup
table. Users are advised to first visualise the predicted risk for all
attainable scores to determine <code>scores</code> (see
<code><a href="#topic+plot_predicted_risk">plot_predicted_risk</a></code>)</p>
</td></tr>
</table>

<hr>
<h2 id='induce_informative_missing'>Internal function: induce informative missing to sample data in the package
to demonstrate how AutoScore handles missing as a separate category</h2><span id='topic+induce_informative_missing'></span>

<h3>Description</h3>

<p>Internal function: induce informative missing to sample data in the package
to demonstrate how AutoScore handles missing as a separate category
</p>


<h3>Usage</h3>

<pre><code class='language-R'>induce_informative_missing(
  df,
  vars_to_induce = c("Lab_A", "Vital_A"),
  prop_missing = 0.4
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="induce_informative_missing_+3A_df">df</code></td>
<td>
<p>A data.frame of sample data.</p>
</td></tr>
<tr><td><code id="induce_informative_missing_+3A_vars_to_induce">vars_to_induce</code></td>
<td>
<p>Names of variables to induce informative missing in.
Default is c(&quot;Lab_A&quot;, &quot;Vital_A&quot;).</p>
</td></tr>
<tr><td><code id="induce_informative_missing_+3A_prop_missing">prop_missing</code></td>
<td>
<p>Proportion of missing to induce for each
<code>vars_to_induce</code>. Can be a single value for a common proportion for
all variables (default is 0.4), or a vector with same length as
<code>vars_to_induce</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assume subjects with normal values (i.e., values close to the
median) are more likely to not have measurements.
</p>


<h3>Value</h3>

<p>Returns <code>df</code> with selected columns modified to have missing.
</p>

<hr>
<h2 id='induce_median_missing'>Internal function: induce informative missing in a single variable</h2><span id='topic+induce_median_missing'></span>

<h3>Description</h3>

<p>Internal function: induce informative missing in a single variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>induce_median_missing(x, prop_missing)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="induce_median_missing_+3A_x">x</code></td>
<td>
<p>Variable to induce missing in.</p>
</td></tr>
<tr><td><code id="induce_median_missing_+3A_prop_missing">prop_missing</code></td>
<td>
<p>Proportion of missing to induce for each
<code>vars_to_induce</code>. Can be a single value for a common proportion for
all variables (default is 0.4), or a vector with same length as
<code>vars_to_induce</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='inv_cloglog'>Internal function: Inverse cloglog link</h2><span id='topic+inv_cloglog'></span>

<h3>Description</h3>

<p>Internal function: Inverse cloglog link
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inv_cloglog(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inv_cloglog_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
</table>

<hr>
<h2 id='inv_logit'>Internal function: Inverse logit link</h2><span id='topic+inv_logit'></span>

<h3>Description</h3>

<p>Internal function: Inverse logit link
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inv_logit(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inv_logit_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
</table>

<hr>
<h2 id='inv_probit'>Internal function: Inverse probit link</h2><span id='topic+inv_probit'></span>

<h3>Description</h3>

<p>Internal function: Inverse probit link
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inv_probit(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inv_probit_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
</table>

<hr>
<h2 id='make_design_mat'>Internal function: Based on <code>find_one_inds</code>, make a design matrix to
compute all scores attainable.</h2><span id='topic+make_design_mat'></span>

<h3>Description</h3>

<p>Internal function: Based on <code>find_one_inds</code>, make a design matrix to
compute all scores attainable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_design_mat(one_inds)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_design_mat_+3A_one_inds">one_inds</code></td>
<td>
<p>Output from <code>find_one_inds</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='plot_auc'>Internal function: Make parsimony plot</h2><span id='topic+plot_auc'></span>

<h3>Description</h3>

<p>Internal function: Make parsimony plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_auc(
  AUC,
  variables,
  num = seq_along(variables),
  auc_lim_min,
  auc_lim_max,
  ylab = "Mean Area Under the Curve",
  title = "Parsimony plot on the validation set"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_auc_+3A_auc">AUC</code></td>
<td>
<p>A vector of AUC values (or mAUC for ordinal outcomes).</p>
</td></tr>
<tr><td><code id="plot_auc_+3A_variables">variables</code></td>
<td>
<p>A vector of variable names</p>
</td></tr>
<tr><td><code id="plot_auc_+3A_num">num</code></td>
<td>
<p>A vector of indices for AUC values to plot. Default is to plot all.</p>
</td></tr>
<tr><td><code id="plot_auc_+3A_auc_lim_min">auc_lim_min</code></td>
<td>
<p>Min y_axis limit in the parsimony plot (Default: 0.5).</p>
</td></tr>
<tr><td><code id="plot_auc_+3A_auc_lim_max">auc_lim_max</code></td>
<td>
<p>Max y_axis limit in the parsimony plot (Default: &quot;adaptive&quot;).</p>
</td></tr>
<tr><td><code id="plot_auc_+3A_ylab">ylab</code></td>
<td>
<p>Title of y-axis</p>
</td></tr>
<tr><td><code id="plot_auc_+3A_title">title</code></td>
<td>
<p>Plot title</p>
</td></tr>
</table>

<hr>
<h2 id='plot_importance'>Internal Function: Print plotted variable importance</h2><span id='topic+plot_importance'></span>

<h3>Description</h3>

<p>Internal Function: Print plotted variable importance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_importance(ranking)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_importance_+3A_ranking">ranking</code></td>
<td>
<p>vector output generated by functions: AutoScore_rank, AutoScore_rank_Survival or AutoScore_rank_Ordinal</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+AutoScore_rank">AutoScore_rank</a></code>, <code><a href="#topic+AutoScore_rank_Survival">AutoScore_rank_Survival</a></code>, <code><a href="#topic+AutoScore_rank_Ordinal">AutoScore_rank_Ordinal</a></code>
</p>

<hr>
<h2 id='plot_predicted_risk'>AutoScore function for binary and ordinal outcomes: Plot predicted risk</h2><span id='topic+plot_predicted_risk'></span>

<h3>Description</h3>

<p>AutoScore function for binary and ordinal outcomes: Plot predicted risk
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_predicted_risk(
  pred_score,
  link = "logit",
  max_score = 100,
  final_variables,
  scoring_table,
  point_size = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_predicted_risk_+3A_pred_score">pred_score</code></td>
<td>
<p>Output from <code><a href="#topic+AutoScore_testing">AutoScore_testing</a></code> (for binary
outcomes) or <code><a href="#topic+AutoScore_testing_Ordinal">AutoScore_testing_Ordinal</a></code> (for ordinal
outcomes).</p>
</td></tr>
<tr><td><code id="plot_predicted_risk_+3A_link">link</code></td>
<td>
<p>(For ordinal outcome only) The link function used in ordinal
regression, which must be the same as the value used to build the risk
score. Default is <code>"logit"</code> for proportional odds model.</p>
</td></tr>
<tr><td><code id="plot_predicted_risk_+3A_max_score">max_score</code></td>
<td>
<p>Maximum total score (Default: 100).</p>
</td></tr>
<tr><td><code id="plot_predicted_risk_+3A_final_variables">final_variables</code></td>
<td>
<p>A vector containing the list of selected variables,
selected from Step(ii) <code><a href="#topic+AutoScore_parsimony">AutoScore_parsimony</a></code> (for binary
outcomes) or <code><a href="#topic+AutoScore_parsimony_Ordinal">AutoScore_parsimony_Ordinal</a></code> (for ordinal
outcomes).</p>
</td></tr>
<tr><td><code id="plot_predicted_risk_+3A_scoring_table">scoring_table</code></td>
<td>
<p>The final scoring table after fine-tuning, generated
from STEP(iv) <code><a href="#topic+AutoScore_fine_tuning">AutoScore_fine_tuning</a></code> (for binary outcomes) or
<code><a href="#topic+AutoScore_fine_tuning_Ordinal">AutoScore_fine_tuning_Ordinal</a></code> (for ordinal outcomes).</p>
</td></tr>
<tr><td><code id="plot_predicted_risk_+3A_point_size">point_size</code></td>
<td>
<p>Size of points in the plot. Default is 0.5.</p>
</td></tr>
</table>

<hr>
<h2 id='plot_roc_curve'>Internal Function: Plotting ROC curve</h2><span id='topic+plot_roc_curve'></span>

<h3>Description</h3>

<p>Internal Function: Plotting ROC curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_roc_curve(prob, labels, quiet = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_roc_curve_+3A_prob">prob</code></td>
<td>
<p>Predicate probability</p>
</td></tr>
<tr><td><code id="plot_roc_curve_+3A_labels">labels</code></td>
<td>
<p>Actual outcome(binary)</p>
</td></tr>
<tr><td><code id="plot_roc_curve_+3A_quiet">quiet</code></td>
<td>
<p>if set to TRUE, there will be no trace printing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value and the ROC curve will be plotted.
</p>

<hr>
<h2 id='plot_survival_km'>AutoScore function for survival outcomes: Print scoring performance (KM curve)</h2><span id='topic+plot_survival_km'></span>

<h3>Description</h3>

<p>Print scoring performance (KM curve) for survival outcome
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_survival_km(
  pred_score,
  score_cut = c(40, 50, 60),
  risk.table = TRUE,
  title = NULL,
  legend.title = "Score",
  xlim = c(0, 90),
  break.x.by = 30,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_survival_km_+3A_pred_score">pred_score</code></td>
<td>
<p>Generated from STEP(v)<code>AutoScore_testing_Survival()</code></p>
</td></tr>
<tr><td><code id="plot_survival_km_+3A_score_cut">score_cut</code></td>
<td>
<p>Score cut-offs to be used for the analysis</p>
</td></tr>
<tr><td><code id="plot_survival_km_+3A_risk.table">risk.table</code></td>
<td>
<p>Allowed values include: TRUE or FALSE specifying whether
to show or not the risk table. Default is TRUE.</p>
</td></tr>
<tr><td><code id="plot_survival_km_+3A_title">title</code></td>
<td>
<p>Title displayed in the KM curve</p>
</td></tr>
<tr><td><code id="plot_survival_km_+3A_legend.title">legend.title</code></td>
<td>
<p>Legend title displayed in the KM curve</p>
</td></tr>
<tr><td><code id="plot_survival_km_+3A_xlim">xlim</code></td>
<td>
<p>limit for x</p>
</td></tr>
<tr><td><code id="plot_survival_km_+3A_break.x.by">break.x.by</code></td>
<td>
<p>Threshold for analyze sensitivity,</p>
</td></tr>
<tr><td><code id="plot_survival_km_+3A_...">...</code></td>
<td>
<p>additional parameters to pass to
<code><a href="survminer.html#topic+ggsurvplot">ggsurvplot</a></code> .</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value and the KM performance will be plotted.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AutoScore_testing_Survival">AutoScore_testing_Survival</a></code>
</p>

<hr>
<h2 id='print_performance_ci_survival'>AutoScore function for survival outcomes: Print predictive performance with confidence intervals</h2><span id='topic+print_performance_ci_survival'></span>

<h3>Description</h3>

<p>Print iAUC, c-index and time-dependent AUC as the predictive performance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_performance_ci_survival(score, validation_set, time_point, n_boot = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_performance_ci_survival_+3A_score">score</code></td>
<td>
<p>Predicted score</p>
</td></tr>
<tr><td><code id="print_performance_ci_survival_+3A_validation_set">validation_set</code></td>
<td>
<p>Dataset for generating performance</p>
</td></tr>
<tr><td><code id="print_performance_ci_survival_+3A_time_point">time_point</code></td>
<td>
<p>The time points to be evaluated using time-dependent AUC(t).</p>
</td></tr>
<tr><td><code id="print_performance_ci_survival_+3A_n_boot">n_boot</code></td>
<td>
<p>Number of bootstrap cycles to compute 95% CI for performance
metrics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value and the ROC performance will be printed out directly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AutoScore_testing_Ordinal">AutoScore_testing_Ordinal</a></code>
</p>

<hr>
<h2 id='print_performance_ordinal'>AutoScore function for ordinal outcomes: Print predictive performance</h2><span id='topic+print_performance_ordinal'></span>

<h3>Description</h3>

<p>Print mean area under the curve (mAUC) and generalised c-index
(if requested)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_performance_ordinal(label, score, n_boot = 100, report_cindex = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_performance_ordinal_+3A_label">label</code></td>
<td>
<p>outcome variable</p>
</td></tr>
<tr><td><code id="print_performance_ordinal_+3A_score">score</code></td>
<td>
<p>predicted score</p>
</td></tr>
<tr><td><code id="print_performance_ordinal_+3A_n_boot">n_boot</code></td>
<td>
<p>Number of bootstrap cycles to compute 95% CI for performance
metrics.</p>
</td></tr>
<tr><td><code id="print_performance_ordinal_+3A_report_cindex">report_cindex</code></td>
<td>
<p>Whether to report generalized c-index for model
evaluation (Default:FALSE for faster evaluation).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value and the ROC performance will be printed out directly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AutoScore_testing_Ordinal">AutoScore_testing_Ordinal</a></code>
</p>

<hr>
<h2 id='print_performance_survival'>AutoScore function for survival outcomes: Print predictive performance</h2><span id='topic+print_performance_survival'></span>

<h3>Description</h3>

<p>Print mean area under the curve (mAUC) and generalised c-index
(if requested)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_performance_survival(score, validation_set, time_point)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_performance_survival_+3A_score">score</code></td>
<td>
<p>Predicted score</p>
</td></tr>
<tr><td><code id="print_performance_survival_+3A_validation_set">validation_set</code></td>
<td>
<p>Dataset for generating performance</p>
</td></tr>
<tr><td><code id="print_performance_survival_+3A_time_point">time_point</code></td>
<td>
<p>The time points to be evaluated using time-dependent AUC(t).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value and the ROC performance will be printed out directly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AutoScore_testing_Ordinal">AutoScore_testing_Ordinal</a></code>
</p>

<hr>
<h2 id='print_roc_performance'>AutoScore function: Print receiver operating characteristic (ROC) performance</h2><span id='topic+print_roc_performance'></span>

<h3>Description</h3>

<p>Print receiver operating characteristic (ROC) performance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_roc_performance(label, score, threshold = "best", metrics_ci = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_roc_performance_+3A_label">label</code></td>
<td>
<p>outcome variable</p>
</td></tr>
<tr><td><code id="print_roc_performance_+3A_score">score</code></td>
<td>
<p>predicted score</p>
</td></tr>
<tr><td><code id="print_roc_performance_+3A_threshold">threshold</code></td>
<td>
<p>Threshold for analyze sensitivity, specificity and other metrics. Default to &quot;best&quot;</p>
</td></tr>
<tr><td><code id="print_roc_performance_+3A_metrics_ci">metrics_ci</code></td>
<td>
<p>whether to calculate confidence interval for the metrics of sensitivity, specificity, etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value and the ROC performance will be printed out directly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AutoScore_testing">AutoScore_testing</a></code>
</p>

<hr>
<h2 id='print_scoring_table'>AutoScore Function: Print scoring tables for visualization</h2><span id='topic+print_scoring_table'></span>

<h3>Description</h3>

<p>AutoScore Function: Print scoring tables for visualization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_scoring_table(scoring_table, final_variable)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_scoring_table_+3A_scoring_table">scoring_table</code></td>
<td>
<p>Raw scoring table generated by AutoScore step(iv) <code><a href="#topic+AutoScore_fine_tuning">AutoScore_fine_tuning</a></code></p>
</td></tr>
<tr><td><code id="print_scoring_table_+3A_final_variable">final_variable</code></td>
<td>
<p>Final included variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame of formatted scoring table
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AutoScore_fine_tuning">AutoScore_fine_tuning</a></code>, <code><a href="#topic+AutoScore_weighting">AutoScore_weighting</a></code>
</p>

<hr>
<h2 id='sample_data'>20000 simulated ICU admission data, with the same distribution as the data in the MIMIC-III ICU database</h2><span id='topic+sample_data'></span>

<h3>Description</h3>

<p>20000 simulated samples, with the same distribution as the data in the MIMIC-III ICU database. It is used for demonstration only in the Guidebook. Run <code>vignette("Guide_book", package = "AutoScore")</code> to see the guidebook or vignette.
</p>

<ul>
<li><p>Johnson, A., Pollard, T., Shen, L. et al. MIMIC-III, a freely accessible critical care database. Sci Data 3, 160035 (2016).
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>sample_data
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 20000 rows and 22 columns.
</p>

<hr>
<h2 id='sample_data_ordinal'>Simulated ED data with ordinal outcome</h2><span id='topic+sample_data_ordinal'></span>

<h3>Description</h3>

<p>Simulated data for 20,000 inpatient visits with demographic
information, healthcare resource utilisation and associated laboratory
tests and vital signs measured in the emergency department (ED). Data were
simulated based on the dataset analysed in the AutoScore-Ordinal paper, and
only includes a subset of variables (with masked variable names) for the
purpose of demonstrating the AutoScore framework for ordinal outcomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_data_ordinal
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 20000 rows and 21 columns.
</p>


<h3>References</h3>


<ul>
<li><p>Saffari SE, Ning Y, Feng X, Chakraborty B, Volovici V, Vaughan R, Ong
ME, Liu N, AutoScore-Ordinal: An interpretable machine learning framework for
generating scoring models for ordinal outcomes, arXiv:2202.08407
</p>
</li></ul>


<hr>
<h2 id='sample_data_ordinal_small'>Simulated ED data with ordinal outcome (small sample size)</h2><span id='topic+sample_data_ordinal_small'></span>

<h3>Description</h3>

<p>5,000 observations randomly sampled from
<code><a href="#topic+sample_data_ordinal">sample_data_ordinal</a></code>. It is used for demonstration only in the
Guidebook.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_data_ordinal_small
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 5000 rows and 21 columns.
</p>

<hr>
<h2 id='sample_data_small'>1000 simulated ICU admission data, with the same distribution as the data in the MIMIC-III ICU database</h2><span id='topic+sample_data_small'></span>

<h3>Description</h3>

<p>1000 simulated samples, with the same distribution as the data in the MIMIC-III ICU database. It is used for demonstration only in the Guidebook. Run <code>vignette("Guide_book", package = "AutoScore")</code> to see the guidebook or vignette.
</p>

<ul>
<li><p>Johnson, A., Pollard, T., Shen, L. et al. MIMIC-III, a freely accessible critical care database. Sci Data 3, 160035 (2016).
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>sample_data_small
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 1000 rows and 22 columns.
</p>

<hr>
<h2 id='sample_data_survival'>20000 simulated MIMIC sample data with survival outcomes</h2><span id='topic+sample_data_survival'></span>

<h3>Description</h3>

<p>20000 simulated samples, with the same distribution
as the data in the MIMIC-III ICU database. Data were simulated based on the dataset
analysed in the AutoScore-Survival paper. It is used for demonstration
only in the Guidebook. Run <code>vignette("Guide_book", package = "AutoScore")</code>
to see the guidebook or vignette.
</p>

<ul>
<li><p>Johnson, A., Pollard, T., Shen, L. et al. MIMIC-III, a freely accessible critical care database. Sci Data 3, 160035 (2016).
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>sample_data_survival
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 20000 rows and 23 columns.
</p>

<hr>
<h2 id='sample_data_survival_small'>1000 simulated MIMIC sample data with survival outcomes</h2><span id='topic+sample_data_survival_small'></span>

<h3>Description</h3>

<p>1000 simulated samples, with the same distribution
as the data in the MIMIC-III ICU database. Data were simulated based on the dataset
analysed in the AutoScore-Survival paper. It is used for demonstration
only in the Guidebook. Run <code>vignette("Guide_book", package = "AutoScore")</code>
to see the guidebook or vignette.
</p>

<ul>
<li><p>Johnson, A., Pollard, T., Shen, L. et al. MIMIC-III, a freely accessible critical care database. Sci Data 3, 160035 (2016).
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>sample_data_survival_small
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 1000 rows and 23 columns.
</p>

<hr>
<h2 id='sample_data_with_missing'>20000 simulated ICU admission data with missing values</h2><span id='topic+sample_data_with_missing'></span>

<h3>Description</h3>

<p>20000 simulated samples with missing values, which can be used for demostrating AutoScore workflow dealing with missing values.
</p>

<ul>
<li><p>Johnson, A., Pollard, T., Shen, L. et al. MIMIC-III, a freely accessible critical care database. Sci Data 3, 160035 (2016).
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>sample_data_with_missing
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 20000 rows and 23 columns.
</p>

<hr>
<h2 id='split_data'>AutoScore Function: Automatically splitting dataset to train,
validation and test set, possibly stratified by label</h2><span id='topic+split_data'></span>

<h3>Description</h3>

<p>AutoScore Function: Automatically splitting dataset to train,
validation and test set, possibly stratified by label
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_data(data, ratio, cross_validation = FALSE, strat_by_label = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_data_+3A_data">data</code></td>
<td>
<p>The dataset to be split</p>
</td></tr>
<tr><td><code id="split_data_+3A_ratio">ratio</code></td>
<td>
<p>The ratio for dividing dataset into training, validation and
testing set. (Default: c(0.7, 0.1, 0.2))</p>
</td></tr>
<tr><td><code id="split_data_+3A_cross_validation">cross_validation</code></td>
<td>
<p>If set to <code>TRUE</code>, cross-validation would be used
for generating parsimony plot, which is suitable for small-size data.
Default to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="split_data_+3A_strat_by_label">strat_by_label</code></td>
<td>
<p>If set to <code>TRUE</code>, data splitting is stratified on
the outcome variable. Default to <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing training, validation and testing set
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sample_data")
names(sample_data)[names(sample_data) == "Mortality_inpatient"] &lt;- "label"
set.seed(4)
#large sample size
out_split &lt;- split_data(data = sample_data, ratio = c(0.7, 0.1, 0.2))
#small sample size
out_split &lt;- split_data(data = sample_data, ratio = c(0.7, 0, 0.3),
                        cross_validation = TRUE)
#large sample size, stratified
out_split &lt;- split_data(data = sample_data, ratio = c(0.7, 0.1, 0.2),
                        strat_by_label = TRUE)
</code></pre>

<hr>
<h2 id='transform_df_fixed'>Internal function: Categorizing continuous variables based on cut_vec (AutoScore Module 2)</h2><span id='topic+transform_df_fixed'></span>

<h3>Description</h3>

<p>Internal function: Categorizing continuous variables based on cut_vec (AutoScore Module 2)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_df_fixed(df, cut_vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform_df_fixed_+3A_df">df</code></td>
<td>
<p>dataset(training, validation or testing) to be processed</p>
</td></tr>
<tr><td><code id="transform_df_fixed_+3A_cut_vec">cut_vec</code></td>
<td>
<p>fixed cut vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Processed <code>data.frame</code> after categorizing based on fixed cut_vec
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
