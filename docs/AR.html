<!DOCTYPE html><html><head><title>Help for package AR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {AR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AR-package'>
<p>Another Look at the Acceptance-Rejection Method</p></a></li>
<li><a href='#AR.Sim'>
<p>Graphical Visualization for Accept-Reject Method</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Another Look at the Acceptance-Rejection Method</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-05-02</td>
</tr>
<tr>
<td>Author:</td>
<td>Abbas Parchami (Department of Statistics, Faculty of Mathematics and Computer, Shahid Bahonar University of Kerman, Kerman, Iran)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Abbas Parchami &lt;parchami@uk.ac.ir&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>In mathematics, 'rejection sampling' is a basic technique used to generate observations from a distribution. It is also commonly called 'the Acceptance-Rejection method' or 'Accept-Reject algorithm' and is a type of Monte Carlo method. 'Acceptance-Rejection method' is based on the observation that to sample a random variable one can perform a uniformly random sampling of the 2D cartesian graph, and keep the samples in the region under the graph of its density function. Package 'AR' is able to generate/simulate random data from a probability density function by Acceptance-Rejection method. Moreover, this package is a useful teaching resource for graphical presentation of Acceptance-Rejection method. From the practical point of view, the user needs to calculate a constant in Acceptance-Rejection method, which package 'AR' is able to compute this constant by optimization tools. Several numerical examples are provided to illustrate the graphical presentation for the Acceptance-Rejection Method.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>DISTRIB</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-05-02 02:33:02 UTC; Parchami</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-05-02 03:54:28 UTC</td>
</tr>
</table>
<hr>
<h2 id='AR-package'>
Another Look at the Acceptance-Rejection Method
</h2><span id='topic+AR-package'></span><span id='topic+AR'></span>

<h3>Description</h3>

<p>There are many distributions for which the inverse transform method and even
general transformations will fail to be able to generate the required random
variables. For these cases, we must turn to indirect methods; that is, methods
in which we generate a candidate random variable and only accept it subject
to passing a test. This class of methods is extremely powerful
and will allow us to simulate from virtually any distribution; see (Robert and Casella, 2010) for more detailes.
These so-called <code>Accept-Reject methods</code> only require us to know the functional
form of the density <code class="reqn">f_X(.)</code> of interest (called the target density) up to a
multiplicative constant. We use a simpler (to simulate) density <code class="reqn">f_Y</code>, called the
instrumental or candidate density, to generate the random variable for which
the simulation is actually done. The constraints we impose on this candidate
density <code class="reqn">f_Y</code> are that:
</p>
<p>(i) <code class="reqn">Y</code> be simulate-able (the data simulation from <code class="reqn">Y</code> be actually possible).
</p>
<p>(ii) There is a constant <code class="reqn">c</code> with <code class="reqn"> \frac{f_X(x)}{f_Y(x)} \leq c </code> for all <code class="reqn"> x \in S_X=\lbrace x: f_X(x)&gt;0 \rbrace</code>.
</p>
<p>(iii) <code class="reqn">f_X</code> and <code class="reqn">f_Y</code> have compatible supports (i.e., <code class="reqn">S_X \subseteq S_Y</code>).
</p>
<p>In this case, <code class="reqn">X</code> can be simulated as follows by Accept-Reject method. First, we generate <code class="reqn">y</code> from <code class="reqn">Y \sim f_Y</code> and,
independently, we generate <code class="reqn">u</code> from  <code class="reqn">U \sim U(0,1)</code>. If  </p>
<p style="text-align: center;"><code class="reqn">u \leq \frac{f_X(y)}{c \ f_Y(y)},</code>
</p>
 
<p>then we set  <code class="reqn">x=y</code>. If the inequality is not satisfied, we then discard/reject <code class="reqn">y</code> and
<code class="reqn">u</code> and start again (Robert and Casella, 2010).
</p>


<h3>Details</h3>

<p>Package <code>AR</code> provides a useful tool for teaching students to understand the theoritical idea behind the <code>Accept-Reject method</code>. This package works with only one function, i.e. function <code>AR.Sim</code> which can generate random sample/vector on the basis of the  <code>Accept-Reject method</code>.
</p>


<h3>Author(s)</h3>

<p>Abbas Parchami
</p>
<p>Maintainer: Abbas Parchami &lt;parchami@uk.ac.ir&gt;
</p>


<h3>References</h3>

<p>Iacus, S.M., Simulation and Inference for Stochastic Differential Equations: With R Examples, Springer, New York (2008).
</p>
<p>Jones, O., Maillardet, R, Robinson, A., Introduction to Scientific Programming and Simulation Using R, Chapman &amp; Hall/CRC, Boca Raton (2009).
</p>
<p>Robert, C.P., Casella, G., Introducing Monte Carlo Methods with R, New York: Springer (2010).
</p>
<p>Vasishth, S., Broe, M., The Foundations of Statistics: A Simulation-based Approach, Springer (2010).
</p>
<p>Wikipedia, the free encyclopedia, Rejection sampling, 
https://en.wikipedia.org/wiki/Rejection_sampling
</p>

<hr>
<h2 id='AR.Sim'>
Graphical Visualization for Accept-Reject Method
</h2><span id='topic+AR.Sim'></span>

<h3>Description</h3>

<p>Package <code>AR</code> provides a graphical presentation for Accept-Reject method by drawing three figures which their explanations are as follow:
</p>
<p>Explanation of Figure 1:  
</p>
<p>Moreover, even when the Rejection Accept-Reject method is applied, it is always hard to optimize the constant <code class="reqn">c</code> for the likelihood ratio. Although, the algorithm works with a bigger constant <code class="reqn">c</code> (with respect to optimal/minimum possible <code class="reqn">c</code>), but increasing <code class="reqn">c</code> cause high rejection rate and the algorithm can be very in-efficient. 
The first figure show three curves <code class="reqn">f_X(x)</code>, <code class="reqn">f_Y(x)</code> and <code class="reqn">\frac{f_X(x)}{f_Y(x)}</code>. Moreover, the optimum <code class="reqn">c</code>  (minimum possible <code class="reqn">c</code>, such that <code class="reqn">\frac{f_X(x)}{f_Y(x)} \leq c</code>) calculated as the maximum height of the curve <code class="reqn">\frac{f_X(x)}{f_Y(x)}</code>, which is also shown on the first figure.
</p>
<p>Explanation of Figure 2:  
</p>
<p>To visualize the motivation behind the <code>Acceptance-Rejection method</code>, imagine graphing curve <code class="reqn">\frac{f_X(y)}{c \ f_Y(y)}</code> onto a large rectangular board and throwing darts at it. Assume that the <code class="reqn">x</code>-positions of these darts/points are uniformly distributed around the board and the distribution of <code class="reqn">y</code>-positions of them are based on <code class="reqn">Y</code> distribution. Now, remove all of the darts/points that are outside the area under the curve <code class="reqn">\frac{f_X(y)}{c \ f_Y(y)}</code>. 
The <code class="reqn">x</code>-positions of the remaining darts will be distributed according to the random variable's density of <code class="reqn">X</code> within the area under the curve. Since, it can be prove that </p>
<p style="text-align: center;"><code class="reqn"> P\left[ Y\leq y \ | \ U \leq \frac{f_X(Y)}{c \ f_Y(Y)} \right] = P\left( X \leq x \right) . </code>
</p>
 
<p>Explanation of Figure 3:  
</p>
<p>For another graphical presentation of the motivation behind the <code>Acceptance-Rejection method</code>, assumes that the considered board (which is presented in explanation of Figure 2) is not necessarily rectangular but is shaped according to some distribution that we know how to generate sample from it (<code class="reqn">c . f_Y(y)</code>).
Therefore, if <code class="reqn">y</code>-positions of random points/darts be equal to <code class="reqn">u.c.f_Y(y)</code>, then all darts/points will be land under the curve <code class="reqn">c.f_Y(y)</code>. 
The acceptance condition in the <code>Acceptance-Rejection method</code> is </p>
<p style="text-align: center;"><code class="reqn">u \leq \frac{f_X(y)}{c \ f_Y(y)},</code>
</p>
<p> or equivalently  </p>
<p style="text-align: center;"><code class="reqn">u.c.f_Y(y) \leq f_X(y),</code>
</p>
 
<p>and it means that after omitting the extra/red random darts/points from the board (which are not satisfy in the acceptance condition), the <code class="reqn">x</code>-positions of the remaining darts/points will be distributed according to the distribution of <code class="reqn">X</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AR.Sim(n, f_X, Y.dist, Y.dist.par, xlim = c(0, 1), S_X = xlim, Rej.Num = TRUE,
       Rej.Rate = TRUE, Acc.Rate = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AR.Sim_+3A_n">n</code></td>
<td>

<p>The number/length of data which must be generated/simulated from <code class="reqn">f_X</code> density.
</p>
</td></tr>
<tr><td><code id="AR.Sim_+3A_f_x">f_X</code></td>
<td>

<p>The density <code class="reqn">f_X</code> of interest for simulation (called the target density)
</p>
</td></tr>
<tr><td><code id="AR.Sim_+3A_y.dist">Y.dist</code></td>
<td>

<p>The distribution name of the random variable <code class="reqn">Y</code>, which used to generate the random data from <code class="reqn">f_Y</code>. Precisely, <code>Y.dist</code> is the name of <code class="reqn">f_Y</code> density which is match with <code>DISTRIB</code> Package. For example, use <code> Y.dist = "norm"</code>, when <code class="reqn"> Y \sim N(\mu, \sigma^2) </code>. 
</p>
</td></tr>
<tr><td><code id="AR.Sim_+3A_y.dist.par">Y.dist.par</code></td>
<td>

<p>A vector of <code class="reqn">Y</code> distribution parameters with considered ordering in <code>stats</code> package and also is match with <code>DISTRIB</code> Package. For example, use <code> Y.dist.par = </code>
<code>c(2,3)</code>, when <code class="reqn"> Y \sim N(\mu=2, \sigma^2=9) </code>. 
</p>
</td></tr>
<tr><td><code id="AR.Sim_+3A_xlim">xlim</code></td>
<td>

<p><code>NULL</code> or a numeric vector of length 2; if non-NULL it provides the defaults for c(from, to) and, unless <code>add=TRUE</code>, selects the <code class="reqn">x</code>-limits of the available plot. Its default is <code> xlim=c(0,1)</code>.
</p>
</td></tr>
<tr><td><code id="AR.Sim_+3A_s_x">S_X</code></td>
<td>

<p>The support of <code class="reqn">X</code> with default <code> S_X = xlim </code>, which is needed for calculating the optimum value of constant <code class="reqn">c</code>.
</p>
</td></tr>
<tr><td><code id="AR.Sim_+3A_rej.num">Rej.Num</code></td>
<td>

<p>A logical argument with default <code>TRUE</code> for calculate the number of rejections in <code>Accept-Reject method</code>. If <code>Rej.Num = FALSE</code>, then the number of rejections is not reported.
</p>
</td></tr>
<tr><td><code id="AR.Sim_+3A_rej.rate">Rej.Rate</code></td>
<td>

<p>A logical argument with default <code>TRUE</code> for calculate the ratio of rejections in <code>Accept-Reject method</code> (i.e. <code>Rej.Num / n</code>). If <code>Rej.Rate = FALSE</code>, then the ratio of rejections is not reported.
</p>
</td></tr>
<tr><td><code id="AR.Sim_+3A_acc.rate">Acc.Rate</code></td>
<td>

<p>A logical argument with default <code>TRUE</code> for calculate the ratio of acceptances in <code>Accept-Reject method</code> (i.e. <code> 1 - Rej.Rate </code>). If <code>Acc.Rate = FALSE</code>, then the ratio of acceptances is not reported.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of generated/simulated data from random variable <code class="reqn">X</code> with length <code class="reqn">n</code>.
</p>
<p>Optimum value for <code class="reqn">c</code>, i.e. the minimum possible value for <code class="reqn">c</code>.
</p>


<h3>References</h3>

<p>Robert, C.P., Casella, G., Introducing Monte Carlo Methods with R, New York: Springer (2010).
</p>
<p>Wikipedia, the free encyclopedia, Rejection sampling, 
https://en.wikipedia.org/wiki/Rejection_sampling
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1: 
data = AR.Sim( n = 150, 
         f_X = function(y){dbeta(y,2.7,6.3)},
         Y.dist = "unif", Y.dist.par = c(0,1),
         Rej.Num = TRUE,
         Rej.Rate = TRUE,
         Acc.Rate = FALSE
         ) 

# QQ-plot
q &lt;- qbeta(ppoints(100), 2.7, 6.3)
qqplot(q, data, cex=0.6, xlab="Quantiles of Beta(2.7,6.3)", 
       ylab="Empirical Quantiles of simulated data")
abline(0, 1, col=2)


# ------------------------------------------------------
# Example 2: From Page 54 of (Robert and Casella, 2009)
f_X = function(x) dbeta(x,2.7,6.3)
Simulation1 &lt;- AR.Sim(n=300, f_X, Y.dist = "unif", Y.dist.par = c(0,1)) 
Simulation2 &lt;- AR.Sim(n=2000, f_X, Y.dist="beta", Y.dist.par=c(2,6) ) 
Simulation3 &lt;- AR.Sim(n=1000, f_X, Y.dist="beta", Y.dist.par=c(1.5,3.7) ) 
Simulation4 &lt;- AR.Sim(n=250, f_X, Y.dist="norm", Y.dist.par=c(.5,.2) ) 
Simulation5 &lt;- AR.Sim(n=200,  f_X, Y.dist="exp", Y.dist.par=3 ) 
Simulation6 &lt;- AR.Sim( 400 ,  f_X, Y.dist="gamma", Y.dist.par=c(2,5) ) 

hist(Simulation1, prob=TRUE)#, col="gray20")
hist(Simulation2, prob=TRUE, add=TRUE, col="gray35")
hist(Simulation3, prob=TRUE, add=TRUE, col="gray60")
hist(Simulation4, prob=TRUE, add=TRUE, col="gray75")
hist(Simulation5, prob=TRUE, add=TRUE, col="gray85")
hist(Simulation6, prob=TRUE, add=TRUE, col="gray100")
curve(f_X(x), add=TRUE, col=2, lty=2, lwd=3)

#compare empirical and theoretical percentiles:
p &lt;- seq(.1, .9, .1)
Qhat1 &lt;- quantile(Simulation1, p) #Empirical quantiles of simulated sample 
Qhat2 &lt;- quantile(Simulation2, p) #Empirical quantiles of simulated sample 
Qhat3 &lt;- quantile(Simulation3, p) #Empirical quantiles of simulated sample 
Qhat4 &lt;- quantile(Simulation4, p) #Empirical quantiles of simulated sample 
Qhat5 &lt;- quantile(Simulation5, p) #Empirical quantiles of simulated sample 
Qhat6 &lt;- quantile(Simulation6, p) #Empirical quantiles of simulated sample 
Q &lt;- qbeta(p, 2.7, 6.3)    #Theoretical quantiles of Be(2.7,6.3)
round( rbind(Q, Qhat1, Qhat2, Qhat3, Qhat4, Qhat5, Qhat6), 3)

# Compute p-value of Kolmogorov-Smirnov test:
ks.test(Simulation1, "pbeta", 2.7, 6.3)$p.value
ks.test(Simulation2, "pbeta", 2.7, 6.3)$p.value
ks.test(Simulation3, "pbeta", 2.7, 6.3)$p.value
ks.test(Simulation4, "pbeta", 2.7, 6.3)$p.value
ks.test(Simulation5, "pbeta", 2.7, 6.3)$p.value
ks.test(Simulation6, "pbeta", 2.7, 6.3)$p.value


# ------------------------------------------------------
# Example 3: Simulate Truncated N(5,2^2) at l=3 and r=14 in left and rigth sides, respectively. 

mu = 5
sigma = 2
l = 3
r = 14
n = 400
f_X = function(x)  dnorm(x,mu,sigma) * 
                   as.integer(l&lt;x &amp; x&lt;r) / (pnorm(r,mu,sigma)-pnorm(l,mu,sigma)) 

Sim1 &lt;- AR.Sim(n, f_X, S_X=c(l,r), Y.dist="norm", Y.dist.par=c(5,4), xlim=c(l-1,r+1) ) 
head(Sim1, 15)
hist(Sim1, prob=TRUE, col="lightgreen")
curve(f_X(x), add=TRUE, col=2, lty=2, lwd=3) # Truncated pdf of N(5,2^2) at l and r
c2 = 1 / (pnorm(r,mu,sigma)-pnorm(l,mu,sigma)) ; c2 #See page 15 jozve

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
