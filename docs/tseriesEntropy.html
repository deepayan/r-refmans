<!DOCTYPE html><html><head><title>Help for package tseriesEntropy</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tseriesEntropy}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Srho'><p>Entropy Measure Of Serial And Cross Dependence</p></a></li>
<li><a href='#Srho-class'><p>Class &quot;Srho&quot;</p></a></li>
<li><a href='#Srho.test'><p>Entropy Test For Serial And Cross Dependence For Categorical Sequences</p></a></li>
<li><a href='#Srho.test-class'><p>Class &quot;Srho.test&quot;</p></a></li>
<li><a href='#Srho.test.AR.p'><p>Entropy Tests For Nonlinearity In Time Series - Parallel Version</p></a></li>
<li><a href='#Srho.test.ts.p'><p>Entropy Tests Of Serial And Cross Dependence For Time Series</p></a></li>
<li><a href='#Srho.ts'><p>Entropy Measure Of Serial And Cross Dependence</p></a></li>
<li><a href='#Srho.ts-class'><p>Class &quot;Srho.ts&quot;</p></a></li>
<li><a href='#surrogate.AR'><p>Surrogate Time Series Through AR Modeling (Sieve Bootstrap)</p></a></li>
<li><a href='#surrogate.ARs'><p>Surrogate Time Series Through A Modeling (Smoothed Sieve Bootstrap)</p></a></li>
<li><a href='#surrogate.SA'><p>Surrogate Time Series Through Simulated Annealing</p></a></li>
<li><a href='#Trho.test.AR.p'><p>Entropy Tests For Nonlinearity In Time Series - Parallel Version</p></a></li>
<li><a href='#Trho.test.SA.p'><p>Entropy Tests For Nonlinearity In Time Series - Parallel Version</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Entropy Based Analysis and Tests for Time Series</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7-2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.14.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cubature, methods, parallel, stats, graphics, ks</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements an Entropy measure of dependence based on the Bhattacharya-Hellinger-Matusita distance. Can be used as a (nonlinear) autocorrelation/crosscorrelation function for continuous and categorical time series. The package includes tests for serial and cross dependence and nonlinearity based on it. Some routines have a parallel version that can be used in a multicore/cluster environment. The package makes use of S4 classes.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Simone Giannerini &lt;simone.giannerini@unibo.it&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-09 15:00:11 UTC; simone.giannerini2</td>
</tr>
<tr>
<td>Author:</td>
<td>Simone Giannerini <a href="https://orcid.org/0000-0002-0710-668X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-09 20:40:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='Srho'>Entropy Measure Of Serial And Cross Dependence</h2><span id='topic+Srho'></span>

<h3>Description</h3>

<p>Entropy based measure of serial and cross dependence for integer or categorical data. Implements a normalized version
of the Hellinger/Matusita distance. As shown in the references the metric measure is a proper distance.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Srho(x, y, lag.max, stationary = TRUE, plot = TRUE, version = c("FORTRAN","R"),
 nor = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Srho_+3A_x">x</code>, <code id="Srho_+3A_y">y</code></td>
<td>
<p>integer or factor time series objects or vectors. (<code>y</code> is missing in the univariate case).</p>
</td></tr>
<tr><td><code id="Srho_+3A_lag.max">lag.max</code></td>
<td>
<p>maximum lag at which to calculate Srho; default is <code>round(N/4)</code> where N is the number of observations.</p>
</td></tr>
<tr><td><code id="Srho_+3A_stationary">stationary</code></td>
<td>
<p>logical. If <code>TRUE</code> assumes stationarity and computes marginal probabilities by using N observations. If <code>FALSE</code> uses N-k observations where k is the lag.</p>
</td></tr>
<tr><td><code id="Srho_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code> (the default) Srho is plotted.</p>
</td></tr>
<tr><td><code id="Srho_+3A_version">version</code></td>
<td>
<p>either <code>"FORTRAN"</code> or <code>"R"</code>. <code>FORTRAN</code> version is the default and is preferred over the pure <code>R</code> version which is considerably slower but is included in case of portability issues.</p>
</td></tr>
<tr><td><code id="Srho_+3A_nor">nor</code></td>
<td>
<p>logical. If <code>TRUE</code> normalizes Srho with respect to its attainable maximum. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>Univariate version: serial entropy</dt><dd><pre>Srho(x, lag.max,
stationary = TRUE, plot = TRUE, version = c("FORTRAN","R"), nor = FALSE)</pre></dd>
<dt>Bivariate version: cross entropy</dt><dd><pre>Srho(x, y, lag.max,
stationary = TRUE, plot = TRUE, version = c("FORTRAN","R"), nor = FALSE)</pre></dd></dl>

<p>This implementation of the measure is normalized to take values in [0, 1]. Normalization is
performed with respect to the maximum attainable value computed analytically.
This makes the results of Srho comparable among different series.</p>


<h3>Value</h3>

<p>An object of S4 class &quot;Srho&quot;, which is a list with the following elements:
</p>
<table>
<tr><td><code>.Data</code></td>
<td>
<p> vector of <code>lag.max</code> elements containing Srho computed at each lag.</p>
</td></tr>
<tr><td><code>lags</code></td>
<td>
<p>integer vector that contains the lags at which Srho is computed.</p>
</td></tr>
<tr><td><code>stationary</code></td>
<td>
<p>Object of class <code>"logical"</code>:  <code>TRUE</code> if the stationary version is computed.</p>
</td></tr>
<tr><td><code>data.type</code></td>
<td>
<p>Object of class <code>"character"</code>: contains the data type.</p>
</td></tr>
<tr><td><code>notes</code></td>
<td>
<p>Object of class <code>"character"</code>: additional notes.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>Unlike <code>ccf</code> the lag k value returned by <code>Srho(x,y)</code> estimates Srho between <code>x[t]</code> and <code>y[t+k]</code>.
The result is returned invisibly if plot is TRUE.
</p>


<h3>Author(s)</h3>

<p>Simone Giannerini&lt;simone.giannerini@unibo.it&gt;</p>


<h3>References</h3>

<p>Granger C. W. J., Maasoumi E., Racine J., (2004) A dependence metric for possibly nonlinear processes.
<em>Journal of Time Series Analysis</em>, <b>25(5)</b>, 649&ndash;669.
</p>
<p>Giannerini S., Maasoumi E., Bee Dagum E., (2015), Entropy testing
for nonlinear serial dependence in time series, <em>Biometrika</em>, <b>102(3)</b>, 661&ndash;675
<a href="https://doi.org/10.1093/biomet/asv007">doi:10.1093/biomet/asv007</a>.
</p>
<p>Maasoumi E., (1993) A compendium to information theory in economics and econometrics.
<em>Econometric Reviews</em>, <b>12(2)</b>, 137&ndash;181.
</p>


<h3>See Also</h3>

<p>See Also <code><a href="#topic+Srho.test">Srho.test</a></code>. The function <code><a href="#topic+Srho.ts">Srho.ts</a></code> implements the same measure for numeric data.</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## UNIVARIATE VERSION
x &lt;- as.integer(rbinom(n=20,size=4,prob=0.5))
Srho(x,lag.max=4)

## BIVARIATE VERSION
y &lt;- as.integer(rbinom(n=20,size=4,prob=0.5))
Srho(x,y,lag.max=4)

## EXAMPLE  1: the effect of normalization
## computes the maximum attainable value by correlating x with itself

set.seed(12)
K    &lt;- 5           # number of categories
smax &lt;- 1-1/sqrt(K) # theoretical maximum under the uniform distribution
x    &lt;- as.integer(sample(1:K,size=1e3,replace=TRUE)) # generates the sequence
S    &lt;- Srho(x,x,lag.max=2,nor=FALSE,plot=FALSE)

plot(S,lwd=2,col=4)
abline(h=smax,col=2,lty=2)
text(x=-1,y=0.54,labels=paste("theoretical maximum = ",round(smax,4),sep=""),col=2)
text(x=-1,y=0.45,labels=paste("estimated maximum = ",round(S[3],4),sep=""),col=4)

</code></pre>

<hr>
<h2 id='Srho-class'>Class &quot;Srho&quot;</h2><span id='topic+Srho-class'></span><span id='topic+plot+2CSrho+2Cmissing-method'></span><span id='topic+show+2CSrho-method'></span>

<h3>Description</h3>

<p>A class for <code>Srho</code> and its extensions</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("Srho", ...)</code>.</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p>Object of class <code>"numeric"</code>: contains Srho computed on the data set.</p>
</dd>
<dt><code>lags</code>:</dt><dd><p>Object of class <code>"integer"</code>: contains the lags at which Srho is computed.</p>
</dd>
<dt><code>stationary</code>:</dt><dd><p>Object of class <code>"logical"</code>:  <code>TRUE</code> if the stationary version is computed.</p>
</dd>
<dt><code>data.type</code>:</dt><dd><p>Object of class <code>"character"</code>: contains the data type.</p>
</dd>
<dt><code>notes</code>:</dt><dd><p>Object of class <code>"character"</code>: additional notes.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>plot</dt><dd><p><code>signature(x = "Srho", y = "missing")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "Srho")</code>: ... </p>
</dd>
</dl>
 

<h3>Author(s)</h3>

<p>Simone Giannerini &lt;simone.giannerini@unibo.it&gt; </p>


<h3>See Also</h3>

<p>See Also <code><a href="#topic+Srho.test-class">Srho.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("Srho")
</code></pre>

<hr>
<h2 id='Srho.test'>Entropy Test For Serial And Cross Dependence For Categorical Sequences</h2><span id='topic+Srho.test'></span>

<h3>Description</h3>

<p>Bootstrap/permutation tests of serial and cross dependence for integer or categorical sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Srho.test(x, y, lag.max=10, B = 1000, stationary = TRUE, plot = TRUE,
quant = c(0.95, 0.99), nor = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Srho.test_+3A_x">x</code>, <code id="Srho.test_+3A_y">y</code></td>
<td>
<p>integer or factor time series objects or vectors. (<code>y</code> is missing in the univariate case).</p>
</td></tr>
<tr><td><code id="Srho.test_+3A_lag.max">lag.max</code></td>
<td>
<p>maximum lag at which to calculate Srho; the default is 10.</p>
</td></tr>
<tr><td><code id="Srho.test_+3A_b">B</code></td>
<td>
<p>number of bootstrap/permutation replications.</p>
</td></tr>
<tr><td><code id="Srho.test_+3A_stationary">stationary</code></td>
<td>
<p>logical. If <code>TRUE</code> assumes stationarity and computes marginal probabilities by using all the N observations. If <code>FALSE</code> uses N-k observations where k is the lag.</p>
</td></tr>
<tr><td><code id="Srho.test_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code>(the default) produces a plot of Srho together with permutation confidence bands under the null hypothesis of independence.</p>
</td></tr>
<tr><td><code id="Srho.test_+3A_quant">quant</code></td>
<td>
<p>quantiles to be specified for the computation of the significant lags and the plot of confidence bands. Up to 2 quantiles can be specified.
Defaults are 95% and 99%.</p>
</td></tr>
<tr><td><code id="Srho.test_+3A_nor">nor</code></td>
<td>
<p>logical. If <code>TRUE</code> normalizes Srho with respect to its attainable maximum. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>Univariate version: test for serial dependence</dt><dd><pre>Srho.test(x, lag.max, B = 1000,
stationary = TRUE, plot = TRUE, quant = c(0.95, 0.99), nor = FALSE)</pre></dd>
<dt>Bivariate version: test for cross dependence</dt><dd><pre>Srho.test(x, y, lag.max, B = 1000,
stationary = TRUE, plot = TRUE, quant = c(0.95, 0.99), nor = FALSE)</pre></dd>
</dl>



<h3>Value</h3>

<p>An object of class &quot;Srho.test&quot;, which is a list with the following elements:
</p>
<table>
<tr><td><code>.Data</code></td>
<td>
<p> vector of <code>lag.max</code> elements containing Srho computed at each lag.</p>
</td></tr>
<tr><td><code>quantiles</code></td>
<td>
<p>Object of class <code>"matrix"</code>: contains the quantiles of the bootstrap/permutation distribution under the null hypothesis.</p>
</td></tr>
<tr><td><code>test.type</code></td>
<td>
<p>Object of class <code>"character"</code>: contains a description of the type of test performed.</p>
</td></tr>
<tr><td><code>significant.lags</code></td>
<td>
<p>Object of class <code>"list"</code>: contains the lags at which Srho exceeds the confidence bands at <code>quant</code>% under the null hypothesis.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>Object of class <code>"numeric"</code>: contains the bootstrap p-value for each lag.</p>
</td></tr>
<tr><td><code>lags</code></td>
<td>
<p>integer vector that contains the lags at which Srho is computed.</p>
</td></tr>
<tr><td><code>stationary</code></td>
<td>
<p>Object of class <code>"logical"</code>:  <code>TRUE</code> if the stationary version is computed.</p>
</td></tr>
<tr><td><code>data.type</code></td>
<td>
<p>Object of class <code>"character"</code>: contains the data type.</p>
</td></tr>
<tr><td><code>notes</code></td>
<td>
<p>Object of class <code>"character"</code>: additional notes.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p> Unlike <code>ccf</code> the lag k value returned
by <code>Srho.test(x,y)</code> estimates Srho between <code>x[t]</code> and
<code>y[t+k]</code>. The result is returned invisibly if plot is
TRUE. </p>


<h3>Author(s)</h3>

<p>Simone Giannerini&lt;simone.giannerini@unibo.it&gt;</p>


<h3>References</h3>

<p>Granger C. W. J., Maasoumi E., Racine J., (2004) A dependence metric for possibly nonlinear processes.
<em>Journal of Time Series Analysis</em>, <b>25(5)</b>, 649&ndash;669.
</p>
<p>Maasoumi E., (1993) A compendium to information theory in economics and econometrics.
<em>Econometric Reviews</em>, <b>12(2)</b>, 137&ndash;181.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+Srho">Srho</a></code>, <code><a href="#topic+Srho.ts">Srho.ts</a></code>. The function <code><a href="#topic+Srho.test.ts">Srho.test.ts</a></code> implements the same test for numeric data.</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12)
x &lt;- as.integer(rbinom(n=30,size=4,prob=0.5))
y &lt;- as.integer(rbinom(n=30,size=4,prob=0.5))
z &lt;- as.integer(c(4,abs(x[-30]*2-2))-rbinom(n=30,size=1,prob=1/2))

# no dependence
Srho.test(x,lag.max=4)   # univariate
Srho.test(x,y,lag.max=4) # bivariate

# lag 1 dependence
Srho.test(x,z,lag.max=4) # bivariate
</code></pre>

<hr>
<h2 id='Srho.test-class'>Class &quot;Srho.test&quot;</h2><span id='topic+Srho.test-class'></span><span id='topic+plot+2CSrho.test+2Cmissing-method'></span><span id='topic+show+2CSrho.test-method'></span>

<h3>Description</h3>

<p>A class of tests for serial dependence and nonlinearity based upon <code>Srho</code>.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("Srho.test", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p>Object of class <code>"numeric"</code>: contains Srho computed on the data set.</p>
</dd>
<dt><code>call</code>:</dt><dd><p>Object of class <code>"call"</code>: contains the call to the routine.</p>
</dd>
<dt><code>call.h</code>:</dt><dd><p>Object of class <code>"call"</code>: contains the call to the routine used for obtaining the surrogates or the bootstrap replicates under the null hypothesis.</p>
</dd>
<dt><code>quantiles</code>:</dt><dd><p>Object of class <code>"matrix"</code>: contains the quantiles of the bootstrap/permutation distribution under the null hypothesis.</p>
</dd>
<dt><code>test.type</code>:</dt><dd><p>Object of class <code>"character"</code>: contains a description of the type of test performed.</p>
</dd>
<dt><code>significant.lags</code>:</dt><dd><p>Object of class <code>"list"</code>: contains the lags at which Srho exceeds the confidence bands at <code>quant</code> under the null hypothesis.</p>
</dd>
<dt><code>p.value</code>:</dt><dd><p>Object of class <code>"numeric"</code>: contains the bootstrap p-value for each lag.</p>
</dd>
<dt><code>lags</code>:</dt><dd><p>Object of class <code>"integer"</code>: contains the lags at which Srho is computed.</p>
</dd>
<dt><code>stationary</code>:</dt><dd><p><code>TRUE</code> if the stationary version is computed.</p>
</dd>
<dt><code>data.type</code>:</dt><dd><p>Object of class <code>"character"</code>: contains the data type.</p>
</dd>
<dt><code>notes</code>:</dt><dd><p>Object of class <code>"character"</code>: additional notes.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+Srho-class">Srho</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>plot</dt><dd><p><code>signature(x = "Srho.test", y = "missing")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "Srho.test")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Simone Giannerini &lt;simone.giannerini@unibo.it&gt; </p>


<h3>See Also</h3>

<p>See Also <code><a href="#topic+Srho-class">Srho</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("Srho.test")
</code></pre>

<hr>
<h2 id='Srho.test.AR.p'>Entropy Tests For Nonlinearity In Time Series - Parallel Version</h2><span id='topic+Srho.test.AR.p'></span><span id='topic+Srho.test.AR'></span>

<h3>Description</h3>

<p>Entropy test of nonlinearity for time series based
on <code><a href="#topic+Srho.ts">Srho.ts</a></code> and surrogate data obtained through
the sieve bootstrap. The parallel version requires <code>parallel</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Srho.test.AR(x, y, lag.max = 10, B = 100, plot = TRUE, quant = c(0.95, 0.99),
 bw = c("reference", "mlcv", "lscv", "scv", "pi"), bdiag=TRUE,
 method = c("integral", "summation"), tol = 0.001, order.max = NULL,
 fit.method=c("yule-walker", "burg", "ols", "mle", "yw"),  smoothed = TRUE ,...)

## Parallel version

Srho.test.AR.p(x, y, lag.max = 10, B = 100, plot = TRUE, quant = c(0.95, 0.99),
 bw = c("reference", "mlcv", "lscv", "scv", "pi"), bdiag=TRUE,
 method = c("integral", "summation"), tol = 0.001, order.max = NULL,
 fit.method=c("yule-walker", "burg", "ols", "mle", "yw"),  smoothed = TRUE,
 nwork=detectCores(),...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Srho.test.AR.p_+3A_x">x</code>, <code id="Srho.test.AR.p_+3A_y">y</code></td>
<td>
<p>univariate numeric time series object or numeric vectors (<code>y</code> is missing in the univariate case).</p>
</td></tr>
<tr><td><code id="Srho.test.AR.p_+3A_lag.max">lag.max</code></td>
<td>
<p>maximum lag at which to calculate Srho; the default is 10.</p>
</td></tr>
<tr><td><code id="Srho.test.AR.p_+3A_b">B</code></td>
<td>
<p>number of surrogate time series.</p>
</td></tr>
<tr><td><code id="Srho.test.AR.p_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code> (the default) produces a plot of Srho together with confidence bands under the null hypothesis of linearity at 95% and 99%.</p>
</td></tr>
<tr><td><code id="Srho.test.AR.p_+3A_quant">quant</code></td>
<td>
<p>quantiles to be specified for the computation of the significant lags and the plot of confidence bands. Up to 2 quantiles can be specified.
Defaults are 95% and 99%.</p>
</td></tr>
<tr><td><code id="Srho.test.AR.p_+3A_bw">bw</code></td>
<td>
<p>see <code><a href="#topic+Srho.ts">Srho.ts</a></code>.</p>
</td></tr>
<tr><td><code id="Srho.test.AR.p_+3A_bdiag">bdiag</code></td>
<td>
<p>see <code><a href="#topic+Srho.ts">Srho.ts</a></code>.</p>
</td></tr>
<tr><td><code id="Srho.test.AR.p_+3A_method">method</code></td>
<td>
<p>see <code><a href="#topic+Srho.ts">Srho.ts</a></code>.</p>
</td></tr>
<tr><td><code id="Srho.test.AR.p_+3A_tol">tol</code></td>
<td>
<p>see <code><a href="#topic+Srho.ts">Srho.ts</a></code>.</p>
</td></tr>
<tr><td><code id="Srho.test.AR.p_+3A_order.max">order.max</code></td>
<td>
<p>see <code><a href="#topic+surrogate.ARs">surrogate.ARs</a></code>.</p>
</td></tr>
<tr><td><code id="Srho.test.AR.p_+3A_fit.method">fit.method</code></td>
<td>
<p>see <code><a href="#topic+surrogate.ARs">surrogate.ARs</a></code>.</p>
</td></tr>
<tr><td><code id="Srho.test.AR.p_+3A_smoothed">smoothed</code></td>
<td>
<p>logical. If <code>TRUE</code> (the default) uses the smoothed sieve bootstrap in <code><a href="#topic+surrogate.ARs">surrogate.ARs</a></code> to generate surrogates. Otherwise uses the classic sieve by calling <code><a href="#topic+surrogate.AR">surrogate.AR</a></code>.</p>
</td></tr>
<tr><td><code id="Srho.test.AR.p_+3A_nwork">nwork</code></td>
<td>
<p>number of workers/processes to be used in parallel environments.</p>
</td></tr>
<tr><td><code id="Srho.test.AR.p_+3A_...">...</code></td>
<td>
<p>further arguments, typically passed to <code><a href="cubature.html#topic+hcubature">hcubature</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each lag from 1 to <code>lag.max</code> <code>Srho.test.AR</code> computes a test for nonlinearity for time series based
on <code><a href="#topic+Srho.ts">Srho.ts</a></code>. The distribution under the null hypothesis of linearity is obtained through the sieve bootstrap.
The routine requires the package parallel to spawn multiple workers.
</p>


<h3>Value</h3>

<p>An object of class &quot;Srho.test&quot;, which is a list with the following elements:
</p>
<table>
<tr><td><code>.Data</code></td>
<td>
<p> vector of <code>lag.max</code> elements containing Srho computed at each lag.</p>
</td></tr>
<tr><td><code>call:</code></td>
<td>
<p>Object of class <code>"call"</code>: contains the call to the routine.</p>
</td></tr>
<tr><td><code>call.h:</code></td>
<td>
<p>Object of class <code>"call"</code>: contains the call to the routine used for obtaining the surrogates or the bootstrap replicates under the null hypothesis</p>
</td></tr>
<tr><td><code>quantiles</code></td>
<td>
<p>Object of class <code>"matrix"</code>: contains the quantiles of the surrogate distribution under the null hypothesis.</p>
</td></tr>
<tr><td><code>test.type</code></td>
<td>
<p>Object of class <code>"character"</code>: contains a description of the type of test performed.</p>
</td></tr>
<tr><td><code>significant.lags</code></td>
<td>
<p>Object of class <code>"list"</code>: contains the lags at which Srho exceeds the confidence bands at <code>quant</code>% under the null hypothesis.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>Object of class <code>"numeric"</code>: contains the bootstrap p-value for each lag.</p>
</td></tr>
<tr><td><code>lags</code></td>
<td>
<p>integer vector that contains the lags at which Srho is computed.</p>
</td></tr>
<tr><td><code>stationary</code></td>
<td>
<p>Object of class <code>"logical"</code>:  <code>TRUE</code> if the stationary version is computed. Set to <code>FALSE</code> by default as only the non-stationary version is implemented.</p>
</td></tr>
<tr><td><code>data.type</code></td>
<td>
<p>Object of class <code>"character"</code>: contains the data type.</p>
</td></tr>
<tr><td><code>notes</code></td>
<td>
<p>Object of class <code>"character"</code>: additional notes.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Simone Giannerini&lt;simone.giannerini@unibo.it&gt;</p>


<h3>References</h3>

<p>Giannerini S., Maasoumi E., Bee Dagum E., (2015), Entropy testing
for nonlinear serial dependence in time series, <em>Biometrika</em>, <b>102(3)</b>, 661&ndash;675
<a href="https://doi.org/10.1093/biomet/asv007">doi:10.1093/biomet/asv007</a>.
</p>


<h3>See Also</h3>

<p>See Also <code><a href="#topic+Srho.ts">Srho.ts</a></code>, <code><a href="#topic+surrogate.AR">surrogate.AR</a></code>, <code><a href="#topic+surrogate.ARs">surrogate.ARs</a></code>, <code><a href="#topic+Srho.test.AR">Srho.test.AR</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## ************************************************************
## WARNING: computationally intensive, increase B with caution
## ************************************************************

# modify nwork to match the number of available cores
set.seed(13)
x      &lt;- arima.sim(n=120, model = list(ar=0.8));
result &lt;- Srho.test.AR.p(x, lag.max = 5,  B = 100, bw='reference', method='integral', nwork=2)

## ** Compare timings **
system.time(Srho.test.AR.p(x, lag.max = 5,  B = 100, bw='reference', method='integral', nwork=4))
system.time(Srho.test.AR(x, lag.max = 5,  B = 100, bw='reference', method='integral'))

## End(Not run)</code></pre>

<hr>
<h2 id='Srho.test.ts.p'>Entropy Tests Of Serial And Cross Dependence For Time Series</h2><span id='topic+Srho.test.ts.p'></span><span id='topic+Srho.test.ts'></span>

<h3>Description</h3>

<p>Entropy test of serial and cross dependence for numeric time series (continuous state space) based on
<code><a href="#topic+Srho.ts">Srho.ts</a></code>. The distribution under the null hypothesis of independence is obtained by means of bootstrap/permutations methods (see <code>ci.type</code>). The parallel version requires <code>parallel</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Srho.test.ts(x, y, lag.max = 10,  B = 100, plot = TRUE, quant = c(0.95, 0.99),
 bw = c("reference","mlcv", "lscv", "scv", "pi"), bdiag=TRUE,
 method =c("integral","summation"), tol=1e-03, ci.type = c("mbb","perm"),...)

## Parallel version  
Srho.test.ts.p(x, y, lag.max = 10,  B = 100, plot = TRUE, quant = c(0.95, 0.99),
 bw = c("reference","mlcv", "lscv", "scv", "pi"), bdiag=TRUE,
 method =c("integral","summation"), tol=1e-03, ci.type = c("mbb","perm"), 
 nwork=detectCores(),...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Srho.test.ts.p_+3A_x">x</code>, <code id="Srho.test.ts.p_+3A_y">y</code></td>
<td>
<p>univariate numeric time series object or numeric vectors (<code>y</code> is missing in the univariate case).</p>
</td></tr>
<tr><td><code id="Srho.test.ts.p_+3A_lag.max">lag.max</code></td>
<td>
<p>maximum lag at which to calculate Srho; the default is 10.</p>
</td></tr>
<tr><td><code id="Srho.test.ts.p_+3A_b">B</code></td>
<td>
<p>number of bootstrap/permutation replications.</p>
</td></tr>
<tr><td><code id="Srho.test.ts.p_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code>(the default) produces a plot of Srho together with confidence bands under the null hypothesis at
levels set by <code>quant</code>.</p>
</td></tr>
<tr><td><code id="Srho.test.ts.p_+3A_quant">quant</code></td>
<td>
<p>quantiles to be specified for the computation of the significant lags and the plot of confidence bands. Up to 2 quantiles can be specified.
Defaults are 95% and 99%.</p>
</td></tr>
<tr><td><code id="Srho.test.ts.p_+3A_bw">bw</code></td>
<td>
<p>see <code><a href="#topic+Srho.ts">Srho.ts</a></code>.</p>
</td></tr>
<tr><td><code id="Srho.test.ts.p_+3A_bdiag">bdiag</code></td>
<td>
<p>see <code><a href="#topic+Srho.ts">Srho.ts</a></code>.</p>
</td></tr>
<tr><td><code id="Srho.test.ts.p_+3A_method">method</code></td>
<td>
<p>see <code><a href="#topic+Srho.ts">Srho.ts</a></code>.</p>
</td></tr>
<tr><td><code id="Srho.test.ts.p_+3A_tol">tol</code></td>
<td>
<p>see <code><a href="#topic+Srho.ts">Srho.ts</a></code>.</p>
</td></tr>
<tr><td><code id="Srho.test.ts.p_+3A_ci.type">ci.type</code></td>
<td>
<p>confidence interval type. determines how the distribution under the null hypothesis is obtained. <code>mbb</code> uses a moving block bootstrap with block length equal to <code>blag</code>, which is equal to <code>lag.max</code> by default. The option <code>perm</code> uses permutation methods (each resampled series is a random permutation of the original series).
The option <code>mbb</code> makes sense only in the bivariate case for which is the default.</p>
</td></tr>
<tr><td><code id="Srho.test.ts.p_+3A_nwork">nwork</code></td>
<td>
<p>number of workers/processes to be used in parallel environments.</p>
</td></tr>
<tr><td><code id="Srho.test.ts.p_+3A_...">...</code></td>
<td>
<p>further arguments, typically, the MBB block length <code>blag</code> or the arguments passed to <code><a href="cubature.html#topic+hcubature">hcubature</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>Univariate version: test for serial dependence</dt><dd><pre>Srho.test.ts.p(x, lag.max = 10,
B = 100, plot = TRUE, quant = c(0.95, 0.99), bdiag=TRUE,
bw = c("reference", "mlcv", "lscv", "scv", "pi"), method =c("integral","summation"), 
tol=1e-03, ci.type = c("perm"), nwork=detectCores())</pre></dd>
<dt>Bivariate version: test for cross dependence</dt><dd><pre>Srho.test.ts.p(x, y, lag.max = 10,
B = 100, plot = TRUE, quant = c(0.95, 0.99), bdiag=TRUE, 
bw = c("reference", "mlcv", "lscv", "scv", "pi"), method =c("integral","summation"), 
tol=1e-03, ci.type = c("mbb","perm"), nwork=detectCores())</pre></dd>
</dl>

<p>For each lag from 1 to <code>lag.max</code> (serial dependence) or from <code>-lag.max</code> to <code>lag.max</code> (cross dependence) <code>Srho.test.ts</code> computes a test for serial/cross dependence for time series based on <code><a href="#topic+Srho.ts">Srho.ts</a></code>. The distribution under the null hypothesis of independence is obtained through either permutation or bootstrap methods. If the option <code>mbb</code> is chosen (bivariate case only) the resampled series use a moving block bootstrap to acccount for the serial dependence of the original series so that the test will have better size than the permutation version.
</p>


<h3>Value</h3>

<p>An object of class &quot;Srho.test&quot;, which is a list with the following elements:
</p>
<table>
<tr><td><code>.Data</code></td>
<td>
<p> vector containing Srho computed at each lag.</p>
</td></tr>
<tr><td><code>call:</code></td>
<td>
<p>Object of class <code>"call"</code>: contains the call to the routine.</p>
</td></tr>
<tr><td><code>call.h:</code></td>
<td>
<p>Object of class <code>"call"</code>: contains the call to the routine used for obtaining the surrogates or the bootstrap replicates under the null hypothesis.</p>
</td></tr>
<tr><td><code>quantiles</code></td>
<td>
<p>Object of class <code>"matrix"</code>: contains the quantiles of the distribution under the null hypothesis.</p>
</td></tr>
<tr><td><code>test.type</code></td>
<td>
<p>Object of class <code>"character"</code>: contains a description of the type of test performed.</p>
</td></tr>
<tr><td><code>significant.lags</code></td>
<td>
<p>Object of class <code>"list"</code>: contains the lags at which Srho exceeds the confidence bands at <code>quant</code>% under the null hypothesis.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>Object of class <code>"numeric"</code>: contains the bootstrap p-value for each lag.</p>
</td></tr>
<tr><td><code>lags</code></td>
<td>
<p>integer vector that contains the lags at which Srho is computed.</p>
</td></tr>
<tr><td><code>stationary</code></td>
<td>
<p>Object of class <code>"logical"</code>:  <code>TRUE</code> if the stationary version is computed. Set to <code>FALSE</code> by default as only the non-stationary version is implemented.</p>
</td></tr>
<tr><td><code>data.type</code></td>
<td>
<p>Object of class <code>"character"</code>: contains the data type.</p>
</td></tr>
<tr><td><code>notes</code></td>
<td>
<p>Object of class <code>"character"</code>: additional notes.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Simone Giannerini&lt;simone.giannerini@unibo.it&gt;</p>


<h3>References</h3>

<p>Granger C. W. J., Maasoumi E., Racine J., (2004) A dependence metric for possibly nonlinear processes.
<em>Journal of Time Series Analysis</em>, <b>25(5)</b>, 649&ndash;669.
</p>
<p>Maasoumi E., (1993) A compendium to information theory in economics and econometrics.
<em>Econometric Reviews</em>, <b>12(2)</b>, 137&ndash;181.
</p>


<h3>See Also</h3>

<p>See Also <code><a href="#topic+Srho.test.ts">Srho.test.ts</a></code> and <code><a href="#topic+Srho.ts">Srho.ts</a></code>. 
The function <code><a href="#topic+Srho.test">Srho.test</a></code> implements the same test for integer/categorical data. 
For a test for nonlinear serial dependence see <code><a href="#topic+Srho.test.AR">Srho.test.AR</a></code>, 
<code><a href="#topic+Trho.test.AR">Trho.test.AR</a></code>, <code><a href="#topic+Trho.test.SA">Trho.test.SA</a></code>, together with their parallel 
versions: <code><a href="#topic+Srho.test.AR.p">Srho.test.AR.p</a></code>, <code><a href="#topic+Trho.test.AR">Trho.test.AR</a></code>, <code><a href="#topic+Trho.test.SA">Trho.test.SA</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## ************************************************************
## WARNING: computationally intensive, increase B with caution
## ************************************************************
set.seed(13)
n      &lt;- 120
w      &lt;- rnorm(n)
x      &lt;- arima.sim(n, model = list(ar=0.8));
y      &lt;- arima.sim(n, model = list(ar=0.8));
z      &lt;- lag(x,-1) + rnorm(n,sd=2) # dependence at lag 1

# UNIVARIATE VERSION
res1 &lt;- Srho.test.ts.p(w, lag.max = 5,  B = 40, ci.type="perm") # independence
res2 &lt;- Srho.test.ts.p(x, lag.max = 5,  B = 40, ci.type="perm") # dependence

# BIVARIATE VERSION
res3 &lt;- Srho.test.ts.p(x, y, lag.max = 5,  B = 40, ci.type="mbb") # independence
res4 &lt;- Srho.test.ts.p(x, z, lag.max = 5,  B = 40, ci.type="mbb") # dependence

## End(Not run)</code></pre>

<hr>
<h2 id='Srho.ts'>Entropy Measure Of Serial And Cross Dependence</h2><span id='topic+Srho.ts'></span>

<h3>Description</h3>

<p>Entropy based measure of serial and cross dependence for continuous data. For integer/categorical data see <code><a href="#topic+Srho">Srho</a></code>.
Implements a normalized version of the Hellinger/Matusita distance. As shown in the references the metric measure is a proper distance.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Srho.ts(x, y, lag.max = 10, bw = c("reference", "mlcv", "lscv", "scv", "pi"),
bdiag=TRUE, method = c("integral", "summation"), plot = TRUE, tol = 0.001, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Srho.ts_+3A_x">x</code>, <code id="Srho.ts_+3A_y">y</code></td>
<td>
<p>univariate numeric time series object or numeric vectors (<code>y</code> is missing in the univariate case).</p>
</td></tr>
<tr><td><code id="Srho.ts_+3A_lag.max">lag.max</code></td>
<td>
<p>maximum lag at which to calculate Srho; default is 10</p>
</td></tr>
<tr><td><code id="Srho.ts_+3A_bw">bw</code></td>
<td>
<p>Object of class <code>"character"</code>: bandwidth selection method, can be <code>"reference"</code>, <code>"mlcv"</code>, <code>"lscv"</code>, <code>"scv"</code>, <code>"pi"</code>.</p>
</td></tr>
<tr><td><code id="Srho.ts_+3A_bdiag">bdiag</code></td>
<td>
<p>Object of class <code>"logical"</code>: if <code>TRUE</code> uses the diagonal version of the bandwidth selectors <code>lscv</code>, <code>scv</code>, <code>pi</code>.</p>
</td></tr>
<tr><td><code id="Srho.ts_+3A_method">method</code></td>
<td>
<p>Object of class <code>"character"</code>: computation method, can be <code>"integral"</code> or <code>"summation"</code>.</p>
</td></tr>
<tr><td><code id="Srho.ts_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code> (the default) Srho is plotted.</p>
</td></tr>
<tr><td><code id="Srho.ts_+3A_tol">tol</code></td>
<td>
<p>max. tolerance, passed to <code><a href="cubature.html#topic+hcubature">hcubature</a></code>.</p>
</td></tr>
<tr><td><code id="Srho.ts_+3A_...">...</code></td>
<td>
<p>further arguments, typically passed to <code><a href="cubature.html#topic+hcubature">hcubature</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>Univariate version: serial entropy</dt><dd><pre>Srho.ts(x, lag.max = 10,
 bw = c("reference", "mlcv", "lscv", "scv", "pi"), bdiag=TRUE,
 method = c("integral", "summation"), plot = TRUE, tol = 0.001)</pre></dd>
<dt>Bivariate version: cross entropy</dt><dd><pre>Srho.ts(x, y, lag.max = 10,
 bw = c("reference", "mlcv", "lscv", "scv", "pi"), bdiag=TRUE,
 method = c("integral", "summation"), plot = TRUE, tol = 0.001)</pre></dd>
</dl>

<p>The bandwidth selection methods are the following:
</p>

<dl>
<dt><code>reference</code>:</dt><dd><p>reference criterion.</p>
</dd>
<dt><code>mlcv</code>:</dt><dd><p>maximum likelihood cross-validation.</p>
</dd>
<dt><code>lscv</code>:</dt><dd><p>least-squares cross-validation, see <code><a href="ks.html#topic+Hlscv">Hlscv</a></code>.</p>
</dd>
<dt><code>scv</code>:</dt><dd><p>smoothed cross-validation, see <code><a href="ks.html#topic+Hscv">Hscv</a></code></p>
</dd>
<dt><code>pi</code>:</dt><dd><p>plugin, see <code><a href="ks.html#topic+Hpi">Hpi</a></code></p>
</dd>
</dl>

<p>If <code>bdiag = TRUE</code> (the default), the diagonal bandwidth selectors <code>Hlscv.diag</code>,
<code>Hscv.diag</code>, <code>Hpi.diag</code> are used.
</p>


<h3>Value</h3>

<p>An object of class &quot;Srho.ts&quot;, with the following slots:
</p>
<table>
<tr><td><code>.Data</code></td>
<td>
<p>Object of class <code>"numeric"</code>: contains Srho computed on the data set.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Object of class <code>"character"</code>: computation method</p>
</td></tr>
<tr><td><code>bandwidth</code></td>
<td>
<p>Object of class <code>"character"</code>: bandwidth selection method.</p>
</td></tr>
<tr><td><code>lags</code></td>
<td>
<p>Object of class <code>"integer"</code>: contains the lags at which Srho is computed.</p>
</td></tr>
<tr><td><code>stationary</code></td>
<td>
<p>Object of class <code>"logical"</code>:  <code>TRUE</code> if the stationary version is computed.</p>
</td></tr>
<tr><td><code>data.type</code></td>
<td>
<p>Object of class <code>"character"</code>: contains the data type.</p>
</td></tr>
<tr><td><code>notes</code></td>
<td>
<p>Object of class <code>"character"</code>: additional notes.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Simone Giannerini&lt;simone.giannerini@unibo.it&gt;</p>


<h3>References</h3>

<p>Granger C. W. J., Maasoumi E., Racine J., (2004) A dependence metric for possibly nonlinear processes.
<em>Journal of Time Series Analysis</em>, <b>25(5)</b>, 649&ndash;669.
</p>
<p>Maasoumi E., (1993) A compendium to information theory in economics and econometrics.
<em>Econometric Reviews</em>, <b>12(2)</b>, 137&ndash;181.
</p>
<p>Giannerini S., Maasoumi E., Bee Dagum E., (2015), Entropy testing
for nonlinear serial dependence in time series, <em>Biometrika</em>, <b>102(3)</b>, 661&ndash;675
<a href="https://doi.org/10.1093/biomet/asv007">doi:10.1093/biomet/asv007</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Srho.test.ts">Srho.test.ts</a></code>, <code><a href="cubature.html#topic+hcubature">hcubature</a></code>, <code><a href="ks.html#topic+ks">ks</a></code>.
The function <code><a href="#topic+Srho">Srho</a></code> implements the same measure for integer/categorical data.</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(11)
x &lt;- arima.sim(list(order = c(1,0,0), ar = 0.8), n = 50)
S &lt;- Srho.ts(x,lag.max=5,method="integral",bw="mlcv")

# creates a nonlinear dependence at lag 1
y &lt;- c(runif(1),x[-50]^2*0.8-0.3)
S &lt;- Srho.ts(x,y,lag.max=3,method="integral",bw="mlcv")
</code></pre>

<hr>
<h2 id='Srho.ts-class'>Class &quot;Srho.ts&quot;</h2><span id='topic+Srho.ts-class'></span><span id='topic+show+2CSrho.ts-method'></span>

<h3>Description</h3>

<p>A class for <code>Srho</code> for continuous data/time series.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("Srho.ts", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p>Object of class <code>"numeric"</code>: contains Srho computed on the data set.</p>
</dd>
<dt><code>method</code>:</dt><dd><p>Object of class <code>"character"</code>: computation method, can be &quot;integral&quot; or &quot;summation&quot;.</p>
</dd>
<dt><code>bandwidth</code>:</dt><dd><p>Object of class <code>"character"</code>: bandwidth selection method.</p>
</dd>
<dt><code>lags</code>:</dt><dd><p>Object of class <code>"integer"</code>: contains the lags at which Srho is computed.</p>
</dd>
<dt><code>stationary</code>:</dt><dd><p>Object of class <code>"logical"</code>:  <code>TRUE</code> if the stationary version is computed.</p>
</dd>
<dt><code>data.type</code>:</dt><dd><p>Object of class <code>"character"</code>: contains the data type.</p>
</dd>
<dt><code>notes</code>:</dt><dd><p>Object of class <code>"character"</code>: additional notes.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+Srho-class">Srho</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "Srho.ts")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Simone Giannerini&lt;simone.giannerini@unibo.it&gt;</p>


<h3>See Also</h3>

<p>See Also <code><a href="#topic+Srho.test-class">Srho.test</a></code>, <code><a href="#topic+Srho-class">Srho</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("Srho.ts")
</code></pre>

<hr>
<h2 id='surrogate.AR'>Surrogate Time Series Through AR Modeling (Sieve Bootstrap)</h2><span id='topic+surrogate.AR'></span>

<h3>Description</h3>

<p>Starting from a time series <code>x</code> given as input, the function generates surrogate series by means of the sieve bootstrap.
The surrogates can be used for testing for non linearity in time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surrogate.AR(x, order.max = NULL, fit.method = c("yule-walker",
 "burg", "ols", "mle", "yw"), nsurr) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surrogate.AR_+3A_x">x</code></td>
<td>
<p>a univariate numeric time series object or a numeric vector.</p>
</td></tr>
<tr><td><code id="surrogate.AR_+3A_order.max">order.max</code></td>
<td>
<p>maximum order of the AR model to fit. Passed to <code><a href="stats.html#topic+ar">ar</a></code></p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="surrogate.AR_+3A_fit.method">fit.method</code></td>
<td>
<p>character string giving the method used to fit the AR model. It is passed to <code><a href="stats.html#topic+ar">ar</a></code> and
has to be one of the strings in the default argument (partial matching works). Defaults to &quot;yule-walker&quot;.</p>
</td></tr>
<tr><td><code id="surrogate.AR_+3A_nsurr">nsurr</code></td>
<td>
<p>number of surrogates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code>N</code> be the length of the series <code>x</code>. The best AR model is chosen by means of the AIC criterion. The residuals of the model are
resampled with replacement. Surrogate series are obtained by driving the fitted model with the resampled residuals.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>surr</code></td>
<td>
<p>a matrix with <code>N</code> rows and <code>nsurr</code> columns, in each column is stored a surrogate.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>contains the call to the routine.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Simone Giannerini&lt;simone.giannerini@unibo.it&gt;</p>


<h3>References</h3>

<p>Giannerini S., Maasoumi E., Bee Dagum E., (2015), Entropy testing
for nonlinear serial dependence in time series, <em>Biometrika</em>, <b>102(3)</b>, 661&ndash;675
<a href="https://doi.org/10.1093/biomet/asv007">doi:10.1093/biomet/asv007</a>.
</p>
<p>Buhlmann, P., (1997). Sieve bootstrap for time series.
<em>Bernoulli</em>, <b>3</b>, 123&ndash;148.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+surrogate.AR">surrogate.AR</a></code>, <code><a href="#topic+Trho.test.AR">Trho.test.AR</a></code>, <code><a href="#topic+surrogate.SA">surrogate.SA</a></code>, <code><a href="#topic+Trho.test.SA">Trho.test.SA</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1345)
# Generates a AR(1) series
x      &lt;- arima.sim(n=120, model = list(ar=0.8));
x.surr &lt;- surrogate.AR(x, nsurr=3);
plot.ts(x.surr$surr,col=4);


## Check that the surrogates have the same ACF of x
corig &lt;- acf(x,10,plot=FALSE)$acf[,,1];
csurr &lt;- acf(x.surr$surr[,1],10,plot=FALSE)$acf[,,1];
round(cbind(corig,csurr,"abs(difference)"=abs(corig-csurr)),3)
</code></pre>

<hr>
<h2 id='surrogate.ARs'>Surrogate Time Series Through A Modeling (Smoothed Sieve Bootstrap)</h2><span id='topic+surrogate.ARs'></span>

<h3>Description</h3>

<p>Starting from a time series <code>x</code> given as input, the function generates surrogate series by means of the smoothed sieve bootstrap.
The surrogates can be used for testing for non linearity in time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surrogate.ARs(x, order.max = NULL,
 fit.method = c("yule-walker","burg", "ols", "mle", "yw"), nsurr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surrogate.ARs_+3A_x">x</code></td>
<td>
<p>a univariate numeric time series object or a numeric vector.</p>
</td></tr>
<tr><td><code id="surrogate.ARs_+3A_order.max">order.max</code></td>
<td>
<p>maximum order of the AR model to fit. Passed to <code><a href="stats.html#topic+ar">ar</a></code>.</p>
</td></tr>
<tr><td><code id="surrogate.ARs_+3A_fit.method">fit.method</code></td>
<td>
<p>character string giving the method used to fit the AR model. It is passed to <code><a href="stats.html#topic+ar">ar</a></code> and
has to be one of the strings in the default argument (partial matching works). Defaults to &quot;yule-walker&quot;.</p>
</td></tr>
<tr><td><code id="surrogate.ARs_+3A_nsurr">nsurr</code></td>
<td>
<p>number of surrogates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code>N</code> be the length of the series <code>x</code>. The best AR model is chosen by means of the AIC criterion. Surrogate series are obtained by driving the fitted model with
the smoothed resampled residuals. Smoothing is performed through Kernel density estimation with a Gaussian Kernel by using the
dafaults of <code><a href="stats.html#topic+density">density</a></code>.</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>surr</code></td>
<td>
<p>a matrix with <code>N</code> rows and <code>nsurr</code> columns, in each column is stored a surrogate.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>contains the call to the routine.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Simone Giannerini&lt;simone.giannerini@unibo.it&gt;</p>


<h3>References</h3>

<p>Giannerini S., Maasoumi E., Bee Dagum E., (2015), Entropy testing
for nonlinear serial dependence in time series, <em>Biometrika</em>, <b>102(3)</b>, 661&ndash;675
<a href="https://doi.org/10.1093/biomet/asv007">doi:10.1093/biomet/asv007</a>.
</p>
<p>Bickel, P., Buhlmann, P., (1999). A new mixing notion and
functional central limit theorems for a sieve bootstrap in time
series. <em>Bernoulli</em> <b>5</b>, 413&ndash;446. </p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+surrogate.AR">surrogate.AR</a></code>, <code><a href="#topic+Trho.test.AR">Trho.test.AR</a></code>, <code><a href="#topic+surrogate.SA">surrogate.SA</a></code>, <code><a href="#topic+Trho.test.SA">Trho.test.SA</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1345)
# Generates a AR(1) series
x      &lt;- arima.sim(n=120, model = list(ar=0.8));
x.surr &lt;- surrogate.ARs(x, order.max=NULL, nsurr=3);
plot.ts(x.surr$surr,col=4);


## Check that the surrogates have the same ACF of x
corig &lt;- acf(x,10,plot=FALSE)$acf[,,1];
csurr &lt;- acf(x.surr$surr[,1],10,plot=FALSE)$acf[,,1];
round(cbind(corig,csurr,"abs(difference)"=abs(corig-csurr)),3)
</code></pre>

<hr>
<h2 id='surrogate.SA'>Surrogate Time Series Through Simulated Annealing</h2><span id='topic+surrogate.SA'></span>

<h3>Description</h3>

<p>Starting from a time series <code>x</code> given as input, the function generates surrogate series through Simulated Annealing.
Each surrogate series is a constrained random permutation having the same autocorrelation function (up to <code>nlag</code> lags) of the original series <code>x</code>.
The surrogates can be used for testing for non linearity in time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surrogate.SA(x, nlag, nsurr, Te = 0.0015, RT = 0.9, eps.SA = 0.05, nsuccmax = 30,
 nmax = 300, che = 1e+05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surrogate.SA_+3A_x">x</code></td>
<td>
<p>a univariate numeric time series object or a numeric vector.</p>
</td></tr>
<tr><td><code id="surrogate.SA_+3A_nlag">nlag</code></td>
<td>
<p>minimization is performed w.r.t. to the first <code>nlag</code> lags.</p>
</td></tr>
<tr><td><code id="surrogate.SA_+3A_nsurr">nsurr</code></td>
<td>
<p>number of surrogates.</p>
</td></tr>
<tr><td><code id="surrogate.SA_+3A_te">Te</code></td>
<td>
<p>starting value for the temperature.</p>
</td></tr>
<tr><td><code id="surrogate.SA_+3A_rt">RT</code></td>
<td>
<p>reduction factor for the temperature <code>Te</code>.</p>
</td></tr>
<tr><td><code id="surrogate.SA_+3A_eps.sa">eps.SA</code></td>
<td>
<p>target tolerance.</p>
</td></tr>
<tr><td><code id="surrogate.SA_+3A_nsuccmax">nsuccmax</code></td>
<td>
<p>Te is decreased after <code>nsuccmax*N</code> successes.</p>
</td></tr>
<tr><td><code id="surrogate.SA_+3A_nmax">nmax</code></td>
<td>
<p>Te is decreased after <code>nmax*N</code> successes.</p>
</td></tr>
<tr><td><code id="surrogate.SA_+3A_che">che</code></td>
<td>
<p>after <code>che*2N</code> global iterations the algorithm starts again.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code>N</code> be the length of the series <code>x</code>. Sensible (<code>N</code>-dependent) defaults are derived for the parameters of the
algorithm, there should not be the need to change them. In case, the user could try increasing <code>eps.SA</code>.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>surr</code></td>
<td>
<p>a matrix with <code>N</code> rows and <code>nsurr</code> columns, in each column is stored a surrogate.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>contains the call to the routine.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Simone Giannerini&lt;simone.giannerini@unibo.it&gt;</p>


<h3>References</h3>

<p>Giannerini S., Maasoumi E., Bee Dagum E., (2015), Entropy testing
for nonlinear serial dependence in time series, <em>Biometrika</em>, <b>102(3)</b>, 661&ndash;675
<a href="https://doi.org/10.1093/biomet/asv007">doi:10.1093/biomet/asv007</a>.
</p>
<p>Schreiber T., Schmitz A.,(2000) Surrogate time series. <em>Physica D</em>, <b>142(3-4)</b>, 346&ndash;382.
</p>


<h3>See Also</h3>

<p>See Also <code><a href="#topic+Trho.test.SA">Trho.test.SA</a></code>, <code><a href="#topic+surrogate.AR">surrogate.AR</a></code>, <code><a href="#topic+Trho.test.AR">Trho.test.AR</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1345)
# Generates a AR(1) series
x      &lt;- arima.sim(n=120, model = list(ar=0.8));
x.surr &lt;- surrogate.SA(x, nlag=10, nsurr=3);
plot.ts(x.surr$surr,col=4);


## Check that the surrogates have the same ACF of x
corig &lt;- acf(x,10,plot=FALSE)$acf[,,1];
csurr &lt;- acf(x.surr$surr[,1],10,plot=FALSE)$acf[,,1];
round(cbind(corig,csurr,"abs(difference)"=abs(corig-csurr)),3)
</code></pre>

<hr>
<h2 id='Trho.test.AR.p'>Entropy Tests For Nonlinearity In Time Series - Parallel Version</h2><span id='topic+Trho.test.AR.p'></span><span id='topic+Trho.test.AR'></span>

<h3>Description</h3>

<p>Entropy test of nonlinearity for time series based
on <code><a href="#topic+Srho.ts">Srho.ts</a></code> and surrogate data obtained through
the sieve bootstrap (AR modeling). The parallel version requires <code>parallel</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Trho.test.AR(x, y, lag.max = 10, B = 100, plot = TRUE, quant = c(0.95, 0.99),
 bw = c("reference", "mlcv", "lscv", "scv", "pi"), bdiag=TRUE,
 method = c("integral", "summation"), tol = 0.001, order.max = NULL,
 fit.method=c("yule-walker", "burg", "ols", "mle", "yw"), smoothed = TRUE,...)

## Parallel version

Trho.test.AR.p(x, y, lag.max = 10, B = 100, plot = TRUE, quant = c(0.95, 0.99),
 bw = c("reference", "mlcv", "lscv", "scv", "pi"), bdiag=TRUE,
 method = c("integral", "summation"), tol = 0.001, order.max = NULL,
 fit.method=c("yule-walker", "burg", "ols", "mle", "yw"),  smoothed = TRUE,
 nwork=detectCores(),...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Trho.test.AR.p_+3A_x">x</code>, <code id="Trho.test.AR.p_+3A_y">y</code></td>
<td>
<p>univariate numeric time series object or numeric vectors (<code>y</code> is missing in the univariate case).</p>
</td></tr>
<tr><td><code id="Trho.test.AR.p_+3A_lag.max">lag.max</code></td>
<td>
<p>maximum lag at which to calculate Trho; the default is 10.</p>
</td></tr>
<tr><td><code id="Trho.test.AR.p_+3A_b">B</code></td>
<td>
<p>number of surrogate time series.</p>
</td></tr>
<tr><td><code id="Trho.test.AR.p_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code> (the default) produces a plot of Trho together with confidence bands under the null hypothesis of linearity at 95% and 99%.</p>
</td></tr>
<tr><td><code id="Trho.test.AR.p_+3A_quant">quant</code></td>
<td>
<p>quantiles to be specified for the computation of the significant lags and the plot of confidence bands. Up to 2 quantiles can be specified.
Defaults are 95% and 99%.</p>
</td></tr>
<tr><td><code id="Trho.test.AR.p_+3A_bw">bw</code></td>
<td>
<p>see <code><a href="#topic+Srho.ts">Srho.ts</a></code>.</p>
</td></tr>
<tr><td><code id="Trho.test.AR.p_+3A_bdiag">bdiag</code></td>
<td>
<p>see <code><a href="#topic+Srho.ts">Srho.ts</a></code>.</p>
</td></tr>
<tr><td><code id="Trho.test.AR.p_+3A_method">method</code></td>
<td>
<p>see <code><a href="#topic+Srho.ts">Srho.ts</a></code>.</p>
</td></tr>
<tr><td><code id="Trho.test.AR.p_+3A_tol">tol</code></td>
<td>
<p>see <code><a href="#topic+Srho.ts">Srho.ts</a></code>.</p>
</td></tr>
<tr><td><code id="Trho.test.AR.p_+3A_order.max">order.max</code></td>
<td>
<p>see <code><a href="#topic+surrogate.ARs">surrogate.ARs</a></code>.</p>
</td></tr>
<tr><td><code id="Trho.test.AR.p_+3A_fit.method">fit.method</code></td>
<td>
<p>see <code><a href="#topic+surrogate.ARs">surrogate.ARs</a></code>.</p>
</td></tr>
<tr><td><code id="Trho.test.AR.p_+3A_smoothed">smoothed</code></td>
<td>
<p>logical. If <code>TRUE</code> (the default) uses the smoothed sieve bootstrap in <code><a href="#topic+surrogate.ARs">surrogate.ARs</a></code> to generate surrogates. Otherwise uses the classic sieve by calling <code><a href="#topic+surrogate.AR">surrogate.AR</a></code>.</p>
</td></tr>
<tr><td><code id="Trho.test.AR.p_+3A_nwork">nwork</code></td>
<td>
<p>number of workers/processes to be used in parallel environments.</p>
</td></tr>
<tr><td><code id="Trho.test.AR.p_+3A_...">...</code></td>
<td>
<p>further arguments, typically passed to <code><a href="cubature.html#topic+hcubature">hcubature</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each lag from 1 to <code>lag.max</code> <code>Trho.test.AR</code> computes a test for nonlinearity for time series based
on <code><a href="#topic+Srho.ts">Srho.ts</a></code>. The distribution under the null hypothesis of a linear Gaussian process is obtained through the sieve bootstrap.
The routine requires the package parallel to spawn multiple workers.
</p>


<h3>Value</h3>

<p>An object of class &quot;Srho.test&quot;, which is a list with the following elements:
</p>
<table>
<tr><td><code>.Data</code></td>
<td>
<p> vector of <code>lag.max</code> elements containing Trho computed at each lag.</p>
</td></tr>
<tr><td><code>call:</code></td>
<td>
<p>Object of class <code>"call"</code>: contains the call to the routine.</p>
</td></tr>
<tr><td><code>call.h:</code></td>
<td>
<p>Object of class <code>"call"</code>: contains the call to the routine used for obtaining the surrogates or the bootstrap replicates under the null hypothesis</p>
</td></tr>
<tr><td><code>quantiles</code></td>
<td>
<p>Object of class <code>"matrix"</code>: contains the quantiles of the surrogate distribution under the null hypothesis.</p>
</td></tr>
<tr><td><code>test.type</code></td>
<td>
<p>Object of class <code>"character"</code>: contains a description of the type of test performed.</p>
</td></tr>
<tr><td><code>significant.lags</code></td>
<td>
<p>Object of class <code>"list"</code>: contains the lags at which Trho exceeds the confidence bands at <code>quant</code>% under the null hypothesis.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>Object of class <code>"numeric"</code>: contains the bootstrap p-value for each lag.</p>
</td></tr>
<tr><td><code>lags</code></td>
<td>
<p>integer vector that contains the lags at which Trho is computed.</p>
</td></tr>
<tr><td><code>stationary</code></td>
<td>
<p>Object of class <code>"logical"</code>:  <code>TRUE</code> if the stationary version is computed. Set to <code>FALSE</code> by default as only the non-stationary version is implemented.</p>
</td></tr>
<tr><td><code>data.type</code></td>
<td>
<p>Object of class <code>"character"</code>: contains the data type.</p>
</td></tr>
<tr><td><code>notes</code></td>
<td>
<p>Object of class <code>"character"</code>: additional notes.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Simone Giannerini&lt;simone.giannerini@unibo.it&gt;</p>


<h3>References</h3>

<p>Giannerini S., Maasoumi E., Bee Dagum E., (2015), Entropy testing
for nonlinear serial dependence in time series, <em>Biometrika</em>, <b>102(3)</b>, 661&ndash;675
<a href="https://doi.org/10.1093/biomet/asv007">doi:10.1093/biomet/asv007</a>.
</p>


<h3>See Also</h3>

<p>See Also <code><a href="#topic+Srho.ts">Srho.ts</a></code>, <code><a href="#topic+surrogate.AR">surrogate.AR</a></code>, <code><a href="#topic+surrogate.ARs">surrogate.ARs</a></code>, <code><a href="#topic+Trho.test.AR">Trho.test.AR</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# modify nwork to match the number of available cores
set.seed(13)
b      &lt;- 100
x      &lt;- arima.sim(n=120, model = list(ar=0.8));
result &lt;- Trho.test.AR.p(x, lag.max = 5, B=b, nwork=2)

## ** Compare timings **
system.time(Trho.test.AR.p(x,lag.max = 5,B=b, nwork=4))
system.time(Trho.test.AR(x,  lag.max = 5,B=b))

## End(Not run)</code></pre>

<hr>
<h2 id='Trho.test.SA.p'>Entropy Tests For Nonlinearity In Time Series - Parallel Version</h2><span id='topic+Trho.test.SA.p'></span><span id='topic+Trho.test.SA'></span>

<h3>Description</h3>

<p>Entropy test of nonlinearity for time series based
on <code><a href="#topic+Srho.ts">Srho.ts</a></code> and surrogate data obtained through
Simulated Annealing. The parallel version requires <code>parallel</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Trho.test.SA(x, y, lag.max = 10,  B = 100, plot = TRUE, quant = c(0.95, 0.99),
 bw = c("reference","mlcv", "lscv", "scv", "pi"), bdiag=TRUE,
 method =c("integral","summation"), tol=1e-03, nlag=trunc(length(x)/4),
 Te=0.0015, RT=0.9, eps.SA=0.05, nsuccmax=30, nmax=300, che=100000,...) 
 
Trho.test.SA.p(x, y, lag.max = 10,  B = 100, plot = TRUE, quant = c(0.95, 0.99),
 bw = c("reference","mlcv", "lscv", "scv", "pi"), bdiag=TRUE,
  method =c("integral","summation"), tol=1e-03, nlag=trunc(length(x)/4), Te=0.0015,
 RT=0.9, eps.SA=0.05, nsuccmax=30, nmax=300, che=100000, nwork=detectCores(),...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Trho.test.SA.p_+3A_x">x</code>, <code id="Trho.test.SA.p_+3A_y">y</code></td>
<td>
<p>univariate numeric time series object or numeric vectors (<code>y</code> is missing in the univariate case).</p>
</td></tr>
<tr><td><code id="Trho.test.SA.p_+3A_lag.max">lag.max</code></td>
<td>
<p>maximum lag at which to calculate Trho; the default is 10.</p>
</td></tr>
<tr><td><code id="Trho.test.SA.p_+3A_b">B</code></td>
<td>
<p>number of surrogate time series.</p>
</td></tr>
<tr><td><code id="Trho.test.SA.p_+3A_plot">plot</code></td>
<td>
<p>logical. If <code>TRUE</code>(the default) produces a plot of Trho together with confidence bands under the null hypothesis of linearity at 95% and 99%.</p>
</td></tr>
<tr><td><code id="Trho.test.SA.p_+3A_quant">quant</code></td>
<td>
<p>quantiles to be specified for the computation of the significant lags and the plot of confidence bands. Up to 2 quantiles can be specified.
Defaults are 95% and 99%.</p>
</td></tr>
<tr><td><code id="Trho.test.SA.p_+3A_bw">bw</code></td>
<td>
<p>see <code><a href="#topic+Srho.ts">Srho.ts</a></code>.</p>
</td></tr>
<tr><td><code id="Trho.test.SA.p_+3A_bdiag">bdiag</code></td>
<td>
<p>see <code><a href="#topic+Srho.ts">Srho.ts</a></code>.</p>
</td></tr>
<tr><td><code id="Trho.test.SA.p_+3A_method">method</code></td>
<td>
<p>see <code><a href="#topic+Srho.ts">Srho.ts</a></code>.</p>
</td></tr>
<tr><td><code id="Trho.test.SA.p_+3A_tol">tol</code></td>
<td>
<p>see <code><a href="#topic+Srho.ts">Srho.ts</a></code>.</p>
</td></tr>
<tr><td><code id="Trho.test.SA.p_+3A_nlag">nlag</code></td>
<td>
<p>see <code><a href="#topic+surrogate.SA">surrogate.SA</a></code>.</p>
</td></tr>
<tr><td><code id="Trho.test.SA.p_+3A_te">Te</code></td>
<td>
<p>see <code><a href="#topic+surrogate.SA">surrogate.SA</a></code>.</p>
</td></tr>
<tr><td><code id="Trho.test.SA.p_+3A_rt">RT</code></td>
<td>
<p>see <code><a href="#topic+surrogate.SA">surrogate.SA</a></code>.</p>
</td></tr>
<tr><td><code id="Trho.test.SA.p_+3A_eps.sa">eps.SA</code></td>
<td>
<p>see <code><a href="#topic+surrogate.SA">surrogate.SA</a></code>.</p>
</td></tr>
<tr><td><code id="Trho.test.SA.p_+3A_nsuccmax">nsuccmax</code></td>
<td>
<p>see <code><a href="#topic+surrogate.SA">surrogate.SA</a></code>.</p>
</td></tr>
<tr><td><code id="Trho.test.SA.p_+3A_nmax">nmax</code></td>
<td>
<p>see <code><a href="#topic+surrogate.SA">surrogate.SA</a></code>.</p>
</td></tr>
<tr><td><code id="Trho.test.SA.p_+3A_che">che</code></td>
<td>
<p>see <code><a href="#topic+surrogate.SA">surrogate.SA</a></code>.</p>
</td></tr>
<tr><td><code id="Trho.test.SA.p_+3A_nwork">nwork</code></td>
<td>
<p>number of workers/processes to be used in parallel environments.</p>
</td></tr>
<tr><td><code id="Trho.test.SA.p_+3A_...">...</code></td>
<td>
<p>further arguments, typically passed to <code><a href="cubature.html#topic+hcubature">hcubature</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each lag from 1 to <code>lag.max</code> <code>Trho.test.SA</code> computes a test for nonlinearity for time series based
on <code><a href="#topic+Srho.ts">Srho.ts</a></code>. The distribution under the null hypothesis of a linear Gaussian process is obtained through a generalization of surrogate data
methods. Surrogate time series are obtained through Simulated Annealing (SA). Sensible (N-dependent) defaults are derived for the parameters of the SA
algorithm, there should not be the need to change them. The routine requires the package parallel to spawn multiple workers.
</p>


<h3>Value</h3>

<p>An object of class &quot;Srho.test&quot;, which is a list with the following elements:
</p>
<table>
<tr><td><code>.Data</code></td>
<td>
<p> vector of <code>lag.max</code> elements containing Trho computed at each lag.</p>
</td></tr>
<tr><td><code>call:</code></td>
<td>
<p>Object of class <code>"call"</code>: contains the call to the routine.</p>
</td></tr>
<tr><td><code>call.h:</code></td>
<td>
<p>Object of class <code>"call"</code>: contains the call to the routine used for obtaining the surrogates or the bootstrap replicates under the null hypothesis.</p>
</td></tr>
<tr><td><code>quantiles</code></td>
<td>
<p>Object of class <code>"matrix"</code>: contains the quantiles of the surrogate distribution under the null hypothesis.</p>
</td></tr>
<tr><td><code>test.type</code></td>
<td>
<p>Object of class <code>"character"</code>: contains a description of the type of test performed.</p>
</td></tr>
<tr><td><code>significant.lags</code></td>
<td>
<p>Object of class <code>"list"</code>: contains the lags at which Trho exceeds the confidence bands at <code>quant</code>% under the null hypothesis.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>Object of class <code>"numeric"</code>: contains the bootstrap p-value for each lag.</p>
</td></tr>
<tr><td><code>lags</code></td>
<td>
<p>integer vector that contains the lags at which Trho is computed.</p>
</td></tr>
<tr><td><code>stationary</code></td>
<td>
<p>Object of class <code>"logical"</code>:  <code>TRUE</code> if the stationary version is computed. Set to <code>FALSE</code> by default as only the non-stationary version is implemented.</p>
</td></tr>
<tr><td><code>data.type</code></td>
<td>
<p>Object of class <code>"character"</code>: contains the data type.</p>
</td></tr>
<tr><td><code>notes</code></td>
<td>
<p>Object of class <code>"character"</code>: additional notes.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Simone Giannerini&lt;simone.giannerini@unibo.it&gt;</p>


<h3>References</h3>

<p>Giannerini S., Maasoumi E., Bee Dagum E., (2015), Entropy testing
for nonlinear serial dependence in time series, <em>Biometrika</em>, <b>102(3)</b>, 661&ndash;675
<a href="https://doi.org/10.1093/biomet/asv007">doi:10.1093/biomet/asv007</a>.
</p>


<h3>See Also</h3>

<p>See Also <code><a href="#topic+Srho.ts">Srho.ts</a></code>, <code><a href="#topic+surrogate.SA">surrogate.SA</a></code>, <code><a href="#topic+Trho.test.SA">Trho.test.SA</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# modify nwork to match the number of available cores
set.seed(13)
x      &lt;- arima.sim(n=120, model = list(ar=0.8));
result &lt;- Trho.test.SA.p(x, lag.max = 5, B = 100, bw='reference', nwork=2)

## ** Compare timings **
system.time(Trho.test.SA.p(x, lag.max = 5, B = 100, bw='reference', nwork=4))
system.time(Trho.test.SA(x, lag.max = 5, B = 100, bw='reference'))

## End(Not run)</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
