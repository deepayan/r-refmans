<!DOCTYPE html><html lang="en"><head><title>Help for package discursive</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {discursive}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cces'><p>Cooperative Congressional Election Study 2018</p></a></li>
<li><a href='#dict_sample'><p>Constraint Dictionary</p></a></li>
<li><a href='#discursive'><p>Compute discursive sophistication for a set of open-ended responses</p></a></li>
<li><a href='#discursive_combine'><p>Combine three components of discursive sophistication in a single scale</p></a></li>
<li><a href='#discursive_constraint'><p>Compute the constraint component of discursive sophistication</p></a></li>
<li><a href='#discursive_range'><p>Compute the range component of discursive sophistication</p></a></li>
<li><a href='#discursive_size'><p>Compute the size component of discursive sophistication</p></a></li>
<li><a href='#ntopics'><p>Compute number of topics based on stm results</p></a></li>
<li><a href='#oe_shannon'><p>Compute Shannon entropy</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Measuring Discursive Sophistication in Open-Ended Survey
Responses</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>A simple approach to measure political sophistication based on open-ended survey responses. Discursive sophistication captures the complexity of individual attitude expression by quantifying its relative size, range, and constraint. For more information on the measurement approach see: Kraft, Patrick W. 2023. "Women Also Know Stuff: Challenging the Gender Gap in Political Sophistication." American Political Science Review (forthcoming).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>SnowballC, stm, stringr, tm, utils</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-11 08:29:00 UTC; patrick</td>
</tr>
<tr>
<td>Author:</td>
<td>Patrick Kraft <a href="https://orcid.org/0000-0003-0123-221X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Patrick Kraft &lt;kraft.pw@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-11 11:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='cces'>Cooperative Congressional Election Study 2018</h2><span id='topic+cces'></span>

<h3>Description</h3>

<p>A subset of data from the UWM Team Content of the 2018 CCES wave. See Kraft (2023) for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cces
</code></pre>


<h3>Format</h3>



<h4><code>cces</code></h4>

<p>A data frame with 1,000 rows and 15 columns:
</p>

<dl>
<dt>age</dt><dd><p>Age (in years)</p>
</dd>
<dt>female</dt><dd><p>Gender (1 = female)</p>
</dd>
<dt>educ_cont</dt><dd><p>Education level (1-6)</p>
</dd>
<dt>pid_cont</dt><dd><p>Party identification (1-7)</p>
</dd>
<dt>educ_pid</dt><dd><p>educ_cont * pid_cont</p>
</dd>
<dt>oe01-oe10</dt><dd><p>Open-ended responses</p>
</dd>
</dl>




<h3>Source</h3>

<p><a href="https://cces.gov.harvard.edu/">https://cces.gov.harvard.edu/</a>
</p>

<hr>
<h2 id='dict_sample'>Constraint Dictionary</h2><span id='topic+dict_sample'></span>

<h3>Description</h3>

<p>A sample of terms that signal a higher level of constraint between different considerations (combining conjunctions and exclusive words). See Kraft (2023) for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dict_sample
</code></pre>


<h3>Format</h3>



<h4><code>cces</code></h4>

<p>A data character vector with 4 elements:
</p>

<dl>
<dt>conjunctions</dt><dd><p>also, and</p>
</dd>
<dt>exclusive</dt><dd><p>but, without</p>
</dd>
</dl>



<hr>
<h2 id='discursive'>Compute discursive sophistication for a set of open-ended responses</h2><span id='topic+discursive'></span>

<h3>Description</h3>

<p>This function takes a data frame (<code>data</code>) containing a set of open-ended responses (<code>openends</code>) to compute the three components of discursive sophistication (size, range, and constraint) and combines them in a single scale. See Kraft (2023) for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discursive(
  data,
  openends,
  meta,
  args_textProcessor = NULL,
  args_prepDocuments = NULL,
  args_stm = NULL,
  keep_stm = TRUE,
  dictionary,
  remove_duplicates = FALSE,
  type = c("scale", "average", "average_scale", "product"),
  progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="discursive_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="discursive_+3A_openends">openends</code></td>
<td>
<p>A character vector containing variable names of open-ended responses in <code>data</code>.</p>
</td></tr>
<tr><td><code id="discursive_+3A_meta">meta</code></td>
<td>
<p>A character vector containing topic prevalence covariates included in <code>data</code>. See <code><a href="stm.html#topic+stm">stm::stm()</a></code> for details.</p>
</td></tr>
<tr><td><code id="discursive_+3A_args_textprocessor">args_textProcessor</code></td>
<td>
<p>A named list containing additional arguments passed to <code><a href="stm.html#topic+textProcessor">stm::textProcessor()</a></code>.</p>
</td></tr>
<tr><td><code id="discursive_+3A_args_prepdocuments">args_prepDocuments</code></td>
<td>
<p>A named list containing additional arguments passed to <code><a href="stm.html#topic+prepDocuments">stm::prepDocuments()</a></code>.</p>
</td></tr>
<tr><td><code id="discursive_+3A_args_stm">args_stm</code></td>
<td>
<p>A named list containing additional arguments passed to <code><a href="stm.html#topic+stm">stm::stm()</a></code>.</p>
</td></tr>
<tr><td><code id="discursive_+3A_keep_stm">keep_stm</code></td>
<td>
<p>Logical. If TRUE function returns output of <code><a href="stm.html#topic+textProcessor">stm::textProcessor()</a></code>, <code><a href="stm.html#topic+prepDocuments">stm::prepDocuments()</a></code>, and <code><a href="stm.html#topic+stm">stm::stm()</a></code>.</p>
</td></tr>
<tr><td><code id="discursive_+3A_dictionary">dictionary</code></td>
<td>
<p>A character vector containing dictionary terms to flag conjunctions and exclusive words. May include regular expressions.</p>
</td></tr>
<tr><td><code id="discursive_+3A_remove_duplicates">remove_duplicates</code></td>
<td>
<p>Logical. If TRUE duplicates in <code>dictionary</code> are removed.</p>
</td></tr>
<tr><td><code id="discursive_+3A_type">type</code></td>
<td>
<p>The method of combining the three components, must be &quot;scale&quot;, &quot;average&quot;, &quot;average_scale&quot;, or &quot;product&quot;. The default is &quot;scale&quot;, which creates an additive index that is re-scaled to mean 0 and standard deviation 1. Alternatively, &quot;average&quot; creates the same additive index without re-scaling; &quot;average_scale&quot; re-scales each individual component to mean 0 and standard deviation 1 before creating the additive index; &quot;product&quot; creates a multiplicative index.</p>
</td></tr>
<tr><td><code id="discursive_+3A_progress">progress</code></td>
<td>
<p>Logical. Shows progress bar if TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the measure of discursive sophistication and the underlying components in a data frame, as well as the output of <code><a href="stm.html#topic+textProcessor">stm::textProcessor()</a></code>, <code><a href="stm.html#topic+prepDocuments">stm::prepDocuments()</a></code>, and <code><a href="stm.html#topic+stm">stm::stm()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>discursive(data = cces,
           openends = c(paste0("oe0", 1:9), "oe10"),
           meta = c("age", "educ_cont", "pid_cont", "educ_pid", "female"),
           args_prepDocuments = list(lower.thresh = 10),
           args_stm = list(K = 25, seed = 12345),
           dictionary = dict_sample)
</code></pre>

<hr>
<h2 id='discursive_combine'>Combine three components of discursive sophistication in a single scale</h2><span id='topic+discursive_combine'></span>

<h3>Description</h3>

<p>This function combines the <code>size</code>, <code>range</code>, and <code>constraint</code> of open-ended responses in a single scale. See Kraft (2023) for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discursive_combine(
  size,
  range,
  constraint,
  type = c("scale", "average", "average_scale", "product")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="discursive_combine_+3A_size">size</code></td>
<td>
<p>A named list containing an element labeled <code>size</code>, which itself consists of a numeric vector containing the size component of discursive sophistication. Usually created via <code><a href="#topic+discursive_size">discursive_size()</a></code>.</p>
</td></tr>
<tr><td><code id="discursive_combine_+3A_range">range</code></td>
<td>
<p>A numeric vector containing the range component of discursive sophistication. Usually created via <code><a href="#topic+discursive_range">discursive_range()</a></code>.</p>
</td></tr>
<tr><td><code id="discursive_combine_+3A_constraint">constraint</code></td>
<td>
<p>A numeric vector containing the constraint component of discursive sophistication. Usually created via <code><a href="#topic+discursive_constraint">discursive_constraint()</a></code>.</p>
</td></tr>
<tr><td><code id="discursive_combine_+3A_type">type</code></td>
<td>
<p>The method of combining the three components, must be &quot;scale&quot;, &quot;average&quot;, &quot;average_scale&quot;, or &quot;product&quot;. The default is &quot;scale&quot;, which creates an additive index that is re-scaled to mean 0 and standard deviation 1. Alternatively, &quot;average&quot; creates the same additive index without re-scaling; &quot;average_scale&quot; re-scales each individual component to mean 0 and standard deviation 1 before creating the additive index; &quot;product&quot; creates a multiplicative index.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the same length as the number of rows in <code>data</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>discursive_combine(size = list(size = runif(100)), range = runif(100), constraint = runif(100))
</code></pre>

<hr>
<h2 id='discursive_constraint'>Compute the constraint component of discursive sophistication</h2><span id='topic+discursive_constraint'></span>

<h3>Description</h3>

<p>This function takes a data frame (<code>data</code>) containing a set of open-ended responses (<code>openends</code>) and a <code>dictionary</code> to identify terms that signal a higher level of constraint between different considerations (usually conjunctions and exclusive words). It returns a numeric vector of dictionary counts re-scaled to range from 0 to 1. See Kraft (2023) for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discursive_constraint(data, openends, dictionary, remove_duplicates = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="discursive_constraint_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="discursive_constraint_+3A_openends">openends</code></td>
<td>
<p>A character vector containing variable names of open-ended responses in <code>data</code>.</p>
</td></tr>
<tr><td><code id="discursive_constraint_+3A_dictionary">dictionary</code></td>
<td>
<p>A character vector containing dictionary terms to flag conjunctions and exclusive words. May include regular expressions.</p>
</td></tr>
<tr><td><code id="discursive_constraint_+3A_remove_duplicates">remove_duplicates</code></td>
<td>
<p>Logical. If TRUE duplicates in <code>dictionary</code> are removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the same length as the number of rows in <code>data</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>discursive_constraint(data = cces,
                      openends = c(paste0("oe0", 1:9), "oe10"),
                      dictionary = dict_sample)
</code></pre>

<hr>
<h2 id='discursive_range'>Compute the range component of discursive sophistication</h2><span id='topic+discursive_range'></span>

<h3>Description</h3>

<p>This function takes a data frame (<code>data</code>) containing a set of open-ended responses (<code>openends</code>) to compute the Shannon entropy in individual response lengths across items. The function returns a numeric vector of topic counts re-scaled to range from 0 to 1. See Kraft (2023) for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discursive_range(data, openends)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="discursive_range_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="discursive_range_+3A_openends">openends</code></td>
<td>
<p>A character vector containing variable names of open-ended responses in <code>data</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the same length as the number of rows in <code>data</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>discursive_range(data = cces,
                 openends = c(paste0("oe0", 1:9), "oe10"))
</code></pre>

<hr>
<h2 id='discursive_size'>Compute the size component of discursive sophistication</h2><span id='topic+discursive_size'></span>

<h3>Description</h3>

<p>This function takes a data frame (<code>data</code>) containing a set of open-ended responses (<code>openends</code>) and additional arguments passed to <code><a href="stm.html#topic+textProcessor">stm::textProcessor()</a></code> and <code><a href="stm.html#topic+prepDocuments">stm::prepDocuments()</a></code> to estimate a structural topic model via <code><a href="stm.html#topic+stm">stm::stm()</a></code>. The results of the the structural topic model are used to compute the relative number of topics raised in each open-ended response. The function returns a numeric vector of topic counts re-scaled to range from 0 to 1. See Kraft (2023) for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discursive_size(
  data,
  openends,
  meta,
  args_textProcessor = NULL,
  args_prepDocuments = NULL,
  args_stm = NULL,
  keep_stm = TRUE,
  progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="discursive_size_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="discursive_size_+3A_openends">openends</code></td>
<td>
<p>A character vector containing variable names of open-ended responses in <code>data</code>.</p>
</td></tr>
<tr><td><code id="discursive_size_+3A_meta">meta</code></td>
<td>
<p>A character vector containing topic prevalence covariates included in <code>data</code>. See <code><a href="stm.html#topic+stm">stm::stm()</a></code> for details.</p>
</td></tr>
<tr><td><code id="discursive_size_+3A_args_textprocessor">args_textProcessor</code></td>
<td>
<p>A named list containing additional arguments passed to <code><a href="stm.html#topic+textProcessor">stm::textProcessor()</a></code>.</p>
</td></tr>
<tr><td><code id="discursive_size_+3A_args_prepdocuments">args_prepDocuments</code></td>
<td>
<p>A named list containing additional arguments passed to <code><a href="stm.html#topic+prepDocuments">stm::prepDocuments()</a></code>.</p>
</td></tr>
<tr><td><code id="discursive_size_+3A_args_stm">args_stm</code></td>
<td>
<p>A named list containing additional arguments passed to <code><a href="stm.html#topic+stm">stm::stm()</a></code>.</p>
</td></tr>
<tr><td><code id="discursive_size_+3A_keep_stm">keep_stm</code></td>
<td>
<p>Logical. If TRUE function returns output of <code><a href="stm.html#topic+textProcessor">stm::textProcessor()</a></code>, <code><a href="stm.html#topic+prepDocuments">stm::prepDocuments()</a></code>, and <code><a href="stm.html#topic+stm">stm::stm()</a></code>.</p>
</td></tr>
<tr><td><code id="discursive_size_+3A_progress">progress</code></td>
<td>
<p>Logical. Shows progress bar if TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the size component of discursive sophistication as well as the output of <code><a href="stm.html#topic+textProcessor">stm::textProcessor()</a></code>, <code><a href="stm.html#topic+prepDocuments">stm::prepDocuments()</a></code>, and <code><a href="stm.html#topic+stm">stm::stm()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>discursive_size(data = cces,
                openends = c(paste0("oe0", 1:9), "oe10"),
                meta = c("age", "educ_cont", "pid_cont", "educ_pid", "female"),
                args_prepDocuments = list(lower.thresh = 10),
                args_stm = list(K = 25, seed = 12345))
</code></pre>

<hr>
<h2 id='ntopics'>Compute number of topics based on stm results</h2><span id='topic+ntopics'></span>

<h3>Description</h3>

<p>This function takes a structural topic model output estimated via <code><a href="stm.html#topic+stm">stm::stm()</a></code> as well as the underlying set of documents created via <code><a href="stm.html#topic+prepDocuments">stm::prepDocuments()</a></code> to compute the relative number of topics raised in each open-ended response. The function returns a numeric vector of topic counts re-scaled to range from 0 to 1. See Kraft (2023) for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ntopics(x, docs, progress = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ntopics_+3A_x">x</code></td>
<td>
<p>A structural topic model estimated via <code><a href="stm.html#topic+stm">stm::stm()</a></code>.</p>
</td></tr>
<tr><td><code id="ntopics_+3A_docs">docs</code></td>
<td>
<p>A set of documents used for the structural topic model; created via <code><a href="stm.html#topic+prepDocuments">stm::prepDocuments()</a></code>.</p>
</td></tr>
<tr><td><code id="ntopics_+3A_progress">progress</code></td>
<td>
<p>Logical. Shows progress bar if TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector with the same length as the number of documents in <code>x</code> and <code>docs</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>meta &lt;- c("age", "educ_cont", "pid_cont", "educ_pid", "female")
openends &lt;- c(paste0("oe0", 1:9), "oe10")
cces$resp &lt;- apply(cces[, openends], 1, paste, collapse = " ")
cces &lt;- cces[!apply(cces[, meta], 1, anyNA), ]
processed &lt;- stm::textProcessor(cces$resp, metadata = cces[, meta])
out &lt;- stm::prepDocuments(processed$documents, processed$vocab, processed$meta, lower.thresh = 10)
stm_fit &lt;- stm::stm(out$documents, out$vocab, prevalence = as.matrix(out$meta), K=25, seed=12345)
ntopics(stm_fit, out)
</code></pre>

<hr>
<h2 id='oe_shannon'>Compute Shannon entropy</h2><span id='topic+oe_shannon'></span>

<h3>Description</h3>

<p>Internal function to compute Shannon entropy in relative word counts across a set of elements in a character vecotr. Entropy is re-scaled to range from 0 to 1. Function used in <code><a href="#topic+discursive_range">discursive_range()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oe_shannon(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="oe_shannon_+3A_x">x</code></td>
<td>
<p>Character vector containing open-ended responses.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector with the same length as x.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
