<!DOCTYPE html><html><head><title>Help for package nullabor</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nullabor}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_true'><p>Add true data into data frame containing null data sets.</p></a></li>
<li><a href='#aud'><p>Conversion rate of 1 Australian Doller (AUD) to 1 US Dollar</p></a></li>
<li><a href='#bin_dist'><p>Binned Distance</p></a></li>
<li><a href='#box_dist'><p>Distance based on side by side Boxplots</p></a></li>
<li><a href='#calc_diff'><p>Calculating the difference between true plot and the null plot with the maximum distance.</p></a></li>
<li><a href='#calc_mean_dist'><p>Calculating the mean distances of each plot in the lineup.</p></a></li>
<li><a href='#decrypt'><p>Use decrypt to reveal the position of the real data.</p></a></li>
<li><a href='#distmet'><p>Empirical distribution of the distance</p></a></li>
<li><a href='#distplot'><p>Plotting the distribution of the distance measure</p></a></li>
<li><a href='#electoral'><p>Polls and election results from the 2012 US Election</p></a></li>
<li><a href='#find_plot_data'><p>Find plot data.</p>
If data is not specified, this function will attempt to find the data
corresponding to the last ggplot2 created or displayed. This will work
in most situations where you are creating the plot and immediately
displaying it, but may not work in other situations.  In those cases,
please specify the data explicitly.</a></li>
<li><a href='#lal'><p>Los Angeles Lakers play-by-play data.</p></a></li>
<li><a href='#lineup'><p>The line-up protocol.</p></a></li>
<li><a href='#null_dist'><p>Generate null data with a specific distribution.</p></a></li>
<li><a href='#null_gen'><p>Computing th distance for the null plots</p></a></li>
<li><a href='#null_lm'><p>Generate null data with null residuals from a model.</p></a></li>
<li><a href='#null_permute'><p>Generate null data by permuting a variable.</p></a></li>
<li><a href='#null_ts'><p>Generate null data by simulating from a time series model.</p></a></li>
<li><a href='#opt_bin_diff'><p>Finds the number of bins in x and y direction which gives the maximum binned distance.</p></a></li>
<li><a href='#pvisual'><p>P-value calculations.</p></a></li>
<li><a href='#reg_dist'><p>Distance based on the regression parameters</p></a></li>
<li><a href='#resid_boot'><p>Bootstrap residuals.</p></a></li>
<li><a href='#resid_pboot'><p>Parametric bootstrap residuals.</p></a></li>
<li><a href='#resid_rotate'><p>Rotation residuals.</p></a></li>
<li><a href='#resid_sigma'><p>Residuals simulated by a normal model, with specified sigma</p></a></li>
<li><a href='#rorschach'><p>The Rorschach protocol.</p></a></li>
<li><a href='#sample_size'><p>Sample size calculator</p></a></li>
<li><a href='#sep_dist'><p>Distance based on separation of clusters</p></a></li>
<li><a href='#turk_results'><p>Sample turk results</p></a></li>
<li><a href='#uni_dist'><p>Distance for univariate data</p></a></li>
<li><a href='#visual_power'><p>Power calculations.</p></a></li>
<li><a href='#wasps'><p>Wasp gene expression data.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.3.9</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for visual inference. Generate null data sets
    and null plots using permutation and simulation. Calculate distance metrics
    for a lineup, and examine the distributions of metrics.</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Graphical Inference</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Di Cook &lt;dicook@monash.edu&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://github.com/dicook/nullabor">http://github.com/dicook/nullabor</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="http://github.com/dicook/nullabor/issues">http://github.com/dicook/nullabor/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, rlang, moments, fpc, tsibble, forecast, ggplot2, dplyr,
purrr, tidyr, tibble, magrittr, viridis</td>
</tr>
<tr>
<td>Suggests:</td>
<td>reshape2, knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>false</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-02-25 21:12:19 UTC; dicook</td>
</tr>
<tr>
<td>Author:</td>
<td>Hadley Wickham <a href="https://orcid.org/0000-0003-4757-117X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, ctb],
  Niladri Roy Chowdhury [aut, ctb],
  Di Cook <a href="https://orcid.org/0000-0002-3813-7155"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Heike Hofmann <a href="https://orcid.org/0000-0001-6216-5183"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-02-25 21:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_true'>Add true data into data frame containing null data sets.</h2><span id='topic+add_true'></span>

<h3>Description</h3>

<p>Add true data into data frame containing null data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_true(samples, true, pos)
</code></pre>

<hr>
<h2 id='aud'>Conversion rate of 1 Australian Doller (AUD) to 1 US Dollar</h2><span id='topic+aud'></span>

<h3>Description</h3>

<p>The dataset consists of the daily exchange rates of 1 Australian Dollar to 1 US Dollar between Jan 9 2018 and Feb 21 2018.
</p>

<hr>
<h2 id='bin_dist'>Binned Distance</h2><span id='topic+bin_dist'></span>

<h3>Description</h3>

<p>Data X is binned into X.bin bins in x-direction and Y.bins in y-direction. The number
of points in each cell is then counted. Same is done for data PX. An euclidean
distance is calculated between the number of points in each cell between X and PX.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bin_dist(X, PX, lineup.dat = lineup.dat, X.bin = 5, Y.bin = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bin_dist_+3A_x">X</code></td>
<td>
<p>a data.frame with two variables, the first two columns
are used</p>
</td></tr>
<tr><td><code id="bin_dist_+3A_px">PX</code></td>
<td>
<p>another data.frame with two variables, the first two columns
are used</p>
</td></tr>
<tr><td><code id="bin_dist_+3A_lineup.dat">lineup.dat</code></td>
<td>
<p>lineup data so that the binning is done based on the lineup data and not
the individual plots, by default lineup.dat = lineup.dat ; if one wishes to calculate the
binned distance between two plots, one should use lineup.dat = NULL</p>
</td></tr>
<tr><td><code id="bin_dist_+3A_x.bin">X.bin</code></td>
<td>
<p>number of bins on the x-direction, by default X.bin = 5</p>
</td></tr>
<tr><td><code id="bin_dist_+3A_y.bin">Y.bin</code></td>
<td>
<p>number of bins on the y-direction, by default Y.bin = 5</p>
</td></tr>
</table>


<h3>Value</h3>

<p>distance between X and PX
</p>


<h3>Examples</h3>

<pre><code class='language-R'>with(mtcars, bin_dist(data.frame(wt, mpg), data.frame(sample(wt), mpg),
lineup.dat = NULL))
</code></pre>

<hr>
<h2 id='box_dist'>Distance based on side by side Boxplots</h2><span id='topic+box_dist'></span>

<h3>Description</h3>

<p>Assuming that data set X consists of a categorical group variable a numeric value,
a summary of the first quartile, median and third quartile of this value is calculated
for each group.
The extent (as absolute difference) of the minimum and maximum value across groups is computed for
first quartile, median and third quartile. Same is done for data PX.
Finally an euclidean distance is calculated between the absolute differences of
X and PX.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>box_dist(X, PX)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="box_dist_+3A_x">X</code></td>
<td>
<p>a data.frame with one factor variable and one continuous
variable</p>
</td></tr>
<tr><td><code id="box_dist_+3A_px">PX</code></td>
<td>
<p>a data.frame with one factor variable and one continuous
variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>distance between X and PX
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require('dplyr')) {
  with(mtcars,
    box_dist(data.frame(as.factor(am), mpg),
    data.frame(as.factor(sample(am)), mpg))
  )
}
</code></pre>

<hr>
<h2 id='calc_diff'>Calculating the difference between true plot and the null plot with the maximum distance.</h2><span id='topic+calc_diff'></span>

<h3>Description</h3>

<p>Distance metric is used to calculate the mean distance between the true plot
and all the null plots in a lineup. The difference between the mean
distance of the true plot and the maximum mean distance of the null plots is
calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_diff(lineup.dat, var, met, pos, dist.arg = NULL, m = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_diff_+3A_lineup.dat">lineup.dat</code></td>
<td>
<p>lineup data to get the lineup</p>
</td></tr>
<tr><td><code id="calc_diff_+3A_var">var</code></td>
<td>
<p>a vector of names of the variables to be used to calculate the difference</p>
</td></tr>
<tr><td><code id="calc_diff_+3A_met">met</code></td>
<td>
<p>distance metric needed to calculate the distance as a character</p>
</td></tr>
<tr><td><code id="calc_diff_+3A_pos">pos</code></td>
<td>
<p>position of the true plot in the lineup</p>
</td></tr>
<tr><td><code id="calc_diff_+3A_dist.arg">dist.arg</code></td>
<td>
<p>a list or vector of inputs for the distance metric met; NULL by default</p>
</td></tr>
<tr><td><code id="calc_diff_+3A_m">m</code></td>
<td>
<p>number of plots in the lineup, by default m = 20</p>
</td></tr>
</table>


<h3>Value</h3>

<p>difference between the mean distance of the true plot and
the maximum mean distance of the null plots
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require('dplyr')){
lineup.dat &lt;- lineup(null_permute('mpg'), mtcars, pos = 1)
calc_diff(lineup.dat, var = c('mpg', 'wt'), met = 'bin_dist',
dist.arg = list(lineup.dat = lineup.dat, X.bin = 5, Y.bin = 5), pos = 1, m = 8)}

if(require('dplyr')){
calc_diff(lineup(null_permute('mpg'), mtcars, pos = 1), var = c('mpg', 'wt'), met = 'reg_dist',
dist.arg = NULL, pos = 1, m = 8)}
</code></pre>

<hr>
<h2 id='calc_mean_dist'>Calculating the mean distances of each plot in the lineup.</h2><span id='topic+calc_mean_dist'></span>

<h3>Description</h3>

<p>Distance metric is used to calculate the mean distance between the true plot
and all the null plots in a lineup. The mean distances of each null plot to all
the other null plots are calculated. The mean distances are returned for all the plots
in the lineup.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_mean_dist(lineup.dat, var, met, pos, dist.arg = NULL, m = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_mean_dist_+3A_lineup.dat">lineup.dat</code></td>
<td>
<p>lineup data of the lineup</p>
</td></tr>
<tr><td><code id="calc_mean_dist_+3A_var">var</code></td>
<td>
<p>a vector of names of the variables to be used to calculate the mean distances</p>
</td></tr>
<tr><td><code id="calc_mean_dist_+3A_met">met</code></td>
<td>
<p>distance metric needed to calculate the distance as a character</p>
</td></tr>
<tr><td><code id="calc_mean_dist_+3A_pos">pos</code></td>
<td>
<p>position of the true plot in the lineup</p>
</td></tr>
<tr><td><code id="calc_mean_dist_+3A_dist.arg">dist.arg</code></td>
<td>
<p>a list or vector of inputs for the distance metric met; NULL by default</p>
</td></tr>
<tr><td><code id="calc_mean_dist_+3A_m">m</code></td>
<td>
<p>number of plots in the lineup, by default m = 20</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the mean distances of each plot in the lineup
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require('dplyr')){
calc_mean_dist(lineup(null_permute('mpg'), mtcars, pos = 1), var = c('mpg', 'wt'),
met = 'reg_dist', pos = 1, m = 10)}
</code></pre>

<hr>
<h2 id='decrypt'>Use decrypt to reveal the position of the real data.</h2><span id='topic+decrypt'></span>

<h3>Description</h3>

<p>The real data position is encrypted by the lineup function, and
writes this out as a text string. Decrypt, decrypts this text
string to reveal which where the real data is.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decrypt(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decrypt_+3A_...">...</code></td>
<td>
<p>character vector to decrypt</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>decrypt('0uXR2p rut L2O2')
</code></pre>

<hr>
<h2 id='distmet'>Empirical distribution of the distance</h2><span id='topic+distmet'></span>

<h3>Description</h3>

<p>The empirical distribution of the distance measures is calculated based on the mean
distance of each of the null plots from the other null plots in a lineup. At this moment
this method works only for <code><a href="#topic+null_permute">null_permute</a></code> method. This function helps get some
assessment of whether the actual data plot is very different from the null plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distmet(
  lineup.dat,
  var,
  met,
  method,
  pos,
  repl = 1000,
  dist.arg = NULL,
  m = 20
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distmet_+3A_lineup.dat">lineup.dat</code></td>
<td>
<p>lineup data</p>
</td></tr>
<tr><td><code id="distmet_+3A_var">var</code></td>
<td>
<p>a vector of names of the variables to be used</p>
</td></tr>
<tr><td><code id="distmet_+3A_met">met</code></td>
<td>
<p>distance metric needed to calculate the distance as a character</p>
</td></tr>
<tr><td><code id="distmet_+3A_method">method</code></td>
<td>
<p>method for generating null data sets</p>
</td></tr>
<tr><td><code id="distmet_+3A_pos">pos</code></td>
<td>
<p>position of the observed data in the lineup</p>
</td></tr>
<tr><td><code id="distmet_+3A_repl">repl</code></td>
<td>
<p>number of sets of null plots selected to obtain the distribution; 1000 by
default</p>
</td></tr>
<tr><td><code id="distmet_+3A_dist.arg">dist.arg</code></td>
<td>
<p>a list or vector of inputs for the distance metric met; NULL by default</p>
</td></tr>
<tr><td><code id="distmet_+3A_m">m</code></td>
<td>
<p>the number of plots in the lineup; m = 20 by default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>lineup has the data used for the calculations
</p>
<p>null_values contains new null samples from which to compare nulls in lineup
</p>
<p>diff difference in distance between nulls and actual data and that of the null
that is most different from other nulls. A negative value means that the actual data
plot is similar to the null plots.
</p>
<p>closest list of the five closest nulls to the actual data plot
</p>
<p>pos position of the actual data plot in the lineup
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Each of these examples uses a small number of nulls (m=8), and a small number of
# repeated sampling from the null distribution (repl=100), to make it faster to run.
# In your own examples you should think about increasing each of these, at least to the defaults.
## Not run: 
if (require('dplyr')) {
  d &lt;- lineup(null_permute('mpg'), mtcars, pos = 1)
  dd &lt;- distmet(d, var = c('mpg', 'wt'),
    'reg_dist', null_permute('mpg'), pos = 1, repl = 100, m = 8)
  distplot(dd, m=8)
}

## End(Not run)

## Not run: 
d &lt;- lineup(null_permute('mpg'), mtcars, pos=4, n=8)
library(ggplot2)
ggplot(d, aes(mpg, wt)) + geom_point() + facet_wrap(~ .sample, ncol=4)
if (require('dplyr')) {
  dd &lt;- distmet(d, var = c('mpg', 'wt'), 'bin_dist', null_permute('mpg'),
    pos = 4, repl = 100, dist.arg = list(lineup.dat = d, X.bin = 5,
    Y.bin = 5), m = 8)
  distplot(dd, m=8)
}

## End(Not run)

# Example using bin_dist
## Not run: 
if (require('dplyr')) {
  d &lt;- lineup(null_permute('mpg'), mtcars, pos = 1)
  library(ggplot2)
  ggplot(d, aes(mpg, wt)) + geom_point() + facet_wrap(~ .sample, ncol=5)
  dd &lt;- distmet(d, var = c('mpg', 'wt'),
    'bin_dist', null_permute('mpg'), pos = 1, repl = 500,
    dist.arg = list(lineup.dat = d, X.bin = 5, Y.bin = 5))
  distplot(dd)
}

## End(Not run)

# Example using uni_dist
## Not run: 
mod &lt;- lm(wt ~ mpg, data = mtcars)
resid.dat &lt;- data.frame(residual = mod$resid)
d &lt;- lineup(null_dist('residual', dist = 'normal'), resid.dat, pos=19)
ggplot(d, aes(residual)) + geom_histogram(binwidth = 0.25) + facet_wrap(~ .sample, ncol=5)
if (require('dplyr')) {
  dd &lt;- distmet(d, var = 'residual', 'uni_dist', null_dist('residual',
    dist = 'normal'), pos = 19, repl = 500)
  distplot(dd)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='distplot'>Plotting the distribution of the distance measure</h2><span id='topic+distplot'></span>

<h3>Description</h3>

<p>The permutation distribution of the distance measure is plotted with the distances for
the null plots. Distance measure values for the null plots and the true plot are overlaid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distplot(dat, m = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distplot_+3A_dat">dat</code></td>
<td>
<p>output from <code><a href="#topic+distmet">distmet</a></code></p>
</td></tr>
<tr><td><code id="distplot_+3A_m">m</code></td>
<td>
<p>the number of plots in the lineup; m = 20 by default</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (require('dplyr')) {
  d &lt;- lineup(null_permute('mpg'), mtcars, pos = 1)
  library(ggplot2)
  ggplot(d, aes(mpg, wt)) + geom_point() + facet_wrap(~.sample)
  distplot(distmet(d, var = c('mpg', 'wt'), 'reg_dist', null_permute('mpg'),
    pos = 1, repl = 100, m = 8), m = 8)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='electoral'>Polls and election results from the 2012 US Election</h2><span id='topic+electoral'></span>

<h3>Description</h3>

<p>Polls and election results from the 2012 US Election
</p>


<h3>Format</h3>

<p>A list with two data frames:
polls is a data frame of 51 rows and 4 variables
</p>

<dl>
<dt>State</dt><dd><p>State name</p>
</dd>
<dt>Electoral.vote</dt><dd><p>Number of electoral votes in the 2012 election</p>
</dd>
<dt>Margin</dt><dd><p>Margin between the parties with the highest number of votes and second highest number of votes.
These margins are based on polls.</p>
</dd>
<dt>Democrat</dt><dd><p>logical vector True, if the democratic party is  the majority party in this state. </p>
</dd>
</dl>

<p>'election' is a data frame of 51 rows and 5 variables
</p>

<dl>
<dt>State</dt><dd><p>State name</p>
</dd>
<dt>Candidate</dt><dd><p>character string of the winner: Romney or Obama</p>
</dd>
<dt>Electoral.vote</dt><dd><p>Number of electoral votes in the 2012 election</p>
</dd>
<dt>Margin</dt><dd><p>Margin between the parties with the highest number of votes and second highest number of votes.
These margins are based on the actual election outcome</p>
</dd>
<dt>Democrat</dt><dd><p>logical vector True, if the democratic party is  the majority party in this state. </p>
</dd>
</dl>

<hr>
<h2 id='find_plot_data'>Find plot data.
If data is not specified, this function will attempt to find the data
corresponding to the last ggplot2 created or displayed. This will work
in most situations where you are creating the plot and immediately
displaying it, but may not work in other situations.  In those cases,
please specify the data explicitly.</h2><span id='topic+find_plot_data'></span>

<h3>Description</h3>

<p>Find plot data.
If data is not specified, this function will attempt to find the data
corresponding to the last ggplot2 created or displayed. This will work
in most situations where you are creating the plot and immediately
displaying it, but may not work in other situations.  In those cases,
please specify the data explicitly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_plot_data(data)
</code></pre>

<hr>
<h2 id='lal'>Los Angeles Lakers play-by-play data.</h2><span id='topic+lal'></span>

<h3>Description</h3>

<p>Play by play data from all games played by the Los Angeles lakers in the
2008/2009 season.
</p>

<hr>
<h2 id='lineup'>The line-up protocol.</h2><span id='topic+lineup'></span>

<h3>Description</h3>

<p>In this protocol the plot of the real data is embedded amongst a field of
plots of data generated to be consistent with some null hypothesis.
If the observe can pick the real data as different from the others, this
lends weight to the statistical significance of the structure in the plot.
The protocol is described in Buja, Cook, Hofmann, Lawrence,
Lee, Swayne, Wickham (2009) Statistical inference for exploratory data
analysis and model diagnostics, Phil. Trans. R. Soc. A, 367, 4361-4383.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lineup(method, true = NULL, n = 20, pos = sample(n, 1), samples = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lineup_+3A_method">method</code></td>
<td>
<p>method for generating null data sets</p>
</td></tr>
<tr><td><code id="lineup_+3A_true">true</code></td>
<td>
<p>true data set. If <code>NULL</code>, <code><a href="#topic+find_plot_data">find_plot_data</a></code>
will attempt to extract it from the current ggplot2 plot.</p>
</td></tr>
<tr><td><code id="lineup_+3A_n">n</code></td>
<td>
<p>total number of samples to generate (including true data)</p>
</td></tr>
<tr><td><code id="lineup_+3A_pos">pos</code></td>
<td>
<p>position of true data.  Leave missing to pick position at
random.  Encryped position will be printed on the command line,
<code><a href="#topic+decrypt">decrypt</a></code> to understand.</p>
</td></tr>
<tr><td><code id="lineup_+3A_samples">samples</code></td>
<td>
<p>samples generated under the null hypothesis. Only specify
this if you don't want lineup to generate the data for you.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generate n - 1 null datasets and randomly position the true data.  If you
pick the real data as being noticeably different, then you have formally
established that it is different to with p-value 1/n.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
ggplot(lineup(null_permute('mpg'), mtcars), aes(mpg, wt)) +
  geom_point() +
  facet_wrap(~ .sample)
ggplot(lineup(null_permute('cyl'), mtcars),
       aes(mpg, .sample, colour = factor(cyl))) +
       geom_point()
</code></pre>

<hr>
<h2 id='null_dist'>Generate null data with a specific distribution.</h2><span id='topic+null_dist'></span>

<h3>Description</h3>

<p>Null hypothesis: variable has specified distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>null_dist(var, dist, params = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="null_dist_+3A_var">var</code></td>
<td>
<p>variable name</p>
</td></tr>
<tr><td><code id="null_dist_+3A_dist">dist</code></td>
<td>
<p>distribution name. One of: beta, cauchy, chisq,
exp, f, gamma, geom, lnorm, logis,
nbinom, binom, norm, pois, t, unif, weibull</p>
</td></tr>
<tr><td><code id="null_dist_+3A_params">params</code></td>
<td>
<p>list of parameters of distribution. If <code>NULL</code>, will
use <code><a href="MASS.html#topic+fitdistr">fitdistr</a></code> to estimate them.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function that given <code>data</code> generates a null data set.
For use with <code><a href="#topic+lineup">lineup</a></code> or <code><a href="#topic+rorschach">rorschach</a></code>
</p>


<h3>See Also</h3>

<p>null_permute, null_lm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dframe &lt;- data.frame(x = rnorm(150))
library(ggplot2)
# three histograms of normally distributed values
ggplot(
  data=rorschach(method=null_dist("x", "norm"), n = 3, true=dframe)
  ) +
  geom_histogram(aes(x=x, y=..density..), binwidth=0.25) +
  facet_grid(.~.sample) +
  geom_density(aes(x=x), colour="steelblue", size=1)

# uniform distributions are not as easy to recognize as such
dframe$x = runif(150)
ggplot(
  data=rorschach(method=null_dist("x", "uniform",
                 params=list(min=0, max=1)),
  n = 3, true=dframe)) +
  geom_histogram(aes(x=x, y=..density..), binwidth=0.1) +
  facet_grid(.~.sample) +
  geom_density(aes(x=x), colour="steelblue", size=1)
</code></pre>

<hr>
<h2 id='null_gen'>Computing th distance for the null plots</h2><span id='topic+null_gen'></span>

<h3>Description</h3>

<p>Computing th distance for the null plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>null_gen(lineup.dat, null, met, method, m, dist.arg)
</code></pre>

<hr>
<h2 id='null_lm'>Generate null data with null residuals from a model.</h2><span id='topic+null_lm'></span>

<h3>Description</h3>

<p>Null hypothesis: variable is linear combination of predictors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>null_lm(f, method = "rotate", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="null_lm_+3A_f">f</code></td>
<td>
<p>model specification formula, as defined by <code><a href="stats.html#topic+lm">lm</a></code></p>
</td></tr>
<tr><td><code id="null_lm_+3A_method">method</code></td>
<td>
<p>method for generating null residuals.  Built in methods
'rotate', 'pboot' and 'boot' are defined by <code><a href="#topic+resid_rotate">resid_rotate</a></code>,
<code><a href="#topic+resid_pboot">resid_pboot</a></code> and <code><a href="#topic+resid_boot">resid_boot</a></code> respectively</p>
</td></tr>
<tr><td><code id="null_lm_+3A_...">...</code></td>
<td>
<p>other arguments passedd onto <code>method</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function that given <code>data</code> generates a null data set.
For use with <code><a href="#topic+lineup">lineup</a></code> or <code><a href="#topic+rorschach">rorschach</a></code>
</p>


<h3>See Also</h3>

<p>null_permute, null_dist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace('reshape2', quietly = TRUE)) {
data("tips", package = "reshape2")
x &lt;- lm(tip ~ total_bill, data = tips)
tips.reg &lt;- data.frame(tips, .resid = residuals(x), .fitted = fitted(x))
library(ggplot2)
ggplot(lineup(null_lm(tip ~ total_bill, method = 'rotate'), tips.reg)) +
  geom_point(aes(x = total_bill, y = .resid)) +
  facet_wrap(~ .sample)
}
</code></pre>

<hr>
<h2 id='null_permute'>Generate null data by permuting a variable.</h2><span id='topic+null_permute'></span>

<h3>Description</h3>

<p>Null hypothesis: variable is independent of others
</p>


<h3>Usage</h3>

<pre><code class='language-R'>null_permute(var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="null_permute_+3A_var">var</code></td>
<td>
<p>name of variable to permute</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function that given <code>data</code> generates a null data set.
For use with <code><a href="#topic+lineup">lineup</a></code> or <code><a href="#topic+rorschach">rorschach</a></code>
</p>


<h3>See Also</h3>

<p>null_lm, null_dist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtcars)
library(ggplot2)
ggplot(data=rorschach(method=null_permute("mpg"), n = 3, true=mtcars)) +
geom_boxplot(aes(x=factor(cyl), y=mpg, fill=factor(cyl))) +facet_grid(.~.sample) +
theme(legend.position="none", aspect.ratio=1)
</code></pre>

<hr>
<h2 id='null_ts'>Generate null data by simulating from a time series model.</h2><span id='topic+null_ts'></span>

<h3>Description</h3>

<p>Null hypothesis: data follows a time series model using auto.arima from the forecast package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>null_ts(var, modelfn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="null_ts_+3A_var">var</code></td>
<td>
<p>variable to model as a time series</p>
</td></tr>
<tr><td><code id="null_ts_+3A_modelfn">modelfn</code></td>
<td>
<p>method for simulating from ts model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function that given <code>data</code> generates a null data set.
For use with <code><a href="#topic+lineup">lineup</a></code> or <code><a href="#topic+rorschach">rorschach</a></code>
</p>


<h3>See Also</h3>

<p>null_model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(forecast)
require(ggplot2)
require(dplyr)
data(aud)
l &lt;- lineup(null_ts("rate", auto.arima), aud)
ggplot(l, aes(x=date, y=rate)) + geom_line() +
  facet_wrap(~.sample, scales="free_y") +
  theme(axis.text = element_blank()) +
  xlab("") + ylab("")
l_dif &lt;- l %&gt;%
  group_by(.sample) %&gt;%
  mutate(d=c(NA,diff(rate))) %&gt;%
  ggplot(aes(x=d)) + geom_density() +
  facet_wrap(~.sample)
</code></pre>

<hr>
<h2 id='opt_bin_diff'>Finds the number of bins in x and y direction which gives the maximum binned distance.</h2><span id='topic+opt_bin_diff'></span>

<h3>Description</h3>

<p>This function finds the optimal number of bins in both x and y direction which should
be used to calculate the binned distance. The binned distance is calculated for each
combination of provided choices of number of bins in x and y direction and finds the
difference using <code>calc_diff</code> for each combination. The combination for which the
difference is maximum should be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opt_bin_diff(
  lineup.dat,
  var,
  xlow,
  xhigh,
  ylow,
  yhigh,
  pos,
  plot = FALSE,
  m = 20
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opt_bin_diff_+3A_lineup.dat">lineup.dat</code></td>
<td>
<p>lineup data to get the lineup</p>
</td></tr>
<tr><td><code id="opt_bin_diff_+3A_var">var</code></td>
<td>
<p>a list of names of the variables to be used to calculate the difference</p>
</td></tr>
<tr><td><code id="opt_bin_diff_+3A_xlow">xlow</code></td>
<td>
<p>the lowest value of number of bins on the x-direction</p>
</td></tr>
<tr><td><code id="opt_bin_diff_+3A_xhigh">xhigh</code></td>
<td>
<p>the highest value of number of bins on the x-direction</p>
</td></tr>
<tr><td><code id="opt_bin_diff_+3A_ylow">ylow</code></td>
<td>
<p>the lowest value of number of bins on the y-direction</p>
</td></tr>
<tr><td><code id="opt_bin_diff_+3A_yhigh">yhigh</code></td>
<td>
<p>the highest value of number of bins on the y-direction</p>
</td></tr>
<tr><td><code id="opt_bin_diff_+3A_pos">pos</code></td>
<td>
<p>position of the true plot in the lineup</p>
</td></tr>
<tr><td><code id="opt_bin_diff_+3A_plot">plot</code></td>
<td>
<p>LOGICAL; if true, returns a tile plot for the combinations
of number of bins with the differences as weights</p>
</td></tr>
<tr><td><code id="opt_bin_diff_+3A_m">m</code></td>
<td>
<p>number of plots in the lineup, by default m = 20</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe with the number of bins and differences
the maximum mean distance of the null plots
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require('dplyr')){
opt_bin_diff(lineup(null_permute('mpg'), mtcars, pos = 1), var = c('mpg', 'wt'),
2, 5, 4, 8, pos = 1, plot = TRUE, m = 8)
}
</code></pre>

<hr>
<h2 id='pvisual'>P-value calculations.</h2><span id='topic+pvisual'></span>

<h3>Description</h3>

<p>These set of functions allow the user to calculate a p-value from the lineup after
it has been evaluated by K independent observers. The different functions
accommodate different lineup construction and showing to observers.
Details are in the papers Majumder et al (2012) JASA, and Hofmann et al (2015).
We distinguish between three different scenarios:
</p>

<ul>
<li><p> Scenario I: in each of K evaluations a different data set and a different set of (m-1) null plots is shown.
</p>
</li>
<li><p> Scenario II: in each of K evaluations the same data set but a different set of (m-1) null plots is shown.
</p>
</li>
<li><p> Scenario III: the same lineup, i.e. same data and same set of null plots, is shown to K different observers.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>pvisual(
  x,
  K,
  m = 20,
  N = 10000,
  type = "scenario3",
  xp = 1,
  target = 1,
  upper.tail = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pvisual_+3A_x">x</code></td>
<td>
<p>number of observed picks of the data plot</p>
</td></tr>
<tr><td><code id="pvisual_+3A_k">K</code></td>
<td>
<p>number of evaluations</p>
</td></tr>
<tr><td><code id="pvisual_+3A_m">m</code></td>
<td>
<p>size of the lineup</p>
</td></tr>
<tr><td><code id="pvisual_+3A_n">N</code></td>
<td>
<p>MC parameter: number of replicates on which MC probabilities are based. Higher number of replicates will decrease MC variability.</p>
</td></tr>
<tr><td><code id="pvisual_+3A_type">type</code></td>
<td>
<p>type of simulation used: scenario 3 assumes that the same lineup is shown in all K evaluations</p>
</td></tr>
<tr><td><code id="pvisual_+3A_xp">xp</code></td>
<td>
<p>exponent used, defaults to 1</p>
</td></tr>
<tr><td><code id="pvisual_+3A_target">target</code></td>
<td>
<p>integer value identifying the location of the data plot</p>
</td></tr>
<tr><td><code id="pvisual_+3A_upper.tail">upper.tail</code></td>
<td>
<p>compute probabilities P(X &gt;= x). Be aware that the use of this parameter is not consistent with the other distribution functions in base. There, a value of P(X &gt; x) is computed for upper.tail=TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector/data frame. For comparison a p value based on a binomial distribution is provided as well.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pvisual(15, 20, m=3) # triangle test
</code></pre>

<hr>
<h2 id='reg_dist'>Distance based on the regression parameters</h2><span id='topic+reg_dist'></span>

<h3>Description</h3>

<p>Dataset X is binned into 5 bins in x-direction. A regression line is fitted to the
data in each bin and the regression coefficients are noted. Same is done for
dataset PX. An euclidean distance is calculated between the two sets of regression
parameters. If the relationship between X and PX looks linear, number of bins should
be equal to 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reg_dist(X, PX, nbins = 1, intercept = TRUE, scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reg_dist_+3A_x">X</code></td>
<td>
<p>a data.frame with two variables, the first column giving
the explanatory variable and the second column giving the response
variable</p>
</td></tr>
<tr><td><code id="reg_dist_+3A_px">PX</code></td>
<td>
<p>another data.frame with two variables, the first column giving
the explanatory variable and the second column giving the response
variable</p>
</td></tr>
<tr><td><code id="reg_dist_+3A_nbins">nbins</code></td>
<td>
<p>number of bins on the x-direction, by default nbins = 1</p>
</td></tr>
<tr><td><code id="reg_dist_+3A_intercept">intercept</code></td>
<td>
<p>include the distances between intercepts?</p>
</td></tr>
<tr><td><code id="reg_dist_+3A_scale">scale</code></td>
<td>
<p>logical value: should the variables be scaled before computing regression coefficients?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>distance between X and PX
</p>


<h3>Examples</h3>

<pre><code class='language-R'>with(mtcars, reg_dist(data.frame(wt, mpg), data.frame(sample(wt), mpg)))
</code></pre>

<hr>
<h2 id='resid_boot'>Bootstrap residuals.</h2><span id='topic+resid_boot'></span>

<h3>Description</h3>

<p>For use with <code><a href="#topic+null_lm">null_lm</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resid_boot(model, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resid_boot_+3A_model">model</code></td>
<td>
<p>to extract residuals from</p>
</td></tr>
<tr><td><code id="resid_boot_+3A_data">data</code></td>
<td>
<p>used to fit model</p>
</td></tr>
</table>

<hr>
<h2 id='resid_pboot'>Parametric bootstrap residuals.</h2><span id='topic+resid_pboot'></span>

<h3>Description</h3>

<p>For use with <code><a href="#topic+null_lm">null_lm</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resid_pboot(model, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resid_pboot_+3A_model">model</code></td>
<td>
<p>to extract residuals from</p>
</td></tr>
<tr><td><code id="resid_pboot_+3A_data">data</code></td>
<td>
<p>used to fit model</p>
</td></tr>
</table>

<hr>
<h2 id='resid_rotate'>Rotation residuals.</h2><span id='topic+resid_rotate'></span>

<h3>Description</h3>

<p>For use with <code><a href="#topic+null_lm">null_lm</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resid_rotate(model, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resid_rotate_+3A_model">model</code></td>
<td>
<p>to extract residuals from</p>
</td></tr>
<tr><td><code id="resid_rotate_+3A_data">data</code></td>
<td>
<p>used to fit model</p>
</td></tr>
</table>

<hr>
<h2 id='resid_sigma'>Residuals simulated by a normal model, with specified sigma</h2><span id='topic+resid_sigma'></span>

<h3>Description</h3>

<p>For use with <code><a href="#topic+null_lm">null_lm</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resid_sigma(model, data, sigma = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resid_sigma_+3A_model">model</code></td>
<td>
<p>to extract residuals from</p>
</td></tr>
<tr><td><code id="resid_sigma_+3A_data">data</code></td>
<td>
<p>used to fit model</p>
</td></tr>
<tr><td><code id="resid_sigma_+3A_sigma">sigma</code></td>
<td>
<p>a specific sigma to model</p>
</td></tr>
</table>

<hr>
<h2 id='rorschach'>The Rorschach protocol.</h2><span id='topic+rorschach'></span>

<h3>Description</h3>

<p>This protocol is used to calibrate the eyes for variation due to sampling.
All plots are typically null data sets, data that is consistent with a null
hypothesis. The protocol is described in Buja, Cook, Hofmann, Lawrence,
Lee, Swayne, Wickham (2009) Statistical inference for exploratory data
analysis and model diagnostics, Phil. Trans. R. Soc. A, 367, 4361-4383.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rorschach(method, true = NULL, n = 20, p = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rorschach_+3A_method">method</code></td>
<td>
<p>method for generating null data sets</p>
</td></tr>
<tr><td><code id="rorschach_+3A_true">true</code></td>
<td>
<p>true data set. If <code>NULL</code>, <code><a href="#topic+find_plot_data">find_plot_data</a></code>
will attempt to extract it from the current ggplot2 plot.</p>
</td></tr>
<tr><td><code id="rorschach_+3A_n">n</code></td>
<td>
<p>total number of samples to generate (including true data)</p>
</td></tr>
<tr><td><code id="rorschach_+3A_p">p</code></td>
<td>
<p>probability of including true data with null data.</p>
</td></tr>
</table>

<hr>
<h2 id='sample_size'>Sample size calculator</h2><span id='topic+sample_size'></span>

<h3>Description</h3>

<p>This function calculates a table of sample sizes for
with an experiment, given a lineup size, and
estimates of the detection rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_size(n = 53:64, m = 20, pA = seq(1/20, 1/3, 0.01), conf = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_size_+3A_n">n</code></td>
<td>
<p>range of sample sizes to check, default is 53:64</p>
</td></tr>
<tr><td><code id="sample_size_+3A_m">m</code></td>
<td>
<p>linup size, default 20</p>
</td></tr>
<tr><td><code id="sample_size_+3A_pa">pA</code></td>
<td>
<p>range of estimated detection rates to consider,
default is seq(1/20, 1/3, 0.01)</p>
</td></tr>
<tr><td><code id="sample_size_+3A_conf">conf</code></td>
<td>
<p>confidence level to use to simulate from binomial</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>pow &lt;- sample_size()
pow
library(ggplot2)
library(viridis)
ggplot(pow, aes(x=n, y=pA, fill=prob, group=pA)) +
  geom_tile() +
  scale_fill_viridis_c("power") +
  ylab("detect rate (pA)") + xlab("sample size (n)") +
  theme_bw()
</code></pre>

<hr>
<h2 id='sep_dist'>Distance based on separation of clusters</h2><span id='topic+sep_dist'></span>

<h3>Description</h3>

<p>The separation between clusters is defined by the minimum distances of a point in
the cluster to a point in another cluster. The number of clusters are provided.
If not, the hierarchical clustering method is used to obtain the clusters. The
separation between the clusters for dataset X is calculated. Same is done for
dataset PX. An euclidean distance is then calculated between these separation for
X and PX.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sep_dist(X, PX, clustering = FALSE, nclust = 3, type = "separation")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sep_dist_+3A_x">X</code></td>
<td>
<p>a data.frame with two or three columns, the first two columns
providing the dataset</p>
</td></tr>
<tr><td><code id="sep_dist_+3A_px">PX</code></td>
<td>
<p>a data.frame with two or three columns, the first two columns
providing the dataset</p>
</td></tr>
<tr><td><code id="sep_dist_+3A_clustering">clustering</code></td>
<td>
<p>LOGICAL; if TRUE, the third column is used as the
clustering variable, by default FALSE</p>
</td></tr>
<tr><td><code id="sep_dist_+3A_nclust">nclust</code></td>
<td>
<p>the number of clusters to be obtained by hierarchical
clustering, by default nclust = 3</p>
</td></tr>
<tr><td><code id="sep_dist_+3A_type">type</code></td>
<td>
<p>character string to specify which measure to use for distance, see ?cluster.stats for details</p>
</td></tr>
</table>


<h3>Value</h3>

<p>distance between X and PX
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require('fpc')) {
with(mtcars, sep_dist(data.frame(wt, mpg, as.numeric(as.factor(mtcars$cyl))),
              data.frame(sample(wt), mpg, as.numeric(as.factor(mtcars$cyl))),
              clustering = TRUE))
}

if (require('fpc')) {
with(mtcars, sep_dist(data.frame(wt, mpg, as.numeric(as.factor(mtcars$cyl))),
             data.frame(sample(wt), mpg, as.numeric(as.factor(mtcars$cyl))),
             nclust = 3))
}
</code></pre>

<hr>
<h2 id='turk_results'>Sample turk results</h2><span id='topic+turk_results'></span>

<h3>Description</h3>

<p>Subset of data from a Turk experiment, used to show how to compute power of a lineup
</p>

<hr>
<h2 id='uni_dist'>Distance for univariate data</h2><span id='topic+uni_dist'></span>

<h3>Description</h3>

<p>The first four moments is calculated for data X and data PX. An euclidean distance
is calculated between these moments for X and PX.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uni_dist(X, PX)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uni_dist_+3A_x">X</code></td>
<td>
<p>a data.frame where the first column is only used</p>
</td></tr>
<tr><td><code id="uni_dist_+3A_px">PX</code></td>
<td>
<p>another data.frame where the first column is only used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>distance between X and PX
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require('moments')){uni_dist(rnorm(100), rpois(100, 2))}
</code></pre>

<hr>
<h2 id='visual_power'>Power calculations.</h2><span id='topic+visual_power'></span>

<h3>Description</h3>

<p>This function simply counts the proportion of people who selected the data plot,
in a set of lineups. It adjusts for multiple picks by the same individual, by weighting
by the total number of choices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>visual_power(data, m = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="visual_power_+3A_data">data</code></td>
<td>
<p>summary of the results, containing columns id, pic_id, response, detected</p>
</td></tr>
<tr><td><code id="visual_power_+3A_m">m</code></td>
<td>
<p>size of the lineup</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of powers for each pic_id
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(turk_results)
visual_power(turk_results)
</code></pre>

<hr>
<h2 id='wasps'>Wasp gene expression data.</h2><span id='topic+wasps'></span>

<h3>Description</h3>

<p>Data from Toth et al (2010) used in Niladri Roy et al (2015)
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
