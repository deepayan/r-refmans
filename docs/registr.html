<!DOCTYPE html><html><head><title>Help for package registr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {registr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#amp_curve'><p>Simulate amplitude variance</p></a></li>
<li><a href='#bfpca'><p>Binary functional principal components analysis</p></a></li>
<li><a href='#bfpca_argPreparation'><p>Internal main preparation function for bfpca</p></a></li>
<li><a href='#bfpca_optimization'><p>Internal main optimization for bfpca</p></a></li>
<li><a href='#bs_deriv'><p>Nth derivative of spline basis</p></a></li>
<li><a href='#coarsen_index'><p>Coarsen an index vector to a given resolution</p></a></li>
<li><a href='#constraints'><p>Define constraints for optimization of warping functions</p></a></li>
<li><a href='#cov_hall'><p>Covariance estimation after Hall et al. (2008)</p></a></li>
<li><a href='#crossprods_irregular'><p>Crossproduct computation for highly irregular grids</p></a></li>
<li><a href='#crossprods_regular'><p>Crossproduct computation for mostly regular grids</p></a></li>
<li><a href='#data_clean'><p>Convert data to a <code>refund</code> object</p></a></li>
<li><a href='#deriv.inv.logit'><p>Estimate the derivative of the logit function</p></a></li>
<li><a href='#determine_npc'><p>Determine the number of FPCs based on the share of explained variance</p></a></li>
<li><a href='#ensure_proper_beta'><p>Correct slightly improper parameter vectors</p></a></li>
<li><a href='#expectedScores'><p>Calculate expected score and score variance for the current subject.</p></a></li>
<li><a href='#expectedXi'><p>Estimate variational parameter for the current subject.</p></a></li>
<li><a href='#fpca_gauss'><p>Functional principal components analysis via variational EM</p></a></li>
<li><a href='#fpca_gauss_argPreparation'><p>Internal main preparation function for fpca_gauss</p></a></li>
<li><a href='#fpca_gauss_optimization'><p>Internal main optimization for fpca_gauss</p></a></li>
<li><a href='#gfpca_twoStep'><p>Generalized functional principal component analysis</p></a></li>
<li><a href='#grid_subj_create'><p>Generate subject-specific grid (t_star)</p></a></li>
<li><a href='#growth_incomplete'><p>Berkeley Growth Study data with simulated incompleteness</p></a></li>
<li><a href='#initial_params'><p>Create initial parameters for (inverse) warping functions</p></a></li>
<li><a href='#lambdaF'><p>Apply lambda transformation of variational parameter.</p></a></li>
<li><a href='#loss_h'><p>Loss function for registration step optimization</p></a></li>
<li><a href='#loss_h_gradient'><p>Gradient of loss function for registration step</p></a></li>
<li><a href='#mean_curve'><p>Simulate mean curve</p></a></li>
<li><a href='#mean_sim'><p>Simulate mean</p></a></li>
<li><a href='#nhanes'><p>NHANES activity data</p></a></li>
<li><a href='#piecewise_linear2_hinv'><p>Create two-parameter piecewise linear (inverse) warping functions</p></a></li>
<li><a href='#plot.fpca'><p>Plot the results of a functional PCA</p></a></li>
<li><a href='#psi1_sim'><p>Simulate PC1</p></a></li>
<li><a href='#psi2_sim'><p>Simulate PC2</p></a></li>
<li><a href='#register_fpca'><p>Register curves using constrained optimization and GFPCA</p></a></li>
<li><a href='#registr'><p>Register Exponential Family Functional Data</p></a></li>
<li><a href='#registr_oneCurve'><p>Internal function to register one curve</p></a></li>
<li><a href='#simulate_functional_data'><p>Simulate functional data</p></a></li>
<li><a href='#simulate_unregistered_curves'><p>Simulate unregistered curves</p></a></li>
<li><a href='#squareTheta'><p>Calculate quadratic form of spline basis functions for the current subject.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Curve Registration for Exponential Family Functional Data</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A method for performing joint registration and functional principal
    component analysis for curves (functional data) that are generated from exponential family distributions. This 
    mainly implements the algorithms described in 'Wrobel et al. (2019)' &lt;<a href="https://doi.org/10.1111%2Fbiom.12963">doi:10.1111/biom.12963</a>&gt; and further adapts them to potentially
    incomplete curves where (some) curves are not observed from the beginning and/or until the end of the common domain. Curve registration 
    can be used to better understand patterns in functional data by separating curves into phase and amplitude variability.
    This software handles both binary and continuous functional data, and is
    especially applicable in accelerometry and wearable technology.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>tidyr, magrittr, dplyr, pbs, Rcpp (&ge; 0.11.5), parallel, MASS,
utils, gamm4, lme4, mgcv, purrr, Matrix</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, cowplot, ggplot2, pbapply,
fastglm</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-26 21:47:56 UTC; wrobelj</td>
</tr>
<tr>
<td>Author:</td>
<td>Julia Wrobel <a href="https://orcid.org/0000-0001-6783-1421"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Alexander Bauer [aut],
  Erin McDonnell [aut],
  Fabian Scheipl [ctb],
  Jeff Goldsmith [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Julia Wrobel &lt;julia.wrobel@cuanschutz.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-02 21:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='amp_curve'>Simulate amplitude variance</h2><span id='topic+amp_curve'></span>

<h3>Description</h3>

<p>This function generates amplitudes for simulated accelerometer data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>amp_curve(grid, period = 2 * pi, spline_based = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="amp_curve_+3A_grid">grid</code></td>
<td>
<p>Grid of x values over which to evaluate the function.</p>
</td></tr>
<tr><td><code id="amp_curve_+3A_period">period</code></td>
<td>
<p>Controls the period of the mean curve</p>
</td></tr>
<tr><td><code id="amp_curve_+3A_spline_based">spline_based</code></td>
<td>
<p>If FALSE curve is constructed using sine and cosine functions,
if TRUE, curve is constructed using B-spline basis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector.
</p>

<hr>
<h2 id='bfpca'>Binary functional principal components analysis</h2><span id='topic+bfpca'></span>

<h3>Description</h3>

<p>Function used in the FPCA step for registering binary functional data,
called by <code><a href="#topic+register_fpca">register_fpca</a></code> when <code>family = "binomial"</code>. 
This method uses a variational EM algorithm to estimate scores and principal components for 
binary functional data. <br /> <br />
The number of functional principal components (FPCs) can either be specified
directly (argument <code>npc</code>) or chosen based on the explained share of
variance (<code>npc_varExplained</code>). In the latter case, the explained share of
variance and accordingly the number of FPCs is estimated before the main
estimation step by once running the FPCA with <code>npc = 20</code> (and
correspondingly <code>Kt = 20</code>). Doing so, we approximate the overall
variance in the data <code>Y</code> with the variance represented by the FPC basis
with 20 FPCs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bfpca(
  Y,
  npc = NULL,
  npc_varExplained = NULL,
  Kt = 8,
  maxiter = 50,
  t_min = NULL,
  t_max = NULL,
  print.iter = FALSE,
  row_obj = NULL,
  seed = 1988,
  periodic = FALSE,
  error_thresh = 1e-04,
  verbose = 1,
  subsample = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bfpca_+3A_y">Y</code></td>
<td>
<p>Dataframe. Should have variables id, value, index.</p>
</td></tr>
<tr><td><code id="bfpca_+3A_npc">npc</code></td>
<td>
<p>The number of functional principal components (FPCs)
has to be specified either directly as <code>npc</code> or based on their explained
share of variance. In the latter case, <code>npc_varExplained</code> has to be set
to a share between 0 and 1.</p>
</td></tr>
<tr><td><code id="bfpca_+3A_npc_varexplained">npc_varExplained</code></td>
<td>
<p>The number of functional principal components (FPCs)
has to be specified either directly as <code>npc</code> or based on their explained
share of variance. In the latter case, <code>npc_varExplained</code> has to be set
to a share between 0 and 1.</p>
</td></tr>
<tr><td><code id="bfpca_+3A_kt">Kt</code></td>
<td>
<p>Number of B-spline basis functions used to estimate mean functions
and functional principal components. Default is 8. If <code>npc_varExplained</code>
is used, <code>Kt</code> is set to 20.</p>
</td></tr>
<tr><td><code id="bfpca_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations to perform for EM algorithm. Default is 50.</p>
</td></tr>
<tr><td><code id="bfpca_+3A_t_min">t_min</code></td>
<td>
<p>Minimum value to be evaluated on the time domain.</p>
</td></tr>
<tr><td><code id="bfpca_+3A_t_max">t_max</code></td>
<td>
<p>Maximum value to be evaluated on the time domain.</p>
</td></tr>
<tr><td><code id="bfpca_+3A_print.iter">print.iter</code></td>
<td>
<p>Prints current error and iteration</p>
</td></tr>
<tr><td><code id="bfpca_+3A_row_obj">row_obj</code></td>
<td>
<p>If NULL, the function cleans the data and calculates row indices. 
Keep this NULL if you are using standalone <code>register</code> function.</p>
</td></tr>
<tr><td><code id="bfpca_+3A_seed">seed</code></td>
<td>
<p>Set seed for reproducibility. Defaults to 1988.</p>
</td></tr>
<tr><td><code id="bfpca_+3A_periodic">periodic</code></td>
<td>
<p>If TRUE, uses periodic b-spline basis functions. Default is FALSE.</p>
</td></tr>
<tr><td><code id="bfpca_+3A_error_thresh">error_thresh</code></td>
<td>
<p>Error threshold to end iterations. Defaults to 0.0001.</p>
</td></tr>
<tr><td><code id="bfpca_+3A_verbose">verbose</code></td>
<td>
<p>Can be set to integers between 0 and 4 to control the level of
detail of the printed diagnostic messages. Higher numbers lead to more detailed
messages. Defaults to 1.</p>
</td></tr>
<tr><td><code id="bfpca_+3A_subsample">subsample</code></td>
<td>
<p>if the number of rows of the data is greater than 
10 million rows, the 'id' values are subsampled to get the mean coefficients.</p>
</td></tr>
<tr><td><code id="bfpca_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to or from other functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>fpca</code> containing:
</p>
<table>
<tr><td><code>fpca_type</code></td>
<td>
<p>Information that FPCA was performed with the 'variationEM' approach,
in contrast to registr::gfpca_twoStep.</p>
</td></tr>
<tr><td><code>t_vec</code></td>
<td>
<p>Time vector over which the mean <code>mu</code> and the functional principal
components <code>efunctions</code> were evaluated.</p>
</td></tr>
<tr><td><code>knots</code></td>
<td>
<p>Cutpoints for B-spline basis used to rebuild <code>alpha</code>.</p>
</td></tr>
<tr><td><code>efunctions</code></td>
<td>
<p><code class="reqn">D \times npc</code> matrix of estimated FPC basis functions.</p>
</td></tr>
<tr><td><code>evalues</code></td>
<td>
<p>Estimated variance of the FPC scores.</p>
</td></tr>
<tr><td><code>evalues_sum</code></td>
<td>
<p>Approximation of the overall variance in <code>Y</code>, based
on an initial run of the FPCA with <code>npc = 20</code>. Is <code>NULL</code> if
<code>npc_varExplained</code> was not specified.</p>
</td></tr>
<tr><td><code>npc</code></td>
<td>
<p>number of FPCs.</p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p><code class="reqn">I \times npc</code> matrix of estimated FPC scores.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>Estimated population-level mean.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>Estimated population-level mean. Same value as <code>alpha</code> but included for compatibility
with <code>refund.shiny</code> package.</p>
</td></tr>
<tr><td><code>subject_coefs</code></td>
<td>
<p>B-spline basis coefficients used to construct subject-specific means. 
For use in <code>registr()</code> function.</p>
</td></tr>
<tr><td><code>Yhat</code></td>
<td>
<p>FPC approximation of subject-specific means, before applying the
response function.</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>The observed data.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p><code>binomial</code>, for compatibility with <code>refund.shiny</code> package.</p>
</td></tr>
<tr><td><code>error</code></td>
<td>
<p>vector containing error for each iteration of the algorithm.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Julia Wrobel <a href="mailto:julia.wrobel@cuanschutz.edu">julia.wrobel@cuanschutz.edu</a>,
Jeff Goldsmith <a href="mailto:ajg2202@cumc.columbia.edu">ajg2202@cumc.columbia.edu</a>,
Alexander Bauer <a href="mailto:alexander.bauer@stat.uni-muenchen.de">alexander.bauer@stat.uni-muenchen.de</a>
</p>


<h3>References</h3>

<p>Jaakkola, T. S. and Jordan, M. I. (1997).
A variational approach to Bayesian logistic regression models and their extensions. 
<em>Proceedings of the Sixth International Workshop on Artificial Intelligence 
and Statistics</em>.
</p>
<p>Tipping, M. E. (1999). Probabilistic Visualisation of High-dimensional binary data.
<em>Advances in neural information processing systems</em>, 592&ndash;598.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Y = simulate_functional_data()$Y

# estimate 2 FPCs
bfpca_obj = bfpca(Y, npc = 2, print.iter = TRUE, maxiter = 25)



plot(bfpca_obj)

# estimate npc adaptively, to explain 90% of the overall variation
bfpca_obj2 = bfpca(Y, npc_varExplained = 0.9, print.iter = TRUE, maxiter = 30)
plot(bfpca_obj2)

</code></pre>

<hr>
<h2 id='bfpca_argPreparation'>Internal main preparation function for bfpca</h2><span id='topic+bfpca_argPreparation'></span>

<h3>Description</h3>

<p>Internal main preparation function for bfpca
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bfpca_argPreparation(
  Y,
  Kt,
  time,
  t_min,
  t_max,
  periodic,
  seed,
  subsample,
  verbose
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bfpca_argPreparation_+3A_y">Y</code>, <code id="bfpca_argPreparation_+3A_time">time</code>, <code id="bfpca_argPreparation_+3A_t_min">t_min</code>, <code id="bfpca_argPreparation_+3A_t_max">t_max</code></td>
<td>
<p>Internal objects created in <code>bfpca</code>.</p>
</td></tr>
<tr><td><code id="bfpca_argPreparation_+3A_kt">Kt</code></td>
<td>
<p>Number of B-spline basis functions used to estimate mean functions
and functional principal components. Default is 8. If <code>npc_varExplained</code>
is used, <code>Kt</code> is set to 20.</p>
</td></tr>
<tr><td><code id="bfpca_argPreparation_+3A_periodic">periodic</code></td>
<td>
<p>If TRUE, uses periodic b-spline basis functions. Default is FALSE.</p>
</td></tr>
<tr><td><code id="bfpca_argPreparation_+3A_seed">seed</code></td>
<td>
<p>Set seed for reproducibility. Defaults to 1988.</p>
</td></tr>
<tr><td><code id="bfpca_argPreparation_+3A_subsample">subsample</code></td>
<td>
<p>if the number of rows of the data is greater than 
10 million rows, the 'id' values are subsampled to get the mean coefficients.</p>
</td></tr>
<tr><td><code id="bfpca_argPreparation_+3A_verbose">verbose</code></td>
<td>
<p>Can be set to integers between 0 and 4 to control the level of
detail of the printed diagnostic messages. Higher numbers lead to more detailed
messages. Defaults to 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with elements <code>knots</code>, <code>Theta_phi</code>, <code>xi</code>,
<code>alpha_coefs</code>.
</p>

<hr>
<h2 id='bfpca_optimization'>Internal main optimization for bfpca</h2><span id='topic+bfpca_optimization'></span>

<h3>Description</h3>

<p>Main optimization function for <code>bfpca</code>. If <code>npc_varExplained</code>
is specified, the function simply returns a list with elements <code>npc</code>
(chosen number of FPCs), <code>evalues</code> (estimated variances of the first 'npc'
FPCs) and <code>evalues_sum</code> (sum of the estimated variances of the first 20
FPCs, as approximation of the overall variance).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bfpca_optimization(
  npc,
  npc_varExplained = NULL,
  Kt,
  maxiter,
  print.iter,
  seed,
  periodic,
  error_thresh,
  verbose,
  Y,
  rows,
  I,
  knots,
  Theta_phi,
  xi,
  alpha_coefs
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bfpca_optimization_+3A_npc">npc</code></td>
<td>
<p>The number of functional principal components (FPCs)
has to be specified either directly as <code>npc</code> or based on their explained
share of variance. In the latter case, <code>npc_varExplained</code> has to be set
to a share between 0 and 1.</p>
</td></tr>
<tr><td><code id="bfpca_optimization_+3A_npc_varexplained">npc_varExplained</code></td>
<td>
<p>The number of functional principal components (FPCs)
has to be specified either directly as <code>npc</code> or based on their explained
share of variance. In the latter case, <code>npc_varExplained</code> has to be set
to a share between 0 and 1.</p>
</td></tr>
<tr><td><code id="bfpca_optimization_+3A_kt">Kt</code></td>
<td>
<p>Number of B-spline basis functions used to estimate mean functions
and functional principal components. Default is 8. If <code>npc_varExplained</code>
is used, <code>Kt</code> is set to 20.</p>
</td></tr>
<tr><td><code id="bfpca_optimization_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations to perform for EM algorithm. Default is 50.</p>
</td></tr>
<tr><td><code id="bfpca_optimization_+3A_print.iter">print.iter</code></td>
<td>
<p>Prints current error and iteration</p>
</td></tr>
<tr><td><code id="bfpca_optimization_+3A_seed">seed</code></td>
<td>
<p>Set seed for reproducibility. Defaults to 1988.</p>
</td></tr>
<tr><td><code id="bfpca_optimization_+3A_periodic">periodic</code></td>
<td>
<p>If TRUE, uses periodic b-spline basis functions. Default is FALSE.</p>
</td></tr>
<tr><td><code id="bfpca_optimization_+3A_error_thresh">error_thresh</code></td>
<td>
<p>Error threshold to end iterations. Defaults to 0.0001.</p>
</td></tr>
<tr><td><code id="bfpca_optimization_+3A_verbose">verbose</code></td>
<td>
<p>Can be set to integers between 0 and 4 to control the level of
detail of the printed diagnostic messages. Higher numbers lead to more detailed
messages. Defaults to 1.</p>
</td></tr>
<tr><td><code id="bfpca_optimization_+3A_y">Y</code>, <code id="bfpca_optimization_+3A_rows">rows</code>, <code id="bfpca_optimization_+3A_i">I</code>, <code id="bfpca_optimization_+3A_knots">knots</code>, <code id="bfpca_optimization_+3A_theta_phi">Theta_phi</code>, <code id="bfpca_optimization_+3A_xi">xi</code>, <code id="bfpca_optimization_+3A_alpha_coefs">alpha_coefs</code></td>
<td>
<p>Internal objects created in
<code>bfpca</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with elements <code>t_vec</code>, <code>Theta_phi_mean</code>, <code>alpha_coefs</code>,
<code>efunctions</code>, <code>evalues</code>, <code>evalues_sum</code>, <code>scores</code>,
<code>subject_coef</code>, <code>fittedVals</code>, <code>error</code>. See documentation of
<code><a href="#topic+fpca_gauss">fpca_gauss</a></code> for details.
</p>

<hr>
<h2 id='bs_deriv'>Nth derivative of spline basis</h2><span id='topic+bs_deriv'></span>

<h3>Description</h3>

<p>This function gets derivative of a spline basis. Adapted from <code>bs()</code> function in <code>splines</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bs_deriv(
  x,
  knots,
  degree = 3L,
  Boundary.knots = range(x),
  derivative = 1,
  intercept = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bs_deriv_+3A_x">x</code></td>
<td>
<p>a numeric vector of values at which to evaluate the B-spline functions or derivatives.</p>
</td></tr>
<tr><td><code id="bs_deriv_+3A_knots">knots</code></td>
<td>
<p>the internal breakpoints that define the spline.</p>
</td></tr>
<tr><td><code id="bs_deriv_+3A_degree">degree</code></td>
<td>
<p>degree of the piecewise polynomial—default is 3 for cubic splines.</p>
</td></tr>
<tr><td><code id="bs_deriv_+3A_boundary.knots">Boundary.knots</code></td>
<td>
<p>boundary points at which to anchor the B-spline basis. 
Set to [0,1] if you want this to be your domain.</p>
</td></tr>
<tr><td><code id="bs_deriv_+3A_derivative">derivative</code></td>
<td>
<p>a positive integer value that specifies which derivative to take. Defaults to 1 for 1st derivative.
Value of 0 returns the original set of b-spline basis functions.</p>
</td></tr>
<tr><td><code id="bs_deriv_+3A_intercept">intercept</code></td>
<td>
<p>if TRUE, an intercept is included in the basis; default is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing:
</p>
<table>
<tr><td><code>basis</code></td>
<td>
<p>A B-spline basis that can be used to approximate the derivative of a function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Julia Wrobel <a href="mailto:julia.wrobel@cuanschutz.edu">julia.wrobel@cuanschutz.edu</a>
</p>

<hr>
<h2 id='coarsen_index'>Coarsen an index vector to a given resolution</h2><span id='topic+coarsen_index'></span>

<h3>Description</h3>

<p>Reduce the resolution of a numeric vector by specifying the number of
<code>significant_digits</code> to which the numbers should be rounded. <br /> <br />
Internal function used to coarsen the index vector before estimating the
two-step GFPCA with <code><a href="#topic+gfpca_twoStep">gfpca_twoStep</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coarsen_index(index, significant_digits)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coarsen_index_+3A_index">index</code></td>
<td>
<p>Numeric vector of index values.</p>
</td></tr>
<tr><td><code id="coarsen_index_+3A_significant_digits">significant_digits</code></td>
<td>
<p>Positive integer value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of rounded index values.
</p>


<h3>Author(s)</h3>

<p>Alexander Bauer <a href="mailto:alexander.bauer@stat.uni-muenchen.de">alexander.bauer@stat.uni-muenchen.de</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>index_vector = c(0.7892, 0.2984, 0.328)
registr:::coarsen_index(index_vector, 1)
registr:::coarsen_index(index_vector, 3)

index_vector2 = c(2803, -7639, 13)
registr:::coarsen_index(index_vector2, 1)
registr:::coarsen_index(index_vector2, 3)

</code></pre>

<hr>
<h2 id='constraints'>Define constraints for optimization of warping functions</h2><span id='topic+constraints'></span>

<h3>Description</h3>

<p>Constraints ensure monotonicity of spline coefficients for warping functions 
for use with <code>constrOptim()</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constraints(Kh, t_min = 0, t_max = 1, warping = "nonparametric")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constraints_+3A_kh">Kh</code></td>
<td>
<p>Number of B-spline basis functions used to estimate warping functions <em>h</em>.</p>
</td></tr>
<tr><td><code id="constraints_+3A_t_min">t_min</code></td>
<td>
<p>Minimum value to be evaluated on the time domain.</p>
</td></tr>
<tr><td><code id="constraints_+3A_t_max">t_max</code></td>
<td>
<p>Maximum value to be evaluated on the time domain.</p>
</td></tr>
<tr><td><code id="constraints_+3A_warping">warping</code></td>
<td>
<p>If <code>nonparametric</code> (default), inverse warping functions are estimated nonparametrically. 
If <code>piecewise_linear2</code> they follow a piecewise linear function with 2 knots.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An list containing:
</p>
<table>
<tr><td><code>ui</code></td>
<td>
<p>A constraint matrix.</p>
</td></tr>
<tr><td><code>ci</code></td>
<td>
<p>A constraint vector.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Julia Wrobel <a href="mailto:julia.wrobel@cuanschutz.edu">julia.wrobel@cuanschutz.edu</a>,
Erin McDonnell <a href="mailto:eim2117@cumc.columbia.edu">eim2117@cumc.columbia.edu</a>
</p>

<hr>
<h2 id='cov_hall'>Covariance estimation after Hall et al. (2008)</h2><span id='topic+cov_hall'></span>

<h3>Description</h3>

<p>Internal function for the estimation of the covariance matrix of the latent
process using the approach of Hall et al. (2008). Used in the
two-step GFPCA approach implemented in <code><a href="#topic+gfpca_twoStep">gfpca_twoStep</a></code>. <br /> <br />
This function is an adaptation of the implementation of Jan
Gertheiss and Ana-Maria Staicu for Gertheiss et al. (2017), with focus on
higher (RAM) efficiency for large data settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov_hall(
  Y,
  index_evalGrid,
  Kt = 25,
  Kc = 10,
  family = "gaussian",
  diag_epsilon = 0.01,
  make_pd = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cov_hall_+3A_y">Y</code></td>
<td>
<p>Dataframe. Should have values id, value, index.</p>
</td></tr>
<tr><td><code id="cov_hall_+3A_index_evalgrid">index_evalGrid</code></td>
<td>
<p>Grid for the evaluation of the covariance structure.</p>
</td></tr>
<tr><td><code id="cov_hall_+3A_kt">Kt</code></td>
<td>
<p>Number of P-spline basis functions for the estimation of the
marginal mean. Defaults to 25.</p>
</td></tr>
<tr><td><code id="cov_hall_+3A_kc">Kc</code></td>
<td>
<p>Number of marginal P-spline basis functions for smoothing the
covariance surface. Defaults to 10.</p>
</td></tr>
<tr><td><code id="cov_hall_+3A_family">family</code></td>
<td>
<p>One of <code>c("gaussian","binomial","gamma","poisson")</code>.
Poisson data are rounded before performing
the GFPCA to ensure integer data, see Details section below.
Defaults to <code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="cov_hall_+3A_diag_epsilon">diag_epsilon</code></td>
<td>
<p>Small constant to which diagonal elements of the
covariance matrix are set if they are smaller. Defaults to 0.01.</p>
</td></tr>
<tr><td><code id="cov_hall_+3A_make_pd">make_pd</code></td>
<td>
<p>Indicator if positive (semi-)definiteness of the returned
latent covariance should be ensured via <code>Matrix::near_PD()</code>. Defaults to
TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implementation deviates from the algorithm described in Hall (2008) in
one crucial step &ndash; we compute the crossproducts of <em>centered</em>
observations and smooth the surface of these crossproducts directly instead
of computing and smoothing the surface of crossproducts of uncentered
observations and subsequently subtracting the (crossproducts of the) mean
function. The former seems to yield smoother eigenfunctions and 
fewer non-positive-definite covariance estimates.
</p>
<p>If the data <code>Y</code> or the crossproduct matrix contain more than
<code>100,000</code> rows or elements, the estimation of the marginal mean or
the smoothing step of the covariance matrix are performed by
using the discretization-based estimation algorithm in <code><a href="mgcv.html#topic+bam">bam</a></code>
rather than the <code><a href="mgcv.html#topic+gam">gam</a></code> estimation algorithm.
</p>


<h3>Value</h3>

<p>Covariance matrix with dimension <code>time_evalGrid x time_evalGrid</code>.
</p>


<h3>Author(s)</h3>

<p>Alexander Bauer <a href="mailto:alexander.bauer@stat.uni-muenchen.de">alexander.bauer@stat.uni-muenchen.de</a> and 
Fabian Scheipl, based on work of Jan Gertheiss and Ana-Maria Staicu
</p>


<h3>References</h3>

<p>Hall, P., Müller, H. G., &amp; Yao, F. (2008). Modelling sparse
generalized longitudinal observations with latent Gaussian processes.
<em>Journal of the Royal Statistical Society: Series B (Statistical Methodology)</em>,
70(4), 703&ndash;723.
</p>
<p>Gertheiss, J., Goldsmith, J., &amp; Staicu, A. M. (2017). A note on
modeling sparse exponential-family functional response curves.
<em>Computational statistics &amp; data analysis</em>, 105, 46&ndash;52.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(growth_incomplete)

index_grid = c(1.25, seq(from = 2, to = 18, by = 1))
cov_matrix = registr:::cov_hall(growth_incomplete, index_evalGrid = index_grid)

</code></pre>

<hr>
<h2 id='crossprods_irregular'>Crossproduct computation for highly irregular grids</h2><span id='topic+crossprods_irregular'></span>

<h3>Description</h3>

<p>Compute the crossproduct in a fast way for highly irregular grids
(index values are mostly unique).
Only used internally in <code>cov_hall()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crossprods_irregular(Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossprods_irregular_+3A_y">Y</code></td>
<td>
<p>Dataframe with the centered observations.
Should have values id, centered, index.</p>
</td></tr>
</table>

<hr>
<h2 id='crossprods_regular'>Crossproduct computation for mostly regular grids</h2><span id='topic+crossprods_regular'></span>

<h3>Description</h3>

<p>Compute the crossproduct in a fast way for mostly regular grids
(index values are mostly *not* unique).
Only used internally in <code>cov_hall()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crossprods_regular(Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossprods_regular_+3A_y">Y</code></td>
<td>
<p>Dataframe with the centered observations.
Should have values id, centered, index.</p>
</td></tr>
</table>

<hr>
<h2 id='data_clean'>Convert data to a <code>refund</code> object</h2><span id='topic+data_clean'></span>

<h3>Description</h3>

<p>Function used for data cleaning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_clean(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_clean_+3A_data">data</code></td>
<td>
<p>Dataframe. Should have values id, value, index.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An list containing:
</p>
<table>
<tr><td><code>Y</code></td>
<td>
<p>The original data sorted by id and index.</p>
</td></tr>
<tr><td><code>Y_rows</code></td>
<td>
<p>A dataframe containing the first and last row for each subject.</p>
</td></tr>
</table>

<hr>
<h2 id='deriv.inv.logit'>Estimate the derivative of the logit function</h2><span id='topic+deriv.inv.logit'></span>

<h3>Description</h3>

<p>Compute the derivative of the logit function for a given point <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'inv.logit'
deriv(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deriv.inv.logit_+3A_x">x</code></td>
<td>
<p>Value at which the derivative is computed</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexander Bauer <a href="mailto:alexander.bauer@stat.uni-muenchen.de">alexander.bauer@stat.uni-muenchen.de</a>
</p>

<hr>
<h2 id='determine_npc'>Determine the number of FPCs based on the share of explained variance</h2><span id='topic+determine_npc'></span>

<h3>Description</h3>

<p>This internal function is called in <code>gfpca_twoStep</code>, <code>fpca_gauss</code>
and <code>bfpca</code> to determine the number of functional principal components
based on their share of explained variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>determine_npc(evalues, npc_criterion)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="determine_npc_+3A_evalues">evalues</code></td>
<td>
<p>Vector of estimated variances of the FPC scores.</p>
</td></tr>
<tr><td><code id="determine_npc_+3A_npc_criterion">npc_criterion</code></td>
<td>
<p>Either (i) a share between 0 and 1, or (ii) a vector with
two elements for the targeted explained share of variance and a cut-off scree
plot criterion, both between 0 and 1. For the latter, e.g.,
<code>npc_criterion = c(0.9,0.02)</code> tries to choose a number of FPCs that
explains at least 90% of variation, but only includes FPCs that explain at
least 2% of variation (even if this means 90% explained variation is not reached).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer for the number of fucntional principal components
</p>

<hr>
<h2 id='ensure_proper_beta'>Correct slightly improper parameter vectors</h2><span id='topic+ensure_proper_beta'></span>

<h3>Description</h3>

<p>Internal function. In the joint iterations between registration and GFPCA,
the optimization with <code>constrOptim()</code> in the registration step sometimes
leads to slightly improper solutions, which cause the optimization to
throw an error in the following optimization step. This function corrects
the parameter vector if one of the following slight inconsistencies occurs
that can mess with the optimization of <code>constrOptim()</code>: <br />
- two neighboring values of the parameter vector are too similar <br />
- the initial values of the parameter vector are smaller than <code>t_min</code>,
the minimum of the underlying time domain <br />
- the last values of the parameter vector are greater than <code>t_max</code>,
the maximum of the underlying time domain <br />
- one parameter value is slightly greater than its following value, i.e.
the parameter vector is not monotone.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ensure_proper_beta(beta, t_min, t_max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ensure_proper_beta_+3A_beta">beta</code></td>
<td>
<p>Parameter vector.</p>
</td></tr>
<tr><td><code id="ensure_proper_beta_+3A_t_min">t_min</code>, <code id="ensure_proper_beta_+3A_t_max">t_max</code></td>
<td>
<p>Minimum and maximum of the underlying time domain in the
registration step.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A slightly changed parameter vector that ensures a proper solution
in the optimization of the registration step.
</p>


<h3>Author(s)</h3>

<p>Alexander Bauer <a href="mailto:alexander.bauer@stat.uni-muenchen.de">alexander.bauer@stat.uni-muenchen.de</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>beta_improper = c(0.24, 1.000047, 1.000002)
registr:::ensure_proper_beta(beta_improper, t_min = 0, t_max = 1)
</code></pre>

<hr>
<h2 id='expectedScores'>Calculate expected score and score variance for the current subject.</h2><span id='topic+expectedScores'></span>

<h3>Description</h3>

<p>Calculations derived using maximum likelihood estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expectedScores(Y, mu, psi, theta, theta_quad)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expectedScores_+3A_y">Y</code></td>
<td>
<p>vector of observations for the current subject.</p>
</td></tr>
<tr><td><code id="expectedScores_+3A_mu">mu</code></td>
<td>
<p>vector of spline coefficients for the population mean.</p>
</td></tr>
<tr><td><code id="expectedScores_+3A_psi">psi</code></td>
<td>
<p>matrix of spline coefficients for the principal component basis functions.</p>
</td></tr>
<tr><td><code id="expectedScores_+3A_theta">theta</code></td>
<td>
<p>spline basis functions for the current subject.</p>
</td></tr>
<tr><td><code id="expectedScores_+3A_theta_quad">theta_quad</code></td>
<td>
<p>quadratic form of theta for the current subject.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with expected score mean and variance for the current subject.
</p>

<hr>
<h2 id='expectedXi'>Estimate variational parameter for the current subject.</h2><span id='topic+expectedXi'></span>

<h3>Description</h3>

<p>Function calculates value of variational parameter using maximum likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expectedXi(theta, mu, mi, psi, Ci)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expectedXi_+3A_theta">theta</code></td>
<td>
<p>spline basis functions for the current subject.</p>
</td></tr>
<tr><td><code id="expectedXi_+3A_mu">mu</code></td>
<td>
<p>vector of spline coefficients for the population mean.</p>
</td></tr>
<tr><td><code id="expectedXi_+3A_mi">mi</code></td>
<td>
<p>vector of expected mean scores for the current subject.</p>
</td></tr>
<tr><td><code id="expectedXi_+3A_psi">psi</code></td>
<td>
<p>matrix of spline coefficients for the principal component basis functions.</p>
</td></tr>
<tr><td><code id="expectedXi_+3A_ci">Ci</code></td>
<td>
<p>expected covariance matrix of scores for the current subject.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of variational parameters for the current subject.
</p>

<hr>
<h2 id='fpca_gauss'>Functional principal components analysis via variational EM</h2><span id='topic+fpca_gauss'></span>

<h3>Description</h3>

<p>Function used in the FPCA step for registering functional data,
called by <code><a href="#topic+register_fpca">register_fpca</a></code> when <code>family = "gaussian"</code>. 
Parameters estimated based on probabilistic PCA framework originally 
introduced by Tipping and Bishop in 1999. <br /> <br />
The number of functional principal components (FPCs) can either be specified
directly (argument <code>npc</code>) or chosen based on the explained share of
variance (<code>npc_varExplained</code>). In the latter case, the explained share of
variance and accordingly the number of FPCs is estimated before the main
estimation step by once running the FPCA with <code>npc = 20</code> (and
correspondingly <code>Kt = 20</code>). Doing so, we approximate the overall
variance in the data <code>Y</code> with the variance represented by the FPC basis
with 20 FPCs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fpca_gauss(
  Y,
  npc = NULL,
  npc_varExplained = NULL,
  Kt = 8,
  maxiter = 20,
  t_min = NULL,
  t_max = NULL,
  print.iter = FALSE,
  row_obj = NULL,
  seed = 1988,
  periodic = FALSE,
  error_thresh = 1e-04,
  subsample = TRUE,
  verbose = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fpca_gauss_+3A_y">Y</code></td>
<td>
<p>Dataframe. Should have variables id, value, index.</p>
</td></tr>
<tr><td><code id="fpca_gauss_+3A_npc">npc</code>, <code id="fpca_gauss_+3A_npc_varexplained">npc_varExplained</code></td>
<td>
<p>The number of functional principal components (FPCs)
has to be specified either directly as <code>npc</code> or based on their explained
share of variance. In the latter case, <code>npc_varExplained</code> has to be set
to a share between 0 and 1.</p>
</td></tr>
<tr><td><code id="fpca_gauss_+3A_kt">Kt</code></td>
<td>
<p>Number of B-spline basis functions used to estimate mean functions
and functional principal components. Default is 8. If <code>npc_varExplained</code>
is used, <code>Kt</code> is set to 20.</p>
</td></tr>
<tr><td><code id="fpca_gauss_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations to perform for EM algorithm. Default is 50.</p>
</td></tr>
<tr><td><code id="fpca_gauss_+3A_t_min">t_min</code></td>
<td>
<p>Minimum value to be evaluated on the time domain.</p>
</td></tr>
<tr><td><code id="fpca_gauss_+3A_t_max">t_max</code></td>
<td>
<p>Maximum value to be evaluated on the time domain.</p>
</td></tr>
<tr><td><code id="fpca_gauss_+3A_print.iter">print.iter</code></td>
<td>
<p>Prints current error and iteration</p>
</td></tr>
<tr><td><code id="fpca_gauss_+3A_row_obj">row_obj</code></td>
<td>
<p>If NULL, the function cleans the data and calculates row indices. 
Keep this NULL if you are using standalone <code>register</code> function.</p>
</td></tr>
<tr><td><code id="fpca_gauss_+3A_seed">seed</code></td>
<td>
<p>Set seed for reproducibility. Defaults to 1988.</p>
</td></tr>
<tr><td><code id="fpca_gauss_+3A_periodic">periodic</code></td>
<td>
<p>If TRUE, uses periodic b-spline basis functions. Default is FALSE.</p>
</td></tr>
<tr><td><code id="fpca_gauss_+3A_error_thresh">error_thresh</code></td>
<td>
<p>Error threshold to end iterations. Defaults to 0.0001.</p>
</td></tr>
<tr><td><code id="fpca_gauss_+3A_subsample">subsample</code></td>
<td>
<p>if the number of rows of the data is greater than 
10 million rows, the 'id' values are subsampled to get the mean coefficients.</p>
</td></tr>
<tr><td><code id="fpca_gauss_+3A_verbose">verbose</code></td>
<td>
<p>Can be set to integers between 0 and 4 to control the level of
detail of the printed diagnostic messages. Higher numbers lead to more detailed
messages. Defaults to 1.</p>
</td></tr>
<tr><td><code id="fpca_gauss_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to or from other functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>fpca</code> containing:
</p>
<table>
<tr><td><code>fpca_type</code></td>
<td>
<p>Information that FPCA was performed with the 'variationEM' approach,
in contrast to registr::gfpca_twoStep.</p>
</td></tr>
<tr><td><code>t_vec</code></td>
<td>
<p>Time vector over which the mean <code>mu</code> and the functional principal
components <code>efunctions</code> were evaluated.</p>
</td></tr>
<tr><td><code>knots</code></td>
<td>
<p>Cutpoints for B-spline basis used to rebuild <code>alpha</code>.</p>
</td></tr>
<tr><td><code>efunctions</code></td>
<td>
<p><code class="reqn">D \times npc</code> matrix of estimated FPC basis functions.</p>
</td></tr>
<tr><td><code>evalues</code></td>
<td>
<p>Estimated variance of the FPC scores.</p>
</td></tr>
<tr><td><code>evalues_sum</code></td>
<td>
<p>Approximation of the overall variance in <code>Y</code>, based
on an initial run of the FPCA with <code>npc = 20</code>. Is <code>NULL</code> if
<code>npc_varExplained</code> was not specified.</p>
</td></tr>
<tr><td><code>npc</code></td>
<td>
<p>number of FPCs.</p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p><code class="reqn">I \times npc</code> matrix of estimated FPC scores.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>Estimated population-level mean.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>Estimated population-level mean. Same value as <code>alpha</code> but included for compatibility
with <code>refund.shiny</code> package.</p>
</td></tr>
<tr><td><code>subject_coefs</code></td>
<td>
<p>B-spline basis coefficients used to construct subject-specific means. 
For use in <code>registr()</code> function.</p>
</td></tr>
<tr><td><code>Yhat</code></td>
<td>
<p>FPC approximation of subject-specific means.</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>The observed data.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p><code>gaussian</code>, for compatibility with <code>refund.shiny</code> package.</p>
</td></tr>
<tr><td><code>sigma2</code></td>
<td>
<p>Estimated error variance</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Julia Wrobel <a href="mailto:julia.wrobel@cuanschutz.edu">julia.wrobel@cuanschutz.edu</a>,
Jeff Goldsmith <a href="mailto:ajg2202@cumc.columbia.edu">ajg2202@cumc.columbia.edu</a>,
Alexander Bauer <a href="mailto:alexander.bauer@stat.uni-muenchen.de">alexander.bauer@stat.uni-muenchen.de</a>
</p>


<h3>References</h3>

<p>Tipping, M. E. and Bishop, C (1999). Probabilistic Principal Component Analysis.
<em>Journal of the Royal Statistical Society Series B,</em>, 592&ndash;598.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(growth_incomplete)

# estimate 2 FPCs
fpca_obj = fpca_gauss(Y = growth_incomplete, npc = 2)
plot(fpca_obj)

# estimate npc adaptively, to explain 90% of the overall variation

fpca_obj2 = fpca_gauss(Y = growth_incomplete, npc_varExplained = 0.9)
plot(fpca_obj, plot_FPCs = 1:2)


</code></pre>

<hr>
<h2 id='fpca_gauss_argPreparation'>Internal main preparation function for fpca_gauss</h2><span id='topic+fpca_gauss_argPreparation'></span>

<h3>Description</h3>

<p>Internal main preparation function for fpca_gauss
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fpca_gauss_argPreparation(
  Y,
  Kt,
  time,
  t_min,
  t_max,
  periodic,
  seed,
  subsample,
  verbose
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fpca_gauss_argPreparation_+3A_y">Y</code>, <code id="fpca_gauss_argPreparation_+3A_time">time</code>, <code id="fpca_gauss_argPreparation_+3A_t_min">t_min</code>, <code id="fpca_gauss_argPreparation_+3A_t_max">t_max</code></td>
<td>
<p>Internal objects created in <code>fpca_gauss</code>.</p>
</td></tr>
<tr><td><code id="fpca_gauss_argPreparation_+3A_kt">Kt</code></td>
<td>
<p>Number of B-spline basis functions used to estimate mean functions
and functional principal components. Default is 8. If <code>npc_varExplained</code>
is used, <code>Kt</code> is set to 20.</p>
</td></tr>
<tr><td><code id="fpca_gauss_argPreparation_+3A_periodic">periodic</code></td>
<td>
<p>If TRUE, uses periodic b-spline basis functions. Default is FALSE.</p>
</td></tr>
<tr><td><code id="fpca_gauss_argPreparation_+3A_seed">seed</code></td>
<td>
<p>Set seed for reproducibility. Defaults to 1988.</p>
</td></tr>
<tr><td><code id="fpca_gauss_argPreparation_+3A_subsample">subsample</code></td>
<td>
<p>if the number of rows of the data is greater than 
10 million rows, the 'id' values are subsampled to get the mean coefficients.</p>
</td></tr>
<tr><td><code id="fpca_gauss_argPreparation_+3A_verbose">verbose</code></td>
<td>
<p>Can be set to integers between 0 and 4 to control the level of
detail of the printed diagnostic messages. Higher numbers lead to more detailed
messages. Defaults to 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with elements <code>knots</code>, <code>Theta_phi</code>, <code>alpha_coefs</code>.
</p>

<hr>
<h2 id='fpca_gauss_optimization'>Internal main optimization for fpca_gauss</h2><span id='topic+fpca_gauss_optimization'></span>

<h3>Description</h3>

<p>Main optimization function for <code>fpca_gauss</code>. If <code>npc_varExplained</code>
is specified, the function simply returns a list with elements <code>npc</code>
(chosen number of FPCs), <code>evalues</code> (estimated variances of the first 'npc'
FPCs) and <code>evalues_sum</code> (sum of the estimated variances of the first 20
FPCs, as approximation of the overall variance).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fpca_gauss_optimization(
  npc,
  npc_varExplained = NULL,
  Kt,
  maxiter,
  print.iter,
  seed,
  periodic,
  error_thresh,
  verbose,
  Y,
  rows,
  I,
  knots,
  Theta_phi,
  alpha_coefs
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fpca_gauss_optimization_+3A_npc">npc</code></td>
<td>
<p>The number of functional principal components (FPCs)
has to be specified either directly as <code>npc</code> or based on their explained
share of variance. In the latter case, <code>npc_varExplained</code> has to be set
to a share between 0 and 1.</p>
</td></tr>
<tr><td><code id="fpca_gauss_optimization_+3A_npc_varexplained">npc_varExplained</code></td>
<td>
<p>The number of functional principal components (FPCs)
has to be specified either directly as <code>npc</code> or based on their explained
share of variance. In the latter case, <code>npc_varExplained</code> has to be set
to a share between 0 and 1.</p>
</td></tr>
<tr><td><code id="fpca_gauss_optimization_+3A_kt">Kt</code></td>
<td>
<p>Number of B-spline basis functions used to estimate mean functions
and functional principal components. Default is 8. If <code>npc_varExplained</code>
is used, <code>Kt</code> is set to 20.</p>
</td></tr>
<tr><td><code id="fpca_gauss_optimization_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations to perform for EM algorithm. Default is 50.</p>
</td></tr>
<tr><td><code id="fpca_gauss_optimization_+3A_print.iter">print.iter</code></td>
<td>
<p>Prints current error and iteration</p>
</td></tr>
<tr><td><code id="fpca_gauss_optimization_+3A_seed">seed</code></td>
<td>
<p>Set seed for reproducibility. Defaults to 1988.</p>
</td></tr>
<tr><td><code id="fpca_gauss_optimization_+3A_periodic">periodic</code></td>
<td>
<p>If TRUE, uses periodic b-spline basis functions. Default is FALSE.</p>
</td></tr>
<tr><td><code id="fpca_gauss_optimization_+3A_error_thresh">error_thresh</code></td>
<td>
<p>Error threshold to end iterations. Defaults to 0.0001.</p>
</td></tr>
<tr><td><code id="fpca_gauss_optimization_+3A_verbose">verbose</code></td>
<td>
<p>Can be set to integers between 0 and 4 to control the level of
detail of the printed diagnostic messages. Higher numbers lead to more detailed
messages. Defaults to 1.</p>
</td></tr>
<tr><td><code id="fpca_gauss_optimization_+3A_y">Y</code>, <code id="fpca_gauss_optimization_+3A_rows">rows</code>, <code id="fpca_gauss_optimization_+3A_i">I</code>, <code id="fpca_gauss_optimization_+3A_knots">knots</code>, <code id="fpca_gauss_optimization_+3A_theta_phi">Theta_phi</code>, <code id="fpca_gauss_optimization_+3A_alpha_coefs">alpha_coefs</code></td>
<td>
<p>Internal objects created in
<code>fpca_gauss</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with elements <code>t_vec</code>, <code>Theta_phi_mean</code>, <code>alpha_coefs</code>,
<code>efunctions</code>, <code>evalues</code>, <code>evalues_sum</code>, <code>scores</code>,
<code>subject_coef</code>, <code>fittedVals</code>, <code>sigma2</code>. See documentation of
<code><a href="#topic+fpca_gauss">fpca_gauss</a></code> for details.
</p>

<hr>
<h2 id='gfpca_twoStep'>Generalized functional principal component analysis</h2><span id='topic+gfpca_twoStep'></span>

<h3>Description</h3>

<p>Function for applying FPCA to different exponential family distributions.
Used in the FPCA step for registering functional data,
called by <code><a href="#topic+register_fpca">register_fpca</a></code> when <code>fpca_type = "two-step"</code>. <br /> <br />
The method implements the 'two-step approach' of Gertheiss et al. (2017)
and is based on the approach of Hall et al. (2008) to estimate functional
principal components. <br /> <br />
The number of functional principal components (FPCs) can either be specified
directly (argument <code>npc</code>) or chosen based on the explained share of
variance (<code>npc_criterion</code>). Using the latter, we approximate the overall
variance in the data <code>Y</code> with the variance represented by the smoothed
covariance surface estimated with <code><a href="#topic+cov_hall">cov_hall</a></code>.
Note that the Eigenvalue decomposition of this covariance surface
sometimes leads to a long tail of subordinate FPCs with small eigenvalues.
Such subordinate dimensions seem to often represent phase rather than
amplitude variation, and can be cut off by specifying the second element of
argument <code>npc_criterion</code>. <br /> <br />
This function is an adaptation of the implementation of Jan
Gertheiss for Gertheiss et al. (2017), with focus on higher (RAM) efficiency
for large data settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gfpca_twoStep(
  Y,
  family = "gaussian",
  npc = NULL,
  npc_criterion = NULL,
  Kt = 8,
  t_min = NULL,
  t_max = NULL,
  row_obj = NULL,
  index_significantDigits = 4L,
  estimation_accuracy = "high",
  start_params = NULL,
  periodic = FALSE,
  verbose = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gfpca_twoStep_+3A_y">Y</code></td>
<td>
<p>Dataframe. Should have values id, value, index.</p>
</td></tr>
<tr><td><code id="gfpca_twoStep_+3A_family">family</code></td>
<td>
<p>One of <code>c("gaussian","binomial","gamma","poisson")</code>.
Poisson data are rounded before performing
the GFPCA to ensure integer data, see Details section below.
Defaults to <code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="gfpca_twoStep_+3A_npc">npc</code>, <code id="gfpca_twoStep_+3A_npc_criterion">npc_criterion</code></td>
<td>
<p>The number of functional principal components (FPCs)
has to be specified either directly as <code>npc</code> or based on their explained
share of variance. In the latter case, <code>npc_criterion</code> can either be set
to (i) a share between 0 and 1, or (ii) a vector with two elements comprising
the targeted explained share of variance and a cut-off scree plot criterion,
both between 0 and 1. As an example for the latter,
<code>npc_criterion = c(0.9,0.02)</code> tries to choose a number of FPCs that
explains at least 90% of variation, but only includes FPCs that explain at
least 2% of variation (even if this means 90% explained variation is not reached).</p>
</td></tr>
<tr><td><code id="gfpca_twoStep_+3A_kt">Kt</code></td>
<td>
<p>Number of B-spline basis functions used to estimate mean functions
and functional principal components. Default is 8.</p>
</td></tr>
<tr><td><code id="gfpca_twoStep_+3A_t_min">t_min</code></td>
<td>
<p>Minimum value to be evaluated on the time domain.</p>
</td></tr>
<tr><td><code id="gfpca_twoStep_+3A_t_max">t_max</code></td>
<td>
<p>Maximum value to be evaluated on the time domain.</p>
</td></tr>
<tr><td><code id="gfpca_twoStep_+3A_row_obj">row_obj</code></td>
<td>
<p>If NULL, the function cleans the data and calculates row indices. 
Keep this NULL if you are using standalone <code>register</code> function.</p>
</td></tr>
<tr><td><code id="gfpca_twoStep_+3A_index_significantdigits">index_significantDigits</code></td>
<td>
<p>Positive integer <code>&gt;= 2</code>, stating the number
of significant digits to which the index grid should be rounded. Coarsening the
index grid is necessary since otherwise the covariance surface matrix
explodes in size in the presence of too many unique index values (which is
always the case after some registration step). Defaults to 4. Set to
<code>NULL</code> to prevent rounding.</p>
</td></tr>
<tr><td><code id="gfpca_twoStep_+3A_estimation_accuracy">estimation_accuracy</code></td>
<td>
<p>One of <code>c("high","low")</code>. When set to <code>"low"</code>,
the mixed model estimation step in <code>lme4</code> is performed with lower
accuracy, reducing computation time. Defaults to <code>"high"</code>.</p>
</td></tr>
<tr><td><code id="gfpca_twoStep_+3A_start_params">start_params</code></td>
<td>
<p>Optional start values for gamm4. Not used if
<code>npc_criterion</code> is specified.</p>
</td></tr>
<tr><td><code id="gfpca_twoStep_+3A_periodic">periodic</code></td>
<td>
<p>Only contained for full consistency with <code>fpca_gauss</code>
and <code>bfpca</code>. If TRUE, returns the knots vector for periodic b-spline
basis functions. Defaults to FALSE. This parameter does not change the
results of the two-step GFPCA.</p>
</td></tr>
<tr><td><code id="gfpca_twoStep_+3A_verbose">verbose</code></td>
<td>
<p>Can be set to integers between 0 and 4 to control the level of
detail of the printed diagnostic messages. Higher numbers lead to more detailed
messages. Defaults to 1.</p>
</td></tr>
<tr><td><code id="gfpca_twoStep_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+cov_hall">cov_hall</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>family = "poisson"</code> the values in <code>Y</code> are rounded before
performing the GFPCA to ensure integer data. This is done to ensure reasonable
computation times. Computation times tend to explode when estimating the
underlying high-dimensional mixed model with continuous Poisson data based
on the <code><a href="gamm4.html#topic+gamm4">gamm4</a></code> package.
</p>
<p>If negative eigenvalues are present, the respective eigenfunctions are dropped
and not considered further.
</p>


<h3>Value</h3>

<p>An object of class <code>fpca</code> containing:
</p>
<table>
<tr><td><code>fpca_type</code></td>
<td>
<p>Information that FPCA was performed with the 'two-step' approach,
in contrast to registr::fpca_gauss or registr::bfpca.</p>
</td></tr>
<tr><td><code>t_vec</code></td>
<td>
<p>Time vector over which the mean <code>mu</code> was evaluated.
The resolution is can be specified by setting <code>index_significantDigits</code>.</p>
</td></tr>
<tr><td><code>knots</code></td>
<td>
<p>Cutpoints for B-spline basis used to rebuild <code>alpha</code>.</p>
</td></tr>
<tr><td><code>efunctions</code></td>
<td>
<p><code class="reqn">D \times npc</code> matrix of estimated FPC basis functions.</p>
</td></tr>
<tr><td><code>evalues</code></td>
<td>
<p>Estimated variance of the FPC scores.</p>
</td></tr>
<tr><td><code>evalues_sum</code></td>
<td>
<p>Sum of all (nonnegative) eigenvalues of the smoothed
covariance surface estimated with <code><a href="#topic+cov_hall">cov_hall</a></code>. Can be used as an
approximation for the total variance present in <code>Y</code> to compute the
shares of explained variance of the FPC scores.</p>
</td></tr>
<tr><td><code>npc</code></td>
<td>
<p>number of FPCs.</p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p><code class="reqn">I \times npc</code> matrix of estimated FPC scores.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>Estimated population-level mean.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>Estimated population-level mean. Same value as <code>alpha</code> but included for compatibility
with <code>refund.shiny</code> package.</p>
</td></tr>
<tr><td><code>subject_coefs</code></td>
<td>
<p>Always <code>NA</code> but included for full consistency
with <code>fpca_gauss</code> and <code>bfpca</code>.</p>
</td></tr> 
<tr><td><code>Yhat</code></td>
<td>
<p>FPC approximation of subject-specific means, before applying the
response function.</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>The observed data.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p><code>binomial</code>, for compatibility with <code>refund.shiny</code> package.</p>
</td></tr>
<tr><td><code>gamm4_theta</code></td>
<td>
<p>Estimated parameters of the mixed model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexander Bauer <a href="mailto:alexander.bauer@stat.uni-muenchen.de">alexander.bauer@stat.uni-muenchen.de</a>,
based on work of Jan Gertheiss
</p>


<h3>References</h3>

<p>Gertheiss, J., Goldsmith, J., &amp; Staicu, A. M. (2017). A note on
modeling sparse exponential-family functional response curves.
<em>Computational statistics &amp; data analysis</em>, 105, 46&ndash;52.
</p>
<p>Hall, P., Müller, H. G., &amp; Yao, F. (2008). Modelling sparse
generalized longitudinal observations with latent Gaussian processes.
<em>Journal of the Royal Statistical Society: Series B (Statistical Methodology)</em>,
70(4), 703&ndash;723.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(growth_incomplete)

# estimate 2 FPCs
fpca_obj = gfpca_twoStep(Y = growth_incomplete, npc = 2, family = "gaussian")
plot(fpca_obj)

# estimate npc adaptively, to explain 90% of the overall variation
fpca_obj2 = gfpca_twoStep(Y = growth_incomplete, npc_criterion = 0.9, family = "gaussian")
plot(fpca_obj2, plot_FPCs = 1:2)

</code></pre>

<hr>
<h2 id='grid_subj_create'>Generate subject-specific grid (t_star)</h2><span id='topic+grid_subj_create'></span>

<h3>Description</h3>

<p>This function creates subject-specific time grid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid_subj_create(coefs, D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid_subj_create_+3A_coefs">coefs</code></td>
<td>
<p>Spline basis coefficients for reconstructing the subject-specific grid.</p>
</td></tr>
<tr><td><code id="grid_subj_create_+3A_d">D</code></td>
<td>
<p>Number of grid points per subject.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector.
</p>

<hr>
<h2 id='growth_incomplete'>Berkeley Growth Study data with simulated incompleteness</h2><span id='topic+growth_incomplete'></span>

<h3>Description</h3>

<p>This dataset from the Berkeley Growth Study comprises the height
development of 39 boys and 54 girls between ages 1 and 18.
It is based on the dataset <code>fda::growth</code> and focuses not on the observed
heights, but on the first derivatives of the curves. Before taking the
first derivative, the curves were slightly smoothed. <br /> <br />
To showcase the functionality of the <code>registr</code> package regarding the
analysis of incomplete curves, the growth curves were artificially made
incomplete. For each child, leading incompleteness was simulated by drawing
a random initial age in the first quarter of the domain.
Also, trailing incompleteness was simulated by drawing
a random cut-off age in the second half of the domain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(growth_incomplete)
</code></pre>


<h3>Format</h3>

<p>A dataframe made up of </p>

<dl>
<dt>id</dt><dd><p>A unique subject identifier;</p>
</dd>
<dt>index</dt><dd><p>Observed age of the child's height;</p>
</dd>
<dt>value</dt><dd><p>First derivative of the height development in the given age.</p>
</dd>
</dl>



<h3>References</h3>

<p>Ramsay, J. O., and Silverman, B. W. (2006),
<em>Functional Data Analysis, 2nd ed.</em>, Springer, New York.
</p>
<p>Tuddenham, R. D., and Snyder, M. M. (1954).
Physical growth of California boys and girls from birth to age 18.
<em>University of California Publications in Child Development</em>, 1, 183-364.
</p>

<hr>
<h2 id='initial_params'>Create initial parameters for (inverse) warping functions</h2><span id='topic+initial_params'></span>

<h3>Description</h3>

<p>Dependent on the specific type of warping functions, this function creates
a vector of initial parameters. For <code>"nonparametric"</code> warpings that
are based on a given spline basis matrix, the initial parameters are defined
s.t. the resulting (inverse) warping function equals a diagonal line.
For <code>"piecewise_linear2"</code> warpings a fixed parameter vector is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initial_params(warping = "nonparametric", K, t_vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initial_params_+3A_warping">warping</code></td>
<td>
<p>If <code>nonparametric</code> (default), inverse warping functions are estimated nonparametrically. 
If <code>piecewise_linear2</code> they follow a piecewise linear function with 2 knots.</p>
</td></tr>
<tr><td><code id="initial_params_+3A_k">K</code></td>
<td>
<p>Spline basis matrix defined over the interval <code>c(t_min, t_max)</code>.</p>
</td></tr>
<tr><td><code id="initial_params_+3A_t_vec">t_vec</code></td>
<td>
<p>Vector of the observed and potentially irregular time grid.</p>
</td></tr>
</table>

<hr>
<h2 id='lambdaF'>Apply lambda transformation of variational parameter.</h2><span id='topic+lambdaF'></span>

<h3>Description</h3>

<p>Simple function for use within other C++ functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambdaF(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lambdaF_+3A_x">x</code></td>
<td>
<p>The value to which you apply the function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value that has been transformed.
</p>

<hr>
<h2 id='loss_h'>Loss function for registration step optimization</h2><span id='topic+loss_h'></span>

<h3>Description</h3>

<p>Loss function for registration step optimization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loss_h(
  Y,
  Theta_h,
  mean_coefs,
  knots,
  beta.inner,
  family,
  t_min,
  t_max,
  t_min_curve,
  t_max_curve,
  incompleteness = NULL,
  lambda_inc = NULL,
  periodic = FALSE,
  Kt = 8,
  warping = "nonparametric",
  priors = FALSE,
  prior_sd = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loss_h_+3A_y">Y</code></td>
<td>
<p>vector of observed points.</p>
</td></tr>
<tr><td><code id="loss_h_+3A_theta_h">Theta_h</code></td>
<td>
<p>B-spline basis for inverse warping functions.</p>
</td></tr>
<tr><td><code id="loss_h_+3A_mean_coefs">mean_coefs</code></td>
<td>
<p>spline coefficient vector for mean curve.</p>
</td></tr>
<tr><td><code id="loss_h_+3A_knots">knots</code></td>
<td>
<p>knot locations for B-spline basis used to estimate mean and FPC basis function.</p>
</td></tr>
<tr><td><code id="loss_h_+3A_beta.inner">beta.inner</code></td>
<td>
<p>spline coefficient vector to be estimated for warping function h.</p>
</td></tr>
<tr><td><code id="loss_h_+3A_family">family</code></td>
<td>
<p>One of <code>c("gaussian","binomial","gamma","poisson")</code>.
For internal purposes, can also be set to <code>"gamma-varEM"</code> and
<code>"poisson-varEM"</code> if the preceding FPCA step in <code>register_fpca</code> was
performed with <code>fpca_type = "variationalEM"</code> which uses Gaussian family.</p>
</td></tr>
<tr><td><code id="loss_h_+3A_t_min">t_min</code>, <code id="loss_h_+3A_t_max">t_max</code></td>
<td>
<p>minimum and maximum value to be evaluated on the time domain.</p>
</td></tr>
<tr><td><code id="loss_h_+3A_t_min_curve">t_min_curve</code>, <code id="loss_h_+3A_t_max_curve">t_max_curve</code></td>
<td>
<p>minimum and maximum value of the observed time domain of the
(potentially incomplete) curve.</p>
</td></tr>
<tr><td><code id="loss_h_+3A_incompleteness">incompleteness</code></td>
<td>
<p>Optional specification of incompleteness structure.
One of <code>c("leading","trailing","full")</code>, specifying that incompleteness
is present only in the initial measurements, only in the trailing measurements, or
in both, respectively. For details see the accompanying vignette.
Defaults to NULL, i.e. no incompleteness structure.
Can only be set when <code>warping = "nonparametric"</code>.</p>
</td></tr>
<tr><td><code id="loss_h_+3A_lambda_inc">lambda_inc</code></td>
<td>
<p>Penalization parameter to control the amount of
overall dilation of the domain.
The higher this lambda, the more the registered domains are forced to have the
same length as the observed domains.
Only used if <code>incompleteness</code> is not NULL.</p>
</td></tr>
<tr><td><code id="loss_h_+3A_periodic">periodic</code></td>
<td>
<p>If <code>TRUE</code> uses periodic b-spline basis functions. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="loss_h_+3A_kt">Kt</code></td>
<td>
<p>Number of B-spline basis functions used to estimate mean functions. Default is 8.</p>
</td></tr>
<tr><td><code id="loss_h_+3A_warping">warping</code></td>
<td>
<p>If <code>nonparametric</code> (default), inverse warping functions are estimated nonparametrically. 
If <code>piecewise_linear2</code> they follow a piecewise linear function with 2 knots.</p>
</td></tr>
<tr><td><code id="loss_h_+3A_priors">priors</code></td>
<td>
<p>For <code>warping = "piecewise_linear2"</code> only. Logical indicator of whether to add Normal priors to pull the knots toward the identity line.</p>
</td></tr>
<tr><td><code id="loss_h_+3A_prior_sd">prior_sd</code></td>
<td>
<p>For <code>warping = "piecewise_linear2"</code> with <code>priors = TRUE</code> only. User-specified standard deviation for the Normal priors 
(single value applied to all 4 knot priors).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The scalar value taken by the loss function.
</p>


<h3>Author(s)</h3>

<p>Julia Wrobel <a href="mailto:julia.wrobel@cuanschutz.edu">julia.wrobel@cuanschutz.edu</a>,
Erin McDonnell <a href="mailto:eim2117@cumc.columbia.edu">eim2117@cumc.columbia.edu</a>,
Alexander Bauer <a href="mailto:alexander.bauer@stat.uni-muenchen.de">alexander.bauer@stat.uni-muenchen.de</a>
</p>

<hr>
<h2 id='loss_h_gradient'>Gradient of loss function for registration step</h2><span id='topic+loss_h_gradient'></span>

<h3>Description</h3>

<p>Gradient of loss function for registration step
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loss_h_gradient(
  Y,
  Theta_h,
  mean_coefs,
  knots,
  beta.inner,
  family = "gaussian",
  incompleteness = NULL,
  lambda_inc = NULL,
  t_min,
  t_max,
  t_min_curve,
  t_max_curve,
  Kt = 8,
  periodic = FALSE,
  warping = "nonparametric"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loss_h_gradient_+3A_y">Y</code></td>
<td>
<p>vector of observed points.</p>
</td></tr>
<tr><td><code id="loss_h_gradient_+3A_theta_h">Theta_h</code></td>
<td>
<p>B-spline basis for inverse warping functions.</p>
</td></tr>
<tr><td><code id="loss_h_gradient_+3A_mean_coefs">mean_coefs</code></td>
<td>
<p>spline coefficient vector for mean curve.</p>
</td></tr>
<tr><td><code id="loss_h_gradient_+3A_knots">knots</code></td>
<td>
<p>knot locations for B-spline basis used to estimate mean and FPC basis function.</p>
</td></tr>
<tr><td><code id="loss_h_gradient_+3A_beta.inner">beta.inner</code></td>
<td>
<p>spline coefficient vector to be estimated for warping function h.</p>
</td></tr>
<tr><td><code id="loss_h_gradient_+3A_family">family</code></td>
<td>
<p>One of <code>c("gaussian","binomial")</code>. Defaults to <code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="loss_h_gradient_+3A_incompleteness">incompleteness</code></td>
<td>
<p>Optional specification of incompleteness structure.
One of <code>c("leading","trailing","full")</code>, specifying that incompleteness
is present only in the initial measurements, only in the trailing measurements, or
in both, respectively. For details see the accompanying vignette.
Defaults to NULL, i.e. no incompleteness structure.
Can only be set when <code>warping = "nonparametric"</code>.</p>
</td></tr>
<tr><td><code id="loss_h_gradient_+3A_lambda_inc">lambda_inc</code></td>
<td>
<p>Penalization parameter to control the amount of
overall dilation of the domain.
The higher this lambda, the more the registered domains are forced to have the
same length as the observed domains.
Only used if <code>incompleteness</code> is not NULL.</p>
</td></tr>
<tr><td><code id="loss_h_gradient_+3A_t_min">t_min</code></td>
<td>
<p>minimum and maximum value to be evaluated on the time domain.</p>
</td></tr>
<tr><td><code id="loss_h_gradient_+3A_t_max">t_max</code></td>
<td>
<p>minimum and maximum value to be evaluated on the time domain.</p>
</td></tr>
<tr><td><code id="loss_h_gradient_+3A_t_min_curve">t_min_curve</code></td>
<td>
<p>minimum and maximum value of the observed time domain of the
(potentially incomplete) curve.</p>
</td></tr>
<tr><td><code id="loss_h_gradient_+3A_t_max_curve">t_max_curve</code></td>
<td>
<p>minimum and maximum value of the observed time domain of the
(potentially incomplete) curve.</p>
</td></tr>
<tr><td><code id="loss_h_gradient_+3A_kt">Kt</code></td>
<td>
<p>Number of B-spline basis functions used to estimate mean functions. Default is 8.</p>
</td></tr>
<tr><td><code id="loss_h_gradient_+3A_periodic">periodic</code></td>
<td>
<p>If <code>TRUE</code>, uses periodic b-spline basis functions. Default is <code>FALSE</code>. 
<code>loss_h_gradient()</code> is currently only available for <code>periodic = FALSE</code>.</p>
</td></tr>
<tr><td><code id="loss_h_gradient_+3A_warping">warping</code></td>
<td>
<p>If <code>nonparametric</code> (default), inverse warping functions are estimated nonparametrically. 
If <code>piecewise_linear2</code> they follow a piecewise linear function with 2 knots.
<code>loss_h_gradient()</code> is currently only available for <code>warping = "nonparametric"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of spline coefficients for the gradient of the loss function.
</p>


<h3>Author(s)</h3>

<p>Julia Wrobel <a href="mailto:julia.wrobel@cuanschutz.edu">julia.wrobel@cuanschutz.edu</a>,
Alexander Bauer <a href="mailto:alexander.bauer@stat.uni-muenchen.de">alexander.bauer@stat.uni-muenchen.de</a>
</p>

<hr>
<h2 id='mean_curve'>Simulate mean curve</h2><span id='topic+mean_curve'></span>

<h3>Description</h3>

<p>This function generates mean for simulated accelerometer data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_curve(grid, period = 2 * pi, spline_based = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_curve_+3A_grid">grid</code></td>
<td>
<p>Grid of x values over which to evaluate the function.</p>
</td></tr>
<tr><td><code id="mean_curve_+3A_period">period</code></td>
<td>
<p>Controls the period of the mean curve</p>
</td></tr>
<tr><td><code id="mean_curve_+3A_spline_based">spline_based</code></td>
<td>
<p>If FALSE curve is constructed using sine and cosine functions,
if TRUE, curve is constructed using B-spline basis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector.
</p>

<hr>
<h2 id='mean_sim'>Simulate mean</h2><span id='topic+mean_sim'></span>

<h3>Description</h3>

<p>This function generates mean for simulated functional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_sim(grid)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_sim_+3A_grid">grid</code></td>
<td>
<p>Grid of x values over which to evaluate the function.</p>
</td></tr>
</table>

<hr>
<h2 id='nhanes'>NHANES activity data</h2><span id='topic+nhanes'></span>

<h3>Description</h3>

<p>Subset of 24 hours of activity data for 50 subjects from 2003-2004
National Health and Nutrition Examination Survey (NHANES). 
Each subject is observed over 24 hours on a Sunday and wore the 
activity collection device for a minimum of 10 hours. Activity is measured each minute over 24 hours.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(nhanes)
</code></pre>


<h3>Format</h3>

<p>A dataframe made up of </p>

<dl>
<dt>id</dt><dd><p>A unique subject identifier;</p>
</dd>
<dt>age</dt><dd><p>Age of survey participant;</p>
</dd>
<dt>gender</dt><dd><p>Gender of survey participant;</p>
</dd>
<dt>index</dt><dd><p>Observed time of activity measurement. Integers from 1 to 1440, indicating minutes
from midnight to midnight;</p>
</dd>
<dt>value</dt><dd><p>Binary value of zero or one indicating inactivity or activity;</p>
</dd>
<dt>raw_activity</dt><dd><p>Raw activity count.</p>
</dd>
</dl>


<hr>
<h2 id='piecewise_linear2_hinv'>Create two-parameter piecewise linear (inverse) warping functions</h2><span id='topic+piecewise_linear2_hinv'></span>

<h3>Description</h3>

<p>This function uses a 2-knot piecewise linear model to calculate inverse warping 
functions for registration. The parameters <code>knot1_x</code> and <code>knot1_y</code>
control the x and y locations of the first knot, and the parameters
<code>knot1_x</code> and <code>knot1_y</code> control the x and y locations of the second
knot. The designation (inverse) is intended to communicate that these 
functions take data from the unregistered space to the registered space, 
consistent with functional data literature on registration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>piecewise_linear2_hinv(grid, knot_locations = c(0.25, 0.3, 0.75, 0.9))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="piecewise_linear2_hinv_+3A_grid">grid</code></td>
<td>
<p>grid of values over which to evaluate the function.</p>
</td></tr>
<tr><td><code id="piecewise_linear2_hinv_+3A_knot_locations">knot_locations</code></td>
<td>
<p>controls the x and y locations of the two knots.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Erin McDonnell <a href="mailto:eim2117@cumc.columbia.edu">eim2117@cumc.columbia.edu</a>
</p>

<hr>
<h2 id='plot.fpca'>Plot the results of a functional PCA</h2><span id='topic+plot.fpca'></span>

<h3>Description</h3>

<p>S3 plot method for class <code>fpca</code>.
Plot FPCA results by visualizing the variation of the individual FPCs around
the global mean. based on an object created with function
<code><a href="#topic+fpca_gauss">fpca_gauss</a></code>, <code><a href="#topic+bfpca">bfpca</a></code> or <code><a href="#topic+gfpca_twoStep">gfpca_twoStep</a></code>. <br /> <br />
The shares of explained variance are included in the plot titles if
<code>x</code> contains an element <code>evalues_sum</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fpca'
plot(
  x,
  plot_FPCs = 1:x$npc,
  sd_factor = 2,
  response_function = NULL,
  add_symbols = TRUE,
  subtitle = TRUE,
  xlim = NULL,
  ylim = NULL,
  xlab = "t [registered]",
  ylab = "y",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fpca_+3A_x">x</code></td>
<td>
<p>Object of class <code>"fpca"</code>.</p>
</td></tr>
<tr><td><code id="plot.fpca_+3A_plot_fpcs">plot_FPCs</code></td>
<td>
<p>Optional index vector of the FPCs to be plotted.
Defaults to all FPCs contained in <code>x</code>.</p>
</td></tr>
<tr><td><code id="plot.fpca_+3A_sd_factor">sd_factor</code></td>
<td>
<p>Numeric factor with which the standard deviations of each
FPC's scores are multiplied to display its variation in the plots.
Defaults to 2.</p>
</td></tr>
<tr><td><code id="plot.fpca_+3A_response_function">response_function</code></td>
<td>
<p>Optional response function to be applied before
plotting the curves. Defaults to <code>NULL</code>, i.e. the identity function if
<code>x$family</code> is one of <code>c("gaussian","binomial")</code> or
<code>exp()</code> if <code>x$family</code> is one of <code>c("gamma","poisson")</code>.</p>
</td></tr>
<tr><td><code id="plot.fpca_+3A_add_symbols">add_symbols</code></td>
<td>
<p>Indicator if '+' and '-' symbols should be added to the
plot to highlight the direction of the displayed FPCs. Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="plot.fpca_+3A_subtitle">subtitle</code></td>
<td>
<p>If TRUE (default) the parameter <code>sd_factor</code>
is displayed in the plot subtitle.</p>
</td></tr>
<tr><td><code id="plot.fpca_+3A_xlim">xlim</code>, <code id="plot.fpca_+3A_ylim">ylim</code></td>
<td>
<p>Optional numeric vectors with limits for the x and y axis.</p>
</td></tr>
<tr><td><code id="plot.fpca_+3A_xlab">xlab</code>, <code id="plot.fpca_+3A_ylab">ylab</code></td>
<td>
<p>Optional titles for the x and y axis.</p>
</td></tr>
<tr><td><code id="plot.fpca_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="ggplot2.html#topic+theme">theme</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>@return If multiple FPCs are plotted, returns a grid of <code>ggplot</code>
plots, created with <code>cowplot::plot_grid</code>. If only one FPC is plotted,
returns a single <code>ggplot</code> plot.
</p>


<h3>Author(s)</h3>

<p>Alexander Bauer <a href="mailto:alexander.bauer@stat.uni-muenchen.de">alexander.bauer@stat.uni-muenchen.de</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(growth_incomplete)

fpca_obj = fpca_gauss(Y = growth_incomplete, npc = 2)
if (requireNamespace("ggplot2", quietly = TRUE) &amp;&amp;
requireNamespace("cowplot", quietly = TRUE)) {
library(ggplot2)
plot(fpca_obj)
}

</code></pre>

<hr>
<h2 id='psi1_sim'>Simulate PC1</h2><span id='topic+psi1_sim'></span>

<h3>Description</h3>

<p>This function generates the first principal component for simulated functional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psi1_sim(grid)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psi1_sim_+3A_grid">grid</code></td>
<td>
<p>Grid of x values over which to evaluate the function.</p>
</td></tr>
</table>

<hr>
<h2 id='psi2_sim'>Simulate PC2</h2><span id='topic+psi2_sim'></span>

<h3>Description</h3>

<p>This function generates the second principal component for simulated functional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psi2_sim(grid)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psi2_sim_+3A_grid">grid</code></td>
<td>
<p>Grid of x values over which to evaluate the function.</p>
</td></tr>
</table>

<hr>
<h2 id='register_fpca'>Register curves using constrained optimization and GFPCA</h2><span id='topic+register_fpca'></span>

<h3>Description</h3>

<p>Function combines constrained optimization and GFPCA to estimate warping functions for 
exponential family curves. See argument <code>family</code> for which families are
supported. Warping functions are calculated by the function <code><a href="#topic+registr">registr</a></code>.
The GFPCA step can be performed either using the variational EM-based GFPCA
approaches of Wrobel et al. (2019) (<code>fpca_type = "variationalEM"</code>, default)
or the mixed model-based two-step approach of Gertheiss et al. (2017)
(<code>fpca_type = "two-step"</code>). <br /> <br />
Warping functions by default are forced to start and end on the diagonal to be
domain-preserving. This behavior can be changed by setting
<code>incompleteness</code> to some other value than NULL and a reasonable <code>lambda_inc</code> value.
For further details see the accompanying vignette. <br /> <br />
The number of functional principal components (FPCs) can either be specified
directly (argument <code>npc</code>) or chosen based on the explained share of
variance in each iteration (argument <code>npc_criterion</code>). <br /> <br />
By specifying <code>cores &gt; 1</code> the registration call can be parallelized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>register_fpca(
  Y,
  Kt = 8,
  Kh = 4,
  family = "gaussian",
  incompleteness = NULL,
  lambda_inc = NULL,
  Y_template = NULL,
  max_iterations = 10,
  npc = NULL,
  npc_criterion = NULL,
  fpca_type = "variationalEM",
  fpca_maxiter = 50,
  fpca_seed = 1988,
  fpca_error_thresh = 1e-04,
  fpca_index_significantDigits = 4L,
  cores = 1L,
  verbose = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="register_fpca_+3A_y">Y</code></td>
<td>
<p>Dataframe. Should have values id, value, index.</p>
</td></tr>
<tr><td><code id="register_fpca_+3A_kt">Kt</code></td>
<td>
<p>Number of B-spline basis functions used to estimate mean functions
and functional principal components. Default is 8. If
<code>fpca_type = "variationalEM"</code> and <code>npc_criterion</code> is used,
<code>Kt</code> is set to 20.</p>
</td></tr>
<tr><td><code id="register_fpca_+3A_kh">Kh</code></td>
<td>
<p>Number of B-spline basis functions used to estimate warping functions <em>h</em>. Default is 4.</p>
</td></tr>
<tr><td><code id="register_fpca_+3A_family">family</code></td>
<td>
<p>One of <code>c("gaussian","binomial","gamma","poisson")</code>.
Families <code>"gamma"</code> and <code>"poisson"</code> are only supported by
<code>fpca_type = "two-step"</code>. Defaults to <code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="register_fpca_+3A_incompleteness">incompleteness</code></td>
<td>
<p>Optional specification of incompleteness structure.
One of <code>c("leading","trailing","full")</code>, specifying that incompleteness
is present only in the initial measurements, only in the trailing measurements, or
in both, respectively. For details see the accompanying vignette.
Defaults to NULL, i.e. no incompleteness structure.
Can only be set when <code>warping = "nonparametric"</code>.</p>
</td></tr>
<tr><td><code id="register_fpca_+3A_lambda_inc">lambda_inc</code></td>
<td>
<p>Penalization parameter to control the amount of
overall dilation of the domain.
The higher this lambda, the more the registered domains are forced to have the
same length as the observed domains.
Only used if <code>incompleteness</code> is not NULL.</p>
</td></tr>
<tr><td><code id="register_fpca_+3A_y_template">Y_template</code></td>
<td>
<p>Optional dataframe with the same structure as <code>Y</code>.
Only used for the initial registration step. If NULL,
curves are registered to the overall mean of all curves in <code>Y</code> as template function.
If specified, the template function is taken as the mean
of all curves in <code>Y_template</code>. Defaults to NULL.</p>
</td></tr>
<tr><td><code id="register_fpca_+3A_max_iterations">max_iterations</code></td>
<td>
<p>Number of iterations for overall algorithm. Defaults to 10.</p>
</td></tr>
<tr><td><code id="register_fpca_+3A_npc">npc</code>, <code id="register_fpca_+3A_npc_criterion">npc_criterion</code></td>
<td>
<p>The number of functional principal components (FPCs)
has to be specified either directly as <code>npc</code> or based on their explained
share of variance. In the latter case, <code>npc_criterion</code> has to be set
to a number between 0 and 1. For <code>fpca_type = "two-step"</code>, it is also
possible to cut off potential tails of subordinate FPCs (see
<code><a href="#topic+gfpca_twoStep">gfpca_twoStep</a></code> for details).</p>
</td></tr>
<tr><td><code id="register_fpca_+3A_fpca_type">fpca_type</code></td>
<td>
<p>One of <code>c("variationalEM","two-step")</code>.
Defaults to <code>"variationalEM"</code>.</p>
</td></tr>
<tr><td><code id="register_fpca_+3A_fpca_maxiter">fpca_maxiter</code></td>
<td>
<p>Only used if <code>fpca_type = "variationalEM"</code>. Number
to pass to the <code>maxiter</code> argument of 'bfpca()' or 'fpca_gauss()'. 
Defaults to 50.</p>
</td></tr>
<tr><td><code id="register_fpca_+3A_fpca_seed">fpca_seed</code></td>
<td>
<p>Only used if <code>fpca_type = "variationalEM"</code>. Number to
pass to the <code>seed</code> argument of 'bfpca()' or 'fpca_gauss()'. Defaults to
1988.</p>
</td></tr>
<tr><td><code id="register_fpca_+3A_fpca_error_thresh">fpca_error_thresh</code></td>
<td>
<p>Only used if <code>fpca_type = "variationalEM"</code>.
Number to pass to the <code>error_thresh</code> argument of 'bfpca()' or
'fpca_gauss()'. Defaults to 0.0001.</p>
</td></tr>
<tr><td><code id="register_fpca_+3A_fpca_index_significantdigits">fpca_index_significantDigits</code></td>
<td>
<p>Only used if <code>fpca_type = "two-step"</code>.
Positive integer <code>&gt;= 2</code>, stating the number of significant digits to which
the index grid should be rounded in the GFPCA step. Coarsening the index grid
is necessary since otherwise the covariance surface matrix explodes in size
in the presence of too many unique index values (which is the case after some
registration step). Defaults to 4. Set to <code>NULL</code> to prevent rounding.</p>
</td></tr>
<tr><td><code id="register_fpca_+3A_cores">cores</code></td>
<td>
<p>Number of cores to be used. If <code>cores &gt; 1</code>, the registration
call is parallelized by using <code>parallel::mclapply</code> (for Unix-based
systems) or <code>parallel::parLapply</code> (for Windows). Defaults to 1,
no parallelized call.</p>
</td></tr>
<tr><td><code id="register_fpca_+3A_verbose">verbose</code></td>
<td>
<p>Can be set to integers between 0 and 4 to control the level of
detail of the printed diagnostic messages. Higher numbers lead to more detailed
messages. Defaults to 1.</p>
</td></tr>
<tr><td><code id="register_fpca_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to registr and to the gfpca functions
(if <code>fpca_type = "variationalEM"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Requires input data <code>Y</code> to be a dataframe in long format with variables 
<code>id</code>, <code>index</code>, and <code>value</code> to indicate subject IDs, 
observation times on the domain, and observations, respectively.
</p>
<p>One joint iteration consists of a GFPCA step and a registration step.
As preprocessing, one initial registration step is performed.
The template function for this registration step is defined by argument
<code>Y_template</code>.
After convergence or <code>max_iterations</code> is reached, one final GFPCA step
is performed.
</p>


<h3>Value</h3>

<p>An object of class <code>registration</code> containing:
</p>
<table>
<tr><td><code>Y</code></td>
<td>
<p>The observed data plus variables <code>t_star</code> and <code>t_hat</code> which are the
unregistered grid and registered grid, respectively.</p>
</td></tr>
<tr><td><code>fpca_obj</code></td>
<td>
<p>List of items from FPCA step.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>Used exponential family.</p>
</td></tr>
<tr><td><code>index_warped</code></td>
<td>
<p>List of the (warped) index values for each iteration.
Has <code>'convergence$iterations + 2'</code> elements since the first two elements
contain the original (observed) index and the warped index values from the
preprocessing registration step (see Details), respectively.</p>
</td></tr>
<tr><td><code>hinv_innerKnots</code></td>
<td>
<p>List of inner knots for setting up the spline bases
for the inverse warping functions. Only contains <code>NULL</code> values for
<code>Kh &lt;= 4</code>.</p>
</td></tr>
<tr><td><code>hinv_beta</code></td>
<td>
<p>Matrix of B-spline basis coefficients used to construct the
subject-specific inverse warping functions. From the last performed
registration step. For details see <code>?registr</code>.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>List with information on the convergence of the joint
approach. Containing the following elements: <br /> <br />
<em>converged</em> <br />
Indicator if the joint algorithm converged or if not
(i.e., <code>max_iterations</code> was reached) <br /> <br />
<em>iterations</em> <br />
Number of joint iterations that were performed. <br /> <br />
<em>delta_index</em> <br />
Vector of mean squared differences between the (warped) index values
(scaled to [0,1] based on the size of the observed domain)
in the current and the previous iteration.
Convergence is reached if this measure drops below 0.0001. <br /> <br />
<em>registration_loss</em> <br />
Vector of the loss in each iteration of the algorithm.
Calculated in the registration step using the exponential family
likelihood with natural parameter from the FPCA step.
Has <code>'iterations + 1'</code> elements since the first element contains the
loss of the preprocessing registration step (see Details).
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Julia Wrobel <a href="mailto:julia.wrobel@cuanschutz.edu">julia.wrobel@cuanschutz.edu</a>
Jeff Goldsmith <a href="mailto:ajg2202@cumc.columbia.edu">ajg2202@cumc.columbia.edu</a>,
Alexander Bauer <a href="mailto:alexander.bauer@stat.uni-muenchen.de">alexander.bauer@stat.uni-muenchen.de</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### complete binomial curves
Y = simulate_unregistered_curves(I = 20, D = 200)

# estimation based on Wrobel et al. (2019)
reg = register_fpca(Y, npc = 2, family = "binomial",
                    fpca_type = "variationalEM", max_iterations = 5)

if (requireNamespace("ggplot2", quietly = TRUE)) {
  library(ggplot2)
  
  ggplot(reg$Y, aes(x = tstar, y = t_hat, group = id)) +
    geom_line(alpha = 0.2) + ggtitle("Estimated warping functions")
  
  plot(reg$fpca_obj, response_function = function(x) { 1 / (1 + exp(-x)) })
}




# estimation based on Gertheiss et al. (2017)
reg2 = register_fpca(Y, npc = 2, family = "binomial",
                     fpca_type = "two-step", max_iterations = 5,
                     fpca_index_significantDigits = 4)
                     
# example using accelerometer data from nhanes 2003-2004 study
data(nhanes)
nhanes_short = nhanes[nhanes$id %in% unique(nhanes$id)[1:5],]
reg_nhanes   = register_fpca(nhanes_short, npc = 2, family = "binomial", max_iterations = 5)


### incomplete Gaussian curves
data(growth_incomplete)

# Force the warping functions to start and end on the diagonal
reg2a = register_fpca(growth_incomplete, npc = 2, family = "gaussian",
                      incompleteness = NULL, max_iterations = 5)
if (requireNamespace("ggplot2", quietly = TRUE)) {
  
  ggplot(reg2a$Y, aes(x = tstar, y = t_hat, group = id)) +
    geom_line(alpha = 0.2) +
    ggtitle("Estimated warping functions")
  ggplot(reg2a$Y, aes(x = t_hat, y = value, group = id)) +
    geom_line(alpha = 0.2) +
    ggtitle("Registered curves")
}
# Allow the warping functions to not start / end on the diagonal.
# The higher lambda_inc, the more the starting points and endpoints are forced
# towards the diagonal.
reg2b = register_fpca(growth_incomplete, npc = 2, family = "gaussian",
                      incompleteness = "full", lambda_inc = 0.1,
                      max_iterations = 5)
if (requireNamespace("ggplot2", quietly = TRUE)) {
  ggplot(reg2b$Y, aes(x = tstar, y = t_hat, group = id)) +
    geom_line(alpha = 0.2) +
    ggtitle("Estimated warping functions")
  ggplot(reg2b$Y, aes(x = t_hat, y = value, group = id)) +
    geom_line(alpha = 0.2) +
    ggtitle("Registered curves")
}

### complete Gamma curves
Y             = simulate_unregistered_curves(I = 20, D = 100)
Y$value       = exp(Y$latent_mean)
registr_gamma = register_fpca(Y, npc = 2, family = "gamma", fpca_type = "two-step",
                              gradient = FALSE, max_iterations = 3)


</code></pre>

<hr>
<h2 id='registr'>Register Exponential Family Functional Data</h2><span id='topic+registr'></span>

<h3>Description</h3>

<p>Software for registering functional data from the exponential family of distributions.
</p>
<p>Function used in the registration step of an FPCA-based approach for 
registering exponential-family, potentially incomplete functional data,
called by <code><a href="#topic+register_fpca">register_fpca</a></code>. 
This method uses constrained optimization to estimate spline 
coefficients for warping functions, where the objective function for optimization comes from 
maximizing the EF likelihood subject to monotonicity constraints on the warping functions. 
You have to either specify <code>obj</code>, which is a fpca 
object from an earlier step, or <code>Y</code>, a dataframe in long format with variables 
<code>id</code>, <code>index</code>, and <code>value</code> to indicate subject IDs, times, and observations, 
respectively. <br /> <br />
Warping functions by default are forced to start and end on the diagonal to be
domain-preserving. This behavior can be changed by setting
<code>incompleteness</code> to some other value than NULL and a reasonable <code>lambda_inc</code> value.
For further details see the accompanying vignette. <br /> <br />
By specifying <code>cores &gt; 1</code> the registration call can be parallelized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>registr(
  obj = NULL,
  Y = NULL,
  Kt = 8,
  Kh = 4,
  family = "gaussian",
  gradient = TRUE,
  incompleteness = NULL,
  lambda_inc = NULL,
  Y_template = NULL,
  beta = NULL,
  t_min = NULL,
  t_max = NULL,
  row_obj = NULL,
  periodic = FALSE,
  warping = "nonparametric",
  gamma_scales = NULL,
  cores = 1L,
  subsample = TRUE,
  verbose = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="registr_+3A_obj">obj</code></td>
<td>
<p>Current estimate of FPC object. 
Can be NULL only if Y argument is selected.</p>
</td></tr>
<tr><td><code id="registr_+3A_y">Y</code></td>
<td>
<p>Dataframe. Should have values id, value, index.</p>
</td></tr>
<tr><td><code id="registr_+3A_kt">Kt</code></td>
<td>
<p>Number of B-spline basis functions used to estimate mean functions. Default is 8.</p>
</td></tr>
<tr><td><code id="registr_+3A_kh">Kh</code></td>
<td>
<p>Number of B-spline basis functions used to estimate warping functions <em>h</em>. Default is 4.</p>
</td></tr>
<tr><td><code id="registr_+3A_family">family</code></td>
<td>
<p>One of <code>c("gaussian","binomial","gamma","poisson")</code>. Defaults to
<code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="registr_+3A_gradient">gradient</code></td>
<td>
<p>If <code>TRUE</code>, uses analytic gradient to calculate derivative. 
If <code>FALSE</code>, calculates gradient numerically. Not available for families
<code>"gamma","poisson"</code>.</p>
</td></tr>
<tr><td><code id="registr_+3A_incompleteness">incompleteness</code></td>
<td>
<p>Optional specification of incompleteness structure.
One of <code>c("leading","trailing","full")</code>, specifying that incompleteness
is present only in the initial measurements, only in the trailing measurements, or
in both, respectively. For details see the accompanying vignette.
Defaults to NULL, i.e. no incompleteness structure.
Can only be set when <code>warping = "nonparametric"</code>.</p>
</td></tr>
<tr><td><code id="registr_+3A_lambda_inc">lambda_inc</code></td>
<td>
<p>Penalization parameter to control the amount of
overall dilation of the domain.
The higher this lambda, the more the registered domains are forced to have the
same length as the observed domains.
Only used if <code>incompleteness</code> is not NULL.</p>
</td></tr>
<tr><td><code id="registr_+3A_y_template">Y_template</code></td>
<td>
<p>Optional dataframe with the same structure as <code>Y</code>.
Only used if <code>obj</code> is NULL. If <code>Y_template</code> is NULL,
curves are registered to the overall mean of all curves in <code>Y</code> as template function.
If <code>Y_template</code> is specified, the template function is taken as the mean
of all curves in <code>Y_template</code>. Default is NULL.</p>
</td></tr>
<tr><td><code id="registr_+3A_beta">beta</code></td>
<td>
<p>Current estimates for beta for each subject. Default is NULL.</p>
</td></tr>
<tr><td><code id="registr_+3A_t_min">t_min</code></td>
<td>
<p>Minimum value to be evaluated on the time domain.
if 'NULL', taken to be minimum observed value.</p>
</td></tr>
<tr><td><code id="registr_+3A_t_max">t_max</code></td>
<td>
<p>Maximum value to be evaluated on the time domain. 
if 'NULL', taken to be maximum observed value.</p>
</td></tr>
<tr><td><code id="registr_+3A_row_obj">row_obj</code></td>
<td>
<p>If NULL, the function cleans the data and calculates row indices. 
Keep this NULL if you are using standalone <code>registr</code> function.</p>
</td></tr>
<tr><td><code id="registr_+3A_periodic">periodic</code></td>
<td>
<p>If <code>TRUE</code>, uses periodic b-spline basis functions. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="registr_+3A_warping">warping</code></td>
<td>
<p>If <code>nonparametric</code> (default), inverse warping functions are estimated nonparametrically. 
If <code>piecewise_linear2</code> they follow a piecewise linear function with 2 knots.</p>
</td></tr>
<tr><td><code id="registr_+3A_gamma_scales">gamma_scales</code></td>
<td>
<p>Only used for <code>family = "gamma"</code>.
Vector with one entry for each subject, containing the current estimate for the scale parameter of its
gamma distribution. Default is NULL, which sets the starting value for the scale parameter to 1.5.</p>
</td></tr>
<tr><td><code id="registr_+3A_cores">cores</code></td>
<td>
<p>Number of cores to be used. If <code>cores &gt; 1</code>, the registration
call is parallelized by using <code>parallel::mclapply</code> (for Unix-based
systems) or <code>parallel::parLapply</code> (for Windows). Defaults to 1,
no parallelized call.</p>
</td></tr>
<tr><td><code id="registr_+3A_subsample">subsample</code></td>
<td>
<p>if the number of rows of the data is greater than 
10 million rows, the 'id' values are subsampled to get the mean coefficients.</p>
</td></tr>
<tr><td><code id="registr_+3A_verbose">verbose</code></td>
<td>
<p>Can be set to integers between 0 and 4 to control the level of
detail of the printed diagnostic messages. Higher numbers lead to more detailed
messages. Defaults to 1.</p>
</td></tr>
<tr><td><code id="registr_+3A_...">...</code></td>
<td>
<p>additional arguments passed to or from other functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The template function for the registration is defined by argument <code>obj</code>
or <code>Y_template</code>, depending on if <code>obj</code> is NULL or not, respectively.
</p>


<h3>Value</h3>

<p>An list containing:
</p>
<table>
<tr><td><code>Y</code></td>
<td>
<p>The observed data. The variables <code>index</code> and <code>index_scaled</code>
contain the new estimated time domain.</p>
</td></tr>
<tr><td><code>loss</code></td>
<td>
<p>Value of the loss function after registraton.</p>
</td></tr>
<tr><td><code>hinv_innerKnots</code></td>
<td>
<p>List of inner knots for setting up the spline bases
for the inverse warping functions. Only contains <code>NULL</code> values for
<code>Kh &lt;= 4</code>.</p>
</td></tr>
<tr><td><code>hinv_beta</code></td>
<td>
<p>Matrix of B-spline basis coefficients used to construct
subject-specific inverse warping functions. See examples on how to
reconstruct a warping function based on <code>hinv_innerKnots</code> and
<code>hinv_beta</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Julia Wrobel
</p>
<p>Julia Wrobel <a href="mailto:julia.wrobel@cuanschutz.edu">julia.wrobel@cuanschutz.edu</a>,
Erin McDonnell <a href="mailto:eim2117@cumc.columbia.edu">eim2117@cumc.columbia.edu</a>,
Alexander Bauer <a href="mailto:alexander.bauer@stat.uni-muenchen.de">alexander.bauer@stat.uni-muenchen.de</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### complete binomial curves
Y = simulate_unregistered_curves()
register_step = registr(obj = NULL, Y = Y, Kt = 6, Kh = 4, family = "binomial", 
                        gradient = TRUE)

### incomplete Gaussian curves
data(growth_incomplete)

# Force the warping functions to start and end on the diagonal to preserve the domain
register_step2a = registr(obj = NULL, Y = growth_incomplete, Kt = 6, Kh = 4,
                          family = "gaussian", gradient = TRUE,
                          incompleteness = NULL)
if (requireNamespace("ggplot2", quietly = TRUE)) {
  library(ggplot2)

  ggplot(register_step2a$Y, aes(x = tstar, y = index, group = id)) +
    geom_line(alpha = 0.2) +
    ggtitle("Estimated warping functions")
  ggplot(register_step2a$Y, aes(x = index, y = value, group = id)) +
    geom_line(alpha = 0.2) +
    ggtitle("Registered curves")
}
  
# Example for how to recreate an estimated inverse warping function given
# the output of registr(). Focus on id "boy01".
id         = "boy01"
index_obsRange_i = range(growth_incomplete$index[growth_incomplete$id == id])
index      = seq(min(index_obsRange_i), max(index_obsRange_i), length.out = 100)
# (note that 'index' must contain both the observed min and max in index_obsRange_i)
Theta_h_i  = splines::bs(index, knots = register_step2a$hinv_innerKnots[[id]], intercept = TRUE)
index_reg  = as.vector(Theta_h_i %*% register_step2a$hinv_beta[,id])
warp_dat_i = data.frame(index_observed   = index,
                        index_registered = index_reg)
if (requireNamespace("ggplot2", quietly = TRUE)) {
  ggplot(warp_dat_i, aes(x = index_observed, y = index_registered)) + geom_line() +
    ggtitle("Extracted warping function for id 'boy01'")
}

# Allow the warping functions to not start / end on the diagonal.
# The higher lambda_inc, the more the starting points and endpoints are
# forced towards the diagonal.
register_step2b = registr(obj = NULL, Y = growth_incomplete, Kt = 6, Kh = 4,
                          family = "gaussian", gradient = TRUE,
                          incompleteness = "full", lambda_inc = 1)
if (requireNamespace("ggplot2", quietly = TRUE)) {
  ggplot(register_step2b$Y, aes(x = tstar, y = index, group = id)) +
    geom_line(alpha = 0.2) +
    ggtitle("Estimated warping functions")
  ggplot(register_step2b$Y, aes(x = index, y = value, group = id)) +
    geom_line(alpha = 0.2) +
    ggtitle("Registered curves")
}

# Define the template function only over a subset of the curves
# (even though not very reasonable in this example)
template_ids    = c("girl12","girl13","girl14")
Y_template      = growth_incomplete[growth_incomplete$id %in% template_ids,]
register_step2c = registr(obj = NULL, Y = growth_incomplete, Kt = 6, Kh = 4,
                          family = "gaussian", gradient = TRUE,
                          Y_template = Y_template,
                          incompleteness = "full", lambda_inc = 1)
if (requireNamespace("ggplot2", quietly = TRUE)) {
  ggplot(register_step2c$Y, aes(x = index, y = value, group = id)) +
    geom_line(alpha = 0.2) +
    ggtitle("Registered curves")
}



</code></pre>

<hr>
<h2 id='registr_oneCurve'>Internal function to register one curve</h2><span id='topic+registr_oneCurve'></span>

<h3>Description</h3>

<p>This internal function is only to be used from within <code>registr</code>.
It performs the main optimization step with <code>constrOptim</code> for the
registration of one curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>registr_oneCurve(
  obj = NULL,
  Y = NULL,
  Kt = 8,
  Kh = 4,
  family = "gaussian",
  gradient = TRUE,
  incompleteness = NULL,
  lambda_inc = NULL,
  beta = NULL,
  t_min = NULL,
  t_max = NULL,
  periodic = FALSE,
  warping = "nonparametric",
  gamma_scales = NULL,
  global_knots = NULL,
  mean_coefs = NULL,
  ...,
  verbose = 1,
  just_return_list = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="registr_oneCurve_+3A_obj">obj</code></td>
<td>
<p>Current estimate of FPC object. 
Can be NULL only if Y argument is selected.</p>
</td></tr>
<tr><td><code id="registr_oneCurve_+3A_y">Y</code></td>
<td>
<p>Dataframe. Should have values id, value, index.</p>
</td></tr>
<tr><td><code id="registr_oneCurve_+3A_kt">Kt</code></td>
<td>
<p>Number of B-spline basis functions used to estimate mean functions. Default is 8.</p>
</td></tr>
<tr><td><code id="registr_oneCurve_+3A_kh">Kh</code></td>
<td>
<p>Number of B-spline basis functions used to estimate warping functions <em>h</em>. Default is 4.</p>
</td></tr>
<tr><td><code id="registr_oneCurve_+3A_family">family</code></td>
<td>
<p>One of <code>c("gaussian","binomial","gamma","poisson")</code>. Defaults to
<code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="registr_oneCurve_+3A_gradient">gradient</code></td>
<td>
<p>If <code>TRUE</code>, uses analytic gradient to calculate derivative. 
If <code>FALSE</code>, calculates gradient numerically. Not available for families
<code>"gamma","poisson"</code>.</p>
</td></tr>
<tr><td><code id="registr_oneCurve_+3A_incompleteness">incompleteness</code></td>
<td>
<p>Optional specification of incompleteness structure.
One of <code>c("leading","trailing","full")</code>, specifying that incompleteness
is present only in the initial measurements, only in the trailing measurements, or
in both, respectively. For details see the accompanying vignette.
Defaults to NULL, i.e. no incompleteness structure.
Can only be set when <code>warping = "nonparametric"</code>.</p>
</td></tr>
<tr><td><code id="registr_oneCurve_+3A_lambda_inc">lambda_inc</code></td>
<td>
<p>Penalization parameter to control the amount of
overall dilation of the domain.
The higher this lambda, the more the registered domains are forced to have the
same length as the observed domains.
Only used if <code>incompleteness</code> is not NULL.</p>
</td></tr>
<tr><td><code id="registr_oneCurve_+3A_beta">beta</code></td>
<td>
<p>Current estimates for beta for each subject. Default is NULL.</p>
</td></tr>
<tr><td><code id="registr_oneCurve_+3A_t_min">t_min</code></td>
<td>
<p>Minimum value to be evaluated on the time domain.
if 'NULL', taken to be minimum observed value.</p>
</td></tr>
<tr><td><code id="registr_oneCurve_+3A_t_max">t_max</code></td>
<td>
<p>Maximum value to be evaluated on the time domain. 
if 'NULL', taken to be maximum observed value.</p>
</td></tr>
<tr><td><code id="registr_oneCurve_+3A_periodic">periodic</code></td>
<td>
<p>If <code>TRUE</code>, uses periodic b-spline basis functions. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="registr_oneCurve_+3A_warping">warping</code></td>
<td>
<p>If <code>nonparametric</code> (default), inverse warping functions are estimated nonparametrically. 
If <code>piecewise_linear2</code> they follow a piecewise linear function with 2 knots.</p>
</td></tr>
<tr><td><code id="registr_oneCurve_+3A_gamma_scales">gamma_scales</code></td>
<td>
<p>Only used for <code>family = "gamma"</code>.
Vector with one entry for each subject, containing the current estimate for the scale parameter of its
gamma distribution. Default is NULL, which sets the starting value for the scale parameter to 1.5.</p>
</td></tr>
<tr><td><code id="registr_oneCurve_+3A_global_knots">global_knots</code></td>
<td>
<p>knots for the basis/splines, passed to [pbs::pbs()] 
or [stats::bs()]</p>
</td></tr>
<tr><td><code id="registr_oneCurve_+3A_mean_coefs">mean_coefs</code></td>
<td>
<p>Mean coefficients for the mean of all curves or 
GFPCA based.  May extract from 'obj' object</p>
</td></tr>
<tr><td><code id="registr_oneCurve_+3A_...">...</code></td>
<td>
<p>additional arguments passed to or from other functions</p>
</td></tr>
<tr><td><code id="registr_oneCurve_+3A_verbose">verbose</code></td>
<td>
<p>Can be set to integers between 0 and 4 to control the level of
detail of the printed diagnostic messages. Higher numbers lead to more detailed
messages. Defaults to 1.</p>
</td></tr>
<tr><td><code id="registr_oneCurve_+3A_just_return_list">just_return_list</code></td>
<td>
<p>Do not use.  For developers only</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An list containing:
</p>
<table>
<tr><td><code>hinv_innerKnots</code></td>
<td>
<p>Inner knots for setting up the spline basis
for the inverse warping function.</p>
</td></tr>
<tr><td><code>hinv_beta</code></td>
<td>
<p>Estimated B-spline basis coefficients used to construct
subject-specific inverse warping functions.</p>
</td></tr>
<tr><td><code>t_hat</code></td>
<td>
<p>Vector of registered time domain.</p>
</td></tr>
<tr><td><code>loss</code></td>
<td>
<p>Loss of the optimal solution.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Julia Wrobel <a href="mailto:julia.wrobel@cuanschutz.edu">julia.wrobel@cuanschutz.edu</a>,
Erin McDonnell <a href="mailto:eim2117@cumc.columbia.edu">eim2117@cumc.columbia.edu</a>,
Alexander Bauer <a href="mailto:alexander.bauer@stat.uni-muenchen.de">alexander.bauer@stat.uni-muenchen.de</a>
</p>

<hr>
<h2 id='simulate_functional_data'>Simulate functional data</h2><span id='topic+simulate_functional_data'></span>

<h3>Description</h3>

<p>This function simulates functional data. The data it outputs is generated from a mean function
and two orthogonal principal component basis functions. The mean and principal components are 
based on sine and cosine functions. Subject-specific scores for each PC are drawn from normal 
distributions with standard deviation lambda1 and lambda2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_functional_data(
  lambda1 = 2,
  lambda2 = 1,
  I = 50,
  D = 100,
  seed = 1988,
  vary_D = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_functional_data_+3A_lambda1">lambda1</code></td>
<td>
<p>Standard deviation for PC1 scores.</p>
</td></tr>
<tr><td><code id="simulate_functional_data_+3A_lambda2">lambda2</code></td>
<td>
<p>Standard deviation for PC2 scores.</p>
</td></tr>
<tr><td><code id="simulate_functional_data_+3A_i">I</code></td>
<td>
<p>Number of subjects. Defaults is 50.</p>
</td></tr>
<tr><td><code id="simulate_functional_data_+3A_d">D</code></td>
<td>
<p>Number of grid points per subject. Default is 100.</p>
</td></tr>
<tr><td><code id="simulate_functional_data_+3A_seed">seed</code></td>
<td>
<p>Seed for reproducibility. Default is 1988.</p>
</td></tr>
<tr><td><code id="simulate_functional_data_+3A_vary_d">vary_D</code></td>
<td>
<p>Indicates if grid length vary by subject. If FALSE all subjects have grid length D.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>Y</code></td>
<td>
<p>Simulated dataframe with variables id, value, index, and latent_mean.</p>
</td></tr>
<tr><td><code>psi1</code></td>
<td>
<p>True values for first principal component.</p>
</td></tr>
<tr><td><code>psi2</code></td>
<td>
<p>True values for second principal component.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>True values for population-level mean.</p>
</td></tr>
</table>
<p>A list containing:
</p>
<table>
<tr><td><code>Y</code></td>
<td>
<p>A dataframe of simulated data.</p>
</td></tr>
<tr><td><code>psi1</code></td>
<td>
<p>The first simulated eigenfunction.</p>
</td></tr>
<tr><td><code>psi2</code></td>
<td>
<p>The second simulated eigenfunction.</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>The population mean.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Julia Wrobel <a href="mailto:julia.wrobel@cuanschutz.edu">julia.wrobel@cuanschutz.edu</a>
</p>

<hr>
<h2 id='simulate_unregistered_curves'>Simulate unregistered curves</h2><span id='topic+simulate_unregistered_curves'></span>

<h3>Description</h3>

<p>This function simulates unregistered curves, providing the time values for both 
the unregistered curves (t_star) and the registered curves (t). Curves all have one peak, the location
of which is shifted on the unregistered domain, meant to mimic accelerometer data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_unregistered_curves(
  I = 50,
  D = 100,
  lambda = 15,
  seed = 1988,
  period = 2 * pi,
  spline_based = FALSE,
  phase_variation = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_unregistered_curves_+3A_i">I</code></td>
<td>
<p>Number of subjects. Defaults is 50.</p>
</td></tr>
<tr><td><code id="simulate_unregistered_curves_+3A_d">D</code></td>
<td>
<p>Number of grid points per subject. Default is 100.</p>
</td></tr>
<tr><td><code id="simulate_unregistered_curves_+3A_lambda">lambda</code></td>
<td>
<p>Standard deviation for subject-specific amplitudes.</p>
</td></tr>
<tr><td><code id="simulate_unregistered_curves_+3A_seed">seed</code></td>
<td>
<p>Seed for reproducibility. Default is 1988.</p>
</td></tr>
<tr><td><code id="simulate_unregistered_curves_+3A_period">period</code></td>
<td>
<p>Controls the period of the mean curve</p>
</td></tr>
<tr><td><code id="simulate_unregistered_curves_+3A_spline_based">spline_based</code></td>
<td>
<p>If FALSE curve is constructed using sine and cosine functions,
if TRUE, curve is constructed using B-spline basis.</p>
</td></tr>
<tr><td><code id="simulate_unregistered_curves_+3A_phase_variation">phase_variation</code></td>
<td>
<p>If TRUE, creates phase variation 
(registered curves are observed on uneven grid). If FALSE, no phase variation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A simulated dataframe with variables id, value, index, latent_mean, and t. Index is the domain
on which curves are unregistered and t is the domain on which curves are registered.
</p>


<h3>Author(s)</h3>

<p>Julia Wrobel <a href="mailto:julia.wrobel@cuanschutz.edu">julia.wrobel@cuanschutz.edu</a>,
Jeff Goldsmith <a href="mailto:ajg2202@cumc.columbia.edu">ajg2202@cumc.columbia.edu</a>
</p>

<hr>
<h2 id='squareTheta'>Calculate quadratic form of spline basis functions for the current subject.</h2><span id='topic+squareTheta'></span>

<h3>Description</h3>

<p>Calculations quadratic form of theta with diagonalized variational parameter in the center.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>squareTheta(xi, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="squareTheta_+3A_xi">xi</code></td>
<td>
<p>vector of variational parameters for the current subject.</p>
</td></tr>
<tr><td><code id="squareTheta_+3A_theta">theta</code></td>
<td>
<p>spline basis functions for the current subject.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of the quadratic form of theta for the current subject.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
