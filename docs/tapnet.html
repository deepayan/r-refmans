<!DOCTYPE html><html><head><title>Help for package tapnet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tapnet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#fit_tapnet'><p>Fit the tapnet model to a network</p></a></li>
<li><a href='#gof_tapnet'><p>Goodness-of-fit of a tapnet fit</p></a></li>
<li><a href='#internalFunctions'><p>Helper functions for tapnet</p></a></li>
<li><a href='#make_tapnet'><p>Constructs an object of type &quot;tapnet&quot;</p></a></li>
<li><a href='#predict_tapnet'><p>Predict from fitted tapnet to new data</p></a></li>
<li><a href='#simnetfromtap'><p>Simulates a network from parameters, abundances, traits and phylogeny provided</p></a></li>
<li><a href='#simulate_tapnet'><p>Creates a simulated along with all parameters, abundances, traits and phylogeny used</p></a></li>
<li><a href='#tapnet-package'><p>tapnet: A package for fitting, and predicting from, bipartite interaction networks.</p></a></li>
<li><a href='#tapnet2df'><p>Convert tapnet object into data.frame</p></a></li>
<li><a href='#Tinoco'><p>Hummingbird-flower networks</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Trait Matching and Abundance for Predicting Bipartite Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to produce, fit and predict from bipartite networks with abundance, trait and phylogenetic information. Its methods are described in detail in Benadi, G., Dormann, C.F., Fruend, J., Stephan, R. &amp; Vazquez, D.P. (2021) Quantitative prediction of interactions in bipartite networks based on traits, abundances, and phylogeny. The American Naturalist, in press.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ape, bipartite, MPSEM, phytools, stats, utils, vegan</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/biometry/tapnet">https://github.com/biometry/tapnet</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, utils</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-01-23 15:47:46 UTC; Carsten</td>
</tr>
<tr>
<td>Author:</td>
<td>Carsten Dormann [aut, cre],
  Gita Benadi [aut],
  Boris Tinoco [dtc],
  Ruth Stephan [ctb],
  Jochen Fruend [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Carsten Dormann &lt;carsten.dormann@biom.uni-freiburg.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-01-28 11:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='fit_tapnet'>Fit the tapnet model to a network</h2><span id='topic+fit_tapnet'></span>

<h3>Description</h3>

<p>Estimates the parameters of the tapnet model by log-likelihood based on the oberved network(s)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_tapnet(
  tapnet,
  ini = NULL,
  tmatch_type_pem = "normal",
  tmatch_type_obs = "normal",
  lambda = 0,
  method = "Nelder",
  maxit = 50000,
  hessian = FALSE,
  obj_function = "multinom",
  fit.delta = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_tapnet_+3A_tapnet">tapnet</code></td>
<td>
<p>a tapnet object;</p>
</td></tr>
<tr><td><code id="fit_tapnet_+3A_ini">ini</code></td>
<td>
<p>initial parameter values for the optimization; optional;</p>
</td></tr>
<tr><td><code id="fit_tapnet_+3A_tmatch_type_pem">tmatch_type_pem</code></td>
<td>
<p>type of trait matching function for latent traits, currently &quot;normal&quot; or &quot;shiftlnorm&quot;;</p>
</td></tr>
<tr><td><code id="fit_tapnet_+3A_tmatch_type_obs">tmatch_type_obs</code></td>
<td>
<p>type of trait matching function for observed traits, currently &quot;normal&quot; or &quot;shiftlnorm&quot;;</p>
</td></tr>
<tr><td><code id="fit_tapnet_+3A_lambda">lambda</code></td>
<td>
<p>LASSO shrinkage factor for latent trait parameters;</p>
</td></tr>
<tr><td><code id="fit_tapnet_+3A_method">method</code></td>
<td>
<p>Optimization method (most derivative-based approaches will not work! SANN is a (slow) alternative to the default);</p>
</td></tr>
<tr><td><code id="fit_tapnet_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of steps for optimization;</p>
</td></tr>
<tr><td><code id="fit_tapnet_+3A_hessian">hessian</code></td>
<td>
<p>logical: output hessian for calculation of standard errors?</p>
</td></tr>
<tr><td><code id="fit_tapnet_+3A_obj_function">obj_function</code></td>
<td>
<p>Objective function for the optimization, either &quot;multinom&quot; or &quot;sq_diff&quot;;</p>
</td></tr>
<tr><td><code id="fit_tapnet_+3A_fit.delta">fit.delta</code></td>
<td>
<p>logical; should the parameter delta be fitted? It allows tapnet to down-weigh the importance of trait matching relative to abundances.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The core function for using the tapnet approach: it fits the model to the data (= networks). Then, the estimated parameters can be used to predict to other networks (using <code><a href="#topic+predict_tapnet">predict_tapnet</a></code>).
</p>


<h3>Value</h3>

<p>A tapnet-fit object, containing the tapnet model parameters as entries &quot;par_opt&quot;, the settings of the tmatch_type for PEMs and observed traits, the parameter set for lambda, the optimisation method set, along with its maxit-value, and, finally, the output of the call to <code>optim</code>, including the target value (the negative log-likelihood), the convergence report and the parameters as fitted <em>at the transformed scale</em>. Note that the entries under &quot;opt&quot; will not be the same as those under &quot;par_opt&quot;!
</p>


<h3>Author(s)</h3>

<p>Gita Benadi &lt;gita.benadi@biom.uni-freiburg.de&gt; and Carsten Dormann &lt;carsten.dormann@biom.uni-freiburg.de&gt;
</p>


<h3>References</h3>

<p>Benadi et al. in prep
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # takes about 35 s
 data(Tinoco)
 tap &lt;- make_tapnet(tree_low = plant_tree, tree_high = humm_tree, networks = networks[2:3], 
        traits_low = plant_traits, traits_high = humm_traits, npems_lat = 4)
 fit &lt;- fit_tapnet(tap) # fits to networks 2 and 3 only
 str(fit)
  

</code></pre>

<hr>
<h2 id='gof_tapnet'>Goodness-of-fit of a tapnet fit</h2><span id='topic+gof_tapnet'></span>

<h3>Description</h3>

<p>Provides various measures to describe how well the tapnet model fits the data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gof_tapnet(
  fit,
  tapnet = NULL,
  indices = c("connectance", "NODF", "weighted NODF", "H2"),
  nrep = 1000,
  se_refit = FALSE,
  se_nsim = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gof_tapnet_+3A_fit">fit</code></td>
<td>
<p>results of applying fit_tapnet to the tapnet object;</p>
</td></tr>
<tr><td><code id="gof_tapnet_+3A_tapnet">tapnet</code></td>
<td>
<p>a tapnet object created with simulate_tapnet or make_tapnet; if NULL, the name stored in the attributes of fit is used to access an object of that name in the global environment; can be used e.g. in simulations, when the tapnet object is renamed relative to the one fitted;</p>
</td></tr>
<tr><td><code id="gof_tapnet_+3A_indices">indices</code></td>
<td>
<p>network indices to compare between observed and fitted network; calls <code><a href="bipartite.html#topic+networklevel">networklevel</a></code>;</p>
</td></tr>
<tr><td><code id="gof_tapnet_+3A_nrep">nrep</code></td>
<td>
<p>Number of networks to simulate for indices comparison; these are draws from the fitted multinomial distribution;</p>
</td></tr>
<tr><td><code id="gof_tapnet_+3A_se_refit">se_refit</code></td>
<td>
<p>logical; should standard errors for the parameters be calculated using parametric bootstrap (refitting on simulated data)? Defaults to FALSE because it's very slow (i.e. takes hours).</p>
</td></tr>
<tr><td><code id="gof_tapnet_+3A_se_nsim">se_nsim</code></td>
<td>
<p>number of simulations for parametric bootstrap (ignored unless the previous argument is set to TRUE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a function particularly interesting for simulated data, when the true parameters are known. In this case, GOF for fitted latent traits and so forth are computed.
</p>


<h3>Value</h3>

<p>A list of goodness-of-fit measures: bc_sim_web are the Bray-Curtis similarities between fitted and observed network; cor_web are Spearman correlations between fitted and observed; and net_indices compute the selected network indices for fitted and observed networks. If more than one network is used for fitting, all these measures are returned for all networks (as vector or list under the respective label). See example.
</p>


<h3>Author(s)</h3>

<p>Gita Benadi &lt;gita.benadi@biom.uni-freiburg.de&gt; and Carsten Dormann &lt;carsten.dormann@biom.uni-freiburg.de&gt;
</p>


<h3>References</h3>

<p>Benadi et al. in prep
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data(Tinoco)
  tap &lt;- make_tapnet(tree_low = plant_tree, tree_high = humm_tree, networks = networks[2:3], 
         traits_low = plant_traits, traits_high = humm_traits, npems_lat = 4)
  fit &lt;- fit_tapnet(tap) # uses networks 2 and 3 for fitting!
  gof_tapnet(fit)


</code></pre>

<hr>
<h2 id='internalFunctions'>Helper functions for tapnet</h2><span id='topic+internalFunctions'></span><span id='topic+helper'></span><span id='topic+functions'></span><span id='topic+pems_from_tree'></span><span id='topic+select_relevant_pems'></span><span id='topic+tmatch'></span><span id='topic+param_vec2list'></span><span id='topic+loglik_tapnet'></span><span id='topic+latent_cor'></span><span id='topic+web_indices'></span><span id='topic+refit_params'></span>

<h3>Description</h3>

<p>Lower-level, non-exported functions to be called by the main tapnet functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>internalFunctions()

pems_from_tree(tree)

select_relevant_pems(tree, species)

tmatch(delta_t, type = "normal", width = 1, shift = 0, err = 1e-05)

param_vec2list(params, n, m, fit.delta = FALSE)

loglik_tapnet(
  params,
  networks,
  tmatch_type_pem,
  tmatch_type_obs,
  lambda = 0,
  obj_function = "multinom",
  fit.delta = TRUE
)

latent_cor(true_pars, fitted_pars, pems_low, pems_high)

web_indices(web, web_dim, indices)

refit_params(tapnet, fit, fitted_I_mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="internalFunctions_+3A_tree">tree</code></td>
<td>
<p>phylogenetic tree in phylo format;</p>
</td></tr>
<tr><td><code id="internalFunctions_+3A_species">species</code></td>
<td>
<p>a named vector of species, representing (some of) the tips of the phylogenetic tree;</p>
</td></tr>
<tr><td><code id="internalFunctions_+3A_delta_t">delta_t</code></td>
<td>
<p>vector of pairwise trait differences (higher - lower);</p>
</td></tr>
<tr><td><code id="internalFunctions_+3A_type">type</code></td>
<td>
<p>trait matching function: either &quot;normal&quot; or &quot;shiftlnorm&quot;;</p>
</td></tr>
<tr><td><code id="internalFunctions_+3A_width">width</code></td>
<td>
<p>width parameter of trait matching function, similar to sd in the normal;</p>
</td></tr>
<tr><td><code id="internalFunctions_+3A_shift">shift</code></td>
<td>
<p>shift parameter (optimum trait distance), currently ignored in fitting;</p>
</td></tr>
<tr><td><code id="internalFunctions_+3A_err">err</code></td>
<td>
<p>&quot;baseline&quot; probability of match, even if traits do not match at all;</p>
</td></tr>
<tr><td><code id="internalFunctions_+3A_params">params</code></td>
<td>
<p>parameter vector with setting for tapnet simulation;</p>
</td></tr>
<tr><td><code id="internalFunctions_+3A_n">n</code></td>
<td>
<p>number of latent trait linear combination parameters (lower level);</p>
</td></tr>
<tr><td><code id="internalFunctions_+3A_m">m</code></td>
<td>
<p>number of latent trait linear combination parameters (higher level);</p>
</td></tr>
<tr><td><code id="internalFunctions_+3A_fit.delta">fit.delta</code></td>
<td>
<p>logical; should the trait-weighting exponent delta be fitted?</p>
</td></tr>
<tr><td><code id="internalFunctions_+3A_networks">networks</code></td>
<td>
<p>the &quot;networks&quot; part of a tapnet object;</p>
</td></tr>
<tr><td><code id="internalFunctions_+3A_tmatch_type_pem">tmatch_type_pem</code></td>
<td>
<p>type of trait matching function for latent traits;</p>
</td></tr>
<tr><td><code id="internalFunctions_+3A_tmatch_type_obs">tmatch_type_obs</code></td>
<td>
<p>type(s) of trait matching functions for observed traits; can be a vector as long as there are traits;</p>
</td></tr>
<tr><td><code id="internalFunctions_+3A_lambda">lambda</code></td>
<td>
<p>LASSO shrinkage parameter to avoid collinearity issues when observed traits are phylogenetically correlated;</p>
</td></tr>
<tr><td><code id="internalFunctions_+3A_obj_function">obj_function</code></td>
<td>
<p>objective function, either &quot;multinom&quot; or anything else (currently anything else leads to OLS fitting);</p>
</td></tr>
<tr><td><code id="internalFunctions_+3A_true_pars">true_pars</code></td>
<td>
<p>parameters used for simulating the network;</p>
</td></tr>
<tr><td><code id="internalFunctions_+3A_fitted_pars">fitted_pars</code></td>
<td>
<p>parameters estimated by <code><a href="#topic+fit_tapnet">fit_tapnet</a></code>;</p>
</td></tr>
<tr><td><code id="internalFunctions_+3A_pems_low">pems_low</code></td>
<td>
<p>phylogenetic eigenvectors for the lower trophic level;</p>
</td></tr>
<tr><td><code id="internalFunctions_+3A_pems_high">pems_high</code></td>
<td>
<p>phylogenetic eigenvectors for the higher trophic level;</p>
</td></tr>
<tr><td><code id="internalFunctions_+3A_web">web</code></td>
<td>
<p>data for an interaction network in vector form, e.g. from predict_tapnet;</p>
</td></tr>
<tr><td><code id="internalFunctions_+3A_web_dim">web_dim</code></td>
<td>
<p>vector of two numbers indicating the rows and column of the network matrix;</p>
</td></tr>
<tr><td><code id="internalFunctions_+3A_indices">indices</code></td>
<td>
<p>vector of names of network indices to compute; see <code><a href="bipartite.html#topic+networklevel">networklevel</a></code> for what is available;</p>
</td></tr>
<tr><td><code id="internalFunctions_+3A_tapnet">tapnet</code></td>
<td>
<p>a tapnet object;</p>
</td></tr>
<tr><td><code id="internalFunctions_+3A_fit">fit</code></td>
<td>
<p>a fitted tapnet;</p>
</td></tr>
<tr><td><code id="internalFunctions_+3A_fitted_i_mat">fitted_I_mat</code></td>
<td>
<p>the fitted I-matrix of a fitted tapnet object (I think).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>They do roughly the following: 
</p>

<dl>
<dt><code>pems_from_tree</code></dt><dd><p>computes phylogenetic eigenvectors from a phylogenetic tree;</p>
</dd>
<dt><code>select_relevant_pems</code></dt><dd><p>identifies those phylogenetic eigenvectors (PEMs) of the full tree most relevant for a network containing only a subset of species;</p>
</dd>
<dt><code>tmatch</code></dt><dd><p>calculates interaction probabilities based on trait matching;</p>
</dd>
<dt><code>param_vec2list</code></dt><dd><p>converts a vector of parameters (for trait matching and latent trait combinations) into a named list;</p>
</dd>
<dt><code>loglik_tapnet</code></dt><dd><p>the log-likelihood function for fitting the tapnet model; actually quite an important function, easy to break, so not for the user to easily access;</p>
</dd>
<dt><code>latent_cor</code></dt><dd><p>computes correlation of fitted latent with true constructed traits for simulated data;</p>
</dd>
<dt><code>web_indices</code></dt><dd><p>computes the specified network indices for the provided network, after turning the prediction vector into a matrix;</p>
</dd>
<dt><code>refit_params</code></dt><dd><p>Simulate new networks from a fitted tapnet object, re-fit on the simulated network and output the parameter values.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Gita Benadi &lt;gita.benadi@biom.uni-freiburg.de&gt;, Carsten Dormann &lt;carsten.dormann@biom.uni-freiburg.de&gt; and Jochen Fründ &lt;jochen.fruend@biom.uni-freiburg.de&gt;
</p>


<h3>References</h3>

<p>Benadi et al. in prep
</p>

<hr>
<h2 id='make_tapnet'>Constructs an object of type &quot;tapnet&quot;</h2><span id='topic+make_tapnet'></span>

<h3>Description</h3>

<p>Collates networks, traits and phylogenies into a consistent data structure used for all other tapnet functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_tapnet(
  tree_low,
  tree_high,
  networks,
  abun_low = NULL,
  abun_high = NULL,
  traits_low = NULL,
  traits_high = NULL,
  npems_lat = NULL,
  use.all.pems = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_tapnet_+3A_tree_low">tree_low</code></td>
<td>
<p>phylogenetic tree of lower trophic level; required;</p>
</td></tr>
<tr><td><code id="make_tapnet_+3A_tree_high">tree_high</code></td>
<td>
<p>phylogenetic tree of higher trophic level; required;</p>
</td></tr>
<tr><td><code id="make_tapnet_+3A_networks">networks</code></td>
<td>
<p>a single or list of interaction network (as matrix); required;</p>
</td></tr>
<tr><td><code id="make_tapnet_+3A_abun_low">abun_low</code></td>
<td>
<p>named abundance vector(s) for lower trophic level (single vector or list of vectors); optional;</p>
</td></tr>
<tr><td><code id="make_tapnet_+3A_abun_high">abun_high</code></td>
<td>
<p>named abundance vector(s) for higher trophic level; optional;</p>
</td></tr>
<tr><td><code id="make_tapnet_+3A_traits_low">traits_low</code></td>
<td>
<p>lower trophic level traits (species x traits matrix with row and column names); optional;</p>
</td></tr>
<tr><td><code id="make_tapnet_+3A_traits_high">traits_high</code></td>
<td>
<p>higher trophic level traits (species x traits matrix with row and column names; optional;</p>
</td></tr>
<tr><td><code id="make_tapnet_+3A_npems_lat">npems_lat</code></td>
<td>
<p>number of phylogenetic eigenvectors to be used to construct latent traits. If NULL, all eigenvectors will be used.</p>
</td></tr>
<tr><td><code id="make_tapnet_+3A_use.all.pems">use.all.pems</code></td>
<td>
<p>option to force the function to use all phylogenetic eigenvectors, not only those useful for describing the specific network's species.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tapnet objects are the starting point for almost all other tapnet functions. They contain the information on the species and the (quantitative) interaction network data.
</p>


<h3>Value</h3>

<p>A tapnet object, i.e. an thoroughly organised list with the inputs as entries. If multiple networks are provided, each has its own list entry, with PEMs, traits and abundances given for each network separately, in addition to the overall phylogenetic eigenvectors across all networks. See example for, well, for an example.
</p>


<h3>Author(s)</h3>

<p>Gita Benadi &lt;gita.benadi@biom.uni-freiburg.de&gt;
</p>


<h3>References</h3>

<p>Benadi et al. in prep
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Tinoco)
tapnet_web1 &lt;- make_tapnet(tree_low = plant_tree, tree_high = humm_tree, networks = networks[1], 
               traits_low = plant_traits, traits_high = humm_traits, npems_lat = 4)
str(tapnet_web1) # show tapnet structure

</code></pre>

<hr>
<h2 id='predict_tapnet'>Predict from fitted tapnet to new data</h2><span id='topic+predict_tapnet'></span>

<h3>Description</h3>

<p>Function allows direct use of data prepared for tapnet analysis by other statistical methods, e.g. regression approaches
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_tapnet(fit, abuns, tapnet = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_tapnet_+3A_fit">fit</code></td>
<td>
<p>results of applying fit_tapnet to the tapnet object;</p>
</td></tr>
<tr><td><code id="predict_tapnet_+3A_abuns">abuns</code></td>
<td>
<p>named list of two entries (&quot;low&quot; and &quot;high&quot;), containing a species-named vector of abundances of the new network</p>
</td></tr>
<tr><td><code id="predict_tapnet_+3A_tapnet">tapnet</code></td>
<td>
<p>optional name of a tapnet object containing traits, phylogeny etc.; these are not stored in <span class="option">fit</span>, but rather it is assumed that a tapnet object with the name stored in <span class="option">fit</span> is available in the global environment. That may not be the case, e.g. when simulating networks. In this case, <span class="option">tapnet</span> provides the required tapnet-object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fitted tapnet object contains the estimated parameters, describing how traits, abundance and phylogeny play together to produce the network(s) used for fitting. This information is now used to predict interaction probabilities for a new network. Accordingly, we need to know this new network's species abundances (an input to the function), PEMs and traits. The latter are computed based on the information contained in the tapnet object (which is linked in by attribute reference). For new species, their PEMs are computed and the network is simulated, using <code><a href="#topic+simnetfromtap">simnetfromtap</a></code>, for the information provided.
</p>


<h3>Value</h3>

<p>A matrix of predicted interaction probabilities, summing to 1. This would need to be multiplied by the total number of interactions in the new network to be comparable to the observations.
</p>


<h3>Author(s)</h3>

<p>Ruth Stephan, Gita Benadi and Carsten Dormann &lt;carsten.dormann@biom.uni-freiburg.de&gt;
</p>


<h3>References</h3>

<p>Benadi et al. in prep
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  data(Tinoco)
  tap &lt;- make_tapnet(tree_low = plant_tree, tree_high = humm_tree, networks = networks[1:2], 
         traits_low = plant_traits, traits_high = humm_traits, npems_lat = 4)
  fit &lt;- fit_tapnet(tap) # uses two networks for fitting!
  gof_tapnet(fit)
  # predict to omitted forest network's abundances:
  pred1 &lt;- predict_tapnet(fit, abuns=list("low"=plant_abun[[3]], "high"=humm_abun[[3]] )) 
  cor(as.vector(pred1*sum(networks[[3]])), as.vector(networks[[3]])) 


</code></pre>

<hr>
<h2 id='simnetfromtap'>Simulates a network from parameters, abundances, traits and phylogeny provided</h2><span id='topic+simnetfromtap'></span>

<h3>Description</h3>

<p>The workhorse function of this package, called by various other functions to construct a bipartite interaction network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simnetfromtap(
  traits,
  abuns,
  paramsList,
  pems,
  tmatch_type_pem,
  tmatch_type_obs
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simnetfromtap_+3A_traits">traits</code></td>
<td>
<p>a named (&quot;low&quot;/&quot;high&quot;) list of species-named trait data matrices for lower and higher trophic level;</p>
</td></tr>
<tr><td><code id="simnetfromtap_+3A_abuns">abuns</code></td>
<td>
<p>a named (&quot;low&quot;/&quot;high&quot;) list of species-named abundance vectors for lower and higher trophic level;</p>
</td></tr>
<tr><td><code id="simnetfromtap_+3A_paramslist">paramsList</code></td>
<td>
<p>a list of parameter values with six elements: [[1]] and [[2]]: two vectors of linear combination parameters (importance values, one vector for each trophic level); [[3]]: a single shift parameter added to linear combination of higher trophic level PEMs; [[4]]: a single trait matching parameter for the PEMs; [[5]]: a vector of trait matching parameters for observed traits; [[6]]: a non-negative scalar delta to weight the importance of abundances</p>
</td></tr>
<tr><td><code id="simnetfromtap_+3A_pems">pems</code></td>
<td>
<p>a named (&quot;low&quot;/&quot;high&quot;) list of two species-named data frames (PEMs of lower and higher trophic level);</p>
</td></tr>
<tr><td><code id="simnetfromtap_+3A_tmatch_type_pem">tmatch_type_pem</code></td>
<td>
<p>type of trait matching function for latent traits (any name accepted by <code><a href="#topic+tmatch">tmatch</a></code>, currently &quot;normal&quot; and &quot;shiftlnorm&quot;);</p>
</td></tr>
<tr><td><code id="simnetfromtap_+3A_tmatch_type_obs">tmatch_type_obs</code></td>
<td>
<p>type of trait matching function for observed traits (see previous argument).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Details in here!
</p>


<h3>Value</h3>

<p>A named interaction matrix.
</p>


<h3>Author(s)</h3>

<p>Gita Benadi &lt;gita.benadi@biom.uni-freiburg.de&gt; and Carsten Dormann &lt;carsten.dormann@biom.uni-freiburg.de&gt;
</p>


<h3>References</h3>

<p>Benadi et al. in prep
</p>

<hr>
<h2 id='simulate_tapnet'>Creates a simulated along with all parameters, abundances, traits and phylogeny used</h2><span id='topic+simulate_tapnet'></span>

<h3>Description</h3>

<p>Simulation function to produce a tapnet object, i.e. one or more networks along with their descriptors, abundances, traits, phylogenetic information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_tapnet(
  nlower,
  nhigher,
  ntraits_nopem,
  ntraits_pem,
  pem_noise = 0.5,
  abuns = "lognormal",
  meanlog = 0,
  sdlog = 1,
  tmatch_type_pem = "normal",
  tmatch_type_obs = "normal",
  npems_lat = NULL,
  lat_low = 1,
  lat_high = 1,
  tmatch_width_pem = 1,
  pem_shift = 0,
  tmatch_width_obs = 1,
  Nwebs = 1,
  prop_species = 1,
  new_abuns = FALSE,
  Nobs = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_tapnet_+3A_nlower">nlower</code></td>
<td>
<p>species number in lower trophic level;</p>
</td></tr>
<tr><td><code id="simulate_tapnet_+3A_nhigher">nhigher</code></td>
<td>
<p>species number in higher trophic level;</p>
</td></tr>
<tr><td><code id="simulate_tapnet_+3A_ntraits_nopem">ntraits_nopem</code></td>
<td>
<p>number of phylogenetically uncorrelated traits (for each level);</p>
</td></tr>
<tr><td><code id="simulate_tapnet_+3A_ntraits_pem">ntraits_pem</code></td>
<td>
<p>number of phylogenetically correlated traits (for each level);</p>
</td></tr>
<tr><td><code id="simulate_tapnet_+3A_pem_noise">pem_noise</code></td>
<td>
<p>noise (sd of normal dist) to put on PEMs;</p>
</td></tr>
<tr><td><code id="simulate_tapnet_+3A_abuns">abuns</code></td>
<td>
<p>abundances set to &quot;lognormal&quot;, &quot;equal&quot; or a list of two abundance vectors;</p>
</td></tr>
<tr><td><code id="simulate_tapnet_+3A_meanlog">meanlog</code></td>
<td>
<p>parameters of the log-normal distribution for drawing abundances;</p>
</td></tr>
<tr><td><code id="simulate_tapnet_+3A_sdlog">sdlog</code></td>
<td>
<p>same as before, but width;</p>
</td></tr>
<tr><td><code id="simulate_tapnet_+3A_tmatch_type_pem">tmatch_type_pem</code></td>
<td>
<p>type of trait matching function for latent traits;</p>
</td></tr>
<tr><td><code id="simulate_tapnet_+3A_tmatch_type_obs">tmatch_type_obs</code></td>
<td>
<p>type of trait matching function for observed traits (can be a vector as long as there are traits);</p>
</td></tr>
<tr><td><code id="simulate_tapnet_+3A_npems_lat">npems_lat</code></td>
<td>
<p>number of phylogenetic eigenvectors to be used to construct latent traits. If NULL, all eigenvectors will be used;</p>
</td></tr>
<tr><td><code id="simulate_tapnet_+3A_lat_low">lat_low</code></td>
<td>
<p>vector of PEM linear combination parameters for lower trophic level; if 1, all values will be set to 1, if &quot;random&quot;, values will be drawn from a uniform dist;</p>
</td></tr>
<tr><td><code id="simulate_tapnet_+3A_lat_high">lat_high</code></td>
<td>
<p>same for higher trophic level;</p>
</td></tr>
<tr><td><code id="simulate_tapnet_+3A_tmatch_width_pem">tmatch_width_pem</code></td>
<td>
<p>width of trait matching function for latent (PEM-based) traits;</p>
</td></tr>
<tr><td><code id="simulate_tapnet_+3A_pem_shift">pem_shift</code></td>
<td>
<p>shift parameter for latent trait matching;</p>
</td></tr>
<tr><td><code id="simulate_tapnet_+3A_tmatch_width_obs">tmatch_width_obs</code></td>
<td>
<p>width of trait matching function for observed traits, can be a single value or a vector of length ntraits_nopem + ntraits_pem;</p>
</td></tr>
<tr><td><code id="simulate_tapnet_+3A_nwebs">Nwebs</code></td>
<td>
<p>number of webs to be simulated;</p>
</td></tr>
<tr><td><code id="simulate_tapnet_+3A_prop_species">prop_species</code></td>
<td>
<p>proportion of species in the phylogeny that appear in each web (species are drawn randomly). With multiple networks, this allows to create networks with partly overlapping species composition.</p>
</td></tr>
<tr><td><code id="simulate_tapnet_+3A_new_abuns">new_abuns</code></td>
<td>
<p>If abuns = &quot;lognormal&quot; and Nwebs &gt; 1, should new abundances be drawn for each web?</p>
</td></tr>
<tr><td><code id="simulate_tapnet_+3A_nobs">Nobs</code></td>
<td>
<p>number of observed interactions per web</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function was written to explore the fitting of networks by different methods. Hence, we first have to simulate such networks. It is a very nice starting point for simulations, but irrelevant for tapnet-based analyses. The function internally sets up all the parameters and then calls <code><a href="#topic+simnetfromtap">simnetfromtap</a></code> for the simulation of the actual network. Lots of options means, regrettably, lots of decisions for the user.
</p>


<h3>Value</h3>

<p>A tapnet object, with a highly nested structure. There are six entries at the top level: trees, traits_all, networks, sim_params and the two tmatch types. Within networks, there is a list of 5 entries (for each of the <span class="option">Nweb</span> networks): abundances, traits, PEMs, web and I_mat. &quot;I_mat&quot; is the actual output from simnetfromtap, while &quot;web&quot; is a single draw from a multinomial distribution with I_mat as probabilities and <span class="option">Nobs</span> as size.
</p>


<h3>Author(s)</h3>

<p>Gita Benadi &lt;gita.benadi@biom.uni-freiburg.de&gt;, Jochen Fründ &lt;jochen.fruend@biom.uni-freiburg.de&gt; and Carsten Dormann &lt;carsten.dormann@biom.uni-freiburg.de&gt;
</p>


<h3>References</h3>

<p>Benadi et al. in prep
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tapnet &lt;- simulate_tapnet(nlower=10, nhigher=20, ntraits_nopem=2, ntraits_pem=0) 
# a minimal call of simulate_tapnet
str(tapnet, 1) # the structure at the first level
str(tapnet, 2) # the structure at the first and second level

</code></pre>

<hr>
<h2 id='tapnet-package'>tapnet: A package for fitting, and predicting from, bipartite interaction networks.</h2><span id='topic+tapnet-package'></span>

<h3>Description</h3>

<p>The package provides three categories of important functions:
making tapnet objects, fitting the tapnet, and predicting to new data. All other functions are helpers or quality monitoring. 
The idea of using abundances, observed traits and phylogeny-derived latent traits to quantitatively fit and predict interaction 
is detailed in Benadi et al. (2021). This package accompanies the paper.
</p>


<h3>Making a tapnet object</h3>

<p>To be filled with content ... For now, see example in predict_tapnet.
Alternatively to having actual observed data, one can simulate a tapnet object.
</p>


<h3>Fitting a tapnet</h3>

<p>To be filled with content.
</p>


<h3>Predicting from a tapnet</h3>

<p>To be filled with content.
</p>


<h3>News/versions</h3>


<dl>
<dt>0.3; 10-Jun-2019</dt><dd><p>Added option &quot;tapnet&quot; to predict_tapnet in order to be able to use it on simulations. Cleaned up the code according to devtools::check-report.</p>
</dd>
<dt>0.2; 19-Sep-2019</dt><dd><p>Tinoco-data updated to now also contain external abundances (thanks Boris for providing these!). Help file for these data updated accordingly. By now we have used tapnet on many simulations and some real data and are fairly confident that the functions work as they should. The real test comes when data are not carefully prepared, with corrupted names and in non-alphabetical order, networks have NAs and so forth. Hopefully we have coded properly for these cases, too.</p>
</dd>
<dt>0.1</dt><dd><p>Initial version with all functions complete and a data set for demonstration. Code written by Gita Benadi, Carsten Dormann and Jochen Fründ, data provided by Boris Tinoco.</p>
</dd>
</dl>



<h3>References</h3>

<p>Benadi, G., Dormann, C.F., Fründ, J., Stephan, R.\&amp; Vázquez, D.P. (2021) Quantitative prediction of interactions in bipartite networks based on traits, abundances, and phylogeny. <em>The American Naturalist</em>, in press.
</p>

<hr>
<h2 id='tapnet2df'>Convert tapnet object into data.frame</h2><span id='topic+tapnet2df'></span>

<h3>Description</h3>

<p>Function allows direct use of data prepared for tapnet analysis by other statistical methods, e.g. regression approaches
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tapnet2df(tapnetObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tapnet2df_+3A_tapnetobject">tapnetObject</code></td>
<td>
<p>results of applying fit_tapnet to the tapnet object;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simply puts all data into a data.frame, with each row an entry in the network matrix.
</p>


<h3>Value</h3>

<p>A data.frame containing network observations, PEMs, traits and abundances for regression-type analysis.
</p>


<h3>Author(s)</h3>

<p>Carsten Dormann &lt;carsten.dormann@biom.uni-freiburg.de&gt;
</p>


<h3>References</h3>

<p>Benadi et al. in prep
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ex &lt;- simulate_tapnet(nlower=10, nhigher=50, ntraits_pem=3, ntraits_nopem=2, Nwebs = 3)
df &lt;- tapnet2df(ex)
head(df)
## Not run: 
  library(ranger)
  frf &lt;- ranger(interactions ~ ., data=df[, -c(1:2)], importance="impurity")
  sort(importance(frf), decreasing=TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='Tinoco'>Hummingbird-flower networks</h2><span id='topic+Tinoco'></span><span id='topic+humm_traits'></span><span id='topic+humm_tree'></span><span id='topic+humm_abun'></span><span id='topic+networks'></span><span id='topic+plant_tree'></span><span id='topic+plant_traits'></span><span id='topic+plant_abun'></span>

<h3>Description</h3>

<p>An example dataset for tapnet analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Tinoco)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 14 rows and 1 columns.
</p>


<h3>Details</h3>

<p>These data are from the supplement of Tinoco et al. (2017) and contain three observed networks (forest at Mazan, shrubland at Llaviuco, cattle farm at Nero, all in Ecuador), along with traits of flowers and birds (corolla and beak length, respectively) as well as phylogenies and external abundances for all species. These data are in several ways special, but most of all because of the very high sampling effort that went into the networks.
</p>
<p>For sake of clarity, we provide the data as separate objects. So when &quot;Tinoco&quot; is called, it will load seven objects: networks, humm_traits, humm_tree, humm_abun, plant_traits, plant_tree and plant_abun. To combine them into a useable tapnet object, use <code><a href="#topic+make_tapnet">make_tapnet</a></code>. Phylogenetic trees are of class &quot;phylo&quot; (as used/produced by <span class="pkg">phytools</span>). Abundance data were provided independently of the other data directly by Boris (the other data are on dryad doi: <a href="https://doi.org/10.5061/dryad.j860v">10.5061/dryad.j860v</a>). For the external abundances of hummingbirds, 12 point counts were performed in the same habitats where hummingbird - plant interactions were observed. &quot;Abundance were obtained by averaging the abundance of each species per point count across the study period.&quot; &quot;Plant abundances are averages across the study period.&quot; Many thanks to Boris for making his data freely available!
</p>


<h3>Author(s)</h3>

<p>Boris A. Tinoco Molina <a href="mailto:btinoco@uazuay.edu.ec">btinoco@uazuay.edu.ec</a> collected the data; Carsten F. Dormann <a href="mailto:carsten.dormann@biom.uni-freiburg.de">carsten.dormann@biom.uni-freiburg.de</a> packaged them
</p>


<h3>References</h3>

<p>Tinoco, B. A.; Graham, C. H.; Aguilar, J. M. &amp; Schleuning, M. Effects of hummingbird morphology on specialization in pollination networks vary with resource availability. <em>Oikos</em> <b>126</b>, 52-–60
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ls()
data(Tinoco)
ls() # adds seven objects!

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
