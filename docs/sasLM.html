<!DOCTYPE html><html lang="en"><head><title>Help for package sasLM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sasLM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#sasLM-package'><p>'SAS' Linear Model</p></a></li>
<li><a href='#af'><p>Convert some columns of a data.frame to factors</p></a></li>
<li><a href='#aov1'><p>ANOVA with Type I SS</p></a></li>
<li><a href='#aov2'><p>ANOVA with Type II SS</p></a></li>
<li><a href='#aov3'><p>ANOVA with Type III SS</p></a></li>
<li><a href='#aspirinCHD'>
<p>An example data for meta-analysis - aspirin in coronary heart disease</p></a></li>
<li><a href='#BasicUtil'><p>Internal Functions</p></a></li>
<li><a href='#BEdata'>
<p>An Example Data of Bioequivalence Study</p></a></li>
<li><a href='#bk'><p>Beautify the output of knitr::kable</p></a></li>
<li><a href='#BY'><p>Analysis BY variable</p></a></li>
<li><a href='#CIest'><p>Confidence Interval Estimation</p></a></li>
<li><a href='#Coll'><p>Collinearity Diagnostics</p></a></li>
<li><a href='#CONTR'><p>F Test with a Set of Contrasts</p></a></li>
<li><a href='#Cor.test'><p>Correlation test of multiple numeric columns</p></a></li>
<li><a href='#corFisher'><p>Correlation test by Fisher's Z transformation</p></a></li>
<li><a href='#cSS'><p>Sum of Square with a Given Contrast Set</p></a></li>
<li><a href='#CumAlpha'><p>Cumulative Alpha for the Fixed Z-value</p></a></li>
<li><a href='#CV'><p>Coefficient of Variation in percentage</p></a></li>
<li><a href='#Diffogram'><p>Plot Pairwise Differences</p></a></li>
<li><a href='#DoEdata'>
<p>Example Datasets</p></a></li>
<li><a href='#Drift'><p>Drift defined by Lan and DeMets for Group Sequential Design</p></a></li>
<li><a href='#e1'><p>Get a Contrast Matrix for Type I SS</p></a></li>
<li><a href='#e2'><p>Get a Contrast Matrix for Type II SS</p></a></li>
<li><a href='#e3'><p>Get a Contrast Matrix for Type III SS</p></a></li>
<li><a href='#EMS'><p>Expected Mean Square Formula</p></a></li>
<li><a href='#est'><p>Estimate Linear Functions</p></a></li>
<li><a href='#ESTM'><p>Estimate Linear Function</p></a></li>
<li><a href='#estmb'><p>Estimability Check</p></a></li>
<li><a href='#ExitP'><p>Exit Probability with cumulative Z-test in Group Sequential Design</p></a></li>
<li><a href='#g2inv'><p>Generalized type 2 inverse matrix, g2 inverse</p></a></li>
<li><a href='#G2SWEEP'><p>Generalized inverse matrix of type 2 for linear regression</p></a></li>
<li><a href='#geoCV'><p>Geometric Coefficient of Variation in percentage</p></a></li>
<li><a href='#geoMean'><p>Geometric Mean without NA</p></a></li>
<li><a href='#GLM'><p>General Linear Model similar to SAS PROC GLM</p></a></li>
<li><a href='#is.cor'><p>Is it a correlation matrix?</p></a></li>
<li><a href='#Kurtosis'><p>Kurtosis</p></a></li>
<li><a href='#KurtosisSE'><p>Standard Error of Kurtosis</p></a></li>
<li><a href='#LCL'><p>Lower Confidence Limit</p></a></li>
<li><a href='#lfit'><p>Linear Fit</p></a></li>
<li><a href='#lr'><p>Linear Regression with g2 inverse</p></a></li>
<li><a href='#lr0'><p>Simple Linear Regressions with Each Independent Variable</p></a></li>
<li><a href='#LSM'><p>Least Square Means</p></a></li>
<li><a href='#Max'><p>Max without NA</p></a></li>
<li><a href='#Mean'><p>Mean without NA</p></a></li>
<li><a href='#Median'><p>Median without NA</p></a></li>
<li><a href='#Min'><p>Min without NA</p></a></li>
<li><a href='#ModelMatrix'><p>Model Matrix</p></a></li>
<li><a href='#mtest'><p>Independent two groups t-test similar to PROC TTEST with summarized input</p></a></li>
<li><a href='#N'><p>Number of observations</p></a></li>
<li><a href='#OR'><p>Odds Ratio of two groups</p></a></li>
<li><a href='#ORcmh'><p>Odds Ratio of two groups with strata by CMH method</p></a></li>
<li><a href='#ORinv'><p>Odds Ratio of two groups with strata by inverse variance method</p></a></li>
<li><a href='#ORmn'><p>Odds Ratio and Score CI of two groups with strata by MN method</p></a></li>
<li><a href='#ORmn1'><p>Odds Ratio and Score CI of two groups without strata by the MN method</p></a></li>
<li><a href='#pB'><p>Plot Confidence and Prediction Bands for Simple Linear Regression</p></a></li>
<li><a href='#Pcor.test'><p>Partial Correlation test of multiple columns</p></a></li>
<li><a href='#pD'><p>Diagnostic Plot for Regression</p></a></li>
<li><a href='#PDIFF'><p>Pairwise Difference</p></a></li>
<li><a href='#PocockBound'><p>Pocock (fixed) Bound for the cumulative Z-test with a final target alpha-value</p></a></li>
<li><a href='#pResD'><p>Residual Diagnostic Plot for Regression</p></a></li>
<li><a href='#QuartileRange'><p>Inter-Quartile Range</p></a></li>
<li><a href='#Range'><p>Range</p></a></li>
<li><a href='#RanTest'><p>Test with Random Effects</p></a></li>
<li><a href='#RD'><p>Risk Difference between two groups</p></a></li>
<li><a href='#RDinv'><p>Risk Difference between two groups with strata by inverse variance method</p></a></li>
<li><a href='#RDmn'><p>Risk Difference and Score CI between two groups with strata by the MN method</p></a></li>
<li><a href='#RDmn1'><p>Risk Difference and Score CI between two groups without strata by the MN method</p></a></li>
<li><a href='#REG'><p>Regression of Linear Least Square, similar to SAS PROC REG</p></a></li>
<li><a href='#regD'><p>Regression of Conventional Way with Rich Diagnostics</p></a></li>
<li><a href='#RR'><p>Relative Risk of the two groups</p></a></li>
<li><a href='#RRinv'><p>Relative Risk of two groups with strata by inverse variance method</p></a></li>
<li><a href='#RRmn'><p>Relative Risk and Score CI of two groups with strata by the MN method</p></a></li>
<li><a href='#RRmn1'><p>Relative Risk and Score CI of two groups without strata by by MN method</p></a></li>
<li><a href='#satt'><p>Satterthwaite Approximation of Variance and Degree of Freedom</p></a></li>
<li><a href='#ScoreCI'><p>Score Confidence Interval for a Proportion or a Binomial Distribution</p></a></li>
<li><a href='#SD'><p>Standard Deviation</p></a></li>
<li><a href='#SEM'><p>Standard Error of the Sample Mean</p></a></li>
<li><a href='#seqBound'><p>Sequential bounds for cumulative Z-test in Group Sequential Design</p></a></li>
<li><a href='#seqCI'><p>Confidence interval with the last Z-value for the group sequential design</p></a></li>
<li><a href='#Skewness'><p>Skewness</p></a></li>
<li><a href='#SkewnessSE'><p>Standard Error of Skewness</p></a></li>
<li><a href='#SLICE'><p>F Test with Slice</p></a></li>
<li><a href='#SS'><p>Sum of Square</p></a></li>
<li><a href='#T3MS'><p>Type III Expected Mean Square Formula</p></a></li>
<li><a href='#T3test'><p>Test Type III SS using error term other than MSE</p></a></li>
<li><a href='#tmtest'><p>Independent two means test similar to t.test with summarized input</p></a></li>
<li><a href='#trimmedMean'><p>Trimmed Mean</p></a></li>
<li><a href='#tsum'><p>Table Summary</p></a></li>
<li><a href='#tsum0'><p>Table Summary 0 independent(x) variable</p></a></li>
<li><a href='#tsum1'><p>Table Summary 1 independent(x) variable</p></a></li>
<li><a href='#tsum2'><p>Table Summary 2 independent(x) variables</p></a></li>
<li><a href='#tsum3'><p>Table Summary 3 independent(x) variables</p></a></li>
<li><a href='#TTEST'><p>Independent two groups t-test comparable to PROC TTEST</p></a></li>
<li><a href='#UCL'><p>Upper Confidence Limit</p></a></li>
<li><a href='#UNIV'><p>Univariate Descriptive Statistics</p></a></li>
<li><a href='#vtest'><p>F-Test for the ratio of two groups' variances</p></a></li>
<li><a href='#WhiteTest'><p>White's Model Specification Test</p></a></li>
<li><a href='#ztest'><p>Test for the difference of two groups' means</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.10.5</td>
</tr>
<tr>
<td>Title:</td>
<td>'SAS' Linear Model</td>
</tr>
<tr>
<td>Description:</td>
<td>This is a core implementation of 'SAS' procedures for linear models - GLM, REG, ANOVA, TTEST, FREQ, and UNIVARIATE. Some R packages provide type II and type III SS. However, the results of nested and complex designs are often different from those of 'SAS.' Different results does not necessarily mean incorrectness. However, many wants the same results to SAS. This package aims to achieve that. 
             Reference: Littell RC, Stroup WW, Freund RJ (2002, ISBN:0-471-22174-0).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), mvtnorm</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS</td>
</tr>
<tr>
<td>Author:</td>
<td>Kyun-Seop Bae [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kyun-Seop Bae &lt;k@acr.kr&gt;</td>
</tr>
<tr>
<td>Copyright:</td>
<td>2020-, Kyun-Seop Bae</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://cran.r-project.org/package=sasLM">https://cran.r-project.org/package=sasLM</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-02 05:41:37 UTC; Kyun-SeopBae</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-02 06:10:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='sasLM-package'>'SAS' Linear Model</h2><span id='topic+sasLM-package'></span><span id='topic+sasLM'></span>

<h3>Description</h3>

<p>This is a core implementation of 'SAS' procedures for linear models - GLM, REG, and ANOVA. Some packages provide type II and type III SS. However, the results of nested and complex designs are often different from those of 'SAS'. A different result does not necessarily mean incorrectness. However, many want the same result with 'SAS'. This package aims to achieve that. 
Reference: Littell RC, Stroup WW, Freund RJ (2002, ISBN:0-471-22174-0).
</p>


<h3>Details</h3>

<p>This will serve those who want SAS PROC GLM, REG, and ANOVA in R. 
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>Examples</h3>

<pre><code class='language-R'>## SAS PROC GLM Script for Typical Bioequivalence Data
# PROC GLM DATA=BEdata;
#   CLASS SEQ SUBJ PRD TRT;
#   MODEL LNCMAX = SEQ SUBJ(SEQ) PRD TRT;
#   RANDOM SUBJ(SEQ)/TEST;
#   LSMEANS TRT / DIFF=CONTROL("R") CL ALPHA=0.1;
#   ODS OUTPUT LSMeanDiffCL=LSMD;

# DATA LSMD;  SET LSMD;
#   PE = EXP(DIFFERENCE);
#   LL = EXP(LowerCL);
#   UL = EXP(UpperCL);  
# PROC PRINT DATA=LSMD; RUN;
##

## SAS PROC GLM equivalent
BEdata = af(BEdata, c("SEQ", "SUBJ", "PRD", "TRT")) # Columns as factor
formula1 = log(CMAX) ~ SEQ/SUBJ + PRD + TRT # Model
GLM(formula1, BEdata) # ANOVA tables of Type I, II, III SS
RanTest(formula1, BEdata, Random="SUBJ") # Hypothesis test with SUBJ as random
ci0 = CIest(formula1, BEdata, "TRT", c(-1, 1), 0.90) # 90$ CI
exp(ci0[, c("Estimate", "Lower CL", "Upper CL")]) # 90% CI of GMR

## 'nlme' or SAS PROC MIXED is preferred for an unbalanced case
## SAS PROC MIXED equivalent
# require(nlme)
# Result = lme(log(CMAX) ~ SEQ + PRD + TRT, random=~1|SUBJ, data=BEdata)
# summary(Result)
# VarCorr(Result)
# ci = intervals(Result, 0.90) ; ci 
# exp(ci$fixed["TRTT",])
##
</code></pre>

<hr>
<h2 id='af'>Convert some columns of a data.frame to factors</h2><span id='topic+af'></span>

<h3>Description</h3>

<p>Conveniently convert some columns of data.frame into factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  af(DataFrame, Cols)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="af_+3A_dataframe">DataFrame</code></td>
<td>
<p>a <code>data.frame</code></p>
</td></tr>
<tr><td><code id="af_+3A_cols">Cols</code></td>
<td>
<p>column names or indices to be converted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It performs conversion of some columns in a <code>data.frame</code> into factors conveniently. 
</p>


<h3>Value</h3>

<p>Returns a <code>data.frame</code> with converted columns.
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>

<hr>
<h2 id='aov1'>ANOVA with Type I SS</h2><span id='topic+aov1'></span>

<h3>Description</h3>

<p>ANOVA with Type I SS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  aov1(Formula, Data, BETA=FALSE, Resid=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aov1_+3A_formula">Formula</code></td>
<td>
<p>a conventional formula for a linear model.</p>
</td></tr>
<tr><td><code id="aov1_+3A_data">Data</code></td>
<td>
<p>a <code>data.frame</code> to be analyzed</p>
</td></tr>
<tr><td><code id="aov1_+3A_beta">BETA</code></td>
<td>
<p>if <code>TRUE</code>, coefficients (parameters) of <code>REG</code> will be returned. This is equivalent to SOLUTION option of SAS PROC GLM</p>
</td></tr>
<tr><td><code id="aov1_+3A_resid">Resid</code></td>
<td>
<p>if <code>TRUE</code>, fitted values (y hat) and residuals will be returned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It performs the core function of SAS PROC GLM, and returns Type I SS. This accepts continuous independent variables also.
</p>


<h3>Value</h3>

<p>The result table is comparable to that of SAS PROC ANOVA.
</p>
<table role = "presentation">
<tr><td><code>Df</code></td>
<td>
<p>degree of freedom</p>
</td></tr>
<tr><td><code>Sum Sq</code></td>
<td>
<p>sum of square for the set of contrasts</p>
</td></tr>
<tr><td><code>Mean Sq</code></td>
<td>
<p>mean square</p>
</td></tr>
<tr><td><code>F value</code></td>
<td>
<p>F value for the F distribution</p>
</td></tr>
<tr><td><code>Pr(&gt;F)</code></td>
<td>
<p>proability of larger than F value</p>
</td></tr> 
</table>
<p>Next returns are optional.
</p>
<table role = "presentation">
<tr><td><code>Parameter</code></td>
<td>
<p>Parameter table with standard error, t value, p value. <code>TRUE</code> is 1, and <code>FALSE</code> is 0 in the <code>Estimable</code> column. This is returned only with BETA=TRUE option.</p>
</td></tr>
<tr><td><code>Fitted</code></td>
<td>
<p>Fitted value or y hat. This is returned only with Resid=TRUE option.</p>
</td></tr>
<tr><td><code>Residual</code></td>
<td>
<p>Weigthed residuals. This is returned only with Resid=TRUE option.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>Examples</h3>

<pre><code class='language-R'>  aov1(uptake ~ Plant + Type + Treatment + conc, CO2)
  aov1(uptake ~ Plant + Type + Treatment + conc, CO2, BETA=TRUE)
  aov1(uptake ~ Plant + Type + Treatment + conc, CO2, Resid=TRUE)
  aov1(uptake ~ Plant + Type + Treatment + conc, CO2, BETA=TRUE, Resid=TRUE)
</code></pre>

<hr>
<h2 id='aov2'>ANOVA with Type II SS</h2><span id='topic+aov2'></span>

<h3>Description</h3>

<p>ANOVA with Type II SS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  aov2(Formula, Data, BETA=FALSE, Resid=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aov2_+3A_formula">Formula</code></td>
<td>
<p>a conventional formula for a linear model.</p>
</td></tr>
<tr><td><code id="aov2_+3A_data">Data</code></td>
<td>
<p>a <code>data.frame</code> to be analyzed</p>
</td></tr>
<tr><td><code id="aov2_+3A_beta">BETA</code></td>
<td>
<p>if <code>TRUE</code>, coefficients (parameters) of <code>REG</code> will be returned. This is equivalent to SOLUTION option of SAS PROC GLM</p>
</td></tr>
<tr><td><code id="aov2_+3A_resid">Resid</code></td>
<td>
<p>if <code>TRUE</code>, fitted values (y hat) and residuals will be returned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It performs the core function of SAS PROC GLM, and returns Type II SS. This accepts continuous independent variables also.
</p>


<h3>Value</h3>

<p>The result table is comparable to that of SAS PROC ANOVA.
</p>
<table role = "presentation">
<tr><td><code>Df</code></td>
<td>
<p>degree of freedom</p>
</td></tr>
<tr><td><code>Sum Sq</code></td>
<td>
<p>sum of square for the set of contrasts</p>
</td></tr>
<tr><td><code>Mean Sq</code></td>
<td>
<p>mean square</p>
</td></tr>
<tr><td><code>F value</code></td>
<td>
<p>F value for the F distribution</p>
</td></tr>
<tr><td><code>Pr(&gt;F)</code></td>
<td>
<p>proability of larger than F value</p>
</td></tr> 
</table>
<p>Next returns are optional.
</p>
<table role = "presentation">
<tr><td><code>Parameter</code></td>
<td>
<p>Parameter table with standard error, t value, p value. <code>TRUE</code> is 1, and <code>FALSE</code> is 0 in the <code>Estimable</code> column. This is returned only with BETA=TRUE option.</p>
</td></tr>
<tr><td><code>Fitted</code></td>
<td>
<p>Fitted value or y hat. This is returned only with Resid=TRUE option.</p>
</td></tr>
<tr><td><code>Residual</code></td>
<td>
<p>Weigthed residuals. This is returned only with Resid=TRUE option.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>Examples</h3>

<pre><code class='language-R'>  aov2(uptake ~ Plant + Type + Treatment + conc, CO2)
  aov2(uptake ~ Plant + Type + Treatment + conc, CO2, BETA=TRUE)
  aov2(uptake ~ Plant + Type + Treatment + conc, CO2, Resid=TRUE)
  aov2(uptake ~ Plant + Type + Treatment + conc, CO2, BETA=TRUE, Resid=TRUE)
  aov2(uptake ~ Type, CO2)
  aov2(uptake ~ Type - 1, CO2)
</code></pre>

<hr>
<h2 id='aov3'>ANOVA with Type III SS</h2><span id='topic+aov3'></span>

<h3>Description</h3>

<p>ANOVA with Type III SS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  aov3(Formula, Data, BETA=FALSE, Resid=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aov3_+3A_formula">Formula</code></td>
<td>
<p>a conventional formula for a linear model.</p>
</td></tr>
<tr><td><code id="aov3_+3A_data">Data</code></td>
<td>
<p>a <code>data.frame</code> to be analyzed</p>
</td></tr>
<tr><td><code id="aov3_+3A_beta">BETA</code></td>
<td>
<p>if <code>TRUE</code>, coefficients (parameters) of <code>REG</code> will be returned. This is equivalent to SOLUTION option of SAS PROC GLM</p>
</td></tr>
<tr><td><code id="aov3_+3A_resid">Resid</code></td>
<td>
<p>if <code>TRUE</code>, fitted values (y hat) and residuals will be returned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It performs the core function of SAS PROC GLM, and returns Type III SS. This accepts continuous independent variables also.
</p>


<h3>Value</h3>

<p>The result table is comparable to that of SAS PROC ANOVA.
</p>
<table role = "presentation">
<tr><td><code>Df</code></td>
<td>
<p>degree of freedom</p>
</td></tr>
<tr><td><code>Sum Sq</code></td>
<td>
<p>sum of square for the set of contrasts</p>
</td></tr>
<tr><td><code>Mean Sq</code></td>
<td>
<p>mean square</p>
</td></tr>
<tr><td><code>F value</code></td>
<td>
<p>F value for the F distribution</p>
</td></tr>
<tr><td><code>Pr(&gt;F)</code></td>
<td>
<p>proability of larger than F value</p>
</td></tr> 
</table>
<p>Next returns are optional.
</p>
<table role = "presentation">
<tr><td><code>Parameter</code></td>
<td>
<p>Parameter table with standard error, t value, p value. <code>TRUE</code> is 1, and <code>FALSE</code> is 0 in the <code>Estimable</code> column. This is returned only with BETA=TRUE option.</p>
</td></tr>
<tr><td><code>Fitted</code></td>
<td>
<p>Fitted value or y hat. This is returned only with Resid=TRUE option.</p>
</td></tr>
<tr><td><code>Residual</code></td>
<td>
<p>Weigthed residuals. This is returned only with Resid=TRUE option.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>Examples</h3>

<pre><code class='language-R'>  aov3(uptake ~ Plant + Type + Treatment + conc, CO2)
  aov3(uptake ~ Plant + Type + Treatment + conc, CO2, BETA=TRUE)
  aov3(uptake ~ Plant + Type + Treatment + conc, CO2, Resid=TRUE)
  aov3(uptake ~ Plant + Type + Treatment + conc, CO2, BETA=TRUE, Resid=TRUE)
</code></pre>

<hr>
<h2 id='aspirinCHD'>
An example data for meta-analysis - aspirin in coronary heart disease
</h2><span id='topic+aspirinCHD'></span>

<h3>Description</h3>

<p>The data is from 'Canner PL. An overview of six clinical trials of aspirin in coronary heart disease. Stat Med. 1987'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aspirinCHD</code></pre>


<h3>Format</h3>

<p>A data frame with 6 rows.
</p>

<dl>
<dt><code>y1</code></dt><dd><p>death event count of aspirin group</p>
</dd>
<dt><code>n1</code></dt><dd><p>total subjet of aspirin group</p>
</dd>
<dt><code>y2</code></dt><dd><p>death event count of placebo group</p>
</dd>
<dt><code>n2</code></dt><dd><p>total subject of placebo group</p>
</dd>
</dl>



<h3>Details</h3>

<p>This data is for educational purpose.
</p>


<h3>References</h3>

<p>Canner PL. An overview of six clinical trials of aspirin in coronary heart disease. Stat Med. 1987;6:255-263.
</p>

<hr>
<h2 id='BasicUtil'>Internal Functions</h2><span id='topic+pivotJ'></span><span id='topic+sortColName'></span><span id='topic+sumANOVA'></span><span id='topic+sumREG'></span><span id='topic+lsm0'></span><span id='topic+llsm0'></span><span id='topic+bL'></span><span id='topic+GrpCode'></span><span id='topic+plotDiff'></span><span id='topic+plotDunnett'></span><span id='topic+CheckAlias'></span><span id='topic+ex'></span><span id='topic+WhiteH'></span>

<h3>Description</h3>

<p>Internal functions</p>


<h3>Details</h3>

<p>These are not to be called by the user.</p>

<hr>
<h2 id='BEdata'>
An Example Data of Bioequivalence Study
</h2><span id='topic+BEdata'></span>

<h3>Description</h3>

<p>Contains Cmax data from a real bioequivalence study. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BEdata</code></pre>


<h3>Format</h3>

<p>A data frame with 91 observations on the following 6 variables.
</p>

<dl>
<dt><code>ADM</code></dt><dd><p>Admission or Hospitalization Group Code: 1, 2, or 3</p>
</dd>
<dt><code>SEQ</code></dt><dd><p>Group or Sequence character code: 'RT' or 'TR&quot;</p>
</dd>
<dt><code>PRD</code></dt><dd><p>Period numeric value: 1 or 2</p>
</dd>
<dt><code>TRT</code></dt><dd><p>Treatment or Drug code: 'R' or 'T'</p>
</dd>
<dt><code>SUBJ</code></dt><dd><p>Subject ID</p>
</dd>
<dt><code>CMAX</code></dt><dd><p>Cmax values</p>
</dd>
</dl>



<h3>Details</h3>

<p>This contains a real data of 2x2 bioequivalence study, which has three different hospitalization groups. See Bae KS, Kang SH. Bioequivalence data analysis for the case of separate hospitalization. Transl Clin Pharmacol. 2017;25(2):93-100. doi.org/10.12793/tcp.2017.25.2.93
</p>

<hr>
<h2 id='bk'>Beautify the output of knitr::kable</h2><span id='topic+bk'></span>

<h3>Description</h3>

<p>Trailing zeros after integer is somewhat annoying. This removes those in the vector of strings.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  bk(ktab, rpltag=c("n", "N"), dig=10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bk_+3A_ktab">ktab</code></td>
<td>
<p>an output of <code>knitr::kable</code></p>
</td></tr>
<tr><td><code id="bk_+3A_rpltag">rpltag</code></td>
<td>
<p>tag string of replacement rows. This is usually &quot;n&quot; which means the sample count.</p>
</td></tr>
<tr><td><code id="bk_+3A_dig">dig</code></td>
<td>
<p>maximum digits of decimals in the <code>kable</code> output</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is convenient if used with tsum0, tsum1, tsum2, tsum3, This requires <code>knitr::kable</code>.
</p>


<h3>Value</h3>

<p>A new processed vector of strings. The class is still <code>knitr_kable</code>.
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsum0">tsum0</a></code>, <code><a href="#topic+tsum1">tsum1</a></code>, <code><a href="#topic+tsum2">tsum2</a></code>, <code><a href="#topic+tsum3">tsum3</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## OUTPUT example
# t0 = tsum0(CO2, "uptake", c("mean", "median", "sd", "length", "min", "max"))
# bk(kable(t0)) # requires knitr package
#
# |       |        x|
# |:------|--------:|
# |mean   | 27.21310|
# |median | 28.30000|
# |sd     | 10.81441|
# |n      | 84      |
# |min    |  7.70000|
# |max    | 45.50000|

# t1 = tsum(uptake ~ Treatment, CO2, 
#           e=c("mean", "median", "sd", "min", "max", "length"), 
#           ou=c("chilled", "nonchilled"),
#           repl=list(c("median", "length"), c("med", "N")))
# 
# bk(kable(t1, digits=3)) # requires knitr package
# 
# |     | chilled| nonchilled| Combined|
# |:----|-------:|----------:|--------:|
# |mean |  23.783|     30.643|   27.213|
# |med  |  19.700|     31.300|   28.300|
# |sd   |  10.884|      9.705|   10.814|
# |min  |   7.700|     10.600|    7.700|
# |max  |  42.400|     45.500|   45.500|
# |N    |  42    |     42    |   84    |
</code></pre>

<hr>
<h2 id='BY'>Analysis BY variable</h2><span id='topic+BY'></span>

<h3>Description</h3>

<p>GLM, REG, aov1 etc. functions can be run by levels of a variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  BY(FUN, Formula, Data, By, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BY_+3A_fun">FUN</code></td>
<td>
<p>Function name to be called such as GLM, REG</p>
</td></tr>
<tr><td><code id="BY_+3A_formula">Formula</code></td>
<td>
<p>a conventional formula for a linear model.</p>
</td></tr>
<tr><td><code id="BY_+3A_data">Data</code></td>
<td>
<p>a <code>data.frame</code> to be analyzed</p>
</td></tr>
<tr><td><code id="BY_+3A_by">By</code></td>
<td>
<p>a variable name in the <code>Data</code></p>
</td></tr>
<tr><td><code id="BY_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code>FUN</code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This mimics SAS procedues' BY clause.
</p>


<h3>Value</h3>

<p>a list of <code>FUN</code> function outputs. The names are after each level.
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>Examples</h3>

<pre><code class='language-R'>  BY(GLM, uptake ~ Treatment + as.factor(conc), CO2, By="Type")
  BY(REG, uptake ~ conc, CO2, By="Type")
</code></pre>

<hr>
<h2 id='CIest'>Confidence Interval Estimation</h2><span id='topic+CIest'></span>

<h3>Description</h3>

<p>Get point estimate and its confidence interval with given contrast and alpha value using t distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  CIest(Formula, Data, Term, Contrast, conf.level=0.95) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CIest_+3A_formula">Formula</code></td>
<td>
<p>a conventional formula for a linear model</p>
</td></tr>
<tr><td><code id="CIest_+3A_data">Data</code></td>
<td>
<p>a <code>data.frame</code> to be analyzed</p>
</td></tr>
<tr><td><code id="CIest_+3A_term">Term</code></td>
<td>
<p>a factor name to be estimated</p>
</td></tr>
<tr><td><code id="CIest_+3A_contrast">Contrast</code></td>
<td>
<p>a level vector. Level is alphabetically ordered by default.</p>
</td></tr>
<tr><td><code id="CIest_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level of confidence interval</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Get point estimate and its confidence interval with given contrast and alpha value using t distribution.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Estimate</code></td>
<td>
<p>point estimate of the input linear contrast</p>
</td></tr>
<tr><td><code>Lower CL</code></td>
<td>
<p>lower confidence limit</p>
</td></tr>
<tr><td><code>Upper CL</code></td>
<td>
<p>upper confidence limit</p>
</td></tr>
<tr><td><code>Std. Error</code></td>
<td>
<p>standard error of the point estimate</p>
</td></tr>
<tr><td><code>t value</code></td>
<td>
<p>value for t distribution</p>
</td></tr>
<tr><td><code>Df</code></td>
<td>
<p>degree of freedom</p>
</td></tr>
<tr><td><code>Pr(&gt;|t|)</code></td>
<td>
<p>probability of larger than absolute t value from t distribution with residual's degree of freedom</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>Examples</h3>

<pre><code class='language-R'>  CIest(log(CMAX) ~ SEQ/SUBJ + PRD + TRT, BEdata, "TRT", c(-1, 1), 0.90) # 90% CI
</code></pre>

<hr>
<h2 id='Coll'>Collinearity Diagnostics</h2><span id='topic+Coll'></span>

<h3>Description</h3>

<p>Collearity diagnostics with tolerance, VIF, eigenvalue, condition index, variance proportions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Coll(Formula, Data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Coll_+3A_formula">Formula</code></td>
<td>
<p>fomula of the model</p>
</td></tr>
<tr><td><code id="Coll_+3A_data">Data</code></td>
<td>
<p>input data as a matrix or data.frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sometimes collinearity diagnostics after multiple linear regression are necessary.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Tol</code></td>
<td>
<p>tolerance of independent variables</p>
</td></tr>
<tr><td><code>VIF</code></td>
<td>
<p>variance inflation factor of independent variables</p>
</td></tr>
<tr><td><code>Eigenvalue</code></td>
<td>
<p>eigenvalue of Z'Z (crossproduct) of standardized independent variables</p>
</td></tr>
<tr><td><code>Cond. Index</code></td>
<td>
<p>condition index</p>
</td></tr>
<tr><td><code>Proportions of variances</code></td>
<td>
<p>under the names of coefficients</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>Examples</h3>

<pre><code class='language-R'>  Coll(mpg ~ disp + hp + drat + wt + qsec, mtcars) 
</code></pre>

<hr>
<h2 id='CONTR'>F Test with a Set of Contrasts</h2><span id='topic+CONTR'></span>

<h3>Description</h3>

<p>Do F test with a given set of contrasts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  CONTR(L, Formula, Data, mu=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CONTR_+3A_l">L</code></td>
<td>
<p>contrast matrix. Each row is a contrast.</p>
</td></tr>
<tr><td><code id="CONTR_+3A_formula">Formula</code></td>
<td>
<p>a conventional formula for a linear model</p>
</td></tr>
<tr><td><code id="CONTR_+3A_data">Data</code></td>
<td>
<p>a <code>data.frame</code> to be analyzed</p>
</td></tr>
<tr><td><code id="CONTR_+3A_mu">mu</code></td>
<td>
<p>a vector of mu for the hypothesis L. The length should be equal to the row count of L.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>It performs F test with a given set of contrasts (a matrix). It is similar to the CONTRAST clause of SAS PROC GLM. This can test the hypothesis that the linear combination (function)'s mean vector is mu.
</p>


<h3>Value</h3>

<p>Returns sum of square and its F value and p-value.
</p>
<table role = "presentation">
<tr><td><code>Df</code></td>
<td>
<p>degree of freedom</p>
</td></tr>
<tr><td><code>Sum Sq</code></td>
<td>
<p>sum of square for the set of contrasts</p>
</td></tr>
<tr><td><code>Mean Sq</code></td>
<td>
<p>mean square</p>
</td></tr>
<tr><td><code>F value</code></td>
<td>
<p>F value for the F distribution</p>
</td></tr>
<tr><td><code>Pr(&gt;F)</code></td>
<td>
<p>proability of larger than F value</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>See Also</h3>

<p><code><a href="#topic+cSS">cSS</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  CONTR(t(c(0, -1, 1)), uptake ~ Type, CO2) # sum of square 
  GLM(uptake ~ Type, CO2) # compare with the above
</code></pre>

<hr>
<h2 id='Cor.test'>Correlation test of multiple numeric columns</h2><span id='topic+Cor.test'></span>

<h3>Description</h3>

<p>Testing correlation between numeric columns of data with Pearson method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Cor.test(Data, conf.level=0.95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Cor.test_+3A_data">Data</code></td>
<td>
<p>a matrix or a data.frame</p>
</td></tr>
<tr><td><code id="Cor.test_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It uses all numeric columns of input data. It uses &quot;pairwise.complete.obs&quot; rows.
</p>


<h3>Value</h3>

<p>Row names show which columns are used for the test
</p>
<table role = "presentation">
<tr><td><code>Estimate</code></td>
<td>
<p>point estimate of correlation</p>
</td></tr>
<tr><td><code>Lower CL</code></td>
<td>
<p>upper confidence limit</p>
</td></tr>
<tr><td><code>Upper CL</code></td>
<td>
<p>lower condidence limit</p>
</td></tr>
<tr><td><code>t value</code></td>
<td>
<p>t value of the t distribution</p>
</td></tr>
<tr><td><code>Df</code></td>
<td>
<p>degree of freedom</p>
</td></tr>
<tr><td><code>Pr(&gt;|t|)</code></td>
<td>
<p>probability with the t distribution</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>Examples</h3>

<pre><code class='language-R'>  Cor.test(mtcars)
</code></pre>

<hr>
<h2 id='corFisher'>Correlation test by Fisher's Z transformation</h2><span id='topic+corFisher'></span>

<h3>Description</h3>

<p>Testing correlation between two numeric vectors by Fisher's Z transformation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  corFisher(x, y, conf.level=0.95, rho=0) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="corFisher_+3A_x">x</code></td>
<td>
<p>the first input numeric vector</p>
</td></tr>
<tr><td><code id="corFisher_+3A_y">y</code></td>
<td>
<p>the second input numeric vector</p>
</td></tr>
<tr><td><code id="corFisher_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level</p>
</td></tr>
<tr><td><code id="corFisher_+3A_rho">rho</code></td>
<td>
<p>population correlation rho under null hypothesis</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>This accepts only two numeric vectors.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>N</code></td>
<td>
<p>sample size, length of input vectors</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>sample correlation</p>
</td></tr>
<tr><td><code>Fisher.z</code></td>
<td>
<p>Fisher's z</p>
</td></tr>
<tr><td><code>bias</code></td>
<td>
<p>bias to correct</p>
</td></tr>
<tr><td><code>rho.hat</code></td>
<td>
<p>point estimate of population rho</p>
</td></tr>
<tr><td><code>conf.level</code></td>
<td>
<p>confidence level for the confidence interval</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>lower limit of confidence interval</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>upper limit of confidence interval</p>
</td></tr>
<tr><td><code>rho0</code></td>
<td>
<p>population correlation rho under null hypothesis</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>p value under the null hypothesis</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>References</h3>

<p>Fisher RA. Statistical Methods for Research Workers. 14e. 1973</p>


<h3>Examples</h3>

<pre><code class='language-R'>  corFisher(mtcars$disp, mtcars$hp, rho=0.6)
</code></pre>

<hr>
<h2 id='cSS'>Sum of Square with a Given Contrast Set</h2><span id='topic+cSS'></span>

<h3>Description</h3>

<p>Calculates sum of squares of a contrast from a <code>lfit</code> result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  cSS(K, rx, mu=0, eps=1e-8)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cSS_+3A_k">K</code></td>
<td>
<p>contrast matrix. Each row is a contrast.</p>
</td></tr>
<tr><td><code id="cSS_+3A_rx">rx</code></td>
<td>
<p>a result of <code>lfit</code> function</p>
</td></tr>  
<tr><td><code id="cSS_+3A_mu">mu</code></td>
<td>
<p>a vector of mu for the hypothesis K. The length should be equal to the row count of K.</p>
</td></tr>  
<tr><td><code id="cSS_+3A_eps">eps</code></td>
<td>
<p>Less than this value is considered as zero.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It calculates sum of squares with given a contrast matrix and a <code>lfit</code> result. It corresponds to SAS PROC GLM CONTRAST. This can test the hypothesis that the linear combination (function)'s mean vector is mu.
</p>


<h3>Value</h3>

<p>Returns sum of square and its F value and p-value.
</p>
<table role = "presentation">
<tr><td><code>Df</code></td>
<td>
<p>degree of freedom</p>
</td></tr>
<tr><td><code>Sum Sq</code></td>
<td>
<p>sum of square for the set of contrasts</p>
</td></tr>
<tr><td><code>Mean Sq</code></td>
<td>
<p>mean square</p>
</td></tr>
<tr><td><code>F value</code></td>
<td>
<p>F value for the F distribution</p>
</td></tr>
<tr><td><code>Pr(&gt;F)</code></td>
<td>
<p>proability of larger than F value</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>See Also</h3>

<p><code><a href="#topic+CONTR">CONTR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  rx = REG(uptake ~ Type, CO2, summarize=FALSE)
  cSS(t(c(0, -1, 1)), rx) # sum of square 
  GLM(uptake ~ Type, CO2) # compare with the above
</code></pre>

<hr>
<h2 id='CumAlpha'>Cumulative Alpha for the Fixed Z-value</h2><span id='topic+CumAlpha'></span>

<h3>Description</h3>

<p>Cumulative alpha values with repeated hypothesis with a fixed upper bound z-value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  CumAlpha(x, K=2, side=2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CumAlpha_+3A_x">x</code></td>
<td>
<p>fixed upper z-value bound for the repeated hypothesis test</p>
</td></tr>
<tr><td><code id="CumAlpha_+3A_k">K</code></td>
<td>
<p>total number of tests</p>
</td></tr>
<tr><td><code id="CumAlpha_+3A_side">side</code></td>
<td>
<p>1=one-side test, 2=two-side test</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It calculates cumulative alpha-values for the even-interval repeated hypothesis test with a fixed upper bound z-value. It assumes linear (proportional) increase of information amount and Brownian motion of z-value, i.e. the correlation is sqrt(t_i/t_j).
</p>


<h3>Value</h3>

<p>The result is a matrix.
</p>
<table role = "presentation">
<tr><td><code>ti</code></td>
<td>
<p>time of test, Even-interval is assumed.</p>
</td></tr>
<tr><td><code>cum.alpha</code></td>
<td>
<p>cumulative alpha valued</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>References</h3>

<p>Reboussin DM, DeMets DL, Kim K, Lan KKG. Computations for group sequential boundaries using the Lan-DeMets function method. Controlled Clinical Trials. 2000;21:190-207.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  CumAlpha(x=qnorm(1 - 0.05/2), K=10) # two-side Z-test with alpha=0.05 for ten times
</code></pre>

<hr>
<h2 id='CV'>Coefficient of Variation in percentage</h2><span id='topic+CV'></span>

<h3>Description</h3>

<p>Coefficient of variation in percentage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  CV(y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CV_+3A_y">y</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It removes <code>NA</code>.
</p>


<h3>Value</h3>

<p>Coefficient of variation in percentage.  
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>Examples</h3>

<pre><code class='language-R'> CV(mtcars$mpg)
</code></pre>

<hr>
<h2 id='Diffogram'>Plot Pairwise Differences</h2><span id='topic+Diffogram'></span>

<h3>Description</h3>

<p>Plot pairwise differences by a common.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Diffogram(Formula, Data, Term, conf.level=0.95, adj="lsd", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Diffogram_+3A_formula">Formula</code></td>
<td>
<p>a conventional formula for a linear model</p>
</td></tr>
<tr><td><code id="Diffogram_+3A_data">Data</code></td>
<td>
<p>a <code>data.frame</code> to be analyzed</p>
</td></tr>
<tr><td><code id="Diffogram_+3A_term">Term</code></td>
<td>
<p>a factor name to be estimated</p>
</td></tr>
<tr><td><code id="Diffogram_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level of confidence interval</p>
</td></tr>
<tr><td><code id="Diffogram_+3A_adj">adj</code></td>
<td>
<p>&quot;lsd&quot;, &quot;tukey&quot;, &quot;scheffe&quot;, &quot;bon&quot;, or &quot;duncan&quot; to adjust p-value and confidence limit</p>
</td></tr>
<tr><td><code id="Diffogram_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code>plot</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This usually shows the shortest interval. It corresponds to SAS PROC GLM PDIFF. For adjust method &quot;dunnett&quot;, see <code>PDIFF</code> function.
</p>


<h3>Value</h3>

<p>no return value, but a plot on the current device
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>See Also</h3>

<p><code><a href="#topic+LSM">LSM</a></code>, <code><a href="#topic+PDIFF">PDIFF</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  Diffogram(uptake ~ Type*Treatment + as.factor(conc), CO2, "as.factor(conc)")
</code></pre>

<hr>
<h2 id='DoEdata'>
Example Datasets
</h2><span id='topic+DoEdata'></span><span id='topic+score1'></span><span id='topic+bondreturn'></span><span id='topic+bulblife'></span><span id='topic+simxy1'></span><span id='topic+simxy2'></span><span id='topic+qcpass'></span><span id='topic+oneway'></span><span id='topic+edupgm'></span><span id='topic+transfat'></span><span id='topic+brandtar'></span><span id='topic+bacteria'></span><span id='topic+temptrend'></span><span id='topic+dietwt'></span><span id='topic+pigfeed'></span><span id='topic+hlpump'></span><span id='topic+BP'></span><span id='topic+fertpest1'></span><span id='topic+fertpest2'></span><span id='topic+defect1'></span><span id='topic+toollife'></span><span id='topic+score2'></span><span id='topic+rosemite'></span><span id='topic+sodium'></span><span id='topic+dampoll1'></span><span id='topic+dampoll2'></span><span id='topic+twoway'></span><span id='topic+dstrength'></span><span id='topic+tirewear1'></span><span id='topic+tirewear2'></span><span id='topic+tirewear3'></span><span id='topic+defect2'></span><span id='topic+keyspeed'></span><span id='topic+dynamite'></span><span id='topic+feedmice1'></span><span id='topic+feedmice2'></span><span id='topic+ccdyield'></span><span id='topic+bearing'></span><span id='topic+rsdata0'></span><span id='topic+ptensile'></span><span id='topic+beanyield'></span><span id='topic+leprosy'></span><span id='topic+feedsheep'></span>

<h3>Description</h3>

<p>Contains data frames to be used for textbooks
</p>


<h3>Details</h3>

<p>This contains datasets for textbooks.
</p>

<hr>
<h2 id='Drift'>Drift defined by Lan and DeMets for Group Sequential Design</h2><span id='topic+Drift'></span>

<h3>Description</h3>

<p>Calculate the drift value with given upper bounds (z-valuse), times of test, and power.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Drift(bi, ti=NULL, Power=0.9)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Drift_+3A_bi">bi</code></td>
<td>
<p>upper bound z-values</p>
</td></tr>
<tr><td><code id="Drift_+3A_ti">ti</code></td>
<td>
<p>times of test. These should be in the range of [0, 1]. If omitted, even-interval is assumed.</p>
</td></tr>
<tr><td><code id="Drift_+3A_power">Power</code></td>
<td>
<p>target power at the final test</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It calculates the drift value with given upper bound z-values, times of test, and power. If the times of test is not given, even-interval is assumed. <code>mvtnorm::pmvt</code> (with noncentrality) is better than pmvnorm in calculating power and sample size. But, Lan-DeMets used multi-variate normal rather than multi-variate noncentral t distributionh. This function followed Lan-DeMets for the consistency with previous results.
</p>


<h3>Value</h3>

<p>Drift value for the given condition
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>References</h3>

<p>Reboussin DM, DeMets DL, Kim K, Lan KKG. Computations for group sequential boundaries using the Lan-DeMets function method. Controlled Clinical Trials. 2000;21:190-207.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  Drift(seqBound(ti=(1:5)/5)[, "up.bound"])
</code></pre>

<hr>
<h2 id='e1'>Get a Contrast Matrix for Type I SS</h2><span id='topic+e1'></span>

<h3>Description</h3>

<p>Makes a contrast matrix for type I SS using forward Doolittle method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  e1(XpX, eps=1e-8)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="e1_+3A_xpx">XpX</code></td>
<td>
<p>crossprodut of a design or model matrix. This should have appropriate column names.</p>
</td></tr>
<tr><td><code id="e1_+3A_eps">eps</code></td>
<td>
<p>Less than this value is considered as zero.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It makes a contrast matrix for type I SS. If zapsmall is used, the result becomes more inaccurate.
</p>


<h3>Value</h3>

<p>A contrast matrix for type I SS.
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x = ModelMatrix(uptake ~ Plant + Type + Treatment + conc, CO2)
  round(e1(crossprod(x$X)), 12)
</code></pre>

<hr>
<h2 id='e2'>Get a Contrast Matrix for Type II SS</h2><span id='topic+e2'></span>

<h3>Description</h3>

<p>Makes a contrast matrix for type II SS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  e2(x, eps=1e-8)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="e2_+3A_x">x</code></td>
<td>
<p>an output of ModelMatrix</p>
</td></tr>
<tr><td><code id="e2_+3A_eps">eps</code></td>
<td>
<p>Less than this value is considered as zero.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It makes a contrast matrix for type II SS. If zapsmall is used, the result becomes more inaccurate.
</p>


<h3>Value</h3>

<p>A contrast matrix for type II SS.
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>Examples</h3>

<pre><code class='language-R'>  round(e2(ModelMatrix(uptake ~ Plant + Type + Treatment + conc, CO2)), 12)
  round(e2(ModelMatrix(uptake ~ Type, CO2)), 12)
  round(e2(ModelMatrix(uptake ~ Type - 1, CO2)), 12)
</code></pre>

<hr>
<h2 id='e3'>Get a Contrast Matrix for Type III SS</h2><span id='topic+e3'></span>

<h3>Description</h3>

<p>Makes a contrast matrix for type III SS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  e3(x, eps=1e-8)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="e3_+3A_x">x</code></td>
<td>
<p>an output of ModelMatrix</p>
</td></tr>
<tr><td><code id="e3_+3A_eps">eps</code></td>
<td>
<p>Less than this value is considered as zero.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It makes a contrast matrix for type III SS. If zapsmall is used, the result becomes more inaccurate.
</p>


<h3>Value</h3>

<p>A contrast matrix for type III SS.
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>Examples</h3>

<pre><code class='language-R'>  round(e3(ModelMatrix(uptake ~ Plant + Type + Treatment + conc, CO2)), 12)
</code></pre>

<hr>
<h2 id='EMS'>Expected Mean Square Formula</h2><span id='topic+EMS'></span>

<h3>Description</h3>

<p>Calculates a formula table for expected mean square of the given contrast. The default is for Type III SS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  EMS(Formula, Data, Type=3, eps=1e-8)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EMS_+3A_formula">Formula</code></td>
<td>
<p>a conventional formula for a linear model</p>
</td></tr>
<tr><td><code id="EMS_+3A_data">Data</code></td>
<td>
<p>a <code>data.frame</code> to be analyzed</p>
</td></tr>
<tr><td><code id="EMS_+3A_type">Type</code></td>
<td>
<p>type of sum of squares. The default is 3. Type 4 is not supported yet.</p>
</td></tr>
<tr><td><code id="EMS_+3A_eps">eps</code></td>
<td>
<p>Less than this value is considered as zero.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>This is necessary for further hypothesis tests of nesting factors.
</p>


<h3>Value</h3>

<p>A coefficient matrix for Type III expected mean square
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>Examples</h3>

<pre><code class='language-R'>  f1 = log(CMAX) ~ SEQ/SUBJ + PRD + TRT
  EMS(f1, BEdata)
  EMS(f1, BEdata, Type=1)
  EMS(f1, BEdata, Type=2)
</code></pre>

<hr>
<h2 id='est'>Estimate Linear Functions</h2><span id='topic+est'></span>

<h3>Description</h3>

<p>Estimates Linear Functions with a given GLM result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  est(L, X, rx, conf.level=0.95, adj="lsd", paired=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="est_+3A_l">L</code></td>
<td>
<p>a matrix of linear contrast rows to be tested</p>
</td></tr>
<tr><td><code id="est_+3A_x">X</code></td>
<td>
<p>a model (design) matrix from <code>ModelMatrix</code></p>
</td></tr>
<tr><td><code id="est_+3A_rx">rx</code></td>
<td>
<p>a result of <code>lfit</code> function</p>
</td></tr>
<tr><td><code id="est_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level of confidence limit</p>
</td></tr>
<tr><td><code id="est_+3A_adj">adj</code></td>
<td>
<p>adjustment method for grouping. This supports &quot;tukey&quot;, &quot;bon&quot;, &quot;scheffe&quot;, &quot;duncan&quot;, and &quot;dunnett&quot;. This only affects grouping, not the confidence interval.</p>
</td></tr>
<tr><td><code id="est_+3A_paired">paired</code></td>
<td>
<p>If this is TRUE, L matrix is for the pairwise comparison such as PDIFF function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It tests rows of linear function. Linear function means linear combination of estimated coefficients. It corresponds to SAS PROC GLM ESTIMATE. Same sample size per group is assumed for the Tukey adjustment. 
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Estimate</code></td>
<td>
<p>point estimate of the input linear contrast</p>
</td></tr>
<tr><td><code>Lower CL</code></td>
<td>
<p>lower confidence limit by &quot;lsd&quot; method</p>
</td></tr>
<tr><td><code>Upper CL</code></td>
<td>
<p>upper confidence limit by &quot;lsd&quot; method</p>
</td></tr>
<tr><td><code>Std. Error</code></td>
<td>
<p>standard error of the point estimate</p>
</td></tr>
<tr><td><code>t value</code></td>
<td>
<p>value for t distribution for other than &quot;scheffe&quot; method</p>
</td></tr>
<tr><td><code>F value</code></td>
<td>
<p>value for F distribution for &quot;scheffe&quot; method only</p>
</td></tr>
<tr><td><code>Df</code></td>
<td>
<p>degree of freedom of residuals</p>
</td></tr>
<tr><td><code>Pr(&gt;|t|)</code></td>
<td>
<p>probability of larger than absolute t value from t distribution with residual's degree of freedom, for other than &quot;scheffe&quot; method</p>
</td></tr>
<tr><td><code>Pr(&gt;F)</code></td>
<td>
<p>probability of larger than F value from F distribution with residual's degree of freedom, for &quot;scheffe&quot; method only</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>See Also</h3>

<p><code><a href="#topic+ESTM">ESTM</a></code>, <code><a href="#topic+PDIFF">PDIFF</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  x = ModelMatrix(uptake ~ Type, CO2)
  rx = REG(uptake ~ Type, CO2, summarize=FALSE)
  est(t(c(0, -1, 1)), x$X, rx) # Quebec - Mississippi 
  t.test(uptake ~ Type, CO2) # compare with the above
</code></pre>

<hr>
<h2 id='ESTM'>Estimate Linear Function</h2><span id='topic+ESTM'></span><span id='topic+ESTMIMATE'></span>

<h3>Description</h3>

<p>Estimates Linear Function with a formula and a dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ESTM(L, Formula, Data, conf.level=0.95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ESTM_+3A_l">L</code></td>
<td>
<p>a matrix of linear functions rows to be tested</p>
</td></tr>
<tr><td><code id="ESTM_+3A_formula">Formula</code></td>
<td>
<p>a conventional formula for a linear model</p>
</td></tr>
<tr><td><code id="ESTM_+3A_data">Data</code></td>
<td>
<p>a <code>data.frame</code> to be analyzed</p>
</td></tr>
<tr><td><code id="ESTM_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level of confidence limit</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It tests rows of linear functions. Linear function means linear combination of estimated coefficients. It is similar to SAS PROC GLM ESTIMATE. This is a convenient version of <code>est</code> function.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Estimate</code></td>
<td>
<p>point estimate of the input linear contrast</p>
</td></tr>
<tr><td><code>Lower CL</code></td>
<td>
<p>lower confidence limit</p>
</td></tr>
<tr><td><code>Upper CL</code></td>
<td>
<p>upper confidence limit</p>
</td></tr>
<tr><td><code>Std. Error</code></td>
<td>
<p>standard error of the point estimate</p>
</td></tr>
<tr><td><code>t value</code></td>
<td>
<p>value for t distribution</p>
</td></tr>
<tr><td><code>Df</code></td>
<td>
<p>degree of freedom</p>
</td></tr>
<tr><td><code>Pr(&gt;|t|)</code></td>
<td>
<p>probability of larger than absolute t value from t distribution with residual's degree of freedom</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>See Also</h3>

<p><code><a href="#topic+est">est</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  ESTM(t(c(0, -1, 1)), uptake ~ Type, CO2) # Quevec - Mississippi 
</code></pre>

<hr>
<h2 id='estmb'>Estimability Check</h2><span id='topic+estmb'></span>

<h3>Description</h3>

<p>Check the estimability of row vectors of coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  estmb(L, X, g2, eps=1e-8)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estmb_+3A_l">L</code></td>
<td>
<p>row vectors of coefficients</p>
</td></tr>
<tr><td><code id="estmb_+3A_x">X</code></td>
<td>
<p>a model (design) matrix from <code>ModelMatrix</code></p>
</td></tr>
<tr><td><code id="estmb_+3A_g2">g2</code></td>
<td>
<p>g2 generalized inverse of <code>crossprod(X)</code></p>
</td></tr>
<tr><td><code id="estmb_+3A_eps">eps</code></td>
<td>
<p>absolute value less than this is considered to be zero.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It checks the estimability of L, row vectors of coefficients. This corresponds to SAS PROC GLM ESTIMATE. See &lt;Kennedy Jr. WJ, Gentle JE. Statistical Computing. 1980&gt; p361 or &lt;Golub GH, Styan GP. Numerical Computations for Univariate Linear Models. 1971&gt;.
</p>


<h3>Value</h3>

<p>a vector of logical values indicating which row is estimable (as TRUE)
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>See Also</h3>

<p><code><a href="#topic+G2SWEEP">G2SWEEP</a></code></p>

<hr>
<h2 id='ExitP'>Exit Probability with cumulative Z-test in Group Sequential Design</h2><span id='topic+ExitP'></span>

<h3>Description</h3>

<p>Exit probabilities with given drift, upper bounds, and times of test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ExitP(Theta, bi, ti=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ExitP_+3A_theta">Theta</code></td>
<td>
<p>drift value defined by Lan-DeMets. See the reference.</p>
</td></tr>
<tr><td><code id="ExitP_+3A_bi">bi</code></td>
<td>
<p>upper bound z-values</p>
</td></tr>
<tr><td><code id="ExitP_+3A_ti">ti</code></td>
<td>
<p>times of test. These should be in the range of [0, 1]. If omitted, even-interval is assumed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It calculates exit proabilities and cumulative exit probabilities with given drift, upper z-bounds and times of test. If the times of test is not given, even-interval is assumed. <code>mvtnorm::pmvt</code> (with noncentrality) is better than pmvnorm in calculating power and sample size. But, Lan-DeMets used multi-variate normal rather than multi-variate noncentral t distributionh. This function followed Lan-DeMets for the consistency with previous results.
</p>


<h3>Value</h3>

<p>The result is a matrix.
</p>
<table role = "presentation">
<tr><td><code>ti</code></td>
<td>
<p>time of test</p>
</td></tr>
<tr><td><code>bi</code></td>
<td>
<p>upper z-bound</p>
</td></tr>
<tr><td><code>cum.alpha</code></td>
<td>
<p>cumulative alpha-value</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>References</h3>

<p>Reboussin DM, DeMets DL, Kim K, Lan KKG. Computations for group sequential boundaries using the Lan-DeMets function method. Controlled Clinical Trials. 2000;21:190-207.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  b0 = seqBound(ti=(1:5)/5)[, "up.bound"]
  ExitP(Theta = Drift(b0), bi = b0)
</code></pre>

<hr>
<h2 id='g2inv'>Generalized type 2 inverse matrix, g2 inverse</h2><span id='topic+g2inv'></span>

<h3>Description</h3>

<p>Generalized inverse is usually not unique. Some programs use this algorithm to get a unique generalized inverse matrix. This uses SWEEP operator and works for non-square matrix also.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  g2inv(A, eps=1e-08) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="g2inv_+3A_a">A</code></td>
<td>
<p>a matrix to be inverted</p>
</td></tr>
<tr><td><code id="g2inv_+3A_eps">eps</code></td>
<td>
<p>Less than this value is considered as zero.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See 'SAS Technical Report R106, The Sweep Operator: Its importance in Statistical Computing' by J. H. Goodnight for the detail.
</p>


<h3>Value</h3>

<p>g2 inverse
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>References</h3>

<p>Searle SR, Khuri AI. Matrix Algebra Useful for Statistics. 2e. John Wiley and Sons Inc. 2017.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+G2SWEEP">G2SWEEP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  A = matrix(c(1, 2, 4, 3, 3, -1, 2, -2, 5, -4, 0, -7), byrow=TRUE, ncol=4) ; A
  g2inv(A)
</code></pre>

<hr>
<h2 id='G2SWEEP'>Generalized inverse matrix of type 2 for linear regression</h2><span id='topic+G2SWEEP'></span>

<h3>Description</h3>

<p>Generalized inverse is usually not unique. Some programs use this algorithm to get a unique generalized inverse matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  G2SWEEP(A, Augmented=FALSE, eps=1e-08) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="G2SWEEP_+3A_a">A</code></td>
<td>
<p>a matrix to be inverted. If <code>A</code> is not a square matrix, G2SWEEP calls g2inv function.</p>
</td></tr>
<tr><td><code id="G2SWEEP_+3A_augmented">Augmented</code></td>
<td>
<p>If this is <code>TRUE</code> and <code>A</code> is a model(design) matrix X, the last column should be X'y, the last row y'X, and the last cell y'y. See the reference and example for the detail. If the input matrix <code>A</code> is not a square matrix, <code>Augmented</code> option cannot be TRUE.</p>
</td></tr>
<tr><td><code id="G2SWEEP_+3A_eps">eps</code></td>
<td>
<p>Less than this value is considered as zero.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generalized inverse of g2-type is used by some softwares to do linear regression. See 'SAS Technical Report R106, The Sweep Operator: Its importance in Statistical Computing' by J. H. Goodnight for the detail.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>when Augmented=FALSE</code></td>
<td>
<p>ordinary g2 inverse</p>
</td></tr>
<tr><td><code>when Augmented=TRUE</code></td>
<td>
<p>g2 inverse and beta hats in the last column and the last row, and sum of square error (SSE) in the last cell</p>
</td></tr>
<tr><td><code>attribute "rank"</code></td>
<td>
<p>the rank of input matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>See Also</h3>

<p><code><a href="#topic+lfit">lfit</a></code>, <code><a href="#topic+ModelMatrix">ModelMatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  f1 = uptake ~ Type + Treatment # formula
  x = ModelMatrix(f1, CO2)  # Model matrix and relevant information
  y = model.frame(f1, CO2)[, 1] # observation vector
  nc = ncol(x$X) # number of columns of model matrix
  XpY = crossprod(x$X, y)
  aXpX = rbind(cbind(crossprod(x$X), XpY), cbind(t(XpY), crossprod(y)))
  ag2 = G2SWEEP(aXpX, Augmented=TRUE)
  b = ag2[1:nc, (nc + 1)] ; b # Beta hat
  iXpX = ag2[1:nc, 1:nc] ; iXpX # g2 inverse of X'X
  SSE = ag2[(nc + 1), (nc + 1)] ; SSE # Sum of Square Error
  DFr = nrow(x$X) - attr(ag2, "rank") ; DFr # Degree of freedom for the residual

# Compare the below with the above
  REG(f1, CO2)
  aov1(f1, CO2)
</code></pre>

<hr>
<h2 id='geoCV'>Geometric Coefficient of Variation in percentage</h2><span id='topic+geoCV'></span>

<h3>Description</h3>

<p>Geometric coefficient of variation in percentage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  geoCV(y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geoCV_+3A_y">y</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It removes <code>NA</code>. This is sqrt(exp(var(log(x))) - 1)*100.
</p>


<h3>Value</h3>

<p>Geometric coefficient of variation in percentage.  
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>See Also</h3>

<p><code><a href="#topic+geoMean">geoMean</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  geoCV(mtcars$mpg)
</code></pre>

<hr>
<h2 id='geoMean'>Geometric Mean without NA</h2><span id='topic+geoMean'></span>

<h3>Description</h3>

<p>mean without <code>NA</code> values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  geoMean(y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geoMean_+3A_y">y</code></td>
<td>
<p>a vector of numerics</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It removes <code>NA</code> in the input vector. 
</p>


<h3>Value</h3>

<p>geometric mean value
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>See Also</h3>

<p><code><a href="#topic+geoCV">geoCV</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  geoMean(mtcars$mpg)
</code></pre>

<hr>
<h2 id='GLM'>General Linear Model similar to SAS PROC GLM</h2><span id='topic+GLM'></span>

<h3>Description</h3>

<p>GLM is the main function of this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  GLM(Formula, Data, BETA=FALSE, EMEAN=FALSE, Resid=FALSE, conf.level=0.95,
      Weights=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GLM_+3A_formula">Formula</code></td>
<td>
<p>a conventional formula for a linear model.</p>
</td></tr>
<tr><td><code id="GLM_+3A_data">Data</code></td>
<td>
<p>a <code>data.frame</code> to be analyzed</p>
</td></tr>
<tr><td><code id="GLM_+3A_beta">BETA</code></td>
<td>
<p>if <code>TRUE</code>, coefficients (parameters) of <code>REG</code> will be returned. This is equivalent to SOLUTION option of SAS PROC GLM</p>
</td></tr>
<tr><td><code id="GLM_+3A_emean">EMEAN</code></td>
<td>
<p>if <code>TRUE</code>, least square means (or expected means) will be returned. This is equivalent to LSMEANS clause of SAS PROC GLM</p>
</td></tr>
<tr><td><code id="GLM_+3A_resid">Resid</code></td>
<td>
<p>if <code>TRUE</code>, fitted values (y hat) and residuals will be returned</p>
</td></tr>
<tr><td><code id="GLM_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level for the confidence limit of the least square mean</p>
</td></tr>
<tr><td><code id="GLM_+3A_weights">Weights</code></td>
<td>
<p>weights for the weighted least square</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It performs the core function of SAS PROC GLM. Least square means for the interaction term of three variables is not supported yet.
</p>


<h3>Value</h3>

<p>The result is comparable to that of SAS PROC GLM.
</p>
<table role = "presentation">
<tr><td><code>ANOVA</code></td>
<td>
<p>ANOVA table for the model</p>
</td></tr>
<tr><td><code>Fitness</code></td>
<td>
<p>Some measures of goodness of fit such as R-square and CV</p>
</td></tr>
<tr><td><code>Type I</code></td>
<td>
<p>Type I sum of square table</p>
</td></tr>
<tr><td><code>Type II</code></td>
<td>
<p>Type II sum of square table</p>
</td></tr>
<tr><td><code>Type III</code></td>
<td>
<p>Type III sum of square table</p>
</td></tr>
<tr><td><code>Parameter</code></td>
<td>
<p>Parameter table with standard error, t value, p value. <code>TRUE</code> is 1, and <code>FALSE</code> is 0 in the <code>Estimable</code> column. This is returned only with BETA=TRUE option.</p>
</td></tr>
<tr><td><code>Expected Mean</code></td>
<td>
<p>Least square (or expected) mean table with confidence limit. This is returned only with EMEAN=TRUE option.</p>
</td></tr>
<tr><td><code>Fitted</code></td>
<td>
<p>Fitted value or y hat. This is returned only with Resid=TRUE option.</p>
</td></tr>
<tr><td><code>Residual</code></td>
<td>
<p>Weigthed residuals. This is returned only with Resid=TRUE option.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>Examples</h3>

<pre><code class='language-R'>GLM(uptake ~ Type*Treatment + conc, CO2[-1,]) # Making data unbalanced
GLM(uptake ~ Type*Treatment + conc, CO2[-1,], BETA=TRUE)
GLM(uptake ~ Type*Treatment + conc, CO2[-1,], EMEAN=TRUE)
GLM(uptake ~ Type*Treatment + conc, CO2[-1,], Resid=TRUE)
GLM(uptake ~ Type*Treatment + conc, CO2[-1,], BETA=TRUE, EMEAN=TRUE)
GLM(uptake ~ Type*Treatment + conc, CO2[-1,], BETA=TRUE, EMEAN=TRUE, Resid=TRUE)
</code></pre>

<hr>
<h2 id='is.cor'>Is it a correlation matrix?</h2><span id='topic+is.cor'></span>

<h3>Description</h3>

<p>Testing if the input matrix is a correlation matrix or not
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  is.cor(m, eps=1e-16)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.cor_+3A_m">m</code></td>
<td>
<p>a presumed correlation matrix</p>
</td></tr>
<tr><td><code id="is.cor_+3A_eps">eps</code></td>
<td>
<p>epsilon value. An absolute value less than this is considered as zero.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A diagonal component should not be necessarily 1. But it should be close to 1.
</p>


<h3>Value</h3>

<p>TRUE or FALSE
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>

<hr>
<h2 id='Kurtosis'>Kurtosis</h2><span id='topic+Kurtosis'></span>

<h3>Description</h3>

<p>Kurtosis with a conventional formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Kurtosis(y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Kurtosis_+3A_y">y</code></td>
<td>
<p>a vector of numerics</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It removes <code>NA</code> in the input vector. 
</p>


<h3>Value</h3>

<p>Estimate of kurtosis
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>See Also</h3>

<p><code><a href="#topic+KurtosisSE">KurtosisSE</a></code>
</p>

<hr>
<h2 id='KurtosisSE'>Standard Error of Kurtosis</h2><span id='topic+KurtosisSE'></span>

<h3>Description</h3>

<p>Standard error of the estimated kurtosis with a conventional formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  KurtosisSE(y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="KurtosisSE_+3A_y">y</code></td>
<td>
<p>a vector of numerics</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It removes <code>NA</code> in the input vector. 
</p>


<h3>Value</h3>

<p>Standard error of the estimated kurtosis
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>See Also</h3>

<p><code><a href="#topic+Kurtosis">Kurtosis</a></code>
</p>

<hr>
<h2 id='LCL'>Lower Confidence Limit</h2><span id='topic+LCL'></span>

<h3>Description</h3>

<p>The estimate of the lower bound of confidence limit using t-distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  LCL(y, conf.level=0.95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LCL_+3A_y">y</code></td>
<td>
<p>a vector of numerics</p>
</td></tr>
<tr><td><code id="LCL_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It removes <code>NA</code> in the input vector. 
</p>


<h3>Value</h3>

<p>The estimate of the lower bound of confidence limit using t-distribution
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>See Also</h3>

<p><code><a href="#topic+UCL">UCL</a></code>
</p>

<hr>
<h2 id='lfit'>Linear Fit</h2><span id='topic+lfit'></span>

<h3>Description</h3>

<p>Fits a least square linear model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  lfit(x, y, eps=1e-8)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lfit_+3A_x">x</code></td>
<td>
<p>a result of ModelMatrix</p>
</td></tr>
<tr><td><code id="lfit_+3A_y">y</code></td>
<td>
<p>a column vector of response, dependent variable</p>
</td></tr>
<tr><td><code id="lfit_+3A_eps">eps</code></td>
<td>
<p>Less than this value is considered as zero.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Minimum version of least square fit of a linear model
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>coeffcients</code></td>
<td>
<p>beta coefficients</p>
</td></tr>
<tr><td><code>g2</code></td>
<td>
<p>g2 inverse</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>rank of the model matrix</p>
</td></tr>
<tr><td><code>DFr</code></td>
<td>
<p>degree of freedom for the residual</p>
</td></tr>
<tr><td><code>SSE</code></td>
<td>
<p>sum of squares error</p>
</td></tr>
<tr><td><code>SST</code></td>
<td>
<p>sum of squares total</p>
</td></tr>
<tr><td><code>DFr2</code></td>
<td>
<p>degree of freedom of the residual for beta coefficient</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>See Also</h3>

<p><code><a href="#topic+ModelMatrix">ModelMatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  f1 = uptake ~ Type*Treatment + conc
  x = ModelMatrix(f1, CO2)
  y = model.frame(f1, CO2)[,1]
  lfit(x, y)
</code></pre>

<hr>
<h2 id='lr'>Linear Regression with g2 inverse</h2><span id='topic+lr'></span>

<h3>Description</h3>

<p>Coefficients calculated with g2 inverse. Output is similar to <code>summary(lm())</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  lr(Formula, Data, eps=1e-8)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lr_+3A_formula">Formula</code></td>
<td>
<p>a conventional formula for a linear model</p>
</td></tr>
<tr><td><code id="lr_+3A_data">Data</code></td>
<td>
<p>a <code>data.frame</code> to be analyzed</p>
</td></tr>
<tr><td><code id="lr_+3A_eps">eps</code></td>
<td>
<p>Less than this value is considered as zero.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It uses G2SWEEP to get g2 inverse. The result is similar to <code>summary(lm())</code> without options.
</p>


<h3>Value</h3>

<p>The result is comparable to that of SAS PROC REG.
</p>
<table role = "presentation">
<tr><td><code>Estimate</code></td>
<td>
<p>point estimate of parameters, coefficients</p>
</td></tr>
<tr><td><code>Std. Error</code></td>
<td>
<p>standard error of the point estimate</p>
</td></tr>
<tr><td><code>t value</code></td>
<td>
<p>value for t distribution</p>
</td></tr>
<tr><td><code>Pr(&gt;|t|)</code></td>
<td>
<p>probability of larger than absolute t value from t distribution with residual's degree of freedom</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>Examples</h3>

<pre><code class='language-R'>  lr(uptake ~ Plant + Type + Treatment + conc, CO2)
  lr(uptake ~ Plant + Type + Treatment + conc - 1, CO2)
  lr(uptake ~ Type, CO2)
  lr(uptake ~ Type - 1, CO2)
</code></pre>

<hr>
<h2 id='lr0'>Simple Linear Regressions with Each Independent Variable</h2><span id='topic+lr0'></span>

<h3>Description</h3>

<p>Usually, the first step to multiple linear regression is simple linear regressions with a single independent variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  lr0(Formula, Data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lr0_+3A_formula">Formula</code></td>
<td>
<p>a conventional formula for a linear model. Intercept will always be added.</p>
</td></tr>
<tr><td><code id="lr0_+3A_data">Data</code></td>
<td>
<p>a <code>data.frame</code> to be analyzed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It performs simple linear regression for each independent variable.
</p>


<h3>Value</h3>

<p>Each row means one simple linear regression with that row name as the only independent variable.
</p>
<table role = "presentation">
<tr><td><code>Intercept</code></td>
<td>
<p>estimate of the intecept</p>
</td></tr>
<tr><td><code>SE(Intercept)</code></td>
<td>
<p>standard error of the intercept</p>
</td></tr>
<tr><td><code>Slope</code></td>
<td>
<p>estimate of the slope</p>
</td></tr>
<tr><td><code>SE(Slope)</code></td>
<td>
<p>standard error of the slope</p>
</td></tr>
<tr><td><code>Rsq</code></td>
<td>
<p>R-squared for the simple linear model</p>
</td></tr>
<tr><td><code>Pr(&gt;F)</code></td>
<td>
<p>p-value of slope or the model</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>Examples</h3>

<pre><code class='language-R'>  lr0(uptake ~ Plant + Type + Treatment + conc, CO2)
  lr0(mpg ~ ., mtcars)
</code></pre>

<hr>
<h2 id='LSM'>Least Square Means</h2><span id='topic+LSM'></span>

<h3>Description</h3>

<p>Estimates least square means using g2 inverse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  LSM(Formula, Data, Term, conf.level=0.95, adj="lsd", hideNonEst=TRUE, 
      PLOT=FALSE, descend=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LSM_+3A_formula">Formula</code></td>
<td>
<p>a conventional formula of model</p>
</td></tr>
<tr><td><code id="LSM_+3A_data">Data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="LSM_+3A_term">Term</code></td>
<td>
<p>term name to be returned. If there is only one independent variable, this can be omitted.</p>
</td></tr>
<tr><td><code id="LSM_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level for the confidence limit</p>
</td></tr>
<tr><td><code id="LSM_+3A_adj">adj</code></td>
<td>
<p>adjustment method for grouping, &quot;lsd&quot;(default), &quot;tukey&quot;, &quot;bon&quot;, &quot;duncan&quot;, &quot;scheffe&quot; are available. This does not affects SE, Lower CL, Upper CL of the output table.</p>
</td></tr>  
<tr><td><code id="LSM_+3A_hidenonest">hideNonEst</code></td>
<td>
<p>logical. hide non-estimables</p>
</td></tr>
<tr><td><code id="LSM_+3A_plot">PLOT</code></td>
<td>
<p>logical. whether to plot LSMs and their confidence intervals</p>
</td></tr>
<tr><td><code id="LSM_+3A_descend">descend</code></td>
<td>
<p>logical. This specifies the plotting order be ascending or descending.</p>
</td></tr>
<tr><td><code id="LSM_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code>plot</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>It corresponds to SAS PROC GLM LSMEANS. The result of the second example below may be different from <code>emmeans</code>. This is because SAS or this function calculates mean of the transformed continuous variable. However, <code>emmeans</code> calculates the average before the transformation. Interaction of three variables is not supported yet. For adjust method &quot;dunnett&quot;, see <code>PDIFF</code> function.
</p>


<h3>Value</h3>

<p>Returns a table of expectations, t values and p-values.
</p>
<table role = "presentation">
<tr><td><code>Group</code></td>
<td>
<p>group character. This appears with one-way ANOVA or <code>Term</code> or <code>adj</code> argument is provided.  </p>
</td></tr>
<tr><td><code>LSmean</code></td>
<td>
<p>point estimate of least square mean</p>
</td></tr>
<tr><td><code>LowerCL</code></td>
<td>
<p>lower confidence limit with the given confidence level by &quot;lsd&quot; method</p>
</td></tr>
<tr><td><code>UpperCL</code></td>
<td>
<p>upper confidence limit with the given confidence level by &quot;lsd&quot; method</p>
</td></tr>
<tr><td><code>SE</code></td>
<td>
<p>standard error of the point estimate</p>
</td></tr>
<tr><td><code>Df</code></td>
<td>
<p>degree of freedom of point estimate</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>See Also</h3>

<p><code><a href="#topic+PDIFF">PDIFF</a></code>, <code><a href="#topic+Diffogram">Diffogram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  LSM(uptake ~ Type, CO2[-1,])
  LSM(uptake ~ Type - 1, CO2[-1,])
  LSM(uptake ~ Type*Treatment + conc, CO2[-1,])
  LSM(uptake ~ Type*Treatment + conc - 1, CO2[-1,])
  LSM(log(uptake) ~ Type*Treatment + log(conc), CO2[-1,])
  LSM(log(uptake) ~ Type*Treatment + log(conc) - 1, CO2[-1,])
  LSM(log(uptake) ~ Type*Treatment + as.factor(conc), CO2[-1,])
  LSM(log(uptake) ~ Type*Treatment + as.factor(conc) - 1, CO2[-1,])
  LSM(log(CMAX) ~ SEQ/SUBJ + PRD + TRT, BEdata)
  LSM(log(CMAX) ~ SEQ/SUBJ + PRD + TRT - 1, BEdata)
</code></pre>

<hr>
<h2 id='Max'>Max without NA</h2><span id='topic+Max'></span>

<h3>Description</h3>

<p>maximum without <code>NA</code> values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Max(y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Max_+3A_y">y</code></td>
<td>
<p>a vector of numerics</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It removes <code>NA</code> in the input vector. 
</p>


<h3>Value</h3>

<p>maximum value
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>

<hr>
<h2 id='Mean'>Mean without NA</h2><span id='topic+Mean'></span>

<h3>Description</h3>

<p>mean without <code>NA</code> values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Mean(y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Mean_+3A_y">y</code></td>
<td>
<p>a vector of numerics</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It removes <code>NA</code> in the input vector. 
</p>


<h3>Value</h3>

<p>mean value
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>

<hr>
<h2 id='Median'>Median without NA</h2><span id='topic+Median'></span>

<h3>Description</h3>

<p>median without <code>NA</code> values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Median(y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Median_+3A_y">y</code></td>
<td>
<p>a vector of numerics</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It removes <code>NA</code> in the input vector. 
</p>


<h3>Value</h3>

<p>median value
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>

<hr>
<h2 id='Min'>Min without NA</h2><span id='topic+Min'></span>

<h3>Description</h3>

<p>minimum without <code>NA</code> values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Min(y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Min_+3A_y">y</code></td>
<td>
<p>a vector of numerics</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It removes <code>NA</code> in the input vector. 
</p>


<h3>Value</h3>

<p>minimum value
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>

<hr>
<h2 id='ModelMatrix'>Model Matrix</h2><span id='topic+ModelMatrix'></span>

<h3>Description</h3>

<p>This model matrix is similar to <code>model.matrix</code>. But it does not omit unnecessary columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ModelMatrix(Formula, Data, KeepOrder=FALSE, XpX=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ModelMatrix_+3A_formula">Formula</code></td>
<td>
<p>a conventional formula for a linear model</p>
</td></tr>
<tr><td><code id="ModelMatrix_+3A_data">Data</code></td>
<td>
<p>a <code>data.frame</code> to be analyzed</p>
</td></tr>
<tr><td><code id="ModelMatrix_+3A_keeporder">KeepOrder</code></td>
<td>
<p>If <code>KeepOrder</code> is <code>TRUE</code>, terms in <code>Formula</code> will be kept. This is for Type I SS.</p>
</td></tr>
<tr><td><code id="ModelMatrix_+3A_xpx">XpX</code></td>
<td>
<p>If <code>XpX</code> is <code>TRUE</code>, the cross-product of the design matrix (XpX, X'X) will be returned instead of the design matrix (X).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It makes the model(design) matrix for <code>GLM</code>.
</p>


<h3>Value</h3>

<p>Model matrix and attributes similar to the output of <code>model.matrix</code>.
</p>
<table role = "presentation">
<tr><td><code>X</code></td>
<td>
<p>design matrix, i.e. model matrix</p>
</td></tr>
<tr><td><code>XpX</code></td>
<td>
<p>cross-product of the design matrix, X'X</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>detailed information about terms such as formula and labels</p>
</td></tr>
<tr><td><code>termsIndices</code></td>
<td>
<p>term indices</p>
</td></tr>
<tr><td><code>assign</code></td>
<td>
<p>assignemnt of columns for each term in order, different way of expressing term indices</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>

<hr>
<h2 id='mtest'>Independent two groups t-test similar to PROC TTEST with summarized input</h2><span id='topic+mtest'></span>

<h3>Description</h3>

<p>This is comparable to SAS PROC TTEST except using summarized input (sufficient statistics).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  mtest(m1, s1, n1, m0, s0, n0, conf.level=0.95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mtest_+3A_m1">m1</code></td>
<td>
<p>mean of the first (test, active, experimental) group</p>
</td></tr>
<tr><td><code id="mtest_+3A_s1">s1</code></td>
<td>
<p>sample standard deviation of the first group</p>
</td></tr>
<tr><td><code id="mtest_+3A_n1">n1</code></td>
<td>
<p>sample size of the first group</p>
</td></tr>
<tr><td><code id="mtest_+3A_m0">m0</code></td>
<td>
<p>mean of the second (reference, control, placebo) group</p>
</td></tr>
<tr><td><code id="mtest_+3A_s0">s0</code></td>
<td>
<p>sample standard deviation of the second group</p>
</td></tr>
<tr><td><code id="mtest_+3A_n0">n0</code></td>
<td>
<p>sample size of the second group</p>
</td></tr>
<tr><td><code id="mtest_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This uses summarized input. This also produces confidence intervals of means and variances by group.
</p>


<h3>Value</h3>

<p>The output format is comparable to SAS PROC TTEST.
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>See Also</h3>

<p><code><a href="#topic+TTEST">TTEST</a></code>, <code><a href="#topic+tmtest">tmtest</a></code>, <code><a href="#topic+ztest">ztest</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  mtest(5.4, 10.5, 3529, 5.1, 8.9, 5190) # NEJM 388;15 p1386
</code></pre>

<hr>
<h2 id='N'>Number of observations</h2><span id='topic+N'></span>

<h3>Description</h3>

<p>Number of observations excluding <code>NA</code> values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  N(y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="N_+3A_y">y</code></td>
<td>
<p>a vector of numerics</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It removes <code>NA</code> in the input vector. 
</p>


<h3>Value</h3>

<p>Count of the observation
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>

<hr>
<h2 id='OR'>Odds Ratio of two groups</h2><span id='topic+OR'></span>

<h3>Description</h3>

<p>Odds Ratio between two groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  OR(y1, n1, y2, n2, conf.level=0.95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="OR_+3A_y1">y1</code></td>
<td>
<p>positive event count of test (the first) group</p>
</td></tr>
<tr><td><code id="OR_+3A_n1">n1</code></td>
<td>
<p>total count of the test (the first) group</p>
</td></tr>
<tr><td><code id="OR_+3A_y2">y2</code></td>
<td>
<p>positive event count of control (the second) group</p>
</td></tr>
<tr><td><code id="OR_+3A_n2">n2</code></td>
<td>
<p>total count of control (the second) group</p>
</td></tr>
<tr><td><code id="OR_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It calculates odds ratio of two groups. No continuity correction here. If you need percent scale, multiply the output by 100.
</p>


<h3>Value</h3>

<p>The result is a data.frame.
</p>
<table role = "presentation">
<tr><td><code>odd1</code></td>
<td>
<p>proportion from the first group</p>
</td></tr>
<tr><td><code>odd2</code></td>
<td>
<p>proportion from the second group</p>
</td></tr>
<tr><td><code>OR</code></td>
<td>
<p>odds ratio, odd1/odd2</p>
</td></tr>
<tr><td><code>SElog</code></td>
<td>
<p>standard error of log(OR)</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>lower confidence limit of OR</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>upper confidence limit of OR</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>See Also</h3>

<p><code><a href="#topic+RD">RD</a></code>, <code><a href="#topic+RR">RR</a></code>, <code><a href="#topic+RDmn1">RDmn1</a></code>, <code><a href="#topic+RRmn1">RRmn1</a></code>, <code><a href="#topic+ORmn1">ORmn1</a></code>, <code><a href="#topic+RDmn">RDmn</a></code>, <code><a href="#topic+RRmn">RRmn</a></code>, <code><a href="#topic+ORmn">ORmn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  OR(104, 11037, 189, 11034) # no continuity correction
</code></pre>

<hr>
<h2 id='ORcmh'>Odds Ratio of two groups with strata by CMH method</h2><span id='topic+ORcmh'></span>

<h3>Description</h3>

<p>Odds ratio and its score confidence interval of two groups with stratification by Cochran-Mantel-Haenszel method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ORcmh(d0, conf.level=0.95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ORcmh_+3A_d0">d0</code></td>
<td>
<p>A data.frame or matrix, of which each row means a strata. This should have four columns named y1, n1, y2, and n2; y1 and y2 for events of each group, n1 and n2 for sample size of each strata. The second group is usually the control group.</p>
</td></tr>
<tr><td><code id="ORcmh_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It calculates odds ratio and its score confidence interval of two groups. This can be used for meta-analysis also.
</p>


<h3>Value</h3>

<p>The following output will be returned for each stratum and common value. There is no standard error.
</p>
<table role = "presentation">
<tr><td><code>odd1</code></td>
<td>
<p>odd from the first group, y1/(n1 - y1)</p>
</td></tr>
<tr><td><code>odd2</code></td>
<td>
<p>odd from the second group, y2/(n2 - y2)</p>
</td></tr>
<tr><td><code>OR</code></td>
<td>
<p>odds ratio, odd1/odd2. The point estimate of common OR is calculated with MH weight.</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>lower confidence limit of OR</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>upper confidence limit of OR</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>See Also</h3>

<p><code><a href="#topic+RDmn1">RDmn1</a></code>, <code><a href="#topic+RRmn1">RRmn1</a></code>, <code><a href="#topic+ORmn1">ORmn1</a></code>, <code><a href="#topic+RDmn">RDmn</a></code>, <code><a href="#topic+RRmn">RRmn</a></code>, <code><a href="#topic+ORmn">ORmn</a></code>, <code><a href="#topic+RDinv">RDinv</a></code>, <code><a href="#topic+RRinv">RRinv</a></code>, <code><a href="#topic+ORinv">ORinv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  d1 = matrix(c(25, 339, 28, 335, 23, 370, 40, 364), nrow=2, byrow=TRUE)
  colnames(d1) =  c("y1", "n1", "y2", "n2")
  ORcmh(d1)
</code></pre>

<hr>
<h2 id='ORinv'>Odds Ratio of two groups with strata by inverse variance method</h2><span id='topic+ORinv'></span>

<h3>Description</h3>

<p>Odds ratio and its score confidence interval of two groups with stratification by inverse variance method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ORinv(d0, conf.level=0.95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ORinv_+3A_d0">d0</code></td>
<td>
<p>A data.frame or matrix, of which each row means a stratum. This should have four columns named y1, n1, y2, and n2; y1 and y2 for events of each group, n1 and n2 for sample size of each strata. The second group is usually the control group.</p>
</td></tr>
<tr><td><code id="ORinv_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It calculates odds ratio and its confidence interval of two groups by inverse variance method. This supports stratification. This can be used for meta-analysis also.
</p>


<h3>Value</h3>

<p>The following output will be returned for each stratum and common value. There is no standard error.
</p>
<table role = "presentation">
<tr><td><code>odd1</code></td>
<td>
<p>odd from the first group, y1/(n1 - y1)</p>
</td></tr>
<tr><td><code>odd2</code></td>
<td>
<p>odd from the second group, y2/(n2 - y2)</p>
</td></tr>
<tr><td><code>OR</code></td>
<td>
<p>odds ratio, odd1/odd2. The point estimate of common OR is calculated with MH weight.</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>lower confidence limit of OR</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>upper confidence limit of OR</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>See Also</h3>

<p><code><a href="#topic+RDmn1">RDmn1</a></code>, <code><a href="#topic+RRmn1">RRmn1</a></code>, <code><a href="#topic+ORmn1">ORmn1</a></code>, <code><a href="#topic+RDmn">RDmn</a></code>, <code><a href="#topic+RRmn">RRmn</a></code>, <code><a href="#topic+ORmn">ORmn</a></code>, <code><a href="#topic+RDinv">RDinv</a></code>, <code><a href="#topic+RRinv">RRinv</a></code>, <code><a href="#topic+ORcmh">ORcmh</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  d1 = matrix(c(25, 339, 28, 335, 23, 370, 40, 364), nrow=2, byrow=TRUE)
  colnames(d1) =  c("y1", "n1", "y2", "n2")
  ORinv(d1)
</code></pre>

<hr>
<h2 id='ORmn'>Odds Ratio and Score CI of two groups with strata by MN method</h2><span id='topic+ORmn'></span>

<h3>Description</h3>

<p>Odds ratio and its score confidence interval of two groups with stratification by the Miettinen and Nurminen method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ORmn(d0, conf.level=0.95, eps=1e-8)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ORmn_+3A_d0">d0</code></td>
<td>
<p>A data.frame or matrix, of which each row means a strata. This should have four columns named y1, n1, y2, and n2; y1 and y2 for events of each group, n1 and n2 for sample size of each strata. The second group is usually the control group.</p>
</td></tr>
<tr><td><code id="ORmn_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level</p>
</td></tr>
<tr><td><code id="ORmn_+3A_eps">eps</code></td>
<td>
<p>absolute value less than eps is regarded as negligible</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It calculates odds ratio and its score confidence interval of the two groups. The confidence interval is asymmetric, and there is no standard error in the output. This supports stratification. This implementation uses uniroot function, which usually gives at least 5 significant digits. Whereas PropCIs::orscoreci function uses incremental or decremental search by the factor of 1.001 which gives only about 3 significant digits. This can be used for meta-analysis also.
</p>


<h3>Value</h3>

<p>The following output will be returned for each stratum and common value. There is no standard error.
</p>
<table role = "presentation">
<tr><td><code>odd1</code></td>
<td>
<p>odd from the first group, y1/(n1 - y1)</p>
</td></tr>
<tr><td><code>odd2</code></td>
<td>
<p>odd from the second group, y2/(n2 - y2)</p>
</td></tr>
<tr><td><code>OR</code></td>
<td>
<p>odds ratio, odd1/odd2. The point estimate of common OR is calculated with MN weight.</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>lower confidence limit of OR</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>upper confidence limit of OR</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>References</h3>

<p>Miettinen O, Nurminen M. Comparative analysis of two rates. Stat Med 1985;4:213-26
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RDmn1">RDmn1</a></code>, <code><a href="#topic+RRmn1">RRmn1</a></code>, <code><a href="#topic+ORmn1">ORmn1</a></code>, <code><a href="#topic+RDmn">RDmn</a></code>, <code><a href="#topic+RRmn">RRmn</a></code>, <code><a href="#topic+RDinv">RDinv</a></code>, <code><a href="#topic+RRinv">RRinv</a></code>, <code><a href="#topic+ORinv">ORinv</a></code>, <code><a href="#topic+ORcmh">ORcmh</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  d1 = matrix(c(25, 339, 28, 335, 23, 370, 40, 364), nrow=2, byrow=TRUE)
  colnames(d1) =  c("y1", "n1", "y2", "n2")
  ORmn(d1)
</code></pre>

<hr>
<h2 id='ORmn1'>Odds Ratio and Score CI of two groups without strata by the MN method</h2><span id='topic+ORmn1'></span>

<h3>Description</h3>

<p>Odds ratio and its score confidence interval of two groups without stratification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ORmn1(y1, n1, y2, n2, conf.level=0.95, eps=1e-8)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ORmn1_+3A_y1">y1</code></td>
<td>
<p>positive event count of test (the first) group</p>
</td></tr>
<tr><td><code id="ORmn1_+3A_n1">n1</code></td>
<td>
<p>total count of the test (the first) group</p>
</td></tr>
<tr><td><code id="ORmn1_+3A_y2">y2</code></td>
<td>
<p>positive event count of control (the second) group</p>
</td></tr>
<tr><td><code id="ORmn1_+3A_n2">n2</code></td>
<td>
<p>total count of control (the second) group</p>
</td></tr>
<tr><td><code id="ORmn1_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level</p>
</td></tr>
<tr><td><code id="ORmn1_+3A_eps">eps</code></td>
<td>
<p>absolute value less than eps is regarded as negligible</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>It calculates odds ratio and its score confidence interval of the two groups. The confidence interval is asymmetric, and there is no standard error in the output. This does not support stratification. This implementation uses uniroot function, which usually gives at least 5 significant digits. Whereas PropCIs::orscoreci function uses incremental or decremental search by the factor of 1.001 which gives only less than 3 significant digits.
</p>


<h3>Value</h3>

<p>There is no standard error.
</p>
<table role = "presentation">
<tr><td><code>odd1</code></td>
<td>
<p>odd from the first group, y1/(n1 - y1)</p>
</td></tr>
<tr><td><code>odd2</code></td>
<td>
<p>odd from the second group, y2/(n2 - y2)</p>
</td></tr>
<tr><td><code>OR</code></td>
<td>
<p>odds ratio, odd1/odd2</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>lower confidence limit of OR</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>upper confidence limit of OR</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>References</h3>

<p>Miettinen O, Nurminen M. Comparative analysis of two rates. Stat Med 1985;4:213-26
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RDmn1">RDmn1</a></code>, <code><a href="#topic+RRmn1">RRmn1</a></code>, <code><a href="#topic+RDmn">RDmn</a></code>, <code><a href="#topic+RRmn">RRmn</a></code>, <code><a href="#topic+ORmn">ORmn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ORmn1(104, 11037, 189, 11034)
</code></pre>

<hr>
<h2 id='pB'>Plot Confidence and Prediction Bands for Simple Linear Regression</h2><span id='topic+pB'></span>

<h3>Description</h3>

<p>It plots bands of the confidence interval and prediction interval for simple linear regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  pB(Formula, Data, Resol=300, conf.level=0.95, lx, ly, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pB_+3A_formula">Formula</code></td>
<td>
<p>a formula</p>
</td></tr>
<tr><td><code id="pB_+3A_data">Data</code></td>
<td>
<p>a data.frame</p>
</td></tr>
<tr><td><code id="pB_+3A_resol">Resol</code></td>
<td>
<p>resolution for the output</p>
</td></tr>
<tr><td><code id="pB_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level</p>
</td></tr>
<tr><td><code id="pB_+3A_lx">lx</code></td>
<td>
<p>x position of legend</p>
</td></tr>
<tr><td><code id="pB_+3A_ly">ly</code></td>
<td>
<p>y position of legend</p>
</td></tr>
<tr><td><code id="pB_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code>plot</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>It plots. Discard return values. If <code>lx</code> or <code>ly</code> is missing, the legend position is calculated automatically.
</p>


<h3>Value</h3>

<p>Ignore return values.
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>Examples</h3>

<pre><code class='language-R'>  pB(hp ~ disp, mtcars)
  pB(mpg ~ disp, mtcars)
</code></pre>

<hr>
<h2 id='Pcor.test'>Partial Correlation test of multiple columns</h2><span id='topic+Pcor.test'></span>

<h3>Description</h3>

<p>Testing partial correlation between many columns of data with Pearson method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Pcor.test(Data, x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Pcor.test_+3A_data">Data</code></td>
<td>
<p>a numeric matrix or data.frame</p>
</td></tr>
<tr><td><code id="Pcor.test_+3A_x">x</code></td>
<td>
<p>names of columns to be tested</p>
</td></tr>
<tr><td><code id="Pcor.test_+3A_y">y</code></td>
<td>
<p>names of control columns</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It performs multiple partial correlation test. It uses &quot;complete.obs&quot; rows of x and y columns.
</p>


<h3>Value</h3>

<p>Row names show which columns are used for the test
</p>
<table role = "presentation">
<tr><td><code>Estimate</code></td>
<td>
<p>point estimate of correlation</p>
</td></tr>
<tr><td><code>Df</code></td>
<td>
<p>degree of freedom</p>
</td></tr>
<tr><td><code>t value</code></td>
<td>
<p>t value of the t distribution</p>
</td></tr>
<tr><td><code>Pr(&gt;|t|)</code></td>
<td>
<p>probability with the t distribution</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>Examples</h3>

<pre><code class='language-R'>Pcor.test(mtcars, c("mpg", "hp", "qsec"), c("drat", "wt"))
</code></pre>

<hr>
<h2 id='pD'>Diagnostic Plot for Regression</h2><span id='topic+pD'></span>

<h3>Description</h3>

<p>Four standard diagnostic plots for regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  pD(rx, Title=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pD_+3A_rx">rx</code></td>
<td>
<p>a result of lm, which can give <code>fitted</code>, <code>residuals</code>, and <code>rstandard</code>.</p>
</td></tr>
<tr><td><code id="pD_+3A_title">Title</code></td>
<td>
<p>title to be printed on the plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most frequently used diagnostic plots are 'observed vs. fitted', 'standardized residual vs. fitted', 'distribution plot of standard residuals', and 'Q-Q plot of standardized residuals'.
</p>


<h3>Value</h3>

<p>Four diagnostic plots in a page.
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>Examples</h3>

<pre><code class='language-R'>  pD(lm(uptake ~ Plant + Type + Treatment + conc, CO2), "Diagnostic Plot")
</code></pre>

<hr>
<h2 id='PDIFF'>Pairwise Difference</h2><span id='topic+PDIFF'></span>

<h3>Description</h3>

<p>Estimates pairwise differences by a common method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  PDIFF(Formula, Data, Term, conf.level=0.95, adj="lsd", ref, PLOT=FALSE, 
        reverse=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PDIFF_+3A_formula">Formula</code></td>
<td>
<p>a conventional formula for a linear model</p>
</td></tr>
<tr><td><code id="PDIFF_+3A_data">Data</code></td>
<td>
<p>a <code>data.frame</code> to be analyzed</p>
</td></tr>
<tr><td><code id="PDIFF_+3A_term">Term</code></td>
<td>
<p>a factor name to be estimated</p>
</td></tr>
<tr><td><code id="PDIFF_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level of confidence interval</p>
</td></tr>
<tr><td><code id="PDIFF_+3A_adj">adj</code></td>
<td>
<p>&quot;lsd&quot;, &quot;tukey&quot;, &quot;scheffe&quot;, &quot;bon&quot;, &quot;duncan&quot;, or &quot;dunnett&quot; to adjust p-value and confidence limit</p>
</td></tr>
<tr><td><code id="PDIFF_+3A_ref">ref</code></td>
<td>
<p>reference or control level for Dunnett test</p>
</td></tr>
<tr><td><code id="PDIFF_+3A_plot">PLOT</code></td>
<td>
<p>whether to plot or not the diffogram</p>
</td></tr>
<tr><td><code id="PDIFF_+3A_reverse">reverse</code></td>
<td>
<p>reverse A - B to B - A</p>
</td></tr>
<tr><td><code id="PDIFF_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code>plot</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>It corresponds to PDIFF option of SAS PROC GLM.
</p>


<h3>Value</h3>

<p>Returns a table of expectations, t values and p-values. Output columns may vary according to the adjustment option.
</p>
<table role = "presentation">
<tr><td><code>Estimate</code></td>
<td>
<p>point estimate of the input linear contrast</p>
</td></tr>
<tr><td><code>Lower CL</code></td>
<td>
<p>lower confidence limit</p>
</td></tr>
<tr><td><code>Upper CL</code></td>
<td>
<p>upper confidence limit</p>
</td></tr>
<tr><td><code>Std. Error</code></td>
<td>
<p>standard error of the point estimate</p>
</td></tr>
<tr><td><code>t value</code></td>
<td>
<p>value for t distribution</p>
</td></tr>
<tr><td><code>Df</code></td>
<td>
<p>degree of freedom</p>
</td></tr>
<tr><td><code>Pr(&gt;|t|)</code></td>
<td>
<p>probability of larger than absolute t value from t distribution with residual's degree of freedom</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>See Also</h3>

<p><code><a href="#topic+LSM">LSM</a></code>, <code><a href="#topic+Diffogram">Diffogram</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  PDIFF(uptake ~ Type*Treatment + as.factor(conc), CO2, "as.factor(conc)")
  PDIFF(uptake ~ Type*Treatment + as.factor(conc), CO2, "as.factor(conc)", adj="tukey")
</code></pre>

<hr>
<h2 id='PocockBound'>Pocock (fixed) Bound for the cumulative Z-test with a final target alpha-value</h2><span id='topic+PocockBound'></span>

<h3>Description</h3>

<p>Cumulative alpha values with cumulative hypothesis test with a fixed upper bound z-value in group sequential design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  PocockBound(K=2, alpha=0.05, side=2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PocockBound_+3A_k">K</code></td>
<td>
<p>total number of tests</p>
</td></tr>
<tr><td><code id="PocockBound_+3A_alpha">alpha</code></td>
<td>
<p>alpha value at the final test</p>
</td></tr>
<tr><td><code id="PocockBound_+3A_side">side</code></td>
<td>
<p>1=one-side test, 2=two-side test</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Pocock suggested a fixed upper bound z-value for the cumulative hypothesis test in group sequential designs.
</p>


<h3>Value</h3>

<p>a fixed upper bound z-value for the K times repated hypothesis test with a final alpha-value.
Attributes are;
</p>
<table role = "presentation">
<tr><td><code>ti</code></td>
<td>
<p>time of test, Even-interval is assumed.</p>
</td></tr>
<tr><td><code>cum.alpha</code></td>
<td>
<p>cumulative alpha valued</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>References</h3>

<p>Reboussin DM, DeMets DL, Kim K, Lan KKG. Computations for group sequential boundaries using the Lan-DeMets function method. Controlled Clinical Trials. 2000;21:190-207.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  PocockBound(K=2) # Z-value of upper bound for the two-stage design
</code></pre>

<hr>
<h2 id='pResD'>Residual Diagnostic Plot for Regression</h2><span id='topic+pResD'></span>

<h3>Description</h3>

<p>Nine residual diagnostics plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  pResD(rx, Title=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pResD_+3A_rx">rx</code></td>
<td>
<p>a result of lm, which can give <code>fitted</code>, <code>residuals</code>, and <code>rstandard</code>.</p>
</td></tr>
<tr><td><code id="pResD_+3A_title">Title</code></td>
<td>
<p>title to be printed on the plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>SAS-style residual diagnostic plots.
</p>


<h3>Value</h3>

<p>Nine residual diagnostic plots in a page.
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>Examples</h3>

<pre><code class='language-R'>  pResD(lm(uptake ~ Plant + Type + Treatment + conc, CO2), "Residual Diagnostic Plot")
</code></pre>

<hr>
<h2 id='QuartileRange'>Inter-Quartile Range</h2><span id='topic+QuartileRange'></span>

<h3>Description</h3>

<p>Interquartile range (Q3 - Q1) with a conventional formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  QuartileRange(y, Type=2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="QuartileRange_+3A_y">y</code></td>
<td>
<p>a vector of numerics</p>
</td></tr>
<tr><td><code id="QuartileRange_+3A_type">Type</code></td>
<td>
<p>a type specifier to be passed to <code>IQR</code> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It removes <code>NA</code> in the input vector. Type 2 is SAS default, while Type 6 is SPSS default.
</p>


<h3>Value</h3>

<p>The value of an interquartile range
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>

<hr>
<h2 id='Range'>Range</h2><span id='topic+Range'></span>

<h3>Description</h3>

<p>The range, maximum - minimum, as a scalar value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Range(y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Range_+3A_y">y</code></td>
<td>
<p>a vector of numerics</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It removes <code>NA</code> in the input vector. 
</p>


<h3>Value</h3>

<p>A scalar value of a range
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>

<hr>
<h2 id='RanTest'>Test with Random Effects</h2><span id='topic+RanTest'></span>

<h3>Description</h3>

<p>Hypothesis test of with specified type SS using random effects as error terms. This corresponds to SAS PROC GLM's RANDOM /TEST clause.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  RanTest(Formula, Data, Random="", Type=3, eps=1e-8)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RanTest_+3A_formula">Formula</code></td>
<td>
<p>a conventional formula for a linear model</p>
</td></tr>
<tr><td><code id="RanTest_+3A_data">Data</code></td>
<td>
<p>a <code>data.frame</code> to be analyzed</p>
</td></tr>
<tr><td><code id="RanTest_+3A_random">Random</code></td>
<td>
<p>a vector of random effects. All should be specified as primary terms, not as interaction terms. All interaction terms with random factor are regarded as random effects.</p>
</td></tr>
<tr><td><code id="RanTest_+3A_type">Type</code></td>
<td>
<p>Sum of square type to be used as contrast</p>
</td></tr>
<tr><td><code id="RanTest_+3A_eps">eps</code></td>
<td>
<p>Less than this value is considered as zero.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Type can be from 1 to 3. All interaction terms with random factor are regarded as random effects.
Here the error term should not be MSE.
</p>


<h3>Value</h3>

<p>Returns ANOVA and E(MS) tables with specified type SS.
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>Examples</h3>

<pre><code class='language-R'>  RanTest(log(CMAX) ~ SEQ/SUBJ + PRD + TRT, BEdata, Random="SUBJ")
  fBE = log(CMAX) ~ ADM/SEQ/SUBJ + PRD + TRT
  RanTest(fBE, BEdata, Random=c("ADM", "SUBJ"))
  RanTest(fBE, BEdata, Random=c("ADM", "SUBJ"), Type=2)
  RanTest(fBE, BEdata, Random=c("ADM", "SUBJ"), Type=1)
</code></pre>

<hr>
<h2 id='RD'>Risk Difference between two groups</h2><span id='topic+RD'></span>

<h3>Description</h3>

<p>Risk (proportion) difference between two groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  RD(y1, n1, y2, n2, conf.level=0.95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RD_+3A_y1">y1</code></td>
<td>
<p>positive event count of test (the first) group</p>
</td></tr>
<tr><td><code id="RD_+3A_n1">n1</code></td>
<td>
<p>total count of the test (the first) group</p>
</td></tr>
<tr><td><code id="RD_+3A_y2">y2</code></td>
<td>
<p>positive event count of control (the second) group</p>
</td></tr>
<tr><td><code id="RD_+3A_n2">n2</code></td>
<td>
<p>total count of control (the second) group</p>
</td></tr>
<tr><td><code id="RD_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It calculates risk difference between the two groups. No continuity correction here. If you need percent scale, multiply the output by 100.
</p>


<h3>Value</h3>

<p>The result is a data.frame.
</p>
<table role = "presentation">
<tr><td><code>p1</code></td>
<td>
<p>proportion from the first group</p>
</td></tr>
<tr><td><code>p2</code></td>
<td>
<p>proportion from the second group</p>
</td></tr>
<tr><td><code>RD</code></td>
<td>
<p>risk difference, p1 - p2</p>
</td></tr>
<tr><td><code>SE</code></td>
<td>
<p>standard error of RD</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>lower confidence limit of RD</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>upper confidence limit of RD</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>See Also</h3>

<p><code><a href="#topic+RR">RR</a></code>, <code><a href="#topic+OR">OR</a></code>, <code><a href="#topic+RDmn1">RDmn1</a></code>, <code><a href="#topic+RRmn1">RRmn1</a></code>, <code><a href="#topic+ORmn1">ORmn1</a></code>, <code><a href="#topic+RDmn">RDmn</a></code>, <code><a href="#topic+RRmn">RRmn</a></code>, <code><a href="#topic+ORmn">ORmn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  RD(104, 11037, 189, 11034) # no continuity correction
</code></pre>

<hr>
<h2 id='RDinv'>Risk Difference between two groups with strata by inverse variance method</h2><span id='topic+RDinv'></span>

<h3>Description</h3>

<p>Risk difference and its score confidence interval between two groups with stratification by inverse variance method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  RDinv(d0, conf.level=0.95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RDinv_+3A_d0">d0</code></td>
<td>
<p>A data.frame or matrix, of which each row means a stratum. This should have four columns named y1, n1, y2, and n2; y1 and y2 for events of each group, n1 and n2 for the sample size of each stratum. The second group is usually the control group.</p>
</td></tr>
<tr><td><code id="RDinv_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It calculates risk difference and its confidence interval between two groups by inverse variance method. If you need percent scale, multiply the output by 100. This supports stratification. This can be used for meta-analysis also.
</p>


<h3>Value</h3>

<p>The following output will be returned for each stratum and common value. There is no standard error.
</p>
<table role = "presentation">
<tr><td><code>p1</code></td>
<td>
<p>proportion from the first group, y1/n1</p>
</td></tr>
<tr><td><code>p2</code></td>
<td>
<p>proportion from the second group, y2/n2</p>
</td></tr>
<tr><td><code>RD</code></td>
<td>
<p>risk difference, p1 - p2. The point estimate of common RD is calculated with MH weight.</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>lower confidence limit of RD</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>upper confidence limit of RD</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>See Also</h3>

<p><code><a href="#topic+RDmn1">RDmn1</a></code>, <code><a href="#topic+RRmn1">RRmn1</a></code>, <code><a href="#topic+ORmn1">ORmn1</a></code>, <code><a href="#topic+RDmn">RDmn</a></code>, <code><a href="#topic+RRmn">RRmn</a></code>, <code><a href="#topic+ORmn">ORmn</a></code>, <code><a href="#topic+RRinv">RRinv</a></code>, <code><a href="#topic+ORinv">ORinv</a></code>, <code><a href="#topic+ORcmh">ORcmh</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  d1 = matrix(c(25, 339, 28, 335, 23, 370, 40, 364), nrow=2, byrow=TRUE)
  colnames(d1) =  c("y1", "n1", "y2", "n2")
  RDinv(d1)
</code></pre>

<hr>
<h2 id='RDmn'>Risk Difference and Score CI between two groups with strata by the MN method</h2><span id='topic+RDmn'></span>

<h3>Description</h3>

<p>Risk difference and its score confidence interval between two groups with stratification by the Miettinen and Nurminen method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  RDmn(d0, conf.level=0.95, eps=1e-8)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RDmn_+3A_d0">d0</code></td>
<td>
<p>A data.frame or matrix, of which each row means a stratum. This should have four columns named y1, n1, y2, and n2; y1 and y2 for events of each group, n1 and n2 for sample size of each stratum. The second group is usually the control group. Maximum allowable value for n1 and n2 is 1e8.</p>
</td></tr>
<tr><td><code id="RDmn_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level</p>
</td></tr>
<tr><td><code id="RDmn_+3A_eps">eps</code></td>
<td>
<p>absolute value less than eps is regarded as negligible</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It calculates risk difference and its score confidence interval between the two groups. The confidence interval is asymmetric, and there is no standard error in the output. If you need percent scale, multiply the output by 100. This supports stratification. This implementation uses uniroot function which usually gives at least 5 significant digits. This can be used for meta-analysis also.
</p>


<h3>Value</h3>

<p>The following output will be returned for each stratum and common value. There is no standard error.
</p>
<table role = "presentation">
<tr><td><code>p1</code></td>
<td>
<p>proportion from the first group, y1/n1</p>
</td></tr>
<tr><td><code>p2</code></td>
<td>
<p>proportion from the second group, y2/n2</p>
</td></tr>
<tr><td><code>RD</code></td>
<td>
<p>risk difference, p1 - p2. The point estimate of common RD is calculated with MN weight.</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>lower confidence limit of RD</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>upper confidence limit of RD</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>References</h3>

<p>Miettinen O, Nurminen M. Comparative analysis of two rates. Stat Med 1985;4:213-26
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RDmn1">RDmn1</a></code>, <code><a href="#topic+RRmn1">RRmn1</a></code>, <code><a href="#topic+ORmn1">ORmn1</a></code>, <code><a href="#topic+RRmn">RRmn</a></code>, <code><a href="#topic+ORmn">ORmn</a></code>, <code><a href="#topic+RDinv">RDinv</a></code>, <code><a href="#topic+RRinv">RRinv</a></code>, <code><a href="#topic+ORinv">ORinv</a></code>, <code><a href="#topic+ORcmh">ORcmh</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  d1 = matrix(c(25, 339, 28, 335, 23, 370, 40, 364), nrow=2, byrow=TRUE)
  colnames(d1) =  c("y1", "n1", "y2", "n2")
  RDmn(d1)
</code></pre>

<hr>
<h2 id='RDmn1'>Risk Difference and Score CI between two groups without strata by the MN method</h2><span id='topic+RDmn1'></span>

<h3>Description</h3>

<p>Risk difference and its score confidence interval between two groups without stratification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  RDmn1(y1, n1, y2, n2, conf.level=0.95, eps=1e-8)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RDmn1_+3A_y1">y1</code></td>
<td>
<p>positive event count of test (the first) group</p>
</td></tr>
<tr><td><code id="RDmn1_+3A_n1">n1</code></td>
<td>
<p>total count of the test (the first) group. Maximum allowable value is 1e8.</p>
</td></tr>
<tr><td><code id="RDmn1_+3A_y2">y2</code></td>
<td>
<p>positive event count of control (the second) group</p>
</td></tr>
<tr><td><code id="RDmn1_+3A_n2">n2</code></td>
<td>
<p>total count of control (the second) group. Maximum allowable value is 1e8.</p>
</td></tr>
<tr><td><code id="RDmn1_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level</p>
</td></tr>
<tr><td><code id="RDmn1_+3A_eps">eps</code></td>
<td>
<p>absolute value less than eps is regarded as negligible</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>It calculates risk difference and its score confidence interval between the two groups. The confidence interval is asymmetric, and there is no standard error in the output. If you need percent scale, multiply the output by 100. This does not support stratification. This implementation uses uniroot function which usually gives at least 5 significant digits.
</p>


<h3>Value</h3>

<p>There is no standard error.
</p>
<table role = "presentation">
<tr><td><code>p1</code></td>
<td>
<p>proportion from the first group, y1/n1</p>
</td></tr>
<tr><td><code>p2</code></td>
<td>
<p>proportion from the second group, y2/n2</p>
</td></tr>
<tr><td><code>RD</code></td>
<td>
<p>risk difference, p1 - p2</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>lower confidence limit of RD</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>upper confidence limit of RD</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>References</h3>

<p>Miettinen O, Nurminen M. Comparative analysis of two rates. Stat Med 1985;4:213-26
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RRmn1">RRmn1</a></code>, <code><a href="#topic+ORmn1">ORmn1</a></code>, <code><a href="#topic+RDmn">RDmn</a></code>, <code><a href="#topic+RRmn">RRmn</a></code>, <code><a href="#topic+ORmn">ORmn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  RDmn1(104, 11037, 189, 11034)
</code></pre>

<hr>
<h2 id='REG'>Regression of Linear Least Square, similar to SAS PROC REG</h2><span id='topic+REG'></span>

<h3>Description</h3>

<p>REG is similar to SAS PROC REG.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  REG(Formula, Data, conf.level=0.95, HC=FALSE, Resid=FALSE, Weights=1,
      summarize=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="REG_+3A_formula">Formula</code></td>
<td>
<p>a conventional formula for a linear model</p>
</td></tr>
<tr><td><code id="REG_+3A_data">Data</code></td>
<td>
<p>a <code>data.frame</code> to be analyzed</p>
</td></tr>
<tr><td><code id="REG_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level for the confidence limit</p>
</td></tr>
<tr><td><code id="REG_+3A_hc">HC</code></td>
<td>
<p>heteroscedasticity related output is required such as HC0, HC3, White's first and second moment specification test</p>
</td></tr>
<tr><td><code id="REG_+3A_resid">Resid</code></td>
<td>
<p>if <code>TRUE</code>, fitted values (y hat) and residuals will be returned</p>
</td></tr>
<tr><td><code id="REG_+3A_weights">Weights</code></td>
<td>
<p>weights for each observation or residual square. This is usually the inverse of each variance.</p>
</td></tr>
<tr><td><code id="REG_+3A_summarize">summarize</code></td>
<td>
<p>If this is <code>FALSE</code>, <code>REG</code> returns just <code>lfit</code> result.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It performs the core function of SAS PROC REG.
</p>


<h3>Value</h3>

<p>The result is comparable to that of SAS PROC REG.
</p>
<p>The first part is ANOVA table.
</p>
<p>The second part is measures about fitness.
</p>
<p>The third part is the estimates of coefficients.
</p>
<table role = "presentation">
<tr><td><code>Estimate</code></td>
<td>
<p>point estimate of parameters, coefficients</p>
</td></tr>
<tr><td><code>Estimable</code></td>
<td>
<p>estimability: 1=TRUE, 0=FALSE. This appears only when at least one inestimability occurs.</p>
</td></tr>
<tr><td><code>Std. Error</code></td>
<td>
<p>standard error of the point estimate</p>
</td></tr>
<tr><td><code>Lower CL</code></td>
<td>
<p>lower confidence limit with conf.level</p>
</td></tr>
<tr><td><code>Upper CL</code></td>
<td>
<p>lower confidence limit with conf.level</p>
</td></tr>
<tr><td><code>Df</code></td>
<td>
<p>degree of freedom</p>
</td></tr>
<tr><td><code>t value</code></td>
<td>
<p>value for t distribution</p>
</td></tr>
<tr><td><code>Pr(&gt;|t|)</code></td>
<td>
<p>probability of larger than absolute t value from t distribution with residual's degree of freedom</p>
</td></tr>
</table>
<p>The above result is repeated using HC0 and HC3, with following White's first and second moment specification test, if HC option is specified.
The t values and their p values with HC1 and HC2 are between those of HC0 and H3.
</p>
<table role = "presentation">
<tr><td><code>Fitted</code></td>
<td>
<p>Fitted value or y hat. This is returned only with Resid=TRUE option.</p>
</td></tr>
<tr><td><code>Residual</code></td>
<td>
<p>Weighted residuals. This is returned only with Resid=TRUE option.</p>
</td></tr>
</table>
<p>If <code>summarize=FALSE</code>, <code>REG</code> returns;
</p>
<table role = "presentation">
<tr><td><code>coeffcients</code></td>
<td>
<p>beta coefficients</p>
</td></tr>
<tr><td><code>g2</code></td>
<td>
<p>g2 inverse</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>rank of the model matrix</p>
</td></tr>
<tr><td><code>DFr</code></td>
<td>
<p>degree of freedom for the residual</p>
</td></tr>
<tr><td><code>SSE</code></td>
<td>
<p>sum of square error</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>See Also</h3>

<p><code><a href="#topic+lr">lr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  REG(uptake ~ Plant + Type + Treatment + conc, CO2)
  REG(uptake ~ conc, CO2, HC=TRUE)
  REG(uptake ~ conc, CO2, Resid=TRUE)
  REG(uptake ~ conc, CO2, HC=TRUE, Resid=TRUE)
  REG(uptake ~ conc, CO2, summarize=FALSE)
</code></pre>

<hr>
<h2 id='regD'>Regression of Conventional Way with Rich Diagnostics</h2><span id='topic+regD'></span>

<h3>Description</h3>

<p><code>regD</code> provides rich diagnostics such as student residual, leverage(hat), Cook's D, studentized deleted residual, DFFITS, and DFBETAS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regD(Formula, Data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="regD_+3A_formula">Formula</code></td>
<td>
<p>a conventional formula for a linear model</p>
</td></tr>
<tr><td><code id="regD_+3A_data">Data</code></td>
<td>
<p>a <code>data.frame</code> to be analyzed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It performs the conventional regression analysis. This does not use g2 inverse, therefore it cannot handle a singular matrix. If the model(design) matrix is not full rank, use <code>REG</code> or fewer parameters.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Coefficients</code></td>
<td>
<p>conventional coefficients summary with Wald statistics</p>
</td></tr>
<tr><td><code>Diagnostics</code></td>
<td>
<p>Diagnostics table for detecting outlier or influential/leverage points. This includes fitted (Predicted), residual (Residual), standard error of residual(se_resid), studentized residual(RStudent), hat(Leverage), Cook's D, studentized deleted residual(sdResid), DIFFITS, and COVRATIO.</p>
</td></tr>
<tr><td><code>DFBETAS</code></td>
<td>
<p>Column names are the names of coefficients. Each row shows how much each coefficient is affected by deleting the corressponding row of observation.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>Examples</h3>

<pre><code class='language-R'>  regD(uptake ~ conc, CO2)
</code></pre>

<hr>
<h2 id='RR'>Relative Risk of the two groups</h2><span id='topic+RR'></span>

<h3>Description</h3>

<p>Relative Risk between the two groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  RR(y1, n1, y2, n2, conf.level=0.95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RR_+3A_y1">y1</code></td>
<td>
<p>positive event count of test (the first) group</p>
</td></tr>
<tr><td><code id="RR_+3A_n1">n1</code></td>
<td>
<p>total count of the test (the first) group</p>
</td></tr>
<tr><td><code id="RR_+3A_y2">y2</code></td>
<td>
<p>positive event count of control (the second) group</p>
</td></tr>
<tr><td><code id="RR_+3A_n2">n2</code></td>
<td>
<p>total count of control (the second) group</p>
</td></tr>
<tr><td><code id="RR_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It calculates relative risk of the two groups. No continuity correction here. If you need percent scale, multiply the output by 100.
</p>


<h3>Value</h3>

<p>The result is a data.frame.
</p>
<table role = "presentation">
<tr><td><code>p1</code></td>
<td>
<p>proportion from the first group</p>
</td></tr>
<tr><td><code>p2</code></td>
<td>
<p>proportion from the second group</p>
</td></tr>
<tr><td><code>RR</code></td>
<td>
<p>relative risk, p1/p2</p>
</td></tr>
<tr><td><code>SElog</code></td>
<td>
<p>standard error of log(RR)</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>lower confidence limit of RR</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>upper confidence limit of RR</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>See Also</h3>

<p><code><a href="#topic+RD">RD</a></code>, <code><a href="#topic+OR">OR</a></code>, <code><a href="#topic+RDmn1">RDmn1</a></code>, <code><a href="#topic+RRmn1">RRmn1</a></code>, <code><a href="#topic+ORmn1">ORmn1</a></code>, <code><a href="#topic+RDmn">RDmn</a></code>, <code><a href="#topic+RRmn">RRmn</a></code>, <code><a href="#topic+ORmn">ORmn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  RR(104, 11037, 189, 11034) # no continuity correction
</code></pre>

<hr>
<h2 id='RRinv'>Relative Risk of two groups with strata by inverse variance method</h2><span id='topic+RRinv'></span>

<h3>Description</h3>

<p>Relative risk and its score confidence interval of two groups with stratification by inverse variance method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  RRinv(d0, conf.level=0.95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RRinv_+3A_d0">d0</code></td>
<td>
<p>A data.frame or matrix, of which each row means a stratum. This should have four columns named y1, n1, y2, and n2; y1 and y2 for events of each group, n1 and n2 for sample size of each stratum. The second group is usually the control group.</p>
</td></tr>
<tr><td><code id="RRinv_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It calculates relative risk and its confidence interval of two groups by inverse variance method. This supports stratification. This can be used for meta-analysis also.
</p>


<h3>Value</h3>

<p>The following output will be returned for each stratum and common value. There is no standard error.
</p>
<table role = "presentation">
<tr><td><code>p1</code></td>
<td>
<p>proportion from the first group, y1/n1</p>
</td></tr>
<tr><td><code>p2</code></td>
<td>
<p>proportion from the second group, y2/n2</p>
</td></tr>
<tr><td><code>RR</code></td>
<td>
<p>relative risk, p1/p2. The point estimate of common RR is calculated with MH weight.</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>lower confidence limit of RR</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>upper confidence limit of RR</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>See Also</h3>

<p><code><a href="#topic+RDmn1">RDmn1</a></code>, <code><a href="#topic+RRmn1">RRmn1</a></code>, <code><a href="#topic+ORmn1">ORmn1</a></code>, <code><a href="#topic+RDmn">RDmn</a></code>, <code><a href="#topic+RRmn">RRmn</a></code>, <code><a href="#topic+ORmn">ORmn</a></code>, <code><a href="#topic+RDinv">RDinv</a></code>, <code><a href="#topic+ORinv">ORinv</a></code>, <code><a href="#topic+ORcmh">ORcmh</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  d1 = matrix(c(25, 339, 28, 335, 23, 370, 40, 364), nrow=2, byrow=TRUE)
  colnames(d1) =  c("y1", "n1", "y2", "n2")
  RRinv(d1)
</code></pre>

<hr>
<h2 id='RRmn'>Relative Risk and Score CI of two groups with strata by the MN method</h2><span id='topic+RRmn'></span>

<h3>Description</h3>

<p>Relative risk and its score confidence interval of two groups with stratification by the Miettinen and Nurminen method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  RRmn(d0, conf.level=0.95, eps=1e-8)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RRmn_+3A_d0">d0</code></td>
<td>
<p>A data.frame or matrix, of which each row means a strata. This should have four columns named y1, n1, y2, and n2; y1 and y2 for events of each group, n1 and n2 for sample size of each stratum. The second group is usually the control group.</p>
</td></tr>
<tr><td><code id="RRmn_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level</p>
</td></tr>
<tr><td><code id="RRmn_+3A_eps">eps</code></td>
<td>
<p>absolute value less than eps is regarded as negligible</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It calculates relative risk and its score confidence interval of the two groups. The confidence interval is asymmetric, and there is no standard error in the output. This supports stratification. This implementation uses uniroot function, which usually gives at least 5 significant digits. Whereas PropCIs::riskscoreci function uses cubic equation approximation which gives only about 2 significant digits. This can be used for meta-analysis also.
</p>


<h3>Value</h3>

<p>The following output will be returned for each strata and common value. There is no standard error.
</p>
<table role = "presentation">
<tr><td><code>p1</code></td>
<td>
<p>proportion from the first group, y1/n1</p>
</td></tr>
<tr><td><code>p2</code></td>
<td>
<p>proportion from the second group, y2/n2</p>
</td></tr>
<tr><td><code>RR</code></td>
<td>
<p>relative risk, p1/p2. Point estimate of common RR is calculated with MN weight.</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>lower confidence limit of RR</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>upper confidence limit of RR</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>References</h3>

<p>Miettinen O, Nurminen M. Comparative analysis of two rates. Stat Med 1985;4:213-26
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RDmn1">RDmn1</a></code>, <code><a href="#topic+RRmn1">RRmn1</a></code>, <code><a href="#topic+ORmn1">ORmn1</a></code>, <code><a href="#topic+RDmn">RDmn</a></code>, <code><a href="#topic+ORmn">ORmn</a></code>, <code><a href="#topic+RDinv">RDinv</a></code>, <code><a href="#topic+RRinv">RRinv</a></code>, <code><a href="#topic+ORinv">ORinv</a></code>, <code><a href="#topic+ORcmh">ORcmh</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  d1 = matrix(c(25, 339, 28, 335, 23, 370, 40, 364), nrow=2, byrow=TRUE)
  colnames(d1) =  c("y1", "n1", "y2", "n2")
  RRmn(d1)
</code></pre>

<hr>
<h2 id='RRmn1'>Relative Risk and Score CI of two groups without strata by by MN method</h2><span id='topic+RRmn1'></span>

<h3>Description</h3>

<p>Relative risk and its score confidence interval of the two groups without stratification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  RRmn1(y1, n1, y2, n2, conf.level=0.95, eps=1e-8)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RRmn1_+3A_y1">y1</code></td>
<td>
<p>positive event count of test (the first) group</p>
</td></tr>
<tr><td><code id="RRmn1_+3A_n1">n1</code></td>
<td>
<p>total count of the test (the first) group</p>
</td></tr>
<tr><td><code id="RRmn1_+3A_y2">y2</code></td>
<td>
<p>positive event count of control (the second) group</p>
</td></tr>
<tr><td><code id="RRmn1_+3A_n2">n2</code></td>
<td>
<p>total count of control (the second) group</p>
</td></tr>
<tr><td><code id="RRmn1_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level</p>
</td></tr>
<tr><td><code id="RRmn1_+3A_eps">eps</code></td>
<td>
<p>absolute value less than eps is regarded as negligible</p>
</td></tr>    
</table>


<h3>Details</h3>

<p>It calculates the relative risk and its score confidence interval of the two groups. The confidence interval is asymmetric, and there is no standard error in the output. This does not support stratification. This implementation uses uniroot function, which usually gives at least 5 significant digits. Whereas PropCIs::riskscoreci function uses cubic equation approximation which gives only about 2 significant digits.
</p>


<h3>Value</h3>

<p>There is no standard error.
</p>
<table role = "presentation">
<tr><td><code>p1</code></td>
<td>
<p>proportion from the first group, y1/n1</p>
</td></tr>
<tr><td><code>p2</code></td>
<td>
<p>proportion from the second group, y2/n2</p>
</td></tr>
<tr><td><code>RR</code></td>
<td>
<p>relative risk, p1/p2</p>
</td></tr>
<tr><td><code>lower</code></td>
<td>
<p>lower confidence limit of RR</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>upper confidence limit of RR</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>References</h3>

<p>Miettinen O, Nurminen M. Comparative analysis of two rates. Stat Med 1985;4:213-26
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RDmn1">RDmn1</a></code>, <code><a href="#topic+ORmn1">ORmn1</a></code>, <code><a href="#topic+RDmn">RDmn</a></code>, <code><a href="#topic+RRmn">RRmn</a></code>, <code><a href="#topic+ORmn">ORmn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  RRmn1(104, 11037, 189, 11034)
</code></pre>

<hr>
<h2 id='satt'>Satterthwaite Approximation of Variance and Degree of Freedom</h2><span id='topic+satt'></span>

<h3>Description</h3>

<p>Calculates pooled variance and degree of freedom using Satterthwaite equation. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  satt(vars, dfs, ws=c(1, 1)) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="satt_+3A_vars">vars</code></td>
<td>
<p>a vector of variances</p>
</td></tr>
<tr><td><code id="satt_+3A_dfs">dfs</code></td>
<td>
<p>a vector of degree of freedoms</p>
</td></tr>
<tr><td><code id="satt_+3A_ws">ws</code></td>
<td>
<p>a vector of weights</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input can be more than two variances.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Variance</code></td>
<td>
<p>approximated variance</p>
</td></tr>
<tr><td><code>Df</code></td>
<td>
<p>degree of freedom</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>

<hr>
<h2 id='ScoreCI'>Score Confidence Interval for a Proportion or a Binomial Distribution</h2><span id='topic+ScoreCI'></span>

<h3>Description</h3>

<p>Score confidence of a proportion in one group
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ScoreCI(y, n, conf.level=0.95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ScoreCI_+3A_y">y</code></td>
<td>
<p>positive event count of a group</p>
</td></tr>
<tr><td><code id="ScoreCI_+3A_n">n</code></td>
<td>
<p>total count of a group</p>
</td></tr>
<tr><td><code id="ScoreCI_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It calculates score confidence interval of a proportion in one group. The confidence interval is asymmetric and there is no standard error in the output. If you need percent scale, multiply the output by 100.
</p>


<h3>Value</h3>

<p>The result is a data.frame. There is no standard error.
</p>
<table role = "presentation">
<tr><td><code>PE</code></td>
<td>
<p>point estimation for the proportion</p>
</td></tr>
<tr><td><code>Lower</code></td>
<td>
<p>lower confidence limit of Prop</p>
</td></tr>
<tr><td><code>Upper</code></td>
<td>
<p>upper confidence limit of Prop</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+binom.test">binom.test</a></code>, <code><a href="stats.html#topic+prop.test">prop.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ScoreCI(104, 11037)
</code></pre>

<hr>
<h2 id='SD'>Standard Deviation</h2><span id='topic+SD'></span>

<h3>Description</h3>

<p>Standard deviation of a sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  SD(y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SD_+3A_y">y</code></td>
<td>
<p>a vector of numerics</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It removes <code>NA</code> in the input vector. The length of the vector should be larger than 1.
</p>


<h3>Value</h3>

<p>Sample standard deviation
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>

<hr>
<h2 id='SEM'>Standard Error of the Sample Mean</h2><span id='topic+SEM'></span>

<h3>Description</h3>

<p>The estimate of the standard error of the sample mean
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  SEM(y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SEM_+3A_y">y</code></td>
<td>
<p>a vector of numerics</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It removes <code>NA</code> in the input vector. 
</p>


<h3>Value</h3>

<p>The estimate of the standard error of the sample mean
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>

<hr>
<h2 id='seqBound'>Sequential bounds for cumulative Z-test in Group Sequential Design</h2><span id='topic+seqBound'></span>

<h3>Description</h3>

<p>Sequential upper bounds for cumulative Z-test on accumaltive data. Z values are correlated. This is usually used for group sequential design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  seqBound(ti, alpha = 0.05, side = 2, t2 = NULL, asf = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seqBound_+3A_ti">ti</code></td>
<td>
<p>times for test. These should be [0, 1].</p>
</td></tr>
<tr><td><code id="seqBound_+3A_alpha">alpha</code></td>
<td>
<p>goal alpha value for the last test at time 0.</p>
</td></tr>
<tr><td><code id="seqBound_+3A_side">side</code></td>
<td>
<p>1=one-side test, 2=two-side test</p>
</td></tr>
<tr><td><code id="seqBound_+3A_t2">t2</code></td>
<td>
<p>fractions of information amount. These should be [0, 1]. If not available, ti will be used instead.</p>
</td></tr>
<tr><td><code id="seqBound_+3A_asf">asf</code></td>
<td>
<p>alpha spending function. 1=O'Brien-Flemming, 2=Pocock, 3=alpha*ti, 4=alpha*ti^1.5, 5=alpha*ti^2</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It calculates upper z-bounds and cumulative alpha-values for the repeated test in group sequential design. The correlation is assumed to be sqrt(t_i/t_j).
</p>


<h3>Value</h3>

<p>The result is a matrix.
</p>
<table role = "presentation">
<tr><td><code>ti</code></td>
<td>
<p>time of test</p>
</td></tr>
<tr><td><code>bi</code></td>
<td>
<p>upper z-bound</p>
</td></tr>
<tr><td><code>cum.alpha</code></td>
<td>
<p>cumulative alpha-value</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>References</h3>

<p>Reboussin DM, DeMets DL, Kim K, Lan KKG. Computations for group sequential boundaries using the Lan-DeMets function method. Controlled Clinical Trials. 2000;21:190-207.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  seqBound(ti=(1:5)/5)
  seqBound(ti=(1:5)/5, asf=2)
</code></pre>

<hr>
<h2 id='seqCI'>Confidence interval with the last Z-value for the group sequential design</h2><span id='topic+seqCI'></span>

<h3>Description</h3>

<p>Confidence interval with given upper bounds, time of tests, the last Z-value, and confidence level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  seqCI(bi, ti, Zval, conf.level=0.95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seqCI_+3A_bi">bi</code></td>
<td>
<p>upper bound z-values</p>
</td></tr>
<tr><td><code id="seqCI_+3A_ti">ti</code></td>
<td>
<p>times for test. These should be [0, 1].</p>
</td></tr>
<tr><td><code id="seqCI_+3A_zval">Zval</code></td>
<td>
<p>the last z-value from the observed data. This is not necessarily the planned final Z-value.</p>
</td></tr>
<tr><td><code id="seqCI_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It calculates confidence interval with given upper bounds, time of tests, the last Z-value, and confidence level. It assumes two-side test. <code>mvtnorm::pmvt</code> (with noncentrality) is better than pmvnorm in calculating power, sample size, and confidence interval. But, Lan-DeMets used multi-variate normal rather than multi-variate noncentral t distributionh. This function followed Lan-DeMets for the consistency with previous results. For the theoretical background, see the reference.
</p>


<h3>Value</h3>

<p>confidence interval of Z-value for the given confidence level.
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>References</h3>

<p>Reboussin DM, DeMets DL, Kim K, Lan KKG. Computations for group sequential boundaries using the Lan-DeMets function method. Controlled Clinical Trials. 2000;21:190-207.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  seqCI(bi = c(2.53, 2.61, 2.57, 2.47, 2.43, 2.38), 
        ti = c(.2292, .3333, .4375, .5833, .7083, .8333), Zval=2.82)
</code></pre>

<hr>
<h2 id='Skewness'>Skewness</h2><span id='topic+Skewness'></span>

<h3>Description</h3>

<p>Skewness with a conventional formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  Skewness(y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Skewness_+3A_y">y</code></td>
<td>
<p>a vector of numerics</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It removes <code>NA</code> in the input vector. 
</p>


<h3>Value</h3>

<p>Estimate of skewness
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>See Also</h3>

<p><code><a href="#topic+SkewnessSE">SkewnessSE</a></code>
</p>

<hr>
<h2 id='SkewnessSE'>Standard Error of Skewness</h2><span id='topic+SkewnessSE'></span>

<h3>Description</h3>

<p>Standard errof of the skewness with a conventional formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  SkewnessSE(y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SkewnessSE_+3A_y">y</code></td>
<td>
<p>a vector of numerics</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It removes <code>NA</code> in the input vector. 
</p>


<h3>Value</h3>

<p>Standard error of the estimated skewness
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>See Also</h3>

<p><code><a href="#topic+Skewness">Skewness</a></code>
</p>

<hr>
<h2 id='SLICE'>F Test with Slice</h2><span id='topic+SLICE'></span>

<h3>Description</h3>

<p>Do F test with a given slice term.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  SLICE(Formula, Data, Term, By)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SLICE_+3A_formula">Formula</code></td>
<td>
<p>a conventional formula for a linear model</p>
</td></tr>
<tr><td><code id="SLICE_+3A_data">Data</code></td>
<td>
<p>a <code>data.frame</code> to be analyzed</p>
</td></tr>
<tr><td><code id="SLICE_+3A_term">Term</code></td>
<td>
<p>a factor name (not interaction) to calculate the sum of square and do F test with least square means</p>
</td></tr>
<tr><td><code id="SLICE_+3A_by">By</code></td>
<td>
<p>a factor name to be used for slice</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>It performs F test with a given slice term. It is similar to the SLICE option SAS PROC GLM.
</p>


<h3>Value</h3>

<p>Returns sum of square and its F value and p-value. Row names are the levels of the slice term.
</p>
<table role = "presentation">
<tr><td><code>Df</code></td>
<td>
<p>degree of freedom</p>
</td></tr>
<tr><td><code>Sum Sq</code></td>
<td>
<p>sum of square for the set of contrasts</p>
</td></tr>
<tr><td><code>Mean Sq</code></td>
<td>
<p>mean square</p>
</td></tr>
<tr><td><code>F value</code></td>
<td>
<p>F value for the F distribution</p>
</td></tr>
<tr><td><code>Pr(&gt;F)</code></td>
<td>
<p>proability of larger than F value</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>Examples</h3>

<pre><code class='language-R'>  SLICE(uptake ~ Type*Treatment, CO2, "Type", "Treatment") 
  SLICE(uptake ~ Type*Treatment, CO2, "Treatment", "Type") 
</code></pre>

<hr>
<h2 id='SS'>Sum of Square</h2><span id='topic+SS'></span>

<h3>Description</h3>

<p>Sum of squares with ANOVA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  SS(x, rx, L, eps=1e-8)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SS_+3A_x">x</code></td>
<td>
<p>a result of <code>ModelMatrix</code> containing design information</p>
</td></tr>
<tr><td><code id="SS_+3A_rx">rx</code></td>
<td>
<p>a result of <code>lfit</code></p>
</td></tr>
<tr><td><code id="SS_+3A_l">L</code></td>
<td>
<p>linear hypothesis, a full matrix matching the information in <code>x</code></p>
</td></tr>
<tr><td><code id="SS_+3A_eps">eps</code></td>
<td>
<p>Less than this value is considered as zero.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>It calculates sum of squares and completes the ANOVA table.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>ANOVA table</code></td>
<td>
<p>a classical ANOVA table without the residual(Error) part.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>See Also</h3>

<p><code><a href="#topic+ModelMatrix">ModelMatrix</a></code>,
<code><a href="#topic+lfit">lfit</a></code>
</p>

<hr>
<h2 id='T3MS'>Type III Expected Mean Square Formula</h2><span id='topic+T3MS'></span>

<h3>Description</h3>

<p>Calculates a formula table for expected mean square of Type III SS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  T3MS(Formula, Data, L0, eps=1e-8)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="T3MS_+3A_formula">Formula</code></td>
<td>
<p>a conventional formula for a linear model</p>
</td></tr>
<tr><td><code id="T3MS_+3A_data">Data</code></td>
<td>
<p>a <code>data.frame</code> to be analyzed</p>
</td></tr>
<tr><td><code id="T3MS_+3A_l0">L0</code></td>
<td>
<p>a matrix of row linear contrasts, if missed, <code>e3</code> is used</p>
</td></tr>
<tr><td><code id="T3MS_+3A_eps">eps</code></td>
<td>
<p>Less than this value is considered as zero.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is necessary for further hypothesis tests of nesting factors.
</p>


<h3>Value</h3>

<p>A coefficient matrix for Type III expected mean square
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>Examples</h3>

<pre><code class='language-R'>  T3MS(log(CMAX) ~ SEQ/SUBJ + PRD + TRT, BEdata)
</code></pre>

<hr>
<h2 id='T3test'>Test Type III SS using error term other than MSE</h2><span id='topic+T3test'></span>

<h3>Description</h3>

<p>Hypothesis test of Type III SS using an error term other than MSE. This corresponds to SAS PROC GLM's RANDOM /TEST clause.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  T3test(Formula, Data, H="", E="", eps=1e-8)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="T3test_+3A_formula">Formula</code></td>
<td>
<p>a conventional formula for a linear model</p>
</td></tr>
<tr><td><code id="T3test_+3A_data">Data</code></td>
<td>
<p>a <code>data.frame</code> to be analyzed</p>
</td></tr>
<tr><td><code id="T3test_+3A_h">H</code></td>
<td>
<p>Hypothesis term</p>
</td></tr>
<tr><td><code id="T3test_+3A_e">E</code></td>
<td>
<p>Error term</p>
</td></tr>
<tr><td><code id="T3test_+3A_eps">eps</code></td>
<td>
<p>Less than this value is considered as zero.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It tests a factor of type III SS using some other term as an error term.
Here the error term should not be MSE.
</p>


<h3>Value</h3>

<p>Returns one or more ANOVA table(s) of type III SS.
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>Examples</h3>

<pre><code class='language-R'>  T3test(log(CMAX) ~ SEQ/SUBJ + PRD + TRT, BEdata, E=c("SEQ:SUBJ"))
  T3test(log(CMAX) ~ SEQ/SUBJ + PRD + TRT, BEdata, H="SEQ", E=c("SEQ:SUBJ"))
</code></pre>

<hr>
<h2 id='tmtest'>Independent two means test similar to t.test with summarized input</h2><span id='topic+tmtest'></span>

<h3>Description</h3>

<p>This produces essentially the same to t.test except using summarized input (sufficient statistics).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  tmtest(m1, s1, n1, m0, s0, n0, conf.level=0.95, nullHypo=0, var.equal=F)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tmtest_+3A_m1">m1</code></td>
<td>
<p>mean of the first (test, active, experimental) group</p>
</td></tr>
<tr><td><code id="tmtest_+3A_s1">s1</code></td>
<td>
<p>sample standard deviation of the first group</p>
</td></tr>
<tr><td><code id="tmtest_+3A_n1">n1</code></td>
<td>
<p>sample size of the first group</p>
</td></tr>
<tr><td><code id="tmtest_+3A_m0">m0</code></td>
<td>
<p>mean of the second (reference, control, placebo) group</p>
</td></tr>
<tr><td><code id="tmtest_+3A_s0">s0</code></td>
<td>
<p>sample standard deviation of the second group</p>
</td></tr>
<tr><td><code id="tmtest_+3A_n0">n0</code></td>
<td>
<p>sample size of the second group</p>
</td></tr>
<tr><td><code id="tmtest_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level</p>
</td></tr>
<tr><td><code id="tmtest_+3A_nullhypo">nullHypo</code></td>
<td>
<p>value for the difference of means under null hypothesis</p>
</td></tr>
<tr><td><code id="tmtest_+3A_var.equal">var.equal</code></td>
<td>
<p>assumption on the variance equality</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default is Welch t-test with Satterthwaite approximation.
</p>


<h3>Value</h3>

<p>The output format is very similar to t.test
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>See Also</h3>

<p><code><a href="#topic+mtest">mtest</a></code>, <code><a href="#topic+TTEST">TTEST</a></code>, <code><a href="#topic+ztest">ztest</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  tmtest(5.4, 10.5, 3529, 5.1, 8.9, 5190) # NEJM 388;15 p1386
  tmtest(5.4, 10.5, 3529, 5.1, 8.9, 5190, var.equal=TRUE)
</code></pre>

<hr>
<h2 id='trimmedMean'>Trimmed Mean</h2><span id='topic+trimmedMean'></span>

<h3>Description</h3>

<p>Trimmed mean wrapping <code>mean</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  trimmedMean(y, Trim=0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trimmedMean_+3A_y">y</code></td>
<td>
<p>a vector of numerics</p>
</td></tr>
<tr><td><code id="trimmedMean_+3A_trim">Trim</code></td>
<td>
<p>trimming proportion. Default is 0.05</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It removes <code>NA</code> in the input vector.
</p>


<h3>Value</h3>

<p>The value of trimmed mean
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>

<hr>
<h2 id='tsum'>Table Summary</h2><span id='topic+tsum'></span>

<h3>Description</h3>

<p>Summarize a continuous dependent variable with or without independent variables.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  tsum(Formula=NULL, Data=NULL, ColNames=NULL, MaxLevel=30, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsum_+3A_formula">Formula</code></td>
<td>
<p>a conventional formula</p>
</td></tr>
<tr><td><code id="tsum_+3A_data">Data</code></td>
<td>
<p>a data.frame or a matrix</p>
</td></tr>
<tr><td><code id="tsum_+3A_colnames">ColNames</code></td>
<td>
<p>If there is no Formula, this will be used.</p>
</td></tr>
<tr><td><code id="tsum_+3A_maxlevel">MaxLevel</code></td>
<td>
<p>More than this will not be handled.</p>
</td></tr>
<tr><td><code id="tsum_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code>tsum0</code>, <code>tsum1</code>, <code>tsum2</code>, or <code>tsum3</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A convenient summarization function for a continuous variable. This is a wrapper function to <code>tsum0</code>, <code>tsum1</code>, <code>tsum2</code>, or <code>tsum3</code>.
</p>


<h3>Value</h3>

<p>A data.frame of descriptive summarization values. 
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsum0">tsum0</a></code>, <code><a href="#topic+tsum1">tsum1</a></code>, <code><a href="#topic+tsum2">tsum2</a></code>, <code><a href="#topic+tsum3">tsum3</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  tsum(lh)
  t(tsum(CO2))
  t(tsum(uptake ~ Treatment, CO2))
  tsum(uptake ~ Type + Treatment, CO2)
  print(tsum(uptake ~ conc + Type + Treatment, CO2), digits=3)
</code></pre>

<hr>
<h2 id='tsum0'>Table Summary 0 independent(x) variable</h2><span id='topic+tsum0'></span>

<h3>Description</h3>

<p>Summarize a continuous dependent(y) variable without any independent(x) variable.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  tsum0(d, y, e=c("Mean", "SD", "N"), repl=list(c("length"), c("n")))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsum0_+3A_d">d</code></td>
<td>
<p>a data.frame or matrix with colnames</p>
</td></tr>
<tr><td><code id="tsum0_+3A_y">y</code></td>
<td>
<p>y variable name, a continuous variable</p>
</td></tr>
<tr><td><code id="tsum0_+3A_e">e</code></td>
<td>
<p>a vector of summarize function names</p>
</td></tr>
<tr><td><code id="tsum0_+3A_repl">repl</code></td>
<td>
<p>list of strings to replace after summarize. The length of list should be 2, and both should have the same length.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A convenient summarization function for a continuous variable.
</p>


<h3>Value</h3>

<p>A vector of summarized values 
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsum">tsum</a></code>, <code><a href="#topic+tsum1">tsum1</a></code>, <code><a href="#topic+tsum2">tsum2</a></code>, <code><a href="#topic+tsum3">tsum3</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  tsum0(CO2, "uptake")
  tsum0(CO2, "uptake", repl=list(c("mean", "length"), c("Mean", "n")))
</code></pre>

<hr>
<h2 id='tsum1'>Table Summary 1 independent(x) variable</h2><span id='topic+tsum1'></span>

<h3>Description</h3>

<p>Summarize a continuous dependent(y) variable with one independent(x) variable.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  tsum1(d, y, u, e=c("Mean", "SD", "N"), ou="", repl=list(c("length"), ("n")))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsum1_+3A_d">d</code></td>
<td>
<p>a data.frame or matrix with colnames</p>
</td></tr>
<tr><td><code id="tsum1_+3A_y">y</code></td>
<td>
<p>y variable name. a continuous variable</p>
</td></tr>
<tr><td><code id="tsum1_+3A_u">u</code></td>
<td>
<p>x variable name, upper side variable</p>
</td></tr>
<tr><td><code id="tsum1_+3A_e">e</code></td>
<td>
<p>a vector of summarize function names</p>
</td></tr>
<tr><td><code id="tsum1_+3A_ou">ou</code></td>
<td>
<p>order of levels of upper side x variable</p>
</td></tr>
<tr><td><code id="tsum1_+3A_repl">repl</code></td>
<td>
<p>list of strings to replace after summarize. The length of list should be 2, and both should have the same length.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A convenient summarization function for a continuous variable with one x variable.
</p>


<h3>Value</h3>

<p>A data.frame of summarized values. Row names are from <code>e</code> names. Column names are from the levels of x variable. 
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsum">tsum</a></code>, <code><a href="#topic+tsum0">tsum0</a></code>, <code><a href="#topic+tsum2">tsum2</a></code>, <code><a href="#topic+tsum3">tsum3</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  tsum1(CO2, "uptake", "Treatment")
  tsum1(CO2, "uptake", "Treatment", 
        e=c("mean", "median", "sd", "min", "max", "length"), 
        ou=c("chilled", "nonchilled"),
        repl=list(c("median", "length"), c("med", "n")))
</code></pre>

<hr>
<h2 id='tsum2'>Table Summary 2 independent(x) variables</h2><span id='topic+tsum2'></span>

<h3>Description</h3>

<p>Summarize a continuous dependent(y) variable with two independent(x) variables.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  tsum2(d, y, l, u, e=c("Mean", "SD", "N"), h=NULL, ol="", ou="", rm.dup=TRUE, 
        repl=list(c("length"), c("n")))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsum2_+3A_d">d</code></td>
<td>
<p>a data.frame or matrix with colnames</p>
</td></tr>
<tr><td><code id="tsum2_+3A_y">y</code></td>
<td>
<p>y variable name. a continuous variable</p>
</td></tr>
<tr><td><code id="tsum2_+3A_l">l</code></td>
<td>
<p>x variable name to be shown on the left side</p>
</td></tr>
<tr><td><code id="tsum2_+3A_u">u</code></td>
<td>
<p>x variable name to be shown on the upper side</p>
</td></tr>
<tr><td><code id="tsum2_+3A_e">e</code></td>
<td>
<p>a vector of summarize function names</p>
</td></tr>
<tr><td><code id="tsum2_+3A_h">h</code></td>
<td>
<p>a vector of summarize function names for the horizontal subgroup. If <code>NULL</code>, it becomes the same as <code>e</code> argument.</p>
</td></tr>
<tr><td><code id="tsum2_+3A_ol">ol</code></td>
<td>
<p>order of levels of left side x variable</p>
</td></tr>
<tr><td><code id="tsum2_+3A_ou">ou</code></td>
<td>
<p>order of levels of upper side x variable</p>
</td></tr>
<tr><td><code id="tsum2_+3A_rm.dup">rm.dup</code></td>
<td>
<p>if <code>TRUE</code>, duplicated names of levels are specified on the first occurrence only.</p>
</td></tr>
<tr><td><code id="tsum2_+3A_repl">repl</code></td>
<td>
<p>list of strings to replace after summarize. The length of list should be 2, and both should have the same length.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A convenient summarization function for a continuous variable with two x variables; one on the left side, the other on the upper side.
</p>


<h3>Value</h3>

<p>A data.frame of summarized values. Column names are from the levels of <code>u</code>. Row names are basically from the levels of <code>l</code>. 
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsum">tsum</a></code>, <code><a href="#topic+tsum0">tsum0</a></code>, <code><a href="#topic+tsum1">tsum1</a></code>, <code><a href="#topic+tsum3">tsum3</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  tsum2(CO2, "uptake", "Type", "Treatment")
  tsum2(CO2, "uptake", "Type", "conc")
  tsum2(CO2, "uptake", "Type", "Treatment", 
        e=c("mean", "median", "sd", "min", "max", "length"), 
        ou=c("chilled", "nonchilled"),
        repl=list(c("median", "length"), c("med", "n")))
</code></pre>

<hr>
<h2 id='tsum3'>Table Summary 3 independent(x) variables</h2><span id='topic+tsum3'></span>

<h3>Description</h3>

<p>Summarize a continuous dependent(y) variable with three independent(x) variables.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  tsum3(d, y, l, u, e=c("Mean", "SD", "N"), h=NULL, ol1="", ol2="", ou="", 
        rm.dup=TRUE, repl=list(c("length"), c("n")))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsum3_+3A_d">d</code></td>
<td>
<p>a data.frame or matrix with colnames</p>
</td></tr>
<tr><td><code id="tsum3_+3A_y">y</code></td>
<td>
<p>y variable name. a continuous variable</p>
</td></tr>
<tr><td><code id="tsum3_+3A_l">l</code></td>
<td>
<p>a vector of two x variable names to be shown on the left side. The length should be 2.</p>
</td></tr>
<tr><td><code id="tsum3_+3A_u">u</code></td>
<td>
<p>x variable name to be shown on the upper side</p>
</td></tr>
<tr><td><code id="tsum3_+3A_e">e</code></td>
<td>
<p>a vector of summarize function names</p>
</td></tr>
<tr><td><code id="tsum3_+3A_h">h</code></td>
<td>
<p>a list of two vectors of summarize function names for the first and second horizontal subgroups. If <code>NULL</code>, it becomes the same as <code>e</code> argument.</p>
</td></tr>
<tr><td><code id="tsum3_+3A_ol1">ol1</code></td>
<td>
<p>order of levels of 1st left side x variable</p>
</td></tr>
<tr><td><code id="tsum3_+3A_ol2">ol2</code></td>
<td>
<p>order of levels of 2nd left side x variable</p>
</td></tr>
<tr><td><code id="tsum3_+3A_ou">ou</code></td>
<td>
<p>order of levels of upper side x variable</p>
</td></tr>
<tr><td><code id="tsum3_+3A_rm.dup">rm.dup</code></td>
<td>
<p>if <code>TRUE</code>, duplicated names of levels are specified on the first occurrence only.</p>
</td></tr>
<tr><td><code id="tsum3_+3A_repl">repl</code></td>
<td>
<p>list of strings to replace after summarize. The length of list should be 2, and both should have the same length.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A convenient summarization function for a continuous variable with three x variables; two on the left side, the other on the upper side.
</p>


<h3>Value</h3>

<p>A data.frame of summarized values. Column names are from the levels of <code>u</code>. Row names are basically from the levels of <code>l</code>. 
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsum">tsum</a></code>, <code><a href="#topic+tsum0">tsum0</a></code>, <code><a href="#topic+tsum1">tsum1</a></code>, <code><a href="#topic+tsum2">tsum2</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  tsum3(CO2, "uptake", c("Type", "Treatment"), "conc")
  tsum3(CO2, "uptake", c("Type", "Treatment"), "conc", 
        e=c("mean", "median", "sd", "min", "max", "length"),
        h=list(c("mean", "sd", "length"), c("mean", "length")),
        ol2=c("chilled", "nonchilled"),
        repl=list(c("median", "length"), c("med", "n")))
</code></pre>

<hr>
<h2 id='TTEST'>Independent two groups t-test comparable to PROC TTEST</h2><span id='topic+TTEST'></span>

<h3>Description</h3>

<p>This is comparable to SAS PROC TTEST.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  TTEST(x, y, conf.level=0.95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TTEST_+3A_x">x</code></td>
<td>
<p>a vector of data from the first (test, active, experimental) group</p>
</td></tr>
<tr><td><code id="TTEST_+3A_y">y</code></td>
<td>
<p>a vector of data from the second (reference, control, placebo) group</p>
</td></tr>
<tr><td><code id="TTEST_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Caution on choosing the row to use in the output.
</p>


<h3>Value</h3>

<p>The output format is comparable to SAS PROC TTEST.
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>See Also</h3>

<p><code><a href="#topic+mtest">mtest</a></code>, <code><a href="#topic+tmtest">tmtest</a></code>, <code><a href="#topic+ztest">ztest</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  TTEST(mtcars[mtcars$am==1, "mpg"], mtcars[mtcars$am==0, "mpg"])
</code></pre>

<hr>
<h2 id='UCL'>Upper Confidence Limit</h2><span id='topic+UCL'></span>

<h3>Description</h3>

<p>The estimate of the upper bound of the confidence limit using t-distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  UCL(y, conf.level=0.95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="UCL_+3A_y">y</code></td>
<td>
<p>a vector of numerics</p>
</td></tr>
<tr><td><code id="UCL_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It removes <code>NA</code> in the input vector. 
</p>


<h3>Value</h3>

<p>The estimate of the upper bound of the confidence limit using t-distribution
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>

<hr>
<h2 id='UNIV'>Univariate Descriptive Statistics</h2><span id='topic+UNIV'></span>

<h3>Description</h3>

<p>Returns descriptive statistics of a numeric vector. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  UNIV(y, conf.level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="UNIV_+3A_y">y</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="UNIV_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level for confidence limit</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A convenient and comprehensive function for descriptive statistics. NA is removed during the calculation. This is similar to SAS PROC UNIVARIATE.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>nAll</code></td>
<td>
<p>count of all elements in the input vector</p>
</td></tr>
<tr><td><code>nNA</code></td>
<td>
<p>count of NA element</p>
</td></tr>
<tr><td><code>nFinite</code></td>
<td>
<p>count of finite numbers</p>
</td></tr>
<tr><td><code>Mean</code></td>
<td>
<p>mean excluding NA</p>
</td></tr>
<tr><td><code>SD</code></td>
<td>
<p>standard deviation excluding NA</p>
</td></tr>
<tr><td><code>CV</code></td>
<td>
<p>coefficient of variation in percent</p>
</td></tr>
<tr><td><code>SEM</code></td>
<td>
<p>standard error of the sample mean, the sample mean divided by nFinite</p>
</td></tr>
<tr><td><code>LowerCL</code></td>
<td>
<p>lower confidence limit of mean</p>
</td></tr>
<tr><td><code>UpperCL</code></td>
<td>
<p>upper confidence limit of mean</p>
</td></tr>
<tr><td><code>TrimmedMean</code></td>
<td>
<p>trimmed mean with trimming 1 - confidence level</p>
</td></tr>
<tr><td><code>Min</code></td>
<td>
<p>minimum value</p>
</td></tr>
<tr><td><code>Q1</code></td>
<td>
<p>first quartile value</p>
</td></tr>
<tr><td><code>Median</code></td>
<td>
<p>median value</p>
</td></tr>
<tr><td><code>Q3</code></td>
<td>
<p>third quartile value</p>
</td></tr>
<tr><td><code>Max</code></td>
<td>
<p>maximum value</p>
</td></tr>
<tr><td><code>Range</code></td>
<td>
<p>range of finite numbers. maximum - minimum</p>
</td></tr>
<tr><td><code>IQR</code></td>
<td>
<p>inter-quartile range type 2, which is SAS default</p>
</td></tr>
<tr><td><code>MAD</code></td>
<td>
<p>median absolute deviation</p>
</td></tr>
<tr><td><code>VarLL</code></td>
<td>
<p>lower confidence limit of variance</p>
</td></tr>
<tr><td><code>VarUL</code></td>
<td>
<p>upper confidence limit of variance</p>
</td></tr>
<tr><td><code>Skewness</code></td>
<td>
<p>skewness</p>
</td></tr>
<tr><td><code>SkewnessSE</code></td>
<td>
<p>standard error of skewness</p>
</td></tr>
<tr><td><code>Kurtosis</code></td>
<td>
<p>kurtosis</p>
</td></tr>
<tr><td><code>KurtosisSE</code></td>
<td>
<p>kurtosis</p>
</td></tr>
<tr><td><code>GeometricMean</code></td>
<td>
<p>geometric mean, calculated only when all given values are positive.</p>
</td></tr>
<tr><td><code>GeometricCV</code></td>
<td>
<p>geometric coefficient of variation in percent, calculated only when all given values are positive.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>Examples</h3>

<pre><code class='language-R'>  UNIV(lh)
</code></pre>

<hr>
<h2 id='vtest'>F-Test for the ratio of two groups' variances</h2><span id='topic+vtest'></span>

<h3>Description</h3>

<p>F-test for the ratio of two groups' variances. This is similar to var.test except using the summarized input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  vtest(v1, n1, v0, n0, ratio=1, conf.level=0.95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vtest_+3A_v1">v1</code></td>
<td>
<p>sample variance of the first (test, active, experimental) group</p>
</td></tr>
<tr><td><code id="vtest_+3A_n1">n1</code></td>
<td>
<p>sample size of the first group</p>
</td></tr>
<tr><td><code id="vtest_+3A_v0">v0</code></td>
<td>
<p>sample variance of the second (reference, control, placebo) group</p>
</td></tr>
<tr><td><code id="vtest_+3A_n0">n0</code></td>
<td>
<p>sample size of the second group</p>
</td></tr>
<tr><td><code id="vtest_+3A_ratio">ratio</code></td>
<td>
<p>value for the ratio of variances under null hypothesis</p>
</td></tr>
<tr><td><code id="vtest_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the confidence interval of one group, use UNIV function.
</p>


<h3>Value</h3>

<p>The output format is very similar to var.test.
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>Examples</h3>

<pre><code class='language-R'>  vtest(10.5^2, 5190, 8.9^2, 3529) # NEJM 388;15 p1386
  vtest(2.3^2, 13, 1.5^2, 11, conf.level=0.9) # Red book p240
</code></pre>

<hr>
<h2 id='WhiteTest'>White's Model Specification Test</h2><span id='topic+WhiteTest'></span>

<h3>Description</h3>

<p>This is shown in SAS PROC REG as the Test of First and Second Moment Specification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  WhiteTest(rx)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="WhiteTest_+3A_rx">rx</code></td>
<td>
<p>a result of lm</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is also called as White's general test for heteroskedasticity.
</p>


<h3>Value</h3>

<p>Returns a direct test result by more coomplex theorem 2 , not by simpler corollary 1.
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>References</h3>

<p>White H. A Heteroskedasticity-Consistent Covariance Matrix Estimator and a Direct Test for Heteroskedasticity. Econometrica 1980;48(4):817-838.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  WhiteTest(lm(mpg ~ disp, mtcars))
</code></pre>

<hr>
<h2 id='ztest'>Test for the difference of two groups' means</h2><span id='topic+ztest'></span>

<h3>Description</h3>

<p>This is similar to two groups t-test, but using standard normal (Z) distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ztest(m1, s1, n1, m0, s0, n0, conf.level=0.95, nullHypo=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ztest_+3A_m1">m1</code></td>
<td>
<p>mean of the first (test, active, experimental) group</p>
</td></tr>
<tr><td><code id="ztest_+3A_s1">s1</code></td>
<td>
<p>known standard deviation of the first group</p>
</td></tr>
<tr><td><code id="ztest_+3A_n1">n1</code></td>
<td>
<p>sample size of the first group</p>
</td></tr>
<tr><td><code id="ztest_+3A_m0">m0</code></td>
<td>
<p>mean of the second (reference, control, placebo) group</p>
</td></tr>
<tr><td><code id="ztest_+3A_s0">s0</code></td>
<td>
<p>known standard deviationo of the second group</p>
</td></tr>
<tr><td><code id="ztest_+3A_n0">n0</code></td>
<td>
<p>sample size of the second group</p>
</td></tr>
<tr><td><code id="ztest_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level</p>
</td></tr>
<tr><td><code id="ztest_+3A_nullhypo">nullHypo</code></td>
<td>
<p>value for the difference of means under null hypothesis</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use this only for known standard deviations (or variances) or very large sample sizes per group.
</p>


<h3>Value</h3>

<p>The output format is very similar to t.test
</p>


<h3>Author(s)</h3>

<p>Kyun-Seop Bae k@acr.kr</p>


<h3>See Also</h3>

<p><code><a href="#topic+mtest">mtest</a></code>, <code><a href="#topic+tmtest">tmtest</a></code>, <code><a href="#topic+TTEST">TTEST</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  ztest(5.4, 10.5, 3529, 5.1, 8.9, 5190) # NEJM 388;15 p1386
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
