<!DOCTYPE html><html lang="en"><head><title>Help for package PolyHaplotyper</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PolyHaplotyper}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#allhap'><p>Find all possible haplotypes</p></a></li>
<li><a href='#allHaplotypes'><p>get all haplotypes for the given markers</p></a></li>
<li><a href='#build_ahccompletelist'><p>generate a list with all haplotype combinations</p></a></li>
<li><a href='#calcMrkHaptable'><p>produce a table of nr of markers vs nr of haplotypes</p></a></li>
<li><a href='#calcStatistics'><p>calculate some statistics of the solutions of all haploblocks</p></a></li>
<li><a href='#checkmrkDosage'><p>check a marker dosages matrix or data.frame</p></a></li>
<li><a href='#compareHapMrkDosages'><p>compare haplotyping results with observed markers dosages</p></a></li>
<li><a href='#compareHapresults'><p>compare two haplotyping results</p></a></li>
<li><a href='#demo_ped'><p>pedigree</p></a></li>
<li><a href='#demo_snpdos'><p>dosages of SNP alleles</p></a></li>
<li><a href='#expandHapdos'><p>Add dropped rows back to haplotype dosage matrix</p></a></li>
<li><a href='#getFSfreqs'><p>get all FS haplotype combinations expected from two parental haplotype</p>
combinations, with their frequencies</a></li>
<li><a href='#getGameteFreqs'><p>get all gametes and their frequencies for a parental</p>
haplotype combination</a></li>
<li><a href='#hapcomb2hapdos'><p>convert haplotype combinations to haplotype dosages</p></a></li>
<li><a href='#hapdos2hapcomb'><p>convert haplotype dosages to haplotype combinations</p></a></li>
<li><a href='#hapdos2mrkdos'><p>calculate the marker dosages resulting from haplotype dosage</p>
combinations</a></li>
<li><a href='#haploblock_df2list'><p>convert a haploblock-defining data frame to a list</p></a></li>
<li><a href='#inferHaplotypes'><p>infer haplotypes for one or more haploblocks</p></a></li>
<li><a href='#make.Happyinf.input'><p>convert PolyHaplotyper input data to Happy-inf format</p></a></li>
<li><a href='#make.SATlotyper.input'><p>convert PolyHaplotyper marker data to SATlotyper format</p></a></li>
<li><a href='#make.ShesisPlus.input'><p>convert PolyHaplotyper marker data to ShesisPlus format</p></a></li>
<li><a href='#mergeReplicates'><p>merge replicate samples in dosage matrix</p></a></li>
<li><a href='#mrkdid2mrkdos'><p>get the marker dosages from mrkdids (marker dosage IDs)</p></a></li>
<li><a href='#mrkdos2mrkdid'><p>get marker dosage IDs from marker dosages</p></a></li>
<li><a href='#overviewByFS'><p>generate an overview of the results by haploblock and by FS family</p></a></li>
<li><a href='#padded'><p>pad an integer (prefix with zeroes to a fixed length)</p></a></li>
<li><a href='#pedigreeHapCheck'><p>check the consistency of haploblock genotypes over a pedigree</p></a></li>
<li><a href='#pedigreeSim2PH'><p>convert the PedigreeSim true haplotypes to marker dosages and</p>
haplotype dosages</a></li>
<li><a href='#phblocks'><p>List of markers per haploblock</p></a></li>
<li><a href='#phdos'><p>dosages of SNP alleles</p></a></li>
<li><a href='#phFS'><p>members of FS families</p></a></li>
<li><a href='#phpar'><p>parents of FS families</p></a></li>
<li><a href='#phped'><p>pedigree</p></a></li>
<li><a href='#phresults'><p>haplotyping results</p></a></li>
<li><a href='#read.Happyinf.output'><p>read the haplotyping results from the Happy-inf output</p></a></li>
<li><a href='#read.SATlotyper.output'><p>read the haplotyping results from the SATlotyper output</p></a></li>
<li><a href='#read.ShesisPlus.output'><p>Read the haplotyping results from the ShesisPlus output</p></a></li>
<li><a href='#run.SATlotyper'><p>A simple interface to run SATlotyper</p></a></li>
<li><a href='#showOneFS'><p>show marker and haplotype dosages for one FS family</p></a></li>
<li><a href='#totHapcombCount'><p>calculate the total nr of possible haplotype combinations</p></a></li>
<li><a href='#usedhap'><p>Find all used (inferred) haplotypes</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Assignment of Haplotypes Based on SNP Dosages in Diploids and
Polyploids</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Roeland E. Voorrips</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Roeland E. Voorrips &lt;roeland.voorrips@wur.nl&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Infer the genetic composition of individuals
    in terms of haplotype dosages for a haploblock, based
    on bi-allelic marker dosages, for any ploidy level.
    Reference: Voorrips and Tumino: PolyHaplotyper: haplotyping in polyploids based on bi-allelic marker dosage data.
    Submitted to BMC Bioinformatics (2021).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>XML</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-06-17 12:52:29 UTC; voorr001</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-06-17 14:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='allhap'>Find all possible haplotypes</h2><span id='topic+allhap'></span>

<h3>Description</h3>

<p>Find all possible haplotypes for a haploblock from the
haplotyping result
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allhap(hapresults, haploblock)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="allhap_+3A_hapresults">hapresults</code></td>
<td>
<p>list as returned by inferhaplotypes, or one element
of such a list (i.e. the results for one haploblock)</p>
</td></tr>
<tr><td><code id="allhap_+3A_haploblock">haploblock</code></td>
<td>
<p>if hapresults is one element of the return value of
inferHaplotypes, haploblock should be missing of NULL; else haploblock is
a single value indicating the haploblock: either its name of its index
in hapresults</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function works with the results of inferHaplotypes; the setting
of dropUnused does not affect this function
</p>


<h3>Value</h3>

<p>an array with all possible haplotypes. The haplotypes are in columns,
with the haplotype numbers as colnames; the markers are in rows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PolyHaplotyper_small)
# show the composition of all possible haplotypes with the markers
# in the first haploblock:
allhap(hapresults=phresults, haploblock=1)
</code></pre>

<hr>
<h2 id='allHaplotypes'>get all haplotypes for the given markers</h2><span id='topic+allHaplotypes'></span>

<h3>Description</h3>

<p>Given a set of bi-allelic (SNP) marker names, generate all
possible haplotypes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allHaplotypes(mrknames)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="allHaplotypes_+3A_mrknames">mrknames</code></td>
<td>
<p>the names of the (bi-allelic) markers in the
haploblock (contig)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with markers in columns and all possible (2 ^ nmrk)
haplotypes in rows. 0: haplotype contains the non-dosage-counted marker
allele (the reference allele); 1: haplotype contains the dosage-counted
(alternative) marker allele. The colnames are the marker names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># show the 8 possible haplotypes with 3 bi-allelic markers:
allHaplotypes(mrknames=c("mrkA", "mrkB", "mrkC"))
</code></pre>

<hr>
<h2 id='build_ahccompletelist'>generate a list with all haplotype combinations</h2><span id='topic+build_ahccompletelist'></span>

<h3>Description</h3>

<p>generate a list which contains for each marker dosage combination
at a given ploidy all matching haplotype combinations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_ahccompletelist(ploidy, maxmrk, savesec=1800, printsec=300,
overwrite, shorten=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="build_ahccompletelist_+3A_ploidy">ploidy</code></td>
<td>
<p>ploidy; may be even or odd, but inferHaplotypes only works
with even ploidy if FS families are present, so building an ahccompletelist
for odd ploidy is probably not useful</p>
</td></tr>
<tr><td><code id="build_ahccompletelist_+3A_maxmrk">maxmrk</code></td>
<td>
<p>the list will countain all haplotype combinations for
haploblocks of 1...maxmrk markers</p>
</td></tr>
<tr><td><code id="build_ahccompletelist_+3A_savesec">savesec</code></td>
<td>
<p>default 1800: number of seconds between successive saves of
the intermediate results</p>
</td></tr>
<tr><td><code id="build_ahccompletelist_+3A_printsec">printsec</code></td>
<td>
<p>default 300: number of seconds between printout of
the current set of haplotypes. NA or 0 suppresses printing.</p>
</td></tr>
<tr><td><code id="build_ahccompletelist_+3A_overwrite">overwrite</code></td>
<td>
<p>the new file ahccompletelist_&lt;ploidy&gt;x.RData is written in
the working directory. If a file with that name already exists and would be
changed, this is aborted and the old file maintained if overwrite is FALSE</p>
</td></tr>
<tr><td><code id="build_ahccompletelist_+3A_shorten">shorten</code></td>
<td>
<p>if file ahccompletelist_&lt;ploidy&gt;x.RData already exists and
covers haploblocks of lengths longer than maxmrk,
this file is left unchanged if shorten is FALSE (default), but is shortened
to maxmrk if shorten is TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An ahccompletelist reduces the processing time of inferHaplotypes enormously
but takes a long time to build. This should therefore be done when
PolyHaplotyper will be used multiple times.<br />
If an ahccompletelist file already exists in the working directory, this file is
used as starting point; if maxmrk is larger than the length of the existing
list only the additional items are calculated.<br />
If this function crashes (due to exceeding the memory limits of the computer
or of R) the file ahccompletelist_&lt;ploidy&gt;x.RData in the working directory
contains an intact version of the ahccompletelist for the last finished
marker count. Also, the temporary file
&quot;buildAHCcompletelist_&lt;datetime&gt;&quot;_&quot;&lt;nmrk&gt;.RData&quot; contains a part of the
list item for the number of markers being calculated at that moment.<br />
Note that this function takes lots of time and memory already for
ploidy 4 / maxmrk 7 and ploidy 6 / maxmrk 5, and is not practicable above
ploidy 4 / maxmrk 8, ploidy 6 / maxmrk 6, ploidy 8 / maxmrk 5. Also, the
files are large and take up considerable memory, and most of the size is
used for the largest haploblock size. Therefore maxmrk should
not be taken larger than necessary.
</p>


<h3>Value</h3>

<p>NULL (invisible); the actual result is a file in the working directory
named ahccompletelist_&lt;ploidy&gt;x.RData
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# this example will create a file ahccompletelist_4x.RData
# in the working directory, for ploidy=4x and 1 - 4 markers:
build_ahccompletelist(ploidy=4, maxmrk=4, overwrite=FALSE)

</code></pre>

<hr>
<h2 id='calcMrkHaptable'>produce a table of nr of markers vs nr of haplotypes</h2><span id='topic+calcMrkHaptable'></span>

<h3>Description</h3>

<p>produce a table of nr of markers vs nr of haplotypes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcMrkHaptable(ovwFS)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calcMrkHaptable_+3A_ovwfs">ovwFS</code></td>
<td>
<p>a list as produced by overviewFS. Only the first 2 columns of
list item ovw are used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a frequency table with the numbers of haploblocks, with
all combinations of marker counts and inferred haplotype counts per haploblock.
The column with haplotype count NA (if any) shows the haploblocks for which
no haplotype solution was found (the reason for that would usually be found
in column 1 of ovwFS$messages)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PolyHaplotyper_small)
phovw &lt;- overviewByFS(haploblock=phblocks, parents=phpar, FS=phFS,
                     hapresults=phresults)
# in this small dataset there are only 2 haploblocks, each with 4 markers:
calcMrkHaptable(ovwFS=phovw)
# in both haploblocks 5 haplotypes are inferred
</code></pre>

<hr>
<h2 id='calcStatistics'>calculate some statistics of the solutions of all haploblocks</h2><span id='topic+calcStatistics'></span>

<h3>Description</h3>

<p>calculate some statistics of the solutions of all haploblocks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcStatistics(pedchk, ovwFS, indiv, haploblocks)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calcStatistics_+3A_pedchk">pedchk</code></td>
<td>
<p>a list as generated by pedigreeHapCheck</p>
</td></tr>
<tr><td><code id="calcStatistics_+3A_ovwfs">ovwFS</code></td>
<td>
<p>a list as produced by overviewFS, or NA if no FS families
available. If ovwFS is specified, pedchk and ovwFS should have
been calculated from the same underlying data</p>
</td></tr>
<tr><td><code id="calcStatistics_+3A_indiv">indiv</code></td>
<td>
<p>missing, NULL or a vector of names of individuals. If present,
the component pedstats is calculated only over the individuals in the vector,
else over all individuals. Component FSstats is not affected by indiv</p>
</td></tr>
<tr><td><code id="calcStatistics_+3A_haploblocks">haploblocks</code></td>
<td>
<p>missing, NULL or a vector of names or numbers of
haploblocks, or a list of haploblocks as in the inferHaplotypes input.
If present, components pedstats and FSstats are calculated only over the
specified haploblocks, else over all haploblocks.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with one or two items:<br />
pedstats: a data.frame with one row per haploblock, showing numbers
of individuals in columns<br />
- mrk: individuals with complete marker data<br />
- hap: individuals with an assigned haplotype combination<br />
- match.NA: individuals where a match between the haplotypes of the individual
and its parents could not be verified (either the individual itself or both
parents have no haplotype combination assigned)<br />
- noDR.TRUE: individuals whose haplotype combination matches that of its
parents, assuming polysomic inheritance without Double Reduction<br />
- noDR.FALSE: individuals whose haplotype combination doesn't match that of its
parents, assuming polysomic inheritance without Double Reduction<br />
- withDR.TRUE: individuals whose haplotype combination matches that of its
parents, assuming polysomic inheritance, allowing Double Reduction<br />
- withDR.FALSE: individuals whose haplotype combination doesn't match that of
its parents, assuming polysomic inheritance, allowing Double Reduction<br />
The total number of individuals is <br />
match.NA + noDR.TRUE + noDR.FALSE == match.NA + withDR.TRUE + withDR.FALSE;<br />
the number of individuals with missing marker data or without assigned
haplotype dosages can be calculated by subtracting mrk or hap from that
total.<br />
FSstats (only if ovwFS specified): a data.frame with for each FS family,
&quot;rest&quot; and &quot;all&quot; one row, with columns<br />
- pop: the FS family numbers, &quot;rest&quot; (all individuals not belonging to the
FSs or their parents) and &quot;all&quot; (all individuals)<br />
- bothparmrk: for how many haploblocks have both parents complete marker data?<br />
- FSdone: for how many haploblocks has a solution based on polysomic
inheritance been found for this FS family?<br />
- mrk: the average number of (FS) individuals with complete marker data<br />
- imp: the average number of (FS) individuals with imputed marker data<br />
- hap: the average number of (FS) individuals with an assigned haplotype
combination<br />
The numbers for &quot;all&quot; include also the FS parents (each parent counted only
once, even if some parents produced more than one FS family), which are not
included in any of the other rows; therefore &quot;all&quot; is not equal to the sum of
the rows above.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PolyHaplotyper_small)
phchk &lt;- pedigreeHapCheck(ped=phped, mrkDosage=phdos, haploblock=phblocks,
                          hapresults=phresults)
phovw &lt;- overviewByFS(haploblock=phblocks, parents=phpar, FS=phFS,
                     hapresults=phresults)
calcStatistics(pedchk=phchk, ovwFS=phovw)
</code></pre>

<hr>
<h2 id='checkmrkDosage'>check a marker dosages matrix or data.frame</h2><span id='topic+checkmrkDosage'></span>

<h3>Description</h3>

<p>check a marker dosages matrix or data.frame, select columns and rows,
convert to matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkmrkDosage(mrkDosage, ploidy, indiv=NULL, markers=NULL,
generateMarkernames=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkmrkDosage_+3A_mrkdosage">mrkDosage</code></td>
<td>
<p>matrix or data.frame. Markers are in rows, individuals in
columns, each cell has a marker dosage. If mrkDosage is a matrix,
the colnames are the individual names and the rownames are the marker names.
If mrkDosage is a data.frame and the name of the first column starts with
&quot;marker&quot; (upper/lowercase not relevant) the contents of this column are used
as marker names, else the rownames are used as marker names. The (other)
column names are the individual names.
All marker dosages must be in 0:ploidy or NA.</p>
</td></tr>
<tr><td><code id="checkmrkDosage_+3A_ploidy">ploidy</code></td>
<td>
<p>an integer value; all dosages are checked to be in 0:ploidy or NA</p>
</td></tr>
<tr><td><code id="checkmrkDosage_+3A_indiv">indiv</code></td>
<td>
<p>NULL (default) or a character vector with names of individuals
to be selected. If NULL, all individuals are selected</p>
</td></tr>
<tr><td><code id="checkmrkDosage_+3A_markers">markers</code></td>
<td>
<p>NULL (default) or a character vector with names of markers
to be selected. If NULL, all markers are selected.</p>
</td></tr>
<tr><td><code id="checkmrkDosage_+3A_generatemarkernames">generateMarkernames</code></td>
<td>
<p>if TRUE (default) and mrkDosage has no markernames
specified, markernames are generated automatically. Markernames
must be either present or be generated, and none may be missing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called by inferHaplotypes and by mergeReplicates, so
normally there is no need for the user to call this function directly.
</p>


<h3>Value</h3>

<p>a matrix with the selected columns in the order of indiv and the
selected rows in order of markers (or all columns or rows in the original
order if indiv or markers are not specified), with
names of individuals as column names, marker names as row names
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mrkdos &lt;- data.frame(
 marker=paste0("mrk", 1:3),
 indiv1=c(1, 2, 2),
 indiv2=c(4, 0, 0),
 indiv3=c(3, 0, 2))
# use all rows and columns:
checkmrkDosage(mrkDosage=mrkdos, ploidy=4)
# use only first and last row and column and change the order:
checkmrkDosage(mrkDosage=mrkdos, ploidy=4, indiv=c("indiv3", "indiv1"),
              markers=c("mrk3", "mrk1"))
</code></pre>

<hr>
<h2 id='compareHapMrkDosages'>compare haplotyping results with observed markers dosages</h2><span id='topic+compareHapMrkDosages'></span>

<h3>Description</h3>

<p>compare haplotyping results with observed markers dosages
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareHapMrkDosages(mrkDosage, hapresults)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compareHapMrkDosages_+3A_mrkdosage">mrkDosage</code></td>
<td>
<p>a data.frame or matrix with the marker dosages, in
the format of inferHaplotypes()</p>
</td></tr>
<tr><td><code id="compareHapMrkDosages_+3A_hapresults">hapresults</code></td>
<td>
<p>a list as returned by inferHaplotypes,
with one item (itself a list) per haploblock with at least a matrix hapdos
and a character vector markers. All markers in all haploblocks must also
occur in mrkDosages, and all individuals in the hapdos matrices must also
occur in mrkDosages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 3-D array with dimensions haploblock, individual, and chkresult:
mrkNA (ALL markers in the haploblock have missing data for the individual),
hapNA (the haplotype dosages do not sum to ploidy and/or are missing),
match (TRUE if the non-missing marker dosages match the haplotype dosages,
FALSE is there is a conflict, NA if mrkNA and/or hapNA are TRUE)
Each element is itself a list with elements:
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PolyHaplotyper_small)
chmd &lt;- compareHapMrkDosages(mrkDosage=phdos, hapresults=phresults)
# show results for first haploblock, first 8 individuals:
chmd[1, 1:8,]
</code></pre>

<hr>
<h2 id='compareHapresults'>compare two haplotyping results</h2><span id='topic+compareHapresults'></span>

<h3>Description</h3>

<p>compare two haplotyping results, e.g. PolyHaplotyper and
SATlotyper
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareHapresults(haploblock, hapresultsA, hapresultsB)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compareHapresults_+3A_haploblock">haploblock</code></td>
<td>
<p>a list of character vectors. The names are the names of the
haploblocks, the character vectors have the names of the markers in each
haploblock.</p>
</td></tr>
<tr><td><code id="compareHapresults_+3A_hapresultsa">hapresultsA</code></td>
<td>
<p>and</p>
</td></tr>
<tr><td><code id="compareHapresults_+3A_hapresultsb">hapresultsB</code></td>
<td>
<p>two list as returned by inferHaplotypes,
with one item (itself a list) per haploblock with at least a matrix hapdos
and a character vector markers. All
haploblocks in param haploblock must occur in hapresultsA and in hapresultsB.
The individual names (colnames of the hapdos items for each haploblock)
must be identical and in the same order in hapresultsA and hapresultsB</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with one element per haploblock in param haploblock.
Each element is itself a list with elements:
$identical: TRUE or FALSE<br />
$message: a single string, &quot;&quot; if the comparison is possible, else the reason
why not (if $message is not &quot;&quot;, $identical is always FALSE). The next
elements are only present if $message is &quot;&quot;:<br />
$compindiv: a matrix comparing the two hapdos, with one column per individual
and 5 rows: Both_NA, A_NA, B_NA, Equal, Uneq. The last 2 have NA values if A
and/or B is NA
$haplofreq: a matrix with one row per haplotype occurring in A and/or B,
and columns A and B, with the total frequency of each haplotype in
hapdos A or hapdos B
</p>

<hr>
<h2 id='demo_ped'>pedigree</h2><span id='topic+demo_ped'></span>

<h3>Description</h3>

<p>A data.frame with a pedigree; used in vignette, stored in
PolyHaplotyper_demo.RData
</p>


<h3>Format</h3>

<p>a data.frame with 661 rows (samples) and
4 columns: genotype, mother, father, sample_nr
</p>

<hr>
<h2 id='demo_snpdos'>dosages of SNP alleles</h2><span id='topic+demo_snpdos'></span>

<h3>Description</h3>

<p>A data.frame with the allele dosages for 30 SNPs in 661
samples; used in vignette, stored in PolyHaplotyper_demo.RData
</p>


<h3>Format</h3>

<p>a data.frame with 30 rows (SNPs) and 663 columns. The first
two columns contain the SNP name and contig; the remaining columns
contain the allele dosages (integers in 0..6 or NA) of the SNPs in
661 samples
</p>

<hr>
<h2 id='expandHapdos'>Add dropped rows back to haplotype dosage matrix</h2><span id='topic+expandHapdos'></span>

<h3>Description</h3>

<p>Haplotype dosage matrices generated with the dropUnused=TRUE
lack some haplotypes that are required by pedigreeHapCheck; this
function adds them back.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expandHapdos(hapdos, nhap, hbname)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expandHapdos_+3A_hapdos">hapdos</code></td>
<td>
<p>a haplotype dosage matrix as returned by a.o. inferHaplotypes.
The rownames are assumed to have all the same length:
they are composed of the haploblock name to which the 0-padded haplotype number
is appended, separated by &quot;_&quot;</p>
</td></tr>
<tr><td><code id="expandHapdos_+3A_nhap">nhap</code></td>
<td>
<p>the total number of haplotypes for the haploblock:
nhap = 2^nmrk with nmrk the number of markers in the haploblock</p>
</td></tr>
<tr><td><code id="expandHapdos_+3A_hbname">hbname</code></td>
<td>
<p>the haploblock name (only used when hapdos has 0 rows)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix similar to hapdos with rows for the dropped haplotypes
re-inserted, with the correct rownames and containing only 0 and NA values
</p>


<h3>Examples</h3>

<pre><code class='language-R'># specify haplotype dosages of 4 tetraploid individuals,
# only the 3 occurring haplotypes (1, 5 and 6) are given:
haplodosg &lt;- matrix(c(1,2,1, 4,0,0, 0,4,0, 0,0,4), nrow=3,
                   dimnames=list(paste0("demohap_", c(1,5,6)), paste0("indiv", 1:4)))
# add the rows for the absent haplotypes, assuming the haploblock consists
# of 3 markers, so 8 haplotypes are possible:
expandHapdos(hapdos=haplodosg, nhap=8)
</code></pre>

<hr>
<h2 id='getFSfreqs'>get all FS haplotype combinations expected from two parental haplotype
combinations, with their frequencies</h2><span id='topic+getFSfreqs'></span>

<h3>Description</h3>

<p>get all FS haplotype combinations expected from two parental
haplotype combinations, with their frequencies. Different from getFScombs in
that it returns the unique FS combinations as well as their frequencies, and
that it also considers Double Reduction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFSfreqs(parhac, DRrate)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getFSfreqs_+3A_parhac">parhac</code></td>
<td>
<p>matrix with one column for each parent and &lt;ploidy&gt; rows,
giving the haplotype combinations for each parent</p>
</td></tr>
<tr><td><code id="getFSfreqs_+3A_drrate">DRrate</code></td>
<td>
<p>the rate of double reduction per meiosis (NOT per allele!); e.g.
with a DRrate of 0.04, a tetraploid parent with genotype ABCD will produce
a fraction of 0.04 of DR gametes AA, BB, CC and DD (each with a frequency of
0.01), and a fraction of 0.96 of the non-DR gametes AB, AC, AD, BC, BD, CD
(each with a frequency of 0.16)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of 2 elements:<br />
FShac: a matrix with one column per unique FS haplotype combination and
the same row count as parhac, giving the FS haplotype combinations. There are
no duplicated columns but several (not necessarily adjacent) columns
may correspond to the same mrkdid<br />
freq: a vector of length ncol(hapcomb), with for each FS haplotype combination
in hapcomb its frequency (0.0 ... 1.0). The colnames are NULL: haplotype
combinations are not named.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># specify combinations of haplotypes in two tetraploid parents:
hapcomb &lt;- matrix(c(2,2,5,6, 1,2,5,5), ncol=2)
# FS frequencies without double reduction:
getFSfreqs(parhac=hapcomb, DRrate=0)
# FS frequencies with 5\% double reduction:
getFSfreqs(parhac=hapcomb, DRrate=0.05)
</code></pre>

<hr>
<h2 id='getGameteFreqs'>get all gametes and their frequencies for a parental
haplotype combination</h2><span id='topic+getGameteFreqs'></span>

<h3>Description</h3>

<p>get all gametes and their frequencies for a parental
haplotype combination
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGameteFreqs(parhac, DRrate)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getGameteFreqs_+3A_parhac">parhac</code></td>
<td>
<p>vector of the parental haplotype combination of length &lt;ploidy&gt;,
giving the &lt;ploidy&gt; haplotype numbers present
per haplotype giving the dosage of that haplotype, summing to ploidy</p>
</td></tr>
<tr><td><code id="getGameteFreqs_+3A_drrate">DRrate</code></td>
<td>
<p>the rate of double reduction per meiosis (NOT per allele!); e.g.
with a DRrate of 0.04, a tetraploid parent with genotype ABCD will produce
a fraction of 0.04 of DR gametes AA, BB, CC and DD (each with a frequency of
0.01), and a fraction of 0.96 of the non-DR gametes AB, AC, AD, BC, BD, CD
(each with a frequency of 0.16)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>for hexaploids the DR gametes consist of a duplication of one of the
6 parental alleles, combined with one copy of one of the other 5 alleles.<br />
Calculation is faster if DRrate is 0.0
</p>


<h3>Value</h3>

<p>a list of 2 elements:<br />
hapcomb: a matrix with one column per unique gamete and ploidy/2 rows.
Each element is the number (ID) of a haplotype). Within columns the
haplotypes are sorted from low to high; the columns are ordered from left
to right, first on row 1, then on row 2 etc<br />
freq: a vector of length ncol(hapcomb), with for each gamete in hapcomb its
frequency (0.0 ... 1.0)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># specify combination of haplotypes in a tetraploid parent:
hapcomb &lt;- c(2,2,5,6) # 2 copies of haplotype 2, 1 each of 5 and 6
# gamete frequencies without double reduction:
getGameteFreqs(parhac=hapcomb, DRrate=0)
# gamete frequencies with 5\% double reduction:
getGameteFreqs(parhac=hapcomb, DRrate=0.05)
</code></pre>

<hr>
<h2 id='hapcomb2hapdos'>convert haplotype combinations to haplotype dosages</h2><span id='topic+hapcomb2hapdos'></span>

<h3>Description</h3>

<p>converts matrices that contain haplotype combinations in columns
(as the matrices in ahccompletelist or ahclist) to matrices with the haplotype
dosages
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hapcomb2hapdos(hapcomb, nhap)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hapcomb2hapdos_+3A_hapcomb">hapcomb</code></td>
<td>
<p>matrix with &lt;ploidy&gt; rows and any number of columns. Each column
contains a set of haplotypes (numbers in 1 ... nhap). NAs allowed but no
values outside this range (not checked). E.g. a column with numbers
1-1-3-12 means two copies of haplotype 1 and one of haplotypes 3 and 12 each.</p>
</td></tr>
<tr><td><code id="hapcomb2hapdos_+3A_nhap">nhap</code></td>
<td>
<p>the total number of possible haplotypes: 2^nmrk where nmrk is the
number of bi-allelic markers in the haploblock</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with nhap rows (one row for each possible haplotype) and as many
columns as in hapmat, giving the dosages of each haplotype in each column
of hapmat.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># specify haplotype combinations of 2 individuals:
haplocomb &lt;- matrix(c(1,5,5,6, 5,6,6,6), ncol=2,
                   dimnames=list(NULL, c("indiv1", "indiv2")))
# convert to dosage matrix,
# assuming haploblock has 3 markers, so 8 possible haplotypes:
hapcomb2hapdos(hapcomb=haplocomb, nhap=8)
</code></pre>

<hr>
<h2 id='hapdos2hapcomb'>convert haplotype dosages to haplotype combinations</h2><span id='topic+hapdos2hapcomb'></span>

<h3>Description</h3>

<p>convert a vector or matrix of haplotype dosages to a vector
or matrix of haplotype combinations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hapdos2hapcomb(hapdos, ploidy)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hapdos2hapcomb_+3A_hapdos">hapdos</code></td>
<td>
<p>a vector with one item for some or all possible haplotypes,
with the dosage of the haplotypes, summing to ploidy; or a matrix where
each column is such a vector, each representing an individual. Missing data
are allowed (but any NA makes the entire vector or matrix column unknown);
if a matrix, 0 rows indicate missing values for all individuals.
When hapdos is a matrix, the haplotype numbers must be given as rownames;
when a vector, as names. Not all possible haplotype numbers need to be present
but the ones that are present must be in ascending order, no duplicates
or missing values allowed.</p>
</td></tr>
<tr><td><code id="hapdos2hapcomb_+3A_ploidy">ploidy</code></td>
<td>
<p>the ploidy (one number)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a sorted vector of length ploidy with all haplotype numbers present,
or a matrix where each column is such a vector, with the same
colnames as hapdos
</p>


<h3>Examples</h3>

<pre><code class='language-R'># specify haplotype dosages of 4 tetraploid individuals,
# only the 3 occurring haplotypes (1, 5 and 6) are given:
haplodosg &lt;- matrix(c(1,2,1, 4,0,0, 0,4,0, 0,0,4), nrow=3,
                   dimnames=list(paste0("demohap_", c(1,5,6)), paste0("indiv", 1:4)))
# usage with hapdos as matrix:
hapdos2hapcomb(hapdos=haplodosg, ploidy=4)
# usage with hapdos as vector:
hapdos2hapcomb(hapdos=haplodosg[, 1], ploidy=4)
</code></pre>

<hr>
<h2 id='hapdos2mrkdos'>calculate the marker dosages resulting from haplotype dosage
combinations</h2><span id='topic+hapdos2mrkdos'></span>

<h3>Description</h3>

<p>calculate the marker dosages resulting from haplotype dosage
combinations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hapdos2mrkdos(hapdos, allhap)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hapdos2mrkdos_+3A_hapdos">hapdos</code></td>
<td>
<p>a matrix with one column per combination of haplotypes
and one row for each possible haplotype (corresponding to the rows of allhap)
with dosage of the haplotypes in each combination. A vector is interpreted
as a one-column matrix; all columns must sum to ploidy. The rownames of
the matrix (or names of the vector) must contain the haplotype numbers</p>
</td></tr>
<tr><td><code id="hapdos2mrkdos_+3A_allhap">allhap</code></td>
<td>
<p>a matrix as returned by allHaplotypes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>if hapdos contains NA values, all values in the corresponding
column of the result will also be NA
</p>


<h3>Value</h3>

<p>a matrix with columns corresponding to the columns of hapdos
and one row for each marker, with the dosages of each marker in each combination;
colnames are the mrkdids (marker dosage IDs), rownames are the marker names taken
from allhap
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get a matrix of all haplotypes with the 3 specified markers:
ah &lt;- allHaplotypes(mrknames=c("mrkA", "mrkB", "mrkC"))
# specify haplotype dosages of 4 tetraploid individuals,
# only the 3 occurring haplotypes (1, 5 and 6) are given:
haplodosg &lt;-
 matrix(c(1,2,1, 4,0,0, 0,4,0, 0,0,4), nrow=3,
        dimnames=list(paste0("demohap_", c(1,5,6)), paste0("indiv", 1:4)))
# calculate the corresponding marker (SNP) dosages:
hapdos2mrkdos(hapdos=haplodosg, allhap=ah)
</code></pre>

<hr>
<h2 id='haploblock_df2list'>convert a haploblock-defining data frame to a list</h2><span id='topic+haploblock_df2list'></span>

<h3>Description</h3>

<p>convert a haploblock-defining data frame to a list as needed
by inferHaplotypes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haploblock_df2list(df, mrkcol, hbcol, sorted=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="haploblock_df2list_+3A_df">df</code></td>
<td>
<p>a data.frame with at least the following two columns</p>
</td></tr>
<tr><td><code id="haploblock_df2list_+3A_mrkcol">mrkcol</code></td>
<td>
<p>the name or number of the column with the markers</p>
</td></tr>
<tr><td><code id="haploblock_df2list_+3A_hbcol">hbcol</code></td>
<td>
<p>the name or number of the column with the haploblocks</p>
</td></tr>
<tr><td><code id="haploblock_df2list_+3A_sorted">sorted</code></td>
<td>
<p>if TRUE (default) the haploblock list is sorted in alphabetical
order of haploblock name (the markers within haploblocks are not sorted);
if FALSE the haploblocks will be in order of first occurrence in df</p>
</td></tr>
</table>


<h3>Details</h3>

<p>function inferHaplotypes needs a list where each item is a
vector of all markers in one haploblock. This function produces such a list
from a data.frame where the markers are in one column and the haploblocks
in another column. The markers and haploblocks columns may be character,
factor or numeric, and the columns may be indicated by name or number.
</p>


<h3>Value</h3>

<p>the desired list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df1 &lt;- data.frame(
 marker=paste0("mrk",1:9),
 block=LETTERS[c(1,2,3,2,3,1,1,2,2)],
 extracol=runif(9))
haploblock_df2list(df=df1, mrkcol="marker", hbcol=2)
</code></pre>

<hr>
<h2 id='inferHaplotypes'>infer haplotypes for one or more haploblocks</h2><span id='topic+inferHaplotypes'></span>

<h3>Description</h3>

<p>infer haplotypes for one or more haploblocks, for all individuals,
using FS family(s) (with parents) if present, and infer haplotypes for
non-FS material as well
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inferHaplotypes(mrkDosage, indiv=NULL, ploidy, haploblock,
parents=NULL, FS=NULL, minfrac=c(0.1, 0.01), errfrac=0.025, DRrate=0.025,
maxmrk=0, dropUnused=TRUE, maxparcombs=150000, minPseg=1e-8,
knownHap=integer(0), progress=TRUE, printtimes=FALSE, ahcdir)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inferHaplotypes_+3A_mrkdosage">mrkDosage</code></td>
<td>
<p>matrix or data.frame. Markers are in rows, individuals in
columns, each cell has a marker dosage. Names of individuals are the column
names, marker names are the row names or (if a data.frame) in a column named
MarkerNames. All marker dosages must be in 0:ploidy or NA.</p>
</td></tr>
<tr><td><code id="inferHaplotypes_+3A_indiv">indiv</code></td>
<td>
<p>NULL (default) or a character vector with names of all individuals
to be considered. If NULL, all columns of mrkDosage are selected.<br />
All indivs that are not in parents or FS vectors (see below) are considered
unrelated, i.e. we have no implementation for pedigrees (yet).</p>
</td></tr>
<tr><td><code id="inferHaplotypes_+3A_ploidy">ploidy</code></td>
<td>
<p>all marker dosages should be in 0:ploidy or NA</p>
</td></tr>
<tr><td><code id="inferHaplotypes_+3A_haploblock">haploblock</code></td>
<td>
<p>a list of character vectors. The names are the names of the
haploblocks, the character vectors have the names of the markers in each
haploblock. Haplotype names are constructed from the haploblock names, which
are used as prefixes to which the (zero-padded) haplotype numbers are are
appended with separator '_'.</p>
</td></tr>
<tr><td><code id="inferHaplotypes_+3A_parents">parents</code></td>
<td>
<p>a matrix with one row for each FS family and two columns
for the two parents, containing the names of the female and male parent
of each family.</p>
</td></tr>
<tr><td><code id="inferHaplotypes_+3A_fs">FS</code></td>
<td>
<p>a list of character vectors. Each character vector has the names of
the individuals of one FS family. The items of the list should correspond
to the rows of the parents matrix, in the same order.</p>
</td></tr>
<tr><td><code id="inferHaplotypes_+3A_minfrac">minfrac</code></td>
<td>
<p>vector of two fractions, default 0.1 and 0.01. A haplotype is
considered to be certainly present if it must occur in at least a fraction
minfrac[1] of all individuals; in the final stage for the &quot;other&quot;
individuals (those that do not belong to the FS or its parents) this fraction
is lowered to minfrac[2]; see also inferHaps_noFS</p>
</td></tr>
<tr><td><code id="inferHaplotypes_+3A_errfrac">errfrac</code></td>
<td>
<p>default 0.025. The assumed fraction marker genotypes with an error
(over all markers in the haploblock). The errors are assumed to be uniformly
distributed over all except the original marker dosage combinations (mrkdids)</p>
</td></tr>
<tr><td><code id="inferHaplotypes_+3A_drrate">DRrate</code></td>
<td>
<p>default 0.025. The rate of double reduction per meiosis (NOT
per allele!); e.g. with a DRrate of 0.04, a tetraploid parent with
genotype ABCD will produce a fraction of 0.04 of DR gametes AA, BB, CC and DD
(each with a frequency of 0.01), and a fraction of 0.96 of the non-DR gametes
AB, AC, AD, BC, BD, CD (each with a frequency of 0.16)</p>
</td></tr>
<tr><td><code id="inferHaplotypes_+3A_maxmrk">maxmrk</code></td>
<td>
<p>Haploblocks with more than maxmrk markers will be skipped.
Default 0: no haploblocks are skipped</p>
</td></tr>
<tr><td><code id="inferHaplotypes_+3A_dropunused">dropUnused</code></td>
<td>
<p>TRUE (default) if the returned matrix should only contain
rows for haplotypes that are present; if FALSE matrix contains rows for all
possible haplotypes</p>
</td></tr>
<tr><td><code id="inferHaplotypes_+3A_maxparcombs">maxparcombs</code></td>
<td>
<p>Parent 1 and 2 both may have multiple possible haplotype
combinations. For each pair of haplotype combinations (one from P1 and one
from P2) the expected FS segregation must be checked against the observed.
This may take a long time if many such combinations need to be checked.
This parameter sets a limit to the number of allowed combinations per
haploblock; default 150000 takes about 45 min.</p>
</td></tr>
<tr><td><code id="inferHaplotypes_+3A_minpseg">minPseg</code></td>
<td>
<p>default 1e-8. The minimum P-value of a chisquared test for
segregation in FS families. The best solution for an FS family is selected
based on a combination of P-value and number of required haplotypes, among all
candidate solutions with a P-value of at least minPseg. If no such solution
is found the FS and its parents are treated as unrelated material</p>
</td></tr>
<tr><td><code id="inferHaplotypes_+3A_knownhap">knownHap</code></td>
<td>
<p>integer vector with haplotype numbers (haplotypes that must be
present according to prior inference or knowledge, numbers refer to rows of
matrix produced by allHaplotypes); default integer(0), i.e. no known
haplotypes</p>
</td></tr>
<tr><td><code id="inferHaplotypes_+3A_progress">progress</code></td>
<td>
<p>if TRUE, and new haplotype combinations need to be calculated,
and the number of markers and the ploidy are both &gt;= 6, progress is indicated
by printed messages</p>
</td></tr>
<tr><td><code id="inferHaplotypes_+3A_printtimes">printtimes</code></td>
<td>
<p>if TRUE, the time needed to process each haploblock is
printed</p>
</td></tr>
<tr><td><code id="inferHaplotypes_+3A_ahcdir">ahcdir</code></td>
<td>
<p>a single directory, or not specified.
inferHaplotypes uses lists that for each combination of marker
dosages give all possible combinations of haplotype dosages. These lists
(ahclist and ahccompletelist) are loaded and saved at the directory
specified by ahcdir. If no ahcdir is specified it is set to the current
working directory.<br />
If an ahclist or ahccompletelist for the correct ploidy is already in
GlobalEnv this is used and no new list is loaded, even if ahcdir is specified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First we consider the case where one or more FS families and their
parents are present in the set of samples. In that case, initially the
possible haplotype configurations of the parents are determined.
From that, all their possible gametes (assuming polysomic
inheritance) are calculated and all possible FS haplotype configurations.
Comparing this with the observed FS marker dosages the most likely parental
and FS configurations are found.<br />
It is possible that multiple parental combinations can explain the observed
marker dosages in the FS. In that case, if one is clearly more likely and/or
needs less haplotypes, that one is chosen. If there is no clear best solution
still the parents and FS individuals that have the same haplotype
configuration over all likely solutions are assigned that configuration.<br />
For FS where no good solution is found (because of an error in the marker
dosages of a parent, or because the correct solution was not considered) the
parents and individuals will be considered as unrelated material.<br />
If several FS families share common parents they are treated as a group,
and only solutions are considered that are acceptable for all families
in the group.<br />
Finally (or if no FS families are present, immediately) the other samples
are haplotyped, which are considered as unrelated material. If FS families
have been solved the haplotypes in their parents are considered &quot;known&quot;,
and known haplotypes can also be supplied (parameter knownHap). For these
samples we consecutively add haplotypes that must be present in a minimum
number of individuals, always trying to minimize the number of needed
haplotypes.<br />
InferHaplotypes uses tables that, for each combination of dosages of the
markers in the haploblock, list all haplotype combinations (ahc) that
result in these marker dosages. In principle inferHaplotypes uses a list
(ahccompletelist) that, for a given ploidy, has all the haplotype combinations
for haploblocks from 1 up to some maximum number of markers. This list can be
computed with function build_ahccompletelist. If this list is not available
(or is some haploblocks contain more markers than the list), the ahc for
the (extra) marker.<br />
See the PolyHaplotyper vignette for an illustrated explanation.
</p>


<h3>Value</h3>

<p>a list with for each haploblock one item that itself is a list
with items:<br />
message; if this is &quot;&quot; the haploblock is processed and further
elements are present; else this message says why the haploblock was
skipped (currently only if it contains too many markers)<br />
hapdos: a matrix with the dosages of each haplotype (in rows) for each
individual (in columns). For each individual the haplotype dosages
sum to the ploidy. If dropUnused is TRUE Only the haplotypes that
occur in the population are shown, else all haplotypes<br />
mrkdids: a vector of the mrkdid (marker dosage ID) for each individual
(each combination of marker dosages has its own ID; if any of the
markers has an NA dosage the corresponding mrkdid is also NA).<br />
The mrkdids can be converted to the marker dosages with function
mrkdid2mrkdos.<br />
markers: a vector with the names of the markers in the haploblock<br />
imputedGeno: a matrix in the same format as param mrkDosage, with one row
for each marker in the haploblock and one column per imputed
individual, with the dosages of the markers. These are the individuals
that have incomplete data in mrkDosage but where the available marker
dosages match only one of the expected marker genotypes in the FS
family (only individuals in FS families are imputed). It is possible
that an individual with imputed marker dosages is not haplotyped (as
is the case for individuals with complete marker data) if the
marker dosages match different possible haplotype combinations.
The next elements are only present if one or more FS families were
specified:<br />
FSfit: a logical vector with one element per FS family; TRUE if a (or
more than one) acceptable solution for the FS is found (although
if multiple solution are found they might not be used if unclear
which one is the best solution). (Even if no
solution was found for an FS, still its individuals may have a
haplotype combination assigned ignoring their pedigree)<br />
FSmessages: a character vector with one item per FS family: any
message relating to the fitting of a model for that FS,
not necessarily an error<br />
FSpval: a vector of the chi-squared P-value associated with the selected
FS model for each FS family, or the maximum P value over all
models in case none was selected<br />
If for new combinations of marker dosages the possible haplotype combinations
have to be calculated, an ahclist file is written to ahcdir
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# this example takes about 1 minute to run:
data(PolyHaplotyper_small)
results &lt;- inferHaplotypes(mrkDosage=phdos, ploidy=6,
haploblock=phblocks, parents=phpar, FS=phFS)
names(results)
names(results[[1]])

</code></pre>

<hr>
<h2 id='make.Happyinf.input'>convert PolyHaplotyper input data to Happy-inf format</h2><span id='topic+make.Happyinf.input'></span>

<h3>Description</h3>

<p>convert PolyHaplotyper input data to Happy-inf format
for a single haploblock
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.Happyinf.input(mrkDosage, indiv=NULL, haploblock,
ploidy, fname)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make.Happyinf.input_+3A_mrkdosage">mrkDosage</code></td>
<td>
<p>matrix or data.frame of allele dosages; same as input for
inferHaplotypes. Markers are in rows, individuals in columns, each cell has
a marker dosage. All marker dosages must be in 0:ploidy or NA</p>
</td></tr>
<tr><td><code id="make.Happyinf.input_+3A_indiv">indiv</code></td>
<td>
<p>the names of the individuals to include in the Happy-inf
input data. Default NULL includes all individuals</p>
</td></tr>
<tr><td><code id="make.Happyinf.input_+3A_haploblock">haploblock</code></td>
<td>
<p>a list of character vectors. The names are the names of the
haploblocks, the character vectors have the names of the markers in each
haploblock. Only the markers in haploblock will be included in the
Happy-inf input data</p>
</td></tr>
<tr><td><code id="make.Happyinf.input_+3A_ploidy">ploidy</code></td>
<td>
<p>single integer: the ploidy level</p>
</td></tr>
<tr><td><code id="make.Happyinf.input_+3A_fname">fname</code></td>
<td>
<p>filename of a tab-separated output file: this will contain the
data in Happy-inf format (the saved data.frame is also the return value).
If &quot;&quot; no file is written</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame in the Happy-inf input format: a header row with
&quot;SNPID&quot;, &quot;block&quot; and names of the individuals and one row per marker, with
only the individuals, markers and blocks as specified.
#'SNPID has the marker names, &quot;Block&quot; the haploblock names. All markers
of a haploblock are in contiguous rows. Missing dosages
are represented by &quot;NA&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PolyHaplotyper_small)
HAPin &lt;- make.Happyinf.input(mrkDosage=phdos, haploblock=phblocks,
                            ploidy=6, fname="")
HAPin[,1:8]
</code></pre>

<hr>
<h2 id='make.SATlotyper.input'>convert PolyHaplotyper marker data to SATlotyper format</h2><span id='topic+make.SATlotyper.input'></span>

<h3>Description</h3>

<p>convert PolyHaplotyper marker data (input) to SATlotyper
format for a single haploblock.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.SATlotyper.input(mrkDosage, indiv=NULL, markers,
ploidy, phenotype=0, fname)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make.SATlotyper.input_+3A_mrkdosage">mrkDosage</code></td>
<td>
<p>matrix or data.frame of allele dosages; same as input for
inferHaplotypes. Markers are in rows, individuals in columns, each cell has
a marker dosage. All marker dosages must be in 0:ploidy or NA</p>
</td></tr>
<tr><td><code id="make.SATlotyper.input_+3A_indiv">indiv</code></td>
<td>
<p>the names of the individuals to include in the ShesisPlus
input data. Default NULL includes all individuals</p>
</td></tr>
<tr><td><code id="make.SATlotyper.input_+3A_markers">markers</code></td>
<td>
<p>character vector with the names of the markers in the
haploblock; all must occur in mrkDosage</p>
</td></tr>
<tr><td><code id="make.SATlotyper.input_+3A_ploidy">ploidy</code></td>
<td>
<p>single integer: the ploidy level</p>
</td></tr>
<tr><td><code id="make.SATlotyper.input_+3A_phenotype">phenotype</code></td>
<td>
<p>vector with the phenotypes of all individuals, in order
of the columns of dosmat; default 0</p>
</td></tr>
<tr><td><code id="make.SATlotyper.input_+3A_fname">fname</code></td>
<td>
<p>filename of a *.csv output file: this will contain the data
in the SATlotyper format (the saved data.frame is also the return value).
If &quot;&quot; no file is written</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame in the SATlotyper input format: a header row with
&quot;Genotype&quot; and the marker names, and one row per individual with the
individual name plus for each marker the genotype as a sorted
string of &lt;ploidy&gt; A's and B's, or &lt;ploidy&gt; N's
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PolyHaplotyper_small)
SATin &lt;- make.SATlotyper.input(mrkDosage=phdos, markers=phblocks[[1]],
                              ploidy=6, fname="")
head(SATin)
</code></pre>

<hr>
<h2 id='make.ShesisPlus.input'>convert PolyHaplotyper marker data to ShesisPlus format</h2><span id='topic+make.ShesisPlus.input'></span>

<h3>Description</h3>

<p>convert PolyHaplotyper marker data (input) to ShesisPlus
format for a single haploblock.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.ShesisPlus.input(mrkDosage, indiv=NULL, markers,
ploidy, phenotype=0, fname="")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make.ShesisPlus.input_+3A_mrkdosage">mrkDosage</code></td>
<td>
<p>matrix or data.frame of allele dosages; same as input for
inferHaplotypes. Markers are in rows, individuals in columns, each cell has
a marker dosage. All marker dosages must be in 0:ploidy or NA</p>
</td></tr>
<tr><td><code id="make.ShesisPlus.input_+3A_indiv">indiv</code></td>
<td>
<p>the names of the individuals to include in the ShesisPlus
input data. Default NULL includes all individuals</p>
</td></tr>
<tr><td><code id="make.ShesisPlus.input_+3A_markers">markers</code></td>
<td>
<p>character vector with the names of the markers in the
haploblock; all must occur in mrkDosage</p>
</td></tr>
<tr><td><code id="make.ShesisPlus.input_+3A_ploidy">ploidy</code></td>
<td>
<p>single integer: the ploidy level</p>
</td></tr>
<tr><td><code id="make.ShesisPlus.input_+3A_phenotype">phenotype</code></td>
<td>
<p>vector with the phenotypes of all individuals, in order
of the columns of dosmat; default 0</p>
</td></tr>
<tr><td><code id="make.ShesisPlus.input_+3A_fname">fname</code></td>
<td>
<p>filename of the output file: this will contain the data
in the ShesisPlus format (the saved data.frame is also the return value).
If &quot;&quot; (default) no file is written</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ShesisPlus needs the data formatted as: 1 column with names of
individuals, 1 column with the phenotypes (with missing values represented
as &quot;NA&quot;), and for each of the selected markers &lt;ploidy&gt; columns,
with the (unphased) marker alleles. Here we use only biallelic markers;
their alleles are indicated by 1 and 2 for the ref and alt allele,
and 0 for missing data. <br />
The contents of file fname can be pasted into the input data box of
the ShesisPlus web interface at http://shesisplus.bio-x.cn/SHEsis.html
</p>


<h3>Value</h3>

<p>a data.frame in the described ShesisPlus input format
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PolyHaplotyper_small)
SSPin &lt;- make.ShesisPlus.input(mrkDosage=phdos, markers=phblocks[[1]],
                              ploidy=6)
SSPin[1:6,1:8]
</code></pre>

<hr>
<h2 id='mergeReplicates'>merge replicate samples in dosage matrix</h2><span id='topic+mergeReplicates'></span>

<h3>Description</h3>

<p>merge replicate samples in dosage matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeReplicates(mrkDosage, replist, solveConflicts=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mergeReplicates_+3A_mrkdosage">mrkDosage</code></td>
<td>
<p>a dosage matrix with markers in rows and individuals in columns.
row names are marker names, column names are individual names.</p>
</td></tr>
<tr><td><code id="mergeReplicates_+3A_replist">replist</code></td>
<td>
<p>a list of character vectors, each of which has the sample names
of a set of replicates</p>
</td></tr>
<tr><td><code id="mergeReplicates_+3A_solveconflicts">solveConflicts</code></td>
<td>
<p>if TRUE (default) and there are conflicting dosage
assignments between replicates for the same marker, the one with highest
frequency is used, provided the total freq of other dosages = 1 OR
&lt;= 10% of the frequency of the most frequent dosage. If
solveConflicts is FALSE and there are conflicting dosages, the consensus for
that marker will be NA</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function merges all sets of replicates, each to one column.
The column name of the one retained column is the first one for that set
in replist.<br />
For each set of replicates it calls getConsensusmrkDosage
</p>


<h3>Value</h3>

<p>a version of mrkDosage in which only one column of each set of replicates
is retained; this column (the first in its set as specified in replist)
now has the consensus scores over all replicates. Also, if mrkDosage was a
data.frame, it is converted into a matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># construct a dosage matrix with some missing data:
dosmat &lt;-
 matrix(c(rep(c(3,0,1),3), rep(c(1,1,2),4)), nrow=3,
        dimnames=list(c("mrk1","mrk2","mrk3"),
                      c("a1","a2","a3", "b1","b2","b3","b4")))
ix &lt;- matrix(c(1,1, 3,1, 2,2, 1,3, 2,4, 1,5, 2,6), ncol=2, byrow=TRUE)
dosmat[ix] &lt;- NA
dosmat
# define 2 sets of replicates:
reps &lt;- list(c("a1","a2","a3"), c("b1","b2","b3","b4"))
# merge:
mergeReplicates(mrkDosage=dosmat, replist=reps)
# introduce a conflicting dosage:
dosmat[3,2] &lt;- 2
# merge:
mergeReplicates(mrkDosage=dosmat, replist=reps)
</code></pre>

<hr>
<h2 id='mrkdid2mrkdos'>get the marker dosages from mrkdids (marker dosage IDs)</h2><span id='topic+mrkdid2mrkdos'></span>

<h3>Description</h3>

<p>get the marker dosages from mrkdids (marker dosage IDs)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mrkdid2mrkdos(dosageIDs, nmrk, ploidy, mrknames=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mrkdid2mrkdos_+3A_dosageids">dosageIDs</code></td>
<td>
<p>vector of marker-dosage-combination IDs (mrkdid)</p>
</td></tr>
<tr><td><code id="mrkdid2mrkdos_+3A_nmrk">nmrk</code></td>
<td>
<p>character vector of marker names in the haploblock</p>
</td></tr>
<tr><td><code id="mrkdid2mrkdos_+3A_ploidy">ploidy</code></td>
<td>
<p>the ploidy level, a single positive integer</p>
</td></tr>
<tr><td><code id="mrkdid2mrkdos_+3A_mrknames">mrknames</code></td>
<td>
<p>a vector of nmrk marker names (default NULL): if not NULL
these are used as rownames of the returned matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with in columns the marker dosages corresponding to the
marker dosageIDs, with these mrkdids as colnames, and one row per marker,
with marker names as rownames if mrknames are specified
</p>


<h3>Examples</h3>

<pre><code class='language-R'># dosages of 3 markers in 3 tetraploid individuals:
mrkdosg &lt;-
 matrix(c(1,2,2, 4,0,0, 3,0,2), nrow=3,
        dimnames=list(c("mrkA", "mrkB", "mrkC"), c("indiv1", "indiv2", "indiv3")))
# get the "marker dosage IDs":
dids &lt;- mrkdos2mrkdid(mrkDosage=mrkdosg, ploidy=4)
# convert dids back to marker dosages:
mrkdid2mrkdos(dosageIDs=dids, nmrk=3, ploidy=4, mrknames=c("mrkA", "mrkB", "mrkC"))
</code></pre>

<hr>
<h2 id='mrkdos2mrkdid'>get marker dosage IDs from marker dosages</h2><span id='topic+mrkdos2mrkdid'></span>

<h3>Description</h3>

<p>get marker dosage IDs (mrkdid) from marker dosages
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mrkdos2mrkdid(mrkDosage, indiv=NULL, ploidy, check=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mrkdos2mrkdid_+3A_mrkdosage">mrkDosage</code></td>
<td>
<p>matrix or data.frame. Markers are in rows, individuals in
columns, each cell has a marker dosage. Names of individuals are the column
names, marker names are the row names or (if a data.frame) in a column named
MarkerNames. All marker dosages must be in 0:ploidy or NA. If a data.frame,
additional columns may be present.</p>
</td></tr>
<tr><td><code id="mrkdos2mrkdid_+3A_indiv">indiv</code></td>
<td>
<p>NULL (default) or a character vector with names of individuals
to be selected. If NULL, all columns are selected;
if mrkDosage is a data.frame, that is probably not what is intended.</p>
</td></tr>
<tr><td><code id="mrkdos2mrkdid_+3A_ploidy">ploidy</code></td>
<td>
<p>all marker dosages are checked to be in 0:ploidy or NA</p>
</td></tr>
<tr><td><code id="mrkdos2mrkdid_+3A_check">check</code></td>
<td>
<p>if TRUE (default) checkmrkDosage is called. If FALSE it is
assumed that mrkDosage is a matrix (not a data.frame) and it is not checked.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>with ploidy==1 and (of course) all dosages 0 or 1 this function
returns the haplotype numbers for the haplotype specified by each column
</p>


<h3>Value</h3>

<p>a vector of marker dosage IDs, one for each column of mrkDosage:
each a number in 1:((ploidy+1)^nrow(mrkDosage)), NA for each column in
dosages where any of the dosages are NA
</p>


<h3>Examples</h3>

<pre><code class='language-R'># dosages of 3 markers in 3 tetraploid individuals:
mrkdosg &lt;-
 matrix(c(1,2,2, 4,0,0, 3,0,2), nrow=3,
        dimnames=list(c("mrkA", "mrkB", "mrkC"), c("indiv1", "indiv2", "indiv3")))
# get the "marker dosage IDs":
dids &lt;- mrkdos2mrkdid(mrkDosage=mrkdosg, ploidy=4)
# convert dids back to marker dosages:
mrkdid2mrkdos(dosageIDs=dids, nmrk=3, ploidy=4, mrknames=c("mrkA", "mrkB", "mrkC"))
</code></pre>

<hr>
<h2 id='overviewByFS'>generate an overview of the results by haploblock and by FS family</h2><span id='topic+overviewByFS'></span>

<h3>Description</h3>

<p>generate an overview of the results by haploblock and by
FS family
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overviewByFS(haploblock, parents, FS, hapresults)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="overviewByFS_+3A_haploblock">haploblock</code></td>
<td>
<p>a list of character vectors. The names are the names of the
haploblocks, the character vectors have the names of the markers in each
haploblock.</p>
</td></tr>
<tr><td><code id="overviewByFS_+3A_parents">parents</code></td>
<td>
<p>a matrix of two colums and one row per FS, containing the names
of the two parents of each FS</p>
</td></tr>
<tr><td><code id="overviewByFS_+3A_fs">FS</code></td>
<td>
<p>a list of character vectors with the names of the samples for
each FS</p>
</td></tr>
<tr><td><code id="overviewByFS_+3A_hapresults">hapresults</code></td>
<td>
<p>a list as returned by inferHaplotypes, with one
item per haploblock, containing at least all those in the list
specified by haploblock</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with two items:<br />
- ovw: an integer matrix with one row per haploblock and the following
columns:<br />
* nmrk: the number of markers in the haploblock<br />
* nhap: the number of different haplotypes assigned over all individuals
(NA if no solution was found for this haplotype; the reason for that is
listed in the first column of item messages of the return value)<br />
* for each FS family a set of 6 columns:<br />
+ parmrk (0, 1 or 2: the number of parents with complete marker data)<br />
+ fit (0=FALSE or 1=TRUE), indicating if a solution for the FS was found
based on polysomic inheritance)<br />
+ mrk: the number of FS progeny with complete marker data<br />
+ imp: the number of FS progeny where complete marker data were imputed<br />
+ hap: the number of FS progeny with assigned haplotype combinations.
hap will be less than the mrk value if the same FS marker genotype can be
produced with different combinations of haplotypes that are all compatible
with the parental haplotype combinations) or if some FS marker genotypes
cannot be produced by the inferred parental haplotype combinations<br />
+ P: the chi-squared P-value of the best fitting solution, even if this is
discarded because of lack of fit).<br />
* For &quot;rest&quot; (all individuals that are not part of the FS's or their
parents) and &quot;all&quot; (all individuals) there are also columns mrk and hap,
and for &quot;all&quot; there is also a column imp, similar to those for the
FS families. The numbers for &quot;all&quot; are the sums
of those for the FS families, the FS parents (some FS may share a parent
but shared parents are counted only one) and the &quot;rest&quot;.<br />
- messages  : a character matrix with one row per haploblock and the following
columns:<br />
* haploblock: the reason why there is no solution for the
haploblock (&quot;&quot; if there is a solution)
* one column for each FS family with a possible message or &quot;&quot;. A message
can indicate a failure to find a solution for the FS family but may also
describe less significant problems, such as some progeny with unexpected
marker dosages etc.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PolyHaplotyper_small)
overviewByFS(haploblock=phblocks, parents=phpar, FS=phFS,
            hapresults=phresults)
</code></pre>

<hr>
<h2 id='padded'>pad an integer (prefix with zeroes to a fixed length)</h2><span id='topic+padded'></span>

<h3>Description</h3>

<p>pad an integer (prefix with zeroes to a fixed length)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>padded(x, maxx=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="padded_+3A_x">x</code></td>
<td>
<p>vector of non-negative integers</p>
</td></tr>
<tr><td><code id="padded_+3A_maxx">maxx</code></td>
<td>
<p>a single integer to whose nchar all x elements will be padded;
if 0 (default) the largest value in x will be used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector representing the values of x left-padded with 0's
to the length of integer maxx or of max(x)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>padded(c(21, 1, 121, NA, 0))
padded(c(21, 1, 121, NA, 0), maxx=1000)
</code></pre>

<hr>
<h2 id='pedigreeHapCheck'>check the consistency of haploblock genotypes over a pedigree</h2><span id='topic+pedigreeHapCheck'></span>

<h3>Description</h3>

<p>For all haploblocks, check whether the inheritance of inferred
haplotypes over the pedigree is consistent without or with allowing for
double reduction (DR), and assuming polysomic inheritance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pedigreeHapCheck(ped, mrkDosage, haploblock, hapresults)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pedigreeHapCheck_+3A_ped">ped</code></td>
<td>
<p>data.frame or matrix listing the pedigree. Column 1 has names of
all individuals (no duplicates, no NA), column 2 and 3 have the parents
(duplicates and NA allowed, also individuals with one known parent or
with two identical parents allowed). No sorting of the pedigree is needed.
All parents should also be listed as individuals; if that is not the case
the missing parents will be added as founders and a warning will be issued.</p>
</td></tr>
<tr><td><code id="pedigreeHapCheck_+3A_mrkdosage">mrkDosage</code></td>
<td>
<p>a matrix with one row for each marker
and one column for each individual, with the observed dosages. Individuals
with one or more NA dosages are considered to have no marker data. Individual
names are the colnames, no duplicates allowed; the set of individuals
needs not be the same as those in ped; individual names common to mrkDosage
and ped must be exactly identical (upper/lower case and whitespace included)</p>
</td></tr>
<tr><td><code id="pedigreeHapCheck_+3A_haploblock">haploblock</code></td>
<td>
<p>a list of character vectors. The names are the names of the
haploblocks, the character vectors have the names of the markers in each
haploblock</p>
</td></tr>
<tr><td><code id="pedigreeHapCheck_+3A_hapresults">hapresults</code></td>
<td>
<p>a list as returned by inferHaplotypes, with one
item per haploblock, containing at least all those in the list
specified by haploblock</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with two items:<br />
- ped_arr: a 3D logical array with dimensions individuals, diagnostics and
haploblocks. For each individual and each haploblock there are 4
diagnostics:<br />
* mrk: does the individual have complete marker dosage data?<br />
* imp: were the marker dosages for this individual imputed?<br />
* hap: is there a haplotype combination assigned to the individual?<br />
* noDR: does the haplotype genotype of the individual match that of its
parents, assuming polysomic inheritance but no Double Reduction? NA if the
individual or both its parents do not have a haplotype genotype assigned<br />
* withDR: as noDR, but allowing Double Reduction<br />
- parents_arr: a 3D integer array with dimensions parents (all individuals
that occur as parents in the pedigree), diagnostics and haploblocks.
For each parent and each haploblock there are 7 diagnostics:<br />
* par_mrkdata: 0=FALSE, 1=TRUE, does this parent have complete marker data?<br />
* par_hapdata: 0=FALSE, 1=TRUE, does this parent have a haplotype
genotype assigned?<br />
* totprogeny: how many first-generation progeny (children) does this parent
have (combined over all its matings, both as mother and as father)<br />
* prog_mrkdata: how many progeny have complete marker dosage data?<br />
* prog_hapdata: how many progeny have a haplotype combination assigned?<br />
* nonDRmatch: how many progeny have a haplotype combination that is
compatible with their parent's haplotype combinations, assuming polysomic
inheritance but no Double Reduction<br />
* DRmatch: as nonDRmatch, but also allowing DR<br />
Both ped_arr and parents_arr contain all haploblocks in haploblock, also
those skipped because of too many markers and those without any haplotyped
individuals. These can be excluded by excluding them from the haploblock list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PolyHaplotyper_small)
phchk &lt;- pedigreeHapCheck(ped=phped, mrkDosage=phdos, haploblock=phblocks,
                         hapresults=phresults)
# show the top of the ped_arr for haploblock 1:
phchk$ped_arr[1:6,,1]
# show the top of the parents_arr for haploblock 1:
phchk$parents_arr[1:6,,1]
</code></pre>

<hr>
<h2 id='pedigreeSim2PH'>convert the PedigreeSim true haplotypes to marker dosages and
haplotype dosages</h2><span id='topic+pedigreeSim2PH'></span>

<h3>Description</h3>

<p>convert the PedigreeSim true haplotypes to marker dosages and
haplotype dosages
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pedigreeSim2PH(ps_geno, haploblock, indiv=NULL, dropUnused=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pedigreeSim2PH_+3A_ps_geno">ps_geno</code></td>
<td>
<p>the filename of a *_genotypes.dat file as produced by
PedigreeSim, or a data.frame read from such a file (with a column marker,
followed by &lt;ploidy&gt; columns per individual with the marker alleles for each
homolog; the names of these columns must be &lt;indivname&gt;_&lt;homolog number&gt;).
ps_geno should not contain missing data (this will be true unless the
PedigreeSim output is midified)</p>
</td></tr>
<tr><td><code id="pedigreeSim2PH_+3A_haploblock">haploblock</code></td>
<td>
<p>a list of character vectors. The names are the names of the
haploblocks, the character vectors have the names of the markers in each
haploblock. Haplotype names are constructed from the haploblock names, which
are used as prefixes to which the (zero-padded) haplotype numbers are are
appended with separator '_'.<br />
All markers in haploblock must be present in ps_geno. If haploblock is NULL
only the marker dosages are generated, not the haplotype dosages.</p>
</td></tr>
<tr><td><code id="pedigreeSim2PH_+3A_indiv">indiv</code></td>
<td>
<p>the names of the individuals to be extracted; default NULL: all
individuals in ps_geno. If not NULL, all indiv must be present in ps_geno</p>
</td></tr>
<tr><td><code id="pedigreeSim2PH_+3A_dropunused">dropUnused</code></td>
<td>
<p>TRUE (default) if the returned matrix should only contain
rows for haplotypes that are present; if FALSE matrix contains rows for all
possible haplotypes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>if all alleles are in 0/1, these are kept. If only 2 allele symbols
occur in ps_geno all are converted (alphabetically) to 0/1 in
the same way (e.g. if the alleles are A and B, A -&gt; 0 and B -&gt; 1, even in
markers with only B's). If different allele symbols are used between
markers, per marker the (alphabetically or numerically) lowest -&gt; 0 and
the highest -&gt; 1.
So if more than two different allele symbols occur in ps_geno, and
one marker has only A and another only B alleles, both are converted
to 0's.<br />
in mrkDosage, the dosage of the alleles (converted to) 1 is reported
</p>


<h3>Value</h3>

<p>a list with 2 items:<br />
$mrkDosage: a matrix of marker dosages in the input format of inferHaplotypes,
with all markers that occur in haploblock, sorted according to haploblock,
and for the selected indiv in the specified order<br />
$haplist: (only if haploblock is not NULL) a list with one element for each
haploblock, similar to the
inferHaplotypes output). Each element is itself a list, with two components:<br />
$hapdos is a matrix with the haplotype dosages for that haploblock for each
individual<br />
$markers:  a vector with the names of
the markers in the haploblock in the output of inferHaplotypes
</p>

<hr>
<h2 id='phblocks'>List of markers per haploblock</h2><span id='topic+phblocks'></span>

<h3>Description</h3>

<p>A list with for each haploblock the names of the markers it
contains; used in manuals, stored in PolyHaplotyper_small.RData
</p>


<h3>Format</h3>

<p>a list with 2 character vectors
</p>

<hr>
<h2 id='phdos'>dosages of SNP alleles</h2><span id='topic+phdos'></span>

<h3>Description</h3>

<p>A matrix with the allele dosages for 8 SNPs in 661
samples; used in manuals, stored in PolyHaplotyper_small.RData
</p>


<h3>Format</h3>

<p>a data.frame with 30 rows (SNPs) and 663 columns. The first
two columns contain the SNP name and contig; the remaining columns
contain the allele dosages (integers in 0..6 or NA) of the SNPs in
661 samples
</p>

<hr>
<h2 id='phFS'>members of FS families</h2><span id='topic+phFS'></span>

<h3>Description</h3>

<p>A list with for each FS family the names of the individuals it
contains; used in manuals, stored in PolyHaplotyper_small.RData
</p>


<h3>Format</h3>

<p>a list with 4 vectors, each with the (here numeric) names of
the FS members
</p>

<hr>
<h2 id='phpar'>parents of FS families</h2><span id='topic+phpar'></span>

<h3>Description</h3>

<p>A matrix with the names of the parents of each FS family;
used in manuals, stored in PolyHaplotyper_small.RData
</p>


<h3>Format</h3>

<p>a matrix with 4 rows, 1 per FS family, and 2 columns, 1 for each
parent
</p>

<hr>
<h2 id='phped'>pedigree</h2><span id='topic+phped'></span>

<h3>Description</h3>

<p>A data.frame with a pedigree; used in manuals, stored in
PolyHaplotyper_small.RData
</p>


<h3>Format</h3>

<p>a data.frame with 661 rows (samples) and
4 columns: genotype, mother, father, sample_nr
</p>

<hr>
<h2 id='phresults'>haplotyping results</h2><span id='topic+phresults'></span>

<h3>Description</h3>

<p>A list with the results of function inferHaplotypes; used in
manuals, stored in PolyHaplotyper_small.RData
</p>


<h3>Format</h3>

<p>a list with 2 elements, one per haploblock; each element itself
a list with multiple components
</p>

<hr>
<h2 id='read.Happyinf.output'>read the haplotyping results from the Happy-inf output</h2><span id='topic+read.Happyinf.output'></span>

<h3>Description</h3>

<p>read the haplotyping results from the Happy-inf output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.Happyinf.output(file_prefix, dropUnused=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.Happyinf.output_+3A_file_prefix">file_prefix</code></td>
<td>
<p>the prefix for the output files generated by
Happy-inf (the value of the -o parameter)</p>
</td></tr>
<tr><td><code id="read.Happyinf.output_+3A_dropunused">dropUnused</code></td>
<td>
<p>TRUE (default) if the returned matrix should only contain
rows for haplotypes that are present; if FALSE matrix contains rows for all
possible haplotypes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function reads the &lt;file_prefix&gt;.stat.dat and
&lt;file_prefix&gt;.stats.dat files. The first contains one row per SNP marker,
grouped per haploblock and &lt;ploidy&gt; columns per individual with the SNP
haplotypes, where SNP alleles are represented as 0 or 1, or NA for unknown.
For one SNP, the &lt;ploidy&gt; alleles in an individual are all known or all
unknown It is possible that of the different SNPs in a haploblock
some are known and some are not; in the conversion to PolyHaplotyper format
all these partially known haplotypes are made unknown.
The latter file has a statistics &quot;mismatch&quot; and &quot;ratio&quot; for each individual /
haploblock combination; for their meaning see the Happyinf readme file.
</p>


<h3>Value</h3>

<p>a list with 2 items: <br />
$hapdos is a matrix with individuals in columns and haplotypes in rows,
giving the dosages of the haplotypes in each individual (summing to ploidy).
This is the same format as the hapdos components of the inferHaplotypes
results of PolyHaplotyper except that <br />
$stats is a matrix with individuals in rows (matching dosmat) and two rows
named mismatch and ratio.
</p>

<hr>
<h2 id='read.SATlotyper.output'>read the haplotyping results from the SATlotyper output</h2><span id='topic+read.SATlotyper.output'></span>

<h3>Description</h3>

<p>read the haplotyping results from the SATlotyper output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.SATlotyper.output(fname, output="", allelecodes=c("A", "B"),
sep, haploblockname="")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.SATlotyper.output_+3A_fname">fname</code></td>
<td>
<p>filename of an xml file produced by SATlotyper</p>
</td></tr>
<tr><td><code id="read.SATlotyper.output_+3A_output">output</code></td>
<td>
<p>character vector, console output of SATlotyper;
this contains a table of calculated haplotypes with more info
than the xml file</p>
</td></tr>
<tr><td><code id="read.SATlotyper.output_+3A_allelecodes">allelecodes</code></td>
<td>
<p>the codes used for the ref and alt SNP alleles in
make.SATlotyper.input, default &quot;A&quot; and &quot;B&quot;</p>
</td></tr>
<tr><td><code id="read.SATlotyper.output_+3A_sep">sep</code></td>
<td>
<p>the separator used in make.SATlotyper.input (SATlotyper cleverly
identifies this separator and uses it for its output), default tab</p>
</td></tr>
<tr><td><code id="read.SATlotyper.output_+3A_haploblockname">haploblockname</code></td>
<td>
<p>if not &quot;&quot; (default) the haplotype IDs are given as
&lt;haploblockname&gt;_&lt;hapnr&gt;, else just as &lt;hapnr&gt;, left_padded with zeroes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The xml file is parsed using the package XML. The resulting list has
3 items named source, bootstrapping and haplotyping. In this function source is
ignored and the results are obtained from haplotypings[[1]] (i.e. even if multiple
haplotypings were done only the first is extracted), with the haplotype
score from the bootstrapping item added to the haplotype.info.
</p>


<h3>Value</h3>

<p>a list with 3 items: <br />
$hapdos is a matrix with individuals in columns and haplotypes in rows,
giving the dosages of the haplotypes in each individual (summing to ploidy).
This is the same format as the hapdos components of the inferHaplotypes
results of PolyHaplotyper <br />
$haplotype.info is a data.frame that is a combination of information from two
or three tables:<br />
columns Haplotype and necessity are from element
haplotypings[[1]]$haplotypes in the xml file, <br />
column hapnr gives the PolyHaplotyper equivalents of the Haplotypes, <br />
column score is from element bootstrapping in the xml file, <br />
columns id, number, frequency, homozygous, necessary, distance and
neighbours are from (the console) output if present. <br />
The haplotype.info data.frame is ordered by hapnr. <br />
$HaplotypingScore is the single number in $haplotyping[[1]]$score.
</p>

<hr>
<h2 id='read.ShesisPlus.output'>Read the haplotyping results from the ShesisPlus output</h2><span id='topic+read.ShesisPlus.output'></span>

<h3>Description</h3>

<p>Read the haplotyping results from the ShesisPlus output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.ShesisPlus.output(SSPout, order.by=c("", "hapnr", "count")[2])
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.ShesisPlus.output_+3A_sspout">SSPout</code></td>
<td>
<p>filename of a text file with ShesisPlus output (as copied from
the web page produced by running ShesisPlus web interface
at http://shesisplus.bio-x.cn/SHEsis.html); or a character vector with the
same output</p>
</td></tr>
<tr><td><code id="read.ShesisPlus.output_+3A_order.by">order.by</code></td>
<td>
<p>how to order the rows of the hapstat data.frame. &quot;hapnr&quot; means
ordering by haplotype number, &quot;count&quot; means ordering by decreasing Total.count,
anything else results in no reordering. By default order by hapnr.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If present, the markernames and the haplotype statistics are read from
the file. ShesisPlus does not provide haplotype combinations for individuals
</p>


<h3>Value</h3>

<p>a list with 2 items: $markernames has the marker names in the markers in
the haploblock (if present in the file); hapstat contains the haplotype statistics
as read from the file with an additional (first) column hapnr: the haplotype
numbers as defined in PolyHaplotyper. The other columns are Haplotype (as sequences
of marker alleles), Total.count (of the haplotype over the whole population) and,
according to an email from Zhiqiang Li of 13-04-2020) BETA: Regression coefficient,
SE: Standard error, R2: Regression r-squared, T: t-distribution statistics,
P: p-value
</p>


<h3>Examples</h3>

<pre><code class='language-R'># we give a typical SSP output as character vector; instead we could also
# give the name of a text file
SSPout &lt;- c(
 " Please cite:",
 "",
 "    Shen, J. et al. SHEsisPlus, a toolset for genetic studies ...",
 "    Shi, Y. et al. SHEsis, a powerful software platform ...",
 "    Li, Z. et al. A partition-ligation-combination-subdivision ...",
 "",
 "if you find this tool useful in your research. Thanks!",
 "",
 "Haplotype Analysis:",
 "",
 "Haplotypes with frequency &lt;0.03 are ignored.",
 "Loci chosen for haplotype analysis: m1, m2, m3, m4",
 "Haplotype 	Total count 	Beta 	SE 	R2 	T 	p",
 "1122 	2232 	0.002 	0.01 	1.01e-04 	0.252 	0.8",
 "1222 	230 	-0.019 	0.017 	0.002 	-1.15 	0.25",
 "1221 	152 	-0.01 	0.024 	2.94e-04 	-0.43 	0.667",
 "2222 	288 	0.008 	0.02 	2.93e-04 	0.429 	0.667",
 "1121 	142 	-0.009 	0.022 	2.81e-04 	-0.42 	0.674"
)
read.ShesisPlus.output(SSPout)
</code></pre>

<hr>
<h2 id='run.SATlotyper'>A simple interface to run SATlotyper</h2><span id='topic+run.SATlotyper'></span>

<h3>Description</h3>

<p>A simple interface to run SATlotyper
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.SATlotyper(path_to_SATlotyper, infile, outfile,
SAT_solver="sat4j.conf")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run.SATlotyper_+3A_path_to_satlotyper">path_to_SATlotyper</code></td>
<td>
<p>path to the folder where SATlotyper.jar and
the *.conf files of the SAT-solvers are located</p>
</td></tr>
<tr><td><code id="run.SATlotyper_+3A_infile">infile</code></td>
<td>
<p>name (and path) to the SATlotyper input file</p>
</td></tr>
<tr><td><code id="run.SATlotyper_+3A_outfile">outfile</code></td>
<td>
<p>name (and path) for the SATlotyper output file (an xml file)</p>
</td></tr>
<tr><td><code id="run.SATlotyper_+3A_sat_solver">SAT_solver</code></td>
<td>
<p>name of the *.conf file for the SAT-solver to use.
Default &quot;sat4j.conf&quot; because this works under both Windows and Linux.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function issues a system command to invoke SATlotyper.
Java and SATlotyper must be installed. This is just a simple interface for
convenience; for more control run SATlotyper directly from the command window.
</p>


<h3>Value</h3>

<p>The return is a list with elements:<br />
$cmd : the command passed to the system<br />
$result: screen output from SATlotyper; this
contains some extra info not present in the output xml file)<br />
The main result is the outfile
</p>

<hr>
<h2 id='showOneFS'>show marker and haplotype dosages for one FS family</h2><span id='topic+showOneFS'></span>

<h3>Description</h3>

<p>show marker and haplotype dosages for one FS family and its
parents
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showOneFS(FSnr, hbresults, mrkDosage, FS, parents)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="showOneFS_+3A_fsnr">FSnr</code></td>
<td>
<p>the number of the FS family (indexes the FS list and parents)</p>
</td></tr>
<tr><td><code id="showOneFS_+3A_hbresults">hbresults</code></td>
<td>
<p>a list with the haplotyping results for one haploblock:
one element of a list as returned by inferHaplotypes</p>
</td></tr>
<tr><td><code id="showOneFS_+3A_mrkdosage">mrkDosage</code></td>
<td>
<p>a matrix of marker dosages, may contain rows for more
markers than only those in the current haploblock (the relevant markers are
specified in the hbresults list)</p>
</td></tr>
<tr><td><code id="showOneFS_+3A_fs">FS</code></td>
<td>
<p>a list of which each item is a (character) vector with the
names of the individuals in that FS family</p>
</td></tr>
<tr><td><code id="showOneFS_+3A_parents">parents</code></td>
<td>
<p>a (character) matrix with 2 columns and one row for each
FS family in FS, with the names of the two parents of each family</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with 3 elements:<br />
$mrkdat: a matrix with info on the marker dosages distribution in the FS. The
first two columns are for the parents: the parent name is between (brackets)
in the column name, their mrkdid (marker dosage ID) in row 1 and their marker
dosages below that. The remaining columns are for the different mrkdids
observed in the FS: the mrkdid itself in the column name, its frequency in
row 1 and its marker dosages below that. The final column gives the frequency
of individuals with one or more missing marker dosages.<br />
$hapdat: a matrix with similar layout as mrkdat, but now with the haplotype
dosages rather than the marker dosages. Some mrkdids (columns) may not have
a haplotype dosage combination assigned (if multiple possible haplotype
combinations result in the same marker dosages)<br />
usedhap: a matrix with the dosage (0 or 1) of each marker in each of the
used haplotypes; haplotype nrs in columns, markers in rows
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PolyHaplotyper_small)
# show the results of the first FS family in the first haploblock:
showOneFS(FSnr=1, hbresults=phresults[[1]], mrkDosage=phdos,
         FS=phFS, parents=phpar)

</code></pre>

<hr>
<h2 id='totHapcombCount'>calculate the total nr of possible haplotype combinations</h2><span id='topic+totHapcombCount'></span>

<h3>Description</h3>

<p>calculate the total nr of possible haplotype combinations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>totHapcombCount(ploidy, nmrk)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="totHapcombCount_+3A_ploidy">ploidy</code></td>
<td>
<p>a vector of 1 or more ploidy levels</p>
</td></tr>
<tr><td><code id="totHapcombCount_+3A_nmrk">nmrk</code></td>
<td>
<p>a vector of 1 or more numbers of markers per haploblock</p>
</td></tr>
</table>


<h3>Details</h3>

<p>nmrk is used to calculate the total number of possible haplotypes
= 2^nmrk. The shorter vector of ploidy and nmrk is recycled.
</p>


<h3>Value</h3>

<p>a vector with the number of possible haplotype combinations for
each pair of ploidy and nmrk values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>totHapcombCount(ploidy=4, nmrk=c(1:8))
</code></pre>

<hr>
<h2 id='usedhap'>Find all used (inferred) haplotypes</h2><span id='topic+usedhap'></span>

<h3>Description</h3>

<p>Find all haplotypes for a haploblock that were inferred to be
present in the population (i.e. all haplotypes used for haplotyping any of
the individuals)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>usedhap(hapresults, haploblock)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="usedhap_+3A_hapresults">hapresults</code></td>
<td>
<p>list as returned by inferhaplotypes, or one element
of such a list (i.e. the results for one haploblock)</p>
</td></tr>
<tr><td><code id="usedhap_+3A_haploblock">haploblock</code></td>
<td>
<p>if hapresults is one element of the return value of
inferHaplotypes, haploblock should be missing of NULL; else haploblock is
a single value indicating the haploblock: either its name of its index
in hapresults</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function works with the results of inferHaplotypes; the setting
of dropUnused does not affect this function
</p>


<h3>Value</h3>

<p>an array with the haplotypes that are used in the
population. The haplotypes are in columns, with the haplotype numbers as
colnames; the markers are in rows.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(PolyHaplotyper_small)
# show the composition of haplotypes inferred to be present
# in the first haploblock:
usedhap(hapresults=phresults, haploblock=1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
