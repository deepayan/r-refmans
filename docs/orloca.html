<!DOCTYPE html><html><head><title>Help for package orloca</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {orloca}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#orloca-package'><p>Operations Research LOCational Analysis Models</p></a></li>
<li><a href='#andalusia'><p>Cities of Andalusia</p></a></li>
<li><a href='#as-methods'><p>as-methods</p></a></li>
<li><a href='#as.data.frame.loca.p'><p>as.data.frame.loca.p</p>
S3 method to convert from loca.p to data.frame</a></li>
<li><a href='#as.loca.p'><p>as.loca.p</p>
The following is for S3 compatibility, mainly for documentation check</a></li>
<li><a href='#as.loca.p.data.frame'><p>as.loca.p.data.frame</p>
S3 method to convert from data.frame to loca.p</a></li>
<li><a href='#as.loca.p.matrix'><p>as.loca.p.matrix</p>
S3 method to convert from matrix to loca.p</a></li>
<li><a href='#as.matrix.loca.p'><p>as.matrix.loca.p</p>
S3 method to convert from loca.p to matrix</a></li>
<li><a href='#contour.loca.p'><p>Plots of the min-sum objective function</p></a></li>
<li><a href='#distsum'><p>Computes distsum function</p></a></li>
<li><a href='#distsumgra'><p>Computes the gradient of distsum function</p></a></li>
<li><a href='#distsuml2'><p>distsuml2 and distsuml2gra at orloca package</p></a></li>
<li><a href='#distsuml2min'><p>distsuml2min at orloca package</p></a></li>
<li><a href='#distsumlp'><p>distsumlp and distsumlpgra at orloca package</p></a></li>
<li><a href='#distsumlpmin'><p>distsumlpmin at orloca package</p></a></li>
<li><a href='#distsummin'><p>Returns the solution of the minimization problem</p></a></li>
<li><a href='#loca.p'><p>loca.p class for Operations Research LOCational Analysis</p></a></li>
<li><a href='#paquete-orloca'><p>Modelos de Investigacion Operativa para el Analisis de Localizacion (Operations Research LOCational Analysis Models)</p></a></li>
<li><a href='#persp.loca.p'><p>Plots of the min-sum objective function</p></a></li>
<li><a href='#plot'><p>plot of loca.p class objects</p></a></li>
<li><a href='#rloca.p'><p>Random instances generator of loca.p class object</p></a></li>
<li><a href='#zsum'><p>zsum</p></a></li>
<li><a href='#zsumgra'><p>zsumgra</p></a></li>
<li><a href='#zsummin'><p>zsummin</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Depends:</td>
<td>methods, png, ucminf</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, graphics, knitr, rmarkdown, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>orloca.es, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Title:</td>
<td>Operations Research LOCational Analysis Models</td>
</tr>
<tr>
<td>Version:</td>
<td>5.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-31</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Author:</td>
<td>Manuel Munoz-Marquez &lt;manuel.munoz@uca.es&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Manuel Munoz-Marquez &lt;manuel.munoz@uca.es&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Objects and methods to handle and solve the min-sum location problem, also known as Fermat-Weber problem. The min-sum location problem search for a point such that the weighted sum of the distances to the demand points are minimized. See "The Fermat-Weber location problem revisited" by Brimberg, Mathematical Programming, 1, pg. 71-76, 1995. &lt;<a href="https://doi.org/10.1007%2FBF01592245">doi:10.1007/BF01592245</a>&gt;.
	     General global optimization algorithms are used to solve the problem, along with the adhoc Weiszfeld method, see "Sur le point pour lequel la Somme des distances de n points donnes est minimum", by Weiszfeld, Tohoku Mathematical Journal, First Series, 43, pg. 355-386, 1937 or "On the point for which the sum of the distances to n given points is minimum", by E. Weiszfeld and F. Plastria, Annals of Operations Research, 167, pg. 7-41, 2009. &lt;<a href="https://doi.org/10.1007%2Fs10479-008-0352-z">doi:10.1007/s10479-008-0352-z</a>&gt;.</td>
</tr>
<tr>
<td>Language:</td>
<td>en, es</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://knuth.uca.es/orloca/">http://knuth.uca.es/orloca/</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Repository/R-Forge/Project:</td>
<td>orloca</td>
</tr>
<tr>
<td>Repository/R-Forge/Revision:</td>
<td>64</td>
</tr>
<tr>
<td>Repository/R-Forge/DateTimeStamp:</td>
<td>2024-02-01 10:47:09</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-07 13:20:02 UTC</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-01 11:05:21 UTC; rforge</td>
</tr>
</table>
<hr>
<h2 id='orloca-package'>Operations Research LOCational Analysis Models</h2><span id='topic+orloca'></span><span id='topic+orloca-package'></span>

<h3>Description</h3>

<p>Objects and methods to handle and solve the min-sum location problem, also known as Fermat-Weber problem.
</p>


<h3>Details</h3>

<pre>

Package:   orloca

Type:      Package

Version:   5.6

Date:      2024-01-31

License:   GPL (&gt;= 3)
</pre>
<p>The min-sum location problem search for a point such that the weighted sum of the distances to the demand points are minimized. See &quot;The Fermat-Weber location problem revisited&quot; by Brimberg, Mathematical Programming, 1, pg. 71-76, 1995, <a href="https://doi.org/10.1007/BF01592245">doi:10.1007/BF01592245</a>.
</p>
<p>General global optimization algorithms are used to solve the problem, along with the adhoc Weiszfeld method, see &quot;Sur le point pour lequel la Somme des distances de n points donnes est minimum&quot;, by E. Weiszfeld, Tohoku Mathematical Journal, First Series, 43, pg. 355-386, 1937 or &quot;On the point for which the sum of the distances to n given points is minimum&quot;, by E. Weiszfeld and F. Plastria, Annals of Operations Research, 167, pg. 7-41, 2009, <a href="https://doi.org/10.1007/s10479-008-0352-z">doi:10.1007/s10479-008-0352-z</a>.
</p>
<p>The package provides a class <code>loca.p</code> that represents a location problem with a finite set of demand points on the plane.
Also, it is possible to plot the points and the objective function.
Such objective function is the total weighted distances travelled by all the customers to the service.
</p>
<p>Non-planar location problems could be handle in future versions of the package.
</p>
<p>For a demo, load the package with the instruction <code>library(orloca)</code>, and run the demo executing the instruction <code>demo(orloca)</code>.
</p>
<p>The package is ready for internationalization. The author kindly ask for translated version of the .mo file to include in the package.
</p>


<h3>Author(s)</h3>

<p>Manuel Munoz-Marquez &lt;manuel.munoz@uca.es&gt;
</p>
<p>Mantainer: Manuel Munoz-Marquez &lt;manuel.munoz@uca.es&gt;
</p>


<h3>References</h3>

<p>[1] Brimberg, J. <em>The Fermat-Weber location problem revisited</em>, Mathematical Programming, 1, pg. 71-76, 1995. <a href="https://doi.org/10.1007/BF01592245">doi:10.1007/BF01592245</a>.
</p>
<p>[2] Love, R. F., Morris, J. G., Wesolowsky, G. O. <em>Facilities Location: Chapter 2: Introduction to Single-Facility Location</em>, 1988, North-Holland. ISBN: 0-444-01031-9.
</p>
<p>[3] Weiszfeld, E. and Plastria, F. <em>On the point for which the sum of the distances to n given points is minimum</em>, Annals of Operations Research, 167, pg. 7-41, 2009, <a href="https://doi.org/10.1007/s10479-008-0352-z">doi:10.1007/s10479-008-0352-z</a>.
</p>
<p>[4] <a href="http://knuth.uca.es/orloca/">http://knuth.uca.es/orloca/</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="http://knuth.uca.es/orloca/">http://knuth.uca.es/orloca/</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># A new unweighted loca.p object
o &lt;- loca.p(x = c(-1, 1, 1, -1), y = c(-1, -1, 1, 1))

# Compute the sum of distances to point (3, 4)
# [1] 20.39384
distsum(o, 3, 4)

# Compute the sum of distances to point (3, 4) using lp norm with p = 2.5
# [1] 19.27258
distsum(o, 3, 4, lp = 2.5)

# Solve the optimization problem
# [1] 0 0
distsummin(o)

# Contour plot
contour(o)

# Run a demo of the package
demo(orloca)

</code></pre>

<hr>
<h2 id='andalusia'>Cities of Andalusia</h2><span id='topic+andalusia'></span>

<h3>Description</h3>

<p>The 'andalusia' data frame has 12 rows and 4 columns, which are the geographical position of the main capital cities of andalusia.
</p>


<h3>Format</h3>

<p><code>name</code>: The name of the city or relative position label.
</p>
<p><code>x</code>: The x coordinate of points.
</p>
<p><code>y</code>: The y coordinate of points.
</p>
<p><code>city</code>: If yes the point is a city in other case is a limit.
</p>


<h3>Usage</h3>

<p>data('andalusia')
</p>


<h3>Source</h3>

<p>Data are taken from wikipedia.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+orloca-package">orloca-package</a></code>.
</p>

<hr>
<h2 id='as-methods'>as-methods</h2><span id='topic+as-methods'></span><span id='topic+as.data.frame'></span><span id='topic+as.matrix'></span><span id='topic+as.loca.p+2Cdata.frame-method'></span><span id='topic+as.loca.p+2Cmatrix-method'></span>

<h3>Description</h3>

<p>Conversions between loca.p class and some others classes
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as-methods_+3A_x">x</code></td>
<td>
<p>is the object to convert to the new class object.</p>
</td></tr>
<tr><td><code id="as-methods_+3A_row.names">row.names</code></td>
<td>
<p>Unused.</p>
</td></tr>
<tr><td><code id="as-methods_+3A_optional">optional</code></td>
<td>
<p>Unused.</p>
</td></tr>
<tr><td><code id="as-methods_+3A_...">...</code></td>
<td>
<p>Other arguments, unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods to convert from and to <code>loca.p</code> class.
</p>
<p>NA's  values are not allowed in any of the arguments.
</p>
<p>The <code>matrix</code> or <code>data.frame</code> to convert into <code>loca.p</code> must have at least two columns.
The first column will be consider as the x coordinates, the second as the y coordinates, and the third (if given) as the values of weights <code>w</code>.
</p>


<h3>Value</h3>

<p>It returns a new object of the new class.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+loca.p">loca.p</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A new unweighted loca.p object
loca &lt;- loca.p(x = c(-1, 1, 1, -1), y = c(-1, -1, 1, 1))

# Conversion to matrix
m &lt;- as.matrix(loca)

# Show matrix
m

# Conversion from matrix
as.loca.p(m)
</code></pre>

<hr>
<h2 id='as.data.frame.loca.p'>as.data.frame.loca.p
S3 method to convert from loca.p to data.frame</h2><span id='topic+as.data.frame.loca.p'></span>

<h3>Description</h3>

<p>Conversions between loca.p class and some others classes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'loca.p'
as.data.frame(x, row.names = NULL, optional = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.data.frame.loca.p_+3A_x">x</code></td>
<td>
<p>is the object to convert to the new class object.</p>
</td></tr>
<tr><td><code id="as.data.frame.loca.p_+3A_row.names">row.names</code></td>
<td>
<p>Unused.</p>
</td></tr>
<tr><td><code id="as.data.frame.loca.p_+3A_optional">optional</code></td>
<td>
<p>Unused.</p>
</td></tr>
<tr><td><code id="as.data.frame.loca.p_+3A_...">...</code></td>
<td>
<p>Other arguments, unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods to convert from and to <code>loca.p</code> class.
</p>
<p>NA's  values are not allowed in any of the arguments.
</p>
<p>The <code>matrix</code> or <code>data.frame</code> to convert into <code>loca.p</code> must have at least two columns.
The first column will be consider as the x coordinates, the second as the y coordinates, and the third (if given) as the values of weights <code>w</code>.
</p>


<h3>Value</h3>

<p>It returns a new object of the new class.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+loca.p">loca.p</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A new unweighted loca.p object
loca &lt;- loca.p(x = c(-1, 1, 1, -1), y = c(-1, -1, 1, 1))

# Conversion to matrix
m &lt;- as.matrix(loca)

# Show matrix
m

# Conversion from matrix
as.loca.p(m)
</code></pre>

<hr>
<h2 id='as.loca.p'>as.loca.p 
The following is for S3 compatibility, mainly for documentation check</h2><span id='topic+as.loca.p'></span>

<h3>Description</h3>

<p>Conversions between loca.p class and some others classes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.loca.p(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.loca.p_+3A_x">x</code></td>
<td>
<p>is the object to convert to the new class object.</p>
</td></tr>
<tr><td><code id="as.loca.p_+3A_...">...</code></td>
<td>
<p>Other arguments, unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods to convert from and to <code>loca.p</code> class.
</p>
<p>NA's  values are not allowed in any of the arguments.
</p>
<p>The <code>matrix</code> or <code>data.frame</code> to convert into <code>loca.p</code> must have at least two columns.
The first column will be consider as the x coordinates, the second as the y coordinates, and the third (if given) as the values of weights <code>w</code>.
</p>


<h3>Value</h3>

<p>It returns a new object of the new class.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+loca.p">loca.p</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A new unweighted loca.p object
loca &lt;- loca.p(x = c(-1, 1, 1, -1), y = c(-1, -1, 1, 1))

# Conversion to matrix
m &lt;- as.matrix(loca)

# Show matrix
m

# Conversion from matrix
as.loca.p(m)
</code></pre>

<hr>
<h2 id='as.loca.p.data.frame'>as.loca.p.data.frame
S3 method to convert from data.frame to loca.p</h2><span id='topic+as.loca.p.data.frame'></span>

<h3>Description</h3>

<p>Conversions between loca.p class and some others classes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.loca.p.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.loca.p.data.frame_+3A_x">x</code></td>
<td>
<p>is the object to convert to the new class object.</p>
</td></tr>
<tr><td><code id="as.loca.p.data.frame_+3A_...">...</code></td>
<td>
<p>Other arguments, unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods to convert from and to <code>loca.p</code> class.
</p>
<p>NA's  values are not allowed in any of the arguments.
</p>
<p>The <code>matrix</code> or <code>data.frame</code> to convert into <code>loca.p</code> must have at least two columns.
The first column will be consider as the x coordinates, the second as the y coordinates, and the third (if given) as the values of weights <code>w</code>.
</p>


<h3>Value</h3>

<p>It returns a new object of the new class.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+loca.p">loca.p</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A new unweighted loca.p object
loca &lt;- loca.p(x = c(-1, 1, 1, -1), y = c(-1, -1, 1, 1))

# Conversion to matrix
m &lt;- as.matrix(loca)

# Show matrix
m

# Conversion from matrix
as.loca.p(m)
</code></pre>

<hr>
<h2 id='as.loca.p.matrix'>as.loca.p.matrix
S3 method to convert from matrix to loca.p</h2><span id='topic+as.loca.p.matrix'></span>

<h3>Description</h3>

<p>Conversions between loca.p class and some others classes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.loca.p.matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.loca.p.matrix_+3A_x">x</code></td>
<td>
<p>is the object to convert to the new class object.</p>
</td></tr>
<tr><td><code id="as.loca.p.matrix_+3A_...">...</code></td>
<td>
<p>Other arguments, unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods to convert from and to <code>loca.p</code> class.
</p>
<p>NA's  values are not allowed in any of the arguments.
</p>
<p>The <code>matrix</code> or <code>data.frame</code> to convert into <code>loca.p</code> must have at least two columns.
The first column will be consider as the x coordinates, the second as the y coordinates, and the third (if given) as the values of weights <code>w</code>.
</p>


<h3>Value</h3>

<p>It returns a new object of the new class.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+loca.p">loca.p</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A new unweighted loca.p object
loca &lt;- loca.p(x = c(-1, 1, 1, -1), y = c(-1, -1, 1, 1))

# Conversion to matrix
m &lt;- as.matrix(loca)

# Show matrix
m

# Conversion from matrix
as.loca.p(m)
</code></pre>

<hr>
<h2 id='as.matrix.loca.p'>as.matrix.loca.p
S3 method to convert from loca.p to matrix</h2><span id='topic+as.matrix.loca.p'></span>

<h3>Description</h3>

<p>Conversions between loca.p class and some others classes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'loca.p'
as.matrix(x, rownames.force = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.matrix.loca.p_+3A_x">x</code></td>
<td>
<p>is the object to convert to the new class object.</p>
</td></tr>
<tr><td><code id="as.matrix.loca.p_+3A_rownames.force">rownames.force</code></td>
<td>
<p>If True the rownames is setted</p>
</td></tr>
<tr><td><code id="as.matrix.loca.p_+3A_...">...</code></td>
<td>
<p>Other arguments, unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods to convert from and to <code>loca.p</code> class.
</p>
<p>NA's  values are not allowed in any of the arguments.
</p>
<p>The <code>matrix</code> or <code>data.frame</code> to convert into <code>loca.p</code> must have at least two columns.
The first column will be consider as the x coordinates, the second as the y coordinates, and the third (if given) as the values of weights <code>w</code>.
</p>


<h3>Value</h3>

<p>It returns a new object of the new class.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+loca.p">loca.p</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A new unweighted loca.p object
loca &lt;- loca.p(x = c(-1, 1, 1, -1), y = c(-1, -1, 1, 1))

# Conversion to matrix
m &lt;- as.matrix(loca)

# Show matrix
m

# Conversion from matrix
as.loca.p(m)
</code></pre>

<hr>
<h2 id='contour.loca.p'>Plots of the min-sum objective function</h2><span id='topic+contour.loca.p'></span>

<h3>Description</h3>

<p><code>contour</code> provides a graphical representations of min-sum objective function, which is the weighted sum of the distances to demand points (<code>distsum</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'loca.p'
contour(
  x,
  lp = numeric(0),
  xmin = min(min(x@x), xleft),
  xmax = max(max(x@x), xright),
  ymin = min(min(x@y), ybottom),
  ymax = max(max(x@y), ytop),
  n = 100,
  img = NULL,
  xleft = min(x@x),
  ybottom = min(x@y),
  xright = max(x@x),
  ytop = max(x@y),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="contour.loca.p_+3A_x">x</code></td>
<td>
<p>The loca.p object to compute the objective.</p>
</td></tr>
<tr><td><code id="contour.loca.p_+3A_lp">lp</code></td>
<td>
<p>If given, then <code class="reqn">l_p</code> norm will be used instead of the Euclidean norm.</p>
</td></tr>
<tr><td><code id="contour.loca.p_+3A_xmin">xmin</code></td>
<td>
<p>The minimum value for x axis.</p>
</td></tr>
<tr><td><code id="contour.loca.p_+3A_xmax">xmax</code></td>
<td>
<p>The maximum value for x axis.</p>
</td></tr>
<tr><td><code id="contour.loca.p_+3A_ymin">ymin</code></td>
<td>
<p>The minimum value for y axis.</p>
</td></tr>
<tr><td><code id="contour.loca.p_+3A_ymax">ymax</code></td>
<td>
<p>The maximum value for y axis.</p>
</td></tr>
<tr><td><code id="contour.loca.p_+3A_n">n</code></td>
<td>
<p>The number of divisions for grid.</p>
</td></tr>
<tr><td><code id="contour.loca.p_+3A_img">img</code></td>
<td>
<p>A raster image to plot on background.</p>
</td></tr>
<tr><td><code id="contour.loca.p_+3A_xleft">xleft</code></td>
<td>
<p>The left position of the image.</p>
</td></tr>
<tr><td><code id="contour.loca.p_+3A_ybottom">ybottom</code></td>
<td>
<p>The bottom position of the image.</p>
</td></tr>
<tr><td><code id="contour.loca.p_+3A_xright">xright</code></td>
<td>
<p>The right position of the image.</p>
</td></tr>
<tr><td><code id="contour.loca.p_+3A_ytop">ytop</code></td>
<td>
<p>The top position of the image.</p>
</td></tr>
<tr><td><code id="contour.loca.p_+3A_...">...</code></td>
<td>
<p>Other options.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code class="reqn">p&lt;1</code> then <code class="reqn">l_p</code> is not a norm, so only <code class="reqn">p&gt;=1</code> are valid values.
</p>


<h3>Value</h3>

<p><code>contour.loca.p</code> plots a contour plot of min-sum function (<code>distsum</code>).
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+orloca-package">orloca-package</a></code>, <code><a href="#topic+plot.loca.p">plot.loca.p</a></code> and <code><a href="#topic+loca.p">loca.p</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A new unweighted loca.p object
loca &lt;- loca.p(x = c(-1, 1, 1, -1), y = c(-1, -1, 1, 1))

# The contour plot of min-sum function for loca (a loca.p object)
contour(loca)

</code></pre>

<hr>
<h2 id='distsum'>Computes distsum function</h2><span id='topic+distsum'></span><span id='topic+distsum+2Cloca.p-method'></span>

<h3>Description</h3>

<p>The objective function and the gradient of the objective function for the min-sum location problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distsum(o, x = 0, y = 0, lp = numeric(0))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distsum_+3A_o">o</code></td>
<td>
<p>An object of <code>loca.p</code> class.</p>
</td></tr>
<tr><td><code id="distsum_+3A_x">x</code></td>
<td>
<p>The x coordinate of the point to be evaluated.</p>
</td></tr>
<tr><td><code id="distsum_+3A_y">y</code></td>
<td>
<p>The y coordinate of the point to be evaluated.</p>
</td></tr>
<tr><td><code id="distsum_+3A_lp">lp</code></td>
<td>
<p>If given, then <code class="reqn">l_p</code> norm will be used instead of the Euclidean norm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function zsum is deprecated and will be removed from new versions of the package.
</p>


<h3>Value</h3>

<p><code>distsum</code> returns the objective function of the min-sum location problem, <code class="reqn">\sum_{a_i \in o} w_i d(a_i, (x,y))</code>, where <code class="reqn">d(a_i, (x,y))</code> gives the euclidean or the <code class="reqn">l_p</code> distances between <code class="reqn">a_i</code> and the point <code class="reqn">(x,y)</code>.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+orloca-package">orloca-package</a></code> and <code><a href="#topic+distsummin">distsummin</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A new unweighted loca.p object
loca &lt;- loca.p(x = c(-1, 1, 1, -1), y = c(-1, -1, 1, 1))
# Evaluation of distsum at (0, 0)
distsum(loca)

# Evaluation of distsum at (1, 3)
distsum(loca, 1, 3)
# Compute the objective function at point (3, 4) using lp norm and p = 2.5
distsum(loca, 3, 4, lp=2.5)
# The gradient function at (1,3)
distsumgra(loca, 1, 3)

</code></pre>

<hr>
<h2 id='distsumgra'>Computes the gradient of distsum function</h2><span id='topic+distsumgra'></span><span id='topic+distsumgra+2Cloca.p-method'></span>

<h3>Description</h3>

<p>The gradient of the objective function for the min-sum location problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distsumgra(o, x = 0, y = 0, lp = numeric(0), partial = F)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distsumgra_+3A_o">o</code></td>
<td>
<p>An object of <code>loca.p</code> class.</p>
</td></tr>
<tr><td><code id="distsumgra_+3A_x">x</code></td>
<td>
<p>The x coordinate of the point to be evaluated.</p>
</td></tr>
<tr><td><code id="distsumgra_+3A_y">y</code></td>
<td>
<p>The y coordinate of the point to be evaluated.</p>
</td></tr>
<tr><td><code id="distsumgra_+3A_lp">lp</code></td>
<td>
<p>If given, then <code class="reqn">l_p</code> norm will be used instead of the Euclidean norm.</p>
</td></tr>
<tr><td><code id="distsumgra_+3A_partial">partial</code></td>
<td>
<p>If (x,y) is a demand point <code>partial=T</code> means ignore such point to compute the gradient. This option is mainly for internal use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function zsumgra is deprecated and will be removed from new versions of the package.
</p>


<h3>Value</h3>

<p><code>distsumgra</code> returns the gradient vector of the objective function of the min-sum location problem, <code class="reqn">\sum_{a_i \in o} w_i d(a_i, (x,y))</code>, where <code class="reqn">d(a_i, (x,y))</code> gives the euclidean or the <code class="reqn">l_p</code> distances between <code class="reqn">a_i</code> and the point <code class="reqn">(x,y)</code>.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+orloca-package">orloca-package</a></code> and <code><a href="#topic+distsum">distsum</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A new unweighted loca.p object
loca &lt;- loca.p(x = c(-1, 1, 1, -1), y = c(-1, -1, 1, 1))
# Evaluation of distsum at (0, 0)
distsum(loca)

# Evaluation of distsum at (1, 3)
distsum(loca, 1, 3)
# Compute the objective function at point (3, 4) using lp norm and p = 2.5
distsum(loca, 3, 4, lp=2.5)
# The gradient function at (1,3)
distsumgra(loca, 1, 3)

</code></pre>

<hr>
<h2 id='distsuml2'>distsuml2 and distsuml2gra at orloca package</h2><span id='topic+distsuml2'></span><span id='topic+distsuml2+2Cloca.p-method'></span><span id='topic+distsuml2gra'></span><span id='topic+distsuml2gra+2Cloca.p-method'></span>

<h3>Description</h3>

<p><code>distsum</code> and <code>distsumgra</code> functions for the Euclidean norm (<code class="reqn">l_2</code>). Mainly for internal use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distsuml2(o, x = 0, y = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distsuml2_+3A_o">o</code></td>
<td>
<p>An object of <code>loca.p</code> class.</p>
</td></tr>
<tr><td><code id="distsuml2_+3A_x">x</code></td>
<td>
<p>The x coordinate of the point to be evaluated.</p>
</td></tr>
<tr><td><code id="distsuml2_+3A_y">y</code></td>
<td>
<p>The y coordinate of the point to be evaluated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code class="reqn">(x,y)</code> is a demand point <code>partial=T</code> means ignore such point to compute the gradient. This option is mainly for internal use.
</p>


<h3>Value</h3>

<p><code>distsuml2</code> returns the objective function of the min-sum location problem, <code class="reqn">\sum_{a_i \in o} w_i d(a_i, (x,y))</code>, where <code class="reqn">d(a_i, (x,y))</code> gives the euclidean distances between <code class="reqn">a_i</code> and the point <code class="reqn">(x,y)</code>.  <code>distsumgra</code> returns the gradient vector of the function <code>distsum</code>.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+orloca-package">orloca-package</a></code>, <code><a href="#topic+distsum">distsum</a></code>, <code><a href="#topic+distsumgra">distsumgra</a></code> and <code><a href="#topic+distsummin">distsummin</a></code>.
</p>

<hr>
<h2 id='distsuml2min'>distsuml2min at orloca package</h2><span id='topic+distsuml2min'></span><span id='topic+distsuml2min+2Cloca.p-method'></span>

<h3>Description</h3>

<p><code>distsuml2min</code> is the <code>distsummin</code> function for the Euclidean norm (<code class="reqn">l_2</code>).
This function returns the solution of the minimization problem.
Mainly for internal use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distsuml2min(
  o,
  x = 0,
  y = 0,
  max.iter = 100,
  eps = 0.001,
  verbose = FALSE,
  algorithm = "Weiszfeld",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distsuml2min_+3A_o">o</code></td>
<td>
<p>An object of loca.p class.</p>
</td></tr>
<tr><td><code id="distsuml2min_+3A_x">x</code></td>
<td>
<p>The x coordinate of the starting point. It's default value is 0.</p>
</td></tr>
<tr><td><code id="distsuml2min_+3A_y">y</code></td>
<td>
<p>The y coordinate of the starting point. It's default value is 0.</p>
</td></tr>
<tr><td><code id="distsuml2min_+3A_max.iter">max.iter</code></td>
<td>
<p>Maximum number of iterations allowed. It's default value is 100000.</p>
</td></tr>
<tr><td><code id="distsuml2min_+3A_eps">eps</code></td>
<td>
<p>The module of the gradient in the stop rule. It's default value is 1e-3.</p>
</td></tr>
<tr><td><code id="distsuml2min_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE the function produces detailed output. It's default value is FALSE.</p>
</td></tr>
<tr><td><code id="distsuml2min_+3A_algorithm">algorithm</code></td>
<td>
<p>The method to be use. For this version of the package, the valid values are: &quot;gradient&quot; for a gradient based method, &quot;search&quot; for local search method (this option is deprecated), &quot;ucminf&quot; for optimization with ucminf from ucminf package, and &quot;Weiszfeld&quot; for the Weiszfeld method or any of the valid method for optim function, now &quot;Nelder-Mead&quot;, &quot;BFGS&quot;, &quot;CG&quot;, &quot;L-BFGS-B&quot;, &quot;SANN&quot;. &quot;Weiszfeld&quot; is the default value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithms Weiszfeld and gradient include and optimality test for demand points.
The Weiszfeld version of the algorithm also implements slow convergence test and accelerator procedure.
</p>
<p>If <code class="reqn">p &lt; 1</code> thus <code class="reqn">l_p</code> is not a norm, so, only <code class="reqn">p \ge 1</code> are valid values.
</p>
<p>Since <code class="reqn">l_2</code> norm is the Euclidean norm, when <code class="reqn">p=2</code> <code>distsumlpmin</code> are equal to <code>distsummin</code>.
But the computations involved are greater for the first form.
</p>
<p>max.iter for SANN algorithm is the number of evaluation of objective function, so this method usually requires large values of max.iter to reach optimal value
</p>
<p>The function zsummin is deprecated and will be removed from new versions of the package.
</p>


<h3>Value</h3>

<p><code>distsummin</code> returns an array with the coordinates of the solution point.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+orloca-package">orloca-package</a></code>, <code><a href="#topic+loca.p">loca.p</a></code> and <code><a href="#topic+distsum">distsum</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A new unweighted loca.p object
loca &lt;- loca.p(x = c(-1, 1, 1, -1), y = c(-1, -1, 1, 1))
# Compute the minimum
sol&lt;-distsummin(loca)

# Show the result
sol

# Evaluation of the objective function at solution point
distsum(loca, sol[1], sol[2])

</code></pre>

<hr>
<h2 id='distsumlp'>distsumlp and distsumlpgra at orloca package</h2><span id='topic+distsumlp'></span><span id='topic+distsumlp+2Cloca.p-method'></span><span id='topic+distsumlpgra'></span><span id='topic+distsumlpgra+2Cloca.p-method'></span>

<h3>Description</h3>

<p>distsum and distsumgra functions with <code class="reqn">l_p</code> norm. Mainly for internal use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distsumlp(o, x = 0, y = 0, p = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distsumlp_+3A_o">o</code></td>
<td>
<p>An object of <code>loca.p</code> class.</p>
</td></tr>
<tr><td><code id="distsumlp_+3A_x">x</code></td>
<td>
<p>The x coordinate of the point to be evaluated.</p>
</td></tr>
<tr><td><code id="distsumlp_+3A_y">y</code></td>
<td>
<p>The y coordinate of the point to be evaluated.</p>
</td></tr>
<tr><td><code id="distsumlp_+3A_p">p</code></td>
<td>
<p>The <code class="reqn">l_p</code> norm to use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code class="reqn">p&lt;1</code> then <code class="reqn">l_p</code> is not a norm, so only <code class="reqn">p&gt;=1</code> are valid values.
</p>
<p>Since <code class="reqn">l_2</code> norm is the Euclidean norm, when <code class="reqn">p=2</code> <code>distsumlp</code> are equal to <code>distsum</code>, and <code>distsumlpgra</code> are equal to <code>distsumgra</code>.
But the computations involved are greater for the firsts form.
</p>


<h3>Value</h3>

<p><code>distsumlp</code> returns the objective function of the min-sum location problem with <code class="reqn">l_p</code> norm, <code class="reqn">\sum_{a_i \in o} w_i d(a_i, (x,y))</code>, where <code class="reqn">d(a_i, (x,y))</code> gives the distances between <code class="reqn">a_i</code> and the point <code class="reqn">(x,y)</code> using <code class="reqn">l_p</code> norm.
</p>
<p><code>distsumlpgra</code> returns the gradient vector of the function <code>distsumlp</code>. If <code class="reqn">(x,y)</code> is a demand point <code>partial=T</code> means ignore such point to compute the gradient. This option is mainly for internal use.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+distsum">distsum</a></code>, <code><a href="#topic+orloca-package">orloca-package</a></code> and <code><a href="#topic+distsumlpmin">distsumlpmin</a></code>.
</p>

<hr>
<h2 id='distsumlpmin'>distsumlpmin at orloca package</h2><span id='topic+distsumlpmin'></span><span id='topic+distsumlpmin+2Cloca.p-method'></span>

<h3>Description</h3>

<p><code>distsumlpmin</code> is the <code>distsummin</code> function for the norm (<code class="reqn">l_p</code>).
This function returns the solution of the minimization problem.
Mainly for internal use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distsumlpmin(
  o,
  x = 0,
  y = 0,
  p = 2,
  max.iter = 100,
  eps = 0.001,
  verbose = FALSE,
  algorithm = "Weiszfeld",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distsumlpmin_+3A_o">o</code></td>
<td>
<p>An object of loca.p class.</p>
</td></tr>
<tr><td><code id="distsumlpmin_+3A_x">x</code></td>
<td>
<p>The x coordinate of the starting point. It's default value is 0.</p>
</td></tr>
<tr><td><code id="distsumlpmin_+3A_y">y</code></td>
<td>
<p>The y coordinate of the starting point. It's default value is 0.</p>
</td></tr>
<tr><td><code id="distsumlpmin_+3A_max.iter">max.iter</code></td>
<td>
<p>Maximum number of iterations allowed. It's default value is 100000.</p>
</td></tr>
<tr><td><code id="distsumlpmin_+3A_eps">eps</code></td>
<td>
<p>The module of the gradient in the stop rule. It's default value is 1e-3.</p>
</td></tr>
<tr><td><code id="distsumlpmin_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE the function produces detailed output. It's default value is FALSE.</p>
</td></tr>
<tr><td><code id="distsumlpmin_+3A_algorithm">algorithm</code></td>
<td>
<p>The method to be use. For this version of the package, the valid values are: &quot;gradient&quot; for a gradient based method, &quot;search&quot; for local search method (this option is deprecated), &quot;ucminf&quot; for optimization with ucminf from ucminf package, and &quot;Weiszfeld&quot; for the Weiszfeld method or any of the valid method for optim function, now &quot;Nelder-Mead&quot;, &quot;BFGS&quot;, &quot;CG&quot;, &quot;L-BFGS-B&quot;, &quot;SANN&quot;. &quot;Weiszfeld&quot; is the default value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithms Weiszfeld and gradient include and optimality test for demand points.
The Weiszfeld version of the algorithm also implements slow convergence test and accelerator procedure.
</p>
<p>If <code class="reqn">p &lt; 1</code> thus <code class="reqn">l_p</code> is not a norm, so, only <code class="reqn">p \ge 1</code> are valid values.
</p>
<p>Since <code class="reqn">l_2</code> norm is the Euclidean norm, when <code class="reqn">p=2</code> <code>distsumlpmin</code> are equal to <code>distsummin</code>.
But the computations involved are greater for the first form.
</p>
<p>max.iter for SANN algorithm is the number of evaluation of objective function, so this method usually requires large values of max.iter to reach optimal value
</p>
<p>The function zsummin is deprecated and will be removed from new versions of the package.
</p>


<h3>Value</h3>

<p><code>distsummin</code> returns an array with the coordinates of the solution point.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+orloca-package">orloca-package</a></code>, <code><a href="#topic+loca.p">loca.p</a></code> and <code><a href="#topic+distsum">distsum</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A new unweighted loca.p object
loca &lt;- loca.p(x = c(-1, 1, 1, -1), y = c(-1, -1, 1, 1))
# Compute the minimum
sol&lt;-distsummin(loca)

# Show the result
sol

# Evaluation of the objective function at solution point
distsum(loca, sol[1], sol[2])

</code></pre>

<hr>
<h2 id='distsummin'>Returns the solution of the minimization problem</h2><span id='topic+distsummin'></span><span id='topic+distsummin+2Cloca.p-method'></span>

<h3>Description</h3>

<p>Solve the min-sum location problem for a given <code>loca.p</code> class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distsummin(
  o,
  x = 0,
  y = 0,
  lp = numeric(0),
  max.iter = 1e+05,
  eps = 0.001,
  verbose = FALSE,
  algorithm = "Weiszfeld",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distsummin_+3A_o">o</code></td>
<td>
<p>An object of loca.p class.</p>
</td></tr>
<tr><td><code id="distsummin_+3A_x">x</code></td>
<td>
<p>The x coordinate of the starting point. It's default value is 0.</p>
</td></tr>
<tr><td><code id="distsummin_+3A_y">y</code></td>
<td>
<p>The y coordinate of the starting point. It's default value is 0.</p>
</td></tr>
<tr><td><code id="distsummin_+3A_lp">lp</code></td>
<td>
<p>If given, the <code class="reqn">l_p</code> norm will be used instead of the Euclidean norm.</p>
</td></tr>
<tr><td><code id="distsummin_+3A_max.iter">max.iter</code></td>
<td>
<p>Maximum number of iterations allowed. It's default value is 100000.</p>
</td></tr>
<tr><td><code id="distsummin_+3A_eps">eps</code></td>
<td>
<p>The module of the gradient in the stop rule. It's default value is 1e-3.</p>
</td></tr>
<tr><td><code id="distsummin_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE the function produces detailed output. It's default value is FALSE.</p>
</td></tr>
<tr><td><code id="distsummin_+3A_algorithm">algorithm</code></td>
<td>
<p>The method to be use. For this version of the package, the valid values are: &quot;gradient&quot; for a gradient based method, &quot;search&quot; for local search method (this option is deprecated), &quot;ucminf&quot; for optimization with ucminf from ucminf package, and &quot;Weiszfeld&quot; for the Weiszfeld method or any of the valid method for optim function, now &quot;Nelder-Mead&quot;, &quot;BFGS&quot;, &quot;CG&quot;, &quot;L-BFGS-B&quot;, &quot;SANN&quot;. &quot;Weiszfeld&quot; is the default value.</p>
</td></tr>
<tr><td><code id="distsummin_+3A_...">...</code></td>
<td>
<p>Other options for optimization algorithms.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithms Weiszfeld and gradient include and optimality test for demand points.
The Weiszfeld version of the algorithm also implements slow convergence test and accelerator procedure.
</p>
<p>If <code class="reqn">p &lt; 1</code> thus <code class="reqn">l_p</code> is not a norm, so, only <code class="reqn">p \ge 1</code> are valid values.
</p>
<p>Since <code class="reqn">l_2</code> norm is the Euclidean norm, when <code class="reqn">p=2</code> <code>distsumlpmin</code> are equal to <code>distsummin</code>.
But the computations involved are greater for the first form.
</p>
<p>max.iter for SANN algorithm is the number of evaluation of objective function, so this method usually requires large values of max.iter to reach optimal value
</p>
<p>The function zsummin is deprecated and will be removed from new versions of the package.
</p>


<h3>Value</h3>

<p><code>distsummin</code> returns an array with the coordinates of the solution point.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+orloca-package">orloca-package</a></code>, <code><a href="#topic+loca.p">loca.p</a></code> and <code><a href="#topic+distsum">distsum</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A new unweighted loca.p object
loca &lt;- loca.p(x = c(-1, 1, 1, -1), y = c(-1, -1, 1, 1))
# Compute the minimum
sol&lt;-distsummin(loca)

# Show the result
sol

# Evaluation of the objective function at solution point
distsum(loca, sol[1], sol[2])

</code></pre>

<hr>
<h2 id='loca.p'>loca.p class for Operations Research LOCational Analysis</h2><span id='topic+loca.p'></span><span id='topic+print'></span><span id='topic+summary'></span>

<h3>Description</h3>

<p>An object of class <code>loca.p</code> represents a weighted location problem with a finite demand points set.
The <code><a href="#topic+orloca-package">orloca-package</a></code> is mainly devoted to deals with location problems.
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loca.p_+3A_x">x</code></td>
<td>
<p>is a vector of the x coordinates of the demand points.</p>
</td></tr>
<tr><td><code id="loca.p_+3A_y">y</code></td>
<td>
<p>is a vector of the y coordinates of the demand points.</p>
</td></tr>
<tr><td><code id="loca.p_+3A_w">w</code></td>
<td>
<p>is a vector of weights of the demand points. If w is omitted then all weights are considered as 1.</p>
</td></tr>
<tr><td><code id="loca.p_+3A_label">label</code></td>
<td>
<p>If given, it is the label of the new object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main generator of the loca.p class is <code>loca.p(x, y, w = numeric(0), label = "")</code>.
An alternative form is <code>new("loca.p", x, y, w = numeric(0), label = "")</code>.
</p>
<p>The lengths of <code>x</code> and <code>y</code> vector must be equals.
The length of <code>w</code> must be equal to the previous ones or must be 0, or should be omitted.
NA's values are not allowed at any of the arguments.
</p>
<p><code>summary(x)</code> returns a summary of the <code>x</code> <code>loca.p</code> object and <code>print(x)</code> prints the <code>x</code> <code>loca.p</code> object in table format.
</p>


<h3>Value</h3>

<p>If the arguments have valid values, it returns a new object of class <code>loca.p</code>, else it returns an error.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+orloca-package">orloca-package</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A new unweighted loca.p object
loca &lt;- loca.p(x = c(-1, 1, 1, -1), y = c(-1, -1, 1, 1))
# or
loca &lt;- new("loca.p", x = c(-1, 1, 1, -1), y = c(-1, -1, 1, 1))

# An example with weights and name
locb &lt;- new("loca.p", x = c(-1, 1, 1, -1), y = c(-1, -1, 1, 1),
w = c(1, 2, 1, 2), label = "Weighted case")

</code></pre>

<hr>
<h2 id='paquete-orloca'>Modelos de Investigacion Operativa para el Analisis de Localizacion (Operations Research LOCational Analysis Models)</h2><span id='topic+paquete-orloca'></span>

<h3>Description</h3>

<p>Objetos y metodos para manejar y resolver el problema de localizacion de suma ponderada minima, tambien conocido como problema de Fermat-Weber.
</p>
<pre>

Paquete:   orloca

Version:   5.5

Fecha:      2023-09-19

Licencia:   GPL (&gt;= 3)
</pre>


<h3>Details</h3>

<p>El problema de localizacion de suma minima busca un punto tal que la suma ponderada de las distancias a los puntos de demanda se minimice.
Vease &quot;The Fermat-Weber location problem revisited&quot; por Brimberg, Mathematical Programming, 1, pag. 71-76, 1995. <a href="https://doi.org/10.1007/BF01592245">doi:10.1007/BF01592245</a>.
</p>
<p>Se usan algoritmos generales de optimizacion global para resolver el problema, junto con el metodo adhoc Weiszfeld, vease &quot;Sur le point pour lequel la Somme des distance de n points donnes est minimum&quot;, por Weiszfeld, Tohoku Mathematical Journal, First Series, 43, pag. 355-386, 1937 o &quot;On the point for which the sum of the distances to n given points is minimum&quot;, por E. Weiszfeld y F. Plastria, Annals of Operations Research, 167, pg. 7-41, 2009. <a href="https://doi.org/10.1007/s10479-008-0352-z">doi:10.1007/s10479-008-0352-z</a>.
</p>
<p>El paquete proporciona una clase <code>loca.p</code> que representa un problema de localizacion sobre el plano.
Tambien permite dibujar los puntos junto a la funcion objetivo.
Dicho objetivo es la suma ponderada de las distancias que viajan los clientes del servicio.
</p>
<p>Versiones no planas del problema podrian incorporarse en futuras versiones del paquete.
</p>
<p>Para una demostracion, cargue el paquete con la instrucción <code>library(orloca)</code> y ejecute la demostracion con la instruccion <code>demo(orloca)</code>.
</p>
<p>El paquete esta preparado para su internacionalizacion.
Las traducciones de los ficheros .mo recibidas seran anadidas en proximas versiones del paquete.
</p>


<h3>Author(s)</h3>

<p>Manuel Munoz-Marquez &lt;manuel.munoz@uca.es&gt;
</p>
<p>Mantenedor: Manuel Munoz-Marquez &lt;manuel.munoz@uca.es&gt;
</p>


<h3>References</h3>

<p>[1] Brimberg, J. <em>The Fermat-Weber location problem revisited</em>, Mathematical Programming, 1, pg. 71-76, 1995. <a href="https://doi.org/10.1007/BF01592245">doi:10.1007/BF01592245</a>.
</p>
<p>[2] Love, R. F., Morris, J. G., Wesolowsky, G. O. <em>Facilities Location: Chapter 2: Introduction to Single-Facility Location</em>, 1988, North-Holland
</p>
<p>[3] Weiszfeld, E. and Plastria, F. <em>On the point for which the sum of the distances to n given points is minimum</em>, Annals of Operations Research, 167, pg. 7-41, 2009, <a href="https://doi.org/10.1007/s10479-008-0352-z">doi:10.1007/s10479-008-0352-z</a>.
</p>
<p>[4] <a href="http://knuth.uca.es/orloca/">http://knuth.uca.es/orloca/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Un objeto loca.p no ponderado
o &lt;- loca.p(x = c(-1, 1, 1, -1), y = c(-1, -1, 1, 1))

# Calcula la funcion objetivo en el punto (3, 4)
# [1] 20.39384
zsum(o, 3, 4)

# Calcula la suma de las distancias al punto (3, 4) usando la norma lp con p = 2.5
# [1] 19.27258
zsum(o, 3, 4, lp = 2.5)

# Resuelve el problema de localizacion
# [1] 0 0
zsummin(o)

# Curvas de nivel
contour(o)

# Ejecuta una demo del paquete
demo(orloca)
</code></pre>

<hr>
<h2 id='persp.loca.p'>Plots of the min-sum objective function</h2><span id='topic+persp.loca.p'></span>

<h3>Description</h3>

<p><code>persp</code> provides a graphical representations of objetive function of the min-sum problem, which is the total weighte distance to the demand points (<code>distsum</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'loca.p'
persp(
  x,
  lp = numeric(0),
  xmin = min(x@x),
  xmax = max(x@x),
  ymin = min(x@y),
  ymax = max(x@y),
  n = 10,
  ticktype = "detailed",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="persp.loca.p_+3A_x">x</code></td>
<td>
<p>The loca.p object to compute the objective.</p>
</td></tr>
<tr><td><code id="persp.loca.p_+3A_lp">lp</code></td>
<td>
<p>If given, then <code class="reqn">l_p</code> norm will be used instead of the Euclidean norm.</p>
</td></tr>
<tr><td><code id="persp.loca.p_+3A_xmin">xmin</code></td>
<td>
<p>The minimum value for x axis.</p>
</td></tr>
<tr><td><code id="persp.loca.p_+3A_xmax">xmax</code></td>
<td>
<p>The maximum value for x axis.</p>
</td></tr>
<tr><td><code id="persp.loca.p_+3A_ymin">ymin</code></td>
<td>
<p>The minimum value for y axis.</p>
</td></tr>
<tr><td><code id="persp.loca.p_+3A_ymax">ymax</code></td>
<td>
<p>The maximum value for y axis.</p>
</td></tr>
<tr><td><code id="persp.loca.p_+3A_n">n</code></td>
<td>
<p>The number of divisions for grid.</p>
</td></tr>
<tr><td><code id="persp.loca.p_+3A_ticktype">ticktype</code></td>
<td>
<p>parameter to pass to low level function persp</p>
</td></tr>
<tr><td><code id="persp.loca.p_+3A_...">...</code></td>
<td>
<p>Other options.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code class="reqn">p&lt;1</code> then <code class="reqn">l_p</code> is not a norm, so only <code class="reqn">p&gt;=1</code> are valid values.
</p>


<h3>Value</h3>

<p>A plot a 3D plot or min-sum function.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+orloca-package">orloca-package</a></code>, <code><a href="#topic+plot.loca.p">plot.loca.p</a></code> and <code><a href="#topic+loca.p">loca.p</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A new unweighted loca.p object
loca &lt;- loca.p(x = c(-1, 1, 1, -1), y = c(-1, -1, 1, 1))

# The 3D graphics
persp(loca)

</code></pre>

<hr>
<h2 id='plot'>plot of loca.p class objects</h2><span id='topic+plot'></span><span id='topic+plot.loca.p'></span>

<h3>Description</h3>

<p>This method provides a graphical representations of an object of class <code>loca.p</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'loca.p'
plot(
  x,
  xlab = "",
  ylab = "",
  main = paste(gettext("Plot of loca.p"), ifelse(x@label == "", "", paste0(": \"",
    x@label, "\""))),
  img = NULL,
  xlim = c(min(xleft, min(x@x)), max(xright, max(x@x))),
  ylim = c(min(ybottom, min(x@y)), max(ytop, max(x@y))),
  xleft = min(x@x),
  ybottom = min(x@y),
  xright = max(x@x),
  ytop = max(x@y),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>The <code>loca.p</code> object to plot.</p>
</td></tr>
<tr><td><code id="plot_+3A_xlab">xlab</code></td>
<td>
<p>The label for x axis.</p>
</td></tr>
<tr><td><code id="plot_+3A_ylab">ylab</code></td>
<td>
<p>The label for y axis.</p>
</td></tr>
<tr><td><code id="plot_+3A_main">main</code></td>
<td>
<p>The main title for the plot.</p>
</td></tr>
<tr><td><code id="plot_+3A_img">img</code></td>
<td>
<p>A raster image to plot on background.</p>
</td></tr>
<tr><td><code id="plot_+3A_xlim">xlim</code></td>
<td>
<p>Limit over the x axes of the plot.</p>
</td></tr>
<tr><td><code id="plot_+3A_ylim">ylim</code></td>
<td>
<p>Limit over the y axes of the plot.</p>
</td></tr>
<tr><td><code id="plot_+3A_xleft">xleft</code></td>
<td>
<p>The left position of the image.</p>
</td></tr>
<tr><td><code id="plot_+3A_ybottom">ybottom</code></td>
<td>
<p>The bottom position of the image.</p>
</td></tr>
<tr><td><code id="plot_+3A_xright">xright</code></td>
<td>
<p>The right position of the image.</p>
</td></tr>
<tr><td><code id="plot_+3A_ytop">ytop</code></td>
<td>
<p>The top position of the image.</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>Other graphical options.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function plots demand points by evaluating limits automatically.
</p>


<h3>Value</h3>

<p>The function plots the required graphics.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+orloca-package">orloca-package</a></code>, <code><a href="#topic+loca.p">loca.p</a></code> and <code><a href="#topic+plot">plot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A new unweighted loca.p object
loca &lt;- loca.p(x = c(-1, 1, 1, -1), y = c(-1, -1, 1, 1))
# The plot of loca object
plot(loca)

</code></pre>

<hr>
<h2 id='rloca.p'>Random instances generator of loca.p class object</h2><span id='topic+rloca.p'></span>

<h3>Description</h3>

<p><code>rloca.p</code> function returns a random instance of <code>loca.p</code> class object at a given rectangular region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rloca.p(
  n,
  xmin = 0,
  xmax = 1,
  ymin = 0,
  ymax = 1,
  wmin = 1,
  wmax = 1,
  label = "",
  groups = 0,
  xgmin = xmin,
  xgmax = xmax,
  ygmin = ymin,
  ygmax = ymax
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rloca.p_+3A_n">n</code></td>
<td>
<p>The number of demand points.</p>
</td></tr>
<tr><td><code id="rloca.p_+3A_xmin">xmin</code></td>
<td>
<p>Minimum value for the x coordinates of the demand points.</p>
</td></tr>
<tr><td><code id="rloca.p_+3A_xmax">xmax</code></td>
<td>
<p>Maximum value for the x coordinates of the demand points.</p>
</td></tr>
<tr><td><code id="rloca.p_+3A_ymin">ymin</code></td>
<td>
<p>Minimum value for the y coordinates of the demand points.</p>
</td></tr>
<tr><td><code id="rloca.p_+3A_ymax">ymax</code></td>
<td>
<p>Maximum value for the y coordinates of the demand points.</p>
</td></tr>
<tr><td><code id="rloca.p_+3A_wmin">wmin</code></td>
<td>
<p>Minimum value for weights</p>
</td></tr>
<tr><td><code id="rloca.p_+3A_wmax">wmax</code></td>
<td>
<p>Maximum value for weights</p>
</td></tr>
<tr><td><code id="rloca.p_+3A_label">label</code></td>
<td>
<p>The label for the new loca.p object.</p>
</td></tr>
<tr><td><code id="rloca.p_+3A_groups">groups</code></td>
<td>
<p>The number of (almost) equal size groups to generate, or a list size of the groups to generate. In the second case <code>n</code> will be ignored.</p>
</td></tr>
<tr><td><code id="rloca.p_+3A_xgmin">xgmin</code></td>
<td>
<p>Minimum value for the x coordinate of demand points with respect to the group reference point.</p>
</td></tr>
<tr><td><code id="rloca.p_+3A_xgmax">xgmax</code></td>
<td>
<p>Maximum value for the x coordinate of demand points with respect to the group reference point.</p>
</td></tr>
<tr><td><code id="rloca.p_+3A_ygmin">ygmin</code></td>
<td>
<p>Minimum value for the y coordinate of demand points with respect to the group reference point.</p>
</td></tr>
<tr><td><code id="rloca.p_+3A_ygmax">ygmax</code></td>
<td>
<p>Maximum value for the y coordinate of demand points with respect to the group reference point.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>n</code> must be at least 1.
</p>
<p><code>xmin</code> must be less or equal than <code>xmax</code>.
</p>
<p><code>ymin</code> must be less or equal than <code>ymax</code>.
</p>
<p>If a non zero value is given for <code>groups</code> parameter, then a reference point for each group are generated. At second stage, the offset part for each demand point are generated, and added to the reference point generated at the first stage.
</p>
<p>Note that <code>groups = 1</code> is not equivalent to the default value <code>groups = 0</code>, because in the first case a reference point are generated at the first stage.
</p>


<h3>Value</h3>

<p>If the arguments are valid values, it returns a new object of <code>loca.p</code> class, else it returns an error.
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+orloca-package">orloca-package</a></code> and <code>loca.p</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A random loca.p object at unit square with 5 demand points
rloca.p(5)
# At another region
rloca.p(10, xmin=-2, xmax=2, ymin=-2, ymax=2)
# Five groups
rloca.p(48, groups=5)
# Three unequal size groups
rloca.p(1, groups=c(10, 7, 2))
</code></pre>

<hr>
<h2 id='zsum'>zsum</h2><span id='topic+zsum'></span>

<h3>Description</h3>

<p>The function zsum is deprected and could be removed in next version of the package. Use <a href="#topic+distsum">distsum</a> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zsum(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zsum_+3A_...">...</code></td>
<td>
<p>Parameters passed to distsum</p>
</td></tr>
</table>

<hr>
<h2 id='zsumgra'>zsumgra</h2><span id='topic+zsumgra'></span>

<h3>Description</h3>

<p>The function zsumgra is deprected and could be removed in next version of the package. Use <a href="#topic+distsumgra">distsumgra</a> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zsumgra(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zsumgra_+3A_...">...</code></td>
<td>
<p>Parameters passed to distsumgra</p>
</td></tr>
</table>

<hr>
<h2 id='zsummin'>zsummin</h2><span id='topic+zsummin'></span>

<h3>Description</h3>

<p>The function zsummin is deprected and could be removed in next version of the package. Use <a href="#topic+distsummin">distsummin</a> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zsummin(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zsummin_+3A_...">...</code></td>
<td>
<p>Parameters passed to distsummin</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
