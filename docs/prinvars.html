<!DOCTYPE html><html><head><title>Help for package prinvars</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {prinvars}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#prinvars-package'><p>Principal Variables Package</p></a></li>
<li><a href='#Block-class'><p>Block</p></a></li>
<li><a href='#pla'><p>Principal Loading Analysis</p></a></li>
<li><a href='#pla.drop_blocks'><p>Drop Blocks</p></a></li>
<li><a href='#pla.keep_blocks'><p>Keep Blocks</p></a></li>
<li><a href='#print.pla'><p>Print Function for pla S3</p></a></li>
<li><a href='#show,Block-method'><p>Block - Show</p></a></li>
<li><a href='#spla'><p>Sparse Principal Loading Analysis</p></a></li>
<li><a href='#str,Block-method'><p>Block - str</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Principal Variables</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides methods for reducing the number of features within a data set. See Bauer JO (2021) &lt;<a href="https://doi.org/10.1145%2F3475827.3475832">doi:10.1145/3475827.3475832</a>&gt; and Bauer JO, Drabant B (2021) &lt;<a href="https://doi.org/10.1016%2Fj.jmva.2021.104754">doi:10.1016/j.jmva.2021.104754</a>&gt; for more information on principal loading analysis.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, Rdpack, elasticnet, PMA</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Ronho/prinvars">https://github.com/Ronho/prinvars</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Ronho/prinvars/issues">https://github.com/Ronho/prinvars/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Collate:</td>
<td>'block.R' 'cor.R' 'explained-variance.R' 'get-blocks.R'
'thresholding.R' 'scale.R' 'utils.R' 'pla.R'
'prinvars-package.R'</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), AER</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-09 09:20:26 UTC; Qunor</td>
</tr>
<tr>
<td>Author:</td>
<td>Jan O. Bauer [aut],
  Ron Holzapfel [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ron Holzapfel &lt;ronholzapfel@outlook.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-09 09:50:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='prinvars-package'>Principal Variables Package</h2><span id='topic+prinvars-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>This package provides methods for dimensionality reduction.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Ron Holzapfel <a href="mailto:ronholzapfel@outlook.de">ronholzapfel@outlook.de</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Jan O. Bauer
</p>
</li></ul>



<h3>References</h3>

<p>Bauer JO (2021).
&ldquo;Correlation based principal loading analysis.&rdquo;
In <em>2021 4th International Conference on Mathematics and Statistics</em>, 27&ndash;34.
ISBN 9781450389907, <a href="https://doi.org/10.1145/3475827.3475832">doi:10.1145/3475827.3475832</a>.
Bauer JO, Drabant B (2021).
&ldquo;Principal loading analysis.&rdquo;
<em>Journal of Multivariate Analysis</em>, <b>184</b>, 104754.
ISSN 0047259X, <a href="https://doi.org/10.1016/j.jmva.2021.104754">doi:10.1016/j.jmva.2021.104754</a>.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/Ronho/prinvars">https://github.com/Ronho/prinvars</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/Ronho/prinvars/issues">https://github.com/Ronho/prinvars/issues</a>
</p>
</li></ul>


<hr>
<h2 id='Block-class'>Block</h2><span id='topic+Block-class'></span>

<h3>Description</h3>

<p>Class used within the package to keep the structure and
information about the generated blocks.
</p>


<h3>Slots</h3>


<dl>
<dt><code>features</code></dt><dd><p>a vector of numeric which contains the indices of the block.</p>
</dd>
<dt><code>explained_variance</code></dt><dd><p>a numeric which contains the variance explained of
the blocks variables based on the whole data set.</p>
</dd>
<dt><code>is_valid</code></dt><dd><p>a logical which indicates if the block structure is valid.</p>
</dd>
<dt><code>ev_influenced</code></dt><dd><p>a vector of numeric which contains the indices of the
eigenvectors influenced by this block.</p>
</dd>
</dl>

<hr>
<h2 id='pla'>Principal Loading Analysis</h2><span id='topic+pla'></span>

<h3>Description</h3>

<p>This function performs a principal loading analysis on the given
data matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pla(
  x,
  cor = FALSE,
  scaled_ev = FALSE,
  thresholds = 0.33,
  threshold_mode = c("cutoff", "percentage"),
  expvar = c("approx", "exact"),
  check = c("rnc", "rows"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pla_+3A_x">x</code></td>
<td>
<p>a numeric matrix or data frame which provides the data for the
principal loading analysis.</p>
</td></tr>
<tr><td><code id="pla_+3A_cor">cor</code></td>
<td>
<p>a logical value indicating whether the calculation should use the
correlation or the covariance matrix.</p>
</td></tr>
<tr><td><code id="pla_+3A_scaled_ev">scaled_ev</code></td>
<td>
<p>a logical value indicating whether the eigenvectors should
be scaled.</p>
</td></tr>
<tr><td><code id="pla_+3A_thresholds">thresholds</code></td>
<td>
<p>a numeric value or list of numeric values used to determine
&quot;small&quot; values inside the eigenvectors. If multiple values are given, a list
of pla results will be returned.</p>
</td></tr>
<tr><td><code id="pla_+3A_threshold_mode">threshold_mode</code></td>
<td>
<p>a character string indicating how the threshold is
determined and used. <code>cutoff</code> indicates the usage of a threshold value.
<code>percentage</code> indicates that the cutoff value is determined by the
maximum element of each vector multiplied with the threshold value.</p>
</td></tr>
<tr><td><code id="pla_+3A_expvar">expvar</code></td>
<td>
<p>a character string indicating the method used for calculating
the explained variance. <code>approx</code> uses the explained variance of each
eigenvector i.e. its eigenvalue. <code>exact</code> uses the variance of each
variable.</p>
</td></tr>
<tr><td><code id="pla_+3A_check">check</code></td>
<td>
<p>a character string indicating if only rows or rows as well as
columns are used to detect the underlying block structure. <code>rows</code> checks
if the rows fulfill the required structure. <code>rnc</code> checks if rows and
columns fulfill the required structure.</p>
</td></tr>
<tr><td><code id="pla_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>single or list of <code>pla</code> class containing the following attributes:
</p>
<table>
<tr><td><code>x</code></td>
<td>

<p>a numeric matrix or data frame which equals the input of <code>x</code>.
</p>
</td></tr>
<tr><td><code>c</code></td>
<td>

<p>a numeric matrix or data frame which is the covariance or correlation
matrix based on the input of <code>cov</code>.
</p>
</td></tr>
<tr><td><code>loadings</code></td>
<td>

<p>a matrix of variable loadings (i.e. a matrix containing the
eigenvectors of the dispersion matrix).
</p>
</td></tr>
<tr><td><code>threshold</code></td>
<td>

<p>a numeric value which equals the input of <code>thresholds</code>.
</p>
</td></tr>
<tr><td><code>threshold_mode</code></td>
<td>

<p>a character string which equals the input of <code>threshold_mode</code>.
</p>
</td></tr>
<tr><td><code>blocks</code></td>
<td>

<p>a list of blocks which are identified by principal loading analysis.
</p>
</td></tr>
</table>
<p>See Bauer and Drabant (2021) for more information.
</p>


<h3>References</h3>

<p>Bauer JO, Drabant B (2021).
&ldquo;Principal loading analysis.&rdquo;
<em>Journal of Multivariate Analysis</em>, <b>184</b>, 104754.
ISSN 0047259X, <a href="https://doi.org/10.1016/j.jmva.2021.104754">doi:10.1016/j.jmva.2021.104754</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("AER")){
require(AER)
data("OECDGrowth")

## The scales in OECDGrowth differ hence using the correlation matrix is
## highly recommended.

pla(OECDGrowth, thresholds=0.5) ## not recommended
pla(OECDGrowth, cor=TRUE, thresholds=0.5)

## We obtain three blocks: (randd), (gdp85, gdp60) and (invest, school,
## popgrowth). Block 1, i.e. the 1x1 block (randd), explains only 5.76% of
## the overall variance. Hence, discarding this block seems appropriate.

pla_obj = pla(OECDGrowth, cor=TRUE, thresholds=0.5)
pla.drop_blocks(pla_obj, c(1)) ## drop block 1

## Sometimes, considering the blocks we keep rather than the blocks we want
## to discard might be more convenient.

pla.keep_blocks(pla_obj, c(2,3)) ## keep block 2 and block 3
}

</code></pre>

<hr>
<h2 id='pla.drop_blocks'>Drop Blocks</h2><span id='topic+pla.drop_blocks'></span>

<h3>Description</h3>

<p>Used to pass the indices of the blocks we want to discard.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pla.drop_blocks(object, blocks, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pla.drop_blocks_+3A_object">object</code></td>
<td>
<p>a pla object.</p>
</td></tr>
<tr><td><code id="pla.drop_blocks_+3A_blocks">blocks</code></td>
<td>
<p>a list of numeric values indicating the indices of the blocks
that should be removed.</p>
</td></tr>
<tr><td><code id="pla.drop_blocks_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of the following attributes:
</p>
<table>
<tr><td><code>x</code></td>
<td>

<p>a numeric matrix or data frame containing the reduced set of original
variables.
</p>
</td></tr>
<tr><td><code>cc_matrix</code></td>
<td>

<p>a numeric matrix or data frame which contains the conditional dispersion
matrix. Depending on the pla procedure, this is either the conditional
covariance matrix or the conditional correlation matrix.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("AER")){
require(AER)
data("OECDGrowth")

pla(OECDGrowth, cor=TRUE, thresholds=0.5)

## we obtain three blocks: (randd), (gdp85,gdp60) and (invest, school,
## popgrowth). Block 1, i.e. the 1x1 block (randd), explains only 5.76% of
## the overall variance. Hence, discarding this block seems appropriate.

pla_obj = pla(OECDGrowth, cor=TRUE, thresholds=0.5)
pla.drop_blocks(pla_obj, c(1)) ## drop block 1
}

</code></pre>

<hr>
<h2 id='pla.keep_blocks'>Keep Blocks</h2><span id='topic+pla.keep_blocks'></span>

<h3>Description</h3>

<p>Used to pass the indices of the blocks we want to keep (i.e.
which we do no want to be discarded).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pla.keep_blocks(object, blocks, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pla.keep_blocks_+3A_object">object</code></td>
<td>
<p>a <code>pla</code> object.</p>
</td></tr>
<tr><td><code id="pla.keep_blocks_+3A_blocks">blocks</code></td>
<td>
<p>a list of numeric values indicating the indices of the blocks
that should be kept.</p>
</td></tr>
<tr><td><code id="pla.keep_blocks_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of the following attributes:
</p>
<table>
<tr><td><code>x</code></td>
<td>

<p>a numeric matrix or data frame containing the reduced set of original
variables.
</p>
</td></tr>
<tr><td><code>cc_matrix</code></td>
<td>

<p>a numeric matrix or data frame which contains the conditional dispersion
matrix. Depending on the pla procedure, this is either the conditional
covariance matrix or the conditional correlation matrix.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("AER")){
require(AER)
data("OECDGrowth")

pla(OECDGrowth, cor=TRUE, thresholds=0.5)

## we obtain three blocks: (randd), (gdp85,gdp60) and (invest, school,
## popgrowth). Block 1, i.e. the 1x1 block (randd), explains only 5.76% of
## the overall variance. Hence, discarding this block seems appropriate.
## Therefore, we keep block 2 and block 3.

pla_obj = pla(OECDGrowth, cor=TRUE, thresholds=0.5)
pla.keep_blocks(pla_obj, c(2,3)) ## keep block 2 and block 3
}

</code></pre>

<hr>
<h2 id='print.pla'>Print Function for pla S3</h2><span id='topic+print.pla'></span>

<h3>Description</h3>

<p>Prints the blocks, threshold, threshold_mode and the loadings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pla'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.pla_+3A_x">x</code></td>
<td>
<p>a pla object.</p>
</td></tr>
<tr><td><code id="print.pla_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A pla object which equals the input of <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(requireNamespace("AER")){
require(AER)
data("OECDGrowth")

pla_obj = pla(OECDGrowth, cor=TRUE, thresholds=0.5)
print(pla_obj)
}

</code></pre>

<hr>
<h2 id='show+2CBlock-method'>Block - Show</h2><span id='topic+show+2CBlock-method'></span>

<h3>Description</h3>

<p>Prints the blocks structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Block'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2CBlock-method_+3A_object">object</code></td>
<td>
<p>block.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>block &lt;- new("Block", features=c(2, 5), explained_variance=0.03)
print(block)
</code></pre>

<hr>
<h2 id='spla'>Sparse Principal Loading Analysis</h2><span id='topic+spla'></span>

<h3>Description</h3>

<p>This function performs sparse principal loading analysis
on the given data matrix. We refer to Bauer (2022) for more information.
The corresponding sparse loadings are calculated either using <code>PMD</code> from
the <code>PMA</code> package or using <code>spca</code> from the <code>elasticnet</code>
package. The respective methods are given by Zou et al. (2006) and Witten et
al. (2009) respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spla(
  x,
  method = c("pmd", "spca"),
  para,
  cor = FALSE,
  criterion = c("corrected", "normal"),
  threshold = 1e-07,
  rho = 1e-06,
  max.iter = 200,
  trace = FALSE,
  eps.conv = 0.001,
  orthogonal = TRUE,
  check = c("rnc", "rows"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spla_+3A_x">x</code></td>
<td>
<p>a numeric matrix or data frame which provides the data for the
sparse principal loading analysis.</p>
</td></tr>
<tr><td><code id="spla_+3A_method">method</code></td>
<td>
<p>chooses the methods to calculate the sparse loadings.
<code>pmd</code> uses the method from Witten et al. (2009) and <code>spca</code> uses the
method from Zou et al. (2006).</p>
</td></tr>
<tr><td><code id="spla_+3A_para">para</code></td>
<td>
<p>when <code>method="pmd"</code>: an integer giving the bound for the
L1 regularization. When <code>method="spca"</code>: a vector containing the
regularization parameter for each variable.</p>
</td></tr>
<tr><td><code id="spla_+3A_cor">cor</code></td>
<td>
<p>a logical value indicating whether the calculation should use the
correlation or the covariance matrix.</p>
</td></tr>
<tr><td><code id="spla_+3A_criterion">criterion</code></td>
<td>
<p>a character string indicating if the weight-corrected
evaluation criterion (CEC) or the evaluation criterion (EC) is used.
<code>corrected</code> changes the loadings to weight all variables equally while
<code>normal</code> does not change the loadings.</p>
</td></tr>
<tr><td><code id="spla_+3A_threshold">threshold</code></td>
<td>
<p>a numeric value used to determine zero elements in the
loading. This serves mostly to correct approximation errors.</p>
</td></tr>
<tr><td><code id="spla_+3A_rho">rho</code></td>
<td>
<p>penalty parameter. When <code>method="SPCA"</code>, we need further
regularizations for the case when the number of variables is larger than the
number of observations. We refer to Zou et al. (2006) and Bauer (2022) for
more details.</p>
</td></tr>
<tr><td><code id="spla_+3A_max.iter">max.iter</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="spla_+3A_trace">trace</code></td>
<td>
<p>a logical value indicating if the progress is printed.</p>
</td></tr>
<tr><td><code id="spla_+3A_eps.conv">eps.conv</code></td>
<td>
<p>a numerical value as convergence criterion.</p>
</td></tr>
<tr><td><code id="spla_+3A_orthogonal">orthogonal</code></td>
<td>
<p>a logical value indicating if the sparse loadings are
orthogonalized.</p>
</td></tr>
<tr><td><code id="spla_+3A_check">check</code></td>
<td>
<p>a character string indicating if only rows or rows as well as
columns are used to detect the underlying block structure. <code>rows</code> checks
if the rows fulfill the required structure. <code>rnc</code> checks if rows and
columns fulfill the required structure.</p>
</td></tr>
<tr><td><code id="spla_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>single or list of <code>pla</code> class containing the following attributes:
</p>
<table>
<tr><td><code>x</code></td>
<td>

<p>a numeric matrix or data frame which equals the input of <code>x</code>.
</p>
</td></tr>
<tr><td><code>EC</code></td>
<td>

<p>a numeric vector that contains the weight-corrected evaluation criterion
(CEC) if <code>criterion="corrected"</code> and the evaluation criterion (EC) if
<code>criterion="normal"</code>.
</p>
</td></tr>
<tr><td><code>loadings</code></td>
<td>

<p>a matrix of variable loadings (i.e. a matrix containing the sparse
loadings).
</p>
</td></tr>
<tr><td><code>blocks</code></td>
<td>

<p>a list of blocks which are identified by sparse principal loading analysis.
</p>
</td></tr>
<tr><td><code>W</code></td>
<td>

<p>a matrix of variable loadings used to calculate the evaluation criterion.
If <code>criterion="corrected"</code>, <code>W</code> contains an orthogonal matrix
with equal weights in the first column of each loading-block. If
<code>criterion="normal"</code>, <code>W</code> are the <code>loadings</code>.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Bauer JO (2022).
&ldquo;Variable selection and covariance structure identification using sparse principal loading analysis.&rdquo;
<em>Working Paper</em>.
Witten DM, Tibshirani R, Hastie TA (2009).
&ldquo;A penalized matrix decomposition, with applications to sparse principal components and canonical correlation analysis.&rdquo;
<em>Biostatistics</em>, <b>10</b>(3), 515-534.
<a href="https://doi.org/10.1093/biostatistics/kxp008">doi:10.1093/biostatistics/kxp008</a>.
Zou H, Hastie T, Tibshirani R (2006).
&ldquo;Sparse Principal Component Analysis.&rdquo;
<em>Journal of Computational and Graphical Statistics</em>, <b>15</b>(2), 265&ndash;286.
ISSN 1061-8600, <a href="https://doi.org/10.1198/106186006X113430">doi:10.1198/106186006X113430</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############
## First example: we apply SPLA to a classic example from PCA
#############

spla(USArrests, method = "spca", para=c(0.5, 0.5, 0.5, 0.5), cor=TRUE)

## we obtain two blocks:
## 1x1 (Urbanpop) and 3x3 (Murder, Aussault, Rape).
## The large CEC of 0.922 indicates that the given structure is reasonable.

spla(USArrests, method = "spca", para=c(0.5, 0.5, 0.7, 0.5), cor=TRUE)

## we obtain three blocks:
## 1x1 (Urbanpop), 1x1 (Rape) and 2x2 (Murder, Aussault).
## The mid-ish CEC of 0.571 for (Murder, Aussault) indicates that the found 
## structure might not be adequate.

#############
## Second example: we replicate a synthetic example similar to Bauer (2022)
#############

set.seed(1)
N = 500
V1 = rnorm(N,0,10)
V2 = rnorm(N,0,11)

## Create the blocks (X_1,...,X_4) and (X_5,...,X_8) synthetically

X1 = V1 + rnorm(N,0,1) #X_j = V_1 + N(0,1) for j =1,...,4
X2 = V1 + rnorm(N,0,1)
X3 = V1 + rnorm(N,0,1)
X4 = V1 + rnorm(N,0,1)

X5 = V2 + rnorm(N,0,1) #X_j = V_1 + N(0,1) for j =5,...9
X6 = V2 + rnorm(N,0,1)
X7 = V2 + rnorm(N,0,1)
X8 = V2 + rnorm(N,0,1)

X = cbind(X1, X2, X3, X4, X5, X6, X7, X8)

## Conduct SPLA to obtain the blocks (X_1,...,X_4) and (X_5,...,X_8)

## use method = "pmd" (default)
spla(X, para = 1.4)

## use method = "spca"
spla(X, method = "spca", para = c(500,60,3,8,5,7,13,4))

</code></pre>

<hr>
<h2 id='str+2CBlock-method'>Block - str</h2><span id='topic+str+2CBlock-method'></span>

<h3>Description</h3>

<p>Generic function to create a string out of the blocks structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Block'
str(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="str+2B2CBlock-method_+3A_object">object</code></td>
<td>
<p>block.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string representing the Block.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>block &lt;- new("Block", features=c(2, 5), explained_variance=0.03)
str(block)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
