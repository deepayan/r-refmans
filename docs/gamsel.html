<!DOCTYPE html><html lang="en"><head><title>Help for package gamsel</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gamsel}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#gamsel-package'><p>Fit Regularization Path for Generalized Additive Models</p></a></li>
<li><a href='#basis.gen'><p>Generate basis</p></a></li>
<li><a href='#cv.gamsel'><p>Cross-validation Routine for Gamsel</p></a></li>
<li><a href='#gamsel'><p>Fit Regularization Path for Gaussian or Binomial Generalized Additive Model</p></a></li>
<li><a href='#gamsel-internal'><p>Internal gamsel functions</p></a></li>
<li><a href='#getActive'><p>Returns active variables</p></a></li>
<li><a href='#plot.cv.gamsel'><p>Plotting Routine for Gamsel Cross-Validation Object</p></a></li>
<li><a href='#plot.gamsel'><p>Plotting Routine <code>gamsel</code> Object</p></a></li>
<li><a href='#predict.gamsel'><p>Gamsel Prediction Routine</p></a></li>
<li><a href='#print.gamsel'><p>print a gamsel object</p></a></li>
<li><a href='#pseudo.bases'><p>Generate pseudo-spline bases</p></a></li>
<li><a href='#summary.gamsel'><p>Gamsel summary routine</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fit Regularization Path for Generalized Additive Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.8-5</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-09-24</td>
</tr>
<tr>
<td>Description:</td>
<td>Using overlap grouped-lasso penalties, 'gamsel' selects whether a term in a 'gam' is nonzero, linear, or a non-linear spline (up to a specified max df per variable). It fits the entire regularization path on a grid of values for the overall penalty lambda, both for gaussian and binomial families. See  &lt;<a href="https://doi.org/10.48550%2FarXiv.1506.03850">doi:10.48550/arXiv.1506.03850</a>&gt; for more details.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>foreach, mda, splines</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://arxiv.org/abs/1506.03850">https://arxiv.org/abs/1506.03850</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-24 19:47:33 UTC; hastie</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexandra Chouldechova [aut],
  Trevor Hastie [aut, cre],
  Balasubramanian Narasimhan [ctb],
  Vitalie Spinu [ctb],
  Matt Wand [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Trevor Hastie &lt;hastie@stanford.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-24 21:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='gamsel-package'>Fit Regularization Path for Generalized Additive Models</h2><span id='topic+gamsel-package'></span>

<h3>Description</h3>

<p>Using overlap grouped lasso penalties, gamsel selects whether a
term in a gam is nonzero, linear, or a non-linear spline (up to a
specified max df per variable). It fits the entire regularization
path on a grid of values for the overall penalty lambda, both for
gaussian and binomial families. Key functions are <a href="#topic+gamsel">gamsel</a>,
<a href="#topic+predict.gamsel">predict.gamsel</a>, <a href="#topic+plot.gamsel">plot.gamsel</a>, <a href="#topic+print.gamsel">print.gamsel</a>, <a href="#topic+summary.gamsel">summary.gamsel</a>,
<a href="#topic+cv.gamsel">cv.gamsel</a>, <a href="#topic+plot.cv.gamsel">plot.cv.gamsel</a>
</p>


<h3>Author(s)</h3>

<p>Alexandra Chouldechova, Trevor Hastie Maintainer: Trevor Hastie
<a href="mailto:hastie@stanford.edu">hastie@stanford.edu</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://arxiv.org/abs/1506.03850">https://arxiv.org/abs/1506.03850</a>
</p>
</li></ul>


<hr>
<h2 id='basis.gen'>Generate basis</h2><span id='topic+basis.gen'></span>

<h3>Description</h3>

<p>Generate basis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basis.gen(x, df = 6, thresh = 0.01, degree = 8, parms = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="basis.gen_+3A_x">x</code></td>
<td>
<p>A vector of values for <code>basis.gen</code>, or a matrix for
<code>pseudo.bases</code></p>
</td></tr>
<tr><td><code id="basis.gen_+3A_df">df</code></td>
<td>
<p>The degrees of freedom of the smoothing spline.</p>
</td></tr>
<tr><td><code id="basis.gen_+3A_thresh">thresh</code></td>
<td>
<p>If the next eigenvector improves the approximation by less
than threshold, a truncated bases is returned. For <code>pseudo.bases</code> this
can be a single value or a vector of values, which are recycled sequentially
for each column of <code>x</code></p>
</td></tr>
<tr><td><code id="basis.gen_+3A_degree">degree</code></td>
<td>
<p>The nominal number of basis elements. The basis returned has
no more than <code>degree</code> columns. For <code>pseudo.bases</code> this can be a
single value or a vector of values, which are recycled sequentially for each
column of <code>x</code></p>
</td></tr>
<tr><td><code id="basis.gen_+3A_parms">parms</code></td>
<td>
<p>A parameter set. If included in the call, these are used to
define the basis. This is used for prediction.</p>
</td></tr>
<tr><td><code id="basis.gen_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the basis
</p>

<hr>
<h2 id='cv.gamsel'>Cross-validation Routine for Gamsel</h2><span id='topic+cv.gamsel'></span>

<h3>Description</h3>

<p>A routine for performing K-fold cross-validation for gamsel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.gamsel(
  x,
  y,
  lambda = NULL,
  family = c("gaussian", "binomial"),
  degrees = rep(10, p),
  dfs = rep(5, p),
  bases = pseudo.bases(x, degrees, dfs, parallel = parallel, ...),
  type.measure = c("mse", "mae", "deviance", "class"),
  nfolds = 10,
  foldid,
  keep = FALSE,
  parallel = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv.gamsel_+3A_x">x</code></td>
<td>
<p><code>x</code> matrix as in <code>gamsel</code></p>
</td></tr>
<tr><td><code id="cv.gamsel_+3A_y">y</code></td>
<td>
<p>response <code>y</code> as in <code>gamsel</code></p>
</td></tr>
<tr><td><code id="cv.gamsel_+3A_lambda">lambda</code></td>
<td>
<p>Optional use-supplied lambda sequence.  If <code>NULL</code>,
default behaviour is for <code>gamsel</code> routine to automatically select a
good lambda sequence.</p>
</td></tr>
<tr><td><code id="cv.gamsel_+3A_family">family</code></td>
<td>
<p><code>family</code> as in <code>gamsel</code></p>
</td></tr>
<tr><td><code id="cv.gamsel_+3A_degrees">degrees</code></td>
<td>
<p><code>degrees</code> as in <code>gamsel</code></p>
</td></tr>
<tr><td><code id="cv.gamsel_+3A_dfs">dfs</code></td>
<td>
<p><code>dfs</code> as in <code>gamsel</code></p>
</td></tr>
<tr><td><code id="cv.gamsel_+3A_bases">bases</code></td>
<td>
<p><code>bases</code> as in <code>gamsel</code></p>
</td></tr>
<tr><td><code id="cv.gamsel_+3A_type.measure">type.measure</code></td>
<td>
<p>Loss function for cross-validated error calculation.
Currently there are four options: <code>mse</code> (mean squared error),
<code>mae</code> (mean absolute error), <code>deviance</code> (deviance, same as
<code>mse</code> for <code>family="gaussian"</code>), <code>class</code> (misclassification
error, for use with <code>family="binomial"</code>).</p>
</td></tr>
<tr><td><code id="cv.gamsel_+3A_nfolds">nfolds</code></td>
<td>
<p>Numer of folds (default is 10).  Maximum value is <code>nobs</code>.
Small values of <code>nfolds</code> are recommended for large data sets.</p>
</td></tr>
<tr><td><code id="cv.gamsel_+3A_foldid">foldid</code></td>
<td>
<p>Optional vector of length <code>nobs</code> with values between 1
and <code>nfolds</code> specifying what fold each observation is in.</p>
</td></tr>
<tr><td><code id="cv.gamsel_+3A_keep">keep</code></td>
<td>
<p>If <code>keep=TRUE</code>, a <em>prevalidated</em> array is returned
containing fitted values for each observation and each value of
<code>lambda</code>. This means these fits are computed with this observation and
the rest of its fold omitted. The <code>folid</code> vector is also returned.
Default is keep=FALSE</p>
</td></tr>
<tr><td><code id="cv.gamsel_+3A_parallel">parallel</code></td>
<td>
<p>If <code>TRUE</code>, use parallel <code>foreach</code> to fit each
fold. See the example below for usage details.</p>
</td></tr>
<tr><td><code id="cv.gamsel_+3A_...">...</code></td>
<td>
<p>Other arguments that can be passed to <code>gamsel</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function has the effect of running <code>gamsel</code> <code>nfolds</code>+1 times.
The initial run uses all the data and gets the <code>lambda</code> sequence.  The
remaining runs fit the data with each of the folds omitted in turn.  The
error is accumulated, and the average error and standard deviation over the
folds is computed.  Note that <code>cv.gamsel</code> does NOT search for values
for <code>gamma</code>. A specific value should be supplied, else <code>gamma=.4</code>
is assumed by default. If users would like to cross-validate <code>gamma</code> as
well, they should call <code>cv.gamsel</code> with a pre-computed vector
<code>foldid</code>, and then use this same fold vector in separate calls to
<code>cv.gamsel</code> with different values of <code>gamma</code>. Note also that the
results of <code>cv.gamsel</code> are random, since the folds are selected at
random. Users can reduce this randomness by running <code>cv.gamsel</code> many
times, and averaging the error curves.
</p>


<h3>Value</h3>

<p>an object of class <code>"cv.gamsel"</code> is returned, which is a list
with the ingredients of the cross-validation fit.  </p>
<table role = "presentation">
<tr><td><code>lambda</code></td>
<td>
<p>the values
of <code>lambda</code> used in the fits.</p>
</td></tr> <tr><td><code>cvm</code></td>
<td>
<p>The mean cross-validated
error - a vector of length <code>length(lambda)</code>.</p>
</td></tr> <tr><td><code>cvsd</code></td>
<td>
<p>estimate of
standard error of <code>cvm</code>.</p>
</td></tr> <tr><td><code>cvup</code></td>
<td>
<p>upper curve = <code>cvm+cvsd</code>.</p>
</td></tr>
<tr><td><code>cvlo</code></td>
<td>
<p>lower curve = <code>cvm-cvsd</code>.</p>
</td></tr> <tr><td><code>nzero</code></td>
<td>
<p>number of non-zero
coefficients at each <code>lambda</code>.</p>
</td></tr> <tr><td><code>name</code></td>
<td>
<p>a text string indicating
type of measure (for plotting purposes).</p>
</td></tr> <tr><td><code>gamsel.fit</code></td>
<td>
<p>a fitted gamsel
object for the full data.</p>
</td></tr> <tr><td><code>lambda.min</code></td>
<td>
<p>value of <code>lambda</code> that
gives minimum <code>cvm</code>.</p>
</td></tr> <tr><td><code>lambda.1se</code></td>
<td>
<p>largest value of <code>lambda</code>
such that error is within 1 standard error of the minimum.</p>
</td></tr>
<tr><td><code>fit.preval</code></td>
<td>
<p>if <code>keep=TRUE</code>, this is the array of prevalidated
fits. Some entries can be <code>NA</code>, if that and subsequent values of
<code>lambda</code> are not reached for that fold</p>
</td></tr> <tr><td><code>foldid</code></td>
<td>
<p>if
<code>keep=TRUE</code>, the fold assignments used</p>
</td></tr> <tr><td><code>index.min</code></td>
<td>
<p>the sequence
number of the minimum lambda.</p>
</td></tr> <tr><td><code>index.1se</code></td>
<td>
<p>the sequence number of the
1se lambda value.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexandra Chouldechova and Trevor Hastie<br /> Maintainer: Trevor
Hastie <a href="mailto:hastie@stanford.edu">hastie@stanford.edu</a>
</p>


<h3>References</h3>

<p>Chouldechova, A. and Hastie, T. (2015) <em>Generalized
Additive Model Selection</em>
</p>


<h3>See Also</h3>

<p><code>gamsel</code>, <code>plot</code> function for <code>cv.gamsel</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##data=gamsel:::gendata(n=500,p=12,k.lin=3,k.nonlin=3,deg=8,sigma=0.5)
data = readRDS(system.file("extdata/gamsel_example.RDS", package = "gamsel"))
attach(data)
bases=pseudo.bases(X,degree=10,df=6)
# Gaussian gam
gamsel.out=gamsel(X,y,bases=bases)
par(mfrow=c(1,2),mar=c(5,4,3,1))
summary(gamsel.out)
gamsel.cv=cv.gamsel(X,y,bases=bases)
par(mfrow=c(1,1))
plot(gamsel.cv)
par(mfrow=c(3,4))
plot(gamsel.out,newx=X,index=20)

</code></pre>

<hr>
<h2 id='gamsel'>Fit Regularization Path for Gaussian or Binomial Generalized Additive Model</h2><span id='topic+gamsel'></span>

<h3>Description</h3>

<p>Using overlap grouped lasso penalties, gamsel selects whether a term in a
gam is nonzero, linear, or a non-linear spline (up to a specified max df per
variable). It fits the entire regularization path on a grid of values for
the overall penalty lambda, both for gaussian and binomial families.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamsel(
  x,
  y,
  num_lambda = 50,
  lambda = NULL,
  family = c("gaussian", "binomial"),
  degrees = rep(10, p),
  gamma = 0.4,
  dfs = rep(5, p),
  bases = pseudo.bases(x, degrees, dfs, parallel = parallel, ...),
  tol = 1e-04,
  max_iter = 2000,
  traceit = FALSE,
  parallel = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gamsel_+3A_x">x</code></td>
<td>
<p>Input (predictor) matrix of dimension <code>nobs</code> x <code>nvars</code>.
Each observation is a row.</p>
</td></tr>
<tr><td><code id="gamsel_+3A_y">y</code></td>
<td>
<p>Response variable.  Quantitative for <code>family="gaussian"</code> and
with values in <code>{0,1}</code> for <code>family="binomial"</code></p>
</td></tr>
<tr><td><code id="gamsel_+3A_num_lambda">num_lambda</code></td>
<td>
<p>Number of <code>lambda</code> values to use. (Length of
<code>lambda</code> sequence.)</p>
</td></tr>
<tr><td><code id="gamsel_+3A_lambda">lambda</code></td>
<td>
<p>User-supplied <code>lambda</code> sequence.  For best performance,
leave as <code>NULL</code> and allow the routine to automatically select
<code>lambda</code>.  Otherwise, supply a (preferably gradually) decreasing
sequence.</p>
</td></tr>
<tr><td><code id="gamsel_+3A_family">family</code></td>
<td>
<p>Response type. <code>"gaussian"</code> for linear model (default).
<code>"binomial"</code> for logistic model.</p>
</td></tr>
<tr><td><code id="gamsel_+3A_degrees">degrees</code></td>
<td>
<p>An integer vector of length <code>nvars</code> specifying the
maximum number of spline basis functions to use for each variable.</p>
</td></tr>
<tr><td><code id="gamsel_+3A_gamma">gamma</code></td>
<td>
<p>Penalty mixing parameter <code class="reqn">0 \le\gamma\le 1</code>.  Values <code class="reqn">
\gamma &lt; 0.5</code> penalize linear fit less than non-linear fit.  The default is
<code class="reqn">\gamma = 0.4</code>, which encourages a linear term over a nonlinear term.</p>
</td></tr>
<tr><td><code id="gamsel_+3A_dfs">dfs</code></td>
<td>
<p>Numeric vector of length <code>nvars</code> specifying the maximum
(end-of-path) degrees of freedom for each variable.</p>
</td></tr>
<tr><td><code id="gamsel_+3A_bases">bases</code></td>
<td>
<p>A list of orthonormal bases for the non-linear terms for each
variable. The function <code>pseudo.bases</code> generates these, using the
parameters <code>dfs</code> and <code>degrees</code>. See the documentation for
<code><a href="#topic+pseudo.bases">pseudo.bases</a></code>.</p>
</td></tr>
<tr><td><code id="gamsel_+3A_tol">tol</code></td>
<td>
<p>Convergence threshold for coordinate descent.  The coordinate
descent loop continues until the total change in objective after a pass over
all variables is less than <code>tol</code>.  Default is <code>1e-4</code>.</p>
</td></tr>
<tr><td><code id="gamsel_+3A_max_iter">max_iter</code></td>
<td>
<p>Maximum number of coordinate descent iterations over all the
variables for each <code>lambda</code> value.  Default is 2000.</p>
</td></tr>
<tr><td><code id="gamsel_+3A_traceit">traceit</code></td>
<td>
<p>If <code>TRUE</code>, various information is printed during the
fitting process.</p>
</td></tr>
<tr><td><code id="gamsel_+3A_parallel">parallel</code></td>
<td>
<p>passed on to the <code>pseudo.bases()</code> function. Uses
multiple process if available.</p>
</td></tr>
<tr><td><code id="gamsel_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to <code>pseudo.bases()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sequence of models along the <code>lambda</code> path is fit by (block)
cordinate descent.  In the case of logistic regression the fitting routine
may terminate before all <code>num_lambda</code> values of <code>lambda</code> have been
used.  This occurs when the fraction of null deviance explained by the model
gets too close to 1, at which point the fit becomes numerically unstable.
Each of the smooth terms is computed using an approximation to the
Demmler-Reinsch smoothing spline basis for that variable, and the
accompanying diagonal pernalty matrix.
</p>


<h3>Value</h3>

<p>An object with S3 class <code>gamsel</code>.  %% If it is a LIST, use
</p>
<table role = "presentation">
<tr><td><code>intercept</code></td>
<td>
<p>Intercept sequence of length <code>num_lambda</code></p>
</td></tr>
<tr><td><code>alphas</code></td>
<td>
<p><code>nvars</code> x <code>num_lambda</code> matrix of linear coefficient
estimates</p>
</td></tr> <tr><td><code>betas</code></td>
<td>
<p><code>sum(degrees)</code> x <code>num_lambda</code> matrix of
non-linear coefficient estimates</p>
</td></tr> <tr><td><code>lambdas</code></td>
<td>
<p>The sequence of lambda
values used</p>
</td></tr> <tr><td><code>degrees</code></td>
<td>
<p>Number of basis functions used for each
variable</p>
</td></tr> <tr><td><code>parms</code></td>
<td>
<p>A set of parameters that capture the bases used. This
allows for efficient generation of the bases elements for
<code>predict.gamsel</code></p>
</td></tr></table>
<p>, the <code>predict</code> method for this class.
</p>
<table role = "presentation">
<tr><td><code>family</code></td>
<td>
<p><code>"gaussian"</code> or <code>"binomial"</code></p>
</td></tr> <tr><td><code>nulldev</code></td>
<td>
<p>Null
deviance (deviance of the intercept model)</p>
</td></tr> <tr><td><code>dev.ratio</code></td>
<td>
<p>Vector of
length <code>num_lambda</code> giving fraction of (null) deviance explained by
each model along the <code>lambda</code> sequence</p>
</td></tr> <tr><td><code>call</code></td>
<td>
<p>The call that
produced this object</p>
</td></tr></table>
<p> %% ...
</p>


<h3>Author(s)</h3>

<p>Alexandra Chouldechova and Trevor Hastie<br /> Maintainer: Trevor
Hastie <a href="mailto:hastie@stanford.edu">hastie@stanford.edu</a>
</p>


<h3>References</h3>

<p>Chouldechova, A. and Hastie, T. (2015) <em>Generalized
Additive Model Selection</em>, <a href="https://arxiv.org/abs/1506.03850">https://arxiv.org/abs/1506.03850</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.gamsel">predict.gamsel</a></code>, <code><a href="#topic+cv.gamsel">cv.gamsel</a></code>,
<code><a href="#topic+plot.gamsel">plot.gamsel</a></code>, <code><a href="#topic+summary.gamsel">summary.gamsel</a></code>,
<code><a href="#topic+basis.gen">basis.gen</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##data=gamsel:::gendata(n=500,p=12,k.lin=3,k.nonlin=3,deg=8,sigma=0.5)
data = readRDS(system.file("extdata/gamsel_example.RDS", package = "gamsel"))
attach(data)
bases=pseudo.bases(X,degree=10,df=6)
# Gaussian gam
gamsel.out=gamsel(X,y,bases=bases)
par(mfrow=c(1,2),mar=c(5,4,3,1))
summary(gamsel.out)
gamsel.cv=cv.gamsel(X,y,bases=bases)
par(mfrow=c(1,1))
plot(gamsel.cv)
par(mfrow=c(3,4))
plot(gamsel.out,newx=X,index=20)
# Binomial model
gamsel.out=gamsel(X,yb,family="binomial")
par(mfrow=c(1,2),mar=c(5,4,3,1))
summary(gamsel.out)
par(mfrow=c(3,4))
plot(gamsel.out,newx=X,index=30)

</code></pre>

<hr>
<h2 id='gamsel-internal'>Internal gamsel functions</h2><span id='topic+gamsel-internal'></span><span id='topic+basis.subset'></span><span id='topic+df.inv'></span><span id='topic+fracdev'></span><span id='topic+getmin'></span><span id='topic+norm2'></span><span id='topic+poly'></span><span id='topic+summarynz'></span><span id='topic+summaryplot'></span><span id='topic+error.bars'></span>

<h3>Description</h3>

<p>These are not intended for use by users.
</p>


<h3>Author(s)</h3>

<p>Trevor Hastie
</p>

<hr>
<h2 id='getActive'>Returns active variables</h2><span id='topic+getActive'></span>

<h3>Description</h3>

<p>Extract active variables of different kinds from a gamsel object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getActive(
  object,
  index = NULL,
  type = c("nonzero", "linear", "nonlinear"),
  EPS = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getActive_+3A_object">object</code></td>
<td>
<p>gamsel object</p>
</td></tr>
<tr><td><code id="getActive_+3A_index">index</code></td>
<td>
<p>index or vector of indices at which to obtain active
information. <code>NULL</code> returns all.</p>
</td></tr>
<tr><td><code id="getActive_+3A_type">type</code></td>
<td>
<p>type of active variables to report. One of <code>c("nonzero",
"linear", "nonlinear")</code></p>
</td></tr>
<tr><td><code id="getActive_+3A_eps">EPS</code></td>
<td>
<p>threshold for what is nonzero; default is 0</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a vector of variables indices of variables having the desired
properties.
</p>


<h3>Value</h3>

<p>vector of indices
</p>

<hr>
<h2 id='plot.cv.gamsel'>Plotting Routine for Gamsel Cross-Validation Object</h2><span id='topic+plot.cv.gamsel'></span>

<h3>Description</h3>

<p>Produces a cross-validation curve with standard errors for a fitted gamsel
objecty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.gamsel'
plot(x, sign.lambda = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.cv.gamsel_+3A_x">x</code></td>
<td>
<p><code>cv.gamsel</code> object</p>
</td></tr>
<tr><td><code id="plot.cv.gamsel_+3A_sign.lambda">sign.lambda</code></td>
<td>
<p>Either plot against <code>log(lambda)</code> (default) against
<code>-lambda</code> if <code>sign.lambda=-1</code>.</p>
</td></tr>
<tr><td><code id="plot.cv.gamsel_+3A_...">...</code></td>
<td>
<p>Optional graphical parameters to plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A plot showing cross-validation error is produced.  Nothing is returned.
</p>


<h3>Author(s)</h3>

<p>Alexandra Chouldechova and Trevor Hastie<br /> Maintainer: Trevor
Hastie <a href="mailto:hastie@stanford.edu">hastie@stanford.edu</a>
</p>


<h3>References</h3>

<p>Chouldechova, A. and Hastie, T. (2015) <em>Generalized
Additive Model Selection</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##data=gamsel:::gendata(n=500,p=12,k.lin=3,k.nonlin=3,deg=8,sigma=0.5)
data = readRDS(system.file("extdata/gamsel_example.RDS", package = "gamsel"))
attach(data)
bases=pseudo.bases(X,degree=10,df=6)
# Gaussian gam
gamsel.out=gamsel(X,y,bases=bases)
gamsel.cv=cv.gamsel(X,y,bases=bases)
par(mfrow=c(1,1))
plot(gamsel.cv)
</code></pre>

<hr>
<h2 id='plot.gamsel'>Plotting Routine <code>gamsel</code> Object</h2><span id='topic+plot.gamsel'></span>

<h3>Description</h3>

<p>Produces plots of the estimated functions for specified variables at a given
value of <code>lambda</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gamsel'
plot(x, newx, index, which = 1:p, rugplot = TRUE, ylims, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.gamsel_+3A_x">x</code></td>
<td>
<p>Fitted <code>gamsel</code> object.</p>
</td></tr>
<tr><td><code id="plot.gamsel_+3A_newx">newx</code></td>
<td>
<p><code>nobs_new</code> x <code>p</code> matrix giving values of each
predictor at which to plot.</p>
</td></tr>
<tr><td><code id="plot.gamsel_+3A_index">index</code></td>
<td>
<p>Index of lambda value (i.e., model) for which plotting is
desired.</p>
</td></tr>
<tr><td><code id="plot.gamsel_+3A_which">which</code></td>
<td>
<p>Which values to plot.  Default is all variables, i.e.
<code>{1,2,...,nvars}</code>. Besides indices, which can take two special values:
<code>"nonzero"</code> will plot only the nonzero functions, and
<code>"nonlinear"</code> only the nonlinear functions.</p>
</td></tr>
<tr><td><code id="plot.gamsel_+3A_rugplot">rugplot</code></td>
<td>
<p>If <code>TRUE</code>, a rugplot showing values of <code>x</code> is shown
at the bottom of each fitted function plot.</p>
</td></tr>
<tr><td><code id="plot.gamsel_+3A_ylims">ylims</code></td>
<td>
<p><code>ylim</code> argument for plotting each curve, which overides
the default which is the range of all the functions.</p>
</td></tr>
<tr><td><code id="plot.gamsel_+3A_...">...</code></td>
<td>
<p>Optional graphical parameters to plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A plot of the specified fitted functions is produced.  Nothing is returned.
</p>


<h3>Author(s)</h3>

<p>Alexandra Chouldechova and Trevor Hastie<br /> Maintainer: Trevor
Hastie <a href="mailto:hastie@stanford.edu">hastie@stanford.edu</a>
</p>


<h3>References</h3>

<p>Chouldechova, A. and Hastie, T. (2015) <em>Generalized
Additive Model Selection</em>
</p>


<h3>See Also</h3>

<p><code>gamsel</code>, and <code>print.gamsel</code>, <code>summary.gamsel</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##set.seed(1211)
##data=gamsel:::gendata(n=500,p=12,k.lin=3,k.nonlin=3,deg=8,sigma=0.5)
data = readRDS(system.file("extdata/gamsel_example.RDS", package = "gamsel"))
attach(data)
bases=pseudo.bases(X,degree=10,df=6)
# Gaussian gam
gamsel.out=gamsel(X,y,bases=bases)
par(mfrow=c(3,4))
plot(gamsel.out,newx=X,index=20)

</code></pre>

<hr>
<h2 id='predict.gamsel'>Gamsel Prediction Routine</h2><span id='topic+predict.gamsel'></span>

<h3>Description</h3>

<p>Make predictions from a <code>gamsel</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gamsel'
predict(
  object,
  newdata,
  index = NULL,
  type = c("link", "response", "terms", "nonzero"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.gamsel_+3A_object">object</code></td>
<td>
<p>Fitted <code>gamsel</code> object.</p>
</td></tr>
<tr><td><code id="predict.gamsel_+3A_newdata">newdata</code></td>
<td>
<p><code>nobs_new</code> x <code>p</code> matrix of new data values at which
to predict.</p>
</td></tr>
<tr><td><code id="predict.gamsel_+3A_index">index</code></td>
<td>
<p>Index of model in the sequence for which plotting is desired.
Note, this is NOT a lambda value.</p>
</td></tr>
<tr><td><code id="predict.gamsel_+3A_type">type</code></td>
<td>
<p>Type of prediction desired. Type <code>link</code> gives the linear
predictors for <code>"binomial"</code>, and fitted values for <code>"gaussian"</code>.
Type <code>response</code> gives fitted probabilities for <code>"binomial"</code> and
fitted values for <code>"gaussian"</code>. Type <code>"terms"</code> returns a matrix of
fitted functions, with as many columns as there are variables. Type
<code>nonzero</code> returns a list of the indices of nonzero coefficients at the
given <code>lambda</code> index.</p>
</td></tr>
<tr><td><code id="predict.gamsel_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a vector aor a matrix is returned, depending on <code>type</code>.
</p>


<h3>Author(s)</h3>

<p>Alexandra Chouldechova and Trevor Hastie<br /> Maintainer: Trevor
Hastie <a href="mailto:hastie@stanford.edu">hastie@stanford.edu</a>
</p>


<h3>References</h3>

<p>Chouldechova, A. and Hastie, T. (2015) <em>Generalized
Additive Model Selection</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gamsel">gamsel</a></code>, <code><a href="#topic+cv.gamsel">cv.gamsel</a></code>,
<code><a href="#topic+summary.gamsel">summary.gamsel</a></code>, <code><a href="#topic+basis.gen">basis.gen</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##data=gamsel:::gendata(n=500,p=12,k.lin=3,k.nonlin=3,deg=8,sigma=0.5)
data = readRDS(system.file("extdata/gamsel_example.RDS", package = "gamsel"))
attach(data)
bases=pseudo.bases(X,degree=10,df=6)
# Gaussian gam
gamsel.out=gamsel(X,y,bases=bases)
preds=predict(gamsel.out,X,index=20,type="terms")

</code></pre>

<hr>
<h2 id='print.gamsel'>print a gamsel object</h2><span id='topic+print.gamsel'></span>

<h3>Description</h3>

<p>Print a summary of the gamsel path at each step along the path
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gamsel'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.gamsel_+3A_x">x</code></td>
<td>
<p>fitted gamsel object</p>
</td></tr>
<tr><td><code id="print.gamsel_+3A_digits">digits</code></td>
<td>
<p>significant digits in printout</p>
</td></tr>
<tr><td><code id="print.gamsel_+3A_...">...</code></td>
<td>
<p>additional print arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The call that produced the object <code>x</code> is printed, followed by a
five-column matrix with columns <code>NonZero</code>, <code>Lin</code>, <code>NonLin</code>, <code style="white-space: pre;">&#8288;%Dev&#8288;</code>
and <code>Lambda</code>.  The first three columns say how many nonzero, linear
and nonlinear terms there are. <code style="white-space: pre;">&#8288;%Dev&#8288;</code> is the percent deviance
explained (relative to the null deviance).
</p>


<h3>Value</h3>

<p>The matrix above is silently returned
</p>


<h3>Author(s)</h3>

<p>Alexandra Chouldechova and Trevor Hastie<br /> Maintainer: Trevor
Hastie <a href="mailto:hastie@stanford.edu">hastie@stanford.edu</a>
</p>


<h3>References</h3>

<p>Chouldechova, A. and Hastie, T. (2015) <em>Generalized Additive Model Selection</em>
</p>


<h3>See Also</h3>

<p><a href="#topic+predict.gamsel">predict.gamsel</a>, <a href="#topic+cv.gamsel">cv.gamsel</a>,
<a href="#topic+plot.gamsel">plot.gamsel</a>, <a href="#topic+summary.gamsel">summary.gamsel</a>,
<a href="#topic+basis.gen">basis.gen</a>
</p>

<hr>
<h2 id='pseudo.bases'>Generate pseudo-spline bases</h2><span id='topic+pseudo.bases'></span>

<h3>Description</h3>

<p>Generate an approximation to the Demmler-Reinsch orthonormal bases for
smoothing splines, using orthogonal polynomials. <code>basis.gen</code> generates
a basis for a single <code>x</code>, and <code>pseudo.bases</code> generates a list of
bases for each column of the matrix <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pseudo.bases(x, degree = 8, df = 6, parallel = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pseudo.bases_+3A_x">x</code></td>
<td>
<p>A vector of values for <code>basis.gen</code>, or a matrix for
<code>pseudo.bases</code></p>
</td></tr>
<tr><td><code id="pseudo.bases_+3A_degree">degree</code></td>
<td>
<p>The nominal number of basis elements. The basis returned has
no more than <code>degree</code> columns. For <code>pseudo.bases</code> this can be a
single value or a vector of values, which are recycled sequentially for each
column of <code>x</code></p>
</td></tr>
<tr><td><code id="pseudo.bases_+3A_df">df</code></td>
<td>
<p>The degrees of freedom of the smoothing spline.</p>
</td></tr>
<tr><td><code id="pseudo.bases_+3A_parallel">parallel</code></td>
<td>
<p>if TRUE, parallelize</p>
</td></tr>
<tr><td><code id="pseudo.bases_+3A_...">...</code></td>
<td>
<p>other arguments for <code>basis.gen</code> can be passed through to <code>[basis.gen]</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>basis.gen</code> starts with a basis of orthogonal polynomials of total
<code>degree</code>. These are each smoothed using a smoothing spline, which
allows for a one-step approximation to the Demmler-Reinsch basis for a
smoothing spline of rank equal to the degree. See the reference for details.
The function also approximates the appropriate diagonal penalty matrix for
this basis, so that the a approximate smoothing spline (generalized ridge
regression) has the target df.
</p>


<h3>Value</h3>

<p>An orthonormal basis is returned (a list for <code>pseudo.bases</code>).
This has an attribute <code>parms</code>, which has elements
<code>coefs</code>Coefficients needed to generate the orthogonal polynomials
<code>rotate</code>Transformation matrix for transforming the polynomial basis
<code>d</code>penalty values for the diagonal penalty <code>df</code>df used
<code>degree</code>number of columns
</p>


<h3>Author(s)</h3>

<p>Alexandra Chouldechova and Trevor Hastie<br /> Maintainer: Trevor
Hastie <a href="mailto:hastie@stanford.edu">hastie@stanford.edu</a>
</p>


<h3>References</h3>

<p>T. Hastie <em>Pseudosplines</em>. (1996) JRSSB 58(2), 379-396.<br />
Chouldechova, A. and Hastie, T. (2015) <em>Generalized Additive Model
Selection</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##data=gamsel:::gendata(n=500,p=12,k.lin=3,k.nonlin=3,deg=8,sigma=0.5)
data = readRDS(system.file("extdata/gamsel_example.RDS", package = "gamsel"))
attach(data)
bases=pseudo.bases(X,degree=10,df=6)
## Not run: 
     require(doMC)
     registerDoMC(cores=4)
     bases=pseudo.bases(X,degree=10,df=6,parallel=TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='summary.gamsel'>Gamsel summary routine</h2><span id='topic+summary.gamsel'></span>

<h3>Description</h3>

<p>This makes a two-panel plot of the gamsel object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gamsel'
summary(object, label = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.gamsel_+3A_object">object</code></td>
<td>
<p><code>gamsel</code> object</p>
</td></tr>
<tr><td><code id="summary.gamsel_+3A_label">label</code></td>
<td>
<p>if <code>TRUE</code>, annotate the plot with variable labels. Default
is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="summary.gamsel_+3A_...">...</code></td>
<td>
<p>additional arguments to summary</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A two panel plot is produced, that summarizes the linear components and the
nonlinear components, as a function of lambda. For the linear components, it
is the coefficient for each variable. For the nonlinear, we see the norm of
the nonlinear coefficients.
</p>


<h3>Value</h3>

<p>Nothing is returned.
</p>


<h3>Author(s)</h3>

<p>Alexandra Chouldechova and Trevor Hastie<br /> Maintainer: Trevor
Hastie <a href="mailto:hastie@stanford.edu">hastie@stanford.edu</a>
</p>


<h3>References</h3>

<p>Chouldechova, A. and Hastie, T. (2015) <em>Generalized
Additive Model Selection</em>
</p>


<h3>See Also</h3>

<p><code>gamsel</code>, and methods <code>plot</code>, <code>print</code> and
<code>predict</code> for <code>cv.gamsel</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##data=gamsel:::gendata(n=500,p=12,k.lin=3,k.nonlin=3,deg=8,sigma=0.5)
data = readRDS(system.file("extdata/gamsel_example.RDS", package = "gamsel"))
attach(data)
bases=pseudo.bases(X,degree=10,df=6)
# Gaussian gam
gamsel.out=gamsel(X,y,bases=bases)
par(mfrow=c(1,2),mar=c(5,4,3,1))
summary(gamsel.out)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
