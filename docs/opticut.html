<!DOCTYPE html><html lang="en"><head><title>Help for package opticut</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {opticut}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#opticut-package'>
<p>Likelihood Based Optimal Partitioning and Indicator Species Analysis</p></a></li>
<li><a href='#allComb'>
<p>Finding All Possible Binary Partitions</p></a></li>
<li><a href='#bestmodel'>
<p>Best model, Partition, and MLE</p></a></li>
<li><a href='#beta2i'>
<p>Scaling for the Indicator Potential</p></a></li>
<li><a href='#birdrec'>
<p>Bird Species Detections</p></a></li>
<li><a href='#dolina'>
<p>Land Snail Data Set</p></a></li>
<li><a href='#lorenz'>
<p>Lorenz Curve Based Thresholds and Partitions</p></a></li>
<li><a href='#multicut'>
<p>Multi-level Response Model</p></a></li>
<li><a href='#occolors'>
<p>Color Palettes for the opticut Package</p></a></li>
<li><a href='#ocoptions'>
<p>Options for the opticut Package</p></a></li>
<li><a href='#opticut'>
<p>Optimal Binary Response Model</p></a></li>
<li><a href='#optilevels'>
<p>Optimal Number of Factor Levels</p></a></li>
<li><a href='#rankComb'>
<p>Ranking Based Binary Partitions</p></a></li>
<li><a href='#uncertainty'>
<p>Quantifying Uncertainty for Fitted Objects</p></a></li>
<li><a href='#warblers'>
<p>Warblers Data Set</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Likelihood Based Optimal Partitioning and Indicator Species
Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1-3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-05-21</td>
</tr>
<tr>
<td>Author:</td>
<td>Peter Solymos [cre, aut] (&lt;https://orcid.org/0000-0001-7337-1740&gt;), Ermias T. Azeria [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Peter Solymos &lt;psolymos@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Likelihood based optimal partitioning and indicator
  species analysis. Finding the best binary partition for each species
  based on model selection, with the possibility to take into account
  modifying/confounding variables as described
  in Kemencei et al. (2014) &lt;<a href="https://doi.org/10.1556%2FComEc.15.2014.2.6">doi:10.1556/ComEc.15.2014.2.6</a>&gt;.
  The package implements binary and multi-level response models,
  various measures of uncertainty, Lorenz-curve based thresholding,
  with native support for parallel computations.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/psolymos/opticut">https://github.com/psolymos/opticut</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/psolymos/opticut/issues">https://github.com/psolymos/opticut/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0), pbapply (&ge; 1.3-0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, pscl, betareg, ResourceSelection (&ge; 0.3-2), parallel,
mefa4</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-21 16:54:35 UTC; Peter</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-21 22:00:04 UTC</td>
</tr>
</table>
<hr>
<h2 id='opticut-package'>
Likelihood Based Optimal Partitioning and Indicator Species Analysis
</h2><span id='topic+opticut-package'></span>

<h3>Description</h3>

<p>Likelihood based optimal partitioning and indicator
  species analysis. Finding the best binary partition for each species
  based on model selection, with the possibility to take into account
  modifying/confounding variables as described
  in Kemencei et al. (2014) &lt;doi:10.1556/ComEc.15.2014.2.6&gt;.
  The package implements binary and multi-level response models,
  various measures of uncertainty, Lorenz-curve based thresholding,
  with native support for parallel computations.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> opticut</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Likelihood Based Optimal Partitioning and Indicator Species Analysis</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.1-3</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-05-21</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Peter Solymos [cre, aut] (&lt;https://orcid.org/0000-0001-7337-1740&gt;), Ermias T. Azeria [ctb]</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Peter Solymos &lt;psolymos@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Likelihood based optimal partitioning and indicator
  species analysis. Finding the best binary partition for each species
  based on model selection, with the possibility to take into account
  modifying/confounding variables as described
  in Kemencei et al. (2014) &lt;doi:10.1556/ComEc.15.2014.2.6&gt;.
  The package implements binary and multi-level response models,
  various measures of uncertainty, Lorenz-curve based thresholding,
  with native support for parallel computations.</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://github.com/psolymos/opticut</td>
</tr>
<tr>
 <td style="text-align: left;">
BugReports: </td><td style="text-align: left;"> https://github.com/psolymos/opticut/issues</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 3.1.0), pbapply (&gt;= 1.3-0)</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> MASS, pscl, betareg, ResourceSelection (&gt;= 0.3-2), parallel, mefa4</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyData: </td><td style="text-align: left;"> true</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
allComb                 Finding All Possible Binary Partitions
bestmodel               Best model, Partition, and MLE
beta2i                  Scaling for the Indicator Potential
birdrec                 Bird Species Detections
dolina                  Land Snail Data Set
lorenz                  Lorenz Curve Based Thresholds and Partitions
multicut                Multi-level Response Model
occolors                Color Palettes for the opticut Package
ocoptions               Options for the opticut Package
opticut                 Optimal Binary Response Model
opticut-package         Likelihood Based Optimal Partitioning and
                        Indicator Species Analysis
optilevels              Optimal Number of Factor Levels
rankComb                Ranking Based Binary Partitions
uncertainty             Quantifying Uncertainty for Fitted Objects
warblers                Warblers Data Set
</pre>
<p>The main user interface are the <code><a href="#topic+opticut">opticut</a></code>
and <code><a href="#topic+multicut">multicut</a></code> functions
to find the optimal binary or multi-level response models.
Make sure to evaluate <code><a href="#topic+uncertainty">uncertainty</a></code>.
<code><a href="#topic+optilevels">optilevels</a></code> finds the optimal number of factor levels.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos [cre, aut] (&lt;https://orcid.org/0000-0001-7337-1740&gt;), Ermias T. Azeria [ctb]
</p>
<p>Maintainer: Peter Solymos &lt;psolymos@gmail.com&gt;
</p>


<h3>References</h3>

<p>Kemencei, Z., Farkas, R., Pall-Gergely, B., Vilisics, F., Nagy, A., Hornung,
E. &amp; Solymos, P., 2014. Microhabitat associations of land snails in
forested dolinas: implications for coarse filter conservation.
Community Ecology 15:180&ndash;186.
&lt;doi:10.1556/ComEc.15.2014.2.6&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## community data
y &lt;- cbind(
    Sp1=c(4,6,3,5, 5,6,3,4, 4,1,3,2),
    Sp2=c(0,0,0,0, 1,0,0,1, 4,2,3,4),
    Sp3=c(0,0,3,0, 2,3,0,5, 5,6,3,4))

## stratification
g &lt;-    c(1,1,1,1, 2,2,2,2, 3,3,3,3)

## find optimal partitions for each species
oc &lt;- opticut(formula = y ~ 1, strata = g, dist = "poisson")
summary(oc)

## visualize the results
plot(oc, cut = -Inf)

## quantify uncertainty
uc &lt;- uncertainty(oc, type = "asymp", B = 999)
summary(uc)

## go beyond binary partitions

mc &lt;- multicut(formula = y ~ 1, strata = g, dist = "poisson")
summary(mc)

ol &lt;- optilevels(y[,"Sp2"], as.factor(g))
ol[c("delta", "coef", "rank", "levels")]
</code></pre>

<hr>
<h2 id='allComb'>
Finding All Possible Binary Partitions
</h2><span id='topic+allComb'></span><span id='topic+kComb'></span><span id='topic+checkComb'></span>

<h3>Description</h3>

<p>These functions are used to find all possible binary partitions.
Finding all combinations require
a classification vector with K &gt; 1 strata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allComb(x, collapse)
kComb(k)
checkComb(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="allComb_+3A_x">x</code></td>
<td>

<p>a vector for <code>allComb</code> (can be of any type but treated as factor, must have at least 2 unique values); and a numeric matrix for <code>checkComb</code>.
</p>
</td></tr>
<tr><td><code id="allComb_+3A_collapse">collapse</code></td>
<td>

<p>character, what to paste between levels.
Defaults to <code>getOption("ocoptions")$collapse</code>.
</p>
</td></tr>
<tr><td><code id="allComb_+3A_k">k</code></td>
<td>

<p>numeric, number of levels (strata) in a given classification (K &gt; 1).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>kComb</code> returns a contrast matrix corresponding to
all possible binary partitions of the factor with K levels.
Complements are not counted twice, i.e.
(0,0,1,1) is equivalent to (1,1,0,0).
The number of such possible combinations is M = 2^(K - 1) - 1.
</p>
<p><code>allComb</code> takes a classification vector with at least 2 levels
and returns a model matrix with binary partitions.
</p>
<p><code>checkComb</code> checks if combinations are unique and non-complementary
(misfits are returned as attributes). Returns a logical value.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos &lt;psolymos@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+opticut">opticut</a></code> for the user interface.
</p>
<p><code><a href="#topic+rankComb">rankComb</a></code> and <code><a href="#topic+lorenz">lorenz</a></code>
for alternative partitioning algorithms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kComb(k = 2)
kComb(k = 3)
kComb(k = 4)

## finding all combinations
(f &lt;- rep(LETTERS[1:4], each=2))
(mc &lt;- allComb(f, collapse = "_"))
## checking for complementary entries
checkComb(mc) # TRUE
## adding complementary entries to the matrix
mc2 &lt;- cbind(z = 1 - mc[,1], mc[,c(1:ncol(mc), 1)])
colnames(mc2) &lt;- 1:ncol(mc2)
mc2
checkComb(mc2) # FALSE
</code></pre>

<hr>
<h2 id='bestmodel'>
Best model, Partition, and MLE
</h2><span id='topic+bestmodel'></span><span id='topic+bestpart'></span><span id='topic+getMLE'></span>

<h3>Description</h3>

<p>Generic functions for accessing best model, best partition,
and Maximum Likelihood Estimate from fitted objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bestmodel(object, ...)
bestpart(object, ...)
getMLE(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bestmodel_+3A_object">object</code></td>
<td>

<p>fitted model object.
</p>
</td></tr>
<tr><td><code id="bestmodel_+3A_...">...</code></td>
<td>

<p>other arguments passed to the underlying functions.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>bestmodel</code> returns the best supported model for further
manipulation (e.g. prediction).
</p>
<p><code>bestpart</code> returns a matrix with the best supported
partitions for each species (species as columns).
</p>
<p><code>getMLE</code> returns a named list corresponding to the best supported
model. The list has the following elements:
<code>coef</code> is the Maximum Likelihood Estimate (MLE),
<code>vcov</code> is the variance-covariance matrix for the MLE,
<code>dist</code> is the distribution inherited from input <code>object</code>.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos &lt;psolymos@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+opticut">opticut</a></code>, <code><a href="#topic+multicut">multicut</a></code>, <code><a href="#topic+uncertainty">uncertainty</a></code>.
</p>

<hr>
<h2 id='beta2i'>
Scaling for the Indicator Potential
</h2><span id='topic+beta2i'></span>

<h3>Description</h3>

<p>Transformation of estimated contrasts to indicator potential.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta2i(x, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="beta2i_+3A_x">x</code></td>
<td>

<p>numeric, real valued coefficients.
</p>
</td></tr>
<tr><td><code id="beta2i_+3A_scale">scale</code></td>
<td>

<p>numeric, scaling constant.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric vector (I = abs(tanh(x * scale))).
</p>


<h3>Author(s)</h3>

<p>Peter Solymos &lt;psolymos@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+opticut">opticut</a></code> and <code><a href="#topic+multicut">multicut</a></code>
use the scaled I values as indicator potential.
</p>
<p><code><a href="#topic+ocoptions">ocoptions</a></code> for setting value for the default scaling factor.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(-5, 5, 0.1)
Col &lt;- occolors(c("red", "blue"))(10)
plot(x, beta2i(x), type = "n")
s &lt;- seq(1, 0.1, -0.1)
for (i in 1:10) {
    lines(x, beta2i(x, scale = s[i]), col = Col[i])
    text(1.5 - 0.2, beta2i(1.5, scale = s[i]), s[i], col = Col[i])
}
</code></pre>

<hr>
<h2 id='birdrec'>
Bird Species Detections
</h2><span id='topic+birdrec'></span>

<h3>Description</h3>

<p>Data set listing 156 species (mostly birds, few amphibians and mammals) detected
at 127 sites (367 point locations) in Alberta, Canada in 2015,
using autonomous recording technology (ARU; Wildlife Acoustic Song Meter)
for sound recordings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("birdrec")</code></pre>


<h3>Format</h3>

<p>A list with 3 elements with matching ordering:
<code>xtab</code> is a sample x species matrix with number of detections,
<code>samp</code> is a data frame with sample level attributes.
<code>taxa</code> is a data frame with species level attributes.
</p>
<p>Multiple random recordings at each location were selected
according to a stratified random design
(based on combination of <code>TOY</code> and <code>TOD</code>).
These recordings were listened to by trained analysts
and species were identified based on auditory cues.
</p>
<p>This data set lists detections from the first 1-minute segment of each
recording. Dates for the 3967 1-minute segments
range between 2015-03-31 and 2015-07-29.
Variables in <code>birdrec$samp</code> are the following:
</p>
<p><code>PKEY</code>: primary key for location/time combinations.
</p>
<p><code>POINT</code>: unique spatial location IDs, each point had
its own ARU unit.
</p>
<p><code>SITE</code>: site ID (1-4 ARU units deployed per site).
</p>
<p><code>YEAR</code>: year, 2015.
</p>
<p><code>MONTH</code>: month from 3 (March) to 7 (July).
</p>
<p><code>MDAY</code>: day of month, 1-31.
</p>
<p><code>HOUR</code>: 24-hour of day, values between 0-12.
</p>
<p><code>MINUTE</code>: minute, 0-59.
</p>
<p><code>YDAY</code>: ordinal day of the year, 89-209.
</p>
<p><code>RAIN</code>, <code>WIND</code>, <code>INDUSTRY</code>, <code>NOISE</code>:
level of rain, wind, industrial noise, and background noise.
0 = no; 1 = light; 2 = moderate; 3 = heavy.
</p>
<p><code>MICROPHONE</code>:
Every recording contains a certain level of background static due to the
pre-amplifiers; however, problems, such as, electrostatic discharge on the
microphones, faulty wiring, poorly installed microphones and/or
missing microphones can occur causing excess static or dead channels.
0 = no microphone related issues;
1 = left microphone cuts out intermittently;
2 = right microphone cuts out intermittently;
3 = both microphones cut out intermittently;
4 = left channel failed;
5 = right channel failed;
6 = both channels failed (no cases in the data set);
7 = left side extra static;
8 = right side extra static;
9 = both sides extra static;
10 = other issues;
11 = unbalanced channels.
</p>
<p><code>TOY</code>: time of year intervals used for stratified random
selection of dates. 8 intervals divided into 3 major units
(early, mid, and late breeding season; <code>YDAY</code> 140 and 180 were used
as threshold between the major units).
</p>
<p><code>TOD</code>: time of day, midnight (<code>HOUR</code> = 0) or
morning (<code>HOUR</code> &gt; 0).
</p>
<p>Variables in <code>birdrec$taxa</code> are the following:
<code>Species</code>, <code>CommonName</code>, <code>ScientificName</code>,
<code>Family</code>, <code>Order</code>, <code>Class</code>,
and <code>MigratoryBehaviour</code>.
</p>
<p>Methodology and metadata is described in ABMI (2016), and Lankau et al. (2015).
</p>


<h3>Source</h3>

<p>Alberta Biodiversity Monitoring Institute (ABMI, www.abmi.ca)
</p>


<h3>References</h3>

<p>Alberta Biodiversity Monitoring Institute (ABMI), 2016.
Terrestrial field data collection protocols (abridged version) 2016-05-18.
Alberta Biodiversity Monitoring Institute; Edmonton, Alberta, Canada.
</p>
<p>Lankau, H.E., MacPhail, A., Knaggs, M. &amp; Bayne, E., 2015.
Acoustic recording analysis protocol.
Bioacoustic Unit, University of Alberta, and
Alberta Biodiversity Monitoring Institute; Edmonton, Alberta, Canada.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(birdrec)
str(birdrec)

aggregate(rowSums(birdrec$xtab),
    list(TOY=birdrec$samp$TOY, TOD=birdrec$samp$TOD), mean)
boxplot(rowSums(birdrec$xtab) ~ TOD + TOY, birdrec$samp,
    col=c("gold", "tomato"), ylab="# detections")

## Not run: 
y &lt;- ifelse(birdrec$xtab &gt; 0, 1, 0)
g &lt;- paste0(gsub("[[:digit:]]", "", as.character(birdrec$samp$TOY)),
    substr(as.character(birdrec$samp$TOD), 1, 4))
g &lt;- factor(g, levels=c("EarlyMorn", "MidMorn", "LateMorn",
    "EarlyMidn", "MidMidn", "LateMidn"))
## binary response model
oc &lt;- opticut(y ~ 1, strata=g, dist="binomial")
## multi-level response model
mc &lt;- multicut(y ~ 1, strata=g, dist="binomial")

## testing equality of labels
splito &lt;- as.character(summary(oc)$summary$split)
splitm &lt;- as.character(summary(mc)$summary$split)
table(splito == splitm)
## seeing how much those differ
bpo &lt;- summary(oc)$bestpart
bpm &lt;- summary(mc)$bestpart
rs &lt;- rowSums(abs(bpo-bpm))
table(rs)
10 * bpo[rs &gt; 0,] + bpm[rs &gt; 0,]

## End(Not run)
</code></pre>

<hr>
<h2 id='dolina'>
Land Snail Data Set
</h2><span id='topic+dolina'></span>

<h3>Description</h3>

<p>A comprehensive and micro-scale land snail data set from 16 dolinas of the
Aggtelek Karst Area, Hungary.
Data set containing land snail counts as described in Kemecei et al. 2014.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("dolina")</code></pre>


<h3>Format</h3>

<p>A list with 3 elements: <code>xtab</code> is a sample x species matrix with counts,
<code>samp</code> is a data frame with sample level attributes,
<code>taxa</code> is a data frame with scientific names and families for the species.
</p>
<p>Land snails were sampled during daylight hours between
16 and 18 of August, 2007. Samples were taken from four
microhabitat types (<code>dolina$samp$microhab</code>, <code>dolina$samp$mhab</code>):
litter (LI), trunks of live trees (TL), dead
wood (also known as coarse woody debris; DW), and rock (RO).
In each of the 16 dolina (<code>dolina$samp$dolina</code>),
seven samples were collected in the litter microhabitat
along a north-south transect. In the case of the other three
microhabitat types, samples were collected from three random
locations per microhabitat type in each dolina.
A total of 256 samples (<code>dolina$samp$sample</code>) were
collected, each consisting 2 sub-samples collected
by 2 sampling methods (<code>dolina$samp$method</code>):
litter samples (Q) and timed search (T).
</p>
<p>One liter of litter samples including topsoil were collected
to be examined later in the laboratory. Litter samples were
collected adjacent to live wood, dead wood and rocks, and
not from the wood or rocks themselves. Litter samples in the
litter microhabitat were not collected near wood or rocks
(minimum distance of 2 meters). During 5 minutes per site of
time-restricted direct search we investigated microhabitats in
a 1 meter radius circle around the litter sample location, but
also including tree or rock surfaces for those microhabitats.
</p>
<p>The vertical zone (<code>dolina$samp$stratum</code>,
bottom, middle or edge of the dolinas),
aspect of these sample locations (<code>dolina$samp$aspect</code>),
along with litter depth (<code>dolina$samp$lthick</code>, cm),
and litter moisture (<code>dolina$samp$lmoist</code>,
scored on an ordinal scale: 1=dry,
2=fresh, 3=moist) were also recorded.
</p>
<p>Distinction of live animals versus fresh
empty shells was not feasible due to the
method of sorting dry material and the delay in litter sample
processing, so these were combined and constituted the
'fresh' group. Whitened, disintegrating and broken shells
constituted the 'broken' group. This 'broken' group was
excluded from the data set presented here.
</p>


<h3>Source</h3>

<p>Solymos et al. 2016 and Kemencei et al. 2014.
</p>


<h3>References</h3>

<p>Kemencei, Z., Farkas, R., Pall-Gergely, B., Vilisics, F., Nagy, A., Hornung,
E. &amp; Solymos, P., 2014. Microhabitat associations of land snails in
forested dolinas: implications for coarse filter conservation.
Community Ecology 15:180&ndash;186.
&lt;doi:10.1556/ComEc.15.2014.2.6&gt;
</p>
<p>Solymos, P., Kemencei, Z. Pall-Gergely, B., Farkas, R., Vilisics, F., Nagy, A., Kisfali, M. &amp; Hornung, E., 2016. Public data from the dolina project. Version 1.0. Zenodo, &lt;doi:10.5281/zenodo.53080&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dolina)
str(dolina)

## species richness by microhabitat and method
Richness &lt;- rowSums(dolina$xtab &gt; 0)
boxplot(Richness ~ mhab + method, dolina$samp,
    ylab="Species richness", main="Dolina data set",
    col=rep(c("#2C7BB6", "#D7191C"), each=4))
</code></pre>

<hr>
<h2 id='lorenz'>
Lorenz Curve Based Thresholds and Partitions
</h2><span id='topic+lorenz'></span><span id='topic+summary.lorenz'></span><span id='topic+print.summary.lorenz'></span><span id='topic+quantile.lorenz'></span><span id='topic+iquantile'></span><span id='topic+iquantile.lorenz'></span><span id='topic+plot.lorenz'></span>

<h3>Description</h3>

<p>Lorenz curve based thresholds and partitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lorenz(x, n = rep(1, length(x)), na.last = TRUE)

## S3 method for class 'lorenz'
quantile(x, probs = seq(0, 1, 0.25),
    type = c("L", "p"), ...)
iquantile(x, ...)
## S3 method for class 'lorenz'
iquantile(x, values,
    type = c("L", "p"),...)

## S3 method for class 'lorenz'
plot(x, type = c("L", "x"),
    tangent = NA, h = NA, v = NA, ...)

## S3 method for class 'summary.lorenz'
print(x, digits, ...)
## S3 method for class 'lorenz'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lorenz_+3A_x">x</code></td>
<td>
<p>a vector of nonnegative numbers for <code>lorenz</code>, or
an object to plot or summarized.
</p>
</td></tr>
<tr><td><code id="lorenz_+3A_n">n</code></td>
<td>
<p>a vector of frequencies, must be same length as <code>x</code>.
</p>
</td></tr>
<tr><td><code id="lorenz_+3A_na.last">na.last</code></td>
<td>
<p>logical, for controlling the treatment of <code>NA</code>s.
If <code>TRUE</code>, missing values in the data are put last;
if <code>FALSE</code>, they are put first; if <code>NA</code>, they are removed
(see <code><a href="base.html#topic+order">order</a></code>).
</p>
</td></tr>
<tr><td><code id="lorenz_+3A_probs">probs</code></td>
<td>
<p>numeric vector of probabilities with values in [0,1],
as in <code><a href="stats.html#topic+quantile">quantile</a></code>.
</p>
</td></tr>
<tr><td><code id="lorenz_+3A_values">values</code></td>
<td>
<p>numeric vector of values for which the corresponding population quantiles are to be returned.
</p>
</td></tr>
<tr><td><code id="lorenz_+3A_type">type</code></td>
<td>
<p>character. For the <code>plot</code> method it indicates whether to plot
the cumulative distribution quantiles (<code>"L"</code>)
or ordered but not-cumulated values (<code>"x"</code>). For the
<code>quantile</code> and <code>iquantile</code> methods it indicates which
of the quantiles (<code>"L"</code> or <code>"p"</code>) to use.
</p>
</td></tr>
<tr><td><code id="lorenz_+3A_tangent">tangent</code></td>
<td>

<p>color value for the Lorenz-curve tangent when plotted. The default
<code>NA</code> value omits the tangent from the plot.
</p>
</td></tr>
<tr><td><code id="lorenz_+3A_h">h</code></td>
<td>

<p>color value for the horizontal line for the Lorenz-curve tangent
when plotted. The default
<code>NA</code> value omits the horizontal line from the plot.
</p>
</td></tr>
<tr><td><code id="lorenz_+3A_v">v</code></td>
<td>

<p>color value for the vertical line for the Lorenz-curve tangent
when plotted. The default
<code>NA</code> value omits the vertical line from the plot.
</p>
</td></tr>
<tr><td><code id="lorenz_+3A_digits">digits</code></td>
<td>

<p>numeric, number of significant digits in output.
</p>
</td></tr>
<tr><td><code id="lorenz_+3A_object">object</code></td>
<td>

<p>object to summarize.
</p>
</td></tr>
<tr><td><code id="lorenz_+3A_...">...</code></td>
<td>

<p>other arguments passed to the underlying functions.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Lorenz curve is a continuous piecewise linear function
representing the distribution of abundance (income, or wealth).
Cumulative portion of the population: <code class="reqn">p_i = i / m</code> (<code class="reqn">i=1,...,m</code>), vs.
cumulative portion of abundance:
<code class="reqn">L_i = \sum_{j=1}^{i} x_j * n_j / \sum_{j=1}^{n} x_j * n_j</code>.
where <code class="reqn">x_i</code> are indexed in non-decreasing order (<code class="reqn">x_i &lt;= x_{i+1}</code>).
By convention, p_0 = L_0 = 0.
<code>n</code> can represent unequal frequencies.
</p>
<p>The following charactersitics of the Lorenz curve are calculated:
<code>"t"</code>: index where tangent (slope 1) touches the curve;
<code>"x[t]"</code>, <code>"p[t]"</code>, and <code>"L[t]"</code> are values corresponding to
index t, x_t is the unmodified input.
<code>"S"</code>: Lorenz asymmetry coefficient (<code class="reqn">S = p_t + L_t</code>),
<code class="reqn">S = 1</code> indicates symmetry.
<code>"G"</code>: Gini coefficient, 0 is perfect equality,
values close to 1 indicate high inequality.
<code>"J"</code>: Youden index is the (largest) distance between the anti-diagonal
and the curve, distance is largest at the tangent point
(<code class="reqn">J = max(p - L) = p_t - L_t</code>).
</p>


<h3>Value</h3>

<p><code>lorenz</code> returns an object of class lorenz. It is a matrix with m+1 rows
(m = <code>length(x)</code>) and 3 columns (p, L, x).
</p>
<p>The <code>quantile</code> method finds values of x_i corresponding to
quantiles L_i or p_i (depending on the <code>type</code> argument).
The <code>iquantile</code> (inverse quantile) method
finds quantiles of L_i or p_i corresponding to values of x_i.
</p>
<p>The <code>plot</code> method draws a Lorenz curve.
Because the object is a matrix, <code><a href="graphics.html#topic+lines">lines</a></code>
and <code><a href="graphics.html#topic+points">points</a></code> will work for adding multiple lines.
</p>
<p>The <code>summary</code> method returns characteristics of the Lorenz curve.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos &lt;psolymos@gmail.com&gt;
</p>


<h3>References</h3>

<p>Damgaard, C., &amp; Weiner, J. (2000):
Describing inequality in plant size or fecundity.
Ecology 81:1139&ndash;1142.
&lt;doi:10.2307/177185&gt;
</p>
<p>Schisterman, E. F., Perkins, N. J., Liu, A., &amp; Bondell, H. (2005):
Optimal cut-point and its corresponding Youden index
to discriminate individuals using pooled blood samples.
Epidemiology 16:73&ndash;81.
&lt;doi:10.1097/01.ede.0000147512.81966.ba&gt;
</p>
<p>Youden, W. J. (1950):
Index for rating diagnostic tests.
Cancer 3:32&ndash;5.
&lt;doi:10.1002/1097-0142(1950)3:1&lt;32::AID-CNCR2820030106&gt;3.0.CO;2-3&gt;
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+quantile">quantile</a></code>, <code><a href="base.html#topic+order">order</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
x &lt;- c(rexp(100, 10), rexp(200, 1))

l &lt;- lorenz(x)
head(l)
tail(l)
summary(l)
summary(unclass(l))

(q &lt;- c(0.05, 0.5, 0.95))
(p_i &lt;- quantile(l, probs=q, type="p"))
iquantile(l, values=p_i, type="p")
(p_i &lt;- quantile(l, probs=q, type="L"))
iquantile(l, values=p_i, type="L")

op &lt;- par(mfrow=c(2,1))
plot(l, lwd=2, tangent=2, h=3, v=4)
abline(0, 1, lty=2, col="grey")
abline(1, -1, lty=2, col="grey")
plot(l, type="x", lwd=2, h=3, v=4)
par(op)

## Lorenz-tangent approach to binarize a multi-level problem
n &lt;- 100
g &lt;- as.factor(sort(sample(LETTERS[1:4], n, replace=TRUE, prob=4:1)))
x &lt;- rpois(n, exp(as.integer(g)))
mu &lt;- aggregate(x, list(g), mean)
(l &lt;- lorenz(mu$x, table(g)))
(s &lt;- summary(l))

plot(l)
abline(0, 1, lty=2)
lines(rep(s["p[t]"], 2), c(s["p[t]"], s["L[t]"]), col=2)
</code></pre>

<hr>
<h2 id='multicut'>
Multi-level Response Model
</h2><span id='topic+multicut'></span><span id='topic+multicut.default'></span><span id='topic+multicut.formula'></span><span id='topic+multicut1'></span><span id='topic+getMLE.multicut'></span><span id='topic+bestpart.multicut'></span><span id='topic+bestmodel.multicut'></span><span id='topic+fitted.multicut'></span><span id='topic+predict.multicut'></span><span id='topic+lcplot'></span><span id='topic+lcplot.multicut1'></span><span id='topic+plot.multicut'></span><span id='topic+plot.multicut1'></span><span id='topic+strata.multicut'></span><span id='topic+print.multicut'></span><span id='topic+print.multicut1'></span><span id='topic+subset.multicut'></span><span id='topic+summary.multicut'></span><span id='topic+print.summary.multicut'></span><span id='topic+as.data.frame.multicut'></span><span id='topic+as.data.frame.summary.multicut'></span>

<h3>Description</h3>

<p>The functions fits the multi-level response model for each species,
possibly controlling for modifying/confounding variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multicut1(Y, X, Z, dist = "gaussian", sset=NULL, ...)

multicut(...)
## Default S3 method:
multicut(Y, X, strata, dist = "gaussian",
    sset=NULL, cl = NULL, ...)
## S3 method for class 'formula'
multicut(formula, data, strata, dist = "gaussian",
    sset=NULL, cl = NULL, ...)

## S3 method for class 'multicut'
bestmodel(object, which = NULL, ...)
## S3 method for class 'multicut'
bestpart(object, ...)
## S3 method for class 'multicut'
strata(object, ...)
## S3 method for class 'multicut'
getMLE(object, which, vcov=FALSE, ...)
## S3 method for class 'multicut'
subset(x, subset=NULL, ...)
## S3 method for class 'multicut'
fitted(object, ...)
## S3 method for class 'multicut'
predict(object, gnew=NULL, xnew=NULL, ...)

## S3 method for class 'multicut'
plot(x, which = NULL, cut, sort,
    las, ylab = "Relative abundance", xlab = "Strata",
    show_I = TRUE, show_S = TRUE, hr = TRUE, tick = TRUE,
    theme, mar = c(5, 4, 4, 4) + 0.1, bty = "o",
    lower = 0, upper = 1, pos = 0, horizontal=TRUE, ...)
## S3 method for class 'multicut1'
plot(x,
    ylab = "Relative abundance", xlab = "Strata", ...)
lcplot(x, ...)
## S3 method for class 'multicut1'
lcplot(x,
    ylab="Cumulative abundance", xlab="Strata",
    bty = "o", theme, ...)

## S3 method for class 'multicut1'
print(x, digits, ...)
## S3 method for class 'multicut'
print(x, digits, ...)
## S3 method for class 'summary.multicut'
print(x, cut, sort, digits, ...)
## S3 method for class 'multicut'
summary(object, ...)

## S3 method for class 'multicut'
as.data.frame(x,
    row.names = NULL, optional = FALSE, cut, sort, ...)
## S3 method for class 'summary.multicut'
as.data.frame(x,
    row.names = NULL, optional = FALSE, cut, sort, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multicut_+3A_formula">formula</code></td>
<td>

<p>two sided model formula, response species data (matrix,
or possible a vector for single species case) in the left-hand side,
model terms for modifying effects in the right-hand side
(its structure depending on the underlying functions).
For example, in the most basic Gaussian case it can be
<code>y ~ 1</code> (no modifying variables) or <code>y ~ x</code>
(with modifying variables).
Centering the modifying terms (or choosing the origin wisely)
is generally recommended (especially for Gaussian distribution
where linear predictors are additive on the response scale)
because the relative abundance contrasts are estimated at the origin (0).
</p>
</td></tr>
<tr><td><code id="multicut_+3A_data">data</code></td>
<td>

<p>an optional data frame, list or environment containing the variables
in the model. If not found in data, the variables are taken from
<code>parent.frame()</code>, typically the environment
from which <code>multicut</code> is called.
</p>
</td></tr>
<tr><td><code id="multicut_+3A_strata">strata</code>, <code id="multicut_+3A_z">Z</code></td>
<td>

<p>a factor, unique values define strata
(must have at least 2 unique levels, empty levels are dropped).
</p>
</td></tr>
<tr><td><code id="multicut_+3A_dist">dist</code></td>
<td>

<p>character or function, a distribution to fit.
If character, it can follow one of these patterns: <code>"family"</code>,
or <code>"family:link"</code> when appropriate (there is a <code>link</code>
argument in the underlying function, or the link
can be specified via the <code>family</code> argument).
See Details on <code><a href="#topic+opticut">opticut</a></code> page and Examples.
</p>
</td></tr>
<tr><td><code id="multicut_+3A_sset">sset</code></td>
<td>

<p>an optional vector specifying a subset of observations (rows)
to be used in the fitting process. <code>NULL</code> means no subset taken.
</p>
</td></tr>
<tr><td><code id="multicut_+3A_cl">cl</code></td>
<td>

<p>a cluster object, or an integer for multiple cores in parallel computations
(integer value for forking is ignored on Windows).
</p>
</td></tr>
<tr><td><code id="multicut_+3A_y">Y</code></td>
<td>

<p>numeric vector of observations for <code>multicut1</code>,
vector or community matrix for <code>multicut.default</code>.
</p>
</td></tr>
<tr><td><code id="multicut_+3A_x">X</code></td>
<td>

<p>numeric, design matrix for possible confounding/modifier variables.
Can be missing, in which case an intercept-only model is assumed.
</p>
</td></tr>
<tr><td><code id="multicut_+3A_x">x</code>, <code id="multicut_+3A_object">object</code></td>
<td>

<p>object to plot, print, summarize.
</p>
</td></tr>
<tr><td><code id="multicut_+3A_cut">cut</code></td>
<td>

<p>log likelihood ratio value to be used as a cut-off for showing species
whose log likelihood ratio is not less than the cut-off.
</p>
</td></tr>
<tr><td><code id="multicut_+3A_sort">sort</code></td>
<td>

<p>logical value indicating if species/partitions
should be meaningfully sorted, the default is <code>TRUE</code>.
It can take numeric value when only species (<code>1</code>)
or partitions (<code>2</code>) are to be sorted (<code>1:2</code> is equivalent to
<code>TRUE</code>).
</p>
</td></tr>
<tr><td><code id="multicut_+3A_show_i">show_I</code></td>
<td>

<p>logical, if indicator potential (I) should be shown.
</p>
</td></tr>
<tr><td><code id="multicut_+3A_show_s">show_S</code></td>
<td>

<p>logical, if number of indicator species should be shown.
</p>
</td></tr>
<tr><td><code id="multicut_+3A_hr">hr</code>, <code id="multicut_+3A_tick">tick</code></td>
<td>

<p>logical, if horizontal rules (<code>hr</code>)
and ticks to the axis legends (<code>tick</code>) should be added.
Default is <code>TRUE</code> for both.
</p>
</td></tr>
<tr><td><code id="multicut_+3A_theme">theme</code></td>
<td>

<p>color theme as defined by <code><a href="#topic+occolors">occolors</a></code>.
</p>
</td></tr>
<tr><td><code id="multicut_+3A_mar">mar</code></td>
<td>

<p>numeric, graphical parameters for plot margin <code><a href="graphics.html#topic+par">par</a></code>.
</p>
</td></tr>
<tr><td><code id="multicut_+3A_ylab">ylab</code>, <code id="multicut_+3A_xlab">xlab</code>, <code id="multicut_+3A_las">las</code></td>
<td>

<p>graphical arguments, see <code><a href="base.html#topic+plot">plot</a></code>.
By default, <code>las</code> is 1 when <code>horizontal = TRUE</code> and
2 when <code>horizontal = FALSE</code>.
</p>
</td></tr>
<tr><td><code id="multicut_+3A_bty">bty</code></td>
<td>

<p>Character, determines the type of box which is drawn around plots,
see <code><a href="graphics.html#topic+par">par</a></code>.
</p>
</td></tr>
<tr><td><code id="multicut_+3A_lower">lower</code>, <code id="multicut_+3A_upper">upper</code></td>
<td>

<p>numeric (between 0 and 1), <code>lower</code> is the minimum and
<code>upper</code> is the maximum height for rectangles drawn in the plot.
Both need to be in [0, 1] and <code>higher</code> cannot be smaller than <code>lower</code>.
</p>
</td></tr>
<tr><td><code id="multicut_+3A_pos">pos</code></td>
<td>

<p>numeric, position of rectangles in the plot relative to the baseline.
Value must be in the [-1, 1] range (below vs. above baseline).
</p>
</td></tr>
<tr><td><code id="multicut_+3A_horizontal">horizontal</code></td>
<td>

<p>logical, plot orientation: species as rows (<code>TRUE</code>)
or as columns (<code>FALSE</code>).
</p>
</td></tr>
<tr><td><code id="multicut_+3A_digits">digits</code></td>
<td>

<p>numeric, number of significant digits in output.
</p>
</td></tr>
<tr><td><code id="multicut_+3A_which">which</code></td>
<td>

<p>numeric or character (can be a vector) defining
a subset of species from the fitted object,
or <code>NULL</code> (all species, default).
</p>
</td></tr>
<tr><td><code id="multicut_+3A_row.names">row.names</code></td>
<td>

<p><code>NULL</code> or a character vector giving the row names for the data frame.
Missing values are not allowed. See <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>.
</p>
</td></tr>
<tr><td><code id="multicut_+3A_optional">optional</code></td>
<td>

<p>logical. If <code>TRUE</code>, setting row names and converting column names
(to syntactic names: see <code><a href="base.html#topic+make.names">make.names</a></code>) is optional.
See <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>.
</p>
</td></tr>
<tr><td><code id="multicut_+3A_subset">subset</code></td>
<td>

<p>logical, numeric, or character index indicating species to keep,
missing values are not accepted. The default <code>NULL</code> returns
the original object without subsetting.
</p>
</td></tr>
<tr><td><code id="multicut_+3A_vcov">vcov</code></td>
<td>

<p>logical, if variance-covariance matrix is to be returned.
</p>
</td></tr>
<tr><td><code id="multicut_+3A_gnew">gnew</code>, <code id="multicut_+3A_xnew">xnew</code></td>
<td>

<p>new values for <code>strata</code> and modifiers (right-hand-side of formula)
to predict for, or <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="multicut_+3A_...">...</code></td>
<td>

<p>other arguments passed to the underlying functions.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>multicut1</code> returns an object of class 'multicut1'.
</p>
<p><code>multicut</code> returns an object of class 'multicut', that is a list
with the following components:
</p>

<dl>
<dt><code>"call"</code></dt><dd><p>the function call.</p>
</dd>
<dt><code>"species"</code></dt><dd><p>a list of species specific multicut1 objects.</p>
</dd>
<dt><code>"X"</code></dt><dd><p>modifying variables as model matrix.</p>
</dd>
<dt><code>"Y"</code></dt><dd><p>response, single species vector or matrix.</p>
</dd>
<dt><code>"strata"</code></dt><dd><p>defines the stratification.</p>
</dd>
<dt><code>"nobs"</code></dt><dd><p>sample size.</p>
</dd>
<dt><code>"sset"</code></dt><dd><p>subset, if specified.</p>
</dd>
<dt><code>"dist"</code></dt><dd><p>distribution.</p>
</dd>
<dt><code>"failed"</code></dt><dd><p>IDs for failed species models dropped from results list.</p>
</dd>
</dl>

<p>The <code>strata</code> method extracts the <code>strata</code> argument
as factor.
</p>
<p>The <code>print</code> and <code>summary</code> methods are called for their side effects
showing expected values, and log likelihood ratio (logLR).
Optimal binary partitions are determined as part of the
summary based on Lorenz-tangent based thresholding,
which requires nonnegative expected values.
Indicator potential (I) is based on largest the
contrast (difference) between the minimum and maximum
estimates on the linear predictor (link) scale.
</p>
<p>The <code>subset</code> method subsets the species in the multicut object.
</p>
<p>The <code>plot</code> method presents the estimates by species and strata.
The <code>lcplot</code> method plots the Lorenz curve for a single
species 'multicut1' object.
</p>
<p><code><a href="#topic+bestpart">bestpart</a></code> returns a matrix with the best supported
partitions for each species (samples and rows, species as columns).
Binary partitions are based on Lorenz-tangent based optimal threshold
(see <code><a href="#topic+lorenz">lorenz</a></code>).
<code><a href="#topic+lorenz">lorenz</a></code> requires nonnegative fitted values
which is not guaranteed under <code>dist = "gaussian"</code> with identity
link, see <code>fix_fitted</code> <code><a href="#topic+ocoptions">ocoptions</a></code> setting
for how to resolve this (choosing a different link function,
distribution, or centering modified variables is advised).
</p>
<p><code><a href="#topic+bestmodel">bestmodel</a></code> returns the best supported model for further
manipulation (e.g. prediction). Note: custom distribution
functions are designed to return only point estimates,
thus the best model cannot be returned. In this case,
use the best partition returned by <code>bestpart</code> to refit the model.
<code>getMLE</code> returns a named list corresponding to the best supported
model. The list has the following elements:
<code>coef</code> is the Maximum Likelihood Estimate (MLE),
<code>vcov</code> is the variance-covariance matrix for the MLE or <code>NULL</code>,
<code>dist</code> is the distribution inherited from input <code>object</code>.
</p>
<p><code><a href="stats.html#topic+fitted">fitted</a></code> returns expected values on the predictor scale
for the observations as a matrix (number of observations by number of species).
<code><a href="stats.html#topic+predict">predict</a></code> returns <code>fitted</code> values when both <code>gnew</code>
and <code>xnew</code> are <code>NULL</code>, or corresponding point predictions
(expected values) on the predictor scale.
</p>
<p>The coercion methods <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> return a data frame.
</p>


<h3>Warning</h3>

<p>The use of the <code>multicut1</code> function is generally discouraged:
some of the internal checks are not guaranteed to
flag issues when the formula-to-model-matrix translation is side-stepped
(this is what is happening when the modifier variables are supplied
as <code>X</code> argument in <code>multicut1</code>).
Use the <code>multicut</code> function with a single species instead.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos &lt;psolymos@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lorenz">lorenz</a></code> Examples for how multi-level partitions are binarized
using the Lorenz-tangent approach.
</p>
<p><code><a href="#topic+opticut">opticut</a></code> for optimal binary response model,
<code><a href="#topic+optilevels">optilevels</a></code> for finding the optimal number of factor levels.
</p>
<p><code><a href="#topic+beta2i">beta2i</a></code> for indicator potential (I) calculations in summaries.
</p>
<p><code><a href="#topic+bestmodel">bestmodel</a></code>, <code><a href="#topic+bestpart">bestpart</a></code>, and <code><a href="#topic+uncertainty">uncertainty</a></code>
for manipulating fitted objects.
</p>
<p><code><a href="#topic+ocoptions">ocoptions</a></code> on how to set some of the global options
related to the presentation of the results in the package
and how errors encountered during model fitting are handled.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## --- Gaussian
## simple example from Legendre 2013
## Indicator Species: Computation, in
## Encyclopedia of Biodiversity, Volume 4
## https://dx.doi.org/10.1016/B978-0-12-384719-5.00430-5
gr &lt;- as.factor(paste0("X", rep(1:5, each=5)))
spp &lt;- cbind(Species1=rep(c(4,6,5,3,2), each=5),
    Species2=c(rep(c(8,4,6), each=5), 4,4,2, rep(0,7)),
    Species3=rep(c(18,2,0,0,0), each=5))
rownames(spp) &lt;- gr
## must add some noise to avoid perfect fit
spp[6, "Species1"] &lt;- 7
spp[1, "Species3"] &lt;- 17
spp

## negative expected values are not good
oco &lt;- ocoptions(fix_fitted=TRUE)
summary(ocall &lt;- multicut(spp ~ 1, strata=gr, dist="gaussian"))
summary(multicut(spp, strata=gr, dist="gaussian")) # alternative
ocoptions(oco) # reset options

## --- Binomial
## simulated binary data
set.seed(1234)
n &lt;- 200
x0 &lt;- sample(1:4, n, TRUE)
x1 &lt;- ifelse(x0 &lt;= 2, 1, 0)
x2 &lt;- rnorm(n, 0.5, 1)
p1 &lt;- plogis(-0.5 + 2*x1 + -0.8*x2)
Y1 &lt;- rbinom(n, 1, p1)
p2 &lt;- plogis(-0.1 + 2*ifelse(x0==4,1,0) + -0.8*x2)
Y2 &lt;- rbinom(n, 1, p2)
p3 &lt;- plogis(-0.1 + -0.8*x2)
Y3 &lt;- rbinom(n, 1, p3)
Y &lt;- cbind(SPP1=Y1, SPP2=Y2, SPP3=Y3)
X &lt;- model.matrix(~x2)

(m0 &lt;- multicut1(Y1, X, as.factor(x0), dist="binomial"))
lcplot(m0)

summary(m1 &lt;- multicut(Y ~ x2, strata=x0, dist="poisson"))
plot(m1)

## subset results
summary(subset(m1, 1:2))

## best partition
head(bestpart(m1))

## best model
mods &lt;- bestmodel(m1)
mods
## explore further
confint(mods[[1]])

## MLE and variance-covariance matrix (species 1)
getMLE(m1, which = 1, vcov=TRUE)

## fitted values
head(fitted(m1))
## prediction for new data
head(predict(m1, gnew=x0, xnew=data.frame(x2=x2)))

## Not run: 
## --- Zero-inflated Negative Binomial
## dolina example
data(dolina)
## stratum as ordinal
dolina$samp$stratum &lt;- as.integer(dolina$samp$stratum)
## filter species to speed up things a bit
Y &lt;- dolina$xtab[,colSums(dolina$xtab &gt; 0) &gt;= 20]
## opticut results, note the cloglog link function
dol &lt;- multicut(Y ~ stratum + lmoist + method, data=dolina$samp,
    strata=dolina$samp$mhab, dist="zinb:cloglog")
summary(dol)
## vertical plot orientation
plot(dol, horizontal=FALSE, pos=1, upper=0.8)

## parallel
library(parallel)
cl &lt;- makeCluster(2)
multicut(Y ~ stratum + lmoist + method, data=dolina$samp,
    strata=dolina$samp$mhab, dist="zip",cl=cl)
stopCluster(cl)

## --- Customizing distributions
## we may want to expand the Zero-inflation component in a ZIP model
## see how the return value needs to be structured
fun &lt;- function(Y, X, linkinv, zi_term, ...) {
    X &lt;- as.matrix(X)
    mod &lt;- pscl::zeroinfl(Y ~ X-1 | zi_term, dist = "poisson", ...)
    list(coef=coef(mod),
        logLik=logLik(mod),
        linkinv=mod$linkinv)
}
Xdol &lt;- model.matrix(~ stratum + lmoist + method, data=dolina$samp)
## this fits the null model (i.e. no partitions added)
fun(Y[,"amin"], Xdol, zi_term=dolina$samp$method)
## now we can use dist=fun
multicut1(Y[,"amin"], Xdol, Z=dolina$samp$mhab,
    dist=fun, zi_term=dolina$samp$method)
dol2 &lt;- multicut(Y ~ stratum + lmoist + method, data=dolina$samp,
    strata=dolina$samp$mhab, dist=fun, zi_term=dolina$samp$method)
summary(dol2)

## End(Not run)
</code></pre>

<hr>
<h2 id='occolors'>
Color Palettes for the opticut Package
</h2><span id='topic+occolors'></span><span id='topic+col2gray'></span>

<h3>Description</h3>

<p>A convenient way of setting color palettes for the opticut package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>occolors(theme)
col2gray(col, method="BT.709")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="occolors_+3A_theme">theme</code></td>
<td>

<p>character value, character vector, or a function used to interpolate the colors.
The built-in values are <code>"br"</code> (default, blue-red divergent palette,
colorblind safe),
<code>"gr"</code> (green-red divergent palette), <code>"bw"</code> (black and white: grayscale converted <code>"br"</code> settings).
See <code><a href="grDevices.html#topic+colorRampPalette">colorRampPalette</a></code>, <code><a href="grDevices.html#topic+gray">gray</a></code> and the Examples.
</p>
</td></tr>
<tr><td><code id="occolors_+3A_col">col</code></td>
<td>

<p>vector of color specification as described on the help page
for the <code><a href="grDevices.html#topic+col2rgb">col2rgb</a></code> function. This is converted to grayscale.
</p>
</td></tr>
<tr><td><code id="occolors_+3A_method">method</code></td>
<td>

<p>character, the method used for grayscale conversion. See Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Grayscale conversion methods in <code>col2gray</code> calculate gray levels based on
red (R), green (G), and blue (B) color channels as follows:
</p>

<dl>
<dt><code>"BT.709"</code></dt><dd><p>0.2126 * R + 0.7152 * G + 0.0722 * B,
luminosity correction following the  ITU-R BT.709 recommendation;</p>
</dd>
<dt><code>"BT.601"</code></dt><dd><p>0.299 * R + 0.587 * G + 0.114 * B,
luminosity correction following the  ITU-R BT.601 recommendation;</p>
</dd>
<dt><code>"desaturate"</code></dt><dd><p>(max(R, G, B) + min(R, G, B)) / 2,
also called lightness;</p>
</dd>
<dt><code>"average"</code></dt><dd><p>(R + G + B) / 3;</p>
</dd>
<dt><code>"maximum"</code></dt><dd><p>max(R, G, B);</p>
</dd>
<dt><code>"minimum"</code></dt><dd><p>min(R, G, B);</p>
</dd>
<dt><code>"red"</code></dt><dd><p>R;</p>
</dd>
<dt><code>"green"</code></dt><dd><p>G;</p>
</dd>
<dt><code>"blue"</code></dt><dd><p>B.</p>
</dd>
</dl>



<h3>Value</h3>

<p><code>occolors</code> returns a function, see <code><a href="grDevices.html#topic+colorRampPalette">colorRampPalette</a></code>.
</p>
<p><code>col2gray</code> returns a vector of gray colors based on
the conversion <code>method</code> and <code><a href="grDevices.html#topic+gray">gray</a></code>.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos &lt;psolymos@gmail.com&gt;
</p>
<p>Hexadecimal values for the built-in palettes are taken from
<a href="https://colorbrewer2.org/">https://colorbrewer2.org/</a>.
</p>
<p>Converting color to grayscale:
<a href="https://en.wikipedia.org/wiki/Grayscale">https://en.wikipedia.org/wiki/Grayscale</a>
</p>


<h3>See Also</h3>

<p><code><a href="grDevices.html#topic+colorRampPalette">colorRampPalette</a></code> for a general description of palettes.
</p>
<p><code><a href="#topic+ocoptions">ocoptions</a></code> for setting the color theme option in the
opticut package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## using palettes
plot(1:100, rep(2, 100), pch = 15,
    ylim = c(0, 21), axes = FALSE, ann = FALSE,
    col = occolors()(100)) # default 'bg'
text(50, 1, "theme = 'br'")
points(1:100, rep(5, 100), pch = 15,
    col=occolors("gr")(100))
text(50, 4, "theme = 'gr'")
points(1:100, rep(8, 100), pch = 15,
    col=occolors("bw")(100))
text(50, 7, "theme = 'bw'")
points(1:100, rep(11, 100), pch = 15,
    col=occolors(terrain.colors)(100))
text(50, 10, "theme = terrain.colors")
points(1:100, rep(14, 100), pch = 15,
    col=occolors(c("purple", "pink", "orange"))(100))
text(50, 13, "theme = c('purple', 'pink', 'orange')")
points(1:100, rep(17, 100), pch = 15,
    col=occolors(c("#a6611a", "#ffffbf", "#018571"))(100))
text(50, 16, "theme = c('#a6611a', '#ffffbf', '#018571')")
points(1:100, rep(20, 100), pch = 15,
    col=occolors(c("#7b3294", "#ffffbf", "#008837"))(100))
text(50, 19, "theme = c('#7b3294', '#ffffbf', '#008837')")

## grayscale conversions
n &lt;- 25
col &lt;- occolors("br")(n)
method &lt;- c("BT.709", "BT.601",
    "desaturate", "average", "maximum", "minimum",
    "red", "green", "blue")
plot(0, type="n", ann=FALSE, axes=FALSE,
    xlim=c(0, n), ylim=c(3*length(method), 0))
for (j in 1:length(method)) {
    for (i in 1:n) {
        polygon(c(i-1, i, i, i-1), c(0, 0, 1, 1)+((j-1)*3),
            col=col[i], border=col[i])
        polygon(c(i-1, i, i, i-1), c(1, 1, 2, 2)+((j-1)*3),
            col=col2gray(col[i], method=method[j]),
            border=col2gray(col[i], method=method[j]))
        text(n/2, 1+((j-1)*3), method[j])
    }
}
</code></pre>

<hr>
<h2 id='ocoptions'>
Options for the opticut Package
</h2><span id='topic+ocoptions'></span>

<h3>Description</h3>

<p>A convenient way of handling options related to the opticut package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ocoptions(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ocoptions_+3A_...">...</code></td>
<td>

<p>arguments in <code>tag = value</code> form, or a list of tagged values.
The tags must come from the parameters described below.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When parameters are set by <code>ocoptions</code>, their former values are
returned in an invisible named list. Such a list can be passed as an
argument to <code>ocoptions</code> to restore the parameter values.
Tags are the following:
</p>
<table role = "presentation">
<tr><td><code>collapse</code></td>
<td>
<p>character value to be used when merging factor levels,
the default is <code>"+"</code>.</p>
</td></tr>
<tr><td><code>cut</code></td>
<td>
<p>log likelihood ratio value, model/species with lower
values are excluded from summaries and plots,
the default is <code>2</code>.</p>
</td></tr>
<tr><td><code>sort</code></td>
<td>
<p>logical value indicating if species/partitions
should be meaningfully sorted, the default is <code>TRUE</code>.
It can take numeric value when only species (<code>1</code>)
or partitions (<code>2</code>) are to be sorted (<code>1:2</code> is equivalent to
<code>TRUE</code>).</p>
</td></tr>
<tr><td><code>theme</code></td>
<td>
<p>the color theme to be used based on <code><a href="#topic+occolors">occolors</a></code>,
the default is <code>"br"</code>.</p>
</td></tr>
<tr><td><code>check_comb</code></td>
<td>
<p>check the design matrices for complementary partitions
using <code><a href="#topic+checkComb">checkComb</a></code>,
the default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code>try_error</code></td>
<td>
<p>if <code><a href="#topic+opticut">opticut</a></code> and <code><a href="#topic+multicut">multicut</a></code>
should <code><a href="base.html#topic+try">try</a></code> to exclude
species where the models failed (<code>TRUE</code>), the default
is to stop when an error is encountered (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>the scaling factor used to calculate indicator potential (I)
based on the estimated contrast (x): I = abs(tanh(x*scale)),
the default is 0.5.</p>
</td></tr>
<tr><td><code>fix_fitted</code></td>
<td>
<p><code><a href="#topic+bestpart.multicut">bestpart.multicut</a></code>
uses <code><a href="#topic+lorenz">lorenz</a></code> which requires nonnegative fitted values,
however models with identity link can lead to negative expected values.
When <code>TRUE</code> the fitted values (x) are adjusted as x' = x + abs(min(x))
to ensure nonnegativity. The default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code>robust_loglik</code></td>
<td>
<p>if ill-defined models resulting in perfect fit
(infinite log likelihood, or <code>NA</code>, <code>NaN</code>)
should be allowed. The default <code>TRUE</code> makes such ill-defined
log likelihoods a very small real number
<code>-(.Machine$double.xmax^(1/3))</code>.
<code>FALSE</code> is equivalent to allowing every model to
safeguard against such cases or not.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Peter Solymos &lt;psolymos@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simple example from Legendre 2013
## Indicator Species: Computation, in
## Encyclopedia of Biodiversity, Volume 4
## https://dx.doi.org/10.1016/B978-0-12-384719-5.00430-5
gr &lt;- as.factor(paste0("X", rep(1:5, each=5)))
spp &lt;- cbind(Species1=rep(c(4,6,5,3,2), each=5),
    Species2=c(rep(c(8,4,6), each=5), 4,4,2, rep(0,7)),
    Species3=rep(c(18,2,0,0,0), each=5))
rownames(spp) &lt;- gr
## must add some noise to avoid perfect fit
spp[6, "Species1"] &lt;- 7
spp[1, "Species3"] &lt;- 17
spp

## current settings
print(unlist(ocoptions())) # these give identical answers
unlist(getOption("ocoptions"))
summary(ocall &lt;- opticut(spp ~ 1, strata=gr, dist="gaussian", comb="all"))

## resetting pboptions and checking new settings
ocop &lt;- ocoptions(collapse="&amp;", sort=FALSE)
unlist(getOption("ocoptions"))
## running again with new settings
summary(ocall &lt;- opticut(spp ~ 1, strata=gr, dist="gaussian", comb="all"))

## resetting original
ocoptions(ocop)
unlist(getOption("ocoptions"))
</code></pre>

<hr>
<h2 id='opticut'>
Optimal Binary Response Model
</h2><span id='topic+opticut'></span><span id='topic+opticut.default'></span><span id='topic+opticut.formula'></span><span id='topic+opticut1'></span><span id='topic+fitted.opticut'></span><span id='topic+predict.opticut'></span><span id='topic+plot.opticut'></span><span id='topic+wplot'></span><span id='topic+fix_levels'></span><span id='topic+strata'></span><span id='topic+strata.opticut'></span><span id='topic+wplot.opticut'></span><span id='topic+wplot.opticut1'></span><span id='topic+print.opticut'></span><span id='topic+print.opticut1'></span><span id='topic+subset.opticut'></span><span id='topic+summary.opticut'></span><span id='topic+print.summary.opticut'></span><span id='topic+bestmodel.opticut'></span><span id='topic+bestpart.opticut'></span><span id='topic+as.data.frame.opticut'></span><span id='topic+as.data.frame.summary.opticut'></span><span id='topic+getMLE.opticut'></span>

<h3>Description</h3>

<p>The functions fits the multi-level response model for each species
by finding the best binary partition based on model selection.
Possibly controlling for modifying/confounding variables.
The general algorithm is described in Kemencei et al. 2014.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opticut1(Y, X, Z, dist = "gaussian", sset=NULL, ...)

opticut(...)
## Default S3 method:
opticut(Y, X, strata, dist = "gaussian",
    comb = c("rank", "all"), sset=NULL, cl = NULL, ...)
## S3 method for class 'formula'
opticut(formula, data, strata, dist = "gaussian",
    comb = c("rank", "all"), sset=NULL, cl = NULL, ...)

fix_levels(x, sep = "_")
strata(object, ...)
## S3 method for class 'opticut'
strata(object, ...)

## S3 method for class 'opticut'
bestmodel(object, which = NULL, ...)
## S3 method for class 'opticut'
bestpart(object, pos_only = FALSE, ...)
## S3 method for class 'opticut'
getMLE(object, which, vcov=FALSE, ...)
## S3 method for class 'opticut'
subset(x, subset=NULL, ...)
## S3 method for class 'opticut'
fitted(object, ...)
## S3 method for class 'opticut'
predict(object, gnew=NULL, xnew=NULL, ...)

wplot(x, ...)
## S3 method for class 'opticut1'
wplot(x, cut, ylim = c(-1, 1),
    las=1, ylab = "Model weight * Association", xlab = "Partitions",
    theme, mar = c(5, 4, 4, 4) + 0.1, bty = "o", ...)
## S3 method for class 'opticut'
wplot(x, which = NULL, cut, sort,
    las = 1, ylab = "Model weight * Association", xlab = "Partitions",
    theme, mar = c(5, 4, 4, 4) + 0.1, bty = "o", ...)
## S3 method for class 'opticut'
plot(x, which = NULL, cut, sort,
    las, ylab = "Relative abundance", xlab = "Strata",
    show_I = TRUE, show_S = TRUE, hr = TRUE, tick = TRUE,
    theme, mar = c(5, 4, 4, 4) + 0.1, bty = "o",
    lower = 0, upper = 1, pos = 0, horizontal=TRUE, ...)

## S3 method for class 'opticut1'
print(x, cut, sort, digits, ...)
## S3 method for class 'opticut'
print(x, digits, ...)
## S3 method for class 'summary.opticut'
print(x, cut, sort, digits, ...)
## S3 method for class 'opticut'
summary(object, ...)

## S3 method for class 'opticut'
as.data.frame(x,
    row.names = NULL, optional = FALSE, cut, sort, ...)
## S3 method for class 'summary.opticut'
as.data.frame(x,
    row.names = NULL, optional = FALSE, cut, sort, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="opticut_+3A_formula">formula</code></td>
<td>

<p>two sided model formula, response species data (matrix,
or possible a vector for single species case) in the left-hand side,
model terms for modifying effects in the right-hand side
(its structure depending on the underlying functions).
For example, in the most basic Gaussian case it can be
<code>y ~ 1</code> (no modifying variables) or <code>y ~ x</code>
(with modifying variables).
Centering the modifying terms (or choosing the origin wisely)
is generally recommended (especially for Gaussian distribution
where linear predictors are additive on the response scale)
because the relative abundance contrast is estimated at the origin (0).
</p>
</td></tr>
<tr><td><code id="opticut_+3A_data">data</code></td>
<td>

<p>an optional data frame, list or environment containing the variables
in the model. If not found in data, the variables are taken from
<code>parent.frame()</code>, typically the environment
from which <code>opticut</code> is called.
</p>
</td></tr>
<tr><td><code id="opticut_+3A_strata">strata</code></td>
<td>

<p>vector (usually a factor), unique values define partitions
(must have at least 2 unique levels, empty levels are dropped).
It can also be a matrix with rows as observations and
binary partitions as columns.
</p>
</td></tr>
<tr><td><code id="opticut_+3A_dist">dist</code></td>
<td>

<p>character or function, a distribution to fit.
If character, it can follow one of these patterns: <code>"family"</code>,
or <code>"family:link"</code> when appropriate (there is a <code>link</code>
argument in the underlying function, or the link
can be specified via the <code>family</code> argument).
See Details and Examples.
</p>
</td></tr>
<tr><td><code id="opticut_+3A_comb">comb</code></td>
<td>

<p>character, how to define the binary partitions.
<code>"rank"</code> uses <code><a href="#topic+rankComb">rankComb</a></code>,
<code>"all"</code> uses <code><a href="#topic+allComb">allComb</a></code>.
</p>
</td></tr>
<tr><td><code id="opticut_+3A_sset">sset</code></td>
<td>

<p>an optional vector specifying a subset of observations (rows)
to be used in the fitting process. <code>NULL</code> means no subset taken.
</p>
</td></tr>
<tr><td><code id="opticut_+3A_cl">cl</code></td>
<td>

<p>a cluster object, or an integer for multiple cores in parallel computations
(integer value for forking is ignored on Windows).
</p>
</td></tr>
<tr><td><code id="opticut_+3A_y">Y</code></td>
<td>

<p>numeric vector of observations for <code>opticut1</code>,
vector or community matrix for <code>opticut.default</code>.
</p>
</td></tr>
<tr><td><code id="opticut_+3A_x">X</code></td>
<td>

<p>numeric, design matrix. Can be missing, in which case an intercept-only model
is assumed.
</p>
</td></tr>
<tr><td><code id="opticut_+3A_z">Z</code></td>
<td>

<p>factor (must have at least 2 unique levels,
this triggers <code><a href="#topic+rankComb">rankComb</a></code>),
or a design matrix (custom matrix or as returned by <code><a href="#topic+allComb">allComb</a></code>.
</p>
</td></tr>
<tr><td><code id="opticut_+3A_x">x</code>, <code id="opticut_+3A_object">object</code></td>
<td>

<p>object to plot, print, summarize. For <code>fix_levels</code> it needs to be a factor.
</p>
</td></tr>
<tr><td><code id="opticut_+3A_cut">cut</code></td>
<td>

<p>log likelihood ratio value to be used as a cut-off for showing species
whose log likelihood ratio is not less than the cut-off.
</p>
</td></tr>
<tr><td><code id="opticut_+3A_sort">sort</code></td>
<td>

<p>logical value indicating if species/partitions
should be meaningfully sorted, the default is <code>TRUE</code>.
It can take numeric value when only species (<code>1</code>)
or partitions (<code>2</code>) are to be sorted (<code>1:2</code> is equivalent to
<code>TRUE</code>).
</p>
</td></tr>
<tr><td><code id="opticut_+3A_show_i">show_I</code></td>
<td>

<p>logical, if indicator potential (I) should be shown.
</p>
</td></tr>
<tr><td><code id="opticut_+3A_show_s">show_S</code></td>
<td>

<p>logical, if number of indicator species should be shown.
</p>
</td></tr>
<tr><td><code id="opticut_+3A_hr">hr</code>, <code id="opticut_+3A_tick">tick</code></td>
<td>

<p>logical, if horizontal rules (<code>hr</code>)
and ticks to the axis legends (<code>tick</code>) should be added.
Default is <code>TRUE</code> for both.
</p>
</td></tr>
<tr><td><code id="opticut_+3A_theme">theme</code></td>
<td>

<p>color theme as defined by <code><a href="#topic+occolors">occolors</a></code>.
</p>
</td></tr>
<tr><td><code id="opticut_+3A_mar">mar</code></td>
<td>

<p>numeric, graphical parameters for plot margin <code><a href="graphics.html#topic+par">par</a></code>.
</p>
</td></tr>
<tr><td><code id="opticut_+3A_ylab">ylab</code>, <code id="opticut_+3A_xlab">xlab</code>, <code id="opticut_+3A_las">las</code>, <code id="opticut_+3A_ylim">ylim</code></td>
<td>

<p>graphical arguments, see <code><a href="base.html#topic+plot">plot</a></code>.
By default, <code>las</code> is 1 when <code>horizontal = TRUE</code> and
2 when <code>horizontal = FALSE</code>.
</p>
</td></tr>
<tr><td><code id="opticut_+3A_bty">bty</code></td>
<td>

<p>Character, determines the type of box which is drawn around plots,
see <code><a href="graphics.html#topic+par">par</a></code>.
</p>
</td></tr>
<tr><td><code id="opticut_+3A_lower">lower</code>, <code id="opticut_+3A_upper">upper</code></td>
<td>

<p>numeric (between 0 and 1), <code>lower</code> is the minimum and
<code>upper</code> is the maximum height for rectangles drawn in the plot.
Both need to be in [0, 1] and <code>higher</code> cannot be smaller than <code>lower</code>.
</p>
</td></tr>
<tr><td><code id="opticut_+3A_pos">pos</code></td>
<td>

<p>numeric, position of rectangles in the plot relative to the baseline.
Value must be in the [-1, 1] range (below vs. above baseline).
</p>
</td></tr>
<tr><td><code id="opticut_+3A_horizontal">horizontal</code></td>
<td>

<p>logical, plot orientation: species as rows (<code>TRUE</code>)
or as columns (<code>FALSE</code>).
</p>
</td></tr>
<tr><td><code id="opticut_+3A_digits">digits</code></td>
<td>

<p>numeric, number of significant digits in output.
</p>
</td></tr>
<tr><td><code id="opticut_+3A_which">which</code></td>
<td>

<p>numeric or character (can be a vector) defining
a subset of species from the fitted object,
or <code>NULL</code> (all species, default).
</p>
</td></tr>
<tr><td><code id="opticut_+3A_sep">sep</code></td>
<td>

<p>a character string to separate the sub-strings in factor levels.
</p>
</td></tr>
<tr><td><code id="opticut_+3A_row.names">row.names</code></td>
<td>

<p><code>NULL</code> or a character vector giving the row names for the data frame.
Missing values are not allowed. See <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>.
</p>
</td></tr>
<tr><td><code id="opticut_+3A_optional">optional</code></td>
<td>

<p>logical. If <code>TRUE</code>, setting row names and converting column names
(to syntactic names: see <code><a href="base.html#topic+make.names">make.names</a></code>) is optional.
See <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>.
</p>
</td></tr>
<tr><td><code id="opticut_+3A_pos_only">pos_only</code></td>
<td>

<p>logical, best partition normally returns the original variable without
recognizing the direction of the association.
<code>pos_only = TRUE</code> returns values where negative associations are
taken into account and <code>1</code> indicates strata of positive association.
This is only important when <code>comb</code> is not <code>"rank"</code>.
</p>
</td></tr>
<tr><td><code id="opticut_+3A_subset">subset</code></td>
<td>

<p>logical, numeric, or character index indicating species to keep,
missing values are not accepted. The default <code>NULL</code> returns
the original object without subsetting.
</p>
</td></tr>
<tr><td><code id="opticut_+3A_vcov">vcov</code></td>
<td>

<p>logical, if variance-covariance matrix is to be returned.
</p>
</td></tr>
<tr><td><code id="opticut_+3A_gnew">gnew</code>, <code id="opticut_+3A_xnew">xnew</code></td>
<td>

<p>new values for <code>strata</code> and modifiers (right-hand-side of formula)
to predict for, or <code>NULL</code>.
Predicting for new strata available for <code>comb = "rank"</code> models only.
</p>
</td></tr>
<tr><td><code id="opticut_+3A_...">...</code></td>
<td>

<p>other arguments passed to the underlying functions.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently available distributions:
</p>

<dl>
<dt><code>"gaussian"</code></dt><dd><p>real valued continuous observations, e.g. biomass,
uses <code><a href="stats.html#topic+lm">lm</a></code> of the stats package.
Identity link is assumed. Centering modified variables is generally advised
to avoid negative expected values when the response is nonnegative.</p>
</dd>
<dt><code>"poisson"</code></dt><dd><p>Poisson count data,
uses <code><a href="stats.html#topic+glm">glm</a></code> of the stats package.
Exponential (log) link is assumed.</p>
</dd>
<dt><code>"binomial"</code></dt><dd><p>presence-absence (detection-nondetection) type data,
uses <code><a href="stats.html#topic+glm">glm</a></code> of the stats package.
Logistic (logit) link is assumed.</p>
</dd>
<dt><code>"negbin"</code></dt><dd><p>overdispersed Negative Binomial count data,
uses <code><a href="MASS.html#topic+glm.nb">glm.nb</a></code> of the MASS package.
Exponential (log) link is assumed.</p>
</dd>
<dt><code>"beta"</code></dt><dd><p>continuous response in the unit interval (0-1),
e.g. percent cover,
uses <code><a href="betareg.html#topic+betareg">betareg</a></code> of the betareg package.
Logistic (logit) link for the mean model is assumed.</p>
</dd>
<dt><code>"zip"</code></dt><dd><p>zero-inflated Poisson counts,
indicative properties are tested as part of the abundance model,
uses <code><a href="pscl.html#topic+zeroinfl">zeroinfl</a></code> of the pscl package.
Exponential (log) link is used for count based analysis,
the second part of the <code>dist</code> argument following the colon
is used as link function for the zero component (logistic link assumed).</p>
</dd>
<dt><code>"zinb"</code></dt><dd><p>zero-inflated Negative Binomial counts,
indicative properties are tested as part of the abundance model,
uses <code><a href="pscl.html#topic+zeroinfl">zeroinfl</a></code> of the pscl package.
The zero-inflation component refers to the probability of 0.
Exponential (log) link is used for count based analysis,
the second part of the <code>dist</code> argument following the colon
is used as link function for the zero component (logistic link assumed).</p>
</dd>
<dt><code>"zip2"</code></dt><dd><p>zero-inflated Poisson counts,
indicative properties are tested as part of the zero-model,
uses <code><a href="pscl.html#topic+zeroinfl">zeroinfl</a></code> of the pscl package.
The zero-inflation component refers to the probability of 1
to be consistent with other methods regarding positive and negative effects.
Logistic (logit) link is assumed for zero-nonzero based analysis,
only symmetric link functions (logit, probit) allowed.
Exponential (log) link is used for the count data part which cannot be changed.</p>
</dd>
<dt><code>"zinb2"</code></dt><dd><p>zero-inflated Negative Binomial counts,
indicative properties are tested as part of the zero-model,
uses <code><a href="pscl.html#topic+zeroinfl">zeroinfl</a></code> of the pscl package.
The zero-inflation component refers to the probability of 1
to be consistent with other methods regarding positive and negative effects.
Logistic (logit) link is assumed for zero-nonzero based analysis,
only symmetric link functions (logit, probit) allowed.
Exponential (log) link is used for the count data part which cannot be changed.</p>
</dd>
<dt><code>"rsf"</code></dt><dd><p>presence-only data using resource selection
functions (RSF) as explained in  <code><a href="ResourceSelection.html#topic+rsf">rsf</a></code>
in the ResourceSelection package, assuming global availability (<code>m = 0</code>).
The <code>"rsf"</code> works only for single species using <code>opticut1</code>
because 'presence-only' type data cannot be kept in a single
matrix-like object for multiple species.
Intercept only model (i.e. no modifier variables in right-hand-side
of the formula) is accepted for <code>"rsf"</code>.
Exponential (log) link is assumed.</p>
</dd>
<dt><code>"rspf"</code></dt><dd><p>presence-only data using resource selection
probability functions (RSPF)
as explained in <code><a href="ResourceSelection.html#topic+rspf">rspf</a></code>
in the ResourceSelection package, assuming global availability (<code>m = 0</code>).
The <code>"rspf"</code> works only for single species using <code>opticut1</code>
because 'presence-only' type data cannot be kept in a single
matrix-like object for multiple species.
Intercept only model is not accepted for <code>"rspf"</code>, need to have
at least one continuous modifier variable for identifiability
(see Solymos &amp; Lele 2016).
Logistic (logit) link is assumed.</p>
</dd>
</dl>

<p>Custom distributions can be defined, see Examples.
Note: not all downstream algorithms and methods work with custom distributions.
</p>
<p><code>fix_levels</code> is a utility function for replacing characters in
factor levels that are identical to the value of the
<code>getOption("ocoptions")$collapse</code> value.
This case can lead to an error when specifying the <code>strata</code> argument,
and the <code>fix_levels</code> can help.
</p>


<h3>Value</h3>

<p><code>opticut1</code> returns an object of class opticut1, that is a modified
data frame with additional attributes.
</p>
<p><code>opticut</code> returns an object of class opticut, that is a list
with the following components:
</p>

<dl>
<dt><code>"call"</code></dt><dd><p>the function call.</p>
</dd>
<dt><code>"species"</code></dt><dd><p>a list of species specific opticut1 objects.</p>
</dd>
<dt><code>"X"</code></dt><dd><p>modifying variables as model matrix.</p>
</dd>
<dt><code>"Y"</code></dt><dd><p>response, single species vector or matrix.</p>
</dd>
<dt><code>"strata"</code></dt><dd><p>defines the partitions.</p>
</dd>
<dt><code>"nobs"</code></dt><dd><p>sample size.</p>
</dd>
<dt><code>"sset"</code></dt><dd><p>subset, if specified.</p>
</dd>
<dt><code>"nsplit"</code></dt><dd><p>number of binary splits considered.</p>
</dd>
<dt><code>"dist"</code></dt><dd><p>distribution.</p>
</dd>
<dt><code>"comb"</code></dt><dd><p>combination type.</p>
</dd>
<dt><code>"failed"</code></dt><dd><p>IDs for failed species models dropped from results list.</p>
</dd>
<dt><code>"collapse"</code></dt><dd><p>character used for combining partition labels.</p>
</dd>
</dl>

<p><code>fix_levels</code> returns a factor with modified levels.
</p>
<p>The <code>strata</code> method extracts the <code>strata</code> argument
as factor. The method finds unique row combinations
when custom matrix is supplied for <code>strata</code>.
</p>
<p>The <code>print</code> and <code>summary</code> methods are called for their side effects.
The summary shows the following information:
best supported split, strength and sign of association,
indicator potential (I), expected values (mu0, mu1),
log likelihood ratio (logLR), and model weights(w).
</p>
<p>The <code>subset</code> method subsets the species in the opticut object.
</p>
<p>The <code>plot</code> method presents the contrasts by species and strata.
</p>
<p>The <code>wplot</code> (weight plot) shows model weights for partitions.
</p>
<p><code><a href="#topic+bestpart">bestpart</a></code> returns a matrix with the best supported
partitions for each species (samples and rows, species as columns).
</p>
<p><code><a href="#topic+bestmodel">bestmodel</a></code> returns the best supported model for further
manipulation (e.g. prediction). Note: custom distribution
functions are designed to return only point estimates,
thus the best model cannot be returned. In this case,
use the best partition returned by <code>bestpart</code> to refit the model.
<code>getMLE</code> returns a named list corresponding to the best supported
model. The list has the following elements:
<code>coef</code> is the Maximum Likelihood Estimate (MLE),
<code>vcov</code> is the variance-covariance matrix for the MLE or <code>NULL</code>,
<code>dist</code> is the distribution inherited from input <code>object</code>.
</p>
<p><code><a href="stats.html#topic+fitted">fitted</a></code> returns expected values on the predictor scale
for the observations as a matrix (number of observations by number of species).
<code><a href="stats.html#topic+predict">predict</a></code> returns <code>fitted</code> values when both <code>gnew</code>
and <code>xnew</code> are <code>NULL</code>, or corresponding point predictions
(expected values) on the predictor scale
(available for <code>comb = "rank"</code> models only).
</p>
<p>The coercion methods <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> return a data frame.
</p>


<h3>Warning</h3>

<p>The use of the <code>opticut1</code> function is generally discouraged:
some of the internal checks are not guaranteed to
flag issues when the formula-to-model-matrix translation is side-stepped
(this is what is happening when the modifier variables are supplied
as <code>X</code> argument in <code>opticut1</code>).
Use the <code>opticut</code> with a single species instead.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos &lt;psolymos@gmail.com&gt; and Ermias T. Azeria
</p>


<h3>References</h3>

<p>Kemencei, Z., Farkas, R., Pall-Gergely, B., Vilisics, F., Nagy, A., Hornung,
E. &amp; Solymos, P. (2014): Microhabitat associations of land snails in
forested dolinas: implications for coarse filter conservation.
Community Ecology 15:180&ndash;186.
&lt;doi:10.1556/ComEc.15.2014.2.6&gt;
</p>
<p>Solymos, P. &amp; Lele, S. R. (2016): Revisiting resource selection probability
functions and single-visit methods: clarification and extensions.
Methods in Ecology and Evolution 7:196&ndash;205.
&lt;doi:10.1111/2041-210X.12432&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+allComb">allComb</a></code>, and <code><a href="#topic+rankComb">rankComb</a></code>
for partitioning algorithms.
</p>
<p><code><a href="#topic+beta2i">beta2i</a></code> for indicator potential (I) calculations in summaries.
</p>
<p><code><a href="#topic+bestmodel">bestmodel</a></code>, <code><a href="#topic+bestpart">bestpart</a></code>, and <code><a href="#topic+uncertainty">uncertainty</a></code>
for manipulating fitted objects.
</p>
<p><code><a href="#topic+ocoptions">ocoptions</a></code> on how to set some of the global options
related to the presentation of the results in the package
and how errors encountered during model fitting are handled.
</p>
<p><code><a href="#topic+multicut">multicut</a></code> for multinomial-response model,
<code><a href="#topic+optilevels">optilevels</a></code> for finding the optimal number of factor levels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## --- Gaussian
## simple example from Legendre 2013
## Indicator Species: Computation, in
## Encyclopedia of Biodiversity, Volume 4
## https://dx.doi.org/10.1016/B978-0-12-384719-5.00430-5
gr &lt;- as.factor(paste0("X", rep(1:5, each=5)))
spp &lt;- cbind(Species1=rep(c(4,6,5,3,2), each=5),
    Species2=c(rep(c(8,4,6), each=5), 4,4,2, rep(0,7)),
    Species3=rep(c(18,2,0,0,0), each=5))
rownames(spp) &lt;- gr
## must add some noise to avoid perfect fit
spp[6, "Species1"] &lt;- 7
spp[1, "Species3"] &lt;- 17
spp

## all partitions
summary(ocall &lt;- opticut(spp ~ 1, strata=gr, dist="gaussian", comb="all"))
summary(opticut(spp, strata=gr, dist="gaussian", comb="all")) # alternative

## rank based partitions
summary(ocrank &lt;- opticut(spp ~ 1, strata=gr, dist="gaussian", comb="rank"))
summary(opticut(spp, strata=gr, dist="gaussian", comb="rank")) # alternative

## --- Binomial
## simulated binary data
set.seed(1234)
n &lt;- 200
x0 &lt;- sample(1:4, n, TRUE)
x1 &lt;- ifelse(x0 &lt;= 2, 1, 0)
x2 &lt;- rnorm(n, 0.5, 1)
p1 &lt;- plogis(-0.5 + 2*x1 + -0.8*x2)
Y1 &lt;- rbinom(n, 1, p1)
p2 &lt;- plogis(-0.1 + 2*ifelse(x0==4,1,0) + -0.8*x2)
Y2 &lt;- rbinom(n, 1, p2)
p3 &lt;- plogis(-0.1 + -0.8*x2)
Y3 &lt;- rbinom(n, 1, p3)
Y &lt;- cbind(SPP1=Y1, SPP2=Y2, SPP3=Y3)
X &lt;- model.matrix(~x2)

## all partitions, single species
Z &lt;- allComb(x0)
opticut1(Y1, X, Z, dist="binomial")

## rank based partitions, single species
opticut1(Y1, X, as.factor(x0), dist="binomial")

## all partitions, multiple species
(m1 &lt;- opticut(Y ~ x2, strata=x0, dist="poisson", comb="all"))
summary(m1)
## show all species
summary(m1, cut=0)
## plot best partitions and indicator values
plot(m1)
## model weights for all species
wplot(m1)
## different ways of plotting weights for single species
wplot(m1$species[[1]])
wplot(m1, which = 1)

## rank based partitions, multiple species
summary(m2 &lt;- opticut(Y ~ x2, strata=x0, dist="poisson", comb="rank"))
## subset results
summary(subset(m2, 1:2))

## best partition
head(bestpart(m2))

## best model
mods &lt;- bestmodel(m2)
mods
## explore further
confint(mods[[1]])

## MLE and variance-covariance matrix (species 1)
getMLE(m2, which=1, vcov=TRUE)

## fitted values
head(fitted(m2))
## prediction for new data
head(predict(m2, gnew=x0, xnew=data.frame(x2=x2)))

## Not run: 
## --- Zero-inflated Negative Binomial
## dolina example
data(dolina)
## stratum as ordinal
dolina$samp$stratum &lt;- as.integer(dolina$samp$stratum)
## filter species to speed up things a bit
Y &lt;- dolina$xtab[,colSums(dolina$xtab &gt; 0) &gt;= 20]
## opticut results, note the cloglog link function
dol &lt;- opticut(Y ~ stratum + lmoist + method, data=dolina$samp,
    strata=dolina$samp$mhab, dist="zinb:cloglog")
summary(dol)
## vertical plot orientation
plot(dol, horizontal=FALSE, pos=1, upper=0.8)

## parallel computing comparisons
library(parallel)
cl &lt;- makeCluster(2)
## sequential, all combinations (2^(K-1) - 1)
system.time(opticut(Y ~ stratum + lmoist + method, data=dolina$samp,
    strata=dolina$samp$mhab, dist="zinb", comb="all", cl=NULL))
## sequential, rank based combinations (K - 1)
system.time(opticut(Y ~ stratum + lmoist + method, data=dolina$samp,
    strata=dolina$samp$mhab, dist="zinb", comb="rank", cl=NULL))
## parallel, all combinations (2^(K-1) - 1)
system.time(opticut(Y ~ stratum + lmoist + method, data=dolina$samp,
    strata=dolina$samp$mhab, dist="zinb", comb="all", cl=cl))
## parallel, rank based combinations (K - 1)
system.time(opticut(Y ~ stratum + lmoist + method, data=dolina$samp,
    strata=dolina$samp$mhab, dist="zinb", comb="rank", cl=cl))
stopCluster(cl)

## --- Customizing distributions
## we may want to expand the Zero-inflation component in a ZIP model
## see how the return value needs to be structured
fun &lt;- function(Y, X, linkinv, zi_term, ...) {
    X &lt;- as.matrix(X)
    mod &lt;- pscl::zeroinfl(Y ~ X-1 | zi_term, dist = "poisson", ...)
    list(coef=coef(mod),
        logLik=logLik(mod),
        linkinv=mod$linkinv)
}
Xdol &lt;- model.matrix(~ stratum + lmoist + method, data=dolina$samp)
## this fits the null model (i.e. no partitions added)
fun(Y[,"amin"], Xdol, zi_term=dolina$samp$method)
## now we can use dist=fun
opticut1(Y[,"amin"], Xdol, Z=dolina$samp$mhab,
    dist=fun, zi_term=dolina$samp$method)
dol2 &lt;- opticut(Y ~ stratum + lmoist + method, data=dolina$samp,
    strata=dolina$samp$mhab, dist=fun, zi_term=dolina$samp$method)
summary(dol2)

## End(Not run)

## current collapse value
getOption("ocoptions")$collapse
## factor levels sometimes need to be manipulated
## before feeding it to opticut
fix_levels(as.factor(c("A b", "C d")), sep=":")
fix_levels(as.factor(c("A b", "C d")), sep="")
</code></pre>

<hr>
<h2 id='optilevels'>
Optimal Number of Factor Levels
</h2><span id='topic+optilevels'></span><span id='topic+bestmodel.optilevels'></span>

<h3>Description</h3>

<p>Finds the optimal number of factor levels given the data and a model
using a likelihood-based agglomerative algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optilevels(y, x, z = NULL, alpha = 0, dist = "gaussian", ...)

## S3 method for class 'optilevels'
bestmodel(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optilevels_+3A_y">y</code></td>
<td>

<p>vector of observations.
</p>
</td></tr>
<tr><td><code id="optilevels_+3A_x">x</code></td>
<td>

<p>a factor or a matrix of proportions (i.e. the values 0 and 1 should have
consistent meaning across the columns, often through a unit sum constraint).
It is the user's responsibility to ensure that values supplied
for <code>x</code> are sensible. <code>x</code> is not expected to
include an intercept.
</p>
</td></tr>
<tr><td><code id="optilevels_+3A_z">z</code></td>
<td>

<p>a design matrix with predictor variables besides the one(s) defined
via the argument <code>x</code>.
It is the user's responsibility to ensure that values supplied
for <code>z</code> are sensible and it also makes sense to bind
<code>x</code> and <code>z</code> together.
Variables in <code>z</code> should be centered (mean 0) (and
possibly normalized by SD), because the design matrix
from <code>x</code> is not expected to include an intercept.
</p>
</td></tr>
<tr><td><code id="optilevels_+3A_alpha">alpha</code></td>
<td>
<p>numeric [0-1],
weighting factor for calculating information criteria for model selection
(i.e. IC = (1-alpha)*AIC + alpha*BIC, also referred to as CAIC: consistent AIC).
</p>
</td></tr>
<tr><td><code id="optilevels_+3A_dist">dist</code></td>
<td>

<p>character, distribution argument passed to underlying functions,
see listed on the help page of <code><a href="#topic+opticut">opticut</a></code>
(except for <code>dist = "zip2"</code>, <code>dist = "zinb2"</code>
<code>dist = "rsf"</code>, and <code>dist = "rspf"</code>).
</p>
</td></tr>
<tr><td><code id="optilevels_+3A_object">object</code></td>
<td>

<p>fitted object.
</p>
</td></tr>
<tr><td><code id="optilevels_+3A_...">...</code></td>
<td>

<p>other arguments passed to the underlying functions, see <code><a href="#topic+opticut1">opticut1</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'optilevels' that is a list with the following elements:
</p>

<dl>
<dt><code>"delta"</code></dt><dd><p>delta IC values along the selection path considering best models.</p>
</dd>
<dt><code>"ic"</code></dt><dd><p>IC values along the selection path considering best models.</p>
</dd>
<dt><code>"coef"</code></dt><dd><p>matrix of coefficients (linear predictor scale)
corresponding to argument <code>x</code>
along the selection path considering best models.</p>
</dd>
<dt><code>"zcoef"</code></dt><dd><p>matrix of coefficients (linear predictor scale)
corresponding to argument <code>z</code> when not <code>NULL</code>
along the selection path considering best models, or <code>NULL</code>.</p>
</dd>
<dt><code>"rank"</code></dt><dd><p>matrix ranks based on the coefficients
along the selection path considering best models.
Ranking uses the default <code>ties.method = "average"</code> in <code><a href="base.html#topic+rank">rank</a></code>.</p>
</dd>
<dt><code>"deltalist"</code></dt><dd><p>delta IC values along the selection path
considering all competing models.</p>
</dd>
<dt><code>"iclist"</code></dt><dd><p>IC values along the selection path
considering all competing models.</p>
</dd>
<dt><code>"coeflist"</code></dt><dd><p>matrix of coefficients (linear predictor scale)
corresponding to argument <code>x</code>
along the selection path considering all competing models.</p>
</dd>
<dt><code>"zcoeflist"</code></dt><dd><p>matrix of coefficients (linear predictor scale)
corresponding to argument <code>z</code> when not <code>NULL</code>
along the selection path considering all competing models, or <code>NULL</code>.</p>
</dd>
<dt><code>"ranklist"</code></dt><dd><p>matrix ranks based on the coefficients
along the selection path considering all competing models.</p>
</dd>
<dt><code>"levels"</code></dt><dd><p>list of (merged) factor levels along the selection path
considering best models.</p>
</dd>
<dt><code>"Y"</code></dt><dd><p>vector of observations (argument <code>y</code>).</p>
</dd>
<dt><code>"X"</code></dt><dd><p>design matrix component corresponding to argument <code>x</code>.</p>
</dd>
<dt><code>"Z"</code></dt><dd><p>design matrix component corresponding to argument <code>z</code>.</p>
</dd>
<dt><code>"alpha"</code></dt><dd><p>weighting argument.</p>
</dd>
<dt><code>"dist"</code></dt><dd><p>distribution argument.</p>
</dd>
<dt><code>"factor"</code></dt><dd><p>logical, indicating if argument <code>x</code> is a factor
(<code>TRUE</code>) or a matrix (<code>FALSE</code>).</p>
</dd>
</dl>

<p><code>bestmodel</code> returns the best supported model for further
manipulation (e.g. prediction).
</p>


<h3>Author(s)</h3>

<p>Peter Solymos &lt;psolymos@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+opticut">opticut</a></code> and <code><a href="#topic+multicut">multicut</a></code>
for fitting best binary and multi-level response models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## --- Factor levels with Gaussian distribution
## simple example from Legendre 2013
## Indicator Species: Computation, in
## Encyclopedia of Biodiversity, Volume 4
## https://dx.doi.org/10.1016/B978-0-12-384719-5.00430-5
gr &lt;- as.factor(paste0("X", rep(1:5, each=5)))
spp &lt;- cbind(Species1=rep(c(4,6,5,3,2), each=5),
    Species2=c(rep(c(8,4,6), each=5), 4,4,2, rep(0,7)),
    Species3=rep(c(18,2,0,0,0), each=5))
rownames(spp) &lt;- gr
## must add some noise to avoid perfect fit
spp[6, "Species1"] &lt;- 7
spp[1, "Species3"] &lt;- 17
spp

ol &lt;- optilevels(spp[,"Species3"], gr)
ol[c("delta", "coef", "rank", "levels")]

## get the final factor level
gr1 &lt;- gr
levels(gr1) &lt;- ol$level[[length(ol$level)]]
table(gr, gr1)

## compare the models
o0 &lt;- lm(spp[,"Species3"] ~ gr - 1)
o1 &lt;- lm(spp[,"Species3"] ~ gr1 - 1)
data.frame(AIC(o0, o1), delta=AIC(o0, o1)$AIC - AIC(o0))
ol$delta # should be identical

## --- Proportions with Poisson distribution
## simulation
set.seed(123)
n &lt;- 500 # number of observations
k &lt;- 5 # number of habitat types
b &lt;- c(-1, -0.2, -0.2, 0.5, 1)
names(b) &lt;- LETTERS[1:k]
x &lt;- replicate(k, exp(rnorm(n)))
x &lt;- x / rowSums(x) # proportions
X &lt;- model.matrix(~.-1, data=data.frame(x))
lam &lt;- exp(drop(crossprod(t(X), b)))
y &lt;- rpois(n, lam)

z &lt;- optilevels(y, x, dist="poisson")

## best model refit
bestmodel(z)

## estimates
plogis(z$coef)
plogis(b)
## optimal classification
z$rank

## get the final matrix
x1 &lt;- mefa4::groupSums(x, 2, z$levels[[length(z$levels)]])
head(x)
head(x1)

## compare the models
m0 &lt;- glm(y ~ x - 1, family="poisson")
m1 &lt;- glm(y ~ x1 - 1, family="poisson")
data.frame(AIC(m0, m1), delta=AIC(m0, m1)$AIC - AIC(m0))
z$delta # should be identical

## Not run: 
## dolina example with factor
data(dolina)
dolina$samp$stratum &lt;- as.integer(dolina$samp$stratum)
y &lt;- dolina$xtab[dolina$samp$method == "Q", "ppyg"]
x &lt;- dolina$samp$mhab[dolina$samp$method == "Q"]
z &lt;- scale(model.matrix(~ stratum + lmoist - 1,
    dolina$samp[dolina$samp$method == "Q",]))

## without additional covariates
dol1 &lt;- optilevels(y, x, z=NULL, dist="poisson")
dol1$rank
summary(bestmodel(dol1))

## with additional covariates
dol2 &lt;- optilevels(y, x, z, dist="poisson")
dol2$rank
summary(bestmodel(dol2))

## compare the two models
AIC(bestmodel(dol1), bestmodel(dol2))

## End(Not run)
</code></pre>

<hr>
<h2 id='rankComb'>
Ranking Based Binary Partitions
</h2><span id='topic+rankComb'></span><span id='topic+oComb'></span>

<h3>Description</h3>

<p>Blindly fitting a model to all possible partitions is wasteful
use of resources. Instead, one can rank the K levels (strata)
based on expected response values
to explore only K-1 binary partitions along the gradient
defined by the ranks of the expected values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oComb(x, collapse)
rankComb(Y, X, Z, dist = "gaussian", collapse, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rankComb_+3A_y">Y</code></td>
<td>

<p>numeric, vector of observations.
</p>
</td></tr>
<tr><td><code id="rankComb_+3A_x">X</code></td>
<td>

<p>numeric, design matrix.
</p>
</td></tr>
<tr><td><code id="rankComb_+3A_z">Z</code></td>
<td>

<p>factor, must have at least 2 unique levels.
</p>
</td></tr>
<tr><td><code id="rankComb_+3A_dist">dist</code></td>
<td>

<p>character, distribution argument passed to underlying functions,
see listed on the help page of <code><a href="#topic+opticut">opticut</a></code>.
</p>
</td></tr>
<tr><td><code id="rankComb_+3A_x">x</code></td>
<td>

<p>and a numeric vector.
</p>
</td></tr>
<tr><td><code id="rankComb_+3A_collapse">collapse</code></td>
<td>

<p>character, what to paste between levels.
Defaults to <code>getOption("ocoptions")$collapse</code>.
</p>
</td></tr>
<tr><td><code id="rankComb_+3A_...">...</code></td>
<td>

<p>other arguments passed to the underlying functions, see <code><a href="#topic+opticut">opticut</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>oComb</code> returns the 'contrast' matrix based on the rank vector as input.
Ranked from lowest to highest expected value among the partitions.
</p>
<p>The function <code>rankComb</code> fits the model with multiple (K &gt; 2) factor levels
to find out the ranking, and returns a binary classification matrix
as returned by <code>oComb</code> corresponding to the ranking.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos &lt;psolymos@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+allComb">allComb</a></code> for alternative partitioning algorithm.
</p>
<p><code><a href="#topic+opticut">opticut</a></code> for the user interface.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simulate some data
set.seed(1234)
n &lt;- 200
x0 &lt;- sample(1:4, n, TRUE)
x1 &lt;- ifelse(x0 %in% 1:2, 1, 0)
x2 &lt;- rnorm(n, 0.5, 1)
lam &lt;- exp(0.5 + 0.5*x1 + -0.2*x2)
Y &lt;- rpois(n, lam)

## binary partitions
head(rc &lt;- rankComb(Y, model.matrix(~x2), as.factor(x0), dist="poisson"))
attr(rc, "est") # expected values in factor levels
aggregate(exp(0.5 + 0.5*x1), list(x0=x0), mean) # true values

## simple example
oComb(1:4, "+")
## using estimates
oComb(attr(rc, "est"))
</code></pre>

<hr>
<h2 id='uncertainty'>
Quantifying Uncertainty for Fitted Objects
</h2><span id='topic+uncertainty'></span><span id='topic+uncertainty.opticut'></span><span id='topic+uncertainty.multicut'></span><span id='topic+print.uncertainty1'></span><span id='topic+print.uncertainty'></span><span id='topic+print.summary.uncertainty'></span><span id='topic+summary.uncertainty'></span><span id='topic+strata.uncertainty'></span><span id='topic+bestpart.uncertainty'></span><span id='topic+bestpart.uncertainty1'></span><span id='topic+check_strata'></span><span id='topic+as.data.frame.uncertainty'></span><span id='topic+as.data.frame.summary.uncertainty'></span><span id='topic+bsmooth'></span><span id='topic+bsmooth.uncertainty1'></span><span id='topic+bsmooth.uncertainty'></span><span id='topic+subset.uncertainty'></span>

<h3>Description</h3>

<p>Quantifying uncertainty for fitted objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uncertainty(object, ...)
## S3 method for class 'opticut'
uncertainty(object,
    which = NULL, type = c("asymp", "boot", "multi"),
    B = 99, cl = NULL, ...)
## S3 method for class 'multicut'
uncertainty(object,
    which = NULL, type = c("asymp", "boot"),
    B = 99, cl = NULL, ...)

check_strata(x, mat)
## S3 method for class 'uncertainty'
strata(object, ...)
## S3 method for class 'uncertainty'
subset(x, subset=NULL, ...)

## S3 method for class 'uncertainty'
bestpart(object, ...)
## S3 method for class 'uncertainty1'
bestpart(object, ...)

## S3 method for class 'uncertainty1'
print(x, ...)
## S3 method for class 'uncertainty'
print(x, ...)
## S3 method for class 'summary.uncertainty'
print(x, sort, digits, ...)
## S3 method for class 'uncertainty'
summary(object, level = 0.95, ...)

## S3 method for class 'uncertainty'
as.data.frame(x,
    row.names = NULL, optional = FALSE, sort, ...)
## S3 method for class 'summary.uncertainty'
as.data.frame(x,
    row.names = NULL, optional = FALSE, sort, ...)

## S3 method for class 'uncertainty1'
bsmooth(object, ...)
## S3 method for class 'uncertainty'
bsmooth(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uncertainty_+3A_object">object</code></td>
<td>

<p>fitted model object
(which should not contain extra arguments as part of <code>...</code>),
or an output from <code>uncertainty</code> for the <code>summary</code> method.
</p>
</td></tr>
<tr><td><code id="uncertainty_+3A_which">which</code></td>
<td>

<p>numeric or character (can be a vector) defining
a subset of species from the fitted object,
or or <code>NULL</code> (all species, default).
</p>
</td></tr>
<tr><td><code id="uncertainty_+3A_type">type</code></td>
<td>

<p>character, describing the type of uncertainty calculation.
See Details.
</p>
</td></tr>
<tr><td><code id="uncertainty_+3A_b">B</code></td>
<td>

<p>numeric, number of iterations. For <code>type = "boot"</code> and
<code>type = "multi"</code> it can be a user-supplied matrix with indices for
resampling with dimensions length of observations times B.
</p>
</td></tr>
<tr><td><code id="uncertainty_+3A_cl">cl</code></td>
<td>

<p>a cluster object, or an integer for multiple cores in parallel computations
(integer value for forking is ignored on Windows).
</p>
</td></tr>
<tr><td><code id="uncertainty_+3A_x">x</code></td>
<td>

<p>an object to be printed.
</p>
</td></tr>
<tr><td><code id="uncertainty_+3A_level">level</code></td>
<td>

<p>the confidence level required.
</p>
</td></tr>
<tr><td><code id="uncertainty_+3A_sort">sort</code></td>
<td>

<p>logical value indicating if species
should be meaningfully sorted, the default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="uncertainty_+3A_digits">digits</code></td>
<td>

<p>numeric, number of significant digits in output.
</p>
</td></tr>
<tr><td><code id="uncertainty_+3A_mat">mat</code></td>
<td>

<p>a matrix with resampling indices (rows as samples, columns as iterations).
</p>
</td></tr>
<tr><td><code id="uncertainty_+3A_row.names">row.names</code></td>
<td>

<p><code>NULL</code> or a character vector giving the row names for the data frame.
Missing values are not allowed. See <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>.
</p>
</td></tr>
<tr><td><code id="uncertainty_+3A_optional">optional</code></td>
<td>

<p>logical. If <code>TRUE</code>, setting row names and converting column names
(to syntactic names: see <code><a href="base.html#topic+make.names">make.names</a></code>) is optional.
See <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>.
</p>
</td></tr>
<tr><td><code id="uncertainty_+3A_subset">subset</code></td>
<td>

<p>logical, numeric, or character index indicating species to keep,
missing values are not accepted.
</p>
</td></tr>
<tr><td><code id="uncertainty_+3A_...">...</code></td>
<td>

<p>other arguments passed to the underlying functions.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uncertainty is calculated for
indicator potential <code>I</code>, and expected values
(<code>mu0</code>, and <code>mu1</code> for opticut, and <code>mu_*</code> for multicut objects).
</p>
<p><code>"asymp"</code>: asymptotic distribution is based on best supported model
(this option is unavailable for custom distribution functions because
it requires the Hessian matrix).
This type is available for both opticut and multicut objects.
</p>
<p><code>"boot"</code>: non-parametric bootstrap distribution
based on best partition found for the input object.
This type is available for both opticut and multicut objects.
</p>
<p><code>"multi"</code>: non-parametric bootstrap distribution
based on best partition found for the bootstrap data (i.e.
the model ranking is re-evaluated each time).
<code>"multi"</code> works only if <code>comb = "rank"</code> in the
<code><a href="#topic+opticut">opticut</a></code> call.
This type is not available for multicut objects.
</p>


<h3>Value</h3>

<p><code>uncertainty</code> returns an object of class 'uncertainty'.
The <code>uncertainty</code> element of the object is a list with species specific
output as elements (object class 'uncertainty1').
Each 'uncertainty1' output is a data frame with columns:
<code>best</code> partition, indicator potential <code>I</code>,
and expected values
(<code>mu0</code>, and <code>mu1</code> for opticut, and <code>mu_*</code> for multicut objects).
</p>
<p><code>check_strata</code> returns a logical vector checking if
all original strata from the input object are represented
by resampling indices. Number of strata are attached as attributes
for further diagnostics.
</p>
<p>The summary method prints the name of the best supported split,
selection frequency (R, reliability), indicator values (I, based on
the distribution of values within the best supported split with highest
reliability) and confidence interval for I (based on <code>level</code>).
</p>
<p>The <code>subset</code> method subsets the species in the uncertainty object.
</p>
<p><code><a href="#topic+bestpart">bestpart</a></code> finds the selection frequencies for
strata as best partitions (number of strata x number of species).
</p>
<p>The coercion method <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> returns a data frame.
</p>
<p>The <code>bsmooth</code> method returns bootstrap smoothed results
for each strata (not available for multicut based uncertainty objects,
check uncertainty results instead).
</p>


<h3>Warning</h3>

<p>Resampling methods can lead to complete exclusion of certain strata
when sample size is small. Try revising the stratification of the
input object, or provide custom resampling indices via the <code>B</code>
argument using stratified (block) bootstrap, jackknife (leave-one-out),
or similar techniques. Finding a suitable random seed
via <code><a href="base.html#topic+set.seed">set.seed</a></code> or dropping unsuitable iterations
can also resolve the issue.
</p>


<h3>Author(s)</h3>

<p>Peter Solymos &lt;psolymos@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+opticut">opticut</a></code> and <code><a href="#topic+multicut">multicut</a></code> for the
user interface of the input objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2345)
n &lt;- 50
x0 &lt;- sample(1:4, n, TRUE)
x1 &lt;- ifelse(x0 %in% 1:2, 1, 0)
x2 &lt;- rnorm(n, 0.5, 1)
x3 &lt;- ifelse(x0 %in% 2:4, 1, 0)
lam1 &lt;- exp(0.5 + 1*x1 + -0.2*x2)
Y1 &lt;- rpois(n, lam1)
lam2 &lt;- exp(1 + 0.5*x3)
Y2 &lt;- rpois(n, lam2)
Y3 &lt;- rpois(n, exp(0))
Y &lt;- cbind(Spp1=Y1, Spp2=Y2, Spp3=Y3)

oc &lt;- opticut(Y ~ x2, strata=x0, dist="poisson", comb="rank")

## asymptotic confidence intervals
(uc1 &lt;- uncertainty(oc, type="asymp", B=999))
summary(uc1)
## bootstrap-based confidence intervals
(uc2 &lt;- uncertainty(oc, type="boot", B=19))
summary(uc2)

## use user-supplied indices
## multi-model bootstrap based uncertainties
B &lt;- replicate(25, sample.int(n, replace=TRUE))
check_strata(oc, B) # check representation
(uc3 &lt;- uncertainty(oc, type="multi", B=B))
summary(uc3)

## best partitions:
## selection frequencies for strata and species
bestpart(uc3)
heatmap(bestpart(uc3), scale="none", col=occolors()(25))

## bootstrap smoothed predictions per strata
bsmooth(uc3)
heatmap(bestpart(uc3), scale="none", col=occolors()(25))

## individual species results
uc3$uncertainty
bestpart(uc3$uncertainty[[1]])
bsmooth(uc3$uncertainty[[1]])

## Not run: 
## block bootstrap
block_fun &lt;- function()
    unlist(lapply(unique(x0), function(z) if (sum(x0==z) &lt; 2)
        which(x0==z) else sample(which(x0==z), sum(x0==z), replace=TRUE)))
B &lt;- replicate(25, block_fun())
check_strata(oc, B) # check representation
summary(uncertainty(oc, type="multi", B=B))

## jackknife
B &lt;- sapply(1:n, function(i) which((1:n) != i))
check_strata(oc, B) # check representation
summary(uncertainty(oc, type="multi", B=B))

## multicut based uncertainty
mc &lt;- multicut(Y ~ x2, strata=x0, dist="poisson")

## asymptotic confidence intervals
(muc1 &lt;- uncertainty(mc, type="asymp", B=999))
summary(muc1)
bestpart(muc1)

## bootstrap-based confidence intervals
(muc2 &lt;- uncertainty(mc, type="boot", B=19))
summary(muc2)
bestpart(muc2)

## dolina example
data(dolina)
## stratum as ordinal
dolina$samp$stratum &lt;- as.integer(dolina$samp$stratum)
## filter species to speed up things a bit
Y &lt;- ifelse(dolina$xtab[,colSums(dolina$xtab &gt; 0) &gt;= 20] &gt; 0, 1, 0)
## opticut results, note the cloglog link function
dol &lt;- opticut(Y ~ stratum + lmoist + method, data=dolina$samp,
    strata=dolina$samp$mhab, dist="binomial:cloglog")

## parallel computing for uncertainty
library(parallel)
cl &lt;- makeCluster(2)
ucdol &lt;- uncertainty(dol, type="multi", B=25, cl=cl)
stopCluster(cl)

bestpart(ucdol)
heatmap(t(bestpart(ucdol)), scale="none", col=occolors()(25),
    distfun=function(x) dist(x, "manhattan"))

## See how indicator value changes with different partitions
## (and why it is the wrong metric to use in this calse)
with(ucdol$uncertainty[["pvic"]],
    boxplot(I ~ best, col="gold", ylab="Indicator value"))
## What we should calculate is the bootstrap smoothed mean of the
## expected value and its confidence intervals
bs &lt;- bsmooth(ucdol$uncertainty[["pvic"]])
boxplot(t(bs), ylab="Expected value")
cbind(Mean=rowMeans(bs), t(apply(bs, 1, quantile, probs=c(0.025, 0.975))))

## A more interesting simulated example for bootstrap smoothing
## and comparing opticut vs. multicut
set.seed(1)
n &lt;- 2000
x &lt;- sort(runif(n, -8, 8))
p &lt;- plogis(0.5 + -0.1 * x + -0.2 * x^2)
y &lt;- rbinom(n, 1, p)
d &lt;- diff(range(x))/10
br &lt;- seq(min(x), max(x), by=d)
g &lt;- cut(x, br, include.lowest=TRUE)
levels(g) &lt;- LETTERS[1:nlevels(g)]
o &lt;- opticut(y ~ 1, strata=g, dist="binomial")
m &lt;- multicut(y ~ 1, strata=g, dist="binomial")
library(parallel)
cl &lt;- makeCluster(2)
uo &lt;- uncertainty(o, type="multi", B=99, cl=cl)
um &lt;- uncertainty(m, type="boot", B=99, cl=cl)
stopCluster(cl)
## bootstrap average for opticut
bs &lt;- bsmooth(uo$uncertainty[[1]])
stat &lt;- cbind(Mean=rowMeans(bs),
    t(apply(bs, 1, quantile, probs=c(0.025, 0.975))))
## bootstrap average for multicut
bsm &lt;- as.matrix(um$uncertainty[[1]][,-(1:2)])
statm &lt;- cbind(Mean=colMeans(bsm),
    t(apply(bsm, 2, quantile, probs=c(0.025, 0.975))))

op &lt;- par(mfrow=c(2,1))
plot(p ~ x, type="l", ylim=c(0,1), main="Binary partitions (opticut)")
abline(v=br, col="grey", lty=3)
lines(br[-1]-0.5*d, stat[,1], col=4)
lines(br[-1]-0.5*d, stat[,2], col=4, lty=2)
lines(br[-1]-0.5*d, stat[,3], col=4, lty=2)
lines(br[-1]-0.5*d, bs[,1], col=2)
legend("topright", bty="n", lty=c(1,1,2,1), col=c(1,4,4,2),
    legend=c("True response","bsmooth","0.95 CI","Best partition"))

plot(p ~ x, type="l", ylim=c(0,1), main="Multi-level model (multicut)")
abline(v=br, col="grey", lty=3)
lines(br[-1]-0.5*d, statm[,1], col=4)
lines(br[-1]-0.5*d, statm[,2], col=4, lty=2)
lines(br[-1]-0.5*d, statm[,3], col=4, lty=2)
legend("topright", bty="n", lty=c(1,1,2), col=c(1,4,4),
    legend=c("True response","bsmooth","0.95 CI"))
par(op)

## End(Not run)
</code></pre>

<hr>
<h2 id='warblers'>
Warblers Data Set
</h2><span id='topic+warblers'></span>

<h3>Description</h3>

<p>Five species of warblers were studied to determine the factors
controlling the species abundances and competition (MacArthur 1958).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("warblers")</code></pre>


<h3>Format</h3>

<p>A list with 3 elements: <code>xtab</code> is a list of sample x species matrices
(<code>sec_prc</code>: percentages of total number of seconds of observations,
<code>num_prc</code>: percentages of total number of observations in seconds,
<code>sec_cnt</code>: counts based on percentages and totals of seconds,
<code>num_cnt</code>: counts based on percentages and totals),
<code>samp</code> is a data frame with sample level attributes such as height
(6 is the base, 1 is the top of trees, most trees were 50&ndash;60 feet tall)
and depth of branches in the canopy
(B: bare or lichen- covered base, M: middle zone of old needles,
T: terminal zone of new, less than 1.5 years old, needles or buds) ,
<code>taxa</code> is a data frame with scientific and common names for the species.
</p>


<h3>Source</h3>

<p>MacArthur 1958.
</p>


<h3>References</h3>

<p>MacArthur, R. H., 1958.
Population ecology of some warblers of northeastern coniferous forests.
Ecology 39:599&ndash;619.
&lt;doi:10.2307/1931600&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(warblers)
str(warblers)

warbh &lt;- mefa4::groupSums(warblers$xtab$num_cnt, 1, warblers$samp$height)
warbd &lt;- mefa4::groupSums(warblers$xtab$num_cnt, 1, warblers$samp$depth)
op &lt;- par(mfrow=c(1,2))
matplot(rownames(warbh), warbh, type="b", xlab="height")
matplot(warbd, type="b", axes=FALSE, xlab="depth")
box()
axis(2)
axis(1, 1:3, rownames(warbd))
par(op)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
