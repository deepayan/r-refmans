<!DOCTYPE html><html><head><title>Help for package ginormal</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ginormal}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dgin'><p>Density for the generalized inverse normal distribution</p></a></li>
<li><a href='#dtgin'><p>Density for the generalized inverse normal distribution truncated to the positive or negative reals</p></a></li>
<li><a href='#rgin'><p>Generating random numbers from the generalized inverse normal distribution</p></a></li>
<li><a href='#rtgin'><p>Generating random numbers from the generalized inverse normal distribution truncated to the positive or negative reals</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Generalized Inverse Normal Distribution Density and Generation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Density function and generation of random variables from the Generalized Inverse Normal (GIN) distribution from Robert (1991) &lt;<a href="https://doi.org/10.1016%2F0167-7152%2891%2990174-P">doi:10.1016/0167-7152(91)90174-P</a>&gt;. Also provides density functions and generation from the GIN distribution truncated to positive or negative reals. Theoretical guarantees supporting the sampling algorithms and an application to Bayesian estimation of network formation models can be found in the working paper Ding, Estrada and Montoya-Blandón (2023) <a href="https://www.smontoyablandon.com/publication/networks/network_externalities.pdf">https://www.smontoyablandon.com/publication/networks/network_externalities.pdf</a>.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/smonto2/ginormal">https://github.com/smonto2/ginormal</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/smonto2/ginormal/issues">https://github.com/smonto2/ginormal/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>BAS</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-27 18:11:33 UTC; smb32q</td>
</tr>
<tr>
<td>Author:</td>
<td>Santiago Montoya-Blandón
    <a href="https://orcid.org/0000-0003-2229-2254"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre, aut],
  Cheng Ding [aut],
  Juan Estrada <a href="https://orcid.org/0000-0003-0070-7586"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Zhilang Xia [aut],
  Shanjie Zhang [ctb],
  Jianming Jin [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Santiago Montoya-Blandón &lt;Santiago.Montoya-Blandon@glasgow.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-27 22:40:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='dgin'>Density for the generalized inverse normal distribution</h2><span id='topic+dgin'></span>

<h3>Description</h3>

<p>Density for the generalized inverse normal distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgin(z, alpha, mu, tau, log = TRUE, quasi = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dgin_+3A_z">z</code></td>
<td>
<p>quantile.</p>
</td></tr>
<tr><td><code id="dgin_+3A_alpha">alpha</code></td>
<td>
<p>degrees-of-freedom parameter.</p>
</td></tr>
<tr><td><code id="dgin_+3A_mu">mu</code></td>
<td>
<p>similar to location parameter, controls asymmetry of the distribution.</p>
</td></tr>
<tr><td><code id="dgin_+3A_tau">tau</code></td>
<td>
<p>similar to scale parameter, controls spread of the distribution.</p>
</td></tr>
<tr><td><code id="dgin_+3A_log">log</code></td>
<td>
<p>logical; should the log of the density be returned? Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="dgin_+3A_quasi">quasi</code></td>
<td>
<p>logical; should the quasi-density value be returned? Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, only scalars are supported for the quantile and parameter values.
Density is supported on the entire real line, <code>z</code> and <code>mu</code> can take any value
in <code class="reqn">(-\infty, \infty)</code>. Density is only defined for parameter values
<code>alpha</code> &gt; 1 or <code>tau</code> &gt; 0, so it is set to 0 outside of these values.
The quasi-density or kernel is the density without the normalization constant,
use <code>quasi = TRUE</code> for this behavior.
</p>


<h3>Value</h3>

<p>Numeric scalar with density.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Computing (log) density
dgin(z = 1, alpha = 3, mu = 1, tau = 1, log = TRUE, quasi = FALSE)

# Generalized inverse normal density with alpha = 5, mu = 0, tau = 1
z_vals &lt;- seq(-5, 5, length.out = 200)
fz_unc &lt;- sapply(z_vals, function(z) dgin(z, 5, 0, 1, FALSE))
plot(z_vals, fz_unc, type = "l", xlab = 'Values', ylab = 'Density')
</code></pre>

<hr>
<h2 id='dtgin'>Density for the generalized inverse normal distribution truncated to the positive or negative reals</h2><span id='topic+dtgin'></span>

<h3>Description</h3>

<p>Density for the generalized inverse normal distribution truncated to the positive or negative reals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtgin(
  z,
  alpha,
  mu,
  tau,
  sign = TRUE,
  log = TRUE,
  quasi = FALSE,
  method = "Fortran"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dtgin_+3A_z">z</code></td>
<td>
<p>quantile.</p>
</td></tr>
<tr><td><code id="dtgin_+3A_alpha">alpha</code></td>
<td>
<p>degrees-of-freedom parameter.</p>
</td></tr>
<tr><td><code id="dtgin_+3A_mu">mu</code></td>
<td>
<p>similar to location parameter, controls asymmetry of the distribution.</p>
</td></tr>
<tr><td><code id="dtgin_+3A_tau">tau</code></td>
<td>
<p>similar to scale parameter, controls spread of the distribution.</p>
</td></tr>
<tr><td><code id="dtgin_+3A_sign">sign</code></td>
<td>
<p>logical. <code>TRUE</code> implies truncation to positive numbers (<code>z</code> &gt; 0)
and <code>FALSE</code> to negative numbers (<code>z</code> &lt; 0).</p>
</td></tr>
<tr><td><code id="dtgin_+3A_log">log</code></td>
<td>
<p>logical; should the log of the density be returned? Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="dtgin_+3A_quasi">quasi</code></td>
<td>
<p>logical; should the quasi-density value be returned? Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="dtgin_+3A_method">method</code></td>
<td>
<p>string with the method used to compute the parabolic cylinder function
in the normalization constant. <code>method = "Fortran"</code> uses a compiled Fortran version,
which is the default. <code>method = "R"</code> uses an R translation of this function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, only scalars are supported for the quantile and parameter values.
Density is supported on the positive reals (<code>z</code> &gt; 0) when <code>sign = TRUE</code> and to
negative reals (<code>z</code> &lt; 0) when <code>sign = FALSE</code>. <code>mu</code> can take any value
in <code class="reqn">(-\infty, \infty)</code>. Density is only defined for parameter values
<code>alpha</code> &gt; 1 or <code>tau</code> &gt; 0, so it is set to 0 outside of these values.
The quasi-density or kernel is the density without the normalization constant,
use <code>quasi = TRUE</code> for this behavior.
</p>


<h3>Value</h3>

<p>Numeric scalar with density.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Computing (log) truncated densities
dtgin(z = 1, alpha = 3, mu = 1, tau = 1, sign = TRUE, log = TRUE, quasi = FALSE)
dtgin(z = -1, alpha = 3, mu = -1, tau = 1, sign = FALSE, log = TRUE, quasi = FALSE)

# Generalized inverse normal density with alpha = 5, mu = 0, tau = 1
n_values &lt;- 200
z_vals &lt;- seq(-5, 5, length.out = n_values)

# Truncated to positive reals (z &gt; 0)
fz_p &lt;- sapply(z_vals[z_vals &gt; 0], function(z) dtgin(z, 5, 0, 1, TRUE, FALSE))
fz_p &lt;- c(rep(0, n_values - sum(z_vals &gt; 0)), fz_p)
plot(z_vals, fz_p, type = "l", xlab = 'Values', ylab = 'Density')

# Truncated to positive reals (z &lt; 0)
fz_n &lt;- sapply(z_vals[z_vals &lt; 0], function(z) dtgin(z, 5, 0, 1, FALSE, FALSE))
fz_n &lt;- c(fz_n, rep(0, n_values - sum(z_vals &lt; 0)))
plot(z_vals, fz_n, type = "l", xlab = 'Values', ylab = 'Density')

# Both truncated densities together
plot(z_vals, fz_p, type = "l", xlab = 'Values', ylab = 'Density')
lines(z_vals, fz_n, col = 'blue', lty = 2)
legend('topright', legend = c('z &gt; 0', 'z &lt; 0'),
       col = c('black', 'blue'), lty = 1:2)
</code></pre>

<hr>
<h2 id='rgin'>Generating random numbers from the generalized inverse normal distribution</h2><span id='topic+rgin'></span>

<h3>Description</h3>

<p>Generating random numbers from the generalized inverse normal distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgin(size, alpha, mu, tau, algo = "hormann", method = "Fortran")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rgin_+3A_size">size</code></td>
<td>
<p>number of desired draws. Output is numpy vector of length equal to size.</p>
</td></tr>
<tr><td><code id="rgin_+3A_alpha">alpha</code></td>
<td>
<p>degrees-of-freedom parameter.</p>
</td></tr>
<tr><td><code id="rgin_+3A_mu">mu</code></td>
<td>
<p>similar to location parameter, controls asymmetry of the distribution.</p>
</td></tr>
<tr><td><code id="rgin_+3A_tau">tau</code></td>
<td>
<p>similar to scale parameter, controls spread of the distribution.</p>
</td></tr>
<tr><td><code id="rgin_+3A_algo">algo</code></td>
<td>
<p>string with desired algorithm to compute minimal bounding rectangle.
If &quot;hormann&quot;, use the method from Hörmann and Leydold (2014). When &quot;leydold&quot;, use the one from Leydold (2001).
Defaults to &quot;hormann&quot; and returns an error for any other values.</p>
</td></tr>
<tr><td><code id="rgin_+3A_method">method</code></td>
<td>
<p>string with the method used to compute the parabolic cylinder function
in the normalization constant. <code>method = "Fortran"</code> uses a compiled Fortran version,
which is the default. <code>method = "R"</code> uses an R translation of this function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, only values of <code>alpha</code> &gt; 2 are supported. For Bayesian posterior sampling,
<code>alpha</code> is always larger than 2 even for non-informative priors. The algorithm requires
calculating the probability of truncation region (either <code>z</code> &lt; 0 or <code>z</code> &gt; 0).
It is more stable to compute a probability bounded away from 0. As <code>mu</code> controls asymmetry,
when <code>mu</code> &gt; 0, P(truncation region) = P(<code>z</code> &gt; 0) &gt;= 50%, and this probability is computed.
If <code>mu</code> &lt; 0, P(<code>z</code> &lt; 0) &gt;= 50% and this region's probability is used.
</p>


<h3>Value</h3>

<p>Numeric vector of length <code>size</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate 1000 values from the distribution with alpha = 5, mu = 0, tau = 1
set.seed(123456)
z_unc &lt;- rgin(1000, 5, 0, 1)

# Compare histogram to true density
z_vals &lt;- seq(-5, 5, length.out = 200)
fz_unc &lt;- sapply(z_vals, function(z) dgin(z, 5, 0, 1, FALSE))
temp &lt;- hist(z_unc, breaks = 200, plot = FALSE)
plot(temp, freq = FALSE, xlim = c(-5, 5), ylim = range(c(fz_unc, temp$density)),
     main = '', xlab = 'Values', ylab = 'Density', col = 'blue')
lines(z_vals, fz_unc, col = 'red', lwd = 2)
</code></pre>

<hr>
<h2 id='rtgin'>Generating random numbers from the generalized inverse normal distribution truncated to the positive or negative reals</h2><span id='topic+rtgin'></span>

<h3>Description</h3>

<p>Generating random numbers from the generalized inverse normal distribution truncated to the positive or negative reals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rtgin(
  size,
  alpha,
  mu,
  tau,
  sign,
  algo = "hormann",
  method = "Fortran",
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rtgin_+3A_size">size</code></td>
<td>
<p>number of desired draws. Output is numpy vector of length equal to size.</p>
</td></tr>
<tr><td><code id="rtgin_+3A_alpha">alpha</code></td>
<td>
<p>degrees-of-freedom parameter.</p>
</td></tr>
<tr><td><code id="rtgin_+3A_mu">mu</code></td>
<td>
<p>similar to location parameter, controls asymmetry of the distribution.</p>
</td></tr>
<tr><td><code id="rtgin_+3A_tau">tau</code></td>
<td>
<p>similar to scale parameter, controls spread of the distribution.</p>
</td></tr>
<tr><td><code id="rtgin_+3A_sign">sign</code></td>
<td>
<p>logical. <code>TRUE</code> implies truncation to positive numbers (<code>z</code> &gt; 0)
and <code>FALSE</code> to negative numbers (<code>z</code> &lt; 0).</p>
</td></tr>
<tr><td><code id="rtgin_+3A_algo">algo</code></td>
<td>
<p>string with desired algorithm to compute minimal bounding rectangle.
If &quot;hormann&quot;, use the method from Hörmann and Leydold (2014). When &quot;leydold&quot;, use the one from Leydold (2001).
Defaults to &quot;hormann&quot; and returns an error for any other values.</p>
</td></tr>
<tr><td><code id="rtgin_+3A_method">method</code></td>
<td>
<p>string with the method used to compute the parabolic cylinder function
in the normalization constant. <code>method = "Fortran"</code> uses a compiled Fortran version,
which is the default. <code>method = "R"</code> uses an R translation of this function.</p>
</td></tr>
<tr><td><code id="rtgin_+3A_verbose">verbose</code></td>
<td>
<p>logical; should the acceptance rate from the ratio-of-uniforms
method be provided along with additional information? Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, only values of <code>alpha</code> &gt; 2 are supported. For Bayesian posterior sampling,
<code>alpha</code> is always larger than 2 even for non-informative priors.
Generate from positive region (<code>z</code> &gt; 0) hen <code>sign = TRUE</code>, and from
negative region (<code>z</code> &lt; 0) when <code>sign = FALSE</code>. When <code>verbose = TRUE</code>,
a list is returned containing the actual draw in <code>value</code>, as well as average
acceptance rate <code>avg_arate</code> and total number of acceptance-rejection steps <code>ARiters</code>.
</p>


<h3>Value</h3>

<p>If <code>verbose = FALSE</code> (default), a numeric vector of length <code>size</code>.
Otherwise, a list with components <code>value</code>, <code>avg_arate</code>, and <code>ARiters</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate 1000 values from the truncated distributions with alpha = 5, mu = 0, tau = 1
set.seed(123456)
n_draws &lt;- 1000
z_p &lt;- rtgin(n_draws, 5, 0, 1, TRUE)
z_n &lt;- rtgin(n_draws, 5, 0, 1, FALSE)

# Compare generation from truncation to positive reals with true density
n_values &lt;- 200
z_vals &lt;- seq(-5, 5, length.out = n_values)
fz_p &lt;- sapply(z_vals[z_vals &gt; 0], function(z) dtgin(z, 5, 0, 1, TRUE, FALSE))
fz_p &lt;- c(rep(0, n_values - sum(z_vals &gt; 0)), fz_p)
temp &lt;- hist(z_p, breaks = 100, plot = FALSE)
plot(temp, freq = FALSE, xlim = c(-5, 5), ylim = range(c(fz_p, temp$density)),
     main = '', xlab = 'Values', ylab = 'Density', col = 'blue')
lines(z_vals, fz_p, col = 'red', lwd = 2)

# Compare generation from truncation to negative reals with true density
fz_n &lt;- sapply(z_vals[z_vals &lt; 0], function(z) dtgin(z, 5, 0, 1, FALSE, FALSE))
fz_n &lt;- c(fz_n, rep(0, n_values - sum(z_vals &lt; 0)))
temp &lt;- hist(z_n, breaks = 100, plot = FALSE)
plot(temp, freq = FALSE, xlim = c(-5, 5), ylim = range(c(fz_n, temp$density)),
     main = '', xlab = 'Values', ylab = 'Density', col = 'blue')
lines(z_vals, fz_n, col = 'red', lwd = 2)

# verbose = TRUE provides info on the acceptance rate of the
# ratio-of-uniforms acceptance-rejection method for sampling the variables
draw_list &lt;- rtgin(50, 5, 0, 1, sign = TRUE, verbose = TRUE)
draw_list$ARiters      # Acceptance-Rejection iterations
draw_list$avg_arate    # Average of 1/ARiters
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
