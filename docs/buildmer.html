<!DOCTYPE html><html><head><title>Help for package buildmer</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {buildmer}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#buildmer-package'><p>Construct and fit as complete a model as possible and perform stepwise elimination</p></a></li>
<li><a href='#add.terms'><p>Add terms to a formula</p></a></li>
<li><a href='#build.formula'><p>Convert a buildmer term list into a proper model formula</p></a></li>
<li><a href='#buildbam'><p>Use <code>buildmer</code> to fit big generalized additive models using <code>bam</code> from package <code>mgcv</code></p></a></li>
<li><a href='#buildclmm'><p>Use <code>buildmer</code> to fit cumulative link mixed models using <code>clmm</code> from package <code>ordinal</code></p></a></li>
<li><a href='#buildcustom'><p>Use <code>buildmer</code> to perform stepwise elimination using a custom fitting function</p></a></li>
<li><a href='#buildgam'><p>Use <code>buildmer</code> to fit generalized additive models using <code>gam</code> from package <code>mgcv</code></p></a></li>
<li><a href='#buildgamm'><p>Use <code>buildmer</code> to fit big generalized additive models using <code>gamm</code> from package <code>mgcv</code></p></a></li>
<li><a href='#buildgamm4'><p>Use <code>buildmer</code> to fit generalized additive models using package <code>gamm4</code></p></a></li>
<li><a href='#buildGLMMadaptive'><p>Use <code>buildmer</code> to fit generalized linear mixed models using <code>mixed_model</code> from package <code>GLMMadaptive</code></p></a></li>
<li><a href='#buildglmmTMB'><p>Use <code>buildmer</code> to perform stepwise elimination on <code>glmmTMB</code> models</p></a></li>
<li><a href='#buildgls'><p>Use <code>buildmer</code> to fit generalized-least-squares models using <code>gls</code> from <code>nlme</code></p></a></li>
<li><a href='#buildlme'><p>Use <code>buildmer</code> to perform stepwise elimination of mixed-effects models fit via <code>lme</code> from <code>nlme</code></p></a></li>
<li><a href='#buildmer'><p>Use <code>buildmer</code> to fit mixed-effects models using <code>lmer</code>/<code>glmer</code> from <code>lme4</code></p></a></li>
<li><a href='#buildmer-class'><p>The buildmer class</p></a></li>
<li><a href='#buildmer.nb'><p>Use <code>buildmer</code> to fit negative-binomial models using <code>glm.nb</code> and <code>glmer.nb</code></p></a></li>
<li><a href='#buildmerControl'><p>Set control options for buildmer</p></a></li>
<li><a href='#buildmertree'><p>Use <code>buildmer</code> to perform stepwise elimination for <code>lmertree</code> and <code>glmertree</code> models from package <code>glmertree</code></p></a></li>
<li><a href='#buildmultinom'><p>Use <code>buildmer</code> to perform stepwise elimination for <code>multinom</code> models from package <code>nnet</code></p></a></li>
<li><a href='#converged'><p>Test a model for convergence</p></a></li>
<li><a href='#diag,formula-method'><p>Diagonalize the random-effect covariance structure, possibly assisting convergence</p></a></li>
<li><a href='#LRTalpha'><p>Generate an LRT elimination function with custom alpha level</p></a></li>
<li><a href='#migrant'><p>A very small dataset from a pilot study on sound change.</p></a></li>
<li><a href='#re2mgcv'><p>Convert lme4 random-effect terms to mgcv 're' smooths</p></a></li>
<li><a href='#remove.terms'><p>Remove terms from a formula</p></a></li>
<li><a href='#tabulate.formula'><p>Parse a formula into a buildmer terms list</p></a></li>
<li><a href='#vowels'><p>Vowel data from a pilot study.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Stepwise Elimination and Term Reordering for Mixed-Effects
Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>2.11</td>
</tr>
<tr>
<td>Description:</td>
<td>Finds the largest possible regression model that will still converge
    for various types of regression analyses (including mixed models and generalized
    additive models) and then optionally performs stepwise elimination similar to the
    forward and backward effect-selection methods in SAS, based on the change in
    log-likelihood or its significance, Akaike's Information Criterion, the Bayesian
    Information Criterion, the explained deviance, or the F-test of the change in RÂ².</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, lme4, methods, mgcv, nlme, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>GLMMadaptive, MASS, gamm4, glmertree, glmmTMB, knitr,
lmerTest, nnet, ordinal, parallel, partykit, pbkrtest,
rmarkdown, testthat</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.freebsd.org/copyright/freebsd-license.html">FreeBSD</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://gitlab.com/cvoeten/buildmer/-/issues">https://gitlab.com/cvoeten/buildmer/-/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-25 00:51:34 UTC; cesko</td>
</tr>
<tr>
<td>Author:</td>
<td>Cesko C. Voeten <a href="https://orcid.org/0000-0003-4687-9973"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Cesko C. Voeten &lt;cvoeten@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-25 04:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='buildmer-package'>Construct and fit as complete a model as possible and perform stepwise elimination</h2><span id='topic+buildmer-package'></span>

<h3>Description</h3>

<p>The <code>buildmer</code> package consists of a number of functions, each designed to fit specific types of models (e.g. <code><a href="#topic+buildmer">buildmer</a></code> for mixed-effects regression, <code><a href="#topic+buildgam">buildgam</a></code> for generalized additive models, <code><a href="#topic+buildmertree">buildmertree</a></code> for mixed-effects-regression trees, and so forth). The common parameters shared by all (or most of) these functions are documented here. If you are looking for a more general description of what the various <code>build...</code> functions do, see under &lsquo;Details&rsquo;. For function-specific details, see the documentation for each individual function.
</p>

<hr>
<h2 id='add.terms'>Add terms to a formula</h2><span id='topic+add.terms'></span>

<h3>Description</h3>

<p>Add terms to a formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.terms(formula, add)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add.terms_+3A_formula">formula</code></td>
<td>
<p>The formula to add terms to.</p>
</td></tr>
<tr><td><code id="add.terms_+3A_add">add</code></td>
<td>
<p>A vector of terms to add. To add terms nested in random-effect groups, use &lsquo;(term|group)&rsquo; syntax if you want to add an independent random effect (e.g. &lsquo;(olderterm|group) + (term|group)&rsquo;), or use &lsquo;term|group&rsquo; syntax if you want to add a dependent random effect to a pre-existing term group (if no such group exists, it will be created at the end of the formula).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The updated formula.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(buildmer)
form &lt;- Reaction ~ Days + (1|Subject)
add.terms(form,'Days|Subject')
add.terms(form,'(0+Days|Subject)')
add.terms(form,c('many','more|terms','to|terms','(be|added)','to|test'))
</code></pre>

<hr>
<h2 id='build.formula'>Convert a buildmer term list into a proper model formula</h2><span id='topic+build.formula'></span>

<h3>Description</h3>

<p>Convert a buildmer term list into a proper model formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build.formula(dep, terms, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build.formula_+3A_dep">dep</code></td>
<td>
<p>The dependent variable.</p>
</td></tr>
<tr><td><code id="build.formula_+3A_terms">terms</code></td>
<td>
<p>The term list.</p>
</td></tr>
<tr><td><code id="build.formula_+3A_env">env</code></td>
<td>
<p>The environment of the formula to return.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A formula.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(buildmer)
form1 &lt;- Reaction ~ Days + (Days|Subject)
terms &lt;- tabulate.formula(form1)
form2 &lt;- build.formula(dep='Reaction',terms)

# check that the two formulas give the same results
library(lme4)
check &lt;- function (f) resid(lmer(f,sleepstudy))
all.equal(check(form1),check(form2))

# can also do double bars now
form1 &lt;- Reaction ~ Days + (Days||Subject)
terms &lt;- tabulate.formula(form1)
form2 &lt;- build.formula(dep='Reaction',terms)
all.equal(check(form1),check(form2))
</code></pre>

<hr>
<h2 id='buildbam'>Use <code>buildmer</code> to fit big generalized additive models using <code>bam</code> from package <code>mgcv</code></h2><span id='topic+buildbam'></span>

<h3>Description</h3>

<p>Use <code>buildmer</code> to fit big generalized additive models using <code>bam</code> from package <code>mgcv</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildbam(
  formula,
  data = NULL,
  family = gaussian(),
  buildmerControl = buildmerControl()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildbam_+3A_formula">formula</code></td>
<td>
<p>See the general documentation under <code><a href="#topic+buildmer-package">buildmer-package</a></code></p>
</td></tr>
<tr><td><code id="buildbam_+3A_data">data</code></td>
<td>
<p>See the general documentation under <code><a href="#topic+buildmer-package">buildmer-package</a></code></p>
</td></tr>
<tr><td><code id="buildbam_+3A_family">family</code></td>
<td>
<p>See the general documentation under <code><a href="#topic+buildmer-package">buildmer-package</a></code></p>
</td></tr>
<tr><td><code id="buildbam_+3A_buildmercontrol">buildmerControl</code></td>
<td>
<p>Control arguments for buildmer &mdash; see the general documentation under <code><a href="#topic+buildmerControl">buildmerControl</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>To work around an issue in <code>bam</code>, you must make sure that your data do not contain a variable named 'intercept'.
</p>
<p><code>lme4</code> random effects are supported: they will be automatically converted using <code><a href="#topic+re2mgcv">re2mgcv</a></code>.
</p>
<p>As <code>bam</code> uses PQL, only <code>crit='F'</code> and <code>crit='deviance'</code> (note that the latter is not a formal test) are supported for non-Gaussian errors.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildmer-package">buildmer-package</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(buildmer)
model &lt;- buildbam(f1 ~ s(timepoint,by=following) + s(participant,by=following,bs='re') +
       s(participant,timepoint,by=following,bs='fs'),data=vowels)

</code></pre>

<hr>
<h2 id='buildclmm'>Use <code>buildmer</code> to fit cumulative link mixed models using <code>clmm</code> from package <code>ordinal</code></h2><span id='topic+buildclmm'></span>

<h3>Description</h3>

<p>Use <code>buildmer</code> to fit cumulative link mixed models using <code>clmm</code> from package <code>ordinal</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildclmm(formula, data = NULL, buildmerControl = buildmerControl())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildclmm_+3A_formula">formula</code></td>
<td>
<p>A formula specifying both fixed and random effects using <code>lme4</code> syntax</p>
</td></tr>
<tr><td><code id="buildclmm_+3A_data">data</code></td>
<td>
<p>See the general documentation under <code><a href="#topic+buildmer-package">buildmer-package</a></code></p>
</td></tr>
<tr><td><code id="buildclmm_+3A_buildmercontrol">buildmerControl</code></td>
<td>
<p>Control arguments for buildmer &mdash; see the general documentation under <code><a href="#topic+buildmerControl">buildmerControl</a></code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+buildmer-package">buildmer-package</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace('ordinal')) {
model &lt;- buildclmm(SURENESS ~ PROD + (1|RESP),data=ordinal::soup,
buildmerControl=list(args=list(link='probit',threshold='equidistant')))
}
</code></pre>

<hr>
<h2 id='buildcustom'>Use <code>buildmer</code> to perform stepwise elimination using a custom fitting function</h2><span id='topic+buildcustom'></span>

<h3>Description</h3>

<p>Use <code>buildmer</code> to perform stepwise elimination using a custom fitting function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildcustom(
  formula,
  data = NULL,
  fit = function(p, formula) stop("'fit' not specified"),
  crit = function(p, ref, alt) stop("'crit' not specified"),
  elim = function(x) stop("'elim' not specified"),
  REML = FALSE,
  buildmerControl = buildmerControl()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildcustom_+3A_formula">formula</code></td>
<td>
<p>See the general documentation under <code><a href="#topic+buildmer-package">buildmer-package</a></code></p>
</td></tr>
<tr><td><code id="buildcustom_+3A_data">data</code></td>
<td>
<p>See the general documentation under <code><a href="#topic+buildmer-package">buildmer-package</a></code></p>
</td></tr>
<tr><td><code id="buildcustom_+3A_fit">fit</code></td>
<td>
<p>A function taking two arguments, of which the first is the <code>buildmer</code> parameter list <code>p</code> and the second one is a formula. The function must return a single object, which is treated as a model object fitted via the provided formula. The function must return an error ('<code>stop()</code>') if the model does not converge.</p>
</td></tr>
<tr><td><code id="buildcustom_+3A_crit">crit</code></td>
<td>
<p>A function taking one argument and returning a single value. The argument is the return value of the function passed in <code>fit</code>, and the returned value must be a numeric indicating the goodness of fit, where smaller is better (like AIC or BIC).</p>
</td></tr>
<tr><td><code id="buildcustom_+3A_elim">elim</code></td>
<td>
<p>A function taking one argument and returning a single value. The argument is the return value of the function passed in <code>crit</code>, and the returned value must be a logical indicating if the small model must be selected (return <code>TRUE</code>) or the large model (return <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="buildcustom_+3A_reml">REML</code></td>
<td>
<p>A logical indicating if the fitting function wishes to distinguish between fits differing in fixed effects (for which <code>p$reml</code> will be set to FALSE) and fits differing only in the random part (for which <code>p$reml</code> will be TRUE). Note that this ignores the usual semantics of buildmer's optional <code>REML</code> argument, because they are redundant: if you wish to force REML on or off, simply code it so in your custom fitting function.</p>
</td></tr>
<tr><td><code id="buildcustom_+3A_buildmercontrol">buildmerControl</code></td>
<td>
<p>Control arguments for buildmer &mdash; see the general documentation under <code><a href="#topic+buildmerControl">buildmerControl</a></code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+buildmer-package">buildmer-package</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Use \code{buildmer} to do stepwise linear discriminant analysis
library(buildmer)
migrant[,-1] &lt;- scale(migrant[,-1])
flipfit &lt;- function (p,formula) {
    # The predictors must be entered as dependent variables in a MANOVA
    # (i.e. the predictors must be flipped with the dependent variable)
    Y &lt;- model.matrix(formula,migrant)
    m &lt;- lm(Y ~ 0+migrant$changed)
    # the model may error out when asking for the MANOVA
    test &lt;- try(anova(m))
    if (inherits(test,'try-error')) test else m
}
crit.F &lt;- function (p,a,b) { # use whole-model F
    pvals &lt;- anova(b)$'Pr(&gt;F)' # not valid for backward!
    pvals[length(pvals)-1]
}
crit.Wilks &lt;- function (p,a,b) {
    if (is.null(a)) return(crit.F(p,a,b)) #not completely correct, but close as F approximates X2
    Lambda &lt;- anova(b,test='Wilks')$Wilks[1]
    p &lt;- length(coef(b))
    n &lt;- 1
    m &lt;- nrow(migrant)
    Bartlett &lt;- ((p-n+1)/2-m)*log(Lambda)
    pchisq(Bartlett,n*p,lower.tail=FALSE)
}

# First, order the terms based on Wilks' Lambda
model &lt;- buildcustom(changed ~ friends.nl+friends.be+multilingual+standard+hearing+reading+
       attention+sleep+gender+handedness+diglossic+age+years,buildmerControl=list(
       fit=flipfit,crit=crit.Wilks,direction='order'))
# Now, use the six most important terms (arbitrary choice) in the LDA
if (require('MASS')) {
model &lt;- lda(changed ~ diglossic + age + reading + friends.be + years + 
       multilingual,data=migrant)
}
</code></pre>

<hr>
<h2 id='buildgam'>Use <code>buildmer</code> to fit generalized additive models using <code>gam</code> from package <code>mgcv</code></h2><span id='topic+buildgam'></span>

<h3>Description</h3>

<p>Use <code>buildmer</code> to fit generalized additive models using <code>gam</code> from package <code>mgcv</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildgam(
  formula,
  data = NULL,
  family = gaussian(),
  quickstart = 0,
  buildmerControl = buildmerControl()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildgam_+3A_formula">formula</code></td>
<td>
<p>See the general documentation under <code><a href="#topic+buildmer-package">buildmer-package</a></code></p>
</td></tr>
<tr><td><code id="buildgam_+3A_data">data</code></td>
<td>
<p>See the general documentation under <code><a href="#topic+buildmer-package">buildmer-package</a></code></p>
</td></tr>
<tr><td><code id="buildgam_+3A_family">family</code></td>
<td>
<p>See the general documentation under <code><a href="#topic+buildmer-package">buildmer-package</a></code></p>
</td></tr>
<tr><td><code id="buildgam_+3A_quickstart">quickstart</code></td>
<td>
<p>A numeric with values from 0 to 5. If set to 1, will use <code>bam</code> to obtain starting values for <code>gam</code>'s outer iteration, potentially resulting in a much faster fit for each model. If set to 2, will disregard ML/REML and always use <code>bam</code>'s <code>fREML</code> for the quickstart fit. 3 also sets <code>discrete=TRUE</code>. Values between 3 and 4 fit the quickstart model to a subset of that value (e.g.\ <code>quickstart=3.1</code> fits the quickstart model to 10% of the data, which is also the default if <code>quickstart=3</code>. Values between 4 and 5 do the same, but also set a very sloppy convergence tolerance of 0.2.</p>
</td></tr>
<tr><td><code id="buildgam_+3A_buildmercontrol">buildmerControl</code></td>
<td>
<p>Control arguments for buildmer &mdash; see the general documentation under <code><a href="#topic+buildmerControl">buildmerControl</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>To work around an issue in <code>gam</code>, you must make sure that your data do not contain a variable named 'intercept'.
</p>
<p><code>lme4</code> random effects are supported: they will be automatically converted using <code><a href="#topic+re2mgcv">re2mgcv</a></code>.
</p>
<p>If <code>gam</code>'s <code>optimizer</code> argument is not set to use outer iteration, <code>gam</code> fits using PQL. In this scenario, only <code>crit='F'</code> and <code>crit='deviance'</code> (note that the latter is not a formal test) are legitimate in the generalized case.
</p>
<p>General families implemented in <code>mgcv</code> are supported, provided that they use normal formulas. Currently, this is only true of the <code>cox.ph</code> family. Because this family can only be fitted using REML, <code>buildgam</code> automatically sets <code>gam</code>'s <code>select</code> argument to <code>TRUE</code> and prevents removal of parametric terms.
</p>
<p><code><a href="#topic+buildmerControl">buildmerControl</a></code>'s quickstart function may be used here. If you desire more control (e.g.\ <code>discrete=FALSE</code> but <code>use.chol=TRUE</code>), additional options can be provided as extra arguments and will be passed on to <code>bam</code> as they are applicable. Note that <code>quickstart</code> needs to be larger than 0 to trigger the quickstart path at all.
</p>
<p>If scaled-t errors are used (<code>family=scat</code>), the quickstart path will also provide initial values for the two theta parameters (corresponding to the degrees of freedom and the scale parameter), but only if your installation of package <code>mgcv</code> is at least at version 1.8-32.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildmer-package">buildmer-package</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(buildmer)
model &lt;- buildgam(f1 ~ s(timepoint,by=following) + s(participant,by=following,bs='re') +
       s(participant,timepoint,by=following,bs='fs'),data=vowels)

</code></pre>

<hr>
<h2 id='buildgamm'>Use <code>buildmer</code> to fit big generalized additive models using <code>gamm</code> from package <code>mgcv</code></h2><span id='topic+buildgamm'></span>

<h3>Description</h3>

<p>Use <code>buildmer</code> to fit big generalized additive models using <code>gamm</code> from package <code>mgcv</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildgamm(
  formula,
  data = NULL,
  family = gaussian(),
  buildmerControl = buildmerControl()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildgamm_+3A_formula">formula</code></td>
<td>
<p>See the general documentation under <code><a href="#topic+buildmer-package">buildmer-package</a></code></p>
</td></tr>
<tr><td><code id="buildgamm_+3A_data">data</code></td>
<td>
<p>See the general documentation under <code><a href="#topic+buildmer-package">buildmer-package</a></code></p>
</td></tr>
<tr><td><code id="buildgamm_+3A_family">family</code></td>
<td>
<p>See the general documentation under <code><a href="#topic+buildmer-package">buildmer-package</a></code></p>
</td></tr>
<tr><td><code id="buildgamm_+3A_buildmercontrol">buildmerControl</code></td>
<td>
<p>Control arguments for buildmer &mdash; see the general documentation under <code><a href="#topic+buildmerControl">buildmerControl</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fixed and random effects are to be passed as a single formula in <code>lme4</code> format. This is internally split up into the appropriate <code>fixed</code> and <code>random</code> parts.
Only a single grouping factor is allowed. The random-effect covariance matrix is always unstructured. If you want to use <code>pdMat</code> covariance structures, you must (a) <em>not</em> specify any <code>lme4</code> random-effects term in the formula, and (b) specify your own custom <code>random</code> argument in the <code>args</code> list in <code>buildmerControl</code>. Note that <code>buildgamm</code> will merely pass this through; no term reordering or stepwise elimination is done on a user-provided <code>random</code> argument.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildmer-package">buildmer-package</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(buildmer)
model &lt;- buildgamm(f1 ~ s(timepoint,by=following) + (following|participant) +
       s(participant,timepoint,by=following,bs='fs'),data=vowels)

</code></pre>

<hr>
<h2 id='buildgamm4'>Use <code>buildmer</code> to fit generalized additive models using package <code>gamm4</code></h2><span id='topic+buildgamm4'></span>

<h3>Description</h3>

<p>Use <code>buildmer</code> to fit generalized additive models using package <code>gamm4</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildgamm4(
  formula,
  data = NULL,
  family = gaussian(),
  buildmerControl = buildmerControl()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildgamm4_+3A_formula">formula</code></td>
<td>
<p>See the general documentation under <code><a href="#topic+buildmer-package">buildmer-package</a></code></p>
</td></tr>
<tr><td><code id="buildgamm4_+3A_data">data</code></td>
<td>
<p>See the general documentation under <code><a href="#topic+buildmer-package">buildmer-package</a></code></p>
</td></tr>
<tr><td><code id="buildgamm4_+3A_family">family</code></td>
<td>
<p>See the general documentation under <code><a href="#topic+buildmer-package">buildmer-package</a></code></p>
</td></tr>
<tr><td><code id="buildgamm4_+3A_buildmercontrol">buildmerControl</code></td>
<td>
<p>Control arguments for buildmer &mdash; see the general documentation under <code><a href="#topic+buildmerControl">buildmerControl</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fixed and random effects are to be passed as a single formula in <em><code>lme4</code> format</em>. This is internally split up into the appropriate <code>fixed</code> and <code>random</code> parts.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildmer-package">buildmer-package</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(buildmer)
if (requireNamespace('gamm4')) model &lt;- buildgamm4(f1 ~ s(timepoint,by=following) +
       s(participant,timepoint,by=following,bs='fs'),data=vowels)

</code></pre>

<hr>
<h2 id='buildGLMMadaptive'>Use <code>buildmer</code> to fit generalized linear mixed models using <code>mixed_model</code> from package <code>GLMMadaptive</code></h2><span id='topic+buildGLMMadaptive'></span>

<h3>Description</h3>

<p>Use <code>buildmer</code> to fit generalized linear mixed models using <code>mixed_model</code> from package <code>GLMMadaptive</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildGLMMadaptive(
  formula,
  data = NULL,
  family,
  buildmerControl = buildmerControl()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildGLMMadaptive_+3A_formula">formula</code></td>
<td>
<p>A formula specifying both fixed and random effects using <code>lme4</code> syntax. (Unlike <code>mixed_model</code>, <code>buildGLMMadaptive</code> does not use a separate <code>random</code> argument!)</p>
</td></tr>
<tr><td><code id="buildGLMMadaptive_+3A_data">data</code></td>
<td>
<p>See the general documentation under <code><a href="#topic+buildmer-package">buildmer-package</a></code></p>
</td></tr>
<tr><td><code id="buildGLMMadaptive_+3A_family">family</code></td>
<td>
<p>See the general documentation under <code><a href="#topic+buildmer-package">buildmer-package</a></code></p>
</td></tr>
<tr><td><code id="buildGLMMadaptive_+3A_buildmercontrol">buildmerControl</code></td>
<td>
<p>Control arguments for buildmer &mdash; see the general documentation under <code><a href="#topic+buildmerControl">buildmerControl</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fixed and random effects are to be passed as a single formula in <em><code>lme4</code> format</em>. This is internally split up into the appropriate <code>fixed</code> and <code>random</code> parts.
</p>
<p>As GLMMadaptive can only fit models with a single random-effect grouping factor, having multiple <em>different</em> grouping factors will raise an error.
</p>
<p>If multiple <em>identical</em> random-effect grouping factors are provided, they will be concatenated into a single grouping factor using the double-bar syntax, causing GLMMadaptive to assume a diagonal random-effects covariance matrix. In other words, <code>(1|g) + (0+x|g)</code> will correctly be treated as diagonal, but note the caveat: <code>(a|g) + (b|g)</code> will also be treated as fully diagonal, even if <code>a</code> and <code>b</code> are factors which might still have had correlations between their individual levels! This is a limitation of both GLMMadaptive and buildmer's approach to handling double bars.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildmer-package">buildmer-package</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace('GLMMadaptive')) {
# nonsensical model given these data
model &lt;- buildGLMMadaptive(stress ~ vowel + (vowel|participant),
       family=binomial,data=vowels,buildmerControl=list(args=list(nAGQ=1)))
# or with double-bar syntax for a diagonal r.e. cov. matrix
model &lt;- buildGLMMadaptive(stress ~ vowel + (vowel||participant),
       family=binomial,data=vowels,buildmerControl=list(args=list(nAGQ=1)))
}

</code></pre>

<hr>
<h2 id='buildglmmTMB'>Use <code>buildmer</code> to perform stepwise elimination on <code>glmmTMB</code> models</h2><span id='topic+buildglmmTMB'></span>

<h3>Description</h3>

<p>Use <code>buildmer</code> to perform stepwise elimination on <code>glmmTMB</code> models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildglmmTMB(
  formula,
  data = NULL,
  family = gaussian(),
  buildmerControl = buildmerControl()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildglmmTMB_+3A_formula">formula</code></td>
<td>
<p>See the general documentation under <code><a href="#topic+buildmer-package">buildmer-package</a></code></p>
</td></tr>
<tr><td><code id="buildglmmTMB_+3A_data">data</code></td>
<td>
<p>See the general documentation under <code><a href="#topic+buildmer-package">buildmer-package</a></code></p>
</td></tr>
<tr><td><code id="buildglmmTMB_+3A_family">family</code></td>
<td>
<p>See the general documentation under <code><a href="#topic+buildmer-package">buildmer-package</a></code></p>
</td></tr>
<tr><td><code id="buildglmmTMB_+3A_buildmercontrol">buildmerControl</code></td>
<td>
<p>Control arguments for buildmer &mdash; see the general documentation under <code><a href="#topic+buildmerControl">buildmerControl</a></code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+buildmer-package">buildmer-package</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(buildmer)
if (requireNamespace('glmmTMB')) {
	model &lt;- buildglmmTMB(Reaction ~ Days + (Days|Subject),data=lme4::sleepstudy)
}
</code></pre>

<hr>
<h2 id='buildgls'>Use <code>buildmer</code> to fit generalized-least-squares models using <code>gls</code> from <code>nlme</code></h2><span id='topic+buildgls'></span>

<h3>Description</h3>

<p>Use <code>buildmer</code> to fit generalized-least-squares models using <code>gls</code> from <code>nlme</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildgls(formula, data = NULL, buildmerControl = buildmerControl())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildgls_+3A_formula">formula</code></td>
<td>
<p>See the general documentation under <code><a href="#topic+buildmer-package">buildmer-package</a></code></p>
</td></tr>
<tr><td><code id="buildgls_+3A_data">data</code></td>
<td>
<p>See the general documentation under <code><a href="#topic+buildmer-package">buildmer-package</a></code></p>
</td></tr>
<tr><td><code id="buildgls_+3A_buildmercontrol">buildmerControl</code></td>
<td>
<p>Control arguments for buildmer &mdash; see the general documentation under <code><a href="#topic+buildmerControl">buildmerControl</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A workaround is included to prevent an error when the model matrix is of less than full rank. The summary output of such a model will look a bit strange!
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildmer-package">buildmer-package</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(buildmer)
library(nlme)
vowels$event &lt;- with(vowels,interaction(participant,word))
model &lt;- buildgls(f1 ~ timepoint*following,data=vowels,
	buildmerControl=list(args=list(correlation=corAR1(form=~1|event))))
</code></pre>

<hr>
<h2 id='buildlme'>Use <code>buildmer</code> to perform stepwise elimination of mixed-effects models fit via <code>lme</code> from <code>nlme</code></h2><span id='topic+buildlme'></span>

<h3>Description</h3>

<p>Use <code>buildmer</code> to perform stepwise elimination of mixed-effects models fit via <code>lme</code> from <code>nlme</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildlme(formula, data = NULL, buildmerControl = buildmerControl())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildlme_+3A_formula">formula</code></td>
<td>
<p>A formula specifying both fixed and random effects using <code>lme4</code> syntax. (Unlike <code>lme</code>, <code>buildlme</code> does not use a separate <code>random</code> argument!)</p>
</td></tr>
<tr><td><code id="buildlme_+3A_data">data</code></td>
<td>
<p>See the general documentation under <code><a href="#topic+buildmer-package">buildmer-package</a></code></p>
</td></tr>
<tr><td><code id="buildlme_+3A_buildmercontrol">buildmerControl</code></td>
<td>
<p>Control arguments for buildmer &mdash; see the general documentation under <code><a href="#topic+buildmerControl">buildmerControl</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fixed and random effects are to be passed as a single formula in <code>lme4</code> format. This is internally split up into the appropriate <code>fixed</code> and <code>random</code> parts.
Only a single grouping factor is allowed. The random-effect covariance matrix is always unstructured. If you want to use <code>pdMat</code> covariance structures, you must (a) <em>not</em> specify any <code>lme4</code> random-effects term in the formula, and (b) specify your own custom <code>random</code> argument in the <code>args</code> list in <code>buildmerControl</code>. Note that <code>buildlme</code> will merely pass this through; no term reordering or stepwise elimination is done on a user-provided <code>random</code> argument.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildmer-package">buildmer-package</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(buildmer)
model &lt;- buildlme(Reaction ~ Days + (Days|Subject),data=lme4::sleepstudy)
</code></pre>

<hr>
<h2 id='buildmer'>Use <code>buildmer</code> to fit mixed-effects models using <code>lmer</code>/<code>glmer</code> from <code>lme4</code></h2><span id='topic+buildmer'></span>

<h3>Description</h3>

<p>Use <code>buildmer</code> to fit mixed-effects models using <code>lmer</code>/<code>glmer</code> from <code>lme4</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildmer(
  formula,
  data = NULL,
  family = gaussian(),
  buildmerControl = buildmerControl()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildmer_+3A_formula">formula</code></td>
<td>
<p>See the general documentation under <code><a href="#topic+buildmer-package">buildmer-package</a></code></p>
</td></tr>
<tr><td><code id="buildmer_+3A_data">data</code></td>
<td>
<p>See the general documentation under <code><a href="#topic+buildmer-package">buildmer-package</a></code></p>
</td></tr>
<tr><td><code id="buildmer_+3A_family">family</code></td>
<td>
<p>See the general documentation under <code><a href="#topic+buildmer-package">buildmer-package</a></code></p>
</td></tr>
<tr><td><code id="buildmer_+3A_buildmercontrol">buildmerControl</code></td>
<td>
<p>Control arguments for buildmer &mdash; see the general documentation under <code><a href="#topic+buildmerControl">buildmerControl</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(buildmer)
model &lt;- buildmer(Reaction ~ Days + (Days|Subject),lme4::sleepstudy)

# Tests from github issue #2, that also show the use of the 'direction' and 'crit' parameters:
bm.test &lt;- buildmer(cbind(incidence,size - incidence) ~ period + (1 | herd),
	family=binomial,data=lme4::cbpp)
bm.test &lt;- buildmer(cbind(incidence,size - incidence) ~ period + (1 | herd),
	family=binomial,data=lme4::cbpp,buildmerControl=buildmerControl(direction='forward'))
bm.test &lt;- buildmer(cbind(incidence,size - incidence) ~ period + (1 | herd),
	family=binomial,data=lme4::cbpp,buildmerControl=buildmerControl(crit='AIC'))
bm.test &lt;- buildmer(cbind(incidence,size - incidence) ~ period + (1 | herd),
	family=binomial,data=lme4::cbpp,
	buildmerControl=buildmerControl(direction='forward',crit='AIC'))

# Example showing use of the 'include' parameter to force a particular term into the model
m1 &lt;- buildmer(Reaction ~ Days,data=lme4::sleepstudy,buildmerControl=list(include=~(1|Subject)))
# the below are equivalent
m2 &lt;- buildmer(Reaction ~ Days,data=lme4::sleepstudy,buildmerControl=list(include='(1|Subject)'))
m3 &lt;- buildmer(Reaction ~ Days + (1|Subject),data=lme4::sleepstudy,buildmerControl=list(
	include=~(1|Subject)))
m4 &lt;- buildmer(Reaction ~ Days + (1|Subject),data=lme4::sleepstudy,buildmerControl=list(
	include='(1|Subject)'))
</code></pre>

<hr>
<h2 id='buildmer-class'>The buildmer class</h2><span id='topic+buildmer-class'></span><span id='topic+mkBuildmer'></span>

<h3>Description</h3>

<p>This is a simple convenience class that allows &lsquo;anova&rsquo; and &lsquo;summary&rsquo; calls to fall through to the underlying model object, while retaining buildmer's iteration history. If you need to use the final model for other things, such as prediction, access it through the &lsquo;model&rsquo; slot of the buildmer class object.
</p>


<h3>Slots</h3>


<dl>
<dt><code>model</code></dt><dd><p>The final model containing only the terms that survived elimination</p>
</dd>
<dt><code>p</code></dt><dd><p>Parameters used during the fitting process</p>
</dd>
<dt><code>anova</code></dt><dd><p>The model's ANOVA, if the model was built with &lsquo;anova=TRUE&rsquo;</p>
</dd>
<dt><code>summary</code></dt><dd><p>The model's summary, if the model was built with &lsquo;summary=TRUE&rsquo;</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+buildmer">buildmer</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Manually create a bare-bones buildmer object:
model &lt;- lm(Sepal.Length ~ Petal.Length,iris)
p &lt;- list(in.buildmer=FALSE)
library(buildmer)
bm &lt;- mkBuildmer(model=model,p=p,anova=NULL,summary=NULL)
summary(bm)
</code></pre>

<hr>
<h2 id='buildmer.nb'>Use <code>buildmer</code> to fit negative-binomial models using <code>glm.nb</code> and <code>glmer.nb</code></h2><span id='topic+buildmer.nb'></span>

<h3>Description</h3>

<p>Use <code>buildmer</code> to fit negative-binomial models using <code>glm.nb</code> and <code>glmer.nb</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildmer.nb(formula, data = NULL, buildmerControl = buildmerControl())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildmer.nb_+3A_formula">formula</code></td>
<td>
<p>See the general documentation under <code><a href="#topic+buildmer-package">buildmer-package</a></code></p>
</td></tr>
<tr><td><code id="buildmer.nb_+3A_data">data</code></td>
<td>
<p>See the general documentation under <code><a href="#topic+buildmer-package">buildmer-package</a></code></p>
</td></tr>
<tr><td><code id="buildmer.nb_+3A_buildmercontrol">buildmerControl</code></td>
<td>
<p>Control arguments for buildmer &mdash; see the general documentation under <code><a href="#topic+buildmerControl">buildmerControl</a></code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+buildmer-package">buildmer-package</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(buildmer)
if (requireNamespace('MASS')) {
model &lt;- buildmer.nb(Days ~ Sex*Age*Eth*Lrn,MASS::quine)
}
</code></pre>

<hr>
<h2 id='buildmerControl'>Set control options for buildmer</h2><span id='topic+buildmerControl'></span>

<h3>Description</h3>

<p><code>buildmerControl</code> provides all the knobs and levers that can be manipulated during the buildmer fitting and <code>summary</code>/<code>anova</code> process. Some of these are part of buildmer's core functionality&mdash;for instance, <code>crit</code> allows to specify different elimination criteria, a core buildmer feature&mdash;whereas some are only meant for internal usage, e.g. <code>I_KNOW_WHAT_I_AM_DOING</code> is only used to turn off the PQL safeguards in <code>buildbam</code>/<code>buildgam</code>, which you really should only do if you have a very good reason to believe that the PQL check is being triggered erroneously for your problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildmerControl(
  formula = quote(stop("No formula specified")),
  data = NULL,
  family = gaussian(),
  args = list(),
  direction = c("order", "backward"),
  cl = NULL,
  crit = NULL,
  elim = NULL,
  fit = function(...) stop("No fitting function specified"),
  include = NULL,
  quiet = FALSE,
  calc.anova = FALSE,
  calc.summary = TRUE,
  ddf = "Wald",
  quickstart = 0,
  singular.ok = FALSE,
  grad.tol = formals(buildmer::converged)$grad.tol,
  hess.tol = formals(buildmer::converged)$hess.tol,
  dep = NULL,
  REML = NA,
  can.use.reml = TRUE,
  force.reml = FALSE,
  scale.est = NA,
  I_KNOW_WHAT_I_AM_DOING = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildmerControl_+3A_formula">formula</code></td>
<td>
<p>The model formula for the maximal model you would like to fit. Alternatively, a buildmer term list as obtained from <code><a href="#topic+tabulate.formula">tabulate.formula</a></code>. In the latter formulation, you also need to specify a <code>dep='...'</code> argument specifying the dependent variable to go along with the term list. See <code><a href="#topic+tabulate.formula">tabulate.formula</a></code> for an example of where this is useful.</p>
</td></tr>
<tr><td><code id="buildmerControl_+3A_data">data</code></td>
<td>
<p>The data to fit the model(s) to.</p>
</td></tr>
<tr><td><code id="buildmerControl_+3A_family">family</code></td>
<td>
<p>The error distribution to use.</p>
</td></tr>
<tr><td><code id="buildmerControl_+3A_args">args</code></td>
<td>
<p>Extra arguments passed to the fitting function.</p>
</td></tr>
<tr><td><code id="buildmerControl_+3A_direction">direction</code></td>
<td>
<p>Character string or vector indicating the direction for stepwise elimination; possible options are <code>'order'</code> (order terms by their contribution to the model), <code>'backward'</code> (backward elimination), <code>'forward'</code> (forward elimination, implies <code>order</code>). The default is the combination <code>c('order','backward')</code>, to first make sure that the model converges and to then perform backward elimination; other such combinations are perfectly allowed.</p>
</td></tr>
<tr><td><code id="buildmerControl_+3A_cl">cl</code></td>
<td>
<p>Specifies a cluster to use for parallelizing the evaluation of terms. This can be an object as returned by function <code>makeCluster</code> from package <code>parallel</code>, or a whole number to let buildmer create, manage, and destroy a cluster for you with the specified number of parallel processes.</p>
</td></tr>
<tr><td><code id="buildmerControl_+3A_crit">crit</code></td>
<td>
<p>Character string or vector determining the criterion used to test terms for their contribution to the model fit in the ordering step. Possible options are <code>'LRT'</code> (likelihood-ratio test based on chi-square mixtures per Stram &amp; Lee 1994 for random effects; this is the default), <code>'LL'</code> (use the raw -2 log likelihood), <code>'AIC'</code> (Akaike Information Criterion), <code>'BIC'</code> (Bayesian Information Criterion), and <code>'deviance'</code> (explained deviance &ndash; note that this is not a formal test). If left at its default value of <code>NULL</code>, the same value is used as in the <code>elim</code> argument; if that is also <code>NULL</code>, both are set to <code>'LRT'</code>. If <code>crit</code> is a function, it may optionally have an <code>crit.name</code> attribute, which will be used as its name in buildmer. This is used to guide the code checking for mismatches between <code>crit</code> and <code>elim</code> arguments.</p>
</td></tr>
<tr><td><code id="buildmerControl_+3A_elim">elim</code></td>
<td>
<p>Character string or vector determining the criterion used to test terms for elimination in the elimination step. Possible options are <code>'LRT'</code> (likelihood-ratio test based on chi-square mixtures per Stram &amp; Lee 1994 for random effects; this is the default), <code>'LL'</code> (use the raw -2 log likelihood), <code>'AIC'</code> (Akaike Information Criterion), <code>'BIC'</code> (Bayesian Information Criterion), and <code>'deviance'</code> (explained deviance &mdash; note that this is not a formal test). If left at its default value of <code>NULL</code>, the same value is used as in the <code>crit</code> argument; if that is also <code>NULL</code>, both are set to <code>'LRT'</code>. If <code>elim</code> is a function, it may optionally have an <code>elim.name</code> attribute, which will be used as its name in buildmer. This is used to guide the code checking for mismatches between <code>crit</code> and <code>elim</code> arguments.</p>
</td></tr>
<tr><td><code id="buildmerControl_+3A_fit">fit</code></td>
<td>
<p>Internal parameter &mdash; do not modify.</p>
</td></tr>
<tr><td><code id="buildmerControl_+3A_include">include</code></td>
<td>
<p>A one-sided formula or character vector of terms that will be included in the model at all times and are not subject to testing for elimination. These do not need to be specified separately in the <code>formula</code> argument. Useful for e.g. passing correlation structures in <code>glmmTMB</code> models.</p>
</td></tr>
<tr><td><code id="buildmerControl_+3A_quiet">quiet</code></td>
<td>
<p>A logical indicating whether to suppress progress messages.</p>
</td></tr>
<tr><td><code id="buildmerControl_+3A_calc.anova">calc.anova</code></td>
<td>
<p>Logical indicating whether to also calculate the ANOVA table for the final model after term elimination.</p>
</td></tr>
<tr><td><code id="buildmerControl_+3A_calc.summary">calc.summary</code></td>
<td>
<p>Logical indicating whether to also calculate the summary table for the final model after term elimination.</p>
</td></tr>
<tr><td><code id="buildmerControl_+3A_ddf">ddf</code></td>
<td>
<p>The method used for calculating <em>p</em>-values for <code>lme4</code> models and <code>calc.anova=TRUE</code> or <code>calc.summary=TRUE</code>. Options are <code>'Wald'</code> (default), <code>'Satterthwaite'</code> (if package <code>lmerTest</code> is available), <code>'Kenward-Roger'</code> (if packages <code>lmerTest</code> and <code>pbkrtest</code> are available), and <code>'lme4'</code> (no <em>p</em>-values).</p>
</td></tr>
<tr><td><code id="buildmerControl_+3A_quickstart">quickstart</code></td>
<td>
<p>For <code>gam</code> models only: a numeric with values from 0 to 5. If set to 1, will use <code>bam</code> to obtain starting values for <code>gam</code>'s outer iteration, potentially resulting in a much faster fit for each model. If set to 2, will disregard ML/REML and always use <code>bam</code>'s <code>fREML</code> for the quickstart fit. 3 also sets <code>discrete=TRUE</code>. Values between 3 and 4 fit the quickstart model to a subset of that value (e.g.\ <code>quickstart=3.1</code> fits the quickstart model to 10% of the data, which is also the default if <code>quickstart=3</code>. Values between 4 and 5 do the same, but also set a very sloppy convergence tolerance of 0.2.</p>
</td></tr>
<tr><td><code id="buildmerControl_+3A_singular.ok">singular.ok</code></td>
<td>
<p>Logical indicating whether singular fits are acceptable. Only for lme4 models.</p>
</td></tr>
<tr><td><code id="buildmerControl_+3A_grad.tol">grad.tol</code></td>
<td>
<p>Tolerance for declaring gradient convergence. For <code>buildbam</code>, the default value is multiplied by 100.</p>
</td></tr>
<tr><td><code id="buildmerControl_+3A_hess.tol">hess.tol</code></td>
<td>
<p>Tolerance for declaring Hessian convergence. For <code>buildbam</code>, the default value is multiplied by 100.</p>
</td></tr>
<tr><td><code id="buildmerControl_+3A_dep">dep</code></td>
<td>
<p>A character string specifying the name of the dependent variable. Only used if <code>formula</code> is a buildmer terms list.</p>
</td></tr>
<tr><td><code id="buildmerControl_+3A_reml">REML</code></td>
<td>
<p>In some situations, the user may want to force REML on or off, rather than using buildmer's autodetection. If <code>REML=TRUE</code> (or more precisely, if <code>isTRUE(REML)</code> evaluates to true), then buildmer will always use REML. This results in invalid results if formal model-comparison criteria are used with models differing in fixed effects (and the user is not guarded against this), but is useful with the 'deviance-explained' criterion, where it is actually the default (you can disable this and use the 'normal' REML/ML-differentiating behavior by passing <code>REML=NA</code>).</p>
</td></tr>
<tr><td><code id="buildmerControl_+3A_can.use.reml">can.use.reml</code></td>
<td>
<p>Internal option specifying whether the fitting engine should distinguish between fixed-effects and random-effects model comparisons. Do not set this option yourself unless you are programming a new fitting function for <code>buildcustom</code>.</p>
</td></tr>
<tr><td><code id="buildmerControl_+3A_force.reml">force.reml</code></td>
<td>
<p>Internal option specifying whether, if not differentiating between fixed-effects and random-effects model comparisons, these comparisons should be based on ML or on REML (if possible). Do not set this option yourself unless you are programming a new fitting function for <code>buildcustom</code>. Enabling this option only makes sense for criteria that do not compare likelihoods, in which case this is an optimization; it is applied automatically for the 'deviance-explained' criterion.</p>
</td></tr>
<tr><td><code id="buildmerControl_+3A_scale.est">scale.est</code></td>
<td>
<p>Internal option specifying whether the model estimates an unknown scale parameter. Used only in <code>crit.F</code>. Possible values are <code>TRUE</code> (scale is estimated), <code>FALSE</code> (scale is known), and <code>NA</code> (unknown, needs to be inferred from the fitted model; this is the default). There is limited support for modifying this parameter.</p>
</td></tr>
<tr><td><code id="buildmerControl_+3A_i_know_what_i_am_doing">I_KNOW_WHAT_I_AM_DOING</code></td>
<td>
<p>An internal option that you should not modify unless you know what you are doing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With the default options, all <code>buildmer</code> functions will do two things:
</p>

<ol>
<li><p> Determine the order of the effects in your model, based on their importance as measured by the likelihood-ratio test statistic. This identifies the &lsquo;maximal model&rsquo;, which is the model containing either all effects specified by the user, or subset of those effects that still allow the model to converge, ordered such that the most information-rich effects have made it in.
</p>
</li>
<li><p> Perform backward stepwise elimination based on the significance of the change in log-likelihood.
</p>
</li></ol>

<p>The final model is returned in the <code>model</code> slot of the returned <code>buildmer</code> object.
All functions in the <code>buildmer</code> package are aware of the distinction between (f)REML and ML, and know to divide chi-square <em>p</em>-values by 2 when comparing models differing only in random effects (see Pinheiro &amp; Bates 2000).
The steps executed above can be changed using the <code>direction</code> argument, allowing for arbitrary chains of, for instance, forward-backward-forward stepwise elimination (although using more than one elimination method on the same data is not recommended). The criterion for determining the importance of terms in the ordering stage and the elimination of terms in the elimination stage can also be changed, using the <code>crit</code> argument.
</p>

<hr>
<h2 id='buildmertree'>Use <code>buildmer</code> to perform stepwise elimination for <code>lmertree</code> and <code>glmertree</code> models from package <code>glmertree</code></h2><span id='topic+buildmertree'></span>

<h3>Description</h3>

<p>Use <code>buildmer</code> to perform stepwise elimination for <code>lmertree</code> and <code>glmertree</code> models from package <code>glmertree</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildmertree(
  formula,
  data = NULL,
  family = gaussian(),
  buildmerControl = buildmerControl(crit = "AIC")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildmertree_+3A_formula">formula</code></td>
<td>
<p>Either a <code>glmertree</code> formula, looking like <code>dep ~ left | middle | right</code> where the <code>middle</code> part is an <code>lme4</code>-style random-effects specification, or an ordinary formula (or buildmer term list thereof) specifying only the dependent variable and the fixed and random effects for the regression part. In the latter case, the additional argument <code>partitioning</code> must be specified as a one-sided formula containing the partitioning part of the model.</p>
</td></tr>
<tr><td><code id="buildmertree_+3A_data">data</code></td>
<td>
<p>See the general documentation under <code><a href="#topic+buildmer-package">buildmer-package</a></code></p>
</td></tr>
<tr><td><code id="buildmertree_+3A_family">family</code></td>
<td>
<p>See the general documentation under <code><a href="#topic+buildmer-package">buildmer-package</a></code></p>
</td></tr>
<tr><td><code id="buildmertree_+3A_buildmercontrol">buildmerControl</code></td>
<td>
<p>Control arguments for buildmer &mdash; see the general documentation under <code><a href="#topic+buildmerControl">buildmerControl</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the likelihood-ratio test is not available for <code>glmertree</code> models, as it cannot be assured that the models being compared are nested. The default is thus to use AIC.
In the generalized case or when testing many partitioning variables, it is recommended to pass <code>joint=FALSE</code>, as this results in a dramatic speed gain and reduces the odds of the final <code>glmer</code> model failing to converge or converging singularly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+buildmer-package">buildmer-package</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace('glmertree')) {
	model &lt;- buildmertree(Reaction ~ 1 | (Days|Subject) | Days,
		buildmerControl=buildmerControl(crit='LL',direction='order',args=list(joint=FALSE)),
        data=lme4::sleepstudy)

	model &lt;- buildmertree(Reaction ~ 1 | (Days|Subject) | Days,
		buildmerControl=buildmerControl(crit='LL',direction='order',args=list(joint=FALSE)),
	        data=lme4::sleepstudy,family=Gamma(link=identity))

}
</code></pre>

<hr>
<h2 id='buildmultinom'>Use <code>buildmer</code> to perform stepwise elimination for <code>multinom</code> models from package <code>nnet</code></h2><span id='topic+buildmultinom'></span>

<h3>Description</h3>

<p>Use <code>buildmer</code> to perform stepwise elimination for <code>multinom</code> models from package <code>nnet</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildmultinom(formula, data = NULL, buildmerControl = buildmerControl())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildmultinom_+3A_formula">formula</code></td>
<td>
<p>See the general documentation under <code><a href="#topic+buildmer-package">buildmer-package</a></code></p>
</td></tr>
<tr><td><code id="buildmultinom_+3A_data">data</code></td>
<td>
<p>See the general documentation under <code><a href="#topic+buildmer-package">buildmer-package</a></code></p>
</td></tr>
<tr><td><code id="buildmultinom_+3A_buildmercontrol">buildmerControl</code></td>
<td>
<p>Control arguments for buildmer &mdash; see the general documentation under <code><a href="#topic+buildmerControl">buildmerControl</a></code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+buildmer-package">buildmer-package</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace('nnet') &amp;&amp; require('MASS')) {
	options(contrasts = c("contr.treatment", "contr.poly"))
	example(birthwt)
	bwt.mu &lt;- buildmultinom(low ~ age*lwt*race*smoke,bwt)
}
</code></pre>

<hr>
<h2 id='converged'>Test a model for convergence</h2><span id='topic+converged'></span>

<h3>Description</h3>

<p>Test a model for convergence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>converged(model, singular.ok = FALSE, grad.tol = 0.1, hess.tol = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="converged_+3A_model">model</code></td>
<td>
<p>The model object to test.</p>
</td></tr>
<tr><td><code id="converged_+3A_singular.ok">singular.ok</code></td>
<td>
<p>A logical indicating whether singular fits are accepted as &lsquo;converged&rsquo; or not. Relevant only for lme4 models.</p>
</td></tr>
<tr><td><code id="converged_+3A_grad.tol">grad.tol</code></td>
<td>
<p>The tolerance to use for checking the gradient. This is currently only used by mgcv, glmmTMB, and clm(m) models.</p>
</td></tr>
<tr><td><code id="converged_+3A_hess.tol">hess.tol</code></td>
<td>
<p>The tolerance to use for checking the Hessian for negative eigenvalues. This is currently only used by mgcv, glmmTMB, and cl(m)m models.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical indicating whether the model converged.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(buildmer)
library(lme4)
good1 &lt;- lm(Reaction ~ Days,sleepstudy)
good2 &lt;- lmer(Reaction ~ Days + (Days|Subject),sleepstudy)
bad &lt;- lmer(Reaction ~ Days + (Days|Subject),sleepstudy,control=lmerControl(
            optimizer='bobyqa',optCtrl=list(maxfun=1)))
sapply(list(good1,good2,bad),converged)
</code></pre>

<hr>
<h2 id='diag+2Cformula-method'>Diagonalize the random-effect covariance structure, possibly assisting convergence</h2><span id='topic+diag+2Cformula-method'></span>

<h3>Description</h3>

<p>Diagonalize the random-effect covariance structure, possibly assisting convergence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'formula'
diag(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diag+2B2Cformula-method_+3A_x">x</code></td>
<td>
<p>A model formula.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The formula with all random-effect correlations forced to zero, per Pinheiro &amp; Bates (2000)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1. Create explicit columns for factor variables
library(buildmer)
vowels &lt;- cbind(vowels,model.matrix(~vowel,vowels))
# 2. Create formula with diagonal covariance structure
form &lt;- diag(f1 ~ (vowel1+vowel2+vowel3+vowel4)*timepoint*following + 
	     ((vowel1+vowel2+vowel3+vowel4)*timepoint*following | participant) +
	     (timepoint | word))
# 3. Convert formula to buildmer terms list, grouping terms starting with 'vowel'
terms &lt;- tabulate.formula(form,group='vowel[^:]')
# 4. Directly pass the terms object to buildmer, using the 'dep' argument to specify the
# dependent variable
model &lt;- buildmer(terms,data=vowels,buildmerControl=list(dep='f1'))
</code></pre>

<hr>
<h2 id='LRTalpha'>Generate an LRT elimination function with custom alpha level</h2><span id='topic+LRTalpha'></span>

<h3>Description</h3>

<p>The <code>elim</code> argument in <code>buildmerControl</code> can take any user-specified elimination function. <code>LRTalpha</code> generates such a function that uses the likelihood-ratio test, based on a user-specified alpha level. (For the default alpha of .05, one can also simply specify the string <code>'LRT'</code> or the function <code>buildmer:::elim.LRT</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LRTalpha(alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LRTalpha_+3A_alpha">alpha</code></td>
<td>
<p>The alpha level for the likelihood-ratio test.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+buildmerControl">buildmerControl</a></code>
</p>

<hr>
<h2 id='migrant'>A very small dataset from a pilot study on sound change.</h2><span id='topic+migrant'></span>

<h3>Description</h3>

<p>A very small dataset from a pilot study on sound change.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(migrant)
</code></pre>


<h3>Format</h3>

<p>A standard data frame.
</p>

<hr>
<h2 id='re2mgcv'>Convert lme4 random-effect terms to mgcv 're' smooths</h2><span id='topic+re2mgcv'></span>

<h3>Description</h3>

<p>Convert lme4 random-effect terms to mgcv 're' smooths
</p>


<h3>Usage</h3>

<pre><code class='language-R'>re2mgcv(formula, data, drop = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="re2mgcv_+3A_formula">formula</code></td>
<td>
<p>The lme4 formula.</p>
</td></tr>
<tr><td><code id="re2mgcv_+3A_data">data</code></td>
<td>
<p>The data.</p>
</td></tr>
<tr><td><code id="re2mgcv_+3A_drop">drop</code></td>
<td>
<p>Logical indicating whether constant, non-intercept columns should be dropped. Default <code>TRUE</code>. A warning is issued if a column needed to be dropped. Note that repeated intercept columns are silently merged without a warning.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(buildmer)
re &lt;- re2mgcv(temp ~ angle + (1|replicate) + (1|recipe),lme4::cake)
model &lt;- buildgam(re$formula,re$data)
# note: the below does NOT work, as the dependent variable is looked up in the data by name!

re &lt;- re2mgcv(log(Reaction) ~ Days + (Days|Subject),lme4::sleepstudy)
</code></pre>

<hr>
<h2 id='remove.terms'>Remove terms from a formula</h2><span id='topic+remove.terms'></span>

<h3>Description</h3>

<p>Remove terms from a formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove.terms(formula, remove, check = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove.terms_+3A_formula">formula</code></td>
<td>
<p>The formula.</p>
</td></tr>
<tr><td><code id="remove.terms_+3A_remove">remove</code></td>
<td>
<p>A vector of terms to remove. To remove terms nested inside random-effect groups, use &lsquo;(term|group)&rsquo; syntax. Note that marginality is respected, i.e. no effects will be removed if they participate in a higher-order interaction, and no fixed effects will be removed if a random slope is included over that fixed effect.</p>
</td></tr>
<tr><td><code id="remove.terms_+3A_check">check</code></td>
<td>
<p>A logical indicating whether effects should be checked for marginality. If <code>TRUE</code> (default), effects will not be removed if doing so would violate marginality. Setting <code>check</code> to <code>FALSE</code> will remove terms unconditionally.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(buildmer)
remove.terms(Reaction ~ Days + (Days|Subject),'(Days|Subject)')
# illustration of the marginality checking mechanism:
# this refuses to remove the term:
remove.terms(Reaction ~ Days + (Days|Subject),'(1|Subject)')
# so does this, because marginality is checked before removal:
remove.terms(Reaction ~ Days + (Days|Subject),c('(Days|Subject)','(1|Subject)'))
# but it works with check=FALSE
remove.terms(Reaction ~ Days + (Days|Subject),'(1|Subject)',check=FALSE)
</code></pre>

<hr>
<h2 id='tabulate.formula'>Parse a formula into a buildmer terms list</h2><span id='topic+tabulate.formula'></span>

<h3>Description</h3>

<p>Parse a formula into a buildmer terms list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tabulate.formula(formula, group = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tabulate.formula_+3A_formula">formula</code></td>
<td>
<p>A formula.</p>
</td></tr>
<tr><td><code id="tabulate.formula_+3A_group">group</code></td>
<td>
<p>A character vector of regular expressions. Terms matching the same regular expression are assigned the same block, and will be evaluated together in buildmer functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A buildmer terms list, which is just a normal data frame.
</p>


<h3>See Also</h3>

<p>buildmer-package
</p>


<h3>Examples</h3>

<pre><code class='language-R'>form &lt;- diag(f1 ~ (vowel1+vowel2+vowel3+vowel4)*timepoint*following +
             ((vowel1+vowel2+vowel3+vowel4)*timepoint*following|participant) + (timepoint|word))
tabulate.formula(form)
tabulate.formula(form,group='vowel[1-4]')
</code></pre>

<hr>
<h2 id='vowels'>Vowel data from a pilot study.</h2><span id='topic+vowels'></span>

<h3>Description</h3>

<p>Vowel data from a pilot study.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(vowels)
</code></pre>


<h3>Format</h3>

<p>A standard data frame.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
