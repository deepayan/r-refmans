<!DOCTYPE html><html><head><title>Help for package fmri</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fmri}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Convert Between fmridata and oro.nifti'><p>Convert Between fmridata and oro.nifti Objects</p></a></li>
<li><a href='#cutroi'><p> I/O function</p></a></li>
<li><a href='#extractData'><p> Extract data or residuals from a fmridata object</p></a></li>
<li><a href='#fmri.cluster'>
<p>Cluster thresholding.</p></a></li>
<li><a href='#fmri.design'><p> Linear Model for FMRI Data</p></a></li>
<li><a href='#fmri.designG'><p> Design matrix for fMRI group analysis</p></a></li>
<li><a href='#fmri.detrend'><p> Detrend fMRI time series</p></a></li>
<li><a href='#fmri.lm'><p> Linear Model for fMRI data</p></a></li>
<li><a href='#fmri.lmePar'><p> Linear Mixed-effects Model for fMRI data</p></a></li>
<li><a href='#fmri.metaPar'><p> Linear Mixed-effects Meta-Analysis model for fMRI data</p></a></li>
<li><a href='#fmri.pvalue'><p> P-values</p></a></li>
<li><a href='#fmri.searchlight'>
<p>Searchlight signal detection</p></a></li>
<li><a href='#fmri.sgroupICA'>
<p>Spatial group ICA for fmri</p></a></li>
<li><a href='#fmri.sICA'><p>Spacial ICA for fmri data</p></a></li>
<li><a href='#fmri.smooth'><p> Smoothing Statistical Parametric Maps</p></a></li>
<li><a href='#fmri.stimulus'><p> Linear Model for FMRI Data</p></a></li>
<li><a href='#gen_fmridata'><p>Generate fmridata example</p></a></li>
<li><a href='#getSearchlightPattern'>
<p>Extract searchlight pattern from a SPM</p></a></li>
<li><a href='#hvred'>
<p>Translation between smoothness and bandwidth for Gaussian kernel</p></a></li>
<li><a href='#ICAfingerprint'>
<p>IC fingerprinting</p></a></li>
<li><a href='#niftiImage2fmri'><p>Create fmridata object from niftiImage</p></a></li>
<li><a href='#plot.fmridata'><p> I/O functions</p></a></li>
<li><a href='#plot.fmriICA'>
<p>Diagnostics plots for objects of class &rdquo;<code>fmriICA</code>&rdquo;</p></a></li>
<li><a href='#plot.fmripvalue'>
<p>Visualize fMRI p-value maps</p></a></li>
<li><a href='#print.fmridata'><p> I/O functions</p></a></li>
<li><a href='#read.AFNI'><p> I/O function</p></a></li>
<li><a href='#read.ANALYZE'><p> I/O Functions</p></a></li>
<li><a href='#read.DICOM'><p> I/O function</p></a></li>
<li><a href='#read.NIFTI'><p> I/O Functions</p></a></li>
<li><a href='#setmask'>
<p>Add or replace mask in an fmridata object</p></a></li>
<li><a href='#sincfilter'>
<p>A function for sinc-interpolation</p></a></li>
<li><a href='#slicetiming'>
<p>slicetiming for fmridata-objects</p></a></li>
<li><a href='#summary.fmridata'><p> I/O functions</p></a></li>
<li><a href='#write.AFNI'><p> I/O functions</p></a></li>
<li><a href='#write.ANALYZE'><p> I/O Functions</p></a></li>
<li><a href='#write.NIFTI'><p> I/O Functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.9.12</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-05</td>
</tr>
<tr>
<td>Title:</td>
<td>Analysis of fMRI Experiments</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, graphics, stats, utils, nlme, parallel, metafor,
methods, aws (&ge; 2.5.1), oro.nifti</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tcltk, tkrplot, fastICA, adimpro (&ge; 0.9)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains R-functions to perform an fMRI analysis as described in
             Polzehl and Tabelow (2019) &lt;<a href="https://doi.org/10.1007%2F978-3-030-29184-6">doi:10.1007/978-3-030-29184-6</a>&gt;,
             Tabelow et al. (2006) &lt;<a href="https://doi.org/10.1016%2Fj.neuroimage.2006.06.029">doi:10.1016/j.neuroimage.2006.06.029</a>&gt;,
             Polzehl et al. (2010) &lt;<a href="https://doi.org/10.1016%2Fj.neuroimage.2010.04.241">doi:10.1016/j.neuroimage.2010.04.241</a>&gt;,
             Tabelow and Polzehl (2011) &lt;<a href="https://doi.org/10.18637%2Fjss.v044.i11">doi:10.18637/jss.v044.i11</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Copyright:</td>
<td>This package is Copyright (C) 2006-2020 Weierstrass
Institute for Applied Analysis and Stochastics.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.wias-berlin.de/software/imaging/">https://www.wias-berlin.de/software/imaging/</a></td>
</tr>
<tr>
<td>Note:</td>
<td>This software comes with NO warranty! It is NOT intended to be
used in clinical applications! For evaluation only!</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-05 21:11:53 UTC; polzehl</td>
</tr>
<tr>
<td>Author:</td>
<td>Karsten Tabelow [aut, cre],
  Joerg Polzehl [aut],
  Brandon Whitcher [ctb],
  Dames Sibylle [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Karsten Tabelow &lt;tabelow@wias-berlin.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-06 12:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Convert+20Between+20fmridata+20and+20oro.nifti'>Convert Between fmridata and oro.nifti Objects</h2><span id='topic+oro2fmri'></span><span id='topic+fmri2oro'></span>

<h3>Description</h3>

<p>NIfTI data can be converted between <code>fmridata</code> S3 objects
(from the <span class="pkg">fmri</span> package) and <code>nifti</code> S4 objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oro2fmri(from, value = NULL, level = 0.75, mask=NULL, setmask = TRUE)
fmri2oro(from, value = NULL, verbose = FALSE, reorient = FALSE,
         call = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Convert+2B20Between+2B20fmridata+2B20and+2B20oro.nifti_+3A_from">from</code></td>
<td>
<p>is the object to be converted.</p>
</td></tr>
<tr><td><code id="Convert+2B20Between+2B20fmridata+2B20and+2B20oro.nifti_+3A_value">value</code></td>
<td>
<p><code>NULL</code></p>
</td></tr>
<tr><td><code id="Convert+2B20Between+2B20fmridata+2B20and+2B20oro.nifti_+3A_level">level</code></td>
<td>
<p>is the quantile level defining the mask.</p>
</td></tr>
<tr><td><code id="Convert+2B20Between+2B20fmridata+2B20and+2B20oro.nifti_+3A_mask">mask</code></td>
<td>
<p>array or nifti-object containing the mask. If set this replaces
the mask defined by argument level.</p>
</td></tr>
<tr><td><code id="Convert+2B20Between+2B20fmridata+2B20and+2B20oro.nifti_+3A_setmask">setmask</code></td>
<td>
<p>is a logical variable (default = <code>TRUE</code>), whether
to define a suitable mask based on <code>level</code>.</p>
</td></tr>
<tr><td><code id="Convert+2B20Between+2B20fmridata+2B20and+2B20oro.nifti_+3A_verbose">verbose</code></td>
<td>
<p>is a logical variable (default = <code>FALSE</code>) that
allows text-based feedback during execution of the function.</p>
</td></tr>
<tr><td><code id="Convert+2B20Between+2B20fmridata+2B20and+2B20oro.nifti_+3A_reorient">reorient</code></td>
<td>
<p>is a logical variable (default = <code>TRUE</code>) that
enforces Qform/Sform transformations.</p>
</td></tr>
<tr><td><code id="Convert+2B20Between+2B20fmridata+2B20and+2B20oro.nifti_+3A_call">call</code></td>
<td>
<p>keeps track of the current function call for use in the
NIfTI extension.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions enhance the capabilities of <span class="pkg">fmri</span> by allowing the
exchange of data objects between <code>nifti</code> and <code>fmridata</code>
classes.
</p>


<h3>Value</h3>

<p>The function <code>oro2fmri</code> produces an S3 object of class
<code>fmridata</code>.  The function <code>fmri2oro</code> produces an S4
object of class <code>nifti</code>.
</p>


<h3>Author(s)</h3>

<p> Brandon Whitcher <a href="mailto:bwhitcher@gmail.com">bwhitcher@gmail.com</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+read.NIFTI">read.NIFTI</a></code>
</p>

<hr>
<h2 id='cutroi'> I/O function </h2><span id='topic+cutroi'></span>

<h3>Description</h3>

<p>This functions cuts a region-of-interest (ROI) from input data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cutroi(data, xind = 1:data$dim[1], yind = 1:data$dim[2], 
             zind = 1:data$dim[3], tind = 1:data$dim[4])
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cutroi_+3A_data">data</code></td>
<td>
<p> Object of class fmridata. </p>
</td></tr>
<tr><td><code id="cutroi_+3A_xind">xind</code></td>
<td>
<p> vector of roi-indices for first data index </p>
</td></tr>
<tr><td><code id="cutroi_+3A_yind">yind</code></td>
<td>
<p> vector of roi-indices for second data index </p>
</td></tr>
<tr><td><code id="cutroi_+3A_zind">zind</code></td>
<td>
<p> vector of roi-indices for third data index </p>
</td></tr>
<tr><td><code id="cutroi_+3A_tind">tind</code></td>
<td>
<p> vector of roi-indices for 4th data index </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Cut a region of interest from frmidata.
</p>


<h3>Value</h3>

<p>Corresponding cut fmridata object.
</p>


<h3>Author(s)</h3>

<p> Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.AFNI">read.AFNI</a></code>, <code><a href="#topic+read.ANALYZE">read.ANALYZE</a></code>, <code><a href="#topic+read.NIFTI">read.NIFTI</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

</code></pre>

<hr>
<h2 id='extractData'> Extract data or residuals from a fmridata object </h2><span id='topic+extractData'></span><span id='topic+condensefMRI'></span><span id='topic+expandfMRI'></span>

<h3>Description</h3>

<p>The function extracts data stored as raw within an object of class
'fmridata'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractData(z, what = "data", maskOnly = FALSE)
expandfMRI(z)
condensefMRI(z, mask)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractData_+3A_z">z</code></td>
<td>
<p> an object of class 'fmridata' </p>
</td></tr>
<tr><td><code id="extractData_+3A_what">what</code></td>
<td>
<p> either <code>"data"</code> or <code>"residuals"</code>. </p>
</td></tr>
<tr><td><code id="extractData_+3A_maskonly">maskOnly</code></td>
<td>
<p>logical: if TRUE only values within the brain mask will be returned.</p>
</td></tr>
<tr><td><code id="extractData_+3A_mask">mask</code></td>
<td>
<p>logical brain mask</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>extractData</code> extracts data stored as raw within an object of class
'fmridata'. Functions <code>expandfMRI</code> and <code>condensefMRI</code> change the way
data and residuals are stored between full 3D data and data within a brain mask.
<code>condensefMRI</code> can also be used to set a more restrictive brain mask.
</p>


<h3>Value</h3>

<p>In case of function <code>extractData</code> an array of dimension <code>data$dim</code> containing either the
fmri-data or residuals. The other two functions return an object of class 'fmridata'.
</p>


<h3>Author(s)</h3>

<p> Joerg Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+fmri.lm">fmri.lm</a></code> </p>

<hr>
<h2 id='fmri.cluster'>
Cluster thresholding.
</h2><span id='topic+fmri.cluster'></span>

<h3>Description</h3>

<p>Detection of activated regions using cluster thresholding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmri.cluster(spm, alpha = 0.05, ncmin = 2, ncmax=ncmin, 
             minimum.signal = 0, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmri.cluster_+3A_spm">spm</code></td>
<td>
<p><code>fmrispm</code> object
</p>
</td></tr>
<tr><td><code id="fmri.cluster_+3A_alpha">alpha</code></td>
<td>

<p>multiple test (over volume and cluster sizes) adjusted significance level
used for thresholds.
</p>
</td></tr>
<tr><td><code id="fmri.cluster_+3A_ncmin">ncmin</code></td>
<td>

<p>minimal cluster size used. An activation is detected if for any
clustersize in <code>nvmin:20</code> the size specific threshold is exceeded.
</p>
</td></tr>
<tr><td><code id="fmri.cluster_+3A_ncmax">ncmax</code></td>
<td>

<p>maximal cluster size used. An activation is detected if for any
clustersize in <code>ncmin:ncmax</code> the size specific threshold is exceeded.
</p>
</td></tr>
<tr><td><code id="fmri.cluster_+3A_minimum.signal">minimum.signal</code></td>
<td>

<p>allows to specify a (positive) minimum value for detected signals. If minimum.signal &gt;0
the thresholds are to conservative, this case needs further improvements.
</p>
</td></tr>
<tr><td><code id="fmri.cluster_+3A_verbose">verbose</code></td>
<td>

<p>intermediate diagnostics
</p>
</td></tr>
</table>


<h3>Details</h3>

<p> Approximate thresholds for the existence of a cluster with spm-values
exceeding a <code>1-beta</code> threshold <code>k_{nc,na:ne}</code> for cluster size <code>nc</code>
are based on a simulation study under the hypothesis and adjusted for number of voxel in 
mask and spatial correlation.
<code>beta</code> is chosen such that under the hypothesis the combined (over cluster sizes
<code>ncmin:ncmax</code>) test has approximate significance level <code>alpha</code>.
</p>


<h3>Value</h3>

<p>Object with class attributes &quot;fmripvalue&quot; and &quot;fmridata&quot;
</p>
<table>
<tr><td><code>pvalue</code></td>
<td>
<p> cluster based p-values for voxel that were detected
for any cluster size, a value of <code>1</code> otherwise.</p>
</td></tr>
<tr><td><code>mask</code></td>
<td>
<p> mask of detected activations </p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p> voxelsize ratio </p>
</td></tr>
<tr><td><code>dim</code></td>
<td>
<p> data dimension </p>
</td></tr>
<tr><td><code>hrf</code></td>
<td>
<p> expected BOLD response for contrast (single stimulus only)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joerg Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fmri.lm">fmri.lm</a></code>, <code><a href="#topic+fmri.pvalue">fmri.pvalue</a></code>, <code><a href="#topic+fmri.searchlight">fmri.searchlight</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: fmri.cluster(fmrispmobj)
</code></pre>

<hr>
<h2 id='fmri.design'> Linear Model for FMRI Data </h2><span id='topic+fmri.design'></span>

<h3>Description</h3>

<p>Return a design matrix for a linear model with given stimuli and
possible polynomial drift terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  fmri.design(stimulus, order = 2, cef = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmri.design_+3A_stimulus">stimulus</code></td>
<td>
<p> matrix containing expected BOLD response(s) for the linear
model as columns or list of expected BOLD responses containing matrices
of dimension <code>scans, number of slices</code> as returned by function
<code><a href="#topic+fmri.stimulus">fmri.stimulus</a></code>.</p>
</td></tr>
<tr><td><code id="fmri.design_+3A_order">order</code></td>
<td>
<p> order of the polynomial drift terms </p>
</td></tr>
<tr><td><code id="fmri.design_+3A_cef">cef</code></td>
<td>
<p> confounding effects </p>
</td></tr>
<tr><td><code id="fmri.design_+3A_verbose">verbose</code></td>
<td>
<p> Report more if <code>TRUE</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The stimuli given in <code>stimulus</code> are used as first columns in
the design matrix.
</p>
<p>The order of the polynomial drift terms is given
by <code>order</code>, which defaults to 2.
</p>
<p>Confounding effects can be included in a matrix <code>cef</code>.
</p>
<p>The polynomials are defined orthogonal to the stimuli given in
<code>stimulus</code>.
</p>


<h3>Value</h3>

<p>design matrix of the linear model
</p>


<h3>Author(s)</h3>

<p> Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a>,
Joerg Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a> </p>


<h3>References</h3>

<p>Polzehl, J. and Tabelow, K.(2007).
<em>fmri: A Package for Analyzing fmri Data</em>,
R News, 7:13-17 .
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fmri.stimulus">fmri.stimulus</a></code>, <code><a href="#topic+fmri.lm">fmri.lm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Example 1
  hrf &lt;- fmri.stimulus(107, c(18, 48, 78), 15, 2)
  z &lt;- fmri.design(hrf, 2)
  par(mfrow=c(2, 2))
  for (i in 1:4) plot(z[, i], type="l")
</code></pre>

<hr>
<h2 id='fmri.designG'> Design matrix for fMRI group analysis </h2><span id='topic+fmri.designG'></span>

<h3>Description</h3>

<p>This function returns a design matrix for multi-subject fMRI data to fit a Linear Mixed-effects Model (one-stage procedure) with given stimuli, polynomial drift terms and a set of known population parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmri.designG(hrf, subj = 1, runs = 1, group = NULL, XG = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmri.designG_+3A_hrf">hrf</code></td>
<td>
<p> vector or matrix containing expected BOLD response(s) 
for one session, typically a <code><a href="#topic+fmri.stimulus">fmri.stimulus</a></code> object. </p>
</td></tr>
<tr><td><code id="fmri.designG_+3A_subj">subj</code></td>
<td>
<p> number of subjects in the study. </p>
</td></tr>
<tr><td><code id="fmri.designG_+3A_runs">runs</code></td>
<td>
<p> number of repeated measures within subjects. </p>
</td></tr>
<tr><td><code id="fmri.designG_+3A_group">group</code></td>
<td>
<p> optional vector to define groups. 
It is expected one value per subject. A grouping factor can also be part of <code>XG</code>. </p>
</td></tr>
<tr><td><code id="fmri.designG_+3A_xg">XG</code></td>
<td>
<p> optionally, a group-level design matrix of class <code>"data.frame"</code>, which contains population parameters such as ages or gender corresponding to the subjects. It is expected one value per subject. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on the dimensionality of the <code>hrf</code> object, which provides the total number of scans (time-points) within each session, the entered number of subjects and repeated measures the auxiliary variables: &quot;subj&quot;, &quot;run&quot;, &quot;scan&quot; and &quot;session&quot; are generated as first part of the returned design matrix.
</p>
<p>If no <code>group</code> argument is specified, only one population will be assumed; otherwise group labels are replicated within sessions of the same subject. 
</p>
<p>First a design matrix for a single run is created by calling: <code>x &lt;- fmri.design(hrf, order = 2)</code>. Hence the polynomial drift terms are defined orthogonal to the stimuli (see <code><a href="#topic+fmri.design">fmri.design</a></code>). This matrix is replicated blockwise to all sessions assuming the same experimental design for all runs. The first drift term, a column of ones, is called &quot;drift0&quot; and models an intercept.
</p>
<p>If given, further subject characteristics are filled in the design matrix.
</p>


<h3>Value</h3>

<p>A design matrix as a data frame, which contains the following variables:
</p>
<table>
<tr><td><code>subj</code></td>
<td>
<p> consecutive subject number: 1 to <code>subj</code> specified as factor </p>
</td></tr>
<tr><td><code>run</code></td>
<td>
<p> consecutive run number within the subjects: 1 to <code>runs</code> specified as factor </p>
</td></tr>
<tr><td><code>scan</code></td>
<td>
<p> consecutive scan number: 1 to T within each session </p>
</td></tr>
<tr><td><code>session</code></td>
<td>
<p> consecutive experiment number: 1 to <code>(subj*runs)</code> specified as factor </p>
</td></tr>
<tr><td><code>group</code></td>
<td>
<p> grouping variable specified as factor, one group by default </p>
</td></tr>
<tr><td><code>hrf</code>, <code>hrf2</code>, <code>...</code></td>
<td>
<p> replicated expected BOLD-response(s) </p>
</td></tr>
<tr><td><code>drift0</code>, <code>drift1</code>, <code>drift2</code></td>
<td>
<p> replicated polynomial drift terms 
created with <code>fmri.design(hrf, order = 2)</code> orthogonal to the stimuli
given in <code>hrf</code> </p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p> further expanded between-subject factors and covariates </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Sibylle Dames </p>


<h3>References</h3>

<p>Polzehl, J. and Tabelow, K.(2007). <em>fmri: A Package for Analyzing fmri Data</em>, R News, 7:13-17.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fmri.stimulus">fmri.stimulus</a></code>, <code><a href="#topic+fmri.design">fmri.design</a></code>, <code><a href="#topic+fmri.lmePar">fmri.lmePar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>subj &lt;- 6
runs &lt;- 1
scans &lt;- 121
times &lt;- c(12, 48, 84, 120, 156, 192, 228, 264) 
duration &lt;- 24          
tr &lt;- 2.5

hrf &lt;- fmri.stimulus(scans, times, duration, tr, times = TRUE)
x.group &lt;- fmri.designG(hrf, subj = subj, runs = runs)
# View(x.group)
</code></pre>

<hr>
<h2 id='fmri.detrend'> Detrend fMRI time series </h2><span id='topic+fmri.detrend'></span>

<h3>Description</h3>

<p>Detrend fMRI dataset with a polynomial of given degree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmri.detrend(data, degree = 1, nuisance=NULL, accoef = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmri.detrend_+3A_data">data</code></td>
<td>
<p> fMRI dataset of class &rdquo;<code>fmridata</code>&rdquo; </p>
</td></tr>
<tr><td><code id="fmri.detrend_+3A_degree">degree</code></td>
<td>
<p> Degree of the polynomial used to detrend the data. defaults to 1 (linear trends). </p>
</td></tr>
<tr><td><code id="fmri.detrend_+3A_nuisance">nuisance</code></td>
<td>
<p> Matrix of additional nuisance parameters to regress against. </p>
</td></tr>
<tr><td><code id="fmri.detrend_+3A_accoef">accoef</code></td>
<td>
<p> Coefficient of AR(1) model used for prewhitening. default 0. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function can be used to detrend the time series of an fMRI dataset <code>data</code> (of class &rdquo;<code>fmridata</code>&rdquo; using polynomials. If the argument <code>degree</code> is larger than 0 (default: 1) the polynomial trends up to the given degree are removed from the data. If the argument <code>accoef</code> is larger than 0 (default: 0) prewhitening using an AR(1) model is performed.
</p>


<h3>Value</h3>

<p>Detrended data object of class &rdquo;<code>fmridata</code>&rdquo;.
</p>


<h3>Author(s)</h3>

<p> Joerg Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a> </p>


<h3>References</h3>

<p>Polzehl, J. and Tabelow, K. (2007).
<em>fmri: A Package for Analyzing fmri Data</em>,
R News, 7:13-17.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fmri.lm">fmri.lm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Example 1
  data &lt;- list(ttt=writeBin(rnorm(32*32*32*107),raw(),4),
               mask=array(1,c(32,32,32)),dim=c(32,32,32,107))
  class(data) &lt;- "fmridata"
  data &lt;- fmri.detrend(data,2)
</code></pre>

<hr>
<h2 id='fmri.lm'> Linear Model for fMRI data </h2><span id='topic+fmri.lm'></span>

<h3>Description</h3>

<p>Estimate the parameters and variances in a linear model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  fmri.lm(ds, z, mask = NULL,
          actype = c("smooth", "noac", "ac", "accalc"),
          contrast = c(1), verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmri.lm_+3A_ds">ds</code></td>
<td>
<p> Data object of class &quot;fmridata&quot; </p>
</td></tr>
<tr><td><code id="fmri.lm_+3A_z">z</code></td>
<td>
<p> Design matrix specifying the expected BOLD response(s)
and additional components for trend and other effects. This can
either be a matrix (in case that no slice timing is required at
this stage) or an 3D - array with 3rd dimension corresponding
to the slice number. It can be interpreted as stacked array of
of design matrices for the individual slices.  </p>
</td></tr>
<tr><td><code id="fmri.lm_+3A_mask">mask</code></td>
<td>
<p> Array of dimensionality of the data describing a (brain) mask
the computation should be restricted to. The default is the
mask given with the data. </p>
</td></tr>
<tr><td><code id="fmri.lm_+3A_actype">actype</code></td>
<td>
<p> String describing the type of handling autocorrelation
of time series. One of &quot;smooth&quot;, &quot;nonac&quot;, &quot;ac&quot;, &quot;accalc&quot;.</p>
</td></tr>
<tr><td><code id="fmri.lm_+3A_contrast">contrast</code></td>
<td>
<p> Contrast vector for the covariates.</p>
</td></tr>
<tr><td><code id="fmri.lm_+3A_verbose">verbose</code></td>
<td>
<p> Verbose mode, default is <code>FALSE</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs parameter estimation in the linear model.
It implements a two step procedure. After primary estimation of the
parameters in the first step residuals are obtained. If <code>actype</code>
<code>%in%</code> <code>c("ac", "accalc", "smooth")</code> an AR(1) model is
fitted, in each voxel, to the time series of residuals. The estimated
AR-coefficients are corrected for bias. If <code>actype=="smooth"</code>
the estimated AR-coefficients are spatially smoothed. If <code>actype</code>
<code>%in%</code> <code>c("ac", "smooth")</code> the linear model is pre-whitened
using the estimated (and possibly smoothed) AR-coefficients. Parameter
and variance estimates are then obtained from the pre-whitened
data. The argument <code>keep</code> describes the amount of data which is
returned. The estimated effects
</p>
<p style="text-align: center;"><code class="reqn">\tilde{\gamma}_i = C^T\tilde{\beta}_i</code>
</p>

<p>and their estimated variances are returned as well as the
residuals and temporal autocorrelation.
<code>cbeta</code> then contains the corresponding parameter
estimates and thus is a vector of corresponding length in each voxel.
</p>
<p>If <code>z</code> is an 3-dimensional array the third component is assumed to
code the design matrix information for the corresponding slice, i.e.
design matrices to differ with respect to slice timing effects. Note that
if motion correction needs to be performed in preprocessing slice time
correction may be better carried out on the data before image registration
using, e.g., function <code><a href="#topic+slicetiming">slicetiming</a></code>.
</p>
<p>If warning &quot;Local smoothness characterized by large bandwidth&quot; occurs,
check <code>scorr</code> elements. If correlation drops with lag towards
zero, data has been pre-smoothed. Adaptive smoothing the SPM can then
only be of limited use. If correlation does not go to zero, check the
residuals of the linear model for unexplained structure (spin saturation
in first scans? discard them!).
</p>


<h3>Value</h3>

<p>object with class attributes &quot;fmrispm&quot; and &quot;fmridata&quot;
</p>
<table>
<tr><td><code>beta</code></td>
<td>
<p>estimated parameters </p>
</td></tr>
<tr><td><code>cbeta</code></td>
<td>
<p>estimated contrast of parameters</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>estimated variance of the contrast of parameters.</p>
</td></tr>
<tr><td><code>varm</code></td>
<td>
<p>covariance matrix of the parameters given by <code>vvector</code></p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>raw (integer size 2) vector containing residuals of the estimated linear model
up to scale factor resscale.</p>
</td></tr>
<tr><td><code>resscale</code></td>
<td>
<p><code>resscale*extractData(object,"residuals")</code> are the residuals. </p>
</td></tr>
<tr><td><code>dim</code></td>
<td>
<p>dimension of the data cube and residuals</p>
</td></tr>
<tr><td><code>arfactor</code></td>
<td>
<p>estimated autocorrelation parameter</p>
</td></tr>
<tr><td><code>rxyz</code></td>
<td>
<p>array of smoothness from estimated correlation for each
voxel in resel space (for analysis without smoothing)</p>
</td></tr>
<tr><td><code>scorr</code></td>
<td>
<p>array of spatial correlations with maximal lags 5, 5, 3 in x,y and z-direction. </p>
</td></tr>
<tr><td><code>bw</code></td>
<td>
<p>vector of bandwidths (in FWHM) corresponding to the spatial correlation within the data.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>ratio of voxel dimensions </p>
</td></tr>
<tr><td><code>vwghts</code></td>
<td>
<p>ratio of estimated variances for the stimuli given by
<code>vvector</code></p>
</td></tr>
<tr><td><code>mask</code></td>
<td>
<p>head mask.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom for t-statistics.</p>
</td></tr>
<tr><td><code>hrf</code></td>
<td>
<p>expected BOLD response for contrast </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a>,
Joerg Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>  </p>


<h3>References</h3>

<p> Worsley, K.J. (2005). Spatial smoothing of autocorrelations
to control the degrees of freedom in fMRI analysis. NeuroImage,
26:635-641.
</p>
<p>Worsley, K.J., Liao, C., Aston, J., Petre, V., Duncan,
G.H., Morales, F., Evans, A.C. (2002). A general statistical analysis
for fMRI data. NeuroImage, 15:1-15.
</p>
<p>Tabelow, K., Polzehl, J., Voss, H.U., and Spokoiny, V. (2006).
<em>Analysing fMRI
experiments with structure adaptive smoothing procedures</em>,
NeuroImage, 33:55-62.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fmri.design">fmri.design</a></code>, <code><a href="#topic+fmri.stimulus">fmri.stimulus</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
  # Example 1
  data &lt;- list(ttt=writeBin(rnorm(32*32*32*107), raw(), 4),
               mask=array(TRUE, c(32, 32, 32)), dim=c(32, 32, 32, 107))
  class(data) &lt;- "fmridata"
  hrf &lt;- fmri.stimulus(107, c(18, 48, 78), 15, 2)
  z &lt;- fmri.design(hrf,2)
  model &lt;- fmri.lm(data, z, verbose=TRUE)
  plot(extractData(data)[16, 16, 16,])
  lines(extractData(data)[16, 16, 16, ] - extractData(model, "residuals")[16, 16, 16, ], col=2)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='fmri.lmePar'> Linear Mixed-effects Model for fMRI data </h2><span id='topic+fmri.lmePar'></span>

<h3>Description</h3>

<p>Group maps are directly estimated from the BOLD time series data of all subjects using <code><a href="nlme.html#topic+lme">lme</a></code> from R package <span class="pkg">nlme</span> to fit a Linear Mixed-effects Model with temporally correlated and heteroscedastic within-subject errors. Voxel-wise regression analysis is accelerated by optional parallel processing using R package <span class="pkg">parallel</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmri.lmePar(bold, z, fixed = NULL, random = NULL, mask = NULL,
            ac = 0.3, vtype = "individual", cluster = 2,
            wghts = c(1, 1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmri.lmePar_+3A_bold">bold</code></td>
<td>
<p> a large 4D-Array with the aggregated fMRI data of all subjects that were previously registered to a common brain atlas. Be careful with the assembly of this array, the order of the data sets has to be compatible with the design matrix: <code>"z"</code>. If not the whole brain but a region is analyzed, vectors with region-indices can be preserved by adding as attributes (e.g. <code>attr(bold, "xind") &lt;- xind</code>).
</p>
</td></tr>
<tr><td><code id="fmri.lmePar_+3A_z">z</code></td>
<td>
<p> a design matrix for a multi-subject and/or multi-session fMRI-study of class <code>"data.frame"</code> specifying the expected BOLD response(s) and additional components for trend and other effects. Typically a <code><a href="#topic+fmri.designG">fmri.designG</a></code> object. This data frame contains all variables named in the model. There are some indispensable variables: <var>&quot;group&quot;</var>, <var>&quot;subj&quot;</var>, <var>&quot;session&quot;</var> and <var>&quot;run&quot;</var>, which define the different strata. That information will be used for setting up the residual variance structure.
</p>
</td></tr>
<tr><td><code id="fmri.lmePar_+3A_fixed">fixed</code></td>
<td>
<p> optionally, a one-sided linear formula describing the fixed-effects part of the model. Default settings are:
<code>fixed &lt;- ~ 0 + hrf + session + drift1:session + drift2:session</code> in case of one detected group, and the same but <code>"hrf"</code> replaced with <code>"hrf:group"</code> if two group levels in <code>z</code> are found. Since an intercept would be a linear combination of the session factor-variable modeling session-specific intercepts, it is excluded.
</p>
</td></tr>
<tr><td><code id="fmri.lmePar_+3A_random">random</code></td>
<td>
<p> optionally, a one-sided formula of the form <code>~ x1 + ... + xn | g1/.../gm</code>, with <code>~ x1 + ... + xn</code> specifying the model for the random effects and <code>g1/.../gm</code> the grouping structure.<br />
</p>
<p>Default is always the basic model without covariates, i.e. <br />
<code>random &lt;- ~ 0 + hrf|subj</code>  if no repeated measures in <code>z</code> are found (<code>nlevels(z$run)==1</code>),<br />
<code>random &lt;- ~ 0 + hrf|subj/session</code>  if repeated measures and<br />
<code>random &lt;- ~ 0 + hrf|session</code>  if repeated measures but one subject only. <br />
In case of two independent groups:<br />
<code>random &lt;- list(subj = pdDiag(~ 0 + hrf:group))</code> is used.
</p>
</td></tr>
<tr><td><code id="fmri.lmePar_+3A_mask">mask</code></td>
<td>
<p> if available, a logical 3D-Array of dimensionality of the data (without time component) describing a brain mask. The computation is restricted to the selected voxels.
</p>
</td></tr>
<tr><td><code id="fmri.lmePar_+3A_ac">ac</code></td>
<td>
<p> if available, a numeric 3D-Array of dimensionality of the data (without time component) with spatially smoothed autocorrelation parameters should be used in the AR(1) models fitted in each voxel, e.g. locally estimated and smoothed AR(1)-coefficients from <code><a href="#topic+fmri.lm">fmri.lm</a></code> applied to the first subject. Alternatively, a global approach with uniform value can be used. In this case enter a number between 0 and 1. Default is <code>0.3</code> applied to all voxels.
</p>
</td></tr>
<tr><td><code id="fmri.lmePar_+3A_vtype">vtype</code></td>
<td>
<p> a character string choosing the residual variance model. If <code>"equal"</code>, homoscedastic variance across subjects is assumed setting weights argument in function <code>lme()</code> to zero, whereas <code>"individual"</code> allows different within-subject variances. Default method is <code>"individual"</code> that means subject-specific error variances using formula: <code>weights &lt;- varIdent(form =~ 1|subj)</code>.
</p>
</td></tr>
<tr><td><code id="fmri.lmePar_+3A_cluster">cluster</code></td>
<td>
<p> number of threads for parallel processing, which is limited to available multi-core CPUs. If you do not know your CPUs, try: <code>detectCores()</code> from <span class="pkg">parallel</span> package. Presets are 2 threads. <code>cluster = 1</code> does not use <span class="pkg">parallel</span> package.
</p>
</td></tr>
<tr><td><code id="fmri.lmePar_+3A_wghts">wghts</code></td>
<td>
<p> a vector of length 3 specifying ratio of voxel dimensions. Isotropic voxels (e.g. MNI-space) are set as default.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fmri.lmePar()</code> fits the configured Linear Mixed-effects Model separately at each voxel and extracts estimated BOLD contrasts, corresponding squared standard errors and degrees of freedom as well as the residuals from resulting <code>lme()</code> objects to produce a statistical parametric map (SPM) for the group(s). Voxel-by-voxel analysis is performed by either the function <code><a href="base.html#topic+apply">apply</a></code> or <code><a href="parallel.html#topic+parApply">parApply</a></code> from <span class="pkg">parallel</span> package, which walks through the <code>bold</code> array.
</p>
<p>If one group is analyzed, from each fitted model the first fixed-effects coefficient and corresponding parameters are stored in results object. This should be the first specified predictor in the fixed-effects part of the model (verify the attribute of <code>"df"</code> in returned object). However, in two-sample case this principle does not work. The order changes, estimated session-specific intercepts now comes first and the number of these coefficients is not fixed. Therefore in current version it has explicitly been looked for the coefficient names: <var>&quot;hrf:group1&quot;</var> and <var>&quot;hrf:group2&quot;</var>. Available functions within the <span class="pkg">nlme</span> package to extract estimated values from <code>lme()</code> objects do not operate at contrast matrices.
</p>
<p>Spatial correlation among voxels, e.g. through the activation of nearby voxels, is ignored at this stage, but corrects for it, when random field theory define a threshold for significant activation at inference stage.
</p>
<p>It is recommended to check your model syntax and residuals choosing some distinct voxels before running the model in loop (see Example, step 1); especially for more advanced designs! Error handling default is to stop if one of the threads produces an error. When this occurs, the output will be lost from any voxel, where the model has fitted successfully.
</p>


<h3>Value</h3>

<p>An object of class <code>"fmrispm"</code> and <code>"fmridata"</code>, basically a list
with components:
</p>
<table>
<tr><td><code>cbeta</code>, <code>cbeta2</code></td>
<td>
<p>estimated BOLD contrast parameters separated for the groups 1 and 2</p>
</td></tr>
<tr><td><code>var</code>, <code>var2</code></td>
<td>
<p>estimated variance of the contrast parameters separated for the groups 1 and 2</p>
</td></tr>
<tr><td><code>mask</code></td>
<td>
<p> brain mask </p>
</td></tr>
<tr><td><code>res</code>, <code>res2</code></td>
<td>
<p>raw (integer size 2) vector containing residuals of the estimated Linear Mixed-effects Model up to scale factor <code>resscale</code> separated for the groups 1 and 2</p>
</td></tr>
<tr><td><code>resscale</code>, <code>resscale2</code></td>
<td>
<p><code>resscale*extractData(object,"residuals")</code> are the residuals of group 1 and group 2 respectively. </p>
</td></tr>
<tr><td><code>arfactor</code></td>
<td>
<p>autocorrelation parameters used in AR(1)-model</p>
</td></tr>
<tr><td><code>rxyz</code>, <code>rxyz2</code></td>
<td>
<p>array of smoothness from estimated correlation for each voxel in resel space separated for the groups 1 and 2 (for analysis without smoothing) </p>
</td></tr>
<tr><td><code>scorr</code>, <code>scorr2</code></td>
<td>
<p>array of spatial correlations with maximal lags 5, 5, 3 in x, y and z-direction separated for the groups 1 and 2 </p>
</td></tr>
<tr><td><code>bw</code>, <code>bw2</code></td>
<td>
<p>vector of bandwidths (in FWHM) corresponding to the spatial correlation within the data separated for the groups 1 and 2</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p> ratio of voxel dimensions </p>
</td></tr>
<tr><td><code>dim</code>, <code>dim2</code></td>
<td>
<p>dimension of the data cube and residuals separated for the groups 1 and 2</p>
</td></tr>
<tr><td><code>df</code>, <code>df2</code></td>
<td>
<p>degrees of freedom for t-statistics reported in <code>lme()</code> objects for the extracted regression coefficients separated for the groups 1 and 2. The name of the coefficient belonging to this df-value appears as attribute.</p>
</td></tr>
<tr><td><code>subjects</code></td>
<td>
<p>number of subjects in the study</p>
</td></tr>
<tr><td><code>subj.runs</code></td>
<td>
<p>number of repeated measures within subjects</p>
</td></tr>
<tr><td><code>sessions</code></td>
<td>
<p>number of total sessions that were analyzed</p>
</td></tr>
<tr><td><code>groups</code></td>
<td>
<p>number of groups in the study</p>
</td></tr>
<tr><td><code>fixedModel</code></td>
<td>
<p>fixed-effects model</p>
</td></tr>
<tr><td><code>randomModel</code></td>
<td>
<p>random-effects model</p>
</td></tr>
<tr><td><code>VarModel</code></td>
<td>
<p>assumption about the subject error variances</p>
</td></tr>
<tr><td><code>cluster</code></td>
<td>
<p>number of threads run in parallel</p>
</td></tr>
<tr><td><code>attr(*</code>, <code>"design")</code></td>
<td>
<p>design matrix for the multi-subject fMRI-study</p>
</td></tr>
<tr><td><code>attr(*</code>, <code>"approach")</code></td>
<td>
<p>one-stage estimation method</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Maybe the computing power is insufficient to carry out a whole brain analysis. You have two opportunities: either select and analyze a certain brain area or switch to a two-stage model.
</p>
<p>Current Limitations<br />
The function cannot handle experimental designs with:
</p>
<ul>
<li><p>more than two independent groups
</p>
</li>
<li><p>more than one stimulus (task)
</p>
</li>
<li><p>paired samples with varying tasks
</p>
</li>
<li><p>user defined contrasts </p>
</li></ul>



<h3>Author(s)</h3>

<p> Sibylle Dames </p>


<h3>References</h3>

<p>Pinheiro J. and Bates D. (2000). Mixed-Effects Models in S and S-Plus. Springer.
</p>
<p>Pinheiro J., Bates D., DebRoy S., Sarkar D. and the R Core team (2014). <em>nlme: Linear and Nonlinear Mixed Effects Models</em> R package version 3.1-117.
</p>


<h3>See Also</h3>

<p><code><a href="nlme.html#topic+lme">lme</a></code>, <code><a href="#topic+fmri.designG">fmri.designG</a></code>,
<code><a href="#topic+fmri.design">fmri.design</a></code>, <code><a href="#topic+fmri.stimulus">fmri.stimulus</a></code>,
<code><a href="#topic+fmri.metaPar">fmri.metaPar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ## Generate some fMRI data sets: noise + stimulus
dx &lt;- dy &lt;- dz &lt;- 32
dt &lt;- 107
hrf &lt;- fmri.stimulus(dt, c(18, 48, 78), 15, 2)
stim &lt;- matrix(hrf, nrow= dx*dy*dz, ncol=dt, byrow=TRUE)
mask &lt;- array(FALSE, c(dx, dy, dz))
mask[12:22,12:22,12:22] &lt;- TRUE

ds1 &lt;- list(ttt=writeBin(1.0*rnorm(dx*dy*dz*dt) + as.vector(5*stim),
            raw(), 4), mask=mask, dim=c(dx, dy, dz, dt))
ds2 &lt;- list(ttt=writeBin(1.7*rnorm(dx*dy*dz*dt) + as.vector(3*stim),
            raw(), 4), mask=mask, dim=c(dx, dy, dz, dt))
ds3 &lt;- list(ttt=writeBin(0.8*rnorm(dx*dy*dz*dt) + as.vector(1*stim),
            raw(), 4), mask=mask, dim=c(dx, dy, dz, dt))
ds4 &lt;- list(ttt=writeBin(1.2*rnorm(dx*dy*dz*dt) + as.vector(2*stim),
            raw(), 4), mask=mask, dim=c(dx, dy, dz, dt))
class(ds1) &lt;- class(ds2) &lt;- class(ds3) &lt;- class(ds4) &lt;- "fmridata"

## Construct a design matrix for a multi-subject study
subj &lt;- 4
runs &lt;- 1
z &lt;-fmri.designG(hrf, subj = subj, runs = runs)

## Assembly of the aggregated BOLD-Array
Bold &lt;- array(0, dim = c(dx,dy,dz,subj*runs*dt))
Bold[1:dx,1:dy,1:dz,1:(dt*1)] &lt;- extractData(ds1)
Bold[1:dx,1:dy,1:dz,(dt*1+1):(dt*2)] &lt;- extractData(ds2)
Bold[1:dx,1:dy,1:dz,(dt*2+1):(dt*3)] &lt;- extractData(ds3)
Bold[1:dx,1:dy,1:dz,(dt*3+1):(dt*4)] &lt;- extractData(ds4)

## Step 1: Check the model
y &lt;- Bold[16, 16, 16, ] # choose one voxel
M1.1 &lt;-  lme(fixed = y ~ 0 + hrf + session + drift1:session + drift2:session,
            random = ~ 0 + hrf|subj,
            correlation = corAR1(value = 0.3, form = ~ 1|subj/session, fixed=TRUE),
            weights = varIdent(form =~ 1|subj),
            method ="REML",
            control = lmeControl(rel.tol=1e-6, returnObject = TRUE),
            data = z)
summary(M1.1)

# Residual plots
plot(M1.1, resid(.,type = "response") ~ scan|subj)
qqnorm(M1.1, ~resid(.,type = "normalized")|subj, abline = c(0,1))

# Testing the assumption of homoscedasticity
M1.2 &lt;- update(M1.1, weights = NULL, data = z)
anova(M1.2, M1.1)

# Model fit: observed and fitted values
fitted.values &lt;- fitted(M1.1)
plot(y[1:dt], type="l", main = "Subject 1", xlab = "scan",
     ylab = "BOLD-signal", ylim = c(-5,5))
lines(fitted.values[names(fitted.values)==1],lty=1,lwd=2)

plot(y[(dt+1):(2*dt)], type="l", main = "Subject 2", xlab = "scan",
     ylab = "BOLD-signal", ylim = c(-5,5))
lines(fitted.values[names(fitted.values)==2],lty=1,lwd=2)

plot(y[(2*dt+1):(3*dt)], type="l", main = "Subject 3", xlab = "scan",
     ylab = "BOLD-signal", ylim = c(-5,5))
lines(fitted.values[names(fitted.values)==3],lty=1,lwd=2)

plot(y[(3*dt+1):(4*dt)], type="l", main = "Subject 4", xlab = "scan",
     ylab = "BOLD-signal", ylim = c(-5,5))
lines(fitted.values[names(fitted.values)==4],lty=1,lwd=2)

## Step 2: Estimate a group map
## without parallelizing
spm.group1a &lt;- fmri.lmePar(Bold, z, mask = mask, cluster = 1)
# same with 4 parallel threads
spm.group1b &lt;- fmri.lmePar(Bold, z, mask = mask, cluster = 4)
## Example for two independent groups
group &lt;- c(1,1,4,4)
z2 &lt;- fmri.designG(hrf, subj = subj, runs = runs, group = group)
spm.group2 &lt;- fmri.lmePar(Bold, z2, mask = mask, cluster = 4)
## End(Not run)
</code></pre>

<hr>
<h2 id='fmri.metaPar'> Linear Mixed-effects Meta-Analysis model for fMRI data </h2><span id='topic+fmri.metaPar'></span>

<h3>Description</h3>

<p>Group maps are estimated from BOLD effect estimates and their variances previously determined for each subject. The function <code><a href="metafor.html#topic+rma.uni">rma.uni</a></code> from R package <span class="pkg">metafor</span> is used to fit mixed-effects meta-analytic models at group level. Voxel-wise regression analysis is accelerated by optional parallel processing using R package <span class="pkg">parallel</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmri.metaPar(Cbold, Vbold, XG = NULL, model = NULL, method = "REML",
             weighted = TRUE, knha = FALSE, mask = NULL, cluster = 2,
             wghts = c(1, 1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmri.metaPar_+3A_cbold">Cbold</code></td>
<td>
<p> a 4D-Array with the aggregated individual BOLD contrast estimates in standard space, e.g. all <code>cbeta</code> maps obtained from single-session analysis with <code><a href="#topic+fmri.lm">fmri.lm</a></code> may put together. Dimensions 1 to 3 define the voxel space, dimension 4 indicates a subject. If not the whole brain but a region is analyzed, vectors with region-indices can be preserved by adding as attributes (e.g. <code>attr(Cbold, "xind") &lt;- xind</code>).
</p>
</td></tr>
<tr><td><code id="fmri.metaPar_+3A_vbold">Vbold</code></td>
<td>
<p> a 4D-Array with the aggregated variance estimates for the contrast parameters in <code>Cbold</code>, e.g. all <code>var</code> maps obtained from single-session analysis with <code><a href="#topic+fmri.lm">fmri.lm</a></code> may put together. Dimensions 1 to 3 define the voxel space, dimension 4 indicates a subject.
</p>
</td></tr>
<tr><td><code id="fmri.metaPar_+3A_xg">XG</code></td>
<td>
<p> optionally, a group-level design matrix of class <code>"data.frame"</code> to include one or more moderators in the model. By default, an intercept is added to the model.
</p>
</td></tr>
<tr><td><code id="fmri.metaPar_+3A_model">model</code></td>
<td>
<p> optionally, a one-sided formula of the form: <code>model &lt;- ~ mod1 + mod2 + mod3</code> describing a model with moderator variables. Adding <code>"-1"</code> removes the intercept term.
</p>
</td></tr>
<tr><td><code id="fmri.metaPar_+3A_method">method</code></td>
<td>
<p> a character string specifying whether a fixed- (method = &quot;FE&quot;) or a random/mixed-effects model (method = &quot;REML&quot;, default) should be fitted. Further estimators for random/mixed-effects models are available, see documentation of <code><a href="metafor.html#topic+rma.uni">rma.uni</a></code> function for more details.
</p>
</td></tr>
<tr><td><code id="fmri.metaPar_+3A_weighted">weighted</code></td>
<td>
<p> logical indicating whether weighted (<code>weighted = TRUE</code>, default) or unweighted estimation should be used to fit the model.
</p>
</td></tr>
<tr><td><code id="fmri.metaPar_+3A_knha">knha</code></td>
<td>
<p> logical specifying whether the method by Knapp and Hartung (2003) should be used for adjusting standard errors of the estimated coefficients (default is FALSE). The Knapp and Hartung adjustment is only meant to be used in the context of random- or mixed-effects models.
</p>
</td></tr>
<tr><td><code id="fmri.metaPar_+3A_mask">mask</code></td>
<td>
<p> if available, a logical 3D-Array of dimensionality of the data (without 4th subject component) describing a brain mask. The computation is restricted to the selected voxels.
</p>
</td></tr>
<tr><td><code id="fmri.metaPar_+3A_cluster">cluster</code></td>
<td>
<p> number of threads for parallel processing, which is limited to available multi-core CPUs. If you do not know your CPUs, try: <code>detectCores()</code> from <span class="pkg">parallel</span> package. Presets are 2 threads. <code>cluster = 1</code> does not use <span class="pkg">parallel</span> package.
</p>
</td></tr>
<tr><td><code id="fmri.metaPar_+3A_wghts">wghts</code></td>
<td>
<p> a vector of length 3 specifying ratio of voxel dimensions. Isotropic voxels (e.g. MNI-space) are set as default.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fmri.metaPar()</code> fits the configured linear mixed-effects meta-analytic (MEMA) model separately at each voxel and extracts the first regression coefficient (usually the overall group mean), corresponding squared standard errors and degrees of freedom as well as the residuals from resulting <code>rma.uni()</code> objects, to obtain a statistical parametric map (SPM) for the group. Voxel-by-voxel analysis is performed by either the function <code><a href="base.html#topic+apply">apply</a></code> or <code><a href="parallel.html#topic+parApply">parApply</a></code> from <span class="pkg">parallel</span> package, which walks through the <code>Cbold</code> array.
</p>
<p>This two-stage approach reduces the computational burden of fitting a full linear mixed-effects (LME) model, <code><a href="#topic+fmri.lmePar">fmri.lmePar</a></code> would do. It assumes first level design is same across subjects and normally distributed not necessarily homogeneous within-subject errors. Warping to standard space has been done before first-stage analyses are carried out. Either no masking or a uniform brain mask should be applied at individual subject analysis level, to avoid loss of information at group level along the edges.
</p>
<p>At the second stage, observed individual BOLD effects from each study are combined in a meta-analytic model. There is the opportunity of weighting the fMRI studies by the precision of their respective effect estimate to take account of first level residual heterogeneity (<code>weighted = TRUE</code>). This is how to deal with intra-subject variability. The REML estimate of cross-subject variability (tau-squared) assumes that each of these observations is drawn independently from the same Gaussian distribution. Since correlation structures cannot be modeled, multi-subject fMRI studies with repeated measures cannot be analyzed in this way.
</p>
<p>Spatial correlation among voxels, e.g. through the activation of nearby voxels, is ignored at this stage, but corrects for it, when random field theory define a threshold for significant activation at inference stage.
</p>
<p>It is recommended to check your model syntax and residuals choosing some distinct voxels before running the model in loop (see Example). Error handling default is to stop if one of the threads produces an error. When this occurs, the output will be lost from any voxel, where the model has fitted successfully.
</p>


<h3>Value</h3>

<p>An object of class <code>"fmrispm"</code> and <code>"fmridata"</code>, basically a list with components:
</p>
<table>
<tr><td><code>beta</code></td>
<td>
<p>estimated regression coefficients</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>estimated standard errors of the coefficients</p>
</td></tr>
<tr><td><code>cbeta</code></td>
<td>
<p>estimated BOLD contrast parameters for the group. Always the first regression coefficient is taken.</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>estimated variance of the BOLD contrast parameters</p>
</td></tr>
<tr><td><code>mask</code></td>
<td>
<p>brain mask</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>raw (integer size 2) vector containing residuals of the estimated linear mixed-effects meta-analytic model up to scale factor <code>resscale</code></p>
</td></tr>
<tr><td><code>resscale</code></td>
<td>
<p><code>resscale*extractData(object,"residuals")</code> are the residuals.</p>
</td></tr>
<tr><td><code>tau2</code></td>
<td>
<p>estimated amount of (residual) heterogeneity. Always 0 when <code>method = "FE"</code>.</p>
</td></tr>
<tr><td><code>rxyz</code></td>
<td>
<p>array of smoothness from estimated correlation for each voxel in resel space (for analysis without smoothing).</p>
</td></tr>
<tr><td><code>scorr</code></td>
<td>
<p>array of spatial correlations with maximal lags 5, 5, 3 in x, y and z-direction</p>
</td></tr>
<tr><td><code>bw</code></td>
<td>
<p>vector of bandwidths (in FWHM) corresponding to the spatial correlation within the data</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>ratio of voxel dimensions</p>
</td></tr>
<tr><td><code>dim</code></td>
<td>
<p>dimension of the data cube and residuals</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>degrees of freedom for t-statistics, df = (n-p-1)</p>
</td></tr>
<tr><td><code>sessions</code></td>
<td>
<p>number of observations entering the meta-analytic model, n</p>
</td></tr>
<tr><td><code>coef</code></td>
<td>
<p>number of coefficients in the meta-analytic model (including the intercept, p+1)</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>estimator used to fit the meta-analytic model. In case of &quot;FE&quot;, it is weighted or unweighted least squares.</p>
</td></tr>
<tr><td><code>weighted</code></td>
<td>
<p>estimation with inverse-variance weights</p>
</td></tr>
<tr><td><code>knha</code></td>
<td>
<p>Knapp and Hartung adjustment</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>meta-analytic regression model</p>
</td></tr>
<tr><td><code>cluster</code></td>
<td>
<p>number of threads running in parallel</p>
</td></tr>
<tr><td><code>attr(*</code>, <code>"design")</code></td>
<td>
<p>group-level design matrix</p>
</td></tr>
<tr><td><code>attr(*</code>, <code>"approach")</code></td>
<td>
<p>two-stage estimation method</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Meta analyses tend to be less powerful for neuroimaging studies, because they only have as many degrees of freedom as number of subjects. If the number of subjects is very small, then it may be impossible to estimate the between-subject variance (tau-squared) with any precision. In this case the fixed effect model may be the only viable option. However, there is also the possibility of using a one-stage model, that includes the full time series data from all subjects and simultaneously estimates subject and group levels parameters (see <code><a href="#topic+fmri.lmePar">fmri.lmePar</a></code>). Although this approach is much more computer intensive, it has the advantage of higher degrees of freedom (&gt; 100) at the end.
</p>
<p>Current Limitations<br />
The function cannot handle:
</p>
<ul>
<li><p>experimental designs with a within-subject (repeated measures) factor
</p>
</li>
<li><p>paired samples with varying tasks, unless the contrast of the two conditions is used as input
</p>
</li></ul>



<h3>Author(s)</h3>

<p> Sibylle Dames </p>


<h3>References</h3>

<p>Chen G., Saad Z.S., Nath A.R., Beauchamp M.S., Cox R.W. (2012). FMRI group analysis combining effect estimates and their variances. NeuroImage, 60: 747-765.
</p>
<p>Knapp G. and Hartung J. (2003). Improved tests for a random effects meta-regression with a single covariate. Statistics in Medicine, 22: 2693-2710.
</p>
<p>Viechtbauer W. (2005). Bias and efficiency of meta-analytic variance estimators in the random-effects model. Journal of Educational and Behavioral Statistics, 30: 261-293.
</p>
<p>Viechtbauer W. (2010). Conducting meta-analyses in R with the metafor package. Journal of Statistical Software, 36(3): 1-48
</p>
<p>Viechtbauer W. (2015). <em>metafor: Meta-Analysis Package for R</em> R package version 1.9-7.
</p>


<h3>See Also</h3>

<p><code><a href="metafor.html#topic+rma.uni">rma.uni</a></code>, <code><a href="#topic+fmri.lm">fmri.lm</a></code>, <code><a href="#topic+fmri.lmePar">fmri.lmePar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ## Generate some fMRI data sets: noise + stimulus
dx &lt;- dy &lt;- dz &lt;- 32
dt &lt;- 107
hrf &lt;- fmri.stimulus(dt, c(18, 48, 78), 15, 2)
stim &lt;- matrix(hrf, nrow= dx*dy*dz, ncol=dt, byrow=TRUE)
mask &lt;- array(FALSE, c(dx, dy, dz))
mask[12:22,12:22,12:22] &lt;- TRUE

ds1 &lt;- list(ttt=writeBin(1.0*rnorm(dx*dy*dz*dt) + as.vector(5*stim),
           raw(), 4), mask = mask, dim = c(dx, dy, dz, dt))
ds2 &lt;- list(ttt=writeBin(1.7*rnorm(dx*dy*dz*dt) + as.vector(3*stim),
           raw(), 4), mask = mask, dim = c(dx, dy, dz, dt))
ds3 &lt;- list(ttt=writeBin(0.8*rnorm(dx*dy*dz*dt) + as.vector(1*stim),
           raw(), 4), mask = mask, dim = c(dx, dy, dz, dt))
ds4 &lt;- list(ttt=writeBin(1.2*rnorm(dx*dy*dz*dt) + as.vector(2*stim),
           raw(), 4), mask = mask, dim = c(dx, dy, dz, dt))
class(ds1) &lt;- class(ds2) &lt;- class(ds3) &lt;- class(ds4) &lt;- "fmridata"

## Stage 1: single-session regression analysis
x &lt;- fmri.design(hrf, order=2)
spm.sub01 &lt;- fmri.lm(ds1, x, mask, actype = "smooth", verbose = TRUE)
spm.sub02 &lt;- fmri.lm(ds2, x, mask, actype = "smooth", verbose = TRUE)
spm.sub03 &lt;- fmri.lm(ds3, x, mask, actype = "smooth", verbose = TRUE)
spm.sub04 &lt;- fmri.lm(ds4, x, mask, actype = "smooth", verbose = TRUE)

## Store observed individual BOLD effects and their variance estimates
subj &lt;- 4
Cbold &lt;- array(0, dim = c(dx, dy, dz, subj))
Cbold[,,,1] &lt;- spm.sub01$cbeta
Cbold[,,,2] &lt;- spm.sub02$cbeta
Cbold[,,,3] &lt;- spm.sub03$cbeta
Cbold[,,,4] &lt;- spm.sub04$cbeta

Vbold &lt;- array(0, dim = c(dx, dy, dz, subj))
Vbold[,,,1] &lt;- spm.sub01$var
Vbold[,,,2] &lt;- spm.sub02$var
Vbold[,,,3] &lt;- spm.sub03$var
Vbold[,,,4] &lt;- spm.sub04$var

## Stage 2: Random-effects meta-regression analysis
## a) Check your model
library(metafor)
M1.1 &lt;- rma.uni(Cbold[16,16,16, ],
                Vbold[16,16,16, ],
                method = "REML",
                weighted = TRUE,
                knha = TRUE,
                verbose = TRUE,
                control = list(stepadj=0.5, maxiter=2000, threshold=0.001))

# Control list contains convergence parameters later used
# at whole data cube. Values were adjusted to fMRI data.

summary(M1.1)
forest(M1.1)
qqnorm(M1.1)

## b) Estimate a group map
## without parallelizing
spm.group1a &lt;- fmri.metaPar(Cbold, Vbold, knha = TRUE,
                            mask = mask, cluster = 1)
## same with 4 parallel threads
spm.group1b &lt;- fmri.metaPar(Cbold, Vbold, knha = TRUE,
                            mask = mask, cluster = 4)
## End(Not run)
</code></pre>

<hr>
<h2 id='fmri.pvalue'> P-values </h2><span id='topic+fmri.pvalue'></span>

<h3>Description</h3>

<p>Determine p-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmri.pvalue(spm, mode="basic", na.rm=FALSE, minimum.signal = 0, alpha= 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmri.pvalue_+3A_spm">spm</code></td>
<td>
 <p><code>fmrispm</code> object </p>
</td></tr>
<tr><td><code id="fmri.pvalue_+3A_mode">mode</code></td>
<td>
<p> type of pvalue definition</p>
</td></tr>
<tr><td><code id="fmri.pvalue_+3A_na.rm">na.rm</code></td>
<td>
<p><code>na.rm</code> specifies how NA's in the SPM are handled. NA's may occur
in voxel where the time series information did not allow for estimating parameters and their variances
or where the time series information where constant over time. A high (1e19) value of the variance
and a parameter of 0 are used to characterize NA's. If <code>na.rm=TRUE</code> the pvalue for the corresponding voxels
is set to 1. Otherwise pvalues are assigned according to the information found in the SPM at the voxel.</p>
</td></tr>
<tr><td><code id="fmri.pvalue_+3A_minimum.signal">minimum.signal</code></td>
<td>
<p>allows to specify a (positive) minimum value for detected signals. If minimum.signal &gt;0
the thresholds are to conservative, this case needs further improvements.</p>
</td></tr>
<tr><td><code id="fmri.pvalue_+3A_alpha">alpha</code></td>
<td>
<p>Significance level in case of <code>mode="FDR"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If only a contrast is given in <code>spm</code>, we simply use a t-statistic
and define p-values according to random field theory for the resulting gaussian
field (sufficiently large number of df - see ref.). If <code>spm</code> is a
vector of length larger than one for each voxel, a chisq field is
calculated and evaluated (see
Worsley and Taylor (2006)). If <code>delta</code> is given, a cone statistics is
used.
</p>
<p>The parameter <code>mode</code> allows for different kinds of p-value
calculation. <code>mode="voxelwise"</code> refers to voxelwise tests while
<code>mode="Bonferroni"</code> adjusts the significance level for multiple testing.
An alternative is <code>mode="FDR"</code> specifying signal detection by False
Discovery Rate (FDR) with proportion of false positives level specified by <code>alpha</code>.
The other choices apply results on excursion sets of random fields
(Worsley 1994, Adler 2003) for smoothed SPM's.
&quot;basic&quot; corresponds to a global definition of the
resel counts based on the amount of smoothness achieved by an equivalent
Gaussian filter. The propagation condition ensures, that under the
hypothesis
</p>
<p style="text-align: center;"><code class="reqn">\hat{\Theta} = 0</code>
</p>

<p>adaptive smoothing performs like a
non adaptive filter with the same kernel function which justifies this
approach. &quot;local&quot;
corresponds to a more conservative setting, where the p-value is
derived from the estimated local resel counts that has been achieved by
adaptive smoothing. In contrast to &quot;basic&quot;, &quot;global&quot; takes a global
median to adjust for the randomness of the weighting scheme generated
by adaptive smoothing. &quot;global&quot; and &quot;local&quot; are more conservative than
&quot;basic&quot;, that is, they generate slightly larger p-values.</p>


<h3>Value</h3>

<p>Object with class attributes &quot;fmripvalue&quot; and &quot;fmridata&quot;
</p>
<table>
<tr><td><code>pvalue</code></td>
<td>
<p> p-value. use with <code><a href="graphics.html#topic+plot">plot</a></code> for thresholding.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p> voxelsize ratio </p>
</td></tr>
<tr><td><code>dim</code></td>
<td>
<p> data dimension </p>
</td></tr>
<tr><td><code>hrf</code></td>
<td>
<p> expected BOLD response for contrast (single stimulus only)</p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p>maximal pvalue as scale information</p>
</td></tr>
<tr><td><code>thresh</code></td>
<td>
<p>actual threshold used</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Unexpected side effects may occur if spm does not meet the
requirements, especially if a parameter estimate vector of length greater than 2 through
argument <code>vvector</code> in <code><a href="#topic+fmri.lm">fmri.lm</a></code> has been produced for every voxel.</p>


<h3>Author(s)</h3>

<p> Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a> </p>


<h3>References</h3>

<p>Polzehl, J. and Tabelow, K. (2007)
<em>fmri: A Package for Analyzing fmri Data</em>,
R News, 7:13-17 .
</p>
<p>Tabelow, K., Polzehl, J., Voss, H.U., and Spokoiny, V. (2006).
<em>Analysing fMRI
experiments with structure adaptive smoothing procedures</em>,
NeuroImage, 33:55-62.
</p>
<p>Worsley, K.J., and Taylor, J.E., <em>Detecting fMRI activation
allowing for unknown latency of the hemodynamic response</em>,
NeuroImage 29:649-654 (2006).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fmri.lm">fmri.lm</a></code>,  <code><a href="#topic+fmri.smooth">fmri.smooth</a></code>, <code><a href="#topic+plot.fmridata">plot.fmridata</a></code>,
<code><a href="#topic+fmri.cluster">fmri.cluster</a></code>, <code><a href="#topic+fmri.searchlight">fmri.searchlight</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: fmri.pvalue(smoothresult)
</code></pre>

<hr>
<h2 id='fmri.searchlight'>
Searchlight signal detection
</h2><span id='topic+fmri.searchlight'></span>

<h3>Description</h3>

<p>Detection of activated regions using searchlights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmri.searchlight(spm, alpha = 0.05, radius, minimum.signal = 0,
   kind = c("abs", "squared"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmri.searchlight_+3A_spm">spm</code></td>
<td>

<p><code>fmrispm</code> object
</p>
</td></tr>
<tr><td><code id="fmri.searchlight_+3A_alpha">alpha</code></td>
<td>

<p>multiple test (over volume) adjusted significance level.
</p>
</td></tr>
<tr><td><code id="fmri.searchlight_+3A_radius">radius</code></td>
<td>

<p>radius of searchlight. Value needs to be larger or equal than 1.
</p>
</td></tr>
<tr><td><code id="fmri.searchlight_+3A_minimum.signal">minimum.signal</code></td>
<td>

<p>allows to specify a (positive) minimum value for detected signals. If minimum.signal &gt;0
the thresholds are to conservative, this case needs further improvements.
</p>
</td></tr>
<tr><td><code id="fmri.searchlight_+3A_kind">kind</code></td>
<td>

<p>Kind of statistics used for aggregation over search light region.
<code>"abs"</code> specifies averaging of absolute voxelwise t-statistics
while <code>"squared"</code> corresponds to averaging of squares of these statistics.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes mean statistics (depending on <code>kind</code>) over a
searchlight region of radius <code>radius</code>.
Approximate voxelwise p-values are determined with respect an empirical
(simulated) distribution of the searchlight statistics under the null hypothesis
a central t-distributed spm. Thresholding used <code>FDR</code> with rate <code>alpha</code>.
</p>


<h3>Value</h3>

<p>Object with class attributes &quot;fmripvalue&quot; and &quot;fmridata&quot;
</p>
<table>
<tr><td><code>pvalue</code></td>
<td>
<p> voxelwise p-value if exceeding FDR-critical value, 1 otherwise.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p> voxelsize ratio </p>
</td></tr>
<tr><td><code>dim</code></td>
<td>
<p> data dimension </p>
</td></tr>
<tr><td><code>hrf</code></td>
<td>
<p> expected BOLD response for contrast (single stimulus only)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joerg Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>References</h3>

<p>Kriegeskorte, N.; Goebel, R. &amp; Bandettini, P. (2006) <em>Information-based functional brain mapping</em>, PNAS 103:3863-3868.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fmri.lm">fmri.lm</a></code>, <code><a href="#topic+fmri.pvalue">fmri.pvalue</a></code>, <code><a href="#topic+fmri.cluster">fmri.cluster</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: fmri.searchlight(fmrispmobj)
</code></pre>

<hr>
<h2 id='fmri.sgroupICA'>
Spatial group ICA for fmri
</h2><span id='topic+fmri.sgroupICA'></span>

<h3>Description</h3>

<p>Combine ICA results from multiple runs or multiple subjects
in group fMRI studies
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmri.sgroupICA(icaobjlist, thresh = 0.75, minsize=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmri.sgroupICA_+3A_icaobjlist">icaobjlist</code></td>
<td>

<p>List of results obtained by function <code><a href="#topic+fmri.sICA">fmri.sICA</a></code>
for a series of fmri data sets (multiple runs or multiple subjects).
</p>
</td></tr>
<tr><td><code id="fmri.sgroupICA_+3A_thresh">thresh</code></td>
<td>

<p>threshold for cluster aggregation. Needs to be in (0,1).
</p>
</td></tr>
<tr><td><code id="fmri.sgroupICA_+3A_minsize">minsize</code></td>
<td>

<p>Minimal size of cluster to consider in IC aggregation. Needs to be
larger than 1.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fMRI time series need to be preprocessed and registered
before thr ICA decomposition is performed.
</p>
<p>The function employs a hierarchical clustering algorithm (complete
linkage) on the combined set of spatial independent components
obtained from the individual time series. A distance matrix is obtained from
correlations of the independent component images. Aggregation of two components from
the same fmri series is prevented in the algorithm.
</p>


<h3>Value</h3>

<p>An object of class &rdquo;<code>fmrigroupICA</code>&rdquo; with components
</p>
<table>
<tr><td><code>icacomp</code></td>
<td>
<p>Mean IC's over cluster members for cluster of size larger
or equal <code>minsize</code></p>
</td></tr>
<tr><td><code>size</code></td>
<td>
<p>Size of selected clusters</p>
</td></tr>
<tr><td><code>cl</code></td>
<td>
<p>Number of selected clusters</p>
</td></tr>
<tr><td><code>cluster</code></td>
<td>
<p>Cluster membership corresponding to <code>thresh</code>.</p>
</td></tr>
<tr><td><code>height</code></td>
<td>
<p>Distance value at which the cluster was created.
Elements correspond to elements of cluster.</p>
</td></tr>
<tr><td><code>hdm</code></td>
<td>
<p>Object returned by function <code><a href="stats.html#topic+hclust">hclust</a></code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joerg Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>References</h3>

<p>F. Esposito et al (2005) Independent component analysis of fMRI group studies by
self-organizing clustering, Neuroimage, pp. 193-205.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fmri.sICA">fmri.sICA</a></code>, <code><a href="#topic+plot.fmrigroupICA">plot.fmrigroupICA</a></code>, <code><a href="stats.html#topic+hclust">hclust</a></code>
</p>

<hr>
<h2 id='fmri.sICA'>Spacial ICA for fmri data</h2><span id='topic+fmri.sICA'></span>

<h3>Description</h3>

<p> Uses fastICA to perform spatial ICA on fMRI data.</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmri.sICA(data, mask=NULL, ncomp=20,
  alg.typ=c("parallel","deflation"), fun=c("logcosh","exp"),
  alpha=1, detrend=TRUE, degree=2, nuisance= NULL, ssmooth=TRUE,
  tsmooth=TRUE, bwt=4, bws=8, unit=c("FWHM","SD"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmri.sICA_+3A_data">data</code></td>
<td>
<p> fMRI dataset of class &rdquo;<code>fmridata</code>&rdquo; </p>
</td></tr>
<tr><td><code id="fmri.sICA_+3A_mask">mask</code></td>
<td>
<p> Brain mask, if <code>NULL</code> then <code>data$mask</code> is used. </p>
</td></tr>
<tr><td><code id="fmri.sICA_+3A_ncomp">ncomp</code></td>
<td>
<p>Number of ICA components to compute.</p>
</td></tr>
<tr><td><code id="fmri.sICA_+3A_alg.typ">alg.typ</code></td>
<td>
<p>Alg. to be used in <code>fastICA</code>.</p>
</td></tr>
<tr><td><code id="fmri.sICA_+3A_fun">fun</code></td>
<td>
<p>Test functions to be used in <code>fastICA</code>.</p>
</td></tr>
<tr><td><code id="fmri.sICA_+3A_alpha">alpha</code></td>
<td>
<p>Scale parameter in test functions, see <code>fastICA</code>.</p>
</td></tr>
<tr><td><code id="fmri.sICA_+3A_detrend">detrend</code></td>
<td>
<p>Trend removal (polynomial)</p>
</td></tr>
<tr><td><code id="fmri.sICA_+3A_degree">degree</code></td>
<td>
<p>degree of polynomial trend</p>
</td></tr>
<tr><td><code id="fmri.sICA_+3A_nuisance">nuisance</code></td>
<td>
<p> Matrix of additional nuisance parameters to regress against. </p>
</td></tr>
<tr><td><code id="fmri.sICA_+3A_ssmooth">ssmooth</code></td>
<td>
<p> Should spatial smoothing be used for variance reduction</p>
</td></tr>
<tr><td><code id="fmri.sICA_+3A_tsmooth">tsmooth</code></td>
<td>
<p> Should temporal smoothing be be applied</p>
</td></tr>
<tr><td><code id="fmri.sICA_+3A_bws">bws</code></td>
<td>
<p>Bandwidth for spatial Gaussian kernel</p>
</td></tr>
<tr><td><code id="fmri.sICA_+3A_bwt">bwt</code></td>
<td>
<p>Bandwidth for temporal Gaussian kernel</p>
</td></tr>
<tr><td><code id="fmri.sICA_+3A_unit">unit</code></td>
<td>
<p>Unit of bandwidth, either standard deviation (SD) of Full Width Half Maximum (FWHM).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If specified polynomial trends and effects due to nuisance parameters, e.g.,
motion parameters, are removed. If <code>smooth==TRUE</code> the resulting residual series is
spatially smoothed using a Gaussian kernel with specified bandwidth.
ICA components are the estimated using fastICA based on data within brain mask.
The components of the result are related as <code>XKW=scomp[mask,]</code> and <code>X=scomp[mask,]*A</code>.
</p>


<h3>Value</h3>

<p>object of class &rdquo;<code>fmriICA</code>&rdquo;
list with components
</p>
<table>
<tr><td><code>scomp</code></td>
<td>
<p>4D array with ICA component images. Last index varies over components. </p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>pre-processed data matrix</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>pre-processed data matrix</p>
</td></tr>
<tr><td><code>W</code></td>
<td>
<p>estimated un-mixing matrix</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>estimated mixing matrix</p>
</td></tr>
<tr><td><code>mask</code></td>
<td>
<p>Brain mask</p>
</td></tr>
<tr><td><code>pixdim</code></td>
<td>
<p>voxelsize</p>
</td></tr>
<tr><td><code>TR</code></td>
<td>
<p>Repetition Time (TR)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Joerg Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.fmriICA">plot.fmriICA</a></code>,<code><a href="#topic+ICAfingerprint">ICAfingerprint</a></code>, <code><a href="fastICA.html#topic+fastICA">fastICA</a></code> </p>

<hr>
<h2 id='fmri.smooth'> Smoothing Statistical Parametric Maps </h2><span id='topic+fmri.smooth'></span>

<h3>Description</h3>

<p>Perform the adaptive weights smoothing procedure 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmri.smooth(spm, hmax = 4, adaptation="aws",
            lkern="Gaussian", skern="Plateau", weighted=TRUE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmri.smooth_+3A_spm">spm</code></td>
<td>
<p> object of class <code>fmrispm</code> </p>
</td></tr>
<tr><td><code id="fmri.smooth_+3A_hmax">hmax</code></td>
<td>
<p> maximum bandwidth to smooth </p>
</td></tr>
<tr><td><code id="fmri.smooth_+3A_adaptation">adaptation</code></td>
<td>
<p> character, type of adaptation. If <code>"none"</code> adaptation is off and non-adaptive 
kernel smoothing with <code>lkern</code> and bandwidth <code>hmax</code> is used. 
Other values are <code>"aws"</code> for adaptive smoothing using an approximative correction term for spatial smoothness in the penalty (fast), <code>"fullaws"</code> for adaptive smoothing using variance
estimates from smoothed residuals in the penalty (CPU-time about twice 
the time compared to <code>adaptation="aws"</code> and <code>"segment"</code> for a
new approach based on segmentation using multi-scale tests.</p>
</td></tr>
<tr><td><code id="fmri.smooth_+3A_lkern">lkern</code></td>
<td>
 <p><code>lkern</code> specifies the location kernel. Defaults to
&quot;Gaussian&quot;, other choices are &quot;Triangle&quot; and &quot;Plateau&quot;. Note that the location kernel is applied to
<code>(x-x_j)^2/h^2</code>, i.e. the use of &quot;Triangle&quot; corresponds to the
Epanechnicov kernel in nonparametric kernel regression. &quot;Plateau&quot; specifies a kernel that is equal to 1 in the interval (0,.3),
decays linearly in (.5,1) and is 0 for arguments larger than 1.
</p>
</td></tr>
<tr><td><code id="fmri.smooth_+3A_skern">skern</code></td>
<td>
 <p><code>skern</code> specifies the kernel for the statistical
penalty. Defaults to &quot;Plateau&quot;, the alternatives are &quot;Triangle&quot; and &quot;Exp&quot;.
&quot;Plateau&quot; specifies a kernel that is equal to 1 in the interval (0,.3),
decays linearly in (.3,1) and is 0 for arguments larger than 1.
<code>lkern="Plateau"</code> and <code>lkern="Triangle"</code> allow for much faster computation (saves up
to 50% CPU-time). <code>lkern="Plateau"</code> produces a less random weighting scheme.</p>
</td></tr>
<tr><td><code id="fmri.smooth_+3A_weighted">weighted</code></td>
<td>
 <p><code>weighted</code> (logical) determines if weights contain the inverse of local 
variances as a factor (Weighted Least Squares). <code>weighted=FALSE</code> does not employ the
heteroscedasticity of variances for the weighting scheme and is preferable if variance estimates
are highly variable, e.g. for short time series.</p>
</td></tr>
<tr><td><code id="fmri.smooth_+3A_...">...</code></td>
<td>
<p>Further internal arguments for the smoothing algorithm usually not
to be set by the user. Allows e.g. for parameter adjustments by
simulation using our propagation condition. Useful exceptions
can be used for <code>adaptation="segment"</code>: Specifically
<code>alpha</code> (default 0.05) defines the significance level for the
signal detection. It can be chosen between 0.01 and 0.2 as for
other values we did not determine the critical values for the
statistical tests. <code>delta</code> (default 0) defines the minimum
signal which should be detected. 
<code>restricted</code> determines if smoothing for voxel detected to be significant is restricted to use only voxel from the same segment. The 
default is <code>restricted=FALSE</code>. <code>restricted</code> slightly changes 
the behaviour under the alternative, i.e. not the interpretation of results.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs the smoothing on the Statistical Parametric Map
spm.
</p>
<p><code>hmax</code> is the (maximal) bandwidth used in the last iteration. Choose
<code>adaptation</code> as <code>"none"</code> for non adaptive
smoothing. <code>lkern</code> can be used for specifying the
localization kernel. For comparison with non adaptive methods use
&quot;Gaussian&quot; (hmax times the voxelsize in x-direction will give the FWHM bandwidth in mm), 
for better adaptation use &quot;Plateau&quot; or &quot;Triangle&quot;
(default, hmax given in voxel). For <code>lkern="Plateau"</code> and <code>lkern="Triangle"</code> thresholds may be inaccurate, due to a violation of
the Gaussian random field assumption under homogeneity. <code>lkern="Plateau"</code> 
is expected to provide best results with adaptive smoothing.
</p>
<p><code>skern</code> can be used for specifying the
kernel for the statistical penalty. &quot;Plateau&quot; is expected to provide the best results,
due to a less random weighting scheme.
</p>
<p>The function handles zero variances by assigning a large value (1e20)
to these variances. Smoothing is restricted to voxel with <code>spm$mask</code>.
</p>


<h3>Value</h3>

<p>object with class attributes &quot;fmrispm&quot; and &quot;fmridata&quot;, or &quot;fmrisegment&quot; and &quot;fmridata&quot; for segmentation choice
</p>
<table>
<tr><td><code>cbeta</code></td>
<td>
<p> smoothed parameter estimate</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p> variance of the parameter</p>
</td></tr>
<tr><td><code>hmax</code></td>
<td>
<p> maximum bandwidth used</p>
</td></tr>
<tr><td><code>rxyz</code></td>
<td>
<p> smoothness in resel space. all directions </p>
</td></tr>
<tr><td><code>rxyz0</code></td>
<td>
<p> smoothness in resel space as would be achieved by
a Gaussian filter with the same bandwidth. all directions </p>
</td></tr>
<tr><td><code>scorr</code></td>
<td>
<p>array of spatial correlations with maximal lags 5, 5, 3 in x,y and z-direction. </p>
</td></tr>
<tr><td><code>bw</code></td>
<td>
<p>vector of bandwidths (in FWHM) corresponding to the spatial correlation within the data.</p>
</td></tr>
<tr><td><code>dim</code></td>
<td>
<p>dimension of the data cube and residuals</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p> ratio of voxel dimensions </p>
</td></tr>
<tr><td><code>vwghts</code></td>
<td>
<p> ratio of estimated variances for the stimuli given by
<code>vvector</code></p>
</td></tr>
<tr><td><code>hrf</code></td>
<td>
<p> Expected BOLD response for the specified effect </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Joerg Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>,
Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a>  </p>


<h3>References</h3>

<p>Polzehl, J., Voss, H.U., and Tabelow, K. (2010).
<em>Structural Adaptive Segmentation for Statistical Parametric Mapping</em>,
NeuroImage, 52:515-523.
</p>
<p>Tabelow, K., Polzehl, J., Voss, H.U., and Spokoiny, V. (2006). 
<em>Analysing fMRI
experiments with structure adaptive smoothing procedures</em>,
NeuroImage, 33:55-62. 
</p>
<p>Polzehl, J. and Spokoiny, V. (2006). <em>Propagation-Separation
Approach for Local Likelihood Estimation</em>, Probab. Theory
Relat. Fields 135:335-362. 
</p>
<p>Polzehl, J. and Tabelow, K. (2007)
<em>fmri: A Package for Analyzing fmri Data</em>,
R News, 7:13-17 .
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: fmri.smooth(spm, hmax = 4, lkern = "Gaussian")
</code></pre>

<hr>
<h2 id='fmri.stimulus'> Linear Model for FMRI Data </h2><span id='topic+fmri.stimulus'></span>

<h3>Description</h3>

<p>Create the expected BOLD response for a given task indicator function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  fmri.stimulus(scans = 1, onsets = c(1), durations = c(1), TR = 2,
                times = FALSE, sliceorder = NULL,
                type = c("canonical", "gamma", "boxcar", "user"),
                par = NULL, scale = 10, hrf = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmri.stimulus_+3A_scans">scans</code></td>
<td>
<p> number of scans </p>
</td></tr>
<tr><td><code id="fmri.stimulus_+3A_onsets">onsets</code></td>
<td>
<p> vector of onset times (in scans) </p>
</td></tr>
<tr><td><code id="fmri.stimulus_+3A_durations">durations</code></td>
<td>
<p> vector of duration of ON stimulus in scans 
(if <code>times==FALSE)</code>) or
seconds (if <code>times==TRUE)</code>)  </p>
</td></tr>
<tr><td><code id="fmri.stimulus_+3A_tr">TR</code></td>
<td>
<p> time between scans in seconds (TR) </p>
</td></tr>
<tr><td><code id="fmri.stimulus_+3A_times">times</code></td>
<td>
<p> logical. If TRUE onsets and durations are given in units of time not number of scans. Defaults to FALSE. </p>
</td></tr>
<tr><td><code id="fmri.stimulus_+3A_sliceorder">sliceorder</code></td>
<td>
<p> order of slice acquisition. If provided separate
expected bold responses are calculated for the slices taking slice
acquisition times into account. Default: no slice timing.
</p>
</td></tr>
<tr><td><code id="fmri.stimulus_+3A_type">type</code></td>
<td>
<p>One of <code>"canonical"</code>, <code>"gamma"</code>, <code>"boxcar"</code>,
<code>"user"</code></p>
</td></tr>
<tr><td><code id="fmri.stimulus_+3A_par">par</code></td>
<td>
<p> Possible parameters to the HRF. </p>
</td></tr>
<tr><td><code id="fmri.stimulus_+3A_scale">scale</code></td>
<td>
<p> Temporal undersampling factor </p>
</td></tr>
<tr><td><code id="fmri.stimulus_+3A_hrf">hrf</code></td>
<td>
<p> If <code>type</code> is <code>"user"</code> this should be a function evaluating the hemodynamic response function </p>
</td></tr>
<tr><td><code id="fmri.stimulus_+3A_verbose">verbose</code></td>
<td>
<p> Report more if <code>TRUE</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions calculates the expected BOLD response for the task
indicator function given by the argument as a convolution with the
hemodynamic response function.
</p>
<p>If <code>sliceorder</code> provides an ordering of slice acquisitions a matrix of
expected Bold responses with columns corresponding to the slice number is
computed.
</p>
<p>For <code>type</code> is <code>"canonical"</code> the latter is modelled by the difference
between two gamma functions as given in the reference (with the defaults
for a1, a2, b1, b2, cc given therein):
</p>
<p style="text-align: center;"><code class="reqn">\left(\frac{t}{d_1}\right)^{a_1} \exp \left(-\frac{t-d_1}{b_1}\right)
- c \left(\frac{t}{d_2}\right)^{a_2} \exp
\left(-\frac{t-d_2}{b_2}\right) </code>
</p>

<p>The parameters <code>a1</code>, <code>a2</code>, <code>b1</code>, <code>b2</code>, <code>cc</code> of this function
can be changed through the argument <code>par</code> in this order.
</p>
<p>Other choices are a simple gamma function
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{k\tau_h (k-1)!} \left( \frac{t}{\tau_h} \right)^k
        \exp \left( - \frac{t}{\tau_h} \right)</code>
</p>

<p>or the <code>"boxcar"</code> stimulus, or a user defined function <code>hrf</code>.
</p>
<p>The dimension  of the function value is set to <code>c(scans, 1)</code>.
</p>
<p>If <code>!is.null(times)</code> durations are specified in seconds.
</p>


<h3>Value</h3>

<p>Vector with dimension <code>c(scans, 1)</code> or a matrix with dimension
<code>c(scans, number of slices)</code>.
</p>


<h3>Author(s)</h3>

<p> Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a>,
Joerg Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a> </p>


<h3>References</h3>

<p> Worsley, K.J., Liao, C., Aston, J., Petre, V., Duncan,
G.H., Morales, F., Evans, A.C. (2002). A general statistical analysis
for fMRI data. NeuroImage, 15:1-15.
</p>
<p>Polzehl, J. and Tabelow, K. (2007)
<em>fmri: A Package for Analyzing fmri Data</em>,
R News, 7:13-17 .
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fmri.design">fmri.design</a></code>, <code><a href="#topic+fmri.lm">fmri.lm</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Example 1
  hrf &lt;- fmri.stimulus(107, c(18, 48, 78), 15, 2)
  z &lt;- fmri.design(hrf, 2)
  par(mfrow=c(2, 2))
  for (i in 1:4) plot(z[, i], type="l")

</code></pre>

<hr>
<h2 id='gen_fmridata'>Generate fmridata example</h2><span id='topic+gen_fmridata'></span>

<h3>Description</h3>

<p>Generate fmridata example
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_fmridata(signal = 1.5, noise = 20, arfactor = 0.3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_fmridata_+3A_signal">signal</code></td>
<td>
<p>Level of signal in the data</p>
</td></tr>
<tr><td><code id="gen_fmridata_+3A_noise">noise</code></td>
<td>
<p>Level of noise in the data</p>
</td></tr>
<tr><td><code id="gen_fmridata_+3A_arfactor">arfactor</code></td>
<td>
<p>Autoregressive factor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>fmridata</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gen_fmridata()

</code></pre>

<hr>
<h2 id='getSearchlightPattern'>
Extract searchlight pattern from a SPM
</h2><span id='topic+getSearchlightPattern'></span>

<h3>Description</h3>

<p>For a provided spm object and a mask of voxel the function extracts
the values of the parameter estimates within the searchlight region
and for all voxel in the mask.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSearchlightPattern(spm, voxel, radius)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSearchlightPattern_+3A_spm">spm</code></td>
<td>

<p>an object of class 'fmrispm'
</p>
</td></tr>
<tr><td><code id="getSearchlightPattern_+3A_voxel">voxel</code></td>
<td>

<p>a mask (logical) with dimensionality compatible to the spm
</p>
</td></tr>
<tr><td><code id="getSearchlightPattern_+3A_radius">radius</code></td>
<td>

<p>radius of the searchlight
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an array of dimension  c(nb, nsl, nvox)
with nb the number of estimated parameters in spm$beta,
nsl the number of voxel in the searchlight and
nvox the number of voxel in the mask provided as second argument
</p>


<h3>Author(s)</h3>

<p>Joerg Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fmri.searchlight">fmri.searchlight</a></code>, <code><a href="#topic+fmri.lm">fmri.lm</a></code>~~~
</p>

<hr>
<h2 id='hvred'>
Translation between smoothness and bandwidth for Gaussian kernel
</h2><span id='topic+hvred'></span>

<h3>Description</h3>

<p>Translation table between smoothness and bandwidth for Gaussian kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(hvred)</code></pre>


<h3>Format</h3>

<p>The format is:
num [1:500, 1:2] 0.101 0.102 0.103 0.104 0.105 ...
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hvred)
## maybe str(hvred) ; plot(hvred) ...
</code></pre>

<hr>
<h2 id='ICAfingerprint'>
IC fingerprinting
</h2><span id='topic+ICAfingerprint'></span>

<h3>Description</h3>

<p>Implements ICA fingerprinting mainly following De Martino et.al., Neuroimage 2007.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ICAfingerprint(icaobj, nbin = 256, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ICAfingerprint_+3A_icaobj">icaobj</code></td>
<td>

<p>object returned by function <code>fmri.sICA</code>.
</p>
</td></tr>
<tr><td><code id="ICAfingerprint_+3A_nbin">nbin</code></td>
<td>

<p>number of bins for entropy estimation
</p>
</td></tr>
<tr><td><code id="ICAfingerprint_+3A_plot">plot</code></td>
<td>

<p>provide results as star plots.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For some characteristics normalization of values differs from De Martino et. al..
Frequency bands are obtained from periodogram estimated instead of using Welch's method.
</p>


<h3>Value</h3>

<p>object of class &rdquo;<code>fmriICA</code>&rdquo;
list with components
</p>
<table>
<tr><td><code>scomp</code></td>
<td>
<p>4D array with ICA component images. Last index varies over components. </p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>pre-processed data matrix</p>
</td></tr>
<tr><td><code>K</code></td>
<td>
<p>pre-processed data matrix</p>
</td></tr>
<tr><td><code>W</code></td>
<td>
<p>estimated un-mixing matrix</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>estimated mixing matrix</p>
</td></tr>
<tr><td><code>mask</code></td>
<td>
<p>Brain mask</p>
</td></tr>
<tr><td><code>pixdim</code></td>
<td>
<p>voxelsize</p>
</td></tr>
<tr><td><code>TR</code></td>
<td>
<p>Repetition Time (TR)</p>
</td></tr>
<tr><td><code>fingerprint</code></td>
<td>
<p>matrix of IC characteristics. Columns correspond to IC's .</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joerg Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>References</h3>

<p>De Martino et. al., Classification of fMRI independent components using IC-fingerprints
and support vector machine classifiers, Neuroimage 34 (2007) 177-194.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fmri.sICA">fmri.sICA</a></code>, <code><a href="#topic+plot.fmriICA">plot.fmriICA</a></code>, <code><a href="fastICA.html#topic+fastICA">fastICA</a></code>
</p>

<hr>
<h2 id='niftiImage2fmri'>Create fmridata object from niftiImage
</h2><span id='topic+niftiImage2fmri'></span>

<h3>Description</h3>

<p>Transforms a niftiImage (created by readNifti from package RNiftyReg) into
an object with class fmridata
</p>


<h3>Usage</h3>

<pre><code class='language-R'>niftiImage2fmri(niftiobj, level = 0.75, mask=NULL, setmask = TRUE, indx = NULL,
   indy = NULL, indz = NULL, avoidnegs = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="niftiImage2fmri_+3A_niftiobj">niftiobj</code></td>
<td>

<p>an object of class niftiImage
</p>
</td></tr>
<tr><td><code id="niftiImage2fmri_+3A_level">level</code></td>
<td>

<p>quantile used in mask definition
</p>
</td></tr>
<tr><td><code id="niftiImage2fmri_+3A_mask">mask</code></td>
<td>
<p>array or nifti-object containing the mask. If set this replaces
the mask defined by argument level.</p>
</td></tr>
<tr><td><code id="niftiImage2fmri_+3A_setmask">setmask</code></td>
<td>

<p>if <code>TRUE</code> create a brain mask
</p>
</td></tr>
<tr><td><code id="niftiImage2fmri_+3A_indx">indx</code></td>
<td>

<p>index vector for subcube definition
</p>
</td></tr>
<tr><td><code id="niftiImage2fmri_+3A_indy">indy</code></td>
<td>

<p>index vector for subcube definition
</p>
</td></tr>
<tr><td><code id="niftiImage2fmri_+3A_indz">indz</code></td>
<td>

<p>index vector for subcube definition
</p>
</td></tr>
<tr><td><code id="niftiImage2fmri_+3A_avoidnegs">avoidnegs</code></td>
<td>

<p>if <code>TRUE</code> change the mean to avoid negative image intensities
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used in connection with readNifti from package RNiftyReg
to read large fMRI series from nifti files. The resulting fmridata-object
stores the image data as 2 byte integer in raw format, in contrast for the
4 byte real used with other functions.
</p>


<h3>Value</h3>

<p>an object of class fmridata
</p>


<h3>Author(s)</h3>

<p> Joerg Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+read.AFNI">read.AFNI</a></code>, <code><a href="#topic+read.DICOM">read.DICOM</a></code>,
<code><a href="#topic+read.ANALYZE">read.ANALYZE</a></code>, <code><a href="#topic+read.NIFTI">read.NIFTI</a></code>
</p>

<hr>
<h2 id='plot.fmridata'> I/O functions </h2><span id='topic+plot.fmridata'></span><span id='topic+plot.fmrisegment'></span>

<h3>Description</h3>

<p>Visualize fMRI data and (intermediate) results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fmridata'
plot(x, anatomic = NULL, maxpvalue = 0.05,
              spm = TRUE, pos = c(-1, -1, -1), type = "slice",
              slice =  1, view = "axial" ,zlim.u =
              NULL, zlim.o = NULL,col.o = heat.colors(256), col.u =
              grey(0:255/255), cutOff = c(0, 1), ...)
## S3 method for class 'fmrisegment'
plot(x, anatomic = NULL,
              slice =  1, view = c( "axial", "coronal", "sagittal") ,zlim.u =
              NULL, zlim.o = NULL,col.o = c( rainbow( 64, start = 2/6, end = 4/6),
              rainbow( 64, start = 0, end = 1/6)),
              col.u = grey(0:127/127), verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fmridata_+3A_x">x</code></td>
<td>
<p> object of class &quot;fmrisegment&quot;, &quot;fmrispm&quot; or &quot;fmridata&quot; </p>
</td></tr>
<tr><td><code id="plot.fmridata_+3A_anatomic">anatomic</code></td>
<td>
<p> overlay of same dimension as the functional data, or fmridata object
(if of x is fmripvalue object) </p>
</td></tr>
<tr><td><code id="plot.fmridata_+3A_maxpvalue">maxpvalue</code></td>
<td>
<p> maximum p-value for thresholding </p>
</td></tr>
<tr><td><code id="plot.fmridata_+3A_spm">spm</code></td>
<td>
<p> logical. if class is &quot;fmrispm&quot; decide whether to plot
the t-statistics for the estimated effect (<code>spm=TRUE</code>) or the estimated effect
itself (<code>spm=FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.fmridata_+3A_pos">pos</code></td>
<td>
<p> voxel to be marked on output </p>
</td></tr>
<tr><td><code id="plot.fmridata_+3A_type">type</code></td>
<td>
<p> string. &quot;slice&quot; for slicewise view and &quot;3d&quot; for
3d view.</p>
</td></tr>
<tr><td><code id="plot.fmridata_+3A_slice">slice</code></td>
<td>
<p> number of slice in x, if anatomic is of &quot;fmridata&quot; class</p>
</td></tr>
<tr><td><code id="plot.fmridata_+3A_view">view</code></td>
<td>
<p> &quot;axial&quot;, &quot;coronal&quot;, or &quot;sagittal&quot;, if anatomic is of &quot;fmridata&quot; class </p>
</td></tr>
<tr><td><code id="plot.fmridata_+3A_zlim.u">zlim.u</code></td>
<td>
<p> full range for anatomical underlay used for color scale, if anatomic is of &quot;fmridata&quot; class </p>
</td></tr>
<tr><td><code id="plot.fmridata_+3A_zlim.o">zlim.o</code></td>
<td>
<p> full range for functional overlay used for color scale, if anatomic is of &quot;fmridata&quot; class </p>
</td></tr>
<tr><td><code id="plot.fmridata_+3A_col.u">col.u</code></td>
<td>
<p> color scale for anatomical underlay, if anatomic is of &quot;fmridata&quot; class, default grey(0:255/255) </p>
</td></tr>
<tr><td><code id="plot.fmridata_+3A_col.o">col.o</code></td>
<td>
<p> color scale for functional overlay, if anatomic is of &quot;fmridata&quot; class, default heat.colors(256) </p>
</td></tr>
<tr><td><code id="plot.fmridata_+3A_cutoff">cutOff</code></td>
<td>
<p> not yet documented </p>
</td></tr>
<tr><td><code id="plot.fmridata_+3A_verbose">verbose</code></td>
<td>
<p> tell something on the progress?</p>
</td></tr>
<tr><td><code id="plot.fmridata_+3A_...">...</code></td>
<td>
<p> additional arguments for plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Provides a slicewise view of &quot;fmridata&quot; objects with anatomic overlay (if
appropriate, that is for class &quot;fmripvalue&quot;). For objects of class
&quot;fmrispm&quot; it plots the t-statistics for the estimated effects if <code>spm</code> is
<code>TRUE</code>, or the estimated effect otherwise. For objects of class
&quot;fmridata&quot; only a plot of the data slices itself is produced. If <code>device</code> is
specified as  &quot;png&quot;, &quot;jpeg&quot;, &quot;ppm&quot; output is done to a file. A grey/color scale
is provided in the remaining space.
</p>
<p>For objects of class &quot;fmrisegment&quot; the smoothed signal size is shown in the
activation segments (two-sided test!).
</p>
<p>If <code>type</code> is &quot;3d&quot; a 3 dimensional interactive view opens. Sliders
to move in the data cube are given (&quot;x&quot;, &quot;y&quot;, &quot;z&quot;, and &quot;t&quot; if class is
&quot;fmridata&quot; only). Time series are shown if available. For objects
of class &quot;fmrispm&quot; a slider is created to remove  information for voxels with
smaller signals than a cut-off value from the plot.
Use pvalues for statistical evaluation. If <code>spm</code> is
<code>FALSE</code> the estimated BOLD response together with a confidence
interval corresponding to <code>maxpvalue</code> is drawn. For objects of class
&quot;fmripvalue&quot; the pvalues with overlay are shown.
</p>


<h3>Value</h3>

<p>If 'type' is &quot;3d&quot; the Tk-object is returned. (Remove the display with <code>tkdestroy(object)</code>)
</p>


<h3>Note</h3>

<p> 3 dimensional plotting requires the <code>tkrplot</code>
package.
</p>


<h3>Author(s)</h3>

<p> Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a> </p>


<h3>References</h3>

<p>Polzehl, J. and Tabelow, K. (2007)
<em>fmri: A Package for Analyzing fmri Data</em>,
R News, 7:13-17 .
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+fmri.pvalue">fmri.pvalue</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: plot(pvalue)
</code></pre>

<hr>
<h2 id='plot.fmriICA'>
Diagnostics plots for objects of class &rdquo;<code>fmriICA</code>&rdquo;
</h2><span id='topic+plot.fmriICA'></span><span id='topic+plot.fmrigroupICA'></span>

<h3>Description</h3>

<p>The function generates plots for inspecting independent components
obtained by spatial independent component analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fmriICA'
plot(x, comp = 1, center = NULL, thresh = 1.5, ...)
## S3 method for class 'fmrigroupICA'
plot(x, comp = 1, center = NULL, thresh = 1.5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fmriICA_+3A_x">x</code></td>
<td>

<p>object returned by function <code>fmri.sICA</code> or preferably
function <code>ICAfingerprinting</code> in case of <code>plot.fmriICA</code>
and object returned by function <code>fmri.sgroupICA</code> in case of
<code>plot.fmrigroupICA</code>
</p>
</td></tr>
<tr><td><code id="plot.fmriICA_+3A_comp">comp</code></td>
<td>

<p>number of the independent component to inspect.
</p>
</td></tr>
<tr><td><code id="plot.fmriICA_+3A_center">center</code></td>
<td>

<p>coordinates for central point to determine axial, coronal and sagittal
slices for display. If NULL the central point of the image cube is selected.
center needs to be within the brain mask.
</p>
</td></tr>
<tr><td><code id="plot.fmriICA_+3A_thresh">thresh</code></td>
<td>

<p>Threshold value
</p>
</td></tr>
<tr><td><code id="plot.fmriICA_+3A_...">...</code></td>
<td>
<p>currently not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p> The function generates diagnostic plots for the independent component specified
in <code>comp</code>. It
provides axial, coronal and sagittal images as determined by <code>center</code>.
Values exceeding the threshold are displayed using a color scale.
An IC fingerprint is given as a star plot.
Additionally the time series corresponding to the spatial IC and its spectral density are plotted.
</p>


<h3>Value</h3>

<p> nothing returned.
</p>


<h3>Author(s)</h3>

<p>Joerg Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>References</h3>

<p>De Martino et. al., Classification of fMRI independent components using IC-fingerprints
and support vector machine classifiers, Neuroimage 34 (2007) 177-194.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fmri.sICA">fmri.sICA</a></code>, <code><a href="#topic+ICAfingerprint">ICAfingerprint</a></code>, <code><a href="fastICA.html#topic+fastICA">fastICA</a></code>
</p>

<hr>
<h2 id='plot.fmripvalue'>
Visualize fMRI p-value maps
</h2><span id='topic+plot.fmripvalue'></span>

<h3>Description</h3>

<p> Visualize objects created by function <code>fmri.pvalue</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fmripvalue'
plot(x, template = NULL, mask = NULL,
      view = c("axial", "coronal", "sagittal", "orthographic"),
      slices = NULL, ncol = 1, nrow = 1, center = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fmripvalue_+3A_x">x</code></td>
<td>

<p>object of class 'fmripvalue'
</p>
</td></tr>
<tr><td><code id="plot.fmripvalue_+3A_template">template</code></td>
<td>

<p>Anatomical image of same origin and direction
as pvalue map in x$pvalue.
</p>
</td></tr>
<tr><td><code id="plot.fmripvalue_+3A_mask">mask</code></td>
<td>

<p>optional brain mask
</p>
</td></tr>
<tr><td><code id="plot.fmripvalue_+3A_view">view</code></td>
<td>

<p>Either 'orthographic' or one of 'axial', 'coronal' or 'sagittal'
</p>
</td></tr>
<tr><td><code id="plot.fmripvalue_+3A_slices">slices</code></td>
<td>

<p>If <code>view != "orthographic"</code> vector of slice numbers to use.
If not provided the <code>ncol*nrow</code> slices with strongest signals are selected
</p>
</td></tr>
<tr><td><code id="plot.fmripvalue_+3A_ncol">ncol</code></td>
<td>

<p>If <code>view != "orthographic"</code> number of slices per row
</p>
</td></tr>
<tr><td><code id="plot.fmripvalue_+3A_nrow">nrow</code></td>
<td>

<p>If <code>view != "orthographic"</code> number of rows in display.
</p>
</td></tr>
<tr><td><code id="plot.fmripvalue_+3A_center">center</code></td>
<td>

<p>If <code>view == "orthographic"</code> center of orthographic view.
If not provided the center is chosen to provide maximal information.
</p>
</td></tr>
<tr><td><code id="plot.fmripvalue_+3A_...">...</code></td>
<td>

<p>additional parameters (not evaluated)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with components
</p>
<table>
<tr><td><code>comp1</code></td>
<td>
<p>slices, numbers refer to spm</p>
</td></tr>
<tr><td><code>comp2</code></td>
<td>
<p>center, numbers refer to spm</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Joerg Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fmri.pvalue">fmri.pvalue</a></code>, ~~~
</p>

<hr>
<h2 id='print.fmridata'> I/O functions </h2><span id='topic+print.fmridata'></span>

<h3>Description</h3>

<p>'print' method for class '&quot;fmridata&quot;'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fmridata'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.fmridata_+3A_x">x</code></td>
<td>
<p> an object of class <code>fmridata</code>, usually, a result of a call to
<code>fmri.lm</code>, <code>fmri.smooth</code>, <code>fmri.pvalue</code>,
<code>read.AFNI</code>, or <code>read.ANALYZE</code>. </p>
</td></tr>
<tr><td><code id="print.fmridata_+3A_...">...</code></td>
<td>
<p> further arguments passed to or from other methods. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method tries to print information on data, like data dimension,
voxel size, value range.
</p>


<h3>Value</h3>

<p>none
</p>


<h3>Author(s)</h3>

<p> Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a> </p>


<h3>References</h3>

<p>Polzehl, J. and Tabelow, K. (2007)
<em>fmri: A Package for Analyzing fmri Data</em>,
R News, 7:13-17 .
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+summary.fmridata">summary.fmridata</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: print(data)
</code></pre>

<hr>
<h2 id='read.AFNI'> I/O function </h2><span id='topic+read.AFNI'></span>

<h3>Description</h3>

<p>Read HEAD/BRIK file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.AFNI(filename,vol=NULL,level=0.75,mask=NULL,setmask=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.AFNI_+3A_filename">filename</code></td>
<td>
<p> name of the file (without extension) </p>
</td></tr>
<tr><td><code id="read.AFNI_+3A_vol">vol</code></td>
<td>
<p>vector of volumes of the dataset to be read</p>
</td></tr>
<tr><td><code id="read.AFNI_+3A_level">level</code></td>
<td>
<p>Quantile level defining the mask</p>
</td></tr>
<tr><td><code id="read.AFNI_+3A_mask">mask</code></td>
<td>
<p>array or nifti-object containing the mask. If set this replaces
the mask defined by argument level.</p>
</td></tr>
<tr><td><code id="read.AFNI_+3A_setmask">setmask</code></td>
<td>
<p>Logical (default <code>TRUE</code>), whether to define a suitable mask based on <code>level</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function reads a HEAD/BRIK file. If <code>vol</code> is given (defaults to
<code>NULL</code>), only volumes in this vector are read, in order to save
memory.
</p>


<h3>Value</h3>

<p>Object of class &quot;fmridata&quot; with the following list entries:
</p>
<table>
<tr><td><code>ttt</code></td>
<td>
<p>raw vector (numeric size 4) containing the four dimensional data cube (the first three dimensions are voxel
dimensions, the fourth dimension denotes the time).</p>
</td></tr>
<tr><td><code>header</code></td>
<td>
<p>header information list</p>
</td></tr>
<tr><td><code>format</code></td>
<td>
<p>data source. string &quot;HEAD/BRIK&quot;</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>voxel size in mm</p>
</td></tr>
<tr><td><code>origin</code></td>
<td>
<p>position of the datacube origin</p>
</td></tr>
<tr><td><code>orient</code></td>
<td>
<p>data orientation code. see AFNI documentation</p>
</td></tr>
<tr><td><code>dim</code></td>
<td>
<p>dimension of the datacube</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>weights vector coding the relative voxel sizes in x,
y, z-direction.</p>
</td></tr>
<tr><td><code>mask</code></td>
<td>
<p>head mask</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a> </p>


<h3>References</h3>

<p>R. W. Cox (1996). AFNI: Software for analysis and visualization of
functional magnetic resonance neuroimages. Computers and Biomed. Res.
29:162-173.
</p>
<p>Polzehl, J. and Tabelow, K. (2007)
<em>fmri: A Package for Analyzing fmri Data</em>,
R News, 7:13-17 .
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+write.AFNI">write.AFNI</a></code>, <code><a href="#topic+read.ANALYZE">read.ANALYZE</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: afni &lt;- read.AFNI("afnifile")
</code></pre>

<hr>
<h2 id='read.ANALYZE'> I/O Functions </h2><span id='topic+read.ANALYZE'></span>

<h3>Description</h3>

<p>Read fMRI data from ANALYZE file(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.ANALYZE(prefix = "", numbered = FALSE, postfix = "",
             picstart = 1, numbpic = 1, level = 0.75, mask=NULL, setmask=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.ANALYZE_+3A_prefix">prefix</code></td>
<td>
<p> string(s). part of the file name before the
number or vector of strings for filename (if <code>numbered</code> is <code>FALSE</code>) </p>
</td></tr>
<tr><td><code id="read.ANALYZE_+3A_numbered">numbered</code></td>
<td>
<p> logical. if <code>FALSE</code> only <code>prefix</code> is taken
as file name (default).</p>
</td></tr>
<tr><td><code id="read.ANALYZE_+3A_postfix">postfix</code></td>
<td>
<p> string. part of the file name after the number</p>
</td></tr>
<tr><td><code id="read.ANALYZE_+3A_picstart">picstart</code></td>
<td>
<p> number of the first image to be read. </p>
</td></tr>
<tr><td><code id="read.ANALYZE_+3A_numbpic">numbpic</code></td>
<td>
<p> number of images to be read </p>
</td></tr>
<tr><td><code id="read.ANALYZE_+3A_level">level</code></td>
<td>
<p>Quantile level defining the mask</p>
</td></tr>
<tr><td><code id="read.ANALYZE_+3A_mask">mask</code></td>
<td>
<p>array or nifti-object containing the mask. If set this replaces
the mask defined by argument level.</p>
</td></tr>
<tr><td><code id="read.ANALYZE_+3A_setmask">setmask</code></td>
<td>
<p>Logical (default <code>TRUE</code>), whether to define a suitable mask based on <code>level</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function reads fMRI data files in ANALYZE format.
If <code>numbered</code> is <code>FALSE</code>, only the vector of strings in <code>prefix</code>
is used for file name (default).
</p>
<p>If <code>numbered</code> is <code>TRUE</code>, it takes the first string in <code>prefix</code> and <code>postfix</code> and
a number of the form &quot;007&quot; in between to create the file name.
</p>
<p>The number is assumed to be 3 digits (including leading zeros). First
number is given in <code>picstart</code>, while <code>numbpic</code> defines the
total number of images to be read. Data in multiple files
will be combined into a four dimensional datacube.
</p>


<h3>Value</h3>

<p>Object of class &quot;fmridata&quot; with the following list entries:
</p>
<table>
<tr><td><code>ttt</code></td>
<td>
<p>raw vector (numeric size 4) containing the four dimensional data cube (the first three dimensions are voxel
dimensions, the fourth dimension denotes the time).</p>
</td></tr>
<tr><td><code>header</code></td>
<td>
<p>header information of the data</p>
</td></tr>
<tr><td><code>format</code></td>
<td>
<p>data source. string &quot;ANALYZE&quot;</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>voxel size in mm</p>
</td></tr>
<tr><td><code>origin</code></td>
<td>
<p>position of the datacube origin</p>
</td></tr>
<tr><td><code>orient</code></td>
<td>
<p>data orientation code</p>
</td></tr>
<tr><td><code>dim</code></td>
<td>
<p>dimension of the datacube</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>weights vector coding the relative voxel sizes in x,
y, z-direction</p>
</td></tr>
<tr><td><code>mask</code></td>
<td>
<p>head mask</p>
</td></tr>
</table>


<h3>Note</h3>

<p>   Since numbering and naming of ANALYZE files widely vary, this
function may not meet your personal needs. See Details section above for
a description.
</p>


<h3>Author(s)</h3>

<p> Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a> </p>


<h3>References</h3>

<p>Biomedical Imaging Resource (2001). Analyze Program. Mayo Foundation.
</p>
<p>Polzehl, J. and Tabelow, K. (2007)
<em>fmri: A Package for Analyzing fmri Data</em>,
R News, 7:13-17 .
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+write.ANALYZE">write.ANALYZE</a></code>, <code><a href="#topic+read.AFNI">read.AFNI</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: analyze &lt;- read.ANALYZE("analyze",TRUE,"file",31,107)</code></pre>

<hr>
<h2 id='read.DICOM'> I/O function </h2><span id='topic+read.DICOM'></span>

<h3>Description</h3>

<p>Read DICOM file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.DICOM(filename,includedata = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.DICOM_+3A_filename">filename</code></td>
<td>
<p> name of the file </p>
</td></tr>
<tr><td><code id="read.DICOM_+3A_includedata">includedata</code></td>
<td>
<p> logical. should data be read too? defaults to <code>TRUE</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function reads a DICOM file.
</p>


<h3>Value</h3>

<p>Object with the following list entries:
</p>
<table>
<tr><td><code>header</code></td>
<td>
<p>header information as raw data</p>
</td></tr>
<tr><td><code>ttt</code></td>
<td>
<p> image data if requested. raw vector (numeric size 4) containing the four dimensional data cube (the first three dimensions are voxel dimensions, the fourth dimension denotes the time).</p>
</td></tr>
<tr><td><code>format</code></td>
<td>
<p>data source. string &quot;DICOM&quot;</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>voxel size in mm</p>
</td></tr>
<tr><td><code>series</code></td>
<td>
<p>series identifier</p>
</td></tr>
<tr><td><code>image</code></td>
<td>
<p>image number within series</p>
</td></tr>
<tr><td><code>dim</code></td>
<td>
<p>dimension of the data if available</p>
</td></tr>
</table>


<h3>Note</h3>

<p> Since the DICOM standard is rather complicated, there may be
cases where this function cannot read a DICOM file. Known issue: it
cannot read header with implicit VR. Return value may change in future
version!
</p>


<h3>Author(s)</h3>

<p> Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a> </p>


<h3>References</h3>

<p>http://medical.nema.org
</p>
<p>Polzehl, J. and Tabelow, K. (2007)
<em>fmri: A Package for Analyzing fmri Data</em>,
R News, 7:13-17 .
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.AFNI">read.AFNI</a></code>, <code><a href="#topic+read.ANALYZE">read.ANALYZE</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: dicom &lt;- read.DICOM("dicomfile")
</code></pre>

<hr>
<h2 id='read.NIFTI'> I/O Functions </h2><span id='topic+read.NIFTI'></span>

<h3>Description</h3>

<p>Read fMRI data from NIFTI file(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.NIFTI(filename, level = 0.75, mask=NULL, setmask=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.NIFTI_+3A_filename">filename</code></td>
<td>
<p> name of the NIfTI file </p>
</td></tr>
<tr><td><code id="read.NIFTI_+3A_level">level</code></td>
<td>
<p>Quantile level defining the mask</p>
</td></tr>
<tr><td><code id="read.NIFTI_+3A_mask">mask</code></td>
<td>
<p>array or nifti-object containing the mask. If set this replaces
the mask defined by argument level.</p>
</td></tr>
<tr><td><code id="read.NIFTI_+3A_setmask">setmask</code></td>
<td>
<p>Logical (default <code>TRUE</code>), whether to define a suitable mask based on <code>level</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function reads fMRI data files in NIfTI format.
</p>
<p>The filename can be given with or without extension. If extension is
not included, the function searches for the &quot;.nii&quot; file and then for
the &quot;hdr/img&quot; pair.
</p>


<h3>Value</h3>

<p>Object of class &quot;fmridata&quot; with the following list entries:
</p>
<table>
<tr><td><code>ttt</code></td>
<td>
<p>raw vector (numeric size 4) containing the four dimensional data cube (the first three dimensions are voxel
dimensions, the fourth dimension denotes the time).</p>
</td></tr>
<tr><td><code>header</code></td>
<td>
<p>header information of the data</p>
</td></tr>
<tr><td><code>format</code></td>
<td>
<p>data source. string &quot;NIFTI&quot;</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>voxel size in mm</p>
</td></tr>
<tr><td><code>origin</code></td>
<td>
<p>position of the datacube origin</p>
</td></tr>
<tr><td><code>orient</code></td>
<td>
<p>data orientation code</p>
</td></tr>
<tr><td><code>dim</code></td>
<td>
<p>dimension of the datacube</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>weights vector coding the relative voxel sizes in x,
y, z-direction</p>
</td></tr>
<tr><td><code>mask</code></td>
<td>
<p>head mask</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a> </p>


<h3>References</h3>

<p>Polzehl, J. and Tabelow, K. (2007)
<em>fmri: A Package for Analyzing fmri Data</em>,
R News, 7:13-17 .
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.ANALYZE">read.ANALYZE</a></code>, <code><a href="#topic+read.AFNI">read.AFNI</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: analyze &lt;- read.NIFTI("niftifile.nii")</code></pre>

<hr>
<h2 id='setmask'>
Add or replace mask in an fmridata object
</h2><span id='topic+setmask'></span>

<h3>Description</h3>

<p>The function replaces the information in the mask component of an fmridata object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setmask(fmriobj, mask)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setmask_+3A_fmriobj">fmriobj</code></td>
<td>

<p>object of class 'fmridata'
</p>
</td></tr>
<tr><td><code id="setmask_+3A_mask">mask</code></td>
<td>

<p>object of class 'array' or 'nifti'
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The dimensions of both objects supplied as arguments need to be compatible.
</p>


<h3>Value</h3>

<p>on object of class 'fmridata'.
</p>


<h3>Author(s)</h3>

<p>Joerg Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+oro2fmri">oro2fmri</a></code>, <code><a href="#topic+niftiImage2fmri">niftiImage2fmri</a></code>, <code><a href="#topic+read.NIFTI">read.NIFTI</a></code>,
<code><a href="#topic+read.AFNI">read.AFNI</a></code>, <code><a href="#topic+read.ANALYZE">read.ANALYZE</a></code>
</p>

<hr>
<h2 id='sincfilter'>
A function for sinc-interpolation
</h2><span id='topic+sincfilter'></span>

<h3>Description</h3>

<p>Performs sinc interpolation for a equidistant time series <code>x</code>
to times <code>t</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sincfilter(t, x, wr=8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sincfilter_+3A_t">t</code></td>
<td>

<p>vector of new time points
</p>
</td></tr>
<tr><td><code id="sincfilter_+3A_x">x</code></td>
<td>

<p>observed time series at times <code>1:length(x)</code>.
</p>
</td></tr>
<tr><td><code id="sincfilter_+3A_wr">wr</code></td>
<td>

<p>determines truncation of series expansion
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of interpolated values of the time series at time points given in
<code>t</code>.
</p>


<h3>Author(s)</h3>

<p>Joerg Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slicetiming">slicetiming</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- 1:107
  y &lt;- rnorm(x)
  z &lt;- sincfilter(seq(1,107,.01),y)
  plot(x, y, ylim=range(y,z))
  lines(seq(1,107,.01),z,col=2)

</code></pre>

<hr>
<h2 id='slicetiming'>
slicetiming for fmridata-objects
</h2><span id='topic+slicetiming'></span>

<h3>Description</h3>

<p>Perform slicetiming for fMRI data, ideally before preprocessing (registration).
Recording times for slices are assumed to be equispaced between scans with
argument <code>sliceorder</code> providing the order of slice acquisitions.
Interpolation between slices is performed using a sinc filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slicetiming(fmridataobj, sliceorder = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slicetiming_+3A_fmridataobj">fmridataobj</code></td>
<td>

<p>object of class fmridata
</p>
</td></tr>
<tr><td><code id="slicetiming_+3A_sliceorder">sliceorder</code></td>
<td>

<p>order of lice acquisitions
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class fmridata
</p>


<h3>Author(s)</h3>

<p>Joerg Polzehl <a href="mailto:polzehl@wias-berlin.de">polzehl@wias-berlin.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fmri.stimulus">fmri.stimulus</a></code>, <code><a href="#topic+fmri.design">fmri.design</a></code>,<code><a href="#topic+fmri.lm">fmri.lm</a></code>,~~~
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
# Example 1
  data &lt;- list(ttt=writeBin(rnorm(32*32*32*107), raw(), 4),
               mask=array(TRUE, c(32, 32, 32)), dim=c(32, 32, 32, 107))
  class(data) &lt;- "fmridata"
  data &lt;- slicetiming(data,sliceorder=1:32)
  ## provides data corrected for sequential slice acquisition in linear order

## End(Not run)
</code></pre>

<hr>
<h2 id='summary.fmridata'> I/O functions </h2><span id='topic+summary.fmridata'></span>

<h3>Description</h3>

<p>'summary' method for class '&quot;fmridata&quot;'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fmridata'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.fmridata_+3A_object">object</code></td>
<td>
<p> an object of class <code>fmridata</code>, usually, a result of a call to
<code>fmri.lm</code>, <code>fmri.smooth</code>, <code>fmri.pvalue</code>,
<code>read.AFNI</code>, or <code>read.ANALYZE</code>. </p>
</td></tr>
<tr><td><code id="summary.fmridata_+3A_...">...</code></td>
<td>
<p> further arguments passed to or from other methods. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method tries to print information on data, like data dimension,
voxel size, value range.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>dim</code></td>
<td>
<p>data dimension</p>
</td></tr>
<tr><td><code>delta</code></td>
<td>
<p>voxel dimension, if available</p>
</td></tr>
<tr><td><code>values</code></td>
<td>
<p>value range</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p> design matrix </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+print.fmridata">print.fmridata</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: summary(data)
</code></pre>

<hr>
<h2 id='write.AFNI'> I/O functions </h2><span id='topic+write.AFNI'></span>

<h3>Description</h3>

<p>Write BRIK/HEAD files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.AFNI(filename, ttt, label = NULL, note = NULL, origin = NULL, 
               delta = NULL, idcode = NULL, header = NULL, taxis = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.AFNI_+3A_filename">filename</code></td>
<td>
<p> name of the file </p>
</td></tr>
<tr><td><code id="write.AFNI_+3A_ttt">ttt</code></td>
<td>
<p> datacube </p>
</td></tr>
<tr><td><code id="write.AFNI_+3A_label">label</code></td>
<td>
<p> labels (BRICK_LABS), depreciated - see header</p>
</td></tr>
<tr><td><code id="write.AFNI_+3A_note">note</code></td>
<td>
<p> notes on data (HISTORY_NOTE), depreciated - see header </p>
</td></tr>
<tr><td><code id="write.AFNI_+3A_origin">origin</code></td>
<td>
<p> origin of datacube (ORIGIN), depreciated - see header </p>
</td></tr>
<tr><td><code id="write.AFNI_+3A_delta">delta</code></td>
<td>
<p> voxel dimensions (DELTA), depreciated - see header </p>
</td></tr>
<tr><td><code id="write.AFNI_+3A_idcode">idcode</code></td>
<td>
<p> idcode of data (IDCODE_STRING), depreciated - see header </p>
</td></tr>
<tr><td><code id="write.AFNI_+3A_header">header</code></td>
<td>
<p> This is a list of header information such as 
DATASET_RANK to be written to the .HEAD file.
Arguments <code>label</code>, ... are depreciated and to be substituted
by a corresponding list entry. For backward compatibility
the use of the old arguments is still supported and should 
give the same results. This will be removed in some future 
release! Since AFNI does not read any dataset with a header choose 
carefully what is written. There are some basic tests in this function,
but this may not be sufficient.</p>
</td></tr>
<tr><td><code id="write.AFNI_+3A_taxis">taxis</code></td>
<td>
<p> logical (defaults to <code>FALSE</code>. Are the sub-bricks time series? 
This results in writing TAXIS attributes to the header file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Write out BRIK/HEAD files as required by AFNI. Most arguments
correspond to entries in the HEAD file, but use is depreciated. Use <code>header</code> and <code>taxis</code> instead!
</p>


<h3>Value</h3>

<p>Nothing is returned.
</p>


<h3>Author(s)</h3>

<p> Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a> </p>


<h3>References</h3>

<p>Polzehl, J. and Tabelow, K. (2007)
<em>fmri: A Package for Analyzing fmri Data</em>,
R News, 7:13-17 .
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.AFNI">read.AFNI</a></code>,<code><a href="#topic+write.ANALYZE">write.ANALYZE</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: write.AFNI(tempfile(), array(as.integer(65526*runif(10*10*10*20)),
     c(10,10,10,20)), c("signal"), note="random data",
     origin=c(0,0,0), delta=c(4,4,5), idcode="unique ID")
## End(Not run)
 write.AFNI(tempfile(), array(as.integer(65526*runif(10*10*10*20)),
     c(10,10,10,20)), header=list(HISTORY_NOTE="random data",
     ORIGIN=c(0,0,0), DELTA=c(4,4,5), IDCODE_STRING="unique ID"),taxis=FALSE)
</code></pre>

<hr>
<h2 id='write.ANALYZE'> I/O Functions </h2><span id='topic+write.ANALYZE'></span>

<h3>Description</h3>

<p>Write a 4 dimensional datacube in ANALYZE file format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.ANALYZE(ttt, header=NULL, filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.ANALYZE_+3A_ttt">ttt</code></td>
<td>
<p> 4 dimensional datacube </p>
</td></tr>
<tr><td><code id="write.ANALYZE_+3A_header">header</code></td>
<td>
<p> header information </p>
</td></tr>
<tr><td><code id="write.ANALYZE_+3A_filename">filename</code></td>
<td>
<p> file name </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Writes the datacube <code>ttt</code> to a file named <code>file</code> in ANALYZE file
format. <code>header</code> is a list that contains the header information
as documented by the Mayo Foundation. We give here a short summary. If
a value is not provided, it will be tried to fill it with reasonable
defaults, but do not expect fine results, if the entry has a special
important meaning (h.i. pixdim).
</p>

<table>
<tr>
 <td style="text-align: right;">
 [1] </td><td style="text-align: left;"> datatype1 -- 10 byte character </td><td style="text-align: right;">
 [2] </td><td style="text-align: left;"> dbname -- 18 byte character</td>
</tr>
<tr>
 <td style="text-align: right;">
 [3] </td><td style="text-align: left;"> extents -- integer </td><td style="text-align: right;">
 [4] </td><td style="text-align: left;"> sessionerror -- integer</td>
</tr>
<tr>
 <td style="text-align: right;">
 [5] </td><td style="text-align: left;"> regular -- character </td><td style="text-align: right;">
 [6] </td><td style="text-align: left;"> hkey -- character</td>
</tr>
<tr>
 <td style="text-align: right;">
 [7] </td><td style="text-align: left;"> dimension -- 8 integers, dimensions ... </td><td style="text-align: right;">
 [8] </td><td style="text-align: left;"> unused -- 7 integers</td>
</tr>
<tr>
 <td style="text-align: right;">
 [9] </td><td style="text-align: left;"> datatype -- integer, datatype usually "4" </td><td style="text-align: right;">
 [10] </td><td style="text-align: left;"> bitpix -- integer</td>
</tr>
<tr>
 <td style="text-align: right;">
 [11] </td><td style="text-align: left;"> dimun0 -- integer </td><td style="text-align: right;">
 [12] </td><td style="text-align: left;"> pixdim -- 8 floats, voxel dimensions ...</td>
</tr>
<tr>
 <td style="text-align: right;">
 [13] </td><td style="text-align: left;"> voxoffset -- float </td><td style="text-align: right;">
 [14] </td><td style="text-align: left;"> funused -- 3 floats</td>
</tr>
<tr>
 <td style="text-align: right;">
 [15] </td><td style="text-align: left;"> calmax -- float </td><td style="text-align: right;">
 [16] </td><td style="text-align: left;"> calmin -- float</td>
</tr>
<tr>
 <td style="text-align: right;">
 [17] </td><td style="text-align: left;"> compressed -- float </td><td style="text-align: right;">
 [18] </td><td style="text-align: left;"> verified -- float</td>
</tr>
<tr>
 <td style="text-align: right;">
 [19] </td><td style="text-align: left;"> glmax -- integer </td><td style="text-align: right;">
 [20] </td><td style="text-align: left;"> glmin -- integer</td>
</tr>
<tr>
 <td style="text-align: right;">
 [21] </td><td style="text-align: left;"> describ -- 80 byte character </td><td style="text-align: right;">
 [22] </td><td style="text-align: left;"> auxfile -- 24 byte character</td>
</tr>
<tr>
 <td style="text-align: right;">
 [23] </td><td style="text-align: left;"> orient -- character </td><td style="text-align: right;">
 [24] </td><td style="text-align: left;"> originator -- 5 integers </td>
</tr>
<tr>
 <td style="text-align: right;">
 [25] </td><td style="text-align: left;"> generated -- 10 byte character </td><td style="text-align: right;">
 [26] </td><td style="text-align: left;"> scannum -- 10 byte character</td>
</tr>
<tr>
 <td style="text-align: right;">
 [27] </td><td style="text-align: left;"> patientid -- 10 byte character </td><td style="text-align: right;">
 [28] </td><td style="text-align: left;"> expdate -- 10 byte character</td>
</tr>
<tr>
 <td style="text-align: right;">
 [29] </td><td style="text-align: left;"> exptime -- 10 byte character </td><td style="text-align: right;">
 [30] </td><td style="text-align: left;"> histun0 -- 3 byte character</td>
</tr>
<tr>
 <td style="text-align: right;">
 [31] </td><td style="text-align: left;"> views -- integer </td><td style="text-align: right;">
 [32] </td><td style="text-align: left;"> voladded -- integer</td>
</tr>
<tr>
 <td style="text-align: right;">
 [33] </td><td style="text-align: left;"> startfield -- integer </td><td style="text-align: right;">
 [34] </td><td style="text-align: left;"> fieldskip -- integer</td>
</tr>
<tr>
 <td style="text-align: right;">
 [35] </td><td style="text-align: left;"> omax -- integer </td><td style="text-align: right;">
 [36] </td><td style="text-align: left;"> omin -- integer</td>
</tr>
<tr>
 <td style="text-align: right;">
 [37] </td><td style="text-align: left;"> smax -- integer </td><td style="text-align: right;">
 [38] </td><td style="text-align: left;"> smin -- integer       </td>
</tr>

</table>

<p>See ANALYZE documentation for details.
</p>


<h3>Value</h3>

<p>Nothing is returned.
</p>


<h3>Author(s)</h3>

<p> Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a> </p>


<h3>References</h3>

<p>Polzehl, J. and Tabelow, K. (2007)
<em>fmri: A Package for Analyzing fmri Data</em>,
R News, 7:13-17 .
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.ANALYZE">read.ANALYZE</a></code>, <code><a href="#topic+write.AFNI">write.AFNI</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 1
write.ANALYZE(array(as.integer(65526*runif(10*10*10*20)),c(10,10,10,20)),
              file=file.path(tempdir(),"analyzefile"))
</code></pre>

<hr>
<h2 id='write.NIFTI'> I/O Functions </h2><span id='topic+write.NIFTI'></span>

<h3>Description</h3>

<p>Write a 4 dimensional datacube in NIfTI file format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.NIFTI(ttt, header=NULL, filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.NIFTI_+3A_ttt">ttt</code></td>
<td>
<p> 4 dimensional datacube </p>
</td></tr>
<tr><td><code id="write.NIFTI_+3A_header">header</code></td>
<td>
<p> header information </p>
</td></tr>
<tr><td><code id="write.NIFTI_+3A_filename">filename</code></td>
<td>
<p> file name </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Writes the datacube <code>ttt</code> to a file named <code>file</code> in NIfTI file
format. <code>header</code> is a list that contains the header
information.
</p>
<p>See NIfTI documentation for details.
</p>


<h3>Value</h3>

<p>Nothing is returned.
</p>


<h3>Author(s)</h3>

<p> Karsten Tabelow <a href="mailto:tabelow@wias-berlin.de">tabelow@wias-berlin.de</a> </p>


<h3>References</h3>

<p>Polzehl, J. and Tabelow, K. (2007)
<em>fmri: A Package for Analyzing fmri Data</em>,
R News, 7:13-17 .
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+read.ANALYZE">read.ANALYZE</a></code>, <code><a href="#topic+write.AFNI">write.AFNI</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example 1
write.NIFTI(array(as.integer(65526*runif(10*10*10*20)),c(10,10,10,20)),
              file=file.path(tempdir(),"niftifile"))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
