<!DOCTYPE html><html lang="en"><head><title>Help for package ohenery</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ohenery}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ohenery'><p>The 'ohenery' package.</p></a></li>
<li><a href='#as.linodds'><p>An object for modeling linear odds.</p></a></li>
<li><a href='#best_picture'><p>Oscar Award Best Picture Data</p></a></li>
<li><a href='#diving'><p>Olympic Diving Data</p></a></li>
<li><a href='#erank'><p>Expected rank under the Harville model.</p></a></li>
<li><a href='#harsm'><p>Friendly interface to softmax regression under Harville model.</p></a></li>
<li><a href='#harsm_invlink'><p>The inverse link for the softmax.</p></a></li>
<li><a href='#harsmfit'><p>Experts only softmax regression under Harville model.</p></a></li>
<li><a href='#hensm'><p>Friendly interface to softmax regression under Henery model.</p></a></li>
<li><a href='#inv_smax'><p>The inverse softmax function.</p></a></li>
<li><a href='#normalize'><p>Normalize a vector to sum to one.</p></a></li>
<li><a href='#ohenery-NEWS'><p>News for package 'ohenery':</p></a></li>
<li><a href='#race_data'><p>Horse Race Data</p></a></li>
<li><a href='#rhenery'><p>Random generation under the Henery (or Harville) softmax model.</p></a></li>
<li><a href='#rsm'><p>Generate variates from a softmax distribution.</p></a></li>
<li><a href='#smax'><p>The softmax function.</p></a></li>
<li><a href='#smlik'><p>Softmax log likelihood under Harville and Henery Models.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Maintainer:</td>
<td>Steven E. Pav &lt;shabbychef@gmail.com&gt;</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-10-24</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>Title:</td>
<td>Modeling of Ordinal Random Variables via Softmax Regression</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/shabbychef/ohenery/issues">https://github.com/shabbychef/ohenery/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Supports the modeling of ordinal random variables, 
    like the outcomes of races, via Softmax regression,
    under the Harville &lt;<a href="https://doi.org/10.1080%2F01621459.1973.10482425">doi:10.1080/01621459.1973.10482425</a>&gt; and
    Henery &lt;<a href="https://doi.org/10.1111%2Fj.2517-6161.1981.tb01153.x">doi:10.1111/j.2517-6161.1981.tb01153.x</a>&gt; models.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.3), maxLik, magrittr, methods, dplyr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rlang, tidyr, forcats, microbenchmark, testthat, numDeriv,
ggplot2, scales, knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/shabbychef/ohenery">https://github.com/shabbychef/ohenery</a></td>
</tr>
<tr>
<td>Collate:</td>
<td>'data.r' 'harsm.r' 'hensm.r' 'linodds.r' 'ohenery.r'
'RcppExports.R' 'rsm.r' 'utils.r'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-25 05:47:28 UTC; spav</td>
</tr>
<tr>
<td>Author:</td>
<td>Steven E. Pav <a href="https://orcid.org/0000-0002-4197-6195"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-25 06:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ohenery'>The 'ohenery' package.</h2><span id='topic+ohenery-package'></span><span id='topic+ohenery'></span>

<h3>Description</h3>

<p>Modeling of ordinal outcomes via the softmax function under
the Harville and Henery models.
</p>


<h3>Harville and Henery models</h3>

<p>The Harville and Henery models describe the probability of 
ordered outcomes in terms of some parameters. 
Typically the ordered outcomes are things like place 
in a race, or winner among a large number of contestants.
The Harville model could be described as a softmax probability
for the first place finish, with a recursive model on the
remaining places.
The Henery model generalizes that to adjust the remaining
places with another parameter.
</p>
<p>These are best illustrated with an example.
Suppose you observe a race of 20 contestants.
Contestant number 11 takes first place,
number 6 takes second place, and 17 takes third place,
while the fourth through twentieth places are not
recorded or not of interest.
Under the Harville model, the probability of this outcome
can be expressed as
</p>
<p style="text-align: center;"><code class="reqn">\frac{\mu_{11}}{\sum_i \mu_i} \frac{\mu_6}{\sum_{i \ne 11} \mu_i}
\frac{\mu_{17}}{\sum_{i \ne 11, i \ne 6} \mu_i},</code>
</p>

<p>where <code class="reqn">\mu_i = \exp{\eta_i}</code>.
In a softmax regression under the Harville model, 
one expresses the odds as <code class="reqn">\eta_i = x_i^{\top}\beta</code>, where
<code class="reqn">x_i</code> are independent variables, for some
<code class="reqn">\beta</code> to be fit by the regression.
</p>
<p>Under the Henery model, one adds gammas, <code class="reqn">\gamma_2, \gamma_3, ...</code> such
that the probability of the outcome above is
</p>
<p style="text-align: center;"><code class="reqn">\frac{\mu_{11}}{\sum_i \mu_i} \frac{\mu_6^{\gamma_2}}{\sum_{i \ne 11} \mu_i^{\gamma_2}}
\frac{\mu_{17}^{\gamma_3}}{\sum_{i \ne 11, i \ne 6} \mu_i^{\gamma_3}}.</code>
</p>

<p>There is no reason to model a <code class="reqn">\gamma_1</code> as anything but one,
since it would be redundant. 
The Henery softmax regression estimates the <code class="reqn">\beta</code> as well as 
the <code class="reqn">\gamma_j</code>. 
To simplify the regression, the higher order gammas are assumed to equal
the last fit value. That is, we usually model
<code class="reqn">\gamma_5=\gamma_4=\gamma_3</code>.
</p>
<p>The regression supports weighted estimation as well. The weights are
applied to the <em>places</em>, not to the participants. The
weighted likelihood under the example above, for the Harville model
is
</p>
<p style="text-align: center;"><code class="reqn">\left(\frac{\mu_{11}}{\sum_i \mu_i}\right)^{w_1} \left(\frac{\mu_6}{\sum_{i \ne 11} \mu_i}\right)^{w_2}
\left(\frac{\mu_{17}}{\sum_{i \ne 11, i \ne 6} \mu_i}\right)^{w_3}.</code>
</p>

<p>The weighting mechanism is how this package deals with unobserved
places.
Rather than marking all runners-up as tied for fourth place, in this
case one sets the <code class="reqn">w_i=0</code> for <code class="reqn">i &gt; 3</code>.
The regression is then not asked to make distinctions between the
tied runners-up.
</p>


<h3>Breaking Changes</h3>

<p>This package is a work in progress. Expect breaking changes.
Please file any bug reports or issues at
<a href="https://github.com/shabbychef/ohenery/issues">https://github.com/shabbychef/ohenery/issues</a>.
</p>


<h3>Legal Mumbo Jumbo</h3>

<p>ohenery is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.
</p>


<h3>Note</h3>

<p>This package is maintained as a hobby.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>
<p><strong>Maintainer</strong>: Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a> (<a href="https://orcid.org/0000-0002-4197-6195">ORCID</a>)
</p>


<h3>References</h3>

<p>Harville, D. A. &quot;Assigning probabilities to the outcomes of multi-entry competitions.&quot; 
Journal of the American Statistical Association 68, no. 342 (1973): 312-316.
<a href="https://doi.org/10.1080/01621459.1973.10482425">doi:10.1080/01621459.1973.10482425</a>
</p>
<p>Henery, R. J. &quot;Permutation probabilities as models for horse races.&quot; 
Journal of the Royal Statistical Society: Series B (Methodological) 43, no. 1 (1981): 86-91.
<a href="https://doi.org/10.1111/j.2517-6161.1981.tb01153.x">doi:10.1111/j.2517-6161.1981.tb01153.x</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/shabbychef/ohenery">https://github.com/shabbychef/ohenery</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/shabbychef/ohenery/issues">https://github.com/shabbychef/ohenery/issues</a>
</p>
</li></ul>


<hr>
<h2 id='as.linodds'>An object for modeling linear odds.</h2><span id='topic+as.linodds'></span><span id='topic+predict.linodds'></span><span id='topic+coef.linodds'></span>

<h3>Description</h3>

<p>A model for odds linear in some feature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.linodds(object, formula, beta)

## S3 method for class 'linodds'
predict(
  object,
  newdata,
  type = c("eta", "mu", "erank"),
  na.action = na.pass,
  group = NULL,
  ...
)

## S3 method for class 'linodds'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.linodds_+3A_object">object</code></td>
<td>
<p>some list-like object.</p>
</td></tr>
<tr><td><code id="as.linodds_+3A_formula">formula</code></td>
<td>
<p>an object of class <code>"<a href="stats.html#topic+formula">formula</a>"</code> (or one that
can be coerced to that class): a symbolic description of the
model to be fitted.  The details of model specification are given
under &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="as.linodds_+3A_beta">beta</code></td>
<td>
<p>the fit coefficients.</p>
</td></tr>
<tr><td><code id="as.linodds_+3A_newdata">newdata</code></td>
<td>
<p>a <code>data.frame</code> from which we can extract a model
frame via the formula of the <code>object</code>.</p>
</td></tr>
<tr><td><code id="as.linodds_+3A_type">type</code></td>
<td>
<p>indicates which prediction should be returned:
</p>

<dl>
<dt><code>eta</code></dt><dd><p>The odds.</p>
</dd>
<dt><code>mu</code></dt><dd><p>The probability.</p>
</dd>
<dt><code>erank</code></dt><dd><p>The expected rank.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="as.linodds_+3A_na.action">na.action</code></td>
<td>
<p>How to deal with missing values in <code>y</code>, <code>g</code>,
<code>X</code>, <code>wt</code>, <code>eta0</code>.</p>
</td></tr>
<tr><td><code id="as.linodds_+3A_group">group</code></td>
<td>
<p>the string name of the group variable in the data,
or a bare character with the group name. The group indices
need not be integers, but that is more efficient. 
They need not be sorted.</p>
</td></tr>
<tr><td><code id="as.linodds_+3A_...">...</code></td>
<td>
<p>other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object which holds a formula, some fit coefficients 
<code class="reqn">\beta</code> which fit in that formula to generate odds
in odds space. 
The odds can then be converted, via <code>predict.linodds</code>
to probabilities, 
or to expected ranks under the Harville model.
Both <code><a href="#topic+harsm">harsm</a></code> and <code><a href="#topic+hensm">hensm</a></code> return
objects of class <code>linodds</code>.
</p>
<p>We think of linear odds as 
<code class="reqn">\eta = x^{\top}\beta</code>,
for independent variables <code class="reqn">x</code>. The odds, <code class="reqn">\eta</code>
are converted to probabilities, <code class="reqn">\mu</code> via
<code class="reqn">\mu = c \exp{\eta},</code> where the constant <code class="reqn">c</code>
is chosen so the <code class="reqn">\mu</code> for a given matching
sum to one.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+harsm">harsm</a></code>, <code><a href="#topic+hensm">hensm</a></code>.
</p>
<p><code><a href="#topic+smax">smax</a></code>, <code><a href="#topic+harsm_invlink">harsm_invlink</a></code>.
</p>

<hr>
<h2 id='best_picture'>Oscar Award Best Picture Data</h2><span id='topic+best_picture'></span>

<h3>Description</h3>

<p>Historical data on the Best Picture nominees and winners
from 1934 through 2014.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(best_picture)
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> object with 484 observations and 19 columns. 
The columns are defined as follows:
</p>

<dl>
<dt><code>year</code></dt><dd><p>The integer year of the nomination. These span from 1934 through 2014. Note that the
number of films nominated per year varies from 5 to 12.</p>
</dd>
<dt><code>film</code></dt><dd><p>The title of the film.</p>
</dd>
<dt><code>winner</code></dt><dd><p>A logical for whether the film won the Oscar for Best
Picture. There is exactly one winning film per year.</p>
</dd>
<dt><code>nominated_for_Writing</code></dt><dd><p>A logical indicating whether the film
was also nominated for a Writing award that year.</p>
</dd>
<dt><code>nominated_for_BestDirector</code></dt><dd><p>A logical indicating whether the film
was also nominated for Best Director award that year.</p>
</dd>
<dt><code>nominated_for_BestActress</code></dt><dd><p>A logical indicating whether the film
was also nominated for at least one Best Actress award that year.</p>
</dd>
<dt><code>nominated_for_BestActor</code></dt><dd><p>A logical indicating whether the film
was also nominated for at least one Best Actor award that year.</p>
</dd>
<dt><code>nominated_for_BestFilmEditing</code></dt><dd><p>A logical indicating whether the film
was also nominated for at least one Best Film Editing award that year.</p>
</dd>
<dt><code>Adventure</code></dt><dd><p>A double computed as a 0/1 indicator of whether
&ldquo;Adventure&rdquo; was one of the genres tagged for the film in IMDb,
divided by the total count of genres tagged for the film.</p>
</dd>
<dt><code>Biography</code></dt><dd><p>A double computed as a 0/1 indicator of whether
&ldquo;Biography&rdquo; was one of the genres tagged for the film in IMDb,
divided by the total count of genres tagged for the film.</p>
</dd>
<dt><code>Comedy</code></dt><dd><p>A double computed as a 0/1 indicator of whether
&ldquo;Comedy&rdquo; was one of the genres tagged for the film in IMDb,
divided by the total count of genres tagged for the film.</p>
</dd>
<dt><code>Crime</code></dt><dd><p>A double computed as a 0/1 indicator of whether
&ldquo;Crime&rdquo; was one of the genres tagged for the film in IMDb,
divided by the total count of genres tagged for the film.</p>
</dd>
<dt><code>Drama</code></dt><dd><p>A double computed as a 0/1 indicator of whether
&ldquo;Drama&rdquo; was one of the genres tagged for the film in IMDb,
divided by the total count of genres tagged for the film.</p>
</dd>
<dt><code>History</code></dt><dd><p>A double computed as a 0/1 indicator of whether
&ldquo;History&rdquo; was one of the genres tagged for the film in IMDb,
divided by the total count of genres tagged for the film.</p>
</dd>
<dt><code>Musical</code></dt><dd><p>A double computed as a 0/1 indicator of whether
&ldquo;Musical&rdquo; was one of the genres tagged for the film in IMDb,
divided by the total count of genres tagged for the film.</p>
</dd>
<dt><code>Romance</code></dt><dd><p>A double computed as a 0/1 indicator of whether
&ldquo;Romance&rdquo; was one of the genres tagged for the film in IMDb,
divided by the total count of genres tagged for the film.</p>
</dd>
<dt><code>Thriller</code></dt><dd><p>A double computed as a 0/1 indicator of whether
&ldquo;Thriller&rdquo; was one of the genres tagged for the film in IMDb,
divided by the total count of genres tagged for the film.</p>
</dd>
<dt><code>War</code></dt><dd><p>A double computed as a 0/1 indicator of whether
&ldquo;War&rdquo; was one of the genres tagged for the film in IMDb,
divided by the total count of genres tagged for the film.</p>
</dd>
<dt><code>Other</code></dt><dd><p>A double computed as 1 minus the sum of
the other genre indicators. Effectively this is is the
sum of indicators for
&ldquo;Mystery&rdquo;, &ldquo;Family&rdquo;, &ldquo;Fantasy&rdquo;, 
&ldquo;Action&rdquo;, &ldquo;Western&rdquo;, &ldquo;Music&rdquo;, 
&ldquo;Sport&rdquo;, &ldquo;Sci Fi&rdquo;,  &ldquo;Film-Noir&rdquo;,
&ldquo;Animation&rdquo;, and &ldquo;Horror&rdquo; divided
by the total count of genres tagged for the film.</p>
</dd>
</dl>



<h3>Note</h3>

<p>&ldquo;Oscar&rdquo; is a copyright property of the Academy of Motion
Picture Arts and Sciences. 
IMDb is owned by Amazon.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>Source</h3>

<p>Awards data were sourced from Wikipedia, while genre data were
sourced from IMDb.
Any errors in transcription are the fault of the package author.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
data(best_picture)

best_picture %&gt;% 
  group_by(nominated_for_BestDirector) %&gt;% 
  summarize(propwin=mean(winner)) %&gt;% 
  ungroup()
best_picture %&gt;% 
  group_by(nominated_for_BestActor) %&gt;% 
  summarize(propwin=mean(winner)) %&gt;% 
  ungroup()
# hmmmm.
best_picture %&gt;% 
  group_by(nominated_for_BestActress) %&gt;% 
  summarize(propwin=mean(winner)) %&gt;% 
 ungroup()

</code></pre>

<hr>
<h2 id='diving'>Olympic Diving Data</h2><span id='topic+diving'></span>

<h3>Description</h3>

<p>One hundred years of Men's Olympic Platform Diving records.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(diving)
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> object with 695 observations and 13 columns. 
</p>
<p>The columns are defined as follows:
</p>

<dl>
<dt><code>Name</code></dt><dd><p>The participant's name.</p>
</dd>
<dt><code>Age</code></dt><dd><p>The age of the participant at the time of the Olympics. Some values missing.</p>
</dd>
<dt><code>Height</code></dt><dd><p>The height of the participant at the time of the Olympics, in centimeters. Many values missing.</p>
</dd>
<dt><code>Weight</code></dt><dd><p>The height of the participant at the time of the Olympics, in kilograms. Many values missing.</p>
</dd>
<dt><code>Team</code></dt><dd><p>The string name of the team (country) which the participant represented.</p>
</dd>
<dt><code>NOC</code></dt><dd><p>The string name of the National Olympic Committee which the participant represented. This is a three character code.</p>
</dd>
<dt><code>Games</code></dt><dd><p>The string name of the Olympic games, including a year.</p>
</dd>
<dt><code>Year</code></dt><dd><p>The integer year of the Olympics. These range from 1906
through 2016.</p>
</dd>
<dt><code>City</code></dt><dd><p>The string name of the host city.</p>
</dd>
<dt><code>Medal</code></dt><dd><p>A string of &ldquo;Gold&rdquo;, &ldquo;Silver&rdquo;,
&ldquo;Bronze&rdquo; or <code>NA</code>.</p>
</dd>
<dt><code>EventId</code></dt><dd><p>A unique integer ID for each Olympics.</p>
</dd>
<dt><code>AthleteId</code></dt><dd><p>A unique integer ID for each participant.</p>
</dd>
<dt><code>HOST_NOC</code></dt><dd><p>The string name of the National Olympic Committee of the nation hosting the Olympics. This is a three character code.</p>
</dd>
</dl>



<h3>Note</h3>

<p>The author makes no guarantees regarding correctness of this data.
</p>
<p>Please attribute this data to the upstream harvester.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>Source</h3>

<p>Data were collected by Randi Griffin from the website
&ldquo;sports-reference.com&rdquo;, and staged on Kaggle at
<a href="https://www.kaggle.com/heesoo37/120-years-of-olympic-history-athletes-and-results">https://www.kaggle.com/heesoo37/120-years-of-olympic-history-athletes-and-results</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(forcats)
data(diving)

fitdat &lt;- diving %&gt;%
  mutate(Finish=case_when(grepl('Gold',Medal)   ~ 1,
                          grepl('Silver',Medal) ~ 2,
                          grepl('Bronze',Medal) ~ 3,
                          TRUE ~ 4)) %&gt;%
  mutate(weight=ifelse(Finish &lt;= 3,1,0)) %&gt;%
  mutate(cut_age=cut(coalesce(Age,22.0),c(12,19.5,21.5,22.5,25.5,99),include.lowest=TRUE)) %&gt;%
  mutate(country=forcats::fct_relevel(forcats::fct_lump(factor(NOC),n=5),'Other')) %&gt;%
  mutate(home_advantage=NOC==HOST_NOC)

hensm(Finish ~ cut_age + country + home_advantage,data=fitdat,weights=weight,group=EventId,ngamma=3)

</code></pre>

<hr>
<h2 id='erank'>Expected rank under the Harville model.</h2><span id='topic+erank'></span>

<h3>Description</h3>

<p>Compute the expected rank of a bunch of entries based on their probability
of winning under the Harville model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>erank(mu)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="erank_+3A_mu">mu</code></td>
<td>
<p>a vector giving the probabilities. Should sum to one.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given the vector <code class="reqn">\mu</code>, we compute the expected rank of each
entry, under the Harville model, where tail probabilities of winning
remain proportional.  
</p>
<p>Under the Harville model, the probability that the <code class="reqn">i</code>th element
is assigned value 1 is 
</p>
<p style="text-align: center;"><code class="reqn">\pi_{1,i} = \frac{\mu_i}{\sum_j \mu_j}.</code>
</p>

<p>Once an element has been assigned a 1, the Harville procedure 
removes it from the set and iterates.
If there are <code class="reqn">k</code> elements in <code class="reqn">\mu</code>, then the <code class="reqn">i</code>th element
can be assigned any place between <code class="reqn">1</code> and <code class="reqn">k</code>. This
function computes the expected value of that random variable.
</p>
<p>While a naive implementation of this function would take
time factorial in <code class="reqn">k</code>, this implementation takes time quadratic
in <code class="reqn">k</code>, since it can be shown that the expected rank of the <code class="reqn">i</code>th
element takes value
</p>
<p style="text-align: center;"><code class="reqn">e_i = k + \frac{1}{2} - \sum_j \frac{\mu_i}{\mu_i + \mu_j}.</code>
</p>



<h3>Value</h3>

<p>The expected ranks, a vector.
</p>


<h3>Note</h3>

<p>we should have the sum of ranks equal to the sum of <code>1:length(mu)</code>.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a garbage example
set.seed(12345)
mus &lt;- runif(12)
mus &lt;- mus / sum(mus)
erank(mus)

# confirm the expected rank via simulation
set.seed(123)
mus &lt;- runif(6,min=0,max=2)
mus &lt;- mus / sum(mus)
set.seed(101)
emp &lt;- rowMeans(replicate(200,rhenery(mu=mus,gamma=rep(1,length(mus)-1)))) 
(emp - erank(mus)) / emp


if (require(microbenchmark)) {
  p10 &lt;- 1:10 / sum(1:10)
  p16 &lt;- 1:16 / sum(1:16)
  p24 &lt;- 1:24 / sum(1:24)
  microbenchmark(erank(p10), erank(p16), erank(p24))
}

</code></pre>

<hr>
<h2 id='harsm'>Friendly interface to softmax regression under Harville model.</h2><span id='topic+harsm'></span><span id='topic+vcov.harsm'></span><span id='topic+print.harsm'></span>

<h3>Description</h3>

<p>A user friendly interface to the softmax regression under the Harville
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>harsm(
  formula,
  data,
  group = NULL,
  weights = NULL,
  fit0 = NULL,
  na.action = na.omit
)

## S3 method for class 'harsm'
vcov(object, ...)

## S3 method for class 'harsm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="harsm_+3A_formula">formula</code></td>
<td>
<p>an object of class <code>"<a href="stats.html#topic+formula">formula</a>"</code> (or one that
can be coerced to that class): a symbolic description of the
model to be fitted.  The details of model specification are given
under &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="harsm_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object
coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing
the variables in the model.  If not found in <code>data</code>, the
variables are taken from <code>environment(formula)</code>,
typically the environment from which <code>lm</code> is called.</p>
</td></tr>
<tr><td><code id="harsm_+3A_group">group</code></td>
<td>
<p>the string name of the group variable in the data,
or a bare character with the group name. The group indices
need not be integers, but that is more efficient. 
They need not be sorted.</p>
</td></tr>
<tr><td><code id="harsm_+3A_weights">weights</code></td>
<td>
<p>an optional vector of weights, or the string or bare name of the 
weights in the <code>data</code> for use in the fitting process. The weights
are attached to the outcomes, not the participant.  Set to <code>NULL</code>
for none.</p>
</td></tr>
<tr><td><code id="harsm_+3A_fit0">fit0</code></td>
<td>
<p>An optional object of class <code>harsm</code> or of <code>hensm</code> 
with the initial fit estimates. 
These will be used for &lsquo;warm start&rsquo; of the estimation procedure. 
A warm start should only speed up estimation, not change the ultimate results. 
When there is mismatch between the coefficients in <code>fit0</code> and the model 
being fit here, the missing coefficients are initialized as zero.</p>
</td></tr>
<tr><td><code id="harsm_+3A_na.action">na.action</code></td>
<td>
<p>How to deal with missing values in the outcomes,
groups, weights, etc.</p>
</td></tr>
<tr><td><code id="harsm_+3A_object">object</code></td>
<td>
<p>an object of class <code>harsm</code>.</p>
</td></tr>
<tr><td><code id="harsm_+3A_...">...</code></td>
<td>
<p>For <code>lm()</code>: additional arguments to be passed to the low level
regression fitting functions (see below).</p>
</td></tr>
<tr><td><code id="harsm_+3A_x">x</code></td>
<td>
<p>an object used to select a method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs a softmax regression by groups, via Maximum Likelihood Estimation,
under the Harville model. 
We fit <code class="reqn">\beta</code> where odds are <code class="reqn">\eta = x^{\top}\beta</code> for 
independent variables <code class="reqn">x</code>. 
The probability of taking first place is then <code class="reqn">\mu=c\exp{\eta}</code>,
where the <code class="reqn">c</code> is chosen so the <code class="reqn">\mu</code> sum to one.
Under the Harville model, conditional on the first place finisher
having been observed, the probability model for second
(and successive) places with the probabilities of the remaining
participants renormalized.
</p>
<p>The <code>print</code> method of the <code>harsm</code> object includes
a display of the R-squared. This measures the improvement
in squared errors of the expected rank from the model
over the null model which posits that all odds are equal.
When the formula includes an offset, a &lsquo;delta R-squared&rsquo;
is also output. This is the improvement in predicted
ranks over the model based on the offset term.
Note that the expected ranks are only easy to produce
under the Harville model; under the Henery model, 
the summary R-squared statistics are not produced.
Note that this computation uses weighted sums of squares,
as the weights contribute to the likelihood term.
However, the square sum computation does not take into
account the standard error of the rank, and so
unlike in linear regression, the softmax regression
does not always give positive R-squareds,
and the statistic is otherwise hard to interpret.
</p>


<h3>Value</h3>

<p>An object of class <code>harsm</code>, but also of <code>maxLik</code> with the
fit.
</p>


<h3>Note</h3>

<p>Since version 0.1.0 of this package, the
normalization of weights used in this function
have changed under the hood. This is to
give correct inference in the case where
zero weights are used to signify finishing
places were not observed. If in doubt,
please confirm inference by simulations,
taking as example the simulations in the README.
</p>
<p>This regression may give odd results when the outcomes are tied,
imposing an arbitrary order on the tied outcomes.
Moreover, no warning may be issued in this case.
In future releases, ties may be dealt with differently,
perhaps in analogy to how ties are treated in the
Cox Proportional Hazards regression, using
the methods of Breslow or Efron.
</p>
<p>To avoid incorrect inference when only the top
performers are recorded, and all others are 
effectively tied, one should use weighting.
Set the weights to zero for participants who
are tied non-winners, and one for the rest
So for example, if you observe the Gold, Silver,
and Bronze medal winners of an Olympic event
that had a starting field of 12 participants,
set weights to 1 for the medal winners, and 0
for the others. Note that the weights do not
attach to the participants, they attach to
the place they took.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+harsmfit">harsmfit</a></code>, <code><a href="#topic+harsmlik">harsmlik</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
nfeat &lt;- 5
set.seed(1234)
g &lt;- ceiling(seq(0.1,1000,by=0.1))
X &lt;- matrix(rnorm(length(g) * nfeat),ncol=nfeat)
beta &lt;- rnorm(nfeat)
eta &lt;- X %*% beta
y &lt;- rsm(eta,g)
# now the pretty frontend
data &lt;- cbind(data.frame(outcome=y,race=g),as.data.frame(X))

fmla &lt;- outcome ~ V1 + V2 + V3 + V4 + V5
fitm &lt;- harsm(fmla,data,group=race)

eta0 &lt;- rowMeans(X)
data &lt;- cbind(data.frame(outcome=y,race=g,eta0=eta0),as.data.frame(X))
fmla &lt;- outcome ~ offset(eta0) + V1 + V2 + V3 + V4 + V5
fitm &lt;- harsm(fmla,data,group=race)

# with weights
data &lt;- cbind(data.frame(outcome=y,race=g,eta0=eta0),as.data.frame(X))
data$wts &lt;- runif(nrow(data),min=1,max=2)
fmla &lt;- outcome ~ offset(eta0) + V1 + V2 + V3 + V4 + V5
fitm &lt;- harsm(fmla,data,group=race,weights=wts)

# softmax on the Best Picture data
data(best_picture)
df &lt;- best_picture
df$place &lt;- ifelse(df$winner,1,2)
df$weight &lt;- ifelse(df$winner,1,0)

fmla &lt;- place ~ nominated_for_BestDirector + nominated_for_BestActor + Drama 
fit0 &lt;- harsm(fmla,data=df,group=year,weights=weight) 

# warm start is a thing:
sub_fmla &lt;- place ~ nominated_for_BestDirector + nominated_for_BestActor 
fit1 &lt;- harsm(sub_fmla,data=df,group=year,weights=weight,fit0=fit0) 


# test against logistic regression
if (require(dplyr)) {
nevent &lt;- 10000
set.seed(1234)
adf &lt;- data_frame(eventnum=floor(seq(1,nevent + 0.7,by=0.5))) %&gt;%
  mutate(x=rnorm(n()),
         program_num=rep(c(1,2),nevent),
         intercept=as.numeric(program_num==1),
         eta=1.5 * x + 0.3 * intercept,
         place=ohenery::rsm(eta,g=eventnum))

# Harville model
modh &lt;- harsm(place ~ intercept + x,data=adf,group=eventnum)

# the collapsed data.frame for glm
ddf &lt;- adf %&gt;%
  arrange(eventnum,program_num) %&gt;%
  group_by(eventnum) %&gt;%
    summarize(resu=as.numeric(first(place)==1),
              delx=first(x) - last(x),
              deli=first(intercept) - last(intercept)) %&gt;%
  ungroup()

# glm logistic fit
modg &lt;- glm(resu ~ delx + 1,data=ddf,family=binomial(link='logit'))

all.equal(as.numeric(coef(modh)),as.numeric(coef(modg)),tolerance=1e-4)
all.equal(as.numeric(vcov(modh)),as.numeric(vcov(modg)),tolerance=1e-4)
}




</code></pre>

<hr>
<h2 id='harsm_invlink'>The inverse link for the softmax.</h2><span id='topic+harsm_invlink'></span>

<h3>Description</h3>

<p>The inverse link function for the softmax. This function
takes the group-wise probabilities, <code class="reqn">\mu</code>, and computes
the expected ranks within each group under the Harville
model. That is, it is a groupwise computation of 
the <code><a href="#topic+erank">erank</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>harsm_invlink(eta, mu = smax(eta, g), g = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="harsm_invlink_+3A_eta">eta</code></td>
<td>
<p>a vector of the odds.
Must be the same length as <code>g</code> if <code>g</code> is given.</p>
</td></tr>
<tr><td><code id="harsm_invlink_+3A_mu">mu</code></td>
<td>
<p>a vector of the probabilities. Should sum to one,
at least per group. 
Should be the same size as <code>g</code> if given. 
If both <code>mu</code> and <code>eta</code> are given, a warning
is issued, and the <code>mu</code> is used.</p>
</td></tr>
<tr><td><code id="harsm_invlink_+3A_g">g</code></td>
<td>
<p>a vector giving the group indices. If <code>NULL</code>,
then we assume only one group is in consideration.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of the ranks.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>See Also</h3>

<p>the ungrouped version of this, <code><a href="#topic+erank">erank</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mus &lt;- runif(12)
mus &lt;- mus / sum(mus)
harsm_invlink(mus)

harsm_invlink(mus,c(rep(1,6),rep(2,6)))
</code></pre>

<hr>
<h2 id='harsmfit'>Experts only softmax regression under Harville model.</h2><span id='topic+harsmfit'></span>

<h3>Description</h3>

<p>An &ldquo;experts only&rdquo; softmax fitting function for the Harville
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>harsmfit(
  y,
  g,
  X,
  wt = NULL,
  eta0 = NULL,
  beta0 = NULL,
  normalize_wt = FALSE,
  method = c("BFGS", "NR", "CG", "NM")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="harsmfit_+3A_y">y</code></td>
<td>
<p>a vector of the ranked outcomes within each group. Only
the order within a group matters.</p>
</td></tr>
<tr><td><code id="harsmfit_+3A_g">g</code></td>
<td>
<p>a vector giving the group indices. Need not be integers, but
that is more efficient. Need not be sorted.
Must be the same length as <code>y</code>.</p>
</td></tr>
<tr><td><code id="harsmfit_+3A_x">X</code></td>
<td>
<p>a matrix of the independent variables. Must have as many rows
as the length of <code>y</code>.</p>
</td></tr>
<tr><td><code id="harsmfit_+3A_wt">wt</code></td>
<td>
<p>an optional vector of the observation level weights. These must
be non-negative, otherwise an error is thrown. Note that the weight of
the last ranked outcome within a group is essentially ignored.
Must be the same length as <code>y</code>.</p>
</td></tr>
<tr><td><code id="harsmfit_+3A_eta0">eta0</code></td>
<td>
<p>an optional vector of the consensus odds. These are added to
the fit odds in odds space before the likelihood caclulation. If given,
then when the model is used to predict, similar consensus odds must be
given.
Must be the same length as <code>y</code>.</p>
</td></tr>
<tr><td><code id="harsmfit_+3A_beta0">beta0</code></td>
<td>
<p>an optional vector of the initial estimate of beta for
&lsquo;warm start&rsquo; of the estimation procedure.
Must be the same length as number of columns in <code>X</code>.
Should only affect the speed of the computation, not the results.
Defaults to all zeroes.</p>
</td></tr>
<tr><td><code id="harsmfit_+3A_normalize_wt">normalize_wt</code></td>
<td>
<p>if <code>TRUE</code>, we renormalize <code>wt</code>, if given,
to have mean value 1. Note that the default value has changed
since version 0.1.0 of this package. Moreover, non-normalized
weights can lead to incorrect inference. Use with caution.</p>
</td></tr>
<tr><td><code id="harsmfit_+3A_method">method</code></td>
<td>
<p>maximisation method, currently either 
&quot;NR&quot; (for Newton-Raphson),
&quot;BFGS&quot; (for Broyden-Fletcher-Goldfarb-Shanno), 
&quot;BFGSR&quot; (for the BFGS algorithm implemented in <span class="rlang"><b>R</b></span>),
&quot;BHHH&quot; (for Berndt-Hall-Hall-Hausman), 
&quot;SANN&quot; (for Simulated ANNealing), 
&quot;CG&quot; (for Conjugate Gradients), 
or &quot;NM&quot; (for Nelder-Mead).  
Lower-case letters (such as &quot;nr&quot; for Newton-Raphson) are allowed.
The default method is &quot;NR&quot; for unconstrained problems, and &quot;NM&quot; or
&quot;BFGS&quot; for constrained problems, depending on if the <code>grad</code>
argument was provided.  &quot;BHHH&quot; is a good alternative given the
likelihood is returned observation-wise (see <code><a href="maxLik.html#topic+maxBHHH">maxBHHH</a></code>).
</p>
<p>Note that stochastic gradient ascent (SGA) is currently not supported
as this method seems to be rarely used for maximum likelihood estimation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a number of events, indexed by group, and a vector <code class="reqn">y</code> of
the ranks of each entry within that group, perform maximum likelihood
estimation under the softmax and proportional probability model.
</p>
<p>The user can optionally supply a vector of <code class="reqn">\eta_0</code>, which are
taken as the fixed, or &lsquo;consensus&rsquo; odds. The estimation is
then conditional on these fixed odds.
</p>
<p>Weighted estimation is supported.
</p>
<p>The code relies on the likelihood function of <code><a href="#topic+harsmlik">harsmlik</a></code>,
and MLE code from <code><a href="maxLik.html#topic+maxLik">maxLik</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>harsm</code>, <code>maxLik</code>, and <code>linodds</code>.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Harville, D. A. &quot;Assigning probabilities to the outcomes of multi-entry competitions.&quot; 
Journal of the American Statistical Association 68, no. 342 (1973): 312-316.
<a href="https://doi.org/10.1080/01621459.1973.10482425">doi:10.1080/01621459.1973.10482425</a>
</p>


<h3>See Also</h3>

<p>the likelihood function, <code><a href="#topic+harsmlik">harsmlik</a></code>, and the
expected rank function (the inverse link), <code><a href="#topic+erank">erank</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nfeat &lt;- 5
set.seed(1234)
g &lt;- ceiling(seq(0.1,1000,by=0.1))
X &lt;- matrix(rnorm(length(g) * nfeat),ncol=nfeat)
beta &lt;- rnorm(nfeat)
eta &lt;- X %*% beta
y &lt;- rsm(eta,g)
     
mod0 &lt;- harsmfit(y=y,g=g,X=X)
summary(mod0)
# now upweight finishers 1-5
modw &lt;- harsmfit(y=y,g=g,X=X,wt=1 + as.numeric(y &lt; 6))
summary(modw)
</code></pre>

<hr>
<h2 id='hensm'>Friendly interface to softmax regression under Henery model.</h2><span id='topic+hensm'></span><span id='topic+vcov.hensm'></span><span id='topic+print.hensm'></span>

<h3>Description</h3>

<p>A user friendly interface to the softmax regression under the Henery model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hensm(
  formula,
  data,
  group = NULL,
  weights = NULL,
  ngamma = 4,
  fit0 = NULL,
  na.action = na.omit
)

## S3 method for class 'hensm'
vcov(object, ...)

## S3 method for class 'hensm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hensm_+3A_formula">formula</code></td>
<td>
<p>an object of class <code>"<a href="stats.html#topic+formula">formula</a>"</code> (or one that
can be coerced to that class): a symbolic description of the
model to be fitted.  The details of model specification are given
under &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="hensm_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object
coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing
the variables in the model.  If not found in <code>data</code>, the
variables are taken from <code>environment(formula)</code>,
typically the environment from which <code>lm</code> is called.</p>
</td></tr>
<tr><td><code id="hensm_+3A_group">group</code></td>
<td>
<p>the string name of the group variable in the data,
or a bare character with the group name. The group indices
need not be integers, but that is more efficient. 
They need not be sorted.</p>
</td></tr>
<tr><td><code id="hensm_+3A_weights">weights</code></td>
<td>
<p>an optional vector of weights, or the string or bare name of the 
weights in the <code>data</code> for use in the fitting process. The weights
are attached to the outcomes, not the participant.  Set to <code>NULL</code>
for none.</p>
</td></tr>
<tr><td><code id="hensm_+3A_ngamma">ngamma</code></td>
<td>
<p>The number of gammas to fit. Should be at least 2.</p>
</td></tr>
<tr><td><code id="hensm_+3A_fit0">fit0</code></td>
<td>
<p>An optional object of class <code>hensm</code> or of <code>harsm</code> 
with the initial fit estimates. 
These will be used for &lsquo;warm start&rsquo; of the estimation procedure. 
A warm start should only speed up estimation, not change the ultimate results. 
When there is mismatch between the coefficients in <code>fit0</code> and the model 
being fit here, the missing coefficients are initialized as zero. 
If <code>ngamma</code> is <code>NULL</code> and <code>fit0</code> is given, 
we default to the number of gammas in the initial fit, otherwise
we fill any missing gammas with 1.
If a <code>harsm</code> object is given, then <code>ngamma</code> must be non-null.</p>
</td></tr>
<tr><td><code id="hensm_+3A_na.action">na.action</code></td>
<td>
<p>How to deal with missing values in <code>y</code>, <code>g</code>,
<code>X</code>, <code>wt</code>, <code>eta0</code>.</p>
</td></tr>
<tr><td><code id="hensm_+3A_object">object</code></td>
<td>
<p>an object of class <code>hensm</code>.</p>
</td></tr>
<tr><td><code id="hensm_+3A_...">...</code></td>
<td>
<p>For <code>lm()</code>: additional arguments to be passed to the low level
regression fitting functions (see below).</p>
</td></tr>
<tr><td><code id="hensm_+3A_x">x</code></td>
<td>
<p>an object used to select a method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Performs a softmax regression by groups, via Maximum Likelihood Estimation.
It is assumed that successive sub-races maintain the proportional
probability of the softmax, up to some gamma coefficients, 
<code class="reqn">\gamma_2, \gamma_3, ..., \gamma_n</code>, which we fit. This model
nests the Harville model fit by <code><a href="#topic+harsm">harsm</a></code>, by fixing all
the gammas equal to 1.
</p>


<h3>Value</h3>

<p>An object of class <code>hensm</code>, but also of <code>maxLik</code> with the
fit.
</p>


<h3>Note</h3>

<p>This regression may give odd results when the outcomes are tied,
imposing an arbitrary order on the tied outcomes.
Moreover, no warning may be issued in this case.
In future releases, ties may be dealt with differently,
perhaps in analogy to how ties are treated in the
Cox Proportional Hazards regression, using
the methods of Breslow or Efron.
</p>
<p>To avoid incorrect inference when only the top
performers are recorded, and all others are 
effectively tied, one should use weighting.
Set the weights to zero for participants who
are tied non-winners, and one for the rest
So for example, if you observe the Gold, Silver,
and Bronze medal winners of an Olympic event
that had a starting field of 12 participants,
set weights to 1 for the medal winners, and 0
for the others. Note that the weights do not
attach to the participants, they attach to
the place they took.
</p>
<p>Since version 0.1.0 of this package, the
normalization of weights used in this function
have changed under the hood. This is to
give correct inference in the case where
zero weights are used to signify finishing
places were not observed. If in doubt,
please confirm inference by simulations,
taking as example the simulations in the README.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+harsm">harsm</a></code>, <code><a href="#topic+smlik">smlik</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
nfeat &lt;- 5
set.seed(1234)
g &lt;- ceiling(seq(0.1,1000,by=0.1))
X &lt;- matrix(rnorm(length(g) * nfeat),ncol=nfeat)
beta &lt;- rnorm(nfeat)
eta &lt;- X %*% beta
# 2FIX: do rhenery
y &lt;- rsm(eta,g)
# now the pretty frontend
data &lt;- cbind(data.frame(outcome=y,race=g),as.data.frame(X))

fmla &lt;- outcome ~ V1 + V2 + V3 + V4 + V5
fitm &lt;- hensm(fmla,data,group=race)

# with offset
eta0 &lt;- rowMeans(X)
data &lt;- cbind(data.frame(outcome=y,race=g,eta0=eta0),as.data.frame(X))
fmla &lt;- outcome ~ offset(eta0) + V1 + V2 + V3 + V4 + V5
fitm &lt;- hensm(fmla,data,group=race)

# on horse race data
library(dplyr)
data(race_data)
df &lt;- race_data %&gt;%
	group_by(EventId) %&gt;%
		mutate(eta0=log(WN_pool / sum(WN_pool))) %&gt;%
	ungroup() %&gt;%
	mutate(weights=ifelse(!is.na(Finish),1,0)) %&gt;%
	mutate(fac_age=cut(Age,c(0,3,5,7,Inf),include.lowest=TRUE)) 

# Henery Model with market efficiency
hensm(Finish ~ eta0,data=df,group=EventId,weights=weights,ngamma=3)

# look for age effect not captured by consensus odds.
fmla &lt;- Finish ~ offset(eta0) + fac_age
fit0 &lt;- hensm(fmla,data=df,group=EventId,weights=weights,ngamma=2)
# allow warm start.
fit1 &lt;- hensm(fmla,data=df,group=EventId,weights=weights,fit0=fit0,ngamma=2)
# allow warm start with more gammas.
fit2 &lt;- hensm(fmla,data=df,group=EventId,weights=weights,fit0=fit0,ngamma=3)
# or a different formula
fit3 &lt;- hensm(update(fmla,~ . + PostPosition),data=df,group=EventId,weights=weights,fit0=fit0)

# warm start from harsm object
fit0_har &lt;- harsm(fmla,data=df,group=EventId,weights=weights)
fit4 &lt;- hensm(fmla,data=df,group=EventId,fit0=fit0_har,weights=weights)

</code></pre>

<hr>
<h2 id='inv_smax'>The inverse softmax function.</h2><span id='topic+inv_smax'></span>

<h3>Description</h3>

<p>The inverse softmax function: take a logarithm and center.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inv_smax(mu, g = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inv_smax_+3A_mu">mu</code></td>
<td>
<p>a vector of the probablities.
Must be the same length as <code>g</code> if <code>g</code> is given.
If <code>mu</code> and <code>eta</code> are both given, we ignore
<code>eta</code> and use <code>mu</code>.</p>
</td></tr>
<tr><td><code id="inv_smax_+3A_g">g</code></td>
<td>
<p>a vector giving the group indices. If <code>NULL</code>,
then we assume only one group is in consideration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the inverse of the softmax function. Given
vector <code class="reqn">\mu</code> for a single group, finds vector 
<code class="reqn">\eta</code> such that
</p>
<p style="text-align: center;"><code class="reqn">\eta_i = \log{\mu_i} + c,</code>
</p>

<p>where <code class="reqn">c</code> is chosen such that the <code class="reqn">\eta</code> sum 
to zero:
</p>
<p style="text-align: center;"><code class="reqn">c = \frac{-1}{n} \sum_i \log{\mu_i}.</code>
</p>



<h3>Value</h3>

<p>the centered log probabilities.
</p>


<h3>Note</h3>

<p>This function can deal with overflow in a semi-coherent way.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smax">smax</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># we can deal with large values:
set.seed(2345)
eta &lt;- rnorm(12,sd=1000)
mu &lt;- smax(eta)
eta0 &lt;- inv_smax(mu)
</code></pre>

<hr>
<h2 id='normalize'>Normalize a vector to sum to one.</h2><span id='topic+normalize'></span>

<h3>Description</h3>

<p>Divide a vector by its sum, resulting in a vector with
sum equal to one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normalize_+3A_x">x</code></td>
<td>
<p>vector of input data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the input divided by its sum. 
For the row-wise version, each row is divided by its sum.
</p>


<h3>Note</h3>

<p>This function will return <code>NA</code> when any elements of the input
are <code>NA</code>. May return <code>Inf</code> if the elements sum
to zero.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>

<hr>
<h2 id='ohenery-NEWS'>News for package 'ohenery':</h2><span id='topic+ohenery-NEWS'></span>

<h3>Description</h3>

<p>News for package &lsquo;ohenery&rsquo;
</p>




<h3><a href="https://cran.r-project.org/package=ohenery"><span class="pkg">ohenery</span></a> Version 0.1.2 (2024-10-25) </h3>


<ul>
<li><p> Allow warm start in harsm and hensm.
</p>
</li></ul>



<h3><a href="https://cran.r-project.org/package=ohenery"><span class="pkg">ohenery</span></a> Version 0.1.1 (2018-10-14) </h3>


<ul>
<li><p> Change default in harsm and hensm to use unnormalized weights,
correcting inference when not all finishes are observed.
</p>
</li></ul>



<h3><a href="https://cran.r-project.org/package=ohenery"><span class="pkg">ohenery</span></a> Initial Version 0.1.0 (2018-10-01) </h3>


<ul>
<li><p> first CRAN release.
</p>
</li></ul>


<hr>
<h2 id='race_data'>Horse Race Data</h2><span id='topic+race_data'></span>

<h3>Description</h3>

<p>Three weeks of horse race data from tracks worldwide.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(race_data)
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> object with 36,418 observations and 19 columns. 
</p>
<p>The columns are defined as follows:
</p>

<dl>
<dt><code>EventId</code></dt><dd><p>An integer ID denoting the event (race). These range from 1 to 4486.</p>
</dd>
<dt><code>TrackId</code></dt><dd><p>An integer ID number of the the track. There are 64
different tracks represented.</p>
</dd>
<dt><code>Type</code></dt><dd><p>The type of event, one of &ldquo;Thoroughbred&rdquo; or &ldquo;Harness&rdquo;.</p>
</dd>
<dt><code>RaceNum</code></dt><dd><p>The integer race number within a group of races at a track on a given date.</p>
</dd>
<dt><code>CorrectedPostTime</code></dt><dd><p>The &lsquo;corrected&rsquo; post time of the race, in the form <code>%Y-%m-%d %H:%M:%S</code>,
presumably in the PDT time zone. Has values like &ldquo;2019-03-05 02:30:00&rdquo;.</p>
</dd>
<dt><code>Yards</code></dt><dd><p>The length of the race, in yards.</p>
</dd>
<dt><code>SurfaceText</code></dt><dd><p>A string, one of 
&ldquo;Turf&rdquo;, &ldquo;Dirt&rdquo;, &ldquo;All-Weather&rdquo; or <code>NA</code>.</p>
</dd>
<dt><code>HorseName</code></dt><dd><p>The string name of the horse.</p>
</dd>
<dt><code>HorseId</code></dt><dd><p>A unique integer ID for each horse. As different horses can have the same name, this ID is constructed from the name 
of the Horse, the Sire and the Dam.</p>
</dd>
<dt><code>Age</code></dt><dd><p>The age of the horse, in integer years, at the time of the event.
Typically less than 10.</p>
</dd>
<dt><code>Sex</code></dt><dd><p>A single character denoting the sex of the horse. I
believe the codes are 
&ldquo;M&rdquo; for &ldquo;Mare&rdquo; (female four years or older), 
&ldquo;G&rdquo; for &ldquo;Gelding&rdquo;,
&ldquo;F&rdquo; for &ldquo;Filly&rdquo; (female under four years of age),
&ldquo;C&rdquo; for &ldquo;Colt&rdquo; (male under four years of age),
&ldquo;H&rdquo; for &ldquo;Horse&rdquo; (male four years of age and up),
&ldquo;R&rdquo; for &ldquo;Rig&rdquo; (hard to explain),
&ldquo;A&rdquo; for &ldquo;???&rdquo;. There are some <code>NA</code> values as well.</p>
</dd>
<dt><code>Weight_lbs</code></dt><dd><p>The weight in integer pounds of the jockey and any equipment. Typically around 120.</p>
</dd>
<dt><code>PostPosition</code></dt><dd><p>The integer starting position of the horse.
Typically there is a slight advantage to starting at the first or second
post position.</p>
</dd>
<dt><code>Medication</code></dt><dd><p>One of several codes indicating any medication the horse may
be taking at the time of the race. I believe &ldquo;L&rdquo; stands for
&ldquo;Lasix&rdquo;, a common medication for lung conditions that is thought to give
horses a slight boost in speed.</p>
</dd>
<dt><code>MorningLine</code></dt><dd><p>A double indicating the &ldquo;morning betting line&rdquo; for
win bets on the horse. It is not clear how to interpret this value, perhaps
it is return on a dollar. Values range from 0.40 to 80.</p>
</dd>
<dt><code>WN_pool</code></dt><dd><p>The total combined pool in win bets, in dollars, on
this horse at post time.</p>
</dd>
<dt><code>PL_pool</code></dt><dd><p>The total combined pool in place bets, in dollars, on
this horse at post time.</p>
</dd>
<dt><code>SH_pool</code></dt><dd><p>The total combined pool in show bets, in dollars, on
this horse at post time.</p>
</dd>
<dt><code>Finish</code></dt><dd><p>The integer finishing position of the horse. A 1 means first place. We only collect values of 1, 2, and 3, while
the remaining finishing places are unknown and left as <code>NA</code>.</p>
</dd>
</dl>



<h3>Note</h3>

<p>The author makes no guarantees regarding correctness of this data.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>Source</h3>

<p>Data were sourced from the web. Don't ask.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
data(race_data)

# compute win bet efficiency
efficiency &lt;- race_data %&gt;%
  group_by(EventId) %&gt;%
    mutate(ImpliedOdds=WN_pool / sum(WN_pool,na.rm=TRUE)) %&gt;%
  ungroup() %&gt;%
  mutate(OddsBucket=cut(ImpliedOdds,c(0,0.05,seq(0.1,1,by=0.10)),include.lowest=TRUE)) %&gt;%
  group_by(OddsBucket) %&gt;%
    summarize(PropWin=mean(as.numeric(coalesce(Finish==1,FALSE)),na.rm=TRUE),
              MedImpl=median(ImpliedOdds,na.rm=TRUE),
              nObs=n()) %&gt;%
  ungroup()


if (require('ggplot2') &amp;&amp; require('scales')) {
  efficiency %&gt;%
    ggplot(aes(MedImpl,PropWin,size=nObs)) + 
    geom_point() + 
    scale_x_sqrt(labels=percent) + 
    scale_y_sqrt(labels=percent) + 
    geom_abline(slope=1,intercept=0,linetype=2,alpha=0.6) + 
    labs(title='actual win probability versus implied win probability',
         size='# horses',
         x='implied win probability',
         y='observed win probability')
 }


</code></pre>

<hr>
<h2 id='rhenery'>Random generation under the Henery (or Harville) softmax model.</h2><span id='topic+rhenery'></span>

<h3>Description</h3>

<p>Given base probabilities, and Henery gamma coefficients,
performs random generation, using R's built in rand seed,
of the final outcome of a race for each participant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rhenery(mu, gamma = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rhenery_+3A_mu">mu</code></td>
<td>
<p>a vector of the probabilities of taking first place.</p>
</td></tr>
<tr><td><code id="rhenery_+3A_gamma">gamma</code></td>
<td>
<p>a vector of the gamma coefficients. Should have length
one less than <code>mu</code>, but if longer the unused elements are ignored.
If shorter, we reserve the right to either throw an error or extend out
the last gamma element. If not given, the coefficients are assumed
to be all one, which is the Harville model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given vectors <code class="reqn">\mu</code> and <code class="reqn">\gamma</code>, first computes
</p>
<p style="text-align: center;"><code class="reqn">\pi_{1,i} = \frac{\mu_i^{\gamma_1}}{\sum_j \mu_j^{\gamma_1}},</code>
</p>

<p>then assigns a <code class="reqn">1</code> to participant <code class="reqn">i</code> with probability
<code class="reqn">\pi_{1,i}</code>. The &lsquo;winning&rsquo; participant is then removed
from consideration, and the process is repeated using the remaining
<code class="reqn">\mu</code> and <code class="reqn">\gamma</code> vectors.
</p>
<p>Typically one has that <code class="reqn">\mu_i = \exp{\eta_i}</code>, for some
&lsquo;odds&rsquo;, <code class="reqn">\eta_i</code>.
</p>
<p>When the <code class="reqn">\gamma</code> are all one, you recover the Harville softmax
model.
</p>


<h3>Value</h3>

<p>A vector, of the same length as the probabilities, giving
the entry of each horse. Note that the expected value of this
returned thing makes sense, it is <em>not</em> the finished rank ordering
of a race.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rsm">rsm</a></code>
</p>

<hr>
<h2 id='rsm'>Generate variates from a softmax distribution.</h2><span id='topic+rsm'></span>

<h3>Description</h3>

<p>Generate variates from a softmax distribution
under Harville or Henery models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsm(eta, g = NULL, mu = NULL, gamma = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rsm_+3A_eta">eta</code></td>
<td>
<p>a vector of the odds.
Must be the same length as <code>g</code> if <code>g</code> is given.</p>
</td></tr>
<tr><td><code id="rsm_+3A_g">g</code></td>
<td>
<p>a vector giving the group indices. If <code>NULL</code>,
then we assume only one group is in consideration.</p>
</td></tr>
<tr><td><code id="rsm_+3A_mu">mu</code></td>
<td>
<p>a vector of the probablities.
Must be the same length as <code>g</code> if <code>g</code> is given.
If <code>mu</code> and <code>eta</code> are both given, we ignore
<code>eta</code> and use <code>mu</code>.</p>
</td></tr>
<tr><td><code id="rsm_+3A_gamma">gamma</code></td>
<td>
<p>a vector of the gamma parameters for the
Henery model. Typically the first element should be 1.
Omit or set all values to 1 to recover the Harville model.
The last element will be extended if the gamma is
not long enough for a given group. Note that gamma is expected
to be very short, and is not &lsquo;aligned&rsquo; with
<code>eta</code> in any way.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given the <code class="reqn">\eta</code> in odds space, and a grouping
variable, returns values in one to the number of
elements in a group. That is, we have a permutation
of 1 through <code class="reqn">n_g</code> on each group as output.
</p>
<p>For a single group, the probability that the <code class="reqn">i</code>th
element of the output is a 1 is equal to
</p>
<p style="text-align: center;"><code class="reqn">\pi_{1,i} = \frac{\mu_i^{\gamma_1}}{\sum_j \mu_j^{\gamma_1}}.</code>
</p>

<p>Once an element has been selected to have output
1, remove it from the set and iterate, but with the
next <code class="reqn">\gamma</code> elements.
</p>


<h3>Value</h3>

<p>a vector of integers, each a permutation of one through
the number of elements in each group.
</p>


<h3>Note</h3>

<p>The output of this function satisfies a kind
of order invariance that <code><a href="#topic+rhenery">rhenery</a></code>
does not, at the cost of some computational inefficiency.
Namely that for a fixed randseed, and for distinct
<code>eta</code>, the output is equivariant with respect
to permutation of the vector <code>eta</code> when there
is only one group.
</p>
<p>Regarding the &lsquo;direction&rsquo;, we associate
higher odds with a smaller outcome. That is, the ith element of
the output encodes the place that the ith participant 
took in the simulated &lsquo;race&rsquo;; it should be small if the
odds for that participant are very high.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simple use
set.seed(1234)
g &lt;- ceiling(seq(1,10,by=0.1))
eta &lt;- rnorm(length(g))
y &lt;- rsm(eta,g=g)

# same same:
set.seed(235)
y1 &lt;- rsm(eta,g=g)
set.seed(235)
y2 &lt;- rsm(g=g,mu=smax(eta,g=g))
y1 - y2

# the default model is Harville
set.seed(1212)
y1 &lt;- rsm(eta,g=g)
set.seed(1212)
y2 &lt;- rsm(eta,g=g,gamma=c(1,1,1,1))
y1 - y2

# repeat several times with the cards stack against
# early runners
set.seed(1234)
colMeans(t(replicate(1000,rsm(sort(rnorm(10,sd=1.5)),g=rep(1,10)))))

# illustrate the invariance
mu &lt;- (1:10) / 55
set.seed(1414)
y1 &lt;- rsm(mu=mu,gamma=c(1,1,1))
set.seed(1414)
y2 &lt;- rev(rsm(mu=rev(mu),gamma=c(1,1,1)))
y1 - y2


nfeat &lt;- 5
set.seed(1234)
g &lt;- ceiling(seq(0.1,1000,by=0.1))
X &lt;- matrix(rnorm(length(g) * nfeat),ncol=nfeat)
beta &lt;- rnorm(nfeat)
eta &lt;- X %*% beta
y &lt;- rsm(eta,g=g)

idx &lt;- order(g,y,decreasing=TRUE) - 1
fooey &lt;- harsmlik(g,idx,eta,deleta=X)
set.seed(3493)
dib &lt;- rnorm(length(beta))
xvl &lt;- seq(-0.01,0.01,length.out=301)
rsu &lt;- sapply(xvl,
              function(del) {
                beta1 &lt;- beta + del * dib
                eta1 &lt;- X %*% beta1
                fooey2 &lt;- harsmlik(g,idx,eta1,deleta=X)
                as.numeric(fooey2) - as.numeric(fooey)
              })
drv &lt;- sapply(xvl,
              function(del) {
                beta1 &lt;- beta + del * dib
                eta1 &lt;- X %*% beta1
                fooey2 &lt;- harsmlik(g,idx,eta1,deleta=X)
                sum(attr(fooey2,'gradient') * dib)
              })

if (require('ggplot2') &amp;&amp; require('dplyr')) {
  bestx &lt;- xvl[which.max(rsu)]
  ph &lt;- data.frame(x=xvl,lik=rsu,grd=drv) %&gt;%
    ggplot(aes(x=x,y=lik)) + 
    geom_point() + 
    geom_line(aes(y=grd/200)) +
    geom_vline(xintercept=bestx,linetype=2,alpha=0.5) + 
    geom_hline(yintercept=0,linetype=2,alpha=0.5)
  print(ph)
}


if (require('dplyr') &amp;&amp; require('knitr')) {
  # expect this to be very small, almost always 1
  set.seed(1234)
  simdraw &lt;- replicate(10000,{
    rsm(eta=c(100,rnorm(7)))[1]
  })

  as.data.frame(table(simdraw)) %&gt;%
    mutate(prob=Freq / sum(Freq)) %&gt;%
    knitr::kable()

  # expect this to be uniform on 2 through 8
  set.seed(1234)
  simdraw &lt;- replicate(10000,{
    rsm(eta=c(100,rnorm(7)))[2]
  })

  as.data.frame(table(simdraw)) %&gt;%
    mutate(prob=Freq / sum(Freq)) %&gt;%
    knitr::kable()
}

</code></pre>

<hr>
<h2 id='smax'>The softmax function.</h2><span id='topic+smax'></span>

<h3>Description</h3>

<p>The softmax function: exponentiate a vector and then
normalize.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smax(eta, g = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smax_+3A_eta">eta</code></td>
<td>
<p>numeric array of the odds.
The odds are de-meaned within each group.</p>
</td></tr>
<tr><td><code id="smax_+3A_g">g</code></td>
<td>
<p>a vector giving the group indices. If <code>NULL</code>,
then we assume only one group is in consideration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given vector <code class="reqn">\eta</code> for a single group, essentially
computes vector <code class="reqn">\mu</code> defined by 
</p>
<p style="text-align: center;"><code class="reqn">\mu_i = \frac{\exp{\eta_i}}{\sum_j \exp{\eta_j}}.</code>
</p>

<p>Note that this computation should be invariant with respect
to level shifts of the <code class="reqn">\eta</code>, and thus we de-mean
the odds first.
</p>


<h3>Value</h3>

<p>the exponentiated data normalized.
For the row-wise version, each row is soft maxed.
</p>


<h3>Note</h3>

<p>This function can deal with overflow in a semi-coherent way.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+normalize">normalize</a></code>, <code><a href="#topic+inv_smax">inv_smax</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># we can deal with large values:
set.seed(2345)
eta &lt;- rnorm(12,sd=1000)
smax(eta)
</code></pre>

<hr>
<h2 id='smlik'>Softmax log likelihood under Harville and Henery Models.</h2><span id='topic+smlik'></span><span id='topic+harsmlik'></span><span id='topic+hensmlik'></span>

<h3>Description</h3>

<p>Compute the softmax log likelihood and gradient of the same.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>harsmlik(g, idx, eta, wt = NULL, deleta = NULL)

hensmlik(g, idx, eta, gamma, wt = NULL, deleta = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smlik_+3A_g">g</code></td>
<td>
<p>a vector giving the group indices.</p>
</td></tr>
<tr><td><code id="smlik_+3A_idx">idx</code></td>
<td>
<p>a vector of integers, the same length as <code>g</code>, which
describes the reverse sort order on the observations, first by group,
then by place within the group. That is, the element <code>idx[0]</code> is the
index of the last place finisher in the group <code>g[0]</code>; then
<code>idx[1]</code> is the index of the next-to-last place finisher in
<code>g[1]</code> (assuming it equals <code>g[0]</code>), and so on.
The <code>idx</code> shall be zero based.</p>
</td></tr>
<tr><td><code id="smlik_+3A_eta">eta</code></td>
<td>
<p>a vector of the odds.
Must be the same length as <code>g</code>.</p>
</td></tr>
<tr><td><code id="smlik_+3A_wt">wt</code></td>
<td>
<p>an optional vector of non-negative elements, the same length
as <code>g</code>, giving the observation level weights. We then compute a 
weighted log likelihood, where the weights are in each summand.
The weights should probably have mean 1, but that's just, like, my
opinion, man. Negative weights throw an error. Note that the weights
for the last place in each group have no effect on the computation.</p>
</td></tr>
<tr><td><code id="smlik_+3A_deleta">deleta</code></td>
<td>
<p>an optional matrix whose row count equals the number of elements
of <code>g</code>, <code>idx</code>, and <code>eta</code>. The rows of <code>deleta</code> are the derivatives of
eta with respect to some <code class="reqn">z</code>. This is used to then maximize
likelihood with respect to <code class="reqn">z</code>.</p>
</td></tr>
<tr><td><code id="smlik_+3A_gamma">gamma</code></td>
<td>
<p>a vector of the gamma parameters. It is assumed that the
first element is <code class="reqn">\gamma_2</code>, while the last element is applied
to all higher order tie breaks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given vectors <code class="reqn">g</code>, <code class="reqn">\eta</code> and optionally the gradient of <code class="reqn">\eta</code>
with respect to some coefficients, computes the log likelihood under the
softmax. The user must provide a reverse ordering as well, which is sorted
first by the groups, <code class="reqn">g</code>, and then, within a group, in increasing
quality order. For a race, this means that the index is in order from the
last place to the first place in that race, where the group numbers
correspond to one race.
</p>
<p>Under the Harville model, the log likelihood on a given group, where we are indexing
in <em>forward</em> order, is 
</p>
<p style="text-align: center;"><code class="reqn">\left(\eta_1 - \log \sum_{j \ge 1} \mu_j\right) + \left(\eta_2 - \log \sum_{j \ge 2} \mu_j\right) + ...</code>
</p>

<p>where <code class="reqn">\mu_i = \exp{\eta_i}</code>.
By &ldquo;forward order&rdquo;, we mean that <code class="reqn">\eta_1</code> corresponds to the
participant taking first place within that group, <code class="reqn">\eta_2</code> took second
place, and so on.
</p>
<p>The Henery model log likelihood takes the form
</p>
<p style="text-align: center;"><code class="reqn">\left(\eta_1 - \log \sum_{j \ge 1} \mu_j\right) + \left(\gamma_2 \eta_2 - \log \sum_{j \ge 2} \mu_j^{\gamma_2}\right) + ...</code>
</p>

<p>for gamma parameters, <code class="reqn">\gamma</code>.
The Henery model corresponds to the Harville model where all the gammas equal 1.
</p>
<p>Weights in weighted estimation apply to each summand.
The weight for the last place participant in a group is irrelevant.
The weighted log likelihood under the Harville model is
</p>
<p style="text-align: center;"><code class="reqn">w_1\left(\eta_1 - \log \sum_{j \ge 1} \mu_j\right) + w_2\left(\eta_2 - \log \sum_{j \ge 2} \mu_j\right) + ...</code>
</p>

<p>One should think of the weights as applying to the outcome,
not the participant.
</p>


<h3>Value</h3>

<p>The log likelihood. If <code>deleta</code> is given, we add an attribute
to the scalar number, called <code>gradient</code> giving the derivative.
For the Henery model we also include a term of <code>gradgamma</code> which is
the gradient of the log likelihood with respect to the gamma vector.
</p>


<h3>Note</h3>

<p>The likelihood function does not yet support ties.
</p>
<p>To avoid incorrect inference when only the top
performers are recorded, and all others are 
effectively tied, one should use weighting.
Set the weights to zero for participants who
are tied non-winners, and one for the rest
So for example, if you observe the Gold, Silver,
and Bronze medal winners of an Olympic event
that had a starting field of 12 participants,
set weights to 1 for the medal winners, and 0
for the others. Note that the weights do not
attach to the participants, they attach to
the place they took.
</p>


<h3>Author(s)</h3>

<p>Steven E. Pav <a href="mailto:shabbychef@gmail.com">shabbychef@gmail.com</a>
</p>


<h3>References</h3>

<p>Harville, D. A. &quot;Assigning probabilities to the outcomes of multi-entry competitions.&quot; 
Journal of the American Statistical Association 68, no. 342 (1973): 312-316.
<a href="https://doi.org/10.1080/01621459.1973.10482425">doi:10.1080/01621459.1973.10482425</a>
</p>
<p>Henery, R. J. &quot;Permutation probabilities as models for horse races.&quot; 
Journal of the Royal Statistical Society: Series B (Methodological) 43, no. 1 (1981): 86-91.
<a href="https://doi.org/10.1111/j.2517-6161.1981.tb01153.x">doi:10.1111/j.2517-6161.1981.tb01153.x</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a garbage example
set.seed(12345)
g &lt;- as.integer(sort(ceiling(20 * runif(100))))
idx &lt;- as.integer(rev(1:length(g)) - 1L)
eta &lt;- rnorm(length(g))
foo &lt;- harsmlik(g=g,idx=idx,eta=eta,deleta=NULL)

# an example with a real idx
nfeat &lt;- 5
set.seed(1234)
g &lt;- ceiling(seq(0.1,1000,by=0.1))
X &lt;- matrix(rnorm(length(g) * nfeat),ncol=nfeat)
beta &lt;- rnorm(nfeat)
eta &lt;- X %*% beta
y &lt;- rsm(eta,g)

idx &lt;- order(g,y,decreasing=TRUE) - 1
foores &lt;- harsmlik(g,idx,eta,deleta=X)

# now reweight them
wt &lt;- runif(length(g))
wt &lt;- wt / mean(wt)   # mean 1 is recommended
foores &lt;- harsmlik(g,idx,eta,wt=wt)

# try hensmlik 
foores &lt;- hensmlik(g,idx,eta,gamma=c(0.9,0.8,1),wt=wt)

# check the value of the gradient by numerical approximation

 nfeat &lt;- 8
 set.seed(321)
 g &lt;- ceiling(seq(0.1,1000,by=0.1))
 X &lt;- matrix(rnorm(length(g) * nfeat),ncol=nfeat)
 beta &lt;- rnorm(nfeat)
 eta &lt;- X %*% beta
 y &lt;- rsm(eta,g)
 
 idx &lt;- order(g,y,decreasing=TRUE) - 1
 if (require(numDeriv)) {
 
 	fastval &lt;- attr(harsmlik(g,idx,eta,deleta=X),'gradient')
 	numap &lt;- grad(function(beta,g,idx,X) { 
 			 eta &lt;- X %*% beta
 			 as.numeric(harsmlik(g,idx,eta))
 			 },
 			 x=beta,g=g,idx=idx,X=X)
 	rbind(fastval,numap)
 }

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
