<!DOCTYPE html><html lang="en"><head><title>Help for package bit64</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bit64}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bit64-package'><p>A S3 class for vectors of 64bit integers</p></a></li>
<li><a href='#all.equal.integer64'><p>Test if two integer64 vectors are all.equal</p></a></li>
<li><a href='#as.character.integer64'><p>Coerce from integer64</p></a></li>
<li><a href='#as.data.frame.integer64'><p>integer64: Coercing to data.frame column</p></a></li>
<li><a href='#as.integer64.character'><p>Coerce to integer64</p></a></li>
<li><a href='#benchmark64'><p>Function for measuring algorithmic performance of high-level and low-level integer64 functions</p></a></li>
<li><a href='#benchmark64.data'><p>Results of performance measurement on a Core i7 Lenovo T410 8 GB RAM under Windows 7 64bit</p></a></li>
<li><a href='#bit64S3'><p>Turning base R functions into S3 generics for bit64</p></a></li>
<li><a href='#c.integer64'><p>Concatenating integer64 vectors</p></a></li>
<li><a href='#cache'><p>Atomic Caching</p></a></li>
<li><a href='#cumsum.integer64'><p>Cumulative Sums, Products, Extremes and lagged differences</p></a></li>
<li><a href='#duplicated.integer64'><p>Determine Duplicate Elements of integer64</p></a></li>
<li><a href='#extract.replace.integer64'><p>Extract or Replace Parts of an integer64 vector</p></a></li>
<li><a href='#format.integer64'><p>Unary operators and functions for integer64 vectors</p></a></li>
<li><a href='#hashcache'><p>Big caching of hashing, sorting, ordering</p></a></li>
<li><a href='#hashmap'><p>Hashing for 64bit integers</p></a></li>
<li><a href='#identical.integer64'><p>Identity function for class 'integer64'</p></a></li>
<li><a href='#is.sorted.integer64'><p>Small cache access methods</p></a></li>
<li><a href='#keypos'><p>Extract Positions in redundant dimension table</p></a></li>
<li><a href='#match.integer64'><p>64-bit integer matching</p></a></li>
<li><a href='#matrix64'><p>Working with integer64 arrays and matrices</p></a></li>
<li><a href='#optimizer64.data'><p>Results of performance measurement on a Core i7 Lenovo T410 8 GB RAM under Windows 7 64bit</p></a></li>
<li><a href='#plusclass'><p>integer64: Maintaining S3 class attribute</p></a></li>
<li><a href='#prank'><p>(P)ercent (Rank)s</p></a></li>
<li><a href='#qtile'><p>(Q)uan(Tile)s</p></a></li>
<li><a href='#ramsort.integer64'><p>Low-level intger64 methods for in-RAM sorting and ordering</p></a></li>
<li><a href='#rank.integer64'><p>Sample Ranks from integer64</p></a></li>
<li><a href='#rep.integer64'><p>Replicate elements of integer64 vectors</p></a></li>
<li><a href='#runif64'><p>integer64: random numbers</p></a></li>
<li><a href='#seq.integer64'><p>integer64: Sequence Generation</p></a></li>
<li><a href='#sort.integer64'><p>High-level intger64 methods for sorting and ordering</p></a></li>
<li><a href='#sortnut'><p>Searching and other uses of sorting for 64bit integers</p></a></li>
<li><a href='#sum.integer64'><p>Summary functions for integer64 vectors</p></a></li>
<li><a href='#table.integer64'><p>Cross Tabulation and Table Creation for integer64</p></a></li>
<li><a href='#tiepos'><p>Extract Positions of Tied Elements</p></a></li>
<li><a href='#unipos'><p>Extract Positions of Unique Elements</p></a></li>
<li><a href='#unique.integer64'><p>Extract Unique Elements from integer64</p></a></li>
<li><a href='#xor.integer64'><p>Binary operators for integer64 vectors</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>A S3 Class for Vectors of 64bit Integers</td>
</tr>
<tr>
<td>Version:</td>
<td>4.6.0-1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0), bit (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>
  Package 'bit64' provides serializable S3 atomic 64bit (signed) integers.
  These are useful for handling database keys and exact counting in +-2^63.
  WARNING: do not use them as replacement for 32bit integers, integer64 are not
  supported for subscripting by R-core and they have different semantics when
  combined with double, e.g. integer64 + double =&gt; integer64.
  Class integer64 can be used in vectors, matrices, arrays and data.frames.
  Methods are available for coercion from and to logicals, integers, doubles,
  characters and factors as well as many elementwise and summary functions.
  Many fast algorithmic operations such as 'match' and 'order' support inter-
  active data exploration and manipulation and optionally leverage caching.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/r-lib/bit64">https://github.com/r-lib/bit64</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, methods, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.3), withr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/needs/development:</td>
<td>testthat</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-16 14:04:20 UTC; michael</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Chirico [aut, cre],
  Jens Oehlschl√§gel [aut],
  Leonardo Silvestri [ctb],
  Ofek Shilon [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Chirico &lt;michaelchirico4@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-16 16:00:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='bit64-package'>A S3 class for vectors of 64bit integers</h2><span id='topic+bit64-package'></span><span id='topic+bit64'></span><span id='topic+is.integer.integer64'></span><span id='topic+is.vector.integer64'></span><span id='topic+integer64'></span><span id='topic+is.integer64'></span><span id='topic+length+3C-.integer64'></span><span id='topic+print.integer64'></span><span id='topic+str.integer64'></span>

<h3>Description</h3>

<p>Package 'bit64' provides fast serializable S3 atomic 64bit (signed) integers
that can be used in vectors, matrices, arrays and data.frames. Methods are
available for coercion from and to logicals, integers, doubles, characters
and factors as well as many elementwise and summary functions.
</p>


<h4>Version 0.8</h4>

<p>With 'integer64' vectors you can store very large integers at the expense
of 64 bits, which is by factor 7 better than 'int64' from package 'int64'.
Due to the smaller memory footprint, the atomic vector architecture and
using only S3 instead of S4 classes, most operations are one to three orders
of magnitude faster: Example speedups are 4x for serialization, 250x for
adding, 900x for coercion and 2000x for object creation. Also 'integer64'
avoids an ongoing (potentially infinite) penalty for garbage collection
observed during existence of 'int64' objects (see code in example section).
</p>



<h4>Version 0.9</h4>

<p>Package 'bit64' - which extends R with fast 64-bit integers - now has fast
(single-threaded) implementations the most important univariate algorithmic
operations (those based on hashing and sorting). We now have methods for
'match', '%in%', 'duplicated', 'unique', 'table', 'sort', 'order', 'rank',
'quantile', 'median' and 'summary'. Regarding data management we also have
novel generics 'unipos' (positions of the unique values), 'tiepos' (
positions of ties), 'keypos' (positions of foreign keys in a sorted
dimension table) and derived methods 'as.factor' and 'as.ordered'. This 64-
bit functionality is implemented carefully to be not slower than the
respective 32-bit operations in Base R and also to avoid outlying waiting
times observed with 'order', 'rank' and 'table' (speedup factors 20/16/200
respective). This increases the dataset size with wich we can work truly
interactive. The speed is achieved by simple heuristic optimizers in high-
level functions choosing the best from multiple low-level algorithms and
further taking advantage of a novel caching if activated. In an example R
session using a couple of these operations the 64-bit integers performed 22x
faster than base 32-bit integers, hash-caching improved this to 24x,
sortorder-caching was most efficient with 38x (caching hashing and sorting
is not worth it with 32x at duplicated RAM consumption).
</p>



<h3>Usage</h3>

<pre><code class='language-R'>integer64(length = 0L)

is.integer64(x)

## S3 replacement method for class 'integer64'
length(x) &lt;- value

## S3 method for class 'integer64'
print(x, quote = FALSE, ...)

## S3 method for class 'integer64'
str(
  object,
  vec.len = strO$vec.len,
  give.head = TRUE,
  give.length = give.head,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bit64-package_+3A_length">length</code></td>
<td>
<p>length of vector using <code><a href="base.html#topic+integer">integer()</a></code></p>
</td></tr>
<tr><td><code id="bit64-package_+3A_x">x</code></td>
<td>
<p>an integer64 vector</p>
</td></tr>
<tr><td><code id="bit64-package_+3A_value">value</code></td>
<td>
<p>an integer64 vector of values to be assigned</p>
</td></tr>
<tr><td><code id="bit64-package_+3A_quote">quote</code></td>
<td>
<p>logical, indicating whether or not strings should be printed with surrounding quotes.</p>
</td></tr>
<tr><td><code id="bit64-package_+3A_...">...</code></td>
<td>
<p>further arguments to the <code><a href="base.html#topic+NextMethod">NextMethod()</a></code></p>
</td></tr>
<tr><td><code id="bit64-package_+3A_object">object</code></td>
<td>
<p>an integer64 vector</p>
</td></tr>
<tr><td><code id="bit64-package_+3A_vec.len">vec.len</code>, <code id="bit64-package_+3A_give.head">give.head</code>, <code id="bit64-package_+3A_give.length">give.length</code></td>
<td>
<p>see <code><a href="utils.html#topic+str">utils::str()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>integer64</code> returns a vector of 'integer64', i.e.,
a vector of <code><a href="base.html#topic+double">double()</a></code> decorated with class 'integer64'.
</p>


<h3>Design considerations</h3>

<p>64 bit integers are related to big data: we need them to overcome address space
limitations. Therefore performance of the 64 bit integer type is critical. In the
S language &ndash; designed in 1975 &ndash; atomic objects were defined to be vectors for a
couple of good reasons: simplicity, option for implicit parallelization, good
cache locality. In recent years many analytical databases have learnt that lesson:
column based data bases provide superior performance for many applications, the
result are products such as MonetDB, Sybase IQ, Vertica, Exasol, Ingres Vectorwise.
If we introduce 64 bit integers not natively in Base R but as an external package,
we should at least strive to make them as 'basic' as possible. Therefore the design
choice of bit64 not only differs from package int64, it is obvious: Like the other
atomic types in Base R, we model data type 'integer64' as a contiguous <code><a href="base.html#topic+atomic">atomic</a></code>
vector in memory, and we use the more basic <a href="methods.html#topic+S3">S3</a> class system, not <a href="base.html#topic+S4">S4</a>. Like
package int64 we want our 'integer64' to be <code><a href="base.html#topic+serialize">serialize</a></code>able, therefore we also
use an existing data type as the basis. Again the choice is obvious: R has only one
64 bit data type: doubles. By using <code><a href="base.html#topic+double">double</a></code>s, <code>integer64</code> <code><a href="base.html#topic+inherits">inherits</a></code> some
functionality such as <code><a href="base.html#topic+is.atomic">is.atomic()</a></code>, <code><a href="base.html#topic+length">length()</a></code>, <code><a href="base.html#topic+length+3C-">length&lt;-</a></code>, <code><a href="base.html#topic+names">names()</a></code>,
<code><a href="base.html#topic+names+3C-">names&lt;-</a></code>, <code><a href="base.html#topic+dim">dim()</a></code>, <code><a href="base.html#topic+dim+3C-">dim&lt;-</a></code>, <code><a href="base.html#topic+dimnames">dimnames()</a></code>, <code><a href="base.html#topic+dimnames+3C-">dimnames&lt;-</a></code>.
</p>
<p>Our R level functions strictly follow the functional programming paradigm:
no modification of arguments or other side-effects. Before version 0.93  we
internally deviated from the strict paradigm in order to boost performance. Our C
functions do not create new return values, instead we pass-in the memory to be
returned as an argument. This gives us the freedom to apply the C-function to new
or old vectors, which helps to avoid unnecessary memory allocation, unnecessary
copying and unnecessary garbage collection. Prior to 0.93 <em>within</em> our R functions
we also deviated from conventional R programming by not using <code><a href="base.html#topic+attr+3C-">attr&lt;-</a></code> and
<code><a href="base.html#topic+attributes+3C-">attributes&lt;-</a></code> because they always did new memory allocation and copying in older
R versions. If we wanted to set attributes of return values that we have freshly
created, we instead used functions <code><a href="bit.html#topic+getsetattr">bit::setattr()</a></code> and <code><a href="bit.html#topic+getsetattr">bit::setattributes()</a></code>.
From version 0.93 <code>bit::setattr()</code> is only used for manipulating <code><a href="#topic+cache">cache</a></code> objects,
in <code><a href="#topic+ramsort.integer64">ramsort.integer64()</a></code>, <code><a href="#topic+sort.integer64">sort.integer64()</a></code>, and <code><a href="#topic+as.data.frame.integer64">as.data.frame.integer64()</a></code>.
</p>


<h3>Arithmetic precision and coercion</h3>

<p>The fact that we introduce 64 bit long long integers &ndash; without introducing 128-bit
long doubles &ndash; creates some subtle challenges: Unlike 32 bit <code><a href="base.html#topic+integer">integer</a></code>s, the
<code>integer64</code> are no longer a proper subset of <code><a href="base.html#topic+double">double</a></code>. If a binary arithmetic
operation does involve a <code>double</code> and a <code>integer</code>, it is a no-brainer to return
<code>double</code> without loss of information. If an <code>integer64</code> meets a <code>double</code>, it is not
trivial what type to return. Switching to <code>integer64</code> limits our ability to
represent very large numbers, switching to <code>double</code> limits our ability to
distinguish <code>x</code> from <code>x+1</code>. Since the latter is the purpose of introducing 64 bit
integers, we usually return <code>integer64</code> from functions involving <code>integer64</code>, for
example in <code><a href="#topic+c.integer64">c()</a></code>, <code><a href="#topic+cbind.integer64">cbind()</a></code>, and
<code><a href="#topic+rbind.integer64">rbind()</a></code>
</p>
<p>Different from Base R, our operators <code><a href="#topic++2B.integer64">+</a></code>, <code><a href="#topic+-.integer64">-</a></code>,
<code><a href="#topic++25+2F+25.integer64">%/%</a></code>, and <code><a href="#topic++25+25.integer64">%%</a></code> coerce their arguments to
<code>integer64</code> and always return <code>integer64</code>.
</p>
<p>The multiplication operator <code><a href="#topic++2A.integer64">*</a></code> coerces its first argument to
<code>integer64</code> but allows its second argument to be also <code>double</code>: the second
argument is internaly coerced to 'long double' and the result of the
multiplication is returned as <code>integer64</code>.
</p>
<p>The division <code><a href="#topic++2F.integer64">/</a></code> and power <code><a href="#topic++5E.integer64">^</a></code> operators also
coerce their first argument to <code>integer64</code> and coerce internally their second
argument to 'long double', they return as <code>double</code>, like
<code><a href="#topic+sqrt.integer64">sqrt()</a></code>, <code><a href="#topic+log.integer64">log()</a></code>,
<code><a href="#topic+log2.integer64">log2()</a></code>, and <code><a href="#topic+log10.integer64">log10()</a></code> do.</p>

<table>
<tr>
 <td style="text-align: center;">
   <strong>argument1</strong> </td><td style="text-align: center;"> <strong>op</strong> </td><td style="text-align: center;"> <strong>argument2</strong> </td><td style="text-align: center;"> <strong>-&gt;</strong> </td><td style="text-align: center;"> <strong>coerced1</strong> </td><td style="text-align: center;"> <strong>op</strong> </td><td style="text-align: center;"> <strong>coerced2</strong> </td><td style="text-align: center;"> <strong>-&gt;</strong> </td><td style="text-align: center;"> <strong>result</strong> </td>
</tr>
<tr>
 <td style="text-align: center;">
   integer64 </td><td style="text-align: center;"> + </td><td style="text-align: center;"> double </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> + </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td>
</tr>
<tr>
 <td style="text-align: center;">
   double </td><td style="text-align: center;"> + </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> + </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td>
</tr>
<tr>
 <td style="text-align: center;">
   integer64 </td><td style="text-align: center;"> - </td><td style="text-align: center;"> double </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> - </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td>
</tr>
<tr>
 <td style="text-align: center;">
   double </td><td style="text-align: center;"> - </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> - </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td>
</tr>
<tr>
 <td style="text-align: center;">
   integer64 </td><td style="text-align: center;"> %/% </td><td style="text-align: center;"> double </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> %/% </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td>
</tr>
<tr>
 <td style="text-align: center;">
   double </td><td style="text-align: center;"> %/% </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> %/% </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td>
</tr>
<tr>
 <td style="text-align: center;">
   integer64 </td><td style="text-align: center;"> %% </td><td style="text-align: center;"> double </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> %% </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td>
</tr>
<tr>
 <td style="text-align: center;">
   double </td><td style="text-align: center;"> %% </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> %% </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td>
</tr>
<tr>
 <td style="text-align: center;">
   integer64 </td><td style="text-align: center;"> * </td><td style="text-align: center;"> double </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> * </td><td style="text-align: center;"> long double </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td>
</tr>
<tr>
 <td style="text-align: center;">
   double </td><td style="text-align: center;"> * </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> * </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td>
</tr>
<tr>
 <td style="text-align: center;">
   integer64 </td><td style="text-align: center;"> / </td><td style="text-align: center;"> double </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> / </td><td style="text-align: center;"> long double </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> double </td>
</tr>
<tr>
 <td style="text-align: center;">
   double </td><td style="text-align: center;"> / </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> / </td><td style="text-align: center;"> long double </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> double </td>
</tr>
<tr>
 <td style="text-align: center;">
   integer64 </td><td style="text-align: center;"> ^ </td><td style="text-align: center;"> double </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> / </td><td style="text-align: center;"> long double </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> double </td>
</tr>
<tr>
 <td style="text-align: center;">
   double </td><td style="text-align: center;"> ^ </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> / </td><td style="text-align: center;"> long double </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> double </td>
</tr>
<tr>
 <td style="text-align: center;">
</td>
</tr>

</table>



<h3>Creating and testing S3 class 'integer64'</h3>

<p>Our creator function <code>integer64</code> takes an argument <code>length</code>, creates an atomic
double vector of this length, attaches an S3 class attribute 'integer64' to it,
and that's it. We simply rely on S3 method dispatch and interpret those 64-bit
elements as 'long long int'.
</p>
<p><code><a href="#topic+is.double">is.double()</a></code> currently returns TRUE for <code>integer64</code> and might return <code>FALSE</code> in
a later release. Consider <code>is.double()</code> to have undefined behavior and do query
<code><a href="#topic+is.integer64">is.integer64()</a></code> <em>before</em> querying <code>is.double()</code>.
</p>
<p>The methods <code><a href="#topic+is.integer64">is.integer64()</a></code> and <code><a href="base.html#topic+is.vector">is.vector()</a></code> both return <code>TRUE</code> for <code>integer64</code>.
Note that we did not patch <code><a href="base.html#topic+storage.mode">storage.mode()</a></code> and <code><a href="base.html#topic+typeof">typeof()</a></code>, which both continue
returning 'double'. Like for 32 bit <code><a href="base.html#topic+integer">integer</a></code>, <code><a href="base.html#topic+mode">mode()</a></code> returns 'numeric' and
<code><a href="base.html#topic+as.double">as.double()</a></code> tries coercing to <code><a href="base.html#topic+double">double</a></code>. It is possible that 'integer64' becomes
a <code>vmode</code> in package ff.
</p>
<p>Further methods for creating <code>integer64</code> are <code><a href="#topic+range.integer64">range()</a></code> which
returns the range of the data type if calles without arguments,
<code><a href="#topic+rep.integer64">rep()</a></code>, <code><a href="#topic+seq.integer64">seq()</a></code>.
</p>
<p>For all available methods on <code>integer64</code> vectors see the index below and the examples.
</p>


<h3>Index of implemented methods</h3>


<table>
<tr>
 <td style="text-align: right;">
   <strong>creating, testing, printing</strong> </td><td style="text-align: right;"> <strong>see also</strong> </td><td style="text-align: left;"> <strong>description</strong> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>NA_integer64_</code> </td><td style="text-align: right;"> <code><a href="base.html#topic+NA_integer_">NA_integer_</a></code> </td><td style="text-align: left;"> NA constant </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>integer64</code> </td><td style="text-align: right;"> <code><a href="base.html#topic+integer">integer</a></code> </td><td style="text-align: left;"> create zero atomic vector </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+runif64">runif64()</a></code> </td><td style="text-align: right;"> <code><a href="stats.html#topic+runif">runif()</a></code> </td><td style="text-align: left;"> create random vector </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+rep.integer64">rep.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+rep">rep()</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+seq.integer64">seq.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+seq">seq()</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+is.integer64">is.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="methods.html#topic+is">is()</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
    </td><td style="text-align: right;"> <code><a href="base.html#topic+is.integer">is.integer()</a></code> </td><td style="text-align: left;"> inherited from Base R </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+is.vector.integer64">is.vector.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+is.vector">is.vector()</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+identical.integer64">identical.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+identical">identical()</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+length+3C-.integer64">length&lt;-.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+length+3C-">length&lt;-</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
    </td><td style="text-align: right;"> <code><a href="base.html#topic+length">length()</a></code> </td><td style="text-align: left;"> inherited from Base R </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="base.html#topic+names+3C-">names&lt;-</a></code> </td><td style="text-align: right;"> inherited from Base R </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
    </td><td style="text-align: right;"> <code><a href="base.html#topic+names">names()</a></code> </td><td style="text-align: left;"> inherited from Base R </td>
</tr>
<tr>
 <td style="text-align: right;">
    </td><td style="text-align: right;"> <code><a href="base.html#topic+dim+3C-">dim&lt;-</a></code> </td><td style="text-align: left;"> inherited from Base R </td>
</tr>
<tr>
 <td style="text-align: right;">
    </td><td style="text-align: right;"> <code><a href="base.html#topic+dim">dim()</a></code> </td><td style="text-align: left;"> inherited from Base R </td>
</tr>
<tr>
 <td style="text-align: right;">
    </td><td style="text-align: right;"> <code><a href="base.html#topic+dimnames+3C-">dimnames&lt;-</a></code> </td><td style="text-align: left;"> inherited from Base R </td>
</tr>
<tr>
 <td style="text-align: right;">
    </td><td style="text-align: right;"> <code><a href="base.html#topic+dimnames">dimnames()</a></code> </td><td style="text-align: left;"> inherited from Base R </td>
</tr>
<tr>
 <td style="text-align: right;">
    </td><td style="text-align: right;"> <code><a href="utils.html#topic+str">str()</a></code> </td><td style="text-align: left;"> inherited from Base R, does not print values correctly </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+print.integer64">print.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+print">print()</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+str.integer64">str.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="utils.html#topic+str">str()</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>


<table>
<tr>
 <td style="text-align: right;">
   <strong>coercing to integer64</strong> </td><td style="text-align: right;"> <strong>see also</strong> </td><td style="text-align: left;"> <strong>description</strong> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+as.integer64">as.integer64()</a></code> </td><td style="text-align: right;">  </td><td style="text-align: left;"> generic </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+as.integer64.bitstring">as.integer64.bitstring()</a></code> </td><td style="text-align: right;"> <code><a href="#topic+as.bitstring">as.bitstring()</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+as.integer64.character">as.integer64.character()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+character">character()</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+as.integer64.double">as.integer64.double()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+double">double()</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+as.integer64.integer">as.integer64.integer()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+integer">integer()</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+as.integer64.integer64">as.integer64.integer64()</a></code> </td><td style="text-align: right;"> <code>integer64</code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+as.integer64.logical">as.integer64.logical()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+logical">logical()</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+as.integer64.NULL">as.integer64.NULL()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+NULL">NULL()</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>


<table>
<tr>
 <td style="text-align: right;">
   <strong>coercing from integer64</strong> </td><td style="text-align: right;"> <strong>see also</strong> </td><td style="text-align: left;"> <strong>description</strong> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+as.list.integer64">as.list.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+as.list">as.list()</a></code> </td><td style="text-align: left;"> generic </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+as.bitstring">as.bitstring()</a></code> </td><td style="text-align: right;"> <code><a href="#topic+as.bitstring">as.bitstring()</a></code> </td><td style="text-align: left;"> generic </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+as.bitstring.integer64">as.bitstring.integer64()</a></code> </td><td style="text-align: right;">  </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+as.character.integer64">as.character.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+as.character">as.character()</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+as.double.integer64">as.double.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+as.double">as.double()</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+as.integer.integer64">as.integer.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+as.integer">as.integer()</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+as.logical.integer64">as.logical.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+as.logical">as.logical()</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>


<table>
<tr>
 <td style="text-align: right;">
   <strong>data structures</strong> </td><td style="text-align: right;"> <strong>see also</strong> </td><td style="text-align: left;"> <strong>description</strong> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+c.integer64">c.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+c">c()</a></code> </td><td style="text-align: left;"> vector concatenate </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+cbind.integer64">cbind.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+cbind">cbind()</a></code> </td><td style="text-align: left;"> column bind </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+rbind.integer64">rbind.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+rbind">rbind()</a></code> </td><td style="text-align: left;"> row bind </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+as.data.frame.integer64">as.data.frame.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+as.data.frame">as.data.frame()</a></code> </td><td style="text-align: left;"> coerce atomic object to data.frame </td>
</tr>
<tr>
 <td style="text-align: right;">
    </td><td style="text-align: right;"> <code><a href="base.html#topic+data.frame">data.frame()</a></code> </td><td style="text-align: left;"> inherited from Base R since we have coercion </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>


<table>
<tr>
 <td style="text-align: right;">
   <strong>subscripting</strong> </td><td style="text-align: right;"> <strong>see also</strong> </td><td style="text-align: left;"> <strong>description</strong> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+extract.replace.integer64">[.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+Extract">[</a></code> </td><td style="text-align: left;"> vector and array extract </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+extract.replace.integer64">[&lt;-.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+Extract">[&lt;-</a></code> </td><td style="text-align: left;"> vector and array assign </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+extract.replace.integer64">[[.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+Extract">[[</a></code> </td><td style="text-align: left;"> scalar extract </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+extract.replace.integer64">[[&lt;-.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+Extract">[[&lt;-</a></code> </td><td style="text-align: left;"> scalar assign </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>


<table>
<tr>
 <td style="text-align: right;">
   <strong>binary operators</strong> </td><td style="text-align: right;"> <strong>see also</strong> </td><td style="text-align: left;"> <strong>description</strong> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic++2B.integer64">+.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic++2B">+</a></code> </td><td style="text-align: left;"> returns integer64 </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+-.integer64">-.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+-">-</a></code> </td><td style="text-align: left;"> returns integer64 </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic++2A.integer64">*.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic++2A">*</a></code> </td><td style="text-align: left;"> returns integer64 </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic++5E.integer64">^.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic++5E">^</a></code> </td><td style="text-align: left;"> returns double </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic++2F.integer64">/.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic++2F">/</a></code> </td><td style="text-align: left;"> returns double </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic++25+2F+25.integer64">%/%.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic++25+2F+25">%/%</a></code> </td><td style="text-align: left;"> returns integer64 </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic++25+25.integer64">%%.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic++25+25">%%</a></code> </td><td style="text-align: left;"> returns integer64 </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>


<table>
<tr>
 <td style="text-align: right;">
   <strong>comparison operators</strong> </td><td style="text-align: right;"> <strong>see also</strong> </td><td style="text-align: left;"> <strong>description</strong> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic++3D+3D.integer64">==.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic++3D+3D">==</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic++21+3D.integer64">!=.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic++21+3D">!=</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic++3C.integer64">&lt;.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic++3C">&lt;</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic++3C+3D.integer64">&lt;=.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic++3C+3D">&lt;=</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic++3E.integer64">&gt;.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic++3E">&gt;</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic++3E+3D.integer64">&gt;=.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic++3E+3D">&gt;=</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>


<table>
<tr>
 <td style="text-align: right;">
<strong>logical operators</strong> </td><td style="text-align: right;"> <strong>see also</strong> </td><td style="text-align: left;"> <strong>description</strong> </td>
</tr>
<tr>
 <td style="text-align: right;">
<code><a href="#topic++21.integer64">!.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic++21">!</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
<code><a href="#topic++26.integer64">&amp;.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic++26">&amp;</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
<code><a href="#topic+xor.integer64">|.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+Logic">|</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
<code><a href="#topic+xor.integer64">xor.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+xor">xor()</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

<table>
<tr>
 <td style="text-align: right;">
   <strong>math functions</strong> </td><td style="text-align: right;"> <strong>see also</strong> </td><td style="text-align: left;"> <strong>description</strong> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+is.na.integer64">is.na.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+is.na">is.na()</a></code> </td><td style="text-align: left;"> returns logical </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+format.integer64">format.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+format">format()</a></code> </td><td style="text-align: left;"> returns character </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+abs.integer64">abs.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+abs">abs()</a></code> </td><td style="text-align: left;"> returns integer64 </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+sign.integer64">sign.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+sign">sign()</a></code> </td><td style="text-align: left;"> returns integer64 </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+log.integer64">log.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+log">log()</a></code> </td><td style="text-align: left;"> returns double </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+log10.integer64">log10.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+log10">log10()</a></code> </td><td style="text-align: left;"> returns double </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+log2.integer64">log2.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+log2">log2()</a></code> </td><td style="text-align: left;"> returns double </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+sqrt.integer64">sqrt.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+sqrt">sqrt()</a></code> </td><td style="text-align: left;"> returns double </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+ceiling.integer64">ceiling.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+ceiling">ceiling()</a></code> </td><td style="text-align: left;"> dummy returning its argument </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+floor.integer64">floor.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+floor">floor()</a></code> </td><td style="text-align: left;"> dummy returning its argument </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+trunc.integer64">trunc.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+trunc">trunc()</a></code> </td><td style="text-align: left;"> dummy returning its argument </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+round.integer64">round.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+round">round()</a></code> </td><td style="text-align: left;"> dummy returning its argument </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+signif.integer64">signif.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+signif">signif()</a></code> </td><td style="text-align: left;"> dummy returning its argument </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>


<table>
<tr>
 <td style="text-align: right;">
   <strong>cumulative functions</strong> </td><td style="text-align: right;"> <strong>see also</strong> </td><td style="text-align: left;"> <strong>description</strong> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+cummin.integer64">cummin.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+cummin">cummin()</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+cummax.integer64">cummax.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+cummax">cummax()</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+cumsum.integer64">cumsum.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+cumsum">cumsum()</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+cumprod.integer64">cumprod.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+cumprod">cumprod()</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+diff.integer64">diff.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+diff">diff()</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>


<table>
<tr>
 <td style="text-align: right;">
   <strong>summary functions</strong> </td><td style="text-align: right;"> <strong>see also</strong> </td><td style="text-align: left;"> <strong>description</strong> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+range.integer64">range.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+range">range()</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+min.integer64">min.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+min">min()</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+max.integer64">max.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+max">max()</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+sum.integer64">sum.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+sum">sum()</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+mean.integer64">mean.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+mean">mean()</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+prod.integer64">prod.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+prod">prod()</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+all.integer64">all.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+all">all()</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+any.integer64">any.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+any">any()</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>


<table>
<tr>
 <td style="text-align: right;">
   <strong>algorithmically complex functions</strong> </td><td style="text-align: right;"> <strong>see also</strong> </td><td style="text-align: left;"> <strong>description (caching)</strong> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+match.integer64">match.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="#topic+match">match()</a></code> </td><td style="text-align: left;"> position of x in table (h//o/so) </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic++25in+25.integer64">%in%.integer64</a></code> </td><td style="text-align: right;"> <code><a href="#topic++25in+25">%in%</a></code> </td><td style="text-align: left;"> is x in table? (h//o/so) </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+duplicated.integer64">duplicated.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+duplicated">duplicated()</a></code> </td><td style="text-align: left;"> is current element duplicate of previous one? (h//o/so) </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+unique.integer64">unique.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+unique">unique()</a></code> </td><td style="text-align: left;"> (shorter) vector of unique values only (h/s/o/so) </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+unipos.integer64">unipos.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="#topic+unipos">unipos()</a></code> </td><td style="text-align: left;"> positions corresponding to unique values (h/s/o/so) </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+tiepos.integer64">tiepos.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="#topic+tiepos">tiepos()</a></code> </td><td style="text-align: left;"> positions of values that are tied (//o/so) </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+keypos.integer64">keypos.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="#topic+keypos">keypos()</a></code> </td><td style="text-align: left;"> position of current value in sorted list of unique values (//o/so) </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+table.integer64">table.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+table">table()</a></code> </td><td style="text-align: left;"> unique values and their frequencies (h/s/o/so) </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+sort.integer64">sort.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+sort">sort()</a></code> </td><td style="text-align: left;"> sorted vector (/s/o/so) </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+order.integer64">order.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="#topic+order">order()</a></code> </td><td style="text-align: left;"> positions of elements that would create sorted vector (//o/so) </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+rank.integer64">rank.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="#topic+rank">rank()</a></code> </td><td style="text-align: left;"> (average) ranks of non-NAs, NAs kept in place (/s/o/so) </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+quantile.integer64">quantile.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="stats.html#topic+quantile">quantile()</a></code> </td><td style="text-align: left;"> (existing) values at specified percentiles (/s/o/so) </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+median.integer64">median.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="stats.html#topic+median">median()</a></code> </td><td style="text-align: left;"> (existing) value at percentile 0.5 (/s/o/so) </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+summary.integer64">summary.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+summary">summary()</a></code> </td><td style="text-align: left;"> (/s/o/so) </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+all.equal.integer64">all.equal.integer64()</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+all.equal">all.equal()</a></code> </td><td style="text-align: left;"> test if two objects are (nearly) equal (/s/o/so) </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>


<table>
<tr>
 <td style="text-align: right;">
   <strong>helper functions</strong> </td><td style="text-align: right;"> <strong>see also</strong> </td><td style="text-align: left;"> <strong>description</strong> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+minusclass">minusclass()</a></code> </td><td style="text-align: right;"> <code><a href="#topic+minusclass">minusclass()</a></code> </td><td style="text-align: left;"> removing class attritbute </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+plusclass">plusclass()</a></code> </td><td style="text-align: right;"> <code><a href="#topic+plusclass">plusclass()</a></code> </td><td style="text-align: left;"> inserting class attribute </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+binattr">binattr()</a></code> </td><td style="text-align: right;"> <code><a href="#topic+binattr">binattr()</a></code> </td><td style="text-align: left;"> define binary op behaviour </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>


<table>
<tr>
 <td style="text-align: right;">
   <strong>tested I/O functions</strong> </td><td style="text-align: right;"> <strong>see also</strong> </td><td style="text-align: left;"> <strong>description</strong> </td>
</tr>
<tr>
 <td style="text-align: right;">
    </td><td style="text-align: right;"> <code><a href="utils.html#topic+read.table">read.table()</a></code> </td><td style="text-align: left;"> inherited from Base R </td>
</tr>
<tr>
 <td style="text-align: right;">
    </td><td style="text-align: right;"> <code><a href="utils.html#topic+write.table">write.table()</a></code> </td><td style="text-align: left;"> inherited from Base R </td>
</tr>
<tr>
 <td style="text-align: right;">
    </td><td style="text-align: right;"> <code><a href="base.html#topic+serialize">serialize()</a></code> </td><td style="text-align: left;"> inherited from Base R </td>
</tr>
<tr>
 <td style="text-align: right;">
    </td><td style="text-align: right;"> <code><a href="base.html#topic+unserialize">unserialize()</a></code> </td><td style="text-align: left;"> inherited from Base R </td>
</tr>
<tr>
 <td style="text-align: right;">
    </td><td style="text-align: right;"> <code><a href="base.html#topic+save">save()</a></code> </td><td style="text-align: left;"> inherited from Base R </td>
</tr>
<tr>
 <td style="text-align: right;">
    </td><td style="text-align: right;"> <code><a href="base.html#topic+load">load()</a></code> </td><td style="text-align: left;"> inherited from Base R </td>
</tr>
<tr>
 <td style="text-align: right;">
    </td><td style="text-align: right;"> <code><a href="base.html#topic+dput">dput()</a></code> </td><td style="text-align: left;"> inherited from Base R </td>
</tr>
<tr>
 <td style="text-align: right;">
    </td><td style="text-align: right;"> <code><a href="base.html#topic+dget">dget()</a></code> </td><td style="text-align: left;"> inherited from Base R </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>



<h3>Limitations inherited from implementing 64 bit integers via an external package</h3>


<ul>
<li> <p><strong>vector size</strong> of atomic vectors is still limited to
<code><a href="base.html#topic+.Machine">.Machine$integer.max</a></code>. However, external memory extending packages
such as ff or bigmemory can extend their address space now with <code>integer64</code>.
Having 64 bit integers also help with those not so obvious address issues that
arise once we exchange data with SQL databases and datawarehouses, which use big
integers as surrogate keys, e.g. on indexed primary key columns. This puts R into
a relatively strong position compared to certain commercial statistical softwares,
which sell database connectivity but neither have the range of 64 bit integers,
nor have integers at all, nor have a single numeric data type in their
macro-glue-language.
</p>
</li>
<li> <p><strong>literals</strong> such as <code style="white-space: pre;">&#8288;123LL&#8288;</code> would require changes to Base R, up to then we need
to write (and call) <code>as.integer64(123L)</code> or <code>as.integer64(123)</code> or
<code>as.integer64('123')</code>. Only the latter allows to specify numbers beyond Base R's
numeric data types and therefore is the recommended way to use &ndash; using only one
way may facilitate migrating code to literals at a later stage.
</p>
</li></ul>



<h3>Limitations inherited from Base R, Core team, can you change this?</h3>


<ul>
<li> <p><strong><code><a href="base.html#topic+identical">identical()</a></code></strong> with default parameters does not distinguish all bit-patterns of
doubles. For testing purposes we provide a wrapper <code><a href="#topic+identical.integer64">identical.integer64()</a></code> that
will distinguish all bit-patterns. It would be desireable to have a single call
of <code>identical()</code> handle both, <code><a href="base.html#topic+double">double</a></code> and <code>integer64</code>.
</p>
</li>
<li><p> the <strong>colon</strong> operator <a href="#topic++3A">:</a> officially does not dispatch S3 methods, however, we
have made it generic:
</p>
<div class="sourceCode r"><pre>from &lt;- lim.integer64()[1]
to &lt;- from+99
from:to
</pre></div>
<p>As a limitation remains: it will only dispatch at its first argument <code>from</code> but
not at its second <code>to</code>.
</p>
</li>
<li> <p><strong><code><a href="#topic+is.double">is.double()</a></code></strong> does not dispatch S3 methods, However, we have made it generic
and it will return <code>FALSE</code> on <code>integer64</code>.
</p>
</li>
<li> <p><strong><code><a href="base.html#topic+c">c()</a></code></strong> only dispatches <code><a href="#topic+c.integer64">c.integer64()</a></code> if the first argument is <code>integer64</code>
and it does not recursively dispatch the proper method when called with argument
<code>recursive=TRUE</code>. Therefore <code>c(list(integer64, integer64))</code> does not work and
for now you can only call <code>c.integer64(list(x, x))</code>.
</p>
</li>
<li> <p><strong>generic binary operators</strong> fail to dispatch <em>any</em> user-defined S3 method
if the two arguments have two different S3 classes. For example we have two
classes <code><a href="bit.html#topic+bit">bit::bit</a></code> and <code><a href="bit.html#topic+bitwhich">bit::bitwhich</a></code> sparsely representing boolean vectors
and we have methods <code><a href="bit.html#topic+xor">&amp;.bit</a></code> and
<code><a href="bit.html#topic+xor">&amp;.bitwhich</a></code>. For an expression involving both as in
<code>bit &amp; bitwhich</code>, none of the two methods is dispatched. Instead a standard
method is dispatched, which neither handles <code>bit</code> nor <code>bitwhich</code>. Although
it lacks symmetry, the better choice would be to dispatch simply the method
of the class of the first argument in case of class conflict. This choice would
allow authors of extension packages providing coherent behaviour at least within
their contributed classes. But as long as none of the package author's methods is
dispatched, they cannot handle the conflicting classes at all.
</p>
</li>
<li> <p><strong><code><a href="base.html#topic+unlist">unlist()</a></code></strong> is not generic and if it were, we would face similar problems as
with <code><a href="base.html#topic+c">c()</a></code>
</p>
</li>
<li> <p><strong><code><a href="base.html#topic+vector">vector()</a></code></strong> with argument <code>mode='integer64'</code> cannot work without adjustment
of Base R
</p>
</li>
<li> <p><strong><code><a href="base.html#topic+as.vector">as.vector()</a></code></strong> with argument <code>mode='integer64'</code> cannot work without adjustment
of Base R
</p>
</li>
<li> <p><strong><code><a href="base.html#topic+is.vector">is.vector()</a></code></strong> does not dispatch its method <code><a href="#topic+is.vector.integer64">is.vector.integer64()</a></code>
</p>
</li>
<li> <p><strong><code><a href="base.html#topic+mode+3C-">mode&lt;-()</a></code></strong> drops the class 'integer64' which is returned from
<code>as.integer64()</code>. Also it does not remove an existing class 'integer64' when
assigning mode 'integer'.
</p>
</li>
<li> <p><strong><code><a href="base.html#topic+storage.mode+3C-">storage.mode&lt;-()</a></code></strong> does not support external data types such as <code>integer64</code>
</p>
</li>
<li> <p><strong><code><a href="base.html#topic+matrix">matrix()</a></code></strong> does drop the 'integer64' class attribute.
</p>
</li>
<li> <p><strong><code><a href="base.html#topic+array">array()</a></code></strong>  does drop the 'integer64' class attribute.
</p>

<ul>
<li><p> In current R versions (1.15.1) this can be circumvented by activating the
function <code>as.vector.integer64()</code>. However, the CRAN maintainer has requested
to remove <code>as.vector.integer64()</code>, even at the price of breaking previously
working functionality of the package.
</p>
</li></ul>

</li>
<li> <p><strong><code><a href="utils.html#topic+str">str()</a></code></strong> does not print the values of <code>integer64</code> correctly
</p>
</li></ul>



<h3>Further limitations</h3>


<ul>
<li> <p><strong>subscripting</strong> non-existing elements and subscripting with <code>NA</code>s is currently
not supported. Such subscripting currently returns <code>9218868437227407266</code> instead
of <code>NA</code> (the <code>NA</code> value of the underlying double code). Following the full R
behaviour here would either destroy performance or require extensive C-coding.
</p>
</li></ul>



<h3>Note</h3>

<p><code>integer64</code> are useful for handling database keys and exact counting in +-2^63.
Do not use them as replacement for 32bit integers, integer64 are not supported for
subscripting by R-core and they have different semantics when combined with double.
Do understand that <code>integer64</code> can only be useful over <code>double</code> if we do not coerce
it to <code>double</code>.
</p>
<p>While
</p>
<p>integer + double -&gt; double + double -&gt; double
</p>
<p>or
</p>
<p>1L + 0.5 -&gt; 1.5
</p>
<p>for additive operations we coerce to <code>integer64</code>
</p>
<p>integer64 + double -&gt;  integer64 + integer64 -&gt; integer64
</p>
<p>hence
</p>
<p>as.integer64(1) + 0.5 -&gt; 1LL + 0LL -&gt; 1LL
</p>
<p>see section &quot;Arithmetic precision and coercion&quot; above
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Michael Chirico <a href="mailto:michaelchirico4@gmail.com">michaelchirico4@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Jens Oehlschl√§gel
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Leonardo Silvestri [contributor]
</p>
</li>
<li><p> Ofek Shilon [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="base.html#topic+integer">integer()</a></code> in base R
</p>


<h3>Examples</h3>

<pre><code class='language-R'>message("Using integer64 in vector")
x &lt;- integer64(8)    # create 64 bit vector
x
is.atomic(x)         # TRUE
is.integer64(x)      # TRUE
is.numeric(x)        # TRUE
is.integer(x)        # FALSE - debatable
is.double(x)         # FALSE - might change
x[] &lt;- 1:2           # assigned value is recycled as usual
x[1:6]               # subscripting as usual
length(x) &lt;- 13      # changing length as usual
x
rep(x, 2)            # replicate as usual
seq(as.integer64(1), 10)     # seq.integer64 is dispatched on first given argument
seq(to=as.integer64(10), 1)  # seq.integer64 is dispatched on first given argument
seq.integer64(along.with=x)  # or call seq.integer64 directly
# c.integer64 is dispatched only if *first* argument is integer64 ...
x &lt;- c(x,runif(length(x), max=100))
# ... and coerces everything to integer64 - including double
x
names(x) &lt;- letters  # use names as usual
x

message("Using integer64 in array - note that 'matrix' currently does not work")
message("as.vector.integer64 removed as requested by the CRAN maintainer")
message("as consequence 'array' also does not work anymore")
message("we still can create a matrix or array by assigning 'dim'")
y &lt;- rep(as.integer64(NA), 12)
dim(y) &lt;- c(3,4)
dimnames(y) &lt;- list(letters[1:3], LETTERS[1:4])
y["a",] &lt;- 1:2       # assigning as usual
y
y[1:2,-4]            # subscripting as usual
# cbind.integer64 dispatched on any argument and coerces everything to integer64
cbind(E=1:3, F=runif(3, 0, 100), G=c("-1","0","1"), y)

message("Using integer64 in data.frame")
str(as.data.frame(x))
str(as.data.frame(y))
str(data.frame(y))
str(data.frame(I(y)))
d &lt;- data.frame(x=x, y=runif(length(x), 0, 100))
d
d$x

message("Using integer64 with csv files")
fi64 &lt;- tempfile()
write.csv(d, file=fi64, row.names=FALSE)
e &lt;- read.csv(fi64, colClasses=c("integer64", NA))
unlink(fi64)
str(e)
identical.integer64(d$x,e$x)

message("Serializing and unserializing integer64")
dput(d, fi64)
e &lt;- dget(fi64)
identical.integer64(d$x,e$x)
e &lt;- d[,]
save(e, file=fi64)
rm(e)
load(file=fi64)
identical.integer64(d,e)

  ## Not run: 
message("== Differences between integer64 and int64 ==")
require(bit64)
require(int64)

message("-- integer64 is atomic --")
is.atomic(integer64())
#is.atomic(int64())
str(integer64(3))
#str(int64(3))

message("-- The following performance numbers are measured under RWin64  --")
message("-- under RWin32 the advantage of integer64 over int64 is smaller --")

message("-- integer64 needs 7x/5x less RAM than int64 under 64/32 bit OS
(and twice the RAM of integer as it should be) --")
#as.vector(object.size(int64(1e6))/object.size(integer64(1e6)))
as.vector(object.size(integer64(1e6))/object.size(integer(1e6)))

message("-- integer64 creates 2000x/1300x faster than int64 under 64/32 bit OS
(and 3x the time of integer) --")
t32 &lt;- system.time(integer(1e8))
t64 &lt;- system.time(integer64(1e8))
#T64 &lt;- system.time(int64(1e7))*10  # using 1e8 as above stalls our R on an i7 8 GB RAM Thinkpad
#T64/t64
t64/t32

i32 &lt;- sample(1e6)
d64 &lt;- as.double(i32)

message("-- the following timings are rather conservative since timings
 of integer64 include garbage collection -- due to looped calls")
message("-- integer64 coerces 900x/100x faster than int64
 under 64/32 bit OS (and 2x the time of coercing to integer) --")
t32 &lt;- system.time(for(i in 1:1000)as.integer(d64))
t64 &lt;- system.time(for(i in 1:1000)as.integer64(d64))
#T64 &lt;- system.time(as.int64(d64))*1000
#T64/t64
t64/t32
td64 &lt;- system.time(for(i in 1:1000)as.double(i32))
t64 &lt;- system.time(for(i in 1:1000)as.integer64(i32))
#T64 &lt;- system.time(for(i in 1:10)as.int64(i32))*100
#T64/t64
t64/td64

message("-- integer64 serializes 4x/0.8x faster than int64
 under 64/32 bit OS (and less than 2x/6x the time of integer or double) --")
t32 &lt;- system.time(for(i in 1:10)serialize(i32, NULL))
td64 &lt;- system.time(for(i in 1:10)serialize(d64, NULL))
i64 &lt;- as.integer64(i32);
t64 &lt;- system.time(for(i in 1:10)serialize(i64, NULL))
rm(i64); gc()
#I64 &lt;- as.int64(i32);
#T64 &lt;- system.time(for(i in 1:10)serialize(I64, NULL))
#rm(I64); gc()
#T64/t64
t64/t32
t64/td64


message("-- integer64 adds 250x/60x faster than int64
 under 64/32 bit OS (and less than 6x the time of integer or double) --")
td64 &lt;- system.time(for(i in 1:100)d64+d64)
t32 &lt;- system.time(for(i in 1:100)i32+i32)
i64 &lt;- as.integer64(i32);
t64 &lt;- system.time(for(i in 1:100)i64+i64)
rm(i64); gc()
#I64 &lt;- as.int64(i32);
#T64 &lt;- system.time(for(i in 1:10)I64+I64)*10
#rm(I64); gc()
#T64/t64
t64/t32
t64/td64

message("-- integer64 sums 3x/0.2x faster than int64
(and at about 5x/60X the time of integer and double) --")
td64 &lt;- system.time(for(i in 1:100)sum(d64))
t32 &lt;- system.time(for(i in 1:100)sum(i32))
i64 &lt;- as.integer64(i32);
t64 &lt;- system.time(for(i in 1:100)sum(i64))
rm(i64); gc()
#I64 &lt;- as.int64(i32);
#T64 &lt;- system.time(for(i in 1:100)sum(I64))
#rm(I64); gc()
#T64/t64
t64/t32
t64/td64

message("-- integer64 diffs 5x/0.85x faster than integer and double
(int64 version 1.0 does not support diff) --")
td64 &lt;- system.time(for(i in 1:10)diff(d64, lag=2L, differences=2L))
t32 &lt;- system.time(for(i in 1:10)diff(i32, lag=2L, differences=2L))
i64 &lt;- as.integer64(i32);
t64 &lt;- system.time(for(i in 1:10)diff(i64, lag=2L, differences=2L))
rm(i64); gc()
t64/t32
t64/td64


message("-- integer64 subscripts 1000x/340x faster than int64
(and at the same speed / 10x slower as integer) --")
ts32 &lt;- system.time(for(i in 1:1000)sample(1e6, 1e3))
t32&lt;- system.time(for(i in 1:1000)i32[sample(1e6, 1e3)])
i64 &lt;- as.integer64(i32);
t64 &lt;- system.time(for(i in 1:1000)i64[sample(1e6, 1e3)])
rm(i64); gc()
#I64 &lt;- as.int64(i32);
#T64 &lt;- system.time(for(i in 1:100)I64[sample(1e6, 1e3)])*10
#rm(I64); gc()
#(T64-ts32)/(t64-ts32)
(t64-ts32)/(t32-ts32)

message("-- integer64 assigns 200x/90x faster than int64
(and 50x/160x slower than integer) --")
ts32 &lt;- system.time(for(i in 1:100)sample(1e6, 1e3))
t32 &lt;- system.time(for(i in 1:100)i32[sample(1e6, 1e3)] &lt;- 1:1e3)
i64 &lt;- as.integer64(i32);
i64 &lt;- system.time(for(i in 1:100)i64[sample(1e6, 1e3)] &lt;- 1:1e3)
rm(i64); gc()
#I64 &lt;- as.int64(i32);
#I64 &lt;- system.time(for(i in 1:10)I64[sample(1e6, 1e3)] &lt;- 1:1e3)*10
#rm(I64); gc()
#(T64-ts32)/(t64-ts32)
(t64-ts32)/(t32-ts32)


tdfi32 &lt;- system.time(dfi32 &lt;- data.frame(a=i32, b=i32, c=i32))
tdfsi32 &lt;- system.time(dfi32[1e6:1,])
fi32 &lt;- tempfile()
tdfwi32 &lt;- system.time(write.csv(dfi32, file=fi32, row.names=FALSE))
tdfri32 &lt;- system.time(read.csv(fi32, colClasses=rep("integer", 3)))
unlink(fi32)
rm(dfi32); gc()

i64 &lt;- as.integer64(i32);
tdfi64 &lt;- system.time(dfi64 &lt;- data.frame(a=i64, b=i64, c=i64))
tdfsi64 &lt;- system.time(dfi64[1e6:1,])
fi64 &lt;- tempfile()
tdfwi64 &lt;- system.time(write.csv(dfi64, file=fi64, row.names=FALSE))
tdfri64 &lt;- system.time(read.csv(fi64, colClasses=rep("integer64", 3)))
unlink(fi64)
rm(i64, dfi64); gc()

#I64 &lt;- as.int64(i32);
#tdfI64 &lt;- system.time(dfI64&lt;-data.frame(a=I64, b=I64, c=I64))
#tdfsI64 &lt;- system.time(dfI64[1e6:1,])
#fI64 &lt;- tempfile()
#tdfwI64 &lt;- system.time(write.csv(dfI64, file=fI64, row.names=FALSE))
#tdfrI64 &lt;- system.time(read.csv(fI64, colClasses=rep("int64", 3)))
#unlink(fI64)
#rm(I64, dfI64); gc()

message("-- integer64 coerces 40x/6x faster to data.frame than int64
(and factor 1/9 slower than integer) --")
#tdfI64/tdfi64
tdfi64/tdfi32
message("-- integer64 subscripts from data.frame 20x/2.5x faster than int64
 (and 3x/13x slower than integer) --")
#tdfsI64/tdfsi64
tdfsi64/tdfsi32
message("-- integer64 csv writes about 2x/0.5x faster than int64
(and about 1.5x/5x slower than integer) --")
#tdfwI64/tdfwi64
tdfwi64/tdfwi32
message("-- integer64 csv reads about 3x/1.5 faster than int64
(and about 2x slower than integer) --")
#tdfrI64/tdfri64
tdfri64/tdfri32

rm(i32, d64); gc()


message("-- investigating the impact on garbage collection: --")
message("-- the fragmented structure of int64 messes up R's RAM --")
message("-- and slows down R's gargbage collection just by existing --")

td32 &lt;- double(21)
td32[1] &lt;- system.time(d64 &lt;- double(1e7))[3]
for (i in 2:11)td32[i] &lt;- system.time(gc(), gcFirst=FALSE)[3]
rm(d64)
for (i in 12:21)td32[i] &lt;- system.time(gc(), gcFirst=FALSE)[3]

t64 &lt;- double(21)
t64[1] &lt;- system.time(i64 &lt;- integer64(1e7))[3]
for (i in 2:11)t64[i] &lt;- system.time(gc(), gcFirst=FALSE)[3]
rm(i64)
for (i in 12:21)t64[i] &lt;- system.time(gc(), gcFirst=FALSE)[3]

#T64 &lt;- double(21)
#T64[1] &lt;- system.time(I64 &lt;- int64(1e7))[3]
#for (i in 2:11)T64[i] &lt;- system.time(gc(), gcFirst=FALSE)[3]
#rm(I64)
#for (i in 12:21)T64[i] &lt;- system.time(gc(), gcFirst=FALSE)[3]

#matplot(1:21, cbind(td32, t64, T64), pch=c("d","i","I"), log="y")
matplot(1:21, cbind(td32, t64), pch=c("d","i"), log="y")
  
## End(Not run)
</code></pre>

<hr>
<h2 id='all.equal.integer64'>Test if two integer64 vectors are all.equal</h2><span id='topic+all.equal.integer64'></span>

<h3>Description</h3>

<p>A utility to compare integer64 objects 'x' and 'y' testing for
‚Äònear equality‚Äô, see <code><a href="base.html#topic+all.equal">all.equal()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'integer64'
all.equal(
  target,
  current,
  tolerance = sqrt(.Machine$double.eps),
  scale = NULL,
  countEQ = FALSE,
  formatFUN = function(err, what) format(err),
  ...,
  check.attributes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="all.equal.integer64_+3A_target">target</code></td>
<td>
<p>a vector of 'integer64' or an object that can be coerced
with <code><a href="#topic+as.integer64">as.integer64()</a></code></p>
</td></tr>
<tr><td><code id="all.equal.integer64_+3A_current">current</code></td>
<td>
<p>a vector of 'integer64' or an object that can be coerced
with <code><a href="#topic+as.integer64">as.integer64()</a></code></p>
</td></tr>
<tr><td><code id="all.equal.integer64_+3A_tolerance">tolerance</code></td>
<td>
<p>numeric &gt; 0.  Differences smaller than <code>tolerance</code> are
not reported.  The default value is close to <code>1.5e-8</code>.</p>
</td></tr>
<tr><td><code id="all.equal.integer64_+3A_scale">scale</code></td>
<td>
<p><code>NULL</code> or numeric &gt; 0, typically of length 1 or
<code>length(target)</code>. See Details.</p>
</td></tr>
<tr><td><code id="all.equal.integer64_+3A_counteq">countEQ</code></td>
<td>
<p>logical indicating if the <code>target == current</code> cases should
be counted when computing the mean (absolute or relative) differences.
The default, <code>FALSE</code> may seem misleading in cases where <code>target</code> and
<code>current</code> only differ in a few places; see the extensive example.</p>
</td></tr>
<tr><td><code id="all.equal.integer64_+3A_formatfun">formatFUN</code></td>
<td>
<p>a <code><a href="base.html#topic+function">function()</a></code> of two arguments, <code>err</code>, the relative,
absolute or scaled error, and <code>what</code>, a character string indicating the
<em>kind</em> of error; maybe used, e.g., to format relative and absolute errors
differently.</p>
</td></tr>
<tr><td><code id="all.equal.integer64_+3A_...">...</code></td>
<td>
<p>further arguments are ignored</p>
</td></tr>
<tr><td><code id="all.equal.integer64_+3A_check.attributes">check.attributes</code></td>
<td>
<p>logical indicating if the <code><a href="base.html#topic+attributes">attributes()</a></code> of <code>target</code>
and <code>current</code> (other than the names) should be compared.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In <code><a href="base.html#topic+all.equal.numeric">all.equal.numeric()</a></code> the type <code>integer</code> is treated as a proper subset
of <code>double</code> i.e. does not complain about comparing <code>integer</code> with <code>double</code>.
Following this logic <code>all.equal.integer64</code> treats <code>integer</code> as a proper
subset of <code>integer64</code> and does not complain about comparing <code>integer</code> with
<code>integer64</code>. <code>double</code> also compares without warning as long as the values
are within <code><a href="#topic+lim.integer64">lim.integer64()</a></code>, if <code>double</code> are bigger <code>all.equal.integer64</code>
complains about the <code style="white-space: pre;">&#8288;all.equal.integer64 overflow warning&#8288;</code>. For further
details see <code><a href="base.html#topic+all.equal">all.equal()</a></code>.
</p>


<h3>Value</h3>

<p>Either ‚ÄòTRUE‚Äô (‚ÄòNULL‚Äô for ‚Äòattr.all.equal‚Äô) or a vector of ‚Äòmode‚Äô
‚Äò&quot;character&quot;‚Äô describing the differences between ‚Äòtarget‚Äô and
‚Äòcurrent‚Äô.
</p>


<h3>Note</h3>

<p><code><a href="base.html#topic+all.equal">all.equal()</a></code> only dispatches to this method if the first argument is <code>integer64</code>,
calling <code><a href="base.html#topic+all.equal">all.equal()</a></code> with a <code>non-integer64</code> first and a <code>integer64</code> second argument
gives undefined behavior!
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+all.equal">all.equal()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  all.equal(as.integer64(1:10), as.integer64(0:9))
  all.equal(as.integer64(1:10), as.integer(1:10))
  all.equal(as.integer64(1:10), as.double(1:10))
  all.equal(as.integer64(1), as.double(1e300))
</code></pre>

<hr>
<h2 id='as.character.integer64'>Coerce from integer64</h2><span id='topic+as.character.integer64'></span><span id='topic+as.bitstring'></span><span id='topic+as.double.integer64'></span><span id='topic+as.integer.integer64'></span><span id='topic+as.logical.integer64'></span><span id='topic+as.bitstring.integer64'></span><span id='topic+print.bitstring'></span><span id='topic+as.list.integer64'></span>

<h3>Description</h3>

<p>Methods to coerce integer64 to other atomic types. 'as.bitstring' coerces
to a human-readable bit representation (strings of zeroes and ones).
The methods <code><a href="base.html#topic+format">format()</a></code>, <code><a href="base.html#topic+as.character">as.character()</a></code>, <code><a href="base.html#topic+as.double">as.double()</a></code>,
<code><a href="base.html#topic+as.logical">as.logical()</a></code>, <code><a href="base.html#topic+as.integer">as.integer()</a></code> do what you would expect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.bitstring(x, ...)

## S3 method for class 'integer64'
as.double(x, keep.names = FALSE, ...)

## S3 method for class 'integer64'
as.integer(x, ...)

## S3 method for class 'integer64'
as.logical(x, ...)

## S3 method for class 'integer64'
as.character(x, ...)

## S3 method for class 'integer64'
as.bitstring(x, ...)

## S3 method for class 'bitstring'
print(x, ...)

## S3 method for class 'integer64'
as.list(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.character.integer64_+3A_x">x</code></td>
<td>
<p>an integer64 vector</p>
</td></tr>
<tr><td><code id="as.character.integer64_+3A_...">...</code></td>
<td>
<p>further arguments to the <code><a href="base.html#topic+NextMethod">NextMethod()</a></code></p>
</td></tr>
<tr><td><code id="as.character.integer64_+3A_keep.names">keep.names</code></td>
<td>
<p>FALSE, set to TRUE to keep a names vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>as.bitstring</code> returns a string of class 'bitstring'.
</p>
<p>The other methods return atomic vectors of the expected types
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.integer64.character">as.integer64.character()</a></code> <code><a href="#topic+integer64">integer64()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  as.character(lim.integer64())
  as.bitstring(lim.integer64())
  as.bitstring(as.integer64(c(
   -2,-1,NA,0:2
  )))
</code></pre>

<hr>
<h2 id='as.data.frame.integer64'>integer64: Coercing to data.frame column</h2><span id='topic+as.data.frame.integer64'></span>

<h3>Description</h3>

<p>Coercing integer64 vector to data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'integer64'
as.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.data.frame.integer64_+3A_x">x</code></td>
<td>
<p>an integer64 vector</p>
</td></tr>
<tr><td><code id="as.data.frame.integer64_+3A_...">...</code></td>
<td>
<p>passed to NextMethod <code><a href="base.html#topic+as.data.frame">as.data.frame()</a></code> after removing the
'integer64' class attribute</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'as.data.frame.integer64' is rather not intended to be called directly,
but it is required to allow integer64 as data.frame columns.
</p>


<h3>Value</h3>

<p>a one-column data.frame containing an integer64 vector
</p>


<h3>Note</h3>

<p>This is currently very slow &ndash; any ideas for improvement?
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cbind.integer64">cbind.integer64()</a></code> <code><a href="#topic+integer64">integer64()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  as.data.frame.integer64(as.integer64(1:12))
  data.frame(a=1:12, b=as.integer64(1:12))
</code></pre>

<hr>
<h2 id='as.integer64.character'>Coerce to integer64</h2><span id='topic+as.integer64.character'></span><span id='topic+as.integer64'></span><span id='topic+as.integer64.NULL'></span><span id='topic+as.integer64.integer64'></span><span id='topic+as.integer64.double'></span><span id='topic+as.integer64.integer'></span><span id='topic+as.integer64.logical'></span><span id='topic+as.integer64.factor'></span><span id='topic+as.integer64.bitstring'></span><span id='topic+NA_integer64_'></span>

<h3>Description</h3>

<p>Methods to coerce from other atomic types to integer64.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.integer64(x, ...)

## S3 method for class ''NULL''
as.integer64(x, ...)

## S3 method for class 'integer64'
as.integer64(x, ...)

## S3 method for class 'double'
as.integer64(x, keep.names = FALSE, ...)

## S3 method for class 'integer'
as.integer64(x, ...)

## S3 method for class 'logical'
as.integer64(x, ...)

## S3 method for class 'character'
as.integer64(x, ...)

## S3 method for class 'factor'
as.integer64(x, ...)

## S3 method for class 'bitstring'
as.integer64(x, ...)

NA_integer64_
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.integer64.character_+3A_x">x</code></td>
<td>
<p>an atomic vector</p>
</td></tr>
<tr><td><code id="as.integer64.character_+3A_...">...</code></td>
<td>
<p>further arguments to the <code><a href="base.html#topic+NextMethod">NextMethod()</a></code></p>
</td></tr>
<tr><td><code id="as.integer64.character_+3A_keep.names">keep.names</code></td>
<td>
<p>FALSE, set to TRUE to keep a names vector</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>integer64</code> of length 1.
</p>


<h3>Details</h3>

<p><code>as.integer64.character</code> is realized using C function <code>strtoll</code> which
does not support scientific notation. Instead of '1e6' use '1000000'.
<code>as.integer64.bitstring</code> evaluates characters '0' and ' ' as zero-bit,
all other one byte characters as one-bit, multi-byte characters are not allowed,
strings shorter than 64 characters are treated as if they were left-padded with '0',
strings longer than 64 bytes are mapped to <code>NA_INTEGER64</code> and a warning is emitted.
</p>


<h3>Value</h3>

<p>The other methods return atomic vectors of the expected types
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.character.integer64">as.character.integer64()</a></code> <code><a href="#topic+integer64">integer64()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as.integer64(as.character(lim.integer64()))
as.integer64(
  structure(c("1111111111111111111111111111111111111111111111111111111111111110",
              "1111111111111111111111111111111111111111111111111111111111111111",
              "1000000000000000000000000000000000000000000000000000000000000000",
              "0000000000000000000000000000000000000000000000000000000000000000",
              "0000000000000000000000000000000000000000000000000000000000000001",
              "0000000000000000000000000000000000000000000000000000000000000010"
  ), class = "bitstring")
)
as.integer64(
 structure(c("............................................................... ",
             "................................................................",
             ".                                                               ",
             "",
             ".",
             "10"
  ), class = "bitstring")
)
</code></pre>

<hr>
<h2 id='benchmark64'>Function for measuring algorithmic performance of high-level and low-level integer64 functions</h2><span id='topic+benchmark64'></span><span id='topic+optimizer64'></span>

<h3>Description</h3>

<p>Function for measuring algorithmic performance of high-level and low-level integer64 functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>benchmark64(nsmall = 2L^16L, nbig = 2L^25L, timefun = repeat.time)

optimizer64(
  nsmall = 2L^16L,
  nbig = 2L^25L,
  timefun = repeat.time,
  what = c("match", "%in%", "duplicated", "unique", "unipos", "table", "rank",
    "quantile"),
  uniorder = c("original", "values", "any"),
  taborder = c("values", "counts"),
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="benchmark64_+3A_nsmall">nsmall</code></td>
<td>
<p>size of smaller vector</p>
</td></tr>
<tr><td><code id="benchmark64_+3A_nbig">nbig</code></td>
<td>
<p>size of larger bigger vector</p>
</td></tr>
<tr><td><code id="benchmark64_+3A_timefun">timefun</code></td>
<td>
<p>a function for timing such as <code><a href="bit.html#topic+repeat.time">bit::repeat.time()</a></code> or <code><a href="base.html#topic+system.time">system.time()</a></code></p>
</td></tr>
<tr><td><code id="benchmark64_+3A_what">what</code></td>
<td>
<p>a vector of names of high-level functions</p>
</td></tr>
<tr><td><code id="benchmark64_+3A_uniorder">uniorder</code></td>
<td>
<p>one of the order parameters that are allowed in <code><a href="#topic+unique.integer64">unique.integer64()</a></code> and <code><a href="#topic+unipos.integer64">unipos.integer64()</a></code></p>
</td></tr>
<tr><td><code id="benchmark64_+3A_taborder">taborder</code></td>
<td>
<p>one of the order parameters that are allowed in <code><a href="#topic+table.integer64">table.integer64()</a></code></p>
</td></tr>
<tr><td><code id="benchmark64_+3A_plot">plot</code></td>
<td>
<p>set to FALSE to suppress plotting</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>benchmark64</code> compares the following scenarios for the following use cases:</p>

<table>
<tr>
 <td style="text-align: right;">
   <strong>scenario name</strong> </td><td style="text-align: left;"> <strong>explanation</strong> </td>
</tr>
<tr>
 <td style="text-align: right;">
   32-bit </td><td style="text-align: left;"> applying Base R function to 32-bit integer data </td>
</tr>
<tr>
 <td style="text-align: right;">
   64-bit </td><td style="text-align: left;"> applying bit64 function to 64-bit integer data (with no cache) </td>
</tr>
<tr>
 <td style="text-align: right;">
   hashcache </td><td style="text-align: left;"> ditto when cache contains <code><a href="#topic+hashmap">hashmap()</a></code>, see <code><a href="#topic+hashcache">hashcache()</a></code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   sortordercache </td><td style="text-align: left;"> ditto when cache contains sorting and ordering, see <code><a href="#topic+sortordercache">sortordercache()</a></code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   ordercache </td><td style="text-align: left;"> ditto when cache contains ordering only, see <code><a href="#topic+ordercache">ordercache()</a></code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   allcache </td><td style="text-align: left;"> ditto when cache contains sorting, ordering and hashing </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>


<table>
<tr>
 <td style="text-align: right;">
   <strong>use case name</strong> </td><td style="text-align: left;"> <strong>explanation</strong> </td>
</tr>
<tr>
 <td style="text-align: right;">
   cache </td><td style="text-align: left;"> filling the cache according to scenario </td>
</tr>
<tr>
 <td style="text-align: right;">
   match(s,b) </td><td style="text-align: left;"> match small in big vector </td>
</tr>
<tr>
 <td style="text-align: right;">
   s %in% b </td><td style="text-align: left;"> small %in% big vector </td>
</tr>
<tr>
 <td style="text-align: right;">
   match(b,s) </td><td style="text-align: left;"> match big in small vector </td>
</tr>
<tr>
 <td style="text-align: right;">
   b %in% s </td><td style="text-align: left;"> big %in% small vector </td>
</tr>
<tr>
 <td style="text-align: right;">
   match(b,b) </td><td style="text-align: left;"> match big in (different) big vector </td>
</tr>
<tr>
 <td style="text-align: right;">
   b %in% b </td><td style="text-align: left;"> big %in% (different) big vector </td>
</tr>
<tr>
 <td style="text-align: right;">
   duplicated(b) </td><td style="text-align: left;"> duplicated of big vector </td>
</tr>
<tr>
 <td style="text-align: right;">
   unique(b) </td><td style="text-align: left;"> unique of big vector </td>
</tr>
<tr>
 <td style="text-align: right;">
   table(b) </td><td style="text-align: left;"> table of big vector </td>
</tr>
<tr>
 <td style="text-align: right;">
   sort(b) </td><td style="text-align: left;"> sorting of big vector </td>
</tr>
<tr>
 <td style="text-align: right;">
   order(b) </td><td style="text-align: left;"> ordering of big vector </td>
</tr>
<tr>
 <td style="text-align: right;">
   rank(b) </td><td style="text-align: left;"> ranking of big vector </td>
</tr>
<tr>
 <td style="text-align: right;">
   quantile(b) </td><td style="text-align: left;"> quantiles of big vector </td>
</tr>
<tr>
 <td style="text-align: right;">
   summary(b) </td><td style="text-align: left;"> summary of of big vector </td>
</tr>
<tr>
 <td style="text-align: right;">
   SESSION </td><td style="text-align: left;"> exemplary session involving multiple calls (including cache filling costs) </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

<p>Note that the timings for the cached variants do <em>not</em> contain the
time costs of building the cache, except for the timing of the exemplary
user session, where the cache costs are included in order to evaluate amortization.
</p>


<h3>Value</h3>

<p><code>benchmark64</code> returns a matrix with elapsed seconds, different high-level tasks
in rows and different scenarios to solve the task in columns. The last row
named 'SESSION' contains the elapsed seconds of the exemplary sesssion.
</p>
<p><code>optimizer64</code> returns a dimensioned list with one row for each high-level
function timed and two columns named after the values of the <code>nsmall</code> and
<code>nbig</code> sample sizes. Each list cell contains a matrix with timings,
low-level-methods in rows and three measurements <code>c("prep","both","use")</code>
in columns. If it can be measured separately, <code>prep</code> contains the timing
of preparatory work such as sorting and hashing, and <code>use</code> contains the
timing of using the prepared work. If the function timed does both,
preparation and use, the timing is in <code>both</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>benchmark64()</code>: compares high-level integer64 functions against the
integer functions from Base R
</p>
</li>
<li> <p><code>optimizer64()</code>: compares for each high-level integer64 function the Base
R integer function with several low-level integer64 functions with and
without caching
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+integer64">integer64()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>message("this small example using system.time does not give serious timings\n
this we do this only to run regression tests")
benchmark64(nsmall=2^7, nbig=2^13, timefun=function(expr)system.time(expr, gcFirst=FALSE))
optimizer64(nsmall=2^7, nbig=2^13, timefun=function(expr)system.time(expr, gcFirst=FALSE)
, plot=FALSE
)
## Not run: 
message("for real measurement of sufficiently large datasets run this on your machine")
benchmark64()
optimizer64()

## End(Not run)
message("let's look at the performance results on Core i7 Lenovo T410 with 8 GB RAM")
data(benchmark64.data)
print(benchmark64.data)

matplot(log2(benchmark64.data[-1,1]/benchmark64.data[-1,])
, pch=c("3", "6", "h", "s", "o", "a")
, xlab="tasks [last=session]"
, ylab="log2(relative speed) [bigger is better]"
)
matplot(t(log2(benchmark64.data[-1,1]/benchmark64.data[-1,]))
, type="b", axes=FALSE
, lwd=c(rep(1, 14), 3)
, xlab="context"
, ylab="log2(relative speed) [bigger is better]"
)
axis(1
, labels=c("32-bit", "64-bit", "hash", "sortorder", "order", "hash+sortorder")
, at=1:6
)
axis(2)
data(optimizer64.data)
print(optimizer64.data)
oldpar &lt;- par(no.readonly = TRUE)
par(mfrow=c(2,1))
par(cex=0.7)
for (i in 1:nrow(optimizer64.data)){
 for (j in 1:2){
   tim &lt;- optimizer64.data[[i,j]]
  barplot(t(tim))
  if (rownames(optimizer64.data)[i]=="match")
   title(paste("match", colnames(optimizer64.data)[j], "in", colnames(optimizer64.data)[3-j]))
  else if (rownames(optimizer64.data)[i]=="%in%")
   title(paste(colnames(optimizer64.data)[j], "%in%", colnames(optimizer64.data)[3-j]))
  else
   title(paste(rownames(optimizer64.data)[i], colnames(optimizer64.data)[j]))
 }
}
par(mfrow=c(1,1))
</code></pre>

<hr>
<h2 id='benchmark64.data'>Results of performance measurement on a Core i7 Lenovo T410 8 GB RAM under Windows 7 64bit</h2><span id='topic+benchmark64.data'></span>

<h3>Description</h3>

<p>These are the results of calling <code><a href="#topic+benchmark64">benchmark64()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(benchmark64.data)
</code></pre>


<h3>Format</h3>

<p>The format is:
</p>
<div class="sourceCode"><pre>num [1:16, 1:6] 2.55e-05 2.37 2.39 1.28 1.39 ...
- attr(*, "dimnames")=List of 2
..$ : chr [1:16] "cache" "match(s,b)" "s %in% b" "match(b,s)" ...
..$ : chr [1:6] "32-bit" "64-bit" "hashcache" "sortordercache" ...
</pre></div>


<h3>Examples</h3>

<pre><code class='language-R'>data(benchmark64.data)
print(benchmark64.data)
matplot(log2(benchmark64.data[-1,1]/benchmark64.data[-1,])
, pch=c("3", "6", "h", "s", "o", "a")
, xlab="tasks [last=session]"
, ylab="log2(relative speed) [bigger is better]"
)
matplot(t(log2(benchmark64.data[-1,1]/benchmark64.data[-1,]))
, axes=FALSE
, type="b"
, lwd=c(rep(1, 14), 3)
, xlab="context"
, ylab="log2(relative speed) [bigger is better]"
)
axis(1
, labels=c("32-bit", "64-bit", "hash", "sortorder", "order", "hash+sortorder")
, at=1:6
)
axis(2)
</code></pre>

<hr>
<h2 id='bit64S3'>Turning base R functions into S3 generics for bit64</h2><span id='topic+bit64S3'></span><span id='topic++3A'></span><span id='topic++3A.default'></span><span id='topic++3A.integer64'></span><span id='topic+is.double'></span><span id='topic+is.double.default'></span><span id='topic+is.double.integer64'></span><span id='topic+match'></span><span id='topic+match.default'></span><span id='topic++25in+25'></span><span id='topic++25in+25.default'></span><span id='topic+rank'></span><span id='topic+rank.default'></span><span id='topic+order'></span><span id='topic+order.default'></span><span id='topic+mtfrm.integer64'></span>

<h3>Description</h3>

<p>Turn those base functions S3 generic which are used in bit64
</p>


<h3>Usage</h3>

<pre><code class='language-R'>from:to
is.double(x)
match(x, table, ...)
x %in% table
rank(x, ...)
order(...)

## Default S3 method:
is.double(x)

## S3 method for class 'integer64'
is.double(x)

## S3 method for class 'integer64'
mtfrm(x)

## Default S3 method:
match(x, table, ...)

## Default S3 method:
x %in% table

## Default S3 method:
rank(x, ...)

## Default S3 method:
order(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bit64S3_+3A_x">x</code></td>
<td>
<p>integer64 vector: the values to be matched, optionally carrying a
cache created with <code><a href="#topic+hashcache">hashcache()</a></code></p>
</td></tr>
<tr><td><code id="bit64S3_+3A_table">table</code></td>
<td>
<p>integer64 vector: the values to be matched against, optionally
carrying a cache created with <code><a href="#topic+hashcache">hashcache()</a></code> or <code><a href="#topic+sortordercache">sortordercache()</a></code></p>
</td></tr>
<tr><td><code id="bit64S3_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="bit64S3_+3A_from">from</code></td>
<td>
<p>scalar denoting first element of sequence</p>
</td></tr>
<tr><td><code id="bit64S3_+3A_to">to</code></td>
<td>
<p>scalar denoting last element of sequence</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following functions are turned into S3 generics in order to dispatch
methods for <code><a href="#topic+integer64">integer64()</a></code>:
</p>

<ul>
<li> <p><code><a href="#topic++3A">:</a></code>
</p>
</li>
<li> <p><code><a href="#topic+is.double">is.double()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+match">match()</a></code>
</p>
</li>
<li> <p><code><a href="#topic++25in+25">%in%</a></code>
</p>
</li>
<li> <p><code><a href="#topic+rank">rank()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+order">order()</a></code>
</p>
</li></ul>



<h3>Value</h3>

<p><code><a href="base.html#topic+invisible">invisible()</a></code>
</p>


<h3>Note</h3>


<ul>
<li> <p><code><a href="#topic+is.double">is.double()</a></code> returns <code>FALSE</code> for <code><a href="#topic+integer64">integer64</a></code>
</p>
</li>
<li> <p><code><a href="#topic++3A">:</a></code> currently only dispatches at its first argument, thus
<code>as.integer64(1):9</code> works but <code>1:as.integer64(9)</code> doesn't
</p>
</li>
<li> <p><code><a href="#topic+match">match()</a></code> currently only dispatches at its first argument and expects
its second argument also to be integer64, otherwise throws an error.
Beware of something like <code>match(2, as.integer64(0:3))</code>
</p>
</li>
<li> <p><code><a href="#topic++25in+25">%in%</a></code> currently only dispatches at its first argument and expects
its second argument also to be integer64, otherwise throws an error.
Beware of something like <code>2 %in% as.integer64(0:3)</code>
</p>
</li>
<li> <p><code><a href="#topic+order">order()</a></code> currently only orders a single argument, trying more than
one raises an error
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+bit64">bit64()</a></code>, <a href="methods.html#topic+S3">S3</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> is.double(as.integer64(1))
    as.integer64(1):9
 match(as.integer64(2), as.integer64(0:3))
 as.integer64(2) %in% as.integer64(0:3)

 unique(as.integer64(c(1,1,2)))
 rank(as.integer64(c(1,1,2)))


 order(as.integer64(c(1,NA,2)))
</code></pre>

<hr>
<h2 id='c.integer64'>Concatenating integer64 vectors</h2><span id='topic+c.integer64'></span><span id='topic+cbind.integer64'></span><span id='topic+rbind.integer64'></span>

<h3>Description</h3>

<p>The ususal functions 'c', 'cbind' and 'rbind'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'integer64'
c(..., recursive = FALSE)

## S3 method for class 'integer64'
cbind(...)

## S3 method for class 'integer64'
rbind(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="c.integer64_+3A_...">...</code></td>
<td>
<p>two or more arguments coerced to 'integer64' and
passed to <code><a href="base.html#topic+NextMethod">NextMethod()</a></code></p>
</td></tr>
<tr><td><code id="c.integer64_+3A_recursive">recursive</code></td>
<td>
<p>logical. If <code>recursive = TRUE</code>, the function
recursively descends through lists (and pairlists) combining all
their elements into a vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="base.html#topic+c">c()</a></code> returns a integer64 vector of the total length of the input
</p>
<p><code><a href="base.html#topic+cbind">cbind()</a></code> and <code><a href="base.html#topic+rbind">rbind()</a></code> return a integer64 matrix
</p>


<h3>Note</h3>

<p>R currently only dispatches generic 'c' to method 'c.integer64' if the
first argument is 'integer64'
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rep.integer64">rep.integer64()</a></code> <code><a href="#topic+seq.integer64">seq.integer64()</a></code> <code><a href="#topic+as.data.frame.integer64">as.data.frame.integer64()</a></code>
<code><a href="#topic+integer64">integer64()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  c(as.integer64(1), 2:6)
  cbind(1:6, as.integer(1:6))
  rbind(1:6, as.integer(1:6))
</code></pre>

<hr>
<h2 id='cache'>Atomic Caching</h2><span id='topic+cache'></span><span id='topic+newcache'></span><span id='topic+jamcache'></span><span id='topic+setcache'></span><span id='topic+getcache'></span><span id='topic+remcache'></span><span id='topic+print.cache'></span>

<h3>Description</h3>

<p>Functions for caching results attached to atomic objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newcache(x)

jamcache(x)

cache(x)

setcache(x, which, value)

getcache(x, which)

remcache(x)

## S3 method for class 'cache'
print(x, all.names = FALSE, pattern, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cache_+3A_x">x</code></td>
<td>
<p>an integer64 vector (or a cache object in case of <code>print.cache</code>)</p>
</td></tr>
<tr><td><code id="cache_+3A_which">which</code></td>
<td>
<p>A character naming the object to be retrieved from the cache or to be stored in the cache</p>
</td></tr>
<tr><td><code id="cache_+3A_value">value</code></td>
<td>
<p>An object to be stored in the cache</p>
</td></tr>
<tr><td><code id="cache_+3A_all.names">all.names</code>, <code id="cache_+3A_pattern">pattern</code></td>
<td>
<p>passed to <code><a href="base.html#topic+ls">ls()</a></code> when listing the cache content</p>
</td></tr>
<tr><td><code id="cache_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>cache</code> is an <code><a href="base.html#topic+environment">environment</a></code> attached to an atomic object with the
<code><a href="base.html#topic+attr">attribute</a></code> name 'cache'. It contains at least a reference to the
atomic object that carries the cache. This is used when accessing
the cache to detect whether the object carrying the cache has been
modified meanwhile.
</p>


<h3>Value</h3>

<p>See details
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>newcache()</code>: creates a new cache referencing  <code>x</code>
</p>
</li>
<li> <p><code>jamcache()</code>: forces <code>x</code> to have a cache
</p>
</li>
<li> <p><code>cache()</code>: returns the cache attached to <code>x</code> if it is not
found to be outdated
</p>
</li>
<li> <p><code>setcache()</code>: assigns a value into the cache of <code>x</code>
</p>
</li>
<li> <p><code>getcache()</code>: gets cache value 'which' from <code>x</code>
</p>
</li>
<li> <p><code>remcache()</code>: removes the cache from <code>x</code>
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="bit.html#topic+still.identical">bit::still.identical()</a></code> for testing whether to symbols point to the same RAM.
</p>
<p>Functions that get and set small cache-content automatically when a cache is present:
<code><a href="bit.html#topic+Metadata">bit::na.count()</a></code>, <code><a href="bit.html#topic+Metadata">bit::nvalid()</a></code>, <code><a href="bit.html#topic+Metadata">bit::is.sorted()</a></code>, <code><a href="bit.html#topic+Metadata">bit::nunique()</a></code> and
<code><a href="bit.html#topic+Metadata">bit::nties()</a></code>
</p>
<p>Setting big caches with a relevant memory footprint requires a conscious decision
of the user: <code><a href="#topic+hashcache">hashcache</a></code>, <code><a href="#topic+sortcache">sortcache</a></code>, <code><a href="#topic+ordercache">ordercache</a></code>, <code><a href="#topic+sortordercache">sortordercache</a></code>
</p>
<p>Functions that use big caches: <code><a href="#topic+match.integer64">match.integer64()</a></code>, <code><a href="#topic++25in+25.integer64">%in%.integer64</a></code>,
<code><a href="#topic+duplicated.integer64">duplicated.integer64()</a></code>, <code><a href="#topic+unique.integer64">unique.integer64()</a></code>, <code><a href="#topic+unipos">unipos()</a></code>, <code><a href="#topic+table.integer64">table.integer64()</a></code>,
<code><a href="#topic+keypos">keypos()</a></code>, <code><a href="#topic+tiepos">tiepos()</a></code>, <code><a href="#topic+rank.integer64">rank.integer64()</a></code>, <code><a href="#topic+prank">prank()</a></code>, <code><a href="#topic+qtile">qtile()</a></code>,
<code><a href="#topic+quantile.integer64">quantile.integer64()</a></code>, <code><a href="#topic+median.integer64">median.integer64()</a></code>, and <code><a href="#topic+summary.integer64">summary.integer64()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
  y &lt;- x
  still.identical(x,y)
  y[1] &lt;- NA
  still.identical(x,y)
  mycache &lt;- newcache(x)
  ls(mycache)
  mycache
  rm(mycache)
  jamcache(x)
  cache(x)
  x[1] &lt;- NA
  cache(x)
  getcache(x, "abc")
  setcache(x, "abc", 1)
  getcache(x, "abc")
  remcache(x)
  cache(x)
</code></pre>

<hr>
<h2 id='cumsum.integer64'>Cumulative Sums, Products, Extremes and lagged differences</h2><span id='topic+cumsum.integer64'></span><span id='topic+diff.integer64'></span><span id='topic+cummin.integer64'></span><span id='topic+cummax.integer64'></span><span id='topic+cumprod.integer64'></span>

<h3>Description</h3>

<p>Cumulative Sums, Products, Extremes and lagged differences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'integer64'
diff(x, lag = 1L, differences = 1L, ...)

## S3 method for class 'integer64'
cummin(x)

## S3 method for class 'integer64'
cummax(x)

## S3 method for class 'integer64'
cumsum(x)

## S3 method for class 'integer64'
cumprod(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cumsum.integer64_+3A_x">x</code></td>
<td>
<p>an atomic vector of class 'integer64'</p>
</td></tr>
<tr><td><code id="cumsum.integer64_+3A_lag">lag</code></td>
<td>
<p>see <code><a href="base.html#topic+diff">diff()</a></code></p>
</td></tr>
<tr><td><code id="cumsum.integer64_+3A_differences">differences</code></td>
<td>
<p>see <code><a href="base.html#topic+diff">diff()</a></code></p>
</td></tr>
<tr><td><code id="cumsum.integer64_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="base.html#topic+cummin">cummin()</a></code>, <code><a href="base.html#topic+cummax">cummax()</a></code> , <code><a href="base.html#topic+cumsum">cumsum()</a></code> and <code><a href="base.html#topic+cumprod">cumprod()</a></code>
return a integer64 vector of the same length as their input
</p>
<p><code><a href="base.html#topic+diff">diff()</a></code> returns a integer64 vector shorter by <code>lag*differences</code> elements
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sum.integer64">sum.integer64()</a></code> <code><a href="#topic+integer64">integer64()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  cumsum(rep(as.integer64(1), 12))
  diff(as.integer64(c(0,1:12)))
  cumsum(as.integer64(c(0, 1:12)))
  diff(cumsum(as.integer64(c(0,0,1:12))), differences=2)
</code></pre>

<hr>
<h2 id='duplicated.integer64'>Determine Duplicate Elements of integer64</h2><span id='topic+duplicated.integer64'></span>

<h3>Description</h3>

<p><code>duplicated()</code> determines which elements of a vector or data frame are duplicates
of elements with smaller subscripts, and returns a logical vector
indicating which elements (rows) are duplicates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'integer64'
duplicated(x, incomparables = FALSE, nunique = NULL, method = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="duplicated.integer64_+3A_x">x</code></td>
<td>
<p>a vector or a data frame or an array or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="duplicated.integer64_+3A_incomparables">incomparables</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="duplicated.integer64_+3A_nunique">nunique</code></td>
<td>
<p>NULL or the number of unique values (including NA). Providing
<code>nunique</code> can speed-up matching when <code>x</code> has no cache. Note that a wrong
<code>nunique</code> can cause undefined behaviour up to a crash.</p>
</td></tr>
<tr><td><code id="duplicated.integer64_+3A_method">method</code></td>
<td>
<p>NULL for automatic method selection or a suitable low-level
method, see details</p>
</td></tr>
<tr><td><code id="duplicated.integer64_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function automatically chooses from several low-level functions
considering the size of <code>x</code> and the availability of a cache.
</p>
<p>Suitable methods are
</p>

<ul>
<li> <p><code><a href="#topic+hashdup">hashdup</a></code> (hashing)
</p>
</li>
<li> <p><code><a href="#topic+sortorderdup">sortorderdup</a></code> (fast ordering)
</p>
</li>
<li> <p><code><a href="#topic+orderdup">orderdup</a></code> (memory saving ordering).
</p>
</li></ul>



<h3>Value</h3>

<p><code>duplicated()</code>: a logical vector of the same length as <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+duplicated">duplicated()</a></code>, <code><a href="#topic+unique.integer64">unique.integer64()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
duplicated(x)

stopifnot(identical(duplicated(x),  duplicated(as.integer(x))))
</code></pre>

<hr>
<h2 id='extract.replace.integer64'>Extract or Replace Parts of an integer64 vector</h2><span id='topic+extract.replace.integer64'></span><span id='topic++5B.integer64'></span><span id='topic++5B+3C-.integer64'></span><span id='topic++5B+5B.integer64'></span><span id='topic++5B+5B+3C-.integer64'></span>

<h3>Description</h3>

<p>Methods to extract and replace parts of an integer64 vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'integer64'
x[i, ...]

## S3 replacement method for class 'integer64'
x[...] &lt;- value

## S3 method for class 'integer64'
x[[...]]

## S3 replacement method for class 'integer64'
x[[...]] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract.replace.integer64_+3A_x">x</code></td>
<td>
<p>an atomic vector</p>
</td></tr>
<tr><td><code id="extract.replace.integer64_+3A_i">i</code></td>
<td>
<p>indices specifying elements to extract</p>
</td></tr>
<tr><td><code id="extract.replace.integer64_+3A_...">...</code></td>
<td>
<p>further arguments to the <code><a href="base.html#topic+NextMethod">NextMethod()</a></code></p>
</td></tr>
<tr><td><code id="extract.replace.integer64_+3A_value">value</code></td>
<td>
<p>an atomic vector with values to be assigned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector or scalar of class 'integer64'
</p>


<h3>Note</h3>

<p>You should not subscript non-existing elements and not use <code>NA</code>s as subscripts.
The current implementation returns <code>9218868437227407266</code> instead of <code>NA</code>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+Extract">[</a></code> <code><a href="#topic+integer64">integer64()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  as.integer64(1:12)[1:3]
  x &lt;- as.integer64(1:12)
  dim(x) &lt;- c(3,4)
  x
  x[]
  x[,2:3]
</code></pre>

<hr>
<h2 id='format.integer64'>Unary operators and functions for integer64 vectors</h2><span id='topic+format.integer64'></span><span id='topic+sign.integer64'></span><span id='topic+abs.integer64'></span><span id='topic+sqrt.integer64'></span><span id='topic+log.integer64'></span><span id='topic+log10.integer64'></span><span id='topic+log2.integer64'></span><span id='topic+trunc.integer64'></span><span id='topic+floor.integer64'></span><span id='topic+ceiling.integer64'></span><span id='topic+signif.integer64'></span><span id='topic+scale.integer64'></span><span id='topic+round.integer64'></span><span id='topic+is.na.integer64'></span><span id='topic+is.finite.integer64'></span><span id='topic+is.infinite.integer64'></span><span id='topic+is.nan.integer64'></span><span id='topic++21.integer64'></span>

<h3>Description</h3>

<p>Unary operators and functions for integer64 vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'integer64'
format(x, justify = "right", ...)

## S3 method for class 'integer64'
sign(x)

## S3 method for class 'integer64'
abs(x)

## S3 method for class 'integer64'
sqrt(x)

## S3 method for class 'integer64'
log(x, base = NULL)

## S3 method for class 'integer64'
log10(x)

## S3 method for class 'integer64'
log2(x)

## S3 method for class 'integer64'
trunc(x, ...)

## S3 method for class 'integer64'
floor(x)

## S3 method for class 'integer64'
ceiling(x)

## S3 method for class 'integer64'
signif(x, digits = 6L)

## S3 method for class 'integer64'
scale(x, center = TRUE, scale = TRUE)

## S3 method for class 'integer64'
round(x, digits = 0L)

## S3 method for class 'integer64'
is.na(x)

## S3 method for class 'integer64'
is.finite(x)

## S3 method for class 'integer64'
is.infinite(x)

## S3 method for class 'integer64'
is.nan(x)

## S3 method for class 'integer64'
!x
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="format.integer64_+3A_x">x</code></td>
<td>
<p>an atomic vector of class 'integer64'</p>
</td></tr>
<tr><td><code id="format.integer64_+3A_justify">justify</code></td>
<td>
<p>should it be right-justified (the default), left-justified,
centred or left alone.</p>
</td></tr>
<tr><td><code id="format.integer64_+3A_...">...</code></td>
<td>
<p>further arguments to the <code><a href="base.html#topic+NextMethod">NextMethod()</a></code></p>
</td></tr>
<tr><td><code id="format.integer64_+3A_base">base</code></td>
<td>
<p>an atomic scalar (we save 50% log-calls by not allowing
a vector base)</p>
</td></tr>
<tr><td><code id="format.integer64_+3A_digits">digits</code></td>
<td>
<p>integer indicating the number of decimal places (round)
or significant digits (signif) to be used. Negative values are allowed
(see <code><a href="base.html#topic+round">round()</a></code>)</p>
</td></tr>
<tr><td><code id="format.integer64_+3A_center">center</code></td>
<td>
<p>see <code><a href="base.html#topic+scale">scale()</a></code></p>
</td></tr>
<tr><td><code id="format.integer64_+3A_scale">scale</code></td>
<td>
<p>see <code><a href="base.html#topic+scale">scale()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="base.html#topic+format">format()</a></code> returns a character vector
</p>
<p><code><a href="base.html#topic+is.na">is.na()</a></code> and <code><a href="base.html#topic++21">!</a></code> return a logical vector
</p>
<p><code><a href="base.html#topic+sqrt">sqrt()</a></code>, <code><a href="base.html#topic+log">log()</a></code>, <code><a href="base.html#topic+log2">log2()</a></code> and <code><a href="base.html#topic+log10">log10()</a></code> return a double vector
</p>
<p><code><a href="base.html#topic+sign">sign()</a></code>, <code><a href="base.html#topic+abs">abs()</a></code>, <code><a href="base.html#topic+floor">floor()</a></code>, <code><a href="base.html#topic+ceiling">ceiling()</a></code>, <code><a href="base.html#topic+trunc">trunc()</a></code> and
<code><a href="base.html#topic+round">round()</a></code> return a vector of class 'integer64'
</p>
<p><code><a href="base.html#topic+signif">signif()</a></code> is not implemented
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xor.integer64">xor.integer64()</a></code> <code><a href="#topic+integer64">integer64()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  sqrt(as.integer64(1:12))
</code></pre>

<hr>
<h2 id='hashcache'>Big caching of hashing, sorting, ordering</h2><span id='topic+hashcache'></span><span id='topic+sortcache'></span><span id='topic+sortordercache'></span><span id='topic+ordercache'></span>

<h3>Description</h3>

<p>Functions to create cache that accelerates many operations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hashcache(x, nunique = NULL, ...)

sortcache(x, has.na = NULL)

sortordercache(x, has.na = NULL, stable = NULL)

ordercache(x, has.na = NULL, stable = NULL, optimize = "time")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hashcache_+3A_x">x</code></td>
<td>
<p>an atomic vector (note that currently only integer64 is supported)</p>
</td></tr>
<tr><td><code id="hashcache_+3A_nunique">nunique</code></td>
<td>
<p>giving <em>correct</em> number of unique elements can help reducing
the size of the hashmap</p>
</td></tr>
<tr><td><code id="hashcache_+3A_...">...</code></td>
<td>
<p>passed to <code><a href="#topic+hashmap">hashmap()</a></code></p>
</td></tr>
<tr><td><code id="hashcache_+3A_has.na">has.na</code></td>
<td>
<p>boolean scalar defining whether the input vector might contain
<code>NA</code>s. If we know we don't have <code>NA</code>s, this may speed-up. <em>Note</em> that you
risk a crash if there are unexpected <code>NA</code>s with <code>has.na=FALSE</code>.</p>
</td></tr>
<tr><td><code id="hashcache_+3A_stable">stable</code></td>
<td>
<p>boolean scalar defining whether stable sorting is needed. Allowing
non-stable may speed-up.</p>
</td></tr>
<tr><td><code id="hashcache_+3A_optimize">optimize</code></td>
<td>
<p>by default ramsort optimizes for 'time' which requires more RAM,
set to 'memory' to minimize RAM requirements and sacrifice speed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The result of relative expensive operations <code><a href="#topic+hashmap">hashmap()</a></code>, <code><a href="bit.html#topic+Sorting">bit::ramsort()</a></code>,
<code><a href="bit.html#topic+Sorting">bit::ramsortorder()</a></code>, and <code><a href="bit.html#topic+Sorting">bit::ramorder()</a></code> can be stored in a cache in
order to avoid multiple excutions. Unless in very specific situations, the
recommended method is <code>hashsortorder</code> only.
</p>


<h3>Value</h3>

<p><code>x</code> with a <code><a href="#topic+cache">cache()</a></code> that contains the result of the expensive operations,
possible together with small derived information (such as <code><a href="#topic+nunique.integer64">nunique.integer64()</a></code>)
and previously cached results.
</p>


<h3>Note</h3>

<p>Note that we consider storing the big results from sorting and/or ordering
as a relevant side-effect, and therefore storing them in the cache should
require a conscious decision of the user.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cache">cache()</a></code> for caching functions and <code><a href="#topic+nunique.integer64">nunique.integer64()</a></code> for methods benefiting
from small caches
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
  sortordercache(x)

</code></pre>

<hr>
<h2 id='hashmap'>Hashing for 64bit integers</h2><span id='topic+hashmap'></span><span id='topic+hashfun'></span><span id='topic+hashfun.integer64'></span><span id='topic+hashmap.integer64'></span><span id='topic+hashpos'></span><span id='topic+hashpos.cache_integer64'></span><span id='topic+hashrev'></span><span id='topic+hashrev.cache_integer64'></span><span id='topic+hashfin'></span><span id='topic+hashfin.cache_integer64'></span><span id='topic+hashrin'></span><span id='topic+hashrin.cache_integer64'></span><span id='topic+hashdup'></span><span id='topic+hashdup.cache_integer64'></span><span id='topic+hashuni'></span><span id='topic+hashuni.cache_integer64'></span><span id='topic+hashupo'></span><span id='topic+hashupo.cache_integer64'></span><span id='topic+hashtab'></span><span id='topic+hashtab.cache_integer64'></span><span id='topic+hashmaptab'></span><span id='topic+hashmaptab.integer64'></span><span id='topic+hashmapuni'></span><span id='topic+hashmapuni.integer64'></span><span id='topic+hashmapupo'></span><span id='topic+hashmapupo.integer64'></span>

<h3>Description</h3>

<p>This is an explicit implementation of hash functionality that underlies
matching and other functions in R. Explicit means that you can create,
store and use hash functionality directly. One advantage is that you can
re-use hashmaps, which avoid re-building hashmaps again and again.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hashfun(x, ...)

## S3 method for class 'integer64'
hashfun(x, minfac = 1.41, hashbits = NULL, ...)

hashmap(x, ...)

## S3 method for class 'integer64'
hashmap(x, nunique = NULL, minfac = 1.41, hashbits = NULL, cache = NULL, ...)

hashpos(cache, ...)

## S3 method for class 'cache_integer64'
hashpos(cache, x, nomatch = NA_integer_, ...)

hashrev(cache, ...)

## S3 method for class 'cache_integer64'
hashrev(cache, x, nomatch = NA_integer_, ...)

hashfin(cache, ...)

## S3 method for class 'cache_integer64'
hashfin(cache, x, ...)

hashrin(cache, ...)

## S3 method for class 'cache_integer64'
hashrin(cache, x, ...)

hashdup(cache, ...)

## S3 method for class 'cache_integer64'
hashdup(cache, ...)

hashuni(cache, ...)

## S3 method for class 'cache_integer64'
hashuni(cache, keep.order = FALSE, ...)

hashupo(cache, ...)

## S3 method for class 'cache_integer64'
hashupo(cache, keep.order = FALSE, ...)

hashtab(cache, ...)

## S3 method for class 'cache_integer64'
hashtab(cache, ...)

hashmaptab(x, ...)

## S3 method for class 'integer64'
hashmaptab(x, nunique = NULL, minfac = 1.5, hashbits = NULL, ...)

hashmapuni(x, ...)

## S3 method for class 'integer64'
hashmapuni(x, nunique = NULL, minfac = 1.5, hashbits = NULL, ...)

hashmapupo(x, ...)

## S3 method for class 'integer64'
hashmapupo(x, nunique = NULL, minfac = 1.5, hashbits = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hashmap_+3A_x">x</code></td>
<td>
<p>an integer64 vector</p>
</td></tr>
<tr><td><code id="hashmap_+3A_...">...</code></td>
<td>
<p>further arguments, passed from generics, ignored in methods</p>
</td></tr>
<tr><td><code id="hashmap_+3A_minfac">minfac</code></td>
<td>
<p>minimum factor by which the hasmap has more elements compared to the data <code>x</code>, ignored if <code>hashbits</code> is given directly</p>
</td></tr>
<tr><td><code id="hashmap_+3A_hashbits">hashbits</code></td>
<td>
<p>length of hashmap is <code>2^hashbits</code></p>
</td></tr>
<tr><td><code id="hashmap_+3A_nunique">nunique</code></td>
<td>
<p>giving <em>correct</em> number of unique elements can help reducing the size of the hashmap</p>
</td></tr>
<tr><td><code id="hashmap_+3A_cache">cache</code></td>
<td>
<p>an optional <code><a href="#topic+cache">cache()</a></code> object into which to put the hashmap (by default a new cache is created</p>
</td></tr>
<tr><td><code id="hashmap_+3A_nomatch">nomatch</code></td>
<td>
<p>the value to be returned if an element is not found in the hashmap</p>
</td></tr>
<tr><td><code id="hashmap_+3A_keep.order">keep.order</code></td>
<td>
<p>determines order of results and speed: <code>FALSE</code> (the default) is faster and returns in the (pseudo)random order of the hash function, <code>TRUE</code> returns in the order of first appearance in the original data, but this requires extra work</p>
</td></tr>
</table>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: right;">
   <strong>function</strong> </td><td style="text-align: right;"> <strong>see also</strong> </td><td style="text-align: left;"> <strong>description</strong> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>hashfun</code> </td><td style="text-align: right;"> <code>digest</code> </td><td style="text-align: left;"> export of the hash function used in <code>hashmap</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>hashmap</code> </td><td style="text-align: right;"> <code><a href="#topic+match.integer64">match()</a></code> </td><td style="text-align: left;"> return hashmap </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>hashpos</code> </td><td style="text-align: right;"> <code><a href="#topic+match.integer64">match()</a></code> </td><td style="text-align: left;"> return positions of <code>x</code> in <code>hashmap</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>hashrev</code> </td><td style="text-align: right;"> <code><a href="#topic+match.integer64">match()</a></code> </td><td style="text-align: left;"> return positions of <code>hashmap</code> in <code>x</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>hashfin</code> </td><td style="text-align: right;"> <code><a href="#topic++25in+25.integer64">%in%.integer64</a></code> </td><td style="text-align: left;"> return logical whether <code>x</code> is in <code>hashmap</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>hashrin</code> </td><td style="text-align: right;"> <code><a href="#topic++25in+25.integer64">%in%.integer64</a></code> </td><td style="text-align: left;"> return logical whether <code>hashmap</code> is in <code>x</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>hashdup</code> </td><td style="text-align: right;"> <code><a href="#topic+duplicated.integer64">duplicated()</a></code> </td><td style="text-align: left;"> return logical whether hashdat is duplicated using hashmap </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>hashuni</code> </td><td style="text-align: right;"> <code><a href="#topic+unique.integer64">unique()</a></code> </td><td style="text-align: left;"> return unique values of hashmap </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>hashmapuni</code> </td><td style="text-align: right;"> <code><a href="#topic+unique.integer64">unique()</a></code> </td><td style="text-align: left;"> return unique values of <code>x</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>hashupo</code> </td><td style="text-align: right;"> <code><a href="#topic+unique.integer64">unique()</a></code> </td><td style="text-align: left;"> return positions of unique values in hashdat </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>hashmapupo</code> </td><td style="text-align: right;"> <code><a href="#topic+unique.integer64">unique()</a></code> </td><td style="text-align: left;"> return positions of unique values in <code>x</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>hashtab</code> </td><td style="text-align: right;"> <code><a href="#topic+table.integer64">table()</a></code> </td><td style="text-align: left;"> tabulate values of hashdat using hashmap in <code>keep.order=FALSE</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>hashmaptab</code> </td><td style="text-align: right;"> <code><a href="#topic+table.integer64">table()</a></code> </td><td style="text-align: left;"> tabulate values of <code>x</code> building hasmap on the fly in <code>keep.order=FALSE</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>See Details
</p>


<h3>See Also</h3>

<p><code><a href="#topic+match.integer64">match()</a></code>, <code><a href="#topic+runif64">runif64()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.integer64(sample(c(NA, 0:9)))
y &lt;- as.integer64(sample(c(NA, 1:9), 10, TRUE))
hashfun(y)
hx &lt;- hashmap(x)
hy &lt;- hashmap(y)
ls(hy)
hashpos(hy, x)
hashrev(hx, y)
hashfin(hy, x)
hashrin(hx, y)
hashdup(hy)
hashuni(hy)
hashuni(hy, keep.order=TRUE)
hashmapuni(y)
hashupo(hy)
hashupo(hy, keep.order=TRUE)
hashmapupo(y)
hashtab(hy)
hashmaptab(y)

stopifnot(identical(match(as.integer(x),as.integer(y)),hashpos(hy, x)))
stopifnot(identical(match(as.integer(x),as.integer(y)),hashrev(hx, y)))
stopifnot(identical(as.integer(x) %in% as.integer(y), hashfin(hy, x)))
stopifnot(identical(as.integer(x) %in% as.integer(y), hashrin(hx, y)))
stopifnot(identical(duplicated(as.integer(y)), hashdup(hy)))
stopifnot(identical(as.integer64(unique(as.integer(y))), hashuni(hy, keep.order=TRUE)))
stopifnot(identical(sort(hashuni(hy, keep.order=FALSE)), sort(hashuni(hy, keep.order=TRUE))))
stopifnot(identical(y[hashupo(hy, keep.order=FALSE)], hashuni(hy, keep.order=FALSE)))
stopifnot(identical(y[hashupo(hy, keep.order=TRUE)], hashuni(hy, keep.order=TRUE)))
stopifnot(identical(hashpos(hy, hashuni(hy, keep.order=TRUE)), hashupo(hy, keep.order=TRUE)))
stopifnot(identical(hashpos(hy, hashuni(hy, keep.order=FALSE)), hashupo(hy, keep.order=FALSE)))
stopifnot(identical(hashuni(hy, keep.order=FALSE), hashtab(hy)$values))
stopifnot(identical(as.vector(table(as.integer(y), useNA="ifany"))
, hashtab(hy)$counts[order.integer64(hashtab(hy)$values)]))
stopifnot(identical(hashuni(hy, keep.order=TRUE), hashmapuni(y)))
stopifnot(identical(hashupo(hy, keep.order=TRUE), hashmapupo(y)))
stopifnot(identical(hashtab(hy), hashmaptab(y)))

    ## Not run: 
    message("explore speed given size of the hasmap in 2^hashbits and size of the data")
    message("more hashbits means more random access and less collisions")
    message("i.e. more data means less random access and more collisions")
    bits &lt;- 24
    b &lt;- seq(-1, 0, 0.1)
    tim &lt;- matrix(NA, length(b), 2, dimnames=list(b, c("bits","bits+1")))
    for (i in 1:length(b)){
      n &lt;- as.integer(2^(bits+b[i]))
      x &lt;- as.integer64(sample(n))
      tim[i,1] &lt;- repeat.time(hashmap(x, hashbits=bits))[3]
      tim[i,2] &lt;- repeat.time(hashmap(x, hashbits=bits+1))[3]
      print(tim)
      matplot(b, tim)
    }
    message("we conclude that n*sqrt(2) is enough to avoid collisions")
    
## End(Not run)
</code></pre>

<hr>
<h2 id='identical.integer64'>Identity function for class 'integer64'</h2><span id='topic+identical.integer64'></span>

<h3>Description</h3>

<p>This will discover any deviation between objects containing integer64 vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identical.integer64(
  x,
  y,
  num.eq = FALSE,
  single.NA = FALSE,
  attrib.as.set = TRUE,
  ignore.bytecode = TRUE,
  ignore.environment = FALSE,
  ignore.srcref = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="identical.integer64_+3A_x">x</code>, <code id="identical.integer64_+3A_y">y</code></td>
<td>
<p>Atomic vector of class 'integer64'</p>
</td></tr>
<tr><td><code id="identical.integer64_+3A_num.eq">num.eq</code>, <code id="identical.integer64_+3A_single.na">single.NA</code>, <code id="identical.integer64_+3A_attrib.as.set">attrib.as.set</code>, <code id="identical.integer64_+3A_ignore.bytecode">ignore.bytecode</code>, <code id="identical.integer64_+3A_ignore.environment">ignore.environment</code>, <code id="identical.integer64_+3A_ignore.srcref">ignore.srcref</code></td>
<td>
<p>See <code><a href="base.html#topic+identical">identical()</a></code>.</p>
</td></tr>
<tr><td><code id="identical.integer64_+3A_...">...</code></td>
<td>
<p>Passed on to <code>identical()</code>. Only <code style="white-space: pre;">&#8288;extptr.as.ref=&#8288;</code> is available as of R 4.4.1,
and then only for versions of R &gt;= 4.2.0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is simply a wrapper to <code><a href="base.html#topic+identical">identical()</a></code> with default arguments
<code style="white-space: pre;">&#8288;num.eq = FALSE, single.NA = FALSE&#8288;</code>.
</p>


<h3>Value</h3>

<p>A single logical value, <code>TRUE</code> or <code>FALSE</code>, never <code>NA</code> and never
anything other than a single value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic++3D+3D.integer64">==.integer64</a></code> <code><a href="base.html#topic+identical">identical()</a></code> <code><a href="#topic+integer64">integer64()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  i64 &lt;- as.double(NA); class(i64) &lt;- "integer64"
  identical(i64-1, i64+1)
  identical.integer64(i64-1, i64+1)
</code></pre>

<hr>
<h2 id='is.sorted.integer64'>Small cache access methods</h2><span id='topic+is.sorted.integer64'></span><span id='topic+na.count.integer64'></span><span id='topic+nvalid.integer64'></span><span id='topic+nunique.integer64'></span><span id='topic+nties.integer64'></span>

<h3>Description</h3>

<p>These methods are packaged here for methods in packages <code>bit64</code> and <code>ff</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'integer64'
na.count(x, ...)

## S3 method for class 'integer64'
nvalid(x, ...)

## S3 method for class 'integer64'
is.sorted(x, ...)

## S3 method for class 'integer64'
nunique(x, ...)

## S3 method for class 'integer64'
nties(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.sorted.integer64_+3A_x">x</code></td>
<td>
<p>some object</p>
</td></tr>
<tr><td><code id="is.sorted.integer64_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All these functions benefit from a <code><a href="#topic+sortcache">sortcache()</a></code>, <code><a href="#topic+ordercache">ordercache()</a></code> or
<code><a href="#topic+sortordercache">sortordercache()</a></code>. <code>na.count()</code>, <code>nvalid()</code> and <code>nunique()</code> also
benefit from a <code><a href="#topic+hashcache">hashcache()</a></code>.
</p>


<h3>Value</h3>

<p><code>is.sorted</code> returns a logical scalar, the other methods return an integer scalar.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>na.count(integer64)</code>: returns the number of <code>NA</code>s
</p>
</li>
<li> <p><code>nvalid(integer64)</code>: returns the number of valid data points,
usually <code><a href="base.html#topic+length">length()</a></code> minus <code>na.count</code>.
</p>
</li>
<li> <p><code>is.sorted(integer64)</code>: checks for sortedness of <code>x</code> (NAs sorted first)
</p>
</li>
<li> <p><code>nunique(integer64)</code>: returns the number of unique values
</p>
</li>
<li> <p><code>nties(integer64)</code>: returns the number of tied values.
</p>
</li></ul>


<h3>Note</h3>

<p>If a <code><a href="#topic+cache">cache()</a></code> exists but the desired value is not cached, then these
functions will store their result in the cache. We do not consider this
a relevant side-effect, since these small cache results do not have a
relevant memory footprint.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cache">cache()</a></code> for caching functions and <code><a href="#topic+sortordercache">sortordercache()</a></code> for functions creating big caches
</p>


<h3>Examples</h3>

<pre><code class='language-R'> x &lt;- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
 length(x)
 na.count(x)
 nvalid(x)
 nunique(x)
 nties(x)
 table.integer64(x)
 x

</code></pre>

<hr>
<h2 id='keypos'>Extract Positions in redundant dimension table</h2><span id='topic+keypos'></span><span id='topic+keypos.integer64'></span>

<h3>Description</h3>

<p><code>keypos</code> returns the positions of the (fact table) elements that participate
in their sorted unique subset (dimension table)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keypos(x, ...)

## S3 method for class 'integer64'
keypos(x, method = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="keypos_+3A_x">x</code></td>
<td>
<p>a vector or a data frame or an array or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="keypos_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="keypos_+3A_method">method</code></td>
<td>
<p>NULL for automatic method selection or a suitable low-level
method, see details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NAs are sorted first in the dimension table, see <code><a href="#topic+ramorder.integer64">ramorder.integer64()</a></code>.
</p>
<p>This function automatically chooses from several low-level functions
considering the size of <code>x</code> and the availability of a cache.
</p>
<p>Suitable methods are
</p>

<ul>
<li> <p><code><a href="#topic+sortorderkey">sortorderkey</a></code> (fast ordering)
</p>
</li>
<li> <p><code><a href="#topic+orderkey">orderkey</a></code> (memory saving ordering).
</p>
</li></ul>



<h3>Value</h3>

<p>an integer vector of the same length as <code>x</code> containing positions
relative to <code>sort(unique(x), na.last=FALSE)</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unique.integer64">unique.integer64()</a></code> for the unique subset and <code><a href="#topic+match.integer64">match.integer64()</a></code>
for finding positions in a different vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
keypos(x)

stopifnot(identical(keypos(x),  match.integer64(x, sort(unique(x), na.last=FALSE))))
</code></pre>

<hr>
<h2 id='match.integer64'>64-bit integer matching</h2><span id='topic+match.integer64'></span><span id='topic++25in+25.integer64'></span>

<h3>Description</h3>

<p><code>match</code> returns a vector of the positions of (first) matches of its first
argument in its second.
<code>%in%</code> is a more intuitive interface as a binary operator, which returns a
logical vector indicating if there is a match or not for its left operand.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'integer64'
match(x, table, nomatch = NA_integer_, nunique = NULL, method = NULL, ...)

## S3 method for class 'integer64'
x %in% table, ...
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="match.integer64_+3A_x">x</code></td>
<td>
<p>integer64 vector: the values to be matched, optionally carrying a
cache created with <code><a href="#topic+hashcache">hashcache()</a></code></p>
</td></tr>
<tr><td><code id="match.integer64_+3A_table">table</code></td>
<td>
<p>integer64 vector: the values to be matched against, optionally
carrying a cache created with <code><a href="#topic+hashcache">hashcache()</a></code> or <code><a href="#topic+sortordercache">sortordercache()</a></code></p>
</td></tr>
<tr><td><code id="match.integer64_+3A_nomatch">nomatch</code></td>
<td>
<p>the value to be returned in the case when no match is found.
Note that it is coerced to integer.</p>
</td></tr>
<tr><td><code id="match.integer64_+3A_nunique">nunique</code></td>
<td>
<p>NULL or the number of unique values of table (including NA).
Providing <code>nunique</code> can speed-up matching when <code>table</code> has no cache. Note
that a wrong nunique can cause undefined behaviour up to a crash.</p>
</td></tr>
<tr><td><code id="match.integer64_+3A_method">method</code></td>
<td>
<p>NULL for automatic method selection or a suitable low-level
method, see details</p>
</td></tr>
<tr><td><code id="match.integer64_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions automatically choose from several low-level functions
considering the size of <code>x</code> and <code>table</code> and the availability of caches.
</p>
<p>Suitable methods for <code style="white-space: pre;">&#8288;%in%.integer64&#8288;</code> are
</p>

<ul>
<li> <p><code><a href="#topic+hashpos">hashpos</a></code> (hash table lookup)
</p>
</li>
<li> <p><code><a href="#topic+hashrev">hashrev</a></code> (reverse lookup)
</p>
</li>
<li> <p><code><a href="#topic+sortorderpos">sortorderpos</a></code> (fast ordering)
</p>
</li>
<li> <p><code><a href="#topic+orderpos">orderpos</a></code> (memory saving ordering).
</p>
</li></ul>

<p>Suitable methods for <code>match.integer64</code> are
</p>

<ul>
<li> <p><code><a href="#topic+hashfin">hashfin</a></code> (hash table lookup)
</p>
</li>
<li> <p><code><a href="#topic+hashrin">hashrin</a></code> (reverse lookup)
</p>
</li>
<li> <p><code><a href="#topic+sortfin">sortfin</a></code> (fast sorting)
</p>
</li>
<li> <p><code><a href="#topic+orderfin">orderfin</a></code> (memory saving ordering).
</p>
</li></ul>



<h3>Value</h3>

<p>A vector of the same length as <code>x</code>.
</p>
<p><code>match</code>: An integer vector giving the position in <code>table</code> of
the first match if there is a match, otherwise <code>nomatch</code>.
</p>
<p>If <code>x[i]</code> is found to equal <code>table[j]</code> then the value
returned in the <code>i</code>-th position of the return value is <code>j</code>,
for the smallest possible <code>j</code>.  If no match is found, the value
is <code>nomatch</code>.
</p>
<p><code>%in%</code>: A logical vector, indicating if a match was located for
each element of <code>x</code>: thus the values are <code>TRUE</code> or
<code>FALSE</code> and never <code>NA</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+match">match()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.integer64(c(NA, 0:9), 32)
table &lt;- as.integer64(c(1:9, NA))
match.integer64(x, table)
"%in%.integer64"(x, table)

x &lt;- as.integer64(sample(c(rep(NA, 9), 0:9), 32, TRUE))
table &lt;- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
stopifnot(identical(match.integer64(x, table), match(as.integer(x), as.integer(table))))
stopifnot(identical("%in%.integer64"(x, table), as.integer(x) %in% as.integer(table)))

## Not run: 
    message("check when reverse hash-lookup beats standard hash-lookup")
    e &lt;- 4:24
    timx &lt;- timy &lt;- matrix(NA, length(e), length(e), dimnames=list(e,e))
    for (iy in seq_along(e))
    for (ix in 1:iy){
        nx &lt;- 2^e[ix]
        ny &lt;- 2^e[iy]
        x &lt;- as.integer64(sample(ny, nx, FALSE))
        y &lt;- as.integer64(sample(ny, ny, FALSE))
        #hashfun(x, bits=as.integer(5))
        timx[ix,iy] &lt;- repeat.time({
        hx &lt;- hashmap(x)
        py &lt;- hashrev(hx, y)
        })[3]
        timy[ix,iy] &lt;- repeat.time({
        hy &lt;- hashmap(y)
        px &lt;- hashpos(hy, x)
        })[3]
        #identical(px, py)
        print(round(timx[1:iy,1:iy]/timy[1:iy,1:iy], 2), na.print="")
    }

    message("explore best low-level method given size of x and table")
    B1 &lt;- 1:27
    B2 &lt;- 1:27
    tim &lt;- array(NA, dim=c(length(B1), length(B2), 5)
 , dimnames=list(B1, B2, c("hashpos","hashrev","sortpos1","sortpos2","sortpos3")))
    for (i1 in B1)
    for (i2 in B2)
    {
      b1 &lt;- B1[i1]
      b2 &lt;- B1[i2]
      n1 &lt;- 2^b1
      n2 &lt;- 2^b2
      x1 &lt;- as.integer64(c(sample(n2, n1-1, TRUE), NA))
      x2 &lt;- as.integer64(c(sample(n2, n2-1, TRUE), NA))
      tim[i1,i2,1] &lt;- repeat.time({h &lt;- hashmap(x2);hashpos(h, x1);rm(h)})[3]
      tim[i1,i2,2] &lt;- repeat.time({h &lt;- hashmap(x1);hashrev(h, x2);rm(h)})[3]
      s &lt;- clone(x2); o &lt;- seq_along(s); ramsortorder(s, o)
      tim[i1,i2,3] &lt;- repeat.time(sortorderpos(s, o, x1, method=1))[3]
      tim[i1,i2,4] &lt;- repeat.time(sortorderpos(s, o, x1, method=2))[3]
      tim[i1,i2,5] &lt;- repeat.time(sortorderpos(s, o, x1, method=3))[3]
      rm(s,o)
      print(apply(tim, 1:2, function(ti)if(any(is.na(ti)))NA else which.min(ti)))
    }

## End(Not run)
</code></pre>

<hr>
<h2 id='matrix64'>Working with integer64 arrays and matrices</h2><span id='topic+matrix64'></span><span id='topic+colSums'></span><span id='topic+colSums.default'></span><span id='topic+colSums.integer64'></span><span id='topic+rowSums'></span><span id='topic+rowSums.default'></span><span id='topic+rowSums.integer64'></span><span id='topic+aperm.integer64'></span>

<h3>Description</h3>

<p>These functions and methods facilitate working with integer64
objects stored in matrices. As ever, the primary motivation
for having tailor-made functions here is that R's methods
often receive input from bit64 and treat the vectors as doubles,
leading to unexpected and/or incorrect results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colSums(x, na.rm = FALSE, dims = 1L)

## Default S3 method:
colSums(x, na.rm = FALSE, dims = 1L)

## S3 method for class 'integer64'
colSums(x, na.rm = FALSE, dims = 1L)

rowSums(x, na.rm = FALSE, dims = 1L)

## Default S3 method:
rowSums(x, na.rm = FALSE, dims = 1L)

## S3 method for class 'integer64'
rowSums(x, na.rm = FALSE, dims = 1L)

## S3 method for class 'integer64'
aperm(a, perm, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="matrix64_+3A_x">x</code></td>
<td>
<p>An array of integer64 numbers.</p>
</td></tr>
<tr><td><code id="matrix64_+3A_na.rm">na.rm</code>, <code id="matrix64_+3A_dims">dims</code></td>
<td>
<p>Same interpretation as in <code><a href="#topic+colSums">colSums()</a></code>.</p>
</td></tr>
<tr><td><code id="matrix64_+3A_a">a</code>, <code id="matrix64_+3A_perm">perm</code></td>
<td>
<p>Passed on to <code><a href="base.html#topic+aperm">aperm()</a></code>.</p>
</td></tr>
<tr><td><code id="matrix64_+3A_...">...</code></td>
<td>
<p>Passed on to subsequent methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As of now, the <code>colSums()</code> and <code>rowSums()</code> methods are implemented
as wrappers around equivalent <code>apply()</code> approaches, because
re-using the default routine (and then applying integer64 to the
result) does not work for objects with missing elements. Ideally
this would eventually get its own dedicated C routine mimicking
that of <code>colSums()</code> for integers; feature requests and PRs welcome.
</p>
<p><code>aperm()</code> is required for <code>apply()</code> to work, in general, otherwise
<code>FUN</code> gets applied to a class-stripped version of the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A = as.integer64(1:6)
dim(A) = 3:2

colSums(A)
rowSums(A)
aperm(A, 2:1)
</code></pre>

<hr>
<h2 id='optimizer64.data'>Results of performance measurement on a Core i7 Lenovo T410 8 GB RAM under Windows 7 64bit</h2><span id='topic+optimizer64.data'></span>

<h3>Description</h3>

<p>These are the results of calling <code><a href="#topic+optimizer64">optimizer64()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(optimizer64.data)
</code></pre>


<h3>Format</h3>

<p>The format is:
</p>
<div class="sourceCode"><pre>List of 16
 $ : num [1:9, 1:3] 0 0 1.63 0.00114 2.44 ...
  ..- attr(*, "dimnames")=List of 2
  .. ..$ : chr [1:9] "match" "match.64" "hashpos" "hashrev" ...
  .. ..$ : chr [1:3] "prep" "both" "use"
 $ : num [1:10, 1:3] 0 0 0 1.62 0.00114 ...
  ..- attr(*, "dimnames")=List of 2
  .. ..$ : chr [1:10] "%in%" "match.64" "%in%.64" "hashfin" ...
  .. ..$ : chr [1:3] "prep" "both" "use"
 $ : num [1:10, 1:3] 0 0 0.00105 0.00313 0.00313 ...
  ..- attr(*, "dimnames")=List of 2
  .. ..$ : chr [1:10] "duplicated" "duplicated.64" "hashdup" "sortorderdup1" ...
  .. ..$ : chr [1:3] "prep" "both" "use"
 $ : num [1:15, 1:3] 0 0 0 0.00104 0.00104 ...
  ..- attr(*, "dimnames")=List of 2
  .. ..$ : chr [1:15] "unique" "unique.64" "hashmapuni" "hashuni" ...
  .. ..$ : chr [1:3] "prep" "both" "use"
 $ : num [1:14, 1:3] 0 0 0 0.000992 0.000992 ...
  ..- attr(*, "dimnames")=List of 2
  .. ..$ : chr [1:14] "unique" "unipos.64" "hashmapupo" "hashupo" ...
  .. ..$ : chr [1:3] "prep" "both" "use"
 $ : num [1:13, 1:3] 0 0 0 0 0.000419 ...
  ..- attr(*, "dimnames")=List of 2
  .. ..$ : chr [1:13] "tabulate" "table" "table.64" "hashmaptab" ...
  .. ..$ : chr [1:3] "prep" "both" "use"
 $ : num [1:7, 1:3] 0 0 0 0.00236 0.00714 ...
  ..- attr(*, "dimnames")=List of 2
  .. ..$ : chr [1:7] "rank" "rank.keep" "rank.64" "sortorderrnk" ...
  .. ..$ : chr [1:3] "prep" "both" "use"
 $ : num [1:6, 1:3] 0 0 0.00189 0.00714 0 ...
  ..- attr(*, "dimnames")=List of 2
  .. ..$ : chr [1:6] "quantile" "quantile.64" "sortqtl" "orderqtl" ...
  .. ..$ : chr [1:3] "prep" "both" "use"
 $ : num [1:9, 1:3] 0 0 0.00105 1.17 0 ...
  ..- attr(*, "dimnames")=List of 2
  .. ..$ : chr [1:9] "match" "match.64" "hashpos" "hashrev" ...
  .. ..$ : chr [1:3] "prep" "both" "use"
 $ : num [1:10, 1:3] 0 0 0 0.00104 1.18 ...
  ..- attr(*, "dimnames")=List of 2
  .. ..$ : chr [1:10] "%in%" "match.64" "%in%.64" "hashfin" ...
  .. ..$ : chr [1:3] "prep" "both" "use"
 $ : num [1:10, 1:3] 0 0 1.64 2.48 2.48 ...
  ..- attr(*, "dimnames")=List of 2
  .. ..$ : chr [1:10] "duplicated" "duplicated.64" "hashdup" "sortorderdup1" ...
  .. ..$ : chr [1:3] "prep" "both" "use"
 $ : num [1:15, 1:3] 0 0 0 1.64 1.64 ...
  ..- attr(*, "dimnames")=List of 2
  .. ..$ : chr [1:15] "unique" "unique.64" "hashmapuni" "hashuni" ...
  .. ..$ : chr [1:3] "prep" "both" "use"
 $ : num [1:14, 1:3] 0 0 0 1.62 1.62 ...
  ..- attr(*, "dimnames")=List of 2
  .. ..$ : chr [1:14] "unique" "unipos.64" "hashmapupo" "hashupo" ...
  .. ..$ : chr [1:3] "prep" "both" "use"
 $ : num [1:13, 1:3] 0 0 0 0 0.32 ...
  ..- attr(*, "dimnames")=List of 2
  .. ..$ : chr [1:13] "tabulate" "table" "table.64" "hashmaptab" ...
  .. ..$ : chr [1:3] "prep" "both" "use"
 $ : num [1:7, 1:3] 0 0 0 2.96 10.69 ...
  ..- attr(*, "dimnames")=List of 2
  .. ..$ : chr [1:7] "rank" "rank.keep" "rank.64" "sortorderrnk" ...
  .. ..$ : chr [1:3] "prep" "both" "use"
 $ : num [1:6, 1:3] 0 0 1.62 10.61 0 ...
  ..- attr(*, "dimnames")=List of 2
  .. ..$ : chr [1:6] "quantile" "quantile.64" "sortqtl" "orderqtl" ...
  .. ..$ : chr [1:3] "prep" "both" "use"
 - attr(*, "dim")= int [1:2] 8 2
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:8] "match" "%in%" "duplicated" "unique" ...
  ..$ : chr [1:2] "65536" "33554432"
</pre></div>


<h3>Examples</h3>

<pre><code class='language-R'>data(optimizer64.data)
print(optimizer64.data)
oldpar &lt;- par(no.readonly = TRUE)
par(mfrow=c(2,1))
par(cex=0.7)
for (i in 1:nrow(optimizer64.data)){
 for (j in 1:2){
   tim &lt;- optimizer64.data[[i,j]]
  barplot(t(tim))
  if (rownames(optimizer64.data)[i]=="match")
   title(paste("match", colnames(optimizer64.data)[j], "in", colnames(optimizer64.data)[3-j]))
  else if (rownames(optimizer64.data)[i]=="%in%")
   title(paste(colnames(optimizer64.data)[j], "%in%", colnames(optimizer64.data)[3-j]))
  else
   title(paste(rownames(optimizer64.data)[i], colnames(optimizer64.data)[j]))
 }
}
par(mfrow=c(1,1))

</code></pre>

<hr>
<h2 id='plusclass'>integer64: Maintaining S3 class attribute</h2><span id='topic+plusclass'></span><span id='topic+minusclass'></span>

<h3>Description</h3>

<p>Maintaining integer64 S3 class attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minusclass(class, whichclass)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plusclass_+3A_class">class</code></td>
<td>
<p>NULL or a character vector of class attributes</p>
</td></tr>
<tr><td><code id="plusclass_+3A_whichclass">whichclass</code></td>
<td>
<p>the (single) class name to add or remove from the class vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL or a character vector of class attributes
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+oldClass">oldClass()</a></code> <code><a href="#topic+integer64">integer64()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plusclass("inheritingclass","integer64")
  minusclass(c("inheritingclass","integer64"), "integer64")
</code></pre>

<hr>
<h2 id='prank'>(P)ercent (Rank)s</h2><span id='topic+prank'></span><span id='topic+prank.integer64'></span>

<h3>Description</h3>

<p>Function <code>prank.integer64</code>  projects the values <code style="white-space: pre;">&#8288;[min..max]&#8288;</code> via ranks
<code style="white-space: pre;">&#8288;[1..n]&#8288;</code> to <code style="white-space: pre;">&#8288;[0..1]&#8288;</code>.
<code><a href="#topic+qtile.integer64">qtile.integer64()</a></code> is the inverse function of 'prank.integer64' and
projects <code style="white-space: pre;">&#8288;[0..1]&#8288;</code> to <code style="white-space: pre;">&#8288;[min..max]&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prank(x, ...)

## S3 method for class 'integer64'
prank(x, method = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prank_+3A_x">x</code></td>
<td>
<p>a integer64 vector</p>
</td></tr>
<tr><td><code id="prank_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="prank_+3A_method">method</code></td>
<td>
<p>NULL for automatic method selection or a suitable low-level
method, see details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>prank.integer64</code> is based on <code><a href="#topic+rank.integer64">rank.integer64()</a></code>.
</p>


<h3>Value</h3>

<p><code>prank</code> returns a numeric vector of the same length as <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rank.integer64">rank.integer64()</a></code> for simple ranks and <code><a href="#topic+qtile">qtile()</a></code> for the
inverse function quantiles.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
prank(x)

x &lt;- x[!is.na(x)]
stopifnot(identical(x,  unname(qtile(x, probs=prank(x)))))
</code></pre>

<hr>
<h2 id='qtile'>(Q)uan(Tile)s</h2><span id='topic+qtile'></span><span id='topic+qtile.integer64'></span><span id='topic+quantile.integer64'></span><span id='topic+median.integer64'></span><span id='topic+mean.integer64'></span><span id='topic+summary.integer64'></span>

<h3>Description</h3>

<p>Function <code><a href="#topic+prank.integer64">prank.integer64()</a></code>  projects the values <code style="white-space: pre;">&#8288;[min..max]&#8288;</code> via ranks
<code style="white-space: pre;">&#8288;[1..n]&#8288;</code> to <code style="white-space: pre;">&#8288;[0..1]&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qtile(x, probs = seq(0, 1, 0.25), ...)

## S3 method for class 'integer64'
qtile(x, probs = seq(0, 1, 0.25), names = TRUE, method = NULL, ...)

## S3 method for class 'integer64'
quantile(
  x,
  probs = seq(0, 1, 0.25),
  na.rm = FALSE,
  names = TRUE,
  type = 0L,
  ...
)

## S3 method for class 'integer64'
median(x, na.rm = FALSE, ...)

## S3 method for class 'integer64'
mean(x, na.rm = FALSE, ...)

## S3 method for class 'integer64'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qtile_+3A_x">x</code></td>
<td>
<p>a integer64 vector</p>
</td></tr>
<tr><td><code id="qtile_+3A_probs">probs</code></td>
<td>
<p>numeric vector of probabilities with values in <code style="white-space: pre;">&#8288;[0,1]&#8288;</code> - possibly containing <code>NA</code>s</p>
</td></tr>
<tr><td><code id="qtile_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="qtile_+3A_names">names</code></td>
<td>
<p>logical; if <code>TRUE</code>, the result has a <code>names</code> attribute. Set to <code>FALSE</code> for speedup with many probs.</p>
</td></tr>
<tr><td><code id="qtile_+3A_method">method</code></td>
<td>
<p>NULL for automatic method selection or a suitable low-level method, see details</p>
</td></tr>
<tr><td><code id="qtile_+3A_na.rm">na.rm</code></td>
<td>
<p>logical; if <code>TRUE</code>, any <code>NA</code> and <code>NaN</code>'s are removed from
<code>x</code> before the quantiles are computed.</p>
</td></tr>
<tr><td><code id="qtile_+3A_type">type</code></td>
<td>
<p>an integer selecting the quantile algorithm, currently only
0 is supported, see details</p>
</td></tr>
<tr><td><code id="qtile_+3A_object">object</code></td>
<td>
<p>a integer64 vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>qtile.ineger64</code> is the inverse function of 'prank.integer64' and projects
<code style="white-space: pre;">&#8288;[0..1]&#8288;</code> to <code style="white-space: pre;">&#8288;[min..max]&#8288;</code>.
</p>
<p>Functions <code>quantile.integer64</code> with <code>type=0</code> and <code>median.integer64</code> are
convenience wrappers to <code>qtile</code>.
</p>
<p>Function <code>qtile</code> behaves very similar to <code>quantile.default</code> with <code>type=1</code>
in that it only returns existing values, it is mostly symmetric but it is
using 'round' rather than 'floor'.
</p>
<p>Note that this implies that <code>median.integer64</code> does not interpolate for even
number of values (interpolation would create values that could not be
represented as 64-bit integers).
</p>
<p>This function automatically chooses from several low-level functions
considering the size of <code>x</code> and the availability of a cache.
</p>
<p>Suitable methods are
</p>

<ul>
<li> <p><code><a href="#topic+sortqtl">sortqtl</a></code> (fast sorting)
</p>
</li>
<li> <p><code><a href="#topic+orderqtl">orderqtl</a></code> (memory saving ordering).
</p>
</li></ul>



<h3>Value</h3>

<p><code>prank</code> returns a numeric vector of the same length as <code>x</code>.
</p>
<p><code>qtile</code> returns a vector with elements from <code>x</code>
at the relative positions specified by <code>probs</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rank.integer64">rank.integer64()</a></code> for simple ranks and <code><a href="stats.html#topic+quantile">quantile()</a></code> for quantiles.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
qtile(x, probs=seq(0, 1, 0.25))
quantile(x, probs=seq(0, 1, 0.25), na.rm=TRUE)
median(x, na.rm=TRUE)
summary(x)

x &lt;- x[!is.na(x)]
stopifnot(identical(x,  unname(qtile(x, probs=prank(x)))))
</code></pre>

<hr>
<h2 id='ramsort.integer64'>Low-level intger64 methods for in-RAM sorting and ordering</h2><span id='topic+ramsort.integer64'></span><span id='topic+shellsort.integer64'></span><span id='topic+shellsortorder.integer64'></span><span id='topic+shellorder.integer64'></span><span id='topic+mergesort.integer64'></span><span id='topic+mergeorder.integer64'></span><span id='topic+mergesortorder.integer64'></span><span id='topic+quicksort.integer64'></span><span id='topic+quicksortorder.integer64'></span><span id='topic+quickorder.integer64'></span><span id='topic+radixsort.integer64'></span><span id='topic+radixsortorder.integer64'></span><span id='topic+radixorder.integer64'></span><span id='topic+ramsortorder.integer64'></span><span id='topic+ramorder.integer64'></span>

<h3>Description</h3>

<p>Fast low-level methods for sorting and ordering. The <code>..sortorder</code>
methods do sorting and ordering at once, which requires more RAM
than ordering but is (almost) as fast as as sorting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'integer64'
shellsort(x, has.na = TRUE, na.last = FALSE, decreasing = FALSE, ...)

## S3 method for class 'integer64'
shellsortorder(x, i, has.na = TRUE, na.last = FALSE, decreasing = FALSE, ...)

## S3 method for class 'integer64'
shellorder(x, i, has.na = TRUE, na.last = FALSE, decreasing = FALSE, ...)

## S3 method for class 'integer64'
mergesort(x, has.na = TRUE, na.last = FALSE, decreasing = FALSE, ...)

## S3 method for class 'integer64'
mergeorder(x, i, has.na = TRUE, na.last = FALSE, decreasing = FALSE, ...)

## S3 method for class 'integer64'
mergesortorder(x, i, has.na = TRUE, na.last = FALSE, decreasing = FALSE, ...)

## S3 method for class 'integer64'
quicksort(
  x,
  has.na = TRUE,
  na.last = FALSE,
  decreasing = FALSE,
  restlevel = floor(1.5 * log2(length(x))),
  ...
)

## S3 method for class 'integer64'
quicksortorder(
  x,
  i,
  has.na = TRUE,
  na.last = FALSE,
  decreasing = FALSE,
  restlevel = floor(1.5 * log2(length(x))),
  ...
)

## S3 method for class 'integer64'
quickorder(
  x,
  i,
  has.na = TRUE,
  na.last = FALSE,
  decreasing = FALSE,
  restlevel = floor(1.5 * log2(length(x))),
  ...
)

## S3 method for class 'integer64'
radixsort(
  x,
  has.na = TRUE,
  na.last = FALSE,
  decreasing = FALSE,
  radixbits = 8L,
  ...
)

## S3 method for class 'integer64'
radixsortorder(
  x,
  i,
  has.na = TRUE,
  na.last = FALSE,
  decreasing = FALSE,
  radixbits = 8L,
  ...
)

## S3 method for class 'integer64'
radixorder(
  x,
  i,
  has.na = TRUE,
  na.last = FALSE,
  decreasing = FALSE,
  radixbits = 8L,
  ...
)

## S3 method for class 'integer64'
ramsort(
  x,
  has.na = TRUE,
  na.last = FALSE,
  decreasing = FALSE,
  stable = TRUE,
  optimize = c("time", "memory"),
  VERBOSE = FALSE,
  ...
)

## S3 method for class 'integer64'
ramsortorder(
  x,
  i,
  has.na = TRUE,
  na.last = FALSE,
  decreasing = FALSE,
  stable = TRUE,
  optimize = c("time", "memory"),
  VERBOSE = FALSE,
  ...
)

## S3 method for class 'integer64'
ramorder(
  x,
  i,
  has.na = TRUE,
  na.last = FALSE,
  decreasing = FALSE,
  stable = TRUE,
  optimize = c("time", "memory"),
  VERBOSE = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ramsort.integer64_+3A_x">x</code></td>
<td>
<p>a vector to be sorted by <code><a href="#topic+ramsort.integer64">ramsort.integer64()</a></code> and
<code><a href="#topic+ramsortorder.integer64">ramsortorder.integer64()</a></code>, i.e. the output of  <code><a href="#topic+sort.integer64">sort.integer64()</a></code></p>
</td></tr>
<tr><td><code id="ramsort.integer64_+3A_has.na">has.na</code></td>
<td>
<p>boolean scalar defining whether the input vector might contain
<code>NA</code>s. If we know we don't have NAs, this may speed-up. <em>Note</em> that you
risk a crash if there are unexpected <code>NA</code>s with <code>has.na=FALSE</code></p>
</td></tr>
<tr><td><code id="ramsort.integer64_+3A_na.last">na.last</code></td>
<td>
<p>boolean scalar telling ramsort whether to sort <code>NA</code>s last
or first. <em>Note</em> that 'boolean' means that there is no third option <code>NA</code>
as in <code><a href="base.html#topic+sort">sort()</a></code></p>
</td></tr>
<tr><td><code id="ramsort.integer64_+3A_decreasing">decreasing</code></td>
<td>
<p>boolean scalar telling ramsort whether to sort increasing
or decreasing</p>
</td></tr>
<tr><td><code id="ramsort.integer64_+3A_...">...</code></td>
<td>
<p>further arguments, passed from generics, ignored in methods</p>
</td></tr>
<tr><td><code id="ramsort.integer64_+3A_i">i</code></td>
<td>
<p>integer positions to be modified by <code><a href="#topic+ramorder.integer64">ramorder.integer64()</a></code> and
<code><a href="#topic+ramsortorder.integer64">ramsortorder.integer64()</a></code>, default is 1:n, in this case the output is
similar to <code><a href="#topic+order.integer64">order.integer64()</a></code></p>
</td></tr>
<tr><td><code id="ramsort.integer64_+3A_restlevel">restlevel</code></td>
<td>
<p>number of remaining recursionlevels before <code>quicksort</code>
switches from recursing to <code>shellsort</code></p>
</td></tr>
<tr><td><code id="ramsort.integer64_+3A_radixbits">radixbits</code></td>
<td>
<p>size of radix in bits</p>
</td></tr>
<tr><td><code id="ramsort.integer64_+3A_stable">stable</code></td>
<td>
<p>boolean scalar defining whether stable sorting is needed.
Allowing non-stable may speed-up.</p>
</td></tr>
<tr><td><code id="ramsort.integer64_+3A_optimize">optimize</code></td>
<td>
<p>by default ramsort optimizes for 'time' which requires more
RAM, set to 'memory' to minimize RAM requirements and sacrifice speed</p>
</td></tr>
<tr><td><code id="ramsort.integer64_+3A_verbose">VERBOSE</code></td>
<td>
<p>cat some info about chosen method</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="bit.html#topic+Sorting">bit::ramsort()</a></code>
</p>


<h3>Value</h3>

<p>These functions return the number of <code>NAs</code> found or assumed
during sorting
</p>


<h3>Note</h3>

<p>Note that these methods purposely violate the functional programming
paradigm: they are called for the side-effect of changing some of
their arguments. The <code>sort</code>-methods change <code>x</code>, the <code>order</code>-methods
change <code>i</code>, and the <code>sortoder</code>-methods change both <code>x</code> and <code>i</code>
</p>


<h3>See Also</h3>

<p><code><a href="bit.html#topic+Sorting">bit::ramsort()</a></code> for the generic, <code>ramsort.default</code> for the methods
provided by package ff, <code><a href="#topic+sort.integer64">sort.integer64()</a></code> for the sort interface and
<code><a href="#topic+sortcache">sortcache()</a></code> for caching the work of sorting
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
  x
  message("ramsort example")
  s &lt;- clone(x)
  ramsort(s)
  message("s has been changed in-place - whether or not ramsort uses an in-place algorithm")
  s
  message("ramorder example")
  s &lt;- clone(x)
  o &lt;- seq_along(s)
  ramorder(s, o)
  message("o has been changed in-place - s remains unchanged")
  s
  o
  s[o]
  message("ramsortorder example")
  o &lt;- seq_along(s)
  ramsortorder(s, o)
  message("s and o have both been changed in-place - this is much faster")
  s
  o
</code></pre>

<hr>
<h2 id='rank.integer64'>Sample Ranks from integer64</h2><span id='topic+rank.integer64'></span>

<h3>Description</h3>

<p>Returns the sample ranks of the values in a vector.  Ties (i.e., equal
values) are averaged and missing values propagated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'integer64'
rank(x, method = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rank.integer64_+3A_x">x</code></td>
<td>
<p>a integer64 vector</p>
</td></tr>
<tr><td><code id="rank.integer64_+3A_method">method</code></td>
<td>
<p>NULL for automatic method selection or a suitable low-level
method, see details</p>
</td></tr>
<tr><td><code id="rank.integer64_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function automatically chooses from several low-level functions
considering the size of <code>x</code> and the availability of a cache.
Suitable methods are
</p>

<ul>
<li> <p><code><a href="#topic+sortorderrnk">sortorderrnk()</a></code> (fast ordering)
</p>
</li>
<li> <p><code><a href="#topic+orderrnk">orderrnk()</a></code> (memory saving ordering).
</p>
</li></ul>



<h3>Value</h3>

<p>A numeric vector of the same length as <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+order.integer64">order.integer64()</a></code>, <code><a href="#topic+rank">rank()</a></code> and <code><a href="#topic+prank">prank()</a></code> for percent rank.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
rank.integer64(x)

stopifnot(identical(rank.integer64(x),  rank(as.integer(x)
, na.last="keep", ties.method = "average")))

</code></pre>

<hr>
<h2 id='rep.integer64'>Replicate elements of integer64 vectors</h2><span id='topic+rep.integer64'></span>

<h3>Description</h3>

<p>Replicate elements of integer64 vectors
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rep.integer64_+3A_x">x</code></td>
<td>
<p>a vector of 'integer64' to be replicated</p>
</td></tr>
<tr><td><code id="rep.integer64_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="base.html#topic+NextMethod">NextMethod()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="base.html#topic+rep">rep()</a></code> returns a integer64 vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+c.integer64">c.integer64()</a></code> <code><a href="#topic+rep.integer64">rep.integer64()</a></code>
<code><a href="#topic+as.data.frame.integer64">as.data.frame.integer64()</a></code> <code><a href="#topic+integer64">integer64()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  rep(as.integer64(1:2), 6)
  rep(as.integer64(1:2), c(6,6))
  rep(as.integer64(1:2), length.out=6)
</code></pre>

<hr>
<h2 id='runif64'>integer64: random numbers</h2><span id='topic+runif64'></span>

<h3>Description</h3>

<p>Create uniform random 64-bit integers within defined range
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runif64(
  n,
  min = lim.integer64()[1L],
  max = lim.integer64()[2L],
  replace = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="runif64_+3A_n">n</code></td>
<td>
<p>length of return vector</p>
</td></tr>
<tr><td><code id="runif64_+3A_min">min</code></td>
<td>
<p>lower inclusive bound for random numbers</p>
</td></tr>
<tr><td><code id="runif64_+3A_max">max</code></td>
<td>
<p>upper inclusive bound for random numbers</p>
</td></tr>
<tr><td><code id="runif64_+3A_replace">replace</code></td>
<td>
<p>set to FALSE for sampleing from a finite pool, see <code><a href="base.html#topic+sample">sample()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each random integer we call R's internal C interface <code>unif_rand()</code> twice.
Each call is mapped to 2^32 unsigned integers. The two 32-bit patterns are
concatenated to form the new integer64. This process is repeated until the
result is not a <code>NA_INTEGER64_</code>.
</p>


<h3>Value</h3>

<p>a integer64 vector
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+runif">runif()</a></code>, <code><a href="#topic+hashfun">hashfun()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  runif64(12)
  runif64(12, -16, 16)
  runif64(12, 0, as.integer64(2^60)-1)  # not 2^60-1 !
  var(runif(1e4))
  var(as.double(runif64(1e4, 0, 2^40))/2^40)  # ~ = 1/12 = .08333

  table(sample(16, replace=FALSE))
  table(runif64(16, 1, 16, replace=FALSE))
  table(sample(16, replace=TRUE))
  table(runif64(16, 1, 16, replace=TRUE))

</code></pre>

<hr>
<h2 id='seq.integer64'>integer64: Sequence Generation</h2><span id='topic+seq.integer64'></span>

<h3>Description</h3>

<p>Generating sequence of integer64 values
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seq.integer64_+3A_from">from</code></td>
<td>
<p>integer64 scalar (in order to dispatch the integer64 method of <code><a href="base.html#topic+seq">seq()</a></code></p>
</td></tr>
<tr><td><code id="seq.integer64_+3A_to">to</code></td>
<td>
<p>scalar</p>
</td></tr>
<tr><td><code id="seq.integer64_+3A_by">by</code></td>
<td>
<p>scalar</p>
</td></tr>
<tr><td><code id="seq.integer64_+3A_length.out">length.out</code></td>
<td>
<p>scalar</p>
</td></tr>
<tr><td><code id="seq.integer64_+3A_along.with">along.with</code></td>
<td>
<p>scalar</p>
</td></tr>
<tr><td><code id="seq.integer64_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>seq.integer64</code> does coerce its arguments 'from', 'to' and 'by' to <code>integer64</code>.
If not provided, the argument 'by' is automatically determined as <code>+1</code> or <code>-1</code>,
but the size of 'by' is not calculated as in <code><a href="base.html#topic+seq">seq()</a></code> (because this might result
in a non-integer value).
</p>


<h3>Value</h3>

<p>an integer64 vector with the generated sequence
</p>


<h3>Note</h3>

<p>In base R <code><a href="#topic++3A">:</a></code> currently is not generic and does not dispatch, see section
&quot;Limitations inherited from Base R&quot; in <code><a href="#topic+integer64">integer64()</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+c.integer64">c.integer64()</a></code> <code><a href="#topic+rep.integer64">rep.integer64()</a></code>
<code><a href="#topic+as.data.frame.integer64">as.data.frame.integer64()</a></code> <code><a href="#topic+integer64">integer64()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # colon not activated: as.integer64(1):12
  seq(as.integer64(1), 12, 2)
  seq(as.integer64(1), by=2, length.out=6)
</code></pre>

<hr>
<h2 id='sort.integer64'>High-level intger64 methods for sorting and ordering</h2><span id='topic+sort.integer64'></span><span id='topic+order.integer64'></span>

<h3>Description</h3>

<p>Fast high-level methods for sorting and ordering. These are wrappers to
<code><a href="#topic+ramsort.integer64">ramsort.integer64()</a></code> and friends and do not modify their arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'integer64'
sort(
  x,
  decreasing = FALSE,
  has.na = TRUE,
  na.last = TRUE,
  stable = TRUE,
  optimize = c("time", "memory"),
  VERBOSE = FALSE,
  ...
)

## S3 method for class 'integer64'
order(
  ...,
  na.last = TRUE,
  decreasing = FALSE,
  has.na = TRUE,
  stable = TRUE,
  optimize = c("time", "memory"),
  VERBOSE = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sort.integer64_+3A_x">x</code></td>
<td>
<p>a vector to be sorted by <code><a href="#topic+ramsort.integer64">ramsort.integer64()</a></code> and
<code><a href="#topic+ramsortorder.integer64">ramsortorder.integer64()</a></code>, i.e. the output of  <code><a href="#topic+sort.integer64">sort.integer64()</a></code></p>
</td></tr>
<tr><td><code id="sort.integer64_+3A_decreasing">decreasing</code></td>
<td>
<p>boolean scalar telling ramsort whether to sort
increasing or decreasing</p>
</td></tr>
<tr><td><code id="sort.integer64_+3A_has.na">has.na</code></td>
<td>
<p>boolean scalar defining whether the input vector might
contain <code>NA</code>s. If we know we don't have NAs, this may speed-up. <em>Note</em>
that you risk a crash if there are unexpected <code>NA</code>s with <code>has.na=FALSE</code></p>
</td></tr>
<tr><td><code id="sort.integer64_+3A_na.last">na.last</code></td>
<td>
<p>boolean scalar telling ramsort whether to sort <code>NA</code>s last
or first. <em>Note</em> that 'boolean' means that there is no third option
<code>NA</code> as in <code><a href="base.html#topic+sort">sort()</a></code></p>
</td></tr>
<tr><td><code id="sort.integer64_+3A_stable">stable</code></td>
<td>
<p>boolean scalar defining whether stable sorting is needed.
Allowing non-stable may speed-up.</p>
</td></tr>
<tr><td><code id="sort.integer64_+3A_optimize">optimize</code></td>
<td>
<p>by default ramsort optimizes for 'time' which requires
more RAM, set to 'memory' to minimize RAM requirements and sacrifice speed</p>
</td></tr>
<tr><td><code id="sort.integer64_+3A_verbose">VERBOSE</code></td>
<td>
<p>cat some info about chosen method</p>
</td></tr>
<tr><td><code id="sort.integer64_+3A_...">...</code></td>
<td>
<p>further arguments, passed from generics, ignored in methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>see <code><a href="base.html#topic+sort">sort()</a></code> and <code><a href="#topic+order">order()</a></code>
</p>


<h3>Value</h3>

<p><code>sort</code> returns the sorted vector and <code>vector</code> returns the order positions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sort.integer64">sort()</a></code>, <code><a href="#topic+sortcache">sortcache()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
  x
  sort(x)
  message("the following has default optimize='time' which is faster but requires more RAM
, this calls 'ramorder'")
  order.integer64(x)
  message("slower with less RAM, this calls 'ramsortorder'")
  order.integer64(x, optimize="memory")
</code></pre>

<hr>
<h2 id='sortnut'>Searching and other uses of sorting for 64bit integers</h2><span id='topic+sortnut'></span><span id='topic+sortnut.integer64'></span><span id='topic+ordernut'></span><span id='topic+ordernut.integer64'></span><span id='topic+sortfin'></span><span id='topic+sortfin.integer64'></span><span id='topic+orderfin'></span><span id='topic+orderfin.integer64'></span><span id='topic+orderpos'></span><span id='topic+orderpos.integer64'></span><span id='topic+sortorderpos'></span><span id='topic+sortorderpos.integer64'></span><span id='topic+orderdup'></span><span id='topic+orderdup.integer64'></span><span id='topic+sortorderdup'></span><span id='topic+sortorderdup.integer64'></span><span id='topic+sortuni'></span><span id='topic+sortuni.integer64'></span><span id='topic+orderuni'></span><span id='topic+orderuni.integer64'></span><span id='topic+sortorderuni'></span><span id='topic+sortorderuni.integer64'></span><span id='topic+orderupo'></span><span id='topic+orderupo.integer64'></span><span id='topic+sortorderupo'></span><span id='topic+sortorderupo.integer64'></span><span id='topic+ordertie'></span><span id='topic+ordertie.integer64'></span><span id='topic+sortordertie'></span><span id='topic+sortordertie.integer64'></span><span id='topic+sorttab'></span><span id='topic+sorttab.integer64'></span><span id='topic+ordertab'></span><span id='topic+ordertab.integer64'></span><span id='topic+sortordertab'></span><span id='topic+sortordertab.integer64'></span><span id='topic+orderkey'></span><span id='topic+orderkey.integer64'></span><span id='topic+sortorderkey'></span><span id='topic+sortorderkey.integer64'></span><span id='topic+orderrnk'></span><span id='topic+orderrnk.integer64'></span><span id='topic+sortorderrnk'></span><span id='topic+sortorderrnk.integer64'></span><span id='topic+sortqtl'></span><span id='topic+sortqtl.integer64'></span><span id='topic+orderqtl'></span><span id='topic+orderqtl.integer64'></span>

<h3>Description</h3>

<p>This is roughly an implementation of hash functionality but based on sorting
instead on a hashmap. Since sorting is more informative than hashing we
can do some more interesting things.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sortnut(sorted, ...)

## S3 method for class 'integer64'
sortnut(sorted, ...)

ordernut(table, order, ...)

## S3 method for class 'integer64'
ordernut(table, order, ...)

sortfin(sorted, x, ...)

## S3 method for class 'integer64'
sortfin(sorted, x, method = NULL, ...)

orderfin(table, order, x, ...)

## S3 method for class 'integer64'
orderfin(table, order, x, method = NULL, ...)

orderpos(table, order, x, ...)

## S3 method for class 'integer64'
orderpos(table, order, x, nomatch = NA, method = NULL, ...)

sortorderpos(sorted, order, x, ...)

## S3 method for class 'integer64'
sortorderpos(sorted, order, x, nomatch = NA, method = NULL, ...)

orderdup(table, order, ...)

## S3 method for class 'integer64'
orderdup(table, order, method = NULL, ...)

sortorderdup(sorted, order, ...)

## S3 method for class 'integer64'
sortorderdup(sorted, order, method = NULL, ...)

sortuni(sorted, nunique, ...)

## S3 method for class 'integer64'
sortuni(sorted, nunique, ...)

orderuni(table, order, nunique, ...)

## S3 method for class 'integer64'
orderuni(table, order, nunique, keep.order = FALSE, ...)

sortorderuni(table, sorted, order, nunique, ...)

## S3 method for class 'integer64'
sortorderuni(table, sorted, order, nunique, ...)

orderupo(table, order, nunique, ...)

## S3 method for class 'integer64'
orderupo(table, order, nunique, keep.order = FALSE, ...)

sortorderupo(sorted, order, nunique, keep.order = FALSE, ...)

## S3 method for class 'integer64'
sortorderupo(sorted, order, nunique, keep.order = FALSE, ...)

ordertie(table, order, nties, ...)

## S3 method for class 'integer64'
ordertie(table, order, nties, ...)

sortordertie(sorted, order, nties, ...)

## S3 method for class 'integer64'
sortordertie(sorted, order, nties, ...)

sorttab(sorted, nunique, ...)

## S3 method for class 'integer64'
sorttab(sorted, nunique, ...)

ordertab(table, order, nunique, ...)

## S3 method for class 'integer64'
ordertab(table, order, nunique, denormalize = FALSE, keep.order = FALSE, ...)

sortordertab(sorted, order, ...)

## S3 method for class 'integer64'
sortordertab(sorted, order, denormalize = FALSE, ...)

orderkey(table, order, na.skip.num = 0L, ...)

## S3 method for class 'integer64'
orderkey(table, order, na.skip.num = 0L, ...)

sortorderkey(sorted, order, na.skip.num = 0L, ...)

## S3 method for class 'integer64'
sortorderkey(sorted, order, na.skip.num = 0L, ...)

orderrnk(table, order, na.count, ...)

## S3 method for class 'integer64'
orderrnk(table, order, na.count, ...)

sortorderrnk(sorted, order, na.count, ...)

## S3 method for class 'integer64'
sortorderrnk(sorted, order, na.count, ...)

sortqtl(sorted, na.count, probs, ...)

## S3 method for class 'integer64'
sortqtl(sorted, na.count, probs, ...)

orderqtl(table, order, na.count, probs, ...)

## S3 method for class 'integer64'
orderqtl(table, order, na.count, probs, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sortnut_+3A_sorted">sorted</code></td>
<td>
<p>a sorted <code><a href="#topic+integer64">integer64</a></code> vector</p>
</td></tr>
<tr><td><code id="sortnut_+3A_...">...</code></td>
<td>
<p>further arguments, passed from generics, ignored in methods</p>
</td></tr>
<tr><td><code id="sortnut_+3A_table">table</code></td>
<td>
<p>the original data with original order under the sorted vector</p>
</td></tr>
<tr><td><code id="sortnut_+3A_order">order</code></td>
<td>
<p>an <code><a href="base.html#topic+integer">integer</a></code> order vector that turns 'table' into 'sorted'</p>
</td></tr>
<tr><td><code id="sortnut_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+integer64">integer64</a></code> vector</p>
</td></tr>
<tr><td><code id="sortnut_+3A_method">method</code></td>
<td>
<p>see Details</p>
</td></tr>
<tr><td><code id="sortnut_+3A_nomatch">nomatch</code></td>
<td>
<p>the value to be returned if an element is not found in the hashmap</p>
</td></tr>
<tr><td><code id="sortnut_+3A_nunique">nunique</code></td>
<td>
<p>number of unique elements, usually we get this from cache
or call <code>sortnut</code> or <code>ordernut</code></p>
</td></tr>
<tr><td><code id="sortnut_+3A_keep.order">keep.order</code></td>
<td>
<p>determines order of results and speed: <code>FALSE</code> (the default)
is faster and returns in sorted order, <code>TRUE</code> returns in the order of first
appearance in the original data, but this requires extra work</p>
</td></tr>
<tr><td><code id="sortnut_+3A_nties">nties</code></td>
<td>
<p>number of tied values, usually we get this from cache or
call <code>sortnut</code> or <code>ordernut</code></p>
</td></tr>
<tr><td><code id="sortnut_+3A_denormalize">denormalize</code></td>
<td>
<p>FALSE returns counts of unique values, TRUE returns each
value with its counts</p>
</td></tr>
<tr><td><code id="sortnut_+3A_na.skip.num">na.skip.num</code></td>
<td>
<p>0 or the number of <code>NA</code>s. With 0, <code>NA</code>s are coded with 1L,
with the number of <code>NA</code>s, these are coded with <code>NA</code></p>
</td></tr>
<tr><td><code id="sortnut_+3A_na.count">na.count</code></td>
<td>
<p>the number of <code>NA</code>s, needed for this low-level function algorithm</p>
</td></tr>
<tr><td><code id="sortnut_+3A_probs">probs</code></td>
<td>
<p>vector of probabilities in <code style="white-space: pre;">&#8288;[0..1]&#8288;</code> for which we seek quantiles</p>
</td></tr>
</table>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: right;">
   <strong>sortfun</strong> </td><td style="text-align: right;"> <strong>orderfun</strong> </td><td style="text-align: right;"> <strong>sortorderfun</strong> </td><td style="text-align: right;"> <strong>see also</strong> </td><td style="text-align: left;"> <strong>description</strong> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>sortnut</code> </td><td style="text-align: right;"> <code>ordernut</code> </td><td style="text-align: right;">  </td><td style="text-align: right;">  </td><td style="text-align: left;"> return number of tied and of unique values </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>sortfin</code> </td><td style="text-align: right;"> <code>orderfin</code> </td><td style="text-align: right;">  </td><td style="text-align: right;"> <code><a href="#topic++25in+25.integer64">%in%.integer64</a></code> </td><td style="text-align: left;"> return logical whether <code>x</code> is in <code>table</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
    </td><td style="text-align: right;"> <code>orderpos</code> </td><td style="text-align: right;"> <code>sortorderpos</code> </td><td style="text-align: right;"> <code><a href="#topic+match.integer64">match()</a></code> </td><td style="text-align: left;"> return positions of <code>x</code> in <code>table</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
    </td><td style="text-align: right;"> <code>orderdup</code> </td><td style="text-align: right;"> <code>sortorderdup</code> </td><td style="text-align: right;"> <code><a href="#topic+duplicated.integer64">duplicated()</a></code> </td><td style="text-align: left;"> return logical whether values are duplicated </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>sortuni</code> </td><td style="text-align: right;"> <code>orderuni</code> </td><td style="text-align: right;"> <code>sortorderuni</code> </td><td style="text-align: right;"> <code><a href="#topic+unique.integer64">unique()</a></code> </td><td style="text-align: left;"> return unique values (=dimensiontable) </td>
</tr>
<tr>
 <td style="text-align: right;">
    </td><td style="text-align: right;"> <code>orderupo</code> </td><td style="text-align: right;"> <code>sortorderupo</code> </td><td style="text-align: right;"> <code><a href="#topic+unique.integer64">unique()</a></code> </td><td style="text-align: left;"> return positions of unique values </td>
</tr>
<tr>
 <td style="text-align: right;">
    </td><td style="text-align: right;"> <code>ordertie</code> </td><td style="text-align: right;"> <code>sortordertie</code> </td><td style="text-align: right;">  </td><td style="text-align: left;"> return positions of tied values </td>
</tr>
<tr>
 <td style="text-align: right;">
    </td><td style="text-align: right;"> <code>orderkey</code> </td><td style="text-align: right;"> <code>sortorderkey</code> </td><td style="text-align: right;">  </td><td style="text-align: left;"> positions of values in vector of unique values (match in dimensiontable) </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>sorttab</code> </td><td style="text-align: right;"> <code>ordertab</code> </td><td style="text-align: right;"> <code>sortordertab</code> </td><td style="text-align: right;"> <code><a href="#topic+table.integer64">table()</a></code> </td><td style="text-align: left;"> tabulate frequency of values </td>
</tr>
<tr>
 <td style="text-align: right;">
    </td><td style="text-align: right;"> <code>orderrnk</code> </td><td style="text-align: right;"> <code>sortorderrnk</code> </td><td style="text-align: right;">  </td><td style="text-align: left;"> rank averaging ties </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>sortqtl</code> </td><td style="text-align: right;"> <code>orderqtl</code> </td><td style="text-align: right;">  </td><td style="text-align: right;">  </td><td style="text-align: left;"> return quantiles given probabilities </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

<p>The functions <code>sortfin</code>, <code>orderfin</code>, <code>orderpos</code> and <code>sortorderpos</code> each
offer three algorithms for finding <code>x</code> in <code>table</code>.
</p>
<p>With <code>method=1L</code> each value of <code>x</code> is searched independently using
<em>binary search</em>, this is fastest for small <code>table</code>s.
</p>
<p>With <code>method=2L</code> the values of <code>x</code> are first sorted and then searched using
<em>doubly exponential search</em>, this is the best allround method.
</p>
<p>With <code>method=3L</code> the values of <code>x</code> are first sorted and then searched using
simple merging, this is the fastest method if <code>table</code> is huge and <code>x</code> has
similar size and distribution of values.
</p>
<p>With <code>method=NULL</code> the functions use a heuristic to determine the fastest
algorithm.
</p>
<p>The functions <code>orderdup</code> and <code>sortorderdup</code> each offer two algorithms for
setting the truth values in the return vector.
</p>
<p>With <code>method=1L</code> the return values are set directly which causes random
write access on a possibly large return vector.
</p>
<p>With <code>method=2L</code> the return values are first set in a smaller bit-vector &ndash;
random access limited to a smaller memory region &ndash; and finally written
sequentially to the logical output  vector.
</p>
<p>With <code>method=NULL</code> the functions use a heuristic to determine the fastest
algorithm.
</p>


<h3>Value</h3>

<p>see details
</p>


<h3>See Also</h3>

<p><code><a href="#topic+match.integer64">match()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> message("check the code of 'optimizer64' for examples:")
 print(optimizer64)
</code></pre>

<hr>
<h2 id='sum.integer64'>Summary functions for integer64 vectors</h2><span id='topic+sum.integer64'></span><span id='topic+any.integer64'></span><span id='topic+all.integer64'></span><span id='topic+prod.integer64'></span><span id='topic+min.integer64'></span><span id='topic+max.integer64'></span><span id='topic+range.integer64'></span><span id='topic+lim.integer64'></span>

<h3>Description</h3>

<p>Summary functions for integer64 vectors. Function 'range' without arguments
returns the smallest and largest value of the 'integer64' class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'integer64'
any(..., na.rm = FALSE)

## S3 method for class 'integer64'
all(..., na.rm = FALSE)

## S3 method for class 'integer64'
sum(..., na.rm = FALSE)

## S3 method for class 'integer64'
prod(..., na.rm = FALSE)

## S3 method for class 'integer64'
min(..., na.rm = FALSE)

## S3 method for class 'integer64'
max(..., na.rm = FALSE)

## S3 method for class 'integer64'
range(..., na.rm = FALSE, finite = FALSE)

lim.integer64()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sum.integer64_+3A_...">...</code></td>
<td>
<p>atomic vectors of class 'integer64'</p>
</td></tr>
<tr><td><code id="sum.integer64_+3A_na.rm">na.rm</code></td>
<td>
<p>logical scalar indicating whether to ignore NAs</p>
</td></tr>
<tr><td><code id="sum.integer64_+3A_finite">finite</code></td>
<td>
<p>logical scalar indicating whether to ignore NAs (just for
compatibility with <code><a href="base.html#topic+range.default">range.default()</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The numerical summary methods always return <code>integer64</code>. Therefore the
methods for <code>min</code>,<code>max</code> and <code>range</code> do not return <code style="white-space: pre;">&#8288;+Inf,-Inf&#8288;</code> on empty
arguments, but <code style="white-space: pre;">&#8288;+9223372036854775807, -9223372036854775807&#8288;</code> (in this sequence).
The same is true if only  <code>NA</code>s are submitted with argument <code>na.rm=TRUE</code>.
</p>
<p><code>lim.integer64</code> returns these limits in proper order
<code style="white-space: pre;">&#8288;-9223372036854775807, +9223372036854775807&#8288;</code> and without a <code><a href="base.html#topic+warning">warning()</a></code>.
</p>


<h3>Value</h3>

<p><code><a href="base.html#topic+all">all()</a></code> and <code><a href="base.html#topic+any">any()</a></code> return a logical scalar
</p>
<p><code><a href="base.html#topic+range">range()</a></code> returns a integer64 vector with two elements
</p>
<p><code><a href="base.html#topic+min">min()</a></code>, <code><a href="base.html#topic+max">max()</a></code>, <code><a href="base.html#topic+sum">sum()</a></code> and <code><a href="base.html#topic+prod">prod()</a></code> return a integer64 scalar
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mean.integer64">mean.integer64()</a></code> <code><a href="#topic+cumsum.integer64">cumsum.integer64()</a></code> <code><a href="#topic+integer64">integer64()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  lim.integer64()
  range(as.integer64(1:12))
</code></pre>

<hr>
<h2 id='table.integer64'>Cross Tabulation and Table Creation for integer64</h2><span id='topic+table.integer64'></span>

<h3>Description</h3>

<p><code>table.integer64</code> uses the cross-classifying integer64 vectors to build a
contingency table of the counts at each combination of vector values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table.integer64(
  ...,
  return = c("table", "data.frame", "list"),
  order = c("values", "counts"),
  nunique = NULL,
  method = NULL,
  dnn = list.names(...),
  deparse.level = 1L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="table.integer64_+3A_...">...</code></td>
<td>
<p>one or more objects which can be interpreted as factors
(including character strings), or a list (or data frame) whose
components can be so interpreted.  (For <code>as.table</code> and <code>as.data.frame</code>,
arguments passed to specific methods.)</p>
</td></tr>
<tr><td><code id="table.integer64_+3A_return">return</code></td>
<td>
<p>choose the return format, see details</p>
</td></tr>
<tr><td><code id="table.integer64_+3A_order">order</code></td>
<td>
<p>By default results are created sorted by &quot;values&quot;, or by &quot;counts&quot;</p>
</td></tr>
<tr><td><code id="table.integer64_+3A_nunique">nunique</code></td>
<td>
<p>NULL or the number of unique values of table (including NA).
Providing <code>nunique</code> can speed-up matching when <code>table</code> has no cache. Note
that a wrong <code>nunique</code> can cause undefined behaviour up to a crash.</p>
</td></tr>
<tr><td><code id="table.integer64_+3A_method">method</code></td>
<td>
<p>NULL for automatic method selection or a suitable low-level
method, see details</p>
</td></tr>
<tr><td><code id="table.integer64_+3A_dnn">dnn</code></td>
<td>
<p>the names to be given to the dimensions in the result
(the <em>dimnames names</em>).</p>
</td></tr>
<tr><td><code id="table.integer64_+3A_deparse.level">deparse.level</code></td>
<td>
<p>controls how the default <code>dnn</code> is constructed. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function automatically chooses from several low-level functions considering
the size of <code>x</code> and the availability of a cache.
</p>
<p>Suitable methods are
</p>

<ul>
<li> <p><code><a href="#topic+hashmaptab">hashmaptab</a></code> (simultaneously creating and using a hashmap)
</p>
</li>
<li> <p><code><a href="#topic+hashtab">hashtab</a></code> (first creating a hashmap then using it)
</p>
</li>
<li> <p><code><a href="#topic+sortordertab">sortordertab</a></code> (fast ordering)
</p>
</li>
<li> <p><code><a href="#topic+ordertab">ordertab</a></code> (memory saving ordering).
</p>
</li></ul>

<p>If the argument <code>dnn</code> is not supplied, the internal function
<code>list.names</code> is called to compute the 'dimname names'.  If the
arguments in <code>...</code> are named, those names are used.  For the
remaining arguments, <code>deparse.level = 0</code> gives an empty name,
<code>deparse.level = 1</code> uses the supplied argument if it is a symbol,
and <code>deparse.level = 2</code> will deparse the argument.
</p>
<p>Arguments <code>exclude</code>, <code>useNA</code>, are not supported, i.e. <code>NA</code>s are always tabulated,
and, different from <code><a href="base.html#topic+table">table()</a></code> they are sorted first if <code>order="values"</code>.
</p>


<h3>Value</h3>

<p>By default (with <code>return="table"</code>) <code><a href="base.html#topic+table">table()</a></code> returns a
<em>contingency table</em>, an object of class <code>"table"</code>, an array of integer values.
Note that unlike S the result is always an array, a 1D array if one factor is
given. Note also that for multidimensional arrays this is a <em>dense</em> return
structure which can dramatically increase RAM requirements (for large arrays
with high mutual information, i.e. many possible input combinations of which
only few occur) and that <code><a href="base.html#topic+table">table()</a></code> is limited to <code>2^31</code> possible combinations
(e.g. two input vectors with 46340 unique values only). Finally note that the
tabulated values or value-combinations are represented as <code>dimnames</code> and that
the implied conversion of values to strings can cause <em>severe</em> performance
problems since each string needs to be integrated into R's global string cache.
</p>
<p>You can use the other <code style="white-space: pre;">&#8288;return=&#8288;</code> options to cope with these problems, the potential
combination limit is increased from <code>2^31</code> to <code>2^63</code> with these options, RAM is
only required for observed combinations and string conversion is avoided.
</p>
<p>With <code>return="data.frame"</code> you get a <em>dense</em> representation as a <code><a href="base.html#topic+data.frame">data.frame()</a></code>
(like that resulting from <code>as.data.frame(table(...))</code>) where only observed
combinations are listed (each as a data.frame row) with the corresponding
frequency counts (the latter as component named by <code>responseName</code>). This is
the inverse of <code><a href="stats.html#topic+xtabs">xtabs()</a></code>.
</p>
<p>With <code>return="list"</code> you also get a <em>dense</em> representation as a simple
<code><a href="base.html#topic+list">list()</a></code> with components
</p>

<ul>
<li> <p><code>values</code> a integer64 vector of the technically tabulated values, for 1D this
is the tabulated values themselves, for kD these are the values representing
the potential combinations of input values
</p>
</li>
<li> <p><code>counts</code> the frequency counts
</p>
</li>
<li> <p><code>dims</code> only for kD: a list with the vectors of the unique values of the
input dimensions
</p>
</li></ul>



<h3>Note</h3>

<p>Note that by using <code><a href="#topic+as.integer64.factor">as.integer64.factor()</a></code> we can also input
factors into <code>table.integer64</code> &ndash; only the <code><a href="base.html#topic+levels">levels()</a></code> get lost.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+table">table()</a></code> for more info on the standard version coping with Base R's
data types, <code><a href="base.html#topic+tabulate">tabulate()</a></code> which can faster tabulate <code><a href="base.html#topic+integer">integer</a></code>s with a limited
range <code style="white-space: pre;">&#8288;[1L .. nL not too big]&#8288;</code>, <code><a href="#topic+unique.integer64">unique.integer64()</a></code> for the unique values
without counting them and <code><a href="#topic+unipos.integer64">unipos.integer64()</a></code> for the positions of the unique values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>message("pure integer64 examples")
x &lt;- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
y &lt;- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
z &lt;- sample(c(rep(NA, 9), letters), 32, TRUE)
table.integer64(x)
table.integer64(x, order="counts")
table.integer64(x, y)
table.integer64(x, y, return="data.frame")

message("via as.integer64.factor we can use 'table.integer64' also for factors")
table.integer64(x, as.integer64(as.factor(z)))
</code></pre>

<hr>
<h2 id='tiepos'>Extract Positions of Tied Elements</h2><span id='topic+tiepos'></span><span id='topic+tiepos.integer64'></span>

<h3>Description</h3>

<p><code>tiepos</code> returns the positions of those elements that participate in ties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tiepos(x, ...)

## S3 method for class 'integer64'
tiepos(x, nties = NULL, method = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tiepos_+3A_x">x</code></td>
<td>
<p>a vector or a data frame or an array or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="tiepos_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="tiepos_+3A_nties">nties</code></td>
<td>
<p>NULL or the number of tied values (including NA). Providing
<code>nties</code> can speed-up when <code>x</code> has no cache. Note that a wrong nties can
cause undefined behaviour up to a crash.</p>
</td></tr>
<tr><td><code id="tiepos_+3A_method">method</code></td>
<td>
<p>NULL for automatic method selection or a suitable low-level
method, see details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function automatically chooses from several low-level functions
considering the size of <code>x</code> and the availability of a cache.
</p>
<p>Suitable methods are
</p>

<ul>
<li> <p><code><a href="#topic+sortordertie">sortordertie</a></code> (fast ordering)
</p>
</li>
<li> <p><code><a href="#topic+ordertie">ordertie</a></code> (memory saving ordering).
</p>
</li></ul>



<h3>Value</h3>

<p>an integer vector of positions
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rank.integer64">rank.integer64()</a></code> for possibly tied ranks and <code><a href="#topic+unipos.integer64">unipos.integer64()</a></code>
for positions of unique values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
tiepos(x)

stopifnot(identical(tiepos(x),  (1:length(x))[duplicated(x) | rev(duplicated(rev(x)))]))
</code></pre>

<hr>
<h2 id='unipos'>Extract Positions of Unique Elements</h2><span id='topic+unipos'></span><span id='topic+unipos.integer64'></span>

<h3>Description</h3>

<p><code>unipos</code> returns the positions of those elements returned by <code><a href="base.html#topic+unique">unique()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unipos(x, incomparables = FALSE, order = c("original", "values", "any"), ...)

## S3 method for class 'integer64'
unipos(
  x,
  incomparables = FALSE,
  order = c("original", "values", "any"),
  nunique = NULL,
  method = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unipos_+3A_x">x</code></td>
<td>
<p>a vector or a data frame or an array or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="unipos_+3A_incomparables">incomparables</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="unipos_+3A_order">order</code></td>
<td>
<p>The order in which positions of unique values will be returned,
see details</p>
</td></tr>
<tr><td><code id="unipos_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="unipos_+3A_nunique">nunique</code></td>
<td>
<p>NULL or the number of unique values (including NA). Providing
<code>nunique</code> can speed-up when <code>x</code> has no cache. Note that a wrong <code>nunique</code>
can cause undefined behaviour up to a crash.</p>
</td></tr>
<tr><td><code id="unipos_+3A_method">method</code></td>
<td>
<p>NULL for automatic method selection or a suitable low-level
method, see details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function automatically chooses from several low-level functions
considering the size of <code>x</code> and the availability of a cache.
</p>
<p>Suitable methods are
</p>

<ul>
<li> <p><code><a href="#topic+hashmapupo">hashmapupo</a></code> (simultaneously creating and using a hashmap)
</p>
</li>
<li> <p><code><a href="#topic+hashupo">hashupo</a></code> (first creating a hashmap then using it)
</p>
</li>
<li> <p><code><a href="#topic+sortorderupo">sortorderupo</a></code> (fast ordering)
</p>
</li>
<li> <p><code><a href="#topic+orderupo">orderupo</a></code> (memory saving ordering).
</p>
</li></ul>

<p>The default <code>order="original"</code> collects unique values in the order of
the first appearance in <code>x</code> like in <code><a href="base.html#topic+unique">unique()</a></code>, this costs extra processing.
<code>order="values"</code> collects unique values in sorted order like in <code><a href="base.html#topic+table">table()</a></code>,
this costs extra processing with the hash methods but comes for free.
<code>order="any"</code> collects unique values in undefined order, possibly faster.
For hash methods this will be a quasi random order, for sort methods this
will be sorted order.
</p>


<h3>Value</h3>

<p>an integer vector of positions
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unique.integer64">unique.integer64()</a></code> for unique values and <code><a href="#topic+match.integer64">match.integer64()</a></code>
for general matching.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
unipos(x)
unipos(x, order="values")

stopifnot(identical(unipos(x),  (1:length(x))[!duplicated(x)]))
stopifnot(identical(unipos(x),  match.integer64(unique(x), x)))
stopifnot(identical(unipos(x, order="values"),  match.integer64(unique(x, order="values"), x)))
stopifnot(identical(unique(x),  x[unipos(x)]))
stopifnot(identical(unique(x, order="values"),  x[unipos(x, order="values")]))

</code></pre>

<hr>
<h2 id='unique.integer64'>Extract Unique Elements from integer64</h2><span id='topic+unique.integer64'></span>

<h3>Description</h3>

<p><code>unique</code> returns a vector like <code>x</code> but with duplicate elements/rows removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'integer64'
unique(
  x,
  incomparables = FALSE,
  order = c("original", "values", "any"),
  nunique = NULL,
  method = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unique.integer64_+3A_x">x</code></td>
<td>
<p>a vector or a data frame or an array or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="unique.integer64_+3A_incomparables">incomparables</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="unique.integer64_+3A_order">order</code></td>
<td>
<p>The order in which unique values will be returned, see details</p>
</td></tr>
<tr><td><code id="unique.integer64_+3A_nunique">nunique</code></td>
<td>
<p>NULL or the number of unique values (including NA). Providing
<code>nunique</code> can speed-up matching when <code>x</code> has no cache. Note that a wrong
'nunique&ldquo; can cause undefined behaviour up to a crash.</p>
</td></tr>
<tr><td><code id="unique.integer64_+3A_method">method</code></td>
<td>
<p>NULL for automatic method selection or a suitable low-level
method, see details</p>
</td></tr>
<tr><td><code id="unique.integer64_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function automatically chooses from several low-level functions
considering the size of <code>x</code> and the availability of a cache.
</p>
<p>Suitable methods are
</p>

<ul>
<li> <p><code><a href="#topic+hashmapuni">hashmapuni</a></code> (simultaneously creating and using a hashmap)
</p>
</li>
<li> <p><code><a href="#topic+hashuni">hashuni</a></code> (first creating a hashmap then using it)
</p>
</li>
<li> <p><code><a href="#topic+sortuni">sortuni</a></code> (fast sorting for sorted order only)
</p>
</li>
<li> <p><code><a href="#topic+sortorderuni">sortorderuni</a></code> (fast ordering for original order only)
</p>
</li>
<li> <p><code><a href="#topic+orderuni">orderuni</a></code> (memory saving ordering).
</p>
</li></ul>

<p>The default <code>order="original"</code> returns unique values in the order of the
first appearance in <code>x</code> like in <code><a href="base.html#topic+unique">unique()</a></code>, this costs extra processing.
<code>order="values"</code> returns unique values in sorted order like in <code><a href="base.html#topic+table">table()</a></code>,
this costs extra processing with the hash methods but comes for free.
<code>order="any"</code> returns unique values in undefined order, possibly faster.
For hash methods this will be a quasi random order, for sort methods this
will be sorted order.
</p>


<h3>Value</h3>

<p>For a vector, an object of the same type of <code>x</code>, but with only
one copy of each duplicated element.  No attributes are copied (so
the result has no names).
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+unique">unique()</a></code> for the generic, <code><a href="#topic+unipos">unipos()</a></code> which gives the indices
of the unique elements and <code><a href="#topic+table.integer64">table.integer64()</a></code> which gives frequencies
of the unique elements.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
unique(x)
unique(x, order="values")

stopifnot(identical(unique(x),  x[!duplicated(x)]))
stopifnot(identical(unique(x),  as.integer64(unique(as.integer(x)))))
stopifnot(identical(unique(x, order="values")
,  as.integer64(sort(unique(as.integer(x)), na.last=FALSE))))

</code></pre>

<hr>
<h2 id='xor.integer64'>Binary operators for integer64 vectors</h2><span id='topic+xor.integer64'></span><span id='topic+binattr'></span><span id='topic++2B.integer64'></span><span id='topic+-.integer64'></span><span id='topic++25+2F+25.integer64'></span><span id='topic++25+25.integer64'></span><span id='topic++2A.integer64'></span><span id='topic++5E.integer64'></span><span id='topic++2F.integer64'></span><span id='topic++3D+3D.integer64'></span><span id='topic++21+3D.integer64'></span><span id='topic++3C.integer64'></span><span id='topic++3C+3D.integer64'></span><span id='topic++3E.integer64'></span><span id='topic++3E+3D.integer64'></span><span id='topic++26.integer64'></span><span id='topic++7C.integer64'></span>

<h3>Description</h3>

<p>Binary operators for integer64 vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binattr(e1, e2)

## S3 method for class 'integer64'
e1 + e2

## S3 method for class 'integer64'
e1 - e2

## S3 method for class 'integer64'
e1 %/% e2

## S3 method for class 'integer64'
e1 %% e2

## S3 method for class 'integer64'
e1 * e2

## S3 method for class 'integer64'
e1 ^ e2

## S3 method for class 'integer64'
e1 / e2

## S3 method for class 'integer64'
e1 == e2

## S3 method for class 'integer64'
e1 != e2

## S3 method for class 'integer64'
e1 &lt; e2

## S3 method for class 'integer64'
e1 &lt;= e2

## S3 method for class 'integer64'
e1 &gt; e2

## S3 method for class 'integer64'
e1 &gt;= e2

## S3 method for class 'integer64'
e1 &amp; e2

## S3 method for class 'integer64'
e1 | e2

## S3 method for class 'integer64'
xor(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xor.integer64_+3A_e1">e1</code></td>
<td>
<p>an atomic vector of class 'integer64'</p>
</td></tr>
<tr><td><code id="xor.integer64_+3A_e2">e2</code></td>
<td>
<p>an atomic vector of class 'integer64'</p>
</td></tr>
<tr><td><code id="xor.integer64_+3A_x">x</code></td>
<td>
<p>an atomic vector of class 'integer64'</p>
</td></tr>
<tr><td><code id="xor.integer64_+3A_y">y</code></td>
<td>
<p>an atomic vector of class 'integer64'</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="base.html#topic++26">&amp;</a></code>, <code><a href="base.html#topic++7C">|</a></code>, <code><a href="base.html#topic+xor">xor()</a></code>, <code><a href="base.html#topic++21+3D">!=</a></code>, <code><a href="base.html#topic++3D+3D">==</a></code>,
<code><a href="base.html#topic++3C">&lt;</a></code>, <code><a href="base.html#topic++3C+3D">&lt;=</a></code>, <code><a href="base.html#topic++3E">&gt;</a></code>, <code><a href="base.html#topic++3E+3D">&gt;=</a></code> return a logical vector
</p>
<p><code><a href="base.html#topic++5E">^</a></code> and <code><a href="base.html#topic++2F">/</a></code> return a double vector
</p>
<p><code><a href="base.html#topic++2B">+</a></code>, <code><a href="base.html#topic+-">-</a></code>, <code><a href="base.html#topic++2A">*</a></code>, <code><a href="base.html#topic++25+2F+25">%/%</a></code>, <code><a href="base.html#topic++25+25">%%</a></code>
return a vector of class 'integer64'
</p>


<h3>See Also</h3>

<p><code><a href="#topic+format.integer64">format.integer64()</a></code> <code><a href="#topic+integer64">integer64()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  as.integer64(1:12) - 1
  options(integer64_semantics="new")
  d &lt;- 2.5
  i &lt;- as.integer64(5)
  d/i  # new 0.5
  d*i  # new 13
  i*d  # new 13
  options(integer64_semantics="old")
  d/i  # old: 0.4
  d*i  # old: 10
  i*d  # old: 13
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
