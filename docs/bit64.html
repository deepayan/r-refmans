<!DOCTYPE html><html><head><title>Help for package bit64</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bit64}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#all.equal.integer64'>
<p>Test if two integer64 vectors are all.equal</p></a></li>
<li><a href='#as.character.integer64'>
<p>Coerce from integer64</p></a></li>
<li><a href='#as.data.frame.integer64'>
<p>integer64: Coercing to data.frame column</p></a></li>
<li><a href='#as.integer64.character'>
<p>Coerce to integer64</p></a></li>
<li><a href='#benchmark64'>
<p>Function for measuring algorithmic performance <br /></p>
of high-level and low-level integer64 functions</a></li>
<li><a href='#benchmark64.data'>
<p>Results of performance measurement on a Core i7 Lenovo T410 8 GB RAM under Windows 7 64bit</p></a></li>
<li><a href='#bit64-package'>
<p>A S3 class for vectors of 64bit integers</p></a></li>
<li><a href='#bit64S3'>
<p>Turning base R functions into S3 generics for bit64</p></a></li>
<li><a href='#c.integer64'>
<p>Concatenating integer64 vectors</p></a></li>
<li><a href='#cache'>
<p>Atomic Caching</p></a></li>
<li><a href='#cumsum.integer64'>
<p>Cumulative Sums, Products, Extremes and lagged differences</p></a></li>
<li><a href='#duplicated.integer64'><p>Determine Duplicate Elements of integer64</p></a></li>
<li><a href='#extract.replace.integer64'>
<p>Extract or Replace Parts of an integer64 vector</p></a></li>
<li><a href='#format.integer64'>
<p>Unary operators and functions for integer64 vectors</p></a></li>
<li><a href='#hashcache'>
<p>Big caching of hashing, sorting, ordering</p></a></li>
<li><a href='#hashmap'>
<p>Hashing for 64bit integers</p></a></li>
<li><a href='#identical.integer64'>
<p>Identity function for class 'integer64'</p></a></li>
<li><a href='#is.sorted.integer64'>
<p>Small cache access methods</p></a></li>
<li><a href='#keypos'><p>Extract Positions in redundant dimension table</p></a></li>
<li><a href='#match.integer64'>
<p>64-bit integer matching</p></a></li>
<li><a href='#optimizer64.data'>
<p>Results of performance measurement on a Core i7 Lenovo T410 8 GB RAM under Windows 7 64bit</p></a></li>
<li><a href='#plusclass'>
<p>integer64: Maintaining S3 class attribute</p></a></li>
<li><a href='#prank'><p>(P)ercent (Rank)s</p></a></li>
<li><a href='#qtile'><p>(Q)uan(Tile)s</p></a></li>
<li><a href='#ramsort.integer64'>
<p>Low-level intger64 methods for in-RAM sorting and ordering</p></a></li>
<li><a href='#rank.integer64'><p>Sample Ranks from integer64</p></a></li>
<li><a href='#rep.integer64'>
<p>Replicate elements of integer64 vectors</p></a></li>
<li><a href='#runif64'>
<p>integer64: random numbers</p></a></li>
<li><a href='#seq.integer64'>
<p>integer64: Sequence Generation</p></a></li>
<li><a href='#sort.integer64'>
<p>High-level intger64 methods for sorting and ordering</p></a></li>
<li><a href='#sortnut'>
<p>Searching and other uses of sorting for 64bit integers</p></a></li>
<li><a href='#sum.integer64'>
<p>Summary functions for integer64 vectors</p></a></li>
<li><a href='#table.integer64'><p>Cross Tabulation and Table Creation for integer64</p></a></li>
<li><a href='#tiepos'><p>Extract Positions of Tied Elements</p></a></li>
<li><a href='#unipos'><p>Extract Positions of Unique Elements</p></a></li>
<li><a href='#unique.integer64'><p>Extract Unique Elements from integer64</p></a></li>
<li><a href='#xor.integer64'>
<p>Binary operators for integer64 vectors</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A S3 Class for Vectors of 64bit Integers</td>
</tr>
<tr>
<td>Version:</td>
<td>4.0.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-08-29</td>
</tr>
<tr>
<td>Author:</td>
<td>Jens Oehlschlägel [aut, cre], Leonardo Silvestri [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jens Oehlschlägel &lt;Jens.Oehlschlaegel@truecluster.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.1), bit (&ge; 4.0.0), utils, methods, stats</td>
</tr>
<tr>
<td>Description:</td>
<td>
 Package 'bit64' provides serializable S3 atomic 64bit (signed) integers. 
 These are useful for handling database keys and exact counting in +-2^63.
 WARNING: do not use them as replacement for 32bit integers, integer64 are not
 supported for subscripting by R-core and they have different semantics when 
 combined with double, e.g. integer64 + double =&gt; integer64. 
 Class integer64 can be used in vectors, matrices, arrays and data.frames. 
 Methods are available for coercion from and to logicals, integers, doubles, 
 characters and factors as well as many elementwise and summary functions. 
 Many fast algorithmic operations such as 'match' and 'order' support inter-
 active data exploration and manipulation and optionally leverage caching.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/truecluster/bit64">https://github.com/truecluster/bit64</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Repository/R-Forge/Project:</td>
<td>ff</td>
</tr>
<tr>
<td>Repository/R-Forge/Revision:</td>
<td>177</td>
</tr>
<tr>
<td>Repository/R-Forge/DateTimeStamp:</td>
<td>2018-08-17 17:45:18</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-08-30 07:20:02 UTC</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-08-29 10:56:45 UTC; jo</td>
</tr>
</table>
<hr>
<h2 id='all.equal.integer64'>
Test if two integer64 vectors are all.equal
</h2><span id='topic+all.equal.integer64'></span>

<h3>Description</h3>

<p>A utility to compare integer64 objects 'x' and 'y' testing for ‘near equality’, see <code><a href="Matrix.html#topic+all.equal">all.equal</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'integer64'
all.equal(
  target
, current
, tolerance = sqrt(.Machine$double.eps)
, scale = NULL
, countEQ = FALSE
, formatFUN = function(err, what) format(err)
, ...
, check.attributes = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all.equal.integer64_+3A_target">target</code></td>
<td>
<p> a vector of 'integer64' or an object that can be coerced with <code><a href="#topic+as.integer64">as.integer64</a></code> </p>
</td></tr>
<tr><td><code id="all.equal.integer64_+3A_current">current</code></td>
<td>
<p> a vector of 'integer64' or an object that can be coerced with <code><a href="#topic+as.integer64">as.integer64</a></code> </p>
</td></tr>
<tr><td><code id="all.equal.integer64_+3A_tolerance">tolerance</code></td>
<td>
<p>numeric <code class="reqn">\ge</code> 0.  Differences smaller than
<code>tolerance</code> are not reported.  The default value is close to
<code>1.5e-8</code>.</p>
</td></tr>
<tr><td><code id="all.equal.integer64_+3A_scale">scale</code></td>
<td>
<p><code>NULL</code> or numeric &gt; 0, typically of length 1 or
<code>length(target)</code>.  See &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="all.equal.integer64_+3A_counteq">countEQ</code></td>
<td>
<p>logical indicating if the <code>target == current</code>
cases should be counted when computing the mean (absolute or
relative) differences.  The default, <code>FALSE</code> may seem
misleading in cases where <code>target</code> and <code>current</code> only
differ in a few places; see the extensive example.</p>
</td></tr>
<tr><td><code id="all.equal.integer64_+3A_formatfun">formatFUN</code></td>
<td>
<p>a <code><a href="base.html#topic+function">function</a></code> of two arguments,
<code>err</code>, the relative, absolute or scaled error, and
<code>what</code>, a character string indicating the <em>kind</em> of error;
maybe used, e.g., to format relative and absolute errors differently.</p>
</td></tr>
<tr><td><code id="all.equal.integer64_+3A_...">...</code></td>
<td>
<p>further arguments are ignored</p>
</td></tr>
<tr><td><code id="all.equal.integer64_+3A_check.attributes">check.attributes</code></td>
<td>
<p>logical indicating if the
<code><a href="base.html#topic+attributes">attributes</a></code> of <code>target</code> and <code>current</code>
(other than the names) should be compared.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In <code><a href="base.html#topic+all.equal.numeric">all.equal.numeric</a></code> the type <code>integer</code> is treated as a proper subset of <code>double</code> 
i.e. does not complain about comparing <code>integer</code> with <code>double</code>. 
Following this logic <code>all.equal.integer64</code> treats <code>integer</code> as a proper subset of <code>integer64</code> 
and does not complain about comparing <code>integer</code> with <code>integer64</code>. <code>double</code> also compares without warning 
as long as the values are within <code><a href="#topic+lim.integer64">lim.integer64</a></code>, if <code>double</code> are bigger <code>all.equal.integer64</code>
complains about the <code>all.equal.integer64 overflow warning</code>. For further details see <code><a href="Matrix.html#topic+all.equal">all.equal</a></code>.
</p>


<h3>Value</h3>

<p>Either ‘TRUE’ (‘NULL’ for ‘attr.all.equal’) or a vector of ‘mode’
‘&quot;character&quot;’ describing the differences between ‘target’ and
‘current’.
</p>


<h3>Note</h3>

<p><code><a href="Matrix.html#topic+all.equal">all.equal</a></code> only dispatches to this method if the first argument is <code>integer64</code>, 
calling <code><a href="Matrix.html#topic+all.equal">all.equal</a></code> with a <code>non-integer64</code> first and a <code>integer64</code> second argument 
gives undefined behavior!
</p>


<h3>Author(s)</h3>

<p>Leonardo Silvestri (for package nanotime)
</p>


<h3>See Also</h3>

<p><code><a href="Matrix.html#topic+all.equal">all.equal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  all.equal(as.integer64(1:10), as.integer64(0:9))
  all.equal(as.integer64(1:10), as.integer(1:10))
  all.equal(as.integer64(1:10), as.double(1:10))
  all.equal(as.integer64(1), as.double(1e300))
</code></pre>

<hr>
<h2 id='as.character.integer64'>
Coerce from integer64
</h2><span id='topic+as.character.integer64'></span><span id='topic+as.double.integer64'></span><span id='topic+as.integer.integer64'></span><span id='topic+as.logical.integer64'></span><span id='topic+as.bitstring'></span><span id='topic+print.bitstring'></span><span id='topic+as.bitstring.integer64'></span><span id='topic+as.factor.integer64'></span><span id='topic+as.ordered.integer64'></span>

<h3>Description</h3>

<p>Methods to coerce integer64 to other atomic types. 
'as.bitstring' coerces to a human-readable bit representation (strings of zeroes and ones). 
The methods <code><a href="base.html#topic+format">format</a></code>, <code><a href="base.html#topic+as.character">as.character</a></code>, <code><a href="base.html#topic+as.double">as.double</a></code>,
<code><a href="base.html#topic+as.logical">as.logical</a></code>, <code><a href="base.html#topic+as.integer">as.integer</a></code> do what you would expect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> as.bitstring(x, ...)
 ## S3 method for class 'integer64'
as.bitstring(x, ...)
 ## S3 method for class 'bitstring'
print(x, ...)
 ## S3 method for class 'integer64'
as.character(x, ...)
 ## S3 method for class 'integer64'
as.double(x, keep.names = FALSE, ...)
 ## S3 method for class 'integer64'
as.integer(x, ...)
 ## S3 method for class 'integer64'
as.logical(x, ...)
 ## S3 method for class 'integer64'
as.factor(x)
 ## S3 method for class 'integer64'
as.ordered(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.character.integer64_+3A_x">x</code></td>
<td>
<p> an integer64 vector </p>
</td></tr>
<tr><td><code id="as.character.integer64_+3A_keep.names">keep.names</code></td>
<td>
<p> FALSE, set to TRUE to keep a names vector </p>
</td></tr>
<tr><td><code id="as.character.integer64_+3A_...">...</code></td>
<td>
<p> further arguments to the <code><a href="base.html#topic+NextMethod">NextMethod</a></code> </p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>as.bitstring</code> returns a string of class 'bitstring'. <br />
The other methods return atomic vectors of the expected types
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel &lt;Jens.Oehlschlaegel@truecluster.com&gt;
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+as.integer64.character">as.integer64.character</a></code> <code><a href="#topic+integer64">integer64</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>  as.character(lim.integer64())
  as.bitstring(lim.integer64())
  as.bitstring(as.integer64(c(
   -2,-1,NA,0:2
  )))
</code></pre>

<hr>
<h2 id='as.data.frame.integer64'>
integer64: Coercing to data.frame column
</h2><span id='topic+as.data.frame.integer64'></span>

<h3>Description</h3>

<p>Coercing integer64 vector to data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'integer64'
as.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.integer64_+3A_x">x</code></td>
<td>
<p> an integer64 vector </p>
</td></tr>
<tr><td><code id="as.data.frame.integer64_+3A_...">...</code></td>
<td>
<p> passed to NextMethod <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> after removing the 'integer64' class attribute </p>
</td></tr>
</table>


<h3>Details</h3>

<p>'as.data.frame.integer64' is rather not intended to be called directly,
but it is required to allow integer64 as data.frame columns.
</p>


<h3>Value</h3>

<p>a one-column data.frame containing an integer64 vector
</p>


<h3>Note</h3>

<p>This is currently very slow &ndash; any ideas for improvement?
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel &lt;Jens.Oehlschlaegel@truecluster.com&gt;
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+cbind.integer64">cbind.integer64</a></code> <code><a href="#topic+integer64">integer64</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  as.data.frame.integer64(as.integer64(1:12))
  data.frame(a=1:12, b=as.integer64(1:12))
</code></pre>

<hr>
<h2 id='as.integer64.character'>
Coerce to integer64
</h2><span id='topic+as.integer64'></span><span id='topic+as.integer64.integer64'></span><span id='topic+as.integer64.NULL'></span><span id='topic+as.integer64.bitstring'></span><span id='topic+as.integer64.character'></span><span id='topic+as.integer64.double'></span><span id='topic+as.integer64.integer'></span><span id='topic+as.integer64.logical'></span><span id='topic+as.integer64.factor'></span><span id='topic+NA_integer64_'></span>

<h3>Description</h3>

<p>Methods to coerce from other atomic types to integer64. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'> NA_integer64_
 as.integer64(x, ...)
 ## S3 method for class 'integer64'
as.integer64(x, ...)
 ## S3 method for class 'NULL'
as.integer64(x, ...)
 ## S3 method for class 'character'
as.integer64(x, ...)
 ## S3 method for class 'bitstring'
as.integer64(x, ...)
 ## S3 method for class 'double'
as.integer64(x, keep.names = FALSE, ...)
 ## S3 method for class 'integer'
as.integer64(x, ...)
 ## S3 method for class 'logical'
as.integer64(x, ...)
 ## S3 method for class 'factor'
as.integer64(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.integer64.character_+3A_x">x</code></td>
<td>
<p> an atomic vector </p>
</td></tr>
<tr><td><code id="as.integer64.character_+3A_keep.names">keep.names</code></td>
<td>
<p> FALSE, set to TRUE to keep a names vector </p>
</td></tr>
<tr><td><code id="as.integer64.character_+3A_...">...</code></td>
<td>
<p> further arguments to the <code><a href="base.html#topic+NextMethod">NextMethod</a></code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>as.integer64.character</code> is realized using C function <code>strtoll</code> which does not support scientific notation. 
Instead of '1e6' use '1000000'. 
<code>as.integer64.bitstring</code> evaluates characters '0' anbd ' ' as zero-bit,
all other one byte characters as one-bit,
multi-byte characters are not allowed,
strings shorter than 64 characters are treated as if they were left-padded with '0',
strings longer than 64 bytes are mapped to <code>NA_INTEGER64</code> and a warning is emitted.
</p>


<h3>Value</h3>

<p>The other methods return atomic vectors of the expected types
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel &lt;Jens.Oehlschlaegel@truecluster.com&gt;
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+as.character.integer64">as.character.integer64</a></code> <code><a href="#topic+integer64">integer64</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>as.integer64(as.character(lim.integer64()))
as.integer64(
  structure(c("1111111111111111111111111111111111111111111111111111111111111110", 
              "1111111111111111111111111111111111111111111111111111111111111111", 
              "1000000000000000000000000000000000000000000000000000000000000000",
              "0000000000000000000000000000000000000000000000000000000000000000", 
              "0000000000000000000000000000000000000000000000000000000000000001", 
              "0000000000000000000000000000000000000000000000000000000000000010" 
  ), class = "bitstring")
)
as.integer64(
 structure(c("............................................................... ", 
             "................................................................", 
             ".                                                               ",
             "", 
             ".", 
             "10"
  ), class = "bitstring")
)
</code></pre>

<hr>
<h2 id='benchmark64'>
Function for measuring algorithmic performance <br /> 
of high-level and low-level integer64 functions
</h2><span id='topic+benchmark64'></span><span id='topic+optimizer64'></span>

<h3>Description</h3>

<p><code>benchmark64</code> compares high-level integer64 functions against the integer functions from Base R <br />
<code>optimizer64</code> compares for each high-level integer64 function the Base R integer function with several low-level integer64 functions with and without caching <br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>benchmark64(nsmall = 2^16, nbig = 2^25, timefun = repeat.time
)
optimizer64(nsmall = 2^16, nbig = 2^25, timefun = repeat.time
, what = c("match", "%in%", "duplicated", "unique", "unipos", "table", "rank", "quantile")
, uniorder = c("original", "values", "any")
, taborder = c("values", "counts")
, plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="benchmark64_+3A_nsmall">nsmall</code></td>
<td>
<p> size of smaller vector </p>
</td></tr>
<tr><td><code id="benchmark64_+3A_nbig">nbig</code></td>
<td>
<p> size of larger bigger vector </p>
</td></tr>
<tr><td><code id="benchmark64_+3A_timefun">timefun</code></td>
<td>
<p> a function for timing such as <code><a href="bit.html#topic+repeat.time">repeat.time</a></code> or <code><a href="base.html#topic+system.time">system.time</a></code> </p>
</td></tr>
<tr><td><code id="benchmark64_+3A_what">what</code></td>
<td>

<p>a vector of names of high-level functions
</p>
</td></tr>
<tr><td><code id="benchmark64_+3A_uniorder">uniorder</code></td>
<td>

<p>one of the order parameters that are allowed in <code><a href="#topic+unique.integer64">unique.integer64</a></code> and <code><a href="#topic+unipos.integer64">unipos.integer64</a></code>
</p>
</td></tr>
<tr><td><code id="benchmark64_+3A_taborder">taborder</code></td>
<td>

<p>one of the order parameters that are allowed in <code><a href="#topic+table.integer64">table.integer64</a></code> 
</p>
</td></tr>
<tr><td><code id="benchmark64_+3A_plot">plot</code></td>
<td>

<p>set to FALSE to suppress plotting 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>benchmark64</code> compares the following scenarios for the following use cases: 
</p>

<table>
<tr>
 <td style="text-align: right;">
  <b>scenario name</b> </td><td style="text-align: left;"> <b>explanation</b> </td>
</tr>
<tr>
 <td style="text-align: right;">
  32-bit  </td><td style="text-align: left;"> applying Base R function to 32-bit integer data </td>
</tr>
<tr>
 <td style="text-align: right;">
  64-bit </td><td style="text-align: left;"> applying bit64 function to 64-bit integer data (with no cache) </td>
</tr>
<tr>
 <td style="text-align: right;">
  hashcache </td><td style="text-align: left;"> dito when cache contains <code><a href="#topic+hashmap">hashmap</a></code>, see <code><a href="#topic+hashcache">hashcache</a></code> </td>
</tr>
<tr>
 <td style="text-align: right;">
  sortordercache </td><td style="text-align: left;"> dito when cache contains sorting and ordering, see <code><a href="#topic+sortordercache">sortordercache</a></code> </td>
</tr>
<tr>
 <td style="text-align: right;">
  ordercache </td><td style="text-align: left;"> dito when cache contains ordering only, see <code><a href="#topic+ordercache">ordercache</a></code> </td>
</tr>
<tr>
 <td style="text-align: right;">
  allcache </td><td style="text-align: left;"> dito when cache contains sorting, ordering and hashing </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td>
</tr>

</table>


<table>
<tr>
 <td style="text-align: right;">
  <b>use case name</b> </td><td style="text-align: left;"> <b>explanation</b> </td>
</tr>
<tr>
 <td style="text-align: right;">
  cache         </td><td style="text-align: left;"> filling the cache according to scenario </td>
</tr>
<tr>
 <td style="text-align: right;">
  match(s,b)    </td><td style="text-align: left;"> match small in big vector </td>
</tr>
<tr>
 <td style="text-align: right;">
  s %in% b      </td><td style="text-align: left;"> small %in% big vector </td>
</tr>
<tr>
 <td style="text-align: right;">
  match(b,s)    </td><td style="text-align: left;"> match big in small vector </td>
</tr>
<tr>
 <td style="text-align: right;">
  b %in% s      </td><td style="text-align: left;"> big %in% small vector </td>
</tr>
<tr>
 <td style="text-align: right;">
  match(b,b)    </td><td style="text-align: left;"> match big in (different) big vector </td>
</tr>
<tr>
 <td style="text-align: right;">
  b %in% b      </td><td style="text-align: left;"> big %in% (different) big vector </td>
</tr>
<tr>
 <td style="text-align: right;">
  duplicated(b) </td><td style="text-align: left;"> duplicated of big vector </td>
</tr>
<tr>
 <td style="text-align: right;">
  unique(b)     </td><td style="text-align: left;"> unique of big vector </td>
</tr>
<tr>
 <td style="text-align: right;">
  table(b)      </td><td style="text-align: left;"> table of big vector </td>
</tr>
<tr>
 <td style="text-align: right;">
  sort(b)       </td><td style="text-align: left;"> sorting of big vector </td>
</tr>
<tr>
 <td style="text-align: right;">
  order(b)      </td><td style="text-align: left;"> ordering of big vector </td>
</tr>
<tr>
 <td style="text-align: right;">
  rank(b)       </td><td style="text-align: left;"> ranking of big vector </td>
</tr>
<tr>
 <td style="text-align: right;">
  quantile(b)   </td><td style="text-align: left;"> quantiles of big vector </td>
</tr>
<tr>
 <td style="text-align: right;">
  summary(b)    </td><td style="text-align: left;"> summary of of big vector </td>
</tr>
<tr>
 <td style="text-align: right;">
  SESSION       </td><td style="text-align: left;"> exemplary session involving multiple calls (including cache filling costs) </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td>
</tr>

</table>

<p>Note that the timings for the cached variants do <em>not</em> contain the time costs of building the cache, except for the timing of the exemplary user session, where the cache costs are included in order to evaluate amortization. 
</p>


<h3>Value</h3>

<p><code>benchmark64</code> returns a matrix with elapsed seconds, different high-level tasks in rows and different scenarios to solve the task in columns. The last row named 'SESSION' contains the elapsed seconds of the exemplary sesssion.
<br />
<code>optimizer64</code> returns a dimensioned list with one row for each high-level function timed and two columns named after the values of the <code>nsmall</code> and <code>nbig</code> sample sizes. Each list cell contains a matrix with timings, low-level-methods in rows and three measurements <code>c("prep","both","use")</code> in columns. If it can be measured separately, <code>prep</code> contains the timing of preparatory work such as sorting and hashing, and <code>use</code> contains the timing of using the prepared work. If the function timed does both, preparation and use, the timing is in <code>both</code>.  
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel &lt;Jens.Oehlschlaegel@truecluster.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+integer64">integer64</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>message("this small example using system.time does not give serious timings\n
this we do this only to run regression tests")
benchmark64(nsmall=2^7, nbig=2^13, timefun=function(expr)system.time(expr, gcFirst=FALSE))
optimizer64(nsmall=2^7, nbig=2^13, timefun=function(expr)system.time(expr, gcFirst=FALSE)
, plot=FALSE
)
## Not run: 
message("for real measurement of sufficiently large datasets run this on your machine")
benchmark64()
optimizer64()

## End(Not run)
message("let's look at the performance results on Core i7 Lenovo T410 with 8 GB RAM")
data(benchmark64.data)
print(benchmark64.data)

matplot(log2(benchmark64.data[-1,1]/benchmark64.data[-1,])
, pch=c("3", "6", "h", "s", "o", "a") 
, xlab="tasks [last=session]"
, ylab="log2(relative speed) [bigger is better]"
)
matplot(t(log2(benchmark64.data[-1,1]/benchmark64.data[-1,]))
, type="b", axes=FALSE 
, lwd=c(rep(1, 14), 3)
, xlab="context"
, ylab="log2(relative speed) [bigger is better]"
)
axis(1
, labels=c("32-bit", "64-bit", "hash", "sortorder", "order", "hash+sortorder")
, at=1:6
)
axis(2)
data(optimizer64.data)
print(optimizer64.data)
oldpar &lt;- par(no.readonly = TRUE)
par(mfrow=c(2,1))
par(cex=0.7)
for (i in 1:nrow(optimizer64.data)){
 for (j in 1:2){
   tim &lt;- optimizer64.data[[i,j]]
  barplot(t(tim))
  if (rownames(optimizer64.data)[i]=="match")
   title(paste("match", colnames(optimizer64.data)[j], "in", colnames(optimizer64.data)[3-j]))
  else if (rownames(optimizer64.data)[i]=="%in%")
   title(paste(colnames(optimizer64.data)[j], "%in%", colnames(optimizer64.data)[3-j]))
  else
   title(paste(rownames(optimizer64.data)[i], colnames(optimizer64.data)[j]))
 }
}
par(mfrow=c(1,1))
</code></pre>

<hr>
<h2 id='benchmark64.data'>
Results of performance measurement on a Core i7 Lenovo T410 8 GB RAM under Windows 7 64bit
</h2><span id='topic+benchmark64.data'></span>

<h3>Description</h3>

<p>These are the results of calling <code><a href="#topic+benchmark64">benchmark64</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(benchmark64.data)</code></pre>


<h3>Format</h3>

<p>The format is:
num [1:16, 1:6] 2.55e-05 2.37 2.39 1.28 1.39 ...
- attr(*, &quot;dimnames&quot;)=List of 2
..$ : chr [1:16] &quot;cache&quot; &quot;match(s,b)&quot; &quot;s %in% b&quot; &quot;match(b,s)&quot; ...
..$ : chr [1:6] &quot;32-bit&quot; &quot;64-bit&quot; &quot;hashcache&quot; &quot;sortordercache&quot; ...
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(benchmark64.data)
print(benchmark64.data)
matplot(log2(benchmark64.data[-1,1]/benchmark64.data[-1,])
, pch=c("3", "6", "h", "s", "o", "a")
, xlab="tasks [last=session]"
, ylab="log2(relative speed) [bigger is better]"
)
matplot(t(log2(benchmark64.data[-1,1]/benchmark64.data[-1,]))
, axes=FALSE
, type="b"
, lwd=c(rep(1, 14), 3)
, xlab="context"
, ylab="log2(relative speed) [bigger is better]"
)
axis(1
, labels=c("32-bit", "64-bit", "hash", "sortorder", "order", "hash+sortorder")
, at=1:6
)
axis(2)
</code></pre>

<hr>
<h2 id='bit64-package'>
A S3 class for vectors of 64bit integers
</h2><span id='topic+bit64-package'></span><span id='topic+bit64'></span><span id='topic+integer64'></span><span id='topic+is.integer64'></span><span id='topic+is.integer.integer64'></span><span id='topic+is.vector.integer64'></span><span id='topic+length+3C-.integer64'></span><span id='topic+print.integer64'></span><span id='topic+str.integer64'></span>

<h3>Description</h3>

<p>Package 'bit64' provides fast serializable S3 atomic 64bit (signed) integers 
that can be used in vectors, matrices, arrays and data.frames. Methods are 
available for coercion from and to logicals, integers, doubles, characters  
and factors as well as many elementwise and summary functions. 
<br />
<b>Version 0.8</b>
With 'integer64' vectors you can store very large integers at the expense
of 64 bits, which is by factor 7 better than 'int64' from package 'int64'.
Due to the smaller memory footprint, the atomic vector architecture and  
using only S3 instead of S4 classes, most operations are one to three orders 
of magnitude faster: Example speedups are 4x for serialization, 250x for 
adding, 900x for coercion and 2000x for object creation. Also 'integer64' 
avoids an ongoing (potentially infinite) penalty for garbage collection
observed during existence of 'int64' objects (see code in example section). 
<br />
<b>Version 0.9</b>
Package 'bit64' - which extends R with fast 64-bit integers - now has fast
(single-threaded) implementations the most important univariate algorithmic 
operations (those based on hashing and sorting). We now have methods for 
'match', '
'quantile', 'median' and 'summary'. Regarding data management we also have 
novel generics 'unipos' (positions of the unique values), 'tiepos' (
positions of ties), 'keypos' (positions of foreign keys in a sorted 
dimension table) and derived methods 'as.factor' and 'as.ordered'. This 64-
bit functionality is implemented carefully to be not slower than the 
respective 32-bit operations in Base R and also to avoid outlying waiting 
times observed with 'order', 'rank' and 'table' (speedup factors 20/16/200 
respective). This increases the dataset size with wich we can work truly 
interactive. The speed is achieved by simple heuristic optimizers in high-
level functions choosing the best from multiple low-level algorithms and 
further taking advantage of a novel caching if activated. In an example R 
session using a couple of these operations the 64-bit integers performed 22x
faster than base 32-bit integers, hash-caching improved this to 24x, 
sortorder-caching was most efficient with 38x (caching hashing and sorting 
is not worth it with 32x at duplicated RAM consumption).
</p>


<h3>Usage</h3>

<pre><code class='language-R'> integer64(length)
 ## S3 method for class 'integer64'
is(x)
 ## S3 replacement method for class 'integer64'
length(x) &lt;- value
 ## S3 method for class 'integer64'
print(x, quote=FALSE, ...)
 ## S3 method for class 'integer64'
str(object, vec.len  = strO$vec.len, give.head = TRUE, give.length = give.head, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bit64-package_+3A_length">length</code></td>
<td>
<p> length of vector using <code><a href="base.html#topic+integer">integer</a></code> </p>
</td></tr>
<tr><td><code id="bit64-package_+3A_x">x</code></td>
<td>
<p> an integer64 vector </p>
</td></tr>
<tr><td><code id="bit64-package_+3A_object">object</code></td>
<td>
<p> an integer64 vector </p>
</td></tr>
<tr><td><code id="bit64-package_+3A_value">value</code></td>
<td>
<p> an integer64 vector of values to be assigned </p>
</td></tr>
<tr><td><code id="bit64-package_+3A_quote">quote</code></td>
<td>
<p> logical, indicating whether or not strings should be printed with surrounding quotes. </p>
</td></tr>
<tr><td><code id="bit64-package_+3A_vec.len">vec.len</code></td>
<td>
<p> see <code><a href="utils.html#topic+str">str</a></code> </p>
</td></tr>
<tr><td><code id="bit64-package_+3A_give.head">give.head</code></td>
<td>
<p> see <code><a href="utils.html#topic+str">str</a></code> </p>
</td></tr>
<tr><td><code id="bit64-package_+3A_give.length">give.length</code></td>
<td>
<p> see <code><a href="utils.html#topic+str">str</a></code> </p>
</td></tr>
<tr><td><code id="bit64-package_+3A_...">...</code></td>
<td>
<p> further arguments to the <code><a href="base.html#topic+NextMethod">NextMethod</a></code> </p>
</td></tr>
</table>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
   Package: </td><td style="text-align: left;"> bit64</td>
</tr>
<tr>
 <td style="text-align: left;">
   Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
   Version: </td><td style="text-align: left;"> 0.5.0</td>
</tr>
<tr>
 <td style="text-align: left;">
   Date: </td><td style="text-align: left;"> 2011-12-12</td>
</tr>
<tr>
 <td style="text-align: left;">
   License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
   LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
   Encoding: </td><td style="text-align: left;"> latin1</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p><code>integer64</code> returns a vector of 'integer64', 
i.e. a vector of <code><a href="base.html#topic+double">double</a></code> decorated with class 'integer64'.
</p>


<h3>Design considerations</h3>

<p>64 bit integers are related to big data: we need them to overcome address space limitations. 
Therefore performance of the 64 bit integer type is critical. 
In the S language &ndash; designed in 1975 &ndash; atomic objects were defined to be vectors for a couple of good reasons:
simplicity, option for implicit parallelization, good cache locality. 
In recent years many analytical databases have learnt that lesson: column based data bases provide superior performance
for many applications, the result are products such as MonetDB, Sybase IQ, Vertica, Exasol, Ingres Vectorwise.
If we introduce 64 bit integers not natively in Base R but as an external package, we should at least strive to 
make them as 'basic' as possible. Therefore the design choice of bit64 not only differs from <code>int64</code>, it is obvious: 
Like the other atomic types in Base R, we model data type 'integer64' as a contiguous <code><a href="base.html#topic+atomic">atomic</a></code> vector in memory, 
and we use the more basic <code><a href="methods.html#topic+S3">S3</a></code> class system, not <code><a href="methods.html#topic+S4">S4</a></code>. Like package <code>int64</code> we want our 'integer64' to be <code><a href="base.html#topic+serialize">serialize</a>able</code>, 
therefore we also use an existing data type as the basis. Again the choice is obvious: R has only one 64 bit data type: doubles.
By using <code><a href="base.html#topic+double">double</a>s</code>, <code>integer64</code> <code><a href="base.html#topic+inherits">inherits</a></code> some functionality such as <code><a href="base.html#topic+is.atomic">is.atomic</a></code>, <code><a href="base.html#topic+length">length</a></code>, 
<code><a href="base.html#topic+length+3C-">length&lt;-</a></code>, <code><a href="base.html#topic+names">names</a></code>, <code><a href="base.html#topic+names+3C-">names&lt;-</a></code>, <code><a href="base.html#topic+dim">dim</a></code>, <code><a href="base.html#topic+dim+3C-">dim&lt;-</a></code>, <code><a href="base.html#topic+dimnames">dimnames</a></code>, <code><a href="base.html#topic+dimnames">dimnames</a></code>.
<br />
Our R level functions strictly follow the functional programming paragdim: 
no modification of arguments or other sideffects. Before version 0.93  we internally deviated from the strict paradigm
in order to boost performance. Our C functions do not create new return values, 
instead we pass-in the memory to be returned as an argument. This gives us the freedom to apply the C-function 
to new or old vectors, which helps to avoid unnecessary memory allocation, unnecessary copying and unnessary garbage collection.
Prior to 0.93 <em>within</em> our R functions we also deviated from conventional R programming by not using <code><a href="base.html#topic+attr+3C-">attr&lt;-</a></code> and <code><a href="base.html#topic+attributes+3C-">attributes&lt;-</a></code> 
because they always did new memory allocation and copying in older R versions. If we wanted to set attributes of return values that we have freshly created,
we instead used functions <code><a href="bit.html#topic+getsetattr">setattr</a></code> and <code><a href="bit.html#topic+getsetattr">setattributes</a></code> from package <code><a href="bit.html#topic+bit">bit</a></code>. 
From version 0.93 <code><a href="bit.html#topic+getsetattr">setattr</a></code> is only used for manipulating <code><a href="#topic+cache">cache</a></code> objects, in <code><a href="#topic+ramsort.integer64">ramsort.integer64</a></code> and <code><a href="#topic+sort.integer64">sort.integer64</a></code> and in <code><a href="#topic+as.data.frame.integer64">as.data.frame.integer64</a></code>.
</p>


<h3>Arithmetic precision and coercion</h3>

<p>The fact that we introduce 64 bit long long integers &ndash; without introducing 128-bit long doubles &ndash; creates some subtle challenges:
Unlike 32 bit <code><a href="base.html#topic+integer">integer</a>s</code>, the <code>integer64</code> are no longer a proper subset of <code><a href="base.html#topic+double">double</a></code>. 
If a binary arithmetic operation does involve a <code>double</code> and a <code>integer</code>, it is a no-brainer to return <code>double</code> 
without loss of information. If an <code>integer64</code> meets a <code>double</code>, it is not trivial what type to return. 
Switching to <code>integer64</code> limits our ability to represent very large numbers, switching to <code>double</code> limits our ability 
to distinguish <code>x</code> from <code>x+1</code>. Since the latter is the purpose of introducing 64 bit integers, we usually return <code>integer64</code> 
from functions involving <code>integer64</code>, for example in <code><a href="#topic+c.integer64">c</a></code>, <code><a href="#topic+cbind.integer64">cbind</a></code> 
and <code><a href="#topic+rbind.integer64">rbind</a></code>. 
<br />
Different from Base R, our operators <code><a href="#topic++2B.integer64">+</a></code>, 
<code><a href="#topic+-.integer64">-</a></code>, <code><a href="#topic++25+2F+25.integer64">%/%</a></code> and <code><a href="#topic++25+25.integer64">%%</a></code> coerce their arguments to 
<code>integer64</code> and always return <code>integer64</code>. 
<br />
The multiplication operator <code><a href="#topic++2A.integer64">*</a></code> coerces its first argument to <code>integer64</code> 
but allows its second argument to be also <code>double</code>: the second argument is internaly coerced to 'long double' 
and the result of the multiplication is returned as <code>integer64</code>. 
<br />
The division <code><a href="#topic++2F.integer64">/</a></code> and power <code><a href="#topic++5E.integer64">^</a></code> operators also coerce their first argument to <code>integer64</code> 
and coerce internally their second argument to 'long double', they return as <code>double</code>, like <code><a href="#topic+sqrt.integer64">sqrt</a></code>, 
<code><a href="#topic+log.integer64">log</a></code>, <code><a href="#topic+log2.integer64">log2</a></code> and <code><a href="#topic+log10.integer64">log10</a></code> do. 
</p>

<table>
<tr>
 <td style="text-align: center;">
  <b>argument1</b> </td><td style="text-align: center;"> <b>op</b> </td><td style="text-align: center;"> <b>argument2</b> </td><td style="text-align: center;"> <b>-&gt;</b> </td><td style="text-align: center;"> <b>coerced1</b> </td><td style="text-align: center;"> <b>op</b> </td><td style="text-align: center;"> <b>coerced2</b> </td><td style="text-align: center;"> <b>-&gt;</b> </td><td style="text-align: center;"> <b>result</b> </td>
</tr>
<tr>
 <td style="text-align: center;">
  integer64 </td><td style="text-align: center;"> + </td><td style="text-align: center;"> double </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> + </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td>
</tr>
<tr>
 <td style="text-align: center;">
  double </td><td style="text-align: center;"> + </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> + </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td>
</tr>
<tr>
 <td style="text-align: center;">
  integer64 </td><td style="text-align: center;"> - </td><td style="text-align: center;"> double </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> - </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td>
</tr>
<tr>
 <td style="text-align: center;">
  double </td><td style="text-align: center;"> - </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> - </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td>
</tr>
<tr>
 <td style="text-align: center;">
  integer64 </td><td style="text-align: center;"> %/% </td><td style="text-align: center;"> double </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> %/% </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td>
</tr>
<tr>
 <td style="text-align: center;">
  double </td><td style="text-align: center;"> %/% </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> %/% </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td>
</tr>
<tr>
 <td style="text-align: center;">
  integer64 </td><td style="text-align: center;"> %% </td><td style="text-align: center;"> double </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> %% </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td>
</tr>
<tr>
 <td style="text-align: center;">
  double </td><td style="text-align: center;"> %% </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> %% </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td>
</tr>
<tr>
 <td style="text-align: center;">
  integer64 </td><td style="text-align: center;"> * </td><td style="text-align: center;"> double </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> * </td><td style="text-align: center;"> long double </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td>
</tr>
<tr>
 <td style="text-align: center;">
  double </td><td style="text-align: center;"> * </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> * </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td>
</tr>
<tr>
 <td style="text-align: center;">
  integer64 </td><td style="text-align: center;"> / </td><td style="text-align: center;"> double </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> / </td><td style="text-align: center;"> long double </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> double </td>
</tr>
<tr>
 <td style="text-align: center;">
  double </td><td style="text-align: center;"> / </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> / </td><td style="text-align: center;"> long double </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> double </td>
</tr>
<tr>
 <td style="text-align: center;">
  integer64 </td><td style="text-align: center;"> ^ </td><td style="text-align: center;"> double </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> / </td><td style="text-align: center;"> long double </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> double </td>
</tr>
<tr>
 <td style="text-align: center;">
  double </td><td style="text-align: center;"> ^ </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> integer64 </td><td style="text-align: center;"> / </td><td style="text-align: center;"> long double </td><td style="text-align: center;"> -&gt; </td><td style="text-align: center;"> double </td>
</tr>
<tr>
 <td style="text-align: center;">
 </td>
</tr>

</table>



<h3>Creating and testing S3 class 'integer64'</h3>

<p>Our creator function <code>integer64</code> takes an argument <code>length</code>, creates an atomic double vector of this length,
attaches an S3 class attribute 'integer64' to it, and that's it. We simply rely on S3 method dispatch and interpret those 
64bit elements as 'long long int'. 
<br />
<code><a href="#topic+is.double">is.double</a></code> currently returns TRUE for <code>integer64</code> and might return FALSE in a later release.
Consider <code>is.double</code> to have undefined behaviour and do query <code>is.integer64</code> <em>before</em> querying <code>is.double</code>.


The methods <code><a href="#topic+is.integer64">is.integer64</a></code> and <code><a href="base.html#topic+is.vector">is.vector</a></code> both return <code>TRUE</code> for <code>integer64</code>. 
Note that we did not patch <code><a href="base.html#topic+storage.mode">storage.mode</a></code> and <code><a href="base.html#topic+typeof">typeof</a></code>, which both continue returning 'double' 
Like for 32 bit <code><a href="base.html#topic+integer">integer</a></code>, <code><a href="base.html#topic+mode">mode</a></code> returns 'numeric' and <code><a href="base.html#topic+as.double">as.double</a></code>) tries coercing to <code><a href="base.html#topic+double">double</a></code>).
It is possible that 'integer64' becomes a <code>vmode</code> in package <code>ff</code>. 
<br />
Further methods for creating <code>integer64</code> are <code><a href="#topic+range.integer64">range</a></code> which returns the range of the data type if calles without arguments,
<code><a href="#topic+rep.integer64">rep</a></code>, <code><a href="#topic+seq.integer64">seq</a></code>. 
<br />
For all available methods on <code>integer64</code> vectors see the index below and the examples.
</p>


<h3>Index of implemented methods</h3>


<table>
<tr>
 <td style="text-align: right;">
   <b>creating,testing,printing</b> </td><td style="text-align: right;"> <b>see also</b>          </td><td style="text-align: left;"> <b>description</b> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>NA_integer64_</code> </td><td style="text-align: right;"> <code><a href="base.html#topic+NA_integer_">NA_integer_</a></code> </td><td style="text-align: left;"> NA constant </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>integer64</code> </td><td style="text-align: right;"> <code><a href="base.html#topic+integer">integer</a></code> </td><td style="text-align: left;"> create zero atomic vector </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+runif64">runif64</a></code> </td><td style="text-align: right;"> <code><a href="stats.html#topic+runif">runif</a></code> </td><td style="text-align: left;"> create random vector </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+rep.integer64">rep.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+rep">rep</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+seq.integer64">seq.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+seq">seq</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+is.integer64">is.integer64</a></code> </td><td style="text-align: right;"> <code><a href="methods.html#topic+is">is</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
                                     </td><td style="text-align: right;"> <code><a href="base.html#topic+is.integer">is.integer</a></code> </td><td style="text-align: left;"> inherited from Base R </td>
</tr>
<tr>
 <td style="text-align: right;">
   
   <code><a href="#topic+is.vector.integer64">is.vector.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+is.vector">is.vector</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+identical.integer64">identical.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+identical">identical</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+length+3C-.integer64">length&lt;-.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+length+3C-">length&lt;-</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
                                     </td><td style="text-align: right;"> <code><a href="base.html#topic+length">length</a></code> </td><td style="text-align: left;"> inherited from Base R </td>
</tr>
<tr>
 <td style="text-align: right;">
                                     </td><td style="text-align: right;"> <code><a href="base.html#topic+names+3C-">names&lt;-</a></code> </td><td style="text-align: left;"> inherited from Base R </td>
</tr>
<tr>
 <td style="text-align: right;">
                                     </td><td style="text-align: right;"> <code><a href="base.html#topic+names">names</a></code> </td><td style="text-align: left;"> inherited from Base R </td>
</tr>
<tr>
 <td style="text-align: right;">
                                     </td><td style="text-align: right;"> <code><a href="base.html#topic+dim+3C-">dim&lt;-</a></code> </td><td style="text-align: left;"> inherited from Base R </td>
</tr>
<tr>
 <td style="text-align: right;">
                                     </td><td style="text-align: right;"> <code><a href="base.html#topic+dim">dim</a></code> </td><td style="text-align: left;"> inherited from Base R </td>
</tr>
<tr>
 <td style="text-align: right;">
                                     </td><td style="text-align: right;"> <code><a href="base.html#topic+dimnames+3C-">dimnames&lt;-</a></code> </td><td style="text-align: left;"> inherited from Base R </td>
</tr>
<tr>
 <td style="text-align: right;">
                                     </td><td style="text-align: right;"> <code><a href="base.html#topic+dimnames">dimnames</a></code> </td><td style="text-align: left;"> inherited from Base R </td>
</tr>
<tr>
 <td style="text-align: right;">
                                    </td><td style="text-align: right;"> <code><a href="utils.html#topic+str">str</a></code> </td><td style="text-align: left;"> inherited from Base R, does not print values correctly </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+print.integer64">print.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+print">print</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+str.integer64">str.integer64</a></code> </td><td style="text-align: right;"> <code><a href="utils.html#topic+str">str</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td>
</tr>
<tr>
 <td style="text-align: right;">
   <b>coercing to integer64</b> </td><td style="text-align: right;"> <b>see also</b>          </td><td style="text-align: left;"> <b>description</b> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+as.integer64">as.integer64</a></code> </td><td style="text-align: right;">   </td><td style="text-align: left;"> generic </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+as.integer64.bitstring">as.integer64.bitstring</a></code> </td><td style="text-align: right;"> <code><a href="#topic+as.bitstring">as.bitstring</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+as.integer64.character">as.integer64.character</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+character">character</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+as.integer64.double">as.integer64.double</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+double">double</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+as.integer64.integer">as.integer64.integer</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+integer">integer</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+as.integer64.integer64">as.integer64.integer64</a></code> </td><td style="text-align: right;"> <code>integer64</code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+as.integer64.logical">as.integer64.logical</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+logical">logical</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+as.integer64.NULL">as.integer64.NULL</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+NULL">NULL</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td>
</tr>
<tr>
 <td style="text-align: right;">
   <b>coercing from integer64</b> </td><td style="text-align: right;"> <b>see also</b>          </td><td style="text-align: left;"> <b>description</b> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+as.bitstring">as.bitstring</a></code> </td><td style="text-align: right;"> <code><a href="#topic+as.bitstring">as.bitstring</a></code> </td><td style="text-align: left;"> generic </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+as.bitstring.integer64">as.bitstring.integer64</a></code> </td><td style="text-align: right;">  </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+as.character.integer64">as.character.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+as.character">as.character</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+as.double.integer64">as.double.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+as.double">as.double</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+as.integer.integer64">as.integer.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+as.integer">as.integer</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+as.logical.integer64">as.logical.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+as.logical">as.logical</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   
 </td>
</tr>
<tr>
 <td style="text-align: right;">
   <b>data structures</b> </td><td style="text-align: right;"> <b>see also</b>          </td><td style="text-align: left;"> <b>description</b> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+c.integer64">c.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+c">c</a></code> </td><td style="text-align: left;"> vector concatenate </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+cbind.integer64">cbind.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+cbind">cbind</a></code> </td><td style="text-align: left;"> column bind </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+rbind.integer64">rbind.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+rbind">rbind</a></code> </td><td style="text-align: left;"> row bind </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+as.data.frame.integer64">as.data.frame.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> </td><td style="text-align: left;"> coerce atomic object to data.frame </td>
</tr>
<tr>
 <td style="text-align: right;">
                                         </td><td style="text-align: right;"> <code><a href="base.html#topic+data.frame">data.frame</a></code> </td><td style="text-align: left;"> inherited from Base R since we have coercion </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td>
</tr>
<tr>
 <td style="text-align: right;">
   <b>subscripting</b> </td><td style="text-align: right;"> <b>see also</b>          </td><td style="text-align: left;"> <b>description</b> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic++5B.integer64">[.integer64</a></code> </td><td style="text-align: right;"> <code><a href="Matrix.html#topic++5B">[</a></code> </td><td style="text-align: left;"> vector and array extract </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic++5B+3C-.integer64">[&lt;-.integer64</a></code> </td><td style="text-align: right;"> <code><a href="Matrix.html#topic++5B+3C-">[&lt;-</a></code> </td><td style="text-align: left;"> vector and array assign </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic++5B+5B.integer64">[[.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic++5B+5B">[[</a></code> </td><td style="text-align: left;"> scalar extract </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic++5B+5B+3C-.integer64">[[&lt;-.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic++5B+5B+3C-">[[&lt;-</a></code> </td><td style="text-align: left;"> scalar assign </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td>
</tr>
<tr>
 <td style="text-align: right;">
   <b>binary operators</b> </td><td style="text-align: right;"> <b>see also</b>          </td><td style="text-align: left;"> <b>description</b> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic++2B.integer64">+.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic++2B">+</a></code> </td><td style="text-align: left;"> returns integer64 </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+-.integer64">-.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+-">-</a></code> </td><td style="text-align: left;"> returns integer64 </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic++2A.integer64">*.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic++2A">*</a></code> </td><td style="text-align: left;"> returns integer64 </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic++5E.integer64">^.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic++5E">^</a></code> </td><td style="text-align: left;"> returns double </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic++2F.integer64">/.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic++2F">/</a></code> </td><td style="text-align: left;"> returns double </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic++25+2F+25.integer64">%/%.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic++25+2F+25">%/%</a></code> </td><td style="text-align: left;"> returns integer64 </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic++25+25.integer64">%%.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic++25+25">%%</a></code> </td><td style="text-align: left;"> returns integer64 </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td>
</tr>
<tr>
 <td style="text-align: right;">
   <b>comparison operators</b> </td><td style="text-align: right;"> <b>see also</b>          </td><td style="text-align: left;"> <b>description</b> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic++3D+3D.integer64">==.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic++3D+3D">==</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic++21+3D.integer64">!=.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic++21+3D">!=</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic++3C.integer64">&lt;.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic++3C">&lt;</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic++3C+3D.integer64">&lt;=.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic++3C+3D">&lt;=</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic++3E.integer64">&gt;.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic++3E">&gt;</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic++3E+3D.integer64">&gt;=.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic++3E+3D">&gt;=</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td>
</tr>
<tr>
 <td style="text-align: right;">
   <b>logical operators</b> </td><td style="text-align: right;"> <b>see also</b>          </td><td style="text-align: left;"> <b>description</b> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic++21.integer64">!.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic++21">!</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic++26.integer64">&amp;.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic++26">&amp;</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic++7C.integer64">|.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic++7C">|</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+xor.integer64">xor.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+xor">xor</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td>
</tr>
<tr>
 <td style="text-align: right;">
   <b>math functions</b> </td><td style="text-align: right;"> <b>see also</b>          </td><td style="text-align: left;"> <b>description</b> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+is.na.integer64">is.na.integer64</a></code> </td><td style="text-align: right;"> <code><a href="Matrix.html#topic+is.na">is.na</a></code> </td><td style="text-align: left;"> returns logical </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+format.integer64">format.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+format">format</a></code> </td><td style="text-align: left;"> returns character </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+abs.integer64">abs.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+abs">abs</a></code> </td><td style="text-align: left;"> returns integer64 </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+sign.integer64">sign.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+sign">sign</a></code> </td><td style="text-align: left;"> returns integer64 </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+log.integer64">log.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+log">log</a></code> </td><td style="text-align: left;"> returns double </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+log10.integer64">log10.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+log10">log10</a></code> </td><td style="text-align: left;">  returns double </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+log2.integer64">log2.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+log2">log2</a></code> </td><td style="text-align: left;">  returns double </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+sqrt.integer64">sqrt.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+sqrt">sqrt</a></code> </td><td style="text-align: left;">  returns double </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+ceiling.integer64">ceiling.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+ceiling">ceiling</a></code> </td><td style="text-align: left;"> dummy returning its argument </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+floor.integer64">floor.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+floor">floor</a></code> </td><td style="text-align: left;"> dummy returning its argument </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+trunc.integer64">trunc.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+trunc">trunc</a></code> </td><td style="text-align: left;"> dummy returning its argument </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+round.integer64">round.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+round">round</a></code> </td><td style="text-align: left;"> dummy returning its argument </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+signif.integer64">signif.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+signif">signif</a></code> </td><td style="text-align: left;"> dummy returning its argument </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td>
</tr>
<tr>
 <td style="text-align: right;">
   <b>cumulative functions</b> </td><td style="text-align: right;"> <b>see also</b>          </td><td style="text-align: left;"> <b>description</b> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+cummin.integer64">cummin.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+cummin">cummin</a></code> </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+cummax.integer64">cummax.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+cummax">cummax</a></code> </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+cumsum.integer64">cumsum.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+cumsum">cumsum</a></code> </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+cumprod.integer64">cumprod.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+cumprod">cumprod</a></code> </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+diff.integer64">diff.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+diff">diff</a></code> </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td>
</tr>
<tr>
 <td style="text-align: right;">
   <b>summary functions</b> </td><td style="text-align: right;"> <b>see also</b>          </td><td style="text-align: left;"> <b>description</b> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+range.integer64">range.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+range">range</a></code> </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+min.integer64">min.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+min">min</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+max.integer64">max.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+max">max</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+sum.integer64">sum.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+sum">sum</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+mean.integer64">mean.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+mean">mean</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+prod.integer64">prod.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+prod">prod</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+all.integer64">all.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+all">all</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+any.integer64">any.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+any">any</a></code> </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td>
</tr>
<tr>
 <td style="text-align: right;">
   <b>algorithmically complex functions</b> </td><td style="text-align: right;"> <b>see also</b>          </td><td style="text-align: left;"> <b>description (caching)</b>  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+match.integer64">match.integer64</a></code> </td><td style="text-align: right;"> <code><a href="#topic+match">match</a></code> </td><td style="text-align: left;"> position of x in table (h//o/so) </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic++25in+25.integer64">%in%.integer64</a></code> </td><td style="text-align: right;"> <code><a href="#topic++25in+25">%in%</a></code> </td><td style="text-align: left;"> is x in table? (h//o/so) </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+duplicated.integer64">duplicated.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+duplicated">duplicated</a></code> </td><td style="text-align: left;"> is current element duplicate of previous one? (h//o/so) </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+unique.integer64">unique.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+unique">unique</a></code> </td><td style="text-align: left;"> (shorter) vector of unique values only (h/s/o/so) </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+unipos.integer64">unipos.integer64</a></code> </td><td style="text-align: right;"> <code><a href="#topic+unipos">unipos</a></code> </td><td style="text-align: left;"> positions corresponding to unique values (h/s/o/so) </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+tiepos.integer64">tiepos.integer64</a></code> </td><td style="text-align: right;"> <code><a href="#topic+tiepos">tiepos</a></code> </td><td style="text-align: left;"> positions of values that are tied (//o/so) </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+keypos.integer64">keypos.integer64</a></code> </td><td style="text-align: right;"> <code><a href="#topic+keypos">keypos</a></code> </td><td style="text-align: left;"> position of current value in sorted list of unique values (//o/so) </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+as.factor.integer64">as.factor.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+as.factor">as.factor</a></code> </td><td style="text-align: left;"> convert to (unordered) factor with sorted levels of previous values (//o/so) </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+as.ordered.integer64">as.ordered.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+as.ordered">as.ordered</a></code> </td><td style="text-align: left;"> convert to ordered factor with sorted levels of previous values (//o/so) </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+table.integer64">table.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+table">table</a></code> </td><td style="text-align: left;"> unique values and their frequencies (h/s/o/so) </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+sort.integer64">sort.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+sort">sort</a></code> </td><td style="text-align: left;"> sorted vector (/s/o/so) </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+order.integer64">order.integer64</a></code> </td><td style="text-align: right;"> <code><a href="#topic+order">order</a></code> </td><td style="text-align: left;"> positions of elements that would create sorted vector (//o/so) </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+rank.integer64">rank.integer64</a></code> </td><td style="text-align: right;"> <code><a href="#topic+rank">rank</a></code> </td><td style="text-align: left;"> (average) ranks of non-NAs, NAs kept in place (/s/o/so) </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+quantile.integer64">quantile.integer64</a></code> </td><td style="text-align: right;"> <code><a href="stats.html#topic+quantile">quantile</a></code> </td><td style="text-align: left;"> (existing) values at specified percentiles (/s/o/so) </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+median.integer64">median.integer64</a></code> </td><td style="text-align: right;"> <code><a href="stats.html#topic+median">median</a></code> </td><td style="text-align: left;"> (existing) value at percentile 0.5 (/s/o/so) </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+summary.integer64">summary.integer64</a></code> </td><td style="text-align: right;"> <code><a href="base.html#topic+summary">summary</a></code> </td><td style="text-align: left;">  (/s/o/so) </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+all.equal.integer64">all.equal.integer64</a></code> </td><td style="text-align: right;"> <code><a href="Matrix.html#topic+all.equal">all.equal</a></code> </td><td style="text-align: left;"> test if two objects are (nearly) equal (/s/o/so) </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td>
</tr>
<tr>
 <td style="text-align: right;">
   <b>helper functions</b> </td><td style="text-align: right;"> <b>see also</b>          </td><td style="text-align: left;"> <b>description</b> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+minusclass">minusclass</a></code> </td><td style="text-align: right;"> <code><a href="#topic+minusclass">minusclass</a></code> </td><td style="text-align: left;"> removing class attritbute </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+plusclass">plusclass</a></code> </td><td style="text-align: right;"> <code><a href="#topic+plusclass">plusclass</a></code> </td><td style="text-align: left;"> inserting class attribute </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code><a href="#topic+binattr">binattr</a></code> </td><td style="text-align: right;"> <code><a href="#topic+binattr">binattr</a></code> </td><td style="text-align: left;"> define binary op behaviour </td>
</tr>
<tr>
 <td style="text-align: right;">
 </td>
</tr>
<tr>
 <td style="text-align: right;">
   <b>tested I/O functions</b> </td><td style="text-align: right;"> <b>see also</b>          </td><td style="text-align: left;"> <b>description</b> </td>
</tr>
<tr>
 <td style="text-align: right;">
                               </td><td style="text-align: right;"> <code><a href="utils.html#topic+read.table">read.table</a></code> </td><td style="text-align: left;"> inherited from Base R </td>
</tr>
<tr>
 <td style="text-align: right;">
                               </td><td style="text-align: right;"> <code><a href="utils.html#topic+write.table">write.table</a></code> </td><td style="text-align: left;"> inherited from Base R </td>
</tr>
<tr>
 <td style="text-align: right;">
                               </td><td style="text-align: right;"> <code><a href="base.html#topic+serialize">serialize</a></code> </td><td style="text-align: left;"> inherited from Base R </td>
</tr>
<tr>
 <td style="text-align: right;">
                               </td><td style="text-align: right;"> <code><a href="base.html#topic+unserialize">unserialize</a></code> </td><td style="text-align: left;"> inherited from Base R </td>
</tr>
<tr>
 <td style="text-align: right;">
                               </td><td style="text-align: right;"> <code><a href="base.html#topic+save">save</a></code> </td><td style="text-align: left;"> inherited from Base R </td>
</tr>
<tr>
 <td style="text-align: right;">
                               </td><td style="text-align: right;"> <code><a href="base.html#topic+load">load</a></code> </td><td style="text-align: left;"> inherited from Base R </td>
</tr>
<tr>
 <td style="text-align: right;">
                               </td><td style="text-align: right;"> <code><a href="base.html#topic+dput">dput</a></code> </td><td style="text-align: left;"> inherited from Base R </td>
</tr>
<tr>
 <td style="text-align: right;">
                               </td><td style="text-align: right;"> <code><a href="base.html#topic+dget">dget</a></code> </td><td style="text-align: left;"> inherited from Base R </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>



<h3>Limitations inherited from implementing 64 bit integers via an external package</h3>


<ul>
<li> <p><b>vector size</b> of atomic vectors is still limited to <code><a href="base.html#topic+.Machine">.Machine</a>$integer.max</code>. 
However, external memory extending packages such as <code>ff</code> or <code>bigmemory</code> 
can extend their address space now with <code>integer64</code>. Having 64 bit integers also help 
with those not so obvious address issues that arise once we exchange data with SQL databases 
and datawarehouses, which use big integers as surrogate keys, e.g. on indexed primary key columns.
This puts R into a relatively strong position compared to certain commercial statistical 
softwares, which sell database connectivity but neither have the range of 64 bit integers, 
nor have integers at all, nor have a single numeric data type in their macro-glue-language.
</p>
</li>
<li> <p><b>literals</b> such as <code>123LL</code> would require changes to Base R, up to then we need to write (and call) 
<code>as.integer64(123L)</code> or <code>as.integer64(123)</code> or <code>as.integer64('123')</code>. 
Only the latter allows to specify numbers beyond Base R's numeric data types and therefore is the recommended
way to use &ndash; using only one way may facilitate migrating code to literals at a later stage.
</p>
</li></ul>



<h3>Limitations inherited from Base R, Core team, can you change this?</h3>


<ul>
<li> <p><b><code><a href="base.html#topic+identical">identical</a></code></b> with default parameters does not distinguish all bit-patterns of doubles. 
For testing purposes we provide a wrapper <code><a href="#topic+identical.integer64">identical.integer64</a></code> that will distinguish all bit-patterns.
It would be desireable to have a single call of <code><a href="base.html#topic+identical">identical</a></code> handle both, <code><a href="base.html#topic+double">double</a></code> and <code>integer64</code>.
</p>
</li>
<li><p> the <b>colon</b> operator <code><a href="#topic++3A">:</a></code> officially does not dispatches S3 methods, however, we have made it generic
</p>
<pre>
     from &lt;- lim.integer64()[1]
     to &lt;- from+99
     from:to
   </pre>
<p>As a limitation remains: it will only dispatch at its first argument <code>from</code> but not at its second <code>to</code>.
</p>
</li>
<li> <p><b><code><a href="#topic+is.double">is.double</a></code></b> does not dispatches S3 methods, However, we have made it generic 
and it will return <code>FALSE</code> on <code>integer64</code>.
</p>
</li>
<li> <p><b><code><a href="base.html#topic+c">c</a></code></b> only dispatches <code><a href="#topic+c.integer64">c.integer64</a></code> if the first argument is <code>integer64</code>
and it does not recursively dispatch the proper method when called with argument <code>recursive=TRUE</code>
Therefore </p>
<pre>
      c(list(integer64,integer64))
    </pre>
<p>does not work and for now you can only call </p>
<pre>
       c.integer64(list(x,x))
     </pre>
</li>
<li> <p><b>generic binary operators</b> fail to dispatch *any* user-defined S3 method 
if the two arguments have two different S3 classes. For example we have two classes 
<code><a href="bit.html#topic+bit">bit</a></code> and <code><a href="bit.html#topic+bitwhich">bitwhich</a></code> sparsely representing boolean vectors 
and we have methods <code><a href="bit.html#topic++26.bit">&amp;.bit</a></code> and <code><a href="bit.html#topic++26.bitwhich">&amp;.bitwhich</a></code>. For an expression
involving both as in <code> bit &amp; bitwhich</code>, none of the two methods is dispatched. 
Instead a standard method is dispatched, which neither handles <code><a href="bit.html#topic+bit">bit</a></code> 
nor <code><a href="bit.html#topic+bitwhich">bitwhich</a></code>. Although it lacks symmetry, the better choice would be to 
dispatch simply the method of the class of the first argument in case of class conflict. 
This choice would allow authors of extension packages providing coherent behaviour 
at least within their contributed classes. But as long as none of the package authors 
methods is dispatched, he cannot handle the conflicting classes at all.
</p>
</li>
<li> <p><b><code><a href="base.html#topic+unlist">unlist</a></code></b> is not generic and if it were, we would face similar problems as with <code>c()</code>
</p>
</li>
<li> <p><b><code><a href="base.html#topic+vector">vector</a></code></b> with argument <code>mode='integer64'</code> cannot work without adjustment of Base R
</p>
</li>
<li> <p><b><code><a href="base.html#topic+as.vector">as.vector</a></code></b> with argument <code>mode='integer64'</code> cannot work without adjustment of Base R
</p>
</li>
<li> <p><b><code><a href="base.html#topic+is.vector">is.vector</a></code></b> does not dispatch its method <code><a href="#topic+is.vector.integer64">is.vector.integer64</a></code>
</p>
</li>
<li> <p><b><code><a href="base.html#topic+mode+3C-">mode&lt;-</a></code></b> drops the class 'integer64' which is returned from <code>as.integer64</code>.
Also it does not remove an existing class 'integer64' when assigning mode 'integer'. 
</p>
</li>
<li> <p><b><code><a href="base.html#topic+storage.mode+3C-">storage.mode&lt;-</a></code></b> does not support external data types such as <code>as.integer64</code>
</p>
</li>
<li> <p><b><code><a href="base.html#topic+matrix">matrix</a></code></b> does drop the 'integer64' class attribute.
</p>
</li>
<li> <p><b><code><a href="base.html#topic+array">array</a></code></b>  does drop the 'integer64' class attribute. 
In current R versions (1.15.1) this can be circumvented by activating the function 
<code>as.vector.integer64</code> further down this file.
However, the CRAN maintainer has requested to remove <code>as.vector.integer64</code>, 
even at the price of breaking previously working functionality of the package. 
</p>
</li>
<li> <p><b><code><a href="utils.html#topic+str">str</a></code></b> does not print the values of <code>integer64</code> correctly
</p>
</li></ul>



<h3>further limitations</h3>


<ul>
<li> <p><b>subscripting</b> non-existing elements and subscripting with <code>NA</code>s is currently not supported. 
Such subscripting currently returns <code>9218868437227407266</code> instead of <code>NA</code> (the <code>NA</code> value of the underlying double code).
Following the full R behaviour here would either destroy performance or require extensive C-coding. 
</p>
</li></ul>



<h3>Note</h3>

<p><code>integer64</code> are useful for handling database keys and exact counting in +-2^63.
Do not use them as replacement for 32bit integers, integer64 are not
supported for subscripting by R-core and they have different semantics 
when combined with double. Do understand that <code>integer64</code> can only be
useful over <code>double</code> if we do not coerce it to <code>double</code>. <br />
<br />
While <br />
integer + double -&gt; double + double -&gt; double <br />
or <br />
1L + 0.5 -&gt; 1.5 <br /> 
for additive operations we coerce to <code>integer64</code> <br />
integer64 + double -&gt;  integer64 + integer64 -&gt; integer64 <br />
hence <br />
as.integer64(1) + 0.5 -&gt; 1LL + 0LL -&gt; 1LL <br />
<br />
see section &quot;Arithmetic precision and coercion&quot; above
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel &lt;Jens.Oehlschlaegel@truecluster.com&gt;
Maintainer: Jens Oehlschlägel &lt;Jens.Oehlschlaegel@truecluster.com&gt;
</p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+integer">integer</a></code> in base R </p>


<h3>Examples</h3>

<pre><code class='language-R'>message("Using integer64 in vector")
x &lt;- integer64(8)    # create 64 bit vector
x
is.atomic(x)         # TRUE
is.integer64(x)      # TRUE
is.numeric(x)        # TRUE
is.integer(x)        # FALSE - debatable
is.double(x)         # FALSE - might change
x[] &lt;- 1:2           # assigned value is recycled as usual
x[1:6]               # subscripting as usual
length(x) &lt;- 13      # changing length as usual
x
rep(x, 2)            # replicate as usual
seq(as.integer64(1), 10)     # seq.integer64 is dispatched on first given argument
seq(to=as.integer64(10), 1)  # seq.integer64 is dispatched on first given argument
seq.integer64(along.with=x)  # or call seq.integer64 directly
# c.integer64 is dispatched only if *first* argument is integer64 ...
x &lt;- c(x,runif(length(x), max=100)) 
# ... and coerces everything to integer64 - including double
x                                   
names(x) &lt;- letters  # use names as usual
x

message("Using integer64 in array - note that 'matrix' currently does not work")
message("as.vector.integer64 removed as requested by the CRAN maintainer")
message("as consequence 'array' also does not work anymore")

message("we still can create a matrix or array by assigning 'dim'")
y &lt;- rep(as.integer64(NA), 12)
dim(y) &lt;- c(3,4)
dimnames(y) &lt;- list(letters[1:3], LETTERS[1:4])
y["a",] &lt;- 1:2       # assigning as usual
y
y[1:2,-4]            # subscripting as usual
# cbind.integer64 dispatched on any argument and coerces everything to integer64
cbind(E=1:3, F=runif(3, 0, 100), G=c("-1","0","1"), y)

message("Using integer64 in data.frame")
str(as.data.frame(x))
str(as.data.frame(y))
str(data.frame(y))
str(data.frame(I(y)))
d &lt;- data.frame(x=x, y=runif(length(x), 0, 100))
d
d$x

message("Using integer64 with csv files")
fi64 &lt;- tempfile()
write.csv(d, file=fi64, row.names=FALSE)
e &lt;- read.csv(fi64, colClasses=c("integer64", NA))
unlink(fi64)
str(e)
identical.integer64(d$x,e$x)

message("Serializing and unserializing integer64")
dput(d, fi64)
e &lt;- dget(fi64)
identical.integer64(d$x,e$x)
e &lt;- d[,]
save(e, file=fi64)
rm(e)
load(file=fi64)
identical.integer64(d,e)

### A couple of unit tests follow hidden in a dontshow{} directive ###
  

  ## Not run: 
message("== Differences between integer64 and int64 ==")
require(bit64)
require(int64)

message("-- integer64 is atomic --")
is.atomic(integer64())
#is.atomic(int64())
str(integer64(3))
#str(int64(3))

message("-- The following performance numbers are measured under RWin64  --")
message("-- under RWin32 the advantage of integer64 over int64 is smaller --")

message("-- integer64 needs 7x/5x less RAM than int64 under 64/32 bit OS 
(and twice the RAM of integer as it should be) --")
#as.vector(object.size(int64(1e6))/object.size(integer64(1e6)))
as.vector(object.size(integer64(1e6))/object.size(integer(1e6)))

message("-- integer64 creates 2000x/1300x faster than int64 under 64/32 bit OS
(and 3x the time of integer) --")
t32 &lt;- system.time(integer(1e8))
t64 &lt;- system.time(integer64(1e8))
#T64 &lt;- system.time(int64(1e7))*10  # using 1e8 as above stalls our R on an i7 8 GB RAM Thinkpad
#T64/t64
t64/t32

i32 &lt;- sample(1e6)
d64 &lt;- as.double(i32)

message("-- the following timings are rather conservative since timings
 of integer64 include garbage collection -- due to looped calls")
message("-- integer64 coerces 900x/100x faster than int64 
 under 64/32 bit OS (and 2x the time of coercing to integer) --")
t32 &lt;- system.time(for(i in 1:1000)as.integer(d64))
t64 &lt;- system.time(for(i in 1:1000)as.integer64(d64))
#T64 &lt;- system.time(as.int64(d64))*1000
#T64/t64
t64/t32
td64 &lt;- system.time(for(i in 1:1000)as.double(i32))
t64 &lt;- system.time(for(i in 1:1000)as.integer64(i32))
#T64 &lt;- system.time(for(i in 1:10)as.int64(i32))*100
#T64/t64
t64/td64

message("-- integer64 serializes 4x/0.8x faster than int64 
 under 64/32 bit OS (and less than 2x/6x the time of integer or double) --")
t32 &lt;- system.time(for(i in 1:10)serialize(i32, NULL))
td64 &lt;- system.time(for(i in 1:10)serialize(d64, NULL))
i64 &lt;- as.integer64(i32); 
t64 &lt;- system.time(for(i in 1:10)serialize(i64, NULL))
rm(i64); gc()
#I64 &lt;- as.int64(i32); 
#T64 &lt;- system.time(for(i in 1:10)serialize(I64, NULL))
#rm(I64); gc()
#T64/t64
t64/t32
t64/td64


message("-- integer64 adds 250x/60x faster than int64
 under 64/32 bit OS (and less than 6x the time of integer or double) --")
td64 &lt;- system.time(for(i in 1:100)d64+d64)
t32 &lt;- system.time(for(i in 1:100)i32+i32)
i64 &lt;- as.integer64(i32); 
t64 &lt;- system.time(for(i in 1:100)i64+i64)
rm(i64); gc()
#I64 &lt;- as.int64(i32); 
#T64 &lt;- system.time(for(i in 1:10)I64+I64)*10
#rm(I64); gc()
#T64/t64
t64/t32
t64/td64

message("-- integer64 sums 3x/0.2x faster than int64 
(and at about 5x/60X the time of integer and double) --")
td64 &lt;- system.time(for(i in 1:100)sum(d64))
t32 &lt;- system.time(for(i in 1:100)sum(i32))
i64 &lt;- as.integer64(i32); 
t64 &lt;- system.time(for(i in 1:100)sum(i64))
rm(i64); gc()
#I64 &lt;- as.int64(i32); 
#T64 &lt;- system.time(for(i in 1:100)sum(I64))
#rm(I64); gc()
#T64/t64
t64/t32
t64/td64

message("-- integer64 diffs 5x/0.85x faster than integer and double
(int64 version 1.0 does not support diff) --")
td64 &lt;- system.time(for(i in 1:10)diff(d64, lag=2L, differences=2L))
t32 &lt;- system.time(for(i in 1:10)diff(i32, lag=2L, differences=2L))
i64 &lt;- as.integer64(i32); 
t64 &lt;- system.time(for(i in 1:10)diff(i64, lag=2L, differences=2L))
rm(i64); gc()
t64/t32
t64/td64


message("-- integer64 subscripts 1000x/340x faster than int64
(and at the same speed / 10x slower as integer) --")
ts32 &lt;- system.time(for(i in 1:1000)sample(1e6, 1e3))
t32&lt;- system.time(for(i in 1:1000)i32[sample(1e6, 1e3)])
i64 &lt;- as.integer64(i32); 
t64 &lt;- system.time(for(i in 1:1000)i64[sample(1e6, 1e3)])
rm(i64); gc()
#I64 &lt;- as.int64(i32); 
#T64 &lt;- system.time(for(i in 1:100)I64[sample(1e6, 1e3)])*10
#rm(I64); gc()
#(T64-ts32)/(t64-ts32)
(t64-ts32)/(t32-ts32)

message("-- integer64 assigns 200x/90x faster than int64
(and 50x/160x slower than integer) --")
ts32 &lt;- system.time(for(i in 1:100)sample(1e6, 1e3))
t32 &lt;- system.time(for(i in 1:100)i32[sample(1e6, 1e3)] &lt;- 1:1e3)
i64 &lt;- as.integer64(i32); 
i64 &lt;- system.time(for(i in 1:100)i64[sample(1e6, 1e3)] &lt;- 1:1e3)
rm(i64); gc()
#I64 &lt;- as.int64(i32); 
#I64 &lt;- system.time(for(i in 1:10)I64[sample(1e6, 1e3)] &lt;- 1:1e3)*10
#rm(I64); gc()
#(T64-ts32)/(t64-ts32)
(t64-ts32)/(t32-ts32)


tdfi32 &lt;- system.time(dfi32 &lt;- data.frame(a=i32, b=i32, c=i32))
tdfsi32 &lt;- system.time(dfi32[1e6:1,])
fi32 &lt;- tempfile()
tdfwi32 &lt;- system.time(write.csv(dfi32, file=fi32, row.names=FALSE))
tdfri32 &lt;- system.time(read.csv(fi32, colClasses=rep("integer", 3)))
unlink(fi32)
rm(dfi32); gc()

i64 &lt;- as.integer64(i32); 
tdfi64 &lt;- system.time(dfi64 &lt;- data.frame(a=i64, b=i64, c=i64))
tdfsi64 &lt;- system.time(dfi64[1e6:1,])
fi64 &lt;- tempfile()
tdfwi64 &lt;- system.time(write.csv(dfi64, file=fi64, row.names=FALSE))
tdfri64 &lt;- system.time(read.csv(fi64, colClasses=rep("integer64", 3)))
unlink(fi64)
rm(i64, dfi64); gc()

#I64 &lt;- as.int64(i32); 
#tdfI64 &lt;- system.time(dfI64&lt;-data.frame(a=I64, b=I64, c=I64))
#tdfsI64 &lt;- system.time(dfI64[1e6:1,])
#fI64 &lt;- tempfile()
#tdfwI64 &lt;- system.time(write.csv(dfI64, file=fI64, row.names=FALSE))
#tdfrI64 &lt;- system.time(read.csv(fI64, colClasses=rep("int64", 3)))
#unlink(fI64)
#rm(I64, dfI64); gc()

message("-- integer64 coerces 40x/6x faster to data.frame than int64
(and factor 1/9 slower than integer) --")
#tdfI64/tdfi64
tdfi64/tdfi32
message("-- integer64 subscripts from data.frame 20x/2.5x faster than int64
 (and 3x/13x slower than integer) --")
#tdfsI64/tdfsi64
tdfsi64/tdfsi32
message("-- integer64 csv writes about 2x/0.5x faster than int64
(and about 1.5x/5x slower than integer) --")
#tdfwI64/tdfwi64
tdfwi64/tdfwi32
message("-- integer64 csv reads about 3x/1.5 faster than int64
(and about 2x slower than integer) --")
#tdfrI64/tdfri64
tdfri64/tdfri32

rm(i32, d64); gc()


message("-- investigating the impact on garbage collection: --")
message("-- the fragmented structure of int64 messes up R's RAM --")
message("-- and slows down R's gargbage collection just by existing --")

td32 &lt;- double(21)
td32[1] &lt;- system.time(d64 &lt;- double(1e7))[3]
for (i in 2:11)td32[i] &lt;- system.time(gc(), gcFirst=FALSE)[3]
rm(d64)
for (i in 12:21)td32[i] &lt;- system.time(gc(), gcFirst=FALSE)[3]

t64 &lt;- double(21)
t64[1] &lt;- system.time(i64 &lt;- integer64(1e7))[3]
for (i in 2:11)t64[i] &lt;- system.time(gc(), gcFirst=FALSE)[3]
rm(i64)
for (i in 12:21)t64[i] &lt;- system.time(gc(), gcFirst=FALSE)[3]

#T64 &lt;- double(21)
#T64[1] &lt;- system.time(I64 &lt;- int64(1e7))[3]
#for (i in 2:11)T64[i] &lt;- system.time(gc(), gcFirst=FALSE)[3]
#rm(I64)
#for (i in 12:21)T64[i] &lt;- system.time(gc(), gcFirst=FALSE)[3]

#matplot(1:21, cbind(td32, t64, T64), pch=c("d","i","I"), log="y")
matplot(1:21, cbind(td32, t64), pch=c("d","i"), log="y")
  
## End(Not run)

</code></pre>

<hr>
<h2 id='bit64S3'>
Turning base R functions into S3 generics for bit64 
</h2><span id='topic+bit64S3'></span><span id='topic++3A'></span><span id='topic++3A.default'></span><span id='topic++3A.integer64'></span><span id='topic+is.double'></span><span id='topic+is.double.default'></span><span id='topic+is.double.integer64'></span><span id='topic+match'></span><span id='topic+match.default'></span><span id='topic++25in+25'></span><span id='topic++25in+25.default'></span><span id='topic+rank'></span><span id='topic+rank.default'></span><span id='topic+order'></span><span id='topic+order.default'></span>

<h3>Description</h3>

<p>Turn those base functions S3 generic which are used in bit64
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	from:to
 #--as-cran complains about \method{:}{default}(from, to)
 #--as-cran complains about \method{:}{integer64}(from, to)
	is.double(x)
 ## Default S3 method:
is.double(x)
 ## S3 method for class 'integer64'
is.double(x)
	match(x, table, ...)
 ## Default S3 method:
match(x, table, ...)
	x %in% table
 ## Default S3 method:
x %in% table
	rank(x, ...)
 ## Default S3 method:
rank(x, ...)
	
 
	order(...)
 ## Default S3 method:
order(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bit64S3_+3A_x">x</code></td>
<td>

<p>integer64 vector: the values to be matched, optionally carrying a cache created with <code><a href="#topic+hashcache">hashcache</a></code>
</p>
</td></tr>
<tr><td><code id="bit64S3_+3A_table">table</code></td>
<td>

<p>integer64 vector: the values to be matched against, optionally carrying a cache created with <code><a href="#topic+hashcache">hashcache</a></code> or <code><a href="#topic+sortordercache">sortordercache</a></code>
</p>
</td></tr>
<tr><td><code id="bit64S3_+3A_from">from</code></td>
<td>
<p> scalar denoting first element of sequence </p>
</td></tr>
<tr><td><code id="bit64S3_+3A_to">to</code></td>
<td>
<p> scalar denoting last element of sequence </p>
</td></tr>
<tr><td><code id="bit64S3_+3A_...">...</code></td>
<td>
<p> ignored </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following functions are turned into S3 gernerics in order to dispatch methods for <code><a href="#topic+integer64">integer64</a></code>: 
</p>
<pre>
	   \code{\link{:}}
	   \code{\link{is.double}}
	   \code{\link{match}}
	   \code{\link{%in%}}
	   
	   \code{\link{rank}}
	   \code{\link{order}}
   </pre>


<h3>Value</h3>

<p><code><a href="base.html#topic+invisible">invisible</a></code>
</p>


<h3>Note</h3>

<p><code><a href="#topic+is.double">is.double</a></code> returns <code>FALSE</code> for <code><a href="#topic+integer64">integer64</a></code> <br />
<code><a href="#topic++3A">:</a></code> currently only dispatches at its first argument, thus <code>as.integer64(1):9</code> works but <code>1:as.integer64(9)</code> doesn't
<code><a href="#topic+match">match</a></code> currently only dispatches at its first argument and expects its second argument also to be integer64, otherwise throws an error. Beware of something like <code>match(2, as.integer64(0:3))</code>
<code><a href="#topic++25in+25">%in%</a></code> currently only dispatches at its first argument and expects its second argument also to be integer64, otherwise throws an error. Beware of something like <code>2 %in% as.integer64(0:3)</code>
<code><a href="#topic+order">order</a></code> currently only orders a single argument, trying more than one raises an error
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel &lt;Jens.Oehlschlaegel@truecluster.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bit64">bit64</a></code>, <code><a href="methods.html#topic+S3">S3</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> is.double(as.integer64(1))
	as.integer64(1):9
 match(as.integer64(2), as.integer64(0:3))
 as.integer64(2) %in% as.integer64(0:3)
 
 unique(as.integer64(c(1,1,2)))
 rank(as.integer64(c(1,1,2)))
 
 
 
 
 
 
 order(as.integer64(c(1,NA,2)))
 
 
</code></pre>

<hr>
<h2 id='c.integer64'>
Concatenating integer64 vectors
</h2><span id='topic+c.integer64'></span><span id='topic+cbind.integer64'></span><span id='topic+rbind.integer64'></span>

<h3>Description</h3>

<p>The ususal functions 'c', 'cbind' and 'rbind'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'integer64'
c(..., recursive = FALSE)
## S3 method for class 'integer64'
cbind(...)
## S3 method for class 'integer64'
rbind(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c.integer64_+3A_...">...</code></td>
<td>
<p> two or more arguments coerced to 'integer64' and passed to <code><a href="base.html#topic+NextMethod">NextMethod</a></code> </p>
</td></tr>
<tr><td><code id="c.integer64_+3A_recursive">recursive</code></td>
<td>
<p> logical. If <code>recursive = TRUE</code>, the function recursively descends through lists (and pairlists) combining all their elements into a vector. </p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="base.html#topic+c">c</a></code> returns a integer64 vector of the total length of the input <br />
<code><a href="base.html#topic+cbind">cbind</a></code> and <code><a href="base.html#topic+rbind">rbind</a></code> return a integer64 matrix
</p>


<h3>Note</h3>

<p>R currently only dispatches generic 'c' to method 'c.integer64' if the first argument is 'integer64'
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel &lt;Jens.Oehlschlaegel@truecluster.com&gt;
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+rep.integer64">rep.integer64</a></code> <code><a href="#topic+seq.integer64">seq.integer64</a></code> 
<code><a href="#topic+as.data.frame.integer64">as.data.frame.integer64</a></code> <code><a href="#topic+integer64">integer64</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  c(as.integer64(1), 2:6)
  cbind(1:6, as.integer(1:6))
  rbind(1:6, as.integer(1:6))
</code></pre>

<hr>
<h2 id='cache'>
Atomic Caching
</h2><span id='topic+cache'></span><span id='topic+newcache'></span><span id='topic+jamcache'></span><span id='topic+setcache'></span><span id='topic+getcache'></span><span id='topic+remcache'></span><span id='topic+print.cache'></span>

<h3>Description</h3>

<p>Functions for caching results attached to atomic objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newcache(x)
jamcache(x)
cache(x)
setcache(x, which, value)
getcache(x, which)
remcache(x)
## S3 method for class 'cache'
print(x, all.names = FALSE, pattern, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cache_+3A_x">x</code></td>
<td>

<p>an integer64 vector (or a cache object in case of <code>print.cache</code>)
</p>
</td></tr>
<tr><td><code id="cache_+3A_which">which</code></td>
<td>

<p>A character naming the object to be retrieved from the cache or to be stored in the cache
</p>
</td></tr>
<tr><td><code id="cache_+3A_value">value</code></td>
<td>

<p>An object to be stored in the cache 
</p>
</td></tr>
<tr><td><code id="cache_+3A_all.names">all.names</code></td>
<td>

<p>passed to <code><a href="base.html#topic+ls">ls</a></code> when listing the cache content
</p>
</td></tr>
<tr><td><code id="cache_+3A_pattern">pattern</code></td>
<td>

<p>passed to <code><a href="base.html#topic+ls">ls</a></code> when listing the cache content
</p>
</td></tr>
<tr><td><code id="cache_+3A_...">...</code></td>
<td>

<p>ignored
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>cache</code> is an <code>link{environment}</code> attached to an atomic object with the <code>link{attrib}</code> name 'cache'. 
It contains at least a reference to the atomic object that carries the cache. 
This is used when accessing the cache to detect whether the object carrying the cache has been modified meanwhile.
Function <code>newcache(x)</code> creates a new cache referencing  <code>x</code> <br />
Function <code>jamcache(x)</code> forces <code>x</code> to have a cache <br />
Function <code>cache(x)</code> returns the cache attached to <code>x</code> if it is not found to be outdated <br />
Function <code>setcache(x, which, value)</code> assigns a value into the cache of <code>x</code> <br />
Function <code>getcache(x, which)</code> gets cache value 'which' from <code>x</code> <br />
Function <code>remcache</code> removes the cache from <code>x</code> <br />
</p>


<h3>Value</h3>

<p>see details
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel &lt;Jens.Oehlschlaegel@truecluster.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="bit.html#topic+still.identical">still.identical</a></code> for testing whether to symbols point to the same RAM. <br />
Functions that get and set small cache-content automatically when a cache is present: <code><a href="bit.html#topic+na.count">na.count</a></code>, <code><a href="bit.html#topic+nvalid">nvalid</a></code>, <code><a href="bit.html#topic+is.sorted">is.sorted</a></code>, <code><a href="bit.html#topic+nunique">nunique</a></code> and <code><a href="bit.html#topic+nties">nties</a></code> <br />
Setting big caches with a relevant memory footprint requires a conscious decision of the user: <code><a href="#topic+hashcache">hashcache</a></code>, <code><a href="#topic+sortcache">sortcache</a></code>, <code><a href="#topic+ordercache">ordercache</a></code> and <code><a href="#topic+sortordercache">sortordercache</a></code> <br />
Functions that use big caches: <code><a href="#topic+match.integer64">match.integer64</a></code>, <code><a href="#topic++25in+25.integer64">%in%.integer64</a></code>, <code><a href="#topic+duplicated.integer64">duplicated.integer64</a></code>, <code><a href="#topic+unique.integer64">unique.integer64</a></code>, <code><a href="#topic+unipos">unipos</a></code>, <code><a href="#topic+table.integer64">table.integer64</a></code>, <code><a href="#topic+as.factor.integer64">as.factor.integer64</a></code>, <code><a href="#topic+as.ordered.integer64">as.ordered.integer64</a></code>, <code><a href="#topic+keypos">keypos</a></code>, <code><a href="#topic+tiepos">tiepos</a></code>, <code><a href="#topic+rank.integer64">rank.integer64</a></code>, <code><a href="#topic+prank">prank</a></code>, <code><a href="#topic+qtile">qtile</a></code>, <code><a href="#topic+quantile.integer64">quantile.integer64</a></code>, <code><a href="#topic+median.integer64">median.integer64</a></code> and <code><a href="#topic+summary.integer64">summary.integer64</a></code> <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	x &lt;- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
	y &lt;- x
	still.identical(x,y)
	y[1] &lt;- NA
	still.identical(x,y)
	mycache &lt;- newcache(x)
	ls(mycache)
	mycache
	rm(mycache)
	jamcache(x)
	cache(x)
	x[1] &lt;- NA
	cache(x)
	getcache(x, "abc")
	setcache(x, "abc", 1)
	getcache(x, "abc")
	remcache(x)
	cache(x)
</code></pre>

<hr>
<h2 id='cumsum.integer64'>
Cumulative Sums, Products, Extremes and lagged differences
</h2><span id='topic+cummin.integer64'></span><span id='topic+cummax.integer64'></span><span id='topic+cumsum.integer64'></span><span id='topic+cumprod.integer64'></span><span id='topic+diff.integer64'></span>

<h3>Description</h3>

<p>Cumulative Sums, Products, Extremes and lagged differences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'integer64'
cummin(x)
## S3 method for class 'integer64'
cummax(x)
## S3 method for class 'integer64'
cumsum(x)
## S3 method for class 'integer64'
cumprod(x)
## S3 method for class 'integer64'
diff(x, lag = 1L, differences = 1L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cumsum.integer64_+3A_x">x</code></td>
<td>
<p> an atomic vector of class 'integer64'</p>
</td></tr>
<tr><td><code id="cumsum.integer64_+3A_lag">lag</code></td>
<td>
<p> see <code><a href="base.html#topic+diff">diff</a></code> </p>
</td></tr>
<tr><td><code id="cumsum.integer64_+3A_differences">differences</code></td>
<td>
<p> see <code><a href="base.html#topic+diff">diff</a></code> </p>
</td></tr>
<tr><td><code id="cumsum.integer64_+3A_...">...</code></td>
<td>
<p> ignored </p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="base.html#topic+cummin">cummin</a></code>, <code><a href="base.html#topic+cummax">cummax</a></code> , <code><a href="base.html#topic+cumsum">cumsum</a></code> and <code><a href="base.html#topic+cumprod">cumprod</a></code> 
return a integer64 vector of the same length as their input<br />
<code><a href="base.html#topic+diff">diff</a></code> returns a integer64 vector shorter by <code>lag*differences</code> elements <br />
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel &lt;Jens.Oehlschlaegel@truecluster.com&gt;
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+sum.integer64">sum.integer64</a></code> <code><a href="#topic+integer64">integer64</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>  cumsum(rep(as.integer64(1), 12))
  diff(as.integer64(c(0,1:12)))
  cumsum(as.integer64(c(0, 1:12)))
  diff(cumsum(as.integer64(c(0,0,1:12))), differences=2)
</code></pre>

<hr>
<h2 id='duplicated.integer64'>Determine Duplicate Elements of integer64</h2><span id='topic+duplicated.integer64'></span>

<h3>Description</h3>

<p><code>duplicated()</code> determines which elements of a vector or data frame are duplicates
of elements with smaller subscripts, and returns a logical vector
indicating which elements (rows) are duplicates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'integer64'
duplicated(x, incomparables = FALSE, nunique = NULL, method = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="duplicated.integer64_+3A_x">x</code></td>
<td>
<p>a vector or a data frame or an array or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="duplicated.integer64_+3A_incomparables">incomparables</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="duplicated.integer64_+3A_nunique">nunique</code></td>
<td>

<p>NULL or the number of unique values (including NA). Providing <code>nunique</code> can speed-up matching when <code>x</code> has no cache. Note that a wrong nunique can cause undefined behaviour up to a crash.
</p>
</td></tr>
<tr><td><code id="duplicated.integer64_+3A_method">method</code></td>
<td>

<p>NULL for automatic method selection or a suitable low-level method, see details
</p>
</td></tr>
<tr><td><code id="duplicated.integer64_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function automatically chooses from several low-level functions considering the size of <code>x</code> and the availability of a cache. 
</p>
<p>Suitable methods are <code><a href="#topic+hashdup">hashdup</a></code> (hashing), <code><a href="#topic+sortorderdup">sortorderdup</a></code> (fast ordering) and <code><a href="#topic+orderdup">orderdup</a></code> (memory saving ordering).
</p>


<h3>Value</h3>

<p><code>duplicated()</code>: a logical vector of the same length as <code>x</code>.  
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel &lt;Jens.Oehlschlaegel@truecluster.com&gt;
</p>


<h3>See Also</h3>

 <p><code><a href="base.html#topic+duplicated">duplicated</a></code>, <code><a href="#topic+unique.integer64">unique.integer64</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
duplicated(x)

stopifnot(identical(duplicated(x),  duplicated(as.integer(x))))
</code></pre>

<hr>
<h2 id='extract.replace.integer64'>
Extract or Replace Parts of an integer64 vector
</h2><span id='topic++5B.integer64'></span><span id='topic++5B+5B.integer64'></span><span id='topic++5B+5B+3C-.integer64'></span><span id='topic++5B+3C-.integer64'></span>

<h3>Description</h3>

<p>Methods to extract and replace parts of an integer64 vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> ## S3 method for class 'integer64'
x[i, ...]
 ## S3 replacement method for class 'integer64'
x[...] &lt;- value 
 ## S3 method for class 'integer64'
x[[...]]
 ## S3 replacement method for class 'integer64'
x[[...]] &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract.replace.integer64_+3A_x">x</code></td>
<td>
<p> an atomic vector </p>
</td></tr>
<tr><td><code id="extract.replace.integer64_+3A_i">i</code></td>
<td>
<p> indices specifying elements to extract </p>
</td></tr>
<tr><td><code id="extract.replace.integer64_+3A_value">value</code></td>
<td>
<p> an atomic vector with values to be assigned </p>
</td></tr>
<tr><td><code id="extract.replace.integer64_+3A_...">...</code></td>
<td>
<p> further arguments to the <code><a href="base.html#topic+NextMethod">NextMethod</a></code> </p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector or scalar of class 'integer64'
</p>


<h3>Note</h3>

<p>You should not subscript non-existing elements and not use <code>NA</code>s as subscripts.
The current implementation returns <code>9218868437227407266</code> instead of <code>NA</code>.
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel &lt;Jens.Oehlschlaegel@truecluster.com&gt;
</p>


<h3>See Also</h3>

 <p><code><a href="Matrix.html#topic++5B">[</a></code> <code><a href="#topic+integer64">integer64</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>  as.integer64(1:12)[1:3]
  x &lt;- as.integer64(1:12)
  dim(x) &lt;- c(3,4)
  x
  x[]
  x[,2:3]
  
</code></pre>

<hr>
<h2 id='format.integer64'>
Unary operators and functions for integer64 vectors
</h2><span id='topic+format.integer64'></span><span id='topic+is.na.integer64'></span><span id='topic+is.nan.integer64'></span><span id='topic+is.finite.integer64'></span><span id='topic+is.infinite.integer64'></span><span id='topic++21.integer64'></span><span id='topic+sign.integer64'></span><span id='topic+abs.integer64'></span><span id='topic+sqrt.integer64'></span><span id='topic+log.integer64'></span><span id='topic+log2.integer64'></span><span id='topic+log10.integer64'></span><span id='topic+floor.integer64'></span><span id='topic+ceiling.integer64'></span><span id='topic+trunc.integer64'></span><span id='topic+round.integer64'></span><span id='topic+signif.integer64'></span><span id='topic+scale.integer64'></span>

<h3>Description</h3>

<p>Unary operators and functions for integer64 vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'integer64'
format(x, justify="right", ...)
## S3 method for class 'integer64'
is.na(x)
## S3 method for class 'integer64'
is.nan(x)
## S3 method for class 'integer64'
is.finite(x)
## S3 method for class 'integer64'
is.infinite(x)
## S3 method for class 'integer64'
!x
## S3 method for class 'integer64'
sign(x)
## S3 method for class 'integer64'
abs(x)
## S3 method for class 'integer64'
sqrt(x)
## S3 method for class 'integer64'
log(x, base)
## S3 method for class 'integer64'
log2(x)
## S3 method for class 'integer64'
log10(x)
## S3 method for class 'integer64'
floor(x)
## S3 method for class 'integer64'
ceiling(x)
## S3 method for class 'integer64'
trunc(x, ...)
## S3 method for class 'integer64'
round(x, digits=0)
## S3 method for class 'integer64'
signif(x, digits=6)
## S3 method for class 'integer64'
scale(x, center = TRUE, scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format.integer64_+3A_x">x</code></td>
<td>
<p> an atomic vector of class 'integer64'</p>
</td></tr>
<tr><td><code id="format.integer64_+3A_base">base</code></td>
<td>
<p> an atomic scalar (we save 50% log-calls by not allowing a vector base) </p>
</td></tr>
<tr><td><code id="format.integer64_+3A_digits">digits</code></td>
<td>
<p> integer indicating the number of decimal places (round) or significant digits (signif) to be used. 
Negative values are allowed (see <code><a href="base.html#topic+round">round</a></code>) </p>
</td></tr>
<tr><td><code id="format.integer64_+3A_justify">justify</code></td>
<td>
<p> should it be right-justified (the default), left-justified, centred or left alone. </p>
</td></tr>
<tr><td><code id="format.integer64_+3A_center">center</code></td>
<td>
<p> see <code><a href="base.html#topic+scale">scale</a></code> </p>
</td></tr>
<tr><td><code id="format.integer64_+3A_scale">scale</code></td>
<td>
<p>  see <code><a href="base.html#topic+scale">scale</a></code> </p>
</td></tr>
<tr><td><code id="format.integer64_+3A_...">...</code></td>
<td>
<p> further arguments to the <code><a href="base.html#topic+NextMethod">NextMethod</a></code> </p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="base.html#topic+format">format</a></code> returns a character vector <br />
<code><a href="Matrix.html#topic+is.na">is.na</a></code> and <code><a href="base.html#topic++21">!</a></code> return a logical vector <br />
<code><a href="base.html#topic+sqrt">sqrt</a></code>, <code><a href="base.html#topic+log">log</a></code>, <code><a href="base.html#topic+log2">log2</a></code> and <code><a href="base.html#topic+log10">log10</a></code> return a double vector <br />
<code><a href="base.html#topic+sign">sign</a></code>, <code><a href="base.html#topic+abs">abs</a></code>, <code><a href="base.html#topic+floor">floor</a></code>, <code><a href="base.html#topic+ceiling">ceiling</a></code>, <code><a href="base.html#topic+trunc">trunc</a></code> and 
<code><a href="base.html#topic+round">round</a></code> return a vector of class 'integer64' <br />
<code><a href="base.html#topic+signif">signif</a></code> is not implemented 
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel &lt;Jens.Oehlschlaegel@truecluster.com&gt;
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+xor.integer64">xor.integer64</a></code> <code><a href="#topic+integer64">integer64</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>  sqrt(as.integer64(1:12))

</code></pre>

<hr>
<h2 id='hashcache'>
Big caching of hashing, sorting, ordering
</h2><span id='topic+hashcache'></span><span id='topic+sortcache'></span><span id='topic+sortordercache'></span><span id='topic+ordercache'></span>

<h3>Description</h3>

<p>Functions to create cache that accelerates many operations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hashcache(x, nunique=NULL, ...)
sortcache(x, has.na = NULL)
sortordercache(x, has.na = NULL, stable = NULL)
ordercache(x, has.na = NULL, stable = NULL, optimize = "time")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hashcache_+3A_x">x</code></td>
<td>

<p>an atomic vector (note that currently only integer64 is supported)
</p>
</td></tr>
<tr><td><code id="hashcache_+3A_nunique">nunique</code></td>
<td>
<p> giving <em>correct</em> number of unique elements can help reducing the size of the hashmap </p>
</td></tr>
<tr><td><code id="hashcache_+3A_has.na">has.na</code></td>
<td>

<p>boolean scalar defining whether the input vector might contain <code>NA</code>s. If we know we don't have NAs, this may speed-up.
<em>Note</em> that you risk a crash if there are unexpected <code>NA</code>s with <code>has.na=FALSE</code>
</p>
</td></tr>
<tr><td><code id="hashcache_+3A_stable">stable</code></td>
<td>

<p>boolean scalar defining whether stable sorting is needed. Allowing non-stable may speed-up.
</p>
</td></tr>
<tr><td><code id="hashcache_+3A_optimize">optimize</code></td>
<td>

<p>by default ramsort optimizes for 'time' which requires more RAM,
set to 'memory' to minimize RAM requirements and sacrifice speed
</p>
</td></tr>
<tr><td><code id="hashcache_+3A_...">...</code></td>
<td>

<p>passed to <code><a href="#topic+hashmap">hashmap</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The result of relative expensive operations <code><a href="#topic+hashmap">hashmap</a></code>, <code><a href="bit.html#topic+ramsort">ramsort</a></code>, <code><a href="bit.html#topic+ramsortorder">ramsortorder</a></code> and <code><a href="bit.html#topic+ramorder">ramorder</a></code> can be stored in a cache in order to avoid multiple excutions. Unless in very specific situations, the recommended method is <code>hashsortorder</code> only.
</p>


<h3>Value</h3>

<p><code>x</code> with a <code><a href="#topic+cache">cache</a></code> that contains the result of the expensive operations, possible together with small derived information (such as <code><a href="#topic+nunique.integer64">nunique.integer64</a></code>) and previously cached results.
</p>


<h3>Note</h3>

<p>Note that we consider storing the big results from sorting and/or ordering as a relevant side-effect, 
and therefore storing them in the cache should require a conscious decision of the user.
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel &lt;Jens.Oehlschlaegel@truecluster.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cache">cache</a></code> for caching functions and <code><a href="bit.html#topic+nunique">nunique</a></code> for methods bennefitting from small caches
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	x &lt;- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
 sortordercache(x)
</code></pre>

<hr>
<h2 id='hashmap'>
Hashing for 64bit integers
</h2><span id='topic+hashfun'></span><span id='topic+hashfun.integer64'></span><span id='topic+hashmap'></span><span id='topic+hashmap.integer64'></span><span id='topic+hashpos'></span><span id='topic+hashpos.cache_integer64'></span><span id='topic+hashrev'></span><span id='topic+hashrev.cache_integer64'></span><span id='topic+hashfin'></span><span id='topic+hashfin.cache_integer64'></span><span id='topic+hashrin'></span><span id='topic+hashrin.cache_integer64'></span><span id='topic+hashdup'></span><span id='topic+hashdup.cache_integer64'></span><span id='topic+hashuni'></span><span id='topic+hashuni.cache_integer64'></span><span id='topic+hashmapuni'></span><span id='topic+hashmapuni.integer64'></span><span id='topic+hashupo'></span><span id='topic+hashupo.cache_integer64'></span><span id='topic+hashmapupo'></span><span id='topic+hashmapupo.integer64'></span><span id='topic+hashtab'></span><span id='topic+hashtab.cache_integer64'></span><span id='topic+hashmaptab'></span><span id='topic+hashmaptab.integer64'></span>

<h3>Description</h3>

<p>This is an explicit implementation of hash functionality that underlies 
matching and other functions in R. Explicit means that you can create, 
store and use hash functionality directly. One advantage is that you can
re-use hashmaps, which avoid re-building hashmaps again and again.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hashfun(x, ...)
## S3 method for class 'integer64'
hashfun(x, minfac=1.41, hashbits=NULL, ...)
hashmap(x, ...)
## S3 method for class 'integer64'
hashmap(x, nunique=NULL, minfac=1.41, hashbits=NULL, cache=NULL, ...)
hashpos(cache, ...)
## S3 method for class 'cache_integer64'
hashpos(cache, x, nomatch = NA_integer_, ...)
hashrev(cache, ...)
## S3 method for class 'cache_integer64'
hashrev(cache, x, nomatch = NA_integer_, ...)
hashfin(cache, ...)
## S3 method for class 'cache_integer64'
hashfin(cache, x, ...)
hashrin(cache, ...)
## S3 method for class 'cache_integer64'
hashrin(cache, x, ...)
hashdup(cache, ...)
## S3 method for class 'cache_integer64'
hashdup(cache, ...)
hashuni(cache, ...)
## S3 method for class 'cache_integer64'
hashuni(cache, keep.order=FALSE, ...)
hashmapuni(x, ...)
## S3 method for class 'integer64'
hashmapuni(x, nunique=NULL, minfac=1.5, hashbits=NULL, ...)
hashupo(cache, ...)
## S3 method for class 'cache_integer64'
hashupo(cache, keep.order=FALSE, ...)
hashmapupo(x, ...)
## S3 method for class 'integer64'
hashmapupo(x, nunique=NULL, minfac=1.5, hashbits=NULL, ...)
hashtab(cache, ...)
## S3 method for class 'cache_integer64'
hashtab(cache, ...)
hashmaptab(x, ...)
## S3 method for class 'integer64'
hashmaptab(x, nunique=NULL, minfac=1.5, hashbits=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hashmap_+3A_x">x</code></td>
<td>
<p> an integer64 vector </p>
</td></tr>
<tr><td><code id="hashmap_+3A_hashmap">hashmap</code></td>
<td>
<p> an object of class 'hashmap' i.e. here 'cache_integer64' </p>
</td></tr>
<tr><td><code id="hashmap_+3A_minfac">minfac</code></td>
<td>
<p> minimum factor by which the hasmap has more elements compared to the data <code>x</code>, ignored if <code>hashbits</code> is given directly </p>
</td></tr>
<tr><td><code id="hashmap_+3A_hashbits">hashbits</code></td>
<td>
<p> length of hashmap is <code>2^hashbits</code> </p>
</td></tr>
<tr><td><code id="hashmap_+3A_cache">cache</code></td>
<td>
<p> an optional <code><a href="#topic+cache">cache</a></code> object into which to put the hashmap (by default a new cache is created)</p>
</td></tr>
<tr><td><code id="hashmap_+3A_nunique">nunique</code></td>
<td>
<p> giving <em>correct</em> number of unique elements can help reducing the size of the hashmap </p>
</td></tr>
<tr><td><code id="hashmap_+3A_nomatch">nomatch</code></td>
<td>
<p> the value to be returned if an element is not found in the hashmap </p>
</td></tr>
<tr><td><code id="hashmap_+3A_keep.order">keep.order</code></td>
<td>
<p> determines order of results and speed: <code>FALSE</code> (the default) is faster and returns in the (pseudo)random order of the hash function, <code>TRUE</code> returns in the order of first appearance in the original data, but this requires extra work </p>
</td></tr> 
<tr><td><code id="hashmap_+3A_...">...</code></td>
<td>
<p> further arguments, passed from generics, ignored in methods </p>
</td></tr>
</table>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: right;">
   <b>function</b> </td><td style="text-align: right;"> <b>see also</b>          </td><td style="text-align: left;"> <b>description</b> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>hashfun</code> </td><td style="text-align: right;"> <code>digest</code> </td><td style="text-align: left;"> export of the hash function used in <code>hashmap</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>hashmap</code> </td><td style="text-align: right;"> <code><a href="#topic+match.integer64">match</a></code> </td><td style="text-align: left;"> return hashmap </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>hashpos</code> </td><td style="text-align: right;"> <code><a href="#topic+match.integer64">match</a></code> </td><td style="text-align: left;"> return positions of <code>x</code> in <code>hashmap</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>hashrev</code> </td><td style="text-align: right;"> <code><a href="#topic+match.integer64">match</a></code> </td><td style="text-align: left;"> return positions of <code>hashmap</code> in <code>x</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>hashfin</code> </td><td style="text-align: right;"> <code><a href="#topic++25in+25.integer64">%in%.integer64</a></code> </td><td style="text-align: left;"> return logical whether <code>x</code> is in <code>hashmap</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>hashrin</code> </td><td style="text-align: right;"> <code><a href="#topic++25in+25.integer64">%in%.integer64</a></code> </td><td style="text-align: left;"> return logical whether <code>hashmap</code> is in <code>x</code>  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>hashdup</code> </td><td style="text-align: right;"> <code><a href="#topic+duplicated.integer64">duplicated</a></code> </td><td style="text-align: left;"> return logical whether hashdat is duplicated using hashmap</td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>hashuni</code> </td><td style="text-align: right;"> <code><a href="#topic+unique.integer64">unique</a></code> </td><td style="text-align: left;"> return unique values of hashmap  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>hashmapuni</code> </td><td style="text-align: right;"> <code><a href="#topic+unique.integer64">unique</a></code> </td><td style="text-align: left;"> return unique values of <code>x</code>  </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>hashupo</code> </td><td style="text-align: right;"> <code><a href="#topic+unique.integer64">unique</a></code> </td><td style="text-align: left;"> return positions of unique values in hashdat </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>hashmapupo</code> </td><td style="text-align: right;"> <code><a href="#topic+unique.integer64">unique</a></code> </td><td style="text-align: left;"> return positions of unique values in <code>x</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>hashtab</code> </td><td style="text-align: right;"> <code><a href="#topic+table.integer64">table</a></code> </td><td style="text-align: left;"> tabulate values of hashdat using hashmap in <code>keep.order=FALSE</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>hashmaptab</code> </td><td style="text-align: right;"> <code><a href="#topic+table.integer64">table</a></code> </td><td style="text-align: left;"> tabulate values of <code>x</code> building hasmap on the fly in <code>keep.order=FALSE</code></td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>see details
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel &lt;Jens.Oehlschlaegel@truecluster.com&gt;
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+match.integer64">match</a></code>, <code><a href="#topic+runif64">runif64</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.integer64(sample(c(NA, 0:9)))
y &lt;- as.integer64(sample(c(NA, 1:9), 10, TRUE))
hashfun(y)
hx &lt;- hashmap(x)
hy &lt;- hashmap(y)
ls(hy)
hashpos(hy, x)
hashrev(hx, y)
hashfin(hy, x)
hashrin(hx, y)
hashdup(hy)
hashuni(hy)
hashuni(hy, keep.order=TRUE)
hashmapuni(y)
hashupo(hy)
hashupo(hy, keep.order=TRUE)
hashmapupo(y)
hashtab(hy)
hashmaptab(y)

stopifnot(identical(match(as.integer(x),as.integer(y)),hashpos(hy, x)))
stopifnot(identical(match(as.integer(x),as.integer(y)),hashrev(hx, y)))
stopifnot(identical(as.integer(x) %in% as.integer(y), hashfin(hy, x)))
stopifnot(identical(as.integer(x) %in% as.integer(y), hashrin(hx, y)))
stopifnot(identical(duplicated(as.integer(y)), hashdup(hy)))
stopifnot(identical(as.integer64(unique(as.integer(y))), hashuni(hy, keep.order=TRUE)))
stopifnot(identical(sort(hashuni(hy, keep.order=FALSE)), sort(hashuni(hy, keep.order=TRUE))))
stopifnot(identical(y[hashupo(hy, keep.order=FALSE)], hashuni(hy, keep.order=FALSE)))
stopifnot(identical(y[hashupo(hy, keep.order=TRUE)], hashuni(hy, keep.order=TRUE)))
stopifnot(identical(hashpos(hy, hashuni(hy, keep.order=TRUE)), hashupo(hy, keep.order=TRUE)))
stopifnot(identical(hashpos(hy, hashuni(hy, keep.order=FALSE)), hashupo(hy, keep.order=FALSE)))
stopifnot(identical(hashuni(hy, keep.order=FALSE), hashtab(hy)$values))
stopifnot(identical(as.vector(table(as.integer(y), useNA="ifany"))
, hashtab(hy)$counts[order.integer64(hashtab(hy)$values)]))
stopifnot(identical(hashuni(hy, keep.order=TRUE), hashmapuni(y)))
stopifnot(identical(hashupo(hy, keep.order=TRUE), hashmapupo(y)))
stopifnot(identical(hashtab(hy), hashmaptab(y)))

	## Not run: 
	message("explore speed given size of the hasmap in 2^hashbits and size of the data")
	message("more hashbits means more random access and less collisions")
	message("i.e. more data means less random access and more collisions")
	bits &lt;- 24
	b &lt;- seq(-1, 0, 0.1)
	tim &lt;- matrix(NA, length(b), 2, dimnames=list(b, c("bits","bits+1")))
    for (i in 1:length(b)){
	  n &lt;- as.integer(2^(bits+b[i]))
	  x &lt;- as.integer64(sample(n))
	  tim[i,1] &lt;- repeat.time(hashmap(x, hashbits=bits))[3]
	  tim[i,2] &lt;- repeat.time(hashmap(x, hashbits=bits+1))[3]
	  print(tim)
      matplot(b, tim)
	}
	message("we conclude that n*sqrt(2) is enough to avoid collisions")
	
## End(Not run)
</code></pre>

<hr>
<h2 id='identical.integer64'>
Identity function for class 'integer64'
</h2><span id='topic+identical.integer64'></span>

<h3>Description</h3>

<p>This will discover any deviation between objects containing integer64 vectors. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'> identical.integer64(x, y, num.eq = FALSE, single.NA = FALSE
, attrib.as.set = TRUE, ignore.bytecode = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identical.integer64_+3A_x">x</code></td>
<td>
<p> atomic vector of class 'integer64' </p>
</td></tr>
<tr><td><code id="identical.integer64_+3A_y">y</code></td>
<td>
<p> atomic vector of class 'integer64' </p>
</td></tr>
<tr><td><code id="identical.integer64_+3A_num.eq">num.eq</code></td>
<td>
<p> see <code><a href="base.html#topic+identical">identical</a></code> </p>
</td></tr>
<tr><td><code id="identical.integer64_+3A_single.na">single.NA</code></td>
<td>
<p> see <code><a href="base.html#topic+identical">identical</a></code> </p>
</td></tr>
<tr><td><code id="identical.integer64_+3A_attrib.as.set">attrib.as.set</code></td>
<td>
<p> see <code><a href="base.html#topic+identical">identical</a></code> </p>
</td></tr>
<tr><td><code id="identical.integer64_+3A_ignore.bytecode">ignore.bytecode</code></td>
<td>
<p> see <code><a href="base.html#topic+identical">identical</a></code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is simply a wrapper to <code><a href="base.html#topic+identical">identical</a></code> with default arguments <code>num.eq = FALSE, single.NA = FALSE</code>.
</p>


<h3>Value</h3>

<p>A single logical value, <code>TRUE</code> or <code>FALSE</code>, never <code>NA</code> and never anything other than a single value. 
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel &lt;Jens.Oehlschlaegel@truecluster.com&gt;
</p>


<h3>See Also</h3>

 <p><code><a href="#topic++3D+3D.integer64">==.integer64</a></code> <code><a href="base.html#topic+identical">identical</a></code> <code><a href="#topic+integer64">integer64</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>  i64 &lt;- as.double(NA); class(i64) &lt;- "integer64"
  identical(i64-1, i64+1)
  identical.integer64(i64-1, i64+1)
</code></pre>

<hr>
<h2 id='is.sorted.integer64'>
Small cache access methods
</h2><span id='topic+is.sorted.integer64'></span><span id='topic+na.count.integer64'></span><span id='topic+nvalid.integer64'></span><span id='topic+nunique.integer64'></span><span id='topic+nties.integer64'></span>

<h3>Description</h3>

<p>These methods are packaged here for methods in packages <code>bit64</code> and <code>ff</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	## S3 method for class 'integer64'
is.sorted(x, ...)
	## S3 method for class 'integer64'
na.count(x, ...)
	## S3 method for class 'integer64'
nvalid(x, ...)
	## S3 method for class 'integer64'
nunique(x, ...)
	## S3 method for class 'integer64'
nties(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.sorted.integer64_+3A_x">x</code></td>
<td>

<p>some object
</p>
</td></tr>
<tr><td><code id="is.sorted.integer64_+3A_...">...</code></td>
<td>

<p>ignored
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All these functions benefit from a <code><a href="#topic+sortcache">sortcache</a></code>, <code><a href="#topic+ordercache">ordercache</a></code> or <code><a href="#topic+sortordercache">sortordercache</a></code>.  
<code>na.count</code>, <code>nvalid</code> and <code>nunique</code> also benefit from a <code><a href="#topic+hashcache">hashcache</a></code>.
<br />
<code>is.sorted</code> checks for sortedness of <code>x</code> (NAs sorted first) <br />
<code>na.count</code> returns the number of <code>NA</code>s <br /> 
<code>nvalid</code> returns the number of valid data points, usually <code><a href="base.html#topic+length">length</a></code> minus <code>na.count</code>. <br />
<code>nunique</code> returns the number of unique values <br />
<code>nties</code> returns the number of tied values. 
</p>


<h3>Value</h3>

<p><code>is.sorted</code> returns a logical scalar, the other methods return an integer scalar.
</p>


<h3>Note</h3>

<p>If a <code><a href="#topic+cache">cache</a></code> exists but the desired value is not cached, 
then these functions will store their result in the cache. 
We do not consider this a relevant side-effect, 
since these small cache results do not have a relevant memory footprint.
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel &lt;Jens.Oehlschlaegel@truecluster.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cache">cache</a></code> for caching functions and <code><a href="#topic+sortordercache">sortordercache</a></code> for functions creating big caches
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	x &lt;- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
 length(x)
 na.count(x)
 nvalid(x)
 nunique(x)
 nties(x)
 table.integer64(x)
 x
</code></pre>

<hr>
<h2 id='keypos'>Extract Positions in redundant dimension table</h2><span id='topic+keypos'></span><span id='topic+keypos.integer64'></span>

<h3>Description</h3>

<p><code>keypos</code> returns the positions of the (fact table) elements that participate in their sorted unique subset (dimension table)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keypos(x, ...)
## S3 method for class 'integer64'
keypos(x, method = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="keypos_+3A_x">x</code></td>
<td>
<p>a vector or a data frame or an array or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="keypos_+3A_method">method</code></td>
<td>

<p>NULL for automatic method selection or a suitable low-level method, see details
</p>
</td></tr>
<tr><td><code id="keypos_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NAs are sorted first in the dimension table, see <code><a href="#topic+ramorder.integer64">ramorder.integer64</a></code>.
<br />
This function automatically chooses from several low-level functions considering the size of <code>x</code> and the availability of a cache. 
Suitable methods are <code><a href="#topic+sortorderkey">sortorderkey</a></code> (fast ordering) 
and <code><a href="#topic+orderkey">orderkey</a></code> (memory saving ordering).
</p>


<h3>Value</h3>

<p>an integer vector of the same length as codex containing positions relativ to codesort(unique(x), na.last=FALSE)
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel &lt;Jens.Oehlschlaegel@truecluster.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unique.integer64">unique.integer64</a></code> for the unique subset and <code><a href="#topic+match.integer64">match.integer64</a></code> for finding positions in a different vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
keypos(x)

stopifnot(identical(keypos(x),  match.integer64(x, sort(unique(x), na.last=FALSE))))
</code></pre>

<hr>
<h2 id='match.integer64'>
64-bit integer matching
</h2><span id='topic+match.integer64'></span><span id='topic++25in+25.integer64'></span>

<h3>Description</h3>

<p><code>match</code> returns a vector of the positions of (first) matches of its first argument in its second. 
</p>
<p><code>%in%</code> is a more intuitive interface as a binary operator, which returns a logical vector indicating if there is a match or not for its left operand. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'integer64'
match(x, table, nomatch = NA_integer_, nunique = NULL, method = NULL, ...)
## S3 method for class 'integer64'
x %in% table, ...
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match.integer64_+3A_x">x</code></td>
<td>

<p>integer64 vector: the values to be matched, optionally carrying a cache created with <code><a href="#topic+hashcache">hashcache</a></code>
</p>
</td></tr>
<tr><td><code id="match.integer64_+3A_table">table</code></td>
<td>

<p>integer64 vector: the values to be matched against, optionally carrying a cache created with <code><a href="#topic+hashcache">hashcache</a></code> or <code><a href="#topic+sortordercache">sortordercache</a></code>
</p>
</td></tr>
<tr><td><code id="match.integer64_+3A_nomatch">nomatch</code></td>
<td>

<p>the value to be returned in the case when no match is found. Note that it is coerced to integer.
</p>
</td></tr>
<tr><td><code id="match.integer64_+3A_nunique">nunique</code></td>
<td>

<p>NULL or the number of unique values of table (including NA). Providing <code>nunique</code> can speed-up matching when <code>table</code> has no cache. Note that a wrong nunique can cause undefined behaviour up to a crash.
</p>
</td></tr>
<tr><td><code id="match.integer64_+3A_method">method</code></td>
<td>

<p>NULL for automatic method selection or a suitable low-level method, see details
</p>
</td></tr>
<tr><td><code id="match.integer64_+3A_...">...</code></td>
<td>

<p>ignored
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions automatically choose from several low-level functions considering the size of <code>x</code> and <code>table</code> and the availability of caches. 
</p>
<p>Suitable methods for <code>%in%.integer64</code> are <code><a href="#topic+hashpos">hashpos</a></code> (hash table lookup), <code><a href="#topic+hashrev">hashrev</a></code> (reverse lookup), <code><a href="#topic+sortorderpos">sortorderpos</a></code> (fast ordering) and <code><a href="#topic+orderpos">orderpos</a></code> (memory saving ordering).
Suitable methods for <code>match.integer64</code> are <code><a href="#topic+hashfin">hashfin</a></code> (hash table lookup), <code><a href="#topic+hashrin">hashrin</a></code> (reverse lookup), <code><a href="#topic+sortfin">sortfin</a></code> (fast sorting) and <code><a href="#topic+orderfin">orderfin</a></code> (memory saving ordering).
</p>


<h3>Value</h3>

<p>A vector of the same length as <code>x</code>.
</p>
<p><code>match</code>: An integer vector giving the position in <code>table</code> of
the first match if there is a match, otherwise <code>nomatch</code>.
</p>
<p>If <code>x[i]</code> is found to equal <code>table[j]</code> then the value
returned in the <code>i</code>-th position of the return value is <code>j</code>,
for the smallest possible <code>j</code>.  If no match is found, the value
is <code>nomatch</code>.
</p>
<p><code>%in%</code>: A logical vector, indicating if a match was located for
each element of <code>x</code>: thus the values are <code>TRUE</code> or
<code>FALSE</code> and never <code>NA</code>.
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel &lt;Jens.Oehlschlaegel@truecluster.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+match">match</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.integer64(c(NA, 0:9), 32)
table &lt;- as.integer64(c(1:9, NA))
match.integer64(x, table)
"%in%.integer64"(x, table)

x &lt;- as.integer64(sample(c(rep(NA, 9), 0:9), 32, TRUE))
table &lt;- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
stopifnot(identical(match.integer64(x, table), match(as.integer(x), as.integer(table))))
stopifnot(identical("%in%.integer64"(x, table), as.integer(x) %in% as.integer(table)))

## Not run: 
	message("check when reverse hash-lookup beats standard hash-lookup")
	e &lt;- 4:24
	timx &lt;- timy &lt;- matrix(NA, length(e), length(e), dimnames=list(e,e))
	for (iy in seq_along(e))
	for (ix in 1:iy){
		nx &lt;- 2^e[ix]
		ny &lt;- 2^e[iy]
		x &lt;- as.integer64(sample(ny, nx, FALSE))
		y &lt;- as.integer64(sample(ny, ny, FALSE))
		#hashfun(x, bits=as.integer(5))
		timx[ix,iy] &lt;- repeat.time({
		hx &lt;- hashmap(x)
		py &lt;- hashrev(hx, y)
		})[3]
		timy[ix,iy] &lt;- repeat.time({
		hy &lt;- hashmap(y)
		px &lt;- hashpos(hy, x)
		})[3]
		#identical(px, py)
		print(round(timx[1:iy,1:iy]/timy[1:iy,1:iy], 2), na.print="")
	}

	message("explore best low-level method given size of x and table")
	B1 &lt;- 1:27
	B2 &lt;- 1:27
	tim &lt;- array(NA, dim=c(length(B1), length(B2), 5)
 , dimnames=list(B1, B2, c("hashpos","hashrev","sortpos1","sortpos2","sortpos3")))
	for (i1 in B1)
	for (i2 in B2)
	{
	  b1 &lt;- B1[i1]
	  b2 &lt;- B1[i2]
	  n1 &lt;- 2^b1
	  n2 &lt;- 2^b2
	  x1 &lt;- as.integer64(c(sample(n2, n1-1, TRUE), NA))
	  x2 &lt;- as.integer64(c(sample(n2, n2-1, TRUE), NA))
	  tim[i1,i2,1] &lt;- repeat.time({h &lt;- hashmap(x2);hashpos(h, x1);rm(h)})[3]
	  tim[i1,i2,2] &lt;- repeat.time({h &lt;- hashmap(x1);hashrev(h, x2);rm(h)})[3]
	  s &lt;- clone(x2); o &lt;- seq_along(s); ramsortorder(s, o)
	  tim[i1,i2,3] &lt;- repeat.time(sortorderpos(s, o, x1, method=1))[3]
	  tim[i1,i2,4] &lt;- repeat.time(sortorderpos(s, o, x1, method=2))[3]
	  tim[i1,i2,5] &lt;- repeat.time(sortorderpos(s, o, x1, method=3))[3]
	  rm(s,o)
	  print(apply(tim, 1:2, function(ti)if(any(is.na(ti)))NA else which.min(ti)))
	}

## End(Not run)
</code></pre>

<hr>
<h2 id='optimizer64.data'>
Results of performance measurement on a Core i7 Lenovo T410 8 GB RAM under Windows 7 64bit
</h2><span id='topic+optimizer64.data'></span>

<h3>Description</h3>

<p>These are the results of calling <code><a href="#topic+optimizer64">optimizer64</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(optimizer64.data)</code></pre>


<h3>Format</h3>

<p>The format is:
List of 16
$ : num [1:9, 1:3] 0 0 1.63 0.00114 2.44 ...
..- attr(*, &quot;dimnames&quot;)=List of 2
.. ..$ : chr [1:9] &quot;match&quot; &quot;match.64&quot; &quot;hashpos&quot; &quot;hashrev&quot; ...
.. ..$ : chr [1:3] &quot;prep&quot; &quot;both&quot; &quot;use&quot;
$ : num [1:10, 1:3] 0 0 0 1.62 0.00114 ...
..- attr(*, &quot;dimnames&quot;)=List of 2
.. ..$ : chr [1:10] &quot;%in%&quot; &quot;match.64&quot; &quot;%in%.64&quot; &quot;hashfin&quot; ...
.. ..$ : chr [1:3] &quot;prep&quot; &quot;both&quot; &quot;use&quot;
$ : num [1:10, 1:3] 0 0 0.00105 0.00313 0.00313 ...
..- attr(*, &quot;dimnames&quot;)=List of 2
.. ..$ : chr [1:10] &quot;duplicated&quot; &quot;duplicated.64&quot; &quot;hashdup&quot; &quot;sortorderdup1&quot; ...
.. ..$ : chr [1:3] &quot;prep&quot; &quot;both&quot; &quot;use&quot;
$ : num [1:15, 1:3] 0 0 0 0.00104 0.00104 ...
..- attr(*, &quot;dimnames&quot;)=List of 2
.. ..$ : chr [1:15] &quot;unique&quot; &quot;unique.64&quot; &quot;hashmapuni&quot; &quot;hashuni&quot; ...
.. ..$ : chr [1:3] &quot;prep&quot; &quot;both&quot; &quot;use&quot;
$ : num [1:14, 1:3] 0 0 0 0.000992 0.000992 ...
..- attr(*, &quot;dimnames&quot;)=List of 2
.. ..$ : chr [1:14] &quot;unique&quot; &quot;unipos.64&quot; &quot;hashmapupo&quot; &quot;hashupo&quot; ...
.. ..$ : chr [1:3] &quot;prep&quot; &quot;both&quot; &quot;use&quot;
$ : num [1:13, 1:3] 0 0 0 0 0.000419 ...
..- attr(*, &quot;dimnames&quot;)=List of 2
.. ..$ : chr [1:13] &quot;tabulate&quot; &quot;table&quot; &quot;table.64&quot; &quot;hashmaptab&quot; ...
.. ..$ : chr [1:3] &quot;prep&quot; &quot;both&quot; &quot;use&quot;
$ : num [1:7, 1:3] 0 0 0 0.00236 0.00714 ...
..- attr(*, &quot;dimnames&quot;)=List of 2
.. ..$ : chr [1:7] &quot;rank&quot; &quot;rank.keep&quot; &quot;rank.64&quot; &quot;sortorderrnk&quot; ...
.. ..$ : chr [1:3] &quot;prep&quot; &quot;both&quot; &quot;use&quot;
$ : num [1:6, 1:3] 0 0 0.00189 0.00714 0 ...
..- attr(*, &quot;dimnames&quot;)=List of 2
.. ..$ : chr [1:6] &quot;quantile&quot; &quot;quantile.64&quot; &quot;sortqtl&quot; &quot;orderqtl&quot; ...
.. ..$ : chr [1:3] &quot;prep&quot; &quot;both&quot; &quot;use&quot;
$ : num [1:9, 1:3] 0 0 0.00105 1.17 0 ...
..- attr(*, &quot;dimnames&quot;)=List of 2
.. ..$ : chr [1:9] &quot;match&quot; &quot;match.64&quot; &quot;hashpos&quot; &quot;hashrev&quot; ...
.. ..$ : chr [1:3] &quot;prep&quot; &quot;both&quot; &quot;use&quot;
$ : num [1:10, 1:3] 0 0 0 0.00104 1.18 ...
..- attr(*, &quot;dimnames&quot;)=List of 2
.. ..$ : chr [1:10] &quot;%in%&quot; &quot;match.64&quot; &quot;%in%.64&quot; &quot;hashfin&quot; ...
.. ..$ : chr [1:3] &quot;prep&quot; &quot;both&quot; &quot;use&quot;
$ : num [1:10, 1:3] 0 0 1.64 2.48 2.48 ...
..- attr(*, &quot;dimnames&quot;)=List of 2
.. ..$ : chr [1:10] &quot;duplicated&quot; &quot;duplicated.64&quot; &quot;hashdup&quot; &quot;sortorderdup1&quot; ...
.. ..$ : chr [1:3] &quot;prep&quot; &quot;both&quot; &quot;use&quot;
$ : num [1:15, 1:3] 0 0 0 1.64 1.64 ...
..- attr(*, &quot;dimnames&quot;)=List of 2
.. ..$ : chr [1:15] &quot;unique&quot; &quot;unique.64&quot; &quot;hashmapuni&quot; &quot;hashuni&quot; ...
.. ..$ : chr [1:3] &quot;prep&quot; &quot;both&quot; &quot;use&quot;
$ : num [1:14, 1:3] 0 0 0 1.62 1.62 ...
..- attr(*, &quot;dimnames&quot;)=List of 2
.. ..$ : chr [1:14] &quot;unique&quot; &quot;unipos.64&quot; &quot;hashmapupo&quot; &quot;hashupo&quot; ...
.. ..$ : chr [1:3] &quot;prep&quot; &quot;both&quot; &quot;use&quot;
$ : num [1:13, 1:3] 0 0 0 0 0.32 ...
..- attr(*, &quot;dimnames&quot;)=List of 2
.. ..$ : chr [1:13] &quot;tabulate&quot; &quot;table&quot; &quot;table.64&quot; &quot;hashmaptab&quot; ...
.. ..$ : chr [1:3] &quot;prep&quot; &quot;both&quot; &quot;use&quot;
$ : num [1:7, 1:3] 0 0 0 2.96 10.69 ...
..- attr(*, &quot;dimnames&quot;)=List of 2
.. ..$ : chr [1:7] &quot;rank&quot; &quot;rank.keep&quot; &quot;rank.64&quot; &quot;sortorderrnk&quot; ...
.. ..$ : chr [1:3] &quot;prep&quot; &quot;both&quot; &quot;use&quot;
$ : num [1:6, 1:3] 0 0 1.62 10.61 0 ...
..- attr(*, &quot;dimnames&quot;)=List of 2
.. ..$ : chr [1:6] &quot;quantile&quot; &quot;quantile.64&quot; &quot;sortqtl&quot; &quot;orderqtl&quot; ...
.. ..$ : chr [1:3] &quot;prep&quot; &quot;both&quot; &quot;use&quot;
- attr(*, &quot;dim&quot;)= int [1:2] 8 2
- attr(*, &quot;dimnames&quot;)=List of 2
..$ : chr [1:8] &quot;match&quot; &quot;%in%&quot; &quot;duplicated&quot; &quot;unique&quot; ...
..$ : chr [1:2] &quot;65536&quot; &quot;33554432&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(optimizer64.data)
print(optimizer64.data)
oldpar &lt;- par(no.readonly = TRUE)
par(mfrow=c(2,1))
par(cex=0.7)
for (i in 1:nrow(optimizer64.data)){
 for (j in 1:2){
   tim &lt;- optimizer64.data[[i,j]]
  barplot(t(tim))
  if (rownames(optimizer64.data)[i]=="match")
   title(paste("match", colnames(optimizer64.data)[j], "in", colnames(optimizer64.data)[3-j]))
  else if (rownames(optimizer64.data)[i]=="%in%")
   title(paste(colnames(optimizer64.data)[j], "%in%", colnames(optimizer64.data)[3-j]))
  else
   title(paste(rownames(optimizer64.data)[i], colnames(optimizer64.data)[j]))
 }
}
par(mfrow=c(1,1))
</code></pre>

<hr>
<h2 id='plusclass'>
integer64: Maintaining S3 class attribute
</h2><span id='topic+plusclass'></span><span id='topic+minusclass'></span>

<h3>Description</h3>

<p>Maintaining integer64 S3 class attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  plusclass(class, whichclass)
  minusclass(class, whichclass)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plusclass_+3A_class">class</code></td>
<td>
<p> NULL or a character vector of class attributes </p>
</td></tr>
<tr><td><code id="plusclass_+3A_whichclass">whichclass</code></td>
<td>
<p> the (single) class name to add or remove from the class vector  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL or a character vector of class attributes
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel &lt;Jens.Oehlschlaegel@truecluster.com&gt;
</p>


<h3>See Also</h3>

 
<p><code><a href="base.html#topic+oldClass">oldClass</a></code> <code><a href="#topic+integer64">integer64</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  plusclass("inheritingclass","integer64")
  minusclass(c("inheritingclass","integer64"), "integer64")
</code></pre>

<hr>
<h2 id='prank'>(P)ercent (Rank)s</h2><span id='topic+prank'></span><span id='topic+prank.integer64'></span>

<h3>Description</h3>

<p>Function <code>prank.integer64</code>  projects the values [min..max] via ranks [1..n] to [0..1]. 
<code><a href="#topic+qtile.integer64">qtile.integer64</a></code> is the inverse function of 'prank.integer64' and projects [0..1] to [min..max].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	prank(x, ...)
	## S3 method for class 'integer64'
prank(x, method = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prank_+3A_x">x</code></td>
<td>
<p>a integer64 vector</p>
</td></tr>
<tr><td><code id="prank_+3A_method">method</code></td>
<td>

<p>NULL for automatic method selection or a suitable low-level method, see details
</p>
</td></tr>
<tr><td><code id="prank_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>prank.integer64</code> is based on <code><a href="#topic+rank.integer64">rank.integer64</a></code>.
</p>


<h3>Value</h3>

<p><code>prank</code> returns a numeric vector of the same length as <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel &lt;Jens.Oehlschlaegel@truecluster.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rank.integer64">rank.integer64</a></code> for simple ranks and <code><a href="#topic+qtile">qtile</a></code> for the inverse function quantiles.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
prank(x)

x &lt;- x[!is.na(x)]
stopifnot(identical(x,  unname(qtile(x, probs=prank(x)))))
</code></pre>

<hr>
<h2 id='qtile'>(Q)uan(Tile)s </h2><span id='topic+qtile'></span><span id='topic+qtile.integer64'></span><span id='topic+quantile.integer64'></span><span id='topic+median.integer64'></span><span id='topic+mean.integer64'></span><span id='topic+summary.integer64'></span>

<h3>Description</h3>

<p>Function <code><a href="#topic+prank.integer64">prank.integer64</a></code>  projects the values [min..max] via ranks [1..n] to [0..1]. 
<code>qtile.ineger64</code> is the inverse function of 'prank.integer64' and projects [0..1] to [min..max].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	qtile(x, probs=seq(0, 1, 0.25), ...)
	## S3 method for class 'integer64'
qtile(x, probs = seq(0, 1, 0.25), names = TRUE, method = NULL, ...)
	## S3 method for class 'integer64'
quantile(x, probs = seq(0, 1, 0.25), na.rm = FALSE, names = TRUE, type=0L, ...)
	## S3 method for class 'integer64'
median(x, na.rm = FALSE, ...)
 ## S3 method for class 'integer64'
mean(x, na.rm = FALSE, ...)
	## S3 method for class 'integer64'
summary(object, ...)
 ## mean(x, na.rm = FALSE, ...)
 ## or
 ## mean(x, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qtile_+3A_x">x</code></td>
<td>
<p>a integer64 vector</p>
</td></tr>
<tr><td><code id="qtile_+3A_object">object</code></td>
<td>
<p>a integer64 vector</p>
</td></tr>
<tr><td><code id="qtile_+3A_probs">probs</code></td>
<td>

<p>numeric vector of probabilities with values in [0,1] - possibly containing <code>NA</code>s
</p>
</td></tr>
<tr><td><code id="qtile_+3A_names">names</code></td>
<td>

<p>logical; if <code>TRUE</code>, the result has a <code>names</code> attribute. Set to <code>FALSE</code> for speedup with many probs.
</p>
</td></tr>
<tr><td><code id="qtile_+3A_type">type</code></td>
<td>

<p>an integer selecting the quantile algorithm, currently only 0 is supported, see details
</p>
</td></tr>
<tr><td><code id="qtile_+3A_method">method</code></td>
<td>

<p>NULL for automatic method selection or a suitable low-level method, see details
</p>
</td></tr>
<tr><td><code id="qtile_+3A_na.rm">na.rm</code></td>
<td>

<p>logical; if <code>TRUE</code>, any <code>NA</code> and <code>NaN</code>'s are removed from <code>x</code> before the quantiles are computed.
</p>
</td></tr>
<tr><td><code id="qtile_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functions <code>quantile.integer64</code> with <code>type=0</code> and <code>median.integer64</code> are convenience wrappers to <code>qtile</code>.
<br />
Function <code>qtile</code> behaves very similar to <code>quantile.default</code> with <code>type=1</code> 
in that it only returns existing values, it is mostly symetric 
but it is using 'round' rather than 'floor'. 
<br />
Note that this implies that <code>median.integer64</code> does not interpolate for even number of values 
(interpolation would create values that could not be represented as 64-bit integers).
<br />
This function automatically chooses from several low-level functions considering the size of <code>x</code> and the availability of a cache. 
Suitable methods are <code><a href="#topic+sortqtl">sortqtl</a></code> (fast sorting) 
and <code><a href="#topic+orderqtl">orderqtl</a></code> (memory saving ordering).
</p>


<h3>Value</h3>

<p><code>prank</code> returns a numeric vector of the same length as <code>x</code>.
<br />
<code>qtile</code> returns a vector with elements from <code>x</code> 
at the relative positions specified by <code>probs</code>.
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel &lt;Jens.Oehlschlaegel@truecluster.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rank.integer64">rank.integer64</a></code> for simple ranks and <code><a href="stats.html#topic+quantile">quantile</a></code> for quantiles.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
qtile(x, probs=seq(0, 1, 0.25))
quantile(x, probs=seq(0, 1, 0.25), na.rm=TRUE)
median(x, na.rm=TRUE)
summary(x)

x &lt;- x[!is.na(x)]
stopifnot(identical(x,  unname(qtile(x, probs=prank(x)))))
</code></pre>

<hr>
<h2 id='ramsort.integer64'>
Low-level intger64 methods for in-RAM sorting and ordering
</h2><span id='topic+ramsort.integer64'></span><span id='topic+shellsort.integer64'></span><span id='topic+quicksort.integer64'></span><span id='topic+mergesort.integer64'></span><span id='topic+radixsort.integer64'></span><span id='topic+ramorder.integer64'></span><span id='topic+shellorder.integer64'></span><span id='topic+quickorder.integer64'></span><span id='topic+mergeorder.integer64'></span><span id='topic+radixorder.integer64'></span><span id='topic+ramsortorder.integer64'></span><span id='topic+shellsortorder.integer64'></span><span id='topic+quicksortorder.integer64'></span><span id='topic+mergesortorder.integer64'></span><span id='topic+radixsortorder.integer64'></span>

<h3>Description</h3>

<p>Fast low-level methods for sorting and ordering. 
The <code>..sortorder</code> methods do sorting and ordering at once, which requires more RAM than ordering but is (almost) as fast as as sorting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'integer64'
shellsort(x, has.na=TRUE, na.last=FALSE, decreasing=FALSE, ...)
## S3 method for class 'integer64'
shellsortorder(x, i, has.na=TRUE, na.last=FALSE, decreasing=FALSE, ...)
## S3 method for class 'integer64'
shellorder(x, i, has.na=TRUE, na.last=FALSE, decreasing=FALSE, ...)
## S3 method for class 'integer64'
mergesort(x, has.na=TRUE, na.last=FALSE, decreasing=FALSE, ...)
## S3 method for class 'integer64'
mergeorder(x, i, has.na=TRUE, na.last=FALSE, decreasing=FALSE, ...)
## S3 method for class 'integer64'
mergesortorder(x, i, has.na=TRUE, na.last=FALSE, decreasing=FALSE, ...)
## S3 method for class 'integer64'
quicksort(x, has.na=TRUE, na.last=FALSE, decreasing=FALSE
, restlevel=floor(1.5*log2(length(x))), ...)
## S3 method for class 'integer64'
quicksortorder(x, i, has.na=TRUE, na.last=FALSE, decreasing=FALSE
, restlevel=floor(1.5*log2(length(x))), ...)
## S3 method for class 'integer64'
quickorder(x, i, has.na=TRUE, na.last=FALSE, decreasing=FALSE
, restlevel=floor(1.5*log2(length(x))), ...)
## S3 method for class 'integer64'
radixsort(x, has.na=TRUE, na.last=FALSE, decreasing=FALSE, radixbits=8L, ...)
## S3 method for class 'integer64'
radixsortorder(x, i, has.na=TRUE, na.last=FALSE, decreasing=FALSE, radixbits=8L, ...)
## S3 method for class 'integer64'
radixorder(x, i, has.na=TRUE, na.last=FALSE, decreasing=FALSE, radixbits=8L, ...)
## S3 method for class 'integer64'
ramsort(x, has.na = TRUE, na.last=FALSE, decreasing = FALSE, stable = TRUE
, optimize = c("time", "memory"), VERBOSE = FALSE, ...)
## S3 method for class 'integer64'
ramsortorder(x, i, has.na = TRUE, na.last=FALSE, decreasing = FALSE, stable = TRUE
, optimize = c("time", "memory"), VERBOSE = FALSE, ...)
## S3 method for class 'integer64'
ramorder(x, i, has.na = TRUE, na.last=FALSE, decreasing = FALSE, stable = TRUE
, optimize = c("time", "memory"), VERBOSE = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ramsort.integer64_+3A_x">x</code></td>
<td>
<p> a vector to be sorted by <code><a href="bit.html#topic+ramsort">ramsort</a></code> and <code><a href="bit.html#topic+ramsortorder">ramsortorder</a></code>, i.e. the output of  <code><a href="base.html#topic+sort">sort</a></code> </p>
</td></tr>
<tr><td><code id="ramsort.integer64_+3A_i">i</code></td>
<td>
<p> integer positions to be modified by <code><a href="bit.html#topic+ramorder">ramorder</a></code> and <code><a href="bit.html#topic+ramsortorder">ramsortorder</a></code>, default is 1:n, in this case the output is similar to <code><a href="#topic+order">order</a></code> </p>
</td></tr>
<tr><td><code id="ramsort.integer64_+3A_has.na">has.na</code></td>
<td>

<p>boolean scalar defining whether the input vector might contain <code>NA</code>s. If we know we don't have NAs, this may speed-up.
<em>Note</em> that you risk a crash if there are unexpected <code>NA</code>s with <code>has.na=FALSE</code>
</p>
</td></tr>
<tr><td><code id="ramsort.integer64_+3A_na.last">na.last</code></td>
<td>

<p>boolean scalar telling ramsort whether to sort <code>NA</code>s last or first.
<em>Note</em> that 'boolean' means that there is no third option <code>NA</code> as in <code><a href="base.html#topic+sort">sort</a></code>
</p>
</td></tr>
<tr><td><code id="ramsort.integer64_+3A_decreasing">decreasing</code></td>
<td>

<p>boolean scalar telling ramsort whether to sort increasing or decreasing
</p>
</td></tr>
<tr><td><code id="ramsort.integer64_+3A_stable">stable</code></td>
<td>

<p>boolean scalar defining whether stable sorting is needed. Allowing non-stable may speed-up.
</p>
</td></tr>
<tr><td><code id="ramsort.integer64_+3A_optimize">optimize</code></td>
<td>

<p>by default ramsort optimizes for 'time' which requires more RAM,
set to 'memory' to minimize RAM requirements and sacrifice speed
</p>
</td></tr>
<tr><td><code id="ramsort.integer64_+3A_restlevel">restlevel</code></td>
<td>

<p>number of remaining recursionlevels before <code>quicksort</code> switches from recursing to <code>shellsort</code>
</p>
</td></tr>
<tr><td><code id="ramsort.integer64_+3A_radixbits">radixbits</code></td>
<td>

<p>size of radix in bits
</p>
</td></tr>
<tr><td><code id="ramsort.integer64_+3A_verbose">VERBOSE</code></td>
<td>

<p>cat some info about chosen method
</p>
</td></tr>
<tr><td><code id="ramsort.integer64_+3A_...">...</code></td>
<td>
<p> further arguments, passed from generics, ignored in methods </p>
</td></tr>
</table>


<h3>Details</h3>

<p>see <code><a href="bit.html#topic+ramsort">ramsort</a></code>
</p>


<h3>Value</h3>

<p>These functions return the number of <code>NAs</code> found or assumed during sorting
</p>


<h3>Note</h3>

<p>Note that these methods purposely violate the functional programming paradigm: they are called for the side-effect of changing some of their arguments.
The <code>sort</code>-methods change <code>x</code>, the <code>order</code>-methods change <code>i</code>, and the <code>sortoder</code>-methods change both <code>x</code> and <code>i</code>
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel &lt;Jens.Oehlschlaegel@truecluster.com&gt;
</p>


<h3>See Also</h3>

 <p><code><a href="bit.html#topic+ramsort">ramsort</a></code> for the generic, <code>ramsort.default</code> for the methods provided by package <code>ff</code>, <code><a href="#topic+sort.integer64">sort.integer64</a></code> for the sort interface and <code><a href="#topic+sortcache">sortcache</a></code> for caching the work of sorting</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
  x
  message("ramsort example")
  s &lt;- clone(x)
  ramsort(s)
  message("s has been changed in-place - whether or not ramsort uses an in-place algorithm")
  s
  message("ramorder example")
  s &lt;- clone(x)
  o &lt;- seq_along(s)
  ramorder(s, o)
  message("o has been changed in-place - s remains unchanged")
  s
  o
  s[o]
  message("ramsortorder example")
  o &lt;- seq_along(s)
  ramsortorder(s, o)
  message("s and o have both been changed in-place - this is much faster")
  s
  o
</code></pre>

<hr>
<h2 id='rank.integer64'>Sample Ranks from integer64</h2><span id='topic+rank.integer64'></span>

<h3>Description</h3>

<p>Returns the sample ranks of the values in a vector.  Ties (i.e., equal
values) are averaged and missing values propagated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	## S3 method for class 'integer64'
rank(x, method = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rank.integer64_+3A_x">x</code></td>
<td>
<p>a integer64 vector</p>
</td></tr>
<tr><td><code id="rank.integer64_+3A_method">method</code></td>
<td>

<p>NULL for automatic method selection or a suitable low-level method, see details
</p>
</td></tr>
<tr><td><code id="rank.integer64_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function automatically chooses from several low-level functions considering the size of <code>x</code> and the availability of a cache. 
Suitable methods are <code><a href="#topic+sortorderrnk">sortorderrnk</a></code> (fast ordering) 
and <code><a href="#topic+orderrnk">orderrnk</a></code> (memory saving ordering).
</p>


<h3>Value</h3>

<p>A numeric vector of the same length as <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel &lt;Jens.Oehlschlaegel@truecluster.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+order.integer64">order.integer64</a></code>, <code><a href="#topic+rank">rank</a></code> and <code><a href="#topic+prank">prank</a></code> for percent rank.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
rank.integer64(x)

stopifnot(identical(rank.integer64(x),  rank(as.integer(x)
, na.last="keep", ties.method = "average")))
</code></pre>

<hr>
<h2 id='rep.integer64'>
Replicate elements of integer64 vectors
</h2><span id='topic+rep.integer64'></span>

<h3>Description</h3>

<p>Replicate elements of integer64 vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'integer64'
rep(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rep.integer64_+3A_x">x</code></td>
<td>
<p> a vector of 'integer64' to be replicated </p>
</td></tr>
<tr><td><code id="rep.integer64_+3A_...">...</code></td>
<td>
<p> further arguments passed to <code><a href="base.html#topic+NextMethod">NextMethod</a></code> </p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="base.html#topic+rep">rep</a></code> returns a integer64 vector
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel &lt;Jens.Oehlschlaegel@truecluster.com&gt;
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+c.integer64">c.integer64</a></code> <code><a href="#topic+rep.integer64">rep.integer64</a></code> 
<code><a href="#topic+as.data.frame.integer64">as.data.frame.integer64</a></code> <code><a href="#topic+integer64">integer64</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  rep(as.integer64(1:2), 6)
  rep(as.integer64(1:2), c(6,6))
  rep(as.integer64(1:2), length.out=6)
</code></pre>

<hr>
<h2 id='runif64'>
integer64: random numbers
</h2><span id='topic+runif64'></span>

<h3>Description</h3>

<p>Create uniform random 64-bit integers within defined range
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  runif64(n, min = lim.integer64()[1], max = lim.integer64()[2], replace=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runif64_+3A_n">n</code></td>
<td>
<p> length of return vector </p>
</td></tr>
<tr><td><code id="runif64_+3A_min">min</code></td>
<td>
<p> lower inclusive bound for random numbers </p>
</td></tr>
<tr><td><code id="runif64_+3A_max">max</code></td>
<td>
<p> upper inclusive bound for random numbers </p>
</td></tr>
<tr><td><code id="runif64_+3A_replace">replace</code></td>
<td>
<p> set to FALSE for sampleing from a finite pool, see <code><a href="base.html#topic+sample">sample</a></code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each random integer we call R's internal C interface <code>unif_rand()</code> twice.
Each call is mapped to 2^32 unsigned integers. The two 32-bit patterns are concatenated
to form the new integer64. This process is repeated until the result is not a <code>NA_INTEGER64</code>. 
</p>


<h3>Value</h3>

<p>a integer64 vector
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel &lt;Jens.Oehlschlaegel@truecluster.com&gt;
</p>


<h3>See Also</h3>

 
<p><code><a href="stats.html#topic+runif">runif</a></code>, <code><a href="#topic+hashfun">hashfun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  runif64(12)
  runif64(12, -16, 16)
  runif64(12, 0, as.integer64(2^60)-1)  # not 2^60-1 !
  var(runif(1e4))
  var(as.double(runif64(1e4, 0, 2^40))/2^40)  # ~ = 1/12 = .08333

  table(sample(16, replace=FALSE))
  table(runif64(16, 1, 16, replace=FALSE))
  table(sample(16, replace=TRUE))
  table(runif64(16, 1, 16, replace=TRUE))
</code></pre>

<hr>
<h2 id='seq.integer64'>
integer64: Sequence Generation
</h2><span id='topic+seq.integer64'></span>

<h3>Description</h3>

<p>Generating sequence of integer64 values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'integer64'
seq(from = NULL, to = NULL, by = NULL, length.out = NULL, along.with = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq.integer64_+3A_from">from</code></td>
<td>
<p> integer64 scalar (in order to dispatch the integer64 method of <code><a href="base.html#topic+seq">seq</a></code> </p>
</td></tr>
<tr><td><code id="seq.integer64_+3A_to">to</code></td>
<td>
<p> scalar </p>
</td></tr>
<tr><td><code id="seq.integer64_+3A_by">by</code></td>
<td>
<p> scalar </p>
</td></tr>
<tr><td><code id="seq.integer64_+3A_length.out">length.out</code></td>
<td>
<p> scalar </p>
</td></tr>
<tr><td><code id="seq.integer64_+3A_along.with">along.with</code></td>
<td>
<p> scalar </p>
</td></tr>
<tr><td><code id="seq.integer64_+3A_...">...</code></td>
<td>
<p> ignored </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>seq.integer64</code> does coerce its arguments 'from', 'to' and 'by' to <code>integer64</code>.
If not provided, the argument 'by' is automatically determined as <code>+1</code> or <code>-1</code>,
but the size of 'by' is not calculated as in <code><a href="base.html#topic+seq">seq</a></code> (because this might result in a non-integer value).
</p>


<h3>Value</h3>

<p>an integer64 vector with the generated sequence
</p>


<h3>Note</h3>

<p>In base R <code><a href="#topic++3A">:</a></code> currently is not generic and does not dispatch, see section &quot;Limitations inherited from Base R&quot; in <code><a href="#topic+integer64">integer64</a></code>
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel &lt;Jens.Oehlschlaegel@truecluster.com&gt;
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+c.integer64">c.integer64</a></code> <code><a href="#topic+rep.integer64">rep.integer64</a></code> 
<code><a href="#topic+as.data.frame.integer64">as.data.frame.integer64</a></code> <code><a href="#topic+integer64">integer64</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # colon not activated: as.integer64(1):12
  seq(as.integer64(1), 12, 2)
  seq(as.integer64(1), by=2, length.out=6)
</code></pre>

<hr>
<h2 id='sort.integer64'>
High-level intger64 methods for sorting and ordering
</h2><span id='topic+sort.integer64'></span><span id='topic+order.integer64'></span>

<h3>Description</h3>

<p>Fast high-level methods for sorting and ordering. 
These are wrappers to <code><a href="bit.html#topic+ramsort">ramsort</a></code> and friends and do not modify their arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'integer64'
sort(x, decreasing = FALSE, has.na = TRUE, na.last = TRUE, stable = TRUE
, optimize = c("time", "memory"), VERBOSE = FALSE, ...)
## S3 method for class 'integer64'
order(..., na.last = TRUE, decreasing = FALSE, has.na = TRUE, stable = TRUE
, optimize = c("time", "memory"), VERBOSE = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort.integer64_+3A_x">x</code></td>
<td>
<p> a vector to be sorted by <code><a href="bit.html#topic+ramsort">ramsort</a></code> and <code><a href="bit.html#topic+ramsortorder">ramsortorder</a></code>, i.e. the output of  <code><a href="base.html#topic+sort">sort</a></code> </p>
</td></tr>
<tr><td><code id="sort.integer64_+3A_has.na">has.na</code></td>
<td>

<p>boolean scalar defining whether the input vector might contain <code>NA</code>s. If we know we don't have NAs, this may speed-up.
<em>Note</em> that you risk a crash if there are unexpected <code>NA</code>s with <code>has.na=FALSE</code>
</p>
</td></tr>
<tr><td><code id="sort.integer64_+3A_na.last">na.last</code></td>
<td>

<p>boolean scalar telling ramsort whether to sort <code>NA</code>s last or first.
<em>Note</em> that 'boolean' means that there is no third option <code>NA</code> as in <code><a href="base.html#topic+sort">sort</a></code>
</p>
</td></tr>
<tr><td><code id="sort.integer64_+3A_decreasing">decreasing</code></td>
<td>

<p>boolean scalar telling ramsort whether to sort increasing or decreasing
</p>
</td></tr>
<tr><td><code id="sort.integer64_+3A_stable">stable</code></td>
<td>

<p>boolean scalar defining whether stable sorting is needed. Allowing non-stable may speed-up.
</p>
</td></tr>
<tr><td><code id="sort.integer64_+3A_optimize">optimize</code></td>
<td>

<p>by default ramsort optimizes for 'time' which requires more RAM,
set to 'memory' to minimize RAM requirements and sacrifice speed
</p>
</td></tr>
<tr><td><code id="sort.integer64_+3A_verbose">VERBOSE</code></td>
<td>

<p>cat some info about chosen method
</p>
</td></tr>
<tr><td><code id="sort.integer64_+3A_...">...</code></td>
<td>
<p> further arguments, passed from generics, ignored in methods </p>
</td></tr>
</table>


<h3>Details</h3>

<p>see <code><a href="base.html#topic+sort">sort</a></code> and <code><a href="#topic+order">order</a></code>
</p>


<h3>Value</h3>

<p><code>sort</code> returns the sorted vector and <code>vector</code> returns the order positions. 
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel &lt;Jens.Oehlschlaegel@truecluster.com&gt;
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+sort.integer64">sort</a></code>, <code><a href="#topic+sortcache">sortcache</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
  x
  sort(x)
  message("the following has default optimize='time' which is faster but requires more RAM
, this calls 'ramorder'")
  order.integer64(x)
  message("slower with less RAM, this calls 'ramsortorder'")
  order.integer64(x, optimize="memory")
</code></pre>

<hr>
<h2 id='sortnut'>
Searching and other uses of sorting for 64bit integers
</h2><span id='topic+sortnut'></span><span id='topic+sortnut.integer64'></span><span id='topic+ordernut'></span><span id='topic+ordernut.integer64'></span><span id='topic+sortfin'></span><span id='topic+sortfin.integer64'></span><span id='topic+orderpos'></span><span id='topic+orderpos.integer64'></span><span id='topic+orderfin'></span><span id='topic+orderfin.integer64'></span><span id='topic+sortorderpos'></span><span id='topic+sortorderpos.integer64'></span><span id='topic+orderdup'></span><span id='topic+orderdup.integer64'></span><span id='topic+sortorderdup'></span><span id='topic+sortorderdup.integer64'></span><span id='topic+sortuni'></span><span id='topic+sortuni.integer64'></span><span id='topic+orderuni'></span><span id='topic+orderuni.integer64'></span><span id='topic+sortorderuni'></span><span id='topic+sortorderuni.integer64'></span><span id='topic+orderupo'></span><span id='topic+orderupo.integer64'></span><span id='topic+sortorderupo'></span><span id='topic+sortorderupo.integer64'></span><span id='topic+ordertie'></span><span id='topic+ordertie.integer64'></span><span id='topic+sortordertie'></span><span id='topic+sortordertie.integer64'></span><span id='topic+sorttab'></span><span id='topic+sorttab.integer64'></span><span id='topic+ordertab'></span><span id='topic+ordertab.integer64'></span><span id='topic+sortordertab'></span><span id='topic+sortordertab.integer64'></span><span id='topic+orderkey'></span><span id='topic+orderkey.integer64'></span><span id='topic+sortorderkey'></span><span id='topic+sortorderkey.integer64'></span><span id='topic+orderrnk'></span><span id='topic+orderrnk.integer64'></span><span id='topic+sortorderrnk'></span><span id='topic+sortorderrnk.integer64'></span><span id='topic+sortqtl'></span><span id='topic+sortqtl.integer64'></span><span id='topic+orderqtl'></span><span id='topic+orderqtl.integer64'></span>

<h3>Description</h3>

<p>This is roughly an implementation of hash functionality but based on sorting instead on a hasmap.
Since sorting is more informative than hashingwe can do some more interesting things.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sortnut(sorted, ...)
ordernut(table, order, ...)
sortfin(sorted, x, ...)
orderfin(table, order, x, ...)
orderpos(table, order, x, ...)
sortorderpos(sorted, order, x, ...)
orderdup(table, order, ...)
sortorderdup(sorted, order, ...)
sortuni(sorted, nunique, ...)
orderuni(table, order, nunique, ...)
sortorderuni(table, sorted, order, nunique, ...)
orderupo(table, order, nunique, ...)
sortorderupo(sorted, order, nunique, keep.order = FALSE, ...)
ordertie(table, order, nties, ...)
sortordertie(sorted, order, nties, ...)
sorttab(sorted, nunique, ...)
ordertab(table, order, nunique, ...)
sortordertab(sorted, order, ...)
orderkey(table, order, na.skip.num = 0L, ...)
sortorderkey(sorted, order, na.skip.num = 0L, ...)
orderrnk(table, order, na.count, ...)
sortorderrnk(sorted, order, na.count, ...)
## S3 method for class 'integer64'
sortnut(sorted, ...)
## S3 method for class 'integer64'
ordernut(table, order, ...)
## S3 method for class 'integer64'
sortfin(sorted, x, method=NULL, ...)
## S3 method for class 'integer64'
orderfin(table, order, x, method=NULL, ...)
## S3 method for class 'integer64'
orderpos(table, order, x, nomatch=NA, method=NULL, ...)
## S3 method for class 'integer64'
sortorderpos(sorted, order, x, nomatch=NA, method=NULL, ...)
## S3 method for class 'integer64'
orderdup(table, order, method=NULL, ...)
## S3 method for class 'integer64'
sortorderdup(sorted, order, method=NULL, ...)
## S3 method for class 'integer64'
sortuni(sorted, nunique, ...)
## S3 method for class 'integer64'
orderuni(table, order, nunique, keep.order=FALSE, ...)
## S3 method for class 'integer64'
sortorderuni(table, sorted, order, nunique, ...)
## S3 method for class 'integer64'
orderupo(table, order, nunique, keep.order=FALSE, ...)
## S3 method for class 'integer64'
sortorderupo(sorted, order, nunique, keep.order = FALSE, ...)
## S3 method for class 'integer64'
ordertie(table, order, nties, ...)
## S3 method for class 'integer64'
sortordertie(sorted, order, nties, ...)
## S3 method for class 'integer64'
sorttab(sorted, nunique, ...)
## S3 method for class 'integer64'
ordertab(table, order, nunique, denormalize=FALSE, keep.order=FALSE, ...)
## S3 method for class 'integer64'
sortordertab(sorted, order, denormalize=FALSE, ...)
## S3 method for class 'integer64'
orderkey(table, order, na.skip.num = 0L, ...)
## S3 method for class 'integer64'
sortorderkey(sorted, order, na.skip.num = 0L, ...)
## S3 method for class 'integer64'
orderrnk(table, order, na.count, ...)
## S3 method for class 'integer64'
sortorderrnk(sorted, order, na.count, ...)
## S3 method for class 'integer64'
sortqtl(sorted, na.count, probs, ...)
## S3 method for class 'integer64'
orderqtl(table, order, na.count, probs, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sortnut_+3A_x">x</code></td>
<td>
<p> an <code><a href="#topic+integer64">integer64</a></code> vector </p>
</td></tr>
<tr><td><code id="sortnut_+3A_sorted">sorted</code></td>
<td>
<p> a sorted <code><a href="#topic+integer64">integer64</a></code> vector </p>
</td></tr>
<tr><td><code id="sortnut_+3A_table">table</code></td>
<td>
<p> the original data with original order under the sorted vector </p>
</td></tr>
<tr><td><code id="sortnut_+3A_order">order</code></td>
<td>
<p> an <code><a href="base.html#topic+integer">integer</a></code> order vector that turns 'table' into 'sorted' </p>
</td></tr>
<tr><td><code id="sortnut_+3A_nunique">nunique</code></td>
<td>
<p> number of unique elements, usually we get this from cache or call <code>sortnut</code> or <code>ordernut</code> </p>
</td></tr>
<tr><td><code id="sortnut_+3A_nties">nties</code></td>
<td>
<p> number of tied values, usually we get this from cache or call <code>sortnut</code> or <code>ordernut</code> </p>
</td></tr>
<tr><td><code id="sortnut_+3A_denormalize">denormalize</code></td>
<td>
<p> FALSE returns counts of unique values, TRUE returns each value with its counts </p>
</td></tr>
<tr><td><code id="sortnut_+3A_nomatch">nomatch</code></td>
<td>
<p> the value to be returned if an element is not found in the hashmap </p>
</td></tr>
<tr><td><code id="sortnut_+3A_keep.order">keep.order</code></td>
<td>
<p> determines order of results and speed: <code>FALSE</code> (the default) is faster and returns in sorted order, <code>TRUE</code> returns in the order of first appearance in the original data, but this requires extra work </p>
</td></tr> 
<tr><td><code id="sortnut_+3A_probs">probs</code></td>
<td>
<p> vector of probabilities in [0..1] for which we seek quantiles </p>
</td></tr>
<tr><td><code id="sortnut_+3A_na.skip.num">na.skip.num</code></td>
<td>
<p> 0 or the number of <code>NA</code>s. With 0, <code>NA</code>s are coded with 1L, with the number of <code>NA</code>s, these are coded with <code>NA</code>, the latter needed for <code><a href="#topic+as.factor.integer64">as.factor.integer64</a></code> </p>
</td></tr>
<tr><td><code id="sortnut_+3A_na.count">na.count</code></td>
<td>
<p> the number of <code>NA</code>s, needed for this low-level function algorithm </p>
</td></tr>
<tr><td><code id="sortnut_+3A_method">method</code></td>
<td>
<p> see details </p>
</td></tr>
<tr><td><code id="sortnut_+3A_...">...</code></td>
<td>
<p> further arguments, passed from generics, ignored in methods </p>
</td></tr>
</table>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: right;">
   <b>sortfun</b> </td><td style="text-align: right;"> <b>orderfun</b> </td><td style="text-align: right;"> <b>sortorderfun</b> </td><td style="text-align: right;"> <b>see also</b>          </td><td style="text-align: left;"> <b>description</b> </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>sortnut</code> </td><td style="text-align: right;"> <code>ordernut</code> </td><td style="text-align: right;">                     </td><td style="text-align: right;">  </td><td style="text-align: left;"> return number of tied and of unique values </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>sortfin</code> </td><td style="text-align: right;"> <code>orderfin</code> </td><td style="text-align: right;">                     </td><td style="text-align: right;"> <code><a href="#topic++25in+25.integer64">%in%.integer64</a></code> </td><td style="text-align: left;"> return logical whether <code>x</code> is in <code>table</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
                  </td><td style="text-align: right;"> <code>orderpos</code> </td><td style="text-align: right;"> <code>sortorderpos</code> </td><td style="text-align: right;"> <code><a href="#topic+match.integer64">match</a></code> </td><td style="text-align: left;"> return positions of <code>x</code> in <code>table</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
                  </td><td style="text-align: right;"> <code>orderdup</code> </td><td style="text-align: right;"> <code>sortorderdup</code> </td><td style="text-align: right;"> <code><a href="#topic+duplicated.integer64">duplicated</a></code> </td><td style="text-align: left;"> return logical whether values are duplicated </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>sortuni</code> </td><td style="text-align: right;"> <code>orderuni</code> </td><td style="text-align: right;"> <code>sortorderuni</code> </td><td style="text-align: right;"> <code><a href="#topic+unique.integer64">unique</a></code> </td><td style="text-align: left;"> return unique values (=dimensiontable) </td>
</tr>
<tr>
 <td style="text-align: right;">
                  </td><td style="text-align: right;"> <code>orderupo</code> </td><td style="text-align: right;"> <code>sortorderupo</code> </td><td style="text-align: right;"> <code><a href="#topic+unique.integer64">unique</a></code> </td><td style="text-align: left;"> return positions of unique values </td>
</tr>
<tr>
 <td style="text-align: right;">
                  </td><td style="text-align: right;"> <code>ordertie</code> </td><td style="text-align: right;"> <code>sortordertie</code> </td><td style="text-align: right;">  </td><td style="text-align: left;"> return positions of tied values </td>
</tr>
<tr>
 <td style="text-align: right;">
                  </td><td style="text-align: right;"> <code>orderkey</code> </td><td style="text-align: right;"> <code>sortorderkey</code> </td><td style="text-align: right;">  </td><td style="text-align: left;"> positions of values in vector of unique values (match in dimensiontable) </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>sorttab</code> </td><td style="text-align: right;"> <code>ordertab</code> </td><td style="text-align: right;"> <code>sortordertab</code> </td><td style="text-align: right;"> <code><a href="#topic+table.integer64">table</a></code> </td><td style="text-align: left;"> tabulate frequency of values  </td>
</tr>
<tr>
 <td style="text-align: right;">
                  </td><td style="text-align: right;"> <code>orderrnk</code> </td><td style="text-align: right;"> <code>sortorderrnk</code> </td><td style="text-align: right;">  </td><td style="text-align: left;"> rank averaging ties </td>
</tr>
<tr>
 <td style="text-align: right;">
   <code>sortqtl</code> </td><td style="text-align: right;"> <code>orderqtl</code> </td><td style="text-align: right;">                     </td><td style="text-align: right;">  </td><td style="text-align: left;"> return quantiles given probabilities </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

<p>The functions <code>sortfin</code>, <code>orderfin</code>, <code>orderpos</code> and <code>sortorderpos</code> each offer three algorithms for finding <code>x</code> in <code>table</code>.  <br />
With <code>method=1L</code> each value of <code>x</code> is searched independently using <em>binary search</em>, this is fastest for small <code>table</code>s. <br />
With <code>method=2L</code> the values of <code>x</code> are first sorted and then searched using <em>doubly exponential search</em>, this is the best allround method. <br />
With <code>method=3L</code> the values of <code>x</code> are first sorted and then searched using simple merging, this is the fastest method if <code>table</code> is huge and <code>x</code> has similar size and distribution of values. <br />
With <code>method=NULL</code> the functions use a heuristic to determine the fastest algorithm. <br />
</p>
<p>The functions <code>orderdup</code> and <code>sortorderdup</code> each offer two algorithms for setting the truth values in the return vector.  <br />
With <code>method=1L</code> the return values are set directly which causes random write access on a possibly large return vector. <br />
With <code>method=2L</code> the return values are first set in a smaller bit-vector &ndash; random access limited to a smaller memory region &ndash; and finally written sequentially to the logical output  vector. <br />
With <code>method=NULL</code> the functions use a heuristic to determine the fastest algorithm. <br />
</p>


<h3>Value</h3>

<p>see details
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel &lt;Jens.Oehlschlaegel@truecluster.com&gt;
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+match.integer64">match</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> message("check the code of 'optimizer64' for examples:")
 print(optimizer64)
</code></pre>

<hr>
<h2 id='sum.integer64'>
Summary functions for integer64 vectors
</h2><span id='topic+all.integer64'></span><span id='topic+any.integer64'></span><span id='topic+min.integer64'></span><span id='topic+max.integer64'></span><span id='topic+range.integer64'></span><span id='topic+lim.integer64'></span><span id='topic+sum.integer64'></span><span id='topic+prod.integer64'></span>

<h3>Description</h3>

<p>Summary functions for integer64 vectors. 
Function 'range' without arguments returns the smallest and largest value of the 'integer64' class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'integer64'
all(..., na.rm = FALSE)
## S3 method for class 'integer64'
any(..., na.rm = FALSE)
## S3 method for class 'integer64'
min(..., na.rm = FALSE)
## S3 method for class 'integer64'
max(..., na.rm = FALSE)
## S3 method for class 'integer64'
range(..., na.rm = FALSE, finite = FALSE)
lim.integer64()
## S3 method for class 'integer64'
sum(..., na.rm = FALSE)
## S3 method for class 'integer64'
prod(..., na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum.integer64_+3A_...">...</code></td>
<td>
<p> atomic vectors of class 'integer64'</p>
</td></tr>
<tr><td><code id="sum.integer64_+3A_na.rm">na.rm</code></td>
<td>
<p> logical scalar indicating whether to ignore NAs </p>
</td></tr>
<tr><td><code id="sum.integer64_+3A_finite">finite</code></td>
<td>
<p> logical scalar indicating whether to ignore NAs (just for compatibility with <code><a href="base.html#topic+range.default">range.default</a></code>) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The numerical summary methods always return <code>integer64</code>. 
Therefor the methods for <code>min</code>,<code>max</code> and <code>range</code> do not return <code>+Inf,-Inf</code>
on empty arguments, but <code>+9223372036854775807, -9223372036854775807</code> (in this sequence).
The same is true if only  <code>NA</code>s are submitted with argument <code>na.rm=TRUE</code>. 
<br />
<code>lim.integer64</code> returns these limits in proper order <code>-9223372036854775807, +9223372036854775807</code> and without a <code><a href="base.html#topic+warning">warning</a></code>.
</p>


<h3>Value</h3>

<p><code><a href="base.html#topic+all">all</a></code> and <code><a href="base.html#topic+any">any</a></code> return a logical scalar<br />
<code><a href="base.html#topic+range">range</a></code> returns a integer64 vector with two elements<br />
<code><a href="base.html#topic+min">min</a></code>, <code><a href="base.html#topic+max">max</a></code>, <code><a href="base.html#topic+sum">sum</a></code> and <code><a href="base.html#topic+prod">prod</a></code> return a integer64 scalar
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel &lt;Jens.Oehlschlaegel@truecluster.com&gt;
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+mean.integer64">mean.integer64</a></code> <code><a href="#topic+cumsum.integer64">cumsum.integer64</a></code> <code><a href="#topic+integer64">integer64</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>  lim.integer64()
  range(as.integer64(1:12))
</code></pre>

<hr>
<h2 id='table.integer64'>Cross Tabulation and Table Creation for integer64</h2><span id='topic+table.integer64'></span>

<h3>Description</h3>

<p><code>table.integer64</code> uses the cross-classifying integer64 vectors to build a contingency
table of the counts at each combination of vector values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table.integer64(...
, return = c("table","data.frame","list")
, order = c("values","counts")
, nunique = NULL
, method = NULL
, dnn = list.names(...), deparse.level = 1
) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table.integer64_+3A_...">...</code></td>
<td>
<p>one or more objects which can be interpreted as factors
(including character strings), or a list (or data frame) whose
components can be so interpreted.  (For <code>as.table</code> and
<code>as.data.frame</code>, arguments passed to specific methods.)</p>
</td></tr>
<tr><td><code id="table.integer64_+3A_nunique">nunique</code></td>
<td>

<p>NULL or the number of unique values of table (including NA). Providing <code>nunique</code> can speed-up matching when <code>table</code> has no cache. Note that a wrong nunique can cause undefined behaviour up to a crash.
</p>
</td></tr>
<tr><td><code id="table.integer64_+3A_order">order</code></td>
<td>

<p>By default results are created sorted by &quot;values&quot;, or by &quot;counts&quot;
</p>
</td></tr>
<tr><td><code id="table.integer64_+3A_method">method</code></td>
<td>

<p>NULL for automatic method selection or a suitable low-level method, see details
</p>
</td></tr>
<tr><td><code id="table.integer64_+3A_return">return</code></td>
<td>

<p>choose the return format, see details
</p>
</td></tr>
<tr><td><code id="table.integer64_+3A_dnn">dnn</code></td>
<td>
<p>the names to be given to the dimensions in the result (the
<em>dimnames names</em>).</p>
</td></tr>
<tr><td><code id="table.integer64_+3A_deparse.level">deparse.level</code></td>
<td>
<p>controls how the default <code>dnn</code> is
constructed.  See &lsquo;Details&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function automatically chooses from several low-level functions considering the size of <code>x</code> and the availability of a cache. 
Suitable methods are <code><a href="#topic+hashmaptab">hashmaptab</a></code> (simultaneously creating and using a hashmap)
, <code><a href="#topic+hashtab">hashtab</a></code> (first creating a hashmap then using it)
, <code><a href="#topic+sortordertab">sortordertab</a></code> (fast ordering) 
and <code><a href="#topic+ordertab">ordertab</a></code> (memory saving ordering).
<br />
If the argument <code>dnn</code> is not supplied, the internal function
<code>list.names</code> is called to compute the &lsquo;dimname names&rsquo;.  If the
arguments in <code>...</code> are named, those names are used.  For the
remaining arguments, <code>deparse.level = 0</code> gives an empty name,
<code>deparse.level = 1</code> uses the supplied argument if it is a symbol,
and <code>deparse.level = 2</code> will deparse the argument.
</p>
<p>Arguments <code>exclude</code>, <code>useNA</code>, are not supported, i.e. <code>NA</code>s are always tabulated, and, different from <code><a href="base.html#topic+table">table</a></code> they are sorted first if <code>order="values"</code>. 
</p>


<h3>Value</h3>

<p>By default (with <code>return="table"</code>) <code><a href="base.html#topic+table">table</a></code> returns a <em>contingency table</em>, an object of
class <code>"table"</code>, an array of integer values. Note that unlike S the result is always an array, a 1D array if one factor is given. Note also that for multidimensional arrays this is a <em>dense</em> return structure which can dramatically increase RAM requirements (for large arrays with high mutual information, i.e. many possible input combinations of which only few occur) and that <code><a href="base.html#topic+table">table</a></code> is limited to <code>2^31</code> possible combinations (e.g. two input vectors with 46340 unique values only). Finally note that the tabulated values or value-combinations are represented as <code>dimnames</code> and that the implied conversion of values to strings can cause <em>severe</em> performance problems since each string needs to be integrated into R's global string cache. 
<br />
You can use the other <code>return=</code> options to cope with these problems, the potential combination limit is increased from <code>2^31</code> to <code>2^63</code> with these options, RAM is only rewquired for observed combinations and string conversion is avoided. 
<br />
With <code>return="data.frame"</code> you get a <em>dense</em> representation as a <code><a href="base.html#topic+data.frame">data.frame</a></code> (like that resulting from <code>as.data.frame(table(...))</code>) where only observed combinations are listed (each as a data.frame row) with the corresponding frequency counts (the latter as component
named by <code>responseName</code>).  This is the inverse of <code><a href="stats.html#topic+xtabs">xtabs</a></code>..
<br />
With <code>return="list"</code> you also get a <em>dense</em> representation as a simple <code><a href="base.html#topic+list">list</a></code> with components 
</p>
<table>
<tr><td><code>values</code></td>
<td>
<p>a integer64 vector of the technically tabulated values, for 1D this is the tabulated values themselves, for kD these are the values representing the potential combinations of input values</p>
</td></tr>
<tr><td><code>counts</code></td>
<td>
<p>the frequency counts</p>
</td></tr>
<tr><td><code>dims</code></td>
<td>
<p>only for kD: a list with the vectors of the unique values of the input dimensions</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Note that by using <code><a href="#topic+as.integer64.factor">as.integer64.factor</a></code> we can also input 
factors into <code>table.integer64</code> &ndash; only the <code><a href="base.html#topic+levels">levels</a></code> get lost.
<br />
Note that because of the existence of <code><a href="#topic+as.factor.integer64">as.factor.integer64</a></code> 
the standard <code><a href="base.html#topic+table">table</a></code> function &ndash; within its limits &ndash; can also be used 
for <code><a href="#topic+integer64">integer64</a></code>, and especially for combining <code><a href="#topic+integer64">integer64</a></code> input 
with other data types.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+table">table</a></code> for more info on the standard version coping with Base R's data types, <code><a href="base.html#topic+tabulate">tabulate</a></code> which can faster tabulate <code><a href="base.html#topic+integer">integer</a>s</code> with a limited range <code>[1L .. nL not too big]</code>, <code><a href="#topic+unique.integer64">unique.integer64</a></code> for the unique values without counting them and <code><a href="#topic+unipos.integer64">unipos.integer64</a></code> for the positions of the unique values. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>message("pure integer64 examples")
x &lt;- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
y &lt;- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
z &lt;- sample(c(rep(NA, 9), letters), 32, TRUE)
table.integer64(x)
table.integer64(x, order="counts")
table.integer64(x, y)
table.integer64(x, y, return="data.frame")

message("via as.integer64.factor we can use 'table.integer64' also for factors")
table.integer64(x, as.integer64(as.factor(z)))

message("via as.factor.integer64 we can also use 'table' for integer64")
table(x)
table(x, exclude=NULL)
table(x, z, exclude=NULL)



</code></pre>

<hr>
<h2 id='tiepos'>Extract Positions of Tied Elements</h2><span id='topic+tiepos'></span><span id='topic+tiepos.integer64'></span>

<h3>Description</h3>

<p><code>tiepos</code> returns the positions of those elements that participate in ties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tiepos(x, ...)
## S3 method for class 'integer64'
tiepos(x, nties = NULL, method = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tiepos_+3A_x">x</code></td>
<td>
<p>a vector or a data frame or an array or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="tiepos_+3A_nties">nties</code></td>
<td>

<p>NULL or the number of tied values (including NA). Providing <code>nties</code> can speed-up when <code>x</code> has no cache. Note that a wrong nties can cause undefined behaviour up to a crash.
</p>
</td></tr>
<tr><td><code id="tiepos_+3A_method">method</code></td>
<td>

<p>NULL for automatic method selection or a suitable low-level method, see details
</p>
</td></tr>
<tr><td><code id="tiepos_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function automatically chooses from several low-level functions considering the size of <code>x</code> and the availability of a cache. 
Suitable methods are <code><a href="#topic+sortordertie">sortordertie</a></code> (fast ordering) 
and <code><a href="#topic+ordertie">ordertie</a></code> (memory saving ordering).
</p>


<h3>Value</h3>

<p>an integer vector of positions
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel &lt;Jens.Oehlschlaegel@truecluster.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rank.integer64">rank.integer64</a></code> for possibly tied ranks and <code><a href="#topic+unipos.integer64">unipos.integer64</a></code> for positions of unique values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
tiepos(x)

stopifnot(identical(tiepos(x),  (1:length(x))[duplicated(x) | rev(duplicated(rev(x)))]))
</code></pre>

<hr>
<h2 id='unipos'>Extract Positions of Unique Elements</h2><span id='topic+unipos'></span><span id='topic+unipos.integer64'></span>

<h3>Description</h3>

<p><code>unipos</code> returns the positions of those elements returned by <code><a href="base.html#topic+unique">unique</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unipos(x, incomparables = FALSE, order = c("original","values","any"), ...)
## S3 method for class 'integer64'
unipos(x, incomparables = FALSE, order = c("original","values","any")
, nunique = NULL, method = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unipos_+3A_x">x</code></td>
<td>
<p>a vector or a data frame or an array or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="unipos_+3A_incomparables">incomparables</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="unipos_+3A_order">order</code></td>
<td>
<p>The order in which positions of unique values will be returned, see details</p>
</td></tr>
<tr><td><code id="unipos_+3A_nunique">nunique</code></td>
<td>

<p>NULL or the number of unique values (including NA). Providing <code>nunique</code> can speed-up when <code>x</code> has no cache. Note that a wrong nunique can cause undefined behaviour up to a crash.
</p>
</td></tr>
<tr><td><code id="unipos_+3A_method">method</code></td>
<td>

<p>NULL for automatic method selection or a suitable low-level method, see details
</p>
</td></tr>
<tr><td><code id="unipos_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function automatically chooses from several low-level functions considering the size of <code>x</code> and the availability of a cache. 
Suitable methods are <code><a href="#topic+hashmapupo">hashmapupo</a></code> (simultaneously creating and using a hashmap)
, <code><a href="#topic+hashupo">hashupo</a></code> (first creating a hashmap then using it)
, <code><a href="#topic+sortorderupo">sortorderupo</a></code> (fast ordering) 
and <code><a href="#topic+orderupo">orderupo</a></code> (memory saving ordering).
<br />
The default <code>order="original"</code> collects unique values in the order of the first appearance in <code>x</code> like in <code><a href="base.html#topic+unique">unique</a></code>, this costs extra processing. 
<code>order="values"</code> collects unique values in sorted order like in <code><a href="base.html#topic+table">table</a></code>, this costs extra processing with the hash methods but comes for free. 
<code>order="any"</code> collects unique values in undefined order, possibly faster. For hash methods this will be a quasi random order, for sort methods this will be sorted order.
</p>


<h3>Value</h3>

<p>an integer vector of positions
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel &lt;Jens.Oehlschlaegel@truecluster.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unique.integer64">unique.integer64</a></code> for unique values and <code><a href="#topic+match.integer64">match.integer64</a></code> for general matching.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
unipos(x)
unipos(x, order="values")

stopifnot(identical(unipos(x),  (1:length(x))[!duplicated(x)]))
stopifnot(identical(unipos(x),  match.integer64(unique(x), x)))
stopifnot(identical(unipos(x, order="values"),  match.integer64(unique(x, order="values"), x)))
stopifnot(identical(unique(x),  x[unipos(x)]))
stopifnot(identical(unique(x, order="values"),  x[unipos(x, order="values")]))
</code></pre>

<hr>
<h2 id='unique.integer64'>Extract Unique Elements from integer64</h2><span id='topic+unique.integer64'></span>

<h3>Description</h3>

<p><code>unique</code> returns a vector like <code>x</code> but with duplicate elements/rows removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'integer64'
unique(x, incomparables = FALSE, order = c("original","values","any")
, nunique = NULL, method = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unique.integer64_+3A_x">x</code></td>
<td>
<p>a vector or a data frame or an array or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="unique.integer64_+3A_incomparables">incomparables</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="unique.integer64_+3A_order">order</code></td>
<td>
<p>The order in which unique values will be returned, see details</p>
</td></tr>
<tr><td><code id="unique.integer64_+3A_nunique">nunique</code></td>
<td>

<p>NULL or the number of unique values (including NA). Providing <code>nunique</code> can speed-up matching when <code>x</code> has no cache. Note that a wrong nunique can cause undefined behaviour up to a crash.
</p>
</td></tr>
<tr><td><code id="unique.integer64_+3A_method">method</code></td>
<td>

<p>NULL for automatic method selection or a suitable low-level method, see details
</p>
</td></tr>
<tr><td><code id="unique.integer64_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function automatically chooses from several low-level functions considering the size of <code>x</code> and the availability of a cache. 
Suitable methods are <code><a href="#topic+hashmapuni">hashmapuni</a></code> (simultaneously creating and using a hashmap)
, <code><a href="#topic+hashuni">hashuni</a></code> (first creating a hashmap then using it)
, <code><a href="#topic+sortuni">sortuni</a></code> (fast sorting for sorted order only)
, <code><a href="#topic+sortorderuni">sortorderuni</a></code> (fast ordering for original order only) 
and <code><a href="#topic+orderuni">orderuni</a></code> (memory saving ordering).
<br />
The default <code>order="original"</code> returns unique values in the order of the first appearance in <code>x</code> like in <code><a href="base.html#topic+unique">unique</a></code>, this costs extra processing. 
<code>order="values"</code> returns unique values in sorted order like in <code><a href="base.html#topic+table">table</a></code>, this costs extra processing with the hash methods but comes for free. 
<code>order="any"</code> returns unique values in undefined order, possibly faster. For hash methods this will be a quasi random order, for sort methods this will be sorted order.
</p>


<h3>Value</h3>

<p>For a vector, an object of the same type of <code>x</code>, but with only
one copy of each duplicated element.  No attributes are copied (so
the result has no names).
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel &lt;Jens.Oehlschlaegel@truecluster.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+unique">unique</a></code> for the generic, <code><a href="#topic+unipos">unipos</a></code> which gives the indices of the unique
elements and <code><a href="#topic+table.integer64">table.integer64</a></code> which gives frequencies of the unique elements.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.integer64(sample(c(rep(NA, 9), 1:9), 32, TRUE))
unique(x)
unique(x, order="values")

stopifnot(identical(unique(x),  x[!duplicated(x)]))
stopifnot(identical(unique(x),  as.integer64(unique(as.integer(x)))))
stopifnot(identical(unique(x, order="values")
,  as.integer64(sort(unique(as.integer(x)), na.last=FALSE))))
</code></pre>

<hr>
<h2 id='xor.integer64'>
Binary operators for integer64 vectors
</h2><span id='topic++26.integer64'></span><span id='topic++7C.integer64'></span><span id='topic+xor.integer64'></span><span id='topic++21+3D.integer64'></span><span id='topic++3D+3D.integer64'></span><span id='topic++3C.integer64'></span><span id='topic++3C+3D.integer64'></span><span id='topic++3E.integer64'></span><span id='topic++3E+3D.integer64'></span><span id='topic++2B.integer64'></span><span id='topic+-.integer64'></span><span id='topic++2A.integer64'></span><span id='topic++5E.integer64'></span><span id='topic++2F.integer64'></span><span id='topic++25+2F+25.integer64'></span><span id='topic++25+25.integer64'></span><span id='topic+binattr'></span>

<h3>Description</h3>

<p>Binary operators for integer64 vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'integer64'
e1 &amp; e2
## S3 method for class 'integer64'
e1 | e2
## S3 method for class 'integer64'
xor(x,y)
## S3 method for class 'integer64'
e1 != e2
## S3 method for class 'integer64'
e1 == e2
## S3 method for class 'integer64'
e1 &lt; e2
## S3 method for class 'integer64'
e1 &lt;= e2
## S3 method for class 'integer64'
e1 &gt; e2
## S3 method for class 'integer64'
e1 &gt;= e2
## S3 method for class 'integer64'
e1 + e2
## S3 method for class 'integer64'
e1 - e2
## S3 method for class 'integer64'
e1 * e2
## S3 method for class 'integer64'
e1 ^ e2
## S3 method for class 'integer64'
e1 / e2
## S3 method for class 'integer64'
e1 %/% e2
## S3 method for class 'integer64'
e1 %% e2
binattr(e1,e2) # for internal use only
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xor.integer64_+3A_e1">e1</code></td>
<td>
<p> an atomic vector of class 'integer64'</p>
</td></tr>
<tr><td><code id="xor.integer64_+3A_e2">e2</code></td>
<td>
<p> an atomic vector of class 'integer64'</p>
</td></tr>
<tr><td><code id="xor.integer64_+3A_x">x</code></td>
<td>
<p> an atomic vector of class 'integer64'</p>
</td></tr>
<tr><td><code id="xor.integer64_+3A_y">y</code></td>
<td>
<p> an atomic vector of class 'integer64'</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="base.html#topic++26">&amp;</a></code>, <code><a href="base.html#topic++7C">|</a></code>, <code><a href="base.html#topic+xor">xor</a></code>, <code><a href="base.html#topic++21+3D">!=</a></code>, <code><a href="base.html#topic++3D+3D">==</a></code>, 
<code><a href="base.html#topic++3C">&lt;</a></code>, <code><a href="base.html#topic++3C+3D">&lt;=</a></code>, <code><a href="base.html#topic++3E">&gt;</a></code>, <code><a href="base.html#topic++3E+3D">&gt;=</a></code> return a logical vector <br />
<code><a href="base.html#topic++5E">^</a></code> and <code><a href="base.html#topic++2F">/</a></code> return a double vector<br />
<code><a href="base.html#topic++2B">+</a></code>, <code><a href="base.html#topic+-">-</a></code>, <code><a href="base.html#topic++2A">*</a></code>, <code><a href="base.html#topic++25+2F+25">%/%</a></code>, <code><a href="base.html#topic++25+25">%%</a></code>
return a vector of class 'integer64'
</p>


<h3>Author(s)</h3>

<p>Jens Oehlschlägel &lt;Jens.Oehlschlaegel@truecluster.com&gt;
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+format.integer64">format.integer64</a></code> <code><a href="#topic+integer64">integer64</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>  as.integer64(1:12) - 1
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
