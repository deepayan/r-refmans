<!DOCTYPE html><html lang="en"><head><title>Help for package subsampling</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {subsampling}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#subsampling'><p>Optimal Subsampling Methods for Statistical Models</p></a></li>
<li><a href='#ssp.glm'><p>Optimal Subsampling Methods for Generalized Linear Models</p></a></li>
<li><a href='#ssp.quantreg'><p>Optimal Subsampling Methods for Quantile Regression Model</p></a></li>
<li><a href='#ssp.relogit'><p>Optimal Subsampling for Logistic Regression Model with Rare Events Data</p></a></li>
<li><a href='#ssp.softmax'><p>Optimal Subsampling Method for Softmax (multinomial logistic) Regression Model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Optimal Subsampling Methods for Statistical Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-11-2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Qingkai Dong &lt;qingkai.dong@uconn.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>
    Balancing computational and statistical efficiency, subsampling techniques offer
    a practical solution for handling large-scale data analysis. Subsampling methods
    enhance statistical modeling for massive datasets by efficiently drawing
    representative subsamples from full dataset based on tailored sampling probabilities. These
    probabilities are optimized for specific goals, such as minimizing the variance
    of coefficient estimates or reducing prediction error.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/dqksnow/Subsampling">https://github.com/dqksnow/Subsampling</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/dqksnow/Subsampling/issues">https://github.com/dqksnow/Subsampling/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>expm, nnet, quantreg, Rcpp (&ge; 1.0.12), stats, survey</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, MASS, rmarkdown, tinytest</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-02 23:30:06 UTC; qingkaidong</td>
</tr>
<tr>
<td>Author:</td>
<td>Qingkai Dong [aut, cre, cph],
  Yaqiong Yao [aut],
  Haiying Wang [aut],
  Qiang Zhang [ctb],
  Jun Yan [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-05 10:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='subsampling'>Optimal Subsampling Methods for Statistical Models</h2><span id='topic+subsampling-package'></span><span id='topic+subsampling'></span>

<h3>Description</h3>

<p>Subsampling methods are utilized in statistical modeling for
massive datasets. These methods aim to draw representative subsamples from the
full dataset based on specific sampling probabilities, with the goal of
maintaining inference efficiency. The sampling probabilities are tailored to
particular objectives, such as minimizing the variance of the estimated
coefficients or reducing prediction error. By using subsampling techniques,
the package balances the trade-off between computational efficiency and statistical
efficiency, making it a practical tool for massive data
analysis.
</p>


<h3>Models Supported</h3>


<ul>
<li><p> Generalized Linear Models (GLMs)
</p>
</li>
<li><p> Softmax (Multinomial) Regression
</p>
</li>
<li><p> Rare Event Logistic Regression
</p>
</li>
<li><p> Quantile Regression
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Qingkai Dong <a href="mailto:qingkai.dong@uconn.edu">qingkai.dong@uconn.edu</a> [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Yaqiong Yao
</p>
</li>
<li><p> Haiying Wang
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Qiang Zhang [contributor]
</p>
</li>
<li><p> Jun Yan [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/dqksnow/Subsampling">https://github.com/dqksnow/Subsampling</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/dqksnow/Subsampling/issues">https://github.com/dqksnow/Subsampling/issues</a>
</p>
</li></ul>


<hr>
<h2 id='ssp.glm'>Optimal Subsampling Methods for Generalized Linear Models</h2><span id='topic+ssp.glm'></span>

<h3>Description</h3>

<p>Draw subsample from full dataset and fit a generalized linear model (GLM) on the subsample. For a quick start, refer to the <a href="https://dqksnow.github.io/subsampling/articles/ssp-logit.html">vignette</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssp.glm(
  formula,
  data,
  subset = NULL,
  n.plt,
  n.ssp,
  family = "binomial",
  criterion = "optL",
  sampling.method = "poisson",
  likelihood = "weighted",
  control = list(...),
  contrasts = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ssp.glm_+3A_formula">formula</code></td>
<td>
<p>A model formula object of class &quot;formula&quot; that describes the model to be fitted.</p>
</td></tr>
<tr><td><code id="ssp.glm_+3A_data">data</code></td>
<td>
<p>A data frame containing the variables in the model. Denote <code class="reqn">N</code> as the number of observations in <code>data</code>.</p>
</td></tr>
<tr><td><code id="ssp.glm_+3A_subset">subset</code></td>
<td>
<p>An optional vector specifying a subset of observations from <code>data</code> to use for the analysis. This subset will be viewed as the full data.</p>
</td></tr>
<tr><td><code id="ssp.glm_+3A_n.plt">n.plt</code></td>
<td>
<p>The pilot subsample size (first-step subsample size).
This subsample is used to compute the pilot estimator and estimate the optimal subsampling probabilities.</p>
</td></tr>
<tr><td><code id="ssp.glm_+3A_n.ssp">n.ssp</code></td>
<td>
<p>The expected size of the optimal subsample (second-step subsample). For <code>sampling.method = 'withReplacement'</code>, The exact subsample size is <code>n.ssp</code>. For <code>sampling.method = 'poisson'</code>, <code>n.ssp</code> is the expected subsample size.</p>
</td></tr>
<tr><td><code id="ssp.glm_+3A_family">family</code></td>
<td>
<p><code>family</code> can be a character string naming a family function, a family function or the result of a call to a family function.</p>
</td></tr>
<tr><td><code id="ssp.glm_+3A_criterion">criterion</code></td>
<td>
<p>The choices include <code>optA</code>, <code>optL</code>(default), <code>LCC</code> and <code>uniform.</code>
</p>

<ul>
<li> <p><code>optA</code> Minimizes the trace of the asymptotic covariance matrix of the subsample estimator.
</p>
</li>
<li> <p><code>optL</code> Minimizes the trace of a transformation of the asymptotic covariance matrix. The computational complexity of
optA is <code class="reqn">O(N d^2)</code> while that of optL is <code class="reqn">O(N d)</code>.
</p>
</li>
<li> <p><code>LCC</code> Local Case-Control sampling probability, used as a baseline subsampling strategy.
</p>
</li>
<li> <p><code>uniform</code> Assigns equal subsampling probability
<code class="reqn">\frac{1}{N}</code> to each observation, serving as a baseline subsampling strategy.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ssp.glm_+3A_sampling.method">sampling.method</code></td>
<td>
<p>The sampling method to use. Options include <code>withReplacement</code>
and <code>poisson</code> (default). <code>withReplacement</code> draws exactly <code>n.ssp</code>
subsamples from size <code class="reqn">N</code> full dataset with replacement, using the specified
subsampling probabilities. <code>poisson</code> draws observations independently by
comparing each subsampling probability with a realization of uniform random
variable  <code class="reqn">U(0,1)</code>.
</p>
<p>Differences between methods:
</p>

<ul>
<li><p> Sample size: <code>withReplacement</code> draws exactly  <code>n.ssp</code> subsamples while <code>poisson</code> draws
subsamples with expected size <code>n.ssp</code>, meaning the actual size may vary.
</p>
</li>
<li><p> Memory usage: <code>withReplacement</code> requires the entire dataset to be loaded at once, while <code>poisson</code>
allows for processing observations sequentially (will be implemented in future version).
</p>
</li>
<li><p> Estimator performance: Theoretical results show that the <code>poisson</code> tends to get a
subsample estimator with lower asymptotic variance compared to the
<code>withReplacement</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="ssp.glm_+3A_likelihood">likelihood</code></td>
<td>
<p>The likelihood function to use. Options include <code>weighted</code> (default) and
<code>logOddsCorrection</code>. A bias-correction likelihood function is required for subsample since unequal subsampling probabilities introduce bias.
</p>

<ul>
<li> <p><code>weighted</code> Applies a weighted likelihood function where each observation is weighted by the inverse of its subsampling probability.
</p>
</li>
<li> <p><code>logOddsCorrection</code> This lieklihood is available only for logistic regression model (i.e., when family is binomial or quasibinomial). It uses a conditional likelihood, where each element of the likelihood represents the probability of <code class="reqn">Y=1</code>, given that this subsample was drawn.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ssp.glm_+3A_control">control</code></td>
<td>
<p>The argument <code>control</code> contains two tuning parameters <code>alpha</code> and <code>b</code>.
</p>

<ul>
<li> <p><code>alpha</code> <code class="reqn">\in [0,1]</code> is the mixture weight of the user-assigned subsampling
probability and uniform subsampling probability. The actual subsample
probability is <code class="reqn">\pi = (1-\alpha)\pi^{opt} + \alpha \pi^{uni}</code>. This protects the estimator from extreme small
subsampling probability. The default value is 0.
</p>
</li>
<li> <p><code>b</code> is a positive number which is used to constaint the poisson subsampling probability. <code>b</code> close to 0 results in subsampling probabilities closer to uniform probability <code class="reqn">\frac{1}{N}</code>. <code>b=2</code> is the default value. See relevant references for further details.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ssp.glm_+3A_contrasts">contrasts</code></td>
<td>
<p>An optional list. It specifies how categorical variables are represented in the design matrix. For example, <code>contrasts = list(v1 = 'contr.treatment', v2 = 'contr.sum')</code>.</p>
</td></tr>
<tr><td><code id="ssp.glm_+3A_...">...</code></td>
<td>
<p>A list of parameters which will be passed to <code>svyglm()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A pilot estimator for the unknown parameter  <code class="reqn">\beta</code> is required because both optA and
optL subsampling probabilities depend on <code class="reqn">\beta</code>. There is no &quot;free lunch&quot; when determining optimal subsampling probabilities. Fortunately the
pilot estimator only needs to satisfy mild conditions. For logistic regression, this
is achieved by drawing a size <code>n.plt</code> subsample with replacement from full
dataset. The case-control subsample probability is applied, that is, <code class="reqn">\pi_i =
  \frac{1}{2N_1}</code> for  <code class="reqn">Y_i=1</code> and  <code class="reqn">\pi_i = \frac{1}{2N_0}</code> for  <code class="reqn">Y_i=0</code>,
<code class="reqn">i=1,...,N</code>, where<code class="reqn">N_0</code> and <code class="reqn">N_1</code> are the counts of observations with <code class="reqn">Y = 0</code> and <code class="reqn">Y = 1</code>, respectively. For other
families, uniform subsampling probabilities are applied. Typically, <code>n.plt</code> is
relatively small compared to <code>n.ssp</code>.
</p>
<p>When <code>criterion = 'uniform'</code>, there is no need to compute the pilot estimator. In this case, a size <code>n.plt + n.ssp</code> subsample will be drawn with uniform sampling probability and <code>coef</code> is the corresponding  estimator.
</p>
<p>As suggested by <code>survey::svyglm()</code>, for binomial and poisson families, use <code>family=quasibinomial()</code> and <code>family=quasipoisson()</code> to avoid a warning &quot;In eval(family$initialize) : non-integer #successes in a binomial glm!&quot;. The quasi versions of the family objects give the same point estimates and suppress the warning. Since subsampling methods only rely on point estimates from svyglm() for further computation, using the quasi families does not introduce any issues.
</p>
<p>For Gamma family, <code>ssp.glm</code> returns only the estimation of coefficients, as the dispersion parameter is not estimated.
</p>


<h3>Value</h3>

<p><code>ssp.glm</code> returns an object of class &quot;ssp.glm&quot; containing the following components (some are optional):
</p>

<dl>
<dt>model.call</dt><dd><p>The original function call.</p>
</dd>
<dt>coef.plt</dt><dd><p>The pilot estimator. See Details for more information.</p>
</dd>
<dt>coef.ssp</dt><dd><p>The estimator obtained from the optimal subsample.</p>
</dd>
<dt>coef</dt><dd><p>The weighted linear combination of <code>coef.plt</code> and <code>coef.ssp</code>. The combination weights depend on the relative size of <code>n.plt</code> and <code>n.ssp</code> and the estimated covariance matrices of <code>coef.plt</code> and <code>coef.ssp.</code> We blend the pilot subsample information into optimal subsample estimator since the pilot subsample has already been drawn. The coefficients and standard errors reported by summary are <code>coef</code> and the square root of <code>diag(cov)</code>.</p>
</dd>
<dt>cov.ssp</dt><dd><p>The covariance matrix of <code>coef.ssp</code>.</p>
</dd>
<dt>cov</dt><dd><p>The covariance matrix of <code>coef</code>.</p>
</dd>
<dt>index.plt</dt><dd><p>Row indices of pilot subsample in the full dataset.</p>
</dd>
<dt>index.ssp</dt><dd><p>Row indices of of optimal subsample in the full dataset.</p>
</dd>
<dt>N</dt><dd><p>The number of observations in the full dataset.</p>
</dd>
<dt>subsample.size.expect</dt><dd><p>The expected subsample size, equals to <code>n.ssp</code> for <code>ssp.glm.</code> Note that for other functions, such as <a href="#topic+ssp.relogit">ssp.relogit</a>, this value may differ.</p>
</dd>
<dt>terms</dt><dd><p>The terms object for the fitted model.</p>
</dd>
</dl>



<h3>References</h3>

<p>Wang, H. (2019). More efficient estimation for logistic regression with optimal subsamples. <em>Journal of machine learning research</em>, <strong>20</strong>(132), 1-59.
</p>
<p>Ai, M., Yu, J., Zhang, H., &amp; Wang, H. (2021). Optimal subsampling algorithms for big data regressions. <em>Statistica Sinica</em>, <strong>31</strong>(2), 749-772.
</p>
<p>Wang, H., &amp; Kim, J. K. (2022). Maximum sampled conditional likelihood for informative subsampling. <em>Journal of machine learning research</em>, <strong>23</strong>(332), 1-50.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># logistic regression
set.seed(2)
N &lt;- 1e4
beta0 &lt;- rep(-0.5, 7)
d &lt;- length(beta0) - 1
corr &lt;- 0.5
sigmax  &lt;- matrix(corr, d, d) + diag(1-corr, d)
X &lt;- MASS::mvrnorm(N, rep(0, d), sigmax)
Y &lt;- rbinom(N, 1, 1 - 1 / (1 + exp(beta0[1] + X %*% beta0[-1])))
data &lt;- as.data.frame(cbind(Y, X))
formula &lt;- Y ~ .
n.plt &lt;- 500
n.ssp &lt;- 1000
subsampling.results &lt;- ssp.glm(formula = formula, 
data = data, 
n.plt = n.plt,
n.ssp = n.ssp,
family = 'quasibinomial',
criterion = "optL",
sampling.method = 'poisson',
likelihood = "logOddsCorrection")
summary(subsampling.results)
subsampling.results &lt;- ssp.glm(formula = formula, 
data = data, 
n.plt = n.plt,
n.ssp = n.ssp,
family = 'quasibinomial', 
criterion = "optL",
sampling.method = 'withReplacement', 
likelihood = "weighted")
summary(subsampling.results)
Uni.subsampling.results &lt;- ssp.glm(formula = formula, 
data = data, 
n.plt = n.plt,
n.ssp = n.ssp,
family = 'quasibinomial', 
criterion = 'uniform')
summary(Uni.subsampling.results)
####################
# poisson regression
set.seed(1)
N &lt;-  1e4
beta0 &lt;- rep(0.5, 7)
d &lt;- length(beta0) - 1
X &lt;- matrix(runif(N * d), N, d)
epsilon &lt;- runif(N)
lambda &lt;- exp(beta0[1] + X %*% beta0[-1])
Y &lt;- rpois(N, lambda)
data &lt;- as.data.frame(cbind(Y, X))
formula &lt;- Y ~ .
n.plt &lt;- 200
n.ssp &lt;- 600
subsampling.results &lt;- ssp.glm(formula = formula, 
data = data, 
n.plt = n.plt,
n.ssp = n.ssp,
family = 'poisson',
criterion = "optL", 
sampling.method = 'poisson',
likelihood = "weighted")
summary(subsampling.results)
subsampling.results &lt;- ssp.glm(formula = formula, 
data = data, 
n.plt = n.plt,
n.ssp = n.ssp,
family = 'poisson', 
criterion = "optL", 
sampling.method = 'withReplacement',
likelihood = "weighted")
summary(subsampling.results)
Uni.subsampling.results &lt;- ssp.glm(formula = formula, 
data = data, 
n.plt = n.plt,
n.ssp = n.ssp,
family = 'poisson', 
criterion = 'uniform')
summary(Uni.subsampling.results)
##################
# gamma regression
set.seed(1)
N &lt;- 1e4
p &lt;- 3
beta0 &lt;- rep(0.5, p + 1)
d &lt;- length(beta0) - 1
shape &lt;- 2
X &lt;- matrix(runif(N * d), N, d)
link_function &lt;- function(X, beta0) 1 / (beta0[1] + X %*% beta0[-1])
scale &lt;- link_function(X, beta0) / shape
Y &lt;- rgamma(N, shape = shape, scale = scale)
data &lt;- as.data.frame(cbind(Y, X))
formula &lt;- Y ~ .
n.plt &lt;- 200
n.ssp &lt;- 1000
subsampling.results &lt;- ssp.glm(formula = formula, 
data = data, 
n.plt = n.plt,
n.ssp = n.ssp,
family = 'Gamma',
criterion = "optL", 
sampling.method = 'poisson',
likelihood = "weighted")
summary(subsampling.results)
</code></pre>

<hr>
<h2 id='ssp.quantreg'>Optimal Subsampling Methods for Quantile Regression Model</h2><span id='topic+ssp.quantreg'></span>

<h3>Description</h3>

<p>Draw subsample from full dataset and fit quantile regression model. For a quick start, refer to the <a href="https://dqksnow.github.io/subsampling/articles/ssp-quantreg.html">vignette</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssp.quantreg(
  formula,
  data,
  subset = NULL,
  tau = 0.5,
  n.plt,
  n.ssp,
  B = 5,
  boot = TRUE,
  criterion = "optL",
  sampling.method = "withReplacement",
  likelihood = c("weighted"),
  control = list(...),
  contrasts = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ssp.quantreg_+3A_formula">formula</code></td>
<td>
<p>A model formula object of class &quot;formula&quot; that describes the model to be fitted.</p>
</td></tr>
<tr><td><code id="ssp.quantreg_+3A_data">data</code></td>
<td>
<p>A data frame containing the variables in the model. Denote <code class="reqn">N</code> as the number of observations in <code>data</code>.</p>
</td></tr>
<tr><td><code id="ssp.quantreg_+3A_subset">subset</code></td>
<td>
<p>An optional vector specifying a subset of observations from <code>data</code> to use for the analysis. This subset will be viewed as the full data.</p>
</td></tr>
<tr><td><code id="ssp.quantreg_+3A_tau">tau</code></td>
<td>
<p>The interested quantile.</p>
</td></tr>
<tr><td><code id="ssp.quantreg_+3A_n.plt">n.plt</code></td>
<td>
<p>The pilot subsample size (first-step subsample size).
This subsample is used to compute the pilot estimator and estimate the optimal subsampling probabilities.</p>
</td></tr>
<tr><td><code id="ssp.quantreg_+3A_n.ssp">n.ssp</code></td>
<td>
<p>The expected size of the optimal subsample (second-step subsample). For <code>sampling.method = 'withReplacement'</code>, The exact subsample size is <code>n.ssp</code>. For <code>sampling.method = 'poisson'</code>, <code>n.ssp</code> is the expected subsample size.</p>
</td></tr>
<tr><td><code id="ssp.quantreg_+3A_b">B</code></td>
<td>
<p>The number of subsamples for the iterative sampling algorithm. Each subsample contains <code>n.ssp</code> observations. This allows us to estimate the covariance matrix.</p>
</td></tr>
<tr><td><code id="ssp.quantreg_+3A_boot">boot</code></td>
<td>
<p>If TRUE then perform iterative sampling algorithm and estimate the covariance matrix. If FALSE then only one subsample with size <code>B*n.ssp</code> is returned.</p>
</td></tr>
<tr><td><code id="ssp.quantreg_+3A_criterion">criterion</code></td>
<td>
<p>It determines how subsampling probabilities are computed.
Choices include <code>optL</code>(default) and <code>uniform</code>.
</p>

<ul>
<li> <p><code>optL</code> Minimizes the trace of a transformation of the asymptotic covariance matrix of the subsample estimator.
</p>
</li>
<li> <p><code>uniform</code> Assigns equal subsampling probability
<code class="reqn">\frac{1}{N}</code> to each observation, serving as a baseline subsampling strategy.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ssp.quantreg_+3A_sampling.method">sampling.method</code></td>
<td>
<p>The sampling method for drawing the optimal subsample.
Choices include <code>withReplacement</code> and <code>poisson</code>(default). <code>withReplacement</code> draws exactly <code>n.ssp</code>
subsamples from size <code class="reqn">N</code> full dataset with replacement, using the specified
subsampling probabilities. <code>poisson</code> draws observations independently by
comparing each subsampling probability with a realization of uniform random
variable  <code class="reqn">U(0,1)</code>.</p>
</td></tr>
<tr><td><code id="ssp.quantreg_+3A_likelihood">likelihood</code></td>
<td>
<p>The type of the maximum likelihood function used to
calculate the optimal subsampling estimator. Currently <code>weighted</code> is implemented which applies a weighted likelihood function where each observation is weighted by the inverse of its subsampling probability.</p>
</td></tr>
<tr><td><code id="ssp.quantreg_+3A_control">control</code></td>
<td>
<p>The argument <code>control</code> contains two tuning parameters <code>alpha</code> and <code>b</code>.
</p>

<ul>
<li> <p><code>alpha</code> <code class="reqn">\in [0,1]</code> is the mixture weight of the user-assigned subsampling
probability and uniform subsampling probability. The actual subsample
probability is <code class="reqn">\pi = (1-\alpha)\pi^{opt} + \alpha \pi^{uni}</code>. This protects the estimator from extreme small
subsampling probability. The default value is 0.
</p>
</li>
<li> <p><code>b</code> is a positive number which is used to constaint the poisson subsampling probability. <code>b</code> close to 0 results in subsampling probabilities closer to uniform probability <code class="reqn">\frac{1}{N}</code>. <code>b=2</code> is the default value.
See relevant references for further details.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ssp.quantreg_+3A_contrasts">contrasts</code></td>
<td>
<p>An optional list. It specifies how categorical variables are represented in the design matrix. For example, <code>contrasts = list(v1 = 'contr.treatment', v2 = 'contr.sum')</code>.</p>
</td></tr>
<tr><td><code id="ssp.quantreg_+3A_...">...</code></td>
<td>
<p>A list of parameters which will be passed to <code>quantreg::rq()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most of the arguments and returned variables have the same meaning with <a href="#topic+ssp.glm">ssp.glm</a>. Refer to <a href="https://dqksnow.github.io/subsampling/articles/ssp-logit.html">vignette</a>
</p>
<p>A pilot estimator for the unknown parameter <code class="reqn">\beta</code> is required because
optL subsampling probabilities depend on <code class="reqn">\beta</code>. There is no &quot;free lunch&quot; when determining optimal subsampling probabilities. For quantile regression, this
is achieved by drawing a size <code>n.plt</code> subsample with replacement from full
dataset, using uniform sampling probability.
</p>
<p>If <code>boot</code>=TRUE, the returned value <code>subsample.size.expect</code> equals to <code>B*n.ssp</code>, and the covariance matrix for <code>coef</code> would be calculated.
If <code>boot</code>=FALSE, the returned value <code>subsample.size.expect</code> equals to <code>B*n.ssp</code>, but the covariance matrix won't be estimated.
</p>


<h3>Value</h3>

<p><code>ssp.quantreg</code> returns an object of class &quot;ssp.quantreg&quot; containing the following components (some are optional):
</p>

<dl>
<dt>model.call</dt><dd><p>The original function call.</p>
</dd>
<dt>coef.plt</dt><dd><p>The pilot estimator. See Details for more information.</p>
</dd>
<dt>coef</dt><dd><p>The estimator obtained from the optimal subsample.</p>
</dd>
<dt>cov</dt><dd><p>The covariance matrix of <code>coef</code></p>
</dd>
<dt>index.plt</dt><dd><p>Row indices of pilot subsample in the full dataset.</p>
</dd>
<dt>index.ssp</dt><dd><p>Row indices of of optimal subsample in the full dataset.</p>
</dd>
<dt>N</dt><dd><p>The number of observations in the full dataset.</p>
</dd>
<dt>subsample.size.expect</dt><dd><p>The expected subsample size</p>
</dd>
<dt>terms</dt><dd><p>The terms object for the fitted model.</p>
</dd>
</dl>



<h3>References</h3>

<p>Wang, H., &amp; Ma, Y. (2021). Optimal subsampling for quantile regression in big data. <em>Biometrika</em>, <strong>108</strong>(1), 99-112.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#quantile regression
set.seed(1)
N &lt;- 1e4
B &lt;- 5
tau &lt;- 0.75
beta.true &lt;- rep(1, 7)
d &lt;- length(beta.true) - 1
corr  &lt;- 0.5
sigmax  &lt;- matrix(0, d, d)
for (i in 1:d) for (j in 1:d) sigmax[i, j] &lt;- corr^(abs(i-j))
X &lt;- MASS::mvrnorm(N, rep(0, d), sigmax)
err &lt;- rnorm(N, 0, 1) - qnorm(tau)
Y &lt;- beta.true[1] + X %*% beta.true[-1] + 
err * rowMeans(abs(X))
data &lt;- as.data.frame(cbind(Y, X))
colnames(data) &lt;- c("Y", paste("V", 1:ncol(X), sep=""))
formula &lt;- Y ~ .
n.plt &lt;- 200
n.ssp &lt;- 100
optL.results &lt;- ssp.quantreg(formula,data,tau = tau,n.plt = n.plt,
n.ssp = n.ssp,B = B,boot = TRUE,criterion = 'optL',
sampling.method = 'withReplacement',likelihood = 'weighted')
summary(optL.results)
uni.results &lt;- ssp.quantreg(formula,data,tau = tau,n.plt = n.plt,
n.ssp = n.ssp,B = B,boot = TRUE,criterion = 'uniform',
sampling.method = 'withReplacement', likelihood = 'weighted')
summary(uni.results)
</code></pre>

<hr>
<h2 id='ssp.relogit'>Optimal Subsampling for Logistic Regression Model with Rare Events Data</h2><span id='topic+ssp.relogit'></span>

<h3>Description</h3>

<p>Draw subsample from full dataset and fit logistic regression model on subsample. For a quick start, refer to the <a href="https://dqksnow.github.io/subsampling/articles/ssp-relogit.html">vignette</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssp.relogit(
  formula,
  data,
  subset = NULL,
  n.plt,
  n.ssp,
  criterion = "optL",
  likelihood = "logOddsCorrection",
  control = list(...),
  contrasts = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ssp.relogit_+3A_formula">formula</code></td>
<td>
<p>A model formula object of class &quot;formula&quot; that describes the model to be fitted.</p>
</td></tr>
<tr><td><code id="ssp.relogit_+3A_data">data</code></td>
<td>
<p>A data frame containing the variables in the model. Denote <code class="reqn">N</code> as the number of observations in <code>data</code>.</p>
</td></tr>
<tr><td><code id="ssp.relogit_+3A_subset">subset</code></td>
<td>
<p>An optional vector specifying a subset of observations from <code>data</code> to use for the analysis. This subset will be viewed as the full data.</p>
</td></tr>
<tr><td><code id="ssp.relogit_+3A_n.plt">n.plt</code></td>
<td>
<p>The pilot subsample size (first-step subsample size).
This subsample is used to compute the pilot estimator and estimate the optimal subsampling probabilities.</p>
</td></tr>
<tr><td><code id="ssp.relogit_+3A_n.ssp">n.ssp</code></td>
<td>
<p>The expected subsample size (the second-step subsample
size) drawn from those samples with <code>Y=0</code>. All rare events (<code>Y=1</code>) are included in the optimal subsample automatically.</p>
</td></tr>
<tr><td><code id="ssp.relogit_+3A_criterion">criterion</code></td>
<td>
<p>The choices include <code>optA</code>, <code>optL</code>(default), <code>LCC</code> and <code>uniform.</code>
</p>

<ul>
<li> <p><code>optA</code> Minimizes the trace of the asymptotic covariance matrix of the subsample estimator.
</p>
</li>
<li> <p><code>optL</code> Minimizes the trace of a transformation of the asymptotic covariance matrix. The computational complexity of
optA is <code class="reqn">O(N d^2)</code> while that of optL is <code class="reqn">O(N d)</code>.
</p>
</li>
<li> <p><code>LCC</code> Local Case-Control sampling probability, used as a baseline subsampling strategy.
</p>
</li>
<li> <p><code>uniform</code> Assigns equal subsampling probability
<code class="reqn">\frac{1}{N}</code> to each observation, serving as a baseline subsampling strategy.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ssp.relogit_+3A_likelihood">likelihood</code></td>
<td>
<p>The likelihood function to use. Options include <code>weighted</code> and
<code>logOddsCorrection</code> (default). A bias-correction likelihood function is required for subsample since unequal subsampling probabilities introduce bias.
</p>

<ul>
<li> <p><code>weighted</code> Applies a weighted likelihood function where each observation is weighted by the inverse of its subsampling probability.
</p>
</li>
<li> <p><code>logOddsCorrection</code> This lieklihood is available only for logistic regression model (i.e., when family is binomial or quasibinomial). It uses a conditional likelihood, where each element of the likelihood represents the probability of <code class="reqn">Y=1</code>, given that this subsample was drawn.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ssp.relogit_+3A_control">control</code></td>
<td>
<p>The argument <code>control</code> contains two tuning parameters <code>alpha</code> and <code>b</code>.
</p>

<ul>
<li> <p><code>alpha</code> <code class="reqn">\in [0,1]</code> is the mixture weight of the user-assigned subsampling
probability and uniform subsampling probability. The actual subsample
probability is <code class="reqn">\pi = (1-\alpha)\pi^{opt} + \alpha \pi^{uni}</code>. This protects the estimator from extreme small
subsampling probability. The default value is 0.
</p>
</li>
<li> <p><code>b</code> is a positive number which is used to constaint the poisson subsampling probability. <code>b</code> close to 0 results in subsampling probabilities closer to uniform probability <code class="reqn">\frac{1}{N}</code>. <code>b=2</code> is the default value. See relevant references for further details.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ssp.relogit_+3A_contrasts">contrasts</code></td>
<td>
<p>An optional list. It specifies how categorical variables are represented in the design matrix. For example, <code>contrasts = list(v1 = 'contr.treatment', v2 = 'contr.sum')</code>.</p>
</td></tr>
<tr><td><code id="ssp.relogit_+3A_...">...</code></td>
<td>
<p>A list of parameters which will be passed to <code>svyglm()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'Rare event' stands for the number of observations where <code class="reqn">Y=1</code> is rare compare to the number of <code class="reqn">Y=0</code> in the full data. In the face of logistic regression with rare events, @wang2021nonuniform shows that the available information ties to the number of positive instances instead of the full data size. Based on this insight, one can keep all the rare instances and perform subsampling on the non-rare instances to reduce the computational cost. When <code>criterion = optA, optL or LCC</code>, all observations with <code class="reqn">Y=1</code> are preserved and it draw <code>n.ssp</code> subsmples from observations with Y=0. When <code>criterion = uniform</code>, it draws (n.plt+n.ssp) subsmples from the full sample with equal sampling probability.
</p>
<p>A pilot estimator for the unknown parameter  <code class="reqn">\beta</code> is required because both optA and
optL subsampling probabilities depend on <code class="reqn">\beta</code>. This
is achieved by drawing half size subsample from rare observations and half from non-rare observations.
</p>
<p>Most of the arguments and returned variables have similar meaning with <a href="#topic+ssp.glm">ssp.glm</a>. Refer to <a href="https://dqksnow.github.io/subsampling/articles/ssp-logit.html">vignette</a>
</p>


<h3>Value</h3>

<p><code>ssp.relogit</code> returns an object of class &quot;ssp.relogit&quot; containing the following components (some are optional):
</p>

<dl>
<dt>model.call</dt><dd><p>The original function call.</p>
</dd>
<dt>coef.plt</dt><dd><p>The pilot estimator. See Details for more information.</p>
</dd>
<dt>coef.ssp</dt><dd><p>The estimator obtained from the optimal subsample.</p>
</dd>
<dt>coef</dt><dd><p>The weighted linear combination of <code>coef.plt</code> and <code>coef.ssp.</code> The combination weights depend on the relative size of <code>n.plt</code> and <code>n.ssp</code> and the estimated covariance matrices of <code>coef.plt</code> and <code>coef.ssp.</code> We blend the pilot subsample information into optimal subsample estimator since the pilot subsample has already been drawn. The coefficients and standard errors reported by summary are <code>coef</code> and the square root of <code>diag(cov)</code>.</p>
</dd>
<dt>cov.ssp</dt><dd><p>The covariance matrix of <code>coef.ssp</code>.</p>
</dd>
<dt>cov</dt><dd><p>The covariance matrix of <code>beta.cmb</code>.</p>
</dd>
<dt>index.plt</dt><dd><p>Row indices of pilot subsample in the full dataset.</p>
</dd>
<dt>index.ssp</dt><dd><p>Row indices of of optimal subsample in the full dataset.</p>
</dd>
<dt>N</dt><dd><p>The number of observations in the full dataset.</p>
</dd>
<dt>subsample.size.expect</dt><dd><p>The expected subsample size.</p>
</dd>
<dt>terms</dt><dd><p>The terms object for the fitted model.</p>
</dd>
</dl>



<h3>References</h3>

<p>Wang, H., Zhang, A., &amp; Wang, C. (2021). Nonuniform negative sampling and log odds correction with rare events data. <em>Advances in Neural Information Processing Systems</em>, <strong>34</strong>, 19847-19859.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
N &lt;- 2 * 1e4
beta0 &lt;- c(-5, -rep(0.7, 6))
d &lt;- length(beta0) - 1
X &lt;- matrix(0, N, d)
corr &lt;- 0.5
sigmax &lt;- corr ^ abs(outer(1:d, 1:d, "-"))
sigmax &lt;- sigmax / 4
X &lt;- MASS::mvrnorm(n = N, mu = rep(0, d), Sigma = sigmax)
Y &lt;- rbinom(N, 1, 1 - 1 / (1 + exp(beta0[1] + X %*% beta0[-1])))
print(paste('N: ', N))
print(paste('sum(Y): ', sum(Y)))
n.plt &lt;- 200
n.ssp &lt;- 1000
data &lt;- as.data.frame(cbind(Y, X))
colnames(data) &lt;- c("Y", paste("V", 1:ncol(X), sep=""))
formula &lt;- Y ~ .
subsampling.results &lt;- ssp.relogit(formula = formula,
                                     data = data,
                                     n.plt = n.plt,
                                     n.ssp = n.ssp,
                                     criterion = 'optA',
                                     likelihood = 'logOddsCorrection')
summary(subsampling.results)
</code></pre>

<hr>
<h2 id='ssp.softmax'>Optimal Subsampling Method for Softmax (multinomial logistic) Regression Model</h2><span id='topic+ssp.softmax'></span>

<h3>Description</h3>

<p>Draw subsample from full dataset and fit softmax(multinomial logistic) regression model on the subsample. Refer to <a href="https://dqksnow.github.io/subsampling/articles/ssp-softmax.html">vignette</a> for a quick start.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssp.softmax(
  formula,
  data,
  subset,
  n.plt,
  n.ssp,
  criterion = "MSPE",
  sampling.method = "poisson",
  likelihood = "MSCLE",
  constraint = "summation",
  control = list(...),
  contrasts = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ssp.softmax_+3A_formula">formula</code></td>
<td>
<p>A model formula object of class &quot;formula&quot; that describes the model to be fitted.</p>
</td></tr>
<tr><td><code id="ssp.softmax_+3A_data">data</code></td>
<td>
<p>A data frame containing the variables in the model. Denote <code class="reqn">N</code> as the number of observations in <code>data</code>.</p>
</td></tr>
<tr><td><code id="ssp.softmax_+3A_subset">subset</code></td>
<td>
<p>An optional vector specifying a subset of observations from <code>data</code> to use for the analysis. This subset will be viewed as the full data.</p>
</td></tr>
<tr><td><code id="ssp.softmax_+3A_n.plt">n.plt</code></td>
<td>
<p>The pilot subsample size (first-step subsample size).
This subsample is used to compute the pilot estimator and estimate the optimal subsampling probabilities.</p>
</td></tr>
<tr><td><code id="ssp.softmax_+3A_n.ssp">n.ssp</code></td>
<td>
<p>The expected size of the optimal subsample (second-step subsample). For <code>sampling.method = 'withReplacement'</code>, The exact subsample size is <code>n.ssp</code>. For <code>sampling.method = 'poisson'</code>, <code>n.ssp</code> is the expected subsample size.</p>
</td></tr>
<tr><td><code id="ssp.softmax_+3A_criterion">criterion</code></td>
<td>
<p>The criterion of optimal subsampling probabilities.
Choices include <code>optA</code>, <code>optL</code>, <code>MSPE</code>(default), <code>LUC</code> and <code>uniform</code>.
</p>

<ul>
<li> <p><code>MSPE</code> Minimizes the mean squared prediction error between subsample estimator and full data estimator.
</p>
</li>
<li> <p><code>optA</code> Minimizes the trace of the asymptotic covariance matrix of the subsample estimator.
</p>
</li>
<li> <p><code>optL</code> Minimizes the trace of a transformation of the asymptotic covariance matrix, which reduces computational costs than <code>optA</code>.
</p>
</li>
<li> <p><code>LUC</code> Local uncertainty sampling method, serving as a baseline subsampling strategy. See Wang and Kim (2022).
</p>
</li>
<li> <p><code>uniform</code> Assigns equal subsampling probability
<code class="reqn">\frac{1}{N}</code> to each observation, serving as a baseline subsampling strategy.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ssp.softmax_+3A_sampling.method">sampling.method</code></td>
<td>
<p>The sampling method to use.
Choices include <code>withReplacement</code> and <code>poisson</code>(default). <code>withReplacement</code> draws exactly <code>n.ssp</code>
subsamples from size <code class="reqn">N</code> full dataset with replacement, using the specified
subsampling probabilities. <code>poisson</code> draws observations independently by
comparing each subsampling probability with a realization of uniform random
variable  <code class="reqn">U(0,1)</code>.
Differences between methods:
</p>

<ul>
<li><p> Sample size: <code>withReplacement</code> draws exactly  <code>n.ssp</code> subsamples while <code>poisson</code> draws
subsamples with expected size <code>n.ssp</code>, meaning the actual size may vary.
</p>
</li>
<li><p> Memory usage: <code>withReplacement</code> requires the entire dataset to be loaded at once, while <code>poisson</code>
allows for processing observations sequentially (will be implemented in future version).
</p>
</li>
<li><p> Estimator performance: Theoretical results show that the <code>poisson</code> tends to get a
subsample estimator with lower asymptotic variance compared to the
<code>withReplacement</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="ssp.softmax_+3A_likelihood">likelihood</code></td>
<td>
<p>A bias-correction likelihood function is required for subsample since unequal subsampling probabilities introduce bias. Choices include
<code>weighted</code> and <code>MSCLE</code>(default).
</p>

<ul>
<li> <p><code>weighted</code> Applies a weighted likelihood function where each observation is weighted by the inverse of its subsampling probability.
</p>
</li>
<li> <p><code>MSCLE</code> It uses a conditional likelihood, where each element of the likelihood represents the density of <code class="reqn">Y_i</code> given that this observation was drawn.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ssp.softmax_+3A_constraint">constraint</code></td>
<td>
<p>The constraint for identifiability of softmax model. Choices include
<code>baseline</code> and <code>summation</code>(default). The baseline constraint assumes the coefficient for the baseline category are <code class="reqn">0</code>. Without loss of generality, we set the category <code class="reqn">Y=0</code> as the baseline category so that <code class="reqn">\boldsymbol{\beta}_0=0</code>. The summation constraint <code class="reqn">\sum_{k=0}^{K} \boldsymbol{\beta}_k</code> is also used in the subsampling method for the purpose of calculating subsampling probability. These two constraints lead to different interpretation of coefficients but are equal for computing <code class="reqn">P(Y_{i,k} = 1 \mid \mathbf{x}_i)</code>. The estimation of coefficients returned by <code>ssp.softmax()</code> is under baseline constraint.</p>
</td></tr>
<tr><td><code id="ssp.softmax_+3A_control">control</code></td>
<td>
<p>A list of parameters for controlling the sampling process. There are two tuning parameters <code>alpha</code> and <code>b</code>. Default is <code>list(alpha=0, b=2)</code>.
</p>

<ul>
<li> <p><code>alpha</code> <code class="reqn">\in [0,1]</code> is the mixture weight of the user-assigned subsampling
probability and uniform subsampling probability. The actual subsample
probability is <code class="reqn">\pi = (1-\alpha)\pi^{opt} + \alpha \pi^{uni}</code>. This protects the estimator from extreme small
subsampling probability. The default value is 0.
</p>
</li>
<li> <p><code>b</code> is a positive number which is used to constaint the poisson subsampling probability. <code>b</code> close to 0 results in subsampling probabilities closer to uniform probability <code class="reqn">\frac{1}{N}</code>. <code>b=2</code> is the default value. See relevant references for further details.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ssp.softmax_+3A_contrasts">contrasts</code></td>
<td>
<p>An optional list. It specifies how categorical variables are represented in the design matrix. For example, <code>contrasts = list(v1 = 'contr.treatment', v2 = 'contr.sum')</code>.</p>
</td></tr>
<tr><td><code id="ssp.softmax_+3A_...">...</code></td>
<td>
<p>A list of parameters which will be passed to <code>nnet::multinom()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A pilot estimator for the unknown parameter  <code class="reqn">\beta</code> is required because MSPE, optA and
optL subsampling probabilities depend on <code class="reqn">\beta</code>. There is no &quot;free lunch&quot; when determining optimal subsampling probabilities. For softmax regression, this
is achieved by drawing a size <code>n.plt</code> subsample with replacement from full
dataset with uniform sampling probability.
</p>


<h3>Value</h3>

<p>ssp.softmax returns an object of class &quot;ssp.softmax&quot; containing the following components (some are optional):
</p>

<dl>
<dt>model.call</dt><dd><p>The original function call.</p>
</dd>
<dt>coef.plt</dt><dd><p>The pilot estimator. See Details for more information.</p>
</dd>
<dt>coef.ssp</dt><dd><p>The estimator obtained from the optimal subsample.</p>
</dd>
<dt>coef</dt><dd><p>The weighted linear combination of <code>coef.plt</code> and <code>coef.ssp</code>, under baseline constraint. The combination weights depend on the relative size of <code>n.plt</code> and <code>n.ssp</code> and the estimated covariance matrices of <code>coef.plt</code> and <code>coef.ssp.</code> We blend the pilot subsample information into optimal subsample estimator since the pilot subsample has already been drawn. The coefficients and standard errors reported by summary are <code>coef</code> and the square root of <code>diag(cov)</code>.</p>
</dd>
<dt>coef.plt.sum</dt><dd><p>The pilot estimator under summation constrraint. <code>coef.plt.sum = G %*% as.vector(coef.plt)</code>.</p>
</dd>
<dt>coef.ssp.sum</dt><dd><p>The estimator obtained from the optimal subsample under summation constrraint. <code>coef.ssp.sum = G %*% as.vector(coef.ssp)</code>.</p>
</dd>
<dt>coef.sum</dt><dd><p>The weighted linear combination of <code>coef.plt</code> and <code>coef.ssp</code>, under summation constrraint. <code>coef.sum = G %*% as.vector(coef)</code>.</p>
</dd>
<dt>cov.plt</dt><dd><p>The covariance matrix of <code>coef.plt</code>.</p>
</dd>
<dt>cov.ssp</dt><dd><p>The covariance matrix of <code>coef.ssp</code>.</p>
</dd>
<dt>cov</dt><dd><p>The covariance matrix of <code>coef.cmb</code>.</p>
</dd>
<dt>cov.plt.sum</dt><dd><p>The covariance matrix of <code>coef.plt.sum</code>.</p>
</dd>
<dt>cov.ssp.sum</dt><dd><p>The covariance matrix of <code>coef.ssp.sum</code>.</p>
</dd>
<dt>cov.sum</dt><dd><p>The covariance matrix of <code>coef.sum</code>.</p>
</dd>
<dt>index.plt</dt><dd><p>Row indices of pilot subsample in the full dataset.</p>
</dd>
<dt>index.ssp</dt><dd><p>Row indices of of optimal subsample in the full dataset.</p>
</dd>
<dt>N</dt><dd><p>The number of observations in the full dataset.</p>
</dd>
<dt>subsample.size.expect</dt><dd><p>The expected subsample size.</p>
</dd>
<dt>terms</dt><dd><p>The terms object for the fitted model.</p>
</dd>
</dl>



<h3>References</h3>

<p>Yao, Y., &amp; Wang, H. (2019). Optimal subsampling for softmax regression. <em>Statistical Papers</em>, <strong>60</strong>, 585-599.
</p>
<p>Han, L., Tan, K. M., Yang, T., &amp; Zhang, T. (2020). Local uncertainty sampling for large-scale multiclass logistic regression. <em>Annals of Statistics</em>, <strong>48</strong>(3), 1770-1788.
</p>
<p>Wang, H., &amp; Kim, J. K. (2022). Maximum sampled conditional likelihood for informative subsampling. <em>Journal of machine learning research</em>, <strong>23</strong>(332), 1-50.
</p>
<p>Yao, Y., Zou, J., &amp; Wang, H. (2023). Optimal poisson subsampling for softmax regression. <em>Journal of Systems Science and Complexity</em>, <strong>36</strong>(4), 1609-1625.
</p>
<p>Yao, Y., Zou, J., &amp; Wang, H. (2023). Model constraints independent optimal subsampling probabilities for softmax regression. <em>Journal of Statistical Planning and Inference</em>, <strong>225</strong>, 188-201.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># softmax regression
d &lt;- 3 # dim of covariates
K &lt;- 2 # K + 1 classes
G &lt;- rbind(rep(-1/(K+1), K), diag(K) - 1/(K+1)) %x% diag(d)
N &lt;- 1e4
beta.true.baseline &lt;- cbind(rep(0, d), matrix(-1.5, d, K))
beta.true.summation &lt;- cbind(rep(1, d), 0.5 * matrix(-1, d, K))
set.seed(1)
mu &lt;- rep(0, d)
sigma &lt;- matrix(0.5, nrow = d, ncol = d)
diag(sigma) &lt;- rep(1, d)
X &lt;- MASS::mvrnorm(N, mu, sigma)
prob &lt;- exp(X %*% beta.true.summation)
prob &lt;- prob / rowSums(prob)
Y &lt;- apply(prob, 1, function(row) sample(0:K, size = 1, prob = row))
n.plt &lt;- 500
n.ssp &lt;- 1000
data &lt;- as.data.frame(cbind(Y, X))
colnames(data) &lt;- c("Y", paste("V", 1:ncol(X), sep=""))
head(data)
formula &lt;- Y ~ . -1
WithRep.MSPE &lt;- ssp.softmax(formula = formula,
 data = data, 
 n.plt = n.plt,
 n.ssp = n.ssp,
 criterion = 'MSPE', 
 sampling.method = 'withReplacement',
 likelihood = 'weighted',
 constraint = 'baseline')
summary(WithRep.MSPE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
