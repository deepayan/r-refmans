<!DOCTYPE html><html><head><title>Help for package ltertools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ltertools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#begin_key'><p>Generate the Skeleton of a Column Key</p></a></li>
<li><a href='#convert_temp'><p>Convert Temperature Values</p></a></li>
<li><a href='#cv'><p>Calculate Coefficient of Variation</p></a></li>
<li><a href='#harmonize'><p>Harmonize Data via a Column Key</p></a></li>
<li><a href='#lter_sites'><p>Long Term Ecological Research Site Information</p></a></li>
<li><a href='#ltertools-package'><p>ltertools: Tools Developed by the Long Term Ecological Research Community</p></a></li>
<li><a href='#read'><p>Read Data from Folder</p></a></li>
<li><a href='#site_subset'><p>Subsets the LTER Site Information Table by Site Codes and Habitats</p></a></li>
<li><a href='#site_timeline'><p>Create a Timeline of Site(s) that Meet Criteria</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools Developed by the Long Term Ecological Research Community</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nicholas Lyon &lt;lyon@nceas.ucsb.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Set of the data science tools created by various members of the Long Term 
    Ecological Research (LTER) community. These functions were initially written largely 
    as standalone operations and have later been aggregated into this package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-3-Clause">BSD_3_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://lter.github.io/ltertools/">https://lter.github.io/ltertools/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/lter/ltertools/issues">https://github.com/lter/ltertools/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, generics, ggplot2, magrittr, purrr, readxl, rlang,
stats, stringr, tidyr, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-22 14:42:42 UTC; lyon</td>
</tr>
<tr>
<td>Author:</td>
<td>Nicholas Lyon <a href="https://orcid.org/0000-0003-3905-1078"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre] (https://njlyon0.github.io/),
  Angel Chen <a href="https://orcid.org/0000-0003-3515-6710"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]
    (angelchen7.github.io),
  National Science Foundation [fnd] (NSF 1929393, 09/01/2019 -
    08/31/2024),
  University of California, Santa Barbara [cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-23 19:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='begin_key'>Generate the Skeleton of a Column Key</h2><span id='topic+begin_key'></span>

<h3>Description</h3>

<p>Creates the start of a 'column key' for harmonizing data. A column key includes a column for the file names to be harmonized into a single data object as well as a column for the column names in those files. Finally, it includes a column indicating the tidied name that corresponds with each raw column name. Harmonization can accept this key object and use it to rename all raw column names&ndash;in a reproducible way&ndash;to standardize across datasets. Currently supports raw files of the following formats: CSV, TXT, XLS, and XLSX
</p>


<h3>Usage</h3>

<pre><code class='language-R'>begin_key(
  raw_folder = NULL,
  data_format = c("csv", "txt", "xls", "xlsx"),
  guess_tidy = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="begin_key_+3A_raw_folder">raw_folder</code></td>
<td>
<p>(character) folder / folder path containing data files to include in key</p>
</td></tr>
<tr><td><code id="begin_key_+3A_data_format">data_format</code></td>
<td>
<p>(character) file extensions to identify within the <code>raw_folder</code>. Default behavior is to search for all supported file types.</p>
</td></tr>
<tr><td><code id="begin_key_+3A_guess_tidy">guess_tidy</code></td>
<td>
<p>(logical) whether to attempt to &quot;guess&quot; what the tidy name equivalent should be for each raw column name. This is accomplished via coercion to lowercase and removal of special character/repeated characters. If <code>FALSE</code> (the default) the &quot;tidy_name&quot; column is returned empty</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(dataframe) skeleton of column key
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate two simple tables
## Dataframe 1
df1 &lt;- data.frame("xx" = c(1:3),
                  "unwanted" = c("not", "needed", "column"),
                  "yy" = letters[1:3])
## Dataframe 2
df2 &lt;- data.frame("LETTERS" = letters[4:7],
                  "NUMBERS" = c(4:7),
                  "BONUS" = c("plantae", "animalia", "fungi", "protista"))

# Generate a local folder for exporting
temp_folder &lt;- tempdir()

# Export both files to that folder
utils::write.csv(x = df1, file = file.path(temp_folder, "df1.csv"), row.names = FALSE)
utils::write.csv(x = df2, file = file.path(temp_folder, "df2.csv"), row.names = FALSE)

# Generate a column key with "guesses" at tidy column names
ltertools::begin_key(raw_folder = temp_folder, data_format = "csv", guess_tidy = TRUE)

</code></pre>

<hr>
<h2 id='convert_temp'>Convert Temperature Values</h2><span id='topic+convert_temp'></span>

<h3>Description</h3>

<p>Converts a given set of temperature values from one unit to another
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_temp(value = NULL, from = NULL, to = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_temp_+3A_value">value</code></td>
<td>
<p>(numeric) temperature values to convert</p>
</td></tr>
<tr><td><code id="convert_temp_+3A_from">from</code></td>
<td>
<p>(character) starting units of the value, not case sensitive.</p>
</td></tr>
<tr><td><code id="convert_temp_+3A_to">to</code></td>
<td>
<p>(character) units to which to convert, not case sensitive.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(numeric) converted temperature values
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Convert from Fahrenheit to Celsius
convert_temp(value = 32, from = "Fahrenheit", to = "c")

</code></pre>

<hr>
<h2 id='cv'>Calculate Coefficient of Variation</h2><span id='topic+cv'></span>

<h3>Description</h3>

<p>Computes the coefficient of variation (CV), by dividing the standard deviation (SD) by the arithmetic mean of a set of numbers. If <code>na_rm</code> is <code>TRUE</code> then missing values are removed before calculation is completed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv(x, na_rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv_+3A_x">x</code></td>
<td>
<p>(numeric) vector of numbers for which to calculate CV</p>
</td></tr>
<tr><td><code id="cv_+3A_na_rm">na_rm</code></td>
<td>
<p>(logical) whether to remove missing values from both average and SD calculation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(numeric) coefficient of variation
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Convert from Fahrenheit to Celsius
cv(x = c(4, 5, 6, 4, 5, 5), na_rm = TRUE)

</code></pre>

<hr>
<h2 id='harmonize'>Harmonize Data via a Column Key</h2><span id='topic+harmonize'></span>

<h3>Description</h3>

<p>A &quot;column key&quot; is meant to streamline harmonization of disparate datasets. This key must include three columns containing: (1) the name of each raw data file to be harmonized, (2) the name of all of the columns in each of those files, and (3) the &quot;tidy name&quot; that corresponds to each raw column name. This function accepts that key and the path to a folder containing all raw data files included in the key. Each dataset is then read in and the original column names are replaced with their respective &quot;tidy_name&quot; indicated in the key. Once this has been done to all files, a single dataframe is returned with only columns indicated in the column name. Currently the following file formats are supported for the raw data: CSV, TXT, XLS, and XLSX
</p>
<p>Note that raw column names without an associated tidy name in the key are removed. We recommend using the <code>begin_key</code> function in this package to generate the skeleton of the key to make achieving the required structure simpler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>harmonize(
  key = NULL,
  raw_folder = NULL,
  data_format = c("csv", "txt", "xls", "xlsx"),
  quiet = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="harmonize_+3A_key">key</code></td>
<td>
<p>(dataframe) key object including a &quot;source&quot;, &quot;raw_name&quot; and &quot;tidy_name&quot; column. Additional columns are allowed but ignored</p>
</td></tr>
<tr><td><code id="harmonize_+3A_raw_folder">raw_folder</code></td>
<td>
<p>(character) folder / folder path containing data files to include in key</p>
</td></tr>
<tr><td><code id="harmonize_+3A_data_format">data_format</code></td>
<td>
<p>(character) file extensions to identify within the <code>raw_folder</code>. Default behavior is to search for all supported file types.</p>
</td></tr>
<tr><td><code id="harmonize_+3A_quiet">quiet</code></td>
<td>
<p>(logical) whether to suppress certain non-warning messages. Defaults to <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>(dataframe) harmonized dataframe including all columns defined in the &quot;tidy_name&quot; column of the key object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate two simple tables
## Dataframe 1
df1 &lt;- data.frame("xx" = c(1:3),
                  "unwanted" = c("not", "needed", "column"),
                  "yy" = letters[1:3])
## Dataframe 2
df2 &lt;- data.frame("LETTERS" = letters[4:7],
                  "NUMBERS" = c(4:7),
                  "BONUS" = c("plantae", "animalia", "fungi", "protista"))

# Generate a local folder for exporting
temp_folder &lt;- tempdir()

# Export both files to that folder
utils::write.csv(x = df1, file = file.path(temp_folder, "df1.csv"), row.names = FALSE)
utils::write.csv(x = df2, file = file.path(temp_folder, "df2.csv"), row.names = FALSE)

# Generate a column key object manually
key_obj &lt;- data.frame("source" = c(rep("df1.csv", 3), 
                                   rep("df2.csv", 3)),
                      "raw_name" = c("xx", "unwanted", "yy",
                                     "LETTERS", "NUMBERS", "BONUS"),
                    "tidy_name" = c("numbers", NA, "letters",
                                    "letters", "numbers", "kingdom"))

# Use that to harmonize the 'raw' files we just created
ltertools::harmonize(key = key_obj, raw_folder = temp_folder, data_format = "csv")

</code></pre>

<hr>
<h2 id='lter_sites'>Long Term Ecological Research Site Information</h2><span id='topic+lter_sites'></span>

<h3>Description</h3>

<p>There are currently 28 field sites involved with the Long Term Ecological Research (LTER) network. These sites occupy a range of habitats and were started / are renewed on site-specific timelines. To make this information more readily available to interested parties, this data object summarizes the key components of each site in an easy-to-use data format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lter_sites
</code></pre>


<h3>Format</h3>

<p>Dataframe with 8 columns and 32 rows
</p>

<dl>
<dt>name</dt><dd><p>Full name of the LTER site</p>
</dd>
<dt>code</dt><dd><p>Abbreviation (typically three letters) of the site name</p>
</dd>
<dt>habitat</dt><dd><p>Simplified habitat designation of the site (or &quot;mixed&quot; for more complex habitat contexts)</p>
</dd>
<dt>start_year</dt><dd><p>Year of initial funding by NSF as an official LTER site</p>
</dd>
<dt>end_year</dt><dd><p>End of current funding cycle grant</p>
</dd>
<dt>latitude</dt><dd><p>Degrees latitude of site</p>
</dd>
<dt>longitude</dt><dd><p>Degrees longitude of site</p>
</dd>
<dt>site_url</dt><dd><p>Website URL for the site</p>
</dd>
</dl>



<h3>Source</h3>

<p> Long Term Ecological Research Network Office. https://lternet.edu/site/
</p>

<hr>
<h2 id='ltertools-package'>ltertools: Tools Developed by the Long Term Ecological Research Community</h2><span id='topic+ltertools'></span><span id='topic+ltertools-package'></span>

<h3>Description</h3>

<p>Set of the data science tools created by various members of the Long Term Ecological Research (LTER) community. These functions were initially written largely as standalone operations and have later been aggregated into this package.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Nicholas Lyon <a href="mailto:lyon@nceas.ucsb.edu">lyon@nceas.ucsb.edu</a> (<a href="https://orcid.org/0000-0003-3905-1078">ORCID</a>) (https://njlyon0.github.io/)
</p>
<p>Authors:
</p>

<ul>
<li><p> Angel Chen <a href="mailto:anchen@nceas.ucsb.edu">anchen@nceas.ucsb.edu</a> (<a href="https://orcid.org/0000-0003-3515-6710">ORCID</a>) (angelchen7.github.io)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p>  National Science Foundation (NSF 1929393, 09/01/2019 - 08/31/2024) [funder]
</p>
</li>
<li><p>  University of California, Santa Barbara [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://lter.github.io/ltertools/">https://lter.github.io/ltertools/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/lter/ltertools/issues">https://github.com/lter/ltertools/issues</a>
</p>
</li></ul>


<hr>
<h2 id='read'>Read Data from Folder</h2><span id='topic+read'></span>

<h3>Description</h3>

<p>Reads in all data files of specified types found in the designated folder. Returns a list with one element for each data file. Currently supports CSV, TXT, XLS, and XLSX
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read(raw_folder = NULL, data_format = c("csv", "txt", "xls", "xlsx"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_+3A_raw_folder">raw_folder</code></td>
<td>
<p>(character) folder / folder path containing data files to read</p>
</td></tr>
<tr><td><code id="read_+3A_data_format">data_format</code></td>
<td>
<p>(character) file extensions to identify within the <code>raw_folder</code>. Default behavior is to search for all supported file types.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(list) data found in specified folder of specified file format(s)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate two simple tables
## Dataframe 1
df1 &lt;- data.frame("xx" = c(1:3),
                  "unwanted" = c("not", "needed", "column"),
                  "yy" = letters[1:3])
## Dataframe 2
df2 &lt;- data.frame("LETTERS" = letters[4:7],
                  "NUMBERS" = c(4:7),
                  "BONUS" = c("plantae", "animalia", "fungi", "protista"))

# Generate a local folder for exporting
temp_folder &lt;- tempdir()

# Export both files to that folder
utils::write.csv(x = df1, file = file.path(temp_folder, "df1.csv"), row.names = FALSE)
utils::write.csv(x = df2, file = file.path(temp_folder, "df2.csv"), row.names = FALSE)

# Read in all CSV files in that folder
read(raw_folder = temp_folder, data_format = "csv")

</code></pre>

<hr>
<h2 id='site_subset'>Subsets the LTER Site Information Table by Site Codes and Habitats</h2><span id='topic+site_subset'></span>

<h3>Description</h3>

<p>Subsets the information on long term ecological research (LTER) sites based on user-specified site codes (i.e., three letter abbreviations), and/or desired habitats. See <code>lter_sites</code> for the full set of site information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>site_subset(sites = NULL, habitats = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="site_subset_+3A_sites">sites</code></td>
<td>
<p>(character) three letter site code(s) identifying site(s) of interest</p>
</td></tr>
<tr><td><code id="site_subset_+3A_habitats">habitats</code></td>
<td>
<p>(character) habitat(s) of interest. See <code>unique(lter_sites$habitat)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>(dataframe) complete site information (8 columns) for all sites that meet the provided site code and/or habitat criteria
</p>

<hr>
<h2 id='site_timeline'>Create a Timeline of Site(s) that Meet Criteria</h2><span id='topic+site_timeline'></span>

<h3>Description</h3>

<p>Creates a ggplot2 plot of all sites that meet the user-specified site code (i.e., three letter abbreviation) and/or habitat criteria. See <code>lter_sites</code> for the full set of site information including accepted site codes and habitat designations (unrecognized entries will trigger a warning and be ignored). Lines are grouped and colored by habitat to better emphasize possible similarities among sites
</p>


<h3>Usage</h3>

<pre><code class='language-R'>site_timeline(sites = NULL, habitats = NULL, colors = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="site_timeline_+3A_sites">sites</code></td>
<td>
<p>(character) three letter site code(s) identifying site(s) of interest</p>
</td></tr>
<tr><td><code id="site_timeline_+3A_habitats">habitats</code></td>
<td>
<p>(character) habitat(s) of interest. See <code>unique(lter_sites$habitat)</code></p>
</td></tr>
<tr><td><code id="site_timeline_+3A_colors">colors</code></td>
<td>
<p>(character) colors to assign to the timelines expressed as a hexadecimal (e.g, #00FF00). Note there must be as many colors as habitats included in the graph</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(ggplot2) plot object of timeline of site(s) that meet user-specified criteria
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Make the full timeline of all sites with default colors by supplying no arguments
site_timeline()

# Or make a timeline of only sites that meet certain criteria
site_timeline(habitats = c("grassland", "forest"))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
