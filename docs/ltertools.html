<!DOCTYPE html><html lang="en-US"><head><title>Help for package ltertools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ltertools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ltertools-package'><p>ltertools: Tools Developed by the Long Term Ecological Research Community</p></a></li>
<li><a href='#begin_key'><p>Generate the Skeleton of a Column Key</p></a></li>
<li><a href='#convert_temp'><p>Convert Temperature Values</p></a></li>
<li><a href='#cv'><p>Calculate Coefficient of Variation</p></a></li>
<li><a href='#expand_key'><p>Generate the Skeleton of a Column Key for Only New Data Files</p></a></li>
<li><a href='#harmonize'><p>Harmonize Data via a Column Key</p></a></li>
<li><a href='#lter_sites'><p>Long Term Ecological Research Site Information</p></a></li>
<li><a href='#make_json'><p>Make a JSON File with Specified Contents</p></a></li>
<li><a href='#read'><p>Read Data from Folder</p></a></li>
<li><a href='#site_subset'><p>Subsets the LTER Site Information Table by Site Codes and Habitats</p></a></li>
<li><a href='#site_timeline'><p>Create a Timeline of Site(s) that Meet Criteria</p></a></li>
<li><a href='#solar_day_info'><p>Identify Solar Day Information</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools Developed by the Long Term Ecological Research Community</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-02-21</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nicholas Lyon &lt;lyon@nceas.ucsb.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Set of the data science tools created by various members of the Long Term 
    Ecological Research (LTER) community. These functions were initially written largely 
    as standalone operations and have later been aggregated into this package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-3-Clause">BSD_3_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://lter.github.io/ltertools/">https://lter.github.io/ltertools/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/lter/ltertools/issues">https://github.com/lter/ltertools/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, generics, ggplot2, magrittr, purrr, readxl, RJSONIO,
stats, stringr, tidyr, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-21 15:25:23 UTC; lyon</td>
</tr>
<tr>
<td>Author:</td>
<td>Nicholas Lyon [aut, cre] (https://njlyon0.github.io/),
  Angel Chen [aut] (https://angelchen7.github.io),
  Miguel C. Leon [ctb] (https://luquillo.lter.network/),
  National Science Foundation [fnd] (NSF 1929393, 09/01/2019 -
    08/31/2024),
  University of California, Santa Barbara [cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-21 15:40:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='ltertools-package'>ltertools: Tools Developed by the Long Term Ecological Research Community</h2><span id='topic+ltertools'></span><span id='topic+ltertools-package'></span>

<h3>Description</h3>

<p>Set of the data science tools created by various members of the Long Term Ecological Research (LTER) community. These functions were initially written largely as standalone operations and have later been aggregated into this package.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Nicholas Lyon <a href="mailto:lyon@nceas.ucsb.edu">lyon@nceas.ucsb.edu</a> (https://njlyon0.github.io/)
</p>
<p>Authors:
</p>

<ul>
<li><p> Angel Chen <a href="mailto:anchen@nceas.ucsb.edu">anchen@nceas.ucsb.edu</a> (https://angelchen7.github.io)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Miguel C. Leon (https://luquillo.lter.network/) [contributor]
</p>
</li>
<li><p>  National Science Foundation (NSF 1929393, 09/01/2019 - 08/31/2024) [funder]
</p>
</li>
<li><p>  University of California, Santa Barbara [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://lter.github.io/ltertools/">https://lter.github.io/ltertools/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/lter/ltertools/issues">https://github.com/lter/ltertools/issues</a>
</p>
</li></ul>


<hr>
<h2 id='begin_key'>Generate the Skeleton of a Column Key</h2><span id='topic+begin_key'></span>

<h3>Description</h3>

<p>Creates the start of a 'column key' for harmonizing data. A column key includes a column for the file names to be harmonized into a single data object as well as a column for the column names in those files. Finally, it includes a column indicating the tidied name that corresponds with each raw column name. Harmonization can accept this key object and use it to rename all raw column names&ndash;in a reproducible way&ndash;to standardize across datasets. Currently supports raw files of the following formats: CSV, TXT, XLS, and XLSX
</p>


<h3>Usage</h3>

<pre><code class='language-R'>begin_key(
  raw_folder = NULL,
  data_format = c("csv", "txt", "xls", "xlsx"),
  guess_tidy = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="begin_key_+3A_raw_folder">raw_folder</code></td>
<td>
<p>(character) folder / folder path containing data files to include in key</p>
</td></tr>
<tr><td><code id="begin_key_+3A_data_format">data_format</code></td>
<td>
<p>(character) file extensions to identify within the <code>raw_folder</code>. Default behavior is to search for all supported file types.</p>
</td></tr>
<tr><td><code id="begin_key_+3A_guess_tidy">guess_tidy</code></td>
<td>
<p>(logical) whether to attempt to &quot;guess&quot; what the tidy name equivalent should be for each raw column name. This is accomplished via coercion to lowercase and removal of special character/repeated characters. If <code>FALSE</code> (the default) the &quot;tidy_name&quot; column is returned empty</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(dataframe) skeleton of column key
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate two simple tables
## Dataframe 1
df1 &lt;- data.frame("xx" = c(1:3),
                  "unwanted" = c("not", "needed", "column"),
                  "yy" = letters[1:3])
## Dataframe 2
df2 &lt;- data.frame("LETTERS" = letters[4:7],
                  "NUMBERS" = c(4:7),
                  "BONUS" = c("plantae", "animalia", "fungi", "protista"))

# Generate a local folder for exporting
temp_folder &lt;- tempdir()

# Export both files to that folder
utils::write.csv(x = df1, file = file.path(temp_folder, "df1.csv"), row.names = FALSE)
utils::write.csv(x = df2, file = file.path(temp_folder, "df2.csv"), row.names = FALSE)

# Generate a column key with "guesses" at tidy column names
ltertools::begin_key(raw_folder = temp_folder, data_format = "csv", guess_tidy = TRUE)

</code></pre>

<hr>
<h2 id='convert_temp'>Convert Temperature Values</h2><span id='topic+convert_temp'></span>

<h3>Description</h3>

<p>Converts a given set of temperature values from one unit to another
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_temp(value = NULL, from = NULL, to = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_temp_+3A_value">value</code></td>
<td>
<p>(numeric) temperature values to convert</p>
</td></tr>
<tr><td><code id="convert_temp_+3A_from">from</code></td>
<td>
<p>(character) starting units of the value, not case sensitive.</p>
</td></tr>
<tr><td><code id="convert_temp_+3A_to">to</code></td>
<td>
<p>(character) units to which to convert, not case sensitive.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(numeric) converted temperature values
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Convert from Fahrenheit to Celsius
convert_temp(value = 32, from = "Fahrenheit", to = "c")

</code></pre>

<hr>
<h2 id='cv'>Calculate Coefficient of Variation</h2><span id='topic+cv'></span>

<h3>Description</h3>

<p>Computes the coefficient of variation (CV), by dividing the standard deviation (SD) by the arithmetic mean of a set of numbers. If <code>na_rm</code> is <code>TRUE</code> then missing values are removed before calculation is completed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv(x, na_rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv_+3A_x">x</code></td>
<td>
<p>(numeric) vector of numbers for which to calculate CV</p>
</td></tr>
<tr><td><code id="cv_+3A_na_rm">na_rm</code></td>
<td>
<p>(logical) whether to remove missing values from both average and SD calculation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(numeric) coefficient of variation
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Convert from Fahrenheit to Celsius
cv(x = c(4, 5, 6, 4, 5, 5), na_rm = TRUE)

</code></pre>

<hr>
<h2 id='expand_key'>Generate the Skeleton of a Column Key for Only New Data Files</h2><span id='topic+expand_key'></span>

<h3>Description</h3>

<p>Data discovery&ndash;and harmonization&ndash;is an iterative process. For those already depending upon a column key and the <code>harmonize</code> function, it can be cumbersome to add rows to an existing column key. This function formats rows for an existing column key for only datasets that are not already (A) in the column key or (B) in the harmonized data table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_key(
  key = NULL,
  raw_folder = NULL,
  harmonized_df = NULL,
  data_format = c("csv", "txt", "xls", "xlsx"),
  guess_tidy = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expand_key_+3A_key">key</code></td>
<td>
<p>(dataframe) key object including a &quot;source&quot;, &quot;raw_name&quot; and &quot;tidy_name&quot; column. Additional columns are allowed but ignored</p>
</td></tr>
<tr><td><code id="expand_key_+3A_raw_folder">raw_folder</code></td>
<td>
<p>(character) folder / folder path containing data files to include in key</p>
</td></tr>
<tr><td><code id="expand_key_+3A_harmonized_df">harmonized_df</code></td>
<td>
<p>(dataframe) harmonized data table produced with the current version of the column key. Must include a &quot;source&quot; column but other columns are ignored.</p>
</td></tr>
<tr><td><code id="expand_key_+3A_data_format">data_format</code></td>
<td>
<p>(character) file extensions to identify within the <code>raw_folder</code>. Default behavior is to search for all supported file types.</p>
</td></tr>
<tr><td><code id="expand_key_+3A_guess_tidy">guess_tidy</code></td>
<td>
<p>(logical) whether to attempt to &quot;guess&quot; what the tidy name equivalent should be for each raw column name. This is accomplished via coercion to lowercase and removal of special character/repeated characters. If <code>FALSE</code> (the default) the &quot;tidy_name&quot; column is returned empty</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(dataframe) skeleton of rows to add to column key for data sources not already in harmonized data table
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate two simple tables
## Dataframe 1
df1 &lt;- data.frame("xx" = c(1:3),
                  "unwanted" = c("not", "needed", "column"),
                  "yy" = letters[1:3])
## Dataframe 2
df2 &lt;- data.frame("LETTERS" = letters[4:7],
                  "NUMBERS" = c(4:7),
                  "BONUS" = c("plantae", "animalia", "fungi", "protista"))

# Generate a local folder for exporting
temp_folder &lt;- tempdir()

# Export both files to that folder
utils::write.csv(x = df1, file = file.path(temp_folder, "df1.csv"), row.names = FALSE)
utils::write.csv(x = df2, file = file.path(temp_folder, "df2.csv"), row.names = FALSE)

# Generate a column key with "guesses" at tidy column names
key1 &lt;- ltertools::begin_key(raw_folder = temp_folder, data_format = "csv", guess_tidy = TRUE)

# Harmonize the data
harmony &lt;- ltertools::harmonize(key = key1, raw_folder = temp_folder)

# Make a new data file
df3 &lt;- data.frame("xx" = c(10:15),
                  "letters" = letters[10:15])

# Export this locally to the temp folder too
utils::write.csv(x = df3, file = file.path(temp_folder, "df3.csv"), row.names = FALSE)

# Identify what needs to be added to the existing column key
ltertools::expand_key(key = key1, raw_folder = temp_folder, harmonized_df = harmony,
                      data_format = "csv", guess_tidy = TRUE)

</code></pre>

<hr>
<h2 id='harmonize'>Harmonize Data via a Column Key</h2><span id='topic+harmonize'></span>

<h3>Description</h3>

<p>A &quot;column key&quot; is meant to streamline harmonization of disparate datasets. This key must include three columns containing: (1) the name of each raw data file to be harmonized, (2) the name of all of the columns in each of those files, and (3) the &quot;tidy name&quot; that corresponds to each raw column name. This function accepts that key and the path to a folder containing all raw data files included in the key. Each dataset is then read in and the original column names are replaced with their respective &quot;tidy_name&quot; indicated in the key. Once this has been done to all files, a single dataframe is returned with only columns indicated in the column name. Currently the following file formats are supported for the raw data: CSV, TXT, XLS, and XLSX
</p>
<p>Note that raw column names without an associated tidy name in the key are removed. We recommend using the <code>begin_key</code> function in this package to generate the skeleton of the key to make achieving the required structure simpler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>harmonize(
  key = NULL,
  raw_folder = NULL,
  data_format = c("csv", "txt", "xls", "xlsx"),
  quiet = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="harmonize_+3A_key">key</code></td>
<td>
<p>(dataframe) key object including a &quot;source&quot;, &quot;raw_name&quot; and &quot;tidy_name&quot; column. Additional columns are allowed but ignored</p>
</td></tr>
<tr><td><code id="harmonize_+3A_raw_folder">raw_folder</code></td>
<td>
<p>(character) folder / folder path containing data files to include in key</p>
</td></tr>
<tr><td><code id="harmonize_+3A_data_format">data_format</code></td>
<td>
<p>(character) file extensions to identify within the <code>raw_folder</code>. Default behavior is to search for all supported file types.</p>
</td></tr>
<tr><td><code id="harmonize_+3A_quiet">quiet</code></td>
<td>
<p>(logical) whether to suppress certain non-warning messages. Defaults to <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>(dataframe) harmonized dataframe including all columns defined in the &quot;tidy_name&quot; column of the key object
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate two simple tables
## Dataframe 1
df1 &lt;- data.frame("xx" = c(1:3),
                  "unwanted" = c("not", "needed", "column"),
                  "yy" = letters[1:3])
## Dataframe 2
df2 &lt;- data.frame("LETTERS" = letters[4:7],
                  "NUMBERS" = c(4:7),
                  "BONUS" = c("plantae", "animalia", "fungi", "protista"))

# Generate a local folder for exporting
temp_folder &lt;- tempdir()

# Export both files to that folder
utils::write.csv(x = df1, file = file.path(temp_folder, "df1.csv"), row.names = FALSE)
utils::write.csv(x = df2, file = file.path(temp_folder, "df2.csv"), row.names = FALSE)

# Generate a column key object manually
key_obj &lt;- data.frame("source" = c(rep("df1.csv", 3), 
                                   rep("df2.csv", 3)),
                      "raw_name" = c("xx", "unwanted", "yy",
                                     "LETTERS", "NUMBERS", "BONUS"),
                    "tidy_name" = c("numbers", NA, "letters",
                                    "letters", "numbers", "kingdom"))

# Use that to harmonize the 'raw' files we just created
ltertools::harmonize(key = key_obj, raw_folder = temp_folder, data_format = "csv")

</code></pre>

<hr>
<h2 id='lter_sites'>Long Term Ecological Research Site Information</h2><span id='topic+lter_sites'></span>

<h3>Description</h3>

<p>There are currently 28 field sites involved with the Long Term Ecological Research (LTER) network. These sites occupy a range of habitats and were started / are renewed on site-specific timelines. To make this information more readily available to interested parties, this data object summarizes the key components of each site in an easy-to-use data format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lter_sites
</code></pre>


<h3>Format</h3>

<p>Dataframe with 8 columns and 32 rows
</p>

<dl>
<dt>name</dt><dd><p>Full name of the LTER site</p>
</dd>
<dt>code</dt><dd><p>Abbreviation (typically three letters) of the site name</p>
</dd>
<dt>habitat</dt><dd><p>Simplified habitat designation of the site (or &quot;mixed&quot; for more complex habitat contexts)</p>
</dd>
<dt>start_year</dt><dd><p>Year of initial funding by NSF as an official LTER site</p>
</dd>
<dt>end_year</dt><dd><p>End of current funding cycle grant</p>
</dd>
<dt>latitude</dt><dd><p>Degrees latitude of site</p>
</dd>
<dt>longitude</dt><dd><p>Degrees longitude of site</p>
</dd>
<dt>site_url</dt><dd><p>Website URL for the site</p>
</dd>
</dl>



<h3>Source</h3>

<p> Long Term Ecological Research Network Office. https://lternet.edu/site/
</p>

<hr>
<h2 id='make_json'>Make a JSON File with Specified Contents</h2><span id='topic+make_json'></span>

<h3>Description</h3>

<p>Creates a JSON (JavaScript Object Notation) file containing the specified name/value pairs. These files are hugely flexible and interpretable by a wide variety of coding languages and thus extremely useful in many contexts. This function is meant to assist those who wish to use JSON files to store user-specific information (e.g., email addresses, absolute file paths, etc.) in collaborative contexts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_json(x = NULL, file = NULL, git_ignore = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_json_+3A_x">x</code></td>
<td>
<p>(character) named vector from which to generate JSON content. Vector elements become JSON values and the vector element names become JSON names. A named vector can be created like so: <code>c("greeting" = "hello", "farewell" = "goodbye")</code>. The characters on the left of the equal signs are names and the characters on the right are values.</p>
</td></tr>
<tr><td><code id="make_json_+3A_file">file</code></td>
<td>
<p>(character) name of JSON file to create with contents provided to <code>x</code>. Must end with &quot;.json&quot;</p>
</td></tr>
<tr><td><code id="make_json_+3A_git_ignore">git_ignore</code></td>
<td>
<p>(logical) whether to add the file name (defined in <code>file</code>) to the '.gitignore' if one exists. Defaults to FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing. Called for side-effects (i.e., creating JSON file)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create contents
my_info &lt;- c("data_path" = "Users/me/documents/my_project/data")

# Generate a local folder for exporting
temp_folder &lt;- tempdir()

# Create a JSON with those contents
make_json(x = my_info, file = file.path(temp_folder, "user.json"), git_ignore = FALSE)

# Read it back in
(user_info &lt;- RJSONIO::fromJSON(content = file.path(temp_folder, "user.json")))

</code></pre>

<hr>
<h2 id='read'>Read Data from Folder</h2><span id='topic+read'></span>

<h3>Description</h3>

<p>Reads in all data files of specified types found in the designated folder. Returns a list with one element for each data file. Currently supports CSV, TXT, XLS, and XLSX
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read(raw_folder = NULL, data_format = c("csv", "txt", "xls", "xlsx"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_+3A_raw_folder">raw_folder</code></td>
<td>
<p>(character) folder / folder path containing data files to read</p>
</td></tr>
<tr><td><code id="read_+3A_data_format">data_format</code></td>
<td>
<p>(character) file extensions to identify within the <code>raw_folder</code>. Default behavior is to search for all supported file types.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(list) data found in specified folder of specified file format(s)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate two simple tables
## Dataframe 1
df1 &lt;- data.frame("xx" = c(1:3),
                  "unwanted" = c("not", "needed", "column"),
                  "yy" = letters[1:3])
## Dataframe 2
df2 &lt;- data.frame("LETTERS" = letters[4:7],
                  "NUMBERS" = c(4:7),
                  "BONUS" = c("plantae", "animalia", "fungi", "protista"))

# Generate a local folder for exporting
temp_folder &lt;- tempdir()

# Export both files to that folder
utils::write.csv(x = df1, file = file.path(temp_folder, "df1.csv"), row.names = FALSE)
utils::write.csv(x = df2, file = file.path(temp_folder, "df2.csv"), row.names = FALSE)

# Read in all CSV files in that folder
read(raw_folder = temp_folder, data_format = "csv")

</code></pre>

<hr>
<h2 id='site_subset'>Subsets the LTER Site Information Table by Site Codes and Habitats</h2><span id='topic+site_subset'></span>

<h3>Description</h3>

<p>Subsets the information on long term ecological research (LTER) sites based on user-specified site codes (i.e., three letter abbreviations), and/or desired habitats. See <code>lter_sites</code> for the full set of site information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>site_subset(sites = NULL, habitats = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="site_subset_+3A_sites">sites</code></td>
<td>
<p>(character) three letter site code(s) identifying site(s) of interest</p>
</td></tr>
<tr><td><code id="site_subset_+3A_habitats">habitats</code></td>
<td>
<p>(character) habitat(s) of interest. See <code>unique(lter_sites$habitat)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>(dataframe) complete site information (8 columns) for all sites that meet the provided site code and/or habitat criteria
</p>

<hr>
<h2 id='site_timeline'>Create a Timeline of Site(s) that Meet Criteria</h2><span id='topic+site_timeline'></span>

<h3>Description</h3>

<p>Creates a ggplot2 plot of all sites that meet the user-specified site code (i.e., three letter abbreviation) and/or habitat criteria. See <code>lter_sites</code> for the full set of site information including accepted site codes and habitat designations (unrecognized entries will trigger a warning and be ignored). Lines are grouped and colored by habitat to better emphasize possible similarities among sites
</p>


<h3>Usage</h3>

<pre><code class='language-R'>site_timeline(sites = NULL, habitats = NULL, colors = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="site_timeline_+3A_sites">sites</code></td>
<td>
<p>(character) three letter site code(s) identifying site(s) of interest</p>
</td></tr>
<tr><td><code id="site_timeline_+3A_habitats">habitats</code></td>
<td>
<p>(character) habitat(s) of interest. See <code>unique(lter_sites$habitat)</code></p>
</td></tr>
<tr><td><code id="site_timeline_+3A_colors">colors</code></td>
<td>
<p>(character) colors to assign to the timelines expressed as a hexadecimal (e.g, #00FF00). Note there must be as many colors as habitats included in the graph</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(ggplot2) plot object of timeline of site(s) that meet user-specified criteria
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Make the full timeline of all sites with default colors by supplying no arguments
site_timeline()

# Or make a timeline of only sites that meet certain criteria
site_timeline(habitats = c("grassland", "forest"))

</code></pre>

<hr>
<h2 id='solar_day_info'>Identify Solar Day Information</h2><span id='topic+solar_day_info'></span>

<h3>Description</h3>

<p>For all days between the specified start and end date, identify the time of sunrise, sunset, and solar noon (in UTC) as well as the day length. The idea for this function was contributed by <a href="https://luquillo.lter.network/">Miguel C. Leon</a> and a Python equivalent lives in the Luquillo site's <a href="https://github.com/LUQ-LTER/LUQ-general-utils">LUQ-general-utils GitHub repository</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solar_day_info(
  lat = NULL,
  lon = NULL,
  start_date = NULL,
  end_date = NULL,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="solar_day_info_+3A_lat">lat</code></td>
<td>
<p>(numeric) latitude coordinate for which to find day length</p>
</td></tr>
<tr><td><code id="solar_day_info_+3A_lon">lon</code></td>
<td>
<p>(numeric) longitude coordinate for which to find day length</p>
</td></tr>
<tr><td><code id="solar_day_info_+3A_start_date">start_date</code></td>
<td>
<p>(character) starting date in 'YYYY-MM-DD' format</p>
</td></tr>
<tr><td><code id="solar_day_info_+3A_end_date">end_date</code></td>
<td>
<p>(character) ending date in 'YYYY-MM-DD' format</p>
</td></tr>
<tr><td><code id="solar_day_info_+3A_quiet">quiet</code></td>
<td>
<p>(logical) whether to suppress certain non-warning messages. Defaults to <code>TRUE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>(dataframe) table of 6 columns and a number of rows equal to the number of days between the specified start and end dates (inclusive). Columns contain: (1) date, (2) sunrise time, (3) sunset time, (4) solar noon, (5) day length, and (6) time zone of columns 2 to 4.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Identify day information in Santa Barbara (California) for one week
solar_day_info(lat = 34.416857, lon = -119.712777, 
               start_date = "2022-02-07", end_date = "2022-02-12", 
               quiet = TRUE)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
