<!DOCTYPE html><html><head><title>Help for package CA3variants</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CA3variants}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ca3basic'>
<p>Three-way Symmetrical Correspondence Analysis</p></a></li>
<li><a href='#ca3plot'>
<p>Row isometric biplot or Column isometric biplot</p></a></li>
<li><a href='#CA3variants'>
<p>Correspondence Analysis variants for three-way contingency tables</p></a></li>
<li><a href='#caplot3d'>

<p>Three dimensional correspondence plot</p></a></li>
<li><a href='#chi3'>
<p>The partition of the Pearson three-way index</p></a></li>
<li><a href='#chi3ordered'>
<p>The partition of the Pearson three-way index.</p></a></li>
<li><a href='#chkneg'>
<p>Check the sign of component values</p></a></li>
<li><a href='#coord'><p>The weighted components of the Tucker3 algorithm</p></a></li>
<li><a href='#coordnsc3'><p>The weighted components of the Tucker3 algorithm</p></a></li>
<li><a href='#criter'><p>The stopping criteria for the Tucker3 algorithm</p></a></li>
<li><a href='#critera'>
<p>Criterion of the Tucker3 algorithm</p></a></li>
<li><a href='#crptrs'>
<p>Pointing to the columns of the component matrices.</p></a></li>
<li><a href='#emerson.poly'>
<p>Orthogonal polynomials</p></a></li>
<li><a href='#flatten'>
<p>Flattened table</p></a></li>
<li><a href='#happy'>

<p>Three-way contingency table</p></a></li>
<li><a href='#happyNL'>

<p>Raw data: Three variables from a Dutch  survey on happiness</p></a></li>
<li><a href='#init3'>
<p>Initial components from the Tuckals3 algorithm</p></a></li>
<li><a href='#init3ordered'>
<p>Initial components from  the Trivariate Moment Decomposition algorithm</p></a></li>
<li><a href='#init3ordered1'>
<p>Initial components from the Trivariate Moment Decomposition algorithm</p></a></li>
<li><a href='#init3ordered2'>
<p>Initial components from the Trivriate Moment Decomposition algorithm</p></a></li>
<li><a href='#invcmp'>
<p>Changing component sign</p></a></li>
<li><a href='#invcor'>
<p>Changing core sign</p></a></li>
<li><a href='#Kron'>
<p>Kronecker product</p></a></li>
<li><a href='#loss1.3'>
<p>General loss criterion</p></a></li>
<li><a href='#loss1.3ordered'>
<p>General loss criterion</p></a></li>
<li><a href='#loss2'>
<p>Difference between two successive components</p></a></li>
<li><a href='#makeindicator'>
<p>Make an Indicator matrix</p></a></li>
<li><a href='#margI'>
<p>Row marginals of a three-way contingency table</p></a></li>
<li><a href='#margJ'>
<p>Column marginals of a three-way contingency table</p></a></li>
<li><a href='#margK'>
<p>Tube marginals of a three-way contingency table</p></a></li>
<li><a href='#museum'>

<p>Raw data: Three variables from a  survey</p></a></li>
<li><a href='#newcomp3'>
<p>Updated component matrices</p></a></li>
<li><a href='#newcomp3ordered'>
<p>Updated component matrices</p></a></li>
<li><a href='#newcomp3ordered1'>
<p>Updated component matrices</p></a></li>
<li><a href='#newcomp3ordered2'>
<p>Updated component matrices</p></a></li>
<li><a href='#nsca3basic'>
<p>Three-way Non-Symmetrical Correspondence Analysis</p></a></li>
<li><a href='#oca3basic'>
<p>Three-way Ordered Symmetrical Correspondence Analysis</p></a></li>
<li><a href='#olive'>

<p>Three-way contingency table</p></a></li>
<li><a href='#onsca3basic'>
<p>Three-way Ordered Non-Symmetrical Correspondence Analysis</p></a></li>
<li><a href='#p.ext'>
<p>The external product in Tuckals3.</p></a></li>
<li><a href='#plot.CA3variants'>
<p>Graphical display resulting from  <code>CA3variants</code></p></a></li>
<li><a href='#plot.tunelocal'>
<p>Graphical display resulting from  <code>tunelocal</code></p></a></li>
<li><a href='#print.CA3variants'>
<p>Print of three-way correspondence analysis results</p></a></li>
<li><a href='#print.tunelocal'>
<p>Print of tunelocal function results</p></a></li>
<li><a href='#prod3'>
<p>Products among arrays</p></a></li>
<li><a href='#ratrank'>

<p>Rating-ranking data a three-way contingency table</p></a></li>
<li><a href='#reconst3'>
<p>Reconstruction of the three-way centred profile table</p></a></li>
<li><a href='#rstand3'>
<p>Weighted centred three-way table for three-way non-symmetric correspondence analysis</p></a></li>
<li><a href='#selmod'>
<p>Selecting the mode.</p></a></li>
<li><a href='#signscore'>
<p>Changing the sign of negative core values.</p></a></li>
<li><a href='#simulabootsimple'>
<p>Generation of parametric bootstrap samples</p></a></li>
<li><a href='#simulabootstrat'>
<p>Generation of parametric bootstrap samples</p></a></li>
<li><a href='#srtcor'><p> Sort the core array</p>
</a></li>
<li><a href='#standtab'>
<p>Three-way centred column profile table for the three-way symmetric correspondence analysis</p></a></li>
<li><a href='#step.g3'>
<p>The core array derived via the Tucker3 model.</p></a></li>
<li><a href='#step.g3ordered'>
<p>The core array derived via the Trivariate Moment Decomposition model.</p></a></li>
<li><a href='#stepi3'>
<p>Component matrices from the Tucker3 decomposition</p></a></li>
<li><a href='#stepi3ordered'>
<p>Component matrices from the Trivariate Moment Decomposition decomposition</p></a></li>
<li><a href='#summary.CA3variants'>
<p>Summary of three-way correspondence analysis results</p></a></li>
<li><a href='#tau3'>
<p>Partition of the Marcotorchino three-way index</p></a></li>
<li><a href='#tau3ordered'>
<p>The partition of the Marcotorchino three-way index.</p></a></li>
<li><a href='#threewayboot'>
<p>Generation of non-parametric bootstrap samples</p></a></li>
<li><a href='#tucker'>
<p>Tucker3 decomposition of the three-way table.</p></a></li>
<li><a href='#tuckerORDERED'>
<p>Trivariate moment decomposition of the three-way table.</p></a></li>
<li><a href='#tunelocal'>
<p>Dimension selection for three-dimensional correspondence biplot using convex hull.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Three-Way Correspondence Analysis Variants</td>
</tr>
<tr>
<td>Version:</td>
<td>3.3.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-10-10</td>
</tr>
<tr>
<td>Author:</td>
<td>Rosaria Lombardo, Eric J Beh and Michel van de Velden</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rosaria Lombardo &lt;rosaria.lombardo@unicampania.it&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides four variants of three-way correspondence analysis (ca):
 three-way symmetrical ca, three-way non-symmetrical ca, three-way ordered symmetrical ca
 and three-way ordered non-symmetrical ca.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&gt; 3.0.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, plotly, tools, ggforce, gridExtra, ggrepel,
multichull, utils</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&gt; 2)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.R-project.org">https://www.R-project.org</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-10 15:45:00 UTC; rosar</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-10 16:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ca3basic'>
Three-way Symmetrical Correspondence Analysis
</h2><span id='topic+ca3basic'></span>

<h3>Description</h3>

<p>This function is used in the main function <code>CA3variants</code> when the input parameter is <code>ca3type="CA3"</code>. <br />
It performs the three-way symmetrical correspondence analysis by TUCKALS3 algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ca3basic(x, p, q, r, test = 10^-6, ctr = T, std = T, sign = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ca3basic_+3A_x">x</code></td>
<td>
<p>The three-way contingency table.
</p>
</td></tr>
<tr><td><code id="ca3basic_+3A_p">p</code></td>
<td>

<p>The number of components of the first mode.
</p>
</td></tr>
<tr><td><code id="ca3basic_+3A_q">q</code></td>
<td>

<p>The number of components of the second mode.
</p>
</td></tr>
<tr><td><code id="ca3basic_+3A_r">r</code></td>
<td>

<p>The number of components of the third mode.
</p>
</td></tr>
<tr><td><code id="ca3basic_+3A_test">test</code></td>
<td>

<p>The treshold used in the algorithm TUCKALS3.
</p>
</td></tr>
<tr><td><code id="ca3basic_+3A_ctr">ctr</code></td>
<td>

<p>The flag parameter (T or F), if F the analysis is not centered.
</p>
</td></tr>
<tr><td><code id="ca3basic_+3A_std">std</code></td>
<td>

<p>The flag parameter (T or F) if F the analysis is not standardized.
</p>
</td></tr>
<tr><td><code id="ca3basic_+3A_sign">sign</code></td>
<td>
<p>The input parameter for changing the sign to the components according to the core sign.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>The original three-way contingency table.</p>
</td></tr>
<tr><td><code>xs</code></td>
<td>
<p>The weighted three-way contingency table.</p>
</td></tr>
<tr><td><code>xhat</code></td>
<td>
<p>Three-way contingency table reconstructed after Tuckals3 by principal components and core array.</p>
</td></tr>
<tr><td><code>nxhat2</code></td>
<td>
<p>The inertia of three-way symmetric correspondence analysis (Three-way Pearson ratio).</p>
</td></tr>
<tr><td><code>prp</code></td>
<td>
<p>The proportion of inertia reconstructed using the p, q, r principal components 
and the core array to the total inertia.
To select the model dimensions (number of principal components), we examine 
the inertia explained by the p, q, r principal components  with respect to the overall fit.</p>
</td></tr>
<tr><td><code>a</code></td>
<td>
<p>The row principal components.</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>The column principal coordinates.</p>
</td></tr>
<tr><td><code>cc</code></td>
<td>
<p>The tube principal coordinates.</p>
</td></tr>
<tr><td><code>g</code></td>
<td>
<p>The core array calculated by using the Tuckals3 algorithm and can be interpreted 
as generalised singular value table. They help to explain the strength of the association between the 
three principal components.</p>
</td></tr>
<tr><td><code>iteration</code></td>
<td>
<p>The number of iterations that are required for the TUCKALS3 algorithm to converge.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Eric J Beh.
</p>

<hr>
<h2 id='ca3plot'>
Row isometric biplot or Column isometric biplot
</h2><span id='topic+ca3plot'></span>

<h3>Description</h3>


<p>This function is used in the main plot function  when the plot type parameter is 
<code>plottype = "biplot"</code> and the variants of three-way CA are not ordered. It can produce a row or a column biplot. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ca3plot(frows, gcols, firstaxis, lastaxis, inertiapc, size1, size2, biptype, addlines)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ca3plot_+3A_frows">frows</code></td>
<td>

<p>The row principal or standard coordinates.
</p>
</td></tr>
<tr><td><code id="ca3plot_+3A_gcols">gcols</code></td>
<td>

<p>The column principal or standard coordinates.
</p>
</td></tr>
<tr><td><code id="ca3plot_+3A_firstaxis">firstaxis</code></td>
<td>

<p>The first axis number.
</p>
</td></tr>
<tr><td><code id="ca3plot_+3A_lastaxis">lastaxis</code></td>
<td>

<p>The second axis number. 
</p>
</td></tr>
<tr><td><code id="ca3plot_+3A_inertiapc">inertiapc</code></td>
<td>

<p>The percentage of the explained inertia by each dimension.
</p>
</td></tr>
<tr><td><code id="ca3plot_+3A_size1">size1</code></td>
<td>

<p>The size of the plotted symbol for categories in biplots. 
</p>
</td></tr>
<tr><td><code id="ca3plot_+3A_size2">size2</code></td>
<td>

<p>The size of the plotted text for categories in biplots. 
</p>
</td></tr>
<tr><td><code id="ca3plot_+3A_biptype">biptype</code></td>
<td>
<p>The input parameter for specifying what kind of biplots is requested. By default, 
it is equal to <code>column-tube</code>, but could be <code>row</code>.
</p>
</td></tr>
<tr><td><code id="ca3plot_+3A_addlines">addlines</code></td>
<td>
<p>The input parameter for plotting lines in  biplot. By default, it is equal to <code>addlines = TRUE</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function depends on the <code>R</code> library <code>plotly</code>.
</p>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Eric J. Beh and Michel van de Velden.
</p>

<hr>
<h2 id='CA3variants'>
Correspondence Analysis variants for three-way contingency tables
</h2><span id='topic+CA3variants'></span>

<h3>Description</h3>

<p>This function performs four variants of three-way correspondence analysis (CA). It does the three-way symmetrical CA, when <code>ca3type = "CA3"</code>, and three-way non-symmetrical 
CA, when <code>ca3type = "NSCA3"</code>, by using the Tucker3 decomposition.
It also performs  ordered  three-way symmetrical CA, when <code>ca3type = "OCA3"</code>, and ordered
three-way non-symmetrical CA, when <code>ca3type = "ONSCA3"</code>, 
by using the Trivariate Moment Decomposition. The non-symmetrical variants consider the three 
variables asymmetrically related, such that one of the variables is the response to be predicted 
given the other two variables. It calculates the coordinates and inertia values of the chosen analyses. 
Furthermore, it allows to look at the index (Pearson's chi-squared or Marcotorchino's tau) partition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CA3variants(Xdata, dims = c(p, q, r), ca3type = "CA3", test = 10^-6, 
resp = "row", norder = 3, sign = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CA3variants_+3A_xdata">Xdata</code></td>
<td>

<p>The three-way data. It can be a <code>R</code> object array or raw data (n individuals by three categorical variables, for an example,
see <code>museum</code> data).
When a three-way non-symmetrical variant is performed, by default, the response variable is the row variable when an array is given, or 
the first of three columns when a raw data set is given. 
For changing, consider the parameter <code>resp = "col"</code> or  <code>resp = "tube"</code>.
</p>
</td></tr>
<tr><td><code id="CA3variants_+3A_dims">dims</code></td>
<td>

<p>The number of components for the first, second and third mode. By default,  no <code>dims</code> is given. When using an
ordered variant of three-way CA recall to consider the complete dimension, i.e. the number of components 
for the first, second and third mode must be equal to the number of rows, columns and tubes, respectively.
</p>
</td></tr>
<tr><td><code id="CA3variants_+3A_ca3type">ca3type</code></td>
<td>

<p>The specification of the analysis to be performed. 
If <code>ca3type = "CA3"</code>, then a three-way symmetrical correspondence analysis will be performed 
(default analysis). 
If <code>ca3type = "NSCA3"</code>, then three-way non-symmetrical correspondence analysis  will be performed.
If <code>ca3type = "OCA3"</code>, then ordered three-way symmetrical correspondence analysis  will be performed.
If <code>ca3type = "ONSCA3"</code>, then ordered three-way non-symmetrical correspondence analysis  will be performed.
</p>
</td></tr>
<tr><td><code id="CA3variants_+3A_test">test</code></td>
<td>

<p>Threshold used in the algorithm for stopping it after the convergence of the
solutions.
</p>
</td></tr>
<tr><td><code id="CA3variants_+3A_resp">resp</code></td>
<td>

<p>The input parameter for specifying in non-symmetrical three-way correspondence analysis variants (<code>ca3type = "NSCA3"</code> 
and <code>ca3type = "ONSCA3"</code>) what is the response variable (logically antecendent to the others). 
By default, <code>resp = "row"</code>, but it could be <code>resp = "col"</code> or <code>resp = "tube"</code>.  
</p>
</td></tr>
<tr><td><code id="CA3variants_+3A_norder">norder</code></td>
<td>

<p>The input parameter for specifying the number of ordered variable when <code>ca3type = "OCA3"</code> or <code>ca3type = "ONSCA3"</code>. 
By default, all three variables are ordered <code>norder = 3</code>. When  <code>norder = 1</code>, you assume that the ordered variable is the column variable.
When  <code>norder = 2</code>, you assume that the ordered variables are the row and column variable.
</p>
</td></tr>
<tr><td><code id="CA3variants_+3A_sign">sign</code></td>
<td>
<p>The input parameter for changing the sign to the components according to the core sign.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function recall internally many other functions, depending on the setting of the input parameters.
After performing three-way symmetric or non-symmetric correspondence analysis, it recall two functions for printing and plotting the results. 
These two important functions are <code>print.CA3variants</code> and <code>plot.CA3variants</code>.</p>


<h3>Value</h3>

<p>The value of output returned depends on the kind of analysis performed.
For a detailed description of the output one can see: <br />
the output value of <code>ca3basic</code> if the input parameter is <code>ca3type="CA3"</code>;
the output value of <code>nsca3basic</code> if the input parameter is <code>ca3type="NSCA3"</code>;
the output value of <code>oca3basic</code> if the input parameter is <code>ca3type="OCA3"</code> 
the output value of <code>onsca3basic</code> if the input parameter is <code>ca3type="ONSCA3"</code> 
</p>


<h3>Author(s)</h3>

<p>Rosaria Lombardo,  Eric J Beh and Michel van de Velden.
</p>


<h3>References</h3>

<p>Beh EJ and Lombardo R (2014) Correspondence Analysis, Theory, Practice and New Strategies. John Wiley &amp; Sons.<br />
Kroonenberg PM (1994) The TUCKALS line: a suite of programs for three-way data analysis. Computational Statistics and Data Analysis, 18, 73&ndash;96.<br />
Lombardo R, Beh EJ and Kroonenberg PM (2021) Symmetrical and Non-Symmetrical Variants of Three-Way Correspondence Analysis for Ordered Variables. 
Statistical Science, 36 (4), 542-561.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(ratrank)
CA3variants(Xdata = ratrank, dims = c(p=2,q=2,r=1), ca3type = "CA3") 
data(happy)
CA3variants(Xdata = happy, dims = c(p=2,q=2,r=2), ca3type = "NSCA3") 
CA3variants(Xdata = happy, dims = c(p=3,q=5,r=4), ca3type = "OCA3") 
CA3variants(Xdata = happy, dims = c(p=3,q=5,r=4), ca3type = "ONSCA3") 
</code></pre>

<hr>
<h2 id='caplot3d'>

Three dimensional correspondence plot
</h2><span id='topic+caplot3d'></span>

<h3>Description</h3>


<p>This function is used in the plot function <code>plot.CAvariants</code> when the logical parameter is 
<code>plot3d = TRUE</code>. 
It produces a 3-dimensional visualization of the association. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>caplot3d(coordR, coordC, inertiaper, firstaxis = 1, lastaxis = 2, thirdaxis = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="caplot3d_+3A_coordr">coordR</code></td>
<td>

<p>The row principal or standard coordinates.
</p>
</td></tr>
<tr><td><code id="caplot3d_+3A_coordc">coordC</code></td>
<td>

<p>The column principal or standard coordinates.
</p>
</td></tr>
<tr><td><code id="caplot3d_+3A_inertiaper">inertiaper</code></td>
<td>

<p>The percentage of the total inertia explained inertia by each dimension.
</p>
</td></tr>
<tr><td><code id="caplot3d_+3A_firstaxis">firstaxis</code></td>
<td>

<p>The first axis number. By default, <code>firstaxis = 1</code>.
</p>
</td></tr>
<tr><td><code id="caplot3d_+3A_lastaxis">lastaxis</code></td>
<td>

<p>The second axis number. By default, <code>lastaxis = 2</code>.
</p>
</td></tr>
<tr><td><code id="caplot3d_+3A_thirdaxis">thirdaxis</code></td>
<td>

<p>The third axis number. By default, <code>thirdaxis = 3</code>.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function depends on the <code>R</code> library <code>plotly</code>.
</p>


<h3>Author(s)</h3>

<p>Rosaria Lombardo and Eric J. Beh
</p>

<hr>
<h2 id='chi3'>
The partition of the Pearson three-way index
</h2><span id='topic+chi3'></span>

<h3>Description</h3>

<p>When three categorical variables are symmetrically related, we can analyse the strength of
the association using the three-way Pearson mean square contingency coefficient, named the chi-squared index.
The function <code>chi3</code> partitions the Pearson phi-squared statistic when in <code>CA3variants</code>
we set the parameter <code>ca3type = "CA3"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chi3(f3, digits = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chi3_+3A_f3">f3</code></td>
<td>

<p>The three-way contingency array given as an input parameter in CA3variants.
</p>
</td></tr>
<tr><td><code id="chi3_+3A_digits">digits</code></td>
<td>

<p>The number of decimal digits. By default digits=3.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The partition of the Pearson index into three two-way association terms and one three-way 
association term. It also shows the explained inertia, the degrees of freedom and 
p-value of each term of the partition.
</p>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Eric J Beh, Ida Camminatiello.
</p>


<h3>References</h3>

<p>Beh EJ and Lombardo R (2014) Correspondence Analysis, Theory, Practice and New Strategies. John Wiley &amp; Sons.<br />
Carlier A and Kroonenberg PM (1996) Decompositions and biplots in three-way correspondence analysis. Psychometrika, 61, 355-373.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(happy)
chi3(f3=happy, digits=3)
</code></pre>

<hr>
<h2 id='chi3ordered'>
The partition of the Pearson three-way index.
</h2><span id='topic+chi3ordered'></span>

<h3>Description</h3>

<p>When three categorical variables are symmetrically related, we can analyse the strength of
the symmetrical  association using the three-way Pearson  statistic.
The function <code>chi3ordered</code> partitions the Pearson phi-squared statistic using orthogonal polynomials
when, in <code>CA3variants</code>, we set the parameter <code>ca3type = "OCA3"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chi3ordered(f3, digits = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chi3ordered_+3A_f3">f3</code></td>
<td>

<p>The three-way contingency array given as an input parameter in <code>CA3variants</code>.
</p>
</td></tr>
<tr><td><code id="chi3ordered_+3A_digits">digits</code></td>
<td>

<p>The number of decimal digits. By default digits=3.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The partition of the Pearson index into three two-way association terms and one 
three-way association term. It also shows the polynomial componets of inertia, the 
percentage of explained inertia, the degrees of freedom and p-value of each term of the partition.
</p>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Eric J Beh, Ida Camminatiello.
</p>


<h3>References</h3>

<p>Lombardo R, Beh EJ and Kroonenberg PM (2021) Symmetrical and Non-Symmetrical Variants of Three-Way Correspondence Analysis for Ordered Variables. 
Statistical Science, 36 (4), 542-561.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#data(happy)
chi3ordered(f3 = happy, digits = 3)
</code></pre>

<hr>
<h2 id='chkneg'>
Check the sign of component values
</h2><span id='topic+chkneg'></span>

<h3>Description</h3>

<p>This function is called from <code>signscore</code>. It checks the negativity of the column of an array
AND the positivity of the columns of an array
If NegPtr = 1 then there is an entirely negative component
If PosPtr = 1 then there is an entirely positive component
If BigPtr = 1 then maximum neg. abs &gt; max pos
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chkneg(comp, nr, nc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chkneg_+3A_comp">comp</code></td>
<td>

<p>One of three component matrix.
</p>
</td></tr>
<tr><td><code id="chkneg_+3A_nr">nr</code></td>
<td>

<p>The row number of the component matrix.</p>
</td></tr>
<tr><td><code id="chkneg_+3A_nc">nc</code></td>
<td>

<p>The column number of the component matrix.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rosaria Lombardo and Pieter M Kroonenberg.</p>


<h3>References</h3>

<p>Kroonenberg PM (1994) The TUCKALS line: a suite of programs for three-way data analysis. Computational Statistics and Data Analysis, 18, 73&ndash;96.<br />
</p>

<hr>
<h2 id='coord'>The weighted components of the Tucker3 algorithm</h2><span id='topic+coord'></span>

<h3>Description</h3>

<p>The function computes the weighted components from the Tucker3 algorithm 
(to take into account the different weight systems in row, column and tube spaces) for symmetrical
three-way correspondence analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coord(res, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coord_+3A_res">res</code></td>
<td>
<p>The component matrices resulting from the Tucker3 algorithm.</p>
</td></tr>
<tr><td><code id="coord_+3A_x">x</code></td>
<td>

<p>The original three-way contingency table.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Eric J Beh.
</p>

<hr>
<h2 id='coordnsc3'>The weighted components of the Tucker3 algorithm</h2><span id='topic+coordnsc3'></span>

<h3>Description</h3>

<p>The function computes the weighted components from the Tucker3 algorithm 
(to take into account the different weight systems in row, column and tube spaces)
for non-symmetrical three-way correspondence analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coordnsc3(res, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coordnsc3_+3A_res">res</code></td>
<td>
<p>The component matrices resulting from the Tucker3 algorithm.</p>
</td></tr>
<tr><td><code id="coordnsc3_+3A_x">x</code></td>
<td>

<p>The original three-way contingency table.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Eric J Beh.
</p>

<hr>
<h2 id='criter'>The stopping criteria for the Tucker3 algorithm</h2><span id='topic+criter'></span>

<h3>Description</h3>

<p>The function computes the stopping criteria needed for the Tucker3 algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>criter(x, xhat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="criter_+3A_x">x</code></td>
<td>
<p>The three-way contingency table</p>
</td></tr>
<tr><td><code id="criter_+3A_xhat">xhat</code></td>
<td>

<p>The reconstruction of the data array using the three component matrices and the core array.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The criterion used in Tuckals3 is the sum of squares of the 
differences between the weighted data array and the reconstructed data array. 
</p>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Eric J Beh.
</p>


<h3>References</h3>

<p>Kroonenberg PM (1994) The TUCKALS line: a suite of programs for three-way data analysis. Computational Statistics and Data Analysis, 18, 73&ndash;96.
</p>

<hr>
<h2 id='critera'>
Criterion of the Tucker3 algorithm
</h2><span id='topic+critera'></span>

<h3>Description</h3>

<p>The function critera is used to define the criterion of the Tucker3 algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>critera(aold, anew)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="critera_+3A_aold">aold</code></td>
<td>

<p>The old component of the first mode.</p>
</td></tr>
<tr><td><code id="critera_+3A_anew">anew</code></td>
<td>

<p>The new component of the first mode.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Eric J Beh</p>


<h3>References</h3>

<p>Kroonenberg PM (1994) The TUCKALS line: a suite of programs for three-way data analysis. Computational Statistics and Data Analysis, 18, 73&ndash;96.
</p>

<hr>
<h2 id='crptrs'>
Pointing to the columns of the component matrices.
</h2><span id='topic+crptrs'></span>

<h3>Description</h3>

<p>Given ICORE, i.e. the pointer to an element in CORE(p,q,r), this subroutine
calculates the IA, IB and IC, pointing to the columns of the component
matrices A, B and C that are responsible for the value in CORE(ICORE).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crptrs(icore, p, q, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crptrs_+3A_icore">icore</code></td>
<td>
<p> The pointer to the core elements whose sign should be reversed.
</p>
</td></tr>
<tr><td><code id="crptrs_+3A_p">p</code></td>
<td>

<p>The dimension number of the first mode.</p>
</td></tr>
<tr><td><code id="crptrs_+3A_q">q</code></td>
<td>

<p>The dimension number of the second mode.</p>
</td></tr>
<tr><td><code id="crptrs_+3A_r">r</code></td>
<td>

<p>The dimension number of the third mode.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>IA</code></td>
<td>

<p>The pointer to the columns of the first component matrix, given the pointer to an element in core. </p>
</td></tr>
<tr><td><code>IB</code></td>
<td>

<p>The pointer to the columns of the second component matrix, given the pointer to an element in core. </p>
</td></tr>
<tr><td><code>IC</code></td>
<td>

<p>The pointer to the columns of the third component matrix, given the pointer to an element in core. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rosaria Lombardo and Pieter M Kroonenberg.</p>


<h3>References</h3>

<p>Kroonenberg PM (1994) The TUCKALS line: a suite of programs for three-way data analysis. Computational Statistics and Data Analysis, 18, 73&ndash;96.
</p>

<hr>
<h2 id='emerson.poly'>
Orthogonal polynomials</h2><span id='topic+emerson.poly'></span>

<h3>Description</h3>

<p>This function is called  from the function <code>oca3basic</code> when in <code>CA3variants</code> we set 
<code>ca3type = "OCA3"</code>.  It allows the analyst to compute the orthogonal polynomials of 
the ordered categorical variable. The number of the polynomials is equal to the variable category less one.
The function computes the polynomial transformation of the ordered categorical variable.</p>


<h3>Usage</h3>

<pre><code class='language-R'>emerson.poly(mj, pj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emerson.poly_+3A_mj">mj</code></td>
<td>

<p>The ordered scores of an ordered variable. By default <code>mj = NULL</code>, the natural scores 
(1,2,...) are computed.
</p>
</td></tr>
<tr><td><code id="emerson.poly_+3A_pj">pj</code></td>
<td>

<p>The marginals, relative frequencies of the ordered variable. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Describe the value returned
</p>
<table>
<tr><td><code>B</code></td>
<td>
<p>The matrix of the orthogonal polynomials without the trivial polynomial.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Note that the sum of the marginals of the ordered variables should be one.
</p>


<h3>Author(s)</h3>

<p>Rosaria Lombardo and Eric J Beh.
</p>


<h3>References</h3>

<p>Beh EJ and Lombardo R (2014) Correspondence Analysis: Theory, Practice and New Strategies. John Wiley &amp; Sons.<br />
Emerson PL (1968)  Numerical construction of orthogonal polynomials from a general recurrence formula. Biometrics, 24 (3), 695-701.<br />
Lombardo R Beh EJ (2016) Variants of Simple Correspondence Analysis. The R Journal, 8 (2), 167&ndash;184.
</p>

<hr>
<h2 id='flatten'>
Flattened table
</h2><span id='topic+flatten'></span>

<h3>Description</h3>

<p>The function flattens the three-way table into the concatenation of two-way matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flatten(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flatten_+3A_x">x</code></td>
<td>
<p>The three-way contingency table.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is utilised by a number of functions: <code>CA3variants</code>, <code>reconst3</code>, <code>newcomp3</code> and 
<code>step.g3</code>.</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>The flattened table of size I,JK where I, J and K are the number of the categories
of rows, columns and tubes, respectively.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Eric J Beh.
</p>

<hr>
<h2 id='happy'>

Three-way contingency table
</h2><span id='topic+happy'></span>

<h3>Description</h3>

<p>This three-way contingency table was generated from the database of the European Social Survey 2016. The variables that we selected for our analysis are Education, Households and Happiness.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(happy)</code></pre>


<h3>Format</h3>

<p>The format is:

row names [1:4] &quot;ED1&quot;, &quot;ED2&quot;, &quot;ED3&quot;, &quot;ED45&quot; 
col names [1:6] &quot;HS1&quot;, &quot;HS2&quot;, &quot;HS3&quot;, &quot;HS4&quot;, &quot;HS5&quot;, &quot;HS&gt;5&quot; 
tube names [1:4] &quot;low&quot;, &quot;middle&quot;, &quot;high&quot;, &quot;very-high&quot;
</p>


<h3>References</h3>

<p>Beh EJ and Lombardo R (2014) Correspondence Analysis: Theory, Practice and New Strategies. John Wiley &amp; Sons. <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>happy &lt;-
structure(c(325, 411, 793, 602, 239, 374, 827, 583, 63, 
181, 361, 303, 42, 129, 229, 224, 16, 49, 89, 54, 
11, 37, 31, 21, 357, 477, 1049, 929, 327, 610, 1447, 
1446, 115, 303, 763, 832, 64, 250, 591, 638, 35, 105, 
183, 185, 15, 56, 99, 71, 265, 327, 769, 928, 342, 
565, 1461, 1808, 104, 314, 768, 1006, 69, 312, 729, 
977, 21, 122, 215, 362, 14, 57, 126, 129, 214, 241, 
554, 660, 419, 561, 1467, 1861, 130, 290, 786, 938, 
89, 319, 741, 1022, 36, 121, 289, 408, 35, 87, 153, 
171), .Dim = c(4, 6, 4), .Dimnames = list(c("ED1", 
"ED2", "ED3", "ED45"), c("HS1", "HS2", "HS3", "HS4", "HS5", "HS&gt;5"
), c("low", "middle", "high", "very-high")))
dim(happy)
</code></pre>

<hr>
<h2 id='happyNL'>

Raw data: Three variables from a Dutch  survey on happiness
</h2><span id='topic+happyNL'></span>

<h3>Description</h3>

<p>This raw data table represents a possible data set selected from a large survey on happiness.
The rows are individuals. The first column concerns four level of happiness, the second column concerns the number of households in a family, 
and the third column their level of Education.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(museum)</code></pre>


<h3>Format</h3>

<p>The format is:
row names [1:4] &quot;low&quot;, &quot;middle&quot;, &quot;high&quot;, &quot;very-high&quot;
col names [1:5] &quot;HS1&quot;, &quot;HS2&quot;, &quot;HS3&quot;, &quot;HS4&quot;, &quot;&gt;HS5&quot;
tube names [1:4] &quot;ED1&quot;, &quot;ED2&quot;, &quot;ED3&quot;, &quot;ED45&quot;
</p>


<h3>References</h3>

<p>Lombardo R, van de Velden M and Beh E J (2022) Three-way Correspondence Analysis in R. (submitted) <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>happyNL&lt;-structure(c(11L, 12L, 15L, 7L, 2L, 6L, 17L, 13L, 0L, 2L, 4L, 
6L, 0L, 5L, 7L, 3L, 0L, 3L, 3L, 1L, 14L, 56L, 52L, 22L, 11L, 
39L, 70L, 65L, 1L, 14L, 19L, 14L, 5L, 12L, 16L, 20L, 2L, 3L, 
10L, 4L, 14L, 44L, 44L, 15L, 6L, 27L, 79L, 47L, 4L, 17L, 40L, 
27L, 2L, 25L, 49L, 38L, 1L, 12L, 12L, 11L, 10L, 41L, 66L, 24L, 
4L, 32L, 100L, 90L, 1L, 8L, 40L, 28L, 3L, 15L, 49L, 35L, 1L, 
4L, 23L, 15L), .Dim = c(4L, 5L, 4L), .Dimnames = list(happy = c("low", 
"middle", "high", "very-high"), hhmmb = c("HS1", "HS2", "HS3", 
"HS4", "&gt;HS5"), edulvla = c("ED1", "ED2", "ED3", "ED45")), class = "table")
dim(happyNL)
data(happyNL)
</code></pre>

<hr>
<h2 id='init3'>
Initial components from the Tuckals3 algorithm
</h2><span id='topic+init3'></span>

<h3>Description</h3>

<p>The function is utilised from the function <code>tucker</code> to compute the 
initial components for each of the three categorical variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init3(x, p, q, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init3_+3A_x">x</code></td>
<td>

<p>The three-way contingency table.
</p>
</td></tr>
<tr><td><code id="init3_+3A_p">p</code></td>
<td>

<p>The number of components of the first mode.
</p>
</td></tr>
<tr><td><code id="init3_+3A_q">q</code></td>
<td>

<p>The number of components of the second mode.
</p>
</td></tr>
<tr><td><code id="init3_+3A_r">r</code></td>
<td>

<p>The number of components of the third mode.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The initial components for each of the three categorical
variables.
</p>
<table>
<tr><td><code>a</code></td>
<td>
<p>The initial component derived from the Tucker3 decomposition for the first mode.</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>The initial component derived from the Tucker3 decomposition for the second mode.</p>
</td></tr>
<tr><td><code>cc</code></td>
<td>
<p>The initial component derived from the Tucker3 decomposition for the third mode.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>The three-way contingency table</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Eric J Beh, Ida Camminatiello.
</p>

<hr>
<h2 id='init3ordered'>
Initial components from  the Trivariate Moment Decomposition algorithm
</h2><span id='topic+init3ordered'></span>

<h3>Description</h3>

<p>The function is utilised from the function <code>tuckerordered</code> to compute the 
initial components for each of the three ordered categorical variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init3ordered(x, p, q, r, x0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init3ordered_+3A_x">x</code></td>
<td>

<p>The three-way contingency table.
</p>
</td></tr>
<tr><td><code id="init3ordered_+3A_p">p</code></td>
<td>

<p>The number of components of the first mode.
</p>
</td></tr>
<tr><td><code id="init3ordered_+3A_q">q</code></td>
<td>

<p>The number of components of the second mode.
</p>
</td></tr>
<tr><td><code id="init3ordered_+3A_r">r</code></td>
<td>

<p>The number of components of the third mode.
</p>
</td></tr>
<tr><td><code id="init3ordered_+3A_x0">x0</code></td>
<td>

<p>The original three-way contingency table.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The initial components for each of the three categorical
variables.

</p>
<table>
<tr><td><code>a</code></td>
<td>
<p>The initial component derived from  the Trivariate Moment Decomposition for the first mode.</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>The initial component derived from  the Trivariate Moment Decomposition for the second mode.</p>
</td></tr>
<tr><td><code>cc</code></td>
<td>
<p>The initial component derived from  the Trivariate Moment Decomposition for the third mode.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>The three-way contingency table.</p>
</td></tr>

</table>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Eric J Beh, Ida Camminatiello.
</p>

<hr>
<h2 id='init3ordered1'>
Initial components from the Trivariate Moment Decomposition algorithm
</h2><span id='topic+init3ordered1'></span>

<h3>Description</h3>

<p>The function is utilised from the function <code>tuckerORDERED</code> to compute the 
initial components for the first ordered categorical variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init3ordered1(x, p, q, r, x0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init3ordered1_+3A_x">x</code></td>
<td>

<p>The three-way contingency table.
</p>
</td></tr>
<tr><td><code id="init3ordered1_+3A_p">p</code></td>
<td>

<p>The number of components of the first mode.
</p>
</td></tr>
<tr><td><code id="init3ordered1_+3A_q">q</code></td>
<td>

<p>The number of components of the second mode.
</p>
</td></tr>
<tr><td><code id="init3ordered1_+3A_r">r</code></td>
<td>

<p>The number of components of the third mode.
</p>
</td></tr>
<tr><td><code id="init3ordered1_+3A_x0">x0</code></td>
<td>

<p>The original three-way contingency table.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The initial components for each of the three categorical
variables.

</p>
<table>
<tr><td><code>a</code></td>
<td>
<p>The initial component derived from the Trivariate Moment Decomposition for the first mode.</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>The initial component derived from  the Trivariate Moment Decomposition for the second mode.</p>
</td></tr>
<tr><td><code>cc</code></td>
<td>
<p>The initial component derived from  the Trivariate Moment Decomposition for the third mode.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>The three-way contingency table.</p>
</td></tr>

</table>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Eric J Beh, Ida Camminatiello.
</p>

<hr>
<h2 id='init3ordered2'>
Initial components from the Trivriate Moment Decomposition algorithm
</h2><span id='topic+init3ordered2'></span>

<h3>Description</h3>

<p>The function is utilised from the function <code>tuckerordered</code> to compute the 
initial components for each of the two ordered categorical variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init3ordered2(x, p, q, r, x0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init3ordered2_+3A_x">x</code></td>
<td>

<p>The three-way contingency table.
</p>
</td></tr>
<tr><td><code id="init3ordered2_+3A_p">p</code></td>
<td>

<p>The number of components of the first mode.
</p>
</td></tr>
<tr><td><code id="init3ordered2_+3A_q">q</code></td>
<td>

<p>The number of components of the second mode.
</p>
</td></tr>
<tr><td><code id="init3ordered2_+3A_r">r</code></td>
<td>

<p>The number of components of the third mode.
</p>
</td></tr>
<tr><td><code id="init3ordered2_+3A_x0">x0</code></td>
<td>

<p>The original three-way contingency table.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The initial components for each of the three categorical
variables.

</p>
<table>
<tr><td><code>a</code></td>
<td>
<p>The initial component derived from the Trivriate Moment Decomposition for the first mode.</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>The initial component derived from the Trivriate Moment Decomposition for the second mode.</p>
</td></tr>
<tr><td><code>cc</code></td>
<td>
<p>The initial component derived from the Trivriate Moment Decomposition for the third mode.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>The three-way contingency table.</p>
</td></tr>

</table>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Eric J Beh, Ida Camminatiello.
</p>

<hr>
<h2 id='invcmp'>
Changing component sign
</h2><span id='topic+invcmp'></span>

<h3>Description</h3>

<p>This function changes the sign of the elements in column of the component
matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invcmp(comp, nr, nc, chgcomp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invcmp_+3A_comp">comp</code></td>
<td>

<p>One of the three component matrices.</p>
</td></tr>
<tr><td><code id="invcmp_+3A_nr">nr</code></td>
<td>

<p>The row number of the component matrix.</p>
</td></tr>
<tr><td><code id="invcmp_+3A_nc">nc</code></td>
<td>

<p>The column number of the component matrix.</p>
</td></tr>
<tr><td><code id="invcmp_+3A_chgcomp">chgcomp</code></td>
<td>

<p>The pointers to the columns of the component matrix that are responsible for the value in the ordered core.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rosaria Lombardo and Pieter M Kroonenberg.</p>


<h3>References</h3>

<p>Kroonenberg PM (1994) The TUCKALS line: a suite of programs for three-way data analysis. Computational Statistics and Data Analysis, 18, 73&ndash;96.
</p>

<hr>
<h2 id='invcor'>
Changing core sign</h2><span id='topic+invcor'></span>

<h3>Description</h3>

<p>This function is used from the function <code>signscore</code>. It changes the sign of the elements of core slice
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invcor(core, p, q, r, chgmode, chgcomp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="invcor_+3A_core">core</code></td>
<td>

<p>The core array.</p>
</td></tr>
<tr><td><code id="invcor_+3A_p">p</code></td>
<td>

<p>The dimension of the first mode.</p>
</td></tr>
<tr><td><code id="invcor_+3A_q">q</code></td>
<td>

<p>The dimension of the second mode.</p>
</td></tr>
<tr><td><code id="invcor_+3A_r">r</code></td>
<td>

<p>The dimension of the third mode.</p>
</td></tr>
<tr><td><code id="invcor_+3A_chgmode">chgmode</code></td>
<td>

<p>One of the three mode to change.</p>
</td></tr>
<tr><td><code id="invcor_+3A_chgcomp">chgcomp</code></td>
<td>

<p>One of the three component to change.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rosaria Lombardo and Pieter M Kroonenberg.</p>


<h3>References</h3>

<p>Kroonenberg PM (1994) The TUCKALS line: a suite of programs for three-way data analysis. Computational Statistics and Data Analysis, 18, 73&ndash;96.
</p>

<hr>
<h2 id='Kron'>
Kronecker product
</h2><span id='topic+Kron'></span>

<h3>Description</h3>

<p>The function performs the Kronecker product. Starting from two matrices of dimension <br />
IxP and JxQ the resulting  matrix will be of dimension IxJ,PxQ. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Kron(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Kron_+3A_a">a</code></td>
<td>
<p>The first matrix of dimension IxP involved in the kronecker product.
</p>
</td></tr>
<tr><td><code id="Kron_+3A_b">b</code></td>
<td>

<p>The second matrix of dimension JxQ involved in the kronecker product.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is utilised from several other functions like <code>CA3variants</code>, 
<code>newcomp3</code>, <code>step.g3</code> and <code>reconst3</code>.
</p>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Eric J Beh, Ida Camminatiello.
</p>

<hr>
<h2 id='loss1.3'>
General loss criterion
</h2><span id='topic+loss1.3'></span>

<h3>Description</h3>

<p>This function represents the general loss function on which is based Tuckals3 and calculates 
the difference between two arrays, x and xhat, where x is the three-way contingency table and xhat 
is the reconstruction of this table by means of components and core array.</p>


<h3>Usage</h3>

<pre><code class='language-R'>loss1.3(param, comp.old)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loss1.3_+3A_param">param</code></td>
<td>

<p>The matrices of the row, column and tube components derived via the Tucker3 model.</p>
</td></tr>
<tr><td><code id="loss1.3_+3A_comp.old">comp.old</code></td>
<td>

<p>The matrices of the row, column and tube components derived in the foregoing iteration of 
the Tuckals3 algorithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The difference between three-way contingency table and its reconstruction from the Tucker3 model.
</p>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Eric J Beh, Ida Camminatiello.
</p>

<hr>
<h2 id='loss1.3ordered'>
General loss criterion
</h2><span id='topic+loss1.3ordered'></span>

<h3>Description</h3>

<p>This function represents the general loss function on which is based the Trivariate Moment Decomposition
and calculates the difference between two arrays, x and xhat, where x is the three-way contingency table and xhat 
is the reconstruction of this table by means of components and core array.</p>


<h3>Usage</h3>

<pre><code class='language-R'>loss1.3ordered(param, comp.old)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loss1.3ordered_+3A_param">param</code></td>
<td>

<p>The matrices of the row, column and tube components derived via the Trivariate Moment Decomposition model.</p>
</td></tr>
<tr><td><code id="loss1.3ordered_+3A_comp.old">comp.old</code></td>
<td>

<p>The matrices of the row, column and tube components derived in the foregoing iteration of 
the Trivriate Moment Decomposition algorithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The difference between three-way contingency table and its reconstruction from the Trivariate Moment Decomposition model.
</p>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Eric J Beh, Ida Camminatiello.
</p>

<hr>
<h2 id='loss2'>
Difference between two successive components
</h2><span id='topic+loss2'></span>

<h3>Description</h3>

<p>The function computes the difference between two successive components in the iteration of the 
Tuckals3 algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loss2(param, comp.old)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loss2_+3A_param">param</code></td>
<td>

<p>The matrices of the row, column and tube components derived via the Tucker3 model.
</p>
</td></tr>
<tr><td><code id="loss2_+3A_comp.old">comp.old</code></td>
<td>

<p>The matrices of the row, column and tube components derived in the foregoing iteration of the Tuckals3 
algorithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The difference between two successive components in the iteration of the Tuckals3 algorithm.
</p>


<h3>Author(s)</h3>

<p>Rosaria Lombardo and Eric J Beh.
</p>

<hr>
<h2 id='makeindicator'>
Make an Indicator matrix 
</h2><span id='topic+makeindicator'></span>

<h3>Description</h3>

<p>From a three-way contingency table (as can be used in CA3variants),
it gives the N x total number of categories (rows+cols+tubs) indicator matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeindicator(X) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeindicator_+3A_x">X</code></td>
<td>

<p>The three-way data array. It must be an <code>R</code> object array.</p>
</td></tr>
</table>


<h3>Value</h3>


<table>
<tr><td><code>Z</code></td>
<td>
<p>Output: the N x total number of categories (rows+cols+tubs) indicator matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Eric J Beh.
</p>

<hr>
<h2 id='margI'>
Row marginals of a three-way contingency table
</h2><span id='topic+margI'></span>

<h3>Description</h3>

<p>This function computes the row marginals of the three-way contingency
table specified by the input parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>margI(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="margI_+3A_m">m</code></td>
<td>
<p>The three-way contingency table.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The row marginals of the considered three-way contingency table.
</p>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Eric J Beh, Ida Camminatiello.
</p>

<hr>
<h2 id='margJ'>
Column marginals of a three-way contingency table
</h2><span id='topic+margJ'></span>

<h3>Description</h3>

<p>The function computes the column marginals of the three-way contingency
table specified by the input parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>margJ(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="margJ_+3A_m">m</code></td>
<td>

<p>The three-way contingency table.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The column marginals of the considered three-way contingency table.




</p>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Eric J Beh, Ida Camminatiello.
</p>

<hr>
<h2 id='margK'>
Tube marginals of a three-way contingency table
</h2><span id='topic+margK'></span>

<h3>Description</h3>

<p>The function computes the tube marginals of the three-way contingency
table specified by the input parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>margK(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="margK_+3A_m">m</code></td>
<td>

<p>The three-way contingency table.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The tube marginals of the considered  three-way contingency table.
</p>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Eric J Beh, Ida Camminatiello.
</p>

<hr>
<h2 id='museum'>

Raw data: Three variables from a  survey
</h2><span id='topic+museum'></span>

<h3>Description</h3>

<p>This raw data table represents a possible data set selected from a large survey on customer satisfacyion during museum visiting.
The rows are individuals. The first column concerns the number of visits, the second column concerns if they like it, and the third column their satisfaction.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(museum)</code></pre>


<h3>Format</h3>

<p>The format is:
num [1:223, 1:3] &quot;often&quot; &quot;much&quot; &quot;excellent&quot; ...<br />


</p>


<h3>References</h3>

<p>Beh EJ and Lombardo R (2014) Correspondence Analysis: Theory, Practice and New Strategies. John Wiley &amp; Sons. <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>museum&lt;-structure(list(nvis = structure(c(2L, 2L, 4L, 4L, 1L, 3L, 3L, 
2L, 4L, 1L, 3L, 3L, 4L, 2L, 4L, 3L, 4L, 2L, 2L, 3L, 4L, 4L, 2L, 
4L, 3L, 4L, 2L, 2L, 4L, 1L, 2L, 2L, 4L, 1L, 4L, 2L, 2L, 2L, 4L, 
1L, 1L, 1L, 1L, 2L, 2L, 3L, 2L, 3L, 4L, 4L, 1L, 3L, 2L, 2L, 3L, 
3L, 3L, 2L, 4L, 3L, 2L, 4L, 2L, 3L, 3L, 3L, 3L, 3L, 3L, 2L, 3L, 
3L, 3L, 3L, 2L, 2L, 4L, 4L, 4L, 4L, 3L, 2L, 3L, 3L, 3L, 4L, 2L, 
2L, 2L, 4L, 1L, 1L, 1L, 1L, 2L, 2L, 3L, 2L, 3L, 4L, 4L, 1L, 3L, 
3L, 2L, 4L, 3L, 2L, 4L, 3L, 2L, 4L, 2L, 3L, 3L, 2L, 2L, 2L, 3L, 
2L, 3L, 2L, 2L, 3L, 2L, 2L, 4L, 4L, 4L, 4L, 4L, 3L, 2L, 3L, 3L, 
3L, 4L, 4L, 1L, 3L, 3L, 2L, 1L, 1L, 1L, 1L, 3L, 4L, 2L, 4L, 3L, 
4L, 2L, 2L, 3L, 4L, 2L, 3L, 3L, 3L, 4L, 2L, 2L, 2L, 4L, 1L, 3L, 
1L, 1L, 2L, 2L, 3L, 2L, 3L, 3L, 3L, 1L, 3L, 2L, 2L, 2L, 1L, 1L, 
2L, 2L, 2L, 1L, 3L, 2L, 3L, 4L, 4L, 1L, 3L, 2L, 2L, 2L, 3L, 2L, 
3L, 4L, 4L, 1L, 3L, 3L, 3L, 2L, 1L, 4L, 1L, 3L, 4L, 3L, 4L, 2L, 
4L, 3L, 4L, 2L, 2L, 3L, 3L, 4L), .Label = c("no", "often", "some", 
"voften"), class = "factor"), like = structure(c(2L, 2L, 2L, 
2L, 2L, 3L, 3L, 2L, 2L, 2L, 3L, 3L, 2L, 3L, 1L, 3L, 2L, 3L, 3L, 
1L, 3L, 2L, 3L, 2L, 3L, 2L, 2L, 3L, 2L, 3L, 3L, 3L, 3L, 3L, 2L, 
2L, 2L, 2L, 2L, 2L, 2L, 2L, 3L, 2L, 2L, 3L, 2L, 3L, 2L, 2L, 2L, 
2L, 2L, 2L, 1L, 2L, 2L, 2L, 1L, 3L, 3L, 2L, 3L, 3L, 2L, 3L, 2L, 
3L, 2L, 2L, 3L, 2L, 3L, 2L, 3L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 
2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 3L, 3L, 2L, 3L, 3L, 3L, 
2L, 2L, 2L, 2L, 2L, 2L, 2L, 3L, 3L, 2L, 3L, 3L, 2L, 3L, 3L, 2L, 
3L, 2L, 3L, 3L, 2L, 3L, 2L, 3L, 2L, 2L, 2L, 2L, 3L, 3L, 2L, 2L, 
2L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 3L, 3L, 2L, 1L, 2L, 2L, 3L, 3L, 
2L, 3L, 1L, 2L, 2L, 3L, 3L, 1L, 3L, 2L, 2L, 2L, 2L, 2L, 2L, 2L, 
2L, 2L, 3L, 2L, 2L, 3L, 2L, 2L, 3L, 2L, 3L, 2L, 2L, 2L, 2L, 2L, 
2L, 2L, 2L, 2L, 2L, 3L, 2L, 2L, 3L, 2L, 3L, 2L, 2L, 2L, 2L, 2L, 
2L, 2L, 1L, 2L, 2L, 2L, 2L, 2L, 2L, 3L, 3L, 2L, 1L, 2L, 2L, 3L, 
3L, 3L, 2L, 3L, 1L, 3L, 2L, 3L, 3L, 1L, 3L, 3L), .Label = c("little", 
"much", "some"), class = "factor"), satisfaction = structure(c(1L, 
2L, 2L, 1L, 1L, 2L, 2L, 1L, 3L, 1L, 3L, 1L, 1L, 2L, 2L, 1L, 2L, 
2L, 2L, 2L, 2L, 1L, 4L, 2L, 2L, 3L, 1L, 2L, 1L, 1L, 3L, 3L, 1L, 
1L, 2L, 1L, 1L, 1L, 2L, 2L, 1L, 4L, 3L, 1L, 1L, 2L, 2L, 2L, 2L, 
2L, 2L, 2L, 2L, 1L, 2L, 1L, 2L, 1L, 2L, 2L, 3L, 1L, 2L, 3L, 2L, 
3L, 2L, 3L, 2L, 1L, 2L, 2L, 2L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 
1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 2L, 1L, 1L, 4L, 3L, 1L, 1L, 2L, 
2L, 2L, 2L, 2L, 2L, 1L, 2L, 1L, 2L, 2L, 3L, 1L, 2L, 3L, 1L, 2L, 
3L, 2L, 3L, 2L, 3L, 2L, 1L, 2L, 2L, 2L, 1L, 1L, 1L, 1L, 1L, 1L, 
1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 1L, 2L, 2L, 1L, 3L, 3L, 1L, 
3L, 1L, 1L, 2L, 2L, 1L, 2L, 2L, 2L, 2L, 2L, 1L, 1L, 1L, 1L, 1L, 
1L, 1L, 1L, 2L, 2L, 1L, 4L, 2L, 1L, 1L, 2L, 2L, 2L, 2L, 2L, 2L, 
1L, 1L, 1L, 2L, 1L, 1L, 4L, 3L, 1L, 1L, 2L, 2L, 2L, 2L, 2L, 2L, 
2L, 2L, 1L, 1L, 2L, 1L, 2L, 1L, 2L, 1L, 2L, 2L, 2L, 1L, 3L, 3L, 
1L, 3L, 4L, 1L, 1L, 2L, 2L, 1L, 2L, 2L, 2L, 2L, 3L, 4L), .Label = c("excellent", 
"good", "suff", "unsuff"), class = "factor")), class = "data.frame", row.names = c("1", 
"2", "3", "5", "6", "8", "9", "10", "12", "13", "14", "16", "17", 
"18", "19", "20", "21", "22", "23", "24", "25", "27", "30", "31", 
"32", "33", "34", "35", "36", "37", "38", "39", "40", "41", "42", 
"43", "44", "45", "46", "47", "48", "49", "50", "51", "52", "54", 
"55", "56", "57", "58", "59", "60", "61", "64", "65", "66", "67", 
"68", "69", "70", "71", "72", "73", "74", "75", "78", "80", "81", 
"82", "84", "85", "86", "87", "88", "89", "90", "91", "92", "95", 
"96", "97", "98", "99", "100", "101", "102", "104", "105", "106", 
"107", "108", "109", "110", "111", "112", "113", "115", "116", 
"117", "118", "119", "120", "121", "122", "123", "124", "125", 
"126", "127", "128", "129", "130", "131", "132", "133", "136", 
"138", "139", "140", "142", "143", "144", "145", "146", "147", 
"148", "149", "150", "151", "153", "154", "155", "156", "157", 
"158", "159", "160", "162", "163", "165", "166", "167", "168", 
"169", "170", "171", "173", "174", "175", "176", "177", "178", 
"179", "180", "181", "182", "183", "184", "185", "186", "187", 
"189", "190", "191", "192", "193", "194", "195", "196", "197", 
"198", "200", "201", "202", "203", "204", "205", "206", "207", 
"208", "209", "210", "211", "212", "213", "214", "215", "217", 
"218", "219", "220", "221", "222", "223", "224", "225", "227", 
"228", "229", "230", "231", "232", "233", "234", "235", "236", 
"237", "238", "239", "240", "241", "242", "243", "244", "245", 
"246", "247", "248", "249", "250", "251", "252", "253"))
dim(museum)
data(museum)
</code></pre>

<hr>
<h2 id='newcomp3'>
Updated component matrices
</h2><span id='topic+newcomp3'></span>

<h3>Description</h3>

<p>The function computes the updated component matrices of the Tucker3 decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newcomp3(param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newcomp3_+3A_param">param</code></td>
<td>

<p>The initial matrices of the row, column and tube components derived via the <code>init3</code> function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is utilised from the function <code>tucker</code>.
</p>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Eric J Beh, Ida Camminatiello.
</p>

<hr>
<h2 id='newcomp3ordered'>
Updated component matrices
</h2><span id='topic+newcomp3ordered'></span>

<h3>Description</h3>

<p>The function computes the updated component matrices of the Trivariate Moment Decomposition. 
It is supposed that the number of the ordered categorical variables is equal to 3.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newcomp3ordered(param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newcomp3ordered_+3A_param">param</code></td>
<td>

<p>The initial matrices of the row, column and tube components derived via the <code>init3</code> function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is utilised from the function <code>tuckerORDERED</code>.
</p>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Eric J Beh, Ida Camminatiello.
</p>

<hr>
<h2 id='newcomp3ordered1'>
Updated component matrices
</h2><span id='topic+newcomp3ordered1'></span>

<h3>Description</h3>

<p>The function computes the updated component matrices of the Trivariate Moment Decomposition. 
It is supposed that the number of the ordered categorical variables is equal to 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newcomp3ordered1(param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newcomp3ordered1_+3A_param">param</code></td>
<td>

<p>The initial matrices of the row, column and tube components derived via the <code>init3</code> function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is utilised from the function <code>tuckerORDERED</code>.
</p>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Eric J Beh, Ida Camminatiello.
</p>

<hr>
<h2 id='newcomp3ordered2'>
Updated component matrices
</h2><span id='topic+newcomp3ordered2'></span>

<h3>Description</h3>

<p>The function computes the updated component matrices of the Trivariate Moment Decomposition. 
It is supposed that the number of the ordered categorical variables is equal to 2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newcomp3ordered2(param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="newcomp3ordered2_+3A_param">param</code></td>
<td>

<p>The initial matrices of the row, column and tube components derived via the <code>init3</code> function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is utilised from the function <code>tuckerORDERED</code>.
</p>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Eric J Beh, Ida Camminatiello.
</p>

<hr>
<h2 id='nsca3basic'>
Three-way Non-Symmetrical Correspondence Analysis
</h2><span id='topic+nsca3basic'></span>

<h3>Description</h3>

<p>This function is used in the main function <code>CA3variants</code> when the input parameter is 
<code>catype="NSCA3"</code>. <br />
It decomposes the Marcotorchino index, computes principal axes, coordinates, weights of rows and columns,<br />
total inertia (equal to the Marcotorchino index) and the rank of the matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nsca3basic(x, p, q, r, test = 10^-6, ctr = T, std = T, sign = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nsca3basic_+3A_x">x</code></td>
<td>

<p>The three-way contingency table.
</p>
</td></tr>
<tr><td><code id="nsca3basic_+3A_p">p</code></td>
<td>

<p>The number of components of the first mode.
</p>
</td></tr>
<tr><td><code id="nsca3basic_+3A_q">q</code></td>
<td>

<p>The number of components of the second mode.
</p>
</td></tr>
<tr><td><code id="nsca3basic_+3A_r">r</code></td>
<td>

<p>The number of components of the third mode.
</p>
</td></tr>
<tr><td><code id="nsca3basic_+3A_test">test</code></td>
<td>

<p>The treshold used in the algorithm.
</p>
</td></tr>
<tr><td><code id="nsca3basic_+3A_ctr">ctr</code></td>
<td>

<p>The flag parameter to center the data (T or F), if F the data are not centered.
</p>
</td></tr>
<tr><td><code id="nsca3basic_+3A_std">std</code></td>
<td>

<p>The flag parameter to weight the data (T or F), if F the data are not weighted.
</p>
</td></tr>
<tr><td><code id="nsca3basic_+3A_sign">sign</code></td>
<td>
<p>The input parameter for changing the sign to the components according to the core sign.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>The original three-way contingency table.</p>
</td></tr>
<tr><td><code>xs</code></td>
<td>
<p>The weighted three-way contingency table.</p>
</td></tr>
<tr><td><code>xhat</code></td>
<td>
<p>The three-way contingency table reconstructed after Tuckals3 by means of the 
principal components and core array.</p>
</td></tr>
<tr><td><code>nxhat2</code></td>
<td>
<p>The inertia of the three-way non-symmetrical correspondence analysis <br />
for one response (the three-way Marcotorchino index).</p>
</td></tr>
<tr><td><code>prp</code></td>
<td>
<p>The proportion of inertia reconstructed using the principal components 
and the core array to the total inertia.<br />
To select the model dimensions (number of principal components), we examine 
the inertia explained by the p, q, r principal components  with respect to the overall fit.</p>
</td></tr>
<tr><td><code>a</code></td>
<td>
<p>The row principal components.</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>The column principal components.</p>
</td></tr>
<tr><td><code>cc</code></td>
<td>
<p>The tube principal components.</p>
</td></tr>
<tr><td><code>g</code></td>
<td>
<p>The core array (generalized singular values) calculated by using the Tuckals3 algorithm. <br />
They help to explain the strength of the association among the three principal components.</p>
</td></tr>
<tr><td><code>iteration</code></td>
<td>
<p>The number of iterations that are required for the TUCKALS3 algorithm to converge.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Eric J Beh.
</p>


<h3>References</h3>

<p>Beh EJ and Lombardo R (2014) Correspondence Analysis, Theory, Practice and New Strategies. John Wiley &amp; Sons.
</p>

<hr>
<h2 id='oca3basic'>
Three-way Ordered Symmetrical Correspondence Analysis
</h2><span id='topic+oca3basic'></span>

<h3>Description</h3>

<p>This function is used in the main function <code>CA3variants</code> when the input parameter is <code>ca3type="OCA3"</code>. <br />
It performs the three-way symmetric correspondence analysis by TUCKALS3.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oca3basic(x, p, q, r, test = 10^-6, ctr = T, std = T, norder = 3, sign = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oca3basic_+3A_x">x</code></td>
<td>
<p>The three-way contingency table.
</p>
</td></tr>
<tr><td><code id="oca3basic_+3A_p">p</code></td>
<td>

<p>The number of components of the first mode.
</p>
</td></tr>
<tr><td><code id="oca3basic_+3A_q">q</code></td>
<td>

<p>The number of components of the second mode.
</p>
</td></tr>
<tr><td><code id="oca3basic_+3A_r">r</code></td>
<td>

<p>The number of components of the third mode.
</p>
</td></tr>
<tr><td><code id="oca3basic_+3A_test">test</code></td>
<td>

<p>The treshold used in the algorithm TUCKALS3.
</p>
</td></tr>
<tr><td><code id="oca3basic_+3A_ctr">ctr</code></td>
<td>

<p>The flag parameter (T or F), if F the analysis is not centered.
</p>
</td></tr>
<tr><td><code id="oca3basic_+3A_std">std</code></td>
<td>

<p>The flag parameter (T or F) if F the analysis is not standardized.
</p>
</td></tr>
<tr><td><code id="oca3basic_+3A_norder">norder</code></td>
<td>

<p>The number of ordered variables considered.
</p>
</td></tr>
<tr><td><code id="oca3basic_+3A_sign">sign</code></td>
<td>
<p>The input parameter for changing the sign to the components according to the core sign.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>The original three-way contingency table.</p>
</td></tr>
<tr><td><code>xs</code></td>
<td>
<p>The weighted three-way contingency table.</p>
</td></tr>
<tr><td><code>xhat</code></td>
<td>
<p>Three-way contingency table reconstructed after Tuckals3 by principal components and core array</p>
</td></tr>
<tr><td><code>nxhat2</code></td>
<td>
<p>The inertia of three-way symmetric correspondence analysis (Three-way Pearson ratio).</p>
</td></tr>
<tr><td><code>prp</code></td>
<td>
<p>The proportion of inertia reconstructed using the p, q, r principal components 
and the core array to the total inertia.
To select the model dimensions (number of principal components), we examine 
the inertia explained by the p, q, r principal components  with respect to the overall fit.</p>
</td></tr>
<tr><td><code>a</code></td>
<td>
<p>The row principal components.</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>The column principal coordinates.</p>
</td></tr>
<tr><td><code>cc</code></td>
<td>
<p>The tube principal coordinates.</p>
</td></tr>
<tr><td><code>g</code></td>
<td>
<p>The core array
calculated by using the Tuckals3 algorithm and can be interpreted 
as generalised singular value table. 
They help to explain the strength of the association between the three principal components.</p>
</td></tr>
<tr><td><code>iteration</code></td>
<td>
<p>The number of iterations that are required for the TUCKALS3 algorithm to converge.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Eric J Beh.
</p>


<h3>References</h3>

<p>Lombardo R, Beh EJ and Kroonenberg PM (2021) Symmetrical and Non-Symmetrical Variants of Three-Way Correspondence Analysis for Ordered Variables. 
Statistical Science, 36 (4), 542-561.
</p>

<hr>
<h2 id='olive'>

Three-way contingency table
</h2><span id='topic+olive'></span>

<h3>Description</h3>

<p>This three-way contingency table represents an historical data set found in Agresti (1990).</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(olive)</code></pre>


<h3>Format</h3>

<p>The format is:

row names [1:6] &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot; 
col names [1:3] &quot;NW&quot;, &quot;NE&quot;, &quot;SW&quot;
tube names [1:2] &quot;urban&quot;, &quot;rural&quot;
</p>


<h3>References</h3>

<p>Beh EJ and Lombardo R (2014) Correspondence Analysis: Theory, Practice and New Strategies. John Wiley &amp; Sons. <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>olive &lt;-structure(c(20, 15, 12, 17, 16, 28, 18, 17, 18, 18, 
6, 25, 12, 9, 23, 21, 19, 30, 30, 22, 21, 17, 8, 
12, 23, 18, 20, 18, 10, 15, 11, 9, 26, 19, 17, 24
), .Dim = c(6L, 3L, 2L), .Dimnames = list(c("A", "B", "C", "D", 
"E", "F"), c("NW", "NE", "SW"), c("urban", "rural")))
dim(olive)
data(olive)
</code></pre>

<hr>
<h2 id='onsca3basic'>
Three-way Ordered Non-Symmetrical Correspondence Analysis
</h2><span id='topic+onsca3basic'></span>

<h3>Description</h3>

<p>This function is used in the main function <code>CA3variants</code> when the input parameter is <code>ca3type="ONSCA3"</code>. <br />
It performs the three-way symmetric correspondence analysis by TUCKALS3.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>onsca3basic(x, p, q, r, test = 10^-6, ctr = T, std = T, norder = 3, sign = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="onsca3basic_+3A_x">x</code></td>
<td>
<p>The three-way contingency table.
</p>
</td></tr>
<tr><td><code id="onsca3basic_+3A_p">p</code></td>
<td>

<p>The number of components of the first mode.
</p>
</td></tr>
<tr><td><code id="onsca3basic_+3A_q">q</code></td>
<td>

<p>The number of components of the second mode.
</p>
</td></tr>
<tr><td><code id="onsca3basic_+3A_r">r</code></td>
<td>

<p>The number of components of the third mode.
</p>
</td></tr>
<tr><td><code id="onsca3basic_+3A_test">test</code></td>
<td>

<p>The treshold used in the algorithm TUCKALS3.
</p>
</td></tr>
<tr><td><code id="onsca3basic_+3A_ctr">ctr</code></td>
<td>

<p>The flag parameter (T or F), if F the analysis is not centered.
</p>
</td></tr>
<tr><td><code id="onsca3basic_+3A_std">std</code></td>
<td>

<p>The flag parameter (T or F) if F the analysis is not standardized.
</p>
</td></tr>
<tr><td><code id="onsca3basic_+3A_norder">norder</code></td>
<td>

<p>The number of ordered variables considered.
</p>
</td></tr>
<tr><td><code id="onsca3basic_+3A_sign">sign</code></td>
<td>
<p>The input parameter for changing the sign to the components according to the core sign.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>The original three-way contingency table.</p>
</td></tr>
<tr><td><code>xs</code></td>
<td>
<p>The weighted three-way contingency table.</p>
</td></tr>
<tr><td><code>xhat</code></td>
<td>
<p>Three-way contingency table reconstructed after Tuckals3 by principal components and core array</p>
</td></tr>
<tr><td><code>nxhat2</code></td>
<td>
<p>The inertia of three-way symmetric correspondence analysis (Three-way Pearson ratio).</p>
</td></tr>
<tr><td><code>prp</code></td>
<td>
<p>The proportion of inertia reconstructed using the p, q, r principal components 
and the core array to the total inertia.
To select the model dimensions (number of principal components), we examine 
the inertia explained by the p, q, r principal components  with respect to the overall fit.</p>
</td></tr>
<tr><td><code>a</code></td>
<td>
<p>The row principal components.</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>The column principal coordinates.</p>
</td></tr>
<tr><td><code>cc</code></td>
<td>
<p>The tube principal coordinates.</p>
</td></tr>
<tr><td><code>g</code></td>
<td>
<p>The core array
calculated by using the Tuckals3 algorithm and can be interpreted 
as generalised singular value table. 
They help to explain the strength of the association between the three principal components.</p>
</td></tr>
<tr><td><code>iteration</code></td>
<td>
<p>The number of iterations that are required for the TUCKALS3 algorithm to converge.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Eric J Beh.
</p>


<h3>References</h3>

<p>Lombardo R, Beh EJ and Kroonenberg PM (2021) Symmetrical and Non-Symmetrical Variants of Three-Way Correspondence Analysis for Ordered Variables. 
Statistical Science, 36 (4), 542-561.
</p>

<hr>
<h2 id='p.ext'>
The external product in Tuckals3.
</h2><span id='topic+p.ext'></span>

<h3>Description</h3>

<p>The  computation of external product between the principal components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p.ext(x,y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p.ext_+3A_x">x</code></td>
<td>

<p>x matrix IxS</p>
</td></tr>
<tr><td><code id="p.ext_+3A_y">y</code></td>
<td>

<p>y matrix JxS</p>
</td></tr>
</table>


<h3>Value</h3>

<p>resultant matrix (IxJ),S  with elements xis per yis
</p>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Eric J Beh, Ida Camminatiello.
</p>

<hr>
<h2 id='plot.CA3variants'>
Graphical display resulting from  <code>CA3variants</code>
</h2><span id='topic+plot.CA3variants'></span>

<h3>Description</h3>

<p>The function <code>plot.CA3variants</code> allows the analyst to graphically display 
six types of biplots for symmetrical 3-way variants and two types of biplots for non-symmetrical 3-way variants.
The six types of biplots for <code>CA3</code> and <code>OCA3</code> are the following.
When the input parameter is <code>biptype = "column-tube"</code> (or <code>biptype = "col-tube"</code>), the function displays the column-tube 
interactive biplot, where the column and tube variables are coded 
interactively and have principal coordinates and the row variable has standard coordinates.  
When the input parameter is <code>biptype = "row"</code>, the function displays the row biplot, where the rows have principal coordinates.  
When the input parameter is <code>biptype = "col"</code>, the function displays the column  biplot, where the columns have principal coordinates.  
When the input parameter is <code>biptype = "row-tube"</code>, the function displays the row-tube biplot, where the row-tubes have principal coordinates.  
When the input parameter is <code>biptype = "tube"</code>, the function displays the tube biplot, where the tubes have principal coordinates
When the input parameter is <code>biptype = "row-column"</code> (or <code>biptype = "row-col"</code>), the function displays the row-column 
interactive biplot, where the row-columns have principal coordinates.  
The two types of biplots for <code>NSCA3</code> and <code>ONSCA3</code> are the following.
When the input parameter is <code>biptype = "pred"</code>, the function displays the biplot where the predictors are coded 
interactively and have principal coordinates and the response has standard coordinates.  
When the input parameter is <code>biptype = "resp"</code>, the function displays the  biplot where the response variable has principal coordinates
and the predictors (interactively coded) have standard coordinates.  
</p>
<p>By default, <code>biptype = "column-tube"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CA3variants'
plot(x, firstaxis = 1, lastaxis = 2, thirdaxis = 3, cex = 0.8,  
biptype="column-tube", scaleplot = NULL,  plot3d = FALSE, pos = 1, 
size1 = 1, size2 = 3, addlines = TRUE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.CA3variants_+3A_x">x</code></td>
<td>

<p>The output parameters of the main function <code>CA3variants</code>.
</p>
</td></tr>
<tr><td><code id="plot.CA3variants_+3A_firstaxis">firstaxis</code></td>
<td>

<p>The dimension reflected along the horizontal axis.
</p>
</td></tr>
<tr><td><code id="plot.CA3variants_+3A_lastaxis">lastaxis</code></td>
<td>

<p>The dimension reflected along the vertical axis.
</p>
</td></tr>
<tr><td><code id="plot.CA3variants_+3A_thirdaxis">thirdaxis</code></td>
<td>

<p>The dimension reflected along the third axis when <code>plot3d = TRUE</code>.
</p>
</td></tr>
<tr><td><code id="plot.CA3variants_+3A_cex">cex</code></td>
<td>

<p>The parameter that specifies the size of character labels of points in graphical displays. 
By default, it is equal to 0.8.
</p>
</td></tr>
<tr><td><code id="plot.CA3variants_+3A_biptype">biptype</code></td>
<td>

<p>The input parameter for specifying what kind of biplot is requested. By default, 
it is equal to <code>column-tube</code>, but could be <code>row-tube</code>, <code>row-column</code>, <code>row</code>,
<code>column</code> and <code>tube</code>.
</p>
</td></tr>
<tr><td><code id="plot.CA3variants_+3A_scaleplot">scaleplot</code></td>
<td>

<p>The scaling parameter for biplots to pull points away from the origin (see gamma biplot in Gower et al 2011). 
By default, it is equal to the overall average 
for the sum of squares of the two sets of coordinates (principal and standard ones), because of
the average sum of squares for the two sets of points is the same (see Van de Velden et al 2017).
</p>
</td></tr>
<tr><td><code id="plot.CA3variants_+3A_plot3d">plot3d</code></td>
<td>
<p>The logical parameter specifies whether a 3D plot is to be included 
in the output or not. By default, <code>plot3d = FALSE</code>.
</p>
</td></tr>
<tr><td><code id="plot.CA3variants_+3A_pos">pos</code></td>
<td>
<p>The input parameter for changing the label position. By default, it is equal to 1.
</p>
</td></tr>
<tr><td><code id="plot.CA3variants_+3A_size1">size1</code></td>
<td>
<p>The input parameter for specifying the size of pointers. By default, it is equal to 1.
</p>
</td></tr>
<tr><td><code id="plot.CA3variants_+3A_size2">size2</code></td>
<td>
<p>The input parameter for specifying the label size. By default, it is equal to 2.
</p>
</td></tr>
<tr><td><code id="plot.CA3variants_+3A_addlines">addlines</code></td>
<td>
<p>The input parameter for plotting lines in  biplots (the points in standard coordinates 
are represented using lines). By default, it is equal to <code>addlines = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.CA3variants_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is utilised by the main function <code>CA3variants</code> and uses the secondary graphical function <code>graph2poly</code>.
</p>


<h3>Value</h3>

<p>Graphical displays of three-way correspondence analysis variants. Interactive plots or biplots are
the graphical results of this function.
</p>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Eric J Beh and Michel van de Velden.
</p>


<h3>References</h3>

<p>Beh EJ and Lombardo R (2014) Correspondence Analysis, Theory, Practice and New Strategies. John Wiley &amp; Sons.<br />
Van de Velden M, Iodice D'Enza A, Palumbo F (2017) Cluster Correspondence Analysis. Psychometrika, 82, 158&ndash;185.<br />
Gower JC, Lubbe SG, and Le Roux, NJ (2011) Understanding biplots. New York: Wiley.<br />
Lombardo R, Beh EJ and Kroonenberg PM (2021) Symmetrical and Non-Symmetrical Variants of Three-Way Correspondence Analysis for Ordered Variables. Statistical Science, 36 (4), 542-561.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(happy)
res.ca3&lt;-CA3variants(happy, dims = c(p = 2, q = 2, r = 2), ca3type = "CA3") 
plot(res.ca3)
res.nsca3&lt;-CA3variants(happy, dims = c(p = 2, q = 2, r = 2), ca3type = "NSCA3") 
plot(res.nsca3, biptype = "resp", plot3d = TRUE)
res.oca3&lt;-CA3variants(happy, dims = c(p = 3, q = 5, r = 4), ca3type = "OCA3", norder = 3) 
plot(res.oca3, biptype = "tube",firstaxis=4,lastaxis=7)
res.onsca3&lt;-CA3variants(happy, dims = c(p = 3, q = 5, r = 4), ca3type = "ONSCA3", norder = 3) 
plot(res.onsca3,biptype="resp",firstaxis=6,lastaxis=7)
</code></pre>

<hr>
<h2 id='plot.tunelocal'>
Graphical display resulting from  <code>tunelocal</code>
</h2><span id='topic+plot.tunelocal'></span>

<h3>Description</h3>

<p>The function <code>plot.tunelocal</code> allows the analyst to graphically display 
the optimal model dimension using a convex hull. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tunelocal'
plot(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.tunelocal_+3A_x">x</code></td>
<td>

<p>The results of the function <code>tunelocal</code>.  It shows the models that are located on the boundary of the convex hull 
and selects an optimal model by means of the scree test values (st).
When using <code>boots=F</code>,  it gives the set of possible dimension combination
of the original data using only the original data array.
When using <code>boots=T</code>,  it gives the set of possible dimension combination
of the original data using bootstrapped data arrays.
</p>
</td></tr>


<tr><td><code id="plot.tunelocal_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Graphical displays of  a convex hull computed using the original data and the bootstrapped data when in <code>tunelocal</code> the input parameter <code>boot=TRUE</code> computed bootstrapped data too.
</p>


<h3>Author(s)</h3>

<p>Rosaria Lombardo,  Michel van de Velden and Eric J. Beh.
</p>


<h3>References</h3>

<p>Beh EJ and Lombardo R (2014) Correspondence Analysis, Theory, Practice and New Strategies. John Wiley &amp; Sons.<br />
Wilderjans TF, Ceulemans E, and Meers K (2013) CHull: A generic convex hull based model
selection method. Behavior Research Methods, 45, 1-15.<br />
Ceulemans E, and Kiers H A L (2006) Selecting among three-mode principal component models
of different types and complexities: A numerical convex hull based method. British Journal of
Mathematical &amp; Statistical Psychology, 59, 133-150.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
res.tunelocal&lt;-tunelocal(happy, ca3type = "CA3",boots = FALSE, 
          nboots = 0)
plot(res.tunelocal)
</code></pre>

<hr>
<h2 id='print.CA3variants'>
Print of three-way correspondence analysis results
</h2><span id='topic+print.CA3variants'></span>

<h3>Description</h3>

<p>This function prints the results of three-way symmetrical or non-symmetrical correspondence analysis. 
If the input parameter, in CA3variants, is <code>ca3type="CA3"</code>, the function prints the results 
of three-way symmetrical correspondence analysis.
If the input parameter, in <code>CA3variants</code>, is <code>ca3type="NSCA3"</code>,
the function prints the results of three-way non-symmetrical correspondence analysis.
If the input parameter, in <code>CA3variants</code>, is <code>ca3type="OCA3"</code>,
the function prints the results of ordered three-way symmetrical correspondence analysis.
If the input parameter, in <code>CA3variants</code>, is <code>ca3type="ONSCA3"</code>,
the function prints the results of ordered three-way non-symmetrical correspondence analysis.
When the input parameter, in <code>print.CA3variants</code>, is <code>digits = 3</code>,
the function prints all the results using three digital numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CA3variants'
print(x, printall= FALSE, digits = 3,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.CA3variants_+3A_x">x</code></td>
<td>

<p>The name of the output of the main function <code>CA3variants</code>.
</p>
</td></tr>
<tr><td><code id="print.CA3variants_+3A_printall">printall</code></td>
<td>

<p>The logical parameter that specifies if to print all the results or some of them. By default, <code>printall = FALSE</code>. 
</p>
</td></tr>
<tr><td><code id="print.CA3variants_+3A_digits">digits</code></td>
<td>

<p>The input parameter specifying the digital number. By default, <code>digits = 3</code>.
</p>
</td></tr>
<tr><td><code id="print.CA3variants_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of output returned depends on the kind of three-way correspondence analysis variant performed.
It also gives the number of the iteration of the algorithm to reach the convergence of the solution.
Depending on the variant of three-way correspondence analysis performed, it gives the related weighted
contingency table, the reconstructed table by the components and core array, the explained inertia,
the total inertia, the inertia in percentage, the proportion of explained inertia given the defined number
of the components, the row standard and principal coordinates, the interactive column-tube standard and 
principal coordinates, the inner-product matrix of coordinates, the core array and index partitioning.
In detail:
</p>
<table>
<tr><td><code>CA3variants</code></td>
<td>
<p>The output of the kind of three-way correspondence analysis analysis considered.</p>
</td></tr>
<tr><td><code>Data</code></td>
<td>
<p>The original three-way contingency table.</p>
</td></tr>
<tr><td><code>xs</code></td>
<td>
<p>The centred and weighted three-way contingency table when the input parameters are <code>ctr=T</code> 
and <code>std=T</code>.</p>
</td></tr>
<tr><td><code>xhat</code></td>
<td>
<p>The three-way contingency table approximated (reconstructed) by the three component matrices 
(of dimension Ixp, Jxq, and Kxr) and the core array.</p>
</td></tr>
<tr><td><code>nxhat2</code></td>
<td>
<p>The sum of squares of the approximated contingency table.</p>
</td></tr>
<tr><td><code>prp</code></td>
<td>
<p>The ratio between the inertia of the complete contingency table and the inertia of the approximated contingency table.</p>
</td></tr> 
<tr><td><code>fi</code></td>
<td>
<p>The principal row coordinates.</p>
</td></tr>
<tr><td><code>fiStandard</code></td>
<td>
<p>The standard row coordinates.</p>
</td></tr>
<tr><td><code>gjk</code></td>
<td>
<p>The principal colum-tube coordinates.</p>
</td></tr>
<tr><td><code>gjkStandard</code></td>
<td>
<p>The standard colum-tube coordinates.</p>
</td></tr>
<tr><td><code>fj</code></td>
<td>
<p>The principal column coordinates.</p>
</td></tr>
<tr><td><code>fjStandard</code></td>
<td>
<p>The standard column coordinates.</p>
</td></tr>
<tr><td><code>gik</code></td>
<td>
<p>The principal row-tube coordinates.</p>
</td></tr>
<tr><td><code>gikStandard</code></td>
<td>
<p>The standard row-tube coordinates.</p>
</td></tr>
<tr><td><code>fk</code></td>
<td>
<p>The principal tube coordinates.</p>
</td></tr>
<tr><td><code>fkStandard</code></td>
<td>
<p>The standard tube coordinates.</p>
</td></tr>
<tr><td><code>gij</code></td>
<td>
<p>The principal row-colum coordinates.</p>
</td></tr>
<tr><td><code>gijStandard</code></td>
<td>
<p>The standard row-colum coordinates.</p>
</td></tr>
<tr><td><code>rows</code></td>
<td>
<p>The row marginals of the three-way data table.</p>
</td></tr>
<tr><td><code>cols</code></td>
<td>
<p>The column marginals of the three-way data table.</p>
</td></tr>
<tr><td><code>tubes</code></td>
<td>
<p>The tube marginals of the three-way data table.</p>
</td></tr>
<tr><td><code>flabels</code></td>
<td>
<p>The row category labels.</p>
</td></tr>
<tr><td><code>glabels</code></td>
<td>
<p>The column category labels.</p>
</td></tr>
<tr><td><code>maxaxes</code></td>
<td>
<p>The maximum dimension to consider.</p>
</td></tr>
<tr><td><code>inertia</code></td>
<td>
<p>The total inertia of a variant of three-way correspondence analysis.</p>
</td></tr>
<tr><td><code>inertiaRSS</code></td>
<td>
<p>The residual inertia of a variant of three-way correspondence analysis.</p>
</td></tr>
<tr><td><code>inertiapc</code></td>
<td>
<p>The percentage contribution of the three components to the total variation.</p>
</td></tr>
<tr><td><code>inertiacoltub</code></td>
<td>
<p>The vector of the percentage contributions of the interactively coded colum-tube  components to the total inertia, 
useful for making interactively coded biplots.</p>
</td></tr>
<tr><td><code>inertiarow</code></td>
<td>
<p>The vector of the percentage contributions of the row  components to the total inertia, 
useful for making response biplots.</p>
</td></tr>
<tr><td><code>iproduct</code></td>
<td>
<p>The inner product between the standard row coordinates (fi) and the column-tube principal 
coordinates (gjk).</p>
</td></tr>
<tr><td><code>g</code></td>
<td>
<p>The core array (i.e. the generalized singular values) calculated by using the Tuckals3 algorithm. </p>
</td></tr> 
<tr><td><code>index3</code></td>
<td>
<p>When <code>ca3type = "CA3"</code> or <code>ca3type = "OCA3"</code>, the index3 represents the partition of the Pearson index 
into three two-way association terms and one three-way association term.
It also shows the C statistic of each term, its degrees of freedom and p-value.
If <code>ca3type = "NSCA3"</code> or <code>ca3type = "ONSCA3"</code>, the index3 returns the partition of the Marcotorchino index into three 
two-way association terms and one three-way association term. It also shows the C statistic of each term, 
its degrees of freedom and p-value.</p>
</td></tr>
<tr><td><code>ca3type</code></td>
<td>
<p>The specification of the analysis to be performed.
When <code>ca3type = "CA3"</code>, then a three-way symmetrical correspondence analysis will be performed 
(default analysis). If <code>ca3type = "NSCA3"</code>, then three-way non-symmetrical correspondence analysis 
will be performed, where one of the variables is the response to be predicted given the other two variables. 
These two three-way variants use the Tucker3 method of decomposition.
When <code>ca3type = "OCA3"</code> or <code>ca3type = "ONSCA3"</code>, then an ordered three-way symmetrical or non-symmetrical
correspondence analysis will be performed. 
Differently, these analysis use a new method of decomposition called Trivariate Moment Decomposition.</p>
</td></tr>

</table>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Eric J Beh and Michel van de Velden.
</p>


<h3>References</h3>

<p>Beh EJ and Lombardo R (2014) Correspondence Analysis, Theory, Practice and New Strategies. John Wiley &amp; Sons.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(happy)
ris.ca3&lt;-CA3variants(happy, dims= c(p=2,q=2,r=2), ca3type = "CA3") 
print(ris.ca3)
ris.nsca3&lt;-CA3variants(happy, dims = c(p=2,q=2,r=2), ca3type = "NSCA3") 
print(ris.nsca3)
ris.oca3&lt;-CA3variants(happy, dims = c(p=3,q=5,r=4), ca3type = "OCA3",norder=3) 
print(ris.oca3)
ris.onsca3&lt;-CA3variants(happy, dims = c(p=3,q=5,r=4), ca3type = "ONSCA3",norder=3) 
print(ris.onsca3)

</code></pre>

<hr>
<h2 id='print.tunelocal'>
Print of tunelocal function results
</h2><span id='topic+print.tunelocal'></span>

<h3>Description</h3>

<p>This function prints the results of <code>tunelocal</code> for choosing the optimal model dimension of a variant of three-way correspondence analysis. 
When <code>boots = T</code> the number of different models that is assessed is based on the size of the original data being analysed.<br />
For example, for a 4 x 5 x 4, there are 80 different models that are assessed.<br />
When <code>boots = T</code>,  the number of different models that is assessed is based on the size of all models <br />
obtained from the combination of dimensions of the bootstrapped data. <br />
For example, for a 4 x 5 x 4 array, there are 800 different models that are assessed. By default<code>nboots = 100</code>, <br />
you can change the parameter value in input of <code>tunelocal</code> function.<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tunelocal'
print(x, digits = 3,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.tunelocal_+3A_x">x</code></td>
<td>

<p>The name of the output of the function <code>tunelocal</code>.
</p>
</td></tr>
<tr><td><code id="print.tunelocal_+3A_digits">digits</code></td>
<td>

<p>The input parameter specifying the digital number. By default, <code>digits = 3</code>.
</p>
</td></tr>
<tr><td><code id="print.tunelocal_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of output returned depends on the kind of sampling chosen.
The sampling for making the convex hull can be based on the 
original data or on the bootstrapped data samples. 
In detail:
</p>
<table>
<tr><td><code>XG</code></td>
<td>
<p>The data samples used for assessing the optimal model dimension (original and/or bootstrapped).</p>
</td></tr>


<tr><td><code>output1</code></td>
<td>
<p>The results of <code>tunelocal</code>.  It gives the goodness-of-fit criteria of models that are located <br />
on the boundary of the convex hull and selects the optimal model by means of the scree test values (st); <br />
see Ceulemans and Kiers  (2006).</p>
</td></tr>
<tr><td><code>ca3type</code></td>
<td>
<p>It gives information about the kind of variant of three-way CA considered.</p>
</td></tr>
<tr><td><code>boots</code></td>
<td>
<p>The flag parameter to perform the search of optimal dimensions using
bootstrap samples. By defaults, <code>boots = FALSE</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rosaria Lombardo,  Michel van de Velden and Eric J. Beh.
</p>


<h3>References</h3>

<p>Wilderjans T F, Ceulemans E, and Meers K (2013) CHull: A generic convex hull based model
selection method. Behavior Research Methods, 45, 1-15.<br />
Ceulemans E, and Kiers H A L (2006) Selecting among three-mode principal component models
of different types and complexities: A numerical convex hull based method. British Journal of
Mathematical &amp; Statistical Psychology, 59, 133-150.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
res.tunelocal&lt;-tunelocal(happy, ca3type = "CA3") 
print(res.tunelocal)
</code></pre>

<hr>
<h2 id='prod3'>
Products among arrays
</h2><span id='topic+prod3'></span>

<h3>Description</h3>

<p>The function calculates the products among arrays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prod3(m, a1, a2, a3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prod3_+3A_m">m</code></td>
<td>

<p>The original three-way contingency table.</p>
</td></tr>
<tr><td><code id="prod3_+3A_a1">a1</code></td>
<td>

<p>The weight matrix related to the rows of the table.</p>
</td></tr>
<tr><td><code id="prod3_+3A_a2">a2</code></td>
<td>

<p>The weight matrix related to the columns of the table.
</p>
</td></tr>
<tr><td><code id="prod3_+3A_a3">a3</code></td>
<td>

<p>The weight matrix related to the tubes of the table.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is utilised in <code>standtab</code>, <code>rstand3</code> and <code>rstand3delta</code> in order to weight the 
contingency table with respect to the three weigth matrices defined in the row, column and tube spaces
differently for the three variants of three-way correspondence analysis.
</p>


<h3>Value</h3>

<p>The three-way contingency table weighted with respect the suitable weight matrices (depending on 
the analysis variants).
</p>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Eric J Beh, Ida Camminatiello.
</p>

<hr>
<h2 id='ratrank'>

Rating-ranking data a three-way contingency table
</h2><span id='topic+ratrank'></span>

<h3>Description</h3>

<p>This three-way contingency table represents a known data set described in van Herk and  van de Velden (2007). The three-way contingency table consists of nine rating
values against nine ranking values given by the same
participants across five European countries (France, Italy, Germany, UK and Spain).</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ratrank)</code></pre>


<h3>Format</h3>

<p>The format is:

row names [1:9] &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;,&quot;7&quot;,&quot;8&quot;,&quot;9&quot; 
col names [1:9] &quot;rank1&quot;, &quot;rank2&quot;, &quot;rank3&quot;, &quot;rank4&quot;, &quot;rank5&quot;, &quot;rank6&quot;,
&quot;rank7&quot;, &quot;rank8&quot;, &quot;rank9&quot;
tube names [1:5] &quot;F&quot;, &quot;I&quot;,&quot;G&quot;,&quot;U&quot;,&quot;S&quot;
</p>


<h3>References</h3>

<p>van Herk H and van de Velden M (2007) Insight into the relative merits of rating and ranking
in a cross-national context using three-way correspondence analysis. Food Quality and Preference, 18, 1096&ndash;1105.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ratrank&lt;-structure(c(766L, 128L, 38L, 10L, 12L, 3L, 2L, 5L, 9L, 619L, 
234L, 67L, 16L, 15L, 5L, 2L, 8L, 7L, 512L, 277L, 109L, 22L, 23L, 
5L, 11L, 7L, 7L, 385L, 291L, 152L, 64L, 41L, 9L, 12L, 7L, 12L, 
297L, 251L, 192L, 82L, 96L, 17L, 12L, 6L, 20L, 187L, 203L, 259L, 
105L, 119L, 44L, 19L, 8L, 29L, 143L, 144L, 209L, 140L, 170L, 
54L, 51L, 22L, 40L, 77L, 100L, 152L, 148L, 215L, 73L, 62L, 56L, 
90L, 47L, 45L, 84L, 119L, 200L, 82L, 98L, 67L, 231L, 859L, 101L, 
53L, 18L, 18L, 9L, 7L, 2L, 16L, 733L, 205L, 53L, 23L, 21L, 13L, 
11L, 6L, 18L, 622L, 224L, 124L, 41L, 27L, 8L, 12L, 6L, 19L, 547L, 
248L, 102L, 78L, 45L, 19L, 11L, 11L, 22L, 466L, 243L, 139L, 76L, 
76L, 25L, 21L, 9L, 28L, 357L, 239L, 168L, 105L, 95L, 61L, 20L, 
14L, 24L, 293L, 192L, 165L, 128L, 133L, 42L, 58L, 28L, 44L, 215L, 
162L, 161L, 127L, 148L, 60L, 65L, 54L, 91L, 140L, 121L, 142L, 
128L, 157L, 69L, 76L, 75L, 175L, 1219L, 193L, 29L, 13L, 3L, 4L, 
2L, 6L, 3L, 651L, 504L, 111L, 30L, 19L, 8L, 5L, 8L, 6L, 476L, 
335L, 230L, 35L, 13L, 8L, 5L, 4L, 6L, 346L, 324L, 201L, 136L, 
30L, 5L, 5L, 6L, 5L, 239L, 299L, 234L, 101L, 170L, 22L, 14L, 
4L, 6L, 166L, 246L, 265L, 116L, 96L, 71L, 27L, 11L, 16L, 124L, 
179L, 215L, 163L, 139L, 52L, 80L, 20L, 32L, 80L, 114L, 172L, 
148L, 168L, 80L, 84L, 96L, 70L, 63L, 48L, 101L, 115L, 183L, 92L, 
123L, 131L, 292L, 916L, 99L, 40L, 12L, 7L, 3L, 3L, 13L, 42L, 
578L, 224L, 65L, 11L, 15L, 6L, 3L, 18L, 30L, 486L, 207L, 140L, 
34L, 14L, 10L, 7L, 16L, 29L, 405L, 207L, 149L, 64L, 30L, 7L, 
14L, 21L, 19L, 304L, 256L, 157L, 60L, 83L, 9L, 17L, 20L, 21L, 
239L, 222L, 195L, 95L, 55L, 34L, 20L, 18L, 18L, 204L, 169L, 213L, 
113L, 89L, 23L, 45L, 16L, 15L, 165L, 148L, 184L, 128L, 121L, 
46L, 38L, 51L, 23L, 89L, 94L, 147L, 141L, 181L, 70L, 57L, 32L, 
82L, 1086L, 89L, 37L, 10L, 12L, 6L, 9L, 6L, 24L, 501L, 251L, 
55L, 11L, 14L, 7L, 7L, 7L, 11L, 415L, 139L, 188L, 22L, 14L, 8L, 
4L, 4L, 12L, 359L, 148L, 111L, 101L, 21L, 7L, 7L, 3L, 15L, 278L, 
158L, 128L, 49L, 127L, 9L, 12L, 6L, 13L, 240L, 162L, 130L, 48L, 
58L, 49L, 11L, 5L, 12L, 185L, 113L, 148L, 78L, 84L, 26L, 52L, 
7L, 16L, 128L, 91L, 119L, 110L, 118L, 37L, 38L, 35L, 28L, 83L, 
50L, 67L, 89L, 165L, 47L, 66L, 46L, 120L), .Dim = c(9L, 9L, 5L
), .Dimnames = list(c("1", "2", "3", "4", "5","6", "7",
                      "8", "9"), c("rank1", "rank2", "rank3", 
                        "rank4", "rank5", "rank6",
                       "rank7", "rank8", "rank9"),
                      c("F", "I", "G", "U", "S")))
dim(ratrank)
data(ratrank)
</code></pre>

<hr>
<h2 id='reconst3'>
Reconstruction of the three-way centred profile table
</h2><span id='topic+reconst3'></span>

<h3>Description</h3>

<p>The function reconstructs the three-way centred profile table using the component matrices from 
the Tucker3 decomposition and the core array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reconst3(param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reconst3_+3A_param">param</code></td>
<td>

<p>The matrices of the row, column and tube components derived via the Tucker3 model.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The three-way reconstructed table of centred profiles. 
</p>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Eric J Beh, Ida Camminatiello.
</p>

<hr>
<h2 id='rstand3'>
Weighted centred three-way table for three-way non-symmetric correspondence analysis
</h2><span id='topic+rstand3'></span>

<h3>Description</h3>

<p>The function computes the three-way weighted centred contingency table to perform three-way
non-symmetric correspondence analysis with one response and two predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rstand3(x, std = T, ctr = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rstand3_+3A_x">x</code></td>
<td>

<p>The original three-way contingency table.
</p>
</td></tr>
<tr><td><code id="rstand3_+3A_std">std</code></td>
<td>

<p>The flag parameter for weighting the original table. If <code>std=F</code> the original contingency table is not weighted.
</p>
</td></tr>
<tr><td><code id="rstand3_+3A_ctr">ctr</code></td>
<td>

<p>The flag parameter for centering the original table. If  <code>ctr=F</code> the original array is not centered.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>xs</code></td>
<td>
<p>The weighted array with respect to the three associated metrics. It is used 
when <code>CA3variants="NSCA"</code> and represents the three-way weighted and centred column profile table.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Eric J Beh, Ida Camminatiello.
</p>

<hr>
<h2 id='selmod'>
Selecting the mode.</h2><span id='topic+selmod'></span>

<h3>Description</h3>

<p>Select the mode in which the column has to be sign reversed.
Below is an heuristic algorithm but a fully rational choice is hard to come by.
Maximal number of sign reversals = p+q+r-2, but this number can be much smaller.
Sign reverse a component, determine which if any of p, q and r is available for reversal.
If one of them is wholly positieve way  never choose it,  else if one is wholly negative  choose that one from  A, B, C respectively;
else if there is a component with a largest absolute value which is negative  choose that one, or the one from A,B,C in that order;
else choose the column of the longest mode; end if  FreeA, FreeB, FreeC = 0 component is not available; = 1 component is available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selmod(aptr, bptr, cptr, posptrA, negptrA, bigptrA, posptrB, negptrB, bigptrB, 
posptrC, negptrC, bigptrC, IA, IB, IC, I, J, K, p, q, r, longest)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selmod_+3A_aptr">aptr</code></td>
<td>

<p>The pointer to the first component matrix.
</p>
</td></tr>
<tr><td><code id="selmod_+3A_bptr">bptr</code></td>
<td>

<p>The pointer to the second component matrix.
</p>
</td></tr>
<tr><td><code id="selmod_+3A_cptr">cptr</code></td>
<td>

<p>The pointer to the third component matrix.
</p>
</td></tr>
<tr><td><code id="selmod_+3A_posptra">posptrA</code></td>
<td>

<p>The pointer to the positive component of the first component matrix.</p>
</td></tr>
<tr><td><code id="selmod_+3A_negptra">negptrA</code></td>
<td>

<p>The pointer to the negative component of the first component matrix.
</p>
</td></tr>
<tr><td><code id="selmod_+3A_bigptra">bigptrA</code></td>
<td>

<p>The pointer to the biggest component (a larger negative positive value than a positive one) of the first component matrix.</p>
</td></tr>
<tr><td><code id="selmod_+3A_posptrb">posptrB</code></td>
<td>

<p>The pointer to the positive component of the first component matrix.</p>
</td></tr>
<tr><td><code id="selmod_+3A_negptrb">negptrB</code></td>
<td>

<p>The pointer to the negative component of the second component matrix.
</p>
</td></tr>
<tr><td><code id="selmod_+3A_bigptrb">bigptrB</code></td>
<td>

<p>The pointer to the biggest component (a larger negative positive value than a positive one) of the second component matrix.</p>
</td></tr>
<tr><td><code id="selmod_+3A_posptrc">posptrC</code></td>
<td>

<p>The pointer to the positive component of the third component matrix.</p>
</td></tr>
<tr><td><code id="selmod_+3A_negptrc">negptrC</code></td>
<td>

<p>The pointer to the negative component of the third component matrix.
</p>
</td></tr>
<tr><td><code id="selmod_+3A_bigptrc">bigptrC</code></td>
<td>

<p>The pointer to the biggest component (a larger negative positive value than a positive one) of the third component matrix.</p>
</td></tr>
<tr><td><code id="selmod_+3A_ia">IA</code></td>
<td>

<p>The pointer to the columns of the first component matrix, given the pointer to an element in core. </p>
</td></tr>
<tr><td><code id="selmod_+3A_ib">IB</code></td>
<td>

<p>The pointer to the columns of the second component matrix, given the pointer to an element in core. </p>
</td></tr>
<tr><td><code id="selmod_+3A_ic">IC</code></td>
<td>

<p>The pointer to the columns of the third component matrix, given the pointer to an element in core. </p>
</td></tr>
<tr><td><code id="selmod_+3A_i">I</code></td>
<td>

<p>The row number of the three-way contingency table.</p>
</td></tr>
<tr><td><code id="selmod_+3A_j">J</code></td>
<td>

<p>The column number of the three-way contingency table.</p>
</td></tr>
<tr><td><code id="selmod_+3A_k">K</code></td>
<td>

<p>The tube number of the three-way contingency table.</p>
</td></tr>
<tr><td><code id="selmod_+3A_p">p</code></td>
<td>

<p>The dimension number of the first mode.</p>
</td></tr>
<tr><td><code id="selmod_+3A_q">q</code></td>
<td>

<p>The dimension number of the second mode.</p>
</td></tr>
<tr><td><code id="selmod_+3A_r">r</code></td>
<td>

<p>The dimension number of the third mode.</p>
</td></tr>
<tr><td><code id="selmod_+3A_longest">longest</code></td>
<td>

<p>The component matrix of the longest mode to change sign (when no special reason for selection could be found).</p>
</td></tr>
</table>


<h3>Value</h3>



<table>
<tr><td><code>success</code></td>
<td>
<p>The flag variable to indicate if one of the components has to be sign reversed.</p>
</td></tr>
<tr><td><code>chgmode</code></td>
<td>
<p>Select the mode (1, 2 or 3) in which the column has to be sign reversed.</p>
</td></tr>
<tr><td><code>chgcomp</code></td>
<td>
<p>The pointer to the columns of the component matrices (A, B or C) <br />
that are responsible for the value in the ordered core array.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rosaria Lombardo and Pieter M Kroonenberg.</p>


<h3>References</h3>

<p>Kroonenberg PM (1994) The TUCKALS line: a suite of programs for three-way data analysis. Computational Statistics and Data Analysis, 18, 73&ndash;96.
</p>

<hr>
<h2 id='signscore'>
Changing the sign of negative core values.
</h2><span id='topic+signscore'></span>

<h3>Description</h3>

<p>This function  makes the signs of the largest core elements positive <br />
to facilitate interpretation. The appropriate columns of the component matrices for inversion <br />
are determined and are reversed accordingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signscore(a, b, cc, I, J, K, p, q, r, core, IFIXA, IFIXB, IFIXC)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signscore_+3A_a">a</code></td>
<td>

<p>The first component matrix A.</p>
</td></tr>
<tr><td><code id="signscore_+3A_b">b</code></td>
<td>

<p>The second component matrix B.</p>
</td></tr>
<tr><td><code id="signscore_+3A_cc">cc</code></td>
<td>

<p>The third component matrix C.</p>
</td></tr>
<tr><td><code id="signscore_+3A_i">I</code></td>
<td>

<p>The row number of the first mode of the three-way contingency table.</p>
</td></tr>
<tr><td><code id="signscore_+3A_j">J</code></td>
<td>

<p>The column number of the second mode of the three-way contingency table.</p>
</td></tr>
<tr><td><code id="signscore_+3A_k">K</code></td>
<td>

<p>The tube number of the third mode of the three-way contingency table.</p>
</td></tr>
<tr><td><code id="signscore_+3A_p">p</code></td>
<td>

<p>The dimension number of the first mode.</p>
</td></tr>
<tr><td><code id="signscore_+3A_q">q</code></td>
<td>

<p>The dimension number of the second mode.</p>
</td></tr>
<tr><td><code id="signscore_+3A_r">r</code></td>
<td>

<p>The dimension number of the third mode.</p>
</td></tr>
<tr><td><code id="signscore_+3A_core">core</code></td>
<td>

<p>The core array (generalized singular values).</p>
</td></tr>
<tr><td><code id="signscore_+3A_ifixa">IFIXA</code></td>
<td>

<p>The flag parameter to indicate whether the first component (A) belongs to a fixed mode. <br />
Fixed modes should not have their signs changed.</p>
</td></tr>
<tr><td><code id="signscore_+3A_ifixb">IFIXB</code></td>
<td>

<p>The flag parameter to indicate whether the second component (B) belongs to a fixed mode. <br />
Fixed modes should not have their signs changed.</p>
</td></tr>
<tr><td><code id="signscore_+3A_ifixc">IFIXC</code></td>
<td>

<p>The flag parameter to indicate whether the third component (C) belongs to a fixed mode. <br />
Fixed modes should not have their signs changed.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>g</code></td>
<td>
<p>The core array.</p>
</td></tr>
<tr><td><code>gord</code></td>
<td>
<p>the core array ordered with respect to the largest values (descending order).</p>
</td></tr>
<tr><td><code>a</code></td>
<td>
<p>The first matrix of components.</p>
</td></tr>
<tr><td><code>aord</code></td>
<td>
<p>The ordered first matrix of the components.</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>The second matrix of the components.</p>
</td></tr>
<tr><td><code>bord</code></td>
<td>
<p>The ordered second matrix of the components.</p>
</td></tr>
<tr><td><code>cc</code></td>
<td>
<p>The third matrix of the components.</p>
</td></tr>
<tr><td><code>ccord</code></td>
<td>
<p>The ordered third matrix of the components.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rosaria Lombardo and Pieter M Kroonenberg.</p>


<h3>References</h3>

<p>Kroonenberg PM (1994) The TUCKALS line: a suite of programs for three-way data analysis. Computational Statistics and Data Analysis, 18, 73&ndash;96.
</p>

<hr>
<h2 id='simulabootsimple'>
Generation of parametric bootstrap samples
</h2><span id='topic+simulabootsimple'></span>

<h3>Description</h3>

<p>This function allows to generate parametric bootstrap samples in order to check the 
optimal dimension number of three-way correspondence analysis. The boostrap samples 
have the same marginal proportions and the total number of the original table.
The adopted sampling scheme is simple.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulabootsimple(Xtable,nboots=100,resamptype=1)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulabootsimple_+3A_xtable">Xtable</code></td>
<td>

<p>The three-way data array. It must be an <code>R</code> object array.
When non-symmetrical analysis for one response variable is performed, the response mode is the row variable.
</p>
</td></tr>
<tr><td><code id="simulabootsimple_+3A_nboots">nboots</code></td>
<td>

<p>The number of bootstrap samples to generate when <code>boots = T</code>. By default <code>nboots = 0</code>.
</p>
</td></tr>
<tr><td><code id="simulabootsimple_+3A_resamptype">resamptype</code></td>
<td>
<p>Set value of resamptype according to two methods: <code>resamptype=1</code> corresponds to multinomial distribution
and <code>resamptype=2</code> to Poisson distribution.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michel van de Velden, Rosaria Lombardo and Eric J Beh.
</p>


<h3>References</h3>

<p>Beh EJ and Lombardo R (2014) Correspondence Analysis, Theory, Practice and New Strategies. John Wiley &amp; Sons.
</p>

<hr>
<h2 id='simulabootstrat'>
Generation of parametric bootstrap samples
</h2><span id='topic+simulabootstrat'></span>

<h3>Description</h3>

<p>This function allows to generate parametric bootstrap samples in order to check the 
optimal dimension number of three-way correspondence analysis. The boostrap samples 
have the same marginal proportions and total number of the original table.
Te adopted sampling scheme is stratified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulabootstrat(Xtable,nboots=100,resamptype=1)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulabootstrat_+3A_xtable">Xtable</code></td>
<td>

<p>The three-way data array. It must be an <code>R</code> object array.
When non-symmetrical analysis for one response variable is performed, the response mode is the row variable.
</p>
</td></tr>
<tr><td><code id="simulabootstrat_+3A_nboots">nboots</code></td>
<td>

<p>The number of bootstrap samples to generate when <code>boots = T</code>. By default <code>nboots = 0</code>.
</p>
</td></tr>
<tr><td><code id="simulabootstrat_+3A_resamptype">resamptype</code></td>
<td>
<p>Set value of resamptype according to two methods: <code>resamptype=1</code> corresponds to multinomial distribution
and <code>resamptype=2</code> to Poisson distribution.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Michel van de Velden, Eric J Beh.
</p>


<h3>References</h3>

<p>Beh EJ and Lombardo R (2014) Correspondence Analysis, Theory, Practice and New Strategies. John Wiley &amp; Sons.
</p>

<hr>
<h2 id='srtcor'> Sort the core array

</h2><span id='topic+srtcor'></span>

<h3>Description</h3>

<p>This function sorts (a copy of) the core matrix and returns
CORPTR, an p*q*r integer array holding the pointers to the greatest
absolute values in CORE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>srtcor(core, p, q, r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="srtcor_+3A_core">core</code></td>
<td>

<p>The core array (generalized singular values).</p>
</td></tr>
<tr><td><code id="srtcor_+3A_p">p</code></td>
<td>

<p>The dimension number of the first mode.</p>
</td></tr>
<tr><td><code id="srtcor_+3A_q">q</code></td>
<td>

<p>The dimension number of the second mode.</p>
</td></tr>
<tr><td><code id="srtcor_+3A_r">r</code></td>
<td>

<p>The dimension number of the third mode.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>coreptr</code></td>
<td>
<p>The pointer to the ordered largest value of the core array.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rosaria Lombardo and Pieter M Kroonenberg.</p>


<h3>References</h3>

<p>Kroonenberg PM (1994) The TUCKALS line: a suite of programs for three-way data analysis. Computational Statistics and Data Analysis, 18, 73&ndash;96.
</p>

<hr>
<h2 id='standtab'>
Three-way centred column profile table for the three-way symmetric correspondence analysis
</h2><span id='topic+standtab'></span>

<h3>Description</h3>

<p>The function computes the three-way centred column profile table to perform 
three-way symmetric correspondence analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standtab(x, std = T, ctr = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standtab_+3A_x">x</code></td>
<td>

<p>The original three-way contingency table.
</p>
</td></tr>
<tr><td><code id="standtab_+3A_std">std</code></td>
<td>

<p>The flag parameter for weighting the original table. If F the original contingency table is not weighted.
</p>
</td></tr>
<tr><td><code id="standtab_+3A_ctr">ctr</code></td>
<td>

<p>The flag parameter for centering the original table. If F the original array is not centered.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Eric J Beh, Ida Camminatiello.
</p>


<h3>References</h3>

<p>Beh EJ and Lombardo R (2014) Correspondence Analysis, Theory, Practice and New Strategies. John Wiley &amp; Sons.
</p>

<hr>
<h2 id='step.g3'>
The core array derived via the Tucker3 model.
</h2><span id='topic+step.g3'></span>

<h3>Description</h3>

<p>The Tucker3 model involves the computation of principal components, which are derived for 
each of the three categorical variables, and of the core array which is akin to the generalised 
correlations between these components. The function <code>step.g3</code> computes the core array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step.g3(param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step.g3_+3A_param">param</code></td>
<td>

<p>The weighted three-way table and the matrices of the row, column and tube components 
derived via the Tuckals3 algorithm.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The core matrix whose the general element can be interpreted as a generalized singular value.
</p>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Eric J Beh, Ida Camminatiello.
</p>


<h3>References</h3>

<p>Beh EJ and Lombardo R (2014) Correspondence Analysis, Theory, Practice and New Strategies. John Wiley &amp; Sons.
</p>

<hr>
<h2 id='step.g3ordered'>
The core array derived via the Trivariate Moment Decomposition model.
</h2><span id='topic+step.g3ordered'></span>

<h3>Description</h3>

<p>The Trivariate Moment Decomposition model involves the computation of 
principal polynomial components, which are derived for each  of the three categorical
variables, and of the polynomial core array which is akin to the generalised correlations 
between these components. The function <code>step.g3ordered</code> computes the core array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step.g3ordered(param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step.g3ordered_+3A_param">param</code></td>
<td>

<p>The weighted three-way table and the matrices of the row, column and tube components 
derived via the Trivariate Moment Decomposition algorithm.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The core matrix whose the general element can be interpreted as a generalized singular value.
</p>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Eric J Beh, Ida Camminatiello.
</p>


<h3>References</h3>

<p>Beh EJ and Lombardo R (2014) Correspondence Analysis, Theory, Practice and New Strategies. John Wiley &amp; Sons.
</p>

<hr>
<h2 id='stepi3'>
Component matrices from the Tucker3 decomposition
</h2><span id='topic+stepi3'></span>

<h3>Description</h3>

<p>The function computes the component matrices from the Tuckals3 algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepi3(param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepi3_+3A_param">param</code></td>
<td>

<p>The weighted contingency table and the matrices of the row, column and tube components derived via 
the Tucker3 model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>newcomp3</code>, <code>stepi3</code>, <code>init3</code> and <code>step.g3</code> compute the 
component matrices and core array in the iterative steps of Tuckals3. They are all utilised from
the function <code>tucker</code>.
</p>


<h3>Value</h3>

<p>Component matrices from the Tucker3 decomposition.</p>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Eric J Beh, Ida Camminatiello.
</p>


<h3>References</h3>

<p>Beh EJ and Lombardo R (2014) Correspondence Analysis, Theory, Practice and New Strategies. John Wiley &amp; Sons.
</p>

<hr>
<h2 id='stepi3ordered'>
Component matrices from the Trivariate Moment Decomposition decomposition
</h2><span id='topic+stepi3ordered'></span>

<h3>Description</h3>

<p>The function computes the polynomial component matrices from the Emerson's recurrence formula for 
the ordered categorical variables of the analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepi3ordered(param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepi3ordered_+3A_param">param</code></td>
<td>

<p>The weighted contingency table and the matrices of the row, column and tube components derived via 
the Trivariate Moment Decomposition model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>newcomp3ordered</code>, <code>stepi3ordered</code>, <code>init3ordered</code> and 
<code>step.g3ordered</code> compute the polynomial component matrices and core array in the Trivariate Moment Decomposition. 
They are all utilised from the function <code>tuckerORDERED</code>.
</p>


<h3>Value</h3>

<p>Component matrices from the Trivariate Moment Decomposition decomposition.</p>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Eric J Beh, Ida Camminatiello.
</p>


<h3>References</h3>

<p>Beh EJ and Lombardo R (2014) Correspondence Analysis, Theory, Practice and New Strategies. John Wiley &amp; Sons.
</p>

<hr>
<h2 id='summary.CA3variants'>
Summary of three-way correspondence analysis results
</h2><span id='topic+summary.CA3variants'></span>

<h3>Description</h3>

<p>This function prints the summary of the  results of three-way symmetrical or non-symmetrical correspondence analysis. 
In particular it gives information on core and squared core and on the explained inertia when reducing dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CA3variants'
summary(object, digits=3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.CA3variants_+3A_object">object</code></td>
<td>

<p>The name of the output of the main function <code>CA3variants</code>.
</p>
</td></tr>
<tr><td><code id="summary.CA3variants_+3A_digits">digits</code></td>
<td>

<p>The input parameter specifying the digital number. By default, <code>digits = 3</code>.
</p>
</td></tr>
<tr><td><code id="summary.CA3variants_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of output returned in short depends on the kind of three-way correspondence analysis variant performed.
It gives  the core table, the squared core table, the explained inertia,
the total inertia and its proportion.
</p>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Eric J Beh and Michel van de Velden.
</p>


<h3>References</h3>

<p>Beh EJ and Lombardo R (2014) Correspondence Analysis, Theory, Practice and New Strategies. John Wiley &amp; Sons.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(happy)
ris.ca3&lt;-CA3variants(happy, dims= c(p=2,q=2,r=2), ca3type = "CA3") 
summary(ris.ca3)
ris.nsca3&lt;-CA3variants(happy, dims = c(p=2,q=2,r=2), ca3type = "NSCA3") 
summary(ris.nsca3)
ris.oca3&lt;-CA3variants(happy, dims = c(p=3,q=5,r=4), ca3type = "OCA3",norder=3) 
summary(ris.oca3)
ris.onsca3&lt;-CA3variants(happy, dims = c(p=3,q=5,r=4), ca3type = "ONSCA3",norder=3) 
summary(ris.onsca3)
</code></pre>

<hr>
<h2 id='tau3'>
Partition of the Marcotorchino three-way index
</h2><span id='topic+tau3'></span>

<h3>Description</h3>

<p>When the association among three categorical variables is asymmetric such that one variable is a 
logical response variable to the other variables, we recommend calculating the non-symmetrical 
three-way measure of predictability such as the Marcotorchino index (Marcotorchino, 1985).
The function <code>tau3</code> partitions the Marcotorchino statistic when, in <code>CA3variants</code>,
we set the parameter <code>ca3type = "NSCA3"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tau3(f3, digits = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tau3_+3A_f3">f3</code></td>
<td>

<p>Three-way contingency array given as an input parameter in <code>CA3variants</code>.
</p>
</td></tr>
<tr><td><code id="tau3_+3A_digits">digits</code></td>
<td>

<p>Number of decimal digits. By default digits=3.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>z</code></td>
<td>
<p>The partition of the Marcotorchino index into three two-way association terms and one three-way 
association term. It also shows the C statistic of each term, its degrees of freedom and p-value.</p>
</td></tr>
<tr><td><code>CM</code></td>
<td>
<p>the C statistic of the Marcotorchino index.</p>
</td></tr>
<tr><td><code>devt</code></td>
<td>
<p>The denominator of the Marcotorchino index.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Eric J Beh, Ida Camminatiello.
</p>


<h3>References</h3>

<p>Beh EJ and Lombardo R (2014) Correspondence Analysis, Theory, Practice and New Strategies. John Wiley &amp; Sons.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(happy)
tau3(happy, digits = 3)
</code></pre>

<hr>
<h2 id='tau3ordered'>
The partition of the Marcotorchino three-way index.
</h2><span id='topic+tau3ordered'></span>

<h3>Description</h3>

<p>When three categorical variables are symmetrically related, we can analyse the strength of
the association using the three-way Marcotorchino index.
The function chi3 partitions the Marcotorchino statistic using orthogonal polynomials
when, in <code>CA3variants</code>, we set the parameter <code>ca3type = "ONSCA3"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tau3ordered(f3, digits = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tau3ordered_+3A_f3">f3</code></td>
<td>

<p>The three-way contingency array given as an input parameter in <code>CA3variants</code>.
</p>
</td></tr>
<tr><td><code id="tau3ordered_+3A_digits">digits</code></td>
<td>

<p>The number of decimal digits. By default digits=3.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The partition of the Marcotorchino index into three two-way non-symmetrical association terms and one 
three-way association term. It also shows the polynomial componets of inertia, the 
percentage of explained inertia, the degrees of freedom and p-value of each term of the partition.
</p>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Eric J Beh.
</p>


<h3>References</h3>

<p>Beh EJ and Lombardo R (2014) Correspondence Analysis, Theory, Practice and New Strategies. John Wiley &amp; Sons.<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#data(olive)
tau3ordered(f3 = olive, digits = 3)
</code></pre>

<hr>
<h2 id='threewayboot'>
Generation of non-parametric bootstrap samples
</h2><span id='topic+threewayboot'></span>

<h3>Description</h3>

<p>This function allows to generate non-parametric bootstrap samples in order to check the 
optimal dimension number of three-way correspondence analysis. The boostrap samples 
have the same marginal proportions and the total number of the original table.
Do nboots bootstrap on the indicator matrix X (observations x (rows+cols+tubs) categories).
From a three-way contingency table, it makes the indicator using <code>makeindicator</code>.
The output is a list of three-way tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>threewayboot(Xdata,nboots=100)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="threewayboot_+3A_xdata">Xdata</code></td>
<td>

<p>The three-way contingency array. It must be an <code>R</code> object array.
</p>
</td></tr>
<tr><td><code id="threewayboot_+3A_nboots">nboots</code></td>
<td>

<p>The number of bootstrap samples to generate when <code>boots = T</code>. By default <code>nboots = 0</code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Michel van de Velden, Eric J Beh.
</p>


<h3>References</h3>

<p>Beh EJ and Lombardo R (2014) Correspondence Analysis, Theory, Practice and New Strategies. John Wiley &amp; Sons.
</p>

<hr>
<h2 id='tucker'>
Tucker3 decomposition of the three-way table.
</h2><span id='topic+tucker'></span>

<h3>Description</h3>

<p>The Tucker3 model, originally proposed by psychologist Ledyard R. Tucker, involves
the computation of principal components, which are derived for each of the three categorical 
variables, and of the core array which is akin to the generalised correlations between these components.
The function represents the heart of the Tuckals3 algorithm to perform the Tucker3 decomposition of the 
three-way array x.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tucker(x, p, q, r, test = 10^-6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tucker_+3A_x">x</code></td>
<td>

<p>The three-way contingency table.
</p>
</td></tr>
<tr><td><code id="tucker_+3A_p">p</code></td>
<td>

<p>The number of components of the first mode.
</p>
</td></tr>
<tr><td><code id="tucker_+3A_q">q</code></td>
<td>

<p>The number of components of the second mode.
</p>
</td></tr>
<tr><td><code id="tucker_+3A_r">r</code></td>
<td>

<p>The number of components of the third mode.
</p>
</td></tr>
<tr><td><code id="tucker_+3A_test">test</code></td>
<td>

<p>The treshold used in the algorithm.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>tucker</code> is utilised from the functions <code>ca3basic</code>, <code>nsca3basic</code> and 
<code>oca3basic</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>a</code></td>
<td>
<p>The final component derived from the Tucker3 decomposition for the first mode.</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>The final component derived from the Tucker3 decomposition for the second mode.</p>
</td></tr>
<tr><td><code>cc</code></td>
<td>
<p>The final component derived from the Tucker3 decomposition for the third mode.</p>
</td></tr>
<tr><td><code>g</code></td>
<td>
<p>The core array.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>The three-way contingency table.</p>
</td></tr>
<tr><td><code>cont</code></td>
<td>
<p>The number of iterations that are required for the Tucker3 algorithm to converge.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Eric J Beh.
</p>


<h3>References</h3>

<p>Kroonenberg PM (1994) The TUCKALS line: a suite of programs for three-way data analysis. Computational Statistics and Data Analysis, 18, 73&ndash;96.
</p>

<hr>
<h2 id='tuckerORDERED'>
Trivariate moment decomposition of the three-way table.
</h2><span id='topic+tuckerORDERED'></span>

<h3>Description</h3>

<p>The Trivariate moment decomposition (TMD) represents the heart of a new algorithm to perform the 
decomposition of the three-way ordered contingency tables. It is based on the orthogonal
polynomials (Emerson 1968) computed for each categorical ordered variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tuckerORDERED(x, p, q, r, test = 10^-6,xi, norder=3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tuckerORDERED_+3A_x">x</code></td>
<td>

<p>The three-way contingency table.
</p>
</td></tr>
<tr><td><code id="tuckerORDERED_+3A_p">p</code></td>
<td>

<p>The number of components of the first mode.
</p>
</td></tr>
<tr><td><code id="tuckerORDERED_+3A_q">q</code></td>
<td>

<p>The number of components of the second mode.
</p>
</td></tr>
<tr><td><code id="tuckerORDERED_+3A_r">r</code></td>
<td>

<p>The number of components of the third mode.
</p>
</td></tr>
<tr><td><code id="tuckerORDERED_+3A_test">test</code></td>
<td>

<p>The treshold used in the algorithm.
</p>
</td></tr>
<tr><td><code id="tuckerORDERED_+3A_xi">xi</code></td>
<td>
<p>The original three-way contingency table.</p>
</td></tr>
<tr><td><code id="tuckerORDERED_+3A_norder">norder</code></td>
<td>

<p>The number of ordered variables.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>tuckerORDERED</code> is utilised from the function <code>oca3basic</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>a</code></td>
<td>
<p>The final component derived from the TMD decomposition for the first mode.</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>The final component derived from the TMD decomposition for the second mode.</p>
</td></tr>
<tr><td><code>cc</code></td>
<td>
<p>The final component derived from the TMD decomposition for the third mode.</p>
</td></tr>
<tr><td><code>g</code></td>
<td>
<p>The core array.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>The three-way contingency table.</p>
</td></tr>
<tr><td><code>cont</code></td>
<td>
<p>The number of iterations that are required for the TMD algorithm to converge. If all variables are
ordered, the convergence is reached in one step, differently if we have mixed variables. Indeed,
the decmposition will become hybrid, a mix of TMD algorithm and Tuckals3 algorithm.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Eric J Beh.
</p>


<h3>References</h3>

<p>Emerson PL (1968)  Numerical construction of orthogonal polynomials from a general recurrence formula. Biometrics, 24 (3), 695-701.<br />
Lombardo R Beh EJ (2016) Variants of Simple Correspondence Analysis. The R Journal, 8 (2), 167&ndash;184.<br />
Lombardo R Beh EJ and Kroonenberg PM (2016) Modelling Trends in Ordered Correspondence Analysis Using Orthogonal Polynomials. Psychometrika, 81(2), 325&ndash;349.
</p>

<hr>
<h2 id='tunelocal'>
Dimension selection for three-dimensional correspondence biplot using convex hull.
</h2><span id='topic+tunelocal'></span>

<h3>Description</h3>

<p>This function allows to select the optimal dimension number 
for correspondence biplot, given the set of possible dimension combination
of the original data.  It determines the models that are located on the boundary of the convex hull 
and selects an optimal model by means of the scree test values (st).
For exploring, it is also possible to check the optimal model dimension by using
boostrap samples which have the same marginal proportions and the total number
of the original table. When the input parameter <code>boots = T</code>, it does bootstrap sampling. 
There are three kinds of possible bootstrap sampling. 
When <code>boottype = "bootnp"</code> it performs a non parametric bootstrap sampling.
When <code>boottype = "bootpsimple"</code> it performs a parametric simple bootstrap sampling.
When <code>boottype = "bootpstrat"</code>, it performs a parametric stratified bootstrap sampling.  
In particular in case of parametric bootstrap types,
when <code>resamptype=1</code> it considers a multinomial distribution, and when <code>resamptype = 2</code> 
it  considers a poisson distribution. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tunelocal(Xdata, ca3type = "CA3", resp = "row", norder = 3, digits = 3, boots = FALSE,  
nboots = 0, boottype= "bootpsimple", resamptype = 1, PercentageFit = 0.01) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tunelocal_+3A_xdata">Xdata</code></td>
<td>

<p>The three-way data. It can be a <code>R</code> object array or raw data (n individuals by three categorical variables, for an example,
see <code>museum</code> data).
When a three-way non-symmetrical variant is performed, by default, the response variable is the row variable when an array is given, or 
the first of three columns when a raw data set is given. 
For changing, consider the parameter <code>resp = "col"</code> or  <code>resp = "tube"</code>.
</p>
</td></tr>
<tr><td><code id="tunelocal_+3A_ca3type">ca3type</code></td>
<td>

<p>The specification of the analysis to be performed. 
If <code>ca3type = "CA3"</code>, then a three-way (symmetrical) correspondence analysis will be performed 
(default analysis). 
If <code>ca3type = "NSCA3"</code>, then three-way non-symmetrical correspondence analysis  will be performed.
If <code>ca3type = "OCA3"</code>, then ordered three-way symmetrical correspondence analysis  will be performed.
If <code>ca3type = "ONSCA3"</code>, then ordered three-way non-symmetrical correspondence analysis  will be performed.
</p>
</td></tr>
<tr><td><code id="tunelocal_+3A_resp">resp</code></td>
<td>

<p>The input parameter for specifying in non-symmetrical three-way correspondence analysis variants (<code>ca3type = "NSCA3"</code> 
and <code>ca3type = "ONSCA3"</code>) what is the response variable (logically antecendent to the others). 
By default <code>resp = "row"</code>, but it could be the column variable <code>resp = "col"</code> or the tube
variable <code>resp = "tube"</code>.  
</p>
</td></tr>
<tr><td><code id="tunelocal_+3A_norder">norder</code></td>
<td>

<p>The input parameter for specifying the number of ordered variable when <code>ca3type = "OCA3"</code> or <code>ca3type = "ONSCA3"</code>.
</p>
</td></tr>
<tr><td><code id="tunelocal_+3A_digits">digits</code></td>
<td>

<p>The input parameter specifying the digital number. By default, <code>digits = 3</code>.
</p>
</td></tr>
<tr><td><code id="tunelocal_+3A_boots">boots</code></td>
<td>

<p>The flag parameter to perform the search of optimal dimensions using
bootstrap samples. By defaults, <code>boots = FALSE</code>.</p>
</td></tr>
<tr><td><code id="tunelocal_+3A_nboots">nboots</code></td>
<td>

<p>The number of bootstrap samples to generate when <code>boots = TRUE</code>. Note that when <code>boots = FALSE</code>,<br />
by default <code>nboots = 0</code>, but when <code>boots = TRUE</code>, by default <code>nboots = 100</code>. 
</p>
</td></tr>
<tr><td><code id="tunelocal_+3A_boottype">boottype</code></td>
<td>
<p>The specification of the kind of bootstrap sampling to be performed. 
If <code>boottype = "bootpsimple"</code>, then a parametric bootstrap using a simple sampling scheme will 
be performed (default sampling).
If <code>boottype = "bootpstrat"</code>, then a parametric bootstrap using a stratified sampling scheme will 
be performed.
If <code>boottype = "bootnp"</code>, then a non-parametric bootstrap using a simple sampling scheme will 
be performed.</p>
</td></tr>
<tr><td><code id="tunelocal_+3A_resamptype">resamptype</code></td>
<td>
<p>When the kind of bootstrap is parametric you can set the data distribution using 
the input parameter <code>resamptype</code> according to two distribution: <code>resamptype=1</code> corresponds 
to multinomial distribution and <code>resamptype=2</code> to Poisson distribution.</p>
</td></tr>
<tr><td><code id="tunelocal_+3A_percentagefit">PercentageFit</code></td>
<td>
<p>Required proportion of increase in fit of a more complex model. By default, 
<code>PercentageFit  =  0.01</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>




<table>
<tr><td><code>output1</code></td>
<td>
<p>Chi-square criterion and df of models on the convex hull. 
It gives the criterion values of the models that are located on the boundary of the convex hull 
and selects the optimal model by means of the scree test values (st).
When using <code>boots = FALSE</code>,  it gives the set of possible dimension combination
of the original data using only the original data array.
When using <code>boots = TRUE</code>,  it gives the set of possible dimension combination
of the original data using bootstrapped data arrays.
</p>
</td></tr>





</table>


<h3>Author(s)</h3>

<p>Rosaria Lombardo, Michel van de Velden, Eric J Beh.
</p>


<h3>References</h3>

<p>Wilderjans T F, Ceulemans E, and Meers K (2013) CHull: A generic convex hull based model
selection method. Behavior Research Methods, 45, 1-15.<br />
Ceulemans E, and Kiers H A L (2006) Selecting among three-mode principal component models
of different types and complexities: A numerical convex hull based method. British Journal of
Mathematical &amp; Statistical Psychology, 59, 133-150.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tunelocal(Xdata = happy, ca3type = "CA3")



</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
