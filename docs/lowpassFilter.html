<!DOCTYPE html><html><head><title>Help for package lowpassFilter</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lowpassFilter}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#convolve'><p>Time discrete convolution</p></a></li>
<li><a href='#deconvolve'><p>Deconvolution of a single jump / isolated peak</p></a></li>
<li><a href='#helpFunctionsFilter'><p>Convolved piecewise constant signals</p></a></li>
<li><a href='#lowpassFilter'><p>Lowpass filtering</p></a></li>
<li><a href='#lowpassFilter-package'><p>Lowpass Filtering</p></a></li>
<li><a href='#randomGeneration'><p>Random number generation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Lowpass Filtering</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.3), stats, methods</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>Description:</td>
<td>Creates lowpass filters which are commonly used in ion channel recordings. It supports generation of random numbers that are filtered, i.e. follow a model for ion channel recordings, see &lt;<a href="https://doi.org/10.1109%2FTNB.2018.2845126">doi:10.1109/TNB.2018.2845126</a>&gt;. Furthermore, time continuous convolutions of piecewise constant signals with the kernel of lowpass filters can be computed.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-29 13:27:18 UTC; pein</td>
</tr>
<tr>
<td>Author:</td>
<td>Pein Florian [aut, cre],
  Thomas Hotz [ctb],
  Inder Tecuapetla-Gómez [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pein Florian &lt;f.pein@lancaster.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-29 18:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='convolve'>Time discrete convolution</h2><span id='topic+convolve'></span><span id='topic+.convolve'></span>

<h3>Description</h3>

<p>For developers only; computes a time discrete convolution.</p>


<h3>Usage</h3>

<pre><code class='language-R'>.convolve(val, kern)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convolve_+3A_val">val</code></td>
<td>
<p>a numeric vector giving the values</p>
</td></tr>
<tr><td><code id="convolve_+3A_kern">kern</code></td>
<td>
<p>a numeric vector giving the time discrete kernel</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector giving the convolution.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lowpassFilter">lowpassFilter</a></code></p>

<hr>
<h2 id='deconvolve'>Deconvolution of a single jump / isolated peak</h2><span id='topic+deconvolve'></span><span id='topic+.deconvolveJump'></span><span id='topic+.deconvolvePeak'></span><span id='topic+deconvolveJump'></span><span id='topic+deconvolvePeak'></span>

<h3>Description</h3>

<p>For developers only; computes the deconvolution of a single jump or an isolated peak assuming that the observations are lowpass filtered. More details are given in <cite>(Pein et al., 2018)</cite>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>.deconvolveJump(grid, observations, time, leftValue, rightValue,
                typeFilter, inputFilter, covariances) 
.deconvolvePeak(gridLeft, gridRight, observations, time, leftValue, rightValue,
                typeFilter, inputFilter, covariances, tolerance)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deconvolve_+3A_grid">grid</code>, <code id="deconvolve_+3A_gridleft">gridLeft</code>, <code id="deconvolve_+3A_gridright">gridRight</code></td>
<td>
<p>numeric vectors giving the potential time points of the single jump, of the left and right jump points of the peak, respectively</p>
</td></tr>
<tr><td><code id="deconvolve_+3A_observations">observations</code></td>
<td>
<p>a numeric vector giving the observed data</p>
</td></tr>
<tr><td><code id="deconvolve_+3A_time">time</code></td>
<td>
<p>a numeric vector of length <code>length(observations)</code> giving the time points at which the <code>observations</code> are observed</p>
</td></tr>
<tr><td><code id="deconvolve_+3A_leftvalue">leftValue</code>, <code id="deconvolve_+3A_rightvalue">rightValue</code></td>
<td>
<p>single numerics giving the value (conductance level) before and after the jump / peak, respectively</p>
</td></tr>
<tr><td><code id="deconvolve_+3A_typefilter">typeFilter</code>, <code id="deconvolve_+3A_inputfilter">inputFilter</code></td>
<td>
<p>a description of the assumed lowpass filter, usually computed by <code><a href="#topic+lowpassFilter">lowpassFilter</a></code></p>
</td></tr>
<tr><td><code id="deconvolve_+3A_covariances">covariances</code></td>
<td>
<p>a numeric vector giving the (regularized) covariances of the observations</p>
</td></tr>
<tr><td><code id="deconvolve_+3A_tolerance">tolerance</code></td>
<td>
<p>a single numeric giving a tolerance for the decision whether the left jump point is smaller than the right jump point</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>.deconvolveJump</code> a single numeric giving the jump point. For <code>.deconvolvePeak</code> a list containing the entries <code>left</code>, <code>right</code> and <code>value</code> giving the left and right jump point and the value of the peak, respectively.
</p>


<h3>References</h3>

<p>Pein, F., Tecuapetla-Gómez, I., Schütte, O., Steinem, C., Munk, A. (2018) Fully-automatic multiresolution idealization for filtered ion channel recordings: flickering event detection. IEEE Trans. Nanobioscience, 17(3):300-320.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lowpassFilter">lowpassFilter</a></code></p>

<hr>
<h2 id='helpFunctionsFilter'>Convolved piecewise constant signals</h2><span id='topic+getConvolution'></span><span id='topic+getSignalJump'></span><span id='topic+getConvolutionJump'></span><span id='topic+getSignalPeak'></span><span id='topic+getConvolutionPeak'></span>

<h3>Description</h3>

<p>Creates piecewise constant signals with a single jump / peak. Computes the convolution of piecewise constant signals with the kernel of a lowpass filter.</p>


<h3>Usage</h3>

<pre><code class='language-R'>getConvolution(t, stepfun, filter, truncated = TRUE)
getSignalJump(t, cp, leftValue, rightValue)
getConvolutionJump(t, cp, leftValue, rightValue, filter, truncated = TRUE)
getSignalPeak(t, cp1, cp2, value, leftValue, rightValue) 
getConvolutionPeak(t, cp1, cp2, value, leftValue, rightValue, filter, truncated = TRUE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="helpFunctionsFilter_+3A_t">t</code></td>
<td>
<p>a numeric vector giving the time points at which the signal / convolution should be computed</p>
</td></tr>
<tr><td><code id="helpFunctionsFilter_+3A_stepfun">stepfun</code></td>
<td>
<p>specification of the piecewise constant signal, i.e. a <code><a href="base.html#topic+data.frame">data.frame</a></code> with named arguments <code>leftEnd</code>, <code>rightEnd</code> and <code>value</code> giving the start and end points of the constant segments and the values on the segments, for instance an object of class <code>stepblock</code> as available by the package 'stepR'</p>
</td></tr>
<tr><td><code id="helpFunctionsFilter_+3A_cp">cp</code>, <code id="helpFunctionsFilter_+3A_cp1">cp1</code>, <code id="helpFunctionsFilter_+3A_cp2">cp2</code></td>
<td>
<p>a single numeric giving the location of the single, first and second jump point, respectively</p>
</td></tr>
<tr><td><code id="helpFunctionsFilter_+3A_value">value</code>, <code id="helpFunctionsFilter_+3A_leftvalue">leftValue</code>, <code id="helpFunctionsFilter_+3A_rightvalue">rightValue</code></td>
<td>
<p>a single numeric giving the function value at, before and after the peak / jump, respectively</p>
</td></tr>
<tr><td><code id="helpFunctionsFilter_+3A_filter">filter</code></td>
<td>
<p>an object of class <code><a href="#topic+lowpassFilter">lowpassFilter</a></code> giving the analogue lowpass filter</p>
</td></tr>
<tr><td><code id="helpFunctionsFilter_+3A_truncated">truncated</code></td>
<td>
<p>a single logical (not NA) indicating whether the signal should be convolved with the truncated or the untruncated filter kernel</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric of length <code>length(t)</code> giving the signal / convolution at time points <code>t</code>
</p>


<h3>References</h3>

<p>Pein, F., Bartsch, A., Steinem, C., and Munk, A. (2020) Heterogeneous idealization of ion channel recordings - Open channel noise. Submitted.
</p>
<p>Pein, F., Tecuapetla-Gómez, I., Schütte, O., Steinem, C., Munk, A. (2018) Fully-automatic multiresolution idealization for filtered ion channel recordings: flickering event detection. IEEE Trans. Nanobioscience, 17(3):300-320.
</p>
<p>Pein, F. (2017) Heterogeneous Multiscale Change-Point Inference and its Application to Ion Channel Recordings.
PhD thesis, Georg-August-Universität Göttingen. http://hdl.handle.net/11858/00-1735-0000-002E-E34A-7.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lowpassFilter">lowpassFilter</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># creating and plotting a signal with a single jump at 0 from 0 to 1
time &lt;- seq(-2, 13, 0.01)
signal &lt;- getSignalJump(time, 0, 0, 1)
plot(time, signal, type = "l")

# setting up the filter
filter &lt;- lowpassFilter(param = list(pole = 4, cutoff = 0.1))

# convolution with the truncated filter
convolution &lt;- getConvolutionJump(time, 0, 0, 1, filter)
lines(time, convolution, col = "red")

# without truncating the filter, looks almost equal
convolution &lt;- getConvolutionJump(time, 0, 0, 1, filter, truncated = FALSE)
lines(time, convolution, col = "blue")


# creating and plotting a signal with a single peak with jumps
# at 0 and at 3 from 0 to 1 to 0
time &lt;- seq(-2, 16, 0.01)
signal &lt;- getSignalPeak(time, 0, 3, 1, 0, 0)
plot(time, signal, type = "l")

# convolution with the truncated filter
convolution &lt;- getConvolutionPeak(time, 0, 3, 1, 0, 0, filter)
lines(time, convolution, col = "red")

# without truncating the filter, looks almost equal
convolution &lt;- getConvolutionPeak(time, 0, 3, 1, 0, 0, filter, truncated = FALSE)
lines(time, convolution, col = "blue")


# doing the same with getConvolution
# signal can also be an object of class stepblock instead,
# e.g. constructed by stepR::stepblock
signal &lt;- data.frame(value = c(0, 1, 0), leftEnd = c(-2, 0, 3), rightEnd = c(0, 3, 16))

convolution &lt;- getConvolution(time, signal, filter)
lines(time, convolution, col = "red")

convolution &lt;- getConvolution(time, signal, filter, truncated = FALSE)
lines(time, convolution, col = "blue")


# more complicated signal
time &lt;- seq(-2, 21, 0.01)
signal &lt;- data.frame(value = c(0, 10, 0, 50, 0), leftEnd = c(-2, 0, 3, 6, 8),
                     rightEnd = c(0, 3, 6, 8, 21))

convolution &lt;- getConvolution(time, signal, filter)
plot(time, convolution, col = "red", type = "l")

convolution &lt;- getConvolution(time, signal, filter, truncated = FALSE)
lines(time, convolution, col = "blue")
</code></pre>

<hr>
<h2 id='lowpassFilter'>Lowpass filtering</h2><span id='topic+lowpassFilter'></span><span id='topic+print.lowpassFilter'></span>

<h3>Description</h3>

<p>Creates a lowpass filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lowpassFilter(type = c("bessel"), param, sr = 1, len = NULL, shift = 0.5)
## S3 method for class 'lowpassFilter'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lowpassFilter_+3A_type">type</code></td>
<td>
<p>a string specifying the type of the filter, currently only Bessel filters are supported</p>
</td></tr>
<tr><td><code id="lowpassFilter_+3A_param">param</code></td>
<td>
<p>a <code><a href="base.html#topic+list">list</a></code> specifying the parameters of the filter depending on <code>type</code>. For <code>"bessel"</code> the entries <code>pole</code> and <code>cutoff</code> have to be specified and no other named entries are allowed. <code>pole</code> has to be a single integer giving the number of poles (order). <code>cutoff</code> has to be a single positive numeric not larger than <code>1</code> giving the normalized cutoff frequency, i.e. the cutoff frequency (in the temporal domain) of the filter divided by the sampling rate</p>
</td></tr>
<tr><td><code id="lowpassFilter_+3A_sr">sr</code></td>
<td>
<p>a single numeric giving the sampling rate</p>
</td></tr>
<tr><td><code id="lowpassFilter_+3A_len">len</code></td>
<td>
<p>a single integer giving the filter length of the truncated and digitised filter, see <cite>Value</cite> for more details. By default (<code>NULL</code>) it is chosen such that the autocorrelation function is below <code>1e-3</code> at <code>len / sr</code> and at all lager lags <code>(len + i) / sr</code>, with <code>i</code> a positive integer</p>
</td></tr>
<tr><td><code id="lowpassFilter_+3A_shift">shift</code></td>
<td>
<p>a single numeric between <code>0</code> and <code>1</code> giving a shift for the digitised filter, i.e. kernel and step are obtained by evaluating the corresponding functions at <code>(0:len + shift) / sr</code></p>
</td></tr>
<tr><td><code id="lowpassFilter_+3A_x">x</code></td>
<td>
<p>the object</p>
</td></tr>
<tr><td><code id="lowpassFilter_+3A_...">...</code></td>
<td>
<p>for generic methods only</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of <code><a href="base.html#topic+class">class</a></code> <code>lowpassFilter</code>, i.e. a <code><a href="base.html#topic+list">list</a></code> that contains
</p>

<dl>
<dt><code>"type"</code>, <code>"param"</code>, <code>"sr"</code>, <code>"len"</code></dt><dd><p>the corresponding arguments</p>
</dd>
<dt><code>"kernfun"</code></dt><dd><p>the kernel function of the filter, obtained as the Laplace transform of the corresponding transfer function</p>
</dd>
<dt><code>"stepfun"</code></dt><dd><p>the step-response of the filter, i.e. the antiderivative of the filter kernel</p>
</dd>
<dt><code>"acfun"</code></dt><dd><p>the autocorrelation function, i.e. the convolution of the filter kernel with itself</p>
</dd>
<dt><code>"acAntiderivative"</code></dt><dd><p>the antiderivative of the autocorrelation function</p>
</dd>
<dt><code>"truncatedKernfun"</code></dt><dd><p>the kernel function of the at <code>len / sr</code> truncated filter, i.e. <code>kernfun</code> truncated and rescaled such that the new kernel still integrates to <code>1</code></p>
</dd>
<dt><code>"truncatedStepfun"</code></dt><dd><p>the step-response of the at <code>len / sr</code> truncated filter, i.e. the antiderivative of the kernel of the truncated filter</p>
</dd>
<dt><code>"truncatedAcfun"</code></dt><dd><p>the autocorrelation function of the at <code>len / sr</code> truncated filter, i.e. the convolution of the kernel of the truncated filter with itself</p>
</dd>
<dt><code>"truncatedAcAntiderivative"</code></dt><dd><p>the antiderivative of the autocorrelation function of the at <code>len / sr</code> truncated filter</p>
</dd>
<dt><code>"kern"</code></dt><dd><p>the digitised filter kernel normalised to one, i.e. <code>kernfun((0:len + shift) / sr) / sum(kernfun((0:len + shift) / sr))</code></p>
</dd>
<dt><code>"step"</code></dt><dd><p>the digitised step-response of the filter, i.e. <code>stepfun((0:len + shift) / sr)</code></p>
</dd>
<dt><code>"acf"</code></dt><dd><p>the discrete autocorrelation, i.e. <code>acfun(0:len / sr)</code></p>
</dd>
<dt><code>"jump"</code></dt><dd><p>the last index of the left half of the filter, i.e. <code>min(which(ret$step &gt;= 0.5)) - 1L</code>, it indicates how much a jump is shifted in time by a convolution of the signal with the digitised kernel of the lowpassfilter; if all values are below <code>0.5</code>, <code>len</code> is returned with a <code>warning</code></p>
</dd>
<dt><code>"number"</code></dt><dd><p>for developers; an integer indicating the type of the filter</p>
</dd>
<dt><code>"list"</code></dt><dd><p>for developers; a list containing precomputed quantities to recreate the filter in C++</p>
</dd>
</dl>



<h3>References</h3>

<p>Pein, F., Bartsch, A., Steinem, C., and Munk, A. (2020) Heterogeneous idealization of ion channel recordings - Open channel noise. Submitted.
</p>
<p>Pein, F., Tecuapetla-Gómez, I., Schütte, O., Steinem, C., Munk, A. (2018) Fully-automatic multiresolution idealization for filtered ion channel recordings: flickering event detection. IEEE Trans. Nanobioscience, 17(3):300-320.
</p>
<p>Pein, F. (2017) Heterogeneous Multiscale Change-Point Inference and its Application to Ion Channel Recordings.
PhD thesis, Georg-August-Universität Göttingen. http://hdl.handle.net/11858/00-1735-0000-002E-E34A-7.
</p>
<p>Hotz, T., Schütte, O., Sieling, H., Polupanow, T., Diederichsen, U., Steinem, C., and Munk, A. (2013) Idealizing
ion channel recordings by a jump segmentation multiresolution filter. IEEE Trans. Nanobioscience, 12(4):376-386.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+filter">filter</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>filter &lt;- lowpassFilter(type = "bessel", param = list(pole = 4L, cutoff = 1e3 / 1e4),
                        sr = 1e4)

# filter kernel, truncated version
plot(filter$kernfun, xlim = c(0, 20 / filter$sr))
t &lt;- seq(0, 20 / filter$sr, 0.01 / filter$sr)
# truncated version looks very similar
lines(t, filter$truncatedKernfun(t), col = "red")

# filter$len (== 11) is chosen automatically
# this ensures that filter$acf &lt; 1e-3 for this lag and at all larger lags
plot(filter$acfun, xlim = c(0, 20 / filter$sr), ylim = c(-0.003, 0.003))
abline(h = 0.001, lty = "22")
abline(h = -0.001, lty = "22")

abline(v = (filter$len - 1L) / filter$sr, col = "grey")
abline(v = filter$len / filter$sr, col = "red")

# filter with sr == 1
filter &lt;- lowpassFilter(type = "bessel", param = list(pole = 4L, cutoff = 1e3 / 1e4))

# filter kernel and its truncated version
plot(filter$kernfun, xlim = c(0, 20 / filter$sr))
t &lt;- seq(0, 20 / filter$sr, 0.01 / filter$sr)
# truncated version looks very similar
lines(t, filter$truncatedKernfun(t), col = "red")
# digitised filter
points((0:filter$len + 0.5) / filter$sr, filter$kern, col = "red", pch = 16)

# without a shift
filter &lt;- lowpassFilter(type = "bessel", param = list(pole = 4L, cutoff = 1e3 / 1e4),
                        shift = 0)
# filter$kern starts with zero
points(0:filter$len / filter$sr, filter$kern, col = "blue", pch = 16)

# much shorter filter
filter &lt;- lowpassFilter(type = "bessel", param = list(pole = 4L, cutoff = 1e3 / 1e4),
                        len = 4L)
points((0:filter$len + 0.5) / filter$sr, filter$kern, col = "darkgreen", pch = 16)
</code></pre>

<hr>
<h2 id='lowpassFilter-package'>Lowpass Filtering</h2><span id='topic+lowpassFilter-package'></span>

<h3>Description</h3>

<p>Creates lowpass filters and offers further functionalities around them. Lowpass filters are commonly used in ion channel recordings.
</p>


<h3>Details</h3>

<p>The main function of this package is <code><a href="#topic+lowpassFilter">lowpassFilter</a></code> which creates lowpass filters, currently only Bessel filters are supported. <code><a href="#topic+randomGeneration">randomGeneration</a></code> and <code><a href="#topic+randomGenerationMA">randomGenerationMA</a></code> allow to generate random numbers that are filtered, i.e. follow a model for ion channel recordings, see <cite>(Pein et al., 2018, 2020)</cite>. <code><a href="#topic+getConvolution">getConvolution</a></code>, <code><a href="#topic+getConvolutionJump">getConvolutionJump</a></code>, and <code><a href="#topic+getConvolutionPeak">getConvolutionPeak</a></code> allow to compute the convolution of a signal with the kernel of a lowpass filter.
</p>


<h3>References</h3>

<p>Pein, F., Bartsch, A., Steinem, C., and Munk, A. (2020) Heterogeneous idealization of ion channel recordings - Open channel noise. Submitted.
</p>
<p>Pein, F., Tecuapetla-Gómez, I., Schütte, O., Steinem, C., Munk, A. (2018) Fully-automatic multiresolution idealization for filtered ion channel recordings: flickering event detection. IEEE Trans. Nanobioscience, 17(3):300-320.
</p>
<p>Pein, F. (2017) Heterogeneous Multiscale Change-Point Inference and its Application to Ion Channel Recordings.
PhD thesis, Georg-August-Universität Göttingen. http://hdl.handle.net/11858/00-1735-0000-002E-E34A-7.
</p>
<p>Hotz, T., Schütte, O., Sieling, H., Polupanow, T., Diederichsen, U., Steinem, C., and Munk, A. (2013) Idealizing
ion channel recordings by a jump segmentation multiresolution filter. IEEE Trans. Nanobioscience, 12(4):376-386.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lowpassFilter">lowpassFilter</a></code>, <code><a href="#topic+randomGeneration">randomGeneration</a></code>, <code><a href="#topic+randomGenerationMA">randomGenerationMA</a></code>, <code><a href="#topic+getConvolution">getConvolution</a></code>, <code><a href="#topic+getConvolutionJump">getConvolutionJump</a></code>, <code><a href="#topic+getConvolutionPeak">getConvolutionPeak</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># creates a lowpass filter
filter &lt;- lowpassFilter(type = "bessel", param = list(pole = 4, cutoff = 0.1), sr = 1e4)
time &lt;- 1:4000 / filter$sr

# creates a piecewise constant signal with a single peak
stepfun &lt;- getSignalPeak(time, cp1 = 0.2, cp2 = 0.2 + 3 / filter$sr, 
                         value = 20, leftValue = 40, rightValue = 40)

# computes the convolution of the signal with the kernel of the lowpass filter
signal &lt;- getConvolutionPeak(time, cp1 = 0.2, cp2 = 0.2 + 3 / filter$sr, 
                             value = 20, leftValue = 40, rightValue = 40,
                             filter = filter)

# generates random numbers that are filtered                             
data &lt;- randomGenerationMA(n = 4000, filter = filter, signal = signal, noise = 1.4)

# generated data
plot(time, data, pch = 16)

# zoom into the single peak
plot(time, data, pch = 16, xlim = c(0.199, 0.202), ylim = c(19, 45))
lines(time, stepfun, col = "blue", type = "s", lwd = 2)
lines(time, signal, col = "red", lwd = 2)

# use of data randomGeneration instead
data &lt;- randomGeneration(n = 4000, filter = filter, signal = signal, noise = 1.4)

# similar result
plot(time, data, pch = 16, xlim = c(0.199, 0.202), ylim = c(19, 45))
lines(time, stepfun, col = "blue", type = "s", lwd = 2)
lines(time, signal, col = "red", lwd = 2)
</code></pre>

<hr>
<h2 id='randomGeneration'>Random number generation</h2><span id='topic+randomGeneration'></span><span id='topic+randomGenerationMA'></span>

<h3>Description</h3>

<p>Generate random numbers that are filtered. Both, signal and noise, are convolved with the given lowpass filter, see details. Can be used to generate synthetic data resembling ion channel recordings, please see <cite>(Pein et al., 2018, 2020)</cite> for the exact models.</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomGeneration(n, filter, signal = 0, noise = 1, oversampling = 100L, seed = n,
                 startTime = 0, truncated = TRUE)
randomGenerationMA(n, filter, signal = 0, noise = 1, seed = n,
                   startTime = 0, truncated = TRUE)                 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randomGeneration_+3A_n">n</code></td>
<td>
<p>a single positive integer giving the number of observations that should be generated</p>
</td></tr>
<tr><td><code id="randomGeneration_+3A_filter">filter</code></td>
<td>
<p>an object of class <code><a href="#topic+lowpassFilter">lowpassFilter</a></code> giving the analogue lowpass filter</p>
</td></tr>
<tr><td><code id="randomGeneration_+3A_signal">signal</code></td>
<td>
<p>either a numeric of length 1 or of length <code>n</code> giving the convolved signal, i.e. the mean of the random numbers, or an object that can be passed to <code>getConvolution</code>, i.e. an object of class <code>stepblock</code>, see <cite>Examples</cite>, giving the signal that will be convolved with the kernel of the lowpass filter <code>filter</code></p>
</td></tr>
<tr><td><code id="randomGeneration_+3A_noise">noise</code></td>
<td>
<p>for <code>randomGenerationMA</code> a single positive finite numeric giving the constant noise level, for <code>randomGeneration</code> either a numeric of length 1 or of length <code>(n + filter$len - 1L) * oversampling</code> or an object of class <code>stepblock</code>, see <cite>Examples</cite>, giving the noise of the random errors, see <cite>Details</cite></p>
</td></tr>
<tr><td><code id="randomGeneration_+3A_oversampling">oversampling</code></td>
<td>
<p>a single positive integer giving the factor by which the errors should be oversampled, see <cite>Details</cite></p>
</td></tr>
<tr><td><code id="randomGeneration_+3A_seed">seed</code></td>
<td>
<p>will be passed to <code><a href="base.html#topic+set.seed">set.seed</a></code> to set a seed, <code><a href="base.html#topic+set.seed">set.seed</a></code> will not be called if this argument is set to <code>"no"</code>, i.e. a single value, interpreted as an <code><a href="base.html#topic+integer">integer</a></code>, <code>NULL</code> or <code>"no"</code></p>
</td></tr>
<tr><td><code id="randomGeneration_+3A_starttime">startTime</code></td>
<td>
<p>a single finite numeric giving the time at which sampling should start</p>
</td></tr>
<tr><td><code id="randomGeneration_+3A_truncated">truncated</code></td>
<td>
<p>a single logical (not NA) indicating whether the signal should be convolved with the truncated or the untruncated filter kernel</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As discussed in <cite>(Pein et al., 2018)</cite> and <cite>(Pein et al., 2020)</cite>, in ion channel recordings the recorded data points can be modelled as equidistant sampled at rate <code>filter$sr</code> from the convolution of a piecewise constant signal perturbed by Gaussian white noise scaled by the noise level with the kernel of an analogue lowpass filter. The noise level is either constant (homogeneous noise, see <cite>(Pein et al., 2018)</cite>) or itself varying (heterogeneous noise, see <cite>(Pein et al., 2020)</cite>). <code>randomGeneration</code> and <code>randomGenerationMA</code> generate synthetic data from such models. <code>randomGeneration</code> allows homogeneous and heterogeneous noise, while <code>randomGenerationMA</code> only allows homogeneous noise, i.e. <code>noise</code> has to be a single numeric giving the constant noise level. The resulting observations represent the conductance at time points <code>startTime + 1:n / filter$sr</code>.
</p>
<p>The generated observations are the sum of a convolved signal evaluated at those time points plus centred Gaussian errors that are correlated (coloured noise), because of the filtering, and scaled by the noise level. The convolved signal evaluated at those time points can either by specified in <code>signal</code> directly or <code>signal</code> can specify a piecewise constant signal that will be convolved with the <code>filter</code> using <code><a href="#topic+getConvolution">getConvolution</a></code> and evaluated at those time points. <code>randomGenerationMA</code> computes a moving average process with the desired autocorrelation to generate random errors. <code>randomGeneration</code> oversamples the error, i.e. generates errors at time points <code>startTime + (seq(1 - filter$len + 1 / oversampling, n, 1 / oversampling) - 1 / 2 / oversampling) / filter$sr</code>, which will then be convolved with the <code>filter</code>. For this function <code>noise</code> can either give the noise levels at those oversampled time points or specify a piecewise constant function that will be automatically evaluated at those time points.
</p>


<h3>Value</h3>

<p>a numeric vector of length <code>n</code> giving the generated random numbers
</p>


<h3>References</h3>

<p>Pein, F., Bartsch, A., Steinem, C., and Munk, A. (2020) Heterogeneous idealization of ion channel recordings - Open channel noise. Submitted.
</p>
<p>Pein, F., Tecuapetla-Gómez, I., Schütte, O., Steinem, C., Munk, A. (2018) Fully-automatic multiresolution idealization for filtered ion channel recordings: flickering event detection. IEEE Trans. Nanobioscience, 17(3):300-320.
</p>
<p>Pein, F. (2017) Heterogeneous Multiscale Change-Point Inference and its Application to Ion Channel Recordings.
PhD thesis, Georg-August-Universität Göttingen. http://hdl.handle.net/11858/00-1735-0000-002E-E34A-7.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lowpassFilter">lowpassFilter</a></code>, <code><a href="#topic+getConvolution">getConvolution</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>filter &lt;- lowpassFilter(type = "bessel", param = list(pole = 4, cutoff = 0.1), sr = 1e4)
time &lt;- 1:4000 / filter$sr
stepfun &lt;- getSignalPeak(time, cp1 = 0.2, cp2 = 0.2 + 3 / filter$sr, 
                         value = 20, leftValue = 40, rightValue = 40)
signal &lt;- getConvolutionPeak(time, cp1 = 0.2, cp2 = 0.2 + 3 / filter$sr, 
                             value = 20, leftValue = 40, rightValue = 40, filter = filter)
data &lt;- randomGenerationMA(n = 4000, filter = filter, signal = signal, noise = 1.4)

# generated data
plot(time, data, pch = 16)

# zoom into the single peak
plot(time, data, pch = 16, xlim = c(0.199, 0.202), ylim = c(19, 45))
lines(time, stepfun, col = "blue", type = "s", lwd = 2)
lines(time, signal, col = "red", lwd = 2)

# use of randomGeneration instead
data &lt;- randomGeneration(n = 4000, filter = filter, signal = signal, noise = 1.4)

# similar result
plot(time, data, pch = 16, xlim = c(0.199, 0.202), ylim = c(19, 45))
lines(time, stepfun, col = "blue", type = "s", lwd = 2)
lines(time, signal, col = "red", lwd = 2)

## heterogeneous noise
# manual creation of an object of class 'stepblock'
# instead the function stepblock in the package stepR can be used
noise &lt;- data.frame(leftEnd = c(0, 0.2, 0.2 + 3 / filter$sr),
                    rightEnd = c(0.2, 0.2 + 3 / filter$sr, 0.4),
                    value = c(1, 30, 1))
attr(noise, "x0") &lt;- 0
class(noise) &lt;- c("stepblock", class(noise))

data &lt;- randomGeneration(n = 4000, filter = filter, signal = signal, noise = noise)

plot(time, data, pch = 16, xlim = c(0.199, 0.202), ylim = c(19, 45))
lines(time, stepfun, col = "blue", type = "s", lwd = 2)
lines(time, signal, col = "red", lwd = 2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
