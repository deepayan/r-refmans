<!DOCTYPE html><html lang="en"><head><title>Help for package dirmcmc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dirmcmc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dirmcmc'><p>dirmcmc: A package implementing Directional Metropolis Hastings for MCMC</p></a></li>
<li><a href='#iact'><p>Integrated Auto correlation times of a Markov Chain</p></a></li>
<li><a href='#mcmcdiag'><p>mcmcdiag</p></a></li>
<li><a href='#metropdir'><p>Directional Metropolis Hastings</p></a></li>
<li><a href='#metropdir.adapt'><p>Directional Metropolis Hastings with Adaptation.</p></a></li>
<li><a href='#msjd'><p>Mean Squared Jump Distance of a Markov Chain</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Directional Metropolis Hastings Algorithm</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-02-17</td>
</tr>
<tr>
<td>Author:</td>
<td>Abhirup Mallik &lt;malli066@umn.edu&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Abhirup Mallik &lt;malli066@umn.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10.0)</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of Directional Metropolis Hastings Algorithm for
    MCMC.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>5.0.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>mcmcse</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-02-27 03:25:06 UTC; datageek</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-02-27 17:47:26</td>
</tr>
</table>
<hr>
<h2 id='dirmcmc'>dirmcmc: A package implementing Directional Metropolis Hastings for MCMC</h2><span id='topic+dirmcmc'></span><span id='topic+dirmcmc-package'></span>

<h3>Description</h3>

<p>dirmcmc package provides functions for simulating from a target distribution with known log unnormalized density and its derivative. The derivative information is needed to construct the DMH kernel, which is a generalization of random walk Metropolis Hastings kernel.
</p>


<h3>dirmcmc functions</h3>

<p><code><a href="#topic+metropdir">metropdir</a></code>: Implements the dmh algorithm to simulate from a given density.
</p>
<p><code><a href="#topic+metropdir.adapt">metropdir.adapt</a></code>: Adaptive version of DMH algorithm.
</p>
<p><code><a href="#topic+iact">iact</a></code>: Integrated auto correlation times of a univariate chain.
</p>
<p><code><a href="#topic+msjd">msjd</a></code>: Mean square jump distance of a multivariate chain.
</p>
<p><code><a href="#topic+mcmcdiag">mcmcdiag</a></code>: Some summary of diagnostics of a given chain.
</p>

<hr>
<h2 id='iact'>Integrated Auto correlation times of a Markov Chain</h2><span id='topic+iact'></span>

<h3>Description</h3>

<p>This function calculates the Integrated Auto Correlation Times of a Markov Chain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iact(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iact_+3A_x">x</code></td>
<td>
<p>chain (one dimension)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Integrated Auto Correlation Times of a Markov Chain X is defined as: </p>
<p style="text-align: center;"><code class="reqn">1 + 2 \sum \Gamma_i</code>
</p>
<p>, where </p>
<p style="text-align: center;"><code class="reqn">\Gamma</code>
</p>
<p> indicates the estimated autocorrelation terms of the chain. These are estimated using the sample correlation matrix from the lagged chain. This measure is intended for one dimensional chains or single component of a multivariate chains.
</p>


<h3>Value</h3>

<p>Integrated ACT of the chain.
</p>


<h3>Author(s)</h3>

<p>Abhirup Mallik, <a href="mailto:malli066@umn.edu">malli066@umn.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msjd">msjd</a></code> for mean squared jumping distance, <code><a href="#topic+mcmcdiag">mcmcdiag</a></code>
for summary of diagnostic measures of a chain, <code>multiESS</code> for Multivariate effective sample size.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Banana Target
lupost.banana &lt;- function(x,B){
 -x[1]^2/200 - 1/2*(x[2]+B*x[1]^2-100*B)^2
}
Banana Gradient
gr.banana &lt;- function(x,B){
 g1 &lt;- -x[1]/100 - 2*B*(x[2]+B*x[1]^2-100*B)
 g2 &lt;- -(x[2]+B*x[1]^2-100*B)
 g &lt;- c(g1,g2)
 return(g)
} 
out.metdir.banana &lt;- metropdir(obj = lupost.banana, dobj = gr.banana,
initial = c(0,1),lchain = 2000,
sd.prop=1.25,
steplen=0.01,s=1.5,B=0.03)
iact(out.metdir.banana$batch[,1])

## End(Not run)
</code></pre>

<hr>
<h2 id='mcmcdiag'>mcmcdiag</h2><span id='topic+mcmcdiag'></span>

<h3>Description</h3>

<p>This function calculates all different diagnostics supported in this library and returns in a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmcdiag(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcmcdiag_+3A_x">X</code></td>
<td>
<p>Chain (Matrix)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates four metrics useful for diagnostics of a Markov chain. The chain input could be univariate or multivariate. The univariate summaries are calculated marginally, for each component for a multivariate chains. Effective sample size is calculated for each component. Integrared auto correlation times is also another componentwise measure calculated for all the components. Multivariate Effective sample size is calculated from mcmcse package. Mean squared jump distance is another multivariate summary measure that is returned.
</p>


<h3>Value</h3>

<p>list with following elements:
</p>

<ul>
<li><p> MEss Multivariate Effective sample size.
</p>
</li>
<li><p> ess vector of effective sample size for each component.
</p>
</li>
<li><p> iact vector of integrated autocorrelation times for each component.
</p>
</li>
<li><p> msjd Mean squared jump distance for the chain.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Abhirup Mallik, <a href="mailto:malli066@umn.edu">malli066@umn.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+iact">iact</a></code> for integrated auto correlation times, <code><a href="#topic+msjd">msjd</a></code>
for mean squared jump distance of a chain, <code>multiESS</code> for Multivariate effective sample size.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Banana Target
lupost.banana &lt;- function(x,B){
 -x[1]^2/200 - 1/2*(x[2]+B*x[1]^2-100*B)^2
}
Banana Gradient
gr.banana &lt;- function(x,B){
 g1 &lt;- -x[1]/100 - 2*B*(x[2]+B*x[1]^2-100*B)
 g2 &lt;- -(x[2]+B*x[1]^2-100*B)
 g &lt;- c(g1,g2)
 return(g)
} 
out.metdir.banana &lt;- metropdir(obj = lupost.banana, dobj = gr.banana,
initial = c(0,1),lchain = 2000,
sd.prop=1.25,
steplen=0.01,s=1.5,B=0.03)
mcmcdiag(out.metdir.banana$batch)

## End(Not run)
</code></pre>

<hr>
<h2 id='metropdir'>Directional Metropolis Hastings</h2><span id='topic+metropdir'></span>

<h3>Description</h3>

<p>Implements Markov Chain Monte Carlo for continuous random vectors using Directional Metropolis Hasting Algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metropdir(obj, dobj, initial, lchain, sd.prop = 1, steplen = 0, s = 0.95,
  ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="metropdir_+3A_obj">obj</code></td>
<td>
<p>an R function that evaluates the log unnormalized probability
density of the desired equilibrium distribution of the Markov chain.
First argument is the state vector of the Markov chain.  Other arguments
arbitrary and taken from the <code>...</code> arguments of this function.
Should return <code>- Inf</code> for points of the state space having
probability zero under the desired equilibrium distribution.</p>
</td></tr>
<tr><td><code id="metropdir_+3A_dobj">dobj</code></td>
<td>
<p>an R function that evaluates the derivative of the log unnormalized probability density at the current state of the markov chain.</p>
</td></tr>
<tr><td><code id="metropdir_+3A_initial">initial</code></td>
<td>
<p>Initial state of the markov chain. <code>obj(state)</code> must not return #' <code>-Inf</code></p>
</td></tr>
<tr><td><code id="metropdir_+3A_lchain">lchain</code></td>
<td>
<p>length of the chain</p>
</td></tr>
<tr><td><code id="metropdir_+3A_sd.prop">sd.prop</code></td>
<td>
<p>scale to use for the proposal</p>
</td></tr>
<tr><td><code id="metropdir_+3A_steplen">steplen</code></td>
<td>
<p>tuning parameter in mean of proposal</p>
</td></tr>
<tr><td><code id="metropdir_+3A_s">s</code></td>
<td>
<p>tuning parameter in the covariance of proposal</p>
</td></tr>
<tr><td><code id="metropdir_+3A_...">...</code></td>
<td>
<p>any arguments to be passed to obj and dobj.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Runs a &ldquo;Directional Metropolis Hastings&rdquo; algorithm, with multivariate normal proposal
producing a Markov chain with equilibrium distribution having a specified
unnormalized density.  Distribution must be continuous.  Support of the
distribution is the support of the density specified by argument <code>obj</code>.
</p>


<h3>Value</h3>

<p>Returns the following objects in a list:
</p>

<ul>
<li><p> accept. acceptance rate.
</p>
</li>
<li><p> batch. resulting chain.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Abhirup Mallik, <a href="mailto:malli066@umn.edu">malli066@umn.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+metropdir.adapt">metropdir.adapt</a></code> for adapting DMH, <code><a href="#topic+iact">iact</a></code> for integrated auto correlation times, <code><a href="#topic+mcmcdiag">mcmcdiag</a></code>, <code><a href="#topic+msjd">msjd</a></code> for mean squared jump distance.
for summary of diagnostic measures of a chain, <code>multiESS</code> for Multivariate effective sample size.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
Sigma &lt;- matrix(c(1,0.2,0.2,1),2,2)
mu &lt;- c(1,1)
Sig.Inv &lt;- solve(Sigma)
Sig.det.sqrt &lt;- sqrt(det(Sigma))
logf &lt;- function(x,mu,Sig.Inv){
  x.center &lt;- as.numeric((x-mu))
  out &lt;- crossprod(x.center,Sig.Inv)
  out &lt;- sum(out*x.center)
  -out/2
  }

gr.logf &lt;- function(x,mu,Sig.Inv){
  x.center &lt;- as.numeric((x-mu))
  out &lt;- crossprod(x.center,Sig.Inv)
  -as.numeric(out)
}
set.seed(1234)
system.time(out &lt;- metropdir(obj = logf, dobj = gr.logf, initial = c(1,1),
                         lchain = 1e4,sd.prop=1,steplen=0,s=1, mu = mu,
                         Sig.Inv = Sig.Inv))
#acceptance rate
out$accept
#density plot
plot(density(out$batch[,1]))

## End(Not run)
</code></pre>

<hr>
<h2 id='metropdir.adapt'>Directional Metropolis Hastings with Adaptation.</h2><span id='topic+metropdir.adapt'></span>

<h3>Description</h3>

<p>Implements adaptive version of directional Metropolis Hastings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metropdir.adapt(obj, dobj, initial, lchain, sd.prop = 1, steplen = 0,
  s = 0.95, batchlen = 100, targetacc = 0.234, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="metropdir.adapt_+3A_obj">obj</code></td>
<td>
<p>an R function that evaluates the log unnormalized probability
density of the desired equilibrium distribution of the Markov chain.
First argument is the state vector of the Markov chain.  Other arguments
arbitrary and taken from the <code>...</code> arguments of this function.
Should return <code>- Inf</code> for points of the state space having
probability zero under the desired equilibrium distribution.</p>
</td></tr>
<tr><td><code id="metropdir.adapt_+3A_dobj">dobj</code></td>
<td>
<p>an R function that evaluates the derivative of the log unnormalized probability density at the current state of the markov chain.</p>
</td></tr>
<tr><td><code id="metropdir.adapt_+3A_initial">initial</code></td>
<td>
<p>Initial state of the markov chain. <code>obj(state)</code> must not return #' <code>-Inf</code></p>
</td></tr>
<tr><td><code id="metropdir.adapt_+3A_lchain">lchain</code></td>
<td>
<p>length of the chain</p>
</td></tr>
<tr><td><code id="metropdir.adapt_+3A_sd.prop">sd.prop</code></td>
<td>
<p>scale to use for the proposal</p>
</td></tr>
<tr><td><code id="metropdir.adapt_+3A_steplen">steplen</code></td>
<td>
<p>tuning parameter in mean of proposal</p>
</td></tr>
<tr><td><code id="metropdir.adapt_+3A_s">s</code></td>
<td>
<p>tuning parameter in the covariance of proposal</p>
</td></tr>
<tr><td><code id="metropdir.adapt_+3A_batchlen">batchlen</code></td>
<td>
<p>length of batch used for update. Default is 100.</p>
</td></tr>
<tr><td><code id="metropdir.adapt_+3A_targetacc">targetacc</code></td>
<td>
<p>Target acceptance ratio</p>
</td></tr>
<tr><td><code id="metropdir.adapt_+3A_...">...</code></td>
<td>
<p>any arguments to be passed to obj and dobj.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is for automatically select a scaling factor for the directional Metropolis Hastings algorithm. This function uses batch wise update of the scale parameter to produce a adaptive chain. The user is required to supply a target acceptance ratio. The adaptive scheme modifies the scale parameter to achieve the target acceptance ratio. It is recommended that to check the output of the adaptation history as returned by the function.
</p>


<h3>Author(s)</h3>

<p>Abhirup Mallik, <a href="mailto:malli066@umn.edu">malli066@umn.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+metropdir">metropdir</a></code> for DMH, <code><a href="#topic+iact">iact</a></code> for integrated auto correlation times, <code><a href="#topic+mcmcdiag">mcmcdiag</a></code>, <code><a href="#topic+msjd">msjd</a></code> for mean squared jump distance.
for summary of diagnostic measures of a chain, <code>multiESS</code> for Multivariate effective sample size.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
Sigma &lt;- matrix(c(1,0.2,0.2,1),2,2)
mu &lt;- c(1,1)
Sig.Inv &lt;- solve(Sigma)
Sig.det.sqrt &lt;- sqrt(det(Sigma))
logf &lt;- function(x,mu,Sig.Inv){
  x.center &lt;- as.numeric((x-mu))
  out &lt;- crossprod(x.center,Sig.Inv)
  out &lt;- sum(out*x.center)
  -out/2
  }

gr.logf &lt;- function(x,mu,Sig.Inv){
  x.center &lt;- as.numeric((x-mu))
  out &lt;- crossprod(x.center,Sig.Inv)
  -as.numeric(out)
}
set.seed(1234)
system.time(out &lt;- metropdir.adapt(obj = logf, dobj = gr.logf, initial = c(1,1),
                         lchain = 1e4,sd.prop=1,steplen=0,s=1, mu = mu,
                         Sig.Inv = Sig.Inv,targetacc=0.44))
#acceptance rate
out$accept
#density plot
plot(density(out$batch[,1]))

## End(Not run)
</code></pre>

<hr>
<h2 id='msjd'>Mean Squared Jump Distance of a Markov Chain</h2><span id='topic+msjd'></span>

<h3>Description</h3>

<p>We calculate mean square euclidean jumping distance. The target covariance is unknown and the assumption of elliptical contour might not hold here, hence, we dont implement the variance scaled version. And this version is computationally faster as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msjd(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="msjd_+3A_x">X</code></td>
<td>
<p>chain (Matrix) (in d dim)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mean squared jump distance of a markov chain is a measure used to diagnose the mixing of the chain. It is calculated as the mean of the squared eucledean distance between every point and its previous point. Usually, this quantity indicates if the chain is moving enough or getting stuck at some region.
</p>


<h3>Value</h3>

<p>Mean squared jump distance of the chain.
</p>


<h3>Author(s)</h3>

<p>Abhirup Mallik, <a href="mailto:malli066@umn.edu">malli066@umn.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+iact">iact</a></code> for integrated auto correlation times, <code><a href="#topic+mcmcdiag">mcmcdiag</a></code>
for summary of diagnostic measures of a chain, <code>multiESS</code> for Multivariate effective sample size.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Banana Target
lupost.banana &lt;- function(x,B){
 -x[1]^2/200 - 1/2*(x[2]+B*x[1]^2-100*B)^2
}
Banana Gradient
gr.banana &lt;- function(x,B){
 g1 &lt;- -x[1]/100 - 2*B*(x[2]+B*x[1]^2-100*B)
 g2 &lt;- -(x[2]+B*x[1]^2-100*B)
 g &lt;- c(g1,g2)
 return(g)
} 
out.metdir.banana &lt;- metropdir(obj = lupost.banana, dobj = gr.banana,
initial = c(0,1),lchain = 2000,
sd.prop=1.25,
steplen=0.01,s=1.5,B=0.03)
msjd(out.metdir.banana$batch)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
