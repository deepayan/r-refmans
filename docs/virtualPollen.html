<!DOCTYPE html><html lang="en"><head><title>Help for package virtualPollen</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {virtualPollen}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#accumulationRate'><p>Accumulation rate</p></a></li>
<li><a href='#acfToDf'><p>Computes temporal autocorrelation in a vector, and returns a dataframe for easy plotting.</p></a></li>
<li><a href='#aggregateSimulation'><p>Aggregates the output of <code>simulatePopulation</code>.</p></a></li>
<li><a href='#compareSimulations'><p>Compares different simulations produced by <code>simulatePopulation</code>.</p></a></li>
<li><a href='#driverA'><p>Driver A</p></a></li>
<li><a href='#driverB'><p>Driver B</p></a></li>
<li><a href='#drivers'><p>Drivers with different temporal autocorrelation.</p></a></li>
<li><a href='#fixParametersTypes'><p>Fix data types in a parameters dataframe.</p></a></li>
<li><a href='#parameters'><p>Parameters of 4 virtual taxa.</p></a></li>
<li><a href='#parametersCheck'><p>Plots main simulation parameters.</p></a></li>
<li><a href='#parametersDataframe'><p>Generates a template dataframe to contain simulation parameters.</p></a></li>
<li><a href='#plotAcf'><p>Plots results of <code>acfToDf</code>.</p></a></li>
<li><a href='#plotSimulation'><p>Plots results of <code>simulatePopulation</code>.</p></a></li>
<li><a href='#rescaleVector'><p>Rescales a vector within given bounds.</p></a></li>
<li><a href='#simulateAccumulationRate'><p>Simulates a virtual sediment accumulation rate.</p></a></li>
<li><a href='#simulateDriver'><p>Generates a random time series with temporal autocorrelation.</p></a></li>
<li><a href='#simulateDriverS'><p>Generates drivers for <code>simulatePopulation</code>.</p></a></li>
<li><a href='#simulatePopulation'><p>Simulates population dynamics for virtual species with different traits.</p></a></li>
<li><a href='#simulation'><p>List with simulation outputs for all virtual taxa in <code>parameters</code>.</p></a></li>
<li><a href='#toRegularTime'><p>Reinterpolates aggregated simulations into regular time.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Simulating Pollen Curves from Virtual Taxa with Different Life
and Niche Traits</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools to generate virtual environmental drivers with a given temporal autocorrelation, and to simulate pollen curves at annual resolution over millennial time-scales based on these drivers and virtual taxa with different life traits and niche features. It also provides the means to simulate quasi-realistic pollen-data conditions by applying simulated accumulation rates and given depth intervals between consecutive samples.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/BlasBenito/virtualPollen">https://github.com/BlasBenito/virtualPollen</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, cowplot, viridis, mgcv, plyr, tidyr, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>devtools, formatR, kableExtra, magrittr, knitr, rmarkdown</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-02-11 17:41:24 UTC; blas</td>
</tr>
<tr>
<td>Author:</td>
<td>Blas M. Benito [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Blas M. Benito &lt;blasbenito@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-02-13 13:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='accumulationRate'>Accumulation rate</h2><span id='topic+accumulationRate'></span>

<h3>Description</h3>

<p>Dataframe, output of <code><a href="#topic+simulateAccumulationRate">simulateAccumulationRate</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(accumulationRate)
</code></pre>


<h3>Format</h3>

<p>Dataframe with 5000 rows and the following columns:
#' @return A dataframe with the following columns.
</p>

<ul>
<li> <p><em>time</em>: numeric, time or age of the given case.  <strong>Important</strong>: the <code>time</code> column goes from &quot;left to right&quot;, meaning that oldest samples have the lowest values of age/time, and viceversa.
</p>
</li>
<li> <p><em>accumulation.rate</em>: numeric, in years per centimetre, simulated accumulation rate.
</p>
</li>
<li> <p><em>grouping</em>: integer, grouping variable to aggregate together (with <code><a href="#topic+aggregateSimulation">aggregateSimulation</a></code>) samples deposited in the same centimetre according <em>accumulation.rate</em>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Blas M. Benito  &lt;blasbenito@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulateAccumulationRate">simulateAccumulationRate</a></code>, <code><a href="#topic+aggregateSimulation">aggregateSimulation</a></code>
</p>

<hr>
<h2 id='acfToDf'>Computes temporal autocorrelation in a vector, and returns a dataframe for easy plotting.</h2><span id='topic+acfToDf'></span>

<h3>Description</h3>

<p>It reads a vector representing a time series, applies <code><a href="stats.html#topic+acf">acf</a></code> for a given number of lags
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acfToDf(
  x = NULL,
  lag.max = 100,
  length.out = 10
  )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="acfToDf_+3A_x">x</code></td>
<td>
<p>numeric vector. Must represent a variable sampled at regular times.</p>
</td></tr>
<tr><td><code id="acfToDf_+3A_lag.max">lag.max</code></td>
<td>
<p>integer, number of lags over which to compute temporal autocorrelation.</p>
</td></tr>
<tr><td><code id="acfToDf_+3A_length.out">length.out</code></td>
<td>
<p>integer, total number of lags to consider for plotting. Should be a subset of <code>lag.max</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes temporal autocorrelation of a given vector using <code><a href="stats.html#topic+acf">acf</a></code>, and returns a dataframe ready for easy plotting with <code><a href="#topic+plotAcf">plotAcf</a></code>.
</p>


<h3>Value</h3>

<p>A dataframe with the columns:
#' </p>

<ul>
<li> <p><em>lag</em>: numeric, lag in the time units of <code>x</code> with a maximum determined by <code>lag.max</code>, and a number of unique values determined by <code>length.out</code>
</p>
</li>
<li> <p><em>acf</em>: Pearson correlation index returned by the <code><a href="stats.html#topic+acf">acf</a></code> for a given number of lags for the given lag.
</p>
</li>
<li> <p><em>ci.max</em>: Maximum value of the confidence interval of <code>acf</code>.
</p>
</li>
<li> <p><em>ci.min</em>: Minimum value of the confidence interval of <code>acf</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Blas M. Benito  &lt;blasbenito@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+acf">acf</a></code>, <code><a href="#topic+plotAcf">plotAcf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#getting a driver
data(driverA)

#computing temporal autocorrelations
x.df &lt;- acfToDf(
  x = driverA,
  lag.max = 1000,
  length.out = 100
)
str(x.df)

#plotting output
plotAcf(x.df)

</code></pre>

<hr>
<h2 id='aggregateSimulation'>Aggregates the output of <code><a href="#topic+simulatePopulation">simulatePopulation</a></code>.</h2><span id='topic+aggregateSimulation'></span>

<h3>Description</h3>

<p>Takes the output of <code><a href="#topic+simulatePopulation">simulatePopulation</a></code> and aggregates it into centimetres by following a sediment accumulation rate produced by <code><a href="#topic+simulateAccumulationRate">simulateAccumulationRate</a></code>. It further samples it at given depth intervals. It intends to simulate a pseudo-realistic sedimentation of the pollen produced by the simulation, and to apply a pollen-sampling pattern to a virtual pollen core.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregateSimulation(
  simulation.output=NULL,
  accumulation.rate=NULL,
  sampling.intervals=1
  )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aggregateSimulation_+3A_simulation.output">simulation.output</code></td>
<td>
<p>list, output of <code><a href="#topic+simulatePopulation">simulatePopulation</a></code>.</p>
</td></tr>
<tr><td><code id="aggregateSimulation_+3A_accumulation.rate">accumulation.rate</code></td>
<td>
<p>dataframe, output of <code><a href="#topic+simulateAccumulationRate">simulateAccumulationRate</a></code>.</p>
</td></tr>
<tr><td><code id="aggregateSimulation_+3A_sampling.intervals">sampling.intervals</code></td>
<td>
<p>integer, numeric vector, depth interval or intervals between consecutive samples in centimetres. If 1, all samples are returned, if 2, returned samples are separated by 1 cm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses the values in the <code>grouping</code> column of the <code><a href="#topic+simulateAccumulationRate">simulateAccumulationRate</a></code> output to aggregate together (by computing the <code>mean</code>) as many samples as cases in <code>grouping</code> have the same identificator. Output samples are identified by the average age of the samples within the given centimetre.
</p>


<h3>Value</h3>

<p>A list of dataframes with as many rows as virtual taxa were produced by <code><a href="#topic+simulatePopulation">simulatePopulation</a></code>, and the following columns: column 1 is the original data, column 2 is the original data aggregated by the accumulation rate, columns 3 to n are the different sampling intervals defined by the user.
</p>


<h3>Author(s)</h3>

<p>Blas M. Benito  &lt;blasbenito@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulateAccumulationRate">simulateAccumulationRate</a></code>, <code><a href="#topic+simulatePopulation">simulatePopulation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#getting example data
data(simulation)
data(accumulationRate)

#aggregating first simulation outcome
sim.output.aggregated &lt;- aggregateSimulation(
 simulation.output = simulation[1],
 accumulation.rate = accumulationRate,
 sampling.intervals = c(2,6))

#comparing simulations
par(mfrow = c(3,1))
#notice the subsetting of the given column of the input list
plot(sim.output.aggregated[[1,1]]$Time,
 sim.output.aggregated[[1,1]]$Pollen,
 type = "l",
 xlim = c(500, 1000),
 main = "Annual"
 )
plot(sim.output.aggregated[[1,2]]$Time,
 sim.output.aggregated[[1,2]]$Pollen,
 type = "l",
 xlim = c(500, 1000),
 main = "2cm"
 )
plot(sim.output.aggregated[[1,3]]$Time,
 sim.output.aggregated[[1,3]]$Pollen,
 type = "l",
 xlim = c(500, 1000),
 main = "6cm"
 )

#check differences in nrow
nrow(sim.output.aggregated[[1,1]]) #original data
nrow(sim.output.aggregated[[1,2]]) #2cm
nrow(sim.output.aggregated[[1,3]]) #6cm intervals

</code></pre>

<hr>
<h2 id='compareSimulations'>Compares different simulations produced by <code><a href="#topic+simulatePopulation">simulatePopulation</a></code>.</h2><span id='topic+compareSimulations'></span>

<h3>Description</h3>

<p>Plots together the results of different virtual taxa produced by a single run of <code><a href="#topic+simulatePopulation">simulatePopulation</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareSimulations(
  simulation.output = NULL,
  species = "all",
  filename = NULL,
  columns = "Pollen",
  time.zoom = NULL,
  width = 12,
  text.size = 20,
  title.size = 25,
  plot.title = ""
  )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compareSimulations_+3A_simulation.output">simulation.output</code></td>
<td>
<p>list, output of <code><a href="#topic+simulatePopulation">simulatePopulation</a></code>.</p>
</td></tr>
<tr><td><code id="compareSimulations_+3A_species">species</code></td>
<td>
<p>a number or vector or numbers representing rows in the parameters dataframe, or a string or vector of strings referencing to the &quot;label&quot; column of the parameters dataframe.</p>
</td></tr>
<tr><td><code id="compareSimulations_+3A_filename">filename</code></td>
<td>
<p>character string, name of output pdf file. If NULL or empty, no pdf is produced.</p>
</td></tr>
<tr><td><code id="compareSimulations_+3A_columns">columns</code></td>
<td>
<p>character string or vector of character strings with these possible values: &quot;Pollen&quot;, &quot;Population.mature&quot;, &quot;Population.immature&quot;, &quot;Population.viable.seeds&quot;, &quot;Suitability&quot;, &quot;Biomass.total&quot;, &quot;Biomass.mature&quot;, &quot;Biomass.immature&quot;, &quot;Mortality.mature&quot;, &quot;Mortality.immature&quot;, &quot;Driver.A&quot;, &quot;Driver.B&quot;.</p>
</td></tr>
<tr><td><code id="compareSimulations_+3A_time.zoom">time.zoom</code></td>
<td>
<p>vector of two numbers, indicating the beginnign and end of the time interval to be plotted (i.e. &quot;c(5000, 10000)&quot;)</p>
</td></tr>
<tr><td><code id="compareSimulations_+3A_width">width</code></td>
<td>
<p>plot width in inches.</p>
</td></tr>
<tr><td><code id="compareSimulations_+3A_text.size">text.size</code></td>
<td>
<p>text size of the plot.</p>
</td></tr>
<tr><td><code id="compareSimulations_+3A_title.size">title.size</code></td>
<td>
<p>plot title size.</p>
</td></tr>
<tr><td><code id="compareSimulations_+3A_plot.title">plot.title</code></td>
<td>
<p>character string to use as plot title.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The user can decide what virtual taxa to plot through the <code>species</code> argument, and what information to show throught the <code>columns</code> argument. Output is plotted on screen by default, and printed to pdf if the <code>filename</code> argument is filled.
</p>


<h3>Author(s)</h3>

<p>Blas M. Benito  &lt;blasbenito@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulatePopulation">simulatePopulation</a></code>, <code><a href="#topic+plotSimulation">plotSimulation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#getting example data
data(simulation)

#compare taxa 1, 2, and 3.
compareSimulations(simulation.output = simulation,
 species = c(1, 2, 3),
 columns = c("Pollen", "Suitability"),
 time.zoom = c(1000, 2000)
)

</code></pre>

<hr>
<h2 id='driverA'>Driver A</h2><span id='topic+driverA'></span>

<h3>Description</h3>

<p>A vector of 5000 values (years) between 0 and 100 generated by <code><a href="#topic+simulateDriver">simulateDriver</a></code> with a temporal autocorrelation significant for 600 years. It is meant to be used as input for <code><a href="#topic+simulatePopulation">simulatePopulation</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(driverA)
</code></pre>


<h3>Format</h3>

<p>Numeric vector of length 5000.
</p>


<h3>Author(s)</h3>

<p>Blas M. Benito  &lt;blasbenito@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulateDriver">simulateDriver</a></code>
</p>

<hr>
<h2 id='driverB'>Driver B</h2><span id='topic+driverB'></span>

<h3>Description</h3>

<p>A vector of 5000 values (years) between 0 and 100 generated by <code><a href="#topic+simulateDriver">simulateDriver</a></code> with a temporal autocorrelation significant for 600 years. It is meant to be used as input for <code><a href="#topic+simulatePopulation">simulatePopulation</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(driverB)
</code></pre>


<h3>Format</h3>

<p>Numeric vector of length 5000.
</p>


<h3>Author(s)</h3>

<p>Blas M. Benito  &lt;blasbenito@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulateDriver">simulateDriver</a></code>
</p>

<hr>
<h2 id='drivers'>Drivers with different temporal autocorrelation.</h2><span id='topic+drivers'></span>

<h3>Description</h3>

<p>A dataframe with 20000 rows and 4 columns (years) containing two drivers (A and B) generated by <code><a href="#topic+simulateDriver">simulateDriver</a></code> with different temporal autocorrelations (200 and 600). Each driver represents a period of 5000 years. This dataset is is meant to be used as input for <code><a href="#topic+simulatePopulation">simulatePopulation</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(drivers)
</code></pre>


<h3>Format</h3>

<p>Dataframe with 4 columns and 20000 rows.
</p>


<h3>Details</h3>


<ul>
<li> <p><em>time</em> integer, represents time from 0 to 10000, <strong>where 0 is the oldest sample, and 10000 is the newest one (opposite to the general interpretation of age in palaeoecology!)</strong>.
</p>
</li>
<li> <p><em>driver</em> character, values are <code>A</code> and <code>B</code>
</p>
</li>
<li> <p><em>autocorrelation.length</em> numeric, values are 200, 600, and 1800.
</p>
</li>
<li> <p><em>value</em> numeric, value of the driver for the given <code>time</code>, <em>driver</em>, and <em>autocorrelation.length</em>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Blas M. Benito  &lt;blasbenito@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulateDriver">simulateDriver</a></code>
</p>

<hr>
<h2 id='fixParametersTypes'>Fix data types in a parameters dataframe.</h2><span id='topic+fixParametersTypes'></span>

<h3>Description</h3>

<p>It converts all columns (but the <code>label</code> one) of a parameters dataframe created by <code><a href="#topic+parametersDataframe">parametersDataframe</a></code> and filled by the user into type numeric, and checks the coherence of the parameters for each taxon. It provides feedback on the check results on screen for each taxon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixParametersTypes(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fixParametersTypes_+3A_x">x</code></td>
<td>
<p>dataframe resulting from <code><a href="#topic+parametersDataframe">parametersDataframe</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Same dataframe provided in argument <code>x</code> but with fixed data types.
</p>


<h3>Author(s)</h3>

<p>Blas M. Benito  &lt;blasbenito@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+parametersDataframe">parametersDataframe</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
parameters &lt;- parametersDataframe(rows=1)
parameters[1,] &lt;- c("Species 1", 50, 20, 2, 0.2, 0, 100, 1000, 1, 0, 50, 10, 0, 0, 600, 600)
parameters &lt;- fixParametersTypes(x=parameters)

</code></pre>

<hr>
<h2 id='parameters'>Parameters of 4 virtual taxa.</h2><span id='topic+parameters'></span>

<h3>Description</h3>

<p>A dataframe with the parameters of 4 virtual taxa. This dataset was generated by <code><a href="#topic+parametersDataframe">parametersDataframe</a></code> and <code><a href="#topic+fixParametersTypes">fixParametersTypes</a></code>. It is meant to be used as input for <code><a href="#topic+simulatePopulation">simulatePopulation</a></code>. Its columns are:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(parameters)
</code></pre>


<h3>Format</h3>

<p>Dataframe with 16 columns and 4 rows.
</p>


<h3>Details</h3>


<ul>
<li> <p><em>label</em>: to store names (character string) of the virtual taxa.
</p>
</li>
<li> <p><em>maximum.age</em>: integer, maximum possible age of the individuals in years.
</p>
</li>
<li> <p><em>reproductive.age</em>: integer, age of sexual maturity in years.
</p>
</li>
<li> <p><em>fecundity</em>: integer, number of maximum viable seeds produced by a mature individual under fully suitable conditions.
</p>
</li>
<li> <p><em>growth.rate</em>: numeric, parameter of the logistic growth function.
</p>
</li>
<li> <p><em>pollen.control</em>: numeric in the interval [0, 1]. If 0, pollen productivity depends on environmental suitability only. The larger the number, biomass takes over environmental suitability in determining pollen productivity.
</p>
</li>
<li> <p><em>maximum.biomass</em>: integer, maximum biomass of the individuals.
</p>
</li>
<li> <p><em>carrying.capacity</em>: integer, maximum sum of biomass of the individuals. Very large carrying capacities plus a low maximum.biomass generates too many individuals for the simulation to remain efficient. Try to set carrying.capacity and maximum.biomass to carrying.capacity divided by biomass returns a number lower than 1000 (and even better if it is closer to 100).
</p>
</li>
<li> <p><em>driver.A.weight</em>: numeric in the interval [0, 1], represents the relative influence of the driver on environmental suitability.
</p>
</li>
<li> <p><em>driver.B.weight</em>: numeric in the interval [0, 1], represents the relative influence of the driver on environmental suitability. The sum of weights of drivers A and B should be 1.
</p>
</li>
<li> <p><em>niche.A.mean</em>: numeric, in the same units as driver A. It is the mean of the normal function defining the response of the virtual taxa to driver A.
</p>
</li>
<li> <p><em>niche.A.sd</em>: numeric, in the same units as driver A. It is the standard deviation of the normal function defining the response of the virtual taxa to driver A.
</p>
</li>
<li> <p><em>niche.B.mean</em>: as above, but for driver B.
</p>
</li>
<li> <p><em>niche.B.sd</em>: as above, but for driver B.
</p>
</li>
<li> <p><em>autocorrelation.length.A</em>: numeric, only useful if several drivers generated with different autocorrelation lengths are available (and identified by the column <code>autocorrelation.length</code>) in the <code>drivers</code> argument provided to the <code><a href="#topic+simulatePopulation">simulatePopulation</a></code> function.
</p>
</li>
<li> <p><em>autocorrelation.length.B</em>: same as above.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Blas M. Benito  &lt;blasbenito@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+parametersCheck">parametersCheck</a></code>, <code><a href="#topic+parametersDataframe">parametersDataframe</a></code>, <code><a href="#topic+simulatePopulation">simulatePopulation</a></code>
</p>

<hr>
<h2 id='parametersCheck'>Plots main simulation parameters.</h2><span id='topic+parametersCheck'></span>

<h3>Description</h3>

<p>Plots the environmental niche, fecundity, growth curve, and maturity age, of each virtual taxa in a parameters dataframe for <code><a href="#topic+simulatePopulation">simulatePopulation</a></code>, to help the user in making choices while adjusting them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parametersCheck(
  parameters,
  species = "all",
  driver.A = NULL,
  driver.B = NULL,
  drivers = NULL,
  filename = NULL
  )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parametersCheck_+3A_parameters">parameters</code></td>
<td>
<p>the parameters dataframe.</p>
</td></tr>
<tr><td><code id="parametersCheck_+3A_species">species</code></td>
<td>
<p>if &quot;all&quot; or &quot;ALL&quot;, all species in &quot;parameters&quot; are plotted. It also accepts a vector of numbers representing the rows of the selected species, or a vector of names of the selected species.</p>
</td></tr>
<tr><td><code id="parametersCheck_+3A_driver.a">driver.A</code></td>
<td>
<p>numeric vector with driver values.</p>
</td></tr>
<tr><td><code id="parametersCheck_+3A_driver.b">driver.B</code></td>
<td>
<p>numeric vector with driver values.</p>
</td></tr>
<tr><td><code id="parametersCheck_+3A_drivers">drivers</code></td>
<td>
<p>dataframe with drivers</p>
</td></tr>
<tr><td><code id="parametersCheck_+3A_filename">filename</code></td>
<td>
<p>character string, filename of the output pdf.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function prints the plot, can save it to a pdf file if <code>filename</code> is provided, and returns a <code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code> object. Priority is given to drivers introduced through the <code>drivers</code> argument.
</p>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Blas M. Benito  &lt;blasbenito@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+parametersDataframe">parametersDataframe</a></code>, <code><a href="#topic+fixParametersTypes">fixParametersTypes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#getting data
data(parameters)
data(drivers)

#plotting parameters
parametersCheck(
 parameters = parameters,
 drivers = drivers
 )


</code></pre>

<hr>
<h2 id='parametersDataframe'>Generates a template dataframe to contain simulation parameters.</h2><span id='topic+parametersDataframe'></span>

<h3>Description</h3>

<p>Generates the dataframe structure needed to contain the parameters used as input for the <code><a href="#topic+simulatePopulation">simulatePopulation</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parametersDataframe(rows=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parametersDataframe_+3A_rows">rows</code></td>
<td>
<p>integer, number of rows in the output dataframe.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The resulting dataframe can either be filled manually through vectors, as shown in the example (but this requires to use the function <code><a href="#topic+fixParametersTypes">fixParametersTypes</a></code> once the dataframe is completed), or can be edited manually in Rstudio by installing the <a href="https://CRAN.R-project.org/package=editData">editData</a> package.
</p>


<h3>Value</h3>

<p>A dataframe filled with <code>NA</code> values and the columns:
</p>

<ul>
<li> <p><em>label</em>: to store names (character string) of the virtual taxa.
</p>
</li>
<li> <p><em>maximum.age</em>: integer, maximum possible age of the individuals in years.
</p>
</li>
<li> <p><em>reproductive.age</em>: integer, age of sexual maturity in years.
</p>
</li>
<li> <p><em>fecundity</em>: integer, number of maximum viable seeds produced by a mature individual under fully suitable conditions.
</p>
</li>
<li> <p><em>growth.rate</em>: numeric, parameter of the logistic growth function.
</p>
</li>
<li> <p><em>pollen.control</em>: numeric in the interval [0, 1]. If 0, pollen productivity depends on environmental suitability only. The larger the number, biomass takes over environmental suitability in determining pollen productivity.
</p>
</li>
<li> <p><em>maximum.biomass</em>: integer, maximum biomass of the individuals.
</p>
</li>
<li> <p><em>carrying.capacity</em>: integer, maximum sum of biomass of the individuals. Very large carrying capacities plus a low maximum.biomass generates too many individuals for the simulation to remain efficient. Try to set carrying.capacity and maximum.biomass to carrying.capacity divided by biomass returns a number lower than 1000 (and even better if it is closer to 100).
</p>
</li>
<li> <p><em>driver.A.weight</em>: numeric in the interval [0, 1], represents the relative influence of the driver on environmental suitability.
</p>
</li>
<li> <p><em>driver.B.weight</em>: numeric in the interval [0, 1], represents the relative influence of the driver on environmental suitability. The sum of weights of drivers A and B should be 1.
</p>
</li>
<li> <p><em>niche.A.mean</em>: numeric, in the same units as driver A. It is the mean of the normal function defining the response of the virtual taxa to driver A.
</p>
</li>
<li> <p><em>niche.A.sd</em>: numeric, in the same units as driver A. It is the standard deviation of the normal function defining the response of the virtual taxa to driver A.
</p>
</li>
<li> <p><em>niche.B.mean</em>: as above, but for driver B.
</p>
</li>
<li> <p><em>niche.B.sd</em>: as above, but for driver B.
</p>
</li>
<li> <p><em>autocorrelation.length.A</em>: numeric, only useful if several drivers generated with different autocorrelation lengths are available (and identified by the column <code>autocorrelation.length</code>) in the <code>drivers</code> argument provided to the <code><a href="#topic+simulatePopulation">simulatePopulation</a></code> function.
</p>
</li>
<li> <p><em>autocorrelation.length.B</em>: same as above.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Blas M. Benito  &lt;blasbenito@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulatePopulation">simulatePopulation</a></code>, <code><a href="#topic+fixParametersTypes">fixParametersTypes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#generating the template
parameters &lt;- parametersDataframe(rows=1)

#filling it with a vector
parameters[1,] &lt;- c("Species 1", 50, 20, 2, 0.2, 0, 100, 1000, 1, 0, 50, 10, 0, 0, 600, 600)

</code></pre>

<hr>
<h2 id='plotAcf'>Plots results of <code><a href="#topic+acfToDf">acfToDf</a></code>.</h2><span id='topic+plotAcf'></span>

<h3>Description</h3>

<p>Plots a dataframe resulting from <code><a href="#topic+acfToDf">acfToDf</a></code> by using <code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotAcf(
  x = NULL,
  plot.title = ""
  )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotAcf_+3A_x">x</code></td>
<td>
<p>dataframe, output of <code><a href="#topic+acfToDf">acfToDf</a></code></p>
</td></tr>
<tr><td><code id="plotAcf_+3A_plot.title">plot.title</code></td>
<td>
<p>string, title of the output plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object
</p>


<h3>Author(s)</h3>

<p>Blas M. Benito  &lt;blasbenito@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+acfToDf">acfToDf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#getting a driver
data(driverA)

#computing temporal autocorrelations
x.df &lt;- acfToDf(
  x = driverA,
  lag.max = 1000,
  length.out = 100
)
str(x.df)

#plotting output
plotAcf(x.df)

</code></pre>

<hr>
<h2 id='plotSimulation'>Plots results of <code><a href="#topic+simulatePopulation">simulatePopulation</a></code>.</h2><span id='topic+plotSimulation'></span>

<h3>Description</h3>

<p>This function takes as input the output of <code><a href="#topic+simulatePopulation">simulatePopulation</a></code>, and plots the pollen abundance, number of individuals, biomass, driver, and environmnetal suitability of each simulation outcome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSimulation(
  simulation.output = NULL,
  species = "all",
  burnin = FALSE,
  filename = NULL,
  time.zoom = NULL,
  panels = c("Driver A",
           "Driver B",
           "Suitability",
           "Population",
           "Mortality",
           "Biomass",
           "Pollen"
           ),
 plot.title = NULL,
 width = 12,
 text.size = 20,
 title.size = 25,
 line.size = 1
 )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotSimulation_+3A_simulation.output">simulation.output</code></td>
<td>
<p>output of <code><a href="#topic+simulatePopulation">simulatePopulation</a></code>.</p>
</td></tr>
<tr><td><code id="plotSimulation_+3A_species">species</code></td>
<td>
<p>a number or vector of numbers representing rows in the parameters dataframe, or a string or vector of strings referencing to the &quot;label&quot; column of the parameters dataframe.</p>
</td></tr>
<tr><td><code id="plotSimulation_+3A_burnin">burnin</code></td>
<td>
<p>if <code>FALSE</code>, burn-in period is not considered in the model.</p>
</td></tr>
<tr><td><code id="plotSimulation_+3A_filename">filename</code></td>
<td>
<p>character string, name of output pdf file. If NULL or empty, no pdf is produced. It shouldn't include the extension of the output file.</p>
</td></tr>
<tr><td><code id="plotSimulation_+3A_time.zoom">time.zoom</code></td>
<td>
<p>vector of two numbers indicating the beginnign and end of the time interval to be plotted (i.e. &quot;c(5000, 10000)&quot;)</p>
</td></tr>
<tr><td><code id="plotSimulation_+3A_panels">panels</code></td>
<td>
<p>character string or vector of character strings with these possible values: &quot;Driver A&quot;, &quot;Driver B&quot;,&quot;Suitability&quot;, &quot;Population&quot;, &quot;Mortality&quot;, &quot;Biomass&quot;, &quot;Pollen&quot;.</p>
</td></tr>
<tr><td><code id="plotSimulation_+3A_plot.title">plot.title</code></td>
<td>
<p>character string to use as plot title.</p>
</td></tr>
<tr><td><code id="plotSimulation_+3A_width">width</code></td>
<td>
<p>plot width in inches.</p>
</td></tr>
<tr><td><code id="plotSimulation_+3A_text.size">text.size</code></td>
<td>
<p>text size of the plot.</p>
</td></tr>
<tr><td><code id="plotSimulation_+3A_title.size">title.size</code></td>
<td>
<p>plot title size.</p>
</td></tr>
<tr><td><code id="plotSimulation_+3A_line.size">line.size</code></td>
<td>
<p>size of lines in plots.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The user can decide what virtual taxa to plot (argument <code>species</code>), and what information to show throught the <code>panels</code> argument. Output is plotted on screen by default, and printed to pdf if the <code>filename</code> argument is filled.
</p>


<h3>Author(s)</h3>

<p>Blas M. Benito  &lt;blasbenito@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulatePopulation">simulatePopulation</a></code>, <code><a href="#topic+compareSimulations">compareSimulations</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#getting example data
data(simulation)

#plot first simulation
plotSimulation(simulation.output = simulation[[1]])

</code></pre>

<hr>
<h2 id='rescaleVector'>Rescales a vector within given bounds.</h2><span id='topic+rescaleVector'></span>

<h3>Description</h3>

<p>Takes a numeric vector <code>x</code> and rescales it within the values given by <code>new.min</code> and <code>new.max</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescaleVector(
  x = rnorm(100),
  new.min = 0,
  new.max = 100,
  integer = FALSE
  )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rescaleVector_+3A_x">x</code></td>
<td>
<p>numeric vector to be rescaled.</p>
</td></tr>
<tr><td><code id="rescaleVector_+3A_new.min">new.min</code></td>
<td>
<p>numeric, new minimum value for <code>x</code>. Default is 0.</p>
</td></tr>
<tr><td><code id="rescaleVector_+3A_new.max">new.max</code></td>
<td>
<p>numeric, new maximum value for <code>x</code>. Default is 100.</p>
</td></tr>
<tr><td><code id="rescaleVector_+3A_integer">integer</code></td>
<td>
<p>boolean, if TRUE, output vector is returned as vector of integers. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the same length as <code>x</code> rescaled between <code>output.min</code> and <code>output.max</code>.
</p>


<h3>Author(s)</h3>

<p>Blas M. Benito  &lt;blasbenito@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#generating example data
x = rnorm(100)

#as float
x.float &lt;- rescaleVector(
  x = x,
  new.min = 0,
  new.max = 100,
  integer = FALSE
  )

#as integer
x.integer &lt;- rescaleVector(
  x = x,
  new.min = 0,
  new.max = 100,
  integer = TRUE
  )

</code></pre>

<hr>
<h2 id='simulateAccumulationRate'>Simulates a virtual sediment accumulation rate.</h2><span id='topic+simulateAccumulationRate'></span>

<h3>Description</h3>

<p>Generates a virtual sediment accumulation rate to be applied to the results of <code><a href="#topic+simulatePopulation">simulatePopulation</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateAccumulationRate(
  seed=50,
  time=1:1000,
  output.min=10,
  output.max=40,
  direction=1,
  plot=TRUE
  )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulateAccumulationRate_+3A_seed">seed</code></td>
<td>
<p>integer, seed to be used by <code><a href="base.html#topic+set.seed">set.seed</a></code> to configure the state of the pseudo-random number generator. It defines the shape of the curve.</p>
</td></tr>
<tr><td><code id="simulateAccumulationRate_+3A_time">time</code></td>
<td>
<p>vector of time values (ideally the same used to generate the simulations). <strong>Important</strong>: the <code>time</code> column goes from &quot;left to right&quot;, meaning that oldest samples have the lowest values of age/time, and viceversa.</p>
</td></tr>
<tr><td><code id="simulateAccumulationRate_+3A_output.min">output.min</code></td>
<td>
<p>numeric, in years per centimetre, minimum sediment accumulation rate (10 by default).</p>
</td></tr>
<tr><td><code id="simulateAccumulationRate_+3A_output.max">output.max</code></td>
<td>
<p>numeric, in years per centimetre, maximum sediment accumulation rate (40 bu default).</p>
</td></tr>
<tr><td><code id="simulateAccumulationRate_+3A_direction">direction</code></td>
<td>
<p>integer, values 1 or -1, to invert the resulting accumulation rate.</p>
</td></tr>
<tr><td><code id="simulateAccumulationRate_+3A_plot">plot</code></td>
<td>
<p>boolean, plots output accumulation rate if <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The accumulation rate curve is generated through a random walk smoothed by a GAM model. The value of the <code>seed</code> argument changes the shape of the curve, but the user has no more control than trying different values to achieve a curve closer to the desired one. If <code>plot</code> is set to <code>TRUE</code>, the accumulation rate curve is printed on screen, but not exported to pdf.
</p>


<h3>Value</h3>

<p>A dataframe like <code><a href="#topic+accumulationRate">accumulationRate</a></code>, with the following columns:
</p>

<ul>
<li> <p><em>time</em>: numeric, time or age of the given case.
</p>
</li>
<li> <p><em>accumulation.rate</em>: numeric, in years per centimetre, simulated accumulation rate.
</p>
</li>
<li> <p><em>grouping</em>: integer, grouping variable to aggregate together (with <code><a href="#topic+aggregateSimulation">aggregateSimulation</a></code>) samples deposited in the same centimetre according <em>accumulation.rate</em>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Blas M. Benito  &lt;blasbenito@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulatePopulation">simulatePopulation</a></code>, <code><a href="#topic+aggregateSimulation">aggregateSimulation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
acc.rate &lt;- simulateAccumulationRate(
 seed = 50,
 time = 1:1000,
 output.min = 10,
 output.max = 40,
 direction = 1,
 plot = TRUE
 )

str(acc.rate)

</code></pre>

<hr>
<h2 id='simulateDriver'>Generates a random time series with temporal autocorrelation.</h2><span id='topic+simulateDriver'></span>

<h3>Description</h3>

<p>Generates a vector of the same legnth as the <code>time</code> argument, with a temporal autocorrelation length close to the defined by <code>autocorrelation.length</code>, and a range within <code>output.min</code> and <code>output.max</code>. The output of this function is intended to be used as an input to the function <code><a href="#topic+simulatePopulation">simulatePopulation</a></code>. <strong>Important</strong>: note that the variable <code>time</code> runs from left to right in <code><a href="#topic+simulatePopulation">simulatePopulation</a></code>, with lower values representing older samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateDriver(
  random.seed = 30,
  time = 1:10000,
  autocorrelation.length = 100,
  output.min = 0,
  output.max = 100,
  rescale = TRUE
  )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulateDriver_+3A_random.seed">random.seed</code></td>
<td>
<p>integer, seed to be used by <code>set.seed()</code>. Default is 50.</p>
</td></tr>
<tr><td><code id="simulateDriver_+3A_time">time</code></td>
<td>
<p>integer, or numeric vector of integers with constant intervals. If a single integer is provided, a time sequence is generated from 1 to the given integer as <em>seq(1, time, by = 1)</em>. Default is 1:10000.</p>
</td></tr>
<tr><td><code id="simulateDriver_+3A_autocorrelation.length">autocorrelation.length</code></td>
<td>
<p>integer, represents the length of the convolution filter to be used to impose a particular temporal structure on the time series. Default is 100, equivalent to a filter composed by a hundred of ones.</p>
</td></tr>
<tr><td><code id="simulateDriver_+3A_output.min">output.min</code></td>
<td>
<p>numeric, minimum value of the output time series. Used as input for<code><a href="#topic+rescaleVector">rescaleVector</a></code>. Default is 0.</p>
</td></tr>
<tr><td><code id="simulateDriver_+3A_output.max">output.max</code></td>
<td>
<p>numeric, maximum value of the output time series. Used as input for <code><a href="#topic+rescaleVector">rescaleVector</a></code>. Default is 100.</p>
</td></tr>
<tr><td><code id="simulateDriver_+3A_rescale">rescale</code></td>
<td>
<p>boolean. If FALSE, <code>output.min</code> and <code>output.max</code> are ignored, and the original data range provided by <code>rnorm</code> is preserved. Default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is recommended to use <code>time</code> vectors with a time step of 1 between consecutive values when the output is to be used as input for <code><a href="#topic+simulatePopulation">simulatePopulation</a></code>, which considers annual time-steps while simulating virtual pollen curves. The initial random sequence of numers is generated by <code>rnorm</code>. Desired temporal autocorrelation are approximate, but deviation becomes higher if <code>autocorrelation.length</code> is larger than half the length of <code>time</code>. Consequently, the function limits <code>autocorrelation.length</code> to <code>length(time)/2</code>.
</p>


<h3>Value</h3>

<p>A vector of the same length as <code>time</code>. Datasets <code><a href="#topic+driverA">driverA</a></code> and <code><a href="#topic+driverB">driverB</a></code> are outputs of this function.
</p>


<h3>Author(s)</h3>

<p>Blas M. Benito  &lt;blasbenito@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rescaleVector">rescaleVector</a></code>, <code><a href="#topic+driverA">driverA</a></code>, <code><a href="#topic+driverB">driverB</a></code>, <code><a href="base.html#topic+set.seed">set.seed</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- simulateDriver(
  random.seed = 30,
  time = 1:10000,
  autocorrelation.length = 100,
  output.min = -10,
  output.max = 20,
  rescale = TRUE
  )

#plots output
plot(x, type = "l")

#checks temporal autocorrelation
acf(x, lag.max = 300)

</code></pre>

<hr>
<h2 id='simulateDriverS'>Generates drivers for <code><a href="#topic+simulatePopulation">simulatePopulation</a></code>.</h2><span id='topic+simulateDriverS'></span>

<h3>Description</h3>

<p>Wrapper of <code>simulateDriver</code> to generate several drivers with different autocorrelation lengths, and return a long format dataframe to be used as input for <code><a href="#topic+simulatePopulation">simulatePopulation</a></code>. It also produces a plot of the generated drivers. <strong>Important</strong>: note that the variable <code>time</code> runs from left to right, with lower values representing older samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulateDriverS(
 random.seeds=c(60, 120),
 time=1:10000,
 autocorrelation.lengths=c(200, 600),
 output.min=c(0,0),
 output.max=c(100, 100),
 driver.names=c("A", "B"),
 filename=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulateDriverS_+3A_random.seeds">random.seeds</code></td>
<td>
<p>vector of integers, seeds to be used by <code>set.seed</code>.</p>
</td></tr>
<tr><td><code id="simulateDriverS_+3A_time">time</code></td>
<td>
<p>integer, or numeric vector of integers with constant intervals. If a single integer is provided, a time sequence is generated from 0 to the given integer as <em>seq(0, time, by = 1)</em>. Default is 1:10000.</p>
</td></tr>
<tr><td><code id="simulateDriverS_+3A_autocorrelation.lengths">autocorrelation.lengths</code></td>
<td>
<p>vector of integers, represents the lengths of the convolution filters to be used to impose a particular temporal structure on each driver. Default is 100, equivalent to a filter composed by a hundred of ones.</p>
</td></tr>
<tr><td><code id="simulateDriverS_+3A_output.min">output.min</code></td>
<td>
<p>numeric vector, minimum values of the output time series. Used as input for <strong>rescaleVector</strong>. Default is 0.</p>
</td></tr>
<tr><td><code id="simulateDriverS_+3A_output.max">output.max</code></td>
<td>
<p>numeric vector, maximum values of the output time series. Used as input for <strong>rescaleVector</strong>. Default is 100.</p>
</td></tr>
<tr><td><code id="simulateDriverS_+3A_driver.names">driver.names</code></td>
<td>
<p>character vector, with labels to be used to identify the drivers.</p>
</td></tr>
<tr><td><code id="simulateDriverS_+3A_filename">filename</code></td>
<td>
<p>character string, name of output pdf file. If NULL or empty, no pdf is produced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is recommended to use <code>time</code> vectors with a time step of 1 between consecutive values when the output is to be used as input for <code><a href="#topic+simulatePopulation">simulatePopulation</a></code>, which considers annual time-steps while simulating virtual pollen curves. Initial random sequence is generated by <code>rnorm</code>. Desired temporal autocorrelation are approximate, but deviation becomes higher if <code>autocorrelation.length</code> is larger than half the length of <code>time</code>. Consequently, the function limits <code>autocorrelation.length</code> to <code>length(time)/2</code>.
</p>


<h3>Value</h3>

<p>A long format dataframe (see dataset <code><a href="#topic+drivers">drivers</a></code>) with the following columns:
</p>

<ul>
<li> <p><em>time</em>: integer.
</p>
</li>
<li> <p><em>driver</em>: character, values are <code>A</code> and <code>B</code>
</p>
</li>
<li> <p><em>autocorrelation.length</em>: numeric, default values are 200, 600, and 1800.
</p>
</li>
<li> <p><em>value</em>: numeric, value of the driver for the given <em>time</em>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Blas M. Benito  &lt;blasbenito@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+drivers">drivers</a></code>, <code><a href="#topic+simulateDriver">simulateDriver</a></code>, <code><a href="#topic+simulatePopulation">simulatePopulation</a></code>, <code><a href="#topic+drivers">drivers</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
drivers &lt;- simulateDriverS(
 random.seeds=c(60, 120),
 time=1:10000,
 autocorrelation.lengths=c(200, 600),
 output.min=c(0,0),
 output.max=c(100, 100),
 driver.names=c("A", "B"),
 filename=NULL
)

str(drivers)

</code></pre>

<hr>
<h2 id='simulatePopulation'>Simulates population dynamics for virtual species with different traits.</h2><span id='topic+simulatePopulation'></span>

<h3>Description</h3>

<p>This function takes as input a dataframe of parameters defining virtual taxa produced by <code><a href="#topic+parametersDataframe">parametersDataframe</a></code> and <code><a href="#topic+fixParametersTypes">fixParametersTypes</a></code>, a driver or drivers generated with <code><a href="#topic+simulateDriver">simulateDriver</a></code> or <code><a href="#topic+simulateDriverS">simulateDriverS</a></code>, and simulates population dynamics for the given virtual taxa at yearly resolution for the time-length defined by the driver or drivers. <strong>Important</strong>: note that the variable <code>time</code> runs from left to right, with lower values representing older samples. The model relies on the following set of assumptions:
</p>

<ul>
<li><p>  The spatial structure of the population is not important to explain its pollen productivity. This is an operative assumption, to speed-up model execution.
</p>
</li>
<li><p>  The environmental niche of the species follows a Gaussian distribution, characterized by a mean (niche optimum, also niche position) and a standard deviation (niche breadth or tolerance).
</p>
</li>
<li><p>  Different drivers can have a different influence on the species dynamics, and that influence can be defined by the user by tuning the weights of each driver.
</p>
</li>
<li><p>  Environmental suitability, expressed in the range [0, 1], is the result of an additive function of the species niches (normal function defined by the species' mean and standard deviation for each driver), the drivers' values, and the relative influence of each driver (driver weights).
</p>
</li>
<li><p>  Pollen productivity is a function of the individual's biomass and environmental suitability, so under a hypothetical constant individual's biomass, its pollen production depends linearly on environmental suitability values.
</p>
</li>
<li><p>  Effective fecundity is limited by environmental suitability. Low environmental suitability values limit recruitment, acting as an environmental filter. Therefore, even though the fecundity of the individuals is fixed by the fecundity parameter, the overall population fecundity is limited by environmental suitability.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>simulatePopulation(
  parameters=NULL,
  species="all",
  driver.A=NULL,
  driver.B=NULL,
  drivers=NULL,
  burnin=TRUE
  )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulatePopulation_+3A_parameters">parameters</code></td>
<td>
<p>dataframe with parameters.</p>
</td></tr>
<tr><td><code id="simulatePopulation_+3A_species">species</code></td>
<td>
<p>if &quot;all&quot; or &quot;ALL&quot;, all species in &quot;parameters&quot; are simulated It also accepts a vector of numbers representing the rows of the selected species, or a vector of names of the selected species.</p>
</td></tr>
<tr><td><code id="simulatePopulation_+3A_driver.a">driver.A</code></td>
<td>
<p>numeric vector with driver values. Typically produced by <code><a href="#topic+simulateDriver">simulateDriver</a></code>.</p>
</td></tr>
<tr><td><code id="simulatePopulation_+3A_driver.b">driver.B</code></td>
<td>
<p>numeric vector with driver values.  Typically produced by <code><a href="#topic+simulateDriver">simulateDriver</a></code>. Must have same length as <code>driver.A</code>.</p>
</td></tr>
<tr><td><code id="simulatePopulation_+3A_drivers">drivers</code></td>
<td>
<p>dataframe with drivers produced by <code><a href="#topic+simulateDriverS">simulateDriverS</a></code>. It should have the columns:
</p>

<ul>
<li> <p><em>time</em> integer.
</p>
</li>
<li> <p><em>driver</em> character, values are <code>A</code> and <code>B</code>
</p>
</li>
<li> <p><em>autocorrelation.length</em> numeric, values are 200, 600, and 1800.
</p>
</li>
<li> <p><em>value</em> numeric, value of the driver for the given <em>time</em>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="simulatePopulation_+3A_burnin">burnin</code></td>
<td>
<p>boolean, generates a warming-up period for the population model of a length of five times the maximum age of the virtual taxa.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model starts with a population of 100 individuals with random ages, in the range [1, maximum age], taken from a uniform distribution (all ages are equiprobable). For each environmental suitability value, including the burn-in period, the model performs the following operations:
</p>

<ul>
<li> <p><strong>Aging</strong>: adds one year to the age of the individuals.
</p>
</li>
<li> <p><strong>Mortality due to senescence</strong>: individuals reaching the maximum age are removed from the simulation.
</p>
</li>
<li> <p><strong>Local extinction and immigration</strong>: If the number of individuals drops to zero, the population is replaced by a &quot;seed bank&quot; of #' 100 individuals with age zero, and the simulation jumps to step 7.. This is intended to simulate the arrival of seeds from nearby regions, and will only lead to population growth if environmental suitability is higher than zero.
</p>
</li>
<li> <p><strong>Plant growth</strong>: Applies a plant growth equation to compute the biomass of every individual.
</p>
</li>
<li> <p><strong>Carrying capacity</strong>: If maximum population biomass is reached, individuals are iteratively selected for removal according to a mortality risk curve computed by the equation <code class="reqn">P_{m} = 1 - sqrt(a/A)</code>, were <em>Pm</em> is the probability of mortality, <em>a</em> is the age of the given individual, and <em>A</em> is the maximum age reached by the virtual taxa. This curve gives removal preference to younger individuals, matching observed patterns in natural populations.
</p>
</li>
<li> <p><strong>Pollen productivity</strong>: In each time step the model computes the pollen productivity (in relative values) of the population using the equation <code class="reqn">P_{t} = \sum x_{it} \times max(S_{t}, B)</code>, where <em>t</em> is time (a given simulation time step), <em>P</em> is the pollen productivity of the population at a given time, <em>x_i</em> represents the biomass of every adult individual, <em>S</em> is the environmental suitability at the given time, <em>B</em> is the contribution of biomass to pollen productivity regardless of environmental suitability (<em>pollen.control</em> parameter in the simulation, 0 by default). If <em>B</em> equals 1, <em>P</em> is equal to the total biomass sum of the adult population, regardless of the environmental suitability. If <em>B</em> equals 0, pollen productivity depends entirely on environmental suitability values.
</p>
</li>
<li> <p><strong>Reproduction</strong>: Generates as many seeds as reproductive individuals are available multiplied by the maximum fecundity and the environmental suitability of the given time.
</p>
</li></ul>

<p>The model returns a table with climatic suitability, pollen production, and population size (reproductive individuals only) per simulation year. Figure 10 shows the results of the population model when applied to the example virtual species.
</p>


<h3>Value</h3>

<p>A list of dataframes, each one of them with the results of one simulation. The dataset <code><a href="#topic+simulation">simulation</a></code> exemplifies the output of this function. Each dataframe in the output list has the columns:
</p>

<ul>
<li> <p><em>Time</em> integer, ages in years. Negative ages indicate the burn-in period.
</p>
</li>
<li> <p><em>Pollen</em> numeric, pollen counts
</p>
</li>
<li> <p><em>Population.mature</em> numeric, number of mature individuals.
</p>
</li>
<li> <p><em>Population.immatre</em> numeric, number of immature individuals.
</p>
</li>
<li> <p><em>Population.viable.seeds</em> numeric, number of viable seeds generated each year.
</p>
</li>
<li> <p><em>Suitability</em> numeric, environmental suitability computed from the driver by the normal function/s defining the taxon niche.
</p>
</li>
<li> <p><em>Biomass.total</em> numeric, overall biomass of the population.
</p>
</li>
<li> <p><em>Biomass.mature</em> numeric, sum of biomass of mature individuals.
</p>
</li>
<li> <p><em>Biomass.immature</em> numeric, sum of biomass of immature individuals.
</p>
</li>
<li> <p><em>Mortality.mature</em> numeric, number of mature individuals dead each year.
</p>
</li>
<li> <p><em>Mortality.immature</em> numeric, same as above for immature individuals.
</p>
</li>
<li> <p><em>Driver.A</em> numeric, values of driver A.
</p>
</li>
<li> <p><em>Driver.B</em> numeric, values of driver B, if available, and NA otherwise.
</p>
</li>
<li> <p><em>Period</em> qualitative, with value &quot;Burn-in&quot; for burn-in period, and &quot;Simulation&quot; otherwise.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Blas M. Benito  &lt;blasbenito@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+parametersDataframe">parametersDataframe</a></code>, <code><a href="#topic+fixParametersTypes">fixParametersTypes</a></code>, <code><a href="#topic+plotSimulation">plotSimulation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#getting data
data(parameters)
data(driverA)

#simulating population dynamics
# of first taxon in parameters
# for first 500 values of driverA
sim.output &lt;- simulatePopulation(
 parameters=parameters[1,],
 driver.A=driverA[1:500]
 )

#checking output
str(sim.output)

</code></pre>

<hr>
<h2 id='simulation'>List with simulation outputs for all virtual taxa in <code><a href="#topic+parameters">parameters</a></code>.</h2><span id='topic+simulation'></span>

<h3>Description</h3>

<p>A list of dataframes with 4 slots, output of <code><a href="#topic+simulatePopulation">simulatePopulation</a></code>, taking <code><a href="#topic+parameters">parameters</a></code> and <code><a href="#topic+drivers">drivers</a></code> as inputs. Each dataframe in the list has the following columns:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(simulation)
</code></pre>


<h3>Format</h3>

<p>List with 4 dataframes with outputs of <code><a href="#topic+simulatePopulation">simulatePopulation</a></code>.
</p>


<h3>Details</h3>


<ul>
<li> <p><em>Time</em>: integer, ages in years. Negative ages indicate the burn-in period.
</p>
</li>
<li> <p><em>Pollen</em>: numeric, pollen counts
</p>
</li>
<li> <p><em>Population.mature</em>: numeric, number of mature individuals.
</p>
</li>
<li> <p><em>Population.immatre</em>: numeric, number of immature individuals.
</p>
</li>
<li> <p><em>Population.viable.seeds</em>: numeric, number of viable seeds generated each year.
</p>
</li>
<li> <p><em>Suitability</em>: numeric, environmental suitability computed from the driver by the normal function/s defining the taxon niche.
</p>
</li>
<li> <p><em>Biomass.total</em>: numeric, overall biomass of the population.
</p>
</li>
<li> <p><em>Biomass.mature</em>: numeric, sum of biomass of mature individuals.
</p>
</li>
<li> <p><em>Biomass.immature</em>: numeric, sum of biomass of immature individuals.
</p>
</li>
<li> <p><em>Mortality.mature</em>: numeric, number of mature individuals dead each year.
</p>
</li>
<li> <p><em>Mortality.immature</em>: numeric, same as above for immature individuals.
</p>
</li>
<li> <p><em>Driver.A</em>: numeric, values of driver A.
</p>
</li>
<li> <p><em>Driver.B</em>: numeric, values of driver B, if available, and NA otherwise.
</p>
</li>
<li> <p><em>Period</em>: qualitative, with value &quot;Burn-in&quot; for burn-in period, and &quot;Simulation&quot; otherwise.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Blas M. Benito  &lt;blasbenito@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulatePopulation">simulatePopulation</a></code>, <code><a href="#topic+plotSimulation">plotSimulation</a></code>
</p>

<hr>
<h2 id='toRegularTime'>Reinterpolates aggregated simulations into regular time.</h2><span id='topic+toRegularTime'></span>

<h3>Description</h3>

<p>Takes the output of <code><a href="#topic+aggregateSimulation">aggregateSimulation</a></code>, and interpolates it into a regular time grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toRegularTime(
  x = NULL,
  time.column = "Time",
  interpolation.interval = NULL,
  columns.to.interpolate = c("Suitability",
                             "Driver.A",
                             "Pollen")
  )
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="toRegularTime_+3A_x">x</code></td>
<td>
<p>list of dataframes (generally the output of <code><a href="#topic+aggregateSimulation">aggregateSimulation</a></code>) or single dataframe  with irregular time series.</p>
</td></tr>
<tr><td><code id="toRegularTime_+3A_time.column">time.column</code></td>
<td>
<p>character string, default value is &quot;Time&quot;.</p>
</td></tr>
<tr><td><code id="toRegularTime_+3A_interpolation.interval">interpolation.interval</code></td>
<td>
<p>integer, in years, time length encompassed by each sample.</p>
</td></tr>
<tr><td><code id="toRegularTime_+3A_columns.to.interpolate">columns.to.interpolate</code></td>
<td>
<p>character string or character vector, columns of simulation output to be interpolated. Any subset of: &quot;Pollen&quot;, &quot;Population.mature&quot;, &quot;Population.immature&quot;, &quot;Population.viable.seeds&quot;, &quot;Suitability&quot;, &quot;Biomass.total&quot;, &quot;Biomass.mature&quot;, &quot;Biomass.immature&quot;, &quot;Mortality.mature&quot;, &quot;Mortality.immature&quot;, &quot;Driver.A&quot;, &quot;Driver.B&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fits a <code><a href="stats.html#topic+loess">loess</a></code> model of the form <code>y ~ x</code>, where <code>y</code> is any column given by <code>columns.to.interpolate</code> and <code>x</code> is the column given by the <code>time.column</code> argument. The model is used to interpolate column <code>y</code> on a regular time series of intervals equal to <code>interpolation.interval</code>. If <code>x</code> is a matrix-like list returned by <code><a href="#topic+aggregateSimulation">aggregateSimulation</a></code> (on results of <code><a href="#topic+simulateAccumulationRate">simulateAccumulationRate</a></code> and <code><a href="#topic+simulatePopulation">simulatePopulation</a></code>), the first column of the matrix will already have a regular time column, and therefore nothing will be done with this column of the list.
</p>


<h3>Value</h3>

<p>If <code>x</code> is a list of dataframes, the function returns a list with the same structure as the input list. If <code>x</code> is a dataframe, the function returns a dataframe. In any case, output dataframes have the columns &quot;Time&quot; (now regular), and any column listed in <code>columns.to.interpolate</code>. <strong>Important</strong>: as in the input data, the <code>time</code> column of the output data has lower time for oldest samples and higher time for newest samples.
</p>


<h3>Author(s)</h3>

<p>Blas M. Benito  &lt;blasbenito@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulateAccumulationRate">simulateAccumulationRate</a></code>, <code><a href="#topic+aggregateSimulation">aggregateSimulation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
#getting example data
data(simulation)
data(accumulationRate)

#aggregating first simulation outcome
sim.output.aggregated &lt;- aggregateSimulation(
 simulation.output = simulation[1],
 accumulation.rate = accumulationRate,
 sampling.intervals = c(2,6))

#to regular time
sim.output.aggregated &lt;- toRegularTime(
 x=sim.output.aggregated,
 time.column ="Time",
 interpolation.interval = 10,
 columns.to.interpolate = c("Suitability", "Pollen")
)

#comparing simulations
par(mfrow = c(3,1))
#notice the subsetting of the given column of the input list
plot(sim.output.aggregated[[1,1]]$Time,
    sim.output.aggregated[[1,1]]$Pollen,
    type = "l",
    xlim = c(500, 1000),
    main = "Annual"
)
plot(sim.output.aggregated[[1,2]]$Time,
    sim.output.aggregated[[1,2]]$Pollen,
    type = "l",
    xlim = c(500, 1000),
    main = "2cm"
)
plot(sim.output.aggregated[[1,3]]$Time,
    sim.output.aggregated[[1,3]]$Pollen,
    type = "l",
    xlim = c(500, 1000),
    main = "6cm"
)

#check differences in nrow
nrow(sim.output.aggregated[[1,1]]) #original data
nrow(sim.output.aggregated[[1,2]]) #2cm
nrow(sim.output.aggregated[[1,3]]) #6cm intervals

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
