<!DOCTYPE html><html lang="en"><head><title>Help for package EPT</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {EPT}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#EPT-internal'><p>Internal EPT Functions</p></a></li>
<li><a href='#eptdecomp'><p>Decomposition of a signal by Ensemble Patch Transform</p></a></li>
<li><a href='#eptdecomp2d'><p>Decomposition of an Image by Two-dimensional Ensemble Patch Transform</p></a></li>
<li><a href='#eptmap'><p>Multiscale Visualization of Ensemble Patch Transform of a Signal</p></a></li>
<li><a href='#eptplot'><p>Plot of Components by Ensemble Patch Transform of a Signal</p></a></li>
<li><a href='#eptransf'><p>Ensemble Patch Transform of a Signal</p></a></li>
<li><a href='#eptransf2d'><p>Two-dimensional Ensemble Patch Transform of an Image</p></a></li>
<li><a href='#localextrema'><p>Finding Local Extrema and Zero-crossings of a Signal</p></a></li>
<li><a href='#LOD'><p>Length of Day Data</p></a></li>
<li><a href='#meptransf'><p>Multiscale Ensemble Patch Transforms of a Signal</p></a></li>
<li><a href='#meptransf2d'><p>Multiscale Two-dimensional Ensemble Patch Transforms of an Image</p></a></li>
<li><a href='#SolarRadiation'><p>Solar Radiation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.7.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-01-05</td>
</tr>
<tr>
<td>Title:</td>
<td>Ensemble Patch Transform, Visualization and Decomposition</td>
</tr>
<tr>
<td>Author:</td>
<td>Donghoh Kim [aut, cre],
  Hee-Seok Oh [aut],
  Guebin Choi [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Donghoh Kim &lt;donghoh.kim@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>For multiscale analysis, this package carries out ensemble patch transform, its visualization and multiscale decomposition. The detailed procedure is described in Kim et al. (2020), and Oh and Kim (2020). D. Kim, G. Choi, H.-S. Oh, Ensemble patch transformation: a flexible framework for decomposition and filtering of signal, EURASIP Journal on Advances in Signal Processing 30 (2020) 1-27 &lt;<a href="https://doi.org/10.1186%2Fs13634-020-00690-7">doi:10.1186/s13634-020-00690-7</a>&gt;. H.-S. Oh, D. Kim, Image decomposition by bidimensional ensemble patch transform, Pattern Recognition Letters 135 (2020) 173-179 &lt;<a href="https://doi.org/10.1016%2Fj.patrec.2020.03.029">doi:10.1016/j.patrec.2020.03.029</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-12-30 04:40:11 UTC; donghohkim</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-01-05 01:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='EPT-internal'>Internal EPT Functions</h2><span id='topic+EPT-internal'></span><span id='topic+chooseindex2d'></span>

<h3>Description</h3>

<p>The <code>chooseindex2d</code> is internal EPT functions.
</p>


<h3>Details</h3>

<p>These are not to be called by the user.
</p>

<hr>
<h2 id='eptdecomp'>Decomposition of a signal by Ensemble Patch Transform</h2><span id='topic+eptdecomp'></span>

<h3>Description</h3>

<p>This function decomposes a signal into frequency component and residue of ensemble patch transform by sifting process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eptdecomp(tindex = NULL, signal, type = "rectangle", tau, 
    process = c("average", "average"), pquantile = c(0, 1), equantile = c(0, 1), 
    gamma = 1, boundary = "symmetric", stoprule = "type1", 
    tol = sd(signal, na.rm = TRUE) * 0.1^2, maxiter = 10, check = FALSE) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eptdecomp_+3A_tindex">tindex</code></td>
<td>
<p>time index at which a signal is observed. When it is <code>NULL</code>, the signal is supposed to be equally spaced.</p>
</td></tr>
<tr><td><code id="eptdecomp_+3A_signal">signal</code></td>
<td>
<p>a set of data or a signal observed at time <code>tindex</code>.</p>
</td></tr>
<tr><td><code id="eptdecomp_+3A_type">type</code></td>
<td>
<p>patch type of <code>"rectangle"</code> or <code>"oval"</code>.</p>
</td></tr>
<tr><td><code id="eptdecomp_+3A_tau">tau</code></td>
<td>
<p>a size parameter for ensemble patch transform.</p>
</td></tr>
<tr><td><code id="eptdecomp_+3A_process">process</code></td>
<td>
<p>specifies transform types for patch and ensemble processes:
<code>process[1]</code> for patch process and process[2] for ensemble process.
Each process has options of <code>"average"</code>, <code>"median"</code>, or <code>"envelope"</code>.
Note that when <code>process[1]</code> is <code>"average"</code> or <code>"median"</code>, <code>process[2]</code> must be <code>"average"</code> or <code>"median"</code>. 
When <code>process[1]</code> is <code>"envelope"</code>, lower and upper envelopes are obtained by <code class="reqn">\code{pquantile[1]} \times 100 \%</code>-quantile 
and <code class="reqn">\code{pquantile[2]} \times 100 \%</code>-quantile of patches, respectively.
When <code>process[2]</code> is <code>"envelope"</code>, ensemble lower and upper envelopes are obtained as 
<code class="reqn">\code{equantile[1]} \times 100 \%</code>-quantile and <code class="reqn">\code{equantile[2]} \times 100 \%</code>-quantile  
of lower and upper envelopes of shifted patches, respectively.</p>
</td></tr>
<tr><td><code id="eptdecomp_+3A_pquantile">pquantile</code></td>
<td>
<p>quantiles for lower and upper envelopes of patch transform. When it is <code>c(0, 1)</code>,
minimum and maximum of a patch are used for lower and upper envelopes, respectively.</p>
</td></tr>
<tr><td><code id="eptdecomp_+3A_equantile">equantile</code></td>
<td>
<p>quantiles for lower and upper envelopes of ensemble patch transform.</p>
</td></tr>            
<tr><td><code id="eptdecomp_+3A_gamma">gamma</code></td>
<td>
<p>controls the amount of envelope magnitude.</p>
</td></tr>
<tr><td><code id="eptdecomp_+3A_boundary">boundary</code></td>
<td>
<p>specifies boundary condition from <code>"symmetric"</code>, <code>"periodic"</code> or <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="eptdecomp_+3A_stoprule">stoprule</code></td>
<td>
<p>stopping rule of sifting. The <code>type1</code> stopping rule indicates that absolute values of ept (ensemble patch transform) component must be less than the user-specified tolerance level.
The <code>type2</code> is the stopping rule that the difference between ept components at the current and previous iterative steps must be less than the user-specified tolerance level.</p>
</td></tr>
<tr><td><code id="eptdecomp_+3A_tol">tol</code></td>
<td>
<p>tolerance for stopping rule of sifting.</p>
</td></tr>
<tr><td><code id="eptdecomp_+3A_maxiter">maxiter</code></td>
<td>
<p>the maximum number of sifting.</p>
</td></tr>
<tr><td><code id="eptdecomp_+3A_check">check</code></td>
<td>
<p>specifies whether the sifting process is displayed. When <code>check = TRUE</code>, ept component and residue for each sifting step are displayed. If <code>check=TRUE</code>, click the plotting area to start the next step.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function decomposes a signal into frequency component and residue of ensemble patch transform by sifting process for a size parameter.
</p>


<h3>Value</h3>

 
<table role = "presentation">
<tr><td><code>eptcomp</code></td>
<td>
<p>matrix of ept (ensemble patch transform) component at each sifting step.</p>
</td></tr>
<tr><td><code>FC</code></td>
<td>
<p>frequency component of ensemble patch transform by sifting process.</p>
</td></tr>
<tr><td><code>residue</code></td>
<td>
<p>residue of ensemble patch transform by sifting process.</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>a list of input parameters of <code>type</code>, <code>tau</code>, <code>process</code>, <code>pquantile</code>, <code>equantile</code>, <code>gamma</code>, <code>boundary</code>, 
and output parameter <code>niter</code>, the number of sifting.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+eptransf">eptransf</a></code>, <code><a href="#topic+meptransf">meptransf</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### example : composite of two components having different frequencies
ndata &lt;- 1000 
tindex &lt;- seq(0, 1, length=ndata)
comp1 &lt;- cos(90*pi*tindex)
comp2 &lt;- cos(10*pi*tindex)
f &lt;- comp1 + comp2 

op &lt;- par(mfrow=c(3,1), mar=c(2,2,2,1))
plot(tindex, f, main="a signal", xlab="", ylab="", type='l')
abline(h=0, lty=3)
plot(tindex, comp1, main="high-frequency component", xlab="", ylab="", type='l')
abline(h=0, lty=3)
plot(tindex, comp2, main="low-frequency component", xlab="", ylab="", type='l')
abline(h=0, lty=3)

#### Decomposition by Ensemble Patch Transform  
outdecom &lt;- eptdecomp(signal=f, tau=21, process=c("envelope", "average"), pquantile=c(0, 1))

#### Decomposition result
plot(tindex, f, main="a signal", xlab="", ylab="", type='l'); abline(h=0, lty=3)
plot(outdecom$FC, type='l', main="", xlab="", ylab=""); abline(h=0, lty=3)
title(paste0("high-frequency component, tau=", 21))
lines(comp1, col="red", lty=2, lwd=0.5)
plot(outdecom$residue, type="l", main="", xlab="", ylab=""); abline(h=0, lty=3)
title(paste0("low-frequency component, tau=", 21))
lines(comp2, col="red", lty=2, lwd=0.5)
par(op)
</code></pre>

<hr>
<h2 id='eptdecomp2d'>Decomposition of an Image by Two-dimensional Ensemble Patch Transform</h2><span id='topic+eptdecomp2d'></span>

<h3>Description</h3>

<p>This function decomposes an image into frequency component and residue of two-dimensional ensemble patch transform by sifting process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eptdecomp2d(x = NULL, y = NULL, z, type = "rectangle", tau, theta = 0, 
    process = c("average", "average"), pquantile = c(0, 1), equantile = c(0, 1), 
    gamma = 1, boundary = "reflexive", 
    stoprule = "type2", tol = 0.1^2, maxiter = 10, check = FALSE) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eptdecomp2d_+3A_x">x</code>, <code id="eptdecomp2d_+3A_y">y</code></td>
<td>
<p>locations of regular grid at which the values in image <code>z</code> are measured. When it is <code>NULL</code>, the image is supposed to be equally spaced.</p>
</td></tr>
<tr><td><code id="eptdecomp2d_+3A_z">z</code></td>
<td>
<p>matrix of an image observed at location <code>(x, y)</code>.</p>
</td></tr>
<tr><td><code id="eptdecomp2d_+3A_type">type</code></td>
<td>
<p>patch type of <code>"rectangle"</code> or <code>"oval"</code>.</p>
</td></tr>
<tr><td><code id="eptdecomp2d_+3A_tau">tau</code></td>
<td>
<p>a size parameter for two-dimensional ensemble patch transform: <code>tau[1]</code> for horizontal size and tau[2] for vertical size of a two-dimensional patch.
When <code>length(tau)</code> is 1, the horizontal and vertical size are the same.</p>
</td></tr>
<tr><td><code id="eptdecomp2d_+3A_theta">theta</code></td>
<td>
<p>a degree of clockwise rotation of a patch.</p>
</td></tr>
<tr><td><code id="eptdecomp2d_+3A_process">process</code></td>
<td>
<p>specifies transform types for patch and ensemble processes:
<code>process[1]</code> for patch process and process[2] for ensemble process.
Each process has options of <code>"average"</code>, <code>"median"</code>, or <code>"envelope"</code>.
Note that when <code>process[1]</code> is <code>"average"</code> or <code>"median"</code>, <code>process[2]</code> must be <code>"average"</code> or <code>"median"</code>. 
When <code>process[1]</code> is <code>"envelope"</code>, lower and upper envelopes are obtained by <code class="reqn">\code{pquantile[1]} \times 100 \%</code>-quantile 
and <code class="reqn">\code{pquantile[2]} \times 100 \%</code>-quantile of patches, respectively.
When <code>process[2]</code> is <code>"envelope"</code>, ensemble lower and upper envelopes are obtained as 
<code class="reqn">\code{equantile[1]} \times 100 \%</code>-quantile and <code class="reqn">\code{equantile[2]} \times 100 \%</code>-quantile  
of lower and upper envelopes of shifted patches, respectively.</p>
</td></tr>
<tr><td><code id="eptdecomp2d_+3A_pquantile">pquantile</code></td>
<td>
<p>quantiles for lower and upper envelopes of patch transform. When it is <code>c(0, 1)</code>,
minimum and maximum of a patch are used for lower and upper envelopes, respectively.</p>
</td></tr>
<tr><td><code id="eptdecomp2d_+3A_equantile">equantile</code></td>
<td>
<p>quantiles for lower and upper envelopes of ensemble patch transform.</p>
</td></tr>            
<tr><td><code id="eptdecomp2d_+3A_gamma">gamma</code></td>
<td>
<p>controls the amount of envelope magnitude.</p>
</td></tr>
<tr><td><code id="eptdecomp2d_+3A_boundary">boundary</code></td>
<td>
<p>specifies boundary condition from <code>"reflexive"</code>, <code>"periodic"</code> or <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="eptdecomp2d_+3A_stoprule">stoprule</code></td>
<td>
<p>stopping rule of sifting. The <code>type1</code> stopping rule indicates that absolute values of ept  (ensemble patch transform) component must be less than the user-specified tolerance level.
The <code>type2</code> is the stopping rule that the difference between ept components at the current and previous iterative steps must be less than the user-specified tolerance level.</p>
</td></tr>
<tr><td><code id="eptdecomp2d_+3A_tol">tol</code></td>
<td>
<p>tolerance for stopping rule of sifting.</p>
</td></tr>
<tr><td><code id="eptdecomp2d_+3A_maxiter">maxiter</code></td>
<td>
<p>the maximum number of sifting.</p>
</td></tr>
<tr><td><code id="eptdecomp2d_+3A_check">check</code></td>
<td>
<p>specifies whether the sifting process is displayed. When <code>check = TRUE</code>, ept component and residue for each sifting step are displayed. If <code>check=TRUE</code>, click the plotting area to start the next step.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function decomposes an image into frequency component and residue of two-dimensional ensemble patch transform by sifting process for a size parameter.
</p>


<h3>Value</h3>

 
<table role = "presentation">
<tr><td><code>eptcomp</code></td>
<td>
<p>list of ept (ensemble patch transform) component at each sifting step when <code>check=TRUE</code>.</p>
</td></tr>
<tr><td><code>FC</code></td>
<td>
<p>frequency component of ensemble patch transform by sifting process.</p>
</td></tr>
<tr><td><code>residue</code></td>
<td>
<p>residue of ensemble patch transform by sifting process.</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>a list of input parameters of <code>type</code>, <code>tau</code>, <code>theta</code>, <code>process</code>, <code>pquantile</code>, <code>equantile</code>, <code>gamma</code>, <code>boundary</code>, 
and output parameter <code>niter</code>, the number of sifting.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+eptransf2d">eptransf2d</a></code>, <code><a href="#topic+meptransf2d">meptransf2d</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### example : composite of two components having different frequencies
nr &lt;- nc &lt;- 128; x &lt;- seq(0, 1, length=nr); y &lt;- seq(0, 1, length=nc)

coscomp1 &lt;- outer(cos(20 * pi * x), cos(20 * pi * y))
coscomp2 &lt;- outer(cos(5* pi * x), cos(5 * pi * y))
cosmeanf &lt;- coscomp1 + coscomp2

op &lt;- par(mfcol=c(3,1), mar=c(0,0.5,2,0.5))
image(cosmeanf, xlab="", ylab="", col=gray(0:100/100), axes=FALSE, main="a composite image")
image(coscomp1, xlab="", ylab="", col=gray(0:100/100), axes=FALSE, main="high-frequency component")
image(coscomp2, xlab="", ylab="", col=gray(0:100/100), axes=FALSE, main="low-frequency component")


#### Decomposition by Ensemble Patch Transform  
outcossift &lt;- eptdecomp2d(z=cosmeanf, tau=8)

#### Decomposition Result
op &lt;- par(mfrow=c(2,2), mar=c(2,2,2,1))
image(outcossift$FC, xlab="", ylab="", col=gray(0:100/100), axes=FALSE, main="Decomposed HF")
persp(outcossift$FC, theta = -30, phi = 45, col = "white", xlab="X", ylab="Y", main="Decomposed HF")
image(outcossift$residue, xlab="", ylab="", col=gray(0:100/100), axes=FALSE, main="Residue")
persp(outcossift$residue, theta = -30, phi = 45, col = "white", xlab="X", ylab="Y", main="Residue")

par(op)
</code></pre>

<hr>
<h2 id='eptmap'>Multiscale Visualization of Ensemble Patch Transform of a Signal</h2><span id='topic+eptmap'></span>

<h3>Description</h3>

<p>This function displays time-scale representation of ensemble patch transform of a signal for a sequence of size parameters.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eptmap(eptransf, taus = eptransf$parameters$tau, maptype = c("C", "D", "DC", "DD"), 
    stat = c("pstat", "Epstat", "pM", "EpM", "psd", "Epsd"),
    der = c("time", "tau"), ncolor = 100, ...) 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eptmap_+3A_eptransf">eptransf</code></td>
<td>
<p>R object of ensemble patch transform by <code>eptransf()</code> or <code>meptransf()</code>.</p>
</td></tr>
<tr><td><code id="eptmap_+3A_taus">taus</code></td>
<td>
<p>specifies size parameters for time-scale visualization.</p>
</td></tr>
<tr><td><code id="eptmap_+3A_maptype">maptype</code></td>
<td>
<p>specifies <code>"C"</code> for centrality map, <code>"D"</code> for dispersion map, <code>"DC"</code> for derivative of centrality map and <code>"DD"</code> for derivative of dispersion map.</p>
</td></tr>
<tr><td><code id="eptmap_+3A_stat">stat</code></td>
<td>
<p><code>"pstat"</code> for centrality of patch transform, <code>"Epstat"</code> for centrality of ensemble patch transform, 
<code>"pM"</code> for mean envelope of patch transform, <code>"EpM"</code> for mean envelope of ensemble patch transform, 
<code>"psd"</code> for standard deviation of patch transform and <code>"Epsd"</code> for standard deviation of ensemble patch transform.</p>
</td></tr>
<tr><td><code id="eptmap_+3A_der">der</code></td>
<td>
<p>specifies derivative with respect to <code>"time"</code> or <code>"tau"</code>.</p>
</td></tr>
<tr><td><code id="eptmap_+3A_ncolor">ncolor</code></td>
<td>
<p>the number of colors (<code class="reqn">\ge 1</code>) to be in the palette.</p>
</td></tr>
<tr><td><code id="eptmap_+3A_...">...</code></td>
<td>
<p>graphical parameters for image.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs multiscale visualization of ensemble patch transform of a signal for a sequence of size parameters. 
This function creates images with <code>heat.colors(ncolor)</code> colors.
</p>


<h3>Value</h3>

<p>image
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eptransf">eptransf</a></code>, <code><a href="#topic+meptransf">meptransf</a></code>, <code><a href="#topic+eptplot">eptplot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a doppler signal
n &lt;- 1000
tindex &lt;- seq(0, 1, length=n)
j &lt;- 5
f &lt;- 10 * sqrt(tindex*(1-tindex)) * sin((2*pi*(1+2^((9-4*j)/5))) / (tindex+2^((9-4*j)/5)))

set.seed(7)
fnoise &lt;- f + 0.4 * rnorm(n)

op &lt;- par(mar=c(2,2,2,1))
plot(f, type="l", , xlab="", ylab="", ylim=range(fnoise))
points(fnoise, cex=0.3)


taus &lt;- seq(4, 64, by=4)

# try1 : Multiscale EPT by average patch transform and average ensemble transform 
try1 &lt;- meptransf(tindex=tindex, signal=fnoise, taus=taus, process=c("average", "average"))

par(mfrow=c(2,2))
eptmap(try1, maptype="C", stat="pstat", main="centrality of patch transform")
eptmap(try1, maptype="D", stat="psd", main="standard deviation of patch transform")
eptmap(try1, maptype="C", stat="Epstat", main="centrality of ensemble patch transform")
eptmap(try1, maptype="D", stat="Epsd", main="standard deviation of ensemble patch transform")

eptmap(try1, maptype="DC", stat="Epstat", der="time", 
    main="derivative of centrality w.r.t time")
eptmap(try1, maptype="DC", stat="Epstat", der="tau", 
    main="derivative of centrality w.r.t tau")
eptmap(try1, maptype="DD", stat="Epsd", der="time", 
    main="derivative of standard deviation w.r.t time")
eptmap(try1, maptype="DD", stat="Epsd", der="tau", 
    main="derivative of standard deviation w.r.t tau", ncolor=70)

# try2 : Multiscale EPT by envelope patch transform and average ensemble transform 
try2 &lt;- meptransf(tindex=tindex, signal=fnoise, taus=taus, process=c("envelope", "average"),
    pquantile=c(0, 1))

eptmap(try2, maptype="C", stat="pM", main="mean envelope of patch transform")
eptmap(try2, maptype="C", stat="EpM", main="mean envelope of ensemble patch transform")
eptmap(try2, maptype="DC", stat="EpM", der="time", 
    main="derivative of mean envelope w.r.t time")
eptmap(try2, maptype="DC", stat="EpM", der="tau", 
    main="derivative of mean envelope w.r.t time")

par(op)
</code></pre>

<hr>
<h2 id='eptplot'>Plot of Components by Ensemble Patch Transform of a Signal</h2><span id='topic+eptplot'></span>

<h3>Description</h3>

<p>This function plots ensemble patch transform of a signal for a sequence of size parameters tau's.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eptplot(eptransf, taus = eptransf$parameters$tau)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eptplot_+3A_eptransf">eptransf</code></td>
<td>
<p>R object of ensemble patch transform by <code>eptransf()</code> or <code>meptransf()</code>.</p>
</td></tr>
<tr><td><code id="eptplot_+3A_taus">taus</code></td>
<td>
<p>specifies size parameters for which ensemble patch transform of a signal is displayed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots ensemble patch transform of a signal for a sequence of size parameters <code>taus</code>.  
</p>


<h3>Value</h3>

<p>plot
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eptransf">eptransf</a></code>, <code><a href="#topic+meptransf">meptransf</a></code>, <code><a href="#topic+eptmap">eptmap</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 500                                                                      
set.seed(1)
x &lt;- c(rnorm(n), arima.sim(list(order = c(1,0,0), ar = 0.9), n = n, sd=sqrt(1-0.9^2)))

taus &lt;- seq(10, 100, by=10)

# eptr1 : Multiscale EPT by average patch transform and average ensemble transform 
eptr1 &lt;- meptransf(tindex=1:(2*n), signal=x, taus=taus, process=c("average", "average"), 
    boundary="none")
names(eptr1)

op &lt;- par(mfcol=c(4,1), mar=c(4,2,2,0.1))
plot(x, xlab="", type="l", main="signal")

eptplot(eptr1)
eptplot(eptr1, taus=20)
eptplot(eptr1, taus=c(20, 30))
lines(eptr1$Epstat[, 2], col="blue")
lines(eptr1$Epstat[, 3], col="red")

# eptr2 : Multiscale EPT by envelope patch transform and average ensemble transform 
eptr2 &lt;- meptransf(tindex=1:(2*n), signal=x, type="oval", taus=taus, 
    process=c("envelope", "average"), pquantile=c(0,1), gamma=0.06, boundary="none")
names(eptr2)

plot(x, xlab="", type="l")
eptplot(eptr2)
eptplot(eptr2, taus=20)
eptplot(eptr2, taus=c(20, 30))
lines(eptr2$EpM[, 2], col="blue")
lines(eptr2$EpM[, 3], col="red")
par(op)
</code></pre>

<hr>
<h2 id='eptransf'>Ensemble Patch Transform of a Signal</h2><span id='topic+eptransf'></span>

<h3>Description</h3>

<p>This function performs ensemble patch transform of a signal for a size parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eptransf(tindex = NULL, signal, type = "rectangle", tau,
    process = c("average", "average"), pquantile = c(0, 1), equantile = c(0, 1), 
    gamma = 1, boundary = "symmetric") 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eptransf_+3A_tindex">tindex</code></td>
<td>
<p>time index at which a signal is observed. When it is <code>NULL</code>, the signal is supposed to be equally spaced.</p>
</td></tr>
<tr><td><code id="eptransf_+3A_signal">signal</code></td>
<td>
<p>a set of data or a signal observed at time <code>tindex</code>.</p>
</td></tr>
<tr><td><code id="eptransf_+3A_type">type</code></td>
<td>
<p>patch type of <code>"rectangle"</code> or <code>"oval"</code>.</p>
</td></tr>
<tr><td><code id="eptransf_+3A_tau">tau</code></td>
<td>
<p>size parameter for ensemble patch transform.</p>
</td></tr>
<tr><td><code id="eptransf_+3A_process">process</code></td>
<td>
<p>specifies transform types for patch and ensemble processes:
<code>process[1]</code> for patch process and process[2] for ensemble process.
Each process has options of <code>"average"</code>, <code>"median"</code>, or <code>"envelope"</code>.
Note that when <code>process[1]</code> is <code>"average"</code> or <code>"median"</code>, <code>process[2]</code> must be <code>"average"</code> or <code>"median"</code>. 
When <code>process[1]</code> is <code>"envelope"</code>, lower and upper envelopes are obtained by <code class="reqn">\code{pquantile[1]} \times 100 \%</code>-quantile 
and <code class="reqn">\code{pquantile[2]} \times 100 \%</code>-quantile of patches, respectively.
When <code>process[2]</code> is <code>"envelope"</code>, ensemble lower and upper envelopes are obtained as 
<code class="reqn">\code{equantile[1]} \times 100 \%</code>-quantile and <code class="reqn">\code{equantile[2]} \times 100 \%</code>-quantile  
of lower and upper envelopes of shifted patches, respectively.</p>
</td></tr>
<tr><td><code id="eptransf_+3A_pquantile">pquantile</code></td>
<td>
<p>quantiles for lower and upper envelopes of patch transform. When it is <code>c(0, 1)</code>,
minimum and maximum of a patch are used for lower and upper envelopes, respectively.</p>
</td></tr>
<tr><td><code id="eptransf_+3A_equantile">equantile</code></td>
<td>
<p>quantiles for lower and upper envelopes of ensemble patch transform.</p>
</td></tr>            
<tr><td><code id="eptransf_+3A_gamma">gamma</code></td>
<td>
<p>controls the amount of envelope magnitude.</p>
</td></tr>
<tr><td><code id="eptransf_+3A_boundary">boundary</code></td>
<td>
<p>specifies boundary condition from <code>"symmetric"</code>, <code>"periodic"</code> or <code>"none"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs ensemble patch transform of a signal for a size parameter <code>tau</code>, and 
produces statistics and envelopes for ensemble patch transform.
When <code>process[1]</code> is <code>"average"</code> or <code>"median"</code>, outputs related to envelopes are defined as <code>NULL</code>.
When <code>process[2]</code> is <code>"envelope"</code>, outputs, <code>pstat</code> and <code>Epstat</code>, are defined as <code>NULL</code>.
</p>


<h3>Value</h3>

 
<table role = "presentation">
<tr><td><code>tindex</code></td>
<td>
<p>time index at which a signal is observed.</p>
</td></tr>
<tr><td><code>signal</code></td>
<td>
<p>a set of data or a signal observed at time <code>tindex</code>.</p>
</td></tr>
<tr><td><code>pstat</code></td>
<td>
<p>centrality of patch transform for size parameter <code>tau</code>.</p>
</td></tr>
<tr><td><code>Epstat</code></td>
<td>
<p>centrality of ensemble patch transform for size parameter <code>tau</code>.</p>
</td></tr>
<tr><td><code>psd</code></td>
<td>
<p>standard deviation of patch transform for size parameter <code>tau</code>.</p>
</td></tr>
<tr><td><code>Epsd</code></td>
<td>
<p>standard deviation of ensemble patch transform for size parameter <code>tau</code>.</p>
</td></tr>
<tr><td><code>pL</code></td>
<td>
<p>lower envelope of patch transform for size parameter <code>tau</code>.</p>
</td></tr>
<tr><td><code>pU</code></td>
<td>
<p>upper envelope of patch transform for size parameter <code>tau</code>.</p>
</td></tr>
<tr><td><code>pM</code></td>
<td>
<p>mean envelope, <code>(pL + pU) / 2</code>, of patch transform for size parameter <code>tau</code>.</p>
</td></tr>
<tr><td><code>pR</code></td>
<td>
<p>distance between lower and upper envelopes, <code>(pU - pL)</code>, of patch transform for size parameter <code>tau</code>.</p>
</td></tr>
<tr><td><code>EpL</code></td>
<td>
<p>lower envelope of ensemble patch transform for size parameter <code>tau</code>.</p>
</td></tr>
<tr><td><code>EpU</code></td>
<td>
<p>upper envelope of ensemble patch transform for size parameter <code>tau</code>.</p>
</td></tr>
<tr><td><code>EpM</code></td>
<td>
<p>mean envelope, <code>(EpL + EpU) / 2</code>, of ensemble patch transform for size parameter <code>tau</code>.</p>
</td></tr>
<tr><td><code>EpR</code></td>
<td>
<p>distance between lower and upper envelopes, <code>(EpU - EpL)</code>, of ensemble patch transform for size parameter <code>tau</code>.</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>a list of input parameters of <code>type</code>, <code>tau</code>, <code>process</code>, <code>pquantile</code>, <code>equantile</code>, <code>gamma</code>, and <code>boundary</code>.</p>
</td></tr>
<tr><td><code>nlevel</code></td>
<td>
<p>the number of size parameter <code>tau</code>. For <code>eptransf()</code> function, <code>nlevel</code> is 1.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+meptransf">meptransf</a></code>, <code><a href="#topic+eptdecomp">eptdecomp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># a doppler signal
n &lt;- 256
tindex &lt;- seq(0, 1, length=n)
j &lt;- 5
f &lt;- 10 * sqrt(tindex*(1-tindex)) * sin((2*pi*(1+2^((9-4*j)/5))) / (tindex+2^((9-4*j)/5)))
fnoise &lt;- f + 0.4 * rnorm(n)
  
#### Ensemble statistics
op &lt;- par(mfrow=c(5,3), mar=c(2,2,2,1))
layout(matrix(c(1, 1, 1, 2:13), 5, 3, byrow = TRUE))

plot(f, main="a doppler signal", xlab="", ylab="", type='l', ylim=range(fnoise))
points(fnoise); abline(h=0, lty=3)

#### Ensemble Patch Transform  
taus &lt;- c(5, 10, 20)

out &lt;- list()
for (i in 1:length(taus)) 
    out[[i]] &lt;- eptransf(signal=fnoise, tau=taus[i], process=c("average", "average"))
    
for (i in 1:length(taus)) {
    plot(out[[i]]$Epstat, type="l", xlab="", ylab="",
        main=paste0("ensemble average of patch mean, tau=", taus[i]))
    abline(h=0, lty=3)   
}

for (i in 1:length(taus)) 
    plot(out[[i]]$Epsd, type='l', xlab="", ylab="", 
         main=paste0("ensemble average of standard deviation, tau=", taus[i]))  

out2 &lt;- list()
for (i in 1:length(taus)) 
    out2[[i]] &lt;- eptransf(signal=fnoise, tau=taus[i], process=c("envelope", "average"))
    
for (i in 1:length(taus)) {
    plot(out2[[i]]$EpM, type="l", col="red", xlab="", ylab="", 
         ylim=range(c(out2[[i]]$EpU,out2[[i]]$EpL)),
         main=paste0("ensemble average of mean envelope, tau=", taus[i]))
    points(fnoise, cex=0.1)
    abline(h=0, lty=3); lines(out2[[i]]$EpU); lines(out2[[i]]$EpL)    
}

for (i in 1:length(taus))
    plot(out2[[i]]$EpR, type='l', xlab="", ylab="",
         main=paste0("ensemble average of envelope distance, tau=", taus[i]))
         
par(op)
</code></pre>

<hr>
<h2 id='eptransf2d'>Two-dimensional Ensemble Patch Transform of an Image</h2><span id='topic+eptransf2d'></span>

<h3>Description</h3>

<p>This function performs two-dimensional ensemble patch transform of an image for a size parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
eptransf2d(x = NULL, y = NULL, z, type = "rectangle", tau, theta = 0, 
    process = c("average", "average"), pquantile = c(0, 1), equantile = c(0, 1), 
    gamma = 1, boundary = "reflexive") 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eptransf2d_+3A_x">x</code>, <code id="eptransf2d_+3A_y">y</code></td>
<td>
<p>locations of regular grid at which the values in image <code>z</code> are measured. When those are <code>NULL</code>, the image is supposed to be equally spaced.</p>
</td></tr>
<tr><td><code id="eptransf2d_+3A_z">z</code></td>
<td>
<p>matrix of an image observed at location <code>(x, y)</code>.</p>
</td></tr>
<tr><td><code id="eptransf2d_+3A_type">type</code></td>
<td>
<p>patch type of <code>"rectangle"</code> or <code>"oval"</code>.</p>
</td></tr>
<tr><td><code id="eptransf2d_+3A_tau">tau</code></td>
<td>
<p>a size parameter for two-dimensional ensemble patch transform: <code>tau[1]</code> for horizontal size and tau[2] for vertical size of a two-dimensional patch.
When <code>length(tau)</code> is 1, the horizontal and vertical size are the same.</p>
</td></tr>
<tr><td><code id="eptransf2d_+3A_theta">theta</code></td>
<td>
<p>a degree of clockwise rotation of a patch.</p>
</td></tr>
<tr><td><code id="eptransf2d_+3A_process">process</code></td>
<td>
<p>specifies transform types for patch and ensemble processes:
<code>process[1]</code> for patch process and process[2] for ensemble process.
Each process has options of <code>"average"</code>, <code>"median"</code>, or <code>"envelope"</code>.
Note that when <code>process[1]</code> is <code>"average"</code> or <code>"median"</code>, <code>process[2]</code> must be <code>"average"</code> or <code>"median"</code>. 
When <code>process[1]</code> is <code>"envelope"</code>, lower and upper envelopes are obtained by <code class="reqn">\code{pquantile[1]} \times 100 \%</code>-quantile 
and <code class="reqn">\code{pquantile[2]} \times 100 \%</code>-quantile of patches, respectively.
When <code>process[2]</code> is <code>"envelope"</code>, ensemble lower and upper envelopes are obtained as 
<code class="reqn">\code{equantile[1]} \times 100 \%</code>-quantile and <code class="reqn">\code{equantile[2]} \times 100 \%</code>-quantile  
of lower and upper envelopes of shifted patches, respectively.</p>
</td></tr>
<tr><td><code id="eptransf2d_+3A_pquantile">pquantile</code></td>
<td>
<p>quantiles for lower and upper envelopes of patch transform. When it is <code>c(0, 1)</code>,
minimum and maximum of a patch are used for lower and upper envelopes, respectively.</p>
</td></tr>
<tr><td><code id="eptransf2d_+3A_equantile">equantile</code></td>
<td>
<p>quantiles for lower and upper envelopes of ensemble patch transform.</p>
</td></tr>            
<tr><td><code id="eptransf2d_+3A_gamma">gamma</code></td>
<td>
<p>controls the amount of envelope magnitude.</p>
</td></tr>
<tr><td><code id="eptransf2d_+3A_boundary">boundary</code></td>
<td>
<p>specifies boundary condition from <code>"reflexive"</code>, <code>"periodic"</code> or <code>"none"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs two-dimensional ensemble patch transform of an image for a size parameter <code>tau</code>, and 
produces statistics and envelopes for two-dimensional ensemble patch transform.
When <code>process[1]</code> is <code>"average"</code> or <code>"median"</code>, outputs related to envelopes are defined as <code>NULL</code>.
When <code>process[2]</code> is <code>"envelope"</code>, outputs, <code>pstat</code> and <code>Epstat</code>, are defined as <code>NULL</code>.
</p>


<h3>Value</h3>

 
<table role = "presentation">
<tr><td><code>x</code>, <code>y</code></td>
<td>
<p>locations of regular grid at which the values in image <code>z</code> are measured. When it is <code>NULL</code>, the image is supposed to be equally spaced.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>matrix of an image observed at location <code>(x, y)</code>.</p>
</td></tr>
<tr><td><code>pstat</code></td>
<td>
<p>centrality of patch transform for size parameter <code>tau</code>.</p>
</td></tr>
<tr><td><code>Epstat</code></td>
<td>
<p>centrality of ensemble patch transform for size parameter <code>tau</code>.</p>
</td></tr>
<tr><td><code>psd</code></td>
<td>
<p>standard deviation of patch transform for size parameter <code>tau</code>.</p>
</td></tr>
<tr><td><code>Epsd</code></td>
<td>
<p>standard deviation of ensemble patch transform for size parameter <code>tau</code>.</p>
</td></tr>
<tr><td><code>pL</code></td>
<td>
<p>lower envelope of patch transform for size parameter <code>tau</code>.</p>
</td></tr>
<tr><td><code>pU</code></td>
<td>
<p>upper envelope of patch transform for size parameter <code>tau</code>.</p>
</td></tr>
<tr><td><code>pM</code></td>
<td>
<p>mean envelope, <code>(pL + pU) / 2</code>, of patch transform for size parameter <code>tau</code>.</p>
</td></tr>
<tr><td><code>pR</code></td>
<td>
<p>distance between lower and upper envelopes, <code>(pU - pL)</code>, of patch transform for size parameter <code>tau</code>.</p>
</td></tr>
<tr><td><code>EpL</code></td>
<td>
<p>lower envelope of ensemble patch transform for size parameter <code>tau</code>.</p>
</td></tr>
<tr><td><code>EpU</code></td>
<td>
<p>upper envelope of ensemble patch transform for size parameter <code>tau</code>.</p>
</td></tr>
<tr><td><code>EpM</code></td>
<td>
<p>mean envelope, <code>(EpL + EpU) / 2</code>, of ensemble patch transform for size parameter <code>tau</code>.</p>
</td></tr>
<tr><td><code>EpR</code></td>
<td>
<p>distance between lower and upper envelopes, <code>(EpU - EpL)</code>, of ensemble patch transform for size parameter <code>tau</code>.</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>a list of input parameters of <code>type</code>, <code>tau</code>, <code>theta</code>, <code>process</code>, <code>pquantile</code>, <code>equantile</code>, <code>gamma</code>, and <code>boundary</code>.</p>
</td></tr>
<tr><td><code>nlevel</code></td>
<td>
<p>the number of size parameter <code>tau</code>. For <code>eptransf2d()</code>, <code>nlevel</code> is 1.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+meptransf2d">meptransf2d</a></code>, <code><a href="#topic+eptdecomp2d">eptdecomp2d</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### example : composite of two components having different frequencies
nr &lt;- nc &lt;- 128; x &lt;- seq(0, 1, length=nr); y &lt;- seq(0, 1, length=nc)

coscomp1 &lt;- outer(cos(20 * pi * x), cos(20 * pi * y))
coscomp2 &lt;- outer(cos(5* pi * x), cos(5 * pi * y))
cosmeanf &lt;- coscomp1 + coscomp2

op &lt;- par(mfcol=c(3,1), mar=c(0,0.5,2,0.5))
image(cosmeanf, xlab="", ylab="", col=gray(0:100/100), axes=FALSE, main="a composite image")
image(coscomp1, xlab="", ylab="", col=gray(0:100/100), axes=FALSE, main="high-frequency component")
image(coscomp2, xlab="", ylab="", col=gray(0:100/100), axes=FALSE, main="low-frequency component")


#### Ensemble average of Ensemble Patch Transform
outcos &lt;- eptransf2d(z=cosmeanf, tau=12)
rangez &lt;- range(cosmeanf) 

par(mfrow=c(3,1), mar=c(2,2,2,1))
image(outcos$Epstat, xlab="", ylab="", col=gray(0:100/100), axes=FALSE, zlim=rangez, 
      main="ensemble average of patch mean")
persp(outcos$Epstat, theta = -30, phi = 45, col = "white", xlab="X", ylab="Y", 
      main="ensemble average of patch mean")
image(outcos$Epsd, xlab="", ylab="", col=gray(0:100/100), axes=FALSE, 
      main="ensemble average of standard deviation")

#### Ensemble Envelope of Ensemble Patch Transform
outcos2 &lt;- eptransf2d(z=cosmeanf, tau=12, process = c("envelope", "average"))
par(mfrow=c(2,2), mar=c(2,2,2,1))
image(outcos2$EpL, xlab="", ylab="", col=gray(0:100/100), axes=FALSE, 
      main="ensemble average of lower envelope")
image(outcos2$EpU, xlab="", ylab="", col=gray(0:100/100), axes=FALSE, 
      main="ensemble average of upper envelope")
image(outcos2$EpM, xlab="", ylab="", col=gray(0:100/100), axes=FALSE, 
      main="ensemble average of mean envelope")
image(outcos2$Epsd, xlab="", ylab="", col=gray(0:100/100), axes=FALSE, 
      main="ensemble average of standard deviation")

par(op)
</code></pre>

<hr>
<h2 id='localextrema'>Finding Local Extrema and Zero-crossings of a Signal</h2><span id='topic+localextrema'></span>

<h3>Description</h3>

<p>This function identifies local extrema and zero-crossings of a signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>localextrema(y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="localextrema_+3A_y">y</code></td>
<td>
<p>a set of data or a signal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function identifies local extrema and zero-crossings of a signal.
</p>


<h3>Value</h3>

 
<table role = "presentation">
<tr><td><code>minindex</code></td>
<td>
<p>matrix of time index at which local minima are attained. 
Each row specifies a starting and ending time index of a local minimum.</p>
</td></tr>
<tr><td><code>maxindex</code></td>
<td>
<p>matrix of time index at which local maxima are attained. 
Each row specifies a starting and ending time index of a local maximum.</p>
</td></tr>
<tr><td><code>nextreme</code></td>
<td>
<p>the number of extrema.</p>
</td></tr> 
<tr><td><code>cross</code></td>
<td>
<p>matrix of time index of zero-crossings. 
Each row specifies a starting and ending time index of zero-crossings.</p>
</td></tr> 
<tr><td><code>ncross</code></td>
<td>
<p>the number of zero-crossings.</p>
</td></tr> 
</table>


<h3>See Also</h3>

<p><code><a href="#topic+eptransf">eptransf</a></code>, <code><a href="#topic+eptdecomp">eptdecomp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- c(0, 1, 2, 1, -1, 1:4, 5, 6, 0, -4, -6, -5:5, -2:2)
#y &lt;- c(0, 0, 0, 1, -1, 1:4, 4, 4, 0, 0, 0, -5:5, -2:2, 2, 2)
#y &lt;- c(0, 0, 0, 1, -1, 1:4, 4, 4, 0, 0, 0, -5:5, -2:2, 0, 0)

plot(y, type = "b"); abline(h = 0)
localextrema(y)

findextrema &lt;- localextrema(y)
points(findextrema$maxindex, y[findextrema$maxindex], pch=16, col="red")
points(findextrema$minindex, y[findextrema$minindex], pch=16, col="blue")
</code></pre>

<hr>
<h2 id='LOD'>Length of Day Data</h2><span id='topic+LOD'></span>

<h3>Description</h3>

<p>The length-of-day was produced by Gross (2001) from 20 January 1962 to 6 January 2001.
The length-of-day (LOD) data was analyzed in Huang et al. (2003).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(LOD)
</code></pre>


<h3>Format</h3>

<p>A list of LOD, YEAR, MONTH and DATE 
</p>


<h3>References</h3>

<p>Gross, R. S. (2001) Combinations of Earth orientation measurements: SPACE2000, COMB2000,
and POLE2000. JPL Publication 01-2. Jet Propulsion Laboratory, Pasadena, CA.
</p>
<p>Huang, N. E., Wu, M. C., Long, S. R., Shen, S., Qu, W., Gloerson, P. and Fan, K. L. (2003)  
A confidence limit for the empirical mode decomposition and Hilbert spectral analysis. 
<em>Proceedings of the Royal Society London A.</em>, <b>459</b>, 2317&ndash;2345. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(LOD)
names(LOD)

xt &lt;- LOD$LOD[LOD$YEAR &gt;= 1981 &amp; LOD$YEAR &lt;= 2000] # From 1981/1/1 to 2000/12/31
xt &lt;- xt/10^4 # measured in millisecond

# EP transform for LOD
outLOD &lt;- eptransf(signal=xt, tau=15, process=c("envelope", "average"), boundary="none")

# outLOD$EpM : candidate of remaining component 
eptplot(outLOD)

op &lt;- par(mfcol=c(3,1), mar=c(2,2,2,1))
plot(xt, type='l', main="LOD", xlab="", ylab="", ylim=range(xt))
plot(xt - outLOD$EpM, type='l', main="candidate of frequency component 
    with half month period", xlab="", ylab=""); abline(h=0, lty=3)
plot(outLOD$EpM, type='l', main="candidate of remaining component", 
    xlab="", ylab="", ylim=range(xt))


# sifting
LODdecom1 &lt;- eptdecomp(signal=xt, tau=15, process=c("envelope", "average"),  
    boundary="none", tol=sd(xt)*0.1^3, maxiter = 30)

# extraction of frequency component with half month period 
plot(xt, type='l', main="LOD", xlab="", ylab="", ylim=range(xt))
plot(LODdecom1$FC, type='l', main="frequency component 
    with half month period", xlab="", ylab=""); abline(h=0, lty=3)
plot(LODdecom1$residue, type='l', main="remaining component", 
    xlab="", ylab="", ylim=range(xt))

# EP transform for remaining signal from LODdecom1
outLOD2 &lt;- eptransf(signal=LODdecom1$residue, tau=30, process=c("envelope", "average"),
    boundary="none")

# outLOD2$EpM : candidate of remaining component for residue signal from LODdecom1
plot(LODdecom1$residue, type='l', main="remaining component from LODdecom1", 
    xlab="", ylab="", ylim=range(xt))
plot(LODdecom1$residue - outLOD2$EpM, type='l', main="candidate of frequency component
    with one month period", xlab="", ylab=""); abline(h=0, lty=3)
plot(outLOD2$EpM, type='l', main="candidate of remaining component", 
    xlab="", ylab="", ylim=range(xt))

# sifting
LODdecom2 &lt;- eptdecomp(signal=LODdecom1$residue, tau=30, process=c("envelope", "average"),
    boundary="none", tol=sd(xt)*0.1^3, maxiter = 50)

# extraction of frequency component with one month period 
plot(LODdecom1$residue, type='l', main="remaining component from LODdecom1", 
    xlab="", ylab="", ylim=range(xt))
plot(LODdecom2$FC, type='l', main="frequency component with one month period", 
    xlab="", ylab=""); abline(h=0, lty=3)
plot(LODdecom2$residue, type='l', main="remaining component", xlab="", ylab="",
    ylim=range(xt))

### Decomposition Result
ttt &lt;- paste(LOD$YEAR, LOD$MONTH, LOD$DATE, sep="/")
ttt &lt;- ttt[LOD$YEAR &gt;= 1981 &amp; LOD$YEAR &lt;= 2000]
ttt &lt;- as.Date(ttt)

att &lt;- as.Date(c("1981/1/1", "1982/1/1", "1983/1/1", "1984/1/1", "1985/1/1", "1986/1/1",
                 "1987/1/1", "1988/1/1", "1989/1/1", "1990/1/1", "1991/1/1", "1992/1/1", 
                 "1993/1/1", "1994/1/1", "1995/1/1", "1996/1/1", "1997/1/1", "1998/1/1", 
                 "1999/1/1", "2000/1/1", "2001/1/1"))

plot(ttt, xt, type='l', main="LOD", xlab="", ylab="", xaxt = "n")
axis(1, at=att, labels=seq(1981, 2001)) 

plot(ttt, LODdecom1$FC, type="l", main="component with half month period by EPT", 
    xlab="", ylab="", xaxt = "n")
axis(1, at=att, labels=seq(1981, 2001)); abline(h=0, lty=3)

plot(ttt, LODdecom2$FC, type="l", main="component with one month period by EPT", 
    xlab="", ylab="", xaxt = "n")
axis(1, at=att, labels=seq(1981, 2001)); abline(h=0, lty=3)

par(op)
</code></pre>

<hr>
<h2 id='meptransf'>Multiscale Ensemble Patch Transforms of a Signal</h2><span id='topic+meptransf'></span>

<h3>Description</h3>

<p>This function performs multiscale ensemble patch transforms of a signal for a sequence of size parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meptransf(tindex = NULL, signal, type = "rectangle", taus, 
    process = c("average", "average"), pquantile = c(0, 1), equantile = c(0, 1), 
    gamma = 1, boundary = "symmetric") 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="meptransf_+3A_tindex">tindex</code></td>
<td>
<p>time index at which a signal is observed. When it is <code>NULL</code>, the signal is supposed to be equally spaced.</p>
</td></tr>
<tr><td><code id="meptransf_+3A_signal">signal</code></td>
<td>
<p>a set of data or a signal observed at time <code>tindex</code>.</p>
</td></tr>
<tr><td><code id="meptransf_+3A_type">type</code></td>
<td>
<p>patch type of <code>"rectangle"</code> or <code>"oval"</code>.</p>
</td></tr>
<tr><td><code id="meptransf_+3A_taus">taus</code></td>
<td>
<p>a sequence of size parameters for ensemble patch transform.</p>
</td></tr>
<tr><td><code id="meptransf_+3A_process">process</code></td>
<td>
<p>specifies transform types for patch and ensemble processes:
<code>process[1]</code> for patch process and process[2] for ensemble process.
Each process has options of <code>"average"</code>, <code>"median"</code>, or <code>"envelope"</code>.
Note that when <code>process[1]</code> is <code>"average"</code> or <code>"median"</code>, <code>process[2]</code> must be <code>"average"</code> or <code>"median"</code>. 
When <code>process[1]</code> is <code>"envelope"</code>, lower and upper envelopes are obtained by <code class="reqn">\code{pquantile[1]} \times 100 \%</code>-quantile 
and <code class="reqn">\code{pquantile[2]} \times 100 \%</code>-quantile of patches, respectively.
When <code>process[2]</code> is <code>"envelope"</code>, ensemble lower and upper envelopes are obtained as 
<code class="reqn">\code{equantile[1]} \times 100 \%</code>-quantile and <code class="reqn">\code{equantile[2]} \times 100 \%</code>-quantile  
of lower and upper envelopes of shifted patches, respectively.</p>
</td></tr>
<tr><td><code id="meptransf_+3A_pquantile">pquantile</code></td>
<td>
<p>quantiles for lower and upper envelopes of patch transform. When it is <code>c(0, 1)</code>,
minimum and maximum of a patch are used for lower and upper envelopes, respectively.</p>
</td></tr>
<tr><td><code id="meptransf_+3A_equantile">equantile</code></td>
<td>
<p>quantiles for lower and upper envelopes of ensemble patch transform.</p>
</td></tr>            
<tr><td><code id="meptransf_+3A_gamma">gamma</code></td>
<td>
<p>controls the amount of envelope magnitude.</p>
</td></tr>
<tr><td><code id="meptransf_+3A_boundary">boundary</code></td>
<td>
<p>specifies boundary condition from <code>"symmetric"</code>, <code>"periodic"</code> or <code>"none"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs multiscale ensemble patch transforms of a signal for a sequence of size parameters <code>taus</code>, and 
produces statistics and envelopes for ensemble patch transform.
When <code>process[1]</code> is <code>"average"</code> or <code>"median"</code>, outputs related to envelopes are defined as <code>NULL</code>.
When <code>process[2]</code> is <code>"envelope"</code>, outputs, <code>pstat</code> and <code>Epstat</code>, are defined as <code>NULL</code>.
</p>


<h3>Value</h3>

 
<table role = "presentation">
<tr><td><code>tindex</code></td>
<td>
<p>time index at which a signal is observed.</p>
</td></tr>
<tr><td><code>signal</code></td>
<td>
<p>a set of data or a signal observed at time <code>tindex</code>.</p>
</td></tr>
<tr><td><code>pstat</code></td>
<td>
<p>matrix of centrality of patch transform for a sequence of size parameters <code>taus</code>.</p>
</td></tr>
<tr><td><code>Epstat</code></td>
<td>
<p>matrix of centrality of ensemble patch transform for a sequence of size parameters <code>taus</code>.</p>
</td></tr>
<tr><td><code>psd</code></td>
<td>
<p>matrix of standard deviation of patch transform for a sequence of size parameters <code>taus</code>.</p>
</td></tr>
<tr><td><code>Epsd</code></td>
<td>
<p>matrix of standard deviation of ensemble patch transform for a sequence of size parameters <code>taus</code>.</p>
</td></tr>
<tr><td><code>pL</code></td>
<td>
<p>matrix of lower envelope of patch transform for a sequence of size parameters <code>taus</code>.</p>
</td></tr>
<tr><td><code>pU</code></td>
<td>
<p>matrix of upper envelope of patch transform for a sequence of size parameters <code>taus</code>.</p>
</td></tr>
<tr><td><code>pM</code></td>
<td>
<p>matrix of mean envelope, <code>(pL + pU) / 2</code>, of patch transform for a sequence of size parameters <code>taus</code>.</p>
</td></tr>
<tr><td><code>pR</code></td>
<td>
<p>matrix of distance between lower and upper envelopes, <code>(pU - pL)</code>, of patch transform for a sequence of size parameters <code>taus</code>.</p>
</td></tr>
<tr><td><code>EpL</code></td>
<td>
<p>matrix of lower envelope of ensemble patch transform for a sequence of size parameters <code>taus</code>.</p>
</td></tr>
<tr><td><code>EpU</code></td>
<td>
<p>matrix of upper envelope of ensemble patch transform for a sequence of size parameters <code>taus</code>.</p>
</td></tr>
<tr><td><code>EpM</code></td>
<td>
<p>matrix of mean envelope, <code>(EpL + EpU) / 2</code>, of ensemble patch transform for a sequence of size parameters <code>taus</code>.</p>
</td></tr>
<tr><td><code>EpR</code></td>
<td>
<p>matrix of distance between lower and upper envelopes, <code>(EpU - EpL)</code>, of ensemble patch transform for a sequence of size parameters <code>taus</code>.</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>vector of correlations between <code>(signal - ept)</code> component and <code>ept</code> component for a sequence of size parameters <code>taus</code>.    
The <code>ept</code> component is component obtained by ensemble patch transform.</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>a list of input parameters of <code>type</code>, <code>taus</code>, <code>process</code>, <code>pquantile</code>, <code>equantile</code>, <code>gamma</code>, and <code>boundary</code>.</p>
</td></tr>
<tr><td><code>nlevel</code></td>
<td>
<p>the number of size parameters <code>taus</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+eptransf">eptransf</a></code>, <code><a href="#topic+eptdecomp">eptdecomp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### example : composite of two components having different frequencies
ndata &lt;- 1000 
tindex &lt;- seq(0, 1, length=ndata)
comp1 &lt;- cos(45*pi*tindex)
comp2 &lt;- cos(6*pi*tindex)
f &lt;- comp1 + comp2 

op &lt;- par(mfcol=c(3,1), mar=c(2,2,2,1))
plot(tindex, f, main="a signal", xlab="", ylab="", type='l')
abline(h=0, lty=3)
plot(tindex, comp1, main="high-frequency component", xlab="", ylab="", type='l')
abline(h=0, lty=3)
plot(tindex, comp2, main="low-frequency component", xlab="", ylab="", type='l')
abline(h=0, lty=3)


#### Multiscale Ensemble Patch Transform according to tau's 
taus1 &lt;- seq(20, 60, by=2)
outmulti &lt;- meptransf(signal=f, taus=taus1, process=c("envelope", "average"),
    pquantile=c(0, 1)) 

#### To continue, click the plot in case of "locator(1)".
par(mfrow=c(2,2), mar=c(2,2,2,1))
for (i in 1:length(taus1)) {
  plot(f - outmulti$EpM[,i], type='l', main="", xlab="", ylab=""); abline(h=0, lty=3)
  title(paste0("Remaining component for tau=", taus1[i]))
  lines(comp1, col="red", lty=2, lwd=0.5)
  plot(outmulti$EpM[,i], type="l", main=, xlab="", ylab=""); abline(h=0, lty=3)
  title(paste0("Mean envelope of ensemble patch transform for tau=", taus1[i]))
  lines(comp2, col="red", lty=2, lwd=0.5); locator(1)  
}

par(op)
</code></pre>

<hr>
<h2 id='meptransf2d'>Multiscale Two-dimensional Ensemble Patch Transforms of an Image</h2><span id='topic+meptransf2d'></span>

<h3>Description</h3>

<p>This function performs multiscale two-dimensional ensemble patch transforms of an image for a sequence of size parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meptransf2d(x = NULL, y = NULL, z, type = "rectangle", taus, theta = 0, 
    process = c("average", "average"), pquantile = c(0, 1), equantile = c(0, 1),
    gamma = 1, boundary = "reflexive") 
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="meptransf2d_+3A_x">x</code>, <code id="meptransf2d_+3A_y">y</code></td>
<td>
<p>locations of regular grid at which the values in image <code>z</code> are measured. When those are <code>NULL</code>, the image is supposed to be equally spaced.</p>
</td></tr>
<tr><td><code id="meptransf2d_+3A_z">z</code></td>
<td>
<p>matrix of an image observed at location <code>(x, y)</code>.</p>
</td></tr>
<tr><td><code id="meptransf2d_+3A_type">type</code></td>
<td>
<p>patch type of <code>"rectangle"</code> or <code>"oval"</code>.</p>
</td></tr>
<tr><td><code id="meptransf2d_+3A_taus">taus</code></td>
<td>
<p>a matrix or vector of size parameters for two-dimensional ensemble patch transform. When it is a matrix, the first and second columns specify
the horizontal and vertical sizes of a two-dimensional patch, respectively.
When it is a vector, the horizontal and vertical size of a two-dimensional patch are the same.</p>
</td></tr>
<tr><td><code id="meptransf2d_+3A_theta">theta</code></td>
<td>
<p>a degree of clockwise rotation of a patch.</p>
</td></tr>
<tr><td><code id="meptransf2d_+3A_process">process</code></td>
<td>
<p>specifies transform types for patch and ensemble processes:
<code>process[1]</code> for patch process and process[2] for ensemble process.
Each process has options of <code>"average"</code>, <code>"median"</code>, or <code>"envelope"</code>.
Note that when <code>process[1]</code> is <code>"average"</code> or <code>"median"</code>, <code>process[2]</code> must be <code>"average"</code> or <code>"median"</code>. 
When <code>process[1]</code> is <code>"envelope"</code>, lower and upper envelopes are obtained by <code class="reqn">\code{pquantile[1]} \times 100 \%</code>-quantile 
and <code class="reqn">\code{pquantile[2]} \times 100 \%</code>-quantile of patches, respectively.
When <code>process[2]</code> is <code>"envelope"</code>, ensemble lower and upper envelopes are obtained as 
<code class="reqn">\code{equantile[1]} \times 100 \%</code>-quantile and <code class="reqn">\code{equantile[2]} \times 100 \%</code>-quantile  
of lower and upper envelopes of shifted patches, respectively.</p>
</td></tr>
<tr><td><code id="meptransf2d_+3A_pquantile">pquantile</code></td>
<td>
<p>quantiles for lower and upper envelopes of patch transform. When it is <code>c(0, 1)</code>,
minimum and maximum of a patch are used for lower and upper envelopes, respectively.</p>
</td></tr>
<tr><td><code id="meptransf2d_+3A_equantile">equantile</code></td>
<td>
<p>quantiles for lower and upper envelopes of ensemble patch transform.</p>
</td></tr>            
<tr><td><code id="meptransf2d_+3A_gamma">gamma</code></td>
<td>
<p>controls the amount of envelope magnitude.</p>
</td></tr>
<tr><td><code id="meptransf2d_+3A_boundary">boundary</code></td>
<td>
<p>specifies boundary condition from <code>"reflexive"</code>, <code>"periodic"</code> or <code>"none"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs multiscale two-dimensional ensemble patch transforms of an image for a sequence of size parameters <code>taus</code>, and 
produces statistics and envelopes for two-dimensional ensemble patch transform.
When <code>process[1]</code> is <code>"average"</code> or <code>"median"</code>, outputs related to envelopes are defined as <code>NULL</code>.
When <code>process[2]</code> is <code>"envelope"</code>, outputs, <code>pstat</code> and <code>Epstat</code>, are defined as <code>NULL</code>.
</p>


<h3>Value</h3>

 
<table role = "presentation">
<tr><td><code>x</code>, <code>y</code></td>
<td>
<p>locations of regular grid at which the values in <code>z</code> are measured. When those are <code>NULL</code>, image is supposed to be equally spaced.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>matrix of an image observed at <code>(x, y)</code>.</p>
</td></tr>
<tr><td><code>pstat</code></td>
<td>
<p>list of centrality of patch transform for a sequence of size parameters <code>taus</code>.</p>
</td></tr>
<tr><td><code>Epstat</code></td>
<td>
<p>list of centrality of ensemble patch transform for a sequence of size parameters <code>taus</code>.</p>
</td></tr>
<tr><td><code>psd</code></td>
<td>
<p>list of standard deviation of patch transform for a sequence of size parameters <code>taus</code>.</p>
</td></tr>
<tr><td><code>Epsd</code></td>
<td>
<p>list of standard deviation of ensemble patch transform for a sequence of size parameters <code>taus</code>.</p>
</td></tr>
<tr><td><code>pL</code></td>
<td>
<p>list of lower envelope of patch transform for a sequence of size parameters <code>taus</code>.</p>
</td></tr>
<tr><td><code>pU</code></td>
<td>
<p>list of upper envelope of patch transform for a sequence of size parameters <code>taus</code>.</p>
</td></tr>
<tr><td><code>pM</code></td>
<td>
<p>list of mean envelope, <code>(pL + pU) / 2</code>, of patch transform for a sequence of size parameters <code>taus</code>.</p>
</td></tr>
<tr><td><code>pR</code></td>
<td>
<p>list of distance between lower and upper envelopes, <code>(pU - pL)</code>, of patch transform for a sequence of size parameters <code>taus</code>.</p>
</td></tr>
<tr><td><code>EpL</code></td>
<td>
<p>list of lower envelope of ensemble patch transform for a sequence of size parameters <code>taus</code>.</p>
</td></tr>
<tr><td><code>EpU</code></td>
<td>
<p>list of upper envelope of ensemble patch transform for a sequence of size parameters <code>taus</code>.</p>
</td></tr>
<tr><td><code>EpM</code></td>
<td>
<p>list of mean envelope, <code>(EpL + EpU) / 2</code>, of ensemble patch transform for a sequence of size parameters <code>taus</code>.</p>
</td></tr>
<tr><td><code>EpR</code></td>
<td>
<p>list of distance between lower and upper envelopes, <code>(EpU - EpL)</code>, of ensemble patch transform for a sequence of size parameters <code>taus</code>.</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p>vector of correlations between <code>(z - ept)</code> component and <code>ept</code> component for a sequence of size parameters <code>taus</code>.    
The <code>ept</code> component is component obtained by ensemble patch transform.</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>a list of input parameters of <code>type</code>, <code>taus</code>, <code>theta</code>, <code>process</code>, <code>pquantile</code>, <code>equantile</code>, <code>gamma</code>, and <code>boundary</code>.</p>
</td></tr>
<tr><td><code>nlevel</code></td>
<td>
<p>the number of size parameters <code>taus</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+eptransf2d">eptransf2d</a></code>, <code><a href="#topic+eptdecomp2d">eptdecomp2d</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### example : composite of two components having different frequencies
nr &lt;- nc &lt;- 128; x &lt;- seq(0, 1, length=nr); y &lt;- seq(0, 1, length=nc)

coscomp1 &lt;- outer(cos(20 * pi * x), cos(20 * pi * y))
coscomp2 &lt;- outer(cos(5* pi * x), cos(5 * pi * y))
cosmeanf &lt;- coscomp1 + coscomp2

op &lt;- par(mfcol=c(3,1), mar=c(0,0.5,2,0.5))
image(cosmeanf, xlab="", ylab="", col=gray(0:100/100), axes=FALSE, main="a composite image")
image(coscomp1, xlab="", ylab="", col=gray(0:100/100), axes=FALSE, main="high-frequency component")
image(coscomp2, xlab="", ylab="", col=gray(0:100/100), axes=FALSE, main="low-frequency component")


#### Multiscale Ensemble Patch Transform according to tau's 
taus1 &lt;- seq(6, 12, by=2)
outcosmulti &lt;- meptransf2d(z=cosmeanf, taus=taus1)

par(mfrow=c(length(taus1), 2), mar=c(2,2,2,1))
for (i in 1:length(taus1)) {
    estlowfreq &lt;- outcosmulti$Epstat[[i]]
    image(estlowfreq, xlab="", ylab="", col=gray(0:100/100), axes=FALSE, 
        main=paste0("ensemble average of patch mean, tau=", taus1[i]))
    persp(estlowfreq, theta = -30, phi = 45, col = "white", xlab="X", ylab="Y", 
        main=paste0("ensemble average of patch mean, tau=", taus1[i]))
}

par(op)
</code></pre>

<hr>
<h2 id='SolarRadiation'>Solar Radiation</h2><span id='topic+SolarRadiation'></span>

<h3>Description</h3>

<p>The solar radiations were hourly observed at Seoul, Daegu, and Busan in South Korea from September 1, 2003 to September 29, 2003. 
The data are available from Korea Meteorological Administration (<a href="https://data.kma.go.kr">https://data.kma.go.kr</a>). 
Daegu and Busan, located in the southeast of the Korean Peninsula, are close to each other geographically, whereas Seoul is located in the middle of the Peninsula.
In addition, note that Daegu and Busan were severely damaged by a typhoon named &ldquo;MAEMI&quot; at that time, while Seoul was hardly affected by the typhoon. 
It is expected that the climatic characteristics of Daegu and Busan are similar, and the pattern of Seoul seems to be different from the other two cities. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SolarRadiation)
</code></pre>


<h3>Format</h3>

<p>A daraframe of Date, Seoul, Daegu and Busan.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(SolarRadiation)
names(SolarRadiation)

# ensemble patch transform
SolarRadiationEpU &lt;- SolarRadiationEpL &lt;- NULL

for(j in 1:3) {
    tmp &lt;- eptransf(signal=SolarRadiation[,j+1], tau=24, process=c("envelope", "average"), 
        pquantile=c(0, 1), gamma=0)
    SolarRadiationEpU &lt;- cbind(SolarRadiationEpU, tmp$EpU)
    SolarRadiationEpL &lt;- cbind(SolarRadiationEpL, tmp$EpL)
}

# Correlation of the solar radiations at Seoul, Daegu, and Busan
cor(SolarRadiation[, 2:4])

# Correlation of ensemble average of upper envelope
cor(SolarRadiationEpU)

op &lt;- par(mfrow=c(3,1), mar=c(2,2,2,2))
plot(SolarRadiation[,2], type='l', main="(a) solar-radiation in Seoul and upper envelope",
    ylim=c(0, 3.3), xaxt="n"); axis(1, at=seq(1, 30*24, by=24), labels=seq(1, 30, by=1)) 
lines(SolarRadiationEpU[,1], lty=2); lines(SolarRadiationEpL[,1], lty=2)
plot(SolarRadiation[,3], type='l', main="(b) solar-radiation in Daegu and upper envelope",
    ylim=c(0, 3.3), xaxt="n"); axis(1, at=seq(1, 30*24, by=24), labels=seq(1, 30, by=1)) 
lines(SolarRadiationEpU[,2], lty=2); lines(SolarRadiationEpL[,2], lty=2)
plot(SolarRadiation[,4], type='l', main="(c) solar-radiation in Busan and upper envelope",
    ylim=c(0, 3.3), xaxt="n"); axis(1, at=seq(1, 30*24, by=24), labels=seq(1, 30, by=1)) 
lines(SolarRadiationEpU[,3], lty=2); lines(SolarRadiationEpL[,3], lty=2)
par(op)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
