<!DOCTYPE html><html lang="en"><head><title>Help for package turboEM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {turboEM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#implants'><p>Fetal Death in Mice</p></a></li>
<li><a href='#internal'><p>Internal functions for turboEM</p></a></li>
<li><a href='#parties'><p>Political Parties</p></a></li>
<li><a href='#psychfactors'><p>Psychiatric Test Correlations</p></a></li>
<li><a href='#rats'><p>Population Growth of Rats</p></a></li>
<li><a href='#turbo'><p>Methods for objects of class &quot;turbo&quot;</p></a></li>
<li><a href='#turboem'><p>A suite of acceleration schemes for fixed-point iterations</p></a></li>
<li><a href='#turbosim'><p>Methods for objects of class &quot;turbosim&quot;</p></a></li>
<li><a href='#turboSim'><p>Conduct benchmark studies of EM accelerator</p></a></li>
<li><a href='#votes'><p>Roll Call Votes</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>A Suite of Convergence Acceleration Schemes for EM, MM and Other
Fixed-Point Algorithms</td>
</tr>
<tr>
<td>Description:</td>
<td>Algorithms for accelerating the convergence of slow,
        monotone sequences from smooth, contraction mapping such as the
        EM and MM algorithms. It can be used to accelerate any smooth,
        linearly convergent acceleration scheme.  A tutorial style
        introduction to this package is available in a vignette on the
        CRAN download page or, when the package is loaded in an R
        session, with vignette("turboEM").</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.12.0), doParallel, foreach, numDeriv, quantreg</td>
</tr>
<tr>
<td>Imports:</td>
<td>iterators</td>
</tr>
<tr>
<td>Suggests:</td>
<td>setRNG</td>
</tr>
<tr>
<td>Version:</td>
<td>2021.1</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Author:</td>
<td>Jennifer F. Bobb [aut],
  Ravi Varadhan [aut, cre],
  Hui Zhao [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ravi Varadhan &lt;ravi.varadhan@jhu.edu&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://coah.jhu.edu/people/Faculty_personal_Pages/Varadhan.html">https://coah.jhu.edu/people/Faculty_personal_Pages/Varadhan.html</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-08-03 19:29:44 UTC; rvaradh1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-08-05 04:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='implants'>Fetal Death in Mice</h2><span id='topic+implants'></span>

<h3>Description</h3>

<p>Data on the number of fetal deaths arising from dominant lethal testing in mice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(implants)</code></pre>


<h3>Format</h3>

<p>A data frame containing the number of dead and survived implants from 523 mice.</p>


<h3>Source</h3>

<p>Zhou H and Lange K (2010). MM Algorithms for Some Discrete Multivariate Distributions. <em>Journal of Computational and Graphical Statistics</em>. 19 (3) 645-665. Supplementary material.</p>


<h3>References</h3>

<p>Haseman JK and Soares ER (1976). The Distribution of Fetal Death in Control Mice and Its Implications on Statistical Tests for Dominant Lethal Effects, <em>Mutation Research/Fundamental and Molecular Mechanisms of Mutagenesis</em>. 41, 277-288.</p>

<hr>
<h2 id='internal'>Internal functions for turboEM</h2><span id='topic+accelerate'></span><span id='topic+line.search'></span><span id='topic+search'></span><span id='topic+optimize.2d.app'></span><span id='topic+inv2'></span><span id='topic+bodyEM'></span><span id='topic+bodyParaEM'></span><span id='topic+bodyDECME'></span><span id='topic+bodyQuasiNewton'></span><span id='topic+bodySquarem1'></span><span id='topic+bodySquarem2'></span><span id='topic+bodyCyclem1'></span><span id='topic+bodyCyclem2'></span><span id='topic+combine'></span>

<h3>Description</h3>

<p>turboEM functions not to be called by users.</p>


<h3>Usage</h3>

<pre><code class='language-R'>accelerate(par, fixptfn, objfn, method = c("em","squarem","pem","decme","qn"), 
  boundary = NULL, pconstr = NULL, project = NULL, ..., control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="internal_+3A_par">par</code></td>
<td>
<p>See <code><a href="#topic+turboem">turboem</a></code>.</p>
</td></tr>
<tr><td><code id="internal_+3A_fixptfn">fixptfn</code></td>
<td>
<p>See <code><a href="#topic+turboem">turboem</a></code>.</p>
</td></tr> 
<tr><td><code id="internal_+3A_objfn">objfn</code></td>
<td>
<p>See <code><a href="#topic+turboem">turboem</a></code>.</p>
</td></tr> 
<tr><td><code id="internal_+3A_method">method</code></td>
<td>
<p>See <code><a href="#topic+turboem">turboem</a></code>.</p>
</td></tr> 
<tr><td><code id="internal_+3A_boundary">boundary</code></td>
<td>
<p>See <code><a href="#topic+turboem">turboem</a></code>.</p>
</td></tr> 
<tr><td><code id="internal_+3A_pconstr">pconstr</code></td>
<td>
<p>See <code><a href="#topic+turboem">turboem</a></code>.</p>
</td></tr> 
<tr><td><code id="internal_+3A_control">control</code></td>
<td>
<p>See <code><a href="#topic+turboem">turboem</a></code>.</p>
</td></tr>
<tr><td><code id="internal_+3A_...">...</code></td>
<td>
<p>See <code><a href="#topic+turboem">turboem</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='parties'>Political Parties</h2><span id='topic+parties'></span>

<h3>Description</h3>

<p>Political parties of members of the U.S. House of Representatives, 2005.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(votes)</code></pre>


<h3>Format</h3>

<p>A vector of integers representing the political parties, with 0, 1, and 2 corresponding to Republicans, Democrats, and Independents, respectively.</p>


<h3>Source</h3>

<p>Diaconis PD, Goel S, and Holmes S (2008). Horseshoes in Multidimensional Scaling and Local Kernel Methods. <em>Annals of Applied Statistics</em>. 2 (3) 777-807. Supplementary material.</p>

<hr>
<h2 id='psychfactors'>Psychiatric Test Correlations</h2><span id='topic+psychfactors'></span>

<h3>Description</h3>

<p>Intercorrelations of outcomes from a set of psychiatric tests for 148 children.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(psychfactors)</code></pre>


<h3>Format</h3>

<p>A 10-by-10 correlation matrix.</p>


<h3>Source</h3>

<p>Maxwell AE (1961). Recent Trends in Factor Analysis. <em>Journal of the Royal Statistical Society. Series A (General)</em>. 124 (1)  49-59.</p>

<hr>
<h2 id='rats'>Population Growth of Rats</h2><span id='topic+rats'></span>

<h3>Description</h3>

<p>Longitudinal measurements of the weights of rats in control and treatment groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(rats)</code></pre>


<h3>Format</h3>

<p>A data frame containing weights from 60 rats divided into two groups, with each rat measured at 5 time points.</p>


<h3>Source</h3>

<p>Gelfand AE, Hills SE, Racine-Poon A, and Smith AFM (1990). Illustration of Bayesian inference in normal data models using Gibbs sampling. <em>Journal of the American Statistical Association</em>. 85, 972-985.</p>

<hr>
<h2 id='turbo'>Methods for objects of class &quot;turbo&quot;</h2><span id='topic+turbo'></span><span id='topic+print.turbo'></span><span id='topic+pars'></span><span id='topic+pars.turbo'></span><span id='topic+error'></span><span id='topic+error.turbo'></span><span id='topic+plot.turbo'></span><span id='topic+grad'></span><span id='topic+grad.turbo'></span><span id='topic+hessian'></span><span id='topic+hessian.turbo'></span><span id='topic+stderror'></span><span id='topic+stderror.turbo'></span>

<h3>Description</h3>

<p>The <code>turbo</code> class represents results from parameter estimation in fixed-point mapping problems. The <code><a href="#topic+turboem">turboem</a></code> function outputs objects of class <code>turbo</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'turbo'
print(x, ...)
## S3 method for class 'turbo'
pars(x, ...)
## S3 method for class 'turbo'
error(x, ...)
## S3 method for class 'turbo'
plot(x, which.methods = seq_along(x$method), 
method.names = x$method[which.methods], xlim, ylim, ...)
## S3 method for class 'turbo'
grad(x, objfn=x$objfn, which.methods = seq_along(x$method), 
  method.names = x$method[which.methods], ...)
## S3 method for class 'turbo'
hessian(x, objfn=x$objfn, which.methods = seq_along(x$method), 
  method.names = x$method[which.methods], ...)
## S3 method for class 'turbo'
stderror(x, objfn=x$objfn, which.methods = seq_along(x$method), 
  method.names = x$method[which.methods], ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="turbo_+3A_x">x</code></td>
<td>
<p>An object of class <code>turbo</code>, typically the output of a call to <code><a href="#topic+turboem">turboem</a></code>.</p>
</td></tr>
<tr><td><code id="turbo_+3A_which.methods">which.methods</code></td>
<td>
<p>A vector identifying for which subset of algorithms results are desired.</p>
</td></tr> 
<tr><td><code id="turbo_+3A_method.names">method.names</code></td>
<td>
<p>A vector of unique identifiers for the algorithms for which results are being provided.</p>
</td></tr>
<tr><td><code id="turbo_+3A_xlim">xlim</code></td>
<td>
<p>Optional range for the x-axis of the trace plot.</p>
</td></tr>
<tr><td><code id="turbo_+3A_ylim">ylim</code></td>
<td>
<p>Optional range for the y-axis of the trace plot.</p>
</td></tr>
<tr><td><code id="turbo_+3A_objfn">objfn</code></td>
<td>
<p>Objective function. Usually this is taken to be the appropriate component of a <code>turbo</code> object.</p>
</td></tr>
<tr><td><code id="turbo_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>print</code></td>
<td>
<p>Shows a brief summary of the results from fitting the acceleration schemes.</p>
</td></tr>
<tr><td><code>pars</code></td>
<td>
<p>Prints the fixed-point values across acceleration schemes at termination of the algorithms.</p>
</td></tr>
<tr><td><code>error</code></td>
<td>
<p>Prints any error messages from running the acceleration schemes</p>
</td></tr>
<tr><td><code>plot</code></td>
<td>
<p>Shows a trace plot of the objective function value over iterations. This method is only available if the call to <code>turboem</code> had the argument<code>control.run[["keep.objfval"]]=TRUE</code></p>
</td></tr>
<tr><td><code>grad</code></td>
<td>
<p>Calculates the gradient of the objective function evaluated at the fixed-point across acceleration schemes. Uses numerical methods from the package <code>numDeriv</code>.</p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p>Calculates the Hessian of the objective function evaluated at the fixed-point across acceleration schemes. Uses numerical methods from the package <code>numDeriv</code>.</p>
</td></tr>
<tr><td><code>stderror</code></td>
<td>
<p>Provides estimates of the standard error of the fixed-point across acceleration schemes.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+turboem">turboem</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###########################################################################
# Also see the vignette by typing:
#  vignette("turboEM")
#
# EM algorithm for Poisson mixture estimation 

fixptfn &lt;- function(p,y) {
# The fixed point mapping giving a single E and M step of the EM algorithm
# 
pnew &lt;- rep(NA,3)
i &lt;- 0:(length(y)-1)
zi &lt;- p[1]*exp(-p[2])*p[2]^i / (p[1]*exp(-p[2])*p[2]^i + (1 - p[1])*exp(-p[3])*p[3]^i)
pnew[1] &lt;- sum(y*zi)/sum(y)
pnew[2] &lt;- sum(y*i*zi)/sum(y*zi)
pnew[3] &lt;- sum(y*i*(1-zi))/sum(y*(1-zi))
p &lt;- pnew
return(pnew)
}

objfn &lt;- function(p,y) {
# Objective function whose local minimum is a fixed point 
# negative log-likelihood of binary poisson mixture
i &lt;- 0:(length(y)-1)
loglik &lt;- y*log(p[1]*exp(-p[2])*p[2]^i/exp(lgamma(i+1)) + 
		(1 - p[1])*exp(-p[3])*p[3]^i/exp(lgamma(i+1)))
return ( -sum(loglik) )
}

# Real data from Hasselblad (JASA 1969)
poissmix.dat &lt;- data.frame(death=0:9, freq=c(162,267,271,185,111,61,27,8,3,1))
y &lt;- poissmix.dat$freq

# Use a preset seed so the example is reproducable. 
require("setRNG")
old.seed &lt;- setRNG(list(kind="Mersenne-Twister", normal.kind="Inversion",
    seed=1))

p0 &lt;- c(runif(1),runif(2,0,4))  # random starting value

# Basic EM algorithm, SQUAREM, and parabolic EM, with default settings
res1 &lt;- turboem(par=p0, y=y, fixptfn=fixptfn, objfn=objfn, method=c("EM", "squarem", "pem"))

# Apply methods for class "turbo"
res1
pars(res1)
grad(res1)
hessian(res1)
stderror(res1)
error(res1)

# We get an error for Dynamic ECME (decme) if we do not specify the boundary function
res2 &lt;- turboem(par=p0, y=y, fixptfn=fixptfn, objfn=objfn, 
  method=c("EM", "squarem", "pem", "decme"))
res2
error(res2)

# we can't plot the results, because we did not store the objective function value at each iteration
# Changing the options to store the objective function values, we can:
res1keep &lt;- turboem(par=p0, y=y, fixptfn=fixptfn, objfn=objfn, method=c("EM", "squarem", "pem"), 
  control.run=list(keep.objfval=TRUE))
plot(res1keep, xlim=c(0.001, 0.02))
</code></pre>

<hr>
<h2 id='turboem'>A suite of acceleration schemes for fixed-point iterations</h2><span id='topic+turboem'></span>

<h3>Description</h3>

<p>Globally-convergent, partially monotone, acceleration schemes for accelerating the convergence of <em>any</em> smooth, monotone, slowly-converging contraction mapping. It can be used to accelerate the convergence of a wide variety of iterations including the expectation-maximization (EM) algorithms and its variants, majorization-minimization (MM) algorithm, power method for dominant eigenvalue-eigenvector, Google's page-rank algorithm, and multi-dimensional scaling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>turboem(par, fixptfn, objfn, method = c("em","squarem","pem","decme","qn"), 
        boundary, pconstr = NULL, project = NULL, parallel = FALSE, ..., 
        control.method = replicate(length(method),list()), control.run = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="turboem_+3A_par">par</code></td>
<td>
<p>A vector of parameters denoting the initial guess for the fixed point.</p>
</td></tr>
<tr><td><code id="turboem_+3A_fixptfn">fixptfn</code></td>
<td>
<p>A vector function, <code class="reqn">F</code> that denotes the fixed-point mapping. This function is the most essential input in the package. It should accept a parameter vector as input and should return a parameter vector of same length. This function defines the fixed-point iteration: <code class="reqn">x_{k+1} = F(x_k)</code>. In the case of EM algorithm, <code class="reqn">F</code> defines a single E and M step.</p>
</td></tr> 
<tr><td><code id="turboem_+3A_objfn">objfn</code></td>
<td>
<p>This is a scalar function, <code class="reqn">L</code>, that denotes a &ldquo;merit&rdquo; function which attains its local minimum at the fixed-point of <code class="reqn">F</code>.  This function should accept a parameter vector as input and should return a scalar value.  In the EM algorithm, the merit function <code class="reqn">L</code> is the negative log-likelihood. In some problems, a natural merit function may not exist. However, this argument is required for all of the algorithms *except* Squarem (which defaults to Squarem-2 if <code>objfn</code> not provided) and EM.</p>
</td></tr> 
<tr><td><code id="turboem_+3A_method">method</code></td>
<td>
<p>Specifies which algorithm(s) will be applied. Must be a vector containing one or more of <code>c("em", "squarem", "pem", "decme", "qn")</code>.</p>
</td></tr>
<tr><td><code id="turboem_+3A_boundary">boundary</code></td>
<td>
<p>Argument required for Dynamic ECME (<code>decme</code>) only. Function to define the subspaces over which the line search is conducted.</p>
</td></tr>
<tr><td><code id="turboem_+3A_pconstr">pconstr</code></td>
<td>
<p>Optional function for defining boundary constraints on parameter values. Function maps a vector of parameter values to TRUE if constraints are satisfied. Note that this argument is only used for the Squarem (<code>squarem</code>), Parabolic EM (<code>pem</code>), and quasi-Newton (<code>qn</code>) algorithms, and it has no effect on the other algorithms.</p>
</td></tr>
<tr><td><code id="turboem_+3A_project">project</code></td>
<td>
<p>Optional function for defining a projection that maps an out-of-bound parameter value into the constrained parameter space. Requires the <code>pconstr</code> argument to be specified in order for the <code>project</code> to be applied.</p>
</td></tr>
<tr><td><code id="turboem_+3A_parallel">parallel</code></td>
<td>
<p>Logical indicating whether the acceleration schemes will be run in parallel. Note that the parallel implementation is based on the <code>foreach</code> package, which depends on a <em>parallel backend</em> being registered prior to running <code>turboem()</code>. See *Details* of <code><a href="foreach.html#topic+foreach">foreach</a></code>.</p>
</td></tr>
<tr><td><code id="turboem_+3A_control.method">control.method</code></td>
<td>
<p>If <code>method = c(method1, method2, ...)</code>, then <code>control.method = list(list1, list2, ...)</code> where <code>list1</code> is the list of control parameters for <code>method1</code>, <code>list2</code> is the list of control parameters for <code>method2</code>, and so on. If <code>length(method) == 1</code>, then <code>control.method</code> is the list of control parameters for the acceleration scheme.  
See *Details*.</p>
</td></tr>
<tr><td><code id="turboem_+3A_control.run">control.run</code></td>
<td>
<p>List of control parameters for convergence and stopping the algorithms.
See *Details*.</p>
</td></tr>
<tr><td><code id="turboem_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>fixptfn</code> and  <code>objfn</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>turboem</code> is a general-purpose algorithm for accelerating the convergence of any slowly-convergent (smooth) fixed-point iteration.  
</p>
<p>The component lists of the <code>control.method</code> are used to specify any changes to default values of algorithm control parameters. Full names of control list elements must be specified, otherwise, user specifications are ignored. Default control parameters for <code>method="squarem"</code> are <code>K=1</code>, <code>square=TRUE</code>, <code>version=3</code>, <code>step.min0=1</code>, <code>step.max0=1</code>, <code>mstep=4</code>, <code>kr=1</code>, <code>objfn.inc=1</code>. Default control parameters for <code>method="pem"</code> are <code>l=10</code>, <code>h=0.1</code>, <code>a=1.5</code>, and <code>version="geometric"</code>. Default control parameters for <code>method="decme"</code> are <code>version="v2"</code> and <code>tol_op=0.01</code>. Default control parameters for <code>method="qn"</code> are <code>qn=5</code>.
</p>
<p>Default values of <code>control.run</code> are: <code>convtype = "parameter"</code>, <code>tol = 1.0e-07</code>, <code>stoptype = "maxiter"</code>, <code>maxiter = 1500</code>, <code>maxtime = 60</code>, <code>convfn.user = NULL</code>, <code>stopfn.user = NULL</code>, <code>trace = FALSE</code>, <code>keep.objfval = FALSE</code>, <code>keep.paramval = FALSE</code>.
</p>
<p>There are two ways the algorithm will terminate. Either the algorithm will terminate if convergence has been achieved, or the algorithm will terminate if convergence has not been achieved within a pre-specified maximum number of iterations or maximum running time. The arguments <code>convtype</code>, <code>tol</code>, and <code>convfn.user</code> control the convergence criterion. The arguments <code>stoptype</code>, <code>maxiter</code>, <code>maxtime</code>, and <code>stopfn.user</code> control the alternative stopping criterion.
</p>
<p>Two types of convergence criteria have been implemented, with an option for the user to define his/her own convergence criterion. If <code>convtype = "parameter"</code>, then the default convergence criterion is to terminate if <code>sqrt(crossprod(new - old)) &lt; tol</code>, where <code>new</code> denotes the current value of the fixed point and <code>old</code> denotes the previous fixed-point value. If <code>convtype = "objfn"</code>, then the default convergence criterion is to terminate if <code>abs(new - old) &lt; tol</code>, where <code>new</code> denotes the current value of the objective function and <code>old</code> denotes the previous value of the objective function.
If the user desires alternate convergence criteria,  <code>convfn.user</code> may be specified as a function with inputs <code>new</code> and <code>old</code> that maps to a logical taking the value TRUE if convergence is achieved and the value FALSE if convergence is not achieved. 
</p>
<p>Two types of alternative stopping criteria have been implemented, with the option for the user to define his/her own stopping criterion. If <code>stoptype = "maxiter"</code>, then the algorithm will terminate if convergence has not been achieved within <code>maxiter</code> iterations of the acceleration scheme. If <code>stoptype = "maxtime"</code>, then the algorithm will terminate if convergence has not been achieved within <code>maxtime</code> seconds of running the acceleration scheme. Note: the running time of the acceleration scheme is calculated once every iteration. If the user desires different alternate stopping criteria than those implemented, <code>stopfn.user</code> may be specified as a function with no inputs that maps to a logical taking the value TRUE which leads to the algorithm being terminated or the value FALSE which leads to the algorithm proceeding as usual.
</p>

<dl>
<dt><code>convtype</code></dt><dd><p>A character string equal to <code>"parameter"</code> or <code>"objfn"</code>. <code>"parameter"</code> indicates that the convergence criterion is a function of the current and previous value of the fixed point. <code>objfn</code> indicates that the convergence criterion is a function of the current and previous value of the objective function.</p>
</dd>
<dt><code>tol</code></dt><dd><p>A small, positive scalar that determines when convergence is achieved. See details above for convergence criteria currently implemented. Default is <code>1.e-07</code>.</p>
</dd>
<dt><code>stoptype</code></dt><dd><p>A character string equal to <code>"maxiter"</code> or <code>"maxtime"</code> that determines an alternative stopping rule for the algorithm. See details above for stopping rules currently implemented. Default is <code>"maxiter"</code>.</p>
</dd>
<dt><code>maxiter</code></dt><dd><p>If <code>stoptype = "maxiter"</code>, specifies the number of iterations after which the algorithm will be terminated if convergence has not been achieved. Default is 1500.</p>
</dd>
<dt><code>maxtime</code></dt><dd><p>If <code>stoptype = "maxtime"</code>, specifies the running time (in seconds) after which the algorithm will be terminated if convergence has not been achieved. Default is 60.</p>
</dd>
<dt><code>convfn.user</code></dt><dd><p>Optional, user-specified function for determining whether convergence has been achieved. Function should take as inputs <code>new</code> and <code>old</code>, where <code>new</code> is the current value (of the fixed point if <code>convtype = "parameter"</code> and of the objective function value if <code>convtype = "objfn"</code>) and <code>old</code> is the previous value. Function should map to a logical taking the value <code>TRUE</code> if convergence is achieved (and hence the algorithm is terminated) and the value <code>FALSE</code> if convergence is not achieved. Default is <code>NULL</code>.</p>
</dd>
<dt><code>stopfn.user</code></dt><dd><p>Optional, user-specified function for determining whether to terminate the algorithm if convergence has not been achieved. See details above for how to specify. Default is <code>NULL</code>.</p>
</dd>
<dt><code>trace</code></dt><dd><p>A logical variable denoting whether some of the intermediate results of iterations should be displayed to the user. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>keep.objfval</code></dt><dd><p>A logical variable denoting whether the objective function value at each iteration should be stored. Default is <code>FALSE</code>.</p>
</dd>
<dt><code>keep.paramval</code></dt><dd><p>A logical variable denoting whether the parameter estimates at each iteration should be stored. Default is <code>FALSE</code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p><code>turboem</code> returns an object of class <code>turbo</code>. An object of class <code>turbo</code> is a list containing at least the following components:
</p>
<table role = "presentation">
<tr><td><code>fail</code></td>
<td>
<p>Vector of logical values whose <code class="reqn">j</code>th element indicates whether algorithm <code class="reqn">j</code> failed (produced an error)</p>
</td></tr>
<tr><td><code>value.objfn</code></td>
<td>
<p>Vector of the value of the objective function <code class="reqn">L</code> at termination for each algorithm.</p>
</td></tr>
<tr><td><code>itr</code></td>
<td>
<p>Vector of the number of iterations completed for each algorithm.</p>
</td></tr>
<tr><td><code>fpeval</code></td>
<td>
<p>Vector of the number of fixed-point evaluations completed for each algorithm.</p>
</td></tr>
<tr><td><code>objfeval</code></td>
<td>
<p>Vector of the number of objective function evaluations completed for each algorithm.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>Vector of logical values whose <code class="reqn">j</code>th element indicates whether algorithm <code class="reqn">j</code> satisfied the convergence criterion before termination</p>
</td></tr>
<tr><td><code>runtime</code></td>
<td>
<p>Matrix whose <code class="reqn">j</code>th row contains the &ldquo;user&rdquo;, &ldquo;system&rdquo;, and &ldquo;elapsed&rdquo; time for running the <code class="reqn">j</code>th algorithm.</p>
</td></tr>
<tr><td><code>errors</code></td>
<td>
<p>Vector whose <code class="reqn">j</code>th element is either NA or contains the error message from running the <code class="reqn">j</code>th algorithm</p>
</td></tr>
<tr><td><code>pars</code></td>
<td>
<p>Matrix whose <code class="reqn">j</code>th row contains the fixed-point parameter values at termination for the <code class="reqn">j</code>th algorithm.</p>
</td></tr>
<tr><td><code>trace.objfval</code></td>
<td>
<p>If <code>control.run[["keep.objfval"]]=TRUE</code>, contains a list whose <code class="reqn">j</code>th component is a vector of objective function values across iterations for the <code class="reqn">j</code>th algorithm.</p>
</td></tr>
<tr><td><code>trace.paramval</code></td>
<td>
<p>If <code>control.run[["keep.paramval"]]=TRUE</code>, contains a list whose <code class="reqn">j</code>th component is a matrix of parameter estimates across iterations for the <code class="reqn">j</code>th algorithm.</p>
</td></tr>
</table>


<h3>References</h3>

 
<p>R Varadhan and C Roland (2008). Simple and globally convergent numerical schemes for accelerating the convergence of any EM algorithm. <em>Scandinavian Journal of Statistics</em>, 35:335-353.
</p>
<p>A Berlinet and C Roland (2009). Parabolic acceleration of the EM algorithm. <em>Stat Comput</em>. 19 (1) 35-47.
</p>
<p>Y He and C Liu (2010) The Dynamic ECME Algorithm. Technical Report. arXiv:1004.0524v1.
</p>
<p>H Zhou, DH Alexander, and KL Lange (2011). A quasi-Newton acceleration for high-dimensional optimization algorithms. <em>Stat Comput</em>. 21 (2) 261-273.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+turbo">turbo</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###########################################################################
# Also see the vignette by typing:
#  vignette("turboEM")
#
# EM algorithm for Poisson mixture estimation 

fixptfn &lt;- function(p,y) {
# The fixed point mapping giving a single E and M step of the EM algorithm
# 
pnew &lt;- rep(NA,3)
i &lt;- 0:(length(y)-1)
zi &lt;- p[1]*exp(-p[2])*p[2]^i / (p[1]*exp(-p[2])*p[2]^i + (1 - p[1])*exp(-p[3])*p[3]^i)
pnew[1] &lt;- sum(y*zi)/sum(y)
pnew[2] &lt;- sum(y*i*zi)/sum(y*zi)
pnew[3] &lt;- sum(y*i*(1-zi))/sum(y*(1-zi))
p &lt;- pnew
return(pnew)
}

objfn &lt;- function(p,y) {
# Objective function whose local minimum is a fixed point 
# negative log-likelihood of binary poisson mixture
i &lt;- 0:(length(y)-1)
loglik &lt;- y*log(p[1]*exp(-p[2])*p[2]^i/exp(lgamma(i+1)) + 
		(1 - p[1])*exp(-p[3])*p[3]^i/exp(lgamma(i+1)))
return ( -sum(loglik) )
}

# Real data from Hasselblad (JASA 1969)
poissmix.dat &lt;- data.frame(death = 0:9, 
	freq = c(162,267,271,185,111,61,27,8,3,1))
y &lt;- poissmix.dat$freq

# Use a preset seed so the example is reproducable. 
require("setRNG")
old.seed &lt;- setRNG(list(kind = "Mersenne-Twister", normal.kind = "Inversion",
    seed = 54321))

p0 &lt;- c(runif(1),runif(2,0,4))  # random starting value

# Basic EM algorithm, SQUAREM, and parabolic EM, with default settings
res1 &lt;- turboem(par = p0, y = y, fixptfn = fixptfn, objfn = objfn, 
	method = c("EM", "squarem", "pem"))

# To apply the dynamic ECME (decme) acceleration scheme, 
# we need to include a boundary function
boundary &lt;- function(par, dr) {
	lower &lt;- c(0, 0, 0)
	upper &lt;- c(1, 10000, 10000)
	low1 &lt;- max(pmin((lower-par)/dr, (upper-par)/dr))
	upp1 &lt;- min(pmax((lower-par)/dr, (upper-par)/dr))
	return(c(low1, upp1))
}
res2 &lt;- turboem(par = p0, y = y, fixptfn = fixptfn, objfn = objfn, 
	boundary = boundary, method = c("EM", "squarem", "pem", "decme"))

# change some of the algorithm-specific default specifications (control.method), 
# as well as the global control parameters (control.run)
res3 &lt;- turboem(par = p0, y = y, fixptfn = fixptfn, objfn = objfn, 
  boundary = boundary, method = c("em", "squarem", "squarem", "decme", "qn", "qn"), 
	control.method = list(list(), list(K = 2), list(K = 3), 
		list(version = "v3"), list(qn = 1), list(qn = 2)),
	control.run = list(tol = 1e-12, stoptype = "maxtime", maxtime = 1))

# Only the standard EM algorithm and SQUAREM *do not* require 
# providing the objective function. 
res4 &lt;- turboem(par = p0, y = y, fixptfn = fixptfn, 
	method = c("em", "squarem", "squarem"), 
	control.method = list(list(), list(K = 1), list(K = 2)))
# If no objective function is provided, the "squarem" method defaults to Squarem-2 
# Or, if control parameter K &gt; 1, it defaults to Cyclem-2. 
# Compare Squarem with and without objective function provided:
res5 &lt;- turboem(par = p0, y = y, fixptfn = fixptfn, method = "squarem")
res5
res6 &lt;- turboem(par = p0, y = y, fixptfn = fixptfn, objfn = objfn, method = "squarem")
res6

</code></pre>

<hr>
<h2 id='turbosim'>Methods for objects of class &quot;turbosim&quot;</h2><span id='topic+turbosim'></span><span id='topic+print.turbosim'></span><span id='topic+summary.turbosim'></span><span id='topic+boxplot.turbosim'></span><span id='topic+dataprof'></span><span id='topic+dataprof.turbosim'></span><span id='topic+pairs.turbosim'></span>

<h3>Description</h3>

<p>The <code>turbosim</code> class represents results from benchmark studies of algorithms to acceleration parameter estimation in fixed-point mapping problems.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'turbosim'
print(x, ...)
## S3 method for class 'turbosim'
summary(object, which.methods = seq_along(object$method), 
method.names = object$method.names[which.methods], eps = 0.1, sol = NULL, ...)
## S3 method for class 'turbosim'
boxplot(x, which.methods = seq_along(x$method), 
method.names = x$method.names[which.methods], 
whichfail = (x$fail | !x$conv)[,which.methods], xunit="sec", log=FALSE, ...)
## S3 method for class 'turbosim'
dataprof(x, which.methods = seq_along(x$method), 
method.names = x$method.names[which.methods], 
whichfail = (x$fail | !x$conv)[,which.methods], col, lty, nout = 50, xlim, ...)
## S3 method for class 'turbosim'
pairs(x, which.methods=seq_along(x$method), 
method.names = x$method.names[which.methods], 
whichfail = (x$fail | !x$conv)[,which.methods], ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="turbosim_+3A_object">object</code></td>
<td>
<p>An object of class <code>turbosim</code>, the structure of which is described in *Details*.</p>
</td></tr>
<tr><td><code id="turbosim_+3A_x">x</code></td>
<td>
<p>An object of class <code>turbosim</code>, the structure of which is described in *Details*.</p>
</td></tr>
<tr><td><code id="turbosim_+3A_which.methods">which.methods</code></td>
<td>
<p>A vector identifying for which subset of algorithms results are desired.</p>
</td></tr> 
<tr><td><code id="turbosim_+3A_method.names">method.names</code></td>
<td>
<p>A vector of unique identifiers for the algorithms for which results are being provided.</p>
</td></tr>
<tr><td><code id="turbosim_+3A_eps">eps</code></td>
<td>
<p>Used to define a tolerance between the objective function value attained by a particular acceleration scheme and the best achievable objective function value (either across schemes or as defined by the user). 
See *Details*.</p>
</td></tr>
<tr><td><code id="turbosim_+3A_sol">sol</code></td>
<td>
<p>Optional argument defining the best achievable objective function value for a given fixed-point mapping problem. Defaults to NULL. 
See *Details*.</p>
</td></tr>
<tr><td><code id="turbosim_+3A_xunit">xunit</code></td>
<td>
<p>Units for running time to be used in the boxplots. Argument takes the value &quot;sec&quot; or &quot;min.&quot;</p>
</td></tr>
<tr><td><code id="turbosim_+3A_log">log</code></td>
<td>
<p>Logical indicating whether the log of the running time will be plotted. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="turbosim_+3A_whichfail">whichfail</code></td>
<td>
<p>A matrix of logical values where the (<code class="reqn">i</code>,<code class="reqn">j</code>)-entry indicates whether algorithm j of simulation iteration i failed (however the user wishes to define a failure for visualization purposes). If argument is not provided by user, then by default a failure is defined to be the event where the algorithm produces an error *or* does not converge.</p>
</td></tr>
<tr><td><code id="turbosim_+3A_col">col</code></td>
<td>
<p>Optional argument: A vector where each component defines the color for the line corresponding to each algorithm being compared.</p>
</td></tr>
<tr><td><code id="turbosim_+3A_lty">lty</code></td>
<td>
<p>Optional argument: A vector where each component defines the line-type for the line corresponding to each algorithm being compared.</p>
</td></tr>
<tr><td><code id="turbosim_+3A_nout">nout</code></td>
<td>
<p>Number of values at which the empirical distribution function is estimated. Should be less than the number of simulation iterations.</p>
</td></tr>
<tr><td><code id="turbosim_+3A_xlim">xlim</code></td>
<td>
<p>Optional argument: Defines the x-axis limits for the data profile. Defaults to the full range of the running times over all algorithms being plotted.</p>
</td></tr>
<tr><td><code id="turbosim_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An object of class <code>turbosim</code> is typically the product of the function <code><a href="#topic+turboSim">turboSim</a></code>. It is a list containing at least the following components:
</p>

<dl>
<dt><code>method.names</code></dt><dd><p>Vector of unique identifiers for the algorithms being compared</p>
</dd>
<dt><code>fail</code></dt><dd><p>Matrix whose (<code class="reqn">i</code>,<code class="reqn">j</code>)-element is a logical (TRUE/FALSE) for whether the <code class="reqn">j</code>th algorithm at the <code class="reqn">i</code>th benchmark study repetition failed (produced an error).</p>
</dd>
<dt><code>convergence</code></dt><dd><p>Matrix whose (<code class="reqn">i</code>,<code class="reqn">j</code>)-element is a logical (TRUE/FALSE) for whether the <code class="reqn">j</code>th algorithm at the <code class="reqn">i</code>th benchmark study repetition satisfied the convergence criterion before termination.</p>
</dd>
<dt><code>value.objfn</code></dt><dd><p>Matrix whose (<code class="reqn">i</code>,<code class="reqn">j</code>)-element is the value of the objective function of the <code class="reqn">j</code>th algorithm at the <code class="reqn">i</code>th benchmark study repetition.</p>
</dd>
<dt><code>runtime</code></dt><dd><p>Matrix whose (<code class="reqn">i</code>,<code class="reqn">j</code>)-element is the running time of the <code class="reqn">j</code>th algorithm at the <code class="reqn">i</code>th benchmark study repetition.</p>
</dd>
<dt><code>itr</code></dt><dd><p>Matrix whose (<code class="reqn">i</code>,<code class="reqn">j</code>)-element is the number of completed iterations of the <code class="reqn">j</code>th algorithm at the <code class="reqn">i</code>th benchmark study repetition.</p>
</dd>
<dt><code>fpeval</code></dt><dd><p>Matrix whose (<code class="reqn">i</code>,<code class="reqn">j</code>)-element is the number of fixed-point function evaluations of the <code class="reqn">j</code>th algorithm at the <code class="reqn">i</code>th benchmark study repetition.</p>
</dd>
<dt><code>objfeval</code></dt><dd><p>Matrix whose (<code class="reqn">i</code>,<code class="reqn">j</code>)-element is the number of objective function evaluations of the <code class="reqn">j</code>th algorithm at the <code class="reqn">i</code>th benchmark study repetition.</p>
</dd>
<dt><code>errors</code></dt><dd><p>Matrix whose (<code class="reqn">i</code>,<code class="reqn">j</code>)-element contains the error message produced by the <code class="reqn">j</code>th algorithm at the <code class="reqn">i</code>th benchmark study repetition (if there was an error).</p>
</dd>
</dl>

<p>This list usually will also contain the components <code>fixptfn</code>, <code>objfn</code>, <code>method</code>, <code>pconstr</code>, <code>project</code>, <code>control.method</code>, and <code>control.run</code>, which were provided as arguments for <code><a href="#topic+turboSim">turboSim</a></code>.
</p>
<p>The <code>summary</code> function shows a table of the number of failures across acceleration schemes. There are three types of failures. The first occurs when the algorithm produces an error message. The second is if the algorithm does not converge before the alternative stopping rule is achieved (e.g. the maximum number of iterations or maximum pre-specified runtime is reached). The third is if the algorithm claims convergence but the value of the objective function is &quot;far&quot; from the best achievable value. To assess this third type of failure, we determine whether the objective function value achieved by the algorithm is close (within <code>eps</code>) to the smallest value achieved across all algorithms at that simulation iteration. Alternatively, if the user knows a priori the true objective function value, he/she may specify the argument <code>sol</code>, in which case, the third type of failure occurs when the objective function value achieved by the algorithm is within <code>eps</code> of <code>sol</code>.
</p>
<p>Further details for each of the methods are provided in the vignette, which can be seen by typing <code>vignette("turboEM")</code>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>summary</code></td>
<td>
<p>Summarizes the number of failures by type across simulation iterations for each acceleration scheme.</p>
</td></tr>
<tr><td><code>boxplot</code></td>
<td>
<p>Shows box plots of algorithm running times for each acceleration scheme.</p>
</td></tr>
<tr><td><code>dataprof</code></td>
<td>
<p>Plots the data profile, or the estimated distribution function of the time until convergence for each acceleration scheme.</p>
</td></tr>
<tr><td><code>pairs</code></td>
<td>
<p>Scatterplot matrix showing pairwise comparison of the running times for each pair of acceleration schemes.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+turboem">turboem</a>, <a href="#topic+turbo">turbo</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
###########################################################################
# Examples provided in the vignette, which can be seen by typing
#  vignette("turboEM")

</code></pre>

<hr>
<h2 id='turboSim'>Conduct benchmark studies of EM accelerator</h2><span id='topic+turboSim'></span>

<h3>Description</h3>

<p>The <code>turboSim</code> function conducts benchmark studies to compare performance of multiple acceleration schemes over a large number of repetitions. The <code><a href="#topic+turboSim">turboSim</a></code> function outputs objects of class <code>turbosim</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>turboSim(parmat, fixptfn, objfn, method = c("em","squarem","pem","decme","qn"), 
  boundary, pconstr = NULL, project = NULL, parallel = FALSE, method.names, 
  keep.pars = FALSE, ..., control.method = replicate(length(method),list()), 
  control.run = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="turboSim_+3A_parmat">parmat</code></td>
<td>
<p>A matrix of starting parameter values, where each row corresponds to a single benchmark study repetition.</p>
</td></tr>
<tr><td><code id="turboSim_+3A_fixptfn">fixptfn</code></td>
<td>
<p>A vector function, <code class="reqn">F</code> that denotes the fixed-point mapping. This function is the most essential input in the package. It should accept a parameter vector as input and should return a parameter vector of same length. This function defines the fixed-point iteration: <code class="reqn">x_{k+1} = F(x_k)</code>. In the case of EM algorithm, <code class="reqn">F</code> defines a single E and M step.</p>
</td></tr> 
<tr><td><code id="turboSim_+3A_objfn">objfn</code></td>
<td>
<p>This is a scalar function, <code class="reqn">L</code>, that denotes a &ldquo;merit&rdquo; function which attains its local minimum at the fixed-point of <code class="reqn">F</code>.  This function should accept a parameter vector as input and should return a scalar value.  In the EM algorithm, the merit function <code class="reqn">L</code> is the negative log-likelihood. In some problems, a natural merit function may not exist. However, this argument is required for all of the algorithms *except* Squarem (which defaults to Squarem-2 if <code>objfn</code> not provided) and EM.</p>
</td></tr> 
<tr><td><code id="turboSim_+3A_method">method</code></td>
<td>
<p>Specifies which algorithm(s) will be applied. Must be a vector containing one or more of <code>c("em", "squarem", "pem", "decme", "qn")</code>.</p>
</td></tr>
<tr><td><code id="turboSim_+3A_boundary">boundary</code></td>
<td>
<p>Argument required for Dynamic ECME (<code>decme</code>) only. Function to define the subspaces over which the line search is conducted.</p>
</td></tr>
<tr><td><code id="turboSim_+3A_pconstr">pconstr</code></td>
<td>
<p>Optional function for defining boundary constraints on parameter values. Function maps a vector of parameter values to TRUE if constraints are satisfied. Note that this argument is only used for the Squarem (<code>squarem</code>), Parabolic EM (<code>pem</code>), and quasi-Newton (<code>qn</code>) algorithms, and it has no effect on the other algorithms.</p>
</td></tr>
<tr><td><code id="turboSim_+3A_project">project</code></td>
<td>
<p>Optional function for defining a projection that maps an out-of-bound parameter value into the constrained parameter space. Requires the <code>pconstr</code> argument to be specified in order for the <code>project</code> to be applied.</p>
</td></tr>
<tr><td><code id="turboSim_+3A_parallel">parallel</code></td>
<td>
<p>Logical indicating whether the <em>repetitions</em> of the benchmark study will be run in parallel. Note that the parallel implementation is based on the <code>foreach</code> package, which depends on a <em>parallel backend</em> being registered prior to running <code>turboSim()</code>. See *Details* of <code><a href="foreach.html#topic+foreach">foreach</a></code>.</p>
</td></tr>
<tr><td><code id="turboSim_+3A_method.names">method.names</code></td>
<td>
<p>Vector of unique names that identify the algorithms being compared.</p>
</td></tr>
<tr><td><code id="turboSim_+3A_keep.pars">keep.pars</code></td>
<td>
<p>Logical indicating whether the parameter values at termination should be kept. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="turboSim_+3A_control.method">control.method</code></td>
<td>
<p>If <code>method = c(method1, method2, ...)</code>, then <code>control.method = list(list1, list2, ...)</code> where <code>list1</code> is the list of control parameters for <code>method1</code>, <code>list2</code> is the list of control parameters for <code>method2</code>, and so on. If <code>length(method) == 1</code>, then <code>control.method</code> is the list of control parameters for the acceleration scheme.  
See *Details* of <code><a href="#topic+turboem">turboem</a></code>.</p>
</td></tr>
<tr><td><code id="turboSim_+3A_control.run">control.run</code></td>
<td>
<p>List of control parameters for convergence and stopping the algorithms.
See *Details* of <code><a href="#topic+turboem">turboem</a></code>.</p>
</td></tr>
<tr><td><code id="turboSim_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>fixptfn</code> and  <code>objfn</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>turboSim</code> returns an object of class <code><a href="#topic+turbosim">turbosim</a></code>.	
</p>


<h3>See Also</h3>

<p><code><a href="#topic+turbosim">turbosim</a>, <a href="#topic+turboem">turboem</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
###########################################################################
# Examples provided in the vignette, which can be seen by typing
#  vignette("turboEM")

</code></pre>

<hr>
<h2 id='votes'>Roll Call Votes</h2><span id='topic+votes'></span>

<h3>Description</h3>

<p>Roll call votes from the U.S. House of Representatives, 2005.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(votes)</code></pre>


<h3>Format</h3>

<p>A 401-by-669 matrix whose (<code class="reqn">i</code>,<code class="reqn">j</code>)-entry corresponds to the vote of the <code class="reqn">i</code>th representative on the <code class="reqn">j</code>th roll call. Possible votes are &quot;yea&quot;, &quot;nay&quot;, or &quot;not voting&quot;, which are represented by 1/2, -1/2, and 0, respectively.</p>


<h3>Source</h3>

<p>Diaconis PD, Goel S, and Holmes S (2008). Horseshoes in Multidimensional Scaling and Local Kernel Methods. <em>Annals of Applied Statistics</em>. 2 (3) 777-807. Supplementary material.</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
