<!DOCTYPE html><html><head><title>Help for package unitizer</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {unitizer}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#unitizer'><p>unitizer</p></a></li>
<li><a href='#+24+2CunitizerItemTestsErrorsDiffs-method'><p>Subsetting Methods for unitizerItemTestsErrorsDiffs objects</p></a></li>
<li><a href='#+24.unitizerItem'><p>Retrieve Test Contents From Test Item</p></a></li>
<li><a href='#all_eq'><p>Like all.equal but Returns Empty String If Not all.equal</p></a></li>
<li><a href='#all.equal.condition'><p>Compare Conditions</p></a></li>
<li><a href='#as.character+2CunitizerChanges-method'><p>Print Out A Summary Of the Changes</p></a></li>
<li><a href='#as.character.bullet'><p>Produce Character Vector Representation of Bullet Lists</p></a></li>
<li><a href='#as.expression+2CunitizerList-method'><p>Coerce to expression by returning items coerced to expressions</p></a></li>
<li><a href='#cap_first'><p>Captalizes or Decapitalizes First Letter</p></a></li>
<li><a href='#capture_output'><p>Capture Both StdOut and StdErr</p></a></li>
<li><a href='#conditionList'><p>Contains A List of Conditions</p></a></li>
<li><a href='#desc'><p>One Line Description of Object</p></a></li>
<li><a href='#editCalls'><p>Edit Calls In Unitizer</p></a></li>
<li><a href='#filename_to_storeid'><p>Create a Store ID from a Test File Name</p></a></li>
<li><a href='#flattenUntz'><p>Reduce S4 objects Into Lists</p></a></li>
<li><a href='#getFun'><p>Utility Function</p></a></li>
<li><a href='#healEnvs'><p>Fix Environment Ancestries</p></a></li>
<li><a href='#infer_unitizer_location'><p>Infers Possible Unitizer Path From Context</p></a></li>
<li><a href='#invalidateLs'><p>Clears ls Info and Marks as Invalid</p></a></li>
<li><a href='#length+2CunitizerChanges-method'><p>Return Sum of Total Changes</p></a></li>
<li><a href='#length+2CunitizerSection-method'><p>Compute Length of a <code>unitizerSection-class</code></p></a></li>
<li><a href='#mock_item'><p>Generates a Dummy Item For Use in Examples</p></a></li>
<li><a href='#nextItem+2CunitizerList-method'><p>Iterate through items of a <code>unitizerList</code> ObjectJK</p></a></li>
<li><a href='#options_zero'><p>Set Options to Initial Zero State</p></a></li>
<li><a href='#print.bullet'><p>Print Methods for <code>UL</code> and <code>OL</code> objects</p></a></li>
<li><a href='#repair_environments'><p>Repair Environment Chains</p></a></li>
<li><a href='#run_ls'><p>Worker function to actually execute the 'ls' work</p></a></li>
<li><a href='#set_unitizer'><p>Set and Retrieve Store Contents</p></a></li>
<li><a href='#show+2CunitizerChanges-method'><p>Print Out A Summary Of the Changes</p></a></li>
<li><a href='#show+2CunitizerDummy-method'><p>Documentation Block for Internal S4 Methods</p></a></li>
<li><a href='#show+2CunitizerItemTestsErrorsDiff-method'><p>Show Method for unitizerItemTestsErrorsDiff objects</p></a></li>
<li><a href='#show+2CunitizerItemTestsErrorsDiffs-method'><p>Show Method for unitizerItemTestsErrorsDiffs objects</p></a></li>
<li><a href='#show.conditionList'><p>Prints A list of Conditions</p></a></li>
<li><a href='#sizeRDS'><p>Measure object size as an RDS</p></a></li>
<li><a href='#sizeUntz'><p>Utility To Examine Object Size</p></a></li>
<li><a href='#testFuns'><p>Store Functions for New vs. Reference Test Comparisons</p></a></li>
<li><a href='#testthat_transcribe_file'><p>Transcribes a <code>testtaht</code> File Into <code>unitizer</code> Format</p></a></li>
<li><a href='#testthat_translate_file'><p>Convert a <code>testthat</code> Test File to a <code>unitizer</code></p></a></li>
<li><a href='#text_wrap'><p>Text Wrapping Utilities</p></a></li>
<li><a href='#unitize'><p>Unitize an R Test Script</p></a></li>
<li><a href='#unitizer_demo'><p>Demo Details and Helper Functions</p></a></li>
<li><a href='#unitizer_ls'><p>An 'ls' Like Function</p></a></li>
<li><a href='#unitizer_prompt'><p>Interactively Retrieve User Input</p></a></li>
<li><a href='#unitizer_result'><p>Return Values and Related Methods for <code>unitize</code> Functions</p></a></li>
<li><a href='#unitizer_sect'><p>Define a <code>unitizer</code> Section</p></a></li>
<li><a href='#unitizer.opts'><p>Unitizer Options</p></a></li>
<li><a href='#unitizerChanges-class'><p>Summary of Changes</p></a></li>
<li><a href='#unitizerGlobalBase-class'><p>Structures For Tracking Global Options</p></a></li>
<li><a href='#unitizerList'><p>S4 Object To Implement Base List Methods</p></a></li>
<li><a href='#unitizerSection-class'><p>Contains Representation For a Section of Tests</p></a></li>
<li><a href='#unitizerState'><p>Tests and Session State</p></a></li>
<li><a href='#unitizerTests-class'><p>Collections of Calls For Testing</p></a></li>
<li><a href='#valid_names'><p>Make Valid Names</p></a></li>
<li><a href='#validate_pre_post'><p>Helper function for validations</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Interactive R Unit Tests</td>
</tr>
<tr>
<td>Description:</td>
<td>Simplifies regression tests by comparing objects produced by test
    code with earlier versions of those same objects.  If objects are unchanged
    the tests pass, otherwise execution stops with error details.  If in
    interactive mode, tests can be reviewed through the provided interactive
    environment.</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.21</td>
</tr>
<tr>
<td>Depends:</td>
<td>methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, crayon (&ge; 1.3.2), diffobj (&ge; 0.1.5.9000)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/brodieG/unitizer">https://github.com/brodieG/unitizer</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/brodieG/unitizer/issues">https://github.com/brodieG/unitizer/issues</a></td>
</tr>
<tr>
<td>Collate:</td>
<td>'asciiml.R' 'capture.R' 'is.R' 'global.R' 'change.R'
'class_unions.R' 'list.R' 'conditions.R' 'item.R' 'deparse.R'
'text.R' 'item.sub.R' 'section.R' 'test.R' 'unitizer.R'
'exec.R' 'prompt.R' 'browse.struct.R' 'browse.R' 'demo.R'
'diff.R' 'faux_prompt.R' 'get.R' 'heal.R' 'load.R' 'ls.R'
'misc.R' 'search.R' 'options.R' 'onload.R' 'parse.R' 'rename.R'
'repairenvs.R' 'result.R' 'shims.R' 'size.R' 'state.R'
'state.compare.R' 'traceback.R' 'translate.R' 'unitize.R'
'unitize.core.R' 'unitizer-package.R' 'unitizer.add.R'
'upgrade.R'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-18 19:12:52 UTC; bg</td>
</tr>
<tr>
<td>Author:</td>
<td>Brodie Gaslam [aut, cre],
  R Core Team [cph] (Traceback function sources.)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Brodie Gaslam &lt;brodie.gaslam@yahoo.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-18 19:50:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='unitizer'>unitizer</h2><span id='topic+unitizer'></span><span id='topic+unitizer-package'></span>

<h3>Description</h3>

<p>Simplifies regression tests by comparing objects produced by test
code with earlier versions of those same objects.  If objects are unchanged
the tests pass.  'unitizer' provides an interactive interface to review
failing tests or new tests.  See vignettes for details.
</p>

<hr>
<h2 id='+24+2CunitizerItemTestsErrorsDiffs-method'>Subsetting Methods for unitizerItemTestsErrorsDiffs objects</h2><span id='topic++24+2CunitizerItemTestsErrorsDiffs-method'></span><span id='topic++5B+5B+2CunitizerItemTestsErrorsDiffs+2CANY-method'></span>

<h3>Description</h3>

<p>Subsetting Methods for unitizerItemTestsErrorsDiffs objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'unitizerItemTestsErrorsDiffs'
x$name

## S4 method for signature 'unitizerItemTestsErrorsDiffs,ANY'
x[[i, j, ..., exact = TRUE]]
</code></pre>

<hr>
<h2 id='+24.unitizerItem'>Retrieve Test Contents From Test Item</h2><span id='topic++24.unitizerItem'></span><span id='topic++24+2CunitizerItem-method'></span><span id='topic++5B+5B+2CunitizerItem+2CANY-method'></span>

<h3>Description</h3>

<p>Intended for use within the <code>unitizer</code> interactive environment, allows
user to retrieve whatever portions of tests are stored by <code>unitizer</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'unitizerItem'
x$name

## S4 method for signature 'unitizerItem,ANY'
x[[i, j, ..., exact = TRUE]]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B24.unitizerItem_+3A_x">x</code></td>
<td>
<p>a <code>unitizerItem</code> object, typically <code>.NEW</code> or <code>.REF</code>
at the <code>unitizer</code> interactive prompt</p>
</td></tr>
<tr><td><code id="+2B24.unitizerItem_+3A_name">name</code></td>
<td>
<p>a valid test sub-component</p>
</td></tr>
<tr><td><code id="+2B24.unitizerItem_+3A_i">i</code></td>
<td>
<p>a valid test sub-component as a character string, or a sub-component
index</p>
</td></tr>
<tr><td><code id="+2B24.unitizerItem_+3A_j">j</code></td>
<td>
<p>missing for compatibility with generic</p>
</td></tr>
<tr><td><code id="+2B24.unitizerItem_+3A_...">...</code></td>
<td>
<p>missing for compatibility with generic</p>
</td></tr>
<tr><td><code id="+2B24.unitizerItem_+3A_exact">exact</code></td>
<td>
<p>unused, always matches exact</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently the following elements are available:
</p>

<ul>
<li> <p><code>call</code> the call that was tested as an unevaluated call,
but keep in mind that if you intend to evaluate this for a reference
item the environment may not be the same so you could get different
results (<code>ls</code> will provide more details)
</p>
</li>
<li> <p><code>value</code> the value that results from evaluating the test, note
this is equivalent to using <code>.new</code> or <code>.ref</code>; note that the
value is displayed using <code><a href="#topic+desc">desc</a></code> when viewing all of
<code>.NEW</code> or <code>.REF</code>
</p>
</li>
<li> <p><code>output</code> the screen output (i.e. anything produced by cat/print,
or any visible evaluation output) as a character vector
</p>
</li>
<li> <p><code>message</code> anything that was output to <code>stderr</code>, mostly
this is all contained in the conditions as well, though there could be
other output here, as a character vector
</p>
</li>
<li> <p><code>conditions</code> a <code><a href="#topic+conditionList">conditionList</a></code> containing all
the conditions produced during test evaluation
</p>
</li>
<li> <p><code>aborted</code> whether the test call issues a restart call to the
'abort' restart, as 'stop' does.
</p>
</li></ul>



<h3>Value</h3>

<p>the test component requested
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## From the unitizer&gt; prompt:
.NEW &lt;- mock_item()  # .NEW is normally available at unitizer prompt
.NEW$call
.NEW$conditions
.NEW$value              # equivalent to `.new`
</code></pre>

<hr>
<h2 id='all_eq'>Like all.equal but Returns Empty String If Not all.equal</h2><span id='topic+all_eq'></span>

<h3>Description</h3>

<p>Used as the default value comparison function since when values mismatch
we use <code><a href="diffobj.html#topic+diffObj">diffObj</a></code> which would make the text output from
<code><a href="base.html#topic+all.equal">all.equal</a></code> somewhat redundant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_eq(target, current, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_eq_+3A_target">target</code></td>
<td>
<p>R object</p>
</td></tr>
<tr><td><code id="all_eq_+3A_current">current</code></td>
<td>
<p>other R object to be compared to <code>target</code></p>
</td></tr>
<tr><td><code id="all_eq_+3A_...">...</code></td>
<td>
<p>arguments to pass to <code><a href="base.html#topic+all.equal">all.equal</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if <code>all.equal</code> returns TRUE, &quot;&quot; otherwise
all_eq(1, 1L)
all_eq(1, 2)
isTRUE(all_eq(1, 2))
</p>

<hr>
<h2 id='all.equal.condition'>Compare Conditions</h2><span id='topic+all.equal.condition'></span><span id='topic+all.equal+2Ccondition+2CANY-method'></span><span id='topic+all.equal+2CconditionList+2CANY-method'></span><span id='topic+all.equal.conditionList'></span>

<h3>Description</h3>

<p>Tests that issue warnings or 'stop' produce <code><a href="base.html#topic+condition">condition</a></code> objects.
The functions documented here are specialized versions of
<code><a href="base.html#topic+all.equal">all.equal</a></code> designed specifically to compare conditions and
condition lists produced during <code>unitizer</code> test evaluations.
<code><a href="#topic+conditionList">conditionList</a></code> objects are lists of conditions that come about
when test expressions emit multiple conditions (e.g. more than one warning).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'conditionList,ANY'
all.equal(target, current, ...)

## S3 method for class 'equal.conditionList'
all(target, current, ...)

## S3 method for class 'equal.condition'
all(target, current, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all.equal.condition_+3A_target">target</code></td>
<td>
<p>the list of conditions that we are matching against</p>
</td></tr>
<tr><td><code id="all.equal.condition_+3A_current">current</code></td>
<td>
<p>the list of conditions we are checking</p>
</td></tr>
<tr><td><code id="all.equal.condition_+3A_...">...</code></td>
<td>
<p>provided for compatibility with generic</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="base.html#topic+condition">condition</a></code> objects produced by tests have one additional
attributed &ldquo;printed&rdquo; which disambiguates whether a condition was the
result of the test expression, or the <code>print</code> / <code>show</code> method used
to display it to screen.
</p>
<p>For <code>conditionList</code> objects, these methods only return TRUE if all
conditions are pairwise <code>all.equal</code>.
</p>


<h3>Value</h3>

<p>TRUE if the (lists of) conditions are equivalent, a character
vector explaining why they are not otherwise
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cond.1 &lt;- simpleWarning('hello world')
cond.2 &lt;- simpleError('hello world')
cond.3 &lt;- simpleError('goodbye world')
all.equal(cond.1, cond.1)
all.equal(cond.1, cond.2)
all.equal(cond.2, cond.3)
## Normally you would never actually create a `conditionList` yourself; these
## are automatically generated by `unitizer` for review at the `unitizer`
## prompt
all.equal(
  conditionList(.items=list(cond.1, cond.2)),
  conditionList(.items=list(cond.1, cond.3))
)
</code></pre>

<hr>
<h2 id='as.character+2CunitizerChanges-method'>Print Out A Summary Of the Changes</h2><span id='topic+as.character+2CunitizerChanges-method'></span>

<h3>Description</h3>

<p>Print Out A Summary Of the Changes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'unitizerChanges'
as.character(x, width = getOption("width"), ...)
</code></pre>

<hr>
<h2 id='as.character.bullet'>Produce Character Vector Representation of Bullet Lists</h2><span id='topic+as.character.bullet'></span>

<h3>Description</h3>

<p>Produce Character Vector Representation of Bullet Lists
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bullet'
as.character(x, width = 0L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.character.bullet_+3A_x">x</code></td>
<td>
<p>object to render</p>
</td></tr>
<tr><td><code id="as.character.bullet_+3A_width">width</code></td>
<td>
<p>how many characters to wrap at</p>
</td></tr>
<tr><td><code id="as.character.bullet_+3A_...">...</code></td>
<td>
<p>dots, other arguments to pass to <code>word_wrap</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector containing rendered object, where each element
corresponds to a line
</p>

<hr>
<h2 id='as.expression+2CunitizerList-method'>Coerce to expression by returning items coerced to expressions</h2><span id='topic+as.expression+2CunitizerList-method'></span>

<h3>Description</h3>

<p>Really only meaningful for classes that implement the <code>.items</code>
slot as an expression, but works for others to the extent
<code>.items</code> contents are coercible to expressions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'unitizerList'
as.expression(x, ...)
</code></pre>

<hr>
<h2 id='cap_first'>Captalizes or Decapitalizes First Letter</h2><span id='topic+cap_first'></span><span id='topic+decap_first'></span>

<h3>Description</h3>

<p>Captalizes or Decapitalizes First Letter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cap_first(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cap_first_+3A_x">x</code></td>
<td>
<p>character</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character
</p>

<hr>
<h2 id='capture_output'>Capture Both StdOut and StdErr</h2><span id='topic+capture_output'></span><span id='topic+print.captured_output'></span>

<h3>Description</h3>

<p>Will sink both &quot;output&quot; and &quot;message&quot; streams without checking whether they
are already sunk, and will unsink them the same way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>capture_output(expr, env = parent.frame())

## S3 method for class 'captured_output'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="capture_output_+3A_expr">expr</code></td>
<td>
<p>a quoted expression to evaluate</p>
</td></tr>
<tr><td><code id="capture_output_+3A_env">env</code></td>
<td>
<p>an environment to evaluate them in</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with stdout and stderr captured separately, classed as
&quot;captured_output&quot;
</p>

<hr>
<h2 id='conditionList'>Contains A List of Conditions</h2><span id='topic+conditionList'></span><span id='topic+conditionList-class'></span>

<h3>Description</h3>

<p>Condition lists are S4 classes that contain <code><a href="base.html#topic+condition">condition</a></code> objects
emitted by <code>unitizer</code> tests.  Condition lists will typically be
accessible via the <code>.NEW</code> and <code>.REF</code> <code>unitizer</code> test objects.
You can access individual conditions using <code>[[</code> (see examples), and for
the most part you can treat them as you would an S3 list containing
conditions.
</p>


<h3>Details</h3>

<p>There are <code>show</code> and <code>all.equal</code> methods implemented for them, the
latter of which is used to compare conditions across tests.  If you wish to
implement a custom comparison function via <code><a href="#topic+unitizer_sect">unitizer_sect</a></code>, your
function will need to compare <code>conditionList</code> objects.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.items</code></dt><dd><p>list of conditions</p>
</dd>
</dl>


<h3>Note</h3>

<p>Implemented as an S4 class to avoid <code>setOldClass</code> and related
compatibility issues; the <code>conditionList</code> class contains
<code><a href="#topic+unitizerList">unitizerList</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unitizer_sect">unitizer_sect</a></code>, <code><a href="#topic+unitizerList">unitizerList</a></code>,
<code><a href="#topic+all.equal.conditionList">all.equal.conditionList</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create a test item as you would find normally at the `unitizer` prompt
## for illustrative purposes:
.NEW &lt;- mock_item()
## Access the first condition from the new test evaluation
.NEW$conditions[[1L]]
## loop through all conditions
for(i in seq_along(.NEW$conditions)) .NEW$conditions[[i]]
</code></pre>

<hr>
<h2 id='desc'>One Line Description of Object</h2><span id='topic+desc'></span>

<h3>Description</h3>

<p>Objects are described by class, and dimensions.  Dimensions is always denoted
in square brackets.  For example, &ldquo;int[10]&rdquo; means an integer of length
ten.  Typically an object will be identified by <code>head(class(obj), 1L)</code>
along with its dimensions.  Recursive objects will have the first level shown
provided that doing so fits within <code>limit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>desc(val, limit = getOption("width"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="desc_+3A_val">val</code></td>
<td>
<p>object to describe</p>
</td></tr>
<tr><td><code id="desc_+3A_limit">limit</code></td>
<td>
<p>max characters to display</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Eventually this will be migrated to an S3 generic to allow recursive dispatch
on object type.
</p>


<h3>Value</h3>

<p>character(1L) describing object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>desc(list(a=iris, b=lm(dist ~ speed, cars), 1:10, matrix(letters, 2)))
</code></pre>

<hr>
<h2 id='editCalls'>Edit Calls In Unitizer</h2><span id='topic+editCalls'></span><span id='topic+editCalls+2Cunitizer+2Clanguage+2Clanguage-method'></span>

<h3>Description</h3>

<p>Used if you want to change language in test expression in a unitizer when
the actual results of running the expressions is unchanged.  This is useful
if you decided to rename functions, etc., without having to re-run the entire
<code>unitize</code> process since <code>unitize</code> matches tests based on
expressions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>editCalls(x, lang.old, lang.new, ...)

## S4 method for signature 'unitizer,language,language'
editCalls(
  x,
  lang.old,
  lang.new,
  interactive.mode = interactive(),
  interactive.only = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="editCalls_+3A_x">x</code></td>
<td>
<p>a unitizer object</p>
</td></tr>
<tr><td><code id="editCalls_+3A_lang.old">lang.old</code></td>
<td>
<p>the name of the function replace</p>
</td></tr>
<tr><td><code id="editCalls_+3A_lang.new">lang.new</code></td>
<td>
<p>the new name of the function</p>
</td></tr>
<tr><td><code id="editCalls_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
<tr><td><code id="editCalls_+3A_interactive.mode">interactive.mode</code></td>
<td>
<p>logical(1L) whether to run in interactive mode (
request user input when needed) or not (error if user input is required,
e.g. if all tests do not pass).</p>
</td></tr>
<tr><td><code id="editCalls_+3A_interactive.only">interactive.only</code></td>
<td>
<p>logical(1L) set to FALSE if you want to allow this to
run in non-interactive mode, but warnings will be suppressed and will
proceed without prompting, obviously...</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a untizer object with function names modifies
</p>


<h3>Note</h3>

<p>this is a somewhat experimental function, so make sure you backup any
unitizers before you try to use it.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
untz &lt;- get_unitizer("tests/unitizer/mytests.unitizer")
untz.edited &lt;- editCalls(untz, quote(myFun), quote(my_fun))
set_unitizer("tests/unitizer/mytests.unitizer", untz.edited)

## End(Not run)
</code></pre>

<hr>
<h2 id='filename_to_storeid'>Create a Store ID from a Test File Name</h2><span id='topic+filename_to_storeid'></span>

<h3>Description</h3>

<p>Create a Store ID from a Test File Name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filename_to_storeid(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filename_to_storeid_+3A_x">x</code></td>
<td>
<p>character(1L) file name ending in .r or .R</p>
</td></tr>
</table>


<h3>Value</h3>

<p>store id name, or NULL if <code>x</code> doesn't meet expectations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>filename_to_storeid(file.path("tests", "unitizer", "foo.R"))
filename_to_storeid(file.path("tests", "unitizer", "boo.r"))
# does not end in [rR]
filename_to_storeid(file.path("tests", "unitizer", "boo"))
</code></pre>

<hr>
<h2 id='flattenUntz'>Reduce S4 objects Into Lists</h2><span id='topic+flattenUntz'></span>

<h3>Description</h3>

<p>This is particularly useful with &quot;list&quot; type S4 objects, and relates loosely
to the subsetting functions defined for <code>unitizerBrowse</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flattenUntz(x, ...)
</code></pre>


<h3>Details</h3>

<p>Currently we only define a method for <code>unitizerItems-class</code> objects
</p>

<hr>
<h2 id='getFun'>Utility Function</h2><span id='topic+getFun'></span>

<h3>Description</h3>

<p>Utility Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFun(name)
</code></pre>

<hr>
<h2 id='healEnvs'>Fix Environment Ancestries</h2><span id='topic+healEnvs'></span><span id='topic+healEnvs+2CunitizerItems+2Cunitizer-method'></span>

<h3>Description</h3>

<p>This is an internal method and exposed so that this aspect of <code>unitizer</code>
is documented for package users (see Details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'unitizerItems,unitizer'
healEnvs(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="healEnvs_+3A_x">x</code></td>
<td>
<p><code>unitizerItems</code> object</p>
</td></tr>
<tr><td><code id="healEnvs_+3A_y">y</code></td>
<td>
<p><code>unitizer</code> object <code>x</code> was generated from</p>
</td></tr>
<tr><td><code id="healEnvs_+3A_...">...</code></td>
<td>
<p>unused, here for inheriting methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Environment healing is necessary because when we let the user pick and chose
which tests to store and which ones to reject, there may no longer be a clear
ancestry chain within the remaining tests.
</p>
<p>The healing process is somewhat complex and full of compromises.  We
are attempting to create a self consistent set of nested parent environments
for each test, but at the same time, we don't want to store all the
combinations of reference and new objects.
</p>
<p>We only store new objects in <code>unitizer</code>, with the lone exception of
objects associated to a test environment.  These will include any assignments
that occur just prior to a test, as well as any objects created by the
actual test.
</p>
<p>There are two ways in which we modify the environment ancestry. If
the user decides to not store some new tests, then the objects created
in between the previous new stored test and the next new stored test are
all moved to the next new stored test, and the previous new stored test
becomes the parent of the next new stored test.
</p>
<p>The second way relates to when the user decides to keep a reference
test over a matching new test.  This is a lot more complicated because
we do not preserve the reference test environment ancestry.  Effectively,
we need to graft the reference test to the new environment ancestry.
</p>
<p>If a reference test that is being kept matches directly to a new test,
then the parent of that new test becomes the parent of the reference
test.
</p>
<p>If there is no direct match, but there are child reference tests that
match to a new item, then the parent is the youngest new test that
is older than the new test that was matched and is kept.  If no new
tests meet this criterion, then base.env is the parent.
</p>
<p>If there is no direct match, and there are no child reference tests
that are being kept that do match to a kept new item, then the parent
will be the last new test that is kept.
</p>
<p>The main takeaway from all this is that reference tests don't really
keep their evaluation environment.  Often this environment is similar
to the new environment.  When there are difference between the two,
the output of <code>ls</code> is customized to highlight
which objects were actually available/unmodified at the time of the
reference test evaluation.  Object names will have the following
symbols appended to explain the object status:
</p>

<ul>
<li><p> ': object exists in browsing environment, but not the same as
it was when test was evalaluated
</p>
</li>
<li><p> *: object was present during test evaluation but is not
available in unitizer anymore
</p>
</li>
<li><p> **: object was not present during test evaluation, but exists
in current environment
</p>
</li></ul>



<h3>Value</h3>

<p><code>unitizerItems</code>
</p>


<h3>Note</h3>

<p>Could be more robust by ensuring that items in <code>x</code> actually do
come from <code>y</code>. This is particularly important since when
we re-assemble the final list, we don't actually use x at all.  Signature
for this should probably ultimately change to be something like
<code>c("unitizer", "x")</code> where x is just a data frame with column 1
the item index, and column 2 whether it originated from &quot;new&quot; or &quot;ref&quot;
</p>


<h3>See Also</h3>

<p><code>updateLs,unitizerItem-method</code>
</p>

<hr>
<h2 id='infer_unitizer_location'>Infers Possible Unitizer Path From Context</h2><span id='topic+infer_unitizer_location'></span><span id='topic+infer_unitizer_location.default'></span><span id='topic+infer_unitizer_location.character'></span>

<h3>Description</h3>

<p>Used by most <code>unitizer</code> functions that operate on <code>unitizer</code>s to
make it easy in interactive use to specify the most likely intended
<code>unitizer</code> in a package or a directory.  For 'R CMD check' and similar
testing should not rely on this functionality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infer_unitizer_location(store.id, ...)

## Default S3 method:
infer_unitizer_location(store.id, ...)

## S3 method for class 'character'
infer_unitizer_location(
  store.id,
  type = "f",
  interactive.mode = interactive(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infer_unitizer_location_+3A_store.id">store.id</code></td>
<td>
<p>character(1L) file or directory name, the file name portion
(i.e after the last slash) may be partially specified</p>
</td></tr>
<tr><td><code id="infer_unitizer_location_+3A_...">...</code></td>
<td>
<p>arguments to pass on to other methods</p>
</td></tr>
<tr><td><code id="infer_unitizer_location_+3A_type">type</code></td>
<td>
<p>character(1L) in <code>c("f", "u", "d")</code>, <code>"f"</code> for test
file, <code>"d"</code> for a directory, <code>"u"</code> for a <code>unitizer</code>
directory</p>
</td></tr>
<tr><td><code id="infer_unitizer_location_+3A_interactive.mode">interactive.mode</code></td>
<td>
<p>logical(1L) whether to allow user input to resolve
ambiguities</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is implemented as an S3 generic to allow third parties to define
inference methods for other types of <code>store.id</code>, but the documentation
here is for the <code>"character"</code> method which is what <code>unitizer</code> uses
by default.
</p>
<p>If <code>store.id</code> is a directory that appears to be an R package (contains
DESCRIPTION, an R folder, a tests folder), will look for candidate files in
<code>file.path(store.id, "tests", "unitizer")</code>, starting with files with the
same name as the package (ending in &quot;.R&quot; or &quot;.unitizer&quot; if <code>type</code> is
<code>"f"</code> or <code>"u"</code> respectively), or if there is only one file, that
file, or if there are multiple candidate files and in interactive mode
prompting user for a selection.  If <code>type</code> is <code>"d"</code>, then will
just provide the <code>"tests/unitizer"</code> directory.
</p>
<p>If <code>name</code> is not a directory, will try to find a file by that name, and
if that fails, will try to partially match a file by that name.  Partial
matching requires the front portion of the name to be fully specified and
no extension be provided (e.g. for <code>"mytests.R"</code>, <code>"myt"</code> is valid,
but <code>"tests"</code> and <code>"myt.R"</code> are both invalid).  Partially specified
files may be specified in subdirectories (e.g. <code>"tests/myt"</code>).
</p>
<p>Inference assumes your files end in <code>".R"</code> for code files and
<code>".unitizer"</code> for <code>unitizer</code> data directories.
</p>
<p>If <code>store.id</code> is NULL, the default <code>infer_unitizer_location</code> method
will attempt to find the top level package directory and then call the
character method with that directory as <code>store.id</code>.  If the parent
package directory cannot be found, then the character method is called with
the current directory as the argument.
</p>


<h3>Value</h3>

<p>character(1L) an inferred path, or <code>store.id</code> with a warning if
path cannot be inferred
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_unitizer">get_unitizer</a></code> for discussion of alternate
<code>store.id</code> objects
</p>

<hr>
<h2 id='invalidateLs'>Clears ls Info and Marks as Invalid</h2><span id='topic+invalidateLs'></span>

<h3>Description</h3>

<p>Useful when tests envs are repaired, or if we're looking at an ignored
test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invalidateLs(x, ...)
</code></pre>

<hr>
<h2 id='length+2CunitizerChanges-method'>Return Sum of Total Changes</h2><span id='topic+length+2CunitizerChanges-method'></span>

<h3>Description</h3>

<p>Return Sum of Total Changes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'unitizerChanges'
length(x)
</code></pre>

<hr>
<h2 id='length+2CunitizerSection-method'>Compute Length of a <code>unitizerSection-class</code></h2><span id='topic+length+2CunitizerSection-method'></span>

<h3>Description</h3>

<p>Compute Length of a <code>unitizerSection-class</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'unitizerSection'
length(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="length+2B2CunitizerSection-method_+3A_x">x</code></td>
<td>
<p>a <code>unitizerSection</code> object</p>
</td></tr>
</table>

<hr>
<h2 id='mock_item'>Generates a Dummy Item For Use in Examples</h2><span id='topic+mock_item'></span>

<h3>Description</h3>

<p>The only purpose of this function is to create a <code>unitizerItem</code> for use
by examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mock_item()
</code></pre>


<h3>Value</h3>

<p>unitizerItem object
</p>

<hr>
<h2 id='nextItem+2CunitizerList-method'>Iterate through items of a <code><a href="#topic+unitizerList">unitizerList</a></code> ObjectJK</h2><span id='topic+nextItem+2CunitizerList-method'></span><span id='topic+prevItem+2CunitizerList-method'></span><span id='topic+getItem+2CunitizerList-method'></span><span id='topic+reset+2CunitizerList-method+2C'></span><span id='topic+done+2CunitizerList-method'></span>

<h3>Description</h3>

<p>Extraction process is a combination of steps:
</p>

<ol>
<li><p> Move Internal pointer with <code>nextItem</code> or <code>prevItem</code>
</p>
</li>
<li><p> Retrieve item <code>getItem</code>
</p>
</li>
<li><p> Check whether we're done iterating with <code>done</code>
</p>
</li></ol>

<p><code>done</code> will return TRUE if the pointer is on either the
first or last entry depending on what direction you are iterating.
If you wish to iterate from the last item forward, you should either
<code>reset</code> with parameter <code>reverse</code> set to TRUE, or re-order
the items.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'unitizerList'
nextItem(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nextItem+2B2CunitizerList-method_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+unitizerList">unitizerList</a></code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+unitizerList">unitizerList</a></code> for <code>getItem</code>,
an item from the list, which could be anything
</p>

<hr>
<h2 id='options_zero'>Set Options to Initial Zero State</h2><span id='topic+options_zero'></span><span id='topic+options_update'></span><span id='topic+validate_options'></span>

<h3>Description</h3>

<p>This makes sure to unset options not present in target.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>options_zero(
  base = merge_lists(getOption("unitizer.opts.init.base"),
    getOption("unitizer.opts.init")),
  as.is = union(getOption("unitizer.opts.asis.base"), getOption("unitizer.opts.asis"))
)

options_update(tar.opts)

validate_options(opts.to.validate, test.files = NULL)
</code></pre>

<hr>
<h2 id='print.bullet'>Print Methods for <code>UL</code> and <code>OL</code> objects</h2><span id='topic+print.bullet'></span>

<h3>Description</h3>

<p>Print Methods for <code>UL</code> and <code>OL</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bullet'
print(x, width = 0L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.bullet_+3A_x">x</code></td>
<td>
<p>object to print</p>
</td></tr>
<tr><td><code id="print.bullet_+3A_width">width</code></td>
<td>
<p>integer how many characters to wrap at, if set to 0 will auto
detect width with <code>getOptions("width")</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisibly a character vector with one element per line printed
</p>

<hr>
<h2 id='repair_environments'>Repair Environment Chains</h2><span id='topic+repair_environments'></span>

<h3>Description</h3>

<p>In theory should never be needed, but use in case you get errors about
corrupted environments.  You should only use this if you get an error
telling you to use it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repair_environments(x, interactive.mode = interactive())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repair_environments_+3A_x">x</code></td>
<td>
<p>either a unitizer, or a store id (see <code><a href="#topic+unitize">unitize</a></code>)</p>
</td></tr>
<tr><td><code id="repair_environments_+3A_interactive.mode">interactive.mode</code></td>
<td>
<p>logical(1L) whether to run in interactive mode (
request user input when needed) or not (error if user input is required,
e.g. if all tests do not pass).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you pass a store id this will re-save the repaired <code>unitizer</code> to
the location specified by the store id.
</p>


<h3>Value</h3>

<p>a <code>unitizer</code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unitize">unitize</a></code>
</p>

<hr>
<h2 id='run_ls'>Worker function to actually execute the 'ls' work</h2><span id='topic+run_ls'></span>

<h3>Description</h3>

<p>Worker function to actually execute the 'ls' work
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_ls(env, stop.env, all.names, pattern, store.env = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_ls_+3A_env">env</code></td>
<td>
<p>the environment to start <code>`ls`</code>ing in</p>
</td></tr>
<tr><td><code id="run_ls_+3A_stop.env">stop.env</code></td>
<td>
<p>the environment to stop at</p>
</td></tr>
<tr><td><code id="run_ls_+3A_all.names">all.names</code></td>
<td>
<p>same as <code>`ls`</code></p>
</td></tr>
<tr><td><code id="run_ls_+3A_pattern">pattern</code></td>
<td>
<p>same as <code>`ls`</code></p>
</td></tr>
<tr><td><code id="run_ls_+3A_store.env">store.env</code></td>
<td>
<p>NULL or environment, if the latter will populate that
environment with all the objects found between <code>`env`</code> and
<code>`stop.env`</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>character or environment depending on <code>`store.env`</code>
</p>

<hr>
<h2 id='set_unitizer'>Set and Retrieve Store Contents</h2><span id='topic+set_unitizer'></span><span id='topic+get_unitizer'></span><span id='topic+get_unitizer.character'></span><span id='topic+get_unitizer.default'></span><span id='topic+get_unitizer.unitizer_result'></span><span id='topic+get_unitizer.unitizer_results'></span>

<h3>Description</h3>

<p>These functions are not used directly; rather, they are used by
<code><a href="#topic+unitize">unitize</a></code> to get and set the <code>unitizer</code> objects.
You should only need to understand these functions if you are
looking to implement a special storage mechanism for the <code>unitizer</code>
objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_unitizer(store.id, unitizer)

get_unitizer(store.id)

## S3 method for class 'character'
get_unitizer(store.id)

## Default S3 method:
get_unitizer(store.id)

## S3 method for class 'unitizer_result'
get_unitizer(store.id)

## S3 method for class 'unitizer_results'
get_unitizer(store.id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_unitizer_+3A_store.id">store.id</code></td>
<td>
<p>a filesystem path to the store (an .rds file)</p>
</td></tr>
<tr><td><code id="set_unitizer_+3A_unitizer">unitizer</code></td>
<td>
<p>a <code>unitizer-class</code> object containing the store
data</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, only a character method is defined, which will interpret
its inputs as a filesystem path to the <code>unitizer</code> folder.  RDSes of
serialization type 2 will be stored and retrieved from there.  The
serialization format may change in the future, but if R maintains
facilities to read/write type 2, we will provide the option to use
that format.  At this time there is no API to change the serialization
format.
</p>
<p>You may write your own methods for special storage situations (
e.g SQL database, ftp server, etc) with the understanding that the
getting method may only accept one argument, the <code>store.id</code>, and
the setting method only two arguments, the <code>store.id</code> and the
<code>unitizer</code>.
</p>
<p>S3 dispatch will be on <code>store.id</code>, and <code>store.id</code> may
be any R object that identifies the unitizer.  For example, a potential
SQL implementation where the unitizers get stored in blobs may look
like so:
</p>
<pre>
my.sql.store.id &lt;- structure(
  list(
    server="myunitizerserver.mydomain.com:3306",
    database="unitizers",
    table="project1",
    id="cornercasetests"
  ),
  class="sql_unitizer"
)
get_unitizer.sql_unitizer &lt;- function(store.id) { # FUNCTION BODY }
set_unitizer.sql_unitizer &lt;- function(store.id, unitizer) { # FUNCTION BODY }

unitize("unitizer/cornertestcases.R", my.sql.store.id)
</pre>
<p>Make sure you also define an <code>as.character</code> method for your object to
produce a human readable identifying string.
</p>
<p>For inspirations for the bodies of the _store functions look at the source
code for <code>unitizer:::get_unitizer.character</code> and
<code>unitizer:::set_unitizer.character</code>.
Expectations for the functions are as follows.  <code>get_unitizer</code> must:
</p>

<ul>
<li><p> return a <code>unitizer-class</code> object if <code>store.id</code>
exists and contains a valid object
</p>
</li>
<li><p> return FALSE if the object doesn't exist (e.g. first time
run-through, so reference copy doesn't exist yet)
</p>
</li>
<li> <p><code><a href="base.html#topic+stop">stop</a></code> on error
</p>
</li></ul>

<p><code>set_unitizer</code> must:
</p>

<ul>
<li><p> return TRUE on success
</p>
</li>
<li> <p><code><a href="base.html#topic+stop">stop</a></code> on error
</p>
</li></ul>



<h3>Value</h3>


<ul>
<li><p> set_unitizer TRUE if unitizer storing worked, error otherwise
</p>
</li>
<li><p> get_unitizer a <code>unitizer-class</code> object, FALSE
if <code>store.id</code> doesn't exist yet, or error otherwise; note that
the <code>unitizer_results</code> method returns a list
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="base.html#topic+saveRDS">saveRDS</a></code>
</p>

<hr>
<h2 id='show+2CunitizerChanges-method'>Print Out A Summary Of the Changes</h2><span id='topic+show+2CunitizerChanges-method'></span>

<h3>Description</h3>

<p>Print Out A Summary Of the Changes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'unitizerChanges'
show(object)
</code></pre>

<hr>
<h2 id='show+2CunitizerDummy-method'>Documentation Block for Internal S4 Methods</h2><span id='topic+show+2CunitizerDummy-method'></span><span id='topic+as.integer+2CunitizerGlobalIndices-method'></span><span id='topic+unitizer_s4method_doc'></span><span id='topic+length+2CunitizerList-method'></span><span id='topic++5B+2CunitizerList+2CsubIndex+2Cmissing+2Cmissing-method'></span><span id='topic++5B+5B+2CunitizerList+2CsubIndex-method'></span><span id='topic++5B+3C-+2CunitizerList+2CsubIndex-method'></span><span id='topic++5B+5B+3C-+2CunitizerList+2CsubIndex-method'></span><span id='topic+as.list+2CunitizerList-method'></span><span id='topic+append+2CunitizerList+2CANY-method'></span><span id='topic+c+2CunitizerList-method'></span><span id='topic+append+2Cfactor+2Cfactor-method'></span><span id='topic+names+2CunitizerList-method'></span><span id='topic+names+3C-+2CunitizerList-method'></span><span id='topic+initialize+2CunitizerItem-method'></span><span id='topic+show+2CunitizerItem-method'></span><span id='topic++2B+2CunitizerItems+2CunitizerItemOrNULL-method'></span><span id='topic++2B+2CunitizerItems+2CunitizerItems-method'></span><span id='topic++2B+2CunitizerTests+2CunitizerSectionExpressionOrExpression-method'></span><span id='topic+show+2CunitizerSummary-method'></span><span id='topic+initialize+2Cunitizer-method'></span><span id='topic+length+2Cunitizer-method'></span><span id='topic+summary+2Cunitizer-method'></span><span id='topic+summary+2CunitizerObjectList-method'></span><span id='topic+show+2CunitizerObjectListSummary-method'></span><span id='topic+as.character+2Cunitizer-method'></span><span id='topic+show+2CunitizerBrowse-method'></span><span id='topic+as.character+2CunitizerBrowse-method'></span><span id='topic+as.data.frame+2CunitizerBrowse-method'></span><span id='topic++2B+2CunitizerBrowse+2CunitizerBrowseSection-method'></span><span id='topic+length+2CunitizerBrowseSubSection-method'></span><span id='topic++5B+2CunitizerBrowse+2CsubIndex+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2CunitizerBrowseSubSection+2CsubIndex+2Cmissing+2Cmissing-method'></span><span id='topic++2B+2CunitizerBrowseSection+2CunitizerBrowseSubSection-method'></span><span id='topic+show+2CunitizerLoadFail-method'></span><span id='topic+as.character+2CunitizerInPkg-method'></span><span id='topic+show+2CunitizerInPkg-method'></span><span id='topic+show+2CunitizerState-method'></span><span id='topic+all.equal+2CunitizerDummy+2CunitizerDummy-method'></span><span id='topic+all.equal+2CunitizerDummy+2CANY-method'></span><span id='topic+all.equal+2CANY+2CunitizerDummy-method'></span><span id='topic+all.equal+2CunitizerStateRaw+2CunitizerStateRaw-method'></span><span id='topic++2B+2Cunitizer+2CunitizerSection-method'></span><span id='topic++2B+2Cunitizer+2CunitizerTestsOrExpression-method'></span><span id='topic++2B+2Cunitizer+2CunitizerItems-method'></span><span id='topic++2B+2Cunitizer+2CunitizerItem-method'></span><span id='topic++2B+2Cunitizer+2CunitizerItemTestsErrors-method'></span>

<h3>Description</h3>

<p>R insists these need to be documented as user facing, but they are not really
so were throwing them all in here.  Actual docs are in non roxygen comments
by fun definitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'unitizerDummy'
show(object)

## S4 method for signature 'unitizerGlobalIndices'
as.integer(x, ...)

## S4 method for signature 'unitizerList'
length(x)

## S4 method for signature 'unitizerList,subIndex,missing,missing'
x[i]

## S4 method for signature 'unitizerList,subIndex'
x[[i]]

## S4 replacement method for signature 'unitizerList,subIndex'
x[i] &lt;- value

## S4 replacement method for signature 'unitizerList,subIndex'
x[[i]] &lt;- value

## S4 method for signature 'unitizerList'
as.list(x, ...)

## S4 method for signature 'unitizerList,ANY'
append(x, values, after = length(x))

## S4 method for signature 'unitizerList'
c(x, ..., recursive = FALSE)

## S4 method for signature 'factor,factor'
append(x, values, after = length(x))

## S4 method for signature 'unitizerList'
names(x)

## S4 replacement method for signature 'unitizerList'
names(x) &lt;- value

## S4 method for signature 'unitizerItem'
initialize(.Object, ...)

## S4 method for signature 'unitizerItem'
show(object)

## S4 method for signature 'unitizerItems,unitizerItemOrNULL'
e1 + e2

## S4 method for signature 'unitizerItems,unitizerItems'
e1 + e2

## S4 method for signature 
## 'unitizerTests,unitizerSectionExpressionOrExpression'
e1 + e2

## S4 method for signature 'unitizerSummary'
show(object)

## S4 method for signature 'unitizer'
initialize(.Object, ...)

## S4 method for signature 'unitizer'
length(x)

## S4 method for signature 'unitizer'
summary(object, silent = FALSE, ...)

## S4 method for signature 'unitizerObjectList'
summary(object, silent = FALSE, ...)

## S4 method for signature 'unitizerObjectListSummary'
show(object)

## S4 method for signature 'unitizer'
as.character(x, ...)

## S4 method for signature 'unitizerBrowse'
show(object)

## S4 method for signature 'unitizerBrowse'
as.character(x, width = 0L, ...)

## S4 method for signature 'unitizerBrowse'
as.data.frame(x, row.names = NULL, optional = FALSE, ...)

## S4 method for signature 'unitizerBrowse,unitizerBrowseSection'
e1 + e2

## S4 method for signature 'unitizerBrowseSubSection'
length(x)

## S4 method for signature 'unitizerBrowse,subIndex,missing,missing'
x[i]

## S4 method for signature 'unitizerBrowseSubSection,subIndex,missing,missing'
x[i]

## S4 method for signature 'unitizerBrowseSection,unitizerBrowseSubSection'
e1 + e2

## S4 method for signature 'unitizerLoadFail'
show(object)

## S4 method for signature 'unitizerInPkg'
as.character(x, ...)

## S4 method for signature 'unitizerInPkg'
show(object)

## S4 method for signature 'unitizerState'
show(object)

## S4 method for signature 'unitizerDummy,unitizerDummy'
all.equal(target, current, ...)

## S4 method for signature 'unitizerDummy,ANY'
all.equal(target, current, ...)

## S4 method for signature 'ANY,unitizerDummy'
all.equal(target, current, ...)

## S4 method for signature 'unitizerStateRaw,unitizerStateRaw'
all.equal(target, current, ...)

## S4 method for signature 'unitizer,unitizerSection'
e1 + e2

## S4 method for signature 'unitizer,unitizerTestsOrExpression'
e1 + e2

## S4 method for signature 'unitizer,unitizerItems'
e1 + e2

## S4 method for signature 'unitizer,unitizerItem'
e1 + e2

## S4 method for signature 'unitizer,unitizerItemTestsErrors'
e1 + e2
</code></pre>


<h3>Details</h3>

<p>Put in this file because this file is included by almost every other file
</p>

<hr>
<h2 id='show+2CunitizerItemTestsErrorsDiff-method'>Show Method for unitizerItemTestsErrorsDiff objects</h2><span id='topic+show+2CunitizerItemTestsErrorsDiff-method'></span>

<h3>Description</h3>

<p>Show Method for unitizerItemTestsErrorsDiff objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'unitizerItemTestsErrorsDiff'
show(object)
</code></pre>

<hr>
<h2 id='show+2CunitizerItemTestsErrorsDiffs-method'>Show Method for unitizerItemTestsErrorsDiffs objects</h2><span id='topic+show+2CunitizerItemTestsErrorsDiffs-method'></span>

<h3>Description</h3>

<p>Show Method for unitizerItemTestsErrorsDiffs objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'unitizerItemTestsErrorsDiffs'
show(object)
</code></pre>

<hr>
<h2 id='show.conditionList'>Prints A list of Conditions</h2><span id='topic+show.conditionList'></span><span id='topic+show+2CconditionList-method'></span>

<h3>Description</h3>

<p>S4 method for <code><a href="#topic+conditionList">conditionList</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'conditionList'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show.conditionList_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+conditionList">conditionList</a></code> object (list of conditions)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object, invisibly
</p>


<h3>See Also</h3>

<p><code><a href="#topic+conditionList">conditionList</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create a test item as you would find normally at the `unitizer` prompt
## for illustrative purposes:
.NEW &lt;- mock_item()
## Show the conditions the test generated (typing `show` here is optional
## since auto-printing should dispatch to `show`)
show(.NEW$conditions)
</code></pre>

<hr>
<h2 id='sizeRDS'>Measure object size as an RDS</h2><span id='topic+sizeRDS'></span>

<h3>Description</h3>

<p>Measure object size as an RDS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sizeRDS(object)
</code></pre>

<hr>
<h2 id='sizeUntz'>Utility To Examine Object Size</h2><span id='topic+sizeUntz'></span>

<h3>Description</h3>

<p>Funny name is just to avoid conflicts with functions with same names in
other packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sizeUntz(x, ...)
</code></pre>

<hr>
<h2 id='testFuns'>Store Functions for New vs. Reference Test Comparisons</h2><span id='topic+testFuns'></span>

<h3>Description</h3>

<p><code>testFuns</code> contains the functions used to compare the results and side
effects of running test expressions.  &ldquo;testFuns&rdquo; objects can be used
as the <code>compare</code> argument for <code><a href="#topic+unitizer_sect">unitizer_sect</a></code>, thereby
allowing you to specify different comparison functions for different aspects
of test evaluation.
</p>


<h3>Details</h3>

<p>The default comparison functions are as follows:
</p>

<ul>
<li><p> value: <code><a href="#topic+all_eq">all_eq</a></code>
</p>
</li>
<li><p> conditions: <code><a href="#topic+all_eq">all_eq</a></code>
</p>
</li>
<li><p> output: <code>function(x, y) TRUE</code>, i.e. not compared
</p>
</li>
<li><p> message: <code>function(x, y) TRUE</code>, i.e. not compared as conditions
should be capturing warnings/errors
</p>
</li>
<li><p> aborted: <code>function(x, y) TRUE</code>, i.e. not compared as conditions
should also be capturing this implicitly
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+unitizer_sect">unitizer_sect</a></code> for more relevant usage examples,
<code><a href="#topic+all_eq">all_eq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># use `identical` instead of `all.equal` to compare values
testFuns(value=identical)
</code></pre>

<hr>
<h2 id='testthat_transcribe_file'>Transcribes a <code>testtaht</code> File Into <code>unitizer</code> Format</h2><span id='topic+testthat_transcribe_file'></span>

<h3>Description</h3>

<p>Internal use only, required so we can ensure the parse succeeded because of
possible parse-deparse issues independent of running <code>unitize</code>, since
<code>unitize</code> cannot be run inside a <code>tryCatch</code> block.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testthat_transcribe_file(
  file.name,
  target.dir = file.path(dirname(file.name), "..", "unitizer"),
  keep.testthat.call = TRUE,
  prompt = "always",
  interactive.mode,
  use.sects = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testthat_transcribe_file_+3A_file.name">file.name</code></td>
<td>
<p>a path to the <code>testthat</code> test file to convert</p>
</td></tr>
<tr><td><code id="testthat_transcribe_file_+3A_target.dir">target.dir</code></td>
<td>
<p>the directory to create the <code>unitizer</code> test file and
test store in; for <code>testthat_translate_file</code> only: if NULL will return
as a character vector what the contents of the translated file would have
been instead of writing the file</p>
</td></tr>
<tr><td><code id="testthat_transcribe_file_+3A_keep.testthat.call">keep.testthat.call</code></td>
<td>
<p>whether to preserve the <code>testthat</code> call that
was converted, as a comment</p>
</td></tr>
<tr><td><code id="testthat_transcribe_file_+3A_prompt">prompt</code></td>
<td>
<p>character(1L): </p>

<ul>
<li><p> &quot;always&quot; to always prompt before writing new files
</p>
</li>
<li><p> &quot;overwrite&quot; only prompt if existing file is about to be overwritten
</p>
</li>
<li><p> &quot;never&quot; never prompt
</p>
</li></ul>
</td></tr>
<tr><td><code id="testthat_transcribe_file_+3A_interactive.mode">interactive.mode</code></td>
<td>
<p>logical(1L) primarily for testing purposes, allows
us to force prompting in non-interactive mode; note that <code>unitize</code>
and <code>unitize_dir</code> are always called in non-interactive mode by these
functions, this parameter only controls prompts generated directly by these
functions.</p>
</td></tr>
<tr><td><code id="testthat_transcribe_file_+3A_use.sects">use.sects</code></td>
<td>
<p>TRUE (default) or FALSE whether to translate
<code>test_that</code> sections to <code>unitizer_sect</code> or simply to turn them
into comment banners.</p>
</td></tr>
<tr><td><code id="testthat_transcribe_file_+3A_...">...</code></td>
<td>
<p>params to pass on to <code>testthat_translate_name</code></p>
</td></tr>
</table>

<hr>
<h2 id='testthat_translate_file'>Convert a <code>testthat</code> Test File to a <code>unitizer</code></h2><span id='topic+testthat_translate_file'></span><span id='topic+testthat_translate_name'></span><span id='topic+testthat_translate_dir'></span>

<h3>Description</h3>

<p>Converts a <b>copy</b> of an existing <code>testthat</code> test file to a
<code>unitizer</code> test file and test store, or a directory of such files to
a corresponding <code>unitizer</code> directory.  See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testthat_translate_file(
  file.name,
  target.dir = file.path(dirname(file.name), "..", "unitizer"),
  state = getOption("unitizer.state"),
  keep.testthat.call = TRUE,
  prompt = "always",
  interactive.mode = interactive(),
  use.sects = TRUE,
  unitize = TRUE,
  ...
)

testthat_translate_dir(
  dir.name,
  target.dir = file.path(dir.name, "..", "unitizer"),
  filter = "^test.*\\.[rR]",
  state = getOption("unitizer.state"),
  keep.testthat.call = TRUE,
  force = FALSE,
  interactive.mode = interactive(),
  use.sects = TRUE,
  unitize = TRUE,
  ...
)

testthat_translate_name(
  file.name,
  target.dir = file.path(dirname(file.name), "..", "unitizer"),
  name.new = NULL,
  name.pattern = "^(?:test\\W*)?(.*)(?:\\.[rR])$",
  name.replace = "\\1"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testthat_translate_file_+3A_file.name">file.name</code></td>
<td>
<p>a path to the <code>testthat</code> test file to convert</p>
</td></tr>
<tr><td><code id="testthat_translate_file_+3A_target.dir">target.dir</code></td>
<td>
<p>the directory to create the <code>unitizer</code> test file and
test store in; for <code>testthat_translate_file</code> only: if NULL will return
as a character vector what the contents of the translated file would have
been instead of writing the file</p>
</td></tr>
<tr><td><code id="testthat_translate_file_+3A_state">state</code></td>
<td>
<p>what state control to use (see same argument for
<code><a href="#topic+unitize">unitize</a></code>)</p>
</td></tr>
<tr><td><code id="testthat_translate_file_+3A_keep.testthat.call">keep.testthat.call</code></td>
<td>
<p>whether to preserve the <code>testthat</code> call that
was converted, as a comment</p>
</td></tr>
<tr><td><code id="testthat_translate_file_+3A_prompt">prompt</code></td>
<td>
<p>character(1L): </p>

<ul>
<li><p> &quot;always&quot; to always prompt before writing new files
</p>
</li>
<li><p> &quot;overwrite&quot; only prompt if existing file is about to be overwritten
</p>
</li>
<li><p> &quot;never&quot; never prompt
</p>
</li></ul>
</td></tr>
<tr><td><code id="testthat_translate_file_+3A_interactive.mode">interactive.mode</code></td>
<td>
<p>logical(1L) primarily for testing purposes, allows
us to force prompting in non-interactive mode; note that <code>unitize</code>
and <code>unitize_dir</code> are always called in non-interactive mode by these
functions, this parameter only controls prompts generated directly by these
functions.</p>
</td></tr>
<tr><td><code id="testthat_translate_file_+3A_use.sects">use.sects</code></td>
<td>
<p>TRUE (default) or FALSE whether to translate
<code>test_that</code> sections to <code>unitizer_sect</code> or simply to turn them
into comment banners.</p>
</td></tr>
<tr><td><code id="testthat_translate_file_+3A_unitize">unitize</code></td>
<td>
<p>TRUE (default) or FALSE whether to run <code>unitize</code> after
the files are translated.</p>
</td></tr>
<tr><td><code id="testthat_translate_file_+3A_...">...</code></td>
<td>
<p>params to pass on to <code>testthat_translate_name</code></p>
</td></tr>
<tr><td><code id="testthat_translate_file_+3A_dir.name">dir.name</code></td>
<td>
<p>a path to the <code>testthat</code> directory to convert</p>
</td></tr>
<tr><td><code id="testthat_translate_file_+3A_filter">filter</code></td>
<td>
<p>regular expression to select what files in a director are
translated</p>
</td></tr>
<tr><td><code id="testthat_translate_file_+3A_force">force</code></td>
<td>
<p>logical(1L) whether to allow writing to a <code>target.dir</code> that
contains files (implies <code>prompt="never"</code> when
<code>testthat_translate_dir</code> runs <code>testthat_translate_file</code>)</p>
</td></tr>
<tr><td><code id="testthat_translate_file_+3A_name.new">name.new</code></td>
<td>
<p>character(1L) the base name for the <code>unitizer</code> files;
do not include an extension as we will add it (&quot;.R&quot; for the testfile,
&quot;.unitizer&quot; for the data directory); set to NULL to generate the name
from the <code>testthat</code> file name</p>
</td></tr>
<tr><td><code id="testthat_translate_file_+3A_name.pattern">name.pattern</code></td>
<td>
<p>character(1L) a regular expression intended to match
the <code>testthat</code> test file name (see <code>name.replace</code>) if
<code>name.pattern</code> matches, then the new file name will be
constructed with this (used as <code>replace</code> parameter to
<code><a href="base.html#topic+sub">sub</a></code>); in addition we will add &quot;.R&quot; and &quot;.unitizer&quot; as the
extensions for the new files so do not include extensions in your
<code>name.replace</code> parameter</p>
</td></tr>
<tr><td><code id="testthat_translate_file_+3A_name.replace">name.replace</code></td>
<td>
<p>character(1L) the replacement token, typically would
include a <code>"\1"</code> token that is filled in by the match group from
<code>name.pattern</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a file path or a character vector (see <code>target.dir</code>)
</p>


<h3>Disclaimers</h3>

<p>If you already have an extensive test suite in <code>testthat</code> and you do not
intend to modify your tests or code very much there is little benefit (and
likely some drawbacks) to migrating your tests to <code>unitizer</code>.  Please
see the introduction vignette for a (biased) view of the pros and cons of
<code>unitizer</code> relative to <code>testthat</code>.
</p>
<p>These translation functions are provided for your convenience.  The
<code>unitizer</code> author does not use them very much since he seldom needs to
migrate <code>testthat</code> tests.  As a result, they have not been tested as
thoroughly as the rest of <code>unitizer</code>.  Translation is designed to work
for the most common <code>testthat</code> use cases, but may not for yours.  Make
sure you <code><a href="#topic+review">review</a></code> the resulting <code>unitizer</code>s to make sure
they contain what you expect before you start relying on them.  This is
particularly important if your <code>testthat</code> test files are not meant to
be run stand-alone with just <code>test_file</code> (see &quot;Differences That May
Cause Problems&quot;).
</p>
<p>Note you can also <code>unitize</code> your <code>testthat</code> files <b>without</b>
translating them (see notes).
</p>


<h3>Workflow</h3>


<ol>
<li><p> Start a fresh R session
</p>
</li>
<li><p> Run your <code>testthat</code> tests with <code>test_dir</code> to
ensure they are still passing.  If your tests are are runnable only
via <code>test_check</code> because they directly access the namespace of your
package, see &quot;Differences That May Cause Problems&quot; below
</p>
</li>
<li><p> Run <code>testthat_dir_translate</code>
</p>
</li>
<li><p> [optional] use <code><a href="#topic+review">review</a></code> to review the resulting
unitizer(s)
</p>
</li></ol>

<p>We recommend using <code>testthat_translate_dir</code> over
<code>testthat_translate_file</code> because the former also copies and loads any
helper files that may be defined.  Since libraries used by multiple test
files are commonly loaded in these helper files, it is likely that just
translating a single file without also copying the helper files will not
work properly.
</p>


<h3>How the Conversion Works</h3>

<p>For a subset of the <code>expect_*</code> functions we extract the <code>object</code>
parameter and discard the rest of the expectation.  For example
</p>
<pre>expect_equal(my_fun(25), 1:10)</pre><p> becomes
</p>
<pre>my_fun(25)</pre><p>.  The idea is that on unitizing the expression the
result will be output to screen and can be reviewed and accepted.
Not all <code>expect_*</code> functions are substituted.  For example,
<code>expect_is</code> and <code>expect_that</code> are left unchanged because the tests
for those functions do not or might not actually test the values of
<code>object</code>.  <code>expect_gt</code> and similar are also left unchanged as that
would require more work than simply extracting the <code>object</code> parameter.
</p>
<p>It is perfectly fine to <code>unitize</code> an <code>expect_*</code> call unsubstituted.
<code>unitizer</code> captures conditions, values, etc., so if an <code>expect_*</code>
test starts failing, it will be detected.
</p>
<p><code>unitizer</code> will then evaluate and store the results of such expressions.
Since in theory we just checked our <code>testthat</code> tests were working,
presumably the re-evaluated expressions will produce the same values.  Please
note that the translation process does not actually check this is true (see
&quot;Differences That May Cause Problems&quot;) so <code>review</code>ing the results is a
good idea.
</p>
<p><code>test_that</code> calls are converted to <code><a href="#topic+unitizer_sect">unitizer_sect</a></code> calls,
and the contents thereof are processed as described above.  Calls to
<code>context</code> are commented out since there currently is no <code>unitizer</code>
equivalent.  Other <code>testthat</code> calls are left unchanged and their return
values used as part of the <code>unitizer</code> tests.
</p>
<p>Only top level calls are converted.  For example, code like
<code>for(i in 1:10) expect_equal(my_fun(i), seq(i))</code> or even
<code>(expect_equal(my_fun(10), 1:10))</code> will not be converted since
<code>expect_equal</code> is nested inside a <code>for</code> and <code>(</code> respectively.
You will need to manually edit these calls (or just let them remain as is,
which is not an issue).
</p>
<p>We identify calls to extract based purely on the function symbols (i.e. we
do not check whether <code>expect_equal</code> actually resolves to
<code>testthat::expect_equal</code> in the context of the test file).
</p>
<p>The <code>unitizer</code> files will be created in a sibling folder to the folder
containing the <code>testthat</code> files.  The names of the new files will be
based on the old files.  See params <code>target.dir</code>, <code>name.new</code>,
<code>name.pattern</code>, and <code>name.replace</code> for more details.  We encourage
you to try the default settings first as those should work well in most
cases.
</p>
<p>When using <code>testthat_translate_dir</code>, any files that match
<code>"^helper.*[rR]$"</code> are copied over to a '/_pre' subdirectory
in <code>"target.dir"</code>, and are pre-loaded by default before the tests are
<code>unitize</code>d.
</p>


<h3><code>unitizer</code> Differences That May Cause Problems</h3>

<p>If you run your tests during development with <code>test_dir</code> odds
are the translation will work just fine.  On the other hand, if you rely
exclusively on <code>test_check</code> you may need to use
<code>state=unitizerStateNoOpt(par.env="pkgName")</code> when you translate to
make sure your tests have access to the internal namespace functions.
See <code><a href="#topic+unitizerState">unitizerState</a></code> for details on how to modify state tracking.
</p>
<p>If your tests were translated with the <code>state</code> parameter changed from
its default value, you will have to use the same value for that parameter in
future <code>unitize</code> or <code>unitize_dir</code> runs.
</p>


<h3>Alternate Use Cases</h3>

<p>If you wish to process <code>testthat</code> files for use with the standard R
&ldquo;.Rout&rdquo; / &ldquo;.Rout.save process&rdquo; you can set the <code>unitize</code>
and <code>use.sects</code> parameters to FALSE.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unitize">unitize</a></code>, <code><a href="#topic+unitizerState">unitizerState</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(testthat)  # required
testthat_translate_file("tests/testthat/test-random.R")

# Translate `dplyr` tests (assumes `dplyr` source is in './dplyr')
# Normally we would use default `state` value but we cannot in this case
# due to conflicting packages and setup

testthat_translate_dir(
  "dplyr/tests/testthat", state=unitizerStateSafe(par.env="dplyr")
)
# Make sure translation worked (checking one file here)
# *NOTE*: folder we are looking at has changed

review("dplyr/tests/unitizer/summarise.unitizer")

# Now we can unitize any time we change our code

unitize_dir(
  "dplyr/tests/unitizer", state=unitizerStateSafe(par.env="dplyr")
)

## End(Not run)
</code></pre>

<hr>
<h2 id='text_wrap'>Text Wrapping Utilities</h2><span id='topic+text_wrap'></span><span id='topic+word_wrap'></span><span id='topic+meta_word_cat'></span><span id='topic+meta_word_msg'></span><span id='topic+word_cat'></span><span id='topic+word_msg'></span><span id='topic+word_comment'></span>

<h3>Description</h3>

<p>Functions to break up character vector components to a specified width.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_wrap(x, width)

word_wrap(
  x,
  width = getOption("width"),
  tolerance = 8L,
  hyphens = TRUE,
  unlist = TRUE,
  collapse = NULL
)

meta_word_cat(
  ...,
  sep = "\n",
  width = getOption("width"),
  tolerance = 8L,
  file = stdout(),
  trail.nl = TRUE
)

meta_word_msg(
  ...,
  sep = "\n",
  width = getOption("width"),
  tolerance = 8L,
  trail.nl = TRUE
)

word_cat(
  ...,
  sep = " ",
  width = getOption("width"),
  tolerance = 8L,
  file = stdout()
)

word_msg(...)

word_comment(
  x,
  width = getOption("width"),
  tolerance = 8L,
  hyphens = TRUE,
  unlist = TRUE,
  color = crayon::has_color()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_wrap_+3A_x">x</code></td>
<td>
<p>character vector</p>
</td></tr>
<tr><td><code id="text_wrap_+3A_width">width</code></td>
<td>
<p>what width to wrap at</p>
</td></tr>
<tr><td><code id="text_wrap_+3A_tolerance">tolerance</code></td>
<td>
<p>how much earlier than <code>width</code> we're allowed to wrap</p>
</td></tr>
<tr><td><code id="text_wrap_+3A_hyphens">hyphens</code></td>
<td>
<p>whether to allow hyphenation</p>
</td></tr>
<tr><td><code id="text_wrap_+3A_unlist">unlist</code></td>
<td>
<p>logical(1L) if FALSE each element in <code>x</code> is returned as
an element of a list, otherwise one character vector is returned</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>text_wrap</code> breaks each element to a specified <code>width</code>,
where <code>width</code> can contain different values for each value in
<code>x</code>
</p>
</li>
<li> <p><code>word_wrap</code> wraps at whitespace, or crudely hyphenates if
necessary; note that unlike <code>text_wrap</code> <code>width</code> must be scalar
</p>
</li>
<li> <p><code>word_cat</code> is like <code>word_wrap</code>, except it outputs to screen
</p>
</li>
<li> <p><code>word_msg</code> is like <code>word_cat</code>, except it ouputs to stderr
</p>
</li>
<li> <p><code>meta_word_cat</code> is like <code>word_cat</code>, except it wraps output
in formatting to highlight this is not normal output
</p>
</li></ul>

<p>Newlines are replaced by empty strings in the output so that each character
vector in the output represents a line of screen output.
</p>


<h3>Value</h3>

<p>a list with, for each item in <code>x</code>, a character vector
of the item wrapped to length <code>width</code>
</p>
<p>if <code>unlist</code> is a parameter, then a character vector, or
if not or if <code>unlist</code> is FALSE, a list with each element from <code>x</code>
corresponding to an element from the list
</p>

<hr>
<h2 id='unitize'>Unitize an R Test Script</h2><span id='topic+unitize'></span><span id='topic+review'></span><span id='topic+unitize_dir'></span>

<h3>Description</h3>

<p>Turn standard R scripts into unit tests by storing the expressions therein
along with the results of their evaluation, and provides an interactive
prompt to review tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unitize(
  test.file = NULL,
  store.id = NULL,
  state = getOption("unitizer.state"),
  pre = NULL,
  post = NULL,
  history = getOption("unitizer.history.file"),
  interactive.mode = interactive(),
  force.update = FALSE,
  auto.accept = character(0L),
  use.diff = getOption("unitizer.use.diff"),
  show.progress = getOption("unitizer.show.progress", TRUE),
  transcript = getOption("unitizer.transcript", !interactive.mode)
)

review(
  store.id = NULL,
  use.diff = getOption("unitizer.use.diff"),
  show.progress = getOption("unitizer.show.progress", TRUE)
)

unitize_dir(
  test.dir = NULL,
  store.ids = filename_to_storeid,
  pattern = "^[^.].*\\.[Rr]$",
  state = getOption("unitizer.state"),
  pre = NULL,
  post = NULL,
  history = getOption("unitizer.history.file"),
  interactive.mode = interactive(),
  force.update = FALSE,
  auto.accept = character(0L),
  use.diff = getOption("unitizer.use.diff"),
  show.progress = getOption("unitizer.show.progress", TRUE),
  transcript = getOption("unitizer.transcript", !interactive.mode)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unitize_+3A_test.file">test.file</code></td>
<td>
<p>path to the file containing tests, if supplied path does not
match an actual system path, <code>unitizer</code> will try to infer a possible
path.  If NULL, will look for a file in the &ldquo;tests/unitizer&rdquo; package
folder if it exists, or in &ldquo;.&rdquo; if it does not.
See <code><a href="#topic+infer_unitizer_location">infer_unitizer_location</a></code>) for details.</p>
</td></tr>
<tr><td><code id="unitize_+3A_store.id">store.id</code></td>
<td>
<p>if NULL (default), <code>unitizer</code> will select a directory
based on the <code>test.file</code> name by replacing <code>.[rR]</code> with
<code>.unitizer</code>.  You can also specify a directory name, or pass any
object that has a defined <code><a href="#topic+get_unitizer">get_unitizer</a></code> method which allows
you to specify non-standard <code>unitizer</code> storage mechanisms (see
<code><a href="#topic+get_unitizer">get_unitizer</a></code>).  Finally, you can pass an actual
<code>unitizer</code> object if you are using <code>review</code>; see <code>store.ids</code>
for <code>unitize_dir</code></p>
</td></tr>
<tr><td><code id="unitize_+3A_state">state</code></td>
<td>
<p>character(1L) one of
<code>c("prisitine", "suggested", "basic", "off", "safe")</code>, an
environment, or a state object produced by <code><a href="#topic+state">state</a></code> or
<code><a href="#topic+in_pkg">in_pkg</a></code>; modifies how <code>unitizer</code> manages aspects of
session state that could affect test evaluation, including the parent
evaluation environment.  For more details see <code><a href="#topic+unitizerState">unitizerState</a></code>
documentation and <code>vignette("unitizer_reproducible_tests")</code></p>
</td></tr>
<tr><td><code id="unitize_+3A_pre">pre</code></td>
<td>
<p>NULL, or a character vector pointing to files and/or directories.
If a character vector, then any files referenced therein will be sourced,
and any directories referenced therein will be scanned non-recursively for
visible files ending in &quot;.r&quot; or &quot;.R&quot;, which are then also sourced.  If
NULL, then <code>unitizer</code> will look for a directory named &quot;_pre&quot; in the
directory containing the first test file and will treat it as if you had
specified it in <code>pre</code>.  Any objects created by those scripts will be
put into a parent environment for all tests.  This provides a mechanism for
creating objects that are shared across different test files, as well as
loading shared packages.  Unlike objects created during test evaluation,
any objects created here will not be stored in the <code>unitizer</code> so you
will have not direct way to check whether these objects changed across
<code>unitizer</code> runs.  Additionally, typing <code>ls</code> from the review
prompt will not list these objects.</p>
</td></tr>
<tr><td><code id="unitize_+3A_post">post</code></td>
<td>
<p>NULL, or a character vector pointing to files and/or directories.
See <code>pre</code>.  If NULL will look for a directory named &quot;_post&quot; in the
directory containing the first test file.  Scripts are run just prior to
exiting <code>unitizer</code>. <code>post</code> code will be run in an environment
with the environment used to run <code>pre</code> as the parent.  This means that
any objects created in <code>pre</code> will be available to <code>post</code>, which
you can use to your advantage if there are some things you do in <code>pre</code>
you wish to undo in <code>post</code>. Keep in mind that <code>unitizer</code> can
manage most aspects of global state, so you should not need to use this
parameter to unload packages, remove objects, etc.  See details.</p>
</td></tr>
<tr><td><code id="unitize_+3A_history">history</code></td>
<td>
<p>character(1L) path to file to use to store history generated
during interactive unitizer session; the default is an empty string, which
leads to <code>unitizer</code> using a temporary file, set to NULL to disable
history capture.</p>
</td></tr>
<tr><td><code id="unitize_+3A_interactive.mode">interactive.mode</code></td>
<td>
<p>logical(1L) whether to run in interactive mode (
request user input when needed) or not (error if user input is required,
e.g. if all tests do not pass).</p>
</td></tr>
<tr><td><code id="unitize_+3A_force.update">force.update</code></td>
<td>
<p>logical(1L) if TRUE will give the option to re-store a
unitizer after re-evaluating all the tests even if all tests passed.
You can also toggle this option from the unitizer prompt by typing <code>O</code>
(capital letter &quot;o&quot;), though <code>force.update=TRUE</code> will force update
irrespective of whether you type <code>O</code> at the prompt</p>
</td></tr>
<tr><td><code id="unitize_+3A_auto.accept">auto.accept</code></td>
<td>
<p>character(X) ADVANCED USE ONLY: YOU CAN EASILY DESTROY
YOUR <code>unitizer</code> WITH THIS; whether to auto-accept tests without
prompting, use values in <code>c("new", "failed", "deleted", "error")</code> to
specify which type(s) of test you wish to auto accept (i.e. same as typing
<code>"Y"</code> at the <code>unitizer</code> prompt) or empty character vector to turn
off (default)</p>
</td></tr>
<tr><td><code id="unitize_+3A_use.diff">use.diff</code></td>
<td>
<p>TRUE or FALSE, whether to use diffs when there is an error,
if FALSE uses <code><a href="base.html#topic+all.equal">all.equal</a></code> instead.</p>
</td></tr>
<tr><td><code id="unitize_+3A_show.progress">show.progress</code></td>
<td>
<p>TRUE or FALSE or integer(1L) in 0:3, whether to show
progress updates for each part of the process (TRUE or &gt; 0), for each file
processed (TRUE or &gt; 1), and for each test processed (TRUE or &gt; 2).</p>
</td></tr>
<tr><td><code id="unitize_+3A_transcript">transcript</code></td>
<td>
<p>TRUE (default in non-interactive mode) or FALSE (default in
interactive mode) causes immediate output of stdout/stderr during test
evaluation instead of deferred display during test review.  This also
causes progress updates to display on new lines instead of overlaying on
the same line.  One limitation of running in this mode is that stderr is no
longer captured at all so is unavailable in the review stage.  stderr
text that is also part of a signalled condition (e.g. &quot;boom&quot; in
'stop(&quot;boom&quot;)') is still shown with the conditions in the review step.  To
see direct stderr output in transcript mode scroll up to the test
evaluation point.</p>
</td></tr>
<tr><td><code id="unitize_+3A_test.dir">test.dir</code></td>
<td>
<p>the directory to run the tests on; if NULL will use the
&ldquo;tests/unitizer&rdquo; package folder if it exists, or &ldquo;.&rdquo; if it
does not.  See <code><a href="#topic+infer_unitizer_location">infer_unitizer_location</a></code>) for details.</p>
</td></tr>
<tr><td><code id="unitize_+3A_store.ids">store.ids</code></td>
<td>
<p>one of </p>

<ul>
<li><p> a function that converts test file names to <code>unitizer</code> ids; if
<code>unitize</code>ing multiple files will be <code>lapply</code>ed over each file
</p>
</li>
<li><p> a character vector with <code>unitizer</code> ids, must be the same
length as the number of test files being reviewed (see <code>store.id</code>)
</p>
</li>
<li><p> a list of unitizer ids, must be the same length as the number of
test files being reviewed; useful when you implement special storage
mechanisms for the <code>unitizers</code> (see <code><a href="#topic+get_unitizer">get_unitizer</a></code>)
</p>
</li></ul>
</td></tr>
<tr><td><code id="unitize_+3A_pattern">pattern</code></td>
<td>
<p>a regular expression used to match what subset of files in
<code>test.dir</code> to <code>unitize</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>unitize</code> creates unit tests from a single R file, and
<code>unitize_dir</code> creates tests from all the R files in the specified
directory (analogous to <code>testthat::test_dir</code>).
</p>
<p><code>unitizer</code> stores are identified by <code>unitizer</code> ids, which by
default are character strings containing the location of the folder the
<code>unitizer</code> RDS files are kept in.  <code>unitize</code> and
friends will create a <code>unitizer</code> id for you based on the test file
name and location, but you can specify your own location as an id, or even
use a completely different mechanism to store the <code>unitizer</code> data by
implementing S3 methods for <code><a href="#topic+get_unitizer">get_unitizer</a></code> and
<code><a href="#topic+set_unitizer">set_unitizer</a></code>.  For more details about storage see those
functions.
</p>
<p><code>review</code> allows you to review existing <code>unitizer</code>s and modify them
by dropping tests from them.  Tests are not evaluated in this mode; you are
just allowed to review the results of previous evaluations of the tests
Because of this, no effort is made to create reproducible state in the
browsing environments, unlike with <code>unitize</code> or <code>unitize_dir</code>
(see <code>state</code> parameter).
</p>
<p>You are strongly encouraged to read through the vignettes
for details and examples (<code>browseVignettes("unitizer")</code>).  The demo
(<code>demo("unitizer")</code>) is also a good introduction to these functions.
</p>


<h3>Value</h3>

<p><code>unitize</code> and company are intended to be used primarily for
the interactive environment and side effects.  The functions do return
summary data about test outcomes and user input as
<code>unitizer_result</code> objects, or for <code>unitize_dir</code> as
<code>unitizer_results</code> objects, invisibly.  See
<code><a href="#topic+unitizer_result">unitizer_result</a></code>.
</p>


<h3>Note</h3>

<p><code>unitizer</code> approximates the semantics of sourcing an R file when running
tests, and those of the interactive prompt when reviewing them.  The
semantics are not identical, and in some cases you may notice differences.
For example, when running tests:
</p>

<ul>
<li><p> All expressions are run with <code>options(warn=1)</code>,
irrespective of what the user sets that option to.
</p>
</li>
<li> <p><code>on.exit(...)</code> expressions will be evaluated immediately for
top-level statements (either in the test file or in an
<code><a href="#topic+unitizer_sect">unitizer_sect</a></code>, thereby defeating their purpose).
</p>
</li>
<li><p> Each test expression is run in its own environment, which is enclosed
by that of previous tests.
</p>
</li>
<li><p> Output and Message streams are sunk so any attempt to debug directly
will be near-impossible as you won't see anything.
</p>
</li>
<li><p> For portable tests it is best to use ASCII only string literals
(avoiding even escaped bytes or Unicode characters), round numbers, etc.,
because <code>unitizer</code> uses deparsed test expressions as indices
to retrieve reference values.  See <code>vignette('u1_intro',
    package='unitizer')</code> for details and work-arounds.
</p>
</li></ul>

<p>When reviewing them:
</p>

<ul>
<li> <p><code>ls()</code> and <code>q()</code> are over-ridden by <code>unitizer</code> utility
functions.
</p>
</li>
<li><p> Expressions are evaluated with <code>options(warn=1)</code> or greater,
although unlike in test running it is possible to set and keep
<code>options(warn=2)</code>.
</p>
</li>
<li><p> Some single upper case letters will be interpreted as <code>unitizer</code>
meta-commands.
</p>
</li></ul>

<p>For a more complete discussion of these differences see the introductory
vignette (<code>vignette('u1_intro')</code>), the &quot;Special Semantics&quot; section of
the tests vignette (<code>vignette('u2_tests')</code>), and the &quot;Evaluating
Expressions at the <code>unitizer</code> Prompt&quot; section of the interactive
environment vignette (<code>vignette('u3_interactive-env')</code>).
</p>


<h3>Default Settings</h3>

<p>Many of the default settings are specified in the form <code>getOption("...")</code>
to allow the user to &quot;permanently&quot; set them to their preferred modes by
setting options in their <code>.Rprofile</code> file.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unitizerState">unitizerState</a></code>, <code><a href="#topic+unitizer.opts">unitizer.opts</a></code>,
<code><a href="#topic+get_unitizer">get_unitizer</a></code>, <code><a href="#topic+infer_unitizer_location">infer_unitizer_location</a></code>,
<code><a href="#topic+unitizer_result">unitizer_result</a></code>
</p>

<hr>
<h2 id='unitizer_demo'>Demo Details and Helper Functions</h2><span id='topic+unitizer_demo'></span><span id='topic++5BPress+20ENTER+20to+20Continue+5D'></span><span id='topic+show_file'></span><span id='topic+copy_fastlm_to_tmpdir'></span><span id='topic+update_fastlm'></span><span id='topic+unitizer_check_demo_state'></span><span id='topic+unitizer_cleanup_demo'></span>

<h3>Description</h3>

<p><code>unitizer</code> provides an interactive demo you can run with
<code>demo("unitizer")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>`[Press ENTER to Continue]`()

show_file(f, width = getOption("width", 80L))

copy_fastlm_to_tmpdir()

update_fastlm(dir, version)

unitizer_check_demo_state()

unitizer_cleanup_demo()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unitizer_demo_+3A_f">f</code></td>
<td>
<p>path to a file</p>
</td></tr>
<tr><td><code id="unitizer_demo_+3A_width">width</code></td>
<td>
<p>display width in characters</p>
</td></tr>
<tr><td><code id="unitizer_demo_+3A_dir">dir</code></td>
<td>
<p>path to the temporary package</p>
</td></tr>
<tr><td><code id="unitizer_demo_+3A_version">version</code></td>
<td>
<p>one of &quot;0.1.0&quot;, &quot;0.1.1&quot;, &quot;0.1.2&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character(1L)
</p>


<h3>Demo Details</h3>

<p>The demo centers around simulated development of the <code>utzflm</code>
package.  <code>unitizer</code> includes in its sources three copies of the source
code for the <code>utzflm</code> package, each at a different stage of
development.  This allows us to create reference <code>unitizer</code> tests under
one version, move to a new version and check for regressions, and finally
fix the regressions with the last version.  The version switching is
intended to represent the package development process.
</p>
<p>The demo manages the <code>utzflm</code> code changes, but between each
update allows the user to interact with <code>unitizer</code>.  The demo operates
under the assumption that the user will accept the first set of tests and
reject the failing tests after the first update.  If the user does anything
different then the demo commentary may not apply anymore.
</p>


<h3><code>utzflm</code></h3>

<p><code>utzflm</code> is a &quot;dummy&quot; package that implements a faster
computation of slope, intercept, and R^2 for single variable linear
regressions than is available via <code>summary(lm()...)</code>.
</p>


<h3>Helper Functions</h3>

<p><code>copy_fastlm_to_tmpdir</code> copies the initial version of the
<code>utzflm</code> sources to a temporary directory, <code>show_file</code>
displays the contents of a source code file, <code>update_fastlm</code> changes the
source code of <code>utzflm</code>, and <code>unitizer_check_demo_state</code>
and <code>unitizer_cleanup_demo</code> perform janitorial functions.  None of
these functions are intended for use outside of the unitizer demo.
</p>

<hr>
<h2 id='unitizer_ls'>An 'ls' Like Function</h2><span id='topic+unitizer_ls'></span>

<h3>Description</h3>

<p>Much like 'ls', except that it is designed to crawl up the <code>`.new`</code> and
<code>`.ref`</code> environments and display all the objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unitizer_ls(
  name,
  pos = -1L,
  envir = parent.frame(),
  all.names = FALSE,
  pattern
)
</code></pre>


<h3>Details</h3>

<p>This is used in <code>`browseUnitizer,unitizer-unitizerBrowse-method`</code>,
and is re-assigned to <code>`ls`</code> for use in the <code>`unitizer`</code> prompt
environment.
</p>


<h3>Value</h3>

<p>list of object names, or a list with environments containing the
objects
</p>

<hr>
<h2 id='unitizer_prompt'>Interactively Retrieve User Input</h2><span id='topic+unitizer_prompt'></span><span id='topic+navigate_prompt'></span><span id='topic+review_prompt'></span><span id='topic+simple_prompt'></span><span id='topic+exit_fun'></span><span id='topic+read_line'></span><span id='topic+read_line_set_vals'></span>

<h3>Description</h3>

<p>Different functions used in different contexts to capture user input.
<code>unitizer_prompt</code>, <code>navigate_prompt</code>, and <code>review_prompt</code> are
more advanced and allow evaluation of arbitrary expressions, in addition to
searching for specific commands such as &quot;Y&quot;, &quot;N&quot;, etc. <code>simple_prompt</code>
only matches along specified values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unitizer_prompt(
  text,
  browse.env = baseenv(),
  help = character(),
  help.opts = character(),
  valid.opts,
  hist.con = NULL,
  exit.condition = function(exp, env) FALSE,
  global,
  warn.sticky = FALSE,
  ...
)

navigate_prompt(
  x,
  curr.id,
  text,
  browse.env1 = globalenv(),
  browse.env2 = globalenv(),
  help = character(),
  help.opts = character(),
  valid.opts,
  warn.sticky = FALSE
)

review_prompt(x, nav.env)

simple_prompt(
  message,
  values = c("Y", "N"),
  prompt = "unitizer&gt; ",
  attempts = 5L,
  case.sensitive = FALSE
)

exit_fun(y, env, valid.vals)

read_line(prompt = "")

read_line_set_vals(vals)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unitizer_prompt_+3A_text">text</code></td>
<td>
<p>the prompt text to display</p>
</td></tr>
<tr><td><code id="unitizer_prompt_+3A_browse.env">browse.env</code></td>
<td>
<p>the environment to evaluate user expressions in; typically
this will contain interesting objects (use <code>ls()</code> to review)</p>
</td></tr>
<tr><td><code id="unitizer_prompt_+3A_help">help</code></td>
<td>
<p>a character vector with help suggestions: the first value in the
vector is <code><a href="#topic+word_cat">word_cat</a></code> output, the rest normal <code>cat</code></p>
</td></tr>
<tr><td><code id="unitizer_prompt_+3A_help.opts">help.opts</code></td>
<td>
<p>a character vector of help options</p>
</td></tr>
<tr><td><code id="unitizer_prompt_+3A_valid.opts">valid.opts</code></td>
<td>
<p>the special letters user can type to get a special action,
typically a character vector where the names are one letter (though they
don't actually have to be) and are looked for as user typed input; note that
the quit and help options will always be appended to this</p>
</td></tr>
<tr><td><code id="unitizer_prompt_+3A_hist.con">hist.con</code></td>
<td>
<p>connection to save history to</p>
</td></tr>
<tr><td><code id="unitizer_prompt_+3A_exit.condition">exit.condition</code></td>
<td>
<p>function used to evaluate whether user input should
cause the prompt loop to exit; this function should accept two parameters:
</p>

<ul>
<li><p> expression typed in by the user
</p>
</li>
<li><p> environment the environment user expressions get evaluated in
</p>
</li></ul>

<p>The function can then decide to exit or not based on either the literal
expression or evaluate the expression and decide based on the result.  This
is implemented this way because <code>eval_user_exp</code> will print to screen
which may not be desirable.  Function should return a value which will then
be returned by <code>unitizer_prompt</code>, unless this value is <code>FALSE</code>
in which case <code>unitizer_prompt</code> will continue with normal evaluation.</p>
</td></tr>
<tr><td><code id="unitizer_prompt_+3A_global">global</code></td>
<td>
<p>unitizerGlobal or NULL, if the global state tracking object;
will be used to record state after evaluating user expressions</p>
</td></tr>
<tr><td><code id="unitizer_prompt_+3A_warn.sticky">warn.sticky</code></td>
<td>
<p>TRUE or FALSE (default) whether any changes to the &quot;warn&quot;
global option made by the evaluation of an R expression under the prompt
should be allowed to stick after the evaluation.  Normally that option value
is reset after each evaluation.</p>
</td></tr>
<tr><td><code id="unitizer_prompt_+3A_...">...</code></td>
<td>
<p>additional arguments for <code>exit.condition</code></p>
</td></tr>
<tr><td><code id="unitizer_prompt_+3A_x">x</code></td>
<td>
<p>a unitizerBrowse object</p>
</td></tr>
<tr><td><code id="unitizer_prompt_+3A_curr.id">curr.id</code></td>
<td>
<p>which id we are currently browsing</p>
</td></tr>
<tr><td><code id="unitizer_prompt_+3A_browse.env1">browse.env1</code></td>
<td>
<p>environment to have user review tests, run commands, etc</p>
</td></tr>
<tr><td><code id="unitizer_prompt_+3A_browse.env2">browse.env2</code></td>
<td>
<p>navigation environment</p>
</td></tr>
<tr><td><code id="unitizer_prompt_+3A_nav.env">nav.env</code></td>
<td>
<p>an environment</p>
</td></tr>
<tr><td><code id="unitizer_prompt_+3A_message">message</code></td>
<td>
<p>character ask the user a question</p>
</td></tr>
<tr><td><code id="unitizer_prompt_+3A_values">values</code></td>
<td>
<p>character valid responses</p>
</td></tr>
<tr><td><code id="unitizer_prompt_+3A_prompt">prompt</code></td>
<td>
<p>see <code><a href="base.html#topic+readline">readline</a></code></p>
</td></tr>
<tr><td><code id="unitizer_prompt_+3A_attempts">attempts</code></td>
<td>
<p>how many times to try before erroring</p>
</td></tr>
<tr><td><code id="unitizer_prompt_+3A_case.sensitive">case.sensitive</code></td>
<td>
<p>whether to care about case sensitivity when matching
user input</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The set-up is intended to replicate something similar to what happens when
code hits a <code>browse()</code> statement.  User expressions are evaluated
and output to screen, and special expressions as described above cause the
evaluation loop to terminate.
</p>
<p><code>navigate_prompt</code> is just a wrapper around <code>unitizer_prompt</code> that
provides the special shortcuts to navigate to other tests in the
<code>unitizer</code>.
</p>
<p><code>review_prompt</code> is also a wrapper, but used only when at the menu that
presents available test items to navigate to.
</p>
<p><code>simple_prompt</code> simpler prompting function used to allow user to select
from pre-specified values.
</p>
<p><code>exit_fun</code> is used as a generic function to pass to the
<code>exit.condition</code> argument of <code>unitizer_prompt</code>.
</p>
<p><code>read_line</code> and <code>read_line_set_vals</code> are utility functions that
are used to implement a version of <code><a href="base.html#topic+readline">readline</a></code> that can be
automated for testing.
</p>


<h3>Value</h3>


<ul>
<li> <p><code>unitizer_prompt</code>: mixed allowable user input
</p>
</li>
<li> <p><code>navigate_prompt</code>: a <code>unitizerBrowse</code> object, or allowable
user input
</p>
</li>
<li> <p><code>review_prompt</code>: a <code>unitizerBrowse</code> object, or &quot;Q&quot; if the
user chose to quit
</p>
</li>
<li> <p><code>simple_prompt</code>: one of <code>values</code> as selected by user
</p>
</li></ul>



<h3>See Also</h3>

<p>browse_unitizer_items
</p>

<hr>
<h2 id='unitizer_result'>Return Values and Related Methods for <code>unitize</code> Functions</h2><span id='topic+unitizer_result'></span><span id='topic+unitizer_results'></span><span id='topic+print.unitizer_result'></span><span id='topic+print.unitizer_results'></span>

<h3>Description</h3>

<p><code>unitize</code> and related functions are run primarily for the interactive
environment they provide and for their side effects (updating stored
<code>unitizer</code> objects), but the return values may be useful under some
circumstances if you need to retrieve test status, user selections, etc..
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'unitizer_result'
print(x, ...)

## S3 method for class 'unitizer_results'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unitizer_result_+3A_x">x</code></td>
<td>
<p>the object to print</p>
</td></tr>
<tr><td><code id="unitizer_result_+3A_...">...</code></td>
<td>
<p>extra arguments for print generic</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>unitize</code> and <code>review</code> return a <code>unitizer_result</code> S3 object.
This is a data frame that contains details about the status of each test.
<code>unitize_dir</code> returns a <code>unitize_results</code> S3 object, which is a
list of <code>unitize_result</code>  objects.
</p>
<p>Both <code>unitize_results</code> and <code>unitize_result</code> have <code>print</code>
methods documented here. In addition to the <code>print</code> methods, both of
the result objects have <code><a href="#topic+get_unitizer">get_unitizer</a></code> methods so that you can
retrieve the stored <code>unitizer</code> objects.
</p>
<p>Please note that with <code>unitize_dir</code> you can re-review a single
<code>unitizer</code> several times during during a single call to
<code>unitize_dir</code>.  This is to allow you to re-evaluate specific
<code>unitizers</code> easily without having to re-run the entire directory again.
Unfortunately, as a result of this feature, the return values of
<code>unitize_dir</code> can be misleading because they only report the result of
the last review cycle.
</p>
<p>Additionally, <code>unitize_dir</code> will report user selections during the last
review even if in the end the user chose not to save the modified
<code>unitizer</code>.  You will be alerted to this by an onscreen message from the
<code>print</code> method (this is tracked in the &quot;updated&quot; attribute of the
<code>unitizer_result</code> object).  Finally, if in the last iteration before
exit you did not save the <code>unitizer</code>, but you did save it in  previous
review cycles in the same <code>unitize_dir</code> call, the displayed selections
and test outcomes will correspond to the last unsaved iteration, not the
one that was saved.  You will be alerted to this by an on-screen message
(this is tracked through the &quot;updated.at.least.once&quot; attribute of the
<code>unitizer_result</code> object).
</p>


<h3>Value</h3>

<p><code>x</code>, invisibly
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unitize">unitize</a></code>, <code><a href="#topic+get_unitizer">get_unitizer</a></code>
</p>

<hr>
<h2 id='unitizer_sect'>Define a <code>unitizer</code> Section</h2><span id='topic+unitizer_sect'></span>

<h3>Description</h3>

<p>The purpose of <code>unitizer</code> sections is to allow the user to tag a
group of test expressions with meta information as well as to modify
how tests are determined to pass or fail.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unitizer_sect(
  title = NULL,
  expr = expression(),
  details = character(),
  compare = new("testFuns")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unitizer_sect_+3A_title">title</code></td>
<td>
<p>character 1 length title for the section, can be omitted
though if you do omit it you will have to refer to the subsequent
arguments by name (i.e. <code>unitizer_sect(expr=...)</code>)</p>
</td></tr>
<tr><td><code id="unitizer_sect_+3A_expr">expr</code></td>
<td>
<p>test expression(s), most commonly a call to <code>{}</code> with
several calls inside (see examples)</p>
</td></tr>
<tr><td><code id="unitizer_sect_+3A_details">details</code></td>
<td>
<p>character more detailed description of what the purpose
of the section is; currently this doesn't do anything.</p>
</td></tr>
<tr><td><code id="unitizer_sect_+3A_compare">compare</code></td>
<td>
<p>a function or a <code><a href="#topic+testFuns">testFuns</a></code> object</p>
</td></tr>
</table>


<h3>Tested Data</h3>

<p><code>unitizer</code> tracks the following:
</p>

<ul>
<li><p> value: the return value of the test
</p>
</li>
<li><p> conditions: any conditions emitted by the test (e.g. warnings or
errors)
</p>
</li>
<li><p> output: screen output
</p>
</li>
<li><p> message: stderr output
</p>
</li>
<li><p> aborted: whether the test issued an 'abort' restart (e.g. by calling
'stop' directly or indirectly)
</p>
</li></ul>

<p>In the future stdout produced by the test expression itself may be captured
separately from that produced by print/showing of the return value, but at
this point the two are combined.
</p>
<p>Each of the components of the test data can be tested, although by default
only <code>value</code> and <code>condition</code> are checked.  Testing <code>output</code> is
potentially duplicative of testing <code>value</code>, since most often
<code>value</code> is printed to screen and the screen output of the value closely
correlates to the actual value.  In some cases it is useful to explicitly
test the <code>output</code>, such as when testing <code>print</code> or <code>show</code>
methods.
</p>


<h3>Comparison Functions</h3>

<p>The comparison function should accept at least two parameters, and
require no more than two.  For each test component, the comparison function
will be passed the reference data as the first argument, and the newly
evaluated data as the second.  The function should return TRUE if the
compared test components are considered equivalent, or FALSE.  Instead of
FALSE, the function may also return a character vector describing the
mismatch, as <code><a href="base.html#topic+all.equal">all.equal</a></code> does.
</p>
<p><b>WARNING</b>: Comparison functions that set and/or unset <code><a href="base.html#topic+sink">sink</a></code>
can potentially cause problems.  If for whatever reason you must really  sink
and unsink output streams, please take extreme care to restore the streams to
the state they were in when the comparison function was called.
</p>
<p>Any output to <code>stdout</code> or <code>stderr</code> is captured and only checked at
the end of the <code>unitizer</code> process with the expectation that there will
be no such output.
</p>
<p><code>value</code> and <code>conditions</code> are compared with <code><a href="#topic+all_eq">all_eq</a></code>,
which is a wrapper to <code><a href="base.html#topic+all.equal">all.equal</a></code> except that it returns FALSE
instead of a descriptive string on failure.  This is because <code>unitizer</code>
will run <code><a href="diffobj.html#topic+diffObj">diffObj</a></code> on the test data components that do
not match and including the <code>all.equal</code> output would be redundant.
</p>
<p>If a comparison function signals a condition (e.g. throws a warning) the
test will not be evaluated, so make sure that your function does not signal
conditions unless it is genuinely failing.
</p>
<p>If you wish to provide custom comparison functions you may do so by passing
an appropriately initialized <code><a href="#topic+testFuns">testFuns</a></code> object as the
value to the <code>compare</code> parameter to <code>unitizer_sect</code>
(see examples).
</p>
<p>Make sure your comparison functions are available to <code><a href="#topic+unitize">unitize</a></code>.
Comparisons will be evaluated in the environment of the test.  By default
<code><a href="#topic+unitize">unitize</a></code> runs tests in environments that are not children to
the global environment, so functions defined there will not be automatically
available.  You can either specify the function in the test file before the
section that uses it, or change the base environment tests are evaluated in
with <code>unitize(..., par.env)</code>, or make sure that the package that
contains your function is loaded within the test script.
</p>


<h3>Nested Sections</h3>

<p>It is possible to have nested sections, but titles, etc. are ignored.  The
only effect of nested sections is to allow you to change the comparison
functions for a portion of the outermost <code>unitizer_sect</code>.
</p>


<h3>Note</h3>

<p>if you want to modify the functions used to compare conditions,
keep in mind that the conditions are stored in <code><a href="#topic+conditionList">conditionList</a></code>
objects so your function must loop through the lists and compare conditions
pairwise.  By default <code>unitizer</code> uses the <code>all.equal</code> method for S4
class <code>conditionList</code>.
</p>
<p><code>untizer</code> does not account for sections when matching new and
reference tests.  All tests will be displayed as per the section they belong
to in the newest version of the test file, irrespective of what section they
were in when the tests were last run.
</p>
<p>Calls to <code>unitizer_sect</code> should be at the top level of your test
script, or nested within other <code>unitizer_sect</code>s (see &quot;Nested Sections&quot;).
Do not expect code like <code>(untizer_sect(..., ...))</code> or
<code>{unitizer_sect(..., ...)}</code> or <code>fun(unitizer_sect(..., ...))</code> to
work.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+testFuns">testFuns</a></code>, <code><a href="#topic+all_eq">all_eq</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>unitizer_sect("Switch to `all.equal` instead of `all_eq`",
  {
    fun(6L)
    fun("hello")
  },
  compare=testFuns(value=all.equal, conditions=all.equal)
)
unitizer_sect("Use identical for ALL test data, including stdout, etc.",
  {
    fun(6L)
    fun("hello")
  },
  compare=identical
)
</code></pre>

<hr>
<h2 id='unitizer.opts'>Unitizer Options</h2><span id='topic+unitizer.opts'></span>

<h3>Description</h3>

<p>Description of major <code>unitizer</code> option settings.  Once <code>unitizer</code>
is loaded, you can see a full list of <code>unitizer</code> options with
<code>grep("^unitizer", options(), value=TRUE)</code>.
</p>


<h3>Basic State Options</h3>

<p>Basic state options:
</p>

<ul>
<li> <p><code>unitizer.state</code>: default state tracking setting (see
<code>unitizerState</code>)
</p>
</li>
<li> <p><code>unitizer.seed</code>: default seed to use when random seed tracking
is enabled; this is of type &quot;Wichman-Hill&quot; because it is a lot more
compact than the default R random seed, and should be adequate for most
unit testing purposes.
</p>
</li></ul>



<h3>Options State Options</h3>

<p>Additionally, when tracking option state we set options to what you would
find in a freshly loaded vanilla R session, except for systems specific
options which we leave unchanged (e.g. <code>getOption("papersize")</code>).
If you want to add default option values or options to leave unchanged, you
can use:
</p>

<ul>
<li> <p><code>unitizer.opts.init</code>: named list, where names are options, and
the associated value is the value to use as the default value for that
option when a <code>unitizer</code> is launched with options tracking enabled.
</p>
</li>
<li> <p><code>unitizer.opts.asis</code>: character, containing regular expressions
to match options to leave unchanged (e.g <code>"^unitizer\."</code>)
</p>
</li></ul>



<h3>Search Path and Namespace State Options</h3>

<p>We also provide options to limit what elements can be removed from
the search path and/or have their namespaces unloaded when <code>unitizer</code>
tracks the search path state.  For example, we use this mechanism to prevent
removal of the <code>unitizer</code> package itself as well as the default
R vanilla session packages.
</p>

<ul>
<li> <p><code>unitizer.namespace.keep</code>: character, names of namespaces to
keep loaded (e.g. <code>"utils"</code>); note that any imported namespaces
imported by namespaces listed here will also remain loaded
</p>
</li>
<li> <p><code>unitizer.search.path.keep</code>: character, names of objects to
keep on search path (e.g. <code>"package:utils"</code>, note the
<code>"package:"</code>); associated namespaces will also be kept loaded
</p>
</li></ul>

<p><b>IMPORTANT</b>: There is a dependency between options tracking and search
path / namespace exceptions that stems from most packages setting their
default options when they are loaded.  As a result, if you add any packages
or namespaces to these options and options state tracking is enabled, then
you must also add their options to <code>unitizer.opts.init</code> or
<code>unitizer.opts.asis</code> to ensure those options remain loaded or at least
set to reasonable values.  If you do not do this the packages risk having
their options unset.
</p>
<p>Some packages cannot be easily loaded and unloaded.  For example
<code>data.table</code> (&lt;= 1.9.5) cannot be unloaded without causing a segfault
(see issue <a href="https://github.com/Rdatatable/data.table/issues/990">#990</a>).
For this reason <code>data.table</code> is included in
<code>getOption("unitizer.namespace.keep")</code> by default.
</p>


<h3>Sytem Default State Options</h3>

<p>The following options hold the default system values for the search
path / namespace and options state tracking options:
</p>

<ul>
<li> <p><code>unitizer.namespace.keep.base</code>: namespaces that are known to
cause problems when unloaded (as of this writing includes
<code>data.table</code>)
</p>
</li>
<li> <p><code>unitizer.search.path.keep.base</code>: vanilla R session packages,
plus <code>"package:unitizer"</code> and <code>"tools:rstudio"</code>, the latter
because its implementation prevents re-attaching it if it is detached.
</p>
</li>
<li> <p><code>unitizer.opts.asis.base</code>: system specific options that should
not affect test evaluation (e.g. <code>getOption("editor")</code>).
</p>
</li>
<li> <p><code>unitizer.opts.init.base</code>: base options (e.g.
<code>getOption("width")</code> that will be set to what we believe are the
factory settings for them.
</p>
</li></ul>

<p>These are kept separate from the user specified ones to limit the possibility
of inadvertent modification. They are exposed as options to allow the user to
unset single values if required, though this is intended to be rare.
<code>unitizer</code> runs with the union of user options and the system versions
described here.  For <code>unitizer.opts.init</code>, any options set that are
also present in <code>unitizer.opts.init.base</code> will overrule the base
version.
</p>


<h3>Display / Text Capture Options</h3>

<p>These options control how <code>unitizer</code> displays data such as diffs, test
results, etc.
</p>

<ul>
<li> <p><code>unitizer.test.out.lines</code>: integer(2L), where first values is
maximum number of lines of screen output to show for each test, and
second value is the number of lines to show if there are more lines than
allowed by the first value
</p>
</li>
<li> <p><code>unitizer.test.msg.lines</code>: like <code>unitizer.test.out.lines</code>,
but for <code>stderr output</code>
</p>
</li>
<li> <p><code>unitizer.test.fail.context.lines</code>: integer(2L), used
exclusively when comparing new to references tests when test faile; first
values is maximum number of lines of context to show around a test,
centered on differences if there are any, and second value is the number
of context lines to show if using the first value is not sufficient to
fully display the test results
</p>
</li>
<li> <p><code>unitizer.show.output</code>: TRUE or FALSE, whether to display test
<code>stdout</code> and <code>stderr</code> output as it is evaluated.
</p>
</li>
<li> <p><code>unitizer.disable.capt</code>: logical(2L), not NA, with names
<code>c("output", "message")</code> where each value indicates whether the
corresponding stream should be captured or not.  For <code>stdout</code> the
stream is still captured but setting the value to FALSE tees it.
</p>
</li>
<li> <p><code>unitizer.max.capture.chars</code>: integer(1L) maximum number of
characters to allow capture of per test
</p>
</li>
<li> <p><code>unitizer.color</code> whether to use ANSI color escape sequences,
set to TRUE to force, FALSE to force off, or NULL to attempt to auto
detect (based on code from package:crayon, thanks Gabor Csardi)
</p>
</li>
<li> <p><code>unitizer.use.diff</code> TRUE or FALSE, whether to use a diff of
test errors (defaults to TRUE)
</p>
</li></ul>



<h3>Misc Options</h3>


<ul>
<li> <p><code>unitizer.history.file</code> character(1L) location of file to use
to store history of command entered by user in in interactive
<code>unitizer</code> prompt; <code>""</code> is interpreted as tempfile()
</p>
</li>
<li> <p><code>unitizer.prompt.b4.quit.time</code> integer(1L) <code>unitizers</code> that
take more seconds than this to evaluate will post a confirmation prompt
before quitting; this is to avoid accidentally quitting after running a
<code>unitizer</code> with many slow running tests and having to re-run them
again.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+unitizerState">unitizerState</a></code>
</p>

<hr>
<h2 id='unitizerChanges-class'>Summary of Changes</h2><span id='topic+unitizerChanges-class'></span>

<h3>Description</h3>

<p>Changes arise any time a user, through the interactive unitizer mode,
requests the storing of a change (accept new version of failed test,
add new test, remove old test).
</p>

<hr>
<h2 id='unitizerGlobalBase-class'>Structures For Tracking Global Options</h2><span id='topic+unitizerGlobalBase-class'></span><span id='topic+unitizerGlobalStatus-class'></span><span id='topic+unitizerGlobalDisabled-class'></span><span id='topic+unitizerGlobalTracking-class'></span><span id='topic+unitizerDummy-class'></span><span id='topic+unitizerGlobalTrackingStore-class'></span><span id='topic+unitizerGlobalState-class'></span><span id='topic+unitizerGlobalIndices-class'></span><span id='topic+unitizerGlobalStateFuns-class'></span><span id='topic+unitizerGlobalNsOptConflict-class'></span>

<h3>Description</h3>

<p>Immplemented as S4 classes just so we can ensure everything is guaranteed
to have the right slots.  This is done by defining a virtual class that has
a validity function that checks the required slots exist.
</p>


<h3>Details</h3>

<p>Not we don't use &quot;ANY&quot; slots here because that would allow partially
specified sub classes (i.e. classes with slots that are &quot;ANY&quot;), which we
do not want to allow.
</p>
<p><code>unitizerGlobalTrackingStore</code> is used to keep &quot;compressed&quot; versions of
<code>unitizerGlobal$tracking</code>.  The compressed versions obviously lose some
information.  In particular, environments or things that have environments
as parents, or large objects, are not stored and instead a reference to
a <code>unitizerDummy</code> object is stored.  This object unambiguously
identifies a non-stored object since no user or system code should
normally creating a <code>unitizerDummy</code> object.
</p>
<p><code>unitizerGlobalState</code> tracks a single state which is just one value from
each of the slots of <code>unitizerGlobalTrackingStore</code>
</p>
<p>When comparing state between new and reference tests, only explicitly stored
items are compared (though any extra or missing items may be brought up as
possible mismatches).
</p>

<hr>
<h2 id='unitizerList'>S4 Object To Implement Base List Methods</h2><span id='topic+unitizerList'></span>

<h3>Description</h3>

<p>Internal <code>unitizer</code> objects used to manage lists of objects.  The only
user facing instance of these objects are <code><a href="#topic+conditionList">conditionList</a></code>
objects.  For the most part these objects behave like normal S3 lists.  The
list contents are kept in the <code>.items</code> slot, and the following methods
are implemented to make the object mostly behave like a standard R list:
<code>[</code>, <code>[[</code>, <code>[&lt;-</code>, <code>[[&lt;-</code>, <code>as.list</code>, <code>append</code>,
<code>length</code>, <code>names</code>, and <code>names&lt;-</code>.
</p>


<h3>Details</h3>

<p>The underlying assumption is that the '.items' slot is a list
(or an expression), and that slot is the only slot for which
it's order and length are meaningful (i.e. there is no other list
or vector of same length as '.items' in a different slot that is
supposed to map to '.items').  This last assumption allows us
to implement the subsetting operators in a meaningful manner.
</p>
<p>The validity method will run <code>validObject</code> on the first, last, and
middle items (if an even number of items, then the middle closer to the
first) assuming they are S4 objects.  We don't run on every object to avoid
potentially expensive computation on all objects.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.items</code></dt><dd><p>a list or expression</p>
</dd>
<dt><code>.pointer</code></dt><dd><p>integer, used for implementing iterators</p>
</dd>
<dt><code>.seek.fwd</code></dt><dd><p>logical used to track what direction iterators are going</p>
</dd>
</dl>


<h3>See Also</h3>

<p><code><a href="#topic+conditionList">conditionList</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>new('unitizerList', .items=list(1, 2, 3))
</code></pre>

<hr>
<h2 id='unitizerSection-class'>Contains Representation For a Section of Tests</h2><span id='topic+unitizerSection-class'></span><span id='topic+unitizerSectionExpression-class'></span><span id='topic+unitizerSectionNA-class'></span>

<h3>Description</h3>

<p><code>unitizerSectionExpression-class</code> contains the actual expressions that
belong to the section, whereas <code>unitizerSection-class</code> only contains
the meta data.  The latter objects are used within <code>]unitizer-class</code>,
whereas the former is really just a temporary object until we can generate
the latter.
</p>


<h3>Details</h3>

<p><code>unitizerSectionNA-class</code> is a specialized section for tests that actually
don't have a section (removed tests that are nonetheless chosen to be kept
by user in interactive environment)
</p>


<h3>Slots</h3>


<dl>
<dt><code>title</code></dt><dd><p>1 lenght character, the name of the section</p>
</dd>
<dt><code>details</code></dt><dd><p>character vector containing additional info on the section</p>
</dd>
<dt><code>compare</code></dt><dd><p>functions to compare the various aspects of a
<code>unitizerItem-class</code> @slot length tracks size of the section</p>
</dd>
</dl>

<hr>
<h2 id='unitizerState'>Tests and Session State</h2><span id='topic+unitizerState'></span><span id='topic+state'></span><span id='topic+state+2C'></span><span id='topic+in_pkg'></span>

<h3>Description</h3>

<p>While R generally adheres to a &quot;functional&quot; programming style, there are
several aspects of session state that can affect the results of code
evaluation (e.g. global environment, search path).  <code>unitizer</code> provides
functionality to increase test reproducibility by controlling session state
so that it is the same every time a test is run.  This functionality is
turned off by default to comply with CRAN requirements, and also because
there are inherent limitations in R that may prevent it from fully working in
some circumstances.  You can permanently enable the suggested state tracking
level by adding <code>options(unitizer.state='suggested')</code> in your
<code>.Rprofile</code>, although if you intend to do this be sure to read the
&ldquo;CRAN non-compliance&rdquo; section.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>state(
  par.env,
  search.path,
  options,
  working.directory,
  random.seed,
  namespaces
)

in_pkg(package = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unitizerState_+3A_par.env">par.env</code></td>
<td>
<p><code>NULL</code> to use the special <code>unitizer</code> parent
environment, or an environment to use as the parent environment, or
the name of a package as a character string to use that packages'
namespace as the parent environment, or a <code>unitizerInPkg</code> object
as produced by <code><a href="#topic+in_pkg">in_pkg</a></code>, assumes .GlobalEnv if unspecified</p>
</td></tr>
<tr><td><code id="unitizerState_+3A_search.path">search.path</code></td>
<td>
<p>one of <code>0:2</code>, uses the default value corresponding to
<code>getOption(unitizer.state)</code>, which is 0 in the default unitizer state
of &ldquo;off&rdquo;.  See &quot;Custom Control&quot; section for details.</p>
</td></tr>
<tr><td><code id="unitizerState_+3A_options">options</code></td>
<td>
<p>same as <code>search.path</code></p>
</td></tr>
<tr><td><code id="unitizerState_+3A_working.directory">working.directory</code></td>
<td>
<p>same as <code>search.path</code></p>
</td></tr>
<tr><td><code id="unitizerState_+3A_random.seed">random.seed</code></td>
<td>
<p>same as <code>search.path</code></p>
</td></tr>
<tr><td><code id="unitizerState_+3A_namespaces">namespaces</code></td>
<td>
<p>same as <code>search.path</code></p>
</td></tr>
<tr><td><code id="unitizerState_+3A_package">package</code></td>
<td>
<p>character(1L) or NULL; if NULL will tell <code>unitize</code>
to attempt to identify if the test file is inside an R package folder
structure and if so run tests in that package's namespace.  This should
work with R CMD check tests as well as in normal usage.  If character will
take the value to be the name of the package to use the namespace of as
the parent environment.  Note that <code>in_pkg</code> does not retrieve the
environment, it just tells <code>unitize</code> to do so.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>for <code>state</code> a <code>unitizerStateRaw</code> object, for <code>in_pkg</code>
a <code>unitizerInPkg</code> object, both of which are suitable as values for
the <code>state</code> parameter for <code><a href="#topic+unitize">unitize</a></code> or as values for the
&ldquo;unitizer.state&rdquo; global option.
</p>


<h3>CRAN Non-Compliance and Other Caveats</h3>

<p>In the default state management mode, this package fully complies with CRAN
policies.  In order to implement advanced state management features we must
lightly trace some <code>base</code> functions to alert <code>unitizer</code> each time
the search path is changed by a test expression.  The traced function
behavior is completely unchanged other than for the side effect of notifying
<code>unitizer</code> each time they are called.  Additionally, the functions are
only traced during <code>unitize</code> evaluation and are untraced on exit.
Unfortunately this tracing is against CRAN policies, which is why it is
disabled by default.
</p>
<p>Arguably other aspects of state management employed outside of
<code>state="default"</code> _could_ be considered CRAN non-compliant, but none of
these are deployed unless you explicitly chose to do so.  Additionally,
<code>unitizer</code> limits state manipulation to the evaluation of its processes
and restores state on exit.  Some exceptional failures may prevent restoring
state fully.
</p>
<p>If state management were to fail fail in an unhandled form, the simplest
work-around is to turn off state management altogether with
<code>state="default"</code>. If it is a particular aspect of state management
(e.g. search paths with packages attached with <code>devtools::load_all</code>),
you can disable just that aspect of state (see &quot;Custom Control&quot; section).
</p>
<p>For more details see the reproducible tests vignette with:
<code>vignette(package='unitizer', 'u4_reproducible-tests')</code>
</p>


<h3>Overview</h3>

<p>You can control how <code>unitizer</code> manages state via
the state argument to <code>unitize</code> or by setting the
&ldquo;unitizer.state&rdquo; option.  This help file discusses state
management with <code>unitizer</code>, and also documents two functions that, in
conjunction with <code><a href="#topic+unitize">unitize</a></code> or <code><a href="#topic+unitize_dir">unitize_dir</a></code> allow you
to control state management.
</p>
<p><b>Note</b>: most of what is written in this page about <code>unitize</code>
applies equally to <code>unitize_dir</code>.
</p>
<p><code>unitizer</code> provides functionality to insulate test code from variability
in the following.  Note the &ldquo;can be&rdquo; wording because by default
these elements of state are not managed:
</p>

<ul>
<li><p> Workspace / Parent Environment: all tests can be
evaluated in environments that are children of a special environment
that does not inherit from <code>.GlobalEnv</code>.  This prevents objects
that are lying around in your workspace from interfering with your
tests.
</p>
</li>
<li><p> Random Seed: can be set to a specific value at the
beginning of each test file so that tests using random values get the
same value at every test iteration. This only sets the seed at the
beginning of each test file, so changes in order or number of functions
that generate random numbers in your test file will affect subsequent
tests.  The advantage of doing this over just setting the seed directly
in the test files is that <code>unitizer</code> tracks the value of the seed
and will tell you the seed changed for any given test (e.g. because you
added a test in the middle of the file that uses the random seed).
</p>
</li>
<li><p> Working Directory: can be set to the tests directory
inside the package directory if the test files appear to be inside the
folder structure of a package, and the test file does not appear to be
run as part of a check run (e.g. R CMD check,
'tools::testInstalledPakage').  If test files are not inside a package
directory structure then can be set to the test files' directory.
</p>
</li>
<li><p> Search Path: can be set to what you would
typically find in a freshly loaded vanilla R session.  This means any non
default packages that are loaded when you run your tests are unloaded
prior to running your tests.  If you want to use the same libraries
across multiple tests you can load them with the <code>pre</code> argument to
<code><a href="#topic+unitize">unitize</a></code> or <code><a href="#topic+unitize_dir">unitize_dir</a></code>.  Due to limitations
of R this is only an approximation to actually restarting R into a fresh
session.
</p>
</li>
<li><p> Options: same as search path, but see &quot;Namespaces&quot; next.
</p>
</li>
<li><p> Namespaces: same as search path; this
option is only made available to support options since many namespaces
set options <code>onLoad</code>, and as such it is necessary to unload and
re-load them to ensure default options are set.  See the &quot;Namespaces and
Options&quot; section.
</p>
</li></ul>

<p>In the &ldquo;suggested&rdquo; state tracking mode (previously known as
&ldquo;recommended&rdquo;), parent environment, random seed, working directory,
and search path are all managed to level 2, which approximates what you would
find in a fresh session (see &quot;Custom Control&quot; section below).  For example,
with the search path managed, each test file will start evaluation with the
search path set to the tests folder of your package.  All these settings are
returned to their original values when <code>unitizer</code> exits.
</p>
<p>To manage the search path <code>unitizer</code> detaches
and re-attaches packages.  This is not always the same as loading a package
into a fresh R session as detaching a package does not necessarily undo every
action that a package takes when it is loaded.  See <code><a href="base.html#topic+detach">detach</a></code> for
potential pitfalls of enabling this setting.  Additionally, packages attached
in non-standard ways (e.g. <code>devtools::load_all</code>) may not re-attach
properly.
</p>
<p>You can modify what aspects of state are managed by using the <code>state</code>
parameter to <code><a href="#topic+unitize">unitize</a></code>.  If you are satisfied with basic default
settings you can just use the presets described in the next section.  If you
want more control you can use the return values of the <code>state</code> and
<code>in_pkg</code> functions as the values for the <code>state</code> parameter for
<code>unitize</code>.
</p>
<p>State is reset after running each test file when running multiple test
files with <code>unitize_dir</code>, which means state changes in one test file
will not affect the next one.
</p>


<h3>State Presets</h3>

<p>For convenience <code>unitizer</code> provides several state management presets
that you can specify via the <code>state</code> parameter to <code><a href="#topic+unitize">unitize</a></code>.
The simplest method is to specify the preset name as a character value:
</p>

<ul>
<li><p> &quot;suggested&quot;: </p>

<ul>
<li><p> Use special (non <code>.GlobalEnv</code>) parent environemnt
</p>
</li>
<li><p> Manage search path
</p>
</li>
<li><p> Manage random seed (and set it to be of type &quot;Wichmann-Hill&quot;
for space considerations).
</p>
</li>
<li><p> Manage workign directory
</p>
</li>
<li><p> Leave namespace and options untouched
</p>
</li></ul>

</li>
<li><p> &quot;safe&quot; like suggested, but turns off tracking for search path in
addition to namespaces and options.  These settings, particularly the
last two, are the most likely to cause compatibility problems.
</p>
</li>
<li><p> &quot;pristine&quot; implements the highest level of state tracking and control
</p>
</li>
<li><p> &quot;basic&quot; keeps all tracking, but at a less aggressive level; state is
reset between each test file to the state before you started
<code>unitize</code>ing so that no single test file affects another, but the
state of your workspace, search path, etc. when you launch
<code>unitizer</code> will affect all the tests (see the Custom Control)
section.
</p>
</li>
<li><p> &quot;off&quot; (default) state tracking is turned off
</p>
</li></ul>



<h3>Custom Control</h3>

<p>If you want to customize each aspect of state control you can pass a
<code>unitizerState</code> object as the <code>state</code> argument.  The simplest way
to do this is by using the <code><a href="#topic+state">state</a></code> constructor function.  Look
at the examples for how to do this.
</p>
<p>For convenience <code>unitize</code> allows you to directly specify a parent
environment if all you want to change is the parent evaluation environment
but are otherwise satisfied with the defaults.  You can even use the
<code><a href="#topic+in_pkg">in_pkg</a></code> function to tell <code>unitizer</code> to use the namespace
associated with your current project, assuming it is an R package.  See
examples for details.
</p>
<p>If you do chose to modify specific aspects of state control here is a guide
to what the various parameter values for <code>state</code> do:
</p>

<ul>
<li><p> For <code>par.env</code>: any of the following:
</p>

<ul>
<li> <p><code>NULL</code> to use the special <code>unitizer</code> parent
environment as the parent environment; this environment has for
parent the parent of <code>.GlobalEnv</code>, so any tests evaluated
therein will not be affected by objects in <code>.GlobalEnv</code>
see (<code>vignette("unitizer_reproducible_state")</code>).
</p>
</li>
<li><p> an environment to use as the parent evaluation environment
</p>
</li>
<li><p> the name of a package to use that package's namespace
environment as the parent environment
</p>
</li>
<li><p> the return value of <code>in_pkg</code>; used primarily to autodetect
what package namespace to use based on package directory structure
</p>
</li></ul>

</li>
<li><p> For all other slots, the settings are in <code>0:2</code> and mean:
</p>

<ul>
<li><p> 0 turn off state tracking
</p>
</li>
<li><p> 1 track, but start with state as it was when <code>unitize</code> was
called.
</p>
</li>
<li><p> 2 track and set state to what you would typically find in a clean
R session, with the exception of <code>random.seed</code>, which is
set to <code>getOption("unitizer.seed")</code> (of kind &quot;Wichmann-Hill&quot;
as that seed is substantially smaller than the R default seed).
</p>
</li></ul>
 </li></ul>

<p>If you chose to use level <code>1</code> for the random seed you should consider
picking a random seed type before you start unitizer that is small like
&quot;Wichman-Hill&quot; as the seed will be recorded each time it changes.
</p>


<h3>Permanently Setting State Tracking</h3>

<p>You can permanently change the default state by setting the
&ldquo;unitizer.state&rdquo; option to the name of the state presets above or to a
or to a state settings option object generated with <code>state</code> as described
in the previous section.
</p>


<h3>Avoiding <code>.GlobalEnv</code></h3>

<p>For the most part avoiding <code>.GlobalEnv</code> leads to more robust and
reproducible tests since the tests are not influenced by objects in the
workspace that may well be changing from test to test.  There are some
potential issues when dealing with functions that expect <code>.GlobalEnv</code> to
be on the search path.  For example, <code>setClass</code> uses <code>topenv</code> to
find a default environment to assign S4 classes to.  Typically this will be
the package environment, or <code>.GlobalEnv</code>.  However, when you are in
<code>unitizer</code> this becomes the next environment on the search path, which
is typically locked, which will cause <code>setClass</code> to fail.  For those
types of functions you should specify them with an environment directly, e.g.
<code>setClass("test", slots=c(a="integer"), where=environment())</code>.
</p>


<h3>Namespaces and Options</h3>

<p>Options and namespace state management require the ability to fully unload
any non-default packages and namespaces, and there are some packages that
cannot be unloaded, or should not be unloaded (e.g.
<a href="https://github.com/Rdatatable/data.table/issues/990">data.table</a>).  I
some systems it may even be impossible to fully unload any compiled code
packages (see <code><a href="base.html#topic+detach">detach</a></code>. If you know the packages you typically
load in your sessions can be unloaded, you can turn this functionality on by
setting <code>options(unitizer.state="pristine")</code> either in your session, in
your <code>.Rprofile</code> file, or using <code>state="prisitine"</code> in each call to
<code>unitize</code> or <code>unitize_dir</code>.  If you have packages that cannot be
unloaded, but you still want to enable these features, see the &quot;Search Path
and Namespace State Options&quot; section of <code><a href="#topic+unitizer.opts">unitizer.opts</a></code> docs.
</p>
<p>If you run <code>unitizer</code> with options and namespace tracking and you run
into a namespace that cannot be unloaded, or should not be unloaded because
it is listed in <code>getOption("unitizer.namespace.keep")</code>, <code>unitizer</code>
will turn off <code>options</code> state tracking from that point onwards.
</p>
<p>Additionally, note that <code>warn</code> and <code>error</code> options are always set
to <code>1</code> and <code>NULL</code> respectively during test evaluation, irrespective
of what option state tracking level you select.
</p>


<h3>Known Untracked State Elements</h3>


<ul>
<li><p> system time: tests involving functions such as <code><a href="base.html#topic+date">date</a></code>
will inevitably fail
</p>
</li>
<li><p> locale: is not tracked because it so specific to the system and so
unlikely be be changed by user action; if you have tests that depend on
locale be sure to set the locale via the <code>pre</code> argument to
<code><a href="#topic+unitize">unitize</a></code>, and also to reset it to the original value in
<code>post</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+unitize">unitize</a></code>, <code><a href="#topic+unitizer.opts">unitizer.opts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## In this examples we use `...` to denote other arguments to `unitize` that
## you should specify.  All examples here apply equally to `unitize_dir`

## Run with suggested state tracking settings
unitize(..., state="suggested")
## Manage as much of state as possible
unitize(..., state="pristine")

## No state management, but evaluate with custom env as parent env
my.env &lt;- new.env()
unitize(..., state=my.env)
## use custom environment, and turn on search.path tracking
## here we must use the `state` function to construct a state object
unitize(..., state=state(par.env=my.env, search.path=2))

## Specify a namespace to run in by name
unitize(..., state="stats")
unitize(..., state=state(par.env="stats")) # equivalent to previous

## Let `unitizer` figure out the namespace from the test file location;
## assumes test file is inside package folder structure
unitize("mytests.R", state=in_pkg()) # assuming mytests.R is part of a pkg
unitize("mytests.R", state=in_pkg("mypkg")) # also works

## End(Not run)
</code></pre>

<hr>
<h2 id='unitizerTests-class'>Collections of Calls For Testing</h2><span id='topic+unitizerTests-class'></span>

<h3>Description</h3>

<p>Should probably add an <code>as.unitizerTests</code> function...
</p>

<hr>
<h2 id='valid_names'>Make Valid Names</h2><span id='topic+valid_names'></span>

<h3>Description</h3>

<p>If names are invalid, quotes them with backtics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>valid_names(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="valid_names_+3A_x">x</code></td>
<td>
<p>character vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector
</p>

<hr>
<h2 id='validate_pre_post'>Helper function for validations</h2><span id='topic+validate_pre_post'></span>

<h3>Description</h3>

<p>Helper function for validations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_pre_post(what, test.dir)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
