<!DOCTYPE html><html><head><title>Help for package csurvey</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {csurvey}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#block.Ord'><p>Specify a Block Monotonic Shape-Restriction in a CSVY Formula</p></a></li>
<li><a href='#csvy'>
<p>Estimation of Domain Means with Monotonicity or Convexity Constraints</p></a></li>
<li><a href='#nhdat'>
<p>A Subset of National Health and Nutrition Examination Survey (NHANES)</p></a></li>
<li><a href='#nhdat2'>
<p>A Subset of National Health and Nutrition Examination Survey (NHANES)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Constrained Regression for Survey Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.9</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-23</td>
</tr>
<tr>
<td>Author:</td>
<td>Xiyue Liao </td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Xiyue Liao &lt;xliao@sdsu.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Domain mean estimation with monotonicity or block monotone constraints. See Xu X, Meyer MC and Opsomer JD (2021)&lt;<a href="https://doi.org/10.1016%2Fj.jspi.2021.02.004">doi:10.1016/j.jspi.2021.02.004</a>&gt; for more details. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>survey (&ge; 4.2-1), cgam (&ge; 1.7), R (&ge; 4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>coneproj, purrr, stats, igraph, graphics, grDevices, MASS,
Matrix</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-23 22:56:29 UTC; xliao</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-23 23:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='block.Ord'>Specify a Block Monotonic Shape-Restriction in a CSVY Formula</h2><span id='topic+block.Ord'></span>

<h3>Description</h3>

<p>A symbolic routine to define that a vector of domain means follows a monotonic ordering in a predictor in a formula argument to csvy. This is the unsmoothed version.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  block.Ord(x, order = NULL, numknots = 0, knots = 0, space = "E")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="block.Ord_+3A_x">x</code></td>
<td>
<p>A numeric predictor which has the same length as the response vector.</p>
</td></tr>
<tr><td><code id="block.Ord_+3A_order">order</code></td>
<td>

<p>A <code class="reqn">1 \times M</code> vector defining the order of domains when the shape constraint is block ordering. 
</p>
</td></tr>
<tr><td><code id="block.Ord_+3A_numknots">numknots</code></td>
<td>
<p>The number of knots used to smoothly constrain a predictor. The value should be <code class="reqn">0</code> for a shape-restricted predictor without smoothing. The default value is <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="block.Ord_+3A_knots">knots</code></td>
<td>
<p>The knots used to smoothly constrain a predictor. The value should be <code class="reqn">0</code> for a shape-restricted predictor without smoothing. The default value is <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="block.Ord_+3A_space">space</code></td>
<td>
<p>A character specifying the method to create knots. It will not be used for a shape-restricted predictor without smoothing. The default value is &quot;E&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The vector x with five attributes, i.e., name: the name of x; shape: 9(&quot;block ordering&quot;); numknots: the numknots argument in &quot;block.Ord&quot;; knots: the knots argument in &quot;block.Ord&quot;; space: the space argument in &quot;block.Ord&quot;.</p>


<h3>Author(s)</h3>

<p>Xiyue Liao
</p>


<h3>See Also</h3>

<p><code><a href="#topic+csvy">csvy</a></code>
</p>

<hr>
<h2 id='csvy'>
Estimation of Domain Means with Monotonicity or Convexity Constraints
</h2><span id='topic+csvy'></span><span id='topic+summary.csvy'></span><span id='topic+vcov.csvy'></span><span id='topic+predict.csvy'></span><span id='topic+coef.csvy'></span><span id='topic+confint.csvy'></span><span id='topic+plotpersp.csvy'></span><span id='topic+barplot.csvy'></span>

<h3>Description</h3>

<p>The csvy function performs design-based domain mean estimation with monotonicity and block-monotone shape constraints.
</p>
<p>For example, in a one dimensional situation, we assume that <code class="reqn">\bar{y}_{U_t}</code> are non-decreasing over <code class="reqn">T</code> domains. If this monotonicity is not used in estimation,
the population domain means can be estimated by the Horvitz-Thompson estimator or the Hajek estimator. To use the monotonicity information, this csvy function starts from the
Hajek estimates <code class="reqn">\bar{y}_{S_t} = (\sum_{k\in S_t}y_k/\pi_k)/N_t</code> and the isotonic estimator <code class="reqn">(\hat{\theta}_1,\ldots,\hat{\theta}_T)^T</code> minimizes the weighted sum of squared deviations from the sample domain means over the set of ordered vectors; that is, <code class="reqn">\bold{\hat{\theta}}</code> is the minimizer of <code class="reqn">(\tilde{\bold{y}}_{S} - \bold{\theta})^T \bold{W}_s (\tilde{\bold{y}}_{S} - \bold{\theta})</code> subject to <code class="reqn">\bold{A\theta} \geq \bold{0}</code>, where <code class="reqn">\bold{W}_S</code> is the diagonal matrix with elements <code class="reqn">\hat{N}_1/\hat{N},\ldots,\hat{N}_D/\hat{N}</code>, and <code class="reqn">\hat{N} = \sum_{t=1}^T \hat{N}_t</code> and <code class="reqn">\bold{A}</code> is a <code class="reqn">m\times T</code> constraint matrix imposing the monotonicity constraint. 
</p>
<p>Domains can also be formed from multiple covariates. In that case, a grid will be used to represent the domains. For example, if there are two predictors <code class="reqn">x_1</code> and <code class="reqn">x_2</code>, and <code class="reqn">x_1</code> has values on <code class="reqn">D_1</code> domains: <code class="reqn">1,\ldots,D_1</code>, <code class="reqn">x_2</code> has values on <code class="reqn">D_2</code> domains: <code class="reqn">1,\ldots,D_2</code>, then the domains formed by <code class="reqn">x_1</code> and <code class="reqn">x_2</code> will be a <code class="reqn">D_1\times D_2</code> by <code class="reqn">2</code> grid.
</p>
<p>To get <code class="reqn">100(1-\alpha)\%</code> approximate confidence intervals or surfaces for the domain means, we apply the method in Meyer, M. C. (2018). <code class="reqn">\hat{p}_J</code> is the estimated probability that the projection of <code class="reqn">y_s</code> onto <code class="reqn">\cal C</code> lands on <code class="reqn">\cal F_J</code>, and the <code class="reqn">\hat{p}_J</code> values are obtained by simulating many normal random vectors with estimated domain means and covariance matrix <code class="reqn">I</code>, where <code class="reqn">I</code> is a <code class="reqn">M \times M</code> matrix, and recording the resulting sets <code class="reqn">J</code>.
</p>
<p>The user needs to provide a survey design, which is specified by the svydesign function in the survey package, and also a data frame containing the response, predictor(s), domain variable, sampling weights, etc. So far, only stratified sampling design with simple random sampling without replacement (STSI) is considered in the examples in this package.
</p>
<p>Note that when there is any empty domain, the user must specify the total number of domains in the <code class="reqn">nD</code> argument. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csvy(formula, design, subset=NULL, nD=NULL, family=stats::gaussian(),
    amat=NULL, level=0.95, n.mix=100L, test=TRUE,...)
## S3 method for class 'csvy'
summary(object,...)
## S3 method for class 'csvy'
vcov(object,...)
## S3 method for class 'csvy'
coef(object,...)

## S3 method for class 'csvy'
confint(object, parm=NULL, level = 0.95, type = c("link", "response"),...)







## S3 method for class 'csvy'
predict(object, newdata = NULL, type = c("link", "response"), 
    se.fit = TRUE, level = 0.95, n.mix = 100,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="csvy_+3A_formula">formula</code></td>
<td>

<p>A formula object which gives a symbolic description of the model to be fitted. It has the form &quot;response ~ predictor&quot;. The response is a vector of length <code class="reqn">n</code>. A predictor can be a non-parametrically modelled variable with a monotonicity or convexity restriction, or a combination of both. In terms of a non-parametrically modelled predictor, the user is supposed to indicate the relationship between the domain mean and a predictor <code class="reqn">x</code> in the following way:
</p>
<p>Assume that <code class="reqn">\mu</code> is the vector of domain means and <code class="reqn">x</code> is a predictor:
</p>

<ul>
<li><p>incr(x): <code class="reqn">\mu</code> is increasing in <code class="reqn">x</code>.
</p>
</li>
<li><p>decr(x): <code class="reqn">\mu</code> is decreasing in <code class="reqn">x</code>.
</p>
</li>
<li><p>block.Ord(x): <code class="reqn">\mu</code> is has a block ordering in <code class="reqn">x</code>.
</p>
</li></ul>

</td></tr>
<tr><td><code id="csvy_+3A_design">design</code></td>
<td>

<p>A survey design, which must be specified by the svydesign routine in the survey package.
</p>
</td></tr>
<tr><td><code id="csvy_+3A_subset">subset</code></td>
<td>

<p>Expression to select a subpopulation.
</p>
</td></tr>
<tr><td><code id="csvy_+3A_nd">nD</code></td>
<td>

<p>Total number of domains.
</p>
</td></tr>
<tr><td><code id="csvy_+3A_family">family</code></td>
<td>

<p>A parameter indicating the error distribution and link function to be used in the model. It can be a character string naming a family function or the result of a call to a family function. This is borrowed from the glm routine in the stats package. There are four families used in csvy: Gaussian, binomial, poisson, and Gamma. 
</p>
</td></tr>
<tr><td><code id="csvy_+3A_amat">amat</code></td>
<td>

<p>A <code class="reqn">k \times M</code> matrix imposing shape constraints in each dimension, where <code class="reqn">M</code> is the
total number of domains. If the user doesn't provide the constraint matrix, a subroutine in the csurvey package will create a constraint matrix according to shape constraints specified in the formula. The default is amat = NULL.
</p>
</td></tr>
<tr><td><code id="csvy_+3A_level">level</code></td>
<td>

<p>Confidence level of the approximate confidence surfaces. The default is 0.95.
</p>
</td></tr>
<tr><td><code id="csvy_+3A_n.mix">n.mix</code></td>
<td>

<p>The number of simulations used to get the approximate confidence intervals or surfaces. If n.mix = 0, no simulation will be done and the face of the final projection will be used to compute the covariance matrix of the constrained estimate. The default is n.mix = 100L.
</p>
</td></tr>
<tr><td><code id="csvy_+3A_test">test</code></td>
<td>

<p>A logical scalar. If test == TRUE, then the p-value for the test <code class="reqn">H_0:\theta</code> is in <code class="reqn">V</code> versus <code class="reqn">H_1:\theta</code> is in <code class="reqn">C</code> is returned. <code class="reqn">C</code> is the constraint cone of the form <code class="reqn">\{\beta: A\beta \ge 0\}</code>, and <code class="reqn">V</code> is the null space of <code class="reqn">A</code>. The default is test = TRUE.
</p>
</td></tr>
<tr><td><code id="csvy_+3A_...">...</code></td>
<td>

<p>Other arguments
</p>
</td></tr>
</table>
<p>The <code>coef</code> function returns estimated systematic component of a csvy object.
</p>
<p>The <code>confint</code> function returns the confidence interval of a csvy object. If type = &quot;response&quot;, then the interval is for the mean; if type = &quot;link&quot;, then the interval is for the systematic component. 
</p>
<table>
<tr><td><code id="csvy_+3A_parm">parm</code></td>
<td>

<p>An argument in the generic confint function in the stats package. For now, this argument is not in use. 
</p>
</td></tr>
</table>
<p>The following arguments are used in the <code>predict</code> function.
</p>
<table>
<tr><td><code id="csvy_+3A_object">object</code></td>
<td>
<p>A csvy object.</p>
</td></tr>
<tr><td><code id="csvy_+3A_newdata">newdata</code></td>
<td>
<p>A data frame in which to look for variables with which to predict. If omitted, the fitted values are used.</p>
</td></tr>
<tr><td><code id="csvy_+3A_type">type</code></td>
<td>

<p>If the response is Gaussian, type = &quot;response&quot; and type = &quot;link&quot; give the predicted mean; if the response is binomial, poisson or Gamma, type = &quot;response&quot; gives the predicted mean, and type = &quot;link&quot; gives the predicted systematic component.
</p>
</td></tr>
<tr><td><code id="csvy_+3A_se.fit">se.fit</code></td>
<td>

<p>Logical switch indicating if confidence intervals are required.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For binomial and Poisson families use <code>family=quasibinomial()</code>
and <code>family=quasipoisson()</code> to avoid a warning about non-integer
numbers of successes.  The &lsquo;quasi&rsquo; versions of the family objects give
the same point estimates and standard errors and do not give the
warning.
</p>
<p><code>predict</code> gives fitted values and sampling variability for specific new
values of covariates.  When <code>newdata</code> are the population mean it
gives the regression estimator of the mean, and when <code>newdata</code> are
the population totals and <code>total</code> is specified it gives the
regression estimator of the population total.  Regression estimators of
mean and total can also be obtained with <code><a href="survey.html#topic+calibrate">calibrate</a></code>.
</p>







<h3>Value</h3>

<p>The output is a list of values used for estimation, inference and visualization. Main output include:
</p>
<table>
<tr><td><code>survey.design</code></td>
<td>
<p>The survey design used in the model.</p>
</td></tr>
<tr><td><code>etahat</code></td>
<td>
<p>Estimated shape-constrained domain systematic component.</p>
</td></tr>
<tr><td><code>etahatu</code></td>
<td>
<p>Estimated unconstrained domain systematic component.</p>
</td></tr>
<tr><td><code>muhat</code></td>
<td>
<p>Estimated shape-constrained domain means.</p>
</td></tr>
<tr><td><code>muhatu</code></td>
<td>
<p>Estimated unconstrained domain means.</p>
</td></tr>
<tr><td><code>lwr</code></td>
<td>
<p>Approximate lower confidence band or surface for the shape-constrained domain mean estimate.</p>
</td></tr>
<tr><td><code>upp</code></td>
<td>
<p>Approximate upper confidence band or surface for the shape-constrained domain mean estimate.</p>
</td></tr>
<tr><td><code>lwru</code></td>
<td>
<p>Approximate lower confidence band or surface for the unconstrained domain mean estimate.</p>
</td></tr>
<tr><td><code>uppu</code></td>
<td>
<p>Approximate upper confidence band or surface for the unconstrained domain mean estimate.</p>
</td></tr>
<tr><td><code>amat</code></td>
<td>
<p>The <code class="reqn">k \times M</code> constraint matrix imposing shape constraints in each dimension, where <code class="reqn">M</code> is the
total number of domains.</p>
</td></tr>
<tr><td><code>grid</code></td>
<td>
<p>A <code class="reqn">M \times p</code> grid, where <code class="reqn">p</code> is the total number of predictors or dimensions.</p>
</td></tr>
<tr><td><code>nd</code></td>
<td>
<p>A vector of sample sizes in all domains.</p>
</td></tr>
<tr><td><code>Ds</code></td>
<td>
<p>A vector of the number of domains in each dimension.</p>
</td></tr>
<tr><td><code>acov</code></td>
<td>
<p>Constrained mixture covariance estimate of domain means.</p>
</td></tr>
<tr><td><code>cov.un</code></td>
<td>
<p>Unconstrained covariance estimate of domain means.</p>
</td></tr>
<tr><td><code>CIC</code></td>
<td>
<p>The cone information criterion proposed in Meyer(2013a). It uses the &quot;null expected degrees of freedom&quot; as a measure of the complexity of the model. See Meyer(2013a) for further details of cic.</p>
</td></tr>
<tr><td><code>CIC.un</code></td>
<td>
<p>The cone information criterion for the unconstrained estimator.</p>
</td></tr>
<tr><td><code>zeros_ps</code></td>
<td>
<p>Index of empty domain(s).</p>
</td></tr>
<tr><td><code>nd</code></td>
<td>
<p>Sample size of each domain.</p>
</td></tr>
<tr><td><code>pval</code></td>
<td>
<p>p-value of the one-sided test.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>The family parameter defined in a csvy formula.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>The observed degree of freedom for the residuals of a csvy fit.</p>
</td></tr>
<tr><td><code>df.null</code></td>
<td>
<p>The degree of freedom for the null model of a csvy fit.</p>
</td></tr>
<tr><td><code>domain</code></td>
<td>
<p>Index of each domain in the data set contained in the survey.design object.</p>
</td></tr>
<tr><td><code>null.deviance</code></td>
<td>
<p>The deviance for the null model of a csvy fit.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>The residual deviance of a csvy fit.</p>
</td></tr>































</table>


<h3>Author(s)</h3>

<p>Xiyue Liao
</p>


<h3>References</h3>

<p>Xu, X. and Meyer, M. C. (2021) One-sided testing of population domain means in surveys. 
</p>
<p>Oliva, C., Meyer, M. C., and Opsomer, J.D. (2020) Estimation and inference of domain means subject to qualitative constraints. <em>Survey Methodology</em>
</p>
<p>Meyer, M. C. (2018) A Framework for Estimation and Inference in Generalized Additive Models with Shape and Order Restrictions. <em>Statistical Science <b>33(4)</b></em> 595&ndash;614.
</p>
<p>Wu, J., Opsomer, J.D., and Meyer, M. C. (2016) Survey estimation of domain means that respect natural orderings. <em>Canadian Journal of Statistics <b>44(4)</b></em> 431&ndash;444.
</p>
<p>Meyer, M. C. (2013a) Semi-parametric additive constrained regression. 
<em>Journal of Nonparametric Statistics <b>25(3)</b></em>, 715.
</p>
<p>Lumley, T. (2004) Analysis of complex survey samples. <em>Journal of Statistical Software <b>9(1)</b></em> 1&ndash;19.
</p>


<h3>See Also</h3>

 
<p><code>plotpersp</code>, to create a 3D Plot for a csvy Object
</p>
<p><code>incr</code>, to specify an increasing shape-restriction in a csvy Formula
</p>
<p><code>decr</code>, to specify an decreasing shape-restriction in a csvy Formula
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(api)

mcat = apipop$meals
for(i in 1:10){mcat[trunc(apipop$meals/10)+1==i] = i}
mcat[mcat==100]=10
D1 = 10

gcat = apipop$col.grad
for(i in 1:10){gcat[trunc(apipop$col.grad/10)+1==i] = i}
gcat[gcat &gt;= 5] = 4
D2 = 4

nsp = c(200,200,200)  ## sample sizes per stratum

es = sample(apipop$snum[apipop$stype=='E'&amp;!is.na(apipop$avg.ed)&amp;!is.na(apipop$api00)],nsp[1])
ms = sample(apipop$snum[apipop$stype=='M'&amp;!is.na(apipop$avg.ed)&amp;!is.na(apipop$api00)],nsp[2])
hs = sample(apipop$snum[apipop$stype=='H'&amp;!is.na(apipop$avg.ed)&amp;!is.na(apipop$api00)],nsp[3])
sid = c(es,ms,hs)

pw = 1:6194*0+4421/nsp[1]
pw[apipop$stype=='M'] = 1018/nsp[2]
pw[apipop$stype=='H'] = 755/nsp[3]

fpc = 1:6194*0+4421
fpc[apipop$stype=='M'] = 1018
fpc[apipop$stype=='H'] = 755

strsamp = cbind(apipop,mcat,gcat,pw,fpc)[sid,]

dstrat = svydesign(ids=~snum, strata=~stype, fpc=~fpc, data=strsamp, weight=~pw)
rds = as.svrepdesign(dstrat, type="JKn")

# Example 1: monotonic in one dimension
ansc1 = csvy(api00~decr(mcat), design=rds, nD=D1)
# checked estimated domain means
# ansc1$muhat

# Example 2: monotonic in three dimensions
D1 = 5
D2 = 5
D3 = 6
Ds = c(D1, D2, D3)
M = cumprod(Ds)[3]

x1vec = 1:D1
x2vec = 1:D2
x3vec = 1:D3
grid = expand.grid(x1vec, x2vec, x3vec)
N = M*100*4
Ns = rep(N/M, M)

mu.f = function(x) {
  mus = x[1]^(0.25)+4*exp(0.5+2*x[2])/(1+exp(0.5+2*x[2]))+sqrt(1/4+x[3])
  mus = as.numeric(mus$Var1)
  return (mus)
}

mus = mu.f(grid)

H = 4
nh = c(180,360,360,540)
n = sum(nh)
Nh = rep(N/H, H)

#generate population
y = NULL
z = NULL

set.seed(1)
for(i in 1:M){
  Ni = Ns[i]
  mui = mus[i]
  ei = rnorm(Ni, 0, sd=1)
  yi = mui + ei
  y = c(y, yi)
  zi = i/M + rnorm(Ni, mean=0, sd=1)
  z = c(z, zi)
}

x1 = rep(grid[,1], times=Ns)
x2 = rep(grid[,2], times=Ns)
x3 = rep(grid[,3], times=Ns)
domain = rep(1:M, times=Ns)

cts = quantile(z, probs=seq(0,1,length=5))
strata = 1:N*0
strata[z &gt;= cts[1] &amp; z &lt; cts[2]] = 1
strata[z &gt;= cts[2] &amp; z &lt; cts[3]] = 2
strata[z &gt;= cts[3] &amp; z &lt; cts[4]] = 3
strata[z &gt;= cts[4] &amp; z &lt;= cts[5]] = 4
freq = rep(N/(length(cts)-1), n)

w0 = Nh/nh
w = 1:N*0
w[strata == 1] = w0[1]
w[strata == 2] = w0[2]
w[strata == 3] = w0[3]
w[strata == 4] = w0[4]
pop = data.frame(y = y, x1 = x1, x2 = x2, x3 = x3, domain = domain, strata = strata, w=w)
ssid = stratsample(pop$strata, c("1"=nh[1], "2"=nh[2], "3"=nh[3], "4"=nh[4]))
sample.stsi = pop[ssid, ,drop=FALSE]
ds = svydesign(id=~1, strata =~strata, fpc=~freq, weights=~w, data=sample.stsi)


#domain means are increasing w.r.t x1, x2 and block monotonic in x3
ord = c(1,1,2,2,3,3)
ans = csvy(y~incr(x1)*incr(x2)*block.Ord(x3,order=ord), design=ds, nD=M, test=FALSE, n.mix=0)

#3D plot of estimated domain means: x1 and x2 with confidence intervals
plotpersp(ans, ci = "both")


#3D plot of estimated domain means: x3 and x2
plotpersp(ans, x3, x2)

#3D plot of estimated domain means: x3 and x2 for each domain of x1
plotpersp(ans, x3, x2, categ="x1")

#3D plot of estimated domain means: x3 and x2 for each domain of x1
plotpersp(ans, x3, x2, categ="x1", NCOL = 3)

# Example 3: unconstrained in one dimension

#no constraint on x1
ans = csvy(y~x1*incr(x2)*incr(x3), design=ds, test=FALSE, n.mix=0) 

#3D plot of estimated domain means: x1 and x2
plotpersp(ans)

</code></pre>

<hr>
<h2 id='nhdat'>
A Subset of National Health and Nutrition Examination Survey (NHANES) 
</h2><span id='topic+nhdat'></span>

<h3>Description</h3>

<p>The National Health and Nutrition Examination Survey (NHANES) combines in-person interviews and physical examinations to produce a comprehensive data set from a probability sample of residents of the U.S.  
</p>
<p>This data set is a subset of the NHANES data with 1,680 subjects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(nhdat)</code></pre>


<h3>Format</h3>


<dl>
<dt><code>id</code></dt><dd><p>a identification vector specifying cluster ids from largest level to smallest level</p>
</dd>
<dt><code>chol</code></dt><dd><p>a binomial vector showing cholestoral level. 1: high; 0: low</p>
</dd>
<dt><code>wcat</code></dt><dd><p>a vector of categorized waist and height ratio</p>
</dd>
<dt><code>gender</code></dt><dd><p>a binary vector of genders</p>
</dd>
<dt><code>age</code></dt><dd><p>a vector of categorized age</p>
</dd>
<dt><code>wt</code></dt><dd><p>sampling weight within each stratum</p>
</dd>
<dt><code>str</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(nhdat)
summary(nhdat)

## End(Not run)
</code></pre>

<hr>
<h2 id='nhdat2'>
A Subset of National Health and Nutrition Examination Survey (NHANES) 
</h2><span id='topic+nhdat2'></span>

<h3>Description</h3>

<p>The National Health and Nutrition Examination Survey (NHANES) combines in-person interviews and physical examinations to produce a comprehensive data set from a probability sample of residents of the U.S.  
</p>
<p>This data set is a subset of the NHANES data with 1,933 subjects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(nhdat2)</code></pre>


<h3>Format</h3>

<p>A data frame with 1933 observations on the following 8 variables.
</p>

<dl>
<dt><code>id</code></dt><dd><p>a identification vector specifying cluster ids from largest level to smallest level</p>
</dd>
<dt><code>chol</code></dt><dd><p>a continuous vector of cholesterol level</p>
</dd>
<dt><code>wcat</code></dt><dd><p>a vector of categorized waist and height ratio</p>
</dd>
<dt><code>icat</code></dt><dd><p>an ordinal vector of categorized income level</p>
</dd>
<dt><code>gender</code></dt><dd><p>a binary vector of genders</p>
</dd>
<dt><code>age</code></dt><dd><p>a vector of categorized age</p>
</dd>
<dt><code>wt</code></dt><dd><p>sampling weight within each stratum</p>
</dd>
<dt><code>str</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>The variable chol in this data set is continuous, which the varible chol in the nhdat data set is binomial.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(nhdat2)
summary(nhdat2)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
