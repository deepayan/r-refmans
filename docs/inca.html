<!DOCTYPE html><html lang="en"><head><title>Help for package inca</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {inca}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#inca-package'><p>Integer Calibration</p></a></li>
<li><a href='#adjWeights'><p>Function for Weights Adjustments</p></a></li>
<li><a href='#intcalibrate'><p>Integer Calibration Function</p></a></li>
<li><a href='#roundWeights'><p>Function for Rounding Weights</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Integer Calibration</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-09-18</td>
</tr>
<tr>
<td>Author:</td>
<td>Luca Sartore &lt;luca.sartore@usda.gov&gt; and Kelly Toppin &lt;kelly.toppin@nass.usda.gov&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Luca Sartore &lt;drwolf85@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Specific functions are provided for rounding real weights to integers and performing an integer programming algorithm for calibration problems. They are useful for census-weights adjustments, or for performing linear regression with integer parameters. This research was supported in part by the U.S. Department of Agriculture, National Agriculture Statistics Service. The findings and conclusions in this publication are those of the authors and should not be construed to represent any official USDA, or US Government determination or policy.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), stats, Matrix</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>survey</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++11</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-09-19 01:35:54 UTC; sartore</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-09-19 04:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='inca-package'>Integer Calibration</h2><span id='topic+inca-package'></span><span id='topic+inca'></span>

<h3>Description</h3>

<p>Specific functions are provided for rounding real weights to integers and performing integer programming algorithms for calibration problems.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> inca</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.0.4</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2019-09-18</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Calibration forces the weighted estimates of calibration variables to match known totals. 
This improves the quality of the design-weighted estimates. It is used to adjust for 
non-response and/or under-coverage. The commonly used methods of calibration produce 
non-integer weights. In cases where weighted estimates must be integers, one must 
&quot;integerize&quot; the calibrated weights. However, this procedure often produces final weights 
that are very different for the &quot;sample&quot; weights. To counter this problem, the <span class="pkg">inca</span> 
package provides specific functions for rounding real weights to integers, and performing 
an integer programming algorithm for calibration problems with integer weights.
</p>
<p>For a complete list of exported functions, use <code>library(help = "inca")</code>.
</p>
<p>This research was supported in part by the U.S. Department of Agriculture, 
National Agriculture Statistics Service. The findings and conclusions in this
publication are those of the authors and should not be construed to represent
any official USDA or U.S. Government determination or policy.
</p>


<h3>Author(s)</h3>

<p>Luca Sartore <a href="mailto:luca.sartore@usda.gov">luca.sartore@usda.gov</a> and Kelly Toppin <a href="mailto:kelly.toppin@nass.usda.gov">kelly.toppin@nass.usda.gov</a>
</p>
<p>Maintainer: Luca Sartore <a href="mailto:drwolf85@gmail.com">drwolf85@gmail.com</a>
</p>


<h3>References</h3>

<p>Theberge, A. (1999). Extensions of calibration estimators in survey sampling. <em>Journal of the American Statistical Association</em>, <b>94</b>(446), 635-644.
</p>
<p>Little, R. J., &amp; Vartivarian, S. (2003). On weighting the rates in non-response weights.
</p>
<p>Kish, L. (1992). Weighting for unequal Pi. <em>Journal of Official Statistics</em>, <b>8</b>(2), 183.
</p>
<p>Rao, J. N. K., &amp; Singh, A. C. (1997). A ridge-shrinkage method for range-restricted weight calibration in survey sampling. <em>In Proceedings of the section on survey research methods</em> (pp. 57-65). American Statistical Association Washington, DC.
</p>
<p>Horvitz, D. G., &amp; Thompson, D. J. (1952). A generalization of sampling without replacement from a finite universe. <em>Journal of the American Statistical Association</em>, <b>47</b>(260), 663-685.
</p>
<p>Kalton, G., &amp; Flores-Cervantes, I. (2003). Weighting methods. <em>Journal of Official Statistics</em>, <b>19</b>(2), 81-98.
</p>
<p>Sartore, L., Toppin, K., Young, L., Spiegelman, C. (2019). Developing integer calibration weights for the Census of Agriculture. <em>Journal of Agricultural, Biological, and Environmental Statistics</em>, <b>24</b>(1), 26-48.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(inca)

</code></pre>

<hr>
<h2 id='adjWeights'>Function for Weights Adjustments</h2><span id='topic+adjWeights'></span>

<h3>Description</h3>

<p>This function provides a trimming procedure to force the weights to be within the provided boundaries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjWeights(weights, lower = -Inf, upper = +Inf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adjWeights_+3A_weights">weights</code></td>
<td>
<p>A numerical vector of weights</p>
</td></tr>
<tr><td><code id="adjWeights_+3A_lower">lower</code></td>
<td>
<p>A numerical vector of lower bounds</p>
</td></tr>
<tr><td><code id="adjWeights_+3A_upper">upper</code></td>
<td>
<p>A numerical vector of upper bounds</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function produces trimmed weights, which will be the input for the rounding
technique before integer calibration. When the weights are bounded, the function rounds-up 
the lower bounds and rounds-down the upper. If the condition <code>upper &gt; lower + 1</code>,
an error is returned.
</p>


<h3>Value</h3>

<p>A vector of adjusted weights
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(inca)
w &lt;- rnorm(150, 0, 2)
aw &lt;- adjWeights(w, runif(150, -3, -1), runif(150, 1, 3))
hist(aw, main = "Adjusted weights")

</code></pre>

<hr>
<h2 id='intcalibrate'>Integer Calibration Function</h2><span id='topic+intcalibrate'></span>

<h3>Description</h3>

<p>This function performs an integer programming algorithm developed for calibrating integer weights, 
in order to reduce a specific objective function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intcalibrate(weights, formula, targets, objective = c("L1", "aL1", "rL1",
  "LB1", "rB1", "rbLasso1", "L2", "aL2", "rL2", "LB2", "rB2", "rbLasso2"),
  tgtBnds = NULL, lower = -Inf, upper = Inf, scale = NULL,
  sparse = FALSE, data = environment(formula))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="intcalibrate_+3A_weights">weights</code></td>
<td>
<p>A numerical vector of real or integer weights to be calibrated. If real values are provided, they will be rounded before applying the calibration algorithm</p>
</td></tr>
<tr><td><code id="intcalibrate_+3A_formula">formula</code></td>
<td>
<p>A formula to express a linear system for hitting the <code>targets</code></p>
</td></tr>
<tr><td><code id="intcalibrate_+3A_targets">targets</code></td>
<td>
<p>A numerical vector of point-targets to hit</p>
</td></tr>
<tr><td><code id="intcalibrate_+3A_objective">objective</code></td>
<td>
<p>A character specifying the objective function used for calibration. By default <code>"L1"</code>. See details for more information</p>
</td></tr>
<tr><td><code id="intcalibrate_+3A_tgtbnds">tgtBnds</code></td>
<td>
<p>A two-column matrix containing the bounds for the point-targets</p>
</td></tr>
<tr><td><code id="intcalibrate_+3A_lower">lower</code></td>
<td>
<p>A numerical vector or value defining the lower bounds of the weights</p>
</td></tr>
<tr><td><code id="intcalibrate_+3A_upper">upper</code></td>
<td>
<p>A numerical vector or value defining the upper bounds of the weights</p>
</td></tr>
<tr><td><code id="intcalibrate_+3A_scale">scale</code></td>
<td>
<p>A numerical vector of positive values</p>
</td></tr>
<tr><td><code id="intcalibrate_+3A_sparse">sparse</code></td>
<td>
<p>A logical value denoting if the linear system is sparse or not. By default it is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="intcalibrate_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> or <code>matrix</code> object containing the data to be used for calibration</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The integer programming algorithm for calibration can be performed by considering one of the following objective functions:
</p>

<dl>
<dt><code>"L1"</code></dt><dd><p>for the summation of absolute errors</p>
</dd>
<dt><code>"aL1"</code></dt><dd><p>for the asymmetric summation of absolute errors</p>
</dd>
<dt><code>"rL1"</code></dt><dd><p>for the summation of absolute relative errors</p>
</dd>
<dt><code>"LB1"</code></dt><dd><p>for the summation of absolute errors if outside the boundaries</p>
</dd>
<dt><code>"rB1"</code></dt><dd><p>for the summation of absolute relative errors if outside the boundaries</p>
</dd>
<dt><code>"rbLasso1"</code></dt><dd><p>for the summation of absolute relative errors if outside the boundaries plus a Lasso penalty based on the distance from the provided weights</p>
</dd>
<dt><code>"L2"</code></dt><dd><p>for the summation of square errors</p>
</dd>
<dt><code>"aL2"</code></dt><dd><p>for the asymmetric summation of square errors</p>
</dd>
<dt><code>"rL2"</code></dt><dd><p>for the summation of square relative errors</p>
</dd>
<dt><code>"LB2"</code></dt><dd><p>for the summation of square errors if outside the boundaries</p>
</dd>
<dt><code>"rB2"</code></dt><dd><p>for the summation of square relative errors if outside the boundaries</p>
</dd>
<dt><code>"rbLasso2"</code></dt><dd><p>for the summation of square relative errors if outside the boundaries plus a Lasso penalty based on the distance from the provided weights</p>
</dd>
</dl>

<p>A two-column matrix must be provided to <code>tgtBnds</code> when <code>objective = "LB1"</code>, <code>objective = "rB1"</code>, 
<code>objective = "rbLasso1"</code>, <code>objective = "LB2"</code>, <code>objective = "rB2"</code>, and <code>objective = "rbLasso2"</code>.
</p>
<p>The argument <code>scale</code> must be specified with a vector of positive reals number when <code>objective = "rL1"</code> 
or <code>objective = "rL2"</code>.
</p>


<h3>Value</h3>

<p>A numerical vector of calibrated integer weights.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(inca)
set.seed(0)
w &lt;- rpois(150, 4)
data &lt;- matrix(rbinom(150000, 1, .3) * rpois(150000, 4), 1000, 150)
y &lt;- data %*% w
w &lt;- runif(150, 0, 7.5)
print(sum(abs(y - data %*% w)))
cw &lt;- intcalibrate(w, ~. + 0, y, lower = 1, upper = 7, sparse = TRUE, data = data)
print(sum(abs(y - data %*% cw)))
barplot(table(cw), main = "Calibrated integer weights")

</code></pre>

<hr>
<h2 id='roundWeights'>Function for Rounding Weights</h2><span id='topic+roundWeights'></span>

<h3>Description</h3>

<p>This function performs an optimal rounding of the provided real weights, 
in order to reduce a specific objective function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roundWeights(weights, formula, targets, objective = c("L1", "aL1", "rL1",
  "LB1", "rB1", "rbLasso1", "L2", "aL2", "rL2", "LB2", "rB2", "rbLasso2"),
  tgtBnds = NULL, lower = -Inf, upper = Inf, scale = NULL,
  sparse = FALSE, data = environment(formula))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="roundWeights_+3A_weights">weights</code></td>
<td>
<p>A numerical vector of real weights to be rounded</p>
</td></tr>
<tr><td><code id="roundWeights_+3A_formula">formula</code></td>
<td>
<p>A formula to express a linear system for hitting the <code>targets</code></p>
</td></tr>
<tr><td><code id="roundWeights_+3A_targets">targets</code></td>
<td>
<p>A numerical vector of point-targets to hit</p>
</td></tr>
<tr><td><code id="roundWeights_+3A_objective">objective</code></td>
<td>
<p>A character specifying the objective function used for calibration. By default, it is <code>"L1"</code>. See details for more information</p>
</td></tr>
<tr><td><code id="roundWeights_+3A_tgtbnds">tgtBnds</code></td>
<td>
<p>A two-column matrix containing the bounds for the point-targets</p>
</td></tr>
<tr><td><code id="roundWeights_+3A_lower">lower</code></td>
<td>
<p>A numerical vector or value defining the lower bounds of the weights</p>
</td></tr>
<tr><td><code id="roundWeights_+3A_upper">upper</code></td>
<td>
<p>A numerical vector or value defining the upper bounds of the weights</p>
</td></tr>
<tr><td><code id="roundWeights_+3A_scale">scale</code></td>
<td>
<p>A numerical vector of positive values</p>
</td></tr>
<tr><td><code id="roundWeights_+3A_sparse">sparse</code></td>
<td>
<p>A logical value denoting if the linear system is sparse or not. By default, it is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="roundWeights_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> or <code>matrix</code> object containing the data to be used for calibration</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The optimal rounding can be performed by considering one of the following objective functions:
</p>

<dl>
<dt><code>"L1"</code></dt><dd><p>for the summation of absolute errors</p>
</dd>
<dt><code>"aL1"</code></dt><dd><p>for the asymmetric summation of absolute errors</p>
</dd>
<dt><code>"rL1"</code></dt><dd><p>for the summation of absolute relative errors</p>
</dd>
<dt><code>"LB1"</code></dt><dd><p>for the summation of absolute errors if outside the boundaries</p>
</dd>
<dt><code>"rB1"</code></dt><dd><p>for the summation of absolute relative errors if outside the boundaries</p>
</dd>
<dt><code>"rbLasso1"</code></dt><dd><p>for the summation of absolute relative errors if outside the boundaries plus a Lasso penalty based on the distance from the provided weights</p>
</dd>
<dt><code>"L2"</code></dt><dd><p>for the summation of square errors</p>
</dd>
<dt><code>"aL2"</code></dt><dd><p>for the asymmetric summation of square errors</p>
</dd>
<dt><code>"rL2"</code></dt><dd><p>for the summation of square relative errors</p>
</dd>
<dt><code>"LB2"</code></dt><dd><p>for the summation of square errors if outside the boundaries</p>
</dd>
<dt><code>"rB2"</code></dt><dd><p>for the summation of square relative errors if outside the boundaries</p>
</dd>
<dt><code>"rbLasso2"</code></dt><dd><p>for the summation of square relative errors if outside the boundaries plus a Lasso penalty based on the distance from the provided weights</p>
</dd>
</dl>

<p>A two-column matrix must be provided to <code>tgtBnds</code> when <code>objective = "LB1"</code>, <code>objective = "rB1"</code>, 
<code>objective = "rbLasso1"</code>, <code>objective = "LB2"</code>, <code>objective = "rB2"</code>, and <code>objective = "rbLasso2"</code>.
</p>
<p>The argument <code>scale</code> must be specified with a vector of positive reals number when <code>objective = "rL1"</code> 
or <code>objective = "rL2"</code>.
</p>


<h3>Value</h3>

<p>A vector of integer weights to be the input of the calibration algorithm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(inca)
set.seed(0)
w &lt;- rpois(150, 4)
data &lt;- matrix(rbinom(150000, 1, .3) * rpois(150000, 4), 1000, 150)
y &lt;- data %*% w
w &lt;- runif(150, 0, 7.5)
rw &lt;- roundWeights(w, ~. + 0, y, lower = 1, upper = 7, sparse = TRUE, data = data)
barplot(table(rw), main = "Rounded weigths")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
