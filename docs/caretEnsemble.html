<!DOCTYPE html><html lang="en-US"><head><title>Help for package caretEnsemble</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {caretEnsemble}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#caretEnsemble'><p>Combine several predictive models via weights</p></a></li>
<li><a href='#+5B.caretList'><p>Index a caretList</p></a></li>
<li><a href='#aggregate_mean_or_first'><p>Aggregate mean or first</p></a></li>
<li><a href='#as.caretList'><p>Convert object to caretList object</p></a></li>
<li><a href='#as.caretList.default'><p>Convert object to caretList object - For Future Use</p></a></li>
<li><a href='#as.caretList.list'><p>Convert list to caretList</p></a></li>
<li><a href='#autoplot.caretStack'><p>Convenience function for more in-depth diagnostic plots of caretStack objects</p></a></li>
<li><a href='#c.caretList'><p>S3 definition for concatenating caretList</p></a></li>
<li><a href='#c.train'><p>S3 definition for concatenating train objects</p></a></li>
<li><a href='#caretList'><p>Create a list of several train models from the caret package</p></a></li>
<li><a href='#caretModelSpec'><p>Generate a specification for fitting a caret model</p></a></li>
<li><a href='#caretPredict'><p>Prediction wrapper for <code>train</code></p></a></li>
<li><a href='#caretStack'><p>Combine several predictive models via stacking</p></a></li>
<li><a href='#caretTrain'><p>Wrapper to train caret models</p></a></li>
<li><a href='#check_caretStack'><p>Check caretStack object</p></a></li>
<li><a href='#checkCustomModel'><p>Validate a custom caret model info list</p></a></li>
<li><a href='#defaultControl'><p>Construct a default train control for use with caretList</p></a></li>
<li><a href='#defaultMetric'><p>Construct a default metric</p></a></li>
<li><a href='#dotplot.caretStack'><p>Comparison dotplot for a caretStack object</p></a></li>
<li><a href='#dropExcludedClass'><p>Drop Excluded Class</p></a></li>
<li><a href='#extractBestPreds'><p>Extract the best predictions from a train object</p></a></li>
<li><a href='#extractCaretTarget'><p>Extracts the target variable from a set of arguments headed to the caret::train function.</p></a></li>
<li><a href='#extractCaretTarget.default'><p>Extracts the target variable from a set of arguments headed to the caret::train.default function.</p></a></li>
<li><a href='#extractCaretTarget.formula'><p>Extracts the target variable from a set of arguments headed to the caret::train.formula function.</p></a></li>
<li><a href='#extractMetric'><p>Generic function to extract accuracy metrics from various model objects</p></a></li>
<li><a href='#extractMetric.caretList'><p>Extract accuracy metrics from a <code>caretList</code> object</p></a></li>
<li><a href='#extractMetric.caretStack'><p>Extract accuracy metrics from a <code>caretStack</code> object</p></a></li>
<li><a href='#extractMetric.train'><p>Extract accuracy metrics from a <code>train</code> model</p></a></li>
<li><a href='#extractModelName'><p>Extract the method name associated with a single train object</p></a></li>
<li><a href='#greedyMSE'><p>Greedy optimization for MSE</p></a></li>
<li><a href='#greedyMSE_caret'><p>caret interface for greedyMSE</p></a></li>
<li><a href='#isClassifier'><p>Is Classifier</p></a></li>
<li><a href='#isClassifierAndValidate'><p>Validate a model type</p></a></li>
<li><a href='#mae'><p>Compute MAE</p></a></li>
<li><a href='#methodCheck'><p>Check that the methods supplied by the user are valid caret methods</p></a></li>
<li><a href='#models.class'><p>caretList of classification models</p></a></li>
<li><a href='#models.reg'><p>caretList of regression models</p></a></li>
<li><a href='#normalize_to_one'><p>Normalize to One</p></a></li>
<li><a href='#permutationImportance'><p>Permutation Importance</p></a></li>
<li><a href='#plot.caretList'><p>Plot a caretList object</p></a></li>
<li><a href='#plot.caretStack'><p>Plot a caretStack object</p></a></li>
<li><a href='#predict.caretList'><p>Create a matrix of predictions for each of the models in a caretList</p></a></li>
<li><a href='#predict.caretStack'><p>Make predictions from a caretStack</p></a></li>
<li><a href='#predict.greedyMSE'><p>Predict method for greedyMSE</p></a></li>
<li><a href='#print.caretStack'><p>Print a caretStack object</p></a></li>
<li><a href='#print.greedyMSE'><p>Print method for greedyMSE</p></a></li>
<li><a href='#print.summary.caretList'><p>Print a summary.caretList object</p></a></li>
<li><a href='#print.summary.caretStack'><p>Print a summary.caretStack object</p></a></li>
<li><a href='#set_excluded_class_id'><p>Set excluded class id</p></a></li>
<li><a href='#shuffled_mae'><p>Shuffled MAE</p></a></li>
<li><a href='#stackedTrainResiduals'><p>Extracted stacked residuals for the autoplot</p></a></li>
<li><a href='#summary.caretList'><p>Summarize a caretList</p></a></li>
<li><a href='#summary.caretStack'><p>Summarize a caretStack object</p></a></li>
<li><a href='#tuneCheck'><p>Check that the tuning parameters list supplied by the user is valid</p></a></li>
<li><a href='#validateExcludedClass'><p>Validate the excluded class</p></a></li>
<li><a href='#varImp.caretStack'><p>Variable importance for caretStack</p></a></li>
<li><a href='#varImp.greedyMSE'><p>variable importance for a greedyMSE model</p></a></li>
<li><a href='#wtd.sd'><p>Calculate a weighted standard deviation</p></a></li>
<li><a href='#X.class'><p>data for classification</p></a></li>
<li><a href='#X.reg'><p>data for classification</p></a></li>
<li><a href='#Y.class'><p>data for classification</p></a></li>
<li><a href='#Y.reg'><p>data for regression</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Ensembles of Caret Models</td>
</tr>
<tr>
<td>Version:</td>
<td>4.0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-08-17</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://zachmayer.github.io/caretEnsemble/">http://zachmayer.github.io/caretEnsemble/</a>,
<a href="https://github.com/zachmayer/caretEnsemble">https://github.com/zachmayer/caretEnsemble</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/zachmayer/caretEnsemble/issues">https://github.com/zachmayer/caretEnsemble/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for creating ensembles of caret models: caretList()
    and caretStack(). caretList() is a convenience function for fitting multiple
    caret::train() models to the same dataset. caretStack() will make linear or
    non-linear combinations of these models, using a caret::train() model as a
    meta-model.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, caTools, covr, earth, gbm, glmnet, klaR, knitr, lintr,
mgcv, mlbench, nnet, randomForest, rmarkdown, rhub, rpart,
spelling, testthat, usethis</td>
</tr>
<tr>
<td>Imports:</td>
<td>caret, data.table, ggplot2, lattice, methods, patchwork,
pbapply, rlang</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-12 20:07:27 UTC; zach</td>
</tr>
<tr>
<td>Author:</td>
<td>Zachary A. Deane-Mayer [aut, cre, cph],
  Jared E. Knowles [ctb],
  Ant贸n L贸pez [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Zachary A. Deane-Mayer &lt;zach.mayer@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-12 21:50:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='caretEnsemble'>Combine several predictive models via weights</h2><span id='topic+caretEnsemble'></span><span id='topic+caretEnsemble-package'></span>

<h3>Description</h3>

<p>Find a greedy, positive only linear combination of several <code><a href="caret.html#topic+train">train</a></code> objects
</p>
<p>Functions for creating ensembles of caret models: caretList and caretStack
</p>


<h3>Usage</h3>

<pre><code class='language-R'>caretEnsemble(all.models, excluded_class_id = 0L, tuneLength = 1L, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="caretEnsemble_+3A_all.models">all.models</code></td>
<td>
<p>an object of class caretList</p>
</td></tr>
<tr><td><code id="caretEnsemble_+3A_excluded_class_id">excluded_class_id</code></td>
<td>
<p>The integer level to exclude from binary classification or multiclass problems.
By default no classes are excluded, as the greedy optimizer requires all classes because it cannot
use negative coefficients.</p>
</td></tr>
<tr><td><code id="caretEnsemble_+3A_tunelength">tuneLength</code></td>
<td>
<p>The size of the grid to search for tuning the model. Defaults to 1, as
the only parameter to optimize is the number of iterations, and the default of 100 works well.</p>
</td></tr>
<tr><td><code id="caretEnsemble_+3A_...">...</code></td>
<td>
<p>additional arguments to pass caret::train</p>
</td></tr>
</table>


<h3>Details</h3>

<p>greedyMSE works well when you want an ensemble that will never be worse than any
single model in the dataset. In the worst case scenario, it will select the single
best model, if none of them can be ensembled to improve the overall score. It will
also never assign any model a negative coefficient, which can help avoid
unintuitive cases at prediction time (e.g. if the correlations between
predictors breaks down on new data, negative coefficients can lead to bad results).
</p>


<h3>Value</h3>

<p>a <code><a href="#topic+caretEnsemble">caretEnsemble</a></code> object
</p>


<h3>Note</h3>

<p>Every model in the &quot;library&quot; must be a separate <code>train</code> object. For
example, if you wish to combine a random forests with several different
values of mtry, you must build a model for each value of mtry. If you
use several values of mtry in one train model, (e.g. tuneGrid =
expand.grid(.mtry=2:5)), caret will select the best value of mtry
before we get a chance to include it in the ensemble. By default,
RMSE is used to ensemble regression models, and AUC is used to ensemble
Classification models. This function does not currently support multi-class
problems
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Zachary A. Deane-Mayer <a href="mailto:zach.mayer@gmail.com">zach.mayer@gmail.com</a> [copyright holder]
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Jared E. Knowles <a href="mailto:jknowles@gmail.com">jknowles@gmail.com</a> [contributor]
</p>
</li>
<li><p> Ant贸n L贸pez <a href="mailto:anton.gomez.lopez@rai.usc.es">anton.gomez.lopez@rai.usc.es</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="http://zachmayer.github.io/caretEnsemble/">http://zachmayer.github.io/caretEnsemble/</a>
</p>
</li>
<li> <p><a href="https://github.com/zachmayer/caretEnsemble">https://github.com/zachmayer/caretEnsemble</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/zachmayer/caretEnsemble/issues">https://github.com/zachmayer/caretEnsemble/issues</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
models &lt;- caretList(iris[1:50, 1:2], iris[1:50, 3], methodList = c("rpart", "rf"))
ens &lt;- caretEnsemble(models)
summary(ens)
</code></pre>

<hr>
<h2 id='+5B.caretList'>Index a caretList</h2><span id='topic++5B.caretList'></span>

<h3>Description</h3>

<p>Index a caret list to extract caret models into a new caretList object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'caretList'
object[index]
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B5B.caretList_+3A_object">object</code></td>
<td>
<p>an object of class caretList</p>
</td></tr>
<tr><td><code id="+2B5B.caretList_+3A_index">index</code></td>
<td>
<p>selected index</p>
</td></tr>
</table>

<hr>
<h2 id='aggregate_mean_or_first'>Aggregate mean or first</h2><span id='topic+aggregate_mean_or_first'></span>

<h3>Description</h3>

<p>For numeric data take the mean. For character data take the first value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregate_mean_or_first(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="aggregate_mean_or_first_+3A_x">x</code></td>
<td>
<p>a train object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.table::data.table with predictions
</p>

<hr>
<h2 id='as.caretList'>Convert object to caretList object</h2><span id='topic+as.caretList'></span>

<h3>Description</h3>

<p>Converts object into a caretList
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.caretList(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.caretList_+3A_object">object</code></td>
<td>
<p>R Object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="#topic+caretList">caretList</a></code> object
</p>

<hr>
<h2 id='as.caretList.default'>Convert object to caretList object - For Future Use</h2><span id='topic+as.caretList.default'></span>

<h3>Description</h3>

<p>Converts object into a caretList  - For Future Use
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
as.caretList(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.caretList.default_+3A_object">object</code></td>
<td>
<p>R object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NA
</p>

<hr>
<h2 id='as.caretList.list'>Convert list to caretList</h2><span id='topic+as.caretList.list'></span>

<h3>Description</h3>

<p>Converts list to caretList
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'list'
as.caretList(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.caretList.list_+3A_object">object</code></td>
<td>
<p>list of caret models</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="#topic+caretList">caretList</a></code> object
</p>

<hr>
<h2 id='autoplot.caretStack'>Convenience function for more in-depth diagnostic plots of caretStack objects</h2><span id='topic+autoplot.caretStack'></span>

<h3>Description</h3>

<p>This function provides a more robust series of diagnostic plots
for a caretEnsemble object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'caretStack'
autoplot(object, training_data = NULL, xvars = NULL, show_class_id = 2L, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="autoplot.caretStack_+3A_object">object</code></td>
<td>
<p>a <code>caretStack</code> object</p>
</td></tr>
<tr><td><code id="autoplot.caretStack_+3A_training_data">training_data</code></td>
<td>
<p>The data used to train the ensemble. Required if xvars is not NULL
Must be in the same row order as when the models were trained.</p>
</td></tr>
<tr><td><code id="autoplot.caretStack_+3A_xvars">xvars</code></td>
<td>
<p>a vector of the names of x variables to plot against residuals</p>
</td></tr>
<tr><td><code id="autoplot.caretStack_+3A_show_class_id">show_class_id</code></td>
<td>
<p>For classification only: which class level to show on the plot</p>
</td></tr>
<tr><td><code id="autoplot.caretStack_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A grid of diagnostic plots. Top left is the range of the performance
metric across each component model along with its standard deviation. Top right
is the residuals from the ensembled model plotted against fitted values.
Middle left is a bar graph of the weights of the component models. Middle
right is the disagreement in the residuals of the component models (unweighted)
across the fitted values. Bottom left and bottom right are the plots of the
residuals against two random or user specified variables. Note that the ensemble
must have been trained with savePredictions = &quot;final&quot;, which is required to
get residuals from the stack for the plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
data(models.reg)
ens &lt;- caretStack(models.reg[1:2], method = "lm")
autoplot(ens)
</code></pre>

<hr>
<h2 id='c.caretList'>S3 definition for concatenating caretList</h2><span id='topic+c.caretList'></span>

<h3>Description</h3>

<p>take N objects of class caretList and concatenate them into a larger object of
class caretList for future ensembling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'caretList'
c(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="c.caretList_+3A_...">...</code></td>
<td>
<p>the objects of class caretList or train to bind into a caretList</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="#topic+caretList">caretList</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
model_list1 &lt;- caretList(Sepal.Width ~ .,
  data = iris,
  tuneList = list(
    lm = caretModelSpec(method = "lm")
  )
)

model_list2 &lt;- caretList(Sepal.Width ~ .,
  data = iris, tuneLength = 1L,
  tuneList = list(
    rf = caretModelSpec(method = "rf")
  )
)

bigList &lt;- c(model_list1, model_list2)
</code></pre>

<hr>
<h2 id='c.train'>S3 definition for concatenating train objects</h2><span id='topic+c.train'></span>

<h3>Description</h3>

<p>take N objects of class train and concatenate into an object of class caretList for future ensembling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'train'
c(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="c.train_+3A_...">...</code></td>
<td>
<p>the objects of class train to bind into a caretList</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="#topic+caretList">caretList</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
model_lm &lt;- caret::train(Sepal.Length ~ .,
  data = iris,
  method = "lm"
)

model_rf &lt;- caret::train(Sepal.Length ~ .,
  data = iris,
  method = "rf",
  tuneLength = 1L
)

model_list &lt;- c(model_lm, model_rf)
</code></pre>

<hr>
<h2 id='caretList'>Create a list of several train models from the caret package</h2><span id='topic+caretList'></span>

<h3>Description</h3>

<p>Build a list of train objects suitable for ensembling using the <code><a href="#topic+caretStack">caretStack</a></code>
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>caretList(
  ...,
  trControl = NULL,
  methodList = NULL,
  tuneList = NULL,
  metric = NULL,
  continue_on_fail = FALSE,
  trim = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="caretList_+3A_...">...</code></td>
<td>
<p>arguments to pass to <code><a href="caret.html#topic+train">train</a></code>. Don't use the formula interface, its slower
and buggier compared to the X, y interface. Use a <code><a href="data.table.html#topic+data.table">data.table</a></code> for X.
Particularly if you have a large dataset and/or many models, using a data.table will
avoid unnecessary copies of your data and can save a lot of time and RAM.
These arguments will determine which train method gets dispatched.</p>
</td></tr>
<tr><td><code id="caretList_+3A_trcontrol">trControl</code></td>
<td>
<p>a <code><a href="caret.html#topic+trainControl">trainControl</a></code> object. If NULL, will use defaultControl.</p>
</td></tr>
<tr><td><code id="caretList_+3A_methodlist">methodList</code></td>
<td>
<p>optional, a character vector of caret models to ensemble.
One of methodList or tuneList must be specified.</p>
</td></tr>
<tr><td><code id="caretList_+3A_tunelist">tuneList</code></td>
<td>
<p>optional, a NAMED list of caretModelSpec objects.
This much more flexible than methodList and allows the
specification of model-specific parameters (e.g. passing trace=FALSE to nnet)</p>
</td></tr>
<tr><td><code id="caretList_+3A_metric">metric</code></td>
<td>
<p>a string, the metric to optimize for. If NULL, we will choose a good one.</p>
</td></tr>
<tr><td><code id="caretList_+3A_continue_on_fail">continue_on_fail</code></td>
<td>
<p>logical, should a valid caretList be returned that
excludes models that fail, default is FALSE</p>
</td></tr>
<tr><td><code id="caretList_+3A_trim">trim</code></td>
<td>
<p>logical should the train models be trimmed to save memory and speed up stacking</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code><a href="caret.html#topic+train">train</a></code> objects. If the model fails to build,
it is dropped from the list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>caretList(
  Sepal.Length ~ Sepal.Width,
  head(iris, 50),
  methodList = c("glm", "lm"),
  tuneList = list(
    nnet = caretModelSpec(method = "nnet", trace = FALSE, tuneLength = 1)
  )
)
</code></pre>

<hr>
<h2 id='caretModelSpec'>Generate a specification for fitting a caret model</h2><span id='topic+caretModelSpec'></span>

<h3>Description</h3>

<p>A caret model specification consists of 2 parts: a model (as a string) and
the arguments to the train call for fitting that model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>caretModelSpec(method = "rf", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="caretModelSpec_+3A_method">method</code></td>
<td>
<p>the modeling method to pass to caret::train</p>
</td></tr>
<tr><td><code id="caretModelSpec_+3A_...">...</code></td>
<td>
<p>Other arguments that will eventually be passed to caret::train</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of lists
</p>


<h3>Examples</h3>

<pre><code class='language-R'>caretModelSpec("rf", tuneLength = 5, preProcess = "ica")
</code></pre>

<hr>
<h2 id='caretPredict'>Prediction wrapper for <code><a href="caret.html#topic+train">train</a></code></h2><span id='topic+caretPredict'></span>

<h3>Description</h3>

<p>This is a prediction wrapper for <code><a href="caret.html#topic+train">train</a></code> with several features:
- If newdata is null, return stacked predictions from the training job, rather than in-sample predictions.
- Always returns probabilities for classification models.
- Optionally drops one predicted class for classification models.
- Always returns a <code><a href="data.table.html#topic+data.table">data.table</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>caretPredict(object, newdata = NULL, excluded_class_id = 1L, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="caretPredict_+3A_object">object</code></td>
<td>
<p>a <code><a href="caret.html#topic+train">train</a></code> object</p>
</td></tr>
<tr><td><code id="caretPredict_+3A_newdata">newdata</code></td>
<td>
<p>New data to use for predictions. If NULL, stacked predictions from the training data are returned.</p>
</td></tr>
<tr><td><code id="caretPredict_+3A_excluded_class_id">excluded_class_id</code></td>
<td>
<p>an integer indicating the class to exclude. If 0L, no class is excluded</p>
</td></tr>
<tr><td><code id="caretPredict_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to <code><a href="caret.html#topic+predict.train">predict.train</a></code>, if newdata is not NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.table
</p>

<hr>
<h2 id='caretStack'>Combine several predictive models via stacking</h2><span id='topic+caretStack'></span>

<h3>Description</h3>

<p>Stack several <code><a href="caret.html#topic+train">train</a></code> models using a <code><a href="caret.html#topic+train">train</a></code> model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>caretStack(
  all.models,
  new_X = NULL,
  new_y = NULL,
  metric = NULL,
  trControl = NULL,
  excluded_class_id = 1L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="caretStack_+3A_all.models">all.models</code></td>
<td>
<p>a caretList, or an object coercible to a caretList (such as a list of train objects)</p>
</td></tr>
<tr><td><code id="caretStack_+3A_new_x">new_X</code></td>
<td>
<p>Data to predict on for the caretList, prior to training the stack (for transfer learning).
if NULL, the stacked predictions will be extracted from the caretList models.</p>
</td></tr>
<tr><td><code id="caretStack_+3A_new_y">new_y</code></td>
<td>
<p>The outcome variable to predict on for the caretList, prior to training the stack
(for transfer learning).
If NULL, will use the observed levels from the first model in the caret stack
If 0, will include all levels.</p>
</td></tr>
<tr><td><code id="caretStack_+3A_metric">metric</code></td>
<td>
<p>the metric to use for grid search on the stacking model.</p>
</td></tr>
<tr><td><code id="caretStack_+3A_trcontrol">trControl</code></td>
<td>
<p>a trainControl object to use for training the ensemble model. If NULL, will use defaultControl.</p>
</td></tr>
<tr><td><code id="caretStack_+3A_excluded_class_id">excluded_class_id</code></td>
<td>
<p>The integer level to exclude from binary classification or multiclass problems.</p>
</td></tr>
<tr><td><code id="caretStack_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to the stacking model</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses either transfer learning or stacking to stack models. Assumes that all models were trained on
the same number of rows of data, with the same target values. The features, cross-validation strategies,
and model types (class vs reg) may vary however. If your stack of models were trained with different number of
rows, please provide new_X and new_y so the models can predict on a common set of data for stacking.
</p>
<p>If your models were trained on different columns, you should use stacking.
</p>
<p>If you have both differing rows and columns in your model set, you are out of luck. You need at least
a common set of rows during training (for stacking) or a common set of columns at
inference time for transfer learning.
</p>


<h3>Value</h3>

<p>S3 caretStack object
</p>


<h3>References</h3>

<p>Caruana, R., Niculescu-Mizil, A., Crew, G., &amp; Ksikes, A. (2004).
Ensemble Selection from Libraries of Models.
<a href="https://www.cs.cornell.edu/~caruana/ctp/ct.papers/caruana.icml04.icdm06long.pdf">https://www.cs.cornell.edu/~caruana/ctp/ct.papers/caruana.icml04.icdm06long.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>models &lt;- caretList(
  x = iris[1:50, 1:2],
  y = iris[1:50, 3],
  methodList = c("rpart", "glm")
)
caretStack(models, method = "glm")
</code></pre>

<hr>
<h2 id='caretTrain'>Wrapper to train caret models</h2><span id='topic+caretTrain'></span>

<h3>Description</h3>

<p>This function is a wrapper around the 'train' function from the 'caret' package.
It allows for the passing of local and global arguments to the 'train' function.
It also allows for the option to continue on fail, and to trim the output model.
Trimming the model removes components that are not needed for stacking, to save
memory and speed up the stacking process. It also converts preds to a data.table.
Its an internal function for use with caretList.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>caretTrain(local_args, global_args, continue_on_fail = FALSE, trim = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="caretTrain_+3A_local_args">local_args</code></td>
<td>
<p>A list of arguments to pass to the 'train' function.</p>
</td></tr>
<tr><td><code id="caretTrain_+3A_global_args">global_args</code></td>
<td>
<p>A list of arguments to pass to the 'train' function.</p>
</td></tr>
<tr><td><code id="caretTrain_+3A_continue_on_fail">continue_on_fail</code></td>
<td>
<p>A logical indicating whether to continue if the 'train' function fails.
If 'TRUE', the function will return 'NULL' if the 'train' function fails.</p>
</td></tr>
<tr><td><code id="caretTrain_+3A_trim">trim</code></td>
<td>
<p>A logical indicating whether to trim the output model.
If 'TRUE', the function will remove some elements that are not needed from the output model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output of the 'train' function.
</p>

<hr>
<h2 id='check_caretStack'>Check caretStack object</h2><span id='topic+check_caretStack'></span>

<h3>Description</h3>

<p>Make sure a caretStack has both a caretList and a train object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_caretStack(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_caretStack_+3A_object">object</code></td>
<td>
<p>a caretStack object</p>
</td></tr>
</table>

<hr>
<h2 id='checkCustomModel'>Validate a custom caret model info list</h2><span id='topic+checkCustomModel'></span>

<h3>Description</h3>

<p>Currently, this only ensures that all model info lists
were also assigned a &quot;method&quot; attribute for consistency with usage
of non-custom models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkCustomModel(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkCustomModel_+3A_x">x</code></td>
<td>
<p>a model info list (e.g. <code>getModelInfo("rf", regex=F)\[[1]]</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>validated model info list (i.e. x)
</p>

<hr>
<h2 id='defaultControl'>Construct a default train control for use with caretList</h2><span id='topic+defaultControl'></span>

<h3>Description</h3>

<p>Unlike caret::trainControl, this function defaults to 5 fold CV.
CV is good for stacking, as every observation is in the test set exactly once.
We use 5 instead of 10 to save compute time, as caretList is for fitting many
models. We also construct explicit fold indexes and return the stacked predictions,
which are needed for stacking. For classification models we return class probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>defaultControl(
  target,
  method = "cv",
  number = 5L,
  savePredictions = "final",
  index = caret::createFolds(target, k = number, list = TRUE, returnTrain = TRUE),
  is_class = is.factor(target) || is.character(target),
  is_binary = length(unique(target)) == 2L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="defaultControl_+3A_target">target</code></td>
<td>
<p>the target variable.</p>
</td></tr>
<tr><td><code id="defaultControl_+3A_method">method</code></td>
<td>
<p>the method to use for trainControl.</p>
</td></tr>
<tr><td><code id="defaultControl_+3A_number">number</code></td>
<td>
<p>the number of folds to use.</p>
</td></tr>
<tr><td><code id="defaultControl_+3A_savepredictions">savePredictions</code></td>
<td>
<p>the type of predictions to save.</p>
</td></tr>
<tr><td><code id="defaultControl_+3A_index">index</code></td>
<td>
<p>the fold indexes to use.</p>
</td></tr>
<tr><td><code id="defaultControl_+3A_is_class">is_class</code></td>
<td>
<p>logical, is this a classification or regression problem.</p>
</td></tr>
<tr><td><code id="defaultControl_+3A_is_binary">is_binary</code></td>
<td>
<p>logical, is this binary classification.</p>
</td></tr>
<tr><td><code id="defaultControl_+3A_...">...</code></td>
<td>
<p>other arguments to pass to <code><a href="caret.html#topic+trainControl">trainControl</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='defaultMetric'>Construct a default metric</h2><span id='topic+defaultMetric'></span>

<h3>Description</h3>

<p>Caret defaults to RMSE for classification and RMSE for regression.
For classification, I would rather use ROC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>defaultMetric(is_class, is_binary)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="defaultMetric_+3A_is_class">is_class</code></td>
<td>
<p>logical, is this a classification or regression problem.</p>
</td></tr>
<tr><td><code id="defaultMetric_+3A_is_binary">is_binary</code></td>
<td>
<p>logical, is this binary classification.</p>
</td></tr>
</table>

<hr>
<h2 id='dotplot.caretStack'>Comparison dotplot for a caretStack object</h2><span id='topic+dotplot.caretStack'></span>

<h3>Description</h3>

<p>This is a function to make a dotplot from a caretStack. It uses dotplot from the
caret package on all the models in the ensemble, excluding the final ensemble model.At the moment,
this function only works if the ensembling model has the same number of resamples as the component models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'caretStack'
dotplot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dotplot.caretStack_+3A_x">x</code></td>
<td>
<p>An object of class caretStack</p>
</td></tr>
<tr><td><code id="dotplot.caretStack_+3A_...">...</code></td>
<td>
<p>passed to dotplot</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
models &lt;- caretList(
  x = iris[1:100, 1:2],
  y = iris[1:100, 3],
  methodList = c("rpart", "glm")
)
meta_model &lt;- caretStack(models, method = "lm")
lattice::dotplot(meta_model)
</code></pre>

<hr>
<h2 id='dropExcludedClass'>Drop Excluded Class</h2><span id='topic+dropExcludedClass'></span>

<h3>Description</h3>

<p>Drop the excluded class from a prediction data.table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dropExcludedClass(x, all_classes, excluded_class_id)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dropExcludedClass_+3A_x">x</code></td>
<td>
<p>a data.table of predictions</p>
</td></tr>
<tr><td><code id="dropExcludedClass_+3A_all_classes">all_classes</code></td>
<td>
<p>a character vector of all classes</p>
</td></tr>
<tr><td><code id="dropExcludedClass_+3A_excluded_class_id">excluded_class_id</code></td>
<td>
<p>an integer indicating the class to exclude</p>
</td></tr>
</table>

<hr>
<h2 id='extractBestPreds'>Extract the best predictions from a train object</h2><span id='topic+extractBestPreds'></span>

<h3>Description</h3>

<p>Extract the best predictions from a train object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractBestPreds(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractBestPreds_+3A_x">x</code></td>
<td>
<p>a train object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.table::data.table with predictions
</p>

<hr>
<h2 id='extractCaretTarget'>Extracts the target variable from a set of arguments headed to the caret::train function.</h2><span id='topic+extractCaretTarget'></span>

<h3>Description</h3>

<p>This function extracts the y variable from a set of arguments headed to a caret::train model.
Since there are 2 methods to call caret::train, this function also has 2 methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractCaretTarget(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractCaretTarget_+3A_...">...</code></td>
<td>
<p>a set of arguments, as in the caret::train function</p>
</td></tr>
</table>

<hr>
<h2 id='extractCaretTarget.default'>Extracts the target variable from a set of arguments headed to the caret::train.default function.</h2><span id='topic+extractCaretTarget.default'></span>

<h3>Description</h3>

<p>This function extracts the y variable from a set of arguments headed to a caret::train.default model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
extractCaretTarget(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractCaretTarget.default_+3A_x">x</code></td>
<td>
<p>an object where samples are in rows and features are in columns. This could be a simple matrix, data frame
or other type (e.g. sparse matrix). See Details below.</p>
</td></tr>
<tr><td><code id="extractCaretTarget.default_+3A_y">y</code></td>
<td>
<p>a numeric or factor vector containing the outcome for each sample.</p>
</td></tr>
<tr><td><code id="extractCaretTarget.default_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='extractCaretTarget.formula'>Extracts the target variable from a set of arguments headed to the caret::train.formula function.</h2><span id='topic+extractCaretTarget.formula'></span>

<h3>Description</h3>

<p>This function extracts the y variable from a set of arguments headed to a caret::train.formula model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
extractCaretTarget(form, data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractCaretTarget.formula_+3A_form">form</code></td>
<td>
<p>A formula of the form y ~ x1 + x2 + ...</p>
</td></tr>
<tr><td><code id="extractCaretTarget.formula_+3A_data">data</code></td>
<td>
<p>Data frame from which variables specified in formula are preferentially to be taken.</p>
</td></tr>
<tr><td><code id="extractCaretTarget.formula_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='extractMetric'>Generic function to extract accuracy metrics from various model objects</h2><span id='topic+extractMetric'></span>

<h3>Description</h3>

<p>A generic function to extract cross-validated accuracy metrics from model objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractMetric(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractMetric_+3A_x">x</code></td>
<td>
<p>An object from which to extract metrics.
The specific method will be dispatched based on the class of <code>x</code>.</p>
</td></tr>
<tr><td><code id="extractMetric_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the specific methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="data.table.html#topic+data.table">data.table</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extractMetric.train">extractMetric.train</a></code>,
<code><a href="#topic+extractMetric.caretList">extractMetric.caretList</a></code>,
<code><a href="#topic+extractMetric.caretStack">extractMetric.caretStack</a></code>
</p>

<hr>
<h2 id='extractMetric.caretList'>Extract accuracy metrics from a <code><a href="#topic+caretList">caretList</a></code> object</h2><span id='topic+extractMetric.caretList'></span>

<h3>Description</h3>

<p>Extract the cross-validated accuracy metrics from each model in a caretList.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'caretList'
extractMetric(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractMetric.caretList_+3A_x">x</code></td>
<td>
<p>a caretList object</p>
</td></tr>
<tr><td><code id="extractMetric.caretList_+3A_...">...</code></td>
<td>
<p>passed to extractMetric.train</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table with metrics from each model.
</p>

<hr>
<h2 id='extractMetric.caretStack'>Extract accuracy metrics from a <code><a href="#topic+caretStack">caretStack</a></code> object</h2><span id='topic+extractMetric.caretStack'></span>

<h3>Description</h3>

<p>Extract the cross-validated accuracy metrics from the ensemble model
and individual models in a caretStack.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'caretStack'
extractMetric(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractMetric.caretStack_+3A_x">x</code></td>
<td>
<p>a caretStack object</p>
</td></tr>
<tr><td><code id="extractMetric.caretStack_+3A_...">...</code></td>
<td>
<p>passed to extractMetric.train and extractMetric.caretList</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table with metrics from the ensemble model and individual models.
</p>

<hr>
<h2 id='extractMetric.train'>Extract accuracy metrics from a <code><a href="caret.html#topic+train">train</a></code> model</h2><span id='topic+extractMetric.train'></span>

<h3>Description</h3>

<p>Extract the cross-validated accuracy metrics and their SDs from caret.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'train'
extractMetric(x, metric = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractMetric.train_+3A_x">x</code></td>
<td>
<p>a train object</p>
</td></tr>
<tr><td><code id="extractMetric.train_+3A_metric">metric</code></td>
<td>
<p>a character string representing the metric to extract.</p>
</td></tr>
<tr><td><code id="extractMetric.train_+3A_...">...</code></td>
<td>
<p>ignored
If NULL, uses the metric that was used to train the model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric representing the metric desired metric.
</p>

<hr>
<h2 id='extractModelName'>Extract the method name associated with a single train object</h2><span id='topic+extractModelName'></span>

<h3>Description</h3>

<p>Extracts the method name associated with a single train object. Note
that for standard models (i.e. those already prespecified by caret), the
&quot;method&quot; attribute on the train object is used directly while for custom
models the &quot;method&quot; attribute within the model$modelInfo attribute is
used instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractModelName(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractModelName_+3A_x">x</code></td>
<td>
<p>a single caret train object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Name associated with model
</p>

<hr>
<h2 id='greedyMSE'>Greedy optimization for MSE</h2><span id='topic+greedyMSE'></span>

<h3>Description</h3>

<p>Greedy optimization for minimizing the mean squared error.
Works for classification and regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>greedyMSE(X, Y, max_iter = 100L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="greedyMSE_+3A_x">X</code></td>
<td>
<p>A numeric matrix of features.</p>
</td></tr>
<tr><td><code id="greedyMSE_+3A_y">Y</code></td>
<td>
<p>A numeric matrix of target values.</p>
</td></tr>
<tr><td><code id="greedyMSE_+3A_max_iter">max_iter</code></td>
<td>
<p>An integer scalar of the maximum number of iterations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components:
</p>
<table role = "presentation">
<tr><td><code>model_weights</code></td>
<td>
<p>A numeric matrix of model_weights.</p>
</td></tr>
<tr><td><code>RMSE</code></td>
<td>
<p>A numeric scalar of the root mean squared error.</p>
</td></tr>
<tr><td><code>max_iter</code></td>
<td>
<p>An integer scalar of the maximum number of iterations.</p>
</td></tr>
</table>

<hr>
<h2 id='greedyMSE_caret'>caret interface for greedyMSE</h2><span id='topic+greedyMSE_caret'></span>

<h3>Description</h3>

<p>caret interface for greedyMSE. greedyMSE works
well when you want an ensemble that will never be worse than any single predictor
in the dataset. It does not use an intercept and it does not allow for
negative coefficients. This makes it highly constrained and in general
does not work well on standard classification and regression problems.
However, it does work well in the case of:
* The predictors are highly correlated with each other
* The predictors are highly correlated with the model
* You expect or want positive only coefficients
In the worse case, this method will select one input and use that,
but in many other cases it will return a positive, weighted average
of the inputs. Since it never uses negative weights, you never get
into a scenario where one model is weighted negative and on new data
you get were predictions because a correlation changed.
Since this model will always be a positive weighted average of the inputs,
it will rarely do worse than the individual models on new data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>greedyMSE_caret()
</code></pre>

<hr>
<h2 id='isClassifier'>Is Classifier</h2><span id='topic+isClassifier'></span>

<h3>Description</h3>

<p>Check if a model is a classifier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isClassifier(model)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isClassifier_+3A_model">model</code></td>
<td>
<p>A train object from the caret package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical indicating whether the model is a classifier.
</p>

<hr>
<h2 id='isClassifierAndValidate'>Validate a model type</h2><span id='topic+isClassifierAndValidate'></span>

<h3>Description</h3>

<p>Validate the model type from a <code><a href="caret.html#topic+train">train</a></code> object.
For classification, validates that the model can predict probabilities, and,
if stacked predictions are requested, that classProbs = TRUE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isClassifierAndValidate(object, validate_for_stacking = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isClassifierAndValidate_+3A_object">object</code></td>
<td>
<p>a <code><a href="caret.html#topic+train">train</a></code> object</p>
</td></tr>
<tr><td><code id="isClassifierAndValidate_+3A_validate_for_stacking">validate_for_stacking</code></td>
<td>
<p>a logical indicating whether to validate the object for stacked predictions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical. TRUE if classifier, otherwise FALSE.
</p>

<hr>
<h2 id='mae'>Compute MAE</h2><span id='topic+mae'></span>

<h3>Description</h3>

<p>Compute the mean absolute error between two vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mae(a, b)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mae_+3A_a">a</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="mae_+3A_b">b</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric scalar.
</p>

<hr>
<h2 id='methodCheck'>Check that the methods supplied by the user are valid caret methods</h2><span id='topic+methodCheck'></span>

<h3>Description</h3>

<p>This function uses modelLookup from caret to ensure the list of
methods supplied by the user are all models caret can fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>methodCheck(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="methodCheck_+3A_x">x</code></td>
<td>
<p>a list of user-supplied tuning parameters and methods</p>
</td></tr>
</table>

<hr>
<h2 id='models.class'>caretList of classification models</h2><span id='topic+models.class'></span>

<h3>Description</h3>

<p>Data for the caretEnsemble package
</p>


<h3>Author(s)</h3>

<p>Zachary Deane-Mayer <a href="mailto:zach.mayer@gmail.com">zach.mayer@gmail.com</a>
</p>

<hr>
<h2 id='models.reg'>caretList of regression models</h2><span id='topic+models.reg'></span>

<h3>Description</h3>

<p>caretList of regression models
</p>


<h3>Author(s)</h3>

<p>Zachary Deane-Mayer <a href="mailto:zach.mayer@gmail.com">zach.mayer@gmail.com</a>
</p>

<hr>
<h2 id='normalize_to_one'>Normalize to One</h2><span id='topic+normalize_to_one'></span>

<h3>Description</h3>

<p>Normalize a vector to sum to one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize_to_one(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normalize_to_one_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector.
</p>

<hr>
<h2 id='permutationImportance'>Permutation Importance</h2><span id='topic+permutationImportance'></span>

<h3>Description</h3>

<p>Permute each variable in a dataset and use the change in predictions to
calculate the importance of each variable. Based on the scikit learn implementation
of permutation importance: <a href="https://scikit-learn.org/stable/modules/permutation_importance.html">https://scikit-learn.org/stable/modules/permutation_importance.html</a>.
However, we don't compare to the target by a metric. We JUST look at the change in the
model's predictions, as measured by MAE. (for classification, this is like using a Brier score).
We shuffle each variable and recompute the predictions before and after the shuffle.
The difference in MAE. is the importance of that variable. We normalize by computing the MAE of the shuffled
original predictions as an upper bound on the MAE and divide by this value.
So a variable that, when shuffled, caused predictions as bad as shuffling the output
predictions, we know that variable is 100
Similarly, as with regular permutation importance, a variable that, when shuffled,
gives the same MAE as the original model has an importance of 0.
</p>
<p>This method cannot yield negative importances. It is merely a measure of how much the models uses
the variable, and does not tell you which variables help or hurt generalization. Use the model's
cross-validated metrics to assess generalization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permutationImportance(model, newdata, normalize = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="permutationImportance_+3A_model">model</code></td>
<td>
<p>A train object from the caret package.</p>
</td></tr>
<tr><td><code id="permutationImportance_+3A_newdata">newdata</code></td>
<td>
<p>A data.frame of new data to use to compute importances. Can be the training data.</p>
</td></tr>
<tr><td><code id="permutationImportance_+3A_normalize">normalize</code></td>
<td>
<p>A logical indicating whether to normalize the importances to sum to one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named numeric vector of variable importances.
</p>

<hr>
<h2 id='plot.caretList'>Plot a caretList object</h2><span id='topic+plot.caretList'></span>

<h3>Description</h3>

<p>This function plots the performance of each model in a caretList object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'caretList'
plot(x, metric = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.caretList_+3A_x">x</code></td>
<td>
<p>a caretList object</p>
</td></tr>
<tr><td><code id="plot.caretList_+3A_metric">metric</code></td>
<td>
<p>which metric to plot</p>
</td></tr>
<tr><td><code id="plot.caretList_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object
</p>

<hr>
<h2 id='plot.caretStack'>Plot a caretStack object</h2><span id='topic+plot.caretStack'></span>

<h3>Description</h3>

<p>This function plots the performance of each model in a caretList object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'caretStack'
plot(x, metric = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.caretStack_+3A_x">x</code></td>
<td>
<p>a caretStack object</p>
</td></tr>
<tr><td><code id="plot.caretStack_+3A_metric">metric</code></td>
<td>
<p>which metric to plot. If NULL, will use the default metric used to train the model.</p>
</td></tr>
<tr><td><code id="plot.caretStack_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a ggplot2 object
</p>

<hr>
<h2 id='predict.caretList'>Create a matrix of predictions for each of the models in a caretList</h2><span id='topic+predict.caretList'></span>

<h3>Description</h3>

<p>Make a matrix of predictions from a list of caret models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'caretList'
predict(object, newdata = NULL, verbose = FALSE, excluded_class_id = 1L, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.caretList_+3A_object">object</code></td>
<td>
<p>an object of class caretList</p>
</td></tr>
<tr><td><code id="predict.caretList_+3A_newdata">newdata</code></td>
<td>
<p>New data for predictions. It can be NULL, but this is ill-advised.</p>
</td></tr>
<tr><td><code id="predict.caretList_+3A_verbose">verbose</code></td>
<td>
<p>Logical. If FALSE no progress bar is printed if TRUE a progress
bar is shown. Default FALSE.</p>
</td></tr>
<tr><td><code id="predict.caretList_+3A_excluded_class_id">excluded_class_id</code></td>
<td>
<p>Integer. The class id to drop when predicting for multiclass</p>
</td></tr>
<tr><td><code id="predict.caretList_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to <code><a href="caret.html#topic+predict.train">predict.train</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='predict.caretStack'>Make predictions from a caretStack</h2><span id='topic+predict.caretStack'></span>

<h3>Description</h3>

<p>Make predictions from a caretStack. This function passes the data to each function in
turn to make a matrix of predictions, and then multiplies that matrix by the vector of
weights to get a single, combined vector of predictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'caretStack'
predict(
  object,
  newdata = NULL,
  se = FALSE,
  level = 0.95,
  excluded_class_id = 0L,
  return_class_only = FALSE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.caretStack_+3A_object">object</code></td>
<td>
<p>a  <code><a href="#topic+caretStack">caretStack</a></code> to make predictions from.</p>
</td></tr>
<tr><td><code id="predict.caretStack_+3A_newdata">newdata</code></td>
<td>
<p>a new dataframe to make predictions on</p>
</td></tr>
<tr><td><code id="predict.caretStack_+3A_se">se</code></td>
<td>
<p>logical, should prediction errors be produced? Default is false.</p>
</td></tr>
<tr><td><code id="predict.caretStack_+3A_level">level</code></td>
<td>
<p>tolerance/confidence level
should be returned</p>
</td></tr>
<tr><td><code id="predict.caretStack_+3A_excluded_class_id">excluded_class_id</code></td>
<td>
<p>Which class to exclude from predictions. Note that if the caretStack
was trained with an excluded_class_id, that class is ALWAYS excluded from the predictions from the
caretList of input models. excluded_class_id for predict.caretStack is for the final ensemble model.
So different classes could be excluded from the caretList models and the final ensemble model.</p>
</td></tr>
<tr><td><code id="predict.caretStack_+3A_return_class_only">return_class_only</code></td>
<td>
<p>a logical indicating whether to return only the class predictions as a factor.
If TRUE, the return will be a factor rather than a data.table. This is a convenience function,
and should not be widely used. For example if you have a downstream process that consumes
the output of the model, you should have that process consume probabilities for each class.
This will make it easier to change prediction probability thresholds if needed in the future.</p>
</td></tr>
<tr><td><code id="predict.caretStack_+3A_verbose">verbose</code></td>
<td>
<p>a logical indicating whether to print progress</p>
</td></tr>
<tr><td><code id="predict.caretStack_+3A_...">...</code></td>
<td>
<p>arguments to pass to <code><a href="caret.html#topic+predict.train">predict.train</a></code> for the ensemble model.
Do not specify type here. For classification, type will always be prob, and for regression, type will always be raw.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prediction weights are defined as variable importance in the stacked
caret model. This is not available for all cases such as where the library
model predictions are transformed before being passed to the stacking model.
</p>


<h3>Value</h3>

<p>a data.table of predictions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>models &lt;- caretList(
  x = iris[1:100, 1:2],
  y = iris[1:100, 3],
  methodList = c("rpart", "glm")
)
meta_model &lt;- caretStack(models, method = "lm")
RMSE(predict(meta_model, iris[101:150, 1:2]), iris[101:150, 3])
</code></pre>

<hr>
<h2 id='predict.greedyMSE'>Predict method for greedyMSE</h2><span id='topic+predict.greedyMSE'></span>

<h3>Description</h3>

<p>Predict method for greedyMSE objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'greedyMSE'
predict(object, newdata, return_labels = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.greedyMSE_+3A_object">object</code></td>
<td>
<p>A greedyMSE object.</p>
</td></tr>
<tr><td><code id="predict.greedyMSE_+3A_newdata">newdata</code></td>
<td>
<p>A numeric matrix of new data.</p>
</td></tr>
<tr><td><code id="predict.greedyMSE_+3A_return_labels">return_labels</code></td>
<td>
<p>A logical scalar of whether to return labels.</p>
</td></tr>
<tr><td><code id="predict.greedyMSE_+3A_...">...</code></td>
<td>
<p>Additional arguments. Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix of predictions.
</p>

<hr>
<h2 id='print.caretStack'>Print a caretStack object</h2><span id='topic+print.caretStack'></span>

<h3>Description</h3>

<p>This is a function to print a caretStack.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'caretStack'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.caretStack_+3A_x">x</code></td>
<td>
<p>An object of class caretStack</p>
</td></tr>
<tr><td><code id="print.caretStack_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>models &lt;- caretList(
  x = iris[1:100, 1:2],
  y = iris[1:100, 3],
  methodList = c("rpart", "glm")
)
meta_model &lt;- caretStack(models, method = "lm")
print(meta_model)
</code></pre>

<hr>
<h2 id='print.greedyMSE'>Print method for greedyMSE</h2><span id='topic+print.greedyMSE'></span>

<h3>Description</h3>

<p>Print method for greedyMSE objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'greedyMSE'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.greedyMSE_+3A_x">x</code></td>
<td>
<p>A greedyMSE object.</p>
</td></tr>
<tr><td><code id="print.greedyMSE_+3A_...">...</code></td>
<td>
<p>Additional arguments. Ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='print.summary.caretList'>Print a summary.caretList object</h2><span id='topic+print.summary.caretList'></span>

<h3>Description</h3>

<p>This is a function to print a summary.caretList
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.caretList'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.caretList_+3A_x">x</code></td>
<td>
<p>An object of class summary.caretList</p>
</td></tr>
<tr><td><code id="print.summary.caretList_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='print.summary.caretStack'>Print a summary.caretStack object</h2><span id='topic+print.summary.caretStack'></span>

<h3>Description</h3>

<p>This is a function to print a summary.caretStack.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.caretStack'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.summary.caretStack_+3A_x">x</code></td>
<td>
<p>An object of class summary.caretStack</p>
</td></tr>
<tr><td><code id="print.summary.caretStack_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>

<hr>
<h2 id='set_excluded_class_id'>Set excluded class id</h2><span id='topic+set_excluded_class_id'></span>

<h3>Description</h3>

<p>Set the excluded class id for a caretStack object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_excluded_class_id(object, is_class)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_excluded_class_id_+3A_object">object</code></td>
<td>
<p>a caretStack object</p>
</td></tr>
<tr><td><code id="set_excluded_class_id_+3A_is_class">is_class</code></td>
<td>
<p>the model type as a logical vector with length 1</p>
</td></tr>
</table>

<hr>
<h2 id='shuffled_mae'>Shuffled MAE</h2><span id='topic+shuffled_mae'></span>

<h3>Description</h3>

<p>Compute the mean absolute error of a model's predictions when a variable is shuffled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shuffled_mae(model, original_data, target, pred_type, shuffle_idx)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shuffled_mae_+3A_original_data">original_data</code></td>
<td>
<p>A data.table of the original data.</p>
</td></tr>
<tr><td><code id="shuffled_mae_+3A_target">target</code></td>
<td>
<p>A matrix of target values.</p>
</td></tr>
<tr><td><code id="shuffled_mae_+3A_shuffle_idx">shuffle_idx</code></td>
<td>
<p>A vector of shuffled indices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of mean absolute errors.
</p>

<hr>
<h2 id='stackedTrainResiduals'>Extracted stacked residuals for the autoplot</h2><span id='topic+stackedTrainResiduals'></span>

<h3>Description</h3>

<p>This function extracts the predictions, observeds, and residuals from a <code>train</code> object.
It uses the object's stacked predictions from cross-validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stackedTrainResiduals(object, show_class_id = 2L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stackedTrainResiduals_+3A_object">object</code></td>
<td>
<p>a <code>train</code> object</p>
</td></tr>
<tr><td><code id="stackedTrainResiduals_+3A_show_class_id">show_class_id</code></td>
<td>
<p>For classification only: which class level to use for residuals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.table::data.table with predictions, observeds, and residuals
</p>

<hr>
<h2 id='summary.caretList'>Summarize a caretList</h2><span id='topic+summary.caretList'></span>

<h3>Description</h3>

<p>This function summarizes the performance of each model in a caretList object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'caretList'
summary(object, metric = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.caretList_+3A_object">object</code></td>
<td>
<p>a caretList object</p>
</td></tr>
<tr><td><code id="summary.caretList_+3A_metric">metric</code></td>
<td>
<p>The metric to show. If NULL will use the metric used to train each model</p>
</td></tr>
<tr><td><code id="summary.caretList_+3A_...">...</code></td>
<td>
<p>passed to extractMetric</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table with metrics from each model.
</p>

<hr>
<h2 id='summary.caretStack'>Summarize a caretStack object</h2><span id='topic+summary.caretStack'></span>

<h3>Description</h3>

<p>This is a function to summarize a caretStack.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'caretStack'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.caretStack_+3A_object">object</code></td>
<td>
<p>An object of class caretStack</p>
</td></tr>
<tr><td><code id="summary.caretStack_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>models &lt;- caretList(
  x = iris[1:100, 1:2],
  y = iris[1:100, 3],
  methodList = c("rpart", "glm")
)
meta_model &lt;- caretStack(models, method = "lm")
summary(meta_model)
</code></pre>

<hr>
<h2 id='tuneCheck'>Check that the tuning parameters list supplied by the user is valid</h2><span id='topic+tuneCheck'></span>

<h3>Description</h3>

<p>This function makes sure the tuning parameters passed by the user
are valid and have the proper naming, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tuneCheck(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tuneCheck_+3A_x">x</code></td>
<td>
<p>a list of user-supplied tuning parameters and methods</p>
</td></tr>
</table>

<hr>
<h2 id='validateExcludedClass'>Validate the excluded class</h2><span id='topic+validateExcludedClass'></span>

<h3>Description</h3>

<p>Helper function to ensure that the excluded level for classification is an integer.
Set to 0L to exclude no class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validateExcludedClass(arg)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validateExcludedClass_+3A_arg">arg</code></td>
<td>
<p>The value to check</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer
</p>

<hr>
<h2 id='varImp.caretStack'>Variable importance for caretStack</h2><span id='topic+varImp.caretStack'></span>

<h3>Description</h3>

<p>This is a function to extract variable importance from a caretStack.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'caretStack'
varImp(object, newdata = NULL, normalize = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="varImp.caretStack_+3A_object">object</code></td>
<td>
<p>An object of class caretStack</p>
</td></tr>
<tr><td><code id="varImp.caretStack_+3A_newdata">newdata</code></td>
<td>
<p>the data to use for computing importance. If NULL, will use the stacked predictions from the models.</p>
</td></tr>
<tr><td><code id="varImp.caretStack_+3A_normalize">normalize</code></td>
<td>
<p>a logical indicating whether to normalize the importances to sum to one.</p>
</td></tr>
<tr><td><code id="varImp.caretStack_+3A_...">...</code></td>
<td>
<p>passed to predict.caretList</p>
</td></tr>
</table>

<hr>
<h2 id='varImp.greedyMSE'>variable importance for a greedyMSE model</h2><span id='topic+varImp.greedyMSE'></span>

<h3>Description</h3>

<p>Variable importance for a greedyMSE model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'greedyMSE'
varImp(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="varImp.greedyMSE_+3A_object">object</code></td>
<td>
<p>A greedyMSE object.</p>
</td></tr>
<tr><td><code id="varImp.greedyMSE_+3A_...">...</code></td>
<td>
<p>Additional arguments. Ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='wtd.sd'>Calculate a weighted standard deviation</h2><span id='topic+wtd.sd'></span>

<h3>Description</h3>

<p>Used to weight deviations among ensembled model predictions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wtd.sd(x, w, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wtd.sd_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="wtd.sd_+3A_w">w</code></td>
<td>
<p>a vector of weights equal to length of x</p>
</td></tr>
<tr><td><code id="wtd.sd_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical indicating how to handle missing values, default = TRUE</p>
</td></tr>
</table>

<hr>
<h2 id='X.class'>data for classification</h2><span id='topic+X.class'></span>

<h3>Description</h3>

<p>data for classification
</p>


<h3>Author(s)</h3>

<p>Zachary Deane-Mayer <a href="mailto:zach.mayer@gmail.com">zach.mayer@gmail.com</a>
</p>

<hr>
<h2 id='X.reg'>data for classification</h2><span id='topic+X.reg'></span>

<h3>Description</h3>

<p>data for classification
</p>


<h3>Author(s)</h3>

<p>Zachary Deane-Mayer <a href="mailto:zach.mayer@gmail.com">zach.mayer@gmail.com</a>
</p>

<hr>
<h2 id='Y.class'>data for classification</h2><span id='topic+Y.class'></span>

<h3>Description</h3>

<p>data for classification
</p>

<hr>
<h2 id='Y.reg'>data for regression</h2><span id='topic+Y.reg'></span>

<h3>Description</h3>

<p>data for regression
</p>


<h3>Author(s)</h3>

<p>Zachary Deane-Mayer <a href="mailto:zach.mayer@gmail.com">zach.mayer@gmail.com</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
