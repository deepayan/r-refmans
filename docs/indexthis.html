<!DOCTYPE html><html><head><title>Help for package indexthis</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {indexthis}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#to_index'><p>Turns one or multiple vectors into an index (aka group id, aka key)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Quick Indexation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp(&ge; 1.0.5)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/lrberge/indexthis">https://github.com/lrberge/indexthis</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.5.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>Quick indexation of any type of vector or of any combination of those. Indexation turns a vector into an integer vector going from 1 to the number of unique elements. Indexes are important building blocks for many algorithms. The method is described at <a href="https://github.com/lrberge/indexthis/">https://github.com/lrberge/indexthis/</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-01 09:57:48 UTC; lrberge</td>
</tr>
<tr>
<td>Author:</td>
<td>Laurent Berge [aut, cre],
  Sebastian Krantz [ctb],
  Morgan Jacob [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Laurent Berge &lt;laurent.berge@u-bordeaux.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-01 17:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='to_index'>Turns one or multiple vectors into an index (aka group id, aka key)</h2><span id='topic+to_index'></span>

<h3>Description</h3>

<p>Turns one or multiple vectors of the same length into an index, that is an integer vector
of the same length ranging from 1 to the number of unique elements in the vectors.
This is equivalent to creating a key.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_index(
  ...,
  list = NULL,
  sorted = FALSE,
  items = FALSE,
  items.simplify = TRUE,
  internal = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_index_+3A_...">...</code></td>
<td>
<p>The vectors to be turned into an index. Only works for atomic vectors.
If multiple vectors are provided, they should all be of the same length. Notes that
you can alternatively provide a list of vectors with the argument <code>list</code>.</p>
</td></tr>
<tr><td><code id="to_index_+3A_list">list</code></td>
<td>
<p>An alternative to using <code>...</code> to pass the input vectors. If provided, it
should be a list of atomic vectors, all of the same length. If this argument is provided,
then <code>...</code> is ignored.</p>
</td></tr>
<tr><td><code id="to_index_+3A_sorted">sorted</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. By default the index order is based on
the order of occurence. Values occurring before have lower index values. Use <code>sorted=TRUE</code>
to have the index to be sorted based on the vector values. For example <code>c(7, 3, 7, -8)</code> will be
turned into <code>c(1, 2, 1, 3)</code> if <code>sorted=FALSE</code> and into <code>c(3, 2, 3, 1)</code> is <code>sorted=TRUE</code>.</p>
</td></tr>
<tr><td><code id="to_index_+3A_items">items</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. Whether to return the input values the indexes
refer to. If <code>TRUE</code>, a list of two elements, named <code>index</code> and <code>items</code>, is returned.
The <code>items</code> object is a data.frame containing the values of the input vectors corresponding
to the index. Note that if there is only one input vector and <code>items.simplify=TRUE</code> (default),
then <code>items</code> is a vector instead of a data.frame.</p>
</td></tr>
<tr><td><code id="to_index_+3A_items.simplify">items.simplify</code></td>
<td>
<p>Logical scalar, default is <code>TRUE</code>. Only used if the values
from the input vectors are returned with <code>items=TRUE</code>. If there is only one input vector,
the <code>items</code> is a vector if <code>items.simplify=TRUE</code>, and a data.frame otherwise.</p>
</td></tr>
<tr><td><code id="to_index_+3A_internal">internal</code></td>
<td>
<p>Logical, default is <code>FALSE</code>. If <code>TRUE</code>, some checks on the data are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm to create the indexes is based on a semi-hashing of the vectors in input.
The hash table is of size <code>2 * n</code>, with <code>n</code> the number of observations. Hence
the hash of all values is partial in order to fit that range. That is to say a
32 bits hash is turned into a <code>log2(2 * n)</code> bits hash simply by shifting the bits.
This in turn will necessarily
lead to multiple collisions (ie different values leading to the same hash). This
is why collisions are checked systematically, guaranteeing the validity of the resulting index.
</p>
<p>Note that <code>NA</code> values are considered as valid and will not be returned as <code>NA</code> in the index.
When indexing numeric vectors, there is no distinction between <code>NA</code> and <code>NaN</code>.
</p>
<p>The algorithm is optimized for input vectors of type: i) numeric or integer (and equivalent
data structures, like, e.g., dates), ii) logicals,
iii) factors, and iv) character.
The algorithm will be slow for types different from the ones previously mentioned,
since a conversion to character will first be applied before indexing.
</p>


<h3>Value</h3>

<p>By default, an integer vector is returned, of the same length as the inputs.
</p>
<p>If you are interested in the values the indexes (i.e. the integer values) refer to, you can
use the argument <code>items = TRUE</code>. In that case, a list of two elements, named <code>index</code>
and <code>items</code>, is returned. The <code>index</code> is the integer vector representing the index, and
the <code>items</code> is a data.frame containing the input values the index refers to.
</p>
<p>Note that if <code>items = TRUE</code> and <code>items.simplify = TRUE</code> and there is only one vector
in input, the <code>items</code> slot of the returned object will be equal to a vector.
</p>


<h3>Author(s)</h3>

<p>Laurent Berge for this original implementation, Morgan Jacob (author of <code>kit</code>) and Sebastian
Krantz (author of <code>collapse</code>) for the hashing idea.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = c("u", "a", "a", "s", "u", "u")
y = c(  5,   5,   5,   3,   3,   7)

# By default, the index value is based on order of occurrence
to_index(x)
to_index(y)
to_index(x, y)

# Use the order of the input values with sorted=TRUE
to_index(x, sorted = TRUE)
to_index(y, sorted = TRUE)
to_index(x, y, sorted = TRUE)

# To get the values to which the index refer, use items=TRUE
to_index(x, items = TRUE)

# play around with the format of the output
to_index(x, items = TRUE, items.simplify = TRUE)   # =&gt; default
to_index(x, items = TRUE, items.simplify = FALSE)

# multiple items are always in a data.frame
to_index(x, y, items = TRUE)

# NAs are considered as valid
x_NA = c("u", NA, "a", "a", "s", "u", "u")
to_index(x_NA, items = TRUE)
to_index(x_NA, items = TRUE, sorted = TRUE)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
