<!DOCTYPE html><html><head><title>Help for package GauPro</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GauPro}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+2A.GauPro_kernel'><p>Kernel product</p></a></li>
<li><a href='#+2B.GauPro_kernel'><p>Kernel sum</p></a></li>
<li><a href='#arma_mult_cube_vec'><p>Cube multiply over first dimension</p></a></li>
<li><a href='#corr_cubic_matrix_symC'><p>Correlation Cubic matrix in C (symmetric)</p></a></li>
<li><a href='#corr_exponential_matrix_symC'><p>Correlation Gaussian matrix in C (symmetric)</p></a></li>
<li><a href='#corr_gauss_dCdX'><p>Correlation Gaussian matrix gradient in C using Armadillo</p></a></li>
<li><a href='#corr_gauss_matrix'><p>Gaussian correlation</p></a></li>
<li><a href='#corr_gauss_matrix_armaC'><p>Correlation Gaussian matrix in C using Armadillo</p></a></li>
<li><a href='#corr_gauss_matrix_sym_armaC'><p>Correlation Gaussian matrix in C using Armadillo (symmetric)</p></a></li>
<li><a href='#corr_gauss_matrix_symC'><p>Correlation Gaussian matrix in C (symmetric)</p></a></li>
<li><a href='#corr_gauss_matrixC'><p>Correlation Gaussian matrix in C using Rcpp</p></a></li>
<li><a href='#corr_latentfactor_matrix_symC'><p>Correlation Latent factor  matrix in C (symmetric)</p></a></li>
<li><a href='#corr_latentfactor_matrixmatrixC'><p>Correlation Latent factor  matrix in C (symmetric)</p></a></li>
<li><a href='#corr_matern32_matrix_symC'><p>Correlation Matern 3/2 matrix in C (symmetric)</p></a></li>
<li><a href='#corr_matern52_matrix_symC'><p>Correlation Gaussian matrix in C (symmetric)</p></a></li>
<li><a href='#corr_orderedfactor_matrix_symC'><p>Correlation ordered factor  matrix in C (symmetric)</p></a></li>
<li><a href='#corr_orderedfactor_matrixmatrixC'><p>Correlation ordered factor matrix in C (symmetric)</p></a></li>
<li><a href='#Cubic'><p>Cubic Kernel R6 class</p></a></li>
<li><a href='#Exponential'><p>Exponential Kernel R6 class</p></a></li>
<li><a href='#FactorKernel'><p>Factor Kernel R6 class</p></a></li>
<li><a href='#GauPro'><p>GauPro_selector</p></a></li>
<li><a href='#GauPro_base'><p>Class providing object with methods for fitting a GP model</p></a></li>
<li><a href='#GauPro_Gauss'><p>Corr Gauss GP using inherited optim</p></a></li>
<li><a href='#GauPro_Gauss_LOO'><p>Corr Gauss GP using inherited optim</p></a></li>
<li><a href='#GauPro_kernel'><p>Kernel R6 class</p></a></li>
<li><a href='#GauPro_kernel_beta'><p>Beta Kernel R6 class</p></a></li>
<li><a href='#GauPro_kernel_model'><p>Gaussian process model with kernel</p></a></li>
<li><a href='#GauPro_kernel_model_LOO'><p>Corr Gauss GP using inherited optim</p></a></li>
<li><a href='#GauPro_trend'><p>Trend R6 class</p></a></li>
<li><a href='#Gaussian'><p>Gaussian Kernel R6 class</p></a></li>
<li><a href='#Gaussian_devianceC'><p>Calculate the Gaussian deviance in C</p></a></li>
<li><a href='#Gaussian_hessianC'><p>Calculate Hessian for a GP with Gaussian correlation</p></a></li>
<li><a href='#Gaussian_hessianCC'><p>Gaussian hessian in C</p></a></li>
<li><a href='#Gaussian_hessianR'><p>Calculate Hessian for a GP with Gaussian correlation</p></a></li>
<li><a href='#GowerFactorKernel'><p>Gower factor Kernel R6 class</p></a></li>
<li><a href='#gpkm'><p>Gaussian process regression model</p></a></li>
<li><a href='#gradfuncarray'><p>Calculate gradfunc in optimization to speed up.</p>
NEEDS TO APERM dC_dparams
Doesn't need to be exported, should only be useful in functions.</a></li>
<li><a href='#gradfuncarrayR'><p>Calculate gradfunc in optimization to speed up.</p>
NEEDS TO APERM dC_dparams
Doesn't need to be exported, should only be useful in functions.</a></li>
<li><a href='#IgnoreIndsKernel'><p>Kernel R6 class</p></a></li>
<li><a href='#kernel_cubic_dC'><p>Derivative of cubic kernel covariance matrix in C</p></a></li>
<li><a href='#kernel_exponential_dC'><p>Derivative of Matern 5/2 kernel covariance matrix in C</p></a></li>
<li><a href='#kernel_gauss_dC'><p>Derivative of Gaussian kernel covariance matrix in C</p></a></li>
<li><a href='#kernel_latentFactor_dC'><p>Derivative of covariance matrix of X with respect to kernel</p>
parameters for the Latent Factor Kernel</a></li>
<li><a href='#kernel_matern32_dC'><p>Derivative of Matern 5/2 kernel covariance matrix in C</p></a></li>
<li><a href='#kernel_matern52_dC'><p>Derivative of Matern 5/2 kernel covariance matrix in C</p></a></li>
<li><a href='#kernel_orderedFactor_dC'><p>Derivative of covariance matrix of X with respect to kernel</p>
parameters for the Ordered Factor Kernel</a></li>
<li><a href='#kernel_product'><p>Gaussian Kernel R6 class</p></a></li>
<li><a href='#kernel_sum'><p>Gaussian Kernel R6 class</p></a></li>
<li><a href='#LatentFactorKernel'><p>Latent Factor Kernel R6 class</p></a></li>
<li><a href='#Matern32'><p>Matern 3/2 Kernel R6 class</p></a></li>
<li><a href='#Matern52'><p>Matern 5/2 Kernel R6 class</p></a></li>
<li><a href='#OrderedFactorKernel'><p>Ordered Factor Kernel R6 class</p></a></li>
<li><a href='#Periodic'><p>Periodic Kernel R6 class</p></a></li>
<li><a href='#PowerExp'><p>Power Exponential Kernel R6 class</p></a></li>
<li><a href='#predict.GauPro'><p>Predict for class GauPro</p></a></li>
<li><a href='#print.summary.GauPro'><p>Print summary.GauPro</p></a></li>
<li><a href='#RatQuad'><p>Rational Quadratic Kernel R6 class</p></a></li>
<li><a href='#sqrt_matrix'><p>Find the square root of a matrix</p></a></li>
<li><a href='#summary.GauPro'><p>if (F)</p>
# Plot is automatically dispatched, same with print and format
#' Plot for class GauPro
#'
#' @param x Object of class GauPro
#' @param ... Additional parameters
#'
#' @return Nothing
#' @export
#'
#' @examples
#' n &lt;- 12
#' x &lt;- matrix(seq(0,1,length.out = n), ncol=1)
#' y &lt;- sin(2*pi*x) + rnorm(n,0,1e-1)
#' gp &lt;- GauPro(X=x, Z=y, parallel=FALSE)
#' if (requireNamespace(&quot;MASS&quot;, quietly = TRUE))
#'   plot(gp)
#'
#'
plot.GauPro &lt;- function(x,  ...)
x$plot(...)
# if (x$D == 1)
#   x$cool1Dplot(...)
#  else if (x$D == 2)
#   x$plot2D(...)
#  else
#   # stop(&quot;No plot method for higher than 2 dimension&quot;)
#   x$plotmarginal()
#


Summary for GauPro object</a></li>
<li><a href='#trend_0'><p>Trend R6 class</p></a></li>
<li><a href='#trend_c'><p>Trend R6 class</p></a></li>
<li><a href='#trend_LM'><p>Trend R6 class</p></a></li>
<li><a href='#Triangle'><p>Triangle Kernel R6 class</p></a></li>
<li><a href='#White'><p>White noise Kernel R6 class</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Gaussian Process Fitting</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.11</td>
</tr>
<tr>
<td>Author:</td>
<td>Collin Erickson</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Collin Erickson &lt;collinberickson@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Fits a Gaussian process model to data. Gaussian processes
 are commonly used in computer experiments to fit an interpolating model.
 The model is stored as an 'R6' object and can be easily updated with new 
 data. There are options to run in parallel, and 'Rcpp'
 has been used to speed up calculations.
 For more info about Gaussian process software, see Erickson et al. (2018)
 &lt;<a href="https://doi.org/10.1016%2Fj.ejor.2017.10.002">doi:10.1016/j.ejor.2017.10.002</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, R6, lbfgs</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, microbenchmark, numDeriv,
ContourFunctions, dplyr, ggplot2, ggrepel, gridExtra, lhs,
mixopt (&gt; 0.1.0), rlang, splitfngr, tidyr, MASS</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/CollinErickson/GauPro">https://github.com/CollinErickson/GauPro</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/CollinErickson/GauPro/issues">https://github.com/CollinErickson/GauPro/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-11 02:42:48 UTC; colli</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-11 11:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+2A.GauPro_kernel'>Kernel product</h2><span id='topic++2A.GauPro_kernel'></span>

<h3>Description</h3>

<p>Kernel product
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GauPro_kernel'
k1 * k2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2A.GauPro_kernel_+3A_k1">k1</code></td>
<td>
<p>First kernel</p>
</td></tr>
<tr><td><code id="+2B2A.GauPro_kernel_+3A_k2">k2</code></td>
<td>
<p>Second kernel</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Kernel which is product of two kernels
</p>


<h3>Examples</h3>

<pre><code class='language-R'>k1 &lt;- Exponential$new(beta=1)
k2 &lt;- Matern32$new(beta=0)
k &lt;- k1 * k2
k$k(matrix(c(2,1), ncol=1))
</code></pre>

<hr>
<h2 id='+2B.GauPro_kernel'>Kernel sum</h2><span id='topic++2B.GauPro_kernel'></span>

<h3>Description</h3>

<p>Kernel sum
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GauPro_kernel'
k1 + k2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2B.GauPro_kernel_+3A_k1">k1</code></td>
<td>
<p>First kernel</p>
</td></tr>
<tr><td><code id="+2B2B.GauPro_kernel_+3A_k2">k2</code></td>
<td>
<p>Second kernel</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Kernel which is sum of two kernels
</p>


<h3>Examples</h3>

<pre><code class='language-R'>k1 &lt;- Exponential$new(beta=1)
k2 &lt;- Matern32$new(beta=0)
k &lt;- k1 + k2
k$k(matrix(c(2,1), ncol=1))
</code></pre>

<hr>
<h2 id='arma_mult_cube_vec'>Cube multiply over first dimension</h2><span id='topic+arma_mult_cube_vec'></span>

<h3>Description</h3>

<p>The result is transposed since that is what apply will give you
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arma_mult_cube_vec(cub, v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arma_mult_cube_vec_+3A_cub">cub</code></td>
<td>
<p>A cube (3D array)</p>
</td></tr>
<tr><td><code id="arma_mult_cube_vec_+3A_v">v</code></td>
<td>
<p>A vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Transpose of multiplication over first dimension of cub time v
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d1 &lt;- 10
d2 &lt;- 1e2
d3 &lt;- 2e2
aa &lt;- array(data = rnorm(d1*d2*d3), dim = c(d1, d2, d3))
bb &lt;- rnorm(d3)
t1 &lt;- apply(aa, 1, function(U) {U%*%bb})
t2 &lt;- arma_mult_cube_vec(aa, bb)
dd &lt;- t1 - t2

summary(dd)
image(dd)
table(dd)
# microbenchmark::microbenchmark(apply(aa, 1, function(U) {U%*%bb}),
#                                arma_mult_cube_vec(aa, bb))
</code></pre>

<hr>
<h2 id='corr_cubic_matrix_symC'>Correlation Cubic matrix in C (symmetric)</h2><span id='topic+corr_cubic_matrix_symC'></span>

<h3>Description</h3>

<p>Correlation Cubic matrix in C (symmetric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corr_cubic_matrix_symC(x, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corr_cubic_matrix_symC_+3A_x">x</code></td>
<td>
<p>Matrix x</p>
</td></tr>
<tr><td><code id="corr_cubic_matrix_symC_+3A_theta">theta</code></td>
<td>
<p>Theta vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Correlation matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>corr_cubic_matrix_symC(matrix(c(1,0,0,1),2,2),c(1,1))
</code></pre>

<hr>
<h2 id='corr_exponential_matrix_symC'>Correlation Gaussian matrix in C (symmetric)</h2><span id='topic+corr_exponential_matrix_symC'></span>

<h3>Description</h3>

<p>Correlation Gaussian matrix in C (symmetric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corr_exponential_matrix_symC(x, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corr_exponential_matrix_symC_+3A_x">x</code></td>
<td>
<p>Matrix x</p>
</td></tr>
<tr><td><code id="corr_exponential_matrix_symC_+3A_theta">theta</code></td>
<td>
<p>Theta vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Correlation matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>corr_gauss_matrix_symC(matrix(c(1,0,0,1),2,2),c(1,1))
</code></pre>

<hr>
<h2 id='corr_gauss_dCdX'>Correlation Gaussian matrix gradient in C using Armadillo</h2><span id='topic+corr_gauss_dCdX'></span>

<h3>Description</h3>

<p>Correlation Gaussian matrix gradient in C using Armadillo
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corr_gauss_dCdX(XX, X, theta, s2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corr_gauss_dCdX_+3A_xx">XX</code></td>
<td>
<p>Matrix XX to get gradient for</p>
</td></tr>
<tr><td><code id="corr_gauss_dCdX_+3A_x">X</code></td>
<td>
<p>Matrix X GP was fit to</p>
</td></tr>
<tr><td><code id="corr_gauss_dCdX_+3A_theta">theta</code></td>
<td>
<p>Theta vector</p>
</td></tr>
<tr><td><code id="corr_gauss_dCdX_+3A_s2">s2</code></td>
<td>
<p>Variance parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>3-dim array of correlation derivative
</p>


<h3>Examples</h3>

<pre><code class='language-R'># corr_gauss_dCdX(matrix(c(1,0,0,1),2,2),c(1,1))
</code></pre>

<hr>
<h2 id='corr_gauss_matrix'>Gaussian correlation</h2><span id='topic+corr_gauss_matrix'></span>

<h3>Description</h3>

<p>Gaussian correlation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corr_gauss_matrix(x, x2 = NULL, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corr_gauss_matrix_+3A_x">x</code></td>
<td>
<p>First data matrix</p>
</td></tr>
<tr><td><code id="corr_gauss_matrix_+3A_x2">x2</code></td>
<td>
<p>Second data matrix</p>
</td></tr>
<tr><td><code id="corr_gauss_matrix_+3A_theta">theta</code></td>
<td>
<p>Correlation parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Correlation matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>corr_gauss_matrix(matrix(1:10,ncol=1), matrix(6:15,ncol=1), 1e-2)
</code></pre>

<hr>
<h2 id='corr_gauss_matrix_armaC'>Correlation Gaussian matrix in C using Armadillo</h2><span id='topic+corr_gauss_matrix_armaC'></span>

<h3>Description</h3>

<p>20-25
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corr_gauss_matrix_armaC(x, y, theta, s2 = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corr_gauss_matrix_armaC_+3A_x">x</code></td>
<td>
<p>Matrix x</p>
</td></tr>
<tr><td><code id="corr_gauss_matrix_armaC_+3A_y">y</code></td>
<td>
<p>Matrix y, must have same number of columns as x</p>
</td></tr>
<tr><td><code id="corr_gauss_matrix_armaC_+3A_theta">theta</code></td>
<td>
<p>Theta vector</p>
</td></tr>
<tr><td><code id="corr_gauss_matrix_armaC_+3A_s2">s2</code></td>
<td>
<p>Variance to multiply matrix by</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Correlation matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>corr_gauss_matrix_armaC(matrix(c(1,0,0,1),2,2),matrix(c(1,0,1,1),2,2),c(1,1))

x1 &lt;- matrix(runif(100*6), nrow=100, ncol=6)
x2 &lt;- matrix(runif(1e4*6), ncol=6)
th &lt;- runif(6)
t1 &lt;- corr_gauss_matrixC(x1, x2, th)
t2 &lt;- corr_gauss_matrix_armaC(x1, x2, th)
identical(t1, t2)
# microbenchmark::microbenchmark(corr_gauss_matrixC(x1, x2, th),
#                                corr_gauss_matrix_armaC(x1, x2, th))
</code></pre>

<hr>
<h2 id='corr_gauss_matrix_sym_armaC'>Correlation Gaussian matrix in C using Armadillo (symmetric)</h2><span id='topic+corr_gauss_matrix_sym_armaC'></span>

<h3>Description</h3>

<p>About 30
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corr_gauss_matrix_sym_armaC(x, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corr_gauss_matrix_sym_armaC_+3A_x">x</code></td>
<td>
<p>Matrix x</p>
</td></tr>
<tr><td><code id="corr_gauss_matrix_sym_armaC_+3A_theta">theta</code></td>
<td>
<p>Theta vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Correlation matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>corr_gauss_matrix_sym_armaC(matrix(c(1,0,0,1),2,2),c(1,1))

x3 &lt;- matrix(runif(1e3*6), ncol=6)
th &lt;- runif(6)
t3 &lt;- corr_gauss_matrix_symC(x3, th)
t4 &lt;- corr_gauss_matrix_sym_armaC(x3, th)
identical(t3, t4)
# microbenchmark::microbenchmark(corr_gauss_matrix_symC(x3, th),
#                     corr_gauss_matrix_sym_armaC(x3, th), times=50)
</code></pre>

<hr>
<h2 id='corr_gauss_matrix_symC'>Correlation Gaussian matrix in C (symmetric)</h2><span id='topic+corr_gauss_matrix_symC'></span>

<h3>Description</h3>

<p>Correlation Gaussian matrix in C (symmetric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corr_gauss_matrix_symC(x, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corr_gauss_matrix_symC_+3A_x">x</code></td>
<td>
<p>Matrix x</p>
</td></tr>
<tr><td><code id="corr_gauss_matrix_symC_+3A_theta">theta</code></td>
<td>
<p>Theta vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Correlation matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>corr_gauss_matrix_symC(matrix(c(1,0,0,1),2,2),c(1,1))
</code></pre>

<hr>
<h2 id='corr_gauss_matrixC'>Correlation Gaussian matrix in C using Rcpp</h2><span id='topic+corr_gauss_matrixC'></span>

<h3>Description</h3>

<p>Correlation Gaussian matrix in C using Rcpp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corr_gauss_matrixC(x, y, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corr_gauss_matrixC_+3A_x">x</code></td>
<td>
<p>Matrix x</p>
</td></tr>
<tr><td><code id="corr_gauss_matrixC_+3A_y">y</code></td>
<td>
<p>Matrix y, must have same number of columns as x</p>
</td></tr>
<tr><td><code id="corr_gauss_matrixC_+3A_theta">theta</code></td>
<td>
<p>Theta vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Correlation matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>corr_gauss_matrixC(matrix(c(1,0,0,1),2,2), matrix(c(1,0,1,1),2,2), c(1,1))
</code></pre>

<hr>
<h2 id='corr_latentfactor_matrix_symC'>Correlation Latent factor  matrix in C (symmetric)</h2><span id='topic+corr_latentfactor_matrix_symC'></span>

<h3>Description</h3>

<p>Correlation Latent factor  matrix in C (symmetric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corr_latentfactor_matrix_symC(x, theta, xindex, latentdim, offdiagequal)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corr_latentfactor_matrix_symC_+3A_x">x</code></td>
<td>
<p>Matrix x</p>
</td></tr>
<tr><td><code id="corr_latentfactor_matrix_symC_+3A_theta">theta</code></td>
<td>
<p>Theta vector</p>
</td></tr>
<tr><td><code id="corr_latentfactor_matrix_symC_+3A_xindex">xindex</code></td>
<td>
<p>Index to use</p>
</td></tr>
<tr><td><code id="corr_latentfactor_matrix_symC_+3A_latentdim">latentdim</code></td>
<td>
<p>Number of latent dimensions</p>
</td></tr>
<tr><td><code id="corr_latentfactor_matrix_symC_+3A_offdiagequal">offdiagequal</code></td>
<td>
<p>What to set off-diagonal values with matching values to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Correlation matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>corr_latentfactor_matrix_symC(matrix(c(1,.5, 2,1.6, 1,0),ncol=2,byrow=TRUE),
                              c(1.5,1.8), 1, 1, 1-1e-6)
corr_latentfactor_matrix_symC(matrix(c(0,0,0,1,0,0,0,2,0,0,0,3,0,0,0,4),
                                     ncol=4, byrow=TRUE),
  c(0.101, -0.714, 0.114, -0.755, 0.117, -0.76, 0.116, -0.752),
  4, 2, 1-1e-6) * 6.85
</code></pre>

<hr>
<h2 id='corr_latentfactor_matrixmatrixC'>Correlation Latent factor  matrix in C (symmetric)</h2><span id='topic+corr_latentfactor_matrixmatrixC'></span>

<h3>Description</h3>

<p>Correlation Latent factor  matrix in C (symmetric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corr_latentfactor_matrixmatrixC(x, y, theta, xindex, latentdim, offdiagequal)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corr_latentfactor_matrixmatrixC_+3A_x">x</code></td>
<td>
<p>Matrix x</p>
</td></tr>
<tr><td><code id="corr_latentfactor_matrixmatrixC_+3A_y">y</code></td>
<td>
<p>Matrix y</p>
</td></tr>
<tr><td><code id="corr_latentfactor_matrixmatrixC_+3A_theta">theta</code></td>
<td>
<p>Theta vector</p>
</td></tr>
<tr><td><code id="corr_latentfactor_matrixmatrixC_+3A_xindex">xindex</code></td>
<td>
<p>Index to use</p>
</td></tr>
<tr><td><code id="corr_latentfactor_matrixmatrixC_+3A_latentdim">latentdim</code></td>
<td>
<p>Number of latent dimensions</p>
</td></tr>
<tr><td><code id="corr_latentfactor_matrixmatrixC_+3A_offdiagequal">offdiagequal</code></td>
<td>
<p>What to set off-diagonal values with matching values to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Correlation matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>corr_latentfactor_matrixmatrixC(matrix(c(1,.5, 2,1.6, 1,0),ncol=2,byrow=TRUE),
                                matrix(c(2,1.6, 1,0),ncol=2,byrow=TRUE),
                                c(1.5,1.8), 1, 1, 1-1e-6)
corr_latentfactor_matrixmatrixC(matrix(c(0,0,0,1,0,0,0,2,0,0,0,3,0,0,0,4),
                                  ncol=4, byrow=TRUE),
                                matrix(c(0,0,0,2,0,0,0,4,0,0,0,1),
                                  ncol=4, byrow=TRUE),
  c(0.101, -0.714, 0.114, -0.755, 0.117, -0.76, 0.116, -0.752),
  4, 2, 1-1e-6) * 6.85
</code></pre>

<hr>
<h2 id='corr_matern32_matrix_symC'>Correlation Matern 3/2 matrix in C (symmetric)</h2><span id='topic+corr_matern32_matrix_symC'></span>

<h3>Description</h3>

<p>Correlation Matern 3/2 matrix in C (symmetric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corr_matern32_matrix_symC(x, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corr_matern32_matrix_symC_+3A_x">x</code></td>
<td>
<p>Matrix x</p>
</td></tr>
<tr><td><code id="corr_matern32_matrix_symC_+3A_theta">theta</code></td>
<td>
<p>Theta vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Correlation matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>corr_gauss_matrix_symC(matrix(c(1,0,0,1),2,2),c(1,1))
</code></pre>

<hr>
<h2 id='corr_matern52_matrix_symC'>Correlation Gaussian matrix in C (symmetric)</h2><span id='topic+corr_matern52_matrix_symC'></span>

<h3>Description</h3>

<p>Correlation Gaussian matrix in C (symmetric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corr_matern52_matrix_symC(x, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corr_matern52_matrix_symC_+3A_x">x</code></td>
<td>
<p>Matrix x</p>
</td></tr>
<tr><td><code id="corr_matern52_matrix_symC_+3A_theta">theta</code></td>
<td>
<p>Theta vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Correlation matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>corr_matern52_matrix_symC(matrix(c(1,0,0,1),2,2),c(1,1))
</code></pre>

<hr>
<h2 id='corr_orderedfactor_matrix_symC'>Correlation ordered factor  matrix in C (symmetric)</h2><span id='topic+corr_orderedfactor_matrix_symC'></span>

<h3>Description</h3>

<p>Correlation ordered factor  matrix in C (symmetric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corr_orderedfactor_matrix_symC(x, theta, xindex, offdiagequal)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corr_orderedfactor_matrix_symC_+3A_x">x</code></td>
<td>
<p>Matrix x</p>
</td></tr>
<tr><td><code id="corr_orderedfactor_matrix_symC_+3A_theta">theta</code></td>
<td>
<p>Theta vector</p>
</td></tr>
<tr><td><code id="corr_orderedfactor_matrix_symC_+3A_xindex">xindex</code></td>
<td>
<p>Index to use</p>
</td></tr>
<tr><td><code id="corr_orderedfactor_matrix_symC_+3A_offdiagequal">offdiagequal</code></td>
<td>
<p>What to set off-diagonal values with matching values to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Correlation matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>corr_orderedfactor_matrix_symC(matrix(c(1,.5, 2,1.6, 1,0),ncol=2,byrow=TRUE),
                              c(1.5,1.8), 1, 1-1e-6)
corr_orderedfactor_matrix_symC(matrix(c(0,0,0,1,0,0,0,2,0,0,0,3,0,0,0,4),
                                     ncol=4, byrow=TRUE),
  c(0.101, -0.714, 0.114, -0.755, 0.117, -0.76, 0.116, -0.752),
  4, 1-1e-6) * 6.85
</code></pre>

<hr>
<h2 id='corr_orderedfactor_matrixmatrixC'>Correlation ordered factor matrix in C (symmetric)</h2><span id='topic+corr_orderedfactor_matrixmatrixC'></span>

<h3>Description</h3>

<p>Correlation ordered factor matrix in C (symmetric)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corr_orderedfactor_matrixmatrixC(x, y, theta, xindex, offdiagequal)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corr_orderedfactor_matrixmatrixC_+3A_x">x</code></td>
<td>
<p>Matrix x</p>
</td></tr>
<tr><td><code id="corr_orderedfactor_matrixmatrixC_+3A_y">y</code></td>
<td>
<p>Matrix y</p>
</td></tr>
<tr><td><code id="corr_orderedfactor_matrixmatrixC_+3A_theta">theta</code></td>
<td>
<p>Theta vector</p>
</td></tr>
<tr><td><code id="corr_orderedfactor_matrixmatrixC_+3A_xindex">xindex</code></td>
<td>
<p>Index to use</p>
</td></tr>
<tr><td><code id="corr_orderedfactor_matrixmatrixC_+3A_offdiagequal">offdiagequal</code></td>
<td>
<p>What to set off-diagonal values with matching values to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Correlation matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>corr_orderedfactor_matrixmatrixC(matrix(c(1,.5, 2,1.6, 1,0),ncol=2,byrow=TRUE),
                                matrix(c(2,1.6, 1,0),ncol=2,byrow=TRUE),
                                c(1.5,1.8), 1, 1-1e-6)
corr_orderedfactor_matrixmatrixC(matrix(c(0,0,0,1,0,0,0,2,0,0,0,3,0,0,0,4),
                                  ncol=4, byrow=TRUE),
                                matrix(c(0,0,0,2,0,0,0,4,0,0,0,1),
                                  ncol=4, byrow=TRUE),
  c(0.101, -0.714, 0.114, -0.755, 0.117, -0.76, 0.116, -0.752),
  4, 1-1e-6) * 6.85
</code></pre>

<hr>
<h2 id='Cubic'>Cubic Kernel R6 class</h2><span id='topic+Cubic'></span>

<h3>Description</h3>

<p>Cubic Kernel R6 class
</p>
<p>Cubic Kernel R6 class
</p>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Value</h3>

<p>Object of <code><a href="R6.html#topic+R6Class">R6Class</a></code> with methods for fitting GP model.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+GauPro_kernel">GauPro::GauPro_kernel</a></code> -&gt; <code><a href="#topic+GauPro_kernel_beta">GauPro::GauPro_kernel_beta</a></code> -&gt; <code>GauPro_kernel_Cubic</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GauPro_kernel_Cubic-k"><code>Cubic$k()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Cubic-kone"><code>Cubic$kone()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Cubic-dC_dparams"><code>Cubic$dC_dparams()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Cubic-dC_dx"><code>Cubic$dC_dx()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Cubic-print"><code>Cubic$print()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Cubic-clone"><code>Cubic$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel" data-id="plot"><a href='../../GauPro/html/GauPro_kernel.html#method-GauPro_kernel-plot'><code>GauPro::GauPro_kernel$plot()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="C_dC_dparams"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-C_dC_dparams'><code>GauPro::GauPro_kernel_beta$C_dC_dparams()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="initialize"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-initialize'><code>GauPro::GauPro_kernel_beta$initialize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="param_optim_lower"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-param_optim_lower'><code>GauPro::GauPro_kernel_beta$param_optim_lower()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="param_optim_start"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-param_optim_start'><code>GauPro::GauPro_kernel_beta$param_optim_start()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="param_optim_start0"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-param_optim_start0'><code>GauPro::GauPro_kernel_beta$param_optim_start0()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="param_optim_upper"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-param_optim_upper'><code>GauPro::GauPro_kernel_beta$param_optim_upper()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="s2_from_params"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-s2_from_params'><code>GauPro::GauPro_kernel_beta$s2_from_params()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="set_params_from_optim"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-set_params_from_optim'><code>GauPro::GauPro_kernel_beta$set_params_from_optim()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-GauPro_kernel_Cubic-k"></a>



<h4>Method <code>k()</code></h4>

<p>Calculate covariance between two points
</p>


<h5>Usage</h5>

<div class="r"><pre>Cubic$k(x, y = NULL, beta = self$beta, s2 = self$s2, params = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>vector.</p>
</dd>
<dt><code>y</code></dt><dd><p>vector, optional. If excluded, find correlation
of x with itself.</p>
</dd>
<dt><code>beta</code></dt><dd><p>Correlation parameters.</p>
</dd>
<dt><code>s2</code></dt><dd><p>Variance parameter.</p>
</dd>
<dt><code>params</code></dt><dd><p>parameters to use instead of beta and s2.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_Cubic-kone"></a>



<h4>Method <code>kone()</code></h4>

<p>Find covariance of two points
</p>


<h5>Usage</h5>

<div class="r"><pre>Cubic$kone(x, y, beta, theta, s2)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>vector</p>
</dd>
<dt><code>y</code></dt><dd><p>vector</p>
</dd>
<dt><code>beta</code></dt><dd><p>correlation parameters on log scale</p>
</dd>
<dt><code>theta</code></dt><dd><p>correlation parameters on regular scale</p>
</dd>
<dt><code>s2</code></dt><dd><p>Variance parameter</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_Cubic-dC_dparams"></a>



<h4>Method <code>dC_dparams()</code></h4>

<p>Derivative of covariance with respect to parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>Cubic$dC_dparams(params = NULL, X, C_nonug, C, nug)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Kernel parameters</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points in rows</p>
</dd>
<dt><code>C_nonug</code></dt><dd><p>Covariance without nugget added to diagonal</p>
</dd>
<dt><code>C</code></dt><dd><p>Covariance with nugget</p>
</dd>
<dt><code>nug</code></dt><dd><p>Value of nugget</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_Cubic-dC_dx"></a>



<h4>Method <code>dC_dx()</code></h4>

<p>Derivative of covariance with respect to X
</p>


<h5>Usage</h5>

<div class="r"><pre>Cubic$dC_dx(XX, X, theta, beta = self$beta, s2 = self$s2)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>matrix of points</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points to take derivative with respect to</p>
</dd>
<dt><code>theta</code></dt><dd><p>Correlation parameters</p>
</dd>
<dt><code>beta</code></dt><dd><p>log of theta</p>
</dd>
<dt><code>s2</code></dt><dd><p>Variance parameter</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_Cubic-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print this object
</p>


<h5>Usage</h5>

<div class="r"><pre>Cubic$print()</pre></div>


<hr>
<a id="method-GauPro_kernel_Cubic-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Cubic$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>k1 &lt;- Cubic$new(beta=runif(6)-.5)
plot(k1)

n &lt;- 12
x &lt;- matrix(seq(0,1,length.out = n), ncol=1)
y &lt;- sin(2*pi*x) + rnorm(n,0,1e-1)
gp &lt;- GauPro_kernel_model$new(X=x, Z=y, kernel=Cubic$new(1),
                              parallel=FALSE, restarts=0)
gp$predict(.454)
</code></pre>

<hr>
<h2 id='Exponential'>Exponential Kernel R6 class</h2><span id='topic+Exponential'></span>

<h3>Description</h3>

<p>Exponential Kernel R6 class
</p>
<p>Exponential Kernel R6 class
</p>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Value</h3>

<p>Object of <code><a href="R6.html#topic+R6Class">R6Class</a></code> with methods for fitting GP model.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+GauPro_kernel">GauPro::GauPro_kernel</a></code> -&gt; <code><a href="#topic+GauPro_kernel_beta">GauPro::GauPro_kernel_beta</a></code> -&gt; <code>GauPro_kernel_Exponential</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GauPro_kernel_Exponential-k"><code>Exponential$k()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Exponential-kone"><code>Exponential$kone()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Exponential-dC_dparams"><code>Exponential$dC_dparams()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Exponential-dC_dx"><code>Exponential$dC_dx()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Exponential-print"><code>Exponential$print()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Exponential-clone"><code>Exponential$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel" data-id="plot"><a href='../../GauPro/html/GauPro_kernel.html#method-GauPro_kernel-plot'><code>GauPro::GauPro_kernel$plot()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="C_dC_dparams"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-C_dC_dparams'><code>GauPro::GauPro_kernel_beta$C_dC_dparams()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="initialize"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-initialize'><code>GauPro::GauPro_kernel_beta$initialize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="param_optim_lower"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-param_optim_lower'><code>GauPro::GauPro_kernel_beta$param_optim_lower()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="param_optim_start"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-param_optim_start'><code>GauPro::GauPro_kernel_beta$param_optim_start()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="param_optim_start0"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-param_optim_start0'><code>GauPro::GauPro_kernel_beta$param_optim_start0()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="param_optim_upper"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-param_optim_upper'><code>GauPro::GauPro_kernel_beta$param_optim_upper()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="s2_from_params"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-s2_from_params'><code>GauPro::GauPro_kernel_beta$s2_from_params()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="set_params_from_optim"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-set_params_from_optim'><code>GauPro::GauPro_kernel_beta$set_params_from_optim()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-GauPro_kernel_Exponential-k"></a>



<h4>Method <code>k()</code></h4>

<p>Calculate covariance between two points
</p>


<h5>Usage</h5>

<div class="r"><pre>Exponential$k(x, y = NULL, beta = self$beta, s2 = self$s2, params = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>vector.</p>
</dd>
<dt><code>y</code></dt><dd><p>vector, optional. If excluded, find correlation
of x with itself.</p>
</dd>
<dt><code>beta</code></dt><dd><p>Correlation parameters.</p>
</dd>
<dt><code>s2</code></dt><dd><p>Variance parameter.</p>
</dd>
<dt><code>params</code></dt><dd><p>parameters to use instead of beta and s2.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_Exponential-kone"></a>



<h4>Method <code>kone()</code></h4>

<p>Find covariance of two points
</p>


<h5>Usage</h5>

<div class="r"><pre>Exponential$kone(x, y, beta, theta, s2)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>vector</p>
</dd>
<dt><code>y</code></dt><dd><p>vector</p>
</dd>
<dt><code>beta</code></dt><dd><p>correlation parameters on log scale</p>
</dd>
<dt><code>theta</code></dt><dd><p>correlation parameters on regular scale</p>
</dd>
<dt><code>s2</code></dt><dd><p>Variance parameter</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_Exponential-dC_dparams"></a>



<h4>Method <code>dC_dparams()</code></h4>

<p>Derivative of covariance with respect to parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>Exponential$dC_dparams(params = NULL, X, C_nonug, C, nug)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Kernel parameters</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points in rows</p>
</dd>
<dt><code>C_nonug</code></dt><dd><p>Covariance without nugget added to diagonal</p>
</dd>
<dt><code>C</code></dt><dd><p>Covariance with nugget</p>
</dd>
<dt><code>nug</code></dt><dd><p>Value of nugget</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_Exponential-dC_dx"></a>



<h4>Method <code>dC_dx()</code></h4>

<p>Derivative of covariance with respect to X
</p>


<h5>Usage</h5>

<div class="r"><pre>Exponential$dC_dx(XX, X, theta, beta = self$beta, s2 = self$s2)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>matrix of points</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points to take derivative with respect to</p>
</dd>
<dt><code>theta</code></dt><dd><p>Correlation parameters</p>
</dd>
<dt><code>beta</code></dt><dd><p>log of theta</p>
</dd>
<dt><code>s2</code></dt><dd><p>Variance parameter</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_Exponential-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print this object
</p>


<h5>Usage</h5>

<div class="r"><pre>Exponential$print()</pre></div>


<hr>
<a id="method-GauPro_kernel_Exponential-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Exponential$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>k1 &lt;- Exponential$new(beta=0)
</code></pre>

<hr>
<h2 id='FactorKernel'>Factor Kernel R6 class</h2><span id='topic+FactorKernel'></span>

<h3>Description</h3>

<p>Factor Kernel R6 class
</p>
<p>Factor Kernel R6 class
</p>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Details</h3>

<p>For a factor that has been converted to its indices.
Each factor will need a separate kernel.
</p>


<h3>Value</h3>

<p>Object of <code><a href="R6.html#topic+R6Class">R6Class</a></code> with methods for fitting GP model.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+GauPro_kernel">GauPro::GauPro_kernel</a></code> -&gt; <code>GauPro_kernel_FactorKernel</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>p</code></dt><dd><p>Parameter for correlation</p>
</dd>
<dt><code>p_est</code></dt><dd><p>Should p be estimated?</p>
</dd>
<dt><code>p_lower</code></dt><dd><p>Lower bound of p</p>
</dd>
<dt><code>p_upper</code></dt><dd><p>Upper bound of p</p>
</dd>
<dt><code>p_length</code></dt><dd><p>length of p</p>
</dd>
<dt><code>s2</code></dt><dd><p>variance</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 estimated?</p>
</dd>
<dt><code>logs2</code></dt><dd><p>Log of s2</p>
</dd>
<dt><code>logs2_lower</code></dt><dd><p>Lower bound of logs2</p>
</dd>
<dt><code>logs2_upper</code></dt><dd><p>Upper bound of logs2</p>
</dd>
<dt><code>xindex</code></dt><dd><p>Index of the factor (which column of X)</p>
</dd>
<dt><code>nlevels</code></dt><dd><p>Number of levels for the factor</p>
</dd>
<dt><code>offdiagequal</code></dt><dd><p>What should offdiagonal values be set to when the
indices are the same? Use to avoid decomposition errors, similar to
adding a nugget.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GauPro_kernel_FactorKernel-new"><code>FactorKernel$new()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_FactorKernel-k"><code>FactorKernel$k()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_FactorKernel-kone"><code>FactorKernel$kone()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_FactorKernel-dC_dparams"><code>FactorKernel$dC_dparams()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_FactorKernel-C_dC_dparams"><code>FactorKernel$C_dC_dparams()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_FactorKernel-dC_dx"><code>FactorKernel$dC_dx()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_FactorKernel-param_optim_start"><code>FactorKernel$param_optim_start()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_FactorKernel-param_optim_start0"><code>FactorKernel$param_optim_start0()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_FactorKernel-param_optim_lower"><code>FactorKernel$param_optim_lower()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_FactorKernel-param_optim_upper"><code>FactorKernel$param_optim_upper()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_FactorKernel-set_params_from_optim"><code>FactorKernel$set_params_from_optim()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_FactorKernel-s2_from_params"><code>FactorKernel$s2_from_params()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_FactorKernel-print"><code>FactorKernel$print()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_FactorKernel-clone"><code>FactorKernel$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel" data-id="plot"><a href='../../GauPro/html/GauPro_kernel.html#method-GauPro_kernel-plot'><code>GauPro::GauPro_kernel$plot()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-GauPro_kernel_FactorKernel-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize kernel object
</p>


<h5>Usage</h5>

<div class="r"><pre>FactorKernel$new(
  s2 = 1,
  D,
  nlevels,
  xindex,
  p_lower = 0,
  p_upper = 0.9,
  p_est = TRUE,
  s2_lower = 1e-08,
  s2_upper = 1e+08,
  s2_est = TRUE,
  p,
  useC = TRUE,
  offdiagequal = 1 - 1e-06
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>s2</code></dt><dd><p>Initial variance</p>
</dd>
<dt><code>D</code></dt><dd><p>Number of input dimensions of data</p>
</dd>
<dt><code>nlevels</code></dt><dd><p>Number of levels for the factor</p>
</dd>
<dt><code>xindex</code></dt><dd><p>Index of the factor (which column of X)</p>
</dd>
<dt><code>p_lower</code></dt><dd><p>Lower bound for p</p>
</dd>
<dt><code>p_upper</code></dt><dd><p>Upper bound for p</p>
</dd>
<dt><code>p_est</code></dt><dd><p>Should p be estimated?</p>
</dd>
<dt><code>s2_lower</code></dt><dd><p>Lower bound for s2</p>
</dd>
<dt><code>s2_upper</code></dt><dd><p>Upper bound for s2</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Should s2 be estimated?</p>
</dd>
<dt><code>p</code></dt><dd><p>Vector of correlations</p>
</dd>
<dt><code>useC</code></dt><dd><p>Should C code used? Not implemented for FactorKernel yet.</p>
</dd>
<dt><code>offdiagequal</code></dt><dd><p>What should offdiagonal values be set to when the
indices are the same? Use to avoid decomposition errors, similar to
adding a nugget.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_FactorKernel-k"></a>



<h4>Method <code>k()</code></h4>

<p>Calculate covariance between two points
</p>


<h5>Usage</h5>

<div class="r"><pre>FactorKernel$k(x, y = NULL, p = self$p, s2 = self$s2, params = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>vector.</p>
</dd>
<dt><code>y</code></dt><dd><p>vector, optional. If excluded, find correlation
of x with itself.</p>
</dd>
<dt><code>p</code></dt><dd><p>Correlation parameters.</p>
</dd>
<dt><code>s2</code></dt><dd><p>Variance parameter.</p>
</dd>
<dt><code>params</code></dt><dd><p>parameters to use instead of beta and s2.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_FactorKernel-kone"></a>



<h4>Method <code>kone()</code></h4>

<p>Find covariance of two points
</p>


<h5>Usage</h5>

<div class="r"><pre>FactorKernel$kone(x, y, p, s2, isdiag = TRUE, offdiagequal = self$offdiagequal)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>vector</p>
</dd>
<dt><code>y</code></dt><dd><p>vector</p>
</dd>
<dt><code>p</code></dt><dd><p>correlation parameters on regular scale</p>
</dd>
<dt><code>s2</code></dt><dd><p>Variance parameter</p>
</dd>
<dt><code>isdiag</code></dt><dd><p>Is this on the diagonal of the covariance?</p>
</dd>
<dt><code>offdiagequal</code></dt><dd><p>What should offdiagonal values be set to when the
indices are the same? Use to avoid decomposition errors, similar to
adding a nugget.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_FactorKernel-dC_dparams"></a>



<h4>Method <code>dC_dparams()</code></h4>

<p>Derivative of covariance with respect to parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>FactorKernel$dC_dparams(params = NULL, X, C_nonug, C, nug)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Kernel parameters</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points in rows</p>
</dd>
<dt><code>C_nonug</code></dt><dd><p>Covariance without nugget added to diagonal</p>
</dd>
<dt><code>C</code></dt><dd><p>Covariance with nugget</p>
</dd>
<dt><code>nug</code></dt><dd><p>Value of nugget</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_FactorKernel-C_dC_dparams"></a>



<h4>Method <code>C_dC_dparams()</code></h4>

<p>Calculate covariance matrix and its derivative
with respect to parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>FactorKernel$C_dC_dparams(params = NULL, X, nug)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Kernel parameters</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points in rows</p>
</dd>
<dt><code>nug</code></dt><dd><p>Value of nugget</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_FactorKernel-dC_dx"></a>



<h4>Method <code>dC_dx()</code></h4>

<p>Derivative of covariance with respect to X
</p>


<h5>Usage</h5>

<div class="r"><pre>FactorKernel$dC_dx(XX, X, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>matrix of points</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points to take derivative with respect to</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional args, not used</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_FactorKernel-param_optim_start"></a>



<h4>Method <code>param_optim_start()</code></h4>

<p>Starting point for parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>FactorKernel$param_optim_start(
  jitter = F,
  y,
  p_est = self$p_est,
  s2_est = self$s2_est
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>jitter</code></dt><dd><p>Should there be a jitter?</p>
</dd>
<dt><code>y</code></dt><dd><p>Output</p>
</dd>
<dt><code>p_est</code></dt><dd><p>Is p being estimated?</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_FactorKernel-param_optim_start0"></a>



<h4>Method <code>param_optim_start0()</code></h4>

<p>Starting point for parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>FactorKernel$param_optim_start0(
  jitter = F,
  y,
  p_est = self$p_est,
  s2_est = self$s2_est
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>jitter</code></dt><dd><p>Should there be a jitter?</p>
</dd>
<dt><code>y</code></dt><dd><p>Output</p>
</dd>
<dt><code>p_est</code></dt><dd><p>Is p being estimated?</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_FactorKernel-param_optim_lower"></a>



<h4>Method <code>param_optim_lower()</code></h4>

<p>Lower bounds of parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>FactorKernel$param_optim_lower(p_est = self$p_est, s2_est = self$s2_est)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>p_est</code></dt><dd><p>Is p being estimated?</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_FactorKernel-param_optim_upper"></a>



<h4>Method <code>param_optim_upper()</code></h4>

<p>Upper bounds of parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>FactorKernel$param_optim_upper(p_est = self$p_est, s2_est = self$s2_est)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>p_est</code></dt><dd><p>Is p being estimated?</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_FactorKernel-set_params_from_optim"></a>



<h4>Method <code>set_params_from_optim()</code></h4>

<p>Set parameters from optimization output
</p>


<h5>Usage</h5>

<div class="r"><pre>FactorKernel$set_params_from_optim(
  optim_out,
  p_est = self$p_est,
  s2_est = self$s2_est
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>optim_out</code></dt><dd><p>Output from optimization</p>
</dd>
<dt><code>p_est</code></dt><dd><p>Is p being estimated?</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_FactorKernel-s2_from_params"></a>



<h4>Method <code>s2_from_params()</code></h4>

<p>Get s2 from params vector
</p>


<h5>Usage</h5>

<div class="r"><pre>FactorKernel$s2_from_params(params, s2_est = self$s2_est)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>parameter vector</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_FactorKernel-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print this object
</p>


<h5>Usage</h5>

<div class="r"><pre>FactorKernel$print()</pre></div>


<hr>
<a id="method-GauPro_kernel_FactorKernel-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>FactorKernel$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>kk &lt;- FactorKernel$new(D=1, nlevels=5, xindex=1)
kk$p &lt;- (1:10)/100
kmat &lt;- outer(1:5, 1:5, Vectorize(kk$k))
kmat
kk$plot()


# 2D, Gaussian on 1D, index on 2nd dim
library(dplyr)
n &lt;- 20
X &lt;- cbind(matrix(runif(n,2,6), ncol=1),
           matrix(sample(1:2, size=n, replace=TRUE), ncol=1))
X &lt;- rbind(X, c(3.3,3))
n &lt;- nrow(X)
Z &lt;- X[,1] - (X[,2]-1.8)^2 + rnorm(n,0,.1)
tibble(X=X, Z) %&gt;% arrange(X,Z)
k2a &lt;- IgnoreIndsKernel$new(k=Gaussian$new(D=1), ignoreinds = 2)
k2b &lt;- FactorKernel$new(D=2, nlevels=3, xind=2)
k2 &lt;- k2a * k2b
k2b$p_upper &lt;- .65*k2b$p_upper
gp &lt;- GauPro_kernel_model$new(X=X, Z=Z, kernel = k2, verbose = 5,
                              nug.min=1e-2, restarts=0)
gp$kernel$k1$kernel$beta
gp$kernel$k2$p
gp$kernel$k(x = gp$X)
tibble(X=X, Z=Z, pred=gp$predict(X)) %&gt;% arrange(X, Z)
tibble(X=X[,2], Z) %&gt;% group_by(X) %&gt;% summarize(n=n(), mean(Z))
curve(gp$pred(cbind(matrix(x,ncol=1),1)),2,6, ylim=c(min(Z), max(Z)))
points(X[X[,2]==1,1], Z[X[,2]==1])
curve(gp$pred(cbind(matrix(x,ncol=1),2)), add=TRUE, col=2)
points(X[X[,2]==2,1], Z[X[,2]==2], col=2)
curve(gp$pred(cbind(matrix(x,ncol=1),3)), add=TRUE, col=3)
points(X[X[,2]==3,1], Z[X[,2]==3], col=3)
legend(legend=1:3, fill=1:3, x="topleft")
# See which points affect (5.5, 3 themost)
data.frame(X, cov=gp$kernel$k(X, c(5.5,3))) %&gt;% arrange(-cov)
plot(k2b)


</code></pre>

<hr>
<h2 id='GauPro'>GauPro_selector</h2><span id='topic+GauPro'></span>

<h3>Description</h3>

<p>GauPro_selector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GauPro(..., type = "Gauss")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GauPro_+3A_...">...</code></td>
<td>
<p>Pass on</p>
</td></tr>
<tr><td><code id="GauPro_+3A_type">type</code></td>
<td>
<p>Type of Gaussian process, or the kind of correlation function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A GauPro object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 12
x &lt;- matrix(seq(0,1,length.out = n), ncol=1)
#y &lt;- sin(2*pi*x) + rnorm(n,0,1e-1)
y &lt;- (2*x) %%1
gp &lt;- GauPro(X=x, Z=y, parallel=FALSE)
</code></pre>

<hr>
<h2 id='GauPro_base'>Class providing object with methods for fitting a GP model</h2><span id='topic+GauPro_base'></span>

<h3>Description</h3>

<p>Class providing object with methods for fitting a GP model
</p>
<p>Class providing object with methods for fitting a GP model
</p>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Value</h3>

<p>Object of <code><a href="R6.html#topic+R6Class">R6Class</a></code> with methods for fitting GP model.
</p>


<h3>Methods</h3>


<dl>
<dt><code>new(X, Z, corr="Gauss", verbose=0, separable=T, useC=F,useGrad=T,
         parallel=T, nug.est=T, ...)</code></dt><dd><p>This method is used to create object of this class with <code>X</code> and <code>Z</code> as the data.</p>
</dd>
<dt><code>update(Xnew=NULL, Znew=NULL, Xall=NULL, Zall=NULL,
restarts = 5,
param_update = T, nug.update = self$nug.est)</code></dt><dd><p>This method updates the model, adding new data if given, then running optimization again.</p>
</dd>
</dl>



<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>X</code></dt><dd><p>Design matrix</p>
</dd>
<dt><code>Z</code></dt><dd><p>Responses</p>
</dd>
<dt><code>N</code></dt><dd><p>Number of data points</p>
</dd>
<dt><code>D</code></dt><dd><p>Dimension of data</p>
</dd>
<dt><code>nug.min</code></dt><dd><p>Minimum value of nugget</p>
</dd>
<dt><code>nug</code></dt><dd><p>Value of the nugget, is estimated unless told otherwise</p>
</dd>
<dt><code>verbose</code></dt><dd><p>0 means nothing printed, 1 prints some, 2 prints most.</p>
</dd>
<dt><code>useGrad</code></dt><dd><p>Should grad be used?</p>
</dd>
<dt><code>useC</code></dt><dd><p>Should C code be used?</p>
</dd>
<dt><code>parallel</code></dt><dd><p>Should the code be run in parallel?</p>
</dd>
<dt><code>parallel_cores</code></dt><dd><p>How many cores are there? It will self detect,
do not set yourself.</p>
</dd>
<dt><code>nug.est</code></dt><dd><p>Should the nugget be estimated?</p>
</dd>
<dt><code>param.est</code></dt><dd><p>Should the parameters be estimated?</p>
</dd>
<dt><code>mu_hat</code></dt><dd><p>Mean estimate</p>
</dd>
<dt><code>s2_hat</code></dt><dd><p>Variance estimate</p>
</dd>
<dt><code>K</code></dt><dd><p>Covariance matrix</p>
</dd>
<dt><code>Kchol</code></dt><dd><p>Cholesky factorization of K</p>
</dd>
<dt><code>Kinv</code></dt><dd><p>Inverse of K</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GauPro-corr_func"><code>GauPro_base$corr_func()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-new"><code>GauPro_base$new()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-initialize_GauPr"><code>GauPro_base$initialize_GauPr()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-fit"><code>GauPro_base$fit()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-update_K_and_estimates"><code>GauPro_base$update_K_and_estimates()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-predict"><code>GauPro_base$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-pred"><code>GauPro_base$pred()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-pred_one_matrix"><code>GauPro_base$pred_one_matrix()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-pred_mean"><code>GauPro_base$pred_mean()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-pred_meanC"><code>GauPro_base$pred_meanC()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-pred_var"><code>GauPro_base$pred_var()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-pred_LOO"><code>GauPro_base$pred_LOO()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-plot"><code>GauPro_base$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-cool1Dplot"><code>GauPro_base$cool1Dplot()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-plot1D"><code>GauPro_base$plot1D()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-plot2D"><code>GauPro_base$plot2D()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-loglikelihood"><code>GauPro_base$loglikelihood()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-optim"><code>GauPro_base$optim()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-optimRestart"><code>GauPro_base$optimRestart()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-update"><code>GauPro_base$update()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-update_data"><code>GauPro_base$update_data()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-update_corrparams"><code>GauPro_base$update_corrparams()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-update_nugget"><code>GauPro_base$update_nugget()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-deviance_searchnug"><code>GauPro_base$deviance_searchnug()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-nugget_update"><code>GauPro_base$nugget_update()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-grad_norm"><code>GauPro_base$grad_norm()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-sample"><code>GauPro_base$sample()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-print"><code>GauPro_base$print()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-clone"><code>GauPro_base$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-GauPro-corr_func"></a>



<h4>Method <code>corr_func()</code></h4>

<p>Correlation function
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_base$corr_func(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Does nothing</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create GauPro object
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_base$new(
  X,
  Z,
  verbose = 0,
  useC = F,
  useGrad = T,
  parallel = FALSE,
  nug = 1e-06,
  nug.min = 1e-08,
  nug.est = T,
  param.est = TRUE,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X</code></dt><dd><p>Matrix whose rows are the input points</p>
</dd>
<dt><code>Z</code></dt><dd><p>Output points corresponding to X</p>
</dd>
<dt><code>verbose</code></dt><dd><p>Amount of stuff to print. 0 is little, 2 is a lot.</p>
</dd>
<dt><code>useC</code></dt><dd><p>Should C code be used when possible? Should be faster.</p>
</dd>
<dt><code>useGrad</code></dt><dd><p>Should the gradient be used?</p>
</dd>
<dt><code>parallel</code></dt><dd><p>Should code be run in parallel? Make optimization
faster but uses more computer resources.</p>
</dd>
<dt><code>nug</code></dt><dd><p>Value for the nugget. The starting value if estimating it.</p>
</dd>
<dt><code>nug.min</code></dt><dd><p>Minimum allowable value for the nugget.</p>
</dd>
<dt><code>nug.est</code></dt><dd><p>Should the nugget be estimated?</p>
</dd>
<dt><code>param.est</code></dt><dd><p>Should the kernel parameters be estimated?</p>
</dd>
<dt><code>...</code></dt><dd><p>Not used</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-initialize_GauPr"></a>



<h4>Method <code>initialize_GauPr()</code></h4>

<p>Not used
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_base$initialize_GauPr()</pre></div>


<hr>
<a id="method-GauPro-fit"></a>



<h4>Method <code>fit()</code></h4>

<p>Fit the model, never use this function
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_base$fit(X, Z)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X</code></dt><dd><p>Not used</p>
</dd>
<dt><code>Z</code></dt><dd><p>Not used</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-update_K_and_estimates"></a>



<h4>Method <code>update_K_and_estimates()</code></h4>

<p>Update Covariance matrix and estimated parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_base$update_K_and_estimates()</pre></div>


<hr>
<a id="method-GauPro-predict"></a>



<h4>Method <code>predict()</code></h4>

<p>Predict mean and se for given matrix
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_base$predict(XX, se.fit = F, covmat = F, split_speed = T)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>Points to predict at</p>
</dd>
<dt><code>se.fit</code></dt><dd><p>Should the se be returned?</p>
</dd>
<dt><code>covmat</code></dt><dd><p>Should the covariance matrix be returned?</p>
</dd>
<dt><code>split_speed</code></dt><dd><p>Should the predictions be split up for speed</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-pred"></a>



<h4>Method <code>pred()</code></h4>

<p>Predict mean and se for given matrix
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_base$pred(XX, se.fit = F, covmat = F, split_speed = T)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>Points to predict at</p>
</dd>
<dt><code>se.fit</code></dt><dd><p>Should the se be returned?</p>
</dd>
<dt><code>covmat</code></dt><dd><p>Should the covariance matrix be returned?</p>
</dd>
<dt><code>split_speed</code></dt><dd><p>Should the predictions be split up for speed</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-pred_one_matrix"></a>



<h4>Method <code>pred_one_matrix()</code></h4>

<p>Predict mean and se for given matrix
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_base$pred_one_matrix(XX, se.fit = F, covmat = F)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>Points to predict at</p>
</dd>
<dt><code>se.fit</code></dt><dd><p>Should the se be returned?</p>
</dd>
<dt><code>covmat</code></dt><dd><p>Should the covariance matrix be returned?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-pred_mean"></a>



<h4>Method <code>pred_mean()</code></h4>

<p>Predict mean
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_base$pred_mean(XX, kx.xx)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>Points to predict at</p>
</dd>
<dt><code>kx.xx</code></dt><dd><p>Covariance matrix between X and XX</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-pred_meanC"></a>



<h4>Method <code>pred_meanC()</code></h4>

<p>Predict mean using C code
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_base$pred_meanC(XX, kx.xx)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>Points to predict at</p>
</dd>
<dt><code>kx.xx</code></dt><dd><p>Covariance matrix between X and XX</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-pred_var"></a>



<h4>Method <code>pred_var()</code></h4>

<p>Predict variance
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_base$pred_var(XX, kxx, kx.xx, covmat = F)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>Points to predict at</p>
</dd>
<dt><code>kxx</code></dt><dd><p>Covariance matrix of XX with itself</p>
</dd>
<dt><code>kx.xx</code></dt><dd><p>Covariance matrix between X and XX</p>
</dd>
<dt><code>covmat</code></dt><dd><p>Not used</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-pred_LOO"></a>



<h4>Method <code>pred_LOO()</code></h4>

<p>Predict at X using leave-one-out. Can use for diagnostics.
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_base$pred_LOO(se.fit = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>se.fit</code></dt><dd><p>Should the standard error and t values be returned?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-plot"></a>



<h4>Method <code>plot()</code></h4>

<p>Plot the object
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_base$plot(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Parameters passed to cool1Dplot(), plot2D(), or plotmarginal()</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-cool1Dplot"></a>



<h4>Method <code>cool1Dplot()</code></h4>

<p>Make cool 1D plot
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_base$cool1Dplot(
  n2 = 20,
  nn = 201,
  col2 = "gray",
  xlab = "x",
  ylab = "y",
  xmin = NULL,
  xmax = NULL,
  ymin = NULL,
  ymax = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n2</code></dt><dd><p>Number of things to plot</p>
</dd>
<dt><code>nn</code></dt><dd><p>Number of things to plot</p>
</dd>
<dt><code>col2</code></dt><dd><p>color</p>
</dd>
<dt><code>xlab</code></dt><dd><p>x label</p>
</dd>
<dt><code>ylab</code></dt><dd><p>y label</p>
</dd>
<dt><code>xmin</code></dt><dd><p>xmin</p>
</dd>
<dt><code>xmax</code></dt><dd><p>xmax</p>
</dd>
<dt><code>ymin</code></dt><dd><p>ymin</p>
</dd>
<dt><code>ymax</code></dt><dd><p>ymax</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-plot1D"></a>



<h4>Method <code>plot1D()</code></h4>

<p>Make 1D plot
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_base$plot1D(
  n2 = 20,
  nn = 201,
  col2 = 2,
  xlab = "x",
  ylab = "y",
  xmin = NULL,
  xmax = NULL,
  ymin = NULL,
  ymax = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n2</code></dt><dd><p>Number of things to plot</p>
</dd>
<dt><code>nn</code></dt><dd><p>Number of things to plot</p>
</dd>
<dt><code>col2</code></dt><dd><p>Color of the prediction interval</p>
</dd>
<dt><code>xlab</code></dt><dd><p>x label</p>
</dd>
<dt><code>ylab</code></dt><dd><p>y label</p>
</dd>
<dt><code>xmin</code></dt><dd><p>xmin</p>
</dd>
<dt><code>xmax</code></dt><dd><p>xmax</p>
</dd>
<dt><code>ymin</code></dt><dd><p>ymin</p>
</dd>
<dt><code>ymax</code></dt><dd><p>ymax</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-plot2D"></a>



<h4>Method <code>plot2D()</code></h4>

<p>Make 2D plot
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_base$plot2D()</pre></div>


<hr>
<a id="method-GauPro-loglikelihood"></a>



<h4>Method <code>loglikelihood()</code></h4>

<p>Calculate the log likelihood, don't use this
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_base$loglikelihood(mu = self$mu_hat, s2 = self$s2_hat)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>mu</code></dt><dd><p>Mean vector</p>
</dd>
<dt><code>s2</code></dt><dd><p>s2 param</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-optim"></a>



<h4>Method <code>optim()</code></h4>

<p>Optimize parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_base$optim(
  restarts = 5,
  param_update = T,
  nug.update = self$nug.est,
  parallel = self$parallel,
  parallel_cores = self$parallel_cores
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>restarts</code></dt><dd><p>Number of restarts to do</p>
</dd>
<dt><code>param_update</code></dt><dd><p>Should parameters be updated?</p>
</dd>
<dt><code>nug.update</code></dt><dd><p>Should nugget be updated?</p>
</dd>
<dt><code>parallel</code></dt><dd><p>Should restarts be done in parallel?</p>
</dd>
<dt><code>parallel_cores</code></dt><dd><p>If running parallel, how many cores should be used?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-optimRestart"></a>



<h4>Method <code>optimRestart()</code></h4>

<p>Run a single optimization restart.
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_base$optimRestart(
  start.par,
  start.par0,
  param_update,
  nug.update,
  optim.func,
  optim.grad,
  optim.fngr,
  lower,
  upper,
  jit = T
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>start.par</code></dt><dd><p>Starting parameters</p>
</dd>
<dt><code>start.par0</code></dt><dd><p>Starting parameters</p>
</dd>
<dt><code>param_update</code></dt><dd><p>Should parameters be updated?</p>
</dd>
<dt><code>nug.update</code></dt><dd><p>Should nugget be updated?</p>
</dd>
<dt><code>optim.func</code></dt><dd><p>Function to optimize.</p>
</dd>
<dt><code>optim.grad</code></dt><dd><p>Gradient of function to optimize.</p>
</dd>
<dt><code>optim.fngr</code></dt><dd><p>Function that returns the function value
and its gradient.</p>
</dd>
<dt><code>lower</code></dt><dd><p>Lower bounds for optimization</p>
</dd>
<dt><code>upper</code></dt><dd><p>Upper bounds for optimization</p>
</dd>
<dt><code>jit</code></dt><dd><p>Is jitter being used?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-update"></a>



<h4>Method <code>update()</code></h4>

<p>Update the model, can be data and parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_base$update(
  Xnew = NULL,
  Znew = NULL,
  Xall = NULL,
  Zall = NULL,
  restarts = 5,
  param_update = self$param.est,
  nug.update = self$nug.est,
  no_update = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Xnew</code></dt><dd><p>New X matrix</p>
</dd>
<dt><code>Znew</code></dt><dd><p>New Z values</p>
</dd>
<dt><code>Xall</code></dt><dd><p>Matrix with all X values</p>
</dd>
<dt><code>Zall</code></dt><dd><p>All Z values</p>
</dd>
<dt><code>restarts</code></dt><dd><p>Number of optimization restarts</p>
</dd>
<dt><code>param_update</code></dt><dd><p>Should the parameters be updated?</p>
</dd>
<dt><code>nug.update</code></dt><dd><p>Should the nugget be updated?</p>
</dd>
<dt><code>no_update</code></dt><dd><p>Should none of the parameters/nugget be updated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-update_data"></a>



<h4>Method <code>update_data()</code></h4>

<p>Update the data
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_base$update_data(Xnew = NULL, Znew = NULL, Xall = NULL, Zall = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Xnew</code></dt><dd><p>New X matrix</p>
</dd>
<dt><code>Znew</code></dt><dd><p>New Z values</p>
</dd>
<dt><code>Xall</code></dt><dd><p>Matrix with all X values</p>
</dd>
<dt><code>Zall</code></dt><dd><p>All Z values</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-update_corrparams"></a>



<h4>Method <code>update_corrparams()</code></h4>

<p>Update the correlation parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_base$update_corrparams(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Args passed to update</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-update_nugget"></a>



<h4>Method <code>update_nugget()</code></h4>

<p>Update the nugget
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_base$update_nugget(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Args passed to update</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-deviance_searchnug"></a>



<h4>Method <code>deviance_searchnug()</code></h4>

<p>Optimize deviance for nugget
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_base$deviance_searchnug()</pre></div>


<hr>
<a id="method-GauPro-nugget_update"></a>



<h4>Method <code>nugget_update()</code></h4>

<p>Update the nugget
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_base$nugget_update()</pre></div>


<hr>
<a id="method-GauPro-grad_norm"></a>



<h4>Method <code>grad_norm()</code></h4>

<p>Calculate the norm of the gradient at XX
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_base$grad_norm(XX)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>Points to calculate at</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-sample"></a>



<h4>Method <code>sample()</code></h4>

<p>Sample at XX
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_base$sample(XX, n = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>Input points to sample at</p>
</dd>
<dt><code>n</code></dt><dd><p>Number of samples</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print object
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_base$print()</pre></div>


<hr>
<a id="method-GauPro-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_base$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>#n &lt;- 12
#x &lt;- matrix(seq(0,1,length.out = n), ncol=1)
#y &lt;- sin(2*pi*x) + rnorm(n,0,1e-1)
#gp &lt;- GauPro(X=x, Z=y, parallel=FALSE)
</code></pre>

<hr>
<h2 id='GauPro_Gauss'>Corr Gauss GP using inherited optim</h2><span id='topic+GauPro_Gauss'></span>

<h3>Description</h3>

<p>Corr Gauss GP using inherited optim
</p>
<p>Corr Gauss GP using inherited optim
</p>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Value</h3>

<p>Object of <code><a href="R6.html#topic+R6Class">R6Class</a></code> with methods for fitting GP model.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+GauPro">GauPro::GauPro</a></code> -&gt; <code>GauPro_Gauss</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>corr</code></dt><dd><p>Name of correlation</p>
</dd>
<dt><code>theta</code></dt><dd><p>Correlation parameters</p>
</dd>
<dt><code>theta_length</code></dt><dd><p>Length of theta</p>
</dd>
<dt><code>theta_map</code></dt><dd><p>Map for theta</p>
</dd>
<dt><code>theta_short</code></dt><dd><p>Short vector for theta</p>
</dd>
<dt><code>separable</code></dt><dd><p>Are the dimensions separable?</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GauPro_Gauss-new"><code>GauPro_Gauss$new()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_Gauss-corr_func"><code>GauPro_Gauss$corr_func()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_Gauss-deviance_theta"><code>GauPro_Gauss$deviance_theta()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_Gauss-deviance_theta_log"><code>GauPro_Gauss$deviance_theta_log()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_Gauss-deviance"><code>GauPro_Gauss$deviance()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_Gauss-deviance_grad"><code>GauPro_Gauss$deviance_grad()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_Gauss-deviance_fngr"><code>GauPro_Gauss$deviance_fngr()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_Gauss-deviance_log"><code>GauPro_Gauss$deviance_log()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_Gauss-deviance_log2"><code>GauPro_Gauss$deviance_log2()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_Gauss-deviance_log_grad"><code>GauPro_Gauss$deviance_log_grad()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_Gauss-deviance_log2_grad"><code>GauPro_Gauss$deviance_log2_grad()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_Gauss-deviance_log2_fngr"><code>GauPro_Gauss$deviance_log2_fngr()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_Gauss-get_optim_functions"><code>GauPro_Gauss$get_optim_functions()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_Gauss-param_optim_lower"><code>GauPro_Gauss$param_optim_lower()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_Gauss-param_optim_upper"><code>GauPro_Gauss$param_optim_upper()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_Gauss-param_optim_start"><code>GauPro_Gauss$param_optim_start()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_Gauss-param_optim_start0"><code>GauPro_Gauss$param_optim_start0()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_Gauss-param_optim_jitter"><code>GauPro_Gauss$param_optim_jitter()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_Gauss-update_params"><code>GauPro_Gauss$update_params()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_Gauss-grad"><code>GauPro_Gauss$grad()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_Gauss-grad_dist"><code>GauPro_Gauss$grad_dist()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_Gauss-hessian"><code>GauPro_Gauss$hessian()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_Gauss-print"><code>GauPro_Gauss$print()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_Gauss-clone"><code>GauPro_Gauss$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="cool1Dplot"><a href='../../GauPro/html/GauPro.html#method-GauPro-cool1Dplot'><code>GauPro::GauPro$cool1Dplot()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="deviance_searchnug"><a href='../../GauPro/html/GauPro.html#method-GauPro-deviance_searchnug'><code>GauPro::GauPro$deviance_searchnug()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="fit"><a href='../../GauPro/html/GauPro.html#method-GauPro-fit'><code>GauPro::GauPro$fit()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="grad_norm"><a href='../../GauPro/html/GauPro.html#method-GauPro-grad_norm'><code>GauPro::GauPro$grad_norm()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="initialize_GauPr"><a href='../../GauPro/html/GauPro.html#method-GauPro-initialize_GauPr'><code>GauPro::GauPro$initialize_GauPr()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="loglikelihood"><a href='../../GauPro/html/GauPro.html#method-GauPro-loglikelihood'><code>GauPro::GauPro$loglikelihood()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="nugget_update"><a href='../../GauPro/html/GauPro.html#method-GauPro-nugget_update'><code>GauPro::GauPro$nugget_update()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="optim"><a href='../../GauPro/html/GauPro.html#method-GauPro-optim'><code>GauPro::GauPro$optim()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="optimRestart"><a href='../../GauPro/html/GauPro.html#method-GauPro-optimRestart'><code>GauPro::GauPro$optimRestart()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="plot"><a href='../../GauPro/html/GauPro.html#method-GauPro-plot'><code>GauPro::GauPro$plot()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="plot1D"><a href='../../GauPro/html/GauPro.html#method-GauPro-plot1D'><code>GauPro::GauPro$plot1D()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="plot2D"><a href='../../GauPro/html/GauPro.html#method-GauPro-plot2D'><code>GauPro::GauPro$plot2D()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="pred"><a href='../../GauPro/html/GauPro.html#method-GauPro-pred'><code>GauPro::GauPro$pred()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="pred_LOO"><a href='../../GauPro/html/GauPro.html#method-GauPro-pred_LOO'><code>GauPro::GauPro$pred_LOO()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="pred_mean"><a href='../../GauPro/html/GauPro.html#method-GauPro-pred_mean'><code>GauPro::GauPro$pred_mean()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="pred_meanC"><a href='../../GauPro/html/GauPro.html#method-GauPro-pred_meanC'><code>GauPro::GauPro$pred_meanC()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="pred_one_matrix"><a href='../../GauPro/html/GauPro.html#method-GauPro-pred_one_matrix'><code>GauPro::GauPro$pred_one_matrix()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="pred_var"><a href='../../GauPro/html/GauPro.html#method-GauPro-pred_var'><code>GauPro::GauPro$pred_var()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="predict"><a href='../../GauPro/html/GauPro.html#method-GauPro-predict'><code>GauPro::GauPro$predict()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="sample"><a href='../../GauPro/html/GauPro.html#method-GauPro-sample'><code>GauPro::GauPro$sample()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="update"><a href='../../GauPro/html/GauPro.html#method-GauPro-update'><code>GauPro::GauPro$update()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="update_K_and_estimates"><a href='../../GauPro/html/GauPro.html#method-GauPro-update_K_and_estimates'><code>GauPro::GauPro$update_K_and_estimates()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="update_corrparams"><a href='../../GauPro/html/GauPro.html#method-GauPro-update_corrparams'><code>GauPro::GauPro$update_corrparams()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="update_data"><a href='../../GauPro/html/GauPro.html#method-GauPro-update_data'><code>GauPro::GauPro$update_data()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="update_nugget"><a href='../../GauPro/html/GauPro.html#method-GauPro-update_nugget'><code>GauPro::GauPro$update_nugget()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-GauPro_Gauss-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create GauPro object
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_Gauss$new(
  X,
  Z,
  verbose = 0,
  separable = T,
  useC = F,
  useGrad = T,
  parallel = FALSE,
  nug = 1e-06,
  nug.min = 1e-08,
  nug.est = T,
  param.est = T,
  theta = NULL,
  theta_short = NULL,
  theta_map = NULL,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X</code></dt><dd><p>Matrix whose rows are the input points</p>
</dd>
<dt><code>Z</code></dt><dd><p>Output points corresponding to X</p>
</dd>
<dt><code>verbose</code></dt><dd><p>Amount of stuff to print. 0 is little, 2 is a lot.</p>
</dd>
<dt><code>separable</code></dt><dd><p>Are dimensions separable?</p>
</dd>
<dt><code>useC</code></dt><dd><p>Should C code be used when possible? Should be faster.</p>
</dd>
<dt><code>useGrad</code></dt><dd><p>Should the gradient be used?</p>
</dd>
<dt><code>parallel</code></dt><dd><p>Should code be run in parallel? Make optimization
faster but uses more computer resources.</p>
</dd>
<dt><code>nug</code></dt><dd><p>Value for the nugget. The starting value if estimating it.</p>
</dd>
<dt><code>nug.min</code></dt><dd><p>Minimum allowable value for the nugget.</p>
</dd>
<dt><code>nug.est</code></dt><dd><p>Should the nugget be estimated?</p>
</dd>
<dt><code>param.est</code></dt><dd><p>Should the kernel parameters be estimated?</p>
</dd>
<dt><code>theta</code></dt><dd><p>Correlation parameters</p>
</dd>
<dt><code>theta_short</code></dt><dd><p>Correlation parameters, not recommended</p>
</dd>
<dt><code>theta_map</code></dt><dd><p>Correlation parameters, not recommended</p>
</dd>
<dt><code>...</code></dt><dd><p>Not used</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_Gauss-corr_func"></a>



<h4>Method <code>corr_func()</code></h4>

<p>Correlation function
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_Gauss$corr_func(x, x2 = NULL, theta = self$theta)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>First point</p>
</dd>
<dt><code>x2</code></dt><dd><p>Second point</p>
</dd>
<dt><code>theta</code></dt><dd><p>Correlation parameter</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_Gauss-deviance_theta"></a>



<h4>Method <code>deviance_theta()</code></h4>

<p>Calculate deviance
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_Gauss$deviance_theta(theta)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>theta</code></dt><dd><p>Correlation parameter</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_Gauss-deviance_theta_log"></a>



<h4>Method <code>deviance_theta_log()</code></h4>

<p>Calculate deviance
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_Gauss$deviance_theta_log(beta)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>beta</code></dt><dd><p>Correlation parameter on log scale</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_Gauss-deviance"></a>



<h4>Method <code>deviance()</code></h4>

<p>Calculate deviance
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_Gauss$deviance(theta = self$theta, nug = self$nug)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>theta</code></dt><dd><p>Correlation parameter</p>
</dd>
<dt><code>nug</code></dt><dd><p>Nugget</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_Gauss-deviance_grad"></a>



<h4>Method <code>deviance_grad()</code></h4>

<p>Calculate deviance gradient
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_Gauss$deviance_grad(
  theta = NULL,
  nug = self$nug,
  joint = NULL,
  overwhat = if (self$nug.est) "joint" else "theta"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>theta</code></dt><dd><p>Correlation parameter</p>
</dd>
<dt><code>nug</code></dt><dd><p>Nugget</p>
</dd>
<dt><code>joint</code></dt><dd><p>Calculate over theta and nug at same time?</p>
</dd>
<dt><code>overwhat</code></dt><dd><p>Calculate over theta and nug at same time?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_Gauss-deviance_fngr"></a>



<h4>Method <code>deviance_fngr()</code></h4>

<p>Calculate deviance and gradient at same time
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_Gauss$deviance_fngr(
  theta = NULL,
  nug = NULL,
  overwhat = if (self$nug.est) "joint" else "theta"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>theta</code></dt><dd><p>Correlation parameter</p>
</dd>
<dt><code>nug</code></dt><dd><p>Nugget</p>
</dd>
<dt><code>overwhat</code></dt><dd><p>Calculate over theta and nug at same time?</p>
</dd>
<dt><code>joint</code></dt><dd><p>Calculate over theta and nug at same time?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_Gauss-deviance_log"></a>



<h4>Method <code>deviance_log()</code></h4>

<p>Calculate deviance gradient
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_Gauss$deviance_log(beta = NULL, nug = self$nug, joint = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>beta</code></dt><dd><p>Correlation parameter on log scale</p>
</dd>
<dt><code>nug</code></dt><dd><p>Nugget</p>
</dd>
<dt><code>joint</code></dt><dd><p>Calculate over theta and nug at same time?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_Gauss-deviance_log2"></a>



<h4>Method <code>deviance_log2()</code></h4>

<p>Calculate deviance on log scale
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_Gauss$deviance_log2(beta = NULL, lognug = NULL, joint = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>beta</code></dt><dd><p>Correlation parameter on log scale</p>
</dd>
<dt><code>lognug</code></dt><dd><p>Log of nugget</p>
</dd>
<dt><code>joint</code></dt><dd><p>Calculate over theta and nug at same time?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_Gauss-deviance_log_grad"></a>



<h4>Method <code>deviance_log_grad()</code></h4>

<p>Calculate deviance gradient on log scale
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_Gauss$deviance_log_grad(
  beta = NULL,
  nug = self$nug,
  joint = NULL,
  overwhat = if (self$nug.est) "joint" else "theta"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>beta</code></dt><dd><p>Correlation parameter</p>
</dd>
<dt><code>nug</code></dt><dd><p>Nugget</p>
</dd>
<dt><code>joint</code></dt><dd><p>Calculate over theta and nug at same time?</p>
</dd>
<dt><code>overwhat</code></dt><dd><p>Calculate over theta and nug at same time?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_Gauss-deviance_log2_grad"></a>



<h4>Method <code>deviance_log2_grad()</code></h4>

<p>Calculate deviance gradient on log scale
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_Gauss$deviance_log2_grad(
  beta = NULL,
  lognug = NULL,
  joint = NULL,
  overwhat = if (self$nug.est) "joint" else "theta"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>beta</code></dt><dd><p>Correlation parameter</p>
</dd>
<dt><code>lognug</code></dt><dd><p>Log of nugget</p>
</dd>
<dt><code>joint</code></dt><dd><p>Calculate over theta and nug at same time?</p>
</dd>
<dt><code>overwhat</code></dt><dd><p>Calculate over theta and nug at same time?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_Gauss-deviance_log2_fngr"></a>



<h4>Method <code>deviance_log2_fngr()</code></h4>

<p>Calculate deviance and gradient on log scale
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_Gauss$deviance_log2_fngr(
  beta = NULL,
  lognug = NULL,
  joint = NULL,
  overwhat = if (self$nug.est) "joint" else "theta"
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>beta</code></dt><dd><p>Correlation parameter</p>
</dd>
<dt><code>lognug</code></dt><dd><p>Log of nugget</p>
</dd>
<dt><code>joint</code></dt><dd><p>Calculate over theta and nug at same time?</p>
</dd>
<dt><code>overwhat</code></dt><dd><p>Calculate over theta and nug at same time?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_Gauss-get_optim_functions"></a>



<h4>Method <code>get_optim_functions()</code></h4>

<p>Get optimization functions
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_Gauss$get_optim_functions(param_update, nug.update)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param_update</code></dt><dd><p>Should the parameters be updated?</p>
</dd>
<dt><code>nug.update</code></dt><dd><p>Should the nugget be updated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_Gauss-param_optim_lower"></a>



<h4>Method <code>param_optim_lower()</code></h4>

<p>Lower bound of params
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_Gauss$param_optim_lower()</pre></div>


<hr>
<a id="method-GauPro_Gauss-param_optim_upper"></a>



<h4>Method <code>param_optim_upper()</code></h4>

<p>Upper bound of params
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_Gauss$param_optim_upper()</pre></div>


<hr>
<a id="method-GauPro_Gauss-param_optim_start"></a>



<h4>Method <code>param_optim_start()</code></h4>

<p>Start value of params for optim
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_Gauss$param_optim_start()</pre></div>


<hr>
<a id="method-GauPro_Gauss-param_optim_start0"></a>



<h4>Method <code>param_optim_start0()</code></h4>

<p>Start value of params for optim
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_Gauss$param_optim_start0()</pre></div>


<hr>
<a id="method-GauPro_Gauss-param_optim_jitter"></a>



<h4>Method <code>param_optim_jitter()</code></h4>

<p>Jitter value of params for optim
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_Gauss$param_optim_jitter(param_value)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param_value</code></dt><dd><p>param value to add jitter to</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_Gauss-update_params"></a>



<h4>Method <code>update_params()</code></h4>

<p>Update value of params after optim
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_Gauss$update_params(restarts, param_update, nug.update)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>restarts</code></dt><dd><p>Number of restarts</p>
</dd>
<dt><code>param_update</code></dt><dd><p>Are the params being updated?</p>
</dd>
<dt><code>nug.update</code></dt><dd><p>Is the nugget being updated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_Gauss-grad"></a>



<h4>Method <code>grad()</code></h4>

<p>Calculate the gradient
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_Gauss$grad(XX)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>Points to calculate grad at</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_Gauss-grad_dist"></a>



<h4>Method <code>grad_dist()</code></h4>

<p>Calculate the gradient distribution
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_Gauss$grad_dist(XX)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>Points to calculate grad at</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_Gauss-hessian"></a>



<h4>Method <code>hessian()</code></h4>

<p>Calculate the hessian
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_Gauss$hessian(XX, useC = self$useC)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>Points to calculate grad at</p>
</dd>
<dt><code>useC</code></dt><dd><p>Should C code be used to speed up?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_Gauss-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print this object
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_Gauss$print()</pre></div>


<hr>
<a id="method-GauPro_Gauss-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_Gauss$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 12
x &lt;- matrix(seq(0,1,length.out = n), ncol=1)
y &lt;- sin(2*pi*x) + rnorm(n,0,1e-1)
gp &lt;- GauPro_Gauss$new(X=x, Z=y, parallel=FALSE)
</code></pre>

<hr>
<h2 id='GauPro_Gauss_LOO'>Corr Gauss GP using inherited optim</h2><span id='topic+GauPro_Gauss_LOO'></span>

<h3>Description</h3>

<p>Corr Gauss GP using inherited optim
</p>
<p>Corr Gauss GP using inherited optim
</p>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Value</h3>

<p>Object of <code><a href="R6.html#topic+R6Class">R6Class</a></code> with methods for fitting GP model.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+GauPro">GauPro::GauPro</a></code> -&gt; <code><a href="#topic+GauPro_Gauss">GauPro::GauPro_Gauss</a></code> -&gt; <code>GauPro_Gauss_LOO</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>use_LOO</code></dt><dd><p>Should the leave-one-out correction be used?</p>
</dd>
<dt><code>tmod</code></dt><dd><p>Second GP model fit to the t-values of leave-one-out predictions</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GauPro_Gauss_LOO-update"><code>GauPro_Gauss_LOO$update()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_Gauss_LOO-pred_one_matrix"><code>GauPro_Gauss_LOO$pred_one_matrix()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_Gauss_LOO-print"><code>GauPro_Gauss_LOO$print()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_Gauss_LOO-clone"><code>GauPro_Gauss_LOO$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="cool1Dplot"><a href='../../GauPro/html/GauPro.html#method-GauPro-cool1Dplot'><code>GauPro::GauPro$cool1Dplot()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="deviance_searchnug"><a href='../../GauPro/html/GauPro.html#method-GauPro-deviance_searchnug'><code>GauPro::GauPro$deviance_searchnug()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="fit"><a href='../../GauPro/html/GauPro.html#method-GauPro-fit'><code>GauPro::GauPro$fit()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="grad_norm"><a href='../../GauPro/html/GauPro.html#method-GauPro-grad_norm'><code>GauPro::GauPro$grad_norm()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="initialize_GauPr"><a href='../../GauPro/html/GauPro.html#method-GauPro-initialize_GauPr'><code>GauPro::GauPro$initialize_GauPr()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="loglikelihood"><a href='../../GauPro/html/GauPro.html#method-GauPro-loglikelihood'><code>GauPro::GauPro$loglikelihood()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="nugget_update"><a href='../../GauPro/html/GauPro.html#method-GauPro-nugget_update'><code>GauPro::GauPro$nugget_update()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="optim"><a href='../../GauPro/html/GauPro.html#method-GauPro-optim'><code>GauPro::GauPro$optim()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="optimRestart"><a href='../../GauPro/html/GauPro.html#method-GauPro-optimRestart'><code>GauPro::GauPro$optimRestart()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="plot"><a href='../../GauPro/html/GauPro.html#method-GauPro-plot'><code>GauPro::GauPro$plot()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="plot1D"><a href='../../GauPro/html/GauPro.html#method-GauPro-plot1D'><code>GauPro::GauPro$plot1D()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="plot2D"><a href='../../GauPro/html/GauPro.html#method-GauPro-plot2D'><code>GauPro::GauPro$plot2D()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="pred"><a href='../../GauPro/html/GauPro.html#method-GauPro-pred'><code>GauPro::GauPro$pred()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="pred_LOO"><a href='../../GauPro/html/GauPro.html#method-GauPro-pred_LOO'><code>GauPro::GauPro$pred_LOO()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="pred_mean"><a href='../../GauPro/html/GauPro.html#method-GauPro-pred_mean'><code>GauPro::GauPro$pred_mean()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="pred_meanC"><a href='../../GauPro/html/GauPro.html#method-GauPro-pred_meanC'><code>GauPro::GauPro$pred_meanC()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="pred_var"><a href='../../GauPro/html/GauPro.html#method-GauPro-pred_var'><code>GauPro::GauPro$pred_var()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="predict"><a href='../../GauPro/html/GauPro.html#method-GauPro-predict'><code>GauPro::GauPro$predict()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="sample"><a href='../../GauPro/html/GauPro.html#method-GauPro-sample'><code>GauPro::GauPro$sample()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="update_K_and_estimates"><a href='../../GauPro/html/GauPro.html#method-GauPro-update_K_and_estimates'><code>GauPro::GauPro$update_K_and_estimates()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="update_corrparams"><a href='../../GauPro/html/GauPro.html#method-GauPro-update_corrparams'><code>GauPro::GauPro$update_corrparams()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="update_data"><a href='../../GauPro/html/GauPro.html#method-GauPro-update_data'><code>GauPro::GauPro$update_data()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="update_nugget"><a href='../../GauPro/html/GauPro.html#method-GauPro-update_nugget'><code>GauPro::GauPro$update_nugget()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_Gauss" data-id="corr_func"><a href='../../GauPro/html/GauPro_Gauss.html#method-GauPro_Gauss-corr_func'><code>GauPro::GauPro_Gauss$corr_func()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_Gauss" data-id="deviance"><a href='../../GauPro/html/GauPro_Gauss.html#method-GauPro_Gauss-deviance'><code>GauPro::GauPro_Gauss$deviance()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_Gauss" data-id="deviance_fngr"><a href='../../GauPro/html/GauPro_Gauss.html#method-GauPro_Gauss-deviance_fngr'><code>GauPro::GauPro_Gauss$deviance_fngr()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_Gauss" data-id="deviance_grad"><a href='../../GauPro/html/GauPro_Gauss.html#method-GauPro_Gauss-deviance_grad'><code>GauPro::GauPro_Gauss$deviance_grad()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_Gauss" data-id="deviance_log"><a href='../../GauPro/html/GauPro_Gauss.html#method-GauPro_Gauss-deviance_log'><code>GauPro::GauPro_Gauss$deviance_log()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_Gauss" data-id="deviance_log2"><a href='../../GauPro/html/GauPro_Gauss.html#method-GauPro_Gauss-deviance_log2'><code>GauPro::GauPro_Gauss$deviance_log2()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_Gauss" data-id="deviance_log2_fngr"><a href='../../GauPro/html/GauPro_Gauss.html#method-GauPro_Gauss-deviance_log2_fngr'><code>GauPro::GauPro_Gauss$deviance_log2_fngr()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_Gauss" data-id="deviance_log2_grad"><a href='../../GauPro/html/GauPro_Gauss.html#method-GauPro_Gauss-deviance_log2_grad'><code>GauPro::GauPro_Gauss$deviance_log2_grad()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_Gauss" data-id="deviance_log_grad"><a href='../../GauPro/html/GauPro_Gauss.html#method-GauPro_Gauss-deviance_log_grad'><code>GauPro::GauPro_Gauss$deviance_log_grad()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_Gauss" data-id="deviance_theta"><a href='../../GauPro/html/GauPro_Gauss.html#method-GauPro_Gauss-deviance_theta'><code>GauPro::GauPro_Gauss$deviance_theta()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_Gauss" data-id="deviance_theta_log"><a href='../../GauPro/html/GauPro_Gauss.html#method-GauPro_Gauss-deviance_theta_log'><code>GauPro::GauPro_Gauss$deviance_theta_log()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_Gauss" data-id="get_optim_functions"><a href='../../GauPro/html/GauPro_Gauss.html#method-GauPro_Gauss-get_optim_functions'><code>GauPro::GauPro_Gauss$get_optim_functions()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_Gauss" data-id="grad"><a href='../../GauPro/html/GauPro_Gauss.html#method-GauPro_Gauss-grad'><code>GauPro::GauPro_Gauss$grad()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_Gauss" data-id="grad_dist"><a href='../../GauPro/html/GauPro_Gauss.html#method-GauPro_Gauss-grad_dist'><code>GauPro::GauPro_Gauss$grad_dist()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_Gauss" data-id="hessian"><a href='../../GauPro/html/GauPro_Gauss.html#method-GauPro_Gauss-hessian'><code>GauPro::GauPro_Gauss$hessian()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_Gauss" data-id="initialize"><a href='../../GauPro/html/GauPro_Gauss.html#method-GauPro_Gauss-initialize'><code>GauPro::GauPro_Gauss$initialize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_Gauss" data-id="param_optim_jitter"><a href='../../GauPro/html/GauPro_Gauss.html#method-GauPro_Gauss-param_optim_jitter'><code>GauPro::GauPro_Gauss$param_optim_jitter()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_Gauss" data-id="param_optim_lower"><a href='../../GauPro/html/GauPro_Gauss.html#method-GauPro_Gauss-param_optim_lower'><code>GauPro::GauPro_Gauss$param_optim_lower()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_Gauss" data-id="param_optim_start"><a href='../../GauPro/html/GauPro_Gauss.html#method-GauPro_Gauss-param_optim_start'><code>GauPro::GauPro_Gauss$param_optim_start()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_Gauss" data-id="param_optim_start0"><a href='../../GauPro/html/GauPro_Gauss.html#method-GauPro_Gauss-param_optim_start0'><code>GauPro::GauPro_Gauss$param_optim_start0()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_Gauss" data-id="param_optim_upper"><a href='../../GauPro/html/GauPro_Gauss.html#method-GauPro_Gauss-param_optim_upper'><code>GauPro::GauPro_Gauss$param_optim_upper()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_Gauss" data-id="update_params"><a href='../../GauPro/html/GauPro_Gauss.html#method-GauPro_Gauss-update_params'><code>GauPro::GauPro_Gauss$update_params()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-GauPro_Gauss_LOO-update"></a>



<h4>Method <code>update()</code></h4>

<p>Update the model, can be data and parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_Gauss_LOO$update(
  Xnew = NULL,
  Znew = NULL,
  Xall = NULL,
  Zall = NULL,
  restarts = 5,
  param_update = self$param.est,
  nug.update = self$nug.est,
  no_update = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Xnew</code></dt><dd><p>New X matrix</p>
</dd>
<dt><code>Znew</code></dt><dd><p>New Z values</p>
</dd>
<dt><code>Xall</code></dt><dd><p>Matrix with all X values</p>
</dd>
<dt><code>Zall</code></dt><dd><p>All Z values</p>
</dd>
<dt><code>restarts</code></dt><dd><p>Number of optimization restarts</p>
</dd>
<dt><code>param_update</code></dt><dd><p>Should the parameters be updated?</p>
</dd>
<dt><code>nug.update</code></dt><dd><p>Should the nugget be updated?</p>
</dd>
<dt><code>no_update</code></dt><dd><p>Should none of the parameters/nugget be updated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_Gauss_LOO-pred_one_matrix"></a>



<h4>Method <code>pred_one_matrix()</code></h4>

<p>Predict mean and se for given matrix
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_Gauss_LOO$pred_one_matrix(XX, se.fit = F, covmat = F)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>Points to predict at</p>
</dd>
<dt><code>se.fit</code></dt><dd><p>Should the se be returned?</p>
</dd>
<dt><code>covmat</code></dt><dd><p>Should the covariance matrix be returned?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_Gauss_LOO-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print this object
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_Gauss_LOO$print()</pre></div>


<hr>
<a id="method-GauPro_Gauss_LOO-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_Gauss_LOO$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 12
x &lt;- matrix(seq(0,1,length.out = n), ncol=1)
y &lt;- sin(2*pi*x) + rnorm(n,0,1e-1)
gp &lt;- GauPro_Gauss_LOO$new(X=x, Z=y, parallel=FALSE)
</code></pre>

<hr>
<h2 id='GauPro_kernel'>Kernel R6 class</h2><span id='topic+GauPro_kernel'></span>

<h3>Description</h3>

<p>Kernel R6 class
</p>
<p>Kernel R6 class
</p>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Value</h3>

<p>Object of <code><a href="R6.html#topic+R6Class">R6Class</a></code> with methods for fitting GP model.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>D</code></dt><dd><p>Number of input dimensions of data</p>
</dd>
<dt><code>useC</code></dt><dd><p>Should C code be used when possible? Can be much faster.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GauPro_kernel-plot"><code>GauPro_kernel$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel-print"><code>GauPro_kernel$print()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel-clone"><code>GauPro_kernel$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-GauPro_kernel-plot"></a>



<h4>Method <code>plot()</code></h4>

<p>Plot kernel decay.
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel$plot(X = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X</code></dt><dd><p>Matrix of points the kernel is used with. Some will be used
to demonstrate how the covariance changes.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print this object
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel$print()</pre></div>


<hr>
<a id="method-GauPro_kernel-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>#k &lt;- GauPro_kernel$new()
</code></pre>

<hr>
<h2 id='GauPro_kernel_beta'>Beta Kernel R6 class</h2><span id='topic+GauPro_kernel_beta'></span>

<h3>Description</h3>

<p>Beta Kernel R6 class
</p>
<p>Beta Kernel R6 class
</p>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Details</h3>

<p>This is the base structure for a kernel that uses beta = log10(theta)
for the lengthscale parameter.
It standardizes the params because they all use the same underlying
structure.
Kernels that inherit this only need to implement kone and dC_dparams.
</p>


<h3>Value</h3>

<p>Object of <code><a href="R6.html#topic+R6Class">R6Class</a></code> with methods for fitting GP model.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+GauPro_kernel">GauPro::GauPro_kernel</a></code> -&gt; <code>GauPro_kernel_beta</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>beta</code></dt><dd><p>Parameter for correlation. Log of theta.</p>
</dd>
<dt><code>beta_est</code></dt><dd><p>Should beta be estimated?</p>
</dd>
<dt><code>beta_lower</code></dt><dd><p>Lower bound of beta</p>
</dd>
<dt><code>beta_upper</code></dt><dd><p>Upper bound of beta</p>
</dd>
<dt><code>beta_length</code></dt><dd><p>length of beta</p>
</dd>
<dt><code>s2</code></dt><dd><p>variance</p>
</dd>
<dt><code>logs2</code></dt><dd><p>Log of s2</p>
</dd>
<dt><code>logs2_lower</code></dt><dd><p>Lower bound of logs2</p>
</dd>
<dt><code>logs2_upper</code></dt><dd><p>Upper bound of logs2</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Should s2 be estimated?</p>
</dd>
<dt><code>useC</code></dt><dd><p>Should C code used? Much faster.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GauPro_kernel_beta-new"><code>GauPro_kernel_beta$new()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_beta-k"><code>GauPro_kernel_beta$k()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_beta-kone"><code>GauPro_kernel_beta$kone()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_beta-param_optim_start"><code>GauPro_kernel_beta$param_optim_start()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_beta-param_optim_start0"><code>GauPro_kernel_beta$param_optim_start0()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_beta-param_optim_lower"><code>GauPro_kernel_beta$param_optim_lower()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_beta-param_optim_upper"><code>GauPro_kernel_beta$param_optim_upper()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_beta-set_params_from_optim"><code>GauPro_kernel_beta$set_params_from_optim()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_beta-C_dC_dparams"><code>GauPro_kernel_beta$C_dC_dparams()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_beta-s2_from_params"><code>GauPro_kernel_beta$s2_from_params()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_beta-clone"><code>GauPro_kernel_beta$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel" data-id="plot"><a href='../../GauPro/html/GauPro_kernel.html#method-GauPro_kernel-plot'><code>GauPro::GauPro_kernel$plot()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel" data-id="print"><a href='../../GauPro/html/GauPro_kernel.html#method-GauPro_kernel-print'><code>GauPro::GauPro_kernel$print()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-GauPro_kernel_beta-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize kernel object
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_beta$new(
  beta,
  s2 = 1,
  D,
  beta_lower = -8,
  beta_upper = 6,
  beta_est = TRUE,
  s2_lower = 1e-08,
  s2_upper = 1e+08,
  s2_est = TRUE,
  useC = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>beta</code></dt><dd><p>Initial beta value</p>
</dd>
<dt><code>s2</code></dt><dd><p>Initial variance</p>
</dd>
<dt><code>D</code></dt><dd><p>Number of input dimensions of data</p>
</dd>
<dt><code>beta_lower</code></dt><dd><p>Lower bound for beta</p>
</dd>
<dt><code>beta_upper</code></dt><dd><p>Upper bound for beta</p>
</dd>
<dt><code>beta_est</code></dt><dd><p>Should beta be estimated?</p>
</dd>
<dt><code>s2_lower</code></dt><dd><p>Lower bound for s2</p>
</dd>
<dt><code>s2_upper</code></dt><dd><p>Upper bound for s2</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Should s2 be estimated?</p>
</dd>
<dt><code>useC</code></dt><dd><p>Should C code used? Much faster.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_beta-k"></a>



<h4>Method <code>k()</code></h4>

<p>Calculate covariance between two points
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_beta$k(
  x,
  y = NULL,
  beta = self$beta,
  s2 = self$s2,
  params = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>vector.</p>
</dd>
<dt><code>y</code></dt><dd><p>vector, optional. If excluded, find correlation
of x with itself.</p>
</dd>
<dt><code>beta</code></dt><dd><p>Correlation parameters. Log of theta.</p>
</dd>
<dt><code>s2</code></dt><dd><p>Variance parameter.</p>
</dd>
<dt><code>params</code></dt><dd><p>parameters to use instead of beta and s2.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_beta-kone"></a>



<h4>Method <code>kone()</code></h4>

<p>Calculate covariance between two points
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_beta$kone(x, y, beta, theta, s2)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>vector.</p>
</dd>
<dt><code>y</code></dt><dd><p>vector.</p>
</dd>
<dt><code>beta</code></dt><dd><p>Correlation parameters. Log of theta.</p>
</dd>
<dt><code>theta</code></dt><dd><p>Correlation parameters.</p>
</dd>
<dt><code>s2</code></dt><dd><p>Variance parameter.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_beta-param_optim_start"></a>



<h4>Method <code>param_optim_start()</code></h4>

<p>Starting point for parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_beta$param_optim_start(
  jitter = F,
  y,
  beta_est = self$beta_est,
  s2_est = self$s2_est
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>jitter</code></dt><dd><p>Should there be a jitter?</p>
</dd>
<dt><code>y</code></dt><dd><p>Output</p>
</dd>
<dt><code>beta_est</code></dt><dd><p>Is beta being estimated?</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_beta-param_optim_start0"></a>



<h4>Method <code>param_optim_start0()</code></h4>

<p>Starting point for parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_beta$param_optim_start0(
  jitter = F,
  y,
  beta_est = self$beta_est,
  s2_est = self$s2_est
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>jitter</code></dt><dd><p>Should there be a jitter?</p>
</dd>
<dt><code>y</code></dt><dd><p>Output</p>
</dd>
<dt><code>beta_est</code></dt><dd><p>Is beta being estimated?</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_beta-param_optim_lower"></a>



<h4>Method <code>param_optim_lower()</code></h4>

<p>Upper bounds of parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_beta$param_optim_lower(
  beta_est = self$beta_est,
  s2_est = self$s2_est
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>beta_est</code></dt><dd><p>Is beta being estimated?</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
<dt><code>p_est</code></dt><dd><p>Is p being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_beta-param_optim_upper"></a>



<h4>Method <code>param_optim_upper()</code></h4>

<p>Upper bounds of parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_beta$param_optim_upper(
  beta_est = self$beta_est,
  s2_est = self$s2_est
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>beta_est</code></dt><dd><p>Is beta being estimated?</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
<dt><code>p_est</code></dt><dd><p>Is p being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_beta-set_params_from_optim"></a>



<h4>Method <code>set_params_from_optim()</code></h4>

<p>Set parameters from optimization output
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_beta$set_params_from_optim(
  optim_out,
  beta_est = self$beta_est,
  s2_est = self$s2_est
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>optim_out</code></dt><dd><p>Output from optimization</p>
</dd>
<dt><code>beta_est</code></dt><dd><p>Is beta being estimated?</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_beta-C_dC_dparams"></a>



<h4>Method <code>C_dC_dparams()</code></h4>

<p>Calculate covariance matrix and its derivative
with respect to parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_beta$C_dC_dparams(params = NULL, X, nug)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Kernel parameters</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points in rows</p>
</dd>
<dt><code>nug</code></dt><dd><p>Value of nugget</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_beta-s2_from_params"></a>



<h4>Method <code>s2_from_params()</code></h4>

<p>Get s2 from params vector
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_beta$s2_from_params(params, s2_est = self$s2_est)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>parameter vector</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_beta-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_beta$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>#k1 &lt;- Matern52$new(beta=0)
</code></pre>

<hr>
<h2 id='GauPro_kernel_model'>Gaussian process model with kernel</h2><span id='topic+GauPro_kernel_model'></span>

<h3>Description</h3>

<p>Class providing object with methods for fitting a GP model.
Allows for different kernel and trend functions to be used.
The object is an R6 object with many methods that can be called.
</p>
<p>'gpkm()' is equivalent to 'GauPro_kernel_model$new()', but is easier to type
and gives parameter autocomplete suggestions.
</p>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Value</h3>

<p>Object of <code><a href="R6.html#topic+R6Class">R6Class</a></code> with methods for fitting GP model.
</p>


<h3>Methods</h3>


<dl>
<dt><code>new(X, Z, corr="Gauss", verbose=0, separable=T, useC=F,
                  useGrad=T,
         parallel=T, nug.est=T, ...)</code></dt><dd>
<p>This method is used to create object of this
class with <code>X</code> and <code>Z</code> as the data.</p>
</dd>
<dt><code>update(Xnew=NULL, Znew=NULL, Xall=NULL, Zall=NULL,
restarts = 0,
param_update = T, nug.update = self$nug.est)</code></dt><dd><p>This method updates the
model, adding new data if given, then running optimization again.</p>
</dd>
</dl>



<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>X</code></dt><dd><p>Design matrix</p>
</dd>
<dt><code>Z</code></dt><dd><p>Responses</p>
</dd>
<dt><code>N</code></dt><dd><p>Number of data points</p>
</dd>
<dt><code>D</code></dt><dd><p>Dimension of data</p>
</dd>
<dt><code>nug.min</code></dt><dd><p>Minimum value of nugget</p>
</dd>
<dt><code>nug.max</code></dt><dd><p>Maximum value of the nugget.</p>
</dd>
<dt><code>nug.est</code></dt><dd><p>Should the nugget be estimated?</p>
</dd>
<dt><code>nug</code></dt><dd><p>Value of the nugget, is estimated unless told otherwise</p>
</dd>
<dt><code>param.est</code></dt><dd><p>Should the kernel parameters be estimated?</p>
</dd>
<dt><code>verbose</code></dt><dd><p>0 means nothing printed, 1 prints some, 2 prints most.</p>
</dd>
<dt><code>useGrad</code></dt><dd><p>Should grad be used?</p>
</dd>
<dt><code>useC</code></dt><dd><p>Should C code be used?</p>
</dd>
<dt><code>parallel</code></dt><dd><p>Should the code be run in parallel?</p>
</dd>
<dt><code>parallel_cores</code></dt><dd><p>How many cores are there? By default it detects.</p>
</dd>
<dt><code>kernel</code></dt><dd><p>The kernel to determine the correlations.</p>
</dd>
<dt><code>trend</code></dt><dd><p>The trend.</p>
</dd>
<dt><code>mu_hatX</code></dt><dd><p>Predicted trend value for each point in X.</p>
</dd>
<dt><code>s2_hat</code></dt><dd><p>Variance parameter estimate</p>
</dd>
<dt><code>K</code></dt><dd><p>Covariance matrix</p>
</dd>
<dt><code>Kchol</code></dt><dd><p>Cholesky factorization of K</p>
</dd>
<dt><code>Kinv</code></dt><dd><p>Inverse of K</p>
</dd>
<dt><code>Kinv_Z_minus_mu_hatX</code></dt><dd><p>K inverse times Z minus the predicted
trend at X.</p>
</dd>
<dt><code>restarts</code></dt><dd><p>Number of optimization restarts to do when updating.</p>
</dd>
<dt><code>normalize</code></dt><dd><p>Should the inputs be normalized?</p>
</dd>
<dt><code>normalize_mean</code></dt><dd><p>If using normalize, the mean of each column.</p>
</dd>
<dt><code>normalize_sd</code></dt><dd><p>If using normalize, the standard
deviation of each column.</p>
</dd>
<dt><code>optimizer</code></dt><dd><p>What algorithm should be used to optimize the
parameters.</p>
</dd>
<dt><code>track_optim</code></dt><dd><p>Should it track the parameters evaluated
while optimizing?</p>
</dd>
<dt><code>track_optim_inputs</code></dt><dd><p>If track_optim is TRUE,
this will keep a list of parameters evaluated.
View them with plot_track_optim.</p>
</dd>
<dt><code>track_optim_dev</code></dt><dd><p>If track_optim is TRUE,
this will keep a vector of the deviance values calculated
while optimizing parameters.
View them with plot_track_optim.</p>
</dd>
<dt><code>formula</code></dt><dd><p>Formula</p>
</dd>
<dt><code>convert_formula_data</code></dt><dd><p>List for storing data to convert data
using the formula</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GauPro-new"><code>GauPro_kernel_model$new()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-fit"><code>GauPro_kernel_model$fit()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-update_K_and_estimates"><code>GauPro_kernel_model$update_K_and_estimates()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-predict"><code>GauPro_kernel_model$predict()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-pred"><code>GauPro_kernel_model$pred()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-pred_one_matrix"><code>GauPro_kernel_model$pred_one_matrix()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-pred_mean"><code>GauPro_kernel_model$pred_mean()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-pred_meanC"><code>GauPro_kernel_model$pred_meanC()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-pred_var"><code>GauPro_kernel_model$pred_var()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-pred_LOO"><code>GauPro_kernel_model$pred_LOO()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-pred_var_after_adding_points"><code>GauPro_kernel_model$pred_var_after_adding_points()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-pred_var_after_adding_points_sep"><code>GauPro_kernel_model$pred_var_after_adding_points_sep()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-pred_var_reduction"><code>GauPro_kernel_model$pred_var_reduction()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-pred_var_reductions"><code>GauPro_kernel_model$pred_var_reductions()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-plot"><code>GauPro_kernel_model$plot()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-cool1Dplot"><code>GauPro_kernel_model$cool1Dplot()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-plot1D"><code>GauPro_kernel_model$plot1D()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-plot2D"><code>GauPro_kernel_model$plot2D()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-plotmarginal"><code>GauPro_kernel_model$plotmarginal()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-plotmarginalrandom"><code>GauPro_kernel_model$plotmarginalrandom()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-plotkernel"><code>GauPro_kernel_model$plotkernel()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-plotLOO"><code>GauPro_kernel_model$plotLOO()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-plot_track_optim"><code>GauPro_kernel_model$plot_track_optim()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-loglikelihood"><code>GauPro_kernel_model$loglikelihood()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-AIC"><code>GauPro_kernel_model$AIC()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-get_optim_functions"><code>GauPro_kernel_model$get_optim_functions()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-param_optim_lower"><code>GauPro_kernel_model$param_optim_lower()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-param_optim_upper"><code>GauPro_kernel_model$param_optim_upper()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-param_optim_start"><code>GauPro_kernel_model$param_optim_start()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-param_optim_start0"><code>GauPro_kernel_model$param_optim_start0()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-param_optim_start_mat"><code>GauPro_kernel_model$param_optim_start_mat()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-optim"><code>GauPro_kernel_model$optim()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-optimRestart"><code>GauPro_kernel_model$optimRestart()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-update"><code>GauPro_kernel_model$update()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-update_fast"><code>GauPro_kernel_model$update_fast()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-update_params"><code>GauPro_kernel_model$update_params()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-update_data"><code>GauPro_kernel_model$update_data()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-update_corrparams"><code>GauPro_kernel_model$update_corrparams()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-update_nugget"><code>GauPro_kernel_model$update_nugget()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-deviance"><code>GauPro_kernel_model$deviance()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-deviance_grad"><code>GauPro_kernel_model$deviance_grad()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-deviance_fngr"><code>GauPro_kernel_model$deviance_fngr()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-grad"><code>GauPro_kernel_model$grad()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-grad_norm"><code>GauPro_kernel_model$grad_norm()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-grad_dist"><code>GauPro_kernel_model$grad_dist()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-grad_sample"><code>GauPro_kernel_model$grad_sample()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-grad_norm2_mean"><code>GauPro_kernel_model$grad_norm2_mean()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-grad_norm2_dist"><code>GauPro_kernel_model$grad_norm2_dist()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-grad_norm2_sample"><code>GauPro_kernel_model$grad_norm2_sample()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-hessian"><code>GauPro_kernel_model$hessian()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-gradpredvar"><code>GauPro_kernel_model$gradpredvar()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-sample"><code>GauPro_kernel_model$sample()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-optimize_fn"><code>GauPro_kernel_model$optimize_fn()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-EI"><code>GauPro_kernel_model$EI()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-maxEI"><code>GauPro_kernel_model$maxEI()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-maxqEI"><code>GauPro_kernel_model$maxqEI()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-KG"><code>GauPro_kernel_model$KG()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-AugmentedEI"><code>GauPro_kernel_model$AugmentedEI()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-CorrectedEI"><code>GauPro_kernel_model$CorrectedEI()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-importance"><code>GauPro_kernel_model$importance()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-print"><code>GauPro_kernel_model$print()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-summary"><code>GauPro_kernel_model$summary()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro-clone"><code>GauPro_kernel_model$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-GauPro-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create kernel_model object
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$new(
  X,
  Z,
  kernel,
  trend,
  verbose = 0,
  useC = TRUE,
  useGrad = TRUE,
  parallel = FALSE,
  parallel_cores = "detect",
  nug = 1e-06,
  nug.min = 1e-08,
  nug.max = 100,
  nug.est = TRUE,
  param.est = TRUE,
  restarts = 0,
  normalize = FALSE,
  optimizer = "L-BFGS-B",
  track_optim = FALSE,
  formula,
  data,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X</code></dt><dd><p>Matrix whose rows are the input points</p>
</dd>
<dt><code>Z</code></dt><dd><p>Output points corresponding to X</p>
</dd>
<dt><code>kernel</code></dt><dd><p>The kernel to use. E.g., Gaussian$new().</p>
</dd>
<dt><code>trend</code></dt><dd><p>Trend to use. E.g., trend_constant$new().</p>
</dd>
<dt><code>verbose</code></dt><dd><p>Amount of stuff to print. 0 is little, 2 is a lot.</p>
</dd>
<dt><code>useC</code></dt><dd><p>Should C code be used when possible? Should be faster.</p>
</dd>
<dt><code>useGrad</code></dt><dd><p>Should the gradient be used?</p>
</dd>
<dt><code>parallel</code></dt><dd><p>Should code be run in parallel? Make optimization
faster but uses more computer resources.</p>
</dd>
<dt><code>parallel_cores</code></dt><dd><p>When using parallel, how many cores should
be used?</p>
</dd>
<dt><code>nug</code></dt><dd><p>Value for the nugget. The starting value if estimating it.</p>
</dd>
<dt><code>nug.min</code></dt><dd><p>Minimum allowable value for the nugget.</p>
</dd>
<dt><code>nug.max</code></dt><dd><p>Maximum allowable value for the nugget.</p>
</dd>
<dt><code>nug.est</code></dt><dd><p>Should the nugget be estimated?</p>
</dd>
<dt><code>param.est</code></dt><dd><p>Should the kernel parameters be estimated?</p>
</dd>
<dt><code>restarts</code></dt><dd><p>How many optimization restarts should be used when
estimating parameters?</p>
</dd>
<dt><code>normalize</code></dt><dd><p>Should the data be normalized?</p>
</dd>
<dt><code>optimizer</code></dt><dd><p>What algorithm should be used to optimize the
parameters.</p>
</dd>
<dt><code>track_optim</code></dt><dd><p>Should it track the parameters evaluated
while optimizing?</p>
</dd>
<dt><code>formula</code></dt><dd><p>Formula for the data if giving in a data frame.</p>
</dd>
<dt><code>data</code></dt><dd><p>Data frame of data. Use in conjunction with formula.</p>
</dd>
<dt><code>...</code></dt><dd><p>Not used</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-fit"></a>



<h4>Method <code>fit()</code></h4>

<p>Fit model
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$fit(X, Z)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X</code></dt><dd><p>Inputs</p>
</dd>
<dt><code>Z</code></dt><dd><p>Outputs</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-update_K_and_estimates"></a>



<h4>Method <code>update_K_and_estimates()</code></h4>

<p>Update covariance matrix and estimates
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$update_K_and_estimates()</pre></div>


<hr>
<a id="method-GauPro-predict"></a>



<h4>Method <code>predict()</code></h4>

<p>Predict for a matrix of points
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$predict(
  XX,
  se.fit = F,
  covmat = F,
  split_speed = F,
  mean_dist = FALSE,
  return_df = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>points to predict at</p>
</dd>
<dt><code>se.fit</code></dt><dd><p>Should standard error be returned?</p>
</dd>
<dt><code>covmat</code></dt><dd><p>Should covariance matrix be returned?</p>
</dd>
<dt><code>split_speed</code></dt><dd><p>Should the matrix be split for faster predictions?</p>
</dd>
<dt><code>mean_dist</code></dt><dd><p>Should the error be for the distribution of the mean?</p>
</dd>
<dt><code>return_df</code></dt><dd><p>When returning se.fit, should it be returned in
a data frame? Otherwise it will be a list, which is faster.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-pred"></a>



<h4>Method <code>pred()</code></h4>

<p>Predict for a matrix of points
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$pred(
  XX,
  se.fit = F,
  covmat = F,
  split_speed = F,
  mean_dist = FALSE,
  return_df = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>points to predict at</p>
</dd>
<dt><code>se.fit</code></dt><dd><p>Should standard error be returned?</p>
</dd>
<dt><code>covmat</code></dt><dd><p>Should covariance matrix be returned?</p>
</dd>
<dt><code>split_speed</code></dt><dd><p>Should the matrix be split for faster predictions?</p>
</dd>
<dt><code>mean_dist</code></dt><dd><p>Should the error be for the distribution of the mean?</p>
</dd>
<dt><code>return_df</code></dt><dd><p>When returning se.fit, should it be returned in
a data frame? Otherwise it will be a list, which is faster.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-pred_one_matrix"></a>



<h4>Method <code>pred_one_matrix()</code></h4>

<p>Predict for a matrix of points
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$pred_one_matrix(
  XX,
  se.fit = F,
  covmat = F,
  return_df = FALSE,
  mean_dist = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>points to predict at</p>
</dd>
<dt><code>se.fit</code></dt><dd><p>Should standard error be returned?</p>
</dd>
<dt><code>covmat</code></dt><dd><p>Should covariance matrix be returned?</p>
</dd>
<dt><code>return_df</code></dt><dd><p>When returning se.fit, should it be returned in
a data frame? Otherwise it will be a list, which is faster.</p>
</dd>
<dt><code>mean_dist</code></dt><dd><p>Should the error be for the distribution of the mean?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-pred_mean"></a>



<h4>Method <code>pred_mean()</code></h4>

<p>Predict mean
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$pred_mean(XX, kx.xx)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>points to predict at</p>
</dd>
<dt><code>kx.xx</code></dt><dd><p>Covariance of X with XX</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-pred_meanC"></a>



<h4>Method <code>pred_meanC()</code></h4>

<p>Predict mean using C
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$pred_meanC(XX, kx.xx)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>points to predict at</p>
</dd>
<dt><code>kx.xx</code></dt><dd><p>Covariance of X with XX</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-pred_var"></a>



<h4>Method <code>pred_var()</code></h4>

<p>Predict variance
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$pred_var(XX, kxx, kx.xx, covmat = F)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>points to predict at</p>
</dd>
<dt><code>kxx</code></dt><dd><p>Covariance of XX with itself</p>
</dd>
<dt><code>kx.xx</code></dt><dd><p>Covariance of X with XX</p>
</dd>
<dt><code>covmat</code></dt><dd><p>Should the covariance matrix be returned?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-pred_LOO"></a>



<h4>Method <code>pred_LOO()</code></h4>

<p>leave one out predictions
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$pred_LOO(se.fit = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>se.fit</code></dt><dd><p>Should standard errors be included?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-pred_var_after_adding_points"></a>



<h4>Method <code>pred_var_after_adding_points()</code></h4>

<p>Predict variance after adding points
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$pred_var_after_adding_points(add_points, pred_points)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>add_points</code></dt><dd><p>Points to add</p>
</dd>
<dt><code>pred_points</code></dt><dd><p>Points to predict at</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-pred_var_after_adding_points_sep"></a>



<h4>Method <code>pred_var_after_adding_points_sep()</code></h4>

<p>Predict variance reductions after adding each point separately
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$pred_var_after_adding_points_sep(add_points, pred_points)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>add_points</code></dt><dd><p>Points to add</p>
</dd>
<dt><code>pred_points</code></dt><dd><p>Points to predict at</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-pred_var_reduction"></a>



<h4>Method <code>pred_var_reduction()</code></h4>

<p>Predict variance reduction for a single point
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$pred_var_reduction(add_point, pred_points)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>add_point</code></dt><dd><p>Point to add</p>
</dd>
<dt><code>pred_points</code></dt><dd><p>Points to predict at</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-pred_var_reductions"></a>



<h4>Method <code>pred_var_reductions()</code></h4>

<p>Predict variance reductions
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$pred_var_reductions(add_points, pred_points)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>add_points</code></dt><dd><p>Points to add</p>
</dd>
<dt><code>pred_points</code></dt><dd><p>Points to predict at</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-plot"></a>



<h4>Method <code>plot()</code></h4>

<p>Plot the object
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$plot(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Parameters passed to cool1Dplot(), plot2D(), or plotmarginal()</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-cool1Dplot"></a>



<h4>Method <code>cool1Dplot()</code></h4>

<p>Make cool 1D plot
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$cool1Dplot(
  n2 = 20,
  nn = 201,
  col2 = "green",
  xlab = "x",
  ylab = "y",
  xmin = NULL,
  xmax = NULL,
  ymin = NULL,
  ymax = NULL,
  gg = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n2</code></dt><dd><p>Number of things to plot</p>
</dd>
<dt><code>nn</code></dt><dd><p>Number of things to plot</p>
</dd>
<dt><code>col2</code></dt><dd><p>color</p>
</dd>
<dt><code>xlab</code></dt><dd><p>x label</p>
</dd>
<dt><code>ylab</code></dt><dd><p>y label</p>
</dd>
<dt><code>xmin</code></dt><dd><p>xmin</p>
</dd>
<dt><code>xmax</code></dt><dd><p>xmax</p>
</dd>
<dt><code>ymin</code></dt><dd><p>ymin</p>
</dd>
<dt><code>ymax</code></dt><dd><p>ymax</p>
</dd>
<dt><code>gg</code></dt><dd><p>Should ggplot2 be used to make plot?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-plot1D"></a>



<h4>Method <code>plot1D()</code></h4>

<p>Make 1D plot
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$plot1D(
  n2 = 20,
  nn = 201,
  col2 = 2,
  col3 = 3,
  xlab = "x",
  ylab = "y",
  xmin = NULL,
  xmax = NULL,
  ymin = NULL,
  ymax = NULL,
  gg = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>n2</code></dt><dd><p>Number of things to plot</p>
</dd>
<dt><code>nn</code></dt><dd><p>Number of things to plot</p>
</dd>
<dt><code>col2</code></dt><dd><p>Color of the prediction interval</p>
</dd>
<dt><code>col3</code></dt><dd><p>Color of the interval for the mean</p>
</dd>
<dt><code>xlab</code></dt><dd><p>x label</p>
</dd>
<dt><code>ylab</code></dt><dd><p>y label</p>
</dd>
<dt><code>xmin</code></dt><dd><p>xmin</p>
</dd>
<dt><code>xmax</code></dt><dd><p>xmax</p>
</dd>
<dt><code>ymin</code></dt><dd><p>ymin</p>
</dd>
<dt><code>ymax</code></dt><dd><p>ymax</p>
</dd>
<dt><code>gg</code></dt><dd><p>Should ggplot2 be used to make plot?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-plot2D"></a>



<h4>Method <code>plot2D()</code></h4>

<p>Make 2D plot
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$plot2D(se = FALSE, mean = TRUE, horizontal = TRUE, n = 50)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>se</code></dt><dd><p>Should the standard error of prediction be plotted?</p>
</dd>
<dt><code>mean</code></dt><dd><p>Should the mean be plotted?</p>
</dd>
<dt><code>horizontal</code></dt><dd><p>If plotting mean and se, should they be next to each
other?</p>
</dd>
<dt><code>n</code></dt><dd><p>Number of points along each dimension</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-plotmarginal"></a>



<h4>Method <code>plotmarginal()</code></h4>

<p>Plot marginal. For each input, hold all others at a constant
value and adjust it along it's range to see how the prediction changes.
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$plotmarginal(npt = 5, ncol = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>npt</code></dt><dd><p>Number of lines to make. Each line represents changing a
single variable while holding the others at the same values.</p>
</dd>
<dt><code>ncol</code></dt><dd><p>Number of columnsfor the plot</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-plotmarginalrandom"></a>



<h4>Method <code>plotmarginalrandom()</code></h4>

<p>Plot marginal prediction for random sample of inputs
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$plotmarginalrandom(npt = 100, ncol = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>npt</code></dt><dd><p>Number of random points to evaluate</p>
</dd>
<dt><code>ncol</code></dt><dd><p>Number of columns in the plot</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-plotkernel"></a>



<h4>Method <code>plotkernel()</code></h4>

<p>Plot the kernel
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$plotkernel(X = self$X)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X</code></dt><dd><p>X matrix for kernel plot</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-plotLOO"></a>



<h4>Method <code>plotLOO()</code></h4>

<p>Plot leave one out predictions for design points
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$plotLOO()</pre></div>


<hr>
<a id="method-GauPro-plot_track_optim"></a>



<h4>Method <code>plot_track_optim()</code></h4>

<p>If track_optim, this will plot the parameters
in the order they were evaluated.
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$plot_track_optim(minindex = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>minindex</code></dt><dd><p>Minimum index to plot.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-loglikelihood"></a>



<h4>Method <code>loglikelihood()</code></h4>

<p>Calculate loglikelihood of parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$loglikelihood(mu = self$mu_hatX, s2 = self$s2_hat)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>mu</code></dt><dd><p>Mean parameters</p>
</dd>
<dt><code>s2</code></dt><dd><p>Variance parameter</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-AIC"></a>



<h4>Method <code>AIC()</code></h4>

<p>AIC (Akaike information criterion)
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$AIC()</pre></div>


<hr>
<a id="method-GauPro-get_optim_functions"></a>



<h4>Method <code>get_optim_functions()</code></h4>

<p>Get optimization functions
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$get_optim_functions(param_update, nug.update)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>param_update</code></dt><dd><p>Should parameters be updated?</p>
</dd>
<dt><code>nug.update</code></dt><dd><p>Should nugget be updated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-param_optim_lower"></a>



<h4>Method <code>param_optim_lower()</code></h4>

<p>Lower bounds of parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$param_optim_lower(nug.update)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>nug.update</code></dt><dd><p>Is the nugget being updated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-param_optim_upper"></a>



<h4>Method <code>param_optim_upper()</code></h4>

<p>Upper bounds of parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$param_optim_upper(nug.update)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>nug.update</code></dt><dd><p>Is the nugget being updated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-param_optim_start"></a>



<h4>Method <code>param_optim_start()</code></h4>

<p>Starting point for parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$param_optim_start(nug.update, jitter)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>nug.update</code></dt><dd><p>Is nugget being updated?</p>
</dd>
<dt><code>jitter</code></dt><dd><p>Should there be a jitter?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-param_optim_start0"></a>



<h4>Method <code>param_optim_start0()</code></h4>

<p>Starting point for parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$param_optim_start0(nug.update, jitter)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>nug.update</code></dt><dd><p>Is nugget being updated?</p>
</dd>
<dt><code>jitter</code></dt><dd><p>Should there be a jitter?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-param_optim_start_mat"></a>



<h4>Method <code>param_optim_start_mat()</code></h4>

<p>Get matrix for starting points of optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$param_optim_start_mat(restarts, nug.update, l)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>restarts</code></dt><dd><p>Number of restarts to use</p>
</dd>
<dt><code>nug.update</code></dt><dd><p>Is nugget being updated?</p>
</dd>
<dt><code>l</code></dt><dd><p>Not used</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-optim"></a>



<h4>Method <code>optim()</code></h4>

<p>Optimize parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$optim(
  restarts = self$restarts,
  n0 = 5 * self$D,
  param_update = T,
  nug.update = self$nug.est,
  parallel = self$parallel,
  parallel_cores = self$parallel_cores
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>restarts</code></dt><dd><p>Number of restarts to do</p>
</dd>
<dt><code>n0</code></dt><dd><p>This many starting parameters are chosen and evaluated.
The best ones are used as the starting points for optimization.</p>
</dd>
<dt><code>param_update</code></dt><dd><p>Should parameters be updated?</p>
</dd>
<dt><code>nug.update</code></dt><dd><p>Should nugget be updated?</p>
</dd>
<dt><code>parallel</code></dt><dd><p>Should restarts be done in parallel?</p>
</dd>
<dt><code>parallel_cores</code></dt><dd><p>If running parallel, how many cores should be used?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-optimRestart"></a>



<h4>Method <code>optimRestart()</code></h4>

<p>Run a single optimization restart.
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$optimRestart(
  start.par,
  start.par0,
  param_update,
  nug.update,
  optim.func,
  optim.grad,
  optim.fngr,
  lower,
  upper,
  jit = T,
  start.par.i
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>start.par</code></dt><dd><p>Starting parameters</p>
</dd>
<dt><code>start.par0</code></dt><dd><p>Starting parameters</p>
</dd>
<dt><code>param_update</code></dt><dd><p>Should parameters be updated?</p>
</dd>
<dt><code>nug.update</code></dt><dd><p>Should nugget be updated?</p>
</dd>
<dt><code>optim.func</code></dt><dd><p>Function to optimize.</p>
</dd>
<dt><code>optim.grad</code></dt><dd><p>Gradient of function to optimize.</p>
</dd>
<dt><code>optim.fngr</code></dt><dd><p>Function that returns the function value
and its gradient.</p>
</dd>
<dt><code>lower</code></dt><dd><p>Lower bounds for optimization</p>
</dd>
<dt><code>upper</code></dt><dd><p>Upper bounds for optimization</p>
</dd>
<dt><code>jit</code></dt><dd><p>Is jitter being used?</p>
</dd>
<dt><code>start.par.i</code></dt><dd><p>Starting parameters for this restart</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-update"></a>



<h4>Method <code>update()</code></h4>

<p>Update the model. Should only give in
(Xnew and Znew) or (Xall and Zall).
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$update(
  Xnew = NULL,
  Znew = NULL,
  Xall = NULL,
  Zall = NULL,
  restarts = self$restarts,
  param_update = self$param.est,
  nug.update = self$nug.est,
  no_update = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Xnew</code></dt><dd><p>New X values to add.</p>
</dd>
<dt><code>Znew</code></dt><dd><p>New Z values to add.</p>
</dd>
<dt><code>Xall</code></dt><dd><p>All X values to be used. Will replace existing X.</p>
</dd>
<dt><code>Zall</code></dt><dd><p>All Z values to be used. Will replace existing Z.</p>
</dd>
<dt><code>restarts</code></dt><dd><p>Number of optimization restarts.</p>
</dd>
<dt><code>param_update</code></dt><dd><p>Are the parameters being updated?</p>
</dd>
<dt><code>nug.update</code></dt><dd><p>Is the nugget being updated?</p>
</dd>
<dt><code>no_update</code></dt><dd><p>Are no parameters being updated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-update_fast"></a>



<h4>Method <code>update_fast()</code></h4>

<p>Fast update when adding new data.
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$update_fast(Xnew = NULL, Znew = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Xnew</code></dt><dd><p>New X values to add.</p>
</dd>
<dt><code>Znew</code></dt><dd><p>New Z values to add.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-update_params"></a>



<h4>Method <code>update_params()</code></h4>

<p>Update the parameters.
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$update_params(..., nug.update)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Passed to optim.</p>
</dd>
<dt><code>nug.update</code></dt><dd><p>Is the nugget being updated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-update_data"></a>



<h4>Method <code>update_data()</code></h4>

<p>Update the data. Should only give in
(Xnew and Znew) or (Xall and Zall).
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$update_data(
  Xnew = NULL,
  Znew = NULL,
  Xall = NULL,
  Zall = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Xnew</code></dt><dd><p>New X values to add.</p>
</dd>
<dt><code>Znew</code></dt><dd><p>New Z values to add.</p>
</dd>
<dt><code>Xall</code></dt><dd><p>All X values to be used. Will replace existing X.</p>
</dd>
<dt><code>Zall</code></dt><dd><p>All Z values to be used. Will replace existing Z.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-update_corrparams"></a>



<h4>Method <code>update_corrparams()</code></h4>

<p>Update correlation parameters. Not the nugget.
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$update_corrparams(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Passed to self$update()</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-update_nugget"></a>



<h4>Method <code>update_nugget()</code></h4>

<p>Update nugget Not the correlation parameters.
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$update_nugget(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Passed to self$update()</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-deviance"></a>



<h4>Method <code>deviance()</code></h4>

<p>Calculate the deviance.
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$deviance(
  params = NULL,
  nug = self$nug,
  nuglog,
  trend_params = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Kernel parameters</p>
</dd>
<dt><code>nug</code></dt><dd><p>Nugget</p>
</dd>
<dt><code>nuglog</code></dt><dd><p>Log of nugget. Only give in nug or nuglog.</p>
</dd>
<dt><code>trend_params</code></dt><dd><p>Parameters for the trend.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-deviance_grad"></a>



<h4>Method <code>deviance_grad()</code></h4>

<p>Calculate the gradient of the deviance.
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$deviance_grad(
  params = NULL,
  kernel_update = TRUE,
  X = self$X,
  nug = self$nug,
  nug.update,
  nuglog,
  trend_params = NULL,
  trend_update = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Kernel parameters</p>
</dd>
<dt><code>kernel_update</code></dt><dd><p>Is the kernel being updated? If yes,
it's part of the gradient.</p>
</dd>
<dt><code>X</code></dt><dd><p>Input matrix</p>
</dd>
<dt><code>nug</code></dt><dd><p>Nugget</p>
</dd>
<dt><code>nug.update</code></dt><dd><p>Is the nugget being updated? If yes,
it's part of the gradient.</p>
</dd>
<dt><code>nuglog</code></dt><dd><p>Log of the nugget.</p>
</dd>
<dt><code>trend_params</code></dt><dd><p>Trend parameters</p>
</dd>
<dt><code>trend_update</code></dt><dd><p>Is the trend being updated? If yes,
it's part of the gradient.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-deviance_fngr"></a>



<h4>Method <code>deviance_fngr()</code></h4>

<p>Calculate the deviance along with its gradient.
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$deviance_fngr(
  params = NULL,
  kernel_update = TRUE,
  X = self$X,
  nug = self$nug,
  nug.update,
  nuglog,
  trend_params = NULL,
  trend_update = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Kernel parameters</p>
</dd>
<dt><code>kernel_update</code></dt><dd><p>Is the kernel being updated? If yes,
it's part of the gradient.</p>
</dd>
<dt><code>X</code></dt><dd><p>Input matrix</p>
</dd>
<dt><code>nug</code></dt><dd><p>Nugget</p>
</dd>
<dt><code>nug.update</code></dt><dd><p>Is the nugget being updated? If yes,
it's part of the gradient.</p>
</dd>
<dt><code>nuglog</code></dt><dd><p>Log of the nugget.</p>
</dd>
<dt><code>trend_params</code></dt><dd><p>Trend parameters</p>
</dd>
<dt><code>trend_update</code></dt><dd><p>Is the trend being updated? If yes,
it's part of the gradient.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-grad"></a>



<h4>Method <code>grad()</code></h4>

<p>Calculate gradient
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$grad(XX, X = self$X, Z = self$Z)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>points to calculate at</p>
</dd>
<dt><code>X</code></dt><dd><p>X points</p>
</dd>
<dt><code>Z</code></dt><dd><p>output points</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-grad_norm"></a>



<h4>Method <code>grad_norm()</code></h4>

<p>Calculate norm of gradient
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$grad_norm(XX)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>points to calculate at</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-grad_dist"></a>



<h4>Method <code>grad_dist()</code></h4>

<p>Calculate distribution of gradient
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$grad_dist(XX)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>points to calculate at</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-grad_sample"></a>



<h4>Method <code>grad_sample()</code></h4>

<p>Sample gradient at points
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$grad_sample(XX, n)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>points to calculate at</p>
</dd>
<dt><code>n</code></dt><dd><p>Number of samples</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-grad_norm2_mean"></a>



<h4>Method <code>grad_norm2_mean()</code></h4>

<p>Calculate mean of gradient norm squared
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$grad_norm2_mean(XX)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>points to calculate at</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-grad_norm2_dist"></a>



<h4>Method <code>grad_norm2_dist()</code></h4>

<p>Calculate distribution of gradient norm squared
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$grad_norm2_dist(XX)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>points to calculate at</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-grad_norm2_sample"></a>



<h4>Method <code>grad_norm2_sample()</code></h4>

<p>Get samples of squared norm of gradient
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$grad_norm2_sample(XX, n)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>points to sample at</p>
</dd>
<dt><code>n</code></dt><dd><p>Number of samples</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-hessian"></a>



<h4>Method <code>hessian()</code></h4>

<p>Calculate Hessian
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$hessian(XX, as_array = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>Points to calculate Hessian at</p>
</dd>
<dt><code>as_array</code></dt><dd><p>Should result be an array?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-gradpredvar"></a>



<h4>Method <code>gradpredvar()</code></h4>

<p>Calculate gradient of the predictive variance
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$gradpredvar(XX)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>points to calculate at</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-sample"></a>



<h4>Method <code>sample()</code></h4>

<p>Sample at rows of XX
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$sample(XX, n = 1)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>Input matrix</p>
</dd>
<dt><code>n</code></dt><dd><p>Number of samples</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-optimize_fn"></a>



<h4>Method <code>optimize_fn()</code></h4>

<p>Optimize any function of the GP prediction over the
valid input space.
If there are inputs that should only be optimized over a discrete set
of values, specify 'mopar' for all parameters.
Factor inputs will be handled automatically.
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$optimize_fn(
  fn = NULL,
  lower = apply(self$X, 2, min),
  upper = apply(self$X, 2, max),
  n0 = 100,
  minimize = FALSE,
  fn_args = NULL,
  gr = NULL,
  fngr = NULL,
  mopar = NULL,
  groupeval = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>fn</code></dt><dd><p>Function to optimize</p>
</dd>
<dt><code>lower</code></dt><dd><p>Lower bounds to search within</p>
</dd>
<dt><code>upper</code></dt><dd><p>Upper bounds to search within</p>
</dd>
<dt><code>n0</code></dt><dd><p>Number of points to evaluate in initial stage</p>
</dd>
<dt><code>minimize</code></dt><dd><p>Are you trying to minimize the output?</p>
</dd>
<dt><code>fn_args</code></dt><dd><p>Arguments to pass to the function fn.</p>
</dd>
<dt><code>gr</code></dt><dd><p>Gradient of function to optimize.</p>
</dd>
<dt><code>fngr</code></dt><dd><p>Function that returns list with names elements &quot;fn&quot; for the
function value and &quot;gr&quot; for the gradient. Useful when it is slow to
evaluate and fn/gr would duplicate calculations if done separately.</p>
</dd>
<dt><code>mopar</code></dt><dd><p>List of parameters using mixopt</p>
</dd>
<dt><code>groupeval</code></dt><dd><p>Can a matrix of points be evaluated? Otherwise just
a single point at a time.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-EI"></a>



<h4>Method <code>EI()</code></h4>

<p>Calculate expected improvement
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$EI(x, minimize = FALSE, eps = 0, return_grad = FALSE, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Vector to calculate EI of, or matrix for whose rows it should
be calculated</p>
</dd>
<dt><code>minimize</code></dt><dd><p>Are you trying to minimize the output?</p>
</dd>
<dt><code>eps</code></dt><dd><p>Exploration parameter</p>
</dd>
<dt><code>return_grad</code></dt><dd><p>Should the gradient be returned?</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional args</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-maxEI"></a>



<h4>Method <code>maxEI()</code></h4>

<p>Find the point that maximizes the expected improvement.
If there are inputs that should only be optimized over a discrete set
of values, specify 'mopar' for all parameters.
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$maxEI(
  lower = apply(self$X, 2, min),
  upper = apply(self$X, 2, max),
  n0 = 100,
  minimize = FALSE,
  eps = 0,
  dontconvertback = FALSE,
  EItype = "corrected",
  mopar = NULL,
  usegrad = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>lower</code></dt><dd><p>Lower bounds to search within</p>
</dd>
<dt><code>upper</code></dt><dd><p>Upper bounds to search within</p>
</dd>
<dt><code>n0</code></dt><dd><p>Number of points to evaluate in initial stage</p>
</dd>
<dt><code>minimize</code></dt><dd><p>Are you trying to minimize the output?</p>
</dd>
<dt><code>eps</code></dt><dd><p>Exploration parameter</p>
</dd>
<dt><code>dontconvertback</code></dt><dd><p>If data was given in with a formula, should
it converted back to the original scale?</p>
</dd>
<dt><code>EItype</code></dt><dd><p>Type of EI to calculate. One of &quot;EI&quot;, &quot;Augmented&quot;,
or &quot;Corrected&quot;</p>
</dd>
<dt><code>mopar</code></dt><dd><p>List of parameters using mixopt</p>
</dd>
<dt><code>usegrad</code></dt><dd><p>Should the gradient be used when optimizing?
Can make it faster.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-maxqEI"></a>



<h4>Method <code>maxqEI()</code></h4>

<p>Find the multiple points that maximize the expected
improvement. Currently only implements the constant liar method.
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$maxqEI(
  npoints,
  method = "pred",
  lower = apply(self$X, 2, min),
  upper = apply(self$X, 2, max),
  n0 = 100,
  minimize = FALSE,
  eps = 0,
  EItype = "corrected",
  dontconvertback = FALSE,
  mopar = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>npoints</code></dt><dd><p>Number of points to add</p>
</dd>
<dt><code>method</code></dt><dd><p>Method to use for setting the output value for the points
chosen as a placeholder.
Can be one of: &quot;CL&quot; for constant liar,
which uses the best value seen yet; or &quot;pred&quot;, which uses the predicted
value, also called the Believer method in literature.</p>
</dd>
<dt><code>lower</code></dt><dd><p>Lower bounds to search within</p>
</dd>
<dt><code>upper</code></dt><dd><p>Upper bounds to search within</p>
</dd>
<dt><code>n0</code></dt><dd><p>Number of points to evaluate in initial stage</p>
</dd>
<dt><code>minimize</code></dt><dd><p>Are you trying to minimize the output?</p>
</dd>
<dt><code>eps</code></dt><dd><p>Exploration parameter</p>
</dd>
<dt><code>EItype</code></dt><dd><p>Type of EI to calculate. One of &quot;EI&quot;, &quot;Augmented&quot;,
or &quot;Corrected&quot;</p>
</dd>
<dt><code>dontconvertback</code></dt><dd><p>If data was given in with a formula, should
it converted back to the original scale?</p>
</dd>
<dt><code>mopar</code></dt><dd><p>List of parameters using mixopt</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-KG"></a>



<h4>Method <code>KG()</code></h4>

<p>Calculate Knowledge Gradient
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$KG(x, minimize = FALSE, eps = 0, current_extreme = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Point to calculate at</p>
</dd>
<dt><code>minimize</code></dt><dd><p>Is the objective to minimize?</p>
</dd>
<dt><code>eps</code></dt><dd><p>Exploration parameter</p>
</dd>
<dt><code>current_extreme</code></dt><dd><p>Used for recursive solving</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-AugmentedEI"></a>



<h4>Method <code>AugmentedEI()</code></h4>

<p>Calculated Augmented EI
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$AugmentedEI(
  x,
  minimize = FALSE,
  eps = 0,
  return_grad = F,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Vector to calculate EI of, or matrix for whose rows it should
be calculated</p>
</dd>
<dt><code>minimize</code></dt><dd><p>Are you trying to minimize the output?</p>
</dd>
<dt><code>eps</code></dt><dd><p>Exploration parameter</p>
</dd>
<dt><code>return_grad</code></dt><dd><p>Should the gradient be returned?</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional args</p>
</dd>
<dt><code>f</code></dt><dd><p>The reference max, user shouldn't change this.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-CorrectedEI"></a>



<h4>Method <code>CorrectedEI()</code></h4>

<p>Calculated Augmented EI
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$CorrectedEI(
  x,
  minimize = FALSE,
  eps = 0,
  return_grad = F,
  ...
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>Vector to calculate EI of, or matrix for whose rows it should
be calculated</p>
</dd>
<dt><code>minimize</code></dt><dd><p>Are you trying to minimize the output?</p>
</dd>
<dt><code>eps</code></dt><dd><p>Exploration parameter</p>
</dd>
<dt><code>return_grad</code></dt><dd><p>Should the gradient be returned?</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional args</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-importance"></a>



<h4>Method <code>importance()</code></h4>

<p>Feature importance
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$importance(plot = TRUE, print_bars = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>plot</code></dt><dd><p>Should the plot be made?</p>
</dd>
<dt><code>print_bars</code></dt><dd><p>Should the importances be printed as bars?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print this object
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$print()</pre></div>


<hr>
<a id="method-GauPro-summary"></a>



<h4>Method <code>summary()</code></h4>

<p>Summary
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$summary(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Additional arguments</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>https://scikit-learn.org/stable/modules/permutation_importance.html#id2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 12
x &lt;- matrix(seq(0,1,length.out = n), ncol=1)
y &lt;- sin(2*pi*x) + rnorm(n,0,1e-1)
gp &lt;- GauPro_kernel_model$new(X=x, Z=y, kernel="gauss")
gp$predict(.454)
gp$plot1D()
gp$cool1Dplot()

n &lt;- 200
d &lt;- 7
x &lt;- matrix(runif(n*d), ncol=d)
f &lt;- function(x) {x[1]*x[2] + cos(x[3]) + x[4]^2}
y &lt;- apply(x, 1, f)
gp &lt;- GauPro_kernel_model$new(X=x, Z=y, kernel=Gaussian)
</code></pre>

<hr>
<h2 id='GauPro_kernel_model_LOO'>Corr Gauss GP using inherited optim</h2><span id='topic+GauPro_kernel_model_LOO'></span>

<h3>Description</h3>

<p>Corr Gauss GP using inherited optim
</p>
<p>Corr Gauss GP using inherited optim
</p>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Value</h3>

<p>Object of <code><a href="R6.html#topic+R6Class">R6Class</a></code> with methods for fitting GP model.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+GauPro">GauPro::GauPro</a></code> -&gt; <code>GauPro_kernel_model_LOO</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>tmod</code></dt><dd><p>A second GP model for the t-values of leave-one-out predictions</p>
</dd>
<dt><code>use_LOO</code></dt><dd><p>Should the leave-one-out error corrections be used?</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GauPro_kernel_model_LOO-new"><code>GauPro_kernel_model_LOO$new()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_model_LOO-update"><code>GauPro_kernel_model_LOO$update()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_model_LOO-pred_one_matrix"><code>GauPro_kernel_model_LOO$pred_one_matrix()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_model_LOO-clone"><code>GauPro_kernel_model_LOO$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="AIC"><a href='../../GauPro/html/GauPro.html#method-GauPro-AIC'><code>GauPro::GauPro$AIC()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="AugmentedEI"><a href='../../GauPro/html/GauPro.html#method-GauPro-AugmentedEI'><code>GauPro::GauPro$AugmentedEI()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="CorrectedEI"><a href='../../GauPro/html/GauPro.html#method-GauPro-CorrectedEI'><code>GauPro::GauPro$CorrectedEI()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="EI"><a href='../../GauPro/html/GauPro.html#method-GauPro-EI'><code>GauPro::GauPro$EI()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="KG"><a href='../../GauPro/html/GauPro.html#method-GauPro-KG'><code>GauPro::GauPro$KG()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="cool1Dplot"><a href='../../GauPro/html/GauPro.html#method-GauPro-cool1Dplot'><code>GauPro::GauPro$cool1Dplot()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="deviance"><a href='../../GauPro/html/GauPro.html#method-GauPro-deviance'><code>GauPro::GauPro$deviance()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="deviance_fngr"><a href='../../GauPro/html/GauPro.html#method-GauPro-deviance_fngr'><code>GauPro::GauPro$deviance_fngr()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="deviance_grad"><a href='../../GauPro/html/GauPro.html#method-GauPro-deviance_grad'><code>GauPro::GauPro$deviance_grad()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="fit"><a href='../../GauPro/html/GauPro.html#method-GauPro-fit'><code>GauPro::GauPro$fit()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="get_optim_functions"><a href='../../GauPro/html/GauPro.html#method-GauPro-get_optim_functions'><code>GauPro::GauPro$get_optim_functions()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="grad"><a href='../../GauPro/html/GauPro.html#method-GauPro-grad'><code>GauPro::GauPro$grad()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="grad_dist"><a href='../../GauPro/html/GauPro.html#method-GauPro-grad_dist'><code>GauPro::GauPro$grad_dist()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="grad_norm"><a href='../../GauPro/html/GauPro.html#method-GauPro-grad_norm'><code>GauPro::GauPro$grad_norm()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="grad_norm2_dist"><a href='../../GauPro/html/GauPro.html#method-GauPro-grad_norm2_dist'><code>GauPro::GauPro$grad_norm2_dist()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="grad_norm2_mean"><a href='../../GauPro/html/GauPro.html#method-GauPro-grad_norm2_mean'><code>GauPro::GauPro$grad_norm2_mean()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="grad_norm2_sample"><a href='../../GauPro/html/GauPro.html#method-GauPro-grad_norm2_sample'><code>GauPro::GauPro$grad_norm2_sample()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="grad_sample"><a href='../../GauPro/html/GauPro.html#method-GauPro-grad_sample'><code>GauPro::GauPro$grad_sample()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="gradpredvar"><a href='../../GauPro/html/GauPro.html#method-GauPro-gradpredvar'><code>GauPro::GauPro$gradpredvar()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="hessian"><a href='../../GauPro/html/GauPro.html#method-GauPro-hessian'><code>GauPro::GauPro$hessian()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="importance"><a href='../../GauPro/html/GauPro.html#method-GauPro-importance'><code>GauPro::GauPro$importance()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="loglikelihood"><a href='../../GauPro/html/GauPro.html#method-GauPro-loglikelihood'><code>GauPro::GauPro$loglikelihood()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="maxEI"><a href='../../GauPro/html/GauPro.html#method-GauPro-maxEI'><code>GauPro::GauPro$maxEI()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="maxqEI"><a href='../../GauPro/html/GauPro.html#method-GauPro-maxqEI'><code>GauPro::GauPro$maxqEI()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="optim"><a href='../../GauPro/html/GauPro.html#method-GauPro-optim'><code>GauPro::GauPro$optim()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="optimRestart"><a href='../../GauPro/html/GauPro.html#method-GauPro-optimRestart'><code>GauPro::GauPro$optimRestart()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="optimize_fn"><a href='../../GauPro/html/GauPro.html#method-GauPro-optimize_fn'><code>GauPro::GauPro$optimize_fn()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="param_optim_lower"><a href='../../GauPro/html/GauPro.html#method-GauPro-param_optim_lower'><code>GauPro::GauPro$param_optim_lower()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="param_optim_start"><a href='../../GauPro/html/GauPro.html#method-GauPro-param_optim_start'><code>GauPro::GauPro$param_optim_start()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="param_optim_start0"><a href='../../GauPro/html/GauPro.html#method-GauPro-param_optim_start0'><code>GauPro::GauPro$param_optim_start0()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="param_optim_start_mat"><a href='../../GauPro/html/GauPro.html#method-GauPro-param_optim_start_mat'><code>GauPro::GauPro$param_optim_start_mat()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="param_optim_upper"><a href='../../GauPro/html/GauPro.html#method-GauPro-param_optim_upper'><code>GauPro::GauPro$param_optim_upper()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="plot"><a href='../../GauPro/html/GauPro.html#method-GauPro-plot'><code>GauPro::GauPro$plot()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="plot1D"><a href='../../GauPro/html/GauPro.html#method-GauPro-plot1D'><code>GauPro::GauPro$plot1D()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="plot2D"><a href='../../GauPro/html/GauPro.html#method-GauPro-plot2D'><code>GauPro::GauPro$plot2D()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="plotLOO"><a href='../../GauPro/html/GauPro.html#method-GauPro-plotLOO'><code>GauPro::GauPro$plotLOO()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="plot_track_optim"><a href='../../GauPro/html/GauPro.html#method-GauPro-plot_track_optim'><code>GauPro::GauPro$plot_track_optim()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="plotkernel"><a href='../../GauPro/html/GauPro.html#method-GauPro-plotkernel'><code>GauPro::GauPro$plotkernel()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="plotmarginal"><a href='../../GauPro/html/GauPro.html#method-GauPro-plotmarginal'><code>GauPro::GauPro$plotmarginal()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="plotmarginalrandom"><a href='../../GauPro/html/GauPro.html#method-GauPro-plotmarginalrandom'><code>GauPro::GauPro$plotmarginalrandom()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="pred"><a href='../../GauPro/html/GauPro.html#method-GauPro-pred'><code>GauPro::GauPro$pred()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="pred_LOO"><a href='../../GauPro/html/GauPro.html#method-GauPro-pred_LOO'><code>GauPro::GauPro$pred_LOO()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="pred_mean"><a href='../../GauPro/html/GauPro.html#method-GauPro-pred_mean'><code>GauPro::GauPro$pred_mean()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="pred_meanC"><a href='../../GauPro/html/GauPro.html#method-GauPro-pred_meanC'><code>GauPro::GauPro$pred_meanC()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="pred_var"><a href='../../GauPro/html/GauPro.html#method-GauPro-pred_var'><code>GauPro::GauPro$pred_var()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="pred_var_after_adding_points"><a href='../../GauPro/html/GauPro.html#method-GauPro-pred_var_after_adding_points'><code>GauPro::GauPro$pred_var_after_adding_points()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="pred_var_after_adding_points_sep"><a href='../../GauPro/html/GauPro.html#method-GauPro-pred_var_after_adding_points_sep'><code>GauPro::GauPro$pred_var_after_adding_points_sep()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="pred_var_reduction"><a href='../../GauPro/html/GauPro.html#method-GauPro-pred_var_reduction'><code>GauPro::GauPro$pred_var_reduction()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="pred_var_reductions"><a href='../../GauPro/html/GauPro.html#method-GauPro-pred_var_reductions'><code>GauPro::GauPro$pred_var_reductions()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="predict"><a href='../../GauPro/html/GauPro.html#method-GauPro-predict'><code>GauPro::GauPro$predict()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="print"><a href='../../GauPro/html/GauPro.html#method-GauPro-print'><code>GauPro::GauPro$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="sample"><a href='../../GauPro/html/GauPro.html#method-GauPro-sample'><code>GauPro::GauPro$sample()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="summary"><a href='../../GauPro/html/GauPro.html#method-GauPro-summary'><code>GauPro::GauPro$summary()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="update_K_and_estimates"><a href='../../GauPro/html/GauPro.html#method-GauPro-update_K_and_estimates'><code>GauPro::GauPro$update_K_and_estimates()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="update_corrparams"><a href='../../GauPro/html/GauPro.html#method-GauPro-update_corrparams'><code>GauPro::GauPro$update_corrparams()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="update_data"><a href='../../GauPro/html/GauPro.html#method-GauPro-update_data'><code>GauPro::GauPro$update_data()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="update_fast"><a href='../../GauPro/html/GauPro.html#method-GauPro-update_fast'><code>GauPro::GauPro$update_fast()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="update_nugget"><a href='../../GauPro/html/GauPro.html#method-GauPro-update_nugget'><code>GauPro::GauPro$update_nugget()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro" data-id="update_params"><a href='../../GauPro/html/GauPro.html#method-GauPro-update_params'><code>GauPro::GauPro$update_params()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-GauPro_kernel_model_LOO-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a kernel model that uses a leave-one-out GP model
to fix the standard error predictions.
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model_LOO$new(..., LOO_kernel, LOO_options = list())</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Passed to super$initialize.</p>
</dd>
<dt><code>LOO_kernel</code></dt><dd><p>The kernel that should be used for the
leave-one-out model. Shouldn't be too smooth.</p>
</dd>
<dt><code>LOO_options</code></dt><dd><p>Options passed to the leave-one-out model.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_model_LOO-update"></a>



<h4>Method <code>update()</code></h4>

<p>Update the model. Should only give in
(Xnew and Znew) or (Xall and Zall).
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model_LOO$update(
  Xnew = NULL,
  Znew = NULL,
  Xall = NULL,
  Zall = NULL,
  restarts = 5,
  param_update = self$param.est,
  nug.update = self$nug.est,
  no_update = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>Xnew</code></dt><dd><p>New X values to add.</p>
</dd>
<dt><code>Znew</code></dt><dd><p>New Z values to add.</p>
</dd>
<dt><code>Xall</code></dt><dd><p>All X values to be used. Will replace existing X.</p>
</dd>
<dt><code>Zall</code></dt><dd><p>All Z values to be used. Will replace existing Z.</p>
</dd>
<dt><code>restarts</code></dt><dd><p>Number of optimization restarts.</p>
</dd>
<dt><code>param_update</code></dt><dd><p>Are the parameters being updated?</p>
</dd>
<dt><code>nug.update</code></dt><dd><p>Is the nugget being updated?</p>
</dd>
<dt><code>no_update</code></dt><dd><p>Are no parameters being updated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_model_LOO-pred_one_matrix"></a>



<h4>Method <code>pred_one_matrix()</code></h4>

<p>Predict for a matrix of points
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model_LOO$pred_one_matrix(
  XX,
  se.fit = F,
  covmat = F,
  return_df = FALSE,
  mean_dist = FALSE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>points to predict at</p>
</dd>
<dt><code>se.fit</code></dt><dd><p>Should standard error be returned?</p>
</dd>
<dt><code>covmat</code></dt><dd><p>Should covariance matrix be returned?</p>
</dd>
<dt><code>return_df</code></dt><dd><p>When returning se.fit, should it be returned in
a data frame?</p>
</dd>
<dt><code>mean_dist</code></dt><dd><p>Should mean distribution be returned?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_model_LOO-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_kernel_model_LOO$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 12
x &lt;- matrix(seq(0,1,length.out = n), ncol=1)
y &lt;- sin(2*pi*x) + rnorm(n,0,1e-1)
gp &lt;- GauPro_kernel_model_LOO$new(X=x, Z=y, kernel=Gaussian)
y &lt;- x^2 * sin(2*pi*x) + rnorm(n,0,1e-3)
gp &lt;- GauPro_kernel_model_LOO$new(X=x, Z=y, kernel=Matern52)
y &lt;- exp(-1.4*x)*cos(7*pi*x/2)
gp &lt;- GauPro_kernel_model_LOO$new(X=x, Z=y, kernel=Matern52)
</code></pre>

<hr>
<h2 id='GauPro_trend'>Trend R6 class</h2><span id='topic+GauPro_trend'></span>

<h3>Description</h3>

<p>Trend R6 class
</p>
<p>Trend R6 class
</p>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Value</h3>

<p>Object of <code><a href="R6.html#topic+R6Class">R6Class</a></code> with methods for fitting GP model.
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>D</code></dt><dd><p>Number of input dimensions of data</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GauPro_trend-clone"><code>GauPro_trend$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-GauPro_trend-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>GauPro_trend$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>#k &lt;- GauPro_trend$new()
</code></pre>

<hr>
<h2 id='Gaussian'>Gaussian Kernel R6 class</h2><span id='topic+Gaussian'></span>

<h3>Description</h3>

<p>Gaussian Kernel R6 class
</p>
<p>Gaussian Kernel R6 class
</p>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Value</h3>

<p>Object of <code><a href="R6.html#topic+R6Class">R6Class</a></code> with methods for fitting GP model.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+GauPro_kernel">GauPro::GauPro_kernel</a></code> -&gt; <code><a href="#topic+GauPro_kernel_beta">GauPro::GauPro_kernel_beta</a></code> -&gt; <code>GauPro_kernel_Gaussian</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GauPro_kernel_Gaussian-k"><code>Gaussian$k()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Gaussian-kone"><code>Gaussian$kone()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Gaussian-dC_dparams"><code>Gaussian$dC_dparams()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Gaussian-C_dC_dparams"><code>Gaussian$C_dC_dparams()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Gaussian-dC_dx"><code>Gaussian$dC_dx()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Gaussian-d2C_dx2"><code>Gaussian$d2C_dx2()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Gaussian-d2C_dudv"><code>Gaussian$d2C_dudv()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Gaussian-d2C_dudv_ueqvrows"><code>Gaussian$d2C_dudv_ueqvrows()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Gaussian-print"><code>Gaussian$print()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Gaussian-clone"><code>Gaussian$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel" data-id="plot"><a href='../../GauPro/html/GauPro_kernel.html#method-GauPro_kernel-plot'><code>GauPro::GauPro_kernel$plot()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="initialize"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-initialize'><code>GauPro::GauPro_kernel_beta$initialize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="param_optim_lower"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-param_optim_lower'><code>GauPro::GauPro_kernel_beta$param_optim_lower()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="param_optim_start"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-param_optim_start'><code>GauPro::GauPro_kernel_beta$param_optim_start()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="param_optim_start0"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-param_optim_start0'><code>GauPro::GauPro_kernel_beta$param_optim_start0()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="param_optim_upper"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-param_optim_upper'><code>GauPro::GauPro_kernel_beta$param_optim_upper()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="s2_from_params"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-s2_from_params'><code>GauPro::GauPro_kernel_beta$s2_from_params()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="set_params_from_optim"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-set_params_from_optim'><code>GauPro::GauPro_kernel_beta$set_params_from_optim()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-GauPro_kernel_Gaussian-k"></a>



<h4>Method <code>k()</code></h4>

<p>Calculate covariance between two points
</p>


<h5>Usage</h5>

<div class="r"><pre>Gaussian$k(x, y = NULL, beta = self$beta, s2 = self$s2, params = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>vector.</p>
</dd>
<dt><code>y</code></dt><dd><p>vector, optional. If excluded, find correlation
of x with itself.</p>
</dd>
<dt><code>beta</code></dt><dd><p>Correlation parameters.</p>
</dd>
<dt><code>s2</code></dt><dd><p>Variance parameter.</p>
</dd>
<dt><code>params</code></dt><dd><p>parameters to use instead of beta and s2.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_Gaussian-kone"></a>



<h4>Method <code>kone()</code></h4>

<p>Find covariance of two points
</p>


<h5>Usage</h5>

<div class="r"><pre>Gaussian$kone(x, y, beta, theta, s2)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>vector</p>
</dd>
<dt><code>y</code></dt><dd><p>vector</p>
</dd>
<dt><code>beta</code></dt><dd><p>correlation parameters on log scale</p>
</dd>
<dt><code>theta</code></dt><dd><p>correlation parameters on regular scale</p>
</dd>
<dt><code>s2</code></dt><dd><p>Variance parameter</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_Gaussian-dC_dparams"></a>



<h4>Method <code>dC_dparams()</code></h4>

<p>Derivative of covariance with respect to parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>Gaussian$dC_dparams(params = NULL, X, C_nonug, C, nug)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Kernel parameters</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points in rows</p>
</dd>
<dt><code>C_nonug</code></dt><dd><p>Covariance without nugget added to diagonal</p>
</dd>
<dt><code>C</code></dt><dd><p>Covariance with nugget</p>
</dd>
<dt><code>nug</code></dt><dd><p>Value of nugget</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_Gaussian-C_dC_dparams"></a>



<h4>Method <code>C_dC_dparams()</code></h4>

<p>Calculate covariance matrix and its derivative
with respect to parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>Gaussian$C_dC_dparams(params = NULL, X, nug)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Kernel parameters</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points in rows</p>
</dd>
<dt><code>nug</code></dt><dd><p>Value of nugget</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_Gaussian-dC_dx"></a>



<h4>Method <code>dC_dx()</code></h4>

<p>Derivative of covariance with respect to X
</p>


<h5>Usage</h5>

<div class="r"><pre>Gaussian$dC_dx(XX, X, theta, beta = self$beta, s2 = self$s2)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>matrix of points</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points to take derivative with respect to</p>
</dd>
<dt><code>theta</code></dt><dd><p>Correlation parameters</p>
</dd>
<dt><code>beta</code></dt><dd><p>log of theta</p>
</dd>
<dt><code>s2</code></dt><dd><p>Variance parameter</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_Gaussian-d2C_dx2"></a>



<h4>Method <code>d2C_dx2()</code></h4>

<p>Second derivative of covariance with respect to X
</p>


<h5>Usage</h5>

<div class="r"><pre>Gaussian$d2C_dx2(XX, X, theta, beta = self$beta, s2 = self$s2)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>matrix of points</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points to take derivative with respect to</p>
</dd>
<dt><code>theta</code></dt><dd><p>Correlation parameters</p>
</dd>
<dt><code>beta</code></dt><dd><p>log of theta</p>
</dd>
<dt><code>s2</code></dt><dd><p>Variance parameter</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_Gaussian-d2C_dudv"></a>



<h4>Method <code>d2C_dudv()</code></h4>

<p>Second derivative of covariance with respect to
X and XX each once.
</p>


<h5>Usage</h5>

<div class="r"><pre>Gaussian$d2C_dudv(XX, X, theta, beta = self$beta, s2 = self$s2)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>matrix of points</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points to take derivative with respect to</p>
</dd>
<dt><code>theta</code></dt><dd><p>Correlation parameters</p>
</dd>
<dt><code>beta</code></dt><dd><p>log of theta</p>
</dd>
<dt><code>s2</code></dt><dd><p>Variance parameter</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_Gaussian-d2C_dudv_ueqvrows"></a>



<h4>Method <code>d2C_dudv_ueqvrows()</code></h4>

<p>Second derivative of covariance with respect to X and XX
when they equal the same value
</p>


<h5>Usage</h5>

<div class="r"><pre>Gaussian$d2C_dudv_ueqvrows(XX, theta, beta = self$beta, s2 = self$s2)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>matrix of points</p>
</dd>
<dt><code>theta</code></dt><dd><p>Correlation parameters</p>
</dd>
<dt><code>beta</code></dt><dd><p>log of theta</p>
</dd>
<dt><code>s2</code></dt><dd><p>Variance parameter</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_Gaussian-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print this object
</p>


<h5>Usage</h5>

<div class="r"><pre>Gaussian$print()</pre></div>


<hr>
<a id="method-GauPro_kernel_Gaussian-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Gaussian$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>k1 &lt;- Gaussian$new(beta=0)
plot(k1)
k1 &lt;- Gaussian$new(beta=c(0,-1, 1))
plot(k1)


n &lt;- 12
x &lt;- matrix(seq(0,1,length.out = n), ncol=1)
y &lt;- sin(2*pi*x) + rnorm(n,0,1e-1)
gp &lt;- GauPro_kernel_model$new(X=x, Z=y, kernel=Gaussian$new(1),
                              parallel=FALSE)
gp$predict(.454)
gp$plot1D()
gp$cool1Dplot()
</code></pre>

<hr>
<h2 id='Gaussian_devianceC'>Calculate the Gaussian deviance in C</h2><span id='topic+Gaussian_devianceC'></span>

<h3>Description</h3>

<p>Calculate the Gaussian deviance in C
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gaussian_devianceC(theta, nug, X, Z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gaussian_devianceC_+3A_theta">theta</code></td>
<td>
<p>Theta vector</p>
</td></tr>
<tr><td><code id="Gaussian_devianceC_+3A_nug">nug</code></td>
<td>
<p>Nugget</p>
</td></tr>
<tr><td><code id="Gaussian_devianceC_+3A_x">X</code></td>
<td>
<p>Matrix X</p>
</td></tr>
<tr><td><code id="Gaussian_devianceC_+3A_z">Z</code></td>
<td>
<p>Matrix Z</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Correlation matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Gaussian_devianceC(c(1,1), 1e-8, matrix(c(1,0,0,1),2,2), matrix(c(1,0),2,1))
</code></pre>

<hr>
<h2 id='Gaussian_hessianC'>Calculate Hessian for a GP with Gaussian correlation</h2><span id='topic+Gaussian_hessianC'></span>

<h3>Description</h3>

<p>Calculate Hessian for a GP with Gaussian correlation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gaussian_hessianC(XX, X, Z, Kinv, mu_hat, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gaussian_hessianC_+3A_xx">XX</code></td>
<td>
<p>The vector at which to calculate the Hessian</p>
</td></tr>
<tr><td><code id="Gaussian_hessianC_+3A_x">X</code></td>
<td>
<p>The input points</p>
</td></tr>
<tr><td><code id="Gaussian_hessianC_+3A_z">Z</code></td>
<td>
<p>The output values</p>
</td></tr>
<tr><td><code id="Gaussian_hessianC_+3A_kinv">Kinv</code></td>
<td>
<p>The inverse of the correlation matrix</p>
</td></tr>
<tr><td><code id="Gaussian_hessianC_+3A_mu_hat">mu_hat</code></td>
<td>
<p>Estimate of mu</p>
</td></tr>
<tr><td><code id="Gaussian_hessianC_+3A_theta">theta</code></td>
<td>
<p>Theta parameters for the correlation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix, the Hessian at XX
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0)
n &lt;- 40
x &lt;- matrix(runif(n*2), ncol=2)
f1 &lt;- function(a) {sin(2*pi*a[1]) + sin(6*pi*a[2])}
y &lt;- apply(x,1,f1) + rnorm(n,0,.01)
gp &lt;- GauPro(x,y, verbose=2, parallel=FALSE);gp$theta
gp$hessian(c(.2,.75), useC=TRUE) # Should be -38.3, -5.96, -5.96, -389.4 as 2x2 matrix
</code></pre>

<hr>
<h2 id='Gaussian_hessianCC'>Gaussian hessian in C</h2><span id='topic+Gaussian_hessianCC'></span>

<h3>Description</h3>

<p>Gaussian hessian in C
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gaussian_hessianCC(XX, X, Z, Kinv, mu_hat, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gaussian_hessianCC_+3A_xx">XX</code></td>
<td>
<p>point to find Hessian at</p>
</td></tr>
<tr><td><code id="Gaussian_hessianCC_+3A_x">X</code></td>
<td>
<p>matrix of data points</p>
</td></tr>
<tr><td><code id="Gaussian_hessianCC_+3A_z">Z</code></td>
<td>
<p>matrix of output</p>
</td></tr>
<tr><td><code id="Gaussian_hessianCC_+3A_kinv">Kinv</code></td>
<td>
<p>inverse of correlation matrix</p>
</td></tr>
<tr><td><code id="Gaussian_hessianCC_+3A_mu_hat">mu_hat</code></td>
<td>
<p>mean estimate</p>
</td></tr>
<tr><td><code id="Gaussian_hessianCC_+3A_theta">theta</code></td>
<td>
<p>correlation parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Hessian matrix
</p>

<hr>
<h2 id='Gaussian_hessianR'>Calculate Hessian for a GP with Gaussian correlation</h2><span id='topic+Gaussian_hessianR'></span>

<h3>Description</h3>

<p>Calculate Hessian for a GP with Gaussian correlation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gaussian_hessianR(XX, X, Z, Kinv, mu_hat, theta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gaussian_hessianR_+3A_xx">XX</code></td>
<td>
<p>The vector at which to calculate the Hessian</p>
</td></tr>
<tr><td><code id="Gaussian_hessianR_+3A_x">X</code></td>
<td>
<p>The input points</p>
</td></tr>
<tr><td><code id="Gaussian_hessianR_+3A_z">Z</code></td>
<td>
<p>The output values</p>
</td></tr>
<tr><td><code id="Gaussian_hessianR_+3A_kinv">Kinv</code></td>
<td>
<p>The inverse of the correlation matrix</p>
</td></tr>
<tr><td><code id="Gaussian_hessianR_+3A_mu_hat">mu_hat</code></td>
<td>
<p>Estimate of mu</p>
</td></tr>
<tr><td><code id="Gaussian_hessianR_+3A_theta">theta</code></td>
<td>
<p>Theta parameters for the correlation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix, the Hessian at XX
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0)
n &lt;- 40
x &lt;- matrix(runif(n*2), ncol=2)
f1 &lt;- function(a) {sin(2*pi*a[1]) + sin(6*pi*a[2])}
y &lt;- apply(x,1,f1) + rnorm(n,0,.01)
gp &lt;- GauPro(x,y, verbose=2, parallel=FALSE);gp$theta
gp$hessian(c(.2,.75), useC=FALSE) # Should be -38.3, -5.96, -5.96, -389.4 as 2x2 matrix
</code></pre>

<hr>
<h2 id='GowerFactorKernel'>Gower factor Kernel R6 class</h2><span id='topic+GowerFactorKernel'></span>

<h3>Description</h3>

<p>Gower factor Kernel R6 class
</p>
<p>Gower factor Kernel R6 class
</p>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Details</h3>

<p>For a factor that has been converted to its indices.
Each factor will need a separate kernel.
</p>


<h3>Value</h3>

<p>Object of <code><a href="R6.html#topic+R6Class">R6Class</a></code> with methods for fitting GP model.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+GauPro_kernel">GauPro::GauPro_kernel</a></code> -&gt; <code>GauPro_kernel_GowerFactorKernel</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>p</code></dt><dd><p>Parameter for correlation</p>
</dd>
<dt><code>p_est</code></dt><dd><p>Should p be estimated?</p>
</dd>
<dt><code>p_lower</code></dt><dd><p>Lower bound of p</p>
</dd>
<dt><code>p_upper</code></dt><dd><p>Upper bound of p</p>
</dd>
<dt><code>s2</code></dt><dd><p>variance</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 estimated?</p>
</dd>
<dt><code>logs2</code></dt><dd><p>Log of s2</p>
</dd>
<dt><code>logs2_lower</code></dt><dd><p>Lower bound of logs2</p>
</dd>
<dt><code>logs2_upper</code></dt><dd><p>Upper bound of logs2</p>
</dd>
<dt><code>xindex</code></dt><dd><p>Index of the factor (which column of X)</p>
</dd>
<dt><code>nlevels</code></dt><dd><p>Number of levels for the factor</p>
</dd>
<dt><code>offdiagequal</code></dt><dd><p>What should offdiagonal values be set to when the
indices are the same? Use to avoid decomposition errors, similar to
adding a nugget.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GauPro_kernel_GowerFactorKernel-new"><code>GowerFactorKernel$new()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_GowerFactorKernel-k"><code>GowerFactorKernel$k()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_GowerFactorKernel-kone"><code>GowerFactorKernel$kone()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_GowerFactorKernel-dC_dparams"><code>GowerFactorKernel$dC_dparams()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_GowerFactorKernel-C_dC_dparams"><code>GowerFactorKernel$C_dC_dparams()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_GowerFactorKernel-dC_dx"><code>GowerFactorKernel$dC_dx()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_GowerFactorKernel-param_optim_start"><code>GowerFactorKernel$param_optim_start()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_GowerFactorKernel-param_optim_start0"><code>GowerFactorKernel$param_optim_start0()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_GowerFactorKernel-param_optim_lower"><code>GowerFactorKernel$param_optim_lower()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_GowerFactorKernel-param_optim_upper"><code>GowerFactorKernel$param_optim_upper()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_GowerFactorKernel-set_params_from_optim"><code>GowerFactorKernel$set_params_from_optim()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_GowerFactorKernel-s2_from_params"><code>GowerFactorKernel$s2_from_params()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_GowerFactorKernel-print"><code>GowerFactorKernel$print()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_GowerFactorKernel-clone"><code>GowerFactorKernel$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel" data-id="plot"><a href='../../GauPro/html/GauPro_kernel.html#method-GauPro_kernel-plot'><code>GauPro::GauPro_kernel$plot()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-GauPro_kernel_GowerFactorKernel-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize kernel object
</p>


<h5>Usage</h5>

<div class="r"><pre>GowerFactorKernel$new(
  s2 = 1,
  D,
  nlevels,
  xindex,
  p_lower = 0,
  p_upper = 0.9,
  p_est = TRUE,
  s2_lower = 1e-08,
  s2_upper = 1e+08,
  s2_est = TRUE,
  p,
  useC = TRUE,
  offdiagequal = 1 - 1e-06
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>s2</code></dt><dd><p>Initial variance</p>
</dd>
<dt><code>D</code></dt><dd><p>Number of input dimensions of data</p>
</dd>
<dt><code>nlevels</code></dt><dd><p>Number of levels for the factor</p>
</dd>
<dt><code>xindex</code></dt><dd><p>Index of the factor (which column of X)</p>
</dd>
<dt><code>p_lower</code></dt><dd><p>Lower bound for p</p>
</dd>
<dt><code>p_upper</code></dt><dd><p>Upper bound for p</p>
</dd>
<dt><code>p_est</code></dt><dd><p>Should p be estimated?</p>
</dd>
<dt><code>s2_lower</code></dt><dd><p>Lower bound for s2</p>
</dd>
<dt><code>s2_upper</code></dt><dd><p>Upper bound for s2</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Should s2 be estimated?</p>
</dd>
<dt><code>p</code></dt><dd><p>Vector of correlations</p>
</dd>
<dt><code>useC</code></dt><dd><p>Should C code used? Not implemented for FactorKernel yet.</p>
</dd>
<dt><code>offdiagequal</code></dt><dd><p>What should offdiagonal values be set to when the
indices are the same? Use to avoid decomposition errors, similar to
adding a nugget.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_GowerFactorKernel-k"></a>



<h4>Method <code>k()</code></h4>

<p>Calculate covariance between two points
</p>


<h5>Usage</h5>

<div class="r"><pre>GowerFactorKernel$k(x, y = NULL, p = self$p, s2 = self$s2, params = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>vector.</p>
</dd>
<dt><code>y</code></dt><dd><p>vector, optional. If excluded, find correlation
of x with itself.</p>
</dd>
<dt><code>p</code></dt><dd><p>Correlation parameters.</p>
</dd>
<dt><code>s2</code></dt><dd><p>Variance parameter.</p>
</dd>
<dt><code>params</code></dt><dd><p>parameters to use instead of beta and s2.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_GowerFactorKernel-kone"></a>



<h4>Method <code>kone()</code></h4>

<p>Find covariance of two points
</p>


<h5>Usage</h5>

<div class="r"><pre>GowerFactorKernel$kone(
  x,
  y,
  p,
  s2,
  isdiag = TRUE,
  offdiagequal = self$offdiagequal
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>vector</p>
</dd>
<dt><code>y</code></dt><dd><p>vector</p>
</dd>
<dt><code>p</code></dt><dd><p>correlation parameters on regular scale</p>
</dd>
<dt><code>s2</code></dt><dd><p>Variance parameter</p>
</dd>
<dt><code>isdiag</code></dt><dd><p>Is this on the diagonal of the covariance?</p>
</dd>
<dt><code>offdiagequal</code></dt><dd><p>What should offdiagonal values be set to when the
indices are the same? Use to avoid decomposition errors, similar to
adding a nugget.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_GowerFactorKernel-dC_dparams"></a>



<h4>Method <code>dC_dparams()</code></h4>

<p>Derivative of covariance with respect to parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>GowerFactorKernel$dC_dparams(params = NULL, X, C_nonug, C, nug)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Kernel parameters</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points in rows</p>
</dd>
<dt><code>C_nonug</code></dt><dd><p>Covariance without nugget added to diagonal</p>
</dd>
<dt><code>C</code></dt><dd><p>Covariance with nugget</p>
</dd>
<dt><code>nug</code></dt><dd><p>Value of nugget</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_GowerFactorKernel-C_dC_dparams"></a>



<h4>Method <code>C_dC_dparams()</code></h4>

<p>Calculate covariance matrix and its derivative
with respect to parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>GowerFactorKernel$C_dC_dparams(params = NULL, X, nug)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Kernel parameters</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points in rows</p>
</dd>
<dt><code>nug</code></dt><dd><p>Value of nugget</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_GowerFactorKernel-dC_dx"></a>



<h4>Method <code>dC_dx()</code></h4>

<p>Derivative of covariance with respect to X
</p>


<h5>Usage</h5>

<div class="r"><pre>GowerFactorKernel$dC_dx(XX, X, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>matrix of points</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points to take derivative with respect to</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional args, not used</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_GowerFactorKernel-param_optim_start"></a>



<h4>Method <code>param_optim_start()</code></h4>

<p>Starting point for parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>GowerFactorKernel$param_optim_start(
  jitter = F,
  y,
  p_est = self$p_est,
  s2_est = self$s2_est
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>jitter</code></dt><dd><p>Should there be a jitter?</p>
</dd>
<dt><code>y</code></dt><dd><p>Output</p>
</dd>
<dt><code>p_est</code></dt><dd><p>Is p being estimated?</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
<dt><code>alpha_est</code></dt><dd><p>Is alpha being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_GowerFactorKernel-param_optim_start0"></a>



<h4>Method <code>param_optim_start0()</code></h4>

<p>Starting point for parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>GowerFactorKernel$param_optim_start0(
  jitter = F,
  y,
  p_est = self$p_est,
  s2_est = self$s2_est
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>jitter</code></dt><dd><p>Should there be a jitter?</p>
</dd>
<dt><code>y</code></dt><dd><p>Output</p>
</dd>
<dt><code>p_est</code></dt><dd><p>Is p being estimated?</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
<dt><code>alpha_est</code></dt><dd><p>Is alpha being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_GowerFactorKernel-param_optim_lower"></a>



<h4>Method <code>param_optim_lower()</code></h4>

<p>Lower bounds of parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>GowerFactorKernel$param_optim_lower(p_est = self$p_est, s2_est = self$s2_est)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>p_est</code></dt><dd><p>Is p being estimated?</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
<dt><code>alpha_est</code></dt><dd><p>Is alpha being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_GowerFactorKernel-param_optim_upper"></a>



<h4>Method <code>param_optim_upper()</code></h4>

<p>Upper bounds of parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>GowerFactorKernel$param_optim_upper(p_est = self$p_est, s2_est = self$s2_est)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>p_est</code></dt><dd><p>Is p being estimated?</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
<dt><code>alpha_est</code></dt><dd><p>Is alpha being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_GowerFactorKernel-set_params_from_optim"></a>



<h4>Method <code>set_params_from_optim()</code></h4>

<p>Set parameters from optimization output
</p>


<h5>Usage</h5>

<div class="r"><pre>GowerFactorKernel$set_params_from_optim(
  optim_out,
  p_est = self$p_est,
  s2_est = self$s2_est
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>optim_out</code></dt><dd><p>Output from optimization</p>
</dd>
<dt><code>p_est</code></dt><dd><p>Is p being estimated?</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
<dt><code>alpha_est</code></dt><dd><p>Is alpha being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_GowerFactorKernel-s2_from_params"></a>



<h4>Method <code>s2_from_params()</code></h4>

<p>Get s2 from params vector
</p>


<h5>Usage</h5>

<div class="r"><pre>GowerFactorKernel$s2_from_params(params, s2_est = self$s2_est)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>parameter vector</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_GowerFactorKernel-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print this object
</p>


<h5>Usage</h5>

<div class="r"><pre>GowerFactorKernel$print()</pre></div>


<hr>
<a id="method-GauPro_kernel_GowerFactorKernel-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>GowerFactorKernel$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>kk &lt;- GowerFactorKernel$new(D=1, nlevels=5, xindex=1, p=.2)
kmat &lt;- outer(1:5, 1:5, Vectorize(kk$k))
kmat
kk$plot()


# 2D, Gaussian on 1D, index on 2nd dim
library(dplyr)
n &lt;- 20
X &lt;- cbind(matrix(runif(n,2,6), ncol=1),
           matrix(sample(1:2, size=n, replace=TRUE), ncol=1))
X &lt;- rbind(X, c(3.3,3))
n &lt;- nrow(X)
Z &lt;- X[,1] - (X[,2]-1.8)^2 + rnorm(n,0,.1)
tibble(X=X, Z) %&gt;% arrange(X,Z)
k2a &lt;- IgnoreIndsKernel$new(k=Gaussian$new(D=1), ignoreinds = 2)
k2b &lt;- GowerFactorKernel$new(D=2, nlevels=3, xind=2)
k2 &lt;- k2a * k2b
k2b$p_upper &lt;- .65*k2b$p_upper
gp &lt;- GauPro_kernel_model$new(X=X, Z=Z, kernel = k2, verbose = 5,
                              nug.min=1e-2, restarts=0)
gp$kernel$k1$kernel$beta
gp$kernel$k2$p
gp$kernel$k(x = gp$X)
tibble(X=X, Z=Z, pred=gp$predict(X)) %&gt;% arrange(X, Z)
tibble(X=X[,2], Z) %&gt;% group_by(X) %&gt;% summarize(n=n(), mean(Z))
curve(gp$pred(cbind(matrix(x,ncol=1),1)),2,6, ylim=c(min(Z), max(Z)))
points(X[X[,2]==1,1], Z[X[,2]==1])
curve(gp$pred(cbind(matrix(x,ncol=1),2)), add=TRUE, col=2)
points(X[X[,2]==2,1], Z[X[,2]==2], col=2)
curve(gp$pred(cbind(matrix(x,ncol=1),3)), add=TRUE, col=3)
points(X[X[,2]==3,1], Z[X[,2]==3], col=3)
legend(legend=1:3, fill=1:3, x="topleft")
# See which points affect (5.5, 3 themost)
data.frame(X, cov=gp$kernel$k(X, c(5.5,3))) %&gt;% arrange(-cov)
plot(k2b)


</code></pre>

<hr>
<h2 id='gpkm'>Gaussian process regression model</h2><span id='topic+gpkm'></span>

<h3>Description</h3>

<p>Fits a Gaussian process regression model to data.
</p>
<p>An R6 object is returned with many methods.
</p>
<p>'gpkm()' is an alias for 'GauPro_kernel_model$new()'.
For full documentation, see documentation for 'GauPro_kernel_model'.
</p>
<p>Standard methods that work include 'plot()', 'summary()', and 'predict()'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpkm(
  X,
  Z,
  kernel,
  trend,
  verbose = 0,
  useC = TRUE,
  useGrad = TRUE,
  parallel = FALSE,
  parallel_cores = "detect",
  nug = 1e-06,
  nug.min = 1e-08,
  nug.max = 100,
  nug.est = TRUE,
  param.est = TRUE,
  restarts = 0,
  normalize = FALSE,
  optimizer = "L-BFGS-B",
  track_optim = FALSE,
  formula,
  data,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gpkm_+3A_x">X</code></td>
<td>
<p>Matrix whose rows are the input points</p>
</td></tr>
<tr><td><code id="gpkm_+3A_z">Z</code></td>
<td>
<p>Output points corresponding to X</p>
</td></tr>
<tr><td><code id="gpkm_+3A_kernel">kernel</code></td>
<td>
<p>The kernel to use. E.g., Gaussian$new().</p>
</td></tr>
<tr><td><code id="gpkm_+3A_trend">trend</code></td>
<td>
<p>Trend to use. E.g., trend_constant$new().</p>
</td></tr>
<tr><td><code id="gpkm_+3A_verbose">verbose</code></td>
<td>
<p>Amount of stuff to print. 0 is little, 2 is a lot.</p>
</td></tr>
<tr><td><code id="gpkm_+3A_usec">useC</code></td>
<td>
<p>Should C code be used when possible? Should be faster.</p>
</td></tr>
<tr><td><code id="gpkm_+3A_usegrad">useGrad</code></td>
<td>
<p>Should the gradient be used?</p>
</td></tr>
<tr><td><code id="gpkm_+3A_parallel">parallel</code></td>
<td>
<p>Should code be run in parallel? Make optimization
faster but uses more computer resources.</p>
</td></tr>
<tr><td><code id="gpkm_+3A_parallel_cores">parallel_cores</code></td>
<td>
<p>When using parallel, how many cores should
be used?</p>
</td></tr>
<tr><td><code id="gpkm_+3A_nug">nug</code></td>
<td>
<p>Value for the nugget. The starting value if estimating it.</p>
</td></tr>
<tr><td><code id="gpkm_+3A_nug.min">nug.min</code></td>
<td>
<p>Minimum allowable value for the nugget.</p>
</td></tr>
<tr><td><code id="gpkm_+3A_nug.max">nug.max</code></td>
<td>
<p>Maximum allowable value for the nugget.</p>
</td></tr>
<tr><td><code id="gpkm_+3A_nug.est">nug.est</code></td>
<td>
<p>Should the nugget be estimated?</p>
</td></tr>
<tr><td><code id="gpkm_+3A_param.est">param.est</code></td>
<td>
<p>Should the kernel parameters be estimated?</p>
</td></tr>
<tr><td><code id="gpkm_+3A_restarts">restarts</code></td>
<td>
<p>How many optimization restarts should be used when
estimating parameters?</p>
</td></tr>
<tr><td><code id="gpkm_+3A_normalize">normalize</code></td>
<td>
<p>Should the data be normalized?</p>
</td></tr>
<tr><td><code id="gpkm_+3A_optimizer">optimizer</code></td>
<td>
<p>What algorithm should be used to optimize the
parameters.</p>
</td></tr>
<tr><td><code id="gpkm_+3A_track_optim">track_optim</code></td>
<td>
<p>Should it track the parameters evaluated
while optimizing?</p>
</td></tr>
<tr><td><code id="gpkm_+3A_formula">formula</code></td>
<td>
<p>Formula for the data if giving in a data frame.</p>
</td></tr>
<tr><td><code id="gpkm_+3A_data">data</code></td>
<td>
<p>Data frame of data. Use in conjunction with formula.</p>
</td></tr>
<tr><td><code id="gpkm_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default kernel is a Matern 5/2 kernel, but factor/character inputs
will be given factor kernels.
</p>

<hr>
<h2 id='gradfuncarray'>Calculate gradfunc in optimization to speed up.
NEEDS TO APERM dC_dparams
Doesn't need to be exported, should only be useful in functions.</h2><span id='topic+gradfuncarray'></span>

<h3>Description</h3>

<p>Calculate gradfunc in optimization to speed up.
NEEDS TO APERM dC_dparams
Doesn't need to be exported, should only be useful in functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gradfuncarray(dC_dparams, Cinv, Cinv_yminusmu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gradfuncarray_+3A_dc_dparams">dC_dparams</code></td>
<td>
<p>Derivative matrix for covariance function wrt kernel parameters</p>
</td></tr>
<tr><td><code id="gradfuncarray_+3A_cinv">Cinv</code></td>
<td>
<p>Inverse of covariance matrix</p>
</td></tr>
<tr><td><code id="gradfuncarray_+3A_cinv_yminusmu">Cinv_yminusmu</code></td>
<td>
<p>Vector that is the inverse of C times y minus the mean.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector, one value for each parameter
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gradfuncarray(array(dim=c(2,4,4), data=rnorm(32)), matrix(rnorm(16),4,4), rnorm(4))
</code></pre>

<hr>
<h2 id='gradfuncarrayR'>Calculate gradfunc in optimization to speed up.
NEEDS TO APERM dC_dparams
Doesn't need to be exported, should only be useful in functions.</h2><span id='topic+gradfuncarrayR'></span>

<h3>Description</h3>

<p>Calculate gradfunc in optimization to speed up.
NEEDS TO APERM dC_dparams
Doesn't need to be exported, should only be useful in functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gradfuncarrayR(dC_dparams, Cinv, Cinv_yminusmu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gradfuncarrayR_+3A_dc_dparams">dC_dparams</code></td>
<td>
<p>Derivative matrix for covariance function wrt kernel parameters</p>
</td></tr>
<tr><td><code id="gradfuncarrayR_+3A_cinv">Cinv</code></td>
<td>
<p>Inverse of covariance matrix</p>
</td></tr>
<tr><td><code id="gradfuncarrayR_+3A_cinv_yminusmu">Cinv_yminusmu</code></td>
<td>
<p>Vector that is the inverse of C times y minus the mean.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector, one value for each parameter
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a1 &lt;- array(dim=c(2,4,4), data=rnorm(32))
a2 &lt;- matrix(rnorm(16),4,4)
a3 &lt;- rnorm(4)
#gradfuncarray(a1, a2, a3)
#gradfuncarrayR(a1, a2, a3)
</code></pre>

<hr>
<h2 id='IgnoreIndsKernel'>Kernel R6 class</h2><span id='topic+IgnoreIndsKernel'></span>

<h3>Description</h3>

<p>Kernel R6 class
</p>
<p>Kernel R6 class
</p>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Value</h3>

<p>Object of <code><a href="R6.html#topic+R6Class">R6Class</a></code> with methods for fitting GP model.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+GauPro_kernel">GauPro::GauPro_kernel</a></code> -&gt; <code>GauPro_kernel_IgnoreInds</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>D</code></dt><dd><p>Number of input dimensions of data</p>
</dd>
<dt><code>kernel</code></dt><dd><p>Kernel to use on indices that aren't ignored</p>
</dd>
<dt><code>ignoreinds</code></dt><dd><p>Indices to ignore. For a matrix X, these are the columns
to ignore. For example, when those dimensions will be given a different
kernel, such as for factors.</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
<dt><code>s2</code></dt><dd><p>Value of s2 (variance)</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GauPro_kernel_IgnoreInds-new"><code>IgnoreIndsKernel$new()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_IgnoreInds-k"><code>IgnoreIndsKernel$k()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_IgnoreInds-kone"><code>IgnoreIndsKernel$kone()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_IgnoreInds-dC_dparams"><code>IgnoreIndsKernel$dC_dparams()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_IgnoreInds-C_dC_dparams"><code>IgnoreIndsKernel$C_dC_dparams()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_IgnoreInds-dC_dx"><code>IgnoreIndsKernel$dC_dx()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_IgnoreInds-param_optim_start"><code>IgnoreIndsKernel$param_optim_start()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_IgnoreInds-param_optim_start0"><code>IgnoreIndsKernel$param_optim_start0()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_IgnoreInds-param_optim_lower"><code>IgnoreIndsKernel$param_optim_lower()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_IgnoreInds-param_optim_upper"><code>IgnoreIndsKernel$param_optim_upper()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_IgnoreInds-set_params_from_optim"><code>IgnoreIndsKernel$set_params_from_optim()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_IgnoreInds-s2_from_params"><code>IgnoreIndsKernel$s2_from_params()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_IgnoreInds-print"><code>IgnoreIndsKernel$print()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_IgnoreInds-clone"><code>IgnoreIndsKernel$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel" data-id="plot"><a href='../../GauPro/html/GauPro_kernel.html#method-GauPro_kernel-plot'><code>GauPro::GauPro_kernel$plot()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-GauPro_kernel_IgnoreInds-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize kernel object
</p>


<h5>Usage</h5>

<div class="r"><pre>IgnoreIndsKernel$new(k, ignoreinds, useC = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>k</code></dt><dd><p>Kernel to use on the non-ignored indices</p>
</dd>
<dt><code>ignoreinds</code></dt><dd><p>Indices of columns of X to ignore.</p>
</dd>
<dt><code>useC</code></dt><dd><p>Should C code used? Not implemented for IgnoreInds.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_IgnoreInds-k"></a>



<h4>Method <code>k()</code></h4>

<p>Calculate covariance between two points
</p>


<h5>Usage</h5>

<div class="r"><pre>IgnoreIndsKernel$k(x, y = NULL, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>vector.</p>
</dd>
<dt><code>y</code></dt><dd><p>vector, optional. If excluded, find correlation
of x with itself.</p>
</dd>
<dt><code>...</code></dt><dd><p>Passed to kernel</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_IgnoreInds-kone"></a>



<h4>Method <code>kone()</code></h4>

<p>Find covariance of two points
</p>


<h5>Usage</h5>

<div class="r"><pre>IgnoreIndsKernel$kone(x, y, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>vector</p>
</dd>
<dt><code>y</code></dt><dd><p>vector</p>
</dd>
<dt><code>...</code></dt><dd><p>Passed to kernel</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_IgnoreInds-dC_dparams"></a>



<h4>Method <code>dC_dparams()</code></h4>

<p>Derivative of covariance with respect to parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>IgnoreIndsKernel$dC_dparams(params = NULL, X, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Kernel parameters</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points in rows</p>
</dd>
<dt><code>...</code></dt><dd><p>Passed to kernel</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_IgnoreInds-C_dC_dparams"></a>



<h4>Method <code>C_dC_dparams()</code></h4>

<p>Calculate covariance matrix and its derivative
with respect to parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>IgnoreIndsKernel$C_dC_dparams(params = NULL, X, nug)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Kernel parameters</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points in rows</p>
</dd>
<dt><code>nug</code></dt><dd><p>Value of nugget</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_IgnoreInds-dC_dx"></a>



<h4>Method <code>dC_dx()</code></h4>

<p>Derivative of covariance with respect to X
</p>


<h5>Usage</h5>

<div class="r"><pre>IgnoreIndsKernel$dC_dx(XX, X, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>matrix of points</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points to take derivative with respect to</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional arguments passed on to the kernel</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_IgnoreInds-param_optim_start"></a>



<h4>Method <code>param_optim_start()</code></h4>

<p>Starting point for parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>IgnoreIndsKernel$param_optim_start(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Passed to kernel</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_IgnoreInds-param_optim_start0"></a>



<h4>Method <code>param_optim_start0()</code></h4>

<p>Starting point for parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>IgnoreIndsKernel$param_optim_start0(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Passed to kernel</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_IgnoreInds-param_optim_lower"></a>



<h4>Method <code>param_optim_lower()</code></h4>

<p>Lower bounds of parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>IgnoreIndsKernel$param_optim_lower(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Passed to kernel</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_IgnoreInds-param_optim_upper"></a>



<h4>Method <code>param_optim_upper()</code></h4>

<p>Upper bounds of parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>IgnoreIndsKernel$param_optim_upper(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Passed to kernel</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_IgnoreInds-set_params_from_optim"></a>



<h4>Method <code>set_params_from_optim()</code></h4>

<p>Set parameters from optimization output
</p>


<h5>Usage</h5>

<div class="r"><pre>IgnoreIndsKernel$set_params_from_optim(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Passed to kernel</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_IgnoreInds-s2_from_params"></a>



<h4>Method <code>s2_from_params()</code></h4>

<p>Get s2 from params vector
</p>


<h5>Usage</h5>

<div class="r"><pre>IgnoreIndsKernel$s2_from_params(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Passed to kernel</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_IgnoreInds-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print this object
</p>


<h5>Usage</h5>

<div class="r"><pre>IgnoreIndsKernel$print()</pre></div>


<hr>
<a id="method-GauPro_kernel_IgnoreInds-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>IgnoreIndsKernel$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>kg &lt;- Gaussian$new(D=3)
kig &lt;- GauPro::IgnoreIndsKernel$new(k = Gaussian$new(D=3), ignoreinds = 2)
Xtmp &lt;- as.matrix(expand.grid(1:2, 1:2, 1:2))
cbind(Xtmp, kig$k(Xtmp))
cbind(Xtmp, kg$k(Xtmp))
</code></pre>

<hr>
<h2 id='kernel_cubic_dC'>Derivative of cubic kernel covariance matrix in C</h2><span id='topic+kernel_cubic_dC'></span>

<h3>Description</h3>

<p>Derivative of cubic kernel covariance matrix in C
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel_cubic_dC(x, theta, C_nonug, s2_est, beta_est, lenparams_D, s2_nug, s2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel_cubic_dC_+3A_x">x</code></td>
<td>
<p>Matrix x</p>
</td></tr>
<tr><td><code id="kernel_cubic_dC_+3A_theta">theta</code></td>
<td>
<p>Theta vector</p>
</td></tr>
<tr><td><code id="kernel_cubic_dC_+3A_c_nonug">C_nonug</code></td>
<td>
<p>cov mat without nugget</p>
</td></tr>
<tr><td><code id="kernel_cubic_dC_+3A_s2_est">s2_est</code></td>
<td>
<p>whether s2 is being estimated</p>
</td></tr>
<tr><td><code id="kernel_cubic_dC_+3A_beta_est">beta_est</code></td>
<td>
<p>Whether theta/beta is being estimated</p>
</td></tr>
<tr><td><code id="kernel_cubic_dC_+3A_lenparams_d">lenparams_D</code></td>
<td>
<p>Number of parameters the derivative is being calculated for</p>
</td></tr>
<tr><td><code id="kernel_cubic_dC_+3A_s2_nug">s2_nug</code></td>
<td>
<p>s2 times the nug</p>
</td></tr>
<tr><td><code id="kernel_cubic_dC_+3A_s2">s2</code></td>
<td>
<p>s2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Correlation matrix
</p>

<hr>
<h2 id='kernel_exponential_dC'>Derivative of Matern 5/2 kernel covariance matrix in C</h2><span id='topic+kernel_exponential_dC'></span>

<h3>Description</h3>

<p>Derivative of Matern 5/2 kernel covariance matrix in C
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel_exponential_dC(
  x,
  theta,
  C_nonug,
  s2_est,
  beta_est,
  lenparams_D,
  s2_nug,
  s2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel_exponential_dC_+3A_x">x</code></td>
<td>
<p>Matrix x</p>
</td></tr>
<tr><td><code id="kernel_exponential_dC_+3A_theta">theta</code></td>
<td>
<p>Theta vector</p>
</td></tr>
<tr><td><code id="kernel_exponential_dC_+3A_c_nonug">C_nonug</code></td>
<td>
<p>cov mat without nugget</p>
</td></tr>
<tr><td><code id="kernel_exponential_dC_+3A_s2_est">s2_est</code></td>
<td>
<p>whether s2 is being estimated</p>
</td></tr>
<tr><td><code id="kernel_exponential_dC_+3A_beta_est">beta_est</code></td>
<td>
<p>Whether theta/beta is being estimated</p>
</td></tr>
<tr><td><code id="kernel_exponential_dC_+3A_lenparams_d">lenparams_D</code></td>
<td>
<p>Number of parameters the derivative is being calculated for</p>
</td></tr>
<tr><td><code id="kernel_exponential_dC_+3A_s2_nug">s2_nug</code></td>
<td>
<p>s2 times the nug</p>
</td></tr>
<tr><td><code id="kernel_exponential_dC_+3A_s2">s2</code></td>
<td>
<p>s2 parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Correlation matrix
</p>

<hr>
<h2 id='kernel_gauss_dC'>Derivative of Gaussian kernel covariance matrix in C</h2><span id='topic+kernel_gauss_dC'></span>

<h3>Description</h3>

<p>Derivative of Gaussian kernel covariance matrix in C
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel_gauss_dC(x, theta, C_nonug, s2_est, beta_est, lenparams_D, s2_nug)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel_gauss_dC_+3A_x">x</code></td>
<td>
<p>Matrix x</p>
</td></tr>
<tr><td><code id="kernel_gauss_dC_+3A_theta">theta</code></td>
<td>
<p>Theta vector</p>
</td></tr>
<tr><td><code id="kernel_gauss_dC_+3A_c_nonug">C_nonug</code></td>
<td>
<p>cov mat without nugget</p>
</td></tr>
<tr><td><code id="kernel_gauss_dC_+3A_s2_est">s2_est</code></td>
<td>
<p>whether s2 is being estimated</p>
</td></tr>
<tr><td><code id="kernel_gauss_dC_+3A_beta_est">beta_est</code></td>
<td>
<p>Whether theta/beta is being estimated</p>
</td></tr>
<tr><td><code id="kernel_gauss_dC_+3A_lenparams_d">lenparams_D</code></td>
<td>
<p>Number of parameters the derivative is being calculated for</p>
</td></tr>
<tr><td><code id="kernel_gauss_dC_+3A_s2_nug">s2_nug</code></td>
<td>
<p>s2 times the nug</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Correlation matrix
</p>

<hr>
<h2 id='kernel_latentFactor_dC'>Derivative of covariance matrix of X with respect to kernel
parameters for the Latent Factor Kernel</h2><span id='topic+kernel_latentFactor_dC'></span>

<h3>Description</h3>

<p>Derivative of covariance matrix of X with respect to kernel
parameters for the Latent Factor Kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel_latentFactor_dC(
  x,
  pf,
  C_nonug,
  s2_est,
  p_est,
  lenparams_D,
  s2_nug,
  latentdim,
  xindex,
  nlevels,
  s2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel_latentFactor_dC_+3A_x">x</code></td>
<td>
<p>Matrix x</p>
</td></tr>
<tr><td><code id="kernel_latentFactor_dC_+3A_pf">pf</code></td>
<td>
<p>pf vector</p>
</td></tr>
<tr><td><code id="kernel_latentFactor_dC_+3A_c_nonug">C_nonug</code></td>
<td>
<p>cov mat without nugget</p>
</td></tr>
<tr><td><code id="kernel_latentFactor_dC_+3A_s2_est">s2_est</code></td>
<td>
<p>whether s2 is being estimated</p>
</td></tr>
<tr><td><code id="kernel_latentFactor_dC_+3A_p_est">p_est</code></td>
<td>
<p>Whether theta/beta is being estimated</p>
</td></tr>
<tr><td><code id="kernel_latentFactor_dC_+3A_lenparams_d">lenparams_D</code></td>
<td>
<p>Number of parameters the derivative is being calculated for</p>
</td></tr>
<tr><td><code id="kernel_latentFactor_dC_+3A_s2_nug">s2_nug</code></td>
<td>
<p>s2 times the nug</p>
</td></tr>
<tr><td><code id="kernel_latentFactor_dC_+3A_latentdim">latentdim</code></td>
<td>
<p>Number of latent dimensions</p>
</td></tr>
<tr><td><code id="kernel_latentFactor_dC_+3A_xindex">xindex</code></td>
<td>
<p>Which column of x is the indexing variable</p>
</td></tr>
<tr><td><code id="kernel_latentFactor_dC_+3A_nlevels">nlevels</code></td>
<td>
<p>Number of levels</p>
</td></tr>
<tr><td><code id="kernel_latentFactor_dC_+3A_s2">s2</code></td>
<td>
<p>Value of s2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Correlation matrix
</p>

<hr>
<h2 id='kernel_matern32_dC'>Derivative of Matern 5/2 kernel covariance matrix in C</h2><span id='topic+kernel_matern32_dC'></span>

<h3>Description</h3>

<p>Derivative of Matern 5/2 kernel covariance matrix in C
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel_matern32_dC(x, theta, C_nonug, s2_est, beta_est, lenparams_D, s2_nug)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel_matern32_dC_+3A_x">x</code></td>
<td>
<p>Matrix x</p>
</td></tr>
<tr><td><code id="kernel_matern32_dC_+3A_theta">theta</code></td>
<td>
<p>Theta vector</p>
</td></tr>
<tr><td><code id="kernel_matern32_dC_+3A_c_nonug">C_nonug</code></td>
<td>
<p>cov mat without nugget</p>
</td></tr>
<tr><td><code id="kernel_matern32_dC_+3A_s2_est">s2_est</code></td>
<td>
<p>whether s2 is being estimated</p>
</td></tr>
<tr><td><code id="kernel_matern32_dC_+3A_beta_est">beta_est</code></td>
<td>
<p>Whether theta/beta is being estimated</p>
</td></tr>
<tr><td><code id="kernel_matern32_dC_+3A_lenparams_d">lenparams_D</code></td>
<td>
<p>Number of parameters the derivative is being calculated for</p>
</td></tr>
<tr><td><code id="kernel_matern32_dC_+3A_s2_nug">s2_nug</code></td>
<td>
<p>s2 times the nug</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Correlation matrix
</p>

<hr>
<h2 id='kernel_matern52_dC'>Derivative of Matern 5/2 kernel covariance matrix in C</h2><span id='topic+kernel_matern52_dC'></span>

<h3>Description</h3>

<p>Derivative of Matern 5/2 kernel covariance matrix in C
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel_matern52_dC(x, theta, C_nonug, s2_est, beta_est, lenparams_D, s2_nug)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel_matern52_dC_+3A_x">x</code></td>
<td>
<p>Matrix x</p>
</td></tr>
<tr><td><code id="kernel_matern52_dC_+3A_theta">theta</code></td>
<td>
<p>Theta vector</p>
</td></tr>
<tr><td><code id="kernel_matern52_dC_+3A_c_nonug">C_nonug</code></td>
<td>
<p>cov mat without nugget</p>
</td></tr>
<tr><td><code id="kernel_matern52_dC_+3A_s2_est">s2_est</code></td>
<td>
<p>whether s2 is being estimated</p>
</td></tr>
<tr><td><code id="kernel_matern52_dC_+3A_beta_est">beta_est</code></td>
<td>
<p>Whether theta/beta is being estimated</p>
</td></tr>
<tr><td><code id="kernel_matern52_dC_+3A_lenparams_d">lenparams_D</code></td>
<td>
<p>Number of parameters the derivative is being calculated for</p>
</td></tr>
<tr><td><code id="kernel_matern52_dC_+3A_s2_nug">s2_nug</code></td>
<td>
<p>s2 times the nug</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Correlation matrix
</p>

<hr>
<h2 id='kernel_orderedFactor_dC'>Derivative of covariance matrix of X with respect to kernel
parameters for the Ordered Factor Kernel</h2><span id='topic+kernel_orderedFactor_dC'></span>

<h3>Description</h3>

<p>Derivative of covariance matrix of X with respect to kernel
parameters for the Ordered Factor Kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel_orderedFactor_dC(
  x,
  pf,
  C_nonug,
  s2_est,
  p_est,
  lenparams_D,
  s2_nug,
  xindex,
  nlevels,
  s2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel_orderedFactor_dC_+3A_x">x</code></td>
<td>
<p>Matrix x</p>
</td></tr>
<tr><td><code id="kernel_orderedFactor_dC_+3A_pf">pf</code></td>
<td>
<p>pf vector</p>
</td></tr>
<tr><td><code id="kernel_orderedFactor_dC_+3A_c_nonug">C_nonug</code></td>
<td>
<p>cov mat without nugget</p>
</td></tr>
<tr><td><code id="kernel_orderedFactor_dC_+3A_s2_est">s2_est</code></td>
<td>
<p>whether s2 is being estimated</p>
</td></tr>
<tr><td><code id="kernel_orderedFactor_dC_+3A_p_est">p_est</code></td>
<td>
<p>Whether theta/beta is being estimated</p>
</td></tr>
<tr><td><code id="kernel_orderedFactor_dC_+3A_lenparams_d">lenparams_D</code></td>
<td>
<p>Number of parameters the derivative is being calculated for</p>
</td></tr>
<tr><td><code id="kernel_orderedFactor_dC_+3A_s2_nug">s2_nug</code></td>
<td>
<p>s2 times the nug</p>
</td></tr>
<tr><td><code id="kernel_orderedFactor_dC_+3A_xindex">xindex</code></td>
<td>
<p>Which column of x is the indexing variable</p>
</td></tr>
<tr><td><code id="kernel_orderedFactor_dC_+3A_nlevels">nlevels</code></td>
<td>
<p>Number of levels</p>
</td></tr>
<tr><td><code id="kernel_orderedFactor_dC_+3A_s2">s2</code></td>
<td>
<p>Value of s2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Correlation matrix
</p>

<hr>
<h2 id='kernel_product'>Gaussian Kernel R6 class</h2><span id='topic+kernel_product'></span>

<h3>Description</h3>

<p>Gaussian Kernel R6 class
</p>
<p>Gaussian Kernel R6 class
</p>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Value</h3>

<p>Object of <code><a href="R6.html#topic+R6Class">R6Class</a></code> with methods for fitting GP model.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+GauPro_kernel">GauPro::GauPro_kernel</a></code> -&gt; <code>GauPro_kernel_product</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>k1</code></dt><dd><p>kernel 1</p>
</dd>
<dt><code>k2</code></dt><dd><p>kernel 2</p>
</dd>
<dt><code>s2</code></dt><dd><p>Variance</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>k1pl</code></dt><dd><p>param length of kernel 1</p>
</dd>
<dt><code>k2pl</code></dt><dd><p>param length of kernel 2</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GauPro_kernel_product-new"><code>kernel_product$new()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_product-k"><code>kernel_product$k()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_product-param_optim_start"><code>kernel_product$param_optim_start()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_product-param_optim_start0"><code>kernel_product$param_optim_start0()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_product-param_optim_lower"><code>kernel_product$param_optim_lower()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_product-param_optim_upper"><code>kernel_product$param_optim_upper()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_product-set_params_from_optim"><code>kernel_product$set_params_from_optim()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_product-dC_dparams"><code>kernel_product$dC_dparams()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_product-C_dC_dparams"><code>kernel_product$C_dC_dparams()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_product-dC_dx"><code>kernel_product$dC_dx()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_product-s2_from_params"><code>kernel_product$s2_from_params()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_product-print"><code>kernel_product$print()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_product-clone"><code>kernel_product$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel" data-id="plot"><a href='../../GauPro/html/GauPro_kernel.html#method-GauPro_kernel-plot'><code>GauPro::GauPro_kernel$plot()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-GauPro_kernel_product-new"></a>



<h4>Method <code>new()</code></h4>

<p>Is s2 being estimated?
</p>
<p>Length of the parameters of k1
</p>
<p>Length of the parameters of k2
</p>
<p>Initialize kernel
</p>


<h5>Usage</h5>

<div class="r"><pre>kernel_product$new(k1, k2, useC = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>k1</code></dt><dd><p>Kernel 1</p>
</dd>
<dt><code>k2</code></dt><dd><p>Kernel 2</p>
</dd>
<dt><code>useC</code></dt><dd><p>Should C code used? Not applicable for kernel product.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_product-k"></a>



<h4>Method <code>k()</code></h4>

<p>Calculate covariance between two points
</p>


<h5>Usage</h5>

<div class="r"><pre>kernel_product$k(x, y = NULL, params, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>vector.</p>
</dd>
<dt><code>y</code></dt><dd><p>vector, optional. If excluded, find correlation
of x with itself.</p>
</dd>
<dt><code>params</code></dt><dd><p>parameters to use instead of beta and s2.</p>
</dd>
<dt><code>...</code></dt><dd><p>Not used</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_product-param_optim_start"></a>



<h4>Method <code>param_optim_start()</code></h4>

<p>Starting point for parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>kernel_product$param_optim_start(jitter = F, y)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>jitter</code></dt><dd><p>Should there be a jitter?</p>
</dd>
<dt><code>y</code></dt><dd><p>Output</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_product-param_optim_start0"></a>



<h4>Method <code>param_optim_start0()</code></h4>

<p>Starting point for parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>kernel_product$param_optim_start0(jitter = F, y)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>jitter</code></dt><dd><p>Should there be a jitter?</p>
</dd>
<dt><code>y</code></dt><dd><p>Output</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_product-param_optim_lower"></a>



<h4>Method <code>param_optim_lower()</code></h4>

<p>Lower bounds of parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>kernel_product$param_optim_lower()</pre></div>


<hr>
<a id="method-GauPro_kernel_product-param_optim_upper"></a>



<h4>Method <code>param_optim_upper()</code></h4>

<p>Upper bounds of parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>kernel_product$param_optim_upper()</pre></div>


<hr>
<a id="method-GauPro_kernel_product-set_params_from_optim"></a>



<h4>Method <code>set_params_from_optim()</code></h4>

<p>Set parameters from optimization output
</p>


<h5>Usage</h5>

<div class="r"><pre>kernel_product$set_params_from_optim(optim_out)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>optim_out</code></dt><dd><p>Output from optimization</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_product-dC_dparams"></a>



<h4>Method <code>dC_dparams()</code></h4>

<p>Derivative of covariance with respect to parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>kernel_product$dC_dparams(params = NULL, C, X, C_nonug, nug)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Kernel parameters</p>
</dd>
<dt><code>C</code></dt><dd><p>Covariance with nugget</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points in rows</p>
</dd>
<dt><code>C_nonug</code></dt><dd><p>Covariance without nugget added to diagonal</p>
</dd>
<dt><code>nug</code></dt><dd><p>Value of nugget</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_product-C_dC_dparams"></a>



<h4>Method <code>C_dC_dparams()</code></h4>

<p>Calculate covariance matrix and its derivative
with respect to parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>kernel_product$C_dC_dparams(params = NULL, X, nug)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Kernel parameters</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points in rows</p>
</dd>
<dt><code>nug</code></dt><dd><p>Value of nugget</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_product-dC_dx"></a>



<h4>Method <code>dC_dx()</code></h4>

<p>Derivative of covariance with respect to X
</p>


<h5>Usage</h5>

<div class="r"><pre>kernel_product$dC_dx(XX, X)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>matrix of points</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points to take derivative with respect to</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_product-s2_from_params"></a>



<h4>Method <code>s2_from_params()</code></h4>

<p>Get s2 from params vector
</p>


<h5>Usage</h5>

<div class="r"><pre>kernel_product$s2_from_params(params, s2_est = self$s2_est)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>parameter vector</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_product-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print this object
</p>


<h5>Usage</h5>

<div class="r"><pre>kernel_product$print()</pre></div>


<hr>
<a id="method-GauPro_kernel_product-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>kernel_product$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>k1 &lt;- Exponential$new(beta=1)
k2 &lt;- Matern32$new(beta=2)
k &lt;- k1 * k2
k$k(matrix(c(2,1), ncol=1))
</code></pre>

<hr>
<h2 id='kernel_sum'>Gaussian Kernel R6 class</h2><span id='topic+kernel_sum'></span>

<h3>Description</h3>

<p>Gaussian Kernel R6 class
</p>
<p>Gaussian Kernel R6 class
</p>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Value</h3>

<p>Object of <code><a href="R6.html#topic+R6Class">R6Class</a></code> with methods for fitting GP model.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+GauPro_kernel">GauPro::GauPro_kernel</a></code> -&gt; <code>GauPro_kernel_sum</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>k1</code></dt><dd><p>kernel 1</p>
</dd>
<dt><code>k2</code></dt><dd><p>kernel 2</p>
</dd>
<dt><code>k1_param_length</code></dt><dd><p>param length of kernel 1</p>
</dd>
<dt><code>k2_param_length</code></dt><dd><p>param length of kernel 2</p>
</dd>
<dt><code>k1pl</code></dt><dd><p>param length of kernel 1</p>
</dd>
<dt><code>k2pl</code></dt><dd><p>param length of kernel 2</p>
</dd>
<dt><code>s2</code></dt><dd><p>variance</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GauPro_kernel_sum-new"><code>kernel_sum$new()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_sum-k"><code>kernel_sum$k()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_sum-param_optim_start"><code>kernel_sum$param_optim_start()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_sum-param_optim_start0"><code>kernel_sum$param_optim_start0()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_sum-param_optim_lower"><code>kernel_sum$param_optim_lower()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_sum-param_optim_upper"><code>kernel_sum$param_optim_upper()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_sum-set_params_from_optim"><code>kernel_sum$set_params_from_optim()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_sum-dC_dparams"><code>kernel_sum$dC_dparams()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_sum-C_dC_dparams"><code>kernel_sum$C_dC_dparams()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_sum-dC_dx"><code>kernel_sum$dC_dx()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_sum-s2_from_params"><code>kernel_sum$s2_from_params()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_sum-print"><code>kernel_sum$print()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_sum-clone"><code>kernel_sum$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel" data-id="plot"><a href='../../GauPro/html/GauPro_kernel.html#method-GauPro_kernel-plot'><code>GauPro::GauPro_kernel$plot()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-GauPro_kernel_sum-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize kernel
</p>


<h5>Usage</h5>

<div class="r"><pre>kernel_sum$new(k1, k2, useC = TRUE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>k1</code></dt><dd><p>Kernel 1</p>
</dd>
<dt><code>k2</code></dt><dd><p>Kernel 2</p>
</dd>
<dt><code>useC</code></dt><dd><p>Should C code used? Not applicable for kernel sum.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_sum-k"></a>



<h4>Method <code>k()</code></h4>

<p>Calculate covariance between two points
</p>


<h5>Usage</h5>

<div class="r"><pre>kernel_sum$k(x, y = NULL, params, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>vector.</p>
</dd>
<dt><code>y</code></dt><dd><p>vector, optional. If excluded, find correlation
of x with itself.</p>
</dd>
<dt><code>params</code></dt><dd><p>parameters to use instead of beta and s2.</p>
</dd>
<dt><code>...</code></dt><dd><p>Not used</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_sum-param_optim_start"></a>



<h4>Method <code>param_optim_start()</code></h4>

<p>Starting point for parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>kernel_sum$param_optim_start(jitter = F, y)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>jitter</code></dt><dd><p>Should there be a jitter?</p>
</dd>
<dt><code>y</code></dt><dd><p>Output</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_sum-param_optim_start0"></a>



<h4>Method <code>param_optim_start0()</code></h4>

<p>Starting point for parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>kernel_sum$param_optim_start0(jitter = F, y)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>jitter</code></dt><dd><p>Should there be a jitter?</p>
</dd>
<dt><code>y</code></dt><dd><p>Output</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_sum-param_optim_lower"></a>



<h4>Method <code>param_optim_lower()</code></h4>

<p>Lower bounds of parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>kernel_sum$param_optim_lower()</pre></div>


<hr>
<a id="method-GauPro_kernel_sum-param_optim_upper"></a>



<h4>Method <code>param_optim_upper()</code></h4>

<p>Upper bounds of parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>kernel_sum$param_optim_upper()</pre></div>


<hr>
<a id="method-GauPro_kernel_sum-set_params_from_optim"></a>



<h4>Method <code>set_params_from_optim()</code></h4>

<p>Set parameters from optimization output
</p>


<h5>Usage</h5>

<div class="r"><pre>kernel_sum$set_params_from_optim(optim_out)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>optim_out</code></dt><dd><p>Output from optimization</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_sum-dC_dparams"></a>



<h4>Method <code>dC_dparams()</code></h4>

<p>Derivative of covariance with respect to parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>kernel_sum$dC_dparams(params = NULL, C, X, C_nonug, nug)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Kernel parameters</p>
</dd>
<dt><code>C</code></dt><dd><p>Covariance with nugget</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points in rows</p>
</dd>
<dt><code>C_nonug</code></dt><dd><p>Covariance without nugget added to diagonal</p>
</dd>
<dt><code>nug</code></dt><dd><p>Value of nugget</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_sum-C_dC_dparams"></a>



<h4>Method <code>C_dC_dparams()</code></h4>

<p>Calculate covariance matrix and its derivative
with respect to parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>kernel_sum$C_dC_dparams(params = NULL, X, nug)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Kernel parameters</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points in rows</p>
</dd>
<dt><code>nug</code></dt><dd><p>Value of nugget</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_sum-dC_dx"></a>



<h4>Method <code>dC_dx()</code></h4>

<p>Derivative of covariance with respect to X
</p>


<h5>Usage</h5>

<div class="r"><pre>kernel_sum$dC_dx(XX, X)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>matrix of points</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points to take derivative with respect to</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_sum-s2_from_params"></a>



<h4>Method <code>s2_from_params()</code></h4>

<p>Get s2 from params vector
</p>


<h5>Usage</h5>

<div class="r"><pre>kernel_sum$s2_from_params(params)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>parameter vector</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_sum-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print this object
</p>


<h5>Usage</h5>

<div class="r"><pre>kernel_sum$print()</pre></div>


<hr>
<a id="method-GauPro_kernel_sum-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>kernel_sum$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>k1 &lt;- Exponential$new(beta=1)
k2 &lt;- Matern32$new(beta=2)
k &lt;- k1 + k2
k$k(matrix(c(2,1), ncol=1))
</code></pre>

<hr>
<h2 id='LatentFactorKernel'>Latent Factor Kernel R6 class</h2><span id='topic+LatentFactorKernel'></span>

<h3>Description</h3>

<p>Latent Factor Kernel R6 class
</p>
<p>Latent Factor Kernel R6 class
</p>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Details</h3>

<p>Used for factor variables, a single dimension.
Each level of the factor gets mapped into a latent space,
then the distances in that space determine their correlations.
</p>


<h3>Value</h3>

<p>Object of <code><a href="R6.html#topic+R6Class">R6Class</a></code> with methods for fitting GP model.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+GauPro_kernel">GauPro::GauPro_kernel</a></code> -&gt; <code>GauPro_kernel_LatentFactorKernel</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>p</code></dt><dd><p>Parameter for correlation</p>
</dd>
<dt><code>p_est</code></dt><dd><p>Should p be estimated?</p>
</dd>
<dt><code>p_lower</code></dt><dd><p>Lower bound of p</p>
</dd>
<dt><code>p_upper</code></dt><dd><p>Upper bound of p</p>
</dd>
<dt><code>p_length</code></dt><dd><p>length of p</p>
</dd>
<dt><code>s2</code></dt><dd><p>variance</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 estimated?</p>
</dd>
<dt><code>logs2</code></dt><dd><p>Log of s2</p>
</dd>
<dt><code>logs2_lower</code></dt><dd><p>Lower bound of logs2</p>
</dd>
<dt><code>logs2_upper</code></dt><dd><p>Upper bound of logs2</p>
</dd>
<dt><code>xindex</code></dt><dd><p>Index of the factor (which column of X)</p>
</dd>
<dt><code>nlevels</code></dt><dd><p>Number of levels for the factor</p>
</dd>
<dt><code>latentdim</code></dt><dd><p>Dimension of embedding space</p>
</dd>
<dt><code>pf_to_p_log</code></dt><dd><p>Logical vector used to convert pf to p</p>
</dd>
<dt><code>p_to_pf_inds</code></dt><dd><p>Vector of indexes used to convert p to pf</p>
</dd>
<dt><code>offdiagequal</code></dt><dd><p>What should offdiagonal values be set to when the
indices are the same? Use to avoid decomposition errors, similar to
adding a nugget.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GauPro_kernel_LatentFactorKernel-new"><code>LatentFactorKernel$new()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_LatentFactorKernel-k"><code>LatentFactorKernel$k()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_LatentFactorKernel-kone"><code>LatentFactorKernel$kone()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_LatentFactorKernel-dC_dparams"><code>LatentFactorKernel$dC_dparams()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_LatentFactorKernel-C_dC_dparams"><code>LatentFactorKernel$C_dC_dparams()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_LatentFactorKernel-dC_dx"><code>LatentFactorKernel$dC_dx()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_LatentFactorKernel-param_optim_start"><code>LatentFactorKernel$param_optim_start()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_LatentFactorKernel-param_optim_start0"><code>LatentFactorKernel$param_optim_start0()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_LatentFactorKernel-param_optim_lower"><code>LatentFactorKernel$param_optim_lower()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_LatentFactorKernel-param_optim_upper"><code>LatentFactorKernel$param_optim_upper()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_LatentFactorKernel-set_params_from_optim"><code>LatentFactorKernel$set_params_from_optim()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_LatentFactorKernel-p_to_pf"><code>LatentFactorKernel$p_to_pf()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_LatentFactorKernel-s2_from_params"><code>LatentFactorKernel$s2_from_params()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_LatentFactorKernel-plotLatent"><code>LatentFactorKernel$plotLatent()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_LatentFactorKernel-print"><code>LatentFactorKernel$print()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_LatentFactorKernel-clone"><code>LatentFactorKernel$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel" data-id="plot"><a href='../../GauPro/html/GauPro_kernel.html#method-GauPro_kernel-plot'><code>GauPro::GauPro_kernel$plot()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-GauPro_kernel_LatentFactorKernel-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize kernel object
</p>


<h5>Usage</h5>

<div class="r"><pre>LatentFactorKernel$new(
  s2 = 1,
  D,
  nlevels,
  xindex,
  latentdim,
  p_lower = 0,
  p_upper = 1,
  p_est = TRUE,
  s2_lower = 1e-08,
  s2_upper = 1e+08,
  s2_est = TRUE,
  useC = TRUE,
  offdiagequal = 1 - 1e-06
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>s2</code></dt><dd><p>Initial variance</p>
</dd>
<dt><code>D</code></dt><dd><p>Number of input dimensions of data</p>
</dd>
<dt><code>nlevels</code></dt><dd><p>Number of levels for the factor</p>
</dd>
<dt><code>xindex</code></dt><dd><p>Index of X to use the kernel on</p>
</dd>
<dt><code>latentdim</code></dt><dd><p>Dimension of embedding space</p>
</dd>
<dt><code>p_lower</code></dt><dd><p>Lower bound for p</p>
</dd>
<dt><code>p_upper</code></dt><dd><p>Upper bound for p</p>
</dd>
<dt><code>p_est</code></dt><dd><p>Should p be estimated?</p>
</dd>
<dt><code>s2_lower</code></dt><dd><p>Lower bound for s2</p>
</dd>
<dt><code>s2_upper</code></dt><dd><p>Upper bound for s2</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Should s2 be estimated?</p>
</dd>
<dt><code>useC</code></dt><dd><p>Should C code used? Much faster.</p>
</dd>
<dt><code>offdiagequal</code></dt><dd><p>What should offdiagonal values be set to when the
indices are the same? Use to avoid decomposition errors, similar to
adding a nugget.</p>
</dd>
<dt><code>p</code></dt><dd><p>Vector of latent variables</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_LatentFactorKernel-k"></a>



<h4>Method <code>k()</code></h4>

<p>Calculate covariance between two points
</p>


<h5>Usage</h5>

<div class="r"><pre>LatentFactorKernel$k(x, y = NULL, p = self$p, s2 = self$s2, params = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>vector.</p>
</dd>
<dt><code>y</code></dt><dd><p>vector, optional. If excluded, find correlation
of x with itself.</p>
</dd>
<dt><code>p</code></dt><dd><p>Correlation parameters.</p>
</dd>
<dt><code>s2</code></dt><dd><p>Variance parameter.</p>
</dd>
<dt><code>params</code></dt><dd><p>parameters to use instead of beta and s2.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_LatentFactorKernel-kone"></a>



<h4>Method <code>kone()</code></h4>

<p>Find covariance of two points
</p>


<h5>Usage</h5>

<div class="r"><pre>LatentFactorKernel$kone(
  x,
  y,
  pf,
  s2,
  isdiag = TRUE,
  offdiagequal = self$offdiagequal
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>vector</p>
</dd>
<dt><code>y</code></dt><dd><p>vector</p>
</dd>
<dt><code>pf</code></dt><dd><p>correlation parameters on regular scale, includes zeroes
for first level.</p>
</dd>
<dt><code>s2</code></dt><dd><p>Variance parameter</p>
</dd>
<dt><code>isdiag</code></dt><dd><p>Is this on the diagonal of the covariance?</p>
</dd>
<dt><code>offdiagequal</code></dt><dd><p>What should offdiagonal values be set to when the
indices are the same? Use to avoid decomposition errors, similar to
adding a nugget.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_LatentFactorKernel-dC_dparams"></a>



<h4>Method <code>dC_dparams()</code></h4>

<p>Derivative of covariance with respect to parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>LatentFactorKernel$dC_dparams(params = NULL, X, C_nonug, C, nug)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Kernel parameters</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points in rows</p>
</dd>
<dt><code>C_nonug</code></dt><dd><p>Covariance without nugget added to diagonal</p>
</dd>
<dt><code>C</code></dt><dd><p>Covariance with nugget</p>
</dd>
<dt><code>nug</code></dt><dd><p>Value of nugget</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_LatentFactorKernel-C_dC_dparams"></a>



<h4>Method <code>C_dC_dparams()</code></h4>

<p>Calculate covariance matrix and its derivative
with respect to parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>LatentFactorKernel$C_dC_dparams(params = NULL, X, nug)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Kernel parameters</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points in rows</p>
</dd>
<dt><code>nug</code></dt><dd><p>Value of nugget</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_LatentFactorKernel-dC_dx"></a>



<h4>Method <code>dC_dx()</code></h4>

<p>Derivative of covariance with respect to X
</p>


<h5>Usage</h5>

<div class="r"><pre>LatentFactorKernel$dC_dx(XX, X, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>matrix of points</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points to take derivative with respect to</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional args, not used</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_LatentFactorKernel-param_optim_start"></a>



<h4>Method <code>param_optim_start()</code></h4>

<p>Starting point for parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>LatentFactorKernel$param_optim_start(
  jitter = F,
  y,
  p_est = self$p_est,
  s2_est = self$s2_est
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>jitter</code></dt><dd><p>Should there be a jitter?</p>
</dd>
<dt><code>y</code></dt><dd><p>Output</p>
</dd>
<dt><code>p_est</code></dt><dd><p>Is p being estimated?</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_LatentFactorKernel-param_optim_start0"></a>



<h4>Method <code>param_optim_start0()</code></h4>

<p>Starting point for parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>LatentFactorKernel$param_optim_start0(
  jitter = F,
  y,
  p_est = self$p_est,
  s2_est = self$s2_est
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>jitter</code></dt><dd><p>Should there be a jitter?</p>
</dd>
<dt><code>y</code></dt><dd><p>Output</p>
</dd>
<dt><code>p_est</code></dt><dd><p>Is p being estimated?</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_LatentFactorKernel-param_optim_lower"></a>



<h4>Method <code>param_optim_lower()</code></h4>

<p>Lower bounds of parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>LatentFactorKernel$param_optim_lower(p_est = self$p_est, s2_est = self$s2_est)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>p_est</code></dt><dd><p>Is p being estimated?</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_LatentFactorKernel-param_optim_upper"></a>



<h4>Method <code>param_optim_upper()</code></h4>

<p>Upper bounds of parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>LatentFactorKernel$param_optim_upper(p_est = self$p_est, s2_est = self$s2_est)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>p_est</code></dt><dd><p>Is p being estimated?</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_LatentFactorKernel-set_params_from_optim"></a>



<h4>Method <code>set_params_from_optim()</code></h4>

<p>Set parameters from optimization output
</p>


<h5>Usage</h5>

<div class="r"><pre>LatentFactorKernel$set_params_from_optim(
  optim_out,
  p_est = self$p_est,
  s2_est = self$s2_est
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>optim_out</code></dt><dd><p>Output from optimization</p>
</dd>
<dt><code>p_est</code></dt><dd><p>Is p being estimated?</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_LatentFactorKernel-p_to_pf"></a>



<h4>Method <code>p_to_pf()</code></h4>

<p>Convert p (short parameter vector) to pf (long parameter
vector with zeros).
</p>


<h5>Usage</h5>

<div class="r"><pre>LatentFactorKernel$p_to_pf(p)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>p</code></dt><dd><p>Parameter vector</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_LatentFactorKernel-s2_from_params"></a>



<h4>Method <code>s2_from_params()</code></h4>

<p>Get s2 from params vector
</p>


<h5>Usage</h5>

<div class="r"><pre>LatentFactorKernel$s2_from_params(params, s2_est = self$s2_est)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>parameter vector</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_LatentFactorKernel-plotLatent"></a>



<h4>Method <code>plotLatent()</code></h4>

<p>Plot the points in the latent space
</p>


<h5>Usage</h5>

<div class="r"><pre>LatentFactorKernel$plotLatent()</pre></div>


<hr>
<a id="method-GauPro_kernel_LatentFactorKernel-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print this object
</p>


<h5>Usage</h5>

<div class="r"><pre>LatentFactorKernel$print()</pre></div>


<hr>
<a id="method-GauPro_kernel_LatentFactorKernel-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>LatentFactorKernel$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>https://stackoverflow.com/questions/27086195/linear-index-upper-triangular-matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a new kernel for a single factor with 5 levels,
#  mapped into two latent dimensions.
kk &lt;- LatentFactorKernel$new(D=1, nlevels=5, xindex=1, latentdim=2)
# Random initial parameter values
kk$p
# Plots to understand
kk$plotLatent()
kk$plot()


# 5 levels, 1/4 are similar and 2/3/5 are similar
n &lt;- 30
x &lt;- matrix(sample(1:5, n, TRUE))
y &lt;- c(ifelse(x == 1 | x == 4, 4, -3) + rnorm(n,0,.1))
plot(c(x), y)
m5 &lt;- GauPro_kernel_model$new(
  X=x, Z=y,
  kernel=LatentFactorKernel$new(D=1, nlevels = 5, xindex = 1, latentdim = 2))
m5$kernel$p
# We should see 1/4 and 2/3/4 in separate clusters
m5$kernel$plotLatent()

library(dplyr)
n &lt;- 20
X &lt;- cbind(matrix(runif(n,2,6), ncol=1),
           matrix(sample(1:2, size=n, replace=TRUE), ncol=1))
X &lt;- rbind(X, c(3.3,3), c(3.7,3))
n &lt;- nrow(X)
Z &lt;- X[,1] - (4-X[,2])^2 + rnorm(n,0,.1)
plot(X[,1], Z, col=X[,2])
tibble(X=X, Z) %&gt;% arrange(X,Z)
k2a &lt;- IgnoreIndsKernel$new(k=Gaussian$new(D=1), ignoreinds = 2)
k2b &lt;- LatentFactorKernel$new(D=2, nlevels=3, xind=2, latentdim=2)
k2 &lt;- k2a * k2b
k2b$p_upper &lt;- .65*k2b$p_upper
gp &lt;- GauPro_kernel_model$new(X=X, Z=Z, kernel = k2, verbose = 5,
  nug.min=1e-2, restarts=1)
gp$kernel$k1$kernel$beta
gp$kernel$k2$p
gp$kernel$k(x = gp$X)
tibble(X=X, Z=Z, pred=gp$predict(X)) %&gt;% arrange(X, Z)
tibble(X=X[,2], Z) %&gt;% group_by(X) %&gt;% summarize(n=n(), mean(Z))
curve(gp$pred(cbind(matrix(x,ncol=1),1)),2,6, ylim=c(min(Z), max(Z)))
points(X[X[,2]==1,1], Z[X[,2]==1])
curve(gp$pred(cbind(matrix(x,ncol=1),2)), add=TRUE, col=2)
points(X[X[,2]==2,1], Z[X[,2]==2], col=2)
curve(gp$pred(cbind(matrix(x,ncol=1),3)), add=TRUE, col=3)
points(X[X[,2]==3,1], Z[X[,2]==3], col=3)
legend(legend=1:3, fill=1:3, x="topleft")
# See which points affect (5.5, 3 themost)
data.frame(X, cov=gp$kernel$k(X, c(5.5,3))) %&gt;% arrange(-cov)
plot(k2b)
</code></pre>

<hr>
<h2 id='Matern32'>Matern 3/2 Kernel R6 class</h2><span id='topic+Matern32'></span>

<h3>Description</h3>

<p>Matern 3/2 Kernel R6 class
</p>
<p>Matern 3/2 Kernel R6 class
</p>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Value</h3>

<p>Object of <code><a href="R6.html#topic+R6Class">R6Class</a></code> with methods for fitting GP model.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+GauPro_kernel">GauPro::GauPro_kernel</a></code> -&gt; <code><a href="#topic+GauPro_kernel_beta">GauPro::GauPro_kernel_beta</a></code> -&gt; <code>GauPro_kernel_Matern32</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>sqrt3</code></dt><dd><p>Saved value of square root of 3</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GauPro_kernel_Matern32-k"><code>Matern32$k()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Matern32-kone"><code>Matern32$kone()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Matern32-dC_dparams"><code>Matern32$dC_dparams()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Matern32-dC_dx"><code>Matern32$dC_dx()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Matern32-print"><code>Matern32$print()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Matern32-clone"><code>Matern32$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel" data-id="plot"><a href='../../GauPro/html/GauPro_kernel.html#method-GauPro_kernel-plot'><code>GauPro::GauPro_kernel$plot()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="C_dC_dparams"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-C_dC_dparams'><code>GauPro::GauPro_kernel_beta$C_dC_dparams()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="initialize"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-initialize'><code>GauPro::GauPro_kernel_beta$initialize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="param_optim_lower"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-param_optim_lower'><code>GauPro::GauPro_kernel_beta$param_optim_lower()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="param_optim_start"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-param_optim_start'><code>GauPro::GauPro_kernel_beta$param_optim_start()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="param_optim_start0"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-param_optim_start0'><code>GauPro::GauPro_kernel_beta$param_optim_start0()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="param_optim_upper"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-param_optim_upper'><code>GauPro::GauPro_kernel_beta$param_optim_upper()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="s2_from_params"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-s2_from_params'><code>GauPro::GauPro_kernel_beta$s2_from_params()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="set_params_from_optim"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-set_params_from_optim'><code>GauPro::GauPro_kernel_beta$set_params_from_optim()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-GauPro_kernel_Matern32-k"></a>



<h4>Method <code>k()</code></h4>

<p>Calculate covariance between two points
</p>


<h5>Usage</h5>

<div class="r"><pre>Matern32$k(x, y = NULL, beta = self$beta, s2 = self$s2, params = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>vector.</p>
</dd>
<dt><code>y</code></dt><dd><p>vector, optional. If excluded, find correlation
of x with itself.</p>
</dd>
<dt><code>beta</code></dt><dd><p>Correlation parameters.</p>
</dd>
<dt><code>s2</code></dt><dd><p>Variance parameter.</p>
</dd>
<dt><code>params</code></dt><dd><p>parameters to use instead of beta and s2.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_Matern32-kone"></a>



<h4>Method <code>kone()</code></h4>

<p>Find covariance of two points
</p>


<h5>Usage</h5>

<div class="r"><pre>Matern32$kone(x, y, beta, theta, s2)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>vector</p>
</dd>
<dt><code>y</code></dt><dd><p>vector</p>
</dd>
<dt><code>beta</code></dt><dd><p>correlation parameters on log scale</p>
</dd>
<dt><code>theta</code></dt><dd><p>correlation parameters on regular scale</p>
</dd>
<dt><code>s2</code></dt><dd><p>Variance parameter</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_Matern32-dC_dparams"></a>



<h4>Method <code>dC_dparams()</code></h4>

<p>Derivative of covariance with respect to parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>Matern32$dC_dparams(params = NULL, X, C_nonug, C, nug)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Kernel parameters</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points in rows</p>
</dd>
<dt><code>C_nonug</code></dt><dd><p>Covariance without nugget added to diagonal</p>
</dd>
<dt><code>C</code></dt><dd><p>Covariance with nugget</p>
</dd>
<dt><code>nug</code></dt><dd><p>Value of nugget</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_Matern32-dC_dx"></a>



<h4>Method <code>dC_dx()</code></h4>

<p>Derivative of covariance with respect to X
</p>


<h5>Usage</h5>

<div class="r"><pre>Matern32$dC_dx(XX, X, theta, beta = self$beta, s2 = self$s2)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>matrix of points</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points to take derivative with respect to</p>
</dd>
<dt><code>theta</code></dt><dd><p>Correlation parameters</p>
</dd>
<dt><code>beta</code></dt><dd><p>log of theta</p>
</dd>
<dt><code>s2</code></dt><dd><p>Variance parameter</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_Matern32-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print this object
</p>


<h5>Usage</h5>

<div class="r"><pre>Matern32$print()</pre></div>


<hr>
<a id="method-GauPro_kernel_Matern32-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Matern32$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>k1 &lt;- Matern32$new(beta=0)
plot(k1)

n &lt;- 12
x &lt;- matrix(seq(0,1,length.out = n), ncol=1)
y &lt;- sin(2*pi*x) + rnorm(n,0,1e-1)
gp &lt;- GauPro_kernel_model$new(X=x, Z=y, kernel=Matern32$new(1),
                              parallel=FALSE)
gp$predict(.454)
gp$plot1D()
gp$cool1Dplot()
</code></pre>

<hr>
<h2 id='Matern52'>Matern 5/2 Kernel R6 class</h2><span id='topic+Matern52'></span>

<h3>Description</h3>

<p>Matern 5/2 Kernel R6 class
</p>
<p>Matern 5/2 Kernel R6 class
</p>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Value</h3>

<p>Object of <code><a href="R6.html#topic+R6Class">R6Class</a></code> with methods for fitting GP model.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+GauPro_kernel">GauPro::GauPro_kernel</a></code> -&gt; <code><a href="#topic+GauPro_kernel_beta">GauPro::GauPro_kernel_beta</a></code> -&gt; <code>GauPro_kernel_Matern52</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>sqrt5</code></dt><dd><p>Saved value of square root of 5</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GauPro_kernel_Matern52-k"><code>Matern52$k()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Matern52-kone"><code>Matern52$kone()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Matern52-dC_dparams"><code>Matern52$dC_dparams()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Matern52-dC_dx"><code>Matern52$dC_dx()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Matern52-print"><code>Matern52$print()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Matern52-clone"><code>Matern52$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel" data-id="plot"><a href='../../GauPro/html/GauPro_kernel.html#method-GauPro_kernel-plot'><code>GauPro::GauPro_kernel$plot()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="C_dC_dparams"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-C_dC_dparams'><code>GauPro::GauPro_kernel_beta$C_dC_dparams()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="initialize"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-initialize'><code>GauPro::GauPro_kernel_beta$initialize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="param_optim_lower"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-param_optim_lower'><code>GauPro::GauPro_kernel_beta$param_optim_lower()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="param_optim_start"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-param_optim_start'><code>GauPro::GauPro_kernel_beta$param_optim_start()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="param_optim_start0"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-param_optim_start0'><code>GauPro::GauPro_kernel_beta$param_optim_start0()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="param_optim_upper"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-param_optim_upper'><code>GauPro::GauPro_kernel_beta$param_optim_upper()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="s2_from_params"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-s2_from_params'><code>GauPro::GauPro_kernel_beta$s2_from_params()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="set_params_from_optim"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-set_params_from_optim'><code>GauPro::GauPro_kernel_beta$set_params_from_optim()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-GauPro_kernel_Matern52-k"></a>



<h4>Method <code>k()</code></h4>

<p>Calculate covariance between two points
</p>


<h5>Usage</h5>

<div class="r"><pre>Matern52$k(x, y = NULL, beta = self$beta, s2 = self$s2, params = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>vector.</p>
</dd>
<dt><code>y</code></dt><dd><p>vector, optional. If excluded, find correlation
of x with itself.</p>
</dd>
<dt><code>beta</code></dt><dd><p>Correlation parameters.</p>
</dd>
<dt><code>s2</code></dt><dd><p>Variance parameter.</p>
</dd>
<dt><code>params</code></dt><dd><p>parameters to use instead of beta and s2.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_Matern52-kone"></a>



<h4>Method <code>kone()</code></h4>

<p>Find covariance of two points
</p>


<h5>Usage</h5>

<div class="r"><pre>Matern52$kone(x, y, beta, theta, s2)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>vector</p>
</dd>
<dt><code>y</code></dt><dd><p>vector</p>
</dd>
<dt><code>beta</code></dt><dd><p>correlation parameters on log scale</p>
</dd>
<dt><code>theta</code></dt><dd><p>correlation parameters on regular scale</p>
</dd>
<dt><code>s2</code></dt><dd><p>Variance parameter</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_Matern52-dC_dparams"></a>



<h4>Method <code>dC_dparams()</code></h4>

<p>Derivative of covariance with respect to parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>Matern52$dC_dparams(params = NULL, X, C_nonug, C, nug)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Kernel parameters</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points in rows</p>
</dd>
<dt><code>C_nonug</code></dt><dd><p>Covariance without nugget added to diagonal</p>
</dd>
<dt><code>C</code></dt><dd><p>Covariance with nugget</p>
</dd>
<dt><code>nug</code></dt><dd><p>Value of nugget</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_Matern52-dC_dx"></a>



<h4>Method <code>dC_dx()</code></h4>

<p>Derivative of covariance with respect to X
</p>


<h5>Usage</h5>

<div class="r"><pre>Matern52$dC_dx(XX, X, theta, beta = self$beta, s2 = self$s2)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>matrix of points</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points to take derivative with respect to</p>
</dd>
<dt><code>theta</code></dt><dd><p>Correlation parameters</p>
</dd>
<dt><code>beta</code></dt><dd><p>log of theta</p>
</dd>
<dt><code>s2</code></dt><dd><p>Variance parameter</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_Matern52-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print this object
</p>


<h5>Usage</h5>

<div class="r"><pre>Matern52$print()</pre></div>


<hr>
<a id="method-GauPro_kernel_Matern52-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Matern52$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>k1 &lt;- Matern52$new(beta=0)
plot(k1)

n &lt;- 12
x &lt;- matrix(seq(0,1,length.out = n), ncol=1)
y &lt;- sin(2*pi*x) + rnorm(n,0,1e-1)
gp &lt;- GauPro_kernel_model$new(X=x, Z=y, kernel=Matern52$new(1),
                              parallel=FALSE)
gp$predict(.454)
gp$plot1D()
gp$cool1Dplot()
</code></pre>

<hr>
<h2 id='OrderedFactorKernel'>Ordered Factor Kernel R6 class</h2><span id='topic+OrderedFactorKernel'></span>

<h3>Description</h3>

<p>Ordered Factor Kernel R6 class
</p>
<p>Ordered Factor Kernel R6 class
</p>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Details</h3>

<p>Use for factor inputs that are considered to have an ordering
</p>


<h3>Value</h3>

<p>Object of <code><a href="R6.html#topic+R6Class">R6Class</a></code> with methods for fitting GP model.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+GauPro_kernel">GauPro::GauPro_kernel</a></code> -&gt; <code>GauPro_kernel_OrderedFactorKernel</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>p</code></dt><dd><p>Parameter for correlation</p>
</dd>
<dt><code>p_est</code></dt><dd><p>Should p be estimated?</p>
</dd>
<dt><code>p_lower</code></dt><dd><p>Lower bound of p</p>
</dd>
<dt><code>p_upper</code></dt><dd><p>Upper bound of p</p>
</dd>
<dt><code>p_length</code></dt><dd><p>length of p</p>
</dd>
<dt><code>s2</code></dt><dd><p>variance</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 estimated?</p>
</dd>
<dt><code>logs2</code></dt><dd><p>Log of s2</p>
</dd>
<dt><code>logs2_lower</code></dt><dd><p>Lower bound of logs2</p>
</dd>
<dt><code>logs2_upper</code></dt><dd><p>Upper bound of logs2</p>
</dd>
<dt><code>xindex</code></dt><dd><p>Index of the factor (which column of X)</p>
</dd>
<dt><code>nlevels</code></dt><dd><p>Number of levels for the factor</p>
</dd>
<dt><code>offdiagequal</code></dt><dd><p>What should offdiagonal values be set to when the
indices are the same? Use to avoid decomposition errors, similar to
adding a nugget.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GauPro_kernel_OrderedFactorKernel-new"><code>OrderedFactorKernel$new()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_OrderedFactorKernel-k"><code>OrderedFactorKernel$k()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_OrderedFactorKernel-kone"><code>OrderedFactorKernel$kone()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_OrderedFactorKernel-dC_dparams"><code>OrderedFactorKernel$dC_dparams()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_OrderedFactorKernel-C_dC_dparams"><code>OrderedFactorKernel$C_dC_dparams()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_OrderedFactorKernel-dC_dx"><code>OrderedFactorKernel$dC_dx()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_OrderedFactorKernel-param_optim_start"><code>OrderedFactorKernel$param_optim_start()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_OrderedFactorKernel-param_optim_start0"><code>OrderedFactorKernel$param_optim_start0()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_OrderedFactorKernel-param_optim_lower"><code>OrderedFactorKernel$param_optim_lower()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_OrderedFactorKernel-param_optim_upper"><code>OrderedFactorKernel$param_optim_upper()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_OrderedFactorKernel-set_params_from_optim"><code>OrderedFactorKernel$set_params_from_optim()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_OrderedFactorKernel-s2_from_params"><code>OrderedFactorKernel$s2_from_params()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_OrderedFactorKernel-plotLatent"><code>OrderedFactorKernel$plotLatent()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_OrderedFactorKernel-print"><code>OrderedFactorKernel$print()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_OrderedFactorKernel-clone"><code>OrderedFactorKernel$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel" data-id="plot"><a href='../../GauPro/html/GauPro_kernel.html#method-GauPro_kernel-plot'><code>GauPro::GauPro_kernel$plot()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-GauPro_kernel_OrderedFactorKernel-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize kernel object
</p>


<h5>Usage</h5>

<div class="r"><pre>OrderedFactorKernel$new(
  s2 = 1,
  D = NULL,
  nlevels,
  xindex,
  p_lower = 1e-08,
  p_upper = 5,
  p_est = TRUE,
  s2_lower = 1e-08,
  s2_upper = 1e+08,
  s2_est = TRUE,
  useC = TRUE,
  offdiagequal = 1 - 1e-06
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>s2</code></dt><dd><p>Initial variance</p>
</dd>
<dt><code>D</code></dt><dd><p>Number of input dimensions of data</p>
</dd>
<dt><code>nlevels</code></dt><dd><p>Number of levels for the factor</p>
</dd>
<dt><code>xindex</code></dt><dd><p>Index of X to use the kernel on</p>
</dd>
<dt><code>p_lower</code></dt><dd><p>Lower bound for p</p>
</dd>
<dt><code>p_upper</code></dt><dd><p>Upper bound for p</p>
</dd>
<dt><code>p_est</code></dt><dd><p>Should p be estimated?</p>
</dd>
<dt><code>s2_lower</code></dt><dd><p>Lower bound for s2</p>
</dd>
<dt><code>s2_upper</code></dt><dd><p>Upper bound for s2</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Should s2 be estimated?</p>
</dd>
<dt><code>useC</code></dt><dd><p>Should C code used? Much faster.</p>
</dd>
<dt><code>offdiagequal</code></dt><dd><p>What should offdiagonal values be set to when the
indices are the same? Use to avoid decomposition errors, similar to
adding a nugget.</p>
</dd>
<dt><code>p</code></dt><dd><p>Vector of distances in latent space</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_OrderedFactorKernel-k"></a>



<h4>Method <code>k()</code></h4>

<p>Calculate covariance between two points
</p>


<h5>Usage</h5>

<div class="r"><pre>OrderedFactorKernel$k(x, y = NULL, p = self$p, s2 = self$s2, params = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>vector.</p>
</dd>
<dt><code>y</code></dt><dd><p>vector, optional. If excluded, find correlation
of x with itself.</p>
</dd>
<dt><code>p</code></dt><dd><p>Correlation parameters.</p>
</dd>
<dt><code>s2</code></dt><dd><p>Variance parameter.</p>
</dd>
<dt><code>params</code></dt><dd><p>parameters to use instead of beta and s2.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_OrderedFactorKernel-kone"></a>



<h4>Method <code>kone()</code></h4>

<p>Find covariance of two points
</p>


<h5>Usage</h5>

<div class="r"><pre>OrderedFactorKernel$kone(
  x,
  y,
  p,
  s2,
  isdiag = TRUE,
  offdiagequal = self$offdiagequal
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>vector</p>
</dd>
<dt><code>y</code></dt><dd><p>vector</p>
</dd>
<dt><code>p</code></dt><dd><p>correlation parameters on regular scale</p>
</dd>
<dt><code>s2</code></dt><dd><p>Variance parameter</p>
</dd>
<dt><code>isdiag</code></dt><dd><p>Is this on the diagonal of the covariance?</p>
</dd>
<dt><code>offdiagequal</code></dt><dd><p>What should offdiagonal values be set to when the
indices are the same? Use to avoid decomposition errors, similar to
adding a nugget.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_OrderedFactorKernel-dC_dparams"></a>



<h4>Method <code>dC_dparams()</code></h4>

<p>Derivative of covariance with respect to parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>OrderedFactorKernel$dC_dparams(params = NULL, X, C_nonug, C, nug)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Kernel parameters</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points in rows</p>
</dd>
<dt><code>C_nonug</code></dt><dd><p>Covariance without nugget added to diagonal</p>
</dd>
<dt><code>C</code></dt><dd><p>Covariance with nugget</p>
</dd>
<dt><code>nug</code></dt><dd><p>Value of nugget</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_OrderedFactorKernel-C_dC_dparams"></a>



<h4>Method <code>C_dC_dparams()</code></h4>

<p>Calculate covariance matrix and its derivative
with respect to parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>OrderedFactorKernel$C_dC_dparams(params = NULL, X, nug)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Kernel parameters</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points in rows</p>
</dd>
<dt><code>nug</code></dt><dd><p>Value of nugget</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_OrderedFactorKernel-dC_dx"></a>



<h4>Method <code>dC_dx()</code></h4>

<p>Derivative of covariance with respect to X
</p>


<h5>Usage</h5>

<div class="r"><pre>OrderedFactorKernel$dC_dx(XX, X, ...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>matrix of points</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points to take derivative with respect to</p>
</dd>
<dt><code>...</code></dt><dd><p>Additional args, not used</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_OrderedFactorKernel-param_optim_start"></a>



<h4>Method <code>param_optim_start()</code></h4>

<p>Starting point for parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>OrderedFactorKernel$param_optim_start(
  jitter = F,
  y,
  p_est = self$p_est,
  s2_est = self$s2_est
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>jitter</code></dt><dd><p>Should there be a jitter?</p>
</dd>
<dt><code>y</code></dt><dd><p>Output</p>
</dd>
<dt><code>p_est</code></dt><dd><p>Is p being estimated?</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_OrderedFactorKernel-param_optim_start0"></a>



<h4>Method <code>param_optim_start0()</code></h4>

<p>Starting point for parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>OrderedFactorKernel$param_optim_start0(
  jitter = F,
  y,
  p_est = self$p_est,
  s2_est = self$s2_est
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>jitter</code></dt><dd><p>Should there be a jitter?</p>
</dd>
<dt><code>y</code></dt><dd><p>Output</p>
</dd>
<dt><code>p_est</code></dt><dd><p>Is p being estimated?</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_OrderedFactorKernel-param_optim_lower"></a>



<h4>Method <code>param_optim_lower()</code></h4>

<p>Lower bounds of parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>OrderedFactorKernel$param_optim_lower(p_est = self$p_est, s2_est = self$s2_est)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>p_est</code></dt><dd><p>Is p being estimated?</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_OrderedFactorKernel-param_optim_upper"></a>



<h4>Method <code>param_optim_upper()</code></h4>

<p>Upper bounds of parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>OrderedFactorKernel$param_optim_upper(p_est = self$p_est, s2_est = self$s2_est)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>p_est</code></dt><dd><p>Is p being estimated?</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_OrderedFactorKernel-set_params_from_optim"></a>



<h4>Method <code>set_params_from_optim()</code></h4>

<p>Set parameters from optimization output
</p>


<h5>Usage</h5>

<div class="r"><pre>OrderedFactorKernel$set_params_from_optim(
  optim_out,
  p_est = self$p_est,
  s2_est = self$s2_est
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>optim_out</code></dt><dd><p>Output from optimization</p>
</dd>
<dt><code>p_est</code></dt><dd><p>Is p being estimated?</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_OrderedFactorKernel-s2_from_params"></a>



<h4>Method <code>s2_from_params()</code></h4>

<p>Get s2 from params vector
</p>


<h5>Usage</h5>

<div class="r"><pre>OrderedFactorKernel$s2_from_params(params, s2_est = self$s2_est)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>parameter vector</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_OrderedFactorKernel-plotLatent"></a>



<h4>Method <code>plotLatent()</code></h4>

<p>Plot the points in the latent space
</p>


<h5>Usage</h5>

<div class="r"><pre>OrderedFactorKernel$plotLatent()</pre></div>


<hr>
<a id="method-GauPro_kernel_OrderedFactorKernel-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print this object
</p>


<h5>Usage</h5>

<div class="r"><pre>OrderedFactorKernel$print()</pre></div>


<hr>
<a id="method-GauPro_kernel_OrderedFactorKernel-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>OrderedFactorKernel$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>https://stackoverflow.com/questions/27086195/linear-index-upper-triangular-matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kk &lt;- OrderedFactorKernel$new(D=1, nlevels=5, xindex=1)
kk$p &lt;- (1:10)/100
kmat &lt;- outer(1:5, 1:5, Vectorize(kk$k))
kmat


library(dplyr)
n &lt;- 20
X &lt;- cbind(matrix(runif(n,2,6), ncol=1),
           matrix(sample(1:2, size=n, replace=TRUE), ncol=1))
X &lt;- rbind(X, c(3.3,3), c(3.7,3))
n &lt;- nrow(X)
Z &lt;- X[,1] - (4-X[,2])^2 + rnorm(n,0,.1)
plot(X[,1], Z, col=X[,2])
tibble(X=X, Z) %&gt;% arrange(X,Z)
k2a &lt;- IgnoreIndsKernel$new(k=Gaussian$new(D=1), ignoreinds = 2)
k2b &lt;- OrderedFactorKernel$new(D=2, nlevels=3, xind=2)
k2 &lt;- k2a * k2b
k2b$p_upper &lt;- .65*k2b$p_upper
gp &lt;- GauPro_kernel_model$new(X=X, Z=Z, kernel = k2, verbose = 5,
  nug.min=1e-2, restarts=0)
gp$kernel$k1$kernel$beta
gp$kernel$k2$p
gp$kernel$k(x = gp$X)
tibble(X=X, Z=Z, pred=gp$predict(X)) %&gt;% arrange(X, Z)
tibble(X=X[,2], Z) %&gt;% group_by(X) %&gt;% summarize(n=n(), mean(Z))
curve(gp$pred(cbind(matrix(x,ncol=1),1)),2,6, ylim=c(min(Z), max(Z)))
points(X[X[,2]==1,1], Z[X[,2]==1])
curve(gp$pred(cbind(matrix(x,ncol=1),2)), add=TRUE, col=2)
points(X[X[,2]==2,1], Z[X[,2]==2], col=2)
curve(gp$pred(cbind(matrix(x,ncol=1),3)), add=TRUE, col=3)
points(X[X[,2]==3,1], Z[X[,2]==3], col=3)
legend(legend=1:3, fill=1:3, x="topleft")
# See which points affect (5.5, 3 themost)
data.frame(X, cov=gp$kernel$k(X, c(5.5,3))) %&gt;% arrange(-cov)
plot(k2b)
</code></pre>

<hr>
<h2 id='Periodic'>Periodic Kernel R6 class</h2><span id='topic+Periodic'></span>

<h3>Description</h3>

<p>Periodic Kernel R6 class
</p>
<p>Periodic Kernel R6 class
</p>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Details</h3>

<p>p is the period for each dimension, a is a single number for scaling
</p>


<h3>Value</h3>

<p>Object of <code><a href="R6.html#topic+R6Class">R6Class</a></code> with methods for fitting GP model.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+GauPro_kernel">GauPro::GauPro_kernel</a></code> -&gt; <code>GauPro_kernel_Periodic</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>p</code></dt><dd><p>Parameter for correlation</p>
</dd>
<dt><code>p_est</code></dt><dd><p>Should p be estimated?</p>
</dd>
<dt><code>logp</code></dt><dd><p>Log of p</p>
</dd>
<dt><code>logp_lower</code></dt><dd><p>Lower bound of logp</p>
</dd>
<dt><code>logp_upper</code></dt><dd><p>Upper bound of logp</p>
</dd>
<dt><code>p_length</code></dt><dd><p>length of p</p>
</dd>
<dt><code>alpha</code></dt><dd><p>Parameter for correlation</p>
</dd>
<dt><code>alpha_est</code></dt><dd><p>Should alpha be estimated?</p>
</dd>
<dt><code>logalpha</code></dt><dd><p>Log of alpha</p>
</dd>
<dt><code>logalpha_lower</code></dt><dd><p>Lower bound of logalpha</p>
</dd>
<dt><code>logalpha_upper</code></dt><dd><p>Upper bound of logalpha</p>
</dd>
<dt><code>s2</code></dt><dd><p>variance</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 estimated?</p>
</dd>
<dt><code>logs2</code></dt><dd><p>Log of s2</p>
</dd>
<dt><code>logs2_lower</code></dt><dd><p>Lower bound of logs2</p>
</dd>
<dt><code>logs2_upper</code></dt><dd><p>Upper bound of logs2</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GauPro_kernel_Periodic-new"><code>Periodic$new()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Periodic-k"><code>Periodic$k()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Periodic-kone"><code>Periodic$kone()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Periodic-dC_dparams"><code>Periodic$dC_dparams()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Periodic-C_dC_dparams"><code>Periodic$C_dC_dparams()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Periodic-dC_dx"><code>Periodic$dC_dx()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Periodic-param_optim_start"><code>Periodic$param_optim_start()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Periodic-param_optim_start0"><code>Periodic$param_optim_start0()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Periodic-param_optim_lower"><code>Periodic$param_optim_lower()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Periodic-param_optim_upper"><code>Periodic$param_optim_upper()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Periodic-set_params_from_optim"><code>Periodic$set_params_from_optim()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Periodic-s2_from_params"><code>Periodic$s2_from_params()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Periodic-print"><code>Periodic$print()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Periodic-clone"><code>Periodic$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel" data-id="plot"><a href='../../GauPro/html/GauPro_kernel.html#method-GauPro_kernel-plot'><code>GauPro::GauPro_kernel$plot()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-GauPro_kernel_Periodic-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize kernel object
</p>


<h5>Usage</h5>

<div class="r"><pre>Periodic$new(
  p,
  alpha = 1,
  s2 = 1,
  D,
  p_lower = 0,
  p_upper = 100,
  p_est = TRUE,
  alpha_lower = 0,
  alpha_upper = 100,
  alpha_est = TRUE,
  s2_lower = 1e-08,
  s2_upper = 1e+08,
  s2_est = TRUE,
  useC = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>p</code></dt><dd><p>Periodic parameter</p>
</dd>
<dt><code>alpha</code></dt><dd><p>Periodic parameter</p>
</dd>
<dt><code>s2</code></dt><dd><p>Initial variance</p>
</dd>
<dt><code>D</code></dt><dd><p>Number of input dimensions of data</p>
</dd>
<dt><code>p_lower</code></dt><dd><p>Lower bound for p</p>
</dd>
<dt><code>p_upper</code></dt><dd><p>Upper bound for p</p>
</dd>
<dt><code>p_est</code></dt><dd><p>Should p be estimated?</p>
</dd>
<dt><code>alpha_lower</code></dt><dd><p>Lower bound for alpha</p>
</dd>
<dt><code>alpha_upper</code></dt><dd><p>Upper bound for alpha</p>
</dd>
<dt><code>alpha_est</code></dt><dd><p>Should alpha be estimated?</p>
</dd>
<dt><code>s2_lower</code></dt><dd><p>Lower bound for s2</p>
</dd>
<dt><code>s2_upper</code></dt><dd><p>Upper bound for s2</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Should s2 be estimated?</p>
</dd>
<dt><code>useC</code></dt><dd><p>Should C code used? Much faster if implemented.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_Periodic-k"></a>



<h4>Method <code>k()</code></h4>

<p>Calculate covariance between two points
</p>


<h5>Usage</h5>

<div class="r"><pre>Periodic$k(
  x,
  y = NULL,
  logp = self$logp,
  logalpha = self$logalpha,
  s2 = self$s2,
  params = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>vector.</p>
</dd>
<dt><code>y</code></dt><dd><p>vector, optional. If excluded, find correlation
of x with itself.</p>
</dd>
<dt><code>logp</code></dt><dd><p>Correlation parameters.</p>
</dd>
<dt><code>logalpha</code></dt><dd><p>Correlation parameters.</p>
</dd>
<dt><code>s2</code></dt><dd><p>Variance parameter.</p>
</dd>
<dt><code>params</code></dt><dd><p>parameters to use instead of beta and s2.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_Periodic-kone"></a>



<h4>Method <code>kone()</code></h4>

<p>Find covariance of two points
</p>


<h5>Usage</h5>

<div class="r"><pre>Periodic$kone(x, y, logp, p, alpha, s2)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>vector</p>
</dd>
<dt><code>y</code></dt><dd><p>vector</p>
</dd>
<dt><code>logp</code></dt><dd><p>correlation parameters on log scale</p>
</dd>
<dt><code>p</code></dt><dd><p>correlation parameters on regular scale</p>
</dd>
<dt><code>alpha</code></dt><dd><p>correlation parameter</p>
</dd>
<dt><code>s2</code></dt><dd><p>Variance parameter</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_Periodic-dC_dparams"></a>



<h4>Method <code>dC_dparams()</code></h4>

<p>Derivative of covariance with respect to parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>Periodic$dC_dparams(params = NULL, X, C_nonug, C, nug)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Kernel parameters</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points in rows</p>
</dd>
<dt><code>C_nonug</code></dt><dd><p>Covariance without nugget added to diagonal</p>
</dd>
<dt><code>C</code></dt><dd><p>Covariance with nugget</p>
</dd>
<dt><code>nug</code></dt><dd><p>Value of nugget</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_Periodic-C_dC_dparams"></a>



<h4>Method <code>C_dC_dparams()</code></h4>

<p>Calculate covariance matrix and its derivative
with respect to parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>Periodic$C_dC_dparams(params = NULL, X, nug)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Kernel parameters</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points in rows</p>
</dd>
<dt><code>nug</code></dt><dd><p>Value of nugget</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_Periodic-dC_dx"></a>



<h4>Method <code>dC_dx()</code></h4>

<p>Derivative of covariance with respect to X
</p>


<h5>Usage</h5>

<div class="r"><pre>Periodic$dC_dx(XX, X, logp = self$logp, logalpha = self$logalpha, s2 = self$s2)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>matrix of points</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points to take derivative with respect to</p>
</dd>
<dt><code>logp</code></dt><dd><p>log of p</p>
</dd>
<dt><code>logalpha</code></dt><dd><p>log of alpha</p>
</dd>
<dt><code>s2</code></dt><dd><p>Variance parameter</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_Periodic-param_optim_start"></a>



<h4>Method <code>param_optim_start()</code></h4>

<p>Starting point for parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>Periodic$param_optim_start(
  jitter = F,
  y,
  p_est = self$p_est,
  alpha_est = self$alpha_est,
  s2_est = self$s2_est
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>jitter</code></dt><dd><p>Should there be a jitter?</p>
</dd>
<dt><code>y</code></dt><dd><p>Output</p>
</dd>
<dt><code>p_est</code></dt><dd><p>Is p being estimated?</p>
</dd>
<dt><code>alpha_est</code></dt><dd><p>Is alpha being estimated?</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_Periodic-param_optim_start0"></a>



<h4>Method <code>param_optim_start0()</code></h4>

<p>Starting point for parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>Periodic$param_optim_start0(
  jitter = F,
  y,
  p_est = self$p_est,
  alpha_est = self$alpha_est,
  s2_est = self$s2_est
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>jitter</code></dt><dd><p>Should there be a jitter?</p>
</dd>
<dt><code>y</code></dt><dd><p>Output</p>
</dd>
<dt><code>p_est</code></dt><dd><p>Is p being estimated?</p>
</dd>
<dt><code>alpha_est</code></dt><dd><p>Is alpha being estimated?</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_Periodic-param_optim_lower"></a>



<h4>Method <code>param_optim_lower()</code></h4>

<p>Lower bounds of parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>Periodic$param_optim_lower(
  p_est = self$p_est,
  alpha_est = self$alpha_est,
  s2_est = self$s2_est
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>p_est</code></dt><dd><p>Is p being estimated?</p>
</dd>
<dt><code>alpha_est</code></dt><dd><p>Is alpha being estimated?</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_Periodic-param_optim_upper"></a>



<h4>Method <code>param_optim_upper()</code></h4>

<p>Upper bounds of parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>Periodic$param_optim_upper(
  p_est = self$p_est,
  alpha_est = self$alpha_est,
  s2_est = self$s2_est
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>p_est</code></dt><dd><p>Is p being estimated?</p>
</dd>
<dt><code>alpha_est</code></dt><dd><p>Is alpha being estimated?</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_Periodic-set_params_from_optim"></a>



<h4>Method <code>set_params_from_optim()</code></h4>

<p>Set parameters from optimization output
</p>


<h5>Usage</h5>

<div class="r"><pre>Periodic$set_params_from_optim(
  optim_out,
  p_est = self$p_est,
  alpha_est = self$alpha_est,
  s2_est = self$s2_est
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>optim_out</code></dt><dd><p>Output from optimization</p>
</dd>
<dt><code>p_est</code></dt><dd><p>Is p being estimated?</p>
</dd>
<dt><code>alpha_est</code></dt><dd><p>Is alpha being estimated?</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_Periodic-s2_from_params"></a>



<h4>Method <code>s2_from_params()</code></h4>

<p>Get s2 from params vector
</p>


<h5>Usage</h5>

<div class="r"><pre>Periodic$s2_from_params(params, s2_est = self$s2_est)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>parameter vector</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_Periodic-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print this object
</p>


<h5>Usage</h5>

<div class="r"><pre>Periodic$print()</pre></div>


<hr>
<a id="method-GauPro_kernel_Periodic-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Periodic$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>k1 &lt;- Periodic$new(p=1, alpha=1)
plot(k1)

n &lt;- 12
x &lt;- matrix(seq(0,1,length.out = n), ncol=1)
y &lt;- sin(2*pi*x) + rnorm(n,0,1e-1)
gp &lt;- GauPro_kernel_model$new(X=x, Z=y, kernel=Periodic$new(D=1),
                              parallel=FALSE)
gp$predict(.454)
gp$plot1D()
gp$cool1Dplot()
plot(gp$kernel)
</code></pre>

<hr>
<h2 id='PowerExp'>Power Exponential Kernel R6 class</h2><span id='topic+PowerExp'></span>

<h3>Description</h3>

<p>Power Exponential Kernel R6 class
</p>
<p>Power Exponential Kernel R6 class
</p>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Value</h3>

<p>Object of <code><a href="R6.html#topic+R6Class">R6Class</a></code> with methods for fitting GP model.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+GauPro_kernel">GauPro::GauPro_kernel</a></code> -&gt; <code><a href="#topic+GauPro_kernel_beta">GauPro::GauPro_kernel_beta</a></code> -&gt; <code>GauPro_kernel_PowerExp</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>alpha</code></dt><dd><p>alpha value (the exponent). Between 0 and 2.</p>
</dd>
<dt><code>alpha_lower</code></dt><dd><p>Lower bound for alpha</p>
</dd>
<dt><code>alpha_upper</code></dt><dd><p>Upper bound for alpha</p>
</dd>
<dt><code>alpha_est</code></dt><dd><p>Should alpha be estimated?</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GauPro_kernel_PowerExp-new"><code>PowerExp$new()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_PowerExp-k"><code>PowerExp$k()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_PowerExp-kone"><code>PowerExp$kone()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_PowerExp-dC_dparams"><code>PowerExp$dC_dparams()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_PowerExp-dC_dx"><code>PowerExp$dC_dx()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_PowerExp-param_optim_start"><code>PowerExp$param_optim_start()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_PowerExp-param_optim_start0"><code>PowerExp$param_optim_start0()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_PowerExp-param_optim_lower"><code>PowerExp$param_optim_lower()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_PowerExp-param_optim_upper"><code>PowerExp$param_optim_upper()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_PowerExp-set_params_from_optim"><code>PowerExp$set_params_from_optim()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_PowerExp-print"><code>PowerExp$print()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_PowerExp-clone"><code>PowerExp$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel" data-id="plot"><a href='../../GauPro/html/GauPro_kernel.html#method-GauPro_kernel-plot'><code>GauPro::GauPro_kernel$plot()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="C_dC_dparams"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-C_dC_dparams'><code>GauPro::GauPro_kernel_beta$C_dC_dparams()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="s2_from_params"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-s2_from_params'><code>GauPro::GauPro_kernel_beta$s2_from_params()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-GauPro_kernel_PowerExp-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize kernel object
</p>


<h5>Usage</h5>

<div class="r"><pre>PowerExp$new(
  alpha = 1.95,
  beta,
  s2 = 1,
  D,
  beta_lower = -8,
  beta_upper = 6,
  beta_est = TRUE,
  alpha_lower = 1e-08,
  alpha_upper = 2,
  alpha_est = TRUE,
  s2_lower = 1e-08,
  s2_upper = 1e+08,
  s2_est = TRUE,
  useC = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>alpha</code></dt><dd><p>Initial alpha value (the exponent). Between 0 and 2.</p>
</dd>
<dt><code>beta</code></dt><dd><p>Initial beta value</p>
</dd>
<dt><code>s2</code></dt><dd><p>Initial variance</p>
</dd>
<dt><code>D</code></dt><dd><p>Number of input dimensions of data</p>
</dd>
<dt><code>beta_lower</code></dt><dd><p>Lower bound for beta</p>
</dd>
<dt><code>beta_upper</code></dt><dd><p>Upper bound for beta</p>
</dd>
<dt><code>beta_est</code></dt><dd><p>Should beta be estimated?</p>
</dd>
<dt><code>alpha_lower</code></dt><dd><p>Lower bound for alpha</p>
</dd>
<dt><code>alpha_upper</code></dt><dd><p>Upper bound for alpha</p>
</dd>
<dt><code>alpha_est</code></dt><dd><p>Should alpha be estimated?</p>
</dd>
<dt><code>s2_lower</code></dt><dd><p>Lower bound for s2</p>
</dd>
<dt><code>s2_upper</code></dt><dd><p>Upper bound for s2</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Should s2 be estimated?</p>
</dd>
<dt><code>useC</code></dt><dd><p>Should C code used? Much faster if implemented.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_PowerExp-k"></a>



<h4>Method <code>k()</code></h4>

<p>Calculate covariance between two points
</p>


<h5>Usage</h5>

<div class="r"><pre>PowerExp$k(
  x,
  y = NULL,
  beta = self$beta,
  alpha = self$alpha,
  s2 = self$s2,
  params = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>vector.</p>
</dd>
<dt><code>y</code></dt><dd><p>vector, optional. If excluded, find correlation
of x with itself.</p>
</dd>
<dt><code>beta</code></dt><dd><p>Correlation parameters.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>alpha value (the exponent). Between 0 and 2.</p>
</dd>
<dt><code>s2</code></dt><dd><p>Variance parameter.</p>
</dd>
<dt><code>params</code></dt><dd><p>parameters to use instead of beta and s2.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_PowerExp-kone"></a>



<h4>Method <code>kone()</code></h4>

<p>Find covariance of two points
</p>


<h5>Usage</h5>

<div class="r"><pre>PowerExp$kone(x, y, beta, theta, alpha, s2)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>vector</p>
</dd>
<dt><code>y</code></dt><dd><p>vector</p>
</dd>
<dt><code>beta</code></dt><dd><p>correlation parameters on log scale</p>
</dd>
<dt><code>theta</code></dt><dd><p>correlation parameters on regular scale</p>
</dd>
<dt><code>alpha</code></dt><dd><p>alpha value (the exponent). Between 0 and 2.</p>
</dd>
<dt><code>s2</code></dt><dd><p>Variance parameter</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_PowerExp-dC_dparams"></a>



<h4>Method <code>dC_dparams()</code></h4>

<p>Derivative of covariance with respect to parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>PowerExp$dC_dparams(params = NULL, X, C_nonug, C, nug)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Kernel parameters</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points in rows</p>
</dd>
<dt><code>C_nonug</code></dt><dd><p>Covariance without nugget added to diagonal</p>
</dd>
<dt><code>C</code></dt><dd><p>Covariance with nugget</p>
</dd>
<dt><code>nug</code></dt><dd><p>Value of nugget</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_PowerExp-dC_dx"></a>



<h4>Method <code>dC_dx()</code></h4>

<p>Derivative of covariance with respect to X
</p>


<h5>Usage</h5>

<div class="r"><pre>PowerExp$dC_dx(
  XX,
  X,
  theta,
  beta = self$beta,
  alpha = self$alpha,
  s2 = self$s2
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>matrix of points</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points to take derivative with respect to</p>
</dd>
<dt><code>theta</code></dt><dd><p>Correlation parameters</p>
</dd>
<dt><code>beta</code></dt><dd><p>log of theta</p>
</dd>
<dt><code>alpha</code></dt><dd><p>alpha value (the exponent). Between 0 and 2.</p>
</dd>
<dt><code>s2</code></dt><dd><p>Variance parameter</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_PowerExp-param_optim_start"></a>



<h4>Method <code>param_optim_start()</code></h4>

<p>Starting point for parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>PowerExp$param_optim_start(
  jitter = F,
  y,
  beta_est = self$beta_est,
  alpha_est = self$alpha_est,
  s2_est = self$s2_est
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>jitter</code></dt><dd><p>Should there be a jitter?</p>
</dd>
<dt><code>y</code></dt><dd><p>Output</p>
</dd>
<dt><code>beta_est</code></dt><dd><p>Is beta being estimated?</p>
</dd>
<dt><code>alpha_est</code></dt><dd><p>Is alpha being estimated?</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_PowerExp-param_optim_start0"></a>



<h4>Method <code>param_optim_start0()</code></h4>

<p>Starting point for parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>PowerExp$param_optim_start0(
  jitter = F,
  y,
  beta_est = self$beta_est,
  alpha_est = self$alpha_est,
  s2_est = self$s2_est
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>jitter</code></dt><dd><p>Should there be a jitter?</p>
</dd>
<dt><code>y</code></dt><dd><p>Output</p>
</dd>
<dt><code>beta_est</code></dt><dd><p>Is beta being estimated?</p>
</dd>
<dt><code>alpha_est</code></dt><dd><p>Is alpha being estimated?</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_PowerExp-param_optim_lower"></a>



<h4>Method <code>param_optim_lower()</code></h4>

<p>Lower bounds of parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>PowerExp$param_optim_lower(
  beta_est = self$beta_est,
  alpha_est = self$alpha_est,
  s2_est = self$s2_est
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>beta_est</code></dt><dd><p>Is beta being estimated?</p>
</dd>
<dt><code>alpha_est</code></dt><dd><p>Is alpha being estimated?</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_PowerExp-param_optim_upper"></a>



<h4>Method <code>param_optim_upper()</code></h4>

<p>Upper bounds of parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>PowerExp$param_optim_upper(
  beta_est = self$beta_est,
  alpha_est = self$alpha_est,
  s2_est = self$s2_est
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>beta_est</code></dt><dd><p>Is beta being estimated?</p>
</dd>
<dt><code>alpha_est</code></dt><dd><p>Is alpha being estimated?</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_PowerExp-set_params_from_optim"></a>



<h4>Method <code>set_params_from_optim()</code></h4>

<p>Set parameters from optimization output
</p>


<h5>Usage</h5>

<div class="r"><pre>PowerExp$set_params_from_optim(
  optim_out,
  beta_est = self$beta_est,
  alpha_est = self$alpha_est,
  s2_est = self$s2_est
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>optim_out</code></dt><dd><p>Output from optimization</p>
</dd>
<dt><code>beta_est</code></dt><dd><p>Is beta estimate?</p>
</dd>
<dt><code>alpha_est</code></dt><dd><p>Is alpha estimated?</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_PowerExp-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print this object
</p>


<h5>Usage</h5>

<div class="r"><pre>PowerExp$print()</pre></div>


<hr>
<a id="method-GauPro_kernel_PowerExp-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>PowerExp$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>k1 &lt;- PowerExp$new(beta=0, alpha=0)
</code></pre>

<hr>
<h2 id='predict.GauPro'>Predict for class GauPro</h2><span id='topic+predict.GauPro'></span>

<h3>Description</h3>

<p>Predict for class GauPro
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GauPro'
predict(object, XX, se.fit = F, covmat = F, split_speed = T, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.GauPro_+3A_object">object</code></td>
<td>
<p>Object of class GauPro</p>
</td></tr>
<tr><td><code id="predict.GauPro_+3A_xx">XX</code></td>
<td>
<p>new points to predict</p>
</td></tr>
<tr><td><code id="predict.GauPro_+3A_se.fit">se.fit</code></td>
<td>
<p>Should standard error be returned (and variance)?</p>
</td></tr>
<tr><td><code id="predict.GauPro_+3A_covmat">covmat</code></td>
<td>
<p>Should the covariance matrix be returned?</p>
</td></tr>
<tr><td><code id="predict.GauPro_+3A_split_speed">split_speed</code></td>
<td>
<p>Should the calculation be split up to speed it up?</p>
</td></tr>
<tr><td><code id="predict.GauPro_+3A_...">...</code></td>
<td>
<p>Additional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prediction from object at XX
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 12
x &lt;- matrix(seq(0,1,length.out = n), ncol=1)
y &lt;- sin(2*pi*x) + rnorm(n,0,1e-1)
gp &lt;- GauPro(X=x, Z=y, parallel=FALSE)
predict(gp, .448)
</code></pre>

<hr>
<h2 id='print.summary.GauPro'>Print summary.GauPro</h2><span id='topic+print.summary.GauPro'></span>

<h3>Description</h3>

<p>Print summary.GauPro
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.GauPro'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.GauPro_+3A_x">x</code></td>
<td>
<p>summary.GauPro object</p>
</td></tr>
<tr><td><code id="print.summary.GauPro_+3A_...">...</code></td>
<td>
<p>Additional args</p>
</td></tr>
</table>


<h3>Value</h3>

<p>prints, returns invisible object
</p>

<hr>
<h2 id='RatQuad'>Rational Quadratic Kernel R6 class</h2><span id='topic+RatQuad'></span>

<h3>Description</h3>

<p>Rational Quadratic Kernel R6 class
</p>
<p>Rational Quadratic Kernel R6 class
</p>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Value</h3>

<p>Object of <code><a href="R6.html#topic+R6Class">R6Class</a></code> with methods for fitting GP model.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+GauPro_kernel">GauPro::GauPro_kernel</a></code> -&gt; <code><a href="#topic+GauPro_kernel_beta">GauPro::GauPro_kernel_beta</a></code> -&gt; <code>GauPro_kernel_RatQuad</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>alpha</code></dt><dd><p>alpha value (the exponent). Between 0 and 2.</p>
</dd>
<dt><code>logalpha</code></dt><dd><p>Log of alpha</p>
</dd>
<dt><code>logalpha_lower</code></dt><dd><p>Lower bound for log of alpha</p>
</dd>
<dt><code>logalpha_upper</code></dt><dd><p>Upper bound for log of alpha</p>
</dd>
<dt><code>alpha_est</code></dt><dd><p>Should alpha be estimated?</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GauPro_kernel_RatQuad-new"><code>RatQuad$new()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_RatQuad-k"><code>RatQuad$k()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_RatQuad-kone"><code>RatQuad$kone()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_RatQuad-dC_dparams"><code>RatQuad$dC_dparams()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_RatQuad-dC_dx"><code>RatQuad$dC_dx()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_RatQuad-param_optim_start"><code>RatQuad$param_optim_start()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_RatQuad-param_optim_start0"><code>RatQuad$param_optim_start0()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_RatQuad-param_optim_lower"><code>RatQuad$param_optim_lower()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_RatQuad-param_optim_upper"><code>RatQuad$param_optim_upper()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_RatQuad-set_params_from_optim"><code>RatQuad$set_params_from_optim()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_RatQuad-print"><code>RatQuad$print()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_RatQuad-clone"><code>RatQuad$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel" data-id="plot"><a href='../../GauPro/html/GauPro_kernel.html#method-GauPro_kernel-plot'><code>GauPro::GauPro_kernel$plot()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="C_dC_dparams"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-C_dC_dparams'><code>GauPro::GauPro_kernel_beta$C_dC_dparams()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="s2_from_params"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-s2_from_params'><code>GauPro::GauPro_kernel_beta$s2_from_params()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-GauPro_kernel_RatQuad-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize kernel object
</p>


<h5>Usage</h5>

<div class="r"><pre>RatQuad$new(
  beta,
  alpha = 1,
  s2 = 1,
  D,
  beta_lower = -8,
  beta_upper = 6,
  beta_est = TRUE,
  alpha_lower = 1e-08,
  alpha_upper = 100,
  alpha_est = TRUE,
  s2_lower = 1e-08,
  s2_upper = 1e+08,
  s2_est = TRUE,
  useC = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>beta</code></dt><dd><p>Initial beta value</p>
</dd>
<dt><code>alpha</code></dt><dd><p>Initial alpha value</p>
</dd>
<dt><code>s2</code></dt><dd><p>Initial variance</p>
</dd>
<dt><code>D</code></dt><dd><p>Number of input dimensions of data</p>
</dd>
<dt><code>beta_lower</code></dt><dd><p>Lower bound for beta</p>
</dd>
<dt><code>beta_upper</code></dt><dd><p>Upper bound for beta</p>
</dd>
<dt><code>beta_est</code></dt><dd><p>Should beta be estimated?</p>
</dd>
<dt><code>alpha_lower</code></dt><dd><p>Lower bound for alpha</p>
</dd>
<dt><code>alpha_upper</code></dt><dd><p>Upper bound for alpha</p>
</dd>
<dt><code>alpha_est</code></dt><dd><p>Should alpha be estimated?</p>
</dd>
<dt><code>s2_lower</code></dt><dd><p>Lower bound for s2</p>
</dd>
<dt><code>s2_upper</code></dt><dd><p>Upper bound for s2</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Should s2 be estimated?</p>
</dd>
<dt><code>useC</code></dt><dd><p>Should C code used? Much faster if implemented.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_RatQuad-k"></a>



<h4>Method <code>k()</code></h4>

<p>Calculate covariance between two points
</p>


<h5>Usage</h5>

<div class="r"><pre>RatQuad$k(
  x,
  y = NULL,
  beta = self$beta,
  logalpha = self$logalpha,
  s2 = self$s2,
  params = NULL
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>vector.</p>
</dd>
<dt><code>y</code></dt><dd><p>vector, optional. If excluded, find correlation
of x with itself.</p>
</dd>
<dt><code>beta</code></dt><dd><p>Correlation parameters.</p>
</dd>
<dt><code>logalpha</code></dt><dd><p>A correlation parameter</p>
</dd>
<dt><code>s2</code></dt><dd><p>Variance parameter.</p>
</dd>
<dt><code>params</code></dt><dd><p>parameters to use instead of beta and s2.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_RatQuad-kone"></a>



<h4>Method <code>kone()</code></h4>

<p>Find covariance of two points
</p>


<h5>Usage</h5>

<div class="r"><pre>RatQuad$kone(x, y, beta, theta, alpha, s2)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>vector</p>
</dd>
<dt><code>y</code></dt><dd><p>vector</p>
</dd>
<dt><code>beta</code></dt><dd><p>correlation parameters on log scale</p>
</dd>
<dt><code>theta</code></dt><dd><p>correlation parameters on regular scale</p>
</dd>
<dt><code>alpha</code></dt><dd><p>A correlation parameter</p>
</dd>
<dt><code>s2</code></dt><dd><p>Variance parameter</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_RatQuad-dC_dparams"></a>



<h4>Method <code>dC_dparams()</code></h4>

<p>Derivative of covariance with respect to parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>RatQuad$dC_dparams(params = NULL, X, C_nonug, C, nug)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Kernel parameters</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points in rows</p>
</dd>
<dt><code>C_nonug</code></dt><dd><p>Covariance without nugget added to diagonal</p>
</dd>
<dt><code>C</code></dt><dd><p>Covariance with nugget</p>
</dd>
<dt><code>nug</code></dt><dd><p>Value of nugget</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_RatQuad-dC_dx"></a>



<h4>Method <code>dC_dx()</code></h4>

<p>Derivative of covariance with respect to X
</p>


<h5>Usage</h5>

<div class="r"><pre>RatQuad$dC_dx(XX, X, theta, beta = self$beta, alpha = self$alpha, s2 = self$s2)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>matrix of points</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points to take derivative with respect to</p>
</dd>
<dt><code>theta</code></dt><dd><p>Correlation parameters</p>
</dd>
<dt><code>beta</code></dt><dd><p>log of theta</p>
</dd>
<dt><code>alpha</code></dt><dd><p>parameter</p>
</dd>
<dt><code>s2</code></dt><dd><p>Variance parameter</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_RatQuad-param_optim_start"></a>



<h4>Method <code>param_optim_start()</code></h4>

<p>Starting point for parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>RatQuad$param_optim_start(
  jitter = F,
  y,
  beta_est = self$beta_est,
  alpha_est = self$alpha_est,
  s2_est = self$s2_est
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>jitter</code></dt><dd><p>Should there be a jitter?</p>
</dd>
<dt><code>y</code></dt><dd><p>Output</p>
</dd>
<dt><code>beta_est</code></dt><dd><p>Is beta being estimated?</p>
</dd>
<dt><code>alpha_est</code></dt><dd><p>Is alpha being estimated?</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_RatQuad-param_optim_start0"></a>



<h4>Method <code>param_optim_start0()</code></h4>

<p>Starting point for parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>RatQuad$param_optim_start0(
  jitter = F,
  y,
  beta_est = self$beta_est,
  alpha_est = self$alpha_est,
  s2_est = self$s2_est
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>jitter</code></dt><dd><p>Should there be a jitter?</p>
</dd>
<dt><code>y</code></dt><dd><p>Output</p>
</dd>
<dt><code>beta_est</code></dt><dd><p>Is beta being estimated?</p>
</dd>
<dt><code>alpha_est</code></dt><dd><p>Is alpha being estimated?</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_RatQuad-param_optim_lower"></a>



<h4>Method <code>param_optim_lower()</code></h4>

<p>Lower bounds of parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>RatQuad$param_optim_lower(
  beta_est = self$beta_est,
  alpha_est = self$alpha_est,
  s2_est = self$s2_est
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>beta_est</code></dt><dd><p>Is beta being estimated?</p>
</dd>
<dt><code>alpha_est</code></dt><dd><p>Is alpha being estimated?</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_RatQuad-param_optim_upper"></a>



<h4>Method <code>param_optim_upper()</code></h4>

<p>Upper bounds of parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>RatQuad$param_optim_upper(
  beta_est = self$beta_est,
  alpha_est = self$alpha_est,
  s2_est = self$s2_est
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>beta_est</code></dt><dd><p>Is beta being estimated?</p>
</dd>
<dt><code>alpha_est</code></dt><dd><p>Is alpha being estimated?</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_RatQuad-set_params_from_optim"></a>



<h4>Method <code>set_params_from_optim()</code></h4>

<p>Set parameters from optimization output
</p>


<h5>Usage</h5>

<div class="r"><pre>RatQuad$set_params_from_optim(
  optim_out,
  beta_est = self$beta_est,
  alpha_est = self$alpha_est,
  s2_est = self$s2_est
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>optim_out</code></dt><dd><p>Output from optimization</p>
</dd>
<dt><code>beta_est</code></dt><dd><p>Is beta being estimated?</p>
</dd>
<dt><code>alpha_est</code></dt><dd><p>Is alpha being estimated?</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_RatQuad-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print this object
</p>


<h5>Usage</h5>

<div class="r"><pre>RatQuad$print()</pre></div>


<hr>
<a id="method-GauPro_kernel_RatQuad-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>RatQuad$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>k1 &lt;- RatQuad$new(beta=0, alpha=0)
</code></pre>

<hr>
<h2 id='sqrt_matrix'>Find the square root of a matrix</h2><span id='topic+sqrt_matrix'></span>

<h3>Description</h3>

<p>Same thing as 'expm::sqrtm', but faster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sqrt_matrix(mat, symmetric)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sqrt_matrix_+3A_mat">mat</code></td>
<td>
<p>Matrix to find square root matrix of</p>
</td></tr>
<tr><td><code id="sqrt_matrix_+3A_symmetric">symmetric</code></td>
<td>
<p>Is it symmetric? Passed to eigen.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Square root of mat
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat &lt;- matrix(c(1,.1,.1,1), 2, 2)
smat &lt;- sqrt_matrix(mat=mat, symmetric=TRUE)
smat %*% smat
</code></pre>

<hr>
<h2 id='summary.GauPro'>if (F) 
# Plot is automatically dispatched, same with print and format
#' Plot for class GauPro
#'
#' @param x Object of class GauPro
#' @param ... Additional parameters
#'
#' @return Nothing
#' @export
#'
#' @examples
#' n &lt;- 12
#' x &lt;- matrix(seq(0,1,length.out = n), ncol=1)
#' y &lt;- sin(2*pi*x) + rnorm(n,0,1e-1)
#' gp &lt;- GauPro(X=x, Z=y, parallel=FALSE)
#' if (requireNamespace(&quot;MASS&quot;, quietly = TRUE)) 
#'   plot(gp)
#' 
#'
plot.GauPro &lt;- function(x,  ...) 
x$plot(...)
# if (x$D == 1) 
#   x$cool1Dplot(...)
#  else if (x$D == 2) 
#   x$plot2D(...)
#  else 
#   # stop(&quot;No plot method for higher than 2 dimension&quot;)
#   x$plotmarginal()
# 


Summary for GauPro object</h2><span id='topic+summary.GauPro'></span>

<h3>Description</h3>

<p>if (F) 
# Plot is automatically dispatched, same with print and format
#' Plot for class GauPro
#'
#' @param x Object of class GauPro
#' @param ... Additional parameters
#'
#' @return Nothing
#' @export
#'
#' @examples
#' n &lt;- 12
#' x &lt;- matrix(seq(0,1,length.out = n), ncol=1)
#' y &lt;- sin(2*pi*x) + rnorm(n,0,1e-1)
#' gp &lt;- GauPro(X=x, Z=y, parallel=FALSE)
#' if (requireNamespace(&quot;MASS&quot;, quietly = TRUE)) 
#'   plot(gp)
#' 
#'
plot.GauPro &lt;- function(x,  ...) 
x$plot(...)
# if (x$D == 1) 
#   x$cool1Dplot(...)
#  else if (x$D == 2) 
#   x$plot2D(...)
#  else 
#   # stop(&quot;No plot method for higher than 2 dimension&quot;)
#   x$plotmarginal()
# 


Summary for GauPro object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GauPro'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.GauPro_+3A_object">object</code></td>
<td>
<p>GauPro R6 object</p>
</td></tr>
<tr><td><code id="summary.GauPro_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to summary</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Summary
</p>

<hr>
<h2 id='trend_0'>Trend R6 class</h2><span id='topic+trend_0'></span>

<h3>Description</h3>

<p>Trend R6 class
</p>
<p>Trend R6 class
</p>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Value</h3>

<p>Object of <code><a href="R6.html#topic+R6Class">R6Class</a></code> with methods for fitting GP model.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+GauPro_trend">GauPro::GauPro_trend</a></code> -&gt; <code>GauPro_trend_0</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>m</code></dt><dd><p>Trend parameters</p>
</dd>
<dt><code>m_lower</code></dt><dd><p>m lower bound</p>
</dd>
<dt><code>m_upper</code></dt><dd><p>m upper bound</p>
</dd>
<dt><code>m_est</code></dt><dd><p>Should m be estimated?</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GauPro_trend_0-new"><code>trend_0$new()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_trend_0-Z"><code>trend_0$Z()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_trend_0-dZ_dparams"><code>trend_0$dZ_dparams()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_trend_0-dZ_dx"><code>trend_0$dZ_dx()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_trend_0-param_optim_start"><code>trend_0$param_optim_start()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_trend_0-param_optim_start0"><code>trend_0$param_optim_start0()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_trend_0-param_optim_lower"><code>trend_0$param_optim_lower()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_trend_0-param_optim_upper"><code>trend_0$param_optim_upper()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_trend_0-set_params_from_optim"><code>trend_0$set_params_from_optim()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_trend_0-clone"><code>trend_0$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-GauPro_trend_0-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize trend object
</p>


<h5>Usage</h5>

<div class="r"><pre>trend_0$new(m = 0, m_lower = 0, m_upper = 0, m_est = FALSE, D = NA)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>m</code></dt><dd><p>trend initial parameters</p>
</dd>
<dt><code>m_lower</code></dt><dd><p>trend lower bounds</p>
</dd>
<dt><code>m_upper</code></dt><dd><p>trend upper bounds</p>
</dd>
<dt><code>m_est</code></dt><dd><p>Logical of whether each param should be estimated</p>
</dd>
<dt><code>D</code></dt><dd><p>Number of input dimensions of data</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_trend_0-Z"></a>



<h4>Method <code>Z()</code></h4>

<p>Get trend value for given matrix X
</p>


<h5>Usage</h5>

<div class="r"><pre>trend_0$Z(X, m = self$m, params = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X</code></dt><dd><p>matrix of points</p>
</dd>
<dt><code>m</code></dt><dd><p>trend parameters</p>
</dd>
<dt><code>params</code></dt><dd><p>trend parameters</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_trend_0-dZ_dparams"></a>



<h4>Method <code>dZ_dparams()</code></h4>

<p>Derivative of trend with respect to trend parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>trend_0$dZ_dparams(X, m = m$est, params = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X</code></dt><dd><p>matrix of points</p>
</dd>
<dt><code>m</code></dt><dd><p>trend values</p>
</dd>
<dt><code>params</code></dt><dd><p>overrides m</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_trend_0-dZ_dx"></a>



<h4>Method <code>dZ_dx()</code></h4>

<p>Derivative of trend with respect to X
</p>


<h5>Usage</h5>

<div class="r"><pre>trend_0$dZ_dx(X, m = self$m, params = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X</code></dt><dd><p>matrix of points</p>
</dd>
<dt><code>m</code></dt><dd><p>trend values</p>
</dd>
<dt><code>params</code></dt><dd><p>overrides m</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_trend_0-param_optim_start"></a>



<h4>Method <code>param_optim_start()</code></h4>

<p>Get parameter initial point for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>trend_0$param_optim_start(jitter, trend_est)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>jitter</code></dt><dd><p>Not used</p>
</dd>
<dt><code>trend_est</code></dt><dd><p>If the trend should be estimate.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_trend_0-param_optim_start0"></a>



<h4>Method <code>param_optim_start0()</code></h4>

<p>Get parameter initial point for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>trend_0$param_optim_start0(jitter, trend_est)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>jitter</code></dt><dd><p>Not used</p>
</dd>
<dt><code>trend_est</code></dt><dd><p>If the trend should be estimate.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_trend_0-param_optim_lower"></a>



<h4>Method <code>param_optim_lower()</code></h4>

<p>Get parameter lower bounds for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>trend_0$param_optim_lower(jitter, trend_est)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>jitter</code></dt><dd><p>Not used</p>
</dd>
<dt><code>trend_est</code></dt><dd><p>If the trend should be estimate.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_trend_0-param_optim_upper"></a>



<h4>Method <code>param_optim_upper()</code></h4>

<p>Get parameter upper bounds for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>trend_0$param_optim_upper(jitter, trend_est)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>jitter</code></dt><dd><p>Not used</p>
</dd>
<dt><code>trend_est</code></dt><dd><p>If the trend should be estimate.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_trend_0-set_params_from_optim"></a>



<h4>Method <code>set_params_from_optim()</code></h4>

<p>Set parameters after optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>trend_0$set_params_from_optim(optim_out)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>optim_out</code></dt><dd><p>Output from optim</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_trend_0-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>trend_0$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>t1 &lt;- trend_0$new()
</code></pre>

<hr>
<h2 id='trend_c'>Trend R6 class</h2><span id='topic+trend_c'></span>

<h3>Description</h3>

<p>Trend R6 class
</p>
<p>Trend R6 class
</p>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Value</h3>

<p>Object of <code><a href="R6.html#topic+R6Class">R6Class</a></code> with methods for fitting GP model.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+GauPro_trend">GauPro::GauPro_trend</a></code> -&gt; <code>GauPro_trend_c</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>m</code></dt><dd><p>Trend parameters</p>
</dd>
<dt><code>m_lower</code></dt><dd><p>m lower bound</p>
</dd>
<dt><code>m_upper</code></dt><dd><p>m upper bound</p>
</dd>
<dt><code>m_est</code></dt><dd><p>Should m be estimated?</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GauPro_trend_c-new"><code>trend_c$new()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_trend_c-Z"><code>trend_c$Z()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_trend_c-dZ_dparams"><code>trend_c$dZ_dparams()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_trend_c-dZ_dx"><code>trend_c$dZ_dx()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_trend_c-param_optim_start"><code>trend_c$param_optim_start()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_trend_c-param_optim_start0"><code>trend_c$param_optim_start0()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_trend_c-param_optim_lower"><code>trend_c$param_optim_lower()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_trend_c-param_optim_upper"><code>trend_c$param_optim_upper()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_trend_c-set_params_from_optim"><code>trend_c$set_params_from_optim()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_trend_c-clone"><code>trend_c$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-GauPro_trend_c-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize trend object
</p>


<h5>Usage</h5>

<div class="r"><pre>trend_c$new(m = 0, m_lower = -Inf, m_upper = Inf, m_est = TRUE, D = NA)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>m</code></dt><dd><p>trend initial parameters</p>
</dd>
<dt><code>m_lower</code></dt><dd><p>trend lower bounds</p>
</dd>
<dt><code>m_upper</code></dt><dd><p>trend upper bounds</p>
</dd>
<dt><code>m_est</code></dt><dd><p>Logical of whether each param should be estimated</p>
</dd>
<dt><code>D</code></dt><dd><p>Number of input dimensions of data</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_trend_c-Z"></a>



<h4>Method <code>Z()</code></h4>

<p>Get trend value for given matrix X
</p>


<h5>Usage</h5>

<div class="r"><pre>trend_c$Z(X, m = self$m, params = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X</code></dt><dd><p>matrix of points</p>
</dd>
<dt><code>m</code></dt><dd><p>trend parameters</p>
</dd>
<dt><code>params</code></dt><dd><p>trend parameters</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_trend_c-dZ_dparams"></a>



<h4>Method <code>dZ_dparams()</code></h4>

<p>Derivative of trend with respect to trend parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>trend_c$dZ_dparams(X, m = self$m, params = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X</code></dt><dd><p>matrix of points</p>
</dd>
<dt><code>m</code></dt><dd><p>trend values</p>
</dd>
<dt><code>params</code></dt><dd><p>overrides m</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_trend_c-dZ_dx"></a>



<h4>Method <code>dZ_dx()</code></h4>

<p>Derivative of trend with respect to X
</p>


<h5>Usage</h5>

<div class="r"><pre>trend_c$dZ_dx(X, m = self$m, params = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X</code></dt><dd><p>matrix of points</p>
</dd>
<dt><code>m</code></dt><dd><p>trend values</p>
</dd>
<dt><code>params</code></dt><dd><p>overrides m</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_trend_c-param_optim_start"></a>



<h4>Method <code>param_optim_start()</code></h4>

<p>Get parameter initial point for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>trend_c$param_optim_start(jitter = F, m_est = self$m_est)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>jitter</code></dt><dd><p>Not used</p>
</dd>
<dt><code>m_est</code></dt><dd><p>If the trend should be estimate.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_trend_c-param_optim_start0"></a>



<h4>Method <code>param_optim_start0()</code></h4>

<p>Get parameter initial point for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>trend_c$param_optim_start0(jitter = F, m_est = self$m_est)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>jitter</code></dt><dd><p>Not used</p>
</dd>
<dt><code>m_est</code></dt><dd><p>If the trend should be estimate.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_trend_c-param_optim_lower"></a>



<h4>Method <code>param_optim_lower()</code></h4>

<p>Get parameter lower bounds for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>trend_c$param_optim_lower(m_est = self$m_est)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>m_est</code></dt><dd><p>If the trend should be estimate.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_trend_c-param_optim_upper"></a>



<h4>Method <code>param_optim_upper()</code></h4>

<p>Get parameter upper bounds for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>trend_c$param_optim_upper(m_est = self$m_est)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>m_est</code></dt><dd><p>If the trend should be estimate.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_trend_c-set_params_from_optim"></a>



<h4>Method <code>set_params_from_optim()</code></h4>

<p>Set parameters after optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>trend_c$set_params_from_optim(optim_out)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>optim_out</code></dt><dd><p>Output from optim</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_trend_c-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>trend_c$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>t1 &lt;- trend_c$new()
</code></pre>

<hr>
<h2 id='trend_LM'>Trend R6 class</h2><span id='topic+trend_LM'></span>

<h3>Description</h3>

<p>Trend R6 class
</p>
<p>Trend R6 class
</p>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Value</h3>

<p>Object of <code><a href="R6.html#topic+R6Class">R6Class</a></code> with methods for fitting GP model.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+GauPro_trend">GauPro::GauPro_trend</a></code> -&gt; <code>GauPro_trend_LM</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>m</code></dt><dd><p>Trend parameters</p>
</dd>
<dt><code>m_lower</code></dt><dd><p>m lower bound</p>
</dd>
<dt><code>m_upper</code></dt><dd><p>m upper bound</p>
</dd>
<dt><code>m_est</code></dt><dd><p>Should m be estimated?</p>
</dd>
<dt><code>b</code></dt><dd><p>trend parameter</p>
</dd>
<dt><code>b_lower</code></dt><dd><p>trend lower bounds</p>
</dd>
<dt><code>b_upper</code></dt><dd><p>trend upper bounds</p>
</dd>
<dt><code>b_est</code></dt><dd><p>Should b be estimated?</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GauPro_trend_LM-new"><code>trend_LM$new()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_trend_LM-Z"><code>trend_LM$Z()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_trend_LM-dZ_dparams"><code>trend_LM$dZ_dparams()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_trend_LM-dZ_dx"><code>trend_LM$dZ_dx()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_trend_LM-param_optim_start"><code>trend_LM$param_optim_start()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_trend_LM-param_optim_start0"><code>trend_LM$param_optim_start0()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_trend_LM-param_optim_lower"><code>trend_LM$param_optim_lower()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_trend_LM-param_optim_upper"><code>trend_LM$param_optim_upper()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_trend_LM-set_params_from_optim"><code>trend_LM$set_params_from_optim()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_trend_LM-clone"><code>trend_LM$clone()</code></a>
</p>
</li></ul>


<hr>
<a id="method-GauPro_trend_LM-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize trend object
</p>


<h5>Usage</h5>

<div class="r"><pre>trend_LM$new(
  D,
  m = rep(0, D),
  m_lower = rep(-Inf, D),
  m_upper = rep(Inf, D),
  m_est = rep(TRUE, D),
  b = 0,
  b_lower = -Inf,
  b_upper = Inf,
  b_est = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>D</code></dt><dd><p>Number of input dimensions of data</p>
</dd>
<dt><code>m</code></dt><dd><p>trend initial parameters</p>
</dd>
<dt><code>m_lower</code></dt><dd><p>trend lower bounds</p>
</dd>
<dt><code>m_upper</code></dt><dd><p>trend upper bounds</p>
</dd>
<dt><code>m_est</code></dt><dd><p>Logical of whether each param should be estimated</p>
</dd>
<dt><code>b</code></dt><dd><p>trend parameter</p>
</dd>
<dt><code>b_lower</code></dt><dd><p>trend lower bounds</p>
</dd>
<dt><code>b_upper</code></dt><dd><p>trend upper bounds</p>
</dd>
<dt><code>b_est</code></dt><dd><p>Should b be estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_trend_LM-Z"></a>



<h4>Method <code>Z()</code></h4>

<p>Get trend value for given matrix X
</p>


<h5>Usage</h5>

<div class="r"><pre>trend_LM$Z(X, m = self$m, b = self$b, params = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X</code></dt><dd><p>matrix of points</p>
</dd>
<dt><code>m</code></dt><dd><p>trend parameters</p>
</dd>
<dt><code>b</code></dt><dd><p>trend parameters (slopes)</p>
</dd>
<dt><code>params</code></dt><dd><p>trend parameters</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_trend_LM-dZ_dparams"></a>



<h4>Method <code>dZ_dparams()</code></h4>

<p>Derivative of trend with respect to trend parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>trend_LM$dZ_dparams(X, m = self$m_est, b = self$b_est, params = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X</code></dt><dd><p>matrix of points</p>
</dd>
<dt><code>m</code></dt><dd><p>trend values</p>
</dd>
<dt><code>b</code></dt><dd><p>trend intercept</p>
</dd>
<dt><code>params</code></dt><dd><p>overrides m</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_trend_LM-dZ_dx"></a>



<h4>Method <code>dZ_dx()</code></h4>

<p>Derivative of trend with respect to X
</p>


<h5>Usage</h5>

<div class="r"><pre>trend_LM$dZ_dx(X, m = self$m, params = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>X</code></dt><dd><p>matrix of points</p>
</dd>
<dt><code>m</code></dt><dd><p>trend values</p>
</dd>
<dt><code>params</code></dt><dd><p>overrides m</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_trend_LM-param_optim_start"></a>



<h4>Method <code>param_optim_start()</code></h4>

<p>Get parameter initial point for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>trend_LM$param_optim_start(
  jitter = FALSE,
  b_est = self$b_est,
  m_est = self$m_est
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>jitter</code></dt><dd><p>Not used</p>
</dd>
<dt><code>b_est</code></dt><dd><p>If the mean should be estimated.</p>
</dd>
<dt><code>m_est</code></dt><dd><p>If the linear terms should be estimated.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_trend_LM-param_optim_start0"></a>



<h4>Method <code>param_optim_start0()</code></h4>

<p>Get parameter initial point for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>trend_LM$param_optim_start0(
  jitter = FALSE,
  b_est = self$b_est,
  m_est = self$m_est
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>jitter</code></dt><dd><p>Not used</p>
</dd>
<dt><code>b_est</code></dt><dd><p>If the mean should be estimated.</p>
</dd>
<dt><code>m_est</code></dt><dd><p>If the linear terms should be estimated.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_trend_LM-param_optim_lower"></a>



<h4>Method <code>param_optim_lower()</code></h4>

<p>Get parameter lower bounds for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>trend_LM$param_optim_lower(b_est = self$b_est, m_est = self$m_est)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>b_est</code></dt><dd><p>If the mean should be estimated.</p>
</dd>
<dt><code>m_est</code></dt><dd><p>If the linear terms should be estimated.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_trend_LM-param_optim_upper"></a>



<h4>Method <code>param_optim_upper()</code></h4>

<p>Get parameter upper bounds for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>trend_LM$param_optim_upper(b_est = self$b_est, m_est = self$m_est)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>b_est</code></dt><dd><p>If the mean should be estimated.</p>
</dd>
<dt><code>m_est</code></dt><dd><p>If the linear terms should be estimated.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_trend_LM-set_params_from_optim"></a>



<h4>Method <code>set_params_from_optim()</code></h4>

<p>Set parameters after optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>trend_LM$set_params_from_optim(optim_out)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>optim_out</code></dt><dd><p>Output from optim</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_trend_LM-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>trend_LM$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>t1 &lt;- trend_LM$new(D=2)
</code></pre>

<hr>
<h2 id='Triangle'>Triangle Kernel R6 class</h2><span id='topic+Triangle'></span>

<h3>Description</h3>

<p>Triangle Kernel R6 class
</p>
<p>Triangle Kernel R6 class
</p>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Value</h3>

<p>Object of <code><a href="R6.html#topic+R6Class">R6Class</a></code> with methods for fitting GP model.
</p>


<h3>Super classes</h3>

<p><code><a href="#topic+GauPro_kernel">GauPro::GauPro_kernel</a></code> -&gt; <code><a href="#topic+GauPro_kernel_beta">GauPro::GauPro_kernel_beta</a></code> -&gt; <code>GauPro_kernel_Triangle</code>
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GauPro_kernel_Triangle-k"><code>Triangle$k()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Triangle-kone"><code>Triangle$kone()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Triangle-dC_dparams"><code>Triangle$dC_dparams()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Triangle-dC_dx"><code>Triangle$dC_dx()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Triangle-print"><code>Triangle$print()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_Triangle-clone"><code>Triangle$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel" data-id="plot"><a href='../../GauPro/html/GauPro_kernel.html#method-GauPro_kernel-plot'><code>GauPro::GauPro_kernel$plot()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="C_dC_dparams"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-C_dC_dparams'><code>GauPro::GauPro_kernel_beta$C_dC_dparams()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="initialize"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-initialize'><code>GauPro::GauPro_kernel_beta$initialize()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="param_optim_lower"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-param_optim_lower'><code>GauPro::GauPro_kernel_beta$param_optim_lower()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="param_optim_start"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-param_optim_start'><code>GauPro::GauPro_kernel_beta$param_optim_start()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="param_optim_start0"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-param_optim_start0'><code>GauPro::GauPro_kernel_beta$param_optim_start0()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="param_optim_upper"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-param_optim_upper'><code>GauPro::GauPro_kernel_beta$param_optim_upper()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="s2_from_params"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-s2_from_params'><code>GauPro::GauPro_kernel_beta$s2_from_params()</code></a></span></li>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel_beta" data-id="set_params_from_optim"><a href='../../GauPro/html/GauPro_kernel_beta.html#method-GauPro_kernel_beta-set_params_from_optim'><code>GauPro::GauPro_kernel_beta$set_params_from_optim()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-GauPro_kernel_Triangle-k"></a>



<h4>Method <code>k()</code></h4>

<p>Calculate covariance between two points
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$k(x, y = NULL, beta = self$beta, s2 = self$s2, params = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>vector.</p>
</dd>
<dt><code>y</code></dt><dd><p>vector, optional. If excluded, find correlation
of x with itself.</p>
</dd>
<dt><code>beta</code></dt><dd><p>Correlation parameters.</p>
</dd>
<dt><code>s2</code></dt><dd><p>Variance parameter.</p>
</dd>
<dt><code>params</code></dt><dd><p>parameters to use instead of beta and s2.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_Triangle-kone"></a>



<h4>Method <code>kone()</code></h4>

<p>Find covariance of two points
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$kone(x, y, beta, theta, s2)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>vector</p>
</dd>
<dt><code>y</code></dt><dd><p>vector</p>
</dd>
<dt><code>beta</code></dt><dd><p>correlation parameters on log scale</p>
</dd>
<dt><code>theta</code></dt><dd><p>correlation parameters on regular scale</p>
</dd>
<dt><code>s2</code></dt><dd><p>Variance parameter</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_Triangle-dC_dparams"></a>



<h4>Method <code>dC_dparams()</code></h4>

<p>Derivative of covariance with respect to parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$dC_dparams(params = NULL, X, C_nonug, C, nug)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Kernel parameters</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points in rows</p>
</dd>
<dt><code>C_nonug</code></dt><dd><p>Covariance without nugget added to diagonal</p>
</dd>
<dt><code>C</code></dt><dd><p>Covariance with nugget</p>
</dd>
<dt><code>nug</code></dt><dd><p>Value of nugget</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_Triangle-dC_dx"></a>



<h4>Method <code>dC_dx()</code></h4>

<p>Derivative of covariance with respect to X
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$dC_dx(XX, X, theta, beta = self$beta, s2 = self$s2)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>matrix of points</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points to take derivative with respect to</p>
</dd>
<dt><code>theta</code></dt><dd><p>Correlation parameters</p>
</dd>
<dt><code>beta</code></dt><dd><p>log of theta</p>
</dd>
<dt><code>s2</code></dt><dd><p>Variance parameter</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_Triangle-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print this object
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$print()</pre></div>


<hr>
<a id="method-GauPro_kernel_Triangle-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>Triangle$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>k1 &lt;- Triangle$new(beta=0)
plot(k1)

n &lt;- 12
x &lt;- matrix(seq(0,1,length.out = n), ncol=1)
y &lt;- sin(2*pi*x) + rnorm(n,0,1e-1)
gp &lt;- GauPro_kernel_model$new(X=x, Z=y, kernel=Triangle$new(1),
                              parallel=FALSE)
gp$predict(.454)
gp$plot1D()
gp$cool1Dplot()
</code></pre>

<hr>
<h2 id='White'>White noise Kernel R6 class</h2><span id='topic+White'></span>

<h3>Description</h3>

<p>White noise Kernel R6 class
</p>
<p>White noise Kernel R6 class
</p>


<h3>Format</h3>

<p><code><a href="R6.html#topic+R6Class">R6Class</a></code> object.
</p>


<h3>Value</h3>

<p>Object of <code><a href="R6.html#topic+R6Class">R6Class</a></code> with methods for fitting GP model.
</p>


<h3>Super class</h3>

<p><code><a href="#topic+GauPro_kernel">GauPro::GauPro_kernel</a></code> -&gt; <code>GauPro_kernel_White</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>s2</code></dt><dd><p>variance</p>
</dd>
<dt><code>logs2</code></dt><dd><p>Log of s2</p>
</dd>
<dt><code>logs2_lower</code></dt><dd><p>Lower bound of logs2</p>
</dd>
<dt><code>logs2_upper</code></dt><dd><p>Upper bound of logs2</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Should s2 be estimated?</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-GauPro_kernel_White-new"><code>White$new()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_White-k"><code>White$k()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_White-kone"><code>White$kone()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_White-dC_dparams"><code>White$dC_dparams()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_White-C_dC_dparams"><code>White$C_dC_dparams()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_White-dC_dx"><code>White$dC_dx()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_White-param_optim_start"><code>White$param_optim_start()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_White-param_optim_start0"><code>White$param_optim_start0()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_White-param_optim_lower"><code>White$param_optim_lower()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_White-param_optim_upper"><code>White$param_optim_upper()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_White-set_params_from_optim"><code>White$set_params_from_optim()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_White-s2_from_params"><code>White$s2_from_params()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_White-print"><code>White$print()</code></a>
</p>
</li>
<li> <p><a href="#method-GauPro_kernel_White-clone"><code>White$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="GauPro" data-topic="GauPro_kernel" data-id="plot"><a href='../../GauPro/html/GauPro_kernel.html#method-GauPro_kernel-plot'><code>GauPro::GauPro_kernel$plot()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-GauPro_kernel_White-new"></a>



<h4>Method <code>new()</code></h4>

<p>Initialize kernel object
</p>


<h5>Usage</h5>

<div class="r"><pre>White$new(
  s2 = 1,
  D,
  s2_lower = 1e-08,
  s2_upper = 1e+08,
  s2_est = TRUE,
  useC = TRUE
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>s2</code></dt><dd><p>Initial variance</p>
</dd>
<dt><code>D</code></dt><dd><p>Number of input dimensions of data</p>
</dd>
<dt><code>s2_lower</code></dt><dd><p>Lower bound for s2</p>
</dd>
<dt><code>s2_upper</code></dt><dd><p>Upper bound for s2</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Should s2 be estimated?</p>
</dd>
<dt><code>useC</code></dt><dd><p>Should C code used? Not implemented for White.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_White-k"></a>



<h4>Method <code>k()</code></h4>

<p>Calculate covariance between two points
</p>


<h5>Usage</h5>

<div class="r"><pre>White$k(x, y = NULL, s2 = self$s2, params = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>vector.</p>
</dd>
<dt><code>y</code></dt><dd><p>vector, optional. If excluded, find correlation
of x with itself.</p>
</dd>
<dt><code>s2</code></dt><dd><p>Variance parameter.</p>
</dd>
<dt><code>params</code></dt><dd><p>parameters to use instead of beta and s2.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_White-kone"></a>



<h4>Method <code>kone()</code></h4>

<p>Find covariance of two points
</p>


<h5>Usage</h5>

<div class="r"><pre>White$kone(x, y, s2)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>x</code></dt><dd><p>vector</p>
</dd>
<dt><code>y</code></dt><dd><p>vector</p>
</dd>
<dt><code>s2</code></dt><dd><p>Variance parameter</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_White-dC_dparams"></a>



<h4>Method <code>dC_dparams()</code></h4>

<p>Derivative of covariance with respect to parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>White$dC_dparams(params = NULL, X, C_nonug, C, nug)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Kernel parameters</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points in rows</p>
</dd>
<dt><code>C_nonug</code></dt><dd><p>Covariance without nugget added to diagonal</p>
</dd>
<dt><code>C</code></dt><dd><p>Covariance with nugget</p>
</dd>
<dt><code>nug</code></dt><dd><p>Value of nugget</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_White-C_dC_dparams"></a>



<h4>Method <code>C_dC_dparams()</code></h4>

<p>Calculate covariance matrix and its derivative
with respect to parameters
</p>


<h5>Usage</h5>

<div class="r"><pre>White$C_dC_dparams(params = NULL, X, nug)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>Kernel parameters</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points in rows</p>
</dd>
<dt><code>nug</code></dt><dd><p>Value of nugget</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_White-dC_dx"></a>



<h4>Method <code>dC_dx()</code></h4>

<p>Derivative of covariance with respect to X
</p>


<h5>Usage</h5>

<div class="r"><pre>White$dC_dx(XX, X, s2 = self$s2)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>XX</code></dt><dd><p>matrix of points</p>
</dd>
<dt><code>X</code></dt><dd><p>matrix of points to take derivative with respect to</p>
</dd>
<dt><code>s2</code></dt><dd><p>Variance parameter</p>
</dd>
<dt><code>theta</code></dt><dd><p>Correlation parameters</p>
</dd>
<dt><code>beta</code></dt><dd><p>log of theta</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_White-param_optim_start"></a>



<h4>Method <code>param_optim_start()</code></h4>

<p>Starting point for parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>White$param_optim_start(jitter = F, y, s2_est = self$s2_est)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>jitter</code></dt><dd><p>Should there be a jitter?</p>
</dd>
<dt><code>y</code></dt><dd><p>Output</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_White-param_optim_start0"></a>



<h4>Method <code>param_optim_start0()</code></h4>

<p>Starting point for parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>White$param_optim_start0(jitter = F, y, s2_est = self$s2_est)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>jitter</code></dt><dd><p>Should there be a jitter?</p>
</dd>
<dt><code>y</code></dt><dd><p>Output</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_White-param_optim_lower"></a>



<h4>Method <code>param_optim_lower()</code></h4>

<p>Lower bounds of parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>White$param_optim_lower(s2_est = self$s2_est)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_White-param_optim_upper"></a>



<h4>Method <code>param_optim_upper()</code></h4>

<p>Upper bounds of parameters for optimization
</p>


<h5>Usage</h5>

<div class="r"><pre>White$param_optim_upper(s2_est = self$s2_est)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_White-set_params_from_optim"></a>



<h4>Method <code>set_params_from_optim()</code></h4>

<p>Set parameters from optimization output
</p>


<h5>Usage</h5>

<div class="r"><pre>White$set_params_from_optim(optim_out, s2_est = self$s2_est)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>optim_out</code></dt><dd><p>Output from optimization</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>s2 estimate</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_White-s2_from_params"></a>



<h4>Method <code>s2_from_params()</code></h4>

<p>Get s2 from params vector
</p>


<h5>Usage</h5>

<div class="r"><pre>White$s2_from_params(params, s2_est = self$s2_est)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>params</code></dt><dd><p>parameter vector</p>
</dd>
<dt><code>s2_est</code></dt><dd><p>Is s2 being estimated?</p>
</dd>
</dl>

</div>


<hr>
<a id="method-GauPro_kernel_White-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print this object
</p>


<h5>Usage</h5>

<div class="r"><pre>White$print()</pre></div>


<hr>
<a id="method-GauPro_kernel_White-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>White$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>Examples</h3>

<pre><code class='language-R'>k1 &lt;- White$new(s2=1e-8)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
