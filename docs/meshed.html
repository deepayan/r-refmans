<!DOCTYPE html><html lang="en"><head><title>Help for package meshed</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {meshed}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#meshed-package'>
<p>Methods for fitting models based on Meshed Gaussian Processes (MGPs)</p></a></li>
<li><a href='#predict.spmeshed'><p>Posterior predictive sampling for models based on MGPs</p></a></li>
<li><a href='#rmeshedgp'>
<p>Prior sampling from a Meshed Gaussian Process</p></a></li>
<li><a href='#spmeshed'><p>Posterior sampling for models based on MGPs</p></a></li>
<li><a href='#summary_list_mean'><p>Arithmetic mean of matrices in a list</p></a></li>
<li><a href='#summary_list_q'><p>Quantiles of elements of matrices in a list</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Regression with Meshed Gaussian Processes</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-09-19</td>
</tr>
<tr>
<td>Author:</td>
<td>Michele Peruzzi</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michele Peruzzi &lt;michele.peruzzi@duke.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Fits Bayesian regression models based on latent Meshed Gaussian Processes (MGP) as described in Peruzzi, Banerjee, Finley (2020) &lt;<a href="https://doi.org/10.1080%2F01621459.2020.1833889">doi:10.1080/01621459.2020.1833889</a>&gt;, Peruzzi, Banerjee, Dunson, and Finley (2021) &lt;<a href="https://doi.org/10.48550/arXiv.2101.03579">doi:10.48550/arXiv.2101.03579</a>&gt;, Peruzzi and Dunson (2022) &lt;<a href="https://doi.org/10.48550/arXiv.2201.10080">doi:10.48550/arXiv.2201.10080</a>&gt;. Funded by ERC grant 856506 and NIH grant R01ES028804.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.5), stats, dplyr, glue, rlang, magrittr, FNN</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, abind, rmarkdown, knitr, tidyr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-19 11:39:59 UTC; mkln</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-19 22:56:15 UTC</td>
</tr>
</table>
<hr>
<h2 id='meshed-package'>
Methods for fitting models based on Meshed Gaussian Processes (MGPs)
</h2><span id='topic+meshed'></span><span id='topic+meshed-package'></span>

<h3>Description</h3>

<p><code>meshed</code> is a flexible package for Bayesian regression analysis on spatial or spatiotemporal datasets. The main function for fitting regression models is <code><a href="#topic+spmeshed">spmeshed</a></code>, which outputs posterior samples obtained from Markov chain Monte Carlo which can be summarised using standard tools. The package also provides a function <code><a href="#topic+rmeshedgp">rmeshedgp</a></code> for quickly simulating correlated spatial or spatiotemporal data at a very large number of locations.
</p>


<h3>Details</h3>

<p>The functions <code><a href="#topic+rmeshedgp">rmeshedgp</a></code> and <code><a href="#topic+spmeshed">spmeshed</a></code> are provided for prior and posterior sampling (respectively) of Bayesian spatial or spatiotemporal multivariate regression models based on Meshed Gaussian Processes as introduced by Peruzzi, Banerjee, and Finley (2020). Posterior sampling via <code><a href="#topic+spmeshed">spmeshed</a></code> proceeds by default via GriPS as detailed in Peruzzi, Banerjee, Dunson, and Finley (2021). When at least one outcome is not modeled with Gaussian errors, sampling proceeds taking advantage of Metropolis-adjusted Langevin dynamics as detailed in Peruzzi and Dunson (2022).
</p>


<h3>Author(s)</h3>

<p>Michele Peruzzi 
</p>


<h3>References</h3>

<p>Peruzzi, M., Banerjee, S., and Finley, A.O. (2022)
Highly Scalable Bayesian Geostatistical Modeling via Meshed Gaussian Processes on Partitioned Domains. <em>Journal of the American Statistical Association</em>, 117(538):969-982. <a href="https://doi.org/10.1080/01621459.2020.1833889">doi:10.1080/01621459.2020.1833889</a>
</p>
<p>Peruzzi, M., Banerjee, S., Dunson, D.B., and Finley, A.O.  (2021)
Grid-Parametrize-Split (GriPS) for Improved Scalable Inference in Spatial Big Data Analysis. <a href="https://arxiv.org/abs/2101.03579">https://arxiv.org/abs/2101.03579</a>
</p>
<p>Peruzzi, M., Dunson, D.B. (2022)
Spatial meshing for general Bayesian multivariate models. <a href="https://arxiv.org/abs/2201.10080">https://arxiv.org/abs/2201.10080</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spmeshed">spmeshed</a></code>, <code><a href="#topic+rmeshedgp">rmeshedgp</a></code>
</p>

<hr>
<h2 id='predict.spmeshed'>Posterior predictive sampling for models based on MGPs</h2><span id='topic+predict.spmeshed'></span>

<h3>Description</h3>

<p>Sample from the posterior predictive distribution of the outcomes at new spatial or spatiotemporal locations after MCMC.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spmeshed'
predict(object, newx, newcoords, 
    n_threads=4, verbose=FALSE, ...)
        
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.spmeshed_+3A_object">object</code></td>
<td>
<p>Object output from <code>spmeshed</code> with option <code>settings$saving=TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict.spmeshed_+3A_newx">newx</code></td>
<td>
<p>matrix of covariate values at the new coordinates.</p>
</td></tr>
<tr><td><code id="predict.spmeshed_+3A_newcoords">newcoords</code></td>
<td>
<p>matrix of new coordinates.</p>
</td></tr>
<tr><td><code id="predict.spmeshed_+3A_n_threads">n_threads</code></td>
<td>
<p>integer number of OpenMP threads. This is ineffective if <code>meshed</code> was not compiled with OpenMP support.</p>
</td></tr>
<tr><td><code id="predict.spmeshed_+3A_verbose">verbose</code></td>
<td>
<p>boolean for progress messagging.</p>
</td></tr>
<tr><td><code id="predict.spmeshed_+3A_...">...</code></td>
<td>
<p>other arguments (unused).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>While this function can always be used to make predictions, in most cases it is more efficient to just include the prediction locations in the main data as <code>NA</code> values; <code><a href="#topic+spmeshed">spmeshed</a></code> will sample from the posterior predictive distribution at those locations while doing MCMC. The <code>predict</code> method is only recommended when all 4 of the following are true:
</p>
<p>(1) <code>spmeshed</code> was run with <code>settings$forced_grid=FALSE</code> and
</p>
<p>(2) the prediction locations are uniformly scattered on the domain (or rather, they are not clustered as a large empty area) and
</p>
<p>(3) the number of prediction locations is a large portion of the number of observed data points and 
</p>
<p>(4) the prediction locations are not on a grid. 
</p>
<p>In all other cases the main <code>spmeshed</code> function is setup to be more efficient in automatically performing predictions during MCMC.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>coords_out</code></td>
<td>
<p>matrix with the prediction location coordinates (order updated after predictions).</p>
</td></tr>
<tr><td><code>preds_out</code></td>
<td>
<p>array of dimension (<code class="reqn">n_{o}, q, m</code>) where <code class="reqn">n_{o}</code> is the number of prediction locations, <code class="reqn">q</code> is the output dimension, <code class="reqn">m</code> is the number of MCMC samples.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michele Peruzzi <a href="mailto:michele.peruzzi@duke.edu">michele.peruzzi@duke.edu</a>
</p>


<h3>References</h3>

<p>Peruzzi, M., Banerjee, S., and Finley, A.O. (2020)
Highly Scalable Bayesian Geostatistical Modeling via Meshed Gaussian Processes on Partitioned Domains. <em>Journal of the American Statistical Association</em>, in press. <a href="https://doi.org/10.1080/01621459.2020.1833889">doi:10.1080/01621459.2020.1833889</a>
</p>
<p>Peruzzi, M., Banerjee, S., Dunson, D.B., and Finley, A.O.  (2021)
Grid-Parametrize-Split (GriPS) for Improved Scalable Inference in Spatial Big Data Analysis. <a href="https://arxiv.org/abs/2101.03579">https://arxiv.org/abs/2101.03579</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# toy example with tiny dataset and short MCMC
# on a univariate outcome
library(magrittr)
library(dplyr)
library(meshed)

set.seed(2021)

SS &lt;- 12
n &lt;- SS^2 # total n. locations, including missing ones

coords &lt;- data.frame(Var1=runif(n), Var2=runif(n)) %&gt;%
  as.matrix()

# generate data
sigmasq &lt;- 2.3
phi &lt;- 6
tausq &lt;- .1
B &lt;- c(-1,.5,1)

CC &lt;- sigmasq * exp(-phi * as.matrix(dist(coords)))
LC &lt;- t(chol(CC))
w &lt;- LC %*% rnorm(n)
p &lt;- length(B)
X &lt;- rnorm(n * p) %&gt;% matrix(ncol=p)
y_full &lt;- X %*% B + w + tausq^.5 * rnorm(n)

set_missing &lt;- rbinom(n, 1, 0.1)

simdata &lt;- data.frame(coords,
                      y_full = y_full,
                      w_latent = w) %&gt;%
  mutate(y_observed = ifelse(set_missing==1, NA, y_full))

# MCMC setup
mcmc_keep &lt;- 500
mcmc_burn &lt;- 100
mcmc_thin &lt;- 2

y &lt;- simdata$y_observed
ybar &lt;- mean(y, na.rm=TRUE)

# training set
y_in &lt;- (y-ybar)[!is.na(y)]
X_in &lt;- X[!is.na(y),]
coords_in &lt;- coords[!is.na(y),]

# suppose we dont want to have gridded knots
# i.e. we are fixing the MGP reference set at the observed locations
# (this may be inefficient in big data settings)
meshout &lt;- spmeshed(y_in, X_in, coords_in,
                    axis_partition=c(4,4),
                    n_samples = mcmc_keep, 
                    n_burn = mcmc_burn, 
                    n_thin = mcmc_thin, 
                    settings = list(forced_grid=FALSE, cache=FALSE),
                    prior=list(phi=c(1,15)),
                    verbose = 0,
                    n_threads = 1)

# test set
coords_out &lt;- coords[is.na(y),]
X_out &lt;- X[is.na(y),]

df_predict &lt;- predict(meshout, newx=X_out, newcoords=coords_out)

y_posterior_predictive_mean &lt;- df_predict$preds_out[,1,] %&gt;% 
  apply(1, mean) %&gt;% add(ybar)
df_predicted &lt;- df_predict$coords_out %&gt;% cbind(y_posterior_predictive_mean)

</code></pre>

<hr>
<h2 id='rmeshedgp'>
Prior sampling from a Meshed Gaussian Process
</h2><span id='topic+rmeshedgp'></span>

<h3>Description</h3>

<p>Generates samples from a (univariate) MGP assuming a cubic directed acyclic graph and axis-parallel domain partitioning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmeshedgp(coords, theta, 
  axis_partition = NULL, block_size = 100, 
  n_threads=1, cache=TRUE, verbose=FALSE, debug=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rmeshedgp_+3A_coords">coords</code></td>
<td>

<p>matrix of spatial or spatiotemporal coordinates with <code class="reqn">d=2</code> or <code class="reqn">d=3</code> columns for spatial or spatiotemporal data, respectively.
</p>
</td></tr>
<tr><td><code id="rmeshedgp_+3A_theta">theta</code></td>
<td>

<p>vector with covariance parameters. If <code class="reqn">d=2</code> and <code>theta</code> is a 2-dimensional vector then <code class="reqn">\theta = (\phi, \sigma^2)</code> where <code class="reqn">\phi</code> is the spatial decay and <code class="reqn">\sigma^2</code> is the spatial variance in the exponential covariance model. If <code class="reqn">d=2</code> and <code>theta</code> is a 3-dimensional vector then <code class="reqn">\theta = (\phi, \nu, \sigma^2)</code> and a Matern model with smoothness <code class="reqn">\nu</code> is used instead. If <code class="reqn">d=3</code>, <code>theta</code> must be a 4-dimensional vector and <code class="reqn">\theta=(a, \phi, b, \sigma^2)</code> using Gneiting's non-separable spatiotemporal covariance detailed below.
</p>
</td></tr>
<tr><td><code id="rmeshedgp_+3A_axis_partition">axis_partition</code></td>
<td>

<p>integer vector of length <code class="reqn">d</code> with the number of intervals along which each axis should be partitioned. The domain will be partitioned into <code>prod(axis_partition)</code> blocks. This argument can be left blank when using <code>block_size</code>.
</p>
</td></tr>
<tr><td><code id="rmeshedgp_+3A_block_size">block_size</code></td>
<td>

<p>integer specifying the (approximate) size of the blocks, i.e. how many spatial or spatiotemporal locations should be included in each block. Note: larger values correspond to an MGP that is closer to a full GP, but require more expensive computations. 
</p>
</td></tr>
<tr><td><code id="rmeshedgp_+3A_n_threads">n_threads</code></td>
<td>

<p>integer number of OpenMP threads. This is ineffective if <code>meshed</code> was not compiled with OpenMP support.
</p>
</td></tr>
<tr><td><code id="rmeshedgp_+3A_cache">cache</code></td>
<td>

<p>bool: whether to use cache. Some computational speedup is associated to <code>cache=TRUE</code> if <code>coords</code> are a grid. 
</p>
</td></tr>
<tr><td><code id="rmeshedgp_+3A_verbose">verbose</code></td>
<td>

<p>bool: print some messages.
</p>
</td></tr>
<tr><td><code id="rmeshedgp_+3A_debug">debug</code></td>
<td>

<p>bool: print more messages.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Gaussian processes (GPs) lack in scalability to big datasets due to the assumed unrestricted dependence across the spatial or spatiotemporal domain.
<em>Meshed</em> GPs instead use a directed acyclic graph (DAG) with patterns, called <em>mesh</em>, to simplify the dependence structure across the domain. Each DAG node corresponds to a partition of the domain. MGPs can be interpreted as approximating the GP they originate from, or as standalone processes that can be sampled from. This function samples random MGPs and can thus be used to generate big spatial or spatiotemporal data. 
The only requirement to sample from a MGP compared to a standard GP is the specification of the domain partitioning strategy. Here, either <code>axis_partition</code> or <code>block_size</code> can be used; the default <code>block_size=100</code> can be used to quickly sample smooth surfaces at millions of locations. 
</p>
<p>Just like in a standard GP, one needs a covariance function or kernel which can be set as follows. 
For spatial data (<code class="reqn">d=2</code>), the length of <code>theta</code> determines which model is used (see above). Letting <code class="reqn">h = \| s-s' \|</code> where <code class="reqn">s</code> and <code class="reqn">s'</code> are locations in the spatial domain, the exponential covariance is defined as: 
</p>
<p style="text-align: center;"><code class="reqn">C(h) = \sigma^2 \exp \{ - \phi h \},</code>
</p>

<p>whereas the Matern model is
</p>
<p style="text-align: center;"><code class="reqn">C(h) = \sigma^2  \frac{2^{1-\nu}}{\Gamma(\nu)} \phi^{\nu} h^{\nu} K_{\nu} ( \phi h ),
  </code>
</p>

<p>where <code class="reqn">K_{\nu}</code> is the modified Bessel function of the second kind of order <code class="reqn">\nu</code>.
For spatiotemporal data (<code class="reqn">d=3</code>) the covariance function between locations <code class="reqn">(s, t)</code> and <code class="reqn">(s', t')</code> with distance <code class="reqn">h = \| s-s' \|</code> and time lag <code class="reqn">u = \| t-t' \|</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn"> C(h, u) = \sigma^2 / (a u + 1) \exp \{ -\phi h (a u + 1)^{-b/2} \}, </code>
</p>

<p>which is a special case of non-separable spacetime covariance as introduced by Gneiting (2002).
</p>


<h3>Value</h3>

<p>data.frame with the (reordered) supplied coordinates in the first <code>d</code> columns, and the MGP sample in the last column, labeled <code>w</code>.
</p>


<h3>Author(s)</h3>

<p>Michele Peruzzi &lt;michele.peruzzi@duke.edu&gt;
</p>


<h3>References</h3>

<p>Gneiting, T (2002) Nonseparable, Stationary Covariance Functions for Space-Time Data. <em>Journal of the American Statistical Association</em>. <a href="https://doi.org/10.1198/016214502760047113">doi:10.1198/016214502760047113</a>
</p>
<p>Peruzzi, M., Banerjee, S., and Finley, A.O. (2020)
Highly Scalable Bayesian Geostatistical Modeling via Meshed Gaussian Processes on Partitioned Domains. <em>Journal of the American Statistical Association</em>, in press. <a href="https://doi.org/10.1080/01621459.2020.1833889">doi:10.1080/01621459.2020.1833889</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
library(ggplot2)
library(magrittr)
library(meshed)

# spatial domain (we choose a grid to make a nice image later)
# this generates a dataset of size 6400
xx &lt;- seq(0, 1, length.out=80)
coords &lt;- expand.grid(xx, xx) %&gt;%
  as.matrix()

raster_plot &lt;- function(df){
  ggplot(df, aes(Var1, Var2, fill=w)) +
    geom_raster() +
    scale_fill_viridis_c() +
    theme_minimal() }

# spatial data, exponential covariance
# phi=14, sigma^2=2
simdata &lt;- rmeshedgp(coords, c(14, 2))
raster_plot(simdata)

# spatial data, matern covariance
# phi=14, nu=1, sigma^2=2
simdata &lt;- rmeshedgp(coords, c(14, 1, 2))
raster_plot(simdata)

# spacetime data, gneiting's covariance
# 64000 locations
stcoords &lt;- expand.grid(xx, xx, seq(0, 1, length.out=10))

# it should take less than a couple of seconds
simdata &lt;- rmeshedgp(stcoords, c(1, 14, .5, 2))
# plot data at 7th time period
raster_plot(simdata %&gt;% dplyr::filter(Var3==unique(Var3)[7])) 

</code></pre>

<hr>
<h2 id='spmeshed'>Posterior sampling for models based on MGPs</h2><span id='topic+spmeshed'></span>

<h3>Description</h3>

<p>Fits Bayesian multivariate spatial or spatiotemporal regression models with latent MGPs via Markov chain Monte Carlo.</p>


<h3>Usage</h3>

<pre><code class='language-R'>spmeshed(y, x, coords, k=NULL,
       family = "gaussian",
       axis_partition = NULL, 
       block_size = 30,
       grid_size = NULL,
       grid_custom = NULL,
       n_samples = 1000,
       n_burnin = 100,
       n_thin = 1,
       n_threads = 4,
       verbose = 0,
       predict_everywhere = FALSE,
       settings = list(adapting=TRUE, forced_grid=NULL, 
                          cache=NULL, ps=TRUE, saving=TRUE, low_mem=FALSE, hmc=4),
       prior = list(beta=NULL, tausq=NULL, sigmasq = NULL,
                          phi=NULL, a=NULL, nu = NULL,
                          toplim = NULL, btmlim = NULL, set_unif_bounds=NULL),
       starting = list(beta=NULL, tausq=NULL, theta=NULL, lambda=NULL, v=NULL, 
                       a=NULL, nu = NULL,
                       mcmcsd=.05, 
                       mcmc_startfrom=0),
       debug = list(sample_beta=TRUE, sample_tausq=TRUE, 
                    sample_theta=TRUE, sample_w=TRUE, sample_lambda=TRUE,
                    verbose=FALSE, debug=FALSE),
       indpart=FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spmeshed_+3A_y">y</code></td>
<td>
<p>matrix of multivariate outcomes with <code class="reqn">n</code> rows and <code class="reqn">q</code> columns. Each row of <code>y</code> corresponds to a row of <code>coords</code>. <code>NA</code> values are accepted in any combination and will be predicted via MCMC.</p>
</td></tr>
<tr><td><code id="spmeshed_+3A_x">x</code></td>
<td>
<p>matrix of covariates with <code class="reqn">n</code> rows and <code class="reqn">p</code> columns.</p>
</td></tr>
<tr><td><code id="spmeshed_+3A_coords">coords</code></td>
<td>
<p>matrix of coordinates with <code class="reqn">n</code> rows and <code class="reqn">d=2</code> or <code class="reqn">d=3</code> columns for spatial or spacetime regression, respectively.</p>
</td></tr>
<tr><td><code id="spmeshed_+3A_k">k</code></td>
<td>
<p>integer <code class="reqn">k\leq q</code>, number of latent processes to use for the linear model of coregionalization. If unspecified, this is set to <code class="reqn">q</code><code>=ncol(y)</code>.</p>
</td></tr>
<tr><td><code id="spmeshed_+3A_family">family</code></td>
<td>
<p>a vector with length <code class="reqn">1</code> or <code class="reqn">q</code> whose elements corresponds to the data types of columns of <code>y</code>. Available choices are <code>gaussian</code>, <code>poisson</code>, <code>binomial</code>, <code>beta</code> for outcomes that are continuous, count, binary, or <code class="reqn">(0,1)</code> proportions.</p>
</td></tr>
<tr><td><code id="spmeshed_+3A_axis_partition">axis_partition</code></td>
<td>
<p>integer vector of size <code class="reqn">d</code>: number of intervals each coordinate axis is split into</p>
</td></tr>
<tr><td><code id="spmeshed_+3A_block_size">block_size</code></td>
<td>
<p>integer approximate size of the blocks after domain partitioning. Only used if <code>axis_partition</code> is not specified.</p>
</td></tr>
<tr><td><code id="spmeshed_+3A_grid_size">grid_size</code></td>
<td>
<p>integer vector of size <code class="reqn">d</code>: number of 'knots' of the reference grid along each axis. 
This grid is then partitioned using either <code>axis_partition</code> or <code>block_size</code>.
If unspecified, this is set so that the eventual grid size is close to <code class="reqn">n</code>.
This parameter is ignored if <code>settings$forced_grid=FALSE</code> in which case the data are assumed to be on a grid.</p>
</td></tr>
<tr><td><code id="spmeshed_+3A_grid_custom">grid_custom</code></td>
<td>
<p>list with elements <code>grid</code> and <code>axis_interval_partition</code>. <code>grid</code> is a data.frame with the user supplied grid of knots. It is possible to include covariate values for the grid locations as additional columns, as long as their number matches <code>ncol(x)</code> - this is useful to make raster images of predictions. <code>axis_interval_partition</code> is the user supplied set of cuts for each coordinate axis (Note: these are the actual cutpoints along the axes, not the number of cuts). If left empty, <code>axis_partition</code> will be used to partition the custom grid. No checks are made on the validity of this grid. This parameter is ignored if <code>settings$forced_grid=FALSE</code> in which case the data are assumed to be on a grid.</p>
</td></tr>
<tr><td><code id="spmeshed_+3A_n_samples">n_samples</code></td>
<td>
<p>integer number of MCMC samples at which all the unknowns are stored (including the latent effects).</p>
</td></tr>
<tr><td><code id="spmeshed_+3A_n_burnin">n_burnin</code></td>
<td>
<p>integer number of MCMC samples to discard at the beginning of the chain.</p>
</td></tr>
<tr><td><code id="spmeshed_+3A_n_thin">n_thin</code></td>
<td>
<p>integer thinning parameter for the MCMC chain. Only the chain of latent effects (<code class="reqn">w</code>) is thinned to save memory in big data problems. Chains for other unknowns are not thinned and thus will be of length <code>n_thin * n_samples</code>.</p>
</td></tr>
<tr><td><code id="spmeshed_+3A_n_threads">n_threads</code></td>
<td>
<p>integer number of OpenMP threads. This is ineffective if <code>meshed</code> was not compiled with OpenMP support.</p>
</td></tr>
<tr><td><code id="spmeshed_+3A_verbose">verbose</code></td>
<td>
<p>integer. If <code>verbose&lt;=20</code>, then this is the number of times a message is displayed during MCMC. If <code>verbose&gt;20</code>, then this is the number of MCMC iterations to wait until the next message update. If <code>verbose=Inf</code>, then a message will be printed at each MCMC iteration.</p>
</td></tr>
<tr><td><code id="spmeshed_+3A_predict_everywhere">predict_everywhere</code></td>
<td>
<p>bool used if settings$forced_grid=T. Should predictions be made at the reference grid locations? If not, predictions will be made only at the supplied NA values of Y.</p>
</td></tr>
<tr><td><code id="spmeshed_+3A_settings">settings</code></td>
<td>
<p>list: <code>settings$adapting</code> turns the adaptation of MCMC on/off, <code>settings$forced_grid</code> determines whether or not to use the data grid or a forced grid; if unspecified, the function will try to see what the data look like. Note: if <code>forced_grid=FALSE</code> and <code class="reqn">n</code> is very large and <code class="reqn">coords</code> are irregularly spaced, then expect slowdowns in preprocessing and consider using <code>forced_grid=TRUE</code> instead. <code>settings$saving</code> will save model data if set to <code>TRUE</code>. <code>settings$low_mem</code> will only save <code>beta_mcmc</code>, <code>lambda_mcmc</code>, <code>v_mcmc</code>, <code>tausq_mcmc</code> (and not <code>w_mcmc</code> and <code>lp_mcmc</code>, which can be recovered from the others), thereby using less memory. All fitted predictions remain available in <code>yhat_mcmc</code> for convenience. <code>settings$ps</code> (default <code>TRUE</code>) determines whether to use the PS parametrization (Peruzzi et al 2021). <code>settings$hmc</code>, used if any outcome is not Gaussian, (1: MALA, 2: NUTS, 3: RM-MALA, 4: Simplified manifold preconditioning (default))</p>
</td></tr>
<tr><td><code id="spmeshed_+3A_prior">prior</code></td>
<td>
<p>list: setup for priors of unknown parameters. <code>prior$phi</code> needs to be specified as the support of the Uniform prior for <code class="reqn">\phi</code>. There is currently limited functionality here and some inputs are currently ignored. Defaults are: a vague Gaussian for <code class="reqn">\beta</code>, <code class="reqn">\tau^2_i \sim IG(2,1)</code>, <code class="reqn">\theta_j \sim IG(2,2)</code>, all subject to change.</p>
</td></tr>
<tr><td><code id="spmeshed_+3A_starting">starting</code></td>
<td>
<p>list: setup for starting values of unknown parameters. <code>starting$mcmcsd</code> is the initial standard deviation of proposals. <code>starting$mcmc_startfrom</code> is input to the adaptive MCMC and can be used to manually restart MCMC. There is currently limited functionality here and some parameters may be ignored.</p>
</td></tr>
<tr><td><code id="spmeshed_+3A_debug">debug</code></td>
<td>
<p>list: setup for debugging things. Some parts of MCMC can be turned off here.</p>
</td></tr>
<tr><td><code id="spmeshed_+3A_indpart">indpart</code></td>
<td>
<p>bool defaults to <code>FALSE</code>. If <code>TRUE</code>, this computes an independent partition model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function targets the following model:
</p>
<p style="text-align: center;"><code class="reqn"> y(s) = x(s)^\top \beta + \Lambda v(s) + \epsilon(s), </code>
</p>

<p>where <code class="reqn">y(s)</code> is a <code class="reqn">q</code>-dimensional vector of outcomes at spatial location <code class="reqn">s</code>, <code class="reqn">x(s)</code> is a <code class="reqn">p</code>-dimensional vector of covariates with static coefficients <code class="reqn">\beta</code>, <code class="reqn">\Lambda</code> is a matrix of factor loadings of size <code class="reqn">(q, k)</code>, <code class="reqn">v(s)</code> is a <code class="reqn">k</code>-dimensional vector which collects the realization of independent Gaussian processes <code class="reqn">v_j \sim spmeshed(0, C_j)</code> for <code class="reqn">j=1, \dots, k</code> and where <code class="reqn">C_j(s, s')</code> is a correlation function. <code class="reqn">s</code> is a coordinate in space (<code class="reqn">d=2</code>) or space plus time (<code class="reqn">d=3</code>). The Meshed GP implemented here associates an axis-parallel tessellation of the domain to a cubic directed acyclic graph (mesh).
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>coordsdata</code></td>
<td>
<p>data.frame including the original <code class="reqn">n</code> coordinates plus the <code class="reqn">n_g</code> knot coordinates if the model was run on a forced grid. The additional column <code>forced_grid</code> has value 1 if the corresponding coordinate is a knot in the forced grid. See examples.</p>
</td></tr>
<tr><td><code>savedata</code></td>
<td>
<p>Available if <code>settings$saving==TRUE</code>. Needed for making predictions using <code>predict()</code> after MCMC. Note: <code>NA</code> values of the output are automatically and more efficiently predicted when running <code>spmeshed</code>.</p>
</td></tr>
<tr><td><code>yhat_mcmc</code></td>
<td>
<p>list of length <code>n_samples</code> whose elements are matrices with <code class="reqn">n + n_g</code> rows and <code class="reqn">q</code> columns. Each matrix in the list is a posterior predictive sample of the latent spatial process. <code class="reqn">n_g = 0</code> if the data grid is being used. Given the possibly large <code class="reqn">n</code>, only the thinned chain is output for <code class="reqn">y</code>.</p>
</td></tr>
<tr><td><code>v_mcmc</code></td>
<td>
<p>list of length <code>n_samples</code> whose elements are matrices with <code class="reqn">n + n_g</code> rows and <code class="reqn">k</code> columns. Each matrix in the list is a posterior sample of the <code class="reqn">k</code> latent spatial process. <code class="reqn">n_g = 0</code> if the data grid is being used. Given the possibly large <code class="reqn">n</code>, only the thinned chain is output for <code class="reqn">v</code>.</p>
</td></tr>
<tr><td><code>w_mcmc</code></td>
<td>
<p>list of length <code>n_samples</code> whose elements are matrices with <code class="reqn">n + n_g</code> rows and <code class="reqn">q</code> columns. Each matrix in the list is a posterior sample of <code class="reqn">w = \Lambda v</code>. <code class="reqn">n_g = 0</code> if the data grid is being used. Given the possibly large <code class="reqn">n</code>, only the thinned chain is output for <code class="reqn">w</code>.</p>
</td></tr>
<tr><td><code>lp_mcmc</code></td>
<td>
<p>list of length <code>n_samples</code> whose elements are matrices with <code class="reqn">n + n_g</code> rows and <code class="reqn">q</code> columns. Each matrix in the list is a posterior sample of the linear predictor <code class="reqn">X\beta + \Lambda v</code>. <code class="reqn">n_g = 0</code> if the data grid is being used. Given the possibly large <code class="reqn">n</code>, only the thinned chain is output for <code class="reqn">w</code>.</p>
</td></tr>
<tr><td><code>beta_mcmc</code></td>
<td>
<p>array of size <code>(p, q, n_thin*n_samples)</code> with the posterior sample for the static regression coefficients <code class="reqn">\beta</code>. The <code class="reqn">j</code>th column of each matrix (<code class="reqn">p</code> rows and <code class="reqn">q</code> columns) corresponds to the <code class="reqn">p</code> linear effects on the <code class="reqn">j</code>th outcome. The full chain minus burn-in is returned NOT thinned since <code>p</code> and <code>q</code> are relatively small.</p>
</td></tr>
<tr><td><code>tausq_mcmc</code></td>
<td>
<p>matrix of size <code>(q, n_thin*n_samples)</code>. Each row corresponds to the full MCMC chain for the nugget <code class="reqn">\tau^2_j</code> of the <code class="reqn">j</code>th outcome in the coregionalization/factor model. The full chain minus burn-in is returned NOT thinned since <code>q</code> is relatively small.</p>
</td></tr>
<tr><td><code>theta_mcmc</code></td>
<td>
<p>array of size <code>(h, k, n_thin*n_samples)</code> with the posterior sample for the correlation function parameters <code class="reqn">\theta</code>. <code>h</code> is 2 for spatial data (corresponding to the spatial decay of the exponential covariance (<code class="reqn">\phi_i, i=1, \dots, k</code>), and the variance <code class="reqn">\sigma^2_i, i=1, \dots, k</code>), 4 for spacetime data (corresponding to temporal decay, spatial decay, and separability &ndash; these are referred to as <code class="reqn">a_i</code>, <code class="reqn">\phi_i</code>, and <code class="reqn">\beta_i, i=1, \dots, k</code>, in Gneiting (2002), see <a href="https://doi.org/10.1198/016214502760047113">doi:10.1198/016214502760047113</a>, plus the variance <code class="reqn">\sigma^2, i=1, \dots, k</code>). The full chain minus burn-in is returned NOT thinned since <code>h</code> and <code>k</code> are relatively small. If <code>settings$ps=TRUE</code>, the MCMC output for <code class="reqn">\sigma^2_i</code> (last row of <code>theta_mcmc</code>) should be discarded and <code class="reqn">\Lambda</code> used instead.</p>
</td></tr>
<tr><td><code>lambda_mcmc</code></td>
<td>
<p>array of size <code>(q, k, n_thin*n_samples)</code>. Each matrix (of size <code class="reqn">(q,k)</code>) is a posterior sample for <code class="reqn">\Lambda</code> in the coregionalization/factor model. In univariate models, this is usually called <code class="reqn">\sigma</code>. The full chain minus burn-in is returned NOT thinned since <code>q</code> and <code>k</code> are relatively small.</p>
</td></tr>
<tr><td><code>paramsd</code></td>
<td>
<p>Cholesky factorization of the proposal covariance for adaptive MCMC, after adaptation.</p>
</td></tr>
<tr><td><code>mcmc</code></td>
<td>
<p>Total number of MCMC iterations performed.</p>
</td></tr>
<tr><td><code>mcmc_time</code></td>
<td>
<p>Time in seconds taken for MCMC (not including preprocessing).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michele Peruzzi <a href="mailto:michele.peruzzi@duke.edu">michele.peruzzi@duke.edu</a>
</p>


<h3>References</h3>

<p>Peruzzi, M., Banerjee, S., and Finley, A.O. (2022)
Highly Scalable Bayesian Geostatistical Modeling via Meshed Gaussian Processes on Partitioned Domains. <em>Journal of the American Statistical Association</em>, 117(538):969-982. <a href="https://doi.org/10.1080/01621459.2020.1833889">doi:10.1080/01621459.2020.1833889</a>
</p>
<p>Peruzzi, M., Banerjee, S., Dunson, D.B., and Finley, A.O.  (2021)
Grid-Parametrize-Split (GriPS) for Improved Scalable Inference in Spatial Big Data Analysis. <a href="https://arxiv.org/abs/2101.03579">https://arxiv.org/abs/2101.03579</a>
</p>
<p>Peruzzi, M. and Dunson, D.B. (2022)
Spatial meshing for general Bayesian multivariate models. <a href="https://arxiv.org/abs/2201.10080">https://arxiv.org/abs/2201.10080</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# toy example with tiny dataset and short MCMC
# on a univariate outcome
library(magrittr)
library(dplyr)
library(ggplot2)
library(meshed)

set.seed(2021)

SS &lt;- 12
n &lt;- SS^2 # total n. locations, including missing ones

coords &lt;- expand.grid(xx &lt;- seq(0,1,length.out=SS), xx) %&gt;% 
  as.matrix()

# generate data
sigmasq &lt;- 2.3
phi &lt;- 6
tausq &lt;- .1
B &lt;- c(-1,.5,1)

CC &lt;- sigmasq * exp(-phi * as.matrix(dist(coords)))
LC &lt;- t(chol(CC))
w &lt;- LC %*% rnorm(n)
p &lt;- length(B)
X &lt;- rnorm(n * p) %&gt;% matrix(ncol=p)
y_full &lt;- X %*% B + w + tausq^.5 * rnorm(n)

set_missing &lt;- rbinom(n, 1, 0.1)

simdata &lt;- data.frame(coords,
                      y_full = y_full,
                      w_latent = w) %&gt;%
  mutate(y_observed = ifelse(set_missing==1, NA, y_full))

# MCMC setup
mcmc_keep &lt;- 500
mcmc_burn &lt;- 100
mcmc_thin &lt;- 2

y &lt;- simdata$y_observed
ybar &lt;- mean(y, na.rm=TRUE)

meshout &lt;- spmeshed(y-ybar, X, coords,
                    axis_partition=c(4,4),
                    n_samples = mcmc_keep, 
                    n_burn = mcmc_burn, 
                    n_thin = mcmc_thin, 
                    prior=list(phi=c(1,15)),
                    verbose = 0,
                    n_threads = 1)

# posterior means
best_post_mean &lt;- meshout$beta_mcmc %&gt;% apply(1:2, mean)
  
# process means
wmesh &lt;- data.frame(w_mgp = meshout$w_mcmc %&gt;% summary_list_mean())
# predictions
ymesh &lt;- data.frame(y_mgp = meshout$yhat_mcmc %&gt;% summary_list_mean())

outdf &lt;- 
  meshout$coordsdata %&gt;% 
  cbind(ymesh, wmesh) 

# plot predictions
pred_plot &lt;- outdf %&gt;% 
  ggplot(aes(Var1, Var2, color=y_mgp)) +
  geom_point() +
  scale_color_viridis_c()

# plot latent process
latent_plot &lt;- outdf %&gt;% 
  ggplot(aes(Var1, Var2, color=w_mgp)) +
  geom_point() + 
  scale_color_viridis_c()

# estimation of regression coefficients
plot(density(meshout$beta_mcmc[1,1,]))
abline(v=B[1], col="red")


</code></pre>

<hr>
<h2 id='summary_list_mean'>Arithmetic mean of matrices in a list</h2><span id='topic+summary_list_mean'></span>

<h3>Description</h3>

<p>For a list of matrices <code class="reqn">\{ X^{(1)}, \dots, X^{(L)} \}</code>, all of the same dimension, this function computes the matrix <code class="reqn">\bar{X}</code> with <code class="reqn">i,j</code> entry <code class="reqn"> \bar{X}_{i,j} = \frac{1}{L}\sum_{ l=1 }^{L} X_{ i,j }^{(l)} </code>. This function does not run any check on the dimensions and uses OpenMP if available.</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_list_mean(x, n_threads=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary_list_mean_+3A_x">x</code></td>
<td>
<p>A list of matrices of the same dimension</p>
</td></tr>
<tr><td><code id="summary_list_mean_+3A_n_threads">n_threads</code></td>
<td>
<p>integer number of OpenMP threads. This is ineffective if <code>meshed</code> was not compiled with OpenMP support.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix of mean values.</p>


<h3>Author(s)</h3>

<p>Michele Peruzzi <a href="mailto:michele.peruzzi@duke.edu">michele.peruzzi@duke.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make some data into a list
set.seed(2021)
L &lt;- 200
x &lt;- lapply(1:L, function(i) matrix(runif(300), ncol=3)) 
mean_done &lt;- summary_list_mean(x)
</code></pre>

<hr>
<h2 id='summary_list_q'>Quantiles of elements of matrices in a list</h2><span id='topic+summary_list_q'></span>

<h3>Description</h3>

<p>For a list of matrices <code class="reqn">\{ X^{(1)}, \dots, X^{(L)} \}</code>, all of the same dimension, this function computes the matrix <code class="reqn">\hat{X}</code> with <code class="reqn">i,j</code> entry <code class="reqn"> \hat{X}_{i,j} = </code> <code>quantile(</code><code class="reqn"> \{ X_{ i,j }^{(l)} \}_{l=1}^L </code><code>, q)</code>. This function does not run any check on the dimensions and uses OpenMP if available. This is only a convenience function that is supposed to speed up quantile computation for very large problems. The results may be slightly different from R's <code>quantile</code> which should be used for small problems.</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_list_q(x, q, n_threads=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary_list_q_+3A_x">x</code></td>
<td>
<p>A list of matrices of the same dimension.</p>
</td></tr>
<tr><td><code id="summary_list_q_+3A_q">q</code></td>
<td>
<p>A number between 0 and 1.</p>
</td></tr>
<tr><td><code id="summary_list_q_+3A_n_threads">n_threads</code></td>
<td>
<p>integer number of OpenMP threads. This is ineffective if <code>meshed</code> was not compiled with OpenMP support.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix of quantiles.</p>


<h3>Author(s)</h3>

<p>Michele Peruzzi <a href="mailto:michele.peruzzi@duke.edu">michele.peruzzi@duke.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make some data into a list
set.seed(2021)
L &lt;- 200
x &lt;- lapply(1:L, function(i) matrix(runif(300), ncol=3)) 
quant_done1 &lt;- summary_list_q(x, .9)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
