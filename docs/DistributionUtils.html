<!DOCTYPE html><html lang="en"><head><title>Help for package DistributionUtils</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DistributionUtils}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#DistributionUtils-package'>
<p>Utility functions useful for all distributions in packages following</p>
the standard approach developed in Scott, Wuertz and Dong.</a></li>
<li><a href='#Bessel+20K+20Ratio'><p>Ratio of Bessel K Functions</p></a></li>
<li><a href='#distCalcRange'>
<p>Range of a Unimodal Distribution</p></a></li>
<li><a href='#distIneqMassart'>
<p>Massart Inequality for Distributions</p></a></li>
<li><a href='#distIneqMassartPlot'>
<p>Massart Inequality Plot Function</p></a></li>
<li><a href='#distMode'><p>Mode of a Unimodal Distribution</p></a></li>
<li><a href='#DistributionUtils-internal'><p>Internal Distribution Utilities Functions</p></a></li>
<li><a href='#distStepSize'>
<p>Step Size for Calculating the Range of a Unimodal Distribution</p></a></li>
<li><a href='#incompleteBesselK'><p>The Incomplete Bessel K Function</p></a></li>
<li><a href='#integrateDens'>
<p>Integrates a Density Function</p></a></li>
<li><a href='#inversionTests'>
<p>Inversion Tests for Distributions</p></a></li>
<li><a href='#is.wholenumber'><p>Is Object Numeric and Whole Numbers</p></a></li>
<li><a href='#logHist'><p>Plot Log-Histogram</p></a></li>
<li><a href='#momChangeAbout'><p>Obtain Moments About a New Location</p></a></li>
<li><a href='#momIntegrated'><p>Moments Using Integration</p></a></li>
<li><a href='#momSE'>
<p>Standard Errors of Sample Moments</p></a></li>
<li><a href='#moranTest'>
<p>Moran's Log Spacings Test</p></a></li>
<li><a href='#pDist'>
<p>Distribution and Quantile Functions for Unimodal Distributions</p></a></li>
<li><a href='#safeIntegrate'><p>Safe Integration of One-Dimensional Functions</p></a></li>
<li><a href='#Sample+20Moments'><p>Sample Skewness and Kurtosis</p></a></li>
<li><a href='#tailPlot'>
<p>Tail Plot Functions</p></a></li>
<li><a href='#tsHessian'>
<p>Calculate Two-Sided Hessian Approximation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.6-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-22</td>
</tr>
<tr>
<td>Title:</td>
<td>Distribution Utilities</td>
</tr>
<tr>
<td>Author:</td>
<td>David Scott &lt;d.scott@auckland.ac.nz&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Scott &lt;d.scott@auckland.ac.nz&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>GeneralizedHyperbolic, VarianceGamma, SkewHyperbolic, RUnit</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Description:</td>
<td>Utilities are provided which are of use in the
    packages I have developed for dealing with
    distributions. Currently these packages are GeneralizedHyperbolic,
    VarianceGamma, and SkewHyperbolic and NormalLaplace. Each of these
    packages requires DistributionUtils. Functionality includes sample
    skewness and kurtosis, log-histogram, tail plots, moments by
    integration, changing the point about which a moment is
    calculated, functions for testing distributions using inversion
    tests and the Massart inequality. Also includes an implementation
    of the incomplete Bessel K function.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-24 11:47:27 UTC; dsco036</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-28 11:30:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='DistributionUtils-package'>
Utility functions useful for all distributions in packages following
the standard approach developed in Scott, Wuertz and Dong.
</h2><span id='topic+DistributionUtils-package'></span><span id='topic+DistributionUtils'></span>

<h3>Description</h3>

<p>Functionality includes sample skewness and kurtosis, log-histogram,
tail plots, moments by integration, changing the point about which a
moment is calculated, functions for testing distributions using
inversion tests and the Massart inequality. Also includes an
implementation of the incomplete Bessel K function.  
</p>


<h3>Details</h3>

<p>Contains functions which are useful for packages implementing
distributions. Designed to work with my packages <span class="pkg">GeneralizedHyperbolic</span>,
<span class="pkg">VarianceGamma</span>, <span class="pkg">SkewHyperbolic</span> and <span class="pkg">NormalLaplace</span>.
</p>


<h3>Author(s)</h3>

<p>David Scott &lt;d.scott@auckland.ac.nz&gt;
</p>
<p>Maintainer: David Scott &lt;d.scott@auckland.ac.nz&gt;
</p>


<h3>References</h3>

<p>Scott, David J. and Würtz, Diethelm and Dong, Christine
(2009) Software for Distributions in R. UseR: The R User
Conference 2009
<a href="https://www.r-project.org/conferences/useR-2009/slides/Scott+Wuertz+Dong.pdf">https://www.r-project.org/conferences/useR-2009/slides/Scott+Wuertz+Dong.pdf</a>
</p>


<h3>See Also</h3>

<p><code><a href="GeneralizedHyperbolic.html#topic+GeneralizedHyperbolicDistribution">GeneralizedHyperbolicDistribution</a></code>
</p>

<hr>
<h2 id='Bessel+20K+20Ratio'>Ratio of Bessel K Functions</h2><span id='topic+besselRatio'></span>

<h3>Description</h3>

<p>Calculates the ratio of Bessel K functions of different orders, but
the same value of the argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>besselRatio(x, nu, orderDiff, useExpScaled = 700)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Bessel+2B20K+2B20Ratio_+3A_x">x</code></td>
<td>
<p>Numeric, <code class="reqn">\geq 0</code>. Value at which the numerator and
denominator Bessel functions are evaluated.</p>
</td></tr>
<tr><td><code id="Bessel+2B20K+2B20Ratio_+3A_nu">nu</code></td>
<td>
<p>Numeric. The order of the Bessel function in the
denominator.</p>
</td></tr>
<tr><td><code id="Bessel+2B20K+2B20Ratio_+3A_orderdiff">orderDiff</code></td>
<td>
<p>Numeric. The order of the numerator Bessel function
minus the order of the denominator Bessel function.</p>
</td></tr>
<tr><td><code id="Bessel+2B20K+2B20Ratio_+3A_useexpscaled">useExpScaled</code></td>
<td>
<p>Numeric, <code class="reqn">\geq 0</code>. The smallest value of
<code class="reqn">x</code> for which the ratio is calculated using the
exponentially-scaled Bessel function values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses the function <code><a href="base.html#topic+besselK">besselK</a></code> to calculate the ratio of two
modified Bessel function of the third kind whose orders are
different. The calculation of Bessel functions will underflow if the
value of <code class="reqn">x</code> is greater than around 740. To avoid underflow the
exponentially-scaled Bessel functions can be returned by
<code><a href="base.html#topic+besselK">besselK</a></code>. The ratio is actually unaffected by exponential
scaling since the scaling cancels across numerator and denominator.
</p>
<p>The Bessel function ratio is useful in calculating moments of the
generalized inverse Gaussian distribution, and hence also for the
moments of the hyperbolic and generalized hyperbolic distributions.
</p>


<h3>Value</h3>

<p>The ratio
</p>
<p style="text-align: center;"><code class="reqn">\frac{K_{\nu+k}(x)}{K_{\nu}(x)}</code>
</p>

<p>of two modified Bessel functions of the third kind whose orders differ
by <code class="reqn">k</code>.
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a></p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+besselK">besselK</a></code>, <code><a href="GeneralizedHyperbolic.html#topic+gigMom">gigMom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nus &lt;- c(0:5, 10, 20)
x &lt;- seq(1, 4, length.out = 11)
k &lt;- 3

raw &lt;- matrix(nrow = length(nus), ncol = length(x))
scaled &lt;- matrix(nrow = length(nus), ncol = length(x))
compare &lt;- matrix(nrow = length(nus), ncol = length(x))

for (i in 1:length(nus)){
    for (j in 1:length(x)) {
        raw[i,j] &lt;- besselRatio(x[j], nus[i],
                                orderDiff = k)
        scaled[i,j] &lt;- besselRatio(x[j], nus[i],
                                orderDiff = k, useExpScaled = 1)
        compare[i,j] &lt;- raw[i,j]/scaled[i,j]
    }
}
raw
scaled
compare

</code></pre>

<hr>
<h2 id='distCalcRange'>
Range of a Unimodal Distribution
</h2><span id='topic+distCalcRange'></span>

<h3>Description</h3>

<p>Given the parameters of a unimodal distribution and the root of
the density function name, this function determines the range outside
of which the density function is negligible, to a specified
tolerance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distCalcRange(densFn, param = NULL, tol = 10^(-5), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distCalcRange_+3A_densfn">densFn</code></td>
<td>
<p>Character. The name of the density function for which
range calculation is required.</p>
</td></tr>
<tr><td><code id="distCalcRange_+3A_tol">tol</code></td>
<td>
<p>Tolerance.</p>
</td></tr>
<tr><td><code id="distCalcRange_+3A_param">param</code></td>
<td>
<p>Numeric. A vector giving the parameter values for the
distribution specified by <code>densFn</code>. If no <code>param</code> values
are specified, then the default parameter values of each
distribution are used instead.</p>
</td></tr>
<tr><td><code id="distCalcRange_+3A_...">...</code></td>
<td>
<p>Passes arguments to <code><a href="stats.html#topic+uniroot">uniroot</a></code>.In
particular, the parameters of the distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The name of the unimodal density function must be supplied as the
characters of the root for that density (e.g. <code>norm</code>,
<code>ghyp</code>). The particular unimodal distribution being considered is
specified by the values of the parameters or of the
<code>param</code> vector.
</p>
<p>The function gives a range, outside of which
the density is less than the given tolerance. It is used in
determining break points for the separate sections over which
numerical integration is used to determine the distribution
function. The points are found by using <code><a href="stats.html#topic+uniroot">uniroot</a></code> on the
density function.
</p>


<h3>Value</h3>

<p>A two-component vector giving the lower and upper ends of the range.
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>,
Joyce Li <a href="mailto:xli053@aucklanduni.ac.nz">xli053@aucklanduni.ac.nz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qDist">qDist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>normRange &lt;- distCalcRange("norm", tol = 10^(-7), mean = 4, sd = 1)
normRange
tRange &lt;- distCalcRange("t", tol = 10^(-5), df = 4)
tRange
</code></pre>

<hr>
<h2 id='distIneqMassart'>
Massart Inequality for Distributions
</h2><span id='topic+distIneqMassart'></span>

<h3>Description</h3>

<p>This function implements a test of the random number generator and
distribution function based on an inequality due to Massart (1990).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distIneqMassart(densFn = "norm", n = 10000, probBound = 0.001, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distIneqMassart_+3A_densfn">densFn</code></td>
<td>
<p>Character. The root name of the distribution to be tested.</p>
</td></tr>
<tr><td><code id="distIneqMassart_+3A_n">n</code></td>
<td>
<p>Numeric. The size of the sample to be used.</p>
</td></tr>
<tr><td><code id="distIneqMassart_+3A_probbound">probBound</code></td>
<td>
<p>Numeric. The value of the bound on the right hand side of
the Massart inequality. See <b>Details</b>.</p>
</td></tr>
<tr><td><code id="distIneqMassart_+3A_...">...</code></td>
<td>
<p>Additional arguments to allow specification of the
parameters of the distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Massart (1990) gave a version of the Dvoretsky-Kiefer-Wolfowitz
inequality with the best possible constant:
</p>
<p style="text-align: center;"><code class="reqn">P\left(\sup_{x}|\hat F_n(x)-F(x)|&gt; t\right) \leq%
    2\exp(-2nt^2)</code>
</p>

<p>where <code class="reqn">\hat F_n</code> is the empirical distribution function for
a sample of <code class="reqn">n</code> independent and identically distributed random
variables with distribution function <code class="reqn">F</code>. This inequality is true
for all distribution functions, for all <code class="reqn">n</code> and <code class="reqn">t</code>.
</p>
<p>This test is used in base R to check the standard distribution
functions. The code may be found in the file <code>p-r-random.tests.R</code>
in the <code>tests</code> directory.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>sup</code></td>
<td>
<p>Numeric. The supremum of the absolute difference between
the empirical distribution and the true distribution function.</p>
</td></tr>
<tr><td><code>probBound</code></td>
<td>
<p>Numeric. The value of the bound on the right hand side of
the Massart inequality.</p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p>Numeric. The lower bound which the supremum of the absolute
difference between the empirical distribution and the true
distribution function must exceed.</p>
</td></tr>
<tr><td><code>pVal</code></td>
<td>
<p>Numeric. The probability that the absolute difference
between the empirical distribution and the true distribution function
exceeds <code>t</code>.</p>
</td></tr>
<tr><td><code>check</code></td>
<td>
<p>Logical. Indicates whether the inequality is satisfied
or not.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>,
Christine Yang Dong <a href="mailto:c.dong@auckland.ac.nz">c.dong@auckland.ac.nz</a>
</p>


<h3>References</h3>

<p>Massart P. (1990) The tight constant in the Dvoretsky-Kiefer-Wolfovitz
inequality. <em>Ann. Probab.</em>, <b>18</b>, 1269&ndash;1283.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Normal distribution is the default
distIneqMassart()
## Specify parameter values
distIneqMassart(mean = 1, sd = 2)
## Gamma distribution has no default value for shape
distIneqMassart("gamma", shape = 1)
</code></pre>

<hr>
<h2 id='distIneqMassartPlot'>
Massart Inequality Plot Function
</h2><span id='topic+distIneqMassartPlot'></span>

<h3>Description</h3>

<p>Creates a Massart inequality plot for testing the empirical
distribution and distribution function based on an inequality due to
Massart (1990).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distIneqMassartPlot(densFn = "norm", param = NULL,
                    nSamp = 50, n = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distIneqMassartPlot_+3A_densfn">densFn</code></td>
<td>
<p>Character. The root name of the distribution to be tested.</p>
</td></tr>
<tr><td><code id="distIneqMassartPlot_+3A_n">n</code></td>
<td>
<p>Numeric. The size of the sample to be used.</p>
</td></tr>
<tr><td><code id="distIneqMassartPlot_+3A_nsamp">nSamp</code></td>
<td>
<p>Numeric. The number of samples used to approximate the
LHS probability of the inequality.</p>
</td></tr>
<tr><td><code id="distIneqMassartPlot_+3A_param">param</code></td>
<td>
<p>Numeric. A vector giving the parameter values for the
distribution specified by <code>densFn</code>. If no <code>param</code> values
are specified, then the default parameter values of each
distribution are used instead.</p>
</td></tr>
<tr><td><code id="distIneqMassartPlot_+3A_...">...</code></td>
<td>
<p>Passes the parameters of the distribution other than
specified by <code>param</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Massart (1990) gave a version of the Dvoretsky-Kiefer-Wolfowitz
inequality with the best possible constant:
</p>
<p style="text-align: center;"><code class="reqn">P\left(\sup_{x}|\hat F_n(x)-F(x)|&gt; t\right) \leq%
    2\exp(-2nt^2)</code>
</p>

<p>where <code class="reqn">\hat F_n</code> is the empirical distribution function for
a sample of <code class="reqn">n</code> independent and identically distributed random
variables with distribution function <code class="reqn">F</code>. This inequality is true
for all distribution functions, for all <code class="reqn">n</code> and <code class="reqn">t</code>.
</p>
<p>The red curve in the plot shows the LHS probabilities and the black
curve gives the RHS bound. The red curve should lie below the black
curve in order that the empirical distribution represents a sample
from the theoretical distribution.
</p>


<h3>Value</h3>

<p>Returns <code>NULL</code> invisibly.
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>,
Xinxing Li <a href="mailto:xli053@aucklanduni.ac.nz">xli053@aucklanduni.ac.nz</a>
</p>


<h3>References</h3>

<p>Massart P. (1990) The tight constant in the Dvoretsky-Kiefer-Wolfovitz
inequality. <em>Ann. Probab.</em>, <b>18</b>, 1269&ndash;1283.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
### Not run because of timing requirements of CRAN
### The Massart Inequality plot for standard Normal Distribution
distIneqMassartPlot()

### The Massart Inequality plot for Gamma Distribution
distIneqMassartPlot("gamma", shape = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='distMode'>Mode of a Unimodal Distribution</h2><span id='topic+distMode'></span>

<h3>Description</h3>

<p>Function to calculate the mode of a unimodal distribution which is
specified by the root of the density function name and the
corresponding parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distMode(densFn, param = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distMode_+3A_densfn">densFn</code></td>
<td>
<p>Character. The name of the density function for which
the mode is required.</p>
</td></tr>
<tr><td><code id="distMode_+3A_param">param</code></td>
<td>
<p>Numeric. A vector giving the parameter values for the
distribution specified by <code>densFn</code>. If no <code>param</code> values
are specified, then the default parameter values of each
distribution are used instead.</p>
</td></tr>
<tr><td><code id="distMode_+3A_...">...</code></td>
<td>
<p>Passes arguments to <code><a href="stats.html#topic+optimize">optimize</a></code>. In
particular, the parameters of the distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The name of the unimodal density function must be supplied as the
characters of the root for that density (e.g. <code>norm</code>,
<code>ghyp</code>). The particular unimodal distribution being considered is
specified by the value of the argument <code>param</code>, or for base R
distributions by specification in the ... arguments.
</p>


<h3>Value</h3>

<p>The mode is found by a numerical optimization using
<code><a href="stats.html#topic+optimize">optimize</a></code>.
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>,
Joyce Li <a href="mailto:xli053@aucklanduni.ac.nz">xli053@aucklanduni.ac.nz</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+distStepSize">distStepSize</a></code>, <code><a href="#topic+qDist">qDist</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>normRange &lt;- distCalcRange("norm", tol = 10^(-7), mean = 4, sd = 1)
curve(dnorm(x, mean = 4, sd = 1), normRange[1], normRange[2])
abline(v = distMode("norm", mean = 4, sd = 1), col = "blue")
</code></pre>

<hr>
<h2 id='DistributionUtils-internal'>Internal Distribution Utilities Functions</h2><span id='topic+newIBFR'></span>

<h3>Description</h3>

<p>Internal functions for the package DistributionUtils
</p>


<h3>Details</h3>

<p>Functions which are either not intended to be called by the user or
are waiting to be documented.
</p>

<hr>
<h2 id='distStepSize'>
Step Size for Calculating the Range of a Unimodal Distribution
</h2><span id='topic+distStepSize'></span>

<h3>Description</h3>

<p>Given the parameters of a unimodal distribution and the root of
the density function name, this function determines the step size when
calculating the range of the specified unimodal distribution. The
parameterization used is the one for the corresponding density
function calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distStepSize(densFn, dist,
             param = NULL, side = c("right","left"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distStepSize_+3A_densfn">densFn</code></td>
<td>
<p>Character. The name of the density function for which
the step size needs to be calculated.</p>
</td></tr>
<tr><td><code id="distStepSize_+3A_dist">dist</code></td>
<td>
<p>Numeric. Current distance value, for skew hyperbolic
distribution only</p>
</td></tr>
<tr><td><code id="distStepSize_+3A_param">param</code></td>
<td>
<p>Numeric. A vector giving the parameter values for the
distribution specified by <code>densFn</code>. If no <code>param</code> values
are specified, then the default parameter values of each
distribution are used instead.</p>
</td></tr>
<tr><td><code id="distStepSize_+3A_side">side</code></td>
<td>
<p>Character. <code>"right"</code> for a step to the right,
<code>"left"</code> for a step to the right.</p>
</td></tr>
<tr><td><code id="distStepSize_+3A_...">...</code></td>
<td>
<p>Passes arguments in particular the parameters of the
distribution to random sample generation function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used for stepping to the right or the left to obtain
an enclosing interval so <code>uniroot</code> can be used to search. The
step size for the right tail is the absolute difference between the
median and upper quantile and for the left tail is the absolute
difference between the median and lower quantile. The skew hyperbolic
distribution however needs a special step size. When the tail is
declining exponentially the step is just a linear function of the
current distance from the mode. If the tail is declining only as a
power of <code class="reqn">x</code>, an exponential step is used.
</p>
<p><code>distStepSize</code> is for internal use and is not expected to be
called by users. It is documented here for completeness.
</p>


<h3>Value</h3>

<p>The size of the step.
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>,
Joyce Li <a href="mailto:xli053@aucklanduni.ac.nz">xli053@aucklanduni.ac.nz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distCalcRange">distCalcRange</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>normRange &lt;- distCalcRange("norm", tol = 10^(-7), mean = 4, sd = 1)
normRange
tRange &lt;- distCalcRange("t", tol = 10^(-5), df = 4)
tRange
</code></pre>

<hr>
<h2 id='incompleteBesselK'>The Incomplete Bessel K Function</h2><span id='topic+incompleteBesselK'></span><span id='topic+incompleteBesselKR'></span><span id='topic+SSFcoef'></span><span id='topic+combinatorial'></span><span id='topic+GDENOM'></span><span id='topic+GNUM'></span>

<h3>Description</h3>

<p>Calculates the incomplete Bessel K function using the algorithm and code
provided by Slavinsky and Safouhi (2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>incompleteBesselK (x, y, nu, tol = .Machine$double.eps^0.85, nmax = 120)
incompleteBesselKR(x, y, nu, tol = .Machine$double.eps^0.85, nmax = 120)
SSFcoef(nmax, nu)
combinatorial(nu)
GDENOM(n, x, y, nu, An, nmax, Cnp)
GNUM(n, x, y, nu, Am, An, nmax, Cnp, GM, GN)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="incompleteBesselK_+3A_x">x</code></td>
<td>
<p>Numeric. Value of the first argument of the incomplete Bessel K
function.</p>
</td></tr>
<tr><td><code id="incompleteBesselK_+3A_y">y</code></td>
<td>
<p>Numeric. Value of the  second argument of the incomplete Bessel K
function.</p>
</td></tr>
<tr><td><code id="incompleteBesselK_+3A_nu">nu</code></td>
<td>
<p>Numeric. The order of the incomplete Bessel K function.</p>
</td></tr>
<tr><td><code id="incompleteBesselK_+3A_tol">tol</code></td>
<td>
<p>Numeric. The tolerance for the difference between
successive approximations of the incomplete Bessel K function.</p>
</td></tr>
<tr><td><code id="incompleteBesselK_+3A_nmax">nmax</code></td>
<td>
<p>Integer. The maximum order allowed for the approximation
of the incomplete Bessel K function.</p>
</td></tr>
<tr><td><code id="incompleteBesselK_+3A_n">n</code></td>
<td>
<p>Integer. Current order of the approximation. Not required to be
specified by users.</p>
</td></tr>
<tr><td><code id="incompleteBesselK_+3A_an">An</code></td>
<td>
<p>Matrix of coefficients. Not required to be specified by
users.</p>
</td></tr>
<tr><td><code id="incompleteBesselK_+3A_am">Am</code></td>
<td>
<p>Matrix of coefficients. Not required to be specified by
users.</p>
</td></tr>
<tr><td><code id="incompleteBesselK_+3A_cnp">Cnp</code></td>
<td>
<p>Vector of elements of Pascal's triangle.  Not required to
be specified by users.</p>
</td></tr>
<tr><td><code id="incompleteBesselK_+3A_gn">GN</code></td>
<td>
<p>Vector of denominators used for approximation.  Not required
to be specified by users.</p>
</td></tr>
<tr><td><code id="incompleteBesselK_+3A_gm">GM</code></td>
<td>
<p>Vector of numerators used for approximation.  Not required
to be specified by users.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>incompleteBesselK</code> implements the algorithm
proposed by Slavinsky and Safouhi (2010) and uses code provided by
them.
</p>
<p>The incomplete Bessel K function is defined by
</p>
<p style="text-align: center;"><code class="reqn">K_\nu(x,y)=\int_1^\infty t^{-nu-1}\exp(-xt-y/t)\,dt</code>
</p>

<p>see Slavinsky and Safouhi (2010), or Harris (2008).
</p>
<p><code>incompleteBesselK</code> calls a Fortran routine to carry out the
calculations. <code>incompleteBesselKR()</code> is a pure R version of the
routine for computing the incomplete Bessel K function.
</p>
<p>The functions <code>SSFcoef</code>, <code>combinatorial</code>, <code>GDENOM</code>, and
<code>GNUM</code> are &ldquo;subroutines&rdquo;, i.e., auxiliary functions used in
<code>incompleteBesselKR()</code>.  They are not expected to be called by the
user.
</p>
<p>The approximation to the incomplete Bessel K function returned by
<code>incompleteBesselK</code> is highly accurate.  The default value of
<code>tol</code> is about 10^(-14) on a 32-bit computer.  It appears that
even higher accuracy is possible when <code>x &gt; y</code>.  Then the tolerance
can be taken as <code>.Machine$double.eps</code> and the number of correct
figures essentially coincides with the number of figures representable
in the machine being used.
</p>
<p><code>incompleteBesselKR</code> is very slow compared to the Fortran version
and is only included for those who wish to see the algorithm in <span class="rlang"><b>R</b></span>
rather than Fortran.
</p>


<h3>Value</h3>

<p><code>incompleteBesselK</code> and <code>incompleteBesselKR</code> both return an
approximation to the incomplete Bessel K function as defined above.
</p>


<h3>Note</h3>

<p>The problem of calculation of the incomplete Bessel K function is
equivalent to the problem of calculation of the cumulative
distribution function of the generalized inverse Gaussian
distribution. See <code><a href="GeneralizedHyperbolic.html#topic+dgig">Generalized
Inverse Gaussian</a>.</code>
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>, Thomas Tran, Richard
Slevinsky, Hassan Safouhi.
</p>


<h3>References</h3>

<p>Harris, Frank E. (2008)
Incomplete Bessel, generalized incomplete gamma, or leaky aquifer functions.
<em>J. Comp. Appl. Math.</em> <b>215</b>, 260&ndash;269.
</p>
<p>Slevinsky, Richard M., and Safouhi, Hassan (2009)
New formulae for higher order derivatives and applications.
<em>J. Comp. Appl. Math.</em> <b>233</b>, 405&ndash;419.
</p>
<p>Slevinsky, Richard M., and Safouhi, Hassan (2010)
A recursive algorithm for the G transformation and accurate
computation of incomplete Bessel functions.
<em>Applied Numerical Mathematics</em> <b>60</b>(12), 1411&ndash;1417.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+besselK">besselK</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Harris (2008) gives accurate values (16 figures) for
### x = 0.01, y = 4, and nu = 0:9
### nu = 0, Harris value is 2.22531 07612 66469
options(digits = 16)
incompleteBesselK(0.01, 4, 0)
### nu = 9, Harris value is 0.00324 67980 03149
incompleteBesselK(0.01, 4, 9)

### Other values given in Harris (2008)
### x = 4.95, y = 5.00, nu = 2
incompleteBesselK(4.95, 5, 2) ## 0.00001 22499 87981
### x = 10, y = 2, nu = 6
### Slevinsky and Safouhi (2010) suggest Harris (2008) value
### is incorrect, give value 0.00000 04150 01064 21228
incompleteBesselK(10, 2, 6)
### x = 3.1, y = 2.6, nu = 5
incompleteBesselK(3.1, 2.6, 5) ## 0.00052 85043 25244

### Check values when x &gt; y using numeric integration
(numIBF &lt;- sapply(0:9, incompleteBesselK, x = 4, y = 0.01))

besselFn &lt;- function(t, x, y, nu) {
  (t^(-nu - 1))*exp(-x*t - y/t)
}

(intIBF &lt;- sapply(0:9, integrate, f = besselFn, lower = 1, upper = Inf,
                 x = 4, y = 0.01))
intIBF &lt;- as.numeric(intIBF[1, ])
numIBF - intIBF
max(abs(numIBF - intIBF)) ## 1.256649992398273e-11

options(digits = 7)
</code></pre>

<hr>
<h2 id='integrateDens'>
Integrates a Density Function
</h2><span id='topic+integrateDens'></span>

<h3>Description</h3>

<p>Given a density function specified by the root of the density function
name, returns the integral over a specified range, usually the whole
real line. Used for checking that the integral over the whole real line
is 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integrateDens(densFn = "norm", lower = -Inf, upper = Inf,
              subdivisions = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="integrateDens_+3A_densfn">densFn</code></td>
<td>
<p>Character. The name of the density function to be
integrated.</p>
</td></tr>
<tr><td><code id="integrateDens_+3A_lower">lower</code></td>
<td>
<p>Numeric. The lower limit of the integration.
Defaulty is <code>-Inf</code>.</p>
</td></tr>
<tr><td><code id="integrateDens_+3A_upper">upper</code></td>
<td>
<p>Numeric. The upper limit of the integration.
Defaulty is <code>Inf</code>.</p>
</td></tr>
<tr><td><code id="integrateDens_+3A_subdivisions">subdivisions</code></td>
<td>
<p>Numeric. The number of subdivisions to be passed
to <code>integrate</code>.</p>
</td></tr>
<tr><td><code id="integrateDens_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>integrate</code>. In
particular, the parameters of the distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The name of the density function to be integrated must be supplied as
the characters of the root for that density (e.g. <code>norm</code>,
<code>gamma</code>). The density function specified is integrated
numerically over the range specified via a call to
<code><a href="stats.html#topic+integrate">integrate</a></code>. The parameters of the distribution can be
specified, otherwise the default parameters will be used.
</p>


<h3>Value</h3>

<p>A list of class <code>integrate</code> with components:
</p>
<table role = "presentation">
<tr><td><code>value</code></td>
<td>
<p>The final estimate of the integral.</p>
</td></tr>
<tr><td><code>abs.error</code></td>
<td>
<p>Estimate of the modulus of the absolute error.</p>
</td></tr>
<tr><td><code>subdivisions</code></td>
<td>
<p>The number of subintervals produced in the
subdivision process.</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p><code>OK</code> or a character string giving the
error message.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The matched call to the <code>integrate</code> function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+momIntegrated">momIntegrated</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>integrateDens("norm", mean = 1, sd = 1)
integrateDens("t", df = 4)
integrateDens("exp", rate = 2)
integrateDens("weibull", shape = 1)
</code></pre>

<hr>
<h2 id='inversionTests'>
Inversion Tests for Distributions
</h2><span id='topic+inversionTestpq'></span><span id='topic+inversionTestqp'></span>

<h3>Description</h3>

<p>Functions to check performance of distribution and quantile
functions. Applying the distribution function followed by the quantile
function to a set of numbers should reproduce the original set of
numbers. Likewise applying the quantile function followed by the
distribution function to numbers in the range (0,1) should produce the
original numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inversionTestpq(densFn = "norm", n = 10,
                intTol = .Machine$double.eps^0.25,
                uniTol = intTol, x = NULL, method = "spline", ...)
inversionTestqp(densFn = "norm",
                qs = c(0.001, 0.01, 0.025, 0.05, 0.1, 0.2, 0.4, 0.5,
                       0.6, 0.8, 0.9, 0.95, 0.975, 0.99, 0.999),
                uniTol = .Machine$double.eps^0.25,
                intTol = uniTol, method = "spline", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inversionTests_+3A_densfn">densFn</code></td>
<td>
<p>Character. The root name of the distribution to be tested.</p>
</td></tr>
<tr><td><code id="inversionTests_+3A_qs">qs</code></td>
<td>
<p>Numeric. Set of quantiles to which quantile function then
distribution function will be applied. See <b>Details</b>.</p>
</td></tr>
<tr><td><code id="inversionTests_+3A_n">n</code></td>
<td>
<p>Numeric. Number of values to be sampled from the
distribution. See <b>Details</b>.</p>
</td></tr>
<tr><td><code id="inversionTests_+3A_x">x</code></td>
<td>
<p>Numeric. Values at which the distribution function is to be
evaluated. If <code>NULL</code> values are drawn at random from the
distribution.</p>
</td></tr>
<tr><td><code id="inversionTests_+3A_inttol">intTol</code></td>
<td>
<p>Value of <code>rel.tol</code> and hence <code>abs.tol</code> in calls
to <code>integrate</code>. See <code><a href="stats.html#topic+integrate">integrate</a></code>.</p>
</td></tr>
<tr><td><code id="inversionTests_+3A_unitol">uniTol</code></td>
<td>
<p>Value of <code>tol</code> in calls to <code>uniroot</code>. See
<code><a href="stats.html#topic+uniroot">uniroot</a></code>.</p>
</td></tr>
<tr><td><code id="inversionTests_+3A_method">method</code></td>
<td>
<p>Character. If <code>"spline"</code> quantiles are found from a
spline approximation to the distribution function. If
<code>"integrate"</code>, the distribution function used is always obtained
by integration.</p>
</td></tr>
<tr><td><code id="inversionTests_+3A_...">...</code></td>
<td>
<p>Additional arguments to allow specification of the
parameters of the distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>inversionTestpq</code> takes a sample from the specified distribution
of size <code class="reqn">n</code> then applies the distribution function, followed by
the quantile function.
<code>inversionTestqp</code> applies the quantile function, followed by
the distribution function to the set of quantiles specified by
<code>qs</code>.
</p>
<p>In both cases the starting and ending values should be the same.
</p>
<p>These tests are used in base R to check the standard distribution
functions. The code may be found in the file <code>d-p-q-r.tests.R</code> in
the <code>tests</code> directory.
</p>


<h3>Value</h3>

<p><code>inversionTestpq</code> returns a list with components:
</p>
<table role = "presentation">
<tr><td><code>qpx</code></td>
<td>
<p>Numeric. The result of applying the distribution function
(&lsquo;<span class="file">p</span>&rsquo; function) then the quantile function (&lsquo;<span class="file">q</span>&rsquo; function) to
the randomly generated set of <code class="reqn">x</code> values.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>Numeric. The set of <code class="reqn">x</code> values generated by the &lsquo;<span class="file">r</span>&rsquo;
function.</p>
</td></tr>
<tr><td><code>diffs</code></td>
<td>
<p>Numeric. The differences <code>qpx</code> minus <code>x</code>.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>Numeric. Number of values sampled from the distribution.</p>
</td></tr>
</table>
<p><code>inversionTestqp</code> returns a list with components:
</p>
<table role = "presentation">
<tr><td><code>pqqs</code></td>
<td>
<p>Numeric. The result of applying the quantile function
(&lsquo;<span class="file">q</span>&rsquo; function) then the distribution function (&lsquo;<span class="file">p</span>&rsquo; function) to
the quantiles <code>qs</code>.</p>
</td></tr>
<tr><td><code>qs</code></td>
<td>
<p>Numeric. The set of quantiles.</p>
</td></tr>
<tr><td><code>diffs</code></td>
<td>
<p>Numeric. The differences <code>pqqs</code> minus <code>qs</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>,
Christine Yang Dong <a href="mailto:c.dong@auckland.ac.nz">c.dong@auckland.ac.nz</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Default distribution is normal
inversionTestpq()
inversionTestqp()
## Supply parameters
inversionTestpq(mean = 1, sd = 2)
inversionTestqp(mean = 1, sd = 2)
## Gamma distribution, must specify shape
inversionTestpq("gamma", shape = 1)
inversionTestqp("gamma", shape = 1)
</code></pre>

<hr>
<h2 id='is.wholenumber'>Is Object Numeric and Whole Numbers</h2><span id='topic+is.wholenumber'></span>

<h3>Description</h3>

<p>Checks whether an object is numeric and if so, are all the elements
whole numbers, to a given tolerance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.wholenumber(x, tolerance = .Machine$double.eps^0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.wholenumber_+3A_x">x</code></td>
<td>
<p>The object to be tested.</p>
</td></tr>
<tr><td><code id="is.wholenumber_+3A_tolerance">tolerance</code></td>
<td>
<p>Numeric <code class="reqn">\ge 0</code>. Absolute differences
greater than <code>tolerance</code> are treated as real differences.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The object <code>x</code> is first tested to see if it is numeric. If not
the function returns <code>'FALSE'</code>. Then if all the elements of
<code>x</code> are whole numbers to within the tolerance given by
<code>tolerance</code> the function returns <code>'TRUE'</code>. If not it returns
<code>'FALSE'</code>.
</p>


<h3>Value</h3>

<p>Either <code>'TRUE'</code> or <code>'FALSE'</code> depending on the result of the
test.
</p>


<h3>Author(s)</h3>

<p>David Scott  <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>.</p>


<h3>References</h3>

<p>Based on a post by Tony Plate &lt;tplate@acm.org&gt; on R-help.</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.wholenumber(-3:5)                           # TRUE
is.wholenumber(c(0,0.1,1.3,5))                 # FALSE
is.wholenumber(-3:5 + .Machine$double.eps)     # TRUE
is.wholenumber(-3:5 + .Machine$double.eps^0.5) # FALSE
is.wholenumber(c(2L,3L))                       # TRUE
is.wholenumber(c("2L","3L"))                   # FALSE
is.wholenumber(0i ^ (-3:3))                    # FALSE
is.wholenumber(matrix(1:6, nrow = 3))          # TRUE
is.wholenumber(list(-1:3,2:6))                 # FALSE
is.numeric(list(-1:3,2:6))                     # FALSE
is.wholenumber(unlist(list(-1:3,2:6)))         # TRUE
</code></pre>

<hr>
<h2 id='logHist'>Plot Log-Histogram</h2><span id='topic+logHist'></span>

<h3>Description</h3>

<p>Plots a log-histogram, as in for example Feiller, Flenley and Olbricht
(1992).
</p>
<p>The intended use of the log-histogram is to examine the fit of a
particular density to a set of data, as an alternative to a histogram
with a density curve. For this reason, only the log-density histogram
is implemented, and it is not possible to obtain a log-frequency
histogram.
</p>
<p>The log-histogram can be plotted with histogram-like dashed vertical
bars, or as points marking the tops of the log-histogram bars, or with
both bars and points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  logHist(x, breaks = "Sturges",
          include.lowest = TRUE, right = TRUE,
          main = paste("Log-Histogram of", xName),
          xlim = range(breaks), ylim = NULL, xlab = xName,
          ylab = "Log-density", nclass = NULL, htype = "b", ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logHist_+3A_x">x</code></td>
<td>
<p>A vector of values for which the log-histogram is desired.</p>
</td></tr>
<tr><td><code id="logHist_+3A_breaks">breaks</code></td>
<td>
<p>One of:
</p>

<ul>
<li><p> a vector giving the breakpoints between log-histogram cells;
</p>
</li>
<li><p> a single number giving the number of cells for the log-histogram;
</p>
</li>
<li><p> a character string naming an algorithm to compute the
number of cells (see <b>Details</b>);
</p>
</li>
<li><p> a function to compute the number of cells.
</p>
</li></ul>

<p>In the last three cases the number is a suggestion only.
</p>
</td></tr>
<tr><td><code id="logHist_+3A_include.lowest">include.lowest</code></td>
<td>
<p>Logical. If <code>TRUE</code>,
an &lsquo;x[i]&rsquo; equal to the &lsquo;breaks&rsquo; value will be included in the first
(or last, for <code>right = FALSE</code>) bar.</p>
</td></tr>
<tr><td><code id="logHist_+3A_right">right</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the log-histograms cells are
right-closed (left open) intervals.</p>
</td></tr>
<tr><td><code id="logHist_+3A_main">main</code>, <code id="logHist_+3A_xlab">xlab</code>, <code id="logHist_+3A_ylab">ylab</code></td>
<td>
<p>These arguments to <code>title</code> have useful
defaults here.</p>
</td></tr>
<tr><td><code id="logHist_+3A_xlim">xlim</code></td>
<td>
<p>Sensible default for the range of x values.</p>
</td></tr>
<tr><td><code id="logHist_+3A_ylim">ylim</code></td>
<td>
<p>Calculated by <code>logHist</code>, see <b>Details</b>.</p>
</td></tr>
<tr><td><code id="logHist_+3A_nclass">nclass</code></td>
<td>
<p>Numeric (integer).  For compatibility with <code>hist</code> only,
<code>nclass</code> is equivalent to <code>breaks</code> for a scalar or
character argument.</p>
</td></tr>
<tr><td><code id="logHist_+3A_htype">htype</code></td>
<td>
<p>Type of histogram. Possible types are:
</p>

<ul>
<li><p> '&quot;h&quot;' for a *h*istogram only;
</p>
</li>
<li><p> '&quot;p&quot;' for *p*oints marking the top of the histogram bars only;
</p>
</li>
<li><p> '&quot;b&quot;' for *b*oth.
</p>
</li></ul>

</td></tr>
<tr><td><code id="logHist_+3A_...">...</code></td>
<td>
<p>Further graphical parameters for calls
to <code>plot</code> and <code>points</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses <code><a href="graphics.html#topic+hist.default">hist.default</a></code> to determine the cells or classes and
calculate counts.
</p>
<p>To calculate <code>ylim</code> the following procedure is used. The upper
end of the range is given by the maximum value of the log-density,
plus 25% of the absolute value of the maximum. The lower end of the
range is given by the smallest (finite) value of the log-density, less
25% of the difference between the largest and smallest (finite) values
of the log-density.
</p>
<p>A log-histogram in the form used by Feiller, Flenley and Olbricht (1992)
is plotted. See also Barndorff-Nielsen (1977) for use of log-histograms.
</p>


<h3>Value</h3>

<p>Returns a list with components:
</p>
<table role = "presentation">
<tr><td><code>breaks</code></td>
<td>
<p>The <code class="reqn">n+1</code> cell boundaries (= <code>breaks</code> if that
was a vector).</p>
</td></tr>
<tr><td><code>counts</code></td>
<td>
<p><code class="reqn">n</code> integers; for each cell, the number of
<code>x[]</code> inside.</p>
</td></tr>
<tr><td><code>logDensity</code></td>
<td>
<p>Log of <code class="reqn">\hat f(x_i)</code>, which are estimated
density values.
</p>
<p>If <code>all(diff(breaks) == 1)</code>, estimated density values are the
relative frequencies <code>counts/n</code> and in general satisfy
<code class="reqn">\sum_i \hat f(x_i) (b_{i+1}-b_i) = 1</code>, where <code class="reqn">b_i</code> = <code>breaks[i]</code>.</p>
</td></tr>
<tr><td><code>mids</code></td>
<td>
<p>The <code class="reqn">n</code> cell midpoints.</p>
</td></tr>
<tr><td><code>xName</code></td>
<td>
<p>A character string with the actual <code>x</code> argument name.</p>
</td></tr>
<tr><td><code>heights</code></td>
<td>
<p>The location of the tops of the vertical segments used
in drawing the log-histogram.</p>
</td></tr>
<tr><td><code>ylim</code></td>
<td>
<p>The value of <code>ylim</code> calculated by <code>logHist</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>, Richard Trendall,
Thomas Tran
</p>


<h3>References</h3>

<p>Barndorff-Nielsen, O. (1977)
Exponentially decreasing distributions for the logarithm of particle size,
<em>Proc. Roy. Soc. Lond.</em>,
A<b>353</b>, 401&ndash;419.
</p>
<p>Barndorff-Nielsen, O. and Blæsild, P (1983).
Hyperbolic distributions.
In <em>Encyclopedia of Statistical Sciences</em>,
eds., Johnson, N. L., Kotz, S. and Read, C. B., Vol. 3,
pp. 700&ndash;707. New York: Wiley.
</p>
<p>Fieller, N. J., Flenley, E. C. and Olbricht, W. (1992)
Statistics of particle size data.
<em>Appl. Statist.</em>,
<b>41</b>, 127&ndash;146.
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+hist">hist</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(200)
hist(x)
### default
logHist(x)
### log histogram only
logHist(x, htype = "h")
### points only, some options
logHist(x, htype = "p", pch = 20, cex = 2, col = "steelblue")
</code></pre>

<hr>
<h2 id='momChangeAbout'>Obtain Moments About a New Location</h2><span id='topic+momChangeAbout'></span>

<h3>Description</h3>

<p>Using the moments up to a given order about one location, this function
either returns the moments up to that given order about a new location as a 
vector or it returns a moment of a specific order defined by users 
(order &lt;= maximum order of the given moments) about a new location as a single
number. 
A generalization of using raw moments to obtain a central moment or using 
central moments to obtain a raw moment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  momChangeAbout(order = "all", oldMom, oldAbout, newAbout)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="momChangeAbout_+3A_order">order</code></td>
<td>
<p>One of:
</p>

<ul>
<li><p> the character string &quot;all&quot;, the default;
</p>
</li>
<li><p> a positive integer less than the maximum order of <code>oldMom</code>.
</p>
</li></ul>

</td></tr>
<tr><td><code id="momChangeAbout_+3A_oldmom">oldMom</code></td>
<td>
<p>Numeric. Moments of orders 1, 2, ..., about the point 
<code>oldAbout</code>.</p>
</td></tr>
<tr><td><code id="momChangeAbout_+3A_oldabout">oldAbout</code></td>
<td>
<p>Numeric. The point about which the moments <code>oldMom</code> have
been calculated.</p>
</td></tr>
<tr><td><code id="momChangeAbout_+3A_newabout">newAbout</code></td>
<td>
<p>Numeric. The point about which the desired moment or
moments are to be
obtained.</p>
</td></tr>
</table>


<h3>Details</h3>

  
<p>Suppose <code class="reqn">m_k</code> denotes the <code class="reqn">k</code>-th moment of a random
variable <code class="reqn">X</code> about a point <code class="reqn">a</code>, and <code class="reqn">m_k^*</code>
denotes the <code class="reqn">k</code>-th moment about <code class="reqn">b</code>. Then
<code class="reqn">m_k^*</code> may be determined from the moments
<code class="reqn">m_1,m_2,\dots,m_k</code> according to the formula
</p>
<p style="text-align: center;"><code class="reqn">m_k^*=\sum_{i=0}^k (a-b)^i m^{k-i}</code>
</p>

<p>This is the formula implemented by the function
<code>momChangeAbout</code>. It is a generalization of the well-known
formulae used to change raw moments to central moments or to change
central moments to raw moments. See for example Kendall and Stuart
(1989), Chapter 3.
</p>


<h3>Value</h3>

<p>The moment of order <code>order</code> about the location <code>newAbout</code> when 
<code>order</code> is specified.
The vector of moments about the location <code>newAbout</code> from first
order up to the maximum order of the <code>oldMom</code> when <code>order</code>
takes the value <code>"all"</code> or is not specified. 
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>, 
Christine Yang Dong <a href="mailto:c.dong@auckland.ac.nz">c.dong@auckland.ac.nz</a></p>


<h3>References</h3>

<p>Kendall, M. G. and Stuart, A. (1969).
<em>The Advanced Theory of Statistics, Volume 1, 3rd Edition</em>.
London: Charles Griffin &amp; Company.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Gamma distribution
k &lt;- 4
shape &lt;- 2
old &lt;- 0
new &lt;- 1
sampSize &lt;- 1000000

### Calculate 1st to 4th raw moments 
m &lt;- numeric(k)
for (i in 1:k){
   m[i] &lt;- gamma(shape + i)/gamma(shape)
}
m

### Calculate 4th moment about new 
momChangeAbout(k, m, old, new)
### Calculate 3rd about new
momChangeAbout(3, m, old, new)

### Calculate 1st to 4th moments about new
momChangeAbout(oldMom = m, oldAbout = old, newAbout = new)
momChangeAbout(order = "all", m, old, new)
  
### Approximate kth moment about new using sampling
x &lt;- rgamma(sampSize, shape)
mean((x - new)^k) 
</code></pre>

<hr>
<h2 id='momIntegrated'>Moments Using Integration</h2><span id='topic+momIntegrated'></span>

<h3>Description</h3>

<p>Calculates moments and absolute moments about a given location for any
given distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>momIntegrated(densFn = "ghyp", param = NULL, order, about = 0,
              absolute = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="momIntegrated_+3A_densfn">densFn</code></td>
<td>
<p>Character. The name of the density function whose
moments are to be calculated. See <b>Details</b>.</p>
</td></tr>
<tr><td><code id="momIntegrated_+3A_param">param</code></td>
<td>
<p>Numeric. A vector giving the parameter values for the
distribution specified by <code>densFn</code>. If no <code>param</code> values
are specified, then the default parameter values of the
distribution are used instead.</p>
</td></tr>  
<tr><td><code id="momIntegrated_+3A_order">order</code></td>
<td>
<p>Numeric. The order of the moment or absolute moment to be
calculated.</p>
</td></tr>
<tr><td><code id="momIntegrated_+3A_about">about</code></td>
<td>
<p>Numeric. The point about which the moment is to be calculated.</p>
</td></tr>
<tr><td><code id="momIntegrated_+3A_absolute">absolute</code></td>
<td>
<p>Logical. Whether absolute moments or ordinary moments
are to be calculated. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="momIntegrated_+3A_...">...</code></td>
<td>
<p>Passes arguments to <code><a href="stats.html#topic+integrate">integrate</a></code>. In
particular, the parameters of the distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Denote the density function by <code class="reqn">f</code>. Then if
<code>order</code><code class="reqn">=k</code> and <code>about</code><code class="reqn">=a</code>,
<code>momIntegrated</code> calculates
</p>
<p style="text-align: center;"><code class="reqn">\int_{-\infty}^\infty (x - a)^k f(x) dx</code>
</p>

<p>when <code>absolute = FALSE</code> and
</p>
<p style="text-align: center;"><code class="reqn">\int_{-\infty}^\infty |x - a|^k f(x) dx</code>
</p>

<p>when <code>absolute = TRUE</code>.
</p>
<p>The name of the density function must be supplied as the characters of
the root for that density (e.g. <code>norm</code>, <code>ghyp</code>).
</p>
<p>When <code>densFn="ghyp"</code>,  <code>densFn="hyperb"</code>,
<code>densFn="gig"</code> or <code>densFn = "vg"</code>, the relevant package must
be loaded or an error will result.
</p>
<p>When <code>densFn="invgamma"</code> or <code>"inverse gamma"</code> the
density used is the density of the inverse gamma distribution given by
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \frac{u^\alpha e^{-u}}{x \Gamma(\alpha)}, %
    \quad u = \theta/x</code>
</p>

<p>for <code class="reqn">x &gt; 0</code>, <code class="reqn">\alpha &gt; 0</code> and
<code class="reqn">\theta &gt; 0</code>.  The parameter vector
<code>param = c(shape, rate)</code> where <code>shape</code> <code class="reqn">=\alpha</code> and
<code>rate</code><code class="reqn">=1/\theta</code>. The default value for
<code>param</code> is <code>c(-1, 1)</code>.
</p>


<h3>Value</h3>

<p>The value of the integral as specified in <b>Details</b>.
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>,
Christine Yang Dong <a href="mailto:c.dong@auckland.ac.nz">c.dong@auckland.ac.nz</a>,
Xinxing Li <a href="mailto:xli053@aucklanduni.ac.nz">xli053@aucklanduni.ac.nz</a></p>


<h3>See Also</h3>

<p><code><a href="GeneralizedHyperbolic.html#topic+dghyp">dghyp</a></code>,
<code><a href="GeneralizedHyperbolic.html#topic+dhyperb">dhyperb</a></code>, <code><a href="stats.html#topic+dgamma">dgamma</a></code>,
<code><a href="GeneralizedHyperbolic.html#topic+dgig">dgig</a></code>,
<code><a href="VarianceGamma.html#topic+VarianceGamma">VarianceGamma</a>
  </code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(GeneralizedHyperbolic)
### Calculate the mean of a generalized hyperbolic distribution
### Compare the use of integration and the formula for the mean
m1 &lt;- momIntegrated("ghyp", param = c(0, 1, 3, 1, 1 / 2), order = 1, about = 0)
m1
ghypMean(param = c(0, 1, 3, 1, 1 / 2))
### The first moment about the mean should be zero
momIntegrated("ghyp", order = 1, param = c(0, 1, 3, 1, 1 / 2), about = m1)
### The variance can be calculated from the raw moments
m2 &lt;- momIntegrated("ghyp", order = 2, param = c(0, 1, 3, 1, 1 / 2), about = 0)
m2
m2 - m1^2
### Compare with direct calculation using integration
momIntegrated("ghyp", order = 2, param = c(0, 1, 3, 1, 1 / 2), about = m1)
momIntegrated("ghyp", param = c(0, 1, 3, 1, 1 / 2), order = 2,
              about = m1)
### Compare with use of the formula for the variance
ghypVar(param = c(0, 1, 3, 1, 1 / 2))
</code></pre>

<hr>
<h2 id='momSE'>
Standard Errors of Sample Moments
</h2><span id='topic+momSE'></span>

<h3>Description</h3>

<p>Calculates the approximate standard error of the sample variance,
sample central third moment and sample central fourth moment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>momSE(order = 4, n, mom)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="momSE_+3A_order">order</code></td>
<td>
<p>Integer: either 2, 3, or 4.</p>
</td></tr>
<tr><td><code id="momSE_+3A_n">n</code></td>
<td>
<p>Integer: the sample size.</p>
</td></tr>
<tr><td><code id="momSE_+3A_mom">mom</code></td>
<td>
<p>Numeric: The central moments of order 1 to <code class="reqn">2n</code> of the
distribution being sampled from.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implements the approximate standard error given in Kendall and Stuart
(1969), p.243.
</p>


<h3>Value</h3>

<p>The approximate standard error of the sample moment specified.
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>
</p>


<h3>References</h3>

<p>Kendall, M. G. and Stuart, A. (1969).
<em>The Advanced Theory of Statistics, Volume 1, 3rd Edition</em>.
London: Charles Griffin &amp; Company.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+momChangeAbout">momChangeAbout</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Moments of the normal distribution, mean 1, variance 4
mu &lt;- 1
sigma &lt;- 2
mom &lt;- c(0,sigma^2,0,3*sigma^4,0,15*sigma^6,0,105*sigma^8)
### standard error of sample variance
momSE(2, 100, mom[1:4])
### should be
sqrt(2*sigma^4)/10
### standard error of sample central third moment
momSE(3, 100, mom[1:6])
### should be
sqrt(6*sigma^6)/10
### standard error of sample central fourth moment
momSE(4, 100, mom)
### should be
sqrt(96*sigma^8)/10
</code></pre>

<hr>
<h2 id='moranTest'>
Moran's Log Spacings Test
</h2><span id='topic+moranTest'></span>

<h3>Description</h3>

<p>This function implements a goodness-of-fit test using Moran's log
spacings statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moranTest(x, densFn, param = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="moranTest_+3A_densfn">densFn</code></td>
<td>
<p>Character. The root name of the distribution to be tested.</p>
</td></tr>
<tr><td><code id="moranTest_+3A_x">x</code></td>
<td>
<p>Numeric. Vector of data to be tested.</p>
</td></tr>
<tr><td><code id="moranTest_+3A_param">param</code></td>
<td>
<p>Numeric. A vector giving the parameter values for the
distribution specified by <code>densFn</code>. If no <code>param</code> values
are specified, then the default parameter values of the
distribution are used instead.</p>
</td></tr>
<tr><td><code id="moranTest_+3A_...">...</code></td>
<td>
<p>Additional arguments to allow specification of the
parameters of the distribution other than specified by <code>param</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Moran(1951) gave a statistic for testing the goodness-of-fit of a
random sample of <code class="reqn">x</code>-values to a continuous univariate
distribution with cumulative distribution function
<code class="reqn">F(x,\theta)</code>, where <code class="reqn">\theta</code> is a vector of known
parameters. This function implements the Cheng and Stephens(1989)
extended Moran test for unknown parameters.
</p>
<p>The test statistic is
</p>
<p style="text-align: center;"><code class="reqn">T(\hat \theta)=(M(\hat
    \theta)+1/2k-C_1)/C_2</code>
</p>

<p>Where <code class="reqn">M(\hat \theta)</code>, the Moran statistic, is
</p>
<p style="text-align: center;"><code class="reqn">M(\theta)=-(log(y_1-y_0)+log(y_2-y_1)+...+log(y_m-y_{m-1}))</code>
</p>

<p>M(theta)=-(log(y_1-y_0)+log(y_2-y_1)+...+log(y_m-y_m-1))
</p>
<p>This test has null hypothesis:
<code class="reqn">H_0</code> : a random sample of <code class="reqn">n</code> values of <code class="reqn">x</code> comes
from distribution <code class="reqn">F(x, \theta)</code>, where
<code class="reqn">\theta</code> is the vector of parameters.
Here <code class="reqn">\theta</code> is expected to be the maximum
likelihood estimate <code class="reqn">\hat \theta</code>, an efficient
estimate. The test rejects <code class="reqn">H_0</code> at significance level
<code class="reqn">\alpha</code> if <code class="reqn">T(\hat \theta)</code> &gt;
<code class="reqn">\chi^2_n(\alpha)</code>.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>Numeric. The value of the Moran test statistic.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Numeric. A vector of parameter estimates for the tested
distribution.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>Numeric. The degrees of freedom for the Moran statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>Numeric. The p-value for the test</p>
</td></tr></table>
<p>.
</p>
<table role = "presentation">
<tr><td><code>data.name</code></td>
<td>
<p>Character. A character string giving the name(s) of the
data.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>Character. Type of test performed.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>,
Xinxing Li <a href="mailto:xli053@aucklanduni.ac.nz">xli053@aucklanduni.ac.nz</a>
</p>


<h3>References</h3>

<p>Cheng, R. C. &amp; Stephens, M. A. (1989). A goodness-of-fit test using
Moran's statistic with estimated parameters. <em>Biometrika</em>,
<b>76</b>, 385&ndash;92.
</p>
<p>Moran, P. (1951). The random division of an interval&mdash;PartII.
<em>J. Roy. Statist. Soc. B</em>, <b>13</b>, 147&ndash;50.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Normal Distribution
x &lt;- rnorm(100, mean = 0, sd = 1)
muhat &lt;- mean(x)
sigmahat &lt;- sqrt(var(x)*(100 - 1)/100)
result &lt;- moranTest(x, "norm", mean = muhat, sd = sigmahat)
result

### Exponential Distribution
y &lt;- rexp(200, rate = 3)
lambdahat &lt;- 1/mean(y)
result &lt;- moranTest(y, "exp", rate = lambdahat)
result
</code></pre>

<hr>
<h2 id='pDist'>
Distribution and Quantile Functions for Unimodal Distributions
</h2><span id='topic+pDist'></span><span id='topic+qDist'></span>

<h3>Description</h3>

<p>Given the density function of a unimodal distribution specified by the root
of the density function name, returns the distribution function and
quantile function of the specified distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pDist(densFn = "norm", q, param = NULL, subdivisions = 100,
      lower.tail = TRUE, intTol = .Machine$double.eps^0.25,
      valueOnly = TRUE, ...)
qDist(densFn = "norm", p, param = NULL,
      lower.tail = TRUE, method = "spline", nInterpol = 501,
      uniTol = .Machine$double.eps^0.25,
      subdivisions = 100, intTol = uniTol, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pDist_+3A_densfn">densFn</code></td>
<td>
<p>Character. The name of the density function for which the
distribution function or quantile function is required.</p>
</td></tr>
<tr><td><code id="pDist_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="pDist_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="pDist_+3A_param">param</code></td>
<td>
<p>Numeric. A vector giving the parameter values for the
distribution specified by <code>densFn</code>. If no <code>param</code> values
are specified, then the default parameter values of each
distribution are used instead.</p>
</td></tr>
<tr><td><code id="pDist_+3A_method">method</code></td>
<td>
<p>Character. If <code>"spline"</code> quantiles are found from a
spline approximation to the distribution function. If
<code>"integrate"</code>, the distribution function used is always obtained
by integration.</p>
</td></tr>
<tr><td><code id="pDist_+3A_lower.tail">lower.tail</code></td>
<td>
<p>Logical. If <code>lower.tail = TRUE</code>, the cumulative
density is taken from the lower tail.</p>
</td></tr>
<tr><td><code id="pDist_+3A_subdivisions">subdivisions</code></td>
<td>
<p>The maximum number of subdivisions used to integrate
the density and determine the accuracy of the distribution function
calculation.</p>
</td></tr>
<tr><td><code id="pDist_+3A_inttol">intTol</code></td>
<td>
<p>Value of <code>rel.tol</code> and hence <code>abs.tol</code> in calls
to <code>integrate</code>. See <code><a href="stats.html#topic+integrate">integrate</a></code>.</p>
</td></tr>
<tr><td><code id="pDist_+3A_valueonly">valueOnly</code></td>
<td>
<p>Logical. If <code>valueOnly = TRUE</code> calls to
<code>pDist</code> only return the value obtained for the integral. If
<code>valueOnly = FALSE</code> an estimate of the accuracy of the numerical
integration is also returned.</p>
</td></tr>
<tr><td><code id="pDist_+3A_ninterpol">nInterpol</code></td>
<td>
<p>Number of points used in <code>qDist</code> for cubic spline
interpolation of the distribution function.</p>
</td></tr>
<tr><td><code id="pDist_+3A_unitol">uniTol</code></td>
<td>
<p>Value of <code>tol</code> in calls to <code>uniroot</code>. See
<code><a href="stats.html#topic+uniroot">uniroot</a></code>.</p>
</td></tr>
<tr><td><code id="pDist_+3A_...">...</code></td>
<td>
<p>Passes additional arguments to <code><a href="stats.html#topic+integrate">integrate</a></code>,
<code><a href="#topic+distMode">distMode</a></code> or <code><a href="#topic+distCalcRange">distCalcRange</a></code>. In particular,
the parameters of the distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The name of the unimodal density function must be supplied as the
characters of the root for that density (e.g. <code>norm</code>, <code>ghyp</code>).
</p>
<p><code>pDist</code> uses the function <code><a href="stats.html#topic+integrate">integrate</a></code> to numerically
integrate the density function specified. The integration is from
<code>-Inf</code> to <code>x</code> if <code>x</code> is to the left of the mode, and from
<code>x</code> to <code>Inf</code> if <code>x</code> is to the right of the mode. The
probability calculated this way is subtracted from 1 if
required. Integration in this manner appears to make calculation of the
quantile function more stable in extreme cases.
</p>
<p><code>qDist</code> provides two methods to calculate quantiles both of which
use <code>uniroot</code> to find the value of <code class="reqn">x</code> for which a given
<code class="reqn">q</code> is equal to <code class="reqn">F(x)</code> where <code class="reqn">F(.)</code> denotes the distribution
function. The difference is in how the numerical approximation to
<code class="reqn">F</code> is obtained. The more accurate method, which is specified as
<code>"integrate"</code>, is to calculate the value of <code class="reqn">F(x)</code> whenever it
is required using a call to <code>pDist</code>. It is clear that the time
required for this approach is roughly linear in the number of quantiles
being calculated. The alternative (and default) method is that for the
major part of the distribution a spline approximation to <code class="reqn">F(x)</code> is
calculated and quantiles found using <code>uniroot</code> with this
approximation. For extreme values of some heavy-tailed distributions
(where the tail probability is less than <code class="reqn">10^(-7)</code>), the
integration method is still used even when the method specified as
<code>"spline"</code>.
</p>
<p>If accurate probabilities or quantiles are required, tolerances
(<code>intTol</code> and <code>uniTol</code>) should be set to small values, i.e
<code class="reqn">10^{-10}</code> or <code class="reqn">10^{-12}</code> with
<code>method = "integrate"</code>. Generally then accuracy might be expected
to be at least <code class="reqn">10^{-9}</code>. If the default values of the
functions are used, accuracy can only be expected to be around
<code class="reqn">10^{-4}</code>. Note that on 32-bit systems
<code>.Machine$double.eps^0.25 = 0.0001220703</code> is a typical value.
</p>


<h3>Value</h3>

<p><code>pDist</code> gives the distribution function, <code>qDist</code> gives the
quantile function.
</p>
<p>An estimate of the accuracy of the approximation to the distribution
function can be found by setting <code>valueOnly = FALSE</code> in the call to
<code>pDist</code> which returns a list with components <code>value</code> and
<code>error</code>.
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>
Joyce Li <a href="mailto:xli053@aucklanduni.ac.nz">xli053@aucklanduni.ac.nz</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>pDist("norm", q = 2, mean = 1, sd = 1)
pDist("t", q = 0.5, df = 4)
require(GeneralizedHyperbolic)
pDist("ghyp", q = 0.1)
require(SkewHyperbolic)
qDist("skewhyp", p = 0.4, param = c(0, 1, 0, 10))
qDist("t", p = 0.2, df = 4)
</code></pre>

<hr>
<h2 id='safeIntegrate'>Safe Integration of One-Dimensional Functions</h2><span id='topic+safeIntegrate'></span><span id='topic+print.integrate'></span>

<h3>Description</h3>

<p>Adaptive quadrature of functions of one variable over a finite or
infinite interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>safeIntegrate(f, lower, upper, subdivisions=100,
              rel.tol = .Machine$double.eps^0.25, abs.tol = rel.tol,
              stop.on.error = TRUE, keep.xy = FALSE, aux = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="safeIntegrate_+3A_f">f</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> function taking a numeric first argument and returning
a numeric vector of the same length.  Returning a non-finite element will
generate an error.</p>
</td></tr>
<tr><td><code id="safeIntegrate_+3A_lower">lower</code>, <code id="safeIntegrate_+3A_upper">upper</code></td>
<td>
<p>The limits of integration.  Can be infinite.</p>
</td></tr>
<tr><td><code id="safeIntegrate_+3A_subdivisions">subdivisions</code></td>
<td>
<p>The maximum number of subintervals.</p>
</td></tr>
<tr><td><code id="safeIntegrate_+3A_rel.tol">rel.tol</code></td>
<td>
<p>Relative accuracy requested.</p>
</td></tr>
<tr><td><code id="safeIntegrate_+3A_abs.tol">abs.tol</code></td>
<td>
<p>Absolute accuracy requested.</p>
</td></tr>
<tr><td><code id="safeIntegrate_+3A_stop.on.error">stop.on.error</code></td>
<td>
<p>Logical. If true (the default) an error stops the
function.  If false some errors will give a result with a warning in
the <code>message</code> component.</p>
</td></tr>
<tr><td><code id="safeIntegrate_+3A_keep.xy">keep.xy</code></td>
<td>
<p>Unused.  For compatibility with S.</p>
</td></tr>
<tr><td><code id="safeIntegrate_+3A_aux">aux</code></td>
<td>
<p>Unused.  For compatibility with S.</p>
</td></tr>
<tr><td><code id="safeIntegrate_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code>f</code>.  Remember
to use argument names <em>not</em> matching those of
<code>safeIntegrate(.)</code>!</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is just a wrapper around
<code><a href="stats.html#topic+integrate">integrate</a></code> to check for equality of
<code>upper</code> and <code>lower</code>. A check is made using
<code><a href="base.html#topic+all.equal">all.equal</a></code>. When numerical equality is
detected, if <code>lower</code> (and hence <code>upper</code>) is infinite, the
value of the integral and the absolute error are both set to 0. When
<code>lower</code> is finite, the value of the integral is set to 0, and the
absolute error to the average of the function values at <code>upper</code> and
<code>lower</code> times the difference between <code>upper</code> and <code>lower</code>.
</p>
<p>When <code>upper</code> and <code>lower</code> are determined to be different, the
result is exactly as given by  <code><a href="stats.html#topic+integrate">integrate</a></code>.
</p>


<h3>Value</h3>

<p>A list of class <code>"integrate"</code> with components:
</p>
<table role = "presentation">
<tr><td><code>value</code></td>
<td>
<p>The final estimate of the integral.</p>
</td></tr>
<tr><td><code>abs.error</code></td>
<td>
<p>Estimate of the modulus of the absolute error.</p>
</td></tr>
<tr><td><code>subdivisions</code></td>
<td>
<p>The number of subintervals produced in the
subdivision process.</p>
</td></tr>
<tr><td><code>message</code></td>
<td>
<p><code>"OK"</code> or a character string giving the error message.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The matched call.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>The function <code><a href="stats.html#topic+integrate">integrate</a></code> and
<code><a href="base.html#topic+all.equal">all.equal</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>integrate(dnorm, -1.96, 1.96)
safeIntegrate(dnorm, -1.96, 1.96)  # Same as for integrate()
integrate(dnorm, -Inf, Inf)
safeIntegrate(dnorm, -Inf, Inf)    # Same as for integrate()
integrate(dnorm, 1.96, 1.96)       # OK here but can give an error
safeIntegrate(dnorm, 1.96, 1.96)
integrate(dnorm, -Inf, -Inf)
safeIntegrate(dnorm, -Inf, -Inf)   # Avoids nonsense answer
integrate(dnorm, Inf, Inf)
safeIntegrate(dnorm, Inf, Inf)     # Avoids nonsense answer
</code></pre>

<hr>
<h2 id='Sample+20Moments'>Sample Skewness and Kurtosis</h2><span id='topic+skewness'></span><span id='topic+kurtosis'></span>

<h3>Description</h3>

<p>Computes the sample skewness and sample kurtosis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skewness(x, na.rm = FALSE)
kurtosis(x, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Sample+2B20Moments_+3A_x">x</code></td>
<td>
<p>A numeric vector containing the values whose skewness  or
kurtosis is to be computed.</p>
</td></tr>
<tr><td><code id="Sample+2B20Moments_+3A_na.rm">na.rm</code></td>
<td>
<p>A logical value indicating whether <code>NA</code> values
should be stripped before the computation proceeds.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code class="reqn">N = \mathrm{length}(x)</code>, then the skewness of
<code class="reqn">x</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">N^{-1} \mathrm{sd}(x)^{-3} \sum_i (x_i - \mathrm{mean}(x))^3.</code>
</p>

<p>If <code class="reqn">N = \mathrm{length}(x)</code>, then the kurtosis of
<code class="reqn">x</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">N^{-1} \mathrm{sd}(x)^{-4}%
    \sum_i(x_i - \mathrm{mean}(x))^4 - 3.</code>
</p>



<h3>Value</h3>

<p>The skewness or kurtosis of <code>x</code>.
</p>


<h3>Note</h3>

<p>These functions and the description of them are taken from the
package <span class="pkg">e1071</span>. They are included to avoid having to require an
additional package.</p>


<h3>Author(s)</h3>

<p>Evgenia Dimitriadou, Kurt Hornik, Friedrich Leisch, David Meyer,
and Andreas Weingessel</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100)
skewness(x)
kurtosis(x)
</code></pre>

<hr>
<h2 id='tailPlot'>
Tail Plot Functions
</h2><span id='topic+tailPlot'></span><span id='topic+tailPlotLine'></span><span id='topic+normTailPlotLine'></span><span id='topic+tTailPlotLine'></span><span id='topic+gammaTailPlotLine'></span>

<h3>Description</h3>

<p>Create a left or right tail plot of a data set using
<code>tailPlot</code>. Add a line for any distribution with parameters given
by an argument named <code>param</code>, using <code>tailPlotLine</code>.
Add normal, <code class="reqn">t</code>, or gamma distribution lines to
the plot using <code>normTailPlotLine</code>, <code>tTailPlotLine</code>, or
<code>gammaTailPlotLine</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tailPlot(x, log = "y", side = c("right", "left"), main = NULL,
         xlab = NULL, ylab = NULL, ...)
tailPlotLine(x, distrFn, param = NULL, side = c("right", "left"), ...)
normTailPlotLine(x, mean = 0, sd = 1, side = c("right", "left"), ...)
tTailPlotLine(x, df = Inf, side = c("right", "left"), ...)
gammaTailPlotLine(x, shape = 1, rate = 1, scale = 1/rate,
                  side = c("right", "left"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tailPlot_+3A_x">x</code></td>
<td>
<p>A vector of values for which the tail plot is to be drawn.</p>
</td></tr>
<tr><td><code id="tailPlot_+3A_log">log</code></td>
<td>
<p>A character string which contains <code>"x"</code> if the x-axis
is to be logarithmic, <code>"y"</code> if the y-axis is to be logarithmic
and <code>"xy"</code> or <code>"yx"</code> if both axes are to be logarithmic.</p>
</td></tr>
<tr><td><code id="tailPlot_+3A_side">side</code></td>
<td>
<p>Character. <code>"right"</code> (the default) for a tail plot of
the right-hand tail, <code>"left"</code> for a tail plot of
the left-hand tail.</p>
</td></tr>
<tr><td><code id="tailPlot_+3A_main">main</code></td>
<td>
<p>A main title for the plot.</p>
</td></tr>
<tr><td><code id="tailPlot_+3A_xlab">xlab</code></td>
<td>
<p>A label for the x axis, defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="tailPlot_+3A_ylab">ylab</code></td>
<td>
<p>A label for the y axis, defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="tailPlot_+3A_distrfn">distrFn</code></td>
<td>
<p>Character. The name of the distribution function to be
to be added to the tail plot.</p>
</td></tr>
<tr><td><code id="tailPlot_+3A_param">param</code></td>
<td>
<p>Vector specifying the parameters of the distribution,
defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="tailPlot_+3A_mean">mean</code></td>
<td>
<p>The mean of the normal distribution.</p>
</td></tr>
<tr><td><code id="tailPlot_+3A_sd">sd</code></td>
<td>
<p>The standard deviation of the normal distribution. Must be
positive.</p>
</td></tr>
<tr><td><code id="tailPlot_+3A_df">df</code></td>
<td>
<p>The degrees of freedom of the <code class="reqn">t</code>-distribution, (<code class="reqn">&gt;
      0</code>, may be non-integer). Defaults to <code>Inf</code>, corresponding to
the standard normal distribution. </p>
</td></tr>
<tr><td><code id="tailPlot_+3A_shape">shape</code></td>
<td>
<p>The shape parameter of the gamma distribution. Must be
positive.</p>
</td></tr>
<tr><td><code id="tailPlot_+3A_scale">scale</code></td>
<td>
<p>The scale parameter of the gamma distribution. Must be
strictly positive, <code>scale</code> strictly.</p>
</td></tr>
<tr><td><code id="tailPlot_+3A_rate">rate</code></td>
<td>
<p>The rate parameter of the gamma distribution. An
alternative way to specify the scale.</p>
</td></tr>
<tr><td><code id="tailPlot_+3A_...">...</code></td>
<td>
<p>Other graphical parameters (see <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tailPlot</code> draws either a left-hand or right-hand tail plot of
the data <code>x</code>. See for example Resnick (2007), p.105. The
left-hand tail plot plots the empirical distribution of the data
against the order statistics, for order statistic values below the
median. The right-hand tail plot plots one minus the empirical
distribution of the data against the order statistics, for order
statistic values above the median. The default is for the y-axis to be
plotted on a log scale.
</p>
<p><code>tailPlotLine</code> adds a line for the specified distribution to an
already drawn tail plot. The distribution can be any distribution
which has default parameters, but if parameters need to be supplied
the distribution must have an argument <code>param</code> which specifies
the parameters. This is the case for all distributions in the form
recommended in Scott <em>et al</em> (2009) and includes distributions
from the packages <span class="pkg">GeneralizedHyperbolic</span>, <span class="pkg">SkewHyperbolic</span>,
<span class="pkg">VarianceGamma</span> and <span class="pkg">NormalLaplace</span> (which is on R-Forge).
</p>
<p><code>normTailPlotLine</code>,<code>tTailPlotLine</code> and
<code>gammaTailPlotLine</code> add the corresponding line
derived respectively from the given normal, <code class="reqn">t</code>, or gamma
distribution to an already drawn tail plot.
</p>


<h3>Value</h3>

<p>Returns <code>NULL</code> invisibly.
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>
</p>


<h3>References</h3>

<p>Aas, Kjersti and Hobæk Haff, Ingrid (2006)
The generalised hyperbolic skew Student's <code class="reqn">t</code>-distribution.
<em>Journal of Financial Econometrics</em>, <b>4</b>, 275&ndash;309.
</p>
<p>Resnick, S. (2007) <em>Heavy-Tail Phenomena</em>, New York: Springer.
</p>
<p>Scott, David J. and Würtz, Diethelm and Dong, Christine
(2009) Software for Distributions in R. UseR: The R User
Conference 2009
<a href="https://www.r-project.org/conferences/useR-2009/slides/Scott+Wuertz+Dong.pdf">https://www.r-project.org/conferences/useR-2009/slides/Scott+Wuertz+Dong.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Draw tail plot of some data
x &lt;- rnorm(100, 1, 2)
tailPlot(x)
### Add normal distribution line
normTailPlotLine(x, mean = 1, sd = 2)
### Add t distribution line
tTailPlotLine(x, df = 5, lty = 2)
### Use fitted values
normTailPlotLine(x, mean = mean(x), sd = sd(x), lty = 3)

### Gamma distribution
x &lt;- rgamma(100, shape = 1, scale = 1)
tailPlot(x)
### Add gamma distribution line
gammaTailPlotLine(x, shape = 1, scale = 1)
### Left tail example
tailPlot(x, side = "l")
### Add gamma distribution line
gammaTailPlotLine(x, shape = 1, scale = 1, side = "l")
### Log scale on both axes
tailPlot(x, side = "l", log = "xy")
### Add gamma distribution line
gammaTailPlotLine(x, shape = 1, scale = 1, side = "l")

### Add line from a standard distribution with default parameters
x &lt;- rlnorm(100)
tailPlot(x)
tailPlotLine(x, distrFn = "lnorm")

### Add line from a distribution with 'param' argument
require(VarianceGamma)
param &lt;- c(0,0.5,0,0.5)
x &lt;- rvg(100, param = param)
tailPlot(x)
tailPlotLine(x, distrFn = "vg", param = param)

</code></pre>

<hr>
<h2 id='tsHessian'>
Calculate Two-Sided Hessian Approximation
</h2><span id='topic+tsHessian'></span>

<h3>Description</h3>

<p>Calculates an approximation to the Hessian of a function. Used for
obtaining an approximation to the information matrix for maximum
likelihood estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsHessian(param, fun, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tsHessian_+3A_param">param</code></td>
<td>

<p>Numeric. The Hessian is to be evaluated at this point.
</p>
</td></tr>
<tr><td><code id="tsHessian_+3A_fun">fun</code></td>
<td>

<p>A function of the parameters specified by <code>param</code>, and possibly
other parameters.
</p>
</td></tr>
<tr><td><code id="tsHessian_+3A_...">...</code></td>
<td>

<p>Values of other parameters of the function <code>fun</code> if required.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As a typical statistical application, the function <code>fun</code> is the
log-likelihood function, <code>param</code> specifies the maximum likelihood
estimates of the parameters of the distribution, and the data
constitutes the other parameter values required for determination of
the log-likelihood function.
</p>


<h3>Value</h3>

<p>The approximate Hessian matrix of the function <code>fun</code> where
differentiation is with respect to the vector of parameters
<code>param</code> at the point given by the vector <code>param</code>.
</p>


<h3>Note</h3>

<p>This code was borrowed from the <span class="pkg">fBasics</span> function, in the file
&lsquo;<span class="file">utils-hessian.R</span>&rsquo; with slight modification. This was in turn
borrowed from Kevin Sheppard's Matlab garch toolbox as implemented by
Alexios Ghalanos in his <span class="pkg">rgarch</span> package.
</p>


<h3>Author(s)</h3>

<p>David Scott <a href="mailto:d.scott@auckland.ac.nz">d.scott@auckland.ac.nz</a>,
Christine Yang Dong <a href="mailto:c.dong@auckland.ac.nz">c.dong@auckland.ac.nz</a>
</p>


<h3>See Also</h3>

<p><code>hyperbHessian</code> and <code>summary.hyperbFit</code> in
<span class="pkg">GeneralizedHyperbolic</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Consider Hessian of log(1 + x + 2y)
### Example from Lang: A Second Course in Calculus, p.74
fun &lt;- function(param){
  x &lt;- param[1]
  y &lt;- param[2]
  return(log(1 + x + 2*y))
}

### True value of Hessian at (0,0)
trueHessian &lt;- matrix( c(-1,-2,
                         -2,-4), byrow = 2, nrow = 2)
trueHessian

### Value from tsHessian
approxHessian &lt;- tsHessian(c(0,0), fun = fun)
approxHessian
maxDiff &lt;- max(abs(trueHessian - approxHessian))
### Should be approximately 0.045
maxDiff

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
