<!DOCTYPE html><html lang="en"><head><title>Help for package goweragreement</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {goweragreement}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#confint.gower'><p>Compute a credible interval for a Bayesian Gower fit.</p></a></li>
<li><a href='#discrete.dist'><p>Apply the discrete metric to two scores.</p></a></li>
<li><a href='#gower.agree'><p>Apply the Bayesian Gower agreement methodology to nominal or ordinal data.</p></a></li>
<li><a href='#hpd'><p>Compute a highest posterior density (HPD) interval.</p></a></li>
<li><a href='#influence.gower'><p>Compute DFBETAs for units and/or coders.</p></a></li>
<li><a href='#L1.dist'><p>Apply the L1 distance function to two scores.</p></a></li>
<li><a href='#liver'><p>Ordinal data from a radiological study of congenital diaphragmatic hernia.</p></a></li>
<li><a href='#summary.gower'><p>Print a summary of a Bayesian Gower fit.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Gower Agreement for Categorical Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-09-10</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides tools for applying the Bayesian Gower agreement methodology (presented in the package vignette) to nominal or ordinal data. The framework can accommodate any number of units, any number of coders, and missingness; and can handle both one-way and two-way random study designs. Influential units and/or coders can be identified easily using leave-one-out statistics.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.johnhughes.org">http://www.johnhughes.org</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-10 19:19:40 UTC; johnhughes</td>
</tr>
<tr>
<td>Author:</td>
<td>John Hughes [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>John Hughes &lt;drjphughesjr@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-10 19:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='confint.gower'>Compute a credible interval for a Bayesian Gower fit.</h2><span id='topic+confint.gower'></span>

<h3>Description</h3>

<p>Compute a credible interval for a Bayesian Gower fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gower'
confint(object, parm = "mu", level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confint.gower_+3A_object">object</code></td>
<td>
<p>an object of class <code>"gower"</code>, the result of a call to <code><a href="#topic+gower.agree">gower.agree</a></code>.</p>
</td></tr>
<tr><td><code id="confint.gower_+3A_parm">parm</code></td>
<td>
<p>always ignored since there is only one parameter, mu.</p>
</td></tr>
<tr><td><code id="confint.gower_+3A_level">level</code></td>
<td>
<p>the desired confidence level for the interval. The default is 0.95.</p>
</td></tr>
<tr><td><code id="confint.gower_+3A_...">...</code></td>
<td>
<p>additional arguments. These are passed to <code><a href="stats.html#topic+quantile">quantile</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes a credible interval for mu, the agreement parameter.
</p>
<p>This function uses the bootstrap sample to compute a credible interval. If <code>type = "HPD"</code> is not an element of ..., the lower and upper limits of the interval are appropriate quantiles of the bootstrap sample. Otherwise the limits are for an HPD interval.
</p>


<h3>Value</h3>

<p>A vector with entries giving the lower and upper limits of the interval. These will be labelled as (1 - level) / 2 and 1 - (1 - level) / 2 if the quantile method was used. They will be labeled &quot;Lower&quot; and &quot;Upper&quot; if the interval is an HPD interval.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gower.agree">gower.agree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fit the liver data, using the mean distance for each row of the data matrix.
# The range (which is equal to 4) must be passed to \code{\link{gower.agree}}
# since these data are ordinal and the L1 distance function is used. We assume
# a one-way sampling design for these data, i.e., units are random and coders
# are fixed. Also compute a 95\% credible interval using the quantile method
# and then the HPD method.

data(liver)
liver = as.matrix(liver)
fit = gower.agree(liver, data.type = "ordinal", range = 4)
confint(fit)
confint(fit, type = "HPD")
</code></pre>

<hr>
<h2 id='discrete.dist'>Apply the discrete metric to two scores.</h2><span id='topic+discrete.dist'></span>

<h3>Description</h3>

<p>Apply the discrete metric to two scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discrete.dist(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="discrete.dist_+3A_x">x</code></td>
<td>
<p>a score.</p>
</td></tr>
<tr><td><code id="discrete.dist_+3A_y">y</code></td>
<td>
<p>a score.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function applies the discrete metric to two scores. This is an appropriate distance function for nominal data.
</p>


<h3>Value</h3>

<p>0 if <code>x</code> is equal to <code>y</code>, 1 if <code>x</code> is not equal to <code>y</code>, <code>NA</code> if either score is <code>NA</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+L1.dist">L1.dist</a></code>
</p>

<hr>
<h2 id='gower.agree'>Apply the Bayesian Gower agreement methodology to nominal or ordinal data.</h2><span id='topic+gower.agree'></span>

<h3>Description</h3>

<p>Apply the Bayesian Gower agreement methodology to nominal or ordinal data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gower.agree(
  data,
  data.type = c("nominal", "ordinal"),
  dist.type = c("mean", "max"),
  design = c("one-way", "two-way"),
  iter = 10000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gower.agree_+3A_data">data</code></td>
<td>
<p>a matrix of scores. Each row corresponds to a unit, each column to a coder.</p>
</td></tr>
<tr><td><code id="gower.agree_+3A_data.type">data.type</code></td>
<td>
<p>the type of scores to be analyzed, either <code>"nominal"</code> or <code>"ordinal"</code>.</p>
</td></tr>
<tr><td><code id="gower.agree_+3A_dist.type">dist.type</code></td>
<td>
<p>for ordinal data, whether the row statistics are computed using the mean of the pairwise distances or the maximum pairwise distance.</p>
</td></tr>
<tr><td><code id="gower.agree_+3A_design">design</code></td>
<td>
<p>the sampling design, either <code>"one-way"</code> or <code>"two-way"</code>. For the former, the units are random and the coders are fixed. For the latter, both the units and the coders are random.</p>
</td></tr>
<tr><td><code id="gower.agree_+3A_iter">iter</code></td>
<td>
<p>the desired size of the posterior sample. The default value is 10,000.</p>
</td></tr>
<tr><td><code id="gower.agree_+3A_...">...</code></td>
<td>
<p>additional arguments for the distance function. These are ignored for nominal data. For ordinal data the range of the scores must be provided via argument <code>range</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the package's flagship function. It applies the Bayesian Gower methodology to nominal or ordinal data, and provides an estimate of the posterior mean along with a credible interval.
</p>


<h3>Value</h3>

<p>Function <code>gower.agree</code> returns an object of class <code>"gower"</code>, which is a list comprising the following elements.
</p>
<table role = "presentation">
<tr><td><code>mu.hat</code></td>
<td>
<p>the estimate of the posterior mean.</p>
</td></tr>
<tr><td><code>mu.sample</code></td>
<td>
<p>the posterior sample.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>units</code></td>
<td>
<p>the number of units.</p>
</td></tr>
<tr><td><code>coders</code></td>
<td>
<p>the number of coders.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>the data matrix, sans rows that were removed due to missigness.</p>
</td></tr>
<tr><td><code>data.type</code></td>
<td>
<p>the type of scores, nominal or ordinal.</p>
</td></tr>
<tr><td><code>dist.type</code></td>
<td>
<p>for ordinal data, the manner in which the row statistics were computed.</p>
</td></tr>
<tr><td><code>design</code></td>
<td>
<p>the sampling design, one-way or two-way.</p>
</td></tr>
<tr><td><code>row.stats</code></td>
<td>
<p>the vector of row statistics.</p>
</td></tr>
<tr><td><code>del</code></td>
<td>
<p>the number of rows that were deleted due to missingness.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fit the liver data, using the mean distance for each row of the data matrix.
# The range (which is equal to 4) must be passed to \code{\link{gower.agree}}
# since these data are ordinal and the L1 distance function is used. We assume
# a one-way sampling design for these data, i.e., units are random and coders
# are fixed.

data(liver)
liver = as.matrix(liver)
fit = gower.agree(liver, data.type = "ordinal", range = 4)
summary(fit)
</code></pre>

<hr>
<h2 id='hpd'>Compute a highest posterior density (HPD) interval.</h2><span id='topic+hpd'></span>

<h3>Description</h3>

<p>Compute a highest posterior density (HPD) interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hpd(x, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hpd_+3A_x">x</code></td>
<td>
<p>the posterior sample.</p>
</td></tr>
<tr><td><code id="hpd_+3A_alpha">alpha</code></td>
<td>
<p>the desired significance level.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses a given posterior sample to compute an HPD interval at a given significance level.
</p>


<h3>Value</h3>

<p>A 2-vector containing the lower endpoint and the upper endpoint, respectively.
</p>

<hr>
<h2 id='influence.gower'>Compute DFBETAs for units and/or coders.</h2><span id='topic+influence.gower'></span>

<h3>Description</h3>

<p>Compute DFBETAs for units and/or coders.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gower'
influence(model, units, coders, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="influence.gower_+3A_model">model</code></td>
<td>
<p>a fitted model object, the result of a call to <code><a href="#topic+gower.agree">gower.agree</a></code>.</p>
</td></tr>
<tr><td><code id="influence.gower_+3A_units">units</code></td>
<td>
<p>a vector of integers. A DFBETA will be computed for each of the corresponding units.</p>
</td></tr>
<tr><td><code id="influence.gower_+3A_coders">coders</code></td>
<td>
<p>a vector of integers. A DFBETA will be computed for each of the corresponding coders.</p>
</td></tr>
<tr><td><code id="influence.gower_+3A_...">...</code></td>
<td>
<p>additional arguments. These are ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes DFBETAs for one or more units and/or one or more coders.
</p>


<h3>Value</h3>

<p>A list comprising at most four elements.
</p>
<table role = "presentation">
<tr><td><code>dfbeta.units</code></td>
<td>
<p>a vector containing DFBETAs for the units specified via argument <code>units</code>.</p>
</td></tr>
<tr><td><code>dfbeta.coders</code></td>
<td>
<p>a vector containing DFBETAs for the coders specified via argument <code>coders</code>.</p>
</td></tr>
<tr><td><code>fits.units</code></td>
<td>
<p>a list containing fit objects for the omitted units specified via argument <code>units</code>.</p>
</td></tr>
<tr><td><code>fits.coders</code></td>
<td>
<p>a list containing fit objects for the omitted coders specified via argument <code>coders</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Analyze nominal data previously considered by Krippendorff.
# Assume a one-way design. Compute a DFBETA for unit 6, which
# should be rather influential.

kripp = matrix(c(1,2,3,3,2,1,4,1,2,NA,NA,NA,
                 1,2,3,3,2,2,4,1,2,5,NA,3,
                 NA,3,3,3,2,3,4,2,2,5,1,NA,
                 1,2,3,3,2,4,4,1,2,5,1,NA), 12, 4)
kripp

set.seed(12)
fit = gower.agree(kripp)
summary(fit)
inf = influence(fit, units = 6)

# Report the DFBETA for unit 6 and the estimate of mu when unit 6
# is ommitted.

inf$dfbeta.units
fit$mu.hat - inf$dfbeta.units
</code></pre>

<hr>
<h2 id='L1.dist'>Apply the L1 distance function to two scores.</h2><span id='topic+L1.dist'></span>

<h3>Description</h3>

<p>Apply the L1 distance function to two scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>L1.dist(x, y, range)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="L1.dist_+3A_x">x</code></td>
<td>
<p>a score.</p>
</td></tr>
<tr><td><code id="L1.dist_+3A_y">y</code></td>
<td>
<p>a score.</p>
</td></tr>
<tr><td><code id="L1.dist_+3A_range">range</code></td>
<td>
<p>the range of the scores, i.e., the difference between the maximum score and the minimum score.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function applies the L1 distance function to two scores. This is an appropriate distance function for ordinal data.
</p>


<h3>Value</h3>

<p><code class="reqn">|x - y| / r</code>, where <code class="reqn">r</code> is the range of the scores; or <code>NA</code> if either score is <code>NA</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+discrete.dist">discrete.dist</a></code>
</p>

<hr>
<h2 id='liver'>Ordinal data from a radiological study of congenital diaphragmatic hernia.</h2><span id='topic+liver'></span>

<h3>Description</h3>

<p>This data frame has exactly four columns. The first two columns contain liver herniation grades assigned by the first radiologist, and the final two columns contain grades assigned by the second radiologist. Each radiologist graded each image twice so that intra-rater consistency can be assessed. The liver grades and their meanings are provided below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(liver)
</code></pre>


<h3>Format</h3>

<p>A data frame having 47 rows and four columns
</p>


<h3>Details</h3>


<ul>
<li><p> 1. No herniation of the liver into the fetal chest
</p>
</li>
<li><p> 2. Less than half of the ipsilateral thorax is occupied by the fetal liver
</p>
</li>
<li><p> 3. Greater than half of the thorax is occupied by the fetal liver
</p>
</li>
<li><p> 4. The liver dome reaches the thoracic apex
</p>
</li>
<li><p> 5. The liver dome not only reaches the thoracic apex but also extends across the thoracic midline
</p>
</li></ul>


<hr>
<h2 id='summary.gower'>Print a summary of a Bayesian Gower fit.</h2><span id='topic+summary.gower'></span>

<h3>Description</h3>

<p>Print a summary of a Bayesian Gower fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gower'
summary(object, conf.level = 0.95, digits = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.gower_+3A_object">object</code></td>
<td>
<p>an object of class <code>"gower"</code>, the result of a call to <code><a href="#topic+gower.agree">gower.agree</a></code>.</p>
</td></tr>
<tr><td><code id="summary.gower_+3A_conf.level">conf.level</code></td>
<td>
<p>the confidence level for the credible interval. The default is 0.95.</p>
</td></tr>
<tr><td><code id="summary.gower_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits to display. The default is 4.</p>
</td></tr>
<tr><td><code id="summary.gower_+3A_...">...</code></td>
<td>
<p>additional arguments. These are currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function prints a summary of the fit.
</p>


<h3>Value</h3>

<p>A list containing various elements of the summary is returned invisibly, but this function should be called for its side effects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gower.agree">gower.agree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fit the liver data, using the mean distance for each row of the data matrix.
# The range (which is equal to 4) must be passed to \code{\link{gower.agree}}
# since these data are ordinal and the L1 distance function is used. We assume
# a one-way sampling design for these data, i.e., units are random and coders
# are fixed.

data(liver)
liver = as.matrix(liver)
fit = gower.agree(liver, data.type = "ordinal", range = 4)
summary(fit)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
