<!DOCTYPE html><html lang="en"><head><title>Help for package support.BWS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {support.BWS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#support.BWS-package'>
<p>Tools for Case 1 best-worst scaling</p></a></li>
<li><a href='#bws.apollo'>
<p>Converting a dataset into that for Apollo</p></a></li>
<li><a href='#bws.count'>
<p>Calculating count-based BW scores</p></a></li>
<li><a href='#bws.dataset'>
<p>Creating a data set suitable for case 1 best-worst scaling analysis</p></a></li>
<li><a href='#bws.questionnaire'>
<p>Converting a two-level OMED/BIBD into BWS questions</p></a></li>
<li><a href='#bws.response'>
<p>Generating artificial responses to Case 1 best-worst scaling questions</p></a></li>
<li><a href='#bws.sp'>
<p>Calculating shares of preference</p></a></li>
<li><a href='#fruit'>
<p>Synthetic respondent data set: consumers' preferences for fruits</p></a></li>
<li><a href='#mfa'>
<p>Synthetic respondent data set: citizens' preferences for the multifunctionality of agriculture</p></a></li>
<li><a href='#ricebws1'>
<p>Consumers' preferences for rice characteristics</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Case 1 Best-Worst Scaling</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4-6</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-03-29</td>
</tr>
<tr>
<td>Author:</td>
<td>Hideo Aizaki</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hideo Aizaki &lt;azk-r@spa.nifty.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides basic functions that support an implementation of object case (Case 1) best-worst scaling: a function for converting a two-level orthogonal main-effect design/balanced incomplete block design into questions; two functions for creating a data set suitable for analysis; a function for calculating count-based scores; a function for calculating shares of preference; and a function for generating artificial responses to questions. See Louviere et al. (2015) &lt;<a href="https://doi.org/10.1017%2FCBO9781107337855">doi:10.1017/CBO9781107337855</a>&gt; for details on best-worst scaling, and Aizaki and Fogarty (2023) &lt;<a href="https://doi.org/10.1016%2Fj.jocm.2022.100394">doi:10.1016/j.jocm.2022.100394</a>&gt; for the package.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://lab.agr.hokudai.ac.jp/spmur/">http://lab.agr.hokudai.ac.jp/spmur/</a>
<a href="http://lab.agr.hokudai.ac.jp/nmvr/">http://lab.agr.hokudai.ac.jp/nmvr/</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Suggests:</td>
<td>DoE.base, crossdes, survival, mlogit, gmnl, apollo</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-29 06:51:57 UTC; rpkgdev</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-29 07:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='support.BWS-package'>
Tools for Case 1 best-worst scaling
</h2><span id='topic+support.BWS-package'></span><span id='topic+support.BWS'></span>

<h3>Description</h3>

<p>The package provides three basic functions that support an implementation of object case (Case 1) best-worst scaling: one for converting a two-level orthogonal main-effect design/balanced incomplete block design into questions; one for creating a data set suitable for analysis; and one for calculating count-based scores.
</p>


<h3>Details</h3>

<p>Object case (or Case 1) best-worst scaling (BWS), or maximum difference scaling (MaxDiff) (Finn and Louviere 1992) is a stated preference method. After listing the items (objects) evaluated by respondents, a number of different subsets of the items are constructed from the list using the design of experiments. Each of the subsets is presented as a choice set to respondents, who are then asked to select the best (or most important) item and the worst (or least important) item in the choice set. This question is repeated until all the subsets are evaluated.
</p>
<p>There are two methods to construct choice sets for object case BWS: one uses a two-level orthogonal main-effect design (OMED) (Finn and Louviere, 1992) and the other uses a balanced incomplete block design (BIBD) (Auger et al., 2007). The first method uses a two-level OMED with <code class="reqn">T</code> columns, where <code class="reqn">T</code> is the total number of items evaluated: each column corresponds to an item and each row corresponds to a question. There are two values in the two-level OMEDs (e.g., 1 and 2): one value is interpreted as an item being &ldquo;absent&rdquo; from the corresponding column and the other as being &ldquo;present.&rdquo; In this way, we can decide which items are assigned to each question: for example, if a row in a two-level OMED contains a value of 2 (which means &ldquo;present&rdquo; here ) in the 1st, 5th, and 8th columns, and a value of 1 in the other columns, these three items are presented in a question corresponding to the row.
</p>
<p>The second method uses a BIBD, which is a category of designs in which a subset of treatments is assigned to each block. The features of a BIBD are expressed by &ldquo;number of treatments (items),&rdquo; &ldquo;size of a block (number of items per question),&rdquo; &ldquo;number of blocks (questions),&rdquo; &ldquo;number of replications of each treatment (item),&rdquo; and &ldquo;frequency that each pair of treatments (items) appears in the same block (question).&rdquo; Each row corresponds to a question; the number of columns is equal to the number of items per question; and the level values correspond to item identification numbers. For example, assume that there are seven items, ITEM1, ITEM2, ..., and ITEM7, and a BIBD with seven rows, four columns, and seven level values (1, 2, ..., 7). Under these assumptions, if a row in the BIBD contains values of 1, 4, 6, and 7,  a set containing ITEM1, ITEM4, ITEM6, and ITEM7 is presented in a question corresponding to the row.
</p>
<p>There are two approaches to analyzing responses to object case BWS questions: a counting approach and a modeling approach. The counting approach calculates several types of scores on the basis of the number of times (the frequency or count) item <code class="reqn">i</code> is selected as the best (<code class="reqn">B_{in}</code>) and the worst (<code class="reqn">W_{in}</code>) among all the questions for respondent <code class="reqn">n</code>. These scores are roughly divided into two categories: disaggregated (individual-level) scores and aggregated (total-level) scores (Finn and Louviere, 1992; Lee et al., 2007; Cohen, 2009; Mueller and Rungie, 2009).
</p>
<p>The first category includes a disaggregated BW score and its standardized score:
</p>
<p style="text-align: center;"><code class="reqn">
BW_{in} = B_{in} - W_{in},
</code>
</p>

<p style="text-align: center;"><code class="reqn">
std.BW_{in} = \frac{BW_{in}}{r},
</code>
</p>

<p>where <code class="reqn">r</code> is the frequency with which item <code class="reqn">i</code> appears across all questions.
</p>
<p>The frequency with which item <code class="reqn">i</code> is selected as the best across all questions for <code class="reqn">N</code> respondents is defined as <code class="reqn">B_{i}</code>. Similarly, the frequency with which item <code class="reqn">i</code> is selected as the worst is defined as <code class="reqn">W_{i}</code> (i.e., <code class="reqn">B_{i} = \sum_{n=1}^{N} B_{in}</code>, <code class="reqn">W_{i} = \sum_{n=1}^{N} W_{in}</code>). The second category includes the aggregated versions of <code class="reqn">BW_{in}</code> and <code class="reqn">std.BW_{in}</code>, as well as the square root of the ratio of <code class="reqn">B_{i}</code> to <code class="reqn">W_{i}</code> and its standardized score:
</p>
<p style="text-align: center;"><code class="reqn">
BW_{i} = B_{i} - W_{i},
</code>
</p>

<p style="text-align: center;"><code class="reqn">
std.BW_{i} = \frac{BW_{i}}{Nr},
</code>
</p>

<p style="text-align: center;"><code class="reqn">
sqrt.BW_{i} = \sqrt{\frac{B_{i}}{W_{i}}},
</code>
</p>

<p style="text-align: center;"><code class="reqn">
std.sqrt.BW_{i} = \frac{sqrt.BW_{i}}{max.sqrt.BW_{i}},
</code>
</p>

<p>where <code class="reqn">max.sqrt.BW_{i}</code> is the maximum value of <code class="reqn">sqrt.BW_{i}</code>. 
</p>
<p>The modeling approach uses discrete choice models to analyze responses. In the package, this approach is based on the understanding of respondents' behavior in the following situation (Finn and Louviere, 1992; Auger et al., 2007). Suppose that <code class="reqn">m</code> items exist in a choice set (a question). The number of possible pairs in which item <code class="reqn">i</code> is selected as the best and item <code class="reqn">j</code> is selected as the worst (<code class="reqn">i \neq j</code>) from <code class="reqn">m</code> items is <code class="reqn">m \times (m - 1)</code>. Respondents are assumed to have a utility (<code class="reqn">v</code>) for each item. Further, they are assumed to select item <code class="reqn">i</code> as the best and item <code class="reqn">j</code> as the worst because the difference in utility between <code class="reqn">i</code> and <code class="reqn">j</code> represents the greatest utility difference (the maxdiff model). Under these assumptions, the probability of selecting item <code class="reqn">i</code> as the best and item <code class="reqn">j</code> as the worst is expressed as a conditional logit model:
</p>
<p style="text-align: center;"><code class="reqn">
Pr(i, j) = \frac{\exp(v_{i} - v_{j})}{\sum_{k=1}^{m}\sum_{l=1, k \neq l}^{m}\exp(v_{k} - v_{l})}.
</code>
</p>

<p>A share of preference for item <code class="reqn">i</code> (<code class="reqn">SP_{i}</code>) based on the conditional logit model choice rule is as follows (Cohen, 2003; Cohen and Neira, 2004; Lusk and Briggeman, 2009):
</p>
<p style="text-align: center;"><code class="reqn">
SP_{i} = \frac{\exp(v_{i})}{\sum_{t=1}^{T}\exp(v_{t})}.
</code>
</p>

<p>Version 0.2-0 and later versions of the package are also available for the marginal and marginal sequential models (Hensher et al., 2015, Appendix 6B) in the modeling approach.
</p>


<h3>Acknowledgments</h3>

<p>This work was supported by JSPS KAKENHI Grant Numbers JP25450341, JP16K07886, and JP20K06251.
</p>


<h3>Author(s)</h3>

<p>Hideo Aizaki
</p>


<h3>References</h3>

<p>Aizaki H, Fogarty J (2023)
R packages and tutorial for case 1 best-worst scaling.
<em>Journal of Choice Modelling</em>, <b>46</b>, 100394.
</p>
<p>Aizaki H, Nakatani T, Sato K (2014) 
<em>Stated Preference Methods Using R</em>. 
CRC Press. 
</p>
<p>Auger P, Devinney TM, Louviere JJ (2007) 
Using best-worst scaling methodology to investigate consumer ethical beliefs across countries. 
<em>Journal of Business Ethics</em>, <b>70</b>, 299&ndash;326. 
</p>
<p>Cohen E (2009) 
Applying best-worst scaling to wine marketing. 
<em>International Journal of Wine Business Research</em>, <b>21</b>(1), 8&ndash;23. 
</p>
<p>Cohen SH (2003) 
Maximum difference scaling: 
Improved measures of importance and preference for segmentation. 
<em>Sawtooth Software Research Paper Series</em>, 1&ndash;17. 
<a href="https://sawtoothsoftware.com/resources/technical-papers/maximum-difference-scaling-improved-measures-of-importance-and-preference-for--segmentation">https://sawtoothsoftware.com/resources/technical-papers/maximum-difference-scaling-improved-measures-of-importance-and-preference-for&ndash;segmentation</a>.
</p>
<p>Cohen S, Neira L (2004) 
Measuring preference for product benefits across countries: 
Overcoming scale usage bias with maximum difference scaling. 
<em>Excellence in International Research</em>, 1&ndash;22.
</p>
<p>Finn A, Louviere JJ (1992) 
Determining the appropriate response to evidence of public concern: 
The case of food safety. 
<em>Journal of Public Policy &amp; Marketing</em>, <b>11</b>(2), 12&ndash;25. 
</p>
<p>Hensher DA, Rose JM, Greene WH (2015) 
<em>Applied Choice Analysis</em>. 2nd edition. Cambridge University Press. 
</p>
<p>Hess S, Palma D (2019a) Apollo: 
a flexible, powerful and customisable freeware package for choice model estimation and application. 
<em>Journal of Choice Modelling</em>, <b>32</b>, 100170. 
</p>
<p>Hess S, Palma D (2019b) 
Apollo version 0.0.9, user manual, 
<a href="http://www.apollochoicemodelling.com/">http://www.apollochoicemodelling.com/</a>.
</p>
<p>Lee JA, Soutar GN, Louviere J (2007) 
Measuring values using best-worst scaling: The LOV example. 
<em>Psychology &amp; Marketing</em>, <b>24</b>(12), 1043&ndash;1058. 
</p>
<p>Lusk JL, Briggeman BC (2009) 
Food values. 
<em>American Journal of Agricultural Economics</em>, <b>91</b>(1), 184&ndash;196. 
</p>
<p>Louviere JJ, Flynn TN, Marley AAJ (2015) 
<em>Best-Worst Scaling: Theory, Methods and Applications</em>. 
Cambridge University Press. 
</p>
<p>Mueller S, Rungie C (2009) 
Is there more information in best-worst choice data?: 
Using the attitude heterogeneity structure to identify consumer segments. 
<em>International Journal of Wine Business Research</em>, <b>21</b>(1), 24&ndash;40. 
</p>

<hr>
<h2 id='bws.apollo'>
Converting a dataset into that for Apollo
</h2><span id='topic+bws.apollo'></span>

<h3>Description</h3>

<p>This function converts a dataset generated using <code>bws.dataset</code> into that in a format suitable for a modeling analysis using the <span class="pkg">apollo</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bws.apollo(data, detail = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bws.apollo_+3A_data">data</code></td>
<td>

<p>A data frame containing the output from the function <code><a href="#topic+bws.dataset">bws.dataset</a></code>.
</p>
</td></tr>
<tr><td><code id="bws.apollo_+3A_detail">detail</code></td>
<td>

<p>A logical value: if <code>TRUE</code>, the dataset is returned in a detailed format; and if <code>FALSE</code> (default), the dataset is returned in a simple format.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts a dataset generated using <code><a href="#topic+bws.dataset">bws.dataset</a></code> into that in a format suitable for the modeling analysis using the <span class="pkg">apollo</span> package. The <span class="pkg">apollo</span> is a comprehensive package for choice modelling. The format of a dataset suitable for <span class="pkg">apollo</span> differs from that for <code><a href="survival.html#topic+clogit">clogit</a></code> in <span class="pkg">survival</span>, <code><a href="mlogit.html#topic+mlogit">mlogit</a></code> in <span class="pkg">mlogit</span>, and <code><a href="gmnl.html#topic+gmnl">gmnl</a></code> in <span class="pkg">gmnl</span>. The former assumes that a row corresponds to a question, while the latter assumes that a row corresponds to an alternative. Therefore, the output from <code><a href="#topic+bws.dataset">bws.dataset</a></code>, which is suitable for <code><a href="survival.html#topic+clogit">clogit</a></code>, <code><a href="mlogit.html#topic+mlogit">mlogit</a></code>, and <code><a href="gmnl.html#topic+gmnl">gmnl</a></code>, has to be converted into a dataset for the modeling analysis using <span class="pkg">apollo</span>.
</p>


<h3>Value</h3>

<p>The function <code>bws.apollo</code> returns a data frame that contains variables <code>id</code>, <code>Q</code>, and <code>RES</code>, as well as independent variables in a simple format. While the variable <code>id</code> is assigned to <code>indivID</code> used in the section &ldquo;Definition of core settings&rdquo; of Apollo's model estimation script, the variable <code>RES</code> is assigned to <code>choiceVar</code> used in the section &ldquo;Likelihood definition&rdquo;. The serial number of alternatives is appended to the tail of the independent variable name: e.g., <code>Item1.1</code> for the first alternative, <code>Item1.2</code> for the second alternative, and <code>Item1.3</code> for the third alternative. The independent variables are also used in the section &ldquo;Likelihood definition&rdquo;. The detailed format dataset includes variables that are not used for the analysis with Apollo. For details on Apollo's model estimation script, refer to the vignette (<a href="https://cran.r-project.org/package=apollo">https://cran.r-project.org/package=apollo</a>) and the the user manual (Hess and Palma 2019b).
</p>


<h3>Author(s)</h3>

<p>Hideo Aizaki
</p>


<h3>See Also</h3>

<p><code><a href="#topic+support.BWS-package">support.BWS-package</a></code>, <code><a href="#topic+bws.dataset">bws.dataset</a></code>, <code><a href="survival.html#topic+clogit">clogit</a></code>, <code><a href="mlogit.html#topic+mlogit">mlogit</a></code>, <code><a href="gmnl.html#topic+gmnl">gmnl</a></code>, <code><a href="apollo.html#topic+apollo_estimate">apollo_estimate</a></code>, <code><a href="apollo.html#topic+apollo_mnl">apollo_mnl</a></code>
</p>

<hr>
<h2 id='bws.count'>
Calculating count-based BW scores
</h2><span id='topic+bws.count'></span><span id='topic+print.bws.count'></span><span id='topic+plot.bws.count2'></span><span id='topic+barplot.bws.count2'></span><span id='topic+sum.bws.count2'></span><span id='topic+mean.bws.count2'></span><span id='topic+summary.bws.count2'></span><span id='topic+print.summary.bws.count2'></span>

<h3>Description</h3>

<p>This function calculates various BW scores on the basis of a counting approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bws.count(data, cl = 1)

## S3 method for class 'bws.count'
print(x, digits = max(3, getOption("digits") - 3), scientific = FALSE, ...)

## S3 method for class 'bws.count2'
plot(x, score = c("bw", "b", "w"), pos = 1, xlab = NULL, ylab = NULL, subset, ...)

## S3 method for class 'bws.count2'
barplot(height, score = c("bw", "b", "w", "sbw"), mfrow = NULL, mean = FALSE, 
error.bar = NULL, conf.level = 0.95, subset, sort = FALSE, ...)

## S3 method for class 'bws.count2'
sum(x, ...)

## S3 method for class 'bws.count2'
mean(x, ...)

## S3 method for class 'bws.count2'
summary(object, sort = FALSE, subset, ...)

## S3 method for class 'summary.bws.count2'
print(x, digits = max(3, getOption("digits") - 3), scientific = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bws.count_+3A_data">data</code></td>
<td>

<p>A data frame containing the output from <code>bws.dataset()</code>.
</p>
</td></tr>
<tr><td><code id="bws.count_+3A_cl">cl</code></td>
<td>

<p>A value describing the S3 class of the object created by this function: <code>1</code> for the S3 class <code>"bws.count"</code>, and <code>2</code> for the S3 class <code>"bws.count2"</code>.
</p>
</td></tr>
<tr><td><code id="bws.count_+3A_x">x</code>, <code id="bws.count_+3A_height">height</code>, <code id="bws.count_+3A_object">object</code></td>
<td>

<p>An object of the S3 class <code>"bws.count"</code> or <code>"bws.count2"</code>.
</p>
</td></tr>
<tr><td><code id="bws.count_+3A_digits">digits</code></td>
<td>

<p>The number of significant digits. See the <code><a href="base.html#topic+format">format</a></code> function.
</p>
</td></tr>
<tr><td><code id="bws.count_+3A_scientific">scientific</code></td>
<td>

<p>Scores are encoded in scientific format. See the <code><a href="base.html#topic+format">format</a></code> function.
</p>
</td></tr>
<tr><td><code id="bws.count_+3A_score">score</code></td>
<td>

<p>A character showing a type of the output from this function: <code>"b"</code> is assigned to this argument when the output is based on best scores, <code>"w"</code> is assigned when it is based on worst scores, <code>"bw"</code> is assigned when it is based on best-minus-worst scores, or <code>"sbw"</code> is assigned when it is based on standardized best-minus-worst scores. 
</p>
</td></tr>
<tr><td><code id="bws.count_+3A_pos">pos</code></td>
<td>

<p>A value showing a position of labels for points in the plot. See the argument <code>pos</code> of the <code><a href="graphics.html#topic+text">text</a></code> function.
</p>
</td></tr>
<tr><td><code id="bws.count_+3A_xlab">xlab</code></td>
<td>

<p>A character showing a label for the x axis.
</p>
</td></tr>
<tr><td><code id="bws.count_+3A_ylab">ylab</code></td>
<td>

<p>A character showing a label for the y axis.
</p>
</td></tr>
<tr><td><code id="bws.count_+3A_mfrow">mfrow</code></td>
<td>

<p>A two-element vector <code>c(nr, nc)</code>: bar plots will be drawn in an <code>nr</code>-by-<code>nc</code> array on the device by row.
</p>
</td></tr>
<tr><td><code id="bws.count_+3A_mean">mean</code></td>
<td>

<p>A logical value denoted by <code>TRUE</code> when drawing a bar plot of the aggregated standardized BW scores or <code>FALSE</code> (default) when drawing bar plots of B, W, or BW scores.
</p>
</td></tr>
<tr><td><code id="bws.count_+3A_error.bar">error.bar</code></td>
<td>

<p>A character shoiwng a type of error bar adding on the bar plot of the aggregated standardized BW scores: <code>"sd"</code> for the standard deviation; <code>"se"</code> for the standard error; <code>"ci"</code> for the confidence interval; and <code>NULL</code> (default) for none.
</p>
</td></tr>
<tr><td><code id="bws.count_+3A_conf.level">conf.level</code></td>
<td>

<p>A value showing the confidence level when adding the confidence interval on the bar plot using <code>error.bar</code>.
</p>
</td></tr>
<tr><td><code id="bws.count_+3A_subset">subset</code></td>
<td>

<p>A logical expression indicating a subset of observations to be used.
</p>
</td></tr>
<tr><td><code id="bws.count_+3A_sort">sort</code></td>
<td>

<p>A logical value denoted by <code>TRUE</code> when sorting barplots or items according to mean scores or <code>FALSE</code> (default).
</p>
</td></tr>
<tr><td><code id="bws.count_+3A_...">...</code></td>
<td>

<p>Arguments passed to a function used internally.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates various BW scores on the basis of the counting approach. For details on the scores, refer to <code><a href="#topic+support.BWS-package">support.BWS-package</a></code>. 
</p>
<p>When using this function with the argument <code>cl = 1</code>, it returns an object of the S3 class <code>"bws.count"</code>, containing disaggregated scores and aggregated scores in list format. The first category includes disaggregated best (B), worst (W), best-minus-worst (BW), and standardized BW scoers. The second category includes aggregated B, W, BW, and standardized BW scores as well as the square root of the ratio of the aggregated B to the aggregated W and its standardized scores. The generic function <code>print()</code> is available for the S3 class <code>"bws.count"</code>. The <code>print()</code> shows a summary of disaggregated scores and a table of aggregated scores.
</p>
<p>When using this function with the argument <code>cl = 2</code>, it returns an object of the S3 class <code>"bws.count2"</code>, which inherits from the S3 class <code>"data.frame"</code>, including disaggregated B, W, BW, and standardized BW scores, respondent identification number variable, and respondent characteristic variables. The generic functions such as <code>plot()</code>, <code>barplot()</code>, <code>sum()</code>, <code>mean()</code>, and <code>summary()</code> are available for the S3 class <code>"bws.count2"</code>. The <code>plot()</code> draws the relationship between means and standard deviations of B, W, or BW scores. The <code>barplot()</code> draws the bar plot of the aggregated standardized BW scores or the bar plots of B, W, or BW scores. The <code>sum()</code> returns the aggregated B, W, and BW scores in data frame format. The <code>mean()</code> returns means of B, W, BW, and standardized BW scores in data frame format. The <code>summary()</code> calculates (1) aggregated B, W, BW, and standardized BW scores, (2) item ranks based on the BW score, (3) means of B, W, BW, and standardized BW scores, and (4) the square root of the aggregated B to the aggregated W and its standardized scores. 
</p>


<h3>Value</h3>

<p>The output from <code>bws.count()</code> with the argument <code>cl = 1</code> is an object of the S3 class <code>"bws.count"</code>, containing three components:
</p>
<p>A list <code>disaggregate</code> contains five objects related to disaggregated scores.
</p>
<table role = "presentation">
<tr><td><code>ID</code></td>
<td>
<p>A vector showing the respondent's identification number.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>A matrix showing the number of times item <code class="reqn">i</code> is selected as the best by each respondent.</p>
</td></tr>
<tr><td><code>W</code></td>
<td>
<p>A matrix showing the number of times item <code class="reqn">i</code> is selected as the worst by each respondent.</p>
</td></tr>
<tr><td><code>BW</code></td>
<td>
<p>A matrix showing the difference between <code>B</code> and <code>W</code> for item <code class="reqn">i</code> per respondent.</p>
</td></tr>
<tr><td><code>stdBW</code></td>
<td>
<p>A matrix showing standardized <code>BW</code>.</p>
</td></tr>
</table>
<p>A data frame <code>aggregate</code> contains aggregated scores across all respondents.
</p>
<table role = "presentation">
<tr><td><code>B</code></td>
<td>
<p>A variable showing the number of times item <code class="reqn">i</code> is selected as the best across all respondents.</p>
</td></tr>
<tr><td><code>W</code></td>
<td>
<p>A variable showing the number of times item <code class="reqn">i</code> is selected as the worst across all respondents.</p>
</td></tr>
<tr><td><code>BW</code></td>
<td>
<p>A variable showing the difference between <code>B</code> and <code>W</code> for item <code class="reqn">i</code> across all respondents.</p>
</td></tr>
<tr><td><code>stdBW</code></td>
<td>
<p>A variable showing standardized <code>BW</code>.</p>
</td></tr>
<tr><td><code>sqrtBW</code></td>
<td>
<p>A variable showing the square root of the ratio of <code>B</code> to <code>W</code> for item <code class="reqn">i</code> across all respondents.</p>
</td></tr>
<tr><td><code>std.sqrtBW</code></td>
<td>
<p>A variable showing the standardized <code>sqrtBW</code>.</p>
</td></tr>
</table>
<p>A list <code>information</code> contains basic information related to the BWS questions.
</p>
<table role = "presentation">
<tr><td><code>nrespondents</code></td>
<td>
<p>A variable showing the number of respondents.</p>
</td></tr>
<tr><td><code>nitems</code></td>
<td>
<p>A variable showing the number of items.</p>
</td></tr>
<tr><td><code>fitem</code></td>
<td>
<p>A variable showing the frequency of each item in the choice sets.</p>
</td></tr>
<tr><td><code>vnames</code></td>
<td>
<p>A variable showing the names of each item.</p>
</td></tr>
</table>
<p>The output from <code>bws.count()</code> with the argument <code>cl = 2</code>, which is an object of the S3 class <code>"bws.count2"</code>, is a data frame containing respondent identification number variable, B score variables, W score variables, BW score variables, standardized BW score variables, and respondent characteristic variables. These scores are calculated by each respondent. 
</p>
<p>Note that the S3 class <code>"bws.count"</code> would be replaced by the S3 class <code>"bws.count2"</code> in future.
</p>


<h3>Author(s)</h3>

<p>Hideo Aizaki
</p>


<h3>See Also</h3>

<p><code><a href="#topic+support.BWS-package">support.BWS-package</a></code>, <code><a href="#topic+bws.dataset">bws.dataset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See examples in bws.dataset()
</code></pre>

<hr>
<h2 id='bws.dataset'>
Creating a data set suitable for case 1 best-worst scaling analysis
</h2><span id='topic+bws.dataset'></span>

<h3>Description</h3>

<p>This function creates a data set used for <code>bws.count()</code> in <span class="pkg">support.BWS</span> and <code>clogit()</code> in <span class="pkg">survival</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bws.dataset(data = NULL, response.type = 1,
            choice.sets, design.type = 1,
            item.names = NULL, row.renames = TRUE,
            id = NULL, response = NULL,
            model = "maxdiff", delete.best = FALSE,
            version = NULL, respondent.dataset = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bws.dataset_+3A_data">data</code></td>
<td>

<p>A data frame including responses to BWS questions (i.e., a survey/respondent data set).
</p>
</td></tr>
<tr><td><code id="bws.dataset_+3A_response.type">response.type</code></td>
<td>

<p>A value describing the format of the response variables: <code>1</code> if the response variables follow a row number format, and <code>2</code> if they follow an item number format.
</p>
</td></tr>
<tr><td><code id="bws.dataset_+3A_choice.sets">choice.sets</code></td>
<td>

<p>A data frame or matrix containing choice sets.
</p>
</td></tr>
<tr><td><code id="bws.dataset_+3A_design.type">design.type</code></td>
<td>

<p>A value describing how to design the choice sets: <code>1</code> if the design assigned to <code>choice.sets</code> is a two-level OMED, and <code>2</code> if it is a BIBD.
</p>
</td></tr>
<tr><td><code id="bws.dataset_+3A_item.names">item.names</code></td>
<td>

<p>A vector containing the names of items: if it takes <code>NULL</code>, default item names (i.e., <code>ITEM1</code>, <code>ITEM2</code>, ...) are used in the resultant data set.
</p>
</td></tr>
<tr><td><code id="bws.dataset_+3A_row.renames">row.renames</code></td>
<td>

<p>A logical variable describing whether or not the row names of a data set created by this function are changed. If <code>TRUE</code>, integer values are assigned to the row names starting from <code>1</code>. If <code>FALSE</code>, the row names are not changed.
</p>
</td></tr>
<tr><td><code id="bws.dataset_+3A_id">id</code></td>
<td>

<p>A character showing the name of the respondent identification number variable used in the respondent data set.
</p>
</td></tr>
<tr><td><code id="bws.dataset_+3A_response">response</code></td>
<td>

<p>A vector containing the names of response variables in the respondent data set, showing the best and worst items selected in each BWS question.
</p>
</td></tr>
<tr><td><code id="bws.dataset_+3A_model">model</code></td>
<td>

<p>A character showing a type of data set created by this function: <code>"maxdiff"</code> for the maxdiff model; <code>"marginal"</code> for the marginal model; and  <code>"sequential"</code> for the marginal sequential model.
</p>
</td></tr>
<tr><td><code id="bws.dataset_+3A_delete.best">delete.best</code></td>
<td>

<p>A logical value denoted by <code>TRUE</code> when deleting an item selected as the best in the worst choice set (that is, using a marginal sequential model) or <code>FALSE</code> when not doing so. The argument is deprecated. Please use the argument <code>model</code> instead.
</p>
</td></tr>
<tr><td><code id="bws.dataset_+3A_version">version</code></td>
<td>

<p>A character showing the name of the version variable used in the respondent dataset and choice sets.
</p>
</td></tr>
<tr><td><code id="bws.dataset_+3A_respondent.dataset">respondent.dataset</code></td>
<td>

<p>A data frame containing a respondent data set. The argument is deprecated. Please use the argument <code>data</code> instead.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The respondent data set, in which each row corresponds to a respondent, has to be organized by users. The data set must contain the id variable in the first column, denoting the respondent's identification number, and the response variables in the subsequent columns, each indicating which items are selected as the best and the worst for each question. Although the names of the id and response variables are up to the discretion of the user, the response variables must be constructed such that the best alternates with the worst by question. For example, when there are seven BWS questions, the variables are <code>B1 W1 B2 W2 ... B7 W7</code>; here, <code>Bi</code> and <code>Wi</code> show which items are selected as the best and the worst in the <code>i</code>th question.
</p>
<p>There are two types of data format related to response variables: one is a row number format, and the other is an item number format. In the former, the row numbers of the items selected as the best and the worst are stored in the response variables. In the latter, item numbers are stored in the response variables.
</p>
<p>The arguments <code>choice.sets</code>, <code>design.type</code>, and <code>item.names</code> are the same as those in the <code>bws.questionnaire()</code> function. However, <code>item.names</code> can take <code>NULL</code> (default), when default item names (i.e., <code>ITEM1</code>, <code>ITEM2</code>, ...) are used in the resultant data set. Further, the order of questions in the choice sets has to be the same as that in the respondent data set.
</p>
<p>The argument <code>version</code> is set when two or more versions of the choice sets are used. The version variable must be included in the respondent dataset and choice sets. The variable denotes the serial integer number of versions starting from 1.
</p>
<p>Note that this function in version 0.2-0 and later versions of the package can create a data set for the marginal (sequential) model as well as that for the maxdiff model: <code>"maxdiff"</code> is assigned to the argument <code>model</code> when the maxdiff model is used for the analysis; <code>"marginal"</code> is assigned when the marginal model is used; and <code>"sequential"</code> is assigned when the marginal sequential model is used. Furthermore, the argument <code>delete.best</code> is deprecated: please use the argument <code>model = "sequential"</code> instead.
</p>


<h3>Value</h3>

<p>This function returns a data set in data frame format for the maxdiff model or one for the marginal (sequential) model. The data set for the maxdiff model contains the following variables:
</p>
<table role = "presentation">
<tr><td><code>ID</code></td>
<td>

<p>A respondent's identification number, assigned according to the id variable in the respondent data set.
</p>
</td></tr>
<tr><td><code>Q</code></td>
<td>

<p>A serial number of BWS questions.
</p>
</td></tr>
<tr><td><code>PAIR</code></td>
<td>

<p>A serial number of possible pairs of the best and worst items for each question.
</p>
</td></tr>
<tr><td><code>BEST</code></td>
<td>

<p>An item number treated as the best in the possible pairs of the best and worst items for each question.
</p>
</td></tr>
<tr><td><code>WORST</code></td>
<td>

<p>An item number treated as the worst in the possible pairs of the best and worst items for each question.
</p>
</td></tr>
<tr><td><code>RES.B</code></td>
<td>

<p>An item number selected as the best by respondents.
</p>
</td></tr> 
<tr><td><code>RES.W</code></td>
<td>

<p>An item number selected as the worst by respondents.
</p>
</td></tr>
<tr><td><code>ITEMj</code></td>
<td>

<p>State variables related to the possible pairs of the best and worst items: <code>1</code> if item <code>j</code> is treated as the best in the possible pair, <code>-1</code> if item <code>j</code> is treated as the worst in the possible pair, and <code>0</code> otherwise. These variables are used as independent variables in the model <code>formula</code> of the <code><a href="survival.html#topic+clogit">clogit</a></code> function in <span class="pkg">survival</span> when analyzing responses to BWS questions.
</p>
</td></tr>
<tr><td><code>RES</code></td>
<td>

<p>Responses to BWS questions: <code>TRUE</code> if a possible pair of the best and worst items is selected by respondents and <code>FALSE</code> otherwise. This variable is used as a dependent variable in the model <code>formula</code> of the <code><a href="survival.html#topic+clogit">clogit</a></code> function in <span class="pkg">survival</span> when analyzing responses to BWS questions.
</p>
</td></tr>
<tr><td><code>STR</code></td>
<td>

<p>A stratification variable identifying each combination of respondent and question. This variable is also used in <code>formula</code> of the <code><a href="survival.html#topic+clogit">clogit</a></code> function with the <code><a href="survival.html#topic+strata">strata</a></code> function.
</p>
</td></tr>
</table>
<p>The data set for the marginal (sequential) model contains the variables <code>ID</code>, <code>Q</code>, <code>RES.B</code>, <code>RES.W</code>, and <code>STR</code> mentioned above and the following variables:
</p>
<table role = "presentation">
<tr><td><code>ALT</code></td>
<td>

<p>A serial number of alternatives for each question.
</p>
</td></tr>
<tr><td><code>BW</code></td>
<td>

<p>A state variable that takes the value of <code>1</code> for the possible best items and <code>-1</code> for the possible worst items.
</p>
</td></tr>
<tr><td><code>Item</code></td>
<td>

<p>An item number treated as the possible best or worst items for each question.
</p>
</td></tr>
<tr><td><code>RES</code></td>
<td>

<p>Response to BWS questions: <code>TRUE</code> if a possible best or worst item is selected by respondents and <code>FALSE</code> otherwise. This variable is used as a dependent variable in the model <code>formula</code> of the <code><a href="survival.html#topic+clogit">clogit</a></code> function in <span class="pkg">survival</span> when analyzing responses to BWS questions.
</p>
</td></tr>
<tr><td><code>ITEMj</code></td>
<td>

<p>State variables that takes the value of <code>1</code> for the possible best items and <code>-1</code> for the possible worst items. These variables are used as independent variables in the model <code>formula</code> of the <code><a href="survival.html#topic+clogit">clogit</a></code> function in <span class="pkg">survival</span> when analyzing responses to BWS questions.
</p>
</td></tr>
</table>
<p>Furthermore, the resultant data set includes respondent characteristic variables when the respondent data set has those variables.
</p>


<h3>Author(s)</h3>

<p>Hideo Aizaki
</p>


<h3>See Also</h3>

<p><code><a href="#topic+support.BWS-package">support.BWS-package</a></code>, <code><a href="DoE.base.html#topic+oa.design">oa.design</a></code>, <code><a href="crossdes.html#topic+find.BIB">find.BIB</a></code>, <code><a href="crossdes.html#topic+isGYD">isGYD</a></code>, <code><a href="survival.html#topic+clogit">clogit</a></code>, <code><a href="survival.html#topic+strata">strata</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## load packages
require(DoE.base) # include oa.design() used to generate a two-level OMED
require(crossdes) # include find.BIB() used to generate a BIBD
require(survival) # include clogit() used to analyze responses

if(getRversion() &gt;= "3.6.0") RNGkind(sample.kind = "Rounding")

## example 1: BWS using a two-level OMED
## suppose that ten respondents answered twelve BWS questions valuing nine items

# create a two-level OMED with nine factors
set.seed(123) # set seed for random number generator
des1 &lt;- oa.design(nfactors = 9, nlevels = 2)
des1 # resultant design with twelve rows, nine columns, and level values of 1 and 2

# set item names, in which the order of elements corresponds to 
#  the order of columns in des1
items1 &lt;- LETTERS[1:9] # item names are "A", "B", ..., "I"

# create questions for BWS
bws.questionnaire(
 choice.sets = des1,
 design.type = 1, # OMED
 item.names = items1)

# set a respondent data set in a row number format
res1 &lt;- data.frame(
 ID  = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10), # id variable
 B1  = c(1, 1, 1, 1, 3, 5, 1, 1, 1, 1),  # best item in question 1
 W1  = c(5, 5, 3, 5, 4, 1, 4, 2, 4, 3),  # worst item in question 1
 B2  = c(1, 3, 1, 4, 1, 2, 3, 2, 1, 2),  # best item in question 2
 W2  = c(5, 5, 5, 5, 3, 5, 1, 4, 4, 5),  # worst item in question 2
 B3  = c(1, 2, 1, 2, 4, 1, 1, 3, 1, 3),  # best item in question 3
 W3  = c(4, 3, 3, 3, 3, 4, 4, 2, 3, 4),  # worst item in question 3
 B4  = c(2, 1, 3, 5, 2, 3, 1, 1, 2, 5),  # best item in question 4
 W4  = c(4, 4, 5, 3, 5, 5, 3, 5, 4, 3),  # worst item in question 4
 B5  = c(2, 3, 3, 2, 2, 2, 2, 1, 3, 2),  # best item in question 5
 W5  = c(4, 4, 4, 4, 3, 4, 4, 4, 4, 3),  # worst item in question 5
 B6  = c(2, 1, 1, 3, 3, 3, 1, 1, 1, 1),  # best item in question 6
 W6  = c(1, 2, 3, 2, 1, 2, 3, 2, 2, 3),  # worst item in question 6
 B7  = c(3, 3, 1, 1, 3, 6, 1, 2, 1, 7),  # best item in question 7
 W7  = c(9, 6, 8, 4, 8, 2, 6, 5, 4, 6),  # worst item in question 7
 B8  = c(2, 1, 2, 2, 2, 1, 1, 3, 1, 1),  # best item in question 8
 W8  = c(3, 3, 3, 3, 4, 4, 4, 4, 3, 4),  # worst item in question 8
 B9  = c(2, 1, 3, 1, 4, 2, 3, 4, 1, 1),  # best item in question 9
 W9  = c(3, 2, 2, 3, 3, 3, 2, 2, 3, 4),  # worst item in question 9
 B10 = c(1, 1, 1, 1, 1, 1, 1, 4, 3, 3),  # best item in question 10
 W10 = c(4, 2, 2, 4, 4, 3, 4, 2, 4, 4),  # worst item in question 10
 B11 = c(2, 1, 3, 3, 3, 2, 1, 2, 2, 4),  # best item in question 11
 W11 = c(1, 4, 4, 1, 1, 4, 4, 4, 1, 1),  # worst item in question 11
 B12 = c(2, 2, 1, 1, 1, 1, 3, 2, 1, 2),  # best item in question 12
 W12 = c(3, 3, 2, 3, 3, 2, 2, 3, 3, 3))  # worst item in question 12

# create a data set for the maxdiff model analysis 
#  by combining the choice sets and respondent data set
dat1 &lt;- bws.dataset(
 respondent.dataset = res1,
 response.type = 1, # row number format
 choice.sets = des1,
 design.type = 1)   # OMED

# analyze responses to BWS questions
# counting approach
bws1 &lt;- bws.count(dat1)
# modeling approach
# note: ITEM5 is excluded from fr1 to normalize its coefficient to zero
fr1 &lt;- RES ~ ITEM1 + ITEM2 + ITEM3 + ITEM4 + ITEM6 + ITEM7 +
             ITEM8 + ITEM9 + strata(STR)
clg1 &lt;- clogit(formula = fr1, data = dat1)
clg1


## example 2: BWS using a balanced incomplete block design
## suppose that ten respondents answered seven BWS questions valuing seven items

# create a BIBD with seven items, four items per question, and seven questions
set.seed(123) # set seed for random number generator
des2 &lt;- find.BIB(trt = 7, k = 4, b = 7)
isGYD(des2)  # check whether the design is a BIBD
des2 # resultant design with seven rows, four columns, and level values ranging from 1 to 7

# set item names, in which the order of element corresponds to 
#  the order of level values in des2
items2 &lt;- LETTERS[1:7]

# create questions for BWS
bws.questionnaire(
 choice.sets = des2,
 design.type = 2, # BIBD
 item.names = items2)

# set a respondent data set in a row number format
res2 &lt;- data.frame(
 ID = c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10), # id variable
 B1 = c(2, 1, 2, 4, 2, 2, 2, 1, 2, 1),  # best item in question 1
 W1 = c(3, 4, 3, 3, 1, 3, 3, 2, 3, 3),  # worst item in question 1
 B2 = c(4, 3, 3, 3, 3, 1, 1, 2, 1, 1),  # best item in question 2
 W2 = c(3, 2, 4, 1, 2, 3, 3, 4, 2, 4),  # worst item in question 2
 B3 = c(3, 1, 1, 1, 1, 1, 1, 1, 2, 1),  # best item in question 3
 W3 = c(1, 4, 2, 2, 4, 4, 2, 3, 3, 3),  # worst item in question 3
 B4 = c(2, 2, 1, 3, 2, 2, 2, 2, 4, 1),  # best item in question 4
 W4 = c(4, 4, 3, 4, 1, 3, 4, 1, 2, 4),  # worst item in question 4
 B5 = c(1, 3, 2, 1, 3, 2, 1, 1, 1, 1),  # best item in question 5
 W5 = c(3, 1, 4, 4, 1, 4, 3, 2, 4, 3),  # worst item in question 5
 B6 = c(2, 1, 1, 3, 2, 4, 4, 3, 3, 3),  # best item in question 6
 W6 = c(3, 2, 3, 4, 3, 2, 2, 4, 4, 2),  # worst item in question 6
 B7 = c(2, 1, 3, 1, 3, 2, 3, 3, 2, 2),  # best item in question 7
 W7 = c(4, 4, 4, 4, 4, 1, 4, 1, 4, 4))  # worst item in question 7

# create a data set for the maxdiff model analysis
#  by combining the choice sets and respondent data set
dat2 &lt;- bws.dataset(
 respondent.dataset = res2,
 response.type = 1,   # row number format
 choice.sets = des2,
 design.type = 2,     # BIBD
 item.names = items2) # state variables are labeled using item names

# analyze responses to BWS questions
# counting approach
bws2 &lt;- bws.count(dat2)
bws2
# the argument cl is set to 2 to generaet a data set
#  of the S3 class 'bws.count2'
bws2.2 &lt;- bws.count(dat2, cl = 2)
plot(bws2.2, score = "bw")
barplot(bws2.2, score = "bw")
sum(bws2.2)
summary(bws2.2)
# modeling approach
# note: D is excluded from fr2 to normalized its coefficient to zero
fr2 &lt;- RES ~ A + B + C + E + F + G + strata(STR)
clg2 &lt;- clogit(fr2, data = dat2)
clg2
bws.sp(clg2, base = "D", order = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='bws.questionnaire'>
Converting a two-level OMED/BIBD into BWS questions
</h2><span id='topic+bws.questionnaire'></span>

<h3>Description</h3>

<p>This function converts a two-level orthogonal main-effect design (OMED)/balanced incomplete block design (BIBD) into a series of BWS questions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bws.questionnaire(choice.sets, design.type, item.names)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bws.questionnaire_+3A_choice.sets">choice.sets</code></td>
<td>

<p>A data frame or matrix containing choice sets.
</p>
</td></tr>
<tr><td><code id="bws.questionnaire_+3A_design.type">design.type</code></td>
<td>

<p>A value describing how to design the choice sets: <code>1</code> if the design assigned to <code>choice.sets</code> is a two-level OMED, and <code>2</code> if it is a BIBD.
</p>
</td></tr>
<tr><td><code id="bws.questionnaire_+3A_item.names">item.names</code></td>
<td>

<p>A vector containing the names of items shown in the questions.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A two-level OMED/BIBD is assigned to <code>choice.sets</code>, and may be generated by R functions (e.g., the <code><a href="DoE.base.html#topic+oa.design">oa.design</a></code> function in <span class="pkg">DoE.base</span>; the <code><a href="crossdes.html#topic+find.BIB">find.BIB</a></code> function in <span class="pkg">crossdes</span>) or copied manually from text books/web sites related to the design of experiments.
</p>
<p>When the design is a two-level OMED, each row corresponds to a question and each column corresponds to an item. The level values in the design have to be 1 and 2. The former corresponds to an item being &ldquo;absent&rdquo; from a column and the latter corresponds to the item being &ldquo;present.&rdquo; The correspondence between item names and columns is defined and assigned to the argument <code>item.names</code>: the order of names in the vector assigned to <code>item.names</code> corresponds to the order of columns (from left to right) in the choice sets assigned to <code>choice.sets</code>.
</p>
<p>When the design is a BIBD, each row corresponds to a question and the number of columns is equal to the number of items per question. The level values in the design have to be serial integer values, starting from 1: each value corresponds to an item. The correspondence between item names and level values is defined and assigned to the argument <code>item.names</code>: the order of names in <code>item.names</code> corresponds to the order of level values in the design (i.e., the <code class="reqn">j</code> th item in <code>item.names</code> corresponds to the level value of <code class="reqn">j</code> in the design).
</p>


<h3>Value</h3>

<p>BWS questions converted from the design are returned.
</p>


<h3>Author(s)</h3>

<p>Hideo Aizaki
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bws.dataset">bws.dataset</a></code>, <code><a href="DoE.base.html#topic+oa.design">oa.design</a></code>, <code><a href="crossdes.html#topic+find.BIB">find.BIB</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See examples in bws.dataset()
</code></pre>

<hr>
<h2 id='bws.response'>
Generating artificial responses to Case 1 best-worst scaling questions
</h2><span id='topic+bws.response'></span>

<h3>Description</h3>

<p>This function synthesizes responses to Case 1 best-worst scaling (BWS) questions on the basis of a maximum difference model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bws.response(design, item.names = NULL, b, n, detail = FALSE,
             seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bws.response_+3A_design">design</code></td>
<td>

<p>A matrix or data frame containing a balanced incomplete block design (BIBD).
</p>
</td></tr>
<tr><td><code id="bws.response_+3A_item.names">item.names</code></td>
<td>

<p>A character vector containing the names of items: if <code>NULL</code> (default), default names (i.e., <code>ITEM1</code>, <code>ITEM2</code>, ...) are used in the resultant dataset. The argument is valid for the dataset in a detailed format.
</p>
</td></tr>
<tr><td><code id="bws.response_+3A_b">b</code></td>
<td>

<p>A vector containing parameters of independent variables in the model. The vector is used to calculate utilities for alternatives.
</p>
</td></tr>
<tr><td><code id="bws.response_+3A_n">n</code></td>
<td>

<p>An integer value showing the number of respondents in the resultant dataset.
</p>
</td></tr>
<tr><td><code id="bws.response_+3A_detail">detail</code></td>
<td>

<p>A logical variable: if <code>TRUE</code>, the dataset is returned in a detailed format; and if <code>FALSE</code> (default), the dataset is returned in a simple format.
</p>
</td></tr>
<tr><td><code id="bws.response_+3A_seed">seed</code></td>
<td>

<p>Seed for a random number generator.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function synthesizes responses to Case 1 BWS questions on the basis of a maximum difference model. The model assumes that there are <code class="reqn">m</code> items to be evaluated, and that <code class="reqn">k</code> (<code class="reqn">&lt; m</code>) items exist in a choice set (a question). The number of possible pairs where item <code class="reqn">i</code> is selected as the best and item <code class="reqn">j</code> is selected as the worst (<code class="reqn">i \neq j</code>) from <code class="reqn">k</code> items is given by <code class="reqn">k \times (k - 1)</code>. The model also assumes that the respondents select item <code class="reqn">i</code> as the best and item <code class="reqn">j</code> as the worst because the difference in utility between items <code class="reqn">i</code> and <code class="reqn">j</code> is the highest among all of the <code class="reqn">k \times (k - 1)</code> differences in utility. The systematic component of the utility is assumed to be a linear additive function of the item variables. If the error component of the utility is assumed to be an independently, identically distributed type I extreme value, the probability of selecting item <code class="reqn">i</code> as the best and item <code class="reqn">j</code> as the worst is expressed as a conditional logit model.
</p>
<p>Given the parameter values assigned to the argument <code>b</code>, and the choice sets assigned to the argument <code>design</code>, the function <code>bws.response</code> calculates the utility for the items. The parameter values assigned to the argument <code>b</code> are set as a numerical vector where the elements correspond to the parameters of item variables. For example, assume that seven items A, B, C, D, E, F, and G exist in the list for evaluation, and their corresponding dummy-coded item variables <code class="reqn">D_{A}</code>, <code class="reqn">D_{B}</code>, <code class="reqn">D_{C}</code>, <code class="reqn">D_{D}</code>, <code class="reqn">D_{E}</code>, and <code class="reqn">D_{G}</code> (item F is assumed to be the reference item) have parameter values of 0.5, 1.2, 1.6, 1.8, 2.1, and 0.9, respectively. A vector assigned to the argument <code>b</code> is <code>c(0.5, 1.2, 1.6, 1.8, 2.1, 0, 0.9)</code>, where the sixth element (i.e., item F) corresponds to the reference level, and thus has a value of <code>0</code>. After calculating the utility values (by adding the calculated values of the systematic component of the utility and random numbers generated from a type I extreme value distribution), the function <code>bws.response</code> finds the pair with the highest difference in utility from the <code class="reqn">k \times (k - 1)</code> differences in utility.
</p>


<h3>Value</h3>

<p>The function <code>bws.response</code> returns a data frame that contains synthesized responses to Case 1 BWS questions, in either a detailed or a simple format. The detailed format dataset contains the following variables, as well as independent variables according to the argument <code>item.names</code>.
</p>
<table role = "presentation">
<tr><td><code>id</code></td>
<td>
<p>An identification number of artificial respondents.</p>
</td></tr>
<tr><td><code>Q</code></td>
<td>
<p>A serial number of questions.</p>
</td></tr>
<tr><td><code>PAIR</code></td>
<td>
<p>A serial number of possible pairs of the best and worst items for each question.</p>
</td></tr>
<tr><td><code>BEST</code></td>
<td>
<p>An item number treated as the best in the possible pairs of the best and worst items for each question.</p>
</td></tr>
<tr><td><code>WORST</code></td>
<td>
<p>An item number treated as the worst in the possible pairs of the best and worst items for each question.</p>
</td></tr>
<tr><td><code>RES</code></td>
<td>
<p>Responses to BWS questions, taking the value of 1 if a possible pair of the best and worst items is selected by the synthesized respondents and 0 otherwise.</p>
</td></tr>
<tr><td><code>STR</code></td>
<td>
<p>A stratification variable used to identify each combination of respondent and question.</p>
</td></tr>
</table>
<p>The simple format dataset contains the following variables.
</p>
<table role = "presentation">
<tr><td><code>id</code></td>
<td>
<p>An identification number of artificial respondents.</p>
</td></tr>
<tr><td><code>Bi</code></td>
<td>
<p>A variable describing the row number of the item that is selected as the best in the <code class="reqn">i</code>-th BWS question (see the help for <code><a href="#topic+bws.dataset">bws.dataset</a></code> for a row number format). The serial number of questions is appended to the tail of the variable name (e.g., <code>B1</code> for the first question, <code>B2</code> for the second question, and <code>B3</code> for the third question).</p>
</td></tr>
<tr><td><code>Wi</code></td>
<td>
<p>A variable describing the row number of the item that is selected as the worst in the <code class="reqn">i</code>-th BWS question (see the help for <code><a href="#topic+bws.dataset">bws.dataset</a></code> for a row number format). The serial number of questions is appended to the tail of the variable name (e.g., <code>W1</code> for the first question, <code>W2</code> for the second question, and <code>W3</code> for the third question).</p>
</td></tr>
</table>
<p>The detailed format dataset includes a dependent variable and independent variables for the analysis, and thus is available for discrete choice analysis functions such as the function <code>clogit</code> in the <b>survival</b> package. On the other hand, the simple format dataset only contains variables that correspond to responses to BWS questions, as well as <code>id</code> variable. It must be converted using the function <code>bws.dataset</code> in the package for the analysis. For details, see the Example section.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+support.BWS-package">support.BWS-package</a></code>, <code><a href="#topic+bws.dataset">bws.dataset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The following lines of code synthesize responses to Case 1 BWS questions,
# return them in detailed and simple format, and then fit the models using
# the function clogit in the survival package. The questions evaluate seven
# items. The choice sets consist of seven questions with four items each.
# The function find.BIB in the crossdes package creates the corresponding
# BIBD with seven treatments, seven blocks, and size four. The systematic
# component of the utility for items is the same as that explained in the
# Details section.

## Not run: 
# Load packages
library(survival)
library(crossdes)

# Generate BIBD
set.seed(123)
bibd &lt;- find.BIB(trt = 7, b = 7, k = 4)
isGYD(bibd)
bibd

# Synthesize responses to Case 1 BWS questions
b &lt;- c(0.5, 1.2, 1.6, 1.8, 2.1, 0, 0.9)
items = c("A", "B", "C", "D", "E", "F", "G")
dat.detail &lt;- bws.response(
  design = bibd, item.names = items,
  b = b, n = 100,
  detail = TRUE, seed = 123)
str(dat.detail)
dat.simple &lt;- bws.response(
  design = bibd,
  b = b, n = 100,
  detail = FALSE, seed = 123)
str(dat.simple)

# Convert dat.simple into dataset for the analysis
response.vars &lt;- colnames(dat.simple)[-1]
dat.simple.md &lt;- bws.dataset(
  respondent.dataset = dat.simple,
  response.type = 1,
  choice.sets = bibd,
  design.type = 2,
  item.names = items,
  id = "id",
  response = response.vars,
  model = "maxdiff")

# Fit conditional logit models
mf &lt;- RES ~ A + B + C + D + E + G + strata(STR)
out.detail &lt;- clogit(mf, dat.detail)
out.simple &lt;- clogit(mf, dat.simple.md)
out.simple
all.equal(coef(out.detail), coef(out.simple))

## End(Not run)
</code></pre>

<hr>
<h2 id='bws.sp'>
Calculating shares of preference
</h2><span id='topic+bws.sp'></span>

<h3>Description</h3>

<p>This function calculates shares of preference for each item based on the conditional logit model choice rule.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bws.sp(object, base, coef = NULL, order = FALSE, decreasing = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bws.sp_+3A_object">object</code></td>
<td>

<p>An output from the function <code><a href="survival.html#topic+clogit">clogit</a></code> in <span class="pkg">survival</span> or vector/matrix/data frame containing estimates.
</p>
</td></tr>
<tr><td><code id="bws.sp_+3A_base">base</code></td>
<td>

<p>A character showing the base item.
</p>
</td></tr>
<tr><td><code id="bws.sp_+3A_coef">coef</code></td>
<td>

<p>A vector containing the names of item variables used in the model.
</p>
</td></tr>
<tr><td><code id="bws.sp_+3A_order">order</code></td>
<td>

<p>A logical value denoted by <code>TRUE</code> when the resultant shares are sorted or <code>FALSE</code> when not doing so.
</p>
</td></tr>
<tr><td><code id="bws.sp_+3A_decreasing">decreasing</code></td>
<td>

<p>A logical value denoted by <code>TRUE</code> when the sort order is decreasing, or <code>FALSE</code> when it is increasing.
</p>
</td></tr>
<tr><td><code id="bws.sp_+3A_...">...</code></td>
<td>

<p>Arguments passed to a function used internally.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates a share of preference for item <code class="reqn">i</code>. For details on the shares of preference, refer to <code><a href="#topic+support.BWS-package">support.BWS-package</a></code>. Althoug this function is developed for the function <code><a href="survival.html#topic+clogit">clogit</a></code> in the <span class="pkg">survival</span>, it may be available for other functions regarding discrete choice models. This function assumes a simple model without covariates.
</p>


<h3>Value</h3>

<p>A vector or data frame containing the calculated shares of preference for each item is returned.
</p>


<h3>Author(s)</h3>

<p>Hideo Aizaki
</p>


<h3>See Also</h3>

<p><code><a href="#topic+support.BWS-package">support.BWS-package</a></code>, <code><a href="#topic+bws.dataset">bws.dataset</a></code>, <code><a href="survival.html#topic+clogit">clogit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See examples in bws.dataset()
</code></pre>

<hr>
<h2 id='fruit'>
Synthetic respondent data set: consumers' preferences for fruits
</h2><span id='topic+fruit'></span>

<h3>Description</h3>

<p>Data set artificially created for an example based on a BIBD. This example illustrates consumers' preferences for seven fruits: apple, orange, grapes, banana, peach, melon, and pear.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fruit)
</code></pre>


<h3>Format</h3>

<p>A data frame with 100 respondents on the following 15 variables.
</p>

<dl>
<dt><code>ID</code></dt><dd><p>Identification number of respondents.</p>
</dd>
<dt><code>B1</code></dt><dd><p>Item selected as the best in question 1.</p>
</dd>
<dt><code>W1</code></dt><dd><p>Item selected as the worst in question 1.</p>
</dd>
<dt><code>B2</code></dt><dd><p>Item selected as the best in question 2.</p>
</dd>
<dt><code>W2</code></dt><dd><p>Item selected as the worst in question 2.</p>
</dd>
<dt><code>B3</code></dt><dd><p>Item selected as the best in question 3.</p>
</dd>
<dt><code>W3</code></dt><dd><p>Item selected as the worst in question 3.</p>
</dd>
<dt><code>B4</code></dt><dd><p>Item selected as the best in question 4.</p>
</dd>
<dt><code>W4</code></dt><dd><p>Item selected as the worst in question 4.</p>
</dd>
<dt><code>B5</code></dt><dd><p>Item selected as the best in question 5.</p>
</dd>
<dt><code>W5</code></dt><dd><p>Item selected as the worst in question 5.</p>
</dd>
<dt><code>B6</code></dt><dd><p>Item selected as the best in question 6.</p>
</dd>
<dt><code>W6</code></dt><dd><p>Item selected as the worst in question 6.</p>
</dd>
<dt><code>B7</code></dt><dd><p>Item selected as the best in question 7.</p>
</dd>
<dt><code>W7</code></dt><dd><p>Item selected as the worst in question 7.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Hideo Aizaki
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bws.dataset">bws.dataset</a></code>, <code><a href="crossdes.html#topic+find.BIB">find.BIB</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The following BIBD is generated using find.BIB()
# in the crossdes package:
#  set.seed(123)
#  find.BIB(trt = 7, k = 4, b = 7)
sets.fruit &lt;- cbind(
  c(1,2,2,1,1,3,1),
  c(4,3,4,2,3,5,2),
  c(6,4,5,5,4,6,3),
  c(7,6,7,6,5,7,7)) 
items.fruit &lt;- c(
  "Apple",
  "Orange",
  "Grapes",
  "Banana",
  "Peach",
  "Melon",
  "Pear")
bws.questionnaire(
  choice.sets = sets.fruit,
  design.type = 2,
  item.names = items.fruit)
data(fruit)
data.fruit &lt;- bws.dataset(
  respondent.dataset = fruit,
  response.type = 1,
  choice.sets = sets.fruit,
  design.type = 2,
  item.names = items.fruit)
count.fruit &lt;- bws.count(data = data.fruit)
count.fruit
</code></pre>

<hr>
<h2 id='mfa'>
Synthetic respondent data set: citizens' preferences for the multifunctionality of agriculture
</h2><span id='topic+mfa'></span>

<h3>Description</h3>

<p>Data set artificially created for an example based on a two-level OMED. This example illustrates citizens' preferences for the multifunctionality of agriculture: landscape, biodiversity, water use, land conservation, flood control, rural viability, food security, animal welfare, and cultural heritage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mfa)
</code></pre>


<h3>Format</h3>

<p>A data frame with 100 respondents on the following 25 variables.
</p>

<dl>
<dt><code>ID</code></dt><dd><p>Identification number of respondents.</p>
</dd>
<dt><code>B1</code></dt><dd><p>Item selected as the best in question 1.</p>
</dd>
<dt><code>W1</code></dt><dd><p>Item selected as the worst in question 1.</p>
</dd>
<dt><code>B2</code></dt><dd><p>Item selected as the best in question 2.</p>
</dd>
<dt><code>W2</code></dt><dd><p>Item selected as the worst in question 2.</p>
</dd>
<dt><code>B3</code></dt><dd><p>Item selected as the best in question 3.</p>
</dd>
<dt><code>W3</code></dt><dd><p>Item selected as the worst in question 3.</p>
</dd>
<dt><code>B4</code></dt><dd><p>Item selected as the best in question 4.</p>
</dd>
<dt><code>W4</code></dt><dd><p>Item selected as the worst in question 4.</p>
</dd>
<dt><code>B5</code></dt><dd><p>Item selected as the best in question 5.</p>
</dd>
<dt><code>W5</code></dt><dd><p>Item selected as the worst in question 5.</p>
</dd>
<dt><code>B6</code></dt><dd><p>Item selected as the best in question 6.</p>
</dd>
<dt><code>W6</code></dt><dd><p>Item selected as the worst in question 6.</p>
</dd>
<dt><code>B7</code></dt><dd><p>Item selected as the best in question 7.</p>
</dd>
<dt><code>W7</code></dt><dd><p>Item selected as the worst in question 7.</p>
</dd>
<dt><code>B8</code></dt><dd><p>Item selected as the best in question 8.</p>
</dd>
<dt><code>W8</code></dt><dd><p>Item selected as the worst in question 8.</p>
</dd>
<dt><code>B9</code></dt><dd><p>Item selected as the best in question 9.</p>
</dd>
<dt><code>W9</code></dt><dd><p>Item selected as the worst in question 9.</p>
</dd>
<dt><code>B10</code></dt><dd><p>Item selected as the best in question 10.</p>
</dd>
<dt><code>W10</code></dt><dd><p>Item selected as the worst in question 10.</p>
</dd>
<dt><code>B11</code></dt><dd><p>Item selected as the best in question 11.</p>
</dd>
<dt><code>W11</code></dt><dd><p>Item selected as the worst in question 11.</p>
</dd>
<dt><code>B12</code></dt><dd><p>Item selected as the best in question 12.</p>
</dd>
<dt><code>W12</code></dt><dd><p>Item selected as the worst in question 12.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Hideo Aizaki
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bws.dataset">bws.dataset</a></code>, <code><a href="DoE.base.html#topic+oa.design">oa.design</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The following OA is generated using oa.design()
# in the DoE.base package:
#  set.seed(123)
#  oa.design(nfactors = 9, nlevels = 2)
sets.mfa &lt;- cbind(
  c(1,2,1,2,2,1,2,2,1,1,1,2),
  c(2,1,2,1,2,1,2,2,1,1,2,1),
  c(1,2,1,1,2,1,2,1,2,2,2,1),
  c(1,2,2,2,1,2,2,1,1,1,2,1),
  c(2,2,2,1,1,1,2,1,2,1,1,2),
  c(1,1,2,2,1,1,2,2,2,2,1,1),
  c(2,1,1,2,2,2,2,1,2,1,1,1),
  c(2,1,1,2,1,1,2,1,1,2,2,2),
  c(2,2,1,1,1,2,2,2,1,2,1,1))
items.mfa &lt;- c(
  "Landscape",
  "Biodiversity",
  "Water use",
  "Land conservation",
  "Flood control",
  "Rural viability",
  "Food security",
  "Animal welfare",
  "Cultural heritage")
bws.questionnaire(
  choice.sets = sets.mfa,
  design.type = 1,
  item.names = items.mfa)
data(mfa)
data.mfa &lt;- bws.dataset(
  respondent.dataset = mfa,
  response.type = 1,
  choice.sets = sets.mfa,
  design.type = 1,
  item.names = items.mfa)
count.mfa &lt;- bws.count(data = data.mfa)
count.mfa
</code></pre>

<hr>
<h2 id='ricebws1'>
Consumers' preferences for rice characteristics
</h2><span id='topic+ricebws1'></span>

<h3>Description</h3>

<p>This dataset contains responses to Case 1 BWS questions about consumers' preferences for rice characteristics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ricebws1)
</code></pre>


<h3>Format</h3>

<p>A data frame with 90 respondents on the following 18 variables.
</p>

<dl>
<dt><code>id</code></dt><dd><p>Identification number of respondents.</p>
</dd>
<dt><code>b1</code></dt><dd><p>Item selected as the best in BWS question 1.</p>
</dd>
<dt><code>w1</code></dt><dd><p>Item selected as the worst in BWS question 1.</p>
</dd>
<dt><code>b2</code></dt><dd><p>Item selected as the best in BWS question 2.</p>
</dd>
<dt><code>w2</code></dt><dd><p>Item selected as the worst in BWS question 2.</p>
</dd>
<dt><code>b3</code></dt><dd><p>Item selected as the best in BWS question 3.</p>
</dd>
<dt><code>w3</code></dt><dd><p>Item selected as the worst in BWS question 3.</p>
</dd>
<dt><code>b4</code></dt><dd><p>Item selected as the best in BWS question 4.</p>
</dd>
<dt><code>w4</code></dt><dd><p>Item selected as the worst in BWS question 4.</p>
</dd>
<dt><code>b5</code></dt><dd><p>Item selected as the best in BWS question 5.</p>
</dd>
<dt><code>w5</code></dt><dd><p>Item selected as the worst in BWS question 5.</p>
</dd>
<dt><code>b6</code></dt><dd><p>Item selected as the best in BWS question 6.</p>
</dd>
<dt><code>w6</code></dt><dd><p>Item selected as the worst in BWS question 6.</p>
</dd>
<dt><code>b7</code></dt><dd><p>Item selected as the best in BWS question 7.</p>
</dd>
<dt><code>w7</code></dt><dd><p>Item selected as the worst in BWS question 7.</p>
</dd>
<dt><code>age</code></dt><dd><p>Respondents' age: 1 = &lt;40; 2 = 40-&lt;60; 3 = &gt;=60</p>
</dd>
<dt><code>hp</code></dt><dd><p>Highest price of rice per 5 kg that respondents have purchased for the last six months: 1 = &lt; 1600 JPY; 2 = 1600-&lt;2100; 3 = &gt;=2100</p>
</dd>
<dt><code>chem</code></dt><dd><p>Respondents' valuation of rice grown with low-chemicals: 1 if respondents value low-chemical rice and 0 otherwise</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Hideo Aizaki
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bws.dataset">bws.dataset</a></code>, <code><a href="crossdes.html#topic+find.BIB">find.BIB</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Respondents were asked to select their most and least important
# characteristics of rice when purchasing rice. Rice characteristics
# were assumed to be place of origin, variety, price, taste, safety,
# wash-free rice, and milling date. BWS questions were created from
# a balanced incomplete block design (BIBD) with seven treatments
# (items), four columns (four items per question), and seven rows
# (seven questions).

# Generate the BIBD using find.BIB() in the crossdes package:
require("crossdes")
set.seed(8041)
bibd.ricebws1 &lt;- find.BIB(trt = 7, b = 7, k = 4)
isGYD(bibd.ricebws1)
bibd.ricebws1

# Store rice characteristics used in the survey to items.ricebws1:
items.ricebws1 &lt;- c(
  "Place_of_origin",
  "Variety",
  "Price",
  "Taste",
  "Safety",
  "Washfree_rice",
  "Milling_date")

# Convert the BIBD into the BWS questions:
bws.questionnaire(bibd.ricebws1, design.type = 2,
  item.names = items.ricebws1)

# Load the dataset ricebws1 containing the responses to 
# the BWS questions:
data("ricebws1", package = "support.BWS")
dim(ricebws1)
names(ricebws1)

# Create the dataset for the analysis:
data.ricebws1 &lt;- bws.dataset(
  respondent.dataset = ricebws1,
  response.type = 1,
  choice.sets = bibd.ricebws1,
  design.type = 2,
  item.names = items.ricebws1)

# Calculate BW scores:
count.ricebws1 &lt;- bws.count(data = data.ricebws1)
count.ricebws1
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
