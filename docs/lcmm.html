<!DOCTYPE html><html lang="en"><head><title>Help for package lcmm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lcmm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#lcmm-package'><p>Estimation of extended mixed models using latent classes and latent</p>
processes.</a></li>
<li><a href='#cuminc'><p>Predicted cumulative incidence of event according to a profile of covariates</p></a></li>
<li><a href='#data_hlme'><p>Simulated dataset for hlme function</p></a></li>
<li><a href='#data_lcmm'><p>Simulated dataset for lcmm and Jointlcmm functions</p></a></li>
<li><a href='#Diffepoce'><p>Difference of expected prognostic cross-entropy (EPOCE) estimators and its</p>
95% tracking interval between two joint latent class models estimated with
<code>Jointlcmm</code></a></li>
<li><a href='#dynpred'><p>Individual dynamic predictions from a joint latent class model</p></a></li>
<li><a href='#epoce'><p>Estimators of the Expected Prognostic Observed Cross-Entropy (EPOCE) for</p>
evaluating predictive accuracy of joint latent class models estimated using
<code>Jointlcmm</code></a></li>
<li><a href='#estimates'><p>Maximum likelihood estimates</p></a></li>
<li><a href='#externVar'><p>Estimation of a secondary regression model after the estimation of a primary latent class model</p></a></li>
<li><a href='#fitY'><p>Marginal predictions of the longitudinal outcome(s) in their natural scale</p>
from <code>lcmm</code>, <code>Jointlcmm</code> or <code>multlcmm</code> objects</a></li>
<li><a href='#ForInternalUse'><p>For internal use only ...</p></a></li>
<li><a href='#gridsearch'><p>Automatic grid search</p></a></li>
<li><a href='#hlme'><p>Estimation of latent class linear mixed models</p></a></li>
<li><a href='#ItemInfo'><p>Conditional probabilities and item information given specified latent process values</p>
for <code>lcmm</code> or <code>multlcmm</code>
object with ordinal outcomes.</a></li>
<li><a href='#Jointlcmm'><p>Estimation of joint latent class models for longitudinal and time-to-event</p>
data</a></li>
<li><a href='#lcmm'><p>Estimation of mixed-effect models and latent class mixed-effect models for</p>
different types of outcomes (continuous Gaussian, continuous non-Gaussian or
ordinal)</a></li>
<li><a href='#loglik'><p>Wrapper to the Fortran subroutines computing the log-likelihood</p></a></li>
<li><a href='#mpjlcmm'><p>Estimation of multivariate joint latent class mixed models</p></a></li>
<li><a href='#multlcmm'><p>Estimation of multivariate mixed-effect models and multivariate latent class</p>
mixed-effect models for multivariate longitudinal outcomes of possibly
multiple types (continuous Gaussian, continuous non-Gaussian/curvilinear, ordinal)
that measure the same underlying latent process.</a></li>
<li><a href='#paquid'><p>Longitudinal data on cognitive and physical aging in the elderly</p></a></li>
<li><a href='#permut'><p>Permutation of the latent classes</p></a></li>
<li><a href='#plot'><p>Plot of a fitted model</p></a></li>
<li><a href='#plot.cuminc'><p>Plot of predicted cumulative incidences according to a profile of covariates</p></a></li>
<li><a href='#plot.Diffepoce'><p>Plots</p></a></li>
<li><a href='#plot.dynpred'><p>Plot of individual dynamic predictions</p></a></li>
<li><a href='#plot.ItemInfo'><p>Plot of information functions</p></a></li>
<li><a href='#plot.predict'><p>Plot of predicted trajectories and link functions</p></a></li>
<li><a href='#postprob'><p>Posterior classification stemmed from a <code>hlme</code>, <code>lcmm</code>,</p>
<code>multlcmm</code> or <code>Jointlcmm</code> estimation</a></li>
<li><a href='#predictClass'><p>Posterior classification and class-membership probabilities</p></a></li>
<li><a href='#predictL'><p>Class-specific marginal predictions in the latent process scale for</p>
<code>lcmm</code>, <code>Jointlcmm</code> and <code>multlcmm</code> objects</a></li>
<li><a href='#predictlink'><p>Confidence intervals for the estimated link functions from <code>lcmm</code>,</p>
<code>Jointlcmm</code> and <code>multlcmm</code></a></li>
<li><a href='#predictRE'><p>Predictions of the random-effects</p></a></li>
<li><a href='#predictY'><p>Predictions (marginal and possibly subject-specific in some cases) of a <code>hlme</code>,</p>
<code>lcmm</code>, <code>multlcmm</code> or <code>Jointlcmm</code> object in the natural scale
of the longitudinal outcome(s) computed from a profile of covariates (marginal) or
individual data (subject specific in case of <code>hlme</code>).</a></li>
<li><a href='#predictYback'><p>Marginal predictions in the natural scale of a pre-transformed outcome</p></a></li>
<li><a href='#predictYcond'><p>Conditional predictions of a <code>lcmm</code>, <code>multlcmm</code> or <code>Jointlcmm</code></p>
object in the natural scale of the longitudinal outcome(s) for specified
latent process values.</a></li>
<li><a href='#print.lcmm'><p>Brief summary of a <code>hlme</code>, <code>lcmm</code>,</p>
<code>Jointlcmm</code>,<code>multlcmm</code>, <code>epoce</code> or <code>Diffepoce</code> objects</a></li>
<li><a href='#simdataHADS'><p>Simulated dataset simdataHADS</p></a></li>
<li><a href='#simulate.lcmm'><p>Data simulation according to models from lcmm package</p></a></li>
<li><a href='#StandardMethods'><p>Standard methods for estimated models</p></a></li>
<li><a href='#summary.lcmm'><p>Summary of a <code>hlme</code>, <code>lcmm</code>, <code>Jointlcmm</code>, <code>multlcmm</code>,</p>
<code>mpjlcmm</code>, <code>externSurv</code>, <code>externX</code>
<code>epoce</code> or <code>Diffepoce</code> objects</a></li>
<li><a href='#summaryplot'><p>Summary of models</p></a></li>
<li><a href='#summarytable'><p>Summary of models</p></a></li>
<li><a href='#update.mpjlcmm'><p>Update the longitudinal submodels</p></a></li>
<li><a href='#VarCov'><p>Variance-covariance of the estimates</p></a></li>
<li><a href='#VarCovRE'><p>Estimates, standard errors and Wald test for the parameters of the</p>
variance-covariance matrix of the random effects.</a></li>
<li><a href='#VarExpl'><p>Percentage of variance explained by the (latent class) linear mixed model</p>
regression</a></li>
<li><a href='#WaldMult'><p>Multivariate Wald Test</p></a></li>
<li><a href='#xclass'><p>Cross classifications</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Extended Mixed Models Using Latent Classes and Latent Processes</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-02-12</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimation of various extensions of the mixed models including latent class mixed models, joint latent class mixed models, mixed models for curvilinear outcomes, mixed models for multivariate longitudinal outcomes using a maximum likelihood estimation method (Proust-Lima, Philipps, Liquet (2017) &lt;<a href="https://doi.org/10.18637%2Fjss.v078.i02">doi:10.18637/jss.v078.i02</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2.0)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>nlme, survival (&ge; 2.37-2), parallel, mvtnorm, spacefillr,
marqLevAlg (&gt; 2.0), doParallel, numDeriv</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr,rmarkdown,lattice,NormPsy</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://cecileproust-lima.github.io/lcmm/">https://cecileproust-lima.github.io/lcmm/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/CecileProust-Lima/lcmm/issues">https://github.com/CecileProust-Lima/lcmm/issues</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-12 15:27:03 UTC; vp3</td>
</tr>
<tr>
<td>Author:</td>
<td>Cecile Proust-Lima [aut, cre],
  Viviane Philipps [aut],
  Amadou Diakite [ctb],
  Benoit Liquet [ctb],
  Alan Genz [ctb] (Author of hrmsym subroutine),
  John Burkardt [ctb] (Author of alnorm subroutine)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Cecile Proust-Lima &lt;cecile.proust-lima@inserm.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-12 17:50:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='lcmm-package'>Estimation of extended mixed models using latent classes and latent
processes.</h2><span id='topic+lcmm-package'></span>

<h3>Description</h3>

<p>Functions for the estimation of latent class mixed models (LCMM), joint
latent class mixed models for longitudinal and survival data (JLCM)
and latent process mixed models (with or without latent classes of trajectory) 
for univariate and multivariate longitudinal outcomes of different types 
including curvilinear and ordinal outcomes. 
All the models are estimated in a maximum likelihood framework using an 
iterative algorithm. The package also provides various post fit functions.
</p>


<h3>Details</h3>



<table>
<tr>
 <td style="text-align: left;"> Package: </td><td style="text-align: left;"> lcmm </td>
</tr>
<tr>
 <td style="text-align: left;"> Type: </td><td style="text-align: left;"> Package </td>
</tr>
<tr>
 <td style="text-align: left;"> 
Version: </td><td style="text-align: left;"> 2.2.1 </td>
</tr>
<tr>
 <td style="text-align: left;"> 
Date: </td><td style="text-align: left;"> 2025-02-12</td>
</tr>
<tr>
 <td style="text-align: left;"> 
License: </td><td style="text-align: left;"> GPL (&gt;=2.0) </td>
</tr>
<tr>
 <td style="text-align: left;"> LazyLoad: </td><td style="text-align: left;"> yes </td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>

<p>The package includes for the moment the estimation of :
</p>
 <ul>
<li><p> latent class mixed models for Gaussian longitudinal outcomes
using <code>hlme</code> function, </p>
</li>
<li><p> latent class mixed models for other
quantitative, bounded quantitative (curvilinear) and discrete (ordinal/binary) longitudinal
outcomes using <code>lcmm</code> function, </p>
</li>
<li><p> mixed models (with and without latent classes) for
multivariate longitudinal outcomes of different nature using
<code>multlcmm</code> function (this includes a longitudinal IRT model for homogeneous and heterogeneous data),
</p>
</li>
<li><p> joint latent class mixed models for a
Gaussian (or curvilinear) longitudinal outcome and a right-censored
(potentially left-truncated and of multiple causes) time-to-event using
<code>Jointlcmm</code> function, </p>
</li>
<li><p> joint latent class mixed models for multivariate longitudinal outcomes
and a right-censored (potentially left-truncated and of multiple causes) time-to-event using
<code>mpjlcmm</code> function. </p>
</li></ul>

<p>Please report any bug or comment regarding the package for
future updates VIA GITHUB ONLY.
</p>


<h3>Author(s)</h3>

<p>Cecile Proust-Lima, Viviane Philipps, Amadou Diakite and Benoit
Liquet
</p>
<p><a href="mailto:cecile.proust-lima@inserm.fr">cecile.proust-lima@inserm.fr</a>
</p>


<h3>References</h3>

<p>Proust-Lima C, Philipps V, Liquet B (2017). Estimation of Extended Mixed 
Models Using Latent Classes and Latent Processes: The R Package lcmm. 
Journal of Statistical Software, 78(2), 1-56. doi:10.18637/jss.v078.i02
</p>
<p>Lin, Turnbull, McCulloch and Slate (2002). Latent class models for joint
analysis of longitudinal biomarker and event process data: application to
longitudinal prostate-specific antigen readings and prostate cancer. Journal
of the American Statistical Association 97, 53-65.
</p>
<p>Muthen and Shedden (1999). Finite mixture modeling with mixture outcomes
using the EM algorithm. Biometrics 55, 463-9
</p>
<p>Proust and Jacqmin-Gadda (2005). Estimation of linear mixed models with a
mixture of distribution for the random-effects. Comput Methods Programs
Biomed 78:165-73
</p>
<p>Proust, Jacqmin-Gadda, Taylor, Ganiayre, and Commenges (2006). A nonlinear
model with latent process for cognitive evolution using multivariate
longitudinal data. Biometrics 62, 1014-24.
</p>
<p>Proust-Lima, Dartigues and Jacqmin-Gadda (2011). Misuse of the linear mixed
model when evaluating risk factors of cognitive decline. Amer J Epidemiol
174(9), 1077-88
</p>
<p>Proust-Lima and Taylor (2009). Development and validation of a dynamic
prognostic tool for prostate cancer recurrence using repeated measures of
post-treatment PSA: a joint modelling approach. Biostatistics 10, 535-49.
</p>
<p>Proust-Lima, Sene, Taylor, Jacqmin-Gadda (2014). Joint latent class models
for longitudinal and time-to-event data: a review. Statistical Methods in
Medical Research 23, 74-90.
</p>
<p>Proust-Lima, Amieva, Jacqmin-Gadda (2013). Analysis of multivariate mixed
longitudinal data: A flexible latent process approach. Br J Math Stat
Psychol 66(3), 470-87.
</p>
<p>Proust-Lima, Philipps, Perrot, Blanchin, Sebille (2021). Modeling repeated self-reported
outcome data: a continuous-time longitudinal Item Response Theory model. 
arXiv:210913064. http://arxiv.org/abs/2109.13064
</p>
<p>Proust-Lima, Dartigues, Jacqmin-Gadda (2016). Joint modeling of repeated multivariate 
cognitive measures and competing risks of dementia and death: a latent process and
latent class approach. Stat Med;35(3):382-98
</p>
<p>Proust-Lima, Philipps, Dartigues, Bennett, Glymour, Jacqmin-Gadda, et al (2019). 
Are latent variable models preferable to composite score approaches when assessing
risk factors of change? Evaluation of type-I error and statistical power in longitudinal
cognitive studies. Stat Methods Med Res;28(7):1942-57  
</p>
<p>Verbeke and Lesaffre (1996). A linear mixed-effects model with heterogeneity
in the random-effects population. Journal of the American Statistical
Association 91, 217-21
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://cecileproust-lima.github.io/lcmm/">https://cecileproust-lima.github.io/lcmm/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/CecileProust-Lima/lcmm/issues">https://github.com/CecileProust-Lima/lcmm/issues</a>
</p>
</li></ul>


<hr>
<h2 id='cuminc'>Predicted cumulative incidence of event according to a profile of covariates</h2><span id='topic+cuminc'></span>

<h3>Description</h3>

<p>This function computes the predicted cumulative incidence of each cause of
event according to a profile of covariates from a joint latent class model.
Confidence bands can be computed by a Monte-Carlo method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cuminc(x, time, draws = FALSE, ndraws = 2000, integrateOptions = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cuminc_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code>Jointlcmm</code> or <code>mpjlcmm</code></p>
</td></tr>
<tr><td><code id="cuminc_+3A_time">time</code></td>
<td>
<p>a vector of times at which the cumulative incidence is
calculated</p>
</td></tr>
<tr><td><code id="cuminc_+3A_draws">draws</code></td>
<td>
<p>optional boolean specifying whether a Monte Carlo approximation
of the posterior distribution of the cumulative incidence is computed and
the median, 2.5% and 97.5% percentiles are given. Otherwise, the predicted
cumulative incidence is computed at the point estimate. By default,
draws=FALSE.</p>
</td></tr>
<tr><td><code id="cuminc_+3A_ndraws">ndraws</code></td>
<td>
<p>if draws=TRUE, ndraws specifies the number of draws that
should be generated to approximate the posterior distribution of the
predicted cumulative incidence. By default, ndraws=2000.</p>
</td></tr>
<tr><td><code id="cuminc_+3A_integrateoptions">integrateOptions</code></td>
<td>
<p>optional list specifying the subdivisions, rel.tol
and stop.on.error options (see ?integrate).</p>
</td></tr>
<tr><td><code id="cuminc_+3A_...">...</code></td>
<td>
<p>further arguments, in particular values of the covariates
specified in the survival part of the joint model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>cuminc</code> containing as many matrices as
profiles defined by the covariates values. Each of these matrices contains
the event-specific cumulative incidences in each latent class at the
different times specified.
</p>


<h3>Author(s)</h3>

<p>Viviane Philipps and Cecile Proust-Lima
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Jointlcmm">Jointlcmm</a></code>, <code><a href="#topic+plot.Jointlcmm">plot.Jointlcmm</a></code>, <code><a href="#topic+plot.cuminc">plot.cuminc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m2 &lt;- Jointlcmm(fixed= Ydep1~Time*X1,mixture=~Time,random=~Time,
classmb=~X3,subject='ID',survival = Surv(Tevent,Event)~X1+mixture(X2),
hazard="3-quant-splines",hazardtype="PH",ng=2,data=data_lcmm,
B=c(0.64,-0.62,0,0,0.52,0.81,0.41,0.78,0.1,0.77,-0.05,10.43,11.3,-2.6,
-0.52,1.41,-0.05,0.91,0.05,0.21,1.5))

par(mfrow=c(1,2))
plot(cuminc(m2,time=seq(0,20),X1=0,X2=0), ylim=c(0,1))
plot(cuminc(m2,time=seq(0,20),X1=0,X2=1), ylim=c(0,1))

</code></pre>

<hr>
<h2 id='data_hlme'>Simulated dataset for hlme function</h2><span id='topic+data_hlme'></span>

<h3>Description</h3>

<p>The data were simulated from a 3-latent class linear mixed model. Repeated
data for 100 subjects were simulated. The three latent classes are predicted
by X2 and X3. In each latent class, Y follows a linear mixed model including
intercept and time both with correlated random-effects and class-specific
fixed effects. In addition, X1 and X1*time have a common impact over classes
on the Y trajectory.
</p>


<h3>Format</h3>

<p>A data frame with 326 observations on the following 9 variables.
</p>
 <dl>
<dt>ID</dt><dd><p>subject identification number</p>
</dd>
<dt>Y</dt><dd><p>longitudinal outcome</p>
</dd> <dt>Time</dt><dd><p>time of
measurement</p>
</dd> <dt>X1</dt><dd><p>binary covariate</p>
</dd> <dt>X2</dt><dd><p>binary
covariate</p>
</dd> <dt>X3</dt><dd><p>binary covariate</p>
</dd> </dl>



<h3>See Also</h3>

<p><code><a href="#topic+hlme">hlme</a></code>, <code><a href="#topic+postprob">postprob</a></code>,
<code><a href="#topic+summary.lcmm">summary.lcmm</a></code>, <code><a href="#topic+plot.predict">plot.predict</a></code>
</p>

<hr>
<h2 id='data_lcmm'>Simulated dataset for lcmm and Jointlcmm functions</h2><span id='topic+data_lcmm'></span>

<h3>Description</h3>

<p>The data were simulated from a joint latent class mixed model with 3
classes.  Repeated data of 3 longitudinal outcomes (Ydep1, Ydep2, Ydep3) and
censored time of event (Tevent, Event) with delayed entry (Tentry) were
simulated for a total of 300 subjects.  The three latent classes were
predicted by the continuous covariate X3.  In each latent class, the
longitudinal outcome Ydep1 followed a linear mixed model including
intercept, time and squared time both with correlated random-effects and
class-specific fixed effects. In addition, the binary covariate X1 and its
interaction with time X1:Time had a common impact (over classes) on the
Ydep1 trajectory.  The longitudinal ordinal outcomes Ydep2 and Ydep3 were
generated from Ydep1 using threshold models with respectively 30 and 10
thresholds.  In each latent class, the time of event followed a
class-specific Weibull hazard with a common proportional effect of the
binary covariate X2. Both time of entry Tentry and time of censoring had a
uniform distribution
</p>


<h3>Format</h3>

<p>A data frame with 1678 observations over 300 different subjects and
22 variables.  </p>
 <dl>
<dt>ID</dt><dd><p>subject identification number</p>
</dd>
<dt>Ydep1</dt><dd><p>longitudinal continuous outcome</p>
</dd>
<dt>Ydep2</dt><dd><p>longitudinal ordinal outcome with 31 levels</p>
</dd>
<dt>Ydep3</dt><dd><p>longitudinal ordinal outcome with 11 levels</p>
</dd>
<dt>Tentry</dt><dd><p>delayed entry for the time-to-event</p>
</dd>
<dt>Tevent</dt><dd><p>observed time-to-event: either censoring time or time
of event</p>
</dd> <dt>Event</dt><dd><p>indicator that Tevent is the time of event</p>
</dd>
<dt>Time</dt><dd><p>time of measurement</p>
</dd> <dt>X1</dt><dd><p>binary covariate</p>
</dd>
<dt>X2</dt><dd><p>binary covariate</p>
</dd> <dt>X3</dt><dd><p>continuous covariate</p>
</dd>
<dt>X4</dt><dd><p>categorical covariate</p>
</dd> </dl>



<h3>See Also</h3>

<p><code><a href="#topic+Jointlcmm">Jointlcmm</a></code>, <code><a href="#topic+lcmm">lcmm</a></code>, <code><a href="#topic+hlme">hlme</a></code>
</p>

<hr>
<h2 id='Diffepoce'>Difference of expected prognostic cross-entropy (EPOCE) estimators and its
95% tracking interval between two joint latent class models estimated with
<code>Jointlcmm</code></h2><span id='topic+Diffepoce'></span>

<h3>Description</h3>

<p>This function computes the difference of 2 EPOCE estimates (CVPOL or MPOL)
and its 95% tracking interval between two joint latent class models
estimated using <code>Jointlcmm</code> and evaluated using <code>epoce</code> function.
Difference in CVPOL is computed when the EPOCE was previously estimated on
the same dataset as used for estimation (using an approximated
cross-validation), and difference in MPOL is computed when the EPOCE was
previously estimated on an external dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Diffepoce(epoceM1, epoceM2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Diffepoce_+3A_epocem1">epoceM1</code></td>
<td>
<p>a first object inheriting from class <code>epoce</code></p>
</td></tr>
<tr><td><code id="Diffepoce_+3A_epocem2">epoceM2</code></td>
<td>
<p>a second object inheriting from class <code>epoce</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function does not apply for the moment with multiple causes of event
(competing risks).
</p>
<p>From the EPOCE estimates and the individual contributions to the prognostic
observed log-likelihood obtained with <code>epoce</code> function on the same
dataset from two different estimated joint latent class models, the
difference of CVPOL (or MPOL) and its 95% tracking interval is computed.
The 95% tracking interval is:
</p>
<p>Delta(MPOL) +/- qnorm(0.975)*sqrt(VARIANCE) for an external dataset
</p>
<p>Delta(CVPOL) +/- qnorm(0.975)*sqrt(VARIANCE) for the dataset used in
<code>Jointlcmm</code>
</p>
<p>where Delta(CVPOL) (or Delta(MPOL)) is the difference of CVPOL (or MPOL) of
the two joint latent class models, and VARIANCE is the empirical variance of
the difference of individual contributions to the prognostic observed
log-likelihoods of the two joint latent class models.
</p>
<p>See Commenges et al. (2012) and Proust-Lima et al. (2012) for further
details.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>call.Jointlcmm1</code></td>
<td>
<p>the <code>Jointlcmm</code> call for epoceM1 </p>
</td></tr>
<tr><td><code>call.Jointlcmm2</code></td>
<td>
<p>the <code>Jointlcmm</code> call for epoceM2 </p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr> <tr><td><code>DiffEPOCE</code></td>
<td>
<p>Dataframe containing, for
each prediction time s, the difference in either MPOL or CVPOL depending on
the dataset used, and the 95% tracking bands (TIinf and TIsup) </p>
</td></tr>
<tr><td><code>new.data</code></td>
<td>
<p>a boolean for internal use only, which is FALSE if
computation is done on the same data as for <code>Jointlcmm</code> estimation, and
TRUE otherwise. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cecile Proust-Lima and Amadou Diakite
</p>


<h3>References</h3>

<p>Commenges, Liquet and Proust-Lima (2012). Choice of prognostic
estimators in joint models by estimating differences of expected conditional
Kullback-Leibler risks. Biometrics 68(2), 380-7.
</p>
<p>Proust-Lima, Sene, Taylor, Jacqmin-Gadda (2014). Joint latent class models
for longitudinal and time-to-event data: a review. Statistical Methods in
Medical Research 23, 74-90.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Jointlcmm">Jointlcmm</a></code>, <code><a href="#topic+epoce">epoce</a></code>, <code><a href="#topic+summary.Diffepoce">summary.Diffepoce</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
#### estimation with 2 latent classes (ng=2)
m2 &lt;- Jointlcmm(fixed= Ydep1~Time*X1,random=~Time,mixture=~Time,subject='ID'
,survival = Surv(Tevent,Event)~ X1+X2 ,hazard="Weibull"
,hazardtype="PH",ng=2,data=data_lcmm,
B=c( 0.7608, -9.4974,  1.0242,  1.4331,  0.1063 , 0.6714, 10.4679, 11.3178,
 -2.5671, -0.5386,  1.4616, -0.0605,  0.9489,  0.1020,  0.2079,  1.5045),logscale=TRUE)
m1 &lt;- Jointlcmm(fixed= Ydep1~Time*X1,random=~Time,subject='ID'
,survival = Surv(Tevent,Event)~ X1+X2 ,hazard="Weibull"
,hazardtype="PH",ng=1,data=data_lcmm,
B=c(-7.6634,  0.9136,  0.1002,  0.6641, 10.5675, -1.6589,  1.4767, -0.0806,
  0.9240,0.5643,  1.2277,  1.5004))

## EPOCE computation for predictions times from 1 to 6 on the dataset used
## for estimation of m.
VecTime &lt;- c(1,3,5,7,9,11,13,15)
cvpol1 &lt;- epoce(m1,var.time="Time",pred.times=VecTime)
cvpol1
cvpol2 &lt;- epoce(m2,var.time="Time",pred.times=VecTime)
cvpol2
DeltaEPOCE &lt;- Diffepoce(cvpol1,cvpol2)
summary(DeltaEPOCE)
plot(DeltaEPOCE,bty="l")

## End(Not run)

</code></pre>

<hr>
<h2 id='dynpred'>Individual dynamic predictions from a joint latent class model</h2><span id='topic+dynpred'></span>

<h3>Description</h3>

<p>This function computes individual dynamic predictions and 95% confidence
bands. Given a joint latent class model, a landmark time s, a horizon time t
and measurements until time s, the predicted probability of event in the
window [s,s+t] is calculated. Confidence bands can be provided using a Monte
Carlo method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dynpred(
  model,
  newdata,
  event = 1,
  landmark,
  horizon,
  var.time,
  fun.time = identity,
  na.action = 1,
  draws = FALSE,
  ndraws = 2000
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dynpred_+3A_model">model</code></td>
<td>
<p>an object inheriting from class <code>Jointlcmm</code>.</p>
</td></tr>
<tr><td><code id="dynpred_+3A_newdata">newdata</code></td>
<td>
<p>a data frame containing the data from which predictions are
computed. This data frame must contain all the model's covariates, the
observations of the longitudinal and survival outcomes, the subject
identifier and if necessary the variables specified in prior and TimeDepVar
argumentsfrom Jointlcmm.</p>
</td></tr>
<tr><td><code id="dynpred_+3A_event">event</code></td>
<td>
<p>integer giving the event for which the prediction is to be
calculated</p>
</td></tr>
<tr><td><code id="dynpred_+3A_landmark">landmark</code></td>
<td>
<p>a numeric vector containing the landmark times.</p>
</td></tr>
<tr><td><code id="dynpred_+3A_horizon">horizon</code></td>
<td>
<p>a numeric vector containing the horizon times.</p>
</td></tr>
<tr><td><code id="dynpred_+3A_var.time">var.time</code></td>
<td>
<p>a character indicating the time variable in <code>newdata</code></p>
</td></tr>
<tr><td><code id="dynpred_+3A_fun.time">fun.time</code></td>
<td>
<p>an optional function. This is only required if the time
scales in the longitudinal part of the model and the survival part are
different. In that case, <code>fun.time</code> is the function that translates the
times from the longitudinal part into the time scale of the survival part.
The default is the identity function which means that the two time scales
are the same.</p>
</td></tr>
<tr><td><code id="dynpred_+3A_na.action">na.action</code></td>
<td>
<p>Integer indicating how NAs are managed. The default is 1
for 'na.omit'. The alternative is 2 for 'na.fail'. Other options such as
'na.pass' or 'na.exclude' are not implemented in the current version.</p>
</td></tr>
<tr><td><code id="dynpred_+3A_draws">draws</code></td>
<td>
<p>optional boolean specifying whether median and confidence bands
of the predicted values should be computed (TRUE). IF TRUE, a Monte Carlo
approximation of the posterior distribution of the predicted values is
computed and the median, 2.5% and 97.5% percentiles are given. Otherwise,
the predicted values are computed at the point estimate. By default,
draws=FALSE.</p>
</td></tr>
<tr><td><code id="dynpred_+3A_ndraws">ndraws</code></td>
<td>
<p>if draws=TRUE, ndraws specifies the number of draws that
should be generated to approximate the posterior distribution of the
predicted values. By default, ndraws=2000.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing : </p>
<table role = "presentation">
<tr><td><code>pred</code></td>
<td>
<p>a matrix with 4 columns if
draws=FALSE and 6 columns if draws=TRUE, containing the subjects identifier,
the landmark times, the horizon times, the predicted probability (if
draws=FALSE) or the median, 2.5% and 97.5 % percentiles of the 'ndraws'
probabilities calculated (if draws=TRUE). If a subject has no measurement
before time s or if the event has already occured at time s, his probability
is NA.</p>
</td></tr> <tr><td><code>newdata</code></td>
<td>
<p>a data frame obtained from argument newdata
containing time measurements and longitudinal observations used to compute
the predictions</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cecile Proust-Lima, Viviane Philipps
</p>


<h3>References</h3>

<p>Proust-Lima, Sene, Taylor and Jacqmin-Gadda (2014). Joint latent
class models of longitudinal and time-to-event data: a review. Statistical
Methods in Medical Research 23, 74-90.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.dynpred">plot.dynpred</a></code>, <code><a href="#topic+Jointlcmm">Jointlcmm</a></code>, <code><a href="#topic+predictY">predictY</a></code>, <code><a href="#topic+plot.predict">plot.predict</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Joint latent class model with 2 classes :
m32 &lt;- Jointlcmm(Ydep1~Time*X1,mixture=~Time,random=~Time,subject="ID",
classmb=~X3,ng=2,survival=Surv(Tevent,Event)~X1+mixture(X2),
hazard="3-quant-splines",hazardtype="PH",data=data_lcmm,
B = c(0.641, -0.6217, 0, 0, 0.5045, 0.8115, -0.4316, 0.7798, 0.1027, 
0.7704, -0.0479, 10.4257, 11.2972, -2.5955, -0.5234, 1.4147, 
-0.05, 0.9124, 0.0501, 0.2138, 1.5027))

## Predictions at landmark 10 and 12 for horizon 3, 5 and 10 for two subjects :

dynpred(m32,landmark=c(10,12),horizon=c(3,5,10),var.time="Time",
fun.time=function(x){10*x},newdata=data_lcmm[1:8,])
## Not run: 
dynpred(m32,landmark=c(10,12),horizon=c(3,5,10),var.time="Time",
fun.time=function(x){10*x},newdata=data_lcmm[1:8,],draws=TRUE,ndraws=2000)

## End(Not run)

</code></pre>

<hr>
<h2 id='epoce'>Estimators of the Expected Prognostic Observed Cross-Entropy (EPOCE) for
evaluating predictive accuracy of joint latent class models estimated using
<code>Jointlcmm</code></h2><span id='topic+epoce'></span>

<h3>Description</h3>

<p>This function computes estimators of the Expected Prognostic Observed
Cross-Entropy (EPOCE) for evaluating the predictive accuracy of joint latent
class models estimated using <code>Jointlcmm</code>. On the same data as used for
estimation of the <code>Jointlcmm</code> object, this function computes both the
Mean Prognostic Observed Log-Likelihood (MPOL) and the Cross-Validated
Observed Log-Likelihood (CVPOL), two estimators of EPOCE. The latter
corrects the MPOL estimate for over-optimism by approximated
cross-validation. On external data, this function only computes the Mean
Prognostic Observed Log-Likelihood (MPOL).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>epoce(
  model,
  pred.times,
  var.time,
  fun.time = identity,
  newdata = NULL,
  subset = NULL,
  na.action = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="epoce_+3A_model">model</code></td>
<td>
<p>an object inheriting from class <code>Jointlcmm</code></p>
</td></tr>
<tr><td><code id="epoce_+3A_pred.times">pred.times</code></td>
<td>
<p>Vector of times of prediction, from which predictive
accuracy is evaluated (only subjects still at risk at the time of prediction
are included in the computation, and only information before the time of
prediction is considered.</p>
</td></tr>
<tr><td><code id="epoce_+3A_var.time">var.time</code></td>
<td>
<p>Name of the variable indicating time in the dataset</p>
</td></tr>
<tr><td><code id="epoce_+3A_fun.time">fun.time</code></td>
<td>
<p>an optional function. This is only required if the time
scales in the longitudinal part of the model and the survival part are
different. In that case, <code>fun.time</code> is the function that translates the
times from the longitudinal part into the time scale of the survival part.
The default is the identity function which means that the two time scales
are the same.</p>
</td></tr>
<tr><td><code id="epoce_+3A_newdata">newdata</code></td>
<td>
<p>optional. When missing, the data used for estimating the
<code>Jointlcmm</code> object are used, and CVPOL and MPOL are computed (internal
validation). When newdata is specified, only MPOL is computed on this
newdataset (external validation).</p>
</td></tr>
<tr><td><code id="epoce_+3A_subset">subset</code></td>
<td>
<p>a specification of the rows to be used: defaults to all rows.
This can be any valid indexing vector for the rows of data or if that is not
supplied, a data frame made up of the variable used in formula.</p>
</td></tr>
<tr><td><code id="epoce_+3A_na.action">na.action</code></td>
<td>
<p>Integer indicating how NAs are managed. The default is 1
for 'na.omit'. The alternative is 2 for 'na.fail'. Other options such as
'na.pass' or 'na.exclude' are not implemented in the current version.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function does not apply for the moment with multiple causes of event
(competing risks).
</p>
<p>EPOCE assesses the prognostic information of a joint latent class model. It
relies on information theory.
</p>
<p>MPOL computed at time s equals minus the mean individual contribution to the
conditional log-likelihood of the time to event given the longitudinal data
up to the time of prediction s and given the subject is still at risk of
event in s.
</p>
<p>CVPOL computed at time s equals MPOL at time s plus a penalty term that
corrects for over-optimism when computing predictive accuracy measures on
the same dataset as used for estimation. This penalty term is computed from
the inverse of the Hessian of the joint log-likelihood and the product of
the gradients of the contributions to respectively the joint log-likelihood
and the conditional log-likelihood.
</p>
<p>The theory of EPOCE and its estimators MPOL and CVPOL is given in Commenges
et al. (2012), and further detailed and illustrated for joint models in
Proust-Lima et al. (2013).
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>call.Jointlcmm</code></td>
<td>
<p>the <code>Jointlcmm</code> call</p>
</td></tr>
<tr><td><code>call.epoce</code></td>
<td>
<p>the matched call</p>
</td></tr> <tr><td><code>EPOCE</code></td>
<td>
<p>Dataframe containing, for
each prediction time s, the number of subjects still at risk at s (and with
at least one measure before s), the number of events after time s, the MPOL,
and the CVPOL when computation is done on the dataset used for
<code>Jointlcmm</code> estimation</p>
</td></tr> <tr><td><code>IndivContrib</code></td>
<td>
<p>Individual contributions to
the prognostic observed log-likelihood at each time of prediction. Used for
computing tracking intervals of EPOCE differences between models.</p>
</td></tr>
<tr><td><code>new.data</code></td>
<td>
<p>a boolean for internal use only, which is FALSE if
computation is done on the same data as for <code>Jointlcmm</code> estimation, and
TRUE otherwise.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cecile Proust-Lima and Amadou Diakite
</p>


<h3>References</h3>

<p>Commenges, Liquet and Proust-Lima (2012). Choice of prognostic
estimators in joint models by estimating differences of expected conditional
Kullback-Leibler risks. Biometrics 68(2), 380-7.
</p>
<p>Proust-Lima, Sene, Taylor and Jacqmin-Gadda (2014). Joint latent class
models of longitudinal and time-to-event data: a review. Statistical Methods
in Medical Research 23, 74-90.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Jointlcmm">Jointlcmm</a></code>, <code><a href="#topic+print.epoce">print.epoce</a></code>, <code><a href="#topic+summary.epoce">summary.epoce</a></code>, <code><a href="#topic+plot.epoce">plot.epoce</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
## estimation of a joint latent class model with 2 latent classes (ng=2)
# (see the example section of Jointlcmm for details about
#  the model specification)

m &lt;- Jointlcmm(fixed= Ydep1~Time*X1,random=~Time,mixture=~Time,subject='ID'
,survival = Surv(Tevent,Event)~ X1+X2 ,hazard="Weibull"
,hazardtype="PH",ng=2,data=data_lcmm,logscale=TRUE,
B=c(0.7608, -9.4974 , 1.0242,  1.4331 , 0.1063 , 0.6714, 10.4679, 11.3178,
 -2.5671, -0.5386,  1.4616, -0.0605,  0.9489,  0.1020 , 0.2079,  1.5045))
summary(m)

## Computation of the EPOCE on the same dataset as used for
# estimation of m with times at predictions from 1 to 15 
VecTime &lt;- c(1,3,5,7,9,11,13,15)
cvpl &lt;- epoce(m,var.time="Time",pred.times=VecTime)
summary(cvpl)
plot(cvpl,bty="l",ylim=c(0,2))

## End(Not run)


</code></pre>

<hr>
<h2 id='estimates'>Maximum likelihood estimates</h2><span id='topic+estimates'></span><span id='topic+estimates.hlme'></span><span id='topic+estimates.lcmm'></span><span id='topic+estimates.Jointlcmm'></span><span id='topic+estimates.multlcmm'></span><span id='topic+estimates.externSurv'></span><span id='topic+estimates.externX'></span><span id='topic+estimates.mpjlcmm'></span>

<h3>Description</h3>

<p>This function provides the vector of maximum likelihood estimates of a model
estimated with <code>hlme</code>, <code>lcmm</code>, <code>multlcmm</code>,
<code>Jointlcmm</code>, <code>mpjlcmm</code>, <code>externSurv</code>, or <code>externX</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimates(x, cholesky = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estimates_+3A_x">x</code></td>
<td>
<p>an object of class <code>hlme</code>, <code>lcmm</code>, <code>multlcmm</code> or
<code>Jointlcmm</code></p>
</td></tr>
<tr><td><code id="estimates_+3A_cholesky">cholesky</code></td>
<td>
<p>optional logical indicating if the parameters of
variance-covariance of the random effets should be displayed instead of
their cholesky transformations used in the estimation process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector with all estimates of the model.
</p>


<h3>Author(s)</h3>

<p>Cecile Proust-Lima, Viviane Philipps
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VarCov">VarCov</a></code>, <code><a href="#topic+hlme">hlme</a></code>, <code><a href="#topic+lcmm">lcmm</a></code>,
<code><a href="#topic+multlcmm">multlcmm</a></code>, <code><a href="#topic+Jointlcmm">Jointlcmm</a></code>
</p>

<hr>
<h2 id='externVar'>Estimation of a secondary regression model after the estimation of a primary latent class model</h2><span id='topic+externVar'></span>

<h3>Description</h3>

<p>This function fits regression models to relate a latent class structure (stemmed 
from a latent class model estimated within <code>lcmm</code> package) with either an external
outcome or external class predictors. 
Two inference techniques are implemented. They both account for the 
classification error in the posterior class assignment: 
</p>
<p>- a 2-stage estimation using the joint likelihood of the primary latent 
class model and of the secondary/ external regression;
</p>
<p>- a conditional regression of the external outcome given the underlying 
latent class structure, or of the underlying class structure given external
covariates. 
</p>
<p>It returns an object of one of the <code>lcmm</code> package classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>externVar(
  model,
  fixed,
  mixture,
  random,
  subject,
  classmb,
  survival,
  hazard = "Weibull",
  hazardtype = "Specific",
  hazardnodes = NULL,
  TimeDepVar = NULL,
  logscale = FALSE,
  idiag = FALSE,
  nwg = FALSE,
  randomY = NULL,
  link = NULL,
  intnodes = NULL,
  epsY = NULL,
  cor = NULL,
  nsim = NULL,
  range = NULL,
  data,
  longitudinal,
  method,
  varest,
  M = 200,
  B,
  convB = 1e-04,
  convL = 1e-04,
  convG = 1e-04,
  maxiter = 100,
  posfix,
  partialH = FALSE,
  verbose = FALSE,
  nproc = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="externVar_+3A_model">model</code></td>
<td>
<p>an object inheriting from class <code>hlme</code>, <code>lcmm</code>, 
<code>Jointlcmm</code>, <code>multlcmm</code> or <code>mpjlcmm</code> giving the primary latent
class model.</p>
</td></tr>
<tr><td><code id="externVar_+3A_fixed">fixed</code></td>
<td>
<p>optional, for secondary analyses on an external outcome variable: 
two-sided linear formula object for specifying the outcome and fixed-effect 
part in the secondary model.
The response outcome is on the left of <code>~</code> and the covariates are separated
by <code>+</code> on the right of the <code>~</code>. The right side should be <code>~1</code> to
model the outcome according to the latent classes only.</p>
</td></tr>
<tr><td><code id="externVar_+3A_mixture">mixture</code></td>
<td>
<p>optional, for secondary analyses on an external outcome variable: 
one-sided formula object for the class-specific fixed effects in the model 
for the external outcome. Among the list of covariates included in fixed,
the covariates with class-specific regression parameters are entered in
mixture separated by <code>+</code>. By default, an intercept is included.
If no intercept, <code>-1</code> should be the first term included.</p>
</td></tr>
<tr><td><code id="externVar_+3A_random">random</code></td>
<td>
<p>optional, for secondary analyses on an external outcome variable: 
one-sided linear formula object for specifying the
random effects in the secondary model, if appropriate. 
By default, no random effect is included.</p>
</td></tr>
<tr><td><code id="externVar_+3A_subject">subject</code></td>
<td>
<p>name of the covariate representing the grouping structure.
Even in the absence of a hierarchical structure.</p>
</td></tr>
<tr><td><code id="externVar_+3A_classmb">classmb</code></td>
<td>
<p>optional, for secondary analyses on latent class membership 
according to external covariates: 
optional one-sided formula specifying the external predictors of 
latent class membership to be modeled in the secondary class-membership multinomial 
logistic model. Covariates are separated by <code>+</code> on the right of the <code>~</code>.</p>
</td></tr>
<tr><td><code id="externVar_+3A_survival">survival</code></td>
<td>
<p>optional, for secondary analyses on an external survival outcome:
two-sided formula specifying the external survival part
of the model. The right side should be <code>~1</code> to get the survival associated to
each latent class without any other covariate.</p>
</td></tr>
<tr><td><code id="externVar_+3A_hazard">hazard</code></td>
<td>
<p>optional, for secondary analyses on an external survival outcome:
family of hazard function assumed for the survival model
(Weibull, piecewise or splines)</p>
</td></tr>
<tr><td><code id="externVar_+3A_hazardtype">hazardtype</code></td>
<td>
<p>optional, for secondary analyses on an external survival outcome:
indicator for the type of baseline risk function
(Specific, PH or Common)</p>
</td></tr>
<tr><td><code id="externVar_+3A_hazardnodes">hazardnodes</code></td>
<td>
<p>optional, for secondary analyses on an external survival outcome:
vector containing interior nodes if <code>splines</code> or
<code>piecewise</code> is specified for the baseline hazard function in <code>hazard</code></p>
</td></tr>
<tr><td><code id="externVar_+3A_timedepvar">TimeDepVar</code></td>
<td>
<p>optional, for secondary analyses on an external survival outcome:
vector specifying the name of the time-dependent covariate
in the survival model (only a irreversible event time in allowed)</p>
</td></tr>
<tr><td><code id="externVar_+3A_logscale">logscale</code></td>
<td>
<p>optional, for secondary analyses on an external survival outcome:
boolean indicating whether an exponential (logscale=TRUE) or
a square (logscale=FALSE -by default) transformation is used to
ensure positivity of parameters in the baseline risk functions</p>
</td></tr>
<tr><td><code id="externVar_+3A_idiag">idiag</code></td>
<td>
<p>optional, for secondary analyses on an external outcome:
if appropriate, logical for the structure of the variance-covariance
matrix of the random-effects in the secondary model. 
If <code>FALSE</code>, a non structured matrix of
variance-covariance is considered (by default). If <code>TRUE</code> a diagonal
matrix of variance-covariance is considered.</p>
</td></tr>
<tr><td><code id="externVar_+3A_nwg">nwg</code></td>
<td>
<p>optional, for secondary analyses on an external outcome:
if appropriate, logical indicating if the variance-covariance of the
random-effects in the secondary model is class-specific. If <code>FALSE</code> the
variance-covariance matrix is common over latent classes (by default). If <code>TRUE</code> a
class-specific proportional parameter multiplies the variance-covariance
matrix in each class (the proportional parameter in the last latent class
equals 1 to ensure identifiability).</p>
</td></tr>
<tr><td><code id="externVar_+3A_randomy">randomY</code></td>
<td>
<p>optional, for secondary analyses on an external outcome:
if appropriate, logical for including an outcome-specific random intercept.
If FALSE no outcome-specific random intercept is added (default). If TRUE independent
outcome-specific random intercept with parameterized variance are included</p>
</td></tr>
<tr><td><code id="externVar_+3A_link">link</code></td>
<td>
<p>optional, for secondary analyses on an external outcome:
if appropriate, family of parameterized link functions for the external outcome
if appropriate. Defaults to NULL, corresponding to continuous Gaussian distribution
(hlme function).</p>
</td></tr>
<tr><td><code id="externVar_+3A_intnodes">intnodes</code></td>
<td>
<p>optional, for secondary analyses on an external outcome:
if appropriate, vector of interior nodes. This argument is only
required for a I-splines link function with nodes entered manually.</p>
</td></tr>
<tr><td><code id="externVar_+3A_epsy">epsY</code></td>
<td>
<p>optional, for secondary analyses on an external outcome:
if appropriate, definite positive real used to rescale the marker in (0,1)
when the beta link function is used. By default, epsY=0.5.</p>
</td></tr>
<tr><td><code id="externVar_+3A_cor">cor</code></td>
<td>
<p>optional, for secondary analyses on an external outcome:
if appropriate, indicator for inclusion of an auto correlated Gaussian process
in the latent process linear (latent process) mixed model. Option &quot;BM&quot; indicates
a brownian motion with parameterized variance. Option &quot;AR&quot; specifies an
autoregressive process of order 1 with parameterized variance and correlation
intensity. Each option should be followed by the time variable in brackets as
<code>cor=BM(time)</code>. By default, no autocorrelated Gaussian process is added.</p>
</td></tr>
<tr><td><code id="externVar_+3A_nsim">nsim</code></td>
<td>
<p>optional, for secondary analyses on an external outcome:
if appropriate, number of points to be used in the estimated link function. By default,
nsom=100.</p>
</td></tr>
<tr><td><code id="externVar_+3A_range">range</code></td>
<td>
<p>optional, for secondary analyses on an external outcome:
if appropriate, vector indicating the range of the outcomes (that is the
minimum and maximum). By default, the range is defined according to the minimum
and maximum observed values of the outcome. The option should be used
only for Beta and Splines transformations.</p>
</td></tr>
<tr><td><code id="externVar_+3A_data">data</code></td>
<td>
<p>Data frame containing the variables named in
<code>fixed</code>, <code>mixture</code>, <code>random</code>, <code>classmb</code> and <code>subject</code>,
for both the current function arguments and the primary model arguments
Check <code>details</code> to get information on the data structure, especially with
external outcomes.</p>
</td></tr>
<tr><td><code id="externVar_+3A_longitudinal">longitudinal</code></td>
<td>
<p>only with <code>mpjlcmm</code> primary models and &quot;twoStageJoint&quot;
method: mandatory list containing the longitudinal submodels used in the primary
latent class model.</p>
</td></tr>
<tr><td><code id="externVar_+3A_method">method</code></td>
<td>
<p>character indicating the inference technique to be used:
<code>"twoStageJoint"</code> corresponds to 2-stage estimation using the 
joint log-likelihood. <code>"conditional"</code> corresponds to the conditional 
regression using the underlying true latent class membership.</p>
</td></tr>
<tr><td><code id="externVar_+3A_varest">varest</code></td>
<td>
<p>optional character indicating the method to be used to compute the
variance of the regression estimates in the secondary regression. 
<code>"none"</code> does not account for the
uncertainty in the primary latent class model, <code>"paramBoot"</code> computes the
total variance using a parametric bootstrap technique, <code>"Hessian"</code> computes
the total Hessian of the joint likelihood (implemented for <code>"twoStageJoint"</code>
method only). Default to <code>"Hessian"</code> for <code>"twoStageJoint"</code> method and
<code>"paramBoot"</code> for <code>"conditional"</code> method.</p>
</td></tr>
<tr><td><code id="externVar_+3A_m">M</code></td>
<td>
<p>option integer indicating the number of draws for the parametric boostrap
when <code>varest="paramBoot"</code>. Default to 200.</p>
</td></tr>
<tr><td><code id="externVar_+3A_b">B</code></td>
<td>
<p>optional vector of initial parameter values for the secondary model. 
With an external outcome, the vector has the same structure as a latent class model
estimated in the other functions of <code>lcmm</code> package for the same type of 
outcome except that no parameters should be included for the latent class membership. 
With external class predictors (of size p), the vector is of length 
(ng-1)*(1+p). If <code>B=NULL</code> (by default), internal initial values are considered</p>
</td></tr>
<tr><td><code id="externVar_+3A_convb">convB</code></td>
<td>
<p>optional threshold for the convergence criterion based on the
parameter stability. By default, convB=0.0001.</p>
</td></tr>
<tr><td><code id="externVar_+3A_convl">convL</code></td>
<td>
<p>optional threshold for the convergence criterion based on the
log-likelihood stability. By default, convL=0.0001.</p>
</td></tr>
<tr><td><code id="externVar_+3A_convg">convG</code></td>
<td>
<p>optional threshold for the convergence criterion based on the
derivatives. By default, convG=0.0001.</p>
</td></tr>
<tr><td><code id="externVar_+3A_maxiter">maxiter</code></td>
<td>
<p>optional maximum number of iterations for the secondary model
estimation using Marquardt iterative algorithm. Defaults to 100</p>
</td></tr>
<tr><td><code id="externVar_+3A_posfix">posfix</code></td>
<td>
<p>optional vector specifying indices in parameter vector B the 
secondary model that should not be estimated. Default to NULL, all the 
parameters of the secondary regression are estimated.</p>
</td></tr>
<tr><td><code id="externVar_+3A_partialh">partialH</code></td>
<td>
<p>optional logical for Piecewise and Splines baseline risk functions and
Splines link functions only. Indicates whether the parameters of the baseline risk or
link functions can be dropped from the Hessian matrix to define convergence criteria
(can solve non convergence due to estimates at the boundary of the parameter space - usually 0).</p>
</td></tr>
<tr><td><code id="externVar_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating whether information about computation should be
reported. Default to FALSE.</p>
</td></tr>
<tr><td><code id="externVar_+3A_nproc">nproc</code></td>
<td>
<p>the number cores for parallel computation. Default to 1 (sequential mode).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A. DATA STRUCTURE
</p>
<p>The <code>data</code> argument must follow specific structure. It must include all
the data necessary to compute the posterior classification probabilities
(so a longitudinal format usually) as well as the information for the 
secondary analysis. 
For time-invariant variables in the secondary analyses: 
- if used as an external outcome: the information should not be duplicated 
at each row of the subject. It should appear once for each individual. 
- if used as an external covariate: the information can be duplicated at 
each row of the subject (as usual)
</p>
<p>B. VARIANCE ESTIMATION
</p>
<p>The two techniques rely on a sequential analysis (two-stage analysis) so the
variance calculation should account for both the uncertainty in the first and 
the second stage. 
Not taking into account the first-stage uncertainty by specifying 
<code>varest="none"</code> may lead to the underestimation of the final variance. 
When possible, Method <code>varest="Hessian"</code> which relies on the 
combination of Hessians from the primary and secondary models is recommended. 
However, it may become numerically intensive when the primary latent class 
model includes a high number of parameters. As an alternative, especially 
when the primary model is complex and the second model includes a limited
number of parameters, the parametric Bootstrap method
<code>varest="paramBoot"</code> can be favored.
</p>


<h3>Value</h3>

<p>an object of class <code>externVar</code> and  
<code>externSurv</code> for external survival outcomes,
<code>externX</code> for external class predictors, and
<code>hlme</code>, <code>lcmm</code>, or <code>multlcmm</code> for external longitudinal or cross-sectional outcomes.
</p>


<h3>Author(s)</h3>

<p>Maris Dussartre, Cecile Proust-Lima and Viviane Philipps
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 


###### Estimation of the primary latent class model                   ######
# this is a linear latent class mixed model for Ydep1
# with 2 classes and a linear trajectory

set.seed(1234)
PrimMod &lt;- hlme(Ydep1~Time,random=~Time,subject='ID',ng=1,data=data_lcmm)
PrimMod2 &lt;- hlme(Ydep1~Time,mixture=~Time,random=~Time,subject='ID',
                 ng=2,data=data_lcmm,B=random(PrimMod))

###### Example 1: Relationship between the latent class structure and       #
#                   external class predictors                          ######
      
# We consider here 4 external predictors X1-X4.       
                  
# estimation of the secondary multinomial logistic model with total variance
# computed with the Hessian

XextHess &lt;- externVar(PrimMod2,
                      classmb = ~X1 + X2 + X3 + X4, 
                      subject = "ID",
                      data = data_lcmm,
                      method = "twoStageJoint") 
summary(XextHess)

# estimation of a secondary multinomial logistic model with total variance
# computed with parametric Bootstrap (much longer). When planning to use
# the bootstrap estimator, we recommend running first the analysis 
# with option varest = "none" which is faster but which underestimates 
# the variance. And then use these values as plausible initial values when 
# running the estimation with varest = "paramBoot" to obtain  a valid 
# variance of the parameters. 

XextNone &lt;- externVar(PrimMod2,
                      classmb = ~X1 + X2 + X3 + X4, 
                      subject = "ID",
                      data = data_lcmm,
                      varest = "none",
                      method = "twoStageJoint") 

XextBoot &lt;- externVar(PrimMod2,
                      classmb = ~X1 + X2 + X3 + X4, 
                      subject = "ID",
                      data = data_lcmm,
                      varest = "paramBoot",
                      method = "twoStageJoint",
                      B = XextNone$best) 
summary(XextBoot)

 
###### Example 2: Relationship between a latent class structure and         #
#                external outcome (repeatedly measured over time)     ######
                
                
# We want to estimate a linear mixed model for Ydep2 with a linear trajectory
# adjusted on X1. 
  
# estimation of the secondary linear mixed model with total variance
# computed with the Hessian

YextHess = externVar(PrimMod2,   #primary model
                     fixed = Ydep2 ~ Time*X1,  #secondary model
                     random = ~Time, #secondary model
                     mixture = ~Time,  #secondary model
                     subject="ID",
                     data=data_lcmm,
                     method = "twoStageJoint")
                     

# estimation of a secondary linear mixed model with total variance
# computed with parametric Bootstrap (much longer). When planning to use
# the bootstrap estimator, we recommend running first the analysis 
# with option varest = "none" which is faster but which underestimates 
# the variance. And then use these values as plausible initial values when 
# running the estimation with varest = "paramBoot" to obtain  a valid 
# variance of the parameters. 

YextNone = externVar(PrimMod2,   #primary model
                     fixed = Ydep2 ~ Time*X1,  #secondary model
                     random = ~Time, #secondary model
                     mixture = ~Time,  #secondary model
                     subject="ID",
                     data=data_lcmm,
                     varest = "none",
                     method = "twoStageJoint")

YextBoot = externVar(PrimMod2,   #primary model
                     fixed = Ydep2 ~ Time*X1,  #secondary model
                     random = ~Time, #secondary model
                     mixture = ~Time,  #secondary model
                     subject="ID",
                     data=data_lcmm,
                     method = "twoStageJoint",
                     B = YextNone$best,
                     varest= "paramBoot")

summary(YextBoot) 


###### Example 3: Relationship between a latent class structure and         #
#                      external outcome (survival)                     ######

# We want to estimate a proportional hazard model (with proportional hazard 
# across classes) for time to event Tevent (indicator Event) and assuming 
# a splines baseline risk with 3 knots.

# estimation of the secondary survival model with total variance
# computed with the Hessian

YextHess = externVar(PrimMod2,   #primary model
                     survival = Surv(Tevent,Event)~ X1+mixture(X2), #secondary model
                     hazard="3-quant-splines", #secondary model
                     hazardtype="PH", #secondary model
                     subject="ID",
                     data=data_lcmm,
                     method = "twoStageJoint")
summary(YextHess)


# estimation of a secondary survival model with total variance
# computed with parametric Bootstrap (much longer). When planning to use
# the bootstrap estimator, we recommend running first the analysis 
# with option varest = "none" which is faster but which underestimates 
# the variance. And then use these values as plausible initial values when 
# running the estimation with varest = "paramBoot" to obtain  a valid 
# variance of the parameters. 

YextNone = externVar(PrimMod2,   #primary model
                     survival = Surv(Tevent,Event)~ X1+mixture(X2), #secondary model
                     hazard="3-quant-splines", #secondary model
                     hazardtype="PH", #secondary model
                     subject="ID",
                     data=data_lcmm,
                     varest = "none",
                     method = "twoStageJoint")

YextBoot = externVar(PrimMod2,   #primary model
                     survival = Surv(Tevent,Event)~ X1+mixture(X2), #secondary model
                     hazard="3-quant-splines", #secondary model
                     hazardtype="PH", #secondary model
                     subject="ID",
                     data=data_lcmm,
                     method = "twoStageJoint",
                     B = YextNone$best,
                     varest= "paramBoot")

summary(YextBoot)


## End(Not run)




</code></pre>

<hr>
<h2 id='fitY'>Marginal predictions of the longitudinal outcome(s) in their natural scale
from <code>lcmm</code>, <code>Jointlcmm</code> or <code>multlcmm</code> objects</h2><span id='topic+fitY'></span><span id='topic+fitY.lcmm'></span><span id='topic+fitY.multlcmm'></span><span id='topic+fitY.Jointlcmm'></span>

<h3>Description</h3>

<p>The function computes the marginal predictions of the longitudinal
outcome(s) in their natural scale on the individual data used for the
estimation from <code>lcmm</code>, <code>Jointlcmm</code> or <code>multlcmm</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitY(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitY_+3A_x">x</code></td>
<td>
<p>an object inheriting from classes <code>lcmm</code> or <code>multlcmm</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>lcmm</code> and <code>Jointlcmm</code> objects, returns a matrix with
ng+1 columns containing the subject identifier and the ng class-specific
marginal predicted values.
</p>
<p>For <code>multlcmm</code> objects, returns a matrix with ng+2 columns containing
the subject identifier, the outcome indicator and the ng class-specific
predicted values.
</p>


<h3>Author(s)</h3>

<p>Cecile Proust-Lima, Viviane Philipps
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predictY">predictY</a></code>, <code><a href="#topic+plot.lcmm">plot.lcmm</a></code>
</p>

<hr>
<h2 id='ForInternalUse'>For internal use only ...</h2><span id='topic+ForInternalUse'></span><span id='topic+mixture'></span><span id='topic+factor.names'></span><span id='topic+.Ordlcmm'></span><span id='topic+.Contlcmm'></span><span id='topic+risq_spl'></span><span id='topic+risqcum_spl'></span><span id='topic+.plotresid'></span><span id='topic+.plotpostprob'></span><span id='topic+.plotfit'></span><span id='topic+.plotlinkfuntion'></span><span id='topic+.plotlinkfunctionmult'></span><span id='topic+.plotbaselinerisk'></span><span id='topic+.plotsurvival'></span><span id='topic+C_hetmixlin'></span><span id='topic+C_hetmixcont'></span><span id='topic+C_hetmixord'></span><span id='topic+C_hetmixcontmult'></span><span id='topic+C_jointhet'></span><span id='topic+C_predictcont'></span><span id='topic+C_predictmult'></span><span id='topic+C_postprob2'></span><span id='topic+C_cvpl'></span><span id='topic+C_calculustransfo'></span><span id='topic+Brandom'></span>

<h3>Description</h3>

<p>For internal use only ...
</p>

<hr>
<h2 id='gridsearch'>Automatic grid search</h2><span id='topic+gridsearch'></span>

<h3>Description</h3>

<p>This function provides an automatic grid search for latent class mixed
models estimated with <code>hlme</code>, <code>lcmm</code>, <code>multlcmm</code> and
<code>Jointlcmm</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gridsearch(m, rep, maxiter, minit, cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gridsearch_+3A_m">m</code></td>
<td>
<p>a call of <code>hlme</code>, <code>lcmm</code>, <code>multlcmm</code>, 
<code>Jointlcmm</code> or <code>mpjlcmm</code> corresponding to the model to estimate</p>
</td></tr>
<tr><td><code id="gridsearch_+3A_rep">rep</code></td>
<td>
<p>the number of departures from random initial values</p>
</td></tr>
<tr><td><code id="gridsearch_+3A_maxiter">maxiter</code></td>
<td>
<p>the number of iterations in the optimization algorithm</p>
</td></tr>
<tr><td><code id="gridsearch_+3A_minit">minit</code></td>
<td>
<p>an object of class <code>hlme</code>, <code>lcmm</code>, <code>multlcmm</code>,
<code>Jointlcmm</code> or <code>mpjlcmm</code> corresponding to the same model as specified
in m except for the number of classes (it should be one). This object is used to
generate random initial values</p>
</td></tr>
<tr><td><code id="gridsearch_+3A_cl">cl</code></td>
<td>
<p>a cluster created by makeCluster from package parallel or an integer
specifying the number of cores to use for parallel computation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function permits the estimation of a model from a grid of random initial
values to reduce the odds of a convergence towards a local maximum.
</p>
<p>The function was inspired by the emEM technique described in Biernacki et
al. (2003). It consists in:
</p>
<p>1. randomly generating <code>rep</code> sets of initial values for <code>m</code> from
the estimates of <code>minit</code> (this is done internally using option
<code>B=random(minit)</code> <code>rep</code> times)
</p>
<p>2. running the optimization algorithm for the model specified in <code>m</code>
from the <code>rep</code> sets of initial values with a maximum number of
iterations of <code>maxit</code> each time.
</p>
<p>3. retaining the estimates of the random initialization that provides the
best log-likelihood after <code>maxiter</code> iterations.
</p>
<p>4. running the optimization algorithm from these estimates for the final
estimation.
</p>


<h3>Value</h3>

<p>an object of class <code>hlme</code>, <code>lcmm</code>, <code>multlcmm</code>,
<code>Jointlcmm</code> or <code>mpjlcmm</code> corresponding to the call specified in m.
</p>


<h3>Author(s)</h3>

<p>Cecile Proust-Lima and Viviane Philipps
</p>


<h3>References</h3>

<p>Biernacki C, Celeux G, Govaert G (2003). Choosing Starting
Values for the EM Algorithm for Getting the Highest Likelihood in
Multivariate Gaussian Mixture models. Computational Statistics and Data
Analysis, 41(3-4), 561-575.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# initial model with ng=1 for the random initial values
m1 &lt;- hlme(Y ~ Time * X1, random =~ Time, subject = 'ID', ng = 1, 
      data = data_hlme)

# gridsearch with 10 iterations from 50 random departures
m2d &lt;- gridsearch(rep = 50, maxiter = 10, minit = m1, hlme(Y ~ Time * X1,
      mixture =~ Time, random =~ Time, classmb =~ X2 + X3, subject = 'ID',
          ng = 2, data = data_hlme))
        
## End(Not run)

</code></pre>

<hr>
<h2 id='hlme'>Estimation of latent class linear mixed models</h2><span id='topic+hlme'></span>

<h3>Description</h3>

<p>This function fits linear mixed models and latent class linear mixed models
(LCLMM) also known as growth mixture models or heterogeneous linear mixed
models.  The LCLMM consists in assuming that the population is divided in a
finite number of latent classes. Each latent class is characterised by a
specific trajectory modelled by a class-specific linear mixed model.  Both
the latent class membership and the trajectory can be explained according to
covariates.  This function is limited to a mixture of Gaussian outcomes. For
other types of outcomes, please see function <code>lcmm</code>. For multivariate
longitudinal outcomes, please see <code>multlcmm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hlme(
  fixed,
  mixture,
  random,
  subject,
  classmb,
  ng = 1,
  idiag = FALSE,
  nwg = FALSE,
  cor = NULL,
  data,
  B,
  convB = 1e-04,
  convL = 1e-04,
  convG = 1e-04,
  prior,
  pprior = NULL,
  maxiter = 500,
  subset = NULL,
  na.action = 1,
  posfix = NULL,
  verbose = FALSE,
  returndata = FALSE,
  var.time = NULL,
  partialH = FALSE,
  nproc = 1,
  clustertype = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hlme_+3A_fixed">fixed</code></td>
<td>
<p>two-sided linear formula object for the fixed-effects in the
linear mixed model. The response outcome is on the left of <code>~</code> and the
covariates are separated by <code>+</code> on the right of <code>~</code>.  By default,
an intercept is included. If no intercept, <code>-1</code> should be the first
term included on the right of <code>~</code>.</p>
</td></tr>
<tr><td><code id="hlme_+3A_mixture">mixture</code></td>
<td>
<p>one-sided formula object for the class-specific fixed effects
in the linear mixed model (to specify only for a number of latent classes
greater than 1).  Among the list of covariates included in <code>fixed</code>, the
covariates with class-specific regression parameters are entered in
<code>mixture</code> separated by <code>+</code>.  By default, an intercept is included.
If no intercept, <code>-1</code> should be the first term included.</p>
</td></tr>
<tr><td><code id="hlme_+3A_random">random</code></td>
<td>
<p>optional one-sided formula for the random-effects in the
linear mixed model. Covariates with a random-effect are separated by
<code>+</code>.  By default, an intercept is included. If no intercept, <code>-1</code>
should be the first term included.</p>
</td></tr>
<tr><td><code id="hlme_+3A_subject">subject</code></td>
<td>
<p>name of the covariate representing the grouping structure
specified with &rdquo;.</p>
</td></tr>
<tr><td><code id="hlme_+3A_classmb">classmb</code></td>
<td>
<p>optional one-sided formula describing the covariates in the
class-membership multinomial logistic model. Covariates included are
separated by <code>+</code>. By default, classmb=~1 if ng&gt;1.</p>
</td></tr>
<tr><td><code id="hlme_+3A_ng">ng</code></td>
<td>
<p>optional number of latent classes considered. If <code>ng=1</code> (by
default) no <code>mixture</code> nor <code>classmb</code> should be specified. If
<code>ng&gt;1</code>, <code>mixture</code> is required.</p>
</td></tr>
<tr><td><code id="hlme_+3A_idiag">idiag</code></td>
<td>
<p>optional logical for the structure of the variance-covariance
matrix of the random-effects. If <code>FALSE</code>, a non structured matrix of
variance-covariance is considered (by default).  If <code>TRUE</code> a diagonal
matrix of variance-covariance is considered.</p>
</td></tr>
<tr><td><code id="hlme_+3A_nwg">nwg</code></td>
<td>
<p>optional logical indicating if the variance-covariance of the
random-effects is class-specific. If <code>FALSE</code> the variance-covariance
matrix is common over latent classes (by default). If <code>TRUE</code> a
class-specific proportional parameter multiplies the variance-covariance
matrix in each class (the proportional parameter in the last latent class
equals 1 to ensure identifiability).</p>
</td></tr>
<tr><td><code id="hlme_+3A_cor">cor</code></td>
<td>
<p>optional brownian motion or autoregressive process modeling the
correlation between the observations.  &quot;BM&quot; or &quot;AR&quot; should be specified,
followed by the time variable between brackets. By default, no correlation
is added.</p>
</td></tr>
<tr><td><code id="hlme_+3A_data">data</code></td>
<td>
<p>optional data frame containing the variables named in
<code>fixed</code>, <code>mixture</code>, <code>random</code>, <code>classmb</code> and
<code>subject</code>.</p>
</td></tr>
<tr><td><code id="hlme_+3A_b">B</code></td>
<td>
<p>optional specification for the initial values for the parameters.
Three options are allowed: (1) a vector of initial values is entered (the
order in which the parameters are included is detailed in <code>details</code>
section).  (2) nothing is specified. A preliminary analysis involving the
estimation of a standard linear mixed model is performed to choose initial
values.  (3) when ng&gt;1, a hlme object is entered. It should correspond to
the exact same structure of model but with ng=1. The program will
automatically generate initial values from this model. This specification
avoids the preliminary analysis indicated in (2). Note that due to possible
local maxima, the <code>B</code> vector should be specified and several different
starting points should be tried.</p>
</td></tr>
<tr><td><code id="hlme_+3A_convb">convB</code></td>
<td>
<p>optional threshold for the convergence criterion based on the
parameter stability. By default, convB=0.0001.</p>
</td></tr>
<tr><td><code id="hlme_+3A_convl">convL</code></td>
<td>
<p>optional threshold for the convergence criterion based on the
log-likelihood stability. By default, convL=0.0001.</p>
</td></tr>
<tr><td><code id="hlme_+3A_convg">convG</code></td>
<td>
<p>optional threshold for the convergence criterion based on the
derivatives. By default, convG=0.0001.</p>
</td></tr>
<tr><td><code id="hlme_+3A_prior">prior</code></td>
<td>
<p>optional name of a covariate containing a prior information
about the latent class membership. The covariate should be an integer with
values in 0,1,...,ng. Value 0 indicates no prior for the subject while a
value in 1,...,ng indicates that the subject belongs to the corresponding
latent class.</p>
</td></tr>
<tr><td><code id="hlme_+3A_pprior">pprior</code></td>
<td>
<p>optional vector specifying the names of the covariates containing the
prior probabilities to belong to each latent class. These probabilities should be
between 0 and 1 and should sum up to 1 for each subject.</p>
</td></tr>
<tr><td><code id="hlme_+3A_maxiter">maxiter</code></td>
<td>
<p>optional maximum number of iterations for the Marquardt
iterative algorithm. By default, maxiter=500.</p>
</td></tr>
<tr><td><code id="hlme_+3A_subset">subset</code></td>
<td>
<p>a specification of the rows to be used: defaults to all rows.
This can be any valid indexing vector for the rows of data or if that is not
supplied, a data frame made up of the variable used in formula.</p>
</td></tr>
<tr><td><code id="hlme_+3A_na.action">na.action</code></td>
<td>
<p>Integer indicating how NAs are managed. The default is 1
for 'na.omit'. The alternative is 2 for 'na.fail'. Other options such as
'na.pass' or 'na.exclude' are not implemented in the current version.</p>
</td></tr>
<tr><td><code id="hlme_+3A_posfix">posfix</code></td>
<td>
<p>Optional vector specifying the indices in vector B of the
parameters that should not be estimated. Default to NULL, all parameters are
estimated.</p>
</td></tr>
<tr><td><code id="hlme_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating if information about computation should be
reported. Default to TRUE.</p>
</td></tr>
<tr><td><code id="hlme_+3A_returndata">returndata</code></td>
<td>
<p>logical indicating if data used for computation should be
returned. Default to FALSE, data are not returned.</p>
</td></tr>
<tr><td><code id="hlme_+3A_var.time">var.time</code></td>
<td>
<p>optional character indicating the name of the time variable.</p>
</td></tr>
<tr><td><code id="hlme_+3A_partialh">partialH</code></td>
<td>
<p>optional logical indicating if parameters can be dropped from the
Hessian matrix to define convergence criteria.</p>
</td></tr>
<tr><td><code id="hlme_+3A_nproc">nproc</code></td>
<td>
<p>the number cores for parallel computation.
Default to 1 (sequential mode).</p>
</td></tr>
<tr><td><code id="hlme_+3A_clustertype">clustertype</code></td>
<td>
<p>optional character indicating the type of cluster for parallel computation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A. THE VECTOR OF PARAMETERS B
</p>
<p>The parameters in the vector of initial values <code>B</code> or equivalently in
the vector of maximum likelihood estimates <code>best</code> are included in the
following order:
</p>
<p>(1) ng-1 parameters are required for intercepts in the latent class
membership model, and when covariates are included in <code>classmb</code>, ng-1
paramaters should be entered for each covariate;
</p>
<p>(2) for all covariates in <code>fixed</code>, one parameter is required if the
covariate is not in <code>mixture</code>, ng paramaters are required if the
covariate is also in <code>mixture</code>;
</p>
<p>(3) the variance of each random-effect specified in <code>random</code> (including
the intercept) when <code>idiag=TRUE</code>, or the inferior triangular
variance-covariance matrix of all the random-effects when
<code>idiag=FALSE</code>;
</p>
<p>(4) only when <code>nwg=TRUE</code>, ng-1 parameters are required for the ng-1
class-specific proportional coefficients in the variance covariance matrix
of the random-effects;
</p>
<p>(5) when <code>cor</code> is specified, 1 parameter corresponding to the variance
of the Brownian motion should be entered with <code>cor=BM</code> and 2 parameters
corresponding to the correlation and the variance parameters of the
autoregressive process should be entered
</p>
<p>(6) the standard error of the residual error.
</p>
<p>B. CAUTIONS
</p>
<p>Some caution should be made when using the program:
</p>
<p>(1) As the log-likelihood of a latent class model can have multiple maxima,
a careful choice of the initial values is crucial for ensuring convergence
toward the global maximum.  The program can be run without entering the
vector of initial values (see point 2).  However, we recommend to
systematically enter initial values in <code>B</code> and try different sets of
initial values.
</p>
<p>(2) The automatic choice of initial values we provide requires the
estimation of a preliminary linear mixed model. The user should be aware
that first, this preliminary analysis can take time for large datatsets and
second, that the generated initial values can be very not likely and even
may converge slowly to a local maximum.  This is the reason why several
alternatives exist. The vector of initial values can be directly specified
in <code>B</code> the initial values can be generated (automatically or randomly)
from a model with <code>ng=</code>. Finally, function <code>gridsearch</code> performs
an automatic grid search.
</p>
<p>(3) Convergence criteria are very strict as they are based on the
derivatives of the log-likelihood in addition to the parameter stability and
log-likelihood stability.  In some cases, the program may not converge and
reach the maximum number of iterations fixed at 100.  In this case, the user
should check that parameter estimates at the last iteration are not on the
boundaries of the parameter space.  If the parameters are on the boundaries
of the parameter space, the identifiability of the model is critical. This
may happen especially with splines parameters that may be too close to 0
(lower boundary) or classmb parameters that are too high or low (perfect
classification). When identifiability of some parameters is suspected, the
program can be run again from the former estimates by fixing the suspected
parameters to their value with option posfix. This usually solves the
problem. An alternative is to remove the parameters of the Beta of Splines
link function from the inverse of the Hessian with option partialH.  If not,
the program should be run again with other initial values, with a higher
maximum number of iterations or less strict convergence tolerances.
</p>


<h3>Value</h3>

<p>The list returned is:
</p>
<table role = "presentation">
<tr><td><code>ns</code></td>
<td>
<p>number of grouping units in the dataset</p>
</td></tr>
<tr><td><code>ng</code></td>
<td>
<p>number of latent classes</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>log-likelihood of the model</p>
</td></tr>
<tr><td><code>best</code></td>
<td>
<p>vector of parameter estimates in the same order as specified in <code>B</code> and detailed in section <code>Details</code></p>
</td></tr>
<tr><td><code>V</code></td>
<td>
<p>if the model converged (conv=1 or 3), vector containing the upper triangle
matrix of variance-covariance estimates of <code>best</code> with exception for
variance-covariance parameters of the random-effects for which <code>V</code> contains
the variance-covariance estimates of the Cholesky transformed parameters displayed in
<code>cholesky</code>.
If conv=2, <code>V</code> contains the second derivatives of the log-likelihood.</p>
</td></tr>
<tr><td><code>gconv</code></td>
<td>
<p>vector of convergence criteria: 1. on the parameters, 2. on the
likelihood, 3. on the derivatives</p>
</td></tr>
<tr><td><code>conv</code></td>
<td>
<p>status of convergence: =1 if the convergence criteria were satisfied,
=2 if the maximum number of iterations was reached, =3 if the convergence criteria were
satisfied with a partial Hessian matrix, =4 or 5 if a problem occured
during optimisation</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr>
<tr><td><code>niter</code></td>
<td>
<p>number of Marquardt iterations</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>internal information used in related functions</p>
</td></tr>
<tr><td><code>idiag</code></td>
<td>
<p>internal information used in related functions</p>
</td></tr>
<tr><td><code>pred</code></td>
<td>
<p>table of individual predictions and residuals; it
includes marginal predictions (pred_m), marginal residuals (resid_m),
subject-specific predictions (pred_ss) and subject-specific residuals
(resid_ss) averaged over classes, the observation (obs) and finally the
class-specific marginal and subject-specific predictions (with the number of
the latent class: pred_m_1,pred_m_2,...,pred_ss_1,pred_ss_2,...). If <code>var.time</code>
is specified, the corresponding measurement time is also included.</p>
</td></tr>
<tr><td><code>pprob</code></td>
<td>
<p>table of posterior classification and posterior individual
class-membership probabilities</p>
</td></tr>
<tr><td><code>Xnames</code></td>
<td>
<p>list of covariates included in the model</p>
</td></tr> 
<tr><td><code>predRE</code></td>
<td>
<p>table containing individual predictions of the random-effects
: a column per random-effect, a line per subject</p>
</td></tr>
<tr><td><code>cholesky</code></td>
<td>
<p>vector containing the estimates of the Cholesky transformed
parameters of the variance-covariance matrix of the random-effects</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>the original data set (if returndata is TRUE)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cecile Proust-Lima, Benoit Liquet and Viviane Philipps
</p>
<p><a href="mailto:cecile.proust-lima@inserm.fr">cecile.proust-lima@inserm.fr</a>
</p>


<h3>References</h3>

<p>Proust-Lima C, Philipps V, Liquet B (2017). Estimation of Extended Mixed 
Models Using Latent Classes and Latent Processes: The R Package lcmm. 
Journal of Statistical Software, 78(2), 1-56. doi:10.18637/jss.v078.i02
</p>
<p>Verbeke G and Lesaffre E (1996). A linear mixed-effects model with
heterogeneity in the random-effects population. Journal of the American
Statistical Association 91, 217-21
</p>
<p>Muthen B and Shedden K (1999). Finite mixture modeling with mixture outcomes
using the EM algorithm. Biometrics 55, 463-9
</p>
<p>Proust C and Jacqmin-Gadda H (2005). Estimation of linear mixed models with
a mixture of distribution for the random-effects. Computer Methods Programs
Biomedicine 78, 165-73
</p>


<h3>See Also</h3>

<p><code><a href="#topic+postprob">postprob</a></code>, <code><a href="#topic+plot.hlme">plot.hlme</a></code>,
<code><a href="base.html#topic+summary">summary</a></code>, <code><a href="#topic+predictY">predictY</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

##### Example of a latent class model estimated for a varying number
# of latent classes: 
# The model includes a subject- (ID) and class-specific linear 
# trend (intercept and Time in fixed, random and mixture components)
# and a common effect of X1 and its interaction with time over classes 
# (in fixed). 
# The variance of the random intercept and slope are assumed to be equal 
# over classes (nwg=F).
# The covariate X3 predicts the class membership (in classmb).
#
# !CAUTION: initialization of mixed models with latent classes is 
# of most importance because of the problem of multimodality of the likelihood.
# Calls m2a-m2d illustrate the different implementations for the 
# initial values.

### homogeneous linear mixed model (standard linear mixed model) 
### with correlated random-effects
m1&lt;-hlme(Y~Time*X1,random=~Time,subject='ID',ng=1,data=data_hlme)
summary(m1)

### latent class linear mixed model with 2 classes

# a. automatic specification from G=1 model estimates:
m2a&lt;-hlme(Y~Time*X1,mixture=~Time,random=~Time,classmb=~X2+X3,subject='ID',
         ng=2,data=data_hlme,B=m1)
         
# b. vector of initial values provided by the user:
m2b&lt;-hlme(Y~Time*X1,mixture=~Time,random=~Time,classmb=~X2+X3,subject='ID',
         ng=2,data=data_hlme,B=c(0.11,-0.74,-0.07,20.71,
                                 29.39,-1,0.13,2.45,-0.29,4.5,0.36,0.79,0.97))
 
# c. random draws from G = 1 model estimates:
m2c&lt;-hlme(Y~Time*X1,mixture=~Time,random=~Time,classmb=~X2+X3,subject='ID',
          ng=2,data=data_hlme,B=random(m1))

# d. gridsearch with 50 departures and 10 iterations of the algorithm 
#     (see function gridsearch for details)
## Not run: 
m2d &lt;- gridsearch(rep = 50, maxiter = 10, minit = m1, hlme(Y ~ Time * X1, 
mixture =~ Time, random =~ Time, classmb =~ X2 + X3, subject = 'ID', ng = 2, 
data = data_hlme))


## End(Not run)  
          


# summary of the estimation process
summarytable(m1, m2a, m2b, m2c)

# summary of m2a
summary(m2a)

# posterior classification
postprob(m2a)

# plot of predicted trajectories using some newdata
newdata&lt;-data.frame(Time=seq(0,5,length=100),
X1=rep(0,100),X2=rep(0,100),X3=rep(0,100))
plot(predictY(m2a,newdata,var.time="Time"),legend.loc="right",bty="l")



</code></pre>

<hr>
<h2 id='ItemInfo'>Conditional probabilities and item information given specified latent process values
for <code>lcmm</code> or <code>multlcmm</code>
object with ordinal outcomes.</h2><span id='topic+ItemInfo'></span>

<h3>Description</h3>

<p>The function computes the conditional probability and information function of
each level of each ordinal outcome and the information function at the item level.
Confidence bands (and median) can be computed by a Monte Carlo approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ItemInfo(
  x,
  lprocess,
  condRE_Y = FALSE,
  nsim = 200,
  draws = FALSE,
  ndraws = 2000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ItemInfo_+3A_x">x</code></td>
<td>
<p>an object inheriting from class  <code>lcmm</code> or <code>multlcmm</code>, 
representing a general (latent class) mixed model.</p>
</td></tr>
<tr><td><code id="ItemInfo_+3A_lprocess">lprocess</code></td>
<td>
<p>numeric vector containing the latent process values at which the
predictions should be computed.</p>
</td></tr>
<tr><td><code id="ItemInfo_+3A_condre_y">condRE_Y</code></td>
<td>
<p>for multlcmm objects only, logical indicating if the predictions
are conditional to the outcome-specific random-effects or not. Default to FALSE=
the predictions are marginal to these random effects.</p>
</td></tr>
<tr><td><code id="ItemInfo_+3A_nsim">nsim</code></td>
<td>
<p>number of points used in the numerical integration (Monte-Carlo) with
splines or Beta link functions. nsim should be relatively important
(nsim=200 by default).</p>
</td></tr>
<tr><td><code id="ItemInfo_+3A_draws">draws</code></td>
<td>
<p>optional boolean specifying whether median and confidence bands
of the predicted values should be computed (TRUE). A Monte Carlo approximation 
of the posterior distribution of the predicted values is computed and the median, 
2.5% and 97.5% percentiles are given. Otherwise, the predicted values are 
computed at the point estimate. By default, draws=FALSE.</p>
</td></tr>
<tr><td><code id="ItemInfo_+3A_ndraws">ndraws</code></td>
<td>
<p>if draws=TRUE, ndraws specifies the number of draws that should be
generated to approximate the posterior distribution of the predicted values.
By default, ndraws=2000.</p>
</td></tr>
<tr><td><code id="ItemInfo_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.  They
are ignored in this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>ItemInfo</code> with values :
</p>
<p>- <code>ItemInfo</code>: 
If draws=FALSE, returns a matrix with 3 columns: the first column indicates the
name of the outcome, the second indicates the latent process value and the last
is the computed Fisher information.
If draws=TRUE, returns a matrix with 5 columns: the name of the outcome, the
latent process value and the 50%, 2.5% and 97.5% percentiles of the approximated
posterior distribution of information.
</p>
<p>- <code>LevelInfo</code>: 
If draws=FALSE, returns a matrix with 5 columns: the first column indicates the
name of the outcome, the second indicates the outcome's level, the third indicates the
latent process value and the two last contain the probability and Fisher information.
If draws=TRUE, returns a matrix with 5 columns: the name of the outcome,
the outcome's level, the latent process value and the 50%, 2.5% and 97.5%
percentiles of the approximated posterior distribution of the probability and information.
</p>
<p>- <code>object</code>: the model from which the computations are done.
</p>
<p>- <code>IC</code>: indicator specifying if confidence intervals are computed.
</p>


<h3>Author(s)</h3>

<p>Cecile Proust-Lima, Viviane Philipps
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## This is a toy example to illustrate the information functions.
## The binary outcomes are arbitrarily created, please do not
## consider them as relevent indicators.
data_lcmm$Yord1 &lt;- as.numeric(data_lcmm$Ydep1&gt;10)
data_lcmm$Yord2 &lt;- as.numeric(data_lcmm$Ydep2&gt;25)
m &lt;- multlcmm(Yord1+Yord2~Time+I(Time^2),random=~Time,subject='ID',ng=1,
data=data_lcmm,link="thresholds")
info &lt;- ItemInfo(m,lprocess=seq(-4,4,length.out=100),draws=TRUE)
plot(info)
par(mfrow=c(1,2))
plot(info, which="LevelInfo", outcome="Yord1")
plot(info, which="LevelInfo", outcome="Yord2")
plot(info, which="LevelProb", outcome="Yord1")
plot(info, which="LevelProb", outcome="Yord2")

## End(Not run)

</code></pre>

<hr>
<h2 id='Jointlcmm'>Estimation of joint latent class models for longitudinal and time-to-event
data</h2><span id='topic+Jointlcmm'></span><span id='topic+jlcmm'></span>

<h3>Description</h3>

<p>This function fits joint latent class mixed models for a longitudinal
outcome and a right-censored (possibly left-truncated) time-to-event. The
function handles competing risks and Gaussian or non Gaussian (curvilinear)
longitudinal outcomes. For curvilinear longitudinal outcomes, normalizing
continuous functions (splines or Beta CDF) can be specified as in
<code>lcmm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Jointlcmm(
  fixed,
  mixture,
  random,
  subject,
  classmb,
  ng = 1,
  idiag = FALSE,
  nwg = FALSE,
  survival,
  hazard = "Weibull",
  hazardtype = "Specific",
  hazardnodes = NULL,
  hazardrange = NULL,
  TimeDepVar = NULL,
  link = NULL,
  intnodes = NULL,
  epsY = 0.5,
  range = NULL,
  cor = NULL,
  data,
  B,
  convB = 1e-04,
  convL = 1e-04,
  convG = 1e-04,
  maxiter = 100,
  nsim = 100,
  prior = NULL,
  pprior = NULL,
  logscale = FALSE,
  subset = NULL,
  na.action = 1,
  posfix = NULL,
  partialH = FALSE,
  verbose = FALSE,
  returndata = FALSE,
  var.time = NULL,
  nproc = 1,
  clustertype = NULL
)

jlcmm(
  fixed,
  mixture,
  random,
  subject,
  classmb,
  ng = 1,
  idiag = FALSE,
  nwg = FALSE,
  survival,
  hazard = "Weibull",
  hazardtype = "Specific",
  hazardnodes = NULL,
  hazardrange = NULL,
  TimeDepVar = NULL,
  link = NULL,
  intnodes = NULL,
  epsY = 0.5,
  range = NULL,
  cor = NULL,
  data,
  B,
  convB = 1e-04,
  convL = 1e-04,
  convG = 1e-04,
  maxiter = 100,
  nsim = 100,
  prior = NULL,
  pprior = NULL,
  logscale = FALSE,
  subset = NULL,
  na.action = 1,
  posfix = NULL,
  partialH = FALSE,
  verbose = FALSE,
  returndata = FALSE,
  var.time = NULL,
  nproc = 1,
  clustertype = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Jointlcmm_+3A_fixed">fixed</code></td>
<td>
<p>two-sided linear formula object for the fixed-effects in the
linear mixed model. The response outcome is on the left of <code>~</code> and the
covariates are separated by <code>+</code> on the right of the <code>~</code>.  By
default, an intercept is included. If no intercept, <code>-1</code> should be the
first term included on the right of <code>~</code>.</p>
</td></tr>
<tr><td><code id="Jointlcmm_+3A_mixture">mixture</code></td>
<td>
<p>one-sided formula object for the class-specific fixed effects
in the linear mixed model (to specify only for a number of latent classes
greater than 1).  Among the list of covariates included in <code>fixed</code>, the
covariates with class-specific regression parameters are entered in
<code>mixture</code> separated by <code>+</code>.  By default, an intercept is included.
If no intercept, <code>-1</code> should be the first term included.</p>
</td></tr>
<tr><td><code id="Jointlcmm_+3A_random">random</code></td>
<td>
<p>optional one-sided formula for the random-effects in the
linear mixed model. Covariates with a random-effect are separated by
<code>+</code>.  By default, an intercept is included. If no intercept, <code>-1</code>
should be the first term included.</p>
</td></tr>
<tr><td><code id="Jointlcmm_+3A_subject">subject</code></td>
<td>
<p>name of the covariate representing the grouping structure
(called subject identifier) specified with &rdquo;.</p>
</td></tr>
<tr><td><code id="Jointlcmm_+3A_classmb">classmb</code></td>
<td>
<p>optional one-sided formula describing the covariates in the
class-membership multinomial logistic model. Covariates included are
separated by <code>+</code>. No intercept should be included in this formula.</p>
</td></tr>
<tr><td><code id="Jointlcmm_+3A_ng">ng</code></td>
<td>
<p>optional number of latent classes considered. If <code>ng=1</code> (by
default) no <code>mixture</code> nor <code>classmb</code> should be specified. If
<code>ng&gt;1</code>, <code>mixture</code> is required.</p>
</td></tr>
<tr><td><code id="Jointlcmm_+3A_idiag">idiag</code></td>
<td>
<p>optional logical for the structure of the variance-covariance
matrix of the random-effects. If <code>FALSE</code>, a non structured matrix of
variance-covariance is considered (by default).  If <code>TRUE</code> a diagonal
matrix of variance-covariance is considered.</p>
</td></tr>
<tr><td><code id="Jointlcmm_+3A_nwg">nwg</code></td>
<td>
<p>optional logical indicating if the variance-covariance of the
random-effects is class-specific. If <code>FALSE</code> the variance-covariance
matrix is common over latent classes (by default). If <code>TRUE</code> a
class-specific proportional parameter multiplies the variance-covariance
matrix in each class (the proportional parameter in the last latent class
equals 1 to ensure identifiability).</p>
</td></tr>
<tr><td><code id="Jointlcmm_+3A_survival">survival</code></td>
<td>
<p>two-sided formula object. The left side of the formula
corresponds to a <code>surv()</code> object of type &quot;counting&quot; for right-censored
and left-truncated data (example: <code>Surv(Time,EntryTime,Indicator)</code>) or
of type &quot;right&quot; for right-censored data (example:
<code>Surv(Time,Indicator)</code>). Multiple causes of event can be considered in
the Indicator (0 for censored, k for cause k of event).  The right side of
the formula specifies the names of covariates to include in the survival
model with <code>mixture()</code> when the effect is class-specific (example:
<code>Surv(Time,Indicator) ~</code> <code> X1 + mixture(X2)</code> for a class-common
effect of X1 and a class-specific effect of X2). In the presence of
competing events, covariate effects are common by default. Code
<code>cause(X3)</code> specifies a cause-specific covariate effect for X3 on each
cause of event while <code>cause1(X3)</code> (or <code>cause2(X3)</code>, ...) specifies
a cause-specific effect of X3 on the first (or second, ...) cause only.</p>
</td></tr>
<tr><td><code id="Jointlcmm_+3A_hazard">hazard</code></td>
<td>
<p>optional family of hazard function assumed for the survival
model. By default, &quot;Weibull&quot; specifies a Weibull baseline risk function.
Other possibilities are &quot;piecewise&quot; for a piecewise constant risk function
or &quot;splines&quot; for a cubic M-splines baseline risk function. For these two
latter families, the number of nodes and the location of the nodes should be
specified as well, separated by <code>-</code>. The number of nodes is entered
first followed by <code>-</code>, then the location is specified with &quot;equi&quot;,
&quot;quant&quot; or &quot;manual&quot; for respectively equidistant nodes, nodes at quantiles
of the times of event distribution or interior nodes entered manually in
argument <code>hazardnodes</code>. It is followed by <code>-</code> and finally
&quot;piecewise&quot; or &quot;splines&quot; indicates the family of baseline risk function
considered. Examples include &quot;5-equi-splines&quot; for M-splines with 5
equidistant nodes, &quot;6-quant-piecewise&quot; for piecewise constant risk over 5
intervals and nodes defined at the quantiles of the times of events
distribution and &quot;9-manual-splines&quot; for M-splines risk function with 9
nodes, the vector of 7 interior nodes being entered in the argument
<code>hazardnodes</code>. In the presence of competing events, a vector of hazards
should be provided such as <code>hazard=c("Weibull","splines"</code> with 2 causes
of event, the first one modelled by a Weibull baseline cause-specific risk
function and the second one by splines.</p>
</td></tr>
<tr><td><code id="Jointlcmm_+3A_hazardtype">hazardtype</code></td>
<td>
<p>optional indicator for the type of baseline risk function
when ng&gt;1. By default &quot;Specific&quot; indicates a class-specific baseline risk
function. Other possibilities are &quot;PH&quot; for a baseline risk function
proportional in each latent class, and &quot;Common&quot; for a baseline risk function
that is common over classes. In the presence of competing events, a vector
of hazardtypes should be given.</p>
</td></tr>
<tr><td><code id="Jointlcmm_+3A_hazardnodes">hazardnodes</code></td>
<td>
<p>optional vector containing interior nodes if
<code>splines</code> or <code>piecewise</code> is specified for the baseline hazard
function in <code>hazard</code>.</p>
</td></tr>
<tr><td><code id="Jointlcmm_+3A_hazardrange">hazardrange</code></td>
<td>
<p>optional vector indicating the range of the survival times (that is
the minimum and maximum). By default, the range is defined according to the
minimum and maximum observed values of the survival times. The option should be
used only for piecewise constant and Splines hazard functions.</p>
</td></tr>
<tr><td><code id="Jointlcmm_+3A_timedepvar">TimeDepVar</code></td>
<td>
<p>optional vector containing an intermediate time
corresponding to a change in the risk of event. This time-dependent
covariate can only take the form of a time variable with the assumption that
there is no effect on the risk before this time and a constant effect on the
risk of event after this time (example: initiation of a treatment to account
for).</p>
</td></tr>
<tr><td><code id="Jointlcmm_+3A_link">link</code></td>
<td>
<p>optional family of link functions to estimate. By default,
&quot;linear&quot; option specifies a linear link function leading to a standard
linear mixed model (homogeneous or heterogeneous as estimated in
<code>hlme</code>).  Other possibilities include &quot;beta&quot; for estimating a link
function from the family of Beta cumulative distribution functions,
&quot;thresholds&quot; for using a threshold model to describe the correspondence
between each level of an ordinal outcome and the underlying latent process,
and &quot;Splines&quot; for approximating the link function by I-splines. For this
latter case, the number of nodes and the nodes location should be also
specified. The number of nodes is first entered followed by <code>-</code>, then
the location is specified with &quot;equi&quot;, &quot;quant&quot; or &quot;manual&quot; for respectively
equidistant nodes, nodes at quantiles of the marker distribution or interior
nodes entered manually in argument <code>intnodes</code>. It is followed by
<code>-</code> and finally &quot;splines&quot; is indicated. For example, &quot;7-equi-splines&quot;
means I-splines with 7 equidistant nodes, &quot;6-quant-splines&quot; means I-splines
with 6 nodes located at the quantiles of the marker distribution and
&quot;9-manual-splines&quot; means I-splines with 9 nodes, the vector of 7 interior
nodes being entered in the argument <code>intnodes</code>.</p>
</td></tr>
<tr><td><code id="Jointlcmm_+3A_intnodes">intnodes</code></td>
<td>
<p>optional vector of interior nodes. This argument is only
required for a I-splines link function with nodes entered manually.</p>
</td></tr>
<tr><td><code id="Jointlcmm_+3A_epsy">epsY</code></td>
<td>
<p>optional definite positive real used to rescale the marker in
(0,1) when the beta link function is used. By default, epsY=0.5.</p>
</td></tr>
<tr><td><code id="Jointlcmm_+3A_range">range</code></td>
<td>
<p>optional vector indicating the range of the outcome (that is
the minimum and maximum). By default, the range is defined according to the
minimum and maximum observed values of the outcome. The option should be
used only for Beta and Splines transformations.</p>
</td></tr>
<tr><td><code id="Jointlcmm_+3A_cor">cor</code></td>
<td>
<p>optional brownian motion or autoregressive process modeling the
correlation between the observations.  &quot;BM&quot; or &quot;AR&quot; should be specified,
followed by the time variable between brackets. By default, no correlation
is added.</p>
</td></tr>
<tr><td><code id="Jointlcmm_+3A_data">data</code></td>
<td>
<p>optional data frame containing the variables named in
<code>fixed</code>, <code>mixture</code>, <code>random</code>, <code>classmb</code> and
<code>subject</code>.</p>
</td></tr>
<tr><td><code id="Jointlcmm_+3A_b">B</code></td>
<td>
<p>optional specification for the initial values for the parameters.
Three options are allowed: (1) a vector of initial values is entered (the
order in which the parameters are included is detailed in <code>details</code>
section).  (2) nothing is specified. A preliminary analysis involving the
estimation of a standard linear mixed model is performed to choose initial
values.  (3) when ng&gt;1, a Jointlcmm object is entered. It should correspond
to the exact same structure of model but with ng=1. The program will
automatically generate initial values from this model. This specification
avoids the preliminary analysis indicated in (2) Note that due to possible
local maxima, the <code>B</code> vector should be specified and several different
starting points should be tried.</p>
</td></tr>
<tr><td><code id="Jointlcmm_+3A_convb">convB</code></td>
<td>
<p>optional threshold for the convergence criterion based on the
parameter stability. By default, convB=0.0001.</p>
</td></tr>
<tr><td><code id="Jointlcmm_+3A_convl">convL</code></td>
<td>
<p>optional threshold for the convergence criterion based on the
log-likelihood stability. By default, convL=0.0001.</p>
</td></tr>
<tr><td><code id="Jointlcmm_+3A_convg">convG</code></td>
<td>
<p>optional threshold for the convergence criterion based on the
derivatives. By default, convG=0.0001.</p>
</td></tr>
<tr><td><code id="Jointlcmm_+3A_maxiter">maxiter</code></td>
<td>
<p>optional maximum number of iterations for the Marquardt
iterative algorithm. By default, maxiter=150.</p>
</td></tr>
<tr><td><code id="Jointlcmm_+3A_nsim">nsim</code></td>
<td>
<p>optional number of points for the predicted survival curves and
predicted baseline risk curves. By default, nsim=100.</p>
</td></tr>
<tr><td><code id="Jointlcmm_+3A_prior">prior</code></td>
<td>
<p>optional name of a covariate containing a prior information
about the latent class membership. The covariate should be an integer with
values in 0,1,...,ng. Value O indicates no prior for the subject while a
value in 1,...,ng indicates that the subject belongs to the corresponding
latent class.</p>
</td></tr>
<tr><td><code id="Jointlcmm_+3A_pprior">pprior</code></td>
<td>
<p>optional vector specifying the names of the covariates containing the
prior probabilities to belong to each latent class. These probabilities should be
between 0 and 1 and should sum up to 1 for each subject.</p>
</td></tr>
<tr><td><code id="Jointlcmm_+3A_logscale">logscale</code></td>
<td>
<p>optional boolean indicating whether an exponential
(logscale=TRUE) or a square (logscale=FALSE -by default) transformation is
used to ensure positivity of parameters in the baseline risk functions. See
details section</p>
</td></tr>
<tr><td><code id="Jointlcmm_+3A_subset">subset</code></td>
<td>
<p>a specification of the rows to be used: defaults to all rows.
This can be any valid indexing vector for the rows of data or if that is not
supplied, a data frame made up of the variable used in formula.</p>
</td></tr>
<tr><td><code id="Jointlcmm_+3A_na.action">na.action</code></td>
<td>
<p>Integer indicating how NAs are managed. The default is 1
for 'na.omit'. The alternative is 2 for 'na.fail'. Other options such as
'na.pass' or 'na.exclude' are not implemented in the current version.</p>
</td></tr>
<tr><td><code id="Jointlcmm_+3A_posfix">posfix</code></td>
<td>
<p>Optional vector specifying the indices in vector B of the
parameters that should not be estimated. Default to NULL, all parameters are
estimated.</p>
</td></tr>
<tr><td><code id="Jointlcmm_+3A_partialh">partialH</code></td>
<td>
<p>optional logical for Piecewise and Splines baseline risk
functions and Splines link functions only. Indicates whether the parameters of the
baseline risk or link functions can be dropped from the Hessian matrix to
define convergence criteria.</p>
</td></tr>
<tr><td><code id="Jointlcmm_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating if information about computation should be
reported. Default to TRUE.</p>
</td></tr>
<tr><td><code id="Jointlcmm_+3A_returndata">returndata</code></td>
<td>
<p>logical indicating if data used for computation should be
returned. Default to FALSE, data are not returned.</p>
</td></tr>
<tr><td><code id="Jointlcmm_+3A_var.time">var.time</code></td>
<td>
<p>optional character indicating the name of the time variable.</p>
</td></tr>
<tr><td><code id="Jointlcmm_+3A_nproc">nproc</code></td>
<td>
<p>the number cores for parallel computation.
Default to 1 (sequential mode).</p>
</td></tr>
<tr><td><code id="Jointlcmm_+3A_clustertype">clustertype</code></td>
<td>
<p>optional character indicating the type of cluster for parallel computation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A. BASELINE RISK FUNCTIONS
</p>
<p>For the baseline risk functions, the following parameterizations were
considered. Be careful, parametrisations changed in lcmm_V1.5:
</p>
<p>1. With the &quot;Weibull&quot; function: 2 parameters are necessary w_1 and w_2 so
that the baseline risk function a_0(t) = w_1^2 * w_2^2 * (w_1^2 * t)^(w_2^2 - 1) if
logscale=FALSE and a_0(t) = exp(w_1) * exp(w_2) * (t)^(exp(w_2) - 1) if
logscale=TRUE.
</p>
<p>2. with the &quot;piecewise&quot; step function and nz nodes (y_1,...y_nz), nz-1
parameters are necesssary p_1,...p_nz-1 so that the baseline risk function
a_0(t) = p_j^2 for y_j &lt; t =&lt; y_j+1 if logscale=FALSE and a_0(t) = exp(p_j)
for y_j &lt; t =&lt; y_j+1 if logscale=TRUE.
</p>
<p>3. with the &quot;splines&quot; function and nz nodes (y_1,...y_nz), nz+2 parameters
are necessary s_1,...s_nz+2 so that the baseline risk function a_0(t) =
sum_j s_j^2 M_j(t) if logscale=FALSE and a_0(t) = sum_j exp(s_j) M_j(t) if
logscale=TRUE where M_j is the basis of cubic M-splines.
</p>
<p>Two parametrizations of the baseline risk function are proposed
(logscale=TRUE or FALSE) because in some cases, especially when the
instantaneous risks are very close to 0, some convergence problems may
appear with one parameterization or the other. As a consequence, we
recommend to try the alternative parameterization (changing logscale option)
when a joint latent class model does not converge (maximum number of
iterations reached) where as convergence criteria based on the parameters
and likelihood are small.
</p>
<p>B. THE VECTOR OF PARAMETERS B
</p>
<p>The parameters in the vector of initial values <code>B</code> or in the vector of
maximum likelihood estimates <code>best</code> are included in the following
order: (1) ng-1 parameters are required for intercepts in the latent class
membership model, and if covariates are included in <code>classmb</code>, ng-1
parameters should be entered for each one; (2) parameters for the baseline
risk function: 2 parameters for each Weibull, nz-1 for each piecewise
constant risk and nz+2 for each splines risk; this number should be
multiplied by ng if specific hazard is specified; otherwise, ng-1 additional
proportional effects are expected if PH hazard is specified; otherwise
nothing is added if common hazard is specified. In the presence of competing
events, the number of parameters should be adapted to the number of causes
of event; (3) for all covariates in <code>survival</code>, ng parameters are
required if the covariate is inside a <code>mixture()</code>, otherwise 1
parameter is required. Covariates parameters should be included in the same
order as in <code>survival</code>. In the presence of cause-specific effects, the
number of parameters should be multiplied by the number of causes; (4) for
all covariates in <code>fixed</code>, one parameter is required if the covariate
is not in <code>mixture</code>, ng parameters are required if the covariate is
also in <code>mixture</code>. Parameters should be included in the same order as
in <code>fixed</code>; (5) the variance of each random-effect specified in
<code>random</code> (including the intercept) if <code>idiag=TRUE</code> and the
inferior triangular variance-covariance matrix of all the random-effects if
<code>idiag=FALSE</code>; (6) only if <code>nwg=TRUE</code>, ng-1 parameters for
class-specific proportional coefficients for the variance covariance matrix
of the random-effects; (7) the variance of the residual error.
</p>
<p>C. CAUTION
</p>
<p>Some caution should be made when using the program:
</p>
<p>(1) As the log-likelihood of a latent class model can have multiple maxima,
a careful choice of the initial values is crucial for ensuring convergence
toward the global maximum.  The program can be run without entering the
vector of initial values (see point 2).  However, we recommend to
systematically enter initial values in <code>B</code> and try different sets of
initial values.
</p>
<p>(2) The automatic choice of initial values that we provide requires the
estimation of a preliminary linear mixed model. The user should be aware
that first, this preliminary analysis can take time for large datatsets and
second, that the generated initial values can be very not likely and even
may converge slowly to a local maximum.  This is a reason why several
alternatives exist. The vector of initial values can be directly specified
in <code>B</code> the initial values can be generated (automatically or randomly)
from a model with <code>ng=</code>. Finally, function <code>gridsearch</code> performs
an automatic grid search.
</p>
<p>(3) Convergence criteria are very strict as they are based on derivatives of
the log-likelihood in addition to the parameter and log-likelihood
stability.  In some cases, the program may not converge and reach the
maximum number of iterations fixed at 150.  In this case, the user should
check that parameter estimates at the last iteration are not on the
boundaries of the parameter space.  If the parameters are on the boundaries
of the parameter space, the identifiability of the model is critical. This
may happen especially when baseline risk functions involve splines (value
close to the lower boundary - 0 with logscale=F -infinity with logscale=F)
or classmb parameters that are too high or low (perfect classification) or
linkfunction parameters. When identifiability of some parameters is
suspected, the program can be run again from the former estimates by fixing
the suspected parameters to their value with option posfix. This usually
solves the problem. An alternative is to remove the parameters of the Beta
of Splines link function from the inverse of the Hessian with option
partialH.  If not, the program should be run again with other initial
values.  Some problems of convergence may happen when the instantaneous
risks of event are very low and &quot;piecewise&quot; or &quot;splines&quot; baseline risk
functions are specified. In this case, changing the parameterization of the
baseline risk functions with option logscale is recommended (see paragraph A
for details).
</p>


<h3>Value</h3>

<p>The list returned is: </p>
<table role = "presentation">
<tr><td><code>loglik</code></td>
<td>
<p>log-likelihood of the model</p>
</td></tr>
<tr><td><code>best</code></td>
<td>
<p>vector of parameter estimates in the same order as specified in
<code>B</code> and detailed in section <code>details</code></p>
</td></tr>
<tr><td><code>V</code></td>
<td>
<p>if the model converged (conv=1 or 3), vector containing
the upper triangle matrix of variance-covariance estimates of <code>Best</code>
with exception for variance-covariance parameters of the random-effects for
which <code>V</code> contains the variance-covariance estimates of the Cholesky
transformed parameters displayed in <code>cholesky</code>.
If conv=2, <code>V</code> contains the second derivatives of the log-likelihood.</p>
</td></tr>
<tr><td><code>gconv</code></td>
<td>
<p>vector of
convergence criteria: 1. on the parameters, 2. on the likelihood, 3. on the
derivatives</p>
</td></tr> <tr><td><code>conv</code></td>
<td>
<p>status of convergence: =1 if the convergence
criteria were satisfied, =2 if the maximum number of iterations was reached,
=4 or 5 if a problem occured during optimisation</p>
</td></tr> <tr><td><code>call</code></td>
<td>
<p>the matched
call</p>
</td></tr> <tr><td><code>niter</code></td>
<td>
<p>number of Marquardt iterations</p>
</td></tr> <tr><td><code>pred</code></td>
<td>
<p>table of
individual predictions and residuals; it includes marginal predictions
(pred_m), marginal residuals (resid_m), subject-specific predictions
(pred_ss) and subject-specific residuals (resid_ss) averaged over classes,
the observation (obs) and finally the class-specific marginal and
subject-specific predictions (with the number of the latent class:
pred_m_1,pred_m_2,...,pred_ss_1,pred_ss_2,...). If <code>var.time</code>
is specified, the corresponding measurement time is also included.</p>
</td></tr>
<tr><td><code>pprob</code></td>
<td>
<p>table of
posterior classification and posterior individual class-membership
probabilities based on the longitudinal data and the time-to-event data</p>
</td></tr>
<tr><td><code>pprobY</code></td>
<td>
<p>table of posterior classification and posterior individual
class-membership probabilities based only on the longitudinal data</p>
</td></tr>
<tr><td><code>predRE</code></td>
<td>
<p>table containing individual predictions of the random-effects:
a column per random-effect, a line per subject</p>
</td></tr> <tr><td><code>cholesky</code></td>
<td>
<p>vector
containing the estimates of the Cholesky transformed parameters of the
variance-covariance matrix of the random-effects</p>
</td></tr> <tr><td><code>scoretest</code></td>
<td>
<p>Statistic
of the Score Test for the conditional independence assumption of the
longitudinal and survival data given the latent class structure. Under the
null hypothesis, the statistics is a Chi-square with p degrees of freedom
where p indicates the number of random-effects in the longitudinal mixed
model. See Jacqmin-Gadda and Proust-Lima (2009) for more details.</p>
</td></tr>
<tr><td><code>predSurv</code></td>
<td>
<p>table of predictions giving for the window of times to event
(called &quot;time&quot;), the predicted baseline risk function in each latent class
(called &quot;RiskFct&quot;) and the predicted cumulative baseline risk function in
each latent class (called &quot;CumRiskFct&quot;).</p>
</td></tr> <tr><td><code>hazard</code></td>
<td>
<p>internal information
about the hazard specification used in related functions</p>
</td></tr> <tr><td><code>data</code></td>
<td>
<p>the
original data set (if returndata is TRUE)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cecile Proust Lima, Amadou Diakite and Viviane Philipps
</p>
<p><a href="mailto:cecile.proust-lima@inserm.fr">cecile.proust-lima@inserm.fr</a>
</p>


<h3>References</h3>

<p>Proust-Lima C, Philipps V, Liquet B (2017). Estimation of Extended Mixed 
Models Using Latent Classes and Latent Processes: The R Package lcmm. 
Journal of Statistical Software, 78(2), 1-56. doi:10.18637/jss.v078.i02
</p>
<p>Lin, H., Turnbull, B. W., McCulloch, C. E. and Slate, E. H. (2002). Latent
class models for joint analysis of longitudinal biomarker and event process
data: application to longitudinal prostate-specific antigen readings and
prostate cancer. Journal of the American Statistical Association 97, 53-65.
</p>
<p>Proust-Lima, C. and Taylor, J. (2009). Development and validation of a
dynamic prognostic tool for prostate cancer recurrence using repeated
measures of post-treatment PSA: a joint modelling approach. Biostatistics
10, 535-49.
</p>
<p>Jacqmin-Gadda, H. and Proust-Lima, C. (2010). Score test for conditional
independence between longitudinal outcome and time-to-event given the
classes in the joint latent class model. Biometrics 66(1), 11-9
</p>
<p>Proust-Lima, Sene, Taylor and Jacqmin-Gadda (2014). Joint latent class
models of longitudinal and time-to-event data: a review. Statistical Methods
in Medical Research 23, 74-90.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+postprob">postprob</a></code>, <code><a href="#topic+plot.Jointlcmm">plot.Jointlcmm</a></code>,
<code><a href="#topic+plot.predict">plot.predict</a></code>, <code><a href="#topic+epoce">epoce</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
#### Example of a joint latent class model estimated for a varying number
# of latent classes: 
# The linear mixed model includes a subject- (ID) and class-specific 
# linear trend (intercept and Time in fixed, random and mixture components)
# and a common effect of X1 and its interaction with time over classes 
# (in fixed).
# The variance of the random intercept and slopes are assumed to be equal 
# over classes (nwg=F).
# The covariate X3 predicts the class membership (in classmb). 
# The baseline hazard function is modelled with cubic M-splines -3 
# nodes at the quantiles- (in hazard) and a proportional hazard over 
# classes is assumed (in hazardtype). Covariates X1 and X2 predict the 
# risk of event (in survival) with a common effect over classes for X1
# and a class-specific effect of X2.
# !CAUTION: for illustration, only default initial values where used but 
# other sets of initial values should be tried to ensure convergence
# towards the global maximum.


#### estimation with 1 latent class (ng=1): independent models for the 
# longitudinal outcome and the time of event
m1 &lt;- Jointlcmm(fixed= Ydep1~X1*Time,random=~Time,subject='ID',
survival = Surv(Tevent,Event)~ X1+X2 ,hazard="3-quant-splines",
hazardtype="PH",ng=1,data=data_lcmm)
summary(m1)
#Goodness-of-fit statistics for m1:
#    maximum log-likelihood: -3944.77 ; AIC: 7919.54  ;  BIC: 7975.09  

## End(Not run)

#### estimation with 2 latent classes (ng=2)
m2 &lt;- Jointlcmm(fixed= Ydep1~Time*X1,mixture=~Time,random=~Time,
classmb=~X3,subject='ID',survival = Surv(Tevent,Event)~X1+mixture(X2),
hazard="3-quant-splines",hazardtype="PH",ng=2,data=data_lcmm,
B=c(0.64,-0.62,0,0,0.52,0.81,0.41,0.78,0.1,0.77,-0.05,10.43,11.3,-2.6,
-0.52,1.41,-0.05,0.91,0.05,0.21,1.5))
summary(m2)
#Goodness-of-fit statistics for m2:
#       maximum log-likelihood: -3921.27; AIC: 7884.54; BIC: 7962.32  

## Not run: 
#### estimation with 3 latent classes (ng=3)
m3 &lt;- Jointlcmm(fixed= Ydep1~Time*X1,mixture=~Time,random=~Time,
classmb=~X3,subject='ID',survival = Surv(Tevent,Event)~ X1+mixture(X2),
hazard="3-quant-splines",hazardtype="PH",ng=3,data=data_lcmm,
B=c(0.77,0.4,-0.82,-0.27,0,0,0,0.3,0.62,2.62,5.31,-0.03,1.36,0.82,
-13.5,10.17,10.24,11.51,-2.62,-0.43,-0.61,1.47,-0.04,0.85,0.04,0.26,1.5))
summary(m3)
#Goodness-of-fit statistics for m3:
#       maximum log-likelihood: -3890.26 ; AIC: 7834.53;  BIC: 7934.53  

#### estimation with 4 latent classes (ng=4)
m4 &lt;- Jointlcmm(fixed= Ydep1~Time*X1,mixture=~Time,random=~Time,
classmb=~X3,subject='ID',survival = Surv(Tevent,Event)~ X1+mixture(X2),
hazard="3-quant-splines",hazardtype="PH",ng=4,data=data_lcmm,
B=c(0.54,-0.42,0.36,-0.94,-0.64,-0.28,0,0,0,0.34,0.59,2.6,2.56,5.26,
-0.1,1.27,1.34,0.7,-5.72,10.54,9.02,10.2,11.58,-2.47,-2.78,-0.28,-0.57,
1.48,-0.06,0.61,-0.07,0.31,1.5))
summary(m4)
#Goodness-of-fit statistics for m4:
#   maximum log-likelihood: -3886.93 ; AIC: 7839.86;  BIC: 7962.09  


##### The model with 3 latent classes is retained according to the BIC  
##### and the conditional independence assumption is not rejected at
##### the 5% level. 
# posterior classification
plot(m3,which="postprob")
# Class-specific predicted baseline risk &amp; survival functions in the 
# 3-class model retained (for the reference value of the covariates) 
plot(m3,which="baselinerisk",bty="l")
plot(m3,which="baselinerisk",ylim=c(0,5),bty="l")
plot(m3,which="survival",bty="l")
# class-specific predicted trajectories in the 3-class model retained 
# (with characteristics of subject ID=193)
data &lt;- data_lcmm[data_lcmm$ID==193,]
plot(predictY(m3,var.time="Time",newdata=data,bty="l"))
# predictive accuracy of the model evaluated with EPOCE
vect &lt;- 1:15
cvpl &lt;- epoce(m3,var.time="Time",pred.times=vect)
summary(cvpl)
plot(cvpl,bty="l",ylim=c(0,2))
############## end of example ##############

## End(Not run)

</code></pre>

<hr>
<h2 id='lcmm'>Estimation of mixed-effect models and latent class mixed-effect models for
different types of outcomes (continuous Gaussian, continuous non-Gaussian or
ordinal)</h2><span id='topic+lcmm'></span>

<h3>Description</h3>

<p>This function fits mixed models and latent class mixed models for different
types of outcomes. It handles continuous longitudinal outcomes (Gaussian or
non-Gaussian) as well as bounded quantitative, discrete and ordinal
longitudinal outcomes.  The different types of outcomes are taken into
account using parameterized nonlinear link functions between the observed
outcome and the underlying latent process of interest it measures.  At the
latent process level, the model estimates a standard linear mixed model or a
latent class linear mixed model when heterogeneity in the population is
investigated (in the same way as in function <code>hlme</code>). It should be
noted that the program also works when no random-effect is included.
Parameters of the nonlinear link function and of the latent process mixed
model are estimated simultaneously using a maximum likelihood method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lcmm(
  fixed,
  mixture,
  random,
  subject,
  classmb,
  ng = 1,
  idiag = FALSE,
  nwg = FALSE,
  link = "linear",
  intnodes = NULL,
  epsY = 0.5,
  cor = NULL,
  data,
  B,
  convB = 1e-04,
  convL = 1e-04,
  convG = 1e-04,
  maxiter = 100,
  nsim = 100,
  prior,
  pprior = NULL,
  range = NULL,
  subset = NULL,
  na.action = 1,
  posfix = NULL,
  partialH = FALSE,
  verbose = FALSE,
  returndata = FALSE,
  var.time = NULL,
  nproc = 1,
  clustertype = NULL,
  computeDiscrete = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lcmm_+3A_fixed">fixed</code></td>
<td>
<p>a two-sided linear formula object for specifying the
fixed-effects in the linear mixed model at the latent process level. The
response outcome is on the left of <code>~</code> and the covariates are separated
by <code>+</code> on the right of the <code>~</code>.  Fo identifiability purposes, the
intercept specified by default should not be removed by a <code>-1</code>.</p>
</td></tr>
<tr><td><code id="lcmm_+3A_mixture">mixture</code></td>
<td>
<p>a one-sided formula object for the class-specific fixed
effects in the latent process mixed model (to specify only for a number of
latent classes greater than 1).  Among the list of covariates included in
<code>fixed</code>, the covariates with class-specific regression parameters are
entered in <code>mixture</code> separated by <code>+</code>.  By default, an intercept
is included. If no intercept, <code>-1</code> should be the first term included.</p>
</td></tr>
<tr><td><code id="lcmm_+3A_random">random</code></td>
<td>
<p>an optional one-sided formula for the random-effects in the
latent process mixed model. Covariates with a random-effect are separated by
<code>+</code>.  By default, no random effect is included.</p>
</td></tr>
<tr><td><code id="lcmm_+3A_subject">subject</code></td>
<td>
<p>name of the covariate representing the grouping structure.</p>
</td></tr>
<tr><td><code id="lcmm_+3A_classmb">classmb</code></td>
<td>
<p>an optional one-sided formula describing the covariates in
the class-membership multinomial logistic model. Covariates included are
separated by <code>+</code>.  No intercept should be included in this formula.</p>
</td></tr>
<tr><td><code id="lcmm_+3A_ng">ng</code></td>
<td>
<p>number of latent classes considered. If <code>ng=1</code> no
<code>mixture</code> nor <code>classmb</code> should be specified. If <code>ng&gt;1</code>,
<code>mixture</code> is required.</p>
</td></tr>
<tr><td><code id="lcmm_+3A_idiag">idiag</code></td>
<td>
<p>optional logical for the variance-covariance structure of the
random-effects. If <code>FALSE</code>, a non structured matrix of
variance-covariance is considered (by default).  If <code>TRUE</code> a diagonal
matrix of variance-covariance is considered.</p>
</td></tr>
<tr><td><code id="lcmm_+3A_nwg">nwg</code></td>
<td>
<p>optional logical of class-specific variance-covariance of the
random-effects. If <code>FALSE</code> the variance-covariance matrix is common
over latent classes (by default). If <code>TRUE</code> a class-specific
proportional parameter multiplies the variance-covariance matrix in each
class (the proportional parameter in the last latent class equals 1 to
ensure identifiability).</p>
</td></tr>
<tr><td><code id="lcmm_+3A_link">link</code></td>
<td>
<p>optional family of link functions to estimate. By default,
&quot;linear&quot; option specifies a linear link function leading to a standard
linear mixed model (homogeneous or heterogeneous as estimated in
<code>hlme</code>).  Other possibilities include &quot;beta&quot; for estimating a link
function from the family of Beta cumulative distribution functions,
&quot;thresholds&quot; for using a threshold model to describe the correspondence
between each level of an ordinal outcome and the underlying latent process,
and &quot;Splines&quot; for approximating the link function by I-splines. For this
latter case, the number of nodes and the nodes location should be also
specified. The number of nodes is first entered followed by <code>-</code>, then
the location is specified with &quot;equi&quot;, &quot;quant&quot; or &quot;manual&quot; for respectively
equidistant nodes, nodes at quantiles of the marker distribution or interior
nodes entered manually in argument <code>intnodes</code>. It is followed by
<code>-</code> and finally &quot;splines&quot; is indicated. For example, &quot;7-equi-splines&quot;
means I-splines with 7 equidistant nodes, &quot;6-quant-splines&quot; means I-splines
with 6 nodes located at the quantiles of the marker distribution and
&quot;9-manual-splines&quot; means I-splines with 9 nodes, the vector of 7 interior
nodes being entered in the argument <code>intnodes</code>.</p>
</td></tr>
<tr><td><code id="lcmm_+3A_intnodes">intnodes</code></td>
<td>
<p>optional vector of interior nodes. This argument is only
required for a I-splines link function with nodes entered manually.</p>
</td></tr>
<tr><td><code id="lcmm_+3A_epsy">epsY</code></td>
<td>
<p>optional definite positive real used to rescale the marker in
(0,1) when the beta link function is used. By default, epsY=0.5.</p>
</td></tr>
<tr><td><code id="lcmm_+3A_cor">cor</code></td>
<td>
<p>optional brownian motion or autoregressive process modeling the
correlation between the observations.  &quot;BM&quot; or &quot;AR&quot; should be specified,
followed by the time variable between brackets. By default, no correlation
is added.</p>
</td></tr>
<tr><td><code id="lcmm_+3A_data">data</code></td>
<td>
<p>optional data frame containing the variables named in
<code>fixed</code>, <code>mixture</code>, <code>random</code>, <code>classmb</code> and
<code>subject</code>.</p>
</td></tr>
<tr><td><code id="lcmm_+3A_b">B</code></td>
<td>
<p>optional specification for the initial values for the parameters.
Three options are allowed: (1) a vector of initial values is entered (the
order in which the parameters are included is detailed in <code>details</code>
section).  (2) nothing is specified. A preliminary analysis involving the
estimation of a standard linear mixed model is performed to choose initial
values.  (3) when ng&gt;1, a lcmm object is entered. It should correspond to
the exact same structure of model but with ng=1. The program will
automatically generate initial values from this model. This specification
avoids the preliminary analysis indicated in (2). Note that due to possible
local maxima, the <code>B</code> vector should be specified and several different
starting points should be tried.</p>
</td></tr>
<tr><td><code id="lcmm_+3A_convb">convB</code></td>
<td>
<p>optional threshold for the convergence criterion based on the
parameter stability. By default, convB=0.0001.</p>
</td></tr>
<tr><td><code id="lcmm_+3A_convl">convL</code></td>
<td>
<p>optional threshold for the convergence criterion based on the
log-likelihood stability. By default, convL=0.0001.</p>
</td></tr>
<tr><td><code id="lcmm_+3A_convg">convG</code></td>
<td>
<p>optional threshold for the convergence criterion based on the
derivatives. By default, convG=0.0001.</p>
</td></tr>
<tr><td><code id="lcmm_+3A_maxiter">maxiter</code></td>
<td>
<p>optional maximum number of iterations for the Marquardt
iterative algorithm. By default, maxiter=100.</p>
</td></tr>
<tr><td><code id="lcmm_+3A_nsim">nsim</code></td>
<td>
<p>number of points used to plot the estimated link function. By
default, nsim=100.</p>
</td></tr>
<tr><td><code id="lcmm_+3A_prior">prior</code></td>
<td>
<p>name of the covariate containing the prior on the latent class
membership. The covariate should be an integer with values in 0,1,...,ng.
When there is no prior, the value should be 0. When there is a prior for the
subject, the value should be the number of the latent class (in 1,...,ng).</p>
</td></tr>
<tr><td><code id="lcmm_+3A_pprior">pprior</code></td>
<td>
<p>optional vector specifying the names of the covariates containing the
prior probabilities to belong to each latent class. These probabilities should be
between 0 and 1 and should sum up to 1 for each subject.</p>
</td></tr>
<tr><td><code id="lcmm_+3A_range">range</code></td>
<td>
<p>optional vector indicating the range of the outcome (that is
the minimum and maximum). By default, the range is defined according to the
minimum and maximum observed values of the outcome. The option should be
used only for Beta and Splines transformations.</p>
</td></tr>
<tr><td><code id="lcmm_+3A_subset">subset</code></td>
<td>
<p>optional vector giving the subset of observations in
<code>data</code> to use. By default, all lines.</p>
</td></tr>
<tr><td><code id="lcmm_+3A_na.action">na.action</code></td>
<td>
<p>Integer indicating how NAs are managed. The default is 1
for 'na.omit'. The alternative is 2 for 'na.fail'. Other options such as
'na.pass' or 'na.exclude' are not implemented in the current version.</p>
</td></tr>
<tr><td><code id="lcmm_+3A_posfix">posfix</code></td>
<td>
<p>Optional vector specifying the indices in vector B of the
parameters that should not be estimated. Default to NULL, all parameters are
estimated.</p>
</td></tr>
<tr><td><code id="lcmm_+3A_partialh">partialH</code></td>
<td>
<p>optional logical for Splines link functions only.
Indicates whether the parameters of the link functions can be dropped from
the Hessian matrix to define convergence criteria.</p>
</td></tr>
<tr><td><code id="lcmm_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating if information about computation should be
reported. Default to TRUE.</p>
</td></tr>
<tr><td><code id="lcmm_+3A_returndata">returndata</code></td>
<td>
<p>logical indicating if data used for computation should be
returned. Default to FALSE, data are not returned.</p>
</td></tr>
<tr><td><code id="lcmm_+3A_var.time">var.time</code></td>
<td>
<p>optional character indicating the name of the time variable.</p>
</td></tr>
<tr><td><code id="lcmm_+3A_nproc">nproc</code></td>
<td>
<p>the number cores for parallel computation.
Default to 1 (sequential mode).</p>
</td></tr>
<tr><td><code id="lcmm_+3A_clustertype">clustertype</code></td>
<td>
<p>optional character indicating the type of cluster for parallel computation.</p>
</td></tr>
<tr><td><code id="lcmm_+3A_computediscrete">computeDiscrete</code></td>
<td>
<p>optional logical indicating if a dscrete likelihood and UACV
should be computed. By default, if the outcome only consists of integers computeDiscrete=TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A. THE PARAMETERIZED LINK FUNCTIONS
</p>
<p><code>lcmm</code> function estimates mixed models and latent class mixed models
for different types of outcomes by assuming a parameterized link function
for linking the outcome Y(t) with the underlying latent process L(t) it
measures. To fix the latent process dimension, we chose to constrain the
(first) intercept of the latent class mixed model at the latent process
level at 0 and the standard error of the gaussian error of measurement at 1.
These two parameters are replaced by additional parameters in the
parameterized link function :
</p>
<p>1. With the &quot;linear&quot; link function, 2 parameters are required that
correspond directly to the intercept and the standard error: (Y - b1)/b2 =
L(t).
</p>
<p>2. With the &quot;beta&quot; link function, 4 parameters are required for the
following transformation: [ h(Y(t)',b1,b2) - b3]/b4 where h is the Beta CDF
with canonical parameters c1 and c2 that can be derived from b1 and b2 as
c1=exp(b1)/[exp(b2)*(1+exp(b1))] and c2=1/[exp(b2)*(1+exp(b1))], and Y(t)'
is the rescaled outcome i.e. Y(t)'= [ Y(t) - min(Y(t)) + epsY ] / [
max(Y(t)) - min(Y(t)) +2*epsY ].
</p>
<p>3. With the &quot;splines&quot; link function, n+2 parameters are required for the
following transformation b_1 + b_2*I_1(Y(t)) + ... + b_(n+2) I_(n+1)(Y(t)),
where I_1,...,I_(n+1) is the basis of quadratic I-splines. To constraint the
parameters to be positive, except for b_1, the program estimates b_k^* (for
k=2,...,n+2) so that b_k=(b_k^*)^2.
</p>
<p>4. With the &quot;thresholds&quot; link function for an ordinal outcome in levels
0,...,C. A maximumn of C parameters are required for the following
transformation: Y(t)=c &lt;=&gt; b_c &lt; L(t) &lt;= b_(c+1) with b_0 = - infinity and
b_(C+1)=+infinity. The number of parameters is reduced if some levels do not
have any information. For example, if a level c is not observed in the
dataset, the corresponding threshold b_(c+1) is constrained to be the same
as the previous one b_c. The number of parameters in the link function is
reduced by 1.
</p>
<p>To constraint the parameters to be increasing, except for the first
parameter b_1, the program estimates b_k^* (for k=2,...C) so that
b_k=b_(k-1)+(b_k^*)^2.
</p>
<p>Details of these parameterized link functions can be found in the referred
papers.
</p>
<p>B. THE VECTOR OF PARAMETERS B
</p>
<p>The parameters in the vector of initial values <code>B</code> or in the vector of
maximum likelihood estimates <code>best</code> are included in the following
order: (1) ng-1 parameters are required for intercepts in the latent class
membership model, and if covariates are included in <code>classmb</code>, ng-1
paramaters should be entered for each one; (2) for all covariates in
<code>fixed</code>, one parameter is required if the covariate is not in
<code>mixture</code>, ng paramaters are required if the covariate is also in
<code>mixture</code>; When ng=1, the intercept is not estimated and no parameter
should be specified in <code>B</code>. When ng&gt;1, the first intercept is not
estimated and only ng-1 parameters should be specified in <code>B</code>; (3) the
variance of each random-effect specified in <code>random</code> (including the
intercept) if <code>idiag=TRUE</code> and the inferior triangular
variance-covariance matrix of all the random-effects if <code>idiag=FALSE</code>;
(4) only if <code>nwg=TRUE</code>, ng-1 parameters for class-specific proportional
coefficients for the variance covariance matrix of the random-effects; (5)
In contrast with hlme, due to identifiability purposes, the standard error
of the Gaussian error is not estimated (fixed at 1), and should not be
specified in <code>B</code>; (6) The parameters of the link function: 2 for
&quot;linear&quot;, 4 for &quot;beta&quot;, n+2 for &quot;splines&quot; with n nodes and the number of
levels minus one for &quot;thresholds&quot;.
</p>
<p>C. CAUTIONS REGARDING THE USE OF THE PROGRAM
</p>
<p>Some caution should be made when using the program.  convergence criteria
are very strict as they are based on derivatives of the log-likelihood in
addition to the parameter and log-likelihood stability.  In some cases, the
program may not converge and reach the maximum number of iterations fixed at
100.  In this case, the user should check that parameter estimates at the
last iteration are not on the boundaries of the parameter space.  If the
parameters are on the boundaries of the parameter space, the identifiability
of the model is critical. This may happen especially with splines parameters
that may be too close to 0 (lower boundary) or classmb parameters that are
too high or low (perfect classification). When identifiability of some
parameters is suspected, the program can be run again from the former
estimates by fixing the suspected parameters to their value with option
posfix. This usually solves the problem. An alternative is to remove the
parameters of the Beta of Splines link function from the inverse of the
Hessian with option partialH.  If not, the program should be run again with
other initial values, with a higher maximum number of iterations or less
strict convergence tolerances.
</p>
<p>Specifically when investigating heterogeneity (that is with ng&gt;1): (1) As
the log-likelihood of a latent class model can have multiple maxima, a
careful choice of the initial values is crucial for ensuring convergence
toward the global maximum.  The program can be run without entering the
vector of initial values (see point 2).  However, we recommend to
systematically enter initial values in <code>B</code> and try different sets of
initial values.  (2) The automatic choice of initial values we provide
requires the estimation of a preliminary linear mixed model. The user should
be aware that first, this preliminary analysis can take time for large
datatsets and second, that the generated initial values can be very not
likely and even may converge slowly to a local maximum.  This is the reason
why several alternatives exist. The vector of initial values can be directly
specified in <code>B</code> the initial values can be generated (automatically or
randomly) from a model with <code>ng=</code>. Finally, function <code>gridsearch</code>
performs an automatic grid search.
</p>
<p>D. NUMERICAL INTEGRATION WITH THE THRESHOLD LINK FUNCTION
</p>
<p>With exception for the threshold link function, maximum likelihood
estimation implemented in lcmm does not require any numerical integration
over the random-effects so that the estimation procedure is relatively fast.
See Proust et al. (2006) for more details on the estimation procedure.
</p>
<p>However, with the threshold link function and when at least one
random-effect is specified, a numerical integration over the random-effects
distribution is required in each computation of the individual contribution
to the likelihood which complicates greatly the estimation procedure. For
the moment, we do not allow any option regarding the numerical integration
technics used.  1. When a single random-effect is specified, we use a
standard non-adaptive Gaussian quadrature with 30 points. 2. When at least
two random-effects are specified, we use a multivariate non-adaptive
Gaussian quadrature implemented by Genz (1996) in HRMSYM Fortran subroutine.
</p>
<p>Further developments should allow for adaptive technics and more options
regarding the numerical integration technic.
</p>
<p>E. POSTERIOR DISCRETE LIKELIHOOD
</p>
<p>Models involving nonlinear continuous link functions assume the continuous
data while the model with a threshold model assumes discrete data. As a
consequence, comparing likelihoods or criteria based on the likelihood (as
AIC) for these models is not possible as the former are based on a Lebesgue
measure and the latter on a counting measure. To make the comparison
possible, we compute the posterior discrete likelihood for all the models
with a nonlinear continuous link function. This posterior likelihood
considers the data as discrete; it is computed at the MLE (maximum
likelihood estimates) using the counting measure so that models with
threshold or continuous link functions become comparable. Further details
can be found in Proust-Lima, Amieva, Jacqmin-Gadda (2012).
</p>
<p>In addition to the Akaike information criterion based on the discrete
posterior likelihood, we also compute a universal approximate
cross-validation criterion to compare models based on a different measure.
See Commenges, Proust-Lima, Samieri, Liquet (2015) for further details.
</p>


<h3>Value</h3>

<p>The list returned is: </p>
<table role = "presentation">
<tr><td><code>ns</code></td>
<td>
<p>number of grouping units in the
dataset</p>
</td></tr> <tr><td><code>ng</code></td>
<td>
<p>number of latent classes</p>
</td></tr> <tr><td><code>loglik</code></td>
<td>
<p>log-likelihood of
the model</p>
</td></tr> <tr><td><code>best</code></td>
<td>
<p>vector of parameter estimates in the same order as
specified in <code>B</code> and detailed in section <code>details</code></p>
</td></tr> 
<tr><td><code>V</code></td>
<td>
<p>if the model converged (conv=1 or 3), vector containing the upper triangle
matrix of variance-covariance estimates of <code>Best</code> with exception for
variance-covariance parameters of the random-effects for which <code>V</code> contains the
variance-covariance estimates of the Cholesky transformed parameters displayed in
<code>cholesky</code>.  If conv=2, <code>V</code> contains the second derivatives of the
log-likelihood.</p>
</td></tr><tr><td><code>gconv</code></td>
<td>
<p>vector of convergence criteria: 1. on the
parameters, 2. on the likelihood, 3. on the derivatives</p>
</td></tr> <tr><td><code>conv</code></td>
<td>
<p>status
of convergence: =1 if the convergence criteria were satisfied, =2 if the
maximum number of iterations was reached, =4 or 5 if a problem occured
during optimisation</p>
</td></tr> <tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr> <tr><td><code>niter</code></td>
<td>
<p>number of
Marquardt iterations</p>
</td></tr> <tr><td><code>dataset</code></td>
<td>
<p>dataset</p>
</td></tr> <tr><td><code>N</code></td>
<td>
<p>internal information
used in related functions</p>
</td></tr> <tr><td><code>idiag</code></td>
<td>
<p>internal information used in related
functions</p>
</td></tr> <tr><td><code>pred</code></td>
<td>
<p>table of individual predictions and residuals in the
underlying latent process scale; it includes marginal predictions (pred_m),
marginal residuals (resid_m), subject-specific predictions (pred_ss) and
subject-specific residuals (resid_ss) averaged over classes, the transformed
observations in the latent process scale (obs) and finally the
class-specific marginal and subject-specific predictions (with the number of
the latent class: pred_m_1,pred_m_2,...,pred_ss_1,pred_ss_2,...). If <code>var.time</code>
is specified, the corresponding measurement time is also included. This
output is not available yet when specifying a thresholds transformation.</p>
</td></tr>
<tr><td><code>pprob</code></td>
<td>
<p>table of posterior classification and posterior individual
class-membership probabilities</p>
</td></tr> <tr><td><code>Xnames</code></td>
<td>
<p>list of covariates included in
the model</p>
</td></tr> <tr><td><code>predRE</code></td>
<td>
<p>table containing individual predictions of the
random-effects : a column per random-effect, a line per subject. This output
is not available yet when specifying a thresholds transformation.</p>
</td></tr>
<tr><td><code>cholesky</code></td>
<td>
<p>vector containing the estimates of the Cholesky transformed
parameters of the variance-covariance matrix of the random-effects</p>
</td></tr>
<tr><td><code>estimlink</code></td>
<td>
<p>table containing the simulated values of the marker and
corresponding estimated link function</p>
</td></tr> <tr><td><code>epsY</code></td>
<td>
<p>definite positive real
used to rescale the marker in (0,1) when the beta link function is used. By
default, epsY=0.5.</p>
</td></tr> <tr><td><code>linktype</code></td>
<td>
<p>indicator of link function type: 0 for
linear, 1 for beta, 2 for splines and 3 for thresholds</p>
</td></tr>
<tr><td><code>linknodes</code></td>
<td>
<p>vector of nodes useful only for the 'splines' link
function</p>
</td></tr><tr><td><code>data</code></td>
<td>
<p>the original data set (if returndata is TRUE)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cecile Proust-Lima, Amadou Diakite, Benoit Liquet and Viviane
Philipps
</p>
<p><a href="mailto:cecile.proust-lima@inserm.fr">cecile.proust-lima@inserm.fr</a>
</p>


<h3>References</h3>

<p>Proust-Lima C, Philipps V, Liquet B (2017). Estimation of Extended Mixed 
Models Using Latent Classes and Latent Processes: The R Package lcmm. 
Journal of Statistical Software, 78(2), 1-56. doi:10.18637/jss.v078.i02
</p>
<p>Genz and Keister (1996). Fully symmetric interpolatory rules for multiple
integrals over infinite regions with gaussian weight. Journal of
Computational and Applied Mathematics 71: 299-309.
</p>
<p>Proust and Jacqmin-Gadda (2005). Estimation of linear mixed models with a
mixture of distribution for the random-effects. Comput Methods Programs
Biomed 78: 165-73.
</p>
<p>Proust, Jacqmin-Gadda, Taylor, Ganiayre, and Commenges (2006). A nonlinear
model with latent process for cognitive evolution using multivariate
longitudinal data. Biometrics 62: 1014-24.
</p>
<p>Proust-Lima, Dartigues and Jacqmin-Gadda (2011). Misuse of the linear mixed
model when evaluating risk factors of cognitive decline. Amer J Epidemiol
174(9): 1077-88.
</p>
<p>Proust-Lima, Amieva and Jacqmin-Gadda (2013). Analysis of multivariate mixed
longitudinal data : a flexible latent process approach, British Journal of
Mathematical and Statistical Psychology 66(3): 470-87.
</p>
<p>Commenges, Proust-Lima, Samieri, Liquet (2015). A universal approximate
cross-validation criterion for regular risk functions. Int J Biostat. 2015
May;11(1):51-67
</p>


<h3>See Also</h3>

<p><code><a href="#topic+postprob">postprob</a></code>, <code><a href="#topic+plot.lcmm">plot.lcmm</a></code>, <code><a href="#topic+plot.predict">plot.predict</a></code>,
<code><a href="#topic+hlme">hlme</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
#### Estimation of homogeneous mixed models with different assumed link
#### functions, a quadratic mean trajectory for the latent process and 
#### correlated random intercept and slope (the random quadratic slope 
#### was removed as it did not improve the fit of the data).
#### -- comparison of linear, Beta and 3 different splines link functions --
# linear link function
m10&lt;-lcmm(Ydep2~Time+I(Time^2),random=~Time,subject='ID',ng=1,
data=data_lcmm,link="linear")
summary(m10)
# Beta link function
m11&lt;-lcmm(Ydep2~Time+I(Time^2),random=~Time,subject='ID',ng=1,
data=data_lcmm,link="beta")
summary(m11)
plot(m11,which="linkfunction",bty="l")
# I-splines with 3 equidistant nodes
m12&lt;-lcmm(Ydep2~Time+I(Time^2),random=~Time,subject='ID',ng=1,
data=data_lcmm,link="3-equi-splines")
summary(m12)
# I-splines with 5 nodes at quantiles
m13&lt;-lcmm(Ydep2~Time+I(Time^2),random=~Time,subject='ID',ng=1,
data=data_lcmm,link="5-quant-splines")
summary(m13)
# I-splines with 5 nodes, and interior nodes entered manually
m14&lt;-lcmm(Ydep2~Time+I(Time^2),random=~Time,subject='ID',ng=1,
data=data_lcmm,link="5-manual-splines",intnodes=c(10,20,25))
summary(m14)
plot(m14,which="linkfunction",bty="l")


# Thresholds
# Especially for the threshold link function, we recommend to estimate 
# models with increasing complexity and use estimates of previous ones 
# to specify plausible initial values (we remind that estimation of
# models with threshold link function involves a computationally demanding 
# numerical integration -here of size 3)
m15&lt;-lcmm(Ydep2~Time+I(Time^2),random=~Time,subject='ID',ng=1
,data=data_lcmm,link="thresholds",maxiter=100,
B=c(-0.8379, -0.1103,  0.3832,  0.3788 , 0.4524, -7.3180,  0.5917,  0.7364,
 0.6530, 0.4038,  0.4290,  0.6099,  0.6014 , 0.5354 , 0.5029 , 0.5463,
 0.5310 , 0.5352, 0.6498,  0.6653,  0.5851,  0.6525,  0.6701 , 0.6670 ,
 0.6767 , 0.7394 , 0.7426, 0.7153,  0.7702,  0.6421))
summary(m15)
plot(m15,which="linkfunction",bty="l")

#### Plot of estimated different link functions:
#### (applicable for models that only differ in the "link function" used. 
####  Otherwise, the latent process scale is different and a rescaling
####  is necessary)
plot(m10,which="linkfunction",col=1,xlab="latent process",ylab="marker",
bty="l",xlim=c(-10,5),legend=NULL)
plot(m11,which="linkfunction",add=TRUE,col=2,legend=NULL)
plot(m12,which="linkfunction",add=TRUE,col=3,legend=NULL)
plot(m13,which="linkfunction",add=TRUE,col=4,legend=NULL)
plot(m14,which="linkfunction",add=TRUE,col=5,legend=NULL)
plot(m15,which="linkfunction",add=TRUE,col=6,legend=NULL)
legend(x="bottomright",legend=c("linear","beta","spl_3e","spl_5q","spl_5m","thresholds"),
col=1:6,lty=1,inset=.02,box.lty=0)

#### Estimation of 2-latent class mixed models with different assumed link 
#### functions with individual and class specific linear trend
#### for illustration, only default initial values where used but other
#### sets of initial values should also be tried to ensure convergence 
#### towards the golbal maximum
# Linear link function
m20&lt;-lcmm(Ydep2~Time,random=~Time,subject='ID',mixture=~Time,ng=2,
idiag=TRUE,data=data_lcmm,link="linear",B=c(-0.98,0.79,-2.09,
-0.81,0.19,0.55,24.49,2.24))
summary(m20)
postprob(m20)
# Beta link function
m21&lt;-lcmm(Ydep2~Time,random=~Time,subject='ID',mixture=~Time,ng=2,
idiag=TRUE,data=data_lcmm,link="beta",B=c(-0.1,-0.56,-0.4,-1.77,
0.53,0.14,0.6,-0.83,0.73,0.09))
summary(m21)
postprob(m21)
# I-splines link function (and 5 nodes at quantiles)
m22&lt;-lcmm(Ydep2~Time,random=~Time,subject='ID',mixture=~Time,ng=2,
idiag=TRUE,data=data_lcmm,link="5-quant-splines",B=c(0.12,0.63,
-1.76,-0.39,0.51,0.13,-7.37,1.05,1.28,1.96,1.3,0.93,1.05))
summary(m22)
postprob(m22)

data &lt;- data_lcmm[data_lcmm$ID==193,]
plot(predictL(m22,var.time="Time",newdata=data,bty="l")


## End(Not run)    

</code></pre>

<hr>
<h2 id='loglik'>Wrapper to the Fortran subroutines computing the log-likelihood</h2><span id='topic+loglik'></span><span id='topic+loglikhlme'></span><span id='topic+logliklcmm'></span><span id='topic+loglikmultlcmm'></span><span id='topic+loglikJointlcmm'></span><span id='topic+loglikmpjlcmm'></span>

<h3>Description</h3>

<p>Log-likelihood of hlme, lcmm, multlcmm, Jointlcmm and mpjlcmm models.
The argument's specification is not straightforward, so these functions are usually not directly used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglikhlme(
  b,
  Y0,
  X0,
  prior0,
  pprior0,
  idprob0,
  idea0,
  idg0,
  idcor0,
  ns0,
  ng0,
  nv0,
  nobs0,
  nea0,
  nmes0,
  idiag0,
  nwg0,
  ncor0,
  npm0,
  fix0,
  nfix0,
  bfix0
)

logliklcmm(
  b,
  Y0,
  X0,
  prior0,
  pprior0,
  idprob0,
  idea0,
  idg0,
  idcor0,
  ns0,
  ng0,
  nv0,
  nobs0,
  nea0,
  nmes0,
  idiag0,
  nwg0,
  ncor0,
  npm0,
  epsY0,
  idlink0,
  nbzitr0,
  zitr0,
  minY0,
  maxY0,
  ide0,
  fix0,
  nfix0,
  bfix0
)

loglikmultlcmm(
  b,
  Y0,
  X0,
  prior0,
  pprior0,
  idprob0,
  idea0,
  idg0,
  idcor0,
  idcontr0,
  ny0,
  ns0,
  ng0,
  nv0,
  nobs0,
  nea0,
  nmes0,
  idiag0,
  nwg0,
  ncor0,
  nalea0,
  npm0,
  epsY0,
  idlink0,
  nbzitr0,
  zitr0,
  uniqueY0,
  indiceY0,
  nvalSPLORD0,
  fix0,
  nfix0,
  bfix0,
  methInteg0,
  nMC0,
  dimMC0,
  seqMC0,
  chol0
)

loglikJointlcmm(
  b,
  Y0,
  X0,
  prior0,
  pprior0,
  tentr0,
  tevt0,
  devt0,
  ind_survint0,
  idprob0,
  idea0,
  idg0,
  idcor0,
  idcom0,
  idspecif0,
  idtdv0,
  idlink0,
  epsY0,
  nbzitr0,
  zitr0,
  uniqueY0,
  nvalSPL0,
  indiceY0,
  typrisq0,
  risqcom0,
  nz0,
  zi0,
  ns0,
  ng0,
  nv0,
  nobs0,
  nmes0,
  nbevt0,
  nea0,
  nwg0,
  ncor0,
  idiag0,
  idtrunc0,
  logspecif0,
  npm0,
  fix0,
  nfix0,
  bfix0
)

loglikmpjlcmm(
  b,
  K0,
  ny0,
  nbevt0,
  ng0,
  ns0,
  Y0,
  nobs0,
  X0,
  nv0,
  Xns0,
  nv20,
  prior0,
  Tentr0,
  Tevt0,
  Devt0,
  ind_survint0,
  idnv0,
  idnv20,
  idspecif0,
  idlink0,
  epsY0,
  nbzitr0,
  zitr0,
  uniqueY0,
  nvalSPL0,
  indiceY0,
  typrisq0,
  risqcom0,
  nz0,
  zi0,
  nmes0,
  nea0,
  nw0,
  ncor0,
  nalea0,
  idiag0,
  idtrunc0,
  logspecif0,
  npm0,
  fix0,
  contrainte0,
  nfix0,
  bfix0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loglik_+3A_b">b</code></td>
<td>
<p>the vector of estimated parameters (length npm0)</p>
</td></tr>
<tr><td><code id="loglik_+3A_y0">Y0</code></td>
<td>
<p>the observed values of the outcome(s) (length nobs0)</p>
</td></tr>
<tr><td><code id="loglik_+3A_x0">X0</code></td>
<td>
<p>the observed values of all covariates included in the model (dim nob0 * nv0)</p>
</td></tr>
<tr><td><code id="loglik_+3A_prior0">prior0</code></td>
<td>
<p>the prior latent class (length ns0)</p>
</td></tr>
<tr><td><code id="loglik_+3A_pprior0">pprior0</code></td>
<td>
<p>the prior probabilty of each latent class (dim ns0 * ng0)</p>
</td></tr>
<tr><td><code id="loglik_+3A_idprob0">idprob0</code></td>
<td>
<p>indicator of presence in the class membership submodel (length nv0)</p>
</td></tr>
<tr><td><code id="loglik_+3A_idea0">idea0</code></td>
<td>
<p>indicator of presence in the random part of the longitudinal submodel (length nv0)</p>
</td></tr>
<tr><td><code id="loglik_+3A_idg0">idg0</code></td>
<td>
<p>indicator of presence in the fixed part of the longitudinal submodel (length nv0)</p>
</td></tr>
<tr><td><code id="loglik_+3A_idcor0">idcor0</code></td>
<td>
<p>indicator of presence in the correlation part of the longitudinal submodel (length nv0)</p>
</td></tr>
<tr><td><code id="loglik_+3A_ns0">ns0</code></td>
<td>
<p>number of subjects</p>
</td></tr>
<tr><td><code id="loglik_+3A_ng0">ng0</code></td>
<td>
<p>number of latent classes</p>
</td></tr>
<tr><td><code id="loglik_+3A_nv0">nv0</code></td>
<td>
<p>number of covariates</p>
</td></tr>
<tr><td><code id="loglik_+3A_nobs0">nobs0</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code id="loglik_+3A_nea0">nea0</code></td>
<td>
<p>number of random effects</p>
</td></tr>
<tr><td><code id="loglik_+3A_nmes0">nmes0</code></td>
<td>
<p>number of mesures for each subject (length ns0 or dom ns0*ny0)</p>
</td></tr>
<tr><td><code id="loglik_+3A_idiag0">idiag0</code></td>
<td>
<p>indicator of diagonal variance matrix of the random effects</p>
</td></tr>
<tr><td><code id="loglik_+3A_nwg0">nwg0</code></td>
<td>
<p>number of parameters for proportional random effects over latent classes</p>
</td></tr>
<tr><td><code id="loglik_+3A_ncor0">ncor0</code></td>
<td>
<p>number of parameters for the correlation</p>
</td></tr>
<tr><td><code id="loglik_+3A_npm0">npm0</code></td>
<td>
<p>total number of parameters</p>
</td></tr>
<tr><td><code id="loglik_+3A_fix0">fix0</code></td>
<td>
<p>indicator of non estimated parameter (length npm0+nfix0)</p>
</td></tr>
<tr><td><code id="loglik_+3A_nfix0">nfix0</code></td>
<td>
<p>number of non estimated parameters</p>
</td></tr>
<tr><td><code id="loglik_+3A_bfix0">bfix0</code></td>
<td>
<p>vector of non estimated parameters</p>
</td></tr>
<tr><td><code id="loglik_+3A_epsy0">epsY0</code></td>
<td>
<p>epsY values for Beta transformations</p>
</td></tr>
<tr><td><code id="loglik_+3A_idlink0">idlink0</code></td>
<td>
<p>type of transformation</p>
</td></tr>
<tr><td><code id="loglik_+3A_nbzitr0">nbzitr0</code></td>
<td>
<p>number of nodes for the transformations</p>
</td></tr>
<tr><td><code id="loglik_+3A_zitr0">zitr0</code></td>
<td>
<p>nodes for the transformations</p>
</td></tr>
<tr><td><code id="loglik_+3A_miny0">minY0</code></td>
<td>
<p>minimum value for the longitudinal outcome</p>
</td></tr>
<tr><td><code id="loglik_+3A_maxy0">maxY0</code></td>
<td>
<p>maximum value for the longitudinal outcome</p>
</td></tr>
<tr><td><code id="loglik_+3A_ide0">ide0</code></td>
<td>
<p>indicator of observed values for ordinal outcomes</p>
</td></tr>
<tr><td><code id="loglik_+3A_idcontr0">idcontr0</code></td>
<td>
<p>indicator of presence as contrast in the fixed part of the longitudinal submodel (length nv0)</p>
</td></tr>
<tr><td><code id="loglik_+3A_ny0">ny0</code></td>
<td>
<p>number of longitudinal outcomes</p>
</td></tr>
<tr><td><code id="loglik_+3A_nalea0">nalea0</code></td>
<td>
<p>number of parameters f the outcome specific random effect</p>
</td></tr>
<tr><td><code id="loglik_+3A_uniquey0">uniqueY0</code></td>
<td>
<p>unique values of the longitudinal outcomes</p>
</td></tr>
<tr><td><code id="loglik_+3A_indicey0">indiceY0</code></td>
<td>
<p>correspondance between Y0 and uniqueY0</p>
</td></tr>
<tr><td><code id="loglik_+3A_nvalsplord0">nvalSPLORD0</code></td>
<td>
<p>number of unique values for outcomes modeled with splines transformations or as ordinal outcome</p>
</td></tr>
<tr><td><code id="loglik_+3A_methinteg0">methInteg0</code></td>
<td>
<p>type of integration</p>
</td></tr>
<tr><td><code id="loglik_+3A_nmc0">nMC0</code></td>
<td>
<p>number of nodes for Monte Carlo integration</p>
</td></tr>
<tr><td><code id="loglik_+3A_dimmc0">dimMC0</code></td>
<td>
<p>dimension of the integration</p>
</td></tr>
<tr><td><code id="loglik_+3A_seqmc0">seqMC0</code></td>
<td>
<p>sequence of integration nodes</p>
</td></tr>
<tr><td><code id="loglik_+3A_chol0">chol0</code></td>
<td>
<p>indicator of Cholesky parameterization</p>
</td></tr>
<tr><td><code id="loglik_+3A_tentr0">tentr0</code></td>
<td>
<p>entry time for the survival submodel</p>
</td></tr>
<tr><td><code id="loglik_+3A_tevt0">tevt0</code></td>
<td>
<p>event time for the survival submodel</p>
</td></tr>
<tr><td><code id="loglik_+3A_devt0">devt0</code></td>
<td>
<p>indicator of event for the survival submodel</p>
</td></tr>
<tr><td><code id="loglik_+3A_ind_survint0">ind_survint0</code></td>
<td>
<p>indicator of risk change</p>
</td></tr>
<tr><td><code id="loglik_+3A_idcom0">idcom0</code></td>
<td>
<p>indicator of presence in the survival submodel with common effect</p>
</td></tr>
<tr><td><code id="loglik_+3A_idspecif0">idspecif0</code></td>
<td>
<p>indicator of presence in the survival submodel with cause-specific or class specific effect</p>
</td></tr>
<tr><td><code id="loglik_+3A_idtdv0">idtdv0</code></td>
<td>
<p>indicator of 'TimeDepVar' covariate</p>
</td></tr>
<tr><td><code id="loglik_+3A_nvalspl0">nvalSPL0</code></td>
<td>
<p>number of unique values for outcomes modeled with splines transformations</p>
</td></tr>
<tr><td><code id="loglik_+3A_typrisq0">typrisq0</code></td>
<td>
<p>type of baseline risk</p>
</td></tr>
<tr><td><code id="loglik_+3A_risqcom0">risqcom0</code></td>
<td>
<p>specification of baseline risk across latent classes</p>
</td></tr>
<tr><td><code id="loglik_+3A_nz0">nz0</code></td>
<td>
<p>number of nodes for the baseline</p>
</td></tr>
<tr><td><code id="loglik_+3A_zi0">zi0</code></td>
<td>
<p>nodes for the baseline</p>
</td></tr>
<tr><td><code id="loglik_+3A_nbevt0">nbevt0</code></td>
<td>
<p>number of events</p>
</td></tr>
<tr><td><code id="loglik_+3A_idtrunc0">idtrunc0</code></td>
<td>
<p>indicator of left truncation</p>
</td></tr>
<tr><td><code id="loglik_+3A_logspecif0">logspecif0</code></td>
<td>
<p>indicator of logarithm parameterization</p>
</td></tr>
<tr><td><code id="loglik_+3A_k0">K0</code></td>
<td>
<p>number of latent processes</p>
</td></tr>
<tr><td><code id="loglik_+3A_xns0">Xns0</code></td>
<td>
<p>the observed values of the covariates included in the survival submodel (dim ns0*nv20)</p>
</td></tr>
<tr><td><code id="loglik_+3A_nv20">nv20</code></td>
<td>
<p>number of covariates in Xns0</p>
</td></tr>
<tr><td><code id="loglik_+3A_tentr0">Tentr0</code></td>
<td>
<p>entry time for the survival submodel (length ns0)</p>
</td></tr>
<tr><td><code id="loglik_+3A_tevt0">Tevt0</code></td>
<td>
<p>event time for the survival submodel (length ns0)</p>
</td></tr>
<tr><td><code id="loglik_+3A_devt0">Devt0</code></td>
<td>
<p>indicator of event for the survival submodel (length ns0)</p>
</td></tr>
<tr><td><code id="loglik_+3A_idnv0">idnv0</code></td>
<td>
<p>indicator of presence in each subpart of the longitudinal models (length 4*sum(nv0))</p>
</td></tr>
<tr><td><code id="loglik_+3A_idnv20">idnv20</code></td>
<td>
<p>indicator of presence in each subpart of the survival models (length 3*nv20)</p>
</td></tr>
<tr><td><code id="loglik_+3A_nw0">nw0</code></td>
<td>
<p>number of parameters for proportional random effects over latent classes</p>
</td></tr>
<tr><td><code id="loglik_+3A_contrainte0">contrainte0</code></td>
<td>
<p>type of identifiability constraints</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the log-likelihood
</p>


<h3>Author(s)</h3>

<p>Cecile Proust-Lima, Viviane Philipps
</p>

<hr>
<h2 id='mpjlcmm'>Estimation of multivariate joint latent class mixed models</h2><span id='topic+mpjlcmm'></span>

<h3>Description</h3>

<p>This function fits joint latent class models for multivariate longitudinal markers
and competing causes of event. It is a multivariate
extension of the Jointlcmm function. It defines each longitudinal dimension as a 
latent process (mp in mpjlcmm is for multivariate processes), possibly
measured by sereval continuous markers (Gaussian or curvilinear). For the moment, 
theses processes are assumed independent given the latent classes. 
The (optional) survival part handles competing risks, right censoring and left truncation.
The specification of the function is similar to other estimating functions of the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpjlcmm(
  longitudinal,
  subject,
  classmb,
  ng,
  survival,
  hazard = "Weibull",
  hazardtype = "Specific",
  hazardnodes = NULL,
  TimeDepVar = NULL,
  data,
  B,
  convB = 1e-04,
  convL = 1e-04,
  convG = 1e-04,
  maxiter = 100,
  nsim = 100,
  prior,
  logscale = FALSE,
  subset = NULL,
  na.action = 1,
  posfix = NULL,
  partialH = FALSE,
  verbose = FALSE,
  nproc = 1,
  clustertype = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mpjlcmm_+3A_longitudinal">longitudinal</code></td>
<td>
<p>list of longitudinal models of type hlme, lcmm or multlcmm. Each
model defines the structure of one latent process.</p>
</td></tr>
<tr><td><code id="mpjlcmm_+3A_subject">subject</code></td>
<td>
<p>name of the covariate representing the grouping structure
(called subject identifier)</p>
</td></tr>
<tr><td><code id="mpjlcmm_+3A_classmb">classmb</code></td>
<td>
<p>optional one-sided formula describing the covariates in the
class-membership multinomial logistic model</p>
</td></tr>
<tr><td><code id="mpjlcmm_+3A_ng">ng</code></td>
<td>
<p>number of latent classes considered</p>
</td></tr>
<tr><td><code id="mpjlcmm_+3A_survival">survival</code></td>
<td>
<p>two-sided formula object specifying the survival part of the model</p>
</td></tr>
<tr><td><code id="mpjlcmm_+3A_hazard">hazard</code></td>
<td>
<p>optional family of hazard function assumed for the survival model
(Weibull, piecewise or splines)</p>
</td></tr>
<tr><td><code id="mpjlcmm_+3A_hazardtype">hazardtype</code></td>
<td>
<p>optional indicator for the type of baseline risk function
(Specific, PH or Common)</p>
</td></tr>
<tr><td><code id="mpjlcmm_+3A_hazardnodes">hazardnodes</code></td>
<td>
<p>optional vector containing interior nodes if
<code>splines</code> or <code>piecewise</code> is specified for the baseline hazard
function in <code>hazard</code></p>
</td></tr>
<tr><td><code id="mpjlcmm_+3A_timedepvar">TimeDepVar</code></td>
<td>
<p>optional vector specifying the name of the time-dependent
covariate in the survival model</p>
</td></tr>
<tr><td><code id="mpjlcmm_+3A_data">data</code></td>
<td>
<p>data frame containing all the variables used in the model</p>
</td></tr>
<tr><td><code id="mpjlcmm_+3A_b">B</code></td>
<td>
<p>optional specification for the initial values of the parameters.
Three options are allowed: (1) a vector of initial values is entered (the
order in which the parameters are included is detailed in <code>details</code>
section).  (2) nothing is specified. Initial values are extracted from the models
specified in <code>longitudinal</code>, and default initial values are chosen for the
survival part (3) when ng&gt;1, a mpjlcmm object is entered. It should correspond to
the exact same structure of model but with ng=1. The program will
automatically generate initial values from this model. Note that due to possible
local maxima, the <code>B</code> vector should be specified and several different
starting points should be tried. This can be done automatically using 
gridsearch function.</p>
</td></tr>
<tr><td><code id="mpjlcmm_+3A_convb">convB</code></td>
<td>
<p>optional threshold for the convergence criterion based on the
parameter stability</p>
</td></tr>
<tr><td><code id="mpjlcmm_+3A_convl">convL</code></td>
<td>
<p>optional threshold for the convergence criterion based on the
log-likelihood stability</p>
</td></tr>
<tr><td><code id="mpjlcmm_+3A_convg">convG</code></td>
<td>
<p>optional threshold for the convergence criterion based on the
derivatives</p>
</td></tr>
<tr><td><code id="mpjlcmm_+3A_maxiter">maxiter</code></td>
<td>
<p>optional maximum number of iterations for the Marquardt
iterative algorithm</p>
</td></tr>
<tr><td><code id="mpjlcmm_+3A_nsim">nsim</code></td>
<td>
<p>optional number of points for the predicted survival curves and
predicted baseline risk curves</p>
</td></tr>
<tr><td><code id="mpjlcmm_+3A_prior">prior</code></td>
<td>
<p>optional name of a covariate containing a prior information
about the latent class membership</p>
</td></tr>
<tr><td><code id="mpjlcmm_+3A_logscale">logscale</code></td>
<td>
<p>optional boolean indicating whether an exponential
(logscale=TRUE) or a square (logscale=FALSE -by default) transformation is
used to ensure positivity of parameters in the baseline risk functions</p>
</td></tr>
<tr><td><code id="mpjlcmm_+3A_subset">subset</code></td>
<td>
<p>a specification of the rows to be used: defaults to all rows.
This can be any valid indexing vector for the rows of data or if that is not
supplied, a data frame made up of the variable used in formula.</p>
</td></tr>
<tr><td><code id="mpjlcmm_+3A_na.action">na.action</code></td>
<td>
<p>Integer indicating how NAs are managed. The default is 1
for 'na.omit'. The alternative is 2 for 'na.fail'. Other options such as
'na.pass' or 'na.exclude' are not implemented in the current version.</p>
</td></tr>
<tr><td><code id="mpjlcmm_+3A_posfix">posfix</code></td>
<td>
<p>Optional vector specifying the indices in vector B of the
parameters that should not be estimated. Default to NULL, all parameters are
estimated</p>
</td></tr>
<tr><td><code id="mpjlcmm_+3A_partialh">partialH</code></td>
<td>
<p>optional logical for Piecewise and Splines baseline risk
functions and Splines link functions only. Indicates whether the parameters of the
baseline risk or link functions can be dropped from the Hessian matrix to define
convergence criteria (can solve non convergence due to estimates at the boundary 
of the parameter space - usually 0).</p>
</td></tr>
<tr><td><code id="mpjlcmm_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating whether information about computation should be
reported. Default to FALSE.</p>
</td></tr>
<tr><td><code id="mpjlcmm_+3A_nproc">nproc</code></td>
<td>
<p>the number cores for parallel computation.
Default to 1 (sequential mode).</p>
</td></tr>
<tr><td><code id="mpjlcmm_+3A_clustertype">clustertype</code></td>
<td>
<p>optional character indicating the type of cluster for parallel computation.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cecile Proust Lima and Viviane Philipps
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
paquid$age65 &lt;- (paquid$age-65)/10

##############################################################################
###                          EXAMPLE 1 :                                   ###
###two outcomes measuring the same latent process along with dementia onset###
##############################################################################

## multlcmm model for MMSE and BVRT for 1 class
mult1 &lt;- multlcmm(MMSE+BVRT~age65+I(age65^2)+CEP+male,random=~age65+I(age65^2),
subject="ID",link=c("5-quant-splines","4-quant-splines"),data=paquid)
summary(mult1)

## joint model for 1 class
m1S &lt;- mpjlcmm(longitudinal=list(mult1),subject="ID",ng=1,data=paquid,
survival=Surv(age_init,agedem,dem)~1)
summary(m1S)


##### joint model for 2 classes #####

## specify longitudinal model for 2 classes, without estimation
mult2 &lt;- multlcmm(MMSE+BVRT~age65+I(age65^2)+CEP+male,random=~age65+I(age65^2),
subject="ID",link=c("5-quant-splines","4-quant-splines"),ng=2,
mixture=~age65+I(age65^2),data=paquid,B=random(mult1),maxiter=0)

## estimation of the associated joint model 
m2S &lt;- mpjlcmm(longitudinal=list(mult2),subject="ID",ng=2,data=paquid,
survival=Surv(age_init,agedem,dem)~1)

## estimation by a grid search with 50 replicates, initial values
## randomly generated from m1S
m2S_b &lt;- gridsearch(mpjlcmm(longitudinal=list(mult2),subject="ID",ng=2,
data=paquid,survival=Surv(age_init,agedem,dem)~1), minit=m1S, rep=50, maxiter=30)


##### joint model for 3 classes #####
mult3 &lt;- multlcmm(MMSE+BVRT~age65+I(age65^2)+CEP+male,random=~age65+I(age65^2),
subject="ID",link=c("5-quant-splines","4-quant-splines"),ng=3,
mixture=~age65+I(age65^2),data=paquid,B=random(mult1),maxiter=0)

m3S &lt;- mpjlcmm(longitudinal=list(mult3),subject="ID",ng=3,data=paquid,
survival=Surv(age_init,agedem,dem)~1)

m3S_b &lt;- gridsearch(mpjlcmm(longitudinal=list(mult3),subject="ID",ng=3,
data=paquid,survival=Surv(age_init,agedem,dem)~1), minit=m1S, rep=50, maxiter=30)


##### summary of the models #####

summarytable(m1S,m2S,m2S_b,m3S,m3S_b)



##### post-fit #####

## update longitudinal models :
mod2 &lt;- update(m2S)

mult2_post &lt;- mod2[[1]]
## -&gt; use the available functions for multlcmm on the mult2_post object

## fit of the longitudinal trajectories
par(mfrow=c(2,2))
plot(mult2_post,"fit","age65",marg=TRUE,shades=TRUE,outcome=1)
plot(mult2_post,"fit","age65",marg=TRUE,shades=TRUE,outcome=2)

plot(mult2_post,"fit","age65",marg=FALSE,shades=TRUE,outcome=1)
plot(mult2_post,"fit","age65",marg=FALSE,shades=TRUE,outcome=2)


## predicted trajectories
dpred &lt;- data.frame(age65=seq(0,3,0.1),male=0,CEP=0)

predL &lt;- predictL(mult2_post,newdata=dpred,var.time="age65",confint=TRUE)
plot(predL,shades=TRUE) # in the latent process scale


predY &lt;- predictY(mult2_post,newdata=dpred,var.time="age65",draws=TRUE)

plot(predY,shades=TRUE,ylim=c(0,30),main="MMSE") #in the 0-30 scale for MMSE
plot(predY,shades=TRUE,ylim=c(0,15),outcome=2,main="BVRT") #in 0-15 for BVRT

## baseline hazard and survival curves :
plot(m2S,"hazard")
plot(m2S,"survival")

## posteriori probabilities and classification :
postprob(m2S)



####################################################################################
###                              EXAMPLE 2 :                                     ###
### two latent processes measured each by one outcome along with dementia onset  ###
####################################################################################

## define the two longitudinal models

mMMSE1 &lt;- lcmm(MMSE~age65+I(age65^2)+CEP,random=~age65+I(age65^2),subject="ID",
link="5-quant-splines",data=paquid)

mCESD1 &lt;- lcmm(CESD~age65+I(age65^2)+male,random=~age65+I(age65^2),subject="ID",
link="5-quant-splines",data=paquid)


## joint estimation

mm1S &lt;- mpjlcmm(longitudinal=list(mMMSE1,mCESD1),subject="ID",ng=1,data=paquid,
survival=Surv(age_init,agedem,dem)~CEP+male)


## with 2 latent classes

mMMSE2 &lt;- lcmm(MMSE~age65+I(age65^2)+CEP,random=~age65+I(age65^2),subject="ID",
link="5-quant-splines",data=paquid,ng=2,mixture=~age65+I(age65^2),
B=random(mMMSE1),maxiter=0)

mCESD2 &lt;- lcmm(CESD~age65+I(age65^2)+male,random=~age65+I(age65^2),subject="ID",
link="5-quant-splines",data=paquid,ng=2,mixture=~age65+I(age65^2),
B=random(mCESD1),maxiter=0)

mm2S &lt;- mpjlcmm(longitudinal=list(mMMSE2,mCESD2),subject="ID",ng=2,data=paquid,
survival=Surv(age_init,agedem,dem)~CEP+mixture(male),classmb=~CEP+male)

mm2S_b &lt;- gridsearch(mpjlcmm(longitudinal=list(mMMSE2,mCESD2),subject="ID",ng=2,
data=paquid,survival=Surv(age_init,agedem,dem)~CEP+mixture(male),
classmb=~CEP+male),minit=mm1S,rep=50,maxiter=50)

summarytable(mm1S,mm2S,mm2S_b)


mod1_biv &lt;- update(mm1S)
mod2_biv &lt;- update(mm2S)

## -&gt; use post-fit functions as in exemple 1

## End(Not run)

</code></pre>

<hr>
<h2 id='multlcmm'>Estimation of multivariate mixed-effect models and multivariate latent class
mixed-effect models for multivariate longitudinal outcomes of possibly
multiple types (continuous Gaussian, continuous non-Gaussian/curvilinear, ordinal)
that measure the same underlying latent process.</h2><span id='topic+multlcmm'></span><span id='topic+mlcmm'></span>

<h3>Description</h3>

<p>This function constitutes a multivariate extension of function <code>lcmm</code>.
It fits multivariate mixed models and multivariate latent class mixed models
for multivariate longitudinal outcomes of different types. It handles
continuous longitudinal outcomes (Gaussian or non-Gaussian, curvilinear) as
well as ordinal longitudinal outcomes (with cumulative probit measurement model). 
The model assumes that all the outcomes measure the same underlying latent process
defined as their common factor, and each outcome is related to this latent common
factor by a specific parameterized link function. At the latent process level, the
model estimates a standard linear mixed model or a latent class linear mixed
model when heterogeneity in the population is investigated (in the same way
as in functions <code>hlme</code> and <code>lcmm</code>). Parameters of the nonlinear link 
functions and of the latent process mixed model are estimated simultaneously 
using a maximum likelihood method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multlcmm(
  fixed,
  mixture,
  random,
  subject,
  classmb,
  ng = 1,
  idiag = FALSE,
  nwg = FALSE,
  randomY = FALSE,
  link = "linear",
  intnodes = NULL,
  epsY = 0.5,
  cor = NULL,
  data,
  B,
  convB = 1e-04,
  convL = 1e-04,
  convG = 1e-04,
  maxiter = 100,
  nsim = 100,
  prior,
  pprior = NULL,
  range = NULL,
  subset = NULL,
  na.action = 1,
  posfix = NULL,
  partialH = FALSE,
  verbose = FALSE,
  returndata = FALSE,
  methInteg = "QMC",
  nMC = NULL,
  var.time = NULL,
  nproc = 1,
  clustertype = NULL
)

mlcmm(
  fixed,
  mixture,
  random,
  subject,
  classmb,
  ng = 1,
  idiag = FALSE,
  nwg = FALSE,
  randomY = FALSE,
  link = "linear",
  intnodes = NULL,
  epsY = 0.5,
  cor = NULL,
  data,
  B,
  convB = 1e-04,
  convL = 1e-04,
  convG = 1e-04,
  maxiter = 100,
  nsim = 100,
  prior,
  pprior = NULL,
  range = NULL,
  subset = NULL,
  na.action = 1,
  posfix = NULL,
  partialH = FALSE,
  verbose = FALSE,
  returndata = FALSE,
  methInteg = "QMC",
  nMC = NULL,
  var.time = NULL,
  nproc = 1,
  clustertype = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multlcmm_+3A_fixed">fixed</code></td>
<td>
<p>a two-sided linear formula object for specifying the
fixed-effects in the linear mixed model at the latent process level. The
response outcomes are separated by <code>+</code> on the left of <code>~</code> and the
covariates are separated by <code>+</code> on the right of the <code>~</code>. For
identifiability purposes, the intercept specified by default should not be
removed by a <code>-1</code>. Variables on which a contrast above the different
outcomes should also be estimated are included with <code>contrast()</code>.</p>
</td></tr>
<tr><td><code id="multlcmm_+3A_mixture">mixture</code></td>
<td>
<p>a one-sided formula object for the class-specific fixed
effects in the latent process mixed model (to specify only for a number of
latent classes greater than 1). Among the list of covariates included in
<code>fixed</code>, the covariates with class-specific regression parameters are
entered in <code>mixture</code> separated by <code>+</code>. By default, an intercept is
included. If no intercept, <code>-1</code> should be the first term included.</p>
</td></tr>
<tr><td><code id="multlcmm_+3A_random">random</code></td>
<td>
<p>an optional one-sided formula for the random-effects in the
latent process mixed model. At least one random effect should be included
for identifiability purposes. Covariates with a random-effect are separated
by <code>+</code>. By default, an intercept is included. If no intercept,
<code>-1</code> should be the first term included.</p>
</td></tr>
<tr><td><code id="multlcmm_+3A_subject">subject</code></td>
<td>
<p>name of the covariate representing the grouping structure.</p>
</td></tr>
<tr><td><code id="multlcmm_+3A_classmb">classmb</code></td>
<td>
<p>an optional one-sided formula describing the covariates in
the class-membership multinomial logistic model. Covariates included are
separated by <code>+</code>. No intercept should be included in this formula.</p>
</td></tr>
<tr><td><code id="multlcmm_+3A_ng">ng</code></td>
<td>
<p>number of latent classes considered. If <code>ng=1</code> no
<code>mixture</code> nor <code>classmb</code> should be specified. If <code>ng&gt;1</code>,
<code>mixture</code> is required.</p>
</td></tr>
<tr><td><code id="multlcmm_+3A_idiag">idiag</code></td>
<td>
<p>optional logical for the variance-covariance structure of the
random-effects. If <code>FALSE</code>, a non structured matrix of
variance-covariance is considered (by default). If <code>TRUE</code> a diagonal
matrix of variance-covariance is considered.</p>
</td></tr>
<tr><td><code id="multlcmm_+3A_nwg">nwg</code></td>
<td>
<p>optional logical of class-specific variance-covariance of the
random-effects. If <code>FALSE</code> the variance-covariance matrix is common
over latent classes (by default). If <code>TRUE</code> a class-specific
proportional parameter multiplies the variance-covariance matrix in each
class (the proportional parameter in the last latent class equals 1 to
ensure identifiability).</p>
</td></tr>
<tr><td><code id="multlcmm_+3A_randomy">randomY</code></td>
<td>
<p>optional logical for including an outcome-specific random
intercept. If <code>FALSE</code> no outcome-specific random intercept is added
(default). If <code>TRUE</code> independent outcome-specific random intercepts
with parameterized variance are included.</p>
</td></tr>
<tr><td><code id="multlcmm_+3A_link">link</code></td>
<td>
<p>optional vector of families of parameterized link functions to
estimate (one by outcome). Option &quot;linear&quot; (by default) specifies a linear
link function. Other possibilities include &quot;beta&quot; for estimating a link
function from the family of Beta cumulative distribution functions,
&quot;thresholds&quot; for using a threshold model to describe the correspondence
between each level of an ordinal outcome and the underlying latent process and
&quot;Splines&quot; for approximating the link function by I-splines. For this latter
case, the number of nodes and the nodes location should be also specified.
The number of nodes is first entered followed by <code>-</code>, then the location
is specified with &quot;equi&quot;, &quot;quant&quot; or &quot;manual&quot; for respectively equidistant
nodes, nodes at quantiles of the marker distribution or interior nodes
entered manually in argument <code>intnodes</code>. It is followed by <code>-</code> and
finally &quot;splines&quot; is indicated.  For example, &quot;7-equi-splines&quot; means
I-splines with 7 equidistant nodes, &quot;6-quant-splines&quot; means I-splines with 6
nodes located at the quantiles of the marker distribution and
&quot;9-manual-splines&quot; means I-splines with 9 nodes, the vector of 7 interior
nodes being entered in the argument <code>intnodes</code>.</p>
</td></tr>
<tr><td><code id="multlcmm_+3A_intnodes">intnodes</code></td>
<td>
<p>optional vector of interior nodes. This argument is only
required for a I-splines link function with nodes entered manually.</p>
</td></tr>
<tr><td><code id="multlcmm_+3A_epsy">epsY</code></td>
<td>
<p>optional definite positive real used to rescale the marker in
(0,1) when the beta link function is used. By default, epsY=0.5.</p>
</td></tr>
<tr><td><code id="multlcmm_+3A_cor">cor</code></td>
<td>
<p>optional indicator for inclusion of an autocorrelated Gaussian
process in the latent process linear (latent process) mixed model. Option
&quot;BM&quot; indicates a brownian motion with parameterized variance. Option &quot;AR&quot;
specifies an autoregressive process of order 1 with parameterized variance
and correlation intensity. Each option should be followed by the time
variable in brackets as <code>cor=BM(time)</code>. By default, no autocorrelated
Gaussian process is added.</p>
</td></tr>
<tr><td><code id="multlcmm_+3A_data">data</code></td>
<td>
<p>data frame containing the variables named in <code>fixed</code>,
<code>mixture</code>, <code>random</code>, <code>classmb</code> and <code>subject</code>.</p>
</td></tr>
<tr><td><code id="multlcmm_+3A_b">B</code></td>
<td>
<p>optional specification for the initial values for the parameters.
Three options are allowed: (1) a vector of initial values is entered (the
order in which the parameters are included is detailed in <code>details</code>
section).  (2) nothing is specified. A preliminary analysis involving the
estimation of a standard linear mixed model is performed to choose initial
values.  (3) when ng&gt;1, a multlcmm object is entered. It should correspond
to the exact same structure of model but with ng=1. The program will
automatically generate initial values from this model. This specification
avoids the preliminary analysis indicated in (2) Note that due to possible
local maxima, the <code>B</code> vector should be specified and several different
starting points should be tried.</p>
</td></tr>
<tr><td><code id="multlcmm_+3A_convb">convB</code></td>
<td>
<p>optional threshold for the convergence criterion based on the
parameter stability. By default, convB=0.0001.</p>
</td></tr>
<tr><td><code id="multlcmm_+3A_convl">convL</code></td>
<td>
<p>optional threshold for the convergence criterion based on the
log-likelihood stability. By default, convL=0.0001.</p>
</td></tr>
<tr><td><code id="multlcmm_+3A_convg">convG</code></td>
<td>
<p>optional threshold for the convergence criterion based on the
derivatives. By default, convG=0.0001.</p>
</td></tr>
<tr><td><code id="multlcmm_+3A_maxiter">maxiter</code></td>
<td>
<p>optional maximum number of iterations for the Marquardt
iterative algorithm. By default, maxiter=100.</p>
</td></tr>
<tr><td><code id="multlcmm_+3A_nsim">nsim</code></td>
<td>
<p>number of points used to plot the estimated link functions. By
default, nsim=100.</p>
</td></tr>
<tr><td><code id="multlcmm_+3A_prior">prior</code></td>
<td>
<p>name of the covariate containing the prior on the latent class
membership. The covariate should be an integer with values in 0,1,...,ng.
When there is no prior, the value should be 0. When there is a prior for the
subject, the value should be the number of the latent class (in 1,...,ng).</p>
</td></tr>
<tr><td><code id="multlcmm_+3A_pprior">pprior</code></td>
<td>
<p>optional vector specifying the names of the covariates containing the
prior probabilities to belong to each latent class. These probabilities should be
between 0 and 1 and should sum up to 1 for each subject.</p>
</td></tr>
<tr><td><code id="multlcmm_+3A_range">range</code></td>
<td>
<p>optional vector indicating the range of the outcomes (that is
the minimum and maximum). By default, the range is defined according to the
minimum and maximum observed values of the outcome. The option should be
used only for Beta and Splines transformations.</p>
</td></tr>
<tr><td><code id="multlcmm_+3A_subset">subset</code></td>
<td>
<p>optional vector giving the subset of observations in
<code>data</code> to use. By default, all lines.</p>
</td></tr>
<tr><td><code id="multlcmm_+3A_na.action">na.action</code></td>
<td>
<p>Integer indicating how NAs are managed. The default is 1
for 'na.omit'. The alternative is 2 for 'na.fail'. Other options such as
'na.pass' or 'na.exclude' are not implemented in the current version.</p>
</td></tr>
<tr><td><code id="multlcmm_+3A_posfix">posfix</code></td>
<td>
<p>Optional vector giving the indices in vector B of the
parameters that should not be estimated. Default to NULL, all parameters are
estimated.</p>
</td></tr>
<tr><td><code id="multlcmm_+3A_partialh">partialH</code></td>
<td>
<p>optional logical for Splines link functions only.
Indicates whether the parameters of the link functions can be dropped from
the Hessian matrix to define convergence criteria.</p>
</td></tr>
<tr><td><code id="multlcmm_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating if information about computation should be
reported. Default to TRUE.</p>
</td></tr>
<tr><td><code id="multlcmm_+3A_returndata">returndata</code></td>
<td>
<p>logical indicating if data used for computation should be
returned. Default to FALSE, data are not returned.</p>
</td></tr>
<tr><td><code id="multlcmm_+3A_methinteg">methInteg</code></td>
<td>
<p>character indicating the type of integration if ordinal outcomes
are considered. 'MCO' for ordinary Monte Carlo, 'MCA' for antithetic Monte Carlo,
'QMC' for quasi Monte Carlo. Default to &quot;QMC&quot;.</p>
</td></tr>
<tr><td><code id="multlcmm_+3A_nmc">nMC</code></td>
<td>
<p>integer, number of Monte Carlo simulations. By default, 1000 points are used
if at least one threshold link is specified.</p>
</td></tr>
<tr><td><code id="multlcmm_+3A_var.time">var.time</code></td>
<td>
<p>optional character indicating the name of the time variable.</p>
</td></tr>
<tr><td><code id="multlcmm_+3A_nproc">nproc</code></td>
<td>
<p>the number cores for parallel computation.
Default to 1 (sequential mode).</p>
</td></tr>
<tr><td><code id="multlcmm_+3A_clustertype">clustertype</code></td>
<td>
<p>optional character indicating the type of cluster for parallel computation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A. THE PARAMETERIZED LINK FUNCTIONS
</p>
<p><code>multlcmm</code> function estimates multivariate latent class mixed models
for different types of outcomes by assuming a parameterized link function
for linking each outcome Y_k(t) with the underlying latent common factor
L(t) they measure. To fix the latent process dimension, we chose to
constrain at the latent process level the (first) intercept of the latent
class mixed model at 0 and the standard error of the first random effect at
1.
</p>
<p>1. With the &quot;linear&quot; link function, 2 parameters are required for the
following transformation (Y(t) - b1)/b2
</p>
<p>2. With the &quot;beta&quot; link function, 4 parameters are required for the
following transformation: [ h(Y(t)',b1,b2) - b3]/b4 where h is the Beta CDF
with canonical parameters c1 and c2 that can be derived from b1 and b2 as
c1=exp(b1)/[exp(b2)*(1+exp(b1))] and c2=1/[exp(b2)*(1+exp(b1))], and Y(t)'
is the rescaled outcome i.e. Y(t)'= [ Y(t) - min(Y(t)) + epsY ] / [
max(Y(t)) - min(Y(t)) +2*epsY ].
</p>
<p>3. With the &quot;splines&quot; link function, n+2 parameters are required for the
following transformation b_1 + b_2*I_1(Y(t)) + ... + b_(n+2) I_(n+1)(Y(t)),
where I_1,...,I_(n+1) is the basis of quadratic I-splines. To constraint the
parameters to be positive, except for b_1, the program estimates b_k^* (for
k=2,...,n+2) so that b_k=(b_k^*)^2. This parameterization may lead in some
cases to problems of convergence that we are currently addressing.
</p>
<p>4. With the &quot;thresholds&quot; link function for an ordinal outcome with levels
0,...,C, C-1 parameters are required for the following transformation:
Y(t)=c &lt;=&gt; b_c &lt; L(t) &lt;= b_(c+1) with b_0 = - infinity and b_(C+1)=+infinity.
To constraint the parameters to be increasing, except for the first
parameter b_1, the program estimates b_k^* (for k=2,...C-1) so that
b_k=b_(k-1)+(b_k^*)^2.
</p>
<p>Details of these parameterized link functions can be found in the papers:
Proust-Lima et al. (Biometrics 2006), Proust-Lima et al. (BJMSP 2013),
Proust-Lima et al. (arxiv 2021 - https://arxiv.org/abs/2109.13064)
</p>
<p>B. THE VECTOR OF PARAMETERS B
</p>
<p>The parameters in the vector of initial values <code>B</code> or in the vector of
maximum likelihood estimates <code>best</code> are included in the following
order: (1) ng-1 parameters are required for intercepts in the latent class
membership model, and if covariates are included in <code>classmb</code>, ng-1
paramaters should be entered for each one; (2) for all covariates in
<code>fixed</code>, one parameter is required if the covariate is not in
<code>mixture</code>, ng paramaters are required if the covariate is also in
<code>mixture</code>; When ng=1, the intercept is not estimated and no intercept parameter
should be specified in <code>B</code>. When ng&gt;1, the first intercept is not
estimated and only ng-1 intercept parameters should be specified in <code>B</code>; (3) for
all covariates included with <code>contrast()</code> in <code>fixed</code>, one
supplementary parameter per outcome is required excepted for the last
outcome for which the parameter is not estimated but deduced from the
others; (4) if <code>idiag=TRUE</code>, the variance of each random-effect
specified in <code>random</code> is required excepted the first one (usually the
intercept) which is constrained to 1. (5) if <code>idiag=FALSE</code>, the
inferior triangular variance-covariance matrix of all the random-effects is
required excepted the first variance (usually the intercept) which is
constrained to 1. (6) only if <code>nwg=TRUE</code> and <code>ng</code>&gt;1, ng-1
parameters for class-specific proportional coefficients for the variance
covariance matrix of the random-effects; (7) if <code>cor</code> is specified, the
standard error of the Brownian motion or the standard error and the
correlation parameter of the autoregressive process; (8) the standard error
of the outcome-specific Gaussian errors (one per outcome); (9) if
<code>randomY=TRUE</code>, the standard error of the outcome-specific random
intercept (one per outcome); (10) the parameters of each parameterized link
function: 2 for &quot;linear&quot;, 4 for &quot;beta&quot;, n+2 for &quot;splines&quot; with n nodes.
</p>
<p>C. CAUTIONS REGARDING THE USE OF THE PROGRAM
</p>
<p>Some caution should be made when using the program. Convergence criteria are
very strict as they are based on the derivatives of the log-likelihood in
addition to the parameter and log-likelihood stability. In some cases, the
program may not converge and reach the maximum number of iterations fixed at
100. In this case, the user should check that parameter estimates at the
last iteration are not on the boundaries of the parameter space.
</p>
<p>If the parameters are on the boundaries of the parameter space, the
identifiability of the model is critical. This may happen especially with
splines parameters that may be too close to 0 (lower boundary) or classmb
parameters that are too high or low (perfect classification). When
identifiability of some parameters is suspected, the program can be run
again from the former estimates by fixing the suspected parameters to their
value with option posfix. This usually solves the problem. An alternative is
to remove the parameters of the Beta or Splines link function from the
inverse of the Hessian with option partialH.
</p>
<p>If not, the program should be run again with other initial values, with a
higher maximum number of iterations or less strict convergence tolerances.
</p>
<p>Specifically when investigating heterogeneity (that is with ng&gt;1): (1) As
the log-likelihood of a latent class model can have multiple maxima, a
careful choice of the initial values is crucial for ensuring convergence
toward the global maximum. The program can be run without entering the
vector of initial values (see point 2). However, we recommend to
systematically enter initial values in <code>B</code> and try different sets of
initial values. (2) The automatic choice of initial values we provide
requires the estimation of a preliminary linear mixed model. The user should
be aware that first, this preliminary analysis can take time for large
datatsets and second, that the generated initial values can be very not
likely and even may converge slowly to a local maximum. This is the reason
why several alternatives exist. The vector of initial values can be directly
specified in <code>B</code> the initial values can be generated (automatically or
randomly) from a model with <code>ng=</code>. Finally, function <code>gridsearch</code>
performs an automatic grid search.
</p>
<p>D. NUMERICAL INTEGRATION WITH THE THRESHOLD LINK FUNCTION
</p>
<p>When dealing only with continuous outcomes, the computation of the likelihood does not
require any numerical integration over the random-effects, so that the estimation
procedure is relatively fast.
When at least one ordinal outcome is modeled, a numerical integration over the
random-effects is required in each computation of the individual contribution to the
likelihood. This achieved using a Monte-Carlo procedure. We allow three options:
the standard Monte-Carlo simulations, as well as antithetic Monte-Carlo and quasi
Monte-Carlo methods as proposed in Philipson et al (2020).
</p>


<h3>Value</h3>

<p>The list returned is: </p>
<table role = "presentation">
<tr><td><code>ns</code></td>
<td>
<p>number of grouping units in the
dataset</p>
</td></tr> <tr><td><code>ng</code></td>
<td>
<p>number of latent classes</p>
</td></tr> <tr><td><code>loglik</code></td>
<td>
<p>log-likelihood of
the model</p>
</td></tr> <tr><td><code>best</code></td>
<td>
<p>vector of parameter estimates in the same order as
specified in <code>B</code> and detailed in section <code>details</code></p>
</td></tr>
<tr><td><code>V</code></td>
<td>
<p>if the model converged (conv=1 or 3), vector containing the upper triangle
matrix of variance-covariance estimates of <code>Best</code> with exception for
variance-covariance parameters of the random-effects for which <code>V</code> contains the
variance-covariance estimates of the Cholesky transformed parameters displayed in
<code>cholesky</code>. If conv=2, <code>V</code> contains the second derivatives of the
log-likelihood.</p>
</td></tr> <tr><td><code>gconv</code></td>
<td>
<p>vector of convergence criteria: 1. on the
parameters, 2. on the likelihood, 3. on the derivatives</p>
</td></tr> <tr><td><code>conv</code></td>
<td>
<p>status
of convergence: =1 if the convergence criteria were satisfied, =2 if the
maximum number of iterations was reached, =4 or 5 if a problem occured
during optimisation</p>
</td></tr> <tr><td><code>call</code></td>
<td>
<p>the matched call</p>
</td></tr> <tr><td><code>niter</code></td>
<td>
<p>number of
Marquardt iterations</p>
</td></tr> <tr><td><code>N</code></td>
<td>
<p>internal information used in related
functions</p>
</td></tr> <tr><td><code>idiag</code></td>
<td>
<p>internal information used in related functions</p>
</td></tr>
<tr><td><code>pred</code></td>
<td>
<p>table of individual predictions and residuals in the underlying
latent process scale; it includes marginal predictions (pred_m), marginal
residuals (resid_m), subject-specific predictions (pred_ss) and
subject-specific residuals (resid_ss) averaged over classes, the transformed
observations in the latent process scale (obs) and finally the
class-specific marginal and subject-specific predictions (with the number of
the latent class: pred_m_1,pred_m_2,...,pred_ss_1,pred_ss_2,...). If <code>var.time</code>
is specified, the corresponding measurement time is also included.</p>
</td></tr>
<tr><td><code>pprob</code></td>
<td>
<p>table of posterior classification and posterior individual
class-membership probabilities</p>
</td></tr> <tr><td><code>Xnames</code></td>
<td>
<p>list of covariates included in
the model</p>
</td></tr> <tr><td><code>predRE</code></td>
<td>
<p>table containing individual predictions of the
random-effects : a column per random-effect, a line per subject.</p>
</td></tr>
<tr><td><code>cholesky</code></td>
<td>
<p>vector containing the estimates of the Cholesky transformed
parameters of the variance-covariance matrix of the random-effects</p>
</td></tr>
<tr><td><code>estimlink</code></td>
<td>
<p>table containing the simulated values of each outcome and
the corresponding estimated link function</p>
</td></tr> <tr><td><code>epsY</code></td>
<td>
<p>definite positive
reals used to rescale the markers in (0,1) when the beta link function is
used. By default, epsY=0.5.</p>
</td></tr> <tr><td><code>linktype</code></td>
<td>
<p>indicators of link function
types: 0 for linear, 1 for beta, 2 for splines and 3 for thresholds</p>
</td></tr>
<tr><td><code>linknodes</code></td>
<td>
<p>vector of nodes useful only for the 'splines' link
functions</p>
</td></tr> <tr><td><code>data</code></td>
<td>
<p>the original data set (if returndata is TRUE)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cecile Proust-Lima and Viviane Philipps
</p>
<p><a href="mailto:cecile.proust-lima@inserm.fr">cecile.proust-lima@inserm.fr</a>
</p>


<h3>References</h3>

<p>Proust-Lima C, Philipps V, Liquet B (2017). Estimation of Extended Mixed 
Models Using Latent Classes and Latent Processes: The R Package lcmm. 
Journal of Statistical Software, 78(2), 1-56. doi:10.18637/jss.v078.i02
</p>
<p>Proust and Jacqmin-Gadda (2005). Estimation of linear mixed models with a
mixture of distribution for the random-effects. Comput Methods Programs
Biomed 78: 165-73.
</p>
<p>Proust, Jacqmin-Gadda, Taylor, Ganiayre, and Commenges (2006). A nonlinear
model with latent process for cognitive evolution using multivariate
longitudinal data. Biometrics 62, 1014-24.
</p>
<p>Proust-Lima, Dartigues and Jacqmin-Gadda (2011). Misuse of the linear mixed
model when evaluating risk factors of cognitive decline. Amer J Epidemiol
174(9): 1077-88.
</p>
<p>Proust-Lima, Amieva, Jacqmin-Gadda (2013). Analysis of multivariate mixed
longitudinal data: A flexible latent process approach. Br J Math Stat
Psychol 66(3): 470-87.
</p>
<p>Commenges, Proust-Lima, Samieri, Liquet (2012). A universal approximate
cross-validation criterion and its asymptotic distribution, Arxiv.
</p>
<p>Philipson, Hickey, Crowther, Kolamunnage-Dona (2020). Faster Monte Carlo estimation
of semiparametric joint models of time-to-event and multivariate longitudinal data.
Computational Statistics &amp; Data Analysis 151.
</p>
<p>Proust-Lima, Philipps, Perrot, Blanchin, Sebille (2021). Modeling repeated 
self-reported outcome data: a continuous-time longitudinal Item Response 
Theory model. https://arxiv.org/abs/2109.13064
</p>


<h3>See Also</h3>

<p><code><a href="#topic+postprob">postprob</a></code>, <code><a href="#topic+plot.multlcmm">plot.multlcmm</a></code>, <code><a href="#topic+predictL">predictL</a></code>,
<code><a href="#topic+predictY">predictY</a></code> <code><a href="#topic+lcmm">lcmm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# Latent process mixed model for two curvilinear outcomes. Link functions are 
# aproximated by I-splines, the first one has 3 nodes (i.e. 1 internal node 8),
# the second one has 4 nodes (i.e. 2 internal nodes 12,25)

m1 &lt;- multlcmm(Ydep1+Ydep2~1+Time*X2+contrast(X2),random=~1+Time,
subject="ID",randomY=TRUE,link=c("4-manual-splines","3-manual-splines"),
intnodes=c(8,12,25),data=data_lcmm)

# to reduce the computation time, the same model is estimated using 
# a vector of initial values
m1 &lt;- multlcmm(Ydep1+Ydep2~1+Time*X2+contrast(X2),random=~1+Time,
subject="ID",randomY=TRUE,link=c("4-manual-splines","3-manual-splines"),
intnodes=c(8,12,25),data=data_lcmm, 
B=c(-1.071, -0.192,  0.106, -0.005, -0.193,  1.012,  0.870,  0.881,
  0.000,  0.000, -7.520,  1.401,  1.607 , 1.908,  1.431,  1.082,
 -7.528,  1.135 , 1.454 , 2.328, 1.052))


# output of the model
summary(m1)
# estimated link functions
plot(m1,which="linkfunction")
# variation percentages explained by linear mixed regression
VarExpl(m1,data.frame(Time=0))

#### Heterogeneous latent process mixed model with linear link functions 
#### and 2 latent classes of trajectory 
m2 &lt;- multlcmm(Ydep1+Ydep2~1+Time*X2,random=~1+Time,subject="ID",
link="linear",ng=2,mixture=~1+Time,classmb=~1+X1,data=data_lcmm,
B=c( 18,-20.77,1.16,-1.41,-1.39,-0.32,0.16,-0.26,1.69,1.12,1.1,10.8,
1.24,24.88,1.89))
# summary of the estimation
summary(m2)
# posterior classification
postprob(m2)
# longitudinal predictions in the outcomes scales for a given profile of covariates 
newdata &lt;- data.frame(Time=seq(0,5,length=100),X1=0,X2=0,X3=0)
predGH &lt;- predictY(m2,newdata,var.time="Time",methInteg=0,nsim=20) 
head(predGH)

## End(Not run)

</code></pre>

<hr>
<h2 id='paquid'>Longitudinal data on cognitive and physical aging in the elderly</h2><span id='topic+paquid'></span>

<h3>Description</h3>

<p>The dataset consists in a subsample of the Paquid prospective cohort study.
Repeated measures cognitive measures (MMSE, IST, BVRT psychometric tests),
physical dependency (HIER) and depression sympatomatology (CESD) were
collected over a maximum period of 20 years along with dementia information
(age at dementia diagnosis, dementia diagnosis information).
Time-independent socio-demographic information is also provided (CEP, male,
age_init).
</p>


<h3>Format</h3>

<p>A data frame with 2250 observations over 500 subjects and 12
variables: </p>
 <dl>
<dt>ID</dt><dd><p>subject identification number</p>
</dd>
<dt>MMSE</dt><dd><p>score at the Mini-Mental State Examination (MMSE), a
psychometric test of global cognitive functioning (integer in range 0-30)</p>
</dd>
<dt>BVRT</dt><dd><p>score at the Benton Visual Retention Test (BVRT), a
psychometric test of spatial memory (integer in range 0-15)</p>
</dd>
<dt>IST</dt><dd><p>score at the Isaacs Set Test (IST) truncated at 15
seconds, a test of verbal memory (integer in range 0-40)</p>
</dd>
<dt>HIER</dt><dd><p>score of physical dependency (0=no dependency, 1=mild
dependency, 2=moderate dependency, 3=severe dependency)</p>
</dd>
<dt>CESD</dt><dd><p>score of a short self-report scale CES-D designed to
measure depressive symptomatology in the general population (integer in
range 0-52)</p>
</dd> <dt>age</dt><dd><p>age at the follow-up visit</p>
</dd>
<dt>dem</dt><dd><p>indicator of positive diagnosis of dementia</p>
</dd>
<dt>agedem</dt><dd><p>age at dementia diagnosis for <code>dem=1</code> and at last
contact for <code>dem=0</code></p>
</dd> <dt>age_init</dt><dd><p>age at entry in the
cohort</p>
</dd> <dt>CEP</dt><dd><p>binary indicator of educational level
(<code>CEP=1</code> for subjects who graduated from primary school; <code>CEP=0</code>
otherwise)</p>
</dd> <dt>male</dt><dd><p>binary indicator for gender (<code>male=1</code>
for men; <code>male=0</code> for women)</p>
</dd> </dl>



<h3>References</h3>

<p>Letenneur, L., Commenges, D., Dartigues, J. F., &amp;
Barberger-Gateau, P. (1994). Incidence of dementia and Alzheimer's disease
in elderly community residents of southwestern France. International Journal
of Epidemiology, 23 (6), 1256-61.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
summary(paquid)

</code></pre>

<hr>
<h2 id='permut'>Permutation of the latent classes</h2><span id='topic+permut'></span>

<h3>Description</h3>

<p>This function allows a re-ordering of the latent classes of an estimated model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permut(m, order, estim = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="permut_+3A_m">m</code></td>
<td>
<p>an object inheriting from classes <code>hlme</code>, <code>lcmm</code>, <code>multlcmm</code> or <code>Jointlcmm</code></p>
</td></tr>
<tr><td><code id="permut_+3A_order">order</code></td>
<td>
<p>a vector (integer between 1 and ng) containing the new order of the latent classes</p>
</td></tr>
<tr><td><code id="permut_+3A_estim">estim</code></td>
<td>
<p>optional boolean specifying if the model should estimated with the reordered parameters as initial values. By default, the model is estimated. If FALSE, only the coefficients in <code>$best</code> are modified. All other outputs are not changed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same class as m, with reordered classes, or the initial object with new coefficients if estim is FALSE.
</p>


<h3>Author(s)</h3>

<p>Viviane Philipps and Cecile Proust-Lima
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Estimation of a hlme model with 2 classes
m2 &lt;- hlme(Y~Time*X1,mixture=~Time,random=~Time,classmb=~X2+X3,subject='ID',
         ng=2,data=data_hlme,B=c(0.11,-0.74,-0.07,20.71,
                                 29.39,-1,0.13,2.45,-0.29,4.5,0.36,0.79,0.97))

## Exchange class 2 and class 1
m2b &lt;- permut(m2,order=c(2,1))

</code></pre>

<hr>
<h2 id='plot'>Plot of a fitted model</h2><span id='topic+plot'></span><span id='topic+plot.hlme'></span><span id='topic+plot.lcmm'></span><span id='topic+plot.multlcmm'></span><span id='topic+plot.Jointlcmm'></span><span id='topic+plot.mpjlcmm'></span><span id='topic+plot.externSurv'></span><span id='topic+plot.externX'></span>

<h3>Description</h3>

<p>This function produces different plots (residuals, goodness-of-fit,
estimated link functions, estimated baseline risk/survival and posterior
probabilities distributions) of a fitted object of class hlme, lcmm,
multlcmm or Jointlcmm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hlme'
plot(x, which = "residuals", var.time, break.times, marg, subset, shades, ...)

## S3 method for class 'lcmm'
plot(x, which = "residuals", var.time, break.times, marg, subset, shades, ...)

## S3 method for class 'multlcmm'
plot(
  x,
  which = "residuals",
  var.time,
  break.times,
  marg,
  outcome,
  subset,
  shades,
  ...
)

## S3 method for class 'Jointlcmm'
plot(
  x,
  which = "residuals",
  var.time,
  break.times,
  marg,
  event,
  subset,
  shades,
  ...
)

## S3 method for class 'mpjlcmm'
plot(x, which, event, ...)

## S3 method for class 'externSurv'
plot(x, which = "hazard", event, ...)

## S3 method for class 'externX'
plot(x, which = "postprob", event, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>an object inheriting from classes <code>hlme</code>, <code>lcmm</code>,
<code>multlcmm</code> or <code>Jointlcmm</code>, representing respectively a fitted
latent class linear mixed model, a more general latent class mixed model or
a joint latent class model</p>
</td></tr>
<tr><td><code id="plot_+3A_which">which</code></td>
<td>
<p>a character string indicating the type of plot to produce. For
<code>hlme</code> objects, are available &quot;residuals&quot;, &quot;postprob&quot;,&quot;fit&quot;. For
<code>lcmm</code> and <code>multlcmm</code> objects, are available &quot;residuals&quot;,
&quot;postprob&quot;, &quot;link&quot;, &quot;linkfunction&quot;, &quot;fit&quot;.  For <code>Jointlcmm</code> objects,
are avaiable &quot;residuals&quot;, &quot;postprob&quot;, &quot;link&quot;, &quot;linkfunction&quot;, &quot;fit&quot;,
&quot;hazard&quot;, &quot;baselinerisk&quot;, &quot;survival&quot;. Default to &quot;residuals&quot;</p>
</td></tr>
<tr><td><code id="plot_+3A_var.time">var.time</code></td>
<td>
<p>for <code>which="fit"</code> only, a character string containing
the name of the variable that corresponds to time in the longitudinal model.</p>
</td></tr>
<tr><td><code id="plot_+3A_break.times">break.times</code></td>
<td>
<p>for <code>which="fit"</code> only, either a numeric vector
containing the cuts-off defining the time-intervals or an integer giving the
number of cut-offs. In the latter case, the cut-offs are placed at the
quantiles of the observed times distribution.</p>
</td></tr>
<tr><td><code id="plot_+3A_marg">marg</code></td>
<td>
<p>for <code>which="fit"</code> only, a logical indicating the type of
prediction. If <code>marg=TRUE</code> (the default), the marginal predictions are
provided. If <code>marg=FALSE</code>, the subject-specific predictions are
provided.</p>
</td></tr>
<tr><td><code id="plot_+3A_subset">subset</code></td>
<td>
<p>for <code>which="fit"</code> only, a subset of the data used to
estimate the model, defining the data on which the fit is evaluated. By
default, all the data are used.</p>
</td></tr>
<tr><td><code id="plot_+3A_shades">shades</code></td>
<td>
<p>logical indicating if confidence intervals should be
represented with shades. Default to FALSE, confidence intervals are
represented as dotted lines.</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>other parameters to be passed through to plotting functions.
This includes graphical parameters described in par function and further arguments
legend (character or expression
to appear in the legend. If no legend should be added, <code>"legend"</code>
should be NULL. ),
legend.loc (keyword for the position of the legend from the list
<code>"bottomright"</code>, <code>"bottom"</code>, <code>"bottomleft"</code>, 
<code>"left"</code>, <code>"topleft"</code>,<code>"top"</code>, <code>"topright"</code>,
<code>"right"</code> and <code>"center"</code>. By default, the legend is located in
the top left of the plot. ) and
add (logical indicating if the curves
should be added to an existing plot. Default to FALSE.).</p>
</td></tr>
<tr><td><code id="plot_+3A_outcome">outcome</code></td>
<td>
<p>for <code>which="fit"</code> and <code>multlcmm</code> objects only, the
outcome to consider.</p>
</td></tr>
<tr><td><code id="plot_+3A_event">event</code></td>
<td>
<p>for <code>which="baselinerisk"</code> or <code>which="hazard"</code> only,
an integer corresponding to the numeric code (in the indicator variable) of
the event for which the baseline risk functions are to be plotted. By
default, the first event is considered.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With <code>which="residuals"</code>, this function provides the marginal residuals
against the marginal predictions, the subject-specific residuals against the
subject-specific predictions, a normal QQ-plot with confidence bands for the
marginal residuals and a normal QQ-plot with confidence bands for the
subject-specific residuals.
</p>
<p>With <code>which="postprob"</code>, the function provides the histograms of the
posterior class-membership probabilities stemmed from a <code>Jointlcmm</code>,
<code>lcmm</code>, <code>hlme</code> or <code>multlcmm</code> object.
</p>
<p>With <code>which="link"</code> or <code>which="linkfunction"</code>, the function
displays the estimated transformation(s) specified in the option <code>link</code>
of <code>lcmm</code> and <code>multlcmm</code> functions. It corresponds to the
(non)linear parameterized link estimated between the oberved longitudinal
outcome and the underlying latent process.
</p>
<p>With <code>which="fit"</code>, the function provides the class-specific weighted
marginal and subject-specific mean predicted trajectories with time and the
class-specific weighted mean observed trajectories and their 95% confidence
bounds. The predicted and observed class-specific values are weighted means
within each time interval; For each observation or prediction (in the
transformed scale if appropriate), the weights are the class-specific
(posterior with subject-specific or marginal otherwise) probabilities to
belong to the latent class.
</p>
<p>With <code>which="baselinerisk"</code> or <code>which="hazard"</code>, the function
displays the estimated baseline risk functions for the time-to-event of
interest in each latent class.
</p>
<p>With <code>which="survival"</code>, the function displays the estimated event-free
probabilities (survival functions) for the time-to-event of interest in each
latent class.
</p>


<h3>Author(s)</h3>

<p>Cecile Proust-Lima, Viviane Philipps and Benoit Liquet
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hlme">hlme</a></code>, <code><a href="#topic+lcmm">lcmm</a></code>, <code><a href="#topic+multlcmm">multlcmm</a></code>,
<code><a href="#topic+Jointlcmm">Jointlcmm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

###################### fit, residuals and postprob 

# estimation of the model
m&lt;-lcmm(Y~Time*X1,mixture=~Time,random=~Time,classmb=~X2+X3,
subject='ID',ng=2,data=data_hlme,B=c(0.41,0.55,-0.18,-0.41,
-14.26,-0.34,1.33,13.51,24.65,2.98,1.18,26.26,0.97))  

# fit
plot(m,which="fit",marg=FALSE,var.time="Time",bty="n")
# residuals plot
plot(m)
# postprob plot
plot(m,which="postprob") 


###################### fit, linkfunctions

#### Estimation of homogeneous mixed models with different assumed link
#### functions, a quadratic mean trajectory for the latent process with 
#### independent random intercept, slope and quadratic slope
#### (comparison of linear, Beta and 3 and 5 splines link functions)
## Not run: 

# linear link function
m10&lt;-lcmm(Ydep2~Time+I(Time^2),random=~Time+I(Time^2),subject='ID',ng=1,
          data=data_lcmm,link="linear",
          B=c(-0.7454, -0.2031,  0.2715,  0.2916 , 0.6114, -0.0064,  0.0545,
              0.0128, 25.3795, 2.2371))
            
# Beta link function
m11&lt;-lcmm(Ydep2~Time+I(Time^2),random=~Time+I(Time^2),subject='ID',ng=1,
          data=data_lcmm,link="beta",B=c(-0.9109, -0.0831,  0.5194,  0.1910 ,
          0.8984, -0.0179, -0.0636,  0.0045,  0.5514, -0.7692,  0.7037,  0.0899))
          
# fit 
par(mfrow=c(2,1),mar=c(4,4,1,1))
plot(m11,which="fit",var.time="Time",bty="l",ylim=c(-3,0))
plot(m11,which="fit",var.time="Time",marg=FALSE,bty="l",ylim=c(-3,0))

# I-splines with 3 equidistant nodes
m12&lt;-lcmm(Ydep2~Time+I(Time^2),random=~Time+I(Time^2),subject='ID',ng=1,
          data=data_lcmm,link="3-equi-splines",B=c(-0.9272, -0.0753 , 0.5304, 
          0.1950,  0.9260, -0.0204, -0.0739 , 0.0059, -7.8369,  0.9228 ,-1.4689,
          2.0396,  1.8102))

# I-splines with 5 nodes, and interior nodes entered manually
m13&lt;-lcmm(Ydep2~Time+I(Time^2),random=~Time+I(Time^2),subject='ID',ng=1,
          data=data_lcmm,link="5-manual-splines",intnodes=c(10,20,25),
          B=c(-0.9315, -0.0739 , 0.5254 , 0.1933,  0.9418, -0.0206, -0.0776,
          0.0064, -7.8645, 0.7470,  1.2080,  1.5537 , 1.7558 , 1.3386 , 1.0982))

# Plot of estimated different link functions:
# (applicable for models that only differ in the "link function" used. 
# Otherwise, the latent process scale is different and a rescaling
# is necessary)
plot(m10,which="linkfunction",bty="l")
plot(m11,which="linkfunction",bty="l",add=TRUE,col=2)
plot(m12,which="linkfunction",bty="l",add=TRUE,col=3)
plot(m13,which="linkfunction",bty="l",add=TRUE,col=4)
legend("topleft",legend=c("linear","beta","3-Isplines","5-Isplines"),
col=1:4,lty=1,bty='n')

## End(Not run)


###################### fit, baselinerisk and survival
## Not run: 
#### estimation with 3 latent classes (ng=3) - see Jointlcmm 
#### help for details on the model
m3 &lt;- Jointlcmm(fixed= Ydep1~Time*X1,mixture=~Time,random=~Time,
classmb=~X3,subject='ID',survival = Surv(Tevent,Event)~ X1+mixture(X2),
hazard="3-quant-splines",hazardtype="PH",ng=3,data=data_lcmm,
B=c(0.7576, 0.4095, -0.8232, -0.2737, 0, 0, 0, 0.2838, -0.6338, 
2.6324, 5.3963, -0.0273, 1.3979, 0.8168, -15.041, 10.164, 10.2394, 
11.5109, -2.6219, -0.4553, -0.6055, 1.473, -0.0383, 0.8512, 0.0389, 
0.2624, 1.4982))

# fit
plot(m3,which="fit",var.time="Time",bty="l")
plot(m3,which="fit",var.time="Time",marg=FALSE,bty="l",ylim=c(0,15))


# Class-specific predicted baseline risk &amp; survival functions in the 
# 3-class model retained (for the reference value of the covariates) 
plot(m3,which="baselinerisk",bty="l")
plot(m3,which="baselinerisk",ylim=c(0,5),bty="l")
plot(m3,which="survival",bty="l")

## End(Not run)


</code></pre>

<hr>
<h2 id='plot.cuminc'>Plot of predicted cumulative incidences according to a profile of covariates</h2><span id='topic+plot.cuminc'></span>

<h3>Description</h3>

<p>This function displays the predicted cause-specific cumulative incidences
derived from a joint latent class model according to a profile of
covariates.  
does. ~~
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cuminc'
plot(
  x,
  profil = 1,
  event = 1,
  add = FALSE,
  legend,
  legend.loc = "topleft",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.cuminc_+3A_x">x</code></td>
<td>
<p>an object of class <code>cuminc</code></p>
</td></tr>
<tr><td><code id="plot.cuminc_+3A_profil">profil</code></td>
<td>
<p>an integer giving the profile number for which the cumulative
incidences are to be plotted.</p>
</td></tr>
<tr><td><code id="plot.cuminc_+3A_event">event</code></td>
<td>
<p>an integer giving the event indicator for which the cumulative
incidence are to be plotted.</p>
</td></tr>
<tr><td><code id="plot.cuminc_+3A_add">add</code></td>
<td>
<p>logical indicating if the curves should be added to an existing
plot. Default to FALSE.</p>
</td></tr>
<tr><td><code id="plot.cuminc_+3A_legend">legend</code></td>
<td>
<p>character or expression to appear in the legend. If no legend
should be added, <code>"legend"</code> should be NULL.</p>
</td></tr>
<tr><td><code id="plot.cuminc_+3A_legend.loc">legend.loc</code></td>
<td>
<p>keyword for the position of the legend from the list
<code>"bottomright"</code>, <code>"bottom"</code>, <code>"bottomleft"</code>, <code>"left"</code>,
<code>"topleft"</code>,<code>"top"</code>, <code>"topright"</code>, <code>"right"</code> and
<code>"center"</code>. By default, the legend is located in the top left of the
plot.</p>
</td></tr>
<tr><td><code id="plot.cuminc_+3A_...">...</code></td>
<td>
<p>other parameters to be passed through to plotting functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns NULL
</p>


<h3>Author(s)</h3>

<p>Viviane Philipps and Cecile Proust-Lima
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Jointlcmm">Jointlcmm</a></code>, <code><a href="#topic+plot.Jointlcmm">plot.Jointlcmm</a></code>, <code><a href="#topic+cuminc">cuminc</a></code>
</p>

<hr>
<h2 id='plot.Diffepoce'>Plots</h2><span id='topic+plot.Diffepoce'></span><span id='topic+plot.pred.accuracy'></span><span id='topic+plot.epoce'></span>

<h3>Description</h3>

<p>This function displays plots related to predictive accuracy functions:
<code>epoce</code> and <code>Diffepoce</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Diffepoce'
plot(x, ...)

## S3 method for class 'epoce'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.Diffepoce_+3A_x">x</code></td>
<td>
<p>an object inheriting from classes <code>epoce</code> or <code>Diffepoce</code></p>
</td></tr>
<tr><td><code id="plot.Diffepoce_+3A_...">...</code></td>
<td>
<p>other parameters to be passed through to plotting functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions do not apply for the moment with multiple causes of event
(competing risks).
</p>
<p>For <code>epoce</code> objects, the function displays the EPOCE estimate (either
MPOL or CVPOL) according to the time of prediction.  For <code>Diffepoce</code>
objects, <code>plot</code> displays the difference in EPOCE estimates (either MPOL
or CVPOL) and its 95% tracking interval between two joint latent class
models
</p>


<h3>Value</h3>

<p>Returns plots related to <code>epoce</code> and <code>Diffepoce</code>
</p>


<h3>Author(s)</h3>

<p>Cecile Proust-Lima and Viviane Philipps
</p>


<h3>See Also</h3>

<p><code><a href="#topic+epoce">epoce</a></code>,<code><a href="#topic+Diffepoce">Diffepoce</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# estimation of the joint latent class model
m3 &lt;- Jointlcmm(fixed= Ydep1~Time*X1,mixture=~Time,random=~Time,
classmb=~X3,subject='ID',survival = Surv(Tevent,Event)~X1+mixture(X2),
hazard="3-quant-splines",hazardtype="PH",ng=3,data=data_lcmm,
B=c(0.7667, 0.4020, -0.8243, -0.2726, 0.0000, 0.0000, 0.0000, 0.3020,
-0.6212, 2.6247, 5.3139, -0.0255, 1.3595, 0.8172, -11.6867, 10.1668,
10.2355, 11.5137, -2.6209, -0.4328, -0.6062, 1.4718, -0.0378, 0.8505,
0.0366, 0.2634, 1.4981))
# predictive accuracy of the model evaluated with EPOCE
VecTime &lt;- c(1,3,5,7,9,11,13,15)
cvpl &lt;- epoce(m3,var.time="Time",pred.times=VecTime)
summary(cvpl)
plot(cvpl,bty="l",ylim=c(0,2))

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.dynpred'>Plot of individual dynamic predictions</h2><span id='topic+plot.dynpred'></span>

<h3>Description</h3>

<p>This function provides a graphical representation of individual dynamic
predictions obtained from a joint latent class model and plots
simultaneously the observed outcome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dynpred'
plot(x, subject = NULL, landmark = NULL, horizon = NULL, add = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.dynpred_+3A_x">x</code></td>
<td>
<p>a dynpred object, containing the predicted probabilities of event
in a time window, obtained from a joint latent class model.</p>
</td></tr>
<tr><td><code id="plot.dynpred_+3A_subject">subject</code></td>
<td>
<p>a vector containing the identifiers of the subjects the user
wants to display. If NULL (the default), all subjects are plotted.</p>
</td></tr>
<tr><td><code id="plot.dynpred_+3A_landmark">landmark</code></td>
<td>
<p>a vector containing the landmark times from which the
probabilities are to be plotted. If NULL (the default), all landmarks are
used. If several horizon are specified, only one landmark should be
selected.</p>
</td></tr>
<tr><td><code id="plot.dynpred_+3A_horizon">horizon</code></td>
<td>
<p>a vector containing the horizon times from which the
probabilities are to be plotted. If NULL (the default), all horizons are
used. If several landmarks are specified, only one horizon should be
selected.</p>
</td></tr>
<tr><td><code id="plot.dynpred_+3A_add">add</code></td>
<td>
<p>logical indicating if the plot should be added to an existing
plot. By default (add=FALSE), a new plot is created.</p>
</td></tr>
<tr><td><code id="plot.dynpred_+3A_...">...</code></td>
<td>
<p>optional graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two types of plot are provided for the moment :
</p>
<p>- if one horizon is selected (and one or several landmarks), each prediction
is represented by a point at the landmark time. If available, the
predictions are surrounded by confidence intervals.
</p>
<p>- if several horizons (t1, t2, etc) and only one landmark (s) is selected, a
line linking the predictions (placed at abscissa s+t1, s+t2, etc) is drawn.
Confidence bands (if available) are represented as dotted lines.
</p>


<h3>Value</h3>

<p>returns NULL
</p>


<h3>Author(s)</h3>

<p>Cecile Proust-Lima, Viviane Philipps
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dynpred">dynpred</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 

## Joint latent class model with 2 classes :
m32 &lt;- Jointlcmm(Ydep1~Time*X1,mixture=~Time,random=~Time,subject="ID",
classmb=~X3,ng=2,survival=Surv(Tevent,Event)~X1+mixture(X2),
hazard="3-quant-splines",hazardtype="PH",data=data_lcmm,B = c(0.64, -0.62, 
0, 0, 0.52, 0.81, 0.41, 0.78, 0.1, 0.77, -0.05, 10.43, 11.3, -2.6, -0.52, 1.41, 
-0.05, 0.91, 0.05, 0.21, 1.5))

## Predictions at landmark 10 and 12 for horizon 3, 5 and 10 for two subjects :
dynpred.m32 &lt;- dynpred(m32,landmark=c(10,12),horizon=c(3,5,10),var.time="Time",
fun.time=function(x){10*x},newdata=data_lcmm[4:8,],draws=TRUE,ndraws=2000)

## Plot of the predictions at landmark 10 for horizon 3,5,10 :
plot(dynpred.m32,landmark=10)

## Plot of the predictions at landmark 10 and 12 for horizon 3 :
plot(dynpred.m32,horizon=3)

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.ItemInfo'>Plot of information functions</h2><span id='topic+plot.ItemInfo'></span>

<h3>Description</h3>

<p>This function plots the information functions stemmed
from a <code>lcmm</code> or <code>multlcmm</code> object with ordinal outcomes modeled via threshold links.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ItemInfo'
plot(
  x,
  which = "ItemInfo",
  outcome = "all",
  legend.loc = "topright",
  legend = NULL,
  add = FALSE,
  shades = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.ItemInfo_+3A_x">x</code></td>
<td>
<p>an object inheriting from classes <code>ItemInfo</code></p>
</td></tr>
<tr><td><code id="plot.ItemInfo_+3A_which">which</code></td>
<td>
<p>character specifying the values to plot. Should be one of 'ItemInfo' for
the Fisher information function of the ordinal outcomes, 'LevelInfo' for the
information of each item's level or 'LevelProb' for the probability of the item's
levels.  Default to 'ItemInfo'.</p>
</td></tr>
<tr><td><code id="plot.ItemInfo_+3A_outcome">outcome</code></td>
<td>
<p>character specifying the outcome to consider. Default to &quot;all&quot;.</p>
</td></tr>
<tr><td><code id="plot.ItemInfo_+3A_legend.loc">legend.loc</code></td>
<td>
<p>keyword for the position of the legend from the list
<code>"bottomright"</code>, <code>"bottom"</code>, <code>"bottomleft"</code>, <code>"left"</code>,
<code>"topleft"</code>,<code>"top"</code>, <code>"topright"</code>, <code>"right"</code> and
<code>"center"</code>.</p>
</td></tr>
<tr><td><code id="plot.ItemInfo_+3A_legend">legend</code></td>
<td>
<p>character or expression to appear in the legend. If no legend
should be added, <code>"legend"</code> should be NULL.</p>
</td></tr>
<tr><td><code id="plot.ItemInfo_+3A_add">add</code></td>
<td>
<p>logical indicating if the curves should be added to an existing
plot. Default to FALSE.</p>
</td></tr>
<tr><td><code id="plot.ItemInfo_+3A_shades">shades</code></td>
<td>
<p>logical indicating if confidence intervals should be
represented with shades. Default to FALSE, the confidence intervals are
represented with dotted lines.</p>
</td></tr>
<tr><td><code id="plot.ItemInfo_+3A_...">...</code></td>
<td>
<p>other parameters to be passed through to plotting functions or
to legend</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Viviane Philipps and Cecile Proust-Lima
</p>

<hr>
<h2 id='plot.predict'>Plot of predicted trajectories and link functions</h2><span id='topic+plot.predict'></span><span id='topic+plot.predictL'></span><span id='topic+plot.predictY'></span><span id='topic+plot.predictY.hlme'></span><span id='topic+plot.predictY.lcmm'></span><span id='topic+plot.predictY.Jointlcmm'></span><span id='topic+plot.predictY.multlcmm'></span><span id='topic+plot.predictL.lcmm'></span><span id='topic+plot.predictL.Jointlcmm'></span><span id='topic+plot.predictL.multlcmm'></span><span id='topic+plot.predictlink.lcmm'></span><span id='topic+plot.predictlink.Jointlcmm'></span><span id='topic+plot.predictlink.multlcmm'></span><span id='topic+plot.predictlink'></span><span id='topic+plot.predictYcond'></span>

<h3>Description</h3>

<p>This function provides the class-specific predicted trajectories stemmed
from a <code>hlme</code>, <code>lcmm</code>, <code>multlcmm</code> or <code>Jointlcmm</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'predictL'
plot(x, legend.loc = "topright", legend, add = FALSE, shades = FALSE, ...)

## S3 method for class 'predictY'
plot(
  x,
  outcome = 1,
  legend.loc = "topright",
  legend,
  add = FALSE,
  shades = FALSE,
  ...
)

## S3 method for class 'predictYcond'
plot(x, legend.loc = "topleft", legend, add = FALSE, shades = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.predict_+3A_x">x</code></td>
<td>
<p>an object inheriting from classes <code>predictL</code>, <code>predictY</code>
or <code>predictlink</code> representing respectively the predicted marginal mean
trajectory of the latent process, the predicted marginal mean trajectory of
the longitudinal outcome, or the predicted link function of a fitted latent
class model.</p>
</td></tr>
<tr><td><code id="plot.predict_+3A_legend.loc">legend.loc</code></td>
<td>
<p>keyword for the position of the legend from the list
<code>"bottomright"</code>, <code>"bottom"</code>, <code>"bottomleft"</code>, <code>"left"</code>,
<code>"topleft"</code>,<code>"top"</code>, <code>"topright"</code>, <code>"right"</code> and
<code>"center"</code>.</p>
</td></tr>
<tr><td><code id="plot.predict_+3A_legend">legend</code></td>
<td>
<p>character or expression to appear in the legend. If no legend
should be added, <code>"legend"</code> should be NULL.</p>
</td></tr>
<tr><td><code id="plot.predict_+3A_add">add</code></td>
<td>
<p>logical indicating if the curves should be added to an existing
plot. Default to FALSE.</p>
</td></tr>
<tr><td><code id="plot.predict_+3A_shades">shades</code></td>
<td>
<p>logical indicating if confidence intervals should be
represented with shades. Default to FALSE, the confidence intervals are
represented with dotted lines.</p>
</td></tr>
<tr><td><code id="plot.predict_+3A_...">...</code></td>
<td>
<p>other parameters to be passed through to plotting functions or
to legend</p>
</td></tr>
<tr><td><code id="plot.predict_+3A_outcome">outcome</code></td>
<td>
<p>for <code>predictY</code> and multivariate model fitted with
<code>multlcmm</code> only, the outcome to consider.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cecile Proust-Lima, Benoit Liquet and Viviane Philipps
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hlme">hlme</a></code>, <code><a href="#topic+lcmm">lcmm</a></code>, <code><a href="#topic+Jointlcmm">Jointlcmm</a></code>,
<code><a href="#topic+multlcmm">multlcmm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

################# Prediction from linear latent class model
## fitted model
m&lt;-lcmm(Y~Time*X1,mixture=~Time,random=~Time,classmb=~X2+X3,
subject='ID',ng=2,data=data_hlme,B=c(0.41,0.55,-0.18,-0.41,
-14.26,-0.34,1.33,13.51,24.65,2.98,1.18,26.26,0.97))
## newdata for predictions plot
newdata&lt;-data.frame(Time=seq(0,5,length=100),
X1=rep(0,100),X2=rep(0,100),X3=rep(0,100))
plot(predictL(m,newdata,var.time="Time"),legend.loc="right",bty="l")
## data from the first subject for predictions plot
firstdata&lt;-data_hlme[1:3,]
plot(predictL(m,firstdata,var.time="Time"),legend.loc="right",bty="l")

 ## Not run: 
################# Prediction from a joint latent class model
## fitted model - see help of Jointlcmm function for details on the model
m3 &lt;- Jointlcmm(fixed= Ydep1~Time*X1,mixture=~Time,random=~Time,
classmb=~X3,subject='ID',survival = Surv(Tevent,Event)~X1+mixture(X2),
hazard="3-quant-splines",hazardtype="PH",ng=3,data=data_lcmm,
B=c(0.7576, 0.4095, -0.8232, -0.2737, 0, 0, 0, 0.2838, -0.6338, 
2.6324, 5.3963, -0.0273, 1.398, 0.8168, -15.041, 10.164, 10.2394, 
11.5109, -2.6219, -0.4553, -0.6055, 1.473, -0.0383, 0.8512, 0.0389, 
0.2624, 1.4982))
# class-specific predicted trajectories 
#(with characteristics of subject ID=193)
data &lt;- data_lcmm[data_lcmm$ID==193,]
plot(predictY(m3,newdata=data,var.time="Time"),bty="l")

## End(Not run)

</code></pre>

<hr>
<h2 id='postprob'>Posterior classification stemmed from a <code>hlme</code>, <code>lcmm</code>,
<code>multlcmm</code> or <code>Jointlcmm</code> estimation</h2><span id='topic+postprob'></span><span id='topic+postprob.hlme'></span><span id='topic+postprob.lcmm'></span><span id='topic+postprob.Jointlcmm'></span><span id='topic+postprob.multlcmm'></span><span id='topic+postprob.mpjlcmm'></span><span id='topic+postprob.externSurv'></span><span id='topic+postprob.externX'></span>

<h3>Description</h3>

<p>This function provides informations about the posterior classification
stemmed from a <code>hlme</code>, <code>lcmm</code>, <code>multlcmm</code>, <code>Jointlcmm</code>,
<code>mpjlcmm</code>, <code>externSurv</code> or <code>externX</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>postprob(x, threshold = c(0.7, 0.8, 0.9), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="postprob_+3A_x">x</code></td>
<td>
<p>an object inheriting from classes <code>hlme</code>, <code>lcmm</code>,
<code>Jointlcmm</code> or <code>multlcmm</code> representing respectively a fitted
latent class linear mixed-effects model, a more general latent class mixed
model, a joint latent class model or a multivariate general latent class
mixed model.</p>
</td></tr>
<tr><td><code id="postprob_+3A_threshold">threshold</code></td>
<td>
<p>optional vector of thresholds for the posterior
probabilities</p>
</td></tr>
<tr><td><code id="postprob_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.  They
are ignored in this function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides the number of subjects classified a posteriori in
each latent class, the percentage of subjects classified with a posterior
probability above a certain threshold, and the classification table that
contains the mean of the posterior probability of belonging to each latent
class over the subjects classified in each of the latent classes. This table
aims at evaluating the quality of the posterior classification.  For
<code>hlme</code>, <code>lcmm</code> objects, the posterior classification and the
classification table are derived from the posterior class-membership
probabilities given the vector of repeated measures that are contained in
pprob output matrix. For a <code>Jointlcmm</code> object, the first posterior
classification and the classification table are derived from the posterior
class-membership probabilities given the vector of repeated measures and the
time-to-event information (that are contained in columns probYT1, probYT2,
etc in pprob output matrix). The second posterior classification is derived
from the posterior class-membership probabilities given only the vector of
repeated measures (that are contained in columns probY1, probY2, etc in
pprob output matrix).
</p>


<h3>Value</h3>

<p>A list containing the posterior classification, the posterior
classification table and the percentage of subjects classified with a
posterior probability above the given thresholds.
</p>


<h3>Note</h3>

<p>This function can only be used with latent class mixed models and
joint latent class mixed models that include at least 2 latent classes
</p>


<h3>Author(s)</h3>

<p>Cecile Proust-Lima, Benoit Liquet and Viviane Philipps
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Jointlcmm">Jointlcmm</a></code>, <code><a href="#topic+lcmm">lcmm</a></code>, 
<code><a href="#topic+hlme">hlme</a></code>, <code><a href="#topic+plot.lcmm">plot.lcmm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

m&lt;-lcmm(Y~Time*X1,mixture=~Time,random=~Time,classmb=~X2+X3,
subject='ID',ng=2,data=data_hlme,B=c(0.41,0.55,-0.18,-0.41,
-14.26,-0.34,1.33,13.51,24.65,2.98,1.18,26.26,0.97))
postprob(m)


</code></pre>

<hr>
<h2 id='predictClass'>Posterior classification and class-membership probabilities</h2><span id='topic+predictClass'></span>

<h3>Description</h3>

<p>This function provides the posterior classification and posterior individual 
class-membership probabilities for external data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictClass(model, newdata, subject = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predictClass_+3A_model">model</code></td>
<td>
<p>an object inheriting from class <code>hlme</code>, <code>lcmm</code>, 
<code>Jointlcmm</code> or <code>multlcmm</code> representing a general latent class
mixed model.</p>
</td></tr>
<tr><td><code id="predictClass_+3A_newdata">newdata</code></td>
<td>
<p>data frame containing the data from which predictions are to be computed.
The data frame should include at least all the covariates listed in model$Xnames2,
the outcome(s) and the grouping structure. Names should match exactly.</p>
</td></tr>
<tr><td><code id="predictClass_+3A_subject">subject</code></td>
<td>
<p>character specifying the name of the grouping structure.
If NULL (the default), the same as in the model will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with 2+ng columns: the grouping structure, the predicted class and the
ng posterior class-membership probabilities.
</p>


<h3>Author(s)</h3>

<p>Sasha Cuau, Viviane Philipps, Cecile Proust-Lima
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(NormPsy)
paquid$normMMSE &lt;- normMMSE(paquid$MMSE)
paquid$age65 &lt;- (paquid$age - 65)/10
m2b &lt;- hlme(normMMSE ~ age65+I(age65^2)+CEP, random =~ age65+I(age65^2), subject = 'ID',
data = paquid, ng = 2, mixture =~ age65+I(age65^2), B = c(0, 60, 40, 0, -4, 0, -10, 10,
212.869397, -216.421323,456.229910, 55.713775, -145.715516, 59.351000, 10.072221))
predictClass(m2b, newdata=paquid[1:6,])

## End(Not run)
</code></pre>

<hr>
<h2 id='predictL'>Class-specific marginal predictions in the latent process scale for
<code>lcmm</code>, <code>Jointlcmm</code> and <code>multlcmm</code> objects</h2><span id='topic+predictL'></span><span id='topic+predictL.lcmm'></span><span id='topic+predictL.multlcmm'></span><span id='topic+predictL.Jointlcmm'></span>

<h3>Description</h3>

<p>This function provides a matrix containing the class-specific predicted
trajectories computed in the latent process scale, that is the latent
process underlying the curvilinear outcome(s), for a profile of covariates
specified by the user. This function applies only to <code>lcmm</code> and
<code>multlcmm</code> objects. The function <code>plot.predict</code> provides directly
the plot of these class-specific predicted trajectories. The function
<code>predictY</code> provides the class-specific predicted trajectories computed
in the natural scale of the outcome(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictL(x, newdata, var.time, na.action = 1, confint = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predictL_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code>lcmm</code>,<code>multlcmm</code> or
<code>Jointlcmm</code> representing a (joint) (latent class) mixed model involving
a latent process and estimated link function(s).</p>
</td></tr>
<tr><td><code id="predictL_+3A_newdata">newdata</code></td>
<td>
<p>data frame containing the data from which predictions are
computed. The data frame should include at least all the covariates listed
in x$Xnames2. Names in the data frame should be exactly x$Xnames2 that are
the names of covariates specified in <code>lcmm</code> or <code>multlcmm</code> calls.</p>
</td></tr>
<tr><td><code id="predictL_+3A_var.time">var.time</code></td>
<td>
<p>A character string containing the name of the variable that
corresponds to time in the data frame (x axis in the plot).</p>
</td></tr>
<tr><td><code id="predictL_+3A_na.action">na.action</code></td>
<td>
<p>Integer indicating how NAs are managed. The default is 1
for 'na.omit'. The alternative is 2 for 'na.fail'. Other options such as
'na.pass' or 'na.exclude' are not implemented in the current version.</p>
</td></tr>
<tr><td><code id="predictL_+3A_confint">confint</code></td>
<td>
<p>logical indicating if confidence should be provided. Default
to FALSE.</p>
</td></tr>
<tr><td><code id="predictL_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.  They
are ignored in this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>predictL</code> with values :
</p>
<p>- <code>pred</code> : a matrix containing the class-specific predicted values in
the latent process scale, the lower and the upper limits of the confidence
intervals (if calculated).
</p>
<p>- <code>times</code> : the <code>var.time</code> variable from <code>newdata</code>
</p>


<h3>Author(s)</h3>

<p>Cecile Proust-Lima, Viviane Philipps
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.predict">plot.predict</a></code>, <code><a href="#topic+predictY">predictY</a></code>,
<code><a href="#topic+lcmm">lcmm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### Prediction from a 2-class model with a Splines link function
## Not run: 
## fitted model
m&lt;-lcmm(Ydep2~Time*X1,mixture=~Time,random=~Time,classmb=~X2+X3,
subject='ID',ng=2,data=data_lcmm,link="splines",B=c(
-0.175,      -0.191,       0.654,      -0.443, 
-0.345,      -1.780,       0.913,       0.016, 
 0.389,       0.028,       0.083,      -7.349, 
 0.722,       0.770,       1.376,       1.653, 
 1.640,       1.285))
summary(m)
## predictions for times from 0 to 5 for X1=0
newdata&lt;-data.frame(Time=seq(0,5,length=100),
X1=rep(0,100),X2=rep(0,100),X3=rep(0,100))
predictL(m,newdata,var.time="Time")
## predictions for times from 0 to 5 for X1=1
newdata$X1 &lt;- 1
predictY(m,newdata,var.time="Time")

## End(Not run)

</code></pre>

<hr>
<h2 id='predictlink'>Confidence intervals for the estimated link functions from <code>lcmm</code>,
<code>Jointlcmm</code> and <code>multlcmm</code></h2><span id='topic+predictlink'></span><span id='topic+predictlink.lcmm'></span><span id='topic+predictlink.multlcmm'></span><span id='topic+predictlink.Jointlcmm'></span>

<h3>Description</h3>

<p>This function provides 95% confidence intervals around the estimated
transformation given in estimlink attribute of <code>lcmm</code>, <code>Jointlcmm</code>
and <code>multlcmm</code> objects. It can also be used to evaluate the link
functions at other values than those given in attribute <code>estimlink</code> of
<code>lcmm</code>, <code>Jointlcmm</code> or <code>multlcmm</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictlink(x, ndraws, Yvalues, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predictlink_+3A_x">x</code></td>
<td>
<p>an object inheriting from classes <code>lcmm</code>, <code>Jointlcmm</code> or
<code>multlcmm</code>.</p>
</td></tr>
<tr><td><code id="predictlink_+3A_ndraws">ndraws</code></td>
<td>
<p>the number of draws that should be generated to approximate
the posterior distribution of the transformed values. By default,
ndraws=2000.</p>
</td></tr>
<tr><td><code id="predictlink_+3A_yvalues">Yvalues</code></td>
<td>
<p>a vector (for a <code>lcmm</code> or <code>Jointlcmm</code> object) or a
matrix (for a <code>multlcmm</code> object) containing the values at which to
compute the transformation(s). Default to the values in <code>x$estimlink</code>.</p>
</td></tr>
<tr><td><code id="predictlink_+3A_...">...</code></td>
<td>
<p>other parameters (ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>predictlink</code> with values :
</p>
<p>- <code>pred</code> :
</p>
<p>For a <code>lcmm</code> or <code>Jointlcmm</code> object, a data frame containing the
values at which the transformation is evaluated, the transformed values and
the lower and the upper limits of the confidence intervals (if ndraws&gt;0).
</p>
<p>For a <code>multlcmm</code> object, a data frame containing the indicator of the
outcome, the values at which the transformations are evaluated,the
transformed values and the lower and the upper limits of the confidence
intervals (if ndraws&gt;0).
</p>
<p>- <code>object</code> : the object from which the link function is predicted
</p>


<h3>Author(s)</h3>

<p>Cecile Proust-Lima and Viviane Philipps
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lcmm">lcmm</a></code>, <code><a href="#topic+multlcmm">multlcmm</a></code>,
<code><a href="#topic+plot.lcmm">plot.lcmm</a></code>, <code><a href="#topic+plot.predictlink">plot.predictlink</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 ## Not run: 

## Univariate mixed model with splines link funciton
m14&lt;-lcmm(Ydep2~Time+I(Time^2),random=~Time,subject='ID',ng=1,
data=data_lcmm,link="5-manual-splines",intnodes=c(10,20,25),
B=c(-0.89255, -0.09715, 0.56335, 0.21967, 0.61937, -7.90261, 0.75149, 
-1.22357, 1.55832, 1.75324, 1.33834, 1.0968))

##Transformed values of several scores and their confidence intervals
transf.m14 &lt;- predictlink(m14,ndraws=2000,Yvalues=c(0,1,7:30))
plot(transf.m14)


## Multivariate mixed model with splines link functions
m1 &lt;- multlcmm(Ydep1+Ydep2~1+Time*X2+contrast(X2),random=~1+Time,
subject="ID",randomY=TRUE,link=c("4-manual-splines","3-manual-splines"),
intnodes=c(8,12,25),data=data_lcmm,
B=c(-1.071, -0.192,  0.106, -0.005, -0.193,  1.012,  0.870,  0.881,
  0.000,  0.000, -7.520,  1.401,  1.607 , 1.908,  1.431,  1.082,
 -7.528,  1.135 , 1.454 , 2.328, 1.052))
##Confidence intervals for the transformed values (given in m1$estimlink)
transf.m1 &lt;- predictlink(m1,ndraws=200)
plot(transf.m1)

## End(Not run)

</code></pre>

<hr>
<h2 id='predictRE'>Predictions of the random-effects</h2><span id='topic+predictRE'></span>

<h3>Description</h3>

<p>The function computes the predicted values of the random effects given observed data
provided in input. With multiple latent classes, these predictions are averaged over 
classes using the posterior class-membership probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictRE(model, newdata, subject = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predictRE_+3A_model">model</code></td>
<td>
<p>an object inheriting from class <code>hlme</code>, <code>lcmm</code>, 
<code>Jointlcmm</code> or <code>multlcmm</code> representing a general latent class
mixed model.</p>
</td></tr>
<tr><td><code id="predictRE_+3A_newdata">newdata</code></td>
<td>
<p>data frame containing the data from which predictions are to be computed. 
The data frame should include at least all the covariates listed in model$Xnames2, 
the marker(s) values and the grouping structure. Names should match exactly the names 
of the variables in the model.</p>
</td></tr>
<tr><td><code id="predictRE_+3A_subject">subject</code></td>
<td>
<p>character specifying the name of the grouping structure.
If NULL (the default), the same as in the model will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix containing the grouping structure and the predicted random-effects.
</p>


<h3>Author(s)</h3>

<p>Sasha Cuau, Viviane Philipps, Cecile Proust-Lima
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(NormPsy)
paquid$normMMSE &lt;- normMMSE(paquid$MMSE)
paquid$age65 &lt;- (paquid$age - 65)/10
m2b &lt;- hlme(normMMSE ~ age65+I(age65^2)+CEP, random =~ age65+I(age65^2), subject = 'ID',
data = paquid, ng = 2, mixture =~ age65+I(age65^2), B = c(0, 60, 40, 0, -4, 0, -10, 10,
212.869397, -216.421323,456.229910, 55.713775, -145.715516, 59.351000, 10.072221))
predictRE(m2b,newdata=paquid[1:6,])

## End(Not run)
</code></pre>

<hr>
<h2 id='predictY'>Predictions (marginal and possibly subject-specific in some cases) of a <code>hlme</code>,
<code>lcmm</code>, <code>multlcmm</code> or <code>Jointlcmm</code> object in the natural scale
of the longitudinal outcome(s) computed from a profile of covariates (marginal) or
individual data (subject specific in case of <code>hlme</code>).</h2><span id='topic+predictY'></span><span id='topic+predictY.Jointlcmm'></span><span id='topic+predictY.hlme'></span><span id='topic+predictY.lcmm'></span><span id='topic+predictY.multlcmm'></span>

<h3>Description</h3>

<p>For <code>hlme</code> and <code>Jointlcmm</code> objects, the function computes the
predicted values of the longitudinal marker (in each latent class of ng&gt;1) for a
specified profile of covariates.  For <code>lcmm</code> and <code>multlcmm</code>
objects, the function computes predicted values in the natural scale of the
outcomes for a specified profile of covariates. For linear and threshold
links, the predicted values are computed analytically. For splines and Beta
links, a Gauss-Hermite or Monte-Carlo integration are used to numerically
compute the predictions. In addition, for any type of link function,
confidence bands (and median) can be computed by a Monte Carlo approximation
of the posterior distribution of the predicted values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Jointlcmm'
predictY(
  x,
  newdata,
  var.time,
  methInteg = 0,
  nsim = 20,
  draws = FALSE,
  ndraws = 2000,
  na.action = 1,
  ...
)

## S3 method for class 'hlme'
predictY(
  x,
  newdata,
  var.time,
  draws = FALSE,
  na.action = 1,
  marg = TRUE,
  subject = NULL,
  ...
)

## S3 method for class 'lcmm'
predictY(
  x,
  newdata,
  var.time,
  methInteg = 0,
  nsim = 20,
  draws = FALSE,
  ndraws = 2000,
  na.action = 1,
  ...
)

predictY(x, newdata, var.time, ...)

## S3 method for class 'multlcmm'
predictY(
  x,
  newdata,
  var.time,
  methInteg = 0,
  nsim = 20,
  draws = FALSE,
  ndraws = 2000,
  na.action = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predictY_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code>lcmm</code>, <code>hlme</code>,
<code>Jointlcmm</code> or <code>multlcmm</code> representing a general latent class
mixed model.</p>
</td></tr>
<tr><td><code id="predictY_+3A_newdata">newdata</code></td>
<td>
<p>data frame containing the data from which predictions are to be
computed. The data frame should include at least all the covariates listed
in x$Xnames2. Names in the data frame should be exactly x$Xnames2 that are
the names of covariates specified in <code>lcmm</code>, <code>hlme</code>,
<code>Jointlcmm</code> or <code>multlcmm</code> calls. For <code>hlme</code> object and marg=FALSE,
the grouping structure and values for the outcome should also be specified.</p>
</td></tr>
<tr><td><code id="predictY_+3A_var.time">var.time</code></td>
<td>
<p>A character string containing the name of the variable that
corresponds to time in the data frame (x axis in the plot).</p>
</td></tr>
<tr><td><code id="predictY_+3A_methinteg">methInteg</code></td>
<td>
<p>optional integer specifying the type of numerical
integration required only for predictions with splines or Beta link
functions. Value 0 (by default) specifies a Gauss-Hermite integration which
is very rapid but neglects the correlation between the predicted values (in
presence of random-effects). Value 1 refers to a Monte-Carlo integration
which is slower but correctly account for the correlation between the
predicted values.</p>
</td></tr>
<tr><td><code id="predictY_+3A_nsim">nsim</code></td>
<td>
<p>For a <code>lcmm</code>, <code>multlcmm</code> or <code>Jointlcmm</code> object
only; optional number of points used in the numerical integration with
splines or Beta link functions. For methInteg=0, nsim should be chosen among
the following values: 5, 7, 9, 15, 20, 30, 40 or 50 (nsim=20 by default). If
methInteg=1, nsim should be relatively important (more than 200).</p>
</td></tr>
<tr><td><code id="predictY_+3A_draws">draws</code></td>
<td>
<p>optional boolean specifying whether median and confidence bands
of the predicted values should be computed (TRUE) - whatever the type of
link function. For a <code>lcmm</code>, <code>multlcmm</code> or <code>Jointlcmm</code>
object, a Monte Carlo approximation of the posterior distribution of the
predicted values is computed and the median, 2.5% and 97.5% percentiles
are given. Otherwise, the predicted values are computed at the point
estimate. By default, draws=FALSE.</p>
</td></tr>
<tr><td><code id="predictY_+3A_ndraws">ndraws</code></td>
<td>
<p>For a <code>lcmm</code>, <code>multlcmm</code> or <code>Jointlcmm</code> object
only; if draws=TRUE, ndraws specifies the number of draws that should be
generated to approximate the posterior distribution of the predicted values.
By default, ndraws=2000.</p>
</td></tr>
<tr><td><code id="predictY_+3A_na.action">na.action</code></td>
<td>
<p>Integer indicating how NAs are managed. The default is 1
for 'na.omit'. The alternative is 2 for 'na.fail'. Other options such as
'na.pass' or 'na.exclude' are not implemented in the current version.</p>
</td></tr>
<tr><td><code id="predictY_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods. 
Only the argument 'median' will be used, other are ignored. 'median' should
be a logical indicating whether the median should be computed. By 
default, the mean value is computed.</p>
</td></tr>
<tr><td><code id="predictY_+3A_marg">marg</code></td>
<td>
<p>Optional boolean specifying whether the
predictions are marginal (the default) or subject-specific (marg=FALSE). marge=FALSE 
only works with <code>hlme</code> objects.</p>
</td></tr>
<tr><td><code id="predictY_+3A_subject">subject</code></td>
<td>
<p>For a <code>hlme</code> object with marg=FALSE only, character specifying
the name of the grouping strucuture. If NULL (the default), the same as in the model
(argument x) will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>predictY</code> with values :
</p>
<p>- <code>pred</code> : a matrix with the same rows (number and order) as in
newdata.
</p>
<p>For <code>hlme</code> objects and <code>lcmm</code> or <code>Jointlcmm</code> with
<code>draws=FALSE</code>, returns a matrix with ng columns corresponding to the ng
class-specific vectors of predicted values computed at the point estimate
</p>
<p>For objects of class <code>lcmm</code> or <code>Jointlcmm</code> with <code>draws=TRUE</code>,
returns a matrix with ng*3 columns representing the ng class-specific 50%,
2.5% and 97.5% percentiles of the approximated posterior distribution of
the class-specific predicted values.
</p>
<p>For objects of class <code>multlcmm</code> with <code>draws=FALSE</code>, returns a
matrix with ng+1 columns: the first column indicates the name of the outcome
which is predicted and the ng subsequent columns correspond to the ng
class-specific vectors of predicted values computed at the point estimate
</p>
<p>For objects of class <code>multlcmm</code> with <code>draws=TRUE</code>, returns a
matrix with ng*3+1 columns: the first column indicates the name of the
outcome which is predicted and the ng*3 subsequent columns correspond to the
ng class-specific 50%, 2.5% and 97.5% percentiles of the approximated
posterior distribution of the class-specific predicted values.
</p>
<p>For objects of class <code>hlme</code> with <code>marg=FALSE</code>, returns a matrix
with 2+ng columns : the grouping structure, subject-specific predictions (pred_ss) averaged 
over classes and the class-specific subject-specific predictions (with the
number of the latent class: pred_ss_1,pred_ss_2,...)
</p>
<p>- <code>times</code> : the <code>var.time</code> variable from <code>newdata</code>
</p>


<h3>Author(s)</h3>

<p>Cecile Proust-Lima, Viviane Philipps, Sasha Cuau
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lcmm">lcmm</a></code>, <code><a href="#topic+multlcmm">multlcmm</a></code>, <code><a href="#topic+hlme">hlme</a></code>,
<code><a href="#topic+Jointlcmm">Jointlcmm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#### Prediction from a 2-class model with a Splines link function
## Not run: 
## fitted model
m&lt;-lcmm(Ydep2~Time*X1,mixture=~Time,random=~Time,classmb=~X2+X3,
subject='ID',ng=2,data=data_lcmm,link="splines",B=c(
-0.175,      -0.191,       0.654,      -0.443, 
-0.345,      -1.780,       0.913,       0.016, 
 0.389,       0.028,       0.083,      -7.349, 
 0.722,       0.770,       1.376,       1.653, 
 1.640,       1.285))
summary(m)
## predictions for times from 0 to 5 for X1=0
newdata&lt;-data.frame(Time=seq(0,5,length=100),
X1=rep(0,100),X2=rep(0,100),X3=rep(0,100))
pred0 &lt;- predictY(m,newdata,var.time="Time")
head(pred0)
## Option draws=TRUE to compute a MonteCarlo 
# approximation of the predicted value distribution 
# (quite long with ndraws=2000 by default)
\dontrun{
pred0MC &lt;- predictY(m,newdata,draws=TRUE,var.time="Time")
}
## predictions for times from 0 to 5 for X1=1
newdata$X1 &lt;- 1
pred1 &lt;- predictY(m,newdata,var.time="Time")
## Option draws=TRUE to compute a MonteCarlo 
# approximation of the predicted value distribution 
# (quite long with ndraws=2000 by default)
\dontrun{
pred1MC &lt;- predictY(m,newdata,draws=TRUE,var.time="Time")
}

## End(Not run)

</code></pre>

<hr>
<h2 id='predictYback'>Marginal predictions in the natural scale of a pre-transformed outcome</h2><span id='topic+predictYback'></span>

<h3>Description</h3>

<p>The function computes the predicted values of the longitudinal marker
(in each latent class if ng&gt;1) for a specified profile of covariates, when a
non-parameterized pre-transformation was applied (e.g., log, square root). 
A Gauss-Hermite or Monte-Carlo integration is 
used to numerically compute the back-transformed predictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictYback(
  x,
  newdata,
  var.time,
  methInteg = 0,
  nsim = 20,
  draws = FALSE,
  ndraws = 2000,
  na.action = 1,
  back,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predictYback_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code>hlme</code> representing a general 
latent class mixed model.</p>
</td></tr>
<tr><td><code id="predictYback_+3A_newdata">newdata</code></td>
<td>
<p>data frame containing the data from which predictions are to 
be computed. The data frame should include at least all the covariates listed
in x$Xnames2. Names in the data frame should be exactly x$Xnames2, i.e., 
the names of covariates specified in <code>hlme</code> calls.</p>
</td></tr>
<tr><td><code id="predictYback_+3A_var.time">var.time</code></td>
<td>
<p>A character string containing the name of the variable that
corresponds to time in the data frame (x axis in the plot).</p>
</td></tr>
<tr><td><code id="predictYback_+3A_methinteg">methInteg</code></td>
<td>
<p>optional integer specifying the type of numerical
integration. Value 0 (by default) specifies a Gauss-Hermite integration which
is very rapid but neglects the correlation between the predicted values (in
presence of random-effects). Value 1 refers to a Monte-Carlo integration
which is slower but correctly accounts for the correlation between the
predicted values.</p>
</td></tr>
<tr><td><code id="predictYback_+3A_nsim">nsim</code></td>
<td>
<p>number of points used in the numerical integration.
For methInteg=0, nsim should be chosen among
the following values: 5, 7, 9, 15, 20, 30, 40 or 50 (nsim=20 by default). If
methInteg=1, nsim should be relatively important (more than 200).</p>
</td></tr>
<tr><td><code id="predictYback_+3A_draws">draws</code></td>
<td>
<p>boolean specifying whether confidence bands should be computed.
If draws=TRUE, a Monte Carlo approximation of the posterior distribution of 
the predicted values is computed and the median, 2.5% and 97.5% percentiles
are given. Otherwise, the predicted values are computed at the point
estimate. By default, draws=FALSE.</p>
</td></tr>
<tr><td><code id="predictYback_+3A_ndraws">ndraws</code></td>
<td>
<p>integer. If draws=TRUE, ndraws specifies the number of draws 
that should be generated to approximate the posterior distribution of the 
predicted values. By default, ndraws=2000.</p>
</td></tr>
<tr><td><code id="predictYback_+3A_na.action">na.action</code></td>
<td>
<p>Integer indicating how NAs are managed. The default is 1
for 'na.omit'. The alternative is 2 for 'na.fail'. Other options such as
'na.pass' or 'na.exclude' are not implemented in the current version.</p>
</td></tr>
<tr><td><code id="predictYback_+3A_back">back</code></td>
<td>
<p>function to back-transform the outcome in the original scale.</p>
</td></tr>
<tr><td><code id="predictYback_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods. They
are ignored in this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>predictY</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data_lcmm$transfYdep2 &lt;- sqrt(30 - data_lcmm$Ydep2)
m1 &lt;- hlme(transfYdep2 ~ Time, random=~ Time, subject="ID", data = data_lcmm)
pred1 &lt;- predictYback(m1, newdata = data.frame(Time = seq(0, 3, 0.1)), 
var.time = "Time", back = function(x) {30 - x^2})
plot(pred1)

</code></pre>

<hr>
<h2 id='predictYcond'>Conditional predictions of a <code>lcmm</code>, <code>multlcmm</code> or <code>Jointlcmm</code>
object in the natural scale of the longitudinal outcome(s) for specified
latent process values.</h2><span id='topic+predictYcond'></span>

<h3>Description</h3>

<p>The function computes the predicted values of the longitudinal markers in their
natural scale for specified values of the latent process. For splines and Beta
links, a Gauss-Hermite integration is used to numerically compute the predictions.
In addition, for any type of link function, confidence bands (and median) can be
computed by a Monte Carlo approximation of the posterior distribution of the
predicted values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictYcond(
  x,
  lprocess,
  condRE_Y = FALSE,
  nsim = 200,
  draws = FALSE,
  ndraws = 2000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predictYcond_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code>lcmm</code>, 
<code>Jointlcmm</code> or <code>multlcmm</code> representing a general latent class
mixed model.</p>
</td></tr>
<tr><td><code id="predictYcond_+3A_lprocess">lprocess</code></td>
<td>
<p>numeric vector containing the latent process values at which the
predictions should be computed.</p>
</td></tr>
<tr><td><code id="predictYcond_+3A_condre_y">condRE_Y</code></td>
<td>
<p>for multlcmm objects only, logical indicating if the predictions
are conditional to the outcome specific random effects or not. Default to FALSE,
the predictions are marginal to these random effects.</p>
</td></tr>
<tr><td><code id="predictYcond_+3A_nsim">nsim</code></td>
<td>
<p>number of points used in the numerical integration (Monte-Carlo) with
splines or Beta link functions. nsim should be relatively important
(nsim=200 by default).</p>
</td></tr>
<tr><td><code id="predictYcond_+3A_draws">draws</code></td>
<td>
<p>optional boolean specifying whether median and confidence bands
of the predicted values should be computed (TRUE) - whatever the type of
link function. A Monte Carlo approximation of the posterior distribution of the
predicted values is computed and the median, 2.5% and 97.5% percentiles
are given. Otherwise, the predicted values are computed at the point
estimate. By default, draws=FALSE.</p>
</td></tr>
<tr><td><code id="predictYcond_+3A_ndraws">ndraws</code></td>
<td>
<p>if draws=TRUE, ndraws specifies the number of draws that should be
generated to approximate the posterior distribution of the predicted values.
By default, ndraws=2000.</p>
</td></tr>
<tr><td><code id="predictYcond_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.  They
are ignored in this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>predictYcond</code> with values :
</p>
<p>- <code>pred</code> : 
If draws=FALSE, returns a matrix with 3 columns : the first column indicates the
name of the outcome, the second indicates the latent process value and the last
is the computed prediction.
If draws=TRUE, returns a matrix with 5 columns : the name of the outcome, the
latent process value and the 50%, 2.5% and 97.5% percentiles of the approximated
posterior distribution of predicted values.
</p>
<p>- <code>object</code> : the model from which the predictions are computed.
</p>


<h3>Author(s)</h3>

<p>Cecile Proust-Lima, Viviane Philipps
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predictY">predictY</a></code>, <code><a href="#topic+predictlink">predictlink</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
m12 &lt;- lcmm(Ydep2~Time+I(Time^2),random=~Time,subject='ID',ng=1,
data=data_lcmm,link="3-equi-splines")
predm12 &lt;- predictYcond(m12,lprocess=seq(-8,2,length.out=100),draws=TRUE)
plot(predm12)

## End(Not run)

</code></pre>

<hr>
<h2 id='print.lcmm'>Brief summary of a <code>hlme</code>, <code>lcmm</code>,
<code>Jointlcmm</code>,<code>multlcmm</code>, <code>epoce</code> or <code>Diffepoce</code> objects</h2><span id='topic+print.lcmm'></span><span id='topic+print.hlme'></span><span id='topic+print.Jointlcmm'></span><span id='topic+print.multlcmm'></span><span id='topic+print.epoce'></span><span id='topic+print.Diffepoce'></span><span id='topic+print.externSurv'></span><span id='topic+print.externX'></span><span id='topic+print.mpjlcmm'></span>

<h3>Description</h3>

<p>The function provides a brief summary of <code>hlme</code>,
<code>lcmm</code>,<code>multlcmm</code> or <code>Jointlcmm</code> estimations, and
<code>epoce</code> or <code>Diffepoce</code> computations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lcmm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.lcmm_+3A_x">x</code></td>
<td>
<p>an object inheriting from classes <code>hlme</code>, <code>lcmm</code>, <code>multlcmm</code>
for fitted latent class mixed-effects, or class <code>Jointlcmm</code>, <code>mpjclmm</code> for
a Joint latent class mixed model or <code>epoce</code> for predictive accuracy
computations or <code>externSurv</code>, <code>externX</code> for secondary regression models.</p>
</td></tr>
<tr><td><code id="print.lcmm_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.  They
are ignored in this function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Cecile Proust-Lima, Viviane Philipps, Amadou Diakite and Benoit
Liquet
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hlme">hlme</a></code>, <code><a href="#topic+lcmm">lcmm</a></code>, <code><a href="#topic+Jointlcmm">Jointlcmm</a></code>,
<code>epoce</code>, <code>Diffepoce</code>
</p>

<hr>
<h2 id='simdataHADS'>Simulated dataset simdataHADS</h2><span id='topic+simdataHADS'></span>

<h3>Description</h3>

<p>The data mimic the PREDIALA study described and analyzed in Proust-Lima et al (2021 - 
https://arxiv.org/abs/2109.13064). 
The study aims to describe the trajectories of depressive symptomatology of patients 
suffering end-stage renal disease and registered on the renal transplant waiting list.
Repeated measures of anxiety and depression (HADS) were simulated at different times
of measurement for 561 subjects. Four time-independent covariates were also generated: 
group (dialyzed or pre-emptive), sex and age at entry in the cohort and time on the 
waiting list at entry in the cohort.
</p>


<h3>Format</h3>

<p>A data frame with 1140 observations on the following 13 variables.
</p>

<dl>
<dt>grp</dt><dd><p>group with 0=dialyzed and 1=preemptive</p>
</dd>
<dt>sex</dt><dd><p>sex with 0=woman and 1=man</p>
</dd>
<dt>age</dt><dd><p>age at entry in the cohort</p>
</dd>
<dt>hads_2</dt><dd><p>item 2 of HADS measuring depression</p>
</dd>
<dt>hads_4</dt><dd><p>item 4 of HADS measuring depression</p>
</dd>
<dt>hads_6</dt><dd><p>item 6 of HADS measuring depression</p>
</dd>
<dt>hads_8</dt><dd><p>item 8 of HADS measuring depression</p>
</dd>
<dt>hads_10</dt><dd><p>item 10 of HADS measuring depression</p>
</dd>
<dt>hads_12</dt><dd><p>item 12 of HADS measuring depression</p>
</dd>
<dt>hads_14</dt><dd><p>item 14 of HADS measuring depression</p>
</dd>
<dt>ID</dt><dd><p>subject identification number</p>
</dd>
<dt>time</dt><dd><p>time of measurement</p>
</dd>
<dt>time_entry</dt><dd><p>time on the waiting list at entry in the cohort</p>
</dd>
</dl>


<hr>
<h2 id='simulate.lcmm'>Data simulation according to models from lcmm package</h2><span id='topic+simulate.lcmm'></span>

<h3>Description</h3>

<p>This function simulates a sample according to a model estimated with <code>hlme</code>,
<code>lcmm</code>, <code>multlcmm</code> or <code>Jointlcmm</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lcmm'
simulate(
  object,
  nsim,
  seed,
  times,
  tname = NULL,
  n,
  Xbin = NULL,
  Xcont = NULL,
  entry = 0,
  dropout = NULL,
  pMCAR = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate.lcmm_+3A_object">object</code></td>
<td>
<p>an object of class <code>hlme</code>, <code>lcmm</code>, <code>multlcmm</code> or
<code>Jointlcmm</code></p>
</td></tr>
<tr><td><code id="simulate.lcmm_+3A_nsim">nsim</code></td>
<td>
<p>not used (for compatibility with stats::simulate). The function simulates only one sample</p>
</td></tr>
<tr><td><code id="simulate.lcmm_+3A_seed">seed</code></td>
<td>
<p>the random seed</p>
</td></tr>
<tr><td><code id="simulate.lcmm_+3A_times">times</code></td>
<td>
<p>either a data frame with 2 columns containing IDs and measurement times, or a vector of length 4 specifying the minimal and maximum measurement times, the spacing between 2 consecutive visits and the margin around this spacing</p>
</td></tr>
<tr><td><code id="simulate.lcmm_+3A_tname">tname</code></td>
<td>
<p>the name of the variable representing the measurement times in <code>object</code>.
Default to the second column's name of times if it is a data frame, and to object$var.time otherwise.</p>
</td></tr>
<tr><td><code id="simulate.lcmm_+3A_n">n</code></td>
<td>
<p>number of subjects to simulate. Required only if times is not a data frame.</p>
</td></tr>
<tr><td><code id="simulate.lcmm_+3A_xbin">Xbin</code></td>
<td>
<p>an optional named list giving the probabilities of the binary
covariates to simulate. The list's names should match the binary covariate's names
used in <code>object</code>.</p>
</td></tr>
<tr><td><code id="simulate.lcmm_+3A_xcont">Xcont</code></td>
<td>
<p>an optional named list giving the mean and standard deviation
of the Gaussian covariates to simulate. The list's names should match the
continuous covariate's names used in <code>object</code>.</p>
</td></tr>
<tr><td><code id="simulate.lcmm_+3A_entry">entry</code></td>
<td>
<p>expression to simulate a subject's entry time. Default to 0.</p>
</td></tr>
<tr><td><code id="simulate.lcmm_+3A_dropout">dropout</code></td>
<td>
<p>expression to simulate a subject's time to dropout. Default to NULL,
no dropout is considered.</p>
</td></tr>
<tr><td><code id="simulate.lcmm_+3A_pmcar">pMCAR</code></td>
<td>
<p>optional numeric giving an observation's probability to be missing.
Default to 0, no missing data are introduced.</p>
</td></tr>
<tr><td><code id="simulate.lcmm_+3A_...">...</code></td>
<td>
<p>additionnal options. None is used yet.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with one line per observation and one column per variable. Variables appears in the following order : subject id, measurement time, entry time, binary covariates, continuous covariates, longitudinal outcomes, latent class, entry time, survival time, event indicator.
</p>


<h3>Author(s)</h3>

<p>Viviane Philipps and Cecile Proust-Lima
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## estimation of a 2 classes mixed model
m2 &lt;- hlme(Y~Time*X1,mixture=~Time,random=~Time,classmb=~X2+X3,subject='ID',
         ng=2,data=data_hlme,B=c(0.11,-0.74,-0.07,20.71,
                                 29.39,-1,0.13,2.45,-0.29,4.5,0.36,0.79,0.97))

## simulate according to model m2 with same number of subjects and
## same measurement times as in data_lcmm. Binary covariates X1 and X2 are simulated
## according to a Bernoulli distribution with probability p=0.5, continuous covariate
## X3 is simulated according to a Gaussian distribution with mean=1 and sd=1 :
dsim1 &lt;- simulate(m2, times=data_hlme[,c("ID","Time")],
                  Xbin=list(X1=0.5, X2=0.5), Xcont=list(X3=c(1,1)))

## simulate a dataset of 300 subjects according to the same model
## with new observation times, equally spaced and ranging from 0 to 3 :
dsim2 &lt;- simulate(m2, times=c(0,3,0.5,0), n=300, tname="Time",
                  Xbin=list(X1=0.5, X2=0.5), Xcont=list(X3=c(1,1)))



</code></pre>

<hr>
<h2 id='StandardMethods'>Standard methods for estimated models</h2><span id='topic+StandardMethods'></span><span id='topic+coef.hlme'></span><span id='topic+coef.lcmm'></span><span id='topic+coef.Jointlcmm'></span><span id='topic+coef.multlcmm'></span><span id='topic+coef.mpjlcmm'></span><span id='topic+coef.externSurv'></span><span id='topic+coef.externX'></span><span id='topic+vcov.hlme'></span><span id='topic+vcov.lcmm'></span><span id='topic+vcov.Jointlcmm'></span><span id='topic+vcov.multlcmm'></span><span id='topic+vcov.mpjlcmm'></span><span id='topic+vcov.externSurv'></span><span id='topic+vcov.externX'></span><span id='topic+fixef.hlme'></span><span id='topic+fixef.lcmm'></span><span id='topic+fixef.Jointlcmm'></span><span id='topic+fixef.multlcmm'></span><span id='topic+ranef.hlme'></span><span id='topic+ranef.lcmm'></span><span id='topic+ranef.Jointlcmm'></span><span id='topic+ranef.multlcmm'></span><span id='topic+fitted.hlme'></span><span id='topic+fitted.lcmm'></span><span id='topic+fitted.Jointlcmm'></span><span id='topic+fitted.multlcmm'></span><span id='topic+residuals.hlme'></span><span id='topic+residuals.lcmm'></span><span id='topic+residuals.Jointlcmm'></span><span id='topic+residuals.multlcmm'></span>

<h3>Description</h3>

<p>coef and vcov for hlme, lcmm, mutlcmm, Jointlcmm, mpjlcmm, externSurv, and externX
models, fixef, ranef, fitted and residuals methods for estimated hlme,
lcmm, mutlcmm and Jointlcmm models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hlme'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="StandardMethods_+3A_object">object</code></td>
<td>
<p>an object of class <code>hlme</code>, <code>lcmm</code>, <code>multlcmm</code>
or <code>Jointlcmm</code></p>
</td></tr>
<tr><td><code id="StandardMethods_+3A_...">...</code></td>
<td>
<p>other arguments. There are ignored in these functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>coef</code>, the vector of the estimates.
</p>
<p>For <code>vcov</code>, the variance-covariance matrix of the estimates.
</p>
<p>For <code>fixef</code> : - for <code>hlme</code>, <code>lcmm</code> and <code>multlcmm</code>
objects, a list containing the fixed effects estimates in the
class-membership model and in the longitudinal model.  - for
<code>Jointlcmm</code> objects, a list containing the fixed effects estimates in
the class-membership model, the survival model and in the longitudinal
model.
</p>
<p>For <code>ranef</code>, a matrix (nrow=number of subjects, ncol=number of
covariates with random effect) containing the individual random effects.
</p>
<p>For <code>fitted</code>, a vector containing the subject-specific predictions
extracted from <code>object</code>.
</p>
<p>For <code>residuals</code>, a vector containing the subject-specific residuals
extracted from <code>object</code>.
</p>


<h3>Author(s)</h3>

<p>Cecile Proust-Lima, Viviane Philipps
</p>

<hr>
<h2 id='summary.lcmm'>Summary of a <code>hlme</code>, <code>lcmm</code>, <code>Jointlcmm</code>, <code>multlcmm</code>,
<code>mpjlcmm</code>, <code>externSurv</code>, <code>externX</code>
<code>epoce</code> or <code>Diffepoce</code> objects</h2><span id='topic+summary.lcmm'></span><span id='topic+summary.hlme'></span><span id='topic+summary.Jointlcmm'></span><span id='topic+summary.multlcmm'></span><span id='topic+summary.epoce'></span><span id='topic+summary.Diffepoce'></span><span id='topic+summary.mpjlcmm'></span><span id='topic+summary.externSurv'></span><span id='topic+summary.externX'></span>

<h3>Description</h3>

<p>The function provides a summary of <code>hlme</code>, <code>lcmm</code>, <code>multlcmm</code>
and <code>Jointlcmm</code> estimations, or <code>epoce</code> and <code>Diffepoce</code>
computations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lcmm'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.lcmm_+3A_object">object</code></td>
<td>
<p>an object inheriting from classes <code>hlme</code>, <code>lcmm</code>,
<code>multlcmm</code> for fitted latent class mixed-effects, or class
<code>Jointlcmm</code>, <code>mpjlcmm</code> for a Joint latent class mixed model or <code>epoce</code> or
<code>Diffepoce</code> for predictive accuracy computations or <code>externSurv</code>, <code>externX</code>
for secondary regression models.</p>
</td></tr>
<tr><td><code id="summary.lcmm_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.  They
are ignored in this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>epoce</code> or <code>Diffepoce</code> objects, returns NULL. For
<code>hlme</code>, <code>lcmm</code>, <code>Jointlcmm</code> or <code>multlcmm</code> returns also a
matrix containing the fixed effect estimates in the longitudinal model,
their standard errors, Wald statistics and p-values
</p>


<h3>Author(s)</h3>

<p>Cecile Proust-Lima, Viviane Philipps, Amadou Diakite and Benoit
Liquet
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hlme">hlme</a></code>, <code><a href="#topic+lcmm">lcmm</a></code>, <code><a href="#topic+multlcmm">multlcmm</a></code>,
<code><a href="#topic+Jointlcmm">Jointlcmm</a></code>, <code>epoce</code>, <code>Diffepoce</code>
</p>

<hr>
<h2 id='summaryplot'>Summary of models</h2><span id='topic+summaryplot'></span>

<h3>Description</h3>

<p>This function provides a plot summarizing the results of different models
fitted by <code>hlme</code>, <code>lcmm</code>, <code>multlcmm</code>, <code>Jointlcmm</code>,
<code>mpjlcmm</code> or <code>externVar</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summaryplot(
  m1,
  ...,
  which = c("BIC", "entropy", "ICL"),
  mfrow = c(1, length(which)),
  xaxis = "G"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summaryplot_+3A_m1">m1</code></td>
<td>
<p>an object of class <code>hlme</code>, <code>lcmm</code>, <code>multlcmm</code>,
<code>Jointlcmm</code>, <code>mpjlcmm</code>, <code>externVar</code> or <code>externVar</code>.</p>
</td></tr>
<tr><td><code id="summaryplot_+3A_...">...</code></td>
<td>
<p>further arguments, in particular other objects of class
<code>hlme</code>, <code>lcmm</code>, <code>multlcmm</code>, <code>Jointlcmm</code> or <code>mpjlcmm</code>, and
graphical parameters.</p>
</td></tr>
<tr><td><code id="summaryplot_+3A_which">which</code></td>
<td>
<p>character vector indicating which results should be plotted.
Possible values are &quot;loglik&quot;, &quot;conv&quot;, &quot;npm&quot;, &quot;AIC&quot;, &quot;BIC&quot;, &quot;SABIC&quot;,
&quot;entropy&quot;, &quot;ICL&quot;, &quot;ICL1&quot;, &quot;ICL2&quot;.</p>
</td></tr>
<tr><td><code id="summaryplot_+3A_mfrow">mfrow</code></td>
<td>
<p>for multiple plots, number of rows and columns to split the graphical device.
Default to one line and length(which) columns.</p>
</td></tr>
<tr><td><code id="summaryplot_+3A_xaxis">xaxis</code></td>
<td>
<p>the abscissa of the plot. Default to &quot;G&quot;, the number of latent classes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Can be reported the usual criteria used to assess the fit and the clustering
of the data:
- maximum log-likelihood L (the higher the better)
- number of parameters P, number of classes G, convergence criterion (1 = converged)
- AIC (the lower the better) computed as -2L+2P 
- BIC (the lower the better) computed as -2L+ P log(N) where N is the number of subjects
- SABIC (the lower the better) computed as -2L+ P log((N+2)/24)
- Entropy (the closer to one the better) computed as 1+sum[pi_ig*log(pi_ig)]/(N*log(G))
where pi_ig is the posterior probability that subject i belongs to class g
- ICL (the lower the better) computed in two ways : ICL1 = BIC - sum[pi_ig*log(pi_ig)]
or ICL2 = BIC - 2*sum(log(max(pi_ig)), where the max is taken over the classes for each subject.
- %class computed as the proportion of each class based on c_ig
</p>


<h3>Author(s)</h3>

<p>Sasha Cuau, Viviane Philipps, Cecile Proust-Lima
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+summary">summary</a></code>, <code><a href="#topic+summarytable">summarytable</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(NormPsy)
paquid$normMMSE &lt;- normMMSE(paquid$MMSE)
paquid$age65 &lt;- (paquid$age - 65)/10
m1 &lt;- hlme(normMMSE~age65+I(age65^2)+CEP, random=~age65+I(age65^2), subject='ID', data=paquid)
m2 &lt;- hlme(normMMSE~age65+I(age65^2)+CEP, random=~age65+I(age65^2), subject='ID', data=paquid,
ng = 2, mixture=~age65+I(age65^2), B=m1)
m3g &lt;- gridsearch(hlme(normMMSE~age65+I(age65^2)+CEP, random=~age65+I(age65^2), subject='ID',
data=paquid, ng=3, mixture=~age65+I(age65^2)), rep=100, maxiter=30, minit=m1)
summaryplot(m1, m2, m3g, which=c("BIC","entropy","ICL"),bty="l",pch=20,col=2)

## End(Not run)
</code></pre>

<hr>
<h2 id='summarytable'>Summary of models</h2><span id='topic+summarytable'></span>

<h3>Description</h3>

<p>This function provides a table summarizing the results of different models
fitted by <code>hlme</code>, <code>lcmm</code>, <code>multlcmm</code>, <code>Jointlcmm</code>,
<code>mpjlcmm</code> or <code>externVar</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarytable(
  m1,
  ...,
  which = c("G", "loglik", "npm", "BIC", "%class"),
  display = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summarytable_+3A_m1">m1</code></td>
<td>
<p>an object of class <code>hlme</code>, <code>lcmm</code>, <code>multlcmm</code>, 
<code>Jointlcmm</code>, <code>mpjlcmm</code>, <code>externVar</code> or <code>externVar</code>.</p>
</td></tr>
<tr><td><code id="summarytable_+3A_...">...</code></td>
<td>
<p>further arguments, in particular other objects of class
<code>hlme</code>, <code>lcmm</code>, <code>multlcmm</code>, <code>Jointlcmm</code> or <code>mpjlcmm</code>.</p>
</td></tr>
<tr><td><code id="summarytable_+3A_which">which</code></td>
<td>
<p>character vector indicating which results should be returned.
Possible values are &quot;G&quot;, &quot;loglik&quot;, &quot;conv&quot;, &quot;npm&quot;, &quot;AIC&quot;, &quot;BIC&quot;, &quot;SABIC&quot;,
&quot;entropy&quot;, &quot;ICL&quot;, &quot;ICL1&quot;, &quot;ICL2&quot;, &quot;%class&quot;.</p>
</td></tr>
<tr><td><code id="summarytable_+3A_display">display</code></td>
<td>
<p>logical indicating whether the table should be printed (the default) or not (display=FALSE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Can be reported the usual criteria used to assess the fit and the clustering
of the data:
- maximum log-likelihood L (the higher the better)
- number of parameters P, number of classes G, convergence criterion (1 = converged)
- AIC (the lower the better) computed as -2L+2P 
- BIC (the lower the better) computed as -2L+ P log(N) where N is the number of subjects
- SABIC (the lower the better) computed as -2L+ P log((N+2)/24)
- Entropy (the closer to one the better) computed as 1+sum[pi_ig*log(pi_ig)]/(N*log(G))
where pi_ig is the posterior probability that subject i belongs to class g
- ICL (the lower the better) computed in two ways : ICL1 = BIC - sum[pi_ig*log(pi_ig)]
or ICL2 = BIC - 2*sum(log(max(pi_ig)), where the max is taken over the classes for each subject.
- %class computed as the proportion of each class based on c_ig
</p>


<h3>Value</h3>

<p>a matrix giving for each model the values of the requested indexes.
By default, the number a latent classes, the
log-likelihood, the number of parameters, the BIC and the posterior
probability of the latent classes.
</p>


<h3>Author(s)</h3>

<p>Cecile Proust-Lima, Viviane Philipps
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+summary">summary</a></code>, <code><a href="#topic+hlme">hlme</a></code>, <code><a href="#topic+lcmm">lcmm</a></code>,
<code><a href="#topic+multlcmm">multlcmm</a></code>, <code><a href="#topic+Jointlcmm">Jointlcmm</a></code>
</p>

<hr>
<h2 id='update.mpjlcmm'>Update the longitudinal submodels</h2><span id='topic+update.mpjlcmm'></span>

<h3>Description</h3>

<p>This function updates the longitudinal submodels of a mpjlcmm object by injecting
the estimated parameters and their variances in each hlme/lcmm/multlcmm model used
to define the multi-process joint model.
The same (uni-process) models as specified in the mpjlcmm call are returned, with
updated outputs for best, V, conv, cholesky, pred, predRE, predRE_Y, pprob.
All postfit functions (plots, predictions, ...) can then be called on the updated hlme/lcmm/multlcmm models.
See mpjlcmm's help page for examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mpjlcmm'
update(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update.mpjlcmm_+3A_object">object</code></td>
<td>
<p>an estimated mpjlcmm model</p>
</td></tr>
<tr><td><code id="update.mpjlcmm_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of hlme/lcmm/multlcmm models. The models appear in the same order as
specified in the call to the mpjlcmm function.
</p>

<hr>
<h2 id='VarCov'>Variance-covariance of the estimates</h2><span id='topic+VarCov'></span>

<h3>Description</h3>

<p>This function provides the variance-covariance matrix of the estimates. vcov
is an alias for it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VarCov(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VarCov_+3A_x">x</code></td>
<td>
<p>an object of class <code>hlme</code>, <code>lcmm</code>, <code>multlcmm</code>,
<code>Jointlcmm</code> or <code>mpjlcmm</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix containing the variance-covariance of the estimates. For
the parameters of the matrix of variance-covariance of the random effects,
the Cholesky transformed parameters are considered so that VarCov provides
the covariance matrix of function <code>estimates</code> with cholesky=TRUE.
</p>


<h3>Author(s)</h3>

<p>Cecile Proust-Lima, Viviane Philipps
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimates">estimates</a></code>
</p>

<hr>
<h2 id='VarCovRE'>Estimates, standard errors and Wald test for the parameters of the
variance-covariance matrix of the random effects.</h2><span id='topic+VarCovRE'></span><span id='topic+VarCovRE.hlme'></span><span id='topic+VarCovRE.lcmm'></span><span id='topic+VarCovRE.Jointlcmm'></span><span id='topic+VarCovRE.multlcmm'></span>

<h3>Description</h3>

<p>Fromm the Cholesky transformed parameters, this function provides estimates,
standard errors and Wald test for the parameters of the variance-covariance
matrix of the random effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VarCovRE(Mod)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VarCovRE_+3A_mod">Mod</code></td>
<td>
<p>an object of class <code>hlme</code>, <code>lcmm</code>, <code>multlcmm</code> or
<code>Jointlcmm</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix containing the estimates of the parameters of the
variance-covariance matrix of the random effects, their standard errors,
and, for the covariance parameters, the Wald statistic and the associated
p-value.
</p>


<h3>Author(s)</h3>

<p>Cecile Proust-Lima, Lionelle Nkam and Viviane Philipps
</p>

<hr>
<h2 id='VarExpl'>Percentage of variance explained by the (latent class) linear mixed model
regression</h2><span id='topic+VarExpl'></span><span id='topic+VarExpl.hlme'></span><span id='topic+VarExpl.lcmm'></span><span id='topic+VarExpl.Jointlcmm'></span><span id='topic+VarExpl.multlcmm'></span>

<h3>Description</h3>

<p>The function provides the percentage of variance explained by the (latent
class) linear mixed regression in a model estimated with <code>hlme</code>,
<code>lcmm</code>, <code>multlcmm</code> or <code>Jointlcmm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VarExpl(x, values)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VarExpl_+3A_x">x</code></td>
<td>
<p>an object of class <code>hlme</code>, <code>lcmm</code>, <code>multlcmm</code> or
<code>Jointlcmm</code></p>
</td></tr>
<tr><td><code id="VarExpl_+3A_values">values</code></td>
<td>
<p>a data frame with a unique row that contains the values of the
variables in random and the time variable in the correlation process from
which the percentage of variance should be calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>hlme</code>, <code>lcmm</code>, and <code>Jointlcmm</code> objects, the
function returns a matrix with 1 row and ng (ie the number of latent
classes) columns containing (the class specific) percentages of variance
explained by the linear mixed regression.
</p>
<p>For <code>multlcmm</code> objects, the function returns a matrix containing (the
class specific) percentages of variance explained by the linear mixed
regression for each outcome. The resulting matrix is composed of as many
rows as outcomes and as many columns as latent classes.
</p>


<h3>Author(s)</h3>

<p>Cecile Proust-Lima, Viviane Philipps
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hlme">hlme</a></code>, <code><a href="#topic+lcmm">lcmm</a></code>, <code><a href="#topic+multlcmm">multlcmm</a></code>,
<code><a href="#topic+Jointlcmm">Jointlcmm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
m1 &lt;- multlcmm(Ydep1+Ydep2~1+Time*X2+contrast(X2),random=~1+Time,
subject="ID",randomY=TRUE,link=c("4-manual-splines","3-manual-splines"),
intnodes=c(8,12,25),data=data_lcmm, 
B=c(-1.071, -0.192,  0.106, -0.005, -0.193,  1.012,  0.870,  0.881,
  0.000,  0.000, -7.520,  1.401,  1.607 , 1.908,  1.431,  1.082,
 -7.528,  1.135 , 1.454 , 2.328, 1.052))

# variation percentages explained by linear mixed regression
VarExpl(m1,data.frame(Time=0))

## End(Not run)

</code></pre>

<hr>
<h2 id='WaldMult'>Multivariate Wald Test</h2><span id='topic+WaldMult'></span>

<h3>Description</h3>

<p>This function provides multivariate and univariate Wald tests for
combinations of parameters from <code>hlme</code>, <code>lcmm</code>, <code>multlcmm</code>,
<code>Jointlcmm</code> or <code>mpjlcmm</code> models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WaldMult(Mod, pos = NULL, contrasts = NULL, name = NULL, value = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="WaldMult_+3A_mod">Mod</code></td>
<td>
<p>an object of class <code>hlme</code>, <code>lcmm</code>, <code>multlcmm</code>,
<code>Jointlcmm</code> or <code>mpjlcmm</code></p>
</td></tr>
<tr><td><code id="WaldMult_+3A_pos">pos</code></td>
<td>
<p>a vector containing the indices in <code>Mod$best</code> of the parameters to
test</p>
</td></tr>
<tr><td><code id="WaldMult_+3A_contrasts">contrasts</code></td>
<td>
<p>a numeric vector of same length as pos.  If NULL (the
default), a simultaneous test of the appropriate parameters is realised.  If
contrasts is specified, the quantity to test is the dot product of pos and
contrasts.</p>
</td></tr>
<tr><td><code id="WaldMult_+3A_name">name</code></td>
<td>
<p>a character containing the name the user wants to give to the
test. By default, the name's test is the null hypothesis.</p>
</td></tr>
<tr><td><code id="WaldMult_+3A_value">value</code></td>
<td>
<p>the value(s) to test against. By default, test against 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If contrasts is NULL, the function returns a matrix with 1 row and 2
columns containing the value of the Wald test's statistic and the associated
p-value.
</p>
<p>If contrasts is not NULL, the function returns a matrix with 1 row and 4
columns containing the value of the coefficient (dot product of pos and
contrasts), his standard deviation, the value of the Wald test's statistic
and the associated p-value.
</p>


<h3>Author(s)</h3>

<p>Cecile Proust-Lima, Lionelle Nkam and Viviane Philipps
</p>

<hr>
<h2 id='xclass'>Cross classifications</h2><span id='topic+xclass'></span>

<h3>Description</h3>

<p>This function crosses the posterior classifications of two estimated models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xclass(m1, m2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xclass_+3A_m1">m1</code></td>
<td>
<p>an object inheriting from classes <code>hlme</code>, <code>lcmm</code>, <code>multlcmm</code>, <code>Jointlcmm</code>, <code>mpjlcmm</code> or <code>externVar</code></p>
</td></tr>
<tr><td><code id="xclass_+3A_m2">m2</code></td>
<td>
<p>an object inheriting from classes <code>hlme</code>, <code>lcmm</code>, <code>multlcmm</code>, <code>Jointlcmm</code>, <code>mpjlcmm</code> or <code>externVar</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the contingency table of the two classifications
</p>


<h3>Author(s)</h3>

<p>Viviane Philipps and Cecile Proust-Lima
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Estimation of the models
m2 &lt;- hlme(Y~Time*X1,mixture=~Time,random=~Time,classmb=~X2+X3,subject='ID',ng=2,
data=data_hlme,B=c(0.11,-0.74,-0.07,20.71,29.39,-1,0.13,2.45,-0.29,4.5,0.36,0.79,0.97))
m3 &lt;- hlme(fixed = Y ~ Time * X1, mixture = ~Time, random = ~Time,subject = "ID",
classmb = ~X2 + X3, ng = 3, data = data_hlme,B=c(-0.21, 0.31, -2.11, -0.81, -0.24,
-0.18, 25.4, 20.09, 30.18, -0.43, -1.1, 0.25, 2.37, -0.29, 2.34, 0.03, 0.74, 0.97))

## Compare the classifications
xclass(m2,m3)
# The 39 subjects in class 2 of m3 come from class 1 of m2.
# In the same way, all the subjects in class 3 come from class 2 of m2.
# Class 1 of m3 mixes subject from class 1 and class 2 of m2.

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
