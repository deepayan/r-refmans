<!DOCTYPE html><html lang="en"><head><title>Help for package runMCMCbtadjust</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {runMCMCbtadjust}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#runMCMCbtadjust-package'><p>The versions up to 1.1.1 of this package wer supported by the GAMBAS project funded by the French National Research Agency (ANR-18-CE02-0025).</p>
This package was developed as part of the author activity at UR EFNO, INRAE, France.</a></li>
<li><a href='#findMCMC_strong_corrs'><p>findMCMC_strong_corrs</p></a></li>
<li><a href='#runMCMC_btadjust'><p>runMCMC_btadjust</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Runs Monte Carlo Markov Chain - With Either 'JAGS', 'nimble' or
'greta' - While Adjusting Burn-in and Thinning Parameters</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>The function runMCMC_btadjust() returns a mcmc.list object which is the output of a 
    Markov Chain Monte Carlo obtained - from either 'JAGS', 'nimble' or 'greta' -
	after adjusting burn-in and thinning parameters to meet pre-specified criteria
	in terms of convergence &amp; effective sample size. Used with 'nimble', runMCMC_btadjust()
	allows extra calculations (e.g. information criteria for model comparison and goodness-of-fit
	p-values for model diagnosis).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.cecill.info/licences/Licence_CeCILL_V2.1-en.txt">CECILL-2.1</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>coda</td>
</tr>
<tr>
<td>Suggests:</td>
<td>nimble (&ge; 1.0.0), rjags, runjags, greta, R6, tensorflow,
ggmcmc, rstan, knitr, markdown, testthat (&ge; 3.0.0), nimbleAPT
(&ge; 1.0.6), nimbleHMC, parallel, Hmisc, moments</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-08-20 16:05:01 UTC; fgosselin</td>
</tr>
<tr>
<td>Author:</td>
<td>Frédéric Gosselin <a href="https://orcid.org/0000-0003-3737-106X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut] (institution: INRAE),
  Institut national de recherche pour l'agriculture, l'alimentation et
    l'environnement [cph] (INRAE)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Frédéric Gosselin &lt;frederic.gosselin@inrae.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-08-28 12:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='runMCMCbtadjust-package'>The versions up to 1.1.1 of this package wer supported by the GAMBAS project funded by the French National Research Agency (ANR-18-CE02-0025).
This package was developed as part of the author activity at UR EFNO, INRAE, France.</h2><span id='topic+runMCMCbtadjust'></span><span id='topic+runMCMCbtadjust-package'></span>

<h3>Description</h3>

<p>The function runMCMC_btadjust() returns a mcmc.list object which is the output of a Markov Chain Monte Carlo obtained - from either 'JAGS', 'nimble' or 'greta' - after adjusting burn-in and thinning parameters to meet pre-specified criteria in terms of convergence &amp; effective sample size. Used with 'nimble', runMCMC_btadjust() allows extra calculations (e.g. information criteria for model comparison and goodness-of-fit p-values for model diagnosis).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Frédéric Gosselin <a href="mailto:frederic.gosselin@inrae.fr">frederic.gosselin@inrae.fr</a> (<a href="https://orcid.org/0000-0003-3737-106X">ORCID</a>) (INRAE)
</p>
<p>Other contributors:
</p>

<ul>
<li><p>  Institut national de recherche pour l'agriculture, l'alimentation et l'environnement (INRAE) [copyright holder]
</p>
</li></ul>


<hr>
<h2 id='findMCMC_strong_corrs'>findMCMC_strong_corrs</h2><span id='topic+findMCMC_strong_corrs'></span>

<h3>Description</h3>

<p>finds the couples of parameters of a MCMC.list object that have at least a minCorr level of (absolute) correlation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findMCMC_strong_corrs(
  mcmcList,
  corrMethod = "pearson",
  minCorr = 0.3,
  namesToRemove = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="findMCMC_strong_corrs_+3A_mcmclist">mcmcList</code></td>
<td>
<p>R object of type mcmc.list that contains the MCMC output</p>
</td></tr>
<tr><td><code id="findMCMC_strong_corrs_+3A_corrmethod">corrMethod</code></td>
<td>
<p>character: designates the kind of correlation calculated among &quot;pearson&quot; (the default, for linear relationships), &quot;spearman&quot; (for monotone relationships) or &quot;hoeffd&quot; (for general associations - i.e. dependencies - between parameters)</p>
</td></tr>
<tr><td><code id="findMCMC_strong_corrs_+3A_mincorr">minCorr</code></td>
<td>
<p>double, between 0 and 1: minimum level of (absolute) correlation to report.</p>
</td></tr>
<tr><td><code id="findMCMC_strong_corrs_+3A_namestoremove">namesToRemove</code></td>
<td>
<p>R object (can be a vector, matrix, array, list...) all components of which must be of character type: will remove parameters whose names partially match one of tghese components.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case corrMethod equals &quot;hoeffd&quot;, the hoeffd function in the Hmisc package will be used. This can be very slow. Therefore a warning message is printed in this case.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#generating data
set.seed(1)
y1000&lt;-rnorm(n=1000,mean=600,sd=30)
ModelData &lt;-list(mass = y1000,nobs = length(y1000))

#writing the Jags code as a character chain in R
modeltotransfer&lt;-"model {

# Priors
population.mean ~ dunif(0,5000)
population.sd ~ dunif(0,100)

# Precision = 1/variance: Normal distribution parameterized by precision in Jags
population.variance &lt;- population.sd * population.sd
precision &lt;- 1 / population.variance

# Likelihood
for(i in 1:nobs){
  mass[i] ~ dnorm(population.mean, precision)
 }
 }"

#specifying the initial values
ModelInits &lt;- function()
{list (population.mean = rnorm(1,600,90), population.sd = runif(1, 1, 30))}
params &lt;- c("population.mean", "population.sd", "population.variance")
K&lt;-3
set.seed(1)
Inits&lt;-lapply(1:K,function(x){ModelInits()})

# running runMCMC_btadjust with MCMC_language="Jags":
set.seed(1)
out.mcmc.Coda&lt;-runMCMC_btadjust(MCMC_language="Jags", code=modeltotransfer,
data=ModelData,
Nchains=K, params=params, inits=Inits,
niter.min=1000, niter.max=300000,
nburnin.min=100, nburnin.max=200000,
thin.min=1, thin.max=1000,
neff.min=1000, conv.max=1.05,
control=list(print.diagnostics=TRUE, neff.method="Coda"))

findMCMC_strong_corrs(out.mcmc.Coda)

## End(Not run)
</code></pre>

<hr>
<h2 id='runMCMC_btadjust'>runMCMC_btadjust</h2><span id='topic+runMCMC_btadjust'></span>

<h3>Description</h3>

<p>returns a mcmc.list object which is the output of a Markov Chain Monte Carlo obtained after adjusting burn-in &amp; thinning parameters to meet pre-specified criteria in terms of convergence &amp; effective sample size - i.e. sample size adjusted for autocorrelation - of the MCMC output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runMCMC_btadjust(
  code = NULL,
  data = NULL,
  constants = NULL,
  model = NULL,
  MCMC_language = "Nimble",
  Nchains,
  inits = NULL,
  params = NULL,
  params.conv = NULL,
  params.save = NULL,
  niter.min = 100,
  niter.max = Inf,
  nburnin.min = 10,
  nburnin.max = Inf,
  thin.min = 1,
  thin.max = Inf,
  neff.min = NULL,
  neff.med = NULL,
  neff.mean = NULL,
  conv.max = NULL,
  conv.med = NULL,
  conv.mean = NULL,
  control = list(time.max = NULL, check.convergence = TRUE, check.convergence.firstrun =
    NULL, recheck.convergence = TRUE, convtype = NULL, convtype.Gelman = 2,
    convtype.Geweke = c(0.1, 0.5), convtype.alpha = 0.05, ip.nc = 0, neff.method =
    "Stan", Ncycles.target = 2, props.conv = c(0.25, 0.5, 0.75), min.Nvalues = NULL,
    min.thinmult = 1.1, force.niter.max = FALSE, force.time.max = FALSE,
    time.max.turns.off.niter.max = FALSE, safemultiplier.Nvals = 1.2, max.prop.decr.neff
    = 0.1, round.thinmult = TRUE, thinmult.in.resetMV.temporary = TRUE, 
    
    check.thinmult = 2, decrease.thinmult.multiplier = 0.8, decrease.thinmult.threshold =
    20, only.final.adapt.thin = FALSE, identifier.to.print = "", print.diagnostics =
    FALSE, conv.thorough.check = FALSE, print.thinmult = TRUE, innerprint = FALSE, seed =
    NULL, remove.fixedchains = TRUE, check.installation = TRUE, save.data = FALSE,
    conveff.final.allparams = TRUE),
  control.MCMC = list(confModel.expression.toadd = NULL, sampler = expression(hmc()),
    warmup = 1000, n.adapt = -1, RNG.names = c("base::Wichmann-Hill",
    "base::Marsaglia-Multicarry", "base::Super-Duper", "base::Mersenne-Twister"), n_cores
    = NULL, showCompilerOutput = FALSE, buildDerivs = FALSE, resetMV = FALSE, parallelize
    = FALSE, parallelizeInitExpr = expression(if (MCMC_language == "Nimble") {
    
    library("nimble")
     if (control.MCMC$APT) {
         library("nimbleAPT")
     }

    } else {
     NULL
 }), useConjugacy = FALSE, WAIC = FALSE, WAIC.Nsamples = 2000,
    WAIC.control = list(online = TRUE, dataGroups = NULL, marginalizeNodes = NULL,
    niterMarginal = 1000, convergenceSet = c(0.25, 0.5, 0.75), thin = TRUE, nburnin_extra
    = 0), APT = FALSE, APT.NTemps = 7, APT.initTemps = NULL, APT.tuneTemps = c(10, 0.7),
    APT.thinPrintTemps = expression(niter/5), includeAllStochNodes = FALSE,
    monitorAllStochNodes = FALSE, saveAllStochNodes = FALSE, includeParentNodes = FALSE,
    monitorParentNodes = FALSE, saveParentNodes = FALSE, 
     extraCalculations = NULL)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="runMCMC_btadjust_+3A_code">code</code></td>
<td>
<p>R object: code for the model that will be used to build the MCMC when <code>MCMC_language</code> is &quot;Nimble&quot; or &quot;Jags&quot;. If &quot;Nimble&quot;, must be the name (in R) of the object which is the result of the function <code>nimbleCode</code>. If &quot;Jags&quot;, should be either: (i) a character string which is the name of a txt file that contains the code of the model (as used in the function jags.model): should then end up by &quot;.txt&quot;; or (ii) a character string that contains the text of the Jags code.</p>
</td></tr>
<tr><td><code id="runMCMC_btadjust_+3A_data">data</code></td>
<td>
<p>R list: a list that will contain the data when <code>MCMC_language</code> is &quot;Nimble&quot; or &quot;Jags&quot;. If &quot;Nimble&quot;, will be sent to the <code>data</code> argument of the <code>nimbleModel</code> function in <code>nimble</code> package, i.e. the data that have a random distribution in the model. If <code>MCMC_language</code> is &quot;Greta&quot;, can be used just to document the summary of data in the output.</p>
</td></tr>
<tr><td><code id="runMCMC_btadjust_+3A_constants">constants</code></td>
<td>
<p>R list: a list that will contain the rest of the data (in addition to data) when <code>MCMC_language</code> is &quot;Nimble&quot;. Will be sent to the <code>constants</code> argument of the <code>nimbleModel</code> function in <code>nimble</code> package, i.e. the data that do not have a random distribution in the model. If <code>MCMC_language</code> is &quot;Greta&quot;, can be used just to document the summary of other data in the output.</p>
</td></tr>
<tr><td><code id="runMCMC_btadjust_+3A_model">model</code></td>
<td>
<p>R object: should be the result of the <code>model</code> command of Greta when <code>MCMC_language</code> is &quot;Greta&quot;.</p>
</td></tr>
<tr><td><code id="runMCMC_btadjust_+3A_mcmc_language">MCMC_language</code></td>
<td>
<p>character value: designates the <code>MCMC_language</code> used to write &amp; fit the Bayesian model in R. Current choices are &quot;Nimble&quot; - the default-, &quot;Greta&quot; or &quot;Jags&quot;. Note that in case it is &quot;Nimble&quot;, package <code>nimble</code> should be loaded in your search list if not using parallelization.</p>
</td></tr>
<tr><td><code id="runMCMC_btadjust_+3A_nchains">Nchains</code></td>
<td>
<p>integer value : the number of Markov chains to run in the MCMC.</p>
</td></tr>
<tr><td><code id="runMCMC_btadjust_+3A_inits">inits</code></td>
<td>
<p>either NULL, a function or an R list, with <code>Nchains</code> components. Each component is then a named list that contains the initial values of the parameters for the MCMC.
In case <code>MCMC_language=="Greta"</code>, each component should be the result of the <code>initials</code> function in <code>greta</code> package.
If a function, it will generate values for one chain.</p>
</td></tr>
<tr><td><code id="runMCMC_btadjust_+3A_params">params</code></td>
<td>
<p>character vector: contains the names of the parameters to save at the end of the MCMC and to monitor for convergence and effective sample size;
inactive for convergence/effective sample size if <code>params.conv</code> is specified;
inactive for saving if <code>params.save</code> is specified.</p>
</td></tr>
<tr><td><code id="runMCMC_btadjust_+3A_params.conv">params.conv</code></td>
<td>
<p>character vector: contains the names of the parameters to monitor for convergence and effective sample size.</p>
</td></tr>
<tr><td><code id="runMCMC_btadjust_+3A_params.save">params.save</code></td>
<td>
<p>character vector: contains the names of the parameters to be saved at the end of the MCMC.</p>
</td></tr>
<tr><td><code id="runMCMC_btadjust_+3A_niter.min">niter.min</code></td>
<td>
<p>integer value: the minimum number of iterations in each chain of the MCMC.</p>
</td></tr>
<tr><td><code id="runMCMC_btadjust_+3A_niter.max">niter.max</code></td>
<td>
<p>integer value: the maximum number of iterations in each chain of the MCMC. Will stop the MCMC once the number of iterations will reach this limit.</p>
</td></tr>
<tr><td><code id="runMCMC_btadjust_+3A_nburnin.min">nburnin.min</code></td>
<td>
<p>integer value: the minimum number of burn-in (=transitory) iterations in each chain of the MCMC.</p>
</td></tr>
<tr><td><code id="runMCMC_btadjust_+3A_nburnin.max">nburnin.max</code></td>
<td>
<p>integer value: the maximum number of burn-in (=transitory) iterations in each chain of the MCMC. Will stay at this burn-in value once this limit is reached.</p>
</td></tr>
<tr><td><code id="runMCMC_btadjust_+3A_thin.min">thin.min</code></td>
<td>
<p>integer value: the minimum value of the thin parameter of the MCMC.</p>
</td></tr>
<tr><td><code id="runMCMC_btadjust_+3A_thin.max">thin.max</code></td>
<td>
<p>integer value: the maximum value of the thin parameter of the MCMC. Will stay at this thin value once this limit is reached.</p>
</td></tr>
<tr><td><code id="runMCMC_btadjust_+3A_neff.min">neff.min</code></td>
<td>
<p>positive real number: minimum effective sample size - over parameters used to diagnose convergence &amp; effective sample size- , as calculated with <code>neff.method</code> (specified in <code>Control</code>).
The algorithm will not stop if the minimum number of effective values is not above this value (unless another limit - e.g. <code>niter.max</code> - is reached).</p>
</td></tr>
<tr><td><code id="runMCMC_btadjust_+3A_neff.med">neff.med</code></td>
<td>
<p>positive real number: median effective sample size - over parameters used to diagnose convergence &amp; effective sample size- , as calculated with <code>neff.method</code> (specified in <code>Control</code>).
The algorithm will not stop if the median number of effective values is not above this value (unless another limit - e.g. <code>niter.max</code> - is reached).</p>
</td></tr>
<tr><td><code id="runMCMC_btadjust_+3A_neff.mean">neff.mean</code></td>
<td>
<p>positive real number: mean effective sample size - over parameters used to diagnose convergence &amp; effective sample size-, as calculated with <code>neff.method</code> (specified in <code>Control</code>).
The algorithm will not stop if the mean number of effective values is not above this value (unless another limit - e.g. <code>niter.max</code> - is reached).</p>
</td></tr>
<tr><td><code id="runMCMC_btadjust_+3A_conv.max">conv.max</code></td>
<td>
<p>positive real number: maximum - over parameters used to diagnose convergence &amp; effective sample size - convergence diagnostic, as calculated with <code>convtype</code> method (specified in <code>Control</code>).
The algorithm will not stop if the maximum convergence diagnostic is not below this value (unless another limit - e.g. <code>niter.max</code> - is reached).</p>
</td></tr>
<tr><td><code id="runMCMC_btadjust_+3A_conv.med">conv.med</code></td>
<td>
<p>positive real number: median - over parameters used to diagnose convergence &amp; effective sample size - convergence diagnostic, as calculated with <code>convtype</code> method(specified in <code>Control</code>).
The algorithm will not stop if the median convergence diagnostic is not below this value (unless another limit - e.g. <code>niter.max</code> - is reached).</p>
</td></tr>
<tr><td><code id="runMCMC_btadjust_+3A_conv.mean">conv.mean</code></td>
<td>
<p>positive real number: mean - over parameters used to diagnose convergence &amp; effective sample size - convergence diagnostic, as calculated with <code>convtype</code> method (specified in <code>Control</code>).
The algorithm will not stop if the mean convergence diagnostic is not below this value (unless another limit - e.g. <code>niter.max</code> - is reached).</p>
</td></tr>
<tr><td><code id="runMCMC_btadjust_+3A_control">control</code></td>
<td>
<p>list of <code>runMCMC_btadjust</code> control parameters: with the following components:<br />
</p>
 <ul>
<li> <p><code>time.max</code>: positive number (units: seconds): maximum time of the process in seconds, not including WAIC calculations and extra.calculations; the program will organize itself to stop (not including WAIC calculation and extra calculations as specified in <code>control.MCMC$extraCalculations</code>) before roughly <code>time.max</code>. Default to NULL, corresponding to no time constraint except in case of parallelization (see below).
</p>
</li>
<li> <p><code>check.convergence</code>: logical value: should the program check convergence at all? Default to TRUE. See Details.
</p>
</li>
<li> <p><code>check.convergence.firstrun</code>: logical value: should we check convergence after the first run? Default to NULL in which case will depend on <code>MCMC_language</code>: if MCMC_language!=&quot;Greta&quot; &amp; control.MCMC$n.adapt&lt;=0, will be FALSE otherwise will be TRUE because warmup phase separated from the rest in case of Greta.
</p>
</li>
<li> <p><code>recheck.convergence</code>: logical value: should the algorithm recheck convergence once convergence has been found in a previous run? Default to TRUE.
</p>
</li>
<li> <p><code>convtype</code>: character or NULL value: specifies the type of convergence diagnostic used. Currently implemented: &quot;Gelman&quot; for original Gelman-Rubin diagnostic (only possible if <code>Nchains&gt;=2</code>), &quot;Gelman_new&quot; for the version of the Gelman-Rubin diagnostic in the second version of &quot;Bayesian Data Analysis&quot; (Gelman, Carlin, Stern and Rubin)(only possible if <code>Nchains&gt;=2</code>), &quot;Geweke&quot; for Geweke diagnostic (at present applied only in case <code>Nchains==1</code>) and &quot;Heidelberger&quot; for the reciprocal of Heidelberger-Welch first part of convergence diagnostic based on the Cramer-von Mises test statistic. If NULL (the default), chooses &quot;Geweke&quot; in case Nchains==1 and &quot;Gelman&quot; in case Nchains&gt;1.
</p>
</li>
<li> <p><code>convtype.Gelman</code>: integer value: when <code>convtype=="Gelman"</code>, do we target the Point estimate diagnostic (value 1) or the Upper C.I. diagnostic (value 2). Default to 2.
</p>
</li>
<li> <p><code>convtype.Geweke</code>: real vector with two components between 0 and 1: (i) the fraction of samples to consider as the beginning of the chain (frac1 in geweke.diag); (ii) the fraction of samples to consider as the end of the chain (frac2 in <code>gewke.diag</code>). Default to c(0.1,0.5) as in <code>geweke.diag</code>.
</p>
</li>
<li> <p><code>convtype.alpha</code>: real value between 0 and 1: significance level used in case <code>convtype=="Gelman"</code> and <code>convtype.Gelman==2</code>, or <code>convtype=="Heidelberger"</code>
</p>
</li>
<li> <p><code>props.conv</code>: numeric vector: quantiles of number of iterations removed to recheck convergence and number of effective values (if not converged before or <code>conv.thorough.check</code> is TRUE). Values should be between 0 and 1.
</p>
</li>
<li> <p><code>ip.nc</code>: real value: inflexion point for log(scaleconvs-1); if (very) negative will tend to double the number of iterations in case of non convergence (i.e. add niter iterations) ; if (very) positive will tend to add niter/Ncycles iterations. Default to 0.
</p>
</li>
<li> <p><code>conv.thorough.check</code>: logical value: whether one goes through all the <code>props.conv</code> proportions to find the best one in terms first of convergence (just in terms of respecting the criterion) and then of neffs (if TRUE) or stops at the first <code>props.conv</code> corresponding to convergence or does not change if there is no convergence (if FALSE, the default).
</p>
</li>
<li> <p><code>neff.method</code>: character value: method used to calculate the effective sample sizes. Current choice between &quot;Stan&quot; (the default) and &quot;Coda&quot;. If &quot;Stan&quot;, uses the function <code>monitor</code> in package <code>rstan</code>. If &quot;Coda&quot;, uses the function <code>effectiveSize</code> in package <code>coda</code>.
</p>
</li>
<li> <p><code>Ncycles.target</code>: integer value: targeted number of MCMC runs. Default to 2.
</p>
</li>
<li> <p><code>min.Nvalues</code>: integer value or expression giving an integer value or NULL: minimum number of values to diagnose convergence or level of autocorrelation. Default to NULL in which case is will be given the value neff.max calculated within the program.
</p>
</li>
<li> <p><code>round.thinmult</code>: logical value: should the thin multiplier be rounded to the nearest integer so that past values are precisely positioned on the modified iteration sequence? Default to TRUE. Value of FALSE may not be rigorous or may not converge well.
</p>
</li>
<li> <p><code>thinmult.in.resetMV.temporary</code>: logical value: should the thin multiplier be taken into account in resetting parameter collection in case MCMC_language is &quot;Nimble&quot;. Important mainly if control.MCMC$WAIC is TRUE. If TRUE, resetting will be more frequent, and WAIC calculation will be longer and more rigorous. Default to TRUE.
</p>
</li>
<li> <p><code>check.thinmult</code>: integer value between 1, 2 and 3: how should we check thinmult value after thinmult calculation? If 3, it is tested whether thinmult meets specific criteria -relative to convergence reaching (i.e. if no convergence, no change), number of effective value reaching conservation, minimum number of output values - min.Nvalues- and proportional reduction of number of effective values - and if not decreased values are tested with the same criteria. If 2, the same checkings are done except the one on proportional reduction of effective values. If 1, only the min.Nvalues criterion is taken into account. Default to 2. A value of 3 should produce shorter MCMCs, more values in the output, with more autocorrelation, than a value of 1.
</p>
</li>
<li> <p><code>decrease.thinmult.multiplier</code>: positive number below 1: when adapting the proposed multiplier of thin (thinmult), the multiplier of the current thinmult used to propose a new - smaller - thinmult value, provided thinmult is above decrease.thinmult.threshold. Default to 0.8.
</p>
</li>
<li> <p><code>decrease.thinmult.threshold</code>: positive number above 3: when adapting the proposed multiplier of thin (thinmult), the threshold value for thinmult below which decreases of proposed thinmult are substractions of one unit. Default to 20.
</p>
</li>
<li> <p><code>only.final.adapt.thin</code>: logical value: should the thin parameter be adapted only at the end - so that during running of the MCMC we conserve a sufficient number of values - esp. with respect to min.Nvalues. Default to FALSE.
</p>
</li>
<li> <p><code>min.thinmult</code>: numeric value: minimum value of thin multiplier: if diagnostics suggest to multiply by less than this, this multiplication is not done. Default to 1.1.
</p>
</li>
<li> <p><code>force.niter.max</code>: logical value: if TRUE, the number of iterations is forced to go to niter.max - except for time.max constraints. Default to FALSE.
</p>
</li>
<li> <p><code>force.time.max</code>: logical value: if TRUE, the number of iterations is forced to go to approximately time.max seconds - except for niter.max constraints. Default to FALSE.
</p>
</li>
<li> <p><code>time.max.turns.off.niter.max</code>: logical value: if TRUE, and if time.max is finite, the number of iterations can be greater than niter.max (except if we are only in the phase of force.niter.max or force.time.max). Default to FALSE.
</p>
</li>
<li> <p><code>seed</code>: integer number or NULL value: seed for the pseudo-random number generator inside runMCMC_btadjust. Default to NULL in which case here is no control of this seed.
</p>
</li>
<li> <p><code>identifier.to.print</code>: character string: printed each time an MCMC update is ran to identify the model (esp. if multiple successive calls to <code>runMCMC_btadjust</code> are made).
</p>
</li>
<li> <p><code>safemultiplier.Nvals</code>: positive number: number bigger than 1 used to multiply the targeted number of effective values in calculations of additional number of iterations. Default to 1.2.
</p>
</li>
<li> <p><code>max.prop.decr.neff</code>: number between 0 and 1 used, if check.thinmult==3, to decide if we accept dimension reduction - through augmentation of thin parameter with thinmult -: maximum acceptable Proportional Decrease of the number of effective values: guaranties that at least (1-max.prop.decr.neff) times the number of effective values estimated prior to dimension reduction are kept. Default to 0.1.
</p>
</li>
<li> <p><code>print.diagnostics</code>: logical value: should diagnostics be printed each time they are calculated? Default to FALSE.
</p>
</li>
<li> <p><code>print.thinmult</code>: logical value: should the raw multiplier of thin be printed each time it is calculated? Default to TRUE.
</p>
</li>
<li> <p><code>innerprint</code>: logical value: should printings be done inside the function <code>monitor</code> of <code>rstan</code> in case <code>neff.method=="Stan"</code>? Default to FALSE.
</p>
</li>
<li> <p><code>remove.fixedchains</code>: logical value: should we remove Markov chains that do not vary during the first cycle (i.e. whose all parameters have zero variances)? Default to TRUE. If so, those chains are removed from the diagnostics, from the output values and associated chains are no longer updated if MCMC_language==&quot;Nimble&quot;.
</p>
</li>
<li> <p><code>check.installation</code>: logical value: should the function check installation of packages and programs? Default to TRUE.
</p>
</li>
<li> <p><code>save.data</code>: logical value: should the program save the entire data in the call.params section of the attributes? Default to FALSE, in which case only a summary of data is saved.
</p>
</li>
<li> <p><code>conveff.final.allparams</code>: logical value: should the final convergence/number of effective values calculations in final.diags be done on all parameters? Default to TRUE.
</p>
</li></ul>
</td></tr>
<tr><td><code id="runMCMC_btadjust_+3A_control.mcmc">control.MCMC</code></td>
<td>
<p>list of MCMC control parameters: with the following components - that depend on <code>MCMC_language</code>:
</p>
 <ul>
<li> <p><code>confModel.expression.toadd</code> (only for <code>MCMC_language=="Nimble"</code>): expression to add to <code>confModel</code> to specify samplers, remove nodes... <code>confModel</code> should be referred to by <code>confModel[[i]]</code>. See Details for an example.
</p>
</li>
<li> <p><code>sampler</code> (only for <code>MCMC_language=="Greta"</code>): expression used to specify the sampler used.
</p>
</li>
<li> <p><code>warmup</code> (only for <code>MCMC_language=="Greta"</code>): integer value used as warmup parameter in the mcmc.
</p>
</li>
<li> <p><code>n.adapt</code> (only for <code>MCMC_language=="Jags"</code> or <code>MCMC_language=="Nimble"</code>): integer value: number of iterations used for adaptation (in function <code>jags.model</code> in <code>rjags</code> package in case <code>MCMC_language=="Jags"</code> and otherwise in Nimble - added to burnin: first iterations that are not saved).
</p>
</li>
<li> <p><code>RNG.names</code> (only for <code>MCMC_language=="Jags"</code>): character vector: name of pseudo-random number generators for each chain. Each component of the vector should be among &quot;base::Wichmann-Hill&quot;, &quot;base::Marsaglia-Multicarry&quot;, &quot;base::Super-Duper&quot;, &quot;base::Mersenne-Twister&quot;. If less values than <code>Nchains</code> are provided, they are specified periodically.
</p>
</li>
<li> <p><code>n_cores</code> (only for <code>MCMC_language=="Greta"</code>): integer or NULL: maximum number of cores to use by each sampler.
</p>
</li>
<li> <p><code>showCompilerOutput</code> (only for <code>MCMC_language=="Nimble"</code>): logical value indicating whether details of C++ compilation should be printed. Default to FALSE to get default printings of limited size.
</p>
</li>
<li> <p><code>buildDerivs</code> (only for <code>MCMC_language=="Nimble"</code>): logical value indicating whether derivatives should be prepared when preparing Nimble model (will esp. allow to use HMC sampler). Default to FALSE.
</p>
</li>
<li> <p><code>resetMV</code> (only for <code>MCMC_language=="Nimble"</code>): logical value to be passed to $run specifying whether previous parameter samples should be reset or not. Default to FALSE to speed up WAIC calculations. You can turn it to TRUE if you wish to speed up runs of MCMC (cf. https://groups.google.com/g/nimble-users/c/RHH9Ybh7bSI/m/Su40lgNRBgAJ).
</p>
</li>
<li> <p><code>parallelize</code> (only for <code>MCMC_language=="Jags"</code> and <code>MCMC_language=="Nimble"</code>): logical value specifying whether the MCMC should be parallelized within the <code>runMCMC_btadjust</code> function with the <code>parallel</code> package (and for the moment default settings of this package). Default to FALSE. If TRUE, library <code>parallel</code> should be loaded. If TRUE and <code>control$time.max</code> is unspecified or infinite, each parallelized process will have a maximum duration of 30 days. In case <code>MCMC_language=="Greta"</code>, parallelization is managed directly by Greta.
</p>
</li>
<li> <p><code>parallelizeInitExpr</code> (only for <code>MCMC_language=="Jags"</code> and <code>MCMC_language=="Nimble"</code>): expression to add in each cluster created by parallelization. Default to <code>expression(if(MCMC_language=="Nimble"){library(nimble);if(control.MCMC$APT) {library(nimbleAPT)}} else {NULL})</code>.
</p>
</li>
<li> <p><code>useConjugacy</code> (only for <code>MCMC_language=="Nimble"</code>): logical value specifying whether Nimble should search for conjugate priors in the model. Default to FALSE. If TRUE, can render model configuration shorter (https://groups.google.com/g/nimble-users/c/a6DFCefYfjU/m/kqUWx9UXCgAJ) at the expense of not allowing any conjugate sampler
</p>
</li>
<li> <p><code>WAIC</code> (only for <code>MCMC_language=="Nimble"</code>): logical value specifying whether WAIC should be calculated online within Nimble. Default to FALSE.
</p>
</li>
<li> <p><code>WAIC.Nsamples</code> (only for <code>MCMC_language=="Nimble"</code>): integer number: number of (nearly independent) samples of parameters in the posterior distribution over which to calculate WAIC. If WAIC is calculated on more than one chain, this number will be required for each of these chains. Default to 2000.
</p>
</li>
<li> <p><code>WAIC.control</code> (only for <code>MCMC_language=="Nimble"</code>): named list or list of such named lists: list (or lists) specifying the control parameters to calculate WAIC online within Nimble. Default to list(online=TRUE,dataGroups=NULL,marginalizeNodes=NULL,niterMarginal=1000,convergenceSet=c(0.25,0.5,0.75),thin=TRUE,nburnin_extra=0). Given the way WAIC is here calculated (after convergence and over the last sample outputs for one chain by named list), components thin will be turned to TRUE and nburnin_extra to 0. If several lists are used, only at most the first Nchains - reduced by removal of fixed chains - lists will be taken into account to calculate WAICs in different ways on different Markov Chains.
</p>
</li>
<li> <p><code>APT</code> (only for <code>MCMC_language=="Nimble"</code>): logical value specifying whether <code>NimbleAPT</code> should be used to allow Adaptive Parallel Tempering for at least a subset of the model parameters. If so, the sampler_RW_tempered sampler is declared for all parameters. If wishing to change sampler, use <code>confModel.expression.toadd</code>. Default to FALSE.
</p>
</li>
<li> <p><code>APT.NTemps</code> (only for <code>MCMC_language=="Nimble"</code>): integer number: number of temperatures for <code>NimbleAPT</code>. Default to 7.
</p>
</li>
<li> <p><code>APT.initTemps</code> (only for <code>MCMC_language=="Nimble"</code>): NULL or double vector of length <code>APT.NTemps</code>: initial temperatures for Nimble APT. Default to NULL in which case initial temperatures will be 1:APT.NTemps. The values should be increasing with a first value of 1.
</p>
</li>
<li> <p><code>APT.tuneTemps</code> (only for <code>MCMC_language=="Nimble"</code>): numerical vector of length 2: values to feed the parameters <code>tuneTemper1</code> and <code>tuneTemper2</code> in <code>NimbleAPT</code>. See documentation of <code>NimbleAPT</code>. Default to c(10,0.7).
</p>
</li>
<li> <p><code>APT.thinPrintTemps</code> (only for <code>MCMC_language=="Nimble"</code>): expression or numerical value : thinning parameter for printing temperatures in case APT. Default to expression(niter/5).
</p>
</li>
<li> <p><code>includeAllStochNodes</code> (only for <code>MCMC_language=="Nimble"</code>): logical value specifying whether all stochastic nodes should be made available in <code>runMCMC_btadjust</code>. Default to FALSE. Maybe useful for the <code>extraCalculations</code> component of <code>control.MCMC</code>. Can include more parameters than <code>includeParentNodes</code>. Can be useful for example to calculate goodness-of-fit p-values.
</p>
</li>
<li> <p><code>monitorAllStochNodes</code> (only for <code>MCMC_language=="Nimble"</code>): logical value specifying whether all stochastic nodes should be monitored for convergence and number of effective values in <code>runMCMC_btadjust</code>. Default to FALSE.
</p>
</li>
<li> <p><code>saveAllStochNodes</code> (only for <code>MCMC_language=="Nimble"</code>): logical value specifying whether all stochastic nodes should be made available in <code>runMCMC_btadjust</code> and kept in the result of <code>runMCMC_btadjust</code>. Default to FALSE. Note that if TRUE, will change the content of <code>params_saved</code>.
</p>
</li>
<li> <p><code>includeParentNodes</code> (only for <code>MCMC_language=="Nimble"</code>): logical value specifying whether parent stochastic nodes of data should be made available in <code>runMCMC_btadjust</code>. Default to FALSE. Maybe useful for the <code>extraCalculations</code> component of <code>control.MCMC</code> - for example for &quot;offline&quot; calculations of WAIC or DIC (Deviance information criterion).
</p>
</li>
<li> <p><code>monitorParentNodes</code> (only for <code>MCMC_language=="Nimble"</code>): logical value specifying whether parent stochastic nodes of data should be monitored for convergence and number of effective values in <code>runMCMC_btadjust</code>. Default to FALSE.
</p>
</li>
<li> <p><code>saveParentNodes</code> (only for <code>MCMC_language=="Nimble"</code>): logical value specifying whether parent stochastic nodes of data should be made available in <code>runMCMC_btadjust</code> and kept in the result of <code>runMCMC_btadjust</code>. Default to FALSE. Note that if TRUE, will change the content of <code>params_saved</code>.
</p>
</li>
<li> <p><code>extraCalculations</code> (mainly useful for <code>MCMC_language=="Nimble"</code> but can be used with other languages as well): NULL value or expression that will be evaluated at the end of <code>runMCMC_btadjust</code>. The value of this expression will be saved in the <code>extraResults</code> component of the <code>final.params</code> component of the attributes of the result of <code>runMCMC_btadjust</code>. See the vignette devoted to the use of it. Default to NULL.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Recap: <br />
If <code>MCMC_language=="Nimble"</code>, the code, data and constants arguments should be specified according to the requirements of <code>nimble</code> package. <br />
If <code>MCMC_language=="Jags"</code>, the code and  data arguments need to be specified as required by <code>rjags</code> package.  <br />
If <code>MCMC_language=="Greta"</code>, the model argument must be specified and should be the result of the <code>model</code> command in <code>greta</code> package.  <br />
</p>
<p>Details on <code>check.convergence</code>: <br />
If FALSE, no check of convergence at all, after <code>nburnin.min</code> (&amp; <code>recheck.convergence</code> is put to FALSE &amp; <code>check.convergence.firstrun</code> is dominated by <code>check.convergence</code>). <br />
If TRUE, the convergence behavior is governed by <code>check.convergence.firstrun</code> &amp; <code>recheck.convergence</code>.<br />
</p>
<p>Example for <code>confModel.expression.toadd</code> component of <code>control.MCMC</code>:<br />
<code>confModel.expression.toadd&lt;-expression({ConfModel[[i]]$removeSamplers(c("alpha","dzetad","beta","exper_bias[2]","exper_bias[3]","exper_precision[2]","exper_precision[3]"))
			ConfModel[[i]]$addSampler(target = c("alpha","dzetad","beta"),type = "RW_block")
			ConfModel[[i]]$addSampler(target = c("exper_bias[2]","exper_bias[3]"),type = "RW_block")
			ConfModel[[i]]$addSampler(target = c("exper_precision[2]","exper_precision[3]"),type = "RW_block")
			})</code>
</p>
<p>Remark for <code>params, params.conv, params.save</code>:<br />
in cases of parameters that are vectors, matrices... the <code>params</code> vector can contain only the name of the vector or matrix... in which case all its components will be used. It can also contain the names of individual components.
</p>


<h3>Value</h3>

<p>a <code>mcmc.list</code> object with attributes with the following components:
</p>
 <ul>
<li> <p><code>call.params</code>: a list containing most of the important arguments of the <code>runMCMC_btadjust</code> call as well as either a summary of dimensions/lengths and mean of components of <code>data</code> and <code>constants</code> arguments or their entire values.
</p>
</li>
<li> <p><code>final.params</code>: a list with the parameters of the MCMC at the end of fitting:
</p>
 <ul>
<li> <p><code>converged</code>: logical: TRUE if model has converged when stopping the MCMC, FALSE otherwise
</p>
</li>
<li> <p><code>neffs.reached</code>: logical: TRUE if model has converged and reached the objectives in terms of effective sample size, FALSE otherwise
</p>
</li>
<li> <p><code>final.Nchains</code>: number of Markov chains finally retained - since some chains could be excluded if invariable.
</p>
</li>
<li> <p><code>removed.chains</code>: identity of the Markov chains finally removed - those that would have been invariable during the first cycle.
</p>
</li>
<li> <p><code>burnin</code>: number of iterations of the transient (burn-in) period
</p>
</li>
<li> <p><code>thin</code>: number of iterations used for thinning the final output
</p>
</li>
<li> <p><code>niter.tot</code>: total number of iterations (of each MCMC chain)
</p>
</li>
<li> <p><code>Nvalues</code>: number of saved values (over all the MCMC chains)
</p>
</li>
<li> <p><code>neff.min</code>: minimum number of effective values in the final MCMC (over params.conv)
</p>
</li>
<li> <p><code>neff.median</code>: median number of effective values (over params.conv)
</p>
</li>
<li> <p><code>WAIC</code>: results of the calculus of online WAIC (only if control.MCMC$WAIC and <code>MCMC_language=="Nimble"</code>). One component per component of control.MCMC$control.WAIC. Each component has a WAIC component and then a WAICDetails component.
</p>
</li>
<li> <p><code>extraResults</code>: results of the implementation of control.MCMC$extraCalculations. Can be any kind of R object.
</p>
</li>
<li> <p><code>Temps</code>: results of the series of Temperatures met in APT (only if control.MCMC$APT and <code>MCMC_language=="Nimble"</code>). One line for each end of $run (=MCMC run).
</p>
</li>
<li> <p><code>duration</code>: total duration (elapsed time) of the fit (in seconds)
</p>
</li>
<li> <p><code>duration.MCMC.preparation</code>: duration (elapsed time) of MCMC preparation (in seconds)
</p>
</li>
<li> <p><code>duration.MCMC.transient</code>: duration (elapsed time) of the MCMC transient (burn-in) phase (in seconds)
</p>
</li>
<li> <p><code>duration.MCMC.asymptotic</code>: duration (elapsed time) of the MCMC asymptotic phase (in seconds)
</p>
</li>
<li> <p><code>duration.MCMC.after</code>: duration (elapsed time) of the MCMC phase after the asymptotic phase of sampling (e.g. to calculate WAIC) (in seconds)
</p>
</li>
<li> <p><code>duration.btadjust</code>: duration (elapsed time) outside MCMC preparation &amp; fitting (in seconds)
</p>
</li>
<li> <p><code>CPUduration</code>: total CPU duration (user+system, self+child if not NA - otherwise only self) of the fit (in seconds)
</p>
</li>
<li> <p><code>CPUduration.MCMC.preparation</code>: CPU duration (user+system, self+child if not NA - otherwise only self) of MCMC preparation (in seconds)
</p>
</li>
<li> <p><code>CPUduration.MCMC.transient</code>: CPU duration (user+system, self+child if not NA - otherwise only self) of the MCMC transient (burn-in) phase (in seconds)
</p>
</li>
<li> <p><code>CPUduration.MCMC.asymptotic</code>: CPU duration (user+system, self+child if not NA - otherwise only self) of the MCMC asymptotic phase (in seconds)
</p>
</li>
<li> <p><code>CPUduration.MCMC.after</code>: CPU duration (user+system, self+child if not NA - otherwise only self) of the MCMC phase after the asymptotic phase of sampling (e.g. to calculate WAIC) (in seconds)
</p>
</li>
<li> <p><code>CPUduration.btadjust</code>: CPU duration (user+system, self+child if not NA - otherwise only self) outside MCMC preparation &amp; fitting (in seconds)
</p>
</li>
<li> <p><code>childCPUduration</code>: total child CPU duration (user+system) of the fit (in seconds)
</p>
</li>
<li> <p><code>childCPUduration.MCMC.preparation</code>: child CPU duration (user+system) of MCMC preparation (in seconds)
</p>
</li>
<li> <p><code>childCPUduration.MCMC.transient</code>: child CPU duration (user+system) of the MCMC transient (burn-in) phase (in seconds)
</p>
</li>
<li> <p><code>childCPUduration.MCMC.asymptotic</code>: child CPU duration (user+system) of the MCMC asymptotic phase (in seconds)
</p>
</li>
<li> <p><code>childCPUduration.MCMC.after</code>: child CPU duration (user+system) of the MCMC phase after the asymptotic phase of sampling (e.g. to calculate WAIC) (in seconds)
</p>
</li>
<li> <p><code>childCPUduration.btadjust</code>: child CPU duration (user+system) outside MCMC preparation &amp; fitting (in seconds)
</p>
</li>
<li> <p><code>time</code>: time (from Sys.time) at the end of model fitting
</p>
</li></ul>

</li>
<li> <p><code>final.diags</code>: a list with final diagnostics of the fit:
</p>
 <ul>
<li> <p><code>params</code>: parameters of the MCMC (burn-in, thin, niter...)
</p>
</li>
<li> <p><code>conv_synth</code>: synthetic output of convergence diagnostics
</p>
</li>
<li> <p><code>neff_synth</code>: synthetic output for calculations of effective sample sizes
</p>
</li>
<li> <p><code>conv</code>: raw convergence values for all the parameters being diagnosed if control$conveff.final.allparams is FALSE and all the parameters otherwise
</p>
</li>
<li> <p><code>neff</code>: raw effective sample size values for all the parameters being diagnosed if control$conveff.final.allparams is FALSE and all the parameters otherwise
</p>
</li></ul>

</li>
<li> <p><code>sessionInfo</code>: a list containing the result of the call to sessionInfo() function at the end of runMCMC_btadjust function; contains info on the platform, versions of packages, R version...;
</p>
</li>
<li> <p><code>warnings</code>: a list of the warning messages issued during fitting; unsure it still works with this version
</p>
</li>
<li> <p><code>error</code>: a list with the error messages issued during fitting; unsure it still works with this version
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># for examples with Nimble or Greta, see the Presentation Vignette.
## Not run: 
#generating data
set.seed(1)
y1000&lt;-rnorm(n=1000,mean=600,sd=30)
ModelData &lt;-list(mass = y1000,nobs = length(y1000))

#writing the Jags code as a character chain in R
modeltotransfer&lt;-"model {

# Priors
population.mean ~ dunif(0,5000)
population.sd ~ dunif(0,100)

# Precision = 1/variance: Normal distribution parameterized by precision in Jags
population.variance &lt;- population.sd * population.sd
precision &lt;- 1 / population.variance

# Likelihood
for(i in 1:nobs){
  mass[i] ~ dnorm(population.mean, precision)
 }
 }"

#specifying the initial values
ModelInits &lt;- function()
{list (population.mean = rnorm(1,600,90), population.sd = runif(1, 1, 30))}
params &lt;- c("population.mean", "population.sd", "population.variance")
K&lt;-3
set.seed(1)
Inits&lt;-lapply(1:K,function(x){ModelInits()})

# running runMCMC_btadjust with MCMC_language="Jags":
set.seed(1)
out.mcmc.Coda&lt;-runMCMC_btadjust(MCMC_language="Jags", code=modeltotransfer,
data=ModelData,
Nchains=K, params=params, inits=Inits,
niter.min=1000, niter.max=300000,
nburnin.min=100, nburnin.max=200000,
thin.min=1, thin.max=1000,
neff.min=1000, conv.max=1.05,
control=list(print.diagnostics=TRUE, neff.method="Coda"))

summary(out.mcmc.Coda)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
