<!DOCTYPE html><html lang="en"><head><title>Help for package ttbary</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ttbary}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#drezner'><p>Run an Improved Version of the Algorithm by Drezner, Mehrez and Wesolowsky for Finding Barycenters</p>
Based on Limited Distances</a></li>
<li><a href='#kmeansbary'><p>Compute Pseudo-Barycenter of a List of Point Patterns</p></a></li>
<li><a href='#kmeansbaryeps'><p>Compute Pseudo-Barycenter of a List of Point Patterns (with epsilon-relaxation)</p></a></li>
<li><a href='#kmeansbarynet'><p>Compute Pseudo-Barycenter of a List of Point Patterns on a Network</p></a></li>
<li><a href='#kmeansbaryweightnet'><p>Compute weighted Pseudo-Barycenter of a List of Point Patterns on a Network</p></a></li>
<li><a href='#netsplit'><p>Incorporate Point Patterns into a Network</p></a></li>
<li><a href='#plotmatch'><p>Plot Optimal Matching between Two Point Patterns</p></a></li>
<li><a href='#ppdist'><p>Compute Distance Between Two Point Patterns</p></a></li>
<li><a href='#ppdistnet'><p>Compute Distance Between Two Point Patterns on a Network</p></a></li>
<li><a href='#pplist-data'><p>Simulated Point Pattern Lists</p></a></li>
<li><a href='#sumppdist'><p>Compute Sum of q-th Powers of Distances Between a Point Pattern and a List of Point Patterns</p></a></li>
<li><a href='#sumppdistnet'><p>Compute Sum of q-th Powers of Distances Between a Point Pattern and a Collection of Point Patterns on a Network</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.3-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-11-16</td>
</tr>
<tr>
<td>Title:</td>
<td>Barycenter Methods for Spatial Point Patterns</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dominic Schuhmacher &lt;dominic.schuhmacher@mathematik.uni-goettingen.de&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), spatstat (&ge; 3.0-0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Imports:</td>
<td>spatstat.geom, spatstat.explore, spatstat.model,
spatstat.random, spatstat.linnet, grDevices, graphics, stats,
Rcpp</td>
</tr>
<tr>
<td>Description:</td>
<td>Computes a point pattern in R^2 or on a graph that is representative of a collection of many data patterns. The result is an approximate barycenter (also known as Fréchet mean or prototype) based on a transport-transform metric. Possible choices include Optimal SubPattern Assignment (OSPA) and Spike Time metrics. Details can be found in Müller, Schuhmacher and Mateu (2020) &lt;<a href="https://doi.org/10.1007%2Fs11222-020-09932-y">doi:10.1007/s11222-020-09932-y</a>&gt;.</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-16 10:37:49 UTC; schumi</td>
</tr>
<tr>
<td>Author:</td>
<td>Raoul Müller [aut],
  Dominic Schuhmacher
    <a href="https://orcid.org/0000-0001-7079-6313"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-16 13:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='drezner'>Run an Improved Version of the Algorithm by Drezner, Mehrez and Wesolowsky for Finding Barycenters
Based on Limited Distances</h2><span id='topic+drezner'></span>

<h3>Description</h3>

<p>Find a barycenter of a 2-d point cloud based on minimizing the <code class="reqn">p</code>-th power of the Euclidean 
distance, cut off at <code class="reqn">C=2*\code{penalty}^p</code>. In addition to using a pre-screening procedure to further
alleviate the computational burden of the original algorithm, an option may be specified 
to allow the algorithm to return <code>NA</code> if no location in 2-d space is &quot;good enough&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drezner(clusterx, clustery, penalty, p = 2, reduction = TRUE, aleph = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drezner_+3A_clusterx">clusterx</code>, <code id="drezner_+3A_clustery">clustery</code></td>
<td>
<p>vectors of x- and y-coordinates for the point cloud.</p>
</td></tr>
<tr><td><code id="drezner_+3A_penalty">penalty</code></td>
<td>
<p>the <code class="reqn">p</code>-th power of the Euclidean distance is cut off at <code class="reqn">2 \cdot \code{penalty}^p</code>. 
To cut off at <code class="reqn">C</code>, set <code class="reqn">\code{penalty} = (C/2)^{1/p}</code>.</p>
</td></tr>
<tr><td><code id="drezner_+3A_p">p</code></td>
<td>
<p>the exponent for the distances and cutoffs. <em>Currently only implemented for <code>p=2</code>.</em></p>
</td></tr>
<tr><td><code id="drezner_+3A_reduction">reduction</code></td>
<td>
<p>logical. Shall the pre-screening procedure be applied?</p>
</td></tr>
<tr><td><code id="drezner_+3A_aleph">aleph</code></td>
<td>
<p>logical. Shall the returned value be <code>NA</code> if no good barycenter can be found?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For points <code class="reqn">z_1,\ldots,z_n</code> with <code class="reqn">x</code>-coordinates <code>clusterx</code> and 
<code class="reqn">y</code>-coordinates <code>clustery</code> find a minimizer <code class="reqn">b^*</code> (barycenter) of
</p>
<p style="text-align: center;"><code class="reqn">\gamma(b) = \sum_{i=1}^n \min\{\|z_i-b\|^p, C\}</code>
</p>

<p>or return <code>NA</code> if <code class="reqn">\gamma(b) &gt; \frac{n}{2}C</code> for all <code class="reqn">b \in \mathbf{R}^2</code>.
</p>
<p>The original algorithm is due to Drezner, Mehrez and Wesolowsky (1991). The improvements are from
Müller, Schöbel and Schuhmacher (2022).
</p>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table role = "presentation">
<tr><td><code>barycenterx</code>, <code>barycentery</code></td>
<td>
<p>the <code class="reqn">x</code>- and <code class="reqn">y</code>-coordinates of the barycenter <code class="reqn">b^*</code>
that was found. May both be <code>NA</code> if option <code>aleph=TRUE</code> and no actual barycenter is good
enough.</p>
</td></tr>
<tr><td><code>cost</code></td>
<td>
<p>the total cost <code class="reqn">\gamma(b^*)</code> of the barycenter .</p>
</td></tr>
<tr><td><code>calculations</code></td>
<td>
<p>If <code>reduction=FALSE</code>, the number of point pairs from which the barycenter candidates are calculated. 
Each point pair yields eight candidates.</p>
</td></tr> 
<tr><td><code>skipped</code></td>
<td>
<p>If <code>reduction=TRUE</code>, the number of skipped point pairs
due to the pre-screening procedure.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Raoul Müller  <a href="mailto:raoul.mueller@uni-goettingen.de">raoul.mueller@uni-goettingen.de</a>
</p>


<h3>References</h3>

<p>Zvi Drezner, Avram Mehrez and George O. Wesolowsky (1991).<br />
The facility location problem with limited distances.<br />
Transportation Science 25.3 (1991): 183-187.<br />
www.jstor.org/stable/25768490<br />
<br />
Raoul Müller, Anita Schöbel and Dominic Schuhmacher (2022).<br />
Location problems with cutoff.<br />
Preprint <a href="https://arxiv.org/abs/2203.00910">arXiv:2203.00910</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- rnorm(20)
  y &lt;- rnorm(20)
  plot(x, y, asp=1)
  res &lt;- drezner(x, y, 2)
  points(res$barycenterx, res$barycentery, col=2)
  res &lt;- drezner(x, y, 0.5)
  points(res$barycenterx, res$barycentery, col=4)

</code></pre>

<hr>
<h2 id='kmeansbary'>Compute Pseudo-Barycenter of a List of Point Patterns</h2><span id='topic+kmeansbary'></span>

<h3>Description</h3>

<p>Starting from an initial candidate point pattern <code>zeta</code>, use a k-means-like
algorithm to compute a local minimum in the barycenter problem based on the TT-2 metric
for a list <code>pplist</code> of planar point patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kmeansbary(
  zeta,
  pplist,
  penalty,
  add_del = Inf,
  surplus = 0,
  N = 200L,
  eps = 0.005,
  exact = FALSE,
  verbose = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kmeansbary_+3A_zeta">zeta</code></td>
<td>
<p>a point pattern. Object of class <code>ppp</code> or a list with components <code>x</code> and <code>y</code>.</p>
</td></tr>
<tr><td><code id="kmeansbary_+3A_pplist">pplist</code></td>
<td>
<p>a list of point patterns. Object of class <code>ppplist</code> or any list where each elements
has components  <code>x</code> and <code>y</code>.</p>
</td></tr>
<tr><td><code id="kmeansbary_+3A_penalty">penalty</code></td>
<td>
<p>the penalty for adding/deleting points when computing TT-2 distances.</p>
</td></tr>
<tr><td><code id="kmeansbary_+3A_add_del">add_del</code></td>
<td>
<p>for how many iterations shall the algorithm add points to / delete points from zeta
if this is favorable? Defaults to Inf.</p>
</td></tr>
<tr><td><code id="kmeansbary_+3A_surplus">surplus</code></td>
<td>
<p>by how many points is the barycenter point pattern allowed to be larger than
the largest input point pattern (among pplist and zeta) if add_del &gt; 0.
A larger number increases the computational load.</p>
</td></tr>
<tr><td><code id="kmeansbary_+3A_n">N</code></td>
<td>
<p>the maximum number of iterations.</p>
</td></tr>
<tr><td><code id="kmeansbary_+3A_eps">eps</code></td>
<td>
<p>the algorithm stops if the relative improvement of the objective function between two
iterations is less than eps.</p>
</td></tr>
<tr><td><code id="kmeansbary_+3A_exact">exact</code></td>
<td>
<p>logical. Shall the barycenter of a cluster be calculated exactly by Algorithm 1
of Drezner, Mehrez and Wesolowsky (1991)? In our experience setting <code>exact=TRUE</code>
yields no systematic improvement of the overall objective function value, while the
computation times are substantially larger.</p>
</td></tr>
<tr><td><code id="kmeansbary_+3A_verbose">verbose</code></td>
<td>
<p>the verbosity level. One of 0, 1, 2, 3, where 0 means silent and 3 means full details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given <code class="reqn">k</code> planar point patterns <code class="reqn">\xi_1, \ldots, \xi_k</code> (stored in
<code>pplist</code>), this function finds a local minimizer <code class="reqn">\zeta^*</code> of
</p>
<p style="text-align: center;"><code class="reqn">\sum_{j=1}^k \tau_2(\xi_j, \zeta)^2,</code>
</p>

<p>where <code class="reqn">\tau_2</code> denotes the TT-2 metric based on the Euclidean metric between points.
</p>
<p>Starting from an initial candidate point pattern <code>zeta</code>, the algorithm alternates
between assigning a point from each pattern <code class="reqn">\xi_j</code> to each point of the candidate
and computing new candidate patterns by shifting, adding and deleting points.
A detailed description of the algorithm is given in Müller, Schuhmacher and Mateu (2020).
</p>
<p>For first-time users it is recommended to keep the default values and set <code>penalty</code>
to a noticeable fraction of the diameter of the observation window, e.g. between
0.1 and 0.25 times this diameter.
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<table role = "presentation">
<tr><td><code>cost</code></td>
<td>
<p>the sum of squared TT-2 distances between the computed pseudo-barycenter and the point patterns.</p>
</td></tr>
<tr><td><code>barycenter</code></td>
<td>
<p>the pseudo-barycenter as a <code>ppp</code>-object.</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>the number of iterations required until convergence.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Raoul Müller  <a href="mailto:raoul.mueller@uni-goettingen.de">raoul.mueller@uni-goettingen.de</a><br />
Dominic Schuhmacher <a href="mailto:schuhmacher@math.uni-goettingen.de">schuhmacher@math.uni-goettingen.de</a>
</p>


<h3>References</h3>

<p>Zvi Drezner, Avram Mehrez and George O. Wesolowsky (1991).<br />
The facility location problem with limited distances.<br />
Transportation Science 25.3 (1991): 183-187.<br />
www.jstor.org/stable/25768490<br />
<br />
Raoul Müller, Dominic Schuhmacher and Jorge Mateu (2020).<br />
Statistics and Computing 30, 953-972.<br />
<a href="https://doi.org/10.1007/s11222-020-09932-y">doi:10.1007/s11222-020-09932-y</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kmeansbaryeps">kmeansbaryeps</a></code> for a variant with epsilon relaxation that is typically faster
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pplist_samecard)
plot(superimpose(pplist_samecard), cex=0.7, legend=FALSE,
     xlim=c(-0.2,1.2), ylim=c(-0.1,1.1), main="", use.marks=FALSE) #plotting the data

set.seed(12345)
zeta &lt;- ppp(runif(100), runif(100))
plot(zeta, add=TRUE, col="beige", lwd=2, pch=16) #plotting the start-zeta over the data

res &lt;- kmeansbary(zeta, pplist_samecard, penalty=0.1, add_del=Inf)
plot(res$barycenter, add=TRUE, col="blue", pch=16) #adding the computed barycenter in blue

res$cost
#[1] 30.30387
sumppdist(res$barycenter, pplist_samecard, penalty=0.1, type="tt", p=2, q=2)
#[1] 30.30387
#attr(,"distances")
#[1] 0.5991515 0.6133397 0.6040680 0.6020058 0.5648000 0.6415018 0.6385394 0.5784291 0.5985299
#[10] 0.6313200 0.7186154 ...

</code></pre>

<hr>
<h2 id='kmeansbaryeps'>Compute Pseudo-Barycenter of a List of Point Patterns (with epsilon-relaxation)</h2><span id='topic+kmeansbaryeps'></span>

<h3>Description</h3>

<p>Starting from an initial candidate point pattern <code>zeta</code>, use a k-means-like
algorithm to compute a local minimum in the barycenter problem based on the TT-2 metric
for a list <code>pplist</code> of planar point patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kmeansbaryeps(
  epsvec,
  zeta,
  pplist,
  penalty,
  add_del = Inf,
  surplus = 0,
  relaxVec = c(20, 1, 1, 1),
  N = 200L,
  eps = 0.005,
  exact = FALSE,
  verbose = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kmeansbaryeps_+3A_epsvec">epsvec</code></td>
<td>
<p>a vector containing the values for the relaxed assignment. Last entry should be &lt; 1/n, where n is the largest cardinality among the point 
patterns. Otherwise the algorithm has no guarantee of terminating in a local minimum!
If epsvec[1] is too small, the computational load may be large.
If in doubt, choose c(10^8,10^7,10^6,...,10/(n+1),1/(n+1)).</p>
</td></tr>
<tr><td><code id="kmeansbaryeps_+3A_zeta">zeta</code></td>
<td>
<p>a point pattern. Object of class <code>ppp</code> or a list with components <code>x</code> and <code>y</code>.</p>
</td></tr>
<tr><td><code id="kmeansbaryeps_+3A_pplist">pplist</code></td>
<td>
<p>a list of point patterns. Object of class <code>ppplist</code> or any list where each elements
has components  <code>x</code> and <code>y</code>.</p>
</td></tr>
<tr><td><code id="kmeansbaryeps_+3A_penalty">penalty</code></td>
<td>
<p>the penalty for adding/deleting points when computing TT-2 distances.</p>
</td></tr>
<tr><td><code id="kmeansbaryeps_+3A_add_del">add_del</code></td>
<td>
<p>for how many iterations shall the algorithm add points to / delete points from zeta
if this is favorable? Defaults to Inf.</p>
</td></tr>
<tr><td><code id="kmeansbaryeps_+3A_surplus">surplus</code></td>
<td>
<p>By how many points is the barycenter point pattern allowed to be larger than
the largest input point pattern (among pplist and zeta) if add_del &gt; 0.
A larger number increases the computational load.</p>
</td></tr>
<tr><td><code id="kmeansbaryeps_+3A_relaxvec">relaxVec</code></td>
<td>
<p>a vector of four integers controlling the epsilon-relaxation of the assignments.
See details below.</p>
</td></tr>
<tr><td><code id="kmeansbaryeps_+3A_n">N</code></td>
<td>
<p>the maximum number of iterations.</p>
</td></tr>
<tr><td><code id="kmeansbaryeps_+3A_eps">eps</code></td>
<td>
<p>the algorithm stops if the relative improvement of the objective function between two iterations is less
than eps.</p>
</td></tr>
<tr><td><code id="kmeansbaryeps_+3A_exact">exact</code></td>
<td>
<p>logical. Shall the barycenter of a cluster be calculated exactly by Algorithm 1
of Drezner, Mehrez and Wesolowsky (1991)? In our experience setting <code>exact=TRUE</code>
yields no systematic improvement of the overall objective function value, while the
computation times are substantially larger.</p>
</td></tr>
<tr><td><code id="kmeansbaryeps_+3A_verbose">verbose</code></td>
<td>
<p>the verbosity level. One of 0, 1, 2, 3, where 0 means silent and 3 means full details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given <code class="reqn">k</code> planar point patterns <code class="reqn">\xi_1, \ldots, \xi_k</code> (stored in
<code>pplist</code>), this function finds a local minimizer <code class="reqn">\zeta^*</code> of
</p>
<p style="text-align: center;"><code class="reqn">\sum_{j=1}^k \tau_2(\xi_j, \zeta)^2,</code>
</p>

<p>where <code class="reqn">\tau_2</code> denotes the TT-2 metric based on the Euclidean metric between points.
</p>
<p>Starting from an initial candidate point pattern <code>zeta</code>, the algorithm alternates
between assigning a point from each pattern <code class="reqn">\xi_j</code> to each point of the candidate
and computing new candidate patterns by shifting, adding and deleting points.
A detailed description of the algorithm is given in Müller, Schuhmacher and Mateu (2020).
</p>
<p>For first-time users it is recommended to keep the default values and set <code>penalty</code>
to a noticeable fraction of the diameter of the observation window, e.g. between
0.1 and 0.25 times this diameter.
</p>
<p>The argument <code>relaxVec</code> must be a vector of four integers c(a,b,c,d) &gt; c(0,0,0,0).
For the first <code>a</code> iterations step by step one entry of <code>epsvec</code> is additionally considered in the assignment, starting with
only the first entry in the first iteration. In this <code>a</code> iterations the algorithm can stop if it has improved by less than <code>eps</code> between iterations. 
After <code>a</code> iterations all entries of <code>epsvec</code> before <code>epsvec[b]</code> are ignored and everytime
the algorithm does not improve, the next <code>d</code> entries of epsvec are additionally considered in the following iterations. When the last 
entry of <code>epsvec</code> is considered in the assignments, the entries of epsvec before <code>epsvec[c]</code> are ignored.
<code>relaxVec</code> defaults to c(20,1,1,1) meaning that in every one of the first 20 iterations one additional entry of epsvec
is considered until the algorithm converges. This allows the algorithm to converge before the full epsvec was considered! For further
details see example.
</p>
<p><strong>Warning:</strong> The argument <code>relaxVec</code> offers many different options for controlling the epsilon-relaxation of the assignments
in order to save computation time. But choosing bad parameters may heavily increase the computational load!
If in doubt, go with c(length(epsvec),1,1,1) (see examples).
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<table role = "presentation">
<tr><td><code>cost</code></td>
<td>
<p>the sum of squared TT-2 distances between the computed pseudo-barycenter and the point patterns.</p>
</td></tr>
<tr><td><code>barycenter</code></td>
<td>
<p>the pseudo-barycenter as a <code>ppp</code>-object.</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>the number of iterations required until convergence.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Raoul Müller  <a href="mailto:raoul.mueller@uni-goettingen.de">raoul.mueller@uni-goettingen.de</a><br />
Dominic Schuhmacher <a href="mailto:schuhmacher@math.uni-goettingen.de">schuhmacher@math.uni-goettingen.de</a>
</p>


<h3>References</h3>

<p>Raoul Müller, Dominic Schuhmacher and Jorge Mateu (2020).<br />
Metrics and Barycenters for Point Pattern Data.<br />
Statistics and Computing 30, 953-972.<br />
<a href="https://doi.org/10.1007/s11222-020-09932-y">doi:10.1007/s11222-020-09932-y</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kmeansbary">kmeansbary</a></code> for a similar function that works without epsilon relaxation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pplist_samecard)
plot(superimpose(pplist_samecard), cex=0.7, legend=FALSE,
     xlim=c(-0.2,1.2), ylim=c(-0.1,1.1), main="", use.marks=FALSE) #plotting the data

set.seed(12345)
zeta &lt;- ppp(runif(100),runif(100))
plot(zeta, add=TRUE, col="beige", lwd=2, pch=16) #plotting the start-zeta over the data

epsvec &lt;- c(1e8,1e7,1e6,1e5,1e4,1e3,1e2,10,1,10/101,1/101)

relaxVec1 &lt;- c(length(epsvec),1,1,1) 
#One additional entry of epsvec is considered in each iteration;
#algorithm can stop before full epsvec was used.
#Runs fast with little to no drawback in the quality of the computed solution.
#Time advantage more visible for large datasets.

relaxVec2 &lt;- c(1,1,1,length(epsvec))
#In the first iteration only epsvec[1] is used, after that every assignment is exact.
#Not as fast as the previous version but usually no drawbacks at all in the computed solution.
#Time advantage more visible for large datasets.

relaxVec3 &lt;- c(3,2,3,2)
#in the first 3 iterations epsvec[1],epsvec[1:2],epsvec[1:3] are used in the assignments,
#after that epsvec[2:x] is used, where x starts at 3 (=maximum(a,b)) and increases
#by 2 everytime the algorithm does not improve. When x &gt;= length(epsvec) all assignments
#are done with epsvec[3:length(epsvec)].

res1 &lt;- kmeansbaryeps(epsvec, zeta, pplist_samecard, penalty=0.1, add_del=5, relaxVec = relaxVec1)
res2 &lt;- kmeansbaryeps(epsvec, zeta, pplist_samecard, penalty=0.1, add_del=5, relaxVec = relaxVec2)
res3 &lt;- kmeansbaryeps(epsvec, zeta, pplist_samecard, penalty=0.1, add_del=5, relaxVec = relaxVec3)
plot(res1$barycenter, add=TRUE, col="blue", pch=16) #adding the computed barycenter in blue

</code></pre>

<hr>
<h2 id='kmeansbarynet'>Compute Pseudo-Barycenter of a List of Point Patterns on a Network</h2><span id='topic+kmeansbarynet'></span>

<h3>Description</h3>

<p>Starting from an initial candidate point pattern <code>zeta</code>, use a k-means-like
algorithm to compute a local minimum in the barycenter problem based on the TT-1 metric
for a collection of point patterns on a network. The data needs to be in a special 
form which can be produced with the function <code><a href="#topic+netsplit">netsplit</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kmeansbarynet(dpath, zeta, ppmatrix, penalty, N = 200L, eps = 0.005)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kmeansbarynet_+3A_dpath">dpath</code></td>
<td>
<p>a square matrix whose (<code>i</code>,<code>j</code>)th entry is the shortest-path distance between vertex <code>i</code>
and vertex <code>j</code>. Vertex means either network vertex or data point.</p>
</td></tr>
<tr><td><code id="kmeansbarynet_+3A_zeta">zeta</code></td>
<td>
<p>a vector containing the vertex-indices of the initial candidate for the barycenter.</p>
</td></tr>
<tr><td><code id="kmeansbarynet_+3A_ppmatrix">ppmatrix</code></td>
<td>
<p>a matrix specifying in its columns the vertex-indices of the different data point patterns. A virtual
index that is one greater than the maximum vertex-index can be used to fill up columns so they all have
the same length (see examples).</p>
</td></tr>
<tr><td><code id="kmeansbarynet_+3A_penalty">penalty</code></td>
<td>
<p>the penalty for adding/deleting points when computing TT-1 distances.</p>
</td></tr>
<tr><td><code id="kmeansbarynet_+3A_n">N</code></td>
<td>
<p>the maximum number of iterations.</p>
</td></tr>
<tr><td><code id="kmeansbarynet_+3A_eps">eps</code></td>
<td>
<p>the algorithm stops if the relative improvement of the objective function between two iterations is less
than eps.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given <code class="reqn">k</code> planar point patterns <code class="reqn">\xi_1, \ldots, \xi_k</code> (specified by giving the indices
of their points in the <code class="reqn">k</code> columns of <code>ppmatrix</code>), this function finds a local minimizer <code class="reqn">\zeta^*</code> of
</p>
<p style="text-align: center;"><code class="reqn">\sum_{j=1}^k \tau_1(\xi_j, \zeta),</code>
</p>

<p>where <code class="reqn">\tau_1</code> denotes the TT-1 metric based on the shortest-path metric between points in the network.
</p>
<p>Starting from an initial candidate point pattern <code>zeta</code> (specified by giving the indices
of its points), the algorithm alternates between assigning a point from each pattern <code class="reqn">\xi_j</code>
to each point of the candidate and computing new candidate patterns by shifting points (addition and deletion
of points is currently not implemented).
A detailed description of the algorithm is given in Müller, Schuhmacher and Mateu (2019).
</p>
<p>The most convenient way to obtain objects <code>dpath</code> and <code>ppmatrix</code> of the right form is by calling
<code><a href="#topic+netsplit">netsplit</a></code> and extracting components <code>network$dpath</code> and <code>ppmatrix</code> from the resulting
object (see examples below).
</p>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table role = "presentation">
<tr><td><code>cost</code></td>
<td>
<p>the sum of TT-1 distances between the computed pseudo-barycenter and the point patterns.</p>
</td></tr>
<tr><td><code>barycenter</code></td>
<td>
<p>the pseudo-barycenter as a vector of vertex-indices.</p>
</td></tr>
<tr><td><code>zetalist</code></td>
<td>
<p>a list containing the alternative vertex-indices for each point of the pseudo-barycenter.</p>
</td></tr>
<tr><td><code>barycost</code></td>
<td>
<p>a vector containing the cluster costs for each point of the pseudo-barycenter 
(the alternative indices in <code>zetalist</code> lead to the same cluster cost).</p>
</td></tr> 
<tr><td><code>perm</code></td>
<td>
<p>the permutation matrix for the clusters.</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>the number of iterations required until convergence.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Raoul Müller  <a href="mailto:raoul.mueller@uni-goettingen.de">raoul.mueller@uni-goettingen.de</a><br />
Dominic Schuhmacher <a href="mailto:schuhmacher@math.uni-goettingen.de">schuhmacher@math.uni-goettingen.de</a>
</p>


<h3>References</h3>

<p>Raoul Müller, Dominic Schuhmacher and Jorge Mateu (2019).<br />
Metrics and Barycenters for Point Pattern Data.<br />
Preprint <a href="https://arxiv.org/abs/1909.07266">arXiv:1909.07266</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kmeansbary">kmeansbary</a></code> for a similar function for point patterns in <code class="reqn">R^2</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123456)
nvert &lt;- 100 #number of vertices in the network
npp &lt;- 5 #number of data point patterns
npts &lt;- 40 #number of points per data point pattern
ln &lt;- delaunayNetwork(runifpoint(nvert)) #create an artificial network
ppnetwork &lt;- runiflpp(npts,ln,nsim = npp)
  #simulate npp point patterns with npts points each

plot(ppnetwork[[1]]$domain, cex=0.5, main="")
for (i in 1:npp) {
  plot(as.ppp(ppnetwork[[i]]),vpch=1,col=i,add=TRUE)
     #plotting the point patterns in different colors
}

res &lt;- netsplit(ln, ppnetwork)
  #incorporate data point patterns into the network
  #calculating all pairwise distances between vertices
  #and creating matrix of vertex-indices of data point patterns
  
zeta &lt;- sample(res$nvirtual - 1, median(res$dimensions))
  #sample random vertex-indices in the network
  #taking as cardinality the median of point pattern cardinalities

res2 &lt;- kmeansbarynet(res$network$dpath, zeta, res$ppmatrix, penalty = 0.1)

barycenter &lt;- ppp(res$network$vertices$x[res2$barycenter], res$network$vertices$y[res2$barycenter])
  #construct the barycenter pattern based on the index information in res2
points(barycenter,cex = 1.2, lwd = 2, pch = 4, col = "magenta")
  #add the computed barycenter as magenta crosses

res2$cost
#[1] 18.35171
sumppdistnet(res$network$dpath, res2$barycenter, res$ppmatrix, penalty=0.1, type="tt", p=1, q=1)
#[1] 18.35171
#attr(,"distances")
#[1] 3.666471 3.774709 3.950079 3.841166 3.119284

</code></pre>

<hr>
<h2 id='kmeansbaryweightnet'>Compute weighted Pseudo-Barycenter of a List of Point Patterns on a Network</h2><span id='topic+kmeansbaryweightnet'></span>

<h3>Description</h3>

<p>Starting from an initial candidate point pattern <code>zeta</code>, use a k-means-like
algorithm to compute a local minimum in the barycenter problem based on the TT-1 metric
for a collection of point patterns on a network. The data needs to be in a special 
form which can be produced with the function <code><a href="#topic+netsplit">netsplit</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kmeansbaryweightnet(
  dpath,
  zeta,
  ppmatrix,
  weights,
  penalty,
  N = 200L,
  eps = 0.005
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kmeansbaryweightnet_+3A_dpath">dpath</code></td>
<td>
<p>a square matrix whose (<code>i</code>,<code>j</code>)th entry is the shortest-path distance between vertex <code>i</code>
and vertex <code>j</code>. Vertex means either network vertex or data point.</p>
</td></tr>
<tr><td><code id="kmeansbaryweightnet_+3A_zeta">zeta</code></td>
<td>
<p>a vector containing the vertex-indices of the initial candidate for the barycenter.</p>
</td></tr>
<tr><td><code id="kmeansbaryweightnet_+3A_ppmatrix">ppmatrix</code></td>
<td>
<p>a matrix specifying in its columns the vertex-indices of the different data point patterns. A virtual
index that is one greater than the maximum vertex-index can be used to fill up columns so they all have
the same length (see examples).</p>
</td></tr>
<tr><td><code id="kmeansbaryweightnet_+3A_weights">weights</code></td>
<td>
<p>a vector with weights for each point pattern</p>
</td></tr>
<tr><td><code id="kmeansbaryweightnet_+3A_penalty">penalty</code></td>
<td>
<p>the penalty for adding/deleting points when computing TT-1 distances.</p>
</td></tr>
<tr><td><code id="kmeansbaryweightnet_+3A_n">N</code></td>
<td>
<p>the maximum number of iterations.</p>
</td></tr>
<tr><td><code id="kmeansbaryweightnet_+3A_eps">eps</code></td>
<td>
<p>the algorithm stops if the relative improvement of the objective function between two iterations is less
than eps.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given <code class="reqn">k</code> planar point patterns <code class="reqn">\xi_1, \ldots, \xi_k</code> (specified by giving the indices
of their points in the <code class="reqn">k</code> columns of <code>ppmatrix</code>), this function finds a local minimizer <code class="reqn">\zeta^*</code> of
</p>
<p style="text-align: center;"><code class="reqn">\sum_{j=1}^k \tau_1(\xi_j, \zeta),</code>
</p>

<p>where <code class="reqn">\tau_1</code> denotes the TT-1 metric based on the shortest-path metric between points in the network.
</p>
<p>Starting from an initial candidate point pattern <code>zeta</code> (specified by giving the indices
of its points), the algorithm alternates between assigning a point from each pattern <code class="reqn">\xi_j</code>
to each point of the candidate and computing new candidate patterns by shifting points (addition and deletion
of points is currently not implemented).
A detailed description of the algorithm is given in Müller, Schuhmacher and Mateu (2019).
</p>
<p>The most convenient way to obtain objects <code>dpath</code> and <code>ppmatrix</code> of the right form is by calling
<code><a href="#topic+netsplit">netsplit</a></code> and extracting components <code>network$dpath</code> and <code>ppmatrix</code> from the resulting
object (see examples below).
</p>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table role = "presentation">
<tr><td><code>cost</code></td>
<td>
<p>the sum of TT-1 distances between the computed pseudo-barycenter and the point patterns.</p>
</td></tr>
<tr><td><code>barycenter</code></td>
<td>
<p>the pseudo-barycenter as a vector of vertex-indices.</p>
</td></tr>
<tr><td><code>zetalist</code></td>
<td>
<p>a list containing the alternative vertex-indices for each point of the pseudo-barycenter.</p>
</td></tr>
<tr><td><code>barycost</code></td>
<td>
<p>a vector containing the cluster costs for each point of the pseudo-barycenter 
(the alternative indices in <code>zetalist</code> lead to the same cluster cost).</p>
</td></tr> 
<tr><td><code>perm</code></td>
<td>
<p>the permutation matrix for the clusters.</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>the number of iterations required until convergence.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Raoul Müller  <a href="mailto:raoul.mueller@uni-goettingen.de">raoul.mueller@uni-goettingen.de</a><br />
Dominic Schuhmacher <a href="mailto:schuhmacher@math.uni-goettingen.de">schuhmacher@math.uni-goettingen.de</a>
</p>


<h3>References</h3>

<p>Raoul Müller, Dominic Schuhmacher and Jorge Mateu (2019).<br />
Metrics and Barycenters for Point Pattern Data.<br />
Preprint <a href="https://arxiv.org/abs/1909.07266">arXiv:1909.07266</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kmeansbary">kmeansbary</a></code> for a similar function for point patterns in <code class="reqn">R^2</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123456)
nvert &lt;- 100 #number of vertices in the network
npp &lt;- 5 #number of data point patterns
npts &lt;- 40 #number of points per data point pattern
ln &lt;- delaunayNetwork(runifpoint(nvert)) #create an artificial network
ppnetwork &lt;- runiflpp(npts,ln,nsim = npp)
  #simulate npp point patterns with npts points each

plot(ppnetwork[[1]]$domain, cex=0.5, main="")
for (i in 1:npp) {
  plot(as.ppp(ppnetwork[[i]]),vpch=1,col=i,add=TRUE)
     #plotting the point patterns in different colors
}

res &lt;- netsplit(ln, ppnetwork)
  #incorporate data point patterns into the network
  #calculating all pairwise distances between vertices
  #and creating matrix of vertex-indices of data point patterns
  
zeta &lt;- sample(res$nvirtual - 1, median(res$dimensions))
  #sample random vertex-indices in the network
  #taking as cardinality the median of point pattern cardinalities

res2 &lt;- kmeansbaryweightnet(res$network$dpath, zeta, res$ppmatrix, 
                            weights = c(1,2,3,2,1), penalty = 0.1)

barycenter &lt;- ppp(res$network$vertices$x[res2$barycenter], res$network$vertices$y[res2$barycenter])
  #construct the barycenter pattern based on the index information in res2
points(barycenter,cex = 1.2, lwd = 2, pch = 4, col = "magenta")
  #add the computed barycenter as magenta crosses

res2$cost
#[1] 18.35171
sumppdistnet(res$network$dpath, res2$barycenter, res$ppmatrix, penalty=0.1, type="tt", p=1, q=1)
#[1] 18.35171
#attr(,"distances")
#[1] 3.666471 3.774709 3.950079 3.841166 3.119284

</code></pre>

<hr>
<h2 id='netsplit'>Incorporate Point Patterns into a Network</h2><span id='topic+netsplit'></span>

<h3>Description</h3>

<p>Given a network and a list of point patterns on this network, create a new network from all the
vertices of the original network plus all the points in the patterns, splitting any edges that
contain such points into several shorter edges. This function keeps track which vertex-indices 
represent each of the data point patterns. The returned object contains all the components
needed for a call to <code><a href="#topic+kmeansbarynet">kmeansbarynet</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netsplit(network, pplist)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="netsplit_+3A_network">network</code></td>
<td>
<p>an object of class <code>linnet</code> or <code>lpp</code>. In the latter case the <code>domain</code>
component is extracted and any points of the <code>lpp</code> are ignored.</p>
</td></tr>
<tr><td><code id="netsplit_+3A_pplist">pplist</code></td>
<td>
<p>a list containing (at least) <code>x</code>- and <code>y</code>-coordinates of the point patterns,
which will be projected onto the network</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function relies heavily on code from the package <code>spatstat</code> to create the
new network and efficiently compute all pairwise shortest-path distances between
the new vertices.
</p>
<p>If not all point patterns are of the same size, this function fills up the vertex-indices
of the smaller patterns with a virtual index that is one larger than the maximal
index appearing in the new network. This structure is required for 
calling <code><a href="#topic+kmeansbarynet">kmeansbarynet</a></code>.
</p>


<h3>Value</h3>

<p>A list containing the following components:
</p>
<table role = "presentation">
<tr><td><code>network</code></td>
<td>
<p>the new network with all the points added as vertices. Contains also the matrix
of shortest-path distances between all these points.</p>
</td></tr>
<tr><td><code>ppmatrix</code></td>
<td>
<p>a matrix containing the new vertex-indices of the data point patterns, one column corresponds to one point pattern.</p>
</td></tr> 
<tr><td><code>dimensions</code></td>
<td>
<p>a vector containing the cardinalities of the data point patterns.</p>
</td></tr> 
<tr><td><code>nvirtual</code></td>
<td>
<p>the index of the virtual point.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Raoul Müller  <a href="mailto:raoul.mueller@uni-goettingen.de">raoul.mueller@uni-goettingen.de</a><br />
Dominic Schuhmacher <a href="mailto:schuhmacher@math.uni-goettingen.de">schuhmacher@math.uni-goettingen.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kmeansbarynet">kmeansbarynet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See the example for kmeansbarynet.

</code></pre>

<hr>
<h2 id='plotmatch'>Plot Optimal Matching between Two Point Patterns</h2><span id='topic+plotmatch'></span>

<h3>Description</h3>

<p>After calling <code><a href="#topic+ppdist">ppdist</a></code> with argument <code>ret_matching = TRUE</code>
in a situation where it makes sense to assign to the points of the patterns <code class="reqn">\xi</code>
and <code class="reqn">\eta</code> coordinates in <code class="reqn">R^2</code>, this function may be used to display
the result graphically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotmatch(
  xi,
  eta,
  dmat,
  res,
  penalty,
  p = 1,
  cols = c(2, 4),
  pchs = c(1, 1),
  cexs = c(1, 1),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotmatch_+3A_xi">xi</code>, <code id="plotmatch_+3A_eta">eta</code></td>
<td>
<p>objects of class <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code>.</p>
</td></tr>
<tr><td><code id="plotmatch_+3A_dmat">dmat</code></td>
<td>
<p>a matrix specifying in its <code class="reqn">(i,j)</code>-th entry the distance from the
i-th point of <code class="reqn">\xi</code> to the j-th point of <code class="reqn">\eta</code>.</p>
</td></tr>
<tr><td><code id="plotmatch_+3A_res">res</code></td>
<td>
<p>the object returned by the call to <code><a href="#topic+ppdist">ppdist</a></code> with <code>ret_matching = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotmatch_+3A_penalty">penalty</code></td>
<td>
<p>a positive number. The penalty for adding/deleting points.</p>
</td></tr>
<tr><td><code id="plotmatch_+3A_p">p</code></td>
<td>
<p>a number <code class="reqn">&gt;0</code>. The order of the TT- or RTT-distance computed.</p>
</td></tr>
<tr><td><code id="plotmatch_+3A_cols">cols</code>, <code id="plotmatch_+3A_pchs">pchs</code>, <code id="plotmatch_+3A_cexs">cexs</code></td>
<td>
<p>vectors of length 2 specifying the corresponding graphic 
parameters col, pch and cex for plotting the two point patterns.</p>
</td></tr>
<tr><td><code id="plotmatch_+3A_...">...</code></td>
<td>
<p>further graphic parameters passed to the code that draws the line segments
between the points.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default use-case is to plot a matching obtained with <code><a href="#topic+ppdist">ppdist</a></code>.
In that case <code>dmat</code>, <code>penalty</code> and <code>p</code> should be the same
as in the call to <code>ppdist</code>. These objects are used to display additional
information about the matching.
</p>


<h3>Value</h3>

<p>Used for the side effect of plotting.
</p>


<h3>Author(s)</h3>

<p>Dominic Schuhmacher <a href="mailto:schuhmacher@math.uni-goettingen.de">schuhmacher@math.uni-goettingen.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppdist">ppdist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # See examples for ppdist

</code></pre>

<hr>
<h2 id='ppdist'>Compute Distance Between Two Point Patterns</h2><span id='topic+ppdist'></span><span id='topic+ttdist'></span>

<h3>Description</h3>

<p>Based on an arbitrary matrix of &quot;distances&quot; between the points of two point patterns
<code class="reqn">\xi</code> and <code class="reqn">\eta</code>, this function computes versions of the transport-transform
distance between <code class="reqn">\xi</code> and <code class="reqn">\eta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppdist(
  dmat,
  penalty = 1,
  type = c("tt", "rtt", "TT", "RTT"),
  ret_matching = FALSE,
  p = 1,
  precision = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ppdist_+3A_dmat">dmat</code></td>
<td>
<p>a matrix specifying in its <code class="reqn">(i,j)</code>-th entry the distance from the
i-th point of <code class="reqn">\xi</code> to the j-th point of <code class="reqn">\eta</code>.</p>
</td></tr>
<tr><td><code id="ppdist_+3A_penalty">penalty</code></td>
<td>
<p>a positive number. The penalty for adding/deleting points.</p>
</td></tr>
<tr><td><code id="ppdist_+3A_type">type</code></td>
<td>
<p>either <code>"tt"</code>/<code>"TT"</code> for the transport-transform metric
or <code>"rtt"</code>/<code>"RTT"</code> for the relative transport-transform metric.</p>
</td></tr>
<tr><td><code id="ppdist_+3A_ret_matching">ret_matching</code></td>
<td>
<p>logical. Shall the optimal point matching be returned?</p>
</td></tr>
<tr><td><code id="ppdist_+3A_p">p</code></td>
<td>
<p>a number <code class="reqn">&gt;0</code>. The matching is chosen such that the <code>p</code>-th
order sum (<code class="reqn">\ell_p</code>-norm) is minimized.</p>
</td></tr>
<tr><td><code id="ppdist_+3A_precision">precision</code></td>
<td>
<p>a small positive integer value. The precisions of the computations, which
are currently performed in integers. After correcting for the penalty, <code>dmat^p</code>
is divided by its largest entry, multiplied by <code>10^precision</code> and rounded to
compute the optimal matching. The default value <code>NULL</code> chooses maximal
integer precision possible, which is <code>precision = 9</code> on almost all systems.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The transport-transform (TT) distance gives the minimal total cost for &ldquo;morphing&rdquo;
the pattern <code class="reqn">\xi</code> into the pattern <code class="reqn">\eta</code> by way of shifting points (at costs
specified in <code>dmat</code>) and adding or deleting points (each at cost <code>penalty</code>).
The total cost is determined as 
</p>
<p style="text-align: center;"><code class="reqn">\biggl( \sum_{j=1}^n c_j^p \biggr)^{1/p},</code>
</p>

<p>where <code class="reqn">c_j</code> denotes the cost for the <code class="reqn">j</code>th individual operation and <code class="reqn">n</code> is
the cardinality of the larger point pattern.  
</p>
<p>The relative transport-transform (RTT) metric is exactly the same, but the sum in the
total cost is divided by the larger cardinality:
</p>
<p style="text-align: center;"><code class="reqn">\biggl( \frac{1}{n}\sum_{j=1}^n c_j^p \biggr)^{1/p}.</code>
</p>

<p>The TT- and RTT-metrics form an umbrella concept that    
includes the OSPA and Spike Time metrics frequently used in the literature.
See Müller, Schuhmacher and Mateu (2020) for details.
</p>


<h3>Value</h3>

<p>The corresponding distance between the point patterns if <code>ret_matching</code>
is <code>FALSE</code>. 
</p>
<p>Otherwise a list with components <code>dist</code> containing
this distance and two vectors <code>target1, target2</code> of integers, where
<code>target</code><code class="reqn">i</code> specifies the indices of the points in the other pattern
that the points of the <code class="reqn">i</code>-th pattern are matched to and <code>NA</code> every
time a point is deleted.
</p>
<p>There may be a minus in front of an index, where
<code>-j</code> indicates that the corresponding pairing with point <code>j</code>
would be over a distance of more than <code class="reqn">2^{1/p} \cdot 
        \code{penalty}</code>. This is 
equivalent to saying that the corresponding point of the first pattern
is deleted and the <code class="reqn">j</code>-th point of the second pattern is added. 
</p>
<p>Note that having more than one minus implies that the matching is non-unique.
</p>


<h3>Author(s)</h3>

<p>Dominic Schuhmacher <a href="mailto:schuhmacher@math.uni-goettingen.de">schuhmacher@math.uni-goettingen.de</a>
</p>


<h3>References</h3>

<p>Raoul Müller, Dominic Schuhmacher and Jorge Mateu (2020).<br />
Metrics and Barycenters for Point Pattern Data.<br />
Statistics and Computing 30, 953-972.<br />
<a href="https://doi.org/10.1007/s11222-020-09932-y">doi:10.1007/s11222-020-09932-y</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # small example
  # -------------
  set.seed(181230)
  xi &lt;- spatstat.random::rpoispp(20)
  eta &lt;- spatstat.random::rpoispp(20)
  dmat &lt;- spatstat.geom::crossdist(xi,eta)
  res &lt;- ppdist(dmat, penalty=1,  type="rtt", ret_matching=TRUE, p=1)
  plotmatch(xi, eta, dmat, res, penalty=1, p=1)
  res$dist

  # for comparison: ospa-distance computation from spatstat:
  res_ospa &lt;- spatstat.geom::pppdist(xi,eta,"spa")
  res_ospa$distance  # exactly the same as above because nothing gets cut off 


  # same example, but with a much smaller penalty for adding/deleting points
  # --------------------------------------------------------------- 
  res &lt;- ppdist(dmat, penalty=0.1,  type="rtt", ret_matching=TRUE, p=1)
  plotmatch(xi, eta, dmat, res, penalty=0.1, p=1)
    # dashed lines indicate points that are deleted and re-added at new position
    # grey segments on dashed lines indicate the cost of deletion plus re-addition
  res$dist
  
  # for comparison: ospa-distance computation from spatstat
  # (if things do get cut off, we have to ensure that the cutoff distances
  # are the same, thus cutoff = 2^(1/p) * penalty):
  res_ospa &lt;- spatstat.geom::pppdist(xi,eta,"spa",cutoff=0.2)
  res_ospa$distance  # NOT the same as above
  res_ospa$distance - abs(xi$n-eta$n) * 0.1 / max(xi$n,eta$n)  # the same as above
  
  
  # a larger example
  # --------------------------------------------------------------- 
  set.seed(190203)
  xi &lt;- spatstat.random::rpoispp(2000)
  eta &lt;- spatstat.random::rpoispp(2000)
  dmat &lt;- spatstat.geom::crossdist(xi,eta)
  res &lt;- ppdist(dmat, penalty = 0.1,  type = "rtt", ret_matching = TRUE, p = 1)
  res$dist
  # takes about 2-3 seconds

</code></pre>

<hr>
<h2 id='ppdistnet'>Compute Distance Between Two Point Patterns on a Network</h2><span id='topic+ppdistnet'></span><span id='topic+ttdistnet'></span>

<h3>Description</h3>

<p>Based on an arbitrary matrix of &quot;distances&quot; on a network, this function computes versions
of the transport-transform distance between two point patterns <code class="reqn">\xi</code> and <code class="reqn">\eta</code>
on this network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppdistnet(
  dmat,
  xi = NULL,
  eta = NULL,
  penalty = 1,
  type = c("tt", "rtt", "TT", "RTT"),
  ret_matching = FALSE,
  p = 1,
  precision = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ppdistnet_+3A_dmat">dmat</code></td>
<td>
<p>a matrix specifying in its <code class="reqn">(i,j)</code>-th entry the shortest-path distance from the
i-th point of <code class="reqn">\xi</code> to the j-th point of  <code class="reqn">\eta</code>
OR the distance matrix of a whole network. In the latter case arguments <code class="reqn">\xi</code> and
<code class="reqn">\eta</code> have to be specified.</p>
</td></tr>
<tr><td><code id="ppdistnet_+3A_xi">xi</code></td>
<td>
<p>a vector specifying the vertex-indices of <code class="reqn">\xi</code>, only needed if <code>dmat</code> is the 
distance matrix of a whole network.</p>
</td></tr>
<tr><td><code id="ppdistnet_+3A_eta">eta</code></td>
<td>
<p>a vector specifying the vertex-indices of <code class="reqn">\eta</code>, only needed if <code>dmat</code> is the 
distance matrix of a whole network.</p>
</td></tr>
<tr><td><code id="ppdistnet_+3A_penalty">penalty</code></td>
<td>
<p>a positive number. The penalty for adding/deleting points.</p>
</td></tr>
<tr><td><code id="ppdistnet_+3A_type">type</code></td>
<td>
<p>either <code>"tt"</code>/<code>"TT"</code> for the transport-transform metric
or <code>"rtt"</code>/<code>"RTT"</code> for the relative transport-transform metric.</p>
</td></tr>
<tr><td><code id="ppdistnet_+3A_ret_matching">ret_matching</code></td>
<td>
<p>Logical. Shall the optimal point matching be returned?</p>
</td></tr>
<tr><td><code id="ppdistnet_+3A_p">p</code></td>
<td>
<p>a number <code class="reqn">&gt;0</code>. The matching is chosen such that the <code>p</code>-th
order sum (<code class="reqn">\ell_p</code>-norm) is minimized.</p>
</td></tr>
<tr><td><code id="ppdistnet_+3A_precision">precision</code></td>
<td>
<p>a small positive integer value. The precision of the computations, which
are currently performed in integers. After correcting for the penalty, <code>dmat^p</code>
is divided by its largest entry, multiplied by <code>10^precision</code> and rounded to
compute the optimal matching. The default value <code>NULL</code> chooses maximal
integer precision possible, which is <code>precision = 9</code> on almost all systems.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides a more convenient way for computing (relative)
transport-transform distances on networks if the points of the patterns are given in
terms of indices of network vertices. If <code>dmat</code> contains only the distances
between the points of <code class="reqn">\xi</code> and <code class="reqn">\eta</code>, this function
does the same as <code><a href="#topic+ppdist">ppdist</a></code>.
</p>


<h3>Value</h3>

<p>The corresponding distance between the point patterns if <code>ret_matching</code>
is <code>FALSE</code>. 
</p>
<p>Otherwise a list with components <code>dist</code> containing
this distance and two vectors <code>target1, target2</code> of integers, where
<code>target</code><code class="reqn">i</code> specifies the indices of the points in the other pattern
that the points of the <code class="reqn">i</code>-th pattern are matched to and <code>NA</code> every
time a point is deleted.
</p>
<p>There may be a minus in front of an index, where
<code>-j</code> indicates that the corresponding pairing with point <code>j</code>
would be over a distance of more than <code class="reqn">2^{1/p} \cdot 
        \code{penalty}</code>. This is 
equivalent to saying that the corresponding point of the first pattern
is deleted and the <code class="reqn">j</code>-th point of the second pattern is added. 
</p>
<p>Note that having more than one minus implies that the matching is non-unique.
</p>


<h3>Author(s)</h3>

<p>Raoul Müller  <a href="mailto:raoul.mueller@uni-goettingen.de">raoul.mueller@uni-goettingen.de</a><br />
Dominic Schuhmacher <a href="mailto:schuhmacher@math.uni-goettingen.de">schuhmacher@math.uni-goettingen.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppdist">ppdist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  set.seed(123456)
  nvert &lt;- 100 #number of vertices in the network
  lambda &lt;- 0.5 #expected number of points per unit length
  ln &lt;- delaunayNetwork(runifpoint(nvert)) #create an artificial network
  ppnetwork &lt;- rpoislpp(lambda, ln, nsim = 2)
    #simulate two point patterns on the network

  plot(ppnetwork[[1]]$domain, cex=0.5, main="")
  plot(as.ppp(ppnetwork[[1]]),vpch=1,col=2,add=TRUE)
  plot(as.ppp(ppnetwork[[2]]),vpch=1,col=4,add=TRUE)

  res &lt;- netsplit(ln, ppnetwork)
    #incorporate data point patterns into the network
    #calculating all pairwise distances between vertices
    #and creating matrix of vertex-indices of data point patterns
  
  xi &lt;- res$ppmatrix[1:npoints(ppnetwork[[1]]), 1]
  eta &lt;- res$ppmatrix[1:npoints(ppnetwork[[2]]), 2]
  res2 &lt;- ppdistnet(res$network$dpath, xi = xi, eta = eta,
                    penalty = 1, type = "tt", ret_matching = TRUE, p = 1)
  res2

</code></pre>

<hr>
<h2 id='pplist-data'>Simulated Point Pattern Lists</h2><span id='topic+pplist-data'></span><span id='topic+pplist_samecard'></span><span id='topic+pplist_diffcard'></span>

<h3>Description</h3>

<p>Lists of simulated point patterns for illustrating the computation of barycenters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pplist_samecard

pplist_diffcard
</code></pre>


<h3>Format</h3>

<p>Objects of class <code>pplist</code>, which are essentially lists of <code>ppp</code>-objects.
</p>
<p>An object of class <code>ppplist</code> (inherits from <code>solist</code>, <code>anylist</code>, <code>listof</code>, <code>list</code>) of length 80.
</p>
<p>An object of class <code>ppplist</code> (inherits from <code>solist</code>, <code>anylist</code>, <code>listof</code>, <code>list</code>) of length 50.
</p>


<h3>Details</h3>

<p><code>pplist_samecard</code> contains 80 point patterns of 100 points each. The patterns
were independently generated from a distribution that creates quite distinctive clusters.
</p>
<p><code>pplist_diffcard</code> contains 50 point patterns with cardinalities ranging from 17 to 42. 
The patterns were independently generated from a distribution that creates overlapping clusters.
</p>


<h3>Author(s)</h3>

<p>Raoul Müller  <a href="mailto:raoul.mueller@uni-goettingen.de">raoul.mueller@uni-goettingen.de</a><br />
Dominic Schuhmacher <a href="mailto:schuhmacher@math.uni-goettingen.de">schuhmacher@math.uni-goettingen.de</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># plot the first eight patterns of each data set
plot(superimpose(pplist_samecard[1:8]), legend=FALSE, cex=0.4, cols=1:8)
plot(superimpose(pplist_diffcard[1:8]), legend=FALSE, cex=0.4, cols=1:8)
              
</code></pre>

<hr>
<h2 id='sumppdist'>Compute Sum of q-th Powers of Distances Between a Point Pattern and a List of Point Patterns</h2><span id='topic+sumppdist'></span>

<h3>Description</h3>

<p>Determine the Euclidean distance based TT-p-distances (or RTT-p-distances) between
a single point pattern <code>zeta</code> and each point pattern in a list <code>pplist</code>. Then
compute the sum of <code class="reqn">q</code>-th powers of these distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sumppdist(
  zeta,
  pplist,
  penalty = 1,
  type = c("tt", "rtt", "TT", "RTT"),
  p = 1,
  q = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sumppdist_+3A_zeta">zeta</code></td>
<td>
<p>an object of class <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code>.</p>
</td></tr>
<tr><td><code id="sumppdist_+3A_pplist">pplist</code></td>
<td>
<p>an object of class <code><a href="spatstat.geom.html#topic+solist">ppplist</a></code> or an 
object that can be coerced to this class, such as a list of <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code>
objects.</p>
</td></tr>
<tr><td><code id="sumppdist_+3A_penalty">penalty</code></td>
<td>
<p>a positive number. The penalty for adding/deleting points.</p>
</td></tr>
<tr><td><code id="sumppdist_+3A_type">type</code></td>
<td>
<p>either <code>"tt"</code>/<code>"TT"</code> for the transport-transform metric
or <code>"rtt"</code>/<code>"RTT"</code> for the relative transport-transform metric.</p>
</td></tr>
<tr><td><code id="sumppdist_+3A_p">p</code></td>
<td>
<p>a number <code class="reqn">&gt;0</code>. Matchings between <code>zeta</code> and the patterns in
<code>pplist</code> are chosen such that the <code>p</code>-th order sums (<code class="reqn">\ell_p</code>-norms)
of the Euclidean distances are minimized.</p>
</td></tr>
<tr><td><code id="sumppdist_+3A_q">q</code></td>
<td>
<p>a number <code class="reqn">&gt;0</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main purpose of this function is to evaluate the relative performance
of approximate <code class="reqn">q</code>-th order barycenters of point patterns. A true 
<code class="reqn">q</code>-th order barycenter of the point patterns <code class="reqn">\xi_1,\ldots,\xi_k</code>
with respect to the TT-p metric <code class="reqn">\tau_p</code> minimizes 
</p>
<p style="text-align: center;"><code class="reqn">\sum_{j=1}^k \tau_p(\xi_j, \zeta)^q</code>
</p>

<p>in <code class="reqn">\zeta</code>.      
</p>
<p>The most common choices are <code>p = q = 1</code> and <code>p = q = 2</code>. Other
choices have not been tested.
</p>


<h3>Value</h3>

<p>A nonnegative number, the <code>q</code>-th order sum of the TT-p- or RTT-p-distances 
between <code>zeta</code> and each pattern in <code>pplist</code>. This number has an attribute
<code>distances</code> that contains the individual distances.
</p>


<h3>Author(s)</h3>

<p>Dominic Schuhmacher <a href="mailto:schuhmacher@math.uni-goettingen.de">schuhmacher@math.uni-goettingen.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppdist">ppdist</a></code> for computation of TT-p- and RTT-p-metrics,<br />
<code><a href="#topic+kmeansbary">kmeansbary</a></code> for finding a local minimum of the above sum for <code>p = q = 2</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # See the examples for kmeansbary
  
</code></pre>

<hr>
<h2 id='sumppdistnet'>Compute Sum of q-th Powers of Distances Between a Point Pattern and a Collection of Point Patterns on a Network</h2><span id='topic+sumppdistnet'></span>

<h3>Description</h3>

<p>Based on the shortest-path metric in a network, determine the TT-p-distances (or RTT-p-distances) 
between a single point pattern <code>zeta</code> and a collection of point patterns. Then
compute the sum of <code class="reqn">q</code>-th powers of these distances. The point patterns are
specified by vectors of indices referring to the vertices in the network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sumppdistnet(
  dmat,
  zeta,
  ppmatrix,
  penalty = 1,
  type = c("tt", "rtt", "TT", "RTT"),
  p = 1,
  q = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sumppdistnet_+3A_dmat">dmat</code></td>
<td>
<p>the distance matrix of a network containing all shortest-path distances between its vertices.</p>
</td></tr>
<tr><td><code id="sumppdistnet_+3A_zeta">zeta</code></td>
<td>
<p>a vector specifying the vertex-indices of zeta.</p>
</td></tr>
<tr><td><code id="sumppdistnet_+3A_ppmatrix">ppmatrix</code></td>
<td>
<p>a matrix specifying in its columns the vertex-indices of the point patterns in the collection.
A virtual index that is one greater than the maximum vertex-index in the network
can be used to fill up columns so that they all have the same length.</p>
</td></tr>
<tr><td><code id="sumppdistnet_+3A_penalty">penalty</code></td>
<td>
<p>a positive number. The penalty for adding/deleting points.</p>
</td></tr>
<tr><td><code id="sumppdistnet_+3A_type">type</code></td>
<td>
<p>either <code>"tt"</code>/<code>"TT"</code> for the transport-transform metric
or <code>"rtt"</code>/<code>"RTT"</code> for the relative transport-transform metric.</p>
</td></tr>
<tr><td><code id="sumppdistnet_+3A_p">p</code></td>
<td>
<p>a number <code class="reqn">&gt;0</code>. Matchings between <code>zeta</code> and the patterns in
<code>ppmatrix</code> are chosen such that the <code>p</code>-th order sums (<code class="reqn">\ell_p</code>-norms)
of the shortest-path distances are minimized.</p>
</td></tr>
<tr><td><code id="sumppdistnet_+3A_q">q</code></td>
<td>
<p>a number <code class="reqn">&gt;0</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main purpose of this function is to evaluate the relative performance
of approximate <code class="reqn">q</code>-th order barycenters of point patterns. A true 
<code class="reqn">q</code>-th order barycenter of the point patterns <code class="reqn">\xi_1,\ldots,\xi_k</code>
with respect to the TT-p metric <code class="reqn">\tau_p</code> minimizes 
</p>
<p style="text-align: center;"><code class="reqn">\sum_{j=1}^k \tau_p(\xi_j, \zeta)^q</code>
</p>

<p>in <code class="reqn">\zeta</code>.      
</p>
<p>The most common choices are <code>p = q = 1</code> and <code>p = q = 2</code>. Other
choices have not been tested.
</p>


<h3>Value</h3>

<p>A nonnegative number, the <code>q</code>-th order sum of the TT-p- or RTT-p-distances 
between the patterns represented by <code>zeta</code> and <code>ppmatrix</code>. This number has an attribute
<code>distances</code> that contains the individual distances.
</p>


<h3>Author(s)</h3>

<p>Raoul Müller  <a href="mailto:raoul.mueller@uni-goettingen.de">raoul.mueller@uni-goettingen.de</a><br />
Dominic Schuhmacher <a href="mailto:schuhmacher@math.uni-goettingen.de">schuhmacher@math.uni-goettingen.de</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+kmeansbarynet">kmeansbarynet</a></code>, <code><a href="#topic+sumppdist">sumppdist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # See examples for kmeansbarynet
  
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
