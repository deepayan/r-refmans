<!DOCTYPE html><html><head><title>Help for package sbw</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sbw}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#estimate'><p>Estimate causal contrasts and population means</p></a></li>
<li><a href='#lalonde'><p>The Lalonde data set</p></a></li>
<li><a href='#sbw'><p>Stable balancing weights for causal contrasts and population means.</p></a></li>
<li><a href='#summarize'><p>Summarize output from <code>sbw</code></p></a></li>
<li><a href='#visualize'><p>Visualize output from <code>sbw</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-09-21</td>
</tr>
<tr>
<td>Title:</td>
<td>Stable Balancing Weights for Causal Inference and Missing Data</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jose R. Zubizarreta &lt;zubizarreta@hcp.med.harvard.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2), Matrix, quadprog, slam</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, spatstat.geom</td>
</tr>
<tr>
<td>Enhances:</td>
<td>gurobi, Rcplex, Rmosek, pogs, osqp</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the Stable Balancing Weights by Zubizarreta (2015) &lt;<a href="https://doi.org/10.1080%2F01621459.2015.1023805">doi:10.1080/01621459.2015.1023805</a>&gt;. These are the weights of minimum variance that approximately balance the empirical distribution of the observed covariates. For an overview, see Chattopadhyay, Hase and Zubizarreta (2020) &lt;<a href="https://doi.org/10.1002%2F%28ISSN%291097-0258">doi:10.1002/(ISSN)1097-0258</a>&gt;. To solve the optimization problem in 'sbw', the default solver is 'quadprog', which is readily available through CRAN. The solver 'osqp' is also posted on CRAN. To enhance the performance of 'sbw', users are encouraged to install other solvers such as 'gurobi' and 'Rmosek', which require special installation. For the installation of gurobi and pogs, please follow the instructions at <a href="https://www.gurobi.com/documentation/9.1/quickstart_mac/r_ins_the_r_package.html">https://www.gurobi.com/documentation/9.1/quickstart_mac/r_ins_the_r_package.html</a> and <a href="http://foges.github.io/pogs/stp/r">http://foges.github.io/pogs/stp/r</a>.</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-09-21 20:35:24 UTC; yige</td>
</tr>
<tr>
<td>Author:</td>
<td>Jose R. Zubizarreta [aut, cre],
  Yige Li [aut],
  Kwangho Kim [aut],
  Amine Allouah [ctb],
  Noah Greifer [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-09-22 08:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='estimate'>Estimate causal contrasts and population means</h2><span id='topic+estimate'></span>

<h3>Description</h3>

<p>Function for estimating causal contrasts and population means using the output from <code><a href="#topic+sbw">sbw</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate(object, out = NULL, digits = 6, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_+3A_object">object</code></td>
<td>
<p>an object from function <code><a href="#topic+sbw">sbw</a></code>.</p>
</td></tr>
<tr><td><code id="estimate_+3A_out">out</code></td>
<td>
<p>outcome, a vector of strings with the names of the outcome variables. The default is the <code>out</code> argument from the <code>object</code>.</p>
</td></tr>
<tr><td><code id="estimate_+3A_digits">digits</code></td>
<td>
<p>a scalar with the number of significant digits used to display the estimates. The default is <code>6</code>.</p>
</td></tr>
<tr><td><code id="estimate_+3A_...">...</code></td>
<td>
<p>ignored arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An estimate for the estimand of interest. 
The standard error is calculated by robust sandwich variance estimator.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Please see the examples in the function sbw below.
</code></pre>

<hr>
<h2 id='lalonde'>The Lalonde data set</h2><span id='topic+lalonde'></span>

<h3>Description</h3>

<p>Data set from the National Supported Work Demonstration 
(Lalonde 1986, Dehejia and Wahba 1999). 
This data set is publicly available at 
<a href="https://users.nber.org/~rdehejia/data/.nswdata2.html">https://users.nber.org/~rdehejia/data/.nswdata2.html</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lalonde)
</code></pre>


<h3>Format</h3>

<p>A data frame with 445 observations, corresponding to 185 treated 
and 260 control subjects, and 10 variables.  
The treatment assignment indicator is the first variable of the data frame; 
the next eight columns are the covariates; the last column is the outcome:
</p>

<dl>
<dt>treatment</dt><dd><p>the treatment assignment indicator (1 if treated, 0 otherwise)</p>
</dd>
<dt>age</dt><dd><p>a covariate, measured in years</p>
</dd>
<dt>education</dt><dd><p>a covariate, measured in years</p>
</dd>
<dt>black</dt><dd><p>a covariate indicating race (1 if black, 0 otherwise)</p>
</dd>
<dt>hispanic</dt><dd><p>a covariate indicating race (1 if Hispanic, 0 otherwise)</p>
</dd>
<dt>married</dt><dd><p>a covariate indicating marital status (1 if married, 0 otherwise)</p>
</dd>
<dt>nodegree</dt><dd><p>a covariate indicating high school diploma (1 if no degree, 0 otherwise)</p>
</dd>
<dt>re74</dt><dd><p>a covariate, real earnings in 1974</p>
</dd>
<dt>re75</dt><dd><p>a covariate, real earnings in 1975</p>
</dd>
<dt>re78</dt><dd><p>the outcome, real earnings in 1978</p>
</dd>
</dl>


<h3>Source</h3>

<p><a href="https://users.nber.org/~rdehejia/data/.nswdata2.html">https://users.nber.org/~rdehejia/data/.nswdata2.html</a>
</p>


<h3>References</h3>

<p>Dehejia, R., and Wahba, S. (1999), &quot;Causal Effects in Nonexperimental Studies: Reevaluating the Evaluation of Training Programs,&quot; <em>Journal of the American Statistical Association</em>, 94, 1053-1062.
</p>
<p>Lalonde, R. (1986), &quot;Evaluating the Econometric Evaluations of Training Programs,&quot; <em>American Economic Review</em>, 76, 604-620.
</p>

<hr>
<h2 id='sbw'>Stable balancing weights for causal contrasts and population means.</h2><span id='topic+sbw'></span>

<h3>Description</h3>

<p>Function for finding stable weights (that is, weights of minimum variance) that approximately balance the empirical distribution of the observed covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sbw(
  dat,
  ind = NULL,
  out = NULL,
  bal = list(bal_cov, bal_alg = TRUE, bal_tol, bal_std = "group", bal_gri = c(1e-04,
    0.001, 0.002, 0.005, 0.01, 0.02, 0.05, 0.1), bal_sam = 1000),
  wei = list(wei_sum = TRUE, wei_pos = TRUE),
  sol = list(sol_nam = "quadprog", sol_dis = FALSE),
  par = list(par_est = "att", par_tar = NULL)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sbw_+3A_dat">dat</code></td>
<td>
<p>data, a data frame with a treatment assignment or missingness indicator, covariates, and possibly outcomes (which are optional).</p>
</td></tr>
<tr><td><code id="sbw_+3A_ind">ind</code></td>
<td>
<p>treatment assignment or missingness indicator, a string with the name of the binary treatment or missingness indicator, equal to 1 if treated (missing) and 0 otherwise. 
When <code>par$par_est = "aux"</code>, <code>ind</code> is omitted.</p>
</td></tr>
<tr><td><code id="sbw_+3A_out">out</code></td>
<td>
<p>outcome, a vector of strings with the names of the outcome variables. The default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="sbw_+3A_bal">bal</code></td>
<td>
<p>balance requirements, a list with the requirements for covariate balance with the form
<code>list(bal_cov, bal_alg, bal_tol, bal_std, bal_gri, bal_sam)</code>, where:
</p>
<p><code>bal_cov</code> balance covariates, a vector of strings with the names of the covariates in <code>dat</code> to be balanced.
In simple applications, the balance covariates in <code>bal_cov</code> will be the column names of <code>dat</code> 
(without including the treatment or outcome variables) for the original covariates in the data set. The covariates need to be either continuous or binary. 
Categorical covariates need to be transformed into dummies. In more complex applications, the covariates in <code>dat</code> can be 
transformations of the original covariates in order to balance higher order single or multidimensional moments, or other basis functions. If the transformations of the covariates are indicators of the quantiles
of the empirical distribution of a covariate, then balancing all these indicators will tend to balance the entire marginal distribution
of the covariate.
</p>
<p><code>bal_alg</code> balance algorithm, a logical that indicates whether the tuning algorithm in Wang and Zubizarreta (2020) is 
to be used for automatically selecting the degree of approximate covariates balance.  The default is <code>TRUE</code>.  
See the argument <code>bal_gri</code> below for the candidate values for the degree of approximate covariate balance.
</p>
<p><code>bal_tol</code> balance tolerances, a scalar or vector of scalars
that define the tolerances or maximum differences in means after weighting for the covariates (or transformations thereof) defined in <code>bal_cov</code>.
Note that if <code>bal_tol</code> is a vector, then its length has to be equal to the length of <code>bal_cov</code>. 
Otherwise, the first element in <code>bal_tol</code> will be taken as the balance tolerance for all the constraints in <code>bal_cov</code>.
</p>
<p><code>bal_std</code> balance tolerances in standard deviations, a string that represent 
how the tolerances are adjusted. If <code>bal_std = "group"</code>, the tolerances 
are proportional to the standard deviations in the group/groups to be weighted.
If <code>bal_std = "target"</code>, the tolerances are proportional to the standard deviations 
in the target group. If <code>bal_std = "manual"</code>, the tolerances equal to <code>bal_tol</code>.
The default is <code>"group"</code>.
</p>
<p><code>bal_gri</code> grid of values for the tuning algorithm <code>bal_alg</code>, a vector of candidate values for the degree of approximate covariate balance. 
The default is <code>c(0.0001, 0.001, 0.002, 0.005, 0.01, 0.02, 0.05, 0.1)</code>. 
The computational time is roughly proportional to the number of grid values.
</p>
<p><code>bal_sam</code> number of replicates to be used in <code>bal_alg</code>, an integer specifying the number of bootstrap sample replicates 
to be used to select the degree of approximate covariate balance.  See Wang and Zubizarreta (2020) for details. The default is <code>1000</code>.</p>
</td></tr>
<tr><td><code id="sbw_+3A_wei">wei</code></td>
<td>
<p>weighting constraints, a list with all the weighting constraints with the form
<code>list(wei_sum, wei_pos)</code>, where:
</p>
<p><code>wei_sum</code> sum of weights, a logical variable indicating whether the weights are constrained to sum up to one, or whether their sum 
is unconstrained. The default is <code>TRUE</code> for the sum of weights equal to one. Note that if <code>wei_sum = TRUE</code>, then <code>wei_pos = TRUE</code>.
</p>
<p><code>wei_pos</code> positive or zero (non-negative) weights, a logical variable indicating whether the weights are constrained to be non-negative, or whether they
are unconstrained. The default is <code>TRUE</code> for non-negative weights.  Again, note that if <code>wei_sum = TRUE</code>, then <code>wei_pos = TRUE</code>.</p>
</td></tr>
<tr><td><code id="sbw_+3A_sol">sol</code></td>
<td>
<p>solver, a list that specifies the solver option with the form
</p>
<p><code>list(sol_nam, sol_dis, sol_pog)</code>, where:
</p>
<p><code>sol_nam</code> solver name, a string equal to either <code>"cplex"</code>, <code>"gurobi"</code>, <code>"mosek"</code>, <code>"osqp"</code>, <code>"pogs"</code>, or <code>"quadprog"</code>.
CPLEX, <a href="https://www.gurobi.com/documentation/9.1/refman/ins_the_r_package.html">Gurobi</a> and MOSEK are commercial solvers, but free for academic users. 
<a href="http://foges.github.io/pogs/stp/r">POGS</a> and QUADPROG are free for all. In our experience, POGS is the fastest solver option
and able to handle larger datasets, but it can be difficult to install for non-Mac users 
and more difficult to calibrate. MOSEK is more stable than POGS and faster. 
The default option is <code>sol_nam = "quadprog"</code>. 
</p>
<p><code>sol_dis</code> solver display, a logical variable indicating whether the output is to be displayed or not.
The default is <code>FALSE</code>. This option is specific to <code>"cplex"</code>, <code>"gurobi"</code>, <code>"mosek"</code>, <code>"pogs"</code>, and <code>"osqp"</code>.
</p>
<p><code>sol_pog</code> solver options specific to <code>"pogs"</code>, with the following default parameters:
</p>
<p><code>sol_pog = list(sol_pog_max_iter = 100000, sol_pog_rel_tol = 1e-4,</code> 
</p>
<p><code>sol_pog_abs_tol = 1e-4, sol_pog_gap_stp = TRUE, sol_pog_adp_rho = TRUE)</code>.
</p>
<p>See the POGS manual for details.</p>
</td></tr>
<tr><td><code id="sbw_+3A_par">par</code></td>
<td>
<p>parameter of interest, a list describing the parameter of interest or estimand with the form
<code>list(par_est, par_tar)</code>, where:
</p>
<p><code>par_est</code> estimand. For causal inference, a string equal to:
<code>"att"</code> (Average Treatment effect on the Treated), 
<code>"atc"</code> (Average Treatment effect on the Controls), 
<code>"ate"</code> (Average Treatment Effect), 
<code>"cate"</code> (Conditional Average Treatment Effect). 
For estimation with incomplete outcome data, a string equal to:
<code>"pop"</code> (General population means) or
<code>"aux"</code> (Means for a population specified by the user). The default is <code>"att"</code>.
</p>
<p><code>par_tar</code> target, a string, or a vector of scalars. 
It specifies the targeted population for inference in terms of the observed covariates 
when <code>par_est = "cate"</code>, <code>"pop"</code> or <code>"aux"</code>. Please see the examples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<p><code>dat_weights</code>, a data frame with the optimal weights  <code>dat_weights$sbw_weights</code> ;
</p>
<p><code>ind</code>, an argument provided by the user;
</p>
<p><code>out</code>, an argument provided by the user;
</p>
<p><code>bal</code>, an argument provided by the user;
</p>
<p><code>wei</code>, an argument provided by the user;
</p>
<p><code>sol</code>, an argument provided by the user;
</p>
<p><code>par</code>, an argument provided by the user;
</p>
<p><code>effective_sample_size</code>, effective sample size/sizes for the weighted group/groups;
</p>
<p><code>objective_value</code>, value/values of the objective function/functions at the optimum;
</p>
<p><code>status</code>, status of the solution. If the optimal weights are found, <code>status = optimal</code>;
 otherwise, the solution may be not optimal or not exist, in which case an error will be returned with details specific to the solver used.
 For the solver &quot;quadprog&quot;, the status code is missing, therefore,  <code>status = NA</code> ;
</p>
<p><code>time</code>, time elapsed to find the optimal solution;
</p>
<p><code>shadow_price</code>, dual variables or shadow prices of the covariate balance constraints;
</p>
<p><code>balance_parameters</code>, details of the balance parameters;
</p>
<p><code>cstat</code>, covariate balance statistic used in Wang and Zubizarreta (2020).
A magnitude to be minimized to select the degree of approximate balance in  <code>bal$bal_gri</code> .
</p>


<h3>Source</h3>

<p><a href="https://www.ibm.com/products/ilog-cplex-optimization-studio">https://www.ibm.com/products/ilog-cplex-optimization-studio</a>
</p>
<p><a href="https://www.gurobi.com/products/gurobi-optimizer/">https://www.gurobi.com/products/gurobi-optimizer/</a>
</p>
<p><a href="https://www.mosek.com/products/mosek/">https://www.mosek.com/products/mosek/</a>
</p>
<p><a href="http://foges.github.io/pogs/stp/r">http://foges.github.io/pogs/stp/r</a>
</p>


<h3>References</h3>

<p>Chattopadhyay, A., Hase, C. H., and Zubizarreta, J. R. (2020), &quot;Balancing Versus Modeling Approaches to Weighting in Practice,&quot; Statistics in Medicine, in press.
</p>
<p>Kang, J. D. Y., and Schafer, J. L. (2007), &quot;Demistifying Double Robustness: A Comparison of Alternative Strategies for Estimating a Population Mean from Incomplete Data,&quot; Statistical Science, 22, 523-539.
</p>
<p>Stuart, E. A. Matching methods for causal inference: a review and a look forward. Statistical Science 2010; 25(1): 1-21.
</p>
<p>Wang, Y., and Zubizarreta, J. R. (2020), &quot;Minimal Dispersion Approximately Balancing Weights: Asymtotic Properties and Practical Considerations,&quot; Biometrika, 107, 93-105.
</p>
<p>Zubizarreta, J. R. (2015), &quot;Stable Weights that Balance Covariates for Estimation with Incomplete Outcome Data,&quot; Journal of the American Statistical Association, 110, 910-922.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate data
kangschafer = function(n_obs) {
 # Z are the true covariates
 # t is the indicator for the respondents (treated)
 # y is the outcome
 # X are the observed covariates
 # Returns Z, t y and X sorted in decreasing order by t
 Z = MASS::mvrnorm(n_obs, mu=rep(0, 4), Sigma=diag(4))
 p = 1/(1+exp(Z[, 1]-.5*Z[, 2]+.25*Z[, 3]+.1*Z[, 4]))
 t = rbinom(n_obs, 1, p)
 Zt = cbind(Z, p, t)
 Zt = Zt[order(t), ]
 Z = Zt[, 1:4]
 p = Zt[, 5]
 t = Zt[, 6]
 y = 210+27.4*Z[, 1]+13.7*Z[, 2]+13.7*Z[, 3]+13.7*Z[, 4]+rnorm(n_obs)
 X = cbind(exp(Z[, 1]/2), (Z[, 2]/(1+exp(Z[, 1])))+10, (Z[, 1]*Z[, 3]/
25+.6)^3, (Z[, 2]+Z[, 4]+20)^2)
 return(list(Z=Z, p=p, t=t, y=y, X=X))
}
set.seed(1234)
n_obs = 200
aux = kangschafer(n_obs)
Z = aux$Z
p = aux$p
t = aux$t
y = aux$y
X = aux$X

# Generate data frame
t_ind = t
bal_cov = X
data_frame = as.data.frame(cbind(t_ind, bal_cov, y))
names(data_frame) = c("t_ind", "X1", "X2", "X3", "X4", "Y")

# Define treatment indicator and 
t_ind = "t_ind"
# moment covariates
bal = list()
bal$bal_cov = c("X1", "X2", "X3", "X4")

# Set tolerances
bal$bal_tol = 0.02
bal$bal_std = "group"

# Solve for the Average Treatment Effect on the Treated, ATT (default)
bal$bal_alg = FALSE
sbwatt_object = sbw(dat = data_frame, ind = t_ind, out = "Y", bal = bal)

# # Solve for a Conditional Average Treatment Effect, CATE
# sbwcate_object = sbw(dat = data_frame, ind = t_ind, out = "Y", bal = bal, 
# sol = list(sol_nam = "quadprog"), par = list(par_est = "cate", par_tar = "X1 &gt; 1 &amp; X3 &lt;= 0.22"))

# # Solve for the population mean, POP
# tar = colMeans(bal_cov)
# names(tar) = bal$bal_cov
# sbwpop_object = sbw(dat = data_frame, ind = t_ind, out = "Y", bal = bal, 
# sol = list(sol_nam = "quadprog"), par = list(par_est = "pop"))

# # Solve for a target population mean, AUX
# sbwaux_object = sbw(dat = data_frame, bal = bal, 
# sol = list(sol_nam = "quadprog"), par = list(par_est = "aux", par_tar = tar*1.05))

# # Solve for the ATT using the tuning algorithm
# bal$bal_alg = TRUE
# bal$bal_sam = 1000
# sbwatttun_object = sbw(dat = data_frame, ind = t_ind, out = "Y", bal = bal, 
# sol = list(sol_nam = "quadprog"), par = list(par_est = "att", par_tar = NULL))

# Check
summarize(sbwatt_object)
# summarize(sbwcate_object)
# summarize(sbwpop_object)
# summarize(sbwaux_object)
# summarize(sbwatttun_object)

# Estimate
estimate(sbwatt_object)
# estimate(sbwcate_object)
# estimate(sbwpop_object)
# estimate(sbwatttun_object)

# Visualize
visualize(sbwatt_object)
# visualize(sbwcate_object)
# visualize(sbwpop_object)
# visualize(sbwaux_object)
# visualize(sbwatttun_object)

</code></pre>

<hr>
<h2 id='summarize'>Summarize output from <code>sbw</code></h2><span id='topic+summarize'></span>

<h3>Description</h3>

<p>Function for summarizing the output from <code><a href="#topic+sbw">sbw</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize(object, digits = 6, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_+3A_object">object</code></td>
<td>
<p>an object from the class <code>sbwcau</code> or <code>sbwpop</code> obtained after using <code><a href="#topic+sbw">sbw</a></code>.</p>
</td></tr>
<tr><td><code id="summarize_+3A_digits">digits</code></td>
<td>
<p>The number of significant digits that will be displayed. The default is <code>6</code>.</p>
</td></tr>
<tr><td><code id="summarize_+3A_...">...</code></td>
<td>
<p>ignored arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<p><code>variance</code>, variance of the weights
</p>
<p><code>coefficient_variation</code>, coefficient of variation of the weights
</p>
<p><code>effective_sample_size</code>, effective sample size
</p>
<p><code>balance_table</code>, mean/TASDM balance tables for samples before/after weighting
</p>
<p><code>shadow_price</code>, dual tables or shadow prices for the balanced groups
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Please see the examples in the function sbw above.
</code></pre>

<hr>
<h2 id='visualize'>Visualize output from <code>sbw</code></h2><span id='topic+visualize'></span>

<h3>Description</h3>

<p>Function for visualizing the output from <code><a href="#topic+sbw">sbw</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>visualize(object, plot_cov, ask = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="visualize_+3A_object">object</code></td>
<td>
<p>an object from function <code><a href="#topic+sbw">sbw</a></code>.</p>
</td></tr>
<tr><td><code id="visualize_+3A_plot_cov">plot_cov</code></td>
<td>
<p>names of covariates for which balance is to be displayed.  If <code>NULL</code>, all of the covariates will be displayed.</p>
</td></tr>
<tr><td><code id="visualize_+3A_ask">ask</code></td>
<td>
<p>logical. If <code>TRUE</code> (and the R session is interactive) the user is asked for input, before a new figure is drawn.</p>
</td></tr>
<tr><td><code id="visualize_+3A_...">...</code></td>
<td>
<p>ignored arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. The figures will be shown in the Plots window.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Please see the examples in the function sbw above.
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
