<!DOCTYPE html><html lang="en"><head><title>Help for package freealg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {freealg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#freealg-package'>
<p>The Free Algebra</p></a></li>
<li><a href='#abelianize'><p>Abelianize a <code>freealg</code> object</p></a></li>
<li><a href='#accessor'><p>Accessor methods for freealg objects</p></a></li>
<li><a href='#adjoint'><p>The adjoint map</p></a></li>
<li><a href='#constant'><p>The constant term</p></a></li>
<li><a href='#deriv'><p>Differentiation of <code>freealg</code> objects</p></a></li>
<li><a href='#dot-class'><p>Class &ldquo;dot&rdquo;</p></a></li>
<li><a href='#drop'><p>Drop redundant information</p></a></li>
<li><a href='#freealg'><p>The free algebra</p></a></li>
<li><a href='#freealg-class'><p>Class &ldquo;freealg&rdquo;</p></a></li>
<li><a href='#grade'><p>The grade (or degree) of terms in a <code>freealg</code> object</p></a></li>
<li><a href='#horner'><p>Horner's method</p></a></li>
<li><a href='#inverse'><p>Inverses</p></a></li>
<li><a href='#letters'><p>Single-letter symbols</p></a></li>
<li><a href='#linear'><p>A simple free algebra object</p></a></li>
<li><a href='#nterms'><p>Number of terms in a freealg object</p></a></li>
<li><a href='#Ops.freealg'><p>Arithmetic Ops methods for the the free algebra</p></a></li>
<li><a href='#pepper'><p>Combine variables in every possible order</p></a></li>
<li><a href='#print'><p>Print freealg objects</p></a></li>
<li><a href='#rfalg'><p>Random free algebra objects</p></a></li>
<li><a href='#subs'><p>Substitution</p></a></li>
<li><a href='#zero'><p>The zero algebraic object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>The Free Algebra</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1-8</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), methods</td>
</tr>
<tr>
<td>Description:</td>
<td>The free algebra in R with non-commuting indeterminates.
     Uses 'disordR' discipline
     (Hankin, 2022, &lt;<a href="https://doi.org/10.48550%2FARXIV.2210.03856">doi:10.48550/ARXIV.2210.03856</a>&gt;).  To cite the
     package in publications please use Hankin (2022)
     &lt;<a href="https://doi.org/10.48550%2FARXIV.2211.04002">doi:10.48550/ARXIV.2211.04002</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0-7), partitions (&ge; 1.9-22), disordR (&ge; 0.9-5-1)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr,testthat,magrittr,markdown,rmarkdown,covr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/RobinHankin/freealg">https://github.com/RobinHankin/freealg</a>,
<a href="https://robinhankin.github.io/freealg/">https://robinhankin.github.io/freealg/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/RobinHankin/freealg/issues">https://github.com/RobinHankin/freealg/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-08-26 20:39:27 UTC; rhankin</td>
</tr>
<tr>
<td>Author:</td>
<td>Robin K. S. Hankin
    <a href="https://orcid.org/0000-0001-5982-0415"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-08-26 23:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='freealg-package'>
The Free Algebra
</h2><span id='topic+freealg-package'></span>

<h3>Description</h3>

<p>The free algebra in R with non-commuting indeterminates.
     Uses 'disordR' discipline
     (Hankin, 2022, &lt;doi:10.48550/ARXIV.2210.03856&gt;).  To cite the
     package in publications please use Hankin (2022)
     &lt;doi:10.48550/ARXIV.2211.04002&gt;.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> freealg</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> The Free Algebra</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.1-8</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> person(given=c("Robin", "K. S."), family="Hankin", role = c("aut","cre"), email="hankin.robin@gmail.com", comment = c(ORCID = "0000-0001-5982-0415"))</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 3.5.0), methods</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> The free algebra in R with non-commuting indeterminates.
     Uses 'disordR' discipline
     (Hankin, 2022, &lt;doi:10.48550/ARXIV.2210.03856&gt;).  To cite the
     package in publications please use Hankin (2022)
     &lt;doi:10.48550/ARXIV.2211.04002&gt;.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyData: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> Rcpp (&gt;= 1.0-7), partitions (&gt;= 1.9-22), disordR (&gt;= 0.9-5-1)</td>
</tr>
<tr>
 <td style="text-align: left;">
LinkingTo: </td><td style="text-align: left;"> Rcpp</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> knitr,testthat,magrittr,markdown,rmarkdown,covr</td>
</tr>
<tr>
 <td style="text-align: left;">
VignetteBuilder: </td><td style="text-align: left;"> knitr</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://github.com/RobinHankin/freealg, https://robinhankin.github.io/freealg/</td>
</tr>
<tr>
 <td style="text-align: left;">
BugReports: </td><td style="text-align: left;"> https://github.com/RobinHankin/freealg/issues</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Robin K. S. Hankin [aut, cre] (&lt;https://orcid.org/0000-0001-5982-0415&gt;)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
abelianize              Abelianize a 'freealg' object
accessor                Accessor methods for freealg objects
adjoint                 The adjoint map
constant                The constant term
deriv                   Differentiation of 'freealg' objects
dot-class               Class "dot"
drop                    Drop redundant information
freealg                 The free algebra
freealg-class           Class "freealg"
freealg-package         The Free Algebra
grade                   The grade (or degree) of terms in a 'freealg'
                        object
horner                  Horner's method
inverse                 Inverses
letters                 Single-letter symbols
linear                  A simple free algebra object
nterms                  Number of terms in a freealg object
Ops.freealg             Arithmetic Ops methods for the the free algebra
pepper                  Combine variables in every possible order
print.freealg           Print freealg objects
rfalg                   Random free algebra objects
subs                    Substitution
zero                    The zero algebraic object
</pre>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin [aut, cre] (&lt;https://orcid.org/0000-0001-5982-0415&gt;)
</p>
<p>Maintainer: Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a &lt;- as.freealg("x+xyx")
b &lt;- as.freealg("4x +XyX")  # upper-case interpreted as inverse

a+b
stopifnot(a+b==b+a)   # should be TRUE

a*b ==b*a # FALSE; noncommutative algebra

as.freealg("1+X+xy")^3

rfalg()
rfalg()^2


</code></pre>

<hr>
<h2 id='abelianize'>Abelianize a <code>freealg</code> object</h2><span id='topic+abelianize'></span>

<h3>Description</h3>

<p>Function <code>abelianize()</code> returns a <code>freealg</code> object that is
equivalent to its argument under assumption of Abelianness.  The symbols
are placed in alphabetical order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abelianize(x)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="abelianize_+3A_x">x</code></td>
<td>
<p>A <code>freealg</code> object</p>
</td></tr></table>


<h3>Details</h3>

<p>Abelianizing a free group element means that the symbols can commute
past one another.  Abelianization is vectorized.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>freealg</code>.</p>


<h3>Note</h3>

<p>There is a very similar function in the <a href="https://CRAN.R-project.org/package=freegroup"><span class="pkg">freegroup</span></a>
package.  However, the <a href="https://CRAN.R-project.org/package=frab"><span class="pkg">frab</span></a> package is the best way to work
with the free Abelian group.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
abelianize(as.freealg("ba + 2abbba + 3abAB"))

abelianize(.[rfalg(),rfalg()])

</code></pre>

<hr>
<h2 id='accessor'>Accessor methods for freealg objects</h2><span id='topic+accessor'></span><span id='topic+accessors'></span><span id='topic+words'></span><span id='topic+coeffs'></span><span id='topic+coeffs+3C-'></span><span id='topic+coeffs+3C-.freealg'></span><span id='topic+coefficients'></span><span id='topic++5B.freealg'></span><span id='topic++5B+3C-.freealg'></span>

<h3>Description</h3>

<p>Accessor methods for free algebra objects</p>


<h3>Usage</h3>

<pre><code class='language-R'>words(x)
coeffs(x,drop=TRUE)
coeffs(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="accessor_+3A_x">x</code></td>
<td>
<p>Object of class <code>freealg</code></p>
</td></tr>
<tr><td><code id="accessor_+3A_value">value</code></td>
<td>
<p>Numeric vector of length 1</p>
</td></tr>
<tr><td><code id="accessor_+3A_drop">drop</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to drop the
<code>disord</code> attribute, as per <code>disordR::drop()</code> and
<code>FALSE</code> meaning to consistently return a <code>disord</code> object
irregardless</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Access or set the different parts of a <code>freealg</code> object.  The
constant term is technically a coefficient but is documented under
<code>constant.Rd</code>.
</p>
<p>&ldquo;Pure&rdquo; extraction and replacement (as in <code>a[i]</code> and
<code>a[i] &lt;- value</code> is implemented exprimentally.  The code for
extraction is cute but not particularly efficient.
</p>


<h3>Note</h3>

<p>There is an extended discussion of <a href="https://CRAN.R-project.org/package=disordR"><span class="pkg">disordR</span></a> discipline in the
context of algebras in the <a href="https://CRAN.R-project.org/package=mvp"><span class="pkg">mvp</span></a> package at <code>accessor.Rd</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+constant">constant</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- rfalg()
a
coeffs(a)
words(a)  # NB: hash is identical to that of coeffs(a)

coeffs(a) &lt;- 7   # replacement methods work 
a
coeffs(a)  #


</code></pre>

<hr>
<h2 id='adjoint'>The adjoint map</h2><span id='topic+adjoint'></span><span id='topic+ad'></span>

<h3>Description</h3>

<p>The adjoint <code class="reqn">\mathrm{ad}_X</code> of <code class="reqn">X</code> is a map from a
Lie group <code class="reqn">G</code> to the endomorphism group of <code class="reqn">G</code> defined
by
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{ad}_X(Y)=\left[X,Y\right]</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>ad(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adjoint_+3A_x">x</code></td>
<td>
<p>Object nominally of class <code>freealg</code> but other classes
accepted where they make sense</p>
</td></tr>
</table>


<h3>Details</h3>

<p>details here
</p>


<h3>Note</h3>

<p>Vignette <code>adjoint</code> gives more description</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rfalg()
y &lt;- rfalg()

f &lt;- ad(x)
f(y)


f(f(y)) # [x,[x,y]]

</code></pre>

<hr>
<h2 id='constant'>The constant term</h2><span id='topic+constant'></span><span id='topic+is.constant'></span><span id='topic+constant+3C-'></span><span id='topic+constant.freealg'></span><span id='topic+constant+3C-.freealg'></span><span id='topic+constant.numeric'></span>

<h3>Description</h3>

<p>Get and set the constant term of a <code>freealg</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'freealg'
constant(x)
## S3 method for class 'numeric'
constant(x)
## S3 replacement method for class 'freealg'
constant(x) &lt;- value
is.constant(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="constant_+3A_x">x</code></td>
<td>
<p>Object of class <code>freealg</code></p>
</td></tr>
<tr><td><code id="constant_+3A_value">value</code></td>
<td>
<p>Scalar value for the constant</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The constant term in a free algebra object is the coefficient of the
empty term.  In a <code>freealg</code> object, the map including
<code class="reqn">\emptyset\longrightarrow v</code> implies that <code class="reqn">v</code> is
the constant.
</p>
<p>If <code>x</code> is a <code>freealg</code> object, <code>constant(x)</code> returns
the value of the constant in the multivariate polynomial; if <code>x</code>
is numeric, it returns a constant <code>freealg</code> object with value
<code>x</code>.
</p>
<p>Function <code>is.constant()</code> returns <code>TRUE</code> if its argument has
no variables and <code>FALSE</code> otherwise.
</p>
<p>Setting the coefficients of the empty <code>freealg</code> returns the zero
(empty) object.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- as.freealg("1+X+Y+xy")

constant(p)
constant(p^5)

constant(p) &lt;- 1000
p


</code></pre>

<hr>
<h2 id='deriv'>Differentiation of <code>freealg</code> objects</h2><span id='topic+deriv'></span><span id='topic+aderiv'></span><span id='topic+deriv.freealg'></span><span id='topic+deriv_freealg'></span>

<h3>Description</h3>

<p>Differentiation of <code>freealg</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'freealg'
deriv(expr, r, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deriv_+3A_expr">expr</code></td>
<td>
<p>Object of class <code>freealg</code></p>
</td></tr>
<tr><td><code id="deriv_+3A_r">r</code></td>
<td>
<p>Integer vector.  Elements denote variables to differentiate
with respect to.  If <code>r</code> is a character vector, it is
interpreted as <code>a=1,b=2,...,z=26</code>; if of length 1,
&ldquo;<code>aab</code>&rdquo; is interpreted as <code>c("a","a","b")</code></p>
</td></tr>
<tr><td><code id="deriv_+3A_...">...</code></td>
<td>
<p>Further arguments, currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Experimental function <code>deriv(S,v)</code> returns
<code class="reqn">\frac{\partial^r S}{\partial v_1\partial v_2\ldots\partial
      v_r}</code>.  The Leibniz product rule
</p>
<p style="text-align: center;"><code class="reqn">\left(u\cdot v\right)'=uv'+u'v</code>
</p>

<p>operates even if (as here) <code class="reqn">u,v</code> do not commute.  For example, if
we wish to differentiate <code class="reqn">aaba</code> with respect to <code class="reqn">a</code>, we would
write <code class="reqn">f(a) = aaba</code> and then
</p>
<p style="text-align: center;"><code class="reqn">f(a+\delta a) = (a+\delta a)(a+\delta a)b(a+\delta a)</code>
</p>

<p>and working to first order we have
</p>
<p style="text-align: center;"><code class="reqn">f(a+\delta a) -f(a)= (\delta a)aba + a(\delta a)ba + aab(\delta
  a).</code>
</p>
<p>  In the package:
</p>
<pre>

    &gt; deriv(as.freealg("aaba"),"a")
    free algebra element algebraically equal to
    + 1*aab(da) + 1*a(da)ba + 1*(da)aba
</pre>
<p>A term of a <code>freealg</code> object can include negative values which
correspond to negative powers of variables.  Thus:
</p>
<pre>
    &gt; deriv(as.freealg("AAAA"),"a")       
    free algebra element algebraically equal to
    - 1*AAAA(da)A - 1*AAA(da)AA - 1*AA(da)AAA - 1*A(da)AAAA
  </pre>
<p>(see also the examples).  Vector <code>r</code> may include negative
integers which mean to differentiate with respect to the inverse of
the variable:
</p>
<pre>
    &gt; deriv(as.freealg("3abcbCC"),"C")
    free algebra element algebraically equal to
    + 3*abcbC(dC) + 3*abcb(dC)C - 3*abc(dC)cbCC
  </pre>
<p>It is possible to perform repeated differentiation by passing a
suitable value of <code>r</code>.  For
<code class="reqn">\frac{\partial^2}{\partial a\partial c}</code>:
</p>
<pre>
    &gt; deriv(as.freealg("aaabAcx"),"ac")
    free algebra element algebraically equal to
    - 1*aaabA(da)A(dc)x + 1*aa(da)bA(dc)x + 1*a(da)abA(dc)x + 1*(da)aabA(dc)x
  </pre>
<p>The infinitesimal indeterminates (&ldquo;<code>da</code>&rdquo; etc) are
represented by <code>SHRT_MAX+r</code>, where <code>r</code> is the integer for
the symbol, and <code>SHRT_MAX</code> is the maximum short integer.  This
includes negative <code>r</code>.  So the maximum number for any symbol is
<code>SHRT_MAX</code>.  Inverse elements such as <code>A</code>, being represented
by negative integers, have differentials that are <code>SHRT_MAX-r</code>.
</p>
<p>Function <code>deriv()</code> calls helper function <code>lowlevel_diffn()</code>
which is documented at <code>Ops.freealg.Rd</code>.
</p>
<p>A vignette illustrating this concept and furnishing numerical
verification of the code in the context of matrix algebra is given at
<code>inst/freealg_matrix.Rmd</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
deriv(as.freealg("4*aaaabaacAc"),1)

x &lt;- rfalg()
deriv(x,1:3)

y &lt;- rfalg(7,7,17,TRUE)

deriv(y,1:5)-deriv(y,sample(1:5)) # should be zero


</code></pre>

<hr>
<h2 id='dot-class'>Class &ldquo;dot&rdquo;</h2><span id='topic+dot'></span><span id='topic+.'></span><span id='topic+dot-class'></span><span id='topic+commutator'></span><span id='topic+jacobi'></span><span id='topic+dot_error'></span><span id='topic++5B.dot'></span><span id='topic++5B+2Cdot-method'></span><span id='topic++5B+2Cdot+2CANY+2CANY-method'></span><span id='topic++5B+2Cdot+2CANY+2Cmissing-method'></span><span id='topic++5B+2Cdot+2Cmissing+2CANY-method'></span><span id='topic++5B+2Cdot+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2Cdot+2Cmatrix+2Cmatrix-method'></span><span id='topic++5B+2Cdot+2Cfunction+2Cfunction-method'></span><span id='topic++5B+2Cdot+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+2Cdot+2CANY+2Cmissing+2CANY-method'></span><span id='topic++5B+2Cdot+2Cfunction+2Cfunction+2CANY-method'></span><span id='topic++5B+2Cdot+2Cmatrix+2Cmatrix+2CANY-method'></span><span id='topic++5B+2Cdot+2Cmissing+2CANY+2CANY-method'></span><span id='topic++5B+2Cdot+2Cmissing+2Cmissing+2CANY-method'></span>

<h3>Description</h3>

<p>The dot object is defined so that <code>.[x,y]</code> returns the commutator
of <code>x</code> and <code>y</code>, that is, <code>xy-yx</code> or the Lie bracket
<code class="reqn">[x,y]</code>.  It would have been nice to use <code>[x,y]</code> (that is,
without the dot) but although this is syntactically consistent, it
cannot be done in R.
</p>
<p>The &ldquo;meat&rdquo; of the dot functionality is:
</p>
<pre>
setClass("dot", slots = c(ignore='numeric'))
`.` &lt;- new("dot")
setMethod("[",signature(x="dot",i="ANY",j="ANY"),function(x,i,j,drop){i*j-j*i})
</pre>
<p>The package code includes other bits and pieces such as informative
error messages for idiom such as <code>.[]</code>.  The package defines a
matrix method for the dot object.  This is because &ldquo;<code>*</code>&rdquo;
returns (incorrectly, in my view) the elementwise product, not the
matrix product.
</p>
<p>The Jacobi identity, satisfied by any associative algebra, is
</p>
<p style="text-align: center;"><code class="reqn">
  \left[x,\left[y,z\right]\right]+
  \left[y,\left[z,x\right]\right]+
  \left[z,\left[x,y\right]\right]=0
</code>
</p>

<p>and the left hand side is returned by <code>jacobi()</code>, which should be
zero (for some definition of &ldquo;zero&rdquo;).
</p>
<p>Function <code>ad()</code> returns the adjoint operator.  The <code>adjoint</code>
vignette provides details and examples of the adjoint operator.
</p>
<p>The dot object is generated by running script <code>inst/dot.Rmd</code>, which
includes some further discussion and technical documentation, and
creates file <code>dot.rda</code> which resides in the <code>data/</code> directory.
</p>


<h3>Value</h3>

<p>Always returns an object of the same class as <code>xy</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>ignore</code>:</dt><dd><p>Object of class <code>"numeric"</code>, just a
formal placeholder</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>[</dt><dd><p><code>signature(x = "dot", i = "ANY", j = "ANY")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "dot", i = "ANY", j = "missing")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "dot", i = "function", j = "function")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "dot", i = "matrix", j = "matrix")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "dot", i = "missing", j = "ANY")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "dot", i = "missing", j = "missing")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
.[as.freealg("x"),as.freealg("y")]
.[as.freealg("x"),as.freealg("y+2z")]
.[as.freealg("x+y+2xYx"),as.freealg("x+y+2xYx")]


x &lt;- rfalg()
y &lt;- rfalg()
z &lt;- rfalg()

jacobi(x,y,z) # Jacobi identity
.[x,.[y,z]] + .[y,.[z,x]] + .[z,.[x,y]]  # Jacobi, expanded


f &lt;- ad(x)
f(y)


rM &lt;- function(...){matrix(sample(1:9,9),3,3)} # a random matrix

M &lt;- rM()
N &lt;- rM()
O &lt;- rM()

.[M,N]
jacobi(M,N,O)

plot(.[sin,tan](seq(from=0,to=1,len=100)))

</code></pre>

<hr>
<h2 id='drop'>Drop redundant information</h2><span id='topic+drop'></span><span id='topic+drop+2Cfreealg-method'></span>

<h3>Description</h3>

<p>Coerce constant free algebra objects to numeric</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop(x)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drop_+3A_x">x</code></td>
<td>
<p>Free algebra object</p>
</td></tr></table>


<h3>Details</h3>

<p>If its argument is a constant freealg object, coerce to
numeric.  Modelled on <code>base::drop()</code>.
</p>


<h3>Note</h3>

<p>A few functions in the package take <code>drop</code> as an argument
which, if <code>TRUE</code>, means that the function returns a
<code>drop</code>ped value.</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+constant">constant</a></code>,<code><a href="#topic+coeffs">coeffs</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>drop(linear(1:5))
drop(4+linear(1:5)*0)
</code></pre>

<hr>
<h2 id='freealg'>The free algebra</h2><span id='topic+freealg'></span><span id='topic+is.freealg'></span><span id='topic+as.freealg'></span><span id='topic+is_ok_free'></span><span id='topic+char_to_freealg'></span><span id='topic+natural_char_to_freealg'></span><span id='topic+numeric_to_free'></span><span id='topic+vector_to_free'></span><span id='topic+string_to_freealg'></span>

<h3>Description</h3>

<p>Create, test for, and coerce to, <code>freealg</code> objects</p>


<h3>Usage</h3>

<pre><code class='language-R'>freealg(words, coeffs)
is_ok_free(words,coeffs)
is.freealg(x)
as.freealg(x,...)
char_to_freealg(ch)
natural_char_to_freealg(string)
string_to_freealg(string)
vector_to_free(v,coeffs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="freealg_+3A_words">words</code></td>
<td>
<p>Terms of the algebra object, eg <code>c(1,2,-1,-3,-2)</code>
corresponds to <code>abACB</code> because <code class="reqn">a=1</code>, <code class="reqn">b=2</code> etc;
uppercase, or negative number, means inverse</p>
</td></tr>
<tr><td><code id="freealg_+3A_coeffs">coeffs</code></td>
<td>
<p>Numeric vector corresponding to the coefficients of each
element of the <code>word</code> list</p>
</td></tr>
<tr><td><code id="freealg_+3A_string">string</code></td>
<td>
<p>Character string</p>
</td></tr>
<tr><td><code id="freealg_+3A_ch">ch</code></td>
<td>
<p>Character vector</p>
</td></tr>
<tr><td><code id="freealg_+3A_v">v</code></td>
<td>
<p>Vector of integers</p>
</td></tr>
<tr><td><code id="freealg_+3A_x">x</code></td>
<td>
<p>Object possibly of class <code>freealg</code></p>
</td></tr>
<tr><td><code id="freealg_+3A_...">...</code></td>
<td>
<p>Further arguments, passed to the methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>freealg()</code> is the formal creation mechanism for
<code>freealg</code> objects.  However, it is not very user-friendly; it is
better to use <code>as.freealg()</code> in day-to-day use (although it does
use heuristics for the coefficients if not supplied).
</p>
<p>Low-level helper function <code>is_ok_freealg()</code> checks for consistency
of its arguments.
</p>
<p>A <code>freealg</code> object is a two-element list.  The first element is a
list of integer vectors representing the indices and the second is a
numeric vector of coefficients.  Thus, for example:
</p>
<pre>
&gt; as.freealg("a+4bd+3abbbbc")
free algebra element algebraically equal to
 + 1*a + 3*abbbbc + 4*bd
&gt; dput(as.freealg("a+4bd+3abbbbc"))
structure(list(indices = list(1L, c(1L, 2L, 2L, 2L, 2L, 3L), 
    c(2L, 4L)), coeffs = c(1, 3, 4)), class = "freealg")
</pre>
<p>Observe that the order of the terms is not preserved and indeed is
undefined (implementation-specific).  Zero entries are stripped out.
</p>
<p>Character strings may be coerced to <code>freealg</code> objects;
<code>as.freealg()</code> calls <code>natural_char_to_freealg()</code>, which is
user-friendly.  Functions <code>char_to_freealg()</code> and
<code>string_to_freealg()</code> are low-level helper functions.  These
functions assume that upper-case letters are the multiplicative inverses
of the lower-case equivalents; so for example <code>as.freealg("aA")</code>
and <code>as.freealg(aBcCbA)</code> evaluate to one.  This can be confusing
with the default print method.
</p>


<h3>Note</h3>

<p>Internally, the package uses signed integers and as such can have
<code>.Machine$integer.max</code> different symbols; on my machine this is
2147483647.  Of course the print method cannot deal with this as it
only has 26 symbols for letters a-z (and A-Z for the inverses), but
the objects themselves do not care about the print method.  Note also
that the experimental calculus facility (as per <code>deriv()</code>)
reserves numbers in the range <code>SHRT_MAX</code><code class="reqn">{}\pm r</code> for
infinitesimals, where <code>r</code> is the integer for a symbol.  This
system might change in the future.  </p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
freealg(list(1:2, 2:1,numeric(0),1:6),1:4)
freealg(list(1:2, 2:1,numeric(0),1:6))   # heuristics for coeffs: assume 1

freealg(sapply(1:5,seq_len),1:5)

freealg(replicate(5,sample(-5:5,rgeom(1,1/5),replace=TRUE)),1:5)


as.freealg("1+xaX")^5


</code></pre>

<hr>
<h2 id='freealg-class'>Class &ldquo;freealg&rdquo;</h2><span id='topic+freealg-class'></span>

<h3>Description</h3>

<p>The formal S4 class for <code>freealg</code> objects</p>


<h3>Objects from the Class</h3>

<p>Formal class <dfn>freealg</dfn> is used for functions such as <code>drop()</code>
which need a S4 object.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>

<hr>
<h2 id='grade'>The grade (or degree) of terms in a <code>freealg</code> object
</h2><span id='topic+grade'></span><span id='topic+grade+3C-'></span><span id='topic+grades'></span><span id='topic+degree'></span><span id='topic+deg'></span><span id='topic+degrees'></span>

<h3>Description</h3>

<p>The free algebra <code class="reqn">\mathcal B</code> is a <dfn>graded</dfn> algebra: that
is, for each integer <code class="reqn">n\geq 0</code> there is a homogeneous
subspace <code class="reqn">\mathcal{B}_n</code> with
<code class="reqn">\mathcal{B}_0=\mathcal{R}</code> and
</p>
<p style="text-align: center;"><code class="reqn">
  \mathcal{B}=\bigoplus_{n=0}^\infty\mathcal{B}_n,\quad\mbox{and}\quad\mathcal{B}_n\mathcal{B}_m\subseteq\mathcal{B}_{n+m}\quad\mbox{for all $m,n\geq  0.$}
</code>
</p>

<p>The elements of <code class="reqn">\cup_{n\geq 0}\mathcal{B}_n</code> are
called <dfn>homogeneous</dfn> and those of <code class="reqn">\mathcal{B}_n</code> are
called homogenous of degree (or grade) <code class="reqn">n</code>.
</p>
<p>The <dfn>grade</dfn> of a term is the number of symbols in it.  Thus the
grade of <code>xxx</code> and <code>4xxy</code> is 3; the grade of a constant is
zero.  Because the terms are stored in an implementation-specific way,
the grade of a multi-term object is a <code>disord</code> object.
</p>
<p>The grade of the zero <code>freealg</code> object,
<code>grade(as.freealg(0))</code>, is defined to be <code class="reqn">-\infty</code>,
as per Knuth [TAOCP, volume 2, p436].  This ensures that
<code>max(grades(abelianize(x))) &lt;= max(grades(x))</code> is always satisfied.
However, a case for <code>NULL</code> could be made.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grades(x)
grade(x,n)
grade(x,n) &lt;- value
deg(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grade_+3A_x">x</code></td>
<td>
<p>Freealg object</p>
</td></tr>
<tr><td><code id="grade_+3A_n">n</code></td>
<td>
<p>Integer vector</p>
</td></tr>
<tr><td><code id="grade_+3A_value">value</code></td>
<td>
<p>Replacement value, a numeric vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>grades(x)</code> returns the grade (number of symbols) in each term
of a <code>freealg</code> object <code>x</code>.
</p>
<p><code>deg(x)</code> returns the maximum of the grades of each symbol of
<code>x</code>; <code>max(grades(x))</code>.
</p>
<p><code>grade(x,n)</code> returns the freealg object comprising terms with
grade <code>n</code> (which may be a vector).  Note that this function is
considerably less efficient than <code>clifford::grade()</code>.
</p>
<p><code>grade(x,n) &lt;- value</code> sets the coefficients of terms with grade
<code>n</code>.  For <code>value</code>, a length-one numeric vector is accepted
(notably zero, which kills terms of grade <code>n</code>) and also a
<code>freealg</code> object comprising terms of grade <code>n</code>.
</p>


<h3>Value</h3>

<p>Returns a disord object</p>


<h3>Note</h3>

<p>A similar concept <dfn>grade</dfn> is discussed in the <span class="pkg">clifford</span>
package</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>H. Munthe-Kaas and B. Owren 1999.  &ldquo;Computations in a free Lie
algebra&rdquo;, <em>Phil. Trans. R. Soc. Lond. A</em>, 357:957&ndash;981 (theorem 3.8)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

X &lt;- as.freealg("1 -x + 5*y + 6*x*y -8*x*x*x*x*y*x")
X
grades(X)

a &lt;- rfalg(30)
a
grades(a)
grade(a,2)
grade(a,2) &lt;- 0 # kill all grade-2 terms
a

grade(a,1) &lt;- grade(a,1) * 888 
a
</code></pre>

<hr>
<h2 id='horner'>Horner's method</h2><span id='topic+horner'></span>

<h3>Description</h3>

<p>Horner's method for multivariate polynomials
</p>


<h3>Usage</h3>

<pre><code class='language-R'>horner(P,v)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="horner_+3A_p">P</code></td>
<td>
<p>Free algebra polynomial</p>
</td></tr>
<tr><td><code id="horner_+3A_v">v</code></td>
<td>
<p>Numeric vector of coefficients</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is (almost) the same as <code>mvp::horner()</code>.
</p>
<p>Given a polynomial
</p>
<p style="text-align: center;"><code class="reqn">p(x) = a_0 +a_1x+a_2x^2+\cdots + a_nx^n</code>
</p>

<p>it is possible to express <code class="reqn">p(x)</code> in the algebraically equivalent
form
</p>
<p style="text-align: center;"><code class="reqn">p(x) = a_0 + x\left(a_1+x\left(a_2+\cdots + x\left(a_{n-1} +xa_n
\right)\cdots\right)\right)</code>
</p>

<p>which is much more efficient for evaluation, as it requires only
<code class="reqn">n</code> multiplications and <code class="reqn">n</code> additions, and this is optimal.
Function <code>horner()</code> will take a <code>freealg</code> object for its first
argument.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
horner("x",  1:4)  # note constant term is 1.

horner("x+y",1:3) # note presence of xy and yx terms

horner("1+x+xyX",1:3)
</code></pre>

<hr>
<h2 id='inverse'>Inverses</h2><span id='topic+inverse'></span><span id='topic+all_pos'></span><span id='topic+keep_pos'></span>

<h3>Description</h3>

<p>Multiplicative inverses of symbols in the free algebra</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_pos(x)
keep_pos(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inverse_+3A_x">x</code></td>
<td>
<p>Freealg object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>all_pos()</code> tests for its argument having only positive
powers (that is, no inverse symbols present); function
<code>keep_pos()</code> discards any term with a negative power.
</p>
<p>At various points in the package, it is assumed that upper-case
letters are the multiplicative inverses of the lower-case equivalents;
so for example <code>as.freealg("aA")</code> and <code>as.freealg("aBcCbA")</code>
evaluate to one.  This can be confusing with the default print method.
</p>
<p>Even though individual symbols have multiplicative inverses, a general
element of the free algebra will not have a multiplicative inverse.
For example, <code>1+x</code> does not have an inverse.  The free algebra is
not a division algebra, in general.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
all_pos(rfalg(include.negative = TRUE))
all_pos(rfalg(include.negative = FALSE))


as.freealg("1+xaX")^5



</code></pre>

<hr>
<h2 id='letters'>Single-letter symbols</h2><span id='topic+letters'></span><span id='topic+lettersymbols'></span>

<h3>Description</h3>

<p>Variables <code>a</code>, <code>b</code>,..., <code>z</code> and their inverses
<code>A</code>-<code>Z</code> are given their <code>freealg</code> semantic meaning.
</p>


<h3>Details</h3>

<p>Sometimes it is convenient in an <span class="rlang"><b>R</b></span> session to have all 26 letters a-z
and all 26 uppercase letters A-Z adopt their free algebra
interpretations.  To access this, load the <code>lettersymbols</code> dataset,
which is provided with the package in the <code>inst</code> directory:
</p>
<pre>
  load(system.file("lettersymbols.rda",package="freealg"))
</pre>
<p>Executing this allows you to do cool things such as the
following:
</p>
<pre>
&gt; (1+a-b^2)^4
free algebra element algebraically equal to
+ 1 + 4a + 6aa + 4aaa + aaaa - aaabb - 4aabb - aabba + aabbbb - 6abb - 4abba -
abbaa + abbabb + 4abbbb + abbbba - abbbbbb - 4bb - 6bba - 4bbaa - bbaaa +
bbaabb + 4bbabb + bbabba - bbabbbb + 6bbbb + 4bbbba + bbbbaa - bbbbabb -
4bbbbbb - bbbbbba + bbbbbbbb
&gt; 
</pre>
<p>Lowercase letters <code>c</code>, <code>q</code>, <code>t</code>, and uppercase letters
<code>C</code>, <code>D</code>, <code>F</code>, <code>I</code>, <code>T</code> might pose
difficulties.
</p>
<p>These objects can also be generated by running script
<code>inst/symb.Rmd</code>, which includes some further discussion and
technical documentation and creates file <code>lettersymbols.rda</code> which
formerly resided in the <code>data/</code> directory.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>

<hr>
<h2 id='linear'>A simple free algebra object</h2><span id='topic+linear'></span>

<h3>Description</h3>

<p>Create simple free algebra objects including linear expressions.  For
example:
</p>
<pre>
&gt; linear(1:3)
free algebra element algebraically equal to
+ 1*a + 2*b + 3*c
&gt; linear(1:3,power=5)
free algebra element algebraically equal to
+ 1*aaaaa + 2*bbbbb + 3*ccccc
&gt;
</pre>


<h3>Usage</h3>

<pre><code class='language-R'>linear(x,power=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linear_+3A_x">x</code></td>
<td>
<p>Numeric vector of terms</p>
</td></tr>
<tr><td><code id="linear_+3A_power">power</code></td>
<td>
<p>Integer vector of powers</p>
</td></tr>
</table>


<h3>Note</h3>

<p>It is instructive to compare the functionality documented here with
their <a href="https://CRAN.R-project.org/package=mvp"><span class="pkg">mvp</span></a> equivalents.  Many of the functions documented at
<code>mvp::special.Rd</code> do not make sense in the context of the free
algebra.  Function <code>mvp::product()</code>, for example, imposes an
order on the expansion.
</p>
<p>Function <code>constant()</code> is documented at <code>constant.Rd</code>, but is
listed below for convenience.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+constant">constant</a></code>, <code><a href="#topic+zero">zero</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>linear(1:3)         
linear(1:3,power=5)
linear(1:3,power=3:1)
</code></pre>

<hr>
<h2 id='nterms'>Number of terms in a freealg object</h2><span id='topic+nterms'></span><span id='topic+length'></span>

<h3>Description</h3>

<p>Number of terms in a freealg object; number of coefficients</p>


<h3>Usage</h3>

<pre><code class='language-R'>nterms(x)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nterms_+3A_x">x</code></td>
<td>
<p>Freealg object</p>
</td></tr></table>


<h3>Value</h3>

<p>Returns a non-negative integer</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>(a &lt;- freealg(list(1:3,4:7,1:10),1:3))
nterms(a)
nterms(a+1)
nterms(a*0)
</code></pre>

<hr>
<h2 id='Ops.freealg'>Arithmetic Ops methods for the the free algebra</h2><span id='topic+Ops.freealg'></span><span id='topic+ops'></span><span id='topic+inv'></span><span id='topic+free_negative'></span><span id='topic+freealg_negative'></span><span id='topic+free_times_free'></span><span id='topic+free_times_scalar'></span><span id='topic+free_plus_free'></span><span id='topic+free_plus_numeric'></span><span id='topic+free_power_scalar'></span><span id='topic+free_eq_free'></span><span id='topic+free_equal_free'></span><span id='topic+lowlevel_simplify'></span><span id='topic+lowlevel_free_prod'></span><span id='topic+lowlevel_free_sum'></span><span id='topic+lowlevel_free_power'></span><span id='topic+lowlevel_deriv'></span><span id='topic+lowlevel_diff'></span><span id='topic+lowlevel_diffn'></span><span id='topic+lowlevel_subs'></span>

<h3>Description</h3>

<p>Arithmetic operators for manipulation of freealg objects
such as addition, multiplication, powers, etc
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'freealg'
Ops(e1, e2)
free_negative(S)
free_power_scalar(S,n)
free_eq_free(e1,e2)
free_plus_numeric(S,x)
free_plus_free(e1,e2)
lowlevel_simplify(words,coeffs)
lowlevel_free_prod(words1,coeffs1,words2,coeffs2)
lowlevel_free_sum(words1,coeffs1,words2,coeffs2)
lowlevel_free_power(words,coeffs,n)
lowlevel_diffn(words,coeffs,r)
lowlevel_subs(words1, coeffs1, words2, coeffs2, r)
inv(S)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Ops.freealg_+3A_s">S</code>, <code id="Ops.freealg_+3A_e1">e1</code>, <code id="Ops.freealg_+3A_e2">e2</code></td>
<td>
<p>Objects of class <code>freealg</code></p>
</td></tr>
<tr><td><code id="Ops.freealg_+3A_n">n</code></td>
<td>
<p>Integer, possibly non-positive</p>
</td></tr>
<tr><td><code id="Ops.freealg_+3A_r">r</code></td>
<td>
<p>Integer vector indicating variables to differentiate with
respect to</p>
</td></tr>
<tr><td><code id="Ops.freealg_+3A_x">x</code></td>
<td>
<p>Scalar value</p>
</td></tr>
<tr><td><code id="Ops.freealg_+3A_words">words</code>, <code id="Ops.freealg_+3A_words1">words1</code>, <code id="Ops.freealg_+3A_words2">words2</code></td>
<td>
<p>A list of words, that is, a list of integer vectors
representing the variables in each term</p>
</td></tr>
<tr><td><code id="Ops.freealg_+3A_coeffs">coeffs</code>, <code id="Ops.freealg_+3A_coeffs1">coeffs1</code>, <code id="Ops.freealg_+3A_coeffs2">coeffs2</code></td>
<td>
<p>Numeric vector representing the
coefficients of each word</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>Ops.freealg()</code> passes binary arithmetic operators
(&ldquo;<code>+</code>&rdquo;, &ldquo;<code>-</code>&rdquo;, &ldquo;<code>*</code>&rdquo;,
&ldquo;<code>^</code>&rdquo;, and &ldquo;<code>==</code>&rdquo;) to the appropriate
specialist function.
</p>
<p>The caret, as in <code>a^n</code>, denotes arithmetic exponentiation, as in
<code>x^3==x*x*x</code>.  As an experimental feature, this is (sort of)
vectorised: if <code>n</code> is a vector, then <code>a^n</code> returns the sum
of <code>a</code> raised to the power of each element of <code>n</code>.  For example,
<code>a^c(n1,n2,n3)</code> is <code>a^n1 + a^n2 + a^n3</code>.  Internally,
<code>n</code> is tabulated in the interests of efficiency, so
<code>a^c(0,2,5,5,5,) = 1 + a^2 + 3a^5</code> is evaluated with only a
single fifth power.  Similar functionality is implemented in the
<a href="https://CRAN.R-project.org/package=mvp"><span class="pkg">mvp</span></a> package.
</p>
<p>The only comparison operators are equality and inequality; <code>x==y</code>
is defined as <code>is.zero(x-y)</code>.
</p>
<p>Functions <code>lowlevel_foo()</code> are low-level functions that interface
directly with the <code>C</code> routines in the <code>src/</code> directory and
are not intended for the end-user.
</p>
<p>Function <code>inv()</code> is defined only for freealg objects with a
single term.  If <code>x</code> has a single term we have
<code>inv(x)*x=x*inv(x)=1</code>.  There is no corresponding division in the
package because <code>a/b</code> may be either <code>a*inv(b)</code> or
<code>inv(b)*a</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>rfalg()
as.freealg("1+x+xy+yx")  # variables are non-commutative
as.freealg("x") * as.freealg("X") # upper-case letters are lower-case inverses

constant(as.freealg("x+y+X+Y")^6)  # OEIS sequence A035610

inv(as.freealg("2aaabAAAAx"))

as.freealg("a")^(1:7)


</code></pre>

<hr>
<h2 id='pepper'>Combine variables in every possible order</h2><span id='topic+pepper'></span>

<h3>Description</h3>

<p>Given a list of variables, construct every term comprising only those
variables; function <code>pepper()</code> returns a free algebra object
equal to the sum of these terms.
</p>
<p>The function is named for a query from an exam question set by Sarah
Marshall in which she asked how many ways there are to arrange the
letters of word &ldquo;pepper&rdquo;, the answer being <code class="reqn">\left({6\atop
  1\,2\,3}\right)=\frac{6!}{1!2!3!}=60</code>.
</p>
<p>Function <code>multiset()</code> in the <a href="https://CRAN.R-project.org/package=partitions"><span class="pkg">partitions</span></a> package gives
related functionality; for the record, one way to reproduce
<code>pepper("pepper")</code> would be
</p>
<pre>
    apply(matrix(c("p","e","r")[multiset(c(1,1,1,2,2,3))],nrow=6),2,paste,collapse="")
  </pre>


<h3>Usage</h3>

<pre><code class='language-R'>pepper(v)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pepper_+3A_v">v</code></td>
<td>
<p>Variables to combine.  If a character string, coerce to
variable numbers</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+linear">linear</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>pepper(c(1,1,1,1,1,1,2))  # 6 a's and 1 b
pepper(c(1,2,2,2,3))      # 1 a, 3 b's and 1 c
pepper("pepper")
</code></pre>

<hr>
<h2 id='print'>Print freealg objects</h2><span id='topic+print.freealg'></span>

<h3>Description</h3>

<p>Print methods for free algebra objects.  The indeterminates are
represented using lowercase letters a-z (currently hard coded).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'freealg'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print_+3A_x">x</code></td>
<td>
<p>Object of class <code>freealg</code> in the print method</p>
</td></tr>
<tr><td><code id="print_+3A_...">...</code></td>
<td>
<p>Further arguments, currently ignored</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The print method does not change the internal representation of a
<code>freealg</code> object, which is a two-element list, the first of which
is a list of integer vectors representing words, and the second is a
numeric vector of coefficients.
</p>
<p>The print method uses lowercase letters a-z to represent the
indeterminates; this is currently hard coded:
</p>
<pre>
&gt; (x &lt;- as.freealg("6abbbc + 7cax"))
free algebra element algebraically equal to
+ 6*abbbc + 7*cax
&gt; unclass(x)
$indices
$indices[[1]]
[1] 1 2 2 2 3

$indices[[2]]
[1]  3  1 24


$coeffs
[1] 6 7
</pre>
<p>The print method has special dispensation for length-zero freealg objects
but these are not handled entirely consistently.
</p>
<p>The print method is sensitive to the value of
<code>getOption("usecaret")</code>, defaulting to &ldquo;FALSE&rdquo;.  The default
is to use uppercase letters to represent multiplicative inverses.  Thus,
the inverse of <code>a</code> appears as either &ldquo;<code>a^-1</code>&rdquo; if
<code>usecaret</code> is <code>TRUE</code>, and &ldquo;<code>A</code>&rdquo; if <code>FALSE</code>.
Carets become cumbersome for powers above the first.  For example, the
default notation for <code class="reqn">aba^{-2}</code> is <code>abAA</code> but becomes
<code>aba^-1a^-1</code> if <code>usecaret</code> is <code>TRUE</code>.
</p>
<p>The symbols for the indeterminates are currently hardcoded as
<code>c(letters,LETTERS)</code>.  The intent is to be able to signify 52
distinct indeterminates, <code>a-z,A-Z</code>.  This works fine if option
<code>usecaret</code> is <code>TRUE</code>.  But if option <code>usecaret</code> is
<code>FALSE</code>, this can be confusing: for example, indeterminate number 1
appears as <code>a</code>, and its inverse would appear as &ldquo;<code>A</code>&rdquo;.
But indeterminate number 27 also appears as &ldquo;<code>A</code>&rdquo;.  They
look the same, but no warning is given: caveat emptor!
</p>
<p>The method is also sensitive to <code>getOption("mulsym")</code>, defaulting
to <code>NULL</code>.  This is the multiplication symbol used between the
coefficient and the indeterminate string.  Sometimes an asterisk,
<code>*</code> or a space, might be useful.  If <code>mulsym</code> takes its
default of <code>NULL</code> [or a length zero string], the print method
suppresses coefficients of <code class="reqn">\pm 1</code>.
</p>
<p>Integers exceeding <code>SHRT_MAX</code> are reserved for infinitesimals,
which are printed as &ldquo;<code>da</code>&rdquo;; see the note at <code>deriv.Rd</code>
for details.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+freealg">freealg</a></code>,<code><a href="#topic+deriv">deriv</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
rfalg()

x &lt;- rfalg(inc=TRUE)
x                           # default
options("usecaret" = TRUE)  # use caret
x
options("usecaret" = FALSE) # back to the default
x


x &lt;- freealg(list(5,1:4,3,8,7),c(1,1,1,3,22))
x


options(mulsym = "*")
x
options(mulsym = NULL)  # restore default

</code></pre>

<hr>
<h2 id='rfalg'>Random free algebra objects</h2><span id='topic+rfalg'></span><span id='topic+rfalgg'></span><span id='topic+rfalggg'></span><span id='topic+rfreealg'></span><span id='topic+rfree'></span>

<h3>Description</h3>

<p>Random elements of the free algebra, intended as quick
&ldquo;get you going&rdquo; examples of <code>freealg</code> objects</p>


<h3>Usage</h3>

<pre><code class='language-R'>rfalg(n=7, distinct=3, maxsize=4, include.negative=FALSE)
rfalgg(n=30, distinct=8, maxsize=7, include.negative=FALSE)
rfalggg(n=100, distinct=26, maxsize=30, include.negative=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rfalg_+3A_n">n</code></td>
<td>
<p>Number of terms to generate</p>
</td></tr>
<tr><td><code id="rfalg_+3A_distinct">distinct</code></td>
<td>
<p>Number of distinct symbols to use</p>
</td></tr>
<tr><td><code id="rfalg_+3A_maxsize">maxsize</code></td>
<td>
<p>Maximum number of symbols in any word</p>
</td></tr>
<tr><td><code id="rfalg_+3A_include.negative">include.negative</code></td>
<td>
<p>Boolean, with default <code>FALSE</code> meaning to
use only positive symbols (lower-case letters) and <code>TRUE</code>
meaning to use upper-case letters as well, corresponding to the
inverse of the lower-case symbols</p>
</td></tr>
</table>


<h3>Details</h3>

<p>What you see is what you get, basically.  A term such as
<code>aaBaAbaC</code> will be simplified to <code>aaaC</code>.
</p>
<p>Functions <code>rfalgg()</code> and <code>rfalggg()</code> return successively more
complicated <code>freealg</code> objects.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>rfalg()
rfalg(include.negative=TRUE)^2


constant(rfalg())

</code></pre>

<hr>
<h2 id='subs'>Substitution</h2><span id='topic+subs'></span><span id='topic+subsu'></span><span id='topic+substitute'></span><span id='topic+namechanger'></span>

<h3>Description</h3>

<p>Substitute symbols in a <code>freealg</code> object for numbers or other
<code>freealg</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subs(S, ...)
subsu(S1,S2,r)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="subs_+3A_s">S</code>, <code id="subs_+3A_s1">S1</code>, <code id="subs_+3A_s2">S2</code></td>
<td>
<p>Objects of class <code>freealg</code></p>
</td></tr>
<tr><td><code id="subs_+3A_r">r</code></td>
<td>
<p>Integer specifying symbol to substitute (<code class="reqn">a=1,b=2</code> etc)</p>
</td></tr>
<tr><td><code id="subs_+3A_...">...</code></td>
<td>
<p>named arguments corresponding to variables to substitute</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>subs()</code> substitutes variables for <code>freealg</code> objects
(coerced if necessary) using natural <span class="rlang"><b>R</b></span> idiom.  Observe that this type
of substitution is sensitive to order:
</p>
<pre>
&gt; subs("ax",a="1+x",x="1+a")
free algebra element algebraically equal to
 + 2 + 3*a + 1*aa

&gt; subs("ax",x="1+a",a="1+x")
free algebra element algebraically equal to
 + 2 + 3*x + 1*xx

</pre>
<p>Functions <code>subsu()</code> is a lower-level formal function, not really
intended for the end-user.  Function <code>subsu()</code> takes <code>S1</code> and
substitutes occurrences of symbol <code>r</code> with <code>S2</code>.
</p>
<p>No equivalent to <code>mvp::subvec()</code> is currently implemented.
</p>


<h3>Value</h3>

<p>Returns a <code>freealg</code> object.
</p>


<h3>Note</h3>

<p>Function <code>subs()</code> is one place in the package where the use of
<code>letters</code> is effectively hard-wired in.  Idiom such as
</p>
<p><code>subs("abccc",b="1+3x")</code>
</p>
<p>is very nice, but identifies &ldquo;b&rdquo; with 2.  Note that argument
<code>r</code> of <code>subsu()</code> is canonically an integer but a single
character is interpreted as a <code>letter</code>.  See also the <code>note</code>
at <code>freealg.Rd</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>subs("abccc",b="1+3x")
subs("aaaa",a="1+x")  # binomial

subs("abA",b=31)

subs("1+a",a="A")   # can substitute for an inverse
subs("A",a="1+x")   # inverses are not substituted for


## Sequential substitution works:

subs("abccc",b="1+3x",x="1+d+2e")
subs(rfalg(),a=rfalg())

</code></pre>

<hr>
<h2 id='zero'>The zero algebraic object</h2><span id='topic+zero'></span><span id='topic+is.zero'></span>

<h3>Description</h3>

<p>Test for a <code>freealg</code> object's being zero
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.zero(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zero_+3A_x">x</code></td>
<td>
<p>Object of class <code>freealg</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>is.zero()</code> returns <code>TRUE</code> if <code>x</code> is indeed
the zero free algebra object.  It is defined as
<code>length(coeffs(x))==0</code> for reasons of efficiency, but
conceptually it returns <code>x==constant(0)</code>.
</p>
<p>(Use <code>constant(0)</code> to create the zero object).
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+constant">constant</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
stopifnot(is.zero(constant(0)))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
