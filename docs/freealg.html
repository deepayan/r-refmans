<!DOCTYPE html><html><head><title>Help for package freealg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {freealg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#freealg-package'>
<p>The Free Algebra</p></a></li>
<li><a href='#abelianize'><p>Abelianize a <code>freealg</code> object</p></a></li>
<li><a href='#accessor'><p>Accessor methods for freealg objects</p></a></li>
<li><a href='#adjoint'><p>The adjoint map</p></a></li>
<li><a href='#constant'><p>The constant term</p></a></li>
<li><a href='#deriv'><p>Differentiation of <code>freealg</code> objects</p></a></li>
<li><a href='#dot-class'><p>Class &ldquo;dot&rdquo;</p></a></li>
<li><a href='#drop'><p>Drop redundant information</p></a></li>
<li><a href='#freealg'><p>The free algebra</p></a></li>
<li><a href='#grade'><p>The grade (or degree) of terms in a <code>freealg</code> object</p></a></li>
<li><a href='#horner'><p>Horner's method</p></a></li>
<li><a href='#linear'><p>A simple free algebra object</p></a></li>
<li><a href='#nterms'><p>Number of terms in a freealg object</p></a></li>
<li><a href='#Ops.freealg'><p>Arithmetic Ops methods for the the free algebra</p></a></li>
<li><a href='#pepper'><p>Combine variables in every possible order</p></a></li>
<li><a href='#print'><p>Print freealg objects</p></a></li>
<li><a href='#rfalg'><p>Random free algebra objects</p></a></li>
<li><a href='#subs'><p>Substitution</p></a></li>
<li><a href='#zero'><p>The zero algebraic object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>The Free Algebra</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1-1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), methods</td>
</tr>
<tr>
<td>Description:</td>
<td>The free algebra in R with non-commuting indeterminates.
     Uses 'disordR' discipline
     (Hankin, 2022, &lt;<a href="https://doi.org/10.48550%2FARXIV.2210.03856">doi:10.48550/ARXIV.2210.03856</a>&gt;).  To cite the
     package in publications please use Hankin (2022)
     &lt;<a href="https://doi.org/10.48550%2FARXIV.2211.04002">doi:10.48550/ARXIV.2211.04002</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0-7), partitions (&ge; 1.9-22), mathjaxr, disordR (&ge;
0.9)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr,testthat,magrittr,markdown,rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/RobinHankin/freealg">https://github.com/RobinHankin/freealg</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/RobinHankin/freealg/issues">https://github.com/RobinHankin/freealg/issues</a></td>
</tr>
<tr>
<td>RdMacros:</td>
<td>mathjaxr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-20 19:06:43 UTC; rhankin</td>
</tr>
<tr>
<td>Author:</td>
<td>Robin K. S. Hankin
    <a href="https://orcid.org/0000-0001-5982-0415"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-20 19:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='freealg-package'>
The Free Algebra
</h2><span id='topic+freealg-package'></span>

<h3>Description</h3>

<p>The free algebra in R with non-commuting indeterminates.
     Uses 'disordR' discipline
     (Hankin, 2022, &lt;doi:10.48550/ARXIV.2210.03856&gt;).  To cite the
     package in publications please use Hankin (2022)
     &lt;doi:10.48550/ARXIV.2211.04002&gt;.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> freealg</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> The Free Algebra</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.1-1</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> person(given=c("Robin", "K. S."), family="Hankin", role = c("aut","cre"), email="hankin.robin@gmail.com", comment = c(ORCID = "0000-0001-5982-0415"))</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 3.5.0), methods</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> The free algebra in R with non-commuting indeterminates.
     Uses 'disordR' discipline
     (Hankin, 2022, &lt;doi:10.48550/ARXIV.2210.03856&gt;).  To cite the
     package in publications please use Hankin (2022)
     &lt;doi:10.48550/ARXIV.2211.04002&gt;.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyData: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> Rcpp (&gt;= 1.0-7), partitions (&gt;= 1.9-22), mathjaxr, disordR (&gt;= 0.9)</td>
</tr>
<tr>
 <td style="text-align: left;">
LinkingTo: </td><td style="text-align: left;"> Rcpp</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> knitr,testthat,magrittr,markdown,rmarkdown</td>
</tr>
<tr>
 <td style="text-align: left;">
VignetteBuilder: </td><td style="text-align: left;"> knitr</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://github.com/RobinHankin/freealg</td>
</tr>
<tr>
 <td style="text-align: left;">
BugReports: </td><td style="text-align: left;"> https://github.com/RobinHankin/freealg/issues</td>
</tr>
<tr>
 <td style="text-align: left;">
RdMacros: </td><td style="text-align: left;"> mathjaxr</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Robin K. S. Hankin [aut, cre] (&lt;https://orcid.org/0000-0001-5982-0415&gt;)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
Ops.freealg             Arithmetic Ops methods for the the free algebra
abelianize              Abelianize a 'freealg' object
accessor                Accessor methods for freealg objects
adjoint                 The adjoint map
constant                The constant term
deriv                   Differentiation of 'freealg' objects
dot-class               Class "dot"
drop                    Drop redundant information
freealg                 The free algebra
freealg-package         The Free Algebra
grade                   The grade (or degree) of terms in a 'freealg'
                        object
horner                  Horner's method
linear                  A simple free algebra object
nterms                  Number of terms in a freealg object
pepper                  Combine variables in every possible order
print.freealg           Print freealg objects
rfalg                   Random free algebra objects
subs                    Substitution
zero                    The zero algebraic object
</pre>


<h3>Author(s)</h3>

<p>NA
</p>
<p>Maintainer: Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a &lt;- as.freealg("x+xyx")
b &lt;- as.freealg("4x +XyX")  # upper-case interpreted as inverse

a+b
stopifnot(a+b==b+a)   # should be TRUE

a*b ==b*a # FALSE; noncommutative algebra

as.freealg("1+X+xy")^3

rfalg()
rfalg()^2


</code></pre>

<hr>
<h2 id='abelianize'>Abelianize a <code>freealg</code> object</h2><span id='topic+abelianize'></span>

<h3>Description</h3>

<p>Function <code>abelianize()</code> returns a <code>freealg</code> object that is
equivalent to its argument under assumption of Abelianness.  The symbols
are placed in alphabetical order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abelianize(x)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abelianize_+3A_x">x</code></td>
<td>
<p>A <code>freealg</code> object</p>
</td></tr></table>


<h3>Details</h3>

<p>Abelianizing a free group element means that the symbols can commute
past one another.  Abelianization is vectorized.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>freealg</code>.</p>


<h3>Note</h3>

<p>There is a very similar function in the <span class="pkg">freegroup</span> package.</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
abelianize(as.freealg("ba + 2abbba + 3abAB"))

abelianize(.[rfalg(),rfalg()])

</code></pre>

<hr>
<h2 id='accessor'>Accessor methods for freealg objects</h2><span id='topic+accessor'></span><span id='topic+accessors'></span><span id='topic+words'></span><span id='topic+coeffs'></span><span id='topic+coeffs+3C-'></span><span id='topic+coeffs+3C-.freealg'></span><span id='topic+coefficients'></span>

<h3>Description</h3>

<p>Accessor methods for free algebra objects</p>


<h3>Usage</h3>

<pre><code class='language-R'>words(x)
coeffs(x)
coeffs(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="accessor_+3A_x">x</code></td>
<td>
<p>Object of class <code>freealg</code></p>
</td></tr>
<tr><td><code id="accessor_+3A_value">value</code></td>
<td>
<p>Numeric vector of length 1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Access or set the different parts of an <code>freealg</code> object.  The
constant term is technically a coefficient but is documented under
<code>constant.Rd</code>.
</p>


<h3>Note</h3>

<p>There is an extended discussion of this issue in the <code>mvp</code> object
at <code>accessor.Rd</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+constant">constant</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- rfalg()
a
coeffs(a)
words(a)  # Note hash is identical to that of coeffs(a)

coeffs(a) &lt;- 7   # replacement methods work 
a
coeffs(a)  # 
</code></pre>

<hr>
<h2 id='adjoint'>The adjoint map</h2><span id='topic+adjoint'></span><span id='topic+ad'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>The adjoint \(\mathrm{ad}_X\) of \(X\) is a map from a
Lie group \(G\) to the endomorphism group of \(G\) defined
by
</p>
\[\mathrm{ad}_X(Y)=\left[X,Y\right]\]


<h3>Usage</h3>

<pre><code class='language-R'>ad(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjoint_+3A_x">x</code></td>
<td>
<p>Object nominally of class <code>freealg</code> but other classes
accepted where they make sense</p>
</td></tr>
</table>


<h3>Details</h3>

<p>details here
</p>


<h3>Note</h3>

<p>Vignette <code>adjoint</code> gives more description</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rfalg()
y &lt;- rfalg()

f &lt;- ad(x)
f(y)


f(f(y)) # [x,[x,y]]

</code></pre>

<hr>
<h2 id='constant'>The constant term</h2><span id='topic+constant'></span><span id='topic+constant'></span><span id='topic+is.constant'></span><span id='topic+constant+3C-'></span><span id='topic+constant.freealg'></span><span id='topic+constant+3C-.freealg'></span><span id='topic+constant.numeric'></span>

<h3>Description</h3>

<p>Get and set the constant term of a <code>freealg</code> object</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'freealg'
constant(x)
## S3 method for class 'numeric'
constant(x)
## S3 replacement method for class 'freealg'
constant(x) &lt;- value
is.constant(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constant_+3A_x">x</code></td>
<td>
<p>Object of class <code>freealg</code></p>
</td></tr>
<tr><td><code id="constant_+3A_value">value</code></td>
<td>
<p>Scalar value for the constant</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The constant term in a free algebra object is the coefficient of the
empty term.  In a <code>freealg</code> object, the map including <code>{}
  -&gt; v</code> implies that <code>v</code> is the constant.
</p>
<p>If <code>x</code> is a <code>freealg</code> object, <code>constant(x)</code> returns
the value of the constant in the multivariate polynomial; if <code>x</code>
is numeric, it returns a constant <code>freealg</code> object with value
<code>x</code>.
</p>
<p>Function <code>is.constant()</code> returns <code>TRUE</code> if its argument has
no variables and <code>FALSE</code> otherwise.
</p>
<p>Setting the coefficients of the empty <code>freealg</code> returns the zero
(empty) object.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- as.freealg("1+X+Y+xy")

constant(p)
constant(p^5)

constant(p) &lt;- 1000
p


</code></pre>

<hr>
<h2 id='deriv'>Differentiation of <code>freealg</code> objects</h2><span id='topic+deriv'></span><span id='topic+aderiv'></span><span id='topic+deriv.freealg'></span><span id='topic+deriv_freealg'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Differentiation of <code>freealg</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'freealg'
deriv(expr, r, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deriv_+3A_expr">expr</code></td>
<td>
<p>Object of class <code>freealg</code></p>
</td></tr>
<tr><td><code id="deriv_+3A_r">r</code></td>
<td>
<p>Integer vector.  Elements denote variables to differentiate
with respect to.  If <code>r</code> is a character vector, it is
interpreted as <code>a=1,b=2,...,z=26</code>; if of length 1,
&ldquo;<code>aab</code>&rdquo; is interpreted as <code>c("a","a","b")</code></p>
</td></tr>
<tr><td><code id="deriv_+3A_...">...</code></td>
<td>
<p>Further arguments, currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Experimental function <code>deriv(S,v)</code> returns
\(\frac{\partial^r S}{\partial v_1\partial v_2\ldots\partial
      v_r}\).  The Leibniz product rule
</p>
\[\left(u\cdot v\right)'=uv'+u'v\]
<p>operates even if (as here) <i>u,v</i> do not commute.  For example, if
we wish to differentiate <i>aaba</i> with respect to <i>a</i>, we would
write <i>f(a) = aaba</i> and then
</p>
<p style="text-align: center;"><i>f(a+&delta; a) = (a+&delta; a)(a+&delta; a)b(a+&delta; a)</i></p>

<p>and working to first order we have
</p>
<p style="text-align: center;"><i>f(a+&delta; a) -f(a)= (&delta; a)aba + a(&delta; a)ba + aab(&delta;
  a).</i></p>
<p>  In the package:
</p>
<pre>

    &gt; deriv(as.freealg("aaba"),"a")
    free algebra element algebraically equal to
    + 1*aab(da) + 1*a(da)ba + 1*(da)aba
</pre>
<p>A term of a <code>freealg</code> object can include negative values which
correspond to negative powers of variables.  Thus:
</p>
<pre>
    &gt; deriv(as.freealg("AAAA"),"a")       
    free algebra element algebraically equal to
    - 1*AAAA(da)A - 1*AAA(da)AA - 1*AA(da)AAA - 1*A(da)AAAA
  </pre>
<p>(see also the examples).  Vector <code>r</code> may include negative
integers which mean to differentiate with respect to the inverse of
the variable:
</p>
<pre>
    &gt; deriv(as.freealg("3abcbCC"),"C")
    free algebra element algebraically equal to
    + 3*abcbC(dC) + 3*abcb(dC)C - 3*abc(dC)cbCC
  </pre>
<p>It is possible to perform repeated differentiation by passing a
suitable value of <code>r</code>.  For
\(\frac{\partial^2}{\partial a\partial c}\):
</p>
<pre>
    &gt; deriv(as.freealg("aaabAcx"),"ac")
    free algebra element algebraically equal to
    - 1*aaabA(da)A(dc)x + 1*aa(da)bA(dc)x + 1*a(da)abA(dc)x + 1*(da)aabA(dc)x
  </pre>
<p>The infinitesimal indeterminates (&ldquo;<code>da</code>&rdquo; etc) are
represented by <code>SHRT_MAX+r</code>, where <code>r</code> is the integer for
the symbol, and <code>SHRT_MAX</code> is the maximum short integer.  This
includes negative <code>r</code>.  So the maximum number for any symbol is
<code>SHRT_MAX</code>.  Inverse elements such as <code>A</code>, being represented
by negative integers, have differentials that are <code>SHRT_MAX-r</code>.
</p>
<p>Function <code>deriv()</code> calls helper function <code>lowlevel_diffn()</code>
which is documented at <code>Ops.freealg.Rd</code>.
</p>
<p>A vignette illustrating this concept and furnishing numerical
verification of the code in the context of matrix algebra is given at
<code>inst/freealg_matrix.Rmd</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
deriv(as.freealg("4*aaaabaacAc"),1)

x &lt;- rfalg()
deriv(x,1:3)

y &lt;- rfalg(7,7,17,TRUE)

deriv(y,1:5)-deriv(y,sample(1:5)) # should be zero


</code></pre>

<hr>
<h2 id='dot-class'>Class &ldquo;dot&rdquo;</h2><span id='topic+dot'></span><span id='topic+.'></span><span id='topic+dot-class'></span><span id='topic+commutator'></span><span id='topic+jacobi'></span><span id='topic+dot_error'></span><span id='topic++5B.dot'></span><span id='topic++5B+2Cdot-method'></span><span id='topic++5B+2Cdot+2CANY+2CANY-method'></span><span id='topic++5B+2Cdot+2CANY+2Cmissing-method'></span><span id='topic++5B+2Cdot+2Cmissing+2CANY-method'></span><span id='topic++5B+2Cdot+2Cmissing+2Cmissing-method'></span><span id='topic++5B+2Cdot+2Cmatrix+2Cmatrix-method'></span><span id='topic++5B+2Cdot+2Cfunction+2Cfunction-method'></span><span id='topic++5B+2Cdot+2CANY+2CANY+2CANY-method'></span><span id='topic++5B+2Cdot+2CANY+2Cmissing+2CANY-method'></span><span id='topic++5B+2Cdot+2Cfunction+2Cfunction+2CANY-method'></span><span id='topic++5B+2Cdot+2Cmatrix+2Cmatrix+2CANY-method'></span><span id='topic++5B+2Cdot+2Cmissing+2CANY+2CANY-method'></span><span id='topic++5B+2Cdot+2Cmissing+2Cmissing+2CANY-method'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>The dot object is defined so that idiom like <code>.[x,y]</code> returns the
commutator, that is, <code>xy-yx</code> or the Lie bracket \([x,y]\).  It
would have been nice to use <code>[x,y]</code> (that is, without the dot) but
although this is syntactically consistent, it cannot be done in R.
</p>
<p>The &ldquo;meat&rdquo; of the dot functionality is:
</p>
<pre>
setClass("dot", slots = c(ignore='numeric'))
`.` &lt;- new("dot")
setMethod("[",signature(x="dot",i="ANY",j="ANY"),function(x,i,j,drop){i*j-j*i})
</pre>
<p>The package code includes other bits and pieces such as informative
error messages for idiom such as <code>.[]</code>.  The package defines a
matrix method for the dot object.  This is because &ldquo;<code>*</code>&rdquo;
returns (incorrectly, in my view) the elementwise product, not the
matrix product.
</p>
<p>The Jacobi identity, satisfied by any associative algebra, is
</p>
\[
  \left[x,\left[y,z\right]\right]+
  \left[y,\left[z,x\right]\right]+
  \left[z,\left[x,y\right]\right]=0
\]
<p>and the left hand side is returned by <code>jacobi()</code>, which should be
zero (for some definition of &ldquo;zero&rdquo;).
</p>
<p>Function <code>ad()</code> returns the adjoint operator.  The <code>adjoint</code>
vignette provides details and examples of the adjoint operator.
</p>
<p>The dot object is generated by running script <code>inst/dot.Rmd</code>, which
includes some further discussion and technical documentation, and
creates file <code>dot.rda</code> which resides in the <code>data/</code> directory.
</p>


<h3>Value</h3>

<p>Always returns an object of the same class as <code>xy</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>ignore</code>:</dt><dd><p>Object of class <code>"numeric"</code>, just a
formal placeholder</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>[</dt><dd><p><code>signature(x = "dot", i = "ANY", j = "ANY")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "dot", i = "ANY", j = "missing")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "dot", i = "function", j = "function")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "dot", i = "matrix", j = "matrix")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "dot", i = "missing", j = "ANY")</code>: ... </p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "dot", i = "missing", j = "missing")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
.[as.freealg("x"),as.freealg("y")]
.[as.freealg("x"),as.freealg("y+2z")]
.[as.freealg("x+y+2xYx"),as.freealg("x+y+2xYx")]


x &lt;- rfalg()
y &lt;- rfalg()
z &lt;- rfalg()

jacobi(x,y,z) # Jacobi identity
.[x,.[y,z]] + .[y,.[z,x]] + .[z,.[x,y]]  # Jacobi, expanded


f &lt;- ad(x)
f(y)


rM &lt;- function(...){matrix(sample(1:9,9),3,3)} # a random matrix

M &lt;- rM()
N &lt;- rM()
O &lt;- rM()

.[M,N]
jacobi(M,N,O)

</code></pre>

<hr>
<h2 id='drop'>Drop redundant information</h2><span id='topic+drop'></span><span id='topic+drop+2Cfreealg-method'></span>

<h3>Description</h3>

<p>Coerce constant free algebra objects to numeric</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop(x)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop_+3A_x">x</code></td>
<td>
<p>Free algebra object</p>
</td></tr></table>


<h3>Details</h3>

<p>If its argument is a constant freealg object, coerce to numeric.</p>


<h3>Note</h3>

<p>A few functions in the package take <code>drop</code> as an argument
which, if <code>TRUE</code>, means that the function returns a
<code>drop</code>ped value.</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+constant">constant</a></code>,<code><a href="#topic+coeffs">coeffs</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>drop(linear(1:5))
drop(4+linear(1:5)*0)
</code></pre>

<hr>
<h2 id='freealg'>The free algebra</h2><span id='topic+freealg'></span><span id='topic+is.freealg'></span><span id='topic+as.freealg'></span><span id='topic+is_ok_free'></span><span id='topic+char_to_freealg'></span><span id='topic+natural_char_to_freealg'></span><span id='topic+numeric_to_free'></span><span id='topic+vector_to_free'></span><span id='topic+string_to_freealg'></span>

<h3>Description</h3>

<p>Create, test for, and coerce to, <code>freealg</code> objects</p>


<h3>Usage</h3>

<pre><code class='language-R'>freealg(words, coeffs)
is_ok_free(words,coeffs)
is.freealg(x)
as.freealg(x,...)
char_to_freealg(ch)
natural_char_to_freealg(string)
string_to_freealg(string)
vector_to_free(v,coeffs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freealg_+3A_words">words</code></td>
<td>
<p>Terms of the algebra object, eg <code>c(1,2,-1,-3,-2)</code>
corresponds to <code>abACB</code> because <code class="reqn">a=1</code>, <code class="reqn">b=2</code> etc;
uppercase, or negative number, means inverse</p>
</td></tr>
<tr><td><code id="freealg_+3A_coeffs">coeffs</code></td>
<td>
<p>Numeric vector corresponding to the coefficients of each
element of the <code>word</code> list</p>
</td></tr>
<tr><td><code id="freealg_+3A_string">string</code></td>
<td>
<p>Character string</p>
</td></tr>
<tr><td><code id="freealg_+3A_ch">ch</code></td>
<td>
<p>Character vector</p>
</td></tr>
<tr><td><code id="freealg_+3A_v">v</code></td>
<td>
<p>Vector of integers</p>
</td></tr>
<tr><td><code id="freealg_+3A_x">x</code></td>
<td>
<p>Object possibly of class <code>freealg</code></p>
</td></tr>
<tr><td><code id="freealg_+3A_...">...</code></td>
<td>
<p>Further arguments, passed to the methods</p>
</td></tr>
</table>


<h3>Details</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Function <code>freealg()</code> is the formal creation mechanism for
<code>freealg</code> objects.  However, it is not very user-friendly; it is
better to use <code>as.freealg()</code> in day-to-day use.
</p>
<p>Function <code>is_ok_freealg()</code> checks for consistency of its arguments.
</p>
<p>A <code>freealg</code> object is a two-element list.  The first element is a
list of integer vectors representing the indices and the second is a
numeric vector of coefficients.  Thus, for example:
</p>
<pre>
&gt; as.freealg("a+4bd+3abbbbc")
free algebra element algebraically equal to
 + 1*a + 3*abbbbc + 4*bd
&gt; dput(as.freealg("a+4bd+3abbbbc"))
structure(list(indices = list(1L, c(1L, 2L, 2L, 2L, 2L, 3L), 
    c(2L, 4L)), coeffs = c(1, 3, 4)), class = "freealg")
</pre>
<p>Observe that the order of the terms is not preserved and indeed is
undefined (implementation-specific).  Zero entries are stripped out.
</p>
<p>Character strings may be coerced to <code>freealg</code> objects;
<code>as.freealg()</code> calls <code>natural_char_to_freealg()</code>, which is
user-friendly.  Functions <code>char_to_freealg()</code> and
<code>string_to_freealg()</code> are low-level helper functions.  These
functions assume that upper-case letters are the multiplicative inverses
of the lower-case equivalents; so for example <code>as.freealg("aA")</code>
and <code>as.freealg(aBcCbA)</code> evaluate to one.  This can be confusing
with the default print method.
</p>
<p>Even though individual symbols have multiplicative inverses, a general
element of the free algebra will not have a multiplicative inverse.  For
example, <code>1+x</code> does not have an inverse.  The free algebra is not a
division algebra, in general.
</p>


<h3>Note</h3>

<p>Internally, the package uses signed integers and as such can have
<code>.Machine$integer.max</code> different symbols; on my machine this is
2147483647.  Of course the print method cannot deal with this as it
only has 26 symbols for letters a-z (and A-Z for the inverses), but
the objects themselves do not care about the print method.  Note also
that the experimental calculus facility (as per <code>deriv()</code>)
reserves numbers in the range <code>SHRT_MAX</code>\({}\pm r\) for
infinitesimals, where <code>r</code> is the integer for a symbol.  This
system might change in the future.  </p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
freealg(list(1:2, 2:1,numeric(0),1:6),1:4)

freealg(sapply(1:5,seq_len),1:5)

freealg(replicate(5,sample(-5:5,rgeom(1,1/5),replace=TRUE)),1:5)


as.freealg("1+xaX")^5


</code></pre>

<hr>
<h2 id='grade'>The grade (or degree) of terms in a <code>freealg</code> object
</h2><span id='topic+grade'></span><span id='topic+grade+3C-'></span><span id='topic+grades'></span><span id='topic+degree'></span><span id='topic+degrees'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>The free algebra \(\mathcal B\) is a <dfn>graded</dfn> algebra: that
is, for each integer \(n\geq 0\) there is a homogeneous
subspace \(\mathcal{B}_n\) with
\(\mathcal{B}_0=\mathcal{R}\) and
</p>
\[
  \mathcal{B}=\bigoplus_{n=0}^\infty\mathcal{B}_n,\quad\mbox{and}\quad\mathcal{B}_n\mathcal{B}_m\subseteq\mathcal{B}_{n+m}\quad\mbox{for all $m,n\geq  0.$}
\]
<p>The elements of \(\cup_{n\geq 0}\mathcal{B}_n\) are
called <dfn>homogeneous</dfn> and those of \(\mathcal{B}_n\) are
called homogenous of degree (or grade) \(n\).
</p>
<p>The grade of a term is the number of symbols in it.  Thus the grade of
<code>xxx</code> and <code>4xxy</code> is 3; the grade of a constant is zero.
Because the terms are stored in an implementation-specific way, the
grade of a multi-term object is a <code>disord</code> object.
</p>
<p>The grade of the zero <code>freealg</code> object,
<code>grade(as.freealg(0))</code>, is defined to be zero, which ensures that
<code>max(grades(abelianize(x))) &lt;= max(grades(x))</code> is always satisfied.
However, a case for <code>NULL</code> could be made.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grades(x)
grade(x,n)
grade(x,n) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grade_+3A_x">x</code></td>
<td>
<p>Freealg object</p>
</td></tr>
<tr><td><code id="grade_+3A_n">n</code></td>
<td>
<p>Integer vector</p>
</td></tr>
<tr><td><code id="grade_+3A_value">value</code></td>
<td>
<p>Replacement value, a numeric vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>grades(x)</code> returns the grade (number of symbols) in each term
of a <code>freealg</code> object <code>x</code>.
</p>
<p><code>grade(x,n)</code> returns the freealg object comprising terms with
grade <code>n</code> (which may be a vector).  Note that this function is
considerably less efficient than <code>clifford::grade()</code>.
</p>
<p><code>grade(x,n) &lt;- value</code> sets the coefficients of terms with grade
<code>n</code>.  For <code>value</code>, a length-one numeric vector is accepted
(notably zero, which kills terms of grade <code>n</code>) and also a
<code>freealg</code> object comprising terms of grade coden.
</p>


<h3>Value</h3>

<p>Returns a disord object</p>


<h3>Note</h3>

<p>A similar concept <dfn>grade</dfn> is discussed in the <span class="pkg">clifford</span>
package</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>

<p>H. Munthe-Kaas and B. Owren 1999.  &ldquo;Computations in a free Lie
algebra&rdquo;, <em>Phil. Trans. R. Soc. Lond. A</em>, 357:957&ndash;981 (theorem 3.8)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

X &lt;- as.freealg("1 -x + 5*y + 6*x*y -8*x*x*x*x*y*x")
X
grades(X)

a &lt;- rfalg(30)
a
grades(a)
grade(a,2)
grade(a,2) &lt;- 0 # kill all grade-2 terms
a

grade(a,1) &lt;- grade(a,1) * 888 
a
</code></pre>

<hr>
<h2 id='horner'>Horner's method</h2><span id='topic+horner'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Horner's method for multivariate polynomials
</p>


<h3>Usage</h3>

<pre><code class='language-R'>horner(P,v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="horner_+3A_p">P</code></td>
<td>
<p>Free algebra polynomial</p>
</td></tr>
<tr><td><code id="horner_+3A_v">v</code></td>
<td>
<p>Numeric vector of coefficients</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is (almost) the same as <code>mvp::horner()</code>.
</p>
<p>Given a polynomial
</p>
\[p(x) = a_0 +a_1+a_2x^2+\cdots + a_nx^n\]
<p>it is possible to express <i>p(x)</i> in the algebraically equivalent
form
</p>
\[p(x) = a_0 + x\left(a_1+x\left(a_2+\cdots + x\left(a_{n-1} +xa_n
\right)\cdots\right)\right)\]
<p>which is much more efficient for evaluation, as it requires only <i>n</i>
multiplications and <i>n</i> additions, and this is optimal.  Function
<code>horner()</code> will take a <code>freealg</code> object for its first
argument.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
horner("x",  1:4)  # note constant term is 1.

horner("x+y",1:3) # note presence of xy and yx terms

horner("1+x+xyX",1:3)
</code></pre>

<hr>
<h2 id='linear'>A simple free algebra object</h2><span id='topic+linear'></span>

<h3>Description</h3>

<p>Create simple free algebra objects including linear expressions, for example
</p>
<pre>
&gt; linear(1:3)
free algebra element algebraically equal to
+ 1*a + 2*b + 3*c
&gt; linear(1:3,power=5)
free algebra element algebraically equal to
+ 1*aaaaa + 2*bbbbb + 3*ccccc
&gt;
</pre>


<h3>Usage</h3>

<pre><code class='language-R'>linear(x,power=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linear_+3A_x">x</code></td>
<td>
<p>Numeric vector of terms</p>
</td></tr>
<tr><td><code id="linear_+3A_power">power</code></td>
<td>
<p>Integer vector of powers</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Many of the functions documented at <code>mvp::special.Rd</code> do not make
sense in the context of the free algebra.  Function
<code>mvp::product()</code>, for example, imposes an order on the expansion.
</p>
<p>Function <code>constant()</code> is documented at <code>constant.Rd</code>, but is listed
below for convenience.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+constant">constant</a></code>, <code><a href="#topic+zero">zero</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>linear(1:3)         
linear(1:3,power=5)
linear(1:3,power=3:1)
</code></pre>

<hr>
<h2 id='nterms'>Number of terms in a freealg object</h2><span id='topic+nterms'></span><span id='topic+length'></span>

<h3>Description</h3>

<p>Number of terms in a freealg object; number of coefficients</p>


<h3>Usage</h3>

<pre><code class='language-R'>nterms(x)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nterms_+3A_x">x</code></td>
<td>
<p>Freealg object</p>
</td></tr></table>


<h3>Value</h3>

<p>Returns a non-negative integer</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>(a &lt;- freealg(list(1:3,4:7,1:10),1:3))
nterms(a)
nterms(a+1)
nterms(a*0)
</code></pre>

<hr>
<h2 id='Ops.freealg'>Arithmetic Ops methods for the the free algebra</h2><span id='topic+Ops.freealg'></span><span id='topic+ops'></span><span id='topic+inv'></span><span id='topic+free_negative'></span><span id='topic+freealg_negative'></span><span id='topic+free_times_free'></span><span id='topic+free_times_scalar'></span><span id='topic+free_plus_free'></span><span id='topic+free_plus_numeric'></span><span id='topic+free_power_scalar'></span><span id='topic+free_eq_free'></span><span id='topic+free_equal_free'></span><span id='topic+lowlevel_simplify'></span><span id='topic+lowlevel_free_prod'></span><span id='topic+lowlevel_free_sum'></span><span id='topic+lowlevel_free_power'></span><span id='topic+lowlevel_deriv'></span><span id='topic+lowlevel_diff'></span><span id='topic+lowlevel_diffn'></span><span id='topic+lowlevel_subs'></span>

<h3>Description</h3>

<p>Arithmetic operators for manipulation of freealg objects
such as addition, multiplication, powers, etc
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'freealg'
Ops(e1, e2)
free_negative(S)
free_power_scalar(S,n)
free_eq_free(e1,e2)
free_plus_numeric(S,x)
free_plus_free(e1,e2)
lowlevel_simplify(words,coeffs)
lowlevel_free_prod(words1,coeffs1,words2,coeffs2)
lowlevel_free_sum(words1,coeffs1,words2,coeffs2)
lowlevel_free_power(words,coeffs,n)
lowlevel_diffn(words,coeffs,r)
lowlevel_subs(words1, coeffs1, words2, coeffs2, r)
inv(S)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ops.freealg_+3A_s">S</code>, <code id="Ops.freealg_+3A_e1">e1</code>, <code id="Ops.freealg_+3A_e2">e2</code></td>
<td>
<p>Objects of class <code>freealg</code></p>
</td></tr>
<tr><td><code id="Ops.freealg_+3A_n">n</code></td>
<td>
<p>Integer, possibly non-positive</p>
</td></tr>
<tr><td><code id="Ops.freealg_+3A_r">r</code></td>
<td>
<p>Integer vector indicating variables to differentiate with
respect to</p>
</td></tr>
<tr><td><code id="Ops.freealg_+3A_x">x</code></td>
<td>
<p>Scalar value</p>
</td></tr>
<tr><td><code id="Ops.freealg_+3A_words">words</code>, <code id="Ops.freealg_+3A_words1">words1</code>, <code id="Ops.freealg_+3A_words2">words2</code></td>
<td>
<p>A list of words, that is, a list of integer vectors
representing the variables in each term</p>
</td></tr>
<tr><td><code id="Ops.freealg_+3A_coeffs">coeffs</code>, <code id="Ops.freealg_+3A_coeffs1">coeffs1</code>, <code id="Ops.freealg_+3A_coeffs2">coeffs2</code></td>
<td>
<p>Numeric vector representing the
coefficients of each word</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>Ops.freealg()</code> passes binary arithmetic operators
(&ldquo;<code>+</code>&rdquo;, &ldquo;<code>-</code>&rdquo;, &ldquo;<code>*</code>&rdquo;,
&ldquo;<code>^</code>&rdquo;, and &ldquo;<code>==</code>&rdquo;) to the appropriate
specialist function.
</p>
<p>The caret, as in <code>a^n</code>, denotes arithmetic exponentiation, as in
<code>x^3==x*x*x</code>.  The only comparison operators are equality and
inequality; <code>x==y</code> is defined as <code>is.zero(x-y)</code>.
</p>
<p>Functions <code>lowlevel_foo()</code> are low-level functions that interface
directly with the <code>C</code> routines in the <code>src/</code> directory and
are not intended for the end-user.
</p>
<p>Function <code>inv()</code> is defined only for freealg objects with a
single term.  If <code>x</code> has a single term we have
<code>inv(x)*x=x*inv(x)=1</code>.  There is no corresponding division in the
package because <code>a/b</code> may be either <code>a*inv(b)</code> or
<code>inv(b)*a</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>rfalg()
as.freealg("1+x+xy+yx")  # variables are non-commutative
as.freealg("x") * as.freealg("X") # upper-case letters are lower-case inverses

constant(as.freealg("x+y+X+Y")^6)  # OEIS sequence A035610

inv(as.freealg("2aaabAAAAx"))
</code></pre>

<hr>
<h2 id='pepper'>Combine variables in every possible order</h2><span id='topic+pepper'></span>

<h3>Description</h3>

<p>Given a list of variables, construct every term comprising only those
variables; function <code>pepper()</code> returns a free algebra object
equal to the sum of these terms.
</p>
<p>The function is named for a query from an exam question set by Sarah
Marshall in which she asked how many ways there are to arrange the
letters of word &ldquo;pepper&rdquo;, the answer being <code class="reqn">\left({6\atop
  1\,2\,3}\right)=\frac{6!}{1!2!3!}=60</code>.
</p>
<p>Function <code>multiset()</code> in the <code>partitions</code> package gives
related functionality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pepper(v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pepper_+3A_v">v</code></td>
<td>
<p>Variables to combine.  If a character string, coerce to
variable numbers</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+linear">linear</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>pepper(c(1,2,2,2,3))
pepper("pepper")
</code></pre>

<hr>
<h2 id='print'>Print freealg objects</h2><span id='topic+print.freealg'></span>

<h3>Description</h3>

<p>Print methods for free algebra objects</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'freealg'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_+3A_x">x</code></td>
<td>
<p>Object of class <code>freealg</code> in the print method</p>
</td></tr>
<tr><td><code id="print_+3A_...">...</code></td>
<td>
<p>Further arguments, currently ignored</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The print method does not change the internal representation of a
<code>freealg</code> object, which is a two-element list, the first of which
is a list of integer vectors representing words, and the second is a
numeric vector of coefficients.
</p>
<p>The print method has special dispensation for length-zero freealg objects
but these are not handled entirely consistently.
</p>
<p>The print method is sensitive to the value of
<code>getOption("usecaret")</code>, defaulting to &ldquo;no&rdquo;.  The default is
to use uppercase letters to represent multiplicative inverses, but if
<code>TRUE</code>, inverses are indicated using &ldquo;<code>^-1</code>&rdquo;.  This
becomes cumbersome for powers above the first.  For example, the default
notation for <code class="reqn">aba^{-2}</code> is <code>abAA</code> but becomes
<code>aba^-1a^-1</code> if <code>usecaret</code> is <code>TRUE</code>.
</p>
<p>Integers exceeding <code>SHRT_MAX</code> are reserved for infinitesimals,
which are printed as &ldquo;<code>da</code>&rdquo;; see the note at <code>deriv.Rd</code>
for details.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+freealg">freealg</a></code>,<code><a href="#topic+deriv">deriv</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
rfalg()

x &lt;- rfalg(inc=TRUE)
x                           # default
options("usecaret" = TRUE)  # use caret
x
options("usecaret" = FALSE) # back to the default
x


</code></pre>

<hr>
<h2 id='rfalg'>Random free algebra objects</h2><span id='topic+rfalg'></span><span id='topic+rfreealg'></span><span id='topic+rfree'></span>

<h3>Description</h3>

<p>Random elements of the free algebra, intended as quick
&ldquo;get you going&rdquo; examples of <code>freealg</code> objects</p>


<h3>Usage</h3>

<pre><code class='language-R'>rfalg(n=7, distinct=3, maxsize=4, include.negative=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rfalg_+3A_n">n</code></td>
<td>
<p>Number of terms to generate</p>
</td></tr>
<tr><td><code id="rfalg_+3A_distinct">distinct</code></td>
<td>
<p>Number of distinct symbols to use</p>
</td></tr>
<tr><td><code id="rfalg_+3A_maxsize">maxsize</code></td>
<td>
<p>Maximum number of symbols in any word</p>
</td></tr>
<tr><td><code id="rfalg_+3A_include.negative">include.negative</code></td>
<td>
<p>Boolean, with default <code>FALSE</code> meaning to
use only positive symbols (lower-case letters) and <code>TRUE</code>
meaning to use upper-case letters as well, corresponding to the
inverse of the lower-case symbols</p>
</td></tr>
</table>


<h3>Details</h3>

<p>What you see is what you get, basically.  A term such as
<code>aaBaAbaC</code> will be simplified to <code>aaaC</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>rfalg()
rfalg(include.negative=TRUE)^2


constant(rfalg())

</code></pre>

<hr>
<h2 id='subs'>Substitution</h2><span id='topic+subs'></span><span id='topic+subsu'></span><span id='topic+substitute'></span><span id='topic+namechanger'></span>

<h3>Description</h3>

<p>Substitute symbols in a <code>freealg</code> object for numbers or other
<code>freealg</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subs(S, ...)
subsu(S1,S2,r)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subs_+3A_s">S</code>, <code id="subs_+3A_s1">S1</code>, <code id="subs_+3A_s2">S2</code></td>
<td>
<p>Objects of class <code>freealg</code></p>
</td></tr>
<tr><td><code id="subs_+3A_r">r</code></td>
<td>
<p>Integer specifying symbol to substitute (<code class="reqn">a=1,b=2</code> etc)</p>
</td></tr>
<tr><td><code id="subs_+3A_...">...</code></td>
<td>
<p>named arguments corresponding to variables to substitute</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>subs()</code> substitutes variables for <code>freealg</code> objects
(coerced if necessary) using natural <span class="rlang"><b>R</b></span> idiom.  Observe that this type
of substitution is sensitive to order:
</p>
<pre>
&gt; subs("ax",a="1+x",x="1+a")
free algebra element algebraically equal to
 + 2 + 3*a + 1*aa

&gt; subs("ax",x="1+a",a="1+x")
free algebra element algebraically equal to
 + 2 + 3*x + 1*xx

</pre>
<p>Functions <code>subsu()</code> is a lower-level formal function, not really
intended for the end-user.  Function <code>subsu()</code> takes <code>S1</code> and
substitutes occurrences of symbol <code>r</code> with <code>S2</code>.
</p>
<p>No equivalent to <code>mvp::subvec()</code> is currently implemented.
</p>


<h3>Value</h3>

<p>Returns a <code>freealg</code> object.
</p>


<h3>Note</h3>

<p>Function <code>subs()</code> is one place in the package where the use of
<code>letters</code> is effectively hard-wired in.  Idiom such as
</p>
<p><code>subs("abccc",b="1+3x")</code>
</p>
<p>is very nice, but identifies &ldquo;b&rdquo; with 2.  Note that argument
<code>r</code> of <code>subsu()</code> is canonically an integer but a single
character is interpreted as a <code>letter</code>.  See also the <code>note</code>
at <code>freealg.Rd</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>subs("abccc",b="1+3x")
subs("aaaa",a="1+x")  # binomial

subs("abA",b=31)

subs("1+a",a="A")   # can substitute for an inverse
subs("A",a="1+x")   # inverses are not substituted for


## Sequential substitution works:

subs("abccc",b="1+3x",x="1+d+2e")
subs(rfalg(),a=rfalg())

</code></pre>

<hr>
<h2 id='zero'>The zero algebraic object</h2><span id='topic+zero'></span><span id='topic+is.zero'></span>

<h3>Description</h3>

<p>Test for a <code>freealg</code> object's being zero
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.zero(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zero_+3A_x">x</code></td>
<td>
<p>Object of class <code>freealg</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>is.zero()</code> returns <code>TRUE</code> if <code>x</code> is indeed
the zero free algebra object.  It is defined as
<code>length(coeffs(x))==0</code> for reasons of efficiency, but
conceptually it returns <code>x==constant(0)</code>.
</p>
<p>(Use <code>constant(0)</code> to create the zero object).
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+constant">constant</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
stopifnot(is.zero(constant(0)))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
