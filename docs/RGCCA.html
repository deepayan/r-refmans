<!DOCTYPE html><html lang="en"><head><title>Help for package RGCCA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RGCCA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#available_methods'><p>Available methods for RGCCA</p></a></li>
<li><a href='#ECSI'><p>European Customer Satisfaction Index</p></a></li>
<li><a href='#plot.rgcca'><p>Plot a fitted object from the RGCCA package</p></a></li>
<li><a href='#print.rgcca'><p>Print a fitted object from the RGCCA package</p></a></li>
<li><a href='#rgcca'><p>Regularized Generalized Canonical Correlation Analysis (RGCCA)</p></a></li>
<li><a href='#rgcca_bootstrap'><p>Bootstrap confidence intervals and p-values</p></a></li>
<li><a href='#rgcca_cv'><p>Tune RGCCA parameters by cross-validation</p></a></li>
<li><a href='#rgcca_permutation'><p>Tune the S/RGCCA hyper-parameters by permutation</p></a></li>
<li><a href='#rgcca_predict'><p>Make predictions using RGCCA</p></a></li>
<li><a href='#rgcca_stability'><p>Identify the most stable variables with SGCCA</p></a></li>
<li><a href='#rgcca_transform'><p>Reduce dimensionality using RGCCA</p></a></li>
<li><a href='#Russett'><p>Russett data</p></a></li>
<li><a href='#summary.rgcca'><p>Summary of a fitted object from the RGCCA package</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Regularized and Sparse Generalized Canonical Correlation
Analysis for Multiblock Data</td>
</tr>
<tr>
<td>Version:</td>
<td>3.0.3</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Arthur Tenenhaus &lt;arthur.tenenhaus@centralesupelec.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Multi-block data analysis concerns the analysis of several
    sets of variables (blocks) observed on the same group of individuals.
    The main aims of the RGCCA package are: to study the relationships
    between blocks and to identify subsets of variables of each block
    which are active in their relationships with the other blocks. This
    package allows to (i) run R/SGCCA and related methods,
    (ii) help the user to find out the optimal parameters for R/SGCCA such
    as regularization parameters (tau or sparsity), (iii) evaluate the
    stability of the RGCCA results and their significance, (iv) build predictive
    models from the R/SGCCA. (v) Generic print()
    and plot() functions apply to all these functionalities.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>caret, Deriv, ggplot2 (&ge; 3.4.0), ggrepel, graphics,
gridExtra, MASS, matrixStats, methods, parallel, pbapply,
rlang, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>devtools, FactoMineR, knitr, pander, rmarkdown, rticles,
testthat, vdiffr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/rgcca-factory/RGCCA">https://github.com/rgcca-factory/RGCCA</a>,
<a href="https://rgcca-factory.github.io/RGCCA/">https://rgcca-factory.github.io/RGCCA/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rgcca-factory/RGCCA/issues">https://github.com/rgcca-factory/RGCCA/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-11 20:40:40 UTC; arthu</td>
</tr>
<tr>
<td>Author:</td>
<td>Fabien Girka [aut],
  Etienne Camenen [aut],
  Caroline Peltier [aut],
  Arnaud Gloaguen [aut],
  Vincent Guillemot [aut],
  Laurent Le Brusquet [ths],
  Arthur Tenenhaus [aut, ths, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-11 21:00:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='available_methods'>Available methods for RGCCA</h2><span id='topic+available_methods'></span>

<h3>Description</h3>

<p>List the methods that can be used with the rgcca function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>available_methods()
</code></pre>


<h3>Value</h3>

<p>A vector of the methods implemented with the rgcca function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>available_methods()
</code></pre>

<hr>
<h2 id='ECSI'>European Customer Satisfaction Index</h2><span id='topic+ECSI'></span>

<h3>Description</h3>

<p>The European Consumer Satisfaction Index (ECSI) is an economic indicator that
measures customer satisfaction. ECSI is an adaptation of the Swedish Customer
Satisfaction Barometer (Fornell, 1992) and is compatible with the American
Customer Satisfaction Index.  The indicators describing the latent variables
are given for the Mobile Phone Industry. The original items scaled from 1 to
10 have been transformed into new normalized variables. The minimum possible
value of each variable is 0 and its maximum possible value is equal to 10.
</p>

<dl>
<dt>IMAG</dt><dd><p>Image of the phone provider (eta_1) </p>

<ul>
<li><p> (a) Reputation of the phone provider,
</p>
</li>
<li><p> (b) Trustworthiness,
</p>
</li>
<li><p> (c) Seriousness,
</p>
</li>
<li><p> (d) Solidness,
</p>
</li>
<li><p> (e) Caring about customer's needs.
</p>
</li></ul>
</dd>
<dt>EXPE</dt><dd><p>Customer Expectations of the overall quality (eta_2) </p>

<ul>
<li><p> (a) Expectations for the overall quality of your &quot;mobile phone
provider&quot; at the moment you became customer of this provider,
</p>
</li>
<li><p> (b) Expectations for your &quot;mobile phone provider&quot; to provide
products and services to meet your personal need,
</p>
</li>
<li><p> (c) How often did you expect that things could go wrong at your
&quot;mobile phone provider&quot;.
</p>
</li></ul>
</dd>
<dt>QUAL</dt><dd><p>Perceived Quality (eta_3) </p>

<ul>
<li><p> (a) Overall perceived quality,
</p>
</li>
<li><p> (b) Overall perceived quality,
</p>
</li>
<li><p> (c) Customer service and personal advice offered,
</p>
</li>
<li><p> (d) Quality of the services you use,
</p>
</li>
<li><p> (e) Range of services and products offered,
</p>
</li>
<li><p> (f) Reliability and accuracy of the products and services
provided,
</p>
</li>
<li><p> (g) Clarity and transparency of information provided.
</p>
</li></ul>
</dd>
<dt>VAL</dt><dd><p>Perceived Value (eta_4) </p>

<ul>
<li><p> (a) Given the quality of the products and services offered by
your &quot;mobile phone provider&quot; how would you rate the fees and prices that
you pay for them?
</p>
</li>
<li><p> (b) Given the fees and prices that you pay for your mobile phone
provider how would you rate the quality of the products and services offered
by your &quot;mobile phone provider&quot;?
</p>
</li></ul>
</dd>
<dt>SAT</dt><dd><p>Customer Satisfaction (eta_5) </p>

<ul>
<li><p> (a) Overall satisfaction,
</p>
</li>
<li><p> (b) Fulfillment of expectations,
</p>
</li>
<li><p> (c) How well do you think your &quot;mobile phone provider&quot; compares
with your ideal &quot;mobile phone provider&quot;?
</p>
</li></ul>
</dd>
<dt>LOY</dt><dd><p>Customer Loyalty (eta_6) </p>

<ul>
<li><p> (a) If you would need to choose a new &quot;mobile phone provider&quot; how
likely is it that you would choose your provider again?
</p>
</li>
<li><p> (b) Let us now suppose that other &quot;mobile phone provider&quot;s decide
to lower their fees and prices, but your &quot;mobile phone provider&quot; stays at
the same level as today. At which level of difference (in %) would you
choose another &quot;mobile phone provider&quot;?
</p>
</li>
<li><p> (c) If a friend or colleague asks you for advice, how likely is it
that you would recommend your &quot;mobile phone provider&quot;?
</p>
</li></ul>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>data(ECSI)
</code></pre>


<h3>Format</h3>

<p>A data frame with 250 rows and 24 variables
</p>


<h3>References</h3>

<p>Fornell C. (1992): A national customer satisfaction barometer.
The Swedish experience. Journal of Marketing, (56), 6-21.
</p>

<hr>
<h2 id='plot.rgcca'>Plot a fitted object from the RGCCA package</h2><span id='topic+plot.rgcca'></span><span id='topic+plot.rgcca_cv'></span><span id='topic+plot.rgcca_permutation'></span><span id='topic+plot.rgcca_bootstrap'></span><span id='topic+plot.rgcca_stability'></span>

<h3>Description</h3>

<p>'plot.rgcca()' plots a fitted RGCCA object.
</p>
<p>'plot.rgcca_cv()' plots a fitted rgcca_cv object. Boxplots of the
cross-validated scores for the different parameter sets are displayed.
</p>
<p>'plot.rgcca_permutation()' plots a fitted rgcca_permutation object.
Permutation statistics are displayed for each set of parameters.
</p>
<p>'plot.rgcca_bootstrap()' plots a fitted rgcca_bootstrap object.
Each block variable is shown along with its associated bootstrap
confidence interval and stars reflecting the p-value of assigning
a strictly positive or negative weight to this block variable.
</p>
<p>'plot.rgcca_stability()' calls 'plot.rgcca()' on the fitted RGCCA model
returned by 'rgcca_stability()'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rgcca'
plot(
  x,
  type = "weights",
  block = seq_along(x$call$blocks),
  comp = c(1, 2),
  response = as.factor(rep(1, NROW(x$Y[[1]]))),
  display_order = TRUE,
  title = NULL,
  cex = 1,
  cex_sub = 12 * cex,
  cex_main = 14 * cex,
  cex_lab = 12 * cex,
  cex_point = 3 * cex,
  n_mark = 30,
  sample_colors = NULL,
  sample_shapes = NULL,
  var_colors = NULL,
  var_shapes = NULL,
  AVE_colors = NULL,
  show_sample_names = TRUE,
  show_var_names = TRUE,
  repel = FALSE,
  display_blocks = seq_along(x$call$blocks),
  expand = 1,
  show_arrows = TRUE,
  ...
)

## S3 method for class 'rgcca_cv'
plot(
  x,
  type = c("sd", "quantile"),
  cex = 1,
  cex_main = 14 * cex,
  cex_sub = 12 * cex,
  cex_point = 3 * cex,
  cex_lab = 12 * cex,
  display_order = TRUE,
  ...
)

## S3 method for class 'rgcca_permutation'
plot(
  x,
  type = c("crit", "zstat"),
  cex = 1,
  title = NULL,
  cex_main = 14 * cex,
  cex_sub = 12 * cex,
  cex_point = 3 * cex,
  cex_lab = 12 * cex,
  display_order = TRUE,
  show_legend = FALSE,
  ...
)

## S3 method for class 'rgcca_bootstrap'
plot(
  x,
  block = seq_along(x$rgcca$call$blocks),
  comp = 1,
  type = c("weights", "loadings"),
  empirical = TRUE,
  n_mark = 30,
  display_order = TRUE,
  show_stars = TRUE,
  title = NULL,
  cex = 1,
  cex_sub = 12 * cex,
  cex_main = 14 * cex,
  cex_lab = 12 * cex,
  cex_point = 3 * cex,
  colors = NULL,
  adj.method = "fdr",
  ...
)

## S3 method for class 'rgcca_stability'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.rgcca_+3A_x">x</code></td>
<td>
<p>An object to be plotted (output of functions <code><a href="#topic+rgcca">rgcca</a></code>,
<code><a href="#topic+rgcca_cv">rgcca_cv</a></code>, <code><a href="#topic+rgcca_permutation">rgcca_permutation</a></code>,
<code><a href="#topic+rgcca_bootstrap">rgcca_bootstrap</a></code>, or <code><a href="#topic+rgcca_stability">rgcca_stability</a></code>).</p>
</td></tr>
<tr><td><code id="plot.rgcca_+3A_type">type</code></td>
<td>
<p>A character string indicating the type of plot (see details).</p>
</td></tr>
<tr><td><code id="plot.rgcca_+3A_block">block</code></td>
<td>
<p>A numeric corresponding to the block(s) to plot.</p>
</td></tr>
<tr><td><code id="plot.rgcca_+3A_comp">comp</code></td>
<td>
<p>A numeric vector indicating the component(s) to consider.</p>
</td></tr>
<tr><td><code id="plot.rgcca_+3A_response">response</code></td>
<td>
<p>A vector coloring the points in the &quot;samples&quot; plot.</p>
</td></tr>
<tr><td><code id="plot.rgcca_+3A_display_order">display_order</code></td>
<td>
<p>A logical value for ordering the variables. If TRUE,
variables are ordered from highest to lowest absolute value. If FALSE,
the block order is used. Default is TRUE.</p>
</td></tr>
<tr><td><code id="plot.rgcca_+3A_title">title</code></td>
<td>
<p>A string specifying the title of the plot.</p>
</td></tr>
<tr><td><code id="plot.rgcca_+3A_cex">cex</code></td>
<td>
<p>A numeric defining the size of the objects in the plot. Default
is one.</p>
</td></tr>
<tr><td><code id="plot.rgcca_+3A_cex_sub">cex_sub</code></td>
<td>
<p>A numeric defining the font size of the subtitle. Default is
12 * cex.</p>
</td></tr>
<tr><td><code id="plot.rgcca_+3A_cex_main">cex_main</code></td>
<td>
<p>A numeric defining the font size of the title. Default is
14 * cex.</p>
</td></tr>
<tr><td><code id="plot.rgcca_+3A_cex_lab">cex_lab</code></td>
<td>
<p>A numeric defining the font size of the labels. Default is
12 * cex.</p>
</td></tr>
<tr><td><code id="plot.rgcca_+3A_cex_point">cex_point</code></td>
<td>
<p>A numeric defining the font size of the points. Default is
3 * cex.</p>
</td></tr>
<tr><td><code id="plot.rgcca_+3A_n_mark">n_mark</code></td>
<td>
<p>An integer defining the maximum number plotted objects
(see details).</p>
</td></tr>
<tr><td><code id="plot.rgcca_+3A_sample_colors">sample_colors</code></td>
<td>
<p>A string specifying the colors used to color samples
(used in the &quot;samples&quot; and &quot;biplot&quot; plots).</p>
</td></tr>
<tr><td><code id="plot.rgcca_+3A_sample_shapes">sample_shapes</code></td>
<td>
<p>Shapes used for the sample points (used in the &quot;samples&quot;
and &quot;biplot&quot; plots).</p>
</td></tr>
<tr><td><code id="plot.rgcca_+3A_var_colors">var_colors</code></td>
<td>
<p>Colors used to color variable weights or correlations
with canonical components (used in the &quot;weights&quot;, &quot;loadings&quot;, &quot;cor_circle&quot;
and &quot;biplot&quot; plots).</p>
</td></tr>
<tr><td><code id="plot.rgcca_+3A_var_shapes">var_shapes</code></td>
<td>
<p>Shapes used for the points associated to variable weights
or correlations with canonical components (used in the &quot;cor_circle&quot; and
&quot;biplot&quot; plots).</p>
</td></tr>
<tr><td><code id="plot.rgcca_+3A_ave_colors">AVE_colors</code></td>
<td>
<p>Colors used in the AVE plot.</p>
</td></tr>
<tr><td><code id="plot.rgcca_+3A_show_sample_names">show_sample_names</code></td>
<td>
<p>A logical value for showing the sample names in
plots &quot;samples&quot; and &quot;biplot&quot;.</p>
</td></tr>
<tr><td><code id="plot.rgcca_+3A_show_var_names">show_var_names</code></td>
<td>
<p>A logical value for showing the variable names in
plots &quot;cor_circle&quot; and &quot;biplot&quot;.</p>
</td></tr>
<tr><td><code id="plot.rgcca_+3A_repel">repel</code></td>
<td>
<p>A logical value for repelling text labels from each other.
Default to FALSE.</p>
</td></tr>
<tr><td><code id="plot.rgcca_+3A_display_blocks">display_blocks</code></td>
<td>
<p>A numeric corresponding to the block(s) to display in
the correlation_circle. All blocks are displayed by default.</p>
</td></tr>
<tr><td><code id="plot.rgcca_+3A_expand">expand</code></td>
<td>
<p>A numeric that scales the weights associated to the block
variables in the biplot. Default is 1.</p>
</td></tr>
<tr><td><code id="plot.rgcca_+3A_show_arrows">show_arrows</code></td>
<td>
<p>A logical, if TRUE, arrows are shown in the biplot.
Default is FALSE.</p>
</td></tr>
<tr><td><code id="plot.rgcca_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters.</p>
</td></tr>
<tr><td><code id="plot.rgcca_+3A_show_legend">show_legend</code></td>
<td>
<p>A logical value indicating if legend should
be shown (default is FALSE).</p>
</td></tr>
<tr><td><code id="plot.rgcca_+3A_empirical">empirical</code></td>
<td>
<p>A logical value indicating if the bootstrap confidence
intervals and p-values are derived from the empirical distribution.
(default: TRUE)</p>
</td></tr>
<tr><td><code id="plot.rgcca_+3A_show_stars">show_stars</code></td>
<td>
<p>A logical value indicating if the significance levels
are displayed.</p>
</td></tr>
<tr><td><code id="plot.rgcca_+3A_colors">colors</code></td>
<td>
<p>Colors used in the plots.</p>
</td></tr>
<tr><td><code id="plot.rgcca_+3A_adj.method">adj.method</code></td>
<td>
<p>A string indicating the method used to adjust the p-values.
It must be a method handled by the p.adjust function. Default is &quot;fdr&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument type can take 7 values in 'plot.rgcca':
</p>

<ul>
<li><p> &quot;weights&quot; (default): barplot of the block weight vectors for one
specific block/component. Sorting is applied according to the
display_order argument. The number of displayed weights can be set with
n_marks.
</p>
</li>
<li><p> &quot;loadings&quot;: barplot of the block-loading vectors. Sorting is applied
according to the display_order argument. The number of displayed loadings
can be set with n_marks.
</p>
</li>
<li><p> &quot;samples&quot;: scatter plot of the block components. The blocks used
are defined by the block argument, and the components by the comp argument
(Y[[block[1]]][, comp[1]], Y[[block[2]]][,comp[2]]). Points can
be colored according to the response argument.
</p>
</li>
<li><p>  &quot;cor_circle&quot; for correlation circle. It represents the correlation
between the block component corresponding to the first element of the block
argument, and the variables of the block corresponding to the blocks
specified by the argument display_blocks.
</p>
</li>
<li><p> &quot;both&quot;: displays both sample plot and correlation circle (implemented
only for one block and at least when two components are extracted
(ncomp &gt;= 2).
</p>
</li>
<li><p> &quot;biplot&quot;: displays on the same plot the scatter plot of the block
components and the variables used to compute these block components.
</p>
</li>
<li><p> &quot;ave&quot;: displays the average variance explained for each block.</p>
</li></ul>

<p>Argument type can take 2 values in 'plot.rgcca_cv': </p>

<ul>
<li><p> &quot;sd&quot; (default): the middle bar of the boxplots corresponds to the
mean and their limits are given by the mean plus or minus the
standard deviation.
</p>
</li>
<li><p> &quot;quantile&quot;: the middle bar corresponds to the median and limits of
the boxes are given by the 25% and 75% quantiles.
</p>
</li></ul>

<p>Argument type can take 2 values in 'plot.rgcca_permutation': </p>

<ul>
<li><p> &quot;crit&quot; (default): both the RGCCA criterion on the permuted and not
permuted datasets are displayed for each set of parameters.
</p>
</li>
<li><p> &quot;zstat&quot;: the Z-score is displayed for each set of parameters.
</p>
</li></ul>

<p>Argument type can take 2 values in 'plot.rgcca_bootstrap': </p>

<ul>
<li><p> &quot;weights&quot; (default): statistics about the block-weight
vectors are displayed.
</p>
</li>
<li><p> &quot;loadings&quot;: statistics about the block-loading vectors are displayed.
</p>
</li></ul>



<h3>Value</h3>

<p>A ggplot2 plot object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Plotting of an rgcca object
data("Russett")
blocks &lt;- list(
  agriculture = Russett[, seq(3)],
  industry = Russett[, 4:5],
  politic = as.factor(apply(Russett[, 9:11], 1, which.max))
)
blocks2 &lt;- list(
  agriculture = Russett[, seq(3)],
  industry = Russett[, 4:5],
  politic = Russett[, 6:11]
)
status &lt;- colnames(Russett)[9:11][apply(Russett[, 9:11], 1, which.max)]
fit_rgcca &lt;- rgcca(blocks = blocks, response = 3, ncomp = 2)

plot(fit_rgcca, type = "sample", block = 1:2, comp = 1)
plot(fit_rgcca, type = "loadings")
plot(fit_rgcca, type = "weight")
plot(fit_rgcca, type = "sample")
plot(fit_rgcca, type = "cor_circle")
plot(fit_rgcca, type = "both")
plot(fit_rgcca, type = "biplot")
plot(fit_rgcca, type = "ave")

## Not run: 
# With a superblock
fit_mcoa &lt;- rgcca(blocks = blocks2, method = "mcoa", ncomp = 2)

plot(fit_mcoa, type = "both", response = status)
plot(fit_mcoa, type = "biplot", response = status)

## Plotting of an rgcca_cv object
cv_out &lt;- rgcca_cv(blocks,
  response = 3, method = "rgcca",
  par_type = "tau",
  par_value = 1,
  n_run = 1, n_cores = 1,
  prediction_model = "lda",
  metric = "Accuracy",
  verbose = TRUE
)

plot(cv_out, type = "sd")
plot(cv_out, type = "quantile")

## Ploting of an rgcca_permutation object
perm_out &lt;- rgcca_permutation(blocks2, par_type = "tau",
                              n_perms = 2, n_cores = 1)

plot(perm_out, type = "crit")
plot(perm_out, type = "zstat")

## Plotting of an rgcca_bootstrap object
boot_out &lt;- rgcca_bootstrap(fit_rgcca, n_boot = 20, n_cores = 1)
plot(boot_out, type = "weights", block = 1, comp = 1)
plot(boot_out, type = "loadings", comp = 2,
     display_order = FALSE, show_stars = FALSE)

## Plotting of an rgcca_stability object
fit.sgcca &lt;- rgcca(blocks2, sparsity = c(.8, .9, .6))
res &lt;- rgcca_stability(
  fit.sgcca, n_boot = 10, verbose = TRUE, keep = rep(.1, 3)
)

plot(res, type = "samples")

## End(Not run)

</code></pre>

<hr>
<h2 id='print.rgcca'>Print a fitted object from the RGCCA package</h2><span id='topic+print.rgcca'></span><span id='topic+print.rgcca_cv'></span><span id='topic+print.rgcca_permutation'></span><span id='topic+print.rgcca_bootstrap'></span><span id='topic+print.rgcca_stability'></span>

<h3>Description</h3>

<p>'print.rgcca()' prints a fitted RGCCA object. The method and number of
components are displayed.
</p>
<p>'print.rgcca_cv()' prints a rgcca_cv object. The type of validation,
the number of tried parameter sets, the type of task, and the model used
are displayed.
</p>
<p>'print.rgcca_permutation()' prints a rgcca_permutation object.
The number of permutations and tried parameter sets are displayed.
</p>
<p>'print.rgcca_bootstrap()' prints a rgcca_bootstrap object.
The number of boostrap samples used for fitting is displayed.
</p>
<p>'print.rgcca_stability()' prints a rgcca_stability object.
The number of boostrap samples used for fitting is displayed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rgcca'
print(x, ...)

## S3 method for class 'rgcca_cv'
print(x, ...)

## S3 method for class 'rgcca_permutation'
print(x, ...)

## S3 method for class 'rgcca_bootstrap'
print(x, ...)

## S3 method for class 'rgcca_stability'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.rgcca_+3A_x">x</code></td>
<td>
<p>An object to be printed
(output of functions <code><a href="#topic+rgcca">rgcca</a></code>,
<code><a href="#topic+rgcca_cv">rgcca_cv</a></code>, <code><a href="#topic+rgcca_permutation">rgcca_permutation</a></code>,
<code><a href="#topic+rgcca_bootstrap">rgcca_bootstrap</a></code>, or <code><a href="#topic+rgcca_stability">rgcca_stability</a></code>).</p>
</td></tr>
<tr><td><code id="print.rgcca_+3A_...">...</code></td>
<td>
<p>Further arguments passed to other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>none
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Printing of an rgcca object
data(Russett)
blocks &lt;- list(
  agriculture = Russett[, seq(3)],
  industry = Russett[, 4:5],
  politic = Russett[, 6:8]
)
C &lt;- matrix(c(0, 0, 1, 0, 0, 1, 1, 1, 0), 3, 3)
res &lt;- rgcca(blocks,
  connection = C, ncomp = rep(2, 3), tau = c(1, 1, 1),
  scheme = "factorial", scale = TRUE, verbose = FALSE
)
print(res)

## Printing of an rgcca_cv object
res &lt;- rgcca_cv(blocks,
  response = 3, method = "rgcca", par_type = "tau",
  par_value = c(0, 0.2, 0.3), n_run = 1, n_cores = 1,
  verbose = TRUE
)
print(res)

## Printing of an rgcca_permutation object
perm.out &lt;- rgcca_permutation(blocks,
  par_type = "tau",
  n_perms = 5, n_cores = 1,
  verbose = TRUE
)
print(perm.out)

## Printing of an rgcca_bootstrap object
fit.rgcca &lt;- rgcca(blocks, ncomp = c(2, 1, 2))
boot.out &lt;- rgcca_bootstrap(fit.rgcca, n_boot = 20, n_cores = 2,
                            verbose = TRUE)
print(boot.out)

## Printing of an rgcca_stability object
fit.sgcca &lt;- rgcca(blocks, sparsity = c(.8, .9, .6))
res &lt;- rgcca_stability(fit.sgcca, n_boot = 10, verbose = TRUE)
print(res)
</code></pre>

<hr>
<h2 id='rgcca'>Regularized Generalized Canonical Correlation Analysis (RGCCA)</h2><span id='topic+rgcca'></span>

<h3>Description</h3>

<p>RGCCA is a general statistical framework for multiblock data analysis.
The rgcca() function implements this framework and is the main entry point
of the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgcca(
  blocks,
  connection = NULL,
  tau = 1,
  ncomp = 1,
  scheme = "factorial",
  scale = TRUE,
  init = "svd",
  bias = TRUE,
  tol = 1e-08,
  verbose = FALSE,
  scale_block = "inertia",
  method = "rgcca",
  sparsity = 1,
  response = NULL,
  superblock = FALSE,
  NA_method = "na.ignore",
  quiet = TRUE,
  n_iter_max = 1000,
  comp_orth = TRUE,
  A = NULL,
  C = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rgcca_+3A_blocks">blocks</code></td>
<td>
<p>A list that contains the <code class="reqn">J</code> blocks of variables
<code class="reqn">\mathbf{X_1}, \mathbf{X_2}, ..., \mathbf{X_J}</code>.
Block <code class="reqn">\mathbf{X}_j</code> is a matrix of dimension
<code class="reqn">n \times p_j</code> where <code class="reqn">n</code> is the number of
observations and <code class="reqn">p_j</code> the number of variables. The blocks argument can
be also a fitted cval, rgcca or permutation object.</p>
</td></tr>
<tr><td><code id="rgcca_+3A_connection">connection</code></td>
<td>
<p>A (<code class="reqn">J \times J</code>) symmetric matrix describing
the network of connections between blocks (default value: 1-diag(J)).</p>
</td></tr>
<tr><td><code id="rgcca_+3A_tau">tau</code></td>
<td>
<p>Either a numerical value, a numeric vector of size
<code class="reqn">J</code>, or a
numeric matrix of dimension
<code class="reqn">\mathrm{max}(\textrm{ncomp}) \times J</code>
containing the values of the regularization parameters
(default: tau = 1, for each
block and each dimension), or a string equal to &quot;optimal&quot;.
The regularization parameters varies from 0 (maximizing the correlation) to
1 (maximizing the covariance).
</p>
<p>If tau is a numerical
value, tau is identical across all constraints applied to all
block weight vectors.
</p>
<p>If tau is a vector, tau[j] is used for the constraints applied to
all the block weight vectors associated to block <code class="reqn">\mathbf X_j</code>.
</p>
<p>If tau is a matrix, tau[k, j] is associated with the constraints
applied to the kth block weight vector corresponding to block
<code class="reqn">\mathbf X_j</code>.
</p>
<p>If tau = &quot;optimal&quot; the regularization
parameters are estimated for each block and each dimension using the Schafer
and Strimmer (2005) analytical formula. The tau parameters can also be
estimated using
<a href="#topic+rgcca_permutation">rgcca_permutation</a> or <a href="#topic+rgcca_cv">rgcca_cv</a>.</p>
</td></tr>
<tr><td><code id="rgcca_+3A_ncomp">ncomp</code></td>
<td>
<p>A numerical value or a vector of length <code class="reqn">J</code> indicating
the number of components per block. If a single value is provided,
the same number of components is extracted for every block.</p>
</td></tr>
<tr><td><code id="rgcca_+3A_scheme">scheme</code></td>
<td>
<p>A string or a function specifying the scheme function applied
to
covariance maximization among &quot;horst&quot; (the identity function), &quot;factorial&quot;
(the square function - default value), &quot;centroid&quot; (the absolute value
function). The scheme function can be any continuously differentiable convex
function and it is possible to design explicitly the scheme function
(e.g. function(x) x^4) as argument of the function.  See (Tenenhaus et al,
2017) for details.</p>
</td></tr>
<tr><td><code id="rgcca_+3A_scale">scale</code></td>
<td>
<p>A logical value indicating if variables are standardized.</p>
</td></tr>
<tr><td><code id="rgcca_+3A_init">init</code></td>
<td>
<p>A string giving the type of initialization to use in
the RGCCA algorithm. It could be either by
Singular Value Decompostion (&quot;svd&quot;)
or by random initialization (&quot;random&quot;) (default: &quot;svd&quot;).</p>
</td></tr>
<tr><td><code id="rgcca_+3A_bias">bias</code></td>
<td>
<p>A logical value for biased (<code class="reqn">1/n</code>) or unbiased
(<code class="reqn">1/(n-1)</code>) estimator of the variance/covariance
(default: bias = TRUE).</p>
</td></tr>
<tr><td><code id="rgcca_+3A_tol">tol</code></td>
<td>
<p>The stopping value for the convergence of the algorithm
(default: tol = 1e-08).</p>
</td></tr>
<tr><td><code id="rgcca_+3A_verbose">verbose</code></td>
<td>
<p>A logical value indicating if the progress of the
algorithm is reported while computing.</p>
</td></tr>
<tr><td><code id="rgcca_+3A_scale_block">scale_block</code></td>
<td>
<p>A logical value or a string indicating if each block is
scaled.
</p>
<p>If TRUE or &quot;inertia&quot;, each block is divided by the sum of eigenvalues
of its empirical covariance matrix.
</p>
<p>If &quot;lambda1&quot;, each block is divided by
the square root of the highest eigenvalue of its empirical covariance matrix.
</p>
<p>If standardization is applied (scale = TRUE), the block scaling applies on
the standardized blocks.</p>
</td></tr>
<tr><td><code id="rgcca_+3A_method">method</code></td>
<td>
<p>A string specifying which multiblock component
method to consider. Possible values are found using
<a href="#topic+available_methods">available_methods</a>.</p>
</td></tr>
<tr><td><code id="rgcca_+3A_sparsity">sparsity</code></td>
<td>
<p>Either a numerical value, a numeric vector of
size <code class="reqn">J</code> or a numeric matrix
of dimension <code class="reqn">\textrm{max}(\textrm{ncomp}) \times J</code> encoding the L1
constraints applied to the
block weight vectors. For block <code class="reqn">j</code>, the amount of
sparsity varies between
<code class="reqn">1/\textrm{sqrt}(p_j)</code> and 1 (larger values of sparsity
correspond to less penalization).
</p>
<p>If sparsity is a numerical value, then sparsity is identical across
all constraints applied to all block weight vectors.
</p>
<p>If sparsity is a vector, sparsity[j] is identical across the constraints
applied to the block weight vectors associated to block
<code class="reqn">\mathbf X_j</code>:
</p>
<p style="text-align: center;"><code class="reqn">
   \forall k, \Vert a_{j,k} \Vert_{1} \le \textrm{sparsity}[j] \sqrt{p_j}.
</code>
</p>

<p>If sparsity is a matrix, sparsity[k, j] is associated with the constraints
applied to the kth block weight vector corresponding to block
<code class="reqn">\mathbf X_j</code>:
</p>
<p style="text-align: center;"><code class="reqn">
   \Vert a_{j,k}\Vert_{1} \le \textrm{sparsity}[k,j] \sqrt{p_j}.
</code>
</p>

<p>The sparsity parameter can be estimated by using <a href="#topic+rgcca_permutation">rgcca_permutation</a> or
<a href="#topic+rgcca_cv">rgcca_cv</a>.</p>
</td></tr>
<tr><td><code id="rgcca_+3A_response">response</code></td>
<td>
<p>A numerical value giving the position of the response block.
When the response argument is filled, the supervised mode is automatically
activated.</p>
</td></tr>
<tr><td><code id="rgcca_+3A_superblock">superblock</code></td>
<td>
<p>A logical value indicating if the
superblock option is used.</p>
</td></tr>
<tr><td><code id="rgcca_+3A_na_method">NA_method</code></td>
<td>
<p>A string indicating the method used for
handling missing values (&quot;na.ignore&quot;, &quot;na.omit&quot;). (default: &quot;na.ignore&quot;).
</p>

<ul>
<li><p> &quot;na.omit&quot; corresponds to perform RGCCA on the fully observed
observations (observations from which missing values have been removed).
</p>
</li>
<li><p> &quot;na.ignore&quot; corresponds to perform RGCCA algorithm on available
data (See Tenenhaus et al, 2005).</p>
</li></ul>
</td></tr>
<tr><td><code id="rgcca_+3A_quiet">quiet</code></td>
<td>
<p>A logical value indicating if some diagnostic messages
are reported.</p>
</td></tr>
<tr><td><code id="rgcca_+3A_n_iter_max">n_iter_max</code></td>
<td>
<p>Integer giving the algorithm's maximum number of
iterations.</p>
</td></tr>
<tr><td><code id="rgcca_+3A_comp_orth">comp_orth</code></td>
<td>
<p>A logical value indicating if the deflation should lead to
orthogonal block components or orthogonal block weight vectors.</p>
</td></tr>
<tr><td><code id="rgcca_+3A_a">A</code></td>
<td>
<p>Deprecated argument, please use blocks instead.</p>
</td></tr>
<tr><td><code id="rgcca_+3A_c">C</code></td>
<td>
<p>Deprecated argument, please use connection instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given <code class="reqn">J</code> data matrices
<code class="reqn">\mathbf X_1, \mathbf X_2, \dots, \mathbf X_J</code>
that represent <code class="reqn">J</code> sets of variables
observed on the same set of <code class="reqn">n</code> individuals. These matrices
<code class="reqn">\mathbf X_1, \mathbf X_2, \dots, \mathbf X_J</code>,
called blocks must have the same number of rows, but may (and usually will)
have different numbers of columns.
</p>
<p>RGCCA aims to study the relationships between these <code class="reqn">J</code> blocks.
It constitutes a general framework for many multi-block component methods
(see Tenenhaus and Tenenhaus, 2011 ; Tenenhaus et al. 2017). It combines the
power of multi-block data analysis  methods (maximization of well identified
criteria) and the flexibility of PLS path modeling (the researcher decides
which blocks are connected and which are not). Hence, the use of RGCCA
requires the construction (user specified) of a design matrix
<code class="reqn">\mathbf C</code> that
characterizes the connections between blocks. Elements of the (symmetric)
design matrix <code class="reqn">\mathbf C = (c_{jk})</code>
are positive (and usually equal to 1 if blocks <code class="reqn">j</code>
and <code class="reqn">k</code> are connected, and 0 otherwise).
The rgcca() function implements
a monotone global convergent algorithm: the bounded criteria to be
maximized increases at each step of the iterative procedure and hits, at
convergence, a stationary point of the RGCCA optimization problem.
</p>
<p>Moreover,
when the tau argument is used, depending on the dimensionality of each block
<code class="reqn">\mathbf X_j, j = 1, \ldots, J</code>,
the primal algorithm (when <code class="reqn">n \geq p_j</code>) or the dual algorithm
(when <code class="reqn">n &lt; p_j</code>) is used (see Tenenhaus et al. 2015).
</p>
<p>When sparsity is
specified SGCCA, extends RGCCA to address the issue of variable selection
(Tenenhaus et al, 2014). Specifically, RGCCA is combined with an L1-penalty
that gives rise to Sparse GCCA (SGCCA). The SGCCA algorithm is very similar
to the RGCCA algorithm and keeps the same convergence properties (i.e. the
bounded criteria to be maximized increases at each step of the iterative
procedure and hits at convergence a stationary point).
</p>
<p>At last, a deflation strategy can be used to compute several block
components
(specified by ncomp) per block. Within each block, components or weight
vectors are guaranteed to be orthogonal. It should be noted that the numbers
of components per block can differ from one block to another.
</p>
<p>The rgcca() function handle missing values (punctual or blockwise missing
structure) using the algorithm described in (Tenenhaus et al, 2005).
</p>
<p>Guidelines describing how to use RGCCA in practice are provided in
(Garali et al., 2018).
</p>


<h3>Value</h3>

<p>A fitted rgcca object.
</p>
<table role = "presentation">
<tr><td><code>Y</code></td>
<td>
<p>A list of <code class="reqn">J</code> elements. The jth element
of the list <code class="reqn">Y</code>
is a matrix that contains the block components for block j.</p>
</td></tr>
<tr><td><code>a</code></td>
<td>
<p>A list of <code class="reqn">J</code> elements. The jth element
of the list <code class="reqn">a</code>
is a matrix that contains the block weight vectors for block j.</p>
</td></tr>
<tr><td><code>astar</code></td>
<td>
<p>A list of <code class="reqn">J</code> elements. Each column of astar[[j]] is
a vector such that Y[[j]] = blocks[[j]] %*% astar[[j]].</p>
</td></tr>
<tr><td><code>crit</code></td>
<td>
<p>A list of vector of length max(ncomp). Each vector of
the list is related to one specific deflation stage and reports the values
of the criterion for this stage across iterations.</p>
</td></tr>
<tr><td><code>primal_dual</code></td>
<td>
<p>A vector of length J. Element <code class="reqn">j</code>
is either &quot;primal&quot; or &quot;dual&quot;, depending on whether the primal or dual
RGCCA algorithm was used for block <code class="reqn">j</code>.</p>
</td></tr>
<tr><td><code>AVE</code></td>
<td>
<p>A list of numerical values giving the indicators of model
quality based on the Average Variance Explained (AVE): AVE(for each block),
AVE(outer model), AVE(inner model).</p>
</td></tr>
<tr><td><code>optimal</code></td>
<td>
<p>A logical value indicating if the Schaffer and
Strimmer formula was applied for estimating the optimal tau parameters.</p>
</td></tr>
<tr><td><code>opt</code></td>
<td>
<p>A list containing some options of
the fitted RGCCA object.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>Call of the function.</p>
</td></tr>
<tr><td><code>blocks</code></td>
<td>
<p>A list that contains the <code class="reqn">J</code>
blocks of variables
<code class="reqn">\mathbf X_1, \mathbf X_2, \dots, \mathbf X_J</code>.
Block <code class="reqn">\mathbf X_j</code> is a matrix of dimension
<code class="reqn">n \times p_j</code> where <code class="reqn">p_j</code> is the number of
variables in <code class="reqn">\mathbf X_j</code>. These blocks are preprocessed
according to the values of
scale/scale_block/NA_method.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Garali I, Adanyeguh IM, Ichou F, Perlbarg V, Seyer A, Colsch B,
Moszer I, Guillemot V, Durr A, Mochel F, Tenenhaus A. (2018) A strategy for
multimodal data integration: application to biomarkers identification
in spinocerebellar ataxia. Briefings in Bioinformatics. 19(6):1356-1369.
</p>
<p>Tenenhaus M., Tenenhaus A. and Groenen P. J. (2017). Regularized
generalized canonical correlation analysis: a framework for sequential
multiblock component methods. Psychometrika, 82(3), 737-777.
</p>
<p>Tenenhaus A., Philippe C. and Frouin, V. (2015). Kernel
generalized canonical correlation analysis. Computational Statistics and
Data Analysis, 90, 114-131.
</p>
<p>Tenenhaus A., Philippe C., Guillemot V., Le Cao K. A., Grill J.
and Frouin, V. (2014), Variable selection for generalized canonical
correlation analysis, Biostatistics, 15(3), pp. 569-583.
</p>
<p>Tenenhaus A. and Tenenhaus M., (2011). Regularized Generalized
Canonical Correlation Analysis, Psychometrika, 76(2), pp 257-284.
</p>
<p>Tenenhaus, M., Vinzi, V. E., Chatelin, Y. M., &amp; Lauro, C. (2005).
PLS path modeling. Computational statistics &amp; data analysis, 48(1), 159-205.
</p>
<p>Schafer J. and Strimmer K. (2005). A shrinkage approach to
large-scale covariance matrix estimation and implications for functional
genomics. Statistical Applications in Genetics and Molecular Biology 4:32.
</p>
<p>Arnaud Gloaguen, Vincent Guillemot, Arthur Tenenhaus.
An efficient algorithm to satisfy l1 and l2 constraints.
49emes Journees de Statistique, May 2017, Avignon, France. (hal-01630744)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.rgcca">plot.rgcca</a></code>, <code><a href="#topic+summary.rgcca">summary.rgcca</a></code>,
<code><a href="#topic+rgcca_cv">rgcca_cv</a></code>,
<code><a href="#topic+rgcca_permutation">rgcca_permutation</a></code>
<code><a href="#topic+rgcca_predict">rgcca_predict</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>####################
# Example 1: RGCCA #
####################
# Create the dataset
data(Russett)
blocks &lt;- list(
  agriculture = Russett[, seq(3)],
  industry = Russett[, 4:5],
  politic = Russett[, 6:11]
)

politic &lt;- as.factor(apply(Russett[, 9:11], 1, which.max))

# RGCCA with default values : Blocks are fully connected, factorial scheme
# tau = 1 for all blocks, one component per block.
fit_rgcca &lt;- rgcca(blocks = blocks)

print(fit_rgcca)

plot(fit_rgcca, type = "weight", block = 1:3)

plot(fit_rgcca,
  type = "sample", block = 1:2,
  comp = rep(1, 2), resp = politic
)


############################################
# Example 2: RGCCA and multiple components #
############################################
#  By default rgcca() returns orthogonal block components.
fit_rgcca &lt;- rgcca(blocks,
  method = "rgcca",
  connection = 1 - diag(3),
  superblock = FALSE,
  tau = rep(1, 3),
  ncomp = c(2, 2, 2),
  scheme = "factorial",
  comp_orth = TRUE,
  verbose = TRUE
)

print(fit_rgcca)

plot(fit_rgcca,
  type = "sample", block = 1,
  comp = 1:2, resp = politic
)

plot(fit_rgcca, type = "weight",
     block = 1:3, display_order = FALSE)

##############################
# Example 3: MCOA with RGCCA #
##############################

fit_rgcca &lt;- rgcca(blocks, method = "mcoa", ncomp = 2)
print(fit_rgcca)

# biplot representation
plot(fit_rgcca, type = "biplot", block = 4, resp = politic)

## Not run: 
  ####################################
  # Example 4: RGCCA and permutation #
  ####################################

  # Tune the model to find the best set of tau parameters.
  # By default, blocks are fully connected.

  set.seed(27) #favorite number
  perm_out &lt;- rgcca_permutation(blocks,
    n_cores = 1,
    par_type = "tau",
    n_perms = 50
  )

  print(perm_out)
  plot(perm_out)

  # all the parameters were imported from a fitted permutation object
  fit_rgcca &lt;- rgcca(perm_out)
  print(fit_rgcca)


  #######################################
  # Example 5: RGCCA and dual algorithm #
  #######################################
  # Download the dataset's package at http://biodev.cea.fr/sgcca/ and install
  # it from the package archive file.
  # You can do it with the following R commands:
  if (!("gliomaData" %in% rownames(installed.packages()))) {
    destfile &lt;- tempfile()
    download.file(
      "http://biodev.cea.fr/sgcca/gliomaData_0.4.tar.gz", destfile
     )
    install.packages(destfile, repos = NULL, type = "source")
  }

  data("ge_cgh_locIGR", package = "gliomaData")

  blocks &lt;- ge_cgh_locIGR$multiblocks
  Loc &lt;- factor(ge_cgh_locIGR$y)
  levels(Loc) &lt;- colnames(ge_cgh_locIGR$multiblocks$y)
  blocks[[3]] &lt;- Loc
  sapply(blocks, NCOL)

  # rgcca algorithm using the dual formulation for X1 and X2
  # and the dual formulation for X3. X3 is the group coding matrix associated
  # with the qualitative variable Loc. This block is considered
  # as response block and specified using the argument response.

  fit_rgcca &lt;- rgcca(
    blocks = blocks,
    response = 3,
    method = "rgcca",
    tau = c(1, 1, 0),
    ncomp = 1,
    scheme = function(x) x^2, #factorial scheme,
    verbose = TRUE,
  )

  fit_rgcca$primal_dual
  print(fit_rgcca)

  ###########################################
  # Example 6: RGCCA and variable selection #
  ###########################################

  # Variable selection and RGCCA : the sgcca algorithm
  fit_sgcca &lt;- rgcca(
    blocks = blocks,
    method = "sgcca",
    response = 3,
    sparsity = c(.071, .2, 1), ncomp = 1,
    scheme = "factorial", verbose = TRUE,
  )

  print(fit_sgcca)


  ############################################
  #  Example 7: RGCCA, multiple components   #
  #  and different penalties per component   #
  ############################################

  # S/RGCCA algorithm with multiple components and different
  # penalties for each components (-&gt; sparsity is a matrix)

  fit_rgcca &lt;- rgcca(blocks, response = 3,
    tau = matrix(c(.5, .5, 0, 1, 1, 0), nrow = 2, byrow = TRUE),
    ncomp = c(2, 2, 1), scheme = "factorial")

  print(fit_rgcca)


  # the same applies for SGCCA
  fit_sgcca &lt;- rgcca(blocks, response = 3,
    sparsity = matrix(c(.071, 0.2,  1,
                        0.06, 0.15, 1), nrow = 2, byrow = TRUE),
    ncomp = c(2, 2, 1), scheme = "factorial")

  print(fit_sgcca)

  ##################################################
  # Example 8: Supervised mode en cross validation #
  ##################################################
  # Prediction of the location from GE and CGH

  # Tune sparsity values based on the cross-validated accuracy.
  set.seed(27) #favorite number
  cv_out &lt;- rgcca_cv(blocks, response = 3,
                     par_type = "sparsity",
                     par_length = 10,
                     ncomp = 1,
                     prediction_model = "lda",
                     metric = "Accuracy",
                     k = 3, n_run = 5,
                     n_cores = 2)
  print(cv_out)
  plot(cv_out, display_order = TRUE)

  # all the parameters were imported from the fitted cval object.
  fit_rgcca &lt;- rgcca(cv_out)
  print(fit_rgcca)

## End(Not run)

</code></pre>

<hr>
<h2 id='rgcca_bootstrap'>Bootstrap confidence intervals and p-values</h2><span id='topic+rgcca_bootstrap'></span>

<h3>Description</h3>

<p>Bootstrap confidence intervals and p-values for evaluating the
significance/stability of the block-weight vectors produced by S/RGCCA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgcca_bootstrap(
  rgcca_res,
  n_boot = 100,
  n_cores = 1,
  balanced = TRUE,
  keep_all_variables = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rgcca_bootstrap_+3A_rgcca_res">rgcca_res</code></td>
<td>
<p>A fitted RGCCA object (see  <code><a href="#topic+rgcca">rgcca</a></code>).</p>
</td></tr>
<tr><td><code id="rgcca_bootstrap_+3A_n_boot">n_boot</code></td>
<td>
<p>The number of bootstrap samples (default: 100).</p>
</td></tr>
<tr><td><code id="rgcca_bootstrap_+3A_n_cores">n_cores</code></td>
<td>
<p>The number of cores used for parallelization.</p>
</td></tr>
<tr><td><code id="rgcca_bootstrap_+3A_balanced">balanced</code></td>
<td>
<p>A logical value indicating if a balanced bootstrap procedure
is performed or not (default is TRUE).</p>
</td></tr>
<tr><td><code id="rgcca_bootstrap_+3A_keep_all_variables">keep_all_variables</code></td>
<td>
<p>A logical value indicating if all variables have
to be kept even when some of them have null variance for at least one
bootstrap sample (default is FALSE).</p>
</td></tr>
<tr><td><code id="rgcca_bootstrap_+3A_verbose">verbose</code></td>
<td>
<p>A logical value indicating if the progress of the bootstrap
procedure is reported.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A rgcca_bootstrap object that can be printed and plotted.
</p>
<table role = "presentation">
<tr><td><code>n_boot</code></td>
<td>
<p>The number of bootstrap samples, returned
for further use.</p>
</td></tr>
<tr><td><code>rgcca</code></td>
<td>
<p>The RGCCA object fitted on the original data.</p>
</td></tr>
<tr><td><code>bootstrap</code></td>
<td>
<p>A data.frame with the block weight vectors and
loadings computed on each bootstrap sample.</p>
</td></tr>
<tr><td><code>stats</code></td>
<td>
<p>A data.frame of statistics summarizing the bootstrap
data.frame.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+plot.rgcca_bootstrap">plot.rgcca_bootstrap</a></code>,
<code><a href="#topic+summary.rgcca_bootstrap">summary.rgcca_bootstrap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Bootstrap confidence intervals and p-values for RGCCA
data(Russett)
blocks &lt;- list(
  agriculture = Russett[, seq(3)],
  industry = Russett[, 4:5],
  politic = Russett[, 6:8]
)

fit_rgcca &lt;- rgcca(blocks, ncomp = 1)

boot_out &lt;- rgcca_bootstrap(fit_rgcca, n_boot = 20, n_cores = 1,
                            verbose = TRUE)

print(boot_out)
plot(boot_out, type = "weight", block = 1:3, comp = 1,
     display_order = FALSE)


## Not run: 

 # Download the dataset's package at http://biodev.cea.fr/sgcca/ and install
 # it from the package archive file.
 # You can do it with the following R commands:
 if (!("gliomaData" %in% rownames(installed.packages()))) {
   destfile &lt;- tempfile()
   download.file(
     "http://biodev.cea.fr/sgcca/gliomaData_0.4.tar.gz", destfile
   )
   install.packages(destfile, repos = NULL, type = "source")
 }

 data("ge_cgh_locIGR", package = "gliomaData")
 blocks &lt;- ge_cgh_locIGR$multiblocks
 Loc &lt;- factor(ge_cgh_locIGR$y)
 levels(Loc) &lt;- colnames(ge_cgh_locIGR$multiblocks$y)
 blocks [[3]] &lt;- Loc


 fit_sgcca &lt;- rgcca(blocks, response = 3,
    sparsity = c(.071, .2, 1), ncomp = 1,
   scheme = "factorial",
   verbose = TRUE
 )

 print(fit_sgcca)

 boot_out &lt;- rgcca_bootstrap(fit_sgcca, n_boot = 50, n_cores = 2)
 plot(boot_out, block = 1:2, type = "weight",
       comp = 1, n_mark = 300000,
       display_order = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='rgcca_cv'>Tune RGCCA parameters by cross-validation</h2><span id='topic+rgcca_cv'></span>

<h3>Description</h3>

<p>This function is used to select automatically &quot;sparsity&quot;, &quot;tau&quot; or &quot;ncomp&quot;
by cross-validation. This function only applies in a supervised setting,
and filling the response argument is therefore mandatory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgcca_cv(
  blocks,
  method = "rgcca",
  response = NULL,
  par_type = "tau",
  par_value = NULL,
  par_length = 10,
  validation = "kfold",
  prediction_model = "lm",
  metric = NULL,
  k = 5,
  n_run = 1,
  n_cores = 1,
  quiet = TRUE,
  superblock = FALSE,
  scale = TRUE,
  scale_block = TRUE,
  tol = 1e-08,
  scheme = "factorial",
  NA_method = "na.ignore",
  rgcca_res = NULL,
  tau = 1,
  ncomp = 1,
  sparsity = 1,
  init = "svd",
  bias = TRUE,
  verbose = TRUE,
  n_iter_max = 1000,
  comp_orth = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rgcca_cv_+3A_blocks">blocks</code></td>
<td>
<p>A list that contains the <code class="reqn">J</code> blocks of variables
<code class="reqn">\mathbf{X_1}, \mathbf{X_2}, ..., \mathbf{X_J}</code>.
Block <code class="reqn">\mathbf{X}_j</code> is a matrix of dimension
<code class="reqn">n \times p_j</code> where <code class="reqn">n</code> is the number of
observations and <code class="reqn">p_j</code> the number of variables. The blocks argument can
be also a fitted cval, rgcca or permutation object.</p>
</td></tr>
<tr><td><code id="rgcca_cv_+3A_method">method</code></td>
<td>
<p>A string specifying which multiblock component
method to consider. Possible values are found using
<a href="#topic+available_methods">available_methods</a>.</p>
</td></tr>
<tr><td><code id="rgcca_cv_+3A_response">response</code></td>
<td>
<p>A numerical value giving the position of the response block.
When the response argument is filled, the supervised mode is automatically
activated.</p>
</td></tr>
<tr><td><code id="rgcca_cv_+3A_par_type">par_type</code></td>
<td>
<p>A character giving the parameter to tune among &quot;sparsity&quot;,
&quot;tau&quot; or &quot;ncomp&quot;.</p>
</td></tr>
<tr><td><code id="rgcca_cv_+3A_par_value">par_value</code></td>
<td>
<p>The parameter values to be tested, either NULL,
a numerical vector of size <code class="reqn">J</code>, or a matrix of size
par_length <code class="reqn">\times J</code>.
</p>
<p>If par_value is NULL, up to par_length sets of parameters are generated
uniformly from
the minimum and maximum possible values of the parameter defined by par_type
for each block. Minimum possible values are 0 for tau,
<code class="reqn">1/\textrm{sqrt}(p_j)</code> for sparsity, and 1
for ncomp. Maximum possible values are 1 for tau and sparsity, and
<code class="reqn">p_j</code> for ncomp.
</p>
<p>If par_value is a vector, it overwrites the maximum values taken for the
range of generated parameters.
</p>
<p>If par_value is a matrix, par_value directly corresponds to the set of
tested parameters.</p>
</td></tr>
<tr><td><code id="rgcca_cv_+3A_par_length">par_length</code></td>
<td>
<p>An integer indicating the number of sets of candidate
parameters to be tested (if par_value is not a matrix).</p>
</td></tr>
<tr><td><code id="rgcca_cv_+3A_validation">validation</code></td>
<td>
<p>A string specifying the type of validation among &quot;loo&quot; and
&quot;kfold&quot;. For small datasets (e.g. &lt;30 samples), it is recommended to use a
loo (leave-one-out) procedure.</p>
</td></tr>
<tr><td><code id="rgcca_cv_+3A_prediction_model">prediction_model</code></td>
<td>
<p>A string giving the model used for prediction.
Please see caret::modelLookup() for a list of the available models.</p>
</td></tr>
<tr><td><code id="rgcca_cv_+3A_metric">metric</code></td>
<td>
<p>A string indicating the metric of interest.
It should be one of the following scores:
</p>
<p>For classification: &quot;Accuracy&quot;, &quot;Kappa&quot;, &quot;F1&quot;, &quot;Sensitivity&quot;, &quot;Specificity&quot;,
&quot;Pos_Pred_Value&quot;, &quot;Neg_Pred_Value&quot;, &quot;Precision&quot;, &quot;Recall&quot;, &quot;Detection_Rate&quot;,
&quot;Balanced_Accuracy&quot;.
</p>
<p>For regression: &quot;RMSE&quot;, &quot;MAE&quot;.</p>
</td></tr>
<tr><td><code id="rgcca_cv_+3A_k">k</code></td>
<td>
<p>An integer giving the number of folds (if validation = 'kfold').</p>
</td></tr>
<tr><td><code id="rgcca_cv_+3A_n_run">n_run</code></td>
<td>
<p>An integer giving the number of Monte-Carlo Cross-Validation
(MCCV) to be run (if validation = 'kfold').</p>
</td></tr>
<tr><td><code id="rgcca_cv_+3A_n_cores">n_cores</code></td>
<td>
<p>The number of cores used for parallelization.</p>
</td></tr>
<tr><td><code id="rgcca_cv_+3A_quiet">quiet</code></td>
<td>
<p>A logical value indicating if some diagnostic messages
are reported.</p>
</td></tr>
<tr><td><code id="rgcca_cv_+3A_superblock">superblock</code></td>
<td>
<p>A logical value indicating if the
superblock option is used.</p>
</td></tr>
<tr><td><code id="rgcca_cv_+3A_scale">scale</code></td>
<td>
<p>A logical value indicating if variables are standardized.</p>
</td></tr>
<tr><td><code id="rgcca_cv_+3A_scale_block">scale_block</code></td>
<td>
<p>A logical value or a string indicating if each block is
scaled.
</p>
<p>If TRUE or &quot;inertia&quot;, each block is divided by the sum of eigenvalues
of its empirical covariance matrix.
</p>
<p>If &quot;lambda1&quot;, each block is divided by
the square root of the highest eigenvalue of its empirical covariance matrix.
</p>
<p>If standardization is applied (scale = TRUE), the block scaling applies on
the standardized blocks.</p>
</td></tr>
<tr><td><code id="rgcca_cv_+3A_tol">tol</code></td>
<td>
<p>The stopping value for the convergence of the algorithm
(default: tol = 1e-08).</p>
</td></tr>
<tr><td><code id="rgcca_cv_+3A_scheme">scheme</code></td>
<td>
<p>A string or a function specifying the scheme function applied
to
covariance maximization among &quot;horst&quot; (the identity function), &quot;factorial&quot;
(the square function - default value), &quot;centroid&quot; (the absolute value
function). The scheme function can be any continuously differentiable convex
function and it is possible to design explicitly the scheme function
(e.g. function(x) x^4) as argument of the function.  See (Tenenhaus et al,
2017) for details.</p>
</td></tr>
<tr><td><code id="rgcca_cv_+3A_na_method">NA_method</code></td>
<td>
<p>A string indicating the method used for
handling missing values (&quot;na.ignore&quot;, &quot;na.omit&quot;). (default: &quot;na.ignore&quot;).
</p>

<ul>
<li><p> &quot;na.omit&quot; corresponds to perform RGCCA on the fully observed
observations (observations from which missing values have been removed).
</p>
</li>
<li><p> &quot;na.ignore&quot; corresponds to perform RGCCA algorithm on available
data (See Tenenhaus et al, 2005).</p>
</li></ul>
</td></tr>
<tr><td><code id="rgcca_cv_+3A_rgcca_res">rgcca_res</code></td>
<td>
<p>A fitted RGCCA object (see  <code><a href="#topic+rgcca">rgcca</a></code>).</p>
</td></tr>
<tr><td><code id="rgcca_cv_+3A_tau">tau</code></td>
<td>
<p>Either a numerical value, a numeric vector of size
<code class="reqn">J</code>, or a
numeric matrix of dimension
<code class="reqn">\mathrm{max}(\textrm{ncomp}) \times J</code>
containing the values of the regularization parameters
(default: tau = 1, for each
block and each dimension), or a string equal to &quot;optimal&quot;.
The regularization parameters varies from 0 (maximizing the correlation) to
1 (maximizing the covariance).
</p>
<p>If tau is a numerical
value, tau is identical across all constraints applied to all
block weight vectors.
</p>
<p>If tau is a vector, tau[j] is used for the constraints applied to
all the block weight vectors associated to block <code class="reqn">\mathbf X_j</code>.
</p>
<p>If tau is a matrix, tau[k, j] is associated with the constraints
applied to the kth block weight vector corresponding to block
<code class="reqn">\mathbf X_j</code>.
</p>
<p>If tau = &quot;optimal&quot; the regularization
parameters are estimated for each block and each dimension using the Schafer
and Strimmer (2005) analytical formula. The tau parameters can also be
estimated using
<a href="#topic+rgcca_permutation">rgcca_permutation</a> or <a href="#topic+rgcca_cv">rgcca_cv</a>.</p>
</td></tr>
<tr><td><code id="rgcca_cv_+3A_ncomp">ncomp</code></td>
<td>
<p>A numerical value or a vector of length <code class="reqn">J</code> indicating
the number of components per block. If a single value is provided,
the same number of components is extracted for every block.</p>
</td></tr>
<tr><td><code id="rgcca_cv_+3A_sparsity">sparsity</code></td>
<td>
<p>Either a numerical value, a numeric vector of
size <code class="reqn">J</code> or a numeric matrix
of dimension <code class="reqn">\textrm{max}(\textrm{ncomp}) \times J</code> encoding the L1
constraints applied to the
block weight vectors. For block <code class="reqn">j</code>, the amount of
sparsity varies between
<code class="reqn">1/\textrm{sqrt}(p_j)</code> and 1 (larger values of sparsity
correspond to less penalization).
</p>
<p>If sparsity is a numerical value, then sparsity is identical across
all constraints applied to all block weight vectors.
</p>
<p>If sparsity is a vector, sparsity[j] is identical across the constraints
applied to the block weight vectors associated to block
<code class="reqn">\mathbf X_j</code>:
</p>
<p style="text-align: center;"><code class="reqn">
   \forall k, \Vert a_{j,k} \Vert_{1} \le \textrm{sparsity}[j] \sqrt{p_j}.
</code>
</p>

<p>If sparsity is a matrix, sparsity[k, j] is associated with the constraints
applied to the kth block weight vector corresponding to block
<code class="reqn">\mathbf X_j</code>:
</p>
<p style="text-align: center;"><code class="reqn">
   \Vert a_{j,k}\Vert_{1} \le \textrm{sparsity}[k,j] \sqrt{p_j}.
</code>
</p>

<p>The sparsity parameter can be estimated by using <a href="#topic+rgcca_permutation">rgcca_permutation</a> or
<a href="#topic+rgcca_cv">rgcca_cv</a>.</p>
</td></tr>
<tr><td><code id="rgcca_cv_+3A_init">init</code></td>
<td>
<p>A string giving the type of initialization to use in
the RGCCA algorithm. It could be either by
Singular Value Decompostion (&quot;svd&quot;)
or by random initialization (&quot;random&quot;) (default: &quot;svd&quot;).</p>
</td></tr>
<tr><td><code id="rgcca_cv_+3A_bias">bias</code></td>
<td>
<p>A logical value for biased (<code class="reqn">1/n</code>) or unbiased
(<code class="reqn">1/(n-1)</code>) estimator of the variance/covariance
(default: bias = TRUE).</p>
</td></tr>
<tr><td><code id="rgcca_cv_+3A_verbose">verbose</code></td>
<td>
<p>A logical value indicating if the progress of the
algorithm is reported while computing.</p>
</td></tr>
<tr><td><code id="rgcca_cv_+3A_n_iter_max">n_iter_max</code></td>
<td>
<p>Integer giving the algorithm's maximum number of
iterations.</p>
</td></tr>
<tr><td><code id="rgcca_cv_+3A_comp_orth">comp_orth</code></td>
<td>
<p>A logical value indicating if the deflation should lead to
orthogonal block components or orthogonal block weight vectors.</p>
</td></tr>
<tr><td><code id="rgcca_cv_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to prediction_model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the response block is univariate. The RGCCA components of each block
are used as input variables of the predictive model (specified by
&quot;prediction_model&quot;) to predict the response block. The best combination of
parameters is the one with the best cross-validated score.
For multivariate response block, The RGCCA components of each block
are used as input variables of the predictive models (specified by
&quot;prediction_model&quot;) to predict each column of the response block.
The cross-validated scores of each model are then averaged. The best
combination of parameters is the one with the best averaged cross-validated
score.
</p>


<h3>Value</h3>

<p>A rgcca_cv object that can be printed and plotted.
</p>
<table role = "presentation">
<tr><td><code>k</code></td>
<td>
<p>An integer giving the number of folds.</p>
</td></tr>
<tr><td><code>n_run</code></td>
<td>
<p>An integer giving the number of MCCV.</p>
</td></tr>
<tr><td><code>opt</code></td>
<td>
<p>A list containing some options of the
RGCCA model.</p>
</td></tr>
<tr><td><code>metric</code></td>
<td>
<p>A string indicating the metric used during the process
of cross-validation.</p>
</td></tr>
<tr><td><code>cv</code></td>
<td>
<p>A matrix of dimension par_length x (k x n_run).
Each row of cv
corresponds to one set of candidate parameters. Each column of cv corresponds
to the cross-validated score of a specific fold in a specific run.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>A list of the input parameters of the RGCCA model.</p>
</td></tr>
<tr><td><code>par_type</code></td>
<td>
<p>The type of parameter tuned (either &quot;tau&quot;,
&quot;sparsity&quot;, or &quot;ncomp&quot;).</p>
</td></tr>
<tr><td><code>best_params</code></td>
<td>
<p>The set of parameters that yields the best
cross-validated scores.</p>
</td></tr>
<tr><td><code>params</code></td>
<td>
<p>A matrix reporting the sets of candidate parameters
used during the cross-validation process.</p>
</td></tr>
<tr><td><code>validation</code></td>
<td>
<p>A string specifying the type of validation
(either &quot;loo&quot; or &quot;kfold&quot;).</p>
</td></tr>
<tr><td><code>stats</code></td>
<td>
<p>A data.frame containing various statistics (mean, sd,
median, first quartile, third quartile) of the cross-validated score for
each set of parameters that has been tested.</p>
</td></tr>
<tr><td><code>classification</code></td>
<td>
<p>A boolean indicating if the model performs a
classification task.</p>
</td></tr>
<tr><td><code>prediction_model</code></td>
<td>
<p>A string giving the model used for
prediction.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Cross_validation for classification

set.seed(27) #favorite number
data(Russett)
blocks &lt;- list(
  agriculture = Russett[, 1:3],
  industry = Russett[, 4:5],
  politic = as.factor(apply(Russett[, 9:11], 1, which.max))
)

cv_out &lt;- rgcca_cv(blocks, response = 3, method = "rgcca",
                   par_type = "tau",
                   par_length = 5,
                   prediction_model = "lda", #caret::modelLookup()
                   metric = "Accuracy",
                   k=3, n_run = 3,
                   verbose = TRUE)


print(cv_out)
plot(cv_out)

# A fitted cval object is given as output of the rgcca() function

fit_opt = rgcca(cv_out)
## Not run: 
# Cross_validation for regression

set.seed(27) #favorite number
data(Russett)
blocks &lt;- list(
  agriculture = Russett[, 1:3],
  industry = Russett[, 4:5],
  politic =  Russett[, 6:8]
)

cv_out &lt;- rgcca_cv(blocks, response = 3, method = "rgcca",
                   par_type = "tau",
                   par_value = c(0.6, 0.75, 0.8),
                   prediction_model = "lm", #caret::modelLookup()
                   metric = "RMSE",
                   k=3, n_run = 5,
                   verbose = TRUE)

print(cv_out)
plot(cv_out)

fit_opt = rgcca(cv_out)


 data("ge_cgh_locIGR", package = "gliomaData")
 blocks &lt;- ge_cgh_locIGR$multiblocks
 Loc &lt;- factor(ge_cgh_locIGR$y)
 levels(Loc) &lt;- colnames(ge_cgh_locIGR$multiblocks$y)
 blocks[[3]] &lt;- Loc
 set.seed(27) # favorite number

  cv_out = rgcca_cv(blocks, response = 3,
                   ncomp = 1,
                   prediction_model = "glmnet",
                   family = "multinomial", lambda = .001,
                   par_type = "sparsity",
                   par_value = c(.071, .2, 1),
                   metric = "Balanced_Accuracy",
                   n_cores = 2,
 )

 print(cv_out)
 plot(cv_out, display_order = FALSE)

  cv_out = rgcca_cv(blocks, response = 3,
                   ncomp = 1,
                   prediction_model = "glmnet",
                   family = "multinomial", lambda = .001,
                   par_type = "ncomp",
                   par_value = c(5, 5, 1),
                   metric = "Balanced_Accuracy",
                   n_cores = 2,
 )

 print(cv_out)
 plot(cv_out, display_order = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='rgcca_permutation'>Tune the S/RGCCA hyper-parameters by permutation</h2><span id='topic+rgcca_permutation'></span>

<h3>Description</h3>

<p>This function can be used to automatically select the hyper-parameters
(amount of sparsity for sgcca or shrinkage parameters for RGCCA).
A permutation-based strategy very similar to the one proposed in
(Witten et al, 2009) is implemented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgcca_permutation(
  blocks,
  par_type = "tau",
  par_value = NULL,
  par_length = 10,
  n_perms = 20,
  n_cores = 1,
  quiet = TRUE,
  scale = TRUE,
  scale_block = TRUE,
  method = "rgcca",
  connection = NULL,
  scheme = "factorial",
  ncomp = 1,
  tau = 1,
  sparsity = 1,
  init = "svd",
  bias = TRUE,
  tol = 1e-08,
  response = NULL,
  superblock = FALSE,
  NA_method = "na.ignore",
  rgcca_res = NULL,
  verbose = TRUE,
  n_iter_max = 1000,
  comp_orth = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rgcca_permutation_+3A_blocks">blocks</code></td>
<td>
<p>A list that contains the <code class="reqn">J</code> blocks of variables
<code class="reqn">\mathbf{X_1}, \mathbf{X_2}, ..., \mathbf{X_J}</code>.
Block <code class="reqn">\mathbf{X}_j</code> is a matrix of dimension
<code class="reqn">n \times p_j</code> where <code class="reqn">n</code> is the number of
observations and <code class="reqn">p_j</code> the number of variables. The blocks argument can
be also a fitted cval, rgcca or permutation object.</p>
</td></tr>
<tr><td><code id="rgcca_permutation_+3A_par_type">par_type</code></td>
<td>
<p>A character giving the parameter to tune among &quot;sparsity&quot;,
&quot;tau&quot; or &quot;ncomp&quot;.</p>
</td></tr>
<tr><td><code id="rgcca_permutation_+3A_par_value">par_value</code></td>
<td>
<p>The parameter values to be tested, either NULL,
a numerical vector of size <code class="reqn">J</code>, or a matrix of size
par_length <code class="reqn">\times J</code>.
</p>
<p>If par_value is NULL, up to par_length sets of parameters are generated
uniformly from
the minimum and maximum possible values of the parameter defined by par_type
for each block. Minimum possible values are 0 for tau,
<code class="reqn">1/\textrm{sqrt}(p_j)</code> for sparsity, and 1
for ncomp. Maximum possible values are 1 for tau and sparsity, and
<code class="reqn">p_j</code> for ncomp.
</p>
<p>If par_value is a vector, it overwrites the maximum values taken for the
range of generated parameters.
</p>
<p>If par_value is a matrix, par_value directly corresponds to the set of
tested parameters.</p>
</td></tr>
<tr><td><code id="rgcca_permutation_+3A_par_length">par_length</code></td>
<td>
<p>An integer indicating the number of sets of candidate
parameters to be tested (if par_value is not a matrix).</p>
</td></tr>
<tr><td><code id="rgcca_permutation_+3A_n_perms">n_perms</code></td>
<td>
<p>The number of permutations for each set of parameters
(default is 20).</p>
</td></tr>
<tr><td><code id="rgcca_permutation_+3A_n_cores">n_cores</code></td>
<td>
<p>The number of cores used for parallelization.</p>
</td></tr>
<tr><td><code id="rgcca_permutation_+3A_quiet">quiet</code></td>
<td>
<p>A logical value indicating if some diagnostic messages
are reported.</p>
</td></tr>
<tr><td><code id="rgcca_permutation_+3A_scale">scale</code></td>
<td>
<p>A logical value indicating if variables are standardized.</p>
</td></tr>
<tr><td><code id="rgcca_permutation_+3A_scale_block">scale_block</code></td>
<td>
<p>A logical value or a string indicating if each block is
scaled.
</p>
<p>If TRUE or &quot;inertia&quot;, each block is divided by the sum of eigenvalues
of its empirical covariance matrix.
</p>
<p>If &quot;lambda1&quot;, each block is divided by
the square root of the highest eigenvalue of its empirical covariance matrix.
</p>
<p>If standardization is applied (scale = TRUE), the block scaling applies on
the standardized blocks.</p>
</td></tr>
<tr><td><code id="rgcca_permutation_+3A_method">method</code></td>
<td>
<p>A string specifying which multiblock component
method to consider. Possible values are found using
<a href="#topic+available_methods">available_methods</a>.</p>
</td></tr>
<tr><td><code id="rgcca_permutation_+3A_connection">connection</code></td>
<td>
<p>A (<code class="reqn">J \times J</code>) symmetric matrix describing
the network of connections between blocks (default value: 1-diag(J)).</p>
</td></tr>
<tr><td><code id="rgcca_permutation_+3A_scheme">scheme</code></td>
<td>
<p>A string or a function specifying the scheme function applied
to
covariance maximization among &quot;horst&quot; (the identity function), &quot;factorial&quot;
(the square function - default value), &quot;centroid&quot; (the absolute value
function). The scheme function can be any continuously differentiable convex
function and it is possible to design explicitly the scheme function
(e.g. function(x) x^4) as argument of the function.  See (Tenenhaus et al,
2017) for details.</p>
</td></tr>
<tr><td><code id="rgcca_permutation_+3A_ncomp">ncomp</code></td>
<td>
<p>A numerical value or a vector of length <code class="reqn">J</code> indicating
the number of components per block. If a single value is provided,
the same number of components is extracted for every block.</p>
</td></tr>
<tr><td><code id="rgcca_permutation_+3A_tau">tau</code></td>
<td>
<p>Either a numerical value, a numeric vector of size
<code class="reqn">J</code>, or a
numeric matrix of dimension
<code class="reqn">\mathrm{max}(\textrm{ncomp}) \times J</code>
containing the values of the regularization parameters
(default: tau = 1, for each
block and each dimension), or a string equal to &quot;optimal&quot;.
The regularization parameters varies from 0 (maximizing the correlation) to
1 (maximizing the covariance).
</p>
<p>If tau is a numerical
value, tau is identical across all constraints applied to all
block weight vectors.
</p>
<p>If tau is a vector, tau[j] is used for the constraints applied to
all the block weight vectors associated to block <code class="reqn">\mathbf X_j</code>.
</p>
<p>If tau is a matrix, tau[k, j] is associated with the constraints
applied to the kth block weight vector corresponding to block
<code class="reqn">\mathbf X_j</code>.
</p>
<p>If tau = &quot;optimal&quot; the regularization
parameters are estimated for each block and each dimension using the Schafer
and Strimmer (2005) analytical formula. The tau parameters can also be
estimated using
<a href="#topic+rgcca_permutation">rgcca_permutation</a> or <a href="#topic+rgcca_cv">rgcca_cv</a>.</p>
</td></tr>
<tr><td><code id="rgcca_permutation_+3A_sparsity">sparsity</code></td>
<td>
<p>Either a numerical value, a numeric vector of
size <code class="reqn">J</code> or a numeric matrix
of dimension <code class="reqn">\textrm{max}(\textrm{ncomp}) \times J</code> encoding the L1
constraints applied to the
block weight vectors. For block <code class="reqn">j</code>, the amount of
sparsity varies between
<code class="reqn">1/\textrm{sqrt}(p_j)</code> and 1 (larger values of sparsity
correspond to less penalization).
</p>
<p>If sparsity is a numerical value, then sparsity is identical across
all constraints applied to all block weight vectors.
</p>
<p>If sparsity is a vector, sparsity[j] is identical across the constraints
applied to the block weight vectors associated to block
<code class="reqn">\mathbf X_j</code>:
</p>
<p style="text-align: center;"><code class="reqn">
   \forall k, \Vert a_{j,k} \Vert_{1} \le \textrm{sparsity}[j] \sqrt{p_j}.
</code>
</p>

<p>If sparsity is a matrix, sparsity[k, j] is associated with the constraints
applied to the kth block weight vector corresponding to block
<code class="reqn">\mathbf X_j</code>:
</p>
<p style="text-align: center;"><code class="reqn">
   \Vert a_{j,k}\Vert_{1} \le \textrm{sparsity}[k,j] \sqrt{p_j}.
</code>
</p>

<p>The sparsity parameter can be estimated by using <a href="#topic+rgcca_permutation">rgcca_permutation</a> or
<a href="#topic+rgcca_cv">rgcca_cv</a>.</p>
</td></tr>
<tr><td><code id="rgcca_permutation_+3A_init">init</code></td>
<td>
<p>A string giving the type of initialization to use in
the RGCCA algorithm. It could be either by
Singular Value Decompostion (&quot;svd&quot;)
or by random initialization (&quot;random&quot;) (default: &quot;svd&quot;).</p>
</td></tr>
<tr><td><code id="rgcca_permutation_+3A_bias">bias</code></td>
<td>
<p>A logical value for biased (<code class="reqn">1/n</code>) or unbiased
(<code class="reqn">1/(n-1)</code>) estimator of the variance/covariance
(default: bias = TRUE).</p>
</td></tr>
<tr><td><code id="rgcca_permutation_+3A_tol">tol</code></td>
<td>
<p>The stopping value for the convergence of the algorithm
(default: tol = 1e-08).</p>
</td></tr>
<tr><td><code id="rgcca_permutation_+3A_response">response</code></td>
<td>
<p>A numerical value giving the position of the response block.
When the response argument is filled, the supervised mode is automatically
activated.</p>
</td></tr>
<tr><td><code id="rgcca_permutation_+3A_superblock">superblock</code></td>
<td>
<p>A logical value indicating if the
superblock option is used.</p>
</td></tr>
<tr><td><code id="rgcca_permutation_+3A_na_method">NA_method</code></td>
<td>
<p>A string indicating the method used for
handling missing values (&quot;na.ignore&quot;, &quot;na.omit&quot;). (default: &quot;na.ignore&quot;).
</p>

<ul>
<li><p> &quot;na.omit&quot; corresponds to perform RGCCA on the fully observed
observations (observations from which missing values have been removed).
</p>
</li>
<li><p> &quot;na.ignore&quot; corresponds to perform RGCCA algorithm on available
data (See Tenenhaus et al, 2005).</p>
</li></ul>
</td></tr>
<tr><td><code id="rgcca_permutation_+3A_rgcca_res">rgcca_res</code></td>
<td>
<p>A fitted RGCCA object (see  <code><a href="#topic+rgcca">rgcca</a></code>).</p>
</td></tr>
<tr><td><code id="rgcca_permutation_+3A_verbose">verbose</code></td>
<td>
<p>A logical value indicating if the progress of the
permutation procedure is reported.</p>
</td></tr>
<tr><td><code id="rgcca_permutation_+3A_n_iter_max">n_iter_max</code></td>
<td>
<p>Integer giving the algorithm's maximum number of
iterations.</p>
</td></tr>
<tr><td><code id="rgcca_permutation_+3A_comp_orth">comp_orth</code></td>
<td>
<p>A logical value indicating if the deflation should lead to
orthogonal block components or orthogonal block weight vectors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The tuning parameters are selected using the permutation scheme proposed in
(Witten et al, 2009). For each candidate tuning parameter value, the
following is performed:
</p>
<p>(1) Repeat the following n_perms times (for n_perms large): <br />
<code style="white-space: pre;">&#8288;    &#8288;</code>(a) Randomly permuted the rows of <code class="reqn">X_1</code>,..., <code class="reqn">X_J</code>
to create new blocks: <code class="reqn">X_1^*</code>,..., <code class="reqn">X_J^*</code>. <br />
<code style="white-space: pre;">&#8288;    &#8288;</code>(b) Run S/RGCCA on the permuted blocks <code class="reqn">X_1^*</code>,...,
<code class="reqn">X_J^*</code>.<br />
<code style="white-space: pre;">&#8288;    &#8288;</code>(c) Record the S/RGCCA criterion <code class="reqn">t^*</code>.
</p>
<p>(2) Run S/RGCCA on the original blocks <code class="reqn">X_1</code>,..., <code class="reqn">X_J</code>.
</p>
<p>(3) Record the S/RGCCA criterion <code class="reqn">t</code>.
</p>
<p>(4) The resulting p-value is given by <code class="reqn">\textrm{mean}(t^* &gt; t)</code>;
that is, the fraction of <code class="reqn">t^*</code> that exceeds the value of <code class="reqn">t</code>
obtained from the real data.
</p>
<p>(5) The resulting zstat is defined as
<code class="reqn">\frac{t-\textrm{mean}(t^*)}{\textrm{sd}(t^*)}</code>.
</p>
<p>Then, choose the tuning parameter values that gives the highest value in
Step 5.
</p>


<h3>Value</h3>

<p>A rgcca_permutation object that can be printed and plotted.
</p>
<table role = "presentation">
<tr><td><code>opt</code></td>
<td>
<p>A list indicating some options of the RGCCA model used
during the permutation.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>A list containing the input parameters of the
RGCCA model.</p>
</td></tr>
<tr><td><code>par_type</code></td>
<td>
<p>The type of parameter tuned (either &quot;tau&quot;,
&quot;sparsity&quot;, or &quot;ncomp&quot;).</p>
</td></tr>
<tr><td><code>n_perms</code></td>
<td>
<p>The number of permutations for each set of candidate
tuning parameters.</p>
</td></tr>
<tr><td><code>best_params</code></td>
<td>
<p>The set of tuning parameters that yields the
highest Z-statistic.</p>
</td></tr>
<tr><td><code>permcrit</code></td>
<td>
<p>A matrix of permuted S/RGCCA criteria. The ith row of
permcrit contains the n_perms values of S/RGCCA permuted criteria
obtained for the ith set of tuning parameters.</p>
</td></tr>
<tr><td><code>params</code></td>
<td>
<p>A matrix reporting the sets of candidate parameters
used during the permutation process.</p>
</td></tr>
<tr><td><code>stats</code></td>
<td>
<p>A data.frame containing in columns:
the sets of candidate
parameters, the corresponding non permuted criteria, means and standard
deviations of permuted criteria, Z-statistics and p-values.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Witten, D. M., Tibshirani, R., &amp; Hastie, T. (2009). A penalized
matrix decomposition, with applications to sparse principal components and
canonical correlation analysis. Biostatistics, 10(3), 515-534.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>####################################
# Permutation based strategy for   #
# determining the best shrinkage   #
# parameters (par_type = "tau")    #
####################################

data(Russett)
blocks &lt;- list(
  agriculture = Russett[, seq(3)],
  industry = Russett[, 4:5],
  politic = Russett[, 6:11]
)

C &lt;- matrix(c(
  0, 0, 1,
  0, 0, 1,
  1, 1, 0
), 3, 3)

# default value: 10 vectors from rep(0, length(blocks))
# to rep(1, length(blocks)), uniformly distributed.

fit &lt;- rgcca_permutation(blocks,
  connection = C,
  par_type = "tau",
  par_length = 10, n_perms = 2,
  n_cores = 1, verbose = TRUE
)

print(fit)
plot(fit)
fit$best_params

## Not run: 
 # It is possible to define explicitly K combinations of shrinkage
 # parameters to be tested and in that case a matrix of dimension KxJ is
 # required. Each row of this matrix corresponds to one specific set of
 # shrinkage parameters.
 par_value &lt;- matrix(c(
    0, 0, 0,
   1, 1, 0,
   0.5, 0.5, 0.5,
   sapply(blocks, RGCCA:::tau.estimate),
   1, 1, 1
 ), 5, 3, byrow = TRUE)


 perm.out &lt;- rgcca_permutation(blocks,
    connection = C,
   par_type = "tau",
   par_value = par_value,
   n_perms = 5, n_cores = 1
 )

 print(perm.out)
 plot(perm.out)

 # with superblock

 perm.out &lt;- rgcca_permutation(blocks,
    par_type = "tau",
   superblock = TRUE,
   scale = TRUE, scale_block = FALSE,
   n_perms = 5, n_cores = 1
 )

 print(perm.out)
 plot(perm.out)

 # used a fitted rgcca_permutation object as input of the rgcca function
 fit.rgcca &lt;- rgcca(perm.out)
 print(fit.rgcca)

 ######################################
 # Permutation based strategy for     #
 # determining the best sparsity      #
 # parameters (par_type = "sparsity") #
 ######################################

 # defaut value: 10 vectors from minimum values
 # (1/sqrt(ncol(X1)), ..., 1/sqrt(ncol(XJ))
 # to rep(1, J), uniformly distributed.

 perm.out &lt;- rgcca_permutation(blocks,
    par_type = "sparsity",
   n_perms = 50, n_cores = 1
 )

 print(perm.out)
 plot(perm.out)
 perm.out$best_params

 # when par_value is a vector of length J. Each element of the vector
 # indicates the maximum value of sparsity to be considered for each block.
 # par_length (default value = 10) vectors from minimum values
 # (1/sqrt(ncol(X1)), ..., 1/sqrt(ncol(XJ)) to maximum values, uniformly
 # distributed, are then considered.

 perm.out &lt;- rgcca_permutation(blocks,
    connection = C,
   par_type = "sparsity",
   par_value = c(0.6, 0.75, 0.5),
   par_length = 7, n_perms = 20,
   n_cores = 1, tol = 1e-3
 )

 print(perm.out)
 plot(perm.out)
 perm.out$best_params

 # when par_value is a scalar, the same maximum value is applied
 # for each block

 perm.out &lt;- rgcca_permutation(blocks,
    connection = C,
   par_type = "sparsity",
   par_value = 0.8, par_length = 5,
   n_perms = 10, n_cores = 1
)

 perm.out$params

######################################
# Speed up the permutation procedure #
######################################

 # The rgcca_permutation function can be quite time-consuming. Since
 # approximate estimates of the block weight vectors are acceptable in this
 # case, it is possible to reduce the value of the tolerance (tol argument)
 # of the RGCCA algorithm to speed up the permutation procedure.
 #
 data("ge_cgh_locIGR", package = "gliomaData")
 A &lt;- ge_cgh_locIGR$multiblocks
 Loc &lt;- factor(ge_cgh_locIGR$y)
 levels(Loc) &lt;- colnames(ge_cgh_locIGR$multiblocks$y)
 A[[3]] &lt;- A[[3]][, -3]
 C &lt;- matrix(c(0, 0, 1, 0, 0, 1, 1, 1, 0), 3, 3)

 # check dimensions of the blocks
 sapply(A, dim)

 par_value &lt;- matrix(c(
    seq(0.1, 1, by = 0.1),
   seq(0.1, 1, by = 0.1),
   rep(0, 10)
 ), 10, 3, byrow = FALSE)

 fit &lt;- rgcca_permutation(A,
    connection = C,
   par_type = "tau",
   par_value = par_value,
   par_length = 10,
   n_perms = 10, n_cores = 1, tol = 1e-2
 )
 print(fit)
 plot(fit)

## End(Not run)

</code></pre>

<hr>
<h2 id='rgcca_predict'>Make predictions using RGCCA</h2><span id='topic+rgcca_predict'></span>

<h3>Description</h3>

<p>This function aims to make predictions combining a fitted RGCCA object
and a prediction model for classification or regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgcca_predict(
  rgcca_res,
  blocks_test = rgcca_res$call$blocks,
  prediction_model = "lm",
  metric = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rgcca_predict_+3A_rgcca_res">rgcca_res</code></td>
<td>
<p>A fitted RGCCA object (see  <code><a href="#topic+rgcca">rgcca</a></code>).</p>
</td></tr>
<tr><td><code id="rgcca_predict_+3A_blocks_test">blocks_test</code></td>
<td>
<p>A list of test blocks from which we aim to predict the
associated response block. If the test response block is present among
blocks_test, metrics are computed by comparing the predictions and the
true values.</p>
</td></tr>
<tr><td><code id="rgcca_predict_+3A_prediction_model">prediction_model</code></td>
<td>
<p>A string giving the model used for prediction.
Please see caret::modelLookup() for a list of the available models.</p>
</td></tr>
<tr><td><code id="rgcca_predict_+3A_metric">metric</code></td>
<td>
<p>A string indicating the metric of interest.
It should be one of the following scores:
</p>
<p>For classification: &quot;Accuracy&quot;, &quot;Kappa&quot;, &quot;F1&quot;, &quot;Sensitivity&quot;, &quot;Specificity&quot;,
&quot;Pos_Pred_Value&quot;, &quot;Neg_Pred_Value&quot;, &quot;Precision&quot;, &quot;Recall&quot;, &quot;Detection_Rate&quot;,
&quot;Balanced_Accuracy&quot;.
</p>
<p>For regression: &quot;RMSE&quot;, &quot;MAE&quot;.</p>
</td></tr>
<tr><td><code id="rgcca_predict_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to prediction_model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements:
</p>
<table role = "presentation">
<tr><td><code>score</code></td>
<td>
<p>The score obtained on the testing block. NA if the test
block is missing.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>A list of the models trained using caret to make the
predictions and compute the scores.</p>
</td></tr>
<tr><td><code>metric</code></td>
<td>
<p>A list of data.frames containing the scores obtained
on the training and testing sets.</p>
</td></tr>
<tr><td><code>confusion</code></td>
<td>
<p>A list containing NA for regression tasks.
Otherwise, the confusion summary produced by caret for train and test.</p>
</td></tr>
<tr><td><code>projection</code></td>
<td>
<p>A list of matrices containing the projections
of the test blocks using the canonical components from the fitted RGCCA
object. The response block is not projected.</p>
</td></tr>
<tr><td><code>prediction</code></td>
<td>
<p>A list of data.frames with the predictions
of the test and train response blocks.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("Russett")
blocks &lt;- list(
  agriculture = Russett[, 1:3],
  industry = Russett[, 4:5],
  politic = Russett[, 6:8]
)
X_train &lt;- lapply(blocks, function(x) x[seq(1, 30), ])
X_test &lt;- lapply(blocks, function(x) x[seq(31, 47), ])
fit &lt;- rgcca(X_train,
  tau = 1, ncomp = c(3, 2, 3), response = 3
)
res &lt;- rgcca_predict(fit, X_test)
</code></pre>

<hr>
<h2 id='rgcca_stability'>Identify the most stable variables with SGCCA</h2><span id='topic+rgcca_stability'></span>

<h3>Description</h3>

<p>This function can be used to identify the most stable variables
identified as relevant by SGCCA. A Variable Importance in the Projection
(VIP) based criterion is used to identify the most stable variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgcca_stability(
  rgcca_res,
  keep = vapply(rgcca_res$a, function(x) mean(x != 0), FUN.VALUE = 1),
  n_boot = 100,
  n_cores = 1,
  verbose = TRUE,
  balanced = TRUE,
  keep_all_variables = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rgcca_stability_+3A_rgcca_res">rgcca_res</code></td>
<td>
<p>A fitted RGCCA object (see <code><a href="#topic+rgcca">rgcca</a></code>).</p>
</td></tr>
<tr><td><code id="rgcca_stability_+3A_keep">keep</code></td>
<td>
<p>A numeric vector indicating the proportion of variables per
block to select.</p>
</td></tr>
<tr><td><code id="rgcca_stability_+3A_n_boot">n_boot</code></td>
<td>
<p>The number of bootstrap samples (default: 100).</p>
</td></tr>
<tr><td><code id="rgcca_stability_+3A_n_cores">n_cores</code></td>
<td>
<p>The number of cores for parallelization.</p>
</td></tr>
<tr><td><code id="rgcca_stability_+3A_verbose">verbose</code></td>
<td>
<p>A logical value indicating if the progress of the procedure
is reported.</p>
</td></tr>
<tr><td><code id="rgcca_stability_+3A_balanced">balanced</code></td>
<td>
<p>A logical value indicating if a balanced bootstrap procedure
is performed or not (default is TRUE).</p>
</td></tr>
<tr><td><code id="rgcca_stability_+3A_keep_all_variables">keep_all_variables</code></td>
<td>
<p>A logical value indicating if all variables have
to be kept even when some of them have null variance for at least one
bootstrap sample (default is FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A rgcca_stability object that can be printed and plotted.
</p>
<table role = "presentation">
<tr><td><code>top</code></td>
<td>
<p>A data.frame giving the indicator (VIP)
on which the variables are ranked.</p>
</td></tr>
<tr><td><code>n_boot</code></td>
<td>
<p>The number of bootstrap samples, returned
for further use.</p>
</td></tr>
<tr><td><code>keepVar</code></td>
<td>
<p>The indices of the most stable variables.</p>
</td></tr>
<tr><td><code>bootstrap</code></td>
<td>
<p>A data.frame with the block weight vectors
computed on each bootstrap sample.</p>
</td></tr>
<tr><td><code>rgcca_res</code></td>
<td>
<p>An RGCCA object fitted on the most stable
variables.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
 ###########################
 # stability and bootstrap #
 ###########################

 data("ge_cgh_locIGR", package = "gliomaData")
 blocks &lt;- ge_cgh_locIGR$multiblocks
 Loc &lt;- factor(ge_cgh_locIGR$y)
 levels(Loc) &lt;- colnames(ge_cgh_locIGR$multiblocks$y)
 blocks[[3]] &lt;- Loc

 fit_sgcca &lt;- rgcca(blocks,
    sparsity = c(.071, .2, 1),
    ncomp = c(1, 1, 1),
    scheme = "centroid",
    verbose = TRUE, response = 3
)

 boot_out &lt;- rgcca_bootstrap(fit_sgcca, n_boot = 100, n_cores = 1)

 fit_stab &lt;- rgcca_stability(fit_sgcca,
   keep = sapply(fit_sgcca$a, function(x) mean(x != 0)),
   n_cores = 1, n_boot = 10,
   verbose = TRUE
 )

 boot_out &lt;- rgcca_bootstrap(
   fit_stab, n_boot = 500, n_cores = 1, verbose = TRUE
 )

 plot(boot_out, block = 1:2, n_mark = 2000, display_order = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='rgcca_transform'>Reduce dimensionality using RGCCA</h2><span id='topic+rgcca_transform'></span>

<h3>Description</h3>

<p>This function projects testing blocks using the block weight vectors of a
fitted RGCCA object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgcca_transform(rgcca_res, blocks_test = rgcca_res$call$blocks)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rgcca_transform_+3A_rgcca_res">rgcca_res</code></td>
<td>
<p>A fitted RGCCA object (see  <code><a href="#topic+rgcca">rgcca</a></code>).</p>
</td></tr>
<tr><td><code id="rgcca_transform_+3A_blocks_test">blocks_test</code></td>
<td>
<p>A list of blocks (data.frame or matrix) to be projected.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of matrices containing the projections of the test blocks
using the block weight vectors of a fitted RGCCA object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Russett")
blocks &lt;- list(
  agriculture = Russett[, 1:3],
  industry = Russett[, 4:5],
  politic = Russett[, 6:11])

Xtrain &lt;- lapply(blocks, function(x) x[1:32, ])
Xtest &lt;- lapply(blocks, function(x) x[33:47, ])
fit_rgcca &lt;- rgcca(Xtrain, ncomp = 2)
projection &lt;- rgcca_transform(fit_rgcca, Xtest)
</code></pre>

<hr>
<h2 id='Russett'>Russett data</h2><span id='topic+Russett'></span>

<h3>Description</h3>

<p>The Russett data set (Russett, 1964) is studied in Gifi (1990). Three
blocks of variables have been defined for 47 countries. The first block
is related to &quot;Agricultural Inequality&quot;, the second to
&quot;Industrial Development&quot;, and the last one describes the
&quot;Political Instability&quot;. Russett collected this data to study
relationships between Agricultural Inequality, Industrial Development and
Political Instability. Russett's hypotheses can be formulated as follows:
It is difficult for a country to escape dictatorship when its agricultural
inequality is above-average and its industrial development below-average.
</p>

<dl>
<dt>X1</dt><dd><p>Agricultural Inequality </p>

<ul>
<li><p> GINI: Inequality of land distribution,
</p>
</li>
<li><p> FARM: Percentage of farmers that own half of the land,
</p>
</li>
<li><p> RENT: Percentage of farmers that rent all their land.
</p>
</li></ul>
</dd>
<dt>X2</dt><dd><p>Industrial Development </p>

<ul>
<li><p> GNPR: Gross national product per capita ($1955),
</p>
</li>
<li><p> LABO: Percentage of labor forced employed in agriculture.
</p>
</li></ul>
</dd>
<dt>X3</dt><dd><p>Political Instability </p>

<ul>
<li><p> INST: Instability of executive (45-61),
</p>
</li>
<li><p> ECKS: Number of violent internal war incidents (46-61),
</p>
</li>
<li><p> DEAT: Number of people killed as a result of civic group
violence (50-62),
</p>
</li>
<li><p> DEMOSTAB: Stable democracy,
</p>
</li>
<li><p> DEMOINST: Unstable democracy,
</p>
</li>
<li><p> DICTATOR: Dictatorship.
</p>
</li></ul>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>data(Russett)
</code></pre>


<h3>Format</h3>

<p>A data frame with 47 rows and 12 variables.
</p>


<h3>References</h3>

<p>Russett B.M. (1964), Inequality and Instability: The Relation of
Land Tenure to Politics, World Politics 16:3, 442-454.
</p>
<p>Gifi, A. (1990), Nonlinear multivariate analysis,
Chichester: Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Loading of the Russett dataset
data(Russett)
#Russett is partitioned into three blocks (X_agric, X_ind, X_polit)
X_agric &lt;- Russett[, c("gini", "farm", "rent")]
X_ind &lt;- Russett[, c("gnpr", "labo")]
X_polit &lt;- Russett[, c("inst", "ecks", "death", "demostab",
                       "demoinst", "dictator")]
A &lt;- list(X_agric, X_ind, X_polit)
</code></pre>

<hr>
<h2 id='summary.rgcca'>Summary of a fitted object from the RGCCA package</h2><span id='topic+summary.rgcca'></span><span id='topic+summary.rgcca_cv'></span><span id='topic+summary.rgcca_permutation'></span><span id='topic+summary.rgcca_bootstrap'></span><span id='topic+summary.rgcca_stability'></span>

<h3>Description</h3>

<p>'summary.rgcca()' summarizes a fitted RGCCA object.
Some information about the
model are displayed like model parameters or criterion.
</p>
<p>'summary.rgcca_cv()' summarizes a fitted rgcca_cv object. Parameters of the
analysis, tuning parameters and statistics for each set of
parameters are displayed.
</p>
<p>'summary.rgcca_permutation()' summarizes a fitted rgcca_permutation object.
Parameters of the analysis, tuning parameters and statistics for each set of
parameters are displayed.
</p>
<p>'summary.rgcca_bootstrap()' summarizes a fitted rgcca_bootstrap object.
Parameters of the analysis and bootstrap statistics are displayed.
</p>
<p>'summary.rgcca_stability()' calls 'summary.rgcca()' on the fitted RGCCA model
returned by 'rgcca_stability()'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rgcca'
summary(object, ...)

## S3 method for class 'rgcca_cv'
summary(object, type = c("sd", "quantile"), ...)

## S3 method for class 'rgcca_permutation'
summary(object, ...)

## S3 method for class 'rgcca_bootstrap'
summary(
  object,
  block = seq_along(object$rgcca$call$blocks),
  comp = 1,
  type = c("weights", "loadings"),
  empirical = TRUE,
  display_order = FALSE,
  adj.method = "fdr",
  ...
)

## S3 method for class 'rgcca_stability'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.rgcca_+3A_object">object</code></td>
<td>
<p>An object to be summarized
(output of functions <code><a href="#topic+rgcca">rgcca</a></code>,
<code><a href="#topic+rgcca_cv">rgcca_cv</a></code>, <code><a href="#topic+rgcca_permutation">rgcca_permutation</a></code>,
<code><a href="#topic+rgcca_bootstrap">rgcca_bootstrap</a></code>, or <code><a href="#topic+rgcca_stability">rgcca_stability</a></code>).</p>
</td></tr>
<tr><td><code id="summary.rgcca_+3A_...">...</code></td>
<td>
<p>Further arguments passed to other methods
(for the displaying of matrices).</p>
</td></tr>
<tr><td><code id="summary.rgcca_+3A_type">type</code></td>
<td>
<p>A character string indicating the type of the summarized object
(see details).</p>
</td></tr>
<tr><td><code id="summary.rgcca_+3A_block">block</code></td>
<td>
<p>A numeric corresponding to the block(s) to summarize.</p>
</td></tr>
<tr><td><code id="summary.rgcca_+3A_comp">comp</code></td>
<td>
<p>A numeric vector indicating the component(s) to consider.</p>
</td></tr>
<tr><td><code id="summary.rgcca_+3A_empirical">empirical</code></td>
<td>
<p>A logical value indicating if the bootstrap confidence
intervals and p-values are derived from the empirical distribution.
(default: TRUE)</p>
</td></tr>
<tr><td><code id="summary.rgcca_+3A_display_order">display_order</code></td>
<td>
<p>A logical value for ordering the variables. If TRUE,
variables are ordered from highest to lowest absolute value. If FALSE,
the block order is used. Default is TRUE.</p>
</td></tr>
<tr><td><code id="summary.rgcca_+3A_adj.method">adj.method</code></td>
<td>
<p>A string indicating the method used to adjust the p-values.
It must be a method handled by the p.adjust function. Default is &quot;fdr&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument type can take two values in 'summary.cval': </p>

<ul>
<li><p> &quot;sd&quot; (default): mean values of the cross-validated scores are reported,
as well as means plus or minus standard deviations.
</p>
</li>
<li><p> &quot;quantiles&quot;: median values, 25% and 75% quantiles of the
cross-validated scores are reported.
</p>
</li></ul>

<p>Argument type can take two values in 'summary.bootstrap': </p>

<ul>
<li><p> &quot;weights&quot; (default): statistics about the block-weight vectors
are reported.
</p>
</li>
<li><p> &quot;loadings&quot;: statistics about the block-loading vectors are reported.
</p>
</li></ul>



<h3>Value</h3>

<p>none
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Summary of an rgcca object
data(Russett)
blocks &lt;- list(
  agriculture = Russett[, seq(3)],
  industry = Russett[, 4:5],
  politic = Russett[, 6:8]
)
C &lt;- matrix(c(0, 0, 1, 0, 0, 1, 1, 1, 0), 3, 3)
res &lt;- rgcca(blocks,
  connection = C, ncomp = rep(2, 3), tau = c(1, 1, 1),
  scheme = "factorial", scale = TRUE, verbose = FALSE
)
summary(res)

## Summary of an rgcca_cv object
res &lt;- rgcca_cv(blocks,
  response = 3, method = "rgcca", par_type = "tau",
  par_value = c(0, 0.2, 0.3), n_run = 1, n_cores = 1,
  verbose = TRUE
)
summary(res)

## Summary of an rgcca_permutation object
perm.out &lt;- rgcca_permutation(blocks,
  par_type = "tau",
  n_perms = 5, n_cores = 1,
  verbose = TRUE
)
summary(perm.out)

## Summary of an rgcca_bootstrap object
fit.rgcca &lt;- rgcca(blocks, ncomp = c(2, 1, 2))
boot.out &lt;- rgcca_bootstrap(fit.rgcca, n_boot = 20, n_cores = 2,
                            verbose = TRUE)
summary(boot.out)

## Summary of an rgcca_stability object
fit.sgcca &lt;- rgcca(blocks, sparsity = c(.8, .9, .6))
res &lt;- rgcca_stability(fit.sgcca, n_boot = 10, verbose = TRUE)
summary(res)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
