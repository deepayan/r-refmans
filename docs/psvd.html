<!DOCTYPE html><html lang="en"><head><title>Help for package psvd</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {psvd}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#psvd-package'><p>Eigendecomposition, Singular-Values and the Power Method</p></a></li>
<li><a href='#calcPCA'><p>Perform principal component analysis</p></a></li>
<li><a href='#calcSVD'><p>Perform singular values decomposition</p></a></li>
<li><a href='#eigenV'><p>Compute the eigenvectors matrix of a square symmetric matrix</p></a></li>
<li><a href='#eigenVc'><p>Compute the eigenvectors of a square symmetric matrix</p></a></li>
<li><a href='#mGS'><p>Modified Gram-Schmidt orthogonalization of a matrix</p></a></li>
<li><a href='#mGSc'><p>Modified Gram-Schmidt orthogonalization of a matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.1-0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-10-02</td>
</tr>
<tr>
<td>Title:</td>
<td>Eigendecomposition, Singular-Values and the Power Method</td>
</tr>
<tr>
<td>Author:</td>
<td>Doulaye Dembele <a href="https://orcid.org/0000-0003-3879-6940"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Doulaye Dembele &lt;doulaye@igbmc.fr&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0),</td>
</tr>
<tr>
<td>Description:</td>
<td>For a data matrix with m rows and n columns (m&gt;=n), the power
	     method is used to compute, simultaneously, the eigendecomposition
	     of a square symmetric matrix. This result is used to obtain the
	     singular value decomposition (SVD) and the principal component
             analysis (PCA) results. Compared to the classical SVD method,
	     the first r singular values can be computed. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-23 06:52:38 UTC; doulaye</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-25 08:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='psvd-package'>Eigendecomposition, Singular-Values and the Power Method</h2><span id='topic+psvd-package'></span>

<h3>Description</h3>

<p>The power method is used to compute simultaneously the
eigenvectors of a square symmetric matrix. Using the classical method,
all eigenvectors are computed. The method used here allows to compute the
first r eigenvectors using only matrix multiplications and the Gram-Schmidt
orthogonalization algorithm. The relationships between the eigendecomposition
factors, on the one hand, and the PCA factors or SVD factors, on the order
hand, are used to get SVD or PCA results).
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
     Package: </td><td style="text-align: left;"> psvd</td>
</tr>
<tr>
 <td style="text-align: left;">
     Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
     Version: </td><td style="text-align: left;"> 0.1-0</td>
</tr>
<tr>
 <td style="text-align: left;">
     Date: </td><td style="text-align: left;"> 2024-10-02</td>
</tr>
<tr>
 <td style="text-align: left;">
     License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>Package psvd has the following functions:
</p>

<table>
<tr>
 <td style="text-align: right;">
   calcSVD(): </td><td style="text-align: left;"> Given a data matrix X of size (m,n), m &gt;=n, this function
       allows to compute</td>
</tr>
<tr>
 <td style="text-align: right;"> </td><td style="text-align: left;"> the singular value decomposition. </td>
</tr>
<tr>
 <td style="text-align: right;">
   calcPCA(): </td><td style="text-align: left;"> Given a data matrix X of size (m,n), m &gt;=n, this function
       allows to\ compute</td>
</tr>
<tr>
 <td style="text-align: right;"> </td><td style="text-align: left;"> the principal component analysis.</td>
</tr>
<tr>
 <td style="text-align: right;">
   mGS(): </td><td style="text-align: left;"> Modified Gramf-Schmidt orthogonalization method, R code,
          internal use.</td>
</tr>
<tr>
 <td style="text-align: right;">
   mGSc(): </td><td style="text-align: left;"> Modified Gramf-Schmidt orthogonalization method, C code,
           internal use.</td>
</tr>
<tr>
 <td style="text-align: right;">
   eigenV(): </td><td style="text-align: left;"> Computation of the eigenvectors matrix for a symmetric
       square matrix using</td>
</tr>
<tr>
 <td style="text-align: right;"> </td><td style="text-align: left;"> the power method, R Code, internal use.</td>
</tr>
<tr>
 <td style="text-align: right;">
   eigenVc(): </td><td style="text-align: left;"> Computation of the eigenvectors matrix for a symmetric
       square matrix using</td>
</tr>
<tr>
 <td style="text-align: right;"> </td><td style="text-align: left;"> the power method, C Code, internal use.
  </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Doulaye Dembele: <a href="mailto:doulaye@igbmc.fr">doulaye@igbmc.fr</a></p>


<h3>References</h3>

<p>Dembele D. (2024), <em>Manuscript in preparation</em></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
X &lt;- as.matrix(iris[,1:4])
rownames(X) &lt;- iris[,5]
res &lt;- calcSVD(X, r=4)
res$d
res$v
res$iter
</code></pre>

<hr>
<h2 id='calcPCA'>Perform principal component analysis</h2><span id='topic+calcPCA'></span>

<h3>Description</h3>

<p>Given a data matrix, the function allows to perform principal
component analysis using a power method to get the eigendecomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  calcPCA(X, r, eta, itmax, err, normed, mySeed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calcPCA_+3A_x">X</code></td>
<td>
<p>Data matrix of size (m,n), m &gt;= n.</p>
</td></tr>
<tr><td><code id="calcPCA_+3A_r">r</code></td>
<td>
<p>Number of principal components, default: r=2.</p>
</td></tr>
<tr><td><code id="calcPCA_+3A_eta">eta</code></td>
<td>
<p>Power method tuning parameter, default: eta=10.</p>
</td></tr>
<tr><td><code id="calcPCA_+3A_itmax">itmax</code></td>
<td>
<p>Maximum number of iteration in the power method,
default: itmax=200.</p>
</td></tr>
<tr><td><code id="calcPCA_+3A_err">err</code></td>
<td>
<p>Tolerance level in the power method, default: err=1e-8.</p>
</td></tr>
<tr><td><code id="calcPCA_+3A_normed">normed</code></td>
<td>
<p>TRUE (default) or FALSE for PCA using standardized
data or not.</p>
</td></tr>
<tr><td><code id="calcPCA_+3A_myseed">mySeed</code></td>
<td>
<p>An integer allowing to reproduce results from
two different runs, default: mySeed=50.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>X is usually a data matrix .
</p>


<h3>Value</h3>

<p>This function returns a data frame containing 5 components
</p>
<table role = "presentation">
<tr><td><code>values</code></td>
<td>
<p>Eigenvalues</p>
</td></tr>
<tr><td><code>vectors</code></td>
<td>
<p>Matrix with the eigenvectors.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>The number of iterations used in the eigendecomposition.</p>
</td></tr>
<tr><td><code>li</code></td>
<td>
<p>Projection of rows in the r principal components space.</p>
</td></tr>
<tr><td><code>co</code></td>
<td>
<p>Projection of columns in the r principal components space.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
X &lt;- as.matrix(iris[,1:4])
rownames(X) &lt;- iris[,5]
res &lt;- calcPCA(X, r=3)
res$values
pcol &lt;- c(rep("cyan",50), rep("red",50), rep("blue",50))
plot(res$li[,1], res$li[,3], col = pcol)
</code></pre>

<hr>
<h2 id='calcSVD'>Perform singular values decomposition</h2><span id='topic+calcSVD'></span>

<h3>Description</h3>

<p>Given a data matrix, the function allows to perform a singular
decomposition using a power method and relationship between SVD factors
and the eigendecomposition factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  calcSVD(X, r, eta, itmax, err,mySeed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calcSVD_+3A_x">X</code></td>
<td>
<p>Data matrix of size (m,n), m &gt;= n.</p>
</td></tr>
<tr><td><code id="calcSVD_+3A_r">r</code></td>
<td>
<p>Rank r approximation, default: r=2.</p>
</td></tr>
<tr><td><code id="calcSVD_+3A_eta">eta</code></td>
<td>
<p>Power method tuning parameter, default: eta=10.</p>
</td></tr>
<tr><td><code id="calcSVD_+3A_itmax">itmax</code></td>
<td>
<p>Maximum number of iteration in the power method,
default: itmax=200.</p>
</td></tr>
<tr><td><code id="calcSVD_+3A_err">err</code></td>
<td>
<p>Tolerance level in the power method, default: err=1e-8.</p>
</td></tr>
<tr><td><code id="calcSVD_+3A_myseed">mySeed</code></td>
<td>
<p>An integer allowing to reproduce results from
two different runs, default: mySeed=50.</p>
</td></tr>
</table>


<h3>Details</h3>

<p> X is usually a data matrix.</p>


<h3>Value</h3>

<p>This function returns a data frame containing 4 components
</p>
<table role = "presentation">
<tr><td><code>d</code></td>
<td>
<p>Singular values.</p>
</td></tr>
<tr><td><code>u</code></td>
<td>
<p>Matrix with the right eigenvectors.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>Matrix with the right eigenvectors.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>The number of iterations used in the eigendecomposition.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
X &lt;- as.matrix(iris[,1:4])
rownames(X) &lt;- iris[,5]
res &lt;- calcSVD(X, r=3)
res$d
res$v
res$iter
</code></pre>

<hr>
<h2 id='eigenV'>Compute the eigenvectors matrix of a square symmetric matrix</h2><span id='topic+eigenV'></span>

<h3>Description</h3>

<p>This is an internal function which uses a R code to calculate an
eidendecomposition of a square symmetric matrix. This function is used in
the power method allowing to compute singular values and principal component 
analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  eigenV(xmat, wp, itmax, err)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eigenV_+3A_xmat">xmat</code></td>
<td>
<p>Square symmetric matrix of order d.</p>
</td></tr>
<tr><td><code id="eigenV_+3A_wp">wp</code></td>
<td>
<p>Columns orthogonal matrix of size (d,r), r &lt;= d.</p>
</td></tr>
<tr><td><code id="eigenV_+3A_itmax">itmax</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="eigenV_+3A_err">err</code></td>
<td>
<p>Tolerance level in the iterative search.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a data frame containing 2 components
</p>
<table role = "presentation">
<tr><td><code>wc</code></td>
<td>
<p>Eigenvectors matrix.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Number of iterations by the power method.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- 3
w &lt;- matrix(rnorm(d*d,0,1), ncol=d)
wp &lt;- mGS(w)
XtX &lt;- matrix(c(3,2,1,2,1,0,1,0,1), ncol=3)
res &lt;- eigenV(XtX, wp, itmax=100, err=1e-8)
t(res$wc) 
</code></pre>

<hr>
<h2 id='eigenVc'>Compute the eigenvectors of a square symmetric matrix</h2><span id='topic+eigenVc'></span>

<h3>Description</h3>

<p>This is an internal function which uses a C code to calculate an
eidendecomposition of a square symmetric matrix. This function is used in
the power method allowing to compute singular values and principal component 
analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  eigenVc(xmat, wp, d, r, itmax, err)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eigenVc_+3A_xmat">xmat</code></td>
<td>
<p>Square symmetric matrix of order d.</p>
</td></tr>
<tr><td><code id="eigenVc_+3A_wp">wp</code></td>
<td>
<p>Columns orthogonal matrix of size (d,r), r &lt;= d.</p>
</td></tr>
<tr><td><code id="eigenVc_+3A_d">d</code></td>
<td>
<p>Number of rows of wp.</p>
</td></tr>
<tr><td><code id="eigenVc_+3A_r">r</code></td>
<td>
<p>Number of columns of wp.</p>
</td></tr>
<tr><td><code id="eigenVc_+3A_itmax">itmax</code></td>
<td>
<p>Maximum number of iterations.</p>
</td></tr>
<tr><td><code id="eigenVc_+3A_err">err</code></td>
<td>
<p>Tolerance level in the iterative search.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a data frame containing 2 components
</p>
<table role = "presentation">
<tr><td><code>wc</code></td>
<td>
<p>Eigenvectors matrix.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Number of iterations by the power method.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- 3
r &lt;- 3
w &lt;- c(rnorm(d*r,0,1))
res &lt;- mGSc(w, d, r)
wp &lt;- res$wp
XtX &lt;- c(3,2,1,2,1,0,1,0,1)
res &lt;- eigenVc(XtX, wp, d, r, itmax=100, err=1e-8)
wc &lt;- matrix(res$wc, d, r)
t(wc) 
</code></pre>

<hr>
<h2 id='mGS'>Modified Gram-Schmidt orthogonalization of a matrix</h2><span id='topic+mGS'></span>

<h3>Description</h3>

<p>This is an internal function which uses a R code to calculate an
orthogonalization of a matrix. This function is used in the power method
allowing to compute an eigendecomposition of a symmetric square.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  mGS(A)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mGS_+3A_a">A</code></td>
<td>
<p>Matrix in vector form.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a matrix which columns are the eigenvectors
</p>
<table role = "presentation">
<tr><td><code>wp</code></td>
<td>
<p>Eigevectors matrix.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(rnorm(6,0,1), ncol=2)
res &lt;- mGS(A)
t(res) 
</code></pre>

<hr>
<h2 id='mGSc'>Modified Gram-Schmidt orthogonalization of a matrix</h2><span id='topic+mGSc'></span>

<h3>Description</h3>

<p>This is an internal function which uses a C code to calculate an
orthogonalization of a matrix. This function is used in the power method
allowing to compute an eigendecomposition of a symmetric square.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  mGSc(amat, m, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mGSc_+3A_amat">amat</code></td>
<td>
<p>Matrix in vector form.</p>
</td></tr>
<tr><td><code id="mGSc_+3A_m">m</code></td>
<td>
<p>Number of rows of the matrix amat.</p>
</td></tr>
<tr><td><code id="mGSc_+3A_n">n</code></td>
<td>
<p>Number of columns of the matrix amat.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns  a data frame containing 1 component
</p>
<table role = "presentation">
<tr><td><code>wp</code></td>
<td>
<p>Eigenvectors matrix.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- 3
r &lt;- 2
amat &lt;- c(rnorm(d*r,0,1))
res &lt;- mGSc(amat, d, r)
wp &lt;- matrix(res$wp, nrow=d, ncol=r)
t(wp) 
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
