<!DOCTYPE html><html lang="en"><head><title>Help for package remotePARTS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {remotePARTS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#remotePARTS-package'><p>remotePARTS: Spatiotemporal Autoregression Analyses for Large Data Sets</p></a></li>
<li><a href='#calc_dfpart'><p>calculate degrees of freedom for partitioned GLS</p></a></li>
<li><a href='#check_posdef'><p>Check if a matrix is positive definite</p></a></li>
<li><a href='#chisqr'><p>Conduct a chi-squared test</p></a></li>
<li><a href='#chisqr.partGLS'><p>Conduct a chisqr test of &quot;partGLS&quot; object</p></a></li>
<li><a href='#covar_taper'><p>Tapered-spherical distance-based covariance function</p></a></li>
<li><a href='#crosspart_GLS'><p>Calculate cross-partition statistics in a partitioned GLS</p></a></li>
<li><a href='#distm_km'><p>Calculate a distance matrix from coordinates</p></a></li>
<li><a href='#fitAR'><p>AR regressions by REML</p></a></li>
<li><a href='#fitAR_map'><p>Map-level AR REML</p></a></li>
<li><a href='#fitCLS'><p>CLS for time series</p></a></li>
<li><a href='#fitCLS_map'><p>Map-level CLS for time series</p></a></li>
<li><a href='#fitCor'><p>Estimate spatial parameters from time series residuals</p></a></li>
<li><a href='#fitGLS'><p>Fit a PARTS GLS model.</p></a></li>
<li><a href='#fitGLS_opt'><p>Fit a PARTS GLS model, with maximum likelihood spatial parameters</p></a></li>
<li><a href='#fitGLS_opt_FUN'><p>Function that fitGLS_opt optimizes over</p></a></li>
<li><a href='#invert_chol'><p>Invert the cholesky decomposition of V</p></a></li>
<li><a href='#max_dist'><p>calculate maximum distance among a table of coordinates</p></a></li>
<li><a href='#MC_GLSpart'><p>fit a parallel partitioned GLS</p></a></li>
<li><a href='#ndvi_AK10000'><p>NDVI remote sensing data for 10,000 random pixels from Alaska, with rare</p>
land classes removed.</a></li>
<li><a href='#optimize_nugget'><p>Find the maximum likelihood estimate of the nugget</p></a></li>
<li><a href='#part_chisqr'><p>Chisqr test for partitioned GLS</p></a></li>
<li><a href='#part_ttest'><p>Correlated t-test for paritioned GLS</p></a></li>
<li><a href='#partGLS_ndviAK'><p>partitioned GLS results</p></a></li>
<li><a href='#print.partGLS'><p>S3 print method for &quot;partGLS&quot; objects</p></a></li>
<li><a href='#print.remoteCor'><p>S3 print method for &quot;remoteCor&quot; class</p></a></li>
<li><a href='#print.remoteGLS'><p>print method for remoteGLS</p></a></li>
<li><a href='#print.remoteTS'><p>S3 print method for remoteTS class</p></a></li>
<li><a href='#remoteGLS'><p>remoteGLS constructor (S3)</p></a></li>
<li><a href='#sample_partitions'><p>Randomly sample a partition matrix for partitioned GLS</p></a></li>
<li><a href='#t.test.partGLS'><p>Conduct a t-test of &quot;partGLS&quot; object</p></a></li>
<li><a href='#test_covar_fun'><p>Test passing a covariance function and arguments</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Spatiotemporal Autoregression Analyses for Large Data Sets</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.4</td>
</tr>
<tr>
<td>Description:</td>
<td>
  These tools were created to test map-scale hypotheses about trends in large
  remotely sensed data sets but any data with spatial and temporal variation
  can be analyzed. Tests are conducted using the PARTS method for analyzing spatially
  autocorrelated time series
  (Ives et al., 2021: &lt;<a href="https://doi.org/10.1016%2Fj.rse.2021.112678">doi:10.1016/j.rse.2021.112678</a>&gt;).
  The method's unique approach can handle extremely large data sets that other
  spatiotemporal models cannot, while still appropriately accounting for
  spatial and temporal autocorrelation. This is done by partitioning the data
  into smaller chunks, analyzing chunks separately and then combining the
  separate analyses into a single, correlated test of the map-scale hypotheses.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/morrowcj/remotePARTS">https://github.com/morrowcj/remotePARTS</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/morrowcj/remotePARTS/issues">https://github.com/morrowcj/remotePARTS/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, geosphere (&ge; 1.5.10), Rcpp (&ge; 1.0.5), CompQuadForm,
foreach, parallel, iterators, doParallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>dplyr (&ge; 1.0.0), data.table, knitr, rmarkdown, markdown,
sqldf, devtools, ggplot2, reshape2, sf</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-15 15:59:14 UTC; morrowcj</td>
</tr>
<tr>
<td>Author:</td>
<td>Clay Morrow <a href="https://orcid.org/0000-0002-3069-3296"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Anthony Ives <a href="https://orcid.org/0000-0001-9375-9523"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Clay Morrow &lt;morrowcj@outlook.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-15 19:52:13 UTC</td>
</tr>
</table>
<hr>
<h2 id='remotePARTS-package'>remotePARTS: Spatiotemporal Autoregression Analyses for Large Data Sets</h2><span id='topic+remotePARTS'></span><span id='topic+remotePARTS-package'></span>

<h3>Description</h3>

<p>These tools were created to test map-scale hypotheses about trends in large remotely sensed data sets but any data with spatial and temporal variation can be analyzed. Tests are conducted using the PARTS method for analyzing spatially autocorrelated time series (Ives et al., 2021: <a href="https://doi.org/10.1016/j.rse.2021.112678">doi:10.1016/j.rse.2021.112678</a>). The method's unique approach can handle extremely large data sets that other spatiotemporal models cannot, while still appropriately accounting for spatial and temporal autocorrelation. This is done by partitioning the data into smaller chunks, analyzing chunks separately and then combining the separate analyses into a single, correlated test of the map-scale hypotheses.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Clay Morrow <a href="mailto:morrowcj@outlook.com">morrowcj@outlook.com</a> (<a href="https://orcid.org/0000-0002-3069-3296">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Anthony Ives <a href="mailto:arives@wisc.edu">arives@wisc.edu</a> (<a href="https://orcid.org/0000-0001-9375-9523">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/morrowcj/remotePARTS">https://github.com/morrowcj/remotePARTS</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/morrowcj/remotePARTS/issues">https://github.com/morrowcj/remotePARTS/issues</a>
</p>
</li></ul>


<hr>
<h2 id='calc_dfpart'>calculate degrees of freedom for partitioned GLS</h2><span id='topic+calc_dfpart'></span>

<h3>Description</h3>

<p>calculate degrees of freedom for partitioned GLS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_dfpart(partsize, p, p0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc_dfpart_+3A_partsize">partsize</code></td>
<td>
<p>number of pixels in each partition</p>
</td></tr>
<tr><td><code id="calc_dfpart_+3A_p">p</code></td>
<td>
<p>number of predictors in alternate model</p>
</td></tr>
<tr><td><code id="calc_dfpart_+3A_p0">p0</code></td>
<td>
<p>number of parameters in null model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named vector containing the first and second degrees of freedom (&quot;df1&quot; and &quot;df2&quot;, respectively)
</p>

<hr>
<h2 id='check_posdef'>Check if a matrix is positive definite</h2><span id='topic+check_posdef'></span>

<h3>Description</h3>

<p>Check if a matrix is positive definite
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_posdef(M)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_posdef_+3A_m">M</code></td>
<td>
<p>numeric matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>check if a matrix is 1) square, 2) symmetric, and 3) positive
definite
</p>


<h3>Value</h3>

<p>returns a named logical vector with the following elements:
</p>

<dl>
<dt>sqr</dt><dd><p>logical: indicating whether <code>M</code> is square</p>
</dd>
<dt>sym</dt><dd><p>logical: indicating whether <code>M</code> is symmetric</p>
</dd>
<dt>posdef</dt><dd><p>logical: indicating whether <code>M</code> is positive-definitive</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
# distance matrix
M = distm_scaled(expand.grid(x = 1:3, y = 1:3))

# check if it is positive definitive
check_posdef(M)

# check if the covariance matrix is positive definitive
check_posdef(covar_exp(M, .1))

# non-symmetric matrix
check_posdef(matrix(1:9, 3, 3))

# non-square matrix
check_posdef(matrix(1:6, 3, 2))

</code></pre>

<hr>
<h2 id='chisqr'>Conduct a chi-squared test</h2><span id='topic+chisqr'></span>

<h3>Description</h3>

<p>generic S3 method for a chi-squared test
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chisqr(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chisqr_+3A_x">x</code></td>
<td>
<p>object on which to conduct the test</p>
</td></tr>
<tr><td><code id="chisqr_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>results of the chi-squared test (generic)
</p>

<hr>
<h2 id='chisqr.partGLS'>Conduct a chisqr test of &quot;partGLS&quot; object</h2><span id='topic+chisqr.partGLS'></span>

<h3>Description</h3>

<p>Conduct a correlated chi-square test on a partitioned GLS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'partGLS'
chisqr(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chisqr.partGLS_+3A_x">x</code></td>
<td>
<p>&quot;remoteGLS&quot; object</p>
</td></tr>
<tr><td><code id="chisqr.partGLS_+3A_...">...</code></td>
<td>
<p>additional arguments passed to print</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a p-value for the correlated chisqr test
</p>

<hr>
<h2 id='covar_taper'>Tapered-spherical distance-based covariance function</h2><span id='topic+covar_taper'></span><span id='topic+covar_exp'></span><span id='topic+covar_exppow'></span>

<h3>Description</h3>

<p>Tapered-spherical distance-based covariance function
</p>
<p>Exponential distance-based covariance function
</p>
<p>Exponential-power distance-based covariance function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covar_taper(d, theta, cor = NULL)

covar_exp(d, range)

covar_exppow(d, range, shape)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="covar_taper_+3A_d">d</code></td>
<td>
<p>a numeric vector or matrix of distances</p>
</td></tr>
<tr><td><code id="covar_taper_+3A_theta">theta</code></td>
<td>
<p>distance beyond which covariances are forced to 0.</p>
</td></tr>
<tr><td><code id="covar_taper_+3A_cor">cor</code></td>
<td>
<p>optional correlation parameter. If included, the covariance is
subtracted from <code>cor</code>.</p>
</td></tr>
<tr><td><code id="covar_taper_+3A_range">range</code></td>
<td>
<p>range parameter</p>
</td></tr>
<tr><td><code id="covar_taper_+3A_shape">shape</code></td>
<td>
<p>shape parameter</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>covar_taper</code> calculates covariance v as follows:
</p>
<p>if <code>d &lt;= theta</code>, then <code>v = ((1 - (d/theta))^2) * (1 + (d/(2 * theta)))</code>
</p>
<p>if <code>d &gt; theta</code>, then <code>v = 0</code>
</p>
<p><code>covar_exp</code> calculates covariance v as follows:
</p>
<p><code>v = exp(-d/range)</code>
</p>
<p><code>covar_exppow</code> calculates covariance v as follows:
</p>
<p><code>v = exp(-(d/range)^2)</code>
</p>
<p>Note that <code>covar_exppow(..., shape = 1)</code> is equivalent to
<code>covar_exp()</code> but is needed as a separate function for use with <code>fitCor</code>.
</p>


<h3>Value</h3>

<p>a tapered-spherical transformation of d is returned.
</p>
<p>the exponential covariance (v)
</p>
<p>exponential-power covariance (v)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# simulate dummy data
map.width = 5 # square map width
coords = expand.grid(x = 1:map.width, y = 1:map.width) # coordinate matrix

# calculate distance
D = geosphere::distm(coords) # distance matrix

# visualize covariance matrix
image(covar_taper(D, theta = .5*max(D)))

# plot tapered covariance function
curve(covar_taper(x, theta = .5), from = 0, to = 1);abline(v = 0.5, lty = 2, col = "grey80")


# visualize covariance matrix
image(covar_exp(D, range = .2*max(D)))

# plot exponential function with different ranges
curve(covar_exp(x, range = .2), from = 0, to = 1)
curve(covar_exp(x, range = .1), from = 0, to = 1, col = "blue", add = TRUE)
legend("topright", legend = c("range = 0.2", "range = 0.1"), col = c("black", "blue"), lty = 1)


# visualize Exponential covariance matrix
image(covar_exppow(D, range = .2*max(D), shape = 1))

# visualize Exponential-power covariance matrix
image(covar_exppow(D, range = .2*max(D), shape = .5))

# plot exponential power function with different shapes
curve(covar_exppow(x, range = .2, shape = 1), from = 0, to = 1)
curve(covar_exppow(x, range = .2, shape = .5), from = 0, to = 1, col = "blue", add = TRUE)
legend("topright", legend = c("shape = 1.0", "shape = 0.5"), col = c("black", "blue"), lty = 1)

</code></pre>

<hr>
<h2 id='crosspart_GLS'>Calculate cross-partition statistics in a partitioned GLS</h2><span id='topic+crosspart_GLS'></span>

<h3>Description</h3>

<p>Calculate cross-partition statistics between two GLS partitions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crosspart_GLS(
  xxi,
  xxj,
  xxi0,
  xxj0,
  invChol_i,
  invChol_j,
  Vsub,
  nug_i,
  nug_j,
  df1,
  df2,
  small = TRUE,
  ncores = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crosspart_GLS_+3A_xxi">xxi</code></td>
<td>
<p>numeric matrix xx from  partition i</p>
</td></tr>
<tr><td><code id="crosspart_GLS_+3A_xxj">xxj</code></td>
<td>
<p>numeric matrix xx from  partition j</p>
</td></tr>
<tr><td><code id="crosspart_GLS_+3A_xxi0">xxi0</code></td>
<td>
<p>numeric matrix xx0 from  partition i</p>
</td></tr>
<tr><td><code id="crosspart_GLS_+3A_xxj0">xxj0</code></td>
<td>
<p>numeric matrix xx0 from  partition j</p>
</td></tr>
<tr><td><code id="crosspart_GLS_+3A_invchol_i">invChol_i</code></td>
<td>
<p>numeric matrix invcholV from  partition i</p>
</td></tr>
<tr><td><code id="crosspart_GLS_+3A_invchol_j">invChol_j</code></td>
<td>
<p>numeric matrix invcholV from  partition j</p>
</td></tr>
<tr><td><code id="crosspart_GLS_+3A_vsub">Vsub</code></td>
<td>
<p>numeric variance matrix for Xij (upper block)</p>
</td></tr>
<tr><td><code id="crosspart_GLS_+3A_nug_i">nug_i</code></td>
<td>
<p>nugget from partition i</p>
</td></tr>
<tr><td><code id="crosspart_GLS_+3A_nug_j">nug_j</code></td>
<td>
<p>nugget from partition j</p>
</td></tr>
<tr><td><code id="crosspart_GLS_+3A_df1">df1</code></td>
<td>
<p>first degree of freedom</p>
</td></tr>
<tr><td><code id="crosspart_GLS_+3A_df2">df2</code></td>
<td>
<p>second degree of freedom</p>
</td></tr>
<tr><td><code id="crosspart_GLS_+3A_small">small</code></td>
<td>
<p>logical: if <code>TRUE</code>, only return <code>rcoefij</code>, <code>rSSRij</code>,
and <code>rSSEij</code></p>
</td></tr>
<tr><td><code id="crosspart_GLS_+3A_ncores">ncores</code></td>
<td>
<p>an optional integer indicating how many CPU threads to use for
matrix calculations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>crosspart_GLS</code> returns a list of cross-partition statistics.
</p>
<p>If <code>small = FALSE</code>, the list contains the following elements
</p>

<dl>
<dt>Rij</dt><dd></dd>
<dt>Hi</dt><dd></dd>
<dt>Hj</dt><dd></dd>
<dt>Hi0</dt><dd></dd>
<dt>Hj0</dt><dd></dd>
<dt>SiR</dt><dd></dd>
<dt>SjR</dt><dd></dd>
<dt>rcoefij</dt><dd></dd>
<dt>rSSRij</dt><dd></dd>
<dt>rSSEij</dt><dd></dd>
<dt>Vcoefij</dt><dd></dd>
</dl>

<p>If <code>small = FALSE</code>, the list only contains the necessary elements
<code>rcoefij</code>, <code>rSSRij</code>, and <code>rSSEij</code>.
</p>


<h3>See Also</h3>

<p>Other partitionedGLS: 
<code><a href="#topic+MC_GLSpart">MC_GLSpart</a>()</code>,
<code><a href="#topic+sample_partitions">sample_partitions</a>()</code>
</p>

<hr>
<h2 id='distm_km'>Calculate a distance matrix from coordinates</h2><span id='topic+distm_km'></span><span id='topic+distm_scaled'></span>

<h3>Description</h3>

<p>Calculate the distances among points from a single coordinate matrix
or
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distm_km(coords, coords2 = NULL)

distm_scaled(coords, coords2 = NULL, distm_FUN = "distm_km")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distm_km_+3A_coords">coords</code></td>
<td>
<p>a coordinate matrix with 2 columns and rows corresponding to
each location.</p>
</td></tr>
<tr><td><code id="distm_km_+3A_coords2">coords2</code></td>
<td>
<p>an optional coordinate matrix</p>
</td></tr>
<tr><td><code id="distm_km_+3A_distm_fun">distm_FUN</code></td>
<td>
<p>function used to calculate the distance matrix. This function
dictates the units of &quot;max.dist&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>distm_km</code> is simply a wrapper for <code>geosphere::distm()</code>
</p>


<h3>Value</h3>

<p><code>distm_km</code> returns a distance matrix in km
</p>
<p>A distance matrix is returned.
</p>
<p>If <code>coords2 = NULL</code>, then distances among points in <code>coords</code> are
calculated. Otherwise, distances are calculated between points in <code>coords</code>
and <code>coords2</code>
</p>
<p><code>distm_km</code> returns a distance matrix in km and <code>distm_scaled</code> returns
relative distances (between 0 and 1). The resulting matrix has the attribute
&quot;max.dist&quot; which stores the maximum distance of the map. &quot;max.dist&quot; is in
km for <code>distm_km</code> and in the units of <code>distm_FUN</code> for <code>distm_scaled</code>.
</p>


<h3>See Also</h3>

<p><code>?geosphere::distm()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>map.width = 3 # square map width
coords = expand.grid(x = 1:map.width, y = 1:map.width) # coordinate matrix
distm_scaled(coords) # calculate relative distance matrix

</code></pre>

<hr>
<h2 id='fitAR'>AR regressions by REML</h2><span id='topic+fitAR'></span><span id='topic+AR_fun'></span>

<h3>Description</h3>

<p><code>fitAR</code> is used to fit AR(1) time series regression
analysis using restricted maximum likelihood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitAR(formula, data = NULL)

AR_fun(par, y, X, logLik.only = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitAR_+3A_formula">formula</code></td>
<td>
<p>a model formula, as used by <code>stats::lm()</code></p>
</td></tr>
<tr><td><code id="fitAR_+3A_data">data</code></td>
<td>
<p>optional data environment to search for variables in <code>formula</code>.
As used by <code>lm()</code></p>
</td></tr>
<tr><td><code id="fitAR_+3A_par">par</code></td>
<td>
<p>AR parameter value</p>
</td></tr>
<tr><td><code id="fitAR_+3A_y">y</code></td>
<td>
<p>vector of time series (response)</p>
</td></tr>
<tr><td><code id="fitAR_+3A_x">X</code></td>
<td>
<p>model matrix (predictors)</p>
</td></tr>
<tr><td><code id="fitAR_+3A_loglik.only">logLik.only</code></td>
<td>
<p>logical: should only the partial log-likelihood be computed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function finds the restricted maximum likelihood (REML) to estimate
parameters for the regression model with AR(1) random error terms
</p>
<p style="text-align: center;"><code class="reqn">y(t) =  X(t) \beta + \varepsilon(t)</code>
</p>

<p style="text-align: center;"><code class="reqn">\varepsilon(t) =  \rho \varepsilon(t-1) + \delta(t)</code>
</p>

<p>where <code class="reqn">y(t)</code> is the response at time <code class="reqn">t</code>;
</p>
<p><code class="reqn">X(t)</code> is a model matrix containing covariates;
</p>
<p><code class="reqn">\beta</code> is a vector of effects of <code class="reqn">X(t)</code>;
<code class="reqn">\varepsilon(t)</code> is the autocorrelated random error;
</p>
<p><code class="reqn">\delta \sim N(0, \sigma)</code> is a temporally independent
Gaussian random variable with mean zero and standard deviation
<code class="reqn">\sigma</code>;
</p>
<p>and <code class="reqn">\rho</code> is the AR(1) autoregression parameter
</p>
<p><code>fitAR</code> estimates the parameter via mathematical optimization
of the restricted log-likelihood function.
</p>
<p><code>AR_fun</code> is the work horse behind <code>fitAR</code> that is called
by <code>optim</code> to estimate the autoregression parameter <code class="reqn">\rho</code>.
</p>


<h3>Value</h3>

<p><code>fitAR</code> returns a list object of class &quot;remoteTS&quot;, which contains
the following elements.
</p>

<dl>
<dt>call</dt><dd><p>the function call</p>
</dd>
<dt>coefficients</dt><dd><p>a named vector of coefficients</p>
</dd>
<dt>SE</dt><dd><p>the standard errors of parameter estimates</p>
</dd>
<dt>tstat</dt><dd><p>the t-statistics for coefficients</p>
</dd>
<dt>pval</dt><dd><p>the p-values corresponding to t-tests of coefficients</p>
</dd>
<dt>MSE</dt><dd><p>the model mean squared error</p>
</dd>
<dt>logLik</dt><dd><p>the log-likelihood of the model fit</p>
</dd>
<dt>residuals</dt><dd><p>the residuals: response minus fitted values</p>
</dd>
<dt>fitted.values</dt><dd><p>the fitted mean values</p>
</dd>
<dt>rho</dt><dd><p>The AR parameter, determined via REML</p>
</dd>
<dt>rank</dt><dd><p>the numeric rank of the fitted model</p>
</dd>
<dt>df.residual</dt><dd><p>the residual degrees of freedom</p>
</dd>
<dt>terms</dt><dd><p>the <code>stats::terms</code> object used</p>
</dd>
</dl>

<p>Output is structured similarly to an &quot;lm&quot; object.
</p>
<p>When <code>logLik.only == F</code>, <code>AR_fun</code> returns the output described in
<code>?fitAR</code>. When <code>logLik.only == T</code>, it returns a quantity that is
linearly and negatively related to the restricted log likelihood
(i.e., partial log-likelihood).
</p>


<h3>References</h3>

<p>Ives, A. R., K. C. Abbott, and N. L. Ziebarth. 2010. Analysis of ecological
</p>
<p>time series with ARMA(p,q) models. Ecology 91:858-871.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitAR_map">fitAR_map</a></code> to easily apply <code>fit_AR</code> to many pixels;
<code><a href="#topic+fitCLS">fitCLS</a></code> and <code><a href="#topic+fitCLS_map">fitCLS_map</a></code> for conditional least squares
time series analyses.
</p>
<p>Other remoteTS: 
<code><a href="#topic+fitAR_map">fitAR_map</a>()</code>,
<code><a href="#topic+fitCLS_map">fitCLS_map</a>()</code>,
<code><a href="#topic+fitCLS">fitCLS</a>()</code>
</p>
<p>Other remoteTS: 
<code><a href="#topic+fitAR_map">fitAR_map</a>()</code>,
<code><a href="#topic+fitCLS_map">fitCLS_map</a>()</code>,
<code><a href="#topic+fitCLS">fitCLS</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# simulate dummy data
t = 1:30 # times series
Z = rnorm(30) # random independent variable
x = .2*Z + (.05*t) # generate dependent effects
x[2:30] = x[2:30] + .2*x[1:29] # add autocorrelation

# fit the AR model, using Z as a covariate
(AR = fitAR(x ~ Z))

# get specific components
AR$residuals
AR$coefficients
AR$pval

# now using time as a covariate
(AR.time &lt;- fitAR(x ~ t))

# source variable from a dataframe
df = data.frame(y = x, t.scaled = t/30, Z = Z)
fitAR(y ~ t.scaled + Z, data = df)

## Methods
summary(AR)
residuals(AR)
coefficients(AR)

</code></pre>

<hr>
<h2 id='fitAR_map'>Map-level AR REML</h2><span id='topic+fitAR_map'></span>

<h3>Description</h3>

<p><code>fitAR_map</code> is used to fit AR REML regression to each spatial
location (pixel) within spatiotemporal data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitAR_map(
  Y,
  coords,
  formula = "y ~ t",
  X.list = list(t = 1:ncol(Y)),
  resids.only = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitAR_map_+3A_y">Y</code></td>
<td>
<p>a spatiotemporal response variable: a numeric matrix or data frame
where columns correspond to time points and rows correspond to pixels.</p>
</td></tr>
<tr><td><code id="fitAR_map_+3A_coords">coords</code></td>
<td>
<p>a numeric coordinate matrix or data frame, with two columns and
rows corresponding to each pixel</p>
</td></tr>
<tr><td><code id="fitAR_map_+3A_formula">formula</code></td>
<td>
<p>a model formula, passed to <code>fitAR()</code>: the left side
of the formula should always be &quot;y&quot; and the right hand side should refer to
variables in <code>X.list</code></p>
</td></tr>
<tr><td><code id="fitAR_map_+3A_x.list">X.list</code></td>
<td>
<p>a named list of temporal or spatiotemporal predictor variables:
elements must be either numeric vectors with one element for each time point
or a matrix/data frame with rows corresponding to pixels and columns
corresponding to time point. These elements must be named and referred to
in <code>formula</code></p>
</td></tr>
<tr><td><code id="fitAR_map_+3A_resids.only">resids.only</code></td>
<td>
<p>logical: should output beyond coordinates and residuals be
withheld? Useful when passing output to <code>fitCor()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fitAR_map</code> is a wrapper function that applies <code>fitAR</code> to
many pixels.
</p>
<p>The function loops through the rows of <code>Y</code>, matched with rows of
spatiotemporal predictor matrices. Purely temporal predictors, given by
vectors, are used for all pixels. These predictor variables, given by the
right side of <code>formula</code> are sourced from named elements in <code>X.list</code>.
</p>


<h3>Value</h3>

<p><code>fitCLS_map</code> returns a list object of class &quot;mapTS&quot;.
</p>
<p>The output will always contain at least these elements:
</p>

<dl>
<dt>call</dt><dd><p>the function call</p>
</dd>
<dt>coords</dt><dd><p>the coordinate matrix or dataframe</p>
</dd>
<dt>residuals</dt><dd><p>time series residuals: rows correspond to pixels
(<code>coords</code>)</p>
</dd>
</dl>

<p>When <code>resids.only = FALSE</code>, the output will also contain the following
components. Matrices have rows that correspond to pixels and columns that
correspond to time points and vector elements correspond to pixels.
</p>

<dl>
<dt>coefficients</dt><dd><p>a numeric matrix of coefficeints</p>
</dd>
<dt>SEs</dt><dd><p>a numeric matrix of coefficient standard errors</p>
</dd>
<dt>tstats</dt><dd><p>a numeric matrix of t-statistics for coefficients</p>
</dd>
<dt>pvals</dt><dd><p>a numeric matrix of p-values for coefficients t-tests</p>
</dd>
<dt>rhos</dt><dd><p>a vector of rho values for each pixel</p>
</dd>
<dt>MSEs</dt><dd><p>a numeric vector of MSEs</p>
</dd>
<dt>logLiks</dt><dd><p>a numeric vector of log-likelihoods</p>
</dd>
<dt>fitted.values</dt><dd><p>a numeric matrix of fitted values</p>
</dd>
</dl>

<p>An attribute called &quot;resids.only&quot; is also set to match the value of
<code>resids.only</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitAR">fitAR</a></code> for fitting AR REML to individual time series and <code><a href="#topic+fitCLS">fitCLS</a></code>
&amp; <code><a href="#topic+fitCLS_map">fitCLS_map</a></code> for time series analysis based on conditional least squares.
</p>
<p>Other remoteTS: 
<code><a href="#topic+fitAR">fitAR</a>()</code>,
<code><a href="#topic+fitCLS_map">fitCLS_map</a>()</code>,
<code><a href="#topic+fitCLS">fitCLS</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate dummy data
 time.points = 9 # time series length
 map.width = 5 # square map width
 coords = expand.grid(x = 1:map.width, y = 1:map.width) # coordinate matrix
 ## create empty spatiotemporal variables:
 X &lt;- matrix(NA, nrow = nrow(coords), ncol = time.points) # response
 Z &lt;- matrix(NA, nrow = nrow(coords), ncol = time.points) # predictor
# setup first time point:
 Z[, 1] &lt;- .05*coords[,"x"] + .2*coords[,"y"]
 X[, 1] &lt;- .5*Z[, 1] + rnorm(nrow(coords), 0, .05) #x at time t
 ## project through time:
 for(t in 2:time.points){
   Z[, t] &lt;- Z[, t-1] + rnorm(map.width^2)
   X[, t] &lt;- .2*X[, t-1] + .1*Z[, t] + .05*t + rnorm(nrow(coords), 0 , .25)
 }

# visualize dummy data (NOT RUN)
library(ggplot2);library(dplyr)
data.frame(coords, X) %&gt;%
  reshape2::melt(id.vars = c("x", "y")) %&gt;%
  ggplot(aes(x = x, y = y, fill = value)) +
  geom_tile() +
  facet_wrap(~variable)

# fit AR, showing all output
fitAR_map(X, coords, formula = y ~ t, resids.only = TRUE)

# fit AR with temporal and spatiotemporal predictors
(AR.map &lt;- fitAR_map(X, coords, formula = y ~ t + Z, X.list = list(t = 1:ncol(X),
                     Z = Z), resids.only = FALSE))
## extract some values
AR.map$coefficients # coefficients
AR.map$logLik # log-likelihoods

## Methods
summary(AR.map)
residuals(AR.map)
coefficients(AR.map)

</code></pre>

<hr>
<h2 id='fitCLS'>CLS for time series</h2><span id='topic+fitCLS'></span>

<h3>Description</h3>

<p><code>fitCLS</code> is used to fit conditional least squares regression
to time series data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitCLS(
  formula,
  data = NULL,
  lag.y = 1,
  lag.x = 1,
  debug = FALSE,
  model = FALSE,
  y = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitCLS_+3A_formula">formula</code></td>
<td>
<p>a model formula, as used by <code>stats::lm()</code></p>
</td></tr>
<tr><td><code id="fitCLS_+3A_data">data</code></td>
<td>
<p>optional data environment to search for variables in <code>formula</code>.
As used by <code>lm()</code></p>
</td></tr>
<tr><td><code id="fitCLS_+3A_lag.y">lag.y</code></td>
<td>
<p>an integer indicating the lag (in time steps) between y and y.0</p>
</td></tr>
<tr><td><code id="fitCLS_+3A_lag.x">lag.x</code></td>
<td>
<p>an integer indicating the lag (in time steps) between y and the
independent variables (except y.0).</p>
</td></tr>
<tr><td><code id="fitCLS_+3A_debug">debug</code></td>
<td>
<p>logical debug mode</p>
</td></tr>
<tr><td><code id="fitCLS_+3A_model">model</code></td>
<td>
<p>logical, should the used model matrix be returned? As used by
<code>lm()</code></p>
</td></tr>
<tr><td><code id="fitCLS_+3A_y">y</code></td>
<td>
<p>logical, should the used response variable be returned? As used by
<code>lm()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function regresses the response variable (y) at time t, conditional on the
response at time t-<code>lag.y </code> and the specified dependent variables (X) at
time t-<code>lag.x</code>:
</p>
<p style="text-align: center;"><code class="reqn">y(t) = y(t - lag.y) + X(t - lag.x) + \varepsilon</code>
</p>

<p>where <code class="reqn">y(t)</code> is the response at time <code class="reqn">t</code>;
</p>
<p><code class="reqn">X(t)</code> is a model matrix containing covariates;
</p>
<p><code class="reqn">\beta</code> is a vector of effects of <code class="reqn">X(t)</code>;
</p>
<p>and <code class="reqn">\varepsilon(t)</code> is a temporally independent Gaussian random
variable with mean zero and standard deviation <code class="reqn">\sigma</code>
</p>
<p><code>stats::lm()</code> is then called, using the above equation.
</p>


<h3>Value</h3>

<p><code>fitCLS</code> returns a list object of class &quot;remoteTS&quot;, which
inherits from  &quot;lm&quot;. In addition to the default &quot;lm&quot; components, the output
contains these additional list elements:
</p>

<dl>
<dt>tstat</dt><dd><p>the t-statistics for coefficients</p>
</dd>
<dt>pval</dt><dd><p>the p-values corresponding to t-tests of coefficients</p>
</dd>
<dt>MSE</dt><dd><p>the model mean squared error</p>
</dd>
<dt>logLik</dt><dd><p>the log-likelihood of the model fit</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+fitCLS_map">fitCLS_map</a></code> to easily apply <code>fitCLS</code> to many pixels;
<code><a href="#topic+fitAR">fitAR</a></code> and <code><a href="#topic+fitAR_map">fitAR_map</a></code> for AR time series analyses.
</p>
<p>Other remoteTS: 
<code><a href="#topic+fitAR_map">fitAR_map</a>()</code>,
<code><a href="#topic+fitAR">fitAR</a>()</code>,
<code><a href="#topic+fitCLS_map">fitCLS_map</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# simulate dummy data
t = 1:30 # times series
Z = rnorm(30) # random independent variable
x = .2*Z + (.05*t) # generate dependent effects
x[2:30] = x[2:30] + .2*x[1:29] # add autocorrelation
x = x + rnorm(30, 0, .01)
df = data.frame(x, t, Z) # collect in data frame

# fit a CLS model with previous x, t, and Z as predictors
## note, this model does not follow the underlying process.
### See below for a better fit.
(CLS &lt;- fitCLS(x ~ t + Z, data = df))

# extract other values
CLS$MSE #MSE
CLS$logLik #log-likelihood

# fit with no lag in independent variables (as simulated):
(CLS2 &lt;- fitCLS(x ~ t + Z, df, lag.x = 0))
summary(CLS2)

# no lag in x
fitCLS(x ~ t + Z, df, lag.y = 0)

# visualize the lag
## large lag in x
fitCLS(x ~ t + Z, df, lag.y = 2, lag.x = 0, debug = TRUE)$lag
## large lag in Z
fitCLS(x ~ t + Z, df, lag.y = 0, lag.x = 2, debug = TRUE)$lag

# # throws errors (NOT RUN)
# fitCLS(x ~ t + Z, df, lag.y = 28) # longer lag than time
# fitCLS(cbind(x, rnorm(30)) ~ t + Z, df) # matrix response

## Methods
summary(CLS)
residuals(CLS)

</code></pre>

<hr>
<h2 id='fitCLS_map'>Map-level CLS for time series</h2><span id='topic+fitCLS_map'></span>

<h3>Description</h3>

<p><code>fitCLS_map</code> is used to fit conditional least squares
regression to each spatial location (pixel) within spatiotemporal data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitCLS_map(
  Y,
  coords,
  formula = "y ~ t",
  X.list = list(t = 1:ncol(Y)),
  lag.y = 1,
  lag.x = 0,
  resids.only = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitCLS_map_+3A_y">Y</code></td>
<td>
<p>a spatiotemporal response variable: a numeric matrix or data frame
where columns correspond to time points and rows correspond to pixels.</p>
</td></tr>
<tr><td><code id="fitCLS_map_+3A_coords">coords</code></td>
<td>
<p>a numeric coordinate matrix or data frame, with two columns and
rows corresponding to each pixel</p>
</td></tr>
<tr><td><code id="fitCLS_map_+3A_formula">formula</code></td>
<td>
<p>a model formula, passed to <code>fitCLS()</code>: the left side
of the formula should always be &quot;y&quot; and the right hand side should refer to
variables in <code>X.list</code></p>
</td></tr>
<tr><td><code id="fitCLS_map_+3A_x.list">X.list</code></td>
<td>
<p>a named list of temporal or spatiotemporal predictor variables:
elements must be either numeric vectors with one element for each time point
or a matrix/data frame with rows corresponding to pixels and columns
corresponding to time point. These elements must be named and referred to
in <code>formula</code></p>
</td></tr>
<tr><td><code id="fitCLS_map_+3A_lag.y">lag.y</code></td>
<td>
<p>the lag between y and y.0, passed to <code>fitCLS()</code></p>
</td></tr>
<tr><td><code id="fitCLS_map_+3A_lag.x">lag.x</code></td>
<td>
<p>the lag between y and predictor variables, passed to
<code>fitCLS()</code></p>
</td></tr>
<tr><td><code id="fitCLS_map_+3A_resids.only">resids.only</code></td>
<td>
<p>logical: should output beyond coordinates and residuals be
withheld? Useful when passing output to <code>fitCor()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fitCLS_map</code> is a wrapper function that applies
<code>fitCLS()</code> to many pixels.
</p>
<p>The function loops through the rows of <code>Y</code>, matched with rows of
spatiotemporal predictor matrices. Purely temporal predictors, given by
vectors, are used for all pixels. These predictor variables, given by the
right side of <code>formula</code> are sourced from named elements in <code>X.list</code>.
</p>


<h3>Value</h3>

<p><code>fitCLS_map</code> returns a list object of class &quot;mapTS&quot;.
</p>
<p>The output will always contain at least these elements:
</p>

<dl>
<dt>call</dt><dd><p>the function call</p>
</dd>
<dt>coords</dt><dd><p>the coordinate matrix or dataframe</p>
</dd>
<dt>residuals</dt><dd><p>time series residuals: rows correspond to pixels (<code>coords</code>)</p>
</dd>
</dl>

<p>When <code>resids.only = FALSE</code>, the output will also contain the following
components. Matrices have rows that correspond to pixels and columns that
correspond to time points and vector elements correspond to pixels.
</p>

<dl>
<dt>coefficients</dt><dd><p>a numeric matrix of coefficeints</p>
</dd>
<dt>SEs</dt><dd><p>a numeric matrix of coefficient standard errors</p>
</dd>
<dt>tstats</dt><dd><p>a numeric matrix of t-statistics for coefficients</p>
</dd>
<dt>pvals</dt><dd><p>a numeric matrix of p-values for coefficients t-tests</p>
</dd>
<dt>MSEs</dt><dd><p>a numeric vector of MSEs</p>
</dd>
<dt>logLiks</dt><dd><p>a numeric vector of log-likelihoods</p>
</dd>
<dt>fitted.values</dt><dd><p>a numeric matrix of fitted values</p>
</dd>
</dl>

<p>An attribute called &quot;resids.only&quot; is also set to match the value of
<code>resids.only</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fitCLS">fitCLS</a></code> for fitting CLS on individual time series and
<code><a href="#topic+fitAR">fitAR</a></code> and <code><a href="#topic+fitAR_map">fitAR_map</a></code> for AR REML time series analysis.
</p>
<p>Other remoteTS: 
<code><a href="#topic+fitAR_map">fitAR_map</a>()</code>,
<code><a href="#topic+fitAR">fitAR</a>()</code>,
<code><a href="#topic+fitCLS">fitCLS</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# simulate dummy data
time.points = 9 # time series length
map.width = 5 # square map width
coords = expand.grid(x = 1:map.width, y = 1:map.width) # coordinate matrix
## create empty spatiotemporal variables:
X &lt;- matrix(NA, nrow = nrow(coords), ncol = time.points) # response
Z &lt;- matrix(NA, nrow = nrow(coords), ncol = time.points) # predictor
# setup first time point:
Z[, 1] &lt;- .05*coords[,"x"] + .2*coords[,"y"]
X[, 1] &lt;- .5*Z[, 1] + rnorm(nrow(coords), 0, .05) #x at time t
## project through time:
for(t in 2:time.points){
  Z[, t] &lt;- Z[, t-1] + rnorm(map.width^2)
  X[, t] &lt;- .2*X[, t-1] + .1*Z[, t] + .05*t + rnorm(nrow(coords), 0 , .25)
}

# # visualize dummy data (NOT RUN)
# library(ggplot2);library(dplyr)
# data.frame(coords, X) %&gt;%
#   reshape2::melt(id.vars = c("x", "y")) %&gt;%
#   ggplot(aes(x = x, y = y, fill = value)) +
#   geom_tile() +
#   facet_wrap(~variable)

# fit CLS, showing all output
fitCLS_map(X, coords, formula = y ~ t, resids.only = TRUE)

# fit CLS with temporal and spatiotemporal predictors
(CLS.map &lt;- fitCLS_map(X, coords, formula = y ~ t + Z,
                       X.list = list(t = 1:ncol(X), Z = Z),
                       resids.only = FALSE))
## extract some values
CLS.map$coefficients # coefficients
CLS.map$logLik # log-likelihoods

## Methods
summary(CLS.map)
residuals(CLS.map)
coefficients(CLS.map)

</code></pre>

<hr>
<h2 id='fitCor'>Estimate spatial parameters from time series residuals</h2><span id='topic+fitCor'></span>

<h3>Description</h3>

<p><code>fitCor()</code> estimates parameter values of a distance-based
variance function from the pixel-wise correlations among time series residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitCor(
  resids,
  coords,
  distm_FUN = "distm_scaled",
  covar_FUN = "covar_exp",
  start = list(r = 0.1),
  fit.n = 1000,
  index,
  save_mod = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitCor_+3A_resids">resids</code></td>
<td>
<p>a matrix of time series residuals, with rows corresponding to
pixels and columns to time points</p>
</td></tr>
<tr><td><code id="fitCor_+3A_coords">coords</code></td>
<td>
<p>a numeric coordinate matrix or data frame, with two columns and
rows corresponding to each pixel</p>
</td></tr>
<tr><td><code id="fitCor_+3A_distm_fun">distm_FUN</code></td>
<td>
<p>a function to calculate a distance matrix from <code>coords</code></p>
</td></tr>
<tr><td><code id="fitCor_+3A_covar_fun">covar_FUN</code></td>
<td>
<p>a function to estimate distance-based covariances</p>
</td></tr>
<tr><td><code id="fitCor_+3A_start">start</code></td>
<td>
<p>a named list of starting parameter values for <code>covar_FUN</code>, passed to <code>nls</code></p>
</td></tr>
<tr><td><code id="fitCor_+3A_fit.n">fit.n</code></td>
<td>
<p>an integer indicating how many pixels should be used to estimate parameters.</p>
</td></tr>
<tr><td><code id="fitCor_+3A_index">index</code></td>
<td>
<p>an optional index of pixels to use for parameter estimation</p>
</td></tr>
<tr><td><code id="fitCor_+3A_save_mod">save_mod</code></td>
<td>
<p>logical: should the nls model be saved in the output?</p>
</td></tr>
<tr><td><code id="fitCor_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>nls</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For accurate results, <code>resids</code> and <code>coords</code> must be paired matrices.
Rows of both matrices should correspond to the same pixels.
</p>
<p>Distances between sapmled pixels are calculated with the function specified by
<code>distm_FUN</code>. This function can be any that takes a coordinate
matrix as input and returns a distance matrix between points. Some options
provided by <code>remotePARTS</code> are <code>distm_km()</code>, which returns distances
in kilometers and <code>distm_scaled()</code>, which returns distances scaled between
0 and 1.
</p>
<p><code>covar_FUN</code> can be any function that takes a vector of distances as its
first argument, and at least one parameter as additional arguments. <code>remotePARTS</code>
provides three suitable functions: <code>covar_exp</code>, <code>covar_exppow</code>, and
<code>covar_taper</code>; but user-defined functions are also possible.
</p>
<p>Parameters are estimated with <code>stats::nls()</code> by regressing correlations
among time series residuals on a function of distances specified by <code>covar_FUN</code>.
</p>
<p><code>start</code> is used by <code>nls</code> to determine how many parameters need
estimating, and starting values for those parameters. As such, it is important
that <code>start</code> has named elements for each parameter in <code>covar_FUN</code>.
</p>
<p>The fit will be performed for all pixels specified in <code>index</code>, if provided.
Otherwise, a random sample of length <code>fit.n</code> is used. If <code>fit.n</code>
exceeds the number of pixels, all pixels are used. When random pixels are used,
parameter estimates will be different for each call of the function. For reproducible
results, we recommend taking a random sample of pixels manually and passing in
those values as <code>index</code>.
</p>
<p>Caution: Note that a distance matrix, of size <code class="reqn">n \times n</code> must be fit to the
sampled data where <code class="reqn">n</code> is either <code>fit.n</code> or <code>length(index)</code>.
Take your computer's memory and processing time into consideration when choosing
this size.
</p>
<p>Parameter estimates are always returned in the same scale of distances
calculated by <code>distm_FUN</code>. It is very important that these estimates
are re-scaled by users if output of <code>distm_FUN</code> use units different from
the desired scale. For example,
if the function <code>covar_FUN = function(d, r, a){-(d/r)^a}</code> is used
with <code>distm_FUN = "distm_scaled"</code>, the estimated range parameter <code>r</code>
will be based on a unit-map. Users will likely want to re-scaled it to map
units by multiplying <code>r</code> by the maximum distance among points on your map.
</p>
<p>If the <code>distm_FUN</code> is on the scale of your map (e.g., &quot;distm_km&quot;),
re-scaling is not needed but may be preferable, since it is scaled to the
maximum distance among the sampled data rather than the true maximum
distance. For example, dividing the range parameter by <code>max.distance</code>
and then multiplying it by the true max distance may provide a better range
estimate.
</p>


<h3>Value</h3>

<p><code>fitCor</code> returns a list object of class &quot;remoteCor&quot;, which contains
these elements:
</p>

<dl>
<dt>call</dt><dd><p>the function call</p>
</dd>
<dt>mod</dt><dd><p>the <code>nls</code> fit object, if <code>save_mod=TRUE</code></p>
</dd>
<dt>spcor</dt><dd><p>a vector of the estimated spatial correlation parameters</p>
</dd>
<dt>max.distance</dt><dd><p>the maximum distance among the sampled pixels, as calculated by <code>dist_FUN</code>.</p>
</dd>
<dt>logLik</dt><dd><p>the log-likelihood of the fit</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
# simulate dummy data
set.seed(19)
time.points = 30 # time series length
map.width = 8 # square map width
coords = expand.grid(x = 1:map.width, y = 1:map.width) # coordinate matrix

## create empty spatiotemporal variables:
X &lt;- matrix(NA, nrow = nrow(coords), ncol = time.points) # response
Z &lt;- matrix(NA, nrow = nrow(coords), ncol = time.points) # predictor

## setup first time point:
Z[, 1] &lt;- .05*coords[,"x"] + .2*coords[,"y"]
X[, 1] &lt;- .5*Z[, 1] + rnorm(nrow(coords), 0, .05) #x at time t

## project through time:
for(t in 2:time.points){
  Z[, t] &lt;- Z[, t-1] + rnorm(map.width^2)
  X[, t] &lt;- .2*X[, t-1] + .1*Z[, t] + .05*t + rnorm(nrow(coords), 0 , .25)
}

AR.map = fitAR_map(X, coords, formula = y ~ Z, X.list = list(Z = Z), resids.only = FALSE)

# using pre-defined covariance function
## exponential covariance
fitCor(AR.map$residuals, coords, covar_FUN = "covar_exp", start = list(range = .1))

## exponential-power covariance
fitCor(AR.map$residuals, coords, covar_FUN = "covar_exppow", start = list(range = .1, shape = .2))

# user-specified covariance function
fitCor(AR.map$residuals, coords, covar_FUN = function(d, r){d^r}, start = list(r = .1))

# un-scaled distances:
fitCor(AR.map$residuals, coords, distm_FUN = "distm_km", start = list(r = 106))

# specify which pixels to use, for reproducibility
fitCor(AR.map$residuals, coords, index = 1:64)$spcor #all
fitCor(AR.map$residuals, coords, index = 1:20)$spcor #first 20
fitCor(AR.map$residuals, coords, index = 21:64)$spcor # last 43
# randomly select pixels
fitCor(AR.map$residuals, coords, fit.n = 20)$spcor #random 20
fitCor(AR.map$residuals, coords, fit.n = 20)$spcor # different random 20

</code></pre>

<hr>
<h2 id='fitGLS'>Fit a PARTS GLS model.</h2><span id='topic+fitGLS'></span>

<h3>Description</h3>

<p>Fit a PARTS GLS model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitGLS(
  formula,
  data,
  V,
  nugget = 0,
  formula0 = NULL,
  save.xx = FALSE,
  save.invchol = FALSE,
  logLik.only = FALSE,
  no.F = FALSE,
  coords,
  distm_FUN,
  covar_FUN,
  covar.pars,
  invCholV,
  ncores = NA,
  suppress_compare_warning = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitGLS_+3A_formula">formula</code></td>
<td>
<p>a model formula</p>
</td></tr>
<tr><td><code id="fitGLS_+3A_data">data</code></td>
<td>
<p>an optional data frame environment in which to search for
variables given by <code>formula</code></p>
</td></tr>
<tr><td><code id="fitGLS_+3A_v">V</code></td>
<td>
<p>a covariance matrix, which must be positive definitive. This argument
is optional if <code>coords</code>, <code>distm_FUN</code>, <code>covar_FUN</code>, and
<code>covar.pars</code> are given instead.</p>
</td></tr>
<tr><td><code id="fitGLS_+3A_nugget">nugget</code></td>
<td>
<p>an optional numeric nugget, must be positive</p>
</td></tr>
<tr><td><code id="fitGLS_+3A_formula0">formula0</code></td>
<td>
<p>an optional formula for the null model to be compared with
<code>formula</code> by an F-test</p>
</td></tr>
<tr><td><code id="fitGLS_+3A_save.xx">save.xx</code></td>
<td>
<p>logical: should information needed for cross-partition
comparisons be returned?</p>
</td></tr>
<tr><td><code id="fitGLS_+3A_save.invchol">save.invchol</code></td>
<td>
<p>logical: should the inverse of the Cholesky matrix be
returned?</p>
</td></tr>
<tr><td><code id="fitGLS_+3A_loglik.only">logLik.only</code></td>
<td>
<p>logical: should calculations stop after calculating parital
log-likelihood?</p>
</td></tr>
<tr><td><code id="fitGLS_+3A_no.f">no.F</code></td>
<td>
<p>logical: should F-test calculations be made?</p>
</td></tr>
<tr><td><code id="fitGLS_+3A_coords">coords</code></td>
<td>
<p>optional coordinate matrix for calculating <code>V</code> internally</p>
</td></tr>
<tr><td><code id="fitGLS_+3A_distm_fun">distm_FUN</code></td>
<td>
<p>optional function for calculating a distance matrix from
<code>coords</code>, when calculating <code>V</code> internally</p>
</td></tr>
<tr><td><code id="fitGLS_+3A_covar_fun">covar_FUN</code></td>
<td>
<p>optional distance-based covariance function for calculating
<code>V</code> internally</p>
</td></tr>
<tr><td><code id="fitGLS_+3A_covar.pars">covar.pars</code></td>
<td>
<p>an optional named list of parameters passed to <code>covar_FUN</code>
when calculating <code>V</code> internally</p>
</td></tr>
<tr><td><code id="fitGLS_+3A_invcholv">invCholV</code></td>
<td>
<p>optional pre-calculated inverse cholesky matrix to use in place
of <code>V</code></p>
</td></tr>
<tr><td><code id="fitGLS_+3A_ncores">ncores</code></td>
<td>
<p>an optional integer indicating how many CPU threads to use for
matrix calculations.</p>
</td></tr>
<tr><td><code id="fitGLS_+3A_suppress_compare_warning">suppress_compare_warning</code></td>
<td>
<p>an optional variable to suppress warning that
arises from identical <code>formula</code> and <code>formula0</code>.</p>
</td></tr>
<tr><td><code id="fitGLS_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>optimize_nugget</code>, which are
only used if if <code>nugget = NA</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>conduct generalized least-squares regression of
spatiotemporal trends
</p>
<p><code>fitGLS</code> fits a GLS model, using terms specified in <code>formula</code>.
In the PARTS method, generally the left side of <code>formula</code> should be
pixel-level trend estimates and the right side should be spatial predictors.
The errors of the GLS are correlated according to covariance matrix <code>V</code>.
</p>
<p>If <code>nugget = NA</code>, an ML nugget is estimated from the data using the
<code>optimize_nugget()</code> function. Arguments additional arguments (<code>...</code>)
are passed to <code>optimize_nugget</code> in this case. <code>V</code> must be provided
for nugget optimization.
</p>
<p>If <code>formula0</code> is not specified, the default is to fit an intercept-only
null model.
</p>
<p><code>save.xx</code> is included to allow for manually conducting a partitioned
GLS analyses. Because most users will not need this feature, opting instead
to use <code>fitGLS_parition()</code>, <code>save.xx = FALSE</code> by default.
</p>
<p>Similarly, <code>save.invchol</code> is included to allow for recycling of the
inverse cholesky matrix. Often, inverting the large cholesky matrix
(i.e., <code>invert_chol(V)</code>) is the slowest part of GLS. This argument exists
to allow users to recycle this process, though no <code>remotePARTS</code> function
currently exists that can use <code>invert_chol(V)</code> to fit the GLS.
</p>
<p><code>logLik.only = TRUE</code> will return only the partial log-likelihood, which can
minimized to obtain the maximum likelihood for a given set of data.
</p>
<p>If <code>no.F = TRUE</code>, then the model given by <code>formula</code> is not compared
to the model given by <code>formula0</code>.
</p>
<p>If <code>V</code> is not provided, it can be fit internally by specifying all of
<code>coords</code>, <code>distm_FUN</code>, <code>covar_FUN</code>, and <code>covar.pars</code>.
The function given by <code>distm_FUN</code> will calculate a distance matrix from
<code>coords</code>, which is then transformed into a distance-based covariance
matrix with <code>covar_FUN</code> and parameters given by <code>covar.pars</code>.
</p>
<p>This function uses C++ code that uses the Eigen matrix library (RcppEigen
package) to fit models as efficiently as possible. As such, all available
CPU cores are used for matrix calculations on systems with OpenMP
support.
</p>
<p><code>ncores</code> is passed to the C++ code Eigen::setNpThreads() which sets
the number of cores used for compatible Eigen matrix operations (when OpenMP
is used).
</p>


<h3>Value</h3>

<p><code>fitGLS</code> returns a list object of class &quot;remoteGLS&quot;, if
<code>logLik.only = FALSE</code>. The list contains at least the following elements:
</p>

<dl>
<dt>coefficients</dt><dd><p>coefficient estimates for predictor variables</p>
</dd>
<dt>SSE</dt><dd><p>sum of squares error</p>
</dd>
<dt>MSE</dt><dd><p>mean squared error</p>
</dd>
<dt>SE</dt><dd><p>standard errors</p>
</dd>
<dt>df_t</dt><dd><p>degrees of freedom for the t-test</p>
</dd>
<dt>logDetV</dt><dd><p>log-determinant of V</p>
</dd>
<dt>tstat</dt><dd><p>t-test statistic</p>
</dd>
<dt>pval_t</dt><dd><p>p-value of the t-statistic</p>
</dd>
<dt>logLik</dt><dd><p>the Log-likelihood of the model</p>
</dd>
<dt>nugget</dt><dd><p>the nugget used in fitting</p>
</dd>
<dt>covar_coef</dt><dd><p>the covariance matrix of the coefficients</p>
</dd>
</dl>

<p>If <code>no.F = FALSE</code>, the following elements, corresponding to the null
model and F-test are also calculated:
</p>

<dl>
<dt>coefficients0</dt><dd><p>coefficient estimates for the null model</p>
</dd>
<dt>SSE0</dt><dd><p>sum of squares error for the null model</p>
</dd>
<dt>MSE0</dt><dd><p>mean squared error for the null model</p>
</dd>
<dt>SE0</dt><dd><p>the standard errors for null coefficients</p>
</dd>
<dt>MSR</dt><dd><p>the regression mean square</p>
</dd>
<dt>df0</dt><dd><p>the null model F-test degrees of freedom</p>
</dd>
<dt>LL0</dt><dd><p>the log-likelihood of the null model</p>
</dd>
<dt>df_F</dt><dd><p>the F-test degrees of freedom, for the main model</p>
</dd>
<dt>Fstat</dt><dd><p>the F-statistic</p>
</dd>
<dt>pval_F</dt><dd><p>the F-test p-value</p>
</dd>
<dt>formula</dt><dd><p>the alternate formula used</p>
</dd>
<dt>formula0</dt><dd><p>the null formula used</p>
</dd>
</dl>

<p>An attribute called also set to <code>"no.F"</code> is set to the value of
argument <code>no.F</code>, which signals to generic methods how to handle the output.
</p>
<p>If <code>save.invchol = TRUE</code>, output also includes
</p>

<dl>
<dt>invcholV</dt><dd><p>the inverse of the Cholesky decomposition of the covariance
matrix obtained with <code>invert_chol(V, nugget)</code> </p>
</dd>
</dl>

<p>If <code>save.xx = TRUE</code>, output also includes the following elements
</p>

<dl>
<dt>xx</dt><dd><p>the predictor variables <code>X</code>, from the right side of <code>formula</code>,
transformed by the inverse cholesky matrix: xx = <code>invcholV %*% X</code> </p>
</dd>
<dt>xx0</dt><dd><p>the predictor variables <code>X0</code>, from the right side of <code>formula0</code>,
transformed by the inverse cholesky matrix: xx0 = <code>invcholV %*% X0</code> </p>
</dd>
</dl>

<p>The primary use of <code>xx</code> and <code>xx0</code> is for use with <code>fitGLS_partition()</code>.
</p>
<p>If <code>logLik.only = TRUE</code>, a single numeric output containing the
log-likelihood is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## read data
data(ndvi_AK10000)
df = ndvi_AK10000[seq_len(200), ] # first 200 rows

## fit covariance matrix
V = covar_exp(distm_scaled(cbind(df$lng, df$lat)), range = .01)

## run GLS
(GLS = fitGLS(CLS_coef ~ 0 + land, data = df, V = V))

## with F-test calculations to compare with the NULL model
(GLS.F = fitGLS(CLS_coef ~ 0 + land, data = df, V = V, no.F = FALSE))

## find ML nugget
fitGLS(CLS_coef ~ 0 + land, data = df, V = V, no.F = FALSE, nugget = NA)

## calculate V internally
coords = cbind(df$lng, df$lat)
fitGLS(CLS_coef ~ 0 + land, data = df, logLik.only = FALSE, coords = coords,
       distm_FUN = "distm_scaled", covar_FUN = "covar_exp", covar.pars = list(range = .01))

## use inverse cholesky
fitGLS(CLS_coef ~ 0 + land, data = df, invCholV = invert_chol(V))

## save inverse cholesky matrix
invchol = fitGLS(CLS_coef ~ 0 + land, data = df, V = V, save.invchol = TRUE)$invcholV

## re-use inverse cholesky instead of V
fitGLS(CLS_coef ~ 0 + land, data = df, invCholV = invchol)

## Log-likelihood (fast)
fitGLS(CLS_coef ~ 0 + land, data = df, V = V, logLik.only = TRUE)

</code></pre>

<hr>
<h2 id='fitGLS_opt'>Fit a PARTS GLS model, with maximum likelihood spatial parameters</h2><span id='topic+fitGLS_opt'></span>

<h3>Description</h3>

<p>Fit a PARTS GLS model, with maximum likelihood spatial parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitGLS_opt(
  formula,
  data = NULL,
  coords,
  distm_FUN = "distm_scaled",
  covar_FUN = "covar_exp",
  start = c(range = 0.01, nugget = 0),
  fixed = c(),
  opt.only = FALSE,
  formula0 = NULL,
  save.xx = FALSE,
  save.invchol = FALSE,
  no.F = TRUE,
  trans = list(),
  backtrans = list(),
  debug = TRUE,
  ncores = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitGLS_opt_+3A_formula">formula</code></td>
<td>
<p>a model formula, passed to <code>fitGLS</code></p>
</td></tr>
<tr><td><code id="fitGLS_opt_+3A_data">data</code></td>
<td>
<p>an optional data frame environment in which to search for
variables given by <code>formula</code>; passed to <code>fitGLS</code></p>
</td></tr>
<tr><td><code id="fitGLS_opt_+3A_coords">coords</code></td>
<td>
<p>a numeric coordinate matrix or data frame, with two columns and
rows corresponding to each pixel</p>
</td></tr>
<tr><td><code id="fitGLS_opt_+3A_distm_fun">distm_FUN</code></td>
<td>
<p>a function to calculate a distance matrix from <code>coords</code></p>
</td></tr>
<tr><td><code id="fitGLS_opt_+3A_covar_fun">covar_FUN</code></td>
<td>
<p>a function to estimate distance-based covariances</p>
</td></tr>
<tr><td><code id="fitGLS_opt_+3A_start">start</code></td>
<td>
<p>a named vector of starting values for each parameter to be estimated;
names must match the names of arguments in <code>covar_FUN</code> or &quot;nugget&quot;</p>
</td></tr>
<tr><td><code id="fitGLS_opt_+3A_fixed">fixed</code></td>
<td>
<p>an optional named vector of fixed parameter values; names
must match the names of arguments in <code>covar_FUN</code> or &quot;nugget&quot;</p>
</td></tr>
<tr><td><code id="fitGLS_opt_+3A_opt.only">opt.only</code></td>
<td>
<p>logical: if TRUE, execution will halt after estimating the parameters;
a final GLS will not be fit with the estimated parameters</p>
</td></tr>
<tr><td><code id="fitGLS_opt_+3A_formula0">formula0</code>, <code id="fitGLS_opt_+3A_save.xx">save.xx</code>, <code id="fitGLS_opt_+3A_save.invchol">save.invchol</code>, <code id="fitGLS_opt_+3A_no.f">no.F</code></td>
<td>
<p>arguments passed to <code>fitGLS</code>
for final GLS output</p>
</td></tr>
<tr><td><code id="fitGLS_opt_+3A_trans">trans</code></td>
<td>
<p>optional list of functions for transforming the values in
<code>start</code> or <code>fixed</code> in order to constrain the parameter space within
<code>optim</code></p>
</td></tr>
<tr><td><code id="fitGLS_opt_+3A_backtrans">backtrans</code></td>
<td>
<p>optional list of functions for back-transforming parameters
to their correct scale (for use with <code>trans</code>)</p>
</td></tr>
<tr><td><code id="fitGLS_opt_+3A_debug">debug</code></td>
<td>
<p>logical: debug mode (for use with <code>trans</code> and <code>backtrans</code>)</p>
</td></tr>
<tr><td><code id="fitGLS_opt_+3A_ncores">ncores</code></td>
<td>
<p>an optional integer indicating how many CPU threads to use for calculations.</p>
</td></tr>
<tr><td><code id="fitGLS_opt_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>stats::optim()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimate spatial parameters, via maximum likelihood, from data
rather than from time series residuals; Fit a GLS with these specifications.
</p>
<p><code>fitGLS_opt</code> fits a GLS by estimating spatial parameters from
data. <code><a href="#topic+fitCor">fitCor</a></code>, combined with <code><a href="#topic+fitGLS">fitGLS</a>(nugget = NA)</code>,
gives better estimates of spatial parameters, but time-series residuals may
not be available in all cases. In these cases, spatial parameters can be
estimated from distances among points and a response vector. Mathematical
optimization of the log likelihood of different GLS models are computed by
calling <code>optim()</code> on <code>fitGLS</code>.
</p>
<p>Distances are calculated with <code>distm_FUN</code> and a covariance matrix is
calculated from these distances with <code>covar_FUN</code>. Arguments to to
<code>covar_FUN</code>, except distances, are given by <code>start</code> and <code>fixed</code>.
Parameters specified in <code>start</code> will be be estimated while those given
by <code>fixed</code> will remain constant throughout fitting. Parameter names in
<code>start</code> and <code>fixed</code> should exactly match the names of arguments in
<code>covar_FUN</code> and should not overlap (though, <code>fixed</code> takes precedence).
</p>
<p>In addition to arguments of <code>covar_FUN</code> a &quot;nugget&quot; component can
also be occur in <code>start</code> or <code>fixed</code>. If &quot;nugget&quot; does not occur
in either vector, the GLS are fit with <code>nugget = 0</code>. A zero nugget also
allows much faster computation, through recycling the common
inverse cholesky matrix in each GLS computation. A non-zero nugget requires
inversion of a different matrix at each iteration, which can be
substantially slower.
</p>
<p>If <code>opt.only = FALSE</code>, the estimated parameters are used to fit the final
maximum likelihood GLS solution with <code>fitGLS()</code> and arguments
<code>formula0</code>, <code>save.xx</code>, <code>save.invchol</code>, and <code>no.F</code>.
</p>
<p>Some parameter combinations may not produce valid covariance matrices. During
the optimization step messages about non-positive definitive V may result on
some iterations. These warnings are produced by <code>fitGLS</code> and NA
log-likelihoods are returned in those cases.
</p>
<p>Note that <code>fitGLS_opt</code> fits multiple GLS models, which requires
inverting a large matrix for each one (unless a fixed 0 nugget is used).
This process is very computationally intensive and may take a long time to
finish depending upon your machine and the size of the data.
</p>
<p>Sometimes <code>optim</code> can have a difficult time finding a reasonable solution
and without any constraits on parameter space (with certain algorithms), results
may even be nonsensical. To combat this, <code>fitGLS_opt</code> has the arguments
<code>trans</code> and <code>backtrans</code> which allow you to transform
(and back-transform) parameters to a different scale. For example, you may
want to force the 'range' parameter between 0 and 1. The logit function can
do just that, as its limits are -Inf and Inf as x approaches 0 and 1,
respectively. So, we can set <code>trans</code> to the logit function:
<code>trans = list(range = function(x)log(x/(1-x)))</code>. Then we need to set
<code>backtrans</code> to the inverse logit function to return a parameter value
between 0 and 1: <code>backtrans = list(range = function(x)1/(1+exp(-x)))</code>.
This will force the optimizer to only search for the range parameter in the
space from 0 to 1. Any other constraint function can be used for <code>trans</code>
provided that there is a matching back-transformation.
</p>


<h3>Value</h3>

<p>If <code>opt.only = TRUE</code>, <code>fitGLS_opt</code> returns the
output from <code>stats::optim()</code>: see it's documentation for more details.
</p>
<p>Otherwise, a list with two elements is returned:
</p>

<dl>
<dt>opt</dt><dd><p>output from <code>optim</code>, as above</p>
</dd>
<dt>GLS</dt><dd><p>a &quot;remoteGLS&quot; object. See <code><a href="#topic+fitGLS">fitGLS</a></code> for more details.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+fitCor">fitCor</a></code> for estimating spatial parameters from time
series residuals; <code><a href="#topic+fitGLS">fitGLS</a></code> for fitting GLS and with the option
of estimating the maximum-likelihood nugget component only.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## read data
data(ndvi_AK10000)
df = ndvi_AK10000[seq_len(200), ] # first 200 rows

## estimate nugget and range (very slow)
fitGLS_opt(formula = CLS_coef ~ 0 + land, data = df,
            coords = df[, c("lng", "lat")], start = c(range = .1, nugget = 0),
            opt.only = TRUE)

## estimate range only, fixed nugget at 0, and fit full GLS (slow)
fitGLS_opt(formula = CLS_coef ~ 0 + land, data = df,
             coords = df[, c("lng", "lat")],
             start = c(range = .1), fixed = c("nugget" = 0),
             method = "Brent", lower = 0, upper = 1)

## constrain nugget to 0 and 1
logit &lt;- function(p) {log(p / (1 - p))}
inv_logit &lt;- function(l) {1 / (1 + exp(-l))}

fitGLS_opt(formula = CLS_coef ~ 0 + land, data = df,
           coords = df[, c("lng", "lat")],
           start = c(range = .1, nugget = 1e-10),
           trans = list(nugget = logit), backtrans = list(nugget = inv_logit),
           opt.only = TRUE)

</code></pre>

<hr>
<h2 id='fitGLS_opt_FUN'>Function that fitGLS_opt optimizes over</h2><span id='topic+fitGLS_opt_FUN'></span>

<h3>Description</h3>

<p>Function that fitGLS_opt optimizes over
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitGLS_opt_FUN(
  op,
  fp,
  formula,
  data = NULL,
  coords,
  covar_FUN = "covar_exp",
  distm_FUN = "distm_scaled",
  is.trans = FALSE,
  backtrans = list(),
  ncores = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitGLS_opt_FUN_+3A_op">op</code></td>
<td>
<p>a named vector of parameters to be optimized</p>
</td></tr>
<tr><td><code id="fitGLS_opt_FUN_+3A_fp">fp</code></td>
<td>
<p>a named vector of fixed parameters</p>
</td></tr>
<tr><td><code id="fitGLS_opt_FUN_+3A_formula">formula</code></td>
<td>
<p>GLS model formula</p>
</td></tr>
<tr><td><code id="fitGLS_opt_FUN_+3A_data">data</code></td>
<td>
<p>data source</p>
</td></tr>
<tr><td><code id="fitGLS_opt_FUN_+3A_coords">coords</code></td>
<td>
<p>a coordinate matrix</p>
</td></tr>
<tr><td><code id="fitGLS_opt_FUN_+3A_covar_fun">covar_FUN</code></td>
<td>
<p>a covariance function</p>
</td></tr>
<tr><td><code id="fitGLS_opt_FUN_+3A_distm_fun">distm_FUN</code></td>
<td>
<p>a distm function</p>
</td></tr>
<tr><td><code id="fitGLS_opt_FUN_+3A_is.trans">is.trans</code></td>
<td>
<p>logical: are any of the values in <code>op</code> or <code>fp</code>
transformed, needing back-transformation?</p>
</td></tr>
<tr><td><code id="fitGLS_opt_FUN_+3A_backtrans">backtrans</code></td>
<td>
<p>optional: a named list of functions used to backtransform any element
of <code>op</code> or <code>fp</code>. Names must correspond to names in <code>op</code>
or <code>fp</code>.</p>
</td></tr>
<tr><td><code id="fitGLS_opt_FUN_+3A_ncores">ncores</code></td>
<td>
<p>an optional integer indicating how many CPU threads to use for calculations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>fitGLS_opt_FUN</code> returns the negative log likelihood of a GLS,
given the parameters in <code>op</code> and <code>fp</code>
</p>

<hr>
<h2 id='invert_chol'>Invert the cholesky decomposition of V</h2><span id='topic+invert_chol'></span>

<h3>Description</h3>

<p>Invert the cholesky decomposition of V
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invert_chol(M, nugget = 0, ncores = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="invert_chol_+3A_m">M</code></td>
<td>
<p>numeric (double), positive definite matrix</p>
</td></tr>
<tr><td><code id="invert_chol_+3A_nugget">nugget</code></td>
<td>
<p>numeric (double) nugget to add to M</p>
</td></tr>
<tr><td><code id="invert_chol_+3A_ncores">ncores</code></td>
<td>
<p>optional integer indicating how many cores to use during the
inversion calculation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the inverse of the Cholesky decomposition of M which
should not be confused with the inverse of M *derived* from the
Cholesky decomposition (i.e. 'chol2inv(M)').
</p>


<h3>Value</h3>

<p>numeric matrix: inverse of the Cholesky decomposition (lower triangle)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- crossprod(matrix(1:6, 3))

# without a nugget:
invert_chol(M)

# with a nugget:
invert_chol(M, nugget = 0.2)
</code></pre>

<hr>
<h2 id='max_dist'>calculate maximum distance among a table of coordinates</h2><span id='topic+max_dist'></span>

<h3>Description</h3>

<p>calculate maximum distance among a table of coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_dist(coords, dist_FUN = "distm_km")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="max_dist_+3A_coords">coords</code></td>
<td>
<p>the coordinate matrix (or dataframe) from which a maximum distance is desired.</p>
</td></tr>
<tr><td><code id="max_dist_+3A_dist_fun">dist_FUN</code></td>
<td>
<p>the distance function used to calculate distances</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First the outermost points are found by fitting a convex hull in
Euclidean space. Then, the distances between these outer points is calculated
with <code>dist_FUN</code>, and the maximum of these distances is returned
</p>
<p>This is a fast, simple way of determining the maximum distance.
</p>


<h3>Value</h3>

<p>The maximum distance between two points (units determined by
<code>dist_FUN</code>)
</p>

<hr>
<h2 id='MC_GLSpart'>fit a parallel partitioned GLS</h2><span id='topic+MC_GLSpart'></span><span id='topic+MCGLS_partsummary'></span><span id='topic+multicore_fitGLS_partition'></span><span id='topic+fitGLS_partition'></span><span id='topic+part_data'></span><span id='topic+part_csv'></span>

<h3>Description</h3>

<p>fit a GLS model to a large data set by partitioning the data
into smaller pieces (partitions) and processing these pieces individually and
summarizing output across partitions to conduct hypothesis tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MC_GLSpart(
  formula,
  partmat,
  formula0 = NULL,
  part_FUN = "part_data",
  distm_FUN = "distm_scaled",
  covar_FUN = "covar_exp",
  covar.pars = c(range = 0.1),
  nugget = NA,
  ncross = 6,
  save.GLS = FALSE,
  ncores = parallel::detectCores(logical = FALSE) - 1,
  debug = FALSE,
  ...
)

MCGLS_partsummary(
  MCpartGLS,
  covar.pars = c(range = 0.1),
  save.GLS = FALSE,
  partsize
)

multicore_fitGLS_partition(
  formula,
  partmat,
  formula0 = NULL,
  part_FUN = "part_data",
  distm_FUN = "distm_scaled",
  covar_FUN = "covar_exp",
  covar.pars = c(range = 0.1),
  nugget = NA,
  ncross = 6,
  save.GLS = FALSE,
  ncores = parallel::detectCores(logical = FALSE) - 1,
  do.t.test = TRUE,
  do.chisqr.test = TRUE,
  debug = FALSE,
  ...
)

fitGLS_partition(
  formula,
  partmat,
  formula0 = NULL,
  part_FUN = "part_data",
  distm_FUN = "distm_scaled",
  covar_FUN = "covar_exp",
  covar.pars = c(range = 0.1),
  nugget = NA,
  ncross = 6,
  save.GLS = FALSE,
  do.t.test = TRUE,
  do.chisqr.test = TRUE,
  progressbar = TRUE,
  debug = FALSE,
  ncores = NA,
  parallel = TRUE,
  ...
)

part_data(index, formula, data, formula0 = NULL, coord.names = c("lng", "lat"))

part_csv(index, formula, file, formula0 = NULL, coord.names = c("lng", "lat"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MC_GLSpart_+3A_formula">formula</code></td>
<td>
<p>a formula for the GLS model</p>
</td></tr>
<tr><td><code id="MC_GLSpart_+3A_partmat">partmat</code></td>
<td>
<p>a numeric partition matrix, with values containing indices of locations.</p>
</td></tr>
<tr><td><code id="MC_GLSpart_+3A_formula0">formula0</code></td>
<td>
<p>an optional formula for the null GLS model</p>
</td></tr>
<tr><td><code id="MC_GLSpart_+3A_part_fun">part_FUN</code></td>
<td>
<p>a function to partition individual data. See details for more
information about requirements for this function.</p>
</td></tr>
<tr><td><code id="MC_GLSpart_+3A_distm_fun">distm_FUN</code></td>
<td>
<p>a function to calculate distances from a coordinate matrix</p>
</td></tr>
<tr><td><code id="MC_GLSpart_+3A_covar_fun">covar_FUN</code></td>
<td>
<p>a function to calculate covariances from a distance matrix</p>
</td></tr>
<tr><td><code id="MC_GLSpart_+3A_covar.pars">covar.pars</code></td>
<td>
<p>a named list of parameters passed to <code>covar_FUN</code></p>
</td></tr>
<tr><td><code id="MC_GLSpart_+3A_nugget">nugget</code></td>
<td>
<p>a numeric fixed nugget component: if NA, the nugget is estimated for
each partition</p>
</td></tr>
<tr><td><code id="MC_GLSpart_+3A_ncross">ncross</code></td>
<td>
<p>an integer indicating the number of partitions used to calculate
cross-partition statistics</p>
</td></tr>
<tr><td><code id="MC_GLSpart_+3A_save.gls">save.GLS</code></td>
<td>
<p>logical: should full GLS output be saved for each partition?</p>
</td></tr>
<tr><td><code id="MC_GLSpart_+3A_ncores">ncores</code></td>
<td>
<p>an optional integer indicating how many CPU threads to use for calculations.</p>
</td></tr>
<tr><td><code id="MC_GLSpart_+3A_debug">debug</code></td>
<td>
<p>logical debug mode</p>
</td></tr>
<tr><td><code id="MC_GLSpart_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>part_FUN</code></p>
</td></tr>
<tr><td><code id="MC_GLSpart_+3A_mcpartgls">MCpartGLS</code></td>
<td>
<p>object resulting from MC_partGLS()</p>
</td></tr>
<tr><td><code id="MC_GLSpart_+3A_partsize">partsize</code></td>
<td>
<p>number of locations per partition</p>
</td></tr>
<tr><td><code id="MC_GLSpart_+3A_do.t.test">do.t.test</code></td>
<td>
<p>logical: should a t-test of the GLS coefficients be conducted?</p>
</td></tr>
<tr><td><code id="MC_GLSpart_+3A_do.chisqr.test">do.chisqr.test</code></td>
<td>
<p>logical: should a correlated chi-squared test of the model
fit be conducted?</p>
</td></tr>
<tr><td><code id="MC_GLSpart_+3A_progressbar">progressbar</code></td>
<td>
<p>logical: should progress be tracked with a progress bar?</p>
</td></tr>
<tr><td><code id="MC_GLSpart_+3A_parallel">parallel</code></td>
<td>
<p>logical: should all calculations be done in parallel? See details for
more information</p>
</td></tr>
<tr><td><code id="MC_GLSpart_+3A_index">index</code></td>
<td>
<p>a vector of pixels with which to subset the data</p>
</td></tr>
<tr><td><code id="MC_GLSpart_+3A_data">data</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="MC_GLSpart_+3A_coord.names">coord.names</code></td>
<td>
<p>a vector containing names of spatial coordinate variables
(x and y, respectively)</p>
</td></tr>
<tr><td><code id="MC_GLSpart_+3A_file">file</code></td>
<td>
<p>a text string indicating the csv file from which to read data</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function specified by <code>part_FUN</code> is called internally to obtain
properly formatted subsets of the full data (i.e., partitions). Two functions
are provided in the <code>remotePARTs</code> package for this purpose: <code>part_data</code>
and <code>part_csv</code>. Both of these functions have required arguments that
must be specified through the call to <code>fitGLS_partition</code> (via <code>...</code>).
Check each function's argument list and see &quot;<code>part_FUN</code> details&quot; below
for more information.
</p>
<p><code>partmat</code> is used to partition the data. <code>partmat</code> must be a complete
matrix, without any missing or non-finite values. Columns of <code>partmat</code> are
passed as the first argument <code>part_FUN</code> to obtain data, which is then
passed to <code>fitGLS</code>. Users are encouraged to use <code>sample_partitions()</code>
to obtain a valid <code>partmat</code>.
</p>
<p>The specific dimensions of <code>partmat</code> can have a substantial effect on the
efficiency of <code>fitGLS_partition</code>. For most systems, we do not recommend
fitting with partitions exceeding 3000 locations or pixels
(i.e., <code>partmat(partsize = 3000, ...)</code>). Any larger, and the covariance
matrix inversions may become quite slow (or impossible for some machines).
It may help performance to use smaller even partitions of around 1000-2000
locations.
</p>
<p><code>ncross</code> determines how many partitions are used to estimate cross-partition
statistics. All partitions, up to <code>ncross</code> are compared with all others
in a pairwise fashion. There is no hard rule for setting <code>mincross</code>. More
crosses will ensure convergence, but we believe that the default of 6
(10 total comparisons) should be sufficient for most moderate-sized maps
if 1500-3000 pixel partitions are used. This may require testing with each
individual dataset to determine at what point convergence occurs.
</p>
<p>Covariance matrices for each partition are calculated with <code>covar_FUN</code>
from distances among points within the partition. Parameter values for
<code>covar_FUN</code> are given by <code>covar.pars</code>.
</p>
<p>The distances among points are calculated with <code>distm_FUN</code>.
<code>distm_FUN</code> can be any function, modeled after <code>geosphere::distm()</code>,
that satisfies both: 1) returns a distance matrix among points when a single
coordinate matrix is given as first argument; and 2) returns a matrix
containing distances between two coordinate matrices if given as the first and
second arguments.
</p>
<p>If <code>nugget = NA</code>, a ML nugget is obtained for each partition. Otherwise,
a fixed nugget is used for all partitions.
</p>
<p>It is not required to use all partitions for cross-partition calculations, nor
is it recommended to do so for most large data sets.
</p>
<p>If <code>progressbar = TRUE</code> a text progress bar shows the current status
of the calculations in the console.
</p>


<h3>Value</h3>

<p>a &quot;MC_partGLS&quot;, which is a precursor to a &quot;partGLS&quot; object
</p>
<p>a &quot;partGLS&quot; object
</p>
<p>&quot;partGLS&quot; object
</p>
<p><code>fitGLS_partition</code> returns a list object of class &quot;partGLS&quot; which
contains at least the following elements:
</p>

<dl>
<dt>call</dt><dd><p>the function call</p>
</dd>
<dt>GLS</dt><dd><p>an optional list of &quot;remoteGLS&quot; objects, one for each partition</p>
</dd>
<dt>part</dt><dd><p>statistics calculated from each partition: see below for further
details</p>
</dd>
<dt>cross</dt><dd><p>statistics calculated from each pair of crossed partitions,
determined by <code>ncross</code>: see below for further details</p>
</dd>
<dt>overall</dt><dd><p>summary statistics of the overall model: see below for further
details</p>
</dd>
</dl>

<p><code>part</code> is a sub-list containing the following elements
</p>

<dl>
<dt>coefficients</dt><dd><p>a numeric matrix of GLS coefficients for each partition</p>
</dd>
<dt>SEs</dt><dd><p>a numeric matrix of coefficient standard errors</p>
</dd>
<dt>tstats</dt><dd><p>a numeric matrix of coefficient t-statstitics</p>
</dd>
<dt>pvals_t</dt><dd><p>a numeric matrix of t-test pvalues</p>
</dd>
<dt>nuggets</dt><dd><p>a numeric vector of nuggets for each partition</p>
</dd>
<dt>covar.pars</dt><dd><p><code>covar.pars</code> input vector</p>
</dd>
<dt>modstats</dt><dd><p>a numeric matrix with rows corresponding to partitions and
columns corresponding to log-likelihoods (<code>logLik</code>),
sum of square error (<code>SSE</code>), mean-squared error (<code>MSE</code>),
regression mean-square (<code>MSR</code>), F-statistics (<code>Fstat</code>),
and p-values from F-tests (<code>pval_F</code>)</p>
</dd>
</dl>

<p><code>cross</code> is a sub-list containing the following elements, which are use
to calculate the combined (across partitions) standard errors of the coefficient
estimates and statistical tests. See Ives et al. (2022).
</p>

<dl>
<dt>rcoefs</dt><dd><p>a numeric matrix of cross-partition correlations in the
estimates of the coefficients</p>
</dd>
<dt>rSSRs</dt><dd><p>a numeric vector of cross-partition correlations in the
regression sum of squares</p>
</dd>
<dt>rSSEs</dt><dd><p>a numeric vector of cross-partition correlations in the
sum of squared errors</p>
</dd>
</dl>

<p>and <code>overall</code> is a sub-list containing the elements
</p>

<dl>
<dt>coefficients</dt><dd><p>a numeric vector of the average coefficient estimates
across all partitions</p>
</dd>
<dt>rcoefficients</dt><dd><p>a numeric vector of the average cross-partition
coefficient from across all crosses</p>
</dd>
<dt>rSSR</dt><dd><p>the average cross-partition correlation in the regression
sum of squares</p>
</dd>
<dt>rSSE</dt><dd><p>the average cross-partition correlation in the sum of
squared errors</p>
</dd>
<dt>Fstat</dt><dd><p>the average f-statistic across partitions</p>
</dd>
<dt>dfs</dt><dd><p>degrees of freedom to be used with partitioned GLS f-test</p>
</dd>
<dt>partdims</dt><dd><p>dimensions of <code>partmat</code></p>
</dd>
<dt>pval.chisqr</dt><dd><p>if <code>chisqr.test = TRUE</code>, a p-value for the correlated
chi-squared test</p>
</dd>
<dt>t.test</dt><dd><p>if <code>do.t.test = TRUE</code>, a table with t-test results, including
the coefficient estimates, standard errors, t-statistics, and p-values</p>
</dd>
</dl>

<p><code>part_data</code> and <code>part_csv</code> both return a list with two elements:
</p>

<dl>
<dt>data</dt><dd><p>a dataframe, containing the data subset</p>
</dd>
<dt>coords</dt><dd><p>a coordinate matrix for the subset</p>
</dd>
</dl>



<h3>parallel implementation</h3>

<p>In order to be efficient and account for different user situations, parallel
processing is available natively in <code>fitGLS_partition</code>. There are a few
different specifications that will result in different behavior:
</p>
<p>When <code>parallel = TRUE</code> and <code>ncores &gt; 1</code>, all calculations are done
completely in parallel (via <code>multicore_fitGLS_partition()</code>).
In this case, parallelization is implemented with the
<code>parallel</code>, <code>doParallel</code>, and <code>foreach</code> packages. In this version,
all matrix operations are serialized on each worker but multiple operations
can occur simultaneously..
</p>
<p>When <code>parallel = FALSE</code> and <code>ncores &gt; 1</code>, then most calculations
are done on a single core but matrix opperations use multiple cores. In this
case, <code>ncores</code> is passed to fitGLS. In this option, it is suggested
to not exceed the number of physical cores (not threads).
</p>
<p>When <code>ncores &lt;= 1</code>, then the calculations are completely serialized
</p>
<p>When <code>ncores = NA</code> (the default), only one core is used.
</p>
<p>In the parallel implementation of this function, a progress bar is not possible,
so <code>progressbar</code> is ignored.
</p>


<h3><code>part_FUN</code> details</h3>

<p><code>part_FUN</code> can be any function that satisfies the following criteria
</p>
<p>1. the first argument of <code>part_FUN</code> must accept an index of pixels by which
to subset the data;
</p>
<p>2. <code>part_FUN</code> must also accept <code>formula</code> and <code>formula0</code> from
<code>fitGLS_partition</code>; and
</p>
<p>3. the output of <code>part_FUN</code> must be a list with at least the
following elements, which are passed to <code>fitGLS</code>;
</p>

<dl>
<dt>data</dt><dd><p>a data frame containing all variables given by <code>formula</code>.
Rows should correspond to pixels specified by the first argument</p>
</dd>
<dt>coords</dt><dd><p>a coordinate matrix or data frame. Rows should correspond to
pixels specified by the first argument</p>
</dd>
</dl>

<p>Two functions that satisfy these criteria are provided by <code>remotePARTS</code>:
<code>part_data</code> and <code>part_csv</code>.
</p>
<p><code>part_data</code> uses an in-memory data frame (<code>data</code>)
as a data source. <code>part_csv</code>, instead reads data from a
csv file (<code>file</code>), one partition at a time, for efficient memory usage.
<code>part_csv</code> internally calls <code>sqldf::read.csv.sql()</code> for fast and
efficient row extraction.
</p>
<p>Both functions use <code>index</code> to subset rows of data and <code>formula</code> and
<code>formula0</code> (optional) to determine which variables to select.
</p>
<p>Both functions also use <code>coord.names</code> to indicate which variables contain
spatial coordinates. The name of the x-coordinate column should always preceed
the y-coordinate column: <code>c("x", "y")</code>.
</p>
<p>Users are encouraged to write their own <code>part_FUN</code> functions to meet their
needs. For example, one might be interested in using data stored in a raster
stack or any other file type. In this case, a user-defined <code>part_FUN</code>
function allows access to <code>fitGLS_partition</code> without saving reformatted
copies of data.
</p>


<h3>References</h3>

<p>Ives, A. R., L. Zhu, F. Wang, J. Zhu, C. J. Morrow, and V. C. Radeloff. in review.
Statistical tests for non-independent partitions of large autocorrelated datasets.
MethodsX.
</p>


<h3>See Also</h3>

<p>Other partitionedGLS: 
<code><a href="#topic+crosspart_GLS">crosspart_GLS</a>()</code>,
<code><a href="#topic+sample_partitions">sample_partitions</a>()</code>
</p>
<p>Other partitionedGLS: 
<code><a href="#topic+crosspart_GLS">crosspart_GLS</a>()</code>,
<code><a href="#topic+sample_partitions">sample_partitions</a>()</code>
</p>
<p>Other partitionedGLS: 
<code><a href="#topic+crosspart_GLS">crosspart_GLS</a>()</code>,
<code><a href="#topic+sample_partitions">sample_partitions</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## read data
data(ndvi_AK10000)
df = ndvi_AK10000[seq_len(1000), ] # first 1000 rows

## create partition matrix
pm = sample_partitions(nrow(df), npart = 3)

## fit GLS with fixed nugget
partGLS = fitGLS_partition(formula = CLS_coef ~ 0 + land, partmat = pm,
                           data = df, nugget = 0, do.t.test = TRUE)

## hypothesis tests
chisqr(partGLS) # explanatory power of model
t.test(partGLS) # significance of predictors

## now with a numeric predictor
fitGLS_partition(formula = CLS_coef ~ lat, partmat = pm, data = df, nugget = 0)


## fit ML nugget for each partition (slow)
(partGLS.opt = fitGLS_partition(formula = CLS_coef ~ 0 + land, partmat = pm,
                                data = df, nugget = NA))
partGLS.opt$part$nuggets # ML nuggets

# Certain model structures may not be useful:
## 0 intercept with numeric predictor (produces NAs) and gives a warning in statistical tests
fitGLS_partition(formula = CLS_coef ~ 0 + lat, partmat = pm, data = df, nugget = 0)

## intercept-only, gives warning
fitGLS_partition(formula = CLS_coef ~ 1, partmat = pm, data = df, nugget = 0,
                 do.chisqr.test = FALSE)

## part_data examples
part_data(1:20, CLS_coef ~ 0 + land, data = ndvi_AK10000)


## part_csv examples - ## CAUTION: examples for part_csv() include manipulation side-effects:
# first, create a .csv file from ndviAK
data(ndvi_AK10000)
file.path = file.path(tempdir(), "ndviAK10000-remotePARTS.csv")
write.csv(ndvi_AK10000, file = file.path)

# build a partition from the first 30 pixels in the file
part_csv(1:20, formula = CLS_coef ~ 0 + land, file = file.path)

# now with a random 20 pixels
part_csv(sample(3000, 20), formula = CLS_coef ~ 0 + land, file = file.path)

# remove the example csv file from disk
file.remove(file.path)


</code></pre>

<hr>
<h2 id='ndvi_AK10000'>NDVI remote sensing data for 10,000 random pixels from Alaska, with rare
land classes removed.</h2><span id='topic+ndvi_AK10000'></span>

<h3>Description</h3>

<p>NDVI remote sensing data for 10,000 random pixels from Alaska, with rare
land classes removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ndvi_AK10000
</code></pre>


<h3>Format</h3>

<p>data frame with 10,000 rows corresponding to sites and 37 columns:
</p>

<dl>
<dt>lng</dt><dd><p>longitude of the pixel</p>
</dd>
<dt>lat</dt><dd><p>latitude of the pixel</p>
</dd>
<dt>AR_coef</dt><dd><p>pre-calculated AR REML coefficient standardized by mean ndvi
values for each pixel</p>
</dd>
<dt>CLS_coef</dt><dd><p>pre-calculated CLS coefficient standardized by mean ndvi
values for each pixel</p>
</dd>
<dt>land</dt><dd><p>dominant land class of the pixel</p>
</dd>
<dt>land</dt><dd><p>logical: is this land class rare?</p>
</dd>
<dt>ndvi&lt;t&gt;</dt><dd><p>ndvi value of the pixel during the year &lt;t&gt;</p>
</dd>
</dl>


<hr>
<h2 id='optimize_nugget'>Find the maximum likelihood estimate of the nugget</h2><span id='topic+optimize_nugget'></span>

<h3>Description</h3>

<p>Find the maximum likelihood estimate of the nugget
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimize_nugget(
  X,
  y,
  V,
  lower = 0.001,
  upper = 0.999,
  tol = .Machine$double.eps^0.25,
  debug = FALSE,
  ncores = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optimize_nugget_+3A_x">X</code></td>
<td>
<p>numeric (double) nxp matrix</p>
</td></tr>
<tr><td><code id="optimize_nugget_+3A_y">y</code></td>
<td>
<p>numeric (double) nx1 column vector</p>
</td></tr>
<tr><td><code id="optimize_nugget_+3A_v">V</code></td>
<td>
<p>numeric (double) nxn matrix</p>
</td></tr>
<tr><td><code id="optimize_nugget_+3A_lower">lower</code></td>
<td>
<p>lower boundary for nugget search</p>
</td></tr>
<tr><td><code id="optimize_nugget_+3A_upper">upper</code></td>
<td>
<p>upper boundary for nugget search</p>
</td></tr>
<tr><td><code id="optimize_nugget_+3A_tol">tol</code></td>
<td>
<p>desired accuracy of nugget search</p>
</td></tr>
<tr><td><code id="optimize_nugget_+3A_debug">debug</code></td>
<td>
<p>logical: debug mode?</p>
</td></tr>
<tr><td><code id="optimize_nugget_+3A_ncores">ncores</code></td>
<td>
<p>an optional integer indicating how many CPU threads to use for
matrix calculations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Finds the maximum likelihood nugget estimate via mathematical
optimization.
</p>
<p>To maximize efficiency, <code>optimize_nugget()</code> is implemented entirely
in C++. Optimization takes place via a C++ version of the <code>fmin</code> routine
(Forsythe et al 1977). Translated from http://www.netlib.org/fmm/fmin.f
</p>
<p>The function <code>LogLikGLS()</code> is optimized for <code>nugget</code>. Once the
<code>LogLikGLS()</code> functionality is absorbed by <code>fitGLS()</code>, it will
be used instead.
</p>


<h3>Value</h3>

<p>maximum likelihood nugget estimate
</p>


<h3>See Also</h3>

<p><code>?stats::optimize()</code>
</p>

<hr>
<h2 id='part_chisqr'>Chisqr test for partitioned GLS</h2><span id='topic+part_chisqr'></span>

<h3>Description</h3>

<p>Chisqr test for partitioned GLS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>part_chisqr(Fmean, rSSR, df1, npart)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="part_chisqr_+3A_fmean">Fmean</code></td>
<td>
<p>mean value of F-statistic from correlated F-tests</p>
</td></tr>
<tr><td><code id="part_chisqr_+3A_rssr">rSSR</code></td>
<td>
<p>correlation among partition regression sum of squares</p>
</td></tr>
<tr><td><code id="part_chisqr_+3A_df1">df1</code></td>
<td>
<p>first degree of freedom for F-tests</p>
</td></tr>
<tr><td><code id="part_chisqr_+3A_npart">npart</code></td>
<td>
<p>number of partitions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a p-value for the correlated chisqr test
</p>

<hr>
<h2 id='part_ttest'>Correlated t-test for paritioned GLS</h2><span id='topic+part_ttest'></span>

<h3>Description</h3>

<p>Correlated t-test for paritioned GLS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>part_ttest(coefs, part.covar_coef, rcoefficients, df2, npart)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="part_ttest_+3A_coefs">coefs</code></td>
<td>
<p>vector average GLS coefficients</p>
</td></tr>
<tr><td><code id="part_ttest_+3A_part.covar_coef">part.covar_coef</code></td>
<td>
<p>an array of covar_coef from each partition</p>
</td></tr>
<tr><td><code id="part_ttest_+3A_rcoefficients">rcoefficients</code></td>
<td>
<p>an rcoefficeints array, one for each partition</p>
</td></tr>
<tr><td><code id="part_ttest_+3A_df2">df2</code></td>
<td>
<p>second degree of freedom from partitioned GLS</p>
</td></tr>
<tr><td><code id="part_ttest_+3A_npart">npart</code></td>
<td>
<p>number of partitions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list whose first element is a coefficient table with estimates,
standard errors, t-statistics, and p-values and whose second element is a
matrix of correlations among coefficients.
</p>

<hr>
<h2 id='partGLS_ndviAK'>partitioned GLS results</h2><span id='topic+partGLS_ndviAK'></span>

<h3>Description</h3>

<p>Example output from fitGLS_partition() fit to the <code>ndvi_AK</code> data set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partGLS_ndviAK
</code></pre>


<h3>Format</h3>

<p>an S3 class &quot;partGLS&quot; object. See ?fitGLS_partition() for further
details
</p>

<hr>
<h2 id='print.partGLS'>S3 print method for &quot;partGLS&quot; objects</h2><span id='topic+print.partGLS'></span>

<h3>Description</h3>

<p>S3 print method for &quot;partGLS&quot; objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'partGLS'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.partGLS_+3A_x">x</code></td>
<td>
<p>&quot;partGLS&quot; object</p>
</td></tr>
<tr><td><code id="print.partGLS_+3A_...">...</code></td>
<td>
<p>additional arguments passed to print</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a print-formatted version of key elements of the &quot;partGLS&quot; object.
</p>

<hr>
<h2 id='print.remoteCor'>S3 print method for &quot;remoteCor&quot; class</h2><span id='topic+print.remoteCor'></span>

<h3>Description</h3>

<p>S3 print method for &quot;remoteCor&quot; class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'remoteCor'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.remoteCor_+3A_x">x</code></td>
<td>
<p>remoteCor object to print</p>
</td></tr>
<tr><td><code id="print.remoteCor_+3A_...">...</code></td>
<td>
<p>additional arguments passed to print()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a print-formatted version of key elements of the &quot;remoteCor&quot; object.
</p>

<hr>
<h2 id='print.remoteGLS'>print method for remoteGLS</h2><span id='topic+print.remoteGLS'></span>

<h3>Description</h3>

<p>print method for remoteGLS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'remoteGLS'
print(x, digits = max(3L, getOption("digits") - 3L), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.remoteGLS_+3A_x">x</code></td>
<td>
<p>remoteGLS object</p>
</td></tr>
<tr><td><code id="print.remoteGLS_+3A_digits">digits</code></td>
<td>
<p>digits to print</p>
</td></tr>
<tr><td><code id="print.remoteGLS_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>formatted output for remoteGLS object
</p>

<hr>
<h2 id='print.remoteTS'>S3 print method for remoteTS class</h2><span id='topic+print.remoteTS'></span><span id='topic+summary.remoteTS'></span><span id='topic+print.mapTS'></span><span id='topic+summary.mapTS'></span><span id='topic+smry_funM'></span><span id='topic+smry_funV'></span>

<h3>Description</h3>

<p>S3 print method for remoteTS class
</p>
<p>S3 summary method for remoteTS class
</p>
<p>S3 print method for mapTS class
</p>
<p>S3 summary method for mapTS class
</p>
<p>helper summary function (matrix)
</p>
<p>helper summary function (vector)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'remoteTS'
print(
  x,
  digits = max(3L, getOption("digits") - 3L),
  signif.stars = getOption("show.signif.stars"),
  ...
)

## S3 method for class 'remoteTS'
summary(
  object,
  digits = max(3L, getOption("digits") - 3L),
  signif.stars = getOption("show.signif.stars"),
  ...
)

## S3 method for class 'mapTS'
print(x, digits = max(3L, getOption("digits") - 3L), ...)

## S3 method for class 'mapTS'
summary(
  object,
  digits = max(3L, getOption("digits") - 3L),
  CL = 0.95,
  na.rm = TRUE,
  ...
)

smry_funM(x, CL = 0.95, na.rm = TRUE)

smry_funV(x, CL = 0.95, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.remoteTS_+3A_x">x</code></td>
<td>
<p>numeric matrix</p>
</td></tr>
<tr><td><code id="print.remoteTS_+3A_digits">digits</code></td>
<td>
<p>significant digits to show</p>
</td></tr>
<tr><td><code id="print.remoteTS_+3A_signif.stars">signif.stars</code></td>
<td>
<p>logical, passed to <code>stats::printCoefmat</code></p>
</td></tr>
<tr><td><code id="print.remoteTS_+3A_...">...</code></td>
<td>
<p>additional parameters passed to further print methods</p>
</td></tr>
<tr><td><code id="print.remoteTS_+3A_object">object</code></td>
<td>
<p>mapTS object</p>
</td></tr>
<tr><td><code id="print.remoteTS_+3A_cl">CL</code></td>
<td>
<p>confidence level (default = .95)</p>
</td></tr>
<tr><td><code id="print.remoteTS_+3A_na.rm">na.rm</code></td>
<td>
<p>logical, should observations with NA be removed?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns formatted output
</p>
<p>returns formatted output, including summary stats
</p>
<p>returns formatted output
</p>
<p>returns formatted summary stats
</p>
<p>summary statistics for each column including quartiles, mean, and
upper and lower confidence levels (given by CL)
</p>
<p>summary statistics including quartiles, mean, and upper and lower
confidence levels (given by CL)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate dummy data
 time.points = 9 # time series length
 map.width = 5 # square map width
 coords = expand.grid(x = 1:map.width, y = 1:map.width) # coordinate matrix
 ## create empty spatiotemporal variables:
 X &lt;- matrix(NA, nrow = nrow(coords), ncol = time.points) # response
 Z &lt;- matrix(NA, nrow = nrow(coords), ncol = time.points) # predictor
 # setup first time point:
 Z[, 1] &lt;- .05*coords[,"x"] + .2*coords[,"y"]
 X[, 1] &lt;- .5*Z[, 1] + rnorm(nrow(coords), 0, .05) #x at time t
 ## project through time:
 for(t in 2:time.points){
   Z[, t] &lt;- Z[, t-1] + rnorm(map.width^2)
   X[, t] &lt;- .2*X[, t-1] + .1*Z[, t] + .05*t + rnorm(nrow(coords), 0 , .25)
 }

 ## Pixel CLS
 tmp.df = data.frame(x = X[1, ], t = nrow(X), z = Z[1, ])
 CLS &lt;- fitCLS(x ~ z, data = tmp.df)
 print(CLS)
 summary(CLS)
 residuals(CLS)
 coef(CLS)
 logLik(CLS)
 fitted(CLS)
 # plot(CLS) # doesn't work

 ## Pixel AR
 AR &lt;- fitAR(x ~ z, data = tmp.df)
 print(AR)
 summary(AR)
 coef(AR)
 residuals(AR)
 logLik(AR)
 fitted(AR)
 # plot(AR) # doesn't work

 ## Map CLS
 CLS.map &lt;- fitCLS_map(X, coords, y ~ Z, X.list = list(Z = Z), lag.x = 0, resids.only = TRUE)
 print(CLS.map)
 summary(CLS.map)
 residuals(CLS.map)
 # plot(CLS.map)# doesn't work

 CLS.map &lt;- fitCLS_map(X, coords, y ~ Z, X.list = list(Z = Z), lag.x = 0, resids.only = FALSE)
 print(CLS.map)
 summary(CLS.map)
 coef(CLS.map)
 residuals(CLS.map)
 # logLik(CLS.map) # doesn't work
 fitted(CLS.map)
 # plot(CLS.map) # doesn't work

 ## Map AR
 AR.map &lt;- fitAR_map(X, coords, y ~ Z, X.list = list(Z = Z), resids.only = TRUE)
 print(AR.map)
 summary(AR.map)
 residuals(AR.map)
 # plot(AR.map)# doesn't work

 AR.map &lt;- fitAR_map(X, coords, y ~ Z, X.list = list(Z = Z), resids.only = FALSE)
 print(AR.map)
 summary(AR.map)
 coef(AR.map)
 residuals(AR.map)
 # logLik(AR.map) # doesn't work
 fitted(AR.map)
 # plot(AR.map) # doesn't work

</code></pre>

<hr>
<h2 id='remoteGLS'>remoteGLS constructor (S3)</h2><span id='topic+remoteGLS'></span>

<h3>Description</h3>

<p>remoteGLS constructor (S3)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remoteGLS(formula, formula0, no.F = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remoteGLS_+3A_formula">formula</code></td>
<td>
<p>optional argument specifying the GLS formula</p>
</td></tr>
<tr><td><code id="remoteGLS_+3A_formula0">formula0</code></td>
<td>
<p>optional argument specifying the null GLS formula</p>
</td></tr>
<tr><td><code id="remoteGLS_+3A_no.f">no.F</code></td>
<td>
<p>optional argument specifying the no.F attribute</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an empty S3 object of class &quot;remoteGLS&quot;
</p>

<hr>
<h2 id='sample_partitions'>Randomly sample a partition matrix for partitioned GLS</h2><span id='topic+sample_partitions'></span>

<h3>Description</h3>

<p>Create a matrix whose columns contain indices of non-overlapping
random samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_partitions(
  npix,
  npart = 10,
  partsize = NA,
  pixels = NA,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_partitions_+3A_npix">npix</code></td>
<td>
<p>number of pixels in full dataset</p>
</td></tr>
<tr><td><code id="sample_partitions_+3A_npart">npart</code></td>
<td>
<p>number of partitions to create</p>
</td></tr>
<tr><td><code id="sample_partitions_+3A_partsize">partsize</code></td>
<td>
<p>size of each partition</p>
</td></tr>
<tr><td><code id="sample_partitions_+3A_pixels">pixels</code></td>
<td>
<p>vector of pixel indexes to sample from</p>
</td></tr>
<tr><td><code id="sample_partitions_+3A_verbose">verbose</code></td>
<td>
<p>logical: TRUE prints additional info</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If both <code>npart</code> and <code>partsize</code> is specified, a partition matrix with
these dimensions is returned. If only <code>npart</code>, is specified,
<code>partsize</code> is selected as the largest integer possible  that creates
equal sized partitions. Similarly, if only <code>npart = NA</code>, then <code>npart</code>
is selected to obtain as many partitions as possible.
</p>


<h3>Value</h3>

<p><code>sample_partitions</code> returns a matrix with <code>partsize</code>
rows and <code>npart</code> columns. Columns contain random, non-overlapping samples
from <code>1:npix</code>
</p>


<h3>See Also</h3>

<p>Other partitionedGLS: 
<code><a href="#topic+MC_GLSpart">MC_GLSpart</a>()</code>,
<code><a href="#topic+crosspart_GLS">crosspart_GLS</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># dummy data with 100 pixels and 20 time points
dat.M &lt;- matrix(rnorm(100*20), ncol = 20)

# 4 partitions (exhaustive)
sample_partitions(npix = nrow(dat.M), npart = 4)

# partitions with 10 pixels each (exhaustive)
sample_partitions(npix = nrow(dat.M), partsize = 10)

# 4 partitions each with 10 pixels (non-exhaustive, produces warning)
sample_partitions(npix = nrow(dat.M), npart = 4, partsize = 10)

# index of 50 pixels to use as subset
sub.indx &lt;- c(1:10, 21:25, 30:62, 70:71)

# 5 partitions (exhaustive) from only the specified pixel subset
sample_partitions(npix = nrow(dat.M), npart = 5, pixels = sub.indx)

</code></pre>

<hr>
<h2 id='t.test.partGLS'>Conduct a t-test of &quot;partGLS&quot; object</h2><span id='topic+t.test.partGLS'></span>

<h3>Description</h3>

<p>Conduct a correlated t-test of a partitioned GLS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'partGLS'
t.test(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="t.test.partGLS_+3A_x">x</code></td>
<td>
<p>&quot;partGLS&quot; object</p>
</td></tr>
<tr><td><code id="t.test.partGLS_+3A_...">...</code></td>
<td>
<p>additional arguments passed to print</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list whose first element is a coefficient table with estimates,
standard errors, t-statistics, and p-values and whose second element is a
matrix of correlations among coefficients.
</p>

<hr>
<h2 id='test_covar_fun'>Test passing a covariance function and arguments</h2><span id='topic+test_covar_fun'></span>

<h3>Description</h3>

<p>Test passing a covariance function and arguments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_covar_fun(d, covar_FUN = "covar_exppow", covar.pars = list(range = 0.5))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test_covar_fun_+3A_d">d</code></td>
<td>
<p>numeric vector or matrix of distances</p>
</td></tr>
<tr><td><code id="test_covar_fun_+3A_covar_fun">covar_FUN</code></td>
<td>
<p>distance-based covariance function to use,
which must take <code>d</code> as its first argument</p>
</td></tr>
<tr><td><code id="test_covar_fun_+3A_covar.pars">covar.pars</code></td>
<td>
<p>vector or list of parameters (other than d) passed to the
covar function</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
