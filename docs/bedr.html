<!DOCTYPE html><html lang="en"><head><title>Help for package bedr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bedr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bedr-package'>
<p>A bedtools wrapper for working with genomic ranges in R</p></a></li>
<li><a href='#+25in.region+25'>
<p>checks if regions in object a are found in object b</p></a></li>
<li><a href='#bed2index'>
<p>bed dataframe to index string</p></a></li>
<li><a href='#bed2vcf'>
<p>convert bed to vcf</p></a></li>
<li><a href='#bedr'>
<p>Main bedtools wrapper function.</p></a></li>
<li><a href='#bedr.join.multiple.region'>
<p>join multiple region objects</p></a></li>
<li><a href='#bedr.join.region'>
<p>join two region objects using a left outer join</p></a></li>
<li><a href='#bedr.merge.region'>
<p>merge i.e. collapse overlpaping regions</p></a></li>
<li><a href='#bedr.plot.region'>
<p>Visualize regions or intervals</p></a></li>
<li><a href='#bedr.setup'>
<p>Initialize some config settings for bedr</p></a></li>
<li><a href='#bedr.snm.region'>
<p>sort a region file</p></a></li>
<li><a href='#bedr.sort.region'>
<p>sort a region file</p></a></li>
<li><a href='#bedr.subtract.region'>
<p>subtracts features or ranges in object b from object a</p></a></li>
<li><a href='#catv'>
<p>outputs text if verbose flag is set</p></a></li>
<li><a href='#check.binary'>
<p>checks if binary is in the path</p></a></li>
<li><a href='#cluster.region'>
<p>cluster intervals</p></a></li>
<li><a href='#convert2bed'>
<p>convert object to bed format</p></a></li>
<li><a href='#create.tmp.bed.file'>
<p>output R objects as tmpfiles</p></a></li>
<li><a href='#determine.input'>
<p>Determine input format</p></a></li>
<li><a href='#df2list'>
<p>Data frame to list conversion</p></a></li>
<li><a href='#download.datasets'>
<p>Download some useful datasets</p></a></li>
<li><a href='#flank.region'>
<p>Get adjacent flanks from regions</p></a></li>
<li><a href='#get.chr.length'>
<p>gets the length of each chromosome for a species/build</p></a></li>
<li><a href='#get.example.regions'>
<p>return a set of regions for the examples and unit testing</p></a></li>
<li><a href='#get.fasta'>
<p>Query fasta sequence</p></a></li>
<li><a href='#get.random.regions'>
<p>generates a set of random regions</p></a></li>
<li><a href='#grow.region'>
<p>Get adjacent flanks from regions</p></a></li>
<li><a href='#in.region'>
<p>checks if regions in object a are found in object b</p></a></li>
<li><a href='#index2bed'>
<p>convert a region index into a bed file dataframe</p></a></li>
<li><a href='#is.merged.region'>
<p>checks if region file is merged</p></a></li>
<li><a href='#is.sorted.region'>
<p>checks if region file is sorted</p></a></li>
<li><a href='#is.valid.ref'>
<p>verifies the reference sequence in a vcf</p></a></li>
<li><a href='#is.valid.region'>
<p>checks if region/index is valid</p></a></li>
<li><a href='#is.valid.seq'>
<p>verifies that sequences are correct given coordinates and a reference</p></a></li>
<li><a href='#jaccard'>
<p>calculate the jaccard distance between sets of intervals</p></a></li>
<li><a href='#modifyList2'>
<p>Interface to R's modifyList</p></a></li>
<li><a href='#order.region'>
<p>Gets the sort order of a region index similar to the order command</p></a></li>
<li><a href='#permute.region'>
<p>permute a set of regions</p></a></li>
<li><a href='#process.input'>
<p>process.input</p></a></li>
<li><a href='#query.ucsc'>
<p>read a ucsc table into R</p></a></li>
<li><a href='#read.vcf'>
<p>Read a vcf into R</p></a></li>
<li><a href='#reldist'>
<p>Calculate the relative distance between two sets of intervals</p></a></li>
<li><a href='#size.region'>
<p>Get region size</p></a></li>
<li><a href='#strsplit2matrix'>
<p>split a vector of strings into tabular data</p></a></li>
<li><a href='#tabix'>
<p>Main bedtools wrapper function.</p></a></li>
<li><a href='#table2venn'>
<p>Plot venn diagram</p></a></li>
<li><a href='#test.region.similarity'>
<p>Compare sets of regions via jaccard and relative distance using permutation</p></a></li>
<li><a href='#vcf2bed'>
<p>convert a vcf to a bed file</p></a></li>
<li><a href='#write.vcf'>
<p>write a vcf object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Genomic Region Processing using Tools Such as 'BEDTools',
'BEDOPS' and 'Tabix'</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-04-01</td>
</tr>
<tr>
<td>Author:</td>
<td>Syed Haider [aut],
  Daryl Waggott [aut],
  Emilie Lalonde [ctb],
  Clement Fung [ctb],
  Paul C. Boutros [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paul C. Boutros &lt;pboutros@mednet.ucla.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Genomic regions processing using open-source command line tools such as 'BEDTools', 'BEDOPS' and 'Tabix'. 
  These tools offer scalable and efficient utilities to perform genome arithmetic e.g indexing, formatting and merging.
  bedr API enhances access to these tools as well as offers additional utilities for genomic regions processing.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>Preferred genomic operations engine: 'BEDTools',
'BEDOPS' and 'Tabix (&gt;= 1.3)'.</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr (&ge; 1.4), rmarkdown (&ge; 0.9.5)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>testthat (&ge; 0.7.1), VennDiagram (&ge; 1.6.4), data.table (&ge;
1.8.11), R.utils (&ge; 2.0.2), yaml (&ge; 2.1.10), parallel, grid</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-04-01 18:15:47 UTC; shaider</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-04-01 18:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bedr-package'>
A bedtools wrapper for working with genomic ranges in R
</h2><span id='topic+bedr-package'></span>

<h3>Description</h3>

<p>A bedtools wrapper that allows using a mix of internal R objects and external R files.  A number of convenience functions are provided for simplifying analysis workflows in R.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> bedr</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0.4</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2016-09-19</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL2</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Daryl Waggott<br />
Syed Haider
</p>

<hr>
<h2 id='+25in.region+25'>
checks if regions in object a are found in object b
</h2><span id='topic++25in.region+25'></span>

<h3>Description</h3>

<p>checks if regions in object a are found in object b
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %in.region% y
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25in.region+2B25_+3A_x">x</code></td>
<td>
<p>first region index in the form chr:start-stop.  regions in this index will be checked for intersection in the values of the second index.</p>
</td></tr>
<tr><td><code id="+2B25in.region+2B25_+3A_y">y</code></td>
<td>
<p>second region index.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function can also be called using syntax similar to the %in% operator, for example &quot;region1 %in.region% region2&quot;
</p>


<h3>Value</h3>

<p>Returns a logical vector the length of x.
</p>


<h3>Author(s)</h3>

<p>Daryl Waggott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (check.binary("bedtools")) {

index &lt;- get.example.regions();

a &lt;- index[[1]];
b &lt;- index[[2]];
a &lt;- bedr.sort.region(a);
b &lt;- bedr.sort.region(b);

d &lt;- a %in.region% b

}
</code></pre>

<hr>
<h2 id='bed2index'>
bed dataframe to index string
</h2><span id='topic+bed2index'></span>

<h3>Description</h3>

<p>convert a dataframe in bed format to an index string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bed2index(x, sort = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bed2index_+3A_x">x</code></td>
<td>
<p>a object region object or index</p>
</td></tr>
<tr><td><code id="bed2index_+3A_sort">sort</code></td>
<td>
<p>should the index be sorted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of string based genomic regions
</p>


<h3>Author(s)</h3>

<p>Daryl Waggott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
test.regions &lt;- get.random.regions(10);
bed2index(test.regions);
</code></pre>

<hr>
<h2 id='bed2vcf'>
convert bed to vcf
</h2><span id='topic+bed2vcf'></span>

<h3>Description</h3>

<p>convert bed to vcf
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bed2vcf(x, filename = NULL, zero.based = TRUE, header = NULL, fasta = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bed2vcf_+3A_x">x</code></td>
<td>

<p>the input bed object
</p>
</td></tr>
<tr><td><code id="bed2vcf_+3A_filename">filename</code></td>
<td>

<p>a filename to write to.
</p>
</td></tr>
<tr><td><code id="bed2vcf_+3A_zero.based">zero.based</code></td>
<td>

<p>is the file zero based i.e. bed format.  defaults to true.
</p>
</td></tr>
<tr><td><code id="bed2vcf_+3A_header">header</code></td>
<td>

<p>a list of things to put in the header.  repeated elements such as INFO, FILTER, FORMAT can be put in data.frames.
</p>
</td></tr>
<tr><td><code id="bed2vcf_+3A_fasta">fasta</code></td>
<td>

<p>build of the genome in fasta format
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daryl Waggott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  bed2vcf(x)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='bedr'>
Main bedtools wrapper function.
</h2><span id='topic+bedr'></span>

<h3>Description</h3>

<p>Main bedtools wrapper function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bedr(engine = "bedtools", 
	params = NULL,
	input = list(),
	method = NULL,
	tmpDir = NULL,
	deleteTmpDir = TRUE,
	outputDir = NULL,
	outputFile = NULL,
	check.chr = TRUE,
	check.zero.based = TRUE,
	check.valid = TRUE,
	check.sort = TRUE,
	check.merge = TRUE,
	verbose = TRUE
	);

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bedr_+3A_engine">engine</code></td>
<td>
<p>What analytical engine to use i.e. bedtools, bedops, tabix, unix</p>
</td></tr>
<tr><td><code id="bedr_+3A_params">params</code></td>
<td>
<p>A string that includes all the extra parameters and arguments to the bedtools commmand.  For example if you wanted to do a left outer join you would specificy method as intersect and use params = c(&quot;-loj -header&quot;). If you leave input and method as defaults then this is this string represents the full command.</p>
</td></tr>
<tr><td><code id="bedr_+3A_input">input</code></td>
<td>
<p>A list of input items to be used by bedtools.  Each item should be named by its parameter name in bedtools for example input = list(a=xxx, b=yyy, i=zzz).  Items can be R objects or external files.  R objects need to be in bed format i.e. have chr, start, stop as the first three columns, or, have an position index as the first column or rowname i.e. chr1:100-1000.</p>
</td></tr>
<tr><td><code id="bedr_+3A_method">method</code></td>
<td>
<p>What bedtools method.  This can be intersect, sort, merge etc.  See bedtools documentation for specifcis.</p>
</td></tr>
<tr><td><code id="bedr_+3A_tmpdir">tmpDir</code></td>
<td>
<p>The directory to be used for writing files</p>
</td></tr>
<tr><td><code id="bedr_+3A_deletetmpdir">deleteTmpDir</code></td>
<td>
<p>Should tmp files be deleted.  helpful for diagnostics.</p>
</td></tr>
<tr><td><code id="bedr_+3A_outputdir">outputDir</code></td>
<td>
<p>The output directory.  Only used if outputFile is specified.  It defaults to the current working directory.</p>
</td></tr>
<tr><td><code id="bedr_+3A_outputfile">outputFile</code></td>
<td>
<p>The name of the output file.  If this is specified the output will be sent to a file not an R object</p>
</td></tr>
<tr><td><code id="bedr_+3A_check.chr">check.chr</code></td>
<td>
<p>check for chr prefix</p>
</td></tr>
<tr><td><code id="bedr_+3A_check.zero.based">check.zero.based</code></td>
<td>
<p>check for zero based coordinates</p>
</td></tr>
<tr><td><code id="bedr_+3A_check.valid">check.valid</code></td>
<td>
<p>do all region integrity checks</p>
</td></tr>
<tr><td><code id="bedr_+3A_check.sort">check.sort</code></td>
<td>
<p>check if region is sorted</p>
</td></tr>
<tr><td><code id="bedr_+3A_check.merge">check.merge</code></td>
<td>
<p>check if region is  merged</p>
</td></tr>
<tr><td><code id="bedr_+3A_verbose">verbose</code></td>
<td>
<p>Should messages be printed to screen.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output of command with some parsing to keep it consistent with the input. 
</p>


<h3>Author(s)</h3>

<p>Daryl Waggott
</p>


<h3>See Also</h3>

<p>iranges
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (check.binary("bedtools")) {
set.seed(666)

index &lt;- get.example.regions();
a &lt;- index[[1]];
b &lt;- index[[2]];

### check
is.a.valid  &lt;- is.valid.region(a);
is.b.valid  &lt;- is.valid.region(b);
a &lt;- a[is.a.valid];
b &lt;- b[is.b.valid];

### sort
is.sorted &lt;- is.sorted.region(a);
a.sort1 &lt;- bedr(engine = "bedtools", input = list(i = a), method = "sort", params = "");
b.sort1 &lt;- bedr(engine = "bedtools", input = list(i = b), method = "sort", params = "");
a.sort2 &lt;- bedr(engine = "bedops",   input = list(i = a), method = "sort", params = "");

a.sort3 &lt;- bedr.sort.region(a);
a.sort4 &lt;- bedr.sort.region(a, engine = "unix", method = "natural");
a.sort5 &lt;- bedr.sort.region(a, engine = "R", method = "natural");

### merge
is.merged &lt;- is.merged.region(a.sort1);
a.merge1 &lt;- bedr(engine = "bedtools", input = list(i = a.sort1), method = "merge", params = "");
b.merge1 &lt;- bedr(engine = "bedtools", input = list(i = b.sort1), method = "merge", params = "");
a.merge2 &lt;- bedr(engine = "bedops",   input = list(i = a.sort1), method = "merge", params = "");
# a.merge3 &lt;- bedr.merge.region(a); this will throw an error b/c region is not sorted

### subtract
a.sub1 &lt;- bedr(input = list(a = a.merge1, b = b.merge1), method = "subtract", params="");
a.sub2 &lt;- bedr.subtract.region(a.merge1, b.merge1);

### in.region
is.region &lt;- in.region(a.merge1, b.merge1);
#is.region &lt;- a.merge1 %in.region% b.merge1
### intersect 
# note for bedtools its recommended to bedr.sort.regions before intersect for faster processing
# also if regions are not merged this can cause unexpected behaviour
a.int1 &lt;- bedr(input = list(a = a.sort1, b = b.sort1), method = "intersect", params = "-loj");
a.int1 &lt;- bedr(input = list(a = a.sort1, b = b.sort1), method="intersect",params ="-loj -sorted");
a.int2 &lt;- bedr(input = list(a = a.merge1, b = b.merge1), method="intersect",params="-loj -sorted");
a.int3 &lt;- bedr.join.region(a.merge1, b.merge1);

### multiple join
d &lt;- get.random.regions(100, chr="chr1", sort = TRUE);
a.mult &lt;- bedr.join.multiple.region(x = list(a.merge1,b.merge1,bedr.sort.region(d)));

## Not run: 
  ### groupby 
  # note the "g" column number is based on bed format i.e. first three columns chr, start, stop
  # note the use of first, first, last on the region columns i.e. the union of the regions
  # note currently missing values are not dealt with in bedtools.  also the 5th column is 
  # assumed to be "score" and gets a default "-1" not a "."
  cnv.gene &lt;- bedr(
    input = list(i=cnv.gene), method = "groupby", params = paste(
      "-g 16 -c ", 
      paste(1:15, collapse = ","), 
      " -o ", "first,first,last, ", 
      paste(rep("sum",12), collapse = ","), 
      sep = ""
      )
    );

  ### example 1
  ###  workflow adding gene names to exome sequencing target file
  # download refseq genes from ucsc or query biomart for ensemble gene names.  
  # format them in basic bed format.
  # sort, merge target
  # sort, merge -nms target.  Overlapping genes/features get merged.  
  # this may not be ideal if there are some really big features.
  # intersect -loj target, genes.
  # alternatively, do not merge the target and apply the merge after the intersect.  
  # this will provide precision at the level of the exon.
  
## End(Not run)
}
</code></pre>

<hr>
<h2 id='bedr.join.multiple.region'>
join multiple region objects
</h2><span id='topic+bedr.join.multiple.region'></span>

<h3>Description</h3>

<p>join multiple objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bedr.join.multiple.region(
	x = list(),
	fraction.overlap = 1/1e9,
	empty = FALSE,
	missing.values = ".",
	cluster = FALSE,
	species = "human",
	build = "hg19",
	check.zero.based = TRUE,
	check.chr = TRUE,
	check.valid = TRUE,
	check.sort = TRUE,
	check.merge = TRUE,
	verbose = TRUE
	)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bedr.join.multiple.region_+3A_x">x</code></td>
<td>
<p> list of region objects</p>
</td></tr>
<tr><td><code id="bedr.join.multiple.region_+3A_fraction.overlap">fraction.overlap</code></td>
<td>
<p>proportion of bases to be considered an overlap</p>
</td></tr>
<tr><td><code id="bedr.join.multiple.region_+3A_empty">empty</code></td>
<td>
<p>print rows if no match</p>
</td></tr>
<tr><td><code id="bedr.join.multiple.region_+3A_missing.values">missing.values</code></td>
<td>
<p>missing value character</p>
</td></tr>
<tr><td><code id="bedr.join.multiple.region_+3A_cluster">cluster</code></td>
<td>
<p>TRUE/FALSE for clustering</p>
</td></tr>
<tr><td><code id="bedr.join.multiple.region_+3A_species">species</code></td>
<td>
<p>species i.e. human or mouse</p>
</td></tr>
<tr><td><code id="bedr.join.multiple.region_+3A_build">build</code></td>
<td>
<p>genome build to use for empty regions</p>
</td></tr>
<tr><td><code id="bedr.join.multiple.region_+3A_check.zero.based">check.zero.based</code></td>
<td>
<p>should 0 based coordinates be checked</p>
</td></tr>
<tr><td><code id="bedr.join.multiple.region_+3A_check.chr">check.chr</code></td>
<td>
<p>should chr prefix be checked</p>
</td></tr>
<tr><td><code id="bedr.join.multiple.region_+3A_check.valid">check.valid</code></td>
<td>
<p>check if region is valid</p>
</td></tr>
<tr><td><code id="bedr.join.multiple.region_+3A_check.sort">check.sort</code></td>
<td>
<p>check if region is sorted</p>
</td></tr>
<tr><td><code id="bedr.join.multiple.region_+3A_check.merge">check.merge</code></td>
<td>
<p>check if overlapping regions are merged</p>
</td></tr>
<tr><td><code id="bedr.join.multiple.region_+3A_verbose">verbose</code></td>
<td>
<p>messages and checks</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daryl Waggott
</p>


<h3>References</h3>

<p><a href="http://bedtools.readthedocs.org/en/latest/content/tools/multiinter.html">http://bedtools.readthedocs.org/en/latest/content/tools/multiinter.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (check.binary("bedtools")) {

index &lt;- get.example.regions();

a &lt;- index[[1]];
b &lt;- index[[2]];

a.sort &lt;- bedr.sort.region(a);
b.sort &lt;- bedr.sort.region(b);
d &lt;- get.random.regions(100, chr="chr1", sort = TRUE);

a.mult &lt;- bedr.join.multiple.region(x = list(a.sort,b.sort,bedr.sort.region(d)));
}
</code></pre>

<hr>
<h2 id='bedr.join.region'>
join two region objects using a left outer join
</h2><span id='topic+bedr.join.region'></span>

<h3>Description</h3>

<p>join two region objects using a left outer join
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bedr.join.region(
	x,
	y,
	fraction.overlap = 1/1e9,
	reciporical = FALSE,
	report.n.overlap = FALSE,
	check.zero.based = TRUE,
	check.chr = TRUE,
	check.valid = TRUE,
	check.sort = TRUE,
	check.merge = TRUE,
	verbose = TRUE
	)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bedr.join.region_+3A_x">x</code></td>
<td>
<p> object a</p>
</td></tr>
<tr><td><code id="bedr.join.region_+3A_y">y</code></td>
<td>
<p> object b</p>
</td></tr>
<tr><td><code id="bedr.join.region_+3A_fraction.overlap">fraction.overlap</code></td>
<td>
<p>proportion of overlap to be considered a match</p>
</td></tr>
<tr><td><code id="bedr.join.region_+3A_report.n.overlap">report.n.overlap</code></td>
<td>
<p>should the number of overlapping bases be reported</p>
</td></tr>
<tr><td><code id="bedr.join.region_+3A_reciporical">reciporical</code></td>
<td>
<p>should the fraction overlap be applied to object b as well</p>
</td></tr>
<tr><td><code id="bedr.join.region_+3A_check.zero.based">check.zero.based</code></td>
<td>
<p>should 0 based coordinates be checked</p>
</td></tr>
<tr><td><code id="bedr.join.region_+3A_check.chr">check.chr</code></td>
<td>
<p>should chr prefix be checked</p>
</td></tr>
<tr><td><code id="bedr.join.region_+3A_check.valid">check.valid</code></td>
<td>
<p>check if region is valid</p>
</td></tr>
<tr><td><code id="bedr.join.region_+3A_check.sort">check.sort</code></td>
<td>
<p>check if region is sorted</p>
</td></tr> 
<tr><td><code id="bedr.join.region_+3A_check.merge">check.merge</code></td>
<td>
<p>check if overlapping regions are merged</p>
</td></tr> 
<tr><td><code id="bedr.join.region_+3A_verbose">verbose</code></td>
<td>
<p>messages and checks</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daryl Waggott
</p>


<h3>References</h3>

<p><a href="http://bedtools.readthedocs.org/en/latest/content/tools/intersect.html">http://bedtools.readthedocs.org/en/latest/content/tools/intersect.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (check.binary("bedtools")) {

index &lt;- get.example.regions();

a &lt;- index[[1]];
b &lt;- index[[2]];

a.sort &lt;- bedr.sort.region(a);
b.sort &lt;- bedr.sort.region(b);

d &lt;- bedr.join.region(a.sort, b.sort);
}
</code></pre>

<hr>
<h2 id='bedr.merge.region'>
merge i.e. collapse overlpaping regions
</h2><span id='topic+bedr.merge.region'></span>

<h3>Description</h3>

<p>merge i.e. collapse overlpaping regions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bedr.merge.region(
	x,
	distance = 0,
	list.names = TRUE,
	number = FALSE,
	stratify.by = NULL,
	check.zero.based = TRUE,
	check.chr = TRUE,
	check.valid = TRUE,
	check.sort = TRUE,
	verbose = TRUE
	);
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bedr.merge.region_+3A_x">x</code></td>
<td>
<p> input </p>
</td></tr>
<tr><td><code id="bedr.merge.region_+3A_distance">distance</code></td>
<td>
<p> maximum distance between regions to be merged.  defaults to 0 which means overlapping or bookended features. note that you can use negative distances to enforce a minimum overlap. </p>
</td></tr>
<tr><td><code id="bedr.merge.region_+3A_list.names">list.names</code></td>
<td>
<p> output list of names for merged items</p>
</td></tr>
<tr><td><code id="bedr.merge.region_+3A_number">number</code></td>
<td>
<p> output number of merged items </p>
</td></tr>
<tr><td><code id="bedr.merge.region_+3A_stratify.by">stratify.by</code></td>
<td>
<p>a column name indicating the groups to stratify merging within i.e. gene name.  merging will not happen between groups.</p>
</td></tr>
<tr><td><code id="bedr.merge.region_+3A_check.zero.based">check.zero.based</code></td>
<td>
<p>should 0 based coordinates be checked</p>
</td></tr>
<tr><td><code id="bedr.merge.region_+3A_check.chr">check.chr</code></td>
<td>
<p>should chr prefix be checked</p>
</td></tr>
<tr><td><code id="bedr.merge.region_+3A_check.valid">check.valid</code></td>
<td>
<p>should the region be checkded for integerity</p>
</td></tr>
<tr><td><code id="bedr.merge.region_+3A_check.sort">check.sort</code></td>
<td>
<p> should the sort order be checked</p>
</td></tr>
<tr><td><code id="bedr.merge.region_+3A_verbose">verbose</code></td>
<td>
<p>should log messages and checking take place</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daryl Waggott
</p>


<h3>References</h3>

<p><a href="http://bedtools.readthedocs.org/en/latest/content/tools/merge.html">http://bedtools.readthedocs.org/en/latest/content/tools/merge.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (check.binary("bedtools")) {

index &lt;- get.example.regions();

a &lt;- index[[1]];

a.sort   &lt;- bedr.sort.region(a);
a.merged &lt;- bedr.merge.region(a.sort);

}
</code></pre>

<hr>
<h2 id='bedr.plot.region'>
Visualize regions or intervals
</h2><span id='topic+bedr.plot.region'></span>

<h3>Description</h3>

<p>Visualize regions or intervals.  e.g. VennDiagrams of intersections of distinct intervals, base pairs and genes. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bedr.plot.region(
	input,
	filename = NULL,
	type = "venn",
	feature = "interval",
	fraction.overlap = 0.000000001,
	group = NULL,
	params = list(),
	verbose = TRUE
	)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bedr.plot.region_+3A_input">input</code></td>
<td>
 
<p>A list of input regions or indices
</p>
</td></tr>
<tr><td><code id="bedr.plot.region_+3A_filename">filename</code></td>
<td>

<p>The name of the output image file
</p>
</td></tr>
<tr><td><code id="bedr.plot.region_+3A_type">type</code></td>
<td>

<p>The type of plot. only 'venn' is supported for intersections at the moment.
</p>
</td></tr>
<tr><td><code id="bedr.plot.region_+3A_feature">feature</code></td>
<td>

<p>How should the regions be intersected.  By unique &quot;interval&quot;, &quot;gene&quot;, &quot;size&quot; or &quot;other&quot; to use the features in the first item in the input list.
</p>
</td></tr>
<tr><td><code id="bedr.plot.region_+3A_fraction.overlap">fraction.overlap</code></td>
<td>

<p>Minimum overlap required as a fraction of A. Default is 1E-9 (i.e. 1bp).
</p>
</td></tr>
<tr><td><code id="bedr.plot.region_+3A_group">group</code></td>
<td>

<p>A grouping parameter for barplots.  Possible values include &quot;input&quot;, &quot;chr&quot;, or a categorical vector of length equal to the sum of the input.
</p>
</td></tr>
<tr><td><code id="bedr.plot.region_+3A_params">params</code></td>
<td>

<p>Additional parameters for plotting or intersecting.  See <code><a href="VennDiagram.html#topic+venn.diagram">venn.diagram</a></code> function for possible options.
</p>
</td></tr>
<tr><td><code id="bedr.plot.region_+3A_verbose">verbose</code></td>
<td>

<p>Include text messages.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default a venn diagram is output.  If a single input is used then the plot shows the number of unique and collapsed regions after applying a merge.
</p>


<h3>Value</h3>

<p>Plots!
</p>


<h3>Author(s)</h3>

<p>Daryl Waggott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (check.binary("bedtools")) {
	# example data
	a &lt;- get.random.regions(n = 1000, chr = "chr22", size.mean = 10)
	b &lt;- get.random.regions(n = 1000, chr = "chr22", size.mean = 10)
	d &lt;- get.random.regions(n = 1000, chr = "chr22", size.mean = 10)
	e &lt;- get.random.regions(n = 1000, chr = "chr22", size.mean = 10)
	f &lt;- get.random.regions(n = 1000, chr = "chr22", size.mean = 10)

	pdf("bedr.plot.region.ex.pdf")

	# basic venn diagrams
	bedr.plot.region(input = list(a=a,b=b))
	bedr.plot.region(input = list(a=a,b=b,d=d))
	#bedr.plot.region(input = list(a=a,b=b,d=d,e=e))
	#bedr.plot.region(input = list(a=a,b=b,d=d,e=e,f=f))

	### change venn parameters
	bedr.plot.region(
		input = list(a=a,b=b,d=d),
		params = list(lty = 2, label.col = "black", main = "Region Overlap")
		)

	### try with different 
	#bedr.plot.region(input = list(a=a,b=b), feature = "gene")
	#bedr.plot.region(input = list(a=a,b=b), feature = "reference")
	#bedr.plot.region(input = list(a=a,b=b), feature = "interval")
	#bedr.plot.region(input = list(a=a,b=b), feature = "cluster")
	#bedr.plot.region(input = list(a=a,b=b), feature = "bp")

	dev.off()
	}
</code></pre>

<hr>
<h2 id='bedr.setup'>
Initialize some config settings for bedr
</h2><span id='topic+bedr.setup'></span>

<h3>Description</h3>

<p>Initialize some config settings for bedr. This includes downloading useful datasets if requested.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bedr.setup(datasets = "all", data.dir = paste0(Sys.getenv("HOME"), "/bedr/data"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bedr.setup_+3A_datasets">datasets</code></td>
<td>
<p>A list of datasets to download.  Defaults to &quot;all&quot; i.e. c(&quot;refgene&quot;,&quot;hg19&quot;,&quot;b37&quot;,&quot;hugo&quot;, &quot;cosmic&quot;,&quot;clinvar&quot;)</p>
</td></tr>
<tr><td><code id="bedr.setup_+3A_data.dir">data.dir</code></td>
<td>
<p>A directory to put the data.  Defaults to ~/bedr/data</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default config file is at ~/bedr/config.yml.  It's in yaml format.
</p>


<h3>Author(s)</h3>

<p>Daryl Waggott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  bedr.setup()
  
## End(Not run)
</code></pre>

<hr>
<h2 id='bedr.snm.region'>
sort a region file
</h2><span id='topic+bedr.snm.region'></span>

<h3>Description</h3>

<p>Sort and merge regions object in one step
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bedr.snm.region(
	x,
	method = "lexicographical",
	distance = 0,
	list.names = TRUE,
	number = FALSE,
	check.zero.based = TRUE,
	check.chr = TRUE,
	check.valid = TRUE,
	verbose = TRUE
	)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bedr.snm.region_+3A_x">x</code></td>
<td>
<p> a object region object or index</p>
</td></tr>
<tr><td><code id="bedr.snm.region_+3A_method">method</code></td>
<td>
<p>natural or lexicographic</p>
</td></tr>
<tr><td><code id="bedr.snm.region_+3A_distance">distance</code></td>
<td>
<p> distance between regions to be merged</p>
</td></tr>
<tr><td><code id="bedr.snm.region_+3A_list.names">list.names</code></td>
<td>
<p> output list of names for merged items</p>
</td></tr>
<tr><td><code id="bedr.snm.region_+3A_number">number</code></td>
<td>
<p> output number of merged items </p>
</td></tr>
<tr><td><code id="bedr.snm.region_+3A_check.zero.based">check.zero.based</code></td>
<td>
<p>should 0 based coordinates be checked</p>
</td></tr>
<tr><td><code id="bedr.snm.region_+3A_check.chr">check.chr</code></td>
<td>
<p>should chr prefix be checked</p>
</td></tr>
<tr><td><code id="bedr.snm.region_+3A_check.valid">check.valid</code></td>
<td>
<p>should the region be checkded for integerity</p>
</td></tr>
<tr><td><code id="bedr.snm.region_+3A_verbose">verbose</code></td>
<td>
<p>should log messages and checking take place</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sorted and merged regions object 
</p>


<h3>Author(s)</h3>

<p>Daryl Waggott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (check.binary("bedtools")) {

index &lt;- get.example.regions();

a &lt;- index[[1]];

b &lt;- bedr.snm.region(a);

}
</code></pre>

<hr>
<h2 id='bedr.sort.region'>
sort a region file
</h2><span id='topic+bedr.sort.region'></span>

<h3>Description</h3>

<p>sort a region file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bedr.sort.region(
	x,
	method = "lexicographical",
	engine = "R",
	chr.to.num = c("X" = 23, "Y" = 24, "M" = 25),
	check.zero.based = TRUE,
	check.chr = TRUE,
	check.valid = TRUE,
	check.merge = TRUE,
	verbose = TRUE
	)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bedr.sort.region_+3A_x">x</code></td>
<td>
<p>a region object or index</p>
</td></tr>
<tr><td><code id="bedr.sort.region_+3A_method">method</code></td>
<td>
<p>natural or lexicographic</p>
</td></tr>
<tr><td><code id="bedr.sort.region_+3A_engine">engine</code></td>
<td>
<p>what analytical engine to use for sorting i.e. bedtools, bedops, gnu unix</p>
</td></tr>
<tr><td><code id="bedr.sort.region_+3A_chr.to.num">chr.to.num</code></td>
<td>
<p>chromosome letter names to numbers map. Defaults to Homo sapiens i.e c(&quot;X&quot; = 23, &quot;Y&quot; = 24, &quot;M&quot; = 25)</p>
</td></tr>
<tr><td><code id="bedr.sort.region_+3A_check.zero.based">check.zero.based</code></td>
<td>
<p>should 0 based coordinates be checked</p>
</td></tr>
<tr><td><code id="bedr.sort.region_+3A_check.chr">check.chr</code></td>
<td>
<p>should chr prefix be checked</p>
</td></tr>
<tr><td><code id="bedr.sort.region_+3A_check.valid">check.valid</code></td>
<td>
<p>should the region be checked for integerity</p>
</td></tr>
<tr><td><code id="bedr.sort.region_+3A_check.merge">check.merge</code></td>
<td>
<p> should overlapping regions be checked</p>
</td></tr>
<tr><td><code id="bedr.sort.region_+3A_verbose">verbose</code></td>
<td>
<p>should log messages and checking take place</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daryl Waggott
</p>


<h3>References</h3>

<p><a href="http://bedtools.readthedocs.org/en/latest/content/tools/sort.html">http://bedtools.readthedocs.org/en/latest/content/tools/sort.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (check.binary("bedtools")) {

index &lt;- get.example.regions();
a &lt;- index[[1]];
b &lt;- bedr.sort.region(a);

}
</code></pre>

<hr>
<h2 id='bedr.subtract.region'>
subtracts features or ranges in object b from object a
</h2><span id='topic+bedr.subtract.region'></span>

<h3>Description</h3>

<p>subtracts features or ranges in object b from object a
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bedr.subtract.region(
	x,
	y,
	fraction.overlap = 1/1e9,
	remove.whole.feature = TRUE,
	check.zero.based = TRUE,
	check.chr = TRUE,
	check.valid = TRUE,
	check.sort = TRUE,
	check.merge = TRUE,
	verbose = TRUE
	)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bedr.subtract.region_+3A_x">x</code></td>
<td>
<p>item a</p>
</td></tr>
<tr><td><code id="bedr.subtract.region_+3A_y">y</code></td>
<td>
<p>item b</p>
</td></tr>
<tr><td><code id="bedr.subtract.region_+3A_fraction.overlap">fraction.overlap</code></td>
<td>
<p> what portion of A to be considered an overlap</p>
</td></tr>
<tr><td><code id="bedr.subtract.region_+3A_remove.whole.feature">remove.whole.feature</code></td>
<td>
<p> should whole feature be removed </p>
</td></tr>
<tr><td><code id="bedr.subtract.region_+3A_check.zero.based">check.zero.based</code></td>
<td>
<p>should 0 based coordinates be checked</p>
</td></tr>
<tr><td><code id="bedr.subtract.region_+3A_check.chr">check.chr</code></td>
<td>
<p>should chr prefix be checked</p>
</td></tr>
<tr><td><code id="bedr.subtract.region_+3A_check.valid">check.valid</code></td>
<td>
<p>should the region be checkded for integerity</p>
</td></tr>
<tr><td><code id="bedr.subtract.region_+3A_check.sort">check.sort</code></td>
<td>
<p>check if region is sorted</p>
</td></tr> 
<tr><td><code id="bedr.subtract.region_+3A_check.merge">check.merge</code></td>
<td>
<p>check if overlapping regions are merged</p>
</td></tr> 
<tr><td><code id="bedr.subtract.region_+3A_verbose">verbose</code></td>
<td>
<p> messages and checks</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Regions exclusive to one object of regions.
</p>


<h3>Author(s)</h3>

<p>Daryl Waggott
</p>


<h3>References</h3>

<p><a href="http://bedtools.readthedocs.org/en/latest/content/tools/subtract.html">http://bedtools.readthedocs.org/en/latest/content/tools/subtract.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (check.binary("bedtools")) {
index &lt;- get.example.regions();

a &lt;- index[[1]];
b &lt;- index[[2]];
a &lt;- bedr(engine = "bedtools", input = list(i = a), method = "sort", params = "");
b &lt;- bedr(engine = "bedtools", input = list(i = b), method = "sort", params = "");
d &lt;- bedr.subtract.region(a,b);
}
</code></pre>

<hr>
<h2 id='catv'>
outputs text if verbose flag is set
</h2><span id='topic+catv'></span>

<h3>Description</h3>

<p>outputs text if verbose flag is set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>catv(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="catv_+3A_x">x</code></td>
<td>
<p> some text string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints the text string
</p>


<h3>Author(s)</h3>

<p>Daryl Waggott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
verbose &lt;- TRUE;
catv("Hello Universe!");
verbose &lt;- FALSE;
catv("Goodbye Universe!")

</code></pre>

<hr>
<h2 id='check.binary'>
checks if binary is in the path
</h2><span id='topic+check.binary'></span>

<h3>Description</h3>

<p>check if a binary is in the path.  Specifically used for bedtools, bedops and tabix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check.binary(x = "bedtools", verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check.binary_+3A_x">x</code></td>
<td>
<p>a string referring to a binary/executable i.e. bedtools, bedops, tabix</p>
</td></tr>
<tr><td><code id="check.binary_+3A_verbose">verbose</code></td>
<td>
<p>print log</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used internally to determine functionality selection options.
</p>


<h3>Value</h3>

<p>TRUE or FALSE
</p>


<h3>Author(s)</h3>

<p>Daryl Waggott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>check.binary("bedtools")
</code></pre>

<hr>
<h2 id='cluster.region'>
cluster intervals
</h2><span id='topic+cluster.region'></span>

<h3>Description</h3>

<p>cluster intervals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster.region(
	x,
	distance = 0,
	check.zero.based = TRUE,
	check.chr = TRUE,
	check.valid = TRUE,
	check.sort = TRUE,
	verbose = TRUE
	)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cluster.region_+3A_x">x</code></td>
<td>
<p>The region</p>
</td></tr>
<tr><td><code id="cluster.region_+3A_distance">distance</code></td>
<td>
<p> maximum distance between regions to be merged.  defaults to 0 which means overlapping or bookended features. note that you can use negative distances to enforce a minimum overlap. </p>
</td></tr>
<tr><td><code id="cluster.region_+3A_check.zero.based">check.zero.based</code></td>
<td>
<p>should 0 based coordinates be checked</p>
</td></tr>
<tr><td><code id="cluster.region_+3A_check.chr">check.chr</code></td>
<td>
<p>should chr prefix be checked</p>
</td></tr>
<tr><td><code id="cluster.region_+3A_check.valid">check.valid</code></td>
<td>
<p>should the region be checkded for integerity</p>
</td></tr>
<tr><td><code id="cluster.region_+3A_check.sort">check.sort</code></td>
<td>
<p> should regions be checked for sort order</p>
</td></tr>
<tr><td><code id="cluster.region_+3A_verbose">verbose</code></td>
<td>
<p>should log messages and checking take place</p>
</td></tr>
</table>


<h3>Details</h3>

<p>clusters adjacent features of a specified distance.
</p>


<h3>Value</h3>

<p>A data.frame in bed format
</p>


<h3>Author(s)</h3>

<p>Daryl Waggott
</p>


<h3>References</h3>

<p><a href="http://bedtools.readthedocs.org/en/latest/content/tools/cluster.html">http://bedtools.readthedocs.org/en/latest/content/tools/cluster.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bedr.merge.region">bedr.merge.region</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (check.binary("bedtools")) {

index &lt;- get.example.regions();

a &lt;- index[[1]];

b &lt;- cluster.region(a, distance = 0);
d &lt;- cluster.region(a, distance = 100);

}
</code></pre>

<hr>
<h2 id='convert2bed'>
convert object to bed format
</h2><span id='topic+convert2bed'></span>

<h3>Description</h3>

<p>checks if an object can be converted into a bed style data.frame then does the conversion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert2bed(
	x,
	set.type = TRUE,
	check.zero.based = TRUE,
	check.chr = TRUE,
	check.valid = TRUE,
	check.sort = TRUE,
	check.merge = TRUE,
	verbose = TRUE
	)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert2bed_+3A_x">x</code></td>
<td>
<p>A region index (i.e. chr1:10-100, ...) either as a vector or row.names/first column of a data.frame. Or a data.frame with the first three columns &quot;chr&quot;, s&quot;start&quot;, &quot;end&quot;</p>
</td></tr>
<tr><td><code id="convert2bed_+3A_set.type">set.type</code></td>
<td>
<p>should the attribute input.type be set.  Sometimes it is desirable to avoid setting it when applying intermediate conversion</p>
</td></tr>
<tr><td><code id="convert2bed_+3A_check.zero.based">check.zero.based</code></td>
<td>
<p>should 0 based coordinates be checked</p>
</td></tr>
<tr><td><code id="convert2bed_+3A_check.chr">check.chr</code></td>
<td>
<p>should chr prefix be checked</p>
</td></tr>
<tr><td><code id="convert2bed_+3A_check.valid">check.valid</code></td>
<td>
<p>should the region be checked for integerity</p>
</td></tr>
<tr><td><code id="convert2bed_+3A_check.sort">check.sort</code></td>
<td>
<p>should the region be checked to see if it is sorted</p>
</td></tr>
<tr><td><code id="convert2bed_+3A_check.merge">check.merge</code></td>
<td>
<p>should the region be checked for overlapping regions</p>
</td></tr>
<tr><td><code id="convert2bed_+3A_verbose">verbose</code></td>
<td>
<p>messages and text</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Very useful to convert data before using other bedr functions
</p>


<h3>Value</h3>

<p>Returns x converted to bedformat, as a data frame
</p>


<h3>Author(s)</h3>

<p>Daryl Waggott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  a.bed &lt;- convert.to.bed(a) 
  
## End(Not run)
</code></pre>

<hr>
<h2 id='create.tmp.bed.file'>
output R objects as tmpfiles
</h2><span id='topic+create.tmp.bed.file'></span>

<h3>Description</h3>

<p>output R objects as tmpfiles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.tmp.bed.file(x, name = "bedr", tmpDir = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create.tmp.bed.file_+3A_x">x</code></td>
<td>
<p>region object</p>
</td></tr>
<tr><td><code id="create.tmp.bed.file_+3A_name">name</code></td>
<td>
<p>a prefix for the tmp file.</p>
</td></tr>
<tr><td><code id="create.tmp.bed.file_+3A_tmpdir">tmpDir</code></td>
<td>
<p>where should the temp files be put</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daryl Waggott
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create tmp file 
</code></pre>

<hr>
<h2 id='determine.input'>
Determine input format
</h2><span id='topic+determine.input'></span>

<h3>Description</h3>

<p>Determine input format whether its tabular or bed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>determine.input(x, check.chr = FALSE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="determine.input_+3A_x">x</code></td>
<td>
<p>input vector, matrix or dataframe</p>
</td></tr>
<tr><td><code id="determine.input_+3A_check.chr">check.chr</code></td>
<td>
<p>check whether the coordinates are in chromosomal format with chr prefix</p>
</td></tr>
<tr><td><code id="determine.input_+3A_verbose">verbose</code></td>
<td>
<p>messages and checks</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer value. index format (0), bed (1), index in first column (2), rownmames are index (3), unrecognized(4)
</p>


<h3>Author(s)</h3>

<p>Daryl Waggott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (check.binary("bedtools")) {

index &lt;- get.example.regions();
a &lt;- index[[1]];
bedr:::determine.input(a);
}
</code></pre>

<hr>
<h2 id='df2list'>
Data frame to list conversion
</h2><span id='topic+df2list'></span>

<h3>Description</h3>

<p>Take data frame and return a list of rownames where column value is not 0 i.e. missing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df2list(x, start.col = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="df2list_+3A_x">x</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="df2list_+3A_start.col">start.col</code></td>
<td>
<p>offset from first column to ignore certain columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list following cleanup and change of data structure
</p>


<h3>Author(s)</h3>

<p>Daryl Waggott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  df2list(data.frame(a = 1:10, b = 11:20));
  
## End(Not run)
</code></pre>

<hr>
<h2 id='download.datasets'>
Download some useful datasets
</h2><span id='topic+download.datasets'></span>

<h3>Description</h3>

<p>Download some useful datasets.  Some functions such as plotting and fasta querying require additional data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>download.datasets(datasets = "all", data.dir = paste0(Sys.getenv("HOME"), "/bedr/data"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="download.datasets_+3A_datasets">datasets</code></td>
<td>
<p>A list of datasets to download.  Defaults to &quot;all&quot; i.e. c(&quot;refgene&quot;,&quot;hg19&quot;,&quot;b37&quot;,&quot;hugo&quot;, &quot;cosmic&quot;,&quot;clinvar&quot;)</p>
</td></tr>
<tr><td><code id="download.datasets_+3A_data.dir">data.dir</code></td>
<td>
<p>A directory to put the data.  Defaults to ~/bedr/data</p>
</td></tr>
</table>


<h3>Details</h3>

<p>External datasets are required for some bedr functionality.  For example, plotting intersections based on genes, get.fasta, bed2vcf and validate.gene.names.  If these datasets already exist you can simply place symlinks in a directory and use bedr.setup() to define the data.dir.
</p>


<h3>Value</h3>

<p>some datasets.
</p>


<h3>Author(s)</h3>

<p>Daryl Waggott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  download.datasets("cosmic");
  
## End(Not run)
</code></pre>

<hr>
<h2 id='flank.region'>
Get adjacent flanks from regions
</h2><span id='topic+flank.region'></span>

<h3>Description</h3>

<p>Get adjacent flanks from regions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flank.region(
	x,
	n.add = NULL,
	start.add = NULL,
	end.add = NULL,
	species = "human",
	build = "hg19",
	check.zero.based = TRUE,
	check.chr = TRUE,
	check.valid = TRUE,
	check.sort = TRUE,
	check.merge = TRUE,
	verbose = TRUE
	)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flank.region_+3A_x">x</code></td>
<td>
<p> a object region object or index</p>
</td></tr>
<tr><td><code id="flank.region_+3A_n.add">n.add</code></td>
<td>
<p>the number of bases to be selected from each side of a region</p>
</td></tr>
<tr><td><code id="flank.region_+3A_start.add">start.add</code></td>
<td>
<p>the number of based to be selected from the start of a region</p>
</td></tr>
<tr><td><code id="flank.region_+3A_end.add">end.add</code></td>
<td>
<p>the number of based to be selected from the end of a region</p>
</td></tr>
<tr><td><code id="flank.region_+3A_species">species</code></td>
<td>
<p>the species i.e. human or mouse</p>
</td></tr>
<tr><td><code id="flank.region_+3A_build">build</code></td>
<td>
<p>the genome build i.e. hg19 or mm10</p>
</td></tr>
<tr><td><code id="flank.region_+3A_check.zero.based">check.zero.based</code></td>
<td>
<p>should 0 based coordinates be checked</p>
</td></tr>
<tr><td><code id="flank.region_+3A_check.chr">check.chr</code></td>
<td>
<p>should chr prefix be checked</p>
</td></tr>
<tr><td><code id="flank.region_+3A_check.valid">check.valid</code></td>
<td>
<p>should the region be checkded for integerity</p>
</td></tr>
<tr><td><code id="flank.region_+3A_check.sort">check.sort</code></td>
<td>
<p> should regions be checked for sort order</p>
</td></tr>
<tr><td><code id="flank.region_+3A_check.merge">check.merge</code></td>
<td>
<p> should overlapping regions be checked</p>
</td></tr>
<tr><td><code id="flank.region_+3A_verbose">verbose</code></td>
<td>
<p>should log messages and checking take place</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daryl Waggott
</p>


<h3>References</h3>

<p><a href="http://bedtools.readthedocs.org/en/latest/content/tools/flank.html">http://bedtools.readthedocs.org/en/latest/content/tools/flank.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (check.binary("bedtools")) {

index &lt;- get.example.regions();

a &lt;- index[[1]];
a &lt;- bedr(engine = "bedtools", input = list(i = a), method = "sort", params = "");
b &lt;- flank.region(a, n.add = 20);

}
</code></pre>

<hr>
<h2 id='get.chr.length'>
gets the length of each chromosome for a species/build
</h2><span id='topic+get.chr.length'></span>

<h3>Description</h3>

<p>Gets the length of each chromosome for a species/build.  Choices are human (hg18, hg19, hg38), mouse(mm9, mm10)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.chr.length(chr = NULL, species = "human", build = "hg19")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.chr.length_+3A_chr">chr</code></td>
<td>
<p>a vector of chromosomes to query. defaults to all.</p>
</td></tr>
<tr><td><code id="get.chr.length_+3A_species">species</code></td>
<td>
<p>species</p>
</td></tr>
<tr><td><code id="get.chr.length_+3A_build">build</code></td>
<td>
<p>build</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with chromosome annotations</p>


<h3>Author(s)</h3>

<p>Daryl Waggott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>size &lt;- get.chr.length();
</code></pre>

<hr>
<h2 id='get.example.regions'>
return a set of regions for the examples and unit testing
</h2><span id='topic+get.example.regions'></span>

<h3>Description</h3>

<p>return a set of regions for the examples and unit testing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.example.regions()

</code></pre>


<h3>Value</h3>

<p>A list with three example regions
</p>


<h3>Author(s)</h3>

<p>Daryl Waggott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>index &lt;- get.example.regions()
</code></pre>

<hr>
<h2 id='get.fasta'>
Query fasta sequence
</h2><span id='topic+get.fasta'></span>

<h3>Description</h3>

<p>Query fasta sequence using bedtools get.fasta
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.fasta(
	x,
	fasta = NULL,
	bed12 = FALSE,
	strand = FALSE,
	output.fasta = FALSE,
	use.name.field = FALSE,
	check.zero.based = TRUE,
	check.chr = TRUE,
	check.valid = TRUE,
	check.sort = TRUE,
	check.merge = TRUE,
	verbose = TRUE
	)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.fasta_+3A_x">x</code></td>
<td>
<p>region or index</p>
</td></tr>
<tr><td><code id="get.fasta_+3A_fasta">fasta</code></td>
<td>
<p>a fasta file defaults to mini example hg19 human</p>
</td></tr>
<tr><td><code id="get.fasta_+3A_bed12">bed12</code></td>
<td>
<p>should bed12 format be used</p>
</td></tr>
<tr><td><code id="get.fasta_+3A_strand">strand</code></td>
<td>
<p>strand specific i.e. reverse complement negative</p>
</td></tr>
<tr><td><code id="get.fasta_+3A_output.fasta">output.fasta</code></td>
<td>
<p>output a fasta defaults to a data.frame for easier parsing</p>
</td></tr>
<tr><td><code id="get.fasta_+3A_use.name.field">use.name.field</code></td>
<td>
<p>should the name field be used for</p>
</td></tr>
<tr><td><code id="get.fasta_+3A_check.zero.based">check.zero.based</code></td>
<td>
<p>check for zero based region</p>
</td></tr>
<tr><td><code id="get.fasta_+3A_check.chr">check.chr</code></td>
<td>
<p>check for &quot;chr&quot; prefix </p>
</td></tr>
<tr><td><code id="get.fasta_+3A_check.valid">check.valid</code></td>
<td>
<p>check for valid regions i.e. start &lt; end</p>
</td></tr>
<tr><td><code id="get.fasta_+3A_check.sort">check.sort</code></td>
<td>
<p>check if region is sorted</p>
</td></tr>
<tr><td><code id="get.fasta_+3A_check.merge">check.merge</code></td>
<td>
<p>check if region is merged</p>
</td></tr>
<tr><td><code id="get.fasta_+3A_verbose">verbose</code></td>
<td>
<p>print progress</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses bedtools getFasta to query a fasta file and load into R as a data.frame for easy parsing.
</p>
<p>Note that the hg19 reference genome fasta is large and requires on the order of 4 GB RAM to avoid a segfault happens.
</p>


<h3>Value</h3>

<p>A data.frame or fasta. The data.frame has is two columns corresponding to the region and the sequence.
</p>


<h3>Author(s)</h3>

<p>Daryl Waggott, Syed Haider
</p>


<h3>References</h3>

<p><a href="http://bedtools.readthedocs.org/en/latest/content/tools/getfasta.html">http://bedtools.readthedocs.org/en/latest/content/tools/getfasta.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

if (check.binary("bedtools")) {

## Not run: 

  # get the sequence for a set of regions as a data.frame
  index &lt;- get.example.regions();
  a &lt;- index[[1]];
  b &lt;- get.fasta(bedr.sort.region(a));

  # this time output a fasta
  d &lt;- get.fasta(b, output.fasta = TRUE);
  writeLines(d[[1]], con = "test.fasta");

  # get the region adjacent to a set of mutations in a vcf
  clinvar.vcf.example &lt;- system.file(
    "extdata/clinvar_dbSNP138_example.vcf.gz", 
    package = "bedr"
    );
  clinvar &lt;- read.vcf(clinvar.vcf.example);

  # note that clinvar uses ncbi fasta which does not use "chr" and codes chrM as MT
  clinvar.bed &lt;- data.frame(
    chr = paste0("chr", gsub("MT", "M", clinvar$vcf$CHROM)),
    start = clinvar$vcf$POS - 2,
    end = clinvar$vcf$POS + 1,
    stringsAsFactors = FALSE
    );

  # get trinucleotide sequences of variants on chr M only
  mutation.triplet &lt;- get.fasta(
  	clinvar.bed[which(clinvar.bed$chr == "chrM"), ], 
  	fasta = system.file("extdata/ucsc.hg19.chrM.fasta", package = "bedr"),
  	check.chr = FALSE
  	);
  
## End(Not run)
}
</code></pre>

<hr>
<h2 id='get.random.regions'>
generates a set of random regions
</h2><span id='topic+get.random.regions'></span>

<h3>Description</h3>

<p>generates a set of random regions for a specific species/build.  Choices are human (hg18, hg19), mouse(mm9, mm10). regions are sampled from a log-normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.random.regions(
	n = 10,
	chr = NULL,
	species = "human",
	build = "hg19",
	size.mean = 10,
	size.sd = 0.25,
	mask.gaps = FALSE,
	mask.repeats = FALSE,
	sort.output = TRUE,
	verbose = TRUE
	)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.random.regions_+3A_n">n</code></td>
<td>
<p>number of regions</p>
</td></tr>
<tr><td><code id="get.random.regions_+3A_chr">chr</code></td>
<td>
<p>the chr or region</p>
</td></tr>
<tr><td><code id="get.random.regions_+3A_species">species</code></td>
<td>
<p>species</p>
</td></tr>
<tr><td><code id="get.random.regions_+3A_build">build</code></td>
<td>
<p>build</p>
</td></tr>
<tr><td><code id="get.random.regions_+3A_size.mean">size.mean</code></td>
<td>
<p>region mean in log space</p>
</td></tr>
<tr><td><code id="get.random.regions_+3A_size.sd">size.sd</code></td>
<td>
<p>region sd in log space </p>
</td></tr>
<tr><td><code id="get.random.regions_+3A_mask.gaps">mask.gaps</code></td>
<td>
<p>should the gaps (Ns) in the human reference be ignored as potential start points.  This drammatically increases memory and run time but is more appropriate in almost all settings.  By default it's off.</p>
</td></tr>
<tr><td><code id="get.random.regions_+3A_mask.repeats">mask.repeats</code></td>
<td>
<p>should the repeats from repeatMasker be ignored as potential start points.  This drammatically increases memory and run time but is more appropriate in almost all settings.  By default it's off.</p>
</td></tr>
<tr><td><code id="get.random.regions_+3A_sort.output">sort.output</code></td>
<td>
<p>return a sorted index</p>
</td></tr>
<tr><td><code id="get.random.regions_+3A_verbose">verbose</code></td>
<td>
<p>words</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daryl Waggott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test.regions &lt;- get.random.regions(100)
</code></pre>

<hr>
<h2 id='grow.region'>
Get adjacent flanks from regions
</h2><span id='topic+grow.region'></span>

<h3>Description</h3>

<p>Get adjacent flanks from regions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grow.region(
	x,
	n.add = NULL,
	start.add = NULL,
	end.add = NULL,
	species = "human",
	build = "hg19",
	check.zero.based = TRUE,
	check.chr = TRUE,
	check.valid = TRUE,
	check.sort = TRUE,
	check.merge = TRUE,
	verbose = TRUE
	)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="grow.region_+3A_x">x</code></td>
<td>
<p> a object region object or index</p>
</td></tr>
<tr><td><code id="grow.region_+3A_n.add">n.add</code></td>
<td>
<p>the number of bases to be selected from each side of a region</p>
</td></tr>
<tr><td><code id="grow.region_+3A_start.add">start.add</code></td>
<td>
<p>the number of based to be selected from the start of a region</p>
</td></tr>
<tr><td><code id="grow.region_+3A_end.add">end.add</code></td>
<td>
<p>the number of based to be selected from the end of a region</p>
</td></tr>
<tr><td><code id="grow.region_+3A_species">species</code></td>
<td>
<p>the species i.e. human or mouse</p>
</td></tr>
<tr><td><code id="grow.region_+3A_build">build</code></td>
<td>
<p>the genome build i.e. hg19 or mm10</p>
</td></tr>
<tr><td><code id="grow.region_+3A_check.zero.based">check.zero.based</code></td>
<td>
<p>should 0 based coordinates be checked</p>
</td></tr>
<tr><td><code id="grow.region_+3A_check.chr">check.chr</code></td>
<td>
<p>should chr prefix be checked</p>
</td></tr>
<tr><td><code id="grow.region_+3A_check.valid">check.valid</code></td>
<td>
<p>should the region be checkded for integerity</p>
</td></tr>
<tr><td><code id="grow.region_+3A_check.sort">check.sort</code></td>
<td>
<p> should regions be checked for sort order</p>
</td></tr>
<tr><td><code id="grow.region_+3A_check.merge">check.merge</code></td>
<td>
<p> should overlapping regions be checked</p>
</td></tr>
<tr><td><code id="grow.region_+3A_verbose">verbose</code></td>
<td>
<p>should log messages and checking take place</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daryl Waggott
</p>


<h3>References</h3>

<p><a href="http://bedtools.readthedocs.org/en/latest/content/tools/slop.html">http://bedtools.readthedocs.org/en/latest/content/tools/slop.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (check.binary("bedtools")) {

index &lt;- get.example.regions();

a &lt;- index[[1]];
a &lt;- bedr(engine = "bedtools", input = list(i = a), method = "sort", params = "");
b &lt;- grow.region(a, n.add = 20);

}
</code></pre>

<hr>
<h2 id='in.region'>
checks if regions in object a are found in object b
</h2><span id='topic+in.region'></span>

<h3>Description</h3>

<p>checks if regions in object a are found in object b
</p>


<h3>Usage</h3>

<pre><code class='language-R'>in.region(
	x,
	y,
	proportion.overlap = 1e-09,
	reciprocal.overlap = FALSE,
	check.zero.based = TRUE,
	check.chr = TRUE,
	check.valid = TRUE,
	check.sort = TRUE,
	check.merge = TRUE,
	verbose = FALSE
	)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="in.region_+3A_x">x</code></td>
<td>
<p>first region index in the form chr:start-stop.  regions in this index will be checked for intersection in the values of the second index.</p>
</td></tr>
<tr><td><code id="in.region_+3A_y">y</code></td>
<td>
<p>second region index.</p>
</td></tr>
<tr><td><code id="in.region_+3A_proportion.overlap">proportion.overlap</code></td>
<td>
<p>Defaults 1e-9 which is 1 bp.  See details below for the different interpretation between 0 and 1 based overlap</p>
</td></tr>
<tr><td><code id="in.region_+3A_reciprocal.overlap">reciprocal.overlap</code></td>
<td>
<p>Should the proportion.overlap be reciprocal</p>
</td></tr>
<tr><td><code id="in.region_+3A_check.zero.based">check.zero.based</code></td>
<td>
<p>should 0 based coordinates be checked</p>
</td></tr>
<tr><td><code id="in.region_+3A_check.chr">check.chr</code></td>
<td>
<p>should chr prefix be checked</p>
</td></tr>
<tr><td><code id="in.region_+3A_check.valid">check.valid</code></td>
<td>
<p>check if region is valid</p>
</td></tr>
<tr><td><code id="in.region_+3A_check.sort">check.sort</code></td>
<td>
<p>check if region is sorted</p>
</td></tr>  
<tr><td><code id="in.region_+3A_check.merge">check.merge</code></td>
<td>
<p>check if overlapping regions are merged</p>
</td></tr>  
<tr><td><code id="in.region_+3A_verbose">verbose</code></td>
<td>
<p>prints some debugging information.  currently it just checks if the input regions are overlapping</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function can also be called using syntax similar to the %in% operator, for example &quot;region1 %in.region% region2&quot;
</p>
<p>The default is to report TRUE if there is 1bp overlap in zero based bed format.  That means that region chr1:10-20 and chr1:20-30 would not overlap.  To switch to one based intuitive interpretation set proportion.overlap = 0.
</p>


<h3>Value</h3>

<p>Returns a logical vector the length of x.
</p>


<h3>Author(s)</h3>

<p>Daryl Waggott
</p>


<h3>References</h3>

<p><a href="http://bedtools.readthedocs.org/en/latest/content/tools/intersect.html">http://bedtools.readthedocs.org/en/latest/content/tools/intersect.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (check.binary("bedtools")) {

index &lt;- get.example.regions();

a &lt;- index[[1]];
b &lt;- index[[2]];
a &lt;- bedr(engine = "bedtools", input = list(i = a), method = "sort", params = "");
b &lt;- bedr(engine = "bedtools", input = list(i = b), method = "sort", params = "");

d &lt;- in.region(a,b);

# alternative calling
d &lt;- a %in.region% b

}
</code></pre>

<hr>
<h2 id='index2bed'>
convert a region index into a bed file dataframe
</h2><span id='topic+index2bed'></span>

<h3>Description</h3>

<p>convert a region index into a bed file dataframe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>index2bed(x, set.type = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="index2bed_+3A_x">x</code></td>
<td>
<p>an index</p>
</td></tr>
<tr><td><code id="index2bed_+3A_set.type">set.type</code></td>
<td>
<p>should the attribute input.type be set.  Sometimes it is desirable to avoid setting it when applying intermediate conversion</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daryl Waggott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (check.binary("bedtools")) {

index &lt;- get.example.regions();
a &lt;- index[[1]];
a.bed &lt;- index2bed(a);
}
</code></pre>

<hr>
<h2 id='is.merged.region'>
checks if region file is merged
</h2><span id='topic+is.merged.region'></span>

<h3>Description</h3>

<p>checks if region file is merged
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.merged.region(
	x,
	check.zero.based = TRUE,
	check.chr = TRUE,
	check.valid = TRUE,
	check.sort = TRUE,
	verbose = FALSE
	)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.merged.region_+3A_x">x</code></td>
<td>
<p>region or index</p>
</td></tr>
<tr><td><code id="is.merged.region_+3A_check.zero.based">check.zero.based</code></td>
<td>
<p>should 0 based coordinates be checked</p>
</td></tr>
<tr><td><code id="is.merged.region_+3A_check.chr">check.chr</code></td>
<td>
<p>should chr prefix be checked</p>
</td></tr>
<tr><td><code id="is.merged.region_+3A_check.valid">check.valid</code></td>
<td>
<p>check if region is valid</p>
</td></tr>
<tr><td><code id="is.merged.region_+3A_check.sort">check.sort</code></td>
<td>
<p>check if region is sorted</p>
</td></tr>
<tr><td><code id="is.merged.region_+3A_verbose">verbose</code></td>
<td>
<p>more words</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daryl Waggott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (check.binary("bedtools")) {

index &lt;- get.example.regions();

a &lt;- index[[1]];

b &lt;- is.merged.region(a);

}
</code></pre>

<hr>
<h2 id='is.sorted.region'>
checks if region file is sorted
</h2><span id='topic+is.sorted.region'></span>

<h3>Description</h3>

<p>checks if region file is sorted
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.sorted.region(
	x,
	method = "lex",
	engine = "unix",
	check.zero.based = TRUE,
	check.chr = TRUE,
	check.valid = TRUE,
	check.merge = TRUE,
	verbose = FALSE
	)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.sorted.region_+3A_x">x</code></td>
<td>
<p>The region index, bed file, or bed formatted object</p>
</td></tr>
<tr><td><code id="is.sorted.region_+3A_method">method</code></td>
<td>
<p>lexicgraphical or natural, lex is required for many operations but natural is better for interpretation</p>
</td></tr>
<tr><td><code id="is.sorted.region_+3A_engine">engine</code></td>
<td>
<p>what analytical engine to use for sorting i.e. bedtools, bedops, gnu unix</p>
</td></tr>
<tr><td><code id="is.sorted.region_+3A_check.zero.based">check.zero.based</code></td>
<td>
<p>should 0 based coordinates be checked</p>
</td></tr>
<tr><td><code id="is.sorted.region_+3A_check.chr">check.chr</code></td>
<td>
<p>should chr prefix be checked</p>
</td></tr>
<tr><td><code id="is.sorted.region_+3A_check.valid">check.valid</code></td>
<td>
<p>check if region is valid</p>
</td></tr>
<tr><td><code id="is.sorted.region_+3A_check.merge">check.merge</code></td>
<td>
<p>check if region is merged</p>
</td></tr>
<tr><td><code id="is.sorted.region_+3A_verbose">verbose</code></td>
<td>
<p>more words</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daryl Waggott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (check.binary("bedtools")) {
index &lt;- get.example.regions();

a &lt;- index[[1]];

b &lt;- is.sorted.region(a);
}
</code></pre>

<hr>
<h2 id='is.valid.ref'>
verifies the reference sequence in a vcf
</h2><span id='topic+is.valid.ref'></span>

<h3>Description</h3>

<p>verifies the reference sequence in a vcf
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.valid.ref(
	x,
	fasta = NULL,
	strand = FALSE,
	check.zero.based = TRUE,
	check.chr = TRUE,
	check.valid = TRUE,
	check.sort = TRUE,
	check.merge = TRUE,
	verbose = TRUE
	)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.valid.ref_+3A_x">x</code></td>
<td>
<p>input bed object</p>
</td></tr>
<tr><td><code id="is.valid.ref_+3A_fasta">fasta</code></td>
<td>
<p>a reference build in fasta format</p>
</td></tr>
<tr><td><code id="is.valid.ref_+3A_strand">strand</code></td>
<td>
<p> should strand be used.  if reverse then the sequence will be reverse complemented</p>
</td></tr>
<tr><td><code id="is.valid.ref_+3A_check.zero.based">check.zero.based</code></td>
<td>
<p>should 0 based coordinates be checked</p>
</td></tr>
<tr><td><code id="is.valid.ref_+3A_check.chr">check.chr</code></td>
<td>
<p>should chr prefix be checked</p>
</td></tr>
<tr><td><code id="is.valid.ref_+3A_check.valid">check.valid</code></td>
<td>
<p>should the region be checkded for integerity</p>
</td></tr>
<tr><td><code id="is.valid.ref_+3A_check.sort">check.sort</code></td>
<td>
<p> should regions be checked for sort order</p>
</td></tr>
<tr><td><code id="is.valid.ref_+3A_check.merge">check.merge</code></td>
<td>
<p> should overlapping regions be checked</p>
</td></tr>
<tr><td><code id="is.valid.ref_+3A_verbose">verbose</code></td>
<td>
<p>should log messages and checking take place</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical vector the length of the input
</p>


<h3>Author(s)</h3>

<p>Daryl Waggott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
vcf.path &lt;- system.file("extdata/callerA.vcf.gz", package = "bedr");
vcf.data &lt;- read.vcf(vcf.path, split.info = TRUE);
vcf.data$vcf &lt;- vcf.data$vcf[, 
	c("CHROM", "POS", "END", setdiff(colnames(vcf.data$vcf), c("CHROM", "POS", "END")))
	];
vcf.data$vcf$CHROM &lt;- paste("chr", vcf.data$vcf$CHROM, sep = "");

## Not run: 
	# need reference sequence FASTA and index file to run this, as 'fasta' parameter
	is.valid.ref(vcf.data);
	
## End(Not run)
</code></pre>

<hr>
<h2 id='is.valid.region'>
checks if region/index is valid
</h2><span id='topic+is.valid.region'></span>

<h3>Description</h3>

<p>checks if region/index is valid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.valid.region(
	x,
	check.zero.based = TRUE,
	check.chr = TRUE,
	throw.error = FALSE,
	verbose = TRUE
	)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.valid.region_+3A_x">x</code></td>
<td>
<p>The region index, bed file, or bed formatted object</p>
</td></tr>
<tr><td><code id="is.valid.region_+3A_check.zero.based">check.zero.based</code></td>
<td>
<p>should basic test for zero based coordinates be checked</p>
</td></tr>
<tr><td><code id="is.valid.region_+3A_check.chr">check.chr</code></td>
<td>
<p>should the algorithm check for the &quot;chr&quot; prefix</p>
</td></tr>
<tr><td><code id="is.valid.region_+3A_throw.error">throw.error</code></td>
<td>
<p>should an error be thrown.  The default is to report a logical vector of inconsistencies.</p>
</td></tr>
<tr><td><code id="is.valid.region_+3A_verbose">verbose</code></td>
<td>
<p>should diagnostic messages be printed</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daryl Waggott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>index &lt;- get.example.regions();

a &lt;- index[[1]];
is.valid &lt;- is.valid.region(a);
a.valid &lt;- a[is.valid];

</code></pre>

<hr>
<h2 id='is.valid.seq'>
verifies that sequences are correct given coordinates and a reference
</h2><span id='topic+is.valid.seq'></span>

<h3>Description</h3>

<p>verifies that sequences are correct given coordinates and a reference
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.valid.seq(
	x,
	querySeq,
	fasta = NULL,
	strand = FALSE,
	check.zero.based = TRUE,
	check.chr = TRUE,
	check.valid = TRUE,
	check.sort = TRUE,
	check.merge = TRUE,
	verbose = TRUE
	)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.valid.seq_+3A_x">x</code></td>
<td>
<p>input bed object</p>
</td></tr>
<tr><td><code id="is.valid.seq_+3A_queryseq">querySeq</code></td>
<td>
<p>a vector of sequences the same length as x</p>
</td></tr>
<tr><td><code id="is.valid.seq_+3A_fasta">fasta</code></td>
<td>
<p>a reference build in fasta format</p>
</td></tr>
<tr><td><code id="is.valid.seq_+3A_strand">strand</code></td>
<td>
<p> should strand be used.  if reverse then the sequence will be reverse complemented</p>
</td></tr>
<tr><td><code id="is.valid.seq_+3A_check.zero.based">check.zero.based</code></td>
<td>
<p>should 0 based coordinates be checked</p>
</td></tr>
<tr><td><code id="is.valid.seq_+3A_check.chr">check.chr</code></td>
<td>
<p>should chr prefix be checked</p>
</td></tr>
<tr><td><code id="is.valid.seq_+3A_check.valid">check.valid</code></td>
<td>
<p>should the region be checkded for integerity</p>
</td></tr>
<tr><td><code id="is.valid.seq_+3A_check.sort">check.sort</code></td>
<td>
<p> should regions be checked for sort order</p>
</td></tr>
<tr><td><code id="is.valid.seq_+3A_check.merge">check.merge</code></td>
<td>
<p> should overlapping regions be checked</p>
</td></tr>
<tr><td><code id="is.valid.seq_+3A_verbose">verbose</code></td>
<td>
<p>should log messages and checking take place</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical vector the length of the input querySeq
</p>


<h3>Author(s)</h3>

<p>Daryl Waggott, Syed Haider
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (check.binary("bedtools")) {
  index &lt;- get.example.regions();
  a &lt;- index[[1]];
  a &lt;- get.fasta(bedr.sort.region(a));
  is.valid.seq(x = a, querySeq = a$sequence);
}
</code></pre>

<hr>
<h2 id='jaccard'>
calculate the jaccard distance between sets of intervals
</h2><span id='topic+jaccard'></span>

<h3>Description</h3>

<p>calculate the jaccard distance between sets of intervals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jaccard(
	x,
	y,
	proportion.overlap = 1e-09,
	reciprocal.overlap = FALSE,
	check.zero.based = TRUE,
	check.chr = TRUE,
	check.valid = TRUE,
	check.sort = TRUE,
	check.merge = TRUE,
	verbose = TRUE
	)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jaccard_+3A_x">x</code></td>
<td>
<p>first region to be compared</p>
</td></tr>
<tr><td><code id="jaccard_+3A_y">y</code></td>
<td>
<p>second region to be compared</p>
</td></tr>
<tr><td><code id="jaccard_+3A_proportion.overlap">proportion.overlap</code></td>
<td>
<p>Defaults 1e-9 which is 1 bp.  See details below for the different interpretation between 0 and 1 based overlap</p>
</td></tr>
<tr><td><code id="jaccard_+3A_reciprocal.overlap">reciprocal.overlap</code></td>
<td>
<p>Should the proportion.overlap be reciprocal</p>
</td></tr>
<tr><td><code id="jaccard_+3A_check.zero.based">check.zero.based</code></td>
<td>
<p>should 0 based coordinates be checked</p>
</td></tr>
<tr><td><code id="jaccard_+3A_check.chr">check.chr</code></td>
<td>
<p>should chr prefix be checked</p>
</td></tr>
<tr><td><code id="jaccard_+3A_check.valid">check.valid</code></td>
<td>
<p>should the region be checkded for integerity</p>
</td></tr>
<tr><td><code id="jaccard_+3A_check.sort">check.sort</code></td>
<td>
<p> should regions be checked for sort order</p>
</td></tr>
<tr><td><code id="jaccard_+3A_check.merge">check.merge</code></td>
<td>
<p> should overlapping regions be checked</p>
</td></tr>
<tr><td><code id="jaccard_+3A_verbose">verbose</code></td>
<td>
<p>should log messages and checking take place</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Jaccard metric is the ratio of intersections to unions.  The process can be tweaked by changing the proportion of overlap and even growiwng the regions.
</p>


<h3>Value</h3>

<p>A short vector.
</p>


<h3>Author(s)</h3>

<p>Daryl Waggott
</p>


<h3>References</h3>

<p><a href="http://bedtools.readthedocs.org/en/latest/content/tools/jaccard.html">http://bedtools.readthedocs.org/en/latest/content/tools/jaccard.html</a>
</p>


<h3>See Also</h3>

<p>reldist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (check.binary("bedtools")) {

index &lt;- get.example.regions();

a &lt;- index[[1]];
b &lt;- index[[2]];
a &lt;- bedr(engine = "bedtools", input = list(i = a), method = "sort", params = "");
b &lt;- bedr(engine = "bedtools", input = list(i = b), method = "sort", params = "");
jaccard(a,b);

}
</code></pre>

<hr>
<h2 id='modifyList2'>
Interface to R's modifyList
</h2><span id='topic+modifyList2'></span>

<h3>Description</h3>

<p>Interface to R's modifyList
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modifyList2(x, val)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modifyList2_+3A_x">x</code></td>
<td>
<p>a named list</p>
</td></tr>
<tr><td><code id="modifyList2_+3A_val">val</code></td>
<td>
<p>a named list with components to be updated using x</p>
</td></tr>
</table>


<h3>Value</h3>

<p>modified version of x
</p>


<h3>Author(s)</h3>

<p>Daryl Waggott
</p>


<h3>See Also</h3>

<p>modifyList
</p>

<hr>
<h2 id='order.region'>
Gets the sort order of a region index similar to the order command
</h2><span id='topic+order.region'></span>

<h3>Description</h3>

<p>Helps if you don't want to use sort region on a huge dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order.region(
	x,
	method = "lex",
	check.zero.based = TRUE,
	check.chr = TRUE,
	check.valid = TRUE,
	check.merge = TRUE
	)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="order.region_+3A_x">x</code></td>
<td>
<p>index or bed style data.frame</p>
</td></tr>
<tr><td><code id="order.region_+3A_method">method</code></td>
<td>
<p>natural or lexicographical (lex)</p>
</td></tr>
<tr><td><code id="order.region_+3A_check.zero.based">check.zero.based</code></td>
<td>
<p>should 0 based coordinates be checked</p>
</td></tr>
<tr><td><code id="order.region_+3A_check.chr">check.chr</code></td>
<td>
<p>should chr prefix be checked</p>
</td></tr>
<tr><td><code id="order.region_+3A_check.valid">check.valid</code></td>
<td>
<p>check if region is valid</p>
</td></tr>
<tr><td><code id="order.region_+3A_check.merge">check.merge</code></td>
<td>
<p>check if region is sorted and merged</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Daryl Waggott
</p>


<h3>References</h3>

<p><a href="http://bedtools.readthedocs.org/en/latest/content/tools/intersect.html">http://bedtools.readthedocs.org/en/latest/content/tools/intersect.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (check.binary("bedtools")) {

index &lt;- get.example.regions();

a &lt;- index[[1]];
a &lt;- bedr(engine = "bedtools", input = list(i = a), method = "sort", params = "");
a.order &lt;- order.region(a)

b &lt;- a[a.order];

}
</code></pre>

<hr>
<h2 id='permute.region'>
permute a set of regions
</h2><span id='topic+permute.region'></span>

<h3>Description</h3>

<p>permute a set of regions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permute.region(
	x,
	stratify.by.chr = FALSE,
	species = "human",
	build = "hg19",
	chr.names = paste0("chr",c(1:22,"X","Y","M")),
	mask.gaps = FALSE,
	gaps.file = NULL,
	mask.repeats = FALSE,
	repeats.file = NULL,
	sort.output = TRUE,
	is.checked = FALSE,
	check.zero.based = TRUE,
	check.chr = TRUE,
	check.valid = TRUE,
	verbose = TRUE
	)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="permute.region_+3A_x">x</code></td>
<td>
<p>regions to permute</p>
</td></tr>
<tr><td><code id="permute.region_+3A_stratify.by.chr">stratify.by.chr</code></td>
<td>
<p>Should the permutation be happen separetely for each chromosome.  That is are chromosomes exchangeable.</p>
</td></tr>
<tr><td><code id="permute.region_+3A_species">species</code></td>
<td>
<p>species</p>
</td></tr>
<tr><td><code id="permute.region_+3A_build">build</code></td>
<td>
<p>the build of the reference</p>
</td></tr>
<tr><td><code id="permute.region_+3A_chr.names">chr.names</code></td>
<td>
<p>names of the chromosomes to use</p>
</td></tr>
<tr><td><code id="permute.region_+3A_mask.gaps">mask.gaps</code></td>
<td>
<p>should the gaps (Ns) in the human reference be ignored as potential start points.  This drammatically increases memory and run time but is more appropriate in almost all settings.  It defaults to off</p>
</td></tr>
<tr><td><code id="permute.region_+3A_gaps.file">gaps.file</code></td>
<td>
<p>database file of gaps. Defaults to Homo sapiens Hg19 gap.txt.gz file available through UCSC</p>
</td></tr>
<tr><td><code id="permute.region_+3A_mask.repeats">mask.repeats</code></td>
<td>
<p>should the repeats from repeatMasker be ignored as potential start points.  This drammatically increases memory and run time but is more appropriate in almost all settings.  By default it's off</p>
</td></tr>
<tr><td><code id="permute.region_+3A_repeats.file">repeats.file</code></td>
<td>
<p>database file of repeats as supplied by UCSC containing RepMasker data e.g rmsk.txt.gz</p>
</td></tr>
<tr><td><code id="permute.region_+3A_sort.output">sort.output</code></td>
<td>
<p>should the output be sorted</p>
</td></tr>
<tr><td><code id="permute.region_+3A_is.checked">is.checked</code></td>
<td>
<p>Has the input data already be tested for validity.  This is often done once before multiple permutations.</p>
</td></tr>
<tr><td><code id="permute.region_+3A_check.zero.based">check.zero.based</code></td>
<td>
<p>should 0 based coordinates be checked</p>
</td></tr>
<tr><td><code id="permute.region_+3A_check.chr">check.chr</code></td>
<td>
<p>should chr prefix be checked</p>
</td></tr>
<tr><td><code id="permute.region_+3A_check.valid">check.valid</code></td>
<td>
<p>should the region be checkded for integerity</p>
</td></tr>
<tr><td><code id="permute.region_+3A_verbose">verbose</code></td>
<td>
<p>should log messages and checking take place</p>
</td></tr>
</table>


<h3>Details</h3>

<p>1. Sampling with replacement on region length. 
2. Sampling with replacement on start positions.  Positions that contain Ns in the reference are set to 0 weight during sampling.
</p>
<p>Regions that overlap the end of a chromosome or gap are trimmed.
</p>
<p>Steps 1 and 2 are done within chromosomes if stratify.by.chr is set to true.
</p>


<h3>Value</h3>

<p>A region object with randomized start positions.
</p>


<h3>Author(s)</h3>

<p>Daryl Waggott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (check.binary("bedtools")) {

index &lt;- get.example.regions();
a &lt;- index[[1]];
a &lt;- bedr(engine = "bedtools", input = list(i = a), method = "sort", params = "");
a.perm &lt;- permute.region(a);

}
</code></pre>

<hr>
<h2 id='process.input'>
process.input
</h2><span id='topic+process.input'></span>

<h3>Description</h3>

<p>process.input
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process.input(
	input, 
	tmpDir = NULL,
	include.names = TRUE, 
	check.zero.based = TRUE, 
	check.chr = TRUE, 
	check.valid = TRUE, 
	check.sort = TRUE, 
	check.merge = TRUE, 
	verbose = TRUE
	)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="process.input_+3A_input">input</code></td>
<td>
<p>regions input or a file in one of the standard formats. these are bed, vcf, gff, bam, sam, csv, tsv, txt</p>
</td></tr>
<tr><td><code id="process.input_+3A_tmpdir">tmpDir</code></td>
<td>
<p>The directory to be used for writing files</p>
</td></tr>
<tr><td><code id="process.input_+3A_include.names">include.names</code></td>
<td>
<p>should the names of the input files be included in the output</p>
</td></tr>
<tr><td><code id="process.input_+3A_check.zero.based">check.zero.based</code></td>
<td>
<p>should 0 based coordinates be checked</p>
</td></tr>
<tr><td><code id="process.input_+3A_check.chr">check.chr</code></td>
<td>
<p>should chr prefix be checked</p>
</td></tr>
<tr><td><code id="process.input_+3A_check.valid">check.valid</code></td>
<td>
<p>should the region be checked for integerity</p>
</td></tr>
<tr><td><code id="process.input_+3A_check.sort">check.sort</code></td>
<td>
<p>should the region sorting be checked</p>
</td></tr>
<tr><td><code id="process.input_+3A_check.merge">check.merge</code></td>
<td>
<p>should overlapping regions be checked</p>
</td></tr>
<tr><td><code id="process.input_+3A_verbose">verbose</code></td>
<td>
<p>messages and checks</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of input files
</p>


<h3>Author(s)</h3>

<p>Daryl Waggott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (check.binary("bedtools")) {

index &lt;- get.example.regions();
a &lt;- index[[1]];
a &lt;- bedr(engine = "bedtools", input = list(i = a), method = "sort", params = "");
a.processed &lt;- process.input(a, verbose = FALSE)

}
</code></pre>

<hr>
<h2 id='query.ucsc'>
read a ucsc table into R
</h2><span id='topic+query.ucsc'></span>

<h3>Description</h3>

<p>read a ucsc table into R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>query.ucsc(
	x,
	mirror = "http://hgdownload.soe.ucsc.edu/goldenPath/hg19/database",
	download = TRUE,
	overwrite.local = FALSE,
	columns.keep = NULL,
	verbose = TRUE
	)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="query.ucsc_+3A_x">x</code></td>
<td>
<p>a ucsc data table.  Include the full path including &quot;txt.gz&quot; extenstion to load from a local file.  Note that $HOME/bedr/data will be checked first before downloading.</p>
</td></tr>
<tr><td><code id="query.ucsc_+3A_mirror">mirror</code></td>
<td>
<p>the ucsc mirror</p>
</td></tr>
<tr><td><code id="query.ucsc_+3A_download">download</code></td>
<td>
<p>should the data be downloaded to $HOME/bedr/data/</p>
</td></tr>
<tr><td><code id="query.ucsc_+3A_overwrite.local">overwrite.local</code></td>
<td>
<p>should the local version be overwritten if it exists</p>
</td></tr>
<tr><td><code id="query.ucsc_+3A_columns.keep">columns.keep</code></td>
<td>
<p>what columns to load.  this can help with very large tables where you only want 'chr,start,end'. defaults to all.  you may have to check the sql for the actual column names.</p>
</td></tr>
<tr><td><code id="query.ucsc_+3A_verbose">verbose</code></td>
<td>
<p>more words</p>
</td></tr>
</table>


<h3>Details</h3>

<p>tables can be found at <a href="http://hgdownload.soe.ucsc.edu/goldenPath/hg19/database">http://hgdownload.soe.ucsc.edu/goldenPath/hg19/database</a>
</p>


<h3>Value</h3>

<p>A data.frame
</p>


<h3>Author(s)</h3>

<p>Daryl Wagott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  query.ucsc("refGene");
  
## End(Not run)
</code></pre>

<hr>
<h2 id='read.vcf'>
Read a vcf into R
</h2><span id='topic+read.vcf'></span>

<h3>Description</h3>

<p>Read a vcf into R and parse it for downstream analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.vcf(x, split.info = FALSE, split.samples = FALSE, nrows = -1, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.vcf_+3A_x">x</code></td>
<td>

<p>A vcf
</p>
</td></tr>
<tr><td><code id="read.vcf_+3A_split.info">split.info</code></td>
<td>

<p>Split the info into columns
</p>
</td></tr>
<tr><td><code id="read.vcf_+3A_split.samples">split.samples</code></td>
<td>

<p>Split the sample into columns.  If multiple samples then a list matrices will be created, one matrix for each element in the FORMAT tag.
</p>
</td></tr>
<tr><td><code id="read.vcf_+3A_nrows">nrows</code></td>
<td>

<p>The the number of rows to be read.  Set to 0 to parse the header.
</p>
</td></tr>
<tr><td><code id="read.vcf_+3A_verbose">verbose</code></td>
<td>

<p>print progress
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function can be slow for splitting the INFO, FORMAT for large VCFs.
</p>


<h3>Value</h3>

<p>VCF representation in R as a list.  The first element in the list is the header, the second the body of the VCF.  Every repeating tag in the header i.e. INFO, FORMAT is structured as matrix.  If reading a multi-sample VCF and the split.sample = TRUE, then a matrix is added to the list for every tag in the FORMAT string.
</p>
<p>Note that by default the vcf is returned as a data.table not a data.frame.  Therefore there are some quirks i.e. subsetting via named columns a$vcf[,&quot;CHROM&quot;, with = FALSE].  If in doubt just caset to data.frame.
</p>


<h3>Author(s)</h3>

<p>Daryl Waggott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
clinVar.vcf.example      &lt;- system.file("extdata/clinvar_dbSNP138_example.vcf.gz", package = "bedr")
singleSample.vcf.example &lt;- system.file("extdata/singleSampleOICR_example.vcf.gz", package = "bedr")
multiSample.vcf.example  &lt;- system.file("extdata/multiSampleOICR_example.vcf.gz", package = "bedr")

# read a subset of NCBI clinVar vcf.  Note this has no samples.
vcf1.a &lt;- read.vcf(clinVar.vcf.example)
vcf1.b &lt;- read.vcf(clinVar.vcf.example, split.info = TRUE)

## Not run: 

# same as above but split multiple samples
vcf1.c &lt;- read.vcf(clinVar.vcf.example, split.info = TRUE, split.sample = TRUE) 

# read a single-sample VCF
system.time(
  vcf2.a &lt;- read.vcf(singleSample.vcf.example, split.info = TRUE, split.sample = TRUE)
  )

# read a multi-sample VCF
vcf3.a &lt;- read.vcf(multiSample.vcf.example, split.info = FALSE, split.sample = TRUE);

# multi core example
options("cores"=9);
vcf2.a &lt;- read.vcf(singleSample.vcf.example, split.info = TRUE, split.sample = TRUE)
options("cores"=1);


## End(Not run)
</code></pre>

<hr>
<h2 id='reldist'>
Calculate the relative distance between two sets of intervals
</h2><span id='topic+reldist'></span>

<h3>Description</h3>

<p>Calculate the relative distance between two sets of intervals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reldist(
	x,
	y,
	detail = FALSE,
	check.zero.based = TRUE,
	check.chr = TRUE,
	check.valid = TRUE,
	check.sort =TRUE,
	check.merge = TRUE,
	verbose = TRUE
	)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reldist_+3A_x">x</code></td>
<td>
<p>firt region to be compared</p>
</td></tr>
<tr><td><code id="reldist_+3A_y">y</code></td>
<td>
<p>second region to be compared</p>
</td></tr>
<tr><td><code id="reldist_+3A_detail">detail</code></td>
<td>
<p>should the relative distance be printed for every region</p>
</td></tr>
<tr><td><code id="reldist_+3A_check.zero.based">check.zero.based</code></td>
<td>
<p>should 0 based coordinates be checked</p>
</td></tr>
<tr><td><code id="reldist_+3A_check.chr">check.chr</code></td>
<td>
<p>should chr prefix be checked</p>
</td></tr>
<tr><td><code id="reldist_+3A_check.valid">check.valid</code></td>
<td>
<p>should the region be checkded for integerity</p>
</td></tr>
<tr><td><code id="reldist_+3A_check.sort">check.sort</code></td>
<td>
<p> should regions be checked for sort order</p>
</td></tr>
<tr><td><code id="reldist_+3A_check.merge">check.merge</code></td>
<td>
<p> should overlapping regions be checked</p>
</td></tr>
<tr><td><code id="reldist_+3A_verbose">verbose</code></td>
<td>
<p>should log messages and checking take place</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The frequency of relative distances in bins spanning 0 to 0.5
</p>


<h3>Author(s)</h3>

<p>Daryl Waggott
</p>


<h3>References</h3>

<p><a href="http://bedtools.readthedocs.org/en/latest/content/tools/reldist.html">http://bedtools.readthedocs.org/en/latest/content/tools/reldist.html</a>
</p>


<h3>See Also</h3>

<p>jaccard
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (check.binary("bedtools")) {

index &lt;- get.example.regions();

a &lt;- index[[1]];
b &lt;- index[[2]];
a &lt;- bedr(engine = "bedtools", input = list(i = a), method = "sort", params = "");
b &lt;- bedr(engine = "bedtools", input = list(i = b), method = "sort", params = "");
reldist(a,b);

}
</code></pre>

<hr>
<h2 id='size.region'>
Get region size
</h2><span id='topic+size.region'></span>

<h3>Description</h3>

<p>Get region size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>size.region(
	x, 
	zero.based = TRUE, 
	check.zero.based = TRUE, 
	check.chr = TRUE, 
	check.valid = TRUE, 
	verbose = TRUE
	)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="size.region_+3A_x">x</code></td>
<td>
<p>region in vector, matrix or dataframe format</p>
</td></tr>
<tr><td><code id="size.region_+3A_zero.based">zero.based</code></td>
<td>
<p>whether the coordinates are zero-based or 1</p>
</td></tr>
<tr><td><code id="size.region_+3A_check.zero.based">check.zero.based</code></td>
<td>
<p>should 0 based coordinates be checked</p>
</td></tr>
<tr><td><code id="size.region_+3A_check.chr">check.chr</code></td>
<td>
<p>should chr prefix be checked</p>
</td></tr>
<tr><td><code id="size.region_+3A_check.valid">check.valid</code></td>
<td>
<p>should the region be checked for integerity</p>
</td></tr>
<tr><td><code id="size.region_+3A_verbose">verbose</code></td>
<td>
<p>messages and checks</p>
</td></tr>
</table>


<h3>Value</h3>

<p>size/length of the region
</p>


<h3>Author(s)</h3>

<p>Daryl Waggott
</p>


<h3>See Also</h3>

<p>convert2bed
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (check.binary("bedtools")) {

index &lt;- get.example.regions();

a &lt;- index[[1]];

a.sizes &lt;- bedr:::size.region(a);
}
</code></pre>

<hr>
<h2 id='strsplit2matrix'>
split a vector of strings into tabular data
</h2><span id='topic+strsplit2matrix'></span>

<h3>Description</h3>

<p>split a vector of strings into tabular data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strsplit2matrix(x, split, fixed = FALSE, perl = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="strsplit2matrix_+3A_x">x</code></td>
<td>
<p>a character vector
</p>
</td></tr>
<tr><td><code id="strsplit2matrix_+3A_split">split</code></td>
<td>
<p>the character or regex to split on</p>
</td></tr>
<tr><td><code id="strsplit2matrix_+3A_fixed">fixed</code></td>
<td>
<p>fixed i.e. no regex</p>
</td></tr>
<tr><td><code id="strsplit2matrix_+3A_perl">perl</code></td>
<td>
<p>per style</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daryl Waggott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  a.bed &lt;- strSplitToMatrix(x);
  
## End(Not run)
</code></pre>

<hr>
<h2 id='tabix'>
Main bedtools wrapper function.
</h2><span id='topic+tabix'></span>

<h3>Description</h3>

<p>Main bedtools wrapper function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tabix(
	region,
	file.name,
	params = NULL,
	tmpDir = NULL,
	deleteTmpDir = TRUE,
	outputDir = NULL,
	outputFile = NULL,
	check.zero.based = TRUE,
	check.chr = TRUE,
	check.valid = TRUE,
	check.sort = TRUE,
	check.merge = TRUE,
	verbose = TRUE
	)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tabix_+3A_region">region</code></td>
<td>
<p>The regions to query the tabix'd file</p>
</td></tr>
<tr><td><code id="tabix_+3A_file.name">file.name</code></td>
<td>
<p>The name of the bzipped/indexed tabix file to query</p>
</td></tr>
<tr><td><code id="tabix_+3A_params">params</code></td>
<td>
<p>A string that includes all the extra parameters and arguments to the bedtools commmand.  For example if you wanted to do a left outer join you would specificy method as intersect and use params = c(&quot;-loj -header&quot;). If you leave input and method as defaults then this is this string represents the full command.</p>
</td></tr>
<tr><td><code id="tabix_+3A_tmpdir">tmpDir</code></td>
<td>
<p>The directory to be used for writing files</p>
</td></tr>
<tr><td><code id="tabix_+3A_deletetmpdir">deleteTmpDir</code></td>
<td>
<p>Should tmp files be deleted.  helpful for diagnostics.</p>
</td></tr>
<tr><td><code id="tabix_+3A_outputdir">outputDir</code></td>
<td>
<p>The output directory.  Only used if outputFile is specified.  It defaults to the current working directory.</p>
</td></tr>
<tr><td><code id="tabix_+3A_outputfile">outputFile</code></td>
<td>
<p>The name of the output file.  If this is specified the output will be sent to a file not an R object</p>
</td></tr>
<tr><td><code id="tabix_+3A_check.chr">check.chr</code></td>
<td>
<p>check for chr prefix</p>
</td></tr>
<tr><td><code id="tabix_+3A_check.zero.based">check.zero.based</code></td>
<td>
<p>check for zero based coordinates</p>
</td></tr>
<tr><td><code id="tabix_+3A_check.valid">check.valid</code></td>
<td>
<p>do all region integrity checks</p>
</td></tr>
<tr><td><code id="tabix_+3A_check.sort">check.sort</code></td>
<td>
<p>check if region is sorted</p>
</td></tr>
<tr><td><code id="tabix_+3A_check.merge">check.merge</code></td>
<td>
<p>check if region is  merged</p>
</td></tr>
<tr><td><code id="tabix_+3A_verbose">verbose</code></td>
<td>
<p>Should messages be printed to screen.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output of command with some parsing to keep it consistent with the input. 
</p>


<h3>Author(s)</h3>

<p>Daryl Waggott
</p>


<h3>See Also</h3>

<p>genomicRanges
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (check.binary("tabix")) {
query.regions &lt;- c("1:1000-100000", "1:1000000-1100000")
cosmic.vcf.example &lt;- system.file(
	"extdata/CosmicCodingMuts_v66_20130725_ex.vcf.gz",
	package = "bedr"
	)
cosmic.query &lt;- tabix(query.regions, cosmic.vcf.example, check.chr = FALSE)
}
</code></pre>

<hr>
<h2 id='table2venn'>
Plot venn diagram
</h2><span id='topic+table2venn'></span>

<h3>Description</h3>

<p>Plot venn diagram of regions intersect
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table2venn(x, var.names)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="table2venn_+3A_x">x</code></td>
<td>
<p>intersect table of regions</p>
</td></tr>
<tr><td><code id="table2venn_+3A_var.names">var.names</code></td>
<td>
<p>names of the overlapping regions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>venn diagram input list
</p>


<h3>Author(s)</h3>

<p>Daryl Waggott
</p>


<h3>See Also</h3>

<p>bedr.plot.region
</p>

<hr>
<h2 id='test.region.similarity'>
Compare sets of regions via jaccard and relative distance using permutation
</h2><span id='topic+test.region.similarity'></span>

<h3>Description</h3>

<p>Compare sets of regions via jaccard and relative distance using permutation to get an empirical p-value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.region.similarity(
	x,
	y,
	n = 1000,
	stratify.by.chr = FALSE,
	species = "human",
	build = "hg19",
	mask.gaps = FALSE,
	mask.repeats = FALSE,
	gaps.file = NULL,
	repeats.file = NULL,
	check.zero.based = TRUE,
	check.chr = TRUE,
	check.valid = TRUE,
	verbose = TRUE
	)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test.region.similarity_+3A_x">x</code></td>
<td>
<p>first region to be compared. this is the region that is permuted</p>
</td></tr>
<tr><td><code id="test.region.similarity_+3A_y">y</code></td>
<td>
<p>second region to be compared</p>
</td></tr>
<tr><td><code id="test.region.similarity_+3A_n">n</code></td>
<td>
<p>the number of iterations to permute</p>
</td></tr>
<tr><td><code id="test.region.similarity_+3A_stratify.by.chr">stratify.by.chr</code></td>
<td>
<p>Should the permutation be happen separetely for each chromosome.  That is are chromosomes exchangeable.</p>
</td></tr>
<tr><td><code id="test.region.similarity_+3A_species">species</code></td>
<td>
<p>species</p>
</td></tr>
<tr><td><code id="test.region.similarity_+3A_build">build</code></td>
<td>
<p>the build of the reference</p>
</td></tr>
<tr><td><code id="test.region.similarity_+3A_mask.gaps">mask.gaps</code></td>
<td>
<p>should the gaps (Ns) in the human reference be ignored as potential start points.  This drammatically increases memory and run time but is more appropriate in almost all settings.  By default it's off.</p>
</td></tr>
<tr><td><code id="test.region.similarity_+3A_mask.repeats">mask.repeats</code></td>
<td>
<p>should the repeats from repeatMasker be ignored as potential start points.  This drammatically increases memory and run time but is more appropriate in almost all settings.  By default it's off.</p>
</td></tr>
<tr><td><code id="test.region.similarity_+3A_gaps.file">gaps.file</code></td>
<td>
<p>database file of gaps. Defaults to Homo sapiens Hg19 gap.txt.gz file available through UCSC</p>
</td></tr>
<tr><td><code id="test.region.similarity_+3A_repeats.file">repeats.file</code></td>
<td>
<p>database file of repeats as supplied by UCSC containing RepMasker data e.g rmsk.txt.gz</p>
</td></tr>
<tr><td><code id="test.region.similarity_+3A_check.zero.based">check.zero.based</code></td>
<td>
<p>should 0 based coordinates be checked</p>
</td></tr>
<tr><td><code id="test.region.similarity_+3A_check.chr">check.chr</code></td>
<td>
<p>should chr prefix be checked</p>
</td></tr>
<tr><td><code id="test.region.similarity_+3A_check.valid">check.valid</code></td>
<td>
<p>should the region be checkded for integerity</p>
</td></tr>
<tr><td><code id="test.region.similarity_+3A_verbose">verbose</code></td>
<td>
<p>should log messages and checking take place</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Iteratively permutes intervals and recalculates jaccard and reldist statistics.
</p>


<h3>Value</h3>

<p>A list of results
</p>


<h3>Author(s)</h3>

<p>Daryl Waggott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (check.binary("bedtools")) {

index &lt;- get.example.regions();

a &lt;- index[[1]];
b &lt;- index[[2]];
a &lt;- bedr(engine = "bedtools", input = list(i = a), method = "sort", params = "");
b &lt;- bedr(engine = "bedtools", input = list(i = b), method = "sort", params = "");

# a simple example
test.region.similarity(a, b, n = 8)

# note you can set the cores available to parallelize
options(cores = 4);
system.time(test.region.similarity(a, b, n = 8));

# a real example comparing the distribution of mRNA vs ncRNA genes in RefSeq
## Not run: 

# more core
options(cores = 8);

# load refgene
refgene &lt;- query.ucsc("refGene")
refgene &lt;- refgene[,c("chrom","txStart","txEnd","name","name2","strand")]

# only include canonical chr
chr &lt;- paste0("chr", c(1:22,"X","Y")); 
refgene &lt;- refgene[refgene$chrom 

# remove genes with multiple positions
duplicated.gene &lt;- duplicated(refgene$name2) | duplicated(rev(refgene$name2));
refgene &lt;- refgene[!duplicated.gene,];

# only select pr coding genes
refgene.nm &lt;- refgene[grepl("^NM",refgene$name),];
# only select non protein coding rna genes	
refgene.nr &lt;- refgene[grepl("^NR",refgene$name),];

# sort and merge
refgene.nm &lt;- bedr.snm.region(refgene.nm,check.chr = FALSE);
refgene.nr &lt;- bedr.snm.region(refgene.nr,check.chr = FALSE);

test.region.similarity(refgene.nm, refgene.nr, mask.unmapped = TRUE );

option(core = 1)

## End(Not run)

}

</code></pre>

<hr>
<h2 id='vcf2bed'>
convert a vcf to a bed file
</h2><span id='topic+vcf2bed'></span>

<h3>Description</h3>

<p>Convert a vcf to a bed file.  Currently, it needs to read into R via read.vcf
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vcf2bed(x, filename = NULL, header = FALSE, other = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vcf2bed_+3A_x">x</code></td>
<td>
<p>a vcf object</p>
</td></tr>
<tr><td><code id="vcf2bed_+3A_filename">filename</code></td>
<td>
<p>the name of file if you want it exported</p>
</td></tr>
<tr><td><code id="vcf2bed_+3A_header">header</code></td>
<td>
<p>indicate if the bed file has header or not when exported</p>
</td></tr>
<tr><td><code id="vcf2bed_+3A_other">other</code></td>
<td>
<p>fields to include apart from chr, start, end.</p>
</td></tr>
<tr><td><code id="vcf2bed_+3A_verbose">verbose</code></td>
<td>
<p>more words</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A bed styled R object or an external file
</p>


<h3>Author(s)</h3>

<p>Daryl Waggott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>clinVar.vcf.example &lt;- system.file("extdata/clinvar_dbSNP138_example.vcf.gz", package = "bedr")
x &lt;- read.vcf(clinVar.vcf.example)
x.bed &lt;- vcf2bed(x)
</code></pre>

<hr>
<h2 id='write.vcf'>
write a vcf object
</h2><span id='topic+write.vcf'></span>

<h3>Description</h3>

<p>write a vcf object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.vcf(x, filename = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write.vcf_+3A_x">x</code></td>
<td>
<p>a vcf object</p>
</td></tr>
<tr><td><code id="write.vcf_+3A_filename">filename</code></td>
<td>
<p>a filename</p>
</td></tr>
<tr><td><code id="write.vcf_+3A_verbose">verbose</code></td>
<td>
<p>more words</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input needs to be a vcf object.  This 
</p>


<h3>Value</h3>

<p>A vcf file
</p>


<h3>Author(s)</h3>

<p>Daryl Waggott
</p>


<h3>References</h3>

<p>vcf format specifications
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
vcf  &lt;- read.vcf(system.file("extdata/clinvar_dbSNP138_example.vcf.gz", package = "bedr"));
vcf$header &lt;- c(vcf$header, NOTE="vcf processed by bedr")

## Not run: 
  write.vcf(vcf, filename = paste(tempdir(), "/bedr.example.vcf", sep = ""));
  
## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
