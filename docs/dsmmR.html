<!DOCTYPE html><html><head><title>Help for package dsmmR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dsmmR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#create_sequence'><p>Simulate a sequence for states of choice.</p></a></li>
<li><a href='#dsmmR-package'><p>dsmmR : Estimation and Simulation of Drifting Semi-Markov Models</p></a></li>
<li><a href='#fit_dsmm'><p>Estimation of a drifting semi-Markov chain</p></a></li>
<li><a href='#get_kernel'><p>Obtain the Drifting semi-Markov kernel</p></a></li>
<li><a href='#is.dsmm'><p>Check if an object has a valid <code>dsmm</code> class</p></a></li>
<li><a href='#is.dsmm_fit_nonparametric'><p>Check if an object has a valid <code>dsmm_fit_nonparametric</code> class</p></a></li>
<li><a href='#is.dsmm_fit_parametric'><p>Check if an object has a valid <code>dsmm_fit_parametric</code> class</p></a></li>
<li><a href='#is.dsmm_nonparametric'><p>Check if an object has a valid <code>dsmm_nonparametric</code> class</p></a></li>
<li><a href='#is.dsmm_parametric'><p>Check if an object has a valid <code>dsmm_parametric</code> class</p></a></li>
<li><a href='#lambda'><p>lambda genome</p></a></li>
<li><a href='#nonparametric_dsmm'><p>Non-parametric Drifting semi-Markov model specification</p></a></li>
<li><a href='#parametric_dsmm'><p>Parametric Drifting semi-Markov model specification</p></a></li>
<li><a href='#simulate.dsmm'><p>Simulate a sequence under a drifting semi-Markov kernel.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Estimation and Simulation of Drifting Semi-Markov Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-31</td>
</tr>
<tr>
<td>Description:</td>
<td>Performs parametric and non-parametric estimation and simulation of 
    drifting semi-Markov processes. The definition of parametric and non-parametric
    model specifications is also possible. Furthermore, three different types of
    drifting semi-Markov models are considered. These models differ in the number
    of transition matrices and sojourn time distributions used for the computation
    of a number of semi-Markov kernels, which in turn characterize the drifting 
    semi-Markov kernel. For the parametric model estimation and specification, 
    several discrete distributions are considered for the sojourn times: Uniform,
    Poisson, Geometric, Discrete Weibull and Negative Binomial. The non-parametric
    model specification makes no assumptions about the shape of the sojourn time
    distributions. Semi-Markov models are described in:
    Barbu, V.S., Limnios, N. (2008) &lt;<a href="https://doi.org/10.1007%2F978-0-387-73173-5">doi:10.1007/978-0-387-73173-5</a>&gt;.
    Drifting Markov models are described in:
    Vergne, N. (2008) &lt;<a href="https://doi.org/10.2202%2F1544-6115.1326">doi:10.2202/1544-6115.1326</a>&gt;.
    Reliability indicators of Drifting Markov models are described in:
    Barbu, V. S., Vergne, N. (2019) &lt;<a href="https://doi.org/10.1007%2Fs11009-018-9682-8">doi:10.1007/s11009-018-9682-8</a>&gt;. 
    We acknowledge the DATALAB Project
    <a href="https://lmrs-num.math.cnrs.fr/projet-datalab.html">https://lmrs-num.math.cnrs.fr/projet-datalab.html</a> (financed by the
    European Union with the European Regional Development fund (ERDF) and by
    the Normandy Region) and the HSMM-INCA Project (financed by the French
    Agence Nationale de la Recherche (ANR) under grant ANR-21-CE40-0005).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>Imports:</td>
<td>DiscreteWeibull</td>
</tr>
<tr>
<td>Suggests:</td>
<td>utils, knitr, rmarkdown</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Author:</td>
<td>Vlad Stefan Barbu <a href="https://orcid.org/0000-0002-0840-016X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Ioannis Mavrogiannis [aut, cre],
  Nicolas Vergne [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ioannis Mavrogiannis &lt;mavrogiannis.ioa@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-01 09:12:50 UTC; ioann</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-01 11:00:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='create_sequence'>Simulate a sequence for states of choice.</h2><span id='topic+create_sequence'></span>

<h3>Description</h3>

<p>This is a wrapper function around <code>sample()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_sequence(states, len = 5000, probs = NULL, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_sequence_+3A_states">states</code></td>
<td>
<p>Character vector of unique values. If given the value
&quot;DNA&quot; the values c(&quot;a&quot;, &quot;c&quot;, &quot;g&quot;, &quot;t&quot;) are given instead.</p>
</td></tr>
<tr><td><code id="create_sequence_+3A_len">len</code></td>
<td>
<p>Optional. Positive integer with the default value
equal to 5000.</p>
</td></tr>
<tr><td><code id="create_sequence_+3A_probs">probs</code></td>
<td>
<p>Optional. Numeric vector with values interpreted as
probabilities for each of the states in <code>states</code>. Default value
is equal to 1 over the number of states given, for every state.</p>
</td></tr>
<tr><td><code id="create_sequence_+3A_seed">seed</code></td>
<td>
<p>Optional. Object specifying the initialization of the random
number generator (see more in <code><a href="base.html#topic+set.seed">set.seed</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character sequence of length <code>len</code>.
</p>


<h3>See Also</h3>

<p>For the simulation of a sequence with a drifting semi-Markov kernel:
<a href="#topic+simulate.dsmm">simulate.dsmm</a>.
</p>
<p>The original function: <code><a href="base.html#topic+sample">sample</a></code>.
</p>
<p>About random number generation in R: <code><a href="base.html#topic+RNG">RNG</a></code>.
</p>
<p>For the theoretical background of drifting semi-Markov models: <a href="#topic+dsmmR">dsmmR</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This is equal to having the argument `probs = c(1/4, 1/4, 1/4, 1/4)`.
rand_dna_seq &lt;- create_sequence(states = "DNA")
table(rand_dna_seq)

random_letters &lt;- sample(letters, size = 5, replace = FALSE)
rand_dna_seq2 &lt;- create_sequence(
    states = random_letters,
    probs = c(0.6, 0.3, 0.05, 0.025, 0.025),
    len = 10000)
table(rand_dna_seq2)
</code></pre>

<hr>
<h2 id='dsmmR-package'>dsmmR : Estimation and Simulation of Drifting Semi-Markov Models</h2><span id='topic+dsmmR'></span><span id='topic+dsmmR-package'></span>

<h3>Description</h3>

<p>Performs parametric and non-parametric estimation and simulation
of drifting semi-Markov processes. The definition of parametric and
non-parametric model specifications is also possible. Furthermore, three
different types of drifting semi-Markov models are considered. These models
differ in the number of transition matrices and sojourn time distributions
used for the computation of a number of semi-Markov kernels, which in turn
characterize the drifting semi-Markov kernel.
</p>


<h3>Details</h3>

<p><strong>Introduction</strong>
</p>
<p>The difference between the Markov models and the semi-Markov models
concerns the modelling of the sojourn time distributions.
The Markov models (in discrete time) are modelled by a sojourn time
following the Geometric distribution. The semi-Markov models
are able to have a sojourn time distribution of arbitrary shape.
The further difference with a <em>drifting</em> semi-Markov model,
is that we have <code class="reqn">d + 1</code> (arbitrary) sojourn time distributions
and <code class="reqn">d + 1</code> transition matrices (Model 1),
where <code class="reqn">d</code> is defined as the polynomial degree.
Through them, we compute <code class="reqn">d + 1</code> semi-Markov kernels.
In this work, we also consider the possibility for obtaining these
semi-Markov kernels with <code class="reqn">d + 1</code> transition matrices and <code class="reqn">1</code>
sojourn time distribution (Model 2) or <code class="reqn">d + 1</code> sojourn time
distributions and <code class="reqn">1</code> transition matrix (Model 3).
</p>
<p><strong>Definition</strong>
</p>
<p>Drifting semi-Markov processes are particular non-homogeneous semi-Markov
chains for which the drifting semi-Markov kernel
<code class="reqn">q_{\frac{t}{n}}(u,v,l)</code> is defined as
the probability that, given at the instance <code class="reqn">t</code>
the previous state is <code class="reqn">u</code>, the next state state <code class="reqn">v</code> will be
reached with a sojourn time of <code class="reqn">l</code>:
</p>
<p style="text-align: center;"><code class="reqn">q_{\frac{t}{n}}(u,v,l) = P(J_{t}=v,X_{t}=l|J_{t-1}=u),</code>
</p>

<p>where <code class="reqn">n</code> is the model size, defined as the length of the
embedded Markov chain <code class="reqn">(J_{t})_{t\in \{0,\dots,n\}}</code> minus the
last state, where <code class="reqn">J_{t}</code> is the state at the instant <code class="reqn">t</code> and
<code class="reqn">X_{t}=S_{t}-S_{t-1}</code> is the sojourn time of the state <code class="reqn">J_{t-1}</code>.
</p>
<p>The drifting semi-Markov kernel <code class="reqn">q_{\frac{t}{n}}</code>
is a linear combination of the product of <code class="reqn">d + 1</code> semi-Markov kernels
<code class="reqn">q_{\frac{i}{d}}</code>, where every semi-Markov kernel is the product of
a transition matrix <code class="reqn">p</code> and a sojourn time distribution
<code class="reqn">f</code>. We define the situation when both <code class="reqn">p</code> and
<code class="reqn">f</code> are &quot;drifting&quot; between <code class="reqn">d + 1</code> fixed points of the model
as Model 1, and thus we will use the exponential <code class="reqn">(1)</code> as a way to
refer to the drifting semi-Markov kernel
<code class="reqn">q_{\frac{t}{n}}^{\ (1)}</code> and corresponding
semi-Markov kernels <code class="reqn">q_{\frac{i}{d}}^{\ (1)}</code> in this case.
For Model 2, we allow the transition matrix <code class="reqn">p</code> to drift
but not the sojourn time distributions <code class="reqn">f</code>, and for Model 3 we allow
the sojourn time distributions <code class="reqn">f</code> to drift but not the transition
matrix <code class="reqn">p</code>.
The exponential <code class="reqn">(2)</code> or <code class="reqn">(3)</code> will be used for signifying
Model 2 or Model 3, respectively.
In the general case an exponential will not be used.
</p>
<p><strong><em>Model 1</em></strong>
</p>
<p>Both <code class="reqn">p</code> and <code class="reqn">f</code> are drifting in this case.
Thus, the drifting semi-Markov kernel <code class="reqn">q_{\frac{t}{n}}^{\ (1)}</code> is a
linear combination of the product of <code class="reqn">d + 1</code> semi-Markov kernels
<code class="reqn">q_{\frac{i}{d}}^{\ (1)}</code>, which are given by:
</p>
<p style="text-align: center;"><code class="reqn">q_{\frac{i}{d}}^{\ (1)}(u,v,l)=
{p_{\frac{i}{d}}(u,v)}{f_{\frac{i}{d}}(u,v,l)},</code>
</p>

<p>where for <code class="reqn">i = 0,\dots,d</code> we have <code class="reqn">d + 1</code> Markov transition matrices
<code class="reqn">p_{\frac{i}{d}}(u,v)</code>
of the embedded Markov chain <code class="reqn">(J_{t})_{t\in \{0,\dots,n\}}</code>,
and <code class="reqn">d + 1</code> sojourn time distributions
<code class="reqn">f_{\frac{i}{d}}(u,v,l)</code>. Therefore, the drifting semi-Markov kernel
is described as:
</p>
<p style="text-align: center;"><code class="reqn">q_{\frac{t}{n}}^{\ (1)}(u,v,l)
= \sum_{i = 0}^{d}A_{i}(t)\ q_{\frac{i}{d}}^{\ (1)}(u,v,l)
= \sum_{i = 0}^{d}A_{i}(t)\ p_{\frac{i}{d}}(u,v)f_{\frac{i}{d}}(u,v,l),</code>
</p>

<p>where <code class="reqn">A_i, i = 0, \dots, d</code> are <code class="reqn">d + 1</code> polynomials with degree
<code class="reqn">d</code>, which satisfy the conditions:
</p>
<p style="text-align: center;"><code class="reqn">\sum_{i=0}^{d}A_{i}(t) = 1,</code>
</p>

<p style="text-align: center;"><code class="reqn">A_i \left(\frac{nj}{d} \right)= 1_{\{i=j\}},</code>
</p>

<p>where the indicator function <code class="reqn">1_{\{i=j\}} = 1</code>,
if <code class="reqn">i = j</code>, <code class="reqn">0</code> otherwise.
</p>
<p><strong><em>Model 2</em></strong>
</p>
<p>In this case, <code class="reqn">p</code> is drifting and <code class="reqn">f</code> <strong>is not drifting</strong>.
Therefore, the drifting semi-Markov kernel is now described as:
</p>
<p style="text-align: center;"><code class="reqn">q_{\frac{t}{n}}^{\ (2)}(u,v,l)
= \sum_{i = 0}^{d}A_{i}(t)\ q_{\frac{i}{d}}^{\ (2)}(u,v,l)
= \sum_{i = 0}^{d}A_{i}(t)\ p_{\frac{i}{d}}(u,v)f(u,v,l).</code>
</p>

<p><strong><em>Model 3</em></strong>
</p>
<p>In this case, <code class="reqn">f</code> is drifting and <code class="reqn">p</code> <strong>is not drifting</strong>.
Therefore, the drifting semi-Markov Kernel is now described as:
</p>
<p style="text-align: center;"><code class="reqn">q_{\frac{t}{n}}^{\ (3)}(u,v,l)
= \sum_{i = 0}^{d}A_{i}(t)\ q_{\frac{i}{d}}^{\ (3)}(u,v,l)
= \sum_{i = 0}^{d}A_{i}(t)\ p(u,v)f_{\frac{i}{d}}(u,v,l).</code>
</p>

<p><strong>Parametric and non-parametric model specifications</strong>
</p>
<p>In this package, we can define parametric and non-parametric drifting
semi-Markov models.
</p>
<p>For the <em>parametric</em> case, several discrete distributions are
considered for the modelling of the sojourn times:
Uniform, Geometric, Poisson, Discrete Weibull and Negative Binomial.
This is done from the function
<code>parametric_dsmm</code> which returns an object of the
S3 class (<code>dsmm_parametric</code>, <code>dsmm</code>).
</p>
<p>The <em>non-parametric</em> model specification concerns the sojourn
time distributions when no assumptions are done about the
shape of the distributions. This is done through the function called
<code>nonparametric_dsmm()</code>, that returns an object of class
(<code>dsmm_nonparametric</code>, <code>dsmm</code>).
</p>
<p>It is also possible to proceed with a parametric or non-parametric
estimation for a model on an existing sequence through the function
<code>fit_dsmm()</code>, which returns an object with the S3 class
(<code>dsmm_fit_parametric</code>, <code>dsmm</code>) or
(<code>dsmm_fit_nonparametric</code>, <code>dsmm</code>) respectively, depending
on the given argument <code>estimation = "parametric"</code> or
<code>estimation = "nonparametric"</code> .
</p>
<p>Therefore, the <code>dsmm</code> class acts like a wrapper class
for drifting semi-Markov model specifications, while the classes
<code>dsmm_fit_parametric</code>, <code>dsmm_fit_nonparametric</code>,
<code>dsmm_parametric</code> and <code>dsmm_nonparametric</code>
are exclusive to the functions that create the corresponding models,
and inherit methods from the <code>dsmm</code> class.
</p>
<p>In summary, based on an <code>dsmm</code> object
it is possible to use the following methods:
</p>

<ul>
<li><p> Simulate a sequence through the function <code>simulate.dsmm()</code>.
</p>
</li>
<li><p> Get the drifting semi-Markov kernel
<code class="reqn">q_{\frac{t}{n}}(u,v,l)</code>, for any choice of <code class="reqn">u,v,l</code> or <code class="reqn">t</code>,
through the function <code>get_kernel()</code>.
</p>
</li></ul>

<p><strong>Restrictions</strong>
</p>
<p>The following restrictions must be satisfied for every drifting semi-Markov model:
</p>

<ul>
<li><p> The drifting semi-Markov kernel <code class="reqn">q_{\frac{t}{n}}(u,v,l)</code>,
for every <code class="reqn">t \in \{ 0, \dots, n \}</code> and <code class="reqn">u \in E</code>, has its sums
over <code class="reqn">v</code> and <code class="reqn">l</code>, equal to <code class="reqn">1</code>:
</p>
<p style="text-align: center;"><code class="reqn">
  \sum_{v \in E}\sum_{l = 1}^{+\infty}q_{\frac{t}{n}}(u,v,l)
  = \sum_{v \in E}\sum_{l = 1}^{+\infty}A_{i}(t)\ q_{\frac{i}{d}}(u,v,l)
  = 1.</code>
</p>

</li>
<li><p> Therefore, we also get that for every <code class="reqn">i \in \{0, \dots, d\}</code> and
<code class="reqn">u \in E</code>, the semi-Markov kernel <code class="reqn">q_{\frac{i}{d}}(u,v,l)</code>
has its sums over <code class="reqn">v</code> and <code class="reqn">l</code> equal to <code class="reqn">1</code>:
</p>
<p style="text-align: center;"><code class="reqn">\sum_{v \in E}\sum_{l = 1}^{+\infty}q_{\frac{i}{d}}(u,v,l)
  = 1.</code>
</p>

</li>
<li><p> Lastly, like in semi-Markov models, we do not allow sojourn times
equal to <code class="reqn">0</code> or passing into the same state:
</p>
<p style="text-align: center;"><code class="reqn">q_{\frac{t}{n}}(u,v,0) = 0, \forall u,v \in E,</code>
</p>

<p style="text-align: center;"><code class="reqn">q_{\frac{t}{n}}(u,u,l) = 0, \forall u\in E,l\in\{1,\dots,+\infty\}.</code>
</p>

</li></ul>

<p><strong>Model specification restrictions</strong>
</p>
<p>When we define a drifting semi-Markov model specification through the
functions <code>parametric_dsmm</code> or <code>nonparametric_dsmm</code>,
the following restrictions need to be satisfied.
</p>
<p><strong><em>Model 1</em></strong>
</p>
<p>The semi-Markov kernels are equal to
<code class="reqn">q_{\frac{i}{d}}^{\ (1)}(u,v,l) =
p_{\frac{i}{d}}(u,v)f_{\frac{i}{d}}(u,v,l)</code>. Therefore,
<code class="reqn">\forall u \in E</code> the sums
of <code class="reqn">p_{\frac{i}{d}}(u,v)</code> over <code class="reqn">v</code> and the sums of
<code class="reqn">f_{\frac{i}{d}}(u,v,l)</code> over <code class="reqn">l</code> must be
equal to 1:
</p>
<p style="text-align: center;"><code class="reqn">\sum_{v \in E} p_{\frac{i}{d}}(u,v) = 1,</code>
</p>

<p style="text-align: center;"><code class="reqn">\sum_{l = 1}^{+\infty }f_{\frac{i}{d}}(u,v,l) = 1.</code>
</p>

<p><strong><em>Model 2</em></strong>
</p>
<p>The semi-Markov kernels are equal to <code class="reqn">q_{\frac{i}{d}}^{\ (2)}(u,v,l) =
  p_{\frac{i}{d}}(u,v)f(u,v,l)</code>. Therefore, <code class="reqn">\forall u \in E</code>
the sums of <code class="reqn">p_{\frac{i}{d}}(u,v)</code> over <code class="reqn">v</code> and
the sums of <code class="reqn">f(u,v,l)</code> over <code class="reqn">l</code> must be equal to 1:
</p>
<p style="text-align: center;"><code class="reqn">\sum_{v \in E} p_{\frac{i}{d}}(u,v) = 1,</code>
</p>

<p style="text-align: center;"><code class="reqn">\sum_{l = 1}^{+\infty }f(u,v,l) = 1.</code>
</p>

<p><strong><em>Model 3</em></strong>
</p>
<p>The semi-Markov kernels are equal to <code class="reqn">q_{\frac{i}{d}}^{\ (3)}(u,v,l) =
  p(u,v)f_{\frac{i}{d}}(u,v,l)</code>. Therefore,
<code class="reqn">\forall u \in E</code> the sums
of <code class="reqn">p(u,v)</code> over <code class="reqn">v</code> and the sums of
<code class="reqn">f_{\frac{i}{d}}(u,v,l)</code> over <code class="reqn">l</code> must be
equal to 1:
</p>
<p style="text-align: center;"><code class="reqn">\sum_{v \in E}p(u,v) = 1,</code>
</p>

<p style="text-align: center;"><code class="reqn">\sum_{l = 1}^{+\infty }f_{\frac{i}{d}}(u,v,l) = 1.</code>
</p>



<h3>Community Guidelines</h3>

<p>For third parties wishing to contribute to the software, or to report issues
or problems about the software, they can do so directly through the
<a href="https://github.com/Mavrogiannis-Ioannis/dsmmR">development github page
of the package</a>.
</p>


<h3>Notes</h3>

<p>Automated tests are in place in order to aid the user with any false input made
and, furthermore, to ensure that the functions used return the expected output.
Moreover, through strict automated tests, it is made possible for the user to
properly define their own <code>dsmm</code> objects and make use of them with the generic
functions of the package.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Ioannis Mavrogiannis <a href="mailto:mavrogiannis.ioa@gmail.com">mavrogiannis.ioa@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Vlad Stefan Barbu
</p>
</li>
<li><p> Ioannis Mavrogiannis
</p>
</li>
<li><p> Nicolas Vergne
</p>
</li></ul>



<h3>References</h3>

<p>Barbu, V. S., Limnios, N. (2008). Semi-Markov Chains and Hidden Semi-Markov
Models Toward Applications - Their Use in Reliability and DNA Analysis.
New York: Lecture Notes in Statistics, vol. 191, Springer.
</p>
<p>Vergne, N. (2008). Drifting Markov models with Polynomial Drift and
Applications to DNA Sequences. Statistical Applications in Genetics
Molecular Biology 7 (1).
</p>
<p>Barbu V. S., Vergne, N. (2019). Reliability and survival analysis for
drifting Markov models: modelling and estimation.
Methodology and Computing in Applied Probability, 21(4), 1407-1429.
</p>
<p>T. Nakagawa and S. Osaki. (1975). The discrete Weibull distribution.
IEEE Transactions on Reliability, R-24, 300-301.
</p>
<p>Sanger, F., Coulson, A. R., Hong, G. F., Hill, D. F., &amp; Petersen, G. B.
(1982). Nucleotide sequence of bacteriophage <code class="reqn">\lambda</code> DNA.
Journal of molecular biology, 162(4), 729-773.
</p>


<h3>See Also</h3>

<p>For the estimation of a drifting semi-Markov model given a sequence:
<a href="#topic+fit_dsmm">fit_dsmm</a>.
</p>
<p>For drifting semi-Markov model specifications:
<a href="#topic+parametric_dsmm">parametric_dsmm</a>, <a href="#topic+nonparametric_dsmm">nonparametric_dsmm</a>.
</p>
<p>For the simulation of sequences:
<a href="#topic+simulate.dsmm">simulate.dsmm</a>, <a href="#topic+create_sequence">create_sequence</a>.
</p>
<p>For the retrieval of the drifting semi-Markov kernel through a
<code>dsmm</code> object: <a href="#topic+get_kernel">get_kernel</a>.
</p>

<hr>
<h2 id='fit_dsmm'>Estimation of a drifting semi-Markov chain</h2><span id='topic+fit_dsmm'></span><span id='topic+dsmm_fit'></span><span id='topic+dsmm_fit_nonparametric'></span><span id='topic+dsmm_fit_parametric'></span>

<h3>Description</h3>

<p>Estimation of a drifting semi-Markov chain,
given one sequence of states. This estimation can be parametric
or non-parametric and is available for
the three types of drifting semi-Markov models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_dsmm(
  sequence,
  degree,
  f_is_drifting,
  p_is_drifting,
  states = NULL,
  initial_dist = "unif",
  estimation = "nonparametric",
  f_dist = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_dsmm_+3A_sequence">sequence</code></td>
<td>
<p>Character vector that represents a sequence of states
from the state space <code class="reqn">E</code>.</p>
</td></tr>
<tr><td><code id="fit_dsmm_+3A_degree">degree</code></td>
<td>
<p>Positive integer that represents the polynomial degree
<code class="reqn">d</code> for the drifting semi-Markov model.</p>
</td></tr>
<tr><td><code id="fit_dsmm_+3A_f_is_drifting">f_is_drifting</code></td>
<td>
<p>Logical. Specifies if <code class="reqn">f</code> is drifting or not.</p>
</td></tr>
<tr><td><code id="fit_dsmm_+3A_p_is_drifting">p_is_drifting</code></td>
<td>
<p>Logical. Specifies if <code class="reqn">p</code> is drifting or not.</p>
</td></tr>
<tr><td><code id="fit_dsmm_+3A_states">states</code></td>
<td>
<p>Character vector that represents the state space
<code class="reqn">E</code>, with length equal to <code class="reqn">s = |E|</code>. Default value is set
equal to the sorted, unique states present in the given sequence.</p>
</td></tr>
<tr><td><code id="fit_dsmm_+3A_initial_dist">initial_dist</code></td>
<td>
<p>Optional. Character that represents the method to
estimate the initial distribution.
</p>

<ul>
<li>
<p><code>"unif"</code> : The initial distribution of each state is
equal to <code class="reqn">1/s</code> (default value).
</p>
</li>
<li>
<p><code>"freq"</code> : The initial distribution of each state is
equal to the frequency that it has in the sequence.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fit_dsmm_+3A_estimation">estimation</code></td>
<td>
<p>Optional. Character. Represents whether the
estimation will be nonparametric or parametric.
</p>

<ul>
<li>
<p><code>"nonparametric"</code> : The estimation will be
non-parametric (default value).
</p>
</li>
<li>
<p><code>"parametric"</code> : The estimation will be
parametric.
</p>
</li></ul>
</td></tr>
<tr><td><code id="fit_dsmm_+3A_f_dist">f_dist</code></td>
<td>
<p>Optional. It can be defined in two ways:
</p>

<ul>
<li><p> If <code>estimation = "nonparametric"</code>, it is
equal to <code>NULL</code> (default value).
</p>
</li>
<li><p> If <code>estimation = "parametric"</code>, it is a
character array that specifies the distributions of the sojourn
times, for every state transition.
The list of possible values is:
<code>["unif", "geom", "pois", "dweibull", "nbinom", NA]</code>.
It can be defined in two ways:
</p>

<ul>
<li>
<p>If <code class="reqn">f</code> <strong>is not</strong> drifting, it has dimensions of
<code class="reqn">s \times s</code>.
</p>
</li>
<li>
<p>If <code class="reqn">f</code> <strong>is</strong> drifting, it has dimensions of
<code class="reqn">s \times s \times (d+1)</code>
(see more in <em>Details, Parametric Estimation</em>.)
</p>
</li></ul>

<p>It is defined similarly to the attribute <code>f_dist</code>
in <a href="#topic+dsmm_parametric">dsmm_parametric</a>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>This function estimates a drifting semi-Markov model in the
parametric and non-parametric case.
The parametric estimation can be achieved by the following steps:
</p>

<ol>
<li><p> We obtain the non-parametric estimation of the sojourn time
distributions.
</p>
</li>
<li><p> We estimate the parameters for the distributions defined in
the attribute <code>f_dist</code> through the probabilities
that were obtained in step 1.
</p>
</li></ol>

<p>Three different models are possible for to be estimated for each case.
A normalization technique is used in order to correct estimation errors
from small sequences.
We will use the exponentials <code class="reqn">(1), (2), (3)</code> to distinguish between
the drifting semi-Markov kernel <code class="reqn">\widehat{q}_{\frac{t}{n}}</code> and the
semi-Markov kernels <code class="reqn">\widehat{q}_\frac{i}{d}</code> used in
Model 1, Model 2, Model 3.
More about the theory of drifting semi-Markov models in <a href="#topic+dsmmR">dsmmR</a>.
</p>
<p><strong>Non-parametric Estimation</strong>
</p>
<p><strong><em>Model 1</em></strong>
</p>
<p>When the transition matrix <code class="reqn">p</code> of the embedded Markov chain
<code class="reqn">(J_{t})_{t\in \{0,\dots,n\}}</code> and
the conditional sojourn time distribution <code class="reqn">f</code> are both drifting,
the drifting semi-Markov kernel can be estimated as:
</p>
<p style="text-align: center;"><code class="reqn">\widehat{q}_{\frac{t}{n}}^{\ (1)}(u,v,l) =
      \sum_{i = 0}^{d}A_{i}(t)\ \widehat{q}_{\frac{i}{d}}^{\ (1)}(u,v,l),</code>
</p>

<p><code class="reqn">\forall t \in \{0,\dots,n\}, \forall u,v\in E,
\forall l \in \{1,\dots, k_{max} \} </code>, where <code class="reqn">k_{max}</code> is the maximum
sojourn time that was observed in the sequence and
<code class="reqn">A_i, i = 0, \dots, d</code> are <code class="reqn">d + 1</code> polynomials with degree
<code class="reqn">d</code> (see <a href="#topic+dsmmR">dsmmR</a>).
</p>
<p>The semi-Markov kernels
<code class="reqn">\widehat{q}_{\frac{i}{d}}^{\ (1)}(u,v,l), i = 0, \dots, d</code>,
are estimated through Least Squares Estimation (LSE) and are obtained
after solving the following system, <code class="reqn">\forall t \in \{0, \dots, n\}</code>,
<code class="reqn">\forall u, v \in E</code> and <code class="reqn">\forall l \in \{1, \dots, k_{max}\}</code>:
</p>
<p style="text-align: center;"><code class="reqn">MJ = P,</code>
</p>

<p>where the matrices are written as:
</p>

<ul>
<li>
<p><code class="reqn">M = (M_{ij})_{i,j \in \{0, \dots, d\} } =
\left(\sum_{t=1}^{n}1_{u}(t)A_{i}(t)A_{j}(t)\right)_{
i,j \in \{0, \dots, d\}}</code>
</p>
</li>
<li>
<p><code class="reqn">J = (J_i)_{i \in \{0, \dots, d\} } =
\left(\widehat{q}_{\frac{i}{d}}^{\ (1)}(u,v,l)\right)_{
i \in \{0, \dots, d\}}
</code>
</p>
</li>
<li>
<p><code class="reqn">P=(P_i)_{i\in \{0, \dots, d\} }=
\left(\sum_{t=1}^{n}1_{uvl}(t)A_{i}(t)\right)_{
i \in \{0, \dots, d\}}
</code>
</p>
</li></ul>

<p>and we use the following indicator functions:
</p>

<ul>
<li>
<p><code class="reqn">1_{u}(t) = 1_{ \{J_{t-1} = u \} } = 1</code>,
if at <code class="reqn">t</code> the previous state is <code class="reqn">u</code>,
<code class="reqn">0</code> otherwise.
</p>
</li>
<li>
<p><code class="reqn">1_{uvl}(t) = 1_{ \{J_{t-1} = u, J_{t} = v, X_{t} = l \} } = 1</code>,
if at <code class="reqn">t</code> the previous state is <code class="reqn">u</code>
with sojourn time <code class="reqn">l</code> and next state <code class="reqn">v</code>, <code class="reqn">0</code> otherwise.
</p>
</li></ul>

<p>In order to obtain the estimations of <code class="reqn">\widehat{p}_{\frac{i}{d}}(u,v)</code>
and <code class="reqn">\widehat{f}_{\frac{i}{d}}(u,v,l)</code>, we use the following formulas:
</p>
<p style="text-align: center;"><code class="reqn">\widehat{p}_{\frac{i}{d}}(u,v) =
    \sum_{l = 1}^{k_{max}}\widehat{q}_{\frac{i}{d}}^{\ (1)}(u,v,l),</code>
</p>

<p style="text-align: center;"><code class="reqn">\widehat{f}_{\frac{i}{d}}(u,v,l) =
    \frac{\widehat{q}_{\frac{i}{d}}^{\ (1)}(u,v,l)}{
         \sum_{l = 1}^{k_{max}}\widehat{q}_{\frac{i}{d}}^{\ (1)}(u,v,l)}.</code>
</p>

<p><strong><em>Model 2</em></strong>
</p>
<p>In this case, <code class="reqn">p</code> is drifting and <code class="reqn">f</code> is not drifting. Therefore,
the estimated drifting semi-Markov kernel will be given by:
</p>
<p style="text-align: center;"><code class="reqn">\widehat{q}_{\frac{t}{n}}^{\ (2)}(u,v,l) =
\sum_{i=0}^{d} A_{i}(t)\ \widehat{q}_{\frac{i}{d}}^{\ (2)}(u,v,l),</code>
</p>

<p><code class="reqn">\forall t \in \{0,\dots,n\}, \forall u,v\in E,
\forall l\in \{1,\dots, k_{max} \}</code>, where <code class="reqn">k_{max}</code> is the maximum
sojourn time that was observed in the sequence and
<code class="reqn">A_i, i = 0, \dots, d</code> are <code class="reqn">d + 1</code> polynomials with degree
<code class="reqn">d</code> (see <a href="#topic+dsmmR">dsmmR</a>).
In order to obtain the estimators <code class="reqn">\widehat{p}</code> and <code class="reqn">\widehat{f}</code>,
we use the estimated semi-Markov kernels
<code class="reqn">\widehat{q}_{\frac{i}{d}}^{\ (1)}</code> from Model 1.
Since <code class="reqn">p</code> is drifting, we define the estimation <code class="reqn">\widehat{p}</code>
the same way as we did in Model 1.
In total, we have the following estimations,
<code class="reqn">\forall u,v \in E, \forall l \in \{1,\dots, k_{max} \}</code>:
</p>
<p style="text-align: center;"><code class="reqn">\widehat{p}_{\frac{i}{d}}(u,v) =
    \sum_{l = 1}^{k_{max}}\widehat{q}_{\frac{i}{d}}^{\ (1)}(u,v,l),</code>
</p>

<p style="text-align: center;"><code class="reqn">\widehat{f}(u,v,l) =
    \frac{\sum_{i=0}^{d}\widehat{q}_{\frac{i}{d}}^{\ (1)}(u,v,l)}{
    \sum_{i=0}^{d}\sum_{l=1}^{k_{max}}\widehat{q}_{\frac{i}{d}}^{\ (1)}(u,v,l)}.</code>
</p>

<p>Thus, the <em>estimated</em> semi-Markov kernels for Model 2,
<code class="reqn">\widehat{q}_{\frac{i}{d}}^{\ (2)}(u,v,l) =
\widehat{p}_{\frac{i}{d}}(u,v)\widehat{f}(u,v,l)</code>, can be written with
regards to the <em>estimated</em> semi-Markov kernels of Model 1,
<code class="reqn">\widehat{q}_{\frac{i}{d}}^{\ (1)}</code>, as in the following:
</p>
<p style="text-align: center;"><code class="reqn">\widehat{q}_{\frac{i}{d}}^{\ (2)}(u,v,l) = \frac{
(\sum_{l=1}^{k_{max}}\widehat{q}_{\frac{i}{d}}^{\ (1)}(u,v,l))
(\sum_{i = 0}^{d}\widehat{q}_{\frac{i}{d}}^{\ (1)}(u,v,l))}{
\sum_{i = 0}^{d}\sum_{l=1}^{k_{max}}\widehat{q}_{\frac{i}{d}}^{\ (1)}(u,v,l)}.</code>
</p>

<p><strong><em>Model 3</em></strong>
</p>
<p>In this case, <code class="reqn">f</code> is drifting and <code class="reqn">p</code> is not drifting. Therefore,
the estimated drifting semi-Markov kernel will be given by:
</p>
<p style="text-align: center;"><code class="reqn">\widehat{q}_{\frac{t}{n}}^{\ (3)}(u,v,l) =
\sum_{i=0}^{d} A_{i}(t)\ \widehat{q}_{\frac{i}{d}}^{\ (3)}(u,v,l),</code>
</p>

<p><code class="reqn">\forall t \in \{0,\dots,n\}, \forall u,v\in E,
\forall l\in \{1,\dots, k_{max} \}</code>, where <code class="reqn">k_{max}</code> is the maximum
sojourn time that was observed in the sequence and
<code class="reqn">A_i, i = 0, \dots, d</code> are <code class="reqn">d + 1</code> polynomials with degree
<code class="reqn">d</code> (see <a href="#topic+dsmmR">dsmmR</a>).
In order to obtain the estimators <code class="reqn">\widehat{p}</code> and <code class="reqn">\widehat{f}</code>,
we use the estimated semi-Markov kernels
estimated semi-Markov kernels <code class="reqn">\widehat{q}_{\frac{i}{d}}^{\ (1)}</code>
from Model 1. Since <code class="reqn">f</code> is drifting,
we define the estimation <code class="reqn">\widehat{f}</code> the same way as we did in
Model 1. In total, we have the following estimations,
<code class="reqn">\forall u,v \in E, \forall l \in \{1,\dots, k_{max} \}</code>:
</p>
<p style="text-align: center;"><code class="reqn">\widehat{p}\ (u,v) =
\frac{\sum_{i=0}^{d}\sum_{l=1}^{k_{max}}
\widehat{q}_{\frac{i}{d}}^{\ (1)}(u,v,l)}{d+1},</code>
</p>

<p style="text-align: center;"><code class="reqn">\widehat{f}_{\frac{i}{d}}(u,v,l) =
    \frac{\widehat{q}_{\frac{i}{d}}^{\ (1)}(u,v,l)}{
         \sum_{l = 1}^{k_{max}}\widehat{q}_{\frac{i}{d}}^{\ (1)}(u,v,l)}.</code>
</p>

<p>Thus, the <em>estimated</em> semi-Markov kernels for Model 3,
<code class="reqn">\widehat{q}_{\frac{i}{d}}^{\ (3)}(u,v,l) =
\widehat{p}\ (u,v)\widehat{f}_{\frac{i}{d}}(u,v,l)</code>, can be written with
regards to the <em>estimated</em> semi-Markov kernels of Model 1,
<code class="reqn">\widehat{q}_{\frac{i}{d}}^{\ (1)}</code>, as in the following:
</p>
<p style="text-align: center;"><code class="reqn">\widehat{q}_{\frac{i}{d}}^{\ (3)}(u,v,l) = \frac{
\widehat{q}_{\frac{i}{d}}^{\ (1)}(u,v,l)
\sum_{i=0}^{d}\sum_{l=1}^{k_{max}}\widehat{q}_{\frac{i}{d}}^{\ (1)}(u,v,l)}
{(d+1)\sum_{l=1}^{k_{max}}\widehat{q}_{\frac{i}{d}}^{\ (1)}(u,v,l)}.</code>
</p>

<p><strong>Parametric Estimation</strong>
</p>
<p>In this package, the parametric estimation of the sojourn time distributions
defined in the attribute <code>f_dist</code> is achieved as follows:
</p>

<ol>
<li>
<p>We obtain the non-parametric LSE of the sojourn time distributions
<code class="reqn">f</code>.
</p>
</li>
<li>
<p>We estimate the parameters for the distributions defined in
<code>f_dist</code> through the probabilities of <code class="reqn">f</code>, estimated
in previously in <code class="reqn">1</code>.
</p>
</li></ol>

<p>The available distributions for the modelling of the conditional sojourn
times of the drifting semi-Markov model, defined from
the argument <code>f_dist</code>, have their parameters estimated through the
following formulas:
</p>

<ul>
<li><p> Geometric <code class="reqn">(p)</code>:
</p>
<p><code class="reqn">f(x) = p (1-p)^{x-1}</code>, where <code class="reqn">x = 1, 2, \dots,k_{max}</code>.
We estimate the probability of success <code class="reqn">\widehat{p}</code>
as such:
</p>
<p style="text-align: center;"><code class="reqn">\widehat{p} = \frac{1}{E(X)}</code>
</p>

</li>
<li><p> Poisson <code class="reqn">(\lambda)</code>:
</p>
<p><code class="reqn">f(x) = \frac{\lambda^{x-1} exp(-\lambda)}{(x-1)!}</code>, where
<code class="reqn">x = 1, 2,\dots,k_{max}</code>. We estimate <code class="reqn">\widehat{\lambda} &gt; 0</code>
as such:
</p>
<p style="text-align: center;"><code class="reqn">\widehat{\lambda} = E(X)</code>
</p>

</li>
<li><p> Negative binomial <code class="reqn">(\alpha, p)</code>:
</p>
<p><code class="reqn">f(x)=\frac{\Gamma(x + \alpha - 1)}{\Gamma(\alpha)(x-1)!}
                    p^{\alpha}(1-p)^{x-1}</code>, where
<code class="reqn">x = 1, 2,\ldots,k_{max}</code>.
<code class="reqn">\Gamma</code> is the Gamma function,
<code class="reqn">p</code> is the probability of success and
<code class="reqn">\alpha \in (0, +\infty) </code> is the parameter describing the
number of successful trials, or the dispersion parameter
(the shape parameter of the gamma mixing distribution).
We estimate them as such:
</p>
<p style="text-align: center;"><code class="reqn">\widehat{p} = \frac{E(X)}{Var(X)},</code>
</p>

<p style="text-align: center;"><code class="reqn">\widehat{\alpha} = E(X)\frac{\widehat{p}}{1 - \widehat{p}} =
    \frac{E(X)^2}{Var(X) - E(X)}.</code>
</p>

</li>
<li><p> Discrete Weibull  of type 1 <code class="reqn">(q, \beta)</code>:
</p>
<p><code class="reqn">f(x)=q^{(x-1)^{\beta}}-q^{x^{\beta}}</code>, where
<code class="reqn">x= 1, 2, \dots,k_{max}</code>, <code class="reqn">q</code> is the first parameter with
<code class="reqn">0 &lt; q &lt; 1</code> and <code class="reqn">\beta \in (0, +\infty)</code>
the second parameter. We estimate them as such:
</p>
<p style="text-align: center;"><code class="reqn">\widehat{q} = 1 - f(1),</code>
</p>

<p style="text-align: center;"><code class="reqn">\widehat{\beta} = \frac{\sum_{i = 2}^{k_{max}}
    \log_{i}(\log_{\widehat{q}}(\sum_{j = 1}^{i}f(j)))}{k_{max} - 1}.
    </code>
</p>

<p>Note that we require <code class="reqn">k_{max} \geq 2</code> for estimating
<code class="reqn">\widehat{\beta}</code>.
</p>
</li>
<li><p> Uniform <code class="reqn">(n)</code>:
<code class="reqn">f(x) = 1/n</code> where <code class="reqn">x = 1, 2, \dots, n</code>, for <code class="reqn">n</code> a
positive integer. We use a numerical method to obtain an estimator
for <code class="reqn">\widehat{n}</code> in this case.
</p>
</li></ul>



<h3>Value</h3>

<p>Returns an object of S3 class <code>(dsmm_fit_nonparametric, dsmm)</code>
or <code>(dsmm_fit_parametric, dsmm)</code>. It has the following attributes:
</p>

<ul>
<li> <p><code>dist</code> : List. Contains 2 or 3 arrays,
<code>estimation</code>:
</p>

<ul>
<li><p> If <code>estimation = "nonparametric"</code> we have 2 arrays:
</p>

<ul>
<li> <p><code>p_drift</code> or <code>p_notdrift</code>, corresponding to whether the
defined <code class="reqn">p</code> transition matrix is drifting or not.
</p>
</li>
<li> <p><code>f_drift</code> or <code>f_notdrift</code>, corresponding to whether the
defined <code class="reqn">f</code> sojourn time distribution is drifting or not.
</p>
</li></ul>

</li>
<li><p> If <code>estimation = "parametric"</code> we have 3 arrays:
</p>

<ul>
<li> <p><code>p_drift</code> or <code>p_notdrift</code>, corresponding to whether the
defined <code class="reqn">p</code> transition matrix is drifting or not.
</p>
</li>
<li> <p><code>f_drift_parametric</code> or <code>f_notdrift_parametric</code>,
corresponding to whether the
defined <code class="reqn">f</code> sojourn time distribution is drifting or not.
</p>
</li>
<li> <p><code>f_drift_parameters</code> or <code>f_notdrift_parameters</code>,
which are the defined <code class="reqn">f</code> sojourn time distribution parameters,
depending on whether <code class="reqn">f</code> is drifting or not.
</p>
</li></ul>

</li></ul>

</li>
<li> <p><code>seq</code> : Character vector that contains the
<strong>embedded Markov chain</strong> <code class="reqn">(J_{t})_{t\in \{0,\dots,n\}}</code>
<strong>of the original sequence</strong>.
It is this attribute of the object that describes the size of the model
<code class="reqn">n</code>. Last state is also included, for a total length of <code class="reqn">n+1</code>,
but it is not used for any calculation.
</p>
</li>
<li> <p><code>soj_times</code> : Numerical vector that contains the sojourn times
spent for each state in <code>seq</code> before the jump to the next state.
Last state is also included, for a total length of <code class="reqn">n+1</code>,
but it is not used for any calculation.
</p>
</li>
<li> <p><code>initial_dist</code> : Numerical vector that contains an estimation
for the initial distribution of the realized states in <code>sequence</code>.
It always has values between <code class="reqn">0</code> and <code class="reqn">1</code>.
</p>
</li>
<li> <p><code>states</code> : Character vector. Passing down from the arguments.
It contains the realized states given in the argument <code>sequence</code>.
</p>
</li>
<li> <p><code>s</code> : Positive integer that contains the length of the character
vector given in the attribute <code>states</code>, which is equal to <code class="reqn">s = |E|</code>.
</p>
</li>
<li> <p><code>degree</code> : Positive integer. Passing down from the arguments.
It contains the polynomial degree
<code class="reqn">d</code> considered for the drifting of the model.
</p>
</li>
<li> <p><code>k_max</code> : Numerical value that contains the maximum sojourn
time, which is the maximum value in <code>soj_times</code>, excluding the last
state.
</p>
</li>
<li> <p><code>model_size</code> : Positive integer that contains the size of the
drifting semi-Markov model <code class="reqn">n</code>, which is equal to the length of the
embedded Markov chain <code class="reqn">(J_{t})_{t\in \{0,\dots,n\}}</code>,
minus the last state.
It has a value of <code>length(seq) - 1</code>, for <code>seq</code> as defined above.
</p>
</li>
<li> <p><code>f_is_drifting</code> : Logical. Passing down from the arguments.
Specifies if <code class="reqn">f</code> is drifting or not.
</p>
</li>
<li> <p><code>p_is_drifting</code> : Logical. Passing down from the arguments.
Specifies if <code class="reqn">p</code> is drifting or not.
</p>
</li>
<li> <p><code>Model</code> : Character. Possible values:
</p>

<ul>
<li> <p><code>"Model_1"</code> : Both <code class="reqn">p</code> and <code class="reqn">f</code> are drifting.
</p>
</li>
<li> <p><code>"Model_2"</code> : <code class="reqn">p</code> is drifting and
<code class="reqn">f</code> is not drifting.
</p>
</li>
<li> <p><code>"Model_3"</code> : <code class="reqn">f</code> is drifting and
<code class="reqn">p</code> is not drifting.
</p>
</li></ul>

</li>
<li> <p><code>estimation</code> : Character. Specifies whether parametric or
nonparametric estimation was used.
</p>
</li>
<li> <p><code>A_i</code> : Numerical Matrix. Represents the polynomials
<code class="reqn">A_i(t)</code> with degree <code class="reqn">d</code> that were used for solving
the system <code class="reqn">MJ = P</code>. Used for the methods defined for the
object. Not printed when viewing the object.
</p>
</li>
<li> <p><code>J_i</code> : Numerical Array. Represents the estimated semi-Markov
kernels of the first model
<code class="reqn">(\widehat{q}_{\frac{i}{d}}^{\ (1)}(u,v,l))_{i\in\{0,\dots,d\}}</code>
that were obtained after solving the system <code class="reqn">MJ = P</code>.
Not printed when viewing the object.
</p>
</li></ul>



<h3>References</h3>

<p>V. S. Barbu, N. Limnios. (2008). semi-Markov Chains and Hidden semi-Markov
Models Toward Applications - Their Use in Reliability and DNA Analysis.
New York: Lecture Notes in Statistics, vol. 191, Springer.
</p>
<p>Vergne, N. (2008). Drifting Markov models with Polynomial Drift and
Applications to DNA Sequences. Statistical Applications in Genetics
Molecular Biology 7 (1).
</p>
<p>Barbu V. S., Vergne, N. (2019). Reliability and survival analysis for
Drifting Markov models: modelling and estimation.
Methodology and Computing in Applied Probability, 21(4), 1407-1429.
</p>
<p>T. Nakagawa and S. Osaki. (1975). The discrete Weibull distribution.
IEEE Transactions on Reliability, R-24, 300-301.
</p>


<h3>See Also</h3>

<p>For the theoretical background of drifting semi-Markov models: <a href="#topic+dsmmR">dsmmR</a>.
</p>
<p>For sequence simulation: <a href="#topic+simulate.dsmm">simulate.dsmm</a> and <a href="#topic+create_sequence">create_sequence</a>.
</p>
<p>For drifting semi-Markov model specification:
<a href="#topic+parametric_dsmm">parametric_dsmm</a>, <a href="#topic+nonparametric_dsmm">nonparametric_dsmm</a>
</p>
<p>For the retrieval of the drifting semi-Markov kernel:
<a href="#topic+get_kernel">get_kernel</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a random sequence
sequence &lt;- create_sequence("DNA", len = 2000, seed = 1)
## Alternatively, we could obtain a sequence as follows:
## &gt; data("lambda", package = "dsmmR")
## &gt; sequence &lt;- c(lambda)
states &lt;- sort(unique(sequence))
degree &lt;- 3

# ===========================================================================
# Nonparametric Estimation.
# Fitting a random sequence under distributions of unknown shape.
# ===========================================================================



# ---------------------------------------------------------------------------
# Both p and f are drifting - Model 1.
# ---------------------------------------------------------------------------

obj_model_1 &lt;- fit_dsmm(sequence = sequence,
                        degree = degree,
                        f_is_drifting = TRUE,
                        p_is_drifting = TRUE,
                        states = states,
                        initial_dist = "freq",
                        estimation = "nonparametric", # default value
                        f_dist = NULL # default value
                        )

cat(paste0("We fitted a sequence with ", obj_model_1$Model, ",\n",
           "model size: n = ", obj_model_1$model_size, ",\n",
           "length of state space: s = ", obj_model_1$s, ",\n",
           "maximum sojourn time: k_max = ", obj_model_1$k_max, " and\n",
           "polynomial (drifting) Degree: d = ", obj_model_1$degree, ".\n"))

# Get the drifting p and f arrays.
p_drift &lt;- obj_model_1$dist$p_drift
f_drift &lt;- obj_model_1$dist$f_drift

cat(paste0("Dimension of p_drift: (s, s, d + 1) = (",
           paste(dim(p_drift), collapse = ", "), ").\n",
           "Dimension of f_drift: (s, s, k_max, d + 1) = (",
           paste(dim(f_drift), collapse = ", "), ").\n"))


# ---------------------------------------------------------------------------
# Fitting the sequence when p is drifting and f is not drifting - Model 2.
# ---------------------------------------------------------------------------


obj_model_2 &lt;- fit_dsmm(sequence = sequence,
                        degree = degree,
                        f_is_drifting = FALSE,
                        p_is_drifting = TRUE)


cat(paste0("We fitted a sequence with ", obj_model_2$Model, ".\n"))


# Get the drifting p and non-drifting f arrays.
p_drift_2 &lt;- obj_model_2$dist$p_drift
f_notdrift &lt;- obj_model_2$dist$f_notdrift


all.equal.numeric(p_drift, p_drift_2) # p is the same as in Model 1.


cat(paste0("Dimension of f_notdrift: (s, s, k_max) = (",
           paste(dim(f_notdrift), collapse = ", "), ").\n"))



# ---------------------------------------------------------------------------
# Fitting the sequence when f is drifting and p is not drifting - Model 3.
# ---------------------------------------------------------------------------

obj_model_3 &lt;- fit_dsmm(sequence = sequence,
                        degree = degree,
                        f_is_drifting = TRUE,
                        p_is_drifting = FALSE)

cat(paste0("We fitted a sequence with ", obj_model_3$Model, ".\n"))
# Get the drifting f and non-drifting p arrays.
p_notdrift &lt;- obj_model_3$dist$p_notdrift
f_drift_3 &lt;- obj_model_3$dist$f_drift
all.equal.numeric(f_drift, f_drift_3) # f is the same as in Model 1.
cat(paste0("Dimension of f_notdrift: (s, s) = (",
           paste(dim(p_notdrift), collapse = ", "), ").\n"))

# ===========================================================================
# Parametric Estimation
# Fitting a random sequence under distributions of known shape.
# ===========================================================================
### Comments
### 1.  For the parametric estimation it is recommended to use a common set
###     of distributions while only the parameters (of the sojourn times)
###     are drifting. This results in (generally) higher accuracy.
### 2.  This process is similar to that used in `dsmm_parametric()`.


s &lt;- length(states)
# Getting the distributions for the states.
# Rows correspond to previous state `u`.
# Columns correspond to next state `v`.
f_dist_1 &lt;- matrix(c(NA,         "unif",     "dweibull", "nbinom",
                     "pois",      NA,        "pois",     "dweibull",
                     "geom",     "pois",      NA,        "geom",
                     "dweibull", 'geom',     "pois",      NA),
                   nrow = s, ncol = s, byrow = TRUE)
f_dist &lt;- array(f_dist_1, dim = c(s, s, degree + 1))
dim(f_dist)

# ---------------------------------------------------------------------------
# Both p and f are drifting - Model 1.
# ---------------------------------------------------------------------------

obj_fit_parametric &lt;- fit_dsmm(sequence = sequence,
                               degree = degree,
                               f_is_drifting = TRUE,
                               p_is_drifting = TRUE,
                               states = states,
                               initial_dist = 'unif',
                               estimation = 'parametric',
                               f_dist = f_dist)
cat("The class of `obj_fit_parametric` is : (",
    paste0(class(obj_fit_parametric), collapse = ', '), ").\n")

# Estimated parameters.
f_params &lt;- obj_fit_parametric$dist$f_drift_parameters

# The drifting sojourn time distribution parameters.
f_0 &lt;- f_params[,,,1]
f_1.3 &lt;- f_params[,,,2]
f_2.3 &lt;- f_params[,,,3]
f_1 &lt;- f_params[,,,4]

params &lt;- paste0('q = ', round(f_params["c", "t", 1, ], 3),
                 ', beta = ', round(f_params["c", "t", 2, ], 3))
f_names &lt;- c("f_0", paste0("f_", 1:(degree-1), "/", degree), "f_1")
all_names &lt;- paste(f_names, ":", params)
cat("The drifting of the parameters for passing from \n",
    "`u` = 'c' to `v` = 't' under a discrete Weibull distribution is:",
    "\n", all_names[1], "\n", all_names[2],
    "\n", all_names[3], "\n", all_names[4])

# ---------------------------------------------------------------------------
# f is not drifting, only p is drifting - Model 2.
# ---------------------------------------------------------------------------

obj_fit_parametric_2 &lt;- fit_dsmm(sequence = sequence,
                                 degree = degree,
                                 f_is_drifting = FALSE,
                                 p_is_drifting = TRUE,
                                 initial_dist = 'unif',
                                 estimation = 'parametric',
                                 f_dist = f_dist_1)

cat("The class of `obj_fit_parametric_2` is : (",
    paste0(class(obj_fit_parametric_2), collapse = ', '), ").\n")
# Estimated parameters.
f_params_2 &lt;- obj_fit_parametric_2$dist$f_notdrift_parameters

params_2 &lt;- paste0('q = ', round(f_params_2["c", "t", 1], 3),
                   ', beta = ', round(f_params_2["c", "t", 2], 3))

cat("Not-drifting parameters for passing from ",
    "`u` = 'c' to `v` = 't' \n under a discrete Weibull distribution are:\n",
    paste("f :", params_2))


# ===========================================================================
# Some methods for the `dsmm_fit_nonparametric` and
#  `dsmm_fit_parametric` objects.
# ===========================================================================


sim_seq_nonparametric &lt;- simulate(obj_model_1, nsim = 10)
str(sim_seq_nonparametric)


kernel_drift_parametric &lt;- get_kernel(obj_fit_parametric, klim = 10)
str(kernel_drift_parametric)

</code></pre>

<hr>
<h2 id='get_kernel'>Obtain the Drifting semi-Markov kernel</h2><span id='topic+get_kernel'></span>

<h3>Description</h3>

<p>This is a generic method that computes and returns the drifting
semi-Markov kernel as a numerical array of dimensions
<code class="reqn">s \times s \times k_{max} \times (n + 1)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_kernel(obj, t, u, v, l, klim = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_kernel_+3A_obj">obj</code></td>
<td>
<p>An object that inherits from the S3
classes <code>dsmm</code>,
<code>dsmm_fit_parametric</code>, or
<code>dsmm_fit_nonparametric</code>,
<code>dsmm_nonparametric</code> or <code>dsmm_parametric</code>.</p>
</td></tr>
<tr><td><code id="get_kernel_+3A_t">t</code></td>
<td>
<p>Optional, but recommended. Positive integer specifying
the instance <code class="reqn">t</code> of the visited states.</p>
</td></tr>
<tr><td><code id="get_kernel_+3A_u">u</code></td>
<td>
<p>Optional. Can be either of the two options below:
</p>

<ul>
<li><p> Character specifying the previous state <code class="reqn">u</code>, e.g. <code>u = "a"</code>.
</p>
</li>
<li><p> Positive integer, specifying a state in the state space <code class="reqn">E</code>.
For example, if <code class="reqn">E = \{a, c, g, t\}</code> and <code>u = 1</code>, it corresponds
to the state <code class="reqn">a</code>, if <code>u = 2</code>, it corresponds to the state <code class="reqn">c</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="get_kernel_+3A_v">v</code></td>
<td>
<p>Optional. Can be either of the two options below:
</p>

<ul>
<li><p> Character specifying the next state <code class="reqn">v</code>, e.g. <code>v = "c"</code>.
</p>
</li>
<li><p> Positive integer, specifying a state in the state space <code class="reqn">E</code>.
For example, if <code class="reqn">E = \{a, c, g, t\}</code> and <code>v = 3</code>, it corresponds
to the state <code class="reqn">c</code>, if <code>v = 4</code>, it corresponds to the state <code class="reqn">t</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="get_kernel_+3A_l">l</code></td>
<td>
<p>Optional. Positive integer specifying the sojourn time <code class="reqn">l</code>
that is spent in the previous state <code class="reqn">u</code>.</p>
</td></tr>
<tr><td><code id="get_kernel_+3A_klim">klim</code></td>
<td>
<p>Optional. Positive integer. Used only when <code>obj</code> inherits
from the S3 classes <code>dsmm_parametric</code> or <code>dsmm_fit_parametric</code>.
Specifies the time horizon used to approximate the <code class="reqn">d + 1</code> sojourn time
distributions if <code class="reqn">f</code> is drifting, or just <code class="reqn">1</code> sojourn time
distribution if <code class="reqn">f</code> is <em>not drifting</em>.
Default value is 100.
</p>
<p>A larger value will result in a considerably larger
kernel, which has dimensions of <code class="reqn">s \times s \times klim \times (n + 1)</code>,
which will increase the memory requirements and will slow down considerably
the <code>simulate.dsmm()</code> method.
However, this will lead to better estimations through <code>fit_dsmm()</code>.
(<a href="#topic+dsmm_parametric">dsmm_parametric</a>, <a href="#topic+fit_dsmm">fit_dsmm</a>, <a href="#topic+simulate.dsmm">simulate.dsmm</a>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The drifting semi-Markov kernel is given as the probability that,
given at the instance <code class="reqn">t</code> the previous state
is <code class="reqn">u</code>, the next state state <code class="reqn">v</code> will be reached
with a sojourn time of <code class="reqn">l</code>:
</p>
<p style="text-align: center;"><code class="reqn">q_{\frac{t}{n}}(u,v,l) = P(J_{t}=v,X_{t}=l|J_{t-1}=u),</code>
</p>

<p>where <code class="reqn">n</code> is the model size, defined as the length of the embedded
Markov chain <code class="reqn">(J_{t})_{t\in \{0,\dots,n\}}</code> minus the last state,
<code class="reqn">J_t</code> is the visited state at the instant <code class="reqn">t</code> and
<code class="reqn">X_{t} = S_{t}-S_{t-1}</code> is the sojourn time of the state <code class="reqn">J_{t-1}</code>.
Specifically, it is given as the sum of a linear combination:
</p>
<p style="text-align: center;"><code class="reqn">q_{\frac{t}{n}}(u,v,l)=
     \sum_{i = 0}^{d}A_{i}(t)\ q_{\frac{i}{d}}(u,v,l),</code>
</p>

<p>where <code class="reqn">A_i, i = 0, \dots, d</code> are <code class="reqn">d + 1</code> polynomials with degree
<code class="reqn">d</code> that satisfy certain conditions (see <a href="#topic+dsmmR">dsmmR</a>) and
<code class="reqn">q_{\frac{i}{d}}(u,v,l), i = 0, \dots, d</code>
are <code class="reqn">d + 1</code> semi-Markov kernels.
Three possible model specifications are described below.
We will use the exponentials <code class="reqn">(1), (2), (3)</code> to distinguish between
the drifting semi-Markov kernel <code class="reqn">q_\frac{t}{n}</code> and the
semi-Markov kernels <code class="reqn">q_\frac{i}{d}</code> used in
Model 1, Model 2 and Model 3.
</p>
<p><strong><em>Model 1</em></strong>
</p>
<p>In this case, both <code class="reqn">p</code> and <code class="reqn">f</code> are &quot;drifting&quot; between <code class="reqn">d + 1</code>
fixed points of the model, hence the &quot;drifting&quot; in drifting semi-Markov
models. Therefore, the semi-Markov kernels <code class="reqn">q_{\frac{i}{d}}^{\ (1)}</code> are
equal to:
</p>
<p style="text-align: center;"><code class="reqn">q_{\frac{i}{d}}^{\ (1)}(u,v,l) =
     {p_{\frac{i}{d}}(u,v)}{f_{\frac{i}{d}}(u,v,l)},</code>
</p>

<p>where for <code class="reqn">i = 0, \dots, d</code> we have <code class="reqn">d + 1</code> Markov Transition
matrices <code class="reqn">p_{\frac{i}{d}}(u,v)</code>, and <code class="reqn">d + 1</code> sojourn time
distributions <code class="reqn">f_{\frac{i}{d}}(u,v,l)</code>, where <code class="reqn">d</code> is the
polynomial degree.
</p>
<p>Thus, the drifting semi-Markov kernel will be equal to:
</p>
<p style="text-align: center;"><code class="reqn">q_{\frac{t}{n}}^{\ (1)}(u,v,l) =
\sum_{i = 0}^{d} A_i(t)\ q_{\frac{i}{d}}^{\ (1)}(u,v,l) =
\sum_{i = 0}^{d} A_i(t)\ p_{\frac{i}{d}}(u,v)f_{\frac{i}{d}}(u,v,l)
</code>
</p>

<p><strong><em>Model 2</em></strong>
</p>
<p>In this case, <code class="reqn">p</code> is drifting and <code class="reqn">f</code> <strong>is not drifting</strong>.
Therefore, the semi-Markov kernels <code class="reqn">q_{\frac{i}{d}}^{\ (2)}</code> are
equal to:
</p>
<p style="text-align: center;"><code class="reqn">q_{\frac{i}{d}}^{\ (2)}(u,v,l)={p_{\frac{i}{d}}(u,v)}{f(u,v,l)}.</code>
</p>

<p>Thus, the drifting semi-Markov kernel will be equal to:
</p>
<p style="text-align: center;"><code class="reqn">q_{\frac{t}{n}}^{\ (2)}(u,v,l) =
\sum_{i = 0}^{d} A_i(t)\ q_{\frac{i}{d}}^{\ (2)}(u,v,l) =
\sum_{i = 0}^{d} A_i(t)\ p_{\frac{i}{d}}(u,v)f(u,v,l)
</code>
</p>

<p><strong><em>Model 3</em></strong>
</p>
<p>In this case, <code class="reqn">f</code> is drifting and <code class="reqn">p</code> <strong>is not drifting</strong>.
</p>
<p>Therefore, the semi-Markov kernels <code class="reqn">q_{\frac{i}{d}}^{\ (3)}</code>
are now described as:
</p>
<p style="text-align: center;"><code class="reqn">q_{\frac{i}{d}}^{\ (3)}(u,v,l)={p(u,v)}{f_{\frac{i}{d}}(u,v,l)}.</code>
</p>

<p>Thus, the drifting semi-Markov kernel will be equal to:
</p>
<p style="text-align: center;"><code class="reqn">q_{\frac{t}{n}}^{\ (3)}(u,v,l) =
\sum_{i = 0}^{d} A_i(t)\ q_{\frac{i}{d}}^{\ (3)}(u,v,l) =
\sum_{i = 0}^{d} A_i(t)\ p(u,v)f_{\frac{i}{d}}(u,v,l)
</code>
</p>



<h3>Value</h3>

<p>An array with dimensions of
<code class="reqn">s \times s \times k_{max} \times (n + 1)</code>, giving the
value of the drifting semi-Markov kernel <code class="reqn">q_{\frac{t}{n}}(u,v,l)</code> for
the corresponding <code class="reqn">(u,v,l,t)</code>. If any of <code class="reqn">u,v,l</code> or <code class="reqn">t</code> were
specified, their dimension in the array becomes 1.
</p>


<h3>See Also</h3>

<p>For the objects required to calculate this kernel:
<a href="#topic+fit_dsmm">fit_dsmm</a>, <a href="#topic+parametric_dsmm">parametric_dsmm</a>, <a href="#topic+nonparametric_dsmm">nonparametric_dsmm</a>.
</p>
<p>For sequence simulation through this kernel: <a href="#topic+simulate.dsmm">simulate.dsmm</a>.
</p>
<p>For the theoretical background of drifting semi-Markov models: <a href="#topic+dsmmR">dsmmR</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Setup.
states &lt;- c("Rouen", "Bucharest", "Samos", "Aigio", "Marseille")
seq &lt;- create_sequence(states, probs = c(0.3, 0.1, 0.1, 0.3, 0.2))
obj_model_2 &lt;- fit_dsmm(
    sequence = seq,
    states = states,
    degree = 3,
    f_is_drifting = FALSE,
    p_is_drifting = TRUE
)

# Get the kernel.
kernel_model_2 &lt;- get_kernel(obj_model_2)
cat(paste0("If no further arguments are made, kernel has dimensions ",
           "for all u, v, l, t:\n",
           "(s, s, k_max, n + 1) = (",
           paste(dim(kernel_model_2), collapse = ", "), ")"))

# Specifying `t`.
kernel_model_2_t &lt;- get_kernel(obj_model_2, t = 100)
# kernel_model_2_t[ , , , t = 100]
cat(paste0("If we specify t, the kernel has dimensions for ",
           "all the remaining u, v, l:\n(s, s, k_max) = (",
           paste(dim(kernel_model_2_t), collapse = ", "), ")"))

# Specifying `t` and `u`.
kernel_model_2_tu &lt;- get_kernel(obj_model_2, t = 2, u = "Aigio")
# kernel_model_2_tu["Aigio", , , t = 2]
cat(paste0("If we specify t and u, the kernel has dimensions for ",
           "all the remaining v, l:\n(s, k_max) = (",
           paste(dim(kernel_model_2_tu), collapse = ", "), ")"))

# Specifying `t`, `u` and `v`.
kernel_model_2_tuv &lt;- get_kernel(obj_model_2, t = 3,
                                 u = "Rouen", v = "Bucharest")
# kernel_model_2_tuv["Rouen", "Bucharest", , t = 3]
cat(paste0("If we specify t, u and v, the kernel has dimensions ",
           "for all l:\n(k_max) = (",
           paste(length(kernel_model_2_tuv), collapse = ", "), ")"))

# It is possible to ask for any valid combination of `u`, `v`, `l` and `t`.
</code></pre>

<hr>
<h2 id='is.dsmm'>Check if an object has a valid <code>dsmm</code> class</h2><span id='topic+is.dsmm'></span>

<h3>Description</h3>

<p>Checks for the validity of the specified attributes  and the
inheritance of the S3 class <code>dsmm</code>. This class acts like a parent
class for the classes <code>dsmm_fit_nonparametric,</code>
<code>dsmm_fit_parametric, dsmm_parametric</code> and <code>dsmm_nonparametric</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.dsmm(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.dsmm_+3A_obj">obj</code></td>
<td>
<p>Arbitrary <code>R</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE or FALSE.
</p>


<h3>See Also</h3>

<p><a href="#topic+is.dsmm_fit_nonparametric">is.dsmm_fit_nonparametric</a>, <a href="#topic+is.dsmm_fit_nonparametric">is.dsmm_fit_nonparametric</a>,
<a href="#topic+is.dsmm_parametric">is.dsmm_parametric</a>, <a href="#topic+is.dsmm_nonparametric">is.dsmm_nonparametric</a>
</p>

<hr>
<h2 id='is.dsmm_fit_nonparametric'>Check if an object has a valid <code>dsmm_fit_nonparametric</code> class</h2><span id='topic+is.dsmm_fit_nonparametric'></span>

<h3>Description</h3>

<p>Checks for the validity of the specified attributes and the
inheritance of the S3 class <code>dsmm_fit_nonparametric</code>.
This class inherits methods from the parent class <code>dsmm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.dsmm_fit_nonparametric(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.dsmm_fit_nonparametric_+3A_obj">obj</code></td>
<td>
<p>Arbitrary <code>R</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE or FALSE.
</p>


<h3>See Also</h3>

<p><a href="#topic+is.dsmm">is.dsmm</a>, <a href="#topic+is.dsmm_fit_parametric">is.dsmm_fit_parametric</a>,
<a href="#topic+is.dsmm_nonparametric">is.dsmm_nonparametric</a>, <a href="#topic+is.dsmm_parametric">is.dsmm_parametric</a>
</p>

<hr>
<h2 id='is.dsmm_fit_parametric'>Check if an object has a valid <code>dsmm_fit_parametric</code> class</h2><span id='topic+is.dsmm_fit_parametric'></span>

<h3>Description</h3>

<p>Checks for the validity of the specified attributes and the
inheritance of the S3 class <code>dsmm_fit_parametric</code>.
This class inherits methods from the parent class <code>dsmm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.dsmm_fit_parametric(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.dsmm_fit_parametric_+3A_obj">obj</code></td>
<td>
<p>Arbitrary <code>R</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE or FALSE.
</p>


<h3>See Also</h3>

<p><a href="#topic+is.dsmm">is.dsmm</a>, <a href="#topic+is.dsmm_fit_nonparametric">is.dsmm_fit_nonparametric</a>,
<a href="#topic+is.dsmm_parametric">is.dsmm_parametric</a>, <a href="#topic+is.dsmm_nonparametric">is.dsmm_nonparametric</a>
</p>

<hr>
<h2 id='is.dsmm_nonparametric'>Check if an object has a valid <code>dsmm_nonparametric</code> class</h2><span id='topic+is.dsmm_nonparametric'></span>

<h3>Description</h3>

<p>Checks for the validity of the specified attributes and the
inheritance of the S3 class <code>dsmm_nonparametric</code>.
This class inherits methods from the parent class <code>dsmm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.dsmm_nonparametric(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.dsmm_nonparametric_+3A_obj">obj</code></td>
<td>
<p>Arbitrary <code>R</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE or FALSE.
</p>


<h3>See Also</h3>

<p><a href="#topic+is.dsmm">is.dsmm</a>, <a href="#topic+is.dsmm_fit_nonparametric">is.dsmm_fit_nonparametric</a>,
<a href="#topic+is.dsmm_fit_parametric">is.dsmm_fit_parametric</a>, <a href="#topic+is.dsmm_parametric">is.dsmm_parametric</a>
</p>

<hr>
<h2 id='is.dsmm_parametric'>Check if an object has a valid <code>dsmm_parametric</code> class</h2><span id='topic+is.dsmm_parametric'></span>

<h3>Description</h3>

<p>Checks for the validity of the specified attributes and the
inheritance of the S3 class <code>dsmm_parametric</code>.
This class inherits methods from the parent class <code>dsmm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.dsmm_parametric(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.dsmm_parametric_+3A_obj">obj</code></td>
<td>
<p>Arbitrary <code>R</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE or FALSE.
</p>


<h3>See Also</h3>

<p><a href="#topic+is.dsmm">is.dsmm</a>, <a href="#topic+is.dsmm_fit_parametric">is.dsmm_fit_parametric</a>,
<a href="#topic+is.dsmm_fit_nonparametric">is.dsmm_fit_nonparametric</a>, <a href="#topic+is.dsmm_nonparametric">is.dsmm_nonparametric</a>
</p>

<hr>
<h2 id='lambda'>lambda genome</h2><span id='topic+lambda'></span>

<h3>Description</h3>

<p>Contains the complete genome of the Escherichia phage Lambda.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("lambda", package = "dsmmR")
data(lambda, package = "dsmmR") # equivalent.
# The following requires the package to be loaded,
# e.g. through `library(dsmmR)`.
data("lambda")
data(lambda)
</code></pre>


<h3>Format</h3>

<p>A vector object of type <code>"character"</code> and length of 48502.
It has class of <code>"Rdata"</code>.
</p>


<h3>References</h3>

<p>Sanger, F., Coulson, A. R., Hong, G. F., Hill, D. F., &amp; Petersen, G. B.
(1982). Nucleotide sequence of bacteriophage <code class="reqn">\lambda</code> DNA.
Journal of molecular biology, 162(4), 729-773.
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+data">data</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("lambda", package = "dsmmR")
class(lambda)
sequence &lt;- c(lambda) # Convert to "character" class
str(sequence)
</code></pre>

<hr>
<h2 id='nonparametric_dsmm'>Non-parametric Drifting semi-Markov model specification</h2><span id='topic+nonparametric_dsmm'></span><span id='topic+dsmm_nonparametric'></span><span id='topic+nonparametric'></span>

<h3>Description</h3>

<p>Creates a non-parametric model specification for a drifting
semi-Markov model. Returns an object of class
<code>(dsmm_nonparametric, dsmm)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nonparametric_dsmm(
  model_size,
  states,
  initial_dist,
  degree,
  k_max,
  f_is_drifting,
  p_is_drifting,
  p_dist,
  f_dist
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nonparametric_dsmm_+3A_model_size">model_size</code></td>
<td>
<p>Positive integer that represents the size of
the drifting semi-Markov model <code class="reqn">n</code>. It is equal to the length of a
theoretical embedded Markov chain
<code class="reqn">(J_{t})_{t\in \{0,\dots,n\}}</code>, without the last state.</p>
</td></tr>
<tr><td><code id="nonparametric_dsmm_+3A_states">states</code></td>
<td>
<p>Character vector that represents the state space <code class="reqn">E</code>
. It has length equal to <code class="reqn">s = |E|</code>.</p>
</td></tr>
<tr><td><code id="nonparametric_dsmm_+3A_initial_dist">initial_dist</code></td>
<td>
<p>Numerical vector of <code class="reqn">s</code> probabilities, that
represents the initial distribution for each state in the state
space <code class="reqn">E</code>.</p>
</td></tr>
<tr><td><code id="nonparametric_dsmm_+3A_degree">degree</code></td>
<td>
<p>Positive integer that represents the polynomial degree <code class="reqn">d</code>
for the drifting semi-Markov model.</p>
</td></tr>
<tr><td><code id="nonparametric_dsmm_+3A_k_max">k_max</code></td>
<td>
<p>Positive integer that represents the maximum sojourn time of
choice, for the drifting semi-Markov model.</p>
</td></tr>
<tr><td><code id="nonparametric_dsmm_+3A_f_is_drifting">f_is_drifting</code></td>
<td>
<p>Logical. Specifies if <code class="reqn">f</code> is drifting or not.</p>
</td></tr>
<tr><td><code id="nonparametric_dsmm_+3A_p_is_drifting">p_is_drifting</code></td>
<td>
<p>Logical. Specifies if <code class="reqn">p</code> is drifting or not.</p>
</td></tr>
<tr><td><code id="nonparametric_dsmm_+3A_p_dist">p_dist</code></td>
<td>
<p>Numerical array, that represents the probabilities of the
transition matrix <code class="reqn">p</code> of the embedded Markov chain
<code class="reqn">(J_{t})_{t\in \{0,\dots,n\}}</code> (it is defined
the same way in the <a href="#topic+parametric_dsmm">parametric_dsmm</a> function).
It can be defined in two ways:
</p>

<ul>
<li><p> If <code class="reqn">p</code> <strong>is not</strong> drifting, it has dimensions
of <code class="reqn">s \times s</code>.
</p>
</li>
<li><p> If <code class="reqn">p</code> <strong>is</strong> drifting, it has dimensions
of <code class="reqn">s \times s \times (d+1)</code>
(see more in <em>Details, Defined Arguments</em>.)
</p>
</li></ul>
</td></tr>
<tr><td><code id="nonparametric_dsmm_+3A_f_dist">f_dist</code></td>
<td>
<p>Numerical array, that represents the probabilities of the
conditional sojourn time distributions <code class="reqn">f</code>.
<code class="reqn">0</code> is allowed for state transitions
that we do not wish to have a sojourn time distribution
(e.g. all state transitions to the same state should have <code class="reqn">0</code>
as their value).
It can be defined in two ways:
</p>

<ul>
<li><p> If <code class="reqn">f</code> <strong>is not</strong> drifting, it has dimensions of
<code class="reqn">s \times s \times k_{max}</code>.
</p>
</li>
<li><p> If <code class="reqn">f</code> <strong>is</strong> drifting, it has dimensions of
<code class="reqn">s \times s \times k_{max} \times (d+1)</code>
(see more in <em>Details, Defined Arguments</em>.)
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Defined Arguments</strong>
</p>
<p>For the non-parametric case, we explicitly define:
</p>

<ol>
<li><p> The <em>transition matrix</em> of the embedded Markov chain
<code class="reqn">(J_{t})_{t\in \{0,\dots,n\}}</code>, given in the attribute <code>p_dist</code>:
</p>

<ul>
<li><p> If <code class="reqn">p</code> <strong>is not drifting</strong>, it contains the values:
</p>
<p style="text-align: center;"><code class="reqn">p(u, v), \forall u, v \in E,</code>
</p>

<p>given in an array with dimensions of <code class="reqn">s \times s</code>,
where the first dimension corresponds to the previous state <code class="reqn">u</code>
and the second dimension corresponds to the current state <code class="reqn">v</code>.
</p>
</li>
<li><p> If <code class="reqn">p</code> <strong>is drifting</strong> then, for <code class="reqn">i \in\{0,\dots,d\}</code>,
it contains the values:
</p>
<p style="text-align: center;"><code class="reqn">p_{\frac{i}{d}}(u,v), \forall u, v \in E,</code>
</p>

<p>given in an array with dimensions of <code class="reqn">s \times s \times (d + 1)</code>,
where the first and second dimensions are defined as in the
non-drifting case, and the third dimension corresponds to the
<code class="reqn">d+1</code> different matrices <code class="reqn">p_{\frac{i}{d}}.</code>
</p>
</li></ul>

</li>
<li><p> The <em>conditional sojourn time distribution</em>, given in the
attribute <code>f_dist</code>:
</p>

<ul>
<li><p> If <code class="reqn">f</code> <strong>is not drifting</strong>, it contains the values:
</p>
<p style="text-align: center;"><code class="reqn">f(u,v,l), \forall u,v\in E,\forall l\in \{1,\dots,k_{max}\},</code>
</p>

<p>given in an array with dimensions of <code class="reqn">s \times s \times k_{max}</code>,
where the first dimension corresponds to the previous state <code class="reqn">u</code>,
the second dimension corresponds to the current state <code class="reqn">v</code>,
and the third dimension correspond to the sojourn time <code class="reqn">l</code>.
</p>
</li>
<li><p> If <code class="reqn">f</code> <strong>is drifting</strong> then, for <code class="reqn">i\in \{0,\dots,d\}</code>,
it contains the values:
</p>
<p style="text-align: center;"><code class="reqn">f_{\frac{i}{d}}(u,v,l),\forall u,v\in E,
    \forall l\in \{1,\dots,k_{max}\},</code>
</p>

<p>given in an array with dimensions of
<code class="reqn">s \times s \times k_{max} \times (d + 1)</code>,
where the first, second and third dimensions are defined as in the
non-drifting case, and the fourth dimension corresponds to the
<code class="reqn">d+1</code> different arrays <code class="reqn">f_{\frac{i}{d}}.</code>
</p>
</li></ul>

</li></ol>



<h3>Value</h3>

<p>Returns an object of the S3 class
<code>dsmm_nonparametric,dsmm</code>.
</p>

<ul>
<li> <p><code>dist</code> : List. Contains 2 arrays,
passing down from the arguments:
</p>

<ul>
<li> <p><code>p_drift</code> or <code>p_notdrift</code>, corresponding to whether the
defined <code class="reqn">p</code> transition matrix is drifting or not.
</p>
</li>
<li> <p><code>f_drift</code> or <code>f_notdrift</code>, corresponding to whether the
defined <code class="reqn">f</code> sojourn time distribution is drifting or not.
</p>
</li></ul>

</li>
<li> <p><code>initial_dist</code> : Numerical vector. Passing down from the arguments.
It contains the initial distribution of the drifting semi-Markov model.
</p>
</li>
<li> <p><code>states</code> : Character vector. Passing down from the arguments.
It contains the state space <code class="reqn">E</code>.
</p>
</li>
<li> <p><code>s</code> : Positive integer. It contains the number of states in the
state space, <code class="reqn">s = |E|</code>, which is given in the attribute <code>states</code>.
</p>
</li>
<li> <p><code>degree</code> : Positive integer. Passing down from the arguments.
It contains the polynomial degree <code class="reqn">d</code> considered for the drifting of
the model.
</p>
</li>
<li> <p><code>k_max</code> : Numerical value. Passing down from the arguments.
It contains the maximum sojourn time, for the drifting semi-Markov
model.
</p>
</li>
<li> <p><code>model_size</code> : Positive integer. Passing down from the arguments.
It contains the size of the drifting semi-Markov model <code class="reqn">n</code>, which
represents the length of the embedded Markov chain
<code class="reqn">(J_{t})_{t\in \{0,\dots,n\}}</code>, without the last state.
</p>
</li>
<li> <p><code>f_is_drifting</code> : Logical. Passing down from the arguments.
Specifies if <code class="reqn">f</code> is drifting or not.
</p>
</li>
<li> <p><code>p_is_drifting</code> : Logical. Passing down from the arguments.
Specifies if <code class="reqn">p</code> is drifting or not.
</p>
</li>
<li> <p><code>Model</code> : Character. Possible values:
</p>

<ul>
<li> <p><code>"Model_1"</code> : Both <code class="reqn">p</code> and <code class="reqn">f</code> are drifting.
</p>
</li>
<li> <p><code>"Model_2"</code> : <code class="reqn">p</code> is drifting and <code class="reqn">f</code>
is not drifting.
</p>
</li>
<li> <p><code>"Model_3"</code> : <code class="reqn">f</code> is drifting and <code class="reqn">p</code>
is not drifting.
</p>
</li></ul>

</li>
<li> <p><code>A_i</code> : Numerical Matrix. Represents the polynomials
<code class="reqn">A_i(t)</code> with degree <code class="reqn">d</code> that are used for solving
the system <code class="reqn">MJ = P</code>. Used for the methods defined for the
object. Not printed when viewing the object.
</p>
</li></ul>



<h3>References</h3>

<p>V. S. Barbu, N. Limnios. (2008). semi-Markov Chains and Hidden semi-Markov
Models Toward Applications - Their Use in Reliability and DNA Analysis.
New York: Lecture Notes in Statistics, vol. 191, Springer.
</p>
<p>Vergne, N. (2008). Drifting Markov models with Polynomial Drift and
Applications to DNA Sequences. Statistical Applications in Genetics
Molecular Biology 7 (1).
</p>
<p>Barbu V. S., Vergne, N. (2019). Reliability and survival analysis for
drifting Markov models: modeling and estimation.
Methodology and Computing in Applied Probability, 21(4), 1407-1429.
</p>


<h3>See Also</h3>

<p>Methods applied to this object: <a href="#topic+simulate.dsmm">simulate.dsmm</a>, <a href="#topic+get_kernel">get_kernel</a>.
</p>
<p>For the parametric drifting semi-Markov model specification:
<a href="#topic+parametric_dsmm">parametric_dsmm</a>.
</p>
<p>For the theoretical background of drifting semi-Markov models: <a href="#topic+dsmmR">dsmmR</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Setup.
states &lt;- c("AA", "AC", "CC")
s &lt;- length(states)
d &lt;- 2
k_max &lt;- 3

# ===========================================================================
# Defining non-parametric drifting semi-Markov models.
# ===========================================================================

# ---------------------------------------------------------------------------
# Defining distributions for Model 1 - both p and f are drifting.
# ---------------------------------------------------------------------------

# `p_dist` has dimensions of: (s, s, d + 1).
# Sums over v must be 1 for all u and i = 0, ..., d.
p_dist_1 &lt;- matrix(c(0,   0.1, 0.9,
                     0.5, 0,   0.5,
                     0.3, 0.7, 0),
                   ncol = s, byrow = TRUE)

p_dist_2 &lt;- matrix(c(0,   0.6, 0.4,
                     0.7, 0,   0.3,
                     0.6, 0.4, 0),
                   ncol = s, byrow = TRUE)

p_dist_3 &lt;- matrix(c(0,   0.2, 0.8,
                     0.6, 0,   0.4,
                     0.7, 0.3, 0),
                   ncol = s, byrow = TRUE)

# Get `p_dist` as an array of p_dist_1, p_dist_2 and p_dist_3.
p_dist &lt;- array(c(p_dist_1, p_dist_2, p_dist_3),
                dim = c(s, s, d + 1))

# `f_dist` has dimensions of: (s, s, k_max, d + 1).
# First f distribution. Dimensions: (s, s, k_max).
# Sums over l must be 1, for every u, v and i = 0, ..., d.
f_dist_1_l_1 &lt;- matrix(c(0,   0.2, 0.7,
                         0.3, 0,   0.4,
                         0.2, 0.8, 0),
                       ncol = s, byrow = TRUE)

f_dist_1_l_2 &lt;- matrix(c(0,   0.3,  0.2,
                         0.2, 0,    0.5,
                         0.1, 0.15, 0),
                       ncol = s, byrow = TRUE)

f_dist_1_l_3 &lt;- matrix(c(0,   0.5,  0.1,
                         0.5, 0,    0.1,
                         0.7, 0.05, 0),
                       ncol = s, byrow = TRUE)
# Get f_dist_1
f_dist_1 &lt;- array(c(f_dist_1_l_1, f_dist_1_l_2, f_dist_1_l_3),
                  dim = c(s, s, k_max))

# Second f distribution. Dimensions: (s, s, k_max)
f_dist_2_l_1 &lt;- matrix(c(0,   1/3, 0.4,
                         0.3, 0,   0.4,
                         0.2, 0.1, 0),
                       ncol = s, byrow = TRUE)

f_dist_2_l_2 &lt;- matrix(c(0,   1/3, 0.4,
                         0.4, 0,   0.2,
                         0.3, 0.4, 0),
                       ncol = s, byrow = TRUE)

f_dist_2_l_3 &lt;- matrix(c(0,   1/3, 0.2,
                         0.3, 0,   0.4,
                         0.5, 0.5, 0),
                       ncol = s, byrow = TRUE)

# Get f_dist_2
f_dist_2 &lt;- array(c(f_dist_2_l_1, f_dist_2_l_2, f_dist_2_l_3),
                  dim = c(s, s, k_max))

# Third f distribution. Dimensions: (s, s, k_max)
f_dist_3_l_1 &lt;- matrix(c(0,    0.3, 0.3,
                         0.3,  0,   0.5,
                         0.05, 0.1, 0),
                       ncol = s, byrow = TRUE)

f_dist_3_l_2 &lt;- matrix(c(0,   0.2, 0.6,
                         0.3, 0,   0.35,
                         0.9, 0.2, 0),
                       ncol = s, byrow = TRUE)

f_dist_3_l_3 &lt;- matrix(c(0,    0.5, 0.1,
                         0.4,  0,   0.15,
                         0.05, 0.7, 0),
                       ncol = s, byrow = TRUE)

# Get f_dist_3
f_dist_3 &lt;- array(c(f_dist_3_l_1, f_dist_3_l_2, f_dist_3_l_3),
                  dim = c(s, s, k_max))

# Get f_dist as an array of f_dist_1, f_dist_2 and f_dist_3.
f_dist &lt;- array(c(f_dist_1, f_dist_2, f_dist_3),
                dim = c(s, s, k_max, d + 1))

# ---------------------------------------------------------------------------
# Non-Parametric object for Model 1.
# ---------------------------------------------------------------------------

obj_nonpar_model_1 &lt;- nonparametric_dsmm(
    model_size = 8000,
    states = states,
    initial_dist = c(0.3, 0.5, 0.2),
    degree = d,
    k_max = k_max,
    p_dist = p_dist,
    f_dist = f_dist,
    p_is_drifting = TRUE,
    f_is_drifting = TRUE
)

# p drifting array.
p_drift &lt;- obj_nonpar_model_1$dist$p_drift
p_drift

# f distribution.
f_drift &lt;- obj_nonpar_model_1$dist$f_drift
f_drift

# ---------------------------------------------------------------------------
# Defining Model 2 - p is drifting, f is not drifting.
# ---------------------------------------------------------------------------

# p_dist has the same dimensions as in Model 1: (s, s, d + 1).
p_dist_model_2 &lt;- array(c(p_dist_1, p_dist_2, p_dist_3),
                        dim = c(s, s, d + 1))

# f_dist has dimensions of: (s,s,k_{max}).
f_dist_model_2 &lt;- f_dist_2


# ---------------------------------------------------------------------------
# Non-Parametric object for Model 2.
# ---------------------------------------------------------------------------

obj_nonpar_model_2 &lt;- nonparametric_dsmm(
    model_size = 10000,
    states = states,
    initial_dist = c(0.7, 0.1, 0.2),
    degree = d,
    k_max = k_max,
    p_dist = p_dist_model_2,
    f_dist = f_dist_model_2,
    p_is_drifting = TRUE,
    f_is_drifting = FALSE
)

# p drifting array.
p_drift &lt;- obj_nonpar_model_2$dist$p_drift
p_drift

# f distribution array.
f_notdrift &lt;- obj_nonpar_model_2$dist$f_notdrift
f_notdrift


# ---------------------------------------------------------------------------
# Defining Model 3 - f is drifting, p is not drifting.
# ---------------------------------------------------------------------------


# `p_dist` has dimensions of: (s, s, d + 1).
p_dist_model_3 &lt;- p_dist_3


# `f_dist` has the same dimensions as in Model 1: (s, s, d + 1).
f_dist_model_3 &lt;- array(c(f_dist_1, f_dist_2, f_dist_3),
                        dim = c(s, s, k_max, d + 1))


# ---------------------------------------------------------------------------
# Non-Parametric object for Model 3.
# ---------------------------------------------------------------------------

obj_nonpar_model_3 &lt;- nonparametric_dsmm(
    model_size = 10000,
    states = states,
    initial_dist = c(0.3, 0.4, 0.3),
    degree = d,
    k_max = k_max,
    p_dist = p_dist_model_3,
    f_dist = f_dist_model_3,
    p_is_drifting = FALSE,
    f_is_drifting = TRUE
)

# p distribution matrix.
p_notdrift &lt;- obj_nonpar_model_3$dist$p_notdrift
p_notdrift

# f distribution array.
f_drift &lt;- obj_nonpar_model_3$dist$f_drift
f_drift

# ===========================================================================
# Using methods for non-parametric objects.
# ===========================================================================

kernel_parametric &lt;- get_kernel(obj = obj_nonpar_model_3)
str(kernel_parametric)

sim_seq_par &lt;- simulate(obj_nonpar_model_3, nsim = 50)
str(sim_seq_par)
</code></pre>

<hr>
<h2 id='parametric_dsmm'>Parametric Drifting semi-Markov model specification</h2><span id='topic+parametric_dsmm'></span><span id='topic+dsmm_parametric'></span><span id='topic+parametric'></span>

<h3>Description</h3>

<p>Creates a parametric model specification for a drifting
semi-Markov model. Returns an object of class
<code>(dsmm_parametric, dsmm)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parametric_dsmm(
  model_size,
  states,
  initial_dist,
  degree,
  f_is_drifting,
  p_is_drifting,
  p_dist,
  f_dist,
  f_dist_pars
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parametric_dsmm_+3A_model_size">model_size</code></td>
<td>
<p>Positive integer that represents the size of
the drifting semi-Markov model <code class="reqn">n</code>. It is equal to the length of a
theoretical embedded Markov chain
<code class="reqn">(J_{t})_{t\in \{0,\dots,n\}}</code>, without the last state.</p>
</td></tr>
<tr><td><code id="parametric_dsmm_+3A_states">states</code></td>
<td>
<p>Character vector that represents the state space <code class="reqn">E</code>.
It has length equal to <code class="reqn">s = |E|</code>.</p>
</td></tr>
<tr><td><code id="parametric_dsmm_+3A_initial_dist">initial_dist</code></td>
<td>
<p>Numerical vector of <code class="reqn">s</code> probabilities, that
represents the initial distribution for each state in the state space
<code class="reqn">E</code>.</p>
</td></tr>
<tr><td><code id="parametric_dsmm_+3A_degree">degree</code></td>
<td>
<p>Positive integer that represents the polynomial degree <code class="reqn">d</code>
for the drifting semi-Markov model.</p>
</td></tr>
<tr><td><code id="parametric_dsmm_+3A_f_is_drifting">f_is_drifting</code></td>
<td>
<p>Logical. Specifies if <code class="reqn">f</code> is drifting or not.</p>
</td></tr>
<tr><td><code id="parametric_dsmm_+3A_p_is_drifting">p_is_drifting</code></td>
<td>
<p>Logical. Specifies if <code class="reqn">p</code> is drifting or not.</p>
</td></tr>
<tr><td><code id="parametric_dsmm_+3A_p_dist">p_dist</code></td>
<td>
<p>Numerical array, that represents the probabilities of the
transition matrix <code class="reqn">p</code> of the embedded Markov chain
<code class="reqn">(J_{t})_{t\in \{0,\dots,n\}}</code> (it is defined
the same way in the <a href="#topic+nonparametric_dsmm">nonparametric_dsmm</a> function).
It can be defined in two ways:
</p>

<ul>
<li>
<p>If <code class="reqn">p</code> <strong>is not</strong> drifting, it has dimensions of
<code class="reqn">s \times s</code>.
</p>
</li>
<li>
<p>If <code class="reqn">p</code> <strong>is</strong> drifting, it has dimensions of
<code class="reqn">s \times s \times (d+1)</code>
(see more in <em>Details, Defined Arguments</em>.)</p>
</li></ul>
</td></tr>
<tr><td><code id="parametric_dsmm_+3A_f_dist">f_dist</code></td>
<td>
<p>Character array, that represents the discrete sojourn time
distribution <code class="reqn">f</code> of our choice.
<code>NA</code> is allowed for state transitions
that we do not wish to have a sojourn time distribution
(e.g. all state transition to the same state should have <code>NA</code>
as their value). The list of possible values is:
<code>["unif", "geom", "pois", "dweibull", "nbinom", NA]</code>.
It can be defined in two ways:
</p>

<ul>
<li>
<p>If <code class="reqn">f</code> <strong>is not</strong> drifting, it has dimensions of
<code class="reqn">s \times s</code>.
</p>
</li>
<li>
<p>If <code class="reqn">f</code> <strong>is</strong> drifting, it has dimensions of
<code class="reqn">s \times s \times (d+1)</code>
(see more in <em>Details, Defined Arguments</em>.)</p>
</li></ul>
</td></tr>
<tr><td><code id="parametric_dsmm_+3A_f_dist_pars">f_dist_pars</code></td>
<td>
<p>Numerical array, that represents the parameters of the
sojourn time distributions given in <code>f_dist</code>. <code>NA</code> is allowed,
in the case that the distribution of our choice does not require
a parameter. It can be defined in two ways:
</p>

<ul>
<li><p> If <code class="reqn">f</code> <strong>is not</strong> drifting, it has dimensions of
<code class="reqn">s \times s \times 2</code>, specifying <strong>two</strong> possible
parameters required for the discrete distributions.
</p>
</li>
<li><p> If <code class="reqn">f</code> <strong>is</strong> drifting, it has dimensions of
<code class="reqn">s \times s \times 2 \times (d+1)</code>,
specifying <strong>two</strong> possible parameters required for the discrete
distributions, but for every single one of the <code class="reqn">i = 0, \dots, d</code>
sojourn time distributions <code class="reqn">f_{\frac{i}{d}}</code> that are required.
(see more in <em>Details, Defined Arguments</em>.)</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Defined Arguments</strong>
</p>
<p>For the parametric case, we explicitly define:
</p>

<ol>
<li><p> The <em>transition matrix</em> of the embedded Markov chain
<code class="reqn">(J_{t})_{t\in \{0,\dots,n\}}</code>, given in
the attribute <code>p_dist</code>:
</p>

<ul>
<li><p> If <code class="reqn">p</code> <strong>is not drifting</strong>, it contains the values:
</p>
<p style="text-align: center;"><code class="reqn">p(u,v), \forall u, v \in E,</code>
</p>

<p>given in an array with dimensions of <code class="reqn">s \times s</code>,
where the first dimension corresponds to the previous state <code class="reqn">u</code> and
the second dimension corresponds to the current state <code class="reqn">v</code>.
</p>
</li>
<li><p> If <code class="reqn">p</code> <strong>is drifting</strong>, for <code class="reqn">i \in \{ 0,\dots,d \}</code>,
it contains the values:
</p>
<p style="text-align: center;"><code class="reqn">p_{\frac{i}{d}}(u,v), \forall u, v \in E,</code>
</p>

<p>given in an array with dimensions of <code class="reqn">s \times s \times (d + 1)</code>,
where the first and second dimensions are defined as in the non-drifting
case, and the third dimension corresponds to the <code class="reqn">d+1</code> different
matrices <code class="reqn">p_{\frac{i}{d}}.</code>
</p>
</li></ul>

</li>
<li><p> The <em>conditional sojourn time distribution</em>, given in the
attribute <code>f_dist</code>:
</p>

<ul>
<li><p> If <code class="reqn">f</code> <strong>is not drifting</strong>, it contains the discrete
distribution <em>names</em> (as characters or <code>NA</code>), given in an
array with dimensions of <code class="reqn">s \times s</code>,
where the first dimension corresponds to the previous state <code class="reqn">u</code>,
the second dimension corresponds to the current state <code class="reqn">v</code>.
</p>
</li>
<li><p> If <code class="reqn">f</code> <strong>is drifting</strong>, it contains the discrete
distribution <em>names</em> (as characters or <code>NA</code>) given in an
array with dimensions of <code class="reqn">s \times s \times (d + 1)</code>,
where the first and second dimensions are defined as in the
non-drifting case, and the third dimension corresponds to the
<code class="reqn">d+1</code> different arrays <code class="reqn">f_{\frac{i}{d}}.</code>
</p>
</li></ul>

</li>
<li><p> The <em>conditional sojourn time distribution parameters</em>,
given in the attribute <code>f_dist_pars</code>:
</p>

<ul>
<li><p> If <code class="reqn">f</code> <strong>is not drifting</strong>, it contains the
<em>numerical values</em> (or <code>NA</code>) of the corresponding
distributions defined in <code>f_dist</code>, given in
an array with dimensions of <code class="reqn">s \times s</code>,
where the first dimension corresponds to the previous state <code class="reqn">u</code>,
the second dimension corresponds to the current state <code class="reqn">v</code>.
</p>
</li>
<li><p> If <code class="reqn">f</code> <strong>is drifting</strong>, it contains the
<em>numerical values</em> (or <code>NA</code>) of the corresponding
distributions defined in <code>f_dist</code>, given in an array
with dimensions of <code class="reqn">s \times s \times (d + 1)</code>,
where the first and second dimensions are defined as in the
non-drifting case, and the third dimension corresponds to the
<code class="reqn">d+1</code> different arrays <code class="reqn">f_{\frac{i}{d}}.</code>
</p>
</li></ul>

</li></ol>

<p><strong>Sojourn time distributions</strong>
</p>
<p>In this package, the available distributions for the modeling of the
conditional sojourn times, of the drifting semi-Markov model, used through
the argument <code>f_dist</code>, are the following:
</p>

<ul>
<li><p> Uniform <code class="reqn">(n)</code>:
</p>
<p><code class="reqn">f(x) = 1/n</code>, for <code class="reqn">x = 1, 2, \dots, n</code>, where <code class="reqn">n</code> is a
positive integer.
This can be specified through the following:
</p>

<ul>
<li> <p><code>f_dist = "unif"</code>
</p>
</li>
<li> <p><code>f_dist_pars</code> = (<code class="reqn">n</code>, <code>NA</code>)
(<code class="reqn">n</code> as defined here).
</p>
</li></ul>

</li>
<li><p> Geometric <code class="reqn">(p)</code>:
</p>
<p><code class="reqn">f(x) = p (1-p)^{x-1}</code>, for
<code class="reqn">x = 1, 2, \dots,</code> where <code class="reqn">p \in (0, 1)</code>
is the probability of success.
This can be specified through the following:
</p>

<ul>
<li> <p><code>f_dist</code> = <code>"geom"</code>
</p>
</li>
<li> <p><code>f_dist_pars</code> = (<code class="reqn">p</code>, <code>NA</code>)
(<code class="reqn">p</code> as defined here).
</p>
</li></ul>

</li>
<li><p> Poisson <code class="reqn">(\lambda)</code>:
</p>
<p><code class="reqn">f(x) = \frac{\lambda^{x-1} exp(-\lambda)}{(x-1)!}</code>, for
<code class="reqn">x = 1, 2, \dots,</code> where <code class="reqn">\lambda &gt; 0</code>.
This can be specified through the following:
</p>

<ul>
<li> <p><code>f_dist</code> = <code>"pois"</code>
</p>
</li>
<li> <p><code>f_dist_pars</code> = (<code class="reqn">\lambda</code>, <code>NA</code>)
</p>
</li></ul>

</li>
<li><p> Negative binomial <code class="reqn">(\alpha, p)</code>:
</p>
<p><code class="reqn">f(x)=\frac{\Gamma(x+\alpha-1)}{\Gamma(\alpha)(x-1)!}
    p^{\alpha}(1-p)^{x-1}</code>, for <code class="reqn">x = 1, 2,\dots,</code> where
<code class="reqn">\Gamma</code> is the Gamma function,
<code class="reqn">\alpha \in (0, +\infty) </code> is the parameter describing the
target for number of successful trials, or the dispersion parameter
(the shape parameter of the gamma mixing distribution).
<code class="reqn">p</code> is the probability of success, <code class="reqn">0 &lt; p &lt; 1</code>.
</p>

<ul>
<li> <p><code>f_dist</code> = <code>"nbinom"</code>
</p>
</li>
<li> <p><code>f_dist_pars</code> = (<code class="reqn">\alpha, p</code>)
(<code class="reqn">p</code> as defined here)
</p>
</li></ul>

</li>
<li><p> Discrete Weibull  of type 1 <code class="reqn">(q, \beta)</code>:
</p>
<p><code class="reqn">f(x)=q^{(x-1)^{\beta}}-q^{x^{\beta}}</code>, for <code class="reqn">x=1,2,\dots,</code> with
<code class="reqn">q \in (0, 1)</code> is the first parameter (probability)
and <code class="reqn">\beta \in (0, +\infty)</code> is the second parameter.
This can be specified through the following:
</p>

<ul>
<li> <p><code>f_dist</code> = <code>"dweibull"</code>
</p>
</li>
<li> <p><code>f_dist_pars</code> = (<code class="reqn">q, \beta</code>)
(<code class="reqn">q</code> as defined here)
</p>
</li></ul>

</li></ul>

<p>From these discrete distributions, by using <code>"dweibull", "nbinom"</code>
we require two parameters. It's for this reason that the attribute
<code>f_dist_pars</code> is an array of dimensions
<code class="reqn">s \times s \times 2</code> if <code class="reqn">f</code>
<strong>is not drifting</strong> or <code class="reqn">s \times s \times 2 \times (d+1)</code>
if <code class="reqn">f</code> <strong>is drifting</strong>.
</p>


<h3>Value</h3>

<p>Returns an object of the S3 class <code>dsmm_parametric, dsmm</code>.
It has the following attributes:
</p>

<ul>
<li> <p><code>dist</code> : List. Contains 3 arrays, passing down from the arguments:
</p>

<ul>
<li> <p><code>p_drift</code> or <code>p_notdrift</code>, corresponding to whether the
defined <code class="reqn">p</code> transition matrix is drifting or not.
</p>
</li>
<li> <p><code>f_drift_parametric</code> or <code>f_notdrift_parametric</code>,
corresponding to whether the
defined <code class="reqn">f</code> sojourn time distribution is drifting or not.
</p>
</li>
<li> <p><code>f_drift_parameters</code> or <code>f_notdrift_parameters</code>,
which are the defined <code class="reqn">f</code> sojourn time distribution parameters,
depending on whether <code class="reqn">f</code> is drifting or not.
</p>
</li></ul>

</li>
<li> <p><code>initial_dist</code> : Numerical vector. Passing down from the arguments.
It contains the initial distribution of the drifting semi-Markov model.
</p>
</li>
<li> <p><code>states</code> : Character vector. Passing down from the arguments.
It contains the state space <code class="reqn">E</code>.
</p>
</li>
<li> <p><code>s</code> : Positive integer. It contains the number of states in the
state space, <code class="reqn">s = |E|</code>, which is given in the attribute <code>states</code>.
</p>
</li>
<li> <p><code>degree</code> : Positive integer. Passing down from the arguments.
It contains the polynomial degree <code class="reqn">d</code> considered for the drifting of
the model.
</p>
</li>
<li> <p><code>model_size</code> : Positive integer. Passing down from the arguments.
It contains the size of the drifting semi-Markov model <code class="reqn">n</code>, which
represents the length of the embedded Markov chain
<code class="reqn">(J_{t})_{t\in \{0,\dots,n\}}</code>, without the last state.
</p>
</li>
<li> <p><code>f_is_drifting</code> : Logical. Passing down from the arguments.
Specifies if <code class="reqn">f</code> is drifting or not.
</p>
</li>
<li> <p><code>p_is_drifting</code> : Logical. Passing down from the arguments.
Specifies if <code class="reqn">p</code> is drifting or not.
</p>
</li>
<li> <p><code>Model</code> : Character. Possible values:
</p>

<ul>
<li> <p><code>"Model_1"</code> : Both <code class="reqn">p</code> and <code class="reqn">f</code> are drifting.
</p>
</li>
<li> <p><code>"Model_2"</code> : <code class="reqn">p</code> is drifting and <code class="reqn">f</code>
is not drifting.
</p>
</li>
<li> <p><code>"Model_3"</code> : <code class="reqn">f</code> is drifting and <code class="reqn">p</code>
is not drifting.
</p>
</li></ul>

</li>
<li> <p><code>A_i</code> : Numerical matrix. Represents the polynomials
<code class="reqn">A_i(t)</code> with degree <code class="reqn">d</code> that are used for solving
the system <code class="reqn">MJ = P</code>. Used for the methods defined for the
object. Not printed when viewing the object.
</p>
</li></ul>



<h3>References</h3>

<p>V. S. Barbu, N. Limnios. (2008). semi-Markov Chains and Hidden semi-Markov
Models Toward Applications - Their Use in Reliability and DNA Analysis.
New York: Lecture Notes in Statistics, vol. 191, Springer.
</p>
<p>Vergne, N. (2008). Drifting Markov models with Polynomial Drift and
Applications to DNA Sequences. Statistical Applications in Genetics
Molecular Biology 7 (1).
</p>
<p>Barbu V. S., Vergne, N. (2019). Reliability and survival analysis for
drifting Markov models: modeling and estimation.
Methodology and Computing in Applied Probability, 21(4), 1407-1429.
</p>
<p>T. Nakagawa and S. Osaki. (1975). The discrete Weibull distribution.
IEEE Transactions on Reliability, R-24, 300-301.
</p>


<h3>See Also</h3>

<p>Methods applied to this object: <a href="#topic+simulate.dsmm">simulate.dsmm</a>, <a href="#topic+get_kernel">get_kernel</a>.
</p>
<p>For the non-parametric drifting semi-Markov model specification:
<a href="#topic+nonparametric_dsmm">nonparametric_dsmm</a>.
</p>
<p>For the theoretical background of drifting semi-Markov models: <a href="#topic+dsmmR">dsmmR</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We can also define states in a flexible way, including spaces.
states &lt;- c("Dollar $", " /1'2'3/ ", " Z E T A ", "O_M_E_G_A")
s &lt;- length(states)
d &lt;- 1

# ===========================================================================
# Defining parametric drifting semi-Markov models.
# ===========================================================================

# ---------------------------------------------------------------------------
# Defining the drifting distributions for Model 1.
# ---------------------------------------------------------------------------

# `p_dist` has dimensions of: (s, s, d + 1).
# Sums over v must be 1 for all u and i = 0, ..., d.

# First matrix.
p_dist_1 &lt;- matrix(c(0,   0.1, 0.4, 0.5,
                     0.5, 0,   0.3, 0.2,
                     0.3, 0.4, 0,   0.3,
                     0.8, 0.1, 0.1, 0),
                   ncol = s, byrow = TRUE)

# Second matrix.
p_dist_2 &lt;- matrix(c(0,   0.3, 0.6, 0.1,
                     0.3, 0,   0.4, 0.3,
                     0.5, 0.3, 0,   0.2,
                     0.2, 0.3, 0.5, 0),
                   ncol = s, byrow = TRUE)

# get `p_dist` as an array of p_dist_1 and p_dist_2.
p_dist_model_1 &lt;- array(c(p_dist_1, p_dist_2), dim = c(s, s, d + 1))

# `f_dist` has dimensions of: (s, s, d + 1).
# First matrix.
f_dist_1 &lt;- matrix(c(NA,         "unif", "dweibull", "nbinom",
                     "geom",      NA,    "pois",     "dweibull",
                     "dweibull", "pois",  NA,        "geom",
                     "pois",      NA,    "geom",      NA),
                   nrow = s, ncol = s, byrow = TRUE)


# Second matrix.
f_dist_2 &lt;- matrix(c(NA,     "pois", "geom", "nbinom",
                     "geom",  NA,    "pois", "dweibull",
                     "unif", "geom",  NA,    "geom",
                     "pois", "pois", "geom",  NA),
                   nrow = s, ncol = s, byrow = TRUE)


# get `f_dist` as an array of `f_dist_1` and `f_dist_2`
f_dist_model_1 &lt;- array(c(f_dist_1, f_dist_2), dim = c(s, s, d + 1))


# `f_dist_pars` has dimensions of: (s, s, 2, d + 1).
# First array of coefficients, corresponding to `f_dist_1`.
# First matrix.
f_dist_1_pars_1 &lt;- matrix(c(NA,  5,  0.4, 4,
                            0.7, NA, 5,   0.6,
                            0.2, 3,  NA,  0.6,
                            4,   NA, 0.4, NA),
                          nrow = s, ncol = s, byrow = TRUE)
# Second matrix.
f_dist_1_pars_2 &lt;- matrix(c(NA,  NA, 0.2, 0.6,
                            NA,  NA, NA,  0.8,
                            0.6, NA, NA,  NA,
                            NA,  NA, NA,  NA),
                          nrow = s, ncol = s, byrow = TRUE)

# Second array of coefficients, corresponding to `f_dist_2`.
# First matrix.
f_dist_2_pars_1 &lt;- matrix(c(NA,  6,   0.4, 3,
                            0.7, NA,  2,   0.5,
                            3,   0.6, NA,  0.7,
                            6,   0.2, 0.7, NA),
                          nrow = s, ncol = s, byrow = TRUE)
# Second matrix.
f_dist_2_pars_2 &lt;- matrix(c(NA, NA, NA, 0.6,
                            NA, NA, NA, 0.8,
                            NA, NA, NA, NA,
                            NA, NA, NA, NA),
                          nrow = s, ncol = s, byrow = TRUE)

# Get `f_dist_pars`.
f_dist_pars_model_1 &lt;- array(c(f_dist_1_pars_1, f_dist_1_pars_2,
                               f_dist_2_pars_1, f_dist_2_pars_2),
                             dim = c(s, s, 2, d + 1))

# ---------------------------------------------------------------------------
# Parametric object for Model 1.
# ---------------------------------------------------------------------------

obj_par_model_1 &lt;- parametric_dsmm(
    model_size = 10000,
    states = states,
    initial_dist = c(0.8, 0.1, 0.1, 0),
    degree = d,
    p_dist = p_dist_model_1,
    f_dist = f_dist_model_1,
    f_dist_pars = f_dist_pars_model_1,
    p_is_drifting = TRUE,
    f_is_drifting = TRUE
)

# p drifting array.
p_drift &lt;- obj_par_model_1$dist$p_drift
p_drift

# f distribution.
f_dist_drift &lt;- obj_par_model_1$dist$f_drift_parametric
f_dist_drift

# parameters for the f distribution.
f_dist_pars_drift &lt;- obj_par_model_1$dist$f_drift_parameters
f_dist_pars_drift

# ---------------------------------------------------------------------------
# Defining Model 2 - p is drifting, f is not drifting.
# ---------------------------------------------------------------------------

# `p_dist` has the same dimensions as in Model 1: (s, s, d + 1).
p_dist_model_2 &lt;- array(c(p_dist_1, p_dist_2), dim = c(s, s, d + 1))

# `f_dist` has dimensions of: (s, s).
f_dist_model_2 &lt;- matrix(c( NA,       "pois",  NA,       "nbinom",
                            "geom",    NA,    "geom",    "dweibull",
                            "unif",   "geom",  NA,       "geom",
                            "nbinom", "unif", "dweibull", NA),
                         nrow = s, ncol = s, byrow = TRUE)

# `f_dist_pars` has dimensions of: (s, s, 2),
#  corresponding to `f_dist_model_2`.

# First matrix.
f_dist_pars_1_model_2 &lt;- matrix(c(NA,  0.2, NA,  3,
                                  0.2, NA,  0.2, 0.5,
                                  3,   0.4, NA,  0.7,
                                  2,   3,   0.7, NA),
                                nrow = s, ncol = s, byrow = TRUE)

# Second matrix.
f_dist_pars_2_model_2 &lt;- matrix(c(NA,  NA, NA,  0.6,
                                  NA,  NA, NA,  0.8,
                                  NA,  NA, NA,  NA,
                                  0.2, NA, 0.3, NA),
                                nrow = s, ncol = s, byrow = TRUE)


# Get `f_dist_pars`.
f_dist_pars_model_2 &lt;- array(c(f_dist_pars_1_model_2,
                               f_dist_pars_2_model_2),
                             dim = c(s, s, 2))


# ---------------------------------------------------------------------------
# Parametric object for Model 2.
# ---------------------------------------------------------------------------

obj_par_model_2 &lt;- parametric_dsmm(
    model_size = 10000,
    states = states,
    initial_dist = c(0.8, 0.1, 0.1, 0),
    degree = d,
    p_dist = p_dist_model_2,
    f_dist = f_dist_model_2,
    f_dist_pars = f_dist_pars_model_2,
    p_is_drifting = TRUE,
    f_is_drifting = FALSE
)

# p drifting array.
p_drift &lt;- obj_par_model_2$dist$p_drift
p_drift

# f distribution.
f_dist_notdrift &lt;- obj_par_model_2$dist$f_notdrift_parametric
f_dist_notdrift

# parameters for the f distribution.
f_dist_pars_notdrift &lt;- obj_par_model_2$dist$f_notdrift_parameters
f_dist_pars_notdrift

# ---------------------------------------------------------------------------
# Defining Model 3 - f is drifting, p is not drifting.
# ---------------------------------------------------------------------------

# `p_dist` has dimensions of: (s, s).
p_dist_model_3 &lt;- matrix(c(0,   0.1,  0.3,  0.6,
                           0.4, 0,    0.1,  0.5,
                           0.4, 0.3,  0,    0.3,
                           0.9, 0.01, 0.09, 0),
                         ncol = s, byrow = TRUE)

# `f_dist` has the same dimensions as in Model 1: (s, s, d + 1).
f_dist_model_3 &lt;- array(c(f_dist_1, f_dist_2), dim = c(s, s, d + 1))


# `f_dist_pars` has the same dimensions as in Model 1: (s, s, 2, d + 1).
f_dist_pars_model_3 &lt;- array(c(f_dist_1_pars_1, f_dist_1_pars_2,
                               f_dist_2_pars_1, f_dist_2_pars_2),
                             dim = c(s, s, 2, d + 1))

# ---------------------------------------------------------------------------
# Parametric object for Model 3.
# ---------------------------------------------------------------------------

obj_par_model_3 &lt;- parametric_dsmm(
    model_size = 10000,
    states = states,
    initial_dist = c(0.3, 0.2, 0.2, 0.3),
    degree = d,
    p_dist = p_dist_model_3,
    f_dist = f_dist_model_3,
    f_dist_pars = f_dist_pars_model_3,
    p_is_drifting = FALSE,
    f_is_drifting = TRUE
)

# p drifting array.
p_notdrift &lt;- obj_par_model_3$dist$p_notdrift
p_notdrift

# f distribution.
f_dist_drift &lt;- obj_par_model_3$dist$f_drift_parametric
f_dist_drift

# parameters for the f distribution.
f_dist_pars_drift &lt;- obj_par_model_3$dist$f_drift_parameters
f_dist_pars_drift

# ===========================================================================
# Parametric estimation using methods corresponding to an object
#     which inherits from the class `dsmm_parametric`.
# ===========================================================================

### Comments
### 1.  Using a larger `klim` and a larger `model_size` will increase the
###     accuracy of the model, with the need of larger memory requirements
###     and computational cost.
### 2.  For the parametric estimation it is recommended to use a common set
###     of distributions while only the parameters are drifting. This results
###     in higher accuracy.


# ---------------------------------------------------------------------------
# Defining the distributions for Model 1 - both p and f are drifting.
# ---------------------------------------------------------------------------

# `p_dist` has dimensions of: (s, s, d + 1).
# First matrix.
p_dist_1 &lt;- matrix(c(0,   0.2, 0.4, 0.4,
                     0.5, 0,   0.3, 0.2,
                     0.3, 0.4, 0,   0.3,
                     0.5, 0.3, 0.2, 0),
                   ncol = s, byrow = TRUE)

# Second matrix.
p_dist_2 &lt;- matrix(c(0,   0.3, 0.5, 0.2,
                     0.3, 0,   0.4, 0.3,
                     0.5, 0.3, 0,   0.2,
                     0.2, 0.4, 0.4, 0),
                   ncol = s, byrow = TRUE)

# get `p_dist` as an array of p_dist_1 and p_dist_2.
p_dist_model_1 &lt;- array(c(p_dist_1, p_dist_2), dim = c(s, s, d + 1))

# `f_dist` has dimensions of: (s, s, d + 1).
# We will use the same sojourn time distributions.
f_dist_1 &lt;- matrix(c( NA,        "unif",   "dweibull", "nbinom",
                     "geom",      NA,      "pois",     "dweibull",
                     "dweibull", "pois",    NA,        "geom",
                     "pois",     'nbinom', "geom",      NA),
                   nrow = s, ncol = s, byrow = TRUE)

# get `f_dist`
f_dist_model_1 &lt;- array(f_dist_1, dim = c(s, s, d + 1))

# `f_dist_pars` has dimensions of: (s, s, 2, d + 1).
# First array of coefficients, corresponding to `f_dist_1`.
# First matrix.
f_dist_1_pars_1 &lt;- matrix(c(NA,  7,  0.4, 4,
                            0.7, NA, 5,   0.6,
                            0.2, 3,  NA,  0.6,
                            4,   4,  0.4, NA),
                          nrow = s, ncol = s, byrow = TRUE)
# Second matrix.
f_dist_1_pars_2 &lt;- matrix(c(NA,  NA,  0.2, 0.6,
                            NA,  NA,  NA,  0.8,
                            0.6, NA,  NA,  NA,
                            NA,  0.3, NA,  NA),
                          nrow = s, ncol = s, byrow = TRUE)

# Second array of coefficients, corresponding to `f_dist_2`.
# First matrix.
f_dist_2_pars_1 &lt;- matrix(c(NA,  6,  0.5, 3,
                            0.5, NA, 4,   0.5,
                            0.4, 5,  NA,  0.7,
                            6,   5,  0.7, NA),
                          nrow = s, ncol = s, byrow = TRUE)
# Second matrix.
f_dist_2_pars_2 &lt;- matrix(c(NA,  NA,  0.4, 0.5,
                            NA,  NA,  NA,  0.6,
                            0.5, NA,  NA,  NA,
                            NA,  0.4, NA,  NA),
                          nrow = s, ncol = s, byrow = TRUE)
# Get `f_dist_pars`.
f_dist_pars_model_1 &lt;- array(c(f_dist_1_pars_1, f_dist_1_pars_2,
                               f_dist_2_pars_1, f_dist_2_pars_2),
                             dim = c(s, s, 2, d + 1))

# ---------------------------------------------------------------------------
# Defining the parametric object for Model 1.
# ---------------------------------------------------------------------------

obj_par_model_1 &lt;- parametric_dsmm(
    model_size = 4000,
    states = states,
    initial_dist = c(0.8, 0.1, 0.1, 0),
    degree = d,
    p_dist = p_dist_model_1,
    f_dist = f_dist_model_1,
    f_dist_pars = f_dist_pars_model_1,
    p_is_drifting = TRUE,
    f_is_drifting = TRUE
)

cat("The object has class of (",
    paste0(class(obj_par_model_1),
           collapse = ', '), ").")


# ---------------------------------------------------------------------------
# Generating a sequence from the parametric object.
# ---------------------------------------------------------------------------

# A larger klim will lead to an increase in accuracy.
klim &lt;- 20
sim_seq &lt;- simulate(obj_par_model_1, klim = klim, seed = 1)


# ---------------------------------------------------------------------------
# Fitting the generated sequence under the same distributions.
# ---------------------------------------------------------------------------

fit_par_model1 &lt;- fit_dsmm(sequence = sim_seq,
                           states = states,
                           degree = d,
                           f_is_drifting = TRUE,
                           p_is_drifting = TRUE,
                           estimation = 'parametric',
                           f_dist = f_dist_model_1)

cat("The object has class of (",
    paste0(class(fit_par_model1),
           collapse = ', '), ").")

cat("\nThe estimated parameters are:\n")
fit_par_model1$dist$f_drift_parameters


</code></pre>

<hr>
<h2 id='simulate.dsmm'>Simulate a sequence under a drifting semi-Markov kernel.</h2><span id='topic+simulate.dsmm'></span>

<h3>Description</h3>

<p>Generic function that simulates a number of states <code>nsim</code>
under the rule of a drifting semi-Markov kernel, which is retrieved from the
object <code>obj</code>, which in turn inherits from the S3 class <code>dsmm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dsmm'
simulate(object, nsim = NULL, seed = NULL, seq_length = NULL, klim = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.dsmm_+3A_object">object</code></td>
<td>
<p>An object of S3 class <code>dsmm</code>,
<code>dsmm_fit_nonparametric</code>, <code>dsmm_nonparametric</code>,
<code>dsmm_fit_parametric</code> or <code>dsmm_parametric</code>.</p>
</td></tr>
<tr><td><code id="simulate.dsmm_+3A_nsim">nsim</code></td>
<td>
<p>Optional. An integer specifying the number of simulations to be made
from the drifting semi-Markov kernel. The maximum value of <code>nsim</code> is the
model size which is specified in <code>obj</code>, which is also the default value.
We define a special case for <code>nsim = 0</code>, where only the initial distribution
is considered and only the simulation of its sojourn time will be made, without
the next state.</p>
</td></tr>
<tr><td><code id="simulate.dsmm_+3A_seed">seed</code></td>
<td>
<p>Optional. An integer specifying the initialization of the random
number generator.</p>
</td></tr>
<tr><td><code id="simulate.dsmm_+3A_seq_length">seq_length</code></td>
<td>
<p>Optional. A positive integer that will ensure the simulated
sequence will not have a <em>total length</em> greater than <code>seq_length</code>
(however, it is possible for the total length to be <em>less</em> than
<code>seq_length</code>).</p>
</td></tr>
<tr><td><code id="simulate.dsmm_+3A_klim">klim</code></td>
<td>
<p>Optional. Positive integer. Passed down to <code>get_kernel</code>
for the parametric object, with class <code>dsmm_parametric</code>.
Default value is <code class="reqn">100</code>.</p>
</td></tr>
<tr><td><code id="simulate.dsmm_+3A_...">...</code></td>
<td>
<p>Optional. Attributes passed down from the <code>simulate</code> method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector based on <code>nsim</code> simulations, with a
maximum length of <code>seq_length</code>.
</p>


<h3>See Also</h3>

<p>About random number generation in R: <code><a href="base.html#topic+RNG">RNG</a></code>.
</p>
<p>Fitting a model through a sequence from this function: <a href="#topic+fit_dsmm">fit_dsmm</a>.
</p>
<p>For the theoretical background of drifting semi-Markov models: <a href="#topic+dsmmR">dsmmR</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Setup.
seq &lt;- create_sequence("DNA", len = 1000)
states &lt;- sort(unique(seq))
d &lt;- 1
obj_model_3 &lt;- fit_dsmm(sequence = seq,
                        states = states,
                        degree = d,
                        f_is_drifting = TRUE,
                        p_is_drifting = FALSE)

# Using the method `simulate.dsmm()`.
simulated_seq &lt;- simulate(obj_model_3, seed = 1)
short_sim &lt;- simulate(obj = obj_model_3, nsim = 10, seed = 1)
cut_sim &lt;- simulate(obj = obj_model_3, seq_length = 10, seed = 1)
str(simulated_seq)
str(short_sim)
str(cut_sim)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
