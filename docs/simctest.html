<!DOCTYPE html><html><head><title>Help for package simctest</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {simctest}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#confidenceLimits-methods'><p>Methods for class &lsquo;mmctestres&rsquo; and &lsquo;mmctest&rsquo;, Package &lsquo;simctest&rsquo;</p></a></li>
<li><a href='#confint-methods'><p>Methods for Function run in Package &lsquo;simctest&rsquo;</p></a></li>
<li><a href='#cont-methods'><p>Methods for Function &lsquo;cont&rsquo; in Package &lsquo;simctest&rsquo;</p></a></li>
<li><a href='#getalgprecomp'><p>Construct algorithms</p></a></li>
<li><a href='#getbounds-methods'><p>Methods for Function getbounds in Package &lsquo;simctest&rsquo;</p></a></li>
<li><a href='#getL-methods'><p>Methods for Function getL in Package &lsquo;simctest&rsquo;</p></a></li>
<li><a href='#getNumber-methods'><p>Methods for Function &lsquo;cont&rsquo; in class &lsquo;mmctestres&rsquo;, Package &lsquo;simctest&rsquo;</p></a></li>
<li><a href='#getSamples-methods'><p>Methods for Function &lsquo;cont&rsquo; in class &lsquo;mmctestres&rsquo;, Package &lsquo;simctest&rsquo;</p></a></li>
<li><a href='#getU-methods'><p>Methods for Function getU in Package &lsquo;simctest&rsquo;</p></a></li>
<li><a href='#hBH-methods'><p>Method for class &lsquo;mcmtest&rsquo;, Package &lsquo;simctest&rsquo;</p></a></li>
<li><a href='#hBonferroni-methods'><p>Method for class &lsquo;mcmtest&rsquo;, Package &lsquo;simctest&rsquo;</p></a></li>
<li><a href='#hPC-methods'><p>Method for class &lsquo;mcmtest&rsquo;, Package &lsquo;simctest&rsquo;</p></a></li>
<li><a href='#mcp'><p>Function mcp in package &lsquo;simctest&rsquo;</p></a></li>
<li><a href='#mcpres-class'><p>Class &quot;mcpres&quot;</p></a></li>
<li><a href='#mctest'><p>Sequential implementation of Monte Carlo</p>
tests with p-valube buckets</a></li>
<li><a href='#mkdeltamid'><p>Function mkdeltamid in Package &lsquo;simctest&rsquo;</p></a></li>
<li><a href='#mmctest-class'><p>Class &quot;mmctest&quot;</p></a></li>
<li><a href='#mmctest-methods'><p>Methods for class &lsquo;mmctest&rsquo;, Package &lsquo;simctest&rsquo;</p></a></li>
<li><a href='#mmctestres-class'><p>Class &quot;mmctestres&quot;</p></a></li>
<li><a href='#mmctSampler-class'><p>Class &quot;mmctest&quot;</p></a></li>
<li><a href='#mmctSampler-methods'><p>Methods for class mmctSampler', Package &lsquo;simctest&rsquo;</p></a></li>
<li><a href='#mmctSamplerGeneric-class'><p>Class &quot;mmctSamplerGeneric&quot;</p></a></li>
<li><a href='#pEstimate-methods'><p>Methods for class &lsquo;mmctestres&rsquo; and &lsquo;mmctest&rsquo;, Package &lsquo;simctest&rsquo;</p></a></li>
<li><a href='#rejProb-methods'><p>Methods for class &lsquo;mmctestres&rsquo; and &lsquo;mmctest&rsquo;, Package &lsquo;simctest&rsquo;</p></a></li>
<li><a href='#run-methods'><p>Methods for Function run in Package &lsquo;simctest&rsquo;</p></a></li>
<li><a href='#sampalg-class'><p>Class &quot;sampalg&quot;</p></a></li>
<li><a href='#sampalgonthefly-class'><p>Class &quot;sampalgonthefly&quot;</p></a></li>
<li><a href='#sampalgontheflyres-class'><p>Class &quot;sampalgontheflyres&quot;</p></a></li>
<li><a href='#sampalgPrecomp-class'><p>Class &quot;sampalgPrecomp&quot;</p></a></li>
<li><a href='#sampalgres-class'><p>Class &quot;sampalgres&quot;</p></a></li>
<li><a href='#simctest'><p>Sequential implementation of Monte Carlo</p>
tests</a></li>
<li><a href='#summary.mmctestres-methods'><p>Methods for class &lsquo;mmctestres&rsquo; and &lsquo;mmctest&rsquo;, Package &lsquo;simctest&rsquo;</p></a></li>
<li><a href='#testResult-methods'><p>Methods for class &lsquo;mmctestres&rsquo; and &lsquo;mmctest&rsquo;, Package &lsquo;simctest&rsquo;</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-11-03</td>
</tr>
<tr>
<td>Title:</td>
<td>Safe Implementation of Monte Carlo Tests</td>
</tr>
<tr>
<td>Author:</td>
<td>Axel Gandy &lt;a.gandy@imperial.ac.uk&gt; with contributions from Patrick Rubin-Delanchy &lt;patrick.rubin-delanchy@imperial.ac.uk&gt;, Georg Hahn &lt;ghahn@cantab.net&gt;, Dong Ding &lt;dong.ding10@imperial.ac.uk&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Axel Gandy &lt;a.gandy@imperial.ac.uk&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.2.0), methods, stats</td>
</tr>
<tr>
<td>Description:</td>
<td>Algorithms for the implementation and evaluation of Monte Carlo tests, as well as for their use in multiple testing procedures.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www2.imperial.ac.uk/~agandy">http://www2.imperial.ac.uk/~agandy</a></td>
</tr>
<tr>
<td>Collate:</td>
<td>mcp.R simctest.R mmctest.R multithresh.R</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-11-04 12:17:55 UTC; agandy</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-11-04 13:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='confidenceLimits-methods'>Methods for class &lsquo;mmctestres&rsquo; and &lsquo;mmctest&rsquo;, Package &lsquo;simctest&rsquo;</h2><span id='topic+confidenceLimits'></span><span id='topic+confidenceLimits-methods'></span><span id='topic+confidenceLimits+2Cmmctestres-method'></span><span id='topic+confidenceLimits+2Cmmctest-method'></span>

<h3>Description</h3>

<p>Function which returns a list containing lower confidence limits (vector &lsquo;lowerLimits&rsquo;) and
upper confidence limits (vector &lsquo;upperLimits&rsquo;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'> confidenceLimits(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confidenceLimits-methods_+3A_obj">obj</code></td>
<td>
<p>object of type &lsquo;mmctestres&rsquo; or &lsquo;mmctest&rsquo;.
</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>confidenceLimits(obj)</dt><dd><p> works with object of type mmctestres or mmctest. </p>
</dd>   
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>  fun &lt;- function(ind,n,data) sapply(1:length(ind), function(i) sum(runif(n[i])&lt;=data[ind[i]]));
  i &lt;- mmctSampler(fun,num=500,data=runif(500));
  a &lt;- mmctest(h=hBH);
  a &lt;- run(a, i, maxsteps=list(maxnum=1000000,undecided=10));
  res &lt;- confidenceLimits(a);
  lower &lt;- res$lowerLimits;
  upper &lt;- res$upperLimits;
</code></pre>

<hr>
<h2 id='confint-methods'>Methods for Function run in Package &lsquo;simctest&rsquo;</h2><span id='topic+confint'></span><span id='topic+confint-methods'></span><span id='topic+confint+2CANY+2CANY-method'></span><span id='topic+confint+2Csampalgres+2Cmissing-method'></span>

<h3>Description</h3>

<p>Computes a confidence interval for the p-value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>confint(object,parm,level=0.95,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint-methods_+3A_object">object</code></td>
<td>
<p>An object of type <code><a href="#topic+sampalgres-class">sampalgres</a></code>
resulting from a previous call to <code><a href="#topic+run-methods">run</a></code>
or
<code><a href="#topic+cont-methods">cont</a></code>.
</p>
</td></tr>
<tr><td><code id="confint-methods_+3A_parm">parm</code></td>
<td>
<p>must be missing.</p>
</td></tr>
<tr><td><code id="confint-methods_+3A_level">level</code></td>
<td>
<p>the desired coverage probability.</p>
</td></tr>
<tr><td><code id="confint-methods_+3A_...">...</code></td>
<td>
<p>additional argument(s). Currently not used</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>object = &quot;ANY&quot;, parm = &quot;ANY&quot;</dt><dd><p>  Generic function: see <code><a href="#topic+confint">confint</a></code>. </p>
</dd>
<dt>object = &quot;sampalgres&quot;, parm = &quot;missing&quot;</dt><dd><p>Computes a confidence
interval for the p-value with the coverage probability given by <code>level</code>. </p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>alg&lt;-getalgonthefly()
res &lt;- run(alg, function() runif(1)&lt;0.05);
res
confint(res)
</code></pre>

<hr>
<h2 id='cont-methods'>Methods for Function &lsquo;cont&rsquo; in Package &lsquo;simctest&rsquo;</h2><span id='topic+cont'></span><span id='topic+cont-methods'></span><span id='topic+cont+2Csampalgres-method'></span><span id='topic+cont+2Csampalgontheflyres-method'></span><span id='topic+cont+2Cmmctestres-method'></span>

<h3>Description</h3>

<p>Continues the sampling for some more steps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> cont(data,steps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cont-methods_+3A_data">data</code></td>
<td>
<p>a result of a run of a sampling algorithm that has not
come to a conclusion yet.
</p>
</td></tr>
<tr><td><code id="cont-methods_+3A_steps">steps</code></td>
<td>
<p>maximum number of further iterations to take.
</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>data = &quot;sampalgres&quot;</dt><dd><p> works with the algorithm based on precomputation. </p>
</dd>   
<dt>data = &quot;sampalgontheflyres&quot;</dt><dd><p> works with the on-the-fly algorithm. </p>
</dd>
<dt>data = &quot;mmctestres&quot;</dt><dd><p> works with object of type &quot;mmctestres&quot;. </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- simctest(function() runif(1)&gt;0.95,maxsteps=10);
res
res &lt;- cont(res,1000)
res
res &lt;- cont(res,1000)
res
</code></pre>

<hr>
<h2 id='getalgprecomp'>Construct algorithms</h2><span id='topic+getalgprecomp'></span><span id='topic+getalgonthefly'></span>

<h3>Description</h3>

<p>Constructs classes of type <code><a href="#topic+sampalgonthefly-class">sampalgonthefly</a></code> and <code><a href="#topic+sampalgPrecomp-class">sampalgPrecomp</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getalgonthefly(level = 0.05, epsilon = 0.001, halfspend = 1000)
getalgprecomp(level = 0.05, epsilon = 0.001, halfspend = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getalgprecomp_+3A_level">level</code></td>
<td>
<p>the threshold.</p>
</td></tr>
<tr><td><code id="getalgprecomp_+3A_epsilon">epsilon</code></td>
<td>
<p>the bound on the resampling risk.</p>
</td></tr>
<tr><td><code id="getalgprecomp_+3A_halfspend">halfspend</code></td>
<td>
<p>number of steps after which half the error has been spent.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>getalgonthefly</code> returns an object of type <code><a href="#topic+sampalgonthefly-class">sampalgonthefly</a></code>.
<code>getalgprecomp</code> returns an object of type <code><a href="#topic+sampalgPrecomp-class">sampalgPrecomp</a></code>.
</p>


<h3>Author(s)</h3>

<p>Axel Gandy</p>


<h3>References</h3>

<p>Gandy, A. (2009) Sequential Implementation of Monte Carlo Tests 
with Uniformly Bounded Resampling Risk. JASA, 104(488):1504-1511.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>alg&lt;-getalgprecomp()
run(alg, function() runif(1)&lt;0.01)

alg&lt;-getalgonthefly()
run(alg, function() runif(1)&lt;0.01)
</code></pre>

<hr>
<h2 id='getbounds-methods'>Methods for Function getbounds in Package &lsquo;simctest&rsquo;</h2><span id='topic+getbounds'></span><span id='topic+getbounds-methods'></span><span id='topic+getbounds+2Csampalgres-method'></span><span id='topic+getbounds+2Csampalgontheflyres-method'></span>

<h3>Description</h3>

<p>returns bounds on the p.value if the algorithm has not stopped yet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getbounds(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getbounds-methods_+3A_data">data</code></td>
<td>
<p>an object of type <code><a href="#topic+sampalgres-class">sampalgres</a></code> or <code>linkS4class{sampalgontheflyres}</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='getL-methods'>Methods for Function getL in Package &lsquo;simctest&rsquo;</h2><span id='topic+getL'></span><span id='topic+getL-methods'></span><span id='topic+getL+2CsampalgPrecomp-method'></span>

<h3>Description</h3>

<p>Returns the lower boundary for the stopping rule
</p>


<h3>Usage</h3>

<pre><code class='language-R'>##S4 method
getL(alg,ind)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getL-methods_+3A_alg">alg</code></td>
<td>
<p>the sampling algorithm</p>
</td></tr>
<tr><td><code id="getL-methods_+3A_ind">ind</code></td>
<td>
<p>a vector of indices at which the lower stopping boundary should
be returned</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>alg = &quot;sampalgPrecomp&quot;</dt><dd><p> the sampling algorithm to be used </p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>   getL(getalgprecomp(),1:100)
</code></pre>

<hr>
<h2 id='getNumber-methods'>Methods for Function &lsquo;cont&rsquo; in class &lsquo;mmctestres&rsquo;, Package &lsquo;simctest&rsquo;</h2><span id='topic+getNumber'></span><span id='topic+getNumber-methods'></span><span id='topic+getNumber+2CmmctSamplerGeneric-method'></span><span id='topic+getNumber+2CmmctSampler-method'></span>

<h3>Description</h3>

<p>Function to request number of hypotheses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> getNumber(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getNumber-methods_+3A_obj">obj</code></td>
<td>
<p>object of type &quot;mmctSampler&quot; derived from class &quot;mmctSamplerGeneric&quot;.
</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>getNumber(obj)</dt><dd><p> works with object of type &quot;mmctSampler&quot; derived from class &quot;mmctSamplerGeneric&quot;. </p>
</dd>   
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>  fun &lt;- function(ind,n,data) sapply(1:length(ind), function(i) sum(runif(n[i])&lt;=data[ind[i]]));
  i &lt;- mmctSampler(fun,num=500,data=runif(500));
  number &lt;- getNumber(i);
</code></pre>

<hr>
<h2 id='getSamples-methods'>Methods for Function &lsquo;cont&rsquo; in class &lsquo;mmctestres&rsquo;, Package &lsquo;simctest&rsquo;</h2><span id='topic+getSamples'></span><span id='topic+getSamples-methods'></span><span id='topic+getSamples+2CmmctSamplerGeneric-method'></span><span id='topic+getSamples+2CmmctSampler-method'></span>

<h3>Description</h3>

<p>Function to request further samples from certain hypotheses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> getSamples(obj, ind, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSamples-methods_+3A_obj">obj</code></td>
<td>
<p>object of type &quot;mmctSampler&quot; derived from class &quot;mmctSamplerGeneric&quot;.
</p>
</td></tr>
<tr><td><code id="getSamples-methods_+3A_ind">ind</code></td>
<td>
<p>vector containing the indices of hypotheses
for which further samples are requested.
</p>
</td></tr>
<tr><td><code id="getSamples-methods_+3A_n">n</code></td>
<td>
<p>vector containing number of further samples for each hypothesis in vector &lsquo;ind&rsquo;.
</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>getSamples(obj, ind, n)</dt><dd><p> works with object of type &quot;mmctSampler&quot; derived from class &quot;mmctSamplerGeneric&quot;. </p>
</dd>   
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>  fun &lt;- function(ind,n,data) sapply(1:length(ind), function(i) sum(runif(n[i])&lt;=data[ind[i]]));
  i &lt;- mmctSampler(fun,num=500,data=runif(500));
  samples &lt;- getSamples(i, c(1,2), c(2,2));
</code></pre>

<hr>
<h2 id='getU-methods'>Methods for Function getU in Package &lsquo;simctest&rsquo;</h2><span id='topic+getU'></span><span id='topic+getU-methods'></span><span id='topic+getU+2CsampalgPrecomp-method'></span>

<h3>Description</h3>

<p>Returns the upper boundary for the stopping rule
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getU(alg,ind)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getU-methods_+3A_alg">alg</code></td>
<td>
<p>the sampling algorithm</p>
</td></tr>
<tr><td><code id="getU-methods_+3A_ind">ind</code></td>
<td>
<p>a vector of indices at which the upper stopping boundary should
be returned</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>alg = &quot;sampalgPrecomp&quot;</dt><dd><p> the sampling algorithm to be used </p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>   getU(getalgprecomp(),1:100)
</code></pre>

<hr>
<h2 id='hBH-methods'>Method for class &lsquo;mcmtest&rsquo;, Package &lsquo;simctest&rsquo;</h2><span id='topic+hBH'></span><span id='topic+hBH-methods'></span>

<h3>Description</h3>

<p>Implementation of the multiple testing procedure by Benjamini-Hochberg.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> hBH(p, threshold)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hBH-methods_+3A_p">p</code></td>
<td>
<p>object of type &quot;numeric&quot;.  </p>
</td></tr>
<tr><td><code id="hBH-methods_+3A_threshold">threshold</code></td>
<td>
<p>object of type &quot;numeric&quot;.  </p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>hBH(p, threshold)</dt><dd><p>applies the Benjamini-Hochberg procedure to p-values p with given threshold, returns rejected indices</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>hBH(runif(10),threshold=0.1)
</code></pre>

<hr>
<h2 id='hBonferroni-methods'>Method for class &lsquo;mcmtest&rsquo;, Package &lsquo;simctest&rsquo;</h2><span id='topic+hBonferroni'></span><span id='topic+hBonferroni-methods'></span>

<h3>Description</h3>

<p>Implementation of independent (Bonferroni) multiple testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> hBonferroni(p, threshold)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hBonferroni-methods_+3A_p">p</code></td>
<td>
<p>object of type &quot;numeric&quot;.  </p>
</td></tr>
<tr><td><code id="hBonferroni-methods_+3A_threshold">threshold</code></td>
<td>
<p>object of type &quot;numeric&quot;.  </p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>hBonferroni(p, threshold)</dt><dd><p>performs independent multiple testing using the Bonferroni correction at given threshold, returns rejected indices</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>hBonferroni(runif(10),threshold=0.1)
</code></pre>

<hr>
<h2 id='hPC-methods'>Method for class &lsquo;mcmtest&rsquo;, Package &lsquo;simctest&rsquo;</h2><span id='topic+hPC'></span><span id='topic+hPC-methods'></span>

<h3>Description</h3>

<p>Implementation of the multiple testing procedure by Pounds&amp;Cheng.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> hPC(p, threshold)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hPC-methods_+3A_p">p</code></td>
<td>
<p>object of type &quot;numeric&quot;.  </p>
</td></tr>
<tr><td><code id="hPC-methods_+3A_threshold">threshold</code></td>
<td>
<p>object of type &quot;numeric&quot;.  </p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>hPC(p, threshold)</dt><dd><p>applies the modification by Pounds&amp;Cheng to p-values p with given threshold, returns rejected indices</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>hPC(runif(10),threshold=0.1)
</code></pre>

<hr>
<h2 id='mcp'>Function mcp in package &lsquo;simctest&rsquo;</h2><span id='topic+mcp'></span>

<h3>Description</h3>

<p>An algorithm for the computation of the power of Monte Carlo tests with guaranteed precision</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcp(genstream,alpha=0.05,delta="adaptive",
cp=0.99,maxeffort=Inf,options = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcp_+3A_genstream">genstream</code></td>
<td>
<p>a function that returns a function that returns a
random Bernoulli variable (each stream corresponds to a
dataset. 0 = (T&lt;t), 1= (T&gt;=t) where t is computed from the dataset
and T is a resampled test-statistic from that dataset.)</p>
</td></tr>
<tr><td><code id="mcp_+3A_alpha">alpha</code></td>
<td>
<p>the level of the test.</p>
</td></tr>
<tr><td><code id="mcp_+3A_delta">delta</code></td>
<td>
<p>the desired length of confidence interval, or &quot;adaptive&quot; if using adaptive delta. See details.</p>
</td></tr>
<tr><td><code id="mcp_+3A_maxeffort">maxeffort</code></td>
<td>
<p>maximum effort. Effort is total number of samples taken. Set to finite value if needed (the resulting confidence interval still has the guaranteed coverage probability, but may not be as &lsquo;short&rsquo; as desired). Can also interrupt the algorithm during main loop and get a result of class <code>"mcpres"</code>.</p>
</td></tr>
<tr><td><code id="mcp_+3A_cp">cp</code></td>
<td>
<p>the desired coverage probability.</p>
</td></tr>
<tr><td><code id="mcp_+3A_options">options</code></td>
<td>
<p>Additional options. See details</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>options$maxeffort</code>: set to maximum allowable effort.
</p>
<p><code>options$reports</code>: set to <code>FALSE</code> if onscreen reports are not wanted. 
</p>
<p><code>options$file</code>: optional file-name to save results to.
</p>
<p><code>options$pilotn</code>: number of streams in pilot (1000 by default).
</p>
<p><code>options$pilotmaxsteps</code>: maxsteps in pilot (1000 by default).
</p>
<p><code>options$gammapilotprop</code>: proportion of error spent on pilot CI
(0.1 by default)
</p>
<p><code>options$gammatestprop</code>: proportion of error spent on testing
remaining paths (default is 0.1)
</p>
<p><code>options$spendgammatest</code>: spending sequence for the testing
procedure on the remaining streams. Must be a non-negative function
of integers with positive limit 1 (<code class="reqn">t/(20+t)</code> by default).
</p>
<p><code>options$eta</code>: internal parameter to the testing procedure on the
remaining streams (0.05 by default).
</p>
<p><code>options$maxstepsbase</code>: initial maximum number of steps (500 by
default)
</p>
<p><code>options$maxstepsinc</code>: multiplier for the maximum number of steps
thereafter (1.5 by default).
</p>
<p><code>options$maxbatch</code>: multiplier for the maximum number of steps
thereafter (200000 by default).
</p>
<p><code>options$deltamid</code>: adaptive delta function. Describes the length
of the confidence interval desired depending on the midpoint of the
interval. By default the function requires 0.02 for intervals
containing 0.05 or lower or 0.95 or higher, and 0.1 otherwise. If
using non-default adaptive delta must also specify epsilon
(below).
</p>
<p><code>options$epsilon</code>: error probability for each stream. Only set if using non-standard adaptive delta.
</p>


<h3>Value</h3>

<p>An object of class <code>"mcpres"</code> with slots:
</p>
<table>
<tr><td><code>int</code></td>
<td>
<p>confidence interval for power.</p>
</td></tr>
<tr><td><code>cp</code></td>
<td>
<p>coverage probability.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>Estimate of power.</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>the number of streams started in main loop (or in pilot if
stopped after pilot).</p>
</td></tr>
<tr><td><code>effort</code></td>
<td>
<p>total number of samples generated.</p>
</td></tr>
<tr><td><code>rescount</code></td>
<td>
<p>number of positive and negative outcomes.</p>
</td></tr>
<tr><td><code>truncated</code></td>
<td>
<p>boolean indicating whether procedure was truncated by
user-specified maxeffort.</p>
</td></tr>
<tr><td><code>taccepted</code></td>
<td>
<p>boolean indicating whether the procedure stopped as a
result of a hypothesis test or brute force (the confidence interval coverage probability is guaranteed in either case.)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Axel Gandy and Patrick Rubin-Delanchy</p>


<h3>References</h3>

<p>Gandy, A. and Rubin-Delanchy, P.  An algorithm to compute the power of Monte Carlo tests with guaranteed precision. Annals of Statistics, 41(1):125&ndash;142, 2013.</p>


<h3>See Also</h3>

<p><code>mkdeltamid</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#The following example takes a bit of computing time
## Not run: 
#Example where we know the power should be the level of the test
genstream &lt;- function(){p &lt;- runif(1); function(N){runif(N) &lt;= p}}

res &lt;- mcp(genstream, alpha=0.05, delta="adaptive", cp=0.99)

#should find confidence interval of length 0.02 centered around 0.05
res

## End(Not run)
</code></pre>

<hr>
<h2 id='mcpres-class'>Class &quot;mcpres&quot;</h2><span id='topic+mcpres-class'></span><span id='topic+show+2Cmcpres-method'></span>

<h3>Description</h3>

<p>Result returned by <code>mcp</code></p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("mcpres", ...)</code>.
</p>


<h3>Slots</h3>

       
<dl>
<dt><code>int</code>:</dt><dd><p>Object of class <code>"numeric"</code></p>
</dd>
<dt><code>cp</code>:</dt><dd><p>Object of class <code>"numeric"</code></p>
</dd>
<dt><code>beta</code>:</dt><dd><p>Object of class <code>"numeric"</code></p>
</dd>
<dt><code>N</code>:</dt><dd><p>Object of class <code>"numeric"</code></p>
</dd>
<dt><code>effort</code>:</dt><dd><p>Object of class <code>"numeric"</code></p>
</dd>
<dt><code>rescount</code>:</dt><dd><p>Object of class <code>"numeric"</code></p>
</dd>
<dt><code>truncated</code>:</dt><dd><p>Object of class <code>"logical"</code></p>
</dd>
<dt><code>taccepted</code>:</dt><dd><p>Object of class <code>"logical"</code></p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>show</dt><dd><p><code>signature(object = "mcpres")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Axel Gandy and Patrick Rubin-Delanchy</p>


<h3>References</h3>

<p>Gandy, A. and Rubin-Delanchy, P (2013). An Algorithm to
compute the power of Monte Carlo tests with guaranteed
precision. Annals of Statistics, 41(1):125&ndash;142.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("mcpres")
</code></pre>

<hr>
<h2 id='mctest'>Sequential implementation of Monte Carlo
tests with p-valube buckets</h2><span id='topic+mctest'></span><span id='topic+mctest.RL'></span><span id='topic+mctest.simctest'></span><span id='topic+print.mctestres'></span><span id='topic+J'></span><span id='topic+Jstar'></span>

<h3>Description</h3>

<p>Sequential implementation
of the Monte Carlo test with p-value buckets.
</p>
<p>Implementation of the Robbins-Lai (mctest.RL) and SIMCTEST (mctest.simctest) approaches to compute a decision interval (and decision) with respect to several thresholds/ p-value buckets.
The function &quot;mctest&quot; is a wrapper function for both the Robbins-Lai and the SIMCTEST approach which calls one of the two using an additional parameter &quot;method&quot; (method=&quot;simctest&quot; for SIMCTEST and method=&quot;RL&quot; for Robbins-Lai).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mctest(gen,J=Jstar,epsilon=0.001,batch=10,batchincrement=1.1,maxbatch=100,
  method=c("simctest","RL"))
mctest.RL(gen,J=Jstar,epsilon=0.001,batch=10,batchincrement=1.1,maxbatch=100)
mctest.simctest(gen,J=Jstar,epsilon=0.001,batch=10,batchincrement=1.1,maxbatch=100)
J
Jstar
## S3 method for class 'mctestres'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mctest_+3A_gen">gen</code></td>
<td>
<p>function that performs one sampling step. 
Returns 0 (sampled test statistic does not exceed the observation)
or 1 (sampled test static exceeds the observation)
</p>
</td></tr>
<tr><td><code id="mctest_+3A_method">method</code></td>
<td>
<p>which method to use for stopping</p>
</td></tr>
<tr><td><code id="mctest_+3A_j">J</code></td>
<td>
<p>p-value buckets to use. A matrix with two rows, each column
describes an interval bucket. Column names give the code for the
interval bucket. Defaults to Jstar.
</p>
</td></tr>
<tr><td><code id="mctest_+3A_epsilon">epsilon</code></td>
<td>
<p>error bound</p>
</td></tr>
<tr><td><code id="mctest_+3A_batch">batch</code></td>
<td>
<p>initial number of samples to use before checking for stopping</p>
</td></tr>
<tr><td><code id="mctest_+3A_batchincrement">batchincrement</code></td>
<td>
<p>factor by which the batch size gets multiplied
after each step. 1 would mean no increment</p>
</td></tr>
<tr><td><code id="mctest_+3A_maxbatch">maxbatch</code></td>
<td>
<p>maximum batch size</p>
</td></tr>
<tr><td><code id="mctest_+3A_x">x</code></td>
<td>
<p>object of type &quot;mctestres&quot;</p>
</td></tr>
<tr><td><code id="mctest_+3A_...">...</code></td>
<td>
<p>further arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>mctest</code>, <code>mctest.RL</code> and <code>mctest.simctest</code> all
return an object of class type  <code>mctestres</code>, which has a print
function (<code>print.mctestres</code>).
</p>
<p>An object of class <code>mctestres</code> is a list with  the
following components: <code>step</code> (total batched number of samples drawn), <code>decision.interval</code> (interval for the p-value), <code>decision</code> (expressing significance), <code>est.p</code> (an estimate of the p-value) and <code>realn</code> (the actual number of samples taken without batching).
</p>


<h3>References</h3>

<p>Ding, D., Gandy, A. and Hahn, G. (2019) Implementing Monte Carlo Tests
with P-value Buckets. To appear in Scandinavian Journal of
Statistics. arXiv:1703.09305 [stat.ME].
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #Example used in the above paper
  dat &lt;- matrix(nrow=5,ncol=7,byrow=TRUE,
                c(1,2,2,1,1,0,1, 2,0,0,2,3,0,0, 0,1,1,1,2,7,3, 1,1,2,0,0,0,1, 0,1,1,1,1,0,0))
  loglikrat &lt;- function(data){
    cs &lt;- colSums(data)
    rs &lt;- rowSums(data)
    mu &lt;- outer(rs,cs)/sum(rs)
    2*sum(ifelse(data&lt;=0.5, 0,data*log(data/mu)))
  }
  resample &lt;- function(data){
    cs &lt;- colSums(data)
    rs &lt;- rowSums(data)
    n &lt;- sum(rs)
    mu &lt;- outer(rs,cs)/n/n
    matrix(rmultinom(1,n,c(mu)),nrow=dim(data)[1],ncol=dim(data)[2])
  }
  t &lt;- loglikrat(dat);

  # function to generate samples
  gen &lt;- function(){loglikrat(resample(dat))&gt;=t}

  #using simctest
  mctest(gen)
  mctest.simctest(gen)
  mctest.RL(gen)
</code></pre>

<hr>
<h2 id='mkdeltamid'>Function mkdeltamid in Package &lsquo;simctest&rsquo;</h2><span id='topic+mkdeltamid'></span>

<h3>Description</h3>

<p>Easy creation of adaptive delta function</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkdeltamid(mindelta=0.02, maxdelta=0.1, llim=0.05, rlim=0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkdeltamid_+3A_mindelta">mindelta</code></td>
<td>
<p>desired length of CI for regions of interest, such as
when the power is less than 0.05 or greater than 0.95.</p>
</td></tr>
<tr><td><code id="mkdeltamid_+3A_maxdelta">maxdelta</code></td>
<td>
<p>desired length of CI when power is not in reregion of
interest, e.g. between 0.05 and 0.95 </p>
</td></tr>
<tr><td><code id="mkdeltamid_+3A_llim">llim</code></td>
<td>
<p>change if want different left limit (i.e. not 0.05)</p>
</td></tr>
<tr><td><code id="mkdeltamid_+3A_rlim">rlim</code></td>
<td>
<p>change if want different right limit (i.e. not 0.95)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function, say <code>deltamid</code>, that specifies
the user's desired precision depending on the midpoint of the computed confidence interval.
If the current confidence interval has a midpoint M, then the
algorithm will stop if deltamid(M) &lt;= length of CI.
</p>


<h3>Author(s)</h3>

<p> Axel Gandy and Patrick Rubin-Delanchy</p>


<h3>References</h3>

<p>Gandy, A. and Rubin-Delanchy, P (2013). An Algorithm to
compute the power of Monte Carlo tests with guaranteed
precision. Annals of Statistics, 41(1):125&ndash;142.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## only care about powers around 0.9 or higher
## (e.g. if want to check that the test is powerful enough).

deltamid &lt;- mkdeltamid(mindelta=0.02, maxdelta=1, llim=0, rlim=0.9)

genstream &lt;- function(){p &lt;- runif(1); function(N){runif(N) &lt;= p}}

## The power is 0.05. The algorithm should stop as soon as it is clear
## that the power is not larger than 0.9. (Must specify epsilon
## if using non-standard delta.)

res &lt;- mcp(genstream, alpha=0.05, delta="adaptive", cp=0.99,
options=list(deltamid = deltamid, epsilon = 0.0001))

##should stop early.
res
</code></pre>

<hr>
<h2 id='mmctest-class'>Class &quot;mmctest&quot;</h2><span id='topic+mmctest-class'></span>

<h3>Description</h3>

<p>Class which creates an object of type &quot;mmctestres&quot;.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>mmctest(h=...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>internal</code>:</dt><dd><p>Object of class <code>"environment"</code>  </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>run</dt><dd><p><code>signature(alg = "mmctest", gensample = "mmctSamplerGeneric", maxsteps = "numeric")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Axel Gandy and Georg Hahn </p>


<h3>References</h3>

<p>Gandy, A. and Hahn, G. (2014) MMCTest - a safe algorithm for
implementing multiple Monte Carlo tests. Scandinavian Journal of
Statistics, 41(4):1083&ndash;1101
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fun &lt;- function(ind,n,data) sapply(1:length(ind), function(i) sum(runif(n[i])&lt;=data[ind[i]]));
  i &lt;- mmctSampler(fun,num=500,data=runif(500));
  a &lt;- mmctest(h=hBH);
  a &lt;- run(a, i, maxsteps=list(maxnum=1000000,undecided=10));
</code></pre>

<hr>
<h2 id='mmctest-methods'>Methods for class &lsquo;mmctest&rsquo;, Package &lsquo;simctest&rsquo;</h2><span id='topic+mmctest'></span><span id='topic+mmctest-methods'></span>

<h3>Description</h3>

<p>Constructor for class &lsquo;mmctest&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> mmctest(epsilon=0.01, threshold=0.1, r=10000, h, thompson=F, R=1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mmctest-methods_+3A_epsilon">epsilon</code></td>
<td>
<p>probability of any misclassification one is willing to tolerate
</p>
</td></tr>
<tr><td><code id="mmctest-methods_+3A_threshold">threshold</code></td>
<td>
<p>threshold for testing.
</p>
</td></tr>
<tr><td><code id="mmctest-methods_+3A_r">r</code></td>
<td>
<p>parameter of the spending sequence, see vignette
</p>
</td></tr>
<tr><td><code id="mmctest-methods_+3A_h">h</code></td>
<td>
<p>reference to a multiple testing function of the
form function(p, threshold) which returns the set of
rejected indices.
</p>
</td></tr>
<tr><td><code id="mmctest-methods_+3A_thompson">thompson</code></td>
<td>
<p>if set to true, mmctest will use a Thompson strategy to draw further samples
</p>
</td></tr>
<tr><td><code id="mmctest-methods_+3A_r">R</code></td>
<td>
<p>number of repetitions (=draws from the posterior distributions) used to calculate
empirical probabilities of each hypothesis being rejected &ndash; used to calculate weights
in QuickMMCTest (option thompson=TRUE in the mmctest constructor)
</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>mmctest(epsilon=0.01, threshold=0.1, r=10000, h)</dt><dd><p> returns object of type &lsquo;mmctest&rsquo;. </p>
</dd>   
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>  fun &lt;- function(ind,n,data) sapply(1:length(ind), function(i) sum(runif(n[i])&lt;=data[ind[i]]));
  i &lt;- mmctSampler(fun,num=500,data=runif(500));
  a &lt;- mmctest(h=hBH);
  a &lt;- run(a, i, maxsteps=list(maxnum=1000000,undecided=10));
</code></pre>

<hr>
<h2 id='mmctestres-class'>Class &quot;mmctestres&quot;</h2><span id='topic+mmctestres-class'></span><span id='topic+show+2Cmmctestres-method'></span>

<h3>Description</h3>

<p>Class which stores current result of type &quot;mmctest&quot;.</p>


<h3>Objects from the Class</h3>

<p>Objects should not be created directly.
Objects returned by calls of the form <code>new("mmctest", ...)</code>
are of type mmctestres.
</p>


<h3>Slots</h3>


<dl>
<dt><code>internal</code>:</dt><dd><p>Object of class <code>"environment"</code>  </p>
</dd>
<dt><code>epsilon</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>threshold</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>r</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>R</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>h</code>:</dt><dd><p>Object of class <code>"function"</code>  </p>
</dd>
<dt><code>gensample</code>:</dt><dd><p>Object of class <code>"mmctSamplerGeneric"</code>  </p>
</dd>
<dt><code>g</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>num</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>A</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>B</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>C</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>thompson</code>:</dt><dd><p>Object of class <code>"logical"</code>  </p>
</dd>
<dt><code>rejprob</code>:</dt><dd><p>Object of class <code>"logical"</code>  </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>mainalg</dt><dd><p><code>signature(obj = "mmctestres", stopcrit = "numeric")</code>: ... </p>
</dd>
<dt>cont</dt><dd><p><code>signature(data = "mmctestres", steps = "numeric")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "mmctestres")</code>: ... </p>
</dd>
<dt>pEstimate</dt><dd><p><code>signature(obj = "mmctestres")</code>: ... </p>
</dd>
<dt>rejProb</dt><dd><p><code>signature(obj = "mmctestres")</code>: ... </p>
</dd>
<dt>confidenceLimits</dt><dd><p><code>signature(obj = "mmctestres")</code>: ... </p>
</dd>
<dt>testResult</dt><dd><p><code>signature(obj = "mmctestres")</code>: ... </p>
</dd>
<dt>summary.mmctestres</dt><dd><p><code>signature(object = "mmctestres")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Axel Gandy and Georg Hahn </p>


<h3>References</h3>

<p>Gandy, A. and Hahn, G. (2014) MMCTest - a safe algorithm for
implementing multiple Monte Carlo tests. Scandinavian Journal of
Statistics, 41(4):1083&ndash;1101
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fun &lt;- function(ind,n,data) sapply(1:length(ind), function(i) sum(runif(n[i])&lt;=data[ind[i]]));
  i &lt;- mmctSampler(fun,num=500,data=runif(500));
  a &lt;- mmctest(h=hBH);
  a &lt;- run(a, i, maxsteps=list(maxnum=1000000,undecided=10));
  # a is object of type "mmctestres" now
</code></pre>

<hr>
<h2 id='mmctSampler-class'>Class &quot;mmctest&quot;</h2><span id='topic+mmctSampler-class'></span>

<h3>Description</h3>

<p>Wrapper-Class for &quot;mmctestInterfaceGeneric&quot;, takes a function, the number
of hypotheses and returns derived object of class &quot;mmctestInterfaceGeneric&quot;.
Class provides a slot for additional data.
The function f(ind,n,data) has to return n[i] new samples for each hypothesis ind[i]
in vector &quot;ind&quot;, where i=1...length(ind).
The data stored in the data slot of class &quot;mmctSampler&quot; is also
passed on to &quot;f&quot;.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>mmctSampler(f=...,num=...,data=...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>f</code>:</dt><dd><p>Object of class <code>"function"</code>  </p>
</dd>
<dt><code>num</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>getSamples</dt><dd><p><code>signature(obj="mmctSampler", ind="numeric", n="numeric")</code>: ... </p>
</dd>
<dt>getNumber</dt><dd><p><code>signature(obj="mmctSampler")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Axel Gandy and Georg Hahn </p>


<h3>References</h3>

<p>Gandy, A. and Hahn, G. (2014) MMCTest - a safe algorithm for
implementing multiple Monte Carlo tests. Scandinavian Journal of
Statistics, 41(4):1083&ndash;1101
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  fun &lt;- function(ind,n,data) sapply(1:length(ind), function(i) sum(runif(n[i])&lt;=data[ind[i]]));
  i &lt;- mmctSampler(fun,num=500,data=runif(500));
</code></pre>

<hr>
<h2 id='mmctSampler-methods'>Methods for class mmctSampler', Package &lsquo;simctest&rsquo;</h2><span id='topic+mmctSampler'></span><span id='topic+mmctSampler-methods'></span>

<h3>Description</h3>

<p>Constructor for class 'mmctSampler'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> mmctSampler(f, num, data=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mmctSampler-methods_+3A_f">f</code></td>
<td>
<p>a function f(ind,n,data) which for every hypothesis ind[i]
in vector &quot;ind&quot; returns n[i] new samples and returns the number of
exceedances, where i=1...length(ind).
The data stored in the data slot of class
&quot;mmctSampler&quot; is also passed on to &quot;f&quot;.
</p>
</td></tr>
<tr><td><code id="mmctSampler-methods_+3A_num">num</code></td>
<td>
<p>number of hypotheses.
</p>
</td></tr>
<tr><td><code id="mmctSampler-methods_+3A_data">data</code></td>
<td>
<p>additional slot for data.
</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>mmctSampler(f, num, data)</dt><dd><p> returns object of type 'mmctSampler'
(derived from class 'mmctSamplerGeneric'). </p>
</dd>   
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>  fun &lt;- function(ind,n,data) sapply(1:length(ind), function(i) sum(runif(n[i])&lt;=data[ind[i]]));
  i &lt;- mmctSampler(fun,num=500,data=runif(500));
</code></pre>

<hr>
<h2 id='mmctSamplerGeneric-class'>Class &quot;mmctSamplerGeneric&quot;</h2><span id='topic+mmctSamplerGeneric-class'></span>

<h3>Description</h3>

<p>Generic class, has to be implemented as &quot;mmctSampler&quot;.</p>


<h3>Objects from the Class</h3>

<p>This is a virtual class - no objects should be derived from it.
</p>


<h3>Methods</h3>


<dl>
<dt>getSamples</dt><dd><p><code>signature(obj = "mmctSamplerGeneric", ind = "numeric", n = "numeric")</code>: ... </p>
</dd>
<dt>getNumber</dt><dd><p><code>signature(obj = "mmctSamplerGeneric")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Axel Gandy and Georg Hahn </p>


<h3>References</h3>

<p>Gandy, A. and Hahn, G. (2014) MMCTest - a safe algorithm for
implementing multiple Monte Carlo tests. Scandinavian Journal of
Statistics, 41(4):1083&ndash;1101
</p>

<hr>
<h2 id='pEstimate-methods'>Methods for class &lsquo;mmctestres&rsquo; and &lsquo;mmctest&rsquo;, Package &lsquo;simctest&rsquo;</h2><span id='topic+pEstimate'></span><span id='topic+pEstimate-methods'></span><span id='topic+pEstimate+2Cmmctestres-method'></span><span id='topic+pEstimate+2Cmmctest-method'></span>

<h3>Description</h3>

<p>Function which shows current estimates of p-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> pEstimate(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pEstimate-methods_+3A_obj">obj</code></td>
<td>
<p>object of type &lsquo;mmctestres&rsquo; or &lsquo;mmctest&rsquo;.
</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>pEstimate(obj)</dt><dd><p> works with object of type mmctestres or mmctest. </p>
</dd>   
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>  fun &lt;- function(ind,n,data) sapply(1:length(ind), function(i) sum(runif(n[i])&lt;=data[ind[i]]));
  i &lt;- mmctSampler(fun,num=500,data=runif(500));
  a &lt;- mmctest(h=hBH);
  a &lt;- run(a, i, maxsteps=list(maxnum=1000000,undecided=10));
  pEstimate(a);
</code></pre>

<hr>
<h2 id='rejProb-methods'>Methods for class &lsquo;mmctestres&rsquo; and &lsquo;mmctest&rsquo;, Package &lsquo;simctest&rsquo;</h2><span id='topic+rejProb'></span><span id='topic+rejProb-methods'></span><span id='topic+rejProb+2Cmmctestres-method'></span><span id='topic+rejProb+2Cmmctest-method'></span>

<h3>Description</h3>

<p>Function which returns empirical rejection probabilities.
Threshold against e.g. 0.5 to obtain rejections (all rejProb&gt;0.5 are rejected).
Important: For usage in connection with thompson=TRUE (see the mmctest constructor).
</p>


<h3>Usage</h3>

<pre><code class='language-R'> rejProb(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rejProb-methods_+3A_obj">obj</code></td>
<td>
<p>object of type &lsquo;mmctestres&rsquo; or &lsquo;mmctest&rsquo;.
</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>rejProb(obj)</dt><dd><p> works with object of type mmctestres or mmctest. </p>
</dd>   
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>  fun &lt;- function(ind,n,data) sapply(1:length(ind), function(i) sum(runif(n[i])&lt;=data[ind[i]]));
  i &lt;- mmctSampler(fun,num=500,data=runif(500));
  a &lt;- mmctest(h=hBH);
  a &lt;- run(a, i, maxsteps=list(maxnum=1000000,undecided=10));
  rejProb(a);
</code></pre>

<hr>
<h2 id='run-methods'>Methods for Function run in Package &lsquo;simctest&rsquo;</h2><span id='topic+run'></span><span id='topic+run-methods'></span><span id='topic+run+2CsampalgPrecomp+2CANY-method'></span><span id='topic+run+2Csampalgonthefly+2CANY-method'></span><span id='topic+run+2Cmmctest+2CmmctSamplerGeneric-method'></span>

<h3>Description</h3>

<p>Starts a sampling algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  run(alg,gensample,maxsteps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run-methods_+3A_alg">alg</code></td>
<td>
<p>the sampling algorithm. An object of type &quot;sampalg&quot; or &quot;mmctest&quot;.
</p>
</td></tr>
<tr><td><code id="run-methods_+3A_gensample">gensample</code></td>
<td>
<p>a function returing the result of one resampling step
(0=no rejection, 1=rejection of the null hypothesis), or an object of
type &quot;mmctSamplerGeneric&quot; if alg=&quot;mmctest&quot;.
</p>
</td></tr>
<tr><td><code id="run-methods_+3A_maxsteps">maxsteps</code></td>
<td>
<p>the maximal number of steps to take
</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>alg = &quot;sampalgPrecomp&quot;</dt><dd><p> the algorithm to be used </p>
</dd>
<dt>alg = &quot;sampalgonthefly&quot;</dt><dd><p> the algorithm to be used </p>
</dd>
<dt>alg = &quot;mmctest&quot;, gensample = &quot;mmctSamplerGeneric&quot;</dt><dd><p> the algorithm to be used </p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>alg&lt;-getalgonthefly()
res &lt;- run(alg, function() runif(1)&lt;0.2);
res
</code></pre>

<hr>
<h2 id='sampalg-class'>Class &quot;sampalg&quot;</h2><span id='topic+sampalg-class'></span>

<h3>Description</h3>

<p>Virtual base class for several sequential sampling algorithms.</p>


<h3>Objects from the Class</h3>

<p>This is a virtual class - no objects should be derived from it.
</p>


<h3>Slots</h3>


<dl>
<dt><code>internal</code>:</dt><dd><p>Internal status data of the algorithm. Object of class <code>"environment"</code>  </p>
</dd>
</dl>



<h3>Methods</h3>

<p>No methods defined with class &quot;sampalg&quot; in the signature.
</p>


<h3>Author(s)</h3>

<p> Axel Gandy </p>


<h3>See Also</h3>

<p><code><a href="#topic+sampalgonthefly-class">sampalgonthefly</a></code>, <code><a href="#topic+sampalgPrecomp-class">sampalgPrecomp</a></code>
</p>

<hr>
<h2 id='sampalgonthefly-class'>Class &quot;sampalgonthefly&quot;</h2><span id='topic+sampalgonthefly'></span><span id='topic+sampalgonthefly-class'></span>

<h3>Description</h3>

<p>A sequential sampling algorithm that creates its boundaries
on the fly.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>getalgonthefly(level,epsilon,halfspend)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>internal</code>:</dt><dd><p>Object of class
<code>"environment"</code>. Internal state of the algorithm. Do not access. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+sampalg-class">sampalg</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>run</dt><dd><p><code>signature(alg = "sampalgonthefly")</code>: ... </p>
</dd>
</dl>


<dl>
<dt>getboundaryandprob</dt><dd><p><code>signature(alg = "sampalgonthefly")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Axel Gandy </p>


<h3>References</h3>

<p>Gandy, A. (2009) Sequential Implementation of Monte Carlo Tests 
with Uniformly Bounded Resampling Risk. JASA 104(488):1504-1511.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sampalgPrecomp-class">sampalgPrecomp</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("sampalgonthefly")
</code></pre>

<hr>
<h2 id='sampalgontheflyres-class'>Class &quot;sampalgontheflyres&quot;</h2><span id='topic+sampalgontheflyres-class'></span><span id='topic+contalg+2Csampalgontheflyres-method'></span>

<h3>Description</h3>

<p>Class returned as result from <code>simctest</code> and <code>run</code>.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("sampalgontheflyres", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>porig</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>U</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>L</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>ind</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>preverr</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>p.value</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>steps</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>pos</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>alg</code>:</dt><dd><p>Object of class <code>"sampalg"</code>  </p>
</dd>
<dt><code>gen</code>:</dt><dd><p>Object of class <code>"function"</code>  </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+sampalgres-class">sampalgres</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>contalg</dt><dd><p><code>signature(data = "sampalgontheflyres")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Axel Gandy </p>


<h3>References</h3>

<p>Gandy, A. (2009) Sequential Implementation of Monte Carlo Tests 
with Uniformly Bounded Resampling Risk. JASA 104(488):1504-1511.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simctest">simctest</a></code>, <code><a href="#topic+sampalgres-class">sampalgres</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("sampalgontheflyres")
</code></pre>

<hr>
<h2 id='sampalgPrecomp-class'>Class &quot;sampalgPrecomp&quot;</h2><span id='topic+sampalgPrecomp'></span><span id='topic+sampalgPrecomp-class'></span>

<h3>Description</h3>

<p>A sampling algorithm that precomputes the boundaries</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls to <code><a href="#topic+getalgprecomp">getalgprecomp</a></code>
</p>


<h3>Slots</h3>


<dl>
<dt><code>internal</code>:</dt><dd><p>internal state of the object. Do not access. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+sampalg-class">sampalg</a>"</code>, directly.
</p>


<h3>Author(s)</h3>

<p> Axel Gandy </p>


<h3>References</h3>

<p>Gandy, A. (2009) Sequential Implementation of Monte Carlo Tests 
with Uniformly Bounded Resampling Risk. JASA 104(488):1504-1511.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("sampalgPrecomp")
</code></pre>

<hr>
<h2 id='sampalgres-class'>Class &quot;sampalgres&quot;</h2><span id='topic+sampalgres-class'></span><span id='topic+contalg+2Csampalgres-method'></span><span id='topic+show+2Csampalgres-method'></span>

<h3>Description</h3>

<p>Results returned by <code>run</code> - Internal.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("sampalgres", ...)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>p.value</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>steps</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>pos</code>:</dt><dd><p>Object of class <code>"numeric"</code>  </p>
</dd>
<dt><code>alg</code>:</dt><dd><p>Object of class <code>"sampalg"</code>  </p>
</dd>
<dt><code>gen</code>:</dt><dd><p>Object of class <code>"function"</code>  </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>confint</dt><dd><p><code>signature(object = "sampalgres", parm = "missing")</code>: ... </p>
</dd>
<dt>contalg</dt><dd><p><code>signature(data = "sampalgres")</code>: ... </p>
</dd>
<dt>getbounds</dt><dd><p><code>signature(data = "sampalgres")</code>: ... </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "sampalgres")</code>: ... </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Axel Gandy </p>


<h3>References</h3>

<p>Gandy, A. (2009) Sequential Implementation of Monte Carlo Tests 
with Uniformly Bounded Resampling Risk. JASA 104(488):1504-1511.</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("sampalgres")
</code></pre>

<hr>
<h2 id='simctest'>Sequential implementation of Monte Carlo
tests</h2><span id='topic+simctest'></span>

<h3>Description</h3>

<p>Wrapper function for convenient use of the sequential implementation
of the Monte Carlo test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simctest(gensample, level=0.05, epsilon=1e-3, maxsteps=1e4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simctest_+3A_gensample">gensample</code></td>
<td>
<p>function that performs one sampling step. 
Returns 0 (sampled test statistic does not exceed the observation)
or 1 (sampled test static exceeds the observation).
</p>
</td></tr>
<tr><td><code id="simctest_+3A_level">level</code></td>
<td>
<p>level passed to <code><a href="#topic+getalgonthefly">getalgonthefly</a></code></p>
</td></tr>
<tr><td><code id="simctest_+3A_epsilon">epsilon</code></td>
<td>
<p>error bound epsilon passed to <code><a href="#topic+getalgonthefly">getalgonthefly</a></code></p>
</td></tr>
<tr><td><code id="simctest_+3A_maxsteps">maxsteps</code></td>
<td>
<p>maximal number of steps to take</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+sampalgres-class">sampalgres</a></code>.
</p>


<h3>Author(s)</h3>

<p>Axel Gandy</p>


<h3>References</h3>

<p>Gandy, A. (2009) Sequential Implementation of Monte Carlo Tests 
with Uniformly Bounded Resampling Risk. JASA 104(488):1504-1511.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  #Example used in the above paper
  dat &lt;- matrix(nrow=5,ncol=7,byrow=TRUE,
                c(1,2,2,1,1,0,1, 2,0,0,2,3,0,0, 0,1,1,1,2,7,3, 1,1,2,0,0,0,1, 0,1,1,1,1,0,0))
  loglikrat &lt;- function(data){
    cs &lt;- colSums(data)
    rs &lt;- rowSums(data)
    mu &lt;- outer(rs,cs)/sum(rs)
    2*sum(ifelse(data&lt;=0.5, 0,data*log(data/mu)))
  }
  resample &lt;- function(data){
    cs &lt;- colSums(data)
    rs &lt;- rowSums(data)
    n &lt;- sum(rs)
    mu &lt;- outer(rs,cs)/n/n
    matrix(rmultinom(1,n,c(mu)),nrow=dim(data)[1],ncol=dim(data)[2])
  }
  t &lt;- loglikrat(dat);

  # function to generate samples
  gen &lt;- function(){loglikrat(resample(dat))&gt;=t}

  #using simctest
  simctest(gen,maxsteps=10000)

  #now trying simctest.cont
  res &lt;- simctest(gen,maxsteps=500)
  res

  cont(res,20000)

</code></pre>

<hr>
<h2 id='summary.mmctestres-methods'>Methods for class &lsquo;mmctestres&rsquo; and &lsquo;mmctest&rsquo;, Package &lsquo;simctest&rsquo;</h2><span id='topic+summary.mmctestres'></span><span id='topic+summary.mmctestres-methods'></span><span id='topic+summary.mmctestres+2Cmmctestres-method'></span><span id='topic+summary.mmctestres+2Cmmctest-method'></span>

<h3>Description</h3>

<p>Function which shows current estimates of p-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'mmctestres'
summary(object,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.mmctestres-methods_+3A_object">object</code></td>
<td>
<p>object of type &lsquo;mmctestres&rsquo; or &lsquo;mmctest&rsquo;.
</p>
</td></tr>
<tr><td><code id="summary.mmctestres-methods_+3A_...">...</code></td>
<td>
<p>No further arguments needed. Listed only for compatibility with generic &lsquo;summary&rsquo; method.</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>summary.mmctestres(object)</dt><dd><p> works with object of type mmctestres or mmctest. </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>  fun &lt;- function(ind,n,data) sapply(1:length(ind), function(i) sum(runif(n[i])&lt;=data[ind[i]]));
  i &lt;- mmctSampler(fun,num=500,data=runif(500));
  a &lt;- mmctest(h=hBH);
  a &lt;- run(a, i, maxsteps=list(maxnum=1000000,undecided=10));
  summary.mmctestres(a);
</code></pre>

<hr>
<h2 id='testResult-methods'>Methods for class &lsquo;mmctestres&rsquo; and &lsquo;mmctest&rsquo;, Package &lsquo;simctest&rsquo;</h2><span id='topic+testResult'></span><span id='topic+testResult-methods'></span><span id='topic+testResult+2Cmmctestres-method'></span><span id='topic+testResult+2Cmmctest-method'></span>

<h3>Description</h3>

<p>Function which returns a list containing indices of rejected hypotheses (vector &lsquo;rejected&rsquo;),
nonrejected hypotheses (vector &lsquo;nonrejected&rsquo;) and undecided hypotheses (vector &lsquo;undecided&rsquo;)
</p>


<h3>Usage</h3>

<pre><code class='language-R'> testResult(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testResult-methods_+3A_obj">obj</code></td>
<td>
<p>object of type &lsquo;mmctestres&rsquo; or &lsquo;mmctest&rsquo;.
</p>
</td></tr>
</table>


<h3>Methods</h3>


<dl>
<dt>testResult(obj)</dt><dd><p> works with object of type mmctestres or mmctest. </p>
</dd>   
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>  fun &lt;- function(ind,n,data) sapply(1:length(ind), function(i) sum(runif(n[i])&lt;=data[ind[i]]));
  i &lt;- mmctSampler(fun,num=500,data=runif(500));
  a &lt;- mmctest(h=hBH);
  a &lt;- run(a, i, maxsteps=list(maxnum=1000000,undecided=10));
  res &lt;- testResult(a);
  rejected &lt;- res$rejected;
  nonrejected &lt;- res$nonrejected;
  undecided &lt;- res$undecided;
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
