<!DOCTYPE html><html lang="en"><head><title>Help for package xegaDerivationTrees</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {xegaDerivationTrees}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#booleanGrammar'><p>A constant function which returns the BNF (Backus-Naur Form)</p>
of a context-free grammar for the XOR problem.</a></li>
<li><a href='#chooseNode'><p>Selects an attributed node in an attributed node list randomly.</p></a></li>
<li><a href='#chooseRule'><p>Selects a production rule index at random from a vector of production rules.</p></a></li>
<li><a href='#chooseRulek'><p>Selects k-th production rule index from a vector of production rules.</p></a></li>
<li><a href='#compatibleSubtrees'><p>Test the compatibility of subtrees.</p></a></li>
<li><a href='#compileBNF'><p>Compile a  BNF (Backus-Naur Form) of a context-free grammar.</p></a></li>
<li><a href='#decodeCDT'><p>Converts a complete derivation tree into a program.</p></a></li>
<li><a href='#decodeDT'><p>Decodes a derivation tree into a program.</p></a></li>
<li><a href='#decodeDTsym'><p>Decodes a derivation tree into a list of the leaf symbols</p>
of the derivation tree.</a></li>
<li><a href='#decodeTree'><p>Returns a list of all symbols of a derivation tree</p>
in depth-first left-to-right order.</a></li>
<li><a href='#filterANL'><p>Filter an Attributed Node List (ANL) of a derivation tree by depth.</p></a></li>
<li><a href='#filterANLid'><p>Filter an Attributed Node List (ANL) of a derivation tree by a symbol identifier.</p></a></li>
<li><a href='#generateDerivationTree'><p>Generates a derivation tree from an integer vector.</p></a></li>
<li><a href='#leavesIncompleteDT'><p>Returns the list of symbol identifiers</p>
of the leaves of a derivation tree.</a></li>
<li><a href='#randomDerivationTree'><p>Generates a random derivation tree.</p></a></li>
<li><a href='#rndPartition'><p>Randomly partitions n in k parts.</p></a></li>
<li><a href='#rndsub'><p>Transforms a non-terminal symbol into a random 1-level derivation tree.</p></a></li>
<li><a href='#rndsubk'><p>Transforms a non-terminal symbol into a 1-level derivation tree</p>
for a given k.</a></li>
<li><a href='#substituteSymbol'><p>Codes the substitution of a non-terminal symbol by the symbols</p>
derived by a production rule as a nested list.</a></li>
<li><a href='#testGenerateDerivationTree'><p>Generate, decode, and show <code>times</code> derivation trees from random</p>
integer vectors for grammar BNF on the console.</a></li>
<li><a href='#treeANL'><p>Builds an Attributed Node List (ANL) of a derivation tree.</p></a></li>
<li><a href='#treeChildren'><p>Returns the children of a derivation tree.</p></a></li>
<li><a href='#treeExtract'><p>Extracts the subtree at position <code>pos</code> in a derivation tree.</p></a></li>
<li><a href='#treeInsert'><p>Inserts a subtree into a derivation tree at a <code>node</code>.</p></a></li>
<li><a href='#treeLeaves'><p>Measures the number of leaves of a complete derivation tree.</p></a></li>
<li><a href='#treeListDepth'><p>Measures the depth of a (nested) list.</p></a></li>
<li><a href='#treeNodes'><p>Measures the number of inner nodes in a derivation tree.</p></a></li>
<li><a href='#treeRoot'><p>Returns the root of a derivation tree.</p></a></li>
<li><a href='#treeSize'><p>Measures the number of symbols in a derivation tree.</p></a></li>
<li><a href='#xegaDerivationTrees'><p>Package xegaDerivationTrees</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Generating and Manipulating Derivation Trees</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Derivation tree operations are needed for implementing 
            grammar-based genetic programming and grammatical evolution:  
            Generating of a random derivation trees of a context-free grammar 
            of bounded depth, decoding a derivation tree, 
            choosing a random node in a derivation tree, 
            extracting a tree whose root is a specified node, and 
            inserting a subtree into a derivation tree at a specified node.
            These operations are necessary for the initializiation and 
            for decoders of a random population of programs, 
            as well as for implementing crossover and mutation operators.
            Depth-bounds are guaranteed by switching to a grammar 
            without recursive production rules. 
            For executing the examples, the package 'BNF' is needed.
            The basic tree operations of generating, extracting, and 
            inserting of derivation trees as well as the conditions 
            for guaranteeing complete derivation trees have been 
            presented in Geyer-Schulz (1997, ISBN:978-3-7908-0830-X).
            The use of random integer vectors for the generation 
            of derivation trees has been introduced in 
            Ryan, C., Collins, J. J., and  O'Neill, M. (1998)
            &lt;<a href="https://doi.org/10.1007%2FBFb0055930">doi:10.1007/BFb0055930</a>&gt;. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td>&lt;<a href="https://github.com/ageyerschulz/xegaDerivationTrees&amp;gt;">https://github.com/ageyerschulz/xegaDerivationTrees&gt;</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>xegaBNF</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-12 19:23:17 UTC; dj2333</td>
</tr>
<tr>
<td>Author:</td>
<td>Andreas Geyer-Schulz
    <a href="https://orcid.org/0009-0000-5237-3579"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andreas Geyer-Schulz &lt;Andreas.Geyer-Schulz@kit.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-13 16:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='booleanGrammar'>A constant function which returns the BNF (Backus-Naur Form) 
of a context-free grammar for the XOR problem.</h2><span id='topic+booleanGrammar'></span>

<h3>Description</h3>

<p>A constant function which returns the BNF (Backus-Naur Form) 
of a context-free grammar for the XOR problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>booleanGrammar()
</code></pre>


<h3>Details</h3>

<p>Imported from package xegaBNF for use in examples.
</p>


<h3>Value</h3>

<p>A named list with elements <code>$filename</code> and  <code>$BNF</code> 
representing the grammar of a boolean grammar with two variables and
the boolean functions <code>AND</code>, <code>OR</code>, and <code>NOT</code>.
</p>


<h3>See Also</h3>

<p>Other Grammar: 
<code><a href="#topic+compileBNF">compileBNF</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>booleanGrammar()
</code></pre>

<hr>
<h2 id='chooseNode'>Selects an attributed node in an attributed node list randomly.</h2><span id='topic+chooseNode'></span>

<h3>Description</h3>

<p><code>chooseNode()</code> returns  a random attributed node 
from an attributed node list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chooseNode(ANL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chooseNode_+3A_anl">ANL</code></td>
<td>
<p>Attributed node list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An attributed <code>node</code> has the following elements:
</p>

<ul>
<li> <p><code>ID</code>
</p>
</li>
<li> <p><code>NonTerminal</code>
</p>
</li>
<li> <p><code>Pos</code>
</p>
</li>
<li> <p><code>Depth</code>
</p>
</li>
<li> <p><code>Rdepth</code>
</p>
</li>
<li> <p><code>subtreedepth</code>
</p>
</li>
<li> <p><code>node$Index</code>
</p>
</li></ul>

<p>These elements can be used e.g. 
</p>

<ul>
<li><p> for inserting and extracting subtrees 
(<code>Pos</code> or  <code>node$Index</code>), 
</p>
</li>
<li><p> for checking
the feasibility of subtree substitution (<code>ID</code>),
</p>
</li>
<li><p> for checking depth bounds 
(<code>Depth</code>, <code>RDepth</code>, and <code>subtreedepth</code>),
...
</p>
</li></ul>



<h3>Value</h3>

<p>Attributed node.
</p>


<h3>See Also</h3>

<p>Other Random Choice: 
<code><a href="#topic+chooseRule">chooseRule</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g&lt;-compileBNF(booleanGrammar())
a&lt;-randomDerivationTree(g$Start, g)
b&lt;-treeANL(a, g$ST)
c&lt;-chooseNode(b$ANL)

</code></pre>

<hr>
<h2 id='chooseRule'>Selects a production rule index at random from a vector of production rules.</h2><span id='topic+chooseRule'></span>

<h3>Description</h3>

<p><code>chooseRule()</code> selects a production rule index 
from the vector of production rule indices 
in the <code>g$PT$LHS$</code> for a non-terminal symbol.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chooseRule(riv)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chooseRule_+3A_riv">riv</code></td>
<td>
<p>Vector of production rules indices for 
a non-terminal symbol.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer. Index of the production rule.
</p>


<h3>See Also</h3>

<p>Other Random Choice: 
<code><a href="#topic+chooseNode">chooseNode</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chooseRule(c(7, 8, 9))
chooseRule(as.vector(1))
</code></pre>

<hr>
<h2 id='chooseRulek'>Selects k-th production rule index from a vector of production rules.</h2><span id='topic+chooseRulek'></span>

<h3>Description</h3>

<p><code>chooseRulek()</code> selects the k-th production rule index 
from the vector of production rule indices 
in the <code>g$PT$LHS$</code> for a non-terminal symbol.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chooseRulek(riv, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chooseRulek_+3A_riv">riv</code></td>
<td>
<p>Vector of production rules indices for 
a non-terminal symbol.</p>
</td></tr>
<tr><td><code id="chooseRulek_+3A_k">k</code></td>
<td>
<p>Integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The index of the production rule.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chooseRulek(c(7, 8, 9), 9)
chooseRulek(as.vector(1), 9)
</code></pre>

<hr>
<h2 id='compatibleSubtrees'>Test the compatibility of subtrees.</h2><span id='topic+compatibleSubtrees'></span>

<h3>Description</h3>

<p><code>compatibleSubtrees()</code> tests the compatibility of two 
subtrees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compatibleSubtrees(n1, n2, maxdepth = 5, DepthBounded = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compatibleSubtrees_+3A_n1">n1</code></td>
<td>
<p>Attributed node of the root of subtree 1.</p>
</td></tr>
<tr><td><code id="compatibleSubtrees_+3A_n2">n2</code></td>
<td>
<p>Attributed node of the root of subtree 2.</p>
</td></tr>
<tr><td><code id="compatibleSubtrees_+3A_maxdepth">maxdepth</code></td>
<td>
<p>Integer. Maximal derivation depth.</p>
</td></tr>
<tr><td><code id="compatibleSubtrees_+3A_depthbounded">DepthBounded</code></td>
<td>

<ul>
<li> <p><code>TRUE</code>: Only subtrees 
with the same root symbol and which respect 
the depth restrictions are compatible. 
</p>
</li>
<li> <p><code>FALSE</code>: The depth restrictions are not 
checked.</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p><code>compatibleSubtrees()</code> tests the compatibility of two 
subtrees:
</p>

<ol>
<li><p> The root symbol of the two subtrees must be identical:
<code>(n1$ID==n2$ID)</code>.
</p>
</li>
<li><p> The depth restrictions must hold:
</p>

<ol>
<li> <p><code>depth(n1) + depth(subtree2) &lt;= maxdepth+maxSPT</code>
</p>
</li>
<li> <p><code>depth(n2) + depth(subtree1) &lt;= maxdepth+maxSPT</code> 
</p>
</li></ol>
 
<p>maxSPT is the maximal number of derivations needed 
to generate a complete derivation tree.</p>
</li></ol>



<h3>Value</h3>

<p><code>TRUE</code> or <code>FALSE</code>
</p>


<h3>See Also</h3>

<p>Other Tree Operations: 
<code><a href="#topic+treeExtract">treeExtract</a>()</code>,
<code><a href="#topic+treeInsert">treeInsert</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g&lt;-compileBNF(booleanGrammar())
t1&lt;-randomDerivationTree(g$Start, g)
t1anl&lt;-treeANL(t1, g$ST)
t2&lt;-randomDerivationTree(g$Start, g)
t2anl&lt;-treeANL(t2, g$ST)
n1&lt;-chooseNode(t1anl$ANL)
n2&lt;-chooseNode(t2anl$ANL)
compatibleSubtrees(n1, n2)
compatibleSubtrees(n1, n2, maxdepth=1)
compatibleSubtrees(n1, n2, DepthBounded=FALSE)

</code></pre>

<hr>
<h2 id='compileBNF'>Compile a  BNF (Backus-Naur Form) of a context-free grammar.</h2><span id='topic+compileBNF'></span>

<h3>Description</h3>

<p><code>compileBNF()</code> produces a context-free grammar  
from its specification in Backus-Naur form (BNF).   
Warning: No error checking is implemented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compileBNF(g, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compileBNF_+3A_g">g</code></td>
<td>
<p>A character string with a BNF.</p>
</td></tr>
<tr><td><code id="compileBNF_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. TRUE: Show progress. Default: FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A grammar consists of the symbol table <code>ST</code>, the production
table <code>PT</code>, the start symbol <code>Start</code>, 
and the short production
table <code>SPT</code>. 
</p>
<p>The function performs the following steps:
</p>

<ol>
<li><p> Make the symbol table. 
</p>
</li>
<li><p> Make the production table. 
</p>
</li>
<li><p> Extract the start symbol. 
</p>
</li>
<li><p> Compile a short production table.
</p>
</li>
<li><p> Return the grammar.</p>
</li></ol>



<h3>Value</h3>

<p>A grammar object (list) with the attributes 
</p>

<ul>
<li> <p><code>name</code>: Filename of the grammar.
</p>
</li>
<li> <p><code>ST</code>: Symbol table. 
</p>
</li>
<li> <p><code>PT</code>: Production table. 
</p>
</li>
<li> <p><code>Start</code>: Start symbol of the grammar.
</p>
</li>
<li> <p><code>SPT</code>: Short production table.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other Grammar: 
<code><a href="#topic+booleanGrammar">booleanGrammar</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g&lt;-compileBNF(booleanGrammar())
g$ST
g$PT
g$Start
g$SPT
</code></pre>

<hr>
<h2 id='decodeCDT'>Converts a complete derivation tree into a program.</h2><span id='topic+decodeCDT'></span>

<h3>Description</h3>

<p><code>decodeCDT()</code> returns a program
(a text string with the terminal symbol string).
If the derivation tree still has non-terminal leaves,
the non-terminal leaves are omitted.
The program produces a syntax error.
The program can not be repaired.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decodeCDT(tree, ST)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="decodeCDT_+3A_tree">tree</code></td>
<td>
<p>Derivation tree.</p>
</td></tr>
<tr><td><code id="decodeCDT_+3A_st">ST</code></td>
<td>
<p>Symbol table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Program.
</p>


<h3>See Also</h3>

<p>Other Decoder: 
<code><a href="#topic+decodeDTsym">decodeDTsym</a>()</code>,
<code><a href="#topic+decodeDT">decodeDT</a>()</code>,
<code><a href="#topic+decodeTree">decodeTree</a>()</code>,
<code><a href="#topic+leavesIncompleteDT">leavesIncompleteDT</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g&lt;-compileBNF(booleanGrammar())
a&lt;-randomDerivationTree(g$Start, g)
decodeCDT(a, g$ST) 

</code></pre>

<hr>
<h2 id='decodeDT'>Decodes a derivation tree into a program.</h2><span id='topic+decodeDT'></span>

<h3>Description</h3>

<p>The program may contain non-terminal symbols
and its evaluation may fail.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decodeDT(tree, ST)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="decodeDT_+3A_tree">tree</code></td>
<td>
<p>Derivation tree.</p>
</td></tr>
<tr><td><code id="decodeDT_+3A_st">ST</code></td>
<td>
<p>Symbol table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Program
</p>


<h3>See Also</h3>

<p>Other Decoder: 
<code><a href="#topic+decodeCDT">decodeCDT</a>()</code>,
<code><a href="#topic+decodeDTsym">decodeDTsym</a>()</code>,
<code><a href="#topic+decodeTree">decodeTree</a>()</code>,
<code><a href="#topic+leavesIncompleteDT">leavesIncompleteDT</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g&lt;-compileBNF(booleanGrammar())
t1&lt;-generateDerivationTree(sym=g$Start,sample(100, 10, replace=TRUE), G=g)
decodeDT(t1$tree, g$ST) 

</code></pre>

<hr>
<h2 id='decodeDTsym'>Decodes a derivation tree into a list of the leaf symbols
of the derivation tree.</h2><span id='topic+decodeDTsym'></span>

<h3>Description</h3>

<p>Decodes a derivation tree into a list of the leaf symbols
of the derivation tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decodeDTsym(tree, ST)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="decodeDTsym_+3A_tree">tree</code></td>
<td>
<p>Derivation tree.</p>
</td></tr>
<tr><td><code id="decodeDTsym_+3A_st">ST</code></td>
<td>
<p>Symbol table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of the leaf symbols of the derivation tree.
</p>


<h3>See Also</h3>

<p>Other Decoder: 
<code><a href="#topic+decodeCDT">decodeCDT</a>()</code>,
<code><a href="#topic+decodeDT">decodeDT</a>()</code>,
<code><a href="#topic+decodeTree">decodeTree</a>()</code>,
<code><a href="#topic+leavesIncompleteDT">leavesIncompleteDT</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g&lt;-compileBNF(booleanGrammar())
t1&lt;-generateDerivationTree(sym=g$Start,sample(100, 10, replace=TRUE), G=g)
decodeDTsym(t1$tree, g$ST) 

</code></pre>

<hr>
<h2 id='decodeTree'>Returns a list of all symbols of a derivation tree  
in depth-first left-to-right order.</h2><span id='topic+decodeTree'></span>

<h3>Description</h3>

<p><code>decodeTree()</code> returns a
list of all symbols of a derivation tree 
in depth-first left-to-right order
(coded as R Factor with the symbol identifiers as levels).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decodeTree(tree, ST)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="decodeTree_+3A_tree">tree</code></td>
<td>
<p>Derivation tree.</p>
</td></tr>
<tr><td><code id="decodeTree_+3A_st">ST</code></td>
<td>
<p>Symbol table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of all symbols in depth-first left-to-right order.
</p>


<h3>See Also</h3>

<p>Other Decoder: 
<code><a href="#topic+decodeCDT">decodeCDT</a>()</code>,
<code><a href="#topic+decodeDTsym">decodeDTsym</a>()</code>,
<code><a href="#topic+decodeDT">decodeDT</a>()</code>,
<code><a href="#topic+leavesIncompleteDT">leavesIncompleteDT</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g&lt;-compileBNF(booleanGrammar())
a&lt;-randomDerivationTree(g$Start, g)
decodeTree(a, g$ST) 

</code></pre>

<hr>
<h2 id='filterANL'>Filter an Attributed Node List (ANL) of a derivation tree by depth.</h2><span id='topic+filterANL'></span>

<h3>Description</h3>

<p><code>filterANL()</code> deletes all nodes whose depth 
<code>node$Depth</code>  is 
less than <code>minb</code> and larger than <code>maxb</code>
from the ANL. 
However, if the resulting list is empty, the original
ANL is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filterANL(ANL, minb = 1, maxb = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filterANL_+3A_anl">ANL</code></td>
<td>
<p>Attributed node list.</p>
</td></tr>
<tr><td><code id="filterANL_+3A_minb">minb</code></td>
<td>
<p>Integer.</p>
</td></tr>
<tr><td><code id="filterANL_+3A_maxb">maxb</code></td>
<td>
<p>Integer.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An attributed <code>node</code> has the following elements:
</p>

<ul>
<li> <p><code>$ID</code>:  Id in the symbol table <code>ST</code>.
</p>
</li>
<li> <p><code>$NT</code>:  Is the symbol a non-terminal?
</p>
</li>
<li> <p><code>$Pos</code>: Position in the trail.
</p>
</li>
<li> <p><code>$Depth</code>:  Depth of node.
</p>
</li>
<li> <p><code>$RDepth</code>: Residual depth for expansion.
</p>
</li>
<li> <p><code>$subtreedepth</code>: Depth of subtree starting here.
</p>
</li>
<li> <p><code>$Index</code>:  R index of the node in the derivation tree.
Allows fast tree extraction and insertion.
</p>
</li></ul>



<h3>Value</h3>

<p>An attributed node list with nodes whose depths are in 
<code>minb:maxb</code>. 
Each node is represented as a list of the following attributes:
</p>

<ul>
<li> <p><code>Node$ID</code>:  Id in the symbol table ST.
</p>
</li>
<li> <p><code>Node$NT</code>:  Is the symbol a non-terminal?
</p>
</li>
<li> <p><code>Node$Pos</code>: Position in the trail.
</p>
</li>
<li> <p><code>Node$Depth</code>:  Depth of node.
</p>
</li>
<li> <p><code>Node$RDepth</code>: Residual depth for expansion.
</p>
</li>
<li> <p><code>Node$subtreedepth</code>: Depth of subtree starting here.
</p>
</li>
<li> <p><code>Node$Index</code>:  R index of the node in the derivation tree.
Allows fast tree extraction and insertion.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other Access Tree Parts: 
<code><a href="#topic+filterANLid">filterANLid</a>()</code>,
<code><a href="#topic+treeANL">treeANL</a>()</code>,
<code><a href="#topic+treeChildren">treeChildren</a>()</code>,
<code><a href="#topic+treeRoot">treeRoot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g&lt;-compileBNF(booleanGrammar())
set.seed(111)
a&lt;-randomDerivationTree(g$Start, g, maxdepth=10)
b&lt;-treeANL(a, g$ST)
c&lt;-filterANL(b, minb=1, maxb=3)
d&lt;-filterANL(b, minb=3, maxb=5)
e&lt;-filterANL(b, minb=14, maxb=15)
f&lt;-filterANL(b, minb=13, maxb=15)

</code></pre>

<hr>
<h2 id='filterANLid'>Filter an Attributed Node List (ANL) of a derivation tree by a symbol identifier.</h2><span id='topic+filterANLid'></span>

<h3>Description</h3>

<p><code>filterANLid()</code> deletes all nodes whose <code>node$ID</code> does not match 
<code>node$ID</code>.
If the resulting list is empty, a list of length 0 is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filterANLid(ANL, nodeID = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filterANLid_+3A_anl">ANL</code></td>
<td>
<p>Attributed node list.</p>
</td></tr>
<tr><td><code id="filterANLid_+3A_nodeid">nodeID</code></td>
<td>
<p>Integer. The identifier of a symbol.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An attributed <code>node</code> has the following elements:
</p>

<ul>
<li> <p><code>$ID</code>:  Id in the symbol table <code>ST</code>.
</p>
</li>
<li> <p><code>$NT</code>:  Is the symbol a non-terminal?
</p>
</li>
<li> <p><code>$Pos</code>: Position in the trail.
</p>
</li>
<li> <p><code>$Depth</code>:  Depth of node.
</p>
</li>
<li> <p><code>$RDepth</code>: Residual depth for expansion.
</p>
</li>
<li> <p><code>$subtreedepth</code>: Depth of subtree starting here.
</p>
</li>
<li> <p><code>$Index</code>:  R index of the node in the derivation tree.
Allows fast tree extraction and insertion.
</p>
</li></ul>

<p>For the implementation of crossover and mutation, we expect a non-terminal symbol identifier.
</p>


<h3>Value</h3>

<p>An attributed node list with nodes whose depths are in 
<code>minb:maxb</code>. 
Each node is represented as a list of the following attributes:
</p>

<ul>
<li> <p><code>Node$ID</code>:  Id in the symbol table ST.
</p>
</li>
<li> <p><code>Node$NT</code>:  Is the symbol a non-terminal?
</p>
</li>
<li> <p><code>Node$Pos</code>: Position in the trail.
</p>
</li>
<li> <p><code>Node$Depth</code>:  Depth of node.
</p>
</li>
<li> <p><code>Node$RDepth</code>: Residual depth for expansion.
</p>
</li>
<li> <p><code>Node$subtreedepth</code>: Depth of subtree starting here.
</p>
</li>
<li> <p><code>Node$Index</code>:  R index of the node in the derivation tree.
Allows fast tree extraction and insertion.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other Access Tree Parts: 
<code><a href="#topic+filterANL">filterANL</a>()</code>,
<code><a href="#topic+treeANL">treeANL</a>()</code>,
<code><a href="#topic+treeChildren">treeChildren</a>()</code>,
<code><a href="#topic+treeRoot">treeRoot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g&lt;-compileBNF(booleanGrammar())
set.seed(111)
a&lt;-randomDerivationTree(g$Start, g, maxdepth=10)
b&lt;-treeANL(a, g$ST)
c&lt;-filterANLid(b, nodeID=5)
d&lt;-filterANLid(b, nodeID=6)
e&lt;-filterANLid(b, nodeID=7)
f&lt;-filterANLid(b, nodeID=8)

</code></pre>

<hr>
<h2 id='generateDerivationTree'>Generates a derivation tree from an integer vector.</h2><span id='topic+generateDerivationTree'></span>

<h3>Description</h3>

<p><code>generateDerivationTree()</code> 
generates a derivation tree from an integer vector.
The derivation tree may be incomplete.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateDerivationTree(sym, kvec, complete = TRUE, G, maxdepth = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generateDerivationTree_+3A_sym">sym</code></td>
<td>
<p>Non-terminal symbol.</p>
</td></tr>
<tr><td><code id="generateDerivationTree_+3A_kvec">kvec</code></td>
<td>
<p>Integer vector.</p>
</td></tr>
<tr><td><code id="generateDerivationTree_+3A_complete">complete</code></td>
<td>
<p>Boolean. FALSE for incomplete derivation trees.</p>
</td></tr>
<tr><td><code id="generateDerivationTree_+3A_g">G</code></td>
<td>
<p>Grammar.</p>
</td></tr>
<tr><td><code id="generateDerivationTree_+3A_maxdepth">maxdepth</code></td>
<td>
<p>Integer. Maximal depth of the derivation tree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>generateDerivationTree()</code> recursively expands 
non-terminals and builds a derivation tree.
</p>


<h3>Value</h3>

<p>A named list l$tree, l$kvec, l$complete.
</p>


<h3>See Also</h3>

<p>Other Generate Derivation Tree: 
<code><a href="#topic+randomDerivationTree">randomDerivationTree</a>()</code>,
<code><a href="#topic+rndsubk">rndsubk</a>()</code>,
<code><a href="#topic+rndsub">rndsub</a>()</code>,
<code><a href="#topic+substituteSymbol">substituteSymbol</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g&lt;-compileBNF(booleanGrammar())
a&lt;-sample(100, 100, replace=TRUE)
b&lt;-generateDerivationTree(sym=g$Start, kvec=a, G=g, maxdepth=10)
decodeDT(b$tree, g$ST)

</code></pre>

<hr>
<h2 id='leavesIncompleteDT'>Returns the list of symbol identifiers
of the leaves of a derivation tree.</h2><span id='topic+leavesIncompleteDT'></span>

<h3>Description</h3>

<p>For incomplete derivation trees, non-terminal symbols
are leaves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leavesIncompleteDT(tree, ST, leavesList = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="leavesIncompleteDT_+3A_tree">tree</code></td>
<td>
<p>Derivation tree.</p>
</td></tr>
<tr><td><code id="leavesIncompleteDT_+3A_st">ST</code></td>
<td>
<p>Symbol table.</p>
</td></tr>
<tr><td><code id="leavesIncompleteDT_+3A_leaveslist">leavesList</code></td>
<td>
<p>List of symbol identifiers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Must perform a depth-first left-to-right tree traversal to collect 
all leave symbols (terminal and non-terminal symbols).
</p>


<h3>Value</h3>

<p>List of symbol identifiers.
</p>


<h3>See Also</h3>

<p>Other Decoder: 
<code><a href="#topic+decodeCDT">decodeCDT</a>()</code>,
<code><a href="#topic+decodeDTsym">decodeDTsym</a>()</code>,
<code><a href="#topic+decodeDT">decodeDT</a>()</code>,
<code><a href="#topic+decodeTree">decodeTree</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g&lt;-compileBNF(booleanGrammar())
a&lt;-randomDerivationTree(g$Start, g)
leavesIncompleteDT(a, g$ST) 

</code></pre>

<hr>
<h2 id='randomDerivationTree'>Generates a random derivation tree.</h2><span id='topic+randomDerivationTree'></span>

<h3>Description</h3>

<p><code>randomDerivationTree()</code> 
generates a random derivation tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomDerivationTree(sym, G, maxdepth = 5, CompleteDT = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="randomDerivationTree_+3A_sym">sym</code></td>
<td>
<p>Non-terminal symbol.</p>
</td></tr>
<tr><td><code id="randomDerivationTree_+3A_g">G</code></td>
<td>
<p>Grammar.</p>
</td></tr>
<tr><td><code id="randomDerivationTree_+3A_maxdepth">maxdepth</code></td>
<td>
<p>Integer. Maximal depth of the derivation tree.</p>
</td></tr>
<tr><td><code id="randomDerivationTree_+3A_completedt">CompleteDT</code></td>
<td>
<p>Boolean. Generate a complete derivation tree? 
Default: TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>RandomDerivationTree()</code> recursively expands 
non-terminals and builds a depth-bounded derivation tree.
</p>


<h3>Value</h3>

<p>Derivation tree (a nested list).
</p>


<h3>See Also</h3>

<p>Other Generate Derivation Tree: 
<code><a href="#topic+generateDerivationTree">generateDerivationTree</a>()</code>,
<code><a href="#topic+rndsubk">rndsubk</a>()</code>,
<code><a href="#topic+rndsub">rndsub</a>()</code>,
<code><a href="#topic+substituteSymbol">substituteSymbol</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g&lt;-compileBNF(booleanGrammar())
a&lt;-randomDerivationTree(g$Start, g)
b&lt;-randomDerivationTree(g$Start, g, maxdepth=10)
c&lt;-randomDerivationTree(g$Start, g, 2, FALSE)

</code></pre>

<hr>
<h2 id='rndPartition'>Randomly partitions n in k parts.</h2><span id='topic+rndPartition'></span>

<h3>Description</h3>

<p>Sampling a partition is a two-step process:
</p>

<ol>
<li><p> The k parts of the partion are sampled in the loop.
This implies that the first partition p is a random number 
between 1 and 1+n-k. The next partition is sampled from 
1 to 1+n-k-p. 
</p>
</li>
<li><p> We permute the partitions.      
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>rndPartition(n, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rndPartition_+3A_n">n</code></td>
<td>
<p>The integer to divide.</p>
</td></tr>
<tr><td><code id="rndPartition_+3A_k">k</code></td>
<td>
<p>Number of parts.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The integer partition of n in k parts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> rndPartition(10, 4)
</code></pre>

<hr>
<h2 id='rndsub'>Transforms a non-terminal symbol into a random 1-level derivation tree.</h2><span id='topic+rndsub'></span>

<h3>Description</h3>

<p><code>rndsub()</code> expands a non-terminal by a random derivation
and returns a 1-level derivation tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rndsub(sym, PT)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rndsub_+3A_sym">sym</code></td>
<td>
<p>Non-terminal symbol.</p>
</td></tr>
<tr><td><code id="rndsub_+3A_pt">PT</code></td>
<td>
<p>Production table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Derivation tree with 1-level.
</p>


<h3>See Also</h3>

<p>Other Generate Derivation Tree: 
<code><a href="#topic+generateDerivationTree">generateDerivationTree</a>()</code>,
<code><a href="#topic+randomDerivationTree">randomDerivationTree</a>()</code>,
<code><a href="#topic+rndsubk">rndsubk</a>()</code>,
<code><a href="#topic+substituteSymbol">substituteSymbol</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g&lt;-compileBNF(booleanGrammar())
rndsub(g$Start, g$PT)

</code></pre>

<hr>
<h2 id='rndsubk'>Transforms a non-terminal symbol into a 1-level derivation tree 
for a given k.</h2><span id='topic+rndsubk'></span>

<h3>Description</h3>

<p><code>rndsubk()</code> expands a non-terminal by a derivation
specified by k and returns a 1-level derivation tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rndsubk(sym, k, PT)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rndsubk_+3A_sym">sym</code></td>
<td>
<p>Non-terminal symbol.</p>
</td></tr>
<tr><td><code id="rndsubk_+3A_k">k</code></td>
<td>
<p>Codon (An integer).</p>
</td></tr>
<tr><td><code id="rndsubk_+3A_pt">PT</code></td>
<td>
<p>Production table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>1-level derivation tree.
</p>


<h3>See Also</h3>

<p>Other Generate Derivation Tree: 
<code><a href="#topic+generateDerivationTree">generateDerivationTree</a>()</code>,
<code><a href="#topic+randomDerivationTree">randomDerivationTree</a>()</code>,
<code><a href="#topic+rndsub">rndsub</a>()</code>,
<code><a href="#topic+substituteSymbol">substituteSymbol</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g&lt;-compileBNF(booleanGrammar())
rndsubk(g$Start, 207, g$PT)

</code></pre>

<hr>
<h2 id='substituteSymbol'>Codes the substitution of a non-terminal symbol by the symbols 
derived by a production rule as a nested list.</h2><span id='topic+substituteSymbol'></span>

<h3>Description</h3>

<p><code>substituteSymbol()</code> 
generates a nested list with the non-terminal symbol as the root 
(first list element) and the derived symbols as the second list element.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>substituteSymbol(rindex, PT)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="substituteSymbol_+3A_rindex">rindex</code></td>
<td>
<p>Rule index.</p>
</td></tr>
<tr><td><code id="substituteSymbol_+3A_pt">PT</code></td>
<td>
<p>Production table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>2-element list.
</p>


<h3>See Also</h3>

<p>Other Generate Derivation Tree: 
<code><a href="#topic+generateDerivationTree">generateDerivationTree</a>()</code>,
<code><a href="#topic+randomDerivationTree">randomDerivationTree</a>()</code>,
<code><a href="#topic+rndsubk">rndsubk</a>()</code>,
<code><a href="#topic+rndsub">rndsub</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g&lt;-compileBNF(booleanGrammar())
substituteSymbol(3, g$PT)

</code></pre>

<hr>
<h2 id='testGenerateDerivationTree'>Generate, decode, and show <code>times</code> derivation trees from random 
integer vectors for grammar BNF on the console.</h2><span id='topic+testGenerateDerivationTree'></span>

<h3>Description</h3>

<p>Generate, decode, and show <code>times</code> derivation trees from random 
integer vectors for grammar BNF on the console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testGenerateDerivationTree(times, BNF, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="testGenerateDerivationTree_+3A_times">times</code></td>
<td>
<p>Number of derivation trees which should be generated.</p>
</td></tr>
<tr><td><code id="testGenerateDerivationTree_+3A_bnf">BNF</code></td>
<td>
<p>BNF.</p>
</td></tr>
<tr><td><code id="testGenerateDerivationTree_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. If TRUE (default) , print decoded derivation tree on console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of complete derivation trees generated.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testGenerateDerivationTree(5, BNF=booleanGrammar())
</code></pre>

<hr>
<h2 id='treeANL'>Builds an Attributed Node List (ANL) of a derivation tree.</h2><span id='topic+treeANL'></span>

<h3>Description</h3>

<p><code>treeANL()</code> recursively traverses a derivation tree
and collects information about the derivation tree in an attributed
node list (ANL).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treeANL(
  tree,
  ST,
  maxdepth = 5,
  ANL = list(),
  IL = list(),
  count = 1,
  depth = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="treeANL_+3A_tree">tree</code></td>
<td>
<p>A derivation tree.</p>
</td></tr>
<tr><td><code id="treeANL_+3A_st">ST</code></td>
<td>
<p>A symbol table.</p>
</td></tr>
<tr><td><code id="treeANL_+3A_maxdepth">maxdepth</code></td>
<td>
<p>Limit on the depth of a derivation tree.</p>
</td></tr>
<tr><td><code id="treeANL_+3A_anl">ANL</code></td>
<td>
<p>Attributed node list (empty on invocation).</p>
</td></tr>
<tr><td><code id="treeANL_+3A_il">IL</code></td>
<td>
<p>Index function list  (empty on invocation).</p>
</td></tr>
<tr><td><code id="treeANL_+3A_count">count</code></td>
<td>
<p>Trail count (1 on invocation).</p>
</td></tr>
<tr><td><code id="treeANL_+3A_depth">depth</code></td>
<td>
<p>Derivation tree depth (1 on invocation).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An attributed <code>node</code> has the following elements:
</p>

<ul>
<li> <p><code>$ID</code>:  Id in the symbol table <code>ST</code>.
</p>
</li>
<li> <p><code>$NT</code>:  Is the symbol a non-terminal?
</p>
</li>
<li> <p><code>$Pos</code>: Position in the trail.
</p>
</li>
<li> <p><code>$Depth</code>:  Depth of node.
</p>
</li>
<li> <p><code>$RDepth</code>: Residual depth for expansion.
</p>
</li>
<li> <p><code>$subtreedepth</code>: Depth of subtree starting here.
</p>
</li>
<li> <p><code>$Index</code>:  R index of the node in the derivation tree.
Allows fast tree extraction and insertion.
</p>
</li></ul>

<p>These elements can be used e.g. 
</p>

<ul>
<li><p> for inserting and extracting subtrees 
(<code>Pos</code> or  <code>node$Index</code>), 
</p>
</li>
<li><p> for checking
the feasibility of subtree substitution (<code>ID</code>),
</p>
</li>
<li><p> for checking depth bounds 
(<code>Depth</code>, <code>RDepth</code>, and <code>subtreedepth</code>),
...
</p>
</li></ul>



<h3>Value</h3>

<p>A list with three elements:
</p>

<ol>
<li> <p><code>r$count</code>: The trail length (not needed).
</p>
</li>
<li> <p><code>r$depth</code>: The derivation tree depth (not needed).
</p>
</li>
<li> <p><code>r$ANL</code>:   The attributed node list is a list of nodes.
Each node is represented as a list of the following attributes:
</p>

<ul>
<li> <p><code>Node$ID</code>:  Id in the symbol table ST.
</p>
</li>
<li> <p><code>Node$NT</code>:  Is the symbol a non-terminal?
</p>
</li>
<li> <p><code>Node$Pos</code>: Position in the trail.
</p>
</li>
<li> <p><code>Node$Depth</code>:  Depth of node.
</p>
</li>
<li> <p><code>Node$RDepth</code>: Residual depth for expansion.
</p>
</li>
<li> <p><code>Node$subtreedepth</code>: Depth of subtree starting here.
</p>
</li>
<li> <p><code>Node$Index</code>:  R index of the node in the derivation tree.
Allows fast tree extraction and insertion.
</p>
</li></ul>
 
</li></ol>



<h3>See Also</h3>

<p>Other Access Tree Parts: 
<code><a href="#topic+filterANLid">filterANLid</a>()</code>,
<code><a href="#topic+filterANL">filterANL</a>()</code>,
<code><a href="#topic+treeChildren">treeChildren</a>()</code>,
<code><a href="#topic+treeRoot">treeRoot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g&lt;-compileBNF(booleanGrammar())
a&lt;-randomDerivationTree(g$Start, g)
b&lt;-treeANL(a, g$ST)
c&lt;-treeANL(a, g$ST, 10)
d&lt;-treeANL(a, g$ST, maxdepth=10)

</code></pre>

<hr>
<h2 id='treeChildren'>Returns the children of a derivation tree.</h2><span id='topic+treeChildren'></span>

<h3>Description</h3>

<p><code>treeChildren()</code> returns the children of a derivation tree
represented as a list of derivation trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treeChildren(tree)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="treeChildren_+3A_tree">tree</code></td>
<td>
<p>Derivation tree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The children of a derivation tree (a list of derivation trees).
</p>


<h3>See Also</h3>

<p>Other Access Tree Parts: 
<code><a href="#topic+filterANLid">filterANLid</a>()</code>,
<code><a href="#topic+filterANL">filterANL</a>()</code>,
<code><a href="#topic+treeANL">treeANL</a>()</code>,
<code><a href="#topic+treeRoot">treeRoot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g&lt;-compileBNF(booleanGrammar())
a&lt;-randomDerivationTree(g$Start, g)
treeChildren(a) 

</code></pre>

<hr>
<h2 id='treeExtract'>Extracts the subtree at position <code>pos</code> in a derivation tree.</h2><span id='topic+treeExtract'></span>

<h3>Description</h3>

<p><code>treeExtract()</code> returns 
the subtree at position <code>pos</code> in a derivation tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treeExtract(tree, node)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="treeExtract_+3A_tree">tree</code></td>
<td>
<p>Derivation tree.</p>
</td></tr>
<tr><td><code id="treeExtract_+3A_node">node</code></td>
<td>
<p>Attributed node.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An attributed <code>node</code> is a list 
whose element <code>node$Index</code> contains 
an access function to the node. 
The access function is represented as a string 
with an executable R index expression.
All what remains to be done, is 
</p>

<ul>
<li><p>  to complete 
the access statement and  
</p>
</li>
<li><p> to return 
the result of parsing and evaluating the string.
</p>
</li></ul>



<h3>Value</h3>

<p>Derivation tree.
</p>


<h3>See Also</h3>

<p>Other Tree Operations: 
<code><a href="#topic+compatibleSubtrees">compatibleSubtrees</a>()</code>,
<code><a href="#topic+treeInsert">treeInsert</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g&lt;-compileBNF(booleanGrammar())
t1&lt;-randomDerivationTree(g$Start, g)
t1anl&lt;-treeANL(t1, g$ST)
n1&lt;-chooseNode(t1anl$ANL)
st1&lt;-treeExtract(t1, n1)
decodeCDT(st1, g$ST)
st2&lt;-treeExtract(t1, chooseNode(t1anl$ANLa))
decodeCDT(st2, g$ST)

</code></pre>

<hr>
<h2 id='treeInsert'>Inserts a subtree into a derivation tree at a <code>node</code>.</h2><span id='topic+treeInsert'></span>

<h3>Description</h3>

<p><code>treeInsert()</code> inserts a <code>subtree</code> into 
a <code>tree</code> at a <code>node</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treeInsert(tree, subtree, node)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="treeInsert_+3A_tree">tree</code></td>
<td>
<p>Derivation tree.</p>
</td></tr>
<tr><td><code id="treeInsert_+3A_subtree">subtree</code></td>
<td>
<p>Subtree.</p>
</td></tr>
<tr><td><code id="treeInsert_+3A_node">node</code></td>
<td>
<p>Attributed node.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An attributed <code>node</code> is a list 
whose element <code>node$Index</code> contains 
an access function to the node. 
The access function is represented as a string 
which contains an executable R index expression.
All what remains to be done, is 
</p>

<ul>
<li><p> to complete 
the assignment statement and 
</p>
</li>
<li><p> to parse and evaluate the string.
</p>
</li></ul>



<h3>Value</h3>

<p>A derivation tree.
</p>


<h3>See Also</h3>

<p>Other Tree Operations: 
<code><a href="#topic+compatibleSubtrees">compatibleSubtrees</a>()</code>,
<code><a href="#topic+treeExtract">treeExtract</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g&lt;-compileBNF(booleanGrammar())
t1&lt;-randomDerivationTree(g$Start, g)
t2&lt;-randomDerivationTree(g$Start, g)
t1anl&lt;-treeANL(t1, g$ST)
n1&lt;-chooseNode(t1anl$ANL)
t2&lt;-randomDerivationTree(n1$ID, g)
tI1&lt;-treeInsert(t1, t2, n1)
decodeCDT(tI1, g$ST)

</code></pre>

<hr>
<h2 id='treeLeaves'>Measures the number of leaves of a complete derivation tree.</h2><span id='topic+treeLeaves'></span>

<h3>Description</h3>

<p><code>treeLeaves()</code> returns 
the number of terminal symbols in a 
complete derivation tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treeLeaves(tree, ST)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="treeLeaves_+3A_tree">tree</code></td>
<td>
<p>Derivation tree.</p>
</td></tr>
<tr><td><code id="treeLeaves_+3A_st">ST</code></td>
<td>
<p>Symbol table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer. Number of terminal symbols in a complete derivation tree.
</p>


<h3>See Also</h3>

<p>Other Measures of Tree Attributes: 
<code><a href="#topic+treeListDepth">treeListDepth</a>()</code>,
<code><a href="#topic+treeNodes">treeNodes</a>()</code>,
<code><a href="#topic+treeSize">treeSize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g&lt;-compileBNF(booleanGrammar())
a&lt;-randomDerivationTree(g$Start, g)
treeLeaves(a, g$ST) 
((treeLeaves(a, g$ST)+treeNodes(a, g$ST)) == treeSize(a))

</code></pre>

<hr>
<h2 id='treeListDepth'>Measures the depth of a (nested) list.</h2><span id='topic+treeListDepth'></span>

<h3>Description</h3>

<p><code>treeListDepth()</code> returns the depth of a nested list.  
For a derivation tree, this is approximately twice
the derivation depth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treeListDepth(t, tDepth = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="treeListDepth_+3A_t">t</code></td>
<td>
<p>List.</p>
</td></tr>
<tr><td><code id="treeListDepth_+3A_tdepth">tDepth</code></td>
<td>
<p>Integer. List depth. Default: 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depth of a nested list.
</p>


<h3>See Also</h3>

<p>Other Measures of Tree Attributes: 
<code><a href="#topic+treeLeaves">treeLeaves</a>()</code>,
<code><a href="#topic+treeNodes">treeNodes</a>()</code>,
<code><a href="#topic+treeSize">treeSize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g&lt;-compileBNF(booleanGrammar())
a&lt;-randomDerivationTree(g$Start, g)
treeListDepth(a) 

</code></pre>

<hr>
<h2 id='treeNodes'>Measures the number of inner nodes in a derivation tree.</h2><span id='topic+treeNodes'></span>

<h3>Description</h3>

<p><code>treeNodes()</code> returns 
the number of non-terminal symbols in a 
derivation tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treeNodes(tree, ST)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="treeNodes_+3A_tree">tree</code></td>
<td>
<p>Derivation tree.</p>
</td></tr>
<tr><td><code id="treeNodes_+3A_st">ST</code></td>
<td>
<p>Symbol table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer. Number of non-terminal symbols in a derivation tree.
</p>


<h3>See Also</h3>

<p>Other Measures of Tree Attributes: 
<code><a href="#topic+treeLeaves">treeLeaves</a>()</code>,
<code><a href="#topic+treeListDepth">treeListDepth</a>()</code>,
<code><a href="#topic+treeSize">treeSize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g&lt;-compileBNF(booleanGrammar())
a&lt;-randomDerivationTree(g$Start, g)
treeNodes(a, g$ST) 

</code></pre>

<hr>
<h2 id='treeRoot'>Returns the root of a derivation tree.</h2><span id='topic+treeRoot'></span>

<h3>Description</h3>

<p><code>treeRoot()</code> returns the root of a derivation tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treeRoot(tree)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="treeRoot_+3A_tree">tree</code></td>
<td>
<p>Derivation tree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Root of a derivation tree.
</p>


<h3>See Also</h3>

<p>Other Access Tree Parts: 
<code><a href="#topic+filterANLid">filterANLid</a>()</code>,
<code><a href="#topic+filterANL">filterANL</a>()</code>,
<code><a href="#topic+treeANL">treeANL</a>()</code>,
<code><a href="#topic+treeChildren">treeChildren</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g&lt;-compileBNF(booleanGrammar())
a&lt;-randomDerivationTree(g$Start, g)
treeRoot(a) 

</code></pre>

<hr>
<h2 id='treeSize'>Measures the number of symbols in a derivation tree.</h2><span id='topic+treeSize'></span>

<h3>Description</h3>

<p><code>treeSize()</code> returns the number of symbols in a 
derivation tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treeSize(tree)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="treeSize_+3A_tree">tree</code></td>
<td>
<p>Derivation tree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer. Number of symbols in a derivation tree.
</p>


<h3>See Also</h3>

<p>Other Measures of Tree Attributes: 
<code><a href="#topic+treeLeaves">treeLeaves</a>()</code>,
<code><a href="#topic+treeListDepth">treeListDepth</a>()</code>,
<code><a href="#topic+treeNodes">treeNodes</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g&lt;-compileBNF(booleanGrammar())
a&lt;-randomDerivationTree(g$Start, g)
treeSize(a) 

</code></pre>

<hr>
<h2 id='xegaDerivationTrees'>Package xegaDerivationTrees</h2><span id='topic+xegaDerivationTrees'></span>

<h3>Description</h3>

<p>Derivation Trees
</p>


<h3>Details</h3>

<p>The implementation of a data type for derivation trees.
</p>
<p>The derivation tree operations for generating complete random subtrees and for
for subtree extraction and insertion are formally introduced in Geyer-Schulz (1997)
and used for implementing mutation and crossover operations. 
</p>
<p>Efficient selection of random subtrees is implemented by building a list of annotated 
tree nodes by a left-right depth-first tree traversal. For each node, the R-index 
to access the subtree is built and stored in the node. The R-index element of a node 
allows subtree extraction and insertion operations with the cost of the R-index operation.  
In addition, filtering operations the node list by different criteria (min depth, max depth, and 
non-terminal symbol type) allow the implementation of flexible and
configurable crossover and mutation operations.
</p>


<h3>The Architecture of the xegaX-Packages</h3>

<p>The xegaX-packages are a family of R-packages which implement 
eXtended Evolutionary and Genetic Algorithms (xega).  
The architecture has 3 layers, 
namely the user interface layer,
the population layer, and the gene layer: 
</p>

<ul>
<li>
<p>The user interface layer (package <code>xega</code>) 
provides a function call interface and configuration support
for several algorithms: genetic algorithms (sga), 
permutation-based genetic algorithms (sgPerm), 
derivation-free algorithms as e.g. differential evolution (sgde), 
grammar-based genetic programming (sgp) and grammatical evolution
(sge). 
</p>
</li>
<li>
<p>The population layer (package <code>xegaPopulation</code>) contains
population-related functionality as well as support for 
adaptive mechanisms which depend on population statistics. 
In addition, support for parallel evaluation of genes is implemented here.
</p>
</li>
<li> 
<p>The gene layer is split in a representation-independent and 
a representation-dependent part:
</p>

<ol>
<li> 
<p>The representation-indendent part (package <code>xegaSelectGene</code>)
is responsible for variants of selection operators, evaluation 
strategies for genes, as well as profiling and timing capabilities.        
</p>
</li>
<li> 
<p>The representation-dependent part consists of the following packages: 
</p>

<ul>
<li> <p><code>xegaGaGene</code> for binary-coded genetic algorithms.
</p>
</li>
<li> <p><code>xegaPermGene</code> for permutation-based genetic algorithms.
</p>
</li>
<li> <p><code>xegaDfGene</code> for derivation-free algorithms. For example, 
differential evolution.
</p>
</li>
<li> <p><code>xegaGpGene</code> for grammar-based genetic algorithms.
</p>
</li>
<li> <p><code>xegaGeGene</code> for grammatical evolution algorithms.
</p>
</li></ul>

<p>The packages <code>xegaDerivationTrees</code> and <code>xegaBNF</code> support
the last two packages:
<code>xegaBNF</code> essentially provides a grammar compiler, and 
<code>xegaDerivationTrees</code> an abstract data type for derivation trees.
</p>
</li></ol>
</li></ul>



<h3>Copyright</h3>

<p>(c) 2023 Andreas Geyer-Schulz
</p>


<h3>License</h3>

<p>MIT
</p>


<h3>URL</h3>

<p>&lt;https://github.com/ageyerschulz/xegaDerivationTrees&gt;
</p>


<h3>Installation</h3>

<p>From cran with <code>install.packages("xegaDerivationTrees")</code>
</p>


<h3>Author(s)</h3>

<p>Andreas Geyer-Schulz
</p>


<h3>References</h3>

<p>Geyer-Schulz, Andreas (1997):
<em>Fuzzy Rule-Based Expert Systems and Genetic Machine Learning</em>,
Physica, Heidelberg.
(ISBN:978-3-7908-0830-X)
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
