<!DOCTYPE html><html><head><title>Help for package inlabru</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {inlabru}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#inlabru-package'><p>inlabru</p></a></li>
<li><a href='#+5B.comp_simple_list'><p>Subsetting of comp_simple_list objects, retaining class</p></a></li>
<li><a href='#add_mappers'><p>Add component input/latent mappers</p></a></li>
<li><a href='#bincount'><p>1D LGCP bin count simulation and comparison with data</p></a></li>
<li><a href='#bm_list'><p>Methods for mapper lists</p></a></li>
<li><a href='#bru'><p>Convenient model fitting using (iterated) INLA</p></a></li>
<li><a href='#bru_call_options'><p>Additional bru options</p></a></li>
<li><a href='#bru_compute_linearisation'><p>Compute inlabru model linearisation information</p></a></li>
<li><a href='#bru_convergence_plot'><p>Plot inlabru convergence diagnostics</p></a></li>
<li><a href='#bru_env_get'><p>Get access to the internal environment</p></a></li>
<li><a href='#bru_fill_missing'><p>Fill in missing values in Spatial grids</p></a></li>
<li><a href='#bru_forward_transformation'><p>Transformation tools</p></a></li>
<li><a href='#bru_get_mapper'><p>Extract mapper information from INLA model component objects</p></a></li>
<li><a href='#bru_inla.stack.mexpand'><p>Backwards compatibility to handle mexpand for INLA &lt;= 24.06.02</p></a></li>
<li><a href='#bru_inla.stack.mjoin'><p>Join stacks intended to be run with different likelihoods</p></a></li>
<li><a href='#bru_int_polygon'><p>Integration points for polygons inside an inla.mesh</p></a></li>
<li><a href='#bru_like_inla_family'><p>Utility functions for bru likelihood objects</p></a></li>
<li><a href='#bru_log'><p>Access methods for <code>bru_log</code> objects</p></a></li>
<li><a href='#bru_log_bookmark'><p>Methods for <code>bru_log</code> bookmarks</p></a></li>
<li><a href='#bru_log_message'><p>Add a log message</p></a></li>
<li><a href='#bru_log_new'><p>Create a <code>bru_log</code> object</p></a></li>
<li><a href='#bru_log_offset'><p>Position methods for <code>bru_log</code> objects</p></a></li>
<li><a href='#bru_log_reset'><p>Clear log contents</p></a></li>
<li><a href='#bru_make_stack'><p>Build an inla data stack from linearisation information</p></a></li>
<li><a href='#bru_mapper'><p>Constructors for <code>bru_mapper</code> objects</p></a></li>
<li><a href='#bru_mapper_aggregate'><p>Mapper for aggregation</p></a></li>
<li><a href='#bru_mapper_collect'><p>Mapper for concatenated variables</p></a></li>
<li><a href='#bru_mapper_const'><p>Constant mapper</p></a></li>
<li><a href='#bru_mapper_factor'><p>Mapper for factor variables</p></a></li>
<li><a href='#bru_mapper_generics'><p>Generic methods for bru_mapper objects</p></a></li>
<li><a href='#bru_mapper_harmonics'><p>Mapper for cos/sin functions</p></a></li>
<li><a href='#bru_mapper_index'><p>Mapper for indexed variables</p></a></li>
<li><a href='#bru_mapper_linear'><p>Mapper for a linear effect</p></a></li>
<li><a href='#bru_mapper_logsumexp'><p>Mapper for log-sum-exp aggregation</p></a></li>
<li><a href='#bru_mapper_marginal'><p>Mapper for marginal distribution transformation</p></a></li>
<li><a href='#bru_mapper_matrix'><p>Mapper for matrix multiplication</p></a></li>
<li><a href='#bru_mapper_mesh_B'><p>Mapper for basis conversion</p></a></li>
<li><a href='#bru_mapper_multi'><p>Mapper for tensor product domains</p></a></li>
<li><a href='#bru_mapper_pipe'><p>Mapper for linking several mappers in sequence</p></a></li>
<li><a href='#bru_mapper_scale'><p>Mapper for element-wise scaling</p></a></li>
<li><a href='#bru_mapper_shift'><p>Mapper for element-wise shifting</p></a></li>
<li><a href='#bru_mapper_taylor'><p>Mapper for linear Taylor approximations</p></a></li>
<li><a href='#bru_mapper.fm_mesh_1d'><p>Mapper for <code>fm_mesh_1d</code></p></a></li>
<li><a href='#bru_mapper.fm_mesh_2d'><p>Mapper for <code>fm_mesh_2d</code></p></a></li>
<li><a href='#bru_model'><p>Create an inlabru model object from model components</p></a></li>
<li><a href='#bru_options'><p>Create or update an options objects</p></a></li>
<li><a href='#bru_safe_inla'><p>Load INLA safely for examples and tests</p></a></li>
<li><a href='#bru_safe_sp'><p>Check for potential <code>sp</code> version compatibility issues</p></a></li>
<li><a href='#bru_standardise_names'><p>Standardise inla hyperparameter names</p></a></li>
<li><a href='#bru_summarise'><p>Summarise and annotate data</p></a></li>
<li><a href='#bru_timings'><p>Extract timing information from fitted bru object</p></a></li>
<li><a href='#bru_timings_plot'><p>Plot inlabru iteration timings</p></a></li>
<li><a href='#bru_used'><p>List components used in a model</p></a></li>
<li><a href='#bru_used_update'><p>Update used_component information objects</p></a></li>
<li><a href='#bru_used_vars'><p>Extract basic variable names from expression</p></a></li>
<li><a href='#code.components'><p>Convert components to R code</p></a></li>
<li><a href='#comp_lin_eval'><p>Construct component linearisations</p></a></li>
<li><a href='#component'><p>Latent model component construction</p></a></li>
<li><a href='#component_eval'><p>Evaluate component values in predictor expressions</p></a></li>
<li><a href='#component_list'><p>Methods for inlabru component lists</p></a></li>
<li><a href='#deltaIC'><p>Summarise DIC and WAIC from <code>lgcp</code> objects.</p></a></li>
<li><a href='#devel.cvmeasure'><p>Variance and correlations measures for prediction components</p></a></li>
<li><a href='#eval_in_data_context'><p>Evaluate expressions in the data context</p></a></li>
<li><a href='#eval_spatial'><p>Evaluate spatial covariates</p></a></li>
<li><a href='#evaluate_comp_lin'><p>Compute all component linearisations</p></a></li>
<li><a href='#evaluate_comp_simple'><p>Compute simplified component mappings</p></a></li>
<li><a href='#evaluate_effect_single_state'><p>Evaluate a component effect</p></a></li>
<li><a href='#evaluate_index'><p>Compute all index values</p></a></li>
<li><a href='#evaluate_inputs'><p>Compute all component inputs</p></a></li>
<li><a href='#evaluate_model'><p>Evaluate or sample from a posterior result given a model and locations</p></a></li>
<li><a href='#evaluate_predictor'><p>Evaluate component effects or expressions</p></a></li>
<li><a href='#expand_labels'><p>Expand labels</p></a></li>
<li><a href='#extract_property'><p>Extract a summary property from all results of an inla result</p></a></li>
<li><a href='#generate'><p>Generate samples from fitted bru models</p></a></li>
<li><a href='#gg'><p>ggplot2 geomes for inlabru related objects</p></a></li>
<li><a href='#gg.bru_prediction'><p>Geom for predictions</p></a></li>
<li><a href='#gg.data.frame'><p>Geom for data.frame</p></a></li>
<li><a href='#gg.fm_mesh_1d'><p>Geom for fm_mesh_1d objects</p></a></li>
<li><a href='#gg.fm_mesh_2d'><p>Geom for inla.mesh objects</p></a></li>
<li><a href='#gg.matrix'><p>Geom for matrix</p></a></li>
<li><a href='#gg.RasterLayer'><p>Geom for RasterLayer objects</p></a></li>
<li><a href='#gg.sf'><p>Geom helper for sf objects</p></a></li>
<li><a href='#gg.SpatialGridDataFrame'><p>Geom for SpatialGridDataFrame objects</p></a></li>
<li><a href='#gg.SpatialLines'><p>Geom for SpatialLines objects</p></a></li>
<li><a href='#gg.SpatialPixels'><p>Geom for SpatialPixels objects</p></a></li>
<li><a href='#gg.SpatialPixelsDataFrame'><p>Geom for SpatialPixelsDataFrame objects</p></a></li>
<li><a href='#gg.SpatialPoints'><p>Geom for SpatialPoints objects</p></a></li>
<li><a href='#gg.SpatialPolygons'><p>Geom for SpatialPolygons objects</p></a></li>
<li><a href='#gg.SpatRaster'><p>Geom wrapper for SpatRaster objects</p></a></li>
<li><a href='#globe'><p>Visualize a globe using RGL</p></a></li>
<li><a href='#glplot'><p>Render objects using RGL</p></a></li>
<li><a href='#gm'><p>ggplot geom for spatial data</p></a></li>
<li><a href='#gmap'><p>Plot a map using extent of a spatial object</p></a></li>
<li><a href='#gorillas'><p>Gorilla nesting sites</p></a></li>
<li><a href='#gorillas_sf'><p>Gorilla nesting sites in sf format</p></a></li>
<li><a href='#iinla'><p>Iterated INLA</p></a></li>
<li><a href='#index_eval'><p>Obtain indices</p></a></li>
<li><a href='#inla_subset_eval'><p>Obtain inla index subset information</p></a></li>
<li><a href='#input_eval'><p>Obtain component inputs</p></a></li>
<li><a href='#ipoints'><p>Deprecated functions in inlabru</p></a></li>
<li><a href='#lgcp'><p>Log Gaussian Cox process (LGCP) inference using INLA</p></a></li>
<li><a href='#like'><p>Observation model construction for usage with <code>bru()</code></p></a></li>
<li><a href='#local_testthat'><p>Unit test helpers</p></a></li>
<li><a href='#make_hierarchical_mesh_basis'><p>Make hierarchical mesh basis functions</p></a></li>
<li><a href='#materncov.bands'><p>Matern correlation or covariance function approximate credible bands.</p></a></li>
<li><a href='#mexdolphin'><p>Pan-tropical spotted dolphins in the Gulf of Mexico</p></a></li>
<li><a href='#mexdolphin_sf'><p>Pan-tropical spotted dolphins in the Gulf of Mexico</p></a></li>
<li><a href='#mrsea'><p>Marine renewables strategic environmental assessment</p></a></li>
<li><a href='#multiplot'><p>Multiple ggplots on a page.</p></a></li>
<li><a href='#parse_inclusion'><p>Parse inclusion of component labels in a predictor expression</p></a></li>
<li><a href='#plot.bru'><p>Plot method for posterior marginals estimated by bru</p></a></li>
<li><a href='#plot.bru_prediction'><p>Plot prediction using ggplot2</p></a></li>
<li><a href='#plotsample'><p>Create a plot sample.</p></a></li>
<li><a href='#point2count'><p>Convert a plot sample of points into one of counts.</p></a></li>
<li><a href='#Poisson1_1D'><p>1-Dimensional Homogeneous Poisson example.</p></a></li>
<li><a href='#Poisson2_1D'><p>1-Dimensional NonHomogeneous Poisson example.</p></a></li>
<li><a href='#Poisson3_1D'><p>1-Dimensional NonHomogeneous Poisson example.</p></a></li>
<li><a href='#predict.bru'><p>Prediction from fitted bru model</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#robins_subset'><p>robins_subset</p></a></li>
<li><a href='#row_kron'><p>Row-wise Kronecker products</p></a></li>
<li><a href='#sample.lgcp'><p>Sample from an inhomogeneous Poisson process</p></a></li>
<li><a href='#seals'><p>Seal pups</p></a></li>
<li><a href='#shrimp'><p>Blue and red shrimp in the Western Mediterranean Sea</p></a></li>
<li><a href='#sline'><p>Convert data frame to SpatialLinesDataFrame</p></a></li>
<li><a href='#spatial.to.ppp'><p>Convert SpatialPoints and boundary polygon to spatstat ppp object</p></a></li>
<li><a href='#spde.posterior'><p>Posteriors of SPDE hyper parameters and Matern correlation or covariance function.</p></a></li>
<li><a href='#spoly'><p>Convert a data.frame of boundary points into a SpatialPolgonsDataFrame</p></a></li>
<li><a href='#summary.bru'><p>Summary for an inlabru fit</p></a></li>
<li><a href='#summary.bru_info'><p>Methods for bru_info objects</p></a></li>
<li><a href='#summary.bru_mapper'><p>mapper object summaries</p></a></li>
<li><a href='#summary.bru_options'><p>Print inlabru options</p></a></li>
<li><a href='#summary.component'><p>Summarise components</p></a></li>
<li><a href='#toygroups'><p>Simulated 1D animal group locations and group sizes</p></a></li>
<li><a href='#toypoints'><p>Simulated 2D point process data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Latent Gaussian Modelling using INLA and Extensions</td>
</tr>
<tr>
<td>Version:</td>
<td>2.11.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.inlabru.org">http://www.inlabru.org</a>, <a href="https://inlabru-org.github.io/inlabru/">https://inlabru-org.github.io/inlabru/</a>,
<a href="https://github.com/inlabru-org/inlabru">https://github.com/inlabru-org/inlabru</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/inlabru-org/inlabru/issues">https://github.com/inlabru-org/inlabru/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Facilitates spatial and general latent Gaussian modeling using
  integrated nested Laplace approximation via the INLA package (<a href="https://www.r-inla.org">https://www.r-inla.org</a>).
  Additionally, extends the GAM-like model class to more general nonlinear predictor
  expressions, and implements a log Gaussian Cox process likelihood for 
  modeling univariate and spatial point processes based on ecological survey data.
  Model components are specified with general inputs and mapping methods to the
  latent variables, and the predictors are specified via general R expressions,
  with separate expressions for each observation likelihood model in
  multi-likelihood models. A prediction method based on fast Monte Carlo sampling
  allows posterior prediction of general expressions of the latent variables.
  Ecology-focused introduction in Bachl, Lindgren, Borchers, and Illian (2019)
  &lt;<a href="https://doi.org/10.1111%2F2041-210X.13168">doi:10.1111/2041-210X.13168</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://inla.r-inla-download.org/R/testing">https://inla.r-inla-download.org/R/testing</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>fmesher (&ge; 0.1.2), methods, R (&ge; 3.6), stats</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, lifecycle, magrittr, MatrixModels, Matrix, plyr, rlang,
sf, sp (&ge; 1.4-5), terra, tibble, utils, withr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, ggmap, ggplot2, graphics, INLA (&ge; 23.01.31), knitr,
maps, mgcv, patchwork, raster, RColorBrewer, rgl, rmarkdown,
scales, shiny, sn, spatstat.geom, spatstat.data, sphereplot,
splancs, tidyterra, testthat, tidyr, DiagrammeR</td>
</tr>
<tr>
<td>Enhances:</td>
<td>stars</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Collate:</td>
<td>'0_inlabru_envir.R' 'bru.gof.R' 'bru.inference.R'
'bru.integration.R' 'bru.spatial.R' 'data.Poisson1_1D.R'
'data.Poisson2_1D.R' 'data.Poisson3_1D.R' 'data.gorillas.R'
'data.mexdolphin.R' 'data.mrsea.R' 'data.robins_subset.R'
'data.seals.R' 'data.shrimp.R' 'data.toygroups.R'
'data.toypoints.R' 'deltaIC.R' 'deprecated.R' 'effect.R'
'environment.R' 'fmesher.R' 'ggplot.R' 'inla.R'
'inlabru-package.R' 'integration.R' 'local_testthat.R'
'mappers.R' 'mesh.R' 'model.R' 'nlinla.R' 'plotsample.R'
'rgl.R' 'sampling.R' 'spatstat.R' 'spde.R' 'stack.R'
'track_plotting.R' 'transformation.R' 'utils.R'</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>BuildVignettes:</td>
<td>true</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-01 21:58:41 UTC; flindgre</td>
</tr>
<tr>
<td>Author:</td>
<td>Finn Lindgren <a href="https://orcid.org/0000-0002-5833-2011"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph] (Finn Lindgren continued development of the main
    code),
  Fabian E. Bachl [aut, cph] (Fabian Bachl wrote the main code),
  David L. Borchers [ctb, dtc, cph] (David Borchers wrote code for
    Gorilla data import and sampling, multiplot tool),
  Daniel Simpson [ctb, cph] (Daniel Simpson wrote the basic LGCP sampling
    method),
  Lindesay Scott-Howard [ctb, dtc, cph] (Lindesay Scott-Howard provided
    MRSea data import code),
  Seaton Andy [ctb] (Andy Seaton provided testing, bugfixes, and
    vignettes),
  Suen Man Ho [ctb, cph] (Man Ho Suen contributed features for aggregated
    responses and vignette updates),
  Roudier Pierre [ctb, cph] (Pierre Roudier contributed general quantile
    summaries),
  Meehan Tim [ctb, cph] (Tim Meehan contributed the SVC vignette and
    robins data),
  Reddy Peddinenikalva Niharika [ctb, cph] (Niharika Peddinenikalva
    contributed the LGCP residuals vignette),
  Perepolkin Dmytro [ctb, cph] (Dmytro Perepolkin contributed the ZIP/ZAP
    vignette)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Finn Lindgren &lt;finn.lindgren@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-01 23:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='inlabru-package'>inlabru</h2><span id='topic+inlabru-package'></span><span id='topic+inlabru'></span>

<h3>Description</h3>

<p>Convenient model fitting using (iterated) INLA.
</p>


<h3>Details</h3>

<p><code>inlabru</code> facilitates Bayesian spatial modelling using integrated nested
Laplace approximations. It is heavily based on R-inla
(<a href="https://www.r-inla.org">https://www.r-inla.org</a>) but adds additional modelling abilities and simplified
syntax for (in particular) spatial models.
Tutorials and more information can be found at
<a href="https://inlabru-org.github.io/inlabru/">https://inlabru-org.github.io/inlabru/</a> and <a href="http://www.inlabru.org/">http://www.inlabru.org/</a>.
The iterative method used for non-linear predictors is documented in the
<code>method</code> vignette.
</p>
<p>The main function for inference using inlabru is <code><a href="#topic+bru">bru()</a></code>.
The general model specification details is documented in <code><a href="#topic+component">component()</a></code> and <code><a href="#topic+like">like()</a></code>.
Posterior quantities beyond the basic summaries can be calculated with
a <code>predict()</code> method, documented in <code><a href="#topic+predict.bru">predict.bru()</a></code>.
For point process inference <code><a href="#topic+lgcp">lgcp()</a></code> can be used as a shortcut to <code>bru(..., like(model="cp", ...))</code>.
</p>
<p>The package comes with multiple real world data sets, namely <a href="#topic+gorillas">gorillas</a>,
<a href="#topic+mexdolphin">mexdolphin</a>, <a href="#topic+gorillas_sf">gorillas_sf</a>, <a href="#topic+mexdolphin_sf">mexdolphin_sf</a>, <a href="#topic+seals_sp">seals_sp</a>. Plotting these data
sets is straight forward using inlabru's extensions
to <code>ggplot2</code>, e.g. the <code><a href="#topic+gg">gg()</a></code> function. For educational purposes some simulated data sets are available
as well, e.g. <a href="#topic+Poisson1_1D">Poisson1_1D</a>, <a href="#topic+Poisson2_1D">Poisson2_1D</a>, <a href="#topic+Poisson2_1D">Poisson2_1D</a> and <a href="#topic+toygroups">toygroups</a>.
</p>


<h3>Author(s)</h3>

<p>Fabian E. Bachl <a href="mailto:bachlfab@gmail.com">bachlfab@gmail.com</a>
and Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="http://www.inlabru.org">http://www.inlabru.org</a>
</p>
</li>
<li> <p><a href="https://inlabru-org.github.io/inlabru/">https://inlabru-org.github.io/inlabru/</a>
</p>
</li>
<li> <p><a href="https://github.com/inlabru-org/inlabru">https://github.com/inlabru-org/inlabru</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/inlabru-org/inlabru/issues">https://github.com/inlabru-org/inlabru/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+5B.comp_simple_list'>Subsetting of comp_simple_list objects, retaining class</h2><span id='topic++5B.comp_simple_list'></span>

<h3>Description</h3>

<p>Subsetting of comp_simple_list objects, retaining class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'comp_simple_list'
x[i]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.comp_simple_list_+3A_x">x</code></td>
<td>
<p><code>comp_simple_list</code> object from which to extract element(s)</p>
</td></tr>
<tr><td><code id="+2B5B.comp_simple_list_+3A_i">i</code></td>
<td>
<p>indices specifying elements to extract</p>
</td></tr>
</table>

<hr>
<h2 id='add_mappers'>Add component input/latent mappers</h2><span id='topic+add_mappers'></span><span id='topic+add_mappers.component'></span><span id='topic+add_mappers.component_list'></span>

<h3>Description</h3>

<p>Add missing mappers between input data and latent variables,
based on likelihood data
</p>
<p>Equip component(s) with mappers for subcomponents that do not
have predefined mappers. When needed, the data in <code>lhoods</code> is used to determine
the appropriate mapper(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_mappers(...)

## S3 method for class 'component'
add_mappers(component, lhoods, ...)

## S3 method for class 'component_list'
add_mappers(components, lhoods, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_mappers_+3A_...">...</code></td>
<td>
<p>Parameters passed on to other methods</p>
</td></tr>
<tr><td><code id="add_mappers_+3A_component">component</code></td>
<td>
<p>A <code>component</code> object</p>
</td></tr>
<tr><td><code id="add_mappers_+3A_lhoods">lhoods</code></td>
<td>
<p>A <code>bru_like_list</code> object</p>
</td></tr>
<tr><td><code id="add_mappers_+3A_components">components</code></td>
<td>
<p>A <code>component_list</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>component</code> object with completed mapper information
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (interactive()) {
}

## End(Not run)
</code></pre>

<hr>
<h2 id='bincount'>1D LGCP bin count simulation and comparison with data</h2><span id='topic+bincount'></span>

<h3>Description</h3>

<p>A common procedure of analyzing the distribution of 1D points is to chose a
binning and plot the data's histogram with respect to this binning. This
function compares the counts that the histogram calculates to simulations
from a 1D log Gaussian Cox process conditioned on the number of data samples.
For each bin this results in a median number of counts as well as a
confidence interval. If the LGCP is a plausible model for the observed points
then most of the histogram counts (number of points within a bin) should be
within the confidence intervals. Note that a proper comparison  is a multiple
testing problem which the function does not solve for you.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bincount(
  result,
  predictor,
  observations,
  breaks,
  nint = 20,
  probs = c(0.025, 0.5, 0.975),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bincount_+3A_result">result</code></td>
<td>
<p>A result object from a <code><a href="#topic+bru">bru()</a></code> or <code><a href="#topic+lgcp">lgcp()</a></code> call</p>
</td></tr>
<tr><td><code id="bincount_+3A_predictor">predictor</code></td>
<td>
<p>A formula describing the prediction of a 1D LGCP via
<code><a href="stats.html#topic+predict">predict()</a></code>.</p>
</td></tr>
<tr><td><code id="bincount_+3A_observations">observations</code></td>
<td>
<p>A vector of observed values</p>
</td></tr>
<tr><td><code id="bincount_+3A_breaks">breaks</code></td>
<td>
<p>A vector of bin boundaries</p>
</td></tr>
<tr><td><code id="bincount_+3A_nint">nint</code></td>
<td>
<p>Number of integration points per bin. Increase this if the bins
are wide and</p>
</td></tr>
<tr><td><code id="bincount_+3A_probs">probs</code></td>
<td>
<p>numeric vector of probabilities with values in <code style="white-space: pre;">&#8288;[0,1]&#8288;</code></p>
</td></tr>
<tr><td><code id="bincount_+3A_...">...</code></td>
<td>
<p>arguments passed on to <code><a href="#topic+predict.bru">predict.bru()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>data.frame</code> with a ggplot attribute <code>ggp</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (require(ggplot2) &amp;&amp; require(fmesher)) {
  # Load a point pattern
  data(Poisson2_1D)

  # Take a look at the point (and frequency) data

  ggplot(pts2) +
    geom_histogram(
      aes(x = x),
      binwidth = 55 / 20,
      boundary = 0,
      fill = NA,
      color = "black"
    ) +
    geom_point(aes(x), y = 0, pch = "|", cex = 4) +
    coord_fixed(ratio = 1)

  # Fit an LGCP model
  x &lt;- seq(0, 55, length.out = 50)
  mesh1D &lt;- fm_mesh_1d(x, boundary = "free")
  mdl &lt;- x ~ spde1D(x, model = inla.spde2.matern(mesh1D)) + Intercept(1)
  fit.spde &lt;- lgcp(mdl, pts2, domain = list(x = c(0, 55)))

  # Calculate bin statistics
  bc &lt;- bincount(
    result = fit.spde,
    observations = pts2,
    breaks = seq(0, max(pts2), length.out = 12),
    predictor = x ~ exp(spde1D + Intercept)
  )


  # Plot them!
  attributes(bc)$ggp
}

## End(Not run)

</code></pre>

<hr>
<h2 id='bm_list'>Methods for mapper lists</h2><span id='topic+bm_list'></span><span id='topic+c.bru_mapper'></span><span id='topic+c.bm_list'></span><span id='topic++5B.bm_list'></span>

<h3>Description</h3>

<p><code>bru_mapper</code> lists can be combined into <code>bm_list</code> lists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bru_mapper'
c(...)

## S3 method for class 'bm_list'
c(...)

## S3 method for class 'bm_list'
x[i]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bm_list_+3A_...">...</code></td>
<td>
<p>Objects to be combined.</p>
</td></tr>
<tr><td><code id="bm_list_+3A_x">x</code></td>
<td>
<p><code>bm_list</code> object from which to extract element(s)</p>
</td></tr>
<tr><td><code id="bm_list_+3A_i">i</code></td>
<td>
<p>indices specifying elements to extract</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>bm_list</code> object
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>c(bm_list)</code>: The <code>...</code> arguments should be <code>bm_list</code>
objects.
</p>
</li>
<li> <p><code>[</code>: Extract sub-list
</p>
</li></ul>


<h3>Functions</h3>


<ul>
<li> <p><code>c(bru_mapper)</code>: The <code>...</code> arguments should be <code>bru_mapper</code>
objects.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- c(A = bru_mapper_const(), B = bru_mapper_scale())
str(m)
str(m[2])
</code></pre>

<hr>
<h2 id='bru'>Convenient model fitting using (iterated) INLA</h2><span id='topic+bru'></span><span id='topic+bru_rerun'></span>

<h3>Description</h3>

<p>This method is a wrapper for <code>INLA::inla</code> and provides
multiple enhancements.
</p>

<ul>
<li>
<p>Easy usage of spatial covariates and automatic construction of inla
projection matrices for (spatial) SPDE models. This feature is
accessible via the <code>components</code> parameter. Practical examples on how to
use spatial data by means of the components parameter can also be found
by looking at the <a href="#topic+lgcp">lgcp</a> function's documentation.
</p>
</li>
<li>
<p>Constructing multiple likelihoods is straight forward. See <a href="#topic+like">like</a> for
more information on how to provide additional likelihoods to <code>bru</code>
using the <code>...</code> parameter list.
</p>
</li>
<li>
<p>Support for non-linear predictors. See example below.
</p>
</li>
<li>
<p>Log Gaussian Cox process (LGCP) inference is
available by using the <code>cp</code> family or (even easier) by using the
<a href="#topic+lgcp">lgcp</a> function.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>bru(components = ~Intercept(1), ..., options = list(), .envir = parent.frame())

bru_rerun(result, options = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_+3A_components">components</code></td>
<td>
<p>A <code>formula</code>-like specification of latent components.
Also used to define a default linear additive predictor.  See
<code><a href="#topic+component">component()</a></code> for details.</p>
</td></tr>
<tr><td><code id="bru_+3A_...">...</code></td>
<td>
<p>Likelihoods, each constructed by a calling <code><a href="#topic+like">like()</a></code>, or named
parameters that can be passed to a single <code><a href="#topic+like">like()</a></code> call. Note that
all the arguments will be evaluated before calling <code><a href="#topic+like">like()</a></code> in order
to detect if they are <code>like</code> objects. This means that
special arguments that need to be evaluated in the context of
<code>response_data</code> or <code>data</code> (such as Ntrials) may will only work that
way in direct calls to <code><a href="#topic+like">like()</a></code>.</p>
</td></tr>
<tr><td><code id="bru_+3A_options">options</code></td>
<td>
<p>A <a href="#topic+bru_options">bru_options</a> options object or a list of options passed
on to <code><a href="#topic+bru_options">bru_options()</a></code></p>
</td></tr>
<tr><td><code id="bru_+3A_.envir">.envir</code></td>
<td>
<p>Environment for component evaluation (for when a non-formula
specification is used)</p>
</td></tr>
<tr><td><code id="bru_+3A_result">result</code></td>
<td>
<p>A previous estimation object of class <code>bru</code></p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>bru_rerun</code> Continue the optimisation from a previously computed estimate.
</p>
</li></ul>



<h3>Value</h3>

<p>bru returns an object of class &quot;bru&quot;. A <code>bru</code> object inherits
from <code>INLA::inla</code> (see the inla documentation for its properties) and
adds additional information stored in the <code>bru_info</code> field.
</p>


<h3>Author(s)</h3>

<p>Fabian E. Bachl <a href="mailto:bachlfab@gmail.com">bachlfab@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (bru_safe_inla(multicore = FALSE)) {

  # Simulate some covariates x and observations y
  input.df &lt;- data.frame(x = cos(1:10))
  input.df &lt;- within(input.df, y &lt;- 5 + 2 * x + rnorm(10, mean = 0, sd = 0.1))

  # Fit a Gaussian likelihood model
  fit &lt;- bru(y ~ x + Intercept, family = "gaussian", data = input.df)

  # Obtain summary
  fit$summary.fixed
}


if (bru_safe_inla(multicore = FALSE)) {

  # Alternatively, we can use the like() function to construct the likelihood:

  lik &lt;- like(family = "gaussian", formula = y ~ x + Intercept, data = input.df)
  fit &lt;- bru(~ x + Intercept(1), lik)
  fit$summary.fixed
}

# An important addition to the INLA methodology is bru's ability to use
# non-linear predictors. Such a predictor can be formulated via like()'s
# \code{formula} parameter. The z(1) notation is needed to ensure that
# the z component should be interpreted as single latent variable and not
# a covariate:

if (bru_safe_inla(multicore = FALSE)) {
  z &lt;- 2
  input.df &lt;- within(input.df, y &lt;- 5 + exp(z) * x + rnorm(10, mean = 0, sd = 0.1))
  lik &lt;- like(
    family = "gaussian", data = input.df,
    formula = y ~ exp(z) * x + Intercept
  )
  fit &lt;- bru(~ z(1) + Intercept(1), lik)

  # Check the result (z posterior should be around 2)
  fit$summary.fixed
}

</code></pre>

<hr>
<h2 id='bru_call_options'>Additional bru options</h2><span id='topic+bru_call_options'></span>

<h3>Description</h3>

<p>Construct a <code>bru_options</code> object including the default and global options,
and converting deprecated option names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_call_options(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_call_options_+3A_...">...</code></td>
<td>
<p>Options passed on to <code><a href="#topic+as.bru_options">as.bru_options()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>bru_options</code> object
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

opts &lt;- bru_call_options()

# Print them:
opts


</code></pre>

<hr>
<h2 id='bru_compute_linearisation'>Compute inlabru model linearisation information</h2><span id='topic+bru_compute_linearisation'></span><span id='topic+bru_compute_linearisation.component'></span><span id='topic+bru_compute_linearisation.bru_like'></span><span id='topic+bru_compute_linearisation.bru_like_list'></span><span id='topic+bru_compute_linearisation.bru_model'></span>

<h3>Description</h3>

<p>Compute inlabru model linearisation information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_compute_linearisation(...)

## S3 method for class 'component'
bru_compute_linearisation(
  cmp,
  model,
  lhood_expr,
  data,
  input,
  state,
  comp_simple,
  effects,
  pred0,
  used,
  allow_latent,
  allow_combine,
  eps,
  ...
)

## S3 method for class 'bru_like'
bru_compute_linearisation(
  lhood,
  model,
  data,
  input,
  state,
  comp_simple,
  eps,
  ...
)

## S3 method for class 'bru_like_list'
bru_compute_linearisation(
  lhoods,
  model,
  input,
  state,
  comp_simple,
  eps = 0.00001,
  ...
)

## S3 method for class 'bru_model'
bru_compute_linearisation(model, lhoods, input, state, comp_simple, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_compute_linearisation_+3A_...">...</code></td>
<td>
<p>Parameters passed on to other methods</p>
</td></tr>
<tr><td><code id="bru_compute_linearisation_+3A_cmp">cmp</code></td>
<td>
<p>A <a href="#topic+bru_component">bru_component</a> object</p>
</td></tr>
<tr><td><code id="bru_compute_linearisation_+3A_model">model</code></td>
<td>
<p>A <code>bru_model</code> object</p>
</td></tr>
<tr><td><code id="bru_compute_linearisation_+3A_lhood_expr">lhood_expr</code></td>
<td>
<p>A predictor expression</p>
</td></tr>
<tr><td><code id="bru_compute_linearisation_+3A_data">data</code></td>
<td>
<p>Input data</p>
</td></tr>
<tr><td><code id="bru_compute_linearisation_+3A_input">input</code></td>
<td>
<p>Precomputed component inputs from <code>evaluate_inputs()</code></p>
</td></tr>
<tr><td><code id="bru_compute_linearisation_+3A_state">state</code></td>
<td>
<p>The state information, as a list of named vectors</p>
</td></tr>
<tr><td><code id="bru_compute_linearisation_+3A_comp_simple">comp_simple</code></td>
<td>
<p>Component evaluation information
</p>

<ul>
<li><p> For <code>bru_component</code>: <code>bru_mapper_taylor</code> object
</p>
</li>
<li><p> For <code>bru_like</code>: A <code>comp_simple_list</code> object
for the components in the likelihood
</p>
</li>
<li><p> For <code>bru_like_list</code>: A <code>comp_simple_list_list</code> object
</p>
</li></ul>
</td></tr>
<tr><td><code id="bru_compute_linearisation_+3A_effects">effects</code></td>
<td>

<ul>
<li><p> For <code>bru_component</code>:
Precomputed effect list for all components involved in the likelihood
expression
</p>
</li></ul>
</td></tr>
<tr><td><code id="bru_compute_linearisation_+3A_pred0">pred0</code></td>
<td>
<p>Precomputed predictor for the given state</p>
</td></tr>
<tr><td><code id="bru_compute_linearisation_+3A_used">used</code></td>
<td>
<p>A <code><a href="#topic+bru_used">bru_used()</a></code> object for the predictor expression</p>
</td></tr>
<tr><td><code id="bru_compute_linearisation_+3A_allow_latent">allow_latent</code></td>
<td>
<p>logical. If <code>TRUE</code>, the latent state of each component is
directly available to the predictor expression, with a <code style="white-space: pre;">&#8288;_latent&#8288;</code> suffix.</p>
</td></tr>
<tr><td><code id="bru_compute_linearisation_+3A_allow_combine">allow_combine</code></td>
<td>
<p>logical; If <code>TRUE</code>, the predictor expression may
involve several rows of the input data to influence the same row.</p>
</td></tr>
<tr><td><code id="bru_compute_linearisation_+3A_eps">eps</code></td>
<td>
<p>The finite difference step size</p>
</td></tr>
<tr><td><code id="bru_compute_linearisation_+3A_lhood">lhood</code></td>
<td>
<p>A <code>bru_like</code> object</p>
</td></tr>
<tr><td><code id="bru_compute_linearisation_+3A_lhoods">lhoods</code></td>
<td>
<p>A <code>bru_like_list</code> object</p>
</td></tr>
</table>

<hr>
<h2 id='bru_convergence_plot'>Plot inlabru convergence diagnostics</h2><span id='topic+bru_convergence_plot'></span>

<h3>Description</h3>

<p>Draws four panels of convergence diagnostics for an iterated INLA method
estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_convergence_plot(x, from = 1, to = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_convergence_plot_+3A_x">x</code></td>
<td>
<p>a <a href="#topic+bru">bru</a> object, typically a result from <code><a href="#topic+bru">bru()</a></code> for a nonlinear
predictor model</p>
</td></tr>
<tr><td><code id="bru_convergence_plot_+3A_from">from</code>, <code id="bru_convergence_plot_+3A_to">to</code></td>
<td>
<p>integer values for the range of iterations to plot.
Default <code>from = 1</code> (start from the first iteration) and <code>to = NULL</code> (end at the last iteration).
Set <code>from = 0</code> to include the initial linearisation point in the track plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Requires the &quot;dplyr&quot;, &quot;ggplot2&quot;, &quot;magrittr&quot;, and &quot;patchwork&quot;
packages to be installed.
</p>


<h3>Value</h3>

<p>A ggplot object with four panels of convergence diagnostics:
</p>

<ul>
<li> <p><code>Tracks</code>: Mode and linearisation values for each effect
</p>
</li>
<li> <p><code>Mode - Lin</code>: Difference between mode and linearisation values for each effect
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;|Change| / sd&#8288;</code>: Absolute change in mode and linearisation values
divided by the standard deviation for each effect
</p>
</li>
<li> <p><code>Change &amp; sd</code>: Absolute change in mode and linearisation values
and standard deviation for each effect
</p>
</li></ul>

<p>For multidimensional components, only the overall average, maximum, and
minimum values are shown.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bru">bru()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit &lt;- bru(...)
bru_convergence_plot(fit)

## End(Not run)
</code></pre>

<hr>
<h2 id='bru_env_get'>Get access to the internal environment</h2><span id='topic+bru_env_get'></span>

<h3>Description</h3>

<p>Get access to the internal environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_env_get()
</code></pre>


<h3>Details</h3>

<p>The environment is defined in 0_inlabru_envir.R which is loaded first.
</p>

<hr>
<h2 id='bru_fill_missing'>Fill in missing values in Spatial grids</h2><span id='topic+bru_fill_missing'></span>

<h3>Description</h3>

<p>Computes nearest-available-value imputation for missing values in space
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_fill_missing(
  data,
  where,
  values,
  layer = NULL,
  selector = NULL,
  batch_size = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_fill_missing_+3A_data">data</code></td>
<td>
<p>A SpatialPointsDataFrame, SpatialPixelsDataFrame,
SpatialGridDataFrame, SpatRaster, Raster, or sf object
containing data to use for filling</p>
</td></tr>
<tr><td><code id="bru_fill_missing_+3A_where">where</code></td>
<td>
<p>A, matrix, data.frame, or SpatialPoints or
SpatialPointsDataFrame, or sf object, containing the locations of the evaluated values</p>
</td></tr>
<tr><td><code id="bru_fill_missing_+3A_values">values</code></td>
<td>
<p>A vector of values to be filled in where <code>is.na(values)</code> is
<code>TRUE</code></p>
</td></tr>
<tr><td><code id="bru_fill_missing_+3A_layer">layer</code>, <code id="bru_fill_missing_+3A_selector">selector</code></td>
<td>
<p>Specifies what data column or columns from which to
extract data, see <code><a href="#topic+component">component()</a></code> for details.</p>
</td></tr>
<tr><td><code id="bru_fill_missing_+3A_batch_size">batch_size</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> due to improved algorithm.
Size of nearest-neighbour calculation blocks, to limit the
memory and computational complexity.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An infilled vector of values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (bru_safe_inla()) {
  points &lt;-
    sp::SpatialPointsDataFrame(
      matrix(1:6, 3, 2),
      data = data.frame(val = c(NA, NA, NA))
    )
  input_coord &lt;- expand.grid(x = 0:7, y = 0:7)
  input &lt;-
    sp::SpatialPixelsDataFrame(
      input_coord,
      data = data.frame(val = as.vector(input_coord$y))
    )
  points$val &lt;- bru_fill_missing(input, points, points$val)
  print(points)

  # To fill in missing values in a grid:
  print(input$val[c(3, 30)])
  input$val[c(3, 30)] &lt;- NA # Introduce missing values
  input$val &lt;- bru_fill_missing(input, input, input$val)
  print(input$val[c(3, 30)])
}

## End(Not run)
</code></pre>

<hr>
<h2 id='bru_forward_transformation'>Transformation tools</h2><span id='topic+bru_forward_transformation'></span><span id='topic+bru_transformation'></span><span id='topic+bru_inverse_transformation'></span>

<h3>Description</h3>

<p>Tools for transforming between N(0,1) variables and other
distributions in predictor expressions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_forward_transformation(qfun, x, ..., tail.split. = 0)

bru_inverse_transformation(pfun, x, ..., tail.split. = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_forward_transformation_+3A_qfun">qfun</code></td>
<td>
<p>A quantile function object, such as <code>qexp</code></p>
</td></tr>
<tr><td><code id="bru_forward_transformation_+3A_x">x</code></td>
<td>
<p>Values to be transformed</p>
</td></tr>
<tr><td><code id="bru_forward_transformation_+3A_...">...</code></td>
<td>
<p>Distribution parameters passed on to the <code>qfun</code> and <code>pfun</code> functions</p>
</td></tr>
<tr><td><code id="bru_forward_transformation_+3A_tail.split.">tail.split.</code></td>
<td>
<p>For x-values larger than <code>tail.split.</code>, upper quantile calculations
are used internally, and for smaller values lower quantile calculations are used. This
can avoid lack of accuracy in the distribution tails. If <code>NULL</code>, forward calculations split at 0,
and inverse calculations use lower tails only, potentially losing accuracy in the upper tails.</p>
</td></tr>
<tr><td><code id="bru_forward_transformation_+3A_pfun">pfun</code></td>
<td>
<p>A CDF function object, such as <code>pexp</code></p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> For <code>bru_forward_transformation</code>, a numeric vector
</p>
</li></ul>


<ul>
<li><p> For <code>bru_inverse_transformation</code>, a numeric vector
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>u &lt;- rnorm(5, 0, 1)
y &lt;- bru_forward_transformation(qexp, u, rate = 2)
v &lt;- bru_inverse_transformation(pexp, y, rate = 2)
rbind(u, y, v)

</code></pre>

<hr>
<h2 id='bru_get_mapper'>Extract mapper information from INLA model component objects</h2><span id='topic+bru_get_mapper'></span><span id='topic+bru_get_mapper.inla.spde'></span><span id='topic+bru_get_mapper.inla.rgeneric'></span><span id='topic+bru_get_mapper_safely'></span>

<h3>Description</h3>

<p>The component definitions will automatically attempt to extract mapper
information from any model object by calling the generic <code>bru_get_mapper</code>.
Any class method implementation should return a <a href="#topic+bru_mapper">bru_mapper</a> object suitable
for the given latent model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_get_mapper(model, ...)

## S3 method for class 'inla.spde'
bru_get_mapper(model, ...)

## S3 method for class 'inla.rgeneric'
bru_get_mapper(model, ...)

bru_get_mapper_safely(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_get_mapper_+3A_model">model</code></td>
<td>
<p>A model component object</p>
</td></tr>
<tr><td><code id="bru_get_mapper_+3A_...">...</code></td>
<td>
<p>Arguments passed on to other methods</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>bru_get_mapper.inla.spde</code> extract an indexed mapper for
the <code>model$mesh</code> object contained in the model object.
It returns <code>NULL</code> gives a warning
if no known mesh type is found in the model object.
</p>
</li></ul>


<ul>
<li> <p><code>bru_get_mapper.inla.rgeneric</code> returns the mapper given by a call to
<code>model$f$rgeneric$definition("mapper")</code>. To support this for your own
<code>inla.rgeneric</code> models, add a <code>"mapper"</code> option to the <code>cmd</code> argument
of your rgeneric definition function. You will need to store the mapper
in your object as well.  Alternative, define your model using a subclass
and define a corresponding <code>bru_get_mapper.subclass</code> method that should return
the corresponding <code>bru_mapper</code> object.
</p>
</li></ul>


<ul>
<li> <p><code>bru_get_mapper_safely</code> tries to call the <code>bru_get_mapper</code>,
and returns <code>NULL</code> if it fails (e.g. due to no available class method).
If the call succeeds and returns non-<code>NULL</code>, it checks that the object
inherits from the <code>bru_mapper</code> class, and gives an error if it does not.
</p>
</li></ul>



<h3>Value</h3>

<p>A <a href="#topic+bru_mapper">bru_mapper</a> object defined by the model component
</p>


<h3>See Also</h3>

<p><a href="#topic+bru_mapper">bru_mapper</a> for mapper constructor methods, and
the individual mappers for specific implementation details.
</p>
<p>Other mappers: 
<code><a href="#topic+bru_mapper">bru_mapper</a>()</code>,
<code><a href="#topic+bru_mapper.fm_mesh_1d">bru_mapper.fm_mesh_1d</a>()</code>,
<code><a href="#topic+bru_mapper.fm_mesh_2d">bru_mapper.fm_mesh_2d</a>()</code>,
<code><a href="#topic+bru_mapper_aggregate">bru_mapper_aggregate</a>()</code>,
<code><a href="#topic+bru_mapper_collect">bru_mapper_collect</a>()</code>,
<code><a href="#topic+bru_mapper_const">bru_mapper_const</a>()</code>,
<code><a href="#topic+bru_mapper_factor">bru_mapper_factor</a>()</code>,
<code><a href="#topic+bru_mapper_generics">bru_mapper_generics</a></code>,
<code><a href="#topic+bru_mapper_harmonics">bru_mapper_harmonics</a>()</code>,
<code><a href="#topic+bru_mapper_index">bru_mapper_index</a>()</code>,
<code><a href="#topic+bru_mapper_linear">bru_mapper_linear</a>()</code>,
<code><a href="#topic+bru_mapper_logsumexp">bru_mapper_logsumexp</a>()</code>,
<code><a href="#topic+bru_mapper_marginal">bru_mapper_marginal</a>()</code>,
<code><a href="#topic+bru_mapper_matrix">bru_mapper_matrix</a>()</code>,
<code><a href="#topic+bru_mapper_mesh_B">bru_mapper_mesh_B</a>()</code>,
<code><a href="#topic+bru_mapper_multi">bru_mapper_multi</a>()</code>,
<code><a href="#topic+bru_mapper_pipe">bru_mapper_pipe</a>()</code>,
<code><a href="#topic+bru_mapper_scale">bru_mapper_scale</a>()</code>,
<code><a href="#topic+bru_mapper_shift">bru_mapper_shift</a>()</code>,
<code><a href="#topic+bru_mapper_taylor">bru_mapper_taylor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (bru_safe_inla(quietly = TRUE)) {
  library(INLA)
  mesh &lt;- fmesher::fm_rcdt_2d_inla(globe = 2)
  spde &lt;- inla.spde2.pcmatern(mesh,
    prior.range = c(1, 0.5),
    prior.sigma = c(1, 0.5)
  )
  mapper &lt;- bru_get_mapper(spde)
  ibm_n(mapper)
}
</code></pre>

<hr>
<h2 id='bru_inla.stack.mexpand'>Backwards compatibility to handle mexpand for INLA &lt;= 24.06.02</h2><span id='topic+bru_inla.stack.mexpand'></span>

<h3>Description</h3>

<p>Expand observation vectors/matrices in stacks into to a multicolumn matrix for multiple likelihoods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_inla.stack.mexpand(
  ...,
  old.names = "BRU.response",
  new.name = "BRU.response"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_inla.stack.mexpand_+3A_...">...</code></td>
<td>
<p>List of stacks that contain vector observations
(existing multilikelihood observation matrices are also permitted)</p>
</td></tr>
<tr><td><code id="bru_inla.stack.mexpand_+3A_old.names">old.names</code></td>
<td>
<p>A vector of strings with the names of the observation vector/matrix for each stack.
If a single string, this is assumed for all the stacks. (default &quot;BRU.response&quot;)</p>
</td></tr>
<tr><td><code id="bru_inla.stack.mexpand_+3A_new.name">new.name</code></td>
<td>
<p>The name to be used for the expanded observation matrix,
possibly the same as an old name. (default &quot;BRU.response&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of modified stacks with multicolumn observations
</p>


<h3>Author(s)</h3>

<p>Fabian E. Bachl <a href="mailto:f.e.bachl@bath.ac.uk">f.e.bachl@bath.ac.uk</a> and Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>

<hr>
<h2 id='bru_inla.stack.mjoin'>Join stacks intended to be run with different likelihoods</h2><span id='topic+bru_inla.stack.mjoin'></span>

<h3>Description</h3>

<p>Helper functions for multi-likelihood models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_inla.stack.mjoin(
  ...,
  compress = TRUE,
  remove.unused = TRUE,
  old.names = "BRU.response",
  new.name = "BRU.response"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_inla.stack.mjoin_+3A_...">...</code></td>
<td>
<p>List of stacks that contain vector observations
(existing multi-likelihood observation matrices are also permitted)</p>
</td></tr>
<tr><td><code id="bru_inla.stack.mjoin_+3A_compress">compress</code></td>
<td>
<p>If <code>TRUE</code>, compress the model by removing duplicated rows of
effects, replacing the corresponding A-matrix columns with a single column
containing the sum.</p>
</td></tr>
<tr><td><code id="bru_inla.stack.mjoin_+3A_remove.unused">remove.unused</code></td>
<td>
<p>If <code>TRUE</code>, compress the model by removing rows of
effects corresponding to all-zero columns in the A matrix (and removing those columns).</p>
</td></tr>
<tr><td><code id="bru_inla.stack.mjoin_+3A_old.names">old.names</code></td>
<td>
<p>A vector of strings with the names of the observation
vector/matrix for each stack.
If a single string, this is assumed for all the stacks. (default &quot;BRU.response&quot;)</p>
</td></tr>
<tr><td><code id="bru_inla.stack.mjoin_+3A_new.name">new.name</code></td>
<td>
<p>The name to be used for the expanded observation matrix,
possibly the same as an old name. (default &quot;BRU.response&quot;)</p>
</td></tr>
</table>

<hr>
<h2 id='bru_int_polygon'>Integration points for polygons inside an inla.mesh</h2><span id='topic+bru_int_polygon'></span>

<h3>Description</h3>

<p>Integration points for polygons inside an inla.mesh
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_int_polygon(mesh, method = NULL, samplers = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_int_polygon_+3A_mesh">mesh</code></td>
<td>
<p>An inla.mesh object</p>
</td></tr>
<tr><td><code id="bru_int_polygon_+3A_method">method</code></td>
<td>
<p>Which integration method to use (&quot;stable&quot;,
with aggregation to mesh vertices, or &quot;direct&quot;)</p>
</td></tr>
<tr><td><code id="bru_int_polygon_+3A_samplers">samplers</code></td>
<td>
<p>If non-NULL, a SpatialPolygons* object</p>
</td></tr>
<tr><td><code id="bru_int_polygon_+3A_...">...</code></td>
<td>
<p>Arguments passed to the low level integration method (<code>make_triangle_integration</code>)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>

<hr>
<h2 id='bru_like_inla_family'>Utility functions for bru likelihood objects</h2><span id='topic+bru_like_inla_family'></span><span id='topic+bru_like_inla_family.bru_like'></span><span id='topic+bru_like_inla_family.bru_like_list'></span><span id='topic+bru_like_control_family'></span><span id='topic+bru_like_control_family.bru_like'></span><span id='topic+bru_like_control_family.bru_like_list'></span>

<h3>Description</h3>

<p>Utility functions for bru likelihood objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_like_inla_family(x, ...)

## S3 method for class 'bru_like'
bru_like_inla_family(x, ...)

## S3 method for class 'bru_like_list'
bru_like_inla_family(x, ...)

bru_like_control_family(x, control.family = NULL, ...)

## S3 method for class 'bru_like'
bru_like_control_family(x, control.family = NULL, ...)

## S3 method for class 'bru_like_list'
bru_like_control_family(x, control.family = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_like_inla_family_+3A_x">x</code></td>
<td>
<p>Object of <code>bru_like</code> or <code>bru_like_list</code> type</p>
</td></tr>
<tr><td><code id="bru_like_inla_family_+3A_control.family">control.family</code></td>
<td>
<p>list of INLA <code>control.family</code> options to override</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>bru_like_inla_family()</code> returns a string or vector of strings
</p>
</li></ul>


<ul>
<li> <p><code>bru_like_control_family()</code> returns a list with <code>INLA::control.family</code> options,
or a list of such lists, with one element per observation model
</p>
</li></ul>


<hr>
<h2 id='bru_log'>Access methods for <code>bru_log</code> objects</h2><span id='topic+bru_log'></span><span id='topic+bru_log.character'></span><span id='topic+bru_log.bru_log'></span><span id='topic+bru_log.iinla'></span><span id='topic+bru_log.bru'></span><span id='topic+print.bru_log'></span><span id='topic+as.character.bru_log'></span><span id='topic++5B.bru_log'></span><span id='topic+c.bru_log'></span><span id='topic+length.bru_log'></span>

<h3>Description</h3>

<p>Access method for <code>bru_log</code> objects.
Note: Up to version <code style="white-space: pre;">&#8288;2.8.0&#8288;</code>, <code>bru_log()</code> was a deprecated alias for <code>bru_log_message()</code>.
When running on <code style="white-space: pre;">&#8288;2.8.0&#8288;</code> or earlier, use <code>bru_log_get()</code> to access the global
log, and <code>cat(fit$bru_iinla$log, sep = "\n")</code> to print a stored estimation object log.
After version <code style="white-space: pre;">&#8288;2.8.0&#8288;</code>, use <code>bru_log()</code> to access the global log, and
<code>bru_log(fit)</code> to access a stored estimation log.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_log(x = NULL, verbosity = NULL)

## S3 method for class 'character'
bru_log(x, verbosity = NULL)

## S3 method for class 'bru_log'
bru_log(x, verbosity = NULL)

## S3 method for class 'iinla'
bru_log(x, verbosity = NULL)

## S3 method for class 'bru'
bru_log(x, verbosity = NULL)

## S3 method for class 'bru_log'
print(x, ..., timestamp = TRUE, verbosity = FALSE)

## S3 method for class 'bru_log'
as.character(x, ...)

## S3 method for class 'bru_log'
x[i]

## S3 method for class 'bru_log'
c(...)

## S3 method for class 'bru_log'
length(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_log_+3A_x">x</code></td>
<td>
<p>An object that is, contains, or can be converted to,
a <code>bru_log</code> object. If <code>NULL</code>, refers to the global <code>inlabru</code> log.</p>
</td></tr>
<tr><td><code id="bru_log_+3A_verbosity">verbosity</code></td>
<td>
<p>integer value for limiting the highest verbosity level being returned.</p>
</td></tr>
<tr><td><code id="bru_log_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="bru_log_+3A_timestamp">timestamp</code></td>
<td>
<p>If <code>TRUE</code>, include the timestamp of each message. Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="bru_log_+3A_i">i</code></td>
<td>
<p>indices specifying elements to extract. If <code>character</code>, denotes
the sequence between bookmark <code>i</code> and the next bookmark (or the end of the
log if <code>i</code> is the last bookmark)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>bru_log</code> A <code>bru_log</code> object, containing a
character vector of log messages, and potentially a vector of bookmarks.
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>print(bru_log)</code>: Print a <code>bru_log</code> object with <code>cat(x, sep = "\n")</code>.
If <code>verbosity</code> is <code>TRUE</code>, include the verbosity level of each message.
</p>
</li>
<li> <p><code>as.character(bru_log)</code>: Convert <code>bru_log</code> object to a plain <code>character</code> vector
</p>
</li>
<li> <p><code>[</code>: Extract a subset of a <code>bru_log</code> object
</p>
</li>
<li> <p><code>c(bru_log)</code>: Concatenate several <code>bru_log</code> or <code>character</code> objects
into a <code>bru_log</code> object.
</p>
</li>
<li> <p><code>length(bru_log)</code>: Obtain the number of log entries
into a <code>bru_log</code> object.
</p>
</li></ul>


<h3>Functions</h3>


<ul>
<li> <p><code>bru_log()</code>: Extract stored log messages. If non-<code>NULL</code>, the <code>verbosity</code> argument
determines the maximum verbosity level of the messages to extract.
</p>
</li></ul>


<h3>See Also</h3>

<p>Other inlabru log methods: 
<code><a href="#topic+bru_log_bookmark">bru_log_bookmark</a>()</code>,
<code><a href="#topic+bru_log_message">bru_log_message</a>()</code>,
<code><a href="#topic+bru_log_new">bru_log_new</a>()</code>,
<code><a href="#topic+bru_log_offset">bru_log_offset</a>()</code>,
<code><a href="#topic+bru_log_reset">bru_log_reset</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bru_log(verbosity = 2L)
print(bru_log(), timestamp = TRUE, verbosity = TRUE)

</code></pre>

<hr>
<h2 id='bru_log_bookmark'>Methods for <code>bru_log</code> bookmarks</h2><span id='topic+bru_log_bookmark'></span><span id='topic+bru_log_bookmarks'></span>

<h3>Description</h3>

<p>Methods for <code>bru_log</code> bookmarks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_log_bookmark(bookmark = "", offset = NULL, x = NULL)

bru_log_bookmarks(x = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_log_bookmark_+3A_bookmark">bookmark</code></td>
<td>
<p>character; The label for a bookmark with a stored offset.</p>
</td></tr>
<tr><td><code id="bru_log_bookmark_+3A_offset">offset</code></td>
<td>
<p>integer; a position offset in the log, with <code>0L</code> pointing at
the start of the log. If negative, denotes the point <code>abs(offset)</code> elements
from tail of the log. When <code>bookmark</code> is non-NULL, the <code>offset</code> applies a
shift (forwards or backwards) to the bookmark list.</p>
</td></tr>
<tr><td><code id="bru_log_bookmark_+3A_x">x</code></td>
<td>
<p>A <code>bru_log</code> object. If <code>NULL</code>, the global <code>inlabru</code> log is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>bru_log_bookmark()</code>: Returns the modified <code>bru_log</code> object if <code>x</code> is non-NULL.
</p>
<p><code>bru_log_bookmarks()</code>: Returns the bookmark vector associated with <code>x</code>
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>bru_log_bookmark()</code>: Set a log bookmark. If <code>offset</code> is <code>NULL</code> (the default),
the bookmark will point to the current end of the log.
</p>
</li>
<li> <p><code>bru_log_bookmarks()</code>: Return a integer vector with named elements being
bookmarks into the global <code>inlabru</code> log with associated log
position offsets.
</p>
</li></ul>


<h3>See Also</h3>

<p>Other inlabru log methods: 
<code><a href="#topic+bru_log">bru_log</a>()</code>,
<code><a href="#topic+bru_log_message">bru_log_message</a>()</code>,
<code><a href="#topic+bru_log_new">bru_log_new</a>()</code>,
<code><a href="#topic+bru_log_offset">bru_log_offset</a>()</code>,
<code><a href="#topic+bru_log_reset">bru_log_reset</a>()</code>
</p>

<hr>
<h2 id='bru_log_message'>Add a log message</h2><span id='topic+bru_log_message'></span>

<h3>Description</h3>

<p>Adds a log message.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_log_message(
  ...,
  domain = NULL,
  appendLF = TRUE,
  verbosity = 1L,
  allow_verbose = TRUE,
  verbose = NULL,
  verbose_store = NULL,
  x = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_log_message_+3A_...">...</code></td>
<td>
<p>For <code>bru_log_message()</code>, zero or more objects passed on to
<code><a href="base.html#topic+message">base::.makeMessage()</a></code></p>
</td></tr>
<tr><td><code id="bru_log_message_+3A_domain">domain</code></td>
<td>
<p>Domain for translations, passed on to <code><a href="base.html#topic+message">base::.makeMessage()</a></code></p>
</td></tr>
<tr><td><code id="bru_log_message_+3A_appendlf">appendLF</code></td>
<td>
<p>logical; whether to add a newline to the message. Only
used for verbose output.</p>
</td></tr>
<tr><td><code id="bru_log_message_+3A_verbosity">verbosity</code></td>
<td>
<p>numeric value describing the verbosity level of the message</p>
</td></tr>
<tr><td><code id="bru_log_message_+3A_allow_verbose">allow_verbose</code></td>
<td>
<p>Whether to allow verbose output. Must be set to FALSE
until the options object has been initialised.</p>
</td></tr>
<tr><td><code id="bru_log_message_+3A_verbose">verbose</code></td>
<td>
<p>logical, numeric, or <code>NULL</code>; local override for verbose
output. If <code>NULL</code>, the global option <code>bru_verbose</code> or default value is used.
If <code>FALSE</code>, no messages are printed. If <code>TRUE</code>, messages with <code>verbosity</code>
<code class="reqn">\le 1</code>
are printed. If numeric, messages with <code>verbosity</code> <code class="reqn">\le</code> <code>verbose</code> are
printed.</p>
</td></tr>
<tr><td><code id="bru_log_message_+3A_verbose_store">verbose_store</code></td>
<td>
<p>Same as <code>verbose</code>, but controlling what messages are
stored in the global log object. Can be controlled via the <code>bru_verbose_store</code>
with <code><a href="#topic+bru_options_set">bru_options_set()</a></code>.</p>
</td></tr>
<tr><td><code id="bru_log_message_+3A_x">x</code></td>
<td>
<p>A <code>bru_log</code> object. If <code>NULL</code>, refers to the global <code>inlabru</code> log.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>bru_log_message</code> returns <code>invisible(x)</code>, where <code>x</code> is the updated <code>bru_log</code>
object, or <code>NULL</code>.
</p>


<h3>See Also</h3>

<p>Other inlabru log methods: 
<code><a href="#topic+bru_log">bru_log</a>()</code>,
<code><a href="#topic+bru_log_bookmark">bru_log_bookmark</a>()</code>,
<code><a href="#topic+bru_log_new">bru_log_new</a>()</code>,
<code><a href="#topic+bru_log_offset">bru_log_offset</a>()</code>,
<code><a href="#topic+bru_log_reset">bru_log_reset</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
  code_runner &lt;- function() {
    local_bru_options_set(
      # Show messages up to and including level 2 (default 0)
      bru_verbose = 2,
      # Store messages to an including level 3 (default Inf, storing all)
      bru_verbose_store = 3
    )

    bru_log_bookmark("bookmark 1")
    bru_log_message("Test message 1", verbosity = 1)
    bru_log_message("Test message 2", verbosity = 2)
    bru_log_bookmark("bookmark 2")
    bru_log_message("Test message 3", verbosity = 3)
    bru_log_message("Test message 4", verbosity = 4)

    invisible()
  }
  message("Run code")
  code_runner()
  message("Check log from bookmark 1")
  print(bru_log()["bookmark 1"])
  message("Check log from bookmark 2")
  print(bru_log()["bookmark 2"])
}
</code></pre>

<hr>
<h2 id='bru_log_new'>Create a <code>bru_log</code> object</h2><span id='topic+bru_log_new'></span>

<h3>Description</h3>

<p>Create a <code>bru_log</code> object, by default empty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_log_new(x = NULL, bookmarks = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_log_new_+3A_x">x</code></td>
<td>
<p>An optional character vector of log messages, or <code>data.frame</code>
with columns <code>message</code>, <code>timestamp</code>, and <code>verbosity</code>.</p>
</td></tr>
<tr><td><code id="bru_log_new_+3A_bookmarks">bookmarks</code></td>
<td>
<p>An optional <code>integer</code> vector of named bookmarks
message in <code>x</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other inlabru log methods: 
<code><a href="#topic+bru_log">bru_log</a>()</code>,
<code><a href="#topic+bru_log_bookmark">bru_log_bookmark</a>()</code>,
<code><a href="#topic+bru_log_message">bru_log_message</a>()</code>,
<code><a href="#topic+bru_log_offset">bru_log_offset</a>()</code>,
<code><a href="#topic+bru_log_reset">bru_log_reset</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- bru_log_new()
x &lt;- bru_log_message("Test message", x = x)
print(x)
</code></pre>

<hr>
<h2 id='bru_log_offset'>Position methods for <code>bru_log</code> objects</h2><span id='topic+bru_log_offset'></span><span id='topic+bru_log_index'></span>

<h3>Description</h3>

<p>Position methods for <code>bru_log</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_log_offset(x = NULL, bookmark = NULL, offset = NULL)

bru_log_index(x = NULL, i, verbosity = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_log_offset_+3A_x">x</code></td>
<td>
<p>A <code>bru_log</code> object. If <code>NULL</code>, the global <code>inlabru</code> log is used.</p>
</td></tr>
<tr><td><code id="bru_log_offset_+3A_bookmark">bookmark</code></td>
<td>
<p>character; The label for a bookmark with a stored offset.</p>
</td></tr>
<tr><td><code id="bru_log_offset_+3A_offset">offset</code></td>
<td>
<p>integer; a position offset in the log, with <code>0L</code> pointing at
the start of the log. If negative, denotes the point <code>abs(offset)</code> elements
from tail of the log. When <code>bookmark</code> is non-NULL, the <code>offset</code> applies a
shift (forwards or backwards) to the bookmark list.</p>
</td></tr>
<tr><td><code id="bru_log_offset_+3A_i">i</code></td>
<td>
<p>indices specifying elements to extract. If <code>character</code>, denotes
the sequence between bookmark <code>i</code> and the next bookmark (or the end of the
log if <code>i</code> is the last bookmark)</p>
</td></tr>
<tr><td><code id="bru_log_offset_+3A_verbosity">verbosity</code></td>
<td>
<p>integer value for limiting the highest verbosity level being returned.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>bru_log_offset()</code>: Utility function for computing log position offsets.
</p>
</li>
<li> <p><code>bru_log_index()</code>: Utility function for computing index vectors
for <code>bru_log</code> objects.
</p>
</li></ul>


<h3>See Also</h3>

<p>Other inlabru log methods: 
<code><a href="#topic+bru_log">bru_log</a>()</code>,
<code><a href="#topic+bru_log_bookmark">bru_log_bookmark</a>()</code>,
<code><a href="#topic+bru_log_message">bru_log_message</a>()</code>,
<code><a href="#topic+bru_log_new">bru_log_new</a>()</code>,
<code><a href="#topic+bru_log_reset">bru_log_reset</a>()</code>
</p>

<hr>
<h2 id='bru_log_reset'>Clear log contents</h2><span id='topic+bru_log_reset'></span>

<h3>Description</h3>

<p>Clears the log contents up to
a given <code>offset</code> or <code>bookmark</code>. Default: clear the entire log.
When <code>x</code> is NULL, the global <code>inlabru</code> log is updated, and <code>invisible(NULL)</code>
is returned. Otherwise the updated object is returned (invisibly).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_log_reset(x = NULL, bookmark = NULL, offset = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_log_reset_+3A_x">x</code></td>
<td>
<p>A <code>bru_log</code> object, or in some cases, and object that can be
converted/extracted to a <code>bru_log</code> object. <code>NULL</code> denotes the global
<code>inlabru</code> log object.</p>
</td></tr>
<tr><td><code id="bru_log_reset_+3A_bookmark">bookmark</code></td>
<td>
<p>character; The label for a bookmark with a stored offset.</p>
</td></tr>
<tr><td><code id="bru_log_reset_+3A_offset">offset</code></td>
<td>
<p>integer; a position offset in the log, with <code>0L</code> pointing at
the start of the log. If negative, denotes the point <code>abs(offset)</code> elements
from tail of the log. When <code>bookmark</code> is non-NULL, the <code>offset</code> applies a
shift (forwards or backwards) to the bookmark list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns (invisibly) the modified <code>bru_log</code> object, or <code>NULL</code> (when <code>x</code> is <code>NULL</code>)
</p>


<h3>See Also</h3>

<p>Other inlabru log methods: 
<code><a href="#topic+bru_log">bru_log</a>()</code>,
<code><a href="#topic+bru_log_bookmark">bru_log_bookmark</a>()</code>,
<code><a href="#topic+bru_log_message">bru_log_message</a>()</code>,
<code><a href="#topic+bru_log_new">bru_log_new</a>()</code>,
<code><a href="#topic+bru_log_offset">bru_log_offset</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (interactive()) {
  bru_log_reset()
}

## End(Not run)
</code></pre>

<hr>
<h2 id='bru_make_stack'>Build an inla data stack from linearisation information</h2><span id='topic+bru_make_stack'></span><span id='topic+bru_make_stack.bru_like'></span><span id='topic+bru_make_stack.bru_like_list'></span>

<h3>Description</h3>

<p>Combine linearisation for multiple likelihoods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_make_stack(...)

## S3 method for class 'bru_like'
bru_make_stack(lhood, lin, idx, ..., family_index = 1L)

## S3 method for class 'bru_like_list'
bru_make_stack(lhoods, lin, idx, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_make_stack_+3A_...">...</code></td>
<td>
<p>Arguments passed on to other methods</p>
</td></tr>
<tr><td><code id="bru_make_stack_+3A_lhood">lhood</code></td>
<td>
<p>A <code>bru_like</code> object</p>
</td></tr>
<tr><td><code id="bru_make_stack_+3A_lin">lin</code></td>
<td>
<p>Linearisation information
</p>

<ul>
<li><p> For <code>.bru_like</code>, a <code>bru_mapper_taylor</code> object
</p>
</li>
<li><p> For <code>.bru_like_list</code>, a list of <code>bru_mapper_taylor</code> objects
</p>
</li></ul>
</td></tr>
<tr><td><code id="bru_make_stack_+3A_idx">idx</code></td>
<td>
<p>Output from <code>evaluate_index(...)</code></p>
</td></tr>
<tr><td><code id="bru_make_stack_+3A_family_index">family_index</code></td>
<td>
<p>integer specifying the family sequence index of the observation model</p>
</td></tr>
<tr><td><code id="bru_make_stack_+3A_lhoods">lhoods</code></td>
<td>
<p>A <code>bru_like_list</code> object</p>
</td></tr>
</table>

<hr>
<h2 id='bru_mapper'>Constructors for <code>bru_mapper</code> objects</h2><span id='topic+bru_mapper'></span><span id='topic+bru_mapper_define'></span>

<h3>Description</h3>

<p>Constructors for <code>bru_mapper</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_mapper(...)

bru_mapper_define(mapper, new_class = NULL, ..., methods = deprecated())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_mapper_+3A_...">...</code></td>
<td>
<p>Arguments passed on to sub-methods, or used for special purposes,
see details for each function below.</p>
</td></tr>
<tr><td><code id="bru_mapper_+3A_mapper">mapper</code></td>
<td>
<p>For <code>bru_mapper_define</code>, a prototype mapper object, see Details.
For <code>bru_mapper_scale</code>, a mapper to be scaled.</p>
</td></tr>
<tr><td><code id="bru_mapper_+3A_new_class">new_class</code></td>
<td>
<p>If non-<code>NULL</code>, this is added at the front of the class definition</p>
</td></tr>
<tr><td><code id="bru_mapper_+3A_methods">methods</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Deprecated.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>bru_mapper()</code> returns a <code>bru_mapper</code> object
</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>bru_mapper()</code>: Generic mapper S3 constructor, used for constructing
mappers for special objects. See below for details of the
default constructor <code><a href="#topic+bru_mapper_define">bru_mapper_define()</a></code> that can be used to define
new mappers in user code.
</p>
</li>
<li> <p><code>bru_mapper_define()</code>: Adds the <code>new_class</code> and &quot;bru_mapper&quot; class
names to the inheritance list for the input <code>mapper</code> object, unless the object
already inherits from these.
</p>
<p>To register mapper classes and methods in scripts, use <code>.S3method()</code>
to register the methods, e.g.
<code>.S3method("ibm_jacobian", "my_mapper_class", ibm_jacobian.my_mapper_class)</code>.
</p>
<p>In packages with <code>Suggests: inlabru</code>, add method information for delayed
registration, e.g.:
</p>
<div class="sourceCode"><pre>#' @rawNamespace S3method(inlabru::bru_get_mapper, inla_rspde)
#' @rawNamespace S3method(inlabru::ibm_n, bru_mapper_inla_rspde)
#' @rawNamespace S3method(inlabru::ibm_values, bru_mapper_inla_rspde)
#' @rawNamespace S3method(inlabru::ibm_jacobian, bru_mapper_inla_rspde)
</pre></div>
<p>or before each method, use <code style="white-space: pre;">&#8288;@exportS3Method&#8288;</code>:
</p>
<div class="sourceCode"><pre>#' @exportS3Method inlabru::bru_get_mapper
</pre></div>
<p>etc., which semi-automates it.
</p>
</li></ul>


<h3>See Also</h3>

<p><a href="#topic+bru_mapper_generics">bru_mapper_generics</a> for generic methods,
the individual mapper pages for special method implementations, and
<a href="#topic+bru_get_mapper">bru_get_mapper</a> for hooks to extract mappers from latent model object
class objects.
</p>
<p>Other mappers: 
<code><a href="#topic+bru_get_mapper">bru_get_mapper</a>()</code>,
<code><a href="#topic+bru_mapper.fm_mesh_1d">bru_mapper.fm_mesh_1d</a>()</code>,
<code><a href="#topic+bru_mapper.fm_mesh_2d">bru_mapper.fm_mesh_2d</a>()</code>,
<code><a href="#topic+bru_mapper_aggregate">bru_mapper_aggregate</a>()</code>,
<code><a href="#topic+bru_mapper_collect">bru_mapper_collect</a>()</code>,
<code><a href="#topic+bru_mapper_const">bru_mapper_const</a>()</code>,
<code><a href="#topic+bru_mapper_factor">bru_mapper_factor</a>()</code>,
<code><a href="#topic+bru_mapper_generics">bru_mapper_generics</a></code>,
<code><a href="#topic+bru_mapper_harmonics">bru_mapper_harmonics</a>()</code>,
<code><a href="#topic+bru_mapper_index">bru_mapper_index</a>()</code>,
<code><a href="#topic+bru_mapper_linear">bru_mapper_linear</a>()</code>,
<code><a href="#topic+bru_mapper_logsumexp">bru_mapper_logsumexp</a>()</code>,
<code><a href="#topic+bru_mapper_marginal">bru_mapper_marginal</a>()</code>,
<code><a href="#topic+bru_mapper_matrix">bru_mapper_matrix</a>()</code>,
<code><a href="#topic+bru_mapper_mesh_B">bru_mapper_mesh_B</a>()</code>,
<code><a href="#topic+bru_mapper_multi">bru_mapper_multi</a>()</code>,
<code><a href="#topic+bru_mapper_pipe">bru_mapper_pipe</a>()</code>,
<code><a href="#topic+bru_mapper_scale">bru_mapper_scale</a>()</code>,
<code><a href="#topic+bru_mapper_shift">bru_mapper_shift</a>()</code>,
<code><a href="#topic+bru_mapper_taylor">bru_mapper_taylor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mapper &lt;- bru_mapper_index(5)
ibm_jacobian(mapper, input = c(1, 3, 4, 5, 2))
</code></pre>

<hr>
<h2 id='bru_mapper_aggregate'>Mapper for aggregation</h2><span id='topic+bru_mapper_aggregate'></span><span id='topic+ibm_n.bru_mapper_aggregate'></span><span id='topic+ibm_n_output.bru_mapper_aggregate'></span><span id='topic+ibm_values.bru_mapper_aggregate'></span><span id='topic+ibm_jacobian.bru_mapper_aggregate'></span><span id='topic+ibm_eval.bru_mapper_aggregate'></span>

<h3>Description</h3>

<p>Constructs a mapper
that aggregates elements of the input state, so it can be used e.g.
for weighted summation or integration over blocks of values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_mapper_aggregate(rescale = FALSE, n_block = NULL)

## S3 method for class 'bru_mapper_aggregate'
ibm_n(mapper, ..., input = NULL, state = NULL, n_state = NULL)

## S3 method for class 'bru_mapper_aggregate'
ibm_n_output(mapper, input = NULL, ...)

## S3 method for class 'bru_mapper_aggregate'
ibm_values(mapper, ..., state = NULL, n_state = NULL)

## S3 method for class 'bru_mapper_aggregate'
ibm_jacobian(mapper, input, state = NULL, ...)

## S3 method for class 'bru_mapper_aggregate'
ibm_eval(mapper, input, state = NULL, ..., sub_lin = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_mapper_aggregate_+3A_rescale">rescale</code></td>
<td>
<p>logical; For <code>bru_mapper_aggregate</code> and <code>bru_mapper_logsumexp</code>,
specifies if the blockwise sums should be normalised by the blockwise weight
sums or not:
</p>

<ul>
<li> <p><code>FALSE</code>: (default) Straight weighted sum, no rescaling.
</p>
</li>
<li> <p><code>TRUE</code>: Divide by the sum of the weight values within each block.
This is useful for integration averages, when the given weights are plain
integration weights. If the weights are <code>NULL</code> or all ones, this is
the same as dividing by the number of entries in each block.
</p>
</li></ul>
</td></tr>
<tr><td><code id="bru_mapper_aggregate_+3A_n_block">n_block</code></td>
<td>
<p>Predetermined number of output blocks. If <code>NULL</code>, overrides
the maximum block index in the inputs.</p>
</td></tr>
<tr><td><code id="bru_mapper_aggregate_+3A_mapper">mapper</code></td>
<td>
<p>A mapper S3 object, inheriting from <code>bru_mapper</code>.</p>
</td></tr>
<tr><td><code id="bru_mapper_aggregate_+3A_...">...</code></td>
<td>
<p>Arguments passed on to other methods</p>
</td></tr>
<tr><td><code id="bru_mapper_aggregate_+3A_input">input</code></td>
<td>
<p>Data input for the mapper.</p>
</td></tr>
<tr><td><code id="bru_mapper_aggregate_+3A_state">state</code></td>
<td>
<p>A vector of latent state values for the mapping,
of length <code>ibm_n(mapper, inla_f = FALSE)</code></p>
</td></tr>
<tr><td><code id="bru_mapper_aggregate_+3A_n_state">n_state</code></td>
<td>
<p>integer giving the length of the state vector for mappers
that have state dependent output size.</p>
</td></tr>
<tr><td><code id="bru_mapper_aggregate_+3A_sub_lin">sub_lin</code></td>
<td>
<p>Internal, optional pre-computed sub-mapper information</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> For <code>bru_mapper_aggregate</code>, <code>input</code> should be a list with elements <code>block</code>
and <code>weights</code>. <code>block</code>
should be a vector of the same length as the <code>state</code>, or <code>NULL</code>, with <code>NULL</code>
equivalent to all-1.
If <code>weights</code> is <code>NULL</code>, it's interpreted as all-1.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+bru_mapper">bru_mapper</a>, <a href="#topic+bru_mapper_generics">bru_mapper_generics</a>
</p>
<p>Other mappers: 
<code><a href="#topic+bru_get_mapper">bru_get_mapper</a>()</code>,
<code><a href="#topic+bru_mapper">bru_mapper</a>()</code>,
<code><a href="#topic+bru_mapper.fm_mesh_1d">bru_mapper.fm_mesh_1d</a>()</code>,
<code><a href="#topic+bru_mapper.fm_mesh_2d">bru_mapper.fm_mesh_2d</a>()</code>,
<code><a href="#topic+bru_mapper_collect">bru_mapper_collect</a>()</code>,
<code><a href="#topic+bru_mapper_const">bru_mapper_const</a>()</code>,
<code><a href="#topic+bru_mapper_factor">bru_mapper_factor</a>()</code>,
<code><a href="#topic+bru_mapper_generics">bru_mapper_generics</a></code>,
<code><a href="#topic+bru_mapper_harmonics">bru_mapper_harmonics</a>()</code>,
<code><a href="#topic+bru_mapper_index">bru_mapper_index</a>()</code>,
<code><a href="#topic+bru_mapper_linear">bru_mapper_linear</a>()</code>,
<code><a href="#topic+bru_mapper_logsumexp">bru_mapper_logsumexp</a>()</code>,
<code><a href="#topic+bru_mapper_marginal">bru_mapper_marginal</a>()</code>,
<code><a href="#topic+bru_mapper_matrix">bru_mapper_matrix</a>()</code>,
<code><a href="#topic+bru_mapper_mesh_B">bru_mapper_mesh_B</a>()</code>,
<code><a href="#topic+bru_mapper_multi">bru_mapper_multi</a>()</code>,
<code><a href="#topic+bru_mapper_pipe">bru_mapper_pipe</a>()</code>,
<code><a href="#topic+bru_mapper_scale">bru_mapper_scale</a>()</code>,
<code><a href="#topic+bru_mapper_shift">bru_mapper_shift</a>()</code>,
<code><a href="#topic+bru_mapper_taylor">bru_mapper_taylor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- bru_mapper_aggregate()
ibm_eval2(m, list(block = c(1, 2, 1, 2), weights = 1:4), 11:14)

</code></pre>

<hr>
<h2 id='bru_mapper_collect'>Mapper for concatenated variables</h2><span id='topic+bru_mapper_collect'></span><span id='topic+ibm_n.bru_mapper_collect'></span><span id='topic+ibm_n_output.bru_mapper_collect'></span><span id='topic+ibm_values.bru_mapper_collect'></span><span id='topic+ibm_is_linear.bru_mapper_collect'></span><span id='topic+ibm_jacobian.bru_mapper_collect'></span><span id='topic+ibm_eval.bru_mapper_collect'></span><span id='topic+ibm_linear.bru_mapper_collect'></span><span id='topic+ibm_invalid_output.bru_mapper_collect'></span><span id='topic++5B.bru_mapper_collect'></span><span id='topic+ibm_names.bru_mapper_collect'></span><span id='topic+ibm_names+3C-.bru_mapper_collect'></span>

<h3>Description</h3>

<p>Constructs a concatenated collection mapping
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_mapper_collect(mappers, hidden = FALSE)

## S3 method for class 'bru_mapper_collect'
ibm_n(mapper, inla_f = FALSE, multi = FALSE, ...)

## S3 method for class 'bru_mapper_collect'
ibm_n_output(mapper, input, state = NULL, inla_f = FALSE, multi = FALSE, ...)

## S3 method for class 'bru_mapper_collect'
ibm_values(mapper, inla_f = FALSE, multi = FALSE, ...)

## S3 method for class 'bru_mapper_collect'
ibm_is_linear(mapper, inla_f = FALSE, multi = FALSE, ...)

## S3 method for class 'bru_mapper_collect'
ibm_jacobian(
  mapper,
  input,
  state = NULL,
  inla_f = FALSE,
  multi = FALSE,
  ...,
  sub_lin = NULL
)

## S3 method for class 'bru_mapper_collect'
ibm_eval(
  mapper,
  input,
  state,
  inla_f = FALSE,
  multi = FALSE,
  ...,
  sub_lin = NULL
)

## S3 method for class 'bru_mapper_collect'
ibm_linear(mapper, input, state, inla_f = FALSE, ...)

## S3 method for class 'bru_mapper_collect'
ibm_invalid_output(mapper, input, state, inla_f = FALSE, multi = FALSE, ...)

## S3 method for class 'bru_mapper_collect'
x[i, drop = TRUE]

## S3 method for class 'bru_mapper_collect'
ibm_names(mapper)

## S3 replacement method for class 'bru_mapper_collect'
ibm_names(mapper) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_mapper_collect_+3A_mappers">mappers</code></td>
<td>
<p>A list of <code>bru_mapper</code> objects</p>
</td></tr>
<tr><td><code id="bru_mapper_collect_+3A_hidden">hidden</code></td>
<td>
<p><code>logical</code>, set to <code>TRUE</code> to flag that the mapper is to be used
as a first level input mapper for <code>INLA::f()</code> in a model that requires making
only the first mapper visible to <code>INLA::f()</code> and <code>INLA::inla.stack()</code>, such
as for &quot;bym2&quot; models, as activated by the <code>inla_f</code> argument to <code>ibm_n</code>,
<code>ibm_values</code>, and <code>ibm_jacobian</code>. Set to <code>FALSE</code> to always access the full
mapper, e.g. for <code>rgeneric</code> models</p>
</td></tr>
<tr><td><code id="bru_mapper_collect_+3A_mapper">mapper</code></td>
<td>
<p>A mapper S3 object, inheriting from <code>bru_mapper</code>.</p>
</td></tr>
<tr><td><code id="bru_mapper_collect_+3A_inla_f">inla_f</code></td>
<td>
<p>logical; when <code>TRUE</code> for <code>ibm_n()</code> and <code>ibm_values()</code>, the
result must be compatible with the <code>INLA::f(...)</code> and corresponding
<code>INLA::inla.stack(...)</code> constructions.  For <code style="white-space: pre;">&#8288;ibm_{eval,jacobian,linear}&#8288;</code>,
the <code>input</code> interpretation may be different.
Implementations do not normally need to do anything different, except
for mappers of the type needed for hidden multicomponent models such
as &quot;bym2&quot;, which can be handled by <code>bru_mapper_collect</code>.</p>
</td></tr>
<tr><td><code id="bru_mapper_collect_+3A_multi">multi</code></td>
<td>
<p>logical;
If <code>TRUE</code> (or positive), recurse one level into sub-mappers</p>
</td></tr>
<tr><td><code id="bru_mapper_collect_+3A_...">...</code></td>
<td>
<p>Arguments passed on to other methods</p>
</td></tr>
<tr><td><code id="bru_mapper_collect_+3A_input">input</code></td>
<td>
<p>Data input for the mapper.</p>
</td></tr>
<tr><td><code id="bru_mapper_collect_+3A_state">state</code></td>
<td>
<p>A vector of latent state values for the mapping,
of length <code>ibm_n(mapper, inla_f = FALSE)</code></p>
</td></tr>
<tr><td><code id="bru_mapper_collect_+3A_sub_lin">sub_lin</code></td>
<td>
<p>Internal, optional pre-computed sub-mapper information</p>
</td></tr>
<tr><td><code id="bru_mapper_collect_+3A_x">x</code></td>
<td>
<p>object from which to extract element(s)</p>
</td></tr>
<tr><td><code id="bru_mapper_collect_+3A_i">i</code></td>
<td>
<p>indices specifying element(s) to extract</p>
</td></tr>
<tr><td><code id="bru_mapper_collect_+3A_drop">drop</code></td>
<td>
<p>logical;
For <code style="white-space: pre;">&#8288;[.bru_mapper_collect&#8288;</code>, whether to extract an individual mapper when
<code>i</code> identifies a single element. If <code>FALSE</code>, a list of sub-mappers is
returned (suitable e.g. for creating a new <code>bru_mapper_collect</code> object).
Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="bru_mapper_collect_+3A_value">value</code></td>
<td>
<p>a character vector of the same length as the number
of sub-mappers in the mapper</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>ibm_jacobian</code> for <code>bru_mapper_collect</code> accepts a list with
named entries, or a list with unnamed but ordered elements.
The names must match the sub-mappers, see <code><a href="#topic+ibm_names.bru_mapper_collect">ibm_names.bru_mapper_collect()</a></code>.
Each list element should take a format accepted by the corresponding
sub-mapper. In case each element is a vector, the input can be given as a
data.frame with named columns, a matrix with named columns, or a matrix
with unnamed but ordered columns. When <code>inla_f=TRUE</code> and <code>hidden=TRUE</code> in
the mapper definition, the input format should instead match that of
the first, non-hidden, sub-mapper.
</p>
</li></ul>


<ul>
<li> <p><code>ibm_invalid_output</code> for <code>bru_mapper_collect</code> accepts a list with
named entries, or a list with unnamed but ordered elements.
The names must match the sub-mappers, see <code><a href="#topic+ibm_names.bru_mapper_collect">ibm_names.bru_mapper_collect()</a></code>.
Each list element should take a format accepted by the corresponding
sub-mapper. In case each element is a vector, the input can be given as a
data.frame with named columns, a matrix with named columns, or a matrix
with unnamed but ordered columns.
</p>
</li></ul>



<h3>Value</h3>


<ul>
<li> <p><code>[</code>-indexing a <code>bru_mapper_collect</code> extracts a subset
<code>bru_mapper_collect</code> object (for drop <code>FALSE</code>) or an individual sub-mapper
(for drop <code>TRUE</code>, and <code>i</code> identifies a single element)
</p>
</li></ul>


<ul>
<li><p> The <code>names()</code> method for <code>bru_mapper_collect</code> returns the names from the
sub-mappers list
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+bru_mapper">bru_mapper</a>, <a href="#topic+bru_mapper_generics">bru_mapper_generics</a>
</p>
<p>Other mappers: 
<code><a href="#topic+bru_get_mapper">bru_get_mapper</a>()</code>,
<code><a href="#topic+bru_mapper">bru_mapper</a>()</code>,
<code><a href="#topic+bru_mapper.fm_mesh_1d">bru_mapper.fm_mesh_1d</a>()</code>,
<code><a href="#topic+bru_mapper.fm_mesh_2d">bru_mapper.fm_mesh_2d</a>()</code>,
<code><a href="#topic+bru_mapper_aggregate">bru_mapper_aggregate</a>()</code>,
<code><a href="#topic+bru_mapper_const">bru_mapper_const</a>()</code>,
<code><a href="#topic+bru_mapper_factor">bru_mapper_factor</a>()</code>,
<code><a href="#topic+bru_mapper_generics">bru_mapper_generics</a></code>,
<code><a href="#topic+bru_mapper_harmonics">bru_mapper_harmonics</a>()</code>,
<code><a href="#topic+bru_mapper_index">bru_mapper_index</a>()</code>,
<code><a href="#topic+bru_mapper_linear">bru_mapper_linear</a>()</code>,
<code><a href="#topic+bru_mapper_logsumexp">bru_mapper_logsumexp</a>()</code>,
<code><a href="#topic+bru_mapper_marginal">bru_mapper_marginal</a>()</code>,
<code><a href="#topic+bru_mapper_matrix">bru_mapper_matrix</a>()</code>,
<code><a href="#topic+bru_mapper_mesh_B">bru_mapper_mesh_B</a>()</code>,
<code><a href="#topic+bru_mapper_multi">bru_mapper_multi</a>()</code>,
<code><a href="#topic+bru_mapper_pipe">bru_mapper_pipe</a>()</code>,
<code><a href="#topic+bru_mapper_scale">bru_mapper_scale</a>()</code>,
<code><a href="#topic+bru_mapper_shift">bru_mapper_shift</a>()</code>,
<code><a href="#topic+bru_mapper_taylor">bru_mapper_taylor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(m &lt;- bru_mapper_collect(list(
  a = bru_mapper_index(2),
  b = bru_mapper_index(3)
), hidden = FALSE))
ibm_eval2(m, list(a = c(1, 2), b = c(1, 3, 2)), 1:5)
</code></pre>

<hr>
<h2 id='bru_mapper_const'>Constant mapper</h2><span id='topic+bru_mapper_const'></span><span id='topic+ibm_n.bru_mapper_const'></span><span id='topic+ibm_values.bru_mapper_const'></span><span id='topic+ibm_jacobian.bru_mapper_const'></span><span id='topic+ibm_eval.bru_mapper_const'></span>

<h3>Description</h3>

<p>Create a constant mapper
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_mapper_const()

## S3 method for class 'bru_mapper_const'
ibm_n(mapper, ...)

## S3 method for class 'bru_mapper_const'
ibm_values(mapper, ...)

## S3 method for class 'bru_mapper_const'
ibm_jacobian(mapper, input, ...)

## S3 method for class 'bru_mapper_const'
ibm_eval(mapper, input, state = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_mapper_const_+3A_mapper">mapper</code></td>
<td>
<p>A mapper S3 object, inheriting from <code>bru_mapper</code>.</p>
</td></tr>
<tr><td><code id="bru_mapper_const_+3A_...">...</code></td>
<td>
<p>Arguments passed on to other methods</p>
</td></tr>
<tr><td><code id="bru_mapper_const_+3A_input">input</code></td>
<td>
<p>Data input for the mapper.</p>
</td></tr>
<tr><td><code id="bru_mapper_const_+3A_state">state</code></td>
<td>
<p>A vector of latent state values for the mapping,
of length <code>ibm_n(mapper, inla_f = FALSE)</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+bru_mapper">bru_mapper</a>, <a href="#topic+bru_mapper_generics">bru_mapper_generics</a>
</p>
<p>Other mappers: 
<code><a href="#topic+bru_get_mapper">bru_get_mapper</a>()</code>,
<code><a href="#topic+bru_mapper">bru_mapper</a>()</code>,
<code><a href="#topic+bru_mapper.fm_mesh_1d">bru_mapper.fm_mesh_1d</a>()</code>,
<code><a href="#topic+bru_mapper.fm_mesh_2d">bru_mapper.fm_mesh_2d</a>()</code>,
<code><a href="#topic+bru_mapper_aggregate">bru_mapper_aggregate</a>()</code>,
<code><a href="#topic+bru_mapper_collect">bru_mapper_collect</a>()</code>,
<code><a href="#topic+bru_mapper_factor">bru_mapper_factor</a>()</code>,
<code><a href="#topic+bru_mapper_generics">bru_mapper_generics</a></code>,
<code><a href="#topic+bru_mapper_harmonics">bru_mapper_harmonics</a>()</code>,
<code><a href="#topic+bru_mapper_index">bru_mapper_index</a>()</code>,
<code><a href="#topic+bru_mapper_linear">bru_mapper_linear</a>()</code>,
<code><a href="#topic+bru_mapper_logsumexp">bru_mapper_logsumexp</a>()</code>,
<code><a href="#topic+bru_mapper_marginal">bru_mapper_marginal</a>()</code>,
<code><a href="#topic+bru_mapper_matrix">bru_mapper_matrix</a>()</code>,
<code><a href="#topic+bru_mapper_mesh_B">bru_mapper_mesh_B</a>()</code>,
<code><a href="#topic+bru_mapper_multi">bru_mapper_multi</a>()</code>,
<code><a href="#topic+bru_mapper_pipe">bru_mapper_pipe</a>()</code>,
<code><a href="#topic+bru_mapper_scale">bru_mapper_scale</a>()</code>,
<code><a href="#topic+bru_mapper_shift">bru_mapper_shift</a>()</code>,
<code><a href="#topic+bru_mapper_taylor">bru_mapper_taylor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- bru_mapper_const()
ibm_eval2(m, input = 1:4)

</code></pre>

<hr>
<h2 id='bru_mapper_factor'>Mapper for factor variables</h2><span id='topic+bru_mapper_factor'></span><span id='topic+ibm_n.bru_mapper_factor'></span><span id='topic+ibm_values.bru_mapper_factor'></span><span id='topic+ibm_jacobian.bru_mapper_factor'></span>

<h3>Description</h3>

<p>Create a factor mapper
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_mapper_factor(values, factor_mapping, indexed = FALSE)

## S3 method for class 'bru_mapper_factor'
ibm_n(mapper, ...)

## S3 method for class 'bru_mapper_factor'
ibm_values(mapper, ...)

## S3 method for class 'bru_mapper_factor'
ibm_jacobian(mapper, input, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_mapper_factor_+3A_values">values</code></td>
<td>
<p>Input values calculated by <code><a href="#topic+input_eval.bru_input">input_eval.bru_input()</a></code></p>
</td></tr>
<tr><td><code id="bru_mapper_factor_+3A_factor_mapping">factor_mapping</code></td>
<td>
<p>character; selects the type of factor mapping.
</p>

<ul>
<li> <p><code>'contrast'</code> for leaving out the first factor level.
</p>
</li>
<li> <p><code>'full'</code> for keeping all levels.
</p>
</li></ul>
</td></tr>
<tr><td><code id="bru_mapper_factor_+3A_indexed">indexed</code></td>
<td>
<p>logical; if <code>TRUE</code>, the <code>ibm_values()</code> method
will return an integer vector instead of the factor levels.
This is needed e.g. for <code>group</code> and <code>replicate</code> mappers, since
<code>INLA::f()</code> doesn't accept factor values. Default: <code>FALSE</code>, which
works for the main input mappers. The default mapper constructions
will set it the required setting.</p>
</td></tr>
<tr><td><code id="bru_mapper_factor_+3A_mapper">mapper</code></td>
<td>
<p>A mapper S3 object, inheriting from <code>bru_mapper</code>.</p>
</td></tr>
<tr><td><code id="bru_mapper_factor_+3A_...">...</code></td>
<td>
<p>Arguments passed on to other methods</p>
</td></tr>
<tr><td><code id="bru_mapper_factor_+3A_input">input</code></td>
<td>
<p>Data input for the mapper.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+bru_mapper">bru_mapper</a>, <a href="#topic+bru_mapper_generics">bru_mapper_generics</a>
</p>
<p>Other mappers: 
<code><a href="#topic+bru_get_mapper">bru_get_mapper</a>()</code>,
<code><a href="#topic+bru_mapper">bru_mapper</a>()</code>,
<code><a href="#topic+bru_mapper.fm_mesh_1d">bru_mapper.fm_mesh_1d</a>()</code>,
<code><a href="#topic+bru_mapper.fm_mesh_2d">bru_mapper.fm_mesh_2d</a>()</code>,
<code><a href="#topic+bru_mapper_aggregate">bru_mapper_aggregate</a>()</code>,
<code><a href="#topic+bru_mapper_collect">bru_mapper_collect</a>()</code>,
<code><a href="#topic+bru_mapper_const">bru_mapper_const</a>()</code>,
<code><a href="#topic+bru_mapper_generics">bru_mapper_generics</a></code>,
<code><a href="#topic+bru_mapper_harmonics">bru_mapper_harmonics</a>()</code>,
<code><a href="#topic+bru_mapper_index">bru_mapper_index</a>()</code>,
<code><a href="#topic+bru_mapper_linear">bru_mapper_linear</a>()</code>,
<code><a href="#topic+bru_mapper_logsumexp">bru_mapper_logsumexp</a>()</code>,
<code><a href="#topic+bru_mapper_marginal">bru_mapper_marginal</a>()</code>,
<code><a href="#topic+bru_mapper_matrix">bru_mapper_matrix</a>()</code>,
<code><a href="#topic+bru_mapper_mesh_B">bru_mapper_mesh_B</a>()</code>,
<code><a href="#topic+bru_mapper_multi">bru_mapper_multi</a>()</code>,
<code><a href="#topic+bru_mapper_pipe">bru_mapper_pipe</a>()</code>,
<code><a href="#topic+bru_mapper_scale">bru_mapper_scale</a>()</code>,
<code><a href="#topic+bru_mapper_shift">bru_mapper_shift</a>()</code>,
<code><a href="#topic+bru_mapper_taylor">bru_mapper_taylor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- bru_mapper_factor(factor(c("a", "b")), "full")
ibm_eval2(m, input = c("b", "a", "a", "b"), state = c(1, 3))

m &lt;- bru_mapper_factor(factor(c("a", "b")), "contrast")
ibm_eval2(m, input = factor(c("b", "a", "a", "b")), state = 2)

</code></pre>

<hr>
<h2 id='bru_mapper_generics'>Generic methods for bru_mapper objects</h2><span id='topic+bru_mapper_generics'></span><span id='topic+ibm_n'></span><span id='topic+ibm_n_output'></span><span id='topic+ibm_values'></span><span id='topic+ibm_is_linear'></span><span id='topic+ibm_jacobian'></span><span id='topic+ibm_linear'></span><span id='topic+ibm_simplify'></span><span id='topic+ibm_eval'></span><span id='topic+ibm_eval2'></span><span id='topic+ibm_names'></span><span id='topic+ibm_names+3C-'></span><span id='topic+ibm_inla_subset'></span><span id='topic+ibm_invalid_output'></span><span id='topic+ibm_n.default'></span><span id='topic+ibm_n_output.default'></span><span id='topic+ibm_values.default'></span><span id='topic+ibm_is_linear.default'></span><span id='topic+ibm_jacobian.default'></span><span id='topic+ibm_linear.default'></span><span id='topic+ibm_simplify.default'></span><span id='topic+ibm_eval.default'></span><span id='topic+ibm_eval2.default'></span><span id='topic+ibm_names.default'></span><span id='topic+ibm_inla_subset.default'></span><span id='topic+ibm_invalid_output.default'></span>

<h3>Description</h3>

<p>A <code>bru_mapper</code> sub-class implementation must provide an
<code>ibm_jacobian()</code> method. If the model size 'n' and definition
values 'values' are stored in the object itself, default methods are
available (see Details). Otherwise the
<code>ibm_n()</code> and <code>ibm_values()</code> methods also need to be provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ibm_n(mapper, inla_f = FALSE, ...)

ibm_n_output(mapper, input, state = NULL, inla_f = FALSE, ...)

ibm_values(mapper, inla_f = FALSE, ...)

ibm_is_linear(mapper, ...)

ibm_jacobian(mapper, input, state = NULL, inla_f = FALSE, ...)

ibm_linear(mapper, input, state = NULL, ...)

ibm_simplify(mapper, input = NULL, state = NULL, ...)

ibm_eval(mapper, input, state = NULL, ...)

ibm_eval2(mapper, input, state = NULL, ...)

ibm_names(mapper)

ibm_names(mapper) &lt;- value

ibm_inla_subset(mapper, ...)

ibm_invalid_output(mapper, input, state, ...)

## Default S3 method:
ibm_n(mapper, inla_f = FALSE, ...)

## Default S3 method:
ibm_n_output(mapper, input, state = NULL, inla_f = FALSE, ...)

## Default S3 method:
ibm_values(mapper, inla_f = FALSE, ...)

## Default S3 method:
ibm_is_linear(mapper, ...)

## Default S3 method:
ibm_jacobian(mapper, input, state, ...)

## Default S3 method:
ibm_linear(mapper, input, state, ...)

## Default S3 method:
ibm_simplify(mapper, input = NULL, state = NULL, ...)

## Default S3 method:
ibm_eval(mapper, input, state = NULL, ..., jacobian = NULL)

## Default S3 method:
ibm_eval2(mapper, input, state, ...)

## Default S3 method:
ibm_names(mapper, ...)

## Default S3 method:
ibm_inla_subset(mapper, ...)

## Default S3 method:
ibm_invalid_output(mapper, input, state, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_mapper_generics_+3A_mapper">mapper</code></td>
<td>
<p>A mapper S3 object, inheriting from <code>bru_mapper</code>.</p>
</td></tr>
<tr><td><code id="bru_mapper_generics_+3A_inla_f">inla_f</code></td>
<td>
<p>logical; when <code>TRUE</code> for <code>ibm_n()</code> and <code>ibm_values()</code>, the
result must be compatible with the <code>INLA::f(...)</code> and corresponding
<code>INLA::inla.stack(...)</code> constructions.  For <code style="white-space: pre;">&#8288;ibm_{eval,jacobian,linear}&#8288;</code>,
the <code>input</code> interpretation may be different.
Implementations do not normally need to do anything different, except
for mappers of the type needed for hidden multicomponent models such
as &quot;bym2&quot;, which can be handled by <code>bru_mapper_collect</code>.</p>
</td></tr>
<tr><td><code id="bru_mapper_generics_+3A_...">...</code></td>
<td>
<p>Arguments passed on to other methods</p>
</td></tr>
<tr><td><code id="bru_mapper_generics_+3A_input">input</code></td>
<td>
<p>Data input for the mapper.</p>
</td></tr>
<tr><td><code id="bru_mapper_generics_+3A_state">state</code></td>
<td>
<p>A vector of latent state values for the mapping,
of length <code>ibm_n(mapper, inla_f = FALSE)</code></p>
</td></tr>
<tr><td><code id="bru_mapper_generics_+3A_value">value</code></td>
<td>
<p>a character vector of the same length as the number
of sub-mappers in the mapper</p>
</td></tr>
<tr><td><code id="bru_mapper_generics_+3A_jacobian">jacobian</code></td>
<td>
<p>For <code>ibm_eval()</code> methods, an optional pre-computed Jacobian, typically
supplied by internal methods that already have the Jacobian.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>ibm_n()</code>: Implementations must return the size of the latent vector
being mapped to.
</p>
</li>
<li> <p><code>ibm_n_output()</code>: Implementations must return an integer denoting the
mapper output length.
The default implementation returns <code>NROW(input)</code>.
Mappers such as <code>bru_mapper_multi</code> and <code>bru_mapper_collect</code>,
that can accept <code>list()</code> inputs require their own methods implementations.
</p>
</li>
<li> <p><code>ibm_values()</code>: When <code>inla_f=TRUE</code>, implementations must return a vector that
would be interpretable by an <code>INLA::f(..., values = ...)</code> specification.
The exception is the method for <code>bru_mapper_multi</code>, that returns a
multi-column data frame.
</p>
</li>
<li> <p><code>ibm_is_linear()</code>: Implementations must return <code>TRUE</code> or <code>FALSE</code>.
If <code>TRUE</code> (returned by the default method unless the mapper
contains an <code>is_linear</code> variable), users of the mapper
may assume the mapper is linear.
</p>
</li>
<li> <p><code>ibm_jacobian()</code>: Implementations must return a (sparse) matrix of size
<code>ibm_n_output(mapper, input, inla_f)</code>
by <code>ibm_n(mapper, inla_f = FALSE)</code>. The <code>inla_f=TRUE</code> argument should
only affect the allowed type of input format.
</p>
</li>
<li> <p><code>ibm_linear()</code>: Implementations must return a <a href="#topic+bru_mapper_taylor">bru_mapper_taylor</a> object
The linearisation information includes <code>offset</code>, <code>jacobian</code>, and <code>state0</code>.
The state information indicates for which state the <code>offset</code> was evaluated,
with <code>NULL</code> meaning all-zero.
The linearised mapper output is defined as
<code>effect(input, state) = offset(input, state0) + jacobian(input, state0) %*% (state - state0)</code>.
The default method calls <code>ibm_eval()</code> and <code>ibm_jacobian()</code> to generate
the needed information.
</p>
</li>
<li> <p><code>ibm_simplify()</code>: Implementations must return a <a href="#topic+bru_mapper">bru_mapper</a> object.
The default method returns <code>ibm_linear(...)</code> for linear mappers, and the
original <code>mapper</code> for non-linear mappers.
</p>
</li>
<li> <p><code>ibm_eval()</code>: Implementations must return a vector of length <code>ibm_n_output(...)</code>.
The <code>input</code> contents must
be in a format accepted by <code>ibm_jacobian(...)</code>
for the mapper.
</p>
</li>
<li> <p><code>ibm_eval2()</code>: Implementations must return a list with elements <code>offset</code> and <code>jacobian</code>.
The <code>input</code> contents must
be in a format accepted by <code>ibm_jacobian(...)</code>
for the mapper.
</p>
</li>
<li> <p><code>ibm_names()</code>: Implementations must return a character vector of sub-mapper names, or <code>NULL</code>.
Intended for providing information about multi-mappers and mapper collections.
</p>
</li>
<li> <p><code>ibm_names(mapper) &lt;- value</code>: Set mapper names.
</p>
</li>
<li> <p><code>ibm_inla_subset()</code>: Implementations must return a logical vector of <code>TRUE/FALSE</code> for
the subset such that, given the full A matrix and values output,
<code>A[, subset, drop = FALSE]</code> and <code>values[subset]</code>
(or <code>values[subset, , drop = FALSE]</code> for data.frame values) are equal
to the <code>inla_f = TRUE</code> version of A and values. The default method uses
the <code>ibm_values</code> output to construct the subset indexing.
</p>
</li>
<li> <p><code>ibm_invalid_output()</code>: Implementations should return a logical vector of length
<code>ibm_n_output(mapper, input, state, ...)</code> indicating which, if any,
output elements of <code>ibm_eval(mapper, input, state, ...)</code> are known to be
invalid.
For for multi/collect mappers, a list, when given a <code>multi=TRUE</code> argument.
</p>
</li>
<li> <p><code>ibm_n(default)</code>: Returns a non-null element 'n' from the
mapper object, and gives an error if it doesn't exist. If <code>inla_f=TRUE</code>,
first checks for a 'n_inla' element.
</p>
</li>
<li> <p><code>ibm_n_output(default)</code>: Returns <code>NROW(input)</code>
</p>
</li>
<li> <p><code>ibm_values(default)</code>: Returns a non-null element
'values' from the mapper object, and <code>seq_len(ibm_n(mapper))</code> if
it doesn't exist.
</p>
</li>
<li> <p><code>ibm_is_linear(default)</code>: Returns logical
<code>is_linear</code> from the mapper object if it exists, and otherwise <code>TRUE</code>.
</p>
</li>
<li> <p><code>ibm_jacobian(default)</code>: Mapper classes must implement their own <code>ibm_jacobian</code> method.
</p>
</li>
<li> <p><code>ibm_linear(default)</code>: Calls <code>ibm_eval()</code> and <code>ibm_jacobian()</code>
and returns a <code>bru_mapper_taylor</code> object.
The <code>state0</code> information in the affine mapper indicates for which state
the <code>offset</code> was evaluated; The affine mapper output is defined as
<code>effect(input, state) = offset(input, state0) + jacobian(input, state0) %*% (state - state0)</code>
</p>
</li>
<li> <p><code>ibm_simplify(default)</code>: Calls <code>ibm_linear()</code> for linear mappers, and returns the original mapper
for non-linear mappers.
</p>
</li>
<li> <p><code>ibm_eval(default)</code>: Verifies that the mapper is linear
with <code>ibm_is_linear()</code>, and then computes a linear mapping
as <code>ibm_jacobian(...) %*% state</code>.  When <code>state</code> is <code>NULL</code>,
a zero vector of length <code>ibm_n_output(...)</code> is returned.
</p>
</li>
<li> <p><code>ibm_eval2(default)</code>: Calls <code>jacobian &lt;- ibm_jacobian(...)</code> and
<code>offset &lt;- ibm_eval(..., jacobian = jacobian)</code>
and returns a list with elements <code>offset</code> and <code>jacobian</code>, as needed
by <code><a href="#topic+ibm_linear.default">ibm_linear.default()</a></code> and similar methods. Mapper classes can implement
their own <code>ibm_eval2</code> method if joint construction of evaluation and Jacobian
is more efficient than separate or sequential construction.
</p>
</li>
<li> <p><code>ibm_names(default)</code>: Returns <code>NULL</code>
</p>
</li>
<li> <p><code>ibm_inla_subset(default)</code>: Uses
the <code>ibm_values</code> output to construct the inla subset indexing, passing
extra arguments such as <code>multi</code> on to the methods (this means it supports
both regular vector values and <code>multi=1</code> data.frame values).
</p>
</li>
<li> <p><code>ibm_invalid_output(default)</code>: Returns an all-<code>FALSE</code> logical vector.
</p>
</li></ul>


<h3>See Also</h3>

<p><a href="#topic+bru_mapper">bru_mapper</a> for constructor methods, and
<a href="#topic+bru_get_mapper">bru_get_mapper</a> for hooks to extract mappers from latent model object
class objects.
</p>
<p><a href="#topic+bru_mapper">bru_mapper</a>, <code><a href="#topic+bru_get_mapper">bru_get_mapper()</a></code>
</p>
<p>Other mappers: 
<code><a href="#topic+bru_get_mapper">bru_get_mapper</a>()</code>,
<code><a href="#topic+bru_mapper">bru_mapper</a>()</code>,
<code><a href="#topic+bru_mapper.fm_mesh_1d">bru_mapper.fm_mesh_1d</a>()</code>,
<code><a href="#topic+bru_mapper.fm_mesh_2d">bru_mapper.fm_mesh_2d</a>()</code>,
<code><a href="#topic+bru_mapper_aggregate">bru_mapper_aggregate</a>()</code>,
<code><a href="#topic+bru_mapper_collect">bru_mapper_collect</a>()</code>,
<code><a href="#topic+bru_mapper_const">bru_mapper_const</a>()</code>,
<code><a href="#topic+bru_mapper_factor">bru_mapper_factor</a>()</code>,
<code><a href="#topic+bru_mapper_harmonics">bru_mapper_harmonics</a>()</code>,
<code><a href="#topic+bru_mapper_index">bru_mapper_index</a>()</code>,
<code><a href="#topic+bru_mapper_linear">bru_mapper_linear</a>()</code>,
<code><a href="#topic+bru_mapper_logsumexp">bru_mapper_logsumexp</a>()</code>,
<code><a href="#topic+bru_mapper_marginal">bru_mapper_marginal</a>()</code>,
<code><a href="#topic+bru_mapper_matrix">bru_mapper_matrix</a>()</code>,
<code><a href="#topic+bru_mapper_mesh_B">bru_mapper_mesh_B</a>()</code>,
<code><a href="#topic+bru_mapper_multi">bru_mapper_multi</a>()</code>,
<code><a href="#topic+bru_mapper_pipe">bru_mapper_pipe</a>()</code>,
<code><a href="#topic+bru_mapper_scale">bru_mapper_scale</a>()</code>,
<code><a href="#topic+bru_mapper_shift">bru_mapper_shift</a>()</code>,
<code><a href="#topic+bru_mapper_taylor">bru_mapper_taylor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ibm_names
mapper &lt;- bru_mapper_multi(list(
  A = bru_mapper_index(2),
  B = bru_mapper_index(2)
))
ibm_names(mapper)
ibm_names(mapper) &lt;- c("new", "names")
ibm_names(mapper)
</code></pre>

<hr>
<h2 id='bru_mapper_harmonics'>Mapper for cos/sin functions</h2><span id='topic+bru_mapper_harmonics'></span><span id='topic+ibm_n.bru_mapper_harmonics'></span><span id='topic+ibm_jacobian.bru_mapper_harmonics'></span>

<h3>Description</h3>

<p>Constructs a mapper for <code>cos</code>/<code>sin</code> functions
of orders 1 (if <code>intercept</code> is <code>TRUE</code>, otherwise 0) through <code>order</code>. The total
number of basis functions is <code>intercept + 2 * order</code>.
</p>
<p>Optionally, each order can be given a non-unit scaling, via the <code>scaling</code>
vector, of length <code>intercept + order</code>. This can be used to
give an effective spectral prior. For example, let
</p>
<div class="sourceCode"><pre>scaling = 1 / (1 + (0:4)^2)
x &lt;- seq(0, 1, length.out = 11)
bmh1 = bru_mapper_harmonics(order = 4, interval = c(0, 1))
u1 &lt;- ibm_eval(
  bmh1,
  input = x,
  state = rnorm(9, sd = rep(scaling, c(1, 2, 2, 2, 2)))
)
</pre></div>
<p>Then, with
</p>
<div class="sourceCode"><pre>bmh2 = bru_mapper_harmonics(order = 4, scaling = scaling)
u2 = ibm_eval(bmh2, input = x, state = rnorm(9))
</pre></div>
<p>the stochastic properties of <code>u1</code> and <code>u2</code> will be the same, with <code>scaling^2</code>
determining the variance for each frequency contribution.
</p>
<p>The period for the first order harmonics is shifted and scaled to match
<code>interval</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_mapper_harmonics(
  order = 1,
  scaling = 1,
  intercept = TRUE,
  interval = c(0, 1)
)

## S3 method for class 'bru_mapper_harmonics'
ibm_n(mapper, inla_f = FALSE, ...)

## S3 method for class 'bru_mapper_harmonics'
ibm_jacobian(mapper, input, state = NULL, inla_f = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_mapper_harmonics_+3A_order">order</code></td>
<td>
<p>For <code>bru_mapper_harmonics</code>, specifies the maximum <code>cos</code>/<code>sin</code>
order. (Default 1)</p>
</td></tr>
<tr><td><code id="bru_mapper_harmonics_+3A_scaling">scaling</code></td>
<td>
<p>For <code>bru_mapper_harmonics</code>, specifies an optional vector of
scaling factors of length <code>intercept + order</code>, or a common single scalar.</p>
</td></tr>
<tr><td><code id="bru_mapper_harmonics_+3A_intercept">intercept</code></td>
<td>
<p>logical; For <code>bru_mapper_harmonics</code>, if <code>TRUE</code>, the first
basis function is a constant. (Default <code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="bru_mapper_harmonics_+3A_interval">interval</code></td>
<td>
<p>numeric length-2 vector specifying a domain interval.
Default <code>c(0, 1)</code>.</p>
</td></tr>
<tr><td><code id="bru_mapper_harmonics_+3A_mapper">mapper</code></td>
<td>
<p>A mapper S3 object, inheriting from <code>bru_mapper</code>.</p>
</td></tr>
<tr><td><code id="bru_mapper_harmonics_+3A_inla_f">inla_f</code></td>
<td>
<p>logical; when <code>TRUE</code> for <code>ibm_n()</code> and <code>ibm_values()</code>, the
result must be compatible with the <code>INLA::f(...)</code> and corresponding
<code>INLA::inla.stack(...)</code> constructions.  For <code style="white-space: pre;">&#8288;ibm_{eval,jacobian,linear}&#8288;</code>,
the <code>input</code> interpretation may be different.
Implementations do not normally need to do anything different, except
for mappers of the type needed for hidden multicomponent models such
as &quot;bym2&quot;, which can be handled by <code>bru_mapper_collect</code>.</p>
</td></tr>
<tr><td><code id="bru_mapper_harmonics_+3A_...">...</code></td>
<td>
<p>Arguments passed on to other methods</p>
</td></tr>
<tr><td><code id="bru_mapper_harmonics_+3A_input">input</code></td>
<td>
<p>Data input for the mapper.</p>
</td></tr>
<tr><td><code id="bru_mapper_harmonics_+3A_state">state</code></td>
<td>
<p>A vector of latent state values for the mapping,
of length <code>ibm_n(mapper, inla_f = FALSE)</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+bru_mapper">bru_mapper</a>, <a href="#topic+bru_mapper_generics">bru_mapper_generics</a>
</p>
<p>Other mappers: 
<code><a href="#topic+bru_get_mapper">bru_get_mapper</a>()</code>,
<code><a href="#topic+bru_mapper">bru_mapper</a>()</code>,
<code><a href="#topic+bru_mapper.fm_mesh_1d">bru_mapper.fm_mesh_1d</a>()</code>,
<code><a href="#topic+bru_mapper.fm_mesh_2d">bru_mapper.fm_mesh_2d</a>()</code>,
<code><a href="#topic+bru_mapper_aggregate">bru_mapper_aggregate</a>()</code>,
<code><a href="#topic+bru_mapper_collect">bru_mapper_collect</a>()</code>,
<code><a href="#topic+bru_mapper_const">bru_mapper_const</a>()</code>,
<code><a href="#topic+bru_mapper_factor">bru_mapper_factor</a>()</code>,
<code><a href="#topic+bru_mapper_generics">bru_mapper_generics</a></code>,
<code><a href="#topic+bru_mapper_index">bru_mapper_index</a>()</code>,
<code><a href="#topic+bru_mapper_linear">bru_mapper_linear</a>()</code>,
<code><a href="#topic+bru_mapper_logsumexp">bru_mapper_logsumexp</a>()</code>,
<code><a href="#topic+bru_mapper_marginal">bru_mapper_marginal</a>()</code>,
<code><a href="#topic+bru_mapper_matrix">bru_mapper_matrix</a>()</code>,
<code><a href="#topic+bru_mapper_mesh_B">bru_mapper_mesh_B</a>()</code>,
<code><a href="#topic+bru_mapper_multi">bru_mapper_multi</a>()</code>,
<code><a href="#topic+bru_mapper_pipe">bru_mapper_pipe</a>()</code>,
<code><a href="#topic+bru_mapper_scale">bru_mapper_scale</a>()</code>,
<code><a href="#topic+bru_mapper_shift">bru_mapper_shift</a>()</code>,
<code><a href="#topic+bru_mapper_taylor">bru_mapper_taylor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- bru_mapper_harmonics(2)
ibm_eval2(m, input = c(0, pi / 4, pi / 2, 3 * pi / 4), 1:5)

</code></pre>

<hr>
<h2 id='bru_mapper_index'>Mapper for indexed variables</h2><span id='topic+bru_mapper_index'></span><span id='topic+ibm_invalid_output.bru_mapper_index'></span><span id='topic+ibm_jacobian.bru_mapper_index'></span>

<h3>Description</h3>

<p>Create a an indexing mapper
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_mapper_index(n = 1L, ...)

## S3 method for class 'bru_mapper_index'
ibm_invalid_output(mapper, input, state, ...)

## S3 method for class 'bru_mapper_index'
ibm_jacobian(mapper, input, state, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_mapper_index_+3A_n">n</code></td>
<td>
<p>Size of a model for <code>bru_mapper_index</code></p>
</td></tr>
<tr><td><code id="bru_mapper_index_+3A_...">...</code></td>
<td>
<p>Arguments passed on to other methods</p>
</td></tr>
<tr><td><code id="bru_mapper_index_+3A_mapper">mapper</code></td>
<td>
<p>A mapper S3 object, inheriting from <code>bru_mapper</code>.</p>
</td></tr>
<tr><td><code id="bru_mapper_index_+3A_input">input</code></td>
<td>
<p>Data input for the mapper.</p>
</td></tr>
<tr><td><code id="bru_mapper_index_+3A_state">state</code></td>
<td>
<p>A vector of latent state values for the mapping,
of length <code>ibm_n(mapper, inla_f = FALSE)</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+bru_mapper">bru_mapper</a>, <a href="#topic+bru_mapper_generics">bru_mapper_generics</a>
</p>
<p>Other mappers: 
<code><a href="#topic+bru_get_mapper">bru_get_mapper</a>()</code>,
<code><a href="#topic+bru_mapper">bru_mapper</a>()</code>,
<code><a href="#topic+bru_mapper.fm_mesh_1d">bru_mapper.fm_mesh_1d</a>()</code>,
<code><a href="#topic+bru_mapper.fm_mesh_2d">bru_mapper.fm_mesh_2d</a>()</code>,
<code><a href="#topic+bru_mapper_aggregate">bru_mapper_aggregate</a>()</code>,
<code><a href="#topic+bru_mapper_collect">bru_mapper_collect</a>()</code>,
<code><a href="#topic+bru_mapper_const">bru_mapper_const</a>()</code>,
<code><a href="#topic+bru_mapper_factor">bru_mapper_factor</a>()</code>,
<code><a href="#topic+bru_mapper_generics">bru_mapper_generics</a></code>,
<code><a href="#topic+bru_mapper_harmonics">bru_mapper_harmonics</a>()</code>,
<code><a href="#topic+bru_mapper_linear">bru_mapper_linear</a>()</code>,
<code><a href="#topic+bru_mapper_logsumexp">bru_mapper_logsumexp</a>()</code>,
<code><a href="#topic+bru_mapper_marginal">bru_mapper_marginal</a>()</code>,
<code><a href="#topic+bru_mapper_matrix">bru_mapper_matrix</a>()</code>,
<code><a href="#topic+bru_mapper_mesh_B">bru_mapper_mesh_B</a>()</code>,
<code><a href="#topic+bru_mapper_multi">bru_mapper_multi</a>()</code>,
<code><a href="#topic+bru_mapper_pipe">bru_mapper_pipe</a>()</code>,
<code><a href="#topic+bru_mapper_scale">bru_mapper_scale</a>()</code>,
<code><a href="#topic+bru_mapper_shift">bru_mapper_shift</a>()</code>,
<code><a href="#topic+bru_mapper_taylor">bru_mapper_taylor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- bru_mapper_index(4)
ibm_eval(m, -2:6, 1:4)
</code></pre>

<hr>
<h2 id='bru_mapper_linear'>Mapper for a linear effect</h2><span id='topic+bru_mapper_linear'></span><span id='topic+ibm_n.bru_mapper_linear'></span><span id='topic+ibm_values.bru_mapper_linear'></span><span id='topic+ibm_jacobian.bru_mapper_linear'></span>

<h3>Description</h3>

<p>Create a mapper for linear effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_mapper_linear()

## S3 method for class 'bru_mapper_linear'
ibm_n(mapper, ...)

## S3 method for class 'bru_mapper_linear'
ibm_values(mapper, ...)

## S3 method for class 'bru_mapper_linear'
ibm_jacobian(mapper, input, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_mapper_linear_+3A_mapper">mapper</code></td>
<td>
<p>A mapper S3 object, inheriting from <code>bru_mapper</code>.</p>
</td></tr>
<tr><td><code id="bru_mapper_linear_+3A_...">...</code></td>
<td>
<p>Arguments passed on to other methods</p>
</td></tr>
<tr><td><code id="bru_mapper_linear_+3A_input">input</code></td>
<td>
<p>Data input for the mapper.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+bru_mapper">bru_mapper</a>, <a href="#topic+bru_mapper_generics">bru_mapper_generics</a>
</p>
<p>Other mappers: 
<code><a href="#topic+bru_get_mapper">bru_get_mapper</a>()</code>,
<code><a href="#topic+bru_mapper">bru_mapper</a>()</code>,
<code><a href="#topic+bru_mapper.fm_mesh_1d">bru_mapper.fm_mesh_1d</a>()</code>,
<code><a href="#topic+bru_mapper.fm_mesh_2d">bru_mapper.fm_mesh_2d</a>()</code>,
<code><a href="#topic+bru_mapper_aggregate">bru_mapper_aggregate</a>()</code>,
<code><a href="#topic+bru_mapper_collect">bru_mapper_collect</a>()</code>,
<code><a href="#topic+bru_mapper_const">bru_mapper_const</a>()</code>,
<code><a href="#topic+bru_mapper_factor">bru_mapper_factor</a>()</code>,
<code><a href="#topic+bru_mapper_generics">bru_mapper_generics</a></code>,
<code><a href="#topic+bru_mapper_harmonics">bru_mapper_harmonics</a>()</code>,
<code><a href="#topic+bru_mapper_index">bru_mapper_index</a>()</code>,
<code><a href="#topic+bru_mapper_logsumexp">bru_mapper_logsumexp</a>()</code>,
<code><a href="#topic+bru_mapper_marginal">bru_mapper_marginal</a>()</code>,
<code><a href="#topic+bru_mapper_matrix">bru_mapper_matrix</a>()</code>,
<code><a href="#topic+bru_mapper_mesh_B">bru_mapper_mesh_B</a>()</code>,
<code><a href="#topic+bru_mapper_multi">bru_mapper_multi</a>()</code>,
<code><a href="#topic+bru_mapper_pipe">bru_mapper_pipe</a>()</code>,
<code><a href="#topic+bru_mapper_scale">bru_mapper_scale</a>()</code>,
<code><a href="#topic+bru_mapper_shift">bru_mapper_shift</a>()</code>,
<code><a href="#topic+bru_mapper_taylor">bru_mapper_taylor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- bru_mapper_linear()
ibm_eval(m, input = 1:4, state = 2)

</code></pre>

<hr>
<h2 id='bru_mapper_logsumexp'>Mapper for log-sum-exp aggregation</h2><span id='topic+bru_mapper_logsumexp'></span><span id='topic+ibm_jacobian.bru_mapper_logsumexp'></span><span id='topic+ibm_eval.bru_mapper_logsumexp'></span>

<h3>Description</h3>

<p>Constructs a mapper
that aggregates elements of <code>exp(state)</code>, with optional non-negative weighting,
and then takes the <code>log()</code>, so it can be used e.g.
for  <code class="reqn">v_k=\log[\sum_{i\in I_k} w_i \exp(u_i)]</code>
and <code class="reqn">v_k=\log[\sum_{i\in I_k} w_i \exp(u_i) / \sum_{i\in I_k} w_i]</code>
calculations.  Relies on the input handling methods for <code>bru_mapper_aggregate</code>,
but also allows the weights to be supplied on a logarithmic scale as <code>log_weights</code>.
To avoid numerical overflow, it uses the common method of internally
shifting the state blockwise;
<code class="reqn">v_k=s_k+\log[\sum_{i\in I_k} \exp(u_i + \log(w_i)- s_k)]</code>,
where <code class="reqn">s_k=\max_{i\in I_k} u_i + \log(w_i)</code> is the shift for block <code class="reqn">k</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_mapper_logsumexp(rescale = FALSE, n_block = NULL)

## S3 method for class 'bru_mapper_logsumexp'
ibm_jacobian(mapper, input, state = NULL, ...)

## S3 method for class 'bru_mapper_logsumexp'
ibm_eval(mapper, input, state = NULL, log = TRUE, ..., sub_lin = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_mapper_logsumexp_+3A_rescale">rescale</code></td>
<td>
<p>logical; For <code>bru_mapper_aggregate</code> and <code>bru_mapper_logsumexp</code>,
specifies if the blockwise sums should be normalised by the blockwise weight
sums or not:
</p>

<ul>
<li> <p><code>FALSE</code>: (default) Straight weighted sum, no rescaling.
</p>
</li>
<li> <p><code>TRUE</code>: Divide by the sum of the weight values within each block.
This is useful for integration averages, when the given weights are plain
integration weights. If the weights are <code>NULL</code> or all ones, this is
the same as dividing by the number of entries in each block.
</p>
</li></ul>
</td></tr>
<tr><td><code id="bru_mapper_logsumexp_+3A_n_block">n_block</code></td>
<td>
<p>Predetermined number of output blocks. If <code>NULL</code>, overrides
the maximum block index in the inputs.</p>
</td></tr>
<tr><td><code id="bru_mapper_logsumexp_+3A_mapper">mapper</code></td>
<td>
<p>A mapper S3 object, inheriting from <code>bru_mapper</code>.</p>
</td></tr>
<tr><td><code id="bru_mapper_logsumexp_+3A_input">input</code></td>
<td>
<p>Data input for the mapper.</p>
</td></tr>
<tr><td><code id="bru_mapper_logsumexp_+3A_state">state</code></td>
<td>
<p>A vector of latent state values for the mapping,
of length <code>ibm_n(mapper, inla_f = FALSE)</code></p>
</td></tr>
<tr><td><code id="bru_mapper_logsumexp_+3A_...">...</code></td>
<td>
<p>Arguments passed on to other methods</p>
</td></tr>
<tr><td><code id="bru_mapper_logsumexp_+3A_log">log</code></td>
<td>
<p>logical; control <code>log</code> output. Default <code>TRUE</code>, see the <code>ibm_eval()</code> details
for <code>logsumexp</code> mappers.</p>
</td></tr>
<tr><td><code id="bru_mapper_logsumexp_+3A_sub_lin">sub_lin</code></td>
<td>
<p>Internal, optional pre-computed sub-mapper information</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> For <code>bru_mapper_logsumexp</code>, <code>input</code> should be a list with elements <code>block</code>
and <code>weights</code>. <code>block</code>
should be a vector of the same length as the <code>state</code>, or <code>NULL</code>, with <code>NULL</code>
equivalent to all-1.
If <code>weights</code> is <code>NULL</code>, it's interpreted as all-1.
</p>
</li></ul>



<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>ibm_eval(bru_mapper_logsumexp)</code>: When <code>log</code> is <code>TRUE</code> (default), <code>ibm_eval()</code> for <code>logsumexp</code> returns
the log-sum-weight-exp value. If <code>FALSE</code>, the <code>sum-weight-exp</code> value is returned.
</p>
</li></ul>


<h3>See Also</h3>

<p><a href="#topic+bru_mapper">bru_mapper</a>, <a href="#topic+bru_mapper_generics">bru_mapper_generics</a>
</p>
<p>Other mappers: 
<code><a href="#topic+bru_get_mapper">bru_get_mapper</a>()</code>,
<code><a href="#topic+bru_mapper">bru_mapper</a>()</code>,
<code><a href="#topic+bru_mapper.fm_mesh_1d">bru_mapper.fm_mesh_1d</a>()</code>,
<code><a href="#topic+bru_mapper.fm_mesh_2d">bru_mapper.fm_mesh_2d</a>()</code>,
<code><a href="#topic+bru_mapper_aggregate">bru_mapper_aggregate</a>()</code>,
<code><a href="#topic+bru_mapper_collect">bru_mapper_collect</a>()</code>,
<code><a href="#topic+bru_mapper_const">bru_mapper_const</a>()</code>,
<code><a href="#topic+bru_mapper_factor">bru_mapper_factor</a>()</code>,
<code><a href="#topic+bru_mapper_generics">bru_mapper_generics</a></code>,
<code><a href="#topic+bru_mapper_harmonics">bru_mapper_harmonics</a>()</code>,
<code><a href="#topic+bru_mapper_index">bru_mapper_index</a>()</code>,
<code><a href="#topic+bru_mapper_linear">bru_mapper_linear</a>()</code>,
<code><a href="#topic+bru_mapper_marginal">bru_mapper_marginal</a>()</code>,
<code><a href="#topic+bru_mapper_matrix">bru_mapper_matrix</a>()</code>,
<code><a href="#topic+bru_mapper_mesh_B">bru_mapper_mesh_B</a>()</code>,
<code><a href="#topic+bru_mapper_multi">bru_mapper_multi</a>()</code>,
<code><a href="#topic+bru_mapper_pipe">bru_mapper_pipe</a>()</code>,
<code><a href="#topic+bru_mapper_scale">bru_mapper_scale</a>()</code>,
<code><a href="#topic+bru_mapper_shift">bru_mapper_shift</a>()</code>,
<code><a href="#topic+bru_mapper_taylor">bru_mapper_taylor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- bru_mapper_logsumexp()
ibm_eval2(m, list(block = c(1, 2, 1, 2), weights = 1:4), 11:14)

</code></pre>

<hr>
<h2 id='bru_mapper_marginal'>Mapper for marginal distribution transformation</h2><span id='topic+bru_mapper_marginal'></span><span id='topic+ibm_n.bru_mapper_marginal'></span><span id='topic+ibm_n_output.bru_mapper_marginal'></span><span id='topic+ibm_values.bru_mapper_marginal'></span><span id='topic+ibm_jacobian.bru_mapper_marginal'></span><span id='topic+ibm_eval.bru_mapper_marginal'></span>

<h3>Description</h3>

<p>Constructs a mapper that transforms the marginal distribution <code>state</code> from
<code class="reqn">\textrm{N}(0,1)</code> to the distribution of a given (continuous)
quantile function. The <code>...</code> arguments are used as parameter arguments to
<code>qfun</code>, <code>pfun</code>, <code>dfun</code>, and <code>dqfun</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_mapper_marginal(
  qfun,
  pfun = NULL,
  dfun = NULL,
  dqfun = NULL,
  ...,
  inverse = FALSE
)

## S3 method for class 'bru_mapper_marginal'
ibm_n(mapper, ..., state = NULL, n_state = NULL)

## S3 method for class 'bru_mapper_marginal'
ibm_n_output(mapper, input, state = NULL, ..., n_state = NULL)

## S3 method for class 'bru_mapper_marginal'
ibm_values(mapper, ..., state = NULL, n_state = NULL)

## S3 method for class 'bru_mapper_marginal'
ibm_jacobian(mapper, input, state = NULL, ..., reverse = FALSE)

## S3 method for class 'bru_mapper_marginal'
ibm_eval(mapper, input, state = NULL, ..., reverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_mapper_marginal_+3A_qfun">qfun</code></td>
<td>
<p>A quantile function, supporting <code>lower.tail</code> and <code>log.p</code> arguments,
like <code><a href="stats.html#topic+Normal">stats::qnorm()</a></code>.</p>
</td></tr>
<tr><td><code id="bru_mapper_marginal_+3A_pfun">pfun</code></td>
<td>
<p>A CDF, supporting <code>lower.tail</code> and <code>log.p</code> arguments,
like <code><a href="stats.html#topic+Normal">stats::pnorm()</a></code>.  Only needed and used when
<code>xor(mapper[["inverse"]], reverse)</code> is <code>TRUE</code> in a method call.
Default <code>NULL</code></p>
</td></tr>
<tr><td><code id="bru_mapper_marginal_+3A_dfun">dfun</code></td>
<td>
<p>A pdf, supporting <code>log</code> argument,
like <code><a href="stats.html#topic+Normal">stats::dnorm()</a></code>. If <code>NULL</code> (default), uses finite
differences on <code>qfun</code> or <code>pfun</code> instead.</p>
</td></tr>
<tr><td><code id="bru_mapper_marginal_+3A_dqfun">dqfun</code></td>
<td>
<p>A function evaluating the reciprocal of the derivative of <code>qfun</code>.
If <code>NULL</code> (default), uses <code>dfun(qfun(...),...)</code> or finite
differences on <code>qfun</code> or <code>pfun</code> instead.</p>
</td></tr>
<tr><td><code id="bru_mapper_marginal_+3A_...">...</code></td>
<td>
<p>Arguments passed on to other methods</p>
</td></tr>
<tr><td><code id="bru_mapper_marginal_+3A_inverse">inverse</code></td>
<td>
<p>logical; If <code>FALSE</code> (default), <code><a href="#topic+bru_mapper_marginal">bru_mapper_marginal()</a></code>
defines a mapping from standard Normal to a specified distribution.
If <code>TRUE</code>, it defines a mapping from the specified distribution to a standard
Normal.</p>
</td></tr>
<tr><td><code id="bru_mapper_marginal_+3A_mapper">mapper</code></td>
<td>
<p>A mapper S3 object, inheriting from <code>bru_mapper</code>.</p>
</td></tr>
<tr><td><code id="bru_mapper_marginal_+3A_state">state</code></td>
<td>
<p>A vector of latent state values for the mapping,
of length <code>ibm_n(mapper, inla_f = FALSE)</code></p>
</td></tr>
<tr><td><code id="bru_mapper_marginal_+3A_n_state">n_state</code></td>
<td>
<p>integer giving the length of the state vector for mappers
that have state dependent output size.</p>
</td></tr>
<tr><td><code id="bru_mapper_marginal_+3A_input">input</code></td>
<td>
<p>Data input for the mapper.</p>
</td></tr>
<tr><td><code id="bru_mapper_marginal_+3A_reverse">reverse</code></td>
<td>
<p>logical; control <code>bru_mapper_marginal</code> evaluation. Default <code>FALSE</code>.
When <code>TRUE</code>, reverses the direction of the mapping, see details for <code>marginal</code>
mappers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>bru_mapper_marginal</code>, non-NULL <code>input</code> values are interpreted
as a parameter list for <code>qfun</code>, overriding that of the mapper itself.
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>ibm_eval(bru_mapper_marginal)</code>: When <code>xor(mapper[["inverse"]], reverse)</code> is
<code>FALSE</code>, <code>ibm_eval()</code>
for <code>marginal</code> returns <code>qfun(pnorm(x), param)</code>, evaluated in a numerically
stable way. Otherwise, evaluates the inverse <code>qnorm(pfun(x, param))</code> instead.
</p>
</li></ul>


<h3>See Also</h3>

<p><a href="#topic+bru_mapper">bru_mapper</a>, <a href="#topic+bru_mapper_generics">bru_mapper_generics</a>
</p>
<p>Other mappers: 
<code><a href="#topic+bru_get_mapper">bru_get_mapper</a>()</code>,
<code><a href="#topic+bru_mapper">bru_mapper</a>()</code>,
<code><a href="#topic+bru_mapper.fm_mesh_1d">bru_mapper.fm_mesh_1d</a>()</code>,
<code><a href="#topic+bru_mapper.fm_mesh_2d">bru_mapper.fm_mesh_2d</a>()</code>,
<code><a href="#topic+bru_mapper_aggregate">bru_mapper_aggregate</a>()</code>,
<code><a href="#topic+bru_mapper_collect">bru_mapper_collect</a>()</code>,
<code><a href="#topic+bru_mapper_const">bru_mapper_const</a>()</code>,
<code><a href="#topic+bru_mapper_factor">bru_mapper_factor</a>()</code>,
<code><a href="#topic+bru_mapper_generics">bru_mapper_generics</a></code>,
<code><a href="#topic+bru_mapper_harmonics">bru_mapper_harmonics</a>()</code>,
<code><a href="#topic+bru_mapper_index">bru_mapper_index</a>()</code>,
<code><a href="#topic+bru_mapper_linear">bru_mapper_linear</a>()</code>,
<code><a href="#topic+bru_mapper_logsumexp">bru_mapper_logsumexp</a>()</code>,
<code><a href="#topic+bru_mapper_matrix">bru_mapper_matrix</a>()</code>,
<code><a href="#topic+bru_mapper_mesh_B">bru_mapper_mesh_B</a>()</code>,
<code><a href="#topic+bru_mapper_multi">bru_mapper_multi</a>()</code>,
<code><a href="#topic+bru_mapper_pipe">bru_mapper_pipe</a>()</code>,
<code><a href="#topic+bru_mapper_scale">bru_mapper_scale</a>()</code>,
<code><a href="#topic+bru_mapper_shift">bru_mapper_shift</a>()</code>,
<code><a href="#topic+bru_mapper_taylor">bru_mapper_taylor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- bru_mapper_marginal(qexp, pexp, rate = 1 / 8)
(val &lt;- ibm_eval(m, state = -5:5))
ibm_eval(m, state = val, reverse = TRUE)
m &lt;- bru_mapper_marginal(qexp, pexp, dexp, rate = 1 / 8)
ibm_eval2(m, state = -3:3)

</code></pre>

<hr>
<h2 id='bru_mapper_matrix'>Mapper for matrix multiplication</h2><span id='topic+bru_mapper_matrix'></span><span id='topic+ibm_n.bru_mapper_matrix'></span><span id='topic+ibm_values.bru_mapper_matrix'></span><span id='topic+ibm_jacobian.bru_mapper_matrix'></span>

<h3>Description</h3>

<p>Create a matrix mapper, for a given number of columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_mapper_matrix(labels)

## S3 method for class 'bru_mapper_matrix'
ibm_n(mapper, ...)

## S3 method for class 'bru_mapper_matrix'
ibm_values(mapper, ...)

## S3 method for class 'bru_mapper_matrix'
ibm_jacobian(mapper, input, state = NULL, inla_f = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_mapper_matrix_+3A_labels">labels</code></td>
<td>
<p>Column labels for matrix mappings; Can be factor, character,
or a single integer specifying the number of columns for integer column indexing.</p>
</td></tr>
<tr><td><code id="bru_mapper_matrix_+3A_mapper">mapper</code></td>
<td>
<p>A mapper S3 object, inheriting from <code>bru_mapper</code>.</p>
</td></tr>
<tr><td><code id="bru_mapper_matrix_+3A_...">...</code></td>
<td>
<p>Arguments passed on to other methods</p>
</td></tr>
<tr><td><code id="bru_mapper_matrix_+3A_input">input</code></td>
<td>
<p>Data input for the mapper.</p>
</td></tr>
<tr><td><code id="bru_mapper_matrix_+3A_state">state</code></td>
<td>
<p>A vector of latent state values for the mapping,
of length <code>ibm_n(mapper, inla_f = FALSE)</code></p>
</td></tr>
<tr><td><code id="bru_mapper_matrix_+3A_inla_f">inla_f</code></td>
<td>
<p>logical; when <code>TRUE</code> for <code>ibm_n()</code> and <code>ibm_values()</code>, the
result must be compatible with the <code>INLA::f(...)</code> and corresponding
<code>INLA::inla.stack(...)</code> constructions.  For <code style="white-space: pre;">&#8288;ibm_{eval,jacobian,linear}&#8288;</code>,
the <code>input</code> interpretation may be different.
Implementations do not normally need to do anything different, except
for mappers of the type needed for hidden multicomponent models such
as &quot;bym2&quot;, which can be handled by <code>bru_mapper_collect</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+bru_mapper">bru_mapper</a>, <a href="#topic+bru_mapper_generics">bru_mapper_generics</a>
</p>
<p>Other mappers: 
<code><a href="#topic+bru_get_mapper">bru_get_mapper</a>()</code>,
<code><a href="#topic+bru_mapper">bru_mapper</a>()</code>,
<code><a href="#topic+bru_mapper.fm_mesh_1d">bru_mapper.fm_mesh_1d</a>()</code>,
<code><a href="#topic+bru_mapper.fm_mesh_2d">bru_mapper.fm_mesh_2d</a>()</code>,
<code><a href="#topic+bru_mapper_aggregate">bru_mapper_aggregate</a>()</code>,
<code><a href="#topic+bru_mapper_collect">bru_mapper_collect</a>()</code>,
<code><a href="#topic+bru_mapper_const">bru_mapper_const</a>()</code>,
<code><a href="#topic+bru_mapper_factor">bru_mapper_factor</a>()</code>,
<code><a href="#topic+bru_mapper_generics">bru_mapper_generics</a></code>,
<code><a href="#topic+bru_mapper_harmonics">bru_mapper_harmonics</a>()</code>,
<code><a href="#topic+bru_mapper_index">bru_mapper_index</a>()</code>,
<code><a href="#topic+bru_mapper_linear">bru_mapper_linear</a>()</code>,
<code><a href="#topic+bru_mapper_logsumexp">bru_mapper_logsumexp</a>()</code>,
<code><a href="#topic+bru_mapper_marginal">bru_mapper_marginal</a>()</code>,
<code><a href="#topic+bru_mapper_mesh_B">bru_mapper_mesh_B</a>()</code>,
<code><a href="#topic+bru_mapper_multi">bru_mapper_multi</a>()</code>,
<code><a href="#topic+bru_mapper_pipe">bru_mapper_pipe</a>()</code>,
<code><a href="#topic+bru_mapper_scale">bru_mapper_scale</a>()</code>,
<code><a href="#topic+bru_mapper_shift">bru_mapper_shift</a>()</code>,
<code><a href="#topic+bru_mapper_taylor">bru_mapper_taylor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- bru_mapper_matrix(labels = c("a", "b"))
ibm_values(m)
ibm_eval2(m, input = matrix(1:6, 3, 2), state = 2:3)

m &lt;- bru_mapper_matrix(labels = 2L)
ibm_values(m)
ibm_eval2(m, input = matrix(1:6, 3, 2), state = 2:3)

</code></pre>

<hr>
<h2 id='bru_mapper_mesh_B'>Mapper for basis conversion</h2><span id='topic+bru_mapper_mesh_B'></span><span id='topic+ibm_n.bru_mapper_mesh_B'></span><span id='topic+ibm_values.bru_mapper_mesh_B'></span><span id='topic+ibm_jacobian.bru_mapper_mesh_B'></span>

<h3>Description</h3>

<p>Creates a mapper for handling basis conversions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_mapper_mesh_B(mesh, B)

## S3 method for class 'bru_mapper_mesh_B'
ibm_n(mapper, ...)

## S3 method for class 'bru_mapper_mesh_B'
ibm_values(mapper, ...)

## S3 method for class 'bru_mapper_mesh_B'
ibm_jacobian(mapper, input, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_mapper_mesh_B_+3A_mesh">mesh</code></td>
<td>
<p>object supported by <code>bru_mapper</code>, typically <code>fm_mesh_2d</code> or
<code>fm_mesh_1d</code></p>
</td></tr>
<tr><td><code id="bru_mapper_mesh_B_+3A_b">B</code></td>
<td>
<p>a square or tall basis conversion matrix</p>
</td></tr>
<tr><td><code id="bru_mapper_mesh_B_+3A_mapper">mapper</code></td>
<td>
<p>A mapper S3 object, inheriting from <code>bru_mapper</code>.</p>
</td></tr>
<tr><td><code id="bru_mapper_mesh_B_+3A_...">...</code></td>
<td>
<p>Arguments passed on to other methods</p>
</td></tr>
<tr><td><code id="bru_mapper_mesh_B_+3A_input">input</code></td>
<td>
<p>The values for which to produce a mapping matrix</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+bru_mapper">bru_mapper</a>, <a href="#topic+bru_mapper_generics">bru_mapper_generics</a>
</p>
<p>Other mappers: 
<code><a href="#topic+bru_get_mapper">bru_get_mapper</a>()</code>,
<code><a href="#topic+bru_mapper">bru_mapper</a>()</code>,
<code><a href="#topic+bru_mapper.fm_mesh_1d">bru_mapper.fm_mesh_1d</a>()</code>,
<code><a href="#topic+bru_mapper.fm_mesh_2d">bru_mapper.fm_mesh_2d</a>()</code>,
<code><a href="#topic+bru_mapper_aggregate">bru_mapper_aggregate</a>()</code>,
<code><a href="#topic+bru_mapper_collect">bru_mapper_collect</a>()</code>,
<code><a href="#topic+bru_mapper_const">bru_mapper_const</a>()</code>,
<code><a href="#topic+bru_mapper_factor">bru_mapper_factor</a>()</code>,
<code><a href="#topic+bru_mapper_generics">bru_mapper_generics</a></code>,
<code><a href="#topic+bru_mapper_harmonics">bru_mapper_harmonics</a>()</code>,
<code><a href="#topic+bru_mapper_index">bru_mapper_index</a>()</code>,
<code><a href="#topic+bru_mapper_linear">bru_mapper_linear</a>()</code>,
<code><a href="#topic+bru_mapper_logsumexp">bru_mapper_logsumexp</a>()</code>,
<code><a href="#topic+bru_mapper_marginal">bru_mapper_marginal</a>()</code>,
<code><a href="#topic+bru_mapper_matrix">bru_mapper_matrix</a>()</code>,
<code><a href="#topic+bru_mapper_multi">bru_mapper_multi</a>()</code>,
<code><a href="#topic+bru_mapper_pipe">bru_mapper_pipe</a>()</code>,
<code><a href="#topic+bru_mapper_scale">bru_mapper_scale</a>()</code>,
<code><a href="#topic+bru_mapper_shift">bru_mapper_shift</a>()</code>,
<code><a href="#topic+bru_mapper_taylor">bru_mapper_taylor</a>()</code>
</p>

<hr>
<h2 id='bru_mapper_multi'>Mapper for tensor product domains</h2><span id='topic+bru_mapper_multi'></span><span id='topic+ibm_n.bru_mapper_multi'></span><span id='topic+ibm_n_output.bru_mapper_multi'></span><span id='topic+ibm_values.bru_mapper_multi'></span><span id='topic+ibm_is_linear.bru_mapper_multi'></span><span id='topic+ibm_jacobian.bru_mapper_multi'></span><span id='topic+ibm_linear.bru_mapper_multi'></span><span id='topic+ibm_eval.bru_mapper_multi'></span><span id='topic+ibm_invalid_output.bru_mapper_multi'></span><span id='topic++5B.bru_mapper_multi'></span><span id='topic+ibm_names.bru_mapper_multi'></span><span id='topic+ibm_names+3C-.bru_mapper_multi'></span>

<h3>Description</h3>

<p>Constructs a rowwise Kronecker product mapping
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_mapper_multi(mappers)

## S3 method for class 'bru_mapper_multi'
ibm_n(mapper, inla_f = FALSE, multi = FALSE, ...)

## S3 method for class 'bru_mapper_multi'
ibm_n_output(mapper, input, ...)

## S3 method for class 'bru_mapper_multi'
ibm_values(mapper, inla_f = FALSE, multi = FALSE, ...)

## S3 method for class 'bru_mapper_multi'
ibm_is_linear(mapper, multi = FALSE, ...)

## S3 method for class 'bru_mapper_multi'
ibm_jacobian(
  mapper,
  input,
  state = NULL,
  inla_f = FALSE,
  multi = FALSE,
  ...,
  sub_A = NULL
)

## S3 method for class 'bru_mapper_multi'
ibm_linear(mapper, input, state, inla_f = FALSE, ...)

## S3 method for class 'bru_mapper_multi'
ibm_eval(
  mapper,
  input,
  state = NULL,
  inla_f = FALSE,
  ...,
  jacobian = NULL,
  pre_A = deprecated()
)

## S3 method for class 'bru_mapper_multi'
ibm_invalid_output(mapper, input, state, inla_f = FALSE, multi = FALSE, ...)

## S3 method for class 'bru_mapper_multi'
x[i, drop = TRUE]

## S3 method for class 'bru_mapper_multi'
ibm_names(mapper)

## S3 replacement method for class 'bru_mapper_multi'
ibm_names(mapper) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_mapper_multi_+3A_mappers">mappers</code></td>
<td>
<p>A list of <code>bru_mapper</code> objects</p>
</td></tr>
<tr><td><code id="bru_mapper_multi_+3A_mapper">mapper</code></td>
<td>
<p>A mapper S3 object, inheriting from <code>bru_mapper</code>.</p>
</td></tr>
<tr><td><code id="bru_mapper_multi_+3A_inla_f">inla_f</code></td>
<td>
<p>logical; when <code>TRUE</code> for <code>ibm_n()</code> and <code>ibm_values()</code>, the
result must be compatible with the <code>INLA::f(...)</code> and corresponding
<code>INLA::inla.stack(...)</code> constructions.  For <code style="white-space: pre;">&#8288;ibm_{eval,jacobian,linear}&#8288;</code>,
the <code>input</code> interpretation may be different.
Implementations do not normally need to do anything different, except
for mappers of the type needed for hidden multicomponent models such
as &quot;bym2&quot;, which can be handled by <code>bru_mapper_collect</code>.</p>
</td></tr>
<tr><td><code id="bru_mapper_multi_+3A_multi">multi</code></td>
<td>
<p>logical;
If <code>TRUE</code> (or positive), recurse one level into sub-mappers</p>
</td></tr>
<tr><td><code id="bru_mapper_multi_+3A_...">...</code></td>
<td>
<p>Arguments passed on to other methods</p>
</td></tr>
<tr><td><code id="bru_mapper_multi_+3A_input">input</code></td>
<td>
<p>Data input for the mapper.</p>
</td></tr>
<tr><td><code id="bru_mapper_multi_+3A_state">state</code></td>
<td>
<p>A vector of latent state values for the mapping,
of length <code>ibm_n(mapper, inla_f = FALSE)</code></p>
</td></tr>
<tr><td><code id="bru_mapper_multi_+3A_sub_a">sub_A</code></td>
<td>
<p>Internal; precomputed Jacobian matrices.</p>
</td></tr>
<tr><td><code id="bru_mapper_multi_+3A_jacobian">jacobian</code></td>
<td>
<p>For <code>ibm_eval()</code> methods, an optional pre-computed Jacobian, typically
supplied by internal methods that already have the Jacobian.</p>
</td></tr>
<tr><td><code id="bru_mapper_multi_+3A_pre_a">pre_A</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> in favour of <code>jacobian</code>.</p>
</td></tr>
<tr><td><code id="bru_mapper_multi_+3A_x">x</code></td>
<td>
<p>object from which to extract element(s)</p>
</td></tr>
<tr><td><code id="bru_mapper_multi_+3A_i">i</code></td>
<td>
<p>indices specifying element(s) to extract</p>
</td></tr>
<tr><td><code id="bru_mapper_multi_+3A_drop">drop</code></td>
<td>
<p>logical;
For <code style="white-space: pre;">&#8288;[.bru_mapper_multi&#8288;</code>, whether to extract an individual mapper when
<code>i</code> identifies a single element. If <code>FALSE</code>, a list of sub-mappers is
returned (suitable e.g. for creating a new <code>bru_mapper_multi</code> object).
Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="bru_mapper_multi_+3A_value">value</code></td>
<td>
<p>a character vector of up to the same length as the number
of mappers in the multi-mapper x</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>ibm_jacobian</code> for <code>bru_mapper_multi</code> accepts a list with
named entries, or a list with unnamed but ordered elements.
The names must match the sub-mappers, see <code><a href="#topic+ibm_names.bru_mapper_multi">ibm_names.bru_mapper_multi()</a></code>.
Each list element should take a format accepted by the corresponding
sub-mapper. In case each element is a vector, the input can be given as a
data.frame with named columns, a matrix with named columns, or a matrix
with unnamed but ordered columns.
</p>
</li></ul>


<ul>
<li> <p><code>ibm_invalid_output</code> for <code>bru_mapper_multi</code> accepts a list with
named entries, or a list with unnamed but ordered elements.
The names must match the sub-mappers, see <code><a href="#topic+ibm_names.bru_mapper_multi">ibm_names.bru_mapper_multi()</a></code>.
Each list element should take a format accepted by the corresponding
sub-mapper. In case each element is a vector, the input can be given as a
data.frame with named columns, a matrix with named columns, or a matrix
with unnamed but ordered columns.
</p>
</li></ul>



<h3>Value</h3>


<ul>
<li> <p><code>[</code>-indexing a <code>bru_mapper_multi</code> extracts a subset
<code>bru_mapper_multi</code> object (for drop <code>FALSE</code>) or an individual sub-mapper
(for drop <code>TRUE</code>, and <code>i</code> identifies a single element)
</p>
</li></ul>



<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>ibm_names(bru_mapper_multi)</code>: Returns the names from the sub-mappers list
</p>
</li></ul>


<h3>See Also</h3>

<p><a href="#topic+bru_mapper">bru_mapper</a>, <a href="#topic+bru_mapper_generics">bru_mapper_generics</a>
</p>
<p>Other mappers: 
<code><a href="#topic+bru_get_mapper">bru_get_mapper</a>()</code>,
<code><a href="#topic+bru_mapper">bru_mapper</a>()</code>,
<code><a href="#topic+bru_mapper.fm_mesh_1d">bru_mapper.fm_mesh_1d</a>()</code>,
<code><a href="#topic+bru_mapper.fm_mesh_2d">bru_mapper.fm_mesh_2d</a>()</code>,
<code><a href="#topic+bru_mapper_aggregate">bru_mapper_aggregate</a>()</code>,
<code><a href="#topic+bru_mapper_collect">bru_mapper_collect</a>()</code>,
<code><a href="#topic+bru_mapper_const">bru_mapper_const</a>()</code>,
<code><a href="#topic+bru_mapper_factor">bru_mapper_factor</a>()</code>,
<code><a href="#topic+bru_mapper_generics">bru_mapper_generics</a></code>,
<code><a href="#topic+bru_mapper_harmonics">bru_mapper_harmonics</a>()</code>,
<code><a href="#topic+bru_mapper_index">bru_mapper_index</a>()</code>,
<code><a href="#topic+bru_mapper_linear">bru_mapper_linear</a>()</code>,
<code><a href="#topic+bru_mapper_logsumexp">bru_mapper_logsumexp</a>()</code>,
<code><a href="#topic+bru_mapper_marginal">bru_mapper_marginal</a>()</code>,
<code><a href="#topic+bru_mapper_matrix">bru_mapper_matrix</a>()</code>,
<code><a href="#topic+bru_mapper_mesh_B">bru_mapper_mesh_B</a>()</code>,
<code><a href="#topic+bru_mapper_pipe">bru_mapper_pipe</a>()</code>,
<code><a href="#topic+bru_mapper_scale">bru_mapper_scale</a>()</code>,
<code><a href="#topic+bru_mapper_shift">bru_mapper_shift</a>()</code>,
<code><a href="#topic+bru_mapper_taylor">bru_mapper_taylor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(m &lt;- bru_mapper_multi(list(
  a = bru_mapper_index(2),
  b = bru_mapper_index(3)
)))
ibm_eval2(m, list(a = c(1, 2, 1), b = c(1, 3, 2)), 1:6)

</code></pre>

<hr>
<h2 id='bru_mapper_pipe'>Mapper for linking several mappers in sequence</h2><span id='topic+bru_mapper_pipe'></span><span id='topic+ibm_n.bru_mapper_pipe'></span><span id='topic+ibm_n_output.bru_mapper_pipe'></span><span id='topic+ibm_values.bru_mapper_pipe'></span><span id='topic+ibm_jacobian.bru_mapper_pipe'></span><span id='topic+ibm_eval.bru_mapper_pipe'></span><span id='topic+ibm_eval2.bru_mapper_pipe'></span><span id='topic+ibm_simplify.bru_mapper_pipe'></span>

<h3>Description</h3>

<p>Create a pipe mapper, where <code>mappers</code> is a list of mappers,
and the evaluated output of each mapper is handed as the state to the next
mapper.
The <code>input</code> format for the <code>ibm_eval</code> and <code>ibm_jacobian</code> methods is
a list of inputs, one for each mapper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_mapper_pipe(mappers)

## S3 method for class 'bru_mapper_pipe'
ibm_n(mapper, ..., input = NULL, state = NULL)

## S3 method for class 'bru_mapper_pipe'
ibm_n_output(mapper, input, state = NULL, ..., n_state = NULL)

## S3 method for class 'bru_mapper_pipe'
ibm_values(mapper, ...)

## S3 method for class 'bru_mapper_pipe'
ibm_jacobian(mapper, input, state = NULL, ...)

## S3 method for class 'bru_mapper_pipe'
ibm_eval(mapper, input, state = NULL, ...)

## S3 method for class 'bru_mapper_pipe'
ibm_eval2(mapper, input, state = NULL, ...)

## S3 method for class 'bru_mapper_pipe'
ibm_simplify(
  mapper,
  input = NULL,
  state = NULL,
  inla_f = FALSE,
  ...,
  n_state = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_mapper_pipe_+3A_mappers">mappers</code></td>
<td>
<p>A list of <code>bru_mapper</code> objects</p>
</td></tr>
<tr><td><code id="bru_mapper_pipe_+3A_mapper">mapper</code></td>
<td>
<p>A mapper S3 object, inheriting from <code>bru_mapper</code>.</p>
</td></tr>
<tr><td><code id="bru_mapper_pipe_+3A_...">...</code></td>
<td>
<p>Arguments passed on to other methods</p>
</td></tr>
<tr><td><code id="bru_mapper_pipe_+3A_input">input</code></td>
<td>
<p>Data input for the mapper.</p>
</td></tr>
<tr><td><code id="bru_mapper_pipe_+3A_state">state</code></td>
<td>
<p>A vector of latent state values for the mapping,
of length <code>ibm_n(mapper, inla_f = FALSE)</code></p>
</td></tr>
<tr><td><code id="bru_mapper_pipe_+3A_n_state">n_state</code></td>
<td>
<p>integer giving the length of the state vector for mappers
that have state dependent output size.</p>
</td></tr>
<tr><td><code id="bru_mapper_pipe_+3A_inla_f">inla_f</code></td>
<td>
<p>logical; when <code>TRUE</code> for <code>ibm_n()</code> and <code>ibm_values()</code>, the
result must be compatible with the <code>INLA::f(...)</code> and corresponding
<code>INLA::inla.stack(...)</code> constructions.  For <code style="white-space: pre;">&#8288;ibm_{eval,jacobian,linear}&#8288;</code>,
the <code>input</code> interpretation may be different.
Implementations do not normally need to do anything different, except
for mappers of the type needed for hidden multicomponent models such
as &quot;bym2&quot;, which can be handled by <code>bru_mapper_collect</code>.</p>
</td></tr>
</table>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>ibm_simplify(bru_mapper_pipe)</code>: Constructs a simplified <code>pipe</code> mapper. For fully linear pipes, calls <code><a href="#topic+ibm_linear">ibm_linear()</a></code>.
For partially non-linear pipes, replaces each sequence of linear mappers with a single
<code><a href="#topic+bru_mapper_taylor">bru_mapper_taylor()</a></code> mapper, while keeping the full list of original mapper
names, allowing the original <code>input</code> structure to be used also with the simplified
mappers, since the <code>taylor</code> mappers are not dependent on inputs.
</p>
</li></ul>


<h3>See Also</h3>

<p><a href="#topic+bru_mapper">bru_mapper</a>, <a href="#topic+bru_mapper_generics">bru_mapper_generics</a>
</p>
<p>Other mappers: 
<code><a href="#topic+bru_get_mapper">bru_get_mapper</a>()</code>,
<code><a href="#topic+bru_mapper">bru_mapper</a>()</code>,
<code><a href="#topic+bru_mapper.fm_mesh_1d">bru_mapper.fm_mesh_1d</a>()</code>,
<code><a href="#topic+bru_mapper.fm_mesh_2d">bru_mapper.fm_mesh_2d</a>()</code>,
<code><a href="#topic+bru_mapper_aggregate">bru_mapper_aggregate</a>()</code>,
<code><a href="#topic+bru_mapper_collect">bru_mapper_collect</a>()</code>,
<code><a href="#topic+bru_mapper_const">bru_mapper_const</a>()</code>,
<code><a href="#topic+bru_mapper_factor">bru_mapper_factor</a>()</code>,
<code><a href="#topic+bru_mapper_generics">bru_mapper_generics</a></code>,
<code><a href="#topic+bru_mapper_harmonics">bru_mapper_harmonics</a>()</code>,
<code><a href="#topic+bru_mapper_index">bru_mapper_index</a>()</code>,
<code><a href="#topic+bru_mapper_linear">bru_mapper_linear</a>()</code>,
<code><a href="#topic+bru_mapper_logsumexp">bru_mapper_logsumexp</a>()</code>,
<code><a href="#topic+bru_mapper_marginal">bru_mapper_marginal</a>()</code>,
<code><a href="#topic+bru_mapper_matrix">bru_mapper_matrix</a>()</code>,
<code><a href="#topic+bru_mapper_mesh_B">bru_mapper_mesh_B</a>()</code>,
<code><a href="#topic+bru_mapper_multi">bru_mapper_multi</a>()</code>,
<code><a href="#topic+bru_mapper_scale">bru_mapper_scale</a>()</code>,
<code><a href="#topic+bru_mapper_shift">bru_mapper_shift</a>()</code>,
<code><a href="#topic+bru_mapper_taylor">bru_mapper_taylor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- bru_mapper_pipe(list(
  scale = bru_mapper_scale(),
  shift = bru_mapper_shift()
))
ibm_eval2(m, input = list(scale = 2, shift = 1:4), state = 1:4)

</code></pre>

<hr>
<h2 id='bru_mapper_scale'>Mapper for element-wise scaling</h2><span id='topic+bru_mapper_scale'></span><span id='topic+ibm_n.bru_mapper_scale'></span><span id='topic+ibm_n_output.bru_mapper_scale'></span><span id='topic+ibm_values.bru_mapper_scale'></span><span id='topic+ibm_jacobian.bru_mapper_scale'></span><span id='topic+ibm_eval.bru_mapper_scale'></span>

<h3>Description</h3>

<p>Create a standalone
scaling mapper that can be used as part of a <code>bru_mapper_pipe</code>.
If <code>mapper</code> is non-null, the <code>bru_mapper_scale()</code> constructor
returns
<code>bru_mapper_pipe(list(mapper = mapper, scale = bru_mapper_scale()))</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_mapper_scale(mapper = NULL)

## S3 method for class 'bru_mapper_scale'
ibm_n(mapper, ..., state = NULL, n_state = NULL)

## S3 method for class 'bru_mapper_scale'
ibm_n_output(mapper, input, state = NULL, ..., n_state = NULL)

## S3 method for class 'bru_mapper_scale'
ibm_values(mapper, ..., state = NULL, n_state = NULL)

## S3 method for class 'bru_mapper_scale'
ibm_jacobian(mapper, input, state = NULL, ..., sub_lin = NULL)

## S3 method for class 'bru_mapper_scale'
ibm_eval(mapper, input, state = NULL, ..., sub_lin = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_mapper_scale_+3A_mapper">mapper</code></td>
<td>
<p>A mapper S3 object, inheriting from <code>bru_mapper</code>.</p>
</td></tr>
<tr><td><code id="bru_mapper_scale_+3A_...">...</code></td>
<td>
<p>Arguments passed on to other methods</p>
</td></tr>
<tr><td><code id="bru_mapper_scale_+3A_state">state</code></td>
<td>
<p>A vector of latent state values for the mapping,
of length <code>ibm_n(mapper, inla_f = FALSE)</code></p>
</td></tr>
<tr><td><code id="bru_mapper_scale_+3A_n_state">n_state</code></td>
<td>
<p>integer giving the length of the state vector for mappers
that have state dependent output size.</p>
</td></tr>
<tr><td><code id="bru_mapper_scale_+3A_input">input</code></td>
<td>
<p>Data input for the mapper.</p>
</td></tr>
<tr><td><code id="bru_mapper_scale_+3A_sub_lin">sub_lin</code></td>
<td>
<p>Internal, optional pre-computed sub-mapper information</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>bru_mapper_scale</code>, <code>input</code> NULL values
are interpreted as no scaling.
</p>


<h3>See Also</h3>

<p><a href="#topic+bru_mapper">bru_mapper</a>, <a href="#topic+bru_mapper_generics">bru_mapper_generics</a>
</p>
<p>Other mappers: 
<code><a href="#topic+bru_get_mapper">bru_get_mapper</a>()</code>,
<code><a href="#topic+bru_mapper">bru_mapper</a>()</code>,
<code><a href="#topic+bru_mapper.fm_mesh_1d">bru_mapper.fm_mesh_1d</a>()</code>,
<code><a href="#topic+bru_mapper.fm_mesh_2d">bru_mapper.fm_mesh_2d</a>()</code>,
<code><a href="#topic+bru_mapper_aggregate">bru_mapper_aggregate</a>()</code>,
<code><a href="#topic+bru_mapper_collect">bru_mapper_collect</a>()</code>,
<code><a href="#topic+bru_mapper_const">bru_mapper_const</a>()</code>,
<code><a href="#topic+bru_mapper_factor">bru_mapper_factor</a>()</code>,
<code><a href="#topic+bru_mapper_generics">bru_mapper_generics</a></code>,
<code><a href="#topic+bru_mapper_harmonics">bru_mapper_harmonics</a>()</code>,
<code><a href="#topic+bru_mapper_index">bru_mapper_index</a>()</code>,
<code><a href="#topic+bru_mapper_linear">bru_mapper_linear</a>()</code>,
<code><a href="#topic+bru_mapper_logsumexp">bru_mapper_logsumexp</a>()</code>,
<code><a href="#topic+bru_mapper_marginal">bru_mapper_marginal</a>()</code>,
<code><a href="#topic+bru_mapper_matrix">bru_mapper_matrix</a>()</code>,
<code><a href="#topic+bru_mapper_mesh_B">bru_mapper_mesh_B</a>()</code>,
<code><a href="#topic+bru_mapper_multi">bru_mapper_multi</a>()</code>,
<code><a href="#topic+bru_mapper_pipe">bru_mapper_pipe</a>()</code>,
<code><a href="#topic+bru_mapper_shift">bru_mapper_shift</a>()</code>,
<code><a href="#topic+bru_mapper_taylor">bru_mapper_taylor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- bru_mapper_scale()
ibm_eval2(m, c(1, 2, 1, 2), 1:4)

</code></pre>

<hr>
<h2 id='bru_mapper_shift'>Mapper for element-wise shifting</h2><span id='topic+bru_mapper_shift'></span><span id='topic+ibm_n.bru_mapper_shift'></span><span id='topic+ibm_n_output.bru_mapper_shift'></span><span id='topic+ibm_values.bru_mapper_shift'></span><span id='topic+ibm_jacobian.bru_mapper_shift'></span><span id='topic+ibm_eval.bru_mapper_shift'></span>

<h3>Description</h3>

<p>Create a standalone
shift mapper that can be used as part of a <code>bru_mapper_pipe</code>.
If <code>mapper</code> is non-null, the <code>bru_mapper_shift()</code> constructor
returns
<code>bru_mapper_pipe(list(mapper = mapper, shift = bru_mapper_shift()))</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_mapper_shift(mapper = NULL)

## S3 method for class 'bru_mapper_shift'
ibm_n(mapper, ..., state = NULL, n_state = NULL)

## S3 method for class 'bru_mapper_shift'
ibm_n_output(mapper, input, state = NULL, ..., n_state = NULL)

## S3 method for class 'bru_mapper_shift'
ibm_values(mapper, ..., state = NULL, n_state = NULL)

## S3 method for class 'bru_mapper_shift'
ibm_jacobian(mapper, input, state = NULL, ..., sub_lin = NULL)

## S3 method for class 'bru_mapper_shift'
ibm_eval(mapper, input, state = NULL, ..., sub_lin = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_mapper_shift_+3A_mapper">mapper</code></td>
<td>
<p>A mapper S3 object, inheriting from <code>bru_mapper</code>.</p>
</td></tr>
<tr><td><code id="bru_mapper_shift_+3A_...">...</code></td>
<td>
<p>Arguments passed on to other methods</p>
</td></tr>
<tr><td><code id="bru_mapper_shift_+3A_state">state</code></td>
<td>
<p>A vector of latent state values for the mapping,
of length <code>ibm_n(mapper, inla_f = FALSE)</code></p>
</td></tr>
<tr><td><code id="bru_mapper_shift_+3A_n_state">n_state</code></td>
<td>
<p>integer giving the length of the state vector for mappers
that have state dependent output size.</p>
</td></tr>
<tr><td><code id="bru_mapper_shift_+3A_input">input</code></td>
<td>
<p>Data input for the mapper.</p>
</td></tr>
<tr><td><code id="bru_mapper_shift_+3A_sub_lin">sub_lin</code></td>
<td>
<p>Internal, optional pre-computed sub-mapper information</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>bru_mapper_shift</code>, <code>input</code> NULL values are interpreted as no shift.
</p>


<h3>See Also</h3>

<p><a href="#topic+bru_mapper">bru_mapper</a>, <a href="#topic+bru_mapper_generics">bru_mapper_generics</a>
</p>
<p>Other mappers: 
<code><a href="#topic+bru_get_mapper">bru_get_mapper</a>()</code>,
<code><a href="#topic+bru_mapper">bru_mapper</a>()</code>,
<code><a href="#topic+bru_mapper.fm_mesh_1d">bru_mapper.fm_mesh_1d</a>()</code>,
<code><a href="#topic+bru_mapper.fm_mesh_2d">bru_mapper.fm_mesh_2d</a>()</code>,
<code><a href="#topic+bru_mapper_aggregate">bru_mapper_aggregate</a>()</code>,
<code><a href="#topic+bru_mapper_collect">bru_mapper_collect</a>()</code>,
<code><a href="#topic+bru_mapper_const">bru_mapper_const</a>()</code>,
<code><a href="#topic+bru_mapper_factor">bru_mapper_factor</a>()</code>,
<code><a href="#topic+bru_mapper_generics">bru_mapper_generics</a></code>,
<code><a href="#topic+bru_mapper_harmonics">bru_mapper_harmonics</a>()</code>,
<code><a href="#topic+bru_mapper_index">bru_mapper_index</a>()</code>,
<code><a href="#topic+bru_mapper_linear">bru_mapper_linear</a>()</code>,
<code><a href="#topic+bru_mapper_logsumexp">bru_mapper_logsumexp</a>()</code>,
<code><a href="#topic+bru_mapper_marginal">bru_mapper_marginal</a>()</code>,
<code><a href="#topic+bru_mapper_matrix">bru_mapper_matrix</a>()</code>,
<code><a href="#topic+bru_mapper_mesh_B">bru_mapper_mesh_B</a>()</code>,
<code><a href="#topic+bru_mapper_multi">bru_mapper_multi</a>()</code>,
<code><a href="#topic+bru_mapper_pipe">bru_mapper_pipe</a>()</code>,
<code><a href="#topic+bru_mapper_scale">bru_mapper_scale</a>()</code>,
<code><a href="#topic+bru_mapper_taylor">bru_mapper_taylor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- bru_mapper_shift()
ibm_eval2(m, c(1, 2, 1, 2), 1:4)

</code></pre>

<hr>
<h2 id='bru_mapper_taylor'>Mapper for linear Taylor approximations</h2><span id='topic+bru_mapper_taylor'></span><span id='topic+ibm_n.bru_mapper_taylor'></span><span id='topic+ibm_n_output.bru_mapper_taylor'></span><span id='topic+ibm_values.bru_mapper_taylor'></span><span id='topic+ibm_jacobian.bru_mapper_taylor'></span><span id='topic+ibm_eval.bru_mapper_taylor'></span>

<h3>Description</h3>

<p>Provides a pre-computed affine mapping,
internally used to represent and evaluate linearisation information.
The <code>state0</code> information indicates for which state the <code>offset</code> was evaluated;
The affine mapper output is defined as
<code>effect(state) = offset + jacobian %*% (state - state0)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_mapper_taylor(
  offset = NULL,
  jacobian = NULL,
  state0 = NULL,
  values_mapper = NULL
)

## S3 method for class 'bru_mapper_taylor'
ibm_n(mapper, inla_f = FALSE, multi = FALSE, ...)

## S3 method for class 'bru_mapper_taylor'
ibm_n_output(mapper, input, ...)

## S3 method for class 'bru_mapper_taylor'
ibm_values(mapper, inla_f = FALSE, multi = FALSE, ...)

## S3 method for class 'bru_mapper_taylor'
ibm_jacobian(mapper, ..., multi = FALSE)

## S3 method for class 'bru_mapper_taylor'
ibm_eval(mapper, input = NULL, state = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_mapper_taylor_+3A_offset">offset</code></td>
<td>
<p>For <code>bru_mapper_taylor</code>, an offset vector evaluated
at <code>state0</code>.
May be <code>NULL</code>, interpreted as an all-zero vector of length determined by
a non-null Jacobian.</p>
</td></tr>
<tr><td><code id="bru_mapper_taylor_+3A_jacobian">jacobian</code></td>
<td>
<p>For <code>bru_mapper_taylor()</code>, the Jacobian matrix,
evaluated at <code>state0</code>, or, a named list of such matrices.
May be <code>NULL</code> or an empty list, for a constant mapping.</p>
</td></tr>
<tr><td><code id="bru_mapper_taylor_+3A_state0">state0</code></td>
<td>
<p>For <code>bru_mapper_taylor</code>, the state the linearisation
was evaluated at, or a list of length matching the <code>jacobian</code> list.
<code>NULL</code> is interpreted as 0.</p>
</td></tr>
<tr><td><code id="bru_mapper_taylor_+3A_values_mapper">values_mapper</code></td>
<td>
<p>mapper object to be used for <code>ibm_n</code> and
<code>ibm_values</code> for <code>inla_f=TRUE</code> (experimental, currently unused)</p>
</td></tr>
<tr><td><code id="bru_mapper_taylor_+3A_mapper">mapper</code></td>
<td>
<p>A mapper S3 object, inheriting from <code>bru_mapper</code>.</p>
</td></tr>
<tr><td><code id="bru_mapper_taylor_+3A_inla_f">inla_f</code></td>
<td>
<p>logical; when <code>TRUE</code> for <code>ibm_n()</code> and <code>ibm_values()</code>, the
result must be compatible with the <code>INLA::f(...)</code> and corresponding
<code>INLA::inla.stack(...)</code> constructions.  For <code style="white-space: pre;">&#8288;ibm_{eval,jacobian,linear}&#8288;</code>,
the <code>input</code> interpretation may be different.
Implementations do not normally need to do anything different, except
for mappers of the type needed for hidden multicomponent models such
as &quot;bym2&quot;, which can be handled by <code>bru_mapper_collect</code>.</p>
</td></tr>
<tr><td><code id="bru_mapper_taylor_+3A_multi">multi</code></td>
<td>
<p>logical;
If <code>TRUE</code> (or positive), recurse one level into sub-mappers</p>
</td></tr>
<tr><td><code id="bru_mapper_taylor_+3A_...">...</code></td>
<td>
<p>Arguments passed on to other methods</p>
</td></tr>
<tr><td><code id="bru_mapper_taylor_+3A_input">input</code></td>
<td>
<p>Data input for the mapper.</p>
</td></tr>
<tr><td><code id="bru_mapper_taylor_+3A_state">state</code></td>
<td>
<p>A vector of latent state values for the mapping,
of length <code>ibm_n(mapper, inla_f = FALSE)</code></p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> The <code>ibm_eval.bru_mapper_taylor()</code> evaluates linearised
mapper information at the given <code>state</code>. The <code>input</code> argument is ignored,
so that the usual argument order
<code>ibm_eval(mapper, input, state)</code> syntax can be used, but also
<code>ibm_eval(mapper, state = state)</code>.  For a mapper with a named jacobian list,
the <code>state</code> argument must also be a named list.  If <code>state</code> is <code>NULL</code>,
all-zero is assumed.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+bru_mapper">bru_mapper</a>, <a href="#topic+bru_mapper_generics">bru_mapper_generics</a>
</p>
<p>Other mappers: 
<code><a href="#topic+bru_get_mapper">bru_get_mapper</a>()</code>,
<code><a href="#topic+bru_mapper">bru_mapper</a>()</code>,
<code><a href="#topic+bru_mapper.fm_mesh_1d">bru_mapper.fm_mesh_1d</a>()</code>,
<code><a href="#topic+bru_mapper.fm_mesh_2d">bru_mapper.fm_mesh_2d</a>()</code>,
<code><a href="#topic+bru_mapper_aggregate">bru_mapper_aggregate</a>()</code>,
<code><a href="#topic+bru_mapper_collect">bru_mapper_collect</a>()</code>,
<code><a href="#topic+bru_mapper_const">bru_mapper_const</a>()</code>,
<code><a href="#topic+bru_mapper_factor">bru_mapper_factor</a>()</code>,
<code><a href="#topic+bru_mapper_generics">bru_mapper_generics</a></code>,
<code><a href="#topic+bru_mapper_harmonics">bru_mapper_harmonics</a>()</code>,
<code><a href="#topic+bru_mapper_index">bru_mapper_index</a>()</code>,
<code><a href="#topic+bru_mapper_linear">bru_mapper_linear</a>()</code>,
<code><a href="#topic+bru_mapper_logsumexp">bru_mapper_logsumexp</a>()</code>,
<code><a href="#topic+bru_mapper_marginal">bru_mapper_marginal</a>()</code>,
<code><a href="#topic+bru_mapper_matrix">bru_mapper_matrix</a>()</code>,
<code><a href="#topic+bru_mapper_mesh_B">bru_mapper_mesh_B</a>()</code>,
<code><a href="#topic+bru_mapper_multi">bru_mapper_multi</a>()</code>,
<code><a href="#topic+bru_mapper_pipe">bru_mapper_pipe</a>()</code>,
<code><a href="#topic+bru_mapper_scale">bru_mapper_scale</a>()</code>,
<code><a href="#topic+bru_mapper_shift">bru_mapper_shift</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- bru_mapper_taylor(
  offset = rep(2, 3),
  jacobian = matrix(1:6, 3, 2),
  state0 = c(1, 2)
)
ibm_eval2(m, state = 2:3)
</code></pre>

<hr>
<h2 id='bru_mapper.fm_mesh_1d'>Mapper for <code>fm_mesh_1d</code></h2><span id='topic+bru_mapper.fm_mesh_1d'></span><span id='topic+ibm_n.bru_mapper_fm_mesh_1d'></span><span id='topic+ibm_values.bru_mapper_fm_mesh_1d'></span><span id='topic+ibm_jacobian.bru_mapper_fm_mesh_1d'></span><span id='topic+bru_mapper.inla.mesh.1d'></span><span id='topic+ibm_n.bru_mapper_inla_mesh_1d'></span><span id='topic+ibm_values.bru_mapper_inla_mesh_1d'></span><span id='topic+ibm_jacobian.bru_mapper_inla_mesh_1d'></span>

<h3>Description</h3>

<p>Create mapper for an <code>fm_mesh_1d</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fm_mesh_1d'
bru_mapper(mesh, indexed = NULL, ...)

## S3 method for class 'bru_mapper_fm_mesh_1d'
ibm_n(mapper, ...)

## S3 method for class 'bru_mapper_fm_mesh_1d'
ibm_values(mapper, ...)

## S3 method for class 'bru_mapper_fm_mesh_1d'
ibm_jacobian(mapper, input, ...)

## S3 method for class 'inla.mesh.1d'
bru_mapper(mesh, indexed = NULL, ...)

## S3 method for class 'bru_mapper_inla_mesh_1d'
ibm_n(mapper, ...)

## S3 method for class 'bru_mapper_inla_mesh_1d'
ibm_values(mapper, ...)

## S3 method for class 'bru_mapper_inla_mesh_1d'
ibm_jacobian(mapper, input, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_mapper.fm_mesh_1d_+3A_mesh">mesh</code></td>
<td>
<p>An <code>fm_mesh_1d</code> or <code>inla.mesh.1d</code> object to use as a mapper</p>
</td></tr>
<tr><td><code id="bru_mapper.fm_mesh_1d_+3A_indexed">indexed</code></td>
<td>
<p>logical; If <code>TRUE</code>, the <code>ibm_values()</code> output will be the
integer indexing sequence for the latent variables (needed for <code>spde</code> models).
If <code>FALSE</code>, the knot
locations are returned (useful as an interpolator for <code>rw2</code> models
and similar).
Default: <code>NULL</code>, to force user specification of this parameter</p>
</td></tr>
<tr><td><code id="bru_mapper.fm_mesh_1d_+3A_...">...</code></td>
<td>
<p>Arguments passed on to other methods</p>
</td></tr>
<tr><td><code id="bru_mapper.fm_mesh_1d_+3A_mapper">mapper</code></td>
<td>
<p>A mapper S3 object, inheriting from <code>bru_mapper</code>.</p>
</td></tr>
<tr><td><code id="bru_mapper.fm_mesh_1d_+3A_input">input</code></td>
<td>
<p>Data input for the mapper.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>bru_mapper(inla.mesh.1d)</code>: Create mapper for an <code>inla.mesh.1d</code> object; converts
the mesh fo <code>fm_mesh_1d</code> first.
</p>
</li></ul>


<h3>See Also</h3>

<p><a href="#topic+bru_mapper">bru_mapper</a>, <a href="#topic+bru_mapper_generics">bru_mapper_generics</a>
</p>
<p>Other mappers: 
<code><a href="#topic+bru_get_mapper">bru_get_mapper</a>()</code>,
<code><a href="#topic+bru_mapper">bru_mapper</a>()</code>,
<code><a href="#topic+bru_mapper.fm_mesh_2d">bru_mapper.fm_mesh_2d</a>()</code>,
<code><a href="#topic+bru_mapper_aggregate">bru_mapper_aggregate</a>()</code>,
<code><a href="#topic+bru_mapper_collect">bru_mapper_collect</a>()</code>,
<code><a href="#topic+bru_mapper_const">bru_mapper_const</a>()</code>,
<code><a href="#topic+bru_mapper_factor">bru_mapper_factor</a>()</code>,
<code><a href="#topic+bru_mapper_generics">bru_mapper_generics</a></code>,
<code><a href="#topic+bru_mapper_harmonics">bru_mapper_harmonics</a>()</code>,
<code><a href="#topic+bru_mapper_index">bru_mapper_index</a>()</code>,
<code><a href="#topic+bru_mapper_linear">bru_mapper_linear</a>()</code>,
<code><a href="#topic+bru_mapper_logsumexp">bru_mapper_logsumexp</a>()</code>,
<code><a href="#topic+bru_mapper_marginal">bru_mapper_marginal</a>()</code>,
<code><a href="#topic+bru_mapper_matrix">bru_mapper_matrix</a>()</code>,
<code><a href="#topic+bru_mapper_mesh_B">bru_mapper_mesh_B</a>()</code>,
<code><a href="#topic+bru_mapper_multi">bru_mapper_multi</a>()</code>,
<code><a href="#topic+bru_mapper_pipe">bru_mapper_pipe</a>()</code>,
<code><a href="#topic+bru_mapper_scale">bru_mapper_scale</a>()</code>,
<code><a href="#topic+bru_mapper_shift">bru_mapper_shift</a>()</code>,
<code><a href="#topic+bru_mapper_taylor">bru_mapper_taylor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- bru_mapper(fm_mesh_1d(c(1:3, 5, 7)), indexed = FALSE)
ibm_values(m)
ibm_eval(m, 1:7, 1:5)
m &lt;- bru_mapper(fm_mesh_1d(c(1:3, 5, 7)), indexed = TRUE)
ibm_values(m)
ibm_eval(m, 1:7, 1:5)

</code></pre>

<hr>
<h2 id='bru_mapper.fm_mesh_2d'>Mapper for <code>fm_mesh_2d</code></h2><span id='topic+bru_mapper.fm_mesh_2d'></span><span id='topic+ibm_n.bru_mapper_fm_mesh_2d'></span><span id='topic+ibm_values.bru_mapper_fm_mesh_2d'></span><span id='topic+ibm_jacobian.bru_mapper_fm_mesh_2d'></span><span id='topic+bru_mapper.inla.mesh'></span><span id='topic+ibm_n.bru_mapper_inla_mesh_2d'></span><span id='topic+ibm_values.bru_mapper_inla_mesh_2d'></span><span id='topic+ibm_jacobian.bru_mapper_inla_mesh_2d'></span>

<h3>Description</h3>

<p>Creates a mapper for 2D <code>fm_mesh_2d</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fm_mesh_2d'
bru_mapper(mesh, ...)

## S3 method for class 'bru_mapper_fm_mesh_2d'
ibm_n(mapper, ...)

## S3 method for class 'bru_mapper_fm_mesh_2d'
ibm_values(mapper, ...)

## S3 method for class 'bru_mapper_fm_mesh_2d'
ibm_jacobian(mapper, input, ...)

## S3 method for class 'inla.mesh'
bru_mapper(mesh, ...)

## S3 method for class 'bru_mapper_inla_mesh_2d'
ibm_n(mapper, ...)

## S3 method for class 'bru_mapper_inla_mesh_2d'
ibm_values(mapper, ...)

## S3 method for class 'bru_mapper_inla_mesh_2d'
ibm_jacobian(mapper, input, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_mapper.fm_mesh_2d_+3A_mesh">mesh</code></td>
<td>
<p>An <code>fm_mesh_2d</code> or <code>inla.mesh.2d</code> object to use as a mapper</p>
</td></tr>
<tr><td><code id="bru_mapper.fm_mesh_2d_+3A_...">...</code></td>
<td>
<p>Arguments passed on to other methods</p>
</td></tr>
<tr><td><code id="bru_mapper.fm_mesh_2d_+3A_mapper">mapper</code></td>
<td>
<p>A mapper S3 object, inheriting from <code>bru_mapper</code>.</p>
</td></tr>
<tr><td><code id="bru_mapper.fm_mesh_2d_+3A_input">input</code></td>
<td>
<p>Data input for the mapper.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>bru_mapper(inla.mesh)</code>: Creates a mapper for 2D <code>inla.mesh</code> objects
</p>
</li></ul>


<h3>See Also</h3>

<p><a href="#topic+bru_mapper">bru_mapper</a>, <a href="#topic+bru_mapper_generics">bru_mapper_generics</a>
</p>
<p>Other mappers: 
<code><a href="#topic+bru_get_mapper">bru_get_mapper</a>()</code>,
<code><a href="#topic+bru_mapper">bru_mapper</a>()</code>,
<code><a href="#topic+bru_mapper.fm_mesh_1d">bru_mapper.fm_mesh_1d</a>()</code>,
<code><a href="#topic+bru_mapper_aggregate">bru_mapper_aggregate</a>()</code>,
<code><a href="#topic+bru_mapper_collect">bru_mapper_collect</a>()</code>,
<code><a href="#topic+bru_mapper_const">bru_mapper_const</a>()</code>,
<code><a href="#topic+bru_mapper_factor">bru_mapper_factor</a>()</code>,
<code><a href="#topic+bru_mapper_generics">bru_mapper_generics</a></code>,
<code><a href="#topic+bru_mapper_harmonics">bru_mapper_harmonics</a>()</code>,
<code><a href="#topic+bru_mapper_index">bru_mapper_index</a>()</code>,
<code><a href="#topic+bru_mapper_linear">bru_mapper_linear</a>()</code>,
<code><a href="#topic+bru_mapper_logsumexp">bru_mapper_logsumexp</a>()</code>,
<code><a href="#topic+bru_mapper_marginal">bru_mapper_marginal</a>()</code>,
<code><a href="#topic+bru_mapper_matrix">bru_mapper_matrix</a>()</code>,
<code><a href="#topic+bru_mapper_mesh_B">bru_mapper_mesh_B</a>()</code>,
<code><a href="#topic+bru_mapper_multi">bru_mapper_multi</a>()</code>,
<code><a href="#topic+bru_mapper_pipe">bru_mapper_pipe</a>()</code>,
<code><a href="#topic+bru_mapper_scale">bru_mapper_scale</a>()</code>,
<code><a href="#topic+bru_mapper_shift">bru_mapper_shift</a>()</code>,
<code><a href="#topic+bru_mapper_taylor">bru_mapper_taylor</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- bru_mapper(fmesher::fmexample$mesh)
ibm_n(m)
ibm_eval(m, as.matrix(expand.grid(-2:2, -2:2)), seq_len(ibm_n(m)))

</code></pre>

<hr>
<h2 id='bru_model'>Create an inlabru model object from model components</h2><span id='topic+bru_model'></span><span id='topic+summary.bru_model'></span><span id='topic+print.summary_bru_model'></span>

<h3>Description</h3>

<p>The <a href="#topic+inlabru">inlabru</a> syntax for model formulae is different from what
<code>INLA::inla</code> considers a valid.
In inla most of the effects are defined by adding an <code>f(...)</code> expression to the formula.
In <a href="#topic+inlabru">inlabru</a> the <code>f</code> is replaced by an arbitrary (exceptions: <code>const</code> and <code>offset</code>)
string that will determine the label of the effect. See Details for further information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_model(components, lhoods)

## S3 method for class 'bru_model'
summary(object, ...)

## S3 method for class 'summary_bru_model'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_model_+3A_components">components</code></td>
<td>
<p>A <a href="#topic+component_list">component_list</a> object</p>
</td></tr>
<tr><td><code id="bru_model_+3A_lhoods">lhoods</code></td>
<td>
<p>A list of one or more <code>lhood</code> objects</p>
</td></tr>
<tr><td><code id="bru_model_+3A_object">object</code></td>
<td>
<p>Object to operate on</p>
</td></tr>
<tr><td><code id="bru_model_+3A_...">...</code></td>
<td>
<p>Arguments passed on to other methods</p>
</td></tr>
<tr><td><code id="bru_model_+3A_x">x</code></td>
<td>
<p>A <code>summary_bru_model</code> object to be printed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For instance
</p>
<p><code>y ~ f(myspde, ...)</code>
</p>
<p>in INLA is equivalent to
</p>
<p><code>y ~ myspde(...)</code>
</p>
<p>in inlabru.
</p>
<p>A disadvantage of the inla way is that there is no clear separation between the name of the covariate
and the label of the effect. Furthermore, for some models like SPDE it is much more natural to
use spatial coordinates as covariates rather than an index into the SPDE vertices. For this purpose
<a href="#topic+inlabru">inlabru</a> provides the <code>main</code> argument. For convenience, the <code>main</code> argument can be used
like the first argument of the f function, e.g., and is the first argument of the component definition.
The <code>INLA</code> model formula
</p>
<p><code>y ~ f(temperature, model = 'linear')</code>
</p>
<p>is equivalent to the <code>inlabru</code> component and formula definition
</p>
<p><code>y ~ temperature(temperature, model = 'linear')</code>
and
<code>y ~ temperature(main = temperature, model = 'linear')</code>
as well as
<code>y ~ temperature(model = 'linear')</code>
which sets <code>main = temperature</code>.
</p>
<p>On the other hand, <code>main</code> can also be a function mapping, e.g the <code><a href="sp.html#topic+coordinates">sp::coordinates()</a></code> function:
</p>
<p><code>y ~ mySPDE(coordinates, ...)</code>
</p>
<p>This extracts the coordinates from the data object, and maps it to the latent
field via the information given in the <code>mapper</code>, which by default is
extracted from the <code>model</code> object, in the case of <code>spde</code> model
objects.
</p>
<p>Morevover, <code>main</code> can be any expression that evaluates within your data as an environment.
For instance, if your data has columns 'a' and 'b', you can create a fixed effect of 'sin(a+b)' by
setting <code>map</code> in the following way:
</p>
<p><code>y ~ myEffect(sin(a+b))</code>
</p>


<h3>Value</h3>

<p>A <a href="#topic+bru_model">bru_model</a> object
</p>

<hr>
<h2 id='bru_options'>Create or update an options objects</h2><span id='topic+bru_options'></span><span id='topic+as.bru_options'></span><span id='topic+bru_options_default'></span><span id='topic+bru_options_check'></span><span id='topic+bru_options_get'></span><span id='topic+bru_options_set'></span><span id='topic+bru_options_reset'></span>

<h3>Description</h3>

<p>Create a new options object, or merge information from several
objects.
</p>
<p>The <code style="white-space: pre;">&#8288;_get&#8288;</code>, <code style="white-space: pre;">&#8288;_set&#8288;</code>, and <code style="white-space: pre;">&#8288;_reset&#8288;</code> functions operate on a global
package options override object. In many cases, setting options in
specific calls to <code><a href="#topic+bru">bru()</a></code> is recommended instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_options(...)

as.bru_options(x = NULL)

bru_options_default()

bru_options_check(options, ignore_null = TRUE)

bru_options_get(name = NULL, include_default = TRUE)

bru_options_set(..., .reset = FALSE)

bru_options_reset()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_options_+3A_...">...</code></td>
<td>
<p>A collection of named options, optionally including one or more
<code><a href="#topic+bru_options">bru_options</a></code> objects. Options specified later override the previous options.</p>
</td></tr>
<tr><td><code id="bru_options_+3A_x">x</code></td>
<td>
<p>An object to be converted to an <code>bru_options</code> object.</p>
</td></tr>
<tr><td><code id="bru_options_+3A_options">options</code></td>
<td>
<p>An <code>bru_options</code> object to be checked</p>
</td></tr>
<tr><td><code id="bru_options_+3A_ignore_null">ignore_null</code></td>
<td>
<p>Ignore missing or NULL options.</p>
</td></tr>
<tr><td><code id="bru_options_+3A_name">name</code></td>
<td>
<p>Either <code>NULL</code>, or single option name string, or character vector
or list with option names,
Default: NULL</p>
</td></tr>
<tr><td><code id="bru_options_+3A_include_default">include_default</code></td>
<td>
<p>logical; If <code>TRUE</code>, the default options are included
together with the global override options. Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="bru_options_+3A_.reset">.reset</code></td>
<td>
<p>For <code>bru_options_set</code>, logical indicating if the global override
options list should be emptied before setting the new option(s).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>bru_options()</code> returns a <code>bru_options</code> object.
</p>
<p>For <code>as.bru_options()</code>, <code>NULL</code> or no input returns an empty
<code>bru_options</code> object, a <code>list</code> is converted via <code>bru_options(...)</code>,
and <code>bru_options</code> input is passed through. Other types of input generates
an error.
</p>
<p><code>bru_options_default()</code> returns an <code>bru_options</code> object containing
default options.
</p>
<p><code>bru_options_check()</code> returns a <code>logical</code>; <code>TRUE</code> if the object
contains valid options for use by other functions
</p>
<p><code>bru_options_get</code> returns either an <code><a href="#topic+bru_options">bru_options</a></code> object, for
<code>name == NULL</code>, the contents of single option, if <code>name</code> is a options name
string, or a named list of option contents, if <code>name</code> is a list of option
name strings.
</p>
<p><code>bru_options_set()</code> returns a copy of the global override options,
invisibly (as <code>bru_options_get(include_default = FALSE)</code>).
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>as.bru_options()</code>: Coerces inputs to a <code>bru_options</code> object.
</p>
</li>
<li> <p><code>bru_options_default()</code>: Returns the default options.
</p>
</li>
<li> <p><code>bru_options_check()</code>: Checks for valid contents of a <code>bru_options</code>
object, and produces warnings for invalid options.
</p>
</li>
<li> <p><code>bru_options_get()</code>: Used to access global package options.
</p>
</li>
<li> <p><code>bru_options_set()</code>: Used to set global package options.
</p>
</li>
<li> <p><code>bru_options_reset()</code>: Clears the global option overrides.
</p>
</li></ul>


<h3>Valid options</h3>

<p>For <code>bru_options</code> and <code>bru_options_set</code>, recognised options are:
</p>

<dl>
<dt>bru_verbose</dt><dd><p>logical or numeric; if <code>TRUE</code>, log messages of <code>verbosity</code>
<code class="reqn">\le 1</code> are printed by <code><a href="#topic+bru_log_message">bru_log_message()</a></code>. If numeric, log messages
of
verbosity <code class="reqn">\le</code><code>bru_verbose</code> are printed.
For line search details, set <code>bru_verbose=2</code> or <code>3</code>.
Default: 0, to not print any messages</p>
</dd>
<dt>bru_verbose_store</dt><dd><p>logical or numeric; if <code>TRUE</code>, log messages of
<code>verbosity</code> <code class="reqn">\le 1</code> are stored by <code><a href="#topic+bru_log_message">bru_log_message()</a></code>. If numeric,
log messages of verbosity <code class="reqn">\le</code> are stored. Default: Inf, to store all messages.</p>
</dd>
<dt>bru_run</dt><dd><p>If TRUE, run inference. Otherwise only return configuration needed
to run inference.</p>
</dd>
<dt>bru_max_iter</dt><dd><p>maximum number of inla iterations, default 10.
Also see the <code>bru_method$rel_tol</code> and related options below.</p>
</dd>
<dt>bru_initial</dt><dd><p>An <code>inla</code> object returned from previous calls of
<code>INLA::inla</code>, <code><a href="#topic+bru">bru()</a></code> or <code><a href="#topic+lgcp">lgcp()</a></code>, or a list of named vectors of starting
values for the latent variables. This will be used as a
starting point for further improvement of the approximate posterior.</p>
</dd>
<dt>bru_int_args</dt><dd><p>List of arguments passed all the way to the
integration method <code>ipoints</code> and <code>int.polygon</code> for 'cp' family models;
</p>

<dl>
<dt>method</dt><dd><p>&quot;stable&quot; or &quot;direct&quot;. For &quot;stable&quot; (default) integration points
are aggregated to mesh vertices.</p>
</dd>
<dt>nsub1</dt><dd><p>Number of integration points per knot interval in 1D. Default 30.</p>
</dd>
<dt>nsub2</dt><dd><p>Number of integration points along a triangle edge for 2D. Default 9.</p>
</dd>
<dt>nsub</dt><dd><p>Deprecated parameter that overrides <code>nsub1</code> and <code>nsub2</code> if set. Default <code>NULL</code>.</p>
</dd>
</dl>

</dd>
<dt>bru_method</dt><dd><p>List of arguments controlling the iterative inlabru method:
</p>

<dl>
<dt>taylor</dt><dd><p>'pandemic'
(default, from version 2.1.15).</p>
</dd>
<dt>search</dt><dd><p>Either 'all' (default), to use all available line search
methods, or one or more of
</p>

<dl>
<dt>'finite'</dt><dd><p>(reduce step size until predictor is finite)</p>
</dd>
<dt>'contract'</dt><dd><p>(decrease step size until trust hypersphere reached)</p>
</dd>
<dt>'expand'</dt><dd><p>(increase step size until no improvement)</p>
</dd>
<dt>'optimise'</dt><dd><p>(fast approximate error norm minimisation)</p>
</dd>
</dl>

<p>To disable line search, set to an empty vector. Line search is not
available for <code>taylor="legacy"</code>.</p>
</dd>
<dt>factor</dt><dd><p>Numeric, <code class="reqn">&gt; 1</code> determining the line search step scaling
multiplier. Default <code class="reqn">(1 + \sqrt{5})/2</code>.</p>
</dd>
<dt>rel_tol</dt><dd><p>Stop the iterations when the largest change in linearisation point
(the conditional latent state mode) in relation to the estimated posterior
standard deviation is less than <code>rel_tol</code>. Default 0.1 (ten percent).</p>
</dd>
<dt>max_step</dt><dd><p>The largest allowed line search step factor. Factor 1 is the
full INLA step. Default is 2.</p>
</dd>
<dt>line_opt_method</dt><dd><p>Which method to use for the line search optimisation step.
Default &quot;onestep&quot;, using a quadratic approximation based on the value and
gradient at zero, and the value at the current best step length guess.
The method &quot;full&quot; does line optimisation on the full nonlinear predictor;
this is slow and intended for debugging purposes only.</p>
</dd>
</dl>

</dd>
<dt>bru_compress_cp</dt><dd><p>logical; when <code>TRUE</code>, compress the
<code class="reqn">\sum_{i=1}^n \eta_i</code>
part of the Poisson process likelihood (<code>family="cp"</code>) into a single term, with <code class="reqn">y=n</code>,
and predictor <code>mean(eta)</code>. Default: <code>TRUE</code></p>
</dd>
<dt>bru_debug</dt><dd><p>logical; when <code>TRUE</code>, activate temporary debug features for
package development. Default: <code>FALSE</code></p>
</dd>
<dt><code>inla()</code> options</dt><dd>
<p>All options not starting with <code>bru_</code> are passed on to <code>inla()</code>, sometimes
after altering according to the needs of the inlabru method.
Warning:
Due to how inlabru currently constructs the <code>inla()</code> call, the <code>mean</code>,
<code>prec</code>, <code>mean.intercept</code>, and <code>prec.intercept</code> settings in
<code>control.fixed</code> will have no
effect. Until a more elegant alternative has been implemented, use explicit
<code>mean.linear</code> and <code>prec.linear</code> specifications in each
<code>model="linear"</code> component instead.
</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+bru_options">bru_options()</a></code>, <code><a href="#topic+bru_options_default">bru_options_default()</a></code>, <code><a href="#topic+bru_options_get">bru_options_get()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (interactive()) {
  # Combine global and user options:
  options1 &lt;- bru_options(bru_options_get(), bru_verbose = TRUE)
  # Create a proto-options object in two equivalent ways:
  options2 &lt;- as.bru_options(bru_verbose = TRUE)
  options2 &lt;- as.bru_options(list(bru_verbose = TRUE))
  # Combine options objects:
  options3 &lt;- bru_options(options1, options2)
}

## End(Not run)
## Not run: 
if (interactive()) {
  bru_options_check(bru_options(bru_max_iter = "text"))
}

## End(Not run)
bru_options_get("bru_verbose")
## Not run: 
if (interactive()) {
  bru_options_set(
    bru_verbose = TRUE,
    verbose = TRUE
  )
}

## End(Not run)
</code></pre>

<hr>
<h2 id='bru_safe_inla'>Load INLA safely for examples and tests</h2><span id='topic+bru_safe_inla'></span>

<h3>Description</h3>

<p>Loads the INLA package with <code>requireNamespace("INLA", quietly = TRUE)</code>, and
optionally checks and sets the multicore <code>num.threads</code> INLA option.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_safe_inla(multicore = NULL, quietly = FALSE, minimum_version = "23.1.31")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_safe_inla_+3A_multicore">multicore</code></td>
<td>
<p>logical; if <code>TRUE</code>, multiple cores are allowed, and the
INLA <code>num.threads</code> option is not checked or altered.
If <code>FALSE</code>, forces <code>num.threads="1:1"</code>. Default: NULL, checks
if running in testthat or non-interactively, in which case sets
<code>multicore=FALSE</code>, otherwise <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="bru_safe_inla_+3A_quietly">quietly</code></td>
<td>
<p>logical; if <code>TRUE</code>, prints diagnostic messages. Default: FALSE.</p>
</td></tr>
<tr><td><code id="bru_safe_inla_+3A_minimum_version">minimum_version</code></td>
<td>
<p>character; the minimum required INLA version.
Default 23.1.31 (should always match the requirement in the package
DESCRIPTION)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical; <code>TRUE</code> if INLA was loaded safely, otherwise FALSE
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (bru_safe_inla()) {
  # Run inla dependent calculations
}

## End(Not run)

</code></pre>

<hr>
<h2 id='bru_safe_sp'>Check for potential <code>sp</code> version compatibility issues</h2><span id='topic+bru_safe_sp'></span>

<h3>Description</h3>

<p>Loads the sp package with <code>requireNamespace("sp", quietly = TRUE)</code>, and
checks and optionally sets the <code>sp</code> evolution status flag if <code>rgdal</code> is unavailable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_safe_sp(quietly = FALSE, force = FALSE, minimum_version = "1.4-5")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_safe_sp_+3A_quietly">quietly</code></td>
<td>
<p>logical; if <code>TRUE</code>, prints diagnostic messages. Default <code>FALSE</code></p>
</td></tr>
<tr><td><code id="bru_safe_sp_+3A_force">force</code></td>
<td>
<p>logical; If <code>rgdal</code> is unavailable
and evolution status is less that <code>2L</code>, return <code>FALSE</code> if <code>force</code> is <code>FALSE</code>.
If <code>force</code> is <code>TRUE</code>, return <code>TRUE</code> if the package configuration is safe,
potentially after forcing the evolution status to <code>2L</code>.
Default <code>FALSE</code></p>
</td></tr>
<tr><td><code id="bru_safe_sp_+3A_minimum_version">minimum_version</code></td>
<td>
<p>character; the minimum required INLA version.
Default 1.4-5 (should always match the requirement in the package
DESCRIPTION)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns (invisibly) <code>FALSE</code> if a potential issue is detected, and give a
message if <code>quietly</code> is <code>FALSE</code>. Otherwise returns <code>TRUE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (bru_safe_sp() &amp;&amp;
  require("sp")) {
  # Run sp dependent calculations
}

## End(Not run)

</code></pre>

<hr>
<h2 id='bru_standardise_names'>Standardise inla hyperparameter names</h2><span id='topic+bru_standardise_names'></span>

<h3>Description</h3>

<p>The inla hyperparameter output uses parameter names that can include
whitespace and special characters. This function replaces those characters
with underscores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_standardise_names(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_standardise_names_+3A_x">x</code></td>
<td>
<p>character vector; names to be standardised</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with standardised names
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bru_standardise_names("Precision for the Gaussian observations")
</code></pre>

<hr>
<h2 id='bru_summarise'>Summarise and annotate data</h2><span id='topic+bru_summarise'></span>

<h3>Description</h3>

<p>Summarise and annotate data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_summarise(
  data,
  probs = c(0.025, 0.5, 0.975),
  x = NULL,
  cbind.only = FALSE,
  max_moment = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_summarise_+3A_data">data</code></td>
<td>
<p>A list of samples, each either numeric or a <code>data.frame</code></p>
</td></tr>
<tr><td><code id="bru_summarise_+3A_probs">probs</code></td>
<td>
<p>A numeric vector of probabilities with values in <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>,
passed to <code>stats::quantile</code></p>
</td></tr>
<tr><td><code id="bru_summarise_+3A_x">x</code></td>
<td>
<p>A <code>data.frame</code> of data columns that should be added to the summary data frame</p>
</td></tr>
<tr><td><code id="bru_summarise_+3A_cbind.only">cbind.only</code></td>
<td>
<p>If TRUE, only <code>cbind</code> the samples and return a matrix where each column is a sample</p>
</td></tr>
<tr><td><code id="bru_summarise_+3A_max_moment">max_moment</code></td>
<td>
<p>integer, at least 2. Determines the largest moment
order information to include in the output. If <code>max_moment &gt; 2</code>,
includes &quot;skew&quot; (skewness, <code>E[(x-m)^3/s^3]</code>), and
if <code>max_moment &gt; 3</code>, includes
&quot;ekurtosis&quot; (excess kurtosis, <code>E[(x-m)^4/s^4] - 3</code>). Default 2.
Note that the Monte Carlo variability of the <code>ekurtois</code> estimate may be large.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> or <code style="white-space: pre;">&#8288;Spatial[Points/Pixels]DataFrame&#8288;</code> with summary statistics,
&quot;mean&quot;, &quot;sd&quot;, <code>paste0("q", probs)</code>, &quot;mean.mc_std_err&quot;, &quot;sd.mc_std_err&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bru_summarise(matrix(rexp(10000), 10, 1000), max_moment = 4, probs = NULL)

</code></pre>

<hr>
<h2 id='bru_timings'>Extract timing information from fitted <a href="#topic+bru">bru</a> object</h2><span id='topic+bru_timings'></span><span id='topic+bru_timings.bru'></span>

<h3>Description</h3>

<p>Extracts a data.frame or tibble with information about the <code>Time</code> (CPU),
<code>System</code>, and <code>Elapsed</code> time for each step of a <code>bru()</code> run.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_timings(object, ...)

## S3 method for class 'bru'
bru_timings(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_timings_+3A_object">object</code></td>
<td>
<p>A fitted <code>bru</code> object</p>
</td></tr>
<tr><td><code id="bru_timings_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>

<hr>
<h2 id='bru_timings_plot'>Plot inlabru iteration timings</h2><span id='topic+bru_timings_plot'></span>

<h3>Description</h3>

<p>Draws the time per iteration for preprocessing (including linearisation),
<code>inla()</code> calls, and
line search. Iteration <code>0</code> is the time used for defining the model structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_timings_plot(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_timings_plot_+3A_x">x</code></td>
<td>
<p>a <a href="#topic+bru">bru</a> object, typically a result from <code><a href="#topic+bru">bru()</a></code> for a nonlinear
predictor model</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Requires the &quot;ggplot2&quot; package to be installed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit &lt;- bru(...)
bru_timings_plot(fit)

## End(Not run)
</code></pre>

<hr>
<h2 id='bru_used'>List components used in a model</h2><span id='topic+bru_used'></span><span id='topic+bru_used.default'></span><span id='topic+bru_used.character'></span><span id='topic+bru_used.expression'></span><span id='topic+bru_used.formula'></span><span id='topic+bru_used.bru'></span><span id='topic+bru_used.list'></span><span id='topic+bru_used.bru_like'></span><span id='topic+bru_used.bru_used'></span><span id='topic+print.bru_used'></span>

<h3>Description</h3>

<p>Create or extract information about which components are used by a model, or
its individual observation models. If a non-NULL <code>labels</code> argument is
supplied, also calls <code><a href="#topic+bru_used_update">bru_used_update()</a></code> on the <code>bru_used</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_used(x = NULL, ...)

## Default S3 method:
bru_used(
  x = NULL,
  ...,
  effect = NULL,
  effect_exclude = NULL,
  latent = NULL,
  labels = NULL
)

## S3 method for class 'character'
bru_used(
  x,
  ...,
  effect = NULL,
  effect_exclude = NULL,
  latent = NULL,
  labels = NULL
)

## S3 method for class 'expression'
bru_used(
  x,
  ...,
  effect = NULL,
  effect_exclude = NULL,
  latent = NULL,
  labels = NULL
)

## S3 method for class 'formula'
bru_used(
  x,
  ...,
  effect = NULL,
  effect_exclude = NULL,
  latent = NULL,
  labels = NULL
)

## S3 method for class 'bru'
bru_used(x, ..., join = TRUE)

## S3 method for class 'list'
bru_used(x, ..., join = TRUE)

## S3 method for class 'bru_like'
bru_used(x, ...)

## S3 method for class 'bru_used'
bru_used(x, labels = NULL, ...)

## S3 method for class 'bru_used'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_used_+3A_x">x</code></td>
<td>
<p>An object that contains information about used components</p>
</td></tr>
<tr><td><code id="bru_used_+3A_...">...</code></td>
<td>
<p>Parameters passed on to the other methods</p>
</td></tr>
<tr><td><code id="bru_used_+3A_effect">effect</code></td>
<td>
<p>character; components used as effects. When <code>NULL</code>, auto-detect
components to include or include all components.</p>
</td></tr>
<tr><td><code id="bru_used_+3A_effect_exclude">effect_exclude</code></td>
<td>
<p>character; components to specifically exclude from
effect evaluation. When <code>NULL</code>, do not specifically exclude any components.</p>
</td></tr>
<tr><td><code id="bru_used_+3A_latent">latent</code></td>
<td>
<p>character; components used as <code style="white-space: pre;">&#8288;_latent&#8288;</code> or <code style="white-space: pre;">&#8288;_eval()&#8288;</code>. When
<code>NULL</code>, auto-detect components.</p>
</td></tr>
<tr><td><code id="bru_used_+3A_labels">labels</code></td>
<td>
<p>character; component labels passed on to
<code><a href="#topic+bru_used_update">bru_used_update()</a></code></p>
</td></tr>
<tr><td><code id="bru_used_+3A_join">join</code></td>
<td>
<p>Whether to join list output into a single object; Default
may depend on the input object class</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>bru_used</code> object (a list with elements <code>effect</code>
and <code>latent</code>), or a list of such objects
(for methods with <code>join = FALSE</code>)
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>bru_used(default)</code>: Create a <code>bru_used</code> object.
</p>
</li>
<li> <p><code>bru_used(character)</code>: Create a <code>bru_used</code> object from a <code>character</code>
representation of an expression.
</p>
</li>
<li> <p><code>bru_used(expression)</code>: Create a <code>bru_used</code> object from an expression object.
</p>
</li>
<li> <p><code>bru_used(formula)</code>: Create a <code>bru_used</code> object from a formula (only the
right-hand side is used).
</p>
</li>
<li> <p><code>bru_used(bru_used)</code>: Convenience method that takes
an existing <code>bru_used</code> object and calls <code><a href="#topic+bru_used_update">bru_used_update()</a></code>
if <code>labels</code> is non-NULL.
</p>
</li></ul>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>print(bru_used)</code>: Print method for <code>bru_used</code> objects.
</p>
</li></ul>


<h3>See Also</h3>

<p>Other bru_used: 
<code><a href="#topic+bru_used_update">bru_used_update</a>()</code>,
<code><a href="#topic+bru_used_vars">bru_used_vars</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(used &lt;- bru_used(~.))
bru_used(used, labels = c("a", "c"))
(used &lt;- bru_used(~ a + b + c_latent + d_latent))
bru_used(used, labels = c("a", "c"))
(used &lt;- bru_used(expression(a + b + c_latent + d_latent)))
bru_used(used, labels = c("a", "c"))

</code></pre>

<hr>
<h2 id='bru_used_update'>Update used_component information objects</h2><span id='topic+bru_used_update'></span><span id='topic+bru_used_update.bru_like_list'></span><span id='topic+bru_used_update.bru_like'></span><span id='topic+bru_used_update.bru_used'></span>

<h3>Description</h3>

<p>Merge available component labels information with used components
information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_used_update(x, labels, ...)

## S3 method for class 'bru_like_list'
bru_used_update(x, labels, ...)

## S3 method for class 'bru_like'
bru_used_update(x, labels, ...)

## S3 method for class 'bru_used'
bru_used_update(x, labels, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_used_update_+3A_x">x</code></td>
<td>
<p>Object to be updated</p>
</td></tr>
<tr><td><code id="bru_used_update_+3A_labels">labels</code></td>
<td>
<p>character vector of component labels</p>
</td></tr>
<tr><td><code id="bru_used_update_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated version of <code>x</code>
</p>


<h3>See Also</h3>

<p>Other bru_used: 
<code><a href="#topic+bru_used">bru_used</a>()</code>,
<code><a href="#topic+bru_used_vars">bru_used_vars</a>()</code>
</p>

<hr>
<h2 id='bru_used_vars'>Extract basic variable names from expression</h2><span id='topic+bru_used_vars'></span><span id='topic+bru_used_vars.character'></span><span id='topic+bru_used_vars.expression'></span><span id='topic+bru_used_vars.formula'></span>

<h3>Description</h3>

<p>Extracts the variable names from an R expression by pre- and post-processing
around <code><a href="base.html#topic+all.vars">all.vars()</a></code>.
First replaces <code>$</code> with <code>[[</code> indexing, so that internal column/variable names
are ignored, then calls <code>all.vars()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bru_used_vars(x, functions = FALSE)

## S3 method for class 'character'
bru_used_vars(x, functions = FALSE)

## S3 method for class 'expression'
bru_used_vars(x, functions = FALSE)

## S3 method for class 'formula'
bru_used_vars(x, functions = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bru_used_vars_+3A_x">x</code></td>
<td>
<p>A <code>formula</code>, <code>expression</code>, or <code>character</code></p>
</td></tr>
<tr><td><code id="bru_used_vars_+3A_functions">functions</code></td>
<td>
<p>logical; if TRUE, include function names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If successful, a character vector, otherwise <code>NULL</code>
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>bru_used_vars(formula)</code>: Only the right-hand side is used.
</p>
</li></ul>


<h3>See Also</h3>

<p>Other bru_used: 
<code><a href="#topic+bru_used">bru_used</a>()</code>,
<code><a href="#topic+bru_used_update">bru_used_update</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bru_used_vars(~.)
bru_used_vars(~ a + b + c_latent + d_eval())
bru_used_vars(expression(a + b + c_latent + d_eval()))

bru_used_vars(~., functions = TRUE)
bru_used_vars(~ a + b + c_latent + d_eval(), functions = TRUE)
bru_used_vars(expression(a + b + c_latent + d_eval()), functions = TRUE)

bru_used_vars(a ~ b)
bru_used_vars(expression(a ~ b))

</code></pre>

<hr>
<h2 id='code.components'>Convert components to R code</h2><span id='topic+code.components'></span>

<h3>Description</h3>

<p>Convert components to R code
</p>


<h3>Usage</h3>

<pre><code class='language-R'>code.components(components, add = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="code.components_+3A_components">components</code></td>
<td>
<p>A <a href="stats.html#topic+formula">formula</a> describing latent model components.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Fabian E. Bachl <a href="mailto:bachlfab@gmail.com">bachlfab@gmail.com</a>
</p>

<hr>
<h2 id='comp_lin_eval'>Construct component linearisations</h2><span id='topic+comp_lin_eval'></span><span id='topic+comp_lin_eval.component'></span><span id='topic+comp_lin_eval.component_list'></span>

<h3>Description</h3>

<p>Constructs the linearisation mapper for each component
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comp_lin_eval(...)

## S3 method for class 'component'
comp_lin_eval(component, input = NULL, state = NULL, ...)

## S3 method for class 'component_list'
comp_lin_eval(components, input, state, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comp_lin_eval_+3A_...">...</code></td>
<td>
<p>Optional parameters passed on to <code>ibm_eval</code>
and 'ibm_jacobian.</p>
</td></tr>
<tr><td><code id="comp_lin_eval_+3A_component">component</code></td>
<td>
<p>A component.</p>
</td></tr>
<tr><td><code id="comp_lin_eval_+3A_input">input</code></td>
<td>
<p>Component inputs, from <code>input_eval()</code></p>
</td></tr>
<tr><td><code id="comp_lin_eval_+3A_state">state</code></td>
<td>
<p>linearisation evaluation state</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>bru_mapper_taylor</code> or <code>comp_simple_list</code> object.
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>

<hr>
<h2 id='component'>Latent model component construction</h2><span id='topic+component'></span><span id='topic+bru_component'></span><span id='topic+component.character'></span>

<h3>Description</h3>

<p>Similar to <code>glm()</code>, <code>gam()</code> and <code>inla()</code>, <code><a href="#topic+bru">bru()</a></code> models can be constructed via
a formula-like syntax, where each latent effect is specified. However, in
addition to the parts of the syntax compatible with <code>INLA::inla</code>, <code>bru</code>
components offer additional functionality which facilitates modelling, and
the predictor expression can be specified separately, allowing more complex
and non-linear predictors to be defined. The formula syntax is just a way to
allow all model components to be defined in a single line of code, but the
definitions can optionally be split up into separate component definitions.
See Details for more information.
</p>
<p>The <code>component</code> methods all rely on the <code><a href="#topic+component.character">component.character()</a></code> method, that
defines a model component with a given label/name. The user usually
doesn't need to call these methods directly, but can instead supply a
formula expression that can be interpreted by the <code><a href="#topic+component_list.formula">component_list.formula()</a></code>
method, called inside <code><a href="#topic+bru">bru()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>component(...)

## S3 method for class 'character'
component(
  object,
  main = NULL,
  weights = NULL,
  ...,
  model = NULL,
  mapper = NULL,
  main_layer = NULL,
  main_selector = NULL,
  n = NULL,
  values = NULL,
  season.length = NULL,
  copy = NULL,
  weights_layer = NULL,
  weights_selector = NULL,
  group = 1L,
  group_mapper = NULL,
  group_layer = NULL,
  group_selector = NULL,
  ngroup = NULL,
  control.group = NULL,
  replicate = 1L,
  replicate_mapper = NULL,
  replicate_layer = NULL,
  replicate_selector = NULL,
  nrep = NULL,
  marginal = NULL,
  A.msk = deprecated(),
  .envir = parent.frame(),
  envir_extra = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="component_+3A_...">...</code></td>
<td>
<p>Parameters passed on to other methods</p>
</td></tr>
<tr><td><code id="component_+3A_object">object</code></td>
<td>
<p>A character label for the component</p>
</td></tr>
<tr><td><code id="component_+3A_main">main</code></td>
<td>
<p><code>main</code> takes an R expression that evaluates to where the latent variables
should be evaluated (coordinates, indices, continuous scalar (for rw2 etc)).
Arguments starting with weights, group, replicate behave similarly to main,
but for the corresponding features of <code>INLA::f()</code>.</p>
</td></tr>
<tr><td><code id="component_+3A_weights">weights</code>, <code id="component_+3A_weights_layer">weights_layer</code>, <code id="component_+3A_weights_selector">weights_selector</code></td>
<td>
<p>Optional specification of effect scaling weights.
Same syntax as for <code>main</code>.</p>
</td></tr>
<tr><td><code id="component_+3A_model">model</code></td>
<td>
<p>Either one of &quot;const&quot; (same as &quot;offset&quot;), &quot;factor_full&quot;,
&quot;factor_contrast&quot;, &quot;linear&quot;,
&quot;fixed&quot;, or a model name or
object accepted by INLA's <code>f</code> function. If set to NULL, then &quot;linear&quot; is used
for vector inputs, and &quot;fixed&quot; for matrix input (converted internally to
an iid model with fixed precision)</p>
</td></tr>
<tr><td><code id="component_+3A_mapper">mapper</code></td>
<td>
<p>Information about how to do the mapping from the values evaluated in <code>main</code>,
and to the latent variables. Auto-detects spde model objects in model and
extracts the mesh object to use as the mapper, and auto-generates mappers
for indexed models. (Default: NULL, for auto-determination)</p>
</td></tr>
<tr><td><code id="component_+3A_main_layer">main_layer</code>, <code id="component_+3A_main_selector">main_selector</code></td>
<td>
<p>The <code style="white-space: pre;">&#8288;_layer&#8288;</code> input should evaluate to a numeric index or character name or
vector of which
layer/variable to extract from a covariate data object given in <code>main</code>.
(Default: NULL if <code style="white-space: pre;">&#8288;_selector&#8288;</code> is given. Otherwise the effect component name,
if it exists in the covariate object, and otherwise the first column of
the covariate data frame)
</p>
<p>The <code style="white-space: pre;">&#8288;_selector&#8288;</code> value should be a character name of a variable
whose contents determines which layer to extract from a covariate for each
data point. (Default: NULL)</p>
</td></tr>
<tr><td><code id="component_+3A_n">n</code></td>
<td>
<p>The number of latent variables in the model. Should be auto-detected
for most or all models (Default: NULL, for auto-detection).
An error is given if it can't figure it out by itself.</p>
</td></tr>
<tr><td><code id="component_+3A_values">values</code></td>
<td>
<p>Specifies for what covariate/index values INLA should build
the latent model. Normally generated internally based on the mapping details.
(Default: NULL, for auto-determination)</p>
</td></tr>
<tr><td><code id="component_+3A_season.length">season.length</code></td>
<td>
<p>Passed on to <code>INLA::f()</code> for model <code>"seasonal"</code>
(TODO: check if this parameter is still fully handled)</p>
</td></tr>
<tr><td><code id="component_+3A_copy">copy</code></td>
<td>
<p>character; label of other component that this component should
be a copy of. If the <code>fixed = FALSE</code>, a scaling constant is estimated, via a
hyperparameter. If <code>fixed = TRUE</code>, the component scaling is fixed, by
default to 1; for fixed scaling, it's more efficient to express the scaling
in the predictor expression instead of making a copy component.</p>
</td></tr>
<tr><td><code id="component_+3A_group">group</code>, <code id="component_+3A_group_mapper">group_mapper</code>, <code id="component_+3A_group_layer">group_layer</code>, <code id="component_+3A_group_selector">group_selector</code>, <code id="component_+3A_ngroup">ngroup</code></td>
<td>
<p>Optional specification of kronecker/group model indexing.</p>
</td></tr>
<tr><td><code id="component_+3A_control.group">control.group</code></td>
<td>
<p><code>list</code> of kronecker/group model parameters, currently
passed directly on to <code>INLA::f</code></p>
</td></tr>
<tr><td><code id="component_+3A_replicate">replicate</code>, <code id="component_+3A_replicate_mapper">replicate_mapper</code>, <code id="component_+3A_replicate_layer">replicate_layer</code>, <code id="component_+3A_replicate_selector">replicate_selector</code>, <code id="component_+3A_nrep">nrep</code></td>
<td>
<p>Optional specification of indices for an independent
replication model. Same syntax as for <code>main</code></p>
</td></tr>
<tr><td><code id="component_+3A_marginal">marginal</code></td>
<td>
<p>May specify a <code>bru_mapper_marginal()</code> mapper,
that is applied before scaling by <code>weights</code>.</p>
</td></tr>
<tr><td><code id="component_+3A_a.msk">A.msk</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> and has no effect.</p>
</td></tr>
<tr><td><code id="component_+3A_.envir">.envir</code></td>
<td>
<p>Evaluation environment</p>
</td></tr>
<tr><td><code id="component_+3A_envir_extra">envir_extra</code></td>
<td>
<p>TODO: check/fix this parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As shorthand, <code><a href="#topic+bru">bru()</a></code> will understand basic additive formulae describing fixed effect
models. For instance, the
components specification <code>y ~ x</code> will define the linear combination of an
effect named <code>x</code> and an intercept to
the response <code>y</code> with respect to the likelihood family stated when calling <code><a href="#topic+bru">bru()</a></code>. Mathematically,
the linear predictor <code class="reqn">\eta</code> would be written down as
</p>
<p style="text-align: center;"><code class="reqn">\eta = \beta * x + c,</code>
</p>

<p>where:
</p>

<dl>
<dt><code class="reqn">c</code></dt><dd><p>is the <em>intercept</em></p>
</dd>
<dt><code class="reqn">x</code></dt><dd><p>is a <em>covariate</em></p>
</dd>
<dt><code class="reqn">\beta</code></dt><dd><p>is a <em>latent variable</em> associated with <code class="reqn">x</code> and</p>
</dd>
<dt><code class="reqn">\psi = \beta * x</code></dt><dd><p> is called the <em>effect</em> of <code class="reqn">x</code></p>
</dd>
</dl>

<p>A problem that arises when using this kind of R formula is that it does not
clearly reflect the mathematical
formula. For instance, when providing the formula to inla, the resulting
object will refer to the random
effect <code class="reqn">\psi = \beta * x </code> as <code>x</code>.
Hence, it is not clear when <code>x</code> refers to the covariate
or the effect of the covariate.
</p>
<p>The <code>component.character</code> method is inlabru's equivalent to INLA's
<code>f</code> function but adds functionality that is unique to inlabru.
</p>
<p>Deprecated parameters:
</p>

<ul>
<li><p> map: Use <code>main</code> instead.
</p>
</li>
<li><p> mesh: Use <code>mapper</code> instead.
</p>
</li></ul>



<h3>Naming random effects</h3>

<p>In INLA, the <code>f()</code> notation is used to define more complex models, but
a simple linear effect model can also be expressed as
</p>
<ul>
<li><p><code>formula = y ~ f(x, model = "linear")</code>,</p>
</li></ul>

<p>where <code>f()</code> is the inla specific function to set up random effects of all kinds. The underlying
predictor would again be <code class="reqn">\eta = \beta * x + c</code> but the result of fitting the model would state
<code>x</code> as the random effect's name. bru allows rewriting this formula in order to explicitly state
the name of the random effect and the name of the associated covariate. This is achieved by replacing <code>f</code>
with an arbitrary name that we wish to assign to the effect, e.g.
</p>
<ul>
<li><p><code>components = y ~ psi(x, model = "linear")</code>.</p>
</li></ul>

<p>Being able to discriminate between <code class="reqn">x</code> and <code class="reqn">\psi</code> is relevant because of two functionalities
bru offers. The formula parameters of both <code><a href="#topic+bru">bru()</a></code> and the prediction method <a href="#topic+predict.bru">predict.bru</a>
are interpreted in the mathematical sense. For instance, <code>predict</code> may be used to analyze the
analytical combination of the covariate <code class="reqn">x</code> and the intercept using
</p>
<ul>
<li><p><code style="white-space: pre;">&#8288;predict(fit, data.frame(x=2)), ~ exp(psi + Intercept)&#8288;</code>.</p>
</li></ul>

<p>which corresponds to the mathematical expression e <sup>&#946; + c</sup>.
</p>
<p>On the other hand, predict may be used to only look at a transformation of
the latent variable <code class="reqn">\beta_\psi</code>
</p>
<ul>
<li><p><code>predict(fit, NULL, ~ exp(psi_latent))</code>.</p>
</li></ul>

<p>which corresponds to the mathematical expression e <sup>&#946;</sup>.
</p>


<h3>Author(s)</h3>

<p>Fabian E. Bachl <a href="mailto:bachlfab@gmail.com">bachlfab@gmail.com</a> and
Finn Lindgren <a href="mailto:Finn.Lindgren@gmail.com">Finn.Lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other component constructors: 
<code><a href="#topic+component_list">component_list</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># As an example, let us create a linear component. Here, the component is
# called "myLinearEffectOfX" while the covariate the component acts on is
# called "x". Note that a list of components is returned because the
# formula may define multiple components

cmp &lt;- component_list(~ myLinearEffectOfX(main = x, model = "linear"))
summary(cmp)
# Equivalent shortcuts:
cmp &lt;- component_list(~ myLinearEffectOfX(x, model = "linear"))
cmp &lt;- component_list(~ myLinearEffectOfX(x))
# Individual component
cmp &lt;- component("myLinearEffectOfX", main = x, model = "linear")
summary(cmp)

if (bru_safe_inla(quietly = TRUE)) {
  # As an example, let us create a linear component. Here, the component is
  # called "myEffectOfX" while the covariate the component acts on is called "x":

  cmp &lt;- component("myEffectOfX", main = x, model = "linear")
  summary(cmp)

  # A more complicated component:
  cmp &lt;- component("myEffectOfX",
    main = x,
    model = INLA::inla.spde2.matern(fm_mesh_1d(1:10))
  )

  # Compound fixed effect component, where x and z are in the input data.
  # The formula will be passed on to MatrixModels::model.Matrix:
  cmp &lt;- component("eff", ~ -1 + x:z, model = "fixed")
  summary(cmp)
}


</code></pre>

<hr>
<h2 id='component_eval'>Evaluate component values in predictor expressions</h2><span id='topic+component_eval'></span>

<h3>Description</h3>

<p>In predictor expressions, <code>name_eval(...)</code> can be used to evaluate
the effect of a component called &quot;name&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>component_eval(
  main,
  group = NULL,
  replicate = NULL,
  weights = NULL,
  .state = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="component_eval_+3A_main">main</code>, <code id="component_eval_+3A_group">group</code>, <code id="component_eval_+3A_replicate">replicate</code>, <code id="component_eval_+3A_weights">weights</code></td>
<td>
<p>Specification of where to evaluate a component.
The four inputs are passed on to the joint <code>bru_mapper</code> for the component,
as
</p>
<div class="sourceCode"><pre>list(mapper = list(
       main = main,
       group = group,
       replicate = replicate),
     scale = weights)
</pre></div></td></tr>
<tr><td><code id="component_eval_+3A_.state">.state</code></td>
<td>
<p>The internal component state. Normally supplied automatically
by the internal methods for evaluating inlabru predictor expressions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of values for a component
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (bru_safe_inla()) {
  mesh &lt;- fmesher::fm_mesh_2d_inla(
    cbind(0, 0),
    offset = 2, max.edge = 0.25
  )
  spde &lt;- INLA::inla.spde2.pcmatern(mesh,
    prior.range = c(0.1, 0.01),
    prior.sigma = c(2, 0.01)
  )
  data &lt;- sp::SpatialPointsDataFrame(
    matrix(runif(10), 5, 2),
    data = data.frame(z = rnorm(5))
  )
  fit &lt;- bru(z ~ -1 + field(coordinates, model = spde),
    family = "gaussian", data = data
  )
  pred &lt;- predict(
    fit,
    data = data.frame(x = 0.5, y = 0.5),
    formula = ~ field_eval(cbind(x, y))
  )
}

## End(Not run)
</code></pre>

<hr>
<h2 id='component_list'>Methods for inlabru component lists</h2><span id='topic+component_list'></span><span id='topic+bru_component_list'></span><span id='topic+component_list.formula'></span><span id='topic+component_list.list'></span><span id='topic+c.component_list'></span><span id='topic+c.component'></span><span id='topic++5B.component_list'></span>

<h3>Description</h3>

<p>Constructor methods for inlabru component lists. Syntax details are given in
<code><a href="#topic+component">component()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>component_list(object, lhoods = NULL, .envir = parent.frame(), ...)

## S3 method for class 'formula'
component_list(object, lhoods = NULL, .envir = parent.frame(), ...)

## S3 method for class 'list'
component_list(object, lhoods = NULL, .envir = parent.frame(), ...)

## S3 method for class 'component_list'
c(...)

## S3 method for class 'component'
c(...)

## S3 method for class 'component_list'
x[i]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="component_list_+3A_object">object</code></td>
<td>
<p>The object to operate on</p>
</td></tr>
<tr><td><code id="component_list_+3A_lhoods">lhoods</code></td>
<td>
<p>A <code>bru_like_list</code> object</p>
</td></tr>
<tr><td><code id="component_list_+3A_.envir">.envir</code></td>
<td>
<p>An evaluation environment for non-formula input</p>
</td></tr>
<tr><td><code id="component_list_+3A_...">...</code></td>
<td>
<p>Parameters passed on to other methods. Also see Details.</p>
</td></tr>
<tr><td><code id="component_list_+3A_x">x</code></td>
<td>
<p><code>component_list</code> object from which to extract a sub-list</p>
</td></tr>
<tr><td><code id="component_list_+3A_i">i</code></td>
<td>
<p>indices specifying elements to extract</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>component_list.formula</code>: Convert a component formula
into a <code>component_list</code> object
</p>
</li></ul>


<ul>
<li> <p><code>component_list.list</code>: Combine a list of components and/or component formulas
into a <code>component_list</code> object
</p>
</li></ul>


<ul>
<li> <p><code>c.component_list</code>: The <code>...</code> arguments should be <code>component_list</code>
objects. The environment from the first argument will be applied to the
resulting <code>component_list</code>.
</p>
</li></ul>


<ul>
<li> <p><code>c.component</code>: The <code>...</code> arguments should be <code>component</code>
objects. The environment from the first argument will be applied to the
resulting &ldquo;component_list'.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Fabian E. Bachl <a href="mailto:bachlfab@gmail.com">bachlfab@gmail.com</a> and
Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Other component constructors: 
<code><a href="#topic+component">component</a>()</code>
</p>
<p>Other component constructors: 
<code><a href="#topic+component">component</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># As an example, let us create a linear component. Here, the component is
# called "myLinearEffectOfX" while the covariate the component acts on is
# called "x". Note that a list of components is returned because the
# formula may define multiple components

eff &lt;- component_list(~ myLinearEffectOfX(main = x, model = "linear"))
summary(eff[[1]])
# Equivalent shortcuts:
eff &lt;- component_list(~ myLinearEffectOfX(x, model = "linear"))
eff &lt;- component_list(~ myLinearEffectOfX(x))
# Individual component
eff &lt;- component("myLinearEffectOfX", main = x, model = "linear")
</code></pre>

<hr>
<h2 id='deltaIC'>Summarise DIC and WAIC from <code>lgcp</code> objects.</h2><span id='topic+deltaIC'></span>

<h3>Description</h3>

<p>Calculates DIC and/or WAIC differences and produces an ordered summary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deltaIC(..., criterion = "DIC")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deltaIC_+3A_...">...</code></td>
<td>
<p>Comma-separated objects inheriting from class <code>inla</code> and obtained
from a run of <code>INLA::inla()</code>, <code><a href="#topic+bru">bru()</a></code> or <code><a href="#topic+lgcp">lgcp()</a></code></p>
</td></tr>
<tr><td><code id="deltaIC_+3A_criterion">criterion</code></td>
<td>
<p>character vector. If it includes 'DIC', computes DIC differences;
If it contains 'WAIC', computes WAIC differences. Default: 'DIC'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with each row containing the Model name, DIC and Delta.DIC,
and/or WAIC and Delta.WAIC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (bru_safe_inla(multicore = FALSE)) {
  # Generate some data
  input.df &lt;- data.frame(idx = 1:10, x = cos(1:10))
  input.df &lt;- within(
    input.df,
    y &lt;- rpois(10, 5 + 2 * cos(1:10) + rnorm(10, mean = 0, sd = 0.1))
  )

  # Fit two models
  fit1 &lt;- bru(
    y ~ x,
    family = "poisson",
    data = input.df,
    options = list(control.compute = list(dic = TRUE))
  )
  fit2 &lt;- bru(
    y ~ x + rand(idx, model = "iid"),
    family = "poisson",
    data = input.df,
    options = list(control.compute = list(dic = TRUE))
  )

  # Compare DIC

  deltaIC(fit1, fit2)
}

</code></pre>

<hr>
<h2 id='devel.cvmeasure'>Variance and correlations measures for prediction components</h2><span id='topic+devel.cvmeasure'></span>

<h3>Description</h3>

<p>Calculates local and integrated variance and correlation measures as introduced by Yuan et al. (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>devel.cvmeasure(joint, prediction1, prediction2, samplers = NULL, mesh = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="devel.cvmeasure_+3A_joint">joint</code></td>
<td>
<p>A joint <code>prediction</code> of two latent model components.</p>
</td></tr>
<tr><td><code id="devel.cvmeasure_+3A_prediction1">prediction1</code></td>
<td>
<p>A <code>prediction</code> of the first component.</p>
</td></tr>
<tr><td><code id="devel.cvmeasure_+3A_prediction2">prediction2</code></td>
<td>
<p>A <code>prediction</code> of the second component.</p>
</td></tr>
<tr><td><code id="devel.cvmeasure_+3A_samplers">samplers</code></td>
<td>
<p>A SpatialPolygon object describing the area for which to compute the cumulative variance measure.</p>
</td></tr>
<tr><td><code id="devel.cvmeasure_+3A_mesh">mesh</code></td>
<td>
<p>The <code>inla.mesh</code> for which the prediction was performed (required for cumulative Vmeasure).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Variance and correlations measures.
</p>


<h3>References</h3>

<p>Y. Yuan, F. E. Bachl, F. Lindgren, D. L. Brochers, J. B. Illian, S. T. Buckland, H. Rue, T. Gerrodette. 2017.
Point process models for spatio-temporal distance sampling data from a large-scale survey of blue whales.
<a href="https://arxiv.org/abs/1604.06013">https://arxiv.org/abs/1604.06013</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (bru_safe_inla() &amp;&amp;
    require(ggplot2, quietly = TRUE) &amp;&amp;
    bru_safe_sp() &amp;&amp;
    require("sp")) {

  # Load Gorilla data

  data("gorillas", package = "inlabru")

  # Use RColorBrewer

  library(RColorBrewer)

  # Fit a model with two components:
  # 1) A spatial smooth SPDE
  # 2) A spatial covariate effect (vegetation)

  pcmatern &lt;- INLA::inla.spde2.pcmatern(gorillas$mesh,
    prior.sigma = c(0.1, 0.01),
    prior.range = c(0.01, 0.01)
  )

  cmp &lt;- coordinates ~ vegetation(gorillas$gcov$vegetation, model = "factor_contrast") +
    spde(coordinates, model = pcmatern) -
    Intercept(1)

  fit &lt;- lgcp(cmp, gorillas$nests,
    samplers = gorillas$boundary,
    domain = list(coordinates = gorillas$mesh),
    options = list(control.inla = list(int.strategy = "eb"))
  )

  # Predict SPDE and vegetation at the mesh vertex locations

  vrt &lt;- fm_vertices(gorillas$mesh, format = "sp")
  pred &lt;- predict(
    fit,
    vrt,
    ~ list(
      joint = spde + vegetation,
      field = spde,
      veg = vegetation
    )
  )

  # Plot component mean

  multiplot(ggplot() +
    gg(gorillas$mesh, color = pred$joint$mean) +
    coord_equal() +
    theme(legend.position = "bottom"),
  ggplot() +
    gg(gorillas$mesh, color = pred$field$mean) +
    coord_equal() +
    theme(legend.position = "bottom"),
  ggplot() +
    gg(gorillas$mesh, color = pred$veg$mean) +
    coord_equal() +
    theme(legend.position = "bottom"),
  cols = 3
  )

  # Plot component variance

  multiplot(ggplot() +
    gg(gorillas$mesh, color = pred$joint$var) +
    coord_equal() +
    theme(legend.position = "bottom"),
  ggplot() +
    gg(gorillas$mesh, color = pred$field$var) +
    coord_equal() +
    theme(legend.position = "bottom"),
  ggplot() +
    gg(gorillas$mesh, color = pred$veg$var) +
    coord_equal() +
    theme(legend.position = "bottom"),
  cols = 3
  )

  # Calculate variance and correlation measure

  vm &lt;- devel.cvmeasure(pred$joint, pred$field, pred$veg)
  lprange &lt;- range(vm$var.joint, vm$var1, vm$var2)

  # Variance contribution of the components

  csc &lt;- scale_fill_gradientn(colours = brewer.pal(9, "YlOrRd"), limits = lprange)
  boundary &lt;- gorillas$boundary

  plot.1 &lt;- ggplot() +
    gg(gorillas$mesh, color = vm$var.joint, mask = boundary) +
    csc +
    coord_equal() +
    ggtitle("joint") +
    theme(legend.position = "bottom")
  plot.2 &lt;- ggplot() +
    gg(gorillas$mesh, color = vm$var1, mask = boundary) +
    csc +
    coord_equal() +
    ggtitle("SPDE") +
    theme(legend.position = "bottom")
  plot.3 &lt;- ggplot() +
    gg(gorillas$mesh, color = vm$var2, mask = boundary) +
    csc +
    coord_equal() +
    ggtitle("vegetation") +
    theme(legend.position = "bottom")

  multiplot(plot.1, plot.2, plot.3, cols = 3)

  # Covariance of SPDE field and vegetation

  ggplot() +
    gg(gorillas$mesh, color = vm$cov)

  # Correlation between field and vegetation

  ggplot() +
    gg(gorillas$mesh, color = vm$cor)

  # Variance and correlation integrated over space

  vm.int &lt;- devel.cvmeasure(pred$joint, pred$field, pred$veg,
    samplers = fm_int(gorillas$mesh, gorillas$boundary),
    mesh = gorillas$mesh
  )
  vm.int
}

</code></pre>

<hr>
<h2 id='eval_in_data_context'>Evaluate expressions in the data context</h2><span id='topic+eval_in_data_context'></span>

<h3>Description</h3>

<p>Evaluate expressions in the data context
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_in_data_context(
  input,
  data = NULL,
  response_data = NULL,
  default = NULL,
  .envir = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_in_data_context_+3A_input">input</code></td>
<td>
<p>An expression to be evaluated</p>
</td></tr>
<tr><td><code id="eval_in_data_context_+3A_data">data</code></td>
<td>
<p>Likelihood-specific data, as a <code>data.frame</code> or
<code>SpatialPoints[DataFrame]</code>
object.</p>
</td></tr>
<tr><td><code id="eval_in_data_context_+3A_response_data">response_data</code></td>
<td>
<p>Likelihood-specific data for models that need different
size/format for inputs and response variables, as a <code>data.frame</code> or
<code>SpatialPoints[DataFrame]</code>
object.</p>
</td></tr>
<tr><td><code id="eval_in_data_context_+3A_default">default</code></td>
<td>
<p>Value used if the expression is evaluated as NULL. Default
NULL</p>
</td></tr>
<tr><td><code id="eval_in_data_context_+3A_.envir">.envir</code></td>
<td>
<p>The evaluation environment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of expression evaluation
</p>

<hr>
<h2 id='eval_spatial'>Evaluate spatial covariates</h2><span id='topic+eval_spatial'></span><span id='topic+eval_spatial.SpatialPolygonsDataFrame'></span><span id='topic+eval_spatial.SpatialPixelsDataFrame'></span><span id='topic+eval_spatial.SpatialGridDataFrame'></span><span id='topic+eval_spatial.sf'></span><span id='topic+eval_spatial.SpatRaster'></span><span id='topic+eval_spatial.stars'></span>

<h3>Description</h3>

<p>Evaluate spatial covariates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_spatial(data, where, layer = NULL, selector = NULL)

## S3 method for class 'SpatialPolygonsDataFrame'
eval_spatial(data, where, layer = NULL, selector = NULL)

## S3 method for class 'SpatialPixelsDataFrame'
eval_spatial(data, where, layer = NULL, selector = NULL)

## S3 method for class 'SpatialGridDataFrame'
eval_spatial(data, where, layer = NULL, selector = NULL)

## S3 method for class 'sf'
eval_spatial(data, where, layer = NULL, selector = NULL)

## S3 method for class 'SpatRaster'
eval_spatial(data, where, layer = NULL, selector = NULL)

## S3 method for class 'stars'
eval_spatial(data, where, layer = NULL, selector = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_spatial_+3A_data">data</code></td>
<td>
<p>Spatial data</p>
</td></tr>
<tr><td><code id="eval_spatial_+3A_where">where</code></td>
<td>
<p>Where to evaluate the data</p>
</td></tr>
<tr><td><code id="eval_spatial_+3A_layer">layer</code></td>
<td>
<p>Which <code>data</code> layer to extract (as integer or character).
May be a vector, specifying a separate layer for each <code>where</code> item.</p>
</td></tr>
<tr><td><code id="eval_spatial_+3A_selector">selector</code></td>
<td>
<p>The name of a variable in <code>where</code> specifying the <code>layer</code>
information.</p>
</td></tr>
</table>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>eval_spatial(SpatialPolygonsDataFrame)</code>: Compatibility wrapper for <code>eval_spatial.sf</code>
</p>
</li>
<li> <p><code>eval_spatial(sf)</code>: Supports point-in-polygon information lookup.
Other combinations are untested.
</p>
</li></ul>

<hr>
<h2 id='evaluate_comp_lin'>Compute all component linearisations</h2><span id='topic+evaluate_comp_lin'></span>

<h3>Description</h3>

<p>Computes individual <code>bru_mapper_taylor</code> objects for included components
for each model likelihood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_comp_lin(model, input, state, inla_f = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_comp_lin_+3A_model">model</code></td>
<td>
<p>A <code>bru_model</code> object</p>
</td></tr>
<tr><td><code id="evaluate_comp_lin_+3A_input">input</code></td>
<td>
<p>A list of named lists of component inputs</p>
</td></tr>
<tr><td><code id="evaluate_comp_lin_+3A_state">state</code></td>
<td>
<p>A named list of component states</p>
</td></tr>
<tr><td><code id="evaluate_comp_lin_+3A_inla_f">inla_f</code></td>
<td>
<p>Controls the input data interpretations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list (class 'comp_simple') of named lists (class 'comp_simple_list')
of <code>bru_mapper_taylor</code> objects,
one for each included component
</p>

<hr>
<h2 id='evaluate_comp_simple'>Compute simplified component mappings</h2><span id='topic+evaluate_comp_simple'></span><span id='topic+evaluate_comp_simple.component_list'></span><span id='topic+evaluate_comp_simple.bru_model'></span>

<h3>Description</h3>

<p>Computes individual <code>bru_mapper_taylor</code> objects for included linear components
for each model likelihood, and keeps non-linear mappers intact.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_comp_simple(...)

## S3 method for class 'component_list'
evaluate_comp_simple(components, input, inla_f = FALSE, ...)

## S3 method for class 'bru_model'
evaluate_comp_simple(model, input, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_comp_simple_+3A_input">input</code></td>
<td>
<p>A list of named lists of component inputs</p>
</td></tr>
<tr><td><code id="evaluate_comp_simple_+3A_inla_f">inla_f</code></td>
<td>
<p>Controls the input data interpretations</p>
</td></tr>
<tr><td><code id="evaluate_comp_simple_+3A_model">model</code></td>
<td>
<p>A <code>bru_model</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list (class 'comp_simple_list_list') of named lists (class 'comp_simple_list')
of <code>bru_mapper</code> objects,
one for each included component
</p>

<hr>
<h2 id='evaluate_effect_single_state'>Evaluate a component effect</h2><span id='topic+evaluate_effect_single_state'></span><span id='topic+evaluate_effect_multi_state'></span><span id='topic+evaluate_effect_single_state.bru_mapper'></span><span id='topic+evaluate_effect_single_state.comp_simple_list'></span><span id='topic+evaluate_effect_multi_state.comp_simple_list'></span><span id='topic+evaluate_effect_single_state.component_list'></span><span id='topic+evaluate_effect_multi_state.component_list'></span>

<h3>Description</h3>

<p>Calculate latent component effects given some data and the state of the
component's internal random variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_effect_single_state(...)

evaluate_effect_multi_state(...)

## S3 method for class 'bru_mapper'
evaluate_effect_single_state(component, input, state, ..., label = NULL)

## S3 method for class 'comp_simple_list'
evaluate_effect_single_state(components, input, state, ...)

## S3 method for class 'comp_simple_list'
evaluate_effect_multi_state(components, input, state, ...)

## S3 method for class 'component_list'
evaluate_effect_single_state(components, input, state, ...)

## S3 method for class 'component_list'
evaluate_effect_multi_state(components, input, state, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_effect_single_state_+3A_...">...</code></td>
<td>
<p>Optional additional parameters, e.g. <code>inla_f</code>. Normally unused.</p>
</td></tr>
<tr><td><code id="evaluate_effect_single_state_+3A_component">component</code></td>
<td>
<p>A <code>bru_mapper</code>, <code>bru_component</code>, <code>comp_simple</code>, or <code>comp_simple_list</code>.</p>
</td></tr>
<tr><td><code id="evaluate_effect_single_state_+3A_input">input</code></td>
<td>
<p>Pre-evaluated component input</p>
</td></tr>
<tr><td><code id="evaluate_effect_single_state_+3A_state">state</code></td>
<td>
<p>Specification of one (for <code>evaluate_effect_single_state</code>) or several
(for <code>evaluate_effect_multi_State</code>) latent variable states:
</p>

<ul>
<li> <p><code>evaluate_effect_single_state.bru_mapper</code>: A vector of the latent component state.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;evaluate_effect_single_state.*_list&#8288;</code>: list of named state vectors.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;evaluate_effect_multi_state.*_list&#8288;</code>: list of lists of named state vectors.
</p>
</li></ul>
</td></tr>
<tr><td><code id="evaluate_effect_single_state_+3A_label">label</code></td>
<td>
<p>Option label used for any warning messages, specifying the
affected component.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>evaluate_effect_single_state.component_list</code>: A list of evaluated
component effect values
</p>
</li></ul>


<ul>
<li> <p><code>evaluate_effect_multi.comp_simple_list</code>: A list of lists of
evaluated component effects, one list for each state
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Fabian E. Bachl <a href="mailto:bachlfab@gmail.com">bachlfab@gmail.com</a> and
Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>

<hr>
<h2 id='evaluate_index'>Compute all index values</h2><span id='topic+evaluate_index'></span>

<h3>Description</h3>

<p>Computes the index values matrices for included components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_index(model, lhoods)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_index_+3A_model">model</code></td>
<td>
<p>A <code>bru_model</code> object</p>
</td></tr>
<tr><td><code id="evaluate_index_+3A_lhoods">lhoods</code></td>
<td>
<p>A <code>bru_like_list</code> object. Deprecated and ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of <code>idx_full</code> and <code>idx_inla</code>,
named list of indices, and <code>inla_subset</code>, and <code>inla_subset</code>,
a named list of logical subset specifications for extracting the <code>INLA::f()</code>
compatible index subsets.
</p>

<hr>
<h2 id='evaluate_inputs'>Compute all component inputs</h2><span id='topic+evaluate_inputs'></span>

<h3>Description</h3>

<p>Computes the component inputs for included components
for each model likelihood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_inputs(model, lhoods, inla_f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_inputs_+3A_model">model</code></td>
<td>
<p>A <code>bru_model</code> object</p>
</td></tr>
<tr><td><code id="evaluate_inputs_+3A_lhoods">lhoods</code></td>
<td>
<p>A <code>bru_like_list</code> object</p>
</td></tr>
<tr><td><code id="evaluate_inputs_+3A_inla_f">inla_f</code></td>
<td>
<p>logical</p>
</td></tr>
</table>

<hr>
<h2 id='evaluate_model'>Evaluate or sample from a posterior result given a model and locations</h2><span id='topic+evaluate_model'></span><span id='topic+evaluate_state'></span>

<h3>Description</h3>

<p>Evaluate or sample from a posterior result given a model and locations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_model(
  model,
  state,
  data = NULL,
  input = NULL,
  comp_simple = NULL,
  predictor = NULL,
  format = NULL,
  used = NULL,
  ...
)

evaluate_state(
  model,
  result,
  property = "mode",
  n = 1,
  seed = 0L,
  num.threads = NULL,
  internal_hyperpar = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_model_+3A_model">model</code></td>
<td>
<p>A <a href="#topic+bru">bru</a> model</p>
</td></tr>
<tr><td><code id="evaluate_model_+3A_state">state</code></td>
<td>
<p>list of state lists, as generated by <code><a href="#topic+evaluate_state">evaluate_state()</a></code></p>
</td></tr>
<tr><td><code id="evaluate_model_+3A_data">data</code></td>
<td>
<p>A <code>list</code>, <code>data.frame</code>, or <code>Spatial*DataFrame</code>, with coordinates
and covariates needed to evaluate the predictor.</p>
</td></tr>
<tr><td><code id="evaluate_model_+3A_input">input</code></td>
<td>
<p>Precomputed inputs list for the components</p>
</td></tr>
<tr><td><code id="evaluate_model_+3A_comp_simple">comp_simple</code></td>
<td>
<p>Precomputed <code>comp_simple_list</code> for the components</p>
</td></tr>
<tr><td><code id="evaluate_model_+3A_predictor">predictor</code></td>
<td>
<p>A formula or an expression to be evaluated given the
posterior or for each sample thereof. The default (<code>NULL</code>) returns a
<code>data.frame</code> containing the sampled effects. In case of a formula the right
hand side is used for evaluation.</p>
</td></tr>
<tr><td><code id="evaluate_model_+3A_format">format</code></td>
<td>
<p>character; determines the storage format of predictor output.
Available options:
</p>

<ul>
<li> <p><code>"auto"</code> If the first evaluated result is a vector or single-column matrix,
the &quot;matrix&quot; format is used, otherwise &quot;list&quot;.
</p>
</li>
<li> <p><code>"matrix"</code> A matrix where each column contains the evaluated predictor
expression for a state.
</p>
</li>
<li> <p><code>"list"</code> A list where each element contains the evaluated predictor
expression for a state.
</p>
</li></ul>
</td></tr>
<tr><td><code id="evaluate_model_+3A_used">used</code></td>
<td>
<p>A <code><a href="#topic+bru_used">bru_used()</a></code> object, or NULL (default)</p>
</td></tr>
<tr><td><code id="evaluate_model_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code>inla.posterior.sample</code></p>
</td></tr>
<tr><td><code id="evaluate_model_+3A_result">result</code></td>
<td>
<p>A <code>bru</code> object from <code><a href="#topic+bru">bru()</a></code> or <code><a href="#topic+lgcp">lgcp()</a></code></p>
</td></tr>
<tr><td><code id="evaluate_model_+3A_property">property</code></td>
<td>
<p>Property of the model components to obtain value from.
Default: &quot;mode&quot;. Other options are &quot;mean&quot;, &quot;0.025quant&quot;, &quot;0.975quant&quot;,
&quot;sd&quot; and &quot;sample&quot;. In case of &quot;sample&quot; you will obtain samples from the
posterior (see <code>n</code> parameter). If <code>result</code> is <code>NULL</code>, all-zero vectors are
returned for each component.</p>
</td></tr>
<tr><td><code id="evaluate_model_+3A_n">n</code></td>
<td>
<p>Number of samples to draw.</p>
</td></tr>
<tr><td><code id="evaluate_model_+3A_seed">seed</code></td>
<td>
<p>If seed != 0L, the random seed</p>
</td></tr>
<tr><td><code id="evaluate_model_+3A_num.threads">num.threads</code></td>
<td>
<p>Specification of desired number of threads for parallel
computations. Default NULL, leaves it up to INLA.
When seed != 0, overridden to &quot;1:1&quot;</p>
</td></tr>
<tr><td><code id="evaluate_model_+3A_internal_hyperpar">internal_hyperpar</code></td>
<td>
<p>logical; If <code>TRUE</code>, return hyperparameter properties
on the internal scale. Currently ignored when <code>property="sample"</code>.
Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>evaluate_model</code> is a wrapper to evaluate model state, A-matrices,
effects, and predictor, all in one call.
</p>
</li></ul>


<ul>
<li> <p><code>evaluate_state</code> evaluates model state properties or samples
</p>
</li></ul>


<hr>
<h2 id='evaluate_predictor'>Evaluate component effects or expressions</h2><span id='topic+evaluate_predictor'></span>

<h3>Description</h3>

<p>Evaluate component effects or expressions, based on a bru model and one or
several states of the latent variables and hyperparameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_predictor(
  model,
  state,
  data,
  effects,
  predictor,
  used = NULL,
  format = "auto"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_predictor_+3A_state">state</code></td>
<td>
<p>A list where each element is a list of named latent state
information, as produced by <code><a href="#topic+evaluate_state">evaluate_state()</a></code></p>
</td></tr>
<tr><td><code id="evaluate_predictor_+3A_data">data</code></td>
<td>
<p>A <code>list</code>, <code>data.frame</code>, or <code>Spatial*DataFrame</code>, with coordinates
and covariates needed to evaluate the model.</p>
</td></tr>
<tr><td><code id="evaluate_predictor_+3A_effects">effects</code></td>
<td>
<p>A list where each element is list of named evaluated effects,
as computed by <code><a href="#topic+evaluate_effect_multi_state.component_list">evaluate_effect_multi_state.component_list()</a></code></p>
</td></tr>
<tr><td><code id="evaluate_predictor_+3A_predictor">predictor</code></td>
<td>
<p>Either a formula or expression</p>
</td></tr>
<tr><td><code id="evaluate_predictor_+3A_used">used</code></td>
<td>
<p>A <code><a href="#topic+bru_used">bru_used()</a></code> object, or NULL (default)</p>
</td></tr>
<tr><td><code id="evaluate_predictor_+3A_format">format</code></td>
<td>
<p>character; determines the storage format of the output.
Available options:
</p>

<ul>
<li> <p><code>"auto"</code> If the first evaluated result is a vector or single-column matrix,
the &quot;matrix&quot; format is used, otherwise &quot;list&quot;.
</p>
</li>
<li> <p><code>"matrix"</code> A matrix where each column contains the evaluated predictor
expression for a state.
</p>
</li>
<li> <p><code>"list"</code> A list where each column contains the evaluated predictor
expression for a state.
</p>
</li></ul>

<p>Default: &quot;auto&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each component, e.g. &quot;name&quot;, the state values are available as
<code>name_latent</code>, and arbitrary evaluation can be done with <code>name_eval(...)</code>, see
<code><a href="#topic+component_eval">component_eval()</a></code>.
</p>


<h3>Value</h3>

<p>A list or matrix is returned, as specified by <code>format</code>
</p>

<hr>
<h2 id='expand_labels'>Expand labels</h2><span id='topic+expand_labels'></span>

<h3>Description</h3>

<p>Expand labels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_labels(labels, expand, suffix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_labels_+3A_labels">labels</code></td>
<td>
<p>character vector; original labels</p>
</td></tr>
<tr><td><code id="expand_labels_+3A_expand">expand</code></td>
<td>
<p>character vector; subset of labels to expand</p>
</td></tr>
<tr><td><code id="expand_labels_+3A_suffix">suffix</code></td>
<td>
<p>character; the suffix to add to the labels selected by <code>expand</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of labels with suffix appended to the selected labels
</p>

<hr>
<h2 id='extract_property'>Extract a summary property from all results of an inla result</h2><span id='topic+extract_property'></span>

<h3>Description</h3>

<p>Extract a summary property from all results of an inla result
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_property(result, property, internal_hyperpar = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_property_+3A_result">result</code></td>
<td>
<p>an <code>inla</code> result object</p>
</td></tr>
<tr><td><code id="extract_property_+3A_property">property</code></td>
<td>
<p>character; &quot;mean&quot;, &quot;sd&quot;, &quot;mode&quot;, or some other column
identifier for inla result <code style="white-space: pre;">&#8288;$summary.fixed&#8288;</code>, <code style="white-space: pre;">&#8288;$summary.random$label&#8288;</code>, and
<code style="white-space: pre;">&#8288;$summary.hyperpar&#8288;</code>, or &quot;joint_mode&quot;. For &quot;joint_mode&quot;, the joint latent mode
is extracted, and the joint hyperparameter mode, in the internal scale.
For &quot;predictor_sd&quot; the posterior standard deviations of the linear predictor
are returned.</p>
</td></tr>
<tr><td><code id="extract_property_+3A_internal_hyperpar">internal_hyperpar</code></td>
<td>
<p>logical; if <code>TRUE</code>, use internal scale for
hyperparamter properties. Default is <code>FALSE</code>, except when <code>property</code> is
&quot;joint_mode&quot; which forces <code>internal_hyperpar=TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named list for each estimated fixed effect coefficient,
random effect vector, and hyperparameter. The hyperparameter names are
standardised with <code><a href="#topic+bru_standardise_names">bru_standardise_names()</a></code>
</p>

<hr>
<h2 id='generate'>Generate samples from fitted bru models</h2><span id='topic+generate'></span><span id='topic+generate.bru'></span>

<h3>Description</h3>

<p>Generic function for sampling for fitted models. The function invokes
particular methods which depend on the class of the first argument.
</p>
<p>Takes a fitted <code>bru</code> object produced by the function <code><a href="#topic+bru">bru()</a></code> and produces
samples given a new set of values for the model covariates or the original
values used for the model fit. The samples can be based on any R expression
that is valid given these values/covariates and the joint
posterior of the estimated random effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate(object, ...)

## S3 method for class 'bru'
generate(
  object,
  newdata = NULL,
  formula = NULL,
  n.samples = 100,
  seed = 0L,
  num.threads = NULL,
  include = NULL,
  exclude = NULL,
  used = NULL,
  ...,
  data = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_+3A_object">object</code></td>
<td>
<p>A <code>bru</code> object obtained by calling <code><a href="#topic+bru">bru()</a></code>.</p>
</td></tr>
<tr><td><code id="generate_+3A_...">...</code></td>
<td>
<p>additional, unused arguments.</p>
</td></tr>
<tr><td><code id="generate_+3A_newdata">newdata</code></td>
<td>
<p>A data.frame or SpatialPointsDataFrame of covariates needed
for sampling.</p>
</td></tr>
<tr><td><code id="generate_+3A_formula">formula</code></td>
<td>
<p>A formula where the right hand side defines an R expression
to evaluate for each generated sample. If <code>NULL</code>, the latent and
hyperparameter states are returned as named list elements.
See Details for more information.</p>
</td></tr>
<tr><td><code id="generate_+3A_n.samples">n.samples</code></td>
<td>
<p>Integer setting the number of samples to draw in order to
calculate the posterior statistics.
The default, 100, is rather low but provides a quick approximate result.</p>
</td></tr>
<tr><td><code id="generate_+3A_seed">seed</code></td>
<td>
<p>Random number generator seed passed on to
<code>INLA::inla.posterior.sample</code></p>
</td></tr>
<tr><td><code id="generate_+3A_num.threads">num.threads</code></td>
<td>
<p>Specification of desired number of threads for parallel
computations. Default NULL, leaves it up to INLA.
When seed != 0, overridden to &quot;1:1&quot;</p>
</td></tr>
<tr><td><code id="generate_+3A_include">include</code></td>
<td>
<p>Character vector of component labels that are needed by the
predictor expression; Default: NULL (include all components that are not
explicitly excluded) if <code>newdata</code> is provided, otherwise <code>character(0)</code>.</p>
</td></tr>
<tr><td><code id="generate_+3A_exclude">exclude</code></td>
<td>
<p>Character vector of component labels that are not used by the
predictor expression. The exclusion list is applied to the list
as determined by the <code>include</code> parameter; Default: NULL (do not remove
any components from the inclusion list)</p>
</td></tr>
<tr><td><code id="generate_+3A_used">used</code></td>
<td>
<p>Either <code>NULL</code> or a <code><a href="#topic+bru_used">bru_used()</a></code> object, overriding <code>include</code> and
<code>exclude</code>.</p>
</td></tr>
<tr><td><code id="generate_+3A_data">data</code></td>
<td>
<p>Deprecated. Use <code>newdata</code> instead.
sampling.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In addition to the component names (that give the effect of each component
evaluated for the input data), the suffix <code style="white-space: pre;">&#8288;_latent&#8288;</code> variable name can be used
to directly access the latent state for a component, and the suffix function
<code style="white-space: pre;">&#8288;_eval&#8288;</code> can be used to evaluate a component at other input values than the
expressions defined in the component definition itself, e.g.
<code>field_eval(cbind(x, y))</code> for a component that was defined with
<code>field(coordinates, ...)</code> (see also <code><a href="#topic+component_eval">component_eval()</a></code>).
</p>
<p>For &quot;iid&quot; models with <code>mapper = bru_mapper_index(n)</code>, <code>rnorm()</code> is used to
generate new realisations for indices greater than <code>n</code>.
</p>


<h3>Value</h3>

<p>The form of the value returned by <code>generate()</code> depends on the data
class and prediction formula. Normally, a data.frame is returned, or a list
of data.frames (if the prediction formula generates a list)
</p>
<p>List of generated samples
</p>


<h3>See Also</h3>

<p><a href="#topic+predict.bru">predict.bru</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (bru_safe_inla(multicore = FALSE) &amp;&amp;
    require("sn", quietly = TRUE)) {

  # Generate data for a simple linear model

  input.df &lt;- data.frame(x = cos(1:10))
  input.df &lt;- within(input.df, y &lt;- 5 + 2 * cos(1:10) + rnorm(10, mean = 0, sd = 0.1))

  # Fit the model

  fit &lt;- bru(y ~ xeff(main = x, model = "linear"),
    family = "gaussian", data = input.df
  )
  summary(fit)

  # Generate samples for some predefined x

  df &lt;- data.frame(x = seq(-4, 4, by = 0.1))
  smp &lt;- generate(fit, df, ~ xeff + Intercept, n.samples = 10)

  # Plot the resulting realizations

  plot(df$x, smp[, 1], type = "l")
  for (k in 2:ncol(smp)) points(df$x, smp[, k], type = "l")

  # We can also draw samples form the joint posterior

  df &lt;- data.frame(x = 1)
  smp &lt;- generate(fit, df, ~ data.frame(xeff, Intercept), n.samples = 10)
  smp[[1]]

  # ... and plot them
  if (require(ggplot2, quietly = TRUE)) {
    plot(do.call(rbind, smp))
  }
}

</code></pre>

<hr>
<h2 id='gg'>ggplot2 geomes for inlabru related objects</h2><span id='topic+gg'></span>

<h3>Description</h3>

<p>gg is a generic function for generating geomes from various kinds of spatial objects, e.g. Spatial* data,
meshes, Raster objects and inla/inlabru predictions. The function invokes particular methods which depend
on the <a href="base.html#topic+class">class</a> of the first argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gg(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gg_+3A_data">data</code></td>
<td>
<p>an object for which to generate a geom.</p>
</td></tr>
<tr><td><code id="gg_+3A_...">...</code></td>
<td>
<p>Arguments passed on to the geom method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The form of the value returned by gg depends on the class of its argument. See the documentation of the particular methods for details of what is produced by that method.
</p>


<h3>See Also</h3>

<p>Other geomes for inla and inlabru predictions: 
<code><a href="#topic+gg.bru_prediction">gg.bru_prediction</a>()</code>,
<code><a href="#topic+gg.data.frame">gg.data.frame</a>()</code>,
<code><a href="#topic+gg.matrix">gg.matrix</a>()</code>,
<code><a href="#topic+gm">gm</a>()</code>
</p>
<p>Other geomes for spatial data: 
<code><a href="#topic+gg.SpatRaster">gg.SpatRaster</a>()</code>,
<code><a href="#topic+gg.SpatialGridDataFrame">gg.SpatialGridDataFrame</a>()</code>,
<code><a href="#topic+gg.SpatialLines">gg.SpatialLines</a>()</code>,
<code><a href="#topic+gg.SpatialPixels">gg.SpatialPixels</a>()</code>,
<code><a href="#topic+gg.SpatialPixelsDataFrame">gg.SpatialPixelsDataFrame</a>()</code>,
<code><a href="#topic+gg.SpatialPoints">gg.SpatialPoints</a>()</code>,
<code><a href="#topic+gg.SpatialPolygons">gg.SpatialPolygons</a>()</code>,
<code><a href="#topic+gg.sf">gg.sf</a>()</code>,
<code><a href="#topic+gm">gm</a>()</code>
</p>
<p>Other geomes for meshes: 
<code><a href="#topic+gg.fm_mesh_1d">gg.fm_mesh_1d</a>()</code>,
<code><a href="#topic+gg.fm_mesh_2d">gg.fm_mesh_2d</a>()</code>,
<code><a href="#topic+gm">gm</a>()</code>
</p>
<p>Other geomes for Raster data: 
<code><a href="#topic+gg.RasterLayer">gg.RasterLayer</a>()</code>,
<code><a href="#topic+gm">gm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("ggplot2", quietly = TRUE)) {
  # Load Gorilla data

  data(gorillas, package = "inlabru")

  # Invoke ggplot and add geomes for the Gorilla nests and the survey boundary

  ggplot() +
    gg(gorillas$boundary) +
    gg(gorillas$nests)
}
</code></pre>

<hr>
<h2 id='gg.bru_prediction'>Geom for predictions</h2><span id='topic+gg.bru_prediction'></span><span id='topic+gg.prediction'></span>

<h3>Description</h3>

<p>This geom serves to visualize <code>prediction</code> objects which usually results from a call to
<code><a href="#topic+predict.bru">predict.bru()</a></code>. Predictions objects provide summary statistics (mean, median, sd, ...) for
one or more random variables. For single variables (or if requested so by setting <code>bar = TRUE</code>),
a boxplot-style geom is constructed to show the statistics. For multivariate predictions the
mean of each variable (y-axis) is plotted agains the row number of the varriable in the prediction
data frame (x-axis) using <code>geom_line</code>. In addition, a <code>geom_ribbon</code> is used to show
the confidence interval.
</p>
<p>Note: <code>gg.bru_prediction</code> also understands the format of INLA-style posterior summaries, e.g.
<code>fit$summary.fixed</code> for an inla object <code>fit</code>
</p>
<p>Requires the <code>ggplot2</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bru_prediction'
gg(data, mapping = NULL, ribbon = TRUE, alpha = NULL, bar = FALSE, ...)

## S3 method for class 'prediction'
gg(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gg.bru_prediction_+3A_data">data</code></td>
<td>
<p>A prediction object, usually the result of a <code><a href="#topic+predict.bru">predict.bru()</a></code> call.</p>
</td></tr>
<tr><td><code id="gg.bru_prediction_+3A_mapping">mapping</code></td>
<td>
<p>a set of aesthetic mappings created by <code>aes</code>. These are passed on to <code>geom_line</code>.</p>
</td></tr>
<tr><td><code id="gg.bru_prediction_+3A_ribbon">ribbon</code></td>
<td>
<p>If TRUE, plot a ribbon around the line based on the smalles and largest
quantiles present in the data, found by matching names starting with <code>q</code> and
followed by a numerical value.  <code>inla()</code>-style <code>numeric+"quant"</code> names are converted
to inlabru style before matching.</p>
</td></tr>
<tr><td><code id="gg.bru_prediction_+3A_alpha">alpha</code></td>
<td>
<p>The ribbons numeric alpha (transparency) level in <code style="white-space: pre;">&#8288;[0,1]&#8288;</code>.</p>
</td></tr>
<tr><td><code id="gg.bru_prediction_+3A_bar">bar</code></td>
<td>
<p>If TRUE plot boxplot-style summary for each variable.</p>
</td></tr>
<tr><td><code id="gg.bru_prediction_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code>geom_line</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Concatenation of a <code>geom_line</code> value and optionally a <code>geom_ribbon</code> value.
</p>


<h3>See Also</h3>

<p>Other geomes for inla and inlabru predictions: 
<code><a href="#topic+gg">gg</a>()</code>,
<code><a href="#topic+gg.data.frame">gg.data.frame</a>()</code>,
<code><a href="#topic+gg.matrix">gg.matrix</a>()</code>,
<code><a href="#topic+gm">gm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (bru_safe_inla() &amp;&amp;
    require(sn, quietly = TRUE) &amp;&amp;
    require(ggplot2, quietly = TRUE)) {
  # Generate some data

  input.df &lt;- data.frame(x = cos(1:10))
  input.df &lt;- within(input.df, y &lt;- 5 + 2 * cos(1:10) + rnorm(10, mean = 0, sd = 0.1))

  # Fit a model with fixed effect 'x' and intercept 'Intercept'

  fit &lt;- bru(y ~ x, family = "gaussian", data = input.df)

  # Predict posterior statistics of 'x'

  xpost &lt;- predict(fit, NULL, formula = ~x_latent)

  # The statistics include mean, standard deviation, the 2.5% quantile, the median,
  # the 97.5% quantile, minimum and maximum sample drawn from the posterior as well as
  # the coefficient of variation and the variance.

  xpost

  # For a single variable like 'x' the default plotting method invoked by gg() will
  # show these statisics in a fashion similar to a box plot:
  ggplot() +
    gg(xpost)


  # The predict function can also be used to simultaneously estimate posteriors
  # of multiple variables:

  xipost &lt;- predict(fit,
    newdata = NULL,
    formula = ~ c(
      Intercept = Intercept_latent,
      x = x_latent
    )
  )
  xipost

  # If we still want a plot in the previous style we have to set the bar parameter to TRUE

  p1 &lt;- ggplot() +
    gg(xipost, bar = TRUE)
  p1

  # Note that gg also understands the posterior estimates generated while running INLA

  p2 &lt;- ggplot() +
    gg(fit$summary.fixed, bar = TRUE)
  multiplot(p1, p2)

  # By default, if the prediction has more than one row, gg will plot the column 'mean' against
  # the row index. This is for instance usefuul for predicting and plotting function
  # but not very meaningful given the above example:

  ggplot() +
    gg(xipost)

  # For ease of use we can also type

  plot(xipost)

  # This type of plot will show a ribbon around the mean, which viszualizes the upper and lower
  # quantiles mentioned above (2.5 and 97.5%). Plotting the ribbon can be turned of using the
  # \code{ribbon} parameter

  ggplot() +
    gg(xipost, ribbon = FALSE)

  # Much like the other geomes produced by gg we can adjust the plot using ggplot2 style
  # commands, for instance

  ggplot() +
    gg(xipost) +
    gg(xipost, mapping = aes(y = median), ribbon = FALSE, color = "red")
}

</code></pre>

<hr>
<h2 id='gg.data.frame'>Geom for data.frame</h2><span id='topic+gg.data.frame'></span>

<h3>Description</h3>

<p>This geom constructor will simply call <code><a href="#topic+gg.bru_prediction">gg.bru_prediction()</a></code> for the data provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
gg(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gg.data.frame_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code><a href="#topic+gg.bru_prediction">gg.bru_prediction()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Requires the <code>ggplot2</code> package.
</p>


<h3>Value</h3>

<p>Concatenation of a <code>geom_line</code> value and optionally a <code>geom_ribbon</code> value.
</p>


<h3>See Also</h3>

<p>Other geomes for inla and inlabru predictions: 
<code><a href="#topic+gg">gg</a>()</code>,
<code><a href="#topic+gg.bru_prediction">gg.bru_prediction</a>()</code>,
<code><a href="#topic+gg.matrix">gg.matrix</a>()</code>,
<code><a href="#topic+gm">gm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (bru_safe_inla() &amp;&amp;
    require(sn, quietly = TRUE) &amp;&amp;
    require(ggplot2, quietly = TRUE)) {
  # Generate some data

  input.df &lt;- data.frame(x = cos(1:10))
  input.df &lt;- within(input.df, y &lt;- 5 + 2 * cos(1:10) + rnorm(10, mean = 0, sd = 0.1))

  # Fit a model with fixed effect 'x' and intercept 'Intercept'

  fit &lt;- bru(y ~ x, family = "gaussian", data = input.df)

  # Predict posterior statistics of 'x'

  xpost &lt;- predict(fit, NULL, formula = ~x_latent)

  # The statistics include mean, standard deviation, the 2.5% quantile, the median,
  # the 97.5% quantile, minimum and maximum sample drawn from the posterior as well as
  # the coefficient of variation and the variance.

  xpost

  # For a single variable like 'x' the default plotting method invoked by gg() will
  # show these statisics in a fashion similar to a box plot:
  ggplot() +
    gg(xpost)


  # The predict function can also be used to simultaneously estimate posteriors
  # of multiple variables:

  xipost &lt;- predict(fit,
    newdata = NULL,
    formula = ~ c(
      Intercept = Intercept_latent,
      x = x_latent
    )
  )
  xipost

  # If we still want a plot in the previous style we have to set the bar parameter to TRUE

  p1 &lt;- ggplot() +
    gg(xipost, bar = TRUE)
  p1

  # Note that gg also understands the posterior estimates generated while running INLA

  p2 &lt;- ggplot() +
    gg(fit$summary.fixed, bar = TRUE)
  multiplot(p1, p2)

  # By default, if the prediction has more than one row, gg will plot the column 'mean' against
  # the row index. This is for instance usefuul for predicting and plotting function
  # but not very meaningful given the above example:

  ggplot() +
    gg(xipost)

  # For ease of use we can also type

  plot(xipost)

  # This type of plot will show a ribbon around the mean, which viszualizes the upper and lower
  # quantiles mentioned above (2.5 and 97.5%). Plotting the ribbon can be turned of using the
  # \code{ribbon} parameter

  ggplot() +
    gg(xipost, ribbon = FALSE)

  # Much like the other geomes produced by gg we can adjust the plot using ggplot2 style
  # commands, for instance

  ggplot() +
    gg(xipost) +
    gg(xipost, mapping = aes(y = median), ribbon = FALSE, color = "red")
}

</code></pre>

<hr>
<h2 id='gg.fm_mesh_1d'>Geom for fm_mesh_1d objects</h2><span id='topic+gg.fm_mesh_1d'></span><span id='topic+gg.inla.mesh.1d'></span>

<h3>Description</h3>

<p>This function generates a <code>geom_point</code> object showing the knots (vertices)
of a 1D mesh.
Requires the <code>ggplot2</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fm_mesh_1d'
gg(
  data,
  mapping = ggplot2::aes(.data[["x"]], .data[["y"]]),
  y = 0,
  shape = 4,
  ...
)

## S3 method for class 'inla.mesh.1d'
gg(
  data,
  mapping = ggplot2::aes(.data[["x"]], .data[["y"]]),
  y = 0,
  shape = 4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gg.fm_mesh_1d_+3A_data">data</code></td>
<td>
<p>An inla.mesh.1d object.</p>
</td></tr>
<tr><td><code id="gg.fm_mesh_1d_+3A_mapping">mapping</code></td>
<td>
<p>aesthetic mappings created by <code>aes</code>. These are passed on to <code>geom_point</code>.</p>
</td></tr>
<tr><td><code id="gg.fm_mesh_1d_+3A_y">y</code></td>
<td>
<p>Single or vector numeric defining the y-coordinates of the mesh knots to plot.</p>
</td></tr>
<tr><td><code id="gg.fm_mesh_1d_+3A_shape">shape</code></td>
<td>
<p>Shape of the knot markers.</p>
</td></tr>
<tr><td><code id="gg.fm_mesh_1d_+3A_...">...</code></td>
<td>
<p>parameters passed on to <code>geom_point</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object generated by <code>geom_point</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>gg(inla.mesh.1d)</code>: Alias for <code>gg.fm_mesh_1d</code>, supporting
<code>inla.mesh.1d</code> objects.
</p>
</li></ul>


<h3>See Also</h3>

<p>Other geomes for meshes: 
<code><a href="#topic+gg">gg</a>()</code>,
<code><a href="#topic+gg.fm_mesh_2d">gg.fm_mesh_2d</a>()</code>,
<code><a href="#topic+gm">gm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (require("fmesher", quietly = TRUE) &amp;&amp;
  require("ggplot2", quietly = TRUE)) {
  # Create a 1D mesh

  mesh &lt;- fm_mesh_1d(seq(0, 10, by = 0.5))

  # Plot it

  ggplot() +
    gg(mesh)

  # Plot it using a different shape and size for the mesh nodes

  ggplot() +
    gg(mesh, shape = "|", size = 5)
}


</code></pre>

<hr>
<h2 id='gg.fm_mesh_2d'>Geom for inla.mesh objects</h2><span id='topic+gg.fm_mesh_2d'></span><span id='topic+gg.inla.mesh'></span>

<h3>Description</h3>

<p>This function extracts the graph of an inla.mesh object and uses <code>geom_line</code> to visualize
the graph's edges. Alternatively, if the <code>color</code> argument is provided, interpolates the colors
across for a set of SpatialPixels covering the mesh area and calls <code><a href="#topic+gg.SpatialPixelsDataFrame">gg.SpatialPixelsDataFrame()</a></code>
to plot the interpolation.
Requires the <code>ggplot2</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fm_mesh_2d'
gg(
  data,
  color = NULL,
  alpha = NULL,
  edge.color = "grey",
  edge.linewidth = 0.25,
  interior = TRUE,
  int.color = "blue",
  int.linewidth = 0.5,
  exterior = TRUE,
  ext.color = "black",
  ext.linewidth = 1,
  crs = NULL,
  mask = NULL,
  nx = 500,
  ny = 500,
  ...
)

## S3 method for class 'inla.mesh'
gg(
  data,
  color = NULL,
  alpha = NULL,
  edge.color = "grey",
  edge.linewidth = 0.25,
  interior = TRUE,
  int.color = "blue",
  int.linewidth = 0.5,
  exterior = TRUE,
  ext.color = "black",
  ext.linewidth = 1,
  crs = NULL,
  mask = NULL,
  nx = 500,
  ny = 500,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gg.fm_mesh_2d_+3A_data">data</code></td>
<td>
<p>An <code>fm_mesh_2d</code> object.</p>
</td></tr>
<tr><td><code id="gg.fm_mesh_2d_+3A_color">color</code></td>
<td>
<p>A vector of scalar values to fill the mesh with colors.
The length of the vector mus correspond to the number of mesh vertices.
The alternative name <code>colour</code> is also recognised.</p>
</td></tr>
<tr><td><code id="gg.fm_mesh_2d_+3A_alpha">alpha</code></td>
<td>
<p>A vector of scalar values setting the alpha value of the colors provided.</p>
</td></tr>
<tr><td><code id="gg.fm_mesh_2d_+3A_edge.color">edge.color</code></td>
<td>
<p>Color of the regular mesh edges.</p>
</td></tr>
<tr><td><code id="gg.fm_mesh_2d_+3A_edge.linewidth">edge.linewidth</code></td>
<td>
<p>Line width for the regular mesh edges. Default 0.25</p>
</td></tr>
<tr><td><code id="gg.fm_mesh_2d_+3A_interior">interior</code></td>
<td>
<p>If TRUE, plot the interior boundaries of the mesh.</p>
</td></tr>
<tr><td><code id="gg.fm_mesh_2d_+3A_int.color">int.color</code></td>
<td>
<p>Color used to plot the interior constraint edges.</p>
</td></tr>
<tr><td><code id="gg.fm_mesh_2d_+3A_int.linewidth">int.linewidth</code></td>
<td>
<p>Line width for the interior constraint edges. Default 0.5</p>
</td></tr>
<tr><td><code id="gg.fm_mesh_2d_+3A_exterior">exterior</code></td>
<td>
<p>If TRUE, plot the exterior boundaries of the mesh.</p>
</td></tr>
<tr><td><code id="gg.fm_mesh_2d_+3A_ext.color">ext.color</code></td>
<td>
<p>Color used to plot the exterior boundary edges.</p>
</td></tr>
<tr><td><code id="gg.fm_mesh_2d_+3A_ext.linewidth">ext.linewidth</code></td>
<td>
<p>Line width for the exterior boundary edges. Default 1</p>
</td></tr>
<tr><td><code id="gg.fm_mesh_2d_+3A_crs">crs</code></td>
<td>
<p>A CRS object supported by <code><a href="#topic+fm_transform">fm_transform()</a></code> defining the coordinate
system to project the mesh to before plotting.</p>
</td></tr>
<tr><td><code id="gg.fm_mesh_2d_+3A_mask">mask</code></td>
<td>
<p>A SpatialPolygon defining the region that is plotted.</p>
</td></tr>
<tr><td><code id="gg.fm_mesh_2d_+3A_nx">nx</code></td>
<td>
<p>Number of pixels in x direction (when plotting using the color parameter).</p>
</td></tr>
<tr><td><code id="gg.fm_mesh_2d_+3A_ny">ny</code></td>
<td>
<p>Number of pixels in y direction (when plotting using the color parameter).</p>
</td></tr>
<tr><td><code id="gg.fm_mesh_2d_+3A_...">...</code></td>
<td>
<p>ignored arguments (S3 generic compatibility).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>geom_line</code> return values or, if the color argument is used, the
values of <code><a href="#topic+gg.SpatialPixelsDataFrame">gg.SpatialPixelsDataFrame()</a></code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>gg(inla.mesh)</code>: Alias for <code>gg.fm_mesh_2d</code>, supporting <code>inla.mesh</code>
objects.
</p>
</li></ul>


<h3>See Also</h3>

<p>Other geomes for meshes: 
<code><a href="#topic+gg">gg</a>()</code>,
<code><a href="#topic+gg.fm_mesh_1d">gg.fm_mesh_1d</a>()</code>,
<code><a href="#topic+gm">gm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (require(fmesher, quietly = TRUE) &amp;&amp;
    require(ggplot2, quietly = TRUE)) {

  # Load Gorilla data
  data("gorillas", package = "inlabru")

  # Plot mesh using default edge colors

  ggplot() +
    gg(gorillas$mesh)

  # Don't show interior and exterior boundaries

  ggplot() +
    gg(gorillas$mesh, interior = FALSE, exterior = FALSE)

  # Change the edge colors

  ggplot() +
    gg(gorillas$mesh,
      edge.color = "green",
      int.color = "black",
      ext.color = "blue"
    )

  # Use the x-coordinate of the vertices to colorize the triangles and
  # mask the plotted area by the survey boundary, i.e. only plot the inside

  xcoord &lt;- gorillas$mesh$loc[, 1]
  ggplot() +
    gg(gorillas$mesh, color = (xcoord - 580), mask = gorillas$boundary) +
    gg(gorillas$boundary)
}

</code></pre>

<hr>
<h2 id='gg.matrix'>Geom for matrix</h2><span id='topic+gg.matrix'></span>

<h3>Description</h3>

<p>Creates a tile geom for plotting a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matrix'
gg(data, mapping = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gg.matrix_+3A_data">data</code></td>
<td>
<p>A <code>matrix</code> object.</p>
</td></tr>
<tr><td><code id="gg.matrix_+3A_mapping">mapping</code></td>
<td>
<p>a set of aesthetic mappings created by <code>aes</code>. These are passed on to <code>geom_tile</code>.</p>
</td></tr>
<tr><td><code id="gg.matrix_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code>geom_tile</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Requires the <code>ggplot2</code> package.
</p>


<h3>Value</h3>

<p>A <code>geom_tile</code> with reversed y scale.
</p>


<h3>See Also</h3>

<p>Other geomes for inla and inlabru predictions: 
<code><a href="#topic+gg">gg</a>()</code>,
<code><a href="#topic+gg.bru_prediction">gg.bru_prediction</a>()</code>,
<code><a href="#topic+gg.data.frame">gg.data.frame</a>()</code>,
<code><a href="#topic+gm">gm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("ggplot2", quietly = TRUE)) {
  A &lt;- matrix(runif(100), nrow = 10)
  ggplot() +
    gg(A)
}
</code></pre>

<hr>
<h2 id='gg.RasterLayer'>Geom for RasterLayer objects</h2><span id='topic+gg.RasterLayer'></span>

<h3>Description</h3>

<p>This function takes a RasterLayer object, converts it into a
<code>SpatialPixelsDataFrame</code> and uses <code>geom_tile</code> to plot the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'RasterLayer'
gg(
  data,
  mapping = ggplot2::aes(x = .data[["x"]], y = .data[["y"]], fill = .data[["layer"]]),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gg.RasterLayer_+3A_data">data</code></td>
<td>
<p>A RasterLayer object.</p>
</td></tr>
<tr><td><code id="gg.RasterLayer_+3A_mapping">mapping</code></td>
<td>
<p>aesthetic mappings created by <code>aes</code>. These are passed on to <code>geom_tile</code>.</p>
</td></tr>
<tr><td><code id="gg.RasterLayer_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code>geom_tile</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires the <code>raster</code> and <code>ggplot2</code> packages.
</p>


<h3>Value</h3>

<p>An object returned by <code>geom_tile</code>
</p>


<h3>See Also</h3>

<p>Other geomes for Raster data: 
<code><a href="#topic+gg">gg</a>()</code>,
<code><a href="#topic+gm">gm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Some features require the raster and spatstat.data packages.
if (require("spatstat.data", quietly = TRUE) &amp;&amp;
  require("raster", quietly = TRUE) &amp;&amp;
  require("ggplot2", quietly = TRUE)) {
  # Load Gorilla data
  data("gorillas", package = "spatstat.data")

  # Convert elevation covariate to RasterLayer

  elev &lt;- as(gorillas.extra$elevation, "RasterLayer")

  # Plot the elevation

  ggplot() +
    gg(elev)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='gg.sf'>Geom helper for sf objects</h2><span id='topic+gg.sf'></span>

<h3>Description</h3>

<p>This function uses <code>geom_sf()</code>, unless overridden by the geom argument.
Requires the <code>ggplot2</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sf'
gg(data, mapping = NULL, ..., geom = "sf")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gg.sf_+3A_data">data</code></td>
<td>
<p>An <code>sf</code> object.</p>
</td></tr>
<tr><td><code id="gg.sf_+3A_mapping">mapping</code></td>
<td>
<p>Default mapping is <code>ggplot2::aes(geometry = ...)</code>,
where the geometry name is obtained from <code>attr(data, "sf_column")</code>.
This is merged with the user supplied mapping.</p>
</td></tr>
<tr><td><code id="gg.sf_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code>geom_sf</code> or <code>geom_tile</code>.</p>
</td></tr>
<tr><td><code id="gg.sf_+3A_geom">geom</code></td>
<td>
<p>Either &quot;sf&quot; (default) or &quot;tile&quot;. For &quot;tile&quot;, uses
<code>geom_tile(..., stat = "sf_coordinates")</code>, intended for converting point data
to grid tiles with the <code>fill</code> aesthetic, which is by default set to the first
data column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot return value
</p>


<h3>See Also</h3>

<p>Other geomes for spatial data: 
<code><a href="#topic+gg">gg</a>()</code>,
<code><a href="#topic+gg.SpatRaster">gg.SpatRaster</a>()</code>,
<code><a href="#topic+gg.SpatialGridDataFrame">gg.SpatialGridDataFrame</a>()</code>,
<code><a href="#topic+gg.SpatialLines">gg.SpatialLines</a>()</code>,
<code><a href="#topic+gg.SpatialPixels">gg.SpatialPixels</a>()</code>,
<code><a href="#topic+gg.SpatialPixelsDataFrame">gg.SpatialPixelsDataFrame</a>()</code>,
<code><a href="#topic+gg.SpatialPoints">gg.SpatialPoints</a>()</code>,
<code><a href="#topic+gg.SpatialPolygons">gg.SpatialPolygons</a>()</code>,
<code><a href="#topic+gm">gm</a>()</code>
</p>

<hr>
<h2 id='gg.SpatialGridDataFrame'>Geom for SpatialGridDataFrame objects</h2><span id='topic+gg.SpatialGridDataFrame'></span>

<h3>Description</h3>

<p>Coerces input <code>SpatialGridDataFrame</code> to <code>SpatialPixelsDataFrame</code> and calls
<code><a href="#topic+gg.SpatialPixelsDataFrame">gg.SpatialPixelsDataFrame()</a></code> to plot it.
Requires the <code>ggplot2</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatialGridDataFrame'
gg(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gg.SpatialGridDataFrame_+3A_data">data</code></td>
<td>
<p>A SpatialGridDataFrame object.</p>
</td></tr>
<tr><td><code id="gg.SpatialGridDataFrame_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code><a href="#topic+gg.SpatialPixelsDataFrame">gg.SpatialPixelsDataFrame()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>geom_tile</code> value.
</p>


<h3>See Also</h3>

<p>Other geomes for spatial data: 
<code><a href="#topic+gg">gg</a>()</code>,
<code><a href="#topic+gg.SpatRaster">gg.SpatRaster</a>()</code>,
<code><a href="#topic+gg.SpatialLines">gg.SpatialLines</a>()</code>,
<code><a href="#topic+gg.SpatialPixels">gg.SpatialPixels</a>()</code>,
<code><a href="#topic+gg.SpatialPixelsDataFrame">gg.SpatialPixelsDataFrame</a>()</code>,
<code><a href="#topic+gg.SpatialPoints">gg.SpatialPoints</a>()</code>,
<code><a href="#topic+gg.SpatialPolygons">gg.SpatialPolygons</a>()</code>,
<code><a href="#topic+gg.sf">gg.sf</a>()</code>,
<code><a href="#topic+gm">gm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  if (require(ggplot2, quietly = TRUE) &amp;&amp;
      bru_safe_sp() &amp;&amp;
      require("sp")) {
    # Load Gorilla data

    data("gorillas", package = "inlabru")

    # Plot Gorilla elevation covariate provided as SpatialPixelsDataFrame.
    # The same syntax applies to SpatialGridDataFrame objects.

    ggplot() +
      gg(gorillas$gcov$elevation)

    # Add Gorilla survey boundary and nest sightings

    ggplot() +
      gg(gorillas$gcov$elevation) +
      gg(gorillas$boundary) +
      gg(gorillas$nests)

    # Load pantropical dolphin data

    data("mexdolphin", package = "inlabru")

    # Plot the pantropical survey boundary, ship transects and dolphin sightings

    ggplot() +
      gg(mexdolphin$ppoly) + # survey boundary as SpatialPolygon
      gg(mexdolphin$samplers) + # ship transects as SpatialLines
      gg(mexdolphin$points) # dolphin sightings as SpatialPoints

    # Change color

    ggplot() +
      gg(mexdolphin$ppoly, color = "green") + # survey boundary as SpatialPolygon
      gg(mexdolphin$samplers, color = "red") + # ship transects as SpatialLines
      gg(mexdolphin$points, color = "blue") # dolphin sightings as SpatialPoints


    # Visualize data annotations: line width by segment number

    names(mexdolphin$samplers) # 'seg' holds the segment number
    ggplot() +
      gg(mexdolphin$samplers, aes(color = seg))

    # Visualize data annotations: point size by dolphin group size

    names(mexdolphin$points) # 'size' holds the group size
    ggplot() +
      gg(mexdolphin$points, aes(size = size))
  }

</code></pre>

<hr>
<h2 id='gg.SpatialLines'>Geom for SpatialLines objects</h2><span id='topic+gg.SpatialLines'></span>

<h3>Description</h3>

<p>Extracts start and end points of the lines and calls <code>geom_segment</code> to plot
lines between them. Requires the <code>ggplot2</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatialLines'
gg(data, mapping = NULL, crs = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gg.SpatialLines_+3A_data">data</code></td>
<td>
<p>A <code>SpatialLines</code> or <code>SpatialLinesDataFrame</code> object.</p>
</td></tr>
<tr><td><code id="gg.SpatialLines_+3A_mapping">mapping</code></td>
<td>
<p>Aesthetic mappings created by <code>ggplot2::aes</code> or <code>ggplot2::aes_</code>
used to update the default
mapping. The default mapping is
<code>ggplot2::aes(x = .data[[coordnames(data)[1]]], y = .data[[coordnames(data)[2]]], xend = .data[[paste0("end.", coordnames(data)[1])]], yend = .data[[paste0("end.", coordnames(data)[2])]])</code>.</p>
</td></tr>
<tr><td><code id="gg.SpatialLines_+3A_crs">crs</code></td>
<td>
<p>A <code>CRS</code> object defining the coordinate system to project the data
to before plotting.</p>
</td></tr>
<tr><td><code id="gg.SpatialLines_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code>ggplot2::geom_segment</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'geom_segment&ldquo; return value.
</p>


<h3>See Also</h3>

<p>Other geomes for spatial data: 
<code><a href="#topic+gg">gg</a>()</code>,
<code><a href="#topic+gg.SpatRaster">gg.SpatRaster</a>()</code>,
<code><a href="#topic+gg.SpatialGridDataFrame">gg.SpatialGridDataFrame</a>()</code>,
<code><a href="#topic+gg.SpatialPixels">gg.SpatialPixels</a>()</code>,
<code><a href="#topic+gg.SpatialPixelsDataFrame">gg.SpatialPixelsDataFrame</a>()</code>,
<code><a href="#topic+gg.SpatialPoints">gg.SpatialPoints</a>()</code>,
<code><a href="#topic+gg.SpatialPolygons">gg.SpatialPolygons</a>()</code>,
<code><a href="#topic+gg.sf">gg.sf</a>()</code>,
<code><a href="#topic+gm">gm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  if (require(ggplot2, quietly = TRUE) &amp;&amp;
      bru_safe_sp() &amp;&amp;
      require("sp")) {
    # Load Gorilla data

    data("gorillas", package = "inlabru")

    # Plot Gorilla elevation covariate provided as SpatialPixelsDataFrame.
    # The same syntax applies to SpatialGridDataFrame objects.

    ggplot() +
      gg(gorillas$gcov$elevation)

    # Add Gorilla survey boundary and nest sightings

    ggplot() +
      gg(gorillas$gcov$elevation) +
      gg(gorillas$boundary) +
      gg(gorillas$nests)

    # Load pantropical dolphin data

    data("mexdolphin", package = "inlabru")

    # Plot the pantropical survey boundary, ship transects and dolphin sightings

    ggplot() +
      gg(mexdolphin$ppoly) + # survey boundary as SpatialPolygon
      gg(mexdolphin$samplers) + # ship transects as SpatialLines
      gg(mexdolphin$points) # dolphin sightings as SpatialPoints

    # Change color

    ggplot() +
      gg(mexdolphin$ppoly, color = "green") + # survey boundary as SpatialPolygon
      gg(mexdolphin$samplers, color = "red") + # ship transects as SpatialLines
      gg(mexdolphin$points, color = "blue") # dolphin sightings as SpatialPoints


    # Visualize data annotations: line width by segment number

    names(mexdolphin$samplers) # 'seg' holds the segment number
    ggplot() +
      gg(mexdolphin$samplers, aes(color = seg))

    # Visualize data annotations: point size by dolphin group size

    names(mexdolphin$points) # 'size' holds the group size
    ggplot() +
      gg(mexdolphin$points, aes(size = size))
  }

</code></pre>

<hr>
<h2 id='gg.SpatialPixels'>Geom for SpatialPixels objects</h2><span id='topic+gg.SpatialPixels'></span>

<h3>Description</h3>

<p>Uses <code>geom_point</code> to plot the pixel centers.
Requires the <code>ggplot2</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatialPixels'
gg(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gg.SpatialPixels_+3A_data">data</code></td>
<td>
<p>A <a href="sp.html#topic+SpatialGrid">sp::SpatialPixels</a> object.</p>
</td></tr>
<tr><td><code id="gg.SpatialPixels_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code>geom_tile</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>geom_tile</code> return value.
</p>


<h3>See Also</h3>

<p>Other geomes for spatial data: 
<code><a href="#topic+gg">gg</a>()</code>,
<code><a href="#topic+gg.SpatRaster">gg.SpatRaster</a>()</code>,
<code><a href="#topic+gg.SpatialGridDataFrame">gg.SpatialGridDataFrame</a>()</code>,
<code><a href="#topic+gg.SpatialLines">gg.SpatialLines</a>()</code>,
<code><a href="#topic+gg.SpatialPixelsDataFrame">gg.SpatialPixelsDataFrame</a>()</code>,
<code><a href="#topic+gg.SpatialPoints">gg.SpatialPoints</a>()</code>,
<code><a href="#topic+gg.SpatialPolygons">gg.SpatialPolygons</a>()</code>,
<code><a href="#topic+gg.sf">gg.sf</a>()</code>,
<code><a href="#topic+gm">gm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("ggplot2", quietly = TRUE) &amp;&amp;
  bru_safe_sp()) {
  # Load Gorilla data

  data(gorillas, package = "inlabru")

  # Turn elevation covariate into SpatialPixels
  pxl &lt;- sp::SpatialPixels(sp::SpatialPoints(gorillas$gcov$elevation))

  # Plot the pixel centers
  ggplot() +
    gg(pxl, size = 0.1)
}
</code></pre>

<hr>
<h2 id='gg.SpatialPixelsDataFrame'>Geom for SpatialPixelsDataFrame objects</h2><span id='topic+gg.SpatialPixelsDataFrame'></span>

<h3>Description</h3>

<p>Coerces input SpatialPixelsDataFrame to data.frame and uses <code>geom_tile</code> to plot it.
Requires the <code>ggplot2</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatialPixelsDataFrame'
gg(data, mapping = NULL, crs = NULL, mask = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gg.SpatialPixelsDataFrame_+3A_data">data</code></td>
<td>
<p>A SpatialPixelsDataFrame object.</p>
</td></tr>
<tr><td><code id="gg.SpatialPixelsDataFrame_+3A_mapping">mapping</code></td>
<td>
<p>Aesthetic mappings created by <code>aes</code> used to update the default
mapping. The default mapping is <code>ggplot2::aes(x = .data[[coordnames(data)[1]]], y = .data[[coordnames(data)[2]]], fill = .data[[names(data)[[1]]]])</code>.</p>
</td></tr>
<tr><td><code id="gg.SpatialPixelsDataFrame_+3A_crs">crs</code></td>
<td>
<p>A <a href="sp.html#topic+CRS-class">sp::CRS</a> object defining the coordinate system to project the data to before plotting.</p>
</td></tr>
<tr><td><code id="gg.SpatialPixelsDataFrame_+3A_mask">mask</code></td>
<td>
<p>A SpatialPolygon defining the region that is plotted.</p>
</td></tr>
<tr><td><code id="gg.SpatialPixelsDataFrame_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code>geom_tile</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>geom_tile</code> return value.
</p>


<h3>See Also</h3>

<p>Other geomes for spatial data: 
<code><a href="#topic+gg">gg</a>()</code>,
<code><a href="#topic+gg.SpatRaster">gg.SpatRaster</a>()</code>,
<code><a href="#topic+gg.SpatialGridDataFrame">gg.SpatialGridDataFrame</a>()</code>,
<code><a href="#topic+gg.SpatialLines">gg.SpatialLines</a>()</code>,
<code><a href="#topic+gg.SpatialPixels">gg.SpatialPixels</a>()</code>,
<code><a href="#topic+gg.SpatialPoints">gg.SpatialPoints</a>()</code>,
<code><a href="#topic+gg.SpatialPolygons">gg.SpatialPolygons</a>()</code>,
<code><a href="#topic+gg.sf">gg.sf</a>()</code>,
<code><a href="#topic+gm">gm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  if (require(ggplot2, quietly = TRUE) &amp;&amp;
      bru_safe_sp() &amp;&amp;
      require("sp")) {
    # Load Gorilla data

    data("gorillas", package = "inlabru")

    # Plot Gorilla elevation covariate provided as SpatialPixelsDataFrame.
    # The same syntax applies to SpatialGridDataFrame objects.

    ggplot() +
      gg(gorillas$gcov$elevation)

    # Add Gorilla survey boundary and nest sightings

    ggplot() +
      gg(gorillas$gcov$elevation) +
      gg(gorillas$boundary) +
      gg(gorillas$nests)

    # Load pantropical dolphin data

    data("mexdolphin", package = "inlabru")

    # Plot the pantropical survey boundary, ship transects and dolphin sightings

    ggplot() +
      gg(mexdolphin$ppoly) + # survey boundary as SpatialPolygon
      gg(mexdolphin$samplers) + # ship transects as SpatialLines
      gg(mexdolphin$points) # dolphin sightings as SpatialPoints

    # Change color

    ggplot() +
      gg(mexdolphin$ppoly, color = "green") + # survey boundary as SpatialPolygon
      gg(mexdolphin$samplers, color = "red") + # ship transects as SpatialLines
      gg(mexdolphin$points, color = "blue") # dolphin sightings as SpatialPoints


    # Visualize data annotations: line width by segment number

    names(mexdolphin$samplers) # 'seg' holds the segment number
    ggplot() +
      gg(mexdolphin$samplers, aes(color = seg))

    # Visualize data annotations: point size by dolphin group size

    names(mexdolphin$points) # 'size' holds the group size
    ggplot() +
      gg(mexdolphin$points, aes(size = size))
  }

</code></pre>

<hr>
<h2 id='gg.SpatialPoints'>Geom for SpatialPoints objects</h2><span id='topic+gg.SpatialPoints'></span>

<h3>Description</h3>

<p>This function coerces the <code>SpatialPoints</code> into a <code>data.frame</code> and uses <code>geom_point</code>
to plot the points. Requires the <code>ggplot2</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatialPoints'
gg(data, mapping = NULL, crs = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gg.SpatialPoints_+3A_data">data</code></td>
<td>
<p>A SpatialPoints object.</p>
</td></tr>
<tr><td><code id="gg.SpatialPoints_+3A_mapping">mapping</code></td>
<td>
<p>Aesthetic mappings created by <code>aes</code> used to update the default
mapping. The default mapping is
<code>ggplot2::aes(x = .data[[coordnames(data)[1]]], y = .data[[coordnames(data)[2]]])</code>.</p>
</td></tr>
<tr><td><code id="gg.SpatialPoints_+3A_crs">crs</code></td>
<td>
<p>A <a href="sp.html#topic+CRS-class">sp::CRS</a> object defining the coordinate system to project the data to before plotting.</p>
</td></tr>
<tr><td><code id="gg.SpatialPoints_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code>geom_point</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>geom_point</code> return value
</p>


<h3>See Also</h3>

<p>Other geomes for spatial data: 
<code><a href="#topic+gg">gg</a>()</code>,
<code><a href="#topic+gg.SpatRaster">gg.SpatRaster</a>()</code>,
<code><a href="#topic+gg.SpatialGridDataFrame">gg.SpatialGridDataFrame</a>()</code>,
<code><a href="#topic+gg.SpatialLines">gg.SpatialLines</a>()</code>,
<code><a href="#topic+gg.SpatialPixels">gg.SpatialPixels</a>()</code>,
<code><a href="#topic+gg.SpatialPixelsDataFrame">gg.SpatialPixelsDataFrame</a>()</code>,
<code><a href="#topic+gg.SpatialPolygons">gg.SpatialPolygons</a>()</code>,
<code><a href="#topic+gg.sf">gg.sf</a>()</code>,
<code><a href="#topic+gm">gm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  if (require(ggplot2, quietly = TRUE) &amp;&amp;
      bru_safe_sp() &amp;&amp;
      require("sp")) {
    # Load Gorilla data

    data("gorillas", package = "inlabru")

    # Plot Gorilla elevation covariate provided as SpatialPixelsDataFrame.
    # The same syntax applies to SpatialGridDataFrame objects.

    ggplot() +
      gg(gorillas$gcov$elevation)

    # Add Gorilla survey boundary and nest sightings

    ggplot() +
      gg(gorillas$gcov$elevation) +
      gg(gorillas$boundary) +
      gg(gorillas$nests)

    # Load pantropical dolphin data

    data("mexdolphin", package = "inlabru")

    # Plot the pantropical survey boundary, ship transects and dolphin sightings

    ggplot() +
      gg(mexdolphin$ppoly) + # survey boundary as SpatialPolygon
      gg(mexdolphin$samplers) + # ship transects as SpatialLines
      gg(mexdolphin$points) # dolphin sightings as SpatialPoints

    # Change color

    ggplot() +
      gg(mexdolphin$ppoly, color = "green") + # survey boundary as SpatialPolygon
      gg(mexdolphin$samplers, color = "red") + # ship transects as SpatialLines
      gg(mexdolphin$points, color = "blue") # dolphin sightings as SpatialPoints


    # Visualize data annotations: line width by segment number

    names(mexdolphin$samplers) # 'seg' holds the segment number
    ggplot() +
      gg(mexdolphin$samplers, aes(color = seg))

    # Visualize data annotations: point size by dolphin group size

    names(mexdolphin$points) # 'size' holds the group size
    ggplot() +
      gg(mexdolphin$points, aes(size = size))
  }

</code></pre>

<hr>
<h2 id='gg.SpatialPolygons'>Geom for SpatialPolygons objects</h2><span id='topic+gg.SpatialPolygons'></span>

<h3>Description</h3>

<p>Uses the <code>ggplot2::fortify()</code> function to turn the <code>SpatialPolygons</code> objects into a
<code>data.frame</code>. Then
calls <code>geom_polygon</code> to plot the polygons. Requires the <code>ggplot2</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatialPolygons'
gg(data, mapping = NULL, crs = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gg.SpatialPolygons_+3A_data">data</code></td>
<td>
<p>A <code>SpatialPolygons</code> or <code>SpatialPolygonsDataFrame</code> object.</p>
</td></tr>
<tr><td><code id="gg.SpatialPolygons_+3A_mapping">mapping</code></td>
<td>
<p>Aesthetic mappings created by <code>aes</code> used to update the default
mapping.</p>
</td></tr>
<tr><td><code id="gg.SpatialPolygons_+3A_crs">crs</code></td>
<td>
<p>A <code>CRS</code> object defining the coordinate system to project the data to before plotting.</p>
</td></tr>
<tr><td><code id="gg.SpatialPolygons_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code>geom_sf</code>.
Unless specified by the user,
the argument <code>alpha = 0.2</code> (alpha level for polygon filling) is added.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Up to version <code style="white-space: pre;">&#8288;2.10.0&#8288;</code>, the <code>ggpolypath</code> package was used to ensure
proper plotting, since the <code>ggplot2::geom_polygon</code> function doesn't always
handle geometries with holes properly. After <code style="white-space: pre;">&#8288;2.10.0&#8288;</code>, the object is converted
to <code>sf</code> format and passed on to <code><a href="#topic+gg.sf">gg.sf()</a></code> instead, as <code>ggplot2</code> version <code style="white-space: pre;">&#8288;3.4.4&#8288;</code>
deprecated the intenrally used <code>ggplot2::fortify()</code> method for
<code>SpatialPolygons/DataFrame</code> objects.
</p>


<h3>Value</h3>

<p>A <code>geom_sf</code> object.
</p>


<h3>See Also</h3>

<p>Other geomes for spatial data: 
<code><a href="#topic+gg">gg</a>()</code>,
<code><a href="#topic+gg.SpatRaster">gg.SpatRaster</a>()</code>,
<code><a href="#topic+gg.SpatialGridDataFrame">gg.SpatialGridDataFrame</a>()</code>,
<code><a href="#topic+gg.SpatialLines">gg.SpatialLines</a>()</code>,
<code><a href="#topic+gg.SpatialPixels">gg.SpatialPixels</a>()</code>,
<code><a href="#topic+gg.SpatialPixelsDataFrame">gg.SpatialPixelsDataFrame</a>()</code>,
<code><a href="#topic+gg.SpatialPoints">gg.SpatialPoints</a>()</code>,
<code><a href="#topic+gg.sf">gg.sf</a>()</code>,
<code><a href="#topic+gm">gm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
  if (require(ggplot2, quietly = TRUE) &amp;&amp;
      bru_safe_sp() &amp;&amp;
      require("sp")) {
    # Load Gorilla data

    data("gorillas", package = "inlabru")

    # Plot Gorilla elevation covariate provided as SpatialPixelsDataFrame.
    # The same syntax applies to SpatialGridDataFrame objects.

    ggplot() +
      gg(gorillas$gcov$elevation)

    # Add Gorilla survey boundary and nest sightings

    ggplot() +
      gg(gorillas$gcov$elevation) +
      gg(gorillas$boundary) +
      gg(gorillas$nests)

    # Load pantropical dolphin data

    data("mexdolphin", package = "inlabru")

    # Plot the pantropical survey boundary, ship transects and dolphin sightings

    ggplot() +
      gg(mexdolphin$ppoly) + # survey boundary as SpatialPolygon
      gg(mexdolphin$samplers) + # ship transects as SpatialLines
      gg(mexdolphin$points) # dolphin sightings as SpatialPoints

    # Change color

    ggplot() +
      gg(mexdolphin$ppoly, color = "green") + # survey boundary as SpatialPolygon
      gg(mexdolphin$samplers, color = "red") + # ship transects as SpatialLines
      gg(mexdolphin$points, color = "blue") # dolphin sightings as SpatialPoints


    # Visualize data annotations: line width by segment number

    names(mexdolphin$samplers) # 'seg' holds the segment number
    ggplot() +
      gg(mexdolphin$samplers, aes(color = seg))

    # Visualize data annotations: point size by dolphin group size

    names(mexdolphin$points) # 'size' holds the group size
    ggplot() +
      gg(mexdolphin$points, aes(size = size))
  }

</code></pre>

<hr>
<h2 id='gg.SpatRaster'>Geom wrapper for SpatRaster objects</h2><span id='topic+gg.SpatRaster'></span>

<h3>Description</h3>

<p>Convenience wrapper function for <code>tidyterra::geom_spatraster()</code>.
Requires the <code>ggplot2</code> and <code>tidyterra</code> packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatRaster'
gg(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gg.SpatRaster_+3A_data">data</code></td>
<td>
<p>A SpatRaster object.</p>
</td></tr>
<tr><td><code id="gg.SpatRaster_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code>geom_spatraster</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output from 'geom_spatraster.
</p>


<h3>See Also</h3>

<p>Other geomes for spatial data: 
<code><a href="#topic+gg">gg</a>()</code>,
<code><a href="#topic+gg.SpatialGridDataFrame">gg.SpatialGridDataFrame</a>()</code>,
<code><a href="#topic+gg.SpatialLines">gg.SpatialLines</a>()</code>,
<code><a href="#topic+gg.SpatialPixels">gg.SpatialPixels</a>()</code>,
<code><a href="#topic+gg.SpatialPixelsDataFrame">gg.SpatialPixelsDataFrame</a>()</code>,
<code><a href="#topic+gg.SpatialPoints">gg.SpatialPoints</a>()</code>,
<code><a href="#topic+gg.SpatialPolygons">gg.SpatialPolygons</a>()</code>,
<code><a href="#topic+gg.sf">gg.sf</a>()</code>,
<code><a href="#topic+gm">gm</a>()</code>
</p>

<hr>
<h2 id='globe'>Visualize a globe using RGL</h2><span id='topic+globe'></span>

<h3>Description</h3>

<p>Creates a textured sphere and lon/lat coordinate annotations.
This function requires the <code>rgl</code> and <code>sphereplot</code> packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>globe(
  R = 1,
  R.grid = 1.05,
  specular = "black",
  axes = FALSE,
  box = FALSE,
  xlab = "",
  ylab = "",
  zlab = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="globe_+3A_r">R</code></td>
<td>
<p>Radius of the globe</p>
</td></tr>
<tr><td><code id="globe_+3A_r.grid">R.grid</code></td>
<td>
<p>Radius of the annotation sphere.</p>
</td></tr>
<tr><td><code id="globe_+3A_specular">specular</code></td>
<td>
<p>Light color of specular effect.</p>
</td></tr>
<tr><td><code id="globe_+3A_axes">axes</code></td>
<td>
<p>If TRUE, plot x, y and z axes.</p>
</td></tr>
<tr><td><code id="globe_+3A_box">box</code></td>
<td>
<p>If TRUE, plot a box around the globe.</p>
</td></tr>
<tr><td><code id="globe_+3A_xlab">xlab</code>, <code id="globe_+3A_ylab">ylab</code>, <code id="globe_+3A_zlab">zlab</code></td>
<td>
<p>Axes labels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value, used for plotting side effect.
</p>


<h3>See Also</h3>

<p>Other inlabru RGL tools: 
<code><a href="#topic+glplot">glplot</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (interactive() &amp;&amp;
    require("rgl", quietly = TRUE) &amp;&amp;
    require("sphereplot", quietly = TRUE) &amp;&amp;
    bru_safe_sp() &amp;&amp;
    require("sp")) {
  # Show the globe
  globe()

  # Load pantropoical dolphin data
  data("mexdolphin", package = "inlabru")

  # Add mesh, ship transects and dolphin sightings stored
  # as inla.mesh, SpatialLines and SpatialPoints objects, respectively

  glplot(mexdolphin$mesh, alpha = 0.2)
  glplot(mexdolphin$samplers, lwd = 5)
  glplot(mexdolphin$points, size = 10)
}

</code></pre>

<hr>
<h2 id='glplot'>Render objects using RGL</h2><span id='topic+glplot'></span><span id='topic+glplot.SpatialPoints'></span><span id='topic+glplot.SpatialLines'></span><span id='topic+glplot.fm_mesh_2d'></span><span id='topic+glplot.inla.mesh'></span>

<h3>Description</h3>

<p><code>glplot()</code> is a generic function for renders various kinds of spatial objects, i.e. <code style="white-space: pre;">&#8288;Spatial*&#8288;</code> data
and <code>fm_mesh_2d</code> objects. The function invokes particular methods which depend on the class of
the first argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glplot(object, ...)

## S3 method for class 'SpatialPoints'
glplot(object, add = TRUE, color = "red", ...)

## S3 method for class 'SpatialLines'
glplot(object, add = TRUE, ...)

## S3 method for class 'fm_mesh_2d'
glplot(object, add = TRUE, col = NULL, ...)

## S3 method for class 'inla.mesh'
glplot(object, add = TRUE, col = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glplot_+3A_object">object</code></td>
<td>
<p>an object used to select a method.</p>
</td></tr>
<tr><td><code id="glplot_+3A_...">...</code></td>
<td>
<p>Parameters passed on to plot_rgl.fm_mesh_2d()</p>
</td></tr>
<tr><td><code id="glplot_+3A_add">add</code></td>
<td>
<p>If TRUE, add the points to an existing plot. If FALSE, create new plot.</p>
</td></tr>
<tr><td><code id="glplot_+3A_color">color</code></td>
<td>
<p>vector of R color characters. See material3d() for details.</p>
</td></tr>
<tr><td><code id="glplot_+3A_col">col</code></td>
<td>
<p>Color specification. A single named color, a vector of scalar values, or a matrix of RGB values.</p>
</td></tr>
</table>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>glplot(SpatialPoints)</code>: This function will calculate the cartesian coordinates of the points provided
and use points3d() in order to render them.
</p>
</li>
<li> <p><code>glplot(SpatialLines)</code>: This function will calculate a cartesian representation of the lines provided
and use lines3d() in order to render them.
</p>
</li>
<li> <p><code>glplot(fm_mesh_2d)</code>: This function transforms the mesh to 3D cartesian coordinates and uses
inla.plot.mesh() with <code>rgl=TRUE</code> to plot the result.
</p>
</li></ul>


<h3>See Also</h3>

<p>Other inlabru RGL tools: 
<code><a href="#topic+globe">globe</a>()</code>
</p>
<p>Other inlabru RGL tools: 
<code><a href="#topic+globe">globe</a>()</code>
</p>
<p>Other inlabru RGL tools: 
<code><a href="#topic+globe">globe</a>()</code>
</p>
<p>Other inlabru RGL tools: 
<code><a href="#topic+globe">globe</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (interactive() &amp;&amp;
    require("rgl", quietly = TRUE) &amp;&amp;
    require("sphereplot", quietly = TRUE) &amp;&amp;
    bru_safe_sp() &amp;&amp;
    require("sp")) {
  # Show the globe
  globe()

  # Load pantropoical dolphin data
  data("mexdolphin", package = "inlabru")

  # Add mesh, ship transects and dolphin sightings stored
  # as inla.mesh, SpatialLines and SpatialPoints objects, respectively

  glplot(mexdolphin$mesh, alpha = 0.2)
  glplot(mexdolphin$samplers, lwd = 5)
  glplot(mexdolphin$points, size = 10)
}

</code></pre>

<hr>
<h2 id='gm'>ggplot geom for spatial data</h2><span id='topic+gm'></span>

<h3>Description</h3>

<p>gm is a wrapper for the <a href="#topic+gg">gg</a> method. It will take the first argument and transform its
coordinate system to latitude and longitude. Thereafter, <a href="#topic+gg">gg</a> is called using the transformed
data and the arguments provided via <code>...</code>. gm is intended to replace gg whenever the
data is supposed to be plotted over a spatial map generated by <a href="#topic+gmap">gmap</a>, which only works
if the coordinate system is latitude/longitude.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gm(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gm_+3A_data">data</code></td>
<td>
<p>an object for which to generate a geom.</p>
</td></tr>
<tr><td><code id="gm_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code><a href="#topic+gg">gg()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The form of the value returned by gm depends on the class of its argument. See the documentation of the particular methods for details of what is produced by that method.
</p>


<h3>See Also</h3>

<p>Other geomes for inla and inlabru predictions: 
<code><a href="#topic+gg">gg</a>()</code>,
<code><a href="#topic+gg.bru_prediction">gg.bru_prediction</a>()</code>,
<code><a href="#topic+gg.data.frame">gg.data.frame</a>()</code>,
<code><a href="#topic+gg.matrix">gg.matrix</a>()</code>
</p>
<p>Other geomes for spatial data: 
<code><a href="#topic+gg">gg</a>()</code>,
<code><a href="#topic+gg.SpatRaster">gg.SpatRaster</a>()</code>,
<code><a href="#topic+gg.SpatialGridDataFrame">gg.SpatialGridDataFrame</a>()</code>,
<code><a href="#topic+gg.SpatialLines">gg.SpatialLines</a>()</code>,
<code><a href="#topic+gg.SpatialPixels">gg.SpatialPixels</a>()</code>,
<code><a href="#topic+gg.SpatialPixelsDataFrame">gg.SpatialPixelsDataFrame</a>()</code>,
<code><a href="#topic+gg.SpatialPoints">gg.SpatialPoints</a>()</code>,
<code><a href="#topic+gg.SpatialPolygons">gg.SpatialPolygons</a>()</code>,
<code><a href="#topic+gg.sf">gg.sf</a>()</code>
</p>
<p>Other geomes for meshes: 
<code><a href="#topic+gg">gg</a>()</code>,
<code><a href="#topic+gg.fm_mesh_1d">gg.fm_mesh_1d</a>()</code>,
<code><a href="#topic+gg.fm_mesh_2d">gg.fm_mesh_2d</a>()</code>
</p>
<p>Other geomes for Raster data: 
<code><a href="#topic+gg">gg</a>()</code>,
<code><a href="#topic+gg.RasterLayer">gg.RasterLayer</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (require("ggplot2", quietly = TRUE)) {
  # Load the Gorilla data
  data(gorillas, package = "inlabru")

  # Create a base map centered around the nests and plot the boundary as well as the nests
  gmap(gorillas$nests, maptype = "satellite") +
    gm(gorillas$boundary) +
    gm(gorillas$nests, color = "white", size = 0.5)
}

## End(Not run)

</code></pre>

<hr>
<h2 id='gmap'>Plot a map using extent of a spatial object</h2><span id='topic+gmap'></span>

<h3>Description</h3>

<p>Uses <code>ggmap::get_map()</code> to query map services like Google Maps for a region centered around
the spatial object provided. Then calls <code>ggmap()</code> to plot the map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmap(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmap_+3A_data">data</code></td>
<td>
<p>A Spatial* object.</p>
</td></tr>
<tr><td><code id="gmap_+3A_...">...</code></td>
<td>
<p>Arguments passed on to get_map().</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires the <code>ggmap</code> package.
</p>


<h3>Value</h3>

<p>a ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (requireNamespace("ggmap", quietly = TRUE) &amp;&amp;
  require("ggplot2", quietly = TRUE)) {
  # Load the Gorilla data
  data(gorillas, package = "inlabru")

  # Create a base map centred around the nests and plot the boundary as well
  # as the nests
  gmap(gorillas$nests, maptype = "satellite") +
    gm(gorillas$boundary) +
    gm(gorillas$nests, color = "white", size = 0.5)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='gorillas'>Gorilla nesting sites</h2><span id='topic+gorillas'></span>

<h3>Description</h3>

<p>This is the <code>gorillas</code> dataset from the package <code>spatstat.data</code>, reformatted
as point process data for use with <code>inlabru</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gorillas
# To avoid the name clash with spatstat.data::gorillas, use
data(gorillas, package = "inlabru")
</code></pre>


<h3>Format</h3>

<p>The data are a list that contains these elements:
</p>

<dl>
<dt><code>nests</code>:</dt><dd><p> A <code>SpatialPointsDataFrame</code> object containing the locations of
the gorilla nests.</p>
</dd>
<dt><code>boundary</code>:</dt><dd><p> An <code>SpatialPolygonsDataFrame</code> object defining the boundary
of the region that was searched for the nests.</p>
</dd>
<dt><code>mesh</code>:</dt><dd><p> An <code>inla.mesh</code> object containing a mesh that can be used
with function <code>lgcp</code> to fit a LGCP to the nest data.</p>
</dd>
<dt><code>gcov</code>:</dt><dd><p> A list of SpatialGridDataFrame objects, one for each of these spatial covariates:
</p>

<dl>
<dt><code>aspect</code></dt><dd><p> Compass direction of the terrain slope. Categorical, with levels
N, NE, E, SE, S, SW, W and NW, which are coded as integers 1 to 8.</p>
</dd>
<dt><code>elevation</code></dt><dd><p> Digital elevation of terrain, in metres.</p>
</dd>
<dt><code>heat</code></dt><dd><p> Heat Load Index at each point on the surface (Beer's aspect),
discretised. Categorical with values Warmest (Beer's aspect between 0 and 0.999),
Moderate (Beer's aspect between 1 and 1.999), Coolest (Beer's aspect equals 2). These are
coded as integers 1, 2 and 3, in that order.</p>
</dd>
<dt><code>slopangle</code></dt><dd><p> Terrain slope, in degrees.</p>
</dd>
<dt><code>slopetype</code></dt><dd><p> Type of slope. Categorical, with values Valley, Toe (toe slope),
Flat, Midslope, Upper and Ridge. These are coded as integers 1 to 6.</p>
</dd>
<dt><code>vegetation</code></dt><dd><p> Vegetation type: a categorical variable with 6 levels coded as
integers 1 to 6 (in order of increasing expected habitat suitability)</p>
</dd>
<dt><code>waterdist</code></dt><dd><p> Euclidean distance from nearest water body, in metres.</p>
</dd>
</dl>

</dd>
<dt><code>plotsample</code></dt><dd><p>Plot sample of gorilla nests, sampling 9x9 over the region, with 60\
</p>

<dl>
<dt><code>counts</code></dt><dd><p> A SpatialPointsDataFrame frame with elements <code>x</code>, <code>y</code>, <code>count</code>,
<code>exposure</code>, being the x- and y-coordinates of the centre of each plot, the count in each
plot and the area of each plot.</p>
</dd>
<dt><code>plots</code></dt><dd><p> A <code>SpatialPolygonsDataFrame</code> defining the individual plot boundaries.</p>
</dd>
<dt><code>nests</code></dt><dd><p> A <code>SpatialPointsDataFrame</code> giving the locations of each detected nest.</p>
</dd>
</dl>

</dd>
</dl>



<h3>Source</h3>

<p>Library <code>spatstat.data</code>.
</p>


<h3>References</h3>

<p>Funwi-Gabga, N. (2008) A pastoralist survey and fire impact assessment in the Kagwene Gorilla
Sanctuary, Cameroon. M.Sc. thesis, Geology and Environmental Science, University of Buea,
Cameroon.
</p>
<p>Funwi-Gabga, N. and Mateu, J. (2012) Understanding the nesting spatial behaviour of gorillas
in the Kagwene Sanctuary, Cameroon. Stochastic Environmental Research and Risk Assessment
26 (6), 793-811.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (bru_safe_inla() &amp;&amp;
  bru_safe_sp() &amp;&amp;
  require("sp") &amp;&amp;
  require(ggplot2, quietly = TRUE)) {
  data(gorillas, package = "inlabru") # get the data

  # plot all the nests, mesh and boundary
  ggplot() +
    gg(gorillas$mesh) +
    gg(gorillas$boundary) +
    gg(gorillas$nests)

  # Plot the elevation covariate
  plot(gorillas$gcov$elevation)

  # Plot the plot sample
  ggplot() +
    gg(gorillas$plotsample$plots) +
    gg(gorillas$plotsample$nests)
}
</code></pre>

<hr>
<h2 id='gorillas_sf'>Gorilla nesting sites in sf format</h2><span id='topic+gorillas_sf'></span><span id='topic+gorillas_sf_gcov'></span>

<h3>Description</h3>

<p>This is the <code>gorillas</code> dataset from the package <code>spatstat.data</code>, reformatted
as point process data for use with <code>inlabru</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gorillas_sf
data(gorillas_sf, package = "inlabru")

gorillas_sf_gcov()
</code></pre>


<h3>Format</h3>

<p>The data are a list that contains these elements:
</p>

<dl>
<dt><code>nests</code>:</dt><dd><p> An <code>sf</code> object containing the locations of
the gorilla nests.</p>
</dd>
<dt><code>boundary</code>:</dt><dd><p> An <code>sf</code> object defining the boundary
of the region that was searched for the nests.</p>
</dd>
<dt><code>mesh</code>:</dt><dd><p> An <code>fm_mesh_2d</code> object containing a mesh that can be used
with function <code>lgcp</code> to fit a LGCP to the nest data.</p>
</dd>
<dt><code>gcov_file</code>:</dt><dd><p> The in-package filename of a <code>terra::SpatRaster</code> object,
with one layer for each of these spatial covariates:
</p>

<dl>
<dt><code>aspect</code></dt><dd><p> Compass direction of the terrain slope. Categorical, with levels
N, NE, E, SE, S, SW, W and NW, which are coded as integers 1 to 8.</p>
</dd>
<dt><code>elevation</code></dt><dd><p> Digital elevation of terrain, in metres.</p>
</dd>
<dt><code>heat</code></dt><dd><p> Heat Load Index at each point on the surface (Beer's aspect),
discretised. Categorical with values Warmest (Beer's aspect between 0 and 0.999),
Moderate (Beer's aspect between 1 and 1.999), Coolest (Beer's aspect equals 2). These are
coded as integers 1, 2 and 3, in that order.</p>
</dd>
<dt><code>slopangle</code></dt><dd><p> Terrain slope, in degrees.</p>
</dd>
<dt><code>slopetype</code></dt><dd><p> Type of slope. Categorical, with values Valley, Toe (toe slope),
Flat, Midslope, Upper and Ridge. These are coded as integers 1 to 6.</p>
</dd>
<dt><code>vegetation</code></dt><dd><p> Vegetation type: a categorical variable with 6 levels coded as
integers 1 to 6 (in order of increasing expected habitat suitability)</p>
</dd>
<dt><code>waterdist</code></dt><dd><p> Euclidean distance from nearest water body, in metres.</p>
</dd>
</dl>

<p>Loading of the covariates can be done with <code>gorillas_sf_gcov()</code> or
</p>
<div class="sourceCode"><pre>gorillas_sf$gcov &lt;- terra::rast(
  system.file(gorillas_sf$gcov_file, package = "inlabru")
)
</pre></div>
</dd>
<dt><code>plotsample</code></dt><dd><p>Plot sample of gorilla nests, sampling 9x9 over the region, with 60\
</p>

<dl>
<dt><code>counts</code></dt><dd><p> A SpatialPointsDataFrame frame with elements <code>x</code>, <code>y</code>, <code>count</code>,
<code>exposure</code>, being the x- and y-coordinates of the centre of each plot, the count in each
plot and the area of each plot.</p>
</dd>
<dt><code>plots</code></dt><dd><p> A <code>SpatialPolygonsDataFrame</code> defining the individual plot boundaries.</p>
</dd>
<dt><code>nests</code></dt><dd><p> A <code>SpatialPointsDataFrame</code> giving the locations of each detected nest.</p>
</dd>
</dl>

</dd>
</dl>



<h3>Functions</h3>


<ul>
<li> <p><code>gorillas_sf_gcov()</code>: Access the <code>gorillas_sf</code> covariates data as a
<code>terra::rast()</code> object.
</p>
</li></ul>


<h3>Source</h3>

<p>Library <code>spatstat.data</code>.
</p>


<h3>References</h3>

<p>Funwi-Gabga, N. (2008) A pastoralist survey and fire impact assessment in the Kagwene Gorilla
Sanctuary, Cameroon. M.Sc. thesis, Geology and Environmental Science, University of Buea,
Cameroon.
</p>
<p>Funwi-Gabga, N. and Mateu, J. (2012) Understanding the nesting spatial behaviour of gorillas
in the Kagwene Sanctuary, Cameroon. Stochastic Environmental Research and Risk Assessment
26 (6), 793-811.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive() &amp;&amp;
  bru_safe_inla() &amp;&amp;
  bru_safe_sp() &amp;&amp;
  require("sp") &amp;&amp;
  require(ggplot2, quietly = TRUE) &amp;&amp;
  requireNamespace("terra")) {
  # plot all the nests, mesh and boundary
  ggplot() +
    gg(gorillas_sf$mesh) +
    geom_sf(
      data = gorillas_sf$boundary,
      alpha = 0.1, fill = "blue"
    ) +
    geom_sf(data = gorillas_sf$nests)

  # Plot the elevation covariate
  gorillas_sf$gcov &lt;- terra::rast(
    system.file(gorillas_sf$gcov_file, package = "inlabru")
  )
  plot(gorillas_sf$gcov$elevation)

  # Plot the plot sample
  ggplot() +
    geom_sf(data = gorillas_sf$plotsample$plots) +
    geom_sf(data = gorillas_sf$plotsample$nests)
}
## Not run: 
gorillas_sf$gcov &lt;- gorillas_sf_gcov()

## End(Not run)
</code></pre>

<hr>
<h2 id='iinla'>Iterated INLA</h2><span id='topic+iinla'></span>

<h3>Description</h3>

<p>This is an internal wrapper for iterated runs of <code>INLA::inla</code>.
For nonlinear models, a linearisation is done with
<code>bru_compute_linearisation</code>, with a line search method between each
iteration. The <code>INLA::inla.stack</code> information is setup by <code><a href="#topic+bru_make_stack">bru_make_stack()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iinla(model, lhoods, initial = NULL, options)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iinla_+3A_model">model</code></td>
<td>
<p>A <a href="#topic+bru_model">bru_model</a> object</p>
</td></tr>
<tr><td><code id="iinla_+3A_lhoods">lhoods</code></td>
<td>
<p>A list of likelihood objects from <code><a href="#topic+like">like()</a></code></p>
</td></tr>
<tr><td><code id="iinla_+3A_initial">initial</code></td>
<td>
<p>A previous <code>bru</code> result or a list of named latent variable
initial states (missing elements are set to zero), to be used as starting
point, or <code>NULL</code>. If non-null, overrides <code>options$bru_initial</code></p>
</td></tr>
<tr><td><code id="iinla_+3A_options">options</code></td>
<td>
<p>A <code>bru_options</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>iinla</code> object that inherits from <code>INLA::inla</code>, with an
added field <code>bru_iinla</code> with elements
</p>

<dl>
<dt>log</dt><dd><p>The diagnostic log messages produced by the run</p>
</dd>
<dt>states</dt><dd><p>The list of linearisation points, one for each inla run</p>
</dd>
<dt>inla_stack</dt><dd><p>The <code>inla.stack</code> object from the final inla run</p>
</dd>
<dt>track</dt><dd><p>A list of convergence tracking vectors</p>
</dd>
</dl>

<p>If an inla run is aborted by an error, the returned object also contains
an element <code>error</code> with the error object.
</p>

<hr>
<h2 id='index_eval'>Obtain indices</h2><span id='topic+index_eval'></span><span id='topic+index_eval.component'></span><span id='topic+index_eval.component_list'></span>

<h3>Description</h3>

<p>Indexes into to the components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>index_eval(...)

## S3 method for class 'component'
index_eval(component, inla_f, ...)

## S3 method for class 'component_list'
index_eval(components, inla_f, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="index_eval_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
<tr><td><code id="index_eval_+3A_component">component</code></td>
<td>
<p>A component.</p>
</td></tr>
<tr><td><code id="index_eval_+3A_inla_f">inla_f</code></td>
<td>
<p>logical; when <code>TRUE</code>, must result in
values compatible with <code>INLA::f(...)</code>
an specification and corresponding <code>INLA::inla.stack(...)</code> constructions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of indices into the latent variables compatible with the
component mapper.
</p>


<h3>Author(s)</h3>

<p>Fabian E. Bachl <a href="mailto:bachlfab@gmail.com">bachlfab@gmail.com</a>,
Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>

<hr>
<h2 id='inla_subset_eval'>Obtain inla index subset information</h2><span id='topic+inla_subset_eval'></span><span id='topic+inla_subset_eval.component_list'></span>

<h3>Description</h3>

<p>Subsets for <code>INLA::f()</code> compatible indexing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inla_subset_eval(...)

## S3 method for class 'component_list'
inla_subset_eval(components, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inla_subset_eval_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
<tr><td><code id="inla_subset_eval_+3A_components">components</code></td>
<td>
<p>A component list.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>

<hr>
<h2 id='input_eval'>Obtain component inputs</h2><span id='topic+input_eval'></span><span id='topic+input_eval.component'></span><span id='topic+input_eval.component_list'></span><span id='topic+input_eval.bru_input'></span>

<h3>Description</h3>

<p>Obtain component inputs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>input_eval(...)

## S3 method for class 'component'
input_eval(component, data, ...)

## S3 method for class 'component_list'
input_eval(components, data, ...)

## S3 method for class 'bru_input'
input_eval(input, data, env = NULL, null.on.fail = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="input_eval_+3A_...">...</code></td>
<td>
<p>Unused.</p>
</td></tr>
<tr><td><code id="input_eval_+3A_component">component</code></td>
<td>
<p>A component.</p>
</td></tr>
<tr><td><code id="input_eval_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code>, <code>tibble</code>, <code>sf</code>, <code>list</code>, or <code style="white-space: pre;">&#8288;Spatial*&#8288;</code> object of
covariates and/or point locations.
If <code>NULL</code>, return the component's map.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An list of mapper input values, formatted for the full component mapper
(of type <code>bru_mapper_pipe</code>)
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>input_eval(bru_input)</code>: Attempts to evaluate a component input (e.g. <code>main</code>,
<code>group</code>, <code>replicate</code>, or <code>weight</code>), and process the results:
</p>

<ol>
<li><p> If <code>eval()</code> failed, return NULL or map everything to 1
(see the <code>null.on.fail</code> argument). This should normally not
happen, unless the component use logic is incorrect,
(e.g. via <code>include</code>/<code>exclude</code>)
leading to missing columns for a certain likelihood in a
multi-<code>like()</code> model.
</p>
</li>
<li><p> If we obtain a function, apply the function to the data object
</p>
</li>
<li><p> If we obtain an object supported by <code><a href="#topic+eval_spatial">eval_spatial()</a></code>, extract the values
of that data frame at the point locations
</p>
</li>
<li><p> Else we obtain a vector and return as-is. This happens when input
references a column of the data points, or some other complete expression
</p>
</li></ol>

</li></ul>


<h3>Simple covariates and the map parameter</h3>

<p>It is not unusual for a random effect act on a transformation of a covariate. In other frameworks this
would mean that the transformed covariate would have to be calculated in advance and added to the
data frame that is usually provided via the <code>data</code> parameter. inlabru provides the option to do
this transformation automatically. For instance, one might be interested in the effect of a covariate
<code class="reqn">x^2</code>. In inla and other frameworks this would require to add a column <code>xsquared</code> to the
input data frame and use the formula
</p>
<ul>
<li><p><code>formula = y ~ f(xsquared, model = "linear")</code>,</p>
</li></ul>

<p>In inlabru this can be achieved in several ways of using the <code>main</code> parameter
(<code>map</code> in version 2.1.13 and earlier), which does not need to be named.
</p>

<ul>
<li><p><code>components = y ~ psi(main = x^2, model = "linear")</code>
</p>
</li>
<li><p><code>components = y ~ psi(x^2, model = "linear")</code>
</p>
</li>
<li><p><code>components = y ~ psi(mySquareFun(x), model = "linear")</code>,
</p>
</li>
<li><p><code>components = y ~ psi(myOtherSquareFun, model = "linear")</code>,
</p>
</li></ul>

<p>In the first example inlabru will interpret the map parameter as an expression to be evaluated within
the data provided. Since <code class="reqn">x</code> is a known covariate it will know how to calculate it. The second
example is an expression as well but it uses a function called <code>mySquareFun</code>. This function is
defined by user but has to be accessible within the work space when setting up the components.
The third example provides the function <code>myOtherSquareFun</code>. In this case,
inlabru will call the function as <code>myOtherSquareFun(.data.)</code>, where <code>.data.</code>
is the data provided via the <code><a href="#topic+like">like()</a></code> <code>data</code> parameter.
The function needs to know what parts of the data to use to construct the
needed output. For example,
</p>
<div class="sourceCode"><pre>myOtherSquareFun &lt;- function(data) {
  data[ ,"x"]^2
}
</pre></div>


<h3>Spatial Covariates</h3>

<p>When fitting spatial models it is common to work with covariates that depend on space, e.g. sea
surface temperature or elevation. Although it is straightforward to add this data to the input
data frame or write a covariate function like in the previous section there is an even more
convenient way in inlabru. Spatial covariates are often stored as <code>SpatialPixelsDataFrame</code>,
<code>SpatialPixelsDataFrame</code> or <code>RasterLayer</code> objects. These can be provided directly via
the input expressions if they are supported by <code><a href="#topic+eval_spatial">eval_spatial()</a></code>, and
the <code><a href="#topic+like">like()</a></code> data is an <code>sf</code> or <code>SpatialPointsDataFrame</code> object.
<code>inlabru</code> will then automatically
evaluate and/or interpolate the covariate at your data locations when using code like
</p>
<div class="sourceCode"><pre>components = y ~ psi(mySpatialPixels, model = "linear")
</pre></div>
<p>For more precise control, use the the <code>layer</code> and <code>selector</code> arguments (see <code><a href="#topic+component">component()</a></code>),
or call <code>eval_spatial()</code> directly, e.g.:
</p>
<div class="sourceCode"><pre>components = y ~ psi(eval_spatial(mySpatialPixels, where = .data.), model = "linear")
</pre></div>


<h3>Coordinates</h3>

<p>A common spatial modelling component when using inla are SPDE models. An important feature of
inlabru is that it will automatically calculate the so called A-matrix (a component model matrix)
which maps SPDE
values at the mesh vertices to values at the data locations. For this purpose, the input
can be set to <code>coordinates</code>, which is the <code>sp</code> package function that extracts point
coordinates from the <code>SpatialPointsDataFrame</code> that was provided as input to <code><a href="#topic+like">like()</a></code>. The code for
this would look as follows:
</p>
<div class="sourceCode"><pre>components = y ~ field(coordinates, model = inla.spde2.matern(...))
</pre></div>
<p>Since <code>coordinates</code> is a function from the <code>sp</code> package, this results in
evaluation of <code>sp::coordinates(.data.)</code>, which loses any CRS information
from the data object.
</p>
<p>For <code>sf</code> data with a geometry column (by default named <code>geometry</code>), use
</p>
<div class="sourceCode"><pre>components = y ~ field(geometry, model = inla.spde2.matern(...))
</pre></div>
<p>Since the CRS information is part of the geometry column of the <code>sf</code> object,
this retains CRS information, so this is more robust, and allows the model
to be built on a different CRS than the observation data.
</p>


<h3>Author(s)</h3>

<p>Fabian E. Bachl <a href="mailto:bachlfab@gmail.com">bachlfab@gmail.com</a>, Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+component">component()</a></code>
</p>

<hr>
<h2 id='ipoints'>Deprecated functions in inlabru</h2><span id='topic+ipoints'></span><span id='topic+cprod'></span><span id='topic+inlabru-deprecated'></span><span id='topic+integration_weight_aggregation'></span><span id='topic+mesh_triangle_integration'></span><span id='topic+bru_mapper.default'></span><span id='topic+bru_mapper_offset'></span><span id='topic+is.inside'></span><span id='topic+vertices.inla.mesh'></span><span id='topic+pixels'></span>

<h3>Description</h3>

<p>These functions still attempt to do their job, but will be removed in a
future version.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ipoints(
  samplers = NULL,
  domain = NULL,
  name = NULL,
  group = NULL,
  int.args = NULL,
  project = deprecated()
)

cprod(..., na.rm = NULL, .blockwise = FALSE)

integration_weight_aggregation(mesh, integ)

mesh_triangle_integration(mesh, tri_subset = NULL, nsub = NULL)

## Default S3 method:
bru_mapper(...)

bru_mapper_offset(...)

is.inside(mesh, loc, mesh.coords = NULL)

vertices.inla.mesh(...)

pixels(mesh, nx = 150, ny = 150, mask = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ipoints_+3A_samplers">samplers</code></td>
<td>
<p>Description of the integration region boundary.
In 1D, a length 2 vector or two-column matrix where each row describes an interval,
or <code>NULL</code>
In 2D either a <code>SpatialPolygon</code> or a <code>SpatialLinesDataFrame</code> with a <code>weight</code> column
defining the width of the a transect line, and optionally further columns used by the
<code>group</code> argument, or <code>NULL</code>.  When <code>domain</code> is <code>NULL</code>, <code>samplers</code> may also
be an <code>inla.mesh.1d</code> or <code>inla.mesh</code> object, that is then treated as a <code>domain</code>
argument instead.</p>
</td></tr>
<tr><td><code id="ipoints_+3A_domain">domain</code></td>
<td>
<p>Either
</p>

<ul>
<li><p> when <code>samplers</code> is a 1D interval(s) definition only, <code>domain</code> can be
a single integer for the number of integration points to place in each 1D
interval, overriding <code>int.args[["nsub1"]]</code>, and otherwise
</p>
</li>
<li><p> when <code>samplers</code> is <code>NULL</code>, <code>domain</code> can be a numeric vector of points,
each given integration weight 1 (and no additional points are added
in between),
</p>
</li>
<li><p> an <code>inla.mesh.1d</code> object for continuous 1D integration, or
</p>
</li>
<li><p> an <code>inla.mesh.2d</code> object for continuous 2D integration.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ipoints_+3A_name">name</code></td>
<td>
<p>Character array stating the name of the domains dimension(s).
If <code>NULL</code>, the names are taken from coordinate names from <code>samplers</code> for
<code style="white-space: pre;">&#8288;Spatial*&#8288;</code> objects, otherwise &quot;x&quot;, &quot;y&quot;, &quot;z&quot; for 2D regions and
<code>"x"</code> for 1D regions</p>
</td></tr>
<tr><td><code id="ipoints_+3A_group">group</code></td>
<td>
<p>Column names of the <code>samplers</code> object (if applicable) for which
the integration points are calculated independently and not merged when
aggregating to mesh nodes.</p>
</td></tr>
<tr><td><code id="ipoints_+3A_int.args">int.args</code></td>
<td>
<p>List of arguments passed to <code>bru_int_polygon</code>.
</p>

<ul>
<li> <p><code>method</code>: &quot;stable&quot; (to aggregate integration weights onto mesh nodes)
or &quot;direct&quot; (to construct a within triangle/segment integration scheme
without aggregating onto mesh nodes)
</p>
</li>
<li> <p><code>nsub1</code>, <code>nsub2</code>: integers controlling the number of internal integration
points before aggregation. Points per triangle: <code>(nsub2+1)^2</code>.
Points per knot segment: <code>nsub1</code>
</p>
</li>
<li> <p><code>poly_method</code>: if set to &quot;legacy&quot;, selects an old polygon integration method
that doesn't handle holes. No longer supported, and will generate an error.
</p>
</li></ul>
</td></tr>
<tr><td><code id="ipoints_+3A_project">project</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Deprecated in favour of <code>int.args(method=...)</code>.
If TRUE, aggregate the integration points to mesh vertices. Default:
<code>project = (identical(int.args$method, "stable"))</code></p>
</td></tr>
<tr><td><code id="ipoints_+3A_...">...</code></td>
<td>
<p>Usually passed on to other methods</p>
</td></tr>
<tr><td><code id="ipoints_+3A_na.rm">na.rm</code></td>
<td>
<p>logical; if <code>TRUE</code>, the rows with weight <code>NA</code> from the
non-overlapping full_join will be removed; if <code>FALSE</code>, set the undefined weights to <code>NA</code>.
If <code>NULL</code> (default), act as <code>TRUE</code>, but warn if any elements needed removing.</p>
</td></tr>
<tr><td><code id="ipoints_+3A_.blockwise">.blockwise</code></td>
<td>
<p>logical; if <code>FALSE</code>, computes full tensor product integration.
If <code>TRUE</code>, computes within-block tensor product integration (used internally
by <code><a href="#topic+fm_int">fm_int()</a></code>).
Default <code>FALSE</code></p>
</td></tr>
<tr><td><code id="ipoints_+3A_mesh">mesh</code></td>
<td>
<p>An <code>inla.mesh</code> object</p>
</td></tr>
<tr><td><code id="ipoints_+3A_integ">integ</code></td>
<td>
<p><code>list</code> of <code>loc</code>, integration points,
and <code>weight</code>, integration weights,
or a <code>SpatialPointsDataFrame</code>. Only the coordinates and <code>weight</code> column
are handled.</p>
</td></tr>
<tr><td><code id="ipoints_+3A_tri_subset">tri_subset</code></td>
<td>
<p>Optional triangle index vector for integration on a subset
of the mesh triangles (Default <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="ipoints_+3A_nsub">nsub</code></td>
<td>
<p>number of subdivision points along each triangle edge, giving
<code>(nsub + 1)^2</code> proto-integration points used to compute
the vertex weights
(default <code>NULL=9</code>, giving 100 integration points for each triangle)</p>
</td></tr>
<tr><td><code id="ipoints_+3A_loc">loc</code></td>
<td>
<p>Points in space stored either as data.frame, a two-column matrix
of x and y coordinates or a SpatialPoints object.</p>
</td></tr>
<tr><td><code id="ipoints_+3A_mesh.coords">mesh.coords</code></td>
<td>
<p>Coordinate names of the mesh. Use only if loc is a
data.frame with respective column names.</p>
</td></tr>
<tr><td><code id="ipoints_+3A_nx">nx</code></td>
<td>
<p>Number of pixels in x direction</p>
</td></tr>
<tr><td><code id="ipoints_+3A_ny">ny</code></td>
<td>
<p>Number of pixels in y direction</p>
</td></tr>
<tr><td><code id="ipoints_+3A_mask">mask</code></td>
<td>
<p>If logical and TRUE, remove pixels that are outside the mesh.
If <code>mask</code> is a <code>Spatial</code> object, only return pixels covered by this object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ipoints()</code>: A <code>data.frame</code>, <code>tibble</code>, <code>sf</code>, or <code>SpatialPointsDataFrame</code> of 1D and
2D integration points, including a <code>weight</code> column and <code>.block</code> column.
</p>
<p>A <code>data.frame</code>, <code>sf</code>, or <code>SpatialPointsDataFrame</code> of multidimensional
integration points and their weights
</p>

<ul>
<li> <p><code>mesh_triangle_integration</code> returns a <code>list</code> with elements <code>loc</code>
and <code>weight</code> with integration points for the mesh
</p>
</li></ul>

<p><code>is.inside()</code>: Single column matrix of Boolean values indicating if a point is
inside the mesh.
</p>
<p><code>SpatialPixelsDataFrame</code> covering the mesh
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>ipoints()</code>: <a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> in favour of <code><a href="fmesher.html#topic+fm_int">fmesher::fm_int()</a></code>
</p>
</li>
<li> <p><code>cprod()</code>: (Blockwise) cross product of integration points.
</p>
<p>Calculates the groupwise cross product of integration points in different
dimensions and multiplies their weights accordingly.
If the object defining points in a particular dimension has no
weights attached to it all weights are assumed to be 1.
</p>
<p>Legacy wrapper for <code><a href="#topic+fm_cprod">fm_cprod()</a></code>
</p>
</li>
<li> <p><code>integration_weight_aggregation()</code>: Aggregate integration weights onto mesh nodes
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use <code><a href="fmesher.html#topic+fm_vertex_projection">fmesher::fm_vertex_projection()</a></code> instead.
</p>
</li>
<li> <p><code>mesh_triangle_integration()</code>: Integration scheme for mesh triangle interiors
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use <code><a href="fmesher.html#topic+fm_int_mesh_2d_core">fmesher::fm_int_mesh_2d_core()</a></code> instead.
</p>
</li>
<li> <p><code>bru_mapper(default)</code>: Calls <code>bru_mapper_define</code>, passing all
arguments along. Mapper implementations should call <code><a href="#topic+bru_mapper_define">bru_mapper_define()</a></code>
instead, and supply at least a <code>new_class</code> class name.
Use of the <code>bru_mapper.default</code> method was deprecated from version 2.7.0,
and removed in version 2.11.0
</p>
</li>
<li> <p><code>bru_mapper_offset()</code>: Creates a <code><a href="#topic+bru_mapper_const">bru_mapper_const()</a></code> mapper.
</p>
</li>
<li> <p><code>is.inside()</code>: Find out which points are inside a mesh.
<a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> in favour of <code><a href="#topic+fm_is_within">fm_is_within()</a></code>.
Replace <code>is.inside(mesh, loc)</code> with <code>fm_is_within(loc, mesh)</code>.
</p>
</li>
<li> <p><code>vertices.inla.mesh()</code>: Extract vertex locations from an <code>inla.mesh</code>.
Converts the vertices of an <code>inla.mesh</code> object into a <code>SpatialPointsDataFrame</code>.
Deprecated in favour of <code><a href="#topic+fm_vertices">fm_vertices()</a></code>
</p>
</li>
<li> <p><code>pixels()</code>: Generate <code>SpatialPixels</code> covering an <code>inla.mesh</code>.
<a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> in favour of <code><a href="fmesher.html#topic+fm_pixels">fmesher::fm_pixels()</a></code>
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fm_cprod">fm_cprod()</a></code>
</p>
<p><code><a href="#topic+fm_is_within">fm_is_within()</a></code>
</p>

<hr>
<h2 id='lgcp'>Log Gaussian Cox process (LGCP) inference using INLA</h2><span id='topic+lgcp'></span>

<h3>Description</h3>

<p>This function performs inference on a LGCP observed via points residing
possibly multiple dimensions. These dimensions are defined via the left hand
side of the formula provided via the model parameter. The left hand side
determines the intensity function that is assumed to drive the LGCP. This may
include effects that lead to a thinning (filtering) of the point process. By
default, the log intensity is assumed to be a linear combination of the
effects defined by the formula's RHS.
</p>
<p>More sophisticated models, e.g.
non-linear thinning, can be achieved by using the predictor argument. The
latter requires multiple runs of INLA for improving the required
approximation of the predictor. In many applications the LGCP is only
observed through subsets of the dimensions the process is living in. For
example, spatial point realizations may only be known in sub-areas of the
modelled space. These observed subsets of the LGCP domain are called samplers
and can be provided via the respective parameter. If samplers is NULL it is
assumed that all of the LGCP's dimensions have been observed completely.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lgcp(
  components,
  data,
  samplers = NULL,
  domain = NULL,
  ips = NULL,
  formula = . ~ .,
  ...,
  options = list(),
  .envir = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lgcp_+3A_components">components</code></td>
<td>
<p>A formula describing the latent components</p>
</td></tr>
<tr><td><code id="lgcp_+3A_data">data</code></td>
<td>
<p>A data frame or <code>SpatialPoints(DataFrame)</code> object</p>
</td></tr>
<tr><td><code id="lgcp_+3A_samplers">samplers</code></td>
<td>
<p>A data frame or <code style="white-space: pre;">&#8288;Spatial[Points/Lines/Polygons]DataFrame&#8288;</code>
objects</p>
</td></tr>
<tr><td><code id="lgcp_+3A_domain">domain</code></td>
<td>
<p>Named list of domain definitions</p>
</td></tr>
<tr><td><code id="lgcp_+3A_ips">ips</code></td>
<td>
<p>Integration points (overrides <code>samplers</code>)</p>
</td></tr>
<tr><td><code id="lgcp_+3A_formula">formula</code></td>
<td>
<p>If NULL, the linear combination implied by the <code>components</code> is
used as a predictor for the point location intensity. If a (possibly
non-linear) expression is provided the respective Taylor approximation is
used as a predictor. Multiple runs of INLA are then required for a better
approximation of the posterior.</p>
</td></tr>
<tr><td><code id="lgcp_+3A_...">...</code></td>
<td>
<p>Further arguments passed on to <code><a href="#topic+like">like()</a></code>. In particular,
optional <code>E</code>, a single numeric used rescale all integration weights by a fixed
factor.</p>
</td></tr>
<tr><td><code id="lgcp_+3A_options">options</code></td>
<td>
<p>See <code><a href="#topic+bru_options_set">bru_options_set()</a></code></p>
</td></tr>
<tr><td><code id="lgcp_+3A_.envir">.envir</code></td>
<td>
<p>The evaluation environment to use for special arguments
(<code>E</code>, <code>Ntrials</code>, <code>weights</code>, <code>scale</code>) if not found in response_data or data.
Defaults to the calling environment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="#topic+bru">bru()</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (bru_safe_inla() &amp;&amp;
  require(ggplot2, quietly = TRUE) &amp;&amp;
  require(fmesher, quietly = TRUE)) {
  # Load the Gorilla data
  data &lt;- gorillas_sf

  # Plot the Gorilla nests, the mesh and the survey boundary
  ggplot() +
    geom_fm(data = data$mesh) +
    gg(data$boundary, fill = "blue", alpha = 0.2) +
    gg(data$nests, col = "red", alpha = 0.2)

  # Define SPDE prior
  matern &lt;- INLA::inla.spde2.pcmatern(
    data$mesh,
    prior.sigma = c(0.1, 0.01),
    prior.range = c(0.1, 0.01)
  )

  # Define domain of the LGCP as well as the model components (spatial SPDE
  # effect and Intercept)
  cmp &lt;- geometry ~ field(geometry, model = matern) + Intercept(1)

  # Fit the model (with int.strategy="eb" to make the example take less time)
  fit &lt;- lgcp(cmp, data$nests,
    samplers = data$boundary,
    domain = list(geometry = data$mesh),
    options = list(control.inla = list(int.strategy = "eb"))
  )

  # Predict the spatial intensity surface
  lambda &lt;- predict(
    fit,
    fm_pixels(data$mesh, mask = data$boundary),
    ~ exp(field + Intercept)
  )

  # Plot the intensity
  ggplot() +
    gg(lambda, geom = "tile") +
    geom_fm(data = data$mesh, alpha = 0, linewidth = 0.05) +
    gg(data$nests, col = "red", alpha = 0.2)
}


</code></pre>

<hr>
<h2 id='like'>Observation model construction for usage with <code><a href="#topic+bru">bru()</a></code></h2><span id='topic+like'></span><span id='topic+like_list'></span><span id='topic+like_list.list'></span><span id='topic+like_list.bru_like'></span><span id='topic+c.bru_like'></span><span id='topic+c.bru_like_list'></span><span id='topic++5B.bru_like_list'></span>

<h3>Description</h3>

<p>Observation model construction for usage with <code><a href="#topic+bru">bru()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>like(
  formula = . ~ .,
  family = "gaussian",
  data = NULL,
  response_data = NULL,
  mesh = deprecated(),
  E = NULL,
  Ntrials = NULL,
  weights = NULL,
  scale = NULL,
  samplers = NULL,
  ips = NULL,
  domain = NULL,
  include = NULL,
  exclude = NULL,
  include_latent = NULL,
  used = NULL,
  allow_latent = deprecated(),
  allow_combine = NULL,
  control.family = NULL,
  options = list(),
  .envir = parent.frame()
)

like_list(...)

## S3 method for class 'list'
like_list(object, envir = NULL, ...)

## S3 method for class 'bru_like'
like_list(..., envir = NULL)

## S3 method for class 'bru_like'
c(..., envir = NULL)

## S3 method for class 'bru_like_list'
c(..., envir = NULL)

## S3 method for class 'bru_like_list'
x[i]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="like_+3A_formula">formula</code></td>
<td>
<p>a <code>formula</code> where the right hand side is a general R
expression defines the predictor used in the model.</p>
</td></tr>
<tr><td><code id="like_+3A_family">family</code></td>
<td>
<p>A string identifying a valid <code>INLA::inla</code> likelihood family.
The default is
<code>gaussian</code> with identity link. In addition to the likelihoods provided
by inla (see <code>names(INLA::inla.models()$likelihood)</code>)
inlabru supports fitting latent Gaussian Cox
processes via <code>family = "cp"</code>.
As an alternative to <code><a href="#topic+bru">bru()</a></code>, the <code><a href="#topic+lgcp">lgcp()</a></code> function provides
a convenient interface to fitting Cox processes.</p>
</td></tr>
<tr><td><code id="like_+3A_data">data</code></td>
<td>
<p>Likelihood-specific data, as a <code>data.frame</code> or
<code>SpatialPoints[DataFrame]</code>
object.</p>
</td></tr>
<tr><td><code id="like_+3A_response_data">response_data</code></td>
<td>
<p>Likelihood-specific data for models that need different
size/format for inputs and response variables, as a <code>data.frame</code> or
<code>SpatialPoints[DataFrame]</code>
object.</p>
</td></tr>
<tr><td><code id="like_+3A_mesh">mesh</code></td>
<td>
<p>Deprecated.</p>
</td></tr>
<tr><td><code id="like_+3A_e">E</code></td>
<td>
<p>Exposure parameter for family = 'poisson' passed on to
<code>INLA::inla</code>. Special case if family is 'cp': rescale all integration
weights by a scalar E. For sampler specific reweighting/effort, use a <code>weight</code>
column in the <code>samplers</code> object, see <code><a href="fmesher.html#topic+fm_int">fmesher::fm_int()</a></code>.
Default taken from <code>options$E</code>, normally <code>1</code>.</p>
</td></tr>
<tr><td><code id="like_+3A_ntrials">Ntrials</code></td>
<td>
<p>A vector containing the number of trials for the 'binomial'
likelihood. Default taken from <code>options$Ntrials</code>, normally <code>1</code>.</p>
</td></tr>
<tr><td><code id="like_+3A_weights">weights</code></td>
<td>
<p>Fixed (optional) weights parameters of the likelihood,
so the log-likelihood<code style="white-space: pre;">&#8288;[i]&#8288;</code> is changed into <code>weights[i] * log_likelihood[i]</code>.
Default value is <code>1</code>. WARNING: The normalizing constant for the likelihood
is NOT recomputed, so ALL marginals (and the marginal likelihood) must be
interpreted with great care.</p>
</td></tr>
<tr><td><code id="like_+3A_scale">scale</code></td>
<td>
<p>Fixed (optional) scale parameters of the precision for several
models, such as Gaussian and student-t response models.</p>
</td></tr>
<tr><td><code id="like_+3A_samplers">samplers</code></td>
<td>
<p>Integration domain for 'cp' family.</p>
</td></tr>
<tr><td><code id="like_+3A_ips">ips</code></td>
<td>
<p>Integration points for 'cp' family. Overrides <code>samplers</code>.</p>
</td></tr>
<tr><td><code id="like_+3A_domain">domain</code></td>
<td>
<p>Named list of domain definitions.</p>
</td></tr>
<tr><td><code id="like_+3A_include">include</code></td>
<td>
<p>Character vector of component labels that are used as effects
by the
predictor expression; Default: the result of <code style="white-space: pre;">&#8288;[all.vars()]&#8288;</code> on the
predictor expression, unless the expression is not &quot;.&quot;, in which case
<code>include=NULL</code>, to include all components that are not
explicitly excluded. The <code><a href="#topic+bru_used">bru_used()</a></code> methods are used
to extract the variable names, followed by removal of non-component names
when the components are available.</p>
</td></tr>
<tr><td><code id="like_+3A_exclude">exclude</code></td>
<td>
<p>Character vector of component labels that are not used by the
predictor expression. The exclusion list is applied to the list
as determined by the <code>include</code> parameter; Default: NULL (do not remove
any components from the inclusion list)</p>
</td></tr>
<tr><td><code id="like_+3A_include_latent">include_latent</code></td>
<td>
<p>character vector.
Specifies which the latent state variables are
directly available to the predictor expression, with a <code style="white-space: pre;">&#8288;_latent&#8288;</code> suffix.
This also makes evaluator functions with suffix <code style="white-space: pre;">&#8288;_eval&#8288;</code> available, taking
parameters <code>main</code>, <code>group</code>, and <code>replicate</code>, taking values for where to
evaluate the component effect that are different than those defined in the
component definition itself (see <code><a href="#topic+component_eval">component_eval()</a></code>). Default <code>NULL</code>
auto-detects use of <code style="white-space: pre;">&#8288;_latent&#8288;</code> and <code style="white-space: pre;">&#8288;_eval&#8288;</code> in the predictor expression.</p>
</td></tr>
<tr><td><code id="like_+3A_used">used</code></td>
<td>
<p>Either <code>NULL</code> or a <code><a href="#topic+bru_used">bru_used()</a></code> object, overriding <code>include</code>,
<code>exclude</code>, and <code>include_latent</code>.</p>
</td></tr>
<tr><td><code id="like_+3A_allow_latent">allow_latent</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> logical, deprecated.
Use <code>include_latent</code> instead.</p>
</td></tr>
<tr><td><code id="like_+3A_allow_combine">allow_combine</code></td>
<td>
<p>logical; If <code>TRUE</code>, the predictor expression may involve
several rows of the input data to influence the same row. Default <code>FALSE</code>,
but forced to <code>TRUE</code> if <code>response_data</code> is non-<code>NULL</code>, <code>data</code> is a <code>list</code>,
or the likelihood construction requires it.</p>
</td></tr>
<tr><td><code id="like_+3A_control.family">control.family</code></td>
<td>
<p>A optional <code>list</code> of <code>INLA::control.family</code> options</p>
</td></tr>
<tr><td><code id="like_+3A_options">options</code></td>
<td>
<p>A <a href="#topic+bru_options">bru_options</a> options object or a list of options passed
on to <code><a href="#topic+bru_options">bru_options()</a></code></p>
</td></tr>
<tr><td><code id="like_+3A_.envir">.envir</code></td>
<td>
<p>The evaluation environment to use for special arguments (<code>E</code>,
<code>Ntrials</code>, <code>weights</code>, and <code>scale</code>) if not found in <code>response_data</code> or <code>data</code>.
Defaults to the calling environment.</p>
</td></tr>
<tr><td><code id="like_+3A_...">...</code></td>
<td>
<p>For <code>like_list.bru_like</code>, one or more <code>bru_like</code> objects</p>
</td></tr>
<tr><td><code id="like_+3A_object">object</code></td>
<td>
<p>A list of <code>bru_like</code> objects</p>
</td></tr>
<tr><td><code id="like_+3A_envir">envir</code></td>
<td>
<p>An optional environment for the new <code>bru_like_list</code> object</p>
</td></tr>
<tr><td><code id="like_+3A_x">x</code></td>
<td>
<p><code>bru_like_list</code> object from which to extract element(s)</p>
</td></tr>
<tr><td><code id="like_+3A_i">i</code></td>
<td>
<p>indices specifying elements to extract</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A likelihood configuration which can be used to parameterise <code><a href="#topic+bru">bru()</a></code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>like_list()</code>: Combine <code>bru_like</code> likelihoods into a <code>bru_like_list</code> object
</p>
</li>
<li> <p><code>like_list(list)</code>: Combine a list of <code>bru_like</code> likelihoods
into a <code>bru_like_list</code> object
</p>
</li>
<li> <p><code>like_list(bru_like)</code>: Combine several <code>bru_like</code> likelihoods
into a <code>bru_like_list</code> object
</p>
</li>
<li> <p><code>c(bru_like)</code>: Combine several <code>bru_like</code> likelihoods and/or <code>bru_like_list</code>
objects into a <code>bru_like_list</code> object
</p>
</li>
<li> <p><code>c(bru_like_list)</code>: Combine several <code>bru_like</code> likelihoods and/or <code>bru_like_list</code>
objects into a <code>bru_like_list</code> object
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Fabian E. Bachl <a href="mailto:bachlfab@gmail.com">bachlfab@gmail.com</a>
</p>
<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (bru_safe_inla() &amp;&amp;
    require(ggplot2, quietly = TRUE)) {

  # The like function's main purpose is to set up models with multiple likelihoods.
  # The following example generates some random covariates which are observed through
  # two different random effect models with different likelihoods

  # Generate the data

  set.seed(123)

  n1 &lt;- 200
  n2 &lt;- 10

  x1 &lt;- runif(n1)
  x2 &lt;- runif(n2)
  z2 &lt;- runif(n2)

  y1 &lt;- rnorm(n1, mean = 2 * x1 + 3)
  y2 &lt;- rpois(n2, lambda = exp(2 * x2 + z2 + 3))

  df1 &lt;- data.frame(y = y1, x = x1)
  df2 &lt;- data.frame(y = y2, x = x2, z = z2)

  # Single likelihood models and inference using bru are done via

  cmp1 &lt;- y ~ -1 + Intercept(1) + x
  fit1 &lt;- bru(cmp1, family = "gaussian", data = df1)
  summary(fit1)

  cmp2 &lt;- y ~ -1 + Intercept(1) + x + z
  fit2 &lt;- bru(cmp2, family = "poisson", data = df2)
  summary(fit2)

  # A joint model has two likelihoods, which are set up using the like function

  lik1 &lt;- like("gaussian", formula = y ~ x + Intercept, data = df1)
  lik2 &lt;- like("poisson", formula = y ~ x + z + Intercept, data = df2)

  # The union of effects of both models gives the components needed to run bru

  jcmp &lt;- ~ x + z + Intercept(1)
  jfit &lt;- bru(jcmp, lik1, lik2)

  # Compare the estimates

  p1 &lt;- ggplot() +
    gg(fit1$summary.fixed, bar = TRUE) +
    ylim(0, 4) +
    ggtitle("Model 1")
  p2 &lt;- ggplot() +
    gg(fit2$summary.fixed, bar = TRUE) +
    ylim(0, 4) +
    ggtitle("Model 2")
  pj &lt;- ggplot() +
    gg(jfit$summary.fixed, bar = TRUE) +
    ylim(0, 4) +
    ggtitle("Joint model")

  multiplot(p1, p2, pj)
}

</code></pre>

<hr>
<h2 id='local_testthat'>Unit test helpers</h2><span id='topic+local_testthat'></span><span id='topic+local_bru_testthat_assign'></span><span id='topic+local_bru_testthat_tolerances'></span><span id='topic+local_bru_options_set'></span><span id='topic+local_basic_intercept_testdata'></span><span id='topic+local_basic_fixed_effect_testdata'></span><span id='topic+local_mrsea_convert'></span><span id='topic+local_bru_safe_inla'></span><span id='topic+local_bru_testthat_setup'></span>

<h3>Description</h3>

<p>Local helper functions for package unit tests
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_bru_testthat_assign(x, values, envir = parent.frame())

local_bru_testthat_tolerances(
  tolerances = c(0.0001, 0.01, 0.1),
  envir = parent.frame()
)

local_bru_options_set(..., .reset = FALSE, envir = parent.frame())

local_basic_intercept_testdata()

local_basic_fixed_effect_testdata()

local_mrsea_convert(x, use_km = FALSE)

local_bru_safe_inla(multicore = FALSE, quietly = TRUE, envir = parent.frame())

local_bru_testthat_setup(envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local_testthat_+3A_x">x</code></td>
<td>
<p>character; Name of variable to assign to</p>
</td></tr>
<tr><td><code id="local_testthat_+3A_values">values</code></td>
<td>
<p>the object to assign to <code>x</code></p>
</td></tr>
<tr><td><code id="local_testthat_+3A_envir">envir</code></td>
<td>
<p>environment for exit handlers</p>
</td></tr>
<tr><td><code id="local_testthat_+3A_tolerances">tolerances</code></td>
<td>
<p>numeric vector of length 3; <code style="white-space: pre;">&#8288;[lowtol, midtol, hitol]&#8288;</code></p>
</td></tr>
<tr><td><code id="local_testthat_+3A_.reset">.reset</code></td>
<td>
<p>For <code>local_bru_options_set</code>, logical indicating if the global
override options list should be emptied before setting the new option(s).</p>
</td></tr>
<tr><td><code id="local_testthat_+3A_multicore">multicore</code></td>
<td>
<p>logical; if <code>TRUE</code>, multiple cores are allowed, and the
INLA <code>num.threads</code> option is not checked or altered. Default: <code>FALSE</code>, multicore
not allowed (used for examples and unit tests).</p>
</td></tr>
<tr><td><code id="local_testthat_+3A_quietly">quietly</code></td>
<td>
<p>logical; if <code>TRUE</code>, prints diagnostic messages. A message is
always printed if the INLA <code>num.threads</code> option is altered, regardless of the
<code>quietly</code> argument. Default: TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>local_bru_options_set()</code> is used to set global package options.
</p>


<h3>Value</h3>

<p><code>local_bru_options_set()</code> returns a copy of the global override
options (not including the defaults), invisibly.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>local_bru_testthat_assign()</code>: Assign local variable. Useful for easy cleanup
of global workspace with <code>withr::deferred_run()</code> when running tests
interactively.
</p>
</li>
<li> <p><code>local_bru_testthat_tolerances()</code>: Assign test tolerances
Assign local tolerance variables. Useful for easy cleanup
of global workspace with <code>withr::deferred_run()</code> when running tests
interactively.
</p>
</li>
<li> <p><code>local_bru_options_set()</code>: Calls <code><a href="#topic+bru_options_set">bru_options_set()</a></code> in a reversible way
</p>
</li>
<li> <p><code>local_bru_safe_inla()</code>: Tests should set num.threads = &quot;1:1&quot; to ensure
within-system repeatability by calling <code>local_bru_safe_inla()</code>;
see also <code><a href="#topic+bru_safe_inla">bru_safe_inla()</a></code>
</p>
</li>
<li> <p><code>local_bru_testthat_setup()</code>: Initialise environment for tests.
Assigns tolerance variables.
To be called either at the top of a testfile, or inside tests.
Does <em>not</em> call <code><a href="#topic+local_bru_safe_inla">local_bru_safe_inla()</a></code>, since that may invoke a skip and
should be called inside each test that relies on INLA.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+bru_options_set">bru_options_set()</a></code>, <code><a href="#topic+bru_options_default">bru_options_default()</a></code>, <code><a href="#topic+bru_options_get">bru_options_get()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my_fun &lt;- function(val) {
  local_bru_options_set(bru_verbose = val)
  bru_options_get("bru_verbose")
}
# Inside the function, the bru_verbose option is changed.
# Outside the function, the bru_verbose option is unchanged.
print(my_fun(TRUE))
print(bru_options_get("bru_verbose"))
print(my_fun(FALSE))
print(bru_options_get("bru_verbose"))
</code></pre>

<hr>
<h2 id='make_hierarchical_mesh_basis'>Make hierarchical mesh basis functions</h2><span id='topic+make_hierarchical_mesh_basis'></span><span id='topic+inla.spde2.pcmatern_B'></span>

<h3>Description</h3>

<p>Make hierarchical mesh basis functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_hierarchical_mesh_basis(mesh, forward = TRUE)

inla.spde2.pcmatern_B(mesh, ..., B)
</code></pre>


<h3>Functions</h3>


<ul>
<li> <p><code>inla.spde2.pcmatern_B()</code>: Construct a pcmatern model with basis change
<a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
</li></ul>

<hr>
<h2 id='materncov.bands'>Matern correlation or covariance function approximate credible bands.</h2><span id='topic+materncov.bands'></span>

<h3>Description</h3>

<p>Evaluate the covariance function for an inla.spde
objectPlots the posterior distribution of the range,
log(range), variance, or log(variance) parameter of a model's
SPDE component. Can also plot Matern correlation or covariance
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>materncov.bands(
  manifold,
  dist,
  log.range,
  log.variance = NULL,
  alpha = 2,
  quantile = 0.95,
  n = 64,
  S1.L = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="materncov.bands_+3A_manifold">manifold</code></td>
<td>
<p>Either &quot;R1&quot;, &quot;S1&quot;, &quot;R2&quot;, or &quot;S2&quot;, from
<code>mesh$manifold</code>, or a full <code>inla.mesh</code> or
<code>inla.mesh.1d</code> object.</p>
</td></tr>
<tr><td><code id="materncov.bands_+3A_dist">dist</code></td>
<td>
<p>A vector of distances at which to calculate the
covariances/correlations</p>
</td></tr>
<tr><td><code id="materncov.bands_+3A_log.range">log.range</code></td>
<td>
<p>A scalar or a list (mean, sd), such as produced by
<code>inla.spde.result(...)$summary.log.range.nominal[[1]][c("mean","sd")]</code></p>
</td></tr>
<tr><td><code id="materncov.bands_+3A_log.variance">log.variance</code></td>
<td>
<p>Either <code>NULL</code>, a scalar, or vector of the
same type as for log.range. When <code>NULL</code>, the correlations
are calculated instead of the covariances.</p>
</td></tr>
<tr><td><code id="materncov.bands_+3A_alpha">alpha</code></td>
<td>
<p>The SPDE operator order. Default 2.</p>
</td></tr>
<tr><td><code id="materncov.bands_+3A_quantile">quantile</code></td>
<td>
<p>The target credible probability. Default 0.95.</p>
</td></tr>
<tr><td><code id="materncov.bands_+3A_n">n</code></td>
<td>
<p>The number of parameter combinations to use for the
approximation. Default 64.</p>
</td></tr>
<tr><td><code id="materncov.bands_+3A_s1.l">S1.L</code></td>
<td>
<p>For <code>manifold</code> <code>"S1"</code>, give the length of the
cyclic interval</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses a Gaussian assumption for the internal model parameters, and finds a region in parameter
space with approximately <code>quantile</code> probability.
</p>


<h3>Value</h3>

<p>A list with estimated covariance or correlation (when <code>log.variance</code> is
<code>NULL</code>) functions:
</p>
<table>
<tr><td><code>lower</code></td>
<td>
<p>An approximate lower bound for the <code>quantile</code> credible region</p>
</td></tr>
<tr><td><code>median</code></td>
<td>
<p>The function for for the approximate median parameters quantile</p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p>An approximate upper bound for the <code>quantile</code> credible region</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:Finn.Lindgren@ed.ac.uk">Finn.Lindgren@ed.ac.uk</a>
</p>

<hr>
<h2 id='mexdolphin'>Pan-tropical spotted dolphins in the Gulf of Mexico</h2><span id='topic+mexdolphin'></span>

<h3>Description</h3>

<p>This a version of the <code>mexdolphins</code> dataset from the package <code>dsm</code>, reformatted
as point process data for use with <code>inlabru</code>. The data are from a combination of several NOAA
shipboard surveys conducted on pan-tropical spotted dolphins in the Gulf of Mexico. 47 observations
of groups of dolphins were detected. The group size was recorded, as well as the Beaufort sea state at
the time of the observation. Transect width is 16 km, i.e. maximal detection
distance 8 km (transect half-width 8 km).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mexdolphin
</code></pre>


<h3>Format</h3>

<p>A list of objects:
</p>

<dl>
<dt><code>points</code>:</dt><dd><p> A <code>SpatialPointsDataFrame</code> object containing the locations of
detected dolphin groups, with their size as an attribute.</p>
</dd>
<dt><code>samplers</code>:</dt><dd><p> A <code>SpatialLinesDataFrame</code> object containing the transect lines
that were surveyed.</p>
</dd>
<dt><code>mesh</code>:</dt><dd><p> An <code>inla.mesh</code> object containing a Delaunay triangulation
mesh (a type of discretization of continuous space) covering the survey region.</p>
</dd>
<dt><code>ppoly</code>:</dt><dd><p> An <code>SpatialPolygonsDataFrame</code> object defining the boundary of the
survey region.</p>
</dd>
<dt><code>simulated</code>:</dt><dd><p> A <code>SpatialPointsDataFrame</code> object containing the locations of a
<em>simulated</em> population of dolphin groups. The population was simulated from a <code>inlabru</code>
model fitted to the actual survey data. Note that the simulated data do not have any associated
size information.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Library <code>dsm</code>.
</p>


<h3>References</h3>

<p>Halpin, P.N., A.J. Read, E. Fujioka, B.D. Best, B. Donnelly, L.J. Hazen, C. Kot, K. Urian,
E. LaBrecque, A. Dimatteo, J. Cleary, C. Good, L.B. Crowder, and K.D. Hyrenbach. 2009.
OBIS-SEAMAP: The world data center for marine mammal, sea bird, and sea turtle distributions.
Oceanography 22(2):104-115
</p>
<p>NOAA Southeast Fisheries Science Center. 1996. Report of a Cetacean Survey of Oceanic and
Selected Continental Shelf Waters of the Northern Gulf of Mexico aboard NOAA Ship Oregon II
(Cruise 220)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (require("ggplot2", quietly = TRUE)) {
  data(mexdolphin, package = "inlabru")
  ggplot() +
    gg(mexdolphin$mesh) +
    gg(mexdolphin$ppoly, color = "blue") +
    gg(mexdolphin$samplers) +
    gg(mexdolphin$points, aes(size = size), color = "red") +
    coord_equal()

  ggplot() +
    gg(mexdolphin$mesh, col = mexdolphin$lambda, mask = mexdolphin$ppoly) +
    coord_equal()
}

## Not run: 
if (requireNamespace("ggmap", quietly = TRUE) &amp;&amp;
  require("ggplot2", quietly = TRUE)) {
  gmap(mexdolphin$depth) +
    gm(mexdolphin$ppoly, color = "blue") +
    gm(mexdolphin$samplers) +
    gm(mexdolphin$points, aes(size = size), color = "red")

  gmap(mexdolphin$depth) +
    gm(mexdolphin$depth, aes(col = depth)) +
    gm(mexdolphin$ppoly)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='mexdolphin_sf'>Pan-tropical spotted dolphins in the Gulf of Mexico</h2><span id='topic+mexdolphin_sf'></span>

<h3>Description</h3>

<p>This a version of the <code>mexdolphins</code> dataset from the package <code>dsm</code>, reformatted
as point process data for use with <code>inlabru</code>, with the parts stored in <code>sf</code> format.
The data are from a combination of several NOAA
shipboard surveys conducted on pan-tropical spotted dolphins in the Gulf of Mexico. 47 observations
of groups of dolphins were detected. The group size was recorded, as well as the Beaufort sea state at
the time of the observation. Transect width is 16 km, i.e. maximal detection
distance 8 km (transect half-width 8 km).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mexdolphin_sf
</code></pre>


<h3>Format</h3>

<p>A list of objects:
</p>

<dl>
<dt><code>points</code>:</dt><dd><p> An <code>sf</code> object containing the locations of
detected dolphin groups, with their size as an attribute.</p>
</dd>
<dt><code>samplers</code>:</dt><dd><p> An <code>sf</code> object containing the transect lines
that were surveyed.</p>
</dd>
<dt><code>mesh</code>:</dt><dd><p> An <code>fm_mesh_2d</code> object containing a Delaunay triangulation
mesh (a type of discretization of continuous space) covering the survey region.</p>
</dd>
<dt><code>ppoly</code>:</dt><dd><p> An <code>sf</code> object defining the boundary of the
survey region.</p>
</dd>
<dt><code>simulated</code>:</dt><dd><p> A <code>sf</code> object containing the locations of a
<em>simulated</em> population of dolphin groups. The population was simulated from a <code>inlabru</code>
model fitted to the actual survey data. Note that the simulated data do not have any associated
size information.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Library <code>dsm</code>.
</p>


<h3>References</h3>

<p>Halpin, P.N., A.J. Read, E. Fujioka, B.D. Best, B. Donnelly, L.J. Hazen, C. Kot, K. Urian,
E. LaBrecque, A. Dimatteo, J. Cleary, C. Good, L.B. Crowder, and K.D. Hyrenbach. 2009.
OBIS-SEAMAP: The world data center for marine mammal, sea bird, and sea turtle distributions.
Oceanography 22(2):104-115
</p>
<p>NOAA Southeast Fisheries Science Center. 1996. Report of a Cetacean Survey of Oceanic and
Selected Continental Shelf Waters of the Northern Gulf of Mexico aboard NOAA Ship Oregon II
(Cruise 220)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (require("ggplot2", quietly = TRUE)) {
  data(mexdolphin_sf, package = "inlabru")
  ggplot() +
    gg(mexdolphin_sf$mesh) +
    gg(mexdolphin_sf$ppoly, color = "blue", alpha = 0, linewidth = 1) +
    gg(mexdolphin_sf$samplers) +
    gg(mexdolphin_sf$points, aes(size = size), color = "red") +
    scale_size_area()

  ggplot() +
    gg(mexdolphin_sf$mesh, color = mexdolphin_sf$lambda, mask = mexdolphin_sf$ppoly)
}

</code></pre>

<hr>
<h2 id='mrsea'>Marine renewables strategic environmental assessment</h2><span id='topic+mrsea'></span>

<h3>Description</h3>

<p>Data imported from package MRSea, see <a href="https://www.creem.st-andrews.ac.uk/software/">https://www.creem.st-andrews.ac.uk/software/</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mrsea
</code></pre>


<h3>Format</h3>

<p>A list of objects:
</p>

<dl>
<dt><code>points</code>:</dt><dd><p> A <code>SpatialPointsDataFrame</code> object containing the locations of
XXXXX.</p>
</dd>
<dt><code>samplers</code>:</dt><dd><p> A <code>SpatialLinesDataFrame</code> object containing the transect lines
that were surveyed.</p>
</dd>
<dt><code>mesh</code>:</dt><dd><p> An <code>fm_mesh_2d</code> object containing a Delaunay triangulation
mesh (a type of discretization of continuous space) covering the survey region.</p>
</dd>
<dt><code>boundary</code>:</dt><dd><p> An <code>SpatialPolygonsDataFrame</code> object defining the boundary of the
survey region.</p>
</dd>
<dt><code>covar</code>:</dt><dd><p> An <code>SpatialPointsDataFrame</code> containing sea depth estimates.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Library <code>MRSea</code>.
</p>


<h3>References</h3>

<p>NONE YET
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (bru_safe_inla() &amp;&amp;
  require(ggplot2, quietly = TRUE)) {
  ggplot() +
    gg(mrsea$mesh) +
    gg(mrsea$samplers) +
    gg(mrsea$points) +
    gg(mrsea$boundary)
}
</code></pre>

<hr>
<h2 id='multiplot'>Multiple ggplots on a page.</h2><span id='topic+multiplot'></span>

<h3>Description</h3>

<p>Renders multiple ggplots on a single page.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiplot(..., plotlist = NULL, cols = 1, layout = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiplot_+3A_...">...</code></td>
<td>
<p>Comma-separated <code>ggplot</code> objects.</p>
</td></tr>
<tr><td><code id="multiplot_+3A_plotlist">plotlist</code></td>
<td>
<p>A list of <code>ggplot</code> objects - an alternative to the comma-separated argument above.</p>
</td></tr>
<tr><td><code id="multiplot_+3A_cols">cols</code></td>
<td>
<p>Number of columns of plots on the page.</p>
</td></tr>
<tr><td><code id="multiplot_+3A_layout">layout</code></td>
<td>
<p>A matrix specifying the layout. If present, 'cols' is ignored. If the layout is
something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE), then plot 1 will go in the upper left,
2 will go in the upper right, and 3 will go all the way across the bottom.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David L. Borchers <a href="mailto:dlb@st-andrews.ac.uk">dlb@st-andrews.ac.uk</a>
</p>


<h3>Source</h3>

<p><a href="http://www.cookbook-r.com/Graphs/Multiple_graphs_on_one_page_(ggplot2)/">http://www.cookbook-r.com/Graphs/Multiple_graphs_on_one_page_(ggplot2)/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("ggplot2", quietly = TRUE)) {
  df &lt;- data.frame(x = 1:10, y = 1:10, z = 11:20)
  pl1 &lt;- ggplot(data = df) +
    geom_line(mapping = aes(x, y), color = "red")
  pl2 &lt;- ggplot(data = df) +
    geom_line(mapping = aes(x, z), color = "blue")
  multiplot(pl1, pl2, cols = 2)
}
</code></pre>

<hr>
<h2 id='parse_inclusion'>Parse inclusion of component labels in a predictor expression</h2><span id='topic+parse_inclusion'></span>

<h3>Description</h3>

<p>Parse inclusion of component labels in a predictor expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_inclusion(thenames, include = NULL, exclude = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_inclusion_+3A_thenames">thenames</code></td>
<td>
<p>Set of labels to restrict</p>
</td></tr>
<tr><td><code id="parse_inclusion_+3A_include">include</code></td>
<td>
<p>Character vector of component labels that are needed by the
predictor expression; Default: NULL (include all components that are not
explicitly excluded)</p>
</td></tr>
<tr><td><code id="parse_inclusion_+3A_exclude">exclude</code></td>
<td>
<p>Character vector of component labels that are not used by the
predictor expression. The exclusion list is applied to the list
as determined by the <code>include</code> parameter; Default: NULL (do not remove
any components from the inclusion list)</p>
</td></tr>
</table>

<hr>
<h2 id='plot.bru'>Plot method for posterior marginals estimated by bru</h2><span id='topic+plot.bru'></span><span id='topic+plotmarginal.inla'></span>

<h3>Description</h3>

<p>From version <code style="white-space: pre;">&#8288;2.11.0&#8288;</code>, <code>plot.bru(x, ...)</code> calls <code>plot.inla(x, ...)</code>
from the <code>INLA</code> package, unless the first argument after <code>x</code> is a
<code>character</code>, in which case the pre-<code style="white-space: pre;">&#8288;2.11.0&#8288;</code> behaviour is used, calling
<code>plotmarginal.inla(x, ...)</code> instead.
</p>
<p>Requires the <code>ggplot2</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bru'
plot(x, ...)

plotmarginal.inla(
  result,
  varname = NULL,
  index = NULL,
  link = function(x) {
     x
 },
  add = FALSE,
  ggp = TRUE,
  lwd = 3,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bru_+3A_x">x</code></td>
<td>
<p>a fitted <code><a href="#topic+bru">bru()</a></code> model.</p>
</td></tr>
<tr><td><code id="plot.bru_+3A_...">...</code></td>
<td>
<p>Options passed on to other methods.</p>
</td></tr>
<tr><td><code id="plot.bru_+3A_result">result</code></td>
<td>
<p>an <code>inla</code> or <code>bru</code> result object</p>
</td></tr>
<tr><td><code id="plot.bru_+3A_varname">varname</code></td>
<td>
<p>character; name of the variable to plot</p>
</td></tr>
<tr><td><code id="plot.bru_+3A_index">index</code></td>
<td>
<p>integer; index of the random effect to plot</p>
</td></tr>
<tr><td><code id="plot.bru_+3A_link">link</code></td>
<td>
<p>function; link function to apply to the variable</p>
</td></tr>
<tr><td><code id="plot.bru_+3A_add">add</code></td>
<td>
<p>logical; if <code>TRUE</code>, add to an existing plot</p>
</td></tr>
<tr><td><code id="plot.bru_+3A_ggp">ggp</code></td>
<td>
<p>logical; unused</p>
</td></tr>
<tr><td><code id="plot.bru_+3A_lwd">lwd</code></td>
<td>
<p>numeric; line width</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (require("ggplot2", quietly = TRUE)) {
  # Generate some data and fit a simple model
  input.df &lt;- data.frame(x = cos(1:10))
  input.df &lt;- within(
    input.df,
    y &lt;- 5 + 2 * x + rnorm(length(x), mean = 0, sd = 0.1)
  )
  fit &lt;- bru(y ~ x, family = "gaussian", data = input.df)
  summary(fit)

  # Plot the posterior density of the model's x-effect
  plot(fit, "x")
}

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.bru_prediction'>Plot prediction using ggplot2</h2><span id='topic+plot.bru_prediction'></span><span id='topic+plot.prediction'></span>

<h3>Description</h3>

<p>Generates a base ggplot2 using <code>ggplot()</code> and adds a geom for input <code>x</code> using <a href="#topic+gg">gg</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bru_prediction'
plot(x, y = NULL, ...)

## S3 method for class 'prediction'
plot(x, y = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bru_prediction_+3A_x">x</code></td>
<td>
<p>a prediction object.</p>
</td></tr>
<tr><td><code id="plot.bru_prediction_+3A_y">y</code></td>
<td>
<p>Ignored argument but required for S3 compatibility.</p>
</td></tr>
<tr><td><code id="plot.bru_prediction_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code><a href="#topic+gg.prediction">gg.prediction()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Requires the <code>ggplot2</code> package.
</p>


<h3>Value</h3>

<p>an object of class <code>gg</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (bru_safe_inla() &amp;&amp;
    require(sn, quietly = TRUE) &amp;&amp;
    require(ggplot2, quietly = TRUE)) {
  # Generate some data

  input.df &lt;- data.frame(x = cos(1:10))
  input.df &lt;- within(input.df, y &lt;- 5 + 2 * cos(1:10) + rnorm(10, mean = 0, sd = 0.1))

  # Fit a model with fixed effect 'x' and intercept 'Intercept'

  fit &lt;- bru(y ~ x, family = "gaussian", data = input.df)

  # Predict posterior statistics of 'x'

  xpost &lt;- predict(fit, NULL, formula = ~x_latent)

  # The statistics include mean, standard deviation, the 2.5% quantile, the median,
  # the 97.5% quantile, minimum and maximum sample drawn from the posterior as well as
  # the coefficient of variation and the variance.

  xpost

  # For a single variable like 'x' the default plotting method invoked by gg() will
  # show these statisics in a fashion similar to a box plot:
  ggplot() +
    gg(xpost)


  # The predict function can also be used to simultaneously estimate posteriors
  # of multiple variables:

  xipost &lt;- predict(fit,
    newdata = NULL,
    formula = ~ c(
      Intercept = Intercept_latent,
      x = x_latent
    )
  )
  xipost

  # If we still want a plot in the previous style we have to set the bar parameter to TRUE

  p1 &lt;- ggplot() +
    gg(xipost, bar = TRUE)
  p1

  # Note that gg also understands the posterior estimates generated while running INLA

  p2 &lt;- ggplot() +
    gg(fit$summary.fixed, bar = TRUE)
  multiplot(p1, p2)

  # By default, if the prediction has more than one row, gg will plot the column 'mean' against
  # the row index. This is for instance usefuul for predicting and plotting function
  # but not very meaningful given the above example:

  ggplot() +
    gg(xipost)

  # For ease of use we can also type

  plot(xipost)

  # This type of plot will show a ribbon around the mean, which viszualizes the upper and lower
  # quantiles mentioned above (2.5 and 97.5%). Plotting the ribbon can be turned of using the
  # \code{ribbon} parameter

  ggplot() +
    gg(xipost, ribbon = FALSE)

  # Much like the other geomes produced by gg we can adjust the plot using ggplot2 style
  # commands, for instance

  ggplot() +
    gg(xipost) +
    gg(xipost, mapping = aes(y = median), ribbon = FALSE, color = "red")
}

</code></pre>

<hr>
<h2 id='plotsample'>Create a plot sample.</h2><span id='topic+plotsample'></span>

<h3>Description</h3>

<p>Creates a plot sample on a regular grid with a random start location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotsample(spdf, boundary, x.ppn = 0.25, y.ppn = 0.25, nx = 5, ny = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotsample_+3A_spdf">spdf</code></td>
<td>
<p>A <code>SpatialPointsDataFrame</code> defining the points that are to be sampled
by the plot sample.</p>
</td></tr>
<tr><td><code id="plotsample_+3A_boundary">boundary</code></td>
<td>
<p>A <code>SpatialPolygonsDataFrame</code> defining the survey boundary within which
the  points occur.</p>
</td></tr>
<tr><td><code id="plotsample_+3A_x.ppn">x.ppn</code></td>
<td>
<p>The proportion of the x=axis that is to be included in the plots.</p>
</td></tr>
<tr><td><code id="plotsample_+3A_y.ppn">y.ppn</code></td>
<td>
<p>The proportion of the y=axis that is to be included in the plots.</p>
</td></tr>
<tr><td><code id="plotsample_+3A_nx">nx</code></td>
<td>
<p>The number of plots in the x-dimension.</p>
</td></tr>
<tr><td><code id="plotsample_+3A_ny">ny</code></td>
<td>
<p>The number of plots in the y-dimension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with three components:
</p>

<dl>
<dt><code>plots</code>:</dt><dd><p> A <code>SpatialPolygonsDataFrame</code> object containing the plots that were
sampled.</p>
</dd>
<dt><code>dets</code>:</dt><dd><p> A <code>SpatialPointsDataFrame</code> object containing the locations of the
points within the plots.</p>
</dd>
<dt><code>counts</code>:</dt><dd><p> A <code>dataframe</code> containing the following columns
</p>

<dl>
<dt><code>x</code>:</dt><dd><p>The x-coordinates of the centres of the plots within the boundary.</p>
</dd>
<dt><code>y</code>:</dt><dd><p>The y-coordinates of the centres of the plots within the boundary.</p>
</dd>
<dt><code>n</code>:</dt><dd><p>The numbers of points in each plot.</p>
</dd>
<dt><code>area</code>:</dt><dd><p>The areas of the plots within the boundary</p>
</dd>
</dl>
</dd>
</dl>
<p>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Some features require the raster package
if (bru_safe_sp() &amp;&amp;
  require("sp") &amp;&amp;
  require("raster", quietly = TRUE) &amp;&amp;
  require("ggplot2", quietly = TRUE)) {
  data(gorillas, package = "inlabru")
  plotpts &lt;- plotsample(gorillas$nests, gorillas$boundary,
    x.ppn = 0.4, y.ppn = 0.4, nx = 5, ny = 5
  )
  ggplot() +
    gg(plotpts$plots) +
    gg(plotpts$dets, pch = "+", cex = 2) +
    gg(gorillas$boundary)
}


</code></pre>

<hr>
<h2 id='point2count'>Convert a plot sample of points into one of counts.</h2><span id='topic+point2count'></span>

<h3>Description</h3>

<p>Converts a plot sample with locations of each point within each plot, into a plot
sample with only the count within each plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>point2count(plots, dets)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="point2count_+3A_plots">plots</code></td>
<td>
<p>A <code>SpatialPolygonsDataFrame</code> object containing the plots that were
sampled.</p>
</td></tr>
<tr><td><code id="point2count_+3A_dets">dets</code></td>
<td>
<p>A <code>SpatialPointsDataFrame</code> object containing the locations of the
points within the plots.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>SpatialPolygonsDataFrame</code> with counts in each plot contained in
slot <code style="white-space: pre;">&#8288;@data$n&#8288;</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Some features require the raster package
if (bru_safe_sp() &amp;&amp;
  require("sp") &amp;&amp;
  require("raster", quietly = TRUE) &amp;&amp;
  require("ggplot2", quietly = TRUE)) {
  data(gorillas, package = "inlabru")
  plotpts &lt;- plotsample(gorillas$nests, gorillas$boundary,
    x.ppn = 0.4, y.ppn = 0.4, nx = 5, ny = 5
  )
  p1 &lt;- ggplot() +
    gg(plotpts$plots) +
    gg(plotpts$dets) +
    gg(gorillas$boundary)
  countdata &lt;- point2count(plotpts$plots, plotpts$dets)
  x &lt;- coordinates(countdata)[, 1]
  y &lt;- coordinates(countdata)[, 2]
  count &lt;- countdata@data$n
  p2 &lt;- ggplot() +
    gg(gorillas$boundary) +
    gg(plotpts$plots) +
    geom_text(aes(label = count, x = x, y = y))
  multiplot(p1, p2, cols = 2)
}


</code></pre>

<hr>
<h2 id='Poisson1_1D'>1-Dimensional Homogeneous Poisson example.</h2><span id='topic+Poisson1_1D'></span><span id='topic+lambda1_1D'></span><span id='topic+E_nc1'></span><span id='topic+pts1'></span><span id='topic+countdata1'></span>

<h3>Description</h3>

<p>Point data and count data, together with intensity function and expected counts for
a homogeneous 1-dimensional Poisson process example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Poisson1_1D)
</code></pre>


<h3>Format</h3>

<p>The data contain the following <code>R</code> objects:
</p>

<dl>
<dt><code>lambda1_1D</code>:</dt><dd><p> A function defining the intensity function of a
nonhomogeneous Poisson process. Note that this function is only defined on
the interval (0,55).</p>
</dd>
<dt><code>E_nc1</code></dt><dd><p> The expected counts of the gridded data.</p>
</dd>
<dt><code>pts1</code></dt><dd><p> The locations of the observed points (a data frame with one column, named <code>x</code>).</p>
</dd>
<dt><code>countdata1</code></dt><dd><p> A data frame with three columns, containing the count data:</p>
</dd>
</dl>

<dl>
<dt><code>x</code></dt><dd><p> The grid cell midpoint.</p>
</dd>
<dt><code>count</code></dt><dd><p> The number of detections in the cell.</p>
</dd>
<dt><code>exposure</code></dt><dd><p> The width of the cell.</p>
</dd>
</dl>




<h3>Examples</h3>

<pre><code class='language-R'>
if (require("ggplot2", quietly = TRUE)) {
  data(Poisson1_1D)
  ggplot(countdata1) +
    geom_point(data = countdata1, aes(x = x, y = count), col = "blue") +
    ylim(0, max(countdata1$count)) +
    geom_point(data = pts1, aes(x = x), y = 0.2, shape = "|", cex = 4) +
    geom_point(
      data = countdata1, aes(x = x), y = 0, shape = "+",
      col = "blue", cex = 4
    ) +
    xlab(expression(bold(s))) +
    ylab("count")
}

</code></pre>

<hr>
<h2 id='Poisson2_1D'>1-Dimensional NonHomogeneous Poisson example.</h2><span id='topic+Poisson2_1D'></span><span id='topic+lambda2_1D'></span><span id='topic+cov2_1D'></span><span id='topic+E_nc2'></span><span id='topic+pts2'></span><span id='topic+countdata2'></span>

<h3>Description</h3>

<p>Point data and count data, together with intensity function and expected counts for
a unimodal nonhomogeneous 1-dimensional Poisson process example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Poisson2_1D)
</code></pre>


<h3>Format</h3>

<p>The data contain the following <code>R</code> objects:
</p>

<dl>
<dt><code>lambda2_1D</code>:</dt><dd><p> A function defining the intensity function of a
nonhomogeneous Poisson process. Note that this function is only defined on
the interval (0,55).</p>
</dd>
<dt><code>cov2_1D</code>:</dt><dd><p> A function that gives what we will call a
'habitat suitability' covariate in 1D space.</p>
</dd>
<dt><code>E_nc2</code></dt><dd><p> The expected counts of the gridded data.</p>
</dd>
<dt><code>pts2</code></dt><dd><p> The locations of the observed points (a data frame with one column, named <code>x</code>).</p>
</dd>
<dt><code>countdata2</code></dt><dd><p> A data frame with three columns, containing the count data:</p>
</dd>
</dl>

<dl>
<dt><code>x</code></dt><dd><p> The grid cell midpoint.</p>
</dd>
<dt><code>count</code></dt><dd><p> The number of detections in the cell.</p>
</dd>
<dt><code>exposure</code></dt><dd><p> The width of the cell.</p>
</dd>
</dl>




<h3>Examples</h3>

<pre><code class='language-R'>
if (require("ggplot2", quietly = TRUE)) {
  data(Poisson2_1D)
  p1 &lt;- ggplot(countdata2) +
    geom_point(data = countdata2, aes(x = x, y = count), col = "blue") +
    ylim(0, max(countdata2$count, E_nc2)) +
    geom_point(
      data = countdata2, aes(x = x), y = 0, shape = "+",
      col = "blue", cex = 4
    ) +
    geom_point(
      data = data.frame(x = countdata2$x, y = E_nc2), aes(x = x),
      y = E_nc2, shape = "_", cex = 5
    ) +
    xlab(expression(bold(s))) +
    ylab("count")
  ss &lt;- seq(0, 55, length.out = 200)
  lambda &lt;- lambda2_1D(ss)
  p2 &lt;- ggplot() +
    geom_line(
      data = data.frame(x = ss, y = lambda),
      aes(x = x, y = y), col = "blue"
    ) +
    ylim(0, max(lambda)) +
    geom_point(data = pts2, aes(x = x), y = 0.2, shape = "|", cex = 4) +
    xlab(expression(bold(s))) +
    ylab(expression(lambda(bold(s))))
  multiplot(p1, p2, cols = 1)
}

</code></pre>

<hr>
<h2 id='Poisson3_1D'>1-Dimensional NonHomogeneous Poisson example.</h2><span id='topic+Poisson3_1D'></span><span id='topic+lambda3_1D'></span><span id='topic+E_nc3a'></span><span id='topic+E_nc3b'></span><span id='topic+pts3'></span><span id='topic+countdata3a'></span><span id='topic+countdata3b'></span>

<h3>Description</h3>

<p>Point data and count data, together with intensity function and expected counts for
a multimodal nonhomogeneous 1-dimensional Poisson process example. Counts are given for two
different gridded data interval widths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Poisson3_1D)
</code></pre>


<h3>Format</h3>

<p>The data contain the following <code>R</code> objects:
</p>

<dl>
<dt><code>lambda3_1D</code>:</dt><dd><p> A function defining the intensity function of a
nonhomogeneous Poisson process. Note that this function is only defined on
the interval (0,55).</p>
</dd>
<dt><code>E_nc3a</code></dt><dd><p> The expected counts of gridded data for the wider bins (10 bins).</p>
</dd>
<dt><code>E_nc3b</code></dt><dd><p> The expected counts of gridded data for the wider bins (20 bins).</p>
</dd>
<dt><code>pts3</code></dt><dd><p> The locations of the observed points (a data frame with one column, named <code>x</code>).</p>
</dd>
<dt><code>countdata3a</code></dt><dd><p> A data frame with three columns, containing the count data for the
10-interval case:</p>
</dd>
<dt><code>countdata3b</code></dt><dd><p> A data frame with three columns, containing the count data for the
20-interval case:</p>
</dd>
</dl>

<dl>
<dt><code>x</code></dt><dd><p> The grid cell midpoint.</p>
</dd>
<dt><code>count</code></dt><dd><p> The number of detections in the cell.</p>
</dd>
<dt><code>exposure</code></dt><dd><p> The width of the cell.</p>
</dd>
</dl>




<h3>Examples</h3>

<pre><code class='language-R'>
if (require("ggplot2", quietly = TRUE)) {
  data(Poisson3_1D)
  # first the plots for the 10-bin case:
  p1a &lt;- ggplot(countdata3a) +
    geom_point(data = countdata3a, aes(x = x, y = count), col = "blue") +
    ylim(0, max(countdata3a$count, E_nc3a)) +
    geom_point(
      data = countdata3a, aes(x = x), y = 0, shape = "+",
      col = "blue", cex = 4
    ) +
    geom_point(
      data = data.frame(x = countdata3a$x, y = E_nc3a),
      aes(x = x), y = E_nc3a, shape = "_", cex = 5
    ) +
    xlab(expression(bold(s))) +
    ylab("count")
  ss &lt;- seq(0, 55, length.out = 200)
  lambda &lt;- lambda3_1D(ss)
  p2a &lt;- ggplot() +
    geom_line(
      data = data.frame(x = ss, y = lambda), aes(x = x, y = y),
      col = "blue"
    ) +
    ylim(0, max(lambda)) +
    geom_point(data = pts3, aes(x = x), y = 0.2, shape = "|", cex = 4) +
    xlab(expression(bold(s))) +
    ylab(expression(lambda(bold(s))))
  multiplot(p1a, p2a, cols = 1)

  # Then the plots for the 20-bin case:
  p1a &lt;- ggplot(countdata3b) +
    geom_point(data = countdata3b, aes(x = x, y = count), col = "blue") +
    ylim(0, max(countdata3b$count, E_nc3b)) +
    geom_point(
      data = countdata3b, aes(x = x), y = 0, shape = "+",
      col = "blue", cex = 4
    ) +
    geom_point(
      data = data.frame(x = countdata3b$x, y = E_nc3b),
      aes(x = x), y = E_nc3b, shape = "_", cex = 5
    ) +
    xlab(expression(bold(s))) +
    ylab("count")
  ss &lt;- seq(0, 55, length.out = 200)
  lambda &lt;- lambda3_1D(ss)
  p2a &lt;- ggplot() +
    geom_line(
      data = data.frame(x = ss, y = lambda), aes(x = x, y = y),
      col = "blue"
    ) +
    ylim(0, max(lambda)) +
    geom_point(data = pts3, aes(x = x), y = 0.2, shape = "|", cex = 4) +
    xlab(expression(bold(s))) +
    ylab(expression(lambda(bold(s))))
  multiplot(p1a, p2a, cols = 1)
}

</code></pre>

<hr>
<h2 id='predict.bru'>Prediction from fitted bru model</h2><span id='topic+predict.bru'></span>

<h3>Description</h3>

<p>Takes a fitted <code>bru</code> object produced by the function <code><a href="#topic+bru">bru()</a></code> and produces
predictions given a new set of values for the model covariates or the
original values used for the model fit. The predictions can be based on any
R expression that is valid given these values/covariates and the joint
posterior of the estimated random effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bru'
predict(
  object,
  newdata = NULL,
  formula = NULL,
  n.samples = 100,
  seed = 0L,
  probs = c(0.025, 0.5, 0.975),
  num.threads = NULL,
  include = NULL,
  exclude = NULL,
  used = NULL,
  drop = FALSE,
  ...,
  data = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.bru_+3A_object">object</code></td>
<td>
<p>An object obtained by calling <code><a href="#topic+bru">bru()</a></code> or <code><a href="#topic+lgcp">lgcp()</a></code>.</p>
</td></tr>
<tr><td><code id="predict.bru_+3A_newdata">newdata</code></td>
<td>
<p>A <code>data.frame</code> or <code>SpatialPointsDataFrame</code> of covariates
needed for the prediction.</p>
</td></tr>
<tr><td><code id="predict.bru_+3A_formula">formula</code></td>
<td>
<p>A formula where the right hand side defines an R expression
to evaluate for each generated sample. If <code>NULL</code>, the latent and
hyperparameter states are returned as named list elements.
See Details for more information.</p>
</td></tr>
<tr><td><code id="predict.bru_+3A_n.samples">n.samples</code></td>
<td>
<p>Integer setting the number of samples to draw in order to
calculate the posterior statistics. The default is rather low but provides
a quick approximate result.</p>
</td></tr>
<tr><td><code id="predict.bru_+3A_seed">seed</code></td>
<td>
<p>Random number generator seed passed on to <code>inla.posterior.sample</code></p>
</td></tr>
<tr><td><code id="predict.bru_+3A_probs">probs</code></td>
<td>
<p>A numeric vector of probabilities with values in <code style="white-space: pre;">&#8288;[0, 1]&#8288;</code>,
passed to <code>stats::quantile</code></p>
</td></tr>
<tr><td><code id="predict.bru_+3A_num.threads">num.threads</code></td>
<td>
<p>Specification of desired number of threads for parallel
computations. Default NULL, leaves it up to INLA.
When seed != 0, overridden to &quot;1:1&quot;</p>
</td></tr>
<tr><td><code id="predict.bru_+3A_include">include</code></td>
<td>
<p>Character vector of component labels that are needed by the
predictor expression; Default: the result of <code style="white-space: pre;">&#8288;[all.vars()]&#8288;</code> on the
predictor expression, unless the expression is not &quot;.&quot;, in which case
<code>include=NULL</code>, to include all components that are not
explicitly excluded. The <code><a href="#topic+bru_used">bru_used()</a></code> methods are used
to extract the variable names, followed by removal of non-component names
when the components are available.</p>
</td></tr>
<tr><td><code id="predict.bru_+3A_exclude">exclude</code></td>
<td>
<p>Character vector of component labels that are not used by the
predictor expression. The exclusion list is applied to the list
as determined by the <code>include</code> parameter; Default: NULL (do not remove
any components from the inclusion list)</p>
</td></tr>
<tr><td><code id="predict.bru_+3A_used">used</code></td>
<td>
<p>Either <code>NULL</code> or a <code><a href="#topic+bru_used">bru_used()</a></code> object, overriding <code>include</code> and
<code>exclude</code>. Default <code>NULL</code></p>
</td></tr>
<tr><td><code id="predict.bru_+3A_drop">drop</code></td>
<td>
<p>logical; If <code>keep=FALSE</code>, <code>newdata</code> is a <code>Spatial*DataFrame</code>, and
the prediciton summary has the same number of rows as <code>newdata</code>, then the
output is a <code>Spatial*DataFrame</code> object. Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="predict.bru_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code>inla.posterior.sample()</code></p>
</td></tr>
<tr><td><code id="predict.bru_+3A_data">data</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Use <code>newdata</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mean value predictions are accompanied by the standard errors, upper and
lower 2.5% quantiles, the
median, variance, coefficient of variation as well as the variance and
minimum and maximum sample
value drawn in course of estimating the statistics.
</p>
<p>Internally, this method calls <code><a href="#topic+generate.bru">generate.bru()</a></code> in order to draw samples from
the model.
</p>
<p>In addition to the component names (that give the effect of each component
evaluated for the input data), the suffix <code style="white-space: pre;">&#8288;_latent&#8288;</code> variable name can be used
to directly access the latent state for a component, and the suffix function
<code style="white-space: pre;">&#8288;_eval&#8288;</code> can be used to evaluate a component at other input values than the
expressions defined in the component definition itself, e.g.
<code>field_eval(cbind(x, y))</code> for a component that was defined with
<code>field(coordinates, ...)</code> (see also <code><a href="#topic+component_eval">component_eval()</a></code>).
</p>
<p>For &quot;iid&quot; models with <code>mapper = bru_mapper_index(n)</code>, <code>rnorm()</code> is used to
generate new realisations for indices greater than <code>n</code>.
</p>


<h3>Value</h3>

<p>a <code>data.frame</code>, <code>sf</code>, or <code style="white-space: pre;">&#8288;Spatial*&#8288;</code> object with predicted mean values and
other summary statistics attached. Non-S4 object outputs have the class
&quot;bru_prediction&quot; added at the front of the class list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (bru_safe_inla(multicore = FALSE) &amp;&amp;
    bru_safe_sp() &amp;&amp;
    require("sp") &amp;&amp;
    require("sn", quietly = TRUE) &amp;&amp;
    require("ggplot2", quietly = TRUE)) {

  # Load the Gorilla data

  data(gorillas, package = "inlabru")

  # Plot the Gorilla nests, the mesh and the survey boundary

  ggplot() +
    gg(gorillas$mesh) +
    gg(gorillas$nests) +
    gg(gorillas$boundary)

  # Define SPDE prior

  matern &lt;- INLA::inla.spde2.pcmatern(gorillas$mesh,
    prior.sigma = c(0.1, 0.01),
    prior.range = c(0.01, 0.01)
  )

  # Define domain of the LGCP as well as the model components (spatial SPDE effect and Intercept)

  cmp &lt;- coordinates ~ mySmooth(main = coordinates, model = matern) + Intercept(1)

  # Fit the model, with "eb" instead of full Bayes
  fit &lt;- lgcp(cmp, gorillas$nests,
    samplers = gorillas$boundary,
    domain = list(coordinates = gorillas$mesh),
    options = list(control.inla = list(int.strategy = "eb"))
  )

  # Once we obtain a fitted model the predict function can serve various purposes.
  # The most basic one is to determine posterior statistics of a univariate
  # random variable in the model, e.g. the intercept

  icpt &lt;- predict(fit, NULL, ~ c(Intercept = Intercept_latent))
  plot(icpt)

  # The formula argument can take any expression that is valid within the model, for
  # instance a non-linear transformation of a random variable

  exp.icpt &lt;- predict(fit, NULL, ~ c(
    "Intercept" = Intercept_latent,
    "exp(Intercept)" = exp(Intercept_latent)
  ))
  plot(exp.icpt, bar = TRUE)

  # The intercept is special in the sense that it does not depend on other variables
  # or covariates. However, this is not true for the smooth spatial effects 'mySmooth'.
  # In order to predict 'mySmooth' we have to define where (in space) to predict. For
  # this purpose, the second argument of the predict function can take \code{data.frame}
  # objects as well as Spatial objects. For instance, we might want to predict
  # 'mySmooth' at the locations of the mesh vertices. Using

  vrt &lt;- fm_vertices(gorillas$mesh, format = "sp")

  # we obtain these vertices as a SpatialPointsDataFrame

  ggplot() +
    gg(gorillas$mesh) +
    gg(vrt, color = "red")

  # Predicting 'mySmooth' at these locations works as follows

  mySmooth &lt;- predict(fit, vrt, ~mySmooth)

  # Note that just like the input also the output will be a SpatialPointsDataFrame
  # and that the predicted statistics are simply added as columns

  class(mySmooth)
  head(vrt)
  head(mySmooth)

  # Plotting the mean, for instance, at the mesh node is straight forward

  ggplot() +
    gg(gorillas$mesh) +
    gg(mySmooth, aes(color = mean), size = 3)

  # However, we are often interested in a spatial field and thus a linear interpolation,
  # which can be achieved by using the gg mechanism for meshes

  ggplot() +
    gg(gorillas$mesh, color = mySmooth$mean)

  # Alternatively, we can predict the spatial field at a grid of locations, e.g. a
  # SpatialPixels object covering the mesh

  pxl &lt;- fm_pixels(gorillas$mesh, format = "sp")
  mySmooth2 &lt;- predict(fit, pxl, ~mySmooth)

  # This will give us a SpatialPixelDataFrame with the columns we are looking for

  head(mySmooth2)
  ggplot() +
    gg(mySmooth2)
}

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+fm_crs_oblique+3C-'></span><span id='topic+fm_ellipsoid_radius+3C-'></span><span id='topic+fm_length_unit+3C-'></span><span id='topic+fm_CRS'></span><span id='topic+fm_CRS_as_list'></span><span id='topic+fm_CRSargs'></span><span id='topic+fm_CRSargs_as_list'></span><span id='topic+fm_as_fm'></span><span id='topic+fm_as_mesh_2d'></span><span id='topic+fm_as_mesh_1d'></span><span id='topic+fm_as_lattice_2d'></span><span id='topic+fm_as_segm'></span><span id='topic+fm_mesh_2d'></span><span id='topic+fm_mesh_1d'></span><span id='topic+fm_lattice_2d'></span><span id='topic+fm_segm'></span><span id='topic+fm_as_sfc'></span><span id='topic+fm_as_sp_crs'></span><span id='topic+fm_contains'></span><span id='topic+fm_cprod'></span><span id='topic+fm_crs'></span><span id='topic+fm_crs_get_ellipsoid_radius'></span><span id='topic+fm_crs_get_lengthunit'></span><span id='topic+fm_crs_get_wkt'></span><span id='topic+fm_crs_is_geocent'></span><span id='topic+fm_crs_oblique'></span><span id='topic+fm_crs_set_ellipsoid_radius'></span><span id='topic+fm_crs_set_lengthunit'></span><span id='topic+fm_ellipsoid_radius'></span><span id='topic+fm_evaluate'></span><span id='topic+fm_evaluator'></span><span id='topic+fm_evaluator_lattice'></span><span id='topic+fm_has_PROJ6'></span><span id='topic+fm_crs_is_identical'></span><span id='topic+fm_identical_CRS'></span><span id='topic+fm_int'></span><span id='topic+fm_int_multi_sampler'></span><span id='topic+fm_length_unit'></span><span id='topic+fm_list_as_CRS'></span><span id='topic+fm_proj4string'></span><span id='topic+fm_sp2segment'></span><span id='topic+fm_spTransform'></span><span id='topic+fm_sp_get_crs'></span><span id='topic+fm_transform'></span><span id='topic+fm_wkt'></span><span id='topic+fm_wkt_as_wkt_tree'></span><span id='topic+fm_wkt_get_ellipsoid_radius'></span><span id='topic+fm_wkt_get_lengthunit'></span><span id='topic+fm_wkt_is_geocent'></span><span id='topic+fm_wkt_predef'></span><span id='topic+fm_wkt_set_ellipsoid_radius'></span><span id='topic+fm_wkt_set_lengthunit'></span><span id='topic+fm_wkt_tree_as_wkt'></span><span id='topic+fm_wkt_tree_get_item'></span><span id='topic+fm_wkt_tree_set_item'></span><span id='topic+fm_wkt_unit_params'></span><span id='topic+fm_centroids'></span><span id='topic+fm_pixels'></span><span id='topic+fm_store_points'></span><span id='topic+fm_vertices'></span><span id='topic+fm_is_within'></span><span id='topic+fm_as_inla_mesh'></span><span id='topic+fm_as_inla_mesh_segment'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>fmesher</dt><dd><p><code><a href="fmesher.html#topic+fm_as_fm">fm_as_fm</a></code>, <code><a href="fmesher.html#topic+fmesher-deprecated">fm_as_inla_mesh</a></code>, <code><a href="fmesher.html#topic+fmesher-deprecated">fm_as_inla_mesh_segment</a></code>, <code><a href="fmesher.html#topic+fm_as_lattice_2d">fm_as_lattice_2d</a></code>, <code><a href="fmesher.html#topic+fm_as_mesh_1d">fm_as_mesh_1d</a></code>, <code><a href="fmesher.html#topic+fm_as_mesh_2d">fm_as_mesh_2d</a></code>, <code><a href="fmesher.html#topic+fm_as_segm">fm_as_segm</a></code>, <code><a href="fmesher.html#topic+fm_as_sfc">fm_as_sfc</a></code>, <code><a href="fmesher.html#topic+fmesher-deprecated">fm_as_sp_crs</a></code>, <code><a href="fmesher.html#topic+fm_centroids">fm_centroids</a></code>, <code><a href="fmesher.html#topic+fm_contains">fm_contains</a></code>, <code><a href="fmesher.html#topic+fm_cprod">fm_cprod</a></code>, <code><a href="fmesher.html#topic+fm_crs">fm_crs</a></code>, <code><a href="fmesher.html#topic+fm_CRS_sp">fm_CRS</a></code>, <code><a href="fmesher.html#topic+fm_CRSargs">fm_CRS_as_list</a></code>, <code><a href="fmesher.html#topic+fm_crs_wkt">fm_crs_get_ellipsoid_radius</a></code>, <code><a href="fmesher.html#topic+fm_crs_wkt">fm_crs_get_lengthunit</a></code>, <code><a href="fmesher.html#topic+fm_crs_wkt">fm_crs_get_wkt</a></code>, <code><a href="fmesher.html#topic+fm_crs_wkt">fm_crs_is_geocent</a></code>, <code><a href="fmesher.html#topic+fm_crs_is_identical">fm_crs_is_identical</a></code>, <code><a href="fmesher.html#topic+fm_crs">fm_crs_oblique</a></code>, <code><a href="fmesher.html#topic+fm_crs-set">fm_crs_oblique&lt;-</a></code>, <code><a href="fmesher.html#topic+fm_crs_wkt">fm_crs_set_ellipsoid_radius</a></code>, <code><a href="fmesher.html#topic+fm_crs_wkt">fm_crs_set_lengthunit</a></code>, <code><a href="fmesher.html#topic+fm_CRSargs">fm_CRSargs</a></code>, <code><a href="fmesher.html#topic+fm_CRSargs">fm_CRSargs_as_list</a></code>, <code><a href="fmesher.html#topic+fm_crs_wkt">fm_ellipsoid_radius</a></code>, <code><a href="fmesher.html#topic+fm_crs_wkt">fm_ellipsoid_radius&lt;-</a></code>, <code><a href="fmesher.html#topic+fm_evaluate">fm_evaluate</a></code>, <code><a href="fmesher.html#topic+fm_evaluate">fm_evaluator</a></code>, <code><a href="fmesher.html#topic+fm_evaluate">fm_evaluator_lattice</a></code>, <code><a href="fmesher.html#topic+fmesher-deprecated">fm_has_PROJ6</a></code>, <code><a href="fmesher.html#topic+fm_crs_is_identical">fm_identical_CRS</a></code>, <code><a href="fmesher.html#topic+fm_int">fm_int</a></code>, <code><a href="fmesher.html#topic+fm_int_multi_sampler">fm_int_multi_sampler</a></code>, <code><a href="fmesher.html#topic+fm_is_within">fm_is_within</a></code>, <code><a href="fmesher.html#topic+fm_lattice_2d">fm_lattice_2d</a></code>, <code><a href="fmesher.html#topic+fm_crs_wkt">fm_length_unit</a></code>, <code><a href="fmesher.html#topic+fm_crs_wkt">fm_length_unit&lt;-</a></code>, <code><a href="fmesher.html#topic+fm_CRSargs">fm_list_as_CRS</a></code>, <code><a href="fmesher.html#topic+fm_mesh_1d">fm_mesh_1d</a></code>, <code><a href="fmesher.html#topic+fm_mesh_2d">fm_mesh_2d</a></code>, <code><a href="fmesher.html#topic+fm_pixels">fm_pixels</a></code>, <code><a href="fmesher.html#topic+fm_crs_wkt">fm_proj4string</a></code>, <code><a href="fmesher.html#topic+fm_segm">fm_segm</a></code>, <code><a href="fmesher.html#topic+fmesher-deprecated">fm_sp_get_crs</a></code>, <code><a href="fmesher.html#topic+fmesher-deprecated">fm_sp2segment</a></code>, <code><a href="fmesher.html#topic+fmesher-deprecated">fm_spTransform</a></code>, <code><a href="fmesher.html#topic+fm_store_points">fm_store_points</a></code>, <code><a href="fmesher.html#topic+fm_transform">fm_transform</a></code>, <code><a href="fmesher.html#topic+fm_vertices">fm_vertices</a></code>, <code><a href="fmesher.html#topic+fm_crs_wkt">fm_wkt</a></code>, <code><a href="fmesher.html#topic+wkt_tree">fm_wkt_as_wkt_tree</a></code>, <code><a href="fmesher.html#topic+fm_crs_wkt">fm_wkt_get_ellipsoid_radius</a></code>, <code><a href="fmesher.html#topic+fm_crs_wkt">fm_wkt_get_lengthunit</a></code>, <code><a href="fmesher.html#topic+fm_crs_wkt">fm_wkt_is_geocent</a></code>, <code><a href="fmesher.html#topic+fm_crs">fm_wkt_predef</a></code>, <code><a href="fmesher.html#topic+fm_crs_wkt">fm_wkt_set_ellipsoid_radius</a></code>, <code><a href="fmesher.html#topic+fm_crs_wkt">fm_wkt_set_lengthunit</a></code>, <code><a href="fmesher.html#topic+wkt_tree">fm_wkt_tree_as_wkt</a></code>, <code><a href="fmesher.html#topic+wkt_tree">fm_wkt_tree_get_item</a></code>, <code><a href="fmesher.html#topic+wkt_tree">fm_wkt_tree_set_item</a></code>, <code><a href="fmesher.html#topic+fm_crs_wkt">fm_wkt_unit_params</a></code></p>
</dd>
</dl>

<hr>
<h2 id='robins_subset'>robins_subset</h2><span id='topic+robins_subset'></span>

<h3>Description</h3>

<p>This is the <code>robins_subset</code> dataset, which is a subset of the
full robins data set used to demonstrate a spatially varying trend coefficient
model in Meehan et al. 2019. The dataset includes American Robin counts,
along with time, location, and effort information, from Audubon Christimas Bird
Counts (CBC) conducted in six US states between 1987 and 2016.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robins_subset
</code></pre>


<h3>Format</h3>

<p>The data are a data.frame with variables
</p>

<dl>
<dt><code>circle</code>:</dt><dd>
<p>Four-letter code of the CBC circle.
</p>
</dd>
<dt><code>bcr</code>:</dt><dd>
<p>Numeric code for the bird conservation region encompassing the
count circle.
</p>
</dd>
<dt><code>state</code>:</dt><dd>
<p>US state encompassing the count circle.
</p>
</dd>
<dt><code>year</code>:</dt><dd>
<p>calendar year the count was conducted.
</p>
</dd>
<dt><code>std_yr</code>:</dt><dd>
<p>transformed year, with 2016 = 0.
</p>
</dd>
<dt><code>count</code>:</dt><dd>
<p>number of robins recorded.
</p>
</dd>
<dt><code>log_hrs</code>:</dt><dd>
<p>the natural log of party hours.
</p>
</dd>
<dt><code>lon</code>:</dt><dd>
<p>longitude of the count circle centroid.
</p>
</dd>
<dt><code>lat</code>:</dt><dd>
<p>latitude of the count circle centroid.
</p>
</dd>
<dt><code>obs</code>:</dt><dd>
<p>unique record identifier.
</p>
</dd>
</dl>



<h3>Source</h3>

<p>https://github.com/tmeeha/inlaSVCBC
</p>


<h3>References</h3>

<p>Meehan, T.D., Michel, N.L., and Rue, H. 2019. Spatial modeling of Audubon
Christmas Bird Counts reveals fine-scale patterns and drivers of relative
abundance trends. Ecosphere, 10(4), p.e02707.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(ggplot2, quietly = TRUE)) {
  data(robins_subset, package = "inlabru") # get the data

  # plot the counts for one year of data
  ggplot(robins_subset[robins_subset$std_yr == 0, ]) +
    geom_point(aes(lon, lat, colour = count + 1)) +
    scale_colour_gradient(low = "blue", high = "red", trans = "log")
}
</code></pre>

<hr>
<h2 id='row_kron'>Row-wise Kronecker products</h2><span id='topic+row_kron'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> in favour of <code><a href="fmesher.html#topic+fm_row_kron">fmesher::fm_row_kron()</a></code>.
</p>
<p>Takes two Matrices and computes the row-wise Kronecker product.  Optionally
applies row-wise weights and/or applies an additional 0/1 row-wise Kronecker
matrix product.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>row_kron(M1, M2, repl = NULL, n.repl = NULL, weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="row_kron_+3A_m1">M1</code></td>
<td>
<p>A matrix that can be transformed into a sparse Matrix.</p>
</td></tr>
<tr><td><code id="row_kron_+3A_m2">M2</code></td>
<td>
<p>A matrix that can be transformed into a sparse Matrix.</p>
</td></tr>
<tr><td><code id="row_kron_+3A_repl">repl</code></td>
<td>
<p>An optional index vector.  For each entry, specifies which
replicate the row belongs to, in the sense used in
<code>INLA::inla.spde.make.A</code></p>
</td></tr>
<tr><td><code id="row_kron_+3A_n.repl">n.repl</code></td>
<td>
<p>The maximum replicate index, in the sense used in
<code>INLA::inla.spde.make.A()</code>.</p>
</td></tr>
<tr><td><code id="row_kron_+3A_weights">weights</code></td>
<td>
<p>Optional scaling weights to be applied row-wise to the
resulting matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Matrix::sparseMatrix</code> object.
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>

<hr>
<h2 id='sample.lgcp'>Sample from an inhomogeneous Poisson process</h2><span id='topic+sample.lgcp'></span>

<h3>Description</h3>

<p>This function provides point samples from one- and two-dimensional inhomogeneous Poisson processes. The
log intensity has to be provided via its values at the nodes of an <code>inla.mesh.1d</code> or
<code>inla.mesh</code> object. In between mesh nodes the log intensity is assumed to be linear.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample.lgcp(
  mesh,
  loglambda,
  strategy = NULL,
  R = NULL,
  samplers = NULL,
  ignore.CRS = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample.lgcp_+3A_mesh">mesh</code></td>
<td>
<p>An <code>INLA::inla.mesh</code> object</p>
</td></tr>
<tr><td><code id="sample.lgcp_+3A_loglambda">loglambda</code></td>
<td>
<p>vector or matrix; A vector of log intensities at the mesh vertices
(for higher order basis functions, e.g.
for <code>inla.mesh.1d</code> meshes, <code>loglambda</code> should be given as <code>mesh$m</code> basis
function weights rather than the values at the <code>mesh$n</code> vertices)
A single scalar is expanded to a vector of the appropriate length.
If a matrix is supplied, one process sample for each column is produced.</p>
</td></tr>
<tr><td><code id="sample.lgcp_+3A_strategy">strategy</code></td>
<td>
<p>Only relevant for 2D meshes. One of <code>'triangulated'</code>, <code>'rectangle'</code>,
<code>'sliced-spherical'</code>, <code>'spherical'</code>. The <code>'rectangle'</code> method is only valid for
CRS-less flat 2D meshes.
If <code>NULL</code> or <code>'auto'</code>, the the likely fastest method is chosen;
<code>'rectangle'</code> for flat 2D meshes with no CRS,
<code>'sliced-spherical'</code> for CRS <code>'longlat'</code> meshes, and
<code>'triangulated'</code> for all other meshes.</p>
</td></tr>
<tr><td><code id="sample.lgcp_+3A_r">R</code></td>
<td>
<p>Numerical value only applicable to spherical and geographical meshes. It is interpreted as
<code>R</code> is the equivalent Earth radius, in km, used to scale the lambda intensity.
For CRS enabled meshes, the default is 6371. For CRS-less spherical meshes, the default is 1.</p>
</td></tr>
<tr><td><code id="sample.lgcp_+3A_samplers">samplers</code></td>
<td>
<p>A <code>SpatialPolygonsDataFrame</code> or <code>inla.mesh</code> object.
Simulated points that fall outside these polygons are discarded.</p>
</td></tr>
<tr><td><code id="sample.lgcp_+3A_ignore.crs">ignore.CRS</code></td>
<td>
<p>logical; if <code>TRUE</code>, ignore any CRS information in the mesh. Default <code>FALSE</code>.
This affects <code>R</code> and the permitted values for <code>strategy</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For 2D processes on a sphere the <code>R</code> parameter can be used to adjust to sphere's radius implied by
the mesh. If the intensity is very high the standard <code>strategy</code> &quot;spherical&quot; can cause memory issues.
Using the &quot;sliced-spherical&quot; strategy can help in this case.
</p>

<ul>
<li><p> For crs-less meshes on R2: Lambda is interpreted in the raw coordinate system. Output has an NA CRS.
</p>
</li>
<li><p> For crs-less meshes on S2: Lambda with raw units, after scaling the mesh to radius <code>R</code>, if specified.
Output is given on the same domain as the mesh, with an NA CRS.
</p>
</li>
<li><p> For crs meshes on R2: Lambda is interpreted as per km^2, after scaling the globe to the Earth radius 6371 km,
or <code>R</code>, if specified. Output given in the same CRS as the mesh.
</p>
</li>
<li><p> For crs meshes on S2: Lambda is interpreted as per km^2, after scaling the globe to the Earth radius 6371 km,
or <code>R</code>, if specified. Output given in the same CRS as the mesh.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>data.frame</code> (1D case),
SpatialPoints (2D flat and 3D spherical surface cases)
SpatialPointsDataFrame (2D/3D surface cases with multiple samples).
For multiple samples, the <code>data.frame</code> output has a
column <code>'sample'</code> giving the index for each sample.
object of point locations.
</p>


<h3>Author(s)</h3>

<p>Daniel Simpson <a href="mailto:dp.simpson@gmail.com">dp.simpson@gmail.com</a> (base rectangle and spherical algorithms),
Fabian E. Bachl <a href="mailto:bachlfab@gmail.com">bachlfab@gmail.com</a> (inclusion in inlabru, sliced spherical sampling),
Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a> (extended CRS support, triangulated sampling)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The INLA package is required
if (bru_safe_inla(quietly = TRUE) &amp;&amp;
  bru_safe_sp() &amp;&amp;
  require("sp")) {
  vertices &lt;- seq(0, 3, by = 0.1)
  mesh &lt;- fm_mesh_1d(vertices)
  loglambda &lt;- 5 - 0.5 * vertices
  pts &lt;- sample.lgcp(mesh, loglambda)
  pts$y &lt;- 0
  plot(vertices, exp(loglambda), type = "l", ylim = c(0, 150))
  points(pts, pch = "|")
}



# The INLA package is required
if (bru_safe_inla(quietly = TRUE) &amp;&amp;
  require(ggplot2, quietly = TRUE) &amp;&amp;
  bru_safe_sp() &amp;&amp;
  require("sp")) {
  data("gorillas", package = "inlabru")
  pts &lt;- sample.lgcp(gorillas$mesh,
    loglambda = 1.5,
    samplers = gorillas$boundary
  )
  ggplot() +
    gg(gorillas$mesh) +
    gg(pts)
}


</code></pre>

<hr>
<h2 id='seals'>Seal pups</h2><span id='topic+seals'></span><span id='topic+seals_sp'></span>

<h3>Description</h3>

<p>This is a single transect of an aereal photo seal pup survey in the Greenland Sea
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(seals_sp)
</code></pre>


<h3>Format</h3>

<p>The data contain these objects:
</p>

<dl>
<dt><code>points</code>:</dt><dd><p> A <code>SpatialPointsDataFrame</code> Center locations of the photos</p>
</dd>
<dt><code>mesh</code>:</dt><dd><p> An <code>fm_mesh_2d</code> enclosing the plane's transect</p>
</dd>
<dt><code>ice.data</code>:</dt><dd><p> An <code>SpatialPointsDataFrame</code> with MODIS ice concentration estimates</p>
</dd>
<dt><code>ice.cv</code>:</dt><dd><p> An <code>covdata</code> object with interpolated ice coverage data</p>
</dd>
</dl>



<h3>Source</h3>

<p>Martin Jullum <a href="mailto:Martin.Jullum@nr.no">Martin.Jullum@nr.no</a>
</p>


<h3>References</h3>

<p>Oigard, T. A. (2013) From pup production to quotas: current status of harp seals in the Greenland Sea.
ICES Journal of Marine Science, doi.10.1093/icesjms/fst155.
</p>
<p>Oigard, T. A. (2014) Current status of hooded seals in the Greenland Sea. Victims of climate change and predation?,
Biological Conservation , 2014, 172, 29 - 36.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(ggplot2, quietly = TRUE)) {
  ggplot() +
    geom_fm(data = seals_sp$mesh) +
    gg(seals_sp$points)
}
</code></pre>

<hr>
<h2 id='shrimp'>Blue and red shrimp in the Western Mediterranean Sea</h2><span id='topic+shrimp'></span>

<h3>Description</h3>

<p>Blue and red shrimp in the Western Mediterranean Sea.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(shrimp)
</code></pre>


<h3>Format</h3>

<p>A list of objects:
</p>

<dl>
<dt><code>haul</code>:</dt><dd><p> A <code>SpatialPointsDataFrame</code> object containing haul locations</p>
</dd>
<dt><code>mesh</code>:</dt><dd><p> An <code>inla.mesh</code> object containing a Delaunay triangulation
mesh (a type of discretization of continuous space) covering the haul locations.</p>
</dd>
</dl>

<dl>
<dt><code>catch</code></dt><dd><p>Catch in Kg.</p>
</dd>
<dt><code>landing</code></dt><dd><p>Landing in Kg.</p>
</dd>
<dt><code>depth</code></dt><dd><p>Mean depth of the fishery haul.</p>
</dd>
</dl>




<h3>Source</h3>

<p>Pennino, Maria Grazia. Personal communication.
</p>


<h3>References</h3>

<p>Pennino, M. G., Paradinas, I., Munoz, F., Illian, J.,Quilez-Lopez, A., Bellido, J.M., Conesa,
D. Accounting for preferential sampling in species distribution models. Ecology and Evolution,  In Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (require(ggplot2, quietly = TRUE)) {
  data(shrimp, package = "inlabru")
  ggplot() +
    gg(shrimp$mesh) +
    gg(shrimp$hauls) +
    coord_equal()
}

</code></pre>

<hr>
<h2 id='sline'>Convert data frame to SpatialLinesDataFrame</h2><span id='topic+sline'></span>

<h3>Description</h3>

<p>A line in 2D space is defined by a start and an and point, each associated with 2D coordinates.
This function takes a <code>data.frame</code> as input and assumes that each row defines a line in space.
In order to do so, the data frame must have at least four columns and the <code>start.cols</code> and
<code>end.cols</code> parameters must be used to point out the names of the columns that define
the start and end coordinates of the line. The data is then converted to a
<code>SpatialLinesDataFrame</code> <code>DF</code>. If a coordinate reference system <code>crs</code> is provided
it is attached to <code>DF</code>. If also <code>to.crs</code> is provided, the coordinate system of <code>DF</code>
is transfromed accordingly. Additional columns of the input data, e.g. covariates,
are retained and attached to <code>DF</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sline(data, start.cols, end.cols, crs = CRS(as.character(NA)), to.crs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sline_+3A_data">data</code></td>
<td>
<p>A data.frame</p>
</td></tr>
<tr><td><code id="sline_+3A_start.cols">start.cols</code></td>
<td>
<p>Character array poitning out the columns of <code>data</code> that hold the start points of the lines</p>
</td></tr>
<tr><td><code id="sline_+3A_end.cols">end.cols</code></td>
<td>
<p>Character array poitning out the columns of <code>data</code> that hold the end points of the lines</p>
</td></tr>
<tr><td><code id="sline_+3A_crs">crs</code></td>
<td>
<p>Coordinate reference system of the original <code>data</code></p>
</td></tr>
<tr><td><code id="sline_+3A_to.crs">to.crs</code></td>
<td>
<p>Coordinate reference system for the SpatialLines ouput.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatialLinesDataFrame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create a data frame defining three lines
lns &lt;- data.frame(
  xs = c(1, 2, 3), ys = c(1, 1, 1), # start points
  xe = c(2, 3, 4), ye = c(2, 2, 2)
) # end points


# Conversion to SpatialLinesDataFrame without CRS
spl &lt;- sline(lns,
  start.cols = c("xs", "ys"),
  end.cols = c("xe", "ye")
)

if (require(ggplot2, quietly = TRUE)) {
  # Plot the lines
  ggplot() +
    gg(spl)
}


</code></pre>

<hr>
<h2 id='spatial.to.ppp'>Convert SpatialPoints and boundary polygon to spatstat ppp object</h2><span id='topic+spatial.to.ppp'></span>

<h3>Description</h3>

<p>Spatstat point pattern objects consist of points and an observation windows. This
function uses a SpatialPoints object and a SpatialPolygon object to generate the points
and the window. Lastly, the ppp() function is called to create the <code>ppp</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatial.to.ppp(points, samplers)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatial.to.ppp_+3A_points">points</code></td>
<td>
<p>A <code>SpatialPoints[DataFrame]</code> object describing the point pattern.</p>
</td></tr>
<tr><td><code id="spatial.to.ppp_+3A_samplers">samplers</code></td>
<td>
<p>A <code>SpatialPolygons[DataFrame]</code> object describing the observation window.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A spatstat <code>spatstat</code> <code>ppp</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (require("spatstat.geom") &amp;&amp;
  bru_safe_sp() &amp;&amp;
  require("sp")) {
  # Load Gorilla data

  data("gorillas", package = "inlabru")

  # Use nest locations and survey boundary to create a spatstat ppp object

  gp &lt;- spatial.to.ppp(gorillas$nests, gorillas$boundary)
  class(gp)

  # Plot it

  plot(gp)
}


</code></pre>

<hr>
<h2 id='spde.posterior'>Posteriors of SPDE hyper parameters and Matern correlation or covariance function.</h2><span id='topic+spde.posterior'></span>

<h3>Description</h3>

<p>Calculate posterior distribution of the range, log(range), variance, or log(variance)
parameter of a model's SPDE component. Can also plot Matern correlation or covariance function.
<code>inla.spde.result</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spde.posterior(result, name, what = "range")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spde.posterior_+3A_result">result</code></td>
<td>
<p>An object inheriting from <code>inla</code>.</p>
</td></tr>
<tr><td><code id="spde.posterior_+3A_name">name</code></td>
<td>
<p>Character stating the name of the SPDE effect, see <code>names(result$summary.random)</code>.</p>
</td></tr>
<tr><td><code id="spde.posterior_+3A_what">what</code></td>
<td>
<p>One of &quot;range&quot;, &quot;log.range&quot;, &quot;variance&quot;, &quot;log.variance&quot;, &quot;matern.correlation&quot; or &quot;matern.covariance&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>prediction</code> object.
</p>


<h3>Author(s)</h3>

<p>Finn Lindgren <a href="mailto:Finn.Lindgren@ed.ac.uk">Finn.Lindgren@ed.ac.uk</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (bru_safe_inla() &amp;&amp; require(ggplot2, quietly = TRUE)) {

  # Load 1D Poisson process data

  data(Poisson2_1D, package = "inlabru")


  # Take a look at the point (and frequency) data

  ggplot(pts2) +
    geom_histogram(aes(x = x), binwidth = 55 / 20, boundary = 0, fill = NA, color = "black") +
    geom_point(aes(x), y = 0, pch = "|", cex = 4) +
    coord_fixed(ratio = 1)

  # Fit an LGCP model with  and SPDE component

  x &lt;- seq(0, 55, length.out = 20)
  mesh1D &lt;- fm_mesh_1d(x, boundary = "free")
  mdl &lt;- x ~ spde1D(x, model = INLA::inla.spde2.matern(mesh1D)) + Intercept(1)
  fit &lt;- lgcp(mdl, data = pts2, domain = list(x = mesh1D))

  # Calculate and plot the posterior range

  range &lt;- spde.posterior(fit, "spde1D", "range")
  plot(range)

  # Calculate and plot the posterior log range

  lrange &lt;- spde.posterior(fit, "spde1D", "log.range")
  plot(lrange)

  # Calculate and plot the posterior variance

  variance &lt;- spde.posterior(fit, "spde1D", "variance")
  plot(variance)

  # Calculate and plot the posterior log variance

  lvariance &lt;- spde.posterior(fit, "spde1D", "log.variance")
  plot(lvariance)

  # Calculate and plot the posterior Matern correlation

  matcor &lt;- spde.posterior(fit, "spde1D", "matern.correlation")
  plot(matcor)

  # Calculate and plot the posterior Matern covariance

  matcov &lt;- spde.posterior(fit, "spde1D", "matern.covariance")
  plot(matcov)
}

</code></pre>

<hr>
<h2 id='spoly'>Convert a data.frame of boundary points into a SpatialPolgonsDataFrame</h2><span id='topic+spoly'></span>

<h3>Description</h3>

<p>A polygon can be described as a sequence of points defining the polygon's boundary.
When given such a sequence (anti clockwise!) this function creates a
SpatialPolygonsDataFrame holding the polygon decribed. By default, the
first two columns of <code>data</code> are assumed to define the x and y coordinates
of the points. This behavior can ba changed using the <code>cols</code> parameter, which
points out the names of the columns holding the coordinates. The coordinate
reference system of the resulting spatial polygon can be set via the <code>crs</code>
paraemter. Posterior conversion to a different CRS is supported using the
<code>to.crs</code> parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spoly(data, cols = colnames(data)[1:2], crs = fm_CRS(), to.crs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spoly_+3A_data">data</code></td>
<td>
<p>A data.frame of points describing the boundary of the polygon</p>
</td></tr>
<tr><td><code id="spoly_+3A_cols">cols</code></td>
<td>
<p>Column names of the x and y coordinates within the data</p>
</td></tr>
<tr><td><code id="spoly_+3A_crs">crs</code></td>
<td>
<p>Coordinate reference system of the points</p>
</td></tr>
<tr><td><code id="spoly_+3A_to.crs">to.crs</code></td>
<td>
<p>Coordinate reference system for the SpatialLines ouput.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>SpatialPolygonsDataFrame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create data frame of boundary points (anti clockwise!)
pts &lt;- data.frame(
  x = c(1, 2, 1.7, 1.3),
  y = c(1, 1, 2, 2)
)

# Convert to SpatialPolygonsDataFrame
pol &lt;- spoly(pts)

if (require(ggplot2, quietly = TRUE)) {
  # Plot it!
  ggplot() +
    gg(pol)
}


</code></pre>

<hr>
<h2 id='summary.bru'>Summary for an inlabru fit</h2><span id='topic+summary.bru'></span><span id='topic+print.summary_bru'></span>

<h3>Description</h3>

<p>Takes a fitted <code>bru</code> object produced by <code><a href="#topic+bru">bru()</a></code> or <code><a href="#topic+lgcp">lgcp()</a></code> and creates
various summaries from it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bru'
summary(object, verbose = FALSE, ...)

## S3 method for class 'summary_bru'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.bru_+3A_object">object</code></td>
<td>
<p>An object obtained from a <code><a href="#topic+bru">bru()</a></code> or <code><a href="#topic+lgcp">lgcp()</a></code> call</p>
</td></tr>
<tr><td><code id="summary.bru_+3A_verbose">verbose</code></td>
<td>
<p>logical; If <code>TRUE</code>, include more details of the
component definitions. If <code>FALSE</code>, only show basic component
definition information. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="summary.bru_+3A_...">...</code></td>
<td>
<p>arguments passed on to component summary functions, see
<code><a href="#topic+summary.component">summary.component()</a></code>.</p>
</td></tr>
<tr><td><code id="summary.bru_+3A_x">x</code></td>
<td>
<p>A <code>summary_bru</code> object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
if (bru_safe_inla(multicore = FALSE)) {

  # Simulate some covariates x and observations y
  input.df &lt;- data.frame(x = cos(1:10))
  input.df &lt;- within(input.df, y &lt;- 5 + 2 * x + rnorm(10, mean = 0, sd = 0.1))

  # Fit a Gaussian likelihood model
  fit &lt;- bru(y ~ x + Intercept, family = "gaussian", data = input.df)

  # Obtain summary
  fit$summary.fixed
}


if (bru_safe_inla(multicore = FALSE)) {

  # Alternatively, we can use the like() function to construct the likelihood:

  lik &lt;- like(family = "gaussian", formula = y ~ x + Intercept, data = input.df)
  fit &lt;- bru(~ x + Intercept(1), lik)
  fit$summary.fixed
}

# An important addition to the INLA methodology is bru's ability to use
# non-linear predictors. Such a predictor can be formulated via like()'s
# \code{formula} parameter. The z(1) notation is needed to ensure that
# the z component should be interpreted as single latent variable and not
# a covariate:

if (bru_safe_inla(multicore = FALSE)) {
  z &lt;- 2
  input.df &lt;- within(input.df, y &lt;- 5 + exp(z) * x + rnorm(10, mean = 0, sd = 0.1))
  lik &lt;- like(
    family = "gaussian", data = input.df,
    formula = y ~ exp(z) * x + Intercept
  )
  fit &lt;- bru(~ z(1) + Intercept(1), lik)

  # Check the result (z posterior should be around 2)
  fit$summary.fixed
}

</code></pre>

<hr>
<h2 id='summary.bru_info'>Methods for bru_info objects</h2><span id='topic+summary.bru_info'></span><span id='topic+print.summary_bru_info'></span><span id='topic+bru_info'></span><span id='topic+bru_info.character'></span><span id='topic+bru_info.bru'></span>

<h3>Description</h3>

<p>Methods for bru_info objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bru_info'
summary(object, verbose = TRUE, ...)

## S3 method for class 'summary_bru_info'
print(x, ...)

bru_info(...)

## S3 method for class 'character'
bru_info(method, ..., inlabru_version = NULL, INLA_version = NULL)

## S3 method for class 'bru'
bru_info(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.bru_info_+3A_object">object</code></td>
<td>
<p>Object to operate on</p>
</td></tr>
<tr><td><code id="summary.bru_info_+3A_verbose">verbose</code></td>
<td>
<p>logical; If <code>TRUE</code>, include more details of the
component definitions. If <code>FALSE</code>, only show basic component
definition information. Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="summary.bru_info_+3A_...">...</code></td>
<td>
<p>Arguments passed on to other methods</p>
</td></tr>
<tr><td><code id="summary.bru_info_+3A_x">x</code></td>
<td>
<p>A <code>summary_bru_info</code> object to be printed</p>
</td></tr>
<tr><td><code id="summary.bru_info_+3A_method">method</code></td>
<td>
<p>character; The type of estimation method used</p>
</td></tr>
<tr><td><code id="summary.bru_info_+3A_inlabru_version">inlabru_version</code></td>
<td>
<p>character; inlabru package version. Default: NULL, for
automatically detecting the version</p>
</td></tr>
<tr><td><code id="summary.bru_info_+3A_inla_version">INLA_version</code></td>
<td>
<p>character; INLA package version. Default: NULL, for
automatically detecting the version</p>
</td></tr>
</table>

<hr>
<h2 id='summary.bru_mapper'>mapper object summaries</h2><span id='topic+summary.bru_mapper'></span><span id='topic+summary.bru_mapper_multi'></span><span id='topic+summary.bru_mapper_pipe'></span><span id='topic+summary.bru_mapper_collect'></span><span id='topic+print.summary_bru_mapper'></span><span id='topic+print.bru_mapper'></span>

<h3>Description</h3>

<p>mapper object summaries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bru_mapper'
summary(object, ..., prefix = "", initial = prefix, depth = 1)

## S3 method for class 'bru_mapper_multi'
summary(object, ..., prefix = "", initial = prefix, depth = 1)

## S3 method for class 'bru_mapper_pipe'
summary(object, ..., prefix = "", initial = prefix, depth = 1)

## S3 method for class 'bru_mapper_collect'
summary(object, ..., prefix = "", initial = prefix, depth = 1)

## S3 method for class 'summary_bru_mapper'
print(x, ...)

## S3 method for class 'bru_mapper'
print(x, ..., prefix = "", initial = prefix, depth = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.bru_mapper_+3A_object">object</code></td>
<td>
<p><code>bru_mapper</code> object to summarise</p>
</td></tr>
<tr><td><code id="summary.bru_mapper_+3A_...">...</code></td>
<td>
<p>Unused arguments</p>
</td></tr>
<tr><td><code id="summary.bru_mapper_+3A_prefix">prefix</code></td>
<td>
<p>character prefix for each line. Default <code>""</code>.</p>
</td></tr>
<tr><td><code id="summary.bru_mapper_+3A_initial">initial</code></td>
<td>
<p>character prefix for the first line. Default <code>initial=prefix</code>.</p>
</td></tr>
<tr><td><code id="summary.bru_mapper_+3A_depth">depth</code></td>
<td>
<p>The recursion depth for multi/collection/pipe mappers.
Default 1, to only show the collection, and not the contents of the sub-mappers.</p>
</td></tr>
<tr><td><code id="summary.bru_mapper_+3A_x">x</code></td>
<td>
<p>Object to be printed</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>mapper &lt;-
  bru_mapper_pipe(
    list(
      bru_mapper_multi(list(
        A = bru_mapper_index(2),
        B = bru_mapper_index(3)
      )),
      bru_mapper_index(2)
    )
  )
summary(mapper, depth = 2)
</code></pre>

<hr>
<h2 id='summary.bru_options'>Print inlabru options</h2><span id='topic+summary.bru_options'></span><span id='topic+print.summary_bru_options'></span>

<h3>Description</h3>

<p>Print inlabru options
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bru_options'
summary(
  object,
  legend = TRUE,
  include_global = TRUE,
  include_default = TRUE,
  ...
)

## S3 method for class 'summary_bru_options'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.bru_options_+3A_object">object</code></td>
<td>
<p>A <a href="#topic+bru_options">bru_options</a> object to be summarised</p>
</td></tr>
<tr><td><code id="summary.bru_options_+3A_legend">legend</code></td>
<td>
<p>logical; If <code>TRUE</code>, include explanatory text, Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="summary.bru_options_+3A_include_global">include_global</code></td>
<td>
<p>logical; If <code>TRUE</code>, include global override options</p>
</td></tr>
<tr><td><code id="summary.bru_options_+3A_include_default">include_default</code></td>
<td>
<p>logical; If <code>TRUE</code>, include default options</p>
</td></tr>
<tr><td><code id="summary.bru_options_+3A_...">...</code></td>
<td>
<p>Further parameters, currently ignored</p>
</td></tr>
<tr><td><code id="summary.bru_options_+3A_x">x</code></td>
<td>
<p>A <code>summary_bru_options</code> object to be printed</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
  options &lt;- bru_options(verbose = TRUE)

  # Don't print options only set in default:
  print(options, include_default = FALSE)

  # Only include options set in the object:
  print(options, include_default = FALSE, include_global = FALSE)
}
</code></pre>

<hr>
<h2 id='summary.component'>Summarise components</h2><span id='topic+summary.component'></span><span id='topic+summary.component_list'></span><span id='topic+print.summary_component'></span><span id='topic+print.summary_component_list'></span>

<h3>Description</h3>

<p>Summarise components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'component'
summary(object, ..., depth = Inf, verbose = TRUE)

## S3 method for class 'component_list'
summary(object, verbose = TRUE, ...)

## S3 method for class 'summary_component'
print(x, ...)

## S3 method for class 'summary_component_list'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.component_+3A_object">object</code></td>
<td>
<p>A <code>component</code> or <code>component_list</code>.</p>
</td></tr>
<tr><td><code id="summary.component_+3A_...">...</code></td>
<td>
<p>passed on to other summary methods</p>
</td></tr>
<tr><td><code id="summary.component_+3A_depth">depth</code></td>
<td>
<p>The depth of which to expand the component mapper.
Default <code>Inf</code>, to traverse the entire mapper tree.</p>
</td></tr>
<tr><td><code id="summary.component_+3A_verbose">verbose</code></td>
<td>
<p>logical; If <code>TRUE</code>, includes more details of the
component definitions. When <code>FALSE</code>, only show basic component
definition information.  Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="summary.component_+3A_x">x</code></td>
<td>
<p>A summary object to be printed.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Fabian E. Bachl <a href="mailto:bachlfab@gmail.com">bachlfab@gmail.com</a>
</p>
<p>Finn Lindgren <a href="mailto:finn.lindgren@gmail.com">finn.lindgren@gmail.com</a>
</p>

<hr>
<h2 id='toygroups'>Simulated 1D animal group locations and group sizes</h2><span id='topic+toygroups'></span>

<h3>Description</h3>

<p>This data set serves to teach the concept of modelling species that gather in groups and where
the grouping behaviour depends on space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(toygroups)
</code></pre>


<h3>Format</h3>

<p>The data are a list that contains these elements:
</p>

<dl>
<dt><code>groups</code>:</dt><dd><p> A <code>data.frame</code> of group locations <code>x</code> and size <code>size</code></p>
</dd>
<dt><code>df.size</code>:</dt><dd><p> IGNORE THIS </p>
</dd>
<dt><code>df.intensity</code>:</dt><dd><p> A <code>data.frame</code> with Poisson process
intensity <code>d.lambda</code> at locations <code>x</code></p>
</dd>
<dt><code>df.rate</code>:</dt><dd><p> A <code>data.frame</code> the locations <code>x</code> and associated <code>rate</code> which
parameterized the exponential distribution from which the group sizes were drawn.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
if (require(ggplot2, quietly = TRUE)) {
  # Load the data

  data("toygroups", package = "inlabru")

  # The data set is a simulation of animal groups residing in a 1D space. Their
  # locations in x-space are sampled from a Cox process with intensity

  ggplot(toygroups$df.intensity) +
    geom_line(aes(x = x, y = g.lambda))

  # Adding the simulated group locations to this plot we obtain

  ggplot(toygroups$df.intensity) +
    geom_line(aes(x = x, y = g.lambda)) +
    geom_point(data = toygroups$groups, aes(x, y = 0), pch = "|")

  # Each group has a size mark attached to it.
  # These group sizes are sampled from an exponential distribution
  # for which the rate parameter depends on the x-coordinate

  ggplot(toygroups$groups) +
    geom_point(aes(x = x, y = size))

  ggplot(toygroups$df.rate) +
    geom_line(aes(x, rate))
}

</code></pre>

<hr>
<h2 id='toypoints'>Simulated 2D point process data</h2><span id='topic+toypoints'></span>

<h3>Description</h3>

<p>This data set serves as an example for basic inlabru.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(toypoints)
</code></pre>


<h3>Format</h3>

<p>The data are a list that contains these elements:
</p>

<dl>
<dt><code>points</code></dt><dd><p>An <code>sf</code> object of point locations and and <code>z</code> measurements</p>
</dd>
<dt><code>mesh</code></dt><dd><p>An <code>fm_mesh_2d</code> object</p>
</dd>
<dt><code>boundary</code></dt><dd><p>An <code>sf</code> polygon denting the region of interest</p>
</dd>
<dt><code>pred_locs</code></dt><dd><p>A <code>sf</code> object with prediction point locations</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>if (require("ggplot2")) {
  ggplot() +
    fmesher::geom_fm(data = toypoints$mesh, alpha = 0) +
    geom_sf(data = toypoints$boundary, fill = "blue", alpha = 0.1) +
    geom_sf(data = toypoints$points, aes(color = z)) +
    scale_color_viridis_c()
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
