<!DOCTYPE html><html lang="es"><head><title>Help for package rmoo</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rmoo}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rmoo-package'><p>rmoo: Multi-Objective Optimization in R</p></a></li>
<li><a href='#algorithm-class'><p>Virtual Parent Class Algorithm</p></a></li>
<li><a href='#associate'><p>Association Operation in Non-Dominated Genetic Algorithms III</p></a></li>
<li><a href='#crowding_distance'><p>Calculation of Crowding Distance</p></a></li>
<li><a href='#generate_reference_points'><p>Determination of Reference Points on a Hyper-Plane</p></a></li>
<li><a href='#get_fixed_rowsum_integer_matrix'><p>Determine the division points on the hyperplane</p></a></li>
<li><a href='#getCrowdingDistance'><p>Accessor methods to the crowding distance for NSGA-II results</p></a></li>
<li><a href='#getDummyFitness'><p>Accessor methods to the dummy fitness for NSGA-I results</p></a></li>
<li><a href='#getFitness'><p>Accessor methods to the fitness for rmoo results</p></a></li>
<li><a href='#getMetrics'><p>Accessor methods to the metrics evaluated during execution</p></a></li>
<li><a href='#getPopulation'><p>Accessor methods to the population for rmoo results</p></a></li>
<li><a href='#kroA100'><p>KROA100</p></a></li>
<li><a href='#kroB100'><p>KROB100</p></a></li>
<li><a href='#kroC100'><p>KROC100</p></a></li>
<li><a href='#niching'><p>Niche-Preservation Operation</p></a></li>
<li><a href='#non_dominated_fronts'><p>Calculate of Non-Dominated Front</p></a></li>
<li><a href='#nsga'><p>Non-Dominated Sorting in Genetic Algorithms</p></a></li>
<li><a href='#nsga_Crossover'><p>Crossover operators in non-dominated genetic algorithms</p></a></li>
<li><a href='#nsga_Mutation'><p>Mutation operators in non-dominated genetic algorithms</p></a></li>
<li><a href='#nsga_Population'><p>Population initialization in non-dominated genetic algorithms</p></a></li>
<li><a href='#nsga_Selection'><p>Selection operators in non-dominated genetic algorithms</p></a></li>
<li><a href='#nsga-class'><p>Virtual Class 'nsga'</p></a></li>
<li><a href='#nsga1-class'><p>Class 'nsga1'</p></a></li>
<li><a href='#nsga2'><p>Non-Dominated Sorting in Genetic Algorithms II</p></a></li>
<li><a href='#nsga2-class'><p>Class 'nsga2'</p></a></li>
<li><a href='#nsga3'><p>Non-Dominated Sorting in Genetic Algorithms III</p></a></li>
<li><a href='#nsga3-class'><p>Class 'nsga3'</p></a></li>
<li><a href='#nsgaControl'><p>A function for setting or retrieving defaults non-dominated genetic operators</p></a></li>
<li><a href='#nsgaMonitor'><p>Monitor non-dominated genetic algorithm evolution</p></a></li>
<li><a href='#numberOrNAOrMatrix-class'><p>Virtual Class 'numberOrNAOrMatrix - Simple Class for subassigment Values'</p></a></li>
<li><a href='#performance_metrics'><p>Objective Values performance metrics</p></a></li>
<li><a href='#plot'><p>Methods for Function 'plot' in Package 'rmoo'</p></a></li>
<li><a href='#print'><p>Methods for Function 'print' in Package 'rmoo'.</p></a></li>
<li><a href='#progress'><p>Methods for Function 'progress' in Package 'rmoo'</p></a></li>
<li><a href='#reference_point_multi_layer'><p>Determination of Multi-layer Reference Points</p></a></li>
<li><a href='#rmoo_func'><p>R Multi-Objective Optimization Main Function</p></a></li>
<li><a href='#scale_reference_directions'><p>Scale Reference Points</p></a></li>
<li><a href='#sharing'><p>Calculation of Dummy Fitness</p></a></li>
<li><a href='#summary'><p>Methods for Function 'summary' in Package 'rmoo'</p></a></li>
<li><a href='#update_points'><p>Adaptive normalization of population members</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Multi-Objective Optimization in R</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>The 'rmoo' package is a framework for multi- and many-objective
        optimization, which allows researchers and users versatility
        in parameter configuration, as well as tools for analysis, replication
        and visualization of results. The 'rmoo' package was built as a fork of
        the 'GA' package by Luca Scrucca(2017) &lt;<a href="https://doi.org/10.32614%2FRJ-2017-008">doi:10.32614/RJ-2017-008</a>&gt; and
        implementing the Non-Dominated Sorting Genetic Algorithms proposed
        by K. Deb's.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>es</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Collate:</td>
<td>'AllClasses.R' 'associate.R' 'crowding_distance.R' 'data.R'
'generate_reference_points.R' 'geneticoperator.R'
'get_fixed_rowsum_integer_matrix.R' 'miscfun.R' 'AllGenerics.R'
'niching.R' 'non_dominated_fronts.R' 'nsga.R' 'nsga2.R'
'nsga3.R' 'nsgaControl.R' 'performance_metrics.R'
'reference_point_multi_layer.R' 'rmoo.R' 'rmoo_func.R'
'sharing.R' 'update_points.R' 'zzz.R'</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, graphics, methods, GA, grDevices, ggplot2,
plotly</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Evolutionary-Optimization-Laboratory/rmoo/">https://github.com/Evolutionary-Optimization-Laboratory/rmoo/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Evolutionary-Optimization-Laboratory/rmoo/issues/">https://github.com/Evolutionary-Optimization-Laboratory/rmoo/issues/</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, covr, rgl, ecr, emoa, cdata, dplyr, reshape2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-24 01:14:40 UTC; Maria</td>
</tr>
<tr>
<td>Author:</td>
<td>Francisco Benitez [aut, cre],
  Diego Pinto Roa <a href="https://orcid.org/0000-0003-2479-9876"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Francisco Benitez &lt;benitezfj94@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-24 02:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='rmoo-package'>rmoo: Multi-Objective Optimization in R</h2><span id='topic+rmoo-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>The 'rmoo' package is a framework for multi- and many-objective optimization, which allows researchers and users versatility in parameter configuration, as well as tools for analysis, replication and visualization of results. The 'rmoo' package was built as a fork of the 'GA' package by Luca Scrucca(2017) <a href="https://doi.org/10.32614/RJ-2017-008">doi:10.32614/RJ-2017-008</a> and implementing the Non-Dominated Sorting Genetic Algorithms proposed by K. Deb's.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Francisco Benitez <a href="mailto:benitezfj94@gmail.com">benitezfj94@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Diego Pinto Roa <a href="mailto:dpinto@pol.una.py">dpinto@pol.una.py</a> (<a href="https://orcid.org/0000-0003-2479-9876">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/Evolutionary-Optimization-Laboratory/rmoo/">https://github.com/Evolutionary-Optimization-Laboratory/rmoo/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/Evolutionary-Optimization-Laboratory/rmoo/issues/">https://github.com/Evolutionary-Optimization-Laboratory/rmoo/issues/</a>
</p>
</li></ul>


<hr>
<h2 id='algorithm-class'>Virtual Parent Class Algorithm</h2><span id='topic+algorithm-class'></span>

<h3>Description</h3>

<p>It will use when other algorithms are implemented. Equivalent to a Abstract
class in other languages.
</p>

<hr>
<h2 id='associate'>Association Operation in Non-Dominated Genetic Algorithms III</h2><span id='topic+associate'></span><span id='topic+associate_to_niches'></span><span id='topic+compute_perpendicular_distance'></span><span id='topic+compute_niche_count'></span>

<h3>Description</h3>

<p>Function that associates each member of the population with a reference point. The function calculates the perpendicular distance of each individual from each of the reference lines. This code section corresponds to Algorithm 3 of the referenced paper.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  associate_to_niches(object, utopian_epsilon = 0)
  compute_perpendicular_distance(x, y)
  compute_niche_count(n_niches, niche_of_individuals)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="associate_+3A_object">object</code></td>
<td>
<p>An object of class <code>"nsga3"</code>.</p>
</td></tr>
<tr><td><code id="associate_+3A_utopian_epsilon">utopian_epsilon</code></td>
<td>
<p>The epsilon used for decrease the ideal point to get the utopian point.</p>
</td></tr>
<tr><td><code id="associate_+3A_x">x</code></td>
<td>
<p>Individuals to calculate their niche.</p>
</td></tr>
<tr><td><code id="associate_+3A_y">y</code></td>
<td>
<p>Reference points.</p>
</td></tr>
<tr><td><code id="associate_+3A_n_niches">n_niches</code></td>
<td>
<p>Number of reference points.</p>
</td></tr>
<tr><td><code id="associate_+3A_niche_of_individuals">niche_of_individuals</code></td>
<td>
<p>The niche count of individuals, except the last front.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the niche count of individuals and the distances between them.</p>


<h3>Author(s)</h3>

<p>Francisco Benitez</p>


<h3>References</h3>

<p>J. Blank and K. Deb, &quot;Pymoo: Multi-Objective Optimization in Python,&quot; in IEEE Access, vol. 8, pp. 89497-89509, 2020, doi: 10.1109/ACCESS.2020.2990567.
</p>
<p>K. Deb and H. Jain, &quot;An Evolutionary Many-Objective Optimization Algorithm Using Reference-Point-Based Nondominated Sorting Approach, Part I: Solving Problems With Box Constraints,&quot; in IEEE Transactions on Evolutionary Computation, vol. 18, no. 4, pp. 577-601, Aug. 2014, doi: 10.1109/TEVC.2013.2281535.
</p>

<hr>
<h2 id='crowding_distance'>Calculation of Crowding Distance</h2><span id='topic+crowding_distance'></span>

<h3>Description</h3>

<p>A Crowded-comparison approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crowding_distance(object, nObj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crowding_distance_+3A_object">object</code>, <code id="crowding_distance_+3A_nobj">nObj</code></td>
<td>
<p>An object of class 'nsga2', usually resulting from a call
to function nsga2. Fitness Function Objective Numbers</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The crowded-comparison operator guides the selection process at the various
stages of the algorithm toward a uniformly spread-out Pareto-optimal front
</p>


<h3>Value</h3>

<p>A vector with the crowding-distance between individuals of a population.
</p>


<h3>Author(s)</h3>

<p>Francisco Benitez
<a href="mailto:benitezfj94@gmail.com">benitezfj94@gmail.com</a>
</p>


<h3>References</h3>

<p>K. Deb, A. Pratap, S. Agarwal and T. Meyarivan, 'A fast and
elitist multiobjective genetic algorithm: NSGA-II,' in IEEE Transactions on
Evolutionary Computation, vol. 6, no. 2, pp. 182-197, April 2002,
doi: 10.1109/4235.996017.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+non_dominated_fronts">non_dominated_fronts()</a></code>
</p>

<hr>
<h2 id='generate_reference_points'>Determination of Reference Points on a Hyper-Plane</h2><span id='topic+generate_reference_points'></span>

<h3>Description</h3>

<p>A implementation of Das and Dennis's Reference Points Generation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_reference_points(m, h, scaling = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_reference_points_+3A_m">m</code>, <code id="generate_reference_points_+3A_h">h</code>, <code id="generate_reference_points_+3A_scaling">scaling</code></td>
<td>
<p>Number of reference points 'h' in M-objective problems, and
scaling that is the scale on which the points are distributed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implemented Reference Point Generation is based on the Das and Dennis's
systematic approach that places points on a normalized hyper-plane which is
equally inclined to all objective axes and has an intercept of one on each axis.
</p>


<h3>Value</h3>

<p>A matrix with the reference points uniformly distributed.
</p>


<h3>Author(s)</h3>

<p>Francisco Benitez
<a href="mailto:benitezfj94@gmail.com">benitezfj94@gmail.com</a>
</p>


<h3>References</h3>

<p>K. Deb and H. Jain, 'An Evolutionary Many-Objective Optimization
Algorithm Using Reference-Point-Based Nondominated Sorting Approach, Part I:
Solving Problems With Box Constraints,' in IEEE Transactions on Evolutionary
Computation, vol. 18, no. 4, pp. 577-601, Aug. 2014,
doi: 10.1109/TEVC.2013.2281535.
</p>
<p>Das, Indraneel &amp; Dennis, J. (2000). Normal-Boundary Intersection: A New
Method for Generating the Pareto Surface in Nonlinear Multicriteria
Optimization Problems. SIAM Journal on Optimization. 8.
10.1137/S1052623496307510.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+non_dominated_fronts">non_dominated_fronts()</a></code> and <code><a href="#topic+get_fixed_rowsum_integer_matrix">get_fixed_rowsum_integer_matrix()</a></code>
</p>

<hr>
<h2 id='get_fixed_rowsum_integer_matrix'>Determine the division points on the hyperplane</h2><span id='topic+get_fixed_rowsum_integer_matrix'></span>

<h3>Description</h3>

<p>Implementation of the recursive function in Generation of Reference points of
Das and Dennis..
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_fixed_rowsum_integer_matrix(m, h)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_fixed_rowsum_integer_matrix_+3A_m">m</code>, <code id="get_fixed_rowsum_integer_matrix_+3A_h">h</code></td>
<td>
<p>Number of reference points 'h' in M-objective problems</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implemented Reference Point Generation is based on the Das and Dennis's
systematic approach that places points on a normalized hyper-plane which is
equally inclined to all objective axes and has an intercept of one on each
axis.
</p>


<h3>Value</h3>

<p>A matrix with the reference points uniformly distributed.
</p>


<h3>Author(s)</h3>

<p>Francisco Benitez
<a href="mailto:benitezfj94@gmail.com">benitezfj94@gmail.com</a>
</p>


<h3>References</h3>

<p>K. Deb and H. Jain, 'An Evolutionary Many-Objective Optimization
Algorithm Using Reference-Point-Based Nondominated Sorting Approach, Part I:
Solving Problems With Box Constraints,' in IEEE Transactions on Evolutionary
Computation, vol. 18, no. 4, pp. 577-601, Aug. 2014,
doi: 10.1109/TEVC.2013.2281535.
</p>
<p>Das, Indraneel &amp; Dennis, J.. (2000). Normal-Boundary Intersection: A New
Method for Generating the Pareto Surface in Nonlinear Multicriteria
Optimization Problems. SIAM Journal on Optimization. 8.
10.1137/S1052623496307510.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+non_dominated_fronts">non_dominated_fronts()</a></code> and <code><a href="#topic+generate_reference_points">generate_reference_points()</a></code>
</p>

<hr>
<h2 id='getCrowdingDistance'>Accessor methods to the crowding distance for NSGA-II results</h2><span id='topic+getCrowdingDistance'></span><span id='topic+getCrowdingDistance+2Cnsga2-method'></span>

<h3>Description</h3>

<p>Accessor methods to the crowding distance for NSGA-II results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCrowdingDistance(obj)

## S4 method for signature 'nsga2'
getCrowdingDistance(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getCrowdingDistance_+3A_obj">obj</code></td>
<td>
<p>an object resulting from the execution of NSGA-II algorithm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector with the crowding distances of class nsga2. See <a href="#topic+nsga2-class">nsga2</a>
for a description of available slots information.
</p>


<h3>Author(s)</h3>

<p>Francisco Benitez
<a href="mailto:benitezfj94@gmail.com">benitezfj94@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Where 'out' is an object resulting from the execution of the NSGA-II algorithm.
#
# getCrowdingDistance(out)
#

</code></pre>

<hr>
<h2 id='getDummyFitness'>Accessor methods to the dummy fitness for NSGA-I results</h2><span id='topic+getDummyFitness'></span><span id='topic+getDummyFitness+2Cnsga1-method'></span>

<h3>Description</h3>

<p>Accessor methods to the dummy fitness for NSGA-I results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDummyFitness(obj)

## S4 method for signature 'nsga1'
getDummyFitness(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getDummyFitness_+3A_obj">obj</code></td>
<td>
<p>an object resulting from the execution of NSGA-I algorithm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix with the dummy fitness of class nsga1. See <a href="#topic+nsga1-class">nsga1</a>
for a description of available slots information.
</p>


<h3>Author(s)</h3>

<p>Francisco Benitez
<a href="mailto:benitezfj94@gmail.com">benitezfj94@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Where 'out' is an object resulting from the execution of the NSGA-I algorithm.
#
# getDummyFitness(out)
#

</code></pre>

<hr>
<h2 id='getFitness'>Accessor methods to the fitness for rmoo results</h2><span id='topic+getFitness'></span>

<h3>Description</h3>

<p>Accessor methods to the fitness for rmoo results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFitness(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getFitness_+3A_obj">obj</code></td>
<td>
<p>an object resulting from the execution of NSGA-I, NSGA-II or NSGA-III
algorithm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints the resulting fitness and when the result of the method-call
is assigned to a variable, the fitness is stored as a data frame.
See <a href="#topic+nsga1-class">nsga1</a> <a href="#topic+nsga2-class">nsga2</a>, <a href="#topic+nsga3-class">nsga3</a> for a description of available
slots information.
</p>


<h3>Author(s)</h3>

<p>Francisco Benitez
<a href="mailto:benitezfj94@gmail.com">benitezfj94@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Where 'out' is an object resulting from the execution of the rmoo.
#
# fitness_result &lt;- getFitness(out)
#
# fitness_result

</code></pre>

<hr>
<h2 id='getMetrics'>Accessor methods to the metrics evaluated during execution</h2><span id='topic+getMetrics'></span><span id='topic+getMetrics+2Cnsga-method'></span><span id='topic+getMetrics+2Cnsga+2Cnsga-method'></span>

<h3>Description</h3>

<p>Accessor methods to the metrics evaluated during execution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMetrics(obj)

## S4 method for signature 'nsga'
getMetrics(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getMetrics_+3A_obj">obj</code></td>
<td>
<p>an object resulting from the execution of NSGA-I, NSGA-II or NSGA-III
algorithm. During the execution of the performance metrics must be evaluated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with performance metrics evaluated iteration by iteration.
</p>


<h3>Author(s)</h3>

<p>Francisco Benitez
<a href="mailto:benitezfj94@gmail.com">benitezfj94@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Where 'out' is an object resulting from the execution of the rmoo.
#
# metrics_result &lt;- getMetrics(out)
#
# metrics_result

</code></pre>

<hr>
<h2 id='getPopulation'>Accessor methods to the population for rmoo results</h2><span id='topic+getPopulation'></span><span id='topic+getPopulation+2Cnsga-method'></span><span id='topic+getPopulation+2Cnsga+2Cnsga-method'></span><span id='topic+getFitness+2Cnsga-method'></span><span id='topic+getFitness+2Cnsga+2Cnsga-method'></span>

<h3>Description</h3>

<p>Accessor methods to the population for rmoo results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getPopulation(obj)

## S4 method for signature 'nsga'
getPopulation(obj)

## S4 method for signature 'nsga'
getFitness(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getPopulation_+3A_obj">obj</code></td>
<td>
<p>an object resulting from the execution of NSGA-I, NSGA-II or NSGA-III
algorithm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints the resulting population and when the result of the method-call
is assigned to a variable, the population is stored as a data frame.
See <a href="#topic+nsga1-class">nsga1</a> <a href="#topic+nsga2-class">nsga2</a>, <a href="#topic+nsga3-class">nsga3</a> for a description of available
slots information.
</p>


<h3>Author(s)</h3>

<p>Francisco Benitez
<a href="mailto:benitezfj94@gmail.com">benitezfj94@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Where 'out' is an object resulting from the execution of rmoo.
#
# population_result &lt;- getPopulation(out)
#
# population_result

</code></pre>

<hr>
<h2 id='kroA100'>KROA100</h2><span id='topic+kroA100'></span>

<h3>Description</h3>

<p>A dataset containing the coord and section of 100 cities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kroA100
</code></pre>


<h3>Format</h3>

<p>A data frame with 100 rows and 2 variables:
</p>

<dl>
<dt>COORD</dt><dd><p>City Coordinates</p>
</dd>
<dt>SECTION</dt><dd><p>City Section</p>
</dd>
</dl>



<h3>References</h3>

<p>Reinelt, G. (1991). TSPLIB—A traveling salesman problem library.
ORSA journal on computing, 3(4), 376-384
</p>

<hr>
<h2 id='kroB100'>KROB100</h2><span id='topic+kroB100'></span>

<h3>Description</h3>

<p>A dataset containing the coord and section of 100 cities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kroB100
</code></pre>


<h3>Format</h3>

<p>A data frame with 100 rows and 2 variables:
</p>

<dl>
<dt>COORD</dt><dd><p>City Coordinates</p>
</dd>
<dt>SECTION</dt><dd><p>City Section</p>
</dd>
</dl>



<h3>References</h3>

<p>Reinelt, G. (1991). TSPLIB—A traveling salesman problem library.
ORSA journal on computing, 3(4), 376-384
</p>

<hr>
<h2 id='kroC100'>KROC100</h2><span id='topic+kroC100'></span>

<h3>Description</h3>

<p>A dataset containing the coord and section of 100 cities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kroC100
</code></pre>


<h3>Format</h3>

<p>A data frame with 100 rows and 2 variables:
</p>

<dl>
<dt>COORD</dt><dd><p>City Coordinates</p>
</dd>
<dt>SECTION</dt><dd><p>City Section</p>
</dd>
</dl>



<h3>References</h3>

<p>Reinelt, G. (1991). TSPLIB—A traveling salesman problem library.
ORSA journal on computing, 3(4), 376-384
</p>

<hr>
<h2 id='niching'>Niche-Preservation Operation</h2><span id='topic+niching'></span>

<h3>Description</h3>

<p>Generation of niche, by associating reference points to population members
</p>


<h3>Usage</h3>

<pre><code class='language-R'>niching(pop, n_remaining, niche_count, niche_of_individuals, dist_to_niche)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="niching_+3A_pop">pop</code></td>
<td>
<p>Last Front Population</p>
</td></tr>
<tr><td><code id="niching_+3A_n_remaining">n_remaining</code></td>
<td>
<p>Number of points to choose</p>
</td></tr>
<tr><td><code id="niching_+3A_niche_count">niche_count</code></td>
<td>
<p>Niche count of individuals with the reference point</p>
</td></tr>
<tr><td><code id="niching_+3A_niche_of_individuals">niche_of_individuals</code></td>
<td>
<p>Count of the closest reference point to the last
front objective values</p>
</td></tr>
<tr><td><code id="niching_+3A_dist_to_niche">dist_to_niche</code></td>
<td>
<p>Distance between closest reference point to last front
objective values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Niching procesure is a algorithms proposed by K. Deb and H. Jain in 2013.
</p>


<h3>Value</h3>

<p>Returns the association of reference points to each individual in the population.
</p>


<h3>Author(s)</h3>

<p>Francisco Benitez
<a href="mailto:benitezfj94@gmail.com">benitezfj94@gmail.com</a>
</p>


<h3>References</h3>

<p>K. Deb and H. Jain, 'An Evolutionary Many-Objective Optimization
Algorithm Using Reference-Point-Based Nondominated Sorting Approach, Part I:
Solving Problems With Box Constraints,' in IEEE Transactions on Evolutionary
Computation, vol. 18, no. 4, pp. 577-601, Aug. 2014,
doi: 10.1109/TEVC.2013.2281535.
</p>
<p>Scrucca, L. (2017) On some extensions to 'GA' package: hybrid optimisation,
parallelisation and islands evolution. The R Journal, 9/1, 187-206.
doi: 10.32614/RJ-2017-008
</p>
<p>Felix-Antoine Fortin, Francois-Michel De Rainville, Marc-André Gardner
Gardner, Marc Parizeau, and Christian Gagne. 2012. DEAP: evolutionary
algorithms made easy. J. Mach. Learn. Res. 13, 1 (January 2012), 2171–2175.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+associate_to_niches">associate_to_niches()</a></code>, <code><a href="#topic+PerformScalarizing">PerformScalarizing()</a></code>
</p>

<hr>
<h2 id='non_dominated_fronts'>Calculate of Non-Dominated Front</h2><span id='topic+non_dominated_fronts'></span>

<h3>Description</h3>

<p>A fast approach for calculate Non-Dominated Fronts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>non_dominated_fronts(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="non_dominated_fronts_+3A_object">object</code></td>
<td>
<p>An object of class 'nsga', usually resulting from a call to
function nsga, nsga2 and nsga3.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function to determine the non-dominated fronts of a population and the
aptitude value.
</p>


<h3>Value</h3>

<p>A list with 'non-dominated fronts' and 'occupied positions' on the fronts.
</p>


<h3>Author(s)</h3>

<p>Francisco Benitez
<a href="mailto:benitezfj94@gmail.com">benitezfj94@gmail.com</a>
</p>


<h3>References</h3>

<p>K. Deb, A. Pratap, S. Agarwal and T. Meyarivan, 'A fast and
elitist multiobjective genetic algorithm: NSGA-II,' in IEEE Transactions on
Evolutionary Computation, vol. 6, no. 2, pp. 182-197, April 2002,
doi: 10.1109/4235.996017.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nsga">nsga()</a></code>, <code><a href="#topic+nsga2">nsga2()</a></code> and <code><a href="#topic+nsga3">nsga3()</a></code>
</p>

<hr>
<h2 id='nsga'>Non-Dominated Sorting in Genetic Algorithms</h2><span id='topic+nsga'></span>

<h3>Description</h3>

<p>Minimization of a fitness function using Non-Dominated Genetic algorithms
(NSGA). Local search using general-purpose optimisation algorithms can be
applied stochastically to exploit interesting regions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nsga(
  type = c("binary", "real-valued", "permutation"),
  fitness,
  ...,
  lower,
  upper,
  nBits,
  population = nsgaControl(type)$population,
  selection = nsgaControl(type)$selection,
  crossover = nsgaControl(type)$crossover,
  mutation = nsgaControl(type)$mutation,
  popSize = 50,
  nObj = ncol(fitness(matrix(10000, ncol = 100, nrow = 100))),
  dshare,
  pcrossover = 0.8,
  pmutation = 0.1,
  maxiter = 100,
  run = maxiter,
  maxFitness = Inf,
  names = NULL,
  suggestions = NULL,
  monitor = if (interactive()) nsgaMonitor else FALSE,
  summary = FALSE,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nsga_+3A_type">type</code></td>
<td>
<p>the type of genetic algorithm to be run depending on the nature
of decision variables. Possible values are:
</p>

<dl>
<dt><code>"binary"</code></dt><dd><p>for binary representations of decision variables.</p>
</dd>
<dt><code>"real-valued"</code></dt><dd><p>for optimization problems where the decision
variables are floating-point representations of real numbers.</p>
</dd>
<dt><code>"permutation"</code></dt><dd><p>for problems that involves reordering of a list
of objects.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="nsga_+3A_fitness">fitness</code></td>
<td>
<p>the fitness function, any allowable R function which takes as
input an individual string representing a potential solution, and returns a
numerical value describing its “fitness”.</p>
</td></tr>
<tr><td><code id="nsga_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitness function. This
allows to write fitness functions that keep some variables fixed during the
search.</p>
</td></tr>
<tr><td><code id="nsga_+3A_lower">lower</code></td>
<td>
<p>a vector of length equal to the decision variables providing the
lower bounds of the search space in case of real-valued or permutation
encoded optimizations.</p>
</td></tr>
<tr><td><code id="nsga_+3A_upper">upper</code></td>
<td>
<p>a vector of length equal to the decision variables providing the
upper bounds of the search space in case of real-valued or permutation
encoded optimizations.</p>
</td></tr>
<tr><td><code id="nsga_+3A_nbits">nBits</code></td>
<td>
<p>a value specifying the number of bits to be used in binary
encoded optimizations.</p>
</td></tr>
<tr><td><code id="nsga_+3A_population">population</code></td>
<td>
<p>an R function for randomly generating an initial population.
See <code><a href="#topic+nsga_Population">nsga_Population()</a></code> for available functions.</p>
</td></tr>
<tr><td><code id="nsga_+3A_selection">selection</code></td>
<td>
<p>an R function performing selection, i.e. a function which
generates a new population of individuals from the current population
probabilistically according to individual fitness.
See <code><a href="#topic+nsga_Selection">nsga_Selection()</a></code> for available functions.</p>
</td></tr>
<tr><td><code id="nsga_+3A_crossover">crossover</code></td>
<td>
<p>an R function performing crossover, i.e. a function which
forms offsprings by combining part of the genetic information from
their parents. See <code><a href="#topic+nsga_Crossover">nsga_Crossover()</a></code> for available functions.</p>
</td></tr>
<tr><td><code id="nsga_+3A_mutation">mutation</code></td>
<td>
<p>an R function performing mutation, i.e. a function which
randomly alters the values of some genes in a parent chromosome.
See <code><a href="#topic+nsga_Mutation">nsga_Mutation()</a></code> for available functions.</p>
</td></tr>
<tr><td><code id="nsga_+3A_popsize">popSize</code></td>
<td>
<p>the population size.</p>
</td></tr>
<tr><td><code id="nsga_+3A_nobj">nObj</code></td>
<td>
<p>number of objective in the fitness function.</p>
</td></tr>
<tr><td><code id="nsga_+3A_dshare">dshare</code></td>
<td>
<p>the maximun phenotypic distance allowed between any two
individuals to become members of a niche.</p>
</td></tr>
<tr><td><code id="nsga_+3A_pcrossover">pcrossover</code></td>
<td>
<p>the probability of crossover between pairs of chromosomes.
Typically this is a large value and by default is set to 0.8.</p>
</td></tr>
<tr><td><code id="nsga_+3A_pmutation">pmutation</code></td>
<td>
<p>the probability of mutation in a parent chromosome. Usually
mutation occurs with a small probability, and by default is set to 0.1.</p>
</td></tr>
<tr><td><code id="nsga_+3A_maxiter">maxiter</code></td>
<td>
<p>the maximum number of iterations to run before the NSGA search
is halted.</p>
</td></tr>
<tr><td><code id="nsga_+3A_run">run</code></td>
<td>
<p>the number of consecutive generations without any improvement in
the best fitness value before the NSGA is stopped.</p>
</td></tr>
<tr><td><code id="nsga_+3A_maxfitness">maxFitness</code></td>
<td>
<p>the upper bound on the fitness function after that the NSGA
search is interrupted.</p>
</td></tr>
<tr><td><code id="nsga_+3A_names">names</code></td>
<td>
<p>a vector of character strings providing the names of decision
variables.</p>
</td></tr>
<tr><td><code id="nsga_+3A_suggestions">suggestions</code></td>
<td>
<p>a matrix of solutions strings to be included in the
initial population. If provided the number of columns must match the number
of decision variables.</p>
</td></tr>
<tr><td><code id="nsga_+3A_monitor">monitor</code></td>
<td>
<p>a logical or an R function which takes as input the current
state of the nsga-class object and show the evolution of the search. By
default, for interactive sessions the function nsgaMonitor prints the average
and best fitness values at each iteration. If set to plot these information
are plotted on a graphical device. Other functions can be written by the user
and supplied as argument. In non interactive sessions, by default
monitor = FALSE so any output is suppressed.</p>
</td></tr>
<tr><td><code id="nsga_+3A_summary">summary</code></td>
<td>
<p>If there will be a summary generation after generation.</p>
</td></tr>
<tr><td><code id="nsga_+3A_seed">seed</code></td>
<td>
<p>an integer value containing the random number generator state.
This argument can be used to replicate the results of a NSGA search. Note
that if parallel computing is required, the doRNG package must be installed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Non-dominated genetic algorithms is a meta-heuristic proposed by
N. Srinivas and K. Deb in 1994. The purpose of the algorithms is to find an
efficient way to optimize multi-objectives functions (two or more).
</p>


<h3>Value</h3>

<p>Returns an object of class nsga1-class. See <a href="#topic+nsga1-class">nsga1</a> for a
description of available slots information.
</p>


<h3>Author(s)</h3>

<p>Francisco Benitez
<a href="mailto:benitezfj94@gmail.com">benitezfj94@gmail.com</a>
</p>


<h3>References</h3>

<p>N. Srinivas and K. Deb, &quot;Multiobjective Optimization Using
Nondominated Sorting in Genetic Algorithms, in Evolutionary Computation,
vol. 2, no. 3, pp. 221-248, Sept. 1994, doi: 10.1162/evco.1994.2.3.221.
</p>
<p>Scrucca, L. (2017) On some extensions to 'GA' package: hybrid optimisation,
parallelisation and islands evolution. The R Journal, 9/1, 187-206.
doi: 10.32614/RJ-2017-008
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nsga2">nsga2()</a></code>, <code><a href="#topic+nsga3">nsga3()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example
#Two Objectives - Real Valued
zdt1 &lt;- function (x) {
 if (is.null(dim(x))) {
   x &lt;- matrix(x, nrow = 1)
 }
 n &lt;- ncol(x)
 g &lt;- 1 + rowSums(x[, 2:n, drop = FALSE]) * 9/(n - 1)
 return(cbind(x[, 1], g * (1 - sqrt(x[, 1]/g))))
}

#Not run:
## Not run: 
result &lt;- nsga(type = "real-valued",
               fitness = zdt1,
               lower = c(0,0),
               upper = c(1,1),
               popSize = 100,
               dshare = 1,
               monitor = FALSE,
               maxiter = 500)

## End(Not run)

</code></pre>

<hr>
<h2 id='nsga_Crossover'>Crossover operators in non-dominated genetic algorithms</h2><span id='topic+nsga_Crossover'></span><span id='topic+nsga_spCrossover'></span><span id='topic+nsgabin_spCrossover'></span><span id='topic+nsgareal_spCrossover'></span><span id='topic+nsgareal_sbxCrossover'></span><span id='topic+nsgaperm_oxCrossover'></span>

<h3>Description</h3>

<p>Functions implementing crossover non-dominated genetic operator.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nsga_spCrossover(object, parents)

  nsgabin_spCrossover(object, parents)

  nsgareal_spCrossover(object, parents)
  nsgareal_sbxCrossover(object, parents, nc = 20)

  nsgaperm_oxCrossover(object, parents)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nsga_Crossover_+3A_object">object</code></td>
<td>
<p>An object of class <code>"nsga"</code>, <code>"nsga2"</code> and <code>"nsga3"</code>, usually resulting from a call to function <code><a href="#topic+nsga">nsga</a></code>, <code><a href="#topic+nsga2">nsga2</a></code> and <code><a href="#topic+nsga3">nsga3</a></code>.</p>
</td></tr>
<tr><td><code id="nsga_Crossover_+3A_parents">parents</code></td>
<td>
<p>A two-rows matrix of values indexing the parents from the current population.</p>
</td></tr>
<tr><td><code id="nsga_Crossover_+3A_nc">nc</code></td>
<td>
<p>Parameters of non-dominated genetic operators.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a list with two elements:
</p>
<table role = "presentation">
<tr><td><code>children</code></td>
<td>
<p>a matrix of dimension 2 times the number of decision variables containing the generated offsprings;</p>
</td></tr>
<tr><td><code>fitness</code></td>
<td>
<p>a vector of length 2 containing the fitness values for the offsprings. A value <code>NA</code> is returned if an offspring is different (which is usually the case) from the two parents.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Francisco Benitez</p>


<h3>References</h3>

<p>Scrucca, L. (2017) On some extensions to 'GA' package: hybrid optimisation, parallelisation and islands evolution. The R Journal, 9/1, 187-206, doi: 10.32614/RJ-2017-008.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nsga">nsga()</a></code>,
<code><a href="#topic+nsga2">nsga2()</a></code> and
<code><a href="#topic+nsga3">nsga3()</a></code>
</p>

<hr>
<h2 id='nsga_Mutation'>Mutation operators in non-dominated genetic algorithms</h2><span id='topic+nsga_Mutation'></span><span id='topic+nsgabin_raMutation'></span><span id='topic+nsgareal_raMutation'></span><span id='topic+nsgareal_polMutation'></span><span id='topic+nsgaperm_simMutation'></span>

<h3>Description</h3>

<p>Functions implementing mutation non-dominated genetic operator.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nsgabin_raMutation(object, parent)

  nsgareal_raMutation(object, parent)
  nsgareal_polMutation(object, parent, nm = 0.20)

  nsgaperm_simMutation(object, parent)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nsga_Mutation_+3A_object">object</code></td>
<td>
<p>An object of class <code>"nsga"</code>, <code>"nsga2"</code> or <code>"nsga3"</code> usually resulting from a call to function <code><a href="#topic+nsga">nsga</a></code>, <code><a href="#topic+nsga2">nsga2</a></code>, <code><a href="#topic+nsga3">nsga3</a></code>.</p>
</td></tr>
<tr><td><code id="nsga_Mutation_+3A_parent">parent</code></td>
<td>
<p>A vector of values for the parent from the current population where mutation should occur.</p>
</td></tr>
<tr><td><code id="nsga_Mutation_+3A_nm">nm</code></td>
<td>
<p>Parameters of genetic operators.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a vector of values containing the mutated string.</p>


<h3>Author(s)</h3>

<p>Francisco Benitez</p>


<h3>References</h3>

<p>Scrucca, L. (2017) On some extensions to 'GA' package: hybrid optimisation, parallelisation and islands evolution. The R Journal, 9/1, 187-206, doi: 10.32614/RJ-2017-008.
</p>

<hr>
<h2 id='nsga_Population'>Population initialization in non-dominated genetic algorithms</h2><span id='topic+nsga_Population'></span><span id='topic+nsgabin_Population'></span><span id='topic+nsgareal_Population'></span><span id='topic+nsgaperm_Population'></span>

<h3>Description</h3>

<p>Functions for creating a random initial population to be used in non-dominated genetic algorithms.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nsgabin_Population(object)

  nsgareal_Population(object)

  nsgaperm_Population(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nsga_Population_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+nsga-class">nsga-class</a></code>, <code><a href="#topic+nsga2-class">nsga2-class</a></code> or <code><a href="#topic+nsga3-class">nsga3-class</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nsgabin_Population</code> generates a random population of <code>object@nBits</code> binary values;
</p>
<p><code>nsgareal_Population</code> generates a random (uniform) population of real values in the range [<code>object@lower</code>, <code>object@upper</code>];
</p>
<p><code>nsgaperm_Population</code> generates a random (uniform) population of integer values in the range [<code>object@lower</code>, <code>object@upper</code>].
</p>


<h3>Value</h3>

<p>Return a matrix of dimension <code>object@popSize</code> times the number of decision variables.</p>


<h3>Author(s)</h3>

<p>Francisco Benitez</p>


<h3>References</h3>

<p>Scrucca, L. (2017) On some extensions to 'GA' package: hybrid optimisation, parallelisation and islands evolution. The R Journal, 9/1, 187-206, doi: 10.32614/RJ-2017-008.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nsga">nsga</a></code>,
<code><a href="#topic+nsga2">nsga2</a></code> and
<code><a href="#topic+nsga3">nsga3</a></code>
</p>

<hr>
<h2 id='nsga_Selection'>Selection operators in non-dominated genetic algorithms</h2><span id='topic+nsga_Selection'></span><span id='topic+nsga_lrSelection'></span><span id='topic+nsga_tourSelection'></span><span id='topic+nsgabin_lrSelection'></span><span id='topic+nsgabin_tourSelection'></span><span id='topic+nsgareal_lrSelection'></span><span id='topic+nsgareal_tourSelection'></span><span id='topic+nsgaperm_lrSelection'></span><span id='topic+nsgaperm_tourSelection'></span>

<h3>Description</h3>

<p>Functions implementing selection non-dominated genetic operator.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nsga_lrSelection(object, r, q)
  nsga_tourSelection(object, k = 3, ...)

  nsgabin_lrSelection(object, r, q)
  nsgabin_tourSelection(object, k = 3, ...)

  nsgareal_lrSelection(object, r, q)
  nsgareal_tourSelection(object, k = 3, ...)

  nsgaperm_lrSelection(object, r, q)
  nsgaperm_tourSelection(object, k = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nsga_Selection_+3A_object">object</code></td>
<td>
<p>An object of class <code>"nsga"</code>, <code>"nsga2"</code> or <code>"nsga3"</code>, usually resulting from a call to function  <code><a href="#topic+nsga">nsga</a></code>,  <code><a href="#topic+nsga2">nsga2</a></code> or <code><a href="#topic+nsga3">nsga3</a></code>.</p>
</td></tr>
<tr><td><code id="nsga_Selection_+3A_r">r</code></td>
<td>
<p>A tuning parameter for the specific selection operator.</p>
</td></tr>
<tr><td><code id="nsga_Selection_+3A_q">q</code></td>
<td>
<p>A tuning parameter for the specific selection operator.</p>
</td></tr>
<tr><td><code id="nsga_Selection_+3A_k">k</code></td>
<td>
<p>A tuning parameter for the specific selection operator.</p>
</td></tr>
<tr><td><code id="nsga_Selection_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a list with two elements:
</p>
<table role = "presentation">
<tr><td><code>population</code></td>
<td>
<p>a matrix of dimension <code>object@popSize</code> times the number of decision variables containing the selected individuals or strings;</p>
</td></tr>
<tr><td><code>fitness</code></td>
<td>
<p>a vector of length <code>object@popSize</code> containing the fitness values for the selected individuals.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Francisco Benitez</p>


<h3>References</h3>

<p>Scrucca, L. (2017) On some extensions to 'GA' package: hybrid optimisation, parallelisation and islands evolution. The R Journal, 9/1, 187-206, doi: 10.32614/RJ-2017-008.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nsga">nsga()</a></code>,
<code><a href="#topic+nsga2">nsga2()</a></code> and
<code><a href="#topic+nsga3">nsga3()</a></code>
</p>

<hr>
<h2 id='nsga-class'>Virtual Class 'nsga'</h2><span id='topic+nsga-class'></span>

<h3>Description</h3>

<p>The 'nsga' class is the parent superclass of the <a href="#topic+nsga1-class">nsga1</a>,
<a href="#topic+nsga2-class">nsga2</a>,  and <a href="#topic+nsga3-class">nsga3</a> classes
</p>


<h3>Slots</h3>


<dl>
<dt><code>call</code></dt><dd><p>an object of class 'call' representing the matched call.</p>
</dd>
<dt><code>type</code></dt><dd><p>a character string specifying the type of genetic algorithm used.</p>
</dd>
<dt><code>lower</code></dt><dd><p>a vector providing for each decision variable the lower bounds of
the search space in case of real-valued or permutation encoded optimisations.</p>
</dd>
<dt><code>upper</code></dt><dd><p>a vector providing for each decision variable the upper bounds of
the search space in case of real-valued or permutation encoded optimizations.</p>
</dd>
<dt><code>nBits</code></dt><dd><p>a value specifying the number of bits to be used in binary
encoded optimizations.</p>
</dd>
<dt><code>names</code></dt><dd><p>a vector of character strings providing the names of decision
variables (optional).</p>
</dd>
<dt><code>popSize</code></dt><dd><p>the population size.</p>
</dd>
<dt><code>front</code></dt><dd><p>Rank of individuals on the non-dominated front.</p>
</dd>
<dt><code>f</code></dt><dd><p>Front of individuals on the non-dominated front.</p>
</dd>
<dt><code>iter</code></dt><dd><p>the actual (or final) iteration of NSGA search.</p>
</dd>
<dt><code>run</code></dt><dd><p>the number of consecutive generations without any improvement in
the best fitness value before the NSGA is stopped.</p>
</dd>
<dt><code>maxiter</code></dt><dd><p>the maximum number of iterations to run before the NSGA search
is halted.</p>
</dd>
<dt><code>suggestions</code></dt><dd><p>a matrix of user provided solutions and included in the
initial population.</p>
</dd>
<dt><code>population</code></dt><dd><p>the current (or final) population.</p>
</dd>
<dt><code>pcrossover</code></dt><dd><p>the crossover probability.</p>
</dd>
<dt><code>pmutation</code></dt><dd><p>the mutation probability.</p>
</dd>
<dt><code>fitness</code></dt><dd><p>the values of fitness function for the current (or final)
population.</p>
</dd>
<dt><code>summary</code></dt><dd><p>a matrix of summary statistics for fitness values at each
iteration (along the rows).</p>
</dd>
<dt><code>fitnessValue</code></dt><dd><p>the best fitness value at the final iteration.</p>
</dd>
<dt><code>solution</code></dt><dd><p>the value(s) of the decision variables giving the best fitness
at the final iteration.</p>
</dd>
</dl>


<h3>Objects from the Class</h3>

<p>Since it is a virtual Class, no objects may be created from it.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass('nsga')
</code></pre>

<hr>
<h2 id='nsga1-class'>Class 'nsga1'</h2><span id='topic+nsga1-class'></span>

<h3>Description</h3>

<p>The class 'nsga1' is instantiated within the execution of rmoo and will be
returned as a result of it. All data generated during execution will be
stored in it.
</p>


<h3>Slots</h3>


<dl>
<dt><code>dumFitness</code></dt><dd><p>a large dummy fitness value assigned to individuals from
the nondominated front.</p>
</dd>
<dt><code>dShare</code></dt><dd><p>the maximun phenotypic distance allowed between any two
individuals to become members of a niche.</p>
</dd>
<dt><code>deltaDummy</code></dt><dd><p>value to decrease the dummy fitness of individuals by
non-dominated fronts.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>showClass('nsga1')
</code></pre>

<hr>
<h2 id='nsga2'>Non-Dominated Sorting in Genetic Algorithms II</h2><span id='topic+nsga2'></span>

<h3>Description</h3>

<p>Minimization of a fitness function using non-dominated sorting genetic
algorithms - II (NSGA-IIs). Multiobjective evolutionary algorithms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nsga2(
  type = c("binary", "real-valued", "permutation"),
  fitness,
  ...,
  lower,
  upper,
  nBits,
  population = nsgaControl(type)$population,
  selection = nsgaControl(type)$selection,
  crossover = nsgaControl(type)$crossover,
  mutation = nsgaControl(type)$mutation,
  popSize = 50,
  nObj = ncol(fitness(matrix(10000, ncol = 100, nrow = 100))),
  pcrossover = 0.8,
  pmutation = 0.1,
  maxiter = 100,
  run = maxiter,
  maxFitness = Inf,
  names = NULL,
  suggestions = NULL,
  monitor = if (interactive()) nsgaMonitor else FALSE,
  summary = FALSE,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nsga2_+3A_type">type</code></td>
<td>
<p>the type of genetic algorithm to be run depending on the nature
of decision variables. Possible values are:
</p>

<dl>
<dt>'binary'</dt><dd><p>for binary representations of decision variables.</p>
</dd>
<dt>'real-valued'</dt><dd><p>for optimization problems where the decision
variables are floating-point representations of real numbers.</p>
</dd>
<dt>'permutation'</dt><dd><p>for problems that involves reordering of a list of
objects.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="nsga2_+3A_fitness">fitness</code></td>
<td>
<p>the fitness function, any allowable R function which takes as
input an individual string representing a potential solution, and returns a
numerical value describing its 'fitness'.</p>
</td></tr>
<tr><td><code id="nsga2_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitness function. This
allows to write fitness functions that keep some variables fixed during the
search</p>
</td></tr>
<tr><td><code id="nsga2_+3A_lower">lower</code></td>
<td>
<p>a vector of length equal to the decision variables providing the
lower bounds of the search space in case of real-valued or permutation
encoded optimizations.</p>
</td></tr>
<tr><td><code id="nsga2_+3A_upper">upper</code></td>
<td>
<p>a vector of length equal to the decision variables providing the
upper bounds of the search space in case of real-valued or permutation
encoded optimizations.</p>
</td></tr>
<tr><td><code id="nsga2_+3A_nbits">nBits</code></td>
<td>
<p>a value specifying the number of bits to be used in binary
encoded optimizations</p>
</td></tr>
<tr><td><code id="nsga2_+3A_population">population</code></td>
<td>
<p>an R function for randomly generating an initial population.
See <code><a href="#topic+nsga_Population">nsga_Population()</a></code> for available functions.</p>
</td></tr>
<tr><td><code id="nsga2_+3A_selection">selection</code></td>
<td>
<p>an R function performing selection, i.e. a function which
generates a new population of individuals from the current population
probabilistically according to individual fitness. See <code><a href="#topic+nsga_Selection">nsga_Selection()</a></code>
for available functions.</p>
</td></tr>
<tr><td><code id="nsga2_+3A_crossover">crossover</code></td>
<td>
<p>an R function performing crossover, i.e. a function which
forms offsprings by combining part of the genetic information from their
parents. See <code><a href="#topic+nsga_Crossover">nsga_Crossover()</a></code> for available functions.</p>
</td></tr>
<tr><td><code id="nsga2_+3A_mutation">mutation</code></td>
<td>
<p>an R function performing mutation, i.e. a function which
randomly alters the values of some genes in a parent chromosome.
See <code><a href="#topic+nsga_Mutation">nsga_Mutation()</a></code> for available functions.</p>
</td></tr>
<tr><td><code id="nsga2_+3A_popsize">popSize</code></td>
<td>
<p>the population size.</p>
</td></tr>
<tr><td><code id="nsga2_+3A_nobj">nObj</code></td>
<td>
<p>number of objective in the fitness function.</p>
</td></tr>
<tr><td><code id="nsga2_+3A_pcrossover">pcrossover</code></td>
<td>
<p>the probability of crossover between pairs of chromosomes.
Typically this is a large value and by default is set to 0.8.</p>
</td></tr>
<tr><td><code id="nsga2_+3A_pmutation">pmutation</code></td>
<td>
<p>the probability of mutation in a parent chromosome. Usually
mutation occurs with a small probability, and by default is set to 0.1.</p>
</td></tr>
<tr><td><code id="nsga2_+3A_maxiter">maxiter</code></td>
<td>
<p>the maximum number of iterations to run before the NSGA search
is halted.</p>
</td></tr>
<tr><td><code id="nsga2_+3A_run">run</code></td>
<td>
<p>the number of consecutive generations without any improvement in
the best fitness value before the NSGA is stopped</p>
</td></tr>
<tr><td><code id="nsga2_+3A_maxfitness">maxFitness</code></td>
<td>
<p>the upper bound on the fitness function after that the NSGA
search is interrupted.</p>
</td></tr>
<tr><td><code id="nsga2_+3A_names">names</code></td>
<td>
<p>a vector of character strings providing the names of decision
variables.</p>
</td></tr>
<tr><td><code id="nsga2_+3A_suggestions">suggestions</code></td>
<td>
<p>a matrix of solutions strings to be included in the
initial population. If provided the number of columns must match the number
of decision variables.</p>
</td></tr>
<tr><td><code id="nsga2_+3A_monitor">monitor</code></td>
<td>
<p>a logical or an R function which takes as input the current
state of the nsga-class object and show the evolution of the search. By
default, for interactive sessions the function nsgaMonitor prints the average
and best fitness values at each iteration. If set to plot these information
are plotted on a graphical device. Other functions can be written by the user
and supplied as argument. In non interactive sessions, by default
monitor = FALSE so any output is suppressed.</p>
</td></tr>
<tr><td><code id="nsga2_+3A_summary">summary</code></td>
<td>
<p>If there will be a summary generation after generation.</p>
</td></tr>
<tr><td><code id="nsga2_+3A_seed">seed</code></td>
<td>
<p>an integer value containing the random number generator state.
This argument can be used to replicate the results of a NSGA search. Note
that if parallel computing is required, the doRNG package must be installed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Non-dominated genetic algorithms II is a meta-heuristic proposed by
K. Deb, A. Pratap, S. Agarwal and T. Meyarivan in 2002. The purpose of the
algorithms is to find an efficient way to optimize multi-objectives functions
(two or more).
</p>


<h3>Value</h3>

<p>Returns an object of class nsga2-class. See <a href="#topic+nsga2-class">nsga2</a> for a
description of available slots information.
</p>


<h3>Author(s)</h3>

<p>Francisco Benitez
<a href="mailto:benitezfj94@gmail.com">benitezfj94@gmail.com</a>
</p>


<h3>References</h3>

<p>K. Deb, A. Pratap, S. Agarwal and T. Meyarivan, 'A fast and
elitist multiobjective genetic algorithm: NSGA-II,' in IEEE Transactions on
Evolutionary Computation, vol. 6, no. 2, pp. 182-197, April 2002,
doi: 10.1109/4235.996017.
</p>
<p>Scrucca, L. (2017) On some extensions to 'GA' package: hybrid optimisation,
parallelisation and islands evolution. The R Journal, 9/1, 187-206.
doi: 10.32614/RJ-2017-008
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nsga">nsga()</a></code>, <code><a href="#topic+nsga3">nsga3()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example
#Two Objectives - Real Valued
zdt1 &lt;- function (x) {
 if (is.null(dim(x))) {
   x &lt;- matrix(x, nrow = 1)
 }
 n &lt;- ncol(x)
 g &lt;- 1 + rowSums(x[, 2:n, drop = FALSE]) * 9/(n - 1)
 return(cbind(x[, 1], g * (1 - sqrt(x[, 1]/g))))
}

#Not run:
## Not run: 
result &lt;- nsga2(type = "real-valued",
                fitness = zdt1,
                lower = c(0,0),
                upper = c(1,1),
                popSize = 100,
                monitor = FALSE,
                maxiter = 500)

## End(Not run)

#Example 2
#Three Objectives - Real Valued
dtlz1 &lt;- function (x, nobj = 3){
    if (is.null(dim(x))) {
        x &lt;- matrix(x, 1)
    }
    n &lt;- ncol(x)
    y &lt;- matrix(x[, 1:(nobj - 1)], nrow(x))
    z &lt;- matrix(x[, nobj:n], nrow(x))
    g &lt;- 100 * (n - nobj + 1 + rowSums((z - 0.5)^2 - cos(20 * pi * (z - 0.5))))
    tmp &lt;- t(apply(y, 1, cumprod))
    tmp &lt;- cbind(t(apply(tmp, 1, rev)), 1)
    tmp2 &lt;- cbind(1, t(apply(1 - y, 1, rev)))
    f &lt;- tmp * tmp2 * 0.5 * (1 + g)
    return(f)
}

#Not run:
## Not run: 
result &lt;- nsga2(type = "real-valued",
                fitness = dtlz1,
                lower = c(0,0,0), upper = c(1,1,1),
                popSize = 92,
                monitor = FALSE,
                maxiter = 500)

## End(Not run)

</code></pre>

<hr>
<h2 id='nsga2-class'>Class 'nsga2'</h2><span id='topic+nsga2-class'></span>

<h3>Description</h3>

<p>The class 'nsga2' is instantiated within the execution of rmoo and will be
returned as a result of it. All data generated during execution will be
stored in it.
</p>


<h3>Slots</h3>


<dl>
<dt><code>crowdingDistance</code></dt><dd><p>Crowding-comparison approach to estiate of the
perimeter of the cuboid formed by using the nearest neighbors as the vertices.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>showClass('nsga2')
</code></pre>

<hr>
<h2 id='nsga3'>Non-Dominated Sorting in Genetic Algorithms III</h2><span id='topic+nsga3'></span>

<h3>Description</h3>

<p>Minimization of a fitness function using non-dominated sorting genetic
algorithms - III (NSGA-IIIs). Multiobjective evolutionary algorithms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nsga3(
  type = c("binary", "real-valued", "permutation"),
  fitness,
  ...,
  lower,
  upper,
  nBits,
  population = nsgaControl(type)$population,
  selection = nsgaControl(type)$selection,
  crossover = nsgaControl(type)$crossover,
  mutation = nsgaControl(type)$mutation,
  popSize = 50,
  nObj = ncol(fitness(matrix(10000, ncol = 100, nrow = 100))),
  n_partitions,
  pcrossover = 0.8,
  pmutation = 0.1,
  reference_dirs = generate_reference_points,
  maxiter = 100,
  run = maxiter,
  maxFitness = Inf,
  names = NULL,
  suggestions = NULL,
  monitor = if (interactive()) nsgaMonitor else FALSE,
  summary = FALSE,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nsga3_+3A_type">type</code></td>
<td>
<p>the type of genetic algorithm to be run depending on the nature
of decision variables. Possible values are:
</p>

<dl>
<dt><code>"binary"</code></dt><dd><p>for binary representations of decision variables.</p>
</dd>
<dt><code>"real-valued"</code></dt><dd><p>for optimization problems where the decision
variables are floating-point representations of real numbers.</p>
</dd>
<dt><code>"permutation"</code></dt><dd><p>for problems that involves reordering of a list
of objects.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="nsga3_+3A_fitness">fitness</code></td>
<td>
<p>the fitness function, any allowable R function which takes as
input an individual string representing a potential solution, and returns a
numerical value describing its “fitness”.</p>
</td></tr>
<tr><td><code id="nsga3_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the fitness function. This
allows to write fitness functions that keep some variables fixed during the
search</p>
</td></tr>
<tr><td><code id="nsga3_+3A_lower">lower</code></td>
<td>
<p>a vector of length equal to the decision variables providing the
lower bounds of the search space in case of real-valued or permutation
encoded optimizations.</p>
</td></tr>
<tr><td><code id="nsga3_+3A_upper">upper</code></td>
<td>
<p>a vector of length equal to the decision variables providing the
upper bounds of the search space in case of real-valued or permutation
encoded optimizations.</p>
</td></tr>
<tr><td><code id="nsga3_+3A_nbits">nBits</code></td>
<td>
<p>a value specifying the number of bits to be used in binary
encoded optimizations.</p>
</td></tr>
<tr><td><code id="nsga3_+3A_population">population</code></td>
<td>
<p>an R function for randomly generating an initial population.
See <code><a href="#topic+nsga_Population">nsga_Population()</a></code> for available functions.</p>
</td></tr>
<tr><td><code id="nsga3_+3A_selection">selection</code></td>
<td>
<p>an R function performing selection, i.e. a function which
generates a new population of individuals from the current population
probabilistically according to individual fitness. See <code><a href="#topic+nsga_Selection">nsga_Selection()</a></code>
for available functions.</p>
</td></tr>
<tr><td><code id="nsga3_+3A_crossover">crossover</code></td>
<td>
<p>an R function performing crossover, i.e. a function which
forms offsprings by combining part of the
genetic information from their parents. See <code><a href="#topic+nsga_Crossover">nsga_Crossover()</a></code>
for available functions.</p>
</td></tr>
<tr><td><code id="nsga3_+3A_mutation">mutation</code></td>
<td>
<p>an R function performing mutation, i.e. a function which
randomly alters the values of some genes in a parent chromosome.
See <code><a href="#topic+nsga_Mutation">nsga_Mutation()</a></code> for available functions.</p>
</td></tr>
<tr><td><code id="nsga3_+3A_popsize">popSize</code></td>
<td>
<p>the population size.</p>
</td></tr>
<tr><td><code id="nsga3_+3A_nobj">nObj</code></td>
<td>
<p>number of objective in the fitness function.</p>
</td></tr>
<tr><td><code id="nsga3_+3A_n_partitions">n_partitions</code></td>
<td>
<p>Partition number of generated reference points</p>
</td></tr>
<tr><td><code id="nsga3_+3A_pcrossover">pcrossover</code></td>
<td>
<p>the probability of crossover between pairs of chromosomes.
Typically this is a large value and by default is set to 0.8.</p>
</td></tr>
<tr><td><code id="nsga3_+3A_pmutation">pmutation</code></td>
<td>
<p>the probability of mutation in a parent chromosome. Usually
mutation occurs with a small probability, and by default is set to 0.1.</p>
</td></tr>
<tr><td><code id="nsga3_+3A_reference_dirs">reference_dirs</code></td>
<td>
<p>Function to generate reference points using Das and
Dennis approach or matrix with supplied reference points.</p>
</td></tr>
<tr><td><code id="nsga3_+3A_maxiter">maxiter</code></td>
<td>
<p>the maximum number of iterations to run before the NSGA search
is halted.</p>
</td></tr>
<tr><td><code id="nsga3_+3A_run">run</code></td>
<td>
<p>the number of consecutive generations without any improvement in
the best fitness value before the NSGA is stopped</p>
</td></tr>
<tr><td><code id="nsga3_+3A_maxfitness">maxFitness</code></td>
<td>
<p>the upper bound on the fitness function after that the NSGA
search is interrupted.</p>
</td></tr>
<tr><td><code id="nsga3_+3A_names">names</code></td>
<td>
<p>a vector of character strings providing the names of decision
variables.</p>
</td></tr>
<tr><td><code id="nsga3_+3A_suggestions">suggestions</code></td>
<td>
<p>a matrix of solutions strings to be included in the initial
population. If provided the number of columns must match the number of
decision variables.</p>
</td></tr>
<tr><td><code id="nsga3_+3A_monitor">monitor</code></td>
<td>
<p>a logical or an R function which takes as input the current
state of the nsga-class object and show the evolution of the search.
By default, for interactive sessions the function nsgaMonitor prints the
average and best fitness values at each iteration. If set to plot these
information are plotted on a graphical device. Other functions can be written
by the user and supplied as argument. In non interactive sessions, by default
monitor = FALSE so any output is suppressed.</p>
</td></tr>
<tr><td><code id="nsga3_+3A_summary">summary</code></td>
<td>
<p>If there will be a summary generation after generation.</p>
</td></tr>
<tr><td><code id="nsga3_+3A_seed">seed</code></td>
<td>
<p>an integer value containing the random number generator state.
This argument can be used to replicate the results of a NSGA search. Note
that if parallel computing is required, the doRNG package must be installed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Non-dominated genetic algorithms III is a meta-heuristic proposed by
K. Deb and H. Jain in 2013.
The purpose of the algorithms is to find an efficient way to optimize
multi-objectives functions (more than three).
</p>


<h3>Value</h3>

<p>Returns an object of class nsga3-class. See <a href="#topic+nsga3-class">nsga3</a> for a
description of available slots information.
</p>


<h3>Author(s)</h3>

<p>Francisco Benitez
<a href="mailto:benitezfj94@gmail.com">benitezfj94@gmail.com</a>
</p>


<h3>References</h3>

<p>K. Deb and H. Jain, &quot;An Evolutionary Many-Objective Optimization
Algorithm Using Reference-Point-Based Nondominated Sorting Approach, Part I:
Solving Problems With Box Constraints,&quot; in IEEE Transactions on Evolutionary
Computation, vol. 18, no. 4, pp. 577-601, Aug. 2014,
doi: 10.1109/TEVC.2013.2281535.
</p>
<p>Scrucca, L. (2017) On some extensions to 'GA' package: hybrid optimisation,
parallelisation and islands evolution. The R Journal, 9/1, 187-206.
doi: 10.32614/RJ-2017-008
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nsga">nsga()</a></code>, <code><a href="#topic+nsga2">nsga2()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example 1
#Two Objectives - Real Valued
zdt1 &lt;- function (x) {
 if (is.null(dim(x))) {
   x &lt;- matrix(x, nrow = 1)
 }
 n &lt;- ncol(x)
 g &lt;- 1 + rowSums(x[, 2:n, drop = FALSE]) * 9/(n - 1)
 return(cbind(x[, 1], g * (1 - sqrt(x[, 1]/g))))
}

#Not run
## Not run: 
result &lt;- nsga3(type = "real-valued",
                fitness = zdt1,
                lower = c(0,0),
                upper = c(1,1),
                popSize = 100,
                n_partitions = 100,
                monitor = FALSE,
                maxiter = 500)

## End(Not run)

#Example 2
#Three Objectives - Real Valued
dtlz1 &lt;- function (x, nobj = 3){
    if (is.null(dim(x))) {
        x &lt;- matrix(x, 1)
    }
    n &lt;- ncol(x)
    y &lt;- matrix(x[, 1:(nobj - 1)], nrow(x))
    z &lt;- matrix(x[, nobj:n], nrow(x))
    g &lt;- 100 * (n - nobj + 1 + rowSums((z - 0.5)^2 - cos(20 * pi * (z - 0.5))))
    tmp &lt;- t(apply(y, 1, cumprod))
    tmp &lt;- cbind(t(apply(tmp, 1, rev)), 1)
    tmp2 &lt;- cbind(1, t(apply(1 - y, 1, rev)))
    f &lt;- tmp * tmp2 * 0.5 * (1 + g)
    return(f)
}

#Not Run
## Not run: 
result &lt;- nsga3(type = "real-valued",
                fitness = dtlz1,
                lower = c(0,0,0),
                upper = c(1,1,1),
                popSize = 92,
                n_partitions = 12,
                monitor = FALSE,
                maxiter = 500)

## End(Not run)

</code></pre>

<hr>
<h2 id='nsga3-class'>Class 'nsga3'</h2><span id='topic+nsga3-class'></span>

<h3>Description</h3>

<p>The class 'nsga3' is instantiated within the execution of rmoo and will be
returned as a result of it. All data generated during execution will be
stored in it.
</p>


<h3>Slots</h3>


<dl>
<dt><code>ideal_point</code></dt><dd><p>Nadir point estimate used as lower bound in normalization.</p>
</dd>
<dt><code>worst_point</code></dt><dd><p>Worst point generated over generations.</p>
</dd>
<dt><code>smin</code></dt><dd><p>Index used to obtain the extreme points.</p>
</dd>
<dt><code>extreme_points</code></dt><dd><p>are selected using the ASF in the (<code><a href="#topic+PerformScalarizing">PerformScalarizing()</a></code>).
Necessary in the  nadir point generation.</p>
</dd>
<dt><code>worst_of_population</code></dt><dd><p>The worst individuals generated by objectives in
the current generation.</p>
</dd>
<dt><code>worst_of_front</code></dt><dd><p>The worst individuals in the first front generated by
objectives in the current generation.</p>
</dd>
<dt><code>nadir_point</code></dt><dd><p>Nadir point estimate used as upper bound in normalization.</p>
</dd>
<dt><code>reference_points</code></dt><dd><p>NSGA-III uses a predefined set of reference points to
ensure diversity in obtained solutions.
The chosen refenrece points can be predefined in structured manner or
supplied by the user. We use the Das and Dennis procedure.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>showClass('nsga3')
</code></pre>

<hr>
<h2 id='nsgaControl'>A function for setting or retrieving defaults non-dominated genetic operators</h2><span id='topic+nsgaControl'></span>

<h3>Description</h3>

<p>Default settings for non-dominated genetic operators used in the 'rmoo' package.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nsgaControl(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nsgaControl_+3A_...">...</code></td>
<td>

<p>no arguments, a single character vector, or a named list with components.
</p>
</td></tr></table>


<h3>Details</h3>

<p>If the function is called with no arguments returns the current default settings, i.e., a list with the following default components:
</p>

<ul>
<li><p><code>"binary"</code>
</p>

<ul>
<li><p><code>population</code> = <code>"nsgabin_Population"</code>
</p>
</li>
<li><p><code>selection</code> = <code>"nsgabin_tourSelection"</code>
</p>
</li>
<li><p><code>crossover</code> = <code>"nsgabin_spCrossover"</code>
</p>
</li>
<li><p><code>mutation</code> = <code>"nsgabin_raMutation"</code>
</p>
</li></ul>


</li>
<li><p><code>"real-valued"</code>
</p>

<ul>
<li><p><code>population</code> = <code>"nsgareal_Population"</code>
</p>
</li>
<li><p><code>selection</code> = <code>"nsgareal_tourSelection"</code>
</p>
</li>
<li><p><code>crossover</code> = <code>"nsgareal_sbxCrossover"</code>
</p>
</li>
<li><p><code>mutation</code> = <code>"nsgareal_polMutation"</code>
</p>
</li></ul>


</li>
<li><p><code>"permutation"</code>
</p>

<ul>
<li><p><code>population</code> = <code>"nsgaperm_Population"</code>
</p>
</li>
<li><p><code>selection</code> = <code>"nsgaperm_tourSelection"</code>
</p>
</li>
<li><p><code>crossover</code> = <code>"nsgaperm_oxCrossover"</code>
</p>
</li>
<li><p><code>mutation</code> = <code>"nsgaperm_simMutation"</code>
</p>
</li></ul>


</li>
<li><p><code>"eps"</code> = the tolerance value used by the package functions. By default set at <code>sqrt(.Machine$double.eps)</code>.
</p>
</li></ul>

<p>The function may be called with a single string specifying the name of the component. In this case the function returns the current default settings.
</p>
<p>To change the default values, a named component must be followed by a single value (in case of <code>"eps"</code>) or a list of component(s) specifying the name of the function for a genetic operator. See the Examples section.
</p>


<h3>Value</h3>

<p>If the argument list is empty the function returns the current list of values.
If the argument list is not empty, the returned list is invisible.
</p>


<h3>Note</h3>

<p>The parameter values set via a call to this function will remain in effect for the rest of the session, affecting the subsequent behaviour of the functions for which the given parameters are relevant.
</p>


<h3>Author(s)</h3>

<p>Francisco Benitez</p>


<h3>References</h3>

<p>Scrucca, L. (2017) On some extensions to 'GA' package: hybrid optimisation, parallelisation and islands evolution. The R Journal, 9/1, 187-206, doi: 10.32614/RJ-2017-008.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nsga">nsga()</a></code>,
<code><a href="#topic+nsga2">nsga2()</a></code> and
<code><a href="#topic+nsga3">nsga3()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # get and save defaults
  defaultControl &lt;- nsgaControl()
  print(defaultControl)
  # get current defaults only for real-valued search
  nsgaControl("real-valued")
  # set defaults for selection operator of real-valued search
  nsgaControl("real-valued" = list(selection = "nsgareal_lrSelection"))
  nsgaControl("real-valued")
  # set defaults for selection and crossover operators of real-valued search
  nsgaControl("real-valued" = list(selection = "nsgareal_lrSelection",
                                   crossover = "nsgareal_spCrossover"))
  nsgaControl("real-valued")
  # restore defaults
  nsgaControl(defaultControl)
  nsgaControl()
</code></pre>

<hr>
<h2 id='nsgaMonitor'>Monitor non-dominated genetic algorithm evolution</h2><span id='topic+nsgaMonitor'></span>

<h3>Description</h3>

<p>Functions to plotting fitness values at each iteration of a search for the 'rmoo' package.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nsgaMonitor(object, number_objectives, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nsgaMonitor_+3A_object">object</code></td>
<td>
<p>an object of class <code>nsga</code>, <code>nsga2</code> or <code>nsga3</code>, usually resulting from a call to function <code><a href="#topic+nsga">nsga</a></code>, <code><a href="#topic+nsga2">nsga2</a></code> or <code><a href="#topic+nsga3">nsga3</a></code>, respectively.</p>
</td></tr>
<tr><td><code id="nsgaMonitor_+3A_number_objectives">number_objectives</code></td>
<td>
<p>numbers of objective values of the function to evaluate.</p>
</td></tr>
<tr><td><code id="nsgaMonitor_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>These functions plot the fitness values of the current step of the nsga3 on the console. <br />
By default, <code>nsgaMonitor</code> is called in interactive sessions by <code><a href="#topic+nsga">nsga</a></code>, <code><a href="#topic+nsga2">nsga2</a></code>, or <code><a href="#topic+nsga3">nsga3</a></code>. <br />
The function can be modified by the user to plot or print the values it considers by iteration. <br />
</p>


<h3>Author(s)</h3>

<p>Francisco Benitez</p>


<h3>References</h3>

<p>Scrucca, L. (2017) On some extensions to 'GA' package: hybrid optimisation, parallelisation and islands evolution. The R Journal, 9/1, 187-206, doi: 10.32614/RJ-2017-008.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nsga">nsga()</a></code>,
<code><a href="#topic+nsga2">nsga2()</a></code> and
<code><a href="#topic+nsga3">nsga3()</a></code>
</p>

<hr>
<h2 id='numberOrNAOrMatrix-class'>Virtual Class 'numberOrNAOrMatrix - Simple Class for subassigment Values'</h2><span id='topic+numberOrNAOrMatrix-class'></span>

<h3>Description</h3>

<p>The class 'numberOrNAOrMatrix' is a simple class union (<code><a href="methods.html#topic+setClassUnion">setClassUnion()</a></code>)
of 'numeric', 'logical', 'logical' and 'matrix'.
</p>


<h3>Objects from the Class</h3>

<p>Since it is a virtual Class, no objects may be created from it.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass('numberOrNAOrMatrix')
</code></pre>

<hr>
<h2 id='performance_metrics'>Objective Values performance metrics</h2><span id='topic+performance_metrics'></span><span id='topic+generational_distance'></span>

<h3>Description</h3>

<p>Functions to evaluate the quality of the results obtained by the algorithms, evaluating their diversity and convergence, providing or not some parameters to compare.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  generational_distance(fitness, reference_points)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="performance_metrics_+3A_fitness">fitness</code></td>
<td>
<p>Objective values generated by the algorithm.</p>
</td></tr>
<tr><td><code id="performance_metrics_+3A_reference_points">reference_points</code></td>
<td>
<p>Optimal points to achieve.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the measurement parameter.</p>


<h3>Author(s)</h3>

<p>Francisco Benitez</p>


<h3>References</h3>

<p>Lamont, G., &amp; Veldhuizen, D.V. (1999). Multiobjective evolutionary algorithms: classifications, analyses, and new innovations.
</p>

<hr>
<h2 id='plot'>Methods for Function 'plot' in Package 'rmoo'</h2><span id='topic+plot'></span><span id='topic+plot+2Cnsga+2Cmissing-method'></span><span id='topic+plot+2Cnsga+2Cmissing'></span><span id='topic+plot+2Cnsga1+2Cmissing-method'></span><span id='topic+plot+2Cnsga1-method'></span><span id='topic+plot+2Cnsga2+2Cmissing-method'></span><span id='topic+plot+2Cnsga2-method'></span><span id='topic+plot+2Cnsga3+2Cmissing-method'></span><span id='topic+plot+2Cnsga3-method'></span>

<h3>Description</h3>

<p>Method used to visualize the fitness of the individuals during the execution
of the algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot(x, y, ...)

## S4 method for signature 'nsga,missing'
plot(x, y = "missing", type = c("scatter", "pcp", "heatmap", "polar"), ...)

## S4 method for signature 'nsga1,missing'
plot(x, y = "missing", type = c("scatter", "pcp", "heatmap", "polar"), ...)

## S4 method for signature 'nsga2,missing'
plot(x, y = "missing", type = c("scatter", "pcp", "heatmap", "polar"), ...)

## S4 method for signature 'nsga3,missing'
plot(x, y = "missing", type = c("scatter", "pcp", "heatmap", "polar"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_+3A_x">x</code>, <code id="plot_+3A_y">y</code></td>
<td>
<p>Objects of either class <a href="#topic+nsga1-class">nsga1</a>,
<a href="#topic+nsga2-class">nsga2</a>,  or <a href="#topic+nsga3-class">nsga3</a>.</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>other arguments passed on to methods
</p>

<dl>
<dt>&quot;optimal&quot;</dt><dd><p>An argument passed to the &quot;scatter&quot; plot. A matrix of
dimension equal to the fitness with which they are compared. This value can
only be compared in 2 and 3 dimensional &quot;scatter&quot; plots.</p>
</dd>
<dt>&quot;individual&quot;</dt><dd><p>An argument passed to the &quot;heatmap&quot; and &quot;polar&quot; plots.
A vector that represents the fitness of the individuals to be displayed.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="plot_+3A_type">type</code></td>
<td>
<p>Type of graph to draw, the graphs can be of the type &quot;scatter&quot;,
&quot;pcp&quot;, &quot;heatmap&quot;, or &quot;polar&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following plots are available:
</p>

<ul>
<li><p>&quot;Scatter Plot&quot;
</p>
</li>
<li><p>&quot;Parallel Coordinate Plot&quot;
</p>
</li>
<li><p>&quot;Heat Map&quot;
</p>
</li>
<li><p>&quot;Polar Coordinate&quot;
</p>
</li></ul>



<h3>Value</h3>

<p>A graph of the evaluated type.
</p>


<h3>Author(s)</h3>

<p>Francisco Benitez
<a href="mailto:benitezfj94@gmail.com">benitezfj94@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Where 'out' is an object of class nsga1, nsga2, or nsga3.
# The plot method will by default plot a scatter plot.
#
# plot(out)
#
# The Parallel Coordinate Plot will be plotted if "pcp" is passed as a parameter to "type".
#
# plot(out, type="pcp")
#
# A heat map plot will be plotted if "heatmap" is passed as a parameter to "type"
# and a vector with the individuals to plot to "individual"
#
# plot(out, type = "heatmap", individual = c(1:5))
#
# A polar coordinate plot will be plotted if "polar" is passed as a parameter to "type"
# and a vector with the individuals to plot to "individual"
#
# plot(out, type = "polar", individual = c(1:5))

</code></pre>

<hr>
<h2 id='print'>Methods for Function 'print' in Package 'rmoo'.</h2><span id='topic+print'></span><span id='topic+print+2Cnsga-method'></span><span id='topic+print+2Cnsga+2Cmissing-method'></span><span id='topic+print+2Cnsga1-method'></span><span id='topic+print+2Cnsga3-method'></span>

<h3>Description</h3>

<p>Method used to print the slots and relevant values of the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print(x, ...)

## S4 method for signature 'nsga'
print(x, ...)

## S4 method for signature 'nsga1'
print(x, ...)

## S4 method for signature 'nsga3'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print_+3A_x">x</code></td>
<td>
<p>Objects of either class <a href="#topic+nsga1-class">nsga1</a>,
<a href="#topic+nsga2-class">nsga2</a>,  or <a href="#topic+nsga3-class">nsga3</a>.</p>
</td></tr>
<tr><td><code id="print_+3A_...">...</code></td>
<td>
<p>other arguments passed on to methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print the slots and relevant values of the object.
</p>


<h3>Author(s)</h3>

<p>Francisco Benitez
<a href="mailto:benitezfj94@gmail.com">benitezfj94@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Where 'out' is an object of class nsga1, nsga2, or nsga3
#
# print(out)

</code></pre>

<hr>
<h2 id='progress'>Methods for Function 'progress' in Package 'rmoo'</h2><span id='topic+progress'></span><span id='topic+progress+2Cnsga-method'></span><span id='topic+progress+2Cnsga+2Cnsga-method'></span><span id='topic+progress+2Cnsga1-method'></span><span id='topic+progress+2Cnsga2-method'></span><span id='topic+progress+2Cnsga3-method'></span>

<h3>Description</h3>

<p>Method used to save the progress of the evaluation results, similar to the
summary method. Passing additional arguments to the progress method evaluates
performance metrics per iteration. This method cannot be called outside of
rmoo execution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>progress(object, ...)

## S4 method for signature 'nsga'
progress(object, ...)

## S4 method for signature 'nsga1'
progress(object, ...)

## S4 method for signature 'nsga2'
progress(object, ...)

## S4 method for signature 'nsga3'
progress(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="progress_+3A_object">object</code></td>
<td>
<p>Objects of either class <a href="#topic+nsga1-class">nsga1</a>,
<a href="#topic+nsga2-class">nsga2</a>,  or <a href="#topic+nsga3-class">nsga3</a>.</p>
</td></tr>
<tr><td><code id="progress_+3A_...">...</code></td>
<td>
<p>other arguments passed on to methods. Passing <code>"reference_dirs"</code>
as arguments will evaluate the performance metrics Hypervolumen,
Generational Distance, and Inverse Generational Distance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length equal to the number of iterations, where the progress made during execution is saved.
</p>


<h3>Author(s)</h3>

<p>Francisco Benitez
<a href="mailto:benitezfj94@gmail.com">benitezfj94@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Where 'out' is an object of class nsga1, nsga2, or nsga3, and callArgs are
# the additional arguments passed when calling the rmoo function, for the
# evaluation of performance metrics, reference points are expected to be passed
# as an argument to reference_dirs.
#
# progress(object, callArgs)
#

</code></pre>

<hr>
<h2 id='reference_point_multi_layer'>Determination of Multi-layer Reference Points</h2><span id='topic+reference_point_multi_layer'></span>

<h3>Description</h3>

<p>A implementation of Multi-layer Reference Points Generation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reference_point_multi_layer(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reference_point_multi_layer_+3A_...">...</code></td>
<td>
<p>The different layers provided by the user</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Multi-layer reference point implementation is based on Blank and Deb's
pymoo library, the approach generates different layers of references point
at different scales, provided by the user.
</p>


<h3>Value</h3>

<p>A matrix with the multi-layer reference points
</p>


<h3>Author(s)</h3>

<p>Francisco Benitez
<a href="mailto:benitezfj94@gmail.com">benitezfj94@gmail.com</a>
</p>


<h3>References</h3>

<p>J. Blank and K. Deb, &quot;Pymoo: Multi-Objective Optimization in
Python,&quot; in IEEE Access, vol. 8, pp. 89497-89509, 2020,
doi: 10.1109/ACCESS.2020.2990567.
</p>
<p>Das, Indraneel &amp; Dennis, J. (2000). Normal-Boundary Intersection: A New
Method for Generating the Pareto Surface in Nonlinear Multicriteria
Optimization Problems. SIAM Journal on Optimization. 8.
10.1137/S1052623496307510.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generate_reference_points">generate_reference_points()</a></code> and <code><a href="#topic+get_fixed_rowsum_integer_matrix">get_fixed_rowsum_integer_matrix()</a></code>
</p>

<hr>
<h2 id='rmoo_func'>R Multi-Objective Optimization Main Function</h2><span id='topic+rmoo_func'></span><span id='topic+rmoo'></span><span id='topic+rmoo-func+2Crmoo-function'></span>

<h3>Description</h3>

<p>Main function of rmoo, based on the parameters it will call the different
algorithms implemented in the package. Optimization algorithms will minimize
a fitness function. For more details of the algorithms
see <code><a href="#topic+nsga">nsga()</a></code>, <code><a href="#topic+nsga2">nsga2()</a></code>, <code><a href="#topic+nsga3">nsga3()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmoo(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rmoo_func_+3A_...">...</code></td>
<td>
<p>argument in which all the values necessary for the configuration
will be passed as parameters. The user is encouraged to see the documentations
of <code><a href="#topic+nsga">nsga()</a></code>, <code><a href="#topic+nsga2">nsga2()</a></code>, <code><a href="#topic+nsga3">nsga3()</a></code> in which the necessary parameters for each
algorithm are cited, in addition, the chosen strategy to execute must be
passed as an argument. This can be seen more clearly in the examples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multi- and Many-Optimization of a fitness function using Non-dominated
Sorting Genetic Algorithms. The algorithms currently implemented by rmoo
are: NSGA-I, NSGA-II and NSGA-III
</p>
<p>The original Non-dominated Sorting Genetic Slgorithms (NSGA-I)is a
meta-heuristic proposed by N. Srinivas and K. Deb in 1994. The purpose of
the algorithms is to find an efficient way to optimize multi-objectives
functions (two or more).
</p>
<p>The Non-dominated genetic algorithms II (NSGA-II) is a meta-heuristic proposed by
K. Deb, A. Pratap, S. Agarwal and T. Meyarivan in 2002. The purpose of the
algorithms is to find an efficient way to optimize multi-objectives functions
(two or more).
</p>
<p>The Non-dominated genetic algorithms III (NSGA-III) is a meta-heuristic proposed by
K. Deb and H. Jain in 2013.
The purpose of the algorithms is to find an efficient way to optimize
multi-objectives functions (more than three).
</p>


<h3>Value</h3>

<p>Returns an object of class ga-class, nsga1-class, nsga2-class or
nsga3-class. See <a href="#topic+nsga1-class">nsga1</a>, <a href="#topic+nsga2-class">nsga2</a>, <a href="#topic+nsga3-class">nsga3</a> for a description of
available slots information.
</p>


<h3>Author(s)</h3>

<p>Francisco Benitez
<a href="mailto:benitezfj94@gmail.com">benitezfj94@gmail.com</a>
</p>


<h3>References</h3>

<p>Scrucca, L. (2017) On some extensions to 'GA' package: hybrid
optimisation, parallelisation and islands evolution. The R Journal, 9/1, 187-206.
doi: 10.32614/RJ-2017-008
</p>
<p>N. Srinivas and K. Deb, &quot;Multiobjective Optimization Using
Nondominated Sorting in Genetic Algorithms, in Evolutionary Computation,
vol. 2, no. 3, pp. 221-248, Sept. 1994, doi: 10.1162/evco.1994.2.3.221.
</p>
<p>K. Deb, A. Pratap, S. Agarwal and T. Meyarivan, 'A fast and
elitist multiobjective genetic algorithm: NSGA-II,' in IEEE Transactions on
Evolutionary Computation, vol. 6, no. 2, pp. 182-197, April 2002,
doi: 10.1109/4235.996017.
</p>
<p>K. Deb and H. Jain, &quot;An Evolutionary Many-Objective Optimization
Algorithm Using Reference-Point-Based Nondominated Sorting Approach, Part I:
Solving Problems With Box Constraints,&quot; in IEEE Transactions on Evolutionary
Computation, vol. 18, no. 4, pp. 577-601, Aug. 2014,
doi: 10.1109/TEVC.2013.2281535.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nsga">nsga()</a></code>, <code><a href="#topic+nsga2">nsga2()</a></code>, <code><a href="#topic+nsga3">nsga3()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example 1
#Two Objectives - Real Valued
zdt1 &lt;- function (x,...) {
 if (is.null(dim(x))) {
   x &lt;- matrix(x, nrow = 1)
 }
 n &lt;- ncol(x)
 g &lt;- 1 + rowSums(x[, 2:n, drop = FALSE]) * 9/(n - 1)
 return(cbind(x[, 1], g * (1 - sqrt(x[, 1]/g))))
}

#Not run:
## Not run: 
result &lt;- rmoo(type = "real-valued",
               fitness = zdt1,
               strategy = "NSGA-I",
               lower = c(0,0),
               upper = c(1,1),
               popSize = 100,
               dshare = 1,
               monitor = FALSE,
               maxiter = 500)


## End(Not run)

#Example 2
#Three Objectives - Real Valued
dtlz1 &lt;- function (x, nobj = 3, ...){
    if (is.null(dim(x))) {
        x &lt;- matrix(x, 1)
    }
    n &lt;- ncol(x)
    y &lt;- matrix(x[, 1:(nobj - 1)], nrow(x))
    z &lt;- matrix(x[, nobj:n], nrow(x))
    g &lt;- 100 * (n - nobj + 1 + rowSums((z - 0.5)^2 - cos(20 * pi * (z - 0.5))))
    tmp &lt;- t(apply(y, 1, cumprod))
    tmp &lt;- cbind(t(apply(tmp, 1, rev)), 1)
    tmp2 &lt;- cbind(1, t(apply(1 - y, 1, rev)))
    f &lt;- tmp * tmp2 * 0.5 * (1 + g)
    return(f)
}

#Not run:
## Not run: 
result &lt;- rmoo(type = "real-valued",
                fitness = dtlz1,
                strategy = "NSGA-II",
                lower = c(0,0,0),
                upper = c(1,1,1),
                popSize = 92,
                monitor = FALSE,
                maxiter = 500)

## End(Not run)
#Example 3
#Two Objectives - Real Valued
zdt1 &lt;- function (x, ...) {
 if (is.null(dim(x))) {
   x &lt;- matrix(x, nrow = 1)
 }
 n &lt;- ncol(x)
 g &lt;- 1 + rowSums(x[, 2:n, drop = FALSE]) * 9/(n - 1)
 return(cbind(x[, 1], g * (1 - sqrt(x[, 1]/g))))
}

#Not run
## Not run: 
result &lt;- rmoo(type = "real-valued",
                fitness = zdt1,
                strategy = "NSGA-III",
                lower = c(0,0),
                upper = c(1,1),
                popSize = 100,
                n_partitions = 100,
                monitor = FALSE,
                maxiter = 500)


## End(Not run)

#Example 4
#Three Objectives - Real Valued
dtlz1 &lt;- function (x, nobj = 3, ...){
  if (is.null(dim(x))) {
    x &lt;- matrix(x, 1)
  }
  n &lt;- ncol(x)
  y &lt;- matrix(x[, 1:(nobj - 1)], nrow(x))
  z &lt;- matrix(x[, nobj:n], nrow(x))
  g &lt;- 100 * (n - nobj + 1 + rowSums((z - 0.5)^2 - cos(20 * pi * (z - 0.5))))
  tmp &lt;- t(apply(y, 1, cumprod))
  tmp &lt;- cbind(t(apply(tmp, 1, rev)), 1)
  tmp2 &lt;- cbind(1, t(apply(1 - y, 1, rev)))
  f &lt;- tmp * tmp2 * 0.5 * (1 + g)
  return(f)
}

#Not Run
## Not run: 
result &lt;- rmoo(type = "real-valued",
                fitness = dtlz1,
                strategy = "NSGA-III",
                lower = c(0,0,0),
                upper = c(1,1,1),
                popSize = 92,
                n_partitions = 12,
                monitor = FALSE,
                maxiter = 500)

## End(Not run)

#Example 5
#Single Objective - Real Valued
f &lt;- function(x,  ...)  (x^2+x)*cos(x)

#Not Run
## Not run: 
result &lt;- rmoo(type = "real-valued",
               fitness = f,
               strategy = "GA",
               lower = -20,
               upper = 20,
               maxiter = 100)

## End(Not run)

</code></pre>

<hr>
<h2 id='scale_reference_directions'>Scale Reference Points</h2><span id='topic+scale_reference_directions'></span>

<h3>Description</h3>

<p>A implementation of Das and Dennis's Reference Points Generation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_reference_directions(ref_dirs, scaling)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_reference_directions_+3A_ref_dirs">ref_dirs</code>, <code id="scale_reference_directions_+3A_scaling">scaling</code></td>
<td>
<p>where 'ref_dirs' are the reference points generated and
'scaling' are the scale on which the points are distributed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The implemented Reference Point Generation is based on the Das and Dennis's
systematic approach that places points on a normalized hyper-plane which is
equally inclined to all objective axes and has an intercept of one on each axis.
</p>


<h3>Value</h3>

<p>A matrix with rescaled reference points uniformly distributed.
</p>


<h3>Author(s)</h3>

<p>Francisco Benitez
<a href="mailto:benitezfj94@gmail.com">benitezfj94@gmail.com</a>
</p>


<h3>References</h3>

<p>J. Blank and K. Deb, &quot;Pymoo: Multi-Objective Optimization in Python,&quot; in
IEEE Access, vol. 8, pp. 89497-89509, 2020, doi: 10.1109/ACCESS.2020.2990567.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generate_reference_points">generate_reference_points()</a></code> and <code><a href="#topic+get_fixed_rowsum_integer_matrix">get_fixed_rowsum_integer_matrix()</a></code>
</p>

<hr>
<h2 id='sharing'>Calculation of Dummy Fitness</h2><span id='topic+sharing'></span>

<h3>Description</h3>

<p>Calculate of sharing distance and dummy fitness
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sharing(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sharing_+3A_object">object</code></td>
<td>
<p>An object of class 'nsga', usually resulting from a call to
function nsga. Fitness Function Objective Numbers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sharing distance operator guides the selection process at the various
stages of the algorithm toward a uniformly spread-out Pareto-optimal front
</p>


<h3>Value</h3>

<p>A vector with the dummy fitness.
</p>


<h3>Author(s)</h3>

<p>Francisco Benitez
<a href="mailto:benitezfj94@gmail.com">benitezfj94@gmail.com</a>
</p>


<h3>References</h3>

<p>N. Srinivas and K. Deb, 'Multiobjective Optimization Using
Nondominated Sorting in Genetic Algorithms,' in Evolutionary Computation,
vol. 2, no. 3, pp. 221-248, Sept. 1994, doi: 10.1162/evco.1994.2.3.221.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+non_dominated_fronts">non_dominated_fronts()</a></code>
</p>

<hr>
<h2 id='summary'>Methods for Function 'summary' in Package 'rmoo'</h2><span id='topic+summary'></span><span id='topic+summary+2Cnsga-method'></span><span id='topic+summary+2Cnsga+2Cnsga-method'></span><span id='topic+summary+2Cnsga1-method'></span><span id='topic+summary+2Cnsga2-method'></span><span id='topic+summary+2Cnsga3-method'></span>

<h3>Description</h3>

<p>Method used to summarize the results of the evaluations, passing additional
arguments in the summary method the performance metrics is evaluated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary(object, ...)

## S4 method for signature 'nsga'
summary(object, ...)

## S4 method for signature 'nsga1'
summary(object, ...)

## S4 method for signature 'nsga2'
summary(object, ...)

## S4 method for signature 'nsga3'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary_+3A_object">object</code></td>
<td>
<p>Objects of either class <a href="#topic+nsga1-class">nsga1</a>,
<a href="#topic+nsga2-class">nsga2</a>,  or <a href="#topic+nsga3-class">nsga3</a>.</p>
</td></tr>
<tr><td><code id="summary_+3A_...">...</code></td>
<td>
<p>other arguments passed on to methods. Passing <code>"reference_dirs"</code>
as arguments will evaluate the performance metrics Hypervolumen,
Generational Distance, and Inverse Generational Distance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A summary of the values resulting from the execution of an algorithm.
</p>


<h3>Author(s)</h3>

<p>Francisco Benitez
<a href="mailto:benitezfj94@gmail.com">benitezfj94@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Where 'out' is an object of class nsga1, nsga2, or nsga3
#
# summary(out)
#
# For the evaluation of the metrics, pass the reference point
#
# ref_points &lt;- generate_reference_points(3,12)
# summary(out, reference_dirs = ref_points)

</code></pre>

<hr>
<h2 id='update_points'>Adaptive normalization of population members</h2><span id='topic+update_points'></span><span id='topic+UpdateIdealPoint'></span><span id='topic+UpdateWorstPoint'></span><span id='topic+PerformScalarizing'></span><span id='topic+get_nadir_point'></span>

<h3>Description</h3>

<p>Functions to scalarize the members of the population to locate them in a normalized hyperplane, finding the ideal point, nadir point, worst point and the extreme points.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  UpdateIdealPoint(object, nObj)
  UpdateWorstPoint(object, nObj)
  PerformScalarizing(population, fitness, smin, extreme_points, ideal_point)
  get_nadir_point(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update_points_+3A_object">object</code></td>
<td>
<p>An object of class <code>"nsga3"</code>.</p>
</td></tr>
<tr><td><code id="update_points_+3A_nobj">nObj</code></td>
<td>
<p>numbers of objective values of the function to evaluate.</p>
</td></tr>
<tr><td><code id="update_points_+3A_population">population</code></td>
<td>
<p>individuals of the population until last front.</p>
</td></tr>
<tr><td><code id="update_points_+3A_fitness">fitness</code></td>
<td>
<p>objective values of the population until last front.</p>
</td></tr>
<tr><td><code id="update_points_+3A_smin">smin</code></td>
<td>
<p>Achievement Escalation Function Index.</p>
</td></tr>
<tr><td><code id="update_points_+3A_extreme_points">extreme_points</code></td>
<td>
<p>Extreme points of the previous generation to upgrade.</p>
</td></tr>
<tr><td><code id="update_points_+3A_ideal_point">ideal_point</code></td>
<td>
<p>Ideal point of the current generation to translate objectives.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return scalarized objective values in a normalized hyperplane.</p>


<h3>Author(s)</h3>

<p>Francisco Benitez</p>


<h3>References</h3>

<p>J. Blank and K. Deb, &quot;Pymoo: Multi-Objective Optimization in Python,&quot; in IEEE Access, vol. 8, pp. 89497-89509, 2020, doi: 10.1109/ACCESS.2020.2990567.
</p>
<p>K. Deb and H. Jain, &quot;An Evolutionary Many-Objective Optimization Algorithm Using Reference-Point-Based Nondominated Sorting Approach, Part I: Solving Problems With Box Constraints,&quot; in IEEE Transactions on Evolutionary Computation, vol. 18, no. 4, pp. 577-601, Aug. 2014, doi: 10.1109/TEVC.2013.2281535.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
