<!DOCTYPE html><html><head><title>Help for package seeds</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {seeds}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#seeds-package'><p>seeds: Estimate Hidden Inputs using the Dynamic Elastic Net</p></a></li>
<li><a href='#BDEN'><p>Bayesian Dynamic Elastic Net</p></a></li>
<li><a href='#confidenceBands'><p>Get the estimated confidence bands for the bayesian method</p></a></li>
<li><a href='#createCompModel'><p>Create compilable c-code of a model</p></a></li>
<li><a href='#DEN'><p>Greedy method for estimating a sparse solution</p></a></li>
<li><a href='#estiStates'><p>Get the estimated states</p></a></li>
<li><a href='#GIBBS_update'><p>Gibbs Update</p></a></li>
<li><a href='#hiddenInputs'><p>Get the estimated hidden inputs</p></a></li>
<li><a href='#importSBML'><p>Import SBML Models using the Bioconductor package 'rsbml'</p></a></li>
<li><a href='#LOGLIKELIHOOD_func'><p>Calculates the Log Likelihood for a new sample given the current state (i.e. log[L(G|x)P(G)])</p></a></li>
<li><a href='#MCMC_component'><p>Componentwise Adapted Metropolis Hastings Sampler</p></a></li>
<li><a href='#Model'><p>Test dataset  for demonstrating the bden algorithm.</p></a></li>
<li><a href='#nominalSol'><p>Calculate the nominal solution of the model</p></a></li>
<li><a href='#odeEquations-class'><p>A S4 class used to handle formatting ODE-Equation and calculate the needed functions for the seeds-algorithm</p></a></li>
<li><a href='#odeModel-class'><p>A class to store the important information of an model.</p></a></li>
<li><a href='#optimal_control_gradient_descent'><p>estimating the optimal control using the dynamic elastic net</p></a></li>
<li><a href='#outputEstimates'><p>Get the estimated outputs</p></a></li>
<li><a href='#plot+2CresultsSeeds+2Cmissing-method'><p>Plot method for the S4 class resultsSeeds</p></a></li>
<li><a href='#plotAnno'><p>Create annotated plot</p></a></li>
<li><a href='#print+2CresultsSeeds-method'><p>A default printing function for the resultsSeeds class</p></a></li>
<li><a href='#res'><p>Results from the uvb dataset for examples</p></a></li>
<li><a href='#resultsSeeds-class'><p>Results Class for the Algorithms</p></a></li>
<li><a href='#setInitState'><p>Set the vector with the initial (state) values</p></a></li>
<li><a href='#setInput'><p>Set the inputs of the model.</p></a></li>
<li><a href='#setMeas'><p>set measurements of the model</p></a></li>
<li><a href='#setMeasFunc'><p>Set the measurement equation for the model</p></a></li>
<li><a href='#setModelEquation'><p>Set the model equation</p></a></li>
<li><a href='#setParms'><p>Set the model parameters</p></a></li>
<li><a href='#setSd'><p>Set the standard deviation of the measurements</p></a></li>
<li><a href='#SETTINGS'><p>Automatic Calculation of optimal Initial Parameters</p></a></li>
<li><a href='#uvbData'><p>UVB signal pathway</p></a></li>
<li><a href='#uvbModel'><p>An object of the odeModel Class</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Estimate Hidden Inputs using the Dynamic Elastic Net</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Algorithms to calculate the hidden inputs of systems of differential equations. 
  These hidden inputs can be interpreted as a control that tries to minimize the
  discrepancies between a given model and taken measurements. The idea is 
  also called the Dynamic Elastic Net, as proposed in the paper "Learning (from) the errors of a systems biology model" 
  (Engelhardt, Froelich, Kschischo 2016) &lt;<a href="https://doi.org/10.1038%2Fsrep20772">doi:10.1038/srep20772</a>&gt;.
  To use the experimental SBML import function, the 'rsbml' package is required. For installation I refer to the official 'rsbml' page: <a href="https://bioconductor.org/packages/release/bioc/html/rsbml.html">https://bioconductor.org/packages/release/bioc/html/rsbml.html</a>.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tobias Newmiwaka &lt;tobias.newmiwaka@gmail.com&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Newmi1988/seeds">https://github.com/Newmi1988/seeds</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Newmi1988/seeds/issues">https://github.com/Newmi1988/seeds/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>deSolve (&ge; 1.20), pracma (&ge; 2.1.4), Deriv (&ge; 3.8.4),
Ryacas, stats, graphics, methods, mvtnorm, matrixStats,
statmod, coda, MASS, ggplot2, tidyr, dplyr, Hmisc, R.utils,
callr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, rsbml</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-07-13 18:13:14 UTC; newmi</td>
</tr>
<tr>
<td>Author:</td>
<td>Tobias Newmiwaka [aut, cre],
  Benjamin Engelhardt [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-07-14 00:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='seeds-package'>seeds: Estimate Hidden Inputs using the Dynamic Elastic Net</h2><span id='topic+seeds'></span><span id='topic+seeds-package'></span>

<h3>Description</h3>

<p>Algorithms to calculate the hidden inputs of systems of differential equations. 
These hidden inputs can be interpreted as a control that tries to minimize the
discrepancies between a given model and taken measurements. The idea is 
also called the Dynamic Elastic Net, as proposed in the paper &quot;Learning (from) the errors of a systems biology model&quot; 
(Engelhardt, Froelich, Kschischo 2016) &lt;doi:10.1038/srep20772&gt;.
To use the experimental SBML import function, the 'rsbml' package is required. For installation I refer to the official 'rsbml' page: &lt;https://bioconductor.org/packages/release/bioc/html/rsbml.html&gt;.
</p>


<h3>Details</h3>

<p>Details
</p>
<p>The first algorithm (DEN) calculates the needed equations using the <code><a href="Deriv.html#topic+Deriv">Deriv</a></code>
function of the <span class="pkg">Deriv</span> package. The process is implemented through the use
of the S4 class <code><a href="#topic+odeEquations-class">odeEquations-class</a></code>. 
</p>
<p>The conjugate gradient based algorithm uses a greedy algorithm to estimate a 
sparse control that tries to minimize the discrepancies between a given 
'nominal model given the measurements (e.g from an experiment). The algorithm
the <code><a href="deSolve.html#topic+ode">ode</a></code> uses <span class="pkg">deSolve</span> to calculate the hidden inputs w 
based on the adjoint equations of the ODE-System. 
</p>
<p>The adjoint equations are calculated using the <code><a href="deSolve.html#topic+ode">ode</a></code> function of the 
<span class="pkg">deSolve</span> package. For the usage of the algorithm please look into the 
examples and documentation given for the functions.
</p>
<p>The second algorithm is called Bayesian Dynamic Elastic Net (BDEN).
The BDEN as a new and fully probabilistic approach, supports the modeler in an 
algorithmic manner to identify possible sources of errors in ODE based models on 
the basis of experimental data.  THE BDEN does not require pre-specified hyper-parameters. 
BDEN thus provides a systematic Bayesian computational method to identify target nodes and 
reconstruct the corresponding error signal including detection of missing and 
wrong molecular interactions within the assumed model. The method works for ODE 
based systems even with uncertain knowledge and noisy data. 
</p>

<dl>
<dt><code><a href="#topic+DEN">DEN</a></code></dt><dd><p>a greedy algorithm to calculate a sparse control</p>
</dd>
<dt><code><a href="#topic+BDEN">BDEN</a></code></dt><dd><p>a basian mcmc approach</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Tobias Newmiwaka <a href="mailto:tobias.newmiwaka@gmail.com">tobias.newmiwaka@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Benjamin Engelhardt <a href="mailto:engelhar@bit.uni-bonn.de">engelhar@bit.uni-bonn.de</a>
</p>
</li></ul>



<h3>References</h3>

<p><strong>Benjamin Engelhardt, Holger Froehlich, Maik Kschischo</strong> 
Learning (from) the errors of a systems biology model, <em>Nature Scientific Reports</em>,
6, 20772, 2016 <a href="https://www.nature.com/articles/srep20772">https://www.nature.com/articles/srep20772</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/Newmi1988/seeds">https://github.com/Newmi1988/seeds</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/Newmi1988/seeds/issues">https://github.com/Newmi1988/seeds/issues</a>
</p>
</li></ul>


<hr>
<h2 id='BDEN'>Bayesian Dynamic Elastic Net</h2><span id='topic+BDEN'></span>

<h3>Description</h3>

<p>Full Bayesian algorithm to detect hidden inputs in ODE based models.The algorithm 
is an extension of the Dynamic Elastic Net algorithm (Engelhardt et al. 2016) inspired by the Elastic-Net Regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BDEN(
  odeModel,
  settings,
  mcmc_component,
  loglikelihood_func,
  gibbs_update,
  ode_sol,
  NegativeStates = FALSE,
  numbertrialsstep = 15,
  numbertrialseps = NA,
  numbertrialinner = 25,
  lambda = 0.001,
  Grad_correct = 0,
  alpha = c(1, 1, 1, 1),
  beta_init = c(1, 1, 1, 1),
  printstatesignore = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BDEN_+3A_odemodel">odeModel</code></td>
<td>
<p>a object of class odeModel from the package seeds. The class saves the details of an experiment for easier manipulation and analysis.</p>
</td></tr>
<tr><td><code id="BDEN_+3A_settings">settings</code></td>
<td>
<p>initial model specific settings (automatically calculated based on the nominal model and data)</p>
</td></tr>
<tr><td><code id="BDEN_+3A_mcmc_component">mcmc_component</code></td>
<td>
<p>sampling algorithm</p>
</td></tr>
<tr><td><code id="BDEN_+3A_loglikelihood_func">loglikelihood_func</code></td>
<td>
<p>likelihood function</p>
</td></tr>
<tr><td><code id="BDEN_+3A_gibbs_update">gibbs_update</code></td>
<td>
<p>gibbs algorithm</p>
</td></tr>
<tr><td><code id="BDEN_+3A_ode_sol">ode_sol</code></td>
<td>
<p>ode solver</p>
</td></tr>
<tr><td><code id="BDEN_+3A_negativestates">NegativeStates</code></td>
<td>
<p>Negative states are allowed</p>
</td></tr>
<tr><td><code id="BDEN_+3A_numbertrialsstep">numbertrialsstep</code></td>
<td>
<p>number of gibbs updates per timepoint. This should be at least 10. Values have direct influence on the runtime.</p>
</td></tr>
<tr><td><code id="BDEN_+3A_numbertrialseps">numbertrialseps</code></td>
<td>
<p>number of samples per mcmc step. This should be greater than numberStates*500.Values have direct influence on the runtime.</p>
</td></tr>
<tr><td><code id="BDEN_+3A_numbertrialinner">numbertrialinner</code></td>
<td>
<p>number of inner samples. This should be greater 15 to guarantee a reasonable exploration of the sample space. Values have direct influnce on the runtime.</p>
</td></tr>
<tr><td><code id="BDEN_+3A_lambda">lambda</code></td>
<td>
<p>initial shrinkage parameter.</p>
</td></tr>
<tr><td><code id="BDEN_+3A_grad_correct">Grad_correct</code></td>
<td>
<p>correction factor for initial sigma estimate</p>
</td></tr>
<tr><td><code id="BDEN_+3A_alpha">alpha</code></td>
<td>
<p>mcmc tuning parameter (weighting of observed states)</p>
</td></tr>
<tr><td><code id="BDEN_+3A_beta_init">beta_init</code></td>
<td>
<p>mcmc tuning parameter (weighting of observed states)</p>
</td></tr>
<tr><td><code id="BDEN_+3A_printstatesignore">printstatesignore</code></td>
<td>
<p>states ignored in final output (default = FALSE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Ordinary differential equations (ODEs) are a popular approach to quantitatively model molecular networks based on biological knowledge. 
However, such knowledge is typically restricted. Wrongly modeled biological mechanisms as well as relevant external influence factors 
that are not included into the model likely manifest in major discrepancies between model predictions and experimental data. 
Finding the exact reasons for such observed discrepancies can be quite challenging in practice. 
In order to address this issue we suggest a Bayesian approach to estimate hidden influences in ODE based models. 
The method can distinguish between exogenous and endogenous hidden influences. Thus, we can detect wrongly specified as well as missed 
molecular interactions in the model. 
The BDEN as a new and fully probabilistic approach, supports the modeler in an algorithmic manner to identify possible sources of errors 
in ODE based models on the basis of experimental data.  THE BDEN does not require pre-specified hyper-parameters. 
BDEN thus provides a systematic Bayesian computational method to identify target nodes and reconstruct the corresponding 
error signal including detection of missing and wrong molecular interactions within the assumed model. 
The method works for ODE based systems even with uncertain knowledge and noisy data. 
In contrast to approaches based on point estimates the Bayesian framework incorporates the given uncertainty and circumvents 
numerical pitfalls which frequently arise from optimization methods (Engelhardt et al. 2017).
</p>
<p>For a complete example of the usage take a look into the vignette of the package.
</p>


<h3>Value</h3>

<p>returns a results-object with default plot function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(bden_uvb)

results &lt;- BDEN(odeModel          = Model,
                lambda            = .001,
                beta_init         = c(1,1,1,1,1),
                numbertrialsstep  = 15,
                numbertrialseps   = 2000,
                numbertrialinner  = 10)

</code></pre>

<hr>
<h2 id='confidenceBands'>Get the estimated confidence bands for the bayesian method</h2><span id='topic+confidenceBands'></span><span id='topic+confidenceBands+2Clist+2Ccharacter+2Cnumeric-method'></span><span id='topic+confidenceBands+2Clist+2Ccharacter+2Cmissing-method'></span><span id='topic+confidenceBands+2CresultsSeeds+2Ccharacter+2Cmissing-method'></span>

<h3>Description</h3>

<p>Get the estimated confidence bands for the bayesian method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>confidenceBands(resultsSeeds, slot, ind)

## S4 method for signature 'list,character,numeric'
confidenceBands(resultsSeeds, slot, ind)

## S4 method for signature 'list,character,missing'
confidenceBands(resultsSeeds, slot, ind)

## S4 method for signature 'resultsSeeds,character,missing'
confidenceBands(resultsSeeds, slot, ind)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confidenceBands_+3A_resultsseeds">resultsSeeds</code></td>
<td>
<p>A object of the class resultsSeeds, which is returned from the algorithms.</p>
</td></tr>
<tr><td><code id="confidenceBands_+3A_slot">slot</code></td>
<td>
<p>Specifies the slot. Options are &quot;states&quot;, &quot;hiddenInputs&quot;, &quot;outputs&quot;</p>
</td></tr>
<tr><td><code id="confidenceBands_+3A_ind">ind</code></td>
<td>
<p>A numeric indicating the index of a resultsSeeds-Object in a list. If not set the last listed object will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe containing the confidence bands of the estiamted states, hidden inputs and outputs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(uvb_res)

confidenceBands(res, slot = "states", ind = 2) 

</code></pre>

<hr>
<h2 id='createCompModel'>Create compilable c-code of a model</h2><span id='topic+createCompModel'></span>

<h3>Description</h3>

<p>Writes a c file that can be compiled for faster solution with the <code><a href="deSolve.html#topic+ode">ode</a></code> solver.
The file created is formatted to be used with the dynamic elastic net. A hidden input is 
added to every component of the state vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createCompModel(modelFunc, parameters, bden, nnStates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createCompModel_+3A_modelfunc">modelFunc</code></td>
<td>
<p>a R-function that can be solved with deSolve. External input of the system should
be declared with 'u'. To ensure that the function is working use the most general
state-space representation.</p>
</td></tr>
<tr><td><code id="createCompModel_+3A_parameters">parameters</code></td>
<td>
<p>a vector describing the parameters of the system. If names are missing the function
tries to extract the declared parameters from the model function.</p>
</td></tr>
<tr><td><code id="createCompModel_+3A_bden">bden</code></td>
<td>
<p>a boolean that indicates if the c-file is used for the mcmc algorithm, default value is 'FALSE'</p>
</td></tr>
<tr><td><code id="createCompModel_+3A_nnstates">nnStates</code></td>
<td>
<p>a bit vector indicating the states that should be non negative</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Note</h3>

<p>On the usage of compiled code in conjunction with <span class="pkg">deSolve</span> take a look into the vignette 'R
Package deSolve, Writing Code in Compiled Languages' of the package.
</p>

<hr>
<h2 id='DEN'>Greedy method for estimating a sparse solution</h2><span id='topic+DEN'></span>

<h3>Description</h3>

<p>The sparse gradient dynamic elastic net calculates controls based on a first optimization with gradient descent. IT should 
result in a sparse vector of hidden inputs. These hidden inputs try to minimize the discrepancy between a given model and the taken measurements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DEN(
  odeModel,
  alphaStep,
  Beta,
  alpha1,
  alpha2,
  x0,
  optW,
  measFunc,
  measData,
  sd,
  epsilon,
  parameters,
  systemInput,
  modelFunc,
  greedyLogical,
  plotEstimates,
  conjGrad,
  cString,
  nnStates,
  verbose
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DEN_+3A_odemodel">odeModel</code></td>
<td>
<p>a object of class <code><a href="#topic+odeModel">odeModel</a></code> from the package seeds. The class saves the details of an experiment for easier manipulation and analysis.</p>
</td></tr>
<tr><td><code id="DEN_+3A_alphastep">alphaStep</code></td>
<td>
<p>the starting stepsize for the gradient descent
a fitting stepsize will be calculated based on a backtracking line search
if the algorithm converges to slow use a bigger stepsize</p>
</td></tr>
<tr><td><code id="DEN_+3A_beta">Beta</code></td>
<td>
<p>scaling parameter for the backtracking to approximate the stepsize of the gradient descent. Is set to  0.8
if no value is given to the function</p>
</td></tr>
<tr><td><code id="DEN_+3A_alpha1">alpha1</code></td>
<td>
<p>L1-norm parameter of the dynamic elastic net approach, is set to zero for this algorithm</p>
</td></tr>
<tr><td><code id="DEN_+3A_alpha2">alpha2</code></td>
<td>
<p>L2-norm parameter of the dynamic elastic net approach
used for regulation purposes</p>
</td></tr>
<tr><td><code id="DEN_+3A_x0">x0</code></td>
<td>
<p>initial state of the ODE system. Can be supplied with  the odeModel class.</p>
</td></tr>
<tr><td><code id="DEN_+3A_optw">optW</code></td>
<td>
<p>a vector that indicates for which knots of the network a input should be calculated. The default is all nodes.</p>
</td></tr>
<tr><td><code id="DEN_+3A_measfunc">measFunc</code></td>
<td>
<p>a R-Function that is used for measurement of the states if the system is not completely
measurable; an empty argument will result in the assumption that all states of the system are
measurable. Can be supplied by the odeModel parameter.</p>
</td></tr>
<tr><td><code id="DEN_+3A_measdata">measData</code></td>
<td>
<p>a table that contains the measurements of the experiment. Used to calculate the needed inputs. Can be supplied with  the odeModel class.</p>
</td></tr>
<tr><td><code id="DEN_+3A_sd">sd</code></td>
<td>
<p>Standard deviation of the measurement. Is used to weight the errors of the estimates in the cost function. Optional parameter. Can be supplied with  the odeModel class. Should contain the time in the first column</p>
</td></tr>
<tr><td><code id="DEN_+3A_epsilon">epsilon</code></td>
<td>
<p>parameter that defines the stopping criteria for the algorithm, in this case percent change in cost function J[w]</p>
</td></tr>
<tr><td><code id="DEN_+3A_parameters">parameters</code></td>
<td>
<p>vector or named vector that contains the parameters of the ODE equation. Can be supplied with  the odeModel class.</p>
</td></tr>
<tr><td><code id="DEN_+3A_systeminput">systemInput</code></td>
<td>
<p>A dataset that describes the external input of the system. The time steps should be given in the first column for the interpolation.</p>
</td></tr>
<tr><td><code id="DEN_+3A_modelfunc">modelFunc</code></td>
<td>
<p>a R-Function that states the ODE system for which the hidden inputs should be calculated. Can be supplied with  the odeModel class.</p>
</td></tr>
<tr><td><code id="DEN_+3A_greedylogical">greedyLogical</code></td>
<td>
<p>a boolean that states if the greedy approach should be used;if set to FALSE the algorithm
will only use perform a calculation of the inputs for all knots without a sparse solution</p>
</td></tr>
<tr><td><code id="DEN_+3A_plotestimates">plotEstimates</code></td>
<td>
<p>boolean that indicated if the current estimate should be plotted.</p>
</td></tr>
<tr><td><code id="DEN_+3A_conjgrad">conjGrad</code></td>
<td>
<p>Boolean that indicates the usage of conjugate gradient method over the normal steepest descent. Defaults to true if not specified.</p>
</td></tr>
<tr><td><code id="DEN_+3A_cstring">cString</code></td>
<td>
<p>Optional parameter: A string that represents constants, can be used to calculate a hidden input for a component that gradient is zero.</p>
</td></tr>
<tr><td><code id="DEN_+3A_nnstates">nnStates</code></td>
<td>
<p>A bit vector indicating the states that should be non negative. Default behaviour will calculate positive and negative states. Can be supplied with  the odeModel class.</p>
</td></tr>
<tr><td><code id="DEN_+3A_verbose">verbose</code></td>
<td>
<p>Boolean indicating if an output in the console should be created to display the gradient descent steps</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm uses a greedy approach to calculate the hidden inputs. Starting with a first estimation of the hidden inputs
the algorithm tries to optimize set of hidden inputs based on the area under the curve from the first run. The algorithm stops 
if a set of hidden gives a lower cost than a set with additional hidden inputs. 
</p>
<p>For a complete example of the usage take a look into the vignette of the package.
</p>


<h3>Value</h3>

<p>returns a list of results objects. The default plot function can be used to plot the results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(uvbModel)

results &lt;- DEN(odeModel = uvbModel, alphaStep = 500, alpha2 = 0.0001,
                epsilon = 0.2, plotEstimates = TRUE)


</code></pre>

<hr>
<h2 id='estiStates'>Get the estimated states</h2><span id='topic+estiStates'></span><span id='topic+estiStates+2Clist+2Cnumeric-method'></span><span id='topic+estiStates+2Clist+2Cmissing-method'></span><span id='topic+estiStates+2CresultsSeeds+2Cmissing-method'></span>

<h3>Description</h3>

<p>Get the estimated states
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estiStates(resultsSeeds, ind)

## S4 method for signature 'list,numeric'
estiStates(resultsSeeds, ind)

## S4 method for signature 'list,missing'
estiStates(resultsSeeds, ind)

## S4 method for signature 'resultsSeeds,missing'
estiStates(resultsSeeds, ind)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estiStates_+3A_resultsseeds">resultsSeeds</code></td>
<td>
<p>A object of the class resultsSeeds, which is returned from the algorithms.</p>
</td></tr>
<tr><td><code id="estiStates_+3A_ind">ind</code></td>
<td>
<p>A numeric indicating the index of a resultsSeeds-Object in a list. If not set the last listed object will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe containing the estimated states
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(uvb_res)

estiStates(res)

</code></pre>

<hr>
<h2 id='GIBBS_update'>Gibbs Update</h2><span id='topic+GIBBS_update'></span>

<h3>Description</h3>

<p>Algorithm implemented according to Engelhardt et al. 2017. The BDEN defines a conditional Gaussian prior 
over each hidden input. The scale of the variance of the Gaussian prior is a strongly decaying and smooth 
distribution peaking at zero, which depends on parameters Lambda2, Tau and Sigma. The parameter Tau is itself 
given by an exponential distribution (one for each component of the hidden influence vector) with parameters 
Lambda1. In consequence, sparsity is dependent on the parameter vector Lambda1, whereas smoothness is 
mainly controlled by Lambda2. These parameters are drawn from hyper-priors, which can be set in a non-informative 
manner or with respect to prior knowledge about the degree of shrinkage and smoothness of the hidden influences (Engelhardt et al. 2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GIBBS_update(D, EPS_inner, R, ROH, SIGMA_0, n, SIGMA, LAMBDA2, LAMBDA1, TAU)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GIBBS_update_+3A_d">D</code></td>
<td>
<p>diagonal weight matrix of the current Gibbs step</p>
</td></tr>
<tr><td><code id="GIBBS_update_+3A_eps_inner">EPS_inner</code></td>
<td>
<p>row-wise vector of current hidden influences [tn,tn+1]</p>
</td></tr>
<tr><td><code id="GIBBS_update_+3A_r">R</code></td>
<td>
<p>parameter for needed for the Gibbs update (for details see Engelhardt et al. 2017)</p>
</td></tr>
<tr><td><code id="GIBBS_update_+3A_roh">ROH</code></td>
<td>
<p>parameter for needed for the Gibbs update (for details see Engelhardt et al. 2017)</p>
</td></tr>
<tr><td><code id="GIBBS_update_+3A_sigma_0">SIGMA_0</code></td>
<td>
<p>prior variance of the prior for the hidden influences</p>
</td></tr>
<tr><td><code id="GIBBS_update_+3A_n">n</code></td>
<td>
<p>number of system states</p>
</td></tr>
<tr><td><code id="GIBBS_update_+3A_sigma">SIGMA</code></td>
<td>
<p>current variance of the prior for the hidden influences (calculated during the Gibbs update)</p>
</td></tr>
<tr><td><code id="GIBBS_update_+3A_lambda2">LAMBDA2</code></td>
<td>
<p>current parameter (smoothness) needed for the Gibbs update (for details see Engelhardt et al. 2017)</p>
</td></tr>
<tr><td><code id="GIBBS_update_+3A_lambda1">LAMBDA1</code></td>
<td>
<p>current parameter (sparsity)  needed for the Gibbs update (for details see Engelhardt et al. 2017)</p>
</td></tr>
<tr><td><code id="GIBBS_update_+3A_tau">TAU</code></td>
<td>
<p>current parameter (smoothness) needed for the Gibbs update (for details see Engelhardt et al. 2017)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function can be replaced by an user defined version if necessary
</p>


<h3>Value</h3>

<p>A list of updated Gibbs parameters; i.e. Sigma, Lambda1, Lambda2, Tau
</p>

<hr>
<h2 id='hiddenInputs'>Get the estimated hidden inputs</h2><span id='topic+hiddenInputs'></span><span id='topic+hiddenInputs+2Clist+2Cnumeric-method'></span><span id='topic+hiddenInputs+2Clist+2Cmissing-method'></span><span id='topic+hiddenInputs+2CresultsSeeds+2Cmissing-method'></span>

<h3>Description</h3>

<p>Get the estimated hidden inputs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hiddenInputs(resultsSeeds, ind)

## S4 method for signature 'list,numeric'
hiddenInputs(resultsSeeds, ind)

## S4 method for signature 'list,missing'
hiddenInputs(resultsSeeds, ind)

## S4 method for signature 'resultsSeeds,missing'
hiddenInputs(resultsSeeds, ind)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hiddenInputs_+3A_resultsseeds">resultsSeeds</code></td>
<td>
<p>A object of the class 'resultsSeeds', which is returned from the algorithms.</p>
</td></tr>
<tr><td><code id="hiddenInputs_+3A_ind">ind</code></td>
<td>
<p>A numeric indicating the index of a 'resultsSeeds'-Object in a list. If not set the last listed object will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dataframe containing the estimated hidden inputs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(uvb_res)

hiddenInputs(res[[2]])

</code></pre>

<hr>
<h2 id='importSBML'>Import SBML Models using the Bioconductor package 'rsbml'</h2><span id='topic+importSBML'></span>

<h3>Description</h3>

<p>A simple function for importing sbml models from a extensive markup language file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>importSBML(filename, times, meas_input)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="importSBML_+3A_filename">filename</code></td>
<td>
<p>name of the import file. Should be located in the working directory.</p>
</td></tr>
<tr><td><code id="importSBML_+3A_times">times</code></td>
<td>
<p>timestep at which the function should be evaluated</p>
</td></tr>
<tr><td><code id="importSBML_+3A_meas_input">meas_input</code></td>
<td>
<p>measurements have to be given in order to analyze the data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a odeModel object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run:  

t &lt;- uvbData[,1]
y &lt;- uvbData[,1:3]
modelFile &lt;- system.file("extdata","BIOMD0000000545_url.xml", package = "seeds")

# generate an odeModel object
uvb &lt;- importSBML(modelFile, times = t, meas = y)


## End(Not run)

</code></pre>

<hr>
<h2 id='LOGLIKELIHOOD_func'>Calculates the Log Likelihood for a new sample given the current state (i.e. log[L(G|x)P(G)])</h2><span id='topic+LOGLIKELIHOOD_func'></span>

<h3>Description</h3>

<p>Algorithm implemented according to Engelhardt et al. 2017.
The function can be replaced by an user defined version if necessary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LOGLIKELIHOOD_func(
  pars,
  Step,
  OBSERVATIONS,
  x_0,
  parameters,
  EPS_inner,
  INPUT,
  D,
  GIBBS_PAR,
  k,
  MU_JUMP,
  SIGMA_JUMP,
  eps_new,
  objectivfunc
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LOGLIKELIHOOD_func_+3A_pars">pars</code></td>
<td>
<p>sampled hidden influence for state k (w_new) at time tn+1</p>
</td></tr>
<tr><td><code id="LOGLIKELIHOOD_func_+3A_step">Step</code></td>
<td>
<p>time step of the sample algorithm corresponding to the given vector of time points</p>
</td></tr>
<tr><td><code id="LOGLIKELIHOOD_func_+3A_observations">OBSERVATIONS</code></td>
<td>
<p>observed values at the given time step/point</p>
</td></tr>
<tr><td><code id="LOGLIKELIHOOD_func_+3A_x_0">x_0</code></td>
<td>
<p>initial values at the given time step/point</p>
</td></tr>
<tr><td><code id="LOGLIKELIHOOD_func_+3A_parameters">parameters</code></td>
<td>
<p>model parameters estimates</p>
</td></tr>
<tr><td><code id="LOGLIKELIHOOD_func_+3A_eps_inner">EPS_inner</code></td>
<td>
<p>current hidden inputs at time tn</p>
</td></tr>
<tr><td><code id="LOGLIKELIHOOD_func_+3A_input">INPUT</code></td>
<td>
<p>discrete input function e.g. stimuli</p>
</td></tr>
<tr><td><code id="LOGLIKELIHOOD_func_+3A_d">D</code></td>
<td>
<p>diagonal weight matrix of the current Gibbs step</p>
</td></tr>
<tr><td><code id="LOGLIKELIHOOD_func_+3A_gibbs_par">GIBBS_PAR</code></td>
<td>
<p>GIBBS_PAR[[&quot;BETA&quot;]] and GIBBS_PAR[[&quot;ALPHA&quot;]]; prespecified or calculated vector of state weights</p>
</td></tr>
<tr><td><code id="LOGLIKELIHOOD_func_+3A_k">k</code></td>
<td>
<p>number state corresponding to the given hidden influence (w_new)</p>
</td></tr>
<tr><td><code id="LOGLIKELIHOOD_func_+3A_mu_jump">MU_JUMP</code></td>
<td>
<p>mean of the normal distributed proposal distribution</p>
</td></tr>
<tr><td><code id="LOGLIKELIHOOD_func_+3A_sigma_jump">SIGMA_JUMP</code></td>
<td>
<p>variance of the normal distributed proposal distribution</p>
</td></tr>
<tr><td><code id="LOGLIKELIHOOD_func_+3A_eps_new">eps_new</code></td>
<td>
<p>current sample vector of the hidden influences (including all states)</p>
</td></tr>
<tr><td><code id="LOGLIKELIHOOD_func_+3A_objectivfunc">objectivfunc</code></td>
<td>
<p>link function to match observations with modeled states</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the log-likelihood for two given hidden inputs
</p>

<hr>
<h2 id='MCMC_component'>Componentwise Adapted Metropolis Hastings Sampler</h2><span id='topic+MCMC_component'></span>

<h3>Description</h3>

<p>Algorithm implemented according to Engelhardt et al. 2017.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MCMC_component(
  LOGLIKELIHOOD_func,
  STEP_SIZE,
  STEP_SIZE_INNER,
  EPSILON,
  JUMP_SCALE,
  STEP,
  OBSERVATIONS,
  Y0,
  INPUTDATA,
  PARAMETER,
  EPSILON_ACT,
  SIGMA,
  DIAG,
  GIBBS_par,
  N,
  BURNIN,
  objective
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MCMC_component_+3A_loglikelihood_func">LOGLIKELIHOOD_func</code></td>
<td>
<p>likelihood function</p>
</td></tr>
<tr><td><code id="MCMC_component_+3A_step_size">STEP_SIZE</code></td>
<td>
<p>number of samples per mcmc step. This should be greater than numberStates*500.Values have direct influence on the runtime.</p>
</td></tr>
<tr><td><code id="MCMC_component_+3A_step_size_inner">STEP_SIZE_INNER</code></td>
<td>
<p>number of inner samples. This should be greater 15 to guarantee a reasonable exploration of the sample space. Values have direct influnce on the runtime.</p>
</td></tr>
<tr><td><code id="MCMC_component_+3A_epsilon">EPSILON</code></td>
<td>
<p>vector of hidden influences (placeholder for customized version)</p>
</td></tr>
<tr><td><code id="MCMC_component_+3A_jump_scale">JUMP_SCALE</code></td>
<td>
<p>ODE system</p>
</td></tr>
<tr><td><code id="MCMC_component_+3A_step">STEP</code></td>
<td>
<p>time step of the sample algorithm corresponding to the given vector of time points</p>
</td></tr>
<tr><td><code id="MCMC_component_+3A_observations">OBSERVATIONS</code></td>
<td>
<p>observed state dynamics e.g. protein concentrations</p>
</td></tr>
<tr><td><code id="MCMC_component_+3A_y0">Y0</code></td>
<td>
<p>initial values of the system</p>
</td></tr>
<tr><td><code id="MCMC_component_+3A_inputdata">INPUTDATA</code></td>
<td>
<p>discrete input function e.g. stimuli</p>
</td></tr>
<tr><td><code id="MCMC_component_+3A_parameter">PARAMETER</code></td>
<td>
<p>model parameters estimates</p>
</td></tr>
<tr><td><code id="MCMC_component_+3A_epsilon_act">EPSILON_ACT</code></td>
<td>
<p>vector of current hidden influences</p>
</td></tr>
<tr><td><code id="MCMC_component_+3A_sigma">SIGMA</code></td>
<td>
<p>current variance of the prior for the hidden influences (calculated during the Gibbs update)</p>
</td></tr>
<tr><td><code id="MCMC_component_+3A_diag">DIAG</code></td>
<td>
<p>diagonal weight matrix of the current Gibbs step</p>
</td></tr>
<tr><td><code id="MCMC_component_+3A_gibbs_par">GIBBS_par</code></td>
<td>
<p>GIBBS_PAR[[&quot;BETA&quot;]] and GIBBS_PAR[[&quot;ALPHA&quot;]]; prespecified or calculated vector of state weights</p>
</td></tr>
<tr><td><code id="MCMC_component_+3A_n">N</code></td>
<td>
<p>number of system states</p>
</td></tr>
<tr><td><code id="MCMC_component_+3A_burnin">BURNIN</code></td>
<td>
<p>number of dismissed samples during burn-in</p>
</td></tr>
<tr><td><code id="MCMC_component_+3A_objective">objective</code></td>
<td>
<p>objective function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function can be replaced by an user defined version if necessary
</p>


<h3>Value</h3>

<p>A matrix with the sampled hidden inputs (row-wise)
</p>

<hr>
<h2 id='Model'>Test dataset  for demonstrating the bden algorithm.</h2><span id='topic+Model'></span>

<h3>Description</h3>

<p>Dataset is identical with the example for the bden algorithm from the vignette. It contains an object of
odeModel that describes the uvb network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(bden_uvb)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>odeModel</code> of length 1.
</p>

<hr>
<h2 id='nominalSol'>Calculate the nominal solution of the model</h2><span id='topic+nominalSol'></span><span id='topic+nominalSol+2CodeModel-method'></span>

<h3>Description</h3>

<p>After an model is defined it can be evaluated. This returns the numerical solution
for the state equation before hidden inputs are calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nominalSol(odeModel)

## S4 method for signature 'odeModel'
nominalSol(odeModel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nominalSol_+3A_odemodel">odeModel</code></td>
<td>
<p>a object of the class ode model describing the experiment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with the numeric solution to the nominal ode equation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
lotka_voltera &lt;- function (t, x, parameters) {
with(as.list(c(x,parameters)), {
 dx1 = x[1]*(alpha - beta*x[2])
  dx2 = -x[2]*(gamma - delta*x[1])
 return(list(c(dx1, dx2)))
})
}

pars &lt;- c(alpha = 2, beta = .5, gamma = .2, delta = .6)
init_state &lt;- c(x1 = 10, x2 = 10)
time &lt;- seq(0, 100, by = 1)
lotVolModel = odeModel(func = lotka_voltera, parms = pars, times = time, y = init_state)
nominalSol(lotVolModel) 

</code></pre>

<hr>
<h2 id='odeEquations-class'>A S4 class used to handle formatting ODE-Equation and calculate the needed functions for the seeds-algorithm</h2><span id='topic+odeEquations-class'></span><span id='topic+odeEquations'></span>

<h3>Description</h3>

<p>A S4 class used to handle formatting ODE-Equation and calculate the needed functions for the seeds-algorithm
</p>


<h3>Value</h3>

<p>Returns a s4 class object containing the needed equations for the costate equation
</p>


<h3>Slots</h3>


<dl>
<dt><code>modelStr</code></dt><dd><p>a vector of strings describing the ODE</p>
</dd>
<dt><code>measureStr</code></dt><dd><p>a vector of strings representing the equation of the measurement function</p>
</dd>
<dt><code>origEq</code></dt><dd><p>a vector of strings containing the original model function</p>
</dd>
<dt><code>measureFunction</code></dt><dd><p>a vector of strings containing the original measurement function</p>
</dd>
<dt><code>costateEq</code></dt><dd><p>a vector of strings describing the costate equation</p>
</dd>
<dt><code>JhT</code></dt><dd><p>a matrix of strings describing the jacobian matrix of the measurement function</p>
</dd>
<dt><code>jacobian</code></dt><dd><p>a matrix of strings representing the jacobian matrix model equations</p>
</dd>
<dt><code>costFunction</code></dt><dd><p>a string containing the cost function</p>
</dd>
<dt><code>hamiltonian</code></dt><dd><p>a string representing the Hamilton function of the model</p>
</dd>
<dt><code>dynamicElasticNet</code></dt><dd><p>boolean that indicates if the system equation should be calculated for the dynamic elastic net</p>
</dd>
<dt><code>parameters</code></dt><dd><p>parameters of the model</p>
</dd>
<dt><code>cond</code></dt><dd><p>a slot to save conditionals in equations, which are used for formatting the c files</p>
</dd>
<dt><code>nnStates</code></dt><dd><p>vector indicating which states should have a non negative solution</p>
</dd>
</dl>

<hr>
<h2 id='odeModel-class'>A class to store the important information of an model.</h2><span id='topic+odeModel-class'></span><span id='topic+odeModel'></span>

<h3>Description</h3>

<p>The slots are used to store the important information of an model. The class is used to create object for the
two algorithms implemented in seeds. Methods are implemented to easily calculate the nominal solution of the model and
change the details of the saved model.
The numerical solutions are calculated using the <span class="pkg">deSolve</span> - package.
</p>


<h3>Value</h3>

<p>an object of class odeModel which defines the model
</p>


<h3>Slots</h3>


<dl>
<dt><code>func</code></dt><dd><p>A funtion containing the ode-equations of the model. For syntax look at the given examples of the <span class="pkg">deSolve</span> package.</p>
</dd>
<dt><code>times</code></dt><dd><p>timesteps at which the model should be evaluated</p>
</dd>
<dt><code>parms</code></dt><dd><p>the parameters of the model</p>
</dd>
<dt><code>input</code></dt><dd><p>matrix containing the inputs with the time points</p>
</dd>
<dt><code>measFunc</code></dt><dd><p>function that converts the output of the ode solution</p>
</dd>
<dt><code>y</code></dt><dd><p>initial (state) values of the ODE system, has to be a vector</p>
</dd>
<dt><code>meas</code></dt><dd><p>matrix with the (experimental) measurements of the system</p>
</dd>
<dt><code>sd</code></dt><dd><p>optional standard deviations of the measurements, is used by the algorithms as weights in the costfunction</p>
</dd>
<dt><code>custom</code></dt><dd><p>customized link function</p>
</dd>
<dt><code>nnStates</code></dt><dd><p>bit vector that indicates if states should be observed by the root function</p>
</dd>
<dt><code>nnTollerance</code></dt><dd><p>tolerance at which a function is seen as zero</p>
</dd>
<dt><code>resetValue</code></dt><dd><p>value a state should be set to by an event</p>
</dd>
</dl>

<hr>
<h2 id='optimal_control_gradient_descent'>estimating the optimal control using the dynamic elastic net</h2><span id='topic+optimal_control_gradient_descent'></span>

<h3>Description</h3>

<p>estimating the optimal control using the dynamic elastic net
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimal_control_gradient_descent(
  alphaStep,
  armijoBeta,
  x0,
  parameters,
  alpha1,
  alpha2,
  measData,
  constStr,
  SD,
  modelFunc,
  measFunc,
  modelInput,
  optW,
  origAUC,
  maxIteration,
  plotEsti,
  conjGrad,
  eps,
  nnStates,
  verbose
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimal_control_gradient_descent_+3A_alphastep">alphaStep</code></td>
<td>
<p>starting value of the stepsize for the gradient descent, will be calculate to minimize the cost function by backtracking algorithm</p>
</td></tr>
<tr><td><code id="optimal_control_gradient_descent_+3A_armijobeta">armijoBeta</code></td>
<td>
<p>scaling of the alphaStep to find a approximately optimal value for the stepsize</p>
</td></tr>
<tr><td><code id="optimal_control_gradient_descent_+3A_x0">x0</code></td>
<td>
<p>initial state of the ode system</p>
</td></tr>
<tr><td><code id="optimal_control_gradient_descent_+3A_parameters">parameters</code></td>
<td>
<p>parameters of the ODE-system</p>
</td></tr>
<tr><td><code id="optimal_control_gradient_descent_+3A_alpha1">alpha1</code></td>
<td>
<p>L1 cost term scalar</p>
</td></tr>
<tr><td><code id="optimal_control_gradient_descent_+3A_alpha2">alpha2</code></td>
<td>
<p>L2 cost term scalar</p>
</td></tr>
<tr><td><code id="optimal_control_gradient_descent_+3A_measdata">measData</code></td>
<td>
<p>measured values of the experiment</p>
</td></tr>
<tr><td><code id="optimal_control_gradient_descent_+3A_conststr">constStr</code></td>
<td>
<p>a string that represents constrains, can be used to calculate a hidden input for a component that gradient is zero</p>
</td></tr>
<tr><td><code id="optimal_control_gradient_descent_+3A_sd">SD</code></td>
<td>
<p>standard deviation of the experiment; leave empty if unknown; matrix should contain the timesteps in the first column</p>
</td></tr>
<tr><td><code id="optimal_control_gradient_descent_+3A_modelfunc">modelFunc</code></td>
<td>
<p>function that describes the ODE-system of the model</p>
</td></tr>
<tr><td><code id="optimal_control_gradient_descent_+3A_measfunc">measFunc</code></td>
<td>
<p>function that maps the states to the outputs</p>
</td></tr>
<tr><td><code id="optimal_control_gradient_descent_+3A_modelinput">modelInput</code></td>
<td>
<p>an dataset that describes the external input of the system</p>
</td></tr>
<tr><td><code id="optimal_control_gradient_descent_+3A_optw">optW</code></td>
<td>
<p>vector that indicated at which knots of the network the algorithm should estimate the hidden inputs</p>
</td></tr>
<tr><td><code id="optimal_control_gradient_descent_+3A_origauc">origAUC</code></td>
<td>
<p>AUCs of the first optimization; only used by the algorithm</p>
</td></tr>
<tr><td><code id="optimal_control_gradient_descent_+3A_maxiteration">maxIteration</code></td>
<td>
<p>a upper bound for the maximal number of iterations</p>
</td></tr>
<tr><td><code id="optimal_control_gradient_descent_+3A_plotesti">plotEsti</code></td>
<td>
<p>boolean that controls of the current estimates should be plotted</p>
</td></tr>
<tr><td><code id="optimal_control_gradient_descent_+3A_conjgrad">conjGrad</code></td>
<td>
<p>boolean that indicates the usage of conjugate gradient method over the normal steepest descent</p>
</td></tr>
<tr><td><code id="optimal_control_gradient_descent_+3A_eps">eps</code></td>
<td>
<p>citeria for stopping the algorithm</p>
</td></tr>
<tr><td><code id="optimal_control_gradient_descent_+3A_nnstates">nnStates</code></td>
<td>
<p>a bit vector indicating the states that should be non negative</p>
</td></tr>
<tr><td><code id="optimal_control_gradient_descent_+3A_verbose">verbose</code></td>
<td>
<p>Boolean indicating if an output in the console should be created to display the gradient descent steps</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the estimated hidden inputs, the AUCs, the estimated states and resulting measurements and the cost function
</p>

<hr>
<h2 id='outputEstimates'>Get the estimated outputs</h2><span id='topic+outputEstimates'></span><span id='topic+outputEstimates+2Clist+2Cnumeric-method'></span><span id='topic+outputEstimates+2Clist+2Cmissing-method'></span><span id='topic+outputEstimates+2CresultsSeeds+2Cmissing-method'></span>

<h3>Description</h3>

<p>Get the estimated outputs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outputEstimates(resultsSeeds, ind)

## S4 method for signature 'list,numeric'
outputEstimates(resultsSeeds, ind)

## S4 method for signature 'list,missing'
outputEstimates(resultsSeeds, ind)

## S4 method for signature 'resultsSeeds,missing'
outputEstimates(resultsSeeds, ind)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="outputEstimates_+3A_resultsseeds">resultsSeeds</code></td>
<td>
<p>A object of the class 'resultsSeeds', which is returned from the algorithms.</p>
</td></tr>
<tr><td><code id="outputEstimates_+3A_ind">ind</code></td>
<td>
<p>A numeric indicating the index of a 'resultsSeeds'-Object in a list. If not set the last listed object will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Dafaframe with estimated measurements.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(uvb_res)

outputEstimates(res[[2]])

</code></pre>

<hr>
<h2 id='plot+2CresultsSeeds+2Cmissing-method'>Plot method for the S4 class resultsSeeds</h2><span id='topic+plot+2CresultsSeeds+2Cmissing-method'></span>

<h3>Description</h3>

<p>A standardized plot function to display the results of the algorithms. Both
algorithms should result in objects of the class resultsSeeds. The results can
be plotted using the <code><a href="base.html#topic+plot">plot</a></code>-function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'resultsSeeds,missing'
plot(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CresultsSeeds+2B2Cmissing-method_+3A_x">x</code></td>
<td>
<p>an object of type resultsSeeds or a list of these objects. If a list
is given the last entry will be plotted.</p>
</td></tr>
<tr><td><code id="plot+2B2CresultsSeeds+2B2Cmissing-method_+3A_y">y</code></td>
<td>
<p>...</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of plots showing the results of the algorithm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(uvb_res)

plot(res[[2]])

</code></pre>

<hr>
<h2 id='plotAnno'>Create annotated plot</h2><span id='topic+plotAnno'></span><span id='topic+plotAnno+2CresultsSeeds-method'></span><span id='topic+plotAnno+2Clist-method'></span>

<h3>Description</h3>

<p>Create a annotated plot with given state and measurement names. The plots are
equal to the output of the normal plot function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotAnno(x, stateAnno, measAnno)

## S4 method for signature 'resultsSeeds'
plotAnno(x, stateAnno, measAnno)

## S4 method for signature 'list'
plotAnno(x, stateAnno, measAnno)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotAnno_+3A_x">x</code></td>
<td>
<p>an object of type resultsSeeds which contains the results of the algorithms</p>
</td></tr>
<tr><td><code id="plotAnno_+3A_stateanno">stateAnno</code></td>
<td>
<p>a character vector describing the names of the states</p>
</td></tr>
<tr><td><code id="plotAnno_+3A_measanno">measAnno</code></td>
<td>
<p>a character vector describing the names of the measurements</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plots of the results with the provided annotation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(uvb_res)

statesAnno &lt;- c("x1", "x2", "x3", "x4", "x5", "x6", "x7", "x8", "x9", "x10", "x11", "x12", "x13")
measurAnno &lt;- c("y1", "y2", "y3", "y4", "y5")

plotAnno(res[[2]], stateAnno = statesAnno, measAnno =  measurAnno)

</code></pre>

<hr>
<h2 id='print+2CresultsSeeds-method'>A default printing function for the resultsSeeds class</h2><span id='topic+print+2CresultsSeeds-method'></span><span id='topic+print+2CresultsSeeds'></span>

<h3>Description</h3>

<p>This function overwrites the default print function and is used for objects 
of the class resultsSeeds. The print function gives the basic information about
the results seeds object. The default printout is the estimated states and 
the calculated hidden inputs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'resultsSeeds'
print(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print+2B2CresultsSeeds-method_+3A_x">x</code></td>
<td>
<p>an object of the class resultsSeeds</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a short summary of the important results
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ubv_res)

plot(res[[2]])


</code></pre>

<hr>
<h2 id='res'>Results from the uvb dataset for examples</h2><span id='topic+res'></span>

<h3>Description</h3>

<p>Data from running the estimation of hidden inputs from the UVB-G Protein demo. This data is used for demonstration the different functions of the package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(uvb_res)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.
</p>

<hr>
<h2 id='resultsSeeds-class'>Results Class for the Algorithms</h2><span id='topic+resultsSeeds-class'></span><span id='topic+resultsSeeds'></span>

<h3>Description</h3>

<p>A S4 class that collects the results of the two algorithms. The class also is equipped
with functions for easily plotting and extracting the different results.
</p>


<h3>Value</h3>

<p>A object of class resultsSeeds collecting all the results of the algorithm
</p>


<h3>Slots</h3>


<dl>
<dt><code>stateNominal</code></dt><dd><p>data.frame containing the states of the nominal model</p>
</dd>
<dt><code>stateEstimates</code></dt><dd><p>data.frame containing the state estimates</p>
</dd>
<dt><code>stateUnscertainLower</code></dt><dd><p>lower bound of the estimated states as calculated by the baysian method</p>
</dd>
<dt><code>stateUnscertainUpper</code></dt><dd><p>upper bound of the estimated states as calculated by the baysian method</p>
</dd>
<dt><code>hiddenInputEstimates</code></dt><dd><p>estimated hidden input</p>
</dd>
<dt><code>hiddenInputUncertainLower</code></dt><dd><p>lower bounds of the estimated hidden inputs</p>
</dd>
<dt><code>hiddenInputUncertainUpper</code></dt><dd><p>upper bounds of the estimated hidden inputs</p>
</dd>
<dt><code>outputEstimates</code></dt><dd><p>estimated measurements resulting from the control of the hidden inputs</p>
</dd>
<dt><code>outputEstimatesUncLower</code></dt><dd><p>lower bound of the confidence bands of the estimated output</p>
</dd>
<dt><code>outputEstimatesUncUpper</code></dt><dd><p>upper bound of the confidence bands of the estimated output</p>
</dd>
<dt><code>Data</code></dt><dd><p>the given measurements</p>
</dd>
<dt><code>DataError</code></dt><dd><p>standard deviation of the given measurements</p>
</dd>
</dl>

<hr>
<h2 id='setInitState'>Set the vector with the initial (state) values</h2><span id='topic+setInitState'></span><span id='topic+setInitState+2CodeModel-method'></span>

<h3>Description</h3>

<p>Set the vector with the initial (state) values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setInitState(odeModel, y)

## S4 method for signature 'odeModel'
setInitState(odeModel, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setInitState_+3A_odemodel">odeModel</code></td>
<td>
<p>an object of the class odeModel</p>
</td></tr>
<tr><td><code id="setInitState_+3A_y">y</code></td>
<td>
<p>vector with the initial values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of odeModel
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("uvbModel")

x0 = c(0.2,10,2,0,0,20,0,0,0,4.2,0.25,20,0)

newModel &lt;- setInitState(uvbModel, y = x0)

</code></pre>

<hr>
<h2 id='setInput'>Set the inputs of the model.</h2><span id='topic+setInput'></span><span id='topic+setInput+2CodeModel-method'></span>

<h3>Description</h3>

<p>It the model has an input it can be set with this function. The inputs
should be a dataframe, where the first column is the timesteps of the
inputs in the second column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setInput(odeModel, input)

## S4 method for signature 'odeModel'
setInput(odeModel, input)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setInput_+3A_odemodel">odeModel</code></td>
<td>
<p>an object of the class modelClass</p>
</td></tr>
<tr><td><code id="setInput_+3A_input">input</code></td>
<td>
<p>function describing the ode equation of the model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of odeModel
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("uvbModel")

model_times &lt;- uvbModel@times
input &lt;- rep(0,length(model_times))

input_Dataframe &lt;- data.frame(t = model_times, u = input)

newModel &lt;- setInput(odeModel = uvbModel,input = input_Dataframe)

</code></pre>

<hr>
<h2 id='setMeas'>set measurements of the model</h2><span id='topic+setMeas'></span><span id='topic+setMeas+2CodeModel-method'></span>

<h3>Description</h3>

<p>The odeModel object stores all important information. Measurements of the objects can be set
directly by adressing the slot, or with this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setMeas(odeModel, meas)

## S4 method for signature 'odeModel'
setMeas(odeModel, meas)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setMeas_+3A_odemodel">odeModel</code></td>
<td>
<p>an object of the class odeModel</p>
</td></tr>
<tr><td><code id="setMeas_+3A_meas">meas</code></td>
<td>
<p>measurements of the model, a matrix with measurements of the model
and the corresponding time values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of odeModel
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(uvbData)
data(uvbModel)

measurements &lt;- uvbData[,1:6]

newModel &lt;- setMeas(odeModel = uvbModel, meas = measurements)

</code></pre>

<hr>
<h2 id='setMeasFunc'>Set the measurement equation for the model</h2><span id='topic+setMeasFunc'></span><span id='topic+setMeasFunc+2CodeModel+2Cfunction+2Cmissing-method'></span><span id='topic+setMeasFunc+2CodeModel+2Cfunction+2Clogical-method'></span>

<h3>Description</h3>

<p>For a given model a measurement equation can be set. If no measurement function is set the
states become the output of the system. The function should be defined as in the example below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setMeasFunc(odeModel, measFunc, custom)

## S4 method for signature 'odeModel,'function',missing'
setMeasFunc(odeModel, measFunc, custom)

## S4 method for signature 'odeModel,'function',logical'
setMeasFunc(odeModel, measFunc, custom)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setMeasFunc_+3A_odemodel">odeModel</code></td>
<td>
<p>an object of the class odeModel</p>
</td></tr>
<tr><td><code id="setMeasFunc_+3A_measfunc">measFunc</code></td>
<td>
<p>measurement function of the model. Has to be a R functions.</p>
</td></tr>
<tr><td><code id="setMeasFunc_+3A_custom">custom</code></td>
<td>
<p>custom indexing for the measurement function (used by the baysian method)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of odeModel
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("uvbModel")

uvbMeasure &lt;- function(x) {

  y1 = 2*x[,5] + x[,4] + x[,8]
  y2 = 2*x[,5] + 2* x[,3] + x[,1]
  y3 = x[,6]
  y4 = x[,11]
  y5 = x[,4]

  return(cbind(y1,y2,y3,y4,y5))
  }

newModel &lt;- setMeasFunc(odeModel = uvbModel, measFunc = uvbMeasure)

</code></pre>

<hr>
<h2 id='setModelEquation'>Set the model equation</h2><span id='topic+setModelEquation'></span><span id='topic+setModelEquation+2CodeModel-method'></span>

<h3>Description</h3>

<p>Set the model equation of the system in an odeModel object. Has to be a function that can be used with the deSolve package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setModelEquation(odeModel, func)

## S4 method for signature 'odeModel'
setModelEquation(odeModel, func)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setModelEquation_+3A_odemodel">odeModel</code></td>
<td>
<p>an object of the class odeModel</p>
</td></tr>
<tr><td><code id="setModelEquation_+3A_func">func</code></td>
<td>
<p>function describing the ode equation of the model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of odeModel
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("uvbModel")

uvbModelEq &lt;- function(t,x,parameters) {
  with (as.list(parameters),{
    
    dx1 = ((-2) * ((ka1 * (x[1]^2) * (x[4]^2)) - (kd1 * x[5])) + 
             (-2) * ((ka2 * (x[1]^2) * x[2]) - (kd2 * x[3])) + 
             ((ks1 *((1) + (uv * n3 * (x[11] + fhy3_s))))  - 
                (kdr1 * ((1) + (n1 * uv)) * x[1])))
    dx2 = ((-1) * ((ka2*(x[1]^2) * x[2]) - (kd2 * x[3])) +
             (-1) * ((ka4 * x[2] * x[12]) - (kd4 * x[13])))
    dx3 = (((ka2 * (x[1]^2) * x[2]) - (kd2*  x[3]))) 
    dx4 = ((-2) * (k1*(x[4]^2)) + (2) * (k2 * x[6]) + 
             (-2) * ((ka1 * (x[1]^2)* (x[4]^2)) - (kd1 * x[5])) +
             (-1)* (ka3 * x[4] *x[7]))
    dx5 =  (((ka1 * (x[1]^2) * (x[4]^2)) -(kd1 * x[5])))
    dx6 = ((-1) * (k2 * x[6]) +  (k1 * (x[4]^2)) +(kd3 * (x[8]^2)))
    dx7 = ((-1) * (ka3 * x[4] * x[7]) + ((ks2 * ((1) + (uv * x[5]))) - 
                                           (kdr2 * x[7])) + (2) * (kd3 * (x[8]^2)))
    dx8 = ((-2) * (kd3 * x[8]^2) + (ka3 * x[4] * x[7])) 
    dx9  = 0 
    dx10 = 0
    dx11 =  (((ks3 * ((1) + (n2 * uv))) -(kdr3 * (((x[3] / (kdr3a + x[3])) + 
            (x[13] / (kdr3b + x[13]))) -(x[5] / (ksr + x[5]))) *  x[11])))
    dx12 = ((-1) * (ka4 * x[2] * x[12]) + (kd4 * x[13]))
    dx13 =((ka4 * x[2] * x[12]) - (kd4 * x[13]))
    
    list(c(dx1,dx2,dx3,dx4,dx5,dx6,dx7,dx8,dx9,dx10,dx11,dx12,dx13))
  })
}

setModelEquation(uvbModel,uvbModelEq)

</code></pre>

<hr>
<h2 id='setParms'>Set the model parameters</h2><span id='topic+setParms'></span><span id='topic+setParms+2CodeModel+2Cnumeric-method'></span>

<h3>Description</h3>

<p>A method to set the model parameters of an odeModel object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setParms(odeModel, parms)

## S4 method for signature 'odeModel,numeric'
setParms(odeModel, parms)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setParms_+3A_odemodel">odeModel</code></td>
<td>
<p>an object of the class odeModel</p>
</td></tr>
<tr><td><code id="setParms_+3A_parms">parms</code></td>
<td>
<p>a vector containing the parameters of the model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of odeModel
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("uvbModel")

newParas &lt;- c(  ks1=0.23,
ks2=4.0526,
kdr1=0.1,
kdr2=0.2118,
k1=0.0043,
k2=161.62,
ka1=0.0372,
ka2=0.0611,
ka3=4.7207,
kd1=94.3524,
kd2=50.6973,
kd3=0.5508,
ks3=0.4397,
kdr3=1.246,
uv=1,
ka4=10.1285,
kd4=1.1999,
n1=3,
n2=2,
n3=3.5,
kdr3a=0.9735,
kdr3b=0.406,
ksr=0.7537,
fhy3_s=5)

newModel &lt;- setParms(odeModel = uvbModel, parms = newParas)

</code></pre>

<hr>
<h2 id='setSd'>Set the standard deviation of the measurements</h2><span id='topic+setSd'></span><span id='topic+setSd+2CodeModel-method'></span>

<h3>Description</h3>

<p>With multiple measurements a standard deviation can be calculated for every point of
measurement. The standard deviation is used to weigh the estimated data points in the 
cost function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setSd(odeModel, sd)

## S4 method for signature 'odeModel'
setSd(odeModel, sd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setSd_+3A_odemodel">odeModel</code></td>
<td>
<p>an object of the class odeModel</p>
</td></tr>
<tr><td><code id="setSd_+3A_sd">sd</code></td>
<td>
<p>a matrix with the standard deviations of the measurements</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of odeModel
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(uvbData)
data(uvbModel)

sd_uvb &lt;- uvbData[,7:11]

newModel &lt;- setSd(odeModel = uvbModel, sd = sd_uvb)

</code></pre>

<hr>
<h2 id='SETTINGS'>Automatic Calculation of optimal Initial Parameters</h2><span id='topic+SETTINGS'></span>

<h3>Description</h3>

<p>Implemented according to Engelhardt et al. 2017.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SETTINGS(
  VARIANCE,
  N,
  BETA_LAMDBA,
  alphainit,
  betainit,
  R = c(1000, 1000),
  ROH = c(10, 10)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SETTINGS_+3A_variance">VARIANCE</code></td>
<td>
<p>standard error of the observed stat dynamics (per time point)</p>
</td></tr>
<tr><td><code id="SETTINGS_+3A_n">N</code></td>
<td>
<p>number of system states</p>
</td></tr>
<tr><td><code id="SETTINGS_+3A_beta_lamdba">BETA_LAMDBA</code></td>
<td>
<p>mcmc tuning parameter (weighting of observed states)</p>
</td></tr>
<tr><td><code id="SETTINGS_+3A_alphainit">alphainit</code></td>
<td>
<p>mcmc tuning parameter (weighting of observed states)</p>
</td></tr>
<tr><td><code id="SETTINGS_+3A_betainit">betainit</code></td>
<td>
<p>mcmc tuning parameter (weighting of observed states)</p>
</td></tr>
<tr><td><code id="SETTINGS_+3A_r">R</code></td>
<td>
<p>mcmc tuning parameter</p>
</td></tr>
<tr><td><code id="SETTINGS_+3A_roh">ROH</code></td>
<td>
<p>mcmc tuning parameter</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function can be replaced by an user defined version if necessary.
</p>


<h3>Value</h3>

<p>A list of optimal initial parameters; i.e. R, Roh, Alpha, Beta, Tau, Lambda1, Lambda2
</p>

<hr>
<h2 id='uvbData'>UVB signal pathway</h2><span id='topic+uvbData'></span>

<h3>Description</h3>

<p>A data frame containing simulated values of the UVB Signaling pathway. The error
of the system is synthetic and is added to the states x3 and x11. The model
is taken from the works of Ouyang et al. <a href="https://doi.org/10.1073/pnas.1412050111">https://doi.org/10.1073/pnas.1412050111</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uvbData
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 8 rows and 11 columns.
</p>


<h3>Details</h3>

<p>A data frame with 8 rows and 11 columns
</p>

<dl>
<dt>t</dt><dd><p>time in fractions of an hour</p>
</dd>
<dt>y1</dt><dd><p>total amounts of UVR8 monomers</p>
</dd>
<dt>y2</dt><dd><p>total amounts of COP1 monomers</p>
</dd>
<dt>y3</dt><dd><p>total amounts of UVR8 dimers</p>
</dd>
<dt>y4</dt><dd><p>concentration of elongated hypocotyl 5 (HY5) protein</p>
</dd>
<dt>y5</dt><dd><p>concentration measured of UVR8 monomers</p>
</dd>
<dt>y1std</dt><dd><p>standard deviation of the first measurement</p>
</dd>
<dt>y2std</dt><dd><p>standard deviation of the second measurement</p>
</dd>
<dt>y3std</dt><dd><p>standard deviation of the third measurement</p>
</dd>
<dt>y4std</dt><dd><p>standard deviation of the fourth measurement</p>
</dd>
<dt>y5std</dt><dd><p>standard deviation of the fifth measurement</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://doi.org/10.1073/pnas.1412050111">https://doi.org/10.1073/pnas.1412050111</a>
</p>

<hr>
<h2 id='uvbModel'>An object of the odeModel Class</h2><span id='topic+uvbModel'></span>

<h3>Description</h3>

<p>Object is used for demonstrating the functions of the odeModel Class. It is used in the demos for the uvb signaling pathway.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(uvbModel)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>odeModel</code> of length 1.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
