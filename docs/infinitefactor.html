<!DOCTYPE html><html><head><title>Help for package infinitefactor</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {infinitefactor}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#infinitefactor-package'>
<p>Bayesian Infinite Factor Models</p></a></li>
<li><a href='#amean'>
<p>Average over the third index of an array</p></a></li>
<li><a href='#interactionDL'>
<p>Factor regression model with interactions using the Dirichlet-Laplace shrinkage prior</p></a></li>
<li><a href='#interactionMGSP'>
<p>Factor regression model with interactions using the Multiplicative Gamma Shrinkage Prior</p></a></li>
<li><a href='#jointRot'>
<p>Resolve rotational ambiguity in samples of factor loadings and factors jointly</p></a></li>
<li><a href='#linearDL'>
<p>Sample Bayesian linear infinite factor models with the Dirichlet-Laplace prior</p></a></li>
<li><a href='#linearMGSP'>
<p>Sample Bayesian linear infinite factor models with the Multiplicative Gamma Shrinkage Prior</p></a></li>
<li><a href='#lmean'>
<p>Average elements of a list</p></a></li>
<li><a href='#msf'>
<p>Resolve label and sign switching in random matrix samples</p></a></li>
<li><a href='#plotmat'>
<p>Plot a matrix</p></a></li>
<li><a href='#Sampler+20Components'>
<p>Sampler Components</p></a></li>
<li><a href='#summat'>
<p>Summarise a matrix from posterior samples</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Infinite Factor Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-03-30</td>
</tr>
<tr>
<td>Author:</td>
<td>Evan Poworoznek</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Evan Poworoznek &lt;infinitefactorpackage@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Sampler and post-processing functions for semi-parametric Bayesian infinite factor models, motivated by the Multiplicative Gamma Shrinkage Prior of Bhattacharya and Dunson (2011) <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3419391/">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3419391/</a>. Contains component C++ functions for building samplers for linear and 2-way interaction factor models using the multiplicative gamma and Dirichlet-Laplace shrinkage priors. The package also contains post processing functions to return matrices that display rotational ambiguity to identifiability through successive application of orthogonalization procedures and resolution of column label and sign switching. This package was developed with the support of the National Institute of Environmental Health Sciences grant 1R01ES028804-01.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.2)</td>
</tr>
<tr>
<td>Depends:</td>
<td>reshape2, ggplot2, stats, utils</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-03-30 20:40:00 UTC; evan</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-04-03 13:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='infinitefactor-package'>
Bayesian Infinite Factor Models
</h2><span id='topic+infinitefactor-package'></span><span id='topic+infinitefactor'></span>

<h3>Description</h3>

<p>Sampler and post-processing functions for semi-parametric Bayesian infinite factor models, motivated by the Multiplicative Gamma Shrinkage Prior of Bhattacharya and Dunson (2011) &lt;https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3419391/&gt;. Contains component C++ functions for building samplers for linear and 2-way interaction factor models using the multiplicative gamma and Dirichlet-Laplace shrinkage priors. The package also contains post processing functions to return matrices that display rotational ambiguity to identifiability through successive application of orthogonalization procedures and resolution of column label and sign switching. This package was developed with the support of the National Institute of Environmental Health Sciences grant 1R01ES028804-01.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> infinitefactor</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Bayesian Infinite Factor Models</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2020-03-30</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Evan Poworoznek</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Evan Poworoznek &lt;infinitefactorpackage@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Sampler and post-processing functions for semi-parametric Bayesian infinite factor models, motivated by the Multiplicative Gamma Shrinkage Prior of Bhattacharya and Dunson (2011) &lt;https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3419391/&gt;. Contains component C++ functions for building samplers for linear and 2-way interaction factor models using the multiplicative gamma and Dirichlet-Laplace shrinkage priors. The package also contains post processing functions to return matrices that display rotational ambiguity to identifiability through successive application of orthogonalization procedures and resolution of column label and sign switching. This package was developed with the support of the National Institute of Environmental Health Sciences grant 1R01ES028804-01.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> Rcpp (&gt;= 1.0.2)</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> reshape2,
ggplot2,
stats,
utils</td>
</tr>
<tr>
 <td style="text-align: left;">
LinkingTo: </td><td style="text-align: left;"> Rcpp, RcppArmadillo</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
amean                   Average over the third index of an array
del_mg                  Sampler Components
infinitefactor-package
                        Bayesian Infinite Factor Models
interactionDL           Factor regression model with interactions using
                        the Dirichlet-Laplace shrinkage prior
interactionMGSP         Factor regression model with interactions using
                        the Multiplicative Gamma Shrinkage Prior
jointRot                Resolve rotational ambiguity in samples of
                        factor loadings and factors jointly
linearDL                Sample Bayesian linear infinite factor models
                        with the Dirichlet-Laplace prior
linearMGSP              Sample Bayesian linear infinite factor models
                        with the Multiplicative Gamma Shrinkage Prior
lmean                   Average elements of a list
msf                     Resolve label and sign switching in random
                        matrix samples
plotmat                 Plot a matrix
summat                  Summarise a matrix from posterior samples
</pre>
<p>Perform sampling with the linearMGSP() and linearDL() functions for linear factor models, or interactionMGSP() and interactionDL() functions for factor regression models including 2-way interactions. See jointRot() or msf() for postprocessing.
</p>


<h3>Author(s)</h3>

<p>Evan Poworoznek
</p>
<p>Maintainer: Evan Poworoznek &lt;infinitefactorpackage@gmail.com&gt;
</p>


<h3>References</h3>

<p>Bhattacharya, Anirban, and David B. Dunson. &quot;Sparse Bayesian infinite factor models.&quot; Biometrika (2011): 291-306.
</p>
<p>Bhattacharya, Anirban, et al. &quot;Dirichlet-Laplace priors for optimal shrinkage.&quot; Journal of the American Statistical Association 110.512 (2015): 1479-1490.
</p>
<p>Ferrari, Federico, and David B. Dunson. &quot;Bayesian Factor Analysis for Inference on Interactions.&quot; arXiv preprint arXiv:1904.11603 (2019).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>k0 = 5
p = 20
n = 100

lambda = matrix(rnorm(p*k0, 0, 0.01), ncol = k0)
lambda[sample.int(p, 40, replace = TRUE) +
         p*(sample.int(k0, 40, replace = TRUE)-1)] = rnorm(40, 0, 1)
lambda[1:7, 1] = rnorm(7, 2, 0.5)
lambda[8:14, 2] = rnorm(7, -2, 0.5)
lambda[15:20, 3] = rnorm(6, 2, 0.5)
lambda[,4] = rnorm(p, 0, 0.5)
lambda[,5] = rnorm(p, 0, 0.5)
plotmat(varimax(lambda)[[1]])

X = matrix(rnorm(n*k0),n,k0)%*%t(lambda) + matrix(rnorm(n*p), n, p)

out = linearMGSP(X = X, nrun = 1000, burn = 500, adapt = FALSE)

aligned = jointRot(out$lambdaSamps, out$etaSamps)

plotmat(lmean(aligned$lambda))
</code></pre>

<hr>
<h2 id='amean'>
Average over the third index of an array
</h2><span id='topic+amean'></span>

<h3>Description</h3>

<p>Convenience function to compute matrix sample means when samples are stored as a 3rd order array. Sampling index should be the third mode.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>amean(ar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="amean_+3A_ar">ar</code></td>
<td>
<p>a 3rd order array
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of dimension dim(ar)[-3]
</p>


<h3>Author(s)</h3>

<p>Evan Poworoznek
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmean">lmean</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ar = array(rnorm(10000), dim = c(10, 10, 100))
amean(ar)
</code></pre>

<hr>
<h2 id='interactionDL'>
Factor regression model with interactions using the Dirichlet-Laplace shrinkage prior
</h2><span id='topic+interactionDL'></span>

<h3>Description</h3>

<p>Perform a regression of y onto X and all 2 way interactions in X using the latent factor model introduced in Ferrari and Dunson (2020). This version uses the Dirichlet-Laplace shrinkage prior as in the original paper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interactionDL(y, X, nrun, burn = 0, thin = 1, 
              delta_rw = 0.0526749, a = 1/2, k = NULL, 
              output = c("covMean", "covSamples", "factSamples", 
              "sigSamples", "coefSamples","errSamples"), 
              verbose = TRUE, dump = FALSE, filename = "samps.Rds", 
              buffer = 10000, adapt = "burn", augment = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interactionDL_+3A_y">y</code></td>
<td>
<p>response vector.</p>
</td></tr>
<tr><td><code id="interactionDL_+3A_x">X</code></td>
<td>
<p>predictor matrix (n x p).</p>
</td></tr>
<tr><td><code id="interactionDL_+3A_nrun">nrun</code></td>
<td>
<p>number of iterations.</p>
</td></tr>
<tr><td><code id="interactionDL_+3A_burn">burn</code></td>
<td>
<p>burn-in period.</p>
</td></tr>
<tr><td><code id="interactionDL_+3A_thin">thin</code></td>
<td>
<p>thinning interval.</p>
</td></tr>
<tr><td><code id="interactionDL_+3A_delta_rw">delta_rw</code></td>
<td>
<p>metropolis-hastings proposal variance.</p>
</td></tr>
<tr><td><code id="interactionDL_+3A_a">a</code></td>
<td>
<p>shrinkage hyperparameter.</p>
</td></tr>
<tr><td><code id="interactionDL_+3A_k">k</code></td>
<td>
<p>number of factors.</p>
</td></tr>
<tr><td><code id="interactionDL_+3A_output">output</code></td>
<td>
<p>output type, a vector including some of: c(&quot;covMean&quot;, &quot;covSamples&quot;, &quot;factSamples&quot;, &quot;sigSamples&quot;, &quot;coefSamples&quot;, &quot;numFactors&quot;, &quot;errSamples&quot;).</p>
</td></tr>
<tr><td><code id="interactionDL_+3A_verbose">verbose</code></td>
<td>
<p>logical. Show progress bar?</p>
</td></tr>
<tr><td><code id="interactionDL_+3A_dump">dump</code></td>
<td>
<p>logical. Save samples to a file during sampling?</p>
</td></tr>
<tr><td><code id="interactionDL_+3A_filename">filename</code></td>
<td>
<p>if dump: filename to address list of posterior samples</p>
</td></tr>
<tr><td><code id="interactionDL_+3A_buffer">buffer</code></td>
<td>
<p>if dump: how often to save samples</p>
</td></tr>
<tr><td><code id="interactionDL_+3A_adapt">adapt</code></td>
<td>
<p>logical or &quot;burn&quot;. Adapt proposal variance in metropolis hastings step? if &quot;burn&quot;, will adapt during burn in and not after.</p>
</td></tr>
<tr><td><code id="interactionDL_+3A_augment">augment</code></td>
<td>
<p>additional sampling steps as an expression</p>
</td></tr>
</table>


<h3>Value</h3>

<p>some of:
</p>
<table>
<tr><td><code>covMean</code></td>
<td>
<p>X covariance posterior mean</p>
</td></tr>
<tr><td><code>omegaSamps</code></td>
<td>
<p>X covariance posterior samples</p>
</td></tr>
<tr><td><code>lambdaSamps</code></td>
<td>
<p>Posterior factor loadings samples (rotationally ambiguous)</p>
</td></tr>
<tr><td><code>etaSamps</code></td>
<td>
<p>Posterior factor samples (rotationally ambiguous)</p>
</td></tr>
<tr><td><code>sigmaSamps</code></td>
<td>
<p>Posterior marginal variance samples (see notation in Bhattacharya and Dunson (2011))</p>
</td></tr>
<tr><td><code>phiSamps</code></td>
<td>
<p>Posterior main effect coefficient samples in factor form (rotationally ambiguous)</p>
</td></tr>
<tr><td><code>PsiSamps</code></td>
<td>
<p>Posterior interaction effect coefficient samples in factor form (rotationally ambiguous)</p>
</td></tr>
<tr><td><code>interceptSamps</code></td>
<td>
<p>Posterior induced intercept samples</p>
</td></tr>
<tr><td><code>mainEffectSamps</code></td>
<td>
<p>Posterior induced main effect coefficient samples</p>
</td></tr>
<tr><td><code>interactionSamps</code></td>
<td>
<p>Posterior induced interaction coefficient samples</p>
</td></tr>
<tr><td><code>ssySamps</code></td>
<td>
<p>Posterior irreducible error samples</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Evan Poworoznek
</p>
<p>Federico Ferrari</p>


<h3>References</h3>

<p>Ferrari, Federico, and David B. Dunson. &quot;Bayesian Factor Analysis for Inference on Interactions.&quot; arXiv preprint arXiv:1904.11603 (2019).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+interactionMGSP">interactionMGSP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>k0 = 5
p = 20
n = 50

lambda = matrix(rnorm(p*k0, 0, 0.01), ncol = k0)
lambda[sample.int(p, 40, replace = TRUE) +
         p*(sample.int(k0, 40, replace = TRUE)-1)] = rnorm(40, 0, 1)
lambda[1:7, 1] = rnorm(7, 2, 0.5)
lambda[8:14, 2] = rnorm(7, -2, 0.5)
lambda[15:20, 3] = rnorm(6, 2, 0.5)
lambda[,4] = rnorm(p, 0, 0.5)
lambda[,5] = rnorm(p, 0, 0.5)
plotmat(varimax(lambda)[[1]])

X = matrix(rnorm(n*k0),n,k0)%*%t(lambda) + matrix(rnorm(n*p), n, p)

beta_true = numeric(p); beta_true[c(1,3,6,8,10,11)] =c(1,1,0.5,-1,-2,-0.5)
Omega_true = matrix(0,p,p)
Omega_true[1,2] = 1; Omega_true[5,2] = -1; Omega_true[10,8] = 1; 
Omega_true[11,5] = -2; Omega_true[1,1] = 0.5; 
Omega_true[2,3] = 0.5; 
Omega_true = Omega_true + t(Omega_true)
y = X%*%beta_true + diag(X%*%Omega_true%*%t(X)) +  rnorm(n,0.5)

intdl = interactionDL(y, X, 1000, 500, k = 5)
</code></pre>

<hr>
<h2 id='interactionMGSP'>
Factor regression model with interactions using the Multiplicative Gamma Shrinkage Prior
</h2><span id='topic+interactionMGSP'></span>

<h3>Description</h3>

<p>Perform a regression of y onto X and all 2 way interactions in X using the latent factor model introduced in Ferrari and Dunson (2020). This version uses the Multiplicative Gamma Shrinkage Prior introduced in Bhattacharya and Dunson (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interactionMGSP(y, X, nrun, burn, thin = 1, 
              delta_rw = 0.0526749, a = 1/2, k = NULL, 
              output = c("covMean", "covSamples", "factSamples", 
              "sigSamples", "coefSamples","errSamples"), 
              verbose = TRUE, dump = FALSE, filename = "samps.Rds", 
              buffer = 10000, adapt = "burn", augment = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interactionMGSP_+3A_y">y</code></td>
<td>
<p>response vector.</p>
</td></tr>
<tr><td><code id="interactionMGSP_+3A_x">X</code></td>
<td>
<p>predictor matrix (n x p).</p>
</td></tr>
<tr><td><code id="interactionMGSP_+3A_nrun">nrun</code></td>
<td>
<p>number of iterations.</p>
</td></tr>
<tr><td><code id="interactionMGSP_+3A_burn">burn</code></td>
<td>
<p>burn-in period.</p>
</td></tr>
<tr><td><code id="interactionMGSP_+3A_thin">thin</code></td>
<td>
<p>thinning interval.</p>
</td></tr>
<tr><td><code id="interactionMGSP_+3A_delta_rw">delta_rw</code></td>
<td>
<p>metropolis-hastings proposal variance.</p>
</td></tr>
<tr><td><code id="interactionMGSP_+3A_a">a</code></td>
<td>
<p>shrinkage hyperparameter.</p>
</td></tr>
<tr><td><code id="interactionMGSP_+3A_k">k</code></td>
<td>
<p>number of factors.</p>
</td></tr>
<tr><td><code id="interactionMGSP_+3A_output">output</code></td>
<td>
<p>output type, a vector including some of: c(&quot;covMean&quot;, &quot;covSamples&quot;, &quot;factSamples&quot;, &quot;sigSamples&quot;, &quot;coefSamples&quot;, &quot;numFactors&quot;, &quot;errSamples&quot;).</p>
</td></tr>
<tr><td><code id="interactionMGSP_+3A_verbose">verbose</code></td>
<td>
<p>logical. Show progress bar?</p>
</td></tr>
<tr><td><code id="interactionMGSP_+3A_dump">dump</code></td>
<td>
<p>logical. Save samples to a file during sampling?</p>
</td></tr>
<tr><td><code id="interactionMGSP_+3A_filename">filename</code></td>
<td>
<p>if dump: filename to address list of posterior samples</p>
</td></tr>
<tr><td><code id="interactionMGSP_+3A_buffer">buffer</code></td>
<td>
<p>if dump: how often to save samples</p>
</td></tr>
<tr><td><code id="interactionMGSP_+3A_adapt">adapt</code></td>
<td>
<p>logical or &quot;burn&quot;. Adapt proposal variance in metropolis hastings step? if &quot;burn&quot;, will adapt during burn in and not after.</p>
</td></tr>
<tr><td><code id="interactionMGSP_+3A_augment">augment</code></td>
<td>
<p>additional sampling steps as an expression</p>
</td></tr>
</table>


<h3>Value</h3>

<p>some of:
</p>
<table>
<tr><td><code>covMean</code></td>
<td>
<p>X covariance posterior mean</p>
</td></tr>
<tr><td><code>omegaSamps</code></td>
<td>
<p>X covariance posterior samples</p>
</td></tr>
<tr><td><code>lambdaSamps</code></td>
<td>
<p>Posterior factor loadings samples (rotationally ambiguous)</p>
</td></tr>
<tr><td><code>etaSamps</code></td>
<td>
<p>Posterior factor samples (rotationally ambiguous)</p>
</td></tr>
<tr><td><code>sigmaSamps</code></td>
<td>
<p>Posterior marginal variance samples (see notation in Bhattacharya and Dunson (2011))</p>
</td></tr>
<tr><td><code>phiSamps</code></td>
<td>
<p>Posterior main effect coefficient samples in factor form (rotationally ambiguous)</p>
</td></tr>
<tr><td><code>PsiSamps</code></td>
<td>
<p>Posterior interaction effect coefficient samples in factor form (rotationally ambiguous)</p>
</td></tr>
<tr><td><code>interceptSamps</code></td>
<td>
<p>Posterior induced intercept samples</p>
</td></tr>
<tr><td><code>mainEffectSamps</code></td>
<td>
<p>Posterior induced main effect coefficient samples</p>
</td></tr>
<tr><td><code>interactionSamps</code></td>
<td>
<p>Posterior induced interaction coefficient samples</p>
</td></tr>
<tr><td><code>ssySamps</code></td>
<td>
<p>Posterior irreducible error samples</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Evan Poworoznek
</p>
<p>Federico Ferrari</p>


<h3>References</h3>

<p>Ferrari, Federico, and David B. Dunson. &quot;Bayesian Factor Analysis for Inference on Interactions.&quot; arXiv preprint arXiv:1904.11603 (2019).
</p>
<p>Bhattacharya, Anirban, and David B. Dunson. &quot;Sparse Bayesian infinite factor models.&quot; Biometrika (2011): 291-306.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+interactionMGSP">interactionMGSP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>k0 = 5
p = 20
n = 50

lambda = matrix(rnorm(p*k0, 0, 0.01), ncol = k0)
lambda[sample.int(p, 40, replace = TRUE) +
         p*(sample.int(k0, 40, replace = TRUE)-1)] = rnorm(40, 0, 1)
lambda[1:7, 1] = rnorm(7, 2, 0.5)
lambda[8:14, 2] = rnorm(7, -2, 0.5)
lambda[15:20, 3] = rnorm(6, 2, 0.5)
lambda[,4] = rnorm(p, 0, 0.5)
lambda[,5] = rnorm(p, 0, 0.5)
plotmat(varimax(lambda)[[1]])

X = matrix(rnorm(n*k0),n,k0)%*%t(lambda) + matrix(rnorm(n*p), n, p)

beta_true = numeric(p); beta_true[c(1,3,6,8,10,11)] =c(1,1,0.5,-1,-2,-0.5)
Omega_true = matrix(0,p,p)
Omega_true[1,2] = 1; Omega_true[5,2] = -1; Omega_true[10,8] = 1; 
Omega_true[11,5] = -2; Omega_true[1,1] = 0.5; 
Omega_true[2,3] = 0.5; 
Omega_true = Omega_true + t(Omega_true)
y = X%*%beta_true + diag(X%*%Omega_true%*%t(X)) +  rnorm(n,0.5)

intmgsp = interactionMGSP(y, X, 1000, 500, k = 5)
</code></pre>

<hr>
<h2 id='jointRot'>
Resolve rotational ambiguity in samples of factor loadings and factors jointly
</h2><span id='topic+jointRot'></span>

<h3>Description</h3>

<p>Performs the varimax rotation on the factor loadings samples and column-based matching to resolve resultant sign and label switching. Rotates the factors along with the loadings to induce identifiability jointly. Note this method will only work on lists of factors and factor loadings that share the same constant number of factors (k) across all samples, and will likely crash the session if this is not the case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jointRot(lambda, eta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jointRot_+3A_lambda">lambda</code></td>
<td>
<p>list of factor loadings samples</p>
</td></tr>
<tr><td><code id="jointRot_+3A_eta">eta</code></td>
<td>
<p>list of factor samples</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>lambda</code></td>
<td>
<p>rotationally aligned factor loadings samples</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
<p>rotationally aligned factor samples</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Evan Poworoznek
</p>


<h3>References</h3>

<p>coming soon...
</p>


<h3>See Also</h3>

<p><code><a href="#topic+msf">msf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>k0 = 5
p = 20
n = 100

lambda = matrix(rnorm(p*k0, 0, 0.01), ncol = k0)
lambda[sample.int(p, 40, replace = TRUE) +
         p*(sample.int(k0, 40, replace = TRUE)-1)] = rnorm(40, 0, 1)
lambda[1:7, 1] = rnorm(7, 2, 0.5)
lambda[8:14, 2] = rnorm(7, -2, 0.5)
lambda[15:20, 3] = rnorm(6, 2, 0.5)
lambda[,4] = rnorm(p, 0, 0.5)
lambda[,5] = rnorm(p, 0, 0.5)
plotmat(varimax(lambda)[[1]])

X = matrix(rnorm(n*k0),n,k0)%*%t(lambda) + matrix(rnorm(n*p), n, p)

out = linearMGSP(X = X, nrun = 1000, burn = 500, adapt = FALSE)

aligned = jointRot(out$lambdaSamps, out$etaSamps)

plotmat(lmean(aligned$lambda))
</code></pre>

<hr>
<h2 id='linearDL'>
Sample Bayesian linear infinite factor models with the Dirichlet-Laplace prior
</h2><span id='topic+linearDL'></span>

<h3>Description</h3>

<p>Perform Bayesian factor analysis by sampling the posterior distribution of parameters in a factor model with the Dirichlet-Laplace shrinkage prior of Bhattacharya et al.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linearDL(X, nrun, burn, thin = 1, prop = 1, 
epsilon = 1e-3, k = NULL,
output = c("covMean", "covSamples", "factSamples",
"sigSamples"), verbose = TRUE, dump = FALSE,
filename = "samps.Rds", buffer = 10000,
augment = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linearDL_+3A_x">X</code></td>
<td>
<p>Data matrix (n x p)</p>
</td></tr>
<tr><td><code id="linearDL_+3A_nrun">nrun</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="linearDL_+3A_burn">burn</code></td>
<td>
<p>burn-in period</p>
</td></tr>
<tr><td><code id="linearDL_+3A_thin">thin</code></td>
<td>
<p>thinning interval</p>
</td></tr>
<tr><td><code id="linearDL_+3A_prop">prop</code></td>
<td>
<p>proportion of elements in each column less than epsilon in magnitude cutoff</p>
</td></tr>
<tr><td><code id="linearDL_+3A_epsilon">epsilon</code></td>
<td>
<p>tolerance</p>
</td></tr>
<tr><td><code id="linearDL_+3A_k">k</code></td>
<td>
<p>Number of factors</p>
</td></tr>
<tr><td><code id="linearDL_+3A_output">output</code></td>
<td>
<p>output type, a vector including some of: c(&quot;covMean&quot;, &quot;covSamples&quot;, &quot;factSamples&quot;, &quot;sigSamples&quot;)</p>
</td></tr>
<tr><td><code id="linearDL_+3A_verbose">verbose</code></td>
<td>
<p>logical. Show progress bar?</p>
</td></tr>
<tr><td><code id="linearDL_+3A_dump">dump</code></td>
<td>
<p>logical. Save output object during sampling?</p>
</td></tr>
<tr><td><code id="linearDL_+3A_filename">filename</code></td>
<td>
<p>if dump, filename for output</p>
</td></tr>
<tr><td><code id="linearDL_+3A_buffer">buffer</code></td>
<td>
<p>if dump, frequency of saving</p>
</td></tr>
<tr><td><code id="linearDL_+3A_augment">augment</code></td>
<td>
<p>additional sampling steps as an expression</p>
</td></tr>
</table>


<h3>Value</h3>

<p>some of:
</p>
<table>
<tr><td><code>covMean</code></td>
<td>
<p>X covariance posterior mean</p>
</td></tr>
<tr><td><code>omegaSamps</code></td>
<td>
<p>X covariance posterior samples</p>
</td></tr>
<tr><td><code>lambdaSamps</code></td>
<td>
<p>Posterior factor loadings samples (rotationally ambiguous)</p>
</td></tr>
<tr><td><code>etaSamps</code></td>
<td>
<p>Posterior factor samples (rotationally ambiguous)</p>
</td></tr>
<tr><td><code>sigmaSamps</code></td>
<td>
<p>Posterior marginal variance samples (see notation in Bhattacharya and Dunson (2011))</p>
</td></tr>
<tr><td><code>numFacts</code></td>
<td>
<p>Number of factors for each iteration</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Evan Poworoznek
</p>


<h3>References</h3>

<p>Bhattacharya, Anirban, et al. &quot;Dirichlet-Laplace priors for optimal shrinkage.&quot; Journal of the American Statistical Association 110.512 (2015): 1479-1490.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linearDL">linearDL</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>k0 = 5
p = 20
n = 50

lambda = matrix(rnorm(p*k0, 0, 0.01), ncol = k0)
lambda[sample.int(p, 40, replace = TRUE) +
         p*(sample.int(k0, 40, replace = TRUE)-1)] = rnorm(40, 0, 1)
lambda[1:7, 1] = rnorm(7, 2, 0.5)
lambda[8:14, 2] = rnorm(7, -2, 0.5)
lambda[15:20, 3] = rnorm(6, 2, 0.5)
lambda[,4] = rnorm(p, 0, 0.5)
lambda[,5] = rnorm(p, 0, 0.5)
plotmat(varimax(lambda)[[1]])

X = matrix(rnorm(n*k0),n,k0)%*%t(lambda) + matrix(rnorm(n*p), n, p)

out = linearMGSP(X = X, nrun = 1000, burn = 500)
</code></pre>

<hr>
<h2 id='linearMGSP'>
Sample Bayesian linear infinite factor models with the Multiplicative Gamma Shrinkage Prior
</h2><span id='topic+linearMGSP'></span>

<h3>Description</h3>

<p>Perform Bayesian factor analysis by sampling the posterior distribution of parameters in a factor model with the Multiplicative Gamma Shrinkage Prior of Bhattacharya and Dunson
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linearMGSP(X, nrun, burn, thin = 1, prop = 1, 
epsilon = 1e-3, kinit = NULL, adapt = TRUE, 
output = c("covMean", "covSamples", "factSamples",
"sigSamples", "numFactors"), verbose = TRUE, 
dump = FALSE, filename = "samps.Rds", buffer = 10000,
augment = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linearMGSP_+3A_x">X</code></td>
<td>
<p>Data matrix (n x p)</p>
</td></tr>
<tr><td><code id="linearMGSP_+3A_nrun">nrun</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code id="linearMGSP_+3A_burn">burn</code></td>
<td>
<p>burn-in period</p>
</td></tr>
<tr><td><code id="linearMGSP_+3A_thin">thin</code></td>
<td>
<p>thinning interval</p>
</td></tr>
<tr><td><code id="linearMGSP_+3A_prop">prop</code></td>
<td>
<p>proportion of elements in each column less than epsilon in magnitude cutoff</p>
</td></tr>
<tr><td><code id="linearMGSP_+3A_epsilon">epsilon</code></td>
<td>
<p>tolerance</p>
</td></tr>
<tr><td><code id="linearMGSP_+3A_kinit">kinit</code></td>
<td>
<p>initial value for the number of factors</p>
</td></tr>
<tr><td><code id="linearMGSP_+3A_adapt">adapt</code></td>
<td>
<p>logical. Whether or not to adapt number of factors across sampling</p>
</td></tr>
<tr><td><code id="linearMGSP_+3A_output">output</code></td>
<td>
<p>output type, a vector including some of: c(&quot;covMean&quot;, &quot;covSamples&quot;, &quot;factSamples&quot;, &quot;sigSamples&quot;, &quot;numFactors&quot;)</p>
</td></tr>
<tr><td><code id="linearMGSP_+3A_verbose">verbose</code></td>
<td>
<p>logical. Show progress bar?</p>
</td></tr>
<tr><td><code id="linearMGSP_+3A_dump">dump</code></td>
<td>
<p>logical. Save output object during sampling?</p>
</td></tr>
<tr><td><code id="linearMGSP_+3A_filename">filename</code></td>
<td>
<p>if dump, filename for output</p>
</td></tr>
<tr><td><code id="linearMGSP_+3A_buffer">buffer</code></td>
<td>
<p>if dump, frequency of saving</p>
</td></tr>
<tr><td><code id="linearMGSP_+3A_augment">augment</code></td>
<td>
<p>additional sampling steps as an expression</p>
</td></tr>
</table>


<h3>Value</h3>

<p>some of:
</p>
<table>
<tr><td><code>covMean</code></td>
<td>
<p>X covariance posterior mean</p>
</td></tr>
<tr><td><code>omegaSamps</code></td>
<td>
<p>X covariance posterior samples</p>
</td></tr>
<tr><td><code>lambdaSamps</code></td>
<td>
<p>Posterior factor loadings samples (rotationally ambiguous)</p>
</td></tr>
<tr><td><code>etaSamps</code></td>
<td>
<p>Posterior factor samples (rotationally ambiguous)</p>
</td></tr>
<tr><td><code>sigmaSamps</code></td>
<td>
<p>Posterior marginal variance samples (see notation in Bhattacharya and Dunson (2011))</p>
</td></tr>
<tr><td><code>numFacts</code></td>
<td>
<p>Number of factors for each iteration</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Evan Poworoznek
</p>


<h3>References</h3>

<p>Bhattacharya, Anirban, and David B. Dunson. &quot;Sparse Bayesian infinite factor models.&quot; Biometrika (2011): 291-306.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linearDL">linearDL</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>k0 = 5
p = 20
n = 50

lambda = matrix(rnorm(p*k0, 0, 0.01), ncol = k0)
lambda[sample.int(p, 40, replace = TRUE) +
         p*(sample.int(k0, 40, replace = TRUE)-1)] = rnorm(40, 0, 1)
lambda[1:7, 1] = rnorm(7, 2, 0.5)
lambda[8:14, 2] = rnorm(7, -2, 0.5)
lambda[15:20, 3] = rnorm(6, 2, 0.5)
lambda[,4] = rnorm(p, 0, 0.5)
lambda[,5] = rnorm(p, 0, 0.5)
plotmat(varimax(lambda)[[1]])

X = matrix(rnorm(n*k0),n,k0)%*%t(lambda) + matrix(rnorm(n*p), n, p)

out = linearMGSP(X = X, nrun = 1000, burn = 500)
</code></pre>

<hr>
<h2 id='lmean'>
Average elements of a list
</h2><span id='topic+lmean'></span>

<h3>Description</h3>

<p>Convenience function to compute sample means when samples are stored as a list. List elements should be compatible with addition and scalar division (e.g. must share the same dimensions).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmean(list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lmean_+3A_list">list</code></td>
<td>
<p>a list of parameter samples</p>
</td></tr>
</table>


<h3>Value</h3>

<p>same type as a single element of the input list
</p>


<h3>Author(s)</h3>

<p>Evan Poworoznek
</p>


<h3>See Also</h3>

<p><code><a href="#topic+amean">amean</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>l = replicate(100, rnorm(10), simplify = FALSE)
lmean(l)
</code></pre>

<hr>
<h2 id='msf'>
Resolve label and sign switching in random matrix samples
</h2><span id='topic+msf'></span><span id='topic+msfOUT'></span><span id='topic+aplr'></span>

<h3>Description</h3>

<p>The msf() function performs column-based matching of a matrix to a pivot to resolve rotational ambiguity remaining after the application of an orthogonalisation procedure on a list of Bayesian matrix samples. The msfOUT() and aplr() functions perform this same matching but instead of returning aligned samples as does msf(), msfOUT outputs the list of permutations and sign switches needed for alignment and aplr outputs a list of matrices permuted and re-signed by msfOUT() output. msfOUT() and aplr() are used in jointRot(). These functions are written in C++ and may crash the R session if passed inappropriate input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>msf(lambda, pivot)

msfOUT(lambda, pivot)

aplr(matr, perm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="msf_+3A_lambda">lambda</code></td>
<td>
<p>matrix to be aligned, named for a factor loadings matrix as in the Bhattacharya and Dunson 2011 notation</p>
</td></tr>
<tr><td><code id="msf_+3A_pivot">pivot</code></td>
<td>
<p>matrix to align with which to align lambda</p>
</td></tr>
<tr><td><code id="msf_+3A_matr">matr</code></td>
<td>
<p>a matrix to apply permutations to</p>
</td></tr>
<tr><td><code id="msf_+3A_perm">perm</code></td>
<td>
<p>a (possibly signed) permutation order for the matr matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>see the examples for suggested usage of msf and jointRot() for suggested usage of msfOUT() and aplr().
</p>


<h3>Author(s)</h3>

<p>Evan Poworoznek
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jointRot">jointRot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lambda = diag(10)[,sample(10)] + 0.001
pivot = diag(10)
msf(lambda, pivot)

# fast implementation for a list of samples
k0 = 5
p = 20
n = 100

lambda = matrix(rnorm(p*k0, 0, 0.01), ncol = k0)
lambda[sample.int(p, 40, replace = TRUE) +
         p*(sample.int(k0, 40, replace = TRUE)-1)] = rnorm(40, 0, 1)
lambda[1:7, 1] = rnorm(7, 2, 0.5)
lambda[8:14, 2] = rnorm(7, -2, 0.5)
lambda[15:20, 3] = rnorm(6, 2, 0.5)
lambda[,4] = rnorm(p, 0, 0.5)
lambda[,5] = rnorm(p, 0, 0.5)
plotmat(varimax(lambda)[[1]])

X = matrix(rnorm(n*k0),n,k0)%*%t(lambda) + matrix(rnorm(n*p), n, p)

out = linearMGSP(X = X, nrun = 1000, burn = 500, adapt = FALSE)

vari = lapply(out$lambdaSamps, varimax)
loads = lapply(vari, `[[`, 1)

norms = sapply(loads, norm, "2")
pivot = loads[order(norms)][[250]]

aligned = lapply(loads, msf, pivot)
plotmat(summat(aligned))
</code></pre>

<hr>
<h2 id='plotmat'>
Plot a matrix
</h2><span id='topic+plotmat'></span>

<h3>Description</h3>

<p>Plot an image of a matrix using ggplot2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotmat(mat, color = "green", title = NULL, args = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotmat_+3A_mat">mat</code></td>
<td>
<p>Matrix to plot</p>
</td></tr>
<tr><td><code id="plotmat_+3A_color">color</code></td>
<td>
<p>Color scheme: &quot;green&quot;, &quot;red&quot;, or &quot;wes&quot;</p>
</td></tr>
<tr><td><code id="plotmat_+3A_title">title</code></td>
<td>
<p>optional plot title</p>
</td></tr>
<tr><td><code id="plotmat_+3A_args">args</code></td>
<td>
<p>optional additional ggplot arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sends image to active graphics device or outputs a ggplot object
</p>


<h3>Note</h3>

<p>Uses reshape2::melt which may be aliased with reshape::melt
</p>


<h3>Author(s)</h3>

<p>Evan Poworoznek
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat = diag(1:9 - 5)
plotmat(mat)
</code></pre>

<hr>
<h2 id='Sampler+20Components'>
Sampler Components
</h2><span id='topic+del_mg'></span><span id='topic+eta_int'></span><span id='topic+eta_lin'></span><span id='topic+lam_lin'></span><span id='topic+mh'></span><span id='topic+phi_dl'></span><span id='topic+phi_int'></span><span id='topic+plm_dl'></span><span id='topic+plm_mg'></span><span id='topic+psi_dl'></span><span id='topic+psi_int'></span><span id='topic+psi_mg'></span><span id='topic+rgig'></span><span id='topic+rig'></span><span id='topic+sig_lin'></span><span id='topic+ssy_int'></span><span id='topic+tau_dl'></span>

<h3>Description</h3>

<p>These are the component full conditional or Metropolis-Hastings updates coded in C++ used in the samplers in this package. The functions follow naming conventions based on their greek letter notation in their respective original papers, cited below, and the paper they come from. Here _mg refers to a component of the Multiplicative Gamma Shrinkage prior of Bhattacharya and Dunson 2011, _dl refers to a component of the Dirichlet-Laplace shrinkage prior of Bhattacharya et al., _lin refers to a component of a linear factor model as in Bhattacharya and Dunson 2011, and _int refers to a component of a factor model with 2-way interactions as in Ferrari and Dunson 2020.
</p>


<h3>Author(s)</h3>

<p>Evan Poworoznek
</p>


<h3>References</h3>

<p>Bhattacharya, Anirban, and David B. Dunson. &quot;Sparse Bayesian infinite factor models.&quot; Biometrika (2011): 291-306.
</p>
<p>Bhattacharya, Anirban, et al. &quot;Dirichlet-Laplace priors for optimal shrinkage.&quot; Journal of the American Statistical Association 110.512 (2015): 1479-1490.
</p>
<p>Ferrari, Federico, and David B. Dunson. &quot;Bayesian Factor Analysis for Inference on Interactions.&quot; arXiv preprint arXiv:1904.11603 (2019).
</p>

<hr>
<h2 id='summat'>
Summarise a matrix from posterior samples
</h2><span id='topic+summat'></span>

<h3>Description</h3>

<p>Provide a summary matrix from a list of matrix-valued parameter samples, returning the mean value for each element with 0 not included in its quantile-based posterior credible interval, and 0 for each element for which 0 is included in its posterior CI.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summat(list, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summat_+3A_list">list</code></td>
<td>
<p>list of matrix valued parameter samples of the same dimensions</p>
</td></tr>
<tr><td><code id="summat_+3A_alpha">alpha</code></td>
<td>
<p>type I error probability</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix
</p>


<h3>Author(s)</h3>

<p>Evan Poworoznek
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lmean">lmean</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>list = replicate(1000, matrix(rnorm(100), ncol = 10) + 
                 10*diag(10), simplify = FALSE)
lmean(list)
summat(list)
plotmat(summat(list))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
